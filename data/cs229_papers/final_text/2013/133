
assisted legion
sean






working legion parallel programming targets
hpc uncommon
thousands thousands memories require
millions threads execution challenges exist programming
lumped
writing functionally
achieving ideally
writing
parallel programming simultaneously express
goals legion separates concerns providing
determines logical structures placed
guarantee effort
introduce functional bugs operational semantics designed invariant functional happens equivalent sequential execution programs
simplifying functional debugging effort
unfortunately debugging issues remains profiling sequential
execution particularly gross
bottlenecks parallel threads cores
resources straight gather profiling nearly impossible

bottlenecks cause bottleneck seem
suited assistance
profiling runs
categorize instances execution environments runtime
characterize instances
execution environment categorization representative instances
debugging medians instances dont outliers
primary readable descriptions
programmer understand operating modes
strongest influence modes

brief legion runtimes profiling


rationale behind
covered
conversion readable



synthetic

concludes brief





legion runtime
entry
inst

proc

finish

identifier
numeric identifier
identifier processor
started executing
finished executing

execution legion runtime topology
processor processor cpu gpu
processor resides
instances resources



definition

profiling potentially
desirable
require profiling runtime



grouped xd captures qualitative

captures quantitative processor
processor
processor
runtime overlap instances
execution resources


proc




proc proc overlap



overlap absolute instances

resources


tries
resources instances






modeled separately legion come shapes

splitting instances
isnt listed indicated
suffice
obvious complicated tries characterize instances
rejected reasons complicated introduces


fidistribution runtimes instances























execution microseconds

runtime instances

importantly succinctly
programmer unlikely satisfy requirement
fits
trying complicated hypothesized
conceptually amounts piecewise approximation
polynomials
submodels estimator runtime instances
introduce





xd















mj

tj xc

constraint diagonal
driven desire avoid yield programmer





submodels initializes exactly
desired
trying knee
minor maximize
incorporates
qi allowing write
















xd












pc
xd mz pl xc








pc xc xd mz pl xc
qi









qi pc
qi pl
xd



xx

qi













gaussians









squares



fithe posterior
submodels gaussians ignoring diagonal
squares
minor optimize
optimizing
asynchronous seemed stable






starting
submodels
covered
estimations listing
helpful
discriminative excluding
listed percentages exclude individually
cumulatively dump favor
strongest listing
listing synthetic























dx











sigma

var

dx


















dx



effectiveness analyzed synthetic
choosing easier visualize
intended synthetic plotted
spatial xs os scatter
xs os distinct
runtimes synthetic bottom
intended figures side
reliably learns separating os
xs perfect job separating os
gaussians

allowed goodness
gets excluding
dont isnt






































































































execution




























































































execution microseconds

synthetic



legion
dont
half
knee bottom half separation
managed gpus
cpus managed highlight operating modes
cpus possibly numa
unable spike runtimes milliseconds
distinguish






optimistic assist legion improvements
wed execution
obvious operations instructions
cache misses creation cover
kind runtime
possibly operating modes
runtime logarithmic
logarithmic probably cover wide runtimes observe
interactions multiplicative runtime easier logarithmic

descriptions arent wed
synthetic
strongly discriminative
dependent
wed favor descriptions
descriptions
dependent seeds worth spending
agglomerative submodels ms spike
programmer doesnt








