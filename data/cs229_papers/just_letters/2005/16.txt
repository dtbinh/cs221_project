re learning to walk  adding force feedback control to the quadruped robot
mark quilling

andy gooden
in collaboration with
honglak lee

andrew ng

yirong shen

introduction 
currently  the quadruped robot plans a sequence of foot movements and joint angles using a two level
hierarchical decomposition of the task  the high level planner plans a sequence of target foot placements
to achieve a desired goal location from a given start location  the high level controller is implemented
using a value function approximation and beam search  the low level controller plans a series of joint
angles to execute the series of footsteps planned by the high level controller  it is the job of the low level
controller to keep the robot balanced  prevent obstacle collision  and execute the desired footstep  the low
level controller is implemented using a policy search whose policy parameters were learned  currently 
there is no feedback in the control path  and a successful journey of the quadruped is highly dependant on
the accuracy of the simulation model  our project will add force sensors to each of the quadrupeds feet 
close the control loop  learn new parameters for the low level controllers optimal policy  and implement
on line trajectory planning 
current control system 
the low level controller uses a potential field to determine the optimal trajectory to accomplish each
individual footstep  the controller uses the following potential field desription 

u t   t   uti   u g     u tg  uti   u g     u ts  uti   u g     u tc   t     u to   t  
g

s

c

o

where u t      u t      u t      and u t    represent potentials for the goal  floor  center of gravity  and
body orientation  respectively  at each instant of time  the robot computes the negative gradient of the
potential function evaluated at the current state 

g t   j    w j u t  t   uti   u g  

the robot then tries to execute the change in joint angles given by g t   j   this  however  does not guarantee
that the three stationary feet do not move  to prevent this  g  is projected into the null space of   
t  j

t

which is a matrix whose nine columns are the gradients of the state variables with respect to the x y z
coordinates of each of the three feet  this null space projection prevents the x y z coordinates of the
stationary feet from changing  while still allowing the desired trajectory to make progress down the
negative gradient of the potential field  this process is all executed off line and the joint angles are written
to a file to be later played back  open loop  to the robot  there are many problems that can arise from
assuming the environment is static and that we can approximate it exactly  the new control will
incorporate force feedback to remedy the problem of uncertain terrain  new control system 
the new closed loop control takes in to account the feedback obtained from the force sensors  by using
this information we are able to better navigate uncertain terrain correcting for unknown parameters of the
environment  by introducing real world information  through a potential function  we are able to increase
the confidence the robot has about the current state  only a few things where modified from the above
algorithm 
   we now write the control action directly to the robot instead of a file 
   update current state reads in the current force reading from the sensor via a micro controller 
   we added a potential function proportional to the force 
with these three added capabilities we are able to do all the control decisions online in real time and have
access to data from the real world 

fiserial communication 
the previous system used serial control code on a pc for one way communication with the robot  the
code would initialize the port  initialize the robot  read the pre computed joints txt file  and control the oneway flow of servo commands to the robot 
in the new system  we ported the robot initialization code over to linux and integrated it with the low level
controller  additionally  we added new two way communication code so that the force sensor data could
be read and sent to the force potential functions  finally  we implemented real time control  such that the
next optimal joint trajectory was computed after receiving the packaged force sensor data from the robot
via serial 
microcontroller and force sensor circuit
to drive the force sensing resistors  fsrs   we created a bank of opamps  the figure below shows our
circuit  the circuit converted the fsr readings to a voltage and sent the signals to the microcontroller 

the microcontroller is a    pin basic atom pro with a d capabilities  the purpose it serves is to
continuously monitor the sensors  package the data and ship it up to the computer  it uses a basic serial
communication protocol to communicate with the linux box  each sensors reading is packaged into   bytes
before sending 
force feedback using estimated desired force 
the approach we took combined the calculation of the desired force at the end of a task with the estimate of
the force gradient with respect to each state  by using the foot placement and center of gravity we are able
to predict a force that the robot should feel on each foot  for every task we calculate a desired goal force
which we use to create an attractive potential around  call this fd goal  for every iteration of the algorithm
 each task contains many  we also calculate the desired force on the robots feet at that instance of time
based on the current state  call this fd  the next step of the algorithm is to calculate the gradient  to do this
we perturb the current state and re calculate the desired force on each foot  call this fd prime  we then
estimate the gradient  f  by the difference between fd and fd prime  our potential function for the force
is then constructed as follows 

c    fd   goal    fa   c     f  

 

here c  and c  are the learned parameters from the pegasus search algorithm and fa is the actual force
reading from the sensors 
fd goal 
the calculation of this force is done once each time we start moving a new foot  the force balance
equations we solve are as follows 

fiwcg x   x 
wcg     y
y   

 w    

x 
y 
 

x     f     x  f   
y     f      y   f   
    f     f   

here w is the mass of the robot  cg is the center of gravity cartesian co ordinates   xi  yi  i           are the
x and y co ordinates of the stationary feet  fi i           are the forces on the stationary feet   x   y   and f 
are the co ordinates of the moving foot and force of the moving foot after task completion  as one may
have noticed the force balance equations have   unknowns with   equations  thus the system is over
determined and has infinite solutions  to remedy this problem we assign a force to the moving foot 
f contact  which is a small contact force that the robot should feel on the moving foot before
continuing to the next task  the above linear equations can then be solved using a simple matrix inverse 
the solutions to this equation  including the assigned moving foot force  are fd goal  a few downfalls to
this calculation is that we dont have access to the cg location at the end of a task so we assume it remains
about constant throughout the maneuver  this is clearly wrong but seems to work ok  our calculations
using the above equations are pretty accurate and provide a concrete goal for the robot to aim for 
f 
this quantity is what actively changes throughout the gradient calculation  it is composed of two
components  fd the instantaneous calculated force of the current state  if our calculations and sensors
where perfect then this would be fa   and fd prime the perturbed force  lets first discuss fd  the reason
we use our calculated force instead of the sensor readings is due to the following facts     the sensors we
are using are very inaccurate     when we try to estimate the gradient we want to be able to base our
calculations in the same reference frame i e  use the same equations for both perturbed and un perturbed
state  so for every gradient calculation we calculate fd based on the current state of the robot and use this
quantity for every perturbed state  fd is calculated in the same way as fd goal except here  because the
foot is moving  we set f  to be zero  now we perturb the current state one component at time calculating
the value of the potential field at that new state  when one component of the state is perturbed we
recalculate the total state and again perform a force calculation  the difference between this force and the
fd is f  we can think of f as the amount of force we expect to get if we move a certain component of the
state be a small increment  this quanity is what tells the robot the direction in which to move to achieve
the desired force 
c  and c  
these are the learned parameters from the search  the constant c  is the relative weight with
respect to the other terms in the potential function  it basically says how important force is compared to our
other objectives  the constant c  is the force gain  we use this to amplify the direction of f because in
many cases f may be very small and almost have no effect on the potential  by amplifying the change we
are able to induce a larger variation in the potential over the different perturbations 
a nice way to think of our potential function is that we have some desired force at the bottom of some
quadratic bowl  fa represents a point along one of the sides of the bowl  and f is a direction from fa  so
by trying to minimize the above quadratic function we are trying to find f which points towards the goal 
if our only task was to maintain a given force distribution over the legs   see results section  then this
potential would be ideal  but because the robots state is dynamically changing over time we have other
goals that become more important  when a given leg is trying to reach a goal configuration there are other
factors that contribute to the potential function  this is where learning the weights will determine the best
relative weighting between the different potentials 
problems 
we encountered quite a few problems with the implementation of the force potential  due to very noisy
sensors and inaccurate state description we had a hard time getting the force to converge to the desired 
sensors 

fithe sensors we used where very insensitive to low forces  due to this fact we almost had a binary model
of the contact force and the above potential was almost overkill for this model  on top of the insensitivity
these force sensors gave very sporadic measurements where the force would jump from high to low values
and visa versa  in theory with accurate  low noise  force readings the above potential will work very well 
but in our experiments we had a lot of problems getting a good response from the robot because small
movements would cause large force changes and thus create a large potential 
force calculations 
in all the force calculations we assume a stable robot as well as the state that we think we are in is the
actual real world state  because there is really no feedback from the real world  besides the force  we often
have a very inaccurate representation of the world  because we rely on this representation to calculate the
expected forces on the feet we often get very inaccurate force predictions  with a perfect model of the
world  our instantaneous force predictions should equal the measured force  although these calculations
were inaccurate we were still able to achieve decent performance from the robot 
results 
   
   
   
   
force 
force 
force 
force 

   
  
  
  
  
 
 

 

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

           

force measurements  trying to maintain balance on flat surface
the above plots are of the robot trying to maintain a equal force distribution over all feet in different
situations  the first plot the robot is on a tilted surface and tries to reach and equilibrium state  because of
the inaccuracy of the sensors the robot often never finds this state due to of on nature of the sensors 
through observation we see the robot reacting to different situations and trying to adapt by changing its
position  the next figure the robot is on a flat ground and is simply trying to maintain equal force on each
foot  the results are a little better but the sensors still make it quite difficult to get a clear picture of the
force converging to the goal  when we tried to collect data of the walking robot we had a lot of trouble
collecting reliable  representative data sets  they were basically noise  we where able to successfully
navigate a multi level surface using force feedback  see video  and gain insight that our algorithm was
working correctly  one thing is clear from all the test and trial we conducted  we need better sensors 
given the time constraints of the quarter by the time we realized the sensors where not adequate for the
robot it was too late 
conclusion 
in conclusion our project turned out quite well and we were able to demonstrate its performance
on real hardware  the algorithm used was sufficient to produce the desired response but there are quite a
few more improvements that need to be made  first is we need to get better  more accurate sensors on the
feet  this follows directly from the fact that our potential function relies strongly on accurate force
measurements that are smooth and continuous  as of now a simple algorithm  such as moving the target
down in the z direction until the moving foot touches would provide almost the same results  what we
where interested in was providing a dynamic response which would not only adapt to uncertain terrains but
stabilize the robot throughout its task  one thing that our potential function relies heavily on is the

fiaccuracy of both force calculations and measurements  the first we have a pretty accurate set of equations
for force under normal circumstances  but if the robot is in an unstable state or has not centered correctly
then we may assign negative numbers to the force calculations  although these circumstances are rare 
once they happen the robot is in big trouble  one of the most frequent times this happened was when we
are transitioning from centering to moving and the cg is just on the border of the supporting triangle 
because we assign a zero desired force to the moving foot  the robot in turn thinks it need to apply a
negative force to a leg to stabilize itselfthis is clearly wrong  another time we may calculate negative
force is when we are assign the goal force to each leg  because  at the moment  we dont have access to the
goal cg we assume the cg remains about constant throughout the maneuver  this can easily be remedied by
having the high level planner spit out the desired cg as well as the feet positions  the algorithm should be
modified to recognize situations where it may see negative force calculations and adapt accordingly  in
closing the we successfully designed a closed loop force feedback controller for the quadruped robot and
successfully demonstrated it performance 
appendix  cool pictures

fi