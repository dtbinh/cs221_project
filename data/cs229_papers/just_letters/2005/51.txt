user authentication based on behavioral
mouse dynamics biometrics

chee hyung yoon
department of computer science
stanford university
stanford  ca      
chyoon cs stanford edu

daniel donghyun kim
department of computer science
stanford university
stanford  ca      
blueagle cs stanford edu

abstract
in this machine learning application  we try to complement the existing security system
by providing another layer of user authentication protection by applying behavioral
biometrics on user mouse dynamics  first we collect the users mouse dynamics data
through an application that monitors the mouse movement for the specified duration 
we extract out certain signature characteristics in the patterns of a users mouse
dynamics  such as double clicking speed  movement velocity and acceleration per
direction  using machine learning techniques  we build a naive bayes model of a users
mouse dynamics  then it is possible to detect unauthorized users by finding anomalies
in the measured mouse dynamics and to prevent the intruder from further accessing the
system  although there has been considerable amount of literature on fingerprinting or
keystroke biometrics  behavioral biometrics based on mouse dynamics has not been
very successful so far  different from the tried methods  we used slightly more detailed
features and machine learning techniques such as unsupervised learning for anomaly
detection 

 

mouse dynamics

using the winnt xp application we implemented using c  and win   assembly  we collect the
information on mouse actions generated as a result of user interaction with a graphical user interface by
installing a global mouse hook on the user system  we consulted     detecting computer intrusions
using behavioral biometrics by awad e  a  issa traore in defining three classes of action  i e   mouse
movement  point and click  and drag   drop and in selecting the features to include  the collected data
include movement speed  pixels second  over traveled distance  pixels  per defined action  mouse
movement speed and acceleration per movement direction  and distribution of double click speed 
   

movement speed over traveled distance per defined action

mouse movement is simply defined as the user moving mouse from point a to point b without pressing
any mouse button  one movement ends when there is no mouse input for the pre defined duration  point
and click is nearly identical to mouse movement  but ends with the user pressing any mouse button 
drag   drop is defined as pressing a button followed by movement and release of the button  we
measure the speed of mouse movement at each time slice of    ms and the distance at each action  since
speed varies much even for specific distance  think that when you start to move a mouse  the speed is
about    but when you are at middle of movement  the speed would reach the maximum   each users
unique pattern can be found by focusing more on the data points near the maximum values  this is
discussed in more detail in the data analysis section  our collected data show that the
speed over distance patterns are somewhat different for each action 

fi   

movement speed per direction of movement

we measure the speed of mouse movement at each time slice of    ms along with the angle of movement 
although the movement speed somewhat depends on what application the user is running  there is a
noticeably detectable pattern that is unique to each user  this unique pattern can be found by focusing
more on the data points near the maximum values by almost same reason of     
   

acceleration per direction of movement

this is identical to the movement speed per direction except that we measure acceleration instead of the
movement speed  note that the data set includes both negative and positive values since acceleration is a
vector 
   

distribution of double click speed

based on our collected data  users have fairly unique and stable distribution in their double click speed or
the time duration between two clicks in a double click action  more precisely 

 
   

data analysis and machine learning
discretization

after collecting enough data for a user  we pre process the data using our program implemented in java 
mainly  we discretize the very fine discrete variables the angle radian value  movement speed  and
acceleration  in the increments of       distance traveled is also discretized in the increments of    
pixels so that the resulting curve is affected less by the noise in the data  double clinking speed is also
discretized in the increments of      sec  these increment values were chosen manually after trying a
number of different values 
   

   percentile

our initial assumption was that the unique characteristics of a users mouse movement speed per
direction lay in the distribution of different values  as we analyzed the data  however  we found that the
values near the maximal value are more stable over different sessions and also unique over different users 
as mentioned in the mouse dynamics section  mouse moving is generally composed of acceleration 
constant speed moving  and deceleration  thus maximal speed tends to represent users unique
characteristic  we also believe that this was the case because whereas the distribution of different values
may get affected by what type of application the user is using  the maximal speed values represent the
users behavioral character  therefore  we extracted the high    percentile values at different angles as
the signature vector of each user  this approach is also resilient to the outliers  which are considered just
noises from a few jerky movements  figure   is the result of taking    percentile values from the
movement speed by movement angle data set 
 
data points
    percentile points

 

angle of movement  rad 

 

 

 

  

  

  

  

 

 

 

 

 
  
  
speed  pixels   sec 

  

  

  

  

fifigure   movement speed by movement angle and    percentile values
   

naive bayes

in order to detect anomalies  we used the naive bayes assumption such that the values of movement
speed or acceleration by angle are independent given the identity of the user  furthermore  we assumed
gaussian distribution of the    percentile values and used this for computing the likelihood of a test set
value  given the identity of the user  thus  our log likelihood is computed as
l    log  p   x   i     y      log 
i

i

   y  i    x   i      
 
exp  
  
   
  

the value of standard deviation was hand tuned for different features to guarantee a large difference in
the resulting likelihood value depending on whether it was the data from the same user  this approach
gave us much better results compared to simply comparing vector distance over the datasets  figure  
shows the movement speed by traveled distance values of three different users including the data over
two different sessions for one user  the signature line for different users is readily observed from the
figure  table   shows the calculated log likelihood values where the mean values are taken from session
  of user a and tested against the other three test sets 
   
user a  session  
user a  session  
user b
user c

   

traveled distance  pixels 

   
   
   
   
   
   
   
 

 

   

 

   
 
   
 
   
 
average movement speed  pixels second 

   

 

figure   traveled distance by movement speed when performing point and click

against user a  session  
user a  session  

      

user b

        

user c

        

user d

         

table   log likelihood for different user identities
in processing the acceleration data  we observed a strong symmetry between the positive  acceleration 
and negative  deceleration  over all users  thus  we decided to use the absolute value of the acceleration
for simplicity  figure   shows the signature acceleration vectors of selected users  here  the blue and red
curves represent the signature acceleration vector of the same user over two different sessions  the
overlap between the two curves is easy to observe 
figure   is the signature double click speed distribution vectors 

fi   
user a  session  
user a  session  
user b
user c

acceleration  pixels seconds seconds 

 

   

 

   

 

   

 
  

  

  

  

 
 
angle of acceleration  rad 

 

 

 

figure   acceleration by angle for selected users
  
user a  session  
user a  sessoin  
user b
user c

  

double click speed     ms 

  
  
  
  
  
  
  
 
 

 

    

   

    
   
probability

    

   

    

figure   double click speed distribution
   

final weight adjustments and anomaly detection

after computing the six log likelihoods for different features  we calculated the linear combination of the
log likelihood values to get the final valuation  the weights for each likelihood was adjusted manually  it
could have been done using some automatic technique such as gradient descent  but our dataset contained
only about a dozen datasets from different sessions  which was not sufficient for using an automatic
convergence algorithm 
after determining the weights  a threshold value for the final log likelihood value is set for each user by
running some training session values against the trained session value so that each training sets final
valuation is higher than the threshold  if a test set value is higher than the threshold  the set is
distinguished as legitimate user  and the set is distinguished as an intruder  otherwise  if the user tends to
be very stable over multiple sessions  the threshold value is set higher and the detection is likely to be
more accurate unless the user deviates much from her profile  in which case a false positive occurs  on

fithe other hand  if the user tends to show unsteady signature vectors over multiple sessions  the threshold
value will be set lower in order to prevent frequent false warnings 
in order to confirm the performance of our algorithm  we tested the trained model against the data sets not
used in the training process  both from the same user over a different session and from other users
including some new users  although the limited number of training sets and test sets does not allow us to
draw ultimate conclusion on the performance  the algorithm worked surprisingly well on our test sets  it
was able to correctly classify all the test sets fed to it  we plan to further collect large set of data and run
more rigorous tests 
another aspect we would like to see improvement on in the future is the duration of data collection time 
current span of an hour to two hours is probably too long to be actually deployed for security extension 
as an intruder may harm or exploit the system in much shorter duration 

 
   

i m p l e m ent a t i o n
data collection

data collection program mouserecorder exe was written in c  and win   assembly code  using
winnt xp low level global mouse hook support  it stores the features described in mouse dynamics
section in four different files 
   

data pre processing

data pre processing program rounder java was implementing using java      it reads in the files
generated by the data collection program and performs discretization on the dataset 
   

data analysis and learning

data analysis was done exclusively in matlab      extractsig m performs    percentile value
extractions  sorting and smoothing of the data using linear interpolation  likelihood m performs the
log likelihood calculation described in section     

 

experiments

we collected data from eight different subjects over multiple sessions by distributing the
mouserecorder exe application  each subject ran the program in background for several hours  and
each session generated four data files each ranging in size from    kb to  mb  in general  having larger
data file resulted in smoother and more stable signature vectors and final likelihood value differed more
from the likelihood obtained from the other test sets 
references
    ahmed awad e  a  and issa traore        detecting computer intrusions using behavioral biometrics 
university of victoria 

fi