cs    final project

title  fault tolerant architecture for machine learning
applications
larkhoon leem  suid          

   introduction
scaling of semiconductor transistors in integrated
circuits has been major thrust for speed and density
improvement of modern microprocessors  at the
same time  ever decreasing semiconductor size
makes it more difficult and expensive to make
microprocessors strictly reliable 
if we look around it is not so hard to find systems
that allow errors  those systems take advantage of
error detection and error correction mechanism to
live up with errors  an example of systems is
telecommunication  noise is inevitable in data
transmission  efficient encoding and decoding
schemes have been invented to fight with noise
errors  encoding and decoding schemes use
iterative and probabilistic algorithms  iterative
characteristics provide good error detection and
error correction points  probabilistic nature of
output result allows relaxed requirement for
accuracy of computation 
machine learning applications shares many
similarities
with
telecommunication
figure   machine learning  
probabilistic applications
decoding encoding  estimation application and
categorization algorithms are iterative and
probabilistic  if we can take advantage of these characteristics of machine learning we
can build an error resilient computer architecture which is cost effective in terms of
testing and power consumption 
in this project report i would like to propose new way of computing for fault tolerant
machine learning application  background information will be given in section    section
  will explain experiments which have been conducted in this project  in section   
architectural design proposal based on experiments will be given 

fi   fault tolerant microprocessor design  ibm g 
reliability has been important issue in microprocessor design and it has been integrated
into chip design  in this section  extra design that was put into commercial
microprocessor such as ibm powerpc g  will be given  it will give us some sense on
how much extra circuit and computing power has to be spent at this node device
fabrication technology 
the ibm g  processor makes extensive use of fault tolerance techniques to recover from
transient faults that constitute the majority of hardware faults  fault tolerance is provided
for the processor  memory and i o systems  traditional redundancy methods are used to
implement fault tolerance in the i o subsystem  there are multiple paths from the
processor to the i o devices  they can be dynamically switched in case of errors  error
checking is provided at interface to prevent errors from propagating into the system 
g  pipeline includes i unit and e unit  i unit is responsible for instruction fetch  decode
and generating necessary addresses  etc  e unit executes instruction and updates
machine state  both i unit and e unit are duplicated respectively  each compare the
results with duplicated results  a divergence between two instances indicates an error 
register unit  r unit  stores checkpointed machine state to facilitate rollback recovery 
also  registers are protected by an error correcting code and r unit is updated whenever
e units generate identical results 
all writes to the l  cache are also written through to the l  cache  which can works as
backup copy of the l  contents  l  cache  the main memory and buses connecting
processor with l  cache are protected with error correcting code ecc  
special logic detects the same failures happening repeatedly in the same storage  such
repeated failures are taken to indicate a permanent fault and affected cache line is
permanently retired 
extra circuit and techniques mentioned here is just samples of the extra features in g   if
we can get rid of circuit space and power consumed in fault tolerant circuits as these 
microprocessor design can be more power efficient 

   experiment setup

figure   experiment setup

fiexperiments were conducted to see how machine learning application are behaving in
errors  k means clustering was chosen as target application  k means clustering is simple
but robust categorization algorithm which was covered in this class 
experiment setup consists of two parts  one is error injection handler and the other is
memory access monitor  error injection handler injects error to machine state  it
simulates errors in arithmetic unit and memory  as shown in fig    timer interrupt calls
error injection code  error injection code randomly chose a register to inject error  bit
location bit       of this register is chosen and this bit is flipped 
second part of experiment setup is memory access monitor  kernel code is modified to
generate dtlb miss at every dtlb access  by this way  we can monitor what memory
address is used for all the memory access during program execution 
experiment was conducted on xilinx virtexii
pro xup board  virtexii pro fpga chip has
embedded powerpc     embedded processors 
although no change can be made to fpga
hardware  there were several advantages that
served the purpose of this project better than
software simulation  first  there is no os process
running on fpga embedded processor  only
minimum exception handler code is all the
process that runs on the processor other than user
application  having os process on the same chip
is disadvantageous as error can be injected to os
process and cause system crash  error resiliency
of os was out of scope of this project and i
decided to focus on error resiliency of machine
learning application only 

figure   xilinx xup board

   proposed microprocessor architecture and project
goal
as proposed system has relaxed reliability criterion  error rate will be much higher than
conventional processors  at processor crash or loss  and unacceptable accuracy due to
errors  we should rollback and restart  convergence check code at the end point of each
iterations of machine learning application will serve as error detection point  if error is
detected  iteration result is dropped and machine state will rolled back to previous
iteration 
because of roll back and restart  the number of iteration will increase compared to
conventional processor  fig   shows imaginary test result of proposed system  multiple
tests have been conducted sequentially  proposed system shows varying number of
iteration counts at each tests when reference conventional system  show constant number
of iteration  this is because of unpredictability of program errors  thus goal of this
project has to minimize the additional iteration counts due to roll back  if this overhead is
higher than power saving from relaxing reliability criterion  this project would be
meaningless 

fifigure   reference vs  proposed system iteration count

   experiments
    array element access
in order to see how memory addresses are corrupted  simple memory access for loop is
tested 

figure   memory address trace with error inejction
memory address is supposed to increase as read line  note that it seems like constant
because axis is in log scale   actual address trace show random jumps at multiple points 
memory address of array element is sum of base address and index value  if error is
injected to a base register  subsequent memory address becomes garbage  all the memory
access should be monitored and if it digresses from start and end address of array  it
should be considered as error  there could be ways to correct this error but to make

fiproposed architecture simple  i chose to roll back and restart whenever memory bound
checking fails 

    error injection to general purpose registers

r 

r 

r 

r 

r 

r 

r 

r 

r 

r 

r  

figure   error injection to gpr
errors were injected to each general purpose registers  some registers could not survive
one error  they were r  stack pointer   r  return address   etc  these registers are all
related to function calls  if sp is corrupted  location where return address was stored can
not be correctly retrieved  thus  if stack pointer gets corrupted  program will jump to
wrong place and application will fail sooner or later 
two measures can be taken to enhance stack pointer reliability  function calls needs to
be inlined so that there will be very few function calls  secondly program counter value
should be monitored  if pc value goes outside where text segment sits  error should be
declared and program should restart 

    error injection to special purpose registers
errors were injected to special purpose registers as well  similar to what we saw in
gprs  there were special purpose registers which could not survive single errors  they
were lr branch target  return address   ctr branch target  loop counter  

filr

ctr

xer
ccr 
pid
dac 
figure   error injection to spr

dear

cr 

    convergence test
each iteration in machine learning application performs convergence test at its end  if we
can find monotonically increasing decreasing feature  it could tells whether output of that
iteration was acceptable or not 
in k means clustering  total sum of distance between each data and its centroid should
monotonically decrease  fig    it will serve as a valuable information to examine the
accuracy of that iteration  if total sum shows oscillation or non monotonic variation as in
fig    result of iteration should be dropped 

figure   convergence test without error

fifigure   convergence test with error

    overall performance
iteration counts were measured at different error rates  with current design  overhead is
less than       in order to achieve good performance  overhead should be reduced down
to less than     
at certain error rate  iteration count rose very quickly and proposed architecture could not
be used for computation 
iter 
count with
error 
iter 
count without
error 

error rate
figure    overall performance result

   conclusion
from this project  we were able to confirm error resiliency in machine learning
applications such as k means clustering  we could deduce what are the requirements for
proposed relaxed reliability microprocessor architecture  they are i  error resiliency in
application algorithm  ii  memory bound checking of data code  iii  low overhead
restart roll back  iv  convergence checking for error detection 

fi