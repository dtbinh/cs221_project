os fingerprint classification using a support vector machine
david fifield
december         

abstract

of fields  and collects the responses into a data structure called an os fingerprint  this is a fingerprint of
linux        

an evaluation of using a support vector machine
 svm  to classify operating system fingerprints in
the nmap security scanner  in solving a simplified
version of operating system classification  the svm
got marginally more accurate results than nmaps
built in classifier 

 

seq sp cc gcd   isr cd ti z ci z ii i ts   
ops o  m b st  nw  o  m b st  nw  o  m b nnt  nw 
 o  m b st  nw  o  m b st  nw  o  m b st   
win w    a  w    a  w    a  w    a  w    a  w    a  
ecn r y df y t    w   d  o m b nnsnw  cc y q  
t  r y df y t    s o a s  f as rd   q  
t  r n 
t  r y df y t    w   a  s o a s  f as o m b st  nw  rd   q  
t  r y df y t    w   s a a z f r o  rd   q  
t  r y df y t    w   s z a s  f ar o  rd   q  
t  r y df y t    w   s a a z f r o  rd   q  
t  r y df y t    w   s z a s  f ar o  rd   q  
u  r y df n t    ipl     un   ripl g rid g ripck g ruck g rud g 
ie r y dfi n t    cd s 

introduction

remote operating system detection  os detection  is
any way of finding out the operating system system
of a network host through analysis of network traffic  it has implications for network security  including network inventory  vulnerability detection  and
exploit tailoring  os detection is a feature of various
network security programs including nmap  p f  and
sinfp 
there are many ways of doing os detection  this
paper is concerned only with active  low level detection  active means that the scanner is free to
send packets and not just sniff passively  low level
means that it operates at the level of ip  tcp  and
icmp  and not  for example  by reading banners from
application services 
os detection is possible because of implementation
differences in tcp ip stacks  os programmers are
free to set some values within certain limits  systems
differ in how they handle unexpected or uncommon
conditions  implementation errors are sometimes visible in network traffic  os detection seeks to elicit as
many of these distinguishing characteristics as possible  nmap sends over a dozen tcp  udp  and icmp
probes  with various valid and invalid combinations

the format of the fingerprint and the meaning of its
fields are described fully in      a dotted notation is
used to refer to tests within each line  in the above
fingerprint it is the case that ecn w   d   meaning
that the tcp window size in the response to the
explicit congestion notification probe was  x  d  
compare with a fingerprint of windows xp sp  
seq sp     gcd   isr   b ti i ii i ss s ts   
ops o  m b nw nnt  nns o  m b nw nnt  nns o  m b nw nnt  
 o  m b nw nnt  nns o  m b nw nnt  nns o  m b nnt  nns 
win w  ffff w  ffff w  ffff w  ffff w  ffff w  ffff 
ecn r y df y tg    w ffff o m b nw nns cc n q  
t  r y df y tg    s o a s  f as rd   q  
t  r y df n tg    w   s z a s f ar o  rd   q  
t  r y df y tg    w ffff s o a s  f as o m b nw nnt  nns rd   q  
t  r y df n tg    w   s a a o f r o  rd   q  
u  r n 
ie r y dfi s tg    cd z 

see that in this case ecn w ffff  a few of other
differences are in the tcp options  ops o  through
ops o  and t  o   dont fragment flags    df   and
explicit congestion notification status  ecn cc   windows responded to the t  probe while linux did not 
 

fi 

also the windows fingerprint is missing lines t   t  
and t  because the host lacked a closed port 

the nmap os database is built from submissions by
users  when nmap fails to identify an operating system it prints a fingerprint and asks the user  if the
os is known  to submit it to an online form along
with a classification  the submissions are integrated
into the database a few times per year  the raw data
for this experiment were        submissions that had
already been integrated into the nmap database between december      and april       the training
set   and       that were received between april     
and october      but had not been integrated  the
testing set  
nmaps second generation database was introduced in june       so these are almost all the submissions available  it is necessary to go far into the
past to counteract the bias that otherwise exists with
the submission system  once an operating system is
reliably matched  it becomes less likely to be submitted in the future 
many submissions have to be discarded because
they are of low quality or have uncertain identification  all submissions marked by nmap as being suspect  using the pseudo test scan g n  were removed 
during manual database integration  submissions for
common operating systems must include the output
of winver exe or uname or equivalent  to check that
the submitter actually has access to the operating
system ostensibly being identified  a robotic classification program did pattern matching against this
uname output to put submissions into one of seven os
families  those that could not be positively identified
were discarded  a human doing database integration
will discard on the order of     of submissions  and
this process is supposed to be even more conservative 
these seven os families were chosen because    
they are common  and     they are easily identified by
their uname strings  linux  windows  freebsd  darwin  mac os x   sunos  solaris   openbsd  and
aix 
as will be discussed in the section called procedure  errors  i e   mistaken submissions  in the training set were only removed as they became apparent 
but every submission in the testing set was carefully
checked by hand  by cross checking against the nmap

this paper is not about the technical details of
os detection probes and the assembly of fingerprints 
rather  it is assumed that the fingerprints are given
and the only remaining task is to classify them  the
focus is on converting a fingerprint to a feature vector and then classifying it using a support vector machine 
os identification is harder than it sounds  in an
ideal world  every operating system would have just
one fingerprint  distinguishable from those of all others  in actuality  one os can have dozens of fingerprints  even at the granularity of a linux kernel micro revision  let also a windows service pack  there
are at least two reasons for this  some tests are sensitive to network conditions and  especially  packetmangling routers  and fingerprints are affected by os
configuration  nmaps current second generation os
database has a simple pattern language that allows
for some variation in fingerprints      but even so it
contains over       fingerprints for     os families
from aix to zynos  of these      are linux     
are windows  and       are miscellaneous embedded operating systems of hardware devices  the
size of this database and its maintenance costs are
one reason for investigating whether machine learning can do the same job 

 

data sources

previous work

sarraute and burroni     used a hierarchy of neural networks and nmaps older first generation os
database to do first coarse  then fine os classification 
zaid aiman     outlined a plan to implement something similar for nmaps second generation database 
joao medeiros et al      used a neural network and
the second generation nmap database to do classification and build a map of operating system similarity 
they used euclidean distance of feature vectors as a
measure of fingerprint similarity 
 

fihandle these as class    members of this class 
seq ti  seq ci  seq ii 
seq ts  u  ruck  ie cd 

database  to remove all errors 
after this winnowing process  the data broke down
as follows 
os
  training   testing
linux
     
   
windows
     
  
freebsd
   
  
darwin
   
 
sunos
   
 
openbsd
  
 
aix
  
 
total
     
   

 

   set  these are marked by the presence or absence of letters from a finite set  t  f through
t  f  tcp flags  are examples using the set
euaprsf  members of this class 
t          f  t          q  ecn q 
   tcp options  ops o  through ops o  as well
as t  o through t  o encode tcp options as
strings like m b st  nw   members of this class 
ops o          t         o  ecn o 

feature selection

each test is converted to a fixed size numeric vector
as follows  the concatenation of all these becomes
the overall feature vector  numeric values map directly to integers 
t  t   
     
enumerations are converted to a sequence of     indicators  one for each possible value  according to the
advice in      the only exceptions are the y n enumerations  which become a single indicator 
u  ripck g           
u  ripck z           
u  ripck i           
t  r n
    
t  r y
    
enumeration numeric tests get categorical indicators
followed by one element for the numeric value  when
an enumerated value is used  the spot for the numeric
data is    when a numeric value is used  all the
categorical indicators are   
ie cd g
             
ie cd s
             
ie cd o
             
ie cd   
              
tcp flags are represented by an indicator for each
flag 
t  f as
                      
t  f r
                      
tcp options  because of their more complex structure  were ignored   see continuing work  
whenever a test was missing  all its elements were
assigned    the concatenation of all these subvectors leads to a feature vector of     elements 

an nmap fingerprint consists of up to     tests     
they can be of five different classes 
   numeric  encoded in hexadecimal  these are
mostly fixed size positive integers taken directly
from packet contents  like t  t  t  probe ttl  
members of this class 
t          t  ecn t  u  t  ie t 
t          tg  ecn tg  u  tg  ie tg 
t         w  win w          ecn w 
t          rd  seq sp  seq gcd  seq isr 
u  ipl  u  un  u  ripl  u  rid 
   enumeration  one of a finite set of symbolic
values  examples are t  r  responsiveness to
t  probe   which may be either y or n  and
u  ripck  integrity of ip checksum   which may
be g  z  or i  members of this class 
t          r  ecn r  u  r  ie r 
t          df  ecn df  u  df 
t          a  t          s 
seq ss  ecn cc  ie dfi  u  ripck  u  rud 
   enumeration or numeric  these may be like either class   or class    an example is ie cd
 icmp response code   which may be any of z 
s  or o  or a number like    if none of the enumeration values fit  u  ripl and u  rid would
appear to be in this class because they may be
numeric or have the value g  but g only stands
for a specific number so it is more convenient to
 

fi 

procedure

using two dimensional vectors for binary features instead of one dimensional   accidentally  leaving out a
libsvm         is the support vector machine im  couple of tests  and artificially adjusting fingerprints
plementation used  the training of the svm went to correct a byte ordering bug present in older veraccording to the recommendations in      specifi  sions of nmap  the training and testing accuracy
cally  the training set was first converted to a set never dropped below     so these changes are likely
of feature vectors  the elements of each vector were not of much consequence   the byte order fix was
scaled to lie in the range         using the rbf kept  
kernel k x    x      exp   x   x         grid search
found good values of c and  using five fold cross
validation  all this is encapsulated in the easy py  
results
and grid py scripts that come with libsvm 
the feature vector and training set were refined the svm classified     of     testing examples corover eight iterations  after each of the first few itera  rectly          both errors were darwin misclassified
tions  each incorrectly classified submission from the as freebsd 
nmaps detection engine  taking the best match
training set was checked for plausibility by matching
it against the nmap database  the matching pro  and accepting any match at     confidence or more 
gram shows the ten closest matches and for common classified     of     correctly          the errors
operating systems all ten are usually variations of the were aix misclassified as an embedded messaging
same os family  it would be surprising  for example  server  aix as darwin  darwin as freebsd  and
for a linux result to be in the top ten for a windows windows as a wireless access point   there were also
fingerprint  submissions that appeared to be wrong    instances of linux classified as embedded  but
were excluded from later iterations     submissions on inspection all of these embedded devices do appear to run linux   if     or greater confidence is
were excluded in this way 
all       testing submissions were individually required of nmap  there is only one mistaken classification  aix as darwin  but    submissions have
checked for correctness     of these were excluded 
in a typical example of a submission that was man  no result at all  for a total accuracy of     in    
ually excluded  one submitter claimed that the op          
erating system was linux         however  when
cross checked using nmap  the nearest matches were

 

   
   
   
   
   

microsoft
microsoft
microsoft
microsoft
microsoft

windows
windows
windows
windows
windows

xp professional sp 
xp sp    sp 
xp sp 
xp sp 
server      sp 

continuing work

these results are promising  but it must be kept in
mind that this particular svm will do well only when
the operating system is known a priori to be in one
of the seven selected families  unlike nmaps matching algorithm  it will always return a result in one of
these families  even if the fingerprint is unlike anything seen before  a practical matching algorithm
will have to be aware of novel fingerprints and at
least avoid returning a very uncertain answer 
it is limiting to have to declare possible os matches
in advance as is done here  windows is unsatisfying
when the technology can reliably distinguish between
windows      sp  and windows xp sp   the
authors of     used a hierarchy of classifiers  so once

the submitter likely scanned the wrong machine by
mistake  or sent the classification of the scanning host
instead of the one being scanned 
after the final iteration  the svm correctly classified       of       training examples          training and cross validation of the final iteration took
about    minutes with easy py  experiments during the earlier iterations included using integers for
enumeration tests instead of categorical indicators 
 

fiwindows was known they could get a more specific
answer by turning to a specialized windows classifier 
even this doesnt answer for the many undocumented
embedded operating systems known only by the
hardware they run on  such as

networks  ieee conference on emerging technologies and factory automation         nmap
os database and artificial neural networks 
nmap dev mailing list         http   seclists 
org nmap dev      q     

polycom soundpoint     or     ip phone
w t web io thermometer model      
xerox workcentre pro c     printer
one possibility  as is done in      is to put all such
miscellaneous fingerprints into a single category 
tcp options are a great source of variation and
should be part of the feature vector  the references
show some ways of doing this 
the source code of the tools developed for
this project is at http   www bamsoftware com 
stanford cs     

references
    gordon fyodor lyon  nmap network scanning  chapter    remote os detection        
http   nmap org book osdetect html 
    chih chung chang and chih jen lin  libsvm 
a library for support vector machines  http   
www csie ntu edu tw cjlin libsvm 
    chih wei hsu  chih chung chang  and chihjen lin  a practical guide to support vector classification  http   www csie ntu edu 
tw cjlin papers guide guide pdf 
    carlos sarraute and javier burroni  using neural networks to improve classical operating
system fingerprinting techniques  electronic
journal of sadio vol     no     pp      
        http   www coresecurity com files 
attachments sarraute ejs pdf
    zaid aiman  ideas  nmap fingerprint analyzer  nmap dev mailing list         http   
seclists org nmap dev      q   
    joao medeiros et al  automating security tests
for industrial automation devices using neural
 

fi