mac malware detection via static file
structure analysis
elizabeth walkup
university of stanford
ewalkup stanford edu

i 

introduction

t is widely acknowledged in the security
community that the current signature based
approach to virus detection is no longer adequate  more recently  antivirus software has
been doing dynamic malicious behavior detection  while this is more effective  it is computationally expensive  so they cannot do very
much of it or the performance of the users
computer will suffer 
static executable analysis offers a possible
solution to the problems of dynamic analysis 
static analysis looks at the structures within
the executable that are necessary in order for
it to run  since these structures are mandated
by the file type  they cannot be removed  encrypted  although their code contents may be  
or obfuscated easily  also  because it simply
involves parsing structures  it is much less computationally expensive than dynamic analysis 
some research has already been done into static
executable analysis for windows portable executable  pe  files 
although mac malware  the general term
for malicious software  is not nearly as prolific
as those for windows  the number is steadily
increasing as macs gain a greater market share 
kaspersky has seen the amount of mac malware double in the last two years  and increase
by a factor of ten in the last four years      
yielding an exponential increase curve  of particular note  the last   or   years has seen a number of advanced persistent threat  apt  malware campaigns targeted specifically at macs 
researching tools to face these threats now ensures that we will be able to better handle the
increasing threat in the future 

i

ii 

dataset

malware samples were gathered from open
research sites like contagio    and virustotal     benign mach o files  for comparison 
were gathered from os x mavericks and opensource programs for os x  the samples themselves are mach o binary executable files  this
is the format of choice for os x programs 
though there are one or two other formats
used in older systems  for legal reasons  opensource malware repositories are hard to find 
so increasing the malware samples by any substantial amount beyond this is difficult 
the current data set consists of     malware
samples and      goodware  benign programs 
samples  this data was randomly divided into
a training set  roughly      and a testing set
 roughly       by number  the samples are
divided as follows 
training set

testing set

   
   

  
   

malware
goodware

iii 

features

the mach o features are pulled out of the
binaries using a python script that parses the
file structures  the information is then stored
in a sqlite database  since machine learning
was done using weka      another python script
converts the information in the database into
a weka supported format  the features are
diverse  some are strings  some are continuousvalued numbers  some are discrete numbers 
and some are boolean    or    

i 

structure features

the script pulls    structural features out of
the database  mostly continuous valued  size 

fibased statistics of various structures  there are
other structural features within the database
that could be used  but these were chosen to
maximize information gain while decreasing
model size  using only structural features  the
top model had a testing error of         
i   mach o file structure
mach o executables    have three main
parts  a mach header  load commands  and
data  the data section is made up of the actual
executable code  which can be compressed or
encrypted  so no features are gathered from
there  the mach header contains information
about the platform the executable was built for 
as well as the file type  dynamic library  etc  
the majority of the structural features come
from the load commands  these contain headers for each code segment in the data  as well as
information about import libraries and how to
load the file in memory  each segment header
also contains information about a substructure
within the segment called a section 

ii 

import features

every executable file imports files and libraries to use within its program  these cannot be encrypted  so their names can be extracted from the binary  however  there are
literally thousands of names that could be
present  which is not easy to incorporate into a
model  to compromise  feature selection was
performed on models built solely from import
features  and the top features were then incorporated back into the main set of features 
when these import features were added  the
testing error of the top model decreased from
        to          a nearly    improvement 

iii 

feature selection

two methods were used to trim features 
forward search selection and information gain
ranking  these two algorithms had many top
features in common  particularly when used
to choose import features  by combing the top
results from these two methods  thousands of
possible import features were reduced to   
dynamic library  dylib  imports and     function imports  combined with the    structural
features  there were     features for all of the
 

models  some of the top features are shown in
table   

iv 

models

for the sake of brevity  only the top five
models will be described  although over   
were tested 

i 

rotation forest

rotation forest    builds an ensemble  or
forest  of decision trees  in this case c    trees 
the feature set is split into k disjoint subsets 
in this case  k was     which corresponds to
roughly   features per set  for each classifier  principal component analysis  pca  is run
using the subset of features chosen  the coefficients found using pca are put into a sparse
rotation matrix  which is rearranged to match
the chosen features  this new matrix multiplied by the training data comprises the model 
to classify a new data point  the confidence for
each individual model is calculated  and the
output class is the one with the highest confidence  this model had a confidence factor of
     

ii 

random forest

random forest     similar to rotation forest  is an ensemble of different decision tree
models  however  instead of using a confidence measure  the different models vote on
the output class  the training sets for these
models are chosen randomly  but with the
same distribution  in this case  there were ten
decision tree models and the models used the
full feature set 

iii 

part

part    is a rule based algorithm  the data
set is divided into several new sets  a partial
pruned c    decision tree is built based on
each set  the leaf of this tree with the largest
data coverage  meaning it classifies the most
instances  is made into a rule  a leaf must
cover at least two instances to be considered
for a rule 

iv 

lmt

lmt    stands for logistic model tree  this
is a basic decision tree except that instead of

fitable    top ten features by informaton gain

dylibs

functions

structural

mbukernel
mbuinstrument
qtcore
wlmstrings
mbustrings
microsoftcomponentplugin
qtgui
libstdc  
qtnetwork
netlib

 exit
 system
 kcfhttpversion   
 umask
 fread
 sysctlnametomib
 cfreadstreamcreateforhttprequest
 ioregistryentryfrompath
 gmtime
 sysctl

num imports
std segsize
file type
avg segsize
std segvmsize
min segsize
avg r 
avg segvmsize
std secsize
avg secalign

having classes at the leaf nodes  it has logistic regression functions  a node must cover
at least fifteen instances to have child nodes 
the functions at the leaf nodes model the class
probability 
pr   g   j  x   x    

e fj   x 
j

k   e fk   x 
j

fj      



j

v v

 malware and goodware have the same
distribution of load com  mand sizes

   

 malware is more likely to use java libraries

vvt

ibk

ibk    is an instance based learning implementation of k nearest neighbors  in this case
k     for each data point  it calculates a similarity for each cluster  that data point is then
assigned to the cluster with the highest similarity 

v 

 malware tends to have more segments
than goodware and use more varied segment flags

   

where vt is a subset of all the features  i s
are weights  and k is the number of possible
feature values 

v 

 goodware tends to import more libraries
than malware

results

many different supervised learning algorithms were evaluated to see which one could
classify the data the best  the algorithms were
trained on the full     attributes  the top ten
results are listed in table    a false positive is
a goodware sample that was classified as malware  and a false negative is a malware sample
that was classified as goodware 
some interesting facts that can be gleaned
from the data itself 

 malware is more likely to use http
stream functions  probably for control exfiltration 
 goodware uses more memory access controls

vi 

discussion

the ensemble methods had the best performance  perhaps due to the complex nature of
the input features or the varied data set  since
all of the import features were nominal features  decision tree models were particularly
well suited for classification 
the fact that the testing error can be reduced to a few percent means that there are
actually tangible differences in static structures
between malware and goodware  this was expected going into the project because substantial results have been produced using a similar
approach with windows portable executable
 pe  files and malware 
 

fitable    top ten supervised learning algorithms results

algorithm
rotation forest
random forest
part
lmt
ibk
smo
ft tree
j   c    tree
regression

training error

test error

false positive

false negative

roc area

       
       
       
       
  
       
       
       
       

       
       
       
       
       
       
       
       
       

    
     
     
     
     
    
    
    
    

     
     
     
     
     
     
     
     
     

     
    
     
    
     
     
     
    
     

however  the results are not quite what
would be considered  production level  for malware detection  as a general rule  the goal is to
keep false positives below        and false negatives below     at best  among these models
the false positive was    and the false negative was       false positives are especially
important to keep low  because customers will
not use an antivirus that blocks their legitimate
programs 
the models built in this project are still useful as triaging tools  in cybersecurity  incident
response teams at businesses are swamped
with email security alerts every day  especially
with regards to suspicious email attachments 
running these models on the applicable executables can allow the incident response team
to focus only on those that have a high probability of being malware  so the conclusion is
that static analysis shows substantial promise 
even if it is not quite refined enough to be
deployed as a standalone antivirus 

vii 

future work

the one major roadblock to this project is
a lack of malware samples  the     samples
here took weeks to obtain  whereas  by contrast 
thousands of goodware samples can be gathered in a day  expanding the sample set would
probably cut down on the generalization error  one possible approach would be to catch
malware using a honeypot setup  though that
often comes with its own set of legal issues 
there are also more features that can be
 

used within the mach o files  adding more
features could possibly increase the accuracy
of the classification  but it comes at the price of
a larger model 
this static analysis approach could also be
used to try and classify malware into  families   for example  all polymorphic flashback
executables   which is an open problem in the
security industry 

references
   

j  rodriguez and l  kuncheva   rotation forest  a new classifier ensemble
method   ieee trans  pattern analysis and
machine intelligence   vol      no      pp 
           oct       

   

leo breiman   random forests   university of california  jan       

   

eibe frank and ian h  witten   generating accurate rulesets without global optimization   university of waikato 

   

n  landwehr  m  hall  and e  frank   logistic model trees     th european conference on machine learning  jun       

   

d  aha  d  kibler  and m  albert 
 instance based learning algorithms  
machine learning   vol     pp              

   

 os x abi mach o file format
reference   mac developer library 
https   developer apple com library mac
 documentation developertools conceptual machoruntime index html 

fi   

   

 weka   the university of waikato 
http   www cs waikato ac nz ml weka  

 contagio malware dump   mila 
http   contagiodump blogspot com  

   

 virustotal  
https   www virustotal com  

      mac
malware  
kaspersky
press
release
     
https   press kaspersky com files         macthreats png 

 

fi