cs    project   best buy recommendation system
nikhil rajendra  anubhav dewan  mehmet can colakoglu

introduction
recommender systems have become an area of active research  they are especially important in the ecommerce industry because they help increase revenues and improve customer experience  a lot of
different techniques have been explored for different kind of recommender systems based on the
desired objective and the data that is available to base the recommendations on  in this project we work
on developing a simple recommender system based on search query and click data  in particular  we are
focusing on recommending xbox games based on a given query  this project originated as a kaggle 
competition and is closed right now  we have implemented different techniques for building
recommendation systems to this problem and compare how they perform and observe their strengths
and weaknesses 

data
the dataset available through the competition website consists of the query search and click data  the
data is from the bestbuy mobile website consisting of clicks in the category of xbox games  this data
contains         different clicks  the attributes provided as part of the training click data were user id 
search query  product  sku  id clicked from the query  along with additional attributes of click and query
times   they also provided an xml file with different attributes for each xbox game available with
bestbuy  this data was difficult to process because it required parsing this xml file and had large
amount of natural text and large numbers of overlapping and redundant product features  we chose to
focus on getting insights based on the search and click data since it allowed us to explore different
methods to develop recommender systems and compare their performance 

preprocessing
string manipulation
the most important feature of the data is the queries since they are the only user inputs provided  being
user inputs  queries exhibit noise which is generated by spelling mistakes  repeated words and
excess redundant characters  to get rid of this noise  we implemented detailed pre processing steps 
   all non alphanumeric characters  except spaces  were removed
   all queries were reduced to lower case
   each query was sorted with respect to the words
   repeated words were removed
   spaces were removed
   all generic queries with the phrases xbox      and xbox     were gathered into a single 
standard query
following the above steps for each of the         queries  we ended up with        unique queries 
the clicks and corresponding product data was aggregated accordingly  this preprocessing is also done
on the test set queries 
before  batman  arkham city
after  arkhambatmancity

 

http   www kaggle com c acm sf chapter hackathon small

fispell checking with clustering
although the results from the pre processing method detailed above resulted in significant reduction of
the number of queries  we explored if we could improve even further  we implemented a clustering
method to group queries  specifically  we used k means clustering with the levenshtein  distance as the
similarity metric 
this approach was implemented successfully and was particularly useful for grouping together longer
queries which are close to each other  the closeness of two reasonably long queries is most likely a
result of spelling mistakes and with this method  we were able to group these queries together and
reduce the number of unique queries from        to       however there were a few issues 
   the choice of number of clusters k is not straightforward and we relied on trial and error in
choosing k  this might be alleviated by using other  hierarchical clustering methods but they also
require a threshold for termination which is again not straightforward to choose 
   for longer queries  this method works very well however for short queries  results arent as
good  the reason for this is that the difference between short queries such as rise and riot
are small enough for them to be clustered together by the algorithm 
due to these issues  we decided not to include this spell checking method into our recommendation
system at this time 
sample cluster 
batman arkham city
batman arhkam city
batman  arkhum city
batman arkhamn city
batman arkman city
batman arlham city
batmam arkham city
batman arkam island

batman arkham city
batman arkhham city
batman arkaham city
batman asrkham city
batman arcyum city
batman arkhem city
batman arkuam city
batman arklum city

batmsn arkham city
batman arkhum city
batmart  arkham city
batman archam city
batman arkhym city
batman adkham city
batman arklym city
batman arkam city  

batman arkhan city
batman arkham cita
batman arkham cuty
batman arkyam city
baseman arkham city
batman arckam city
batman arkahm city
batman arkham cith

methodology
notation
we represent the query  item relationship with the following notation 
 

 

collaborative filtering
for recommender engines collaborative filtering is used to identify different users which are similar to a
particular user  then these similar users are used to recommend products that were popular with them 
in the problem we work on  the notion of users is very weak because we have no additional information
about the users except for the products they clicked on  also the number of clicks per user is very low
 we have         users and        queries in the training data   hence we decided to use collaborative
filtering replacing the notion of user by search queries and try to identify similar queries to each query in
the training set  we also use the notion of finding similar items to what was searched for using the new
query and recommend popular items among similar items  this is sometimes called as item to item
collaborative filtering   these two approaches are highlighted below 

 

levenshtein distance between two strings is the minimum number of single character edits required to transform
one to the other

fiquery based collaborative filtering
this is used to make recommendations based on similar queries used before in the training set  for
finding similar queries based on products clicked on  we use the query item matrix  to measure the
similarity between different queries  we used cosine similarity between the corresponding rows of
    

    

 
   

this has one problem since the similarity between different queries is heavily influenced by very popular
items and the less popular items become less relevant  to counter this we used the inverse frequency
approach where each column of
was scaled by the total number of clicks for that item in the training
set  using this  a query to query similarity matrix was constructed for the training set queries 
    
queries come from an infinite space and given a new query in the test set  it may not map to a query in
the training set  preprocessing of queries was useful to reduce the number of unique queries we had in
the training set  given a new query in the test set  we find the closest matching query using normalized
levenshtein distance 
based on collaborative filtering  we should use similar queries and recommend top   items
corresponding to these similar queries that were clicked on the most  to achieve this we calculate the
weighted sum of all
using
as the weights 
 

 

after calculating this vector we recommend the top   skus with the highest combined score 
item to item collaborative filtering
another way of using collaborative filtering is to identify items that are similar to the item a new query is
searching for  this approach is useful in many e commerce applications because it allows retailers to
recommend products in different categories based on the different items that have been purchased 
this has also been shown to have better scalability for online recommendations compared to user based
collaborative filtering  in our problem we find out item to item similarity by using
  each row of this matrix corresponds to an sku and this matrix stores the number of times the sku
was clicked based on each query  the item to item similarity matrix is then constructed 
    
unlike many recommender systems we dont have data of different products that a user bought and we
need to map a new test query to an existing sku item  we use a roundabout way to do this  given a new
query we find the closest query in the training set  we know the products that were clicked on through
the query  we use the weighted average of the item similarity rows corresponding to the clicked skus to
get a combined similarity vector corresponding to the new query 
 



 

we recommend top   items with the highest combined similarity score 

clustering
cluster models are also widely used in recommender systems  normally  a recommendation engine
would cluster users based on their browsing or purchasing information  and recommend items to a user
based on other users in the same cluster  in our case  the user related information is too sparse for that
to be truly useful as mentioned above  therefore we use query information instead of user information
for the clustering implementation  besides clustering queries  we also implemented an item clustering
method  following are the two approaches 

fiquery clustering
cosine similarity as explained above is used as the similarity metric and k means clustering is used as the
clustering algorithm  here  the choice of k  the number of clusters  is an important one  since we have a
product catalog of      items  not all of them clicked   the number of clusters is chosen to be
considerably smaller than that but still large enough to reflect the diversity of the queries  k       
after that  running the algorithm until convergence creates the query clusters 
for a new query in the test set  we match it to the closest query in the training set  since we have
clustered the queries  this match also matches the new query to a cluster  finally  we output the   top
skus in that cluster  sku popularity is based on the aggregated clicks for the clusters 
sample cluster 
     battfield 
     battlefield bad conpany   
     battfield bad company   
     battle field bad company 
     batlefeild bad company 
     battlefield on sale 
     battlefield bad   
     battlefeild   
     battledielsd bad company   
     bad meets evil album

item clustering
it is also possible to use clustering methods on items in the product catalogue 
constitutes an item 
query matrix  we can use k means clustering with cosine similarity between item rows to cluster the
items  same issues regarding the choice of k are valid in this case and are handled similarly to the query
clustering  k       running the algorithm until convergence creates item clusters 
for a new query in the test set  we use string distance to match it to the closest query in the training set 
let
  we identify all the
 
  be the corresponding row of   for all
corresponding skus  we select the sku with the maximum number of clicks and recommend the top  
skus in its cluster  if we find less than   items in the cluster  the most popular skus are recommended in
the remaining slot 
sample cluster 
    bioshock   limited edition   xbox
   
    bioshock     xbox    
    bioshock infinite   xbox    

evaluation metric
mean average precision  map   this metric was specified by kaggle  it is one of the standard
information retrieval methods to evaluate ranked list of documents corresponding to a given
query  average precision is the average of the precision of k retrieved documents  mean average
precision is the mean of average precision over all queries  in our problem we recommend   products
for a given query  in the test set labels  we have   product corresponding to each query  thus average
precision is defined as follows 
 




firesults and conclusions
we compare results of the four approaches suggested and a benchmark approach from the
competition  the map scores are shown in the table below 
   

      

      

      

   
   

item to item coll  filtering

      

   

query to query coll  filtering

   

item clustering

   

query clustering

   

      

default

   
 

in the benchmark    most popular skus are recommended  irrespective of the query  all our methods
perform significantly better than the benchmark  collaborative filtering for queries and items performs
similarly and query based clustering performs slightly better  item based clustering doesnt perform as
well  this happens primarily since we were not able get good clustering based on items 

future considerations
in the data preprocessing step we explored an approach for spell checking based on clustering but were
not able to integrate that into the final recommendations  such a step would be helpful in reducing the
number of unique training queries 
given a new query we find the closest query in the training set based on modified string distance and
base our models on that  for some queries  this does not work so well because we are not able to find a
suitably close query  preprocessed   hence there is scope for trying different approaches to model the
query strings  based on keywords  and try to make recommendations using the given sku attributes  for
these cases  
also we developed   models  query and item cf and query clustering  which perform reasonably well 
there is scope of developing a composite algorithm that uses the techniques from all the methods and
can provide a better performance 

references
 linden  g   smith  b     york  j          amazon  com recommendations  item to item
collaborative filtering  internet computing  ieee              
 horvitz  e          principles and applications of continual computation  artificial intelligence 
                
 schafer  j   frankowski  d   herlocker  j     sen  s          collaborative filtering recommender
systems  the adaptive web          
 chen  a  y  a     mcleod  d          collaborative filtering for information recommendation
systems  encyclopedia of data warehousing and mining  idea group 
 zhu  m          recall  precision and average precision  department of statistics and actuarial
science  university of waterloo  waterloo 

fi