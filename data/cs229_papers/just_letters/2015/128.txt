playing tetris with genetic algorithms
jason lewis
abstractthe classic video game tetris can be represented as
an optimization problem that can be maximized to produce an
efficient player  in this problem  a player picks moves by
generating future game states and computing a weighted sum of
features for each state  the player picks the move for the state
with the largest weighted sum  the values for these weights are
optimized through a genetic algorithm  after running the genetic
algorithm for    generations using a feature set of size     one of
the best resulting players achieved an average game length of
        moves over    trials 
index termsgenetic algorithm  machine learning  tetris 

i  introduction
tetris is the classic falling blocks video game invented by
russian programmer alexey pajitnov in       this immensely
popular and deceptively simple game is well suited to being
played by a computer player  an individual state of tetris is
easy to represent as  the current game score  the type of tetris
piece  or tetromino  will be dropped next  and a    by   
binary grid representing the currently occupied spaces in the
tetris board  from any possible state in tetris  there is a finite
number of possible moves for a human or computer player to
consider  figure   below shows the seven tetromino types
along with the size of the move set for each tetromino in a
constrained version of tetris that will be described later 

fig     the move set sizes of the seven tetris tetromino types

if tetris is represented as an optimization problem  a
variety of optimization methods can be applied to generate
computer players that play tetris efficiently  one such method
is a genetic algorithm  which is an approach to optimization
that simulates the process of evolution  this paper describes a
framework for applying a genetic algorithm to an optimization
problem for tetris and discusses the results achieved from
running the algorithm 
all code used to produce the results in this paper  including
the tetris implementation  the tetris visualizer  and the genetic
algorithm framework  was all written in java specifically for
this project  the tetris visualizer uses the java based graphical
environment processing 
ii  related works
the concept of applying a genetic algorithm to tetris has
been explored by previous publications  all previous works i
have found follow a similar approach of using a feature set to
evaluate feature vectors for future tetris states and using

genetic algorithms to find the best weights on these features 
the three previous works i found each has some minor
differences  landom flom and cliff robinson       
represented their weights as bit vectors where each generation
can result in random bits being flipped  niko bhm  gabriella
kkai  and stefan mandl        experimented with different
rating functions  including a linear function that is just the dot
product of the weights and features and an exponential function
that takes some exponential of each feature value  david
rollinson and glenn wagner        used nelder mead
optimization on the best weight vectors from the genetic
algorithm to get better results 
in all three of these works  the success of a tetris player
was measured by how many lines are cleared before losing the
game  as opposed to how many points are scored by clearing
more lines at a time  since the number of lines cleared is
roughly proportional to the number of moves  this metric
measures how resilient the player is to losing  but does not
measure how well the player can clear multiple lines at a time 
there have also been some previous works related to the
computability of good moves in tetris  breukelaar  r  et al 
       have shown in tetris is hard  even to approximate that
in the offline version of tetris  where the player knows the
entire finite tetromino sequence in advance  maximizing the
number of rows cleared or pieces placed before losing is nphard 
john brzustowski        analyzes different variations of
tetris to determine if it is possible to win at tetris through
some strategy that is guaranteed to continue playing
indefinitely  he shows that some variations of tetris are
winnable  such as a game that only produces i and o
tetrominos  however  the standard version of tetris that
includes all seven possible tetromino types is not winnable 
specifically  any version of tetris that produces both the s and
z tetrominos is not winnable and will eventually end 
keeping in mind that tetris is not winnable and the offline
version of tetris is incredibly hard to optimize  a tetris player
playing an online version of tetris  where only the next move s
tetromino is known  can only hope to keep the game going as
long as possible while consistently making reasonable moves 
iii  genetic algorithms
before explaining the tetris optimization problem in detail 
here is a brief summary of genetic algorithms 
like other optimization methods  a genetic algorithm
attempt to find inputs from an input space that maximizes the

fioutput of some function  in a genetic algorithm  this function is
referred to as the fitness function which is used to evaluate the
fitness of a candidate input  the algorithm maintains a
population of n candidates  where n typically ranges from
hundreds to thousands 
at the beginning of each iteration of the algorithm  the
current population represents a generation of candidates which
is used to generate a new population of n candidates for the
next generation  each generation is numbered according to
how many iterations of the algorithm have been run 
generation   is initialized with n random inputs from the
input space  a new generation is created by probabilistically
selecting candidates from the current generation  the
probability of a candidate being selected is proportional to its
fitness evaluated by the fitness function 
after all candidates are evaluated  the candidate selection
takes place in three phases  which each contributes a certain
percentage of candidates to the next generation 
 selection  candidates are selected and added to the
next generation unchanged
 mutation  candidates are selected and each
candidate s input is slightly altered in some way before
being added to the next generation
 crossover  candidate pairs are selected and then each
pair of corresponding inputs are combined in some
way to form a new candidate to be added to the next
generation
iv  tetris implementation
the implementation of tetris used for this problem uses a
board of size    by    and allows the player to see the type of
tetromino that will be used in the next turn as well as the
current turn  for simplicity  a player s move only consists of the
rotation of the tetromino and the column on the board from
which to drop the tetromino  disallowing any additional
movements that are normally allowed in tetris  this results in
the move set sizes seen in figure   
in this implementation  there is no timed element where the
tetromino slowly falls down the board  as it is assumed that a
computer player will pick moves very quickly  this
assumption does not consider the possibility of instant gravity
of tetrominos possible in some versions of tetris  which can
make some moves impossible 
if at least one line is cleared after a move  the game score
increases by a certain amount    points are awarded for   line 
  points for   lines     points for   lines  and    points for  
lines  also known as a tetris   this scoring system is
proportionally equivalent to the one used in the nintendo
entertainment system version of tetris 

fig     example visualization of a tetris state 

v  tetris optimization problem
in the tetris optimization problem used in this paper  a
candidate tetris player is characterized by a fixed weight
vector in m  where m is the number of features used to
characterize a state of tetris  given the current state of the
tetris game which contains the next two tetrominos to use  the
player generates every possible future state of tetris after the
next two turns  for each future state  a feature vector is
computed  a particular state is scored as the dot product of the
state s feature vector and the player s weight vector  the move
that is chosen is the one that produces the largest possible dot
product two moves from now 
the abilities of a tetris player can be judged two factors 
 making a large number of moves without losing
 scoring points as efficiently as possible by clearing
multiple lines at a time  preferably by making tetrises
both of these factors are captured by the fitness function 
which is the average number of points per move that a player
earns during a game of tetris  to prevent games for continuing
exceedingly long  the game can be stopped after a specific
maximum number of moves  if the player gets a game over
before reaching that many moves  the average score is still
computed as the number of points earned divided by the
maximum number of moves  this penalizes players that lose
early by a factor of how early the player loses 
another metric used to understand the abilities of a player
is the player s score efficiency  which is the percentage of the
maximum possible score the player earns  a player that only
clears lines through tetrises will earn    points every    moves 
making   the highest possible average score per move  so  a
player s efficiency is measured as its average score per move
divided by   and represented as a percentage 
the tetromino sequence generated for a game is controlled
by a random number generator that when given an initial
random seed will always generate the same sequence  to
prevent overfitting on a particular sequence of tetrominos  the

firandom seed is different for each generation  all players within
a generation are playing with the same tetromino sequence so
that the candidate selection process is fair 
vi  feature set
the feature set used in the tetris optimization problem is
possibly the most significant factor in generating a player that
reliably plays long games with high efficiency  the previous
works mentioned earlier provided many ideas for possible
features  i combined some of these ideas from previous works
along with some of my own ideas into a list of    potential
features  not all of these features are beneficial to the feature
set  so forward search was used to select only the features that
are shown to increase the potential efficiency of a player when
added to the feature set 
the problem was slightly altered for the forward search to
prevent overfitting on the weight vectors and tetromino
sequences  the values for each weight are constrained to the
range          each potential feature set was evaluated over   
tetris games with different random seeds  to speed up the
computation  the maximum number of moves per game was
limited to     and the players only consider tetris states one
move in advance instead of two moves  starting with the best
weights found in the previous iteration of forward search  the
addition of a new feature involves finding the best weight for
the new feature from a fixed set of values  then finding a local
optimum in the neighborhood of the resulting weight vector 

to explain these features  the terms i use are defined as 
 block  a filled space on the board
 hole  an unfilled space that is located below a filled
space
 pit  an unfilled space that is not a hole and has a
filled space  or the board edge  on its left and right
 column height  the row where a column s highest
block is located
the m features are as follows 
 weightedblocks  weighted sum of blocks  where a
block s weight is the row it s on
 connectedholes  number of vertically connected
holes
 linescleared  number of lines currently cleared
during the game
 roughness  sum of absolute difference between
adjacent column heights
 tetrises  number of tetrises currently made during
the game
 pitholepercent  number of pits    number of pits  
number of holes 
 clearableline  maximum number of lines
potentially clearable by a single i  straight  piece
 deepestwell  the row containing the lowest unfilled
block that is not a hole
 blocks  number of blocks on the board
 colholes  number of columns containing at least one
hole
vii  algorithm results
after computing the optimal feature set with size m    
the genetic algorithm was run for    generations with a
population of n       for candidate selection  the selection 
mutation  and crossover phases each contributes          
and     of the new candidates respectively 

fig     results of forward search on features

each column in the graph of figure   shows the results of
one iteration of forward search  in which the best performing
feature is added to the feature set  the cells within a column
are colored closer to red the farther the value is from the top
cell in the column 
after the    top features were found  no additional features
were able to increase the metric  so the final feature set used is
those    features  the last    iterations of forward search are
not shown in figure    every value in those iterations are
      
fig     fitness of candidates over    generations

fithe graph in figure   summarizes the fitness of the
population over all    generations  focusing on the best fitness
and average fitness achieved by each generation  the fitness
scores for the rest of the candidates are shown from red
 second best fitness  to bright orange  worst fitness  to
visualize the overall trend that the population generally
improves over each generation 
based on the results from figure    the algorithm has
mostly converged after    generations  resulting in players that
can usually achieve a minimum average score of     per move
 equivalent to a minimum efficiency of       it is possible that
running more generations might result in a slight increase in
the performance of the best player  but these results are enough
to demonstrate the effectiveness of the algorithm 

while not listed above  it is interesting to note that during
these trials  the average move takes under     milliseconds to
compute  over the    trials  the player achieved an average
fitness of     points per move  an efficiency of         and an
average game length of         moves  under     minutes in
real time   a human player making one move per second
would take over two days to reach the same game length 
the best players from generations           and    were
visualized side by side in the tetris visualizer playing games
with the same sequence  in a series of unrecorded trials  it was
observed subjectively that a higher generation player almost
always gets a better score efficiency than a lower generation
player 

viii  additional testing
the best player of generation    was selected for additional
evaluation     trials were run in which the player plays a full
game of tetris without a maximum move limit until it reaches
a game over  the number of moves and the fitness score was
recorded for each trial  the results are shown in the scatter plot
in figure    a summary of statistics from figure   are shown
in figure   

fig     visualization of players from four generations playing tetris

the screenshot in figure   shows an example of the tetris
visualization of the four players  a short video of the
visualization can be accessed at the following link 
https   vimeo com           
references

fig     scatter plot of    trials of gen    tetris player

average
median
max
min
stddev

num moves
       
       
         
     
           

avg score
      
      
      
      
      

fig     summary statistics from figure   plot

    bhm  n   kkai  g     mandl  s          an evolutionary
approach to tetris  mic      the sixth metaheuristics
international conference  vienna 
    breukelaar  r  et al         tetris is hard  even to
approximate  international journal of computational geometry
  applications 
    brzustowski  j         can you win at tetris  department of
mathematics  university of british columbia 
    flom  l   robinson  c         using a genetic algorithm to
weight an evaluation function for tetris  colorado state
university 
    rollinson  d   wagner  g         tetris ai generation using
nelder mead and genetic algorithms 

fi