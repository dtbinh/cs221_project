cs    project report  cracking captchas
learning to read obscured and distorted text in images
ryan fortune

gary luu

peter mcmahon

rfortune stanford edu

gluu cs stanford edu

pmcmahon stanford edu

abstractin this report we discuss the application of machine learning techniques to the problem of reading text
in captchas  we first present techniques for reading a
captcha that requires only single character classification and
trivial segmentation  and show that we are able to successfully
read such captchas  we then show how we attempted to
read a more difficult captcha  one that required significant
effort to segment before individual character classification can
be attempted  we detail our noise removal  line removal  and
clustering based segmentation techniques  and present our results
for this second type of captcha 

i  i ntroduction
captchas are widely used on the internet as a security
measure to prevent bots from automatically spamming
registration forms  they essentially form a weak turing test
in order to ensure that the user filling out a form on a website
is human  by identifying weaknesses in current captcha
techniques  researchers can enable the development of
captchas that are more resistent to attack by resourceful
spammers 
moreover  there are similarities between the tasks of reading
captchas and reading handwritten text  so the development
of more effective techniques for reading captchas may
yield insights into how one can more effectively apply machine
learning techniques to the problem of handwriting recognition 
there are many different captcha implementations 
many of which are not proprietary  we used eliots php
captcha generator     and brainjars  net captcha
generator      because of the availability of source code
allowing us to generate data sets for supervised learning 
this report is divided into two main sections  the first
concerning our attempt to read eliots captchas  and the
second concerning the more difficult task of reading brainjar
captchas 

ii  e liot  s php captcha s ystem
eliots php captcha  epc  system     is a captcha
generating library freely available on the web under the gpl 
an example of a captcha generated with epc is shown
in figure   

fig    

captcha produced by eliots php captcha 

the important characteristics to note in this captcha
are the following  first  the individual characters are placed
in invisible equally sized subdivisions of the image  second 
the characters use regular computer typeface  with random
font color  without any transformations other than translation 
rotation and size scaling  third  lines have been randomly
drawn across the image 
the epc system thus produces captchas solved by
trivial segmentation techniques  to segment the image  we
simply copy predetermined sections of the image  solving
epc captchas is thus a character recognition problem 
a  character classification using raw pixels as features
we first attempted to build a character classifier using
features represented by the raw data  image pixels  
specifically  we defined an m by n matrix x  where m is
the number of training examples  n is the number of features
 n   wh where w and h are the width and height of each
training image in pixels  respectively  throughout this report
we assume w   h        and xij is the grayscale value 
of the jth pixel in the image of the ith training example 
the jth pixel is defined in a way that allows the  d training
images to be represented using a  d array of pixel features 
an m dimensional vector y is defined that stores the actual
class of each training example  yi   j if the ith training
example is the jth character 
our first attempt at using these features was a classification
algorithm based on multinomial logistic regression  this
approach yielded unsatisfactory results  even when using
training sets where m  n we experienced significant
difficulties with obtaining convergence  both with gradient
  we use the opposite to the usual convention for representing grayscale
pixel values  we convert a grayscale pixel value  x  y old to our format by
subtracting it from the maximum value   x  y new         x  y old   this
has the more natural interpretation of   meaning a pixel is off  and    
meaning it is on 

fim
   
    

linear kernel accuracy
     
     

new dimension k
   
   
    
    a

rbf kernel accuracy
      
      

table i
i mpact of svm k ernel c hoice on accuracy  t raining set size
m  and test set size of       

test set accuracy
    
     
     
     

table ii
i mpact of n ew f eature s pace d imension on accuracy after
applying pca  t raining set size m       on svm with rbf
k ernel   and test set size of       o riginal feature dimension
n        

descent and newtons method 
b  svm classification
we used the libsvm     support vector machine package
to perform multi class classification on the raw pixel features 
we attempted to use the popular spider package  which is
native to matlab  but found that it was unable  to train
datasets as large as ours 
the libsvm library provides support for several kernels  we
determined the classification accuracy with libsvm using the
linear  kernel  and the radial basis function   rbf  kernel 
the libsvm authors recommend that the rbf kernel be used
with kernel parameter   and penalty parameter  c  chosen
by cross validation  our results are shown in table i  the
linear kernel provides good results  and has the advantage
that when selected  the svm will train far more quickly than
with the rbf kernel  the default cross validation training
implementation in libsvm produces excellent results  but
requires considerable computing resources for large training
sets such as ours  the m        case took approximately   
cpu hours to train  libsvm tests     configurations of c and
 values using a basic grid search to determine those that
are optimal  retraining the svm     times on such a large
dataset is very time consuming 
our results were obtained by training on two different
set sizes  and in both cases testing against an independent
set with       examples       of each letter in the latin
alphabet   with the linear kernel we used the libsvm default
c      and with the rbf kernel we used libsvms grid search
optimization of c and  
c  features
due to the significant computational resources required to
train the svm with large datasets when using the raw pixels
as features  we investigated two possibilities for reducing the
dimension of the feature space  we obtained a reduced space
using principal component analysis  pca   and we developed
a custom set of features based on statistical properties of the
  with

n        features  the spider svm could train on at most m  
   examples 
  k x   x     xt x
i
j
i j
  k x   x     exp    x  x      
i
j
i
j
  the parameter c is that in the svm optimization problem 
p
m
minw b     wt w   c i   i  

a this line shows the accuracy when the feature space dimension is not
reduced 

image pixels 
to determine the efficacy of pca for our problem 
generated three new training sets using pca  by mapping
the original n dimensional feature space onto a new kdimensional space  with k        k       and k       
respectively  we trained the svm with these new training
sets  and in each case computed its accuracy using a common
test set  table ii shows the results  reducing the feature
set dimension using pca clearly has a significant negative
impact on accuracy  so we did not continue to use pca 
we calculated a smaller set of median features that
would hopefully capture trends of a given character with
many fewer features  the key to this approach was reducing
a two dimensional image into one dimension  we computed
row sums and column sums separately  and found the median
pixel  this is the pixel where the sum of the values of pixels
to the left equals the sum of the values of pixels to the
right with the same approach for the vertical direction  we
also computed     and     points as well as a few linear
combinations of these three values  once we had the median
point we also calculated radial features using the distance
from the median point as the axis so the sum of pixels
closer to the median point than the radial median equals the
sum of those further away  altogether this created    features 
because these features only represent trends of the data we
supplemented these with other features that merged together
pixels in the original image  we merged cells to reduce a
  x   character into a  x  character  this left us with   
features  much fewer than before  with two class logistic
regression  we were able to distinguish between two character
classes with over     accuracy  however these features did
not perform well once we moved to multi class classification 
d  end to end results
we have shown that we are able to classify individual
characters with high accuracy        when the characters
do not have any lines through them  since segmentation is
trivial in eliots captcha system  we would expect to be
able to correctly read a   character captcha with no lines

fimedian features
accuracy
     

custom features
accuracy
     

raw pixels feature
accuracy
     

table iii
i mpact of c ustom f eatures on accuracy  t raining set size
m       on svm with rbf k ernel   and test set size of       

lines
 
  

character accuracy
     
     

captcha accuracy
     
     

table iv
accuracy of c lassification of w hole captcha s   u sed model
generated with an svm with rbf k ernel   and training set size
m         t est captcha s had either no lines or ten randomly
placed lines   t he test sets had    captcha s each   each  
characters long  

with probability greater than              we conducted an
experiment to verify this by generating    captchas with
no lines  segmenting them  classifying each character  and
then counting how many captchas were correctly read
 we define a captcha being correctly read as one that has
all of its characters correctly classified  
we also sought to determine what the impact of having
random lines placed in the captcha is  we similarly
generated    captchas with    randomly drawn lines
each  and attempted to read them  our results for both
experiments are shown in table iv  we obtained the
expected result for the unobscured text  but with lines in
the captcha  the character classification accuracy drops
by nearly      this has a dramatic impact on the reading
accuracy for the whole captcha  since now the probability
of correctly classifying all   characters in a captcha is
estimated as                 our observed result is in
agreement with this 
iii  m odified b rain jar captcha
we obtained a captcha program from the brain jar
website that contained warped text with noise  in order to
make classifying this captcha more difficult  we modified
it to produce splines lying horizontally across the text  an
sample output is shown in figure    recaptcha      the
current reference standard captcha from the inventors of
the field  uses text that is similarly obscured 
a  individual character recognition
the brainjar captcha is capable of using any characters
in the text  but in this report we focus on recognition of the

fig    

example modified brain jar captcha

training set size m
   
    
    
    
    

test set accuracy
     
     
     
     
     

table v
i mpact of t raining s et s ize on svm accuracy using linear
kernel  t raining and test sets used characters with no noise in
the background or foreground   t he test set had     
examples  

digits      purely due to computational resource constraints 
the character classification problem in brainjars
captcha appears at first glance to be very similar to
that in eliots captcha  instead of individual characters
being translated  rotated and scaled  they are warped  in
addition  the brainjar captcha also has noise both in the
background and in the text  the foreground   as we discuss
shortly  these differences have a significant iimpact on the
individual character classification performance in the brainjar
captcha 
we first attempted to classify individual characters
generated without any background or foreground noise  table
v shows our achieved accuracy as we increase the size of the
training set  we used a linear kernel with the libsvm svm 
with the rbf kernel  with optimization of the parameters c
and  as before  we were able to obtain an accuracy of      
using a training set size of m        available computational
resources limited our ability to investigate the performance of
this kernel using larger training sets  and far superior results
were obtained using the linear kernel with training set sizes
that were not tractable for us when using the rbf kernel 
hence our classification in this section is all based on an
svm using a linear kernel 
in all cases we have used raw pixel values as features 
we tested our pixel statistics based features  but these again
yielded sub optimal accuracy results        accuracy versus
      accuracy when using raw pixel features  in one
experiment that we conducted  
table vi shows the how using training sets with noise
versus those without noise affect accuracy on test sets that
are noisy and not noisy  the objective of this analysis was to
determine whether we should train our svm on noisy data
or on clean data  we also sought to determine the importance
of noise removal in captchas that we want to read  in
this table  blank entries denote quantities we didnt conduct
experiments to measure 
we found that it is best to train the svm using clean
data  this gives us an optimal accuracy of       if the test
set is also clean  our optimal accuracy on data with both

fixxx

x test
training xxx
x
no noise
fg noise only
bg and fg noise

no noise

fg noise only

bg and fg noise

     

     
     

     
     
     

fig    

line removal without clustering beforehand 

table vi
i mpact on accuracy of n oise in t raining and t est s ets   svm
with l inear k ernel   t he training sets had m         t he test
sets had       examples each  
fig    

fig    
white 

k means with radius and pixel intensity  non black pixels are made

background and foreground noise is        it is interesting to
note that when training on clean data  the accuracy decreases
most significantly when foreground noise is included  the
addition of background noise in addition does not have a
large additional impact 
b  noise removal
noise removal is important for line removal  segmentation
and for character classification  we have shown how
the presence of noise adversely affects our accuracy in
single character classification  the following section briefly
discusses the negative impact of noise on the efficacy of our
line removal techniques 

line removal with clustering beforehand 

   slope penalty and dynamic programming  based on
two observations  the fact that the splines typically spanned
the image horizontally and generally would not have any
sharp changes in slope  we devised a dynamic programming
algorithm to find and remove the spline in the text by iterating
across the columns of the image  and using the following
recurrence
scorei j    max scorei  k   k j  
k

where the farther k and j are apart  the lower the value of
k j  
k j   imageheight   j  k 
figures   and   show the results of this algorithm 
respectively with and without clustering before applying the
algorithm 

we next tried clustering using the pixel intensity as well
as the size of the fill region of the pixel  which is defined
as the size in pixels of the largest contiguous area with
similar pixel intensity that the pixel lies in  figure   shows a
sample result following the application of this method  this
noise removal technique clearly yielded superior results 

   monte carlo line removal  we used a probablistic
method to remove lines  for every pixel  we computed the sum
of its value and its immediate neighbors  we choose a starting
point in the center column  and then progress to the left and
right separately  given a previous pixel we look at a column
three pixels to the left right of the previous one and only
consider the five pixels vertically closest to the previous to
maintain a continuous relatively flat line  we create a discount
value equal to half of the previous pixels sum  and subtract
this from each of the five sums  we then randomly choose
among these five by using the differences as weights  if all
five differences are zero  we consider this the end of the line 
we repeat     times and use the pixels that lead to the highest
combined sum 

c  line removal

d  recompletion

we attempted two methods of line removal  one using
dynamic programming to optimize a path  and another using
a probabilistic optimization procedure 

once we know where the line is  we want to remove it from
our images  originally we set the value of any pixels on the
line or immediately above and below to zero  unfortunately
this cut most of the letters in half  we implemented a simple
method to reconnect these characters by looking at the pixels
immediately above and below  since clustering removes most
of the noise  we added the pixels back to the image if both
the above and below pixels have non zero values  as to be
expected  this restores vertical lines well  partially fixes curves 
and does poorly replacing horizontal lines in characters 

looking at figure    we can see that there is noise across
the image in both the background and in the characters
themselves  we tried two variations of features to use for kmeans clustering to remove the noise  first  we tried clustering
on the intensity of the pixel and a count of pixels within a short
  pixel radius that had a similar intensity  producing figure   

fig    

k means with pixel and fill score

fi  chars correct
counts

fig    

fig    

successful segmentation  ltfxql 

unsuccessful segmentation  pacqdb 

e  segmentation
the captcha we were testing did not have merged
characters  so there was some white space between any two
characters in the original image before noise was added  we
assumed that this gap was at least two pixels  however  the
image we analyze has had both foreground and background
noise added so this assumption likely doesnt hold  k means
clustering allows us to remove much but not all of the
background noise  but it also takes a few pixels out of the
main characters 
for segmentation purposes we considered a pixel to be
part of a character if two of four pixels in its immediate area
have non zero values  we then form groups of the non zero
characters pixels if there are other character pixels sufficiently
close  we then take in to account where the line was removed
and merge groups across the line  this leaves us with around
   pixel groups for   character captchas 
in order to merge more groups together  we look at the
rightmost and leftmost ends of each character group  since
english characters tend to be vertically oriented  if any of
the smaller groups ranges are relatively close to the range
of one of the largest  but not close to any of the others 
we merge them together  ideally this prevents merging two
separate characters together  after this  we take the six largest
groups and consider them to be the six characters  we sort
the groups based on their leftmost pixel to restore the ordering 
f  end to end results
we performed an end to end test of our captcha
cracking system on     captchas generated using the
modified brainjar generator  each six characters long  using
only the digits      our experiment attempted to read each
captcha by removing noise  removing the line  with
recompletion   segmenting the image  and then performing
individual character recognition on each character 
table vii shows the results  we present a count of the
number of test captchas in which                 characters

 
  

 
  

 
  

 
 

 
 

 
 

 
 

table vii
c lassification of w hole captcha s   c ounts of c orrect
i ndividual c haracter c lassification per captcha  u sed
model generated with an svm with l inear k ernel   and
training set size m          t he test set had     captcha s  
with   characters   digits      in each  

were correctly identified  not a single whole   digit
captcha was correctly read  however  one captcha
had five of its six digits correctly classified  in    cases  not
a single character was correctly identified  out of     digits
in total      were ultimately correctly classified 
the errors result from a combination of effects from three
imperfect procedures  first  segmentation may fail  second 
recompletion after line removal may fail  which would result
in a portion of a character being deleted  in some cases this is
unimportant  but in others a significant horizontal portion of a
character may be permanently removed  the fifth character in
figure   demonstrates this  a d was transformed into a u 
third  the individual character classification is imperfect  and
even more so in the presence of noise that is not completely
removed 
iv  c onclusions
we have demonstrated that svms can be used to classify
distorted individual characters with a success rate of     
this leads to the ability to read unobscured captchas
amenable to trivial segmentation with a success rate of
approximately      we have also presented methods for
attacking the problem of segmentation in the most difficult
type of captcha currently used 
a  comparison with related work
in      chellapilla et  al  present results for individual
character recognition in captchas using neural networks 
they are able to achieve an accuracy of       even on
warped text  this is considered the current optimal solution
     in an earlier paper       chellapilla et  al  were able to
crack some captchas featuring non trivial segmentation
characteristics with accuracy of approximately     yan and
al ahmad     recently reported on their cracking of the
microsoft captcha  however  to our knowledge there has
been no successful breaking of captchas using warped
text with splines  such as our modified brainjar captcha 
and recaptcha     
proper segmentation is a crucial step for any character
recognition effort and as such there is much prior work that
has already been done  unfortunately for us  most of these
address situations without foreground noise  meaning each
character is contiguous  a situation we do not have  some of
the gaps and holes within our characters could be removed

fiby blurring the image  but doing so would make individual
character recognition more difficult by obscuring character
features  khans thesis     on segmentation suggests using
a drop fall algorithm for general purposes and also suggests
ways of identifying disconnected characters  the drop fall
algorithm described essentially reverses our approach and
uses the whitespace instead of the character pixels themselves
for segmentation  but this approach would similarly suffer
with foreground noise  khans method handles disconnected
characters in way that relies on the disconnect occurring in
specific situations  which is not applicable in captchas 
highly accurate segmentation remains an open problem for
modern captchas 
b  future work
one technique for reading captchas  inspired by the way
humans read captchas  is to use a feedback mechanism
between the segmentation and character classification stages 
in the cases where the segmentation has been done incorrectly 
the certainty of a prediction made by the svm will be low 
in this event  the segmenter should be required to reattempt
segmenting that region of the image  one simple possible
implementation of this idea is to slide a fixed size window
over the data and only accept a segmentation involving the
current window position if the image in that window yields a
character prediction with high certainty 
r eferences
    e  eliot  php captcha  url  http   www ejeliot com pages phpcaptcha
    kumar chellapilla  patrice y  simard  using machine learning to break
visual human interaction proofs  hips   nips      
    kumar chellapilla  kevin larson  patrice simard and mary czerwinski 
computers beat humans at single character recognition in reading based
human interaction proofs  second conference on e mail and anti spam
 ceas       
    jeff yan and ahmad salah el ahmad  a low cost attack on a microsoft
captcha   acm conference on computer and communications
security       
    salman amin khan  character segmentation heuristics for check
amount verification  ph d  thesis  mit       
    mike
hall 
captcha
http   www brainjar com dotnet captchaimage 

image

url 

    recaptcha url  http   recaptcha net 
    chih chung chang and chih jen lin  libsvm  a library for support
vector machines  url  http   www csie ntu edu tw cjlin libsvm
    spider
svm
library
for
http   www kyb mpg de bs people spider 

matlab 

url 

fi