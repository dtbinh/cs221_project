automatic processing of dance dance revolution
john bauer
december         

 

introduction

 

training data

as previously stated  many official versions of ddr
have been released  along with several knockoff games
made by competitors  in addition  a large body
of fan written work exists for the freeware versions 
downloading this data from various websites gives an
easy to find source of training data for this program 

the video game dance dance revolution is a musicbased game of timing  the game plays music and
shows patterns of arrows synchronized with the music  the player stands on a platform marked with
the same four arrows shown in the game and earns a
score based on how closely his steps match the timing of the video game  a pattern of steps for a given
song is called a step chart  and each step chart has
a difficulty based on the speed of the music and the
number of arrows 

however  there is a problem with the data available 
even the official songs are not officially released
by konami  but are ripped  timed and editted by
fans  worse  independently made fan work is often
of questionable quality  songs of both types are often
completely unusable 

official versions and knockoffs of the game have several hundred songs in total  furthermore  freeware
versions exist that allow users to enter their own
songs  to enter a new song in such a version  a user
must find the exact tempo of the music and choose
the timing of the arrows to associate with the music 
in general  a good player will notice a discrepency
of as little as    ms in the timing of a song  so the
timing of the new song must be very precise 

as it turns out  over the years i have collected some of
this music for my own personal use  after eliminating
some because they use features i am not working on
here  i have over     songs timed to within the    ms
accuracy discussed earlier 

this leads to three separate tasks that must all be
completed to process a song for use with ddr  first 
the correct tempo of the song must be found  second 
the music in each measure or beat must be analyzed
to see what steps fit that section of the music  finally 
given this information  the program must assign steps
in time to the music to produce a step chart of a given
difficulty 

 

determining tempo

the first thing to do is to find the tempo of a song 
we can view the timing of the song as a function
from the beat number to time elapsed from the start
of the song  the tempo is then the derivative of this
function  as the tempo may change over the course
of a song  the derivative may not be constant or even
continuous  what we do here is try to find a piecewise
linear approximation to the timing function 

the goal of this project is to analyze a previously
unknown song and produce a step chart compatible
with one of the freeware versions of ddr 
 

fithe first and most important aspect of finding the
timing of a song is to find when a strong downbeat
is  in fact  one can use this ability alone to calculate
the tempo of a song  once two strong beats have been
identified  one can estimate the tempo in between the
two by measuring the possible beats in between and
using the tempo that gives the highest overall score 

be expected because of the songs used  
however  when applied to an actual piece of music 
even these inaccurate results can often give good answers  for example  on a techno remix of xingfu de
ditu  by elva hsiao  this method acheived the   ms
tolerance discussed above  by scanning over  s intervals at a time  first looking for the strongest match
to the wide classifier and then looking in that region
for the strongest match to the narrow classifier  the
classifier accurately found the beats to within   ms
of the known good values 

one way to find a strong downbeat is to make a classifier that can recognize such a downbeat by calculating the spectrum of a song  to make such a classifier 
we first need a set of features  the fmod api library
is useful for this  as it can find the audio spectrum
of a song  using multiple frequencies from a several applying the routine to the song dont sleep in the
slices of time lets one build up a block of frequency subway by petula clark  a song that does not have
a constant tempo  led to a less satisfactory result 
strengths 
with the beats found being off by   ms on average 
although one beat was off by   ms  however  the
ground truth values for this song are noisy  the
tempo is not steady  i had to time it by hand  and
the rhythm of the song is much fainter than that of a
thumping techno piece  all things considered  this is
spectra for a time close to the known beat  such as not a great result  but would be acceptable for casual
the one shown  are given a positive training label  and use or could be corrected by hand for more serious
those for times in between beats are given a negative players   interesting bit of trivia  the beat that is off
by   ms is one i always get wrong when playing this
training label 
song  i assumed it was player error  but perhaps it is
in fact  a procedure that seems to work well is one an error in the ground truth timing  
that actually treats the problem as two separate
pieces  first  we look for a region in which we claim on a song in which the classifier successfully finds
the nearest beat is within   ms  next  we look within accurate downbeats  finding the tempo that matches
that region for a smaller region in which the nearest the intervening beats is easy  the tempo should be
beat is within  ms  in both cases  positive examples one that gives an integer number of beats between
are produced by taking the spectrum of a small win  the two found downbeats  and the way to find that
dow near a known beat  and negative examples are tempo is to take the one which gives the highest score
produced by taking the spectrum of a window outside using the same classifier 
the desired range 
an off the shelf svm library  libsvm  produced a
the first classifier tried was that of naive bayes  higher test rate      on the wide classifier and    
this worked poorly in terms of precision recall or on the narrow classifier  this was trained with a
other numerical measures  for example  on a train  linear kernel  i then used the grid search cross validaing set of      audio samples and a test set of      tion script that came with libsvm to look for a better
the wide classifier    ms tolerance  had a training gaussian kernel  but the best one found had a test
rate of       and a test rate of        the narrow rate of     on the wide classifier test set  as it
classifier   ms tolerance  had a training rate of       was larger  slower  and less accurate  i did not conand a test rate of        random fluctuations are to tinue searching for better parameters for the svm 

 

fialso  i did not search for a polynomial kernel  my
intuition  though  is that a good polynomial kernel
would work well  as it could look for correlations between multiple parts of the spectrum that indicates
how far apart the beats are coming 

gives a        accuracy rate for matching the tempo
over the entire song  using the outlier detection  the
accuracy rate rises to        
one improvement that can be made would be to apply the outlier detection to songs that do not have a
constant tempo  other future directions include improving the usability of the svm by using pca and
by trying a polynomial kernel 

one drawback to using the svm is that the feature
sets are very high dimension  the result is that the
svm is both large     mb  and slow  roughly     th
the speed of naive bayes   this suggests a pca apa completely different approach  which was not improach  but such an approach is not implemented 
plemented  would be to train a classifier that only
one specific case that can be improved is when the accepts spectra of a certain tempo  we then find a
tempo is expected to be a constant tempo  this is strong beat and then take the spectrum of a couoften true for the songs used in ddr  such as techno ple second interval of the song in the region of that
or a lot of pop music  in that case  we can use lin  beat  the spectrum would then be expanded or comear regression to smooth out the pieces  in practice  pressed until the new classifier accepted it  the dilathis can work very well when the piecewise approxi  tion needed would indicate the actual tempo of the
mations were reasonably accurate  for example  on song 
some songs  it can return a tempo within      beats
per minute of the correct value  which gives errors of
less than   ms for the beats throughout the whole
  step timing
song 
this can go awry when one or more of the piecewise approximations are incorrect  though  one way
to correct for this is to use outlier detection on the
approximate tempos  i assume the tempo detection
will take the shape of a gaussian  with a mean where
the true tempo is and a small random noise for the
deviation  it turns out that assuming the measured
tempos come from one gaussian gives a closed form
expression for the maximum likelihood gaussian  no
em needed   i calculate this for the measured tempos
and then ignore any tempos outside some predetermined range  in this case    standard deviations  

once the tempo is known  the next task is to figure
out where in the song the steps should go  traditionally  if you know where the start and the end
of a given beat are  there are six places a dance
dance revolution song can have a step  these are
the downbeat  an eighth note later  one or three sixteenth notes after the downbeat  and either triplet
after the downbeat  more than one step per beat is
possible  of course   recent versions introduced additional timings  such as   nd notes  but i ignored
these for this project  
the goal of this section is to figure out which subset of those six timings are eligible for a given beat 
to build a step chart for a particular song  we can
then use a greedy approach to add more steps until
no more step times have an acceptably strong signal
or until the steps produced meet a given difficulty
criteria 

this greatly improves the output in some cases  for
example  one song from the official data is young
forever  with a correct tempo of     bpm  the
naive bayes approach with no outlier detection finds
a bpm of         a serious error that even a novice
player would notice  with naive bayes and outlier
detection  the calculated bpm is          a very accurate result  running the naive bayes algorithm
without the outlier detection on a subset of the data

i tried three different approaches to find scores for the
six timings  but none of them gave very satisfactory
 

firesults 

correct negatives which we do not want to turn into
false positives 

the first method used features very similar to that
used in the previous task  determining tempo  in
this case  though  i considered the time range from
just before the start of a beat to just after the start of
the next beat in the music  these beats are then fed
to a battery of naive bayes classifiers  one for each
possible type of beat 

another problem is that many beat patterns are
very rare  for example  the triplet pattern corresponding to swung eighth notes is relatively common 
o oo o      the reflection of that pattern  oo oo        
does not occur anywhere in the set of songs i have 
considering these problems  it is not surprising that
the classifiers that were successfully trained only give
an accuracy of                and some classifiers that
might be desired were simply impossible to train
given the lack of data 

for example  it is very common in ddr step charts
to have one step per beat  on the downbeat  one
classifier out of the battery of classifiers takes as positive examples beats in which the downbeat is eligible
for a step  negative examples are beats in which the
downbeat is not eligible for a step  other beat patterns include pairs of eighth notes  an eighth note rest
and an eighth note  and every imaginable subset of
triplets or sixteenth notes 

another method i tried was to train one classifier that
would give a score to any individual part of the step 
the same classifier could be used to see if a step was
suitable on the downbeat  on the eighth note after the
downbeat  or any of the other possible subdivisions 
as ground truth for this approach  i used the official unfortunately  this classifier wound up learning the
step charts for the known songs that i have  if any very simple rule of only ever accepting downbeats as
of the possible step charts had a particular pattern a way of maximizing the training score 
for a given beat  i treated this as a positive training
example  i also treated it as a positive training ex  i plotted precision recall curve to see how to make
ample for simplifications that would make sense to it more effective  but the curve made it clear the
a user  for example     and a    and a   can be amount of information in the classifier was rather low 
simplified to   and   and   or to        but not to increasing the recall meant that too many false posi   a    a    which would sound unusual to a player  tives were mixed in with the new correct positives 
as steps that are placed where they dont belong
otherwise  the beat was a negative example 
are almost unplayable  it is important to keep a high
there are a couple problems with this approach  precision  however  with a high precision  it is very
first  just because no step chart realizes a particu  difficult to get enough signal to place an interesting
lar step pattern doesnt mean it wouldnt be suitable number of steps 
for that beat  for example  there are many songs
available in which a sequence of eighth notes might the third method i attempted  which was the one i fibe a reasonable pattern  but the ground truth step nally used  was to train six classifiers that each tested
charts do not have those eighth notes  accordingly  one part of the subbeat  this method may actually
the classifier for eighth note runs will have many false be the right method  as it allows the step placenegatives in its training data  very rarely will there ment routine to distinguish between how important
be a false positive in the training data  though  the each individual part of the beat is  unfortunately 
result is that the trained classifiers are very conser  it too suffered from the problem of unclean training
vative  unfortunately  increasing the recall is not a data  the overall accuracy of the various classifiers
solution  as the test data with negative scores near averages out to      not a very good result 
the threshold will be a mix of false negatives which
were learned because of the bad training data and once again  the fundamental problem seems to be
with the data set  one of the problems in our learning
 

fitheory problem set covered the idea of training in
a setting where the truth labels are flipped with a
random probability  here  however  the flipping only
ever occurs in one direction  this seems to cause the
classifier to evenly mix the true negatives and the
false negatives in terms of score 

highest signal from the step timing classifier until the
linear classifier said the song was hard enough  a user
parameter to the program  
the linear classifier used as features the number of
steps in the part of the step chart with the highest
step density  by measuring this over a couple different window sizes  this gave a reasonable description
of the difficulty of a song  once again  the ground
truth data was the official ddr data  this time using
the song difficulty labels for each step chart  this
actually led to a high  but acceptable error rate  the
classifier would rarely get the step chart difficulty exactly correct  but it would almost always be within  
of the correct value 

the right solution would be to have an experienced
player hand check the data and give the beat subdivisions labels  i havent done this yet  as it would
take several days to do for the current data set  my
hope is to find some kind of distributed solution involving getting fans of the game online to help solve
the problem  although i havent done that yet  either 

 

a better way to do this would have been to use something such as libsvms regression model on the same
feature space  but this hardly seemed worth it considering the problems were elsewhere in the project 

step placement   difficulty
assessment

one thing i did do to improve the step selection process was to run the step scores found in the previous
section through a k means algorithm  then  instead
of incrementally adding one step at a time  i took all
of the steps at the same signal strength  the idea
was that this would causes beats that sound similar
to have the same step pattern  which would improve
the basic assumption is that when a player is playing the overall quality of the step charts  it was hard
the game  there are some transitions in foot position to judge how effect this was  though  the problems
that are easy to make and some that are harder to described in the previous task meant that there not
make  however  it is rare for a song to increase in dif  many finished products to compare with or without
ficulty by introducing harder foot patterns  as those k means 
simply arent fun to play  the normal way to increase difficulty is to throw more and more steps at
the player  still involving mostly easy transitions  i
built a markov chain using my own knowledge of the  
conclusion
game in which the transitions from one foot position
to another were given different weights based on how
easy it was to make that transition  an interesting the three step process described here gives the basis
extenstion might have been to learn a hmm from the for a good method for making a previously unknown
song compatible with  freeware versions of  ddr 
given data  but i did not explore this idea 
unfortunately  problems with the data used in the
in order to avoid adding too many steps during this second step prevented the algorithm from being very
process  i used a linear classifier  least squares re  successful  the hope is that building a new data set
gression  to assess the difficulty of the song  then  i with more human input will give a program that does
greedily added steps by adding the step of the next a credible job of creating new ddr step charts 
despite these problems with the step timing  the algorithm still comes up with interesting step patterns
some of the time  when that happens  placing the
actual steps is easy  although it might still be interesting to say a few words about that 

 

fi 

acknowledgements

bemanistyle  http   www bemanisyle com 
libsvm  http   www csie ntu edu tw  cjlin libsvm
stepmania  http   www stepmania com 
svm light  http   svmlight joachims org 
fmod api  opencv  gflags
python  visual studio  emacs  etc 
professor ng and the cs     staff

 

fi