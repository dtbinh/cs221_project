Journal Artificial Intelligence Research 20 (2003) 405-430Submitted 10/02; published 12/03VHPOP: Versatile Heuristic Partial Order PlannerHakan L. S. YounesReid G. Simmonslorens@cs.cmu.edureids@cs.cmu.eduSchool Computer Science, Carnegie Mellon UniversityPittsburgh, PA 15213, USAAbstractVHPOP partial order causal link (POCL) planner loosely based UCPOP.draws experience gained early mid 1990s flaw selection strategiesPOCL planning, combines recent developments field domain independent planning distance based heuristics reachability analysis.present adaptation additive heuristic plan space planning, modifyaccount possible reuse existing actions plan. also propose large set novelflaw selection strategies, show help us solve problems previously possible POCL planners. VHPOP also supports planning durative actionsincorporating standard techniques temporal constraint reasoning. demonstrateheuristic techniques used boost performance classical POCL planning effective domains durative actions well. result versatileheuristic POCL planner competitive established CSP-based heuristic state spaceplanners.1. Introductionfirst half last decade, much research domain independent plangeneration focused partial order causal link (POCL) planners. two dominant POCLplanners SNLP (McAllester & Rosenblitt, 1991) UCPOP (Penberthy & Weld,1992), large part planning research aimed scaling two planners.promising attempts making POCL planning practical involved alternative flawselection strategies (Peot & Smith, 1993; Joslin & Pollack, 1994; Schubert & Gerevini, 1995;Williamson & Hanks, 1996; Pollack, Joslin, & Paolucci, 1997). flaw POCL planningeither unlinked precondition (called open condition) action, threatened causallink. flaw selection backtracking point search plan spacecomplete plan, order flaws resolved dramatic effectnumber plans searched solution found. role flaw selection POCLplanning similar role variable selection constraint programming.dramatic advances domain independent planning past sevenyears, focus shifted POCL planning CSP-based planning algorithms(Blum & Furst, 1997; Kautz & Selman, 1996) state space planning heuristic search(Bonet & Geffner, 2001b; Hoffmann & Nebel, 2001). Recently, Nguyen Kambhampati (2001) showed techniques distance based heuristics reachability analysislargely responsible efficiency todays best domain independentplannerscan also used dramatically improve efficiency POCL planners, therebyinitiating revival previously popular approach domain independent planning.c2003AI Access Foundation. rights reserved.fiYounes & Simmonsdrawn experience, well experience flaw selection strategiesglory-days POCL planning, developing Versatile Heuristic PartialOrder Planner (VHPOP), result POCL planner able competewell CSP-based heuristic state space planners 3rd International PlanningCompetition (IPC3).previously (Younes & Simmons, 2002) adapted additive heuristicproposedBonet, Loerincs, Geffner (1997) used HSP (Bonet & Geffner, 2001b)forplan space search. paper present variation additive heuristic POCLplanning accounts possible reuse actions already part plan.show accounting positive interaction often results effective planranking heuristic. also present ablation studies demonstrate effectivenesstie-breaking heuristic based estimated planning effort (defined total numberopen conditions, current future, need resolved order completepartial plan). results show using tie-breaking heuristic almost always improvesplanner performance.heuristics implemented VHPOP work either ground (fully instantiated) lifted (partially instantiated) actions, chose work ground actionsIPC3. shown elsewhere (Younes & Simmons, 2002) planning liftedactions help reduce branching factor search space compared using groundactions, reduction sometimes large enough compensate addedcomplexity comes keep track variable bindings. studiesneeded, however, gain better understanding circumstances planninglifted actions beneficial.VHPOP efficiently implements common flaw selection strategies, DUnfDSep (Peot & Smith, 1993), LCFR (Joslin & Pollack, 1994), ZLIFO (Schubert &Gerevini, 1995). addition these, introduce numerous novel flaw selection strategiespaper, four used IPC3. claim resolvedissue global versus local flaw selectionmanifested conflicting claims madeGerevini Schubert (1996) one hand, Pollack et al. (1997)efficient way reduce number searched plans POCL planningshow combining ideas ZLIFO LCFR get efficientflaw selection strategies. novel flaw selection strategies introduced paperbased heuristic cost, idea previously explored Ghallab Laruelle (1994).also introduce conflict-driven flaw selection strategies aim expose possibleinconsistencies early search, show strategies based ideaeffective domains previously thought particularly difficult POCL planners.Ideally, would like one single flaw selection strategy dominatesstrategies terms number solved problems. yet discover universalstrategy, instead use technique previously explored Howe, Dahlman, Hansen,Scheetz, von Mayrhauser (1999) combining strengths different planning algorithms. idea run several planners concurrently, Howe et al. showedproblems solved running single planner. VHPOPuse basic POCL planning algorithm instances, use different flawselection strategies concurrently.406fiVHPOPVHPOP extends capabilities classical POCL planners also supporting planningdurative actions. accomplished adding simple temporal network (STN)(Dechter, Meiri, & Pearl, 1991) regular plan representation POCL planner.STN records temporal constraints actions plan, supersedes simpleordering constraints usually recorded POCL planners. use STNs permits actionsinterval constraints duration (a feature utilizeddomains IPC3 VHPOP could handle). approach take temporal POCLplanning essentially constraint-based interval approach describedSmith, Frank, Jonsson (2000), similar techniques handling durative actionsPOCL framework traced back least Veres DEVISER (Vere, 1983).contribution temporal POCL planning demonstrating heuristictechniques shown boost performance classical POCL planning also effectivedomains durative actions, validating feasibility POCL paradigmtemporal planning larger set benchmark problems done before.2. Basic POCL Planning Algorithmbriefly review POCL planners work, introduce terminology used throughoutpaper. thorough introduction POCL planning, refer readertutorial least commitment planning Weld (1994).(partial) plan represented tuple hA, L, O, Bi, set actions,L set causal links, set ordering constraints defining partial order set A,B set binding constraints action parameters (B = ground actionsused). action instance action schema planning domain,qplan contain multiple instances action schema. causal link, ai aj ,represents commitment planner precondition q action aj fulfilledeffect action ai .qopen condition, ai , precondition q action ai yet linkedqeffect another action. unsafe link (or threat) causal link, ai aj , whosecondition q unifies negation effect action could possibly orderedai aj . set flaws plan union open conditions unsafelinks: F () = OC() U L().POCL planner searches solution planning problem space partialplans trying resolve flaws plan. Algorithm 1 shows generic procedurePOCL planning given planning problem returns plan solving problem (or failuregiven problem lacks solution). planning problem set initial conditionsset goals G, represented initial plan two dummy actions a0 ,effects a0 represent initial conditions problem preconditionsrepresent goals problem. procedure Make-Initial-Plan usedAlgorithm 1 returns plan h{a0 , }, , {a0 }, i. set P generated,yet visited, partial plans kept. stage planning process, plan selectedremoved P, flaw selected plan. possible refinementsresolving flaw (returned procedure Refinements) added P,process continues P empty (indicates failure) plan without flaws found.407fiYounes & SimmonsAlgorithm 1 Generic POCL planning algorithm formulated Williamson Hanks(1996).Find-Plan(I, G)P {Make-Initial-Plan(I, G)}P 6=element P plan selectionP P \ {}F () =returnelsef element F () flaw selectionP P Refinements(, f )return failure (problem lacks solution)qopen condition, ai , resolved linking q effect existingqnew action. unsafe link, ai aj threatened effect p action ak , resolvedeither ordering ak ai (demotion), ordering ak aj (promotion).use lifted actions instead ground actions, threat also resolved adding bindingconstraints p q cannot unified (separation).3. Search Controlsearch complete plan, first select plan work on, given planselect flaw repair. two choice points indicated Algorithm 1. Makinginformed choice cases essential good planner performance,following presentation choices made VHPOP.3.1 Plan Selection HeuristicVHPOP uses algorithm (Hart, Nilsson, & Raphael, 1968) search planspace. algorithm requires search node evaluation function f (n) = g(n) + h(n),g(n) cost getting n start node (initial plan) h(n)estimated remaining cost reaching goal node (complete plan). want find planscontaining actions, take cost plan number actions it.plan = hA, L, O, Bi therefore g() = |A|.original implementations SNLP UCPOP used hf () = |F ()| heuristic cost function, i.e. number flaws plan. Schubert Gerevini (1995) consideralternatives hf (), present empirical data showing counting open conditions (hoc () = |OC()|) often gives better results. big problem, however, usingnumber open conditions estimate number actions needsadded assumes uniform cost per open condition. ignores factopen conditions linked existing actions (thus requiring additional actions),open conditions resolved adding whole chain actions (thusrequiring one action).408fiVHPOPRecent work heuristic search planning resulted informed heuristic costfunctions state space planners. previous work (Younes & Simmons, 2002)adapted additive heuristicfirst proposed Bonet et al. (1997) subsequently usedHSP (Bonet & Geffner, 2001b)for plan space search also extended handlenegated disjunctive preconditions actions well actions conditional effectslifted actions. heuristic cost function used VHPOP IPC3 variationadditive heuristic reuse actions taken account, coupledtie-breaking rank (introduced Younes & Simmons, 2002) based estimated remainingplanning effort.3.1.1 Additive Heuristic POCL Planningkey assumption behind additive heuristic subgoal independence. giverecursive definition additive heuristic POCL planning, starting levelliterals working towards definition heuristic cost partial plan.Given literal q, let GA(q) set ground actions effect unifiesq. cost literal q definedq unifies literal holds initially0minaGA(q) hadd (a) GA(q) 6=hadd (q) =.otherwisepositive literal q holds initially part initial conditions. negative literal qholds initially q part initial conditions (the closed-world assumption).cost actionhadd (a) = 1 + hadd (Prec(a)),Prec(a) propositional formula negation normal form representing preconditions action a. propositional formula negation normal form negationsoccur level literals. propositional formula transformed negationnormal form, done action preconditions VHPOP parsing domaindescription file.Existentially quantified variables action precondition treated additionalparameters action. cost existentially quantified preconditionsimply defined follows:hadd (x.) = hadd ()deal universally quantified preconditions making fully instantiatedpreprocessing phase, order complete definition heuristic cost actionpreconditions need add definitions heuristic cost conjunctionsdisjunctions. cost conjunction sum cost conjuncts:^hadd () =Xhadd (i )summation formula gives additive heuristic name.definition based assumption subgoals independent, lead409fiYounes & Simmonsoverestimation actual cost conjunctive goal (i.e. heuristic admissible).cost disjunction taken cost disjunct minimal cost:_hadd ( ) = min hadd (i )additive heuristic cost function POCL plans defined follows:Xhadd () =hadd (q)qai OC()cost function conjunction, definition easily lead overestimation number actions needed complete plan, since possible reuse ignored.propose remedy below.cost ground literals efficiently computed dynamic programming.take conditional effects account cost computation. effect q conditioned p action a, add hadd (p) cost achieving q a. needcompute cost ground literals preprocessing phase, leaving littleoverhead evaluating plans planning phase. working lifted actions,extra overhead unification. also noted lifted literalsindependently matched ground literals without considering interactions openconditions action. example, two preconditions (a ?x) (b ?x)action unified ground literals different matchings variable ?x.3.1.2 Accounting Positive Interactionadditive heuristic take reuse actions (other dummy action a0 )account, often overestimates actual number actions needed completeplan. need take positive interaction account order obtainaccurate heuristic estimate recognized state space planning (Nguyen &Kambhampati, 2000; Hoffmann & Nebel, 2001; Refanidis & Vlahavas, 2001) plan spaceplanning (Nguyen & Kambhampati, 2001). IPC3 used slight modificationadditive heuristic address issue action reuse:aj s.t. effect aj unifies q0Xhradd () =ai aj 6qhadd (q) otherwiseai OC()qunderlying assumption heuristic cost function open condition aipossibly resolved linking effect existing action aj giverise new action resolved. course lead overly optimistic estimatenumber actions required complete plan. modified heuristic stilladmissible, however, since cost value used open conditionscannot linked effects existing actions. words, account possiblereuse existing actions potential actions.illustrate difference hadd () hradd () consider planning domaintwo action schemas A1 A2 , A1 preconditions A2 single410fiVHPOPProblemDriverLog6DriverLog7DriverLog8DriverLog9DriverLog10ZenoTravel6ZenoTravel7ZenoTravel8ZenoTravel9ZenoTravel10Satellite6Satellite7Satellite8Satellite9Satellite10MW-Lochaddhradd8.650.163.660.340.334.132.110.93- 15.48- 86.21- 26.590.360.220.490.371.092.411.531.12MW-Loc-Confhaddhradd4.410.130.630.17110.261.480.280.710.7617.412.9037.8137.9911.5321.220.370.240.540.841.290.842.111.951.11LCFR-Lochaddhradd87.582.0121.151.28- 177.273.790.6425.090.9533.3721.200.320.210.550.510.850.831.841.501.36LCFR-Loc-Confhaddhradd1.161.570.222.051.300.8311.242.8233.106.4526.339.4918.220.400.240.621.250.682.502.081.37Table 1: Planning times seconds using different flaw selection strategies selectionproblems DriverLog, ZenoTravel, Satellite domains, showing impacttaking reuse account plan ranking heuristic. dash (-) meansplanner ran memory (512 Mb).precondition q. Assume q achieved action instance A1 .heuristic cost literal q therefore 1 according additive heuristic. Considerplan two unordered actions a1 a2 (ai instance action schemaqAi ) single open condition a2 . hadd () = hadd (q) = 1 correspondingaddition new instance action schema A1 achieve q, hradd () = 0action (viz. a1 ) ordered a2 effect unifies q.Table 1 shows taking reuse account significant impact planning timepractice. modified additive heuristic hradd clearly dominates hadd DriverLogZenoTravel domains despite incurring higher overhead per generated plan. resultsSatellite domain mixed, hadd slight edge overall. showplanning times four flaw selection strategies used VHPOP IPC3.novel flaw selection strategies discussed detail Section 3.2.2.Hoffmann Nebel (2001) describe FF heuristic takes positive interaction actions account extracting plan relaxed planning graph1 , argueaccounting action reuse one contributing factors FFs performanceadvantage HSP. FF heuristic take reuse potential actions account,existing actions case modified additive heuristic.result better estimate actual plan cost, requires plan extracted1. relaxed planning graph planning graph action pairs marked mutex.411fiYounes & Simmonsrelaxed planning graph every search node, could costly. would interestingsee FF heuristic performs used plan space planner.heuristic cost function used RePOP (Nguyen & Kambhampati, 2001), heuristicpartial order planner working solely ground actions, defined using serial planninggraph.2 heuristic similar spirit FF heuristic, like FF heuristictake reuse potential actions account. RePOP heuristic also takes accountreuse existing actions, seemingly without considering ordering constraints,something modified additive heuristic. Furthermore, hradd heuristicalways takes reuse existing actions achieves literal q account,RePOP heuristic considers existing action happens selectedserial planning graph action achieves q. results Table 2 indicateRePOP heuristic may less effective additive heuristic (with withoutreuse) certain domains.3.1.3 Estimating Remaining Effortwant find plans consisting actions, also wantexploring plans possible. Schubert Gerevini (1995) suggest numberopen conditions useful estimate number refinement steps neededcomplete plan. take idea bit further.computing heuristic cost literal, also record estimated effortachieving literal. literal achieved initial conditions estimatedeffort 1 (corresponding work adding causal link plan). costliteral comes action a, estimated effort literal estimated effortpreconditions a, plus 1 linking a. Finally, estimated effort conjunctionsum estimated effort conjuncts, estimated effort disjunctionestimated effort disjunct minimal cost (not effort).main difference heuristic cost estimated effort plan estimated effort assigns value 1 instead 0 literals unified initialcondition. illustrate difference, consider plan two open conditions p qhold initial conditions. heuristic cost 0, estimatedeffort 2. estimated effort basically heuristic estimate total number openconditions resolved complete plan found, usedtie-breaker two plans 0 case f () = f ( 0 ). Consider alternative plan0 number actions single open condition p. planheuristic cost 0 plan , estimated effort 1, 0 wouldselected first estimated effort used tie-breaker. Table 2 shows using estimatedeffort tie-breaker notable impact planner performance haddhradd . Estimated effort helps reduce number generated explored plans casesone (when using hradd problem rocket-ext-a).Estimated effort useful plan ranking heuristic, also heuristic flawselection soon see.2. serial planning graph planning graph every pair non-noop actions level markedmutex.412fiVHPOPProblemgripper-8gripper-10gripper-12gripper-20rocket-ext-arocket-ext-blogistics-alogistics-blogistics-clogistics-dhadd1636 / 7053268 / 13595879 / 235933848 / 1220434917 / 2581027871 / 20034503 / 301857 / 488766 / 4223039 / 1398effort1089 / 4491958 / 7953224 / 129414386 / 555827846 / 2002827277 / 19363481 / 287713 / 404630 / 3462950 / 1384hradd****24507 / 1579015919 / 9000621 / 389694 / 402629 / 3532525 / 1300effort****31213 / 2032110914 / 6705530 / 317584 / 326438 / 2271472 / 682RePOP****30110 / 1776885316 / 51540411 / 191920 / 4364939 / 2468*Table 2: number generated/explored plans hadd hradd withoutestimated effort tie-breaker. RePOP column contains numbers reported Nguyen Kambhampati (2001) RePOP using serial planninggraph heuristic. numbers included purpose showingseems qualitative difference RePOP heuristicheuristics used VHPOP. asterisk (*) means solution foundgenerating 100000 plans. Flaws selected LIFO order.3.2 Flaw Selection Strategiesoriginal implementations SNLP UCPOP threats selected openconditions. one threat (or open condition) selected,one added last selected first (LIFO order). Several alternative flaw selection strategiesproposed attempt improve performance exhibited POCL planners.Peot Smith (1993) show number searched plans reduceddelaying resolution threats. successful proposed delay strategiesDSep, delays threats resolved separation, DUnf,delays threats resolved one way.Joslin Pollack (1994) suggest flaws treated uniformly,flaw least number refinements selected first. flaw selectionstrategy, LCFR, viewed instance most-constrained-variable heuristic usedsimple search rearrangement backtracking (Bitner & Reingold, 1975; Purdom, 1983).main disadvantage LCFR computing repair cost every flaw incurlarge overhead flaw selection. lead longer planning times comparedusing default UCPOP strategy, even number search nodes significantlysmaller LCFR. clever implementation LCFR can, however, reduce overheadflaw selection considerably.Schubert Gerevini (1995) argue LIFO strategy selecting open conditionshelps planner maintain focus achievement particular high-level goal.ZLIFO strategy variation DSep strategy, difference openconditions cannot resolved, resolved one way, selectedopen conditions resolved one way. Gerevini Schubert (1996)present results indicating ZLIFO often needs generate fewer plans LCFRsolution found, smaller overhead flaw selection. results413fiYounes & Simmonsdisputed Pollack et al. (1997). instead attribute much power ZLIFOdelaying separable threats, propose variation LCFR, LCFR-DSep, alsodelays separable threats. Since chose work ground actions IPC3, separabilityissue us.3.2.1 Notation Specifying Flaw Selection Strategiesorder better understand differences various flaw selection strategies,simplify comparative studies, Pollack et al. (1997) proposed unifying notationspecifying flaw selection strategies. adopt notation slight modifications.flaw selection strategy ordered list selection criteria. selection criterionform{flaw types}max refinements ordering criterion,applies flaws given types resolved max refinementsways. limit number refinements, simply write{flaw types}ordering criterion.ordering criterion used order flaws selection criterion applies to. LIFOorder used ordering criterion cannot used distinguish two flaws.Pollack et al. define flaw types (open condition), n (non-separable threat),(separable threat). also define ordering criteria LIFO, FIFO, R(random), LR3 (least refinements first), New. last one applies openconditions, gives preference open conditions resolved adding newaction. rest apply open conditions threats.Flaws matched selection criteria, required completeness everyflaw matches least one selection criterion flaw selection strategy. flawmatches earliest selection criterion, ordered flaws matchingcriterion (according ordering criterion), flaw gets selectedflaw selection strategy. Note always need test flaws. If, example,first selection criterion {n, s}LIFO, found threat, needconsider flaws selection.Using notation, specify many different flaw selection strategies concisemanner. Table 3 specifies flaw selection strategies mentioned earlier. summaryflaw types recognized VHPOP, including three new flaw types defined below, givenTable 4.3.2.2 New Flaw Selection Strategiespropose several additional flaw types ordering criteria, use combination previous ones obtain novel flaw selection strategies. Fournew flaw selection strategies used IPC3 contributed success VHPOPevent.3. original notation ordering criterion LC least (repair) cost, repair costdefined number refinements. introduce new ordering criterion basedheuristic cost, choose rename ordering criterion.414fiVHPOPNameUCPOPDSepDUnfLCFRLCFR-DSepZLIFOSpecification{n, s}LIFO / {o}LIFO{n}LIFO / {o}LIFO / {s}LIFO{n, s}0 LIFO / {n, s}1 LIFO / {o}LIFO / {n, s}LIFO{n, s, o}LR{n, o}LR / {s}LR{n}LIFO / {o}0 LIFO / {o}1 New / {o}LIFO / {s}LIFOTable 3: flaw selection strategies previously proposed planning literature.Flaw TypenluDescriptionnon-separable threatseparable threatopen conditionstatic open conditionlocal open conditionunsafe open conditionTable 4: Summary flaw types recognized VHPOP.Early Commitment Flaw Selection. shown (Younes & Simmons,2002) giving priority static open conditions beneficial planninglifted actions. Introducing new flaw type, t, representing static open conditions,specify flaw selection strategy follows:Static-First {t}LIFO / {n, s}LIFO / {o}LIFOstatic open condition literal involves predicate occurring initialconditions planning problem, effects operator planningdomain. means static open condition always linked initialconditions, initial conditions consist solely ground literals. Resolving staticqopen condition ai therefore cause free variables q bound specificobjects. Resolving static open conditions flaws represents bias towards earlycommitment parameter bindings. resembles search strategy inherent plannersusing ground actions, without necessarily committing bindings parametersaction once. gain reduced branching factor compared planner usingground actions, reduction compensate increased complexity comeskeep track variable bindings.earlier results (Younes & Simmons, 2002) indicated despite reductionnumber generated plans planning lifted actions, using ground actionsstill faster domains. gripper domain, example, using lifted actionsresulted less half number generated plans compared using groundactions, planning ground actions still twice fast. greatlyimproved implementation planner handling variable bindings sincethen. using latest version VHPOP gripper domain, planner415fiYounes & Simmonsroughly fast planning lifted actions giving priority static preconditionsplanning ground actions.Local Flaw Selection. retaining LIFO order selecting open conditions achievable multiple ways, Schubert Gerevini (1995) argue planner tends maintain focus particular higher-level goal regression, instead trying achieve multiplegoals breadth-first manner. goals achieve independent, maintaining focus single goal beneficial. problem LIFO-based flawselection strategy, however, pointed Williamson Hanks (1996),highly sensitive order operator preconditions specified domaindescription.necessary, however, select recently added open condition orderkeep focus achievement one goal. get effect selectingopen conditions, restrict choice recently added action. thereforeintroduce new flaw type, l, representing local open conditions. local open conditionone belongs recently added action still remaining open conditions.use ordering criterion select among local open conditions. Using newflaw type, specify local variant LCFR:LCFR-Loc {n, s, l}LROne would expect strategy less sensitive precondition-order simple LIFO-based strategy. see evidence Table 5, also showsmaintained goal focus achieved local flaw selection strategies help solveproblems compared global flaw selection strategy.Heuristic Flaw Selection. Distance based heuristics used extensivelyranking plans state space planners (e.g., HSP FF). Nguyen Kambhampati(2001) show heuristics useful ranking plans POCL plannerswell. also suggest heuristics could used flaw selection methods,elaborate subject.hard see, however, many plan rank heuristics could usedpurpose selecting among open conditions, since often based estimatingcost achieving open conditions seen Section 3.1.1. giving priority openconditions highest heuristic cost, build plans top-down mannergoals initial conditions. call ordering criterion MC (most cost first).using opposite ordering criterion, LC, would instead tend build plansbottom-up manner. Note two ordering criteria apply open conditions,threats, would need use combination selection criteriathreats. define global local heuristic flaw selection strategies:MC {n, s}LR / {o}MCaddMC-Loc {n, s}LR / {l}MCaddsubscript MC indicates heuristic function use ranking open conditions,case additive heuristic.416fiVHPOPProblemDriverLog6DriverLog7DriverLog8DriverLog9DriverLog10ZenoTravel6ZenoTravel7ZenoTravel8ZenoTravel9ZenoTravel10Satellite6Satellite7Satellite8Satellite9Satellite10UCPOP/|| n0.20 200.23 200.28 170.6270.33 160.27 200.2380.29 110.22 170.26 180.20 190.5490.3580.3470.329LCFR/|| n0.01 200.10 2000.00 1000.037000000000LCFR-Loc/||n0.01200.32200.0010.45140.07200.22200.18160.15190.21180.22170.02200.03200.02200.0010.0120MC/|| n0.18 200.13 180000000000000MC-Loc/|| n0.23 200.25 2000.01 200.08 200.00 200.16 160.18 200.19 200.15 190.02 200.07 200.0740.0010MW/|| n0.02 2000000000000000MW-Loc/||n0.02200.052000.01200.08200.00200.16160.18200.19200.15190.02200.07200.0740.0010Table 5: Relative standard deviation number generated plans (/||)number solved problems (n) 20 instances problem randomprecondition ordered. Low relative standard deviation indicates low sensitivityprecondition order. Results shown VHPOP using seven different flaw selection strategies. memory limit 512 Mb enforced, hradd estimatedeffort tie-breaker used plan ranking heuristic.Section 3.1.3, proposed estimate remaining planning effortopen condition counting total number open conditions would ariseresolving open condition. heuristic could also useful ranking open conditions,often discriminating ordering criterion based heuristic cost.therefore define two additional ordering criteria: MW (most work first) LW.these, define additional flaw selection strategies:MW{n, s}LR / {o}MWaddMW-Loc{n, s}LR / {l}MWaddplanning problems listed Table 5, see MW-Loc sensitiveprecondition order MC-Loc, MW-Loc never performing worse MC-Locfirst two problems performing clearly better.IxTeT (Ghallab & Laruelle, 1994; Laborie & Ghallab, 1995) also uses heuristic techniques guide flaw selection, quite different way suggested here.understanding IxTeT heuristic estimates, possible refinement r resolving flaw, amount change (commitment) would result applying rcurrent plan. open conditions, estimate obtained expanding treesubgoal decomposition, principal regression-match graph (McDermott, 1999).similar heuristic values computed using additive heuristic. However,IxTeT considers number actions need added resolve opencondition also degree current variable domains would reduced possibleaction orderings restricted. Furthermore, IxTeT uses heuristic values choose417fiYounes & Simmonsflaw single refinement stands least costly comparedrefinements flaw. intended effect reduction amountbacktracking needed find solution, although aware evaluationeffectiveness technique.Conflict-Driven Flaw Selection. Common wisdom implementing search heuristicsconstraint satisfaction problems, e.g. propositional satisfiability, first make decisionsmaximal consequences, inconsistencies detected early on, pruning largeparts search space.flaw selection strategy follows principle would link unsafe open conditions open conditions. call open condition unsafe causal linkopen condition would threatened. giving priority unsafe open conditions,planner direct attention possible conflicts/inconsistencies plan earlystage. introduce flaw type u representing unsafe open conditions. Examplesconflict-driven flaw selection strategies using new flaw type following variationsLCFR, LCFR-Loc, MW-Loc:LCFR-Conf {n, s, u}LR / {o}LRLCFR-Loc-Conf {n, s, u}LR / {l}LRMW-Loc-Conf {n, s}LR / {u}MWadd / {l}MWaddfirst two conflict-driven strategies effective link-chain domainconstructed Veloso Blythe (1994). link-chain domain artificial domainspecifically constructed demonstrate weakness POCL planners certain domains.makes domain hard SNLP UCPOP default flaw selectionstrategies open conditions achieved several actions oneaction right choice negative interaction. forces POCL plannerbacktrack excessively link commitments, inconsistencies may immediatelydetected many link alternatives. see Figure 1 VHPOP usingUCPOP flaw selection strategy performs poorly link-chain domain. Usingsophisticated flaw selection strategy LCFR improves performance somewhat.However, two conflict-driven flaw selection strategies problems solvedless second. number generated explored plans fact identicalLCFR-Conf LCFR-Loc-Conf, LCFR-Loc-Conf roughly twice fast LCFRConf reduced overhead. demonstrates benefit local flaw selectionstrategies. Note, however, LCFR faster LCFR-Loc link-chain domain,local strategies always superior global strategies.also see Table 1 conflict-driven flaw selection strategies work wellDriverLog Depots domains, hadd hradd heuristic function rankingplans.4. Temporal POCL Planningclassical planning, actions duration: effects action instantaneous.Many realistic planning domains, however, require actions overlap timedifferent duration. version planning domain definition language (PDDL),418fiVHPOP(s)UCPOPLCFRLCFR-LocLCFR-ConfLCFR-Loc-Conf100806040200123456789 10Number goals1112131415Figure 1: Average planning time ten problems point different flaw selection strategies link-chain domain. Results shown VHPOP usingfive different flaw selection strategies. points strategy solvedten problems without running memory (512 Mb) shown. hfheuristic used rank plans.PDDL2.1, used IPC3 introduces notion durative actions. durativeaction represents interval time, conditions effects associatedeither endpoint interval. Durative actions also invariant conditionsmust hold entire duration action.use constraint-based interval approach temporal POCL planning describedSmith et al. (2000), essence approach used earlier temporal POCLplanners DEVISER (Vere, 1983), ZENO (Penberthy & Weld, 1994), IxTeT(Ghallab & Laruelle, 1994). Like IxTeT, use simple temporal network (STN) recordtemporal constraints. STN representation allows rapid response temporal queries.ZENO, hand, uses integrated approach handling temporalmetric constraints, make use techniques optimized temporal reasoning.following description VHPOP handles type temporal planningdomains expressible PDDL2.1.planning durative actions, substitute partial order representation plan STN . action ai plan, except dummy actionsa0 , represented two nodes t2i1 (start time) t2i (end time) STN, compactly represented d-graph (Dechter et al., 1991). d-graphcomplete directed graph, edge ti tj labeled shortest temporaldistance, dij , two time nodes ti tj (i.e. tj ti dij ). additional time419fiYounes & Simmons01 074 3 0(a)01 074 3 01 045 4 0(b)01 07266 3 0 5 11 045 4 0(c)Figure 2: Matrix representation d-graph, = 1, STN (a) adding actiona1 duration constraint 1 7 1 3, (b) adding action a2 durationconstraint 2 = 4, (c) ordering end a2 end a1 . Explicitlyadded temporal constraints boldface.point, t0 , used reference point represent time zero. default, dij =6= j (dii = 0), signifying upper bound difference tj ti .Constraints added addition new action, linking opencondition, addition ordering constraint endpoints two actions.duration, , durative action ai specified conjunction simple durationconstraints ./ c, c real-valued constant ./ set {=, , }.4simple duration constraint gives rise temporal constraints time nodes t2i1t2i adding ai plan hA, L, , Bi. temporal constraints, termsminimum distance dij two time points, follows:DurationConstraint=cccTemporal Constraintsd2i1,2i = c d2i,2i1 = cd2i1,2i cd2i,2i1 csemantics PDDL2.1 durative actions dictates every action scheduledstrictly time zero. Let denote smallest fraction time required separate twotime points. ensure added action ai scheduled time zero, addtemporal constraint d2i1,0 addition temporal constraints due durationconstraints. Figure 2(a) shows matrix representation d-graph addingaction, a1 , duration constraint 1 7 1 3 null plan. rows columnsmatrix correspond time point 0, start action a1 , end action a1order. adding action a2 duration constraint 2 = 4, d-graphrepresented matrix Figure 2(b). two additional rows columns correspondstart end action a2 order.temporal annotation {s, i, e} added representation open conditions.q@sopen condition ai represents condition must hold start durativeq@eq@iaction ai , ai represents condition must hold end ai , aiinvariant condition ai . equivalent annotation added representation causal4. contrast, Veres DEVISER handle duration constraints form = c.420fiVHPOPq@links. linking open condition ai effect associated time point tjgives rise temporal constraint dkj (k = 2i = e, else k = 2i 1). Figure 2(c)shows representation STN plan actions a1 a2 , before,effect associated end a2 linked condition associated end a1 .Unsafe causal links resolved basically way before, insteadadding ordering constraints actions add temporal constraints timepoints ensuring one time point precedes another time point. ensure timepoint ti precedes time point tj adding temporal constraint dji .Every time add temporal constraint plan, update shortest paths dijcould affected added constraint. propagation constraintscarried O(|A|2 ) time.plan without flaws found, need schedule actions plan, i.e. assignstart time duration action. schedule actions solution STN, solution assigning earliest possible start time action readily availabled-graph representation. start time action ai set d2i1,0 (Corollary 3.2,Dechter et al., 1991) duration d2i1,0 d2i,0 . Assuming Figure 2(c) representsSTN complete plan, would schedule a1 time 1 duration 5 a2time 1 duration 4. easily verify schedule indeed consistentduration constraints given actions, a2 ends a1 required.non-durative action treated durative action fixed duration 0,preconditions associated start time, effects associated end time,without invariant conditions. allows frictionless treatment domainsdurative non-durative actions.Let us moment consider memory requirements temporal POCL planningcompared classical POCL planning. planning non-durative actions, storebit-matrix representing transitive closure ordering constraints O.partial plan n actions, requires n2 bits. n durative actions, hand,need roughly 4n2 floating-point numbers represent d-graph . floatingpoint number requires least 32 bits modern machine, total need100 times many bits represent temporal constraints regular ordering constraintsplan. note, however, refinement changes entriesd-graph, choosing clever representation matrices share storageplans. upper left 3 3 sub-matrix Figure 2(b) example identical matrixFigure 2(a). way store matrices VHPOP allows us exploit commonalitythereby reduce total memory requirements.addition durative actions change basic POCL algorithm.recording temporal constraints temporal annotations handled mannertransparent rest planner. search heuristics described Section 3, althoughtuned specifically temporal planning, used durative actions.need slightly modify definition literal action cost additive heuristictemporal annotations associated preconditions effects durativeactions. Let GAs (q) denote set ground actions achieving q start, GAe (q)421fiYounes & SimmonsNameMW-LocMW-Loc-ConfLCFR-LocLCFR-Loc-ConfSpecification{n, s}LR / {l}MWadd{n, s}LR / {u}MWadd / {l}MWadd{n, s, l}LR{n, s, u}LR / {l}LRTable 6: Flaw selection strategies used VHPOP IPC3.set ground actions achieving q end.0minaGAt (q) hadd (a@t)hadd (q) =define cost literal qq holds initiallyGAt (q) 6=,otherwise{s, e} cost durative action endpoint definedhadd (a@t) = 1 + hadd (Prec (a)).Prec (a) propositional formula representing invariant preconditions preconditions associated start a, Prec e (a) formula representing preconditions a.5. VHPOP IPC3VHPOP allows several flaw selection strategies used simultaneously roundrobin scheme. lets us exploit strengths different flaw selection strategies concurrently, essential success VHPOP IPC3 since yet findsingle superior flaw selection strategy dominates flaw selection strategiesterms number solved problems within given time frame. techniqueuse VHPOP supporting multiple flaw selection strategies essencetechnique proposed Howe et al. (1999) exploiting performance benefits severalplanners meta-planner. Although meta-planner slower fastestplanner single problem, solve problems single planner.used four different flaw selection strategies IPC3 (Table 6), preferring local flawselection strategies tend incur lower overhead global strategiesLCFR MW often appear effective global strategies maintained focused subgoal achievement. four strategies selected initialexperimentation problems competition domains.use multiple flaw selection strategies thought running multipleconcurrent instances planner, separate search queue maintainedflaw selection strategy used. Similar HSP2.0 planning competition2000 (Bonet & Geffner, 2001a), use fixed control strategy schedule multipleinstances planner. first time flaw selection strategy used, allowedgenerate 1000 search nodes. second time flaw selection strategyused, generate another 1000 search nodes, making total 2000 search nodes.subsequent round i, flaw selection strategy permitted generate422fiVHPOPNameMW-LocMW-Loc-ConfLCFR-LocLCFR-Loc-ConfOrder1234STRIPS Limit10000100000200000Durative Limit12000100000240000Table 7: Execution order flaw selection strategies used IPC3, also search limitsused strategy domains without durative actions.1000 2i2 additional nodes. maximum number nodes generated using specific flawselection strategy 1000 2i1 rounds. optional upper limit numbergenerated search nodes set flaw selection strategy. useful flawselection strategies typically solve problems quickly, solve withinreasonable time. Table 7 shows search limits used VHPOP IPC3. limitsdetermined initial trials competition problems. Noteset search limit last flaw selection strategy. Whenever three strategiesreached search limits without found solution, LCFR-Loc-Conf usedphysical resource limits reached.Table 8 shows number plans generated STRIPS Satellite domainsolution found four flaw selection strategies used IPC3, also numbergenerated plans combining four strategies using schedule Table 7.better understand round-robin scheduling works, take closer looknumbers problem 15. Table 9 shows total number generated plans dividedrounds flaw selection strategies. Note although MW-Loc actuallybest strategy problem, stopped already round 5. total numbergenerated plans exactly match actual number generated plans reportedTable 8. consider suspending use flaw selection strategyrefinements last selected plan added, limit roundexceeded slightly practice. numbers Table 9 represent idealized situationflaw selection strategies switched number generated plans exactlymatches limit current round.VHPOP solved 122 problems 224 attempted IPC3. quality plans,terms number steps, generated VHPOP generally high. plainSTRIPS domains, VHPOPs plans typically within 10 percent best plans foundplanner competition, 28 VHPOPs 68 STRIPS plans leastshort best plans found and, POCL planner, VHPOP automatically exploitsparallelism planning domains, generating plans STRIPS domains low total planexecution time (Table 10). Table 11 shows VHPOP also performed well termsnumber solved problems four six STRIPS domains, competitive topperformers MIPS LPG (particularly Rovers domain).423fiYounes & SimmonsProblem12345678101112131415161718MW-Loc118229172738448636000571482000124511723517624123527473853300029751584MW-Loc-Conf118229172843723000629000745874117811723733382000235244400052900029751584LCFR-Loc11824917282210187206201017132311725250005590002157107375344234381724LCFR-Loc-Conf1182491721797706000834688000783127511725250005440002157465000357134381724118229172738448272757118744283417295421826583652813871347189814588Table 8: Number generated plans STRIPS Satellite domain four differentflaw selection strategies used VHPOP IPC3. rightmost columnnumber plans generated VHPOP finding solution usingschedule Table 7. dagger () means planner ran memory(800 Mb) generating least indicated number plans.Round12345678TotalMW-Loc1000100020004000200010000MW-Loc-Conf10001000200040008000160003200036000100000LCFR-Loc10001000200040008000160003200043375107375LCFR-Loc-Conf10001000200040008000160003200064000Total4000400080001600026000480009600079375281375Table 9: closer look round-robin scheduling problem 15 STRIPS Satellitedomain. Italic entries indicate search limit flaw selection strategyreached round.424fiVHPOPDomainDriverLogZenoTravelSatelliteRovers# Solved14131720# Steps1.091.041.071.08# Best5777Execution Time1.151.201.251.08# Best45513Table 10: Relative plan quality STRIPS domains VHPOP solvedhalf problems. two plan quality metrics. Number stepssimply total number steps plan, execution time totaltime required execute plan (counting parallel actions one time step).table shows average ratio VHPOPs plan quality qualitybest plan generated planner, number problems domainVHPOP found best plan also shown.PlannerFFLPGMIPSSimplannerStellaVHPOPDepots2221102243DriverLog151815111014ZenoTravel202016201813Satellite202014171417Rovers2012129420FreeCell2018191201Total11710986915068Table 11: Number problems solved top performing fully automated plannersSTRIPS domains.domains durative actions5 , total execution time given explicit planmetric, objective minimize metric. specification explicit planmetric feature PDDL2.1 present earlier versions PDDL. VHPOP currently ignores objective function always tries find plans steps,come surprise quality VHPOPs plans domains durative actionssignificantly worse quality best plans found (Table 12).6 VHPOPstill produced plans steps, however, 60 percent VHPOPs plansdomains durative actions fewest steps. plan selection heuristicVHPOP uses tuned finding plans steps, would need modifiedorder find plans shorter total execution time. Table 13 shows LPG solvedfar problems domains durative actions, VHPOP competitiveMIPS clearly outperformed TP4 TPSYS.5. two types domains durative actions IPC3: SimpleTime domains actionsconstant duration Time domains durations functions action parameters.results durative actions presented paper SimpleTime domains currentlysupport durations functions action parameters VHPOP. would, principle,hard add support though, expect future versions VHPOP it.6. poor performance part also due use 1 (see Section 4) VHPOP,planners used 0.01 less. Using 0.01 VHPOP reduces total execution time plans15 percent.425fiYounes & SimmonsDomainDriverLogZenoTravelSatelliteRovers# Solved1413177# Steps1.041.041.041.04# Best81095Execution Time1.501.542.511.39# Best0000Table 12: information Table 10, domains durative actions.PlannerLPGMIPSTP4TPSYSVHPOPDepots2011103DriverLog20152214ZenoTravel20145213Satellite2093217Rovers129447Total9258151054Table 13: Number problems solved fully automated planners domains durativeactions.VHPOP top performer IPC3 terms plan quality, fartop terms planning time. VHPOP typically orders magnitude slowerfastest planner. high planning times VHPOP part attributedimplementation details. Improvements code (e.g. using pointer comparison insteadstring comparison whenever possible) since planning competition resulted 1020 percent lower planning times using ground actions using lifted actionsplanner twice fast before. reachability analysis still bottleneck,however, improvements could definitely made there. importantremember, though, basically run four planners using four flaw selectionstrategies concurrently. Table 14 shows average relative performance VHPOPIPC3 compared performance VHPOP using best flaw selection strategyproblem. VHPOP best flaw selection strategy average two threetimes faster VHPOP four concurrent strategies. Using several flaw selectionstrategies simultaneously helps us solve problems, price reduced speed.intelligently scheduling different flaw selection strategies depending domainproblem features, using fixed schedule problems, could potentiallyincrease planner efficiency significantly.6. DiscussionMcDermott (2000) finds absence POCL planners first planning competition1998 striking, planners dominating planning research years earlier. seems doubtful arguments [POCL planners] favor wrong,would interesting see partial-order planners compete future competitions, McDermott writes. two competitions without POCL planners, believe VHPOPsperformance IPC3 demonstrates POCL planningat least ground actionscompetitive CSP-based heuristic state space planning. VHPOP also shows426fiVHPOPDomainDriverLogZenoTravelSatelliteRoversSTRIPS2.522.761.782.32Durative2.662.862.013.37Table 14: number table represents average ratio planning timeVHPOP using four flaw selection strategies concurrently planningtime VHPOP fastest flaw selection strategy.temporal POCL planning made practical using heuristic techniquesdeveloped classical planning. idea using POCL paradigmtemporal planning new goes back least Veres DEVISER (Vere, 1983),first demonstrate effectiveness temporal POCL planning larger setbenchmark problems.hope success VHPOP IPC3 inspire renewed interest planspace planning, made source code VHPOP, written C++, availableresearch community online appendix others build effort.7VHPOP performed well expectations IPC3, see several waysimprove planner. Speed, mentioned Section 5, principalweakness VHPOP. code reachability analysis satisfactory, currently generates ground action instances performing reachability analysis.often leads many ground action instances generated preconditionsfinite heuristic cost (according additive heuristic). believe VHPOPcould profit code reachability analysis well-established planning systemsFF. could also improve speed better scheduling different flaw selection strategies.would like see statistical studies, similar Howe et al. (1999), linking domainproblem features performance various flaw selection strategies.far considered using different flaw selection strategies. However, running multiple instances VHPOP using different plan selection heuristics could equallyinteresting. have, example, noticed using additive heuristic without accounting reuse helps us solve two problems Satellite domain. would alsointeresting FF heuristic implemented VHPOP see well performsplan space planner, possibly using local search techniques instead . likely,however, results local search topology FF heuristic state space (Hoffmann, 2001) carry plan space. many benchmark planning domainscontain actions whose effects undone actions, plan operators causingtransitions search space plan space planner different actions definedplanning domain, effects plan space operator generally irreversible.would likely need add transformational plan operators undo linkingordering decisions. Incidentally, VHPOP started project adding transformational plan operators UCPOP, got side-tracked need better search7. latest version VHPOP available download www.cs.cmu.edu/lorens/vhpop.html.427fiYounes & Simmonscontrol, research transformational POCL planning suspended.recent improvements search control POCL planners, may worthwhileconsider adding transformational plan operators.addition considering different search control heuristics, could also instancesVHPOP working lifted actions instead ground actions. Recent improvementscode significantly reduced overhead maintaining binding constraints,making planning lifted actions look considerably favorable reportedearlier work (Younes & Simmons, 2002). Planning lifted actions could beneficialproblems high branching factor search space due large number objects.would also like see support numeric effects preconditions future versionsVHPOP. would make VHPOP fully compatible PDDL2.1. alsomentioned need plan ranking heuristics better tailored temporal planning,VHPOPs performance terms plan execution time domains durativeactions approach performance best temporal planners IPC3.Acknowledgmentseffort sponsored Defense Advanced Research Project Agency (DARPA)Army Research Office (ARO), contract no. DAAD19-01-1-0485. U.S.Government authorized reproduce distribute reprints Governmental purposesnotwithstanding copyright annotation thereon. views conclusions containedherein authors interpreted necessarily representingofficial policies endorsements, either expressed implied, DARPA, ARO,U.S. Government.ReferencesBitner, J. R., & Reingold, E. M. (1975). Backtrack programming techniques. Communications ACM, 18 (11), 651656.Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. ArtificialIntelligence, 90 (12), 281300.Bonet, B., & Geffner, H. (2001a). Heuristic Search Planner 2.0. AI Magazine, 22 (3), 7780.Bonet, B., & Geffner, H. (2001b). Planning heuristic search. Artificial Intelligence,129 (12), 533.Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism planning. Proceedings Fourteenth National Conference ArtificialIntelligence, pp. 714719, Providence, RI. AAAI Press.Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49 (13), 6195.Gerevini, A., & Schubert, L. (1996). Accelerating partial-order planners: techniqueseffective search control pruning. Journal Artificial Intelligence Research, 5,95137.428fiVHPOPGhallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporalplanner. Hammond, K. (Ed.), Proceedings Second International ConferenceArtificial Intelligence Planning Systems, pp. 6167, Chicago, IL. AAAI Press.Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). formal basis heuristic determination minimum cost paths. IEEE Transactions Systems Science Cybernetics,SSC-4 (2), 100107.Hoffmann, J. (2001). Local search topology planning benchmarks: empirical analysis.Nebel, B. (Ed.), Proceedings Seventeenth International Joint ConferenceArtificial Intelligence, pp. 453458, Seattle, WA. Morgan Kaufmann Publishers.Hoffmann, J., & Nebel, B. (2001). FF planning system: Fast plan generationheuristic search. Journal Artificial Intelligence Research, 14, 253302.Howe, A. E., Dahlman, E., Hansen, C., Scheetz, M., & von Mayrhauser, A. (1999). Exploiting competitive planner performance. Biundo, S., & Fox, M. (Eds.), Proceedings5th European Conference Planning, Vol. 1809 Lecture Notes ComputerScience, pp. 6272, Durham, UK. Springer.Joslin, D., & Pollack, M. E. (1994). Least-cost flaw repair: plan refinement strategypartial-order planning. Proceedings Twelfth National Conference ArtificialIntelligence, pp. 10041009, Seattle, WA. AAAI Press.Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,stochastic search. Proceedings Thirteenth National Conference ArtificialIntelligence, pp. 11941201, Portland, OR. AAAI Press.Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Mellish,C. S. (Ed.), Proceedings Fourteenth International Joint Conference ArtificialIntelligence, pp. 16431649, Montreal, Canada. Morgan Kaufmann Publishers.McAllester, D. A., & Rosenblitt, D. (1991). Systematic nonlinear planning. ProceedingsNinth National Conference Artificial Intelligence, pp. 634639, Anaheim,CA. AAAI Press.McDermott, D. (1999). Using regression-match graphs control search planning. Artificial Intelligence, 109 (12), 111159.McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2),3555.Nguyen, X., & Kambhampati, S. (2000). Extracting effective admissible state spaceheuristics planning graph. Proceedings Seventeenth National Conference Artificial Intelligence, pp. 798805, Austin, TX. AAAI Press.Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Nebel, B.(Ed.), Proceedings Seventeenth International Joint Conference Artificial Intelligence, pp. 459464, Seattle, WA. Morgan Kaufmann Publishers.Penberthy, J. S., & Weld, D. S. (1992). UCPOP: sound, complete, partial order plannerADL. Nebel, B., Rich, C., & Swartout, W. (Eds.), Proceedings ThirdInternational Conference Principles Knowledge Representation Reasoning,pp. 103114, Cambridge, MA. Morgan Kaufmann Publishers.429fiYounes & SimmonsPenberthy, J. S., & Weld, D. S. (1994). Temporal planning continuous change.Proceedings Twelfth National Conference Artificial Intelligence, pp. 10101015, Seattle, WA. AAAI Press.Peot, M. A., & Smith, D. E. (1993). Threat-removal strategies partial-order planning.Proceedings Eleventh National Conference Artificial Intelligence, pp. 492499, Washington, DC. AAAI Press.Pollack, M. E., Joslin, D., & Paolucci, M. (1997). Flaw selection strategies partial-orderplanning. Journal Artificial Intelligence Research, 6, 223262.Purdom, Jr., P. W. (1983). Search rearrangement backtracking polynomial averagetime. Artificial Intelligence, 21 (12), 117133.Refanidis, I., & Vlahavas, I. (2001). GRT planning system: Backward heuristic construction forward state-space planning. Journal Artificial Intelligence Research,15, 115161.Schubert, L., & Gerevini, A. (1995). Accelerating partial order planners improving plangoal choices. Proceedings Seventh International Conference ToolsArtificial Intelligence, pp. 442450, Herndon, VA. IEEE Computer Society Press.Smith, D. E., Frank, J., & Jonsson, A. K. (2000). Bridging gap planningscheduling. Knowledge Engineering Review, 15 (1), 4783.Veloso, M. M., & Blythe, J. (1994). Linkability: Examining causal link commitmentspartial-order planning. Hammond, K. (Ed.), Proceedings Second InternationalConference Artificial Intelligence Planning Systems, pp. 170175, Chicago, IL.AAAI Press.Vere, S. A. (1983). Planning time: Windows durations activities goals. IEEETransactions Pattern Analysis Machine Intelligence, 5 (3), 246267.Weld, D. S. (1994). introduction least commitment planning. AI Magazine, 15 (4),2761.Williamson, M., & Hanks, S. (1996). Flaw selection strategies value-directed planning.Drabble, B. (Ed.), Proceedings Third International Conference ArtificialIntelligence Planning Systems, pp. 237244, Edinburgh, Scotland. AAAI Press.Younes, H. L. S., & Simmons, R. G. (2002). role ground actions refinementplanning. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings SixthInternational Conference Artificial Intelligence Planning Scheduling Systems,pp. 5461, Toulouse, France. AAAI Press.430fifffi! #"$ %'&)(*,+-(**.0/21 .354'166789:; <)*30=*.!>@?9 %&<A1 (0=*.BDCAEFEHGJILKNMPORQSUTVTXWYPZ[A\U]_^,`ba2^Jcd^,egfh)f2i0jAelkmcRZonpjgqr`tsufvh)fvi0jgewyzNx {}|~dLz)zNd2dffff$dA$N$oL0;0ud;0mv0}@55@N#@)}2Nv0Pg8vgJ#,)}#-@R@g52Rg5;-@0P$ff5;-0!d}80gP}@5P;@A50dd)505v PP}ff-@5 8@,}m;gP55P5ff!-@u!5088}!ub-@P588@mN0858;@0P}5@$2t };,Nfffi$}@}$8fifi@fifi}A}$ $$$fi"!#8%$5&fi'$fi$( }))*%+,'fifi.-/0'1*%"+324fit}35fi@$@3+6}}87$ff924fi u5*9ff','2:+0 6*;}$* 6<fi$ fi=>$ ?@@@8Afi +6 }$'>}$B2"AA'0fi A1C $ A@;Dfi%+6 }$'> 2EAF-;/4t}J =fiAmfi@AGfiC *3*%@&fiH*%0fi'?fi$ fiI2J@&fi% Kfi Lfi"fi}$ ffO'N @QP RESTT!U $WVXA 0 }6'YfiC *;*%@KfiZ&fi [fi'Yd+ fi'\Bfi5fi@> }$]fi@t* fiA^ fi _R0fi>$=*}0 ) ' *;t* Nfi fiA*%}$@ '>@1NR }3fiG.fi" }$$ ff" ;fi*%+,'fifi _u}$` 3aMb<cedf c ff b<c Yg 2FvhR/0J( }$60ig*i>+fim}$$ffR( iGiPLjR#2R'^+,@ fi@8ffk>+0 l*3 }$ }>fi6*3m}]k*%@} D6_ *%+ >?Ln+,' >* }m8vR }$Yt*9+ff'A?7AA1Ofi okp+0 q^5]Nr *3t* lU $0fi fi 3+0 6A*3IHfiut"$v(=w&7yxzL( } B)) KfifimNF{Y'i"'* fifi'RJSTTTKU -|(JiP}j3v ~2E@[D@fi9 r* 5*9,'8?fi +6 }$'>'R1'fi1 >6'Jfi .fi" } ff42@@ %fi*%+,'fifi .\t* fiA1fiGw5fi>A+6;}$;tPL7'fiP @24fi|fi15+ff-A@fi>*3'R,0D'fi1C fi &fi'Rv}$u8+>Y'^ fi2E'fi6@.#R } fi$ A1 $.Vfi*@Afi Kfi |fi;( iGPp5'6*%@Kmfi Efi;$ *I7+,'fifi LNr '>5'RlSTTj~U )- fiGfi *%+,'fifi _R56 }&fiJ8fi@E2J'&fi0 @'?$j-4*%' AG6@&fiNr }$6fi Zfi 3v N@}Z6@&fi US5-4tfi 424fifi!5-4t"6Afi 1;+l }*%'fi>A'-) Kfi 5 4>$ }/0&fi0 N6fi 4fiM@fi>+6+ff@>@[fi C,@[51Bfi)2 B* e>fi'> 8\%2"'fi'fiI36rFfiG5fi@> M,fi0fi@u'@1 }$Z2"'fi'=fi'1M,2 @@6Gfil#(**. N %% !<5#&0%% 0<fiffff$@ 3kp@AAfi?%+06A*3m8-u))*%+6fi0fi$ >'fi6'*%@fiC^M+61@'90A-C$$'@_R2"AfiIfiMfiA*%0fiZ fi9*%+,'fifi.RJw5fi>+lm}$et"iP+l}$$2E'2J?.$ $'>fi }$'^' _ *3+6fi0fi$++00$}Z,'@'^+,@.Rfifi*%+,'fifi LD@fi@L8fi@Gfi$fi A*%@Lfi +6@&fi'2D fi $AAfi4fi fi'2) }K1'v+ fi@I+6 }$'> I$ }$6-{+>'A1R246AJ *3+60fi fi $ +6+0 >nJ @24fiU&*3'>A6@Kfi }$ fi @24fiUfi 63$^C,'@]fi @@*3|fiA*%eND- -R5'R jxxz594 &0fi }@PK$ Afi'R jxxx5 .* }$_R"STTS5mv >ACPG$ R jxx5w8*3AfiPB.Rjxxx5I} >.R4{ >A'R{|>'fifi 8R0PA q }_RSTTT8g A*Pv'RSTTj~U R_+ + A0@;24fi 6fi >1+6 }|*3'fi>A'P}$C Kfi 5 G $ }%$ ^I,'@*9' @2"fi* }&fiA'0fi }24fi *%+l0fi fi [ND- -R,{|'i'>t* fifi'R.STT!U w5'fifi'2o $ A@4Zfi>**@' fi15+,+l }$ $90fi 80A01}$Yv+ fi^fi96.dR Afi Yfi'u>fiP2EAF-4t"$+6 }$6 R6AA9t"$0fivRlAg6 ZX'+6$ }&fi'VR }$+ }0 3>*A_ *3*$ Afi1ZAv$ $Zfi 3,*%9~y2 }$ufifi'>@@ >'% N5bbfi LJR$ fi9fiMfi>$ l;R }$ Cfi fi9fiM0fi AF- 8'IAA*%v+ 0fi }&fi'R }; 5'6J@fi4 >A'J?<'^@Mt*GA*%v+ 0fi }&fi"Nr'fi4+ }EMw8tn/^8"*%+6,- -GE'Pw8A* .RffSTT!U -t &fi 5 Dfi4 |fi;X+60 6*fi @,90^@.VR24?4q24 @&"'8 Z =t*Gv+ ~2E'r6t*A)}$++6?A fi J*1 Ab'fi'fi''* fi tl q24@fi$ fi<?;01I >6'^5 +0 }>'-n/0=fi }>fiw8tno/ }$)0w8(H @D0 *fi@fi fi@ff,2 ;fi N;* }&131@>=lfi fi'1;,2 @$ ~^+0 61I0fi @Z* }K13*R,fiG *3*9 fiJ$}$.VfiJ'+)fi 8',;fi" >A0+ 6*3fi3,^@_'24AR8>A@E*%6ff'>@Kfi=')}$M*%P*"d A0fi } fi'>'- {7~^'~R*%3* ~1|,I2J?7' @C* }&fiA AA1u6Pfi fi *%+60fi fi $A1-4- -R Z2E8+,fi'rv }$@'8 _ *%+60fi fi $_*%'fi =fi$ fi424AAl,2 >@ 9lB3r FqC{ fi0AA1fi'm\ } ++0 O0fi l>@> $fit}<24Afi *3 A** &6*,'fi 'R* 1fiI,} e %@Lfi}2"fi*; A**>>*%+fi %24fi L* 7*r* 5*9ff'}N '-@/4;* ~1B,; *%+6'fiA1 ff'@&fi *%+l0fi fi $ +0 6*;G'^@=fi>A+fi [? ^'1O?*3A @ND- -R.fi fi v fi9'+6 ' $ } }fi O>O51*fi+6?A fi |>Y Yfifir$ fi ) ZA @+0 } *MU - $y, @+l }$'G }L0fi 83@'>?4+ 6*3'RK2JG 3+0 61I,"+ff)fi v fi fiG5$ Afiyt1 .fi0Afi Jfi $'R*tfiA1@AA1R8AfiEA*~^8 0*Afi @fi %fi8fi9ff8CNrF--R24fifiA* fi+l }Lfi U -3w8A*3A >1R62"Afi fi>fiP^@L51|fi%* ) fi B fi+60 ~^8A*3+6m}$++60 >$ lu@' A@ fi J' +6 }$ dR } }$ }}P}$Afi^fi>W7fi32"A> fi Z fi'+,@$$,fi1 @fiPfi M6fi ?u@fiW@2"A>;fifi @A;R5An'61*@'fi'-g *%1R&fi@'fi1 $6 +6 }*$ }@.R6fiGfi$@'fi1Y L $ }NN+fiA* +6 }G@R24fi$ Pfi }+> >4fiA* fi >R$A=v$ @fi @'*%+6'fi+6 }Dfi'A }fi'~, Fr zl z5@~l#{z&<dou~d#{K#z {/0L}fi 5*%'>AM6@Kfi}sfiA*%us(JiGigS5-Aju?O@>6Z*t~^Yfi$fiA*;%fi>+ 8 fi0@fiAfi@&fi 5*,'J.+l}$'>0ND--R#"P$A_Rljxx5lw8*3fiPB.Rffjxxx56 ;',fi F-RSTTTKU - AA0fi'VXfiJ+v6Afi8+,6fi>1I6fi&fi,'fi2E'@fi g}$l G^ 6GY*%nfi+6 }$'>'Rfi9 AD fi $AAfi1 }$*%+60fi fi $< $ A@u3fi'>-Mgt OA*%v+ 0fi }&fi *3A>B O*91L^5A'2AGfil@>qfiJGG K8#}Cff=)lq}d8+6AA'fi@8 >"'+dfiZ0*FfiH+}$e+fi$fi6'-B0%H>@6A}$*%;+l }$ $Z15fi*;@ND- -RnA8 'R jxzz5=)=>A;P/ fiR=jxx8jE +fiAfiRR( +ffRPfi@.R8STTj~U@Mfi'fi'>*;fi'^v E l'8W'l'Mfi$ fiAA q2J@+ 6*0- -R_AJ%)2'>t~^ 6vR }$Cfi'b9Z0fi 8fi$ fiG5IS;)2'>@ .R.fi@fi* fi=P! ,fi"0fi 5E}3,8'fi@Z '>@Kfi1- fi'24ARKfi0>'@@3'@fi+ 'fiy1-[/0?9A}H*%+6C*96fi7 + 'fiy1R @')2 6A@0>) fi'Ifi15+ffb>u *3t* ND- -R= $1O0>'RE* lZ>R'fi~U -H5$ s(JiGgi S5-AjR>P'@Cfi M,9@N@5*%'>? 6@&fi'Rv}$Yfi%1N&0fi <fiu+,' fi >Gfi0*%Aff'@;v+ &^@Kfi 6Nrt* >v finfiA,q2U R'fi'>*;fi4A'^ff 6'@1q2J@_-<5$ *91Z^5A'2 RfiA>fi$ $fi0fi'>@'\218 WrF>RE,u5+lAA'fi3}Q,Z5+lfi@Q*%+lfi0fi$AA1 Bfifi@'#&*3'>A6@&fi0}.Vfi'R36rF>R",C8+6AA'fi;>M+~^8}o'$&fi'>@1Qfi$fiZA>A*%+6}$'A@}.Rn*%'fi$|fi$fiI}$fiI,@0 vfifi@>* 4'>@1O(JiGigHS5-AjG+6+l}.R}$lWyffrDRff6%5+lAA'fi">R24fiYfiA*%R+0~^8fit$fi8#@'7?@fiL}$|$6fi +6}$}$u@?'fi"0fi0fi424Afififi4A>-J4>9@fi @&fi0 fi'^6'@1*tB0fi 5'\uA48+6AA'fiA1 ' *3t* $fi@fiu }$ ffREfi'1 .Vfi3$ ~^ufi ++,@3fi C+u"v+ fi fi ufi}FA- $>>@ @46@Kfi'Rfffi+v+ fifi>-</04fiJA<fi$ fi'R$ 6n0>fi* fiA A13 @KfiA@%51* }$18A'R+> =*%> }A*3}$ q2J'v $ $2'^+ff@$ }$A J>>END- -R v >RSTT!U}.Vfi0,@.'24ARfi' 6fi " '@61O [fi' *309A9fi }+@&fi'-Ct'fifi J};,5'fi@@ '>@Kfib1 fi fi?*%Alfi>>,'@@%519fifi ,fi8'@9fiJ d+ 'fim1 ~^ ? 6fi -<Pfifi'$ }$.R# (JiPS5-AjR 9 +l+6 }.Rqfi'^N 6 '@1?' @A*%+6A?'fi1" fi'>*;#lfi" 66+)}$v+ fi $fi '-$+l+6 }.R& =*%+6R8fiy,2 t+,' fi >}Z,"5'fi@| '@&fi1;A.fi'1 _VfiE &fi'D'24fiO@> fi'<F--R&uufi'fi;+>$fi 6P9v+ fiA^%fffififi'( iGPS5-Aj5fi@$6fiA'd fi t5*,' )2 ~15'R60fi 5 $3 Kfi ' Kfi0fififi }$Mfi&fi'^ ?~^'0246A>M+fi =$~^fi %,G+'^@_J- 4A*3+6AA'fiy1RK$WVXA5' +6+6 }.VXfi 6'@1 1RA@^8 %fi5fi@>) 6'0fi= 5>5" > }$ufiu)fi 4u#5KNrl>qU }uu#5&Nr6>q5U4fi$ fit* ~^b6 8uZD0 *Gfi Mu}$|M+fffiA^1-)=@1R6fiufi G}$$fi4,u9 '>@KfiA16 8%}$fiJ,0t* ~^@@fi fiy,2 b,'@&Jfifi $fi Jfi fi"0*%4fiA*%-n/0't14 $'@*fi: +l+6 }}'N }$( iGPS5-Aj~U Zvfi$ ^e+>$fi Nr# Nr6>'UU@fi$ fifi'1'fi-;<'fi'R24K1L6'fi $L+$6fi } fi Y+6'^@Kfi } fi KD0 *,8'fi@'@&fi1%fffifi MIfiv'fiJfi0+6$fi lZ/0fiA6 fi4fiAAfi 6'@1u'^','@u* }95+6?A'fi'-E5$ YG +6+6 }ufi02 A}$+fi@,;Afi @>fi$fi'> AA@ fi u'ufi '@&fi'RR ++6AA ltfi >*++6?A6}$H18Hfiu0*3fiuNr=A*P >fi'RGjxxU -Q<'fi'R=24&1H efi?%0*%>fi' Z,fi* fi4 &^@@&fi" Ifi>1M '@&fi4'fifi &>fiffff$) 6' ~2Hfi)fi u#5KNrl>qU }$u#8KNr>>_U24A)gfi Kfi'>'}R }$9fi5'*%@3'>@Kfi'-n/06AAJfi,*%+6fiIfi*4A6fi5*9,';l0vfiJ>*;<A@'@KfiA1R&6fi A<6fifi'24A- .4fi4@N6}@,08@351+l1824fi;fig+ff'8 fi >'8- -R 3fi"+>@g9>*R&fiG~v5'q6~v5'3@6 N )2+0 q^5Jfi= >Jfi *3+fi l '@1R2"AE fi+@lfi'>*3'R>A*3A@ R&t*4 &}^ ^@.R&,2 6 %,0v+ l)J2EAF-5$ }&13R5fi' $ &)fi , 6'@1@ fi Z &fi''>@g'd @; Z +6+6 }}@(JiPOS5-AjG >AJ'0fi M?*%+6AA'Afi6*%+fi ,}$MfiG&fi @? 24'fi'J2E)2 }&fi=fi*fi$g>*%+fi 'R}@2"'fi'fi'1@0$6fi'/0b' Kufi E '@1Y@ B>>A*%fi }+d@Kfi LfiAG@R }$*9>AfiA9* fi C 9 *%+6fi $MD@l9+l }*t%8+6A?'fi'-9/0' $ Kufi1+0 q^5t}NN'6?Afi1R fi $ u u'0fi | &fi5fi}$fi0>'+6fiu'@* >m@' fi8 KfiIND- -R,fi M1ufi$ fi0 v Afi *34}$$fi A?G }$gfi'fi"fi N'qU%MO b<cH ffcR/0ufi>A<( iGiPsS5-AjuI*tfi^fffi@Y&1fiu} k'@fim+C,'fi2E'@Y+l}$$@ >b}$b++6A? fi m8-wfi'1 }$fi 6@,++lAA fi R~fi'1 +6* l1*%@}fi$ fi"fi'1)2 }&fi"(JiGgi sS5-Aj9fi @$ ~^}Y 6@|+l }$ $>@>>_Rfft* q^5 ;fi ~)2 ~1uD0 *fi~1* 6fiq)2 H>@AAfiA ++6A? fi '-|AZ } 8pfiIfi Lt* ~^Zfi ~2 H@?AfiA++6?Afi 'R51'fi'R$Jfi ffRfi'VX'rfffi %''+| Z*3 @fi fiGXfi ~1* 6'V5 ^'>^@Zfit4$(< 6*Nw A^5 $Z *;*9$ 6fi1L^'1B2EAF\wA $@+6'B">?fiA;w5@> .Rfi8 7 fi'@B)) fi8 Kfiw fiA'fi .R.= 88 > L |(J }$ R6'fi- /0'1u$ ^I+0 q^5 @| 8''R2}$'+fi A1>A*%+6M+0 l*3Ifi$fiu *3+60fi fi $?1 $ A@%2J?F-s/0AI*3- HA&^@@&fi @&fiD15 $E?*%+66fi,v+ ~2E'r @\>?fiAfiA* fi >Rq+ fifi'8 m$0fi'Rfi8 Kfi+60 + fffi }$ , fi &fi'R$}$0t.-n$ ,'^GfiA=2)fi8 R8D0 *fiA+,'>+fffiA^R24'fi'J fi ~1I+0 6A*A0= 88n > 3?8$ 6fi@.-$yfiJ'@>1*<};+'RK6fi $ ~^42E"@8 @%fi 90^0fi"+0 6*}2EAFR5 tm$* 87'+,@$@&fi' ff$vP$fi'R2JC* 1s,|fi?A0*3A>O*3|r$ $$*%@&0fi 0 @3fi$ fiYAA1Hfi [,'@@>A'0'fifi $A%D@fi> 3 *%+6&fi' fi 0ff'fiy2J'@fi +6}$v+ fi $6fi 'w8 +0 l*3[* fiLDfi@&fi 0fi 6R1'fiCfi[+ff'> >* }+o,'fi2E'@@'+6 }'>}$+,' AA'@:0^'>Z* 0Rfi++6?A 6AAAfi1 +6 }$ [fi$ }124A?>* OA?*3fi@.-%/05246A%fi A+vAfi^}$>01Lfi*;0 * B( iGPo}$fiG( } 9)) *3+ff'fiAfi 3*G *%+63+6 }$ }$ ff}$@0fi 5R5$n,AA'^4fi$ fi=fiAA00>1Mfi @ @&fi1 }$u* &0fi LI 8'u*3*%+l0fi fi $.+60 6*3/0; *%+,'fifi }$[fi9+v+ fi }$ ff? ^@@>'>}$O+6 fi7fi' } @fifi0fifi.\24$ fi8 $ +0 6*;E}uff*@}$0^@.R24$ fi"5 $ }$C'u<+0 l*30}C,9A^@|2EAFRl24$ Afi +6+0 >"2)u,fig}$Y24@.R}$ A0Z$~2' fi q2fi%LAG+60 }-9( 0 }*%@}6,'fifi' Afi 6BfiA*%R }9l u}fi .ffR *3*3fi*%@&fifi P+fiA* AAfi1 A*}R+60 }*%@}*t>Jv+ ~2E'r"!$#%'&)(+*-,.%0/#2134 65 #%'&7(*8 :9;*<:#=> *?&A@0B54C/:>@D/71EA1F@G*?/ HI@G5 #KJ @0/<LM/ *<%JE/& :*-HN &7@0/ A1EA1;5'L;@0& %E*I#2(?9;%D=+2EE'O @G' E@0P1;&:#A@0 C5 #%'&7(*:RQIE8/:*<JE#SI*$P@D@0#2#PE:*<8@G& %E*IHN#2#54C9"JE)T3-U9;#2@0/#SL'4 6@0/9V&A@GW54C</A@0A1W@0*X@Y/ *<%JE/& K@GP1ME:F@G##R@G& %E*?/AZ'J S/ 6@0/9[HN#2#54?/:@0/71A1M@G*N96JE T\ &>fiJGG K8#}Cff=)lq}d@0"+>$0'4+>fifi9@ >|+90D1}$,fi^1- ( /0*3+ff'fiAfiI' <$ ~^0 Kfi>A6fi@Ifi fi}?'R}$% fi?21R5$ ^" Kfi>A6fi@Ififi=+0}>fi}$Zfi ;Afi=*%+6>?0 $ - w5fi?AFR& >@,G0fi @u%fi fi0fi>}s,~2 e0 * Dfi*3+ff'fiAfi t%2EAF-et ?@>&A*%@&fiI fi+@+v~2E'r6t*}$ ff=6>=(JiPOS5-AjRA fi'd+ fi"fi" >Ar$ fi $?fi<&fi,'@&fi0fi >5@fi$ fi4+l }$'>Au$fi4'2 @1Z51fi" q^' ffR_6fi A@&1u q22EA=fi'1 H@]' "0fi 8'-]t=fi;fiu0*%ufi?*%ufi%)2 H,'r=fi Afi A>fi >5Efi$ fiE'fi=* fi"@> M0 *fi >5Efi$ fiE@fi">@>>fi };@13fi0ff- gt $+ +l $4fiG 7* ~^8 70fi 0'fi<V fi0@}bfiA'RK$fi fi$ fin2J0>* &0fifi3 8'[fiuX >A%+0 l*3Gfi|,;0^@.V }$[Afi fi;t"$03fi Ct* ~^Ofi'2+0 l*30NL4fi> $ff+0 6*;=ffZfi ; ff-] _c ^pc cc'>5'RE-4NFSTTj~U -s/0uSTTTOt"$9(J}$Lw518fi*3;)*%+,'fifi.-a`r bJ'FCc 6Ded5lWf[+dKE gDffNR h3hNF!U +fiAfiRn(-RnR( +ffR )R- <-R<P fi@.R-0NFSTTj~U j- inrp6l km#'>anl >8DK dKo"`=lKinWrD6C p=D dII du nl 8K dp=KA -E A&2J'~E'R i- <-R PwAt* .R <- NFSTT!U /0w8t"/7T! ) *%+,'fifi .&fifi+_\q20242 -X>F-DW4 qG>At* l# &fifiT!q6fi=A*Rt9-R#P >fi'R#{O-8NpjxxU - $fi+6 } Efi0 +6 }$ +6}$A15?'-5$ Bpp~ >>DKrscGtIiN`scGkAu\vR++-,+j w4! wxl+j w#KS5-{ 0 }Y r* }$.)=>>Rl3-RP#/ fiR_t9- Npjxx8j~U -;"7+6 }.\./0u+,@L+6 } >fifi- `GWr bJ'F c 6'z kd5lW8R v4hNpj~U RffKx x54z w5ffRJ{[-R<PRni-4NFSTT!U -H( iGPS5-Aj\ gt e5fi@>Hfi B( iGP%8+>Cfi*%v++l }$ $* '-{t8 l: rs`sc}|4W'> -=/0A=A>gA*R(-RP2'R-NFSTTj~U -B4AfiA%+l }$ $24fiOfi?*%}[0>'-u$ ~p=8p Vin+ r'''l IA rsp=DK dlWiNp{kD4#R++_-_jS8Gj xlj!S5A,* }.R=-NFSTTSU -J 5fi@$6 Rfi 5*%'>? 4fi0fiLff^ > 6-5$ p= : rC\v8p Vin+ r'''l`Wr bJr c lD d&'llWiN`scGkA h+qR++_-65Gj x55 6.Rt-RnL}{ >>A'R(-Rn{|6'fifi 8Rn-RnP q0 }.R3-ENFSTTTKU -B( } u &fi'+6 }'0fi >1+\6/0>1 }$u+ fiA-<$ ppE `scAp{n_k h\\R++_-_j~+ xlj4z w55'Rn-0NpjxxzU -s( }$ C$ $'I0>fi Kfi'-5$ ppE : r4 =8pWin+ r'''l 3 `cWiN`scGkAu4>qR6++_-8Kzx xKKx!5-,:AA'1v>AR(-4NFSTT!U -]t }>Afi*3;+0 + fffi $B>u 6fi &fi%st"$+6 } }$>>@6A C- `r bE'F$ c 6'e d5lW R 'RRj8Gj xljzz5v>AR#(-RKPG$ _R{[-6NpjxxU -l(J }$ 424Afi>$ 6E>nfi Kfi'-$ %{u?AA.R)G-Nr .-U $R pp~ 8cGtiN`scGk:u\vR++_-_+j w#K! xl+j w#Kx5-_L{ }Y* }.+$UE@De:#SLE /"9;:@G * P@DX@0-#2:@G*lX%G "%GOE9Y@G#*<%#JE%F*"408O/J EA134E2*?JP@D/7@G':62*? %G? ::1EA1MHN?%OE9Y@0#2SzL}/:Z+JES/:9;:'* 1/%OEO4A13>Efiffff${Y'i"' *tfifi'Ri-.NFSTTTKU -n/0jxxzIt"$ ( }$Iw515fi*3=)*%+,'fifi.-?`GWr bJ'F_c 6Ded5lWf[+ dKE gDffNR hNFSU R.! x54 w5{Y'i"'* fifi'Ri-JNFSTT!U -;/4>* n* }&fiA'E+0 8L(JiP-%5$ ppE cPiN`p;n_kDPY0 q WH pCMMR8++_-6z+ x5x#4 K0fi }@_R-RP$ $ fi'R59-_NpjxxxU - *%'>Afi0fiff^ > lJM 6fi &fip7@Z+6 }$$ ppE=8 >Vin+ rffp6 dlWiNp;k:u\u>qR++-_j'Tx xljS8jw8*3Afi.Ri-R P B.R<i-0NpjxxxU -s/*3+ 8 J+l }$ $|24fiH*fi$ E'Ae@0 -O$pp~ 8cGtiN`scGk:u\uR++_-6!4S wx5!!&A8 'R#i9-6NpjxzzU - pp~rr p6 d3oR ff d9 G'#>Wr `sc8 dI-_{[-r* }$.->~fiJournal Arti cial Intelligence Research 20 (2003) 291-341Submitted 10/02ff published 12/03Metric-FF Planning System: Translating \IgnoringDelete Lists" Numeric State VariablesJorg HomannInstitut fur InformatikGeorges-Kohler-Allee, Geb. 5279110 FreiburgGermanyhoffmann@informatik.uni-freiburg.deAbstractPlanning numeric state variables challenge many years,part 3rd International Planning Competition (IPC-3). Currently onepopular successful algorithmic techniques STRIPS planning guide searchheuristic function, heuristic based relaxing planning task ignoringdelete lists available actions.present natural extension \ignoring delete lists" numeric state variables,preserving relevant theoretical properties STRIPS relaxation conditionnumeric task hand \monotonic". identify subset numericIPC-3 competition language, \linear tasks", monotonicity achieved preprocessing. Based that, extend algorithms used heuristic planning systemFF linear tasks. resulting system Metric-FF is, according IPC-3 resultsdiscuss, one two currently ecient numeric planners.1. Introductionplanning community long aware fact purely propositional representation languages, particular STRIPS (Fikes & Nilsson, 1971), well suitedmodeling various phenomena essential real-world problems. particular,modeling context dependent e ects, concurrent execution actions di erent duration,continuous resources awkward, impossible, within STRIPS language.overcomerst limitations, Pednault (1989) dened (nowadays widely accepted) ADL language, amongst things allows conditional e ects (e ectsoccur condition holds true state execution). overcome(one of) latter two limitations, various proposals made (e.g., Ghallab& Laruelle, 1994 Koehler, 1998 Smith & Weld, 1999). recent e ort direction PDDL2.1 language dened Fox Long (2002) input language3rd International Planning Competition (IPC-3). IPC series biennial challengeplanning community, inviting planning systems participate large scale publicly accessible evaluation. IPC-3 hosted AIPS-2002, stressed planning beyondSTRIPS formalism, featuring tracks temporal numeric planners. articledescribes approach behind one planners participated IPC-3, Metric-FF.Metric-FF extension FF system (that handle ADL) numeric constructs.Currently one popular successful algorithmic techniques STRIPSplanning guide search (forward backward, state space plan space) heuristicc 2003 AI Access Foundation. rights reserved.fiHoffmannfunction, heuristic based relaxing planning task ignoring deletelists (i.e. negative e ects) available actions. heuristic value searchstate framework (an estimate of) diculty extending state solutionusing relaxed actions. idearst, independently, proposed McDermott(1996) Bonet et al (1997), widely used huge number variations.Examples planners use idea Unpop (McDermott, 1996, 1999), HSPvarious congurations (Bonet & Ge ner, 1998, 1999, 2001), GRT (Refanidis & Vlahavas,1999, 2001), MIPS (Edelkamp & Helmert, 2001), STAN4 (Fox & Long, 2001), RePOP(Nguyen & Kambhampati, 2001), Sapa (Do & Kambhampati, 2001), FF (Ho mann,2000 Ho mann & Nebel, 2001). search paradigms used planners includeforward backward state space search well partial-order planning. forwardstate space planner FF especially successful IPC-2 (Bacchus, 2001). followsextend heuristic idea STRIPS, ignoring delete lists, numeric state variablesway preserves relevant theoretical properties STRIPS relaxation.phrase properties admissibility, basic informedness, polynomiality.investigation takes place setting forward state space search used FF,seems likely ideas also work search schemes plan-spacesearch (some outlook, Section 8). Sapa system also dealsnumeric constructs. heuristic function, however, completely ignores numeric goalsthus lacks one relevant theoretical properties, basic informedness (we returnlater). also numeric versions MIPS GRT. respective MIPSversion publication available time writing article (Edelkamp,2003), reader referred to, appear JAIR special issue.numeric version GRT, GRT-R (Refanidis & Vlahavas, 2000), allows restrictedform numeric variables expressions, basically limited form resource allocationconsumption. heuristic function considers resource consumption another formstate cost. This, like Sapa's heuristic, lacks basic informedness, see later.numeric planning task, numeric constraints (in action preconditionsgoal) numeric e ects (in action e ects). Constraints e ectsdi erent types. example, constraint require value variable eitherleast high high given constant. numeric e ects can,semantic perspective, either increase decrease value ected variable. Now,delete e ects STRIPS decrease logical value propositional variables, ideaexplore relax numeric task ignoring decreasing e ects. main dicultyidea ignoring decreasing e ects necessarily simplify task.example, goal requires x < 0 x initially equal 0, decreasinge ects needed solve task, relaxed task unsolvable. relaxation thusadequate (preserves theoretical properties mentioned above) tasksalways preferable higher variable values. call tasks monotonic.1 observetasks belong subset numeric IPC-3 competition language, linear tasks(in numeric variables used linear functions), brought1. duality respect ignoring increasing eects decreasing eects.lower variable values always preferable ignoring increasing eects adequate relaxation.Whether one chooses one seem make much dierence. choose monotonicitypositive sense conceptually simpler.292fiTranslating \Ignoring Delete Lists" Numeric State Variablesnormal form monotonic. Based that, extend heuristic algorithms usedFF, thereby whole system, linear tasks.FF (Ho mann & Nebel, 2001) close relative HSP (Bonet & Ge ner, 2001). Searchtakes place forward state space, i.e., starting initial state new statesexplored goal state found. search process FF guided heuristicfunction based solving, search state s, relaxed task starting s.heuristic value number actions respective relaxed plan, i.e.,number actions needed achieve goal assuming delete listsempty. States lower heuristic value preferred. main obstacle extensionFF numeric state variables extend machinery solves relaxed tasksearch state. machinery dened, rest system translatese ortlessly. evaluate resulting planning system Metric-FF discussing resultsnumeric domains used 3rd International Planning Competition. turns out,Metric-FF LPG (Gerevini, Saetti, & Serina, 2003a) best performing numericplanners competition.2article structured follows. Throughout text refer related workrelevant.rst give necessary background terms STRIPS notation,techniques STRIPS version FF uses. Section 3 introduces notationnumeric state variables, i.e., numeric subset PDDL2.1. Section 4 describesheuristic principle STRIPS, relaxation, extended numeric setting.Section 5 denes algorithms solving relaxed numeric tasks. Section 6llsdetails relaxed plans used implement Metric-FF planning system,briey describe ADL constructs handled, exible optimizationcriteria taken account. IPC-3 results discussed Section 7. Section 8concludes outlines future work. appendix contains proofs.2. STRIPS Techniquessection, give background techniques FF system uses STRIPSlanguage. start examining relaxation underlies FF's heuristic function.proceed algorithms used solve relaxed tasks.nally describerelaxed plans used implement actual FF system. discussionlittle detailed would strictly necessary understand FF workings.serves provide solid background come: Sections 4, 5, 6 will, turnsubtopics dealt section, show methodologiesextended numeric setting.start, give notation STRIPS language. refer setsmeannite sets. consider propositional STRIPS language, constructsbased logical propositions. world state set (the true) propositions. actiongiven triple proposition sets, = (pre(a) e (a)+ e (a); ): a's precondition, addlist, delete list, respectively (we use somewhat unusual notation e (a)+ e (a);makes extension numeric variables readable).2. C source code Metric-FF available free download FF homepagehttp://www.informatik.uni-freiburg.de/~hoffmann/ff.html.293fiHoffmannrst specify semantics world states actions. Throughout article,consider sequential planning only, single action time applied worldstate.3 Actions induce state transitions follows. Given world state actiona, result executing (the action sequence consisting solely of) s, result(s hai),result(s hai) := n e (a); e (a)+ action applicable s, pre(a) s. Otherwise,result(s hai) undened. result executing action sequence ha1 : : : staterecursively dened result(s ha1 : : : i) := result(result(s ha1 : : : am;1 i) ),result(s hi) = s.STRIPS task { use word \task" rather \problem" avoid confusioncomplexity theoretic notion decision problems { tuple (P G):set P logical propositions used task, set actions, initial state (aworld state), well goal G (a partial world state, see below). propositionsactions, initial state, goal taken P . Given task (P G), onewantsnd plan. action sequence ha1 : : : 2 plan (P G)G result(I ha1 : : : i). Since relation (not equality) used here, couldseveral goal states plan ends. exists least one plan task,task solvable. Sometimes refer optimal plans. sequential framework, planoptimal task plan task contains fewer actions.2.1 Relaxing Strips Taskswant inform search plan function estimates goal distancesearch states. idea dene relaxation (i.e., simplication) planning tasks,solve, search state, relaxed task, take length relaxed solutionestimate long solution state hand really is. relaxationrst proposed McDermott (1996) Bonet, Loerincs, & Ge ner (1997),relax STRIPS tasks ignoring delete lists actions.Denition 1 Assume STRIPS task (P G). relaxation a+ action 2 A,= (pre(a) e (a)+ e (a); ), deneda+ := (pre(a) e (a)+ ):relaxation (P G) (P A+ G), A+ := fa+ j 2 Ag. actionsequence ha1 : : : 2 relaxed plan (P G) ha+1 : : : a+n plan(P A+ G).Ignoring delete lists simplies task action preconditions goalpositive. identify number desirable properties relaxation has.later dene relaxations numeric variables properties.Denition 2 Let RPLANSAT denote following problem.Assume STRIPS task (P G). relaxation (P G) solvable?3. opposed to, e.g., Graphplan-based approaches (Blum & Furst, 1997), nd sets actionsapplied parallel.294fiTranslating \Ignoring Delete Lists" Numeric State VariablesProposition 1 relaxation given Denition 1 adequate, i.e., following holdstrue.1. Admissibility: plan solves original task also solves relaxed task,i.e., assuming STRIPS task (P G), plan (P G) also relaxedplan (P G).2. Basic informedness: preconditions goals trivially achievedoriginal task holds relaxed task, i.e., assumingSTRIPS task (P G), hi plan (P G) hi relaxed plan (P G), 2 A, result(I hi) pre(a)result(I hi) pre(a+ ).3. Polynomiality: relaxed task solved polynomial time, i.e., decidingRPLANSAT P.proof trivial { admissibility basic informedness follow directlydenitions, polynomiality proved earlier Bylander (1994). prooffound Appendix A.want use length relaxed plans heuristic function, propertiesstated Proposition 1 important following reasons. Admissibility tells usoptimal relaxed plan length admissible heuristic, since optimal real plan alsorelaxed plan.4 Also, mistake solvable state dead end:relaxed plan real plan either (more below). \only if" directionsbasic informedness tell us relaxation give us constraints free(for example, heuristic value zero goal states). heuristicproperties possibly parts problem must solved regionsheuristic information (like heuristic value already zerogoal state reached yet).5 Polynomiality tells us compute heuristicfunction eciently.2.2 Solving Relaxed TasksIdeally, given search state s, would like know many relaxed actions leastneeded reach goal, i.e., would like know length optimal relaxedplan (this would admissible heuristic, c.f. above).nding optimal relaxed plansstill intractable (Bylander, 1994). instead compute arbitrary, i.e., necessarilyoptimal, relaxed plans. done Graphplan-style algorithm (Blum & Furst,1997 Ho mann & Nebel, 2001). Given search state STRIPS task (P G),rst build relaxed planning graph starting s, i.e., task (P G).extract relaxed plan graph. graph building algorithm depictedFigure 1.4. Note using term \admissibility" way slightly abuses notation, admissibility usually refersproperty heuristic function, technique (relaxation, case) based on.5. formulation basic informedness might seem unnecessarily complicated. chose generalformulation hand de nition easily transferred relaxation techniques, likeones introduce later.295fiHoffmannP0 :=:= 0G 6 Pt:= fa 2 ASj pre(a) Pt gPt+1 := Pt a2A e(a)+Pt+1 = Pt fail endif:= + 1endwhilefinallayer := t, succeedFigure 1: Building relaxed planning graph task (P G).planning graph relaxed case simply represented sequence P0 A0 : : :At;1 Pt proposition sets action sets. built incrementally obviousfashion, starting P0 = initial layer, iteratively inserting add e ectsapplicable actions. algorithm fails point reaching goalsnew propositions come in. happens relaxed task unsolvable.Proposition 2 Assume STRIPS task (P G), state s. algorithm depictedFigure 1 fails, relaxed plan (P G).proof Appendix A. main argument that, two consecutive propositionlayers identical, hold true later layers graph reachedxpoint.case goals reached layer finallayer, call relaxed plan extractionmechanism depicted Figure 2. level proposition p (action a)rstlayer relaxed planning graph p (a) appears, i.e., minimump 2 Pt (a 2 At).:= 1 : : : finallayerGt := fg 2 G j level(g) = tgendfor:= finallayer : : :g 2 Gt1select a, level(a) = ; 1, g 2 e(a)+p 2 pre(a)Glevel(p) = fpgendforendforendforFigure 2: Extracting relaxed plan task (P G) (levels finallayer computedalgorithm Figure 1).Relaxed plan extraction based sequence G1 : : : Gfinallayer goal sub-goalsets. Goals sub-goals always inserted set respective level, i.e.,296fiTranslating \Ignoring Delete Lists" Numeric State Variablespositionrst appearance relaxed planning graph. goal sets initializedinserting respective (top-level) goals. backwards loop selects, layer,actions support respective goal set. goals sub-goals g supported,preconditions respective actions become new sub-goals. way, upon terminationselected actions used form relaxed plan state hand.Proposition 3 Assume STRIPS task (P G), state algorithmdepicted Figure 1 reaches goals. actions selected algorithm depictedFigure 2 form relaxed plan (P G).goals sub-goals supported, arranging actions selected layerarbitrary order yields relaxed plan. proof Appendix A.2.3 FFBased relaxed plan information, heuristic state space planner easily implemented.Choices must made use relaxed plans, arrange search strategy. describe specic methods used FF, ecient many STRIPSADL benchmarks (Ho mann & Nebel, 2001). extended system uses straightforward adaptions methods. dene heuristic function, search strategy,pruning technique. heuristic estimates goal distances relaxed plan length.Denition 3 Assume STRIPS task (P G), state s. FF heuristic valueh(s) denedPas follows. algorithm depicted Figure 1 fails, h(s) := 1.Otherwise, h(s) := finallayerjAt j set actions selected layert=1algorithm depicted Figure 2.relaxed plan state, heuristic value set 1.justiedrst property proved Proposition 1: relaxed planreal plan either, i.e., state dead end sense goalsreached it. states pruned search. search schemeuse kind hill-climbing procedure using complete lookaheadnd better states.See Figure 3.Enforced hill-climbing, like (standard) hill-climbing, starts initial stateperforms number search iterations trying improve heuristic value,state zero value reached. normally, iterative improvement done selectingone best direct successor current search state, enforced hill-climbing uses completebreadthrst searchnd strictly better, possibly indirect, successor. search cutsstates seen earlier iteration, expand statesheuristic function recognizes dead ends. strategy works wellbetter successors usually nearby, case many planning benchmarksusing FF heuristic function (Ho mann, 2001, 2002b). better successorcurrent search node, algorithm fails (more below).nally dene pruning technique, selecting set promising successorssearch state. unpromising successors ignored. promising successorstate generated action helpful following sense.297fiHoffmanninitialize current plan empty plan <>:=h(s) 6= 0starting s, perform breadth rst search state s0 h(s0 ) < h(s),avoiding repeated states using hash table,expanding states s00 h(s00 ) = 1state found fail endifadd actions path s0 end current plan:= s0endwhileoutput current plan, succeedFigure 3: enforced hill-climbing algorithm, task heuristic h.Denition 4 Assume STRIPS task (P G), state algorithmdepicted Figure 1 reaches goals. set helpful actions H (s) denedH (s) := fa 2 j e +(a) \ G1 6= gG1 set sub-goals constructed layer 1 algorithm depicted Figure 2.words, action considered helpful achieves least one lowestlevel goals relaxed plan state hand. helpful actions information usedpruning technique. breadthrst search iteration enforced hill-climbing,expanding state s, states generated actions H (s) includedsearch space. Note states relaxed planning graph reachgoals h(s) = 1 get expanded anyway.general, neither enforced hill-climbing helpful actions pruning maintain completeness. algorithm fails enforced hill-climbing gets caught dead end state.happen search backtrack decisions, heuristicfunction return value 1 dead end state. algorithm also fails helpfulactions pruning cuts important states, happen techniquenon-admissible approximation usefulness. deal issue employing safetynet solution, i.e., enforced hill-climbing fails planner starts scratch usingcomplete heuristic search engine, without pruning technique. search engine usedRussel Norvig (1995) term greedy best-rst search. weighted strategyweight wg node cost equation f (s) = wg g(s) + wh h(s) wg = 0,i.e., search simply expands search nodes increasing order goal distance estimation.Repeated states avoided obvious way keeping hash table visited states.3. Numeric State Variablesintroduce notation numeric part PDDL2.1 language (i.e., PDDL2.1 level2) dened Fox Long (2002), used IPC-3. restrict STRIPSreadability reasons. Extensions ADL summarized Section 6.2. setsassumednite unless stated otherwise.298fiTranslating \Ignoring Delete Lists" Numeric State Variablesaddition propositions P , set V numeric variables. Notationally, say V = fv1 : : : vn g (throughout article, n denote number numericvariables). state pair = (p(s) v(s)) p(s) P set propositionsv(s) = (v1 (s) : : : vn (s)) 2 Qn vector rational numbers (the obvious semanticsp(s) true propositions, vi (s) value vi ).6expression arithmetic expression V rational numbers, usingoperators +, ;, , =. numeric constraint triple (exp comp exp0 ) expexp0 expressions, comp 2 f<= ff >g comparator. numeric e ecttriple (vi ass exp) vi 2 V variable, ass 2 f:= += -= = /=g assignment operator, exp expression (the e ect right hand side). condition pair(p(con) v(con)) p(con) P set propositions v(con) set numericconstraints. e ect triple (p(e )+ p(e ); v(e )) p(e )+ P p(e ); Psets propositions (the add- delete-list), v(e ) set numeric e ects6= j (vi ass exp) (vj ass0 exp0 ) 2 v(e ).7 action pair (pre(a) e (a))pre(a) condition e (a) e ect.semantics language straightforward. value exp(v) expressionexp variable value vector v (in s, v numeric part v(s) state s)rational number expression simplies replacing variablesrespective values, undened division 0 occurs. constraint (exp comp exp0 ) holdsstate s, written j= (exp comp exp0 ), values exp exp0 dened s,stand relation comp other. condition con = (p(con) v(con)) holdsstate s, j= con, p(con) p(s), numeric constraints v(con) hold s.value (vi ass exp)(v) numeric e ect (vi ass exp) variable value vector v (in s,v numeric part v(s) state s) outcome modifying value vivalue exp s, using assignment operator ass. numeric e ect applicablevalue dened. e ect e = (p(e )+ p(e ); v(e )) applicablenumeric e ects v(e ) applicable s. e s, e (s) states0 p(s0) = p(s) n p(e ); p(e )+ , v(s0 ) value vector resultsv(s) replacing vi (s) (vi ass exp)(s) (vi ass exp) 2 v(e ). Puttingdenitions together, result executing action state result(s hai) =e (a)(s) j= pre(a) e (a) applicable s, undened otherwise.rst case,said applicable s. action sequence ha1 : : : i, result(s ha1 : : : i)usual dened recursively result(s ha1 : : : i) = result(result(s ha1 : : : an;1 i) )result(s hi) = s.numeric task tuple (V P G) V P variables propositionsused, set actions, state, G condition. sequence actionsha1 : : : 2 plan result applying yields state models G,result(I ha1 : : : ani) j= G.algorithmic framework, make distinctions di erent degrees expressivity allow numeric constraints e ects, i.e., di erent numeric6. ignore, readability reasons, possibility given Fox Long's original languagevariable unde ned value assigned one. methodology easily extended{ fact implemented { deal case.7. Fox Long (2002) make assumption implicitly, requiring outcome actionwell-de ned { note commutative eects variable merged.299fiHoffmannlanguages. numeric language tuple (Cons E -ass E -rh) Cons possiblynite set numeric constraints, E -ass set assignment operators, E -rhpossiblynite set expressions. task (V P G) belongs language constraints, assignment operators, e ect right hand sides members respectivesets.next three sections contain technical part article. organizedfollows.1. Section 4 provides theory Metric-FF's heuristic function based.relaxation, ignoring delete lists described Section 2.1, extended numericvariables. Section 4.1 formalizes key idea restricted numeric language,states extended relaxation fullls admissibility, basic informedness, polynomiality. Section 4.2 abstracts restricted language, identifying generalizedsemantic properties make relaxation work. Section 4.3 introduceslanguage linear tasks, brought linear normal form (LNF)semantic properties. Metric-FF's core planning algorithms implementedLNF tasks.2. Section 5 introduces algorithms implemented Metric-FF's heuristic function.algorithms extensions relaxed Graphplan methods described Section 2.2. Section 5.1 describes algorithms restricted language, Section 5.2extends LNF tasks. state formally algorithms completecorrect. also see algorithms are, theory, less ecient couldbe. number relaxed planning graph layers built exponentialsize task encoding, contrast polynomiality relaxation provedSection 4. reason implementation lags behind theoreticallypossible implementation work done theory fully developed. However, practical point view, least debatable importantpotential exponentiality (the number relaxed planning graph layers builtbounded length shortest relaxed plan). Exploring issue depthtopic future work. details Sections 4.1 5.1.3. Section 6 details relaxed plan information used implement Metric-FFsystem. Section 6.1 explains extension basic FF architecture describedSection 2.3. Section 6.2 explains extension ADL, Section 6.3 describesexible optimization criteria dealt with.4. Relaxing Numeric State Variablesshow relaxation technique STRIPS naturally extended numericcontext. proceed three steps outlined above.4.1 Restricted Languagekey idea relaxation becomes apparent one considers contextconstraints compare variables constants via ff >, += -=300fiTranslating \Ignoring Delete Lists" Numeric State Variablese ects, e ect right hand sides positive constants. formally, restrictedlanguage is:( f(vi comp c) j vi variable comp 2 fff >g c 2 Qgf+= -=gfc j c 2 Q c > 0g )STRIPS, delete lists troublesome falsify propositions mightneed preconditions goal. restricted numeric language here, -= e ectstroublesome diminish value ected variables. idea thereforeignore e ects.Denition 5 Assume restricted numeric task (V P G). relaxation a+action 2 A, = (pre(a) (p(e (a))+ p(e (a)); v(e (a)))), deneda+ := (pre(a) (p(e (a))+ f(vi += exp) j (vi += exp) 2 v(e (a))g)):relaxation (V P G) (V P A+ G), A+ := fa+ j 2 Ag. actionsequence ha1 : : : 2 relaxed plan (V P G) ha+1 : : : a+n plan(V P A+ G).relaxation adequate restricted language, precise sense introduced Section 2.1.Denition 6 Let RESTRICTED-RPLANSAT denote following problem.Assume restricted numeric task (V P G). relaxation (V P G)solvable?Theorem 1 relaxation given Denition 5 adequate, i.e., following holds true.1. Admissibility: assuming restricted numeric task (V P G), plan(V P G) also relaxed plan (V P G).2. Basic informedness: assuming restricted numeric task (V P G), hi plan(V P G) hi relaxed plan (V P G), 2 A,result(I hi) j= pre(a) result(I hi) j= pre(a+ ).3. Polynomiality: deciding RESTRICTED-RPLANSAT P.detailed proof found Appendix A. straightforward extensionSTRIPS proof, exploiting correspondence pre/goal-conditions, add lists,delete lists one hand, x ff >]c constraints, += e ects, -= e ectshand. tricky part lies proving polynomiality, precisely handlerepeated increasing e ects variable. e ects might appliedexponential number times. Consider tasks, n 2 N0 , vi initially 0,vi ff n goal, action e ect (vi += 1). task n, shortest relaxedplan comprises n steps, exponentially long size non-unary encoding301fiHoffmannn. trick one use decide relaxed solvability polynomial time simple1 handling. polynomial decision process forwardxpoint procedure similarbuilding relaxed planning graph. soon appears action increasesvariable vi , one assume vi 's value 1, reecting fact vi 's valuemade arbitrarily high applying sucient number times. indicated earlier,current implementation Metric-FF, describe Section 5, makeuse 1 handling technique, may thus build exponential number relaxedplanning graph layers search state. Section 5.1.words related work order here. one relaxes numeric tasks ignoringnumeric constructs, one gets admissibility polynomiality, basicinformedness. heuristic methods used Sapa (Do & Kambhampati, 2001) GRT-R(Refanidis & Vlahavas, 2000) come quite close extreme case. fact, Sapa's heuristicconstructs relaxed plan completely ignores numeric part task.\resource consumption" resulting relaxed plan (roughly, sum decreasinge ects numeric variables) used estimate number actions would neededre-produce resources, number added heuristic value statehand. particular, method ignores numeric goals preconditions thus lacksbasic informedness. Similarly, heuristic technique used GRT-R considers resourceconsumption another form state cost, take numeric preconditiongoal constraints account. heuristic technique make explicit use relaxedplans denitions directly applied. However, numeric constraintsconsidered, heuristic value purely numeric action precondition zero evenprecondition true current state, technique thus also lacks basicinformedness.4.2 Monotonicity, Dynamic Relaxationlook behind scenes relaxation technique usedrestricted language. abstract syntax numeric constructs, focussemantics instead. dene extension relaxation general context,identify group semantic properties make relaxation adequate.later focus syntactically restricted language, linear tasks, easier seerelaxation adequate. main intention abstract work subsectionprovide theoretical background general characteristics relaxationworks.Let usrst ignore semantic issues, simply extend denition relaxation.general, denition easy restricted case Denition 5.idea still ignore decreasing e ects, diculty whether e ect decreasingdepend context executed in.8 simple example, say actionnumeric e ect (vi += vj ). vj negative value state a's execution,e ect decreases value vi instead increasing it. statically relax8. common practice refer += eects \increasing eects", -= eects \decreasingeects". contrast that, distinguish syntax semantics using += / -= denotesyntax, increasing / decreasing denote semantics (of arbitrary numeric eects).302fiTranslating \Ignoring Delete Lists" Numeric State Variablesignoring parts specication. Instead, relaxation dynamic: relaxstate transition function.Denition 7 Assume state action = (pre(a) e (a)). relaxed resultexecuting result+ (s a) = s0 p(s0 ) = p(s) p(e (a))+ , v(s0 )value vector results v(s) replacing vi (s) (vi ass exp)(s)(vi ass exp) 2 v(e ) (vi ass exp)(s) > vi (s).action sequence ha1 : : : i, result+(s ha1 : : : i) dened recursivelyoriginal result function Section 2. Note that, STRIPS restricted numericlanguage, Denition 7 comes exactly relaxations used before.generalized relaxation, want know exactly situationsrelaxation adequate. Obviously, ignoring decreasing e ects adequategeneral. simple example, value variable vi initially 0, e ect(vi -= 1), goal requires vi < 0, \relaxation" renders task unsolvable. Intuitively, relaxation adequate always preferable numericvariables higher values. Formalizing intuition turns bit tricky.Recall three conditions adequacy relaxation: admissibility (any real plan alsorelaxed plan), basic informedness (the relaxation ignore precondition goalconstraints), polynomiality (solvability relaxation decided polynomialtime). Basic informedness obviously given relaxation here. admissibilitypolynomiality. Say want make sure real plan also relaxed plan.must numeric constraints prefer higher variable values, e ects mustalso. example, say vi = vj = 0 initially, goal vi ff 1, action e ect(vi -= vj ), action e ect (vj -= 1). ignore decreasing e ect vj ,solve task e ect (vi -= vj ) better vj takes lower values.Considering polynomiality, ensure relaxed solvability decided polynomialtime, kinds subtleties must handled. Say want shortcut repeated actionapplication 1 trick, i.e., assuming repeated application increasing e ectsmakes ected variable diverge (as case restricted language above).get trouble repeated (relaxed) application action makes valueected variable converge.9 Similar diculties arise expression constraintdiverge variables. Finally, might constraint looks correctinserting 1, never fulllednite values. exampleconstraint vi ff vi + 1, fullled inserting 1 vi .following denition, introduce number conditions sucientensure none diculties described appear. see \monotonic"tasks real plan also relaxed plan, \strictly monotonic" tasks, given:= e ects acyclic certain sense, relaxed plan existence decided polynomialtime.Denition 8 Assume numeric task (V P G). task monotonic if, pairsstates s0 8vi : vi (s)vi (s0 ), following holds.9. example, initially 1 eect ( += 1 ; v2i ) repeated applicationeect makes value converge 2 (the value applications 2 ; 12 n ).vvvv303nfiHoffmann(1) numeric constraints (exp comp exp0 ) occurring task:j= (exp comp exp0) ) s0 j= (exp comp exp0 ):(2) numeric e ects (vi ass exp) occurring task:(vi ass exp)(s)(vi ass exp)(s0 )relation holds values dened.task strongly monotonic following hold.(3) states s0 above, numeric e ects (vi ass exp) occurringtask, ass 2 f+= -= = /=g:(vi ass exp)(s) ; vi (s)(vi ass exp)(s0 ) ; vi (s0 )relation holds values dened.(4) expressions exp occurring task:8vi 2 v(exp) : lim exp = 1vi !1v(exp) denotes set variables contained exp.(5) numeric constraints (exp comp exp0 ) occurring task:9s : j= (exp comp exp0 ):explanation lengthy denition order. Condition (1) ensuresnumeric constraints prefer higher variable values. Condition (2) e ects,requiring value e ect increase variables. particular,value become undened, i.e., division zero occurs variablesgrow. two conditions suce make real plan relaxed plan, higher variablevalues always preferable. Conditions (3) (5) aim making relaxed solvability easydecide. Condition (3) stronger version condition (2). require valuee ect adds ected variable increases variables. ensuresrepeated application e ect causes value ected variable diverge.illustrate this, e ect (vi += ;vj + c) fullls condition (2) condition (3).outcome e ect always c, monotonic (zero) variables ectsvi vi 's value becomes higher. Condition (4) postulates expressionsdiverge variables, condition (5) postulates constraintsnitevariable assignment makes constraints true. Together condition (1)requirements ensure constraints eventually fullled increasingvalues variables.1010. One could weaken conditions (1) (3) De nition 8 exploiting fact interestedreachable states. matter if, e.g., constraint monotonic region variable valuesnever reached due semantics task. Metric-FF implements analysistechniques, except throwing away actions { them, numeric constraints eects { whosepreconditions reached relaxed planning graph initial state, ignoringnumeric constructs. Exploring topic depth future work.304fiTranslating \Ignoring Delete Lists" Numeric State Variables:= e ects separated denition strong monotonicity, i.e.,postulate condition (2) them, postulate condition (3). Postulatingcondition (3) := e ects would also suce. condition hold evensimplest form := e ects, namely (vi := c), assigning constant variable. Noteprinciple e ect example given above, (vi += ;vj + c).E ects kind common even limited suits benchmarks currentlyavailable (e.g.,lling tank, fuel level assigned maximum level).identify di erent sucient criterion makes := e ects tractable, capturescommon forms e ects. Computing maximum outcome set assignmente ects, relaxation condition (2), becomes easy value changessingle variable propagated value. proof argument that,if, transitively, change vi inuence vi 's value one needsperform value propagation steps, step computing maximum assignmentavailable variable. many steps variables, valuesxed. formalize possible value propagations straightforward graphdenition.Denition 9 Assume numeric task (V P G). task acyclic := e ectsgraph (V E ) cycle-free,E = f(vi vj ) 2 V V j 9a 2 (vj := exp) 2 v(e (a)) : vi 2 v(exp)gv(exp) denoting set variables contained exp.state ways denitions imply adequacy ignoring decreasing e ectsrelaxation. notation relaxed plan existence decision problem, abstractsyntactic issues, assume well-formed input task decision procedurestrongly monotonic acyclic := e ects.Denition 10 Let STRONGLY-MONOTONIC-RPLANSAT denote following prob-lem.Assume numeric task (V P G). relaxed plan (V P G), providedtask strongly monotonic acyclic := e ects?Theorem 2 relaxation given Denition 7 adequate strongly monotonic tasksacyclic := e ects. Precisely following holds true.1. Admissibility: assuming monotonic numeric task (V P G), plan(V P G) also relaxed plan (V P G).2. Basic informedness: assuming numeric task (V P G), hi plan(V P G) hi relaxed plan (V P G), 2result(I hi) j= pre(a) result+(I hi) j= pre(a).3. Polynomiality: deciding STRONGLY-MONOTONIC-RPLANSAT P.305fiHoffmannproof, given Appendix A, basically straightforward exploitation properties ensured denitions. Note Theorem 2 identies sucient criteriamake relaxation work. Interesting questions are, other, maybe weaker,criteria? concrete example, seem certain cases cyclic assignment e ectseasily handled. exactly cases? Answering questionstopic future work.Another thing dealt semantic constraints translatesyntax arithmetic expressions allowed PDDL2.1. considerdetails base rest article subset PDDL2.1 requiredsemantic properties easily achieved { language Metric-FF systemactually implemented. Extending system richer languages open research topic.4.3 Linear Tasks, LNFMetric-FF system implemented deal call linear tasks.language numeric tasks = /= e ects, numeric variablesused linear expressions. formally:( f(exp comp exp0 ) j exp exp0 linear expression comp arbitrarygf:= += -=gfexp j exp linear expressiong )Metric-FF's implementation allows tasks linear following preprocessing step. Assume given planning task (V P G). variable vi 2 Vtask constant vi ected e ect action A. expression taskconstant variables occurring task constants. pre-process replaces taskconstants respective rational numbers resulting inserting initial variablevalues.11Linear tasks are, course, necessarily monotonic. fact, illustrativecounter examples given linear. linear functions monotonic,precisely strictly monotonic diverging, variables, either positivenegative sense. idea introduce, variable vi used negative sensepoint, inverted variable ;vi always takes value (;1) vi . Onereplace vi ;vi points vi used negatively. donevariables, task (strictly) monotonic: variables used positivesense (more details below). Introducing inverted variables viewed shortcut wayinforming heuristic function places use variables positivenegative sense.12 return issue considering Metric-FF's heuristicalgorithms Section 5.2.Given linear task, Metric-FF transforms task call linear normalform (LNF). LNF task, expressions weighted sums variables,weights greater 0. transformation process works follows. First, seriessimple steps transforms task following language.11. If, quotient (exp exp ), exp simpli es 0 expression unde ned respectiveconstraint never ful lled / respective action's eects never become applicable.case one replace constraint \false"/ remove action.12. David Smith, personal communication.=00306fiTranslating \Ignoring Delete Lists" Numeric State VariablesP( f( j 2X cj vj + c ff >] 0) j cj c 2 Q cj 6= 0gf:=+=gPf j 2X cj vj + c j cj c 2 Q cj 6= 0g )achieve language format, one replaces constraints (exp = exp0 ) (expexp0 ) (exp ff exp0), e ects (vi -= exp) (vi += ;exp). restmatter normalizing linear functions. language format di ers LNFvariable weights may negative. This, course, makes di erence. Reconsiderexample variable vi initially 0, action e ect (vi -= 1),goal requires vi < 0. take running example following.language format, a's e ect (vi += ;1), goal requires (;1) vi > 0.Due negative weighting vi goal condition, ignoring decreasing e ectsviable.way introduce inverted variables extension methodology eliminates negative preconditions STRIPS planning (a techniquerst introduced Gazen &Knoblock, 1997). process works follows. Initialize set translated variables:= . Iterate negative weights, otherwise select (arbitrary) occurrence cj vj , cj < 0, weighted sum.P Introduce new variable ;vj . Set;vj (I ) := (;1) vj (I ). e ects (vj +=:=] Pj 2X cj vj + c), introduce (intoe ect set action) e ect (;vj +=:=] j 2X ((;1) cj ) vj + ((;1) c)). Set:= fvj ;vj g. occurrences c v weighted sums c < 0 v 2(where v may one original variables one introduced inverse variables),replace c v ((;1) c) ;v (where ;v respective inverse counterpart v).jV j iterations, weights positive process terminates. taskfollowing linear normal form.P( f( j 2X cj vj + c ff >] 0) j cj c 2 Q cj > 0gf:=+=gPf j 2X cj vj + c j cj c 2 Q cj > 0g )running example, LNF transformation following. twovariables, vj ;vj , initially 0. action two e ects, namely(vi += ;1) (;vi += 1). goal condition expressed terms value;vi , reads ;vi > 0. single application action achieves goal, alsorelaxed transition function e ect ;vi increasing.13 general,easy see LNF tasks strongly monotonic.Proposition 4 Assume linear numeric task (V P G). task LNF,strongly monotonic.Proof: conditions Denition 8 trivially fullled LNF tasks. examples,condition (1) true compare expressions (positively) monotonicvariables constants via ff >. Condition (3) true +=e ects whose right hand sides (positively) monotonic variables.213. Note estimating maximum value ; estimating minimum value .Section 5.2.v307vfiHoffmannProposition 4, LNF task (V P G) acyclic := e ects (rememberseparated Denition 8 condition (3)) task fullls prerequisitesTheorem 2, ignoring decreasing e ects adequate relaxation. thus feasibleuse solutions relaxation means heuristic estimation.:= e ects, one easily translate into, e.g., += e ects { (vi := exp)translates (vi += ((;1) vi )+exp). reader might wonder bother treating:= e ects all. point that, translated e ects behave equivalentlyreal transition function, behave di erently relaxation. running examplesuppose second action a0 e ect (vi := 10). LNF transformation,translated version e ect (vi += ;vi + 10). Say execute, result+ ,rst (with e ects (vi += ;1) (;vi += 1)) a0 . original task, resultingvalue vi 10. translated task, value 11 (because decreasing e ect viignored). make di erence whether treat := e ects separately not.open question whether, situations, di erence important plannerperformance.also remark that, Metric-FF implements introduction inverted variablesLNF tasks only, seems likely similar processes work richer languages,functions strictly monotonic diverging variables.5. Solving Relaxed Tasksconcentrate algorithms used FF, generally algorithmsused obtain heuristic information forward state space search. explainsolve relaxed numeric tasks.rst consider restricted language, extendmethods LNF tasks. algorithms form basis Metric-FF implementation.5.1 Restricted Tasksimplementation uses straightforward extension Graphplan-style algorithmsintroduced Section 2.2. still use two-step processrst builds relaxed planninggraph extracts relaxed plan (if graph succeeds reaching goals).parallel structures keep track progress logical propositions,structures keep track progress terms maximally possible variablevalues. graph building mechanism outlined Figure 4.parts algorithm concerned propositions work exactlySTRIPS case, c.f. Section 2.2. numeric variables, max value vectorlayer species current maximum value variables take on. vectorsupdated obvious fashion, adding layer total sum increasing e ectslayer. termination condition checks whether maximum valuesvariables either changed, already higher needed: mneedi valuevariable vi dened highest requirement variable, i.e.,mneedi := max(;1 fc j (vi ff >] c) 2 v(G)v(pre(a))g):a2ANote algorithm fails relaxed plan (V P G):algorithm fails layer termination condition hold true later layers.308fiTranslating \Ignoring Delete Lists" Numeric State VariablesP0 := s, vi maxi0 := vi (s) endfor:= 0p(G) 6 Pt (v >] c) 2 v (G) maxit 6 6>]c:= fa 2 j p(pre(a)) Pt8(vi >] c) 2 v(pre(a)) : maxit >]cgPt+1 := Pt a2A p(e(a))+ Pv maxit+1 := maxit + a2A (v += c)2v(e(a)) c endforPt+1 = Pt8vi : maxit+1 = maxit maxit > mneedifailendif:= + 1endwhilefinallayer :=Figure 4: Building relaxed planning graph state restricted numeric task(V P G).Also, notenite number layers numeric variablesincrease eventually reachnite mneed values. But, mentioned Section 4.1,number layers exponential task encoding. Reconsider example where,n 2 N0 , vi initially 0, vi ff n goal, action e ect (vi += 1).number graph layers built example, n, exponential non-unary encodingn, whereas one could easily decide solvability 1 trick outlined Section 4.1.hand, appears unlikely implementation provably polynomialdecision procedure would better practice. graph building algorithm polynomiallength output (the minimal length relaxed plan). Also, possiblyexponential minimal length relaxed plan (exponential non-unary encodingvariable values) seem particularly relevant, least examplesspecically constructed provoke exponentiality. remains open question whetherimplementation 1 handling achieve better performance realistic examples.focus relaxed plan extraction. invoked relaxed planning graphsucceeds reaching goals. information graph provides uslevels actions, propositions, numeric goals. actions propositions levelrst graph layer appear, c.f. Section 2.2. numeric goals (vi ff >] c),level graph layer goalrst achieved, i.e., maxit ff >]choldsrst time. plan extraction mechanism outlined Figure 5.Again, logical entities dealt exactly STRIPS case, c.f. Section 2.2.addition propositional (sub-)goal set p(Gt ) layer set v(Gt )numeric goals. Like STRIPS, goals sub-goals always inserted setrst appearance relaxed planning graph, goal sets initializedinserting respective (top-level) goals. backwards loop topbottom layer, selecting actions support propositions numeric variablesrespective goal sets. propositions supported before, di erence309fiHoffmann:= 1 : : : finallayerp(Gt ) := fg 2 p(G) j level(g) = tgv(Gt ) := f(vi >] c) 2 v(G) j level(vi >] c) = tgendfor:= finallayer : : : 1g 2 p(Gt )select a, level(a) = ; 1, g 2 p(e(a))+p 2 p(pre(a)) (v >] c) 2 v (pre(a))p(Glevel(p) ) = fpgv(Glevel(v >] c)) = f(vi >] c)gendforendfor(v >] c) 2 v (Gt )maxit;1 6 6>]cselect a, level(a) = ; 1, (vi += c0 ) 2 v(e(a)),previously selected while-loopc := c ; c0/* introduce a's preconditions */endwhilev(Gt;1 ) = f(viendforendfor>] c)gFigure 5: Extracting relaxed plan state restricted numeric task (V P G)(levels finallayer computed algorithm Figure 4).also numeric preconditions supporting actions must insertedgoal sets below. uniting sets numeric goals contain constraintvariable vi , stronger one constraints taken. numeric goals(vi ff >] c) 2 v(Gt ) general enough select single action several actions; 1 might contributed vi 's maximum value t. SoPsupporters selectedgoal achieved one layer earlier. Note maxit ; a2A 1 (v += c)2v(e (a)) c =maxit;1 , loop always terminate successfully. Note also one occurrenceaction support di erent logical numeric goals di erent e ects,used support numeric goal twice.Upon termination plan extraction, selected actions used form relaxed plan: denoting actions selected layer t, arbitrary linearizationA0 : : : Afinallayer;1 relaxed plan task. Note one apply various simpleheuristics, like selecting += e ects maximum right hand siderst, make relaxedplans short possible.t;5.2 LNF Tasksalgorithms numeric tasks linear normal form di er restricted tasksneed take care := e ects, general expressions numeric310fiTranslating \Ignoring Delete Lists" Numeric State Variablesconstraints e ect right hand sides. turns out, integrating extensionsoverly dicult. issue becomes slightly involved exact terminationcriterion relaxed graph building. solution issue assume,theoretical analysis underlying Theorem 2, := e ects acyclic. outlinegraph building mechanism shown Figure 6.P0 := s, vi maxi0 := vi (s) endfor:= 0p(G) 6 Pt (exp >] 0) 2 v (G) exp(maxt ) 6 6>]0:= fa 2 j p(pre(a)) PtS8(exp >] 0) 2 v(pre(a)) : exp(maxt) >]0gPt+1 := Pt a2A p(e(a))+ Pv maxit+1 := maxit + a2A :(v += exp)2v(e(a)) exp(max )>0 exp(maxt ) endforv maxit+1 := max(maxit+1 maxa2A (v := exp)2v(e(a)) exp(maxt )) endforPt+1 = Pt8vi : maxit+1 = maxit maxit > mneedi (s)failendif:= + 1endwhilefinallayer :=Figure 6: Building relaxed planning graph state LNF task (V P G).Compare Figure 6 Figure 4. deal expressions constraintse ect right hand sides simply inserting respective max values variables,computing respective outcome (recall exp(v) expression exp variablevalue vector v denotes value exp inserting values v). += e ectstaken account obtain maxt+1 values exactly before, i.e., addingcombined contributions maxt (except value right hand sides mustcomputed using maxt values). := e ects taken account determining,+= e ects contributed maxt+1 , whether := e ect graphwhose value, inserting maxt values, higher hitherto maxt+1 value.case, maxt+1 (for respective variable) updated maximum assignmentpossible.part algorithm becomes somewhat complicated, comparisonalgorithm restricted tasks, termination criterion. dicult partcomputation mneed values, i.e., values variables longercontribute anything relaxed solution. values depend statestart from. derive values, start static (non state-dependent) notionsolution-relevant variables. variable vi solution-relevant either occurs numericconstraint, right hand side exp e ect (vj +=:=] exp) solution-relevantvariable vj . Note solution-relevance thus transfers transitively variables.denote set solution-relevant variables rV . state-dependent aspectsrelaxed task, provide notation value variable vi must least takestate order raise (or \support") value positively weighted sum311fiHoffmannPexp = j 2X cj vj + c constant c0 .supvi (s exp c0 ) := (c0 ; c ;Xi6=j 2Xcj vj (s)) = cicourse, support value supvi (s exp c0 ) dened vi 2 v(exp), i.e., vipart weighted sum. reader easily convince him/herself, raisevalue vi supvi (s exp c0 ) know value exp least c0 .use concept determine point variable vi contributes sucientlyconstraints e ect right hand sides contribute to. constraints(exp ff >] 0) vi 2 v(exp) point reached vi ff supvi (s exp 0) (thenconstraint fullled). += e ect right hand sides (vj += exp) vi 2 v(exp)vj 2 rV (vj may needed) point reached vi ff supvi (s exp 0) (the e ecteventually increase vj arbitrarily high values). := e ect right handsides, e ect (vj := exp) vi 2 v(exp) vj 2 rV value vi sucientvi ff supvi(s exp mneedj (s)): e ect high enough assign vj sucient value.main complication want use supv values dene mneedvalues denition := e ects recursive. constitute problem givenassumption := e ects acyclic. e ect, recursion guaranteedterminate. Altogether, denition following.8> ;1>< fsupvi(s exp 0) j (exp >] 0) 2 v(G) Sa2A v(pre(a)) vi 2 v(exp)gmneed (s) := max >(s exp 0) j (v j += exp) 2fsupv) vj 2 rV g:> fsupvi(s exp mneedj (s) j (vj := expa2)A2vS(ea2(Aa))v(ev (2a))v(expvi 2 v(exp) vj 2 rV gNote that, denition, variables mneedi (s) = ;1 variablessolution-relevant.Theorem 3 Assume linear numeric task (V P G) LNF acyclic:= e ects. Assume state s. algorithm depicted Figure 6 fails,relaxed plan (V P G).main proof idea is, before, this: algorithm fails layer termination condition hold true later layers. argument concerning mneed(s)values follows outlined above. full details bit lengthy. See Appendix A.discussed restricted language, number graph layers builtterminationnite { eventually, variables either increase reachnitemneed values { exponential encoding length task. Again, onecould implement provably polynomial algorithm along lines method usedproof Theorem 2, debatable whether implementation would,realistic examples, achieve signicant performance improvements existingimplementation.interesting consider role inverted variables { introducedMetric-FF LNF pre-processing, see Section 4.3 { play relaxed planning graphprocess described above. Estimating maximum value inverted variableestimating minimum value respective original variable. precisely,Figure 6, vj inverted variable vi (;1) maxjt is, t, optimistic312fiTranslating \Ignoring Delete Lists" Numeric State Variablesapproximation minimum value vi take steps: valueresults one ignores increasing e ects vi , optimistic decreasinge ects. sense, introduction inverted variable ;vi = vj viewedway informing relaxed planner where, numeric constraints e ects,use minimum maximum possible value vi , computing optimisticapproximation maximum minimum values.14focus relaxed plan extraction. justied Theorem 3, invokedrelaxed planning graph succeeds reaching goals. Also before, informationgraph provides levels actions, propositions, numeric goals.actions propositions denitions stay same, numeric goals (exp ff >] 0)level graph layer goalrst achieved, i.e., exp(maxt ) ff >]0holdsrst time. outline plan extraction mechanism shown Figure 7.Compared algorithm restricted tasks, shown Figure 5, noveltiesFigure 7 complex numeric goals get split goals individual variables,e ect right hand sides forced suciently high value, := e ectshandled.rst issue, given numeric goal (exp ff >] 0), dealt simplyconstraining variables vi 2 v(exp) take respective max value. Similarly,e ect right hand sides (vi :=+=] exp) forced suciently high requiringvj 2 v(exp) take respective max value. := e ects taken accountalternative way achieving numeric goal (vi ff >] c) 2 v(Gt ). e ect(vi := exp) suciently high value, exp(maxt;1 ) ff >]c, respective actionselected. Otherwise set actions += e ects selected similar fashionrestricted tasks. Figure 5, uniting sets numeric goals containconstraint variable vi , stronger one constraints taken. easysee that, upon termination, selected actions used form relaxed planstate hand.Theorem 4 Assume linear numeric task (V P G) LNF acyclic :=e ects. Assume state algorithm depicted Figure 6 reaches goals.actions selected algorithm depicted Figure 7 form relaxed plan (V P G).(straightforward) proof found Appendix A. conclude sectiontwo additional remarks. One thing might also occurred reader onenecessarily need support goal (exp ff >] 0) requiring vi 2 v(exp)take maximum possible value. Weaker requirements might already sucient.holds true e ect right hand sides. One might ablend shorter relaxed plansusing simple heuristics points. also seems plausible algorithmsspecied work strictly monotonic task uses += e ects acyclic:= e ects, assuming mneed value computation modied appropriately. Exploringidea richer language classes left open topic future work. also left open= e ects /= e ects could taken account.14. insight pointed author David Smith comment submitted versionarticle. Optimistically estimating maximum minimum variable values, generallymultiple variable values, alternative viewpoint monotonicity paradigm explore here.Investigating alternative viewpoint depth open topic.313fiHoffmann:= 1 : : : finallayerp(Gt ) := fg 2 p(G) j level(g) = tgv(Gt ) := f(vi >] maxit ) j (exp >]0) 2 v(G) level(exp >] 0) = vi 2 v(exp)gendfor:= finallayer : : : 1g 2 p(Gt )select a, level(a) = ; 1, g 2 p(e(a))+p 2 p(pre(a)) (exp >] 0) 2 v (pre(a))p(Glevel(p) ) = fpgv(Glevel(exp >] 0)) = f(vi >] maxilevel(exp >] 0)) j vi 2 v(exp)gendforendfor(v >] c) 2 v (Gt )9a, level(a) = ; 1, (v := exp) 2 v (e(a)),v(Gt;1 ) = f(vj maxjt;1) j vj 2 v(exp)gexp(maxt;1 ) >]c/* introduce a's preconditions */elsemaxit;1 6 6>]cselect a, level(a) = ; 1, (vi += exp) 2 v(e(a)), exp(maxt;1 ) > 0previously selected while-loopc := c ; exp(maxt;1 )/* introduce max constraints vars exp *//* introduce a's preconditions */endwhilev(Gt;1 ) = f(viendifendforendfor>] c)gFigure 7: Extracting relaxed plan state LNF task (V P G) (levelsfinallayer computed algorithm Figure 1).6. Metric-FFsection details theoretical algorithmic work described far usedimplement heuristic planning system Metric-FF. Section 6.1 species relaxedplan information used dene basic architecture planner handles STRIPSplus linear tasks acyclic := e ects. describe extensions integratedsystem: Section 6.2 explains extension ADL handled, Section 6.3explains exible optimization criteria taken account.6.1 Basic ArchitectureSTRIPS case, techniques extracting relaxed plans, statespace planner easily implemented. given linear task transformed LNFtask using algorithms described Section 4.3. dene heuristic function, search314fiTranslating \Ignoring Delete Lists" Numeric State Variablesstrategy, pruning technique analogous used STRIPS version FF, c.f.Section 2.3. methods straightforward adaptions STRIPS techniques.heuristic function still estimates goal distance number actions relaxed plan.Denition 11 Assume linear numeric task (V P G) LNF acyclic:= e ects, state s. Metric-FF heuristic value h(s) denedfollows.Pfinallayeralgorithm depicted Figure 6 fails, h(s) := 1. Otherwise, h(s) := t=1jAt jset actions selected layer algorithm depicted Figure 7.search strategy remains exactly same, namely enforced hill-climbing depictedFigure 3. di erence lies way avoid repeated states.STRIPS case, simple hash table lookup procedure. straightforward adaptionwould store visited states s, cut new state s0 identical statevisited before. can, however, derive weaker cuto criterionimportant performance impact certain situations. might s0 di erssolution-irrelevant numeric variables values. example,di erence s0 might s0 execution time spent.expand s0 iteratively might endnite sequence succeeding statesnothing increase execution time (this phenomenon observed variousbenchmark domains). avoid phenomena cutting new states s0dominated stored state s. Given task (V P G), state s0 dominatedstate propositions s0 same, vi 2 V , either visolution-relevant, vi 2 V n rV , vi (s0 )vi (s) holds.15 s0 dominated s,task hand monotonic sense Denition 8, action sequences achievegoal starting s0 starting s.Proposition 5 Assume numeric task (V P G) monotonic. Assume twostates s0 . s0 dominated then, action sequences P 2 , result(s0 P ) j=G result(s P ) j= G.Proof: Say P = ha1 : : : action sequence result(s0 P ) j= G holds.show that, solution-relevant variables vi 2 rV 0jn, vi (result(s0 ha1: : : aj i))vi(result(s ha1 : : : aj i)) holds. proves proposition: variablesgoal constraints rV , goal constraints monotonic (Denition 8 condition(1)), goal constraints fullled result(s0 P ). claimalso fullled result(s P ). prove claim solution-relevant variable valuesinduction j . Base case j = 0: prerequisite, vi (s0 )vi (s) holds vi 2 rV .Inductive case j ! j +1. First, preconditions aj +1 fullled result(s ha1 : : : aj i)due argument used goal constraints above. Second, variablescontained e ect right hand sides solution-relevant variablessolution-relevant denition induction hypothesis holds them. provesclaim monotonicity numeric e ects (Denition 8 condition (2)).215. Recall de nition solution-relevant variables , given Section 5.2: variables occurnumeric constraint, right hand side exp eect ( j ass exp) solution-relevantvariable j .rVvv315fiHoffmannLNF tasks monotonic. Proposition 5, solution plan s0 ,solution plan s. Thus cutting s0 search space already containssolution preserving. Consequently, search iteration performed enforcedhill-climbing, implementation keeps hash table states visited iteration,skips new state dominated least one visited states.16 indicatedabove, various benchmark examples prevents planner looping newstates nothing increase value solution-irrelevant variable like executiontime.17extend STRIPS pruning technique, helpful actions actionssupport either propositional numeric goal lowest layer relaxedplanning graph.Denition 12 Assume linear numeric task (V P G) LNF acyclic:= e ects, state algorithm depicted Figure 6 reaches goals.set helpful actions H (s) denedH (s) := f 2 j p(e (a))+ \ p(G1 ) 6= _9(vi ff >]c) 2 v(G1 ) : 9(vi := exp) 2 v(e (a)) : exp(v(s)) ff >]c _9(vi ff >]c) 2 v(G1 ) : 9(vi += exp) 2 v(e (a)) : exp(v(s)) > 0 gG1 set sub-goals constructed layer 1 algorithm depicted Figure 7.Supporting numeric goal means: := e ects, right hand sidee ect sucient fulgoal += e ects, respective right hand sideexpression greater 0. Note right hand side value e ect lowestlayer relaxed planning graph exactly value state hand. searchiteration enforced hill-climbing, expanding state s, states generatedactions H (s) included search space. Note states relaxedplanning graph reach goals h(s) = 1 get expanded anyway.STRIPS, algorithm fail either enforced hill-climbing gets trappeddead end state helpful actions pruning cuts important states. observedhelpful actions pruning severe numeric domains. So, case enforcedhill-climbing fails try pruning technique turned , i.e., continuehill-climbing procedure point failure without pruning. fails too, likeSTRIPS employ safety net solution: complete greedy best-rst strategy tryingsolve task scratch. strategy expands search nodes increasing ordergoal distance estimation. New states cut dominated alreadyvisited state.16. precisely, new state skipped dominant visited state hashentry. value solution-relevant variables (like executiontime increased), implementation ensures case. Otherwise matterchance. open question visited states could indexed order provide fast exactanswer query whether contain dominant state not.17. consequence undecidability numeric planning (Helmert, 2002),observed even seemingly benign benchmarks. nite state space course wouldrun risk entering nite loop.00316fiTranslating \Ignoring Delete Lists" Numeric State Variables6.2 ADLADL (Pednault, 1989) goes beyond STRIPS allows, action preconditionsgoal, arbitrary equation-freerst-order logical formulae, actions conditionale ects { e ects occur e ect condition holds true. e ect conditionarbitrary (equation-free)rst-order logical formula. numeric setting,e ects contain updates numeric variables. numeric constraints appearpoint logical formula logical atom allowed.Like previous FF version (Ho mann & Nebel, 2001), Metric-FF compiles quantiersdisjunctions away pre-processing phase. Metric-FF compile conditional effects away. Metric-FF's internal language di ers STRIPS (with numeric constraintse ects) actions conditional e ects, e ect conditionsconjunctions propositions (and numeric constraints). reason ADL compiledlanguage heuristic algorithms (i.e., relaxed planning graph)implemented eciently restricted language format. compilationexponentially costly general feasible when, one might expect formulation realistic planning scenario, logical formulae overly complex. reasonconditional e ects also compiled away (which could done principle)that, Nebel (2000) proved, would imply another exponential blow given wantpreserve solution length. Fortunately conditional e ects easily dealtneed compile away. following, give brief overviewcompilation process, extended heuristic function implementation. Exceptheuristic function, thing must adapted state transition function,conceptually trivial.compilation process largely implementation ideas proposedGazen Knoblock (1997), well Koehler Ho mann (2000b). extensionshandle numeric constructs straightforward. process starts usualplanner inputs, i.e., set parameterized operator schemata, initial state,goal formula. compilation works follows.1. Determine predicates numeric functions static sense operator e ect them. predicates functions common phenomenonbenchmark tasks. Examples, transportation context, would connectionslocations given static (connected ?l1 ?l2) predicate, distanceslocations given static (distance ?l1 ?l2) function. Static predicatesfunctions recognized simple sweep operator schemata.2. Transform formulae quantier-free DNF. subdivided three steps:(a) Pre-normalize logical formulae. Following Gazen Knoblock (1997),process expands quantiers, translates negations. end formulae consist conjunctions, disjunctions, atoms containing variables(where atoms numeric constraints).(b) Instantiate parameters. simply done instantiating operatore ect parameters type consistent constants one other.process makes use knowledge static predicates, sense317fiHoffmanninstantiated formulae often simplied (Koehler & Ho mann, 2000b).example, instantiated static predicate (p ~a) occurs formula,instantiation contained initial state, (p ~a) replaced\false". another example, sides numeric constraint staticconstraint replaced either \true" \false".(c) Transform formulae DNF. postponed instantiation, costly, applied smallest formulae possible.fully instantiated formula, likely many static predicate occurrences(constant constraint occurrences) replaced \true" \false", resultingmuch simpler formula structure.3. Finally, DNF formula contains one disjunct, corresponding e ect, operator, goal condition gets split manner proposedGazen Knoblock (1997).logical constructs normalized, numeric constructs tasktransformed LNF manner analogous process described Section 4.3.Integrating conditional e ects relaxed planning process easy matter.relaxed planning graph di ers STRIPS counterpart keeps trackgraph layers action's e ectsrst become applicable. relaxed planextraction process di ers STRIPS counterpart selects supportinge ects propositional numeric goals.6.3 Optimization CriteriaPDDL2.1, user specify optimization criterion task. criterion consistsarbitrary numeric expression together keyword \maximize" \minimize"saying whether higher lower values expression preferred. semanticssolution plan optimal state leads maximal / minimal goal staterespect optimization expression. Metric-FF supports, run \optimization mode",somewhat restrictive form optimization. accepts optimization criterioncriterion transformed, according certain schema, additive action costminimization. heuristic cost state summed cost actionsrespective relaxed plan, search standard weighted weightsset via command line. Note methodology give guaranteequality returned solution heuristic function provably admissible.methodology obvious option given cost relaxed plan (in additivesetting) gives us remaining cost estimation technique free. open questiongeneral optimization criteria dealt with. following, describeimplemented methodology little detail. start STRIPS setting,outline changes made extension ADL.Metric-FF rejects optimization expression linear. Otherwise, optimization keyword \maximize" expression isPmultiplied ;1 minimizationrequired. expression brought LNF, j 2X cj vj (the constant partobviously skipped). notation, optimization criterion accepted (only)action e ects variables vj 2 X increase optimization expression value318fiTranslating \Ignoring Delete Lists" Numeric State Variablesconstant, i.e., e ects vj 2 X form (vj += c) c 2 Q, c ff 0.action a, cost action denedcost(a) :=X(vj += c)2v(e (a)) vj 2Xcj ci.e., sum increases cost variables action, multiplied weightoptimization expression. cost action sequence set sumindividual costs. easy see that, setting,nding goal state minimizesoptimization expression value equivalentnding plan minimal cost. searchalgorithm use is, stated above, standard weighted algorithm implementingbest-rst search function f (s) = wg g(s) + wh h(s) g(s) costsearch path leads s, h(s) remaining cost estimate (i.e., cost relaxedplan s), weights wg wh given command line. Sinceremaining cost estimate general admissible,rst plan found guaranteedoptimal. one would expect empirically better plans found.see is, fact, case IPC-3 testing domains.ADL, cost action state sum costs e ects appear,cost action sequence sum costs actions respective states,minimizing optimization expression equivalent minimizing plan cost.Estimating remaining cost means relaxed plan becomes somewhat less obvious,since choice made e ect costs counted result.e ects selected support logical numeric goals relaxed planextraction, e ects get triggered actually executing relaxedplan. chosen count costs former e ects. heuristic searchalgorithm remains exactly STRIPS case.7. Competition Resultsbriey examine IPC-3 competition data relevant Metric-FF. competitionfeatured domains spanning whole range STRIPS PDDL2.1 level 3, permitscombination logical, numeric, temporal constructs. FF participated STRIPSdomains numeric domains, demonstrating competitive performance.discuss data numeric domains. discussion STRIPS resultsfound competition overview article Long Fox (2003).six numeric domains used competition. domains,includegure showing runtime curves, discuss relative (runtime solution quality)performance text. Like FF, MIPS LPG systems could congured eitherfavor speed quality, i.e., eithernd plan fast possible searchgood plan sense optimization criterion. make graphs readable,show runtime curves planners favor speed. discuss solution qualitybehavior planners terms plan length, i.e., number steps. Noteplanners take account optimization criterion anyway. plannersfavor quality, discuss runtime solution quality behavior text. Givenoptimization mode Metric-FF preliminary implementation, keepdiscussions short. also give brief descriptions domain semantics.319fiHoffmanndetails found overview article (Long & Fox, 2003). focussix domains turn, give short summary Metric-FF's performance.7.1 DepotsDepots domain combination well-known Logistics Blocksworld domains.Objects must transported trucks Logistics, must arrangedstacks Blocksworld. numeric constructs dene fuel consumption truckshoists lift objects (in order stack somewhere). Objects weightssum weights objects loaded onto truck time must lowerequal truck's capacity. Figure 8 shows runtime data 22 Depotsinstances used competition.10000"FF.speed""LPG.speed""MIPS.plain""SemSyn"10001001010.10.0112345678910111213141516171819202122Figure 8: Runtime curves Depots instances planners favoring speed. Timeshown logarithmic scale, instance size scales left right.four planners participating numeric version Depots Metric-FF, LPG,MIPS, SemSyn. time writing, paper numeric versionplanners published. LPG MIPS, reader referred respectivearticles appear JAIR special issue (Gerevini et al., 2003a Edelkamp, 2003).Figure 8 shows, SemSyn solve single smallest instance, MIPS solves 10instances scattered across whole set. Metric-FF LPG solve instancesexhibit similar behavior. Metric-FF planner solve two largestinstances. stated above, show curves congurations favoring speed.competition data, version Metric-FF called \FF.speed", version LPGcalled \LPG.speed", version MIPS called \MIPS.plain".320fiTranslating \Ignoring Delete Lists" Numeric State Variablesassess relative plan quality behavior (i.e., plan length minimization expressionvalue), computed quotients follows. Given planners B, measure, instances solved planners, A's plan quality divided B's plan quality. Computeaverage quotient. points need absolute measure comparisonparticipating planners domain, set planner B hypothetical \Best-of"planner whose data obtained selecting best (i.e., lowest) results planners.individual planners domain ranked comparing Best-of.data obtained concerning plan length Depots, planners shown Figure 8,this. FF.speed's plans average 1:23 times long Best-of's plans, LPG.speed'splans average 1:25 times long Best-of's plans, MIPS.plain's plansaverage 1:29 times long Best-of's plans. Thus plan lengths roughly similar here.single instance SemSyn solves, plan 5 steps FF.speed's 10steps, LPG.speed MIPS.plain 11 steps.next comment algorithms used planner versions favoring quality.MIPS, similar Metric-FF, optimization mode heuristic function becomes kindrelaxed plan cost algorithm. contrast, LPG optimization method startsrst plan, continues search plans better. Metric-FF performsbest-rst search function f (s) = wg g(s)+ wh h(s). competition, weightsset wg = 1 wh = 5. quality version MIPS simply called \MIPS"competition data. improve readability call \MIPS.quality" here, similarquality-favoring versions Metric-FF LPG, called \FF.quality" \LPG.quality".optimization criterion Depots minimize overall fuel consumption. runtime, quality versions MIPS LPG behave slightly worse speedversions. contrast, Metric-FF's quality version solves smallest 3 instances.solution quality, fuel consumption FF.speedrst 3 instances 22, 33, 35,FF.quality 22, 33, 36. Thus optimization e ect observable.instances, MIPS.qualitynds costly plans (32, 63, 44), LPG.quality'splans slightly better (22, 33, 29). Across instances, LPG.quality's plans consume, average, 1:01 times fuel Best-of's plans consume, average value1:46 MIPS.quality.7.2 DriverlogDriverlog domain variation Logistics trucks need drivers,underlying map arbitrary undirected graph (as opposed fully connected graphsstandard version domain). Drivers move di erent paths trucks.numeric constructs specify total time driven walked. Figure 9 showsruntime data 20 Driverlog instances used competition.Depots, participating planners Metric-FF, LPG, MIPS, SemSyn.Again, SemSyn solved smallest instance. LPG.speed plannersolves instances. FF.speed solves one task MIPS.plain (the respective datapoint almost hidden behind \SemSyn" top right corner), roughly fastLPG.speed tasks solves. plan length, none plannersclearly superior. average quotients versus Best-of are: 1:34 FF.speed, 1:44LPG.speed, 1:21 MIPS.plain. FF.speed's LPG.speed's plan lengths thus321fiHoffmann100"FF.speed""LPG.speed""MIPS.plain""SemSyn"1010.10.011234567891011121314151617181920Figure 9: Runtime curves Driverlog instances planners favoring speed. Timeshown logarithmic scale, instance size scales left right.average somewhat longer MIPS.plain. di erence tendencygrow instance size, though. single instance solved SemSyn, SemSyn's plan3 steps planners 8.optimization criterion Driverlog minimize (instance-specic) linearcombination total time, driven distance, walked distance. FF.quality's runtimebehavior is, Depots, lot worse FF.speed, solving 5 smallerinstances. quality plans slightly better, though, 0:94 times FF.speed's valuesaverage. MIPS.quality LPG.quality solve instances speed-favoringcounterparts. average comparison LPG.quality Best-of 1:00 (precisely 1:000411),MIPS.quality 1:31 { single instance, MIPS.quality's plan consumes less fuel(730 units) LPG.quality's plan (736 units).competition also featured version Driverlog (\Hard-Numeric") drivingtruck consumes fuel proportional square load, criterion minimizeinstance-specic linear combination total time fuel consumption. Interestingly,optimization criterion FF.quality slightly less ecient FF.speed, solvinginstances speed-favoring version. come back phenomenonoutlook, discuss e ect optimization expressions runtime performance.overall runtime performance planners similar domain versiondescribed above. optimization expression, FF.quality's values average 0:77times FF.speed (so optimization e ect observed). comparisonBest-of 1:59 FF.quality, 1:007 LPG.quality, 1:72 MIPS.quality.322fiTranslating \Ignoring Delete Lists" Numeric State Variables7.3 ZenotravelZenotravel domain, used competition, rather classical transportationdomain, objects must transported via airplanes. planes use fuel,either slow fast. Fast movement consumes fuel. numeric versiondomain, fuel level plane overall fuel usage numeric variables.addition, numeric variable counts passengers board plane, fast movementallowed number passengers certain threshold. refuel operatorused set fuel level plane back maximum capacity. Without durations,di erence e ects slow fast ying lie higher fuel consumption,thus \fast" ying useless action. Figure 10 shows runtime data 20 Zenotravelinstances used competition.1000"FF.speed""LPG.speed""MIPS.plain""SemSyn"1001010.10.011234567891011121314151617181920Figure 10: Runtime curves Zenotravel instances planners favoring speed. Timeshown logarithmic scale, instance size scales left right.Again, participating planners Metric-FF, LPG, MIPS, SemSyn. SemSyn solves smallest three instances, planners solve whole test set.FF.speed order magnitude faster LPG.speed MIPS.plain. plan length,FF.speed MIPS.plain behave similarly, LPG.speednds somewhat longer plans.quotient values versus Best-of 1:28 FF.speed, 1:45 LPG.speed, 1:22MIPS. visualizing data, onends di erence LPG.speed'sFF.speed's plans grows instance size. SemSyn, again,nds best (shortest) plansinstances solves. quotients FF.speed versus SemSyn 1:00, 2:72,4:50 three instances solved SemSyn.323fiHoffmannoptimization criterion Zenotravel minimize (instance-specic) linearcombination total time fuel consumption. FF.quality's runtime behavior worseFF.speed, solving smaller half test set. MIPS.quality solvesrst 16 instances, LPG.quality solves largest instance. optimizationcriterion values FF.quality average 0:82 times FF.speed, optimizatione ect observed. quotient values versus Best-of 1:51 FF.quality, 1:39LPG.quality, 1:14 MIPS.quality.7.4 SatelliteSatellite, number Satellites must make number observations using installedinstruments. involves turning Satellites right direction, switching instruments , calibrating instruments, taking images. numeric versiondomain, turning Satellites consumes (non-replenishable) fuel, images occupydata memory, Satellites limited data memory capacity. Figure 11 showsruntime data 20 problem instances used competition.1000"FF.speed""LPG.speed""MIPS.plain""TP4"1001010.10.011234567891011121314151617181920Figure 11: Runtime curves Satellite instances planners favoring speed. Timeshown logarithmic scale, instance size scales left right.domain, participating planners Metric-FF, LPG, MIPS, TP4(Haslum & Ge ner, 2001). TP4 (whichnds plans optimal makespan) solves 3smallest instances, MIPS.plain solves 7 smaller instances, LPG.speed solves 10instances, FF.speed solves 14. Note, though, instances LPG.speed failssolve FF.speed solves mainly smaller ones. plan length, quotientsversus Best-of 1:11 FF.speed, 1:04 LPG.speed MIPS.plain, 1:09 TP4.324fiTranslating \Ignoring Delete Lists" Numeric State Variablesplan lengths roughly similar, LPG.speed MIPS.plain seem slightadvantage FF.speed.optimization criterion Satellite minimize overall fuel consumption.FF.quality's (MIPS.quality's) runtime behavior lot worse FF.speed(MIPS.plain), solving 2 (4) smallest instances. LPG.quality solves instances LPG.speed. fuel consumption FF.speed 2 instances FF.qualitysolves 109 97. FF.quality 109 83, slight optimizatione ect one two instances. LPG.qualitynds best plans instancessolves (thus quotient versus Best-of constantly 1:00), comparison MIPS.qualityBest-of 2:54.competition also featured version Satellite (\Hard-Numeric")logical numeric goals all, optimization criterion maximize amountstored data (i.e., memory occupied taken images). exampleoptimization criterion transformed action costs sense explainedSection 6.3. actions take images negative costs. Metric-FF thus rejectsoptimization criterion reports, instances, trivially solvedempty plan. Similarly, plans returned MIPS.plain empty. MIPS.qualityversionnds non-trivial plans smaller half instances. LPGdata competition results domain version.7.5 RoversRovers, number planetary rovers must analyze number rock soil samples,take number images. involves navigating rovers, taking dropping samples(rovers hold one sample time), calibrating camera taking images,communicating data lander. numeric version domain, activitiesdecrease energy available rover certain amount, energy rechargeoperator applied rover located sunny spot. Figure 11 showsruntime data 20 Rovers instances used competition.participating planners domain Metric-FF, LPG, MIPS. Noneplanners solve whole test set, fact LPG, scales best, plannersolve larger instances.18 smaller instances solved quicklythree participants. FF.speed might slight plan length advantage. quotientsversus Best-of 1:02 FF.speed, 1:26 LPG.speed, 1:19 MIPS.plain.optimization criterion Rovers minimize number recharge actionsapplied plan (i.e., cost recharging 1, cost actions 0).optimization criterion, FF.quality solve single instance (we returnoutlook). MIPS.quality LPG.quality solve instancesspeed-favoring counterparts. LPG.quality's plan quality 0 8 instancesMIPS.quality solves. MIPS.quality's plans contain 0 recharge actions three cases, 1recharge action four cases, 2 recharge actions one case.18. actual competition data, LPG failed solve 8 instances due implementation bug.show corrected data provided Alfonso Gerevini.325fiHoffmann100"FF.speed""LPG.speed""MIPS.plain"1010.10.011234567891011121314151617181920Figure 12: Runtime curves Rovers instances planners favoring speed. Timeshown logarithmic scale, instance size scales left right.7.6 SettlersSettlers domain building infrastructure unsettled area. thingsbuilt include housing, railway tracks, sawmills, etc. lot operatorschemata encoding complex building process. raw materials, timber, stone, ore,mustrst felled, broken, mined. One process timber wood coal,process ore iron. Carts, trains, ships built transport materials. Onecombine materials build docks, wharfs, rails, housing, etc. encoding makesintensive use numeric variables domains. domainsnumeric constructs mainly encode resource constraints action costs, Settlersnumeric variables play active part achieving goal. Indeed, many operatorschemata logical e ects all. example, felling timber increases amounttimber available respective location one unit. Loading (unloading) materialunit onto (from) vehicle encoded increasing (decreasing) respective materialavailability vehicle decreasing (increasing) material's availabilityrespective location. building housing unit least one wood stone unit mustavailable, resulting increased housing units decreased wood stone units.numeric variables playing active role domain encoding, Settlersinteresting benchmark numeric planners. Figure 11 shows runtime data 20Settlers instances used competition.Metric-FF MIPS (in versions favor speed) able solveSettlers instances. LPG could participate domain operators326fiTranslating \Ignoring Delete Lists" Numeric State Variables1000"FF.speed""MIPS"1001010.10.011234567891011121314151617181920Figure 13: Runtime curves Settlers instances planners favoring speed. Timeshown logarithmic scale, instance size scales left right.make use universally quantied e ects, LPG support. MIPS.plain solvessingle instance FF.speed solves 6 smallest instances. notedinstances example suite appear rather large. FF.speed's plans6 smallest instances contain 53, 26, 102, 67, 74, 81 actions respectively.comparison, domains except Depots FF.speed's longest planrst 6instances contains 26 steps. Depots numbers 10, 15, 35, 34, 75, 6th instanceisn't solved planner. plan MIPS.plainnds second smallest instancecontains 36 steps (as stated FF.speed's plan instance contains 26 steps).planner favoring quality solved Settlers instances.7.7 Performance Summaryspeed-favoring congurations, Metric-FF LPG perform best, termsruntime solution length. runtime, Driverlog Rovers, LPG scales better(solves instances). Zenotravel, Metric-FF scales better (an order magnitudeadvantage runtime). Settlers, LPG could run, Metric-FF solverather large instances. Depots Satellite, slight advantage Metric-FF,solves instances. MIPS lags behind Metric-FF LPGdomains except Zenotravel scales roughly similar LPG. solution length,roughly similar LPG Metric-FF domains except Zenotravel,LPG's plans longer. Satellite might slight advantage LPG,327fiHoffmannRovers might slight advantage Metric-FF. plan lengths MIPSroughly similar Metric-FF across domains.results Metric-FF optimization mode, FF.quality, less satisfying, leastfar runtime behavior concerned. FF.quality solve single instance RoversSettlers, solves instances Depots, Driverlog (with normal,i.e. \hard" optimization expression), Satellite. FF.quality's runtime behaviorreasonably good Zenotravel Driverlog (with \hard" optimization expression).solution quality behavior mixed. cases observed FF.quality'splans better sense optimization criterion FF.speed's plans are. Betterplan quality clearly observable Driverlog (with \hard" optimization expression)Zenotravel. also observable Driverlog (with normal optimization expression)Satellite, although small number instances solved domains.Compared LPG.quality MIPS.quality, FF.quality quality-favoring plannershows dramatically worse runtime behavior speed-favoring counterpart.reasons must lie algorithmic di erences systems, concerningway treat optimization expressions. outlook speculate reasonsFF.quality's poor runtime behavior, might done it.8. Conclusion Outlookpresented natural extension popular heuristic technique STRIPS {ignoring delete lists { numeric planning. straightforward implementation MetricFF based technique one two best performing numeric planning systemsIPC-3.Let us summarize contributions work little detail.important contribution \monotonicity" idea, i.e., numeric frameworkmain STRIPS concepts (pre/goal-conditions, add lists, delete lists) translatenaturally numeric concepts (monotonic constraints, increasing e ects, decreasinge ects). monotonicity idea might useful many contexts beside specicheuristic planner implementation focus article (some ideas givenoutlook below). heuristic context considered here, have:Abstracted desirable properties (admissibility, basic informedness, polynomiality) ignoring delete lists relaxation STRIPS.Dened natural extension relaxation numeric case provided sufcient criteria identify numeric tasks relaxation preserves desirableproperties.Dened subset PDDL2.1 level 2, linear tasks, sucient criteriaachieved pre-processing technique.Dened algorithms solve relaxed tasks language thus provide heuristic function.Implemented straightforward extension FF,rst technique takes userspecied optimization criteria account. FF extension (FF.speed) shows reasonable performance across number benchmark domains. Specically performed328fiTranslating \Ignoring Delete Lists" Numeric State Variablesbest, together LPG, numeric track 3rd International Planning Competition, terms runtime solution length.19 runtime behavioroptimization technique (FF.quality) unsatisfying, plan quality improvementsobserved.Various research topics left open:background theory given Section 4.2 provides sucient criterianumeric relaxation adequate. question is, weaker sucient criteria, one come complete analysis (i.e.,nd exact bordersbeyond ignoring decreasing e ects longer adequate)? Also,identied borderlines translate, syntactically, mathematical constructs allowedPDDL2.1 level 2?pre-processing algorithm given Section 4.3 (transforming linear tasks LNFtasks) dened linear tasks only. extended richer language classes?Similarly, algorithms given Section 5.2 work LNF. easyextension richer language classes?mentioned Section 4.3, various kinds numeric e ects easily translated(e.g., := e ects += e ects vice versa), respectivetranslations behave di erently relaxation. one identify problem classesone formulation yields better heuristic performance?current optimization technique, FF.quality, restricted optimization criteriatransformed action cost minimization according certain simpletranslation schema. general optimization criteria handled?seen runtime performance FF.quality unsatisfying.appears interaction (as exemplied two di erent quality metricsDriverlog) form optimization (i.e., action cost minimization)expression runtime behavior. explanation might degree \goaldirectedness" minimization expression. Intuitively, minimization expressiongoal-directed closely correlated goal distance, i.e., lower expressionvalue nearer goal vice versa. maximally goal-directed minimizationexpression goal distance (i.e., \total-time" sequential framework).contrast, minimization expression Rovers, number recharge operations,loosely connected goal distance. would worthwhile comegood formal notion goal-directedness, investigate connectionruntime performance (in Driverlog connection less obvious Rovers).practical side, algorithms remain found show better performancematter form optimization expression is. One option alwaysintegrate, extent, current goal distance estimate (i.e., length19. Note one easily imagine domains relaxed plans way Metric-FF uses wouldlikely yield good heuristic information. example, consider 15-puzzle, numeric variablesencoding positions tiles. situation, large degree interactionnumeric variables, relaxed plans presumably able capture interaction.329fiHoffmannrelaxed plan case) remaining cost estimation. Another option usedi erent search schemes. branch-and-bound like approach appears possible (rstnd plan quickly use cost plan upper boundexploration search space).would exciting explore impact monotonicity idea, i.e., correspondence brings pre/goal-conditions monotonic constraints, add listsincreasing e ects, well delete lists decreasing e ects, di erent contextsplanning research. Examples spring mind heuristic approaches, Graphplanbased numeric planning, goal ordering techniques. stimulate imaginationreader:seems likely similar methods used heuristic approachesrelax task ignoring delete lists. example, techniques presumably adapted heuristic estimators partial order framework used RePOP(Nguyen & Kambhampati, 2001), yielding heuristic numeric partial-order planner.Also, appears feasible integrate techniques Sapa's (Do & Kambhampati, 2001) heuristic function, possibly making function accurate variousnumeric situations. another possible avenue, one might able adapt techniques presented use LPG's heuristic precondition cost estimation process(Gerevini, Serina, Saetti, & Spinoni, 2003b), making sensitive numericconstructs, thereby { potentially { improving LPG's performance.Koehler's extension IPP numeric context (Koehler, 1998) su ers complications backward search procedure, signicantly degrade runtime performance. diculties arise monotonic context?Koehler Ho mann (2000a) argue reasonable ordering Btwo goals B if, states achievedrst, one mustdelete order achieve B . monotonicity, straightforward translationtwo numeric goals B ordered Bif, valuesvariables participate sucient achieve A, values mustdecreased necessary value order achieve B . seemsKoehler Ho mann's techniques approximate STRIPS goal orderings transfereasily situation. Similarly, seems monotonicity denitionsapproximation techniques given landmarks (subgoals necessarilyarise planning) Porteous, Sebastia, Ho mann (2001) directlytransferred numeric goals.Acknowledgmentsarticle extended revised version paper (Ho mann, 2002a)published ECAI-02. Metric-FF developed implemented authorvisiting Durham Planning Group, Durham, UK. Thanks go Maria Fox DerekLong discussions, making stay enjoyable. Thanks also go Malte Helmert330fiTranslating \Ignoring Delete Lists" Numeric State Variablesfruitful remarks relaxation theory. thank David Smith insightsnature inverted variables, many detailed comments language. Finallythank anonymous reviewers comments, helped improve paper.Appendix A. Proofsappendix presents proofs theorems detail. three di erent classesresults, focus turn: relaxation adequacy, relaxed Graphplan completeness,relaxed Graphplan correctness. Within classes, results givenlanguages increasing expressivity.A.1 Relaxation AdequacySTRIPS, restricted numeric language, numeric tasks general, proverespective relaxations adequate (in general case, identify situationsrelaxation adequate). proof STRIPS case trivial.Proposition 1 relaxation given Denition 1 adequate, i.e., following holdstrue.1. Admissibility: plan solves original task also solves relaxed task,i.e., assuming STRIPS task (P G), plan (P G) also relaxedplan (P G).2. Basic informedness: preconditions goals trivially achievedoriginal task holds relaxed task, i.e., assumingSTRIPS task (P G), hi plan (P G) hi relaxed plan (P G), 2 A, result(I hi) pre(a)result(I hi) pre(a+ ).3. Polynomiality: relaxed task solved polynomial time, i.e., decidingRPLANSAT P.Proof: 1. application action relaxed action sequence, leastpropositions true true real sequence. action precondition,goal, fullled.2. Holds dropping precondition goal constraints. emptyplan hi plan (P G) G holds. true (P A+ G).Similarly action preconditions.3. proved Bylander (1994).2proof case restricted numeric language straightforward extensionSTRIPS proof, exploiting correspondence pre/goal-conditions, add lists,delete lists one hand, x ff >]c constraints, += e ects, -= e ectshand.Theorem 1 relaxation given Denition 5 adequate, i.e., following holds true.331fiHoffmann1. Admissibility: assuming restricted numeric task (V P G), plan(V P G) also relaxed plan (V P G).2. Basic informedness: assuming restricted numeric task (V P G), hi plan(V P G) hi relaxed plan (V P G), 2 A,result(I hi) j= pre(a) result(I hi) j= pre(a+ ).3. Polynomiality: deciding RESTRICTED-RPLANSAT P.Proof: 1. application step relaxed plan, least propositionstrue true real plan, values numeric variables least highreal plan. action preconditions goal require variable valuesgreater equal constant, constraints remain fullled.2. Holds dropping precondition goal constraints. emptyplan hi plan (V P G) j= G holds. true(V P A+ G). Similarly action preconditions.3. following polynomial time algorithm decides RESTRICTED-RPLANSAT.:= , := v(I )remove, action preconditions goal, propositionsnumeric constraints fullled mi values (i.e., mi ff >]c)G 6=:= fa 2 j pre(a) = g0 := Sa2A p(e (a))+m0 :=2 f1 : : : ng mi 6= 19a 2 : (vi += c) 2 v(e (a)) (m0 )i := 1 endifendfor0 = m0 = fail endif:= 0, := m0remove, action preconditions goal, propositionsnumeric constraints fullled mi valuesendwhilesucceedRemember n denotes number numeric variables. Denote action setiteration algorithm. prove algorithm succeeds relaxedplan, relaxed plan algorithm succeeds, algorithm takespolynomial time size task.relaxed plan ha1 : : : ak (V P G), 2 holds true1k: set (the values m) always include (are always least high as) truefacts relaxed plan (the variable values relaxed plan). algorithm succeedsk iterations. fail earlier impliesxpoint contradictionreachability goals.direction, algorithm succeeds iteration k one constructrelaxed plan. Simply linearize (relaxations the) actions sets A1 : : : Ak332fiTranslating \Ignoring Delete Lists" Numeric State Variablesarbitrary order. action layer += e ect variable xi , repeatedlyexecute action constraints xi removed iterationfullled (as constraints form xi ff >]c, eventually happen).actions applied way preconditions fullled emptyrespective iteration, execution sequence makes constraints truealgorithm.runtime, single iteration polynomial. upper bound numberiterations jV j + jP j. iteration, avoid failure, least one new proposition mustenter one new variable value must set 1.2Generalizing restricted language, ignoring decreasing e ects adequatenumeric constraints monotonic, numeric e ects strongly monotonic (pluschanges due := e ects propagate numeric variable's value). proofgeneralizes, way, proof above.Theorem 2 relaxation given Denition 7 adequate strongly monotonic tasksacyclic := e ects, i.e., following holds true.1. Admissibility: assuming monotonic numeric task (V P G), plan(V P G) also relaxed plan (V P G).2. Basic informedness: assuming numeric task (V P G), hi plan(V P G) hi relaxed plan (V P G), 2result(I hi) j= pre(a) result+(I hi) j= pre(a).3. Polynomiality: deciding STRONGLY-MONOTONIC-RPLANSAT P.Proof: 1. Say ha1 : : : ani plan (V P G). Executing sequence result,precondition goal constraints fullled. Denote vi (t) value variableexecution action , denote vi (t)+ value variable executionaction result+. show vi (t)vi (t)+ t. monotonicitynumeric constraints, Denition 8 condition (1), suces. claim easily showninduction t. = 1, vi (1)vi (1)+ holds simply result+identical result except e ects decrease value variable ignored.+ 1, vi (t)vi (t)+ vi (t + 1)vi (t + 1)+ holds dueargument, plus monotonicity numeric e ects sense Denition 8condition (2): higher input numeric variables are, higher resulting valueected variable becomes.2. empty plan hi plan (V P G) j= G holds.true hi relaxed plan, dropping goal constraints. Similarlyaction preconditions.3. following polynomial time algorithm decides relaxed solvabilitystrongly monotonic task acyclic := e ects.1. := , := v(I )2. remove, action preconditions goal, propositions333fiHoffmann3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.numeric constraints fullled mi valuesG 6=:= fa 2 ASj pre(a) = g0 := a2A p(e (a))+m0 :=2 f1 : : : ng mi 6= 19a 2 (vi ass exp) 2 v(e (a)) :ass 2 f+= -= = /=g (vi ass exp)(m) > mi (m0 )i := 1 endifendfor2 f1 : : : ng mi 6= 19a 2 (vi := exp) 2 v(e (a)) : (vi := exp)(m) > mi(m0 )i := maxa2A (v := exp)2v(e (a)):(v := exp)(m)>m (vi := exp)(m)endifendfor0 = m0 = fail endif:= 0 , := m0remove, action preconditions goal, propositionsnumeric constraints fullled mi values19. endwhile20. succeedHere, above, v(exp) expression exp denotes set variables containedexp. value expression contains variables setnity givenlimit expression variables. Note assumption limits 1(Denition 8 condition (4)) can, particular, computed eciently. provealgorithm succeeds relaxed plan, relaxed planalgorithm succeeds, algorithm takes polynomial time size task.Denote action set iteration algorithm. relaxed planha1 : : : ak (V P G), 2 holds true 1k: variable updatesperformed algorithm always least high performedresult+ function. Note line 13 takes maximum available := e ects.Note also e ects obey Denition 8 condition (2), one needs considermaximum input values order obtain maximum output value. consequence,monotonicity numeric constraints sense Denition 8 condition (1), algorithmreaches goals succeeds k iterations. fail earlierimpliesxpoint contradiction reachability goals.algorithm succeeds iteration k one construct relaxed planfollows. Perform upwards loop 1 k. iteration t, repeatedly applyactions constraints removed line 18, iteration t,fullled. show point eventually reached. pointreached, one continue next higher value step succeedingiteration k completed. actions applied way preconditionsfullled empty iteration actions applied, constructed relaxed plan always fullls constraints removed iteration,Denition 8 condition (1) constraints become false334fiTranslating \Ignoring Delete Lists" Numeric State Variablestrue relaxed plan. reason goals fullled end iterationk. remains show that, iteration t, repeatedly applying actionseventually fulconstraints removed iteration. Denote setvariables got set, iteration t, 1 line 9, denote It0 set variablesgot set 1 line 13, denote Ft set variables got set new value1 line 13. show that:1. one application actions variables Ft least valuesconstraint removal line 18.2. repeated application actions variables It0 reach arbitrarilyhigh values.suces constraints eventually fullled. Assume two claims holdtrue. Then, monotonicity constraints (Denition 8 condition (1)) variablesFt contribute least much fullllment constraints iterationdecision algorithm. variables It0,nite assignmentvariables, higher previous values, makes respective constraints truepoint. simple consequence Denition 8 condition (1) (the constraints preferhigher variable values), condition (4) (the expressions diverge variables), condition(5) (existencenite fullling assignment), fact constraintstrue previous iteration became true setting variables It0 1.rst claim follows simple fact actions responsible increasingvalues variables Ft { actions fulcondition line 12 { are,particular, contained . outcome might higher variablesrespective e ect right hand side increasedrst negative interactionsvariables considering relaxed transition function. argumentsecond claim follows. variables , contains respectiveresponsible action fullling condition lines 8 9. application actionincreases, Denition 8 condition (3), variable's value least muchprevious application, repeated application diverges. Note that, again, relaxedstate transition, applying action worsen situation variables.variables It0 , contains action fullling condition line 13,(vi := exp) 2 v(e (a)), exp containing least one variable v0 2 v(exp) set 1point (as (vi := exp)(m) = 1). Recursively, responsible action a0 setting v0 1 mustincluded previous iteration. e ect a0 v0 := e ect,responsible action must included earlier, on. one point, responsibleaction a00 respective ancestor variable v00 must included line 9. Repeatedapplication a00 causes value v00 diverge (with argument above),e ect transitively causes value vi diverge.nally remains show algorithm terminates polynomial time. Obviouslysingle iteration polynomial. number iterations bounded numbertimes 0 m0 di erent respectively m. Changes values occurlines 5, 9, 13. overall number changes line 5 bound numberlogical propositions, jP j. overall number changes line 9 bound numbernumeric variables, jV j. exponential number iterations termination335fiHoffmannwould exponential number consecutive iterations changes occurline 13. number consecutive iterations is, however, bound jV j jAj.seen follows. Throughout entire sequence iterations, := e ectscontribute changes. := e ects acyclic assumption valuechange propagate value, possible changeoccur new action comes in. takes jV j iterations propagate changesvariables (this length longest possible propagation path), so,least one new action comes iteration t, another new action comesiteration + jV j latest. obvious bound number iterations newactions come jAj, concludes argument.2A.2 Relaxed Graphplan CompletenessSTRIPS LNF tasks prove respective relaxed Graphplan mechanismscomplete, i.e.,nd relaxed plan one. proof STRIPScase trivial.Proposition 2 Assume STRIPS task (P G), state s. algorithm depictedFigure 1 fails, relaxed plan (P G).Proof: show contrapositive, i.e., relaxed plan (P G),algorithm succeeds. Say relaxed plan P = ha1 : : : (P G).algorithm applies,rst layer, possible actions. particular, includes a1 ,layer P1 least facts true true executingrst step P .argument inductively applied actions P , implying layer2 , Pt contains facts true upon executionrst actionsP . implies goals true layer m0m, G Pm . Moreover,algorithm fail layer m00 < m0 : followsxpoint reached,Pi = Pm > m00 , G 6 Pm , contradicts assumptions.20000proof LNF tasks proceeds along line, requires caredetails concerning values beyond numeric variables longer contributesolution.Theorem 3 Assume linear numeric task (V P G) LNF acyclic:= e ects. Assume state s. algorithm depicted Figure 6 fails,relaxed plan (V P G).Proof: show contrapositive, i.e., relaxed plan (V P G),algorithm succeeds. Say relaxed plan P = ha1 : : : (V P G).algorithm applies,rst layer, possible actions. particular, includes a1 ,layer P1 least facts true true executingrst step P ,maxi1 values least high respective variable values. Togetherfact e ect right hand sides positively monotonic (so inserting maxtvalues increase outcome), argument inductively appliedactions P , implying layer 2 , Pt contains factstrue upon executionrst actions P , maxit values least high336fiTranslating \Ignoring Delete Lists" Numeric State Variablesrespective variable values. This, monotonicity numeric constraints,implies goals reached layer m0m, p(G) Pm(exp ff >] 0) 2 v(G) : exp(maxm ) ff >]0. Moreover, algorithm faillayer m00 < m0 . Assume does. m00 new propositions come in,maxi values either changed, already maximum needed value.Denote L set variables vi whose value still low, maximmneedi (s). NoteL rV holds since outside rV mneed values ;1. Pm +1 = Pmand, vi 2 L, maxim +1 = maxim . show Pm +2 = Pm +1 and, vi 2 L,maxim +2 = maxim +1 . proves claim: iterating argument, holdstrue layers > m00 + 1, get contradiction goals reached m0(note constraints variable V n L participates already fullled,increasing variables reach new goal constraints). set propositionscould increase layer m00 +2 new action came in, i.e., 2 +1 , 62 .value variable vi 2 L could increase layer m00 + 2 if: new action came+= e ect right hand side expression (vi += exp) became positive +1 resultincreasing V n L variable values m00 m00 + 1 := right hand side expression(vi := exp) +1 became higher maxim +1 result increasing V n Lvariable values m00 m00 + 1. None three cases occur denitionmneed values (that variables V n L reached).rst case, +1contain new action new precondition constraints became truem00 m00 + 1 { V n L variable values increased, constraintsparticipate already fullled m00 . second case, (vi += exp) e ectright hand sides V n L variables participate already 0 valuesm00 (vi 2 L rV , mneed denition += e ects applies). third case,occurred least one variable vj 2 V n L contained right handside responsible e ect (vi := exp). variable would fulmaxjm > mneedj (s),thus exp(maxm ) > mneedi (s) would hold (vi 2 L rV , mneed denition :=e ects applies), thus maxim +1 > mneedi (s) would hold (through application (vi := exp)) contradiction assumptions. concludes argument.20000000000000000000000000000000000000000A.3 Relaxed Graphplan CorrectnessSTRIPS LNF tasks prove respective relaxed Graphplan mechanismscorrect, i.e., actions select form relaxed plan. proof STRIPScase trivial.Proposition 3 Assume STRIPS task (P G), state algorithmdepicted Figure 1 reaches goals. actions selected algorithm depictedFigure 2 form relaxed plan (P G).Proof: First, note layer goal g 2 Gt, least one actionlevel(a) = ; 1, g 2 e (a)+, due way levels computed. Also,action's preconditions always lower level action itself.algorithm selects set layer t. arrange actionssets arbitrary order obtain relaxed plan (P A+ G). goals337fiHoffmannsub-goals layer achieved actions At;1 . delete e ectsignored, least propositions true needed.2proof LNF tasks straightforward extension STRIPS proof.Theorem 4 Assume linear numeric task (V P G) LNF acyclic :=e ects. Assume state algorithm depicted Figure 6 reaches goals.actions selected algorithm depicted Figure 7 form relaxed plan (V P G).Proof: First, note layer goal g 2 Gt, least one actionlevel(a) = ; 1, g 2 e (a)+ , due way levels computed.numeric goals (exp ff >] 0) 2 v(Gt ), always := e ect suciently high righthand side value,maxit ;Xa2At :(vi += exp)2v(e (a)) exp(maxt 1 )>0exp(maxt;1 ) = maxit;1;holds.rst case loop entered, second case terminatessuccessfully. Note one occurrence action support di erent logical numericgoals di erent e ects, used support numeric goal twice.Denote, layer t, set actions selected algorithm layer.arrange actions sets arbitrary order obtain relaxed plan(A+ G). goals sub-goals layer t, logical numeric, achievedactions At;1 . expressions numeric goals e ect right hand sidesalways least high required constrain contained variables takerespective maximum values. delete e ects ignored, least propositionstrue needed. decreasing e ects ignored monotonicity e ectright hand sides, expression values constraints least high required. 2ReferencesBacchus, F. (2001). AIPS'00 planning competition. AI Magazine, 22 (3), 47{56.Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. ArticialIntelligence, 90 (1-2), 279{298.Bonet, B., & Ge ner, H. (1998). HSP: Heuristic search planner. AIPS-98 PlanningCompetition, Pittsburgh, PA.Bonet, B., & Ge ner, H. (1999). Planning heuristic search: New results. Biundo,S., & Fox, M. (Eds.), Recent Advances AI Planning. 5th European ConferencePlanning (ECP'99), pp. 60{72, Durham, UK. Springer-Verlag.Bonet, B., & Ge ner, H. (2001). Planning heuristic search. Articial Intelligence, 129 (1{2), 5{33.Bonet, B., Loerincs, G., & Ge ner, H. (1997). robust fast action selection mechanism planning. Proceedings 14th National Conference AmericanAssociation Articial Intelligence (AAAI-97), pp. 714{719. MIT Press.338fiTranslating \Ignoring Delete Lists" Numeric State VariablesBylander, T. (1994). computational complexity propositional STRIPS planning.Articial Intelligence, 69 (1{2), 165{204.Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metrictemporal planner. Cesta, A., & Borrajo, D. (Eds.), Recent Advances AI Planning. 6th European Conference Planning (ECP'01), pp. 109{120, Toledo, Spain.Springer-Verlag.Edelkamp, S. (2003). Taming numbers durations model checking integratedplanning system. Journal Articial Intelligence Research. issue.Edelkamp, S., & Helmert, M. (2001). MIPS: model checking integrated planning system.AI Magazine, 22 (3), 67{71.Fikes, R. E., & Nilsson, N. (1971). STRIPS: new approach application theoremproving problem solving. Articial Intelligence, 2, 189{208.Fox, M., & Long, D. (2001). STAN4: hybrid planning strategy based subproblemabstraction. AI Magazine, 22 (3), 81{84.Fox, M., & Long, D. (2002). third international planning competition: Temporalmetric planning. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings6th International Conference Articial Intelligence Planning Scheduling(AIPS-02), pp. 333{335, Toulouse, France. Morgan Kaufmann.Gazen, B. C., & Knoblock, C. (1997). Combining expressiveness UCPOPeciency Graphplan. Steel, S., & Alami, R. (Eds.), Recent AdvancesAI Planning. 4th European Conference Planning (ECP'97), Vol. 1348 LectureNotes Articial Intelligence, pp. 221{233, Toulouse, France. Springer-Verlag.Gerevini, A., Saetti, A., & Serina, I. (2003a). Planning stochastic local searchtemporal action graphs. Journal Articial Intelligence Research. issue.Gerevini, A., Serina, I., Saetti, A., & Spinoni, S. (2003b). Local search techniquestemporal planning LPG. Proceedings 13th International ConferenceAutomated Planning Scheduling (ICAPS-03), Trento, Italy. Morgan Kaufmann.Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporalplanner. Proceedings 2nd International Conference Articial IntelligencePlanning Systems (AIPS-94), pp. 61{67, Chicago, IL. AAAI Press, Menlo Park.Haslum, P., & Ge ner, H. (2001). Heuristic planning time resources. Cesta,A., & Borrajo, D. (Eds.), Recent Advances AI Planning. 6th European ConferencePlanning (ECP'01), pp. 121{132, Toledo, Spain. Springer-Verlag.Helmert, M. (2002). Decidability undecidability results planning numericalstate variables. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings6th International Conference Articial Intelligence Planning Scheduling(AIPS-02), pp. 44{53, Toulouse, France. Morgan Kaufmann.Ho mann, J. (2000). heuristic domain independent planning use enforced hill-climbing algorithm. Proceedings 12th International SymposiumMethodologies Intelligent Systems (ISMIS-00), pp. 216{227. Springer-Verlag.339fiHoffmannHo mann, J. (2001). Local search topology planning benchmarks: empirical analysis.Nebel, B. (Ed.), Proceedings 17th International Joint Conference ArticialIntelligence (IJCAI-01), pp. 453{458, Seattle, Washington, USA. Morgan Kaufmann.Ho mann, J. (2002a). Extending FF numerical state variables. Proceedings15th European Conference Articial Intelligence (ECAI-02), pp. 571{575, Lyon,France. Wiley.Ho mann, J. (2002b). Local search topology planning benchmarks: theoretical analysis.Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings 6th International Conference Articial Intelligence Planning Scheduling (AIPS-02), pp.92{100, Toulouse, France. Morgan Kaufmann.Ho mann, J., & Nebel, B. (2001). FF planning system: Fast plan generationheuristic search. Journal Articial Intelligence Research, 14, 253{302.Koehler, J. (1998). Planning resource constraints. Proceedings 13th EuropeanConference Articial Intelligence (ECAI-98), pp. 489{493, Brighton, UK. Wiley.Koehler, J., & Ho mann, J. (2000a). reasonable forced goal orderings useagenda-driven planning algorithm. Journal Articial Intelligence Research,12, 338{386.Koehler, J., & Ho mann, J. (2000b). instantiation ADL operators involvingarbitraryrst-order formulas. Proceedings ECAI-00 Workshop New ResultsPlanning, Scheduling Design.Long, D., & Fox, M. (2003). 3rd international planning competition: Resultsanalysis. Journal Articial Intelligence Research. issue.McDermott, D. (1996). heuristic estimator means-ends analysis planning.Proceedings 3rd International Conference Articial Intelligence PlanningSystems (AIPS-96), pp. 142{149. AAAI Press, Menlo Park.McDermott, D. V. (1999). Using regression-match graphs control search planning.Articial Intelligence, 109 (1-2), 111{159.Nebel, B. (2000). compilability expressive power propositional planningformalisms. Journal Articial Intelligence Research, 12, 271{315.Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Nebel, B.(Ed.), Proceedings 17th International Joint Conference Articial Intelligence(IJCAI-01), pp. 459{464, Seattle, Washington, USA. Morgan Kaufmann.Pednault, E. P. (1989). ADL: Exploring middle ground STRIPS situation calculus. Brachman, R., Levesque, H. J., & Reiter, R. (Eds.), PrinciplesKnowledge Representation Reasoning: Proceedings 1st International Conference (KR-89), pp. 324{331, Toronto, ON. Morgan Kaufmann.Porteous, J., Sebastia, L., & Ho mann, J. (2001). extraction, ordering, usagelandmarks planning. Cesta, A., & Borrajo, D. (Eds.), Recent Advances AIPlanning. 6th European Conference Planning (ECP'01), pp. 37{48, Toledo, Spain.Springer-Verlag.340fiTranslating \Ignoring Delete Lists" Numeric State VariablesRefanidis, I., & Vlahavas, I. (1999). GRT: domain independent heuristic STRIPSworlds based greedy regression tables. Biundo, S., & Fox, M. (Eds.), RecentAdvances AI Planning. 5th European Conference Planning (ECP'99), pp. 47{59,Durham, UK. Springer-Verlag.Refanidis, I., & Vlahavas, I. (2000). Heuristic planning resources. Proceedings14th European Conference Articial Intelligence (ECAI-00), pp. 521{525, Berlin,Germany. Wiley.Refanidis, I., & Vlahavas, I. (2001). GRT planning system: Backward heuristic construction forward state-space planning. Journal Articial Intelligence Research,15, 115{161.Russell, S., & Norvig, P. (1995). Articial Intelligence: Modern Approach. Prentice-Hall,Englewood Cli s, NJ.Smith, D. E., & Weld, D. S. (1999). Temporal planning mutual exclusion reasoning.Proceedings 16th International Joint Conference Articial Intelligence(IJCAI-99), pp. 326{337, Stockholm, Sweden. Morgan Kaufmann.341fifffifi fi!ff fi fi fi fffififffi fffffffffifffffffifffffi fifi! fi"fffi ff ff ff ff ffff ff ff ff fi fffffffi ff ff ffffffff !ff "ffff # !"$ ff ff % ff %ff ff ffff fi ff%% ff &ff& ff ' ff (#'$ff ff ff ff 'fffffi ffff ffff ff)ff!"fffffffi & % * ff +%!" ff ff ff fi ff%ff&fffi fffffi fi fffi ff fi fi fififffi ff ffff fffiff fi ff fi fi fi ff ff fifi fi fifi fi fifffffi fi ff! "ff#$% &fi #'% ( ##% ) ff * + #,- ff ff fi fffifffi ff fifffifffifi fiff! . *+ #% / * 0fi fifi 1#% 2fi * 34ff 1#% /* 3ff11- .fiff fififi fififffififf5fi fiff ff fi fiff fiff fi fififffifffi fifffi fffififififffifffiff fififffi ff $ff fffifi )fi6!)6- fiff fi fi fiff7 !24 fi * 8 1#- fififfff ff !3ff * .fffi # 11-fffi 9ff ff fffffi ff fi fifffi!(fffi-fiff fiff fffifi fffifffffi !: * ; ff #<- &fffiff fi fififi fififf fi ff fi ff fi ffff !3ff .fffi .fi * .1$-ff fi=fffffi fifi "#$#fi fiffff fifi ff $ff )6 fi fi9 ff fi fiff > fffi fi? fi fffi fi !; * 5 1$-& fffi fiff fffiff fi fi fi fiffff fffiff !. fi 0fi @ * 6 #,- &fffififf ff fffi!&(fffi- fi(fffifi fififfff fi &(fffifi fiff fifffffi fi fififf fffffi ff fi fi fiff fifffffi fi fi fiff fffffiff ( ffff fffi fifi ff fiff fi fifi fi fffffffi fffi>fi fi? fffifi fffffi& fffffifi ff fi !&(fffi- fiff ff fi ff fi ff ffff&(fffi& fi fi &(fffifi fi ff fiffff ff fffi fi !fi fifi- fi fifi fi fifi ff fififf fiff fififi fiff fiff )fi fififffi fi fi ! ff fi fffffifffifi fi fffffi-$ff )6 fffiff fffiffff fi fi fiffff ff9ff fi fiff fiff fi fi fififf fifffi ffff fi fffi fiff fiff&fiff fffi@ fi . 1ff fi fifi fffffiff . $ ff fi fiff ffff fffffi fi fffifi fffffifi fifffi ff fi ff ffffff fi fffi fifffi fi ff fifffffifi . ,ff ff fiff fi fififf $ff )6 fi fffi ff fifffifi fffffifi . B fi ffff fi ff ff;fi fi fiff fiff fffifffi ff fiff fi fi fiff fiffff . ,fffiffff ff fffifi fffffi ff fifffififi fi fi fi fffifi fffi!: * ; ff #<-ffff fffiff(fi fffifi ff fi fffifi ff& fifffi fi fi fi fi fi fi fi,-fifi ff fffiff fi fi fi ff fifi fi ( fi fi fi ffff fi fi !fififffiff- fi fifi fi( fi fi fi ffff fifffffffiff ff ff fi fiff fi 4ff ff fi fi# & fi # fffffifi fififf !ff fi fi fifi ff fi-fi Cff!fi- ffff fi!fi - & fifi fffifi fi fififf fiff fi fi fi fi 7 ff fffffffi ffffff C D% fffffiE# ffff4 C D% ff fffffffffi E#ffff fi 4 C Ffi fi fi fi fifi fifi fi fi ffff fi fi fi C fiff fi 4& fi fi fiff fiff fi fi fffifi fiff ff !ffffffff- ff fi fi4 ff!ff ffff- ff fiff fi fiff fifffiff fi fi !fiff ffff-&fffi fifffiff fiff fi fi fififfC ff fiff fi fi fi C ff !fi fifi fi fi fiff fi fi fi fi fifi - + fi ff fi fiff fiff fi fi fifi ff fi fiff fffi !fffi -3 fififf G fffffi fffifi ff fiff fiff ff # fifi fiff !: * ; ff#<- & fffiff fffi fifffiff fi fiffff fi ff fffi & ff ffff fffiff fi fffi fi ff ff fifi : fi ; ff ffff fi ff fffifi > 4?& fffifi fffifi fffi fffi7 fi fffi fi fi fffi fi fififffi fi fi fiff fi fiHfifffi & fffi fi 9fffififf fi fffffiff fffi !; * 5 1- fi fi ff fffi+ fffi fi fi fi fi fi fffffffi fi C fi fi fi fififi 9ff ffff 4fi fi C9ff fi fi fififf fifffifififf fiff fffififffffifffififfffffffff fffffi fifi fi fi fififi fi fi,fi fiffff fiffff ffff ffffffffffff fffiff ff ff8 fi fi fi fffifi ffff fi fifi ffff fffffi fi fifffffi fifffi fiffff ff fififf fi fi fffi fffififf fi fiff fi fi fffiff !-ff fi fi fi # ffff fi fi !- 4 C ff !J # ! C fifffi fi- ( fi fffiffff fi fifi fi fi fiffffffffffff fffffiff ff ffffff ff;ff fifffiff fffi fffifififi fffi fi ff fffi ;fffffi fffiff fffiff fi fi fiffff fffi fi fiff (( (ff fififffifi fffiff !0ff 8 24 fi * /#<- fifffi ff ff ff fffi fffi fffi >fffifi? ff ff fffi 9fffiffff ffff fi ff ff fiff fffi fffifi& 9 fi fffififf fi fi fi ffffff fi 4 fi fi fi fi fififffififffiff ffffff fi ffff fifffifi ! fi- ff fi fffifi fffi &fffifi fiffff ff !3ff * .fffi 11-fi fi fiff fifffi fi fi fffffi 9 fi fffiffffffffff ffff ffff ffff C C ffffff ffffffffffff fffffiff ffffff. fffiff ff fi fffifffififi fffi ff fifi fffi!fififffifi-fiff fifi fffififf ff fifffifi fffifi fi fi fffi fiffff fi fiffff fffifififfff !: * ; ff #<-ff !; * 5 # - fi !0ff fi #<- fiff fi fffffififf fi fi fiff fi fi !0fi @ * . fi#- ff !3ff * .fffi #- fiff fi fi fffi fiff( fffffi fifffi ff @ fffiff fi fffi ff fiff ! fffifififf fi fi fiff-,fifi ff fffiff fi fi fi ff fiff fffi ffff& 9ff ff !3ff * .fffi 11- fi fi fi fffiff fifi fi fi fiff fffiff ff fi fi fi 9fifffi& ff fififffi $ff )6 fi ffff fifi fffifi fffifi fifi ff ffff fi ffff fi fifi fffffififf fifffi fi fi fifffi fffi fiffH4 fffifi fi9 !; * 5 1$-fiff fifi fffffi fi fffiff fiffffff fiffff ! fi fi-fifffi $ff )6fffffffiff ff ff fiff> ? !ff fi ff fi- fi 4> ? ! 4 fi fi fi- . $, fi ffff fi4 fi $ff )6ff ffff !fffffffiff ff fffffffifffifffi fi fi fi fi fi 5(fffiff fffififffi !fifffi ffff-fi fi ff fi 5(fffifi fi fffi fififffi fffffi ff ffff fffi fiff !#-fi fi !1-fi fi ff ff fffffiKfiff 9ff fffi fi fiff fiffC ffff ff C D% fffiff fffi fi fi 4 fi!ff-ff fiff C ffffff C & fi fi fffi fiff fi 4 fi fififf fiff fi fififffifffffi ! (ff * K##% ) ff * + #1% 8 * 0fi fifi 1#-fffifffiff fiff fi ff ff ff fi fffiff ! ff fi - fi fi fffififffifi ff fffi;fffffi fi ff fi fi fffi fifi fi fififi fffiff fi ff fi ff fffifi ff ff fiff fiff fffi & ffff fffifi ffff fi ! fi fi fi fi fffiff fi ff fi fi fi -. 5(fffiff fi fi ff fi fi fffiffff fffffi fi fifififf fffi (fffi75(fffifi ffffff fifi ff ff fi fififffifi 9fi fi fi fffi 4fffifi fffi,fi fiffff fi5(fffifffffi ff fi fffifi ff fifi fiff fiffff (fffffi ff fi fifffi ff fi fi fffffi fifi 5(fffifi ff fi fffffifi fifi ffff fi fffffifffi fi fi fi fi fffffi fffiffff fi fffifffi fi fi fi fi9 fi 5(fffi!ff- fi4ff fi fiff ffff fi fi ff( fi fi fi fiff fi 9 fi fifffffiff ff fffi fi fififi 5(fffiff(fffi@ fffffi ff fi 5(fffifi 9fififfff fi ff ffff(fffi2ff fififf fi @ 5(fffifi ff fiff ff fffiff%;ff fi fffi fi fffiff fffffffi fffi fi fi fffi fi fi fi fi 5(fffififi L fffi & fi fifi fi fi! ! -- ffff fiff C ff fifffffi fi fffi L% fi fifi fi fi! ! -- ffff fiff C fi ff fi &fffi fi fiff ff ff fffi fi 5(fffifi fffffffi fi fiff fi L! ff ffff "ff L fffffifiLff #fiff ff ffff ffff ffffffff ff#& ffff fffi fi &(fffififf7 fffi fifi fiffffff fi fi ff fffi !- fifffi fi fifffiff fi fi fi !-L fi fi fiff!ff - L fi fiff fi!ff ff- . $,ffff fffi fiff ff ff fiff 3ff fififf fi 4fffi fi fi!ff fi "# fi ff fi ff fi fifi fi $fffi fi fi $ % ff fifffi fi & fi fffi fi fi' ( )"# fi * ( + fi,fi fi * - .$$/fi0,,fifi ff fffiff fi fi fi ff fiLevel 1Level 2Level 3Level 4()(0)(50)(0)(0)(50)mutex(50)[50](0)(120)[70](0)(0)()(120)(50)()(120)(120)()(220)(160)(0)LJ(0)%%()%(220)[100](220)(220)(160)[40](120)mutex(160)(50)%%%; ff #7 ( fi&(fffi/fi ff fifi fifffi K fffi fifffi fi fi fi!ff- fi fi ! fiff- & ff fiff fffiffff fffi fi >!M-? fi fi fffffiffffff fffi !ff >? fi ff ff - fi fi Cff fiff C &fffi fi fi fi ! -ff fi fi fi fi fffiff! 9 ff fi fffffi fi fififffffi fi ffff fi fi9 fi ff fi fifffi fi fifffiff L! - fffi % ff! -fffi fi fi fi fffffi fifffifffi fi fi fiff; ff # fi fifi &(fffifi ff fi ! %- fi fffifi ffff ff fi .ff fiff % %L ! fiff ff - fi L fi fi fiffff ! fiff ff fi % - &fffi fi fifi & fi 9ff @ff fi fi fi fi fiffff fi @ff fi! - fffi .! - fffi fi fi fiff Lfffffi fiff !@ff- fi ! - . fi $,.fifififififififi fiffff fiff fiffff!! - J! - fi fffi .ff %! ff ffff fffi fi %-! % - fi fiff! - fifffi fiffff ! ' -fffi % ;fi fi fi fiff % fi .! ! % - fi fi! - fi fi! % -" ffff" L!ff L ff ffLff ff fiffff ff L fiJ L fiJ+ fi &(fffifffffffi fiffff fifi ffff ff fffi &(fffi! fi&(fffifi fiff ffff fiff ff fffi ff fi fifffi fifi fffi- &fi ff fi fi fi fi ffff ff fffi&(fffififf fi fffi fiff fifffffi fi fffiff fi fi fifffiff fifffffiffffff ffNff fi>ff? fffi fifffifi fi &(fffifffffifi ffff fifffffi fi ff ffff fffi L;fffi fi fi ff ff @fi fifi ! >& ?>.& ? >6? fi >8 ff? fi >2fiff8 ff? fi$ff )6- fi fifffi fi &(fffi;ff fi fffffffi ! >.ff? fi >8 ff? fi $ff )6- fifffiff 5(fffi&fffffi #fffffi fi fffi fi fififffi fffiff fi fi fffi fi fifffi fffifi fi fi.fifffi fiff fffi ff9 9 >ff ?fffiff ffff fiff9 fiff fifi9 fi fififf ( fifi fffi fffi fiff fi fi ff fi $ff)67 fifffffiff 9 fffi fi fi ff fifi fffi !fffifffifffi ff fifi fi9 fifi-fi ff !fifffffifffifffi ff-&fi fi fffiff fi fi fi fiff fffi fiff fi fffi fifi ( fifffi ffff fi ff $ff )6 ff fffi9fffifffififififififififi& " fiff fifi fi1 )"# fi fffi fi fi1 "# fi fi ff ff2 3 - 4$$,/fifi ff fffiff fi fi fi ff fi&ffffff fi ff ffff fi fifffiff fffi !-9 fi fi fffiff fifi fffi fi fifi fifi ff fiff fi fifi fffi fi fi ff fi fi.$B ffA ff ff fififf $ff )6 fifffi fi fifffi fi fffiff fi 4 2fffiff ff ff fffi fi fifi fi fi fffi fiff fiFfi fi fifi fi fifi fi fi fi fi4fi fi5 fi fffi fffi ff fi ff fiffff ff fi fifffi 'fi ff9ff ff9 > ff? ;fffifi ff ff fiffff fi $ff)6ff ffffff ! " # ff " $ %fffi fifi fi 9 fi fififi & fi fi ff fi fififi ffff fi 4fi fifi ffff fi9 fi fi fi fifffi fifffi ;ff ff fi fi fi4fi fffiHfffi fi ff ff fifffiff &9 fi 4ff @ff fffffffffi fi fi ffff fi fi fifi 8 fi fifi fi fffffffi fi ff ff !@ffff- fifffi fifi fi fifffi fifi fffi fiff fiffffff fi " $ %& ff fifi % & ff ff&ff %ff& $ff)6 #$B' fi 4 fi fffi %fi" ff ff ff& '(& J '< , J 1<#1fffi ff fifi B 1<#1 J #$B'ffff ff ffff fiff + fiff fi fffffi fi fifffi fi fffi& fffifffi fi fffifi fi ffff fifffi fffifi ff fi ff fifi &(fffifffffi ff fiff fi ff ff fifi ff fi fffffi fi fi C fi fi fi fi fi ffff5 " fi fiff fi fi !fffi fi 6fi fi6 fi fi,0fi fiffff fifffi ! fifffffifffffi fiff ff -$ffff fi% &ff'ff3 fifi fffifi fiffff fiff ff fi fi (fffi! fififffifi- fi fffiff fi fffi! fi fifi- fffffi fifi fffi9fiff fffffifffifi &fi 9fi fi (fffifi fi fffi ff (fffiff fi fi !fi fffi -( ( fififfffff fi (fffifi fi fi fiff ff ff fi fiffff ffff (fffi& fffi ff fiff ff fi fffi!fi 9fi fi fiff-fi& 9fffi fi@fi fiff fffi fi (fffi&fi fi fifffffi fi (fffififf ff fi (fffi+ fi fffi fi fi (fffifffi fi ; fffi fifffffi fi fi fififf7fi(fffi! fifi fi fi fifi fifi -% fi fffi fffi (fffi% fi (fffiff fiff fi fiffff ff fi fi fffi%fi fi (fffifi ff fifi fiff & fififf fifffi@fifi fi fi fffififififf !3ff * .fffi 1- ffff ff fifi@fi fffifi fffi9fi fifffi; ffff fi fi@fifi fifffffifffi ff fi fiff fi fi fffi!3ff * .fffi # 1-fifi fi (fffifi fi fifffiffff (fffififf fi ffff ff! fi- fi ff fi fi fi fiff ff fi ff fi fifi fi fi fifffi fffi fi ff fi fffi 8fi fi fi fi fi ff fffi ! fi ffffffff fi ff - ff fifi fi fi fi ff fffi &fffi ff fi fi fi fi 9fififffiffff fi ! fi fi fififffifffffi )fi P * )fi #<% 3ff * . ff #'- fffiff fffi fffi fi fiff ffff & fi fffi fi$ff )6 fi fiffff . ,fffffififf fi fiff fffi3 fi fi fffifi fi ff ! -(fffifi ff fifi fffi9fi fi ff7 " fi fi 6 3 4 $$fi fffiff 2ff ff,1fifi ff fffiff fi fi fi ff fi!G$ 7 (fiff G fi ff fifffi ff fiff fffifffi fiff ! #-% 7 ( fffiffff fifi G ff %ff# #fi1 fi fi (fffiff fffi fffiG%fi$ #,fi fffiB'fi %<! - ff ff %ff ! - fi fi ff fi fi! ff ff fi fffifffi ###fi ! - fffi#1! -%#$ %ffff; ff 17 3fffi fffiff fi fffi fifi # & fi fi fi fffiff fi fffi fi fi fi fffi9fifffi ff ffff fi fffi( fifi fiff ff fiff fi fififf fi fi ff fi fi fi fifi(fffi!fiff fi- & fi fi (fffifi ff fiff fi ff fi fi fffiffff ffff fffi fi fffffi)fi fifi3ff fi .fffi !#-ffff fffi fffi ff fi fiff7fififffffi $ff )6 fi fiff fiff ., fiffff fi fi fi fiff fffffifi9fiff !. fi fi #,% 0fi @ * . fi #'-ff (fffifi ffffffff &ffffff (fffiffff 5ff ff fffi fiff fiffff 3 fi (fffifi fiff fi 9fi ff fi fffi fi 9fiffff fi ff (fffifi (fffi% ff8 !fi fi fifi fifffi 2 " fi3 - 4$$,2fi fiffff fiff fi fffi! - fffi fiff fi #(fffififf fi fi fifi fffifffi fiff fi fffi ff fiff!fiff-ffff (fffifi fifffiff fffi@ fi fiff fffifi ff9 fi ff !fi ff- ; ff 1 fi ff fi fffffiff3ff fi .fffi !11-ffff ff fi fi fiffff (fffififf fififfff ff ff 5(fffifi &(fffi& fifffi ff fffiff fi ff $ff )6()fi fffi *ffff& fiff ff ff fi fi 5(fffi5(fffifi fi ff ff fi fi fiff ff ff fiff ! fiff fffififfffff- ( fiff fi fi fi fifffi fi ff 4 ff ff fi!fi fi fffi fffifi fi - & ff fffi fi fiff fi fffiff fi. fi fi fi 5(fffiff fi fi fi !fi ff- ff fi fiff fffffi>? ! fi- 5(fffifi fi=fifi ffff ff fi fffi fi fi fi fifi ffffff fi fffffi+ fi fi fi fi fi5(fffifi fi ff fiff fffiff fi fiff fi !; ff . $, fi fi- ffff ff fifi ff ffff 5(fffifi fi ff fi fiffff . fiff fi ff fiffff fi +ff fiff fiff fififi fiff ff fifi ff& ff fiff fi fi fiff fi fffi fi ! ! - - ff ff fi fi ! ! - -fffi ff ff fi fi ff fififffffi fi fiff fi4 fiHff fi 7! - J!-E!-E!! - J!- J!-E!-E!& 9ff ff fi fffifi !-fi !- fi ff fi fffifififi9 . fi fi fi fi fifi.-fifi ff fffiff fi fi fi ff fiff fifffffi fi fffi!- &9 ff fiff ff fi@ fi ff fffifffi! ff . $'-fi ff ff fifffi fffi4 fffi fi fi fffi fi fi fi fifi fififfff fifi fi > ? fiff fi fi fi fi fi fffi fi fififf ff ff ff fi fiff fffi4 fi ff 9 fi fifffffi fififf fi fifi& fi fi ff fififf fiff fffifi fffi fffi fiff ffff &(fffi9ff ff fffifi fiff ff fi fifi ffff fiff 9 fffififf ff ffff.fiff fi fi fi fi fi ffff fiff fi fffi& ff ff fiff fffi fifi fffifi fifi fi fi ff fi !#-ffff fi !1-Qff ff fi 5(fffififffi ! fifffifi ffffffff- &fi fffi fi ff ff ffffff fi ff ff 4fi ;ff fiff!#- fiff!1- & fffififffffifffifi !fi ffff - fi7& fi fffffi fiff 9 fi fi fi fffffiff fi Qfiff fiff fffififfffff fi $'$" fi fifi# ffff fiff ff ffff&fffifi ff fi Qff $'$" 9 4fi fi ff fi fffififfffffff ff fi fffifi fi fi fffi fffffiff fiff fifi fi fiffff fi fifffifi& fi fi fi ffff fi ffff fi fffifi fi fi fi ff fi ff ffffff!#- fi !1- fiff fi fifffffiff ffff fi fffifi fffi! ff fi-ffff$ . fiff fifi /"# fifi fi # fi ff fi fi: fififi fi.fi fiffff fi+ fi " ff! -ff fi fiff fi ! fiff ff fiff fiff fi fi fffifi- N fi fi fififffifffffiff ! (ff * K ##% ) ff * + #1- " ff! - fiff fi 9 fi" ff! - J fi! - fi fiff %ff fi8 fi fiff ff fffffi!!! -ff! -; ff $ fi ff ff fiff ffff fffifi fififi fi! - fffi %! -ff % ! - !- 4%! -fi fi fiff ff fifffi fi fiff !ffff fiff ff -%! -fi fi ff fi ff ff fffi ff! - !! - fi fi ff- & fffffififf . $$3 fi fi fi fi fi fi $'$" fi fifififififf ( Jff7fi fifi ff fi fffifi fi ff $'$" % fifffi fi fififf fi fi fiff fi & 9ff ( fi! -! -( fi fi ff fi . $1$ fi fifi fi fi fi ff 7 9fffi fffifi ffff fifi ff fiff fiff ! " ff! -- &fi fffffffifi fi fi >ff ? fi fi fiff ff fi fffi! -ffff fi ff ff fiff fi " ff! -fi ffff fi fififfff ff! -fi fi fi ! -fi fi fi7 !- fi 4 % !- fifffiff fffifi ff $'$" % !- fffififfff ff fi ff fi fi fi fi ffff fi ff ffff fiffff $'$" !fi! - ff fiff -% !- ff fiffffff ! @ " ff! - fi-ff ff fi! - J! -Efi! -fifififf ff!"#$$$$%#ff#& fi#%#& fiff%#'$'##'( )))ffff( )#'%* +* #,fiff4 fi ffff )"* fifi 4 fi fffififf-)#fi fifi fi.fifi ff fffiff fi fi fi ff fifi !$7 ( fi fi ! - fi fi fiff ff fiff fiffff &(fffi!$'$" - fifi ! -%%7 ( fi fi fi fffi ff fi fi fi fi ff fffi fi fiff fi fi fi fi ff#! -%1%%$! -%,!- %BJ'fi fi%<! -%fi ! !-%ff ff !#! -! -E!-%##!-%#1! -%! -E!-%#$#,% + + fiff #%#ff%%* #,fi )%%-+ + fiff #& fi##$$* #,* #, fi )%-)%-( )'"fi#& fi-#$$-$ '#'+ + fiff #& fi!#$$* #, $ '!#& fi; ff $7 (ff fffi fffifi fi fi fiffff fi $'$"fififf fi ! -! -ff 9ff fi fi fi fi fifffi fi! - fi fi fffiff fi ffff'#'( )$ ')J ff fi ff ! - fi fi ff ! ! -8 fi fi 9 fifffiff fififf & fffi! - ffff ! - fi ! - fifffi fiff fiff fifffiff ff fi ffff fffifi ffffK ff !- fi !- ff 9fiff Kfiff !fi !- ff fifffi ff fi fifffi fifffi fi fffi fiff fi fi fifffi fi fi#)#$$"#( )"-"-(fi fifffi ;fiff fi fififi fi fififi ! ff fi fifi fi.fi fiffff fiffffff fififf fiff fi fiffff fi ff ffff fifffiff fi fi ff fi fi fi fiff + fifi fi ffff !- fffi! -fi +9 ff fifffffiffff fififf fi fifffi ff ff 6)N fi fififf !fi ffff fiff fififi fffi -.# , fi #$ fi fi fiff ff ff fi fi fi& ff ff 9 fi fi!fi- fi fi fi fiff fifffi ff fi $'$" !#-%! - fi fiff ! - ff ff fi ff fi fi fi 4fi fi ffff )"* !,-%!- fi fiff ff fffifi fi ff fi fi !#$-& ! - fiffM# ff fffifi fffi 6fiff fiff ff fi fi ff ff ! -fi fffifi ff $'$" !! - - ff fiJ fffi ff fi ! #1- ffff fiff fififffi ff fi fi fififfH fiff ff fi.fiff fi fi fi ffff &(fffifffi ; ff, ;ff fi fi fi fifi ; ff , fffifi fffffi fi !ffff fiffff - &fi ff fi fi $'$" @ff & fffifi fififf fi fffffi ; ff , .ff fi fiff ffffff fi fi% fffi fiff ffffff fi fi fi fiff ff fffi fiff% 9fi fffi ff fi fiff fffffffi fi fi fiff fi;ff ff fffi fi fffifi ff ! - fi" ff! -!fi ! ! -- fiJ!fi !! J-ff& ff fffi fi fiff fi!fi ! ! --ff ! - fi fi! - ff (ff ff +! -ff $'$" 9ff fi1ff ff . fi fiff fi fffiff .fi ffff fi fi ff !ff fi.,(fi%%fffi ))(%%fifffiff"#" + + fiff#fi + + fiff"$" + + fiff""%ff#fifi ff fffiff fi fi fi ff fi!fffiffUnsupportedprecondition5mutex9$7$$$&$$7$$",!./mutex,./01rrfffi$7$$$$9$2-.0; ff ,7 ( fifffi fi . fiff ffff fiff ffff fi % ffff%ffffff fi fi fi fiff ffff fi fiff% fffi fiff fi! -<- Ffi fi fi fi fiff ff fi fi fiff & ff fififffi $'$" Kfiff ffff ! % -fi% fi fi & fi fi % fiff $'$" fiff fi fi ! ff ff fi fiff ff fifi -Kfiffff fi fi fi fi & fi '& fi fi fiff ! - fi fi 4 % fi fi)"* ! fi fi fifffi fi ! ! -- & ffff fi $'$" . fi! & -fi J fi fi! '-fi J#! - & 6 !fi ! ! -- % &" ff! - ff (ff ff +6ff fi ff " ff! - fi !%fiff ( fi ) .ff&-fi fi ff fifi4fifi! fffi%(&..(ffff"+ + fifffiff(#fi" + + fiff+ + fiff#fi fiffff fififfff - fi " ff! ( -fififf ( fi fi ff fffi % & ("fffi , ff!+ ff fi fifffi fi ff ff fi ! ! $'$" - (fffffi fi9 fi ; ff , fifi#! - J 11 ( fffi fi fi ff ! - ff fffi fiff ! fi fi - fi% ! fi fi % - fi fiff % fi#fi ! ! %- $'$" -- B fi fi ! fi! - fi fiff ff ff Bfi fiff fi# fi ! ! - $'$" -! &- J #< fifi ! ! %- $'$" -- ff ff BM# ! - BE# ! fffi % - fi fi#$#<#2 ff ff fi fiff ffff %#< fi fi#$ fi ! ! -11 #<E<J 1,( fi 9fffiff fififf! & - $'$" %- fiff& & ff ff fi !& ff ff %#< fiff & fi$'$" ! - fi fi fi fifffi )"* ! % - ffff ! - J #Bfi! - J #< fi & #< E $ J 1 (#$fi ! ! -1, 1fifi% &1,""fffi""fffifi"fi"fiffff* #," + + fiff* #,"fffffifi" + + fiff* #,ff( ff ff fi fi fi fifffffi ! -fi ff fiff & ff fi fifffi fi fiff 9 fi ff fi fifi fifffi ff fi fi fi ffff &(fffiff ff! *ffff - 8 fi fffi fi fi fffi fi ff fi ff fiffff fffi&ff ! - fi fi fifffi ff fi fi fi fiff fififfff fi fffi&ff ! -fi fi fiff fiff fiffff ff ffff fi fffiff fifi&ff ! - fi fi fifi fiff fffiff fi fffi fi ! ! -- &ff ! - fi fifffifi&/fi 2 ff ff ff fi 6ff fi fi./fifi ff fffiff fi fi fi ff fi! $ 7 ( fi fi ffff &(fffi%7 (fiff ff fi fi fi fifffi fi! ! --%#1fi ! ! -%$! - fi L fiJ%,! -%B!-%'fi !!! - -%< ! - E! -$+ + fiff'" + + fiff* #,* #, fi* #,##$'''fi + + fiff#'fi #!! $ 7 ( fi fi ffff &(fffi%7 (fiff ff fi fi fi fifffi fi#! ! --%1fi !!-$+ + fiff'$. + + fiff'; ff B7 (ff ff fi fiff fifffi ffff !- fi ff fi ! - fi fifififf! - ff 9ff fifi 9 ! - fifi fi fifffi fififi 9 . $1#! -ff fiff ff ff#'''$$ !fi.ffff fi fiff ffff ffff fi fffiff ff fi 9 fi 7!J!!-!-J!! -! - J fi !! --fi E fi! -fi!J! !!-!- J! ! -! - J fi ! ! --fi E fi! -fiff fi fiff 9 ; ff B ff fffi 7 fi ! - fi fi fi fiff- . fiff ff ff fffi ff fi !.0fifi$#&$#&&fifi#$fi fiffff fifi fffifi fiff fiffff ff ff ff fi fi fiff fiffff & fffifi fififffi fi ff . $1#! -1(ff fifi $'$"fifi fffifi ! - ff fifffi ff $'$" .$M,fi fi fiff fifi fi fi ff fi fiff! - fi! - ! - .BM'fi fffifi ff " ff! - fifi fi fi 9ff fffififf fi fi fi fi fffi ff fiffffff !fffffifi 4- fiff! -ff fi fi fi fffi fffifi !ffff fi fi-. fiff fi fi fi fiff fi fffifffffififf fi 2ff fi fi ff . $#ff ffff ff fi fi fiffff 2 fi fi fi fififi fiff ff ff fi>4?fffffiffff fffiff fifi fi; ff , (. $11fiff fi1 % &1,!fiff fi ff ff fi ! ! -- ($fi 1$ ! fifffi fi fi fi&(fffififf 1$- .,1$ 1,fifi !$'$"% &- fi' ff ff % & (ff fifffi fi fi ff ff fiff fifi4 fi & fffi $% & (1, E $#+ffff), fffi ff ff& ffff fffi fi fiff fffifi ff fi fi ff fi ffff fi fi fi ff $'$" !! -- fi fiff ff fififfff! - ff J # fi fi fifi ff fi ff ff fi ff fi fififf ff fiff fiff ;ff #! - fiff fiff fifi fiff ffff &(fffi!fiff - . ff fiff fi fi fi fi fi fffffi fifi! - fi; ff ' ff fi ff ff fiff ff! #- ff fi fi fffi4 fi fi.1$ff'ff$'.'" + + fiffff* #,ff+fifi ff fffiff fi fi fi ff fiff fi ff ff! $7 & fi fififf ff fffi ! - fi fi fffifffiff !-%%7 ( fi ff fi !- fi fiff!- ff ff fi fi fi ff# ff fi 34ff &%ffffff431ff! #- %! #- %! #- %$,! #- #%B%% %'J<%J ff fi ! -fi fi %#fi ! ff!! --%##! #-%#1ff ff ! ! #- ! E! --#$ffff! #- E! -%#,#Bffff! #- ! E #-#'! #- E #%#<! #- %#!- %#%++fi++fi#-+ ---+ ##- -# "-#+ "* #, fifi#$$-fi!fi--#$$#--##!-fi ! ff! $7 ( fi fi fi fiff %%7 ( fi ff fi ff ff fi fi fiff !)"*-#%1%$J,fi %B! #-%'%<!! -%!fifi-+ %+%%+#& fi%%+%)%# )#& fi%%#& fi"+#$$#& fi; ff '7 (ff ffff ff fi fi fffifi fifi.2fi fiffff fifififi 4ff ff & fi fiff ff !ff-! - fiff fi fi ffHff fi%ff fi # ! # fififf fi! -- fi! #-ff fi ff ff ff ff ff fi fififfff fi fffifi ff !! #-- fi! #- fi fififffi fi ! ! -- fiff fi ffff fifi! - 9 fi fi . 11 & fi fi ff fi fffifi fiff fiff fi fiffff9 fi fi fi ff fiff 8 fi! #-fi fi fiff fi !ff ff ff - ffff&(fffi:ff fffi fi fiff fffffifi ff fi fiffff fi fifffffi fi fiff ff ( ff fi fffiff fi ff$+fi+fififififffffi;ff fiff 9ff ffff fi ff ff fffifi#M,! #- ff fi # ff !fi fififf fi@fffifi - &BM# fffi ff fi fi fifffffifi ff fiff J fi ff fi fi fffffffiffff fi fi fififf fifffi ffff & fififi fi fi@fifi !B- fi ff fiff fi fi fifi !#- &fffi!M#- fifi fffffffi fi#fifffifffi . fi fffifi ff fi 9ff fi fifffi + fi fi ! fi fffffi fiff fifi - fifffifi ff fi ff 4 fiff fffi ;ff fi ff fi ff ff fi ! ff ff fi ! ff!#- &fi! #- ff fi 4 !#1 #BM#'- fifi fi fi! #-ff fi ff E # fi ffff fi! #- E # fi fi fifi ff ff&fi fffffi fi ff !! #-- !#<-;ff fi fi fi fi fi! #-!$- fi !ffff ff fi fififfff fiff fffi+-+-+--##------##-"++###'fffifi 0 < fi fifi fi& fi fifffi fffffiff fifffifi 1 = > fi ff fi fi fifffifi fi fi fififffi! fi fi fi fi/-fifi ff fffiff fi fi fi ff fififf ! - fi & ff ff fi fffi fi !)"*- fi fi fiff fi fifffi!- ( fi fffi ff fifffi fi fi ff fi ff 4 fififffi !<- &ff fi fi ! fffifffi fi fffffifi ff! #-fi fi fiff! #- .$ fffi ff ff fi@ ff fi fi fi fi & fi fffifi fi fi fffiffff ff fi fi fiffff fifi fi fi ff ffff fiff !##- ;ff fi 4 fi fi ff ! fi- ff fi fi fifffi fi ff fifffi#$M#,! #- ff fi ! fi fi fi ffff fffififi ff -&ff fi ff fffi ff fifi fiff H fi ff fffi .#fiff !fifi- ff fi fi fi fifi@ fi fi fffifi !ff!fifi- fiff fi ff ff!fifi - 2ff fiff fi ff fi ff fi ! fffffi ff ff ff fiff fi fifi ! fi ff fffi fififfffff fifi- ;fi ff fi ffff fififf fi ff ff fifi fffiffff fi fi4ffff fffffi fi fffi ffff; ff < fffi fiff fi fi.fi fi fifi fiff ) fi fi fi fiff ( ff fffiffffffff fiff fififf & 9ff fi fififf fififf fi fi ffff fiff fi&fiff @ff fi fi ! fffiff ff @ff fffi fffifffi fffififf fi ff fi 4 fififf fiff ff 4 fififi. fi fi ! - fififf !fi- fi#, fi #' ff .fi fi#,! - # ! fffi - fi#'! - # ! @ff- ffff! #-#< & 4fi fiff fi fiff(ff ff fi fi fifi fffiff fifi&fi fi fiff fifi % & '6ff fifi % + fifi fi# 1 fi fi ! ff! ! % -- )"*! fi ff! #- J! #- J fi fifffi fiff - &! - ! fifffi fifi fiff % $fffi %- fi! - $ &4 fi & fi ' fiff fi fi fiff fi 2ff ff! &- 9ff $ fi & fi ff 1fi/%%+%#%+%+fi-fi+///+-++fifi#---#-#+ "+#+fi#fi fiffff fi' ff.06fififififififififi5 ff..0.111,-.0(2)(7).ff fi-2.(2)(1)(1)/(2)-(3)(1)(1),(1)(3)(0)-,1(0)1./01; ff <7 ( fifffi ff fi ff ff & fffifffifffi J (& fffi fiffffffff fi000fi ' (fi! &- 9ff #1 fi ff! #- 9ff & fi '6ffff fi fifi fi ( fi ! fffi! ( -# ff ff ' fi )"* fiff % & '.## ff fi ff ff! %- J #1 fifi ff 4 (fi 'E##1E1fi# &"fififffi ff ffIff ff fi fffi fi fi !ff fi fi- ff fi fffi fi fifffififf!: * 34ff1#- !24 fi * 8 1#- fi !/ * 0fi fifi 11- +fiff ff fi ff ff fifi fiff fi ff fffifi fififf ff fi !fi - & fffifi fifffi fi fi fiff fffi fifffififf fi 9fi 4ff fi/fifi ff fffiff fi fi fi ff fi: * 34fffffi ff fffi!fiff- fi fi fi fi fifi ff fi fi ( 2fi fi 34ff !1-fi fiff fiff fifi fi fffiff ff4 fiff ff fffffi fi fi fi fififf fiff fi fi fi ! fi fi -fi ff fi fi 4 ff : * 34fffifffi( 4ff fffiffff ff fiff ff: * 34ff fffifffffifi fffi fffffifi fffi fifi fffffifi fi ff ff fi!fffifi fi fi fifffffi ffff-& ffff fi ff ff fffi fi fiff fi ff fifffifi : fi fi#< fi # ff fiff ff fi fi ff fi fiff fi fi fi fffi fffifffifi 2fffifffi fffifi ff fi fi !ff-fi ff fiff(fffffi 4ff ff ff fi ! fffi# ff fi fffi fiff fi fffi fi ffff ff fffi fffi fffifi ff fi fffi ff & fi fi fi ff fi fifffi ' fifi fi fi fifffi fi fi;fi fiff 4ff ff fi fi fffiffff+ ff !- fi fiff fi fiff : *34ff fffiffff fffi fi & ffffff fi fi fiff fifi ff fi fffi( ff 24 fi !1#- fffifi fiff fiff fffi fififf ff fffifi ff fi fiff (ff 4ff ffff fiff fffifi + fi fi fi fffi fifffifi ff ffff fi fffi fffifififf fi4ff fffi fffifi ff fi fifi fififf fififf ff fi ff ff fifffifi !fiff fiff fi ! ffff fififf fiffff fifi fi fi fifffiffff fi fi ff ffff fi - (ff 9fi4ff fi fffifi ff fi ff fifffiff ff fi ff fi fiff ( fi fififi fiff !fiff ff fifi fiffff- fifffi fffifi fiff#%%(5 . fi ff $ ff fi + fi ,fi fifi ff 1 fifi ff/fi fiffff fifi fi fi fi fi fifffifi ( fi=ff fi ffff fifffffi fiff fi fifffiff fi fi fifi fi fifi 9fffi ff fifi ff fi ff fi ff ffff 6)N ! ff fiff ff . $'--fiff.fi#fffffi ff /ffff fffi ff fiff fi ffff fffiffff &(fffififi fi fi fifffffi fififi fi fi fi ff fifffiff fi fi fiffff fiff fiff fi fiL ffff ff fi fi fi!! -fi L ff !!! -- fi Lfiffff ff fi ffff fffi ff ff L& fiHff fi fi fi fi ff fiff ! -fffi fi fi fi fi fi fi fi !ff ff ff-ff ffff fffi L Ffi fiff ff fffffi fi fiffff fifffifffffifi fiffff 4 fifi fi !fffffiff fi 4 - fi fiff fffi L fiff fifffffffi ff 4fi fiff fffffi ff ! - fi fifffffi fi fi !fi-ff fi ! - fifffiff Lfffi & fi 4fiff ff fiff fiff fiff fffffi fi ff fi fi fi ff fiff! -! - ;ff fifi ffffffff ( % &(fffi; ff # ff fi & fi, ! ; ff - & fi fffi ## fiff ) .! )- J#1! ( - 1$fffifi % fi 4! % -1< ! - ff 11 ! ! -- ! - ff 1< ! ! % --! ) - ff fi #1 ! ! --.fffiff fi ff $ff )6 fi !ff-> ? ff > ? fi 4> ? !; * 5 1$-fffi fi ff fi fi fi 4 fi fiff ff fifi ff 9fi fi. 11 ff fiffH4 +fi fi fi fiff( 9! -!! - fi! - + 9!fffiff fffi fifffffffififififififififififififififi!fififi7 fi fffifi fififi2/,fifi ff fffiff fi fi fi ff fiLevel 1Level 2(0)(50)(50)[50](0)(50)(0)(120)[70](0)()(0)()(0)(0)(270)[40](230)(120)(120)(120)(220)(220)(220)(220)[100]()(50)(220)Level 5(120)(120)mutex(50)(230)[110](0)()(270)mutexLevel 4(50)Level 3()(220)(220)LJ%%%%& &%%%%; ff 7 Nfi &(fffi; ff # fiff fi fi & fi,ffff ( % /fi ff fifi fiff fi K fffi fifffi fifi fi !ff- fi fi ! fiff- &ff fiff fffi ffff fi fffi >!M-? fi fifffffifffi fi fi fi 4fi! -fi! - fi ff !#-! - ff fi fifffi4!1!! - ff fififf fi 4fi !$- ! !! fiff fi fiff -+ff4ff ff fi 44ff fffiffff fi9fi fi fi fififffi fffi) & ff fififf $ff )6 fifffifi fififf fi fi fffi fififi fffffffi fi fi fi fiff ff + fififi fi ffff fi fffffi fi fffifififi!fi!8 !fififi fififi fi fi fiff fi? fifffi fi fififi ff/.fi fiffff fififf fifi 2ffff $ff )6fffifi fffiff fifi4fffififi 9fi K fi fffi fififfffff fi& fifffi ffff fffi 4fffi fifffifi Fff fi ff .& fifffi)ff fi fi ff fffifi fiff fi #Rff ! ff fifi- fiff fffffffi ff fffi fififffi ff fififffi ( fi fffffi ff fi fififf fiff fffiff !3ff .fi * .fffi 1$-! (ff ff /ffff)ffA ff fiff fi 4fffi fi + fiff fi ff fffffiff fi4 fifi fffffi fiff ff fiff fiffff fi fifi fi ff fifi fi fffi fifffi fififf! - ! - ff ! - fi ff fi !fi- fi ! - Jfifffi ff ffff fi fffi fifffi( fffiff fi fiffff ff fifffi fifffi ff ( fffiff fi ffff fififf fffiff fi ff Jfi fffififffiff ( fffi4 fi ffff ff fi fifffi ff 7J EJ J J Jfififffiff ! fi 6 fi- fi ff fi fffiffffff fi fffi fi fi &(fffififf ffffff fi fffi fifffi ;ff fiffff fi fffifi fi fffi fifffi ff ff fi fffi fiffff fi ff fi & fffffi fi fi! - & fi fiff ff fifi fi fifffiffff fi fi ffff ffff& fi fffi fi fi fi!- fifffffi ff fi fffffffi fifffi fi fififf ff fffi . fiff fi fifi fi fi! -- fi fifffi fi fiff ff !fi fi 9 fi fffi fi J!! - fffifi fi fi fiff fi( fffifffi fi fi fi fi fffi0 0 01ff121$ff$ff9 /fi ff ff fi fi! fifi fifi ff fi fi ff fi 4/"# fifi : ? fiff )"# fi ff fifi//fifi ff fffiff fi fi fi ff fiFff fi fi fiHff Hff fi fiHfffffi fffi 4 fi fi fi fifi fffi fifi & fi fifffffifi fffi/ fffffifi fffiff fiff ffff ffff fi fi fffi fi fi4 fffi fifi fifi fffi fi& fi fiffff fifi fiff fffiffJfi fi 9 fi fiff fi fffififf ffff fi fi fi fi ffffff>fi? fifi fiff !ff -ffff fi fi fi fi ff ! fffi fiffff fi fiff fi fiff- + fiff ffff fi fffffi fi fi fiff fi fi fffiff+ ffA fffffifi fiff fffi fi & fi ff fi fifffiff fi fffi . ffff ff ff fiff ff ff fffiff fffi fifi2 fi ! ff- fiff fifi ff fi fffiff 9! - !. $1#-! - fffi # fi fifi fffiff fifi # !I ff fi ff fifi ff fi% fiff ffff ff fi fffiff ffff fi ff ff ff fffifi fffiff(ff 4ff 9! - fi fi fffifffi ff fiff ff ff fi fifffi fififf ff& fffifififf fi fffi 4 fiff ff fffi fi ! fffffi- fi fi ff fi fi fi fifi ff fffi fi + fiff ff fffi fi fi $'$" J!! - fi ff fi fffi fifffi fi fifffifi ff ff $'$" ff H fifi fi fifffi fi fi fi fifffi fffifi &fi fiff fi fffiHfffi ff fi fi fi fffifi .9fi 9fffi fifi fi fiff! - fi 4 fi fi fffifi fffifi@fi fi fifffi fi fi fffi% fffifi fffi/ ff ff fi fffififf fi fffiff Jff fi fifffi fi fi fifi fi fi)( )( ))))ff$ff$ . fi fi /fifi !fi ; $$fi fi ff fi fi$ fi $fi ff/0fi fiffff fififf ff fi fffi fifffi ! J-ff fi fi H fi fi fifffifi ! fi fi fi fi- . fiffff fiff fffififffiff" 01#ff ff ff 2ff,( fi ff fifffi fi 4fffi fi fffffi fffi fi fi fffi & fi fifi fi9 . $1 fiff fffifffififffi fi fi ff fi@ fffiff .9fi ff fi fi ff fifi ! fi fi ! - ff ff fi fi fifi -7!-J! -E! -E #!ff fi fiff fi fi fffifffififffi ff&ff fi fi ff ff fifi fifi ff ffff 9fi ff ff fi@fiff & fiff #fi #fiff ff fi@ fffi fi fi ff fi # & fi9 fiEff! - fi fi 9ff !- ff ff fi &(fffiffff fffffi fffi%9 fi fi fiff fififfHff fi fi fi ff fffi & fffffifffi 9ff@fi ff fffffi fifi fi fffi fiff fifffi fi fifi ! fi ffff fi!-E! -ff E! - J *E!+ ff fi@fi 9ff ff ff fifi ff ff & fiff fiff fififi fi ff fi fi fi fifffffffi ff fiff fffiff fi@ fi fififi fffffifffifi fi fifffiff fiff fi fifi ff fifi fiffff ff fi & 9fffi fffi fi@ fififf ff fifi ff fi fi & fiff fi ff fiff fifi fi fiff fifi fifififf !fifi fi ff fi 9 fi fi ff- +fiff fi fiff fiff ff &(fffifffffffi fi ff &(fffifi@ fiff . fiff fffiff fffi fiff ff ffff &(fffifi fifififffiff fiff fffi &/1333fi3223344303fififi ff fffiff fi fi fi ff fifi fi fi fi fiff ff ff fi fffiff !#-fiff ffff fi !1- fi fiffff fi fi & fiff fi fi fififffi ff fi ffff fiffff fi ff fffffffi fi fi fffifi fifi$ff )6 ff fiff fiff 9ff fifi fffi 9 6)N & 9ff fifi fffiff fi % fi fi fi9ff fi fififf fi fi ff ffff 6)N fi 9ff & ff fi fififffi fiff .fiff ffff fffiff ff fi ffff fifi ff fi fi fi ff ff ff fi 6)Nfiff fiff fi fi fi fi !#-9ff ff ff 6)N fi fi fffiff fi fiff fi fffiff fi !1- fififfff fi fi fffiff ff ff ff 6)N 9 fiff fi ff fi fi fffiffff 6)N''33'33( ff fiff& ff 6 fi fifififf *ff*ff(*ffffff fiff fffiff $ff )6 &ff fffi fi fi fifffi fi 4fffi ff & fifffi fiff fi >.ff? >.& ? >& ? >6?>8 ff? fi >2fiff8 ff? fi fiff fi fi fffiff ;ff fi fffi fi fffi fifffi fffiff fi fi $ff)6 !'''***+* * ffff *-( ff fi fifi ( / () #E !#B 2@- # 3 K( & ff ff fffffifi ff 9 ff ff fiff ff& 6)N ff fi ff fi Bfiff ff fi fi ff 8 fi ff fiff fffiff fi fi fi fi ffff ff fiff fi ff ff fi ff fi fi fifififi 2ff fffi ff fiff ff fifffi fi 2 fi @A fi fffi fi < ff fifi fi ffff fi fi fifi /"# fi<fi fi A@%# ff fffifi fi fi ff <fi fi A@%# ff fififf fi ff fi/fi fi 5 fi ''/2fi fiffff fiff fifi ff5)3,,1,',R;;1$<1,$R.fiff ##11<BR.fifi#11''R).$$#B'BR"2)I) #1111,B,R.fiB#1,R&),1'1,#$R&).S.#,#1#1R. .###,,R&fi #7 8 ffff fifififf fififf$ff )6 ffff ff fffi & fifi fffifffifffiff ff fi $ff )6 & fifi ffff 1ff )ff 2fiff8 ff fiff fiffff fffiffff fffifffiff )ff 6fi fi fffiff fi fffiffff fffiff fifi fi 9 ff fiffIfffi ffff fifffiff fi ,'!ff fi fi Bff - fi fffi fi ,,R !ff fiff ,1 fi fffi <R- ; ff # fififf ff fi fififf fififf& fffiff fifififf& ff fifffi fi fifffififf fi fi fifi fi fiff 4 &fi fi 9ff fiff!24 fi * 8 1#-& fi ff 9ff fiff fi fi fiff ,- & ,ff fi ff fifffiff fiff 1ff ) 8 fffi 1ff )ff 2fiff8 ff & 9ff fi fifffifffffi fi9 4 fiff fi ffff ff&fi ffff fi ff ff fi @ fifi fffi fffi fifffi ffff fi ff fifi ! - fifffi ff fiff fiffff fiff ff ff fi fififffi fffi @ff fi +fi fi ff fiff ffB ff fi fi 6 /fi fffi $ff * .ff fi 1fifi fi 6 /fi # fi fi ff fifi $ ff" fffi0-fifi ff fffiff fi fi fi ff fi+ fffi fi fi ff ffff fi! fiff fifffi fffiff ff fi ff fffi fififf- fi fi 9 ff & fi fi fi# 8 fi fi fi fi fi fi fifi fffiHfffififf ff fifffifffi ff fififffi ff fi fi fifi fffi fifffi fi9fi fi B fifffi fi fi fi ff&fifffi ff fi fi fi fi ff fi fifi!fiff-fi ff9ff ff fi@fififf fiff fi# fi ff fifffifffi ff ;ff fi fifi ff fi. 1 ff , fi ff fiff fi,fi ff fi9 fi B fi&ffff fi fi ff 6)N ff ff 9 fi!- fi fifi! fi- fi 96)N; ff # ## fi #1 fi fifffi !9 ff-% fiff 6)N fi!fiff fi-fffi fi fi fifi fffi fi fffi ffff ffffff9fi 8 fi fffi fi fi ff fffffi fiff; ffffff fififf fffffifffi ff fi% fiff. .fffifffi fififfffff fi fifi ff .&ffff ffff ff ffff fi6)N ! fffiff fi ffff fi fiff- )ff 6ffff fi fffi ff fiffff;fi 8 ff fiffff fiff fffiff fi fiffffffff &ffffff fi fi ff fffi fifffi fiff ; ff # & ff fifffiff fi fifi fiff ff ff fi ff fi fffiff & ff 4ff fiff )ff 6ff fiff ff fi ff fi ffffffff ff fffi ff fiffff fi ff fifffifffi ff fi fififffiffff fffiff + fi ff fi fffffifi >.ff)fiff? ! - 6fiffffff fffiff fi .ff)fiff fi fffi fi fi fiffff fffi ff fffififf fi ff ff fiffff ff3333333fiff fi fi fi 1 fi fifi fi fi fffifi fi ff' fi ffff fffi0fi fiffff fiDriverLog-StripsMillisecondsLPG-speed (20 solved)FF (Speed) (15 solved)MIPS (15 solved)MIPS (Plan) (15 solved)SemSyn (1 solved)Simplanner (11 solved)Stella (10 solved)VHPOP (14 solved)1e+06100000ZenoTravel-SimpleTimeMilliseconds1e+08LPG-speed (19 solved)IxTeT (8 solved)MIPS (14 solved)MIPS (Plan) (16 solved)TP4 (5 solved)TPSYS (2 solved)VHPOP (13 solved)1e+071e+06100000100001000010001000100100101002468101214161820Satellite-ComplexMilliseconds1e+07246810121416182014161820Rovers-NumericMillisecondsLPG-speed (20 solved)MIPS (8 solved)MIPS (Plan) (10 solved)Sapa (16 solved)TP4 (3 solved)1e+060LPG-speed (17 solved)FF (Speed) (9 solved)MIPS (8 solved)MIPS (Plan) (8 solved)1e+06100000100000100001000010001000100100101002468101214161820024681012; ff 7 6)N fi ffff fi fififf$ff )6 ff fi fiff. .ff.& )ff6fi 8 fffifffi ff fi fffififf fi fffiffffff fi&; ff ## fi #1ff ff )ff fiff fffifffffffiff fifffffi fi 6fifffi &6)N fffi fi ffffff .ff)fiff7 fi ff ff fiff ff fififf ff fi ff fi fififf fi fi ff fffiff fiff fifi ! ff fi fi fi fififf ff fiff 4ff fffiff fiff fi0fifi ff fffiff fi fi fi ff fiDriverLog-StripsNumber steps1000LPG-quality (20 solved)FF (Quality) (15 solved)MIPS (15 solved)MIPS (Plan) (15 solved)SemSyn (1 solved)Simplanner (11 solved)Stella (10 solved)VHPOP (14 solved)ZenoTravel-SimpleTimeQuality4500LPG-quality (19 solved)IxTeT (8 solved)MIPS (14 solved)MIPS (Plan) (16 solved)TP4 (5 solved)TPSYS (2 solved)VHPOP (13 solved)400035003000100250020001500100010500002468101214161820Satellite-ComplexQuality7004681012141618201820Rovers-NumericQuality9LPG-quality (20 solved)MIPS (8 solved)MIPS (Plan) (10 solved)Sapa (16 solved)TP4 (3 solved)60020LPG-quality (17 solved)FF (Speed) (9 solved)MIPS (8 solved)MIPS (Plan) (8 solved)8750064005300432002100100024681012141618200246810121416; ff #7 fififi fififf $ff )6 fffi fiff. .ff.& )ff 6fi & fi 8 ff ffffff fffififffiff. )ff fiff fiff fiff - &fffi fi ff ff fi.ff)fiff& ff fififffififffffi fififffiff ff ffff fi fiff fi.ff)fiff .fffifffi .ff)fiff fiff ff fifffffi ff ff fiff 8 ff fifffi .ff)fifffiff fffiffff ff fi Kfiff fi fififffi)ff .fffffiffffff ff fi .ff)fiff.fffifffi fififf fi fiff fifi fi fifi fffi .ff)fiff6ff fifi 6)Nff ff fi fi fi ff . $'fffi fi0fi fiffff fiSatellite-StripsMilliseconds1e+06Satellite-StripsNumber stepsLPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)1001000008010000601000401002010002468101214161820Satellite-SimpleTimeMilliseconds246810121416182012141618201214161820Satellite-SimpleTimeQualityLPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (19 solved)SuperPlanner (Quality) (19 solved)1e+060LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (19 solved)SuperPlanner (Quality) (19 solved)2001000001501000010010005010001002468101214161820Satellite-TimeMilliseconds1e+07246810Satellite-TimeQuality700LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)1e+060LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)600500100000400100003001000200100100100024681012141618200246810; ff ##7 )ffff fi!- fi fi !ff-fiff.ff)fiff !fi fi ff- )ff .ff.& fi &0,fifi ff fffiff fi fi fi ff fiSatellite-ComplexMilliseconds1e+07LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (17 solved)SuperPlanner (Quality) (17 solved)1e+06Satellite-ComplexQuality700LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (17 solved)SuperPlanner (Quality) (17 solved)60050010000040010000300100020010010010002468101214161820Satellite-NumericMilliseconds2468101214161820Satellite-NumericQualityLPG-speed (12 solved)LPG-quality (12 solved)SuperPlanner (Speed) (14 solved)SuperPlanner (Quality) (14 solved)1e+060LPG-speed (12 solved)LPG-quality (12 solved)SuperPlanner (Speed) (14 solved)SuperPlanner (Quality) (14 solved)800700600100000500100004003001000200100100010024681012141618024681012141618; ff #17 )ffff fi!- fi fi !ff-fiff.ff)fiff !fi fi ff- )ff 6fi8 ffff fifi ff fi fi ff fiff fiffffff fi fffi fi ffff fffifi ff fi fi fi 6)N ff ff fi ff fi6)N ff ff& fifffifffi fiff!ff 6)N ff fi- fifi fi ffff.ff)fiff !ff 6)N ff fi ff .ff)fiff-3 fi fi ff ff fi fffi4fi fifi& ff 6)Nfiff fi ff ff fifffi fi fffi4ff fi ff9ff fi fi fifi ff0.fi fiffff fiSatellite-SimpleTime-pfile15Quality180160Satellite-Time-pfile6QualityLPG (1st run, 8 solutions found)LPG (2nd run, 9 solutions found)LPG (3rd run, 12 solutions found)LPG (4th run, 4 solutions found)LPG (5th run, 6 solutions found)SuperPlanner (1 solutions found)LPG (1st run, 11 solutions found)LPG (2nd run, 10 solutions found)LPG (3rd run, 10 solutions found)LPG (4th run, 11 solutions found)LPG (5th run, 11 solutions found)SuperPlanner (2 solutions found)2501402001201501008010060401001000100001000001e+0610CPU TimeQuality100LPG (1st run, 7 solutions found)LPG (2nd run, 4 solutions found)LPG (3rd run, 5 solutions found)LPG (4th run, 6 solutions found)LPG (5th run, 5 solutions found)SuperPlanner (3 solutions found)361000100001000001e+06CPU TimeSatellite-Strips-pfile9Number steps38100Satellite-Numeric-pfile3LPG (1st run, 4 solutions found)LPG (2nd run, 3 solutions found)LPG (3rd run, 3 solutions found)LPG (4th run, 4 solutions found)LPG (5th run, 2 solutions found)SuperPlanner (3 solutions found)90803470603250304028302620101001000CPU Time10000100000101001000CPU Time; ff #$7 )fi fi fi ffff6)N !fiff fi- ff!9 ff - fi .ff)fiff ff ffff)ff .ff.& & fi 8 fffi fi ff fi fffi fi fffi fi ff fifi fi fi ff fi ff fiff fifi fffi.ff)fiff fi ff ff ff ff 6)N fi .ff)fiff; ff #$ff ff fi !fi fi fifi fi ff fifffi fffifffiff- &9 ff6)N fi fi fifi fffi !9 ff - fi .ff)fiff ffff )ff fi )ff)ff ff %ff&$ fi)ffff %ff/ !9ff; ff #$- 9ff !ff ff 6)N fi 9ff .ff)fiff fffi fififf ff fi fiff .ff)fiff ! fi ffff; ff ##0/fifi ff fffiff fi fi fi ff fifi fiff ff ff fi fi ff 9 ff - 2ff ; ff#$ fi fffffffi fifi ff fifi fi fi ff fi .ff)fiff fi fiff ff 6)N ffff ff fi ff; ff #$ fi)ff)ff %ff0 fi )ffff %ff1 .ff)fiff fifffi9 ff fi fi ff fi.ff)fiff 6)N fi .ff)fiff fi fi. ff fififffffifi fffifffi .ff)fiff & fifffi fifi & fi fffiff fiff (: (fifi fiff fi .ff)fiff fi fifi fi fiffff ffffff fffiffff fi .ff)fiff&ff fi fifffiff $ff )6 fifffffffi fi !Ffi11- &fffiffB#R .ff)fiff <<BR &fffifffffiff fiff #,Rfffi ff #$<RKfiff fi fffi fi fififffffiff fiff fifi fffi .ff)fiff9fi 4ff ff fiff .ff)fiffffff ff fi )ff ff fffiff fififfff ff Ifffi& fifffi fi fifffiff fffiffff fi ffHff fi fiff fi fifffifffiffHff+ fi fi fifi@ffff fi ff.ff)fiff fffi ff fi fiff fi(6 fi / fiff ff &( ff &ff .&ff ffff fi.ff)fiff fifffifffi fiffffff fi .ff)fiff fiff ff fi fffffffi ff &fifffi 8 ff fi .ffff fifffifi.ff)fiff & fi fffiffff fifi 2ff fi fi fifffi ff fi .ff)fiffff fi.ffffIfffi ff fiff fiffff ffHff fi.ff)fiff BBH$#Rff fiffff ffHff<#H##'Rff;fi fffi fffiff fiffff fi fffififf $ff )6ff fi fi )6 )B 2@ # 3 K( ff fi ff fi fiff fififf ffff ff fi fififf &ff fi fi fififf fiff fffifffi; ff #,fiffffff fi fifififf fffffi fifffi $ ,ff& /fi fi ) ! $$fi @A00fi fiffff fiRovers-SimpleTime-HandCodedMilliseconds1e+07LPG-speed (20 solved)LPG-quality (20 solved)SHOP2 (20 solved)TALPlanner (20 solved)TLPlan (20 solved)1e+06Rovers-SimpleTime-HandCodedQuality450LPG-speed (20 solved)LPG-quality (20 solved)SHOP2 (20 solved)TALPlanner (20 solved)TLPlan (20 solved)400350100000300100002502001000150100100105002468101214161820Rovers-Time-HandCodedMilliseconds1e+07246810121416182014161820Rovers-Time-HandCodedQualityLPG-speed (18 solved)LPG-quality (18 solved)SHOP2 (20 solved)TALPlanner (20 solved)TLPlan (20 solved)1e+060LPG-speed (18 solved)LPG-quality (18 solved)SHOP2 (20 solved)TALPlanner (20 solved)TLPlan (20 solved)80070060010000050040010000300100020010010002468101214161820024681012; ff #,7 )ffff fifffi fi ff fififffi $ff )6 fi fi fi fi ff fiff fi fi fffifffifffi fi ff fi fffifi fi fiff fifffi fifififffi )ff ff2- ff fi fi fi fffifififfffff ff fi!8fi ( fi 0 ffff + * Sfi fi 1$- ff2-fiffffff fi ff fi fiff fffffffiff fi ff fi9fi fifffi01fifi ff fffiff fi fi fi ff fi!fffffi " #ff$+ fiff fffi fi fi fifffi ff fi !fi -fiffff fffffi fififi fi fififf ff >ffff fi 9ff ffff? fi $ff fffifi )fi 6fi fififf fi fffffiffffffffff fi ffIff fffi fi fiffff ffff7 ffff fiff ff fi fi fi fffi fi fi fiff % 4ff fffifi fi fi fiff% 5fifffiff fi fi fi!3ff * .fffi 11 1$-+ fi fifffi ff fi fiffffff ff&fiff fiff fi ff fiff fffffififf fi fi fi fffiff fi fi !fi ff fffififf24 fi !1$-- fi ff fi fifffffi ff fi fffifi fi >fi ? !3ff * .fffi #-fi fffffffi9fi ffffff !3ff * .fffi 11- &fifffi ffffff fifi fiff (ffffff fiff fi fi ff fifi fi + fiff fi fiff ff fifi ff fiff ffff fifffi fffi ffff ffff fiff & fiff fifffi fffi fifffi ffffff fiff;fi ff ff fffffffifi ff fffifi fffffffi fffffi fiff fi fffifffi fi fi fffifffi fffi fifffifffi fi fiff fi fi fi ( fffi ( fffi!( #$- ff .&)fffi !/ff ff * )fiff ##-$ff%fi&&fi fiffff fi fiff fffi fffffi fi &fffi fi ff fi ff& fi fffffi + fifi fiff5fi@@fiff fi .ff .&fi fi ;fi ff@ ff "fiff 5ff fi .fiIfffi ff ffff fffi fi ( fi fiNff :fffi fi fi ffff= ;fi fi fifffi ;fi /ff 5 ff ff fiff ff fffi@fi $ff )6 PUff 24 fifi ff fififi !fiffff fi fifi ff ff fifffi PUff - fi /fi . fi fi ffff ffff02fi fiffff fifi ' ( fffi fi #ff$fffi fffi fffiff fiff ; ff #B ff ! -4 ! fi 4 fi ! -ff ff "ff #ffff fi fffi fi fi fiff ff "ff fffi fffi fi & ffff fiff= fifffi 9 fffi !: * ; ff #<-ff "ff #fffffi ff fi ff fffi fififi fffiff ff fffi ( fi fffiff fffi !B-fffi fififffi !<M##- fififi fffi fffi fi fififffi ff fi !#1M#- & fiff ff fi fififi ff ! J - fifi fffi fi fffi! J - + fiff ff fi fi fiff fffifi ( fffi ffff ff fi fi fifffi ff fi fifffffiff fi fffffi fi fiff ff ( fffi 9fi fffififi fffififfff3 fi fi fi fi ff fifi fffi !#-fi4 fi ff fi fi 4 !<M- ff !1-fi4 fi ff !fi- fi fiff!< # fi ##- !#- fi fi fffi fi@ fffi fifi 3ff fi . ff !#- !1- fi fffi fi fi4 ff ! - ff ! - fi fi fi fiff ff fifi fi fffifi fi fi fi ff(fi fffi ff fi fi !#- fffi fi fi fi fi4 !#$M#,- ff ! -fi fi4 fi fi ! - fi ! - !fi- fiff !#BM#- & 9ff fififi fi fi4 fi fi fiff fi fi ff fi fiff ff fi fiff ! fiff fi4 -8 fi fi fiff fiff0ff ff !#<-fi fi fififi fi fi fi fi fiff fi fififffi ! - ! - fi ff fi fifi 4 ffff! fifffi fi ! - fi ! - fiff -& ff fi ffff ff fiffff "ff #ffff "ff ffff fiffff ff#$$!"*--*-***"#$$*ff fiff ffffffffffffff6ffff ff "ff fffi ff9ff fffi fi 6ffff ff "ff #ffff ff fifi fffi fi1-fifi ff fffiff fi fi fi ff fiff "ff #ff! $ 7 ( fi fi ! - fi fi fffffiff fi ! -%% 7 (ff fffi fi ! -# % %1 % % %$J J,% %B ff ff fi ! - fi ! ff ! - ! - ff '! - ! - %<ff ff !ff ff ! ! - ! -% HO )fi fffi OH#ff ! - ff fi ff ! - fi ff ! ! - ! -% HO )fi fffi OH###1ff#$ff ff ! - fi ! - ff! - ! -% HO fi fffi OH#,#B!! -%#'ff ! - ff fi ff#<ff ! - ! ff ! - ! - ff -! - ! -% HO fi fffi OH##! -%1%1#++*-+ -**--#--****"5#$$"*!****"!#*5*--#$$*#$$**-##*52 !-*"*5*ff "ff ff! $ 7 ( fffi fi ! - fi fi fffffiff fi ! -%% 7 (ff fffi fi ! -# %ff fi%1 ff ! - ff$ ff fffi ff !,ff ff fi ff ! B! - ! -% HO 6OH' ff ff< ff ff !ff ff fi ff !! - ! -% HO ffff OH# ff ff ! ##ff ff fi ff ! #1! - ! -% HO 4 OH#$***"""#$$!!; ff #B7 fiff fffffi1fi fiffff fifi fiff fi fiff fi fiff fffi fifffi fi fi ff fi fi$ff J fi fi fifi fifffi ff fi fi ! J - fi fiff fi ff fifffi fi fi fiff ff fi fi$ ffJ .fi fifi fifffi fi fi fffi fifi fi ! #-$ff J E # ( fi ff fifi fi fi fffi fi fi fffifi fifi E #fi ! fi fi fi fiff ff - fi * fifi : fifi fi!- fififf4* ff !- ! - fi fi4* ! -* fi ! - ff fi ff * fi6fi !- ff#$M#, ff "ff ffKfiff fi !- fiff fifi fi fffifi !- fi ff ! - ff fi * fi fiffff * fi ! - fffffi! - !! -- fifffififf fifi fffi fi ! -fi fi ff ff fi fffi fi ! -#'M# ff ff fffiff ff fifi&ff fi fiff fifffi fi ff fifi fi 9 fiff 4ff fi fi fifi fffi. fi +ff>fffi ? !fffiff- fi fi fffififf ff fi !. * + #- (ff ff 9 ffff fffi fi fi fi ff 6fffffi fi fi fi fi fi . fi + ff fi fi4 fi fi ff fiff: fi 34ff !1#-fffi ff ff fi fffifi fi fi fiff ff : fiff fi@fififf fi fi fifffi ff fifffffiff fi 4 fi 2ff ff fiff fi9fi 4ff + : fi 34fffi fi fifffifififf fiff ff "ff #ffff fi ff fiff9 ff fi fffiffff & ff fififf fififf 4ff ff ff "ff #fffffi !fi#- ffff ff fiff fffi fififfff fifi fi ! fi fiff fiff- : fi 34ff ff fffffiff fi;fi fffiff fi fiff fi fi 9fi > fififf? fi ff ff fiff ffff;ffff fi ff ff fifffffififi fffffffi fffi fififf ! ' - fffffi1666*+*6************-**fifi ff fffiff fi fi fi ff fifi fi fiff ! fi fi fi fififfff- )ffff ' fiff fi ff ffff fi fiffff ;ff fffi ffff fffffffi fffififf & fi ff fi ffff $ff )6ff fi fififf ffff ff fififf fi )ff 2fi6fiff 6 ffff fiff fi fifffi ff!ff fffi ff fiff fi fi fifffi fi fifi fffi fifi fi ff !3ff * . ff #- ff !!; * 5 #fi- ( fiff fiff; fi 5 !1-;fi ff fi fffiff fi 4fffi fififf ; ff #B9 fffi ff ff fi ; fi 5 !1$-1fi fiffff fifi )'fi*fffffffiffDepots-TimeMilliseconds1e+071e+06Depots-TimeQualityLPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (11 solved)SuperPlanner (Quality) (11 solved)LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (11 solved)SuperPlanner (Quality) (11 solved)250020001000001500100001000100050010001005101520DriverLog-TimeMilliseconds1e+0602551025LPG-speed (18 solved)LPG-quality (18 solved)SuperPlanner (Speed) (16 solved)SuperPlanner (Quality) (16 solved)250010000020DriverLog-TimeQuality3000LPG-speed (18 solved)LPG-quality (18 solved)SuperPlanner (Speed) (16 solved)SuperPlanner (Quality) (16 solved)1520001000015001000100010050010002468101214161820Rovers-TimeMilliseconds1e+06024681012141618201214161820Rovers-TimeQuality1000LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (12 solved)SuperPlanner (Quality) (12 solved)LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (12 solved)SuperPlanner (Quality) (12 solved)1000008001000060010004001002000100246810121416180201,246810fifi ff fffiff fi fi fi ff fiZenoTravel-TimeMilliseconds1e+07LPG-speed (19 solved)LPG-quality (19 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)1e+06ZenoTravel-TimeQuality1800LPG-speed (19 solved)LPG-quality (19 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)160014001000001200100010000800100060040010020010002468101214161820Satellite-TimeMilliseconds1e+0724681012141618201214161820Satellite-TimeQuality700LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)1e+060LPG-speed (20 solved)LPG-quality (20 solved)SuperPlanner (Speed) (20 solved)SuperPlanner (Quality) (20 solved)6005001000004001000030010002001001001000246810121416182001.246810fi fiffff fifi !' !ffffff +fifi& fiffff fifi .ff)fiff ff fifffi ff fi ff fi fiff & fifffiffff 7 ffff !1 fi $ff -% fffffiffHff fi .ff)fiff !,H' -% fffffiffHff fi .ff)fiff !BH< - (fi ff fiff fi ff 6)N ff ff9ff fi fi fi ffff fi ff fi + fififf fifi 9 fi ff ff 6)N fi ff 9+$/,+-+$ /!1+,+!1+,+- fi!1+,+0!1+,+- fi0!1+fffi2222&222& (&2222&#2' (#2( &2% 2' 22#&22& &22&22&#2' (#(2'2% (2% (22(%#&2& #(2&2&22'2#&2fffi&#&2) 222&2'2&2' )2&2&2' )2(#'2) )#)2& (&2( )&2) 2) 2)#%2% '#'2' 2'2'2%&2&#2#'2&2&2&2&2)#)222&2&22#2fffi#2) 222&2&#2&2' )2'222((#&2% '#'2( )&2) 2&2& (&2)#%2&%#&2' 2'&2'22%#2' (#222&2& &2#(2#22&22&2#2fffi&#&2) 2( )&2'22)#'2#2' )2%&2% (22((#%2) '#%2( &2&222'#%2#2&2) %222%#(2&%#&2&2( &2% (22'#)2#2&2&2& &2& &2(#'2fi2( )&2&2% (2&2&22%#'2' )2)#2'2&&#)2& &2#2) %2)#22#'2.fffifi1/fifi ff fffiff fi fi fi ff fifi ,' !ffffff +- .fi& fiffff fi fi fi .ff)fiff fffifffi ff fi ff fi fiff & fifffiff ff 7 ffff !1 fi $ff -% ffff fiffHff fi.ff)fiff !,H' -% fffffi ffHff fi .ff)fiff!BH< -( ff fi ff ff fiff fiff ff ff fi fi fifi fi fi ff fi ! fiffffff - & fi fifi fi fffi ff fiff9fiff .ffff fffi fi 9 fi ff fi fiff ff fffi ffff fffi+$/,+-+$ /!1+,+!1+,+- fi!1+,+0!1+,+- fi0!1+fffi2222&222& (&2222&#2&%#&2% (2%&2'&2&2&22& &2222%#2% )#22&22%&2#(22222&2#2fffi&#&2) 222&2'2&2' )2&2&2' )2(#'2)'#%2( )&222( )&2#2&2&2&2( &2&2#2%#&2&2222#2222222fffi#2) 222&2&#2&2' )2'222((#%2( ((#2( )&2) 22&&2)#%2%#2% 2) %2& &22&#&2#2&222%&2#(22222&2#2fffi&#&2) 2( )&2'22)'#2#2' )2%&2% (22((#%2%&#&2& (&2) %2'2%&2&#2%#&22) %2( &2&2)#'2) '#%222% 2' 2(#'2%#&222% 2&2(#)2fi2( )&2&2%&2&222%#'2' )2)#2) 2(2& &2#2&2#'22#(2.fffifi10fi fiffff fi( P !#$- fifi fifffi fffi )fifi ff)- ./0 $1M,$( P !##- &fffi fffi fifi (ff+#M'fffi 0fi fi .fi fi 6(: ( * ; ff !#<- ;fifi fffi fffififi$ff ffff 12 1#M$: : * 34ff 2 !1#- )fi fi ff fiff $ff ffff 0.1 !#1- BM$$/ff K ff * )fiff P !##- &fffi fffi ff $ffffff 31 '#MB/* 3ff ( !11- &fffifi ff fffffffi7 fiff fiff ffff +ffffff 4 $ff )ffffff+ ff+ ff )+ fifi )+2./ * 0fi fifi . !1#- .fifi7 ( fiff fffffififf +ffffff * 4ff )ffffff + 4)+20& .fi .ffff "fffi/ * 0fi fifi . !11- )fi fffifi ff fffffifi * $ff )ffffff $ff ffff +* ff $+*2. 5+ "fffi +Ffi. !11-fffi fi fffififffifi " ff $ff )ffffff $ff ffff+ * ff $+*2. 5+ "fffi 6fi; * 5 / !#fi- & fi fi ff fi fifffi & 7$ff ffff (ffff 7$( 1 $'<M,1#; * 5 / !# - Ffi )fi 3fffi.&(8 7$ff ffff (ffff 7$( 02 <M##B; * 5 / !1- N@ fi fifi ffff fifffi fffiff fi fiff +ffffff 8 $ff )ffffff$ff ffff + * ff $+*22#1M### ((( )ff; * 5 / !1$- )//51#7 fi )//5 fffffffifi fi 7 $ff ffff (ffff 7$(3ff ( .fi ( * .fffi !1$- fififffi ff fi ff fifffi fi 5)3 +ffffff 4 )ffff $$ff ffff .ffff !586.H58(- ;ff11fifi ff fffiff fi fi fi ff fi3ff ( * . ff 5 !#'- (fffi )fifffiIffff )fiff7 . &ff F4 .fiff 6ff fi )ff 7 $ff ffff (ffff7$( 8 BM#$<3ff ( * . ff 5 !#- ffff fi fffi ff fifi +ffffff 08 ' )ffffff ff fiff$ff ffff $19BM#1 ((( )ffH& &ff3ff ( * .fffi !#- ;fifi ff ff fi fffi+ffffff 0/ ' )ffffff ff fiff$ff ffff$11B$MB# ((( )ffH & )ff3ff ( * .fffi !1- ;fifi fififi fffi fffi7 5fifi fi fiff +ffffff 8 $ff )ffffff$ff ffff + * ff $+*22##1M#1# ((()ffH & )ff3ff ( * .fffi !11- 5)37 (fiff fi fi fiff fffi fffifi +ffffff / $ff )ffffff $ff ffff + * ff $+*2.1#M1 ((( )ffH & )ff3ff ( * .fffi !1$- )fi fifffi 6.)7 ff +fifi fififf ff fi fffi)%'*"($'"* 9 !,-3ff ( .fffi .fi ( * .. !1$- 5fi fiff fffffifi 5)3 +ffffff 0: $ff )fffffffi ff + ; * ff $)+*2:'1M<# ((( )ffH & )ff2fi ) * 34ff 2 !1- ( ff fffifi +ffffff 8 $ff )ffffff $ff ffff + * ff$+*22#, #, ((( )ffH & )ff2fi ) * 34ff 2 !1#- 2 fffi fi ff ff +ffffff * 4ff )ffffff + 4)+20 & .fi .ffff"fffi24 fi P !1$- & ff;;fi 7 fffifi >ff ?ff fi fifffi 7 $ff ffff (ffff 7$(24 fi P !1#- ;;7 & fifffifffi $ - <ff .. !$- B<M'124 fi P * 8 : !1#- & ;;fi 7 ;fifi fffi ffff fiff 7 $ff ffff (ffff 7$( 03 1B$M$10fi @ 2 * . fi : !#- N .(& fi fi fffififi +ffffff 0/ $ff 7 )ffffff $ff ffff $7)$11$#M$1B12fi fiffff fi0fi @ 2 * . fi : !#'- )7 )fifffi fifi fiff .ff 2 * .fiff & !F- +ffffff " ffff' )ffffff ff fiff$ff ffff $1/##,M#1# ((( )ff0ff P 8 : 24 fi P * /!#<- Ffi fffifi (/5 & ffU ff ff fi ;ff ff 3ff fi5 / * ; !1$- & $ff fffififi7 K fififi 7 $ff ffff (ffff 7$((ff / * K / !##- . fi fifffi +ffffff ' ' )ffffff $ff ffff $10'$,M'$8fi / ( & fi 0 ff N ff P + / * Sfi fi ; !1$- .2I)17fi 2&8fi 7 $ff ffff (ffff 7$(8 V * 0fi fifi . !1#- Kfifffi fffffi +ffffff 0= $ff 7 )ffffff $ff ffff $7)$20,BM,'') ff P * + / !#1- N6)I)7 (fifffi fffffiff ff(/5 +ffffff " $ff )ffffff + ff>ffff (ffffff (ff>(?1.#$M##, : ( fffi 0fifi) ff P * + / !#,- &fffifi fi +ffffff "ff ' )ffffff ff fiff$ff ffff $13##M##B .fi +( fffi 0fi fi)fi P / * )fi !#<- ;fi fffi fffifffifffffi 7 $ff ffff (ffff 7$( / 11$M1'1. fi : 0fi @ 2 * 6 : !#,- 8 fffi ffff fi fiff+ffffff "ff ' )ffffff ff fiff$ff ffff $13$$<M$,$ .fi +( fffi 0fi fi. / * + / !#- &fffifi fi fffi+ffffff 0/ 7 )ffffff $ff ffff $7)$11$1'M$$<&fi F !#'- )fi fffi fifffi fffi +ffffff = 4ff)ffffff $ff ffff !F6('-,<M,$"ff . ( !#$- )fi 7 + fi fffi ff fi fi fi $444"+ ff- ff $ff ffff 8 !$- 1,'M1'<2-fiJournal Artificial Intelligence Research 20 (2003) 149-154Submitted 9/03; published 12/03CommentaryCase Durative Actions: Commentary PDDL2.1David E. SmithNASA Ames Research CenterComputational Sciences Division, Mail Stop: 269-2Moffett Field, CA 94035, U.S.A.DESMITH@ARC.NASA.GOVAbstractaddition durative actions PDDL2.1 sparked controversy. Fox Longargued actions considered instantaneous, start stop processes.Ultimately, limited notion durative actions incorporated language. arguenotion still impoverished, underlying philosophical positionregarding durative actions shorthand start action, process, stop actionignores realities modelling execution complex systems.1. IntroductionPDDL2.1 introduces limited notion time classical STRIPS planning framework.particular, introduces notion durative actions, is, actions take time. However, notion durative action rather limited, somewhat begrudging. reflectsunderlying philosophical position Fox Long actions really instantaneous,initiate terminate continuous processes. According view, durative actionsseen shorthand start action, process, stop action. result, durativeactions lack important features, namely ability require (pre)conditions holdspecified intervals, effects take place arbitrary time points withinaction. Fox Long argued features captured breaking durative action series smaller actions effects beginning end,preconditions beginning, end, entire action. However,representation exceptionally cumbersome, ignores fact agent mayseparate control actions. addition, representation forces planneradditional work order connect actions.2. Exampleillustrate problems PDDL2.1 notion durative action, consider simpleexample spacecraft must turn order point instrument particular target.order turn spacecraft, thrusters reaction control system (RCS) fired ordersupply angular velocity. spacecraft coasts pointing correct direction (or nearly so), RCS thrusters fire order stop rotation. Firingthrusters consumes propellant, requires controller dedicated task.addition, thrusters firing, vibration spacecraft, certainoperations cannot performed. thruster firings relatively quick, coastingphase not. general, turning large spacecraft slow process may take severalminutes. reason speedy turns require greater acceleration deceleration,therefore consume propellant.fiS MITHfirst question need answer is, best way model complex operation? could model turning operation initial action start spacecraft turning, another action stop turn, interspersed processes modelcraft between. level detail, seems reasonable modelphysics. However, may well turning guidance built primitive operations spacecraft, possibility starting stopping turnsindependently. could model operation consisting instantaneous actionstart turn, followed finite process terminates turn complete.bother? fact is, interested effects process, initiatedstarting turn. reasons, seems natural proper regard durative action, effects take place throughout action.lets suppose want model operation durative action PDDL2.1.could say something like:(:durative-action turn:parameters (?current-target ?new-target - target):duration(= ?duration (/ (angle ?current-target ?new-target)1(turn-rate))):condition(and (at start (pointing ?current-target))(at start (>= (propellant) propellant-required))(at start (not (controller-in-use)))):effect(and (at start (not (pointing ?current-target)))(at start (decrease (propellant) propellant-required))(at start (controller-in-use))(at start (vibration))(at end (not (controller-in-use)))(at end (not (vibration)))(at end (pointing ?new-target))))However, model action quite conservative. ties controller entireturn operation, specifies vibration present entire operation. addition,consumes required propellant beginning operation. reality, RCSfiring beginning end turn. result, controller needed two periods, vibration present two periods, propellantconsumed two periods. might matter coast phase relatively quick. However, indicated earlier, turning large spacecraft take severalminutes. Unfortunately, PDDL2.1 rather limited notion durative action cannotspecify action conditions effects times start end action.3. Decomposition Sub-actionsFox Long pointed out2 possible model durative action intermediate conditions effects breaking sequence sub-actions. turnaction would need three sub-actions illustrated below: start-turn action, coastaction, stop-turn action, together turn action bind together.1. Note assumes precomputed provided angles possible pairs targets.want this, must provide (vector) direction target planner would needability vector arithmetic trigonometry within formulas.2. Personal communication.150fiT C ASEURATIVE CTIONS : C OMMENTARY PDDL2.1(:durative-action turn:parameters (?current-target ?new-target - target):duration(= ?duration (/ (angle ?current-target ?new-target)(turn-rate))):condition(and (at start (pointing ?current-target))(at start (>= (propellant) propellant-required))(at end (finished))):effect(and (at start (not (pointing ?current-target)))(at start (turning))(at start (enabled-start-turn))(at end (not (turning)))(at end (not (finished-turning)))(at end (pointing ?new-target))))(:durative-action start-turn:parameters ():duration(= ?duration (start-turn-duration)):condition(and (at start (not (controller-in-use)))(at start (>= (propellant) (/ propellant-required 2)))(over (turning))(over (enabled-start-turn))):effect(and (at start (decrease (propellant) (/ propellant-required 2)))(at start (controller-in-use))(at start (vibration))(at end (not (controller-in-use)))(at end (not (vibration)))(at end (not (enabled-start-turn)))(at end (enabled-coast))))(:durative-action coast:parameters ():duration(= ?duration (coast-duration)):condition(and (over (turning))(over (enabled-coast))):effect(and (at end (not (enabled-coast)))(at end (enabled-stop-turn))))(:durative-action stop-turn:parameters ():duration(= ?duration (RCS-duration)):condition(and (at start (not (controller-in-use)))(at start (>= (propellant) (/ propellant-required 2)))(over (turning))(over (enabled-stop-turn))):effect(and (at start (decrease (propellant) (/ propellant-required 2)))(at start (controller-in-use))(at start (vibration))(at end (not (controller-in-use)))(at end (not (vibration)))(at end (not (enabled-stop-turn)))(at start (finished))))Figure 1 shows graphically actions tied together. goal pointingparticular target, turn action required. turn action end precondition(finished), satisfied adding stop-turn action3. Stop-turn151fiS MITHcondition (enabled-stop-turn) satisfied end effect coast action.Likewise, coast action condition (enabled-coast) satisfied end effect start-turn action. start-turn action condition(enabled-start-turn) satisfied start effect turn action. result,turn action forces three sub-actions plan, sub-action forces predecessor sub-actions turn action plan. three sub-actionscondition (turning) satisfied turn action. result, wayconsistently achieved three sub-actions packed sequentiallyturn action.pointing(?current)turningenabled-start-turnpointing(?target)turningfinishedturnpointing(?current)finishedenabled-start-turnenabled-coaststart-turnturningenabled-start-turncoastturningenabled-coastenabled-coastenabled-stop-turnfinishedenabled-stop-turnstop-turnturningenabled-stop-turnFigure 1: Sub-actions Turn operation. Start, end, over-all conditionsshown action. interconnecting start end effects shownaction. simplicity, omitted effects concerning vibration, controlleruse, propellant usagetwo additional subtleties representation. first that, althoughthree sub-actions occur turn action, obvious requirementoccur turn action. Suppose tried place start-turnaction previous turn action. previous turn action would three subactions, wayward start-turn action would conflict sub-actions. Thus,order make work, would push three sub-actions earlier turnaction, on. Realizing cannot work requires difficult induction argument.seems unlikely existing planner could actually infer this, trialerror. result, process generating plans involving actions would incur significant computational overhead, engage needless search.second subtlety overlooked decomposition computingdurations sub-actions bit tricky. reasonable assume startstop turn actions fixed duration, duration coast action depends current3. turns (finished) effect stop-turn must start effect rather end effect. reasonoccur end effect, stop-turn action would need complete prior end turnaction, since (finished) effect mutex (not finished) end effect turn action. Despiteasymmetry representation, stop turn still forced occur wholly within turn actionoverall condition (turning).152fiT C ASEURATIVE CTIONS : C OMMENTARY PDDL2.1target orientations spacecraft. fact, duration coast action mustduration turn action minus durations start stop turn actions.way introduce additional numeric turn-duration function setturn action, used compute duration coast action.process decomposing action sub-actions complex convoluted? all, HTN planning paradigm done time. reasongenerative planning adopted view, better worse, one alloweddirectly specify action used actions connected other.result, order force sub-actions abut fit within turn action, musttricky things. One might argue need HTN capability order modelactions. Indeed, would certainly make things easier. However, another way.4. Richer Durative ActionsOne approach dealing modelling problem admit richer languagemodelling durative actions. make convenient model actions like turn action,need able specify conditions must hold various points intervals withinaction, effects take place various points intervals within action.many possible ways one could express conditions effects, onestraw-man possibility:(:durative-action turn:parameters (?current-target ?new-target - target):duration(= ?duration (/ (angle ?current-target ?new-target) (turn-rate))):condition(and (at start (pointing ?current-target))(at start (>= (propellant) propellant-required))(at start (not (controller-in-use)))(at (- end RCS-duration) (>= (propellant) (/ propellant-required 2)))(at (- end RCS-duration) (not (controller-in-use)))):effect(and (at start (not (pointing ?current-target)))(at start (decrease (propellant) (/ propellant-required 2)))(over [start (+ start RCS-duration)] (controller-in-use))(over [start (+ start RCS-duration)] (vibration))(at (- end RCS-duration) (decrease (propellant) (/ propellant-required 2)))(over [(- end RCS-duration) end] (controller-in-use))(over [(- end RCS-duration) end] (vibration))(at end (pointing ?new-target))))need explicitly construct actions starting stopping turn,coasting. reason, need worry durations connectingsub-actions. Instead, simply specified effects appropriate timesturn action. Note specified vibration controller use interval effects. seemsless cumbersome specifying two separate effects stating controller usebeginning interval, longer use end. However, alsofundamental difference two encodings: encoding above, possibility another independent action could somehow make controller availableinterval use. Bedrax-Weiss et. al. (2003) argued introductionexplicit notion resource PDDL language. notion couldsimplify encoding even further, specifying controller reusableresource required turn action appropriate intervals. Vibration (or stability) could also treated resource, although somewhat less intuitive so.153fiS MITHOne final issue avoided notion continuous change. spacecraftexample, certainly continuous change going on. Propellant burned instantaneously, orientation spacecraft changes continuously. question is,need model this? Certainly domains necessary reason continuous change. Fox Long point out, concurrent actions well simultaneous consumption production resources, may necessary reasonresources change course actions. example, Mars rover receivesenergy solar panels time driving place place. Since battery minimum maximum capacity, one cannot model easily using discreteconsumption production effects. However, consumption production happensimultaneously, one model continuous change taking place start endaction. sufficient spacecraft example since actions increasepropellant, one cannot perform two simultaneous actions affect spacecraftsorientation.5. ConclusionDurative actions PDDL2.1 limited, expressing complex durative actionsdecomposition sub-actions difficult clumsy. time, clearmodelling actions like turning spacecraft terms processes either necessary useful, particularly possibility process deliberately interrupted.domains like this, richer, expressive notion durative action seems like rightmodelling tool. Note would argue modelling processes completelyunnecessary. However, many practical planning applications overkill. resultscomplex representation planning process necessary.cheating model complex processes durative actions? course is. modelling cheating. real world physics, nothing instantaneous indivisible,cheating model anything instantaneous action. Yet, usually content modelaction like turning light switch instantaneous indivisible, even thoughtake small amount time, complex processes behind it. durative actiondifferent simply choosing model details process structure behindaction, even though may necessary model fact action takes time,effects take place different times action. many practical applications, durative actions essential modelling tool, deserve richer treatmentprovided PDDL2.1.ReferencesBedrax-Weiss, T., McGann, C. & Ramakrishnan, S. (2003) Formalizing resources planning. Proceedings ICAPS-03 Workshop PDDL.Fox, M. & Long, D. (2002) PDDL+: Modeling continuous time dependent effects. Proceedings 3rd International NASA Workshop Planning Scheduling Space.Fox, M. & Long, D. (2003) PDDL2.1: extension PDDL expressing temporal planning domains. Journal Artificial Intelligence Research, issue.154fiJournal Artificial Intelligence Research 20 (2003) 379-404Submitted 10/02; published 12/03SHOP2: HTN Planning SystemDana Naunau@cs.umd.eduDept. Computer Science, Institute Systems ResearchUniversity Maryland, College Park, MD 20742 USATsz-Chiu Auchiu@cs.umd.eduDept. Computer ScienceUniversity Maryland, College Park, MD 20742 USAOkhtay Ilghamiokhtay@cs.umd.eduDept. Computer ScienceUniversity Maryland, College Park, MD 20742 USAUgur Kuterukuter@cs.umd.eduDept. Computer ScienceUniversity Maryland, College Park, MD 20742 USAJ. William Murdockmurdockj@us.ibm.comIBM Watson Research Center19 Skyline Dr.Hawthorne, NY 10532 USADan Wudandan@cs.umd.eduDept. Computer ScienceUniversity Maryland, College Park, MD 20742 USAFusun Yamanfusun@cs.umd.eduDept. Computer ScienceUniversity Maryland, College Park, MD 20742 USAAbstractSHOP2 planning system received one awards distinguished performance2002 International Planning Competition. paper describes featuresSHOP2 enabled excel competition, especially aspects SHOP2deal temporal metric planning domains.1. IntroductionSHOP2, Simple Hierarchical Ordered Planner 2 (Nau, Munoz-Avila, Cao, Lotem, & Mitchell,2001), domain-independent planning system based Hierarchical Task Network (HTN)planning. 2002 International Planning Competition, SHOP2 received one topfour awards, one two awards distinguished performance. paper describescharacteristics SHOP2 enabled excel competition.Like predecessor SHOP (Nau, Cao, & Munoz-Avila, 1999), SHOP2 generatessteps plan order steps later executed, knowscurrent state step planning process. reduces complexityreasoning eliminating great deal uncertainty world, thereby makingeasy incorporate substantial expressive power planning system. Like SHOP,c2003AI Access Foundation. rights reserved.fiNau, Au, Ilghami, Kuter, Murdock, Wu, & YamanSHOP2 axiomatic inference, mixed symbolic/numeric computations, callsexternal programs.SHOP2 also capabilities go significantly beyond SHOP:SHOP2 allows tasks subtasks partially ordered; thus plans may interleavesubtasks different tasks. often makes possible specify domain knowledge intuitive manner possible SHOP.SHOP2 incorporates many features PDDL, quantifiers conditionaleffects.alternative ways satisfy methods precondition, SHOP2 sortalternatives according criterion specified definition method.gives convenient way author planning domain tell SHOP2 partssearch space explore first. principle, technique could usedplanner plans forward initial state.SHOP2 handle temporal planning domains, way translatetemporal PDDL operators SHOP2 operators maintain bookkeeping information multiple timelines within current state. principle, techniquecould used non-temporal planner sufficient expressive power.rest paper organized follows. Section 2 gives background HTNplanning, Section 3 describes SHOP2s features planning algorithm. Section 4describes write domain descriptions SHOP2: particular, Section 4.1 discussesbasic problem-solving strategies, Sections 4.2 4.3 describe aspects SHOP2specific handling temporal metric domain features. Section 5 discusses SHOP2sperformance competition, Section 6 discusses related work, Section 7 givessummary conclusion. Appendix contains SHOP2 domain description oneproblem domains planning competition.2. HTN PlanningHTN planning like classical AI planning state world representedset atoms, action corresponds deterministic state transition. However,HTN planners differ classical AI planners plan for, planit.objective HTN planner produce sequence actions performactivity task. description planning domain includes set operators similarclassical planning, also set methods, prescriptiondecompose task subtasks (smaller tasks). Figure 1 gives simple example.Given planning domain, description planning problem contain initial statelike classical planningbut instead goal formula, problem specificationcontain partially ordered set tasks accomplish.Planning proceeds using methods decompose tasks recursively smallersmaller subtasks, planner reaches primitive tasks performed directly using planning operators. nonprimitive task, planner chooses380fiSHOP2: HTN Planning Systemtask:preconditions:task:(transport ?p)(at ?p ?x)(destination p ?y)(available-truck ?t)(transport-two ?p ?q)preconditions:subtasks:(package ?p)(package ?q)subtasks:(dispatch ?t ?x) (load ?t ?p) (move ?t ?x ?y) (return ?t ?x)task:(transport ?p) (transport ?q)task:(dispatch ?t ?x)subtasks: (reserve ?t) (move ?t home ?x)(return ?t ?x)subtasks: (move ?t ?x home)(free ?t)Figure 1: Methods transporting package ?p, transporting two packages ?p ?q,dispatching truck ?t, returning truck. Arrows ordering constraints.shaded subtasks primitive tasks accomplished followingplanning operators: (load ?t ?p) loads ?p onto ?t; (move ?t ?x ?y) moves ?t?x ?y; (reserve ?t) deletes (available-truck ?t) signal truck use;(free ?t) adds (available-truck ?t) signal truck longer use.(transport-two p1 p2)(package p1)(package p2)(transport p1)(transport p1)(at p1 l1)(destination p1 l3)(available-truck t1)(dispatch t1 l1)(dispatch t2 l2)(load t1 p1)(reserve t1)(at p2 l2)(destination p2 l4)(available-truck t2)(return t1 l1)(load t2,p2)(move t1 l1 l3)(reserve t2)(move t1 home l1)(move t2 home l2)(return t2 l2)(move t2 l2 l4)(free t1)(move t1 l3 home)(free t2)(move t2 l4 home)Figure 2: plan accomplishing (transport-two p1 p2) following initial state:{(package p1), (at p1 l1), (destination p1 l3), (available-truck t1), (at t1 home),(package p2), (at p2 l2), (destination p2 l4), (available-truck t2), (at t2 home)}.381fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yamanapplicable method, instantiates decompose task subtasks, choosesinstantiates methods decompose subtasks even further, illustrated Figure 2.plan later turns infeasible, planning system need backtracktry methods.HTN methods generally describe standard operating procedures one wouldnormally use perform tasks domain (e.g., see Figure 1) HTN practitionerswould argue representations appropriate many real-world domainsclassical planning operators, better characterize way users thinkproblems.Like HTN planners, SHOP2 hand-tailorable: planning enginedomain-independent, HTN methods may domain-specific, plannercustomized work different problem domains giving different sets HTNmethods. ability use domain-specific problem-solving knowledge dramaticallyimprove planners performance, sometimes make difference solvingproblem exponential time solving polynomial time (e.g., Gupta & Nau, 1992;Slaney & Thiebaux, 2001). experimental studies (e.g., Nau et al., 1999, 2001; Bacchus& Kabanza, 2000), hand-tailorable planners quickly solved planning problems ordersmagnitude complicated typically solved fully automated planningsystems domain-specific knowledge consists planning operators.3. Features SHOP2section describes SHOP2s planning algorithm SHOP2s distinctive features.3.1 Basic Elements Domain Descriptiondomain description description planning domain, consisting set methods,operators, axioms. describe briefly; additional details appearSection 4.3.1.1 Taskstask represents activity perform. Syntactically, task consists task symbolfollowed list arguments. task may either primitive compound. primitivetask one supposed accomplished planning operator: task symbolname planning operator use, tasks arguments parametersoperator. compound task one needs decomposed smaller tasksusing method; method whose head unifies task symbol argumentsmay potentially applicable decomposing task. details discussedfollowing subsections.3.1.2 Operatorsoperator indicates primitive task performed. operatorssimilar PDDL operators: operator head head(o) consisting operatorsname list parameters, precondition expression pre(o) indicating382fiSHOP2: HTN Planning System(:method; head(transport-person ?p ?c2); precondition(and(at ?p ?c1)(aircraft ?a)(at ?a ?c3)(different ?c1 ?c3)); subtasks(:ordered(move-aircraft ?a ?c1)(board ?p ?a ?c1)(move-aircraft ?a ?c2)(debark ?p ?a ?c2)))Figure 3: SHOP2 method simplified version ZenoTravel domain.true current state order operator applicable, delete list del(o)add list add(o) giving operators negative positive effects. Like PDDL,preconditions effects may include logical connectives quantifiers. operatorsalso numeric computations assignments local variables (an example appearslater Figure 11). PDDL, two operators name; thusprimitive task, applicable actions instances operator.operator also optional cost expression (the default value 1). expression arbitrarily complicated use variables appearoperators head precondition. cost plan sum costs operatorinstances.3.1.3 Methodsmethod indicates decompose compound task partially ordered setsubtasks, compound primitive. simplest version methodthree parts: task method used, preconditioncurrent state must satisfy order method applicable, subtasksneed accomplished order accomplish task.example, Figure 3 simplified version SHOP2 method onedomains AIPS-2002 Planning Competition, ZenoTravel domain. methodgives way transport person ?p aircraft one location ?c1 another location?c2 aircraft already ?c1.1 :ordered keyword specifies subtaskstotally ordered: first move aircraft ?c1, board person, moveaircraft ?c2, debark person.2 specify unordered set subtasks, would1. symbol begins question mark variable name.2. method figure would meaning :ordered omitted. list subtasksbegin :ordered :unordered, SHOP2 assumes :ordered.383fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman(:; head(enough-fuel ?plane ?current-position ?destination ?speed); tail(and (distance ?current-position ?destination ?dist)(fuel ?plane ?fuel-level)(fuel-burn ?speed ?rate)(eval (>= ?fuel-level (* ?rate ?dist)))))Figure 4: SHOP2 axiom simplified version ZenoTravel domain.use keyword :unordered rather :ordered; complicated partial orderingsspecified using nested combinations :ordered :unordered.3generally, method may form(:method head(m) p1 t1 p2 t2 . . .),head(m) task called head m, pi precondition expressionti partially ordered set subtasks. meaning analogous if-then-else:tells SHOP2 p1 satisfied t1 used, otherwise p2 satisfiedt2 used, forth. keep descriptions paper simple,assume without loss generality one precondition expression pre(m)one set subtasks sub(m).general, may several alternative ways accomplishing head(m). mayone method whose head head(m), one set variable bindingssatisfy pre(m), one ordering consistent sub(m), onepossible way accomplish subtasks sub(m). alternatives producebranches SHOP2s search space.3.1.4 Axiomsprecondition method operator may include conjunctions, disjunctions, negations, universal existential quantifiers, implications, numerical computations, external function calls. Furthermore, axioms used infer preconditionsexplicitly asserted current state. axioms generalized versions Horn clauses,written Lisp-like syntax: example, (:- head tail) says head true tail true.tail clause may contain anything may appear preconditionoperator method.example, axiom shown Figure 4 says plane enough fuel reach?destination following conditions satisfied: distance travel ?dist, fuellevel ?fuel-level, burn rate ?rate, ?fuel-level less product ?rate?distance. last conditions handled using external function call,described below.3. notation allow every possible possible partial ordering, problempractice; notation less clumsy allow every possible partial ordering.384fiSHOP2: HTN Planning Systemprocedure SHOP2(s, T, D)P = empty planT0 {t : task constrained precede t}loop= return Pnondeterministically choose T0primitive task{(a, ) : ground instance operator D, substitution unifies {head(a), t}, satisfies preconditions}= return failurenondeterministically choose pair (a, )modify deleting del(a) adding add(a)append Pmodify removing applyingT0 {t : task constrained precede t}else{(m, ) : instance method D, unifies {head(m), t},pre(m) true s, general possible}= return failurenondeterministically choose pair (m, )modify removing t, adding sub(m), constraining tasksub(m) precede tasks preceded, applyingsub(m) 6=T0 {t sub(m) : task constrained precede t}else T0 {t : task constrained precede t}repeatend SHOP2Figure 5: simplified version SHOP2 planning procedure.tail clause (or precondition operator method) contains negation,handled way Prolog: theorem prover takes (not a) truecannot prove a.3.1.5 External Function CallsExternal function calls useful, example, numeric evaluations (e.g.,ZenoTravel domain, check requirement available fuel must greaterequal product burn rate distance traveled). example,competition, SHOP2 used graph-algorithm library compute shortest pathsgraph. principle, would possible implement graph algorithms setmethods. However, writing external functions allows run faster, alsomakes possible access predefined code libraries.385fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman3.2 SHOP2 AlgorithmFigure 5 shows simplified version SHOP2 planning procedure. argumentsinclude initial state s, partially ordered set tasks , domain description D.mentioned earlier, SHOP2 plans tasks orderexecuted. order this, nondeterministically chooses taskpredecessors; first task SHOP2 start working on. point,two cases.first case primitive, i.e., accomplished directly using action(i.e., instance planning operator). case, SHOP2 finds actionmatches whose preconditions satisfied s, applies (if actionexists, branch search space fails).second case compound, i.e., method needs applieddecompose subtasks. case, SHOP2 nondeterministically chooses methodinstance decompose subtasks (if method instance exists,branch search space fails).solution plan involves m, actions P leaf nodesdecomposition tree DP tree shown Figure 2. precondition formulapre(m) must true state immediately precedes first action DPdescendant m. order ensure pre(m) true correct state, SHOP2 needsgenerate leftmost branch way bottom, evaluate pre(m)state a. last three lines loop ensure happen,telling SHOP2 current method subtasks, SHOP2 generate onesubtasks generating subtasks task network.example, SHOP2 could begin generating plan Figure 2 first decomposing(transport-two p1 p2) (transport p1) (transport p2), nondeterministicallychoosing decompose (transport p1) {(dispatch t1 l1), (pickup t1 p1), (move t1 l1l3)}. done that, SHOP2 would required decompose (dispatch t1 l11)decomposing (transport p2), order guarantee (dispatch t1 l1) (reserve t1)occur state world (available t1) evaluated. operator(reserve t1) makes t1 unavailable, thus ensuring (transport p2) decomposedlater, decomposition use truck t2 rather t1.3.3 Additional FeaturesSHOP2 several additional features addition basic ones described earlier.section describes significant ones.3.3.1 Sorting Variable BindingsSHOP2 evaluates methods precondition, gets list possible setsvariable bindings satisfy expression current state. set variablebindings lead different branch SHOP2s search tree. nondeterministic choiceimplemented SHOP2 via depth-first backtracking. SHOP2 find good solutionfind quickly, important decide set variable bindings try first.purpose, SHOP2 sort-by construct sorts list variable bindings specified criterion. especially useful planning problem386fiSHOP2: HTN Planning System(:method; head(transport-person ?p ?c2); precondition(:sort-by ?cost #<(and (at ?p ?c1)(aircraft ?a)(at ?a ?c3)(different ?c1 ?c3)(cost-of ?a ?c3 ?c1 ?cost))); subtasks((move-aircraft ?a ?c1)(board ?p ?a ?c1)(move-aircraft ?a ?c2)(debark ?p ?a ?c2)))Figure 6: Using sort-by SHOP2 method simplified ZenoTravel domain.optimization problem, e.g., problem objective find planleast possible cost. sort-by construct, write heuristic function estimateanticipated cost set variable bindings, sort sets variable bindingsaccording heuristic-function values SHOP2 try promising one first.example, precondition(and (at ?here) (distance ?here ?there ?d))may several different combinations ?here, ?there, ?d satisfyprecondition. expression(:sort-by ?d #> (and (at ?here) (distance ?here ?there ?d)))cause SHOP2 consider variable bindings decreasing order value ?d.complicated example, recall precondition method Figure 3.may several sets variable bindings satisfy precondition currentstate. reformulation precondition Figure 6 tells SHOP2 sort setsvariable bindings increasing order ?cost variable. way, SHOP2 look firstalternative lowest ?cost value.3.3.2 Branch-and-Bound OptimizationSHOP2 allows option using branch-and-bound optimization search leastcost plan. option generally results spending additional planning time ordersearch plans superior quality. using branch-and-bound option, one alsospecify time limit search. search takes longer time limit, SHOP2terminates search returns best plan found far; functionalitypartly inspired anytime algorithms (Boddy & Dean, 1989).387fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman3.3.3 PDDL Operator TranslationSHOP2s planning procedure proved sound complete across large setplanning problems, sense set methods operators capable generating solution problem, planning procedure guaranteed generatecorrect plan (Nau et al., 2001). However, proof tells us planningalgorithm work correctly domain description correct, tell uswhether domain description represents planning domain given setPDDL planning operators.AIPS-2000 planning competition, problem caused difficulty SHOP2spredecessor SHOP. SHOP team developing domain descriptions SHOP purelyhand, made mistakes writing two domains. Thus SHOP foundincorrect solutions problems domains, judges disqualifiedSHOP domains.developing SHOP2, wrote translator program translate PDDL operatorsSHOP2 domain descriptions. domain descriptions produced translatorprogram sufficient efficient planning SHOP2: need modifiedhand order put domain knowledge, described Section 4. However,translator program least provide correct starting point.3.3.4 Debugging FacilitiesSHOP2 also includes several debugging facilities. important tracingmechanism: one tell SHOP2 trace set operators, methods, axioms.example, Figure 8, given names (namely Case1 Case2) two differentclauses method. tell SHOP2 trace either clauses them;SHOP2 print messages time enters exits clause traced.Depending particular tracing options one selects, messages may includethings argument list, current state world, informationwhether operator, method axiom succeeds fails.3.3.5 Protected Conditions Anti-InterleavingSHOP2s planning operators include way specify protected conditions. featuredescribed briefly Nau et al. (2001), bother describeuse planning competition. cases wanted protectconditions possible threats, found convenient either make use flagssimilar available-truck flag Figure 1, use following anti-interleavingfeature SHOP2.method subtasks t1 , . . . , tk , ti begins keyword :immediate,tells SHOP2 plan ti immediately ti1 finishes, without tryinginterleave tasks ti1 ti . Several examples appear appendix.388fiSHOP2: HTN Planning Systemtask person: transport person his/her destination(these tasks unordered; thus subtasks may interleaved)task plane: transport plane destination(these tasks unordered; thus subtasks may interleaved)method transporting person:person already desired destination nothingelseselect planeplane persons current position movehold plane current positionboard person onto planemove plane destinationdebark person destinationmethod transporting plane:plane already desired destination nothingelse move plane destinationFigure 7: Abstract tasks methods simplified version ZenoTravel domain.4. Developing Domain Descriptions SHOP24.1 Basicsfirst step developing domain description SHOP2 formulate abstracttasks methods constitute reasonable problem-solving strategy. example,use simplified version ZenoTravel (one domains planning competition).problem transport people current locations destination,use available airplanes. Figure 7 shows set abstract tasks methodstransporting people moving airplanes.abstract strategy like one Figure 7, implementSHOP2 domain description consisting methods, operators axioms. example,method transporting person shown Figure 8. may onevalue ?p satisfies precondition (plane ?p). so, plane usenondeterministic branching point SHOP2. nondeterministic branching points,domain description may include heuristics guide SHOP2s search; Section 4.3discusses ways write heuristics.method transport-with-plane task, one preconditions whetherplanes fuel level enough get plane current position destination.Figure 4 shows axiom precondition.Actions, boarding people onto planes, debarking planes, refuelingplanes, modeled operators SHOP2. example, SHOP2 operatorboarding given Figure 9.389fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman(:method; head(transport-person ?person ?destination)Case1 ; label use debugging; preconditions(and (at ?person ?current-position)(same ?current-position ?destination)); subtasks()Case2 ; label use debugging; preconditions(and (at ?person ?current-position)(plane ?p)); subtasks((transport-with-plane ?person ?p ?destination)))Figure 8: SHOP2 implementation one methods Figure 7.(:operator; head(board ?person ?plane); preconditions(and (at ?person ?place) (at ?plane ?place)); delete list((at ?person ?place)); add list((in ?person ?plane)))Figure 9: SHOP2 operator simplified ZenoTravel domain.4.2 Writing Temporal DomainsSHOP2s operators least expressive Level 2 actions PDDL, SHOP2explicitly support durative actions Level 3 PDDL, SHOP2explicit mechanism reasoning durative concurrent actions.However, SHOP2 still enough expressive power represent durative concurrentactions, knows current state step planning process sinceoperators assign values variables numeric calculations. allowedus develop preprocessing technique call Multi-Timeline Preprocessing (MTP).MTP technique translating PDDL operators SHOP2 operators keep tracktemporal information current state.pseudocode Figure 10 algorithmic description MTP does.principle, MTP could automatedbut practice, always done hand,needs done planning domain.390fiSHOP2: HTN Planning Systemevery operator planning domainadd two parameters ?start ?durationos preconditionadd assignment ?durationformula calculating os durationadd assignment ?startformula takes maximum write timesdynamic properties os precondition read timesdynamic properties os effectsdynamic property p os effectsadd effects change value write-time(p) ?start +?durationdynamic property appearsadd effects change read-time(p) maximumread-time(p) ?start +?durationFigure 10: Multi-timeline preprocessing (MTP).keep description MTP simple, let us suppose state s, every atom(p c1 . . . cn ) represents single-valued property, i.e., one cn (p c1. . . cn1 cn ) true s. property dynamic operator may change value cn .example, initial state contains (at plane1 city1) operatormoves plane1 different location, location plane1 dynamic.property p changes time, MTP modifies operators keep track,within current state, times property changes timesvarious preconditions depend property. idea dynamic propertyp, current state contain two time-stamps: read-time(p), last timeaction read value p, write-time(p), last time actionmodified value p. MTP modifies operators way wheneveroperator reads (i.e., accesses) dynamic property, operator update propertysread-time, operator writes (i.e., modifies) dynamic property, updatepropertys write-time. Thus, instead single global time, current state containmany local times, namely read-time write-time dynamic property.MTP also inserts preconditions action ensure action beginsread-time property writes write-time propertyreads. prevents two actions overlapping time one writesproperty reads it. example, boarding operator fly operatorplane may overlap, boarding operator requires planelocated particular city fly operator changes location plane.Figure 11 shows one SHOP2 operators produced MTP ZenoTraveldomain. operator involves two dynamic properties: vehicles fuel level location.operator reads properties, may start write times.However, writes one (the fuel level), may start read timevehicles location. Thus refueling may performed concurrentlyactions depend vehicles location, cannot performed concurrentlyactions modify fuel level modify vehicles location.391fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman(:operator (!refuel ?plane ?city ?start ?duration); preconditions((aircraft ?plane)(city ?city)(at ?plane ?city)(fuel ?plane ?fuel-level)(capacity ?plane ?fuel-cap)(refuel-rate ?plane ?rate)(assign ?duration (/ (- ?fuel-cap ?fuel-level) ?rate))(write-time fuel ?plane ?t1)(write-time ?plane ?t2)(read-time fuel ?plane ?t3)(assign ?start (eval (max ?t1 ?t2 ?t3)))(assign ?end (eval (+ ?start ?duration)))(read-time ?plane ?t4)(assign ?new-value (eval (max ?t4 ?end)))); delete list((fuel ?plane ?fuel-level)(write-time fuel ?plane ?t1)(read-time fuel ?plane ?t3)(read-time ?plane ?t4)); add list((fuel ?plane ?fuel-cap)(write-time fuel ?plane ?end)(read-time fuel ?plane ?end)(read-time ?plane ?new-value)))Figure 11: sample SHOP2 operator produced MTP.4.3 Writing Domains Include Optimizationprevious planning competitions, planning benchmarks compared speedplanners length output plans, domain designers concentrated tryingfind reasonably short plan quickly possible. contrast, problemsyears competition included linear objective function needed optimized:best plan longer one minimizes number steps, insteadone minimized objective-function value. tried three approaches searchingoptimal plans:1. Structure SHOP2 methods way take SHOP2 more-or-less directlytoward plan minimizes objective function.2. Write methods, operators, axioms generate plans quickly, use sort-byfeature tell SHOP2 sort alternatives try promising ones first.3. Assign costs operators, use branch-and-bound search find bestplan within execution time limit.392fiSHOP2: HTN Planning Systemfirst approach works well easy tell alternative bestnode search space. example, know problem instancesobjective minimize total fuel used, perfect heuristic ZenoTraveldomain always use fly action instead zoom action. However, approachdoesnt work well isnt immediately obvious alternative best. example,objective minimize total time, naive approach would always usezoom action rather fly action, since zoom action faster. However,zoom action always best choice, requires fuel thus causedelays refueling.second approach extension first approach. Consider exampleZenoTravel domain objective minimize total fuel used. additionmaking planes fly instead zoom; using closer plane transport person alsoreduces total fuel used. set preference using sort-by feature SHOP2.precondition method transporting person sort available planesaccording fuel use order pick person. greedy approach.decision point sort alternatives cost, go alternativelowest objective-function value. Thus, approach guaranteed findoptimal solution. However, combined suitable heuristics, approach resultsnear-optimal plans. competition used technique extensively, producedsatisfactory plans even largest problems.third approach makes use branch-and-bound optimization, explained Section3.3.2. main idea quickly define methods let find plan maypoor quality let SHOP2 perform branch-and-bound search plan spacefind least cost plan best plan find within execution time limit.third approach, challenge setting cost operator.example, objective function requires minimizing total time, order takeconcurrency account, cost action always equal duration.example, suppose latest event current partial plan plane arriveairport time t, two passengers need board plane. needadd two boarding actions plan. Recall ZenoTravel domain, boardingactions take amount time, tb , performed concurrently. However,SHOP2 needs add actions plan one time. first boarding actionincrease total time tb , cost tb . However, second boarding actionincrease total time plan, cost 0. Now, suppose add refuel actionplan. action done concurrently boarding actions, costmax(0, tr tb ), tr time needed refuel.possible combine two approaches. However, experience, using optimization (the third approach) provide much benefit domaindescriptions already included two approaches. situations, SHOP2would frequently find optimal nearly optimal plan even without optimization,meant additional amount time needed branch-and-bound optimization wouldproduce little benefit. Branch-and-bound optimization would perhaps usefulplanning domains cost plan something sum costsoperators; however, domains occur planning competition.393fiNau, Au, Ilghami, Kuter, Murdock, Wu, & YamanInternational Planning Competition, use optimization approachofficial competition trial. competition domains, preliminarytesting SHOP2 optimization time limits, SHOP2 unable find solutionswithin amount time willing let run, except smallestproblems. One way overcome difficulty would use time limits,preliminary tests, never provided significant improvements cost across entireproblem set. One reason lack improvement spent great dealeffort crafting methods used competition. think third approach woulduseful cases immediately clear implement first twoapproaches, one want spend much time devising sophisticated domaindescription.5. Competition ResultsFourteen planning systems competed 2002 International Planning Competition.SHOP2 received distinguished performance award, one top four awards.SHOP2 (along TLPlan TALPlanner) one three planners solvedproblems hand-tailored fully automated tracks. SHOP2 ablesolve problems Strips, Numeric, HardNumeric, SimpleTime, Time, Complexdomains. SHOP2 solved problems planner competition:solved 899 904 problems, 99% success ratio.two hand-tailorable planners, TLPlan solved 894 problems, nearly manySHOP2. Since TALPlanner didnt numeric domains, solved 610 problems,still several hundred problems fully-automated planners solved.general, SHOP2 tended slower TALPlanner TLPlanner, althoughone domain (Satellite-HardNumeric) SHOP2 consistently fastest.speeds three hand-tailorable planners generally appeared polynomiallyrelated other, probably planners domain knowledge enabledfind solutions without much backtracking. three hand-tailorable plannersgenerally much faster fully-automated planners.None three hand-tailorable planners dominated two terms planquality. them, situations solutions significantly bettersignificantly worse two.6. Related Workfollowing subsections discuss HTN planning, ordered task decomposition,hand-tailorable planners participated competition.6.1 HTN PlanningHTN planning first developed 25 years ago (Sacerdoti, 1990; Tate, 1977).Historically, HTN-planning researchers focused practical applications.Examples include production-line scheduling (Wilkins, 1988), crisis management logistics (Currie & Tate, 1991; Tate, Drabble, & Kirby, 1994; Biundo & Schattenberg, 2001),planning scheduling spacecraft (Aarup, Arentoft, Parrod, Stader, & Stokes, 1994;394fiSHOP2: HTN Planning SystemEstlin, Chien, & Wang, 1997), equipment configuration (Agosta, 1995), manufacturabilityanalysis (Hebbar, Smith, Minis, & Nau, 1996; Smith, Hebbar, Nau, & Minis, 1997), evacuation planning (Munoz-Avila, Aha, Nau, Weber, Breslow, & Yaman, 2001), gamebridge (Smith, Nau, & Throop, 1998a, 1998b).development formal semantics HTN planning (Erol, Nau, & Hendler, 1994;Erol, Hendler, & Nau, 1996) shown strictly expressive classicalAI planning: problems expressed HTN planning problemsclassical planning problems.4 Even one places restrictions HTN planningrestrict expressive power classical planning, generally much easiertranslate classical planning problems HTN planning problems vice versa (Lotem,Nau, & Hendler, 1999).6.2 Ordered Task DecompositionOrdered task decomposition (Nau, Smith, & Erol, 1998) special case HTN planningplanning algorithm always builds plans forward initial state world.words, ordered-task-decomposition planner plans tasks ordertasks later performed. first applications ordered task decompositiontailor-made specific application domains. best known example codedeclarer play helped Bridge Baron win 1997 world championship computerbridge (Smith et al., 1998b).SHOP2 based SHOP (Nau et al., 1999), previous domain-independent orderedtask-decomposition planner requires subtasks method, also initialset tasks planning problem, totally ordered rather partially ordered.Thus SHOP, subtasks different tasks cannot interleaved. SHOP2 extends SHOPallowing subtasks method partially ordered. Experiments shownallow SHOP2 create plans efficiently SHOP, using domain descriptionssimpler needed SHOP (Nau et al., 2001). SHOP SHOP2available open-source software hhttp://www.cs.umd.edu/projects/shopi.6.3 TLPlan TALPlannerLike SHOP2, TLPlan (Bacchus & Kabanza, 2000) TALPlanner (Doherty & Kvarnstrom, 2001) competed hand-tailored track AIPS-2002 planning competition.TLPlan TALPlanner similar many respects. forward-chainingsearch apply planning operators current state generate successors. Thus, like SHOP2, know current state world every stepplanning process. control search, planners use control rules writtendeclaratively temporal logic. rules provide domain-specific knowledge tellplanner states bad states, planner backtrack try4. specifically, HTN planning Turing-complete: even undecidable problems expressedHTN planning problems. remains Turing-complete even restrict tasks logical atomspurely propositional (i.e., arguments all). contrast, classical planningrepresents planning problems solutions regular sets. Planners TLPlan (Bacchus& Kabanza, 2000) TALPlanner (Doherty & Kvarnstrom, 2001) overcome limitation classicalplanning extending formalism include function symbols.395fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yamanpaths search space. One difference TLPlan TALPlanner TLPlanuses linear modal tense logic, TALPlanner use TAL, narrative-based linear temporal logic used reasoning action change incompletely specified dynamicenvironments.main difference planners SHOP2 kind controlknowledge use: TLPlan TALPlanner use temporal formulas tellpart search space avoided, whereas SHOP2 uses HTN methods tellparts search space explored. SHOP2s search space consistsnodes reachable using HTN methods, whereas TLPlan TALPlannerexplore part search space avoids bad states successors.hard say type control knowledge effective. Bacchus Kabanza(2000) argue two types useful different situations combininguseful topic future research.7. Summary Conclusionsprimary difference SHOP2 HTN planners SHOP2 planstasks order executed, thus knows current statestep planning process. reduces complexity reasoning removinggreat deal uncertainty world, made easy us incorporate substantial expressive power SHOP2. addition usual HTN methodsoperators, SHOP2s domain descriptions may include axioms, mixed symbolic/numericconditions, external function calls. planning procedure Turing-complete,sound complete large class planning problems (Nau et al., 2001).Like HTN planning systems, SHOP2 plans decomposing tasks subtasks.key idea using HTN planner design set methods encode somethingakin standard operating procedures capture multi-step techniques refiningtask. kinds domain characteristics much natural express HTNformalism action-based formalism; see Lotem et al. (1999) descriptionissued involved.example, consider UM-Translog-2 domain, wrote use problemdomain AIPS-2002 planning competition (Wu & Nau, 2002). UM-Translog-2straightforward generalization UM Translog domain (Andrews, Kettler, Erol, &Hendler, 1995); generalizations include numeric information distances, fuelusage, forth. relatively straightforward formulate UM-Translog-2HTN planning domain. However, much difficult figure formulateUM-Translog-2 PDDL domain use competitors planning competition;task took several months accomplish.HTN planning systems, SHOP2s development originally motivated planning competition instead try solve practical planningproblems. example, JSHOP (a Java implementation SHOP2s predecessor SHOP)generative-planning component HICAP system planning evacuation operations (Munoz-Avila et al., 2001), currently incorporating SHOP2 HICAPreplacement JSHOP. pleased SHOP2s capabilities also gaveability excel International Planning Competition!396fiSHOP2: HTN Planning SystemAcknowledgmentswork supported part following grants, contracts, awards: Air ForceResearch Laboratory F30602-00-2-0505, Army Research Laboratory DAAL0197K0135, NavalResearch Laboratory N00173021G005, University Maryland General ResearchBoard. opinions expressed paper authors necessarilyreflect opinions funders.also wish thank anonymous reviewers, whose comments helped us makesignificant improvements paper.Appendix A. SHOP2 Domain Description ZenoTravel Domain(Numeric Version)AIPS-2002 Planning Competition, four different versions ZenoTraveldomain: Strips version, Numeric version, Simple Time version, Timeversion. developed SHOP2 domain descriptions four versions.follows domain description Numeric version ZenoTravel domain. operators domain description translated original PDDLcoding using rough approximation MTP process Figure 10.(defdomain ZENOTRAVEL((:- (same ?x ?x) ())(:- (different ?x ?y) ((not (same ?x ?y))))(:-(possible-person-in ?city)((person ?p) (at ?p ?city) (goal ?p ?city2)(different ?city2 ?city)))(:operator (!!cost ?end)((maxtime ?max)(assign ?newmax (eval (if (< ?max ?end) ?end ?max))))((maxtime ?max))((maxtime ?newmax))(- ?newmax ?max))(:method (board ?p ?a ?c)((write-time ?a ?start))((!board ?p ?a ?c ?start 1)(:immediate !!cost (call + ?start 1))))(:operator (!board ?p ?a ?c ?start ?duration)((person ?p) (aircraft ?a) (city ?c)(at ?a ?c) (at ?p ?c) (onboard ?a ?num)(read-time ?a ?pmax) (assign ?new-num (+ ?num 1))(assign ?newpmax (max ?pmax (+ ?start ?duration 0.01L0))))((onboard ?a ?num) (read-time ?a ?pmax) (at ?p ?c) (dest ?a ?c))((onboard ?a ?new-num) (read-time ?a ?newpmax) (in ?p ?a))397fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman0.001)(:method (debark ?p ?a ?c)((write-time ?a ?start))((!debark ?p ?a ?c ?start 1)(:immediate !!cost (call + ?start 1))))(:operator (!debark ?p ?a ?c ?start ?duration)((person ?p) (aircraft ?a) (city ?c)(at ?a ?c) (in ?p ?a) (onboard ?a ?num)(read-time ?a ?pmax) (assign ?new-num (- ?num 1))(assign ?newpmax (max ?pmax (+ ?start ?duration 0.01L0))))((onboard ?a ?num) (read-time ?a ?pmax) (in ?p ?a) (dest ?a ?c))((onboard ?a ?new-num) (read-time ?a ?newpmax) (at ?p ?c))0.001)(:method (refuel ?a ?c)((write-time ?a ?start) (read-time ?a ?pmax)(capacity ?a ?cap) (fuel ?a ?fuel)(eval (> ?cap ?fuel))(assign ?duration 1)(assign ?end (+ ?start ?duration 0.01L0))(assign ?newpmax (max ?pmax ?end)))((!!ra ((read-time ?a ?pmax))((read-time ?a ?newpmax)))(:immediate !refuel ?a ?c ?start ?duration)(:immediate !!cost ?end)))(:operator (!refuel ?a ?c ?start ?duration)((aircraft ?a) (city ?c) (at ?a ?c)(fuel ?a ?fuel) (capacity ?a ?cap))((fuel ?a ?fuel))((fuel ?a ?cap))0.001)(:method (zoom ?a ?c1 ?c2)((write-time ?a ?astart) (read-time ?a ?pmax)(distance ?c1 ?c2 ?dist)(fuel ?a ?fuel) (fast-burn ?a ?burn)(eval (>= ?fuel (* ?dist ?burn)))(assign ?duration 1)(assign ?start (max ?pmax ?astart))(assign ?end (+ ?start ?duration 0.01L0)))((!!ra ((write-time ?a ?astart) (read-time ?a ?pmax))((read-time ?a 0) (write-time ?a ?end)))(:immediate !zoom ?a ?c1 ?c2 ?start ?duration)(:immediate !!cost ?end)))(:operator (!zoom ?a ?c1 ?c2 ?start ?duration)((aircraft ?a) (city ?c1) (city ?c2) (onboard ?a ?num)(zoom-limit ?a ?limit) (eval (<= ?num ?limit))398fiSHOP2: HTN Planning System(at ?a ?c1) (distance ?c1 ?c2 ?dist) (fast-burn ?a ?burn)(total-fuel-used ?total-fuel)(assign ?new-total (+ ?total-fuel (* ?dist ?burn)))(fuel ?a ?fuel)(assign ?new-fuel (- ?fuel (* ?dist ?burn))))((at ?a ?c1) (total-fuel-used ?total-fuel) (fuel ?a ?fuel) )((at ?a ?c2) (total-fuel-used ?new-total) (fuel ?a ?new-fuel))0.001)(:method (fly ?a ?c1 ?c2)((write-time ?a ?astart) (read-time ?a ?pmax)(distance ?c1 ?c2 ?dist)(fuel ?a ?fuel) (slow-burn ?a ?burn)(eval (>= ?fuel (* ?dist ?burn)))(assign ?duration 1)(assign ?start (max ?pmax ?astart))(assign ?end (+ ?start ?duration 0.01L0)))((!!ra ((write-time ?a ?astart) (read-time ?a ?pmax))((read-time ?a 0) (write-time ?a ?end)))(:immediate !fly ?a ?c1 ?c2 ?start ?duration)(:immediate !!cost ?end)))(:operator (!fly ?a ?c1 ?c2 ?start ?duration)((aircraft ?a) (city ?c1) (city ?c2)(at ?a ?c1) (distance ?c1 ?c2 ?dist) (slow-burn ?a ?burn)(total-fuel-used ?total-fuel)(assign ?new-total (+ ?total-fuel (* ?dist ?burn)))(fuel ?a ?fuel)(assign ?new-fuel (- ?fuel (* ?dist ?burn))))((at ?a ?c1)(total-fuel-used ?total-fuel)(fuel ?a ?fuel))((at ?a ?c2)(total-fuel-used ?new-total)(fuel ?a ?new-fuel))0.001)(:operator (!!preprocessing ?problem-name)((totaltime-coeff ?tc) (fuelused-coeff ?fc)(eval (setf *tc* ?tc))(eval (setf *fc* ?fc)))()()0)(:operator (!!assert ?g )()()?g0)(:operator (!!ra ?D ?A )()?D?A0)399fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman;;;;;;;;; Main Methods;;;;;(:method (transport-person ?p ?c)Case1 ((at ?p ?c))())(:method (transport-person ?p ?c2)Case2 (:sort-by ?num #>((at ?p ?c1)(at ?a ?c1)(aircraft ?a)(onboard ?a ?num)))((!!assert ((dest ?a ?c1)))(:immediate board ?p ?a ?c1)(!!assert ((dest ?a ?c2)))(:immediate upper-move-aircraft-no-style ?a ?c2)(:immediate debark ?p ?a ?c2)))(:method (transport-person ?p ?c2)Case3 (:sort-by ?cost #<((at ?p ?c1)(aircraft ?a)(at ?a ?c3)(different ?c1 ?c3)(forall (?c) ((dest ?a ?c)) ((same ?c ?c1)))(imply ((different ?c3 ?c1))(not (possible-person-in ?c3)))(travel-cost-info ?a ?c3 ?c1 ?cost ?style)))((!!assert ((dest ?a ?c1)))(:immediate upper-move-aircraft ?a ?c1 ?style)(:immediate board ?p ?a ?c1)(!!assert ((dest ?a ?c2)))(:immediate upper-move-aircraft-no-style ?a ?c2)(:immediate debark ?p ?a ?c2)))(:method (upper-move-aircraft ?a ?c ?style)Case1 ((at ?a ?c))()Case2 ((at ?a ?somecity))((move-aircraft ?a ?somecity ?c ?style)))(:method (upper-move-aircraft-no-style ?a ?c)Case1 ((at ?a ?c))()Case2 (:sort-by ?cost #<((at ?a ?somecity)(travel-cost-info ?a ?somecity ?c ?cost ?style)))((move-aircraft ?a ?somecity ?c ?style)))400fiSHOP2: HTN Planning System(:- (travel-cost-info ?a ?from ?to ?cost slow)CASE1((capacity ?a ?cap) (distance ?from ?to ?dist)(slow-burn ?a ?burn) (eval (< ?cap (* ?dist ?burn)))(assign ?cost most-positive-fixnum))CASE2((distance ?from ?to ?dist) (fuel ?a ?fuel)(slow-burn ?a ?burn)(eval (>= ?fuel (* ?dist ?burn)))(assign ?cost (float (/(+ *tc*(* *fc*(* ?dist ?burn)))1))))CASE3((capacity ?a ?cap)(distance ?from ?to ?dist)(slow-burn ?a ?burn)(assign ?cost (float (/(+ (* *tc* 2)(* *fc*(* ?dist ?burn)))1)))))(:- (travel-cost-info ?a ?from ?to ?cost fast)CASE1((capacity ?a ?cap) (distance ?from ?to ?dist)(fast-burn ?a ?burn) (eval (< ?cap (* ?dist ?burn)))(assign ?cost most-positive-fixnum))CASE2((distance ?from ?to ?dist) (fuel ?a ?fuel)(zoom-limit ?a ?limit) (onboard ?a ?num) (eval (< ?num ?limit))(fast-burn ?a ?burn)(eval (>= ?fuel (* ?dist ?burn)))(assign ?cost (float (/(+ *tc*(* *fc*(* ?dist ?burn)))1))))CASE3((capacity ?a ?cap)(distance ?from ?to ?dist)(fast-burn ?a ?burn)(zoom-limit ?a ?limit) (onboard ?a ?num) (eval (< ?num ?limit))(assign ?cost (float (/(+ (* *tc* 2)(* *fc*(* ?dist ?burn)))1)))))401fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman(:method (move-aircraft ?a ?c1 ?c2 slow)((fuel ?a ?fuel) (distance ?c1 ?c2 ?dist)(slow-burn ?a ?burn)(eval (> ?fuel (* ?dist ?burn))))((fly ?a ?c1 ?c2))()((refuel ?a ?c1)(:immediate fly ?a ?c1 ?c2)))(:method (move-aircraft ?a ?c1 ?c2 fast)((fuel ?a ?fuel) (distance ?c1 ?c2 ?dist)(fast-burn ?a ?burn)(eval (> ?fuel (* ?dist ?burn))))((zoom ?a ?c1 ?c2))()((refuel ?a ?c1)(:immediate zoom ?a ?c1 ?c2)))(:method (transport-aircraft ?a ?c)((not (no-use ?a)))((!!assert ((no-use ?a)))(:immediate upper-move-aircraft-no-style ?a ?c)(:immediate !!ra ((no-use ?a)) ())))ReferencesAarup, M., Arentoft, M. M., Parrod, Y., Stader, J., & Stokes, I. (1994). OPTIMUM-AIV:knowledge-based planning scheduling system spacecraft AIV. IntelligentScheduling, pp. 451469. Morgan Kaufmann.Agosta, J. M. (1995). Formulation implementation equipment configurationproblem SIPE-2 generative planner. Proc. AAAI-95 Spring SymposiumIntegrated Planning Applications, pp. 110.Andrews, S., Kettler, B., Erol, K., & Hendler, J. (1995). UM Translog: planning domaindevelopment benchmarking planning systems. Tech. rep. CS-TR-3487,Dept. Computer Science, University Maryland.Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116.Biundo, S., & Schattenberg, B. (2001). abstract crisis concrete relief. preliminaryreport flexible integration nonlinear hierarchical planning. ProceedingsEuropean Conference Planning.Boddy, M., & Dean, T. (1989). Solving time-dependent planning problems. Sridharan,N. S. (Ed.), Proceedings Eleventh International Joint Conference ArtificialIntelligence, pp. 979984, Detroit, MI, USA. Morgan Kaufmann.Currie, K., & Tate, A. (1991). O-Plan: open planning architecture. Artificial Intelligence, 52 (1), 4986.402fiSHOP2: HTN Planning SystemDoherty, P., & Kvarnstrom, J. (2001). TALplanner: temporal logic based planner. AIMagazine, 22 (3), 95102.Erol, K., Hendler, J., & Nau, D. (1996). Complexity results Hierarchical Task-Networkplanning. Annals Mathematics Artificial Intelligence, 18, 6993.Erol, K., Nau, D., & Hendler, J. (1994). HTN planning: Complexity expressivity.AAAI-94.Estlin, T. A., Chien, S. A., & Wang, X. (1997). argument hybrid HTN/operatorbased approach planning. Proc. Fourth European Conference Planning (ECP97), pp. 184196.Gupta, N., & Nau, D. S. (1992). complexity blocks-world planning. ArtificialIntelligence, 56 (2-3), 223254.Hebbar, K., Smith, S., Minis, I., & Nau, D. (1996). Plan-based evaluation designsmicrowave modules. Proc. ASME Design Technical Conference.Lotem, A., Nau, D., & Hendler, J. (1999). Using planning graphs solving HTN problems.AAAI-99, pp. 534540.Munoz-Avila, H., Aha, D., Nau, D., Weber, R., Breslow, L., & Yaman, F. (2001). SiN:Integrating case-based reasoning task decomposition. IJCAI-2001.Nau, D., Cao, Y., & Munoz-Avila, H. (1999). SHOP: Simple Hierarchical Ordered Planner.IJCAI-99, pp. 968973.Nau, D., Munoz-Avila, H., Cao, Y., Lotem, A., & Mitchell, S. (2001). Total-order planningpartially ordered subtasks. IJCAI-2001, Seattle.Nau, D. S., Smith, S. J. J., & Erol, K. (1998). Control strategies HTN planning: Theoryversus practice. AAAI-98/IAAI-98 Proceedings, pp. 11271133.Sacerdoti, E. D. (1990). nonlinear nature plans. Allen, J., Hendler, J., & Tate, A.(Eds.), Readings Planning, pp. 162170. Morgan Kaufmann. Originally appearedProc. IJCAI-75, pp. 206-214.Slaney, J., & Thiebaux, S. (2001). Blocks world revisited. Artificial Intelligence, 125 (1-2),119153.Smith, S. J., Hebbar, K., Nau, D., & Minis, I. (1997). Integrating electrical mechanicaldesign process planning. Mantyla, M., Finger, S., & Tomiyama, T. (Eds.),Knowledge Intensive CAD, Vol. 2, pp. 269288.Smith, S. J., Nau, D. S., & Throop, T. (1998a). Success spades: Using AI planningtechniques win world championship computer bridge. AAAI-98/IAAI-98,pp. 10791086.Smith, S. J. J., Nau, D. S., & Throop, T. (1998b). Computer bridge: big win AIplanning. AI Magazine, 19 (2), 93105.Tate, A. (1977). Generating project networks. IJCAI-77, pp. 888893.Tate, A., Drabble, B., & Kirby, R. (1994). O-Plan2: Architecture Command, Planning Control. Morgan Kaufmann.403fiNau, Au, Ilghami, Kuter, Murdock, Wu, & YamanWilkins, D. E. (1988). Practical Planning: Extending Classical AI Planning Paradigm.Morgan Kaufmann, San Mateo, CA.Wu, D., & Nau, D. (2002). UM-Translog-2: planning domain designed AIPS-2002.Tech. rep. CS-TR-4402, UMIACS-TR-2002-82, University Maryland.404fiJournal Artificial Intelligence Research 20 (2003) 1-59Submitted 3/03; published 12/033rd International Planning Competition: ResultsAnalysisDerek LongMaria Foxderek.long@cis.strath.ac.ukmaria.fox@cis.strath.ac.ukDepartment Computer Information SciencesUniversity Strathclyde, Glasgow, UKAbstractpaper reports outcome third series biennial international planning competitions, held association International Conference AI PlanningScheduling (AIPS) 2002. addition describing domains, plannersobjectives competition, paper includes analysis results. resultsanalysed several perspectives, order address questions comparativeperformance planners, comparative difficulty domains, degree agreementplanners relative difficulty individual problem instances question well planners scale relative one another increasingly difficult problems.paper addresses questions statistical analysis raw resultscompetition, order determine results considered adequately supported data. paper concludes discussion challenges futurecompetition series.1. IntroductionBeginning 1998 international planning community held biennial event support direct comparison planning systems changing collection benchmarkplanning problems. benefits series events significant: fiveyears, planning systems developed capable solving large complexproblems, using richly expressive domain models meeting advanced demandsstructure quality solutions. competition series inspired many advancesplanning research community well increasingly empirical methodologygrowing interest application planners real problems.paper describe structure, objectives outcomes third competition,took place Toulouse 2002. competition colocated AI PlanningScheduling (AIPS) conference. conference brief report presentedresults achieved participating planners. begin presenting overviewmain results presented conference, showing number problems attemptedsolved planner identifying competition prize-winners. previousyears competition resulted collection large data set comprising data pointsseveral different domains. certain comparative understanding obtainedexamining data individual domains, conclusions drawn basis cannotgeneralised across domains. One goals paper try revealinsights cross boundaries domains allow general questionsanswered. include: planners reveal consistent, stable performancec2003AI Access Foundation Morgan Kaufmann Publishers. rights reserved.fiLong & Foxacross domains? benefit obtained exploiting hand-coded control knowledge?general agreement makes planning problem hard? particularplanning approaches best suited particular kinds problem domains?accepted scientific methodology addressing questions frame precisehypotheses prior collection data sets order control extraneousvariables might distort reality respect questions. datepractice planning community respect competitions.third competition proceeded, previous years, collecting data prior detailedconsideration specific questions wished answer. community yetagreed primary role competition provide carefully crafted platformscientific investigation planners: indeed, main roles far motivateresearchers field, identify new research goals thereby push forward researchhorizons, publicise progress wider community. However, competitionswinners natural tendancy draw conclusions competition datasets state art. conclusions scientifically supportedmisleading even erroneous. Therefore argument trying combinetwo objectives, although admittedly tension might makedifficult combine successfully.way planning competitions currently conducted,analyses describe paper post hoc. conducted analysesdata collected competition period: run experimentscompetition participants felt important datasubmitted competition comprise evidence judged.identified number analyses think provide interesting informationplanning community and, following sections, explore themerigorous way possible within constraints data disposal.difficult work fixed data set collected without precise experimentalquestions mind, unable test many hypotheses occurred usanalyses data inappropriate incomplete. However, despitelimitations data set believe able pose answerimportant questions comparative performances revealed competition.phrase objectives analyses terms null alternative hypthesesstandard approach applying statistical tests. approach partlyinspired earlier work Howe Dahlman (2002). work raised standardevaluation planners done compels planning communitydecide whether future planning competitions conducted way supportsgoals scientific investigation progress field.rest paper organised follows. begin discussing contextcompetition series general form third competition, includingdomains, competitors specific challenges raised. briefly summariseresults competition embarking detailed post hoc analysis competition results. analysis investigates relative performances planners, relativedifficulties problem sets used relative scaling behaviours competitorsacross domains levels. provide appendix present summariescompeting planners details domains used.2fiThe 3rd International Planning Competition2. International Planning Competition Seriesfirst event held conjunction fourth international Artificial IntelligencePlanning Scheduling conference (AIPS98). organised Drew McDermott,together committee senior members research community (McDermott,2000). event took time organise, evolving agreement formevent, kinds planning systems compared, basis comparisonon. final event became direct comparison 5 strips-based planners, twoplanners also attempting extended adl-based language (McDermott, 2000; Long,2000). systems included three Graphplan-based systems, one forward heuristic searchsystem one planning-as-satisfiability satsolver planner. important outcomefirst competition adoption pddl (McDermott & AIPS98 PlanningCompetition Committee, 1998) common representation language planning.Although opportunity offered competitors hand-code control knowledgeplanners, fact planners fully-automated ran probleminstances without priming. entire event staged conference periodfour days, involving intensive sessions generating checking solutionsattempting evaluate results. One idea tried, turnedproblematic practice, score planners performances using functionattempted take account time taken generate plan, length planrelative performance competitors problems. example,planner produced plan faster competitors would rewarded basedmuch faster average problem. attempt score plannersusing one-dimensional measure proved difficult, counter-intuitive results certaincases. end abandoned favour two dimensions: length plan timetaken produce it. decision indicates that, even five systems relativelysmall set problems, impossible make unequivocal decisions systembest. Nevertheless, community (and did) learn much data gathered,offering variety interpretations data, ultimately inspired improveevery way possible.second competition, chaired Fahiem Bacchus, 17 planners competed.increase participation ambitions larger scale testing required eventspread much longer period. fact, testing spread couple months,one final test carried conference site (AIPS00 Breckenridge).second competition formal split systems, small numberusing hand-coded control knowledge others fully-automated. alsosplit strips adl capable systems. larger number competitors includedwider range approaches: well Graphplan-based systems, forward heuristic searchsatsolver, several planners based model-checking approaches usingbdds, one using planning-by-rewriting. Again, proved difficult compare plannersunequivocally, several important observations could made: advantages handcoded control rules domains could seen clearly (as would expected), althoughremained important question difficulty generating writingrules. fully-automated planners, forward heuristic search approach provedparticularly successful, dominating performance domains. Pure Graphplan-based3fiLong & Foxplanning seemed reached zenith first two competitions longerappeared competitive.third competition (and recent time writing) held associationAIPS02 Toulouse. Fourteen planners participated. primary objectivecompetition help push forward research temporal resource-intensiveplanning. Extensions made pddl support modelling temporal numericdomain features. resulted pddl2.1 language (Fox & Long, 2003). extensivechanges pddl2.1 ambitious objectives competition help accountfact fewer people participated 2002 2000. again, real testinggathering data took place two months prior conference. Although initialresults presented conference, detailed analysis took place conferenceitself. rest paper examines objectives third competition, resultsfuture challenges series.3. Overview: Third International Planning Competitionorganisers Third International Planning Competition chose address severalnew challenges believe important ambitions planning community: management problems metric constraints numerically valued variables,temporal planning (including managing concurrency scheduling activities)construction plans subject specified optimisation criteria simple countnumbers steps.Setting goals obvious implications potential competitors termsextended expressive power additional problem-solving required manage extensions. order control extent competitors would required handleextensions successfully, constructed variants, levels, domainsused competition. domains included strips level, numericlevel (using strips metric variables only), simpletime level actionsduration metric values domain full temporal level, time,using durative actions durations determined context usage (so durationdepends parameter values action name). simpletimetime levels involve numeric resources time. address combinationintroduced additional domain variants, discuss below. four levelscorresponds particular degree expressive power pddl2.1, differentchallenges posed versions domain level.secondary goal assess relative effort generating encoding controlrules planners. Unfortunately, failed find way usefully quantify effort.discuss question following sections.3.1 Problem Domainsproblem domains selected competitions been, become, benchmarkdomains used much community empirical evaluation. domainsused often chosen probe specific detail performance.sometimes meant domains representative general features planning4fiThe 3rd International Planning Competitioninappropriate use widespread testing. description domainsused competitions far found Appendix A.third competition, eight families domains used, broadly dividedtransportation domains (Depots, DriverLog ZenoTravel), applications-inspired domains(Rovers Satellite) small collection others (Settlers, FreeCell UM-Translog2).briefly summarise collection describe detail Appendix A.Depots domain combines transportation style problem Logisticswell-known Blocks domain. Logistics domain exhibits high degree parallelism,since separate vehicles utilised concurrently. contrast, Blocks domaincharacterised significant goal interaction. intentiondiscover whether successes planners domains separately couldbrought together problems combined.DriverLog problem involves transportation, twist vehiclesmust supplied driver move.Zeno-travel Another transportation problem, inspired domain used testingzeno planner developed Pemberthy Weld (1994), people mustembark onto planes, fly locations debark, planes consumingfuel different rates according speed travel.Satellite domain inspired problem scheduling satellite observations. problems involve satellites collecting storing data using differentinstruments observe selection targets.Rovers domain motivated 2003 Mars Exploration Rover (MER)missions planned 2009 Mars Science Laboratory (MSL) mission. objectiveuse collection mobile rovers traverse waypoints planet,carrying variety data-collection missions transmitting data backlander. problem includes constraints visibility lander variouslocations ability individual rovers traverse particular pairswaypoints.Settlers domain revolves around management resources, measured usingmetric valued variables. Products must manufactured raw materials usedmanufacture transportation materials. New raw materialsgenerated mining gathering. objective construct variety structuresvarious specified locations.UM-Translog-2 domain pddl2.1 encoding new variant UMTranslog (Wu & Nau, 2002) domain. generated us Dan WuUniversity Maryland. essentially transportation domain, onesignificantly complex previous transportation benchmarks. fact,domain introduced late competition little data collected.therefore discussed paper.5fiLong & Foxalso reused Freecell domain second competition. domain presentedserious challenge participants 2000 interested see whether planningtechnology surpassed challenge intervening two years. Although domainproduced interesting data attempt precisely measure extent2002 performance surpassed 2000.domain (other Settlers, Freecell UM-Translog-2) presentedcompetitors least four different levels previously identified: strips, numericsimpletime time. problems presented levels comprised distincttracks competitors able choose tracks wished compete.addition four main tracks also included two additional tracks, intendedexplore particular ideas. tracks necessitate use additional expressivepower simply allowed existing expressiveness combined produce interestingplanning challenges. example, hardnumeric track consisted problemsSatellite domain logical goals. Plans evaluated metric basedamount data recorded rather determining whether specified logical goalachieved. challenge planners respond plan metric includeactions would acquire data. complex track consisted problems combinedtemporal numeric features. challenge reason resource consumptionparallel managing temporal constraints. total, defveloped 26 domains, 20problem instances domain (a few, unintentially, ended 16 22 instances).domains additional 20 instances large problems intendedhand-coded planners. total nearly 1000 problem instances solved,half intended primarily fully-automated planners.3.2 Competitorspopulation competing planning systems changed three competitions.systems competed system appeared three competitions. part, reflection speed development planning systems, revealingextent technology 1998 surpassed 2002. alsoreflection growing interest series, encouraged competitorscome forward, work involved taking part discouraged previouscompetitors repeating effort. Entering competition involves generating interesting efficient approaches solving planning problem: demandsability construct system respond robustly reliably confrontedpreviously unseen challenges, including domains amongst useddevelopment system. must sufficiently well-engineered performancedominated poor programming rather real algorithmic effort solvingproblem (careless choice data structure undermine opportunity showclever new planning algorithm). systems use hand-coded rules guideplanning system additional demand: time required read understanddomains sufficiently construct sensible control knowledge encode testknowledge achieve good performance. time-table testing relativelycompressed (the entire problem suite generated delivered competitorstwo month period testing carried remotely single machine), using6fiThe 3rd International Planning Competitionhand-coded controls forced find time analyse domains, hypothesise testrules intense sessions.Details competing systems found Appendix B. summarise, manyfully-automated planners use relaxed plan heuristics guide heuristic search.lpg (Gerevini, Saetti, & Serina, 2003) uses local search improve candidate plan structures formed Graphplan-style plan graph. Several planners (mips, ff sapa) alsoextend use relaxed plan heuristics include numeric features. vhpop partialorder planner, demonstrating partial-order planning competitiverecently fashionable heuristic forward state-space search planners. various reasons,several planners generated small collections results, disregardedanalysis.competitors used one version planner, oneparameter setting. attempt enforce use unique versions, leftcompetitors ensure informed variations used. Multiple versionsff, mips lpg used. ff submitted almost data version optimisedspeed performance. small subset data submitted version optimisedquality, showing alternative criteria performance evaluated.analyses report used data generated ff optimisedspeed exclusively. mips also offered data two variants, using slightly different parametersettings. analyses use data one variant (mips) exclusively, except caseSatellite hardnumeric problems used data variant(mips.plain). lpg submitted data three versions: one based earliest plan produced,one based best plan produced longer time span third representedcompromise speed quality. fact, since results versionoptimised quality generated within minutes most, chose use dataexclusively analyses follow. borne mind reviewingresults comparative speed performance planners. performance lpg reliescertain parameter settings. cases, parameters used lpg automaticallyset, cases parameters set hand. paper, appearingissue, Gerevini, Saetti Serena (2003) give new results experiment testingplanner parameters set automatically. general observe significantdifference performance lpg respect data provided competition.three hand-coded planners competed represent two alternative approachesplanning: forward state-space search using control rules prune bad choices promotegood choices, hierarchical task network (htn) planning.508 problems available fully-automated planners mipsplanner attempt them. 904 problems available hand-codedplanners shop2 planner attempt these, solving almostsolving problems overall. tlplan talplanner plannerssolved problems attempted. planners attempted problemsequipped handle. particular, sapa attempt strips problems, althoughcapable solving them.Although planning competitions great source data stateof-the-art planners encouragement catalyst progress field,also lively exciting competition events. means must winners.7fiLong & FoxPlannerFFLPGMIPSSHOP2SapaSemSynSimplannerStellaTALPlannerTLPlanTP4TPSYSVHPOPSolved237 (+70)372331899801191506108942614122Attempted284 (+76)428508904122144122102610894204120224Success Ratio83% (85%)87%65%99%66%8%75%49%100%100%13%12%54%Tracks enteredS, N, HNS, N, HN, ST,S, N, HN, ST, T, CS, N, HN, ST, T, CT, CS, NS, ST,S, N, HN, ST, T, CN, ST, T, CST,S, STFigure 1: Table showing problems attempted solved planners thirdIPC. Tracks S: strips, N: numeric, HN: hardnumeric, ST: simpletime, T:time C: complex. Note ff attempted 76 additional problems intendedhandcoded planners solved 70 successfully. IxTeT solved9 problems plans accepted validator attempted 10problems producing plans could validated due differencesplan syntax used IxTeT defined pddl2.1.8fiThe 3rd International Planning Competitionchoice winners left organisers must treated caution. summarisingresults AIPS conference Toulouse, presented table results formshown Figure 1, together selection graphs showing relative performanceplanners terms speed quality plans several problem sets. hardsynthesise comprehensive view short time final data collectionpresentation (a matter couple days, conference), initial assessmentsbased rather crude evaluation evidence. chose award prize lpgbest performer fully-automated planners: solved problems fullyautomated planners, showing excellent performance time tracks. also awardedprize mips solved second problems widest coveragefully-automated planners. clear ff produced exceptional performancenumeric level problems could well judged worthy prize that. choseacknowledge great difficulty newcomers competition building systemsufficiently robust compete, especially team programmersresearchers support effort. reason awarded prize vhpop bestnewcomer, creditable performance strips simpletime problems.Turning hand-coded planners, awarded prize best performance tlplan,tackled almost problems available, solved attemptedproduced plans high quality dramatic speed. also rewarded shop2fact attempted every problem produced plans planner.quality plans consistently good performance highly competitive.talplanner also performed outstandingly, often producing highest quality planstremendously efficiently, coverage restricted strips timetracks. selecting prize winners chose emphasise breadth coverage, particularlynew challenges handling numeric temporal planning problems. Competitionsdemand degree spectacle selection winners, measured evaluationplanners takes time. paper present various analyses data collectedcompetition leave community judge final rankings planners.3.3 Additional Challengeshardnumeric complex problems used competition easily fitanalysis conducted across results. problems raise interesting specialchallenges planners. discuss challenges, presenting data below.challenges explored one two problem sets, generalisationsperformance planners based data collected inappropriate.not, therefore, perform statistical analysis data, but, instead, present relevantdata simple graphical form.3.3.1 hardnumeric Satellite Problemshardnumeric Satellite problem instances contained logical goals almosttrivial. example, cases problems involved simply ensuringsatellites target specific observation site end plan. However, plan metricused evaluate plans far informative: plans evaluated accordingdata collected satellites execution. Simply satisfying explicit9fiLong & FoxSatellite-HardNumeric6000TLPlan (20 solved)SHOP2 (20 solved)MIPS (20 solved)FF (Speed) (20 solved)5000Quality40003000200010000024681012Problem number14161820Figure 2: Plan quality Satellite hardnumeric problems. High values betterquality plans: quality amount data collected.goals would generate correct plan, worthless one terms plan metric.fully-automated planners, mips ff tackled problems. tlplan shop2hand-coded planners attempted problems. instructive comparequalities plans produced four planners problem set. Figure 2shows quality plans produced hand-coded planners significantlyhigher quality plans generated fully-automated planners. Indeed, ffgenerates plans satisfy logical goals minimise plan size requiredachieve that, lead data collection. careful adjustments, mipsable generate plans collect data, clearly rather limitedresult. closeness results generated tlplan shop2 suggestsolving data collection problem level close optimal, applying similarheuristic approaches problem generating similar locally optimal solutions.domain clearly highlights advantage hand-coded planners exploitationknowledge human domain-engineer bring bear.3.3.2 Complex Satellite Domainaddition hardnumeric Satellite domain, complex Satellite domain alsoconsidered. complexity domain arises fact combines temporalactions, durations dependent parameters action, managementnumerically measured resources (in case, data store available acquired data).problem quality similar knapsack problem, datapacked limited stores appropriate satellites. combined temporaloptimisation problem, involves ensuring satellites efficiently deployed,10fiThe 3rd International Planning CompetitionSatellite-Complex2000MIPS (8 solved)TLPlan (20 solved)SHOP2 (20 solved)Sapa (16 solved)LPG (Quality) (20 solved)180016001400Quality120010008006004002000024681012Problem number14161820Figure 3: Plan quality Satellite complex problems. Low values represent betterplans, since quality measures makespan, minimised.moving targets capturing data according capabilities, currentaspects available store. seen Figure 3, planners fullyautomated hand-coded produced plans quite widely varying quality (lower valuesbetter, here, since quality measured makespan). general, tlplan producedbest quality plans, although lpg also produced high quality plans smallerproblems. seen problems 13, 16, 19 20, particularly, fully-automatedplanners occasionally produced plans quality diverging significantly optimal(we actually know optimal values problems,obviously consider best value produced upper bound optimal value).3.3.3 Settlers DomainSettlers domain based resource-management computer games, resourcesmust accumulated used construct new resource centres, new specialisedproduction capabilities. interesting problem domain highlightspddl2.1 family languages offer convenient way name objectscreated execution plan. version used competition, overcameproblem selection names available outset initiallycommitted role. object constructed, unallocated name usedname it, assigning name properties new object marking nameused. important problem approach creates current plannersinitial grounding actions involves creating possible ways namescould assigned objects used various roles within plan. leadssignificant explosion size domain encoding. interesting observe11fiLong & Fox6 20 problems solved (fully-automated) planner, ffsolved one problem. clear domain remains challenge planningtechnology, also future development pddl2.1 necessaryreview way object construction modelled.4. Analysis Competition PerformanceOne important roles competition identify state art field,terms variety measures, attempt answer broad questionslandscape research area. course, competition cannot last wordstate art. might state art planning systems prevented,whatever reason, taking part competition. However, competitionprovide useful insights capabilities modern planning systems.Planning performance measured terms speed solution problemsnumber quality solutions found. metrics might also identified.different planning architectures heuristic evaluation functions welldifferent kinds domains problems. state art represented specificexemplars architectures heuristic functions interesting exploresuitability different architectures use different domains, scaling behaviourparticular approaches, comparative performance different planning systems, etc.address issues following sections.perform three collections analyses ascertain comparative performance basedconsideration raw speed quality data, extent domain influenced plannerbehaviour scaling behaviour planners. first collection comparisonplanners based raw competition performance. analyse datapoint view consumer interested ranking planners according speedplan quality. experiments aimed answering coarse level questionsform: planner buy? asking questions trying arrivegeneral basis comparison. course, investigation question constrainedmetrics used competition. Furthermore, trade-off one makes timequality depends context planner might deployed. Therefore,cannot combine judgements relative speed relative plan quality performancedetermine unequivocally planner buy. take basic assumption potentialusers domain-independent planning technology interested primarily broad coveragegood behaviour across wide variety domains, rather restricted coveragespectacular behaviour domains. raw performance analysesbased mainly Wilcoxon rank-sum matched-pairs test (see Appendix C), explainedbelow. advantage test non-parametric, meaning relyassumptions shapes properties underlying population distributions.also robust outliers.second collection experiments concerned identifying whetherdomains significantly easier (or harder). perform experimentslevels problems used competition determine whether agreementamongst planners difficulty problems. part, assists us goingexplore scalability issues also allows us determine whether problem12fiThe 3rd International Planning Competitionset presented competition contained interesting challenges. third collectionexperiments compares way planners scale problem sets agreeproblem difficulty.4.1 Raw Performance Analysisperform pairwise comparisons planners ascertain whether consistentpattern identified relative speed plan quality. focus first comparingfully-automated planners and, separately, hand-coded planners. performadditional set analyses try determine raw performance benefit obtaineduse hand-coded control knowledge. this, perform Wilcoxon test pairscrossing boundary fully-automated hand-coded planner groupings.conclusion improvement obtained significant, saycontrol rules yield improvement performance. cannot account price,terms effort encode rules, must paid obtain improvement.understanding involved writing useful control knowledge still anecdotalremains important challenge community quantify precisely. Oneimportant consequence use hand-crafted control knowledge speakplanner performance blurs distinction planning systemcontrol rules produced support performance domain.planner performs well impossible separate contributions planningsystem, architecture system (and extent contributes easeexpressing good control rules) sophistication control rulesused. attempt distinguish planner control rules analysisfollows, least one competitor observed results would significantlyworse less time prepare, while, given time, results couldimproved concentrating optimisation plan metrics rather simplymakespans. observation helps highlight fact that, planners exploiting handcoded control knowledge, competition format seen highly constrainedbasis evaluation performance.summarise, present hypotheses exploring section:Null Hypothesis: basis pairwise distinctionperformances planners terms either time taken plan quality(according specified problem metrics) plans produced.Alternative Hypothesis: planners partially ordered termstime performances and, separately, quality performances.4.2 Analytic Frameworkperform pairwise comparisons, planners fully-automated hand-codedgroups, problems main four problem levels used competition.include analyses complex hardnumeric tracks resulteddata points meaningful statistical conclusions drawn. performWilcoxon rank-sum matched-pairs tests identify whether number times one plannerperformed better indicates significant difference performance13fiLong & Foxtwo. performed pairwise comparisons performances tracksuse results construct partial orderings speed quality performancesplanners tracks. use 0.001 significance level wishextrapolate collections pairwise comparisons infer confidence, p = 0.05level, transitive relationships planners. strips track,largest, perform 15 pairwise comparisons confidence level 951/15 = 0.003required transitive picture. use confidence level 0.001, resultingslightly conservative analysis.use sufficiently large samples T-distribution, used Wilcoxon test,approximately normal. therefore quote Z-values indicate significancedifferences mean performances paired planners. comparepairs planners: cases superiority planner another clearexamination raw data statistical testing obviated.Wilcoxon test tells us one planner performs consistently better anotherwhether consistency statistically significant. tell us much betterone planner another. could little difference performanceperhaps discrepancy accounted mere implementation differences.consistency difference occurs determines whether statisticallysignificant discrepancy performances planners. One planner performconsistently better another even though wins time. example,comparison B, planner might win frequently Bfaster solving subset problems set even though much slower solvinganother subset problems. Provided subset B sufficiently largegreater number wins due emerge significant. example, set 10problems ranked according differences performance, first 7 problemsranking last 3 B, obtain score 28 B score 27.case significant difference emerges regardless magnitude differenceB last three problems (see Appendix C). rank-sum approachbenefit allowing large numbers small wins outweigh small numbers large wins.desirable large win problems indication overall betterperformance. interested trying measure consistency domain-independentbehaviour therefore comparing consistency performance across domains givenplanners perform differently within domains.size win need indicate complexity underlying problemallow us make judgements scalability. Essentially test revealsconsistent patterns performance across range problems. considerinterest knowing one planner significantly consistently better anotherhelps us make objective judgement two planners performing betteracross varied problem set. variability performances consistentpattern emerges, hard perhaps impossible make judgement objectively.cases, comparison using Wilcoxon test lead statisticallysignificant conclusions, proportion wins one planners higherconsistent null hypothesis equal performance. tested using Z-testproportion (see Appendix C). test yields significant result report it,14fiThe 3rd International Planning Competitiondescribed below. test less informative Wilcoxon test takeaccount wins distributed problem set.performing pairwise comparisons must deal cases plannersolve problem. assign infinitely bad speed planner cases, ensuringmaximum possible benefit given planners solving problems, even slowly.methodology valid Wilcoxon test based rank effect simplypush unsolved cases extreme ranking. case quality performinitial collection tests using infinitely bad quality unsolved problems.somewhat difficult decide means compare true quality resultinfinitely bad quality assigned planner produced solution. conclusioncomparison may informative enough, addition perform Wilcoxontest cases planners produced plan. refer casesdouble hits.4.3 Results Analysisresults performing Wilcoxon tests, order compare speed performance fully-automated planners, shown Figure 4. results similar testscompare plan quality presented Figures 5 6. double hits data presentedFigure 6. corresponding tests hand-coded planners shown Figures 78.tables rows corresponding four problem levels competitiongathered sufficient data analysis. are: strips, numeric, simpletime time.many results fully-automated planners strips domainssplit two rows, creating five rows tables. comparisons plan qualityreport strips results using sequential plan length concurrent plan length separately.data rows interpreted following way. cell, representing pairplanners compared, presents Z-value corresponding p-value identifiedWilcoxon statistical table. order planners names title cellsignificant: first planner named one favoured comparison. Underneathcell entry indicating size sample used. sample consistsproblems least one planners compared produced solution:results different sample sizes different comparisons. p-valuegreater 0.001 difference mean performances obtained competingplanners statistically significant concluded planner columnsignificantly out-performing competitor. p-value greater 0.001 differencesignificant, terms transitive view interested, nullhypothesis planners performing roughly equally cannot rejected. indicateabsence significance p < 0.001 level use bold font.Wilcoxon test tells us significant difference mean behaviouridentify planner producing greater proportion wins casesmean behaviour insignificantly different. Therefore, Wilcoxon tests reportssignificant difference pair planners also report Z-valueproportion (see Appendix C), significant, provide missing information.15fiLong & FoxStripsFF-LPG6.2?120LPG-MIPS5.3?118LPG-Sim1.90.06118Sim-MIPS1.9 (3.1)0.06 (?)114MIPS-VHPOP3.4?98VHPOP-Stella0.110.9259StripsSim-Stella7.2?83LPG-VHPOP7?117FF-MIPS8.9?117FF-Sim7.8?117MIPS-Stella4.7?80Sim-VHPOP4.3?108FF-LPG3.5?93LPG-MIPS3.8?86SimpleTimeLPG-MIPS5?100MIPS-VHPOP20.0468VHPOP-TP45.9?54LPG-TP48.4?100MIPS-TPSYS5.9?47TP4-TPSYS2.6< 0.0114TimeLPG-Sapa3.3?95MIPS-Sapa0.720.6772LPG-MIPS3.4?96MIPS-TP45.1?36Sapa-TP45.2?38NumericFF-MIPS8?85Figure 4: Table showing results statistical tests comparison speeds planners.Bolded results significant p = 0.001 level. cellrepresents pair planners compared. presents Z-value corresponding p-value identified Wilcoxon statistical table. orderplanners names title cell significant: first planner namedone favoured comparison. Underneath cell entry indicatingsize sample used. ? indicates result less 0.001.16fiThe 3rd International Planning CompetitionStrips(Seq)LPG-FF0.210.84120LPG-MIPS6.9?118LPG-Sim7.6?118MIPS-Sim0.380.7114Strips(Seq)Sim-Stella5.6?83LPG-VHPOP7.7?117FF-MIPS7.2?117FF-Sim8.5?117LPG-FFMIPS-VHPOP1.30.2198VHPOP-Stella2.1 (3.3)0.04 (?)59MIPS-Stella5?80Sim-VHPOP0.450.65108Strips(Conc)6?120LPG-MIPS5.3?118LPG-Sim8.6?118MIPS-Sim2.4 (4.1)0.01 (?)114MIPS-VHPOP0.690.4998VHPOP-Stella0.930.3559Strips(Conc)Sim-Stella2.10.0383LPG-VHPOP5.2?117FF-MIPS1.40.16117FF-Sim8.5?117MIPS-Stella3.7?80VHPOP-Sim0.130.90108NumericLPG-FF3 (4.5)< 0.01 (?)93LPG-MIPS6.1?86FF-MIPS3.5?85SimpleTimeLPG-MIPS8.7?100MIPS-VHPOP2.4 (3.5)0.01 (?)68VHPOP-TP45.4?54LPG-TP48.6?100MIPS-TPSYS5.6?47TP4-TPSYS2.7< 0.0114LPG-Sapa6.7?95Sapa-MIPS0.0290.9972LPG-MIPS6.6?96LPG-TP46.6?57MIPS-TP4Time5?36Sapa-TP45.2?38Figure 5: Table results statistical tests comparisons plan quality across problemssolved least one planner pair. Bolded resultssignificant p = 0.001 level. ? indicates result less 0.001.17fiLong & FoxStrips(Seq)LPG-FF0.240.83114LPG-MIPS4.3?85LPG-Sim5.9?90MIPS-Sim1.40.1663VHPOP-MIPS2.9< 0.0156VHPOP-Stella4.7?39Strips(Seq)Sim-Stella1.80.0849LPG-VHPOP3.6?68FF-MIPS4.6?86FF-Sim7.1?91MIPS-Stella3.1< 0.0144VHPOP-Sim5.2?51Strips(Conc)LPG-FF6.5?114LPG-MIPS1.50.1485LPG-Sim7.5?90MIPS-Sim6.3?63VHPOP-MIPS3.9?56VHPOP-Stella2.7< 0.0139Strips(Conc)Stella-Sim6?49VHPOP-LPG3< 0.0168MIPS-FF4.8?86FF-Sim7.1?91MIPS-Stella0.240.8344VHPOP-Sim6.1?51LPG-FF3.8?69LPG-MIPS3.2?46MIPS-FF4.2?50SimpleTimeLPG-MIPS6.6?58MIPS-VHPOP2.9 (3.8)< 0.01 (?)44TP4-VHPOP3.4?15LPG-TP41.30.1915TPSYS-MIPS0.610.5410TP4-TPSYS1.80.0710TimeLPG-Sapa4.7?62MIPS-Sapa1.60.0950LPG-MIPS4.2?55LPG-TP41.90.065TP4-MIPS1.10.275TP4-Sapa1.30.195NumericFigure 6: Table showing results statistical tests comparisons quality planspairs planners considering problems solved planners.cell represents pair planners compared. presents Z-valuecorresponding p-value identified Wilcoxon statistical table. orderplanners names title cell significant: first planner namedone favoured comparison. Underneath cell entry indicatingsize sample used. ? indicates result less 0.001.18fiThe 3rd International Planning CompetitionSmall ProblemsStripsNumericTL-TAL6.8?102TAL-SHOP20.0280.99102Large ProblemsTL-SHOP27.2?102TL-SHOP26.5?102TAL-TL5.6?98TAL-SHOP28.5?98TL-SHOP28.2?98TL-SHOP27.9?98SimpleTimeTL-TAL8.7?102SHOP2-TAL0.610.34102TL-SHOP27?102TL-TAL0.770.4498TAL-SHOP26.4?98TL-SHOP28.4?98TimeTL-TAL8.8?102TAL-SHOP20.20.84102TL-SHOP27.8?102TL-TAL3.1?98TAL-SHOP27.3?98TL-SHOP28?98Figure 7: Table showing results statistical tests comparison speeds handcoded planners. ? indicates result less 0.001.Small ProblemsLarge ProblemsStrips(Seq)TL-TAL2.30.01102TAL-SHOP220.04102TL-SHOP25.3?102TAL-TL0.890.3898TAL-SHOP24.4?98TL-SHOP23.6?98Strips(Conc)TAL-TL8.6?102TAL-SHOP24.3?102SHOP2-TL7?102TAL-TL8.6?98TAL-SHOP27?98SHOP2-TL7.7?98NumericTL-SHOP20.180.86102TL-TALSimpleTime10.32102TL-TAL4?Time102TL-SHOP20.150.8898TAL-SHOP24.5?102TL-SHOP25.3?102TAL-TL0.760.4498TAL-SHOP25.5?98TL-SHOP25.4?SHOP2-TAL0.260.80102TL-SHOP23.9?102TL-TAL2.30.0198TAL-SHOP20.540.5898TL-SHOP25.7?98Figure 8: Table showing results statistical tests comparative quality plans producedhand-coded planners. table shows results problems solved leastone planners results restricted problems solved insignificantly different, since hand-coded planners solved almost problemsattempted. ? indicates result less 0.001.19fiLong & FoxZ-value proportion, p-value, appear brackets followingWilcoxon result.4.4 Interpretationresults show null hypothesis rejected. Therefore, adopt alternative hypothesis discuss resulting partial orders inferred data.data presented Figures 4 8 interpreted terms partial orderingsspeed quality performances fully-automated hand-coded plannersfour problem levels. done, level, simply putting orderingpairs planners B Wilcoxon value pair reportedsub-column associated significant 0.001 level. resultsshown Figures 9 12. figures sub-graphs associatedfour problem levels identified. presence arrow graph indicatesstatistically significant ordering exists. absence arrow B indicatesstatistically significant relationship B found correspondingproblem level therefore transitive ordering depend relationship.4.4.1 Partial orderings based speedFigure 9 describes speed comparisons made fully-automatedplanners according Wilcoxon test. observed ff significantly consistently faster fully-automated planners strips numeric levels (thesignificance arrows figure sufficient support transitive reasoning).Indeed, strips numeric levels interesting linear ordering ff,lpg, mips vhpop (three prize-winners amongst fully-automatedplanners) maintained lpg, mips vhpop simpletime level. Despite observation simplanner faster, significant proportion stripsproblems mips, significant Wilcoxon relationshipfour prize-winners comprise spine performance around plannerscompeting levels clustered. relationship breaks time level lpg, mips, sapa tp4 participated. data set seen mipssapa indistinguishable, respect Wilcoxon test, lpg significantlyconsistently faster both.comparing hand-coded planners competition used collection small problems collection large problems problem level. large problemsbeyond capabilities fully-automated planners. Interestingly, handcoded planners behaved differently small large problem collections.marked Figure 10, strips level, performances tlplantalplanner inverted small large problem sets. small simpletimetime problems tlplan consistently faster either talplanner shop2,talplanner shop2 statistically indistinguishable data sets. tlplanalso consistently faster talplanner, turn consistently faster shop2,large time problems.20fiThe 3rd International Planning CompetitionnumericLPGFFVHPOPMIPSSIMPLANNERTP4simple timeTPSYSSTELLAstripskey:Bconsistently faster B.Bfaster B significant numbertimes.SAPALPGTP4MIPStimeFigure 9: partial order fully-automated planners terms relative speedperformances.TALTLSHOP2strips (small)TLSHOP2TALTLSHOP 2TALstrips (large)simple time (large)TALTLTLnumeric(small,large)TALSHOP2SHOP2time (large)simple time, time (small)Figure 10: partial order hand-coded planners terms relative speedperformances.21fiLong & Fox4.4.2 Partial orderings based qualityconstruction partial order quality performance strips levelfully-automated planners shown Figure 11. interpret figures depicting qualityperformance noted that, problem levels except strips, specific qualitymetrics provided plan quality must measured terms metrics.strips level metrics provided quality measure plan length eithersequential concurrent. figures labelled arrows strips graphsdenote whether relationship exists terms sequential concurrent ordering,both. ordering sequential concurrent quality arrow leftunlabelled. observed two planners might ordered one directionsequential length concurrent length.indicated above, comparison quality performance made difficult onetwo planners compared solved many problems (this problemarises fully-automated planners hand-coded planners failed solveproblems proportion unsolved problems affect tests). Usinginfinite quality measure unsolved problems Wilcoxon test concludes plannersolving problems overall better quality words, one interestedoverall solution quality one choose planner solves problems evenif, cases, produces worse quality plans competitor. However, alsowant understand relationship two planners double hits case.notice consideration problems sometimes inverts relationship detectedfirst test. example, Figure 11 observed that, simpletimelevel, vhpop consistently produced better quality plans tp4 across whole problemset but, double hits considered, tp4 produced consistently better plansvhpop. suggests tp4 solving problems higher quality solutions,price pays search find solutions high solves much smallerset problems planners, vhpop. depict results using dottedarrows graphs. Finally, arise Wilcoxon test detects significantrelationship two planners, difference proportion problemssolved two planners significant. indicate resulting weaker relationship usingdashed arrow.Figure 11 shows lpg emerges fully-automated planner consistently producinghighest quality plans problem levels. relationship ff mipscomplex because, whilst ff produced plans better sequential quality mips,mips produced better quality concurrent plans ff considering double hits.reason apparent discrepancy mips post-processes sequential planspartially ordered plans exploiting available concurrency problem,ff exploit. However, fails solve larger subset problems ff, givingff advantage quality overall.strips problems simplanner solves problems stella henceseen performing consistently higher sequential-plan quality level. doublehits considered stella outperforms simplanner concurrent-plan quality. Also,double hits considered, seen vhpop consistently outperforms stella22fiThe 3rd International Planning CompetitionLPGFFMIPSFFnumericconcLPGMIPSTPSYSseqLPGconcVHPOPSIMPLANNERTP4simple timeMIPSconcSAPAseqconcVHPOPseqTP4LPGMIPStimeSTELLAkey:B consistently betterB.with confidenceleast 99.9%.seqstripsB produces better planssignificantly oftenB.Bconsistently betterB double.hits considered.Figure 11: fully-automated planners depicted terms relative quality performances.strips (small)seqTLTALconcSHOP2concTLconcseqconcTALSHOP2seqstrips (large)TLSHOP2TLTALTALSHOP2simple time (small, large)time (small)Figure 12: hand-coded planners depicted terms relative quality performances.23fiLong & Foxsequential-plan quality simplanner cases. Interestingly, vhpop stellaWilcoxon proportion test relationship problems considered.mips outperforms vhpop tpsys simpletime problems, vhpop consistently better tp4. double hits considered tp4 outperforms vhpopdemonstrating tp4 produces better quality solutions problems solves.Given available data seems tp4 tpsys performing significantly differently, may data set small draw conclusion confidence.time data set significant consistent pattern relative performancessapa mips. lpg consistently produces better quality plans.fully-automated planners find speed comparisonsobserved hold planners compared terms quality. Figure 12 showsquality comparisons performed three competing hand-coded planners.shows that, small strips problems tlplan consistently outperformed shop2 termssequential plan quality. small problems talplanner produces shorter makespanplans tlplan shop2 shop2 produces shorter makespan planstlplan. tlplan produces sequential strips plans use post-processingstep introduce parallelism. result certain outperformed makespancomparison planners capable producing parallel plans.significant relationships emerged numeric problems. talplannercompete numeric problems. significant Wilcoxon result established.simpletime problems (both small large) quality performances tlplantalplanner indistinguishable, consistently better shop2.time problems tlplan emerges consistently better talplanner shop2.4.4.3 Cross-boundary partial orderingsperformed final collection comparisons try better understand advantagesobtained use hand-coded rather fully-automated planners, termsspeed quality. compare best-performing fully-automated plannerbest-performing hand-coded planner categories: ff tlplan speed,levels, lpg talplanner strips level, shop2 numeric leveltlplan remaining problem levels, quality.tables Figures 14 15 show results tests. Figure 13 summarisesconclusions. observed tlplan consistently faster ff problemlevels participated, demonstrating control knowledgeexploited tlplan giving real speed advantage. remains seen exactlycase, given several strips domains control knowledgeusually described encoded appears prune additional statesalready pruned ff-style heuristic measure used. reason added valueinteresting question community consider trying evaluate advantagesdisadvantages hand-coded approach.also observed talplanner produces consistently better concurrent planslpg strips level. Again, result needs explained in-depthanalysis control information exploited talplanner. simpletimelevel lpg produces plans consistently better quality tlplan.24fiThe 3rd International Planning CompetitionTLLPGFFlevels (speed)simple time (quality)Key:TALconcTLBconsistently faster/better quality BNotes:significant quality difference FF TLplan STRIPS level.significant difference SHOP2 LPG numeric level.significant difference TLPlan LPG time level.LPGstrips (quality)Figure 13: comparison best fully-automated planners besthand-coded planners problem level.StripsTLPlan-FF6.7< 0.001102NumericSHOP2-LPG8.2< 0.001102SimpleTimeTLPlan-LPG8.6< 0.001102TimeTLPlan-LPG8.7< 0.001102TAL-LPG7.8< 0.001102TAL-VHPOP8.5< 0.001102Figure 14: Table results comparisons fully-automated hand-coded plannersterms speed. cell represents pair planners compared.presents Z-value corresponding p-value identified Wilcoxonstatistical table. order planners names title cellsignificant: first planner named one favoured comparison.Underneath cell entry indicating size sample used.25fiLong & FoxProblems solved least oneProblems solvedStrips(Seq)TLPlan-FF0.570.57102LPG-TAL1.8 (3.9)0.08 (< 0.001)102TAL-VHPOP2.9< 0.01102FF-TLPlan0.350.7297LPG-TAL2.4 (4.2)0.01 (< 0.001)99VHPOP-TAL4.9< 0.00167Strips(Conc)TLPlan-FF0.570.57102TAL-LPG5.9< 0.001102TAL-VHPOP6.4< 0.001102FF-TLPlan0.350.7297TAL-LPG5.6< 0.00199TAL-VHPOP2.6< 0.0167NumericSHOP2-LPG1.90.06102LPG-SHOP21.60.1183SimpleTimeLPG-TLPlan3.9< 0.001102LPG-TLPlan4.3< 0.001100TimeTLPlan-LPG0.0930.92102LPG-TLPlan1.60.1193Figure 15: Table results comparisons plan quality fully-automatedhand-coded planners.interesting observe hand-coding control information appear leadconsistent improvement plan quality across data sets. seem leadspeed advantage must indicate that, general, control rules provide basisefficient pruning weak general heuristic measures. Wilcoxon testmeasure extent speed advantage obtained, measure extentquality advantage obtained using fully-automated planner preference.trade-offs need close analysis, interesting see factuniform advantage obtained hand-coded planners, least smaller problemsformed common foundation testing. course, development hand-codedcontrol knowledge prioritise different aspects solutions generated possibledevelopment control rules might support construction heavilyoptimised plans.5. Tests Magnitudecomplement Wilcoxon tests perform additional analyses identify whether,given two planners compared, magnitude difference performancetwo planners statistically significant. perform paired t-tests (see Appendix C)using subset pairs planners. focus attention pairs consistent significant differences identified, consider meaningfulcompare magnitude results planners consistent domination exhibited.also restrict attention planners were, according Wilcoxon tests,26fiThe 3rd International Planning Competitionimpressive performers competition levels. perform separate testsspeed quality.investigating magnitude differences performances meaningfulinclude problems solved one planners compared. Usinginfinite time quality measures would result magnitude value would grosslydistort true picture. magnitude tests therefore consider double hits.price pay give undesirable emphasis smaller easierproblems since ones frequently solved planners.borne mind interpreting data.hypotheses considered section are:Null Hypothesis: consistent magnitude difference performances planners.Alternative Hypothesis: Planners demonstrate significant differences consistency performance also demonstrate corresponding magnitudesdifferences performances.5.1 Analytic Frameworkt-tests performed using normalised performances two planners.find magnitude difference performances two planners, p1 p2 ,collection problem instances. example, given collection n problems, findpairs results p1ri p2ri obtained instances = 1 = n. case normalisevalues dividing mean pair. process establishesrange performances 0 2, 1 standing equal performance.t-test results t-value representing difference mean normalised performancestwo planners. perform 2-tailed tests p < 0.05 interestedindividual results rather extrapolated partial orderings based magnitude.want consider magnitude information relevant individual consistencyresults.5.2 Results Analysistables Figures 16 20 organised follows. Tables Figures 16, 18 20contain speed results found fully-automated, hand-coded mixed pairs respectively. Tables Figures 17, 19 20 contain quality results threegroups. table row five competition levels (although emptyrows omitted). columns represent pairs planners compared.cell five pieces data reported: mean normalised performanceplanner; t-value computed degrees freedom used (which derivednumber double hits level) resulting p-value. positive t-value meansmagnitude difference favour planner identified second cell. negativet-value favour planner identified first. resulting t-value indicatesdifference magnitude significant p=0.05 level use bold font.speed quality tests, average performance smaller 1 favourableplanner. interpretation value represents average proportion27fiLong & FoxstripsnumericsimpletimetimeFF 0.4LPG 1.6-12.26,113< 0.001FF 0.23LPG 1.77-16.04,68< 0.001LPG 1.03MIPS 0.970.35,570.73LPG 1.25MIPS 0.752.64,540.008MIPS 1.21LPG 0.792.69,840.007MIPS 0.8LPG 1.2-1.84,450.06MIPS 0.85VHPOP 1.15-1.43,430.15LPG 1.16Sapa 0.841.81,610.07FF 0.22MIPS 1.78-21.30,85< 0.001LPG 0.76VHPOP 1.24-2.82,670.005LPG 1.28Sim 0.723.73,89< 0.001Sim 0.26VHPOP 1.74-15.19,50< 0.001MIPS 0.77Sapa 1.23-3.41,49< 0.001Figure 16: Magnitude comparisons fully-automated planners terms speed.strips (seq)strips (conc)numericsimpletimetimeMIPS 1.05LPG 0.955.61,84< 0.001FF 1.18LPG 0.829.70,113< 0.001FF 1.17LPG 0.836.00,68< 0.001LPG 0.86MIPS 1.14-7.98,57< 0.001LPG 0.9MIPS 1.1-3.44,54< 0.001FF 0.95MIPS 1.05-5.39,85< 0.001FF 1.13MIPS 0.876.81,85< 0.001FF 1.01MIPS 0.990.14,490.89MIPS 0.93VHPOP 1.07-3.97,43< 0.001LPG 0.86Sapa 1.14-4.99,61< 0.001LPG 0.98VHPOP 1.02-2.73,670.006LPG 0.7Sim 1.3-12.95,89< 0.001MIPS 1.2LPG 0.84.25,45< 0.001LPG 0.91Sim 1.09-7.21,89< 0.001Sim 1.33VHPOP 0.6714.37,50< 0.001Sim 1.08VHPOP 0.926.01,50< 0.001Figure 17: Magnitude comparisons fully-automated planners terms quality.mean performances pair planners test set. Thus, average performance0.66 planner (which compare average performance 1.34planner pair considered) means first planner is, average, twicefast second.5.3 Interpretationresults demonstrate null hypothesis rejected almost pairwisecomparisons planners Wilcoxon test shows significant consistent performance difference. cases null hypothesis cannot rejected,implying consistent performance difference pair planners translatestatistical significance mean relative performances.28fiThe 3rd International Planning CompetitionstripsnumericsimpletimetimeSmall ProblemsTLPlan 0.52TLPlan 0.61TAL 1.48SHOP2 1.39-12.98,101-8.32,101< 0.001< 0.001TLPlan 0.7SHOP2 1.3-6.21,101< 0.001TLPlan 0.43TLPlan 0.67TAL 1.57SHOP2 1.33-21.34,101-7.79,101< 0.001< 0.001TLPlan 0.44TLPlan 0.59TAL 1.56SHOP2 1.41-25.00,101-10.14,101< 0.001< 0.001TLPlan 1.32TAL 0.687.74,97< 0.001TLPlan 0.31SHOP2 1.69-19.22,92< 0.001TLPlan 0.32SHOP2 1.68-24.27,97< 0.001TLPlan 0.82TAL 1.18-5.75,97< 0.001Large ProblemsTLPlan 0.39TAL 0.24SHOP2 1.61SHOP2 1.76-17.41,97-26.04,97< 0.001< 0.001TAL 0.48SHOP2 1.52-11.28,97< 0.001TLPlan 0.31SHOP2 1.69-23.75,95< 0.001TAL 0.46SHOP2 1.54-12.81,95< 0.001Figure 18: Magnitude comparisons hand-coded planners terms speed.Small Problemsstrips (seq)strips (conc)simpletimetimeTLPlan 0.96SHOP2 1.04-5.48,101< 0.001TLPlan 1.38TAL 0.6221.10,101< 0.001TLPlan 0.89SHOP2 1.11-7.66,101< 0.001TLPlan 0.9TAL 1.1-4.39,101< 0.001TLPlan 1.27SHOP2 0.7311.81,101< 0.001TAL 0.93SHOP2 1.07-3.82,101< 0.001TLPlan 0.94SHOP2 1.06-4.08,101< 0.001TAL 0.88SHOP2 1.12-5.15,101< 0.001TLPlan 0.96SHOP2 1.04-3.82,97< 0.001TLPlan 1.7TAL 0.348.66,97< 0.001TLPlan 0.85SHOP2 1.15-6.85,97< 0.001TLPlan 0.88SHOP2 1.12-6.46,95< 0.001Large ProblemsTAL 0.98SHOP2 1.02-2.13,970.033TLPlan 1.5TAL 0.75SHOP2 0.5SHOP2 1.2516.58,97-8.94,97< 0.001< 0.001TAL 0.87SHOP2 1.13-4.80,97< 0.001Figure 19: Magnitude comparisons hand-coded planners terms quality.SpeedstripssimpletimetimeTLPlan 0.55FF 1.45-7.60,96< 0.001LPG 1.9TLPlan 0.138.14,99< 0.001LPG 1.9TLPlan 0.126.85,92< 0.001QualitySeqConcTLPlan 1TAL 1.04TAL 0.84 TLPlan 1.23FF 1LPG 0.96LPG 1.16LPG 0.770.54,963.89,98-7.16,9812.54,980.589< 0.001< 0.001< 0.001LPG 0.94TLPlan 1.06-3.89,99< 0.001Figure 20: Comparisons fully-automated hand-coded planners termsspeed quality.29fiLong & Foxshown tables 16 20, reassuring consistency emerged resultsWilcoxon tests. is: significant consistency differences identified twoplanners using Wilcoxon test, t-test magnitude generally reveals significantmagnitude difference well.6. Dependence Performance Domainconsider important quantify difficulty problems used competitionprovides basis deeper understanding relative planner performance.explore investigate whether domains used uniformlyconsidered easy, hard, amongst fully-automated hand-coded planners. alsoinvestigate whether, might expected case, strips problems generallyconsidered easier problems numeric temporal levels.two questions lead two related investigations based bootstrapping techniques.analyses show different planners experienced different domains levels difficult,within fully-automated hand-coded categories.first competition, 1998, reported (Long, 2000) planner solvedproblem 25,000 ground actions 10,000 ground actionsmarked limit beyond planner performance markedly unreliable. groundaction formed replacing action schema parameters objects correct typesselected problem instance. static preconditions preconditions whosetruth ascertained entirely initial state used filter groundactions, plausibly applicable counted. Relevant groundactions found applying reachability analysis initial state regressionanalysis goals order identify subset ground actions could actuallyplay useful role plan. seems plausible number ground actions couldoffer guide difficulty problems. fact, brief survey largest problemsthird competition, Figure 21, reveals action counts vary widely acrossdomains. encouraging observe size problems solvedreasonable reliability, least domains, grown significantly, despite factstill typical planners ground action set prior planning. also interestobserve size problems measured action counts strong indicationdifficulty problems Rovers Satellite domains amongst foundharder many planners, despite small action counts.summarise, hypotheses explored section are:Null Hypothesis: domains used competition equally challenging planners levels.Alternative Hypothesis: Domain/level combinations distinguishedterms relative difficulty posed different planners.ease comparison results presented Sections 7 8 observe that,section, specifically concerned cross-domain analysis whetherplanners agreed domain/level combinations hard.30fiThe 3rd International Planning CompetitionDomainDepotsDriverLogZenoTravelRoversSatelliteFreeCellSettlersLargest Ground Action Count332,06431,14032,7807,3644,437112,6005,884Largest Relevant Action Count22,92415,69632,7803,9764,43725,4184,503Figure 21: Counts ground action instances (generated using FF).6.1 Analytic Frameworkorder explore two questions, used planners discover hard domainslevels were. planner, domain problem level plot number probleminstances left solve time milliseconds. results curve, areataken measure difficulty experienced planner solvingproblems given domain given problem level. order keep areacurve finite use cut-off time thirty minutes. extended cut-off time (fifteenminutes used competition) results higher penalty paid plannerfails solve problems.experiment used address first question, null hypothesisplanner finds problems specific level equally difficult across domains. testconstructed, using bootstrapping technique, ten thousand samples twenty valuescollection timings obtained domains appropriate level. valuesselected random performances planners competing domains, onevalue collection randomly selected problems. example, problem onechosen DriverLog, problem two Depots, problem three Rovers, problemfour Depots, etc., value associated problem one would producedproblem planner selected random competed DriverLog.Similarly, value associated problem two would chosen plannercompeted Depots, on. collection 20 values plotted numberproblem instances left solve time, above. resulted samplingdistribution level-specific areas. Using bootstrap samples check whetherarea calculated particular planner-domain-level combination lies extremesdistribution, not. lies first 2.5% distribution reject nullhypothesis grounds planner found problems level, domain,significantly easy. lies top 2.5% distribution reject nullhypothesis conclude problems significantly hard planner.testing relative hardness problem levels within domain (the second question),perform similar experiments which, planner, bootstrapped samplesobtained sampling timings problem levels within domains. resultednew sampling distribution level-independent area statistic. null hypothesis,domain/level combination indicator difficulty, tested seeing whether31fiLong & FoxDepotsDriverLogZenoTravelRoversSatelliteFreeCellSettlersstrips[6]1/30/13/02/14/01/2Level-dependentnumeric simpletime[3][3]1/00/12/01/02/01/00/10/10/21/00/2time[3]0/12/01/01/11/0strips[6]2/21/04/03/14/02/2Level independentnumeric simpletime[3][3]1/10/10/01/02/00/00/20/10/22/00/2time[3]0/11/00/10/11/0Figure 22: Comparisons performance domains fully-automated planners.areas computed planner-domain-level combinations extreme respectnew sampling distribution.6.2 Results AnalysisFigures 22 25 report results two experiments described above. Figures 2223 describe level-specific level-independent comparisons made usingfully-automated planners hand-coded planners respectively. table handcoded planners divided two parts: first five rows correspond smallproblems, latter five rows large problems. performance hand-codedplanners large problems measured using bootstrapped samples takenlarge problem collection.tables organised follows: rows correspond domains, labelled,columns levels considered number planners used. numberplanners varies columns different planners participated differentdomain levels. example, planners participated strips levelothers. planners produced little data justify statistical analysisincluded tests. Thus, eleven fully-automated planners competitionseven produced enough data analysis experiments.cells tables contain two integer values separated diagonal. valueleft diagonal indicates number planners found problemscorresponding domain level significantly easy. value right indicatesnumber found problems significantly hard. Thus, seen Figure 22six fully-automated planners participated strips level Depotsdomain, one found problems easy three found hard. twoplanners areas calculated using method explained foundsufficiently extreme rejection null hypothesis. Broadly speaking (we discussinterpretation data detail below) four left-hand columns tell us whetherproblems particular domain level easy hard relative problemslevel; four right-hand columns tell us whether easy hard relativeproblems. addition, rows allow us compare domains relative difficulty:example, none planners found ZenoTravel hard level relativeproblems level, whilst Depots Rovers found hard least onecompetitor levels.32fiThe 3rd International Planning CompetitionDepotsDriverLogZenoTravelRoversSatelliteDepots (large)DriverLog (large)ZenoTravel (large)Rovers (large)Satellite (large)strips[3]2/00/03/00/22/12/00/13/01/11/0Level-dependentnumeric simpletime[2][3]2/01/02/00/01/03/00/10/30/12/12/02/01/00/11/03/00/01/10/12/0time[3]3/03/03/00/20/13/01/13/01/00/2strips[3]3/03/03/01/02/02/00/03/02/01/0Level-independentnumeric simpletime[2][3]2/03/01/02/01/03/00/10/10/02/11/02/00/00/11/03/00/02/00/12/0time[3]3/00/02/00/20/12/00/13/00/00/1Figure 23: Comparisons performance domains using hand-coded planners.level-independent tests reported exactly way right-hand halvesFigures 22 (for fully-automated comparison) 23 (for hand-coded comparison).tables tell us whether problems particular domain level easy hardrelative problems domains irrespective level.data presented Figures 24 25 show planners found domain-levelcombinations easy hard discussed reference tables Figures 22 23.information might contribute understanding planning approacheslikely suited kinds problems, although analysis would neededpursue question.tables organised follows. row individual planners,indicating domain-level combinations found easy hard corresponding planner. Associated categorization combination easy hardp-value indicating statistical significance finding. presentedfindings significant 5% level. two-tailed test (wepriori knowledge help us determine whether problem would easy hard)critical value easy end 0.025. hard end critical value 0.975. Figure 24shows findings fully-automated planners. Figure 25 shows informationrespect hand-coded planners.6.3 Interpretationresults allow us reject null hypothesis cases, others.able determine significant differences relative hardness domains determinedspecific planners, also evidence lack consistency judgementsdifferent planners. example, domain/level combinations foundhard certain planners others.tables Figures 22 23 allow us determine domains presentedinteresting challenges planners participating competition. Althoughdifficult draw firm conclusions data really indicative, interestingpatterns emerge. example, level-specific data Figure 22 shows nonefully-automated planners found ZenoTravel problems, levels, significantly hardcomparison problems drawn domains level. Satellite33fiLong & FoxFFLPGMIPSSapaSimplannerStellaVHPOPEasyDepots NumericDepots StripsFreeCell StripsRovers StripsSatellite HardNumericSatellite StripsZenoTravel NumericZenoTravel StripsRovers StripsSatellite SimpleTimeSatellite StripsDriverLog HardNumericDriverLog SimpleTimeDriverLog StripsDriverLog TimeFreeCell StripsSatellite HardNumericZenoTravel NumericZenoTravel StripsSatellite TimeDepots StripsZenoTravel StripsSatellite StripsZenoTravel StripsRovers StripsSatellite SimpleTimeSatellite Strips0.0150.0120.017000.00070.00260.00150.00070.0190.00010.00460.00940.00880.0093000.010.00210.00170.00030.0130.016000.00060.0004HardRovers NumericSettlers Numeric11Satellite NumericZenoTravel Time10.98Depots NumericRovers NumericRovers TimeSatellite ComplexSatellite NumericSettlers Numeric0.990.980.980.9811Depots TimeRovers StripsDepots StripsFreeCell StripsDepots SimpleTimeDepots StripsFreeCell StripsRovers SimpleTimeFigure 24: Easy/hard boundaries fully-automated planners.3411111110.98fiThe 3rd International Planning CompetitionSHOP2TALPlannerTLPlanEasyDepots NumericDepots SimpleTimeDepots StripsDepots TimeDepots HC SimpleTimeDepots HC StripsDepots HC TimeDriverLog HardNumericDriverLog SimpleTimeDriverLog StripsSatellite SimpleTimeSatellite StripsSatellite HC SimpleTimeSatellite HC StripsZenoTravel NumericZenoTravel SimpleTimeZenoTravel StripsZenoTravel TimeZenoTravel HC NumericZenoTravel HC SimpleTimeZenoTravel HC StripsZenoTravel HC TimeDepots SimpleTimeDepots StripsDepots TimeDepots HC SimpleTimeDepots HC StripsDriverLog StripsRovers StripsRovers HC SimpleTimeRovers HC StripsZenoTravel SimpleTimeZenoTravel StripsZenoTravel HC SimpleTimeZenoTravel HC StripsZenoTravel HC TimeDepots NumericDepots SimpleTimeDepots StripsDepots TimeDepots HC NumericDepots HC TimeDriverLog HardNumericDriverLog NumericDriverLog SimpleTimeDriverLog StripsRovers HC SimpleTimeRovers HC StripsSatellite SimpleTimeSatellite StripsSatellite HC SimpleTimeZenoTravel SimpleTimeZenoTravel StripsZenoTravel TimeZenoTravel HC SimpleTimeZenoTravel HC StripsZenoTravel HC Time0.00310.00570.00010.00880.000100.00060.0150.0150.01900000.00180.00030.00010.00430.0001000.0001000.0130.0029000.00260.0009000000.0170.00090.010.00090.000300.00840.00510.00830.020.00090.00370.013000.0001000.0014000HardRovers NumericRovers TimeDriverLog HC SimpleTimeDriverLog HC TimeRovers SimpleTimeRovers TimeSatellite SimpleTimeSatellite TimeSatellite HC TimeSatellite HardNumericSatellite HC ComplexSatellite HC Numeric11110.9910.9811111Figure 25: Easy/hard boundaries hand-coded planners. Note: HC indicates largerproblems used hand-coded planners.35fiLong & Foxstrips problems significantly easy, comparison strips problems,majority participating planners, hard them. handSatellite numeric problems found challenging relative numericproblems. Figure 23 shows hand-coded planners found ZenoTravel problems easylevels, comparison problems similar levels, remains truelarge problem instances. Depots problems also easy hand-coded planners.consider level-independent picture right-hand halves Figures 2223 observe ZenoTravel emerges significantly easy fully-automatedplanners, across levels, comparison problems irrespective level.pattern broken one full-automated planner (lpg) finding problems hardtime problem level. Satellite domain similarly easy fully-automatedplanners, levels except numeric. noted number planners findingstrips problems easy level-independent comparisons surprisingly high.interpretation problems population whole much harder,performance strips problems pushed extremes performanceproblems. hand-coded planners found Depots ZenoTravel problemsuniformly easy levels.Considering fully-automated hand-coded planners, DriverLog,Rovers Satellite domains present varied picture, suggesting problemsdomains presented greatest challenges overall. hand-coded plannersfound simpletime Rovers problems significantly hard relative simpletimeproblems, one found problems amongst hardest solveoverall. Interestingly, perceived difficulty small Rovers problems persistlarge problems.interesting comparison made results analysis stripsdomains work Hoffmann (2003b) analysing topologies strips adlversions common planning benchmark domains. Hoffmann examines behaviourh+ function, measuring relaxed distances states state spacesproblems, order determine whether function offers reliable guide navigatestate space search plans. According Hoffmanns analysis, stripsversions Depots, DriverLog Rovers local minima functionarbitrarily wide plateaus (sequences states equal values h+ ). featuresmake problem instances domains hard planners relying h+ (or approximations it) guide search. includes fully-automated plannerscompetition. However, interestingly, several fully-automated planners foundone three domains easy strips level (although casesfound hard). Hoffmann points out, potential hardness domainmean collections problem instances domain hard.observations seem suggest competition collections posed instances tendedtowards easy end spectrum. unintentional demonstratesdifficult obtain good spread challenges, particularly generating problems automatically. Satellite ZenoTravel domains have, contrast, constant-boundedplateaus therefore h+ function reliable guide navigating state spacedomains. Interestingly, analysis fully-automated planners founddomains either easy neither easy hard strips level.36fiThe 3rd International Planning Competition7. Scaling IssuesSection 6 addressed issue relative difficulty problems without considering question whether planners agree difficulty specific problems. resultssection allow us conclude overall consensuscompetition domains levels found hard, allow us determineplanners agreed disagreed particular domains levels. order lookrelative scaling behaviour planners need identify extent agreement.examine scaling behaviour necessary scale measuresperformance way meaningful planners comparison. analysisdescribed section therefore seeks establish statistical evidence agreement.order evaluate scaling behaviour first explore whether competing plannersagree makes problem, within particular domain level, hard. Althoughmight seem straightforward ensure problem set consists increasingly difficultproblems (for example, generating instances increasing size) fact straightforward achieve this. appears problem size difficulty strongly correlated,whether size taken measure number objects, number relations evennumber characters problem description. Although coarse relationshipobserved large instances take time parse ground small instancessometimes present difficult challenges large instances. indicatesfactors size appear important determining whether planners solveindividual instances.summary, hypotheses explored section are:Null Hypothesis: planners differ judgementsindividual problem instances hard within given domain/level combination.Alternative Hypothesis: planners demonstrate significant agreementrelative difficulties problem instances within given domain/level combination.section specifically concerned within-domain/level analysiswhether planners agree relative difficulty problem instances within givendomain/level combination.7.1 Analytic Frameworkdiscussed Section 6, use planners judges determinedifficult individual problems were. Given competing planners proceededfirst grounding problem instance searching problem space usingvariation theme relaxed distance estimate, seems little reason believeplanners would strongly diverge. particular instance, family instances,proved difficult one planner might expected collection wouldchallenging competitors. avoid distracted impact hand-codedcontrol rules separate judgements fully-automated plannershand-coded planners. domain/level combination hypothesis planners37fiLong & FoxFullyAutomatedDepotsDriverLogZenoTravelRoversSatelliteFreeCellSettlersStripsNumericF21,110 = 5.3F19,100 = 17.1F19,100 = 21.7F19,80 = 4.54F19,100 = 7.36F19,100 = 6.21F21,44 = 5.48F19,40 = 17.4F19,40 = 14F18,38 = 9.47F15,48 = 1.74HardNumericSimpleTimeTimeF19,20 = 11.8F21,66 = 1.77F19,60 = 4.44F19,60 = 9.4F19,60 = 4.25F19,60 = 3.6HardNumericSimpleTimeTimeComplexF21,44 = 4.54F19,40 = 5.34F19,40 = 5.54F19,40 = 28.3F19,40 = 5F21,44 = 6.21F19,40 = 6.52F19,40 = 4.22F19,40 = 18F19,40 = 20.6F19,20 = 51.3F19,40 = 4.05F20,63F19,60F17,36F19,40F19,60= 2.14= 4.63= 12.1= 6.92= 4.19ComplexF19,60 = 3.78F5,6 = 1.6Hand-Coded(Small)DepotsDriverLogZenoTravelRoversSatelliteHand-Coded(Large)DepotsDriverLogZenoTravelRoversSatelliteStripsNumericF21,44 = 2.49F19,40 = 2.58F19,40 = 2.93F19,40 = 4.5F19,40 = 7.25F21,22 = 2.19F19,20 = 3.73F19,20 = 8.3F19,20 = 36.5F19,20 = 38.7StripsNumericF21,44F19,40F19,40F19,40F15,32= 11.4= 61.4= 3.14= 17.2= 20.8F21,22F19,20F19,20F19,20F15,16= 3.76= 57.3= 1.47= 29.9= 33.5F19,20 = 6.45F19,20 = 9.4HardNumericF19,20 = 66.4SimpleTimeF21,44 = 13.8F19,40 = 91.6F19,40 = 3.54F19,40 = 33F15,32 = 43.7TimeF21,44F19,40F19,40F19,40F15,32= 10.8= 80.5= 3.37= 49.4= 88.5ComplexF15,16 = 152Figure 26: F-values multiple judgments rank correlation tests.tend agree relative difficulties problems presented within domainlevel.explore extent agreement exists perform rank correlation testsagreement multiple judgements (Kanji, 1999) (we refer test MRC).experiment judges planners subjects problem instances.perform distinct MRC domain/level combination, showing caseplanners ranked instances domain level. therefore perform 25 MRCsfully-automated planners (there 25 distinct domain/level pairs fullyautomated planners competed), 23 hand-coded planners small problems (thehand-coded planners compete Freecell strips Settlers numeric domains)22 hand-coded planners large problems (amongstSatellite hardnumeric instances). results tests shown Figure 26.test n planners rank k problem instances order time taken solve.Unsolved problems create difficulties pushed top end ranking.MRC determines whether independent rankings made n planners agree.test statistic follows F-distribution (k 1, k(n 1)) degrees freedom determiningwhether critical value exceeded.7.2 Results Analysiscells Figure 26 report F values obtained (and degrees freedom used).almost cases critical value exceeded null hypothesis non-agreementcould rejected least 0.05 level. cases (those reported bold38fiThe 3rd International Planning Competitionfont) critical value exceeded statistical evidence therefore foundagreement planners difficulty instances correspondingdomain level. interesting note problematic cases withinnumeric level, fully-automated hand-coded planners. Furthermore, casecomes closest critical boundary (the small Depots numeric problems,hand coded table, F-value 2.19) also within numeric level.7.3 Interpretationresults support rejection null hypothesis almost cases. thereforeadopt alternative hypothesis, observing many cases plannersagree relative difficulties problem instances within given domain/level combination.competition observed talplanner disadvantage respecthand-coded planners, terms comparative speed, running smallproblems. probably java virtual machine start-up time becomessignificant relative actual solution time small instances. see effects startup time tables. Note that, domain/level combinations talplannercompeted (strips, simpletime time) see low level agreement amongsthand-coded planners small problems (except case Rover domain).talplanner disagrees planners rankingactual problems, problems small enough variabilitysetup time throws noise ranking obscures true picture relative problemdifficulty. set large problems see anomaly removedproblems sufficiently challenging java startup time becomes insignificanthigh level agreement ranking obtained. Interestingly, hand-coded plannersshow consistently high level agreement ranking Rovers problems. factemerge fully-automated set may due larger numberjudges fully-automated category.8. Relative Scaling BehavioursMRCs described Section 7 demonstrate planners agree, expected,relative difficulty problem instances within domain/level combinations.cases possible go explore domain level specific scaling behaviourplanners, go investigate section. cannot explorescaling behaviour planners across domains because, discussed Section 6,seem much across-the-board agreement concerning relative hardnessdomains would unlikely see agreement multiple judgments acrossdomain boundaries.ideal basis explore scaling behaviour would collectionproblems canonical scaling difficulty compare performanceplanners scaled progressively harder problems within collection. Unfortunately, many factors contribute making problems hard affect plannersuniformly. result, canonical measurement problem difficulty many domains. Instead, must determine relative difficulty problems using planners39fiLong & Foxjudges. means consider relative scaling behavioursplanners planners agree underlying ordering difficulty problems.Thus, begin identifying appropriate sets problems given pairplanners agree relative hardness problems according analysis Section 7 proceed compare way planners pair scalesproblems increase difficulty. first stage analysis considers ordertwo planners place problems within set, second stage examinesperformance varies two planners progress problemproblem.hypotheses explored section are:Null Hypothesis: planners agree difficulty problemsgiven domain/level combination, exhibit scaling behaviour.Alternative Hypothesis: planners agree difficultyproblems given domain/level combination, demonstrate different scaling behaviours, better scaling performance identifieddata set.section concerned question scaling behaviour within problem setsspecific domain/level combinations already determined agreement,identified Section 7.8.1 Analytic Frameworkorder test different scaling properties planners make pairwise comparisonsperformance using domains planners agreed difficultyproblems. is, use domain comparison planners found hard,found easy neither found hard easy.rank problems order difficulty use results obtained bootstrapping experiment described Section 6. rankings level dependent, lookedscaling within four problem levels recorded results separately.attempt combine results single overall conclusion scaling recognize different planners scale better problem levels others,single planner therefore emerge scaling best overall.compare two planners agreed difficulty least two domains.gives us, case comparison made, data set 30 points.planners agree least two domains conclude insufficient agreement constitutes problem difficultypossible measure relative scaling behaviours meaningful way.perform comparison two planners rank problems data setorder agreed difficulty rank differences performancesplanners problems. explore whether ranking differences correlated ranking problems according difficulty. use rankscannot make assumptions shapes underlying problem distributionsfunctions truly describe performances planners compared,results robust respect factors.40fiThe 3rd International Planning CompetitionFFstripsFFLPGMIPSSapaVHPOPLPGnumeric0.36NJstrips0.87JNJMIPSnumeric simple timetimeN0.930.520.510.61NJJSapatimeN0.58JVHPOPstrips simpletimeN0.930.44 J 0.48JNNFigure 27: Table showing correlation values, fully-automated planners, problemNdifficulty difference time performance, indicating scaling behaviour.means one pairs planners produce data comparisonJmay drawn.means insufficient agreementplanners difficulty domains ranking problems ordercarry comparison.Given two planners, p1 p2 , positive correlation rankings differences values p1 p2 problem difficulty ranking meansdifference performance p1 p2 (that is, performance p1 minus performancep2 ) increasing problems become difficult. curve p1 increasingfaster p2 scales better p1 . negative correlation means p1 scales betterp2 . zero (or near-zero) correlation means scaling behaviour two plannersinsignificantly different. use Spearmans rank correlation test (see Appendix C)identify critical value required confidence 0.05 level.restrict attention planners solved problems overall twocategories. Thus, fully-automated planners compared ff, lpg, mips, vhpopsapa. consider pairs hand coded planners. performcross-category tests evident raw data hand coded planners exhibitbetter scaling behaviour fully-automated planners.8.2 Results Analysistable Figure 27 shows significant scaling differences found pairsfully-automated planners levels. Figure 28 shows relative scalinghand coded planners. sets tests, two planners could comparedlevels competed, domains agreed either easy,hard, neither easy hard. report results planner indexed rowone showing superior scaling behaviour. planners competeNtracks indicate symbol denoting incomparable. significantdifference scaling found indicate zero correlation. agreementJfound support comparison use symboldenoting disagreement. avoidduplication data, place entries positive correlations cell correspondingrow planner favoured comparison omit corresponding negativecorrelation cell row column planners reversed.41fiLong & FoxTLPlanstrips timeTLPlanSHOP2TALPlannerstrips0.77000.86SHOP2numeric simpletime0.930.85N0.46time0.83TALPlannerstrips simple timetime00.2500.76Figure 28: Table showing correlation values, hand-coded planners, problemNdifficulty difference time performance, indicating scaling behaviour.means one pairs planners produce data comparisonmay drawn.8.3 Interpretationalmost cases comparison could performed, significant differencescaling behaviour found, supporting rejection null hypothesis.used domains agreement relativedifficulty problems necessary restrict conclusions domaindependent. However, restricted collection data points disposalmust careful generalise picture. basis analysesbelieve make tentative judgements planners scaling pairwisecomparisons within four competition levels.fully-automated planners observed informally high degree consistency scaling behaviours particular planners across problemlevels competed. Although cannot draw overall conclusions dataset high level confidence observe ff exhibits best scaling behaviourlevels competed lpg exhibits best scaling behaviour temporal levels. remembered perform single-domain comparisons,although might interesting point view exploring domain-specific scaling behaviour might produce interesting results. felt results wouldinteresting curiosities rather anything could support general conclusions.hand coded planners also show high degree cross-level consistency.observed informally tlplan scales much better shop2 across levels, whereasscales marginally better talplanner strips domains significantlylevel. talplanner scales better shop2 levelscompeted. seen shop2 scaling well relative competitors, althoughremembered quality plans produced shop2 superiordomains.Formally tables allow us draw specific conclusions relative scalingbehaviours specific pairs planners, within specific problem levels, 0.05 level.9. Conclusions3rd International Planning Competition focussed issue temporal planningnumeric resource handling. competition structured around two categories:42fiThe 3rd International Planning Competitionfully-automated hand-coded planning systems, four main problem levels: strips,numeric, simpletime time. eight domains, one intendedhand coded planners (the um-translog domain), two solelyfully-automated planners (the FreeCell Settlers domains). Fourteen competitors tookpart, eleven fully-automated track three hand coded track. domaindescription language used pddl2.1, extension pddl standard designedmodelling temporal resource-intensive domains. pddl2.1 described another paperissue (Fox & Long, 2003).collected data set five half thousand data points distributeddomains levels. initial plotting points, terms relative timequality performances planners different domains, revealed numberinteresting patterns. suggest characteristics relative performancescompetitors within competition domains. patterns presented discussedAIPS conference final competition events co-located. However,patterns, indicating relative performances across domainsshowing perceived difficulty competition domain/level combinations, invisible data presented way. paper presents results detailedstatistical analyses competition data, aimed identifying deeper patterns.paper explores three experimental themes. first theme aimed answeringquestion: planner buy? question concerned planneremerges strongest overall performer, rather produced best resultsparticular domain/level combination, asked point viewspeed quality criteria. answer performed comparisons, basedWilcoxon rank-sum matched-pairs test, enabling construction partial orderscompeting planners terms time quality performances four levelscompetition. partial orders concluded that, potential userinterested good behaviour across broad range temporal numeric problemslpg, amongst fully-automated planners, tlplan, amongst hand-codedplanners, best choices. course, specialised coverage required speedsolution paramount choices might made.second theme considers dependence planner performance domain structure. interested exploring extent competing planners agreedomain/level combinations hard easy. analysisperformed addressing first issues statistical complement theoreticalanalysis domain topologies carried Hoffmann (2003b). consideredcompetition domains four levels used competition, whilst Hoffmann considersstrips subset competition domains (he also considers adl domains,use competition). interesting note findingsbroadly consistent conclusions.third theme considered scaling behaviour competing planners. considered two related issues: extent competing planners agreed relativedifficulty problem instances within domain/level combinations extentplanners scaled similarly domain/level combinations agreement. intentions pursuing first issue provide objective scale43fiLong & Foxwould support efforts investigate relative scaling behaviours planners. found relatively little agreement perceived difficulty problems withindomain/level combinations able perform restricted comparison relativescaling behaviour. However, consider results obtained make interestingcontribution deeper comparison planner performances available rawdomain-specific data.many questions would interesting able answer.Amongst questions extent hand-coding domain knowledgereally benefits planner amount (and value) effort involved encodingknowledge. pressing question community one competitionseries might well-suited try answer. However, order pursue futurecompetitions necessary carefully design controlled experiments aimed exploring precise hypotheses. restricted paper post hoc analysiscompetition data, clearly restricted kinds questionsable ask answer. However, hope results methodologiespresented interest planning community helpencourage scientific evaluation performance field.Acknowledgementswould like thank competitors 3rd International Planning Competitioncontributing time enthusiasm event report providingdata made paper possible. would also like thank Adele Howecontributed invaluable advice, comments huge support made possiblepaper go far could hoped. would like thank DavidSmith undertaking unenviable task coordinating editing special issueJournal Artificial Intelligence Research immense patience, goodhumour generous support. Finally, would like thank Martha Pollack firstproposed idea publishing assembled work special issue JournalArtifical Intelligence Research. whole-hearted commitment projectvital successful conclusion.44fiThe 3rd International Planning CompetitionAppendix A. Problem DomainsA.1 First International Planning Competitionfirst competition used following domains:Logistics transportation problem involving aircraft trucks, trucks constrained movement within cities aircraft constrained movement(inter-city) airports. domain allows considerable parallelism.Mystery transportation domain vehicles limited capacity consuming limited stocks fuel.MPrime variant Mystery domain also possible pipe fuellocations order allow vehicles different movement options.Grid problem single robot moves locations grid shapedmap. Locations may locked keys must collected gain accesslocations. objectives problem instances involve transportingkeys particular locations.Gripper simple domain, originally designed demonstrate limitationsGraphplan, collection identical balls must transported robottwo grippers one room adjacent room.Movie simple domain intended explore use conditional effects. collectionsnacks must assembled prior rewinding video watching movie.Assembly complex adl domain challenging use quantified conditionaleffects.A.2 Second International Planning Competitionsecond competition introduced several new domains:Blocks classic blocks-world problem, encoded without explicit referencegripper. domain significant goal interaction.Job-Schedule problem involving machining parts. problem exercisesadl features involving conditional quantified effects, although less complex Assembly domain.Freecell classic solitaire card game widely available computergame. encoding strips domain represents larger problemprevious benchmarks includes awkward addition encoded set integers.Miconics Elevator domain inspired problem planning efficient call sequence elevator car travelling floors large building.several variants, complex including numeric preconditionswell purely logical constraints. adl version offered complex preconditionsinvolving several different connectives strips version offered relatively simpletransportation problem.45fiLong & Foxaddition, Logistics domain reused provide calibration performancecomparison first competition.A.3 Third International Planning CompetitionA.3.1 Depots Domaindomain consists actions load unload trucks, using hoists availablefixed locations. loads crates stacked unstacked onto fixed setpallets locations. trucks hold crates particular order,act like table Blocks domain, allowing crates reordered.domain devised foremost intention testing strips planners.second competition demonstrated Logistics domain longer seriouschallenge, that, planners using hand-coded controls, Blocks domain alsosolved. fully-automated planners Blocks domain still represents challenge, although second competition showed planners solve quite large problems(up twenty blocks) reasonably efficient plans within minutes. However, performance vary widely problems range prove unsolvableplanners. wanted see whether performance achieveddomains could successfully brought together one domain. interestedsee fully-automated planners, interaction problems createsadditional family choice points addition appear transportationblock-tower-construction sub-problems. also interested see handcoded planners rules sub-problems obviously well-understood,obvious whether rules combined single collection withoutproblems interaction.metric version domain adds weight attributes crates weight capacities trucks. addition, trucks consume fuel travels plans mustminimise fuel use. Fuel use constant dependent locations. Fuel also consumed lifting crates, tradeoff considered crates must restackedlocation. Either truck brought act table complex liftingstacking performed using locally available pallets transfer space.temporal versions allow concurrent activities trucks hoists (atlocations). full temporal variant makes time driving dependent truckdistance locations, makes time load unload crate dependentweight crate power hoist. objective minimisemake-span (the overall duration plan).A.3.2 DriverLog Domaindomain drivers walk locations trucks drivelocations. Walking requires traversal different paths used driving,always one intermediate location footpath two road junctions.trucks loaded unloaded packages (with without driver present)objective transport packages locations, ending subsetpackages, trucks drivers specified destinations.46fiThe 3rd International Planning Competitiondomain produced explore power strips solutions transportationproblems transportation involves sub-problem acquiring driver. problemone offers significant opportunity concurrency use drivers vehicles,also interested see temporal variants handled.metric variant domain adds costs walking driving problem instances required planner optimise linear combination total walkingcost total driving cost.full temporal variant makes time spent driving walking locations dependent path traversed, durations dependent actions(as simple temporal version). variants plan quality dependsmake-span.additional variant, hard numeric variant, complicates cost drivingmaking dependent load carried: additional package added truckincreases fuel consumption rate truck current value, making consumption increase quadratic function load.A.3.3 Zeno-Travel Domaindomain actions embark disembark passengers onto aircraft flytwo alternative speeds locations. strips variant rather uninterestingtwo speeds offer meaningful alternatives. metric variantplanes consume fuel different rates according speed travel (two alternatives)distances locations vary. Problem instances require plans minimiselinear combination time fuel use.temporal versions closer original zeno problem. involve durationsdifferent means travel different levels fuel consumption. contrastoriginal zeno problem fuel consumption described continuous function,discrete step functions applied end points durative actions. factfuel aircraft cannot affected multiple different concurrent actionsvalue relevant satisfying precondition actions could begincontinuous consumption replenishment fuel means discrete model fuel usesufficient, demanding less expressive power planners use model.A.3.4 Satellite Domainsatellite domain developed following discussions David E. Smith JeremyFranks nasa Ames Research Center. intended first model satelliteobservation scheduling problem. full problem involves using one satellitesmake observations, collecting data downlinking data ground station.satellites equipped different (possibly overlapping) collections instruments,different characteristics terms appropriate calibration targets, data productions,energy consumption requirements warming cooling down. satellitespointed different targets slewing different attitudes.constraints targets accessible different satellites due occlusionslewing capabilities. Instruments generate data must stored satellitesubsequently downlinked window communication opportunity opens47fiLong & Foxground station. Communication windows fixed. Data takes time downlinkcould impossible downlink entire satellite store given time frame, downlinksmust scheduled around storage capacity, production data observationsopportunities downlink data arise. real problem additionaldifficulties management energy use solar power maintenance operational temperatures periods shadow. order make problemaccessible planners competition (given time scales encoding domain,writing problem generator testing competing planners) several important featuresreal problem simplified. Perhaps important real problemtargets visible particular time-windows, although eliminationproblem downlinking data also significant simplification. Representing windowsopportunity possible pddl2.1, entirely straight-forward remainsarea need development. Management power temperaturealso simplified away.strips version problem involves deciding efficient coveringobservations given satellite capabilities. interesting combinatorial problemsatellites assumed free operate concurrently (in Graphplan-style parallelactivity), otherwise problem offers interesting choice points. strips versionbased earlier Satellite domain contributed Patrik Haslum.metric version problem introduces data capacities satellites fueluse slewing targets. plans expected minimize fuel use obtainingdata. problem combines constrained bin-packing problem (getting datalimited stores satellites, subject constraints certain satellitesequipped obtain certain data) kind route planning problem (finding fuel-efficientpaths targets also considering combined costs fuel consumptionsatellites).temporal versions introduce duration make concurrency important. fulltemporal problem includes different slew times different pairs targets.problems involve minimising make-span times data acquisition. complexversion domain combines temporal metric features plannersrequired manage problem storing different sized data blocks limited capacitysatellite data stores.variant Satellite domain, called hardnumeric version, representsimportant departure traditional planning problems: logical goals describingintended final state trivial (either empty simple final positionssatellites), metric plans declared evaluated quantitydata collected. problem interesting null (or nearly null) plan solveinstances, quality plans zero. produce good plannecessary ensure satellites used collect data this, turn, requiresplanner constructs reasonable data collection goals. hard problemcurrent planners particularly fully-automated planning systems. Nevertheless,realistic demand many problems planner might required face:uncommon specific final state less important effects actionscarried reaching it.48fiThe 3rd International Planning CompetitionA.3.5 Rovers DomainRovers domain constructed simplified representation problemconfronts nasa Mars Exploration Rover missions launched 2003, Mars ScienceLaboratory mission planned 2009 similar missions expected partESA AURORA project. strips version problem involves planning severalrovers, equipped different, possibly overlapping, sets equipment traverseplanet surface. rovers must travel waypoints gathering data transmittingback lander. traversal complicated fact certain rovers restrictedtravelling certain terrain types makes particular routes impassablerovers. Data transmission also constrained visibility landerwaypoints.metric version domain introduces energy cost associated actionsaction allowing rovers recharge, provided sun. problems soughtsolutions minimised numbers recharges, use energy requiredefficient possible.metric temporal variant domain involves energy time management,although instances require planners optimise total duration. demand impliesneed efficient energy use, since recharging action consumes considerableamount time and, model, requires recharging rover remain one placeperiod recharging. opportunity careful division labourrovers makes temporal variants complex interesting problems.A.3.6 Settlers Domaindomain exists metric problem. problem inspired multitudecomputer games involve managing resources, accumulating raw resources slowlycombining advanced processing plants structuresachieve sophisticated objectives. problem proposed Patrik Haslum.interesting difficulty problem presents problem involves constructing new objects resources. easily represented pddl2.1. fact,way capture domain pddl2.1 name objects could constructed give attribute indicating whether actuallyconstructed. leads cumbersome encoding and, moreover, represents particular problem planners ground actions prior planning, since multitudepotential objects must considered process, leading huge collection actions.Many actions uninterestingly different, since specific choice namesobjects created solving instance clearly irrelevant, alternativeconstructed considered planning process.A.3.7 UM-Translog-2 DomainUM-Translog-2 (Wu & Nau, 2002) domain used hand-coded plannersincomplete set results collected due time constraints conclusiontesting period. domain significant challenge sizeseen useful benchmark problem fully-automated planners challengesgrounding searching domain many action schemas.49fiLong & FoxAppendix B. CompetitorsB.1 Fully Automated Plannerseleven competitors category, representing least four distinct planning paradigms (forward search, model-checking, local search partial order planning).Fully-automated planners accept pddl2.1 specifications domain, initial stategoal compute solutions solely basis specifications. additional controlknowledge guidance supplied. Fully-automated planners therefore depend sophisticated search control heuristics efficient storage alternative search branches.popular current approach search control make use variants relaxed planidea originally proposed McDermott (1996) subsequently exploited BonetGeffner (1997) Hoffmann (2000).IxTeT (Laborie & Ghallab, 1995) entered fully-automated planner, retrospectmight better classified hand-coded planner. ability hand-codedomain representations might alleviated problems arose makingcompetition domains accessible IxTeT. IxTeT currently accept domainsproblems pddl format, necessary translate competition domainsrepresentation language. automatic translator pddl IxTeTinput language yet exists clear translation automated.Furthermore, plan representation IxTeT general insisted uponuse competition advantage given need automateplan validation process. fact, several plans produced IxTeT could validated.combination difficulties made impossible offer real insightsperformance IxTeT competition domains. Nevertheless, pleasedattempt made enter IxTeT: important competition causefracture members research community interested enteringlong-established alternative planning technology cannot easilyreengineered meet assumptions underlying competition.B.1.1 FFff extremely successful influential planner since 2000 (Hoffmann & Nebel,2000). based forward state space search using relaxed plans give heuristic guidancechoice possible steps space. Hoffmann extended original ffsystem (Hoffmann, 2003a) include treatment metric domains relaxing metricdimensions problem well logical dimensions.B.1.2 IxTeTIxTeT (Laborie & Ghallab, 1995) well known one first plannersreason time resource intensive domains. version participated partscompetition reimplementation original system described GhallabLaruelle (Ghallab & Laruelle, 1994). mentioned above, IxTeT experienced numberdifficulties competition making difficult evaluate performance. However, seenbroader context planning research application IxTeT made many importantcontributions development temporal resource-intensive planning approaches50fiThe 3rd International Planning Competitionand, powerful plan representation language, suited certain applicationssimplified plan representation used competition inadequate.B.1.3 LPGlpg (Gerevini et al., 2003) based local-search strategy applied plan graphs (Blum& Furst, 1995). approach generalised accommodate metrictemporal structure, making powerful flexible planner. use local searchallows planner configured trade-off time plan quality. Indeed, plannerexhibits time behaviour sense plans reported found and,search allowed run longer, better quality plans might discovered.B.1.4 MIPSmips (Edelkamp, 2003) uses variety techniques, core model-checkerbased ordered binary decision diagrams (obdds), used generate reachablestates. planner uses powerful technique compress state representations ordermake obdds compact. Exhaustive search state space impracticallarge problems mips uses heuristic evaluation function based relaxed plans orderrestrict space explored states. mips tackles concurrency temporal planninglifting partial orders totally ordered plans produced forward search.mips also extended manage metric quantities, also using relaxation heuristicpredict behaviours metric quantities.B.1.5 SAPAsapa (Do & Kambhampati, 2003) forward search planner using relaxed temporalplan heuristic (based use relaxed tgp-style (Smith & Weld, 1999) plan graph)guide search. heuristic supplemented heuristic estimate resourceusage allowing planner handle metric quantities. Temporal structure managedusing delayed effects, that, durative action executed, end effects queuedevent queue, pending application time advanced pointtriggered. focus sapa development management metrictemporal structure. sapa attempt compete strips simpletime problems,performed well complex problems.B.1.6 SEMSYNsemsyn (Parker, 1999) Graphplan-based planner, extensions handle metricadl features. general, Graphplan-based approaches have, exception lpg,proven unequal challenge scaling meet latest sets benchmark problems.suggests search strategy Graphplan must abandoned large problemssolved, underlying plan graph structure need sourcescaling problems (in fact ff, vhpop, sapa lpg use plan graph structuresplanning process).51fiLong & FoxB.1.7 SIMPLANNERsimplanner (Onainda, Sapena, Sebastia, & Marzal, 2001) forward search plannerusing relaxed plan heuristic. heuristic evaluation uses separate relaxed planstop level goals, combining identify useful first action applycurrent state. variant idea relaxed plans appears represent reinforcementnotion helpful actions developed ff, actions selected firstlayer relaxed Graphplan-style plan favoured appropriate candidates nextstep plan.B.1.8 STELLAstella (Sebastia, Onainda, & Marzal, 2001) uses forward heuristic search architecture,modification plans built using landmarks (Porteous, Sebastia, &Hoffmann, 2001). idea identify key states path plan planningbegins use stepping stones progress initial stategoal state.B.1.9 TP4tp4 (Haslum & Geffner, 2001) development hsp (Bonet et al., 1997) planningapproach, one first current generation rather successful heuristicstate-space search planners based relaxed plan heuristics. tp4 extends useheuristic manage temporal plan structure. planner intended find optimalplans (although, minor technical reasons, plans produces slightly suboptimal), using admissible heuristic, requires far greater search effortplanners constructing plans merely heuristically good.B.1.10 TPSYStpsys (Garrido, Onainda, & Barber, 2001; Garrido, Fox, & Long, 2002) temporalplanner based Graphplan. technical differences tpsys tgp (Smith& Weld, 1999), central use temporal plan graph similar, using graphrepresent passage time, actions associated durations.Graphplan-based approaches, search machinery appears scale badly.B.1.11 VHPOPPartial order planners suffered period unfashionable, supplanted Graphplan and, recently, relaxed-plan-based heuristic state-space search planners. vhpop (Younes & Simmons, 2003) represents interesting indication partial orderplanning far defunct. particular, partial order framework offers powerful way handle temporal constraints. vhpop simple temporal network usedmanage temporal constraints end points durative actions allowsplanner successfully treat concurrency features temporal plan structure.Within framework partial-order planner, vhpop makes use plan graph distanceestimates guide search.52fiThe 3rd International Planning CompetitionB.2 Hand-coded Plannersthree entrants category planners requiring hand-coded control knowledge. 2000 competition teams competing planners allowedtime reformulate domain descriptions include domain-specific control knowledge.results show, control knowledge dramatically improve planner performance. However, difficult assess cost-effectiveness hand-coding control knowledge. FahiemBacchus (2001) observed need quantify time effort required identifyencode useful control knowledge order better able judge trade-offfully-automated hand-coded approaches. However, difficult measureeffort involved. principle possible bound time allowed domainreformulation, differences team sizes experience team membersbecome important comparing achieved different participants.third competition, like it, explore factors, impossiblemake judgements relative effectiveness solutions problems offeredhand-coded planning systems. remains important open issuefuture competitions address.B.2.1 SHOP2shop2 (Nau, Au, Ilghami, Kuter, Murdoch, Wu, & Yaman, 2003) Hierarchical TaskNetwork (htn) planner. Like htn planners, shop2 allows tasks subtaskspartially ordered. Thus plans may interleave subtasks different tasksexpansion tasks. However, unlike htn planners, shop2 generates stepsplan order steps later executed thereforemaintain representation current state stage planning process.makes much easier incorporate substantial expressive power htns usedshop2. example, might include axioms, mixed symbolic numeric computation,even calls external programs.B.2.2 TALPLANNERsuccessful hand-coded planners 2000, talplanner (Kvarnstrom &Magnusson, 2003) uses temporal action logic language describing planning domainsuses control rules guide planner making intelligent choices constructingplans forward search idea originally developed tlplan. rules actprune away search branches predicted (by human encoding rules) leadsolutions. Using idea, possible arrive collection rules that,examination given state, guide planner choose actions effectivelyvirtually search required all.B.2.3 TLPLANtlplan (Bacchus & Kabanza, 2000) also uses temporal logic language supportconstruction control rules guide plan search. tlplan preceded talplanneruse idea. tlplan adopts slightly different approach management tem53fiLong & Foxporal structure talplanner, also capable handling metric quantities.extensions tlplan allow handle time described Bacchus Ady (2001).54fiThe 3rd International Planning CompetitionAppendix C. Statistical Techniquesanalysis conducted paper makes use several standard statistical tests.Wilcoxon matched-pairs rank-sum test, proportion test, matched-pairs t-test,Spearmans rank correlation test rank correlation test agreement multiplejudgements. benefit readers unfamiliar tests, brieflysummarise here. appendix constructed using Gopal K. Kanjis 100 StatisticalTests (1999).C.1 Proportion Testtest also known binomial distribution test. test used considerproportion sample particular qualitative observation made.example, proportion rolls die come 6. test examines farexpected proportion observed proportion, given assumed probabilityobservation. use paper, adopt null hypothesis two plannerswin equal likelihood test proportion observed wins one plannerhypothesis. deviation observed proportion expected proportionsufficiently high, null hypothesis rejected.C.2 t-testt-test parametric test: founded assumption underlying population samples drawn nearly normally distributed. reasonablyrobust failures assumption, treated caution true distribution deviates normal. test considers means two samples testsnull hypothesis two samples drawn populations mean.Variants available according known variance underlying populations. t-test conservative version Z-test, relies effectconfirmed Central Limit Theorem that, large samples, sampling ditributionmean normal. t-test applied smaller samples, compensatingdistortion distribution creates. paper, use variantt-test observations drawn matched pairs: element pair testresult conducted close identical circumstances, different test subject (incase, different planner).n pairs observations, di difference pair meandifference, variance, s, differences given by:2=nX(di d)2i=1n1x1 x2 means samples two populations,statistic is:x1 x2t=s/ nn 1 degrees freedom.55fiLong & FoxC.3 Wilcoxon Matched-Pairs Rank-Sum Testuse ranks releases statistical tests parametric assumptions underlyingdistributions replacing actual observed values rank within ordered setobserved values. Wilcoxon matched-pairs test analogous matched-pairs t-test,uses sum ranks values associated two test subjects.pairs ordered according absolute values differences sumranks positive values compared sum ranks negativevalues. two subjects exhibit particular pattern relative behaviourspositive negative values distributed roughly evenly ranksthus rank-sums approximately equal. distortion rank-sumsindicates one subject consistently superior performance other.test defined follows. Given collection n pairs data items, differencespairs found ranked according absolute magnitude. sumranks formed negative positive differences separately. smallertwo rank sums. sufficiently large samples following value approximatelynormally distributed:n(n + 1)/4)pn(n + 1)(2n + 1)/24C.4 Spearmans Rank Correlation Testtest correlation sequence pairs values. Using ranks eliminatessensitivity correlation test function linking pairs values. particular,standard correlation test used find linear relations test pairs, rankcorrelation test restricted way.Given n pairs observations, (xi , yi ), xi values assigned rank value and,separately, yi values assigned rank. pair (xi , yi ), correspondingdifference, di xi yi ranks found. value R is:R=nXd2ii=1large samples test statistic then:Z=6R n(n2 1)n(n + 1) n 1approximately normally distributed.C.5 Rank Correlation Test Agreement Multiple Judgementstests significance correlation n series rank numbers, assignedn judges K subjects. n judges give rank numbers K subjects compute:S=nK(K 2 1)1256fiThe 3rd International Planning CompetitionSD , sum squares differences subjects mean ranks overallmean rank. Let:D1 =SDD1D2, D2 = D1 , S12 =, S22 =nK 1K(n 1)test statistic is:F =S12S22follows F distribution K 1, K(n 1) degrees freedom.57fiLong & FoxReferencesBacchus, F. (2001). AIPS00 planning competition. AI Magazine, 22(3), 4756.Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaining approach. Proceedings IJCAI-01, pp. 417424.Bacchus, F., & Kabanza, F. (2000). Using temporal logic express search control knowledgeplanning. Artificial Intelligence, 116(1-2), 123191.Blum, A., & Furst, M. (1995). Fast Planning Plan-graph Analysis. ProceedingsIJCAI-95.Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanismplanning. Proceedings AAAI-97, pp. 714719. AAAI/MIT Press.Do, M. B., & Kambhampati, S. (2003). Sapa: scalable, multi-objective, heuristic, metric,temporal planner. Journal Artificial Intelligence Research, issue.Edelkamp, S. (2003). Taming numbers durations model-checking integratedplanning system. Journal Artificial Intelligence Research, issue.Fox, M., & Long, D. (2003). pddl2.1: extension pddl expressing temporalplanning domains. Journal Artificial Intelligence Research, issue.Garrido, A., Fox, M., & Long, D. (2002). Temporal planning PDDL2.1. ProceedingsECAI-02.Garrido, A., Onainda, E., & Barber, F. (2001). Time-optimal planning temporal problems. Proceedings ECP-01.Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local searchtemporal action graphs LPG. Journal Artificial Intelligence Research, issue.Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporalplanner. Proceedings AIPS-94.Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. ProceedingsECP-01, Toledo.Hoffmann, J. (2003a). Metric-FF planning system: Translating ignoring delete listsnumerical state variables. Journal Artificial Intelligence Research, issue.Hoffmann, J. (2003b). ignoring delete-lists works: local search topology planningbenchmarks. Tech. rep. 185, Institut fur Informatik, Albert-Ludwigs Universitat,Freiburg.Hoffmann, J., & Nebel, B. (2000). FF planning system: Fast plan generationheuristic search. Journal Artificial Intelligence Research, 14, 253302.Howe, A., & Dahlman, E. (2002). critical assessment benchmark comparison planning. Journal Artificial Intelligence Research, 17, 133.Kanji, G. (1999). 100 Statistical Tests. Sage Publications.Kvarnstrom, J., & Magnusson, M. (2003). Talplanner 3rd international planningcompetition: Extensions control rules. Journal Artificial Intelligence Research,issue.58fiThe 3rd International Planning CompetitionLaborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings IJCAI-95. Morgan Kaufmann.Long, D. (2000). AIPS98 Planning Competition: Competitors perspective. AI Magazine, 21 (2).McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2).McDermott, D., & AIPS98 Planning Competition Committee (1998). PDDLthe planning domain definition language. Tech. rep., Available at: www.cs.yale.edu/homes/dvm.McDermott, D. (1996). heuristic estimator means ends analysis planning.Proceedings AIPS-96, pp. 142149. AAAI Press.Nau, D., Au, T.-C., Ilghami, O., Kuter, U., Murdoch, J., Wu, D., & Yaman, F. (2003).SHOP2: HTN planning environment. Journal Artificial Intelligence Research,issue.Onainda, E., Sapena, O., Sebastia, L., & Marzal, E. (2001). SimPlanner: executionmonitoring system replanning dynamic worlds. Proceedings EPIA-01.Parker, E. (1999). Making graphplan goal-directed. Proceedings ECP-99, pp. 333346.Penberthy, J., & Weld, D. (1994). Temporal planning continuous change. ProceedingsAAAI-94. AAAI/MIT Press.Porteous, J., Sebastia, L., & Hoffmann, J. (2001). extraction, ordering, usagelandmarks planning. Proceedings ECP-01.Sebastia, L., Onainda, E., & Marzal, E. (2001). SteLLa: optimal sequential parallelplanner. Proceedings EPIA-01.Smith, D. E., & Weld, D. S. (1999). Temporal planning mutual exclusion reasoning.Proceedings IJCAI-99, pp. 326337.Wu, D., & Nau, D. (2002). um-translog-2: planning domain designed AIPS-02. Tech.rep. CS-TR-4402, University Maryland.Younes, H., & Simmons, R. (2003). vhpop: Versatile heuristic partial order planner. JournalArtificial Intelligence Research, issue.59fiJournal Artificial Intelligence Research 20 (2003) 195-238Submitted 6/03; published 12/03Taming Numbers Durations Model CheckingIntegrated Planning SystemStefan Edelkampstefan.edelkamp@cs.uni-dortmund.deBaroper Strae 301Fachbereich Informatik, GB IVUniversitat Dortmund44221 DortmundGermanyAbstractModel Checking Integrated Planning System (MIPS) temporal least commitment heuristic search planner based flexible object-oriented workbench architecture.design clearly separates explicit symbolic directed exploration algorithmsset on-line off-line computed estimates associated data structures.MIPS shown distinguished performance last two international planning competitions. last event description language extended pure propositionalplanning include numerical state variables, action durations, plan quality objectivefunctions. Plans longer sequences actions time-stamped schedules.participant fully automated track competition, MIPS provengeneral system; track every benchmark domain efficiently computed plansremarkable quality. article introduces analyzes important algorithmicnovelties necessary tackle new layers expressiveness benchmarkproblems achieve high level performance.extensions include critical path analysis sequentially generated plans generatecorresponding optimal parallel plans. linear time algorithm compute parallelplan bypasses known NP hardness results partial ordering scheduling plansrespect set actions imposed precedence relations. efficiencyalgorithm also allows us improve exploration guidance: encountered planningstate corresponding approximate sequential plan scheduled.One major strength MIPS static analysis phase grounds simplifiesparameterized predicates, functions operators, infers knowledge minimizestate description length, detects domain object symmetries. latter aspectanalyzed detail.MIPS developed serve complete optimal state space planner,admissible estimates, exploration engines branching cuts. competitionversion, however, certain performance compromises made, including floating pointarithmetic, weighted heuristic search exploration according inadmissible estimateparameterized optimization.1. IntroductionPractical action planning model checking appear closely related. MIPSproject targets integration model checking techniques domain-independentaction planner. HSF-Spin experimental model checker (Edelkamp, Leue, & LluchLafuente, 2003) looking towards integration planning technologyc2003AI Access Foundation. rights reserved.fiEdelkampexisting model checker. Additional synergies exploited automated compilationprotocol software model checking problems planner inputs (Edelkamp, 2003).Model checking (Clarke, Grumberg, & Peled, 1999) automated process verifyformal model system satisfies specified temporal property not. illustrativeexample, take elevator control system together correctness property requireselevator eventually stop every call passenger guarantees doorclosed, elevator moving. Although success checking correctness limited,model checkers found many errors current hardware software designs. Modelsoften consist many concurrent sub-systems. combination either synchronous,often seen hardware design verification, asynchronous, frequently given communication security protocols, multi-threaded programming languages like Java.Model checking requires exploration large state spaces containing reachable system states. problem known state explosion problem occurs evensets generated states much smaller set reachable states.error shows safety property violation, like deadlock failed assertion,corresponds one set target nodes state space graph. Roughly speaking,something bad occured. liveness property violation refers (seeded) cyclegraph. Roughly speaking, something good never occur. case elevatorexample, eventually reaching target state request button pressed livenessproperty, certifying closed doors refers safety property.two main validation processes model checking explicit symbolic search.explicit-state model checking state refers fixed memory location statespace graph implicitly generated successive expansions state.symbolic model checking (McMillan, 1993; Clarke, McMillan, Dill, & Hwang, 1992),(fixed-length) binary encodings system states used, state represented characteristic function representation. function evaluates trueBoolean state variables assigned bit values respect binaryencoding system state. Subsequently, characteristic function conjunctionliterals plain variable 1 encoding negated variable 0. Setsstates expressed disjunction individual characteristic functions.unique symbolic representation sets states Boolean formulae binarydecision diagrams (BDDs) (Bryant, 1992) often much smaller explicit one. BDDs(ordered) read-once branching programs nodes corresponding variables, edgescorresponding variable outcomes, path corresponding assignmentvariables resulting evaluation leaves. One reason succinctnessBDDs directed acyclic graphs may express exponentially many paths. transitionrelation defined two state variable sets. evaluates true, operatorexists transforms state valid successor. sense, BDDs exploit regularitiesstate set often appear well suited regular hardware systems. contrast, manysoftware systems inherit highly asynchronous irregular structure, useBDDs fixed variable ordering generally flexible enough.symbolic exploration, set states combined transition relationcompute set possible successor states, i.e. image. Starting initialstate, iteration image computations eventually explores entire reachable state space.196fiTaming Numbers Durations MIPSimprove efficiency image computations, transition relations often providedpartitioned form.correspondence action model checking (Giunchiglia & Traverso, 1999)roughly characterized follows. Similar model checkers, action planners implicitly generate large state spaces, exploration approaches based applyingoperators current state. States spaces model checking planning problemsoften modelled Kripke structures, i.e. state space graphs states labelled propositional predicates. satisfaction specified property one side correspondscomplete exploration, unsolvable problem side. respect,goal action planning cast error corresponding trail interpretedplan. elevator example, goal planning task reach state,doors open elevator moving. Action planning refers safety properties only,since goal achievement traditional competition planning problems yetextended temporal properties. However, temporally extended goals increasingresearch interest (Kabanza, Barbeau, & St-Denis, 1997; Pistore & Traverso, 2001; Lago,Pistore, & Traverso, 2002).contrast model checkers perform either symbolic explicit exploration, MIPSfeatures both. Moreover, combines symbolic explicit search planning formsymbolic pattern databases (Edelkamp, 2002b). planner MIPS implements heuristicsearch algorithms like A* (Pearl, 1985) IDA* (Korf, 1985) exploration, includestate-to-goal approximation search process rank states expanded next.Heuristic search brought considerable gains planning (Bonet & Geffner, 2001;Refanidis & Vlahavas, 2000; Hoffmann & Nebel, 2001; Bertoli, Cimatti, & Roveri, 2001a;Jensen, Bryant, & Veloso, 2002; Feng & Hansen, 2002) model checking (Yang & Dill,1998; Edelkamp et al., 2003; Groce & Visser, 2002; Bloem, Ravi, & Somenzi, 2000; Ruys,2003).Including resource variables, like fuel level vehicle distance twodifferent locations, well action duration relatively new aspects competitiveplanning (Fox & Long, 2003). input format PDDL2.1 restricted variablesfinite domain, also includes rational (floating-point) variables preconditioneffects. Similar set atoms described propositional predicate, set numericalquantities described set parameters. notation PDDL2.1,refer parameterized numerical quantities functions. example, fuel level mightparameterized vehicle present problem instance file description.competition, domains provided different tracks according different layers language expressiveness: i) pure propositional planning, ii) planning numericalresources, iii) planning numerical resources constant action duration, iv) planningnumerical resources variable action duration, and, cases, v) complex problems usually combining time numbers interesting ways. MIPS competedfully automated system performed remarkably well five tracks; solved largenumber problems fully automated planner produced solutionstrack every benchmark domain.paper main algorithmic techniques taming rational numbers, objectivefunctions, action duration described. article structured follows. First,review development MIPS system assert main contributions.197fiEdelkampaddress object-oriented heuristic search framework system. Subsequently,introduce terminology allows us give formal definition syntaxsemantics grounded mixed numerical propositional planning problem instance.introduce core contributions: critical path scheduling concurrent plans,efficient methods detecting using symmetry cuts. PERT scheduling producesoptimal parallel plans linear time given sequence operators precedence relationamong them. paper discusses pruning anomalies effect different optimizationcriteria. analyze correctness efficiency symmetry detection detail.article closes related work concluding remarks.2. Development MIPScompetition version MIPS refers initial work (Edelkamp & Reffel, 1999a)heuristic symbolic exploration planning domains cke model checker (Biere,1997). approach effective sample puzzle solving (Edelkamp & Reffel, 1998)hardware verification problems (Reffel & Edelkamp, 1999).implementing propositional planner, first used BDD library calledStaticBdd, large node tables allocated prior use. implementation process changed BDD representation mainly improve performancesmall planning problems. selected public domain c++ BDD package Buddy (LindNielsen, 1999), flexible. planning process semi-automated (Edelkamp& Reffel, 1999b); variable encodings provided hand, representationsoperators established enumerating possible parameter instances.state space encoding action transition relation fixed, exploration formsymbolic breadth-first search state-space could executed. time,aware work BDD-based planning work Cimatti et al.(1997), likely first link planning via symbolic model checking. team usedmodel checker (nu)SMV basis atom-to-variable planning state encodingscheme top it.Later on, developed parser static analyzer automate inference stateencodings, generation transition relations, extraction solution paths.order minimize length state encoding, new analyzer clustered atomsgroups (Edelkamp & Helmert, 1999). confirmed attempts (Weismuller, 1998),started experimenting PDDL specification cke, state minimization factcrucial. simple encoding using one variable atom appears competitiverespect Graphplan-based (Blum & Furst, 1995) SAT-plan based planners (Kautz& Selman, 1996). Subsequently, MIPS first fully automated planning system basedsymbolic model checking technology could deal large domain descriptions.second international planning competition MIPS (Edelkamp & Helmert, 2001)could handle STRIPS (Fikes & Nilsson, 1971) subset PDDL language (McDermott, 2000) additional features ADL (Pednault, 1989), namely negativepreconditions (universal) conditional effects. MIPS one five planning systemsawarded Distinguished Performance fully automated track. competitionversion (Edelkamp & Helmert, 2000) already included explicit heuristic search algorithmsbased bit-vector state representation relaxed planning heuristic (RPH) (Hoff198fiTaming Numbers Durations MIPSmann & Nebel, 2001) well symbolic heuristic search based HSP heuristic (Bonet& Geffner, 2001) one-to-one atom derivative RPH. competition, usedbreadth-first bi-directional symbolic search whenever single state heuristic search enginegot stuck exploration.planning competitions, explicit (Edelkamp, 2001c) symbolic patterndatabases (Edelkamp, 2002b) proposed off-line estimators completely exploredproblem abstractions. Roughly speaking, pattern database abstractions slice state vector fluents pieces adjust operators accordingly. completely exploredsubspaces serve admissible estimates overall search competitiverelaxed planning heuristic several benchmark domains.third planning competition new levels planning domain description language (PDDL) designed. Level 1 considers pure propositional planning. Level 2 alsoincludes numerical resources objective functions minimized. Level 3 additionallyallows specification actions durations. Consequently, MIPS extendedcope new forms expressiveness.First results MIPS planning PDDL2.1 problems presented (Edelkamp,2001b). preliminary treatment illustrates parsing process two simple benchmark domains. Moreover, propositional heuristics manual branching cuts appliedaccelerate sequential plan generation. work extended (Edelkamp, 2002a),presented two approximate exploration techniques bound fix numericaldomains, first results symmetry detection based fact groups, critical path scheduling,any-time wrapper produce optimal plans, numerical extension RPH.3. Architecture MIPSFigure 1 shows main components MIPS data flow input definitiondomain problem instance resulting temporal plan output.shown shaded light gray, MIPS divided four parts: pre-compilation, heuristics,search algorithms, post-compilation (scheduling). Henceforth, planning processcoarsely grouped three stages, pre-compilation, heuristic search planning,construction temporal plans. problem domain description files fedsystem, analyzed grounded. fixes state space problem solved.intermediate result implicit, saved file use planners modelcheckers. basics pre-compilation covered Section 3.2.next stage defines planning process. object-oriented workbench designplanner allows different heuristic estimates combined different searchstrategies access data structures. Possible choices listed Sections 3.3 3.4.Temporal planning based (PERT) scheduling. issue rearranging sequential(relaxed) plans addressed detail Section 4.3.planning system developed spirit heuristic search framework,HSF short (Edelkamp, 1999), allows attachment newly implemented problem(puzzle) domains already compiled system. Similar approach tookmodel checking within HSF-Spin, kept extensible general design. factcharacterized action planning protocol validation single-agent challenges.contrast model checking approach, planning devised hierarchy system199fiEdelkampdomain.pddlproblem.pddlPrecompilerstatic analyzergroundsymmetryclusterintermediate representationHeuristicsexplicit PDBssymbolic PDBsnumericalRPHSearch Algorithmsrelaxed plansymbolic searchexplicit searchRPHBDDA*, BDD-BFSA*, IDA*, EHCschedulingRPHsequential planrelaxedtemporal planSchedulerCritical Pathtemporal planPERTFigure 1: Architecture MIPS.states: implementation numerical states derived class one propositionalstates.Similarily, heuristic search algorithms based abstract search class.main procedures provided search algorithm state expansionprocedure, heuristic search evaluation function, located one hierarchically organized heuristic estimator classes. sense, algorithms MIPS generalnode expanding schemes adapted different problems. Additional datastructures horizon list Open visited list Closed constructed parameters appropriate search algorithms. result, implementations heuristicsearch algorithms associated data structures planner MIPS almost matchmodel checker.3.1 Example Problemrunning example paper instance rather simple PDDL2.1 problemZeno-Travel. illustrated Figure 2. initial configuration drawn left200fiTaming Numbers Durations MIPSScottBDanC1000C600B80010008001000Ernie6001000ScottErnieDanFigure 2: instance Zeno-Travel domain initial state (left) goal state(s)(right).figure goal configuration right. global local numeric variableassignments shown.Figures 3 4 provide domain problem specifications1 . instance askstemporal plan fly passengers (dan, scott, ernie) located somewhere smallmap (including cities city-a, city-b, city-c, city-d) aircraft (plane)respective target destinations. Boarding debarking take constant amounttime. plane fixed fuel capacity. Fuel time consumed accordingdistances cities travel speed. Fuel restored refuelingaircraft. result, total amount fuel also maintained numerical quantity.3.2 Precompilerstatic analyzer takes domain problem instance input, grounds propositional state information infers different forms planner independent static information.Parsing simple Lisp parser generates tree Lisp entities. reads input filesrecognizes domain problem name. cope variable typing, temporarily assert constant typed predicates removed together constantpredicates pre-compilation step. Thereby, infer type hierarchyassociated mapping objects types.Indexing Based number counted objects, indices grounded predicates,functions actions devised. Since example problem eight objects predicates two parameters, reserve 2 8 8 = 128index positions. Similarly, function distance consumes 64 indices, fuel,1. [...] denotes source fragments omitted sake brevity. given exampleaction definitions passenger debarking flying airplane.201fiEdelkamp(define (domain zeno-travel)(:requirements :durative-actions :typing :fluents)(:types aircraft person city)(:predicates (at ?x - (either person aircraft) ?c - city)(in ?p - person ?a - aircraft))(:functions (fuel ?a - aircraft) (distance ?c1 - city ?c2 - city)(slow-speed ?a - aircraft) (fast-speed ?a - aircraft)(slow-burn ?a - aircraft) (fast-burn ?a - aircraft)(capacity ?a - aircraft)(refuel-rate ?a - aircraft)(total-fuel-used) (boarding-time) (debarking-time))(:durative-action board:parameters (?p - person ?a - aircraft ?c - city):duration (= ?duration boarding-time):condition (and (at start (at ?p ?c))(over (at ?a ?c))):effect (and (at start (not (at ?p ?c)))(at end (in ?p ?a))))[...](:durative-action zoom:parameters (?a - aircraft ?c1 ?c2 - city):duration (= ?duration (/ (distance ?c1 ?c2) (fast-speed ?a))):condition (and (at start (at ?a ?c1))(at start (>= (fuel ?a) (* (distance ?c1 ?c2) (fast-burn ?a))))):effect (and (at start (not (at ?a ?c1)))(at end (at ?a ?c2))(at end (increase total-fuel-used(* (distance ?c1 ?c2) (fast-burn ?a))))(at end (decrease (fuel ?a)(* (distance ?c1 ?c2) (fast-burn ?a))))))(:durative-action refuel:parameters (?a - aircraft ?c - city):duration (= ?duration (/ (- (capacity ?a) (fuel ?a)) (refuel-rate ?a))):condition (and (at start (< (fuel ?a) (capacity ?a)))(over (at ?a ?c))):effect (at end (assign (fuel ?a) (capacity ?a)))))Figure 3: Zeno-Travel domain description PDDL2.1.slow-speed, fast-speed, slow-burn, fast-burn, capacity, refuel-ratereserve eight index positions. quantities total-fuel-used, boarding-time,debarking-time single fact identifier needed. Last least modelduration additional quantity total-time. special variable oneoverwritten least commitment planning approach scheduling plansdescribed Section 4.202fiTaming Numbers Durations MIPS(define (problem zeno-travel-1)(:domain zeno-travel)(:objects plane - aircrafternie scott dan - personcity-a city-b city-c city-d - city)(:init (= total-fuel-used 0) (= debarking-time 20) (= boarding-time 30)(= (distance city-a city-b) 600) (= (distance city-b city-a) 600)(= (distance city-b city-c) 800) (= (distance city-c city-b) 800)(= (distance city-a city-c) 1000) (= (distance city-c city-a) 1000)(= (distance city-c city-d) 1000) (= (distance city-d city-c) 1000)(= (fast-speed plane) (/ 600 60)) (= (slow-speed plane) (/ 400 60))(= (fuel plane) 750)(= (capacity plane) 750)(= (fast-burn plane) (/ 1 2))(= (slow-burn plane) (/ 1 3))(= (refuel-rate plane) (/ 750 60))(at plane city-a) (at scott city-a) (at dan city-c) (at ernie city-c))(:goal (and (at dan city-a) (at ernie city-d) (at scott city-d)))(:metric minimize total-time))Figure 4: Zeno-Travel problem instance.Flattening Temporal Identifiers interpret action integral entity,timed propositional numerical preconditions merged. Similarly,effects merged, independent time happen. Invariant conditionslike (over (at ?a ?c)) action board added precondition set.discuss rationale step Section 4.1.Grounding Propositions Fact-space exploration relaxed enumeration planningproblem determine superset reachable facts. Algorithmically, FIFO factqueue compiled. Successively extracted facts front queue matchedoperators. time preconditions operator fulfilled, resultingatoms according positive effect (add) list determined enqueued.allows us separate constant facts fluents, since latter reachedexploration.Clustering Atoms concise encoding propositional part separate fluentsgroups, state planning space expressed conjunction (possibly trivial) facts drawn fact group (Edelkamp & Helmert,1999). precisely, let #pi (o1 , . . . , oi1 , oi+1 , . . . , ) number objects oifact (p o1 . . . ) true. establish single-valued invariant#pi (o1 , . . . , oi1 , oi+1 , . . . , ) = 1. allow better encoding, predicateslike merged. example, three groups determine unique positionpersons (one five) one group determines position plane (onefour). Therefore, 3 dlog 5e + 1 dlog 4e = 11 bits suffice encode total 19fluents.203fiEdelkampGrounding Actions Fact-space exploration also determines grounded operators.preconditions met grounded, symbolic effect lists instantiated.case determine 98 instantiated operators, which, simplificationseliminate duplicates trivial operators (no-ops), reduced 43.Grounding Functions Simultanous fact space exploration propositional partproblem, heads numerical formulae effect lists grounded.example case three instantiated formulae fluent (vary time): (fuelplane) initial value 750 well total-fuel-used total-time initialized zero. numerical predicates fact constantssubstituted formula-bodies. example, effect (board dan city-a)reduces (increase (total-time) 30), (zoom plane city-a city-b)numerical effects (increase (total-time) 150),(increase (total-fuel-used)300)), (decrease (fuel plane) 300). Refuelling, however, reducesingle rational number, example effects (refuel plane city-a)simplify (increase (total-time) (/ (- (750 (fuel plane)) / 12.5)))(assign (fuel plane) 750). evaluate former assignment especially forward chaining planner, variable (total-time) instantiated on-the-fly.due fact value quantity (fuel plane) constantchanges time.Symmetry Detection Regularities planning problem respect transposition domain objects partially determined static analyzer addresseddetail Section 5.intermediate textual format static analyzer annotated grounded PDDLlike representation serves interface planners model checkers,additional resource plan visualization. Figures 5 6 show parts intermediaterepresentation inferred Zeno-Travel example.3.3 HeuristicsMIPS incorporates following heuristic estimates.Relaxed planning heuristic (RPH) Approximation number planning stepsneeded solve propositional planning problem delete effects removed (Hoffmann & Nebel, 2001). heuristic constructive, returns setoperators appear relaxed plan.Numerical relaxed planning heuristic (numerical RPH) extension RPHdeal numbers combined propositional numerical approximationscheme allowing multiple operator application.Pattern database heuristic (explicit PDB) Different planning space abstractionsfound greedy manner, yielding selection pattern databases fit mainmemory. contrast RPH, pattern database designed disjoint yieldingadmissible estimate needed optimal planning A* (Edelkamp, 2001c).204fiTaming Numbers Durations MIPS(define (grounded zeno-travel-zeno-travel-1)(:fluents(at dan city-a)(at dan city-b)(at dan city-c)(at dan city-d)(at ernie city-a) (at ernie city-b) (at ernie city-c) (at ernie city-d)(at plane city-a) (at plane city-b) (at plane city-c) (at plane city-d)(at scott city-a) (at scott city-b) (at scott city-c) (at scott city-d)(in dan plane)(in ernie plane) (in scott plane))(:variables (fuel plane) (total-fuel-used) (total-time))(:init(at dan city-c)(at ernie city-c) (at plane city-a) (at scott city-a)(= (fuel plane) 750) (= (total-fuel-used) 0) (= (total-time) 0))(:goal (at dan city-a)(at ernie city-d) (at scott city-d))(:metric minimize (total-time) )(:group dan(at dan city-a)(at dan city-b)(at dan city-c)(at dan city-d)(in dan plane))(:group ernie(at ernie city-a) (at ernie city-b) (at ernie city-c) (at ernie city-d)(in ernie plane))(:group plane(at plane city-a) (at plane city-b) (at plane city-c) (at plane city-d))(:group scott(at scott city-a) (at scott city-b) (at scott city-c) (at scott city-d)(in scott plane))Figure 5: Grounded representation Zeno-Travel domain.Symbolic pattern database heuristic (symbolic PDB) Symbolic PDBs apply explicit symbolic heuristic search engines (Edelkamp, 2002b). Due succinctBDD-representation sets states, symbolic PDBs often orders magnitudeslarger explicit ones.Scheduling relaxed plan heuristic (scheduling RPH) Critical-path analysisscheduling guide plan finding phase. Like RPH, computes lengthgreedily extracted sequential plan, scheduling RPH also takes relaxed sequenceoperators account, searches suitable parallel arrangement,turn defines estimator function.3.4 Exploration Algorithmsalgorithm portfolio includes three main explicit heuristic search algorithms.A* A* algorithm (Hart, Nilsson, & Raphael, 1968) variant Dijkstras singlesource shortest path exploration scheme executed re-weighted state space graph.lower bound heuristics, A* shown generate optimal plans (Pearl, 1985).Weighting influence heuristic estimate may accelerate solution finding,also affects optimality (Pohl, 1977).205fiEdelkamp(:action board dan plane city-a:condition(and (at dan city-a) (at plane city-a)):effect(and (in dan plane) (not (at dan city-a))(increase (total-time) (30.000000))))[...](:action zoom plane city-a city-b:condition(and(at plane city-a)(>= (fuel plane) (300.000000))):effect(and (at plane city-b) (not (at plane city-a))(increase (total-time) (60.000000))(increase (total-fuel-used) (300.000000))(decrease (fuel plane) (300.000000))))[...](:action refuel plane city-a:condition(and(at plane city-a)(< (fuel plane) (750.000000))):effect(and(increase (total-time) (/ (- (750.000000) (fuel plane)) (12.500000)))(assign (fuel plane) (750.000000))))[...])Figure 6: Grounded representation Zeno-Travel domain (cont.).Iterative-Deepening A* (IDA*) memory-limited variant A* suited largeexploration problems evaluation functions small integer range low timecomplexity (Korf, 1985). IDA* extended bit-state hashing (Edelkamp &Meyer, 2001) improve duplicate detection respect ordinary transpositiontables (Reinefeld & Marsland, 1994).(Enforced) Hill Climbing (HC) approach another compromise exploration exploitation. Enforced HC searches improved evaluationbreadth-first manner commits established action selections final (Hoffmann,2000). Enforced HC complete undirected problem graphs.MIPS also features following two symbolic search algorithms2 .2. non-deterministic domains, started implementing weak, strong strong cyclic exploration algorithms (Cimatti, Roveri, & Traverso, 1998).206fiTaming Numbers Durations MIPSBidirectional Symbolic Breadth-First-Search (BDD-BFS) implementation performs bidirectional blind symbolic search, choosing next search direction favorfaster execution previous iterations (Edelkamp & Helmert, 1999).Symbolic A* (BDDA*) algorithm (Edelkamp & Reffel, 1998) performs guided symbolic search takes (possibly partitioned) symbolic representation heuristicadditional input.3.5 Composition Competition VersionFigure 1 shaded parts actually used competition versionMIPS dark gray. used relaxed planning heuristic sequential plan generation.scheduling relaxed planning heuristic used temporal domains. Level 2problems use numerically extended RPH, since added systemfinal weeks competition. experimented (symbolic) pattern databasesmixed results. Since pattern databases purely propositional implementationprovide retrieval operators optimal abstract plan, includecompetition version.approach extend relaxed planning heuristic numerical information helpsfind plans challenging numerical domains like Settlers influenced Hoffmanns work competing planner Metric-FF (Hoffmann, 2002a). builds relaxedplanning graph computing fixed-point state vector restricted monotonicallyincreasing propositional numerical variables. version integrating numbersrelaxed planning heuristic general Hoffmanns contribution: restrictedvariable-to-constant comparisons lacks ability simplify linear constraints.Therefore, omit algorithmic details paper.decided employ (enforced) hill climbing explicit plan generation doneMetric-FF probably LPG. Instead applied A* weight 2, meritstates fixed f (S) = g(S) + 2 h(S). conservative plan generationengine chosen avoid unrecognized dead-ends, expected presentbenchmark problems. objective that, least, completeness preserved.also avoided known incomplete pruning rules, like action relevance cuts (Hoffmann &Nebel, 2001) goal ordering cuts (Koehler & Hoffmann, 2000).MIPS, (weighted) A* accesses Dial Weak-Heap priority queue datastructure. former used propositional planning only, latter appliesgeneral planning scheduling estimates. Dial priority queue (Dial, 1969) linearrun time behavior, maximal value w(u, v) + h(v) h(u) edges (u, v)weighted state space graph (labelled heuristic h) bounded constant. WeakHeaps (Edelkamp & Stiegeler, 2002) simple efficient relaxations ordinary heaps.Priority queues implemented dynamic tables double sizesbecome filled. Moreover, MIPS stores generated expanded states hash tablechaining 3 . compression planning state space, variablesappear objective function neglected hash address calculations state3. alternative storage structure collection persistent trees (Bacchus & Kabanza, 2000), onepredicate. best case, queries update times structure logarithmic numberrepresented atoms.207fiEdelkampcomparisons. general, may lead sub-optimal pruning duplicates. However,benchmark domains destroy optimality, since variables addressedobjective function frequently monotonic synonyms found later searchrefer worse solutions.price paid selecting A*, especially planning problems large branching factors, storing frontier nodes space consuming. Recent techniquespartial expansion horizon list (Yoshizumi, Miura, & Ishida, 2000) reduced storagevisited list (Korf & Zhang, 2000; Zhou & Hansen, 2003) includedsystem. cases, number expanded nodes often large,computing relaxed planning estimate appeared computational bottleneck.retrospect, domains chosen, dead-ends central, hillclimbers appeared effective finding solutions.temporal domains introduced additional parameter scale influencepropositional estimates (fp (S) = gp (S) + 2 hp (S)) scheduled ones (fs (S) =gs (S) + 2 hs (S)). precisely, altered comparison function priority queue,comparison parallel length priorities invoked propositional differencevalues larger IN0 . higher value refers higher influencescheduling RPH, = 0 indicates scheduling all. competition produceddata = 0 (pure MIPS), = 2 (optimized MIPS). comparisons MIPSplanners plain version used, since produces solutions.(Edelkamp, 2002a) experimented enumeration approach fix numericalvariables finite domain, any-time wrapper optimization objectivefunctions. options excluded competition versionunpredictable impact planners performance.3.6 VisualizationVisualization important ease plan understanding quickly detect inefficienciesplan generation module. visualization plans MIPS extendedanimation system Vega (Hipke, 2000); Client-Server architecture runs annotatedalgorithm server side, visualized client side Java frontend.main purpose server make algorithms accessible TCP/IP. ablereceive commands multiple clients time. extended Vega twoways (cf. Figures 7 8).Gannt Chart Visualization Gannt Charts representations schedules,horizontal bars drawn activity, indicating estimated duration/cost.user selects planner executed domain problem file,interpreted command line options. Alternatively, established plans sentdirectly visualizer void planner merely mirrors solution file.Benchmark Visualization second extension program suite visualize competition domains. moment, sequential plans shown. temporalplans, refined simulation required, like one produced PDDL2.1 planvalidator. Fortunately, MIPS temporal plan rescheduling sequentialone.208fiTaming Numbers Durations MIPSFigure 7: Visualization plan Gannt Chart format.images represent domain objects collected image web searchengine4 . generalize specific instances, advised MIPS planner exportpropositional numeric state infomation established plan c-like syntax,turn included header domain visualizer.4. PDDL2.1 Planningsection elaborate metric temporal planning MIPS. give formaldescription grounded planning instances introduce temporal model4. used Google (cf. www.google.de) searched small GIFs209fiEdelkampFigure 8: Visualization planning problem instance Settlers.chosen. Next look operator dependency resulting action precedence relation.discuss optimality approach anomalies occur statespace pruning. Last least, turn treatment arbitrary plan objectivefunctions.Table 1 displays basic terminology sets used paper. currentlysuccessful planning system, MIPS grounds parameterized information present domaindescription. set infer suitable index set, indicated bijective mappingset finite domain. embedding important deal unique identifiersentities instead textual internal representation. arrays containingcorresponding information accessed constant time.210fiTaming Numbers Durations MIPSSetOBJYPEPREDFUN CACTFVDescriptorobjectsobject typespredicatesfunctionsactionsoperatorsfluents/atomsvariablesExample(s)dan, city-a, plane, . . .aircraft, person, . . .(at ?a ?c), (in ?p ?a), . . .(fuel ?a), (total-time), . . .(board ?a ?p), (refuel ?a), . . .(board plane scott), . . .(at plane city-b), . . .(fuel plane), (total-time), . . .Table 1: Basic set definitions.Consequently, like several planning systems, MIPS refers grounded planningproblem representations.Definition 1 (Grounded Planning Instance) grounded planning instance quadrupleP = hS, I, O, Gi, set planning states, initial state, Gset goal states. mixed propositional numerical planning problem statespace given2F IR|V| ,2F power set F. Therefore, state pair (Sp , Sn ) propositionalpart Sp 2F numerical part Sn IR|V| .sake brevity, assume operators normal form, meanspropositional parts (preconditions effects) satisfy standard STRIPS notation (Fikes &Nilsson, 1971) numerical parts given form arithmetic trees takenset trees arithmetic operations nodes numerical variablesevaluated constants leaves. However, fundamental differencegeneral representation preconditions effects. current implementation MIPSsimplifies ADL expressions preconditions takes generic precondition treesnumerical parts, thereby including comparison symbols, logical operators arithmeticsubtrees5 .Definition 2 (Syntax Grounded Planning Operators) operator normal form= (, , , ) propositional preconditions F, propositional effects = (a , )F 2 add list delete list , numerical preconditions , numerical effects .numerical precondition c triple c = (hc , , tc ), hc V, {, <, =, >, },tc , arithmetic tree. numerical effect triple =(hm , , tm ), hm V, {, , } tm . case, call hm headnumerical effect.5. newer versions MIPS mixing numerical logical preconditions form (or P (< F 3)),P F F V fact feasible. Boolean expressions put negational normal formdisjunction precondition produce different action instantiations.211fiEdelkampObviously, {, <, =, >, } represents associated comparison relation, denotes assignment variable, indicate respective increase decreaseoperation.Definition 3 (Constraint Satisfaction Modifier Update) Let index mappingvariables. vector Sn = (S1 , . . . , S|V| ) numerical variables satisfies numericalconstraint c = (hc , , tc ) S(hc ) eval(Sn , tc ) true, eval(Sn , tc ) IRobtained substituting v V tc S(hc ) followed simplification tc .0 ) modifiervector Sn = (S1 , . . . , S|V| ) updated vector Sn0 = (S10 , . . . , S|V|= (hm , , tm ) ,0S(h= eval(Sn , tm ) = ,m)0S(h= S(hm ) + eval(Sn , tm ) = ,m)0S(h= S(hm ) eval(Sn , tm ) = .m)next formalize application planning operators given state.Definition 4 (Semantics Grounded Planning Operator Application) operator =(, , , ) applied state = (Sp , Sn ), Sp 2F Sn IR|V| , yields successorstate 0 = (Sp0 , Sn0 ) 2F IR|V| follows.Sp Sn satisfies c Sp0 = (Sp \ ) vector Sn updated.propositional update Sp0 = (Sd \ ) defined standard STRIPS.example take state = (Sp , Sn )Sp = {(at ernie city-d), (at plane city-a), (at scott city-d), (in dan plane)}Sn = {(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 710}.successor Sn0 = (Sp0 , Sn0 ) due action (debark dan plane city-a)Sp0 = {(at dan city-a), (at ernie city-d), (at plane city-a), (at scott city-d)}Sn0 = {(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 730}.effect lists order update operations important. examplerefuelling aircraft ZenoTravel, cf. Figure 6, fuel level reset variabletotal-time updated.set goal states G often given G = (Gp , Gn ) partial propositional statedescription Gp F, Gn set numerical conditions c = (hc , , tc ). Moreover,arithmetic trees tc usually collapses simple leaves labelled numerical constants.Hence, sake simplifying complexity analysis object symmetrymight assume |Gn | |V|. Complex goal description limitation planner,since easily transformed preconditions goal-enabling opererator.212fiTaming Numbers Durations MIPS4.1 Temporal Modelsimplest approach solving temporal planning problem generate sequentialplan. course, option assumes temporal structure contributesvalue plan correctness. is, assumes necessaryconcurrency valid plan. cases actions achieve conditions startpoints delete end points, example, concurrency necessarypart structure valid plan.Definition 5 (Sequential Plan) solution planning problem P = hS, I, O, Giform sequential plan ordered sequence operators Oi O, {1, . . . , k},transforms initial state one goal states G G, i.e., existssequence states Si S, {0, . . . , k}, S0 = I, Sk = G Si outcomeapplying Oi Si1 , {1, . . . , k}.time stamp ti durational operator Oi , {1, . . . , k} starting time.Pi1d(Oj ).d(Oi ) duration operator Oi , ti = j=1sequential plans, time stamps calculated MIPS using extra variabletotal-time. variable updated scheduling operators. example sequential plan time stamps shown Figure 12.Minimizing sequential plan length objective first second planning competitions. Since Graphplan-like planners (Blum & Furst, 1995) like IPP (Koehler,Nebel, & Dimopoulos, 1997) STAN (Long & Fox, 1998) already produced parallel plans(assuming action duration 1), indeed limiting factor evaluating plan quality.important reason artificial restriction total-ordered planseasier automatically validate, necessity checking correctness competition.PDDL 2.1 domain descriptions include temporal modifiers start, all, end,label start denotes preconditions effects invocation timeaction, refers invariance condition end finalization conditionsconsequences action.Figure 9 show two different options flattening information simplepreconditions effects order derive semantic sequential plans. firstcase (top right), compound operator split three smaller parts, one actioninvocation, one invariance maintenance, one action termination.semantics suggested (Fox & Long, 2003).PDDL2.1 effects invariance pattern, i.e. B 0 = . actionboard, quite natural code invariance form conditions (B) performactual status change: person boards aircraft city aircraft requiredremain city throughout action. moving corridor, statuscorridor could encoded invariant would change startingtime action execution.Moreover, found benchmarks uncommon new effects at-startpreconditioned termination control invariance maintenance, i.e. A0 (B C) = .Even though intersection conditions effects formally defined yet,interpreted executing one construct interfere one. reflects213fiEdelkamppre: eff: pre: eff: pre: eff:at-startover-allat-endcond:BCeff:A0B0C0A0pre:B B0C C0eff:ABCA0 B 0 C 0Figure 9: Compiling temporal modifiers operators.possible partition operator sub-operators A, B, C, A0 , B 0 , C 0 . Dependencetransposition separated conditions effects considered Section 4.2.consider example problem more, observe, action board, A0consists (person airplane) predicate. seen above, B requires plane staycity boarding, C empty. action zoom, A0 contains effectplane longer location flight started, B C empty.cases A0 (B C) = .B 0 = A0 (B C) = sequential execution sequencesub-operators (A, A0 , B, B 0 , C, C 0 ) equal execution sequence (A, B, C, A0 , B 0 , C 0 ).reasoning follows. Since B 0 = (A, A0 , B, B 0 , C, C 0 ) = (A, A0 , B, C, C 0 ).Conditions A0 B = A0 C = allows us exchange order correspondingitems, (A, A0 , B, C, C 0 ) = (A, B, C, A0 , C 0 ). more, apply B 0 = derive(A, B, C, A0 , C 0 ) = (A, B, C, A0 , B 0 , C 0 ). consequence remains valid conditionB 0 = weakened B 0 C = .MIPS operator representation bottom right Figure 9 chosen. Noteintermediate format example problem Figures 5 6 implicitly assumedtemporal model. sequential planning competition benchmark domainsobserved many deficiencies model6 .However, applicability model exploiting parallelism limited. exampleconsider two people lift table two sides once, could doneone person alone. case parallel execution set actionscannot totally ordered. allowed MIPS. may argued definingaction requires two different persons certain place would requireequality construct PDDL form numerical maintenance numberpeople room, found another (artificial) example planning problemtotal order. Consider simple STRIPS planning problem domain = {B},G = {{A, C}}, = {({B}, {A}, {B}), ({B}, {C}, {B})}. Obviously, operatorsneeded goal achievement, sequential plan length 2, since Bdeleted operators. However, parallel plan could devised, since preconditionfulfilled first time step.6. current versions MIPS refined model, at-start, all, at-end informationpreserved grounding process attached action. approach allowdependent operators overlap minimizes number gaps, start-start, start-endend-end exclusions. domains, improvement yields much better solutions.214fiTaming Numbers Durations MIPS4.2 Operator Dependencydefinition operator dependency enables computing optimal schedules sequentialplans respect generated action sequence causal operator dependencystructure. operators dependent (or void respect optimizer function),problem inherently sequential schedule leads improvement.Definition 6 (Dependency/Mutex Relation) Let L(t) denote set leaf variablestree . Two grounded operators = (, , , ) O0 = (0 , 0 , 0 , 0 )dependent/mutex, one following three conflicts hold.Propositional conflict propositional precondition set one operator nonempty intersection add delete list other, i.e., (a0 d0 ) 6=(a ) 0 6= .Direct numerical conflict head numerical modifier one operator containedcondition one, i.e. exists c0 = (h0c , , t0c ) 0= (hm , , tm ) hm L(t0c ) {h0c } exists c = (hc , , tc )m0 = (h0m , , t0m ) 0 h0m L(tc ) {hc }.Indirect numerical conflict head numerical modifier one operator contained formula body modifier one, i.e., exists= (hm , , tm ) m0 = (h0m , , t0m ) 0 hm L(t0m ) h0m L(tm ).example, operators (board scott plan city-a) (fly plane city-acity-c) propositional conflict fluent (at plane city-a), (refuelplane-a city-a) (fly plane city-a city-c) direct numerical conflictvariable (fuel plane). Indirect conflicts subtle, appearexample problem.use dependency find optimal concurrent arrangement operatorssequential plan. O2 dependent O1 O1 appears O2 sequentialplan, O1 invoked O2 starts. dependence relation reflexive, i.e.conflict O0 O0 conflict O. Moreover, appears restrictivecompared PDDL 2.1 guidelines mutual exclusion (Fox & Long, 2003),allows operators partially overlapping even dependent.However, possible generalize approach. If, according model FoxLong, two actions Oi represented (Ai , A0i , Bi , Bi0 , Ci , Ci0 ), {1, 2},dependency violation O1 O2 located identifying sub-operatorsinteract. fact may identify eight possible refined conflicts (A1 A01 )interacts (A2 A02 ), (A1 A01 ) interacts (B2 B20 ), (A1 A01 ) interacts(C2 C20 ), (B1 B10 ) interacts (A2 A02 ), (B1 B10 ) interacts (C2 C20 ), (C1 C10 )interacts (A2 A02 ), (C1 C10 ) interacts (A2 A02 ), (C1 C10 ) interacts(A2 A02 ). asserting duration zero pair (Ai , A0i ), d(A) (Bi , Bi0 ), zeropair (Ci , Ci0 ), one fix earliest start end time O2 respect O1 .competition version MIPS, stick simplified temporal model.competition domains, improving sequential plans according dependency relationturned produce plans sufficient quality.215fiEdelkampimplementation, dependence relation computed beforehand tabulatedconstant time access. improve efficiency pre-computation, set leafvariables maintained array, grounded operator constructed.original Graphplan definition propositional mutex relation close ours.fixes interference d0 (a ) 6= (a0 0 ) 6= .Lemma 1 d0 0 , operator inference Graphplan model impliedpropositional MIPS model dependence.Proof: d0 0 , two independent operators = (, ) o0 = (0 , 0 ):(a0 d0 ) = implies (a0 d0 ) = , turn yields d0 = . conditiona0 = inferred analogously.notion dependency also related partial order reduction explicit-state modelchecking (Clarke et al., 1999), two operators O1 O2 independentstate following two properties hold:1. Neither O1 O2 disable execution other.2. O1 O2 commutative, i.e. O1 (O2 (S)) = O2 (O1 (S)) S.next result indicates state space enumeration approaches referproperty.Theorem 1 (Commutativity) Two independent (STRIPS) operators = (, ) O0 =(0 , 0 ) d0 0 commutative preserve enabled property (i.e.O0 enabled enabled O0 (S) O0 enabled O(S)).Proof: Since d0 0 , d0 = a0 = Lemma 1. Letstate ((S \ ) ) let 00 state ((S \ d0 ) a0 ). Since (a0 d0 ) = ,enabled 00 , since (a ) 0 = , O0 enabled 0 . Moreover,S0O(O0 (S)) = (((S \ d0 ) a0 ) \ )= (((S \ d0 ) \ ) a0 )= \ (d0 ) (a0 )= \ (d d0 ) (a a0 )= (((S \ ) \ d0 ) ) a0= (((S \ ) ) \ d0 ) a0 = O0 (O(S)).consequence, operator independence indicates possible transpositions two operators O1 O2 prune exploration sequential plan generation. less restrictivenotion independence, several actions may occur time even onedeletes add-effect another provided (Knoblock, 1994). detect domainsparallelization leads improvement, utilize following sufficient criterion.216fiTaming Numbers Durations MIPSDefinition 7 (Inherent Sequential Domains) planning domain said inherentlysequential operator sequential plan either instantaneous (i.e. zeroduration) dependent immediate predecessor.static analyzer checks testing operator pair. benchmark domains like DesertRats Jugs-and-Water inherently sequential, others like ZenoTravelTaxi not.Definition 8 (Parallel Plan) solution planning problem P = hS, I, O, Giform parallel plan c = ((O1 , t1 ), . . . , (Ok , tk )) arrangement operators Oi O,{1, . . . , k}, transforms initial state one goal states G G,Oi executed time ti IR0 .example parallel plan ZenoTravel problem depicted Figure 12.Backstom (1998) clearly distinguishes partially ordered plans (O1 , . . . , Ok , ),relation {O1 , . . . , Ok }2 partial order (reflexive, transitive, antisymmetric), parallel plans (O1 , . . . , Ok , , #), # ( 1 ) (irreflexive, symmetric)expressing, actions must executed parallel.Definition 9 (Precedence Ordering) ordering induced operators O1 , . . . , OkdefinedOi Oj : Oi Oj dependent 1 < j k.Precedence partial ordering, since neither reflexive transitive. computingtransitive closure relation, however, precedence could extended partialordering. sequential plan O1 , . . . , Ok produces acyclic set precedence constraintsOi Oj , 1 < j k, set operators. also important observe,constraints already topologically sorted according index order 1, . . . , k.Definition 10 (Respecting Precedence Ordering Parallel Plan) let d(O)IR0 duration operator sequential plan. parallel plan c = ((O1 , t1 ),. . . , (Ok , tk )) respects , ti + d(Oi ) tj Oi Oj , 1 < j k.optimizing plans (Backstrom, 1998) defines parallel execution time max{ti +d(Oi ) | Oi {O1 , . . . , Ok }}, Oi Oj , ti + d(Oi ) tj , Oi #Oj ,either ti + d(Oi ) tj tj + d(Oj ) ti . two possible choices # actuallyapparent approach, since already precedence relation handseek optimal arrangement operators. Consequently assert one option,namely ti + d(Oi ) tj true, reducing # . order find optimal schedulessequential plans approach similar (Backstrom, 1998) would necessary.would dramatically increase computational complexity, since optimal schedulingset fixed-timed operators NP-hard. Therefore, decided restrict dependencyrelation .Definition 11 (Optimal Parallel Plan) optimal parallel plan respect sequenceoperators O1 , . . . , Ok precedence ordering plan = ((O1 , t1 ), . . . , (Ok , tk ))minimal parallel execution time OP = max{ti + d(Oi ) | Oi {O1 , . . . , Ok }} amongparallel plans c = ((O1 , t01 ), . . . , (Ok , t0k )) respect .217fiEdelkampProcedure Critical-PathInput: Sequence operators O1 , . . . , Ok , precedence orderingOutput: Optimal parallel plan length max{ti + d(Oi ) | Oi {O1 , . . . , Ok }}{1, . . . , k}e(Oi ) d(Oi )j {1, . . . , 1}(Oj Oi )e(Oi ) < e(Oj ) + d(Oi )e(Oi ) e(Oj ) + d(Oi )return max1ik e(Oi )Figure 10: Algorithm compute critical path costs.Many algorithms suggested convert sequential plans partially orderedones (Pednault, 1986; Regnier & Fade, 1991; Veloso, Perez, & Carbonell, 1990).interpret totally ordered plan maximal constrained partial ordering ={(Oi , Oj ) | 1 < j k} search less constrained plans. However, problemminimum constraint deordering also proven NP-hard, unless so-calledvalidity check polynomial (Backstrom, 1998), deordering maintains validityplan lessening constrainedness, i.e. 0 new ordering 0 .Since explicit model dependency time, optimal parallel planschange ordering relation all.4.3 Critical Path AnalysisProject Evaluation Review Technique (PERT) critical path analysis algorithmusually applied project management problems. critical path sequence activitiestotal time activities path greater equalpath operators. delay tasks critical path leads delay project.heart PERT network tasks needed complete project, showing ordertasks need completed dependencies them.shown Figure 10, PERT scheduling reduces variant Dijkstras shortestpath algorithm acyclic graphs (Cormen, Leiserson, & Rivest, 1990). matter fact,algorithm returns length critical path inferred partially orderedplan. However, obtaining temporal plan easy. algorithm, e(Oi ) tentativeearliest end time operator Oi , {1, . . . , k}, earliest starting times tioperators optimal plan given ti = e(Oi ) d(Oi ).Theorem 2 (PERT Scheduling) Given sequence operators O1 , . . . , Ok precedence ordering , optimal parallel plan = ((O1 , t1 ), . . . , (Ok , tk )) computedoptimal time O(k + | |).Proof: proof induction {1, . . . , k}. induction hypothesisiteration value e(Oi ) correct, e.g. e(Oi ) earliest end time operator218fiTaming Numbers Durations MIPSOi . clearly true = 1, since e(O1 ) = d(O1 ). assume hypothesistrue 1 j < look iteration i. two choices. Either j{1, . . . , 1} Oj Oi . case inner loop completed, e(Oi )set max{e(Oj ) + d(Oj ) | Oj Oi , j {1, . . . , 1}}. hand, e(Oi )optimal, since Oi cannot start earlier max{e(Oj ) | Oj Oi , j {1, . . . , 1}}, sincevalues e(Oj ) already smallest possible induction hypothesis.j {1, . . . , 1} Oj Oi , e(Oi ) = d(Oi ) base case. Therefore,end, max1ik e(Oi ) optimal parallel path length.time space complexity algorithm Critical-Path clearly O(k 2 ),k length sequential plan. Using adjacency list representationefforts reduced time space proportional number vertices edgesdependence graph, size O(k + | |). bound optimal, sinceinput consists (k) operators (| |) dependencies among them.apply critical path scheduling, even consider temporal model FoxLong, allowing overlapping operator execution dependent operators? answeryes. already seen considering two dependent operators Oi OjFox Long model, determine earliest start (and end) time Oj respectfixed start time Oi . need. proof Theorem 2 showsdetermine earliest end time operators sequentially.4.4 Optimality MIPSSince MIPS optimally schedules sequential plans, question remains, systemeventually find optimal plan? competition, system terminatesfirst sequential plan found. Since relaxed planning heuristic admissible,A* variants cannot guarantee optimal (sequential parallel) plans. However, computingoptimal plans desirable, even due limited computational resources finding optimalplans hard.According temporal model, optimal parallel plan, operator either startsends start end time another operator. Therefore, least finite numberactions optimal plan, possibly exponential finite number possibleparallel plans.immediately leads following naive plan enumeration algorithm: |O|ioperator sequences length i, IN, generate possible parallel plans, checkindividual schedule transforms initial state one goals, takesequence smallest parallel plan length. Since parallel plans computed, yieldscomplete optimal algorithm. seen example two persons lifting table,approach expressive applying algorithm finds sequentialplans first. However, algorithm inefficient.practice, natural assumption parallel plan corresponds least one(possible many) sequential one(s). Conversely, partially ordered plan establishedgenerating totally ordered plan first applying scheduling algorithmfind best partial-order.algorithm Figure 11 indicates wrap forward chaining plannerany-time performance gradually improves plan quality. general state219fiEdelkampProcedure Any-TimeInput: Planning Problem hS, I, O, GiOutput: Optimal parallel plan lengthOpen(Open 6= )Extract(Open)0 expand(S)(S 0 G)cp Critical-Path (path(S 0 ), )(cp < )cpelseChange(Open, 0 )returnFigure 11: General any-time search algorithm.expanding scheme maintains search horizon list Open. simplicity maintenance stored nodes list Closed shown. algorithm, current bestcritical path cost bounds upcoming exploration process. turn updatedtime plan found shorter critical path.CriticalPath procedure above, algorithm returns execution time only,established plan. compute plan meets returned value , alsostore schedule generating sequence path(S 0 ) global record. cases,storing 0 sufficient, since path PERT scheduling restored callingprocedure CriticalPath end procedure.Assuming optimal parallel plan schedule sequential plan statespace finite, any-time extension cycle-avoiding enumeration strategy indeedcomplete optimal. reason completeness finite graphs numberacyclic paths G finite every node expansion, algorithm adds newlinks traversal tree. newly added link represents new acyclic path, that,eventually, reservoir paths must exhausted.also valid parallel plans cannot produced PERT schedulingsequential plan? answer no. partial ordering algorithm terminatesoptimal schedule, generate corresponding sequential plan preservingdependency structure. Optimal PERT-scheduling plan respect setoperators imposed precedence relation yield optimal parallel plan.sequential plans eventually generated, optimal parallel plan also foundPERT scheduling.problem enumeration infinite state spaces infinite plateausplan objective function constant value. Normally increasing lengthplan increases cost. However, true benchmark problems, since220fiTaming Numbers Durations MIPSmay infinite sequence events contribute plan objective.example, loading unloading tanks pre-competition test domain DesertRatsaffect total-fuel consumption, minimized one instances.Enumeration schemes contradict known undecidability results numerical planning (Helmert, 2002). additional information like bound maximalnumber actions plan number actions executed parallel,cannot decide whether cycle-free enumeration terminate not. handsolution, any-time algorithm eventually find it.4.5 Pruning AnomaliesAcceleration techniques like duplicate detection sequential plan generationchosen carefully maintain parallel plan length optimality. approach affectparallel optimality, following example shows. ZenoTravel problem considersequences(zoom city-a city-c plane), (board dan plane city-c),(refuel plane city-c), (zoom city-c city-a plane),(board scott plane city-a), (debark dan plane city-a), (refuel plane city-a),(board scott plane city-a), (zoom city-a city-c plane),(board dan plane city-c), (refuel plane city-c),(zoom city-c city-a plane), (debark dan plane city-a), (refuel plane city-a)two sets operators resulting (sequentially generated)states. However, PERT schedule first sequence shorter schedulesecond one, boarding scott done parallel final two actionsplan.small problems, anomalies avoided omitting duplicate pruning.example Figure 12 depicts sequential plan example problem instancePERT schedule, turns overall optimal parallel plan. Another optionstore resulting parallel plan state caching instead sequential one. Noteorder ease generation sequential solutions large planning problem instances,competition version MIPS used sequential state pruning.4.6 Heuristic Searchmain drawback blind path enumeration seemingly slow practicalplanning. Heuristic search algorithms like A* IDA* reorder traversal states,(assuming state caching) affect completeness optimality anytime wrapper. efficiency wrapper directly depends quality pathenumeration. competition version MIPS omitted any-time wrapping, sinceoptimal solutions required practical run-time behavior poor.Instead used A* search engine, terminates first established solution.question remains: still hope finding near optimal parallel plans? generalresult also applicable infinite graphs established (Pearl, 1985): cost every221fiEdelkamp0:100:130:160:200:300:320:350:390:490:530:630:650:(zoom plane city-a city-c) [100](board dan plane city-c)[30](board ernie plane city-c) [30](refuel plane city-c)[40](zoom plane city-c city-a) [100](debark dan plane city-a)[20](board scott plane city-a) [30](refuel plane city-a)[40](zoom plane city-a city-c) [100](refuel plane city-c)[40](zoom plane city-c city-d) [100](debark ernie plane city-d) [20](debark scott plane city-d) [20]0: (zoom plane city-a city-c) [100]100: (board dan plane city-c)[30](board ernie plane city-c) [30]100: (refuel plane city-c)[40]140: (zoom plane city-c city-a) [100]240: (debark dan plane city-a)[20](board scott plane city-a) [30](refuel plane city-a)[40]280: (zoom plane city-a city-c) [100]380: (refuel plane city-c)[40]420: (zoom plane city-c city-d) [100]520: (debark ernie plane city-d) [20](debark scott plane city-d) [20]Figure 12: sequential plan Zeno-Travel (left) PERT schedule (right).infinite path unbounded, A*s cost function f = g + h preserve optimality.additional rationale choosing A*-like exploration MIPS instead hill climbingbest-first. breadth-first search, rising influence g-value crucial.find adequate heuristic estimate parallel plans easy. factestablished competitive admissible heuristic, required optimal planfinding A*. choice scheduling extension RPH. contrast RPH,new heuristic takes relaxed sequence operators searches suitable parallelarrangement, turn defines estimator function.found adding PERT-schedules path state sequenceactions relaxed plan accurate PERT-schedule combined paths.Therefore, classical merit function A*-like search engines f = g +h generating pathlength g heuristic estimate h immediate correspondence parallel planning.Consequently, define heuristic value scheduling RPH parallel plan lengthcombined path minus parallel plan length generating path.4.7 Arbitrary Plan ObjectivesPDDL 2.1 plan metrics minimizing total (parallel) execution timespecified. influences inferred solutions. Figure 13 depict two plans foundMIPS objective functions minimizing total-fuel-used, minimizingcompound (+ (* 10 (total-time)) (* 1 (total-fuel-used))).first case computed optimal value 1,333.33, second caseestablished 7,666.67 optimized merit. optimizing time, ordering boardzoom actions important. optimizing total-fuel reduce speed save fuelconsumption 333.33 per flight may board first passenger immediately.also save two refuel actions respect first case.increasing importance time trade refueling actions time,zooming flight actions chosen complex minimization criterion.first attempt include arbitrary plan objectives alter PERT schedulingprocess. However, results match ones produced validator (Long &222fiTaming Numbers Durations MIPS0: (zoom plane city-a city-c) [100]100: (board dan plane city-c)[30](board ernie plane city-c) [30](refuel plane city-c)[40]140: (zoom plane city-c city-a) [100]240: (debark dan plane city-a)[20](board scott plane city-a) [30](refuel plane city-a)[40]280: (fly plane city-a city-c) [150]430: (fly plane city-c city-d) [150]580: (debark ernie plane city-d) [20](debark scott plane city-d) [20]0: (board scott plane city-a) [30]30: (fly plane city-a city-c) [150]180: (board ernie plane city-c) [30](board dan plane city-c)[30]210: (fly plane city-c city-a) [150]360: (debark dan plane city-a) [20](refuel plane city-a)[53.33]413.33: (fly plane city-a city-c) [150]563.33: (fly plane city-c city-d) [150]713.33: (debark ernie plane city-d)[20](debark scott plane city-d)[20]Figure 13: Optimized plans Zeno-Travel according different plan objectives.Fox, 2001), final time substituted objective function planbuilt.way MIPS evaluates objective functions time follows. First schedules(relaxed final) sequential plan. Variable total-time temporarily substitutedcritical path value objective formula evaluated. avoid conflicts subsequentexpansions, afterwards value total-time set back optimal one sequentialplan.5. Object Symmetriesimportant feature parameterized predicates, functions action descriptionsdomain specification file actions transparent different bindings parametersobjects. Disambiguating information present problem instance file.case typed domains, many planners, including MIPS, compile type information additional predicates, attach additional preconditions actions enrichinitial states suitable object-to-type atoms.consequence, symmetry viewed permutation objects presentcurrent state, goal representation, transparent set operators.n!, n = |OBJ |, possible permutations set objects. Takingaccount type information reduces number possible permutationnt1 , 2 , . . . , k!=n!.t1 !t2 ! . . . tk !ti number objects type i, {1, . . . , k}. moderate sized logisticdomain 10 cities, 10 trucks, 5 airplanes, 15 packages, results 40!/(10! 10!5! 15!) 1020 permutations.reduce number potential symmetries tractable size restrict symmetriesobject transpositions, n(n 1)/2 O(n2 ) candidates. Usingtype information number reduceskXtii=12!=kXti (ti 1)/2.i=1223fiEdelkampfollowing, set typed object transpositions denoted SYMM.Logistics example, |SYMM| = 45 + 45 + 10 + 105 = 205.5.1 Generating Object Symmetries Planning Problemssection compute subset SYMM includes object pairsentire planning problem symmetric. start object transpositions smallestentities planning problem.Definition 12 (Object Transpositions Fluents, Variables, Operators) transposition objects (o, o0 ) SYMM applied fluent f = (p o1 , . . . , ok(p) ) F, writtenf [o o0 ], defined (p o01 , . . . , o0k(p) ), o0i = oi oi/ {o, o0 }, oi = o0 oi = o,oi = oi = o0 , {1, . . . , k(p)}. Object transpositions [o o0 ] applied variablev = (f o1 , . . . , ok(f ) ) V operator = (a o1 , . . . , ok(a) ) defined analogously.example, ZenoTravel problem (at scott city-a)[scott dan] =(at dan city-a).Lemma 2 f F, v V, O, (o, o0 ) SYMM: f [o o0 ] = f [o0 o],v[o o0 ] = v[o0 o], O[o o0 ] = O[o0 o], well f [o o0 ][o o0 ] = f ,v[o o0 ][o o0 ] = v, O[o o0 ][o o0 ] = O.brute-force time complexity computing f [o o0 ] F order O(k(p)),k(p) number object parameters p. However, pre-computing O(|SYMM||F|) sized lookup table, containing index f 0 = f [o o0 ] (o, o0 ) SYMM,time complexity reduced O(1).Definition 13 (Object Transpositions States) Let mapping set{1, . . . , |T |}. object transposition [o o0 ] applied state = (Sp , Sn )Sn = (v1 , . . . , vk ), k = |V|, written S[o o0 ], equal (Sp [o o0 ], Sn [o o0 ])Sp [o o0 ] = {f 0 F | f Sp f 0 = f [o o0 ]}Sn [o o0 ] = (v10 , . . . , vk0 ) vi = vj0 1 (i)[o o0 ] = 1 (j) i, j {1, . . . , k}.initial state example problem I[dan ernie] = I. definitionvariables slightly difficult predicates, since, case, variablecontents, availability, must match.time complexity compute Sn [o o0 ] O(k), since testing 1 (i)[o o0 ] =1 (j) available time O(1) building another O(|SYMM| |V|) sized pre-computedlook-up table. Note times worst-case. terminate computationobject symmetry fluent variable contradictory. summarize complexityresults follows.Lemma 3 worst-case time complexity compute S[o o0 ] state = (Sp , Sn )(o, o0 ) SYMM O(|Sp | + |V|) using O(|SYMM| (|F| + |V|)) space.next step lift concept object transposition planning problems.224fiTaming Numbers Durations MIPSDefinition 14 (Object Transpositions Domains) planning problem P = hS, O, I, Gisymmetric respect object transposition [o o0 ], abbreviated P[o o0 ],I[o o0 ] = G G: G[o o0 ] G.Since goal descriptions partial, prefer writing G[o o0 ] G instead G G:G[o o0 ] G. Moreover, assume goal description complexity G boundedO(|Gp | + |V|).ZenoTravel problem, goal descriptor purely propositional, containing threefacts target location dan, ernie, scott. initial state runningexample planning problem contains object symmetry, since I[scott ernie] 6=G[dan ernie] 6= G.Applying Lemma 3 (o, o0 ) SYMM yields time complexity needed establish object symmetries.Theorem 3 (Time Complexity Object Symmetry Detection) worst-case run-timedetermine set object transpositions planning problem P = hS, O, I, Gisymmetric O(|SYMM| (|Gp | + |Ip | + |V|)).5.2 Including Goal Symmetry ConditionsSymmetries present initial state may vanish reappear explorationforward chaining planner like MIPS. DesertRats domain, example, initial setsupply tanks indistinguishable one loaded truck.fuel levels supply tanks decrease tanks transported another location,previously existing symmetries broken. However, two tanks one location becomeempty, considered symmetric.Goal conditions, however, change time, initial state transformscurrent state C. Therefore, pre-compiling phase refine set SYMMSYMM0 (o, o0 ) SYMM | G[o o0 ] = G .Usually, |SYMM0 | much smaller |SYMM|. ZenoTravel problem instance,object symmetry left SYMM0 transposition scott ernie.Therefore, efficiently compute setSYMM00 (C) {(o, o0 ) SYMM0 | C[o o0 ] = C}symmetries present current state. initial state exampleproblem Zeno-Travel SYMM00 (I) = , scott ernie sharelocation state C object pair would included SYMM00 (C).definition requires C[o o0 ] = C. include symmetric pathsdifferent states. Let C = {(at ernie city-c), (at scott city-d)}. possiblesymmetric plan {(at ernie city-d), (at scott city-c)} commongoal. Viewed differently, complex object symmetries form [o1 o01 ][o2 o02 ]detected. example observe C[scott ernie][city-c city-d] = C.respect Theorem 3 additional restriction reduces time complexitydetect remaining object symmetries O(|SYMM0 | (|Cp | + |V|)).225fiEdelkamp5.3 Pruning Operatorsplanning problem current state C symmetric respect operatortransposition [o o0 ] either application operator applicationoperator O[o o0 ] neglected, significantly reducing branching factor. Lemma 4indicates symmetry used reduce exploration.Lemma 4 operator applicable = S[o o0 ] O[o o0 ] applicableO(S)[o o0 ] = O[o o0 ](S).Proof: applicable O[o o0 ] applicable S[o o0 ]. Since =S[o o0 ], O[o o0 ] applicable S,O[o o0 ](S) = O[o o0 ](S[o o0 ]) = O(S)[o o0 ].pre-computing O(|SYMM| |O|) sized table index (O0 ) operator O0 =O[o o0 ] determined time O(1) (o, o0 ) SYMM0 .Definition 15 (Pruning Set) Let index mapping set {1, . . . , |T |} let(C) set operators applicable state C S. pruning set (C) (C)defined set operators symmetric counterpartminimal index. symmetry reduction 0 (C) (C) defined (C) \ (C).Theorem 4 (Correctness Operator Pruning) Reducing operator set (C) 0 (C)exploration planning problem P = hS, O, I, Gi preserves completeness7 .Proof: Suppose expanded state C, reducing operator set (C) 0 (C)exploration planning problem P = hS, O, I, Gi preserve completeness.Furthermore, let C state property maximal exploration order.sequential plan = (O1 . . . , Ok ) PC = hS, O, C, Gi associatedstate sequence (S0 = C, . . . , Sk G). Obviously, Oi (Si1 ), {1, . . . , k}.choice C O1 (S0 ) \ 0 (S0 ) = (S0 ). definition pruning set(S0 ) exists O10 = O1 [o o0 ] minimal index applicable S0 .Since PC = hS, O, C, Gi = PC [o o0 ] = hS, O, C[o o0 ] = C, G[o o0 ] = Gi ,sequential plan O1 [o o0 ], . . . , Ok [o o0 ] state sequence (S0 [o o0 ] = S0 , S1 [oo0 ], . . . , Sk [o o0 ] = Sk ) reaches goal G. contradicts assumptionreducing operator set (C) 0 (C) preserve completeness C.Since plan objective refers instantiated predicates objects, similarinitial goal state, symmetry breaking. order preserve optimality, oneadditionally check, see object exchange influence plan objective.practice, objective functions often based non-parameterized predicates,case optimal planning algorithm affected symmetry cuts.7. Generally completeness means planner find legal plan. intended here.use completeness terms discarding legal plans favor equally good symmetric plans.226fiTaming Numbers Durations MIPS5.4 Symmetry Reduction MIPSmain purpose restricted implementation MIPS reduce runtime object symmetry detection losing effectiveness. Especiallyimpact quantity O(|SYMM0 | |Cp |) running time considerable.key observation symmetries also present fact groups accordinggroup representatives. shown Figure 5, fact group dan consists facts(at dan city-a), (at dan city-b), (at dan city-c), (at dan city-d), (in danplane). Similarily, ernies group facts (at ernie city-a), (at ernie city-b), (aternie city-c), (at ernie city-d), (in ernie plane). ordering factsgroups chosen way that, except change group representative,corresponding facts match. Together facts groups, operators changefacts groups, stored efficient dictionary.Therefore, restrict object transpositions group representatives. reducesset objects OBJ MIPS considers considerably smaller subset OBJ 0 .example problem |OBJ | = 7, |OBJ 0 | = 4. Many objects, e.g. objectstype city ZenoTravel, selected representatives single attribute invariancebuild group.idea obtain possible transposition fact group representatives, followedlooking respective fact positions current goal state. may happen,one group fixed representative OBJ 0 . case, link groupsrepresentative common. symmetry detection test group chainsobjects matching current goal position.above, symmetries based non-matching goal predicates excluded beforehand. Let RSYMM number remaining symmetries object representatives.Assume one representative per group yields running time propositional objectsymmetry detection state C O(RSYMM + |Cp |). remaining comparisons variables v V implemented described previous section, performedobject pairs pass propositional check.pruning operators, MIPS marks groups correspond object symmetrylarger index visited. guarantees operator least onegroup executed. expanded state matching operator (S)algorithm checks, whether applied operator present visited group, casepruned. time complexity O(|(S)|), since operator group containmentpreprocessed checked constant time.Figure 14 shows effectiveness symmetry reduction planner MIPS DesertRats domain, scales respect total distance d, {300, 400, 500, 600},passed (x-axis). direction, number expanded states A*search MIPS object symmetry reduction (right bars) without symmetry reduction (left bars) shown logarithmic scale. expected, larger problems symmetryreduction yields performance gains one order magnitude (d = 500). alsoyields solutions problems algorithms without symmetry reduction fail duememory restrictions (d = 600)8 .8. memory bound used example set 1/2 GByte.227fiEdelkampFigure 14: Results symmetry pruning Desert Rats. Bars show number statesexpanded without/with symmetry detection.6. Related WorkSTRIPS problems tackled different planning techniques, notablySAT-planning (Kautz & Selman, 1996), IP-planning (Kautz & Walser, 1999), CSPplanning (Rintanen & Jungholt, 1999), graph relaxation (Blum & Furst, 1995), heuristicsearch planning (Bonet & Geffner, 2001).Solving planning problems numerical preconditions effects allowed Level 2Level 3 problems undecidable general (Helmert, 2002). However, structuresprovided benchmark problems simpler general problem class,problems fact solvable.6.1 Temporal Planning Approachessystem Metric-FF (Hoffmann, 2002a) extends FF (Hoffmann & Nebel, 2001)forward chaining heuristic state space planner Level 2 problems. Although, MIPS plangenerator shares several ideas Metric-FF, Hoffmanns system yet extendeddeal temporal domains.Planner TP4 (Haslum & Geffner, 2001) fact scheduling system based groundedproblem instances. cases formula trees numerical conditions assignmentsreduce constants. Utilizing admissible heuristics, TP4 minimizes plan objectiveoptimal parallel plan length. planner distinctive advantages: handlesnumerical preconditions, instantiates numerical conditions fly copecomplex objective functions. Besides input restriction, competition, TP4somewhat limited focus producing optimal solutions.SAPA system (Do & Kambhampati, 2001) domain-independent time resource planner cope metrics concurrent actions. SAPAs general expressivity judged close MIPS. adapts forward chaining algorithm(Bacchus & Ady, 2001). planning approaches instantiate actions fly228fiTaming Numbers Durations MIPStherefore, principle, adapted handle flexible mixed propositional numerical planning problems. search algorithm SAPA extends partial concurrent plansinstead parallelizing sequential plans. uses relaxed temporal planning graphyet unplanned events different heuristic evaluation functions. additional feature,SAPA provides option specifying deadlines.planner LPG (Gerevini & Serina, 2002) based local search planning graphs.uses variant FF planner grounding initial plans generated random walk. subsequent search space LPG consists so-called action graphs (Gerevini& Serina, 1999). temporal module performs action graph modifications transformingaction graph another one. fast plan generation algorithm LPG seemsbest explanation speed advantage LPG respect MIPS,higher number problems LPG solved domains. Optimization LPG governedLagrange multipliers. temporal domains, actions ordered using precedence graphmaintained search, uses refined dependency relation ours.may partly explain plan quality fact consistently better MIPS.IxTeT (Laborie & Ghallab, 1995) general constraint-based planning systeminput format. planner searches space partial plans allows generalresource temporal constraints posed. internal representation consistschronicles, time linearly ordered discrete set instants, multi-valued statevariables either rigid flexible (contingent, controllable, resources), predicatestemporally qualified expressions (events, assertions, resources), temporal atemporalconstraints. clear compare expressivity chronicles PDDL2.1constructs. makes difficult link different temporal models determinetechnique critical path scheduling applicable IxTeT not. opinionunlikely, since IxTeT partial-order. Note IxTeT allows conjunctionpredicates, subtasks, constraints conditional expressions, availablePDDL2.1. analysis partial plans drives planning process dividedthree different modules: feasibility, satisfiability resource conflict resolution.competition domains IxTeT able compete local search heuristic searchplanners.HSTS (Muscettola, 1994) constraint-based planning system based temporal activity networks, written LISP CRL. NASA used many projectslike Deep-Space One. already represent reason metric resources, parallelactivities, general constraints. IxTeT input format significantly differentPDDL2.1. HSTS yet adapted represent reason conditionalbranches. However experiences HSTS planner showed partial-order planningattractive metric/temporal problems, need better search control.Although PDDL2.1 guidelines fact allow infinite branching, 2002 competition consisted finite branching problems. indicated earlier, paperalso concentrates finite branching problems. finite branching, execution timeaction fixed, infinite branching, continous range actions available.problems confronted (real-time) model checking long time.subclasses infinite branching problems like timed automata exhibit finite partitioning symbolic representation states (Pettersson, 1999). techniqueshortest-path reduction unique reduced normal form obtained.229fiEdelkampimplemented temporal network structure, since main data structureexploring timed automata done model checker Uppaal (Pettersson, 1999).work, constraints must form xi xj c xi c. example,set constraints x4 x0 1, x3 x1 2, x0 x1 1, x5 x2 8, x1 x2 2,x4 x3 3, x0 x3 4, x1 x4 7, x2 x5 10, x1 x5 5 shortest-pathreduction x4 x0 1, x3 x1 2, x5 x2 8, x0 x3 4, x1 x4 7, x2 x5 10,x1 x5 5. constraint set over-constrained, algorithm determineunsolvability, otherwise feasible solution returned.Critical path analysis timed precedence networks one simpler casesscheduling. achieved simplification solving sequential path problem first.Note many scheduling techniques apply presented critical path analysissubcomponent (Syslo, Deo, & Kowalik, 1983).6.2 Symmetry Detection Planning Model Checkersprevious results symmetry reduction planning, e.g. (Guere & Alami, 2001),neglect combinatorial explosion possible symmetries least assumeinformation existing symmetries domain supplied user.contrast, work shares similarities approach Fox & Long (1999,2002)inferring object symmetry information fully automatically. Fox Longs work basedsimilarities established TIM inference module (Fox & Long, 1998). searchadditional information current symmetry level form object transpositionmatrix stored updated together state. approach different senseefficiently computes object symmetries state scratch consumesextra space per node expansion.Model checking research long tradition symmetry reduction (Clarke et al., 1999).recent work, Rintanen (2003) connects symmetry detection planning model checkingapproaches transition systems SAT solving. Experiments provided SATencodings Gripper domain; prototypical example symmetry detection. (LluchLafuente, 2003), model checker HSF-Spin extended effectively combine heuristicsearch symmetry detection. also reflects fact (HSF-)Spins explorationmodelled using (labelled) transition systems. Positive empirical results givennon-trivial examples like Petersons mutual exclusion algorithm Database Managerprotocol.briefly review fundamental difference object symmetries (as consideredhere) state space symmetries (as considered model checking).latter approach constructs quotient state space problem (P/) based congruence relation, equivalence relation called congruences1 , s2 , s1 s1 s2 operator O(s1 ) = s01 s02s01 s02 operator O0 O0 (s2 ) = s02 . [O][s] = [s0 ]operator mapping s0 [s] s0 [s0 ].bijection : said symmetry (I) = I, (G) G G Gs, s0 transition s0 exist transition (s)(s0 ). set symmetries generates subgroup g(A) called symmetry group.subgroup g(A) induces equivalence relation states, defined s0230fiTaming Numbers Durations MIPS(s) = s0 g(A). equivalence relation called symmetry relationP induced A. equivalence class called orbit s, denoted [s]A .symmetry relation P congruence P. Moreover, reachable [s]Areachable [I]A . reduces search goal G G finding state [G].explore state space respect state (space) symmetry, function Canonicalize needed. time new successor node generated, determines representativeelement equivalence class. Fixing canonical element trivial, manysystems approximate normal form. Automatically finding symmetries settingalso difficult cast computationally hard graph isomorphism problem.Therefore approaches expect information kind symmetry presentstate space graph. One example rotational symmetry, defined right shiftvariables state vector.6.3 Model Checking Planners2000 competition, two symbolic planners took part: PropPlan (Fourman,2000), BDDPlan (Holldobler & Stor, 2000). Although receive awardsperformance, show interesting properties. PropPlan performs symbolic forwardbreadth first search explore propositional planning problems propositions generalized action preconditions generalized action effects. performed well fullADL Miconic-10 elevator domain (Koehler, 2000). ProbPlan written Poly/MLimplementation SML. BDD-Plan based solving entailment problem fluent calculus BDDs. time authors acknowledged concise domainencoding symbolic heuristic search used MIPS improvements.Model-Based Planner MBP paradigm planning symbolic model checking (Giunchiglia & Traverso, 1999) implemented non-deterministic planningdomains (Cimatti et al., 1998), classified weak, strong, strong-cyclicplanning, plans represented state-action tables. partially observableplanning, system faced exploring space belief states; power setoriginal planning space. Therefore, contrast successor set generation based action application, observations introduce nodes search tree (Bertoli, Cimatti,Roveri, & Traverso, 2001b). Since approach hybrid symbolic representationbelief states explicit search within And-Or search tree, simple heuristicsapplied guide search. need heuristics trade information gainexploration effort also apparent conformant planning (Bertoli et al., 2001a). Recentwork (Bertoli & Cimatti, 2002) proposes improved heuristics belief space planning.UMOP system parses non-deterministic agent domain language explicitlydefines controllable system uncontrollable environment (Jensen & Veloso, 2000).planner also applies BDD refinement techniques automated transition functionpartitioning. New results UMOP system extend weak, strong strong cyclicplanning adversarial planning, environment actively influences outcomeactions. fact, proposed algorithm combines aspects symbolic searchgame playing. UMOP yet participated planning competition.recent developments symbolic exploration expected influence automatedplanning near future. SetA*, (Jensen et al., 2002) provide improved imple231fiEdelkampmentation symbolic heuristic search algorithm BDDA* (Edelkamp & Reffel, 1998)Weighted BDDA* (Edelkamp, 2001a). One improvement SetA* maintains finergrained sets states search horizon. kept matrix according matching g- h- values. contrasts plain bucket representation priorityqueue based f -values. heuristic function implicitly encoded value differencesgrounded actions. Since sets states evaluated heuristics staterather operator dependent remains shown general approach is.above, planning benchmarks considered seemingly simple single-state heuristic search exploration (Hoffmann, 2002b; Helmert, 2001). (Hansen, Zhou, & Feng, 2002)also re-implemented BDDA* suggest symbolic search heuristics explorationalgorithms probably better implemented algebraic decision diagrams (ADDs). Although authors achieved improvement (Edelkamp & Reffel, 1998) solving(n2 1)-Puzzle, established generalization guide symbolic version LAO* exploration algorithm (Hansen & Zilberstein, 2001) probabilistic (MDP) planning resultsremarkable improvement state-of-the-art (Feng & Hansen, 2002).7. Conclusionscompetition planning system MIPS, contributed flexible systemheuristic forward chaining, explicit symbolic search planner finds plans finitebranching numerical problems. planner parses, pre-compiles, solves, schedulesproblem instances, including complex ones duration, resource variables differentobjective functions. main contributions plannerobject-oriented workbench architecture choose combine different heuristics different search algorithms storage structures. design includesstatic analyzer applies efficient fact-space exploration distinguish constantfluent quantities, clusters facts groups, infers static objectsymmetries. static analyzer produces intermediate format groundedsimplified planning domain instances.Optimal temporal planning enumeration algorithms, based precedence relationPERT scheduling sequentially generated plans together concise analysiscorrectness optimality, well integration PERT scheduling MIPScomputing refined heuristic estimate. guides search phase, favoringstates smaller parallel plan length. MIPS instantiates numerical pre- postconditions on-the-fly produces optimized parallel plans.detection dynamic object symmetries, integration different pruningmethods hash transposition cuts, well different strategies optimizing objective functions implementation tricks made systemefficient.paper analyzes theoretical properties contributions, sometimes slightlyabstracting actual implementation.Essentially planning numerical quantities durative actions planningresources time. given framework mixed propositional numerical planning232fiTaming Numbers Durations MIPSproblems presented intermediate format seen normal form temporalmetric planning. paper presents novel temporal planning scheme generatessequential (totally ordered) plans efficiently schedules respect setactions imposed causal structure, without falling known NP-hardness trapsoptimized partial-ordering sequentially generated plans. smaller problems complete enumeration approach guarantees optimal solutions. improve solution qualityapproximate enumeration, (numerical) estimate number operators replacedscheduling relaxed plan state. addressed completeness optimalitydifferent forms exploration. novel study time space complexity dynamicobject symmetry detection given.Model checking always influenced development MIPS, e.g static analysis minimize state description length, symbolic exploration plan extraction,dependence relation PERT schedules according given partial order, bit-statehashing IDA*, importance symmetry detection, forth. Moreover,successes planning MIPS exported back model checking, development heuristic search state model checkers parsing Promela protocol specificationsindicate.Acknowledgmentsauthor would like thank Derek Long Maria Fox helpful discussions concerningpaper Malte Helmert cooperation second planning competition.list editors anonymous reviewers comments helped lot improve text.work supported Deutsche Forschungsgemeinschaft (DFG) projectsHeuristic Search (Ed 74/3) Directed Model Checking (Ed 74/2).ReferencesBacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaningapproach. Proceedings IJCAI-01, pp. 417424.Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116, 123191.Backstrom, C. (1998). Computational aspects reordering plans. Journal ArtificialIntelligence Research, 9, 99137.Bertoli, P., & Cimatti, A. (2002). Improving heuristics planning search belief space.Proceedings AIPS-02, pp. 143152.Bertoli, P., Cimatti, A., & Roveri, M. (2001a). Heuristic search symbolic model checking =efficient conformant planning. Proceedings IJCAI-01, pp. 467472.Bertoli, P., Cimatti, A., Roveri, M., & Traverso, P. (2001b). Planning nondeterministicdomains partial observability via symbolic model checking. ProceedingsIJCAI-01, pp. 473478.Biere, A. (1997). cke - efficient -calculus model checking. Proceedings CAV-97, pp.468471.233fiEdelkampBloem, R., Ravi, K., & Somenzi, F. (2000). Symbolic guided search CTL model checking.Proceedings DAC-00, pp. 2934.Blum, A., & Furst, M. L. (1995). Fast planning planning graph analysis.Proceedings IJCAI-95, pp. 16361642.Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (12), 533.Bryant, R. E. (1992). Symbolic boolean manipulation ordered binary-decision diagrams. ACM Computing Surveys, 24 (3), 142170.Cimatti, A., Giunchiglia, E., Giunchiglia, F., & Traverso, P. (1997). Planning via modelchecking: decision procedure AR. Proceedings ECP-97, pp. 130142.Cimatti, A., Roveri, M., & Traverso, P. (1998). Automatic OBDD-based generationuniversal plans non-deterministic domains. Proceedings AAAI-98, pp. 875881.Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model Checking. MIT Press.Clarke, E. M., McMillan, K. L., Dill, D. L., & Hwang, L. J. (1992). Symbolic model checking:1020 states beyond. Information Computation, 98 (2), 142170.Cormen, T. H., Leiserson, C. E., & Rivest, R. L. (1990). Introduction Algorithms.MIT Press.Dial, R. B. (1969). Shortest-path forest topological ordering. CommunicationACM, 12 (11), 632633.Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Proceedings ECP-01, pp. 109120.Edelkamp, S. (1999). Datenstrukturen und Lernverfahren der Zustandsraumsuche. Ph.D.thesis, University Freiburg. DISKI, Infix.Edelkamp, S. (2001a). Directed symbolic exploration application AI-planning.Proceedings AAAI-01 Spring Symposium Model-based Validation Intelligence,pp. 8492.Edelkamp, S. (2001b). First solutions PDDL+ planning problems. ProceedingsPlanSIG-01, pp. 7588.Edelkamp, S. (2001c). Planning pattern databases. Proceedings ECP-01, pp.1324.Edelkamp, S. (2002a). Mixed propositional numerical planning model checking integrated planning system. Proceeding AIPS-02 Workshop TemporalPlanning, pp. 4755.Edelkamp, S. (2002b). Symbolic pattern databases heuristic search planning. Proceedings AIPS-02, pp. 274283.Edelkamp, S. (2003). Promela planning. Proceedings SPIN-03, pp. 197212.Edelkamp, S., & Helmert, M. (1999). Exhibiting knowledge planning problems minimize state encoding length. Proceeding ECP-99, pp. 135147.234fiTaming Numbers Durations MIPSEdelkamp, S., & Helmert, M. (2000). implementation MIPS. ProceedingsAIPS-00 Workshop Model Theoretic Approaches Planning, pp. 1825.Edelkamp, S., & Helmert, M. (2001). model checking integrated planning system MIPS.AI-Magazine, 6771.Edelkamp, S., Leue, S., & Lluch-Lafuente, A. (2003). Directed explicit-state model checkingvalidation communication protocols. International Journal Software ToolsTechnology (STTT), appear.Edelkamp, S., & Meyer, U. (2001). Theory practice time-space trade-offs memorylimited search. Proceedings KI-01, Lecture Notes Computer Science, pp.169184. Springer.Edelkamp, S., & Reffel, F. (1998). OBDDs heuristic search. Proceedings KI-98, pp.8192.Edelkamp, S., & Reffel, F. (1999a). Deterministic state space planning BDDs.Proceedings ECP-99, Preprint, pp. 381382.Edelkamp, S., & Reffel, F. (1999b). Deterministic state space planning BDDs. Tech.rep. 121, University Freiburg.Edelkamp, S., & Stiegeler, P. (2002). Implementing HEAPSORT n log n 0.9nQUICKSORT n log n + 0.2n comparisons. ACM Journal Experimental Algorithms, 7 (5).Feng, Z., & Hansen, E. (2002). Symbolic heuristic search factored markov decisionprocesses. Proceedings AAAI-02.Fikes, R., & Nilsson, N. (1971). Strips: new approach application theoremproving problem solving. Artificial Intelligence, 2, 189208.Fourman, M. P. (2000). Propositional planning. Proceedings AIPS-00 WorkshopModel-Theoretic Approaches Planning, pp. 1017.Fox, M., & Long, D. (1998). automatic inference state invariants TIM. JournalArtificial Intelligence Research, 9, 367421.Fox, M., & Long, D. (1999). detection exploration symmetry planningproblems. Proceedings IJCAI-99, pp. 956961.Fox, M., & Long, D. (2002). Extending exploitation symmetries planning.Proceedings AIPS-02.Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporalplanning domains. Journal Artificial Intelligence Research, issue.Gerevini, A., & Serina, I. (1999). Fast planning greedy action graphs. ProceedingsAAAI-00.Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphsaction costs. Proceedings AIPS-02.Giunchiglia, F., & Traverso, P. (1999). Planning model checking. ProceedingsECP-99, pp. 119.235fiEdelkampGroce, A., & Visser, W. (2002). Model checking Java programs using structural heuristics.Proceedings ISSTA-02.Guere, E., & Alami, R. (2001). One action enough plan. Proceedings IJCAI-01.Hansen, E., & Zilberstein, S. (2001). LAO*: heuristic search algorithm finds solutionsloops. Artificial Intelligence, 129, 3562.Hansen, E. A., Zhou, R., & Feng, Z. (2002). Symbolic heuristic search using decisiondiagrams. Proceedings SARA-02.Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). formal basis heuristic determinationminimum path cost. IEEE Transactions Systems Science Cybernetics,4, 100107.Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. ProceedingsECP-01, pp. 121132.Helmert, M. (2001). complexity planning transportation domains. Proceedings ECP-01, pp. 349360.Helmert, M. (2002). Decidability undecidability results planning numericalstate variables. Proceedings AIPS-02, pp. 4453.Hipke, C. A. (2000). Verteilte Visualisierung von Geometrischen Algorithmen. Ph.D. thesis,University Freiburg.Hoffmann, J. (2000). heuristic domain independent planning use enforcedhill climbing algorithm. Proceedings ISMIS-00, pp. 216227.Hoffmann, J. (2002a). Extending FF numerical state variables. Proceedings ECAI02.Hoffmann, J. (2002b). Local search topology planning benchmarks: theoretical analysis.Proceedings AIPS-02, pp. 92100.Hoffmann, J., & Nebel, B. (2001). Fast plan generation heuristic search. JournalArtificial Intelligence Research, 14, 253302.Holldobler, S., & Stor, H.-P. (2000). Solving entailment problem fluent calculus using binary decision diagrams. Proceedings AIPS-00 Workshop ModelTheoretic Approaches Planning, pp. 3239.Jensen, R. M., Bryant, R. E., & Veloso, M. M. (2002). SetA*: efficient BDD-basedheuristic search algorithm. Proceedings AAAI-02.Jensen, R., & Veloso, M. M. (2000). OBDD-based universal planning synchronizedagents non-deterministic domains. Journal Artificial Intelligence Research, 13,189226.Kabanza, F., Barbeau, M., & St-Denis, R. (1997). Planning control rules reactive agents.Artificial Intelligence, 95 (1), 67113.Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,stochastic search. Proceedings AAAI-96, pp. 11941201.Kautz, H., & Walser, J. (1999). State-space planning integer optimization. ProceedingsAAAI-99.236fiTaming Numbers Durations MIPSKnoblock, C. (1994). Generating parallel execution plans partial order planner.Proceedings AIPS-94, pp. 98103.Koehler, J. (2000). Elevator control planning problem. Proceedings AIPS-00, pp.331338.Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings useagenda-driven planning algorithm. Journal Artificial Intelligence Research,12, 338386.Koehler, J., Nebel, B., & Dimopoulos, Y. (1997). Extending planning graphs ADLsubset. Proceedings ECP-97, pp. 273285.Korf, R. E. (1985). Depth-first iterative-deepening: optimal admissible tree search.Artificial Intelligence, 27 (1), 97109.Korf, R. E., & Zhang, W. (2000). Divide-and-conquer frontier search applied optimalsequence alignment. Proceedings AAAI-00, pp. 910916.Laborie, P., & Ghallab, M. (1995). Planning sharable resources constraints. Proceedings IJCAI-95, pp. 16431649.Lago, U. D., Pistore, M., & Traverso, P. (2002). Planning language extendedgoals. Proceedings AAAI-02.Lind-Nielsen, J. (1999). Buddy: Binary decision diagram package, release 1.7. TechnicalUniveristy Denmark. Available jln@itu.dk.Lluch-Lafuente, A. (2003). Symmetry reduction heuristic search error detectionmodel checking. Proceedings Workshop Model Checking ArtificialIntelligence (MoChart).Long, D., & Fox, M. (1998). Efficient implementation plan graph STAN. JournalArtificial Intelligence Research, 10, 87115.Long, D., & Fox, M. (2001). Encoding temporal planning domains validating temporal plans. Workshop UK Planning Scheduling Special Interest Group(PlanSIG).McDermott, D. (2000). 1998 AI Planning Competition. AI Magazine, 21 (2).McMillan, K. L. (1993). Symbolic Model Checking. Kluwer Academic Press.Muscettola, N. (1994). HSTS: integrating planning scheduling. Zweben, M., & Fox,M. S. (Eds.), Intelligent Scheduling, pp. 168212. Morgan Kaufmann.Pearl, J. (1985). Heuristics. Addison-Wesley.Pednault, E. (1986). Formulating multiagend, dynamic-world problems classicalframework. Reasoning Action Plans, pp. 4782. Morgan Kaufmann.Pednault, E. (1989). ADL: Exploring middleground Strips situation calculus. Proceedings KR-89, pp. 324332. Morgan Kaufman.Pettersson, P. (1999). Modelling Verification Real-Time Systems Using Timed Automata: Theory Practice. Ph.D. thesis, Department Computer Systems, Uppsala University.237fiEdelkampPistore, M., & Traverso, P. (2001). Planning model checking extended goals nondeterministic domains. Proceedings IJCAI-01.Pohl, I. (1977). Practical theoretical considerations heuristic search algorithms.Machine Intelligence, 8, 5572.Refanidis, I., & Vlahavas, I. (2000). Heuristic planning ressources. ProceedingsECAI-00, pp. 521525.Reffel, F., & Edelkamp, S. (1999). Error detection directed symbolic model checking.Proceedings FM-99, pp. 195211.Regnier, P., & Fade, B. (1991). Determination du parallelisme maximal et optimisationtemporelle dans les plans dactions lineaires. Revue dIntelligence Artificielle, 5 (2),6788.Reinefeld, A., & Marsland, T. (1994). Enhanced iterative-deepening search. IEEE Transactions Pattern Analysis Machine Intelligence, 16 (7), 701710.Rintanen, J. (2003). Symmetry reduction SAT representations transition systems.Proceedings ICAPS-03.Rintanen, J., & Jungholt, H. (1999). Numeric state variables constraint-based planning.Proceedings ECP-99, pp. 109121.Ruys, T. C. (2003). Optimal scheduling using branch bound SPIN 4.0. Proceedings SPIN-03, pp. 117.Syslo, M. M., Deo, N., & Kowalik, J. S. (1983). Discrete Optimization AlgorithmsPascal Programs. Prentice-Hall.Veloso, M. M., Perez, M. A., & Carbonell, J. G. (1990). Nonlinear planning parallelresource allocation. Innovative Approaches Planning, Scheduling Control,pp. 207212.Weismuller, M. (1998). Planen mit einem Modellprufer im -Kalkul . Masters thesis,Universitat Ulm.Yang, C. H., & Dill, D. L. (1998). Validation guided search state space.Proceedings DAC-98, pp. 599604.Yoshizumi, T., Miura, T., & Ishida, T. (2000). A* partial expansion large branchingfactor problems. Proceedings AAAI-00, pp. 923929.Zhou, R., & Hansen, E. (2003). Sparse-memory graph search. Proceedings IJCAI-03.238fiJournal Artificial Intelligence Research 20 (2003) 125132Submitted 09/03; published 12/03CommentaryPower Modelinga Response pddl2.1Fahiem Bacchusfbacchus@cs.toronto.eduDepartment. Computer Science6 Kings College RoadUniversity TorontoToronto, OntarioCanada, M5S 3H5.Abstractcommentary argue although pddl2.1 useful standardplanning competition, design properly consider issue domain modeling.Hence, would advocate use specifying planning domains outside contextplanning competition. Rather, field needs explore different approachesgrapple directly problem effectively modeling utilizingdiverse pieces knowledge typically planning domains.1. IntroductionFox Long terrific job organizing 2002 Planning Competition. non-trivialcomponent work specifying extension pddl much interestingrange problems could addressed competition. Although extension representsuseful standard competition, design ignores power realitydomain modeling. argue new features pddl2.1 unnecessary:similar effects easily captured robust modeling planningdomain.Tlplan planning system competed 2002 planning competition. Despitefact Tlplans specification language direct support featurespddl2.1, still able encode competition domains. Tlplan utilizeslanguage designed suitable robustly modeling planning domains.1found many new features pddl2.1 used competition fact easycapture simply robust modeling planning domain.pddl2.1 takes approach adding new features language, ratherrequiring domain robustly modeled, perhaps surprising givendichotomy still persists AI planning field. dichotomy workdomain-independent planning control-intensive planning. work controlintensive planning tends ignore applicability power state-of-the-art searchalgorithms planning, work domain-independent planning tends ignore powergained, requirements imposed, domain modeling. planning researchersfreely acknowledge importance components, however, one rarely finds work1. Tlplan also includes constructs expressing domain specific control information, referringcomponent language.c2003AI Access Foundation. rights reserved.fiBacchus(:durative-action load-truck:parameters (?t - truck)(?l - location)(?o - cargo)(?c - crane):duration (= ?duration 5):precondition (and (at ?t ?l)(at ?o ?l)(empty ?c)):effect(and (loading ?t)(at end (not loading ?t))...)(:action move-truck:parameters (?t - truck)...:precondition (and (not (loading ?t))...))Figure 1: Converting (over all) conditionsinterface two issues, many researchers workissues.2rest commentary elaborate argument presenting examplesfeatures approaches appearing pddl2.1 demonstrate insensitivity domainmodeling.2. Coordinating Concurrent ActionsSection 5 pddl2.1 document various constructs presented support durativeactions. actions whose effects either immediate (like ordinary non-durativeactions) occur end fixed duration. duration eitherconstant specified functional term. obvious extension, used, e.g., Bacchus& Ady (2001), action could range effects different futuretimepoint, included pddl2.1.3 Without extension (at start) (atend) specifiers reasonable ways specifying delayed effects.non-instantaneous actions concurrency control becomes issue. achievekind control pddl2.1 provides :condition constructs (at start), (at end),(over all). Tlplan provide (at end) (over all) constructs ((atstart) simply ordinary precondition). Yet still able modelplanning domains without them. would argue general constructsnecessary.2. guilty colleagues.3. Instead one must ascend much complex specification continuous effects (presentedSection 5.3 pddl2.1 document) achieve degree flexibility.126fiA Response pddl2.12.1 (over all):Consider load-truck action given Figure 6 pddl2.1 article. containscondition (over (at ?t ?l)): i.e., truck must stay locationload. must moved? allowed move vehicleloaded. Similarly, drive car refueled,turn oven used bake cake, attempt tieshoelaces running, etc. knowledge abounds common sense conditions.natural language use progressive tenses refer ongoing activities. Similarly,natural way model (over all) condition simply action assertactivity ongoing, use negation activity precondition actionscould interfere. resulting transformation load-truck action givenFigure 1.Figure 1 load-truck action advertises initiated on-going loadingtruck adding loading predicate state. end action predicatedeleted. Actions like move-truck could interfere loading blocked adding(not loading) preconditions. Using technique able replace(over all) conditions used competition domains. Interestingly replacementsmade domain sensible readable.Consider brief advantages modeling (over all) effects adding progressivepredicates state.1. method realized without extending standard strip/adl semantics.2. actions preconditions still encapsulates interactions actions. presence (over all) conditions, one would examine everyaction see (over all) conditions interfered oneactions effects. Put another way, actions activation condition continuesMarkovian, i.e., dependent current state. current state continuescarry information needed determine action applied;(over all) conditions, one also needs examine currently active actionsthestate longer encapsulates necessary information.3. Finally, seems resulting domain models natural easierunderstand.2.1.1 ModularityOne concern approach avoiding (over all) conditions, appearsmake adding new actions domain non-modular.4 Non-modularity potentially arisesadding new actions could interfered previous actions,adding new actions could interfere previous actions.first case arises add new actions like refuel, repair, change-tire, etc.,interfered existing action move-truck. solutionadding non-interference preconditions would seem require modifying description4. Thanks David Smith Martha Pollock pointing needed address issuemodularity.127fiBacchusmove-truck add (not (refueling)), (not (repairing)), (not (changing-tire)),etc., preconditionsa new precondition every new action added.second case arises add new action like tow-truck also changeslocation truck. would ensure add preconditionsprogressives required block interfering previously defined actions.second case perhaps problematic, since require modifyingold actions. However, first case issue since one might want modifydefinition previous actions already debugged.using (over all) conditions need make changes old actionsworry effects new actions old. However, would arguemodularity exists syntactic levelit syntactically easy modify domaindescription accommodate new actions. corresponding modularitysemantic level: interferences new action old still exists.cases cannot simply ignore interactions, leaving planner (overall) conditions resolve. found developing domains, many casesnew action added domain bug domain specification appears.example, plans one would expect find longer found planner. Often buglies new action, often bug found specification old actions.domain longer operates expected, one still left task unravelinginteractions specification. general, specifying rich domain requires understandingpossible interactions domain, task (over all) conditionshelp.could argued job planner unravel interactionsdomain. argument, believe, trivializes job specifying planning domain.planners job compute interactions actions sequence (orcomplex composition) actions. Getting domain correctly specified difficult task,requires least understanding actions interact statically, even one leavedynamic interactions planner.Fortunately, systems interactions actions relatively local:typically relatively structured way actions interfere other.makes specifying planning domains feasible.One take advantage structure build robust domain models provideadvantages semantic well syntactic modularity. critical component buildinggood domain models ability use definitions (axioms), feature providedpddl2.1. Tlplan, e.g., one define new predicate symbol using first-orderformula previous defined symbols. defining right high level constructs onetypically provide explicit representation structure interactionsdomain. advantage one also obtains declarative representationstructure, thus achieving natural easier understand domain specification.example above, one could define new predicate (must-be-stationary ?t)disjunction(or (loading ?t) (changing-tire ?t) (repairing ?t) (refueling ?t)).(move-truck ?t ?l1 ?l2) action need single precondition (not(must-be-stationary ?t)), new action requires truck station128fiA Response pddl2.1(:durative-action load-truck:parameters (?t - truck)(?l - location)(?o - cargo)(?c - crane):duration (= ?duration 5):precondition (and (at ?t ?l)(at ?o ?l)(empty ?c)):effect(and (loading ?t)(at end (not loading ?t))(holding ?c ?o)(not (at ?o ?l))(at end (when (holding ?c ?o) (in ?o ?t)))(at end (when (holding ?c ?o) (not (holding ?c ?o))))(at end (when (not (holding ?c ?o)) (load-failed)))))Figure 2: Converting (at end) conditionsary accommodated simply adding new disjunct definition must-bestationary. approach advantage explicitly introducing new conceptmust-be-stationary, helps understanding structuring domain. contrast, (over all) conditions one concept changing at.simple example difference appears trivial, key ideanew concept like must-be-stationary domain, use buildcomplicated concepts.Using explicit progressive preconditions also allows coordination far complex shared uses resource. example, specify refueling drivingrequire exclusive use truck, changing tire done concurrentlyrepairing truck concurrently loading. conditions accommodated action explicitly mention excluded activities precondition,axioms grouping structuring activities complex conditionsusing conditions action preconditions. either case resultexplicit description domain easier understand, debug modify.2.2 (at end):(at end) strange condition. fact, appear competitiondomains. would argue also needed; easily capturedconstructs, rather unnatural would never appear reasonabledomain model. (at end) intended support flexibility whereby actionrelease condition actions might delete condition, longcondition subsequently restored time. Like (over all) condition effectbreaking Markovian nature normal action specifications. natural waymodel situation, would claim, simply use conditional (at end) effects:required condition holds end, desired effect created, otherwise badeffect occur. modified load-truck action given Figure 2.129fiBacchus(:durative-action burnMatch:parameters (?m - match ?l - location):duration (= ?duration 5):precondition (and (have ?m)(at ?l)):effect(and (when (no-other-light-source ?l)(and (not (dark ?l)) (light ?l)))(not (have ?m))(burning ?m)(at end (when (burning ?m) (not (burning ?m))))(at end (when (and (no-other-light-source ?l)(burning ?m))(and (not (light ?l))(dark ?l)))))))(:action blowOutMatch:parameters (?m - match ?l - location):precondition (and (at ?l)(burning ?m)):effect(and (not (burning ?m))(when (no-other-light-source ?l)(and (not (light ?l))(dark ?l))))))Figure 3: Alternate model burn-matchmodification, instead (at end (holding ?c ?o)) condition, simplychanged effects action. (holding ?c ?o) holds end action,action normal effects. Otherwise, adds state marker indicatingload failed. add (not (load-failed)) goal, planner would searchways falsifying antecedent effect (assuming (load-failed) cannotundone), i.e., planner would search ways ensuring (holding ?c ?o) trueend action. Note exactly planner would ensureordinary precondition holds. is, reduce constructstandard features.3. Unspecified DurationsAnother feature pddl2.1 ability specify ranges durations actions.intent actual duration action might affected actions.burnMatch heat-water actions (Figures 10 12 pddl2.1 document)examples range utilized duration.find flexible durations strange, make action dependent futureactions. Furthermore, convinced necessary. Rather thinknatural way model situations would introduce two actions, one startaction (light match, start heating liquid), one end action (blowmatch, take liquid heat). Figures 3 4 present alternate models.burnMatch starts match burning (toggling lighting status locationlight location). also posts default completion130fiA Response pddl2.1(:durative-action heat-water:parameters (?p - pan):duration (= ?duration (/ (- 100 (temperature ?p)) (heat-rate))):precondition (and (full ?p)(onHeatSource ?p)(byPan)):effect (and (heating ?p)(heating-start ?p (current-time))(at end (when (and (byPan) (heating ?p)) (not (heating ?p))))(at end (when (heating ?p)) (assign (temperature ?p) 100))(at end (when (and (not (byPan)) (heating ?p)) (burn-pot ?p)))))(:action take-off-heat:parameters (?p - pan)(?startt - time):precondition (and (heating ?p)(heating-start ?p ?startt)(byPan)):effect (and (not (heating ?p))(when (not (burn-pot ?p))(increase (temperature ?p)(* (- (current-time) ?startt) (heat-rate))))))Figure 4: Alternate model heat-watermatch burning maximum duration. match still burning endmaximum duration extinguished lighting status toggled (if matchsource light). hand, match extinguished earlierblowOutMatch action.heat-water action starts water heating, like burn-match defaultmaximum duration. pan still heated end time raisestemperature pan 100 degrees, and, agent pan, takes panheat, otherwise pan continues heated causing become burnt (thiskeeping previous discussion wanting (at end) preconditions). Notepans temperature never rises 100 (we assuming water keeps boiling).also marks time heating started ((current-time) time actionexecuted). take-off-heat action take pan heat time.uses start time heating calculate temperature water (if potburnt, temperature remains 100, set heat-water).suggesting alternate action specifications right models(e.g., heat-water cannot account putting pot back heat takingoff). suggesting case variable durations made.really necessary even natural domain modeling?4. Conclusionscould list components pddl2.1 seem unnecessary,believe point made. pddl2.1 essential planning competition,certainly strong supporter usefulness competition furtheringplanning research. However, would suggest outside context competition,131fiBacchusissue features included planning domain specification languageneeds grounded application languages. Planning domains, evensimplified ones designed research, modeled many different ways, believebetter produce robust models simpler languages developlanguages features really needed.think many ideas contained pddl2.1 useful, e.g., waycontinuous change treated. Nevertheless, would encourage anyone tryconstruct planning algorithms dealing features. Rather would encouragedevelopment planning algorithms inspired issues arise interestingdomains. is, think incorporation new features planning languagesneeds motivated compelling examples.ReferencesBacchus, F., & Ady, M. (2001). Planning resources concurrency, forward chainingapproach. Proceedings International Joint Conference Artificial Intelligence (IJCAI), pp. 417424.132fiJournal Artificial Intelligence Research 20 (2003) 145-148Submitted 9/03; published 12/03CommentaryPDDL2.1 Art Possible?Commentary Fox LongDrew McDermottdrew.mcdermott@yale.eduDept Computer Science, Yale University,PO Box 208285, New Haven, CT 065208285AbstractPDDL2.1 designed push envelope planning algorithms do,succeeded. adds two important features: durative actions, take time (andmay continuous effects); objective functions measuring quality plans.concept durative actions flawed; treatment semantics revealsstrong attachment way many contemporary planners work. Future PDDLinnovators focus producing clean semantics additions language,let planner implementers worry coupling algorithms problems expressedlatest version language.things considered, Fox Long done terrific job producing PDDL2.1. knowexperience getting committee agree language requires delicate combination diplomacy decree. language extensions emerged 2002competition exactly anyone wanted, apparently everyone livethem. PDDL2.1 serving sturdy basis evaluating comparing planning algorithms, prime purpose language first place. appearsnext competition minor extensions, revisions, necessary.top work negotiating syntax language, Fox Long also produced semantics, display paper, plus elaborate semantics fullyautonomous processes, make PDDL2.1, unfortunately. (I2002 competition committee, and, explain below, enthusiastic otherscommittee concept durative actions.)Probably important innovation PDDL2.1 introduction objectivefunctions plans, thus making plan quality important plan existence. farplanners able much objective functions, indicates thoroughly weve conditioned classical-planning framework. Objective functionsbecome much important future.main defect PDDL2.1 syntax semantics tailored closelycurrently popular style planner. example, functions allowed, exactlyone kind, namely, take non-numeric arguments denote time-varying numericquantities. is, (f ---args--- ), arg must identifier overall valuemust number change situation situation. paradigmatic example(amount-in tank1), might denote volume fuel tank1. term(object-at-distance 3) allowed. restrictions? many plannerseliminate variables outset solution attempt instantiating termsc2003AI Access Foundation. rights reserved.fiMcDermottpossible combinations objects mentioned problem statement. tactic maysound unpromising, many problems reasonable size works surprisingly well.However, soon universe objects becomes infinite tactic stops working,means numbers cant treated like ordinary objects. also means generalfunctions cant part language. function midpoint: LocationLocation Location, would generate infinite set terms (midpointloc-a (midpoint loc-b loc-a)).PDDL 1.0, problems arise functions language. main goal designing agree lowest-common-denominator notation many planners could obviously cope with, could become standardproblem statement. language succeeded quite well regard,1also standard framework discussions go next. discussions,several relevant considerations:1. real-world problems need solved?2. problems lie beyond solvable fringe current state art?3. constructs given clean semantics? coherent semantics all?4. constructs current planning algorithms cope with?listed declining order importance, although grantimportant. believe PDDL2.1 gives much weight consideration 4,example functions good case point. Functions play several different roleslogical theory, PDDL domains are, get it. assemblyplanning domain, someone might want function top (top cylinder-3) denotestop piece worked on. considerations come play?1. Assembly planning real-world problem.2. lies well beyond currently solvable, probably far beyond.3. semantics functions mathematical logic well understood, usesolutions here.4. Current planning algorithms cant cope functions, easilyextended handle functions like top, cant recursively nested.Given answers, considering examples, seems clear adding functions PDDL good idea: would make language easier use realistic problems,many cases would impose minimal burden current planners. presencefunctions makes set problems unsolvable planning system, systemdetect problem encountered go next one. wantedto, could add :functions requirements flag language, hardly seems worthtrouble. But, said above, much weight attached abilities currentplanners PDDL2.1 ended function declaration whose syntax functionsneedlessly restricted whose semantics needlessly complex.1. precise, succeeded well action-based planners, went nowhere hierarchical planners.146fiPDDL2.1 Art Possible?see phenomenon durative actions, is, actions requirespecified amount time execute. committee thrash compromisethings, mainly revolving around far go beyond state art. minority(including me, well Fox Long) thought obvious next stepable model autonomous processes, differ actions two respects:continuous effects, run whenever conditions true (preconditionquite right term), matter target agent (the one executing plans) does.example boiling water: long water pot, water 100degrees Celsius, water boil away, continuously decreasing volume. agentmake use processes making conditions true false appropriate times.Unfortunately, majority committee thought putting processes PDDLbig leap, instead add durative actions. Fox Longs papershows, term durative action really refers two completely different species: actionstake fixed amount time matter what, traveling New YorkLondon;2 actions whose duration partly control planner,boiling water. difference flagged syntactically whether :duration fielddurative action equality (species 1) inequality (species 2). agent executesaction species 1, loses freedom duration action.agent sitting airplane, taking hike. seems unproblematic,consider cleaning warehouse, might modeled taking amount timeproportional messiness warehouse. weird idealization imaginerobot might commit cleaning warehouse, essentially prisonerdecision warehouse clean.Duratives species 2 avoid problem, essentially sneaking autonomous processestheory strange form. allowed use autonomous processes,long pretend target agent executing them. Rather connect processdirectly condition, suppose agent decide stop processpoint consistent constraints ?d, duration action. So, Figure 14Fox Longs paper, rather autonomous process startedstopped changing truth value (onHeatSource pot ), say (onHeatSourcepot ) becomes true false agent starts stops heat-water action.turn-on turn-off actions required.first remark make difference action target agentstop one must wait end marked syntactically. Supposepossible agent get locked kitchen boiling water.longer stop boiling. PDDL2.1, impossible sort thingexpressed. closest come make (over (in agent kitchen))condition durative action, soon agent leaves kitchen mustbring heat-water action close, plan invalid.impression planners handle duratives handle species1, committee decided include duratives. seems clearspecies 2 headed extinction favor straightforward autonomous processes.2. Assuming flight time fixed may seem extreme idealization, allowing time vary(probabilistically?) would push PDDL far beyond classical-planning roots; none controversiesmentioned ever question knowability future.147fiMcDermottFox Long define semantics duratives terms ordinary actions plus monitoring actions make sure conditions remain true intervalstheyre supposed true. possible know exactly monitoring actionssupposed inserted changes fluents linear. way specifying semantics, has, unfortunately, run course. Fox Long point out,future increases complexity temporal constructs make harder expresssemantics PDDL, harder verify plan correct.details durative semantics echo issues arose connectionsemantics functions. tricky part semantics actions incorporatingSTRIPS assumption actions represented terms add lists delete lists,turn requires assuming situations represented finite lists atomicformulas. One might suppose numbers would complicate pictureinfinite number them, fortunately numbers dont compromiseSTRIPS world view. specify blocks location numerical coordinates, stillone location, moving involves deleting assertion stating old locationadding new one.Why, then, Fox Long work hard keep numerical assertions strictly separatenon-numeric? flatten action definitions assigning semantics? quantifiers handled substituting possible terms variables?answer questions odd restrictions functions: Manycurrent planners depend generating possible instances action.usually clarifies semantics language greatly defined without directconnection implementation reasoning system language. (McDermott,2003) sketch formal semantics extension PDDL containing true autonomousprocesses. fulcrum framework set truth conditions process definitions.obvious link requirements planning algorithm, factsemantics allows processes would quite difficult cope exploit. However,hard find subsets process definitions, including corresponding durativeactions, current planners, slight extensions, could handle.One key goals PDDL beginning put pressureautomated-planning community make planners handle realistic class planningproblems. new versions PDDL restricted ways congenial existing planners,sends mixed message, urging us new territory, time reassuring usalgorithms might still basically correct. planning community doesnt reallyneed much reassurance; opt domain-definition language clear syntaxclean semantics find algorithms solve problems domainslanguage describes.ReferencesMcDermott, D. (2003). formal semantics processes PDDL. ProceedingsICAPS-03 Workshop PDDL.148fiJournal Artificial Intelligence Research 20 (2003) 343377Submitted 12/02; published 12/03TALplanner Third International PlanningCompetition: Extensions Control RulesJonas KvarnstromMartin Magnussonjonkv@ida.liu.semarma@ida.liu.seDepartment Computer Information ScienceLinkoping UniversitySE-581 83 Linkoping, SwedenAbstractTALplanner forward-chaining planner relies domain knowledge shapetemporal logic formulas order prune irrelevant parts search space. TALplanner recently participated third International Planning Competition,clear emphasis increasing complexity problem domains used benchmark tests expressivity required represent domains planning system.Like many planners, TALplanner support aspects increase expressivity, number changes planner required. shortintroduction TALplanner, article describes changes madecompetition. also describe process introducing suitabledomain knowledge several competition domains.1. IntroductionLike planners, TALplanner (Kvarnstrom & Doherty, 2000; Doherty & Kvarnstrom,1999; Kvarnstrom, Doherty, & Haslum, 2000; Doherty & Kvarnstrom, 2001; Kvarnstrom &Doherty, 2003; Kvarnstrom, 2002) allows user specify goal shape setatemporal logic formulas must satisfied final state results executingplan. Unlike planners TALplanner also allows specification set temporallogic formulas must satisfied entire state sequence generated plan.Obviously, formulas used specify temporally extended goals,safety maintenance goals must upheld throughout execution plan.However, also possible specify constraints related traditional measures planquality, constraints forbid certain stupid actions taking place,Blockhead blocks world planner Kibler Morris (1981) TLplan BacchusKabanza (2000), initially inspired development TALplanner. example,logistics domain one may specify temporally extended goal stating packagedestination, never picked again, goal stating trucks drivingtwo locations always use shortest path. constraints processedTALplanner order automatically extract control knowledge usedforward-chaining search process, opposed used filter candidate plangenerated. Given sufficiently strong constraints, planner efficiently prunesearch tree, making easier find plan among remaining nodes. Often(as article) search control aspect fact primary reason introducingtemporally extended goal, case goal usually referred control rule.c2003AI Access Foundation. rights reserved.fiKvarnstrom & MagnussonAlthough forward-chaining planners may sometimes suffer lack goal-directednesscompared types planners, use explicitly represented domain-dependentknowledge one way compensating deficiency. significantly, forwardchaining planner always complete description past current states,facilitates use complex operator types complex preconditions conditionaleffects. expressivity useful TALplanner participated third International Planning Competition (IPC-20021 ), clear emphasis increasingcomplexity problem domains used benchmark tests expressivity requiredrepresent domains planning system. fact, TALplanner already supportseveral new features present IPC-20002 , use numericstate variables temporally extended actions variable duration.Nevertheless, several extensions changes implementedcompetition order accommodate semantics PDDL2.1, new versionPDDL (Planning Domain Definition Language, Fox & Long, 2003) used specifyproblem domains problem instances. extensions changes first topicarticle, introduction TALplanner (Sections 2 3), extensionsdiscussed Section 4. second topic describing domain-dependentcontrol rules used six benchmark problem domains hand-tailoredtrack competition, importantly, process generating rulesreasoning behind (Section 5). also describe new changesmade TALplanner competition (Section 6). Finally, concludediscussion positive negative sides using search control knowledgeTALplanner together pointers towards possible future research topics.Please see Long Fox (2003) information basic setupcompetition, detailed descriptions planning domains used, timing planquality results.2. Representation: Using TAL TALplannersemantics TALplanner based extended version TAL-C (Karlsson &Gustafsson, 1999; Doherty, Gustafsson, Karlsson, & Kvarnstrom, 1998), memberTAL (Temporal Action Logics) family narrative-based non-monotonic linear discretemetric time logics reasoning action change. TAL-C developedmodeling domains may include use incomplete information, delayed effectsactions, finite infinite chains indirect effects, interacting concurrent actions, independent processes directly triggered action invocations. Consequently, seenideal choice initial version TALplanner also extensionscould conceivably implemented foreseeable future.TAL narrative consists set labeled statements high-level macro languageL(ND), basic language number statement classes observations fluentvalues (labeled obs), action descriptions (acs), action occurrences (occ), domain constraints(dom), dependency constraints modeling causal relations indirect effects (dep).formal semantics L(ND) defined translation order-sorted first-orderbase language L(FL) circumscription policy providing solution frameramification problems (Doherty, 1994; Gustafsson & Doherty, 1996; Doherty et al., 1998).1. http://www.dur.ac.uk/d.p.long/competition.html2. http://www.cs.toronto.edu/aips2000/344fiTALplanner IPC-2002: Extensions Control RulesL(ND) language designed easily extended different tasks, planning. extension may take shape new specialized macro new typestatement. illustrated Figure 1, TALplanner goal narrative uses version L(ND)called L(ND) , contains standard classes L(ND) statements togetherseveral new types planning-related statements. extensions accompaniedextensions translation function, new variation TAL still sharebase language L(FL).However, TALplanner useL(ND)*L(ND)translation directly planTALPlannerTALTALningprocess. Instead, makes direct usePlan NarrativeGoal Narrativehigher level L(ND) goal narrativeforward-chaining search processL(FL)L(FL)generates plan narrative set1storder1stordertimed action occurrences (correspondingtheorytheoryplan) added,+ Circ(T)+ Circ(T)goal entailed final state.L(FL)+ Quantifier EliminationL(FL)+ Q.E.section, attempt1storder1storderprovide intuitive understanding TALtheorytheory Goalused domain specifications using concrete examplesFigure 1: TAL/TALplanner relationstandard logistics planning domain,set objects (packages) transported truck locations cityairplane airports different cities. next section contains information search process use control rules. See Doherty et al. (1998)detailed description TAL, see Kvarnstrom Doherty (2000)information TALplanner.Notation. formulas L(ND) statements shown using input syntaxTALplanner, exception connectives quantifiers may writtenusing ordinary logical symbols increased clarity. free variables implicitlyuniversally quantified.2.1 Types, Objects State VariablesAlthough planners restricted declaring unstructured set objectsrepresenting types unary predicates, TAL order-sorted allows user specifyhierarchy object types (sorts). logistics domain modeled using standardsort boolean = {true, false} together seven user-specified types: loc (location)subtypes airport city, thing subtypes obj vehicle, lattersubtypes truck plane.TALplanner also allows use numeric types. order keep semanticstypes clear, integers fixed point numbers (that is, numbers fixed numberdecimals) allowed, lower upper bounds must declared numerictype. standard arithmetic operators available numeric typesgiven interpretation semantic attachment.State variables represented using TAL fluents, restricted345fiKvarnstrom & Magnussonpredicates take values arbitrary user-specified sort. logistics domain,one could use two boolean fluents, at(thing, loc) in(obj, vehicle), together cityvalued fluent city of(loc) denoting city containing location loc.2.2 Initial StateGiven fluents defined above, initial state logistics problem instancespecified using L(ND) observation statements:#obs [0] city of(pos1) =city1 city of(pos2) =city2 . . .#obs [0] at(obj11, pos1) at(truck1, pos1) . . .observations consist TAL-C fixed fluent formulas, formulas form [ ] denoting fact fluent formula holds time . fluent formula booleancombination elementary fluent formulas form f =v (f==v input notation),denoting fact fluent f takes value v. boolean fluents,second observation, shorthand notation f f (!f input notation) allowed.notation also extended open, closed, semi-open temporal intervals. additionformulas, function value(, f ) denotes value f time .2.3 Goal: Goal Statements Goal Expressionsstatement class goals (labeled goal) added L(ND) . goal statementconsists fluent formula must hold goal state:#goal at(obj11, airport1) at(obj23, pos1) . . .ability test whether formula entailed (state-based) goal usefultemporally extended goals domain-dependent control rules. Therefore, new macroadded: goal expression goal() holds iff goal problem instance (the conjunction goal statements) entails fluent formula . Stated differently, goal() truemust true every goal state. translation L(FL) somewhat complex;see Kvarnstrom Doherty (2000) information.Note valid plan must end goal state. sufficient visit goal statetemporarily, could case operator effects multiple timepointsfirst satisfying goal destroying concurrent planscreated. (If plans desired reason, would course easy modifydefinition planner accordingly.)2.4 Operator DefinitionsSince TAL-C logic reasoning action change, notion actionsused modeling planning operators. Although TALplanner usesemantics, extended planning language L(ND) contains new operator macroproviding syntax facilitates use resource constraints planningoriented concepts present standard TAL-C. line standardTAL practice preserving logical base language L(FL) semantics providingdifferent variations high-level macro language L(ND) adapted specialtasks.346fiTALplanner IPC-2002: Extensions Control Rulesexamples demonstrate operator definition syntax using three sixlogistics operators. examples shown IPC-2002 benchmark domainsdiscussed.#operator load-truck(obj, truck, loc) :at:precond [s] at(obj, loc) at(truck, loc):effects[s+1] at(obj, loc) := false, [s+1] in(obj, truck) := true#operator unload-truck(obj, truck, loc) :at:precond [s] in(obj, truck) at(truck, loc):effects[s+1] in(obj, truck) := false, [s+1] at(obj, loc) := true#operator drive(truck, loc1 , loc2 ) :at:precond [s] at(truck, loc1 ) city of(loc1 ) =city of(loc2 ) loc1 6= loc2:effects[s+1] at(truck, loc1 ) := false, [s+1] at(truck, loc2 ) := trueAlthough used simple logistics operators above, TALplanner also allowsuse context-dependent quantified effects well prevail conditions. Unlike purepreconditions, prevail conditions limited invocation state operatorrefer entire interval operator executed. intervalprevail condition must hold explicitly specified, provides additional flexibilitycompared requiring precondition must always hold throughout executionaction.2.5 ResourcesTALplanner limited generating sequential plans, resource consumption production could handled using plain operator effects. example, loading truckrequires one unit space, amount available space could decreased follows:#operator load-truck(obj, truck, loc) :at:precond [s] at(obj, loc) at(truck, loc):effects[s+1] space(truck) := value(s, space(truck)) 1, . . .concurrent planning, clearly sufficient, since multiple parallel invocationsload-truck would still consume one unit space. reason, TALplannerexplicit support resources (Kvarnstrom et al., 2000).Resources declared manner similar ordinary fluents:parameters take values arbitrary integer fixed point domain. Unlikeplanners, TALplanner provides one type resource, provides several typesresource effects. Resources produced consumed. also borrowed(and automatically returned), either exclusively, meaning borrower exclusiveuse resource specified interval, non-exclusively, multiple actionsborrow units certain resource concurrently. latter case may appearstrange, useful one wants use resource semaphore mutex.Finally, resources assigned completely new value.347fiKvarnstrom & Magnussonfollowing example, loading truck always consumes one unit space.#operator load-truck(obj, truck, loc) :at:precond [s] at(obj, loc) at(truck, loc):effects[s+1] at(obj, loc) := false, [s+1] in(obj, truck) := true:resources [s+1] :consume space(truck) :amount 1Unlike ordinary fluents, resource res multiple aspects queried usedformulas operator preconditions control rules. timepoint, initial amount available, $init(res). certain amount may consumed timestep ($consumed(res)), produced ($produced(res)), borrowed exclusively ($borrowed(res))borrowed non-exclusively ($borrowed-nonex(res)). results remaining amountavailable ($available(res)), must minimum ($minimum(res))maximum ($maximum(res)) allowed. ability refer aspects directly allowsuser specify complex resource constraints simple minimum maximum value resource, control rule defining maximum amount mayconsumed per time step.concludes description planning domain definitions TAL. followingsections show structure TALplanners forward-chaining search treesearch process constrained using control rules.3. Search Control RulesLike forward-chaining planner, TALplanner searches plan tree rootcorresponds initial state outgoing edge corresponds oneoperators applicable source node. Two trivial examples shown Figure 2,notation [s,t] means action executed time time t.sequential planning (Figure 2a), new action always added time stepprevious action ended. concurrent planning (Figure 2b), TALplanner still adds singleaction time plan, constraint time action executedrelaxed: action must start start existing action currentplan prefix end existing action. searching tree, preferencegiven actions invoked earlier timepoints. words, TALplanner tries addmany applicable actions possible timepoint stepping nexttimepoint, Figure 2b subtree starting [0,4] A3, executing action A3time 0 time 4, would explored backtracking subtree starting[2,5] A3, A3 happens take slightly less time execute due differencesstate action invoked. search process ends soon plannerfound plan ending state satisfying goal. exact definition search treeavailable Kvarnstrom Doherty (2000) sequential TALplanner Kvarnstromet al. (2000) concurrent TALplanner.Although common view node search tree consisting single state,operator function states states, sufficient TALplanner,several reasons: single operator may generate multiple new states, evaluationtemporally extended goal domain-dependent control rule may require accessentire state history beginning initial state, concurrent planning future348fiTALplanner IPC-2002: Extensions Control RulesInitialnode[0,1] A1[3,4] A1[4,7] A3[0,3] A2[0,2] A301Initialnode[0,3] A234[3,4] A1[0,1] A1[0,3] A2[1,12] A4[0,4] A3[2,5] A3[0,2] A3Goalnode2[0,1] A105Goalnode12345[0,3] A2[4,7] A3[0,1] A1[0,3] A2(a) Sequential[2,5] A3(b) ConcurrentFigure 2: Forward-Chaining Search Spacestate may modified several operators reaches final configuration.reasons, convenient view node consisting state sequence,(equivalently) logical model, indicated figure.simple forward-chaining planner implemented searching tree usingstandard search algorithm, iterative deepening depth first search. althoughusing complete search algorithm clearly enough make planner complete,equally clear certain degree goal-directedness required make search processefficient. achieved using domain-dependent control rules.3.1 Using Domain-Dependent Control Rulesfully automated planning, planner generally supplied initial state,set acceptable goal states (often specified using propositional first-order formulasmust hold goal state), set operators used plan.planner determine search plan efficiently, possible exceptionvarious command line options fine-tuned user.However, cases user additional information planning domaincould use planner, information may difficult extract mechanicallysimple domain specification. case, would make sense allow usersupply information planner. Although entails somewhat workuser, may also lead finding plans quickly finding plans higher quality.course many different kinds additional information could givenplanner. TALplanner (inspired TLplan, Bacchus & Kabanza, 2000) allowsuser specify set first-order TAL formulas must entailed final plan.serves two separate purposes. First, allows specification complex temporallyextended goals safety conditions must upheld throughout executionplan, second, additional constraints final plan often allow plannerprune entire branches search tree, since proven leaf branchviolate least one goal. many cases pruning main reasonuse formula, case often called control rule. (Allowing plannerprune branches efficiently requires additional analysis, described Kvarnstrom,2002.)349fiKvarnstrom & Magnusson3.2 Control Rules Logistics Domainfollowing control rules use logistics domain. controlrule examples given IPC-2002 benchmark domains discussed.First, package loaded onto plane plane required move it,i.e., goal requires location another city. Second, unloadedpackage plane, package must arrived correct city satisfying goal.Third, package destination, moved.#control :name only-load-when-necessary[t] in(obj, plane) at(obj, loc)loc [ goal (at(obj, loc)) [t] city of(loc) =6 city of(loc) ][t+1] in(obj, plane)#control :name only-unload-when-necessary[t] in(obj, plane) at(plane, loc)loc [ goal (at(obj, loc)) [t] city of(loc) =city of(loc) ][t+1] in(obj, plane)#control :name objects-remain-at-destinations[t] at(obj, loc) goal (at(obj, loc)) [t+1] at(obj, loc)Note rules could course expressed various logically equivalentforms. variations would identical performance, since TALplanner internallynormalizes many aspects control formulas domain analysis phase.4. Third International Planning Competitionsecond international planning competition (IPC-2000), planning domains usedmainly STRIPS expressivity. Support typed objects required,domains could use ADL-style quantified conditional effects, restricted STRIPSversions also provided.Although expect increase expressivity third competition (IPC2002), quite surprised extent changes. Fortunately, TALplanneralready supported many new requirements, others easily implemented. Despite make rather significant changes order handlecombination extensions efficiently. discussnew requirements affected TALplanner together improvementsprompted domains used competition.4.1 ADL-style Operator DefinitionsThough STRIPS versions planning domains IPC-2002,complex versions domains required use quantified conditional effects. Likecurrent planners, TALplanner limited STRIPS expressivity alreadysupport this.350fiTALplanner IPC-2002: Extensions Control Rules4.2 Numeric Types ArithmeticIPC-2000 domains required numeric values emulated values using ordinaryobjects. Miconic-10 elevator domain, example, floor numbers emulated usingobjects named f0, f1, on. next floor calculated f + 1 usingexplicitly defined predicate above(floor, floor).approach taken simplest versions IPC-2002 domains,also Numeric versions domains numeric types requiredarithmetic operators used. already supported TALplanner,unfortunately enough time write control rules domains.4.3 ConcurrencyDespite fact IPC-2000 domains provided potential using concurrentactions, driving several trucks concurrently logistics domain,reward exploiting potential. Plan quality measured terms numberoperators plan, terms amount time required execute plan.Consequently, several planners (including TALplanner) generated sequential plans,even highly concurrent domains.IPC-2002, plan quality mainly measured terms timepointlast operator finished executing (the makespan plan, scheduling terms),planner generating sequential plans would severely handicapped. Fortunatelyconcurrent version TALplanner already implemented, together supportresources (Kvarnstrom et al., 2000), could used competition.Although concurrent TALplanner already applied number domains,competition provided us varied set domains sometimes exploitedconcurrency slightly different ways. provided us new ideas improvementsTALplanner, several minor enhancements TALplanners formula analysis algorithmsimplemented first phase competition, allowing handle certaintypes control formulas efficiently concurrent planning.4.4 Operators Non-Unit Context-Dependent DurationIPC-2000, plan operator used single time step. SimpleTime Timedversions IPC-2002 planning domains, operators could non-unit duration,(for example) walking requires time driving. already supportedTALplanner, changes required.Timed versions IPC-2002 planning domains, durations operators could also context-dependent, could specified using arithmetic expressions,requiring support numeric types already discussed above. example, timerequired drive truck two locations could specified distancelocations divided speed particular truck. also already supportedTALplanner.TALplanner also permits effects take place multiple timepoints within durationaction, although used competition.351fiKvarnstrom & Magnusson4.5 Non-Integer TimeIPC-2002 contest domains required operator durations calculatedprecision least three decimals, posed problem us. underlying TAL-Clogic based integer time, therefore true TALplanner. Introducingnon-integer time properly would required changes underlying TAL semantics,could done time available, therefore simply multiplieddurations thousand. printing plan, time values divided thousand.4.6 Operators Extended Durationinitial implementation TALplanner (in 19981999), assumed althoughoperators might extended durations, something interesting would happeningsignificant proportion discrete time steps within duration. example,operator invoked might duration 5 time steps, effects take placetime + 1, time + 4, time + 5. assumption influencedalgorithms data structures TALplanner, appeared reasonable time,since planning domains literature used single-step operators.Nevertheless, always intention extend algorithms structureshandling plans sparse effects, discrete time steps contain effects all.would difficult, partly reasoninteresting research issues tackled instead continuously postponed.IPC-2002 finally provided us compelling reason change data structures,together number example domains could used test changes.example, operator timed domain IPC-2002 might duration (say)89.237, requiring 89237 discrete time steps, effects take place beginningend action. led us implement new sparse state structurechange algorithms whose time complexity accidentally depended durationoperator rather number time steps something actually happened.current version TALplanner allows state structures used dependingcharacteristics planning domain.4.7 Moving Targets Rulealready mentioned, TALplanners semantics based use TAL, planning competition uses PDDL2.1. semantic differences two approaches usually major problem, trouble wayeffects durative actions modeled PDDL2.1. essence, PDDL2.1 predicatesnumerical fluents affected effects action considered movingtargets, preconditions another action allowed refertimepoint. Instead, certain intermediate interval (arbitrarily chosen 0.001units time) required assertion fact subsequent usefact, even beginning plan actions cannot begin exactly time 0.TAL, effects taking place time assumed give fluents new values exactlytimepoint, values immediately used. uncertaintyexact time effect takes place, one example explicitly state352fiTALplanner IPC-2002: Extensions Control Rulesvalue unknown inner part certain interval known endinterval (though yet implemented TALplanner).Changing TALplanner use exact PDDL2.1 semantics question,since would change fundamental assumptions planner. Insteadnecessary come workaround let us simulate semantics.several ways could done. One method would involve making minor changesaction definitions order assert final effects action slightly later (0.001units time later, exact). competition instead implemented trivialmodification way plan printed: timepoint something happensplan (for example, operator invoked), additional delay 0.001 inserted.ensures plans safe according PDDL2.1 semantics sometimes leadsgenerating slightly worse plans necessary.4.8 Finding Shortest PathsRover DriverLog domains, vehicles and/or people must travel along road networks, different roads may different costs (lengths) essentialtake shortest path two points.Although possible define shortest path algorithm using TALplanners inputlanguage, formulas become somewhat complicated. Finding shortest pathtwo locations weighted graph places roads seems useful many domains,therefore algorithm implemented directly planner.fact, two algorithms implemented: One finding cost shortestpath two given locations, one finding distance closest locationsatisfying given formula (for example closest location reasonable destinationcertain truck DriverLog domain). functions called controlrules order ensure step one takes leads location shortestpath current destination.5. Modeling Competition Domainseight planning domains third International Planning Competition, six intended hand-tailored planners. Except final domain, UMTranslog-2, domainsexist least four different variations: STRIPS, Numeric (where numeric quantitiesinvolved), SimpleTime (where operators take constant non-unit time), Timed (whereoperator durations may depend actual parameters specific operator invocation).TALplanner participated six domains, due lack time creating controlrules, limited participation STRIPS, SimpleTime, Timed versionsdomains.section describe domains translated PDDL2.1TALplanner, discuss control rules created handle domainsefficiently. main focus two domains: ZenoTravel Satellite.domains describe control rules used competition wellincremental process creating rules, omitting technical detailscouple complex rules turned minimal impact planner performanceplan quality. remaining domains (Depots, DriverLog, Rovers, UMTranslog-2)353fiKvarnstrom & Magnussondescribe general intuitions behind control rules, omitting actual formulasdue space restrictions. First, though, begin comments processformalizing planning domains.5.1 Using Pre-defined PDDL Domains: Half Work Twice Time?order create formal description real-world planning domain, course alwaysnecessary thorough understanding domain plansdomain eventually going used. several reasons required,reasons equally valid regardless whether formalizationeventually used input fully automated planner hand-tailored plannerlike TALplanner.First, understanding domain required order determine aspectsdomain truly need modeled (as types, predicates functions) aspectsabstracted away. example, standard formalization logistics domainmodel distances locations, allows trucks move twolocations one time step. sufficient purposes, plan optimalgiven abstraction may extremely suboptimal actually carried real trucks,usually lack teleportation abilities. Similarly, model package sizesweights, cargo capacities trucks airplanes. Neither model truck drivers,acceptable working hours drivers, additional costs incurred overtime pay, timerequired maintenance activities changing winter tires year.aspects need modeled depends much particular application onemind.Second, detailed understanding domain required order determineoperators available planner exactly preconditions effectsrepresented within abstract logical model domain.finally, hand-tailored planners, domain must understood orderable guide search algorithm using domain-dependent heuristics control rules.Usually aspects domain modeled time, muchinformation knowledge domain gathered order find suitableset predicates operators needed even fully automated plannerreused development control rules heuristics hand-tailored planner.planning competition, however, task divided two parts: organizersdefine set domains using PDDL2.1, competitors handtailored track find suitable ways guiding planners. one way, one could saycompetitors need half work, since formalization already donetask finding control rules remains. Unfortunately still necessaryunderstand domain thoroughly order write control rules.complex domains, half work isolation might easily take twice time,since constraints involved domain understood PDDL2.1formalization rather talking domain experts. especially truecomplex UMTranslog-2 logistics domain, significant amount time spenttrying determine exactly packages allowed moveloaded unloaded various kinds vehicle.354fiTALplanner IPC-2002: Extensions Control RulesFigure 3: ZenoTravel problem instance (STRIPS problem 6)Another problem caused use predefined formalization planningdomain degree detail used model determined advance. realworld would likely minimum level detail required, anythinglevel would acceptable. may seem like problem intuitively,adding new details planning problem ought make harder, would bestremain minimum level detail. always true, especiallycontrol rules involved. seen timed ZenoTravel domain, example,control rules would simpler effective possible refuelspecific level, like real world, rather simple abstract refueloperator unconditionally fills tank completely.taken complaint organization competitionallowing different planners use different formalizations would course completelyinfeasible. Nevertheless, present additional problems encountereddegree real-world domains deserve mentioned here.5.2 ZenoTravel DomainZenoTravel domain, number aircraft fly people cities.five actions available: Persons may board debark aircraft, aircraft may fly,zoom (fly quickly, using fuel), refuel. restrictions many peopleaircraft carry. Flying zooming equivalent except zooming generallyfaster uses fuel. Figure 3 shows example problem, arrows pointinggoal locations.5.2.1 ZenoTravel: STRIPSshow operator definitions STRIPS version ZenoTravel domain.operators less directly translated PDDL representation.main difference PDDL representation uses PDDL2.1 level 1, single-355fiKvarnstrom & Magnussonstep actions, stricter concept mutual exclusion TALplannerautomatically enforces certain invariants, fact aircraft leaveperson boarding, location aircraft modified fly usedprecondition board. TAL-C semantics used TALplanner similarPDDL2.1 level 3 (with durative actions), invariant conditions must statedexplicitly. done using prevail conditions, considered separatetrue pre-conditions. Note STRIPS formalization fly zoom takeamount time, since single-step actions possible.#operator:precond:prevail:effectsboard(person, aircraft, city ) :at[t] at(person, city ) at(aircraft, city )[t+1] at(aircraft, city )[t+1] at(person, city ) := false, [t+1] in(person, aircraft) := true#operator:precond:prevail:effectsdebark(person, aircraft, city ) :at[t] in(person, aircraft) at(aircraft, city )[t+1] at(aircraft, city )[t+1] in(person, aircraft) := false, [t+1] at(person, city ) := true#operator fly(aircraft, city1 , city2 , flevel1 , flevel2 ) :at:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 ) next(flevel2 , flevel1 ):effects[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,[t+1] at(aircraft, city2 ) := true, [t+1] fuel-level(aircraft, flevel2 ) := true#operator zoom(aircraft, city1 , city2 , flevel1 , flevel2 , flevel3 ) :at:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 )next(flevel2 , flevel1 ) next(flevel3 , flevel2 ):effects[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,[t+1] at(aircraft, city2 ) := true, [t+1] fuel-level(aircraft, flevel3 ) := true#operator:precond:prevail:effectsrefuel(aircraft, city , flevel, flevel1 ) :at[t] fuel-level(aircraft, flevel) next(flevel, flevel1 ) at(aircraft, city )[t+1] at(aircraft, city )[t+1] fuel-level(aircraft, flevel) := false, [t+1] fuel-level(aircraft, flevel1 ) := truetranslating operator definitions, time create set control rules.basically two ways this: First, one sit think suitableproperties plan, write control rules ensure propertieshold. Second, one instruct planner show branch exploredsearch tree, observing output one identify obviously stupid choices madeplanner, choosing action instance inevitably leads backtrackingperforming actions useless given goals. Control rules writtenprevent branches tree explored. approachescovered here.begin first method, attempting find number reasonable control rulessimply thinking properties ZenoTravel domain. Given experienceplanning domains, fact quite easy. example, many domainscertain goals satisfied, one never allow356fiTALplanner IPC-2002: Extensions Control Rulesdestroyed. ZenoTravel domain, people destinations never needboard aircraft, gives rise following control rule:#control :name only-board-when-necessary[t] in(person, aircraft) [t+1] in(person, aircraft)city , city2 [ [t] at(person, city ) goal(at(person, city2 )) city 6= city2 ]TAL formula states state transition personaircraft time person aircraft time + 1, (that is, personboarded aircraft), must reason allowed: person mustcertain city must goal person another city.noted previously control formulas usually written many different forms.example, would equally valid state person city (andtherefore aircraft), required somewhere else, nexttimepoint person still board aircraft:#control :name only-board-when-necessary[t] at(person, city ) city2 [ goal(at(person, city2 )) city 6= city2 ][t+1] in(person, aircraft)Note although may first glance appear planner would extraordinarily stupid destroy goals already satisfied, also many casestemporarily destroying goal necessary order satisfy goals. example, goal certain aircraft certain location alreadyreached destination, might still fly number people destinationsreturn destination.Another natural idea (since aircraft follow predetermined routes ZenoTravel,usually real life) would say people debarkreached final destination:#control :name only-debark-when-in-goal-city[t] in(person, aircraft) [t+1] in(person, aircraft)city [ [t] at(aircraft, city ) goal(at(person, city )) ]potential problem rule: cases optimal plan might requirenumber people debark one plane board number planes, couldfly destination concurrently, strictly forbidden only-debark-whenin-goal-city. common problem occurs many planning domains,user determine depending requirements applicationplanner used.number possible choices: could ignore problem accept suboptimal plans, skip rule completely let planner search vastly greatersearch space order find plan guaranteed optimal, compromise,attempt create weaker rule cut search space degreegives optimal closer-to-optimal plans. planning competition conditionssomewhat artificial clearly stated would beneficial plannerspend ten times much effort finding plan plan five percent better,average? guessed would case, consequently chose includecontrol rule stated above.357fiKvarnstrom & Magnussonfuture, better solution would likely prefer plans persondebark reaching destination still allow plans. alternativediscussed detail conclusions.Given two rules, might continue second approach findingcontrol rules. run TALplanner simple problem instance consider operatorsequences planner examines depth-first search process. beginningsequence problem instance Figure 3. complete plan generatedplanner contains 123 operators requires 60 time steps. shown IPC-2002STRIPS result format timepoint action invoked followedaction instance.0:0:1:1:2:2:3:3:(board person4 plane2 city1)(board person5 plane1 city2)(fly plane1 city2 city0 fl5 fl4)(fly plane2 city1 city0 fl3 fl2)(board person1 plane1 city0)(board person2 plane2 city0)(fly plane1 city0 city1 fl4 fl3)(fly plane2 city0 city1 fl2 fl1)4:4:5:5:6:6:7:7:(debark person2 plane2 city1)(debark person5 plane1 city1)(fly plane1 city1 city0 fl3 fl2)(fly plane2 city1 city0 fl1 fl0)(fly plane1 city0 city1 fl2 fl1)(refuel plane2 city0 fl0 fl1)(fly plane1 city1 city0 fl1 fl0)(fly plane2 city0 city1 fl1 fl0)8: (refuel plane1 city0 fl0 fl1)8: (refuel plane2 city1 fl0 fl1)9: (fly plane1 city0 city1 fl1 fl0)9: (fly plane2 city1 city0 fl1 fl0)10: (refuel plane1 city1 fl0 fl1)11: (fly plane1 city1 city0 fl1 fl0)11 : (refuel plane2 city0 fl0 fl1)...beginning operator sequence appears reasonable, time 4, airplanesseem flying around randomly. control rules guiding them, apparentlymainly luck caused planes find reasonable cities fly time 1 3.make airplanes goal-directed, identify three important reasons airplanemove city city2: goal asserts aircraft must end city2plan complete, one passengers wants go city2,person waiting picked airplane city2. following rule formalizesthree intuitions:#control :name planes-always-fly-to-goal[t] at(aircraft, city ) [t+1] at(aircraft, city )city2 [ [t+1] at(aircraft, city2 )(goal(at(aircraft, city2 ))person [ [t] in(person, aircraft) goal(at(person, city2 )) ]person [ [t] at(person, city2 ) goal(at(person, city2 )) ]) ]control rules, TALplanner quickly produce set plans 20 handcoded problems IPC-2002 competition, although plans optimal, nearly bad example given above. Together, plans requiretotal 7164 operators 618 time steps. plan example Figure 3 requires20 operators 7 time steps.Nevertheless, still improvements made. first criterionadmissible: allows plane visit destination even still needs pickdrop passengers. One way preventing would add conditionpassengers must reached destinations:#define [t] all-persons-arrived:person, city [ goal(at(person, city )) [t] at(person, city ) ]358fiTALplanner IPC-2002: Extensions Control Rules#control :name planes-always-fly-to-goal[t] at(aircraft, city ) [t+1] at(aircraft, city )city2 [ [t+1] at(aircraft, city2 )([t] all-persons-arrived goal(at(aircraft, city2 ))person [ [t] in(person, aircraft) goal(at(person, city2 )) ]person [ [t] at(person, city2 ) goal(at(person, city2 )) ]) ]improves plan quality slightly, TALplanner requires 7006 operators 575time steps. new control rule fact strict, seen followingplan tail handcoded STRIPS problem number 3:14:14:14:14:15:15:15:(fly plane2 city4 city7 fl2 fl1)(fly plane4 city8 city9 fl3 fl2)(refuel plane1 city6 fl2 fl3)(refuel plane3 city9 fl4 fl5)(debark person24 plane4 city9)(debark person28 plane4 city9)(debark person34 plane2 city7)15:15:15:15:16:16:(refuel plane1 city6 fl3 fl4)(refuel plane2 city7 fl1 fl2)(refuel plane3 city9 fl5 fl6)(refuel plane4 city9 fl2 fl3)(fly plane1 city6 city8 fl4 fl3)(fly plane3 city9 city4 fl6 fl5)example, plane1 plane3 wait passengers debarkedseveral planes could go final destinations, even thoughclearly see real reason wait, potential passengersalready picked plane1 plane3 already enough fuel.alter control rule according new insight: plane go final destinationpassengers board plane headed towards destinationperson left picked (that is, persons already arrived currentlyboard planes).#define [t] all-persons-arrived-or-in-planes:person, city [ goal(at(person, city )) [t] at(person, city ) aircraft [ in(person, aircraft) ] ]#control :name planes-always-fly-to-goal[t] at(aircraft, city ) [t+1] at(aircraft, city )[t+1] at(aircraft, city2 )((goal(at(aircraft, city2 )) [t] all-persons-arrived-or-in-planesperson [ [t] in(person, aircraft) goal(at(person, city2)) ])person [ [t] in(person, aircraft) goal(at(person, city2 )) ]person [ [t] at(person, city2 ) goal(at(person, city2 )) ])]yields another minor improvement, TALplanner requires 6918 operators564 time steps. example used above, end plan looks follows:14:14:14:14:(fly plane1 city6 city8 fl2 fl1)(fly plane2 city4 city7 fl2 fl1)(fly plane4 city8 city9 fl3 fl2)(refuel plane3 city9 fl4 fl5)15:15:15:15:(debark person24 plane4 city9)(debark person28 plane4 city9)(debark person34 plane2 city7)(fly plane3 city9 city4 fl5 fl4)study plans generated current set rules quickly identifyanother obvious problem: number airplanes may fly location pickperson. again, necessary find reasonable balance findingoptimal plans finding plans quickly. contest, attempted find high quality359fiKvarnstrom & Magnusson(but probably non-optimal) plan quickly possible. done ensuringone airplane may go given place time, sole purposegoing pick person waiting:#control :name planes-always-fly-to-goal[t] at(aircraft, city ) [t+1] at(aircraft, city )city2 [ [t+1] at(aircraft, city2 )((goal(at(aircraft, city2 )) [t] all-persons-arrived-or-in-planesperson [ [t] in(person, aircraft) goal(at(person, city2 )) ])person [ [t] in(person, aircraft) goal(at(person, city2 )) ]person [ [t] at(person, city2 ) goal(at(person, city2 )) ]aircraft2 [ [t+1] at(aircraft2, city2) aircraft2 6= aircraft ])]rule provides major improvement, complete set plans requires 5075operators 434 time steps.far, controlled airplanes fly, people board airplane,debark. rules governing refueling, quick look plan onelarger problem instances reveals whenever aircraft nothing else do,refuel. seems little bit wasteful, satisfied adding rule statingairplanes must refuel tanks empty. rule perfect, sinceairplane may miss opportunity pre-emptively refuel still refuel one fuellevel even going fly, provide significant improvement, bringingnumber operators 4234. number time steps still 434.minor adjustments made rules used competition. adjustments include modification only-board-when-necessary ensureperson must travel city city2 choose plane already needsvisit city city2 , possible, since less likely increase totalnumber flights.One final change prompted fact intended differences timingfly zoom cannot modelled correctly STRIPS version domain. Sinceoperators must take amount time, difference twooperators zoom uses twice much fuel. Although would possibleadd control rule ensuring zoom used, easier simply removezoom operator domain definition.5.2.2 ZenoTravel: SimpleTimeSimpleTime version ZenoTravel quite similar STRIPS version,difference actions may non-unit duration certain preconditionsmust hold throughout execution action. TALplanner operator definitionschanged accordingly. example, board fly operators changed follows:#operator board(person, aircraft, city ) :at:precond [t] at(person, city ) at(aircraft, city ):prevail[t+1, t+20] at(aircraft, city ):duration 20:effects[t+1] at(person, city ) := false, [t+20] in(person, aircraft) := true360fiTALplanner IPC-2002: Extensions Control RulesFigure 4: ZenoTravel problem instance (SimpleTime problem 3)#operator fly(aircraft, city1 , city2 , flevel1 , flevel2 ) :at:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 ) next(flevel2 , flevel1 ):duration 180:effects[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,[t+180] at(aircraft, city2 ) := true, [t+180] fuel-level(aircraft, flevel2 ) := truerun planner set SimpleTime problem instances, get almost immediateresults: planner claims plan instances. reasonis, course, control rules must satisfied valid plan, rulesdesigned underlying assumption actions unit duration. example,consider planes-always-fly-to-goal, states plane leaves city time t,meaningful destination t+1. fly action invoked plane mustcity city1 , beginning next time step intervalaircraft present city all, finally arrives city2 180 time steps later.words, planes-always-fly-to-goal ensures fly operator cannot usedall, quite originally intended.One way solving problem would alter planes-always-fly-to-goal sayplane leaves city time t, meaningful destination t+180. Unfortunately, duration flight would encoded directly control rule insteadoperator, would work Timed version, operatorsvariable durations fact, would even work SimpleTime, zoomoperator must also taken account.Instead, domain model augmented new fluent flying-to(aircraft, city)keeps track whether plane flying, so, destination is. ensurefluent kept up-to-date, following added effects fly zoom operators:[t+1] flying-to(aircraft, city2 ) := true, [t+180] flying-to(aircraft, city2 ) := false // fly[t+1] flying-to(aircraft, city2 ) := true, [t+100] flying-to(aircraft, city2 ) := false // zoomplanes-always-fly-to-goal rule changed follows, statingaircraft ceases city , must flying reasonable destination:#control :name planes-always-fly-to-goal[t] at(aircraft, city ) [t+1] at(aircraft, city )city2 [ [t+1] flying-to(aircraft, city2 ) . . . ]problem arises boarding, new fluent boarding(person, aircraft) addedused whenever necessary. Given changes, following first steps361fiKvarnstrom & Magnussonplan generated TALplanner problem instance Figure 4, shown IPC-2002timed result format timepoint action invoked followedaction instance duration action:0: (board person1 plane1 city0) [20]20: (fly plane1 city0 city1 fl4 fl3) [180]20: (zoom plane1 city0 city1 fl4 fl3 fl2) [100]Intuitively, flying zooming plane1 time impossible,forgotten specify planner. actions preconditions satisfiedtime 20, prevail conditions, effects actions contradictsince take place different timepoints: fly ends time 200, zoomends time 120.several ways specifying fly zoom mutually exclusive.example, would possible introduce interval effect stating flying-to(aircraft,city2 ) must hold throughout inner execution intervals actions, become falseend action:[t+1,t+179] flying-to(aircraft, city2 ) := true, [t+180] flying-to(aircraft, city2 ) := false // fly[t+1,t+ 99] flying-to(aircraft, city2 ) := true, [t+100] flying-to(aircraft, city2 ) := false // zoomwould also possible use semaphore resource: aircraft-specific resourceinitial value 1, borrowed exclusively fly zoom actions.one solutions used, TALplanner finally rewards us short correct plan:0: (board person1 plane1 city0) [20]20: (fly plane1 city0 city1 fl4 fl3) [180]200: (board person3 plane1 city1) [20]200: (debark person1 plane1 city1) [30]230: (fly plane1 city1 city0 fl3 fl2) [180]410: (debark person3 plane1 city0) [30];; Plan length 6, maxtime 440improved? Remember STRIPS version never made use zoomoperator. SimpleTime version, flying takes 180 time steps uses one unitfuel, zooming takes 100 time steps uses two units fuel, refueling one unittakes 73 time steps. 180 + 73 100 + 2 73 therefore oppositesituation: zoom always better fly. Commenting unwanted fly operator yieldsfollowing plan:0: (board person1 plane1 city0) [20]20: (zoom plane1 city0 city1 fl4 fl3 fl2) [100]120: (board person3 plane1 city1) [20]120: (debark person1 plane1 city1) [30]150: (zoom plane1 city1 city0 fl2 fl1 fl0) [100]250: (debark person3 plane1 city0) [30];; Plan length 6, maxtime 280362fiTALplanner IPC-2002: Extensions Control Rules5.2.3 ZenoTravel: TimedTimed version complicates timing actions. Boarding disembarking times constant problem-specific defined respective problemdefinition two new functions, boarding-time debarking-time. Refueling always fillsplane maximum capacity, consumes time relative amount fuel receivedrefuel-rate aircraft. aircraft also fast-speed slow-speedcorresponding fast-burn slow-burn fuel consumption. distances citiesspecified using distance(city1, city2 ) function.Timed version, operator durations correctly calculated precisionthree decimals, prompting TALplanner changes discussed Sections 4.5 4.6.extensions TALplanner implemented, changes neededtransform SimpleTime domain Timed version.important difference perhaps fact depending speed fuelconsumption values defined problem situation operator used,sometimes better use fly operator sometimes better use zoom operator,unlike STRIPS version fly always better SimpleTime domainzoom always better.zooming better flying? may seem like would easy answerquestion, given interested minimizing time: check whetherrefueling aircraft sufficiently able zoom, followed zooming destination,would faster refueling enough able fly flying slowlydestination. handled first clause use-fly-instead-of-zoom below.precondition fly altered require use-fly-instead-of-zoom true,precondition zoom requires use-fly-instead-of-zoom false. interestedminimizing combination time fuel usage, could also takenaccount.quite sufficient handle problems, though. airplane maximumfuel capacity, destination distant, may able zoom. handledsecond clause use-fly-instead-of-zoom.Yet another problem possible tie one refueling action flight,one would expect real world. two reasons problem.First, airplanes may already fuel initial state, situationsplane might zoom destination without incurring additional cost, assumingtime required executing plan metric used planealready enough fuel anyway never refuel.Second, unlike SimpleTime version, airplane cannot refuel enoughrefuel operator always fills tank completely. change likely introducedorder make planning task easier reducing number possible actions choose(for example, planner needs create ground instances operatormight trouble refuel operator would take amount fuel floatingpoint argument). despite probable intention behind change, introduces newproblems control formulas. planes tank half full enough fuelzoom B, might fill entire tank continuing C,used fly operator, might able continue C without refueling all.363fiKvarnstrom & Magnussonmeans one would take possible future flights account determiningwhether fly zoom. domain modeled detail, problem wouldexisted.Given two complications, guaranteeing optimal near-optimal plan usingcontrol rule easy, indeed expected. competition decidedsatisfied heuristic compromise, adding third clause use-fly-instead-of-zoomensuring zooming would require refueling immediately flying would not, flyoperator would used.// Fly (probably) better zoom if:#define [t] use-fly-instead-of-zoom(aircraft, city1, city2):// fly faster wrt speed refueling.([t] (10000 / slow-speed(aircraft) + 10000 * slow-burn(aircraft) / refuel-rate(aircraft)) <(10000 / fast-speed(aircraft) +10000 * fast-burn(aircraft) / refuel-rate(aircraft)))// zoom impossible across given distance.([t] distance(city1 , city2 ) * fast-burn(aircraft) > capacity(aircraft))// zoom refuel immediately fly not.([t] fuel(aircraft) >= distance(city1 , city2 ) * slow-burn(aircraft)fuel(aircraft) < distance(city1 , city2 ) * fast-burn(aircraft))5.2.4 ZenoTravel: DiscussionFinding control rules yield good (but usually suboptimal) plans difficultZenoTravel domain. risks involved flying plane pick passengerssince passengers always fit plane refueling possible city.words, really possible get stuck looking solution. Also, sincegraph cities fully connected, route planning necessary.fourth version ZenoTravel, called Numeric, available contest duelack time decided compete domain.Among things, numeric version contains additional constraint number passengers aircraft carry. first glance, constraint may seemintroduce new problems. However, enforced zoom operator, sincenumeric domain make use durational operators, suffers problemSTRIPS domain: zoom operator consumes fuel limits numberpassengers, deliver advantages faster flying.real difficulty Numeric version comes use problem-specific metricsmeasure quality solution. example, one problem planner mayrequired minimize total-time + 3 * total-fuel-used, another problem mayrequired minimize total-time only. now, usually satisfied findingplans good optimal quality, done tuning control rules,example introducing use-fly-instead-of-zoom function determine whether flyzoom used, discussed above. tuning naturally done domain levelrather problem level. optimizing version TALplanner development.364fiTALplanner IPC-2002: Extensions Control RulesFigure 5: Depots problem instance (STRIPS problem 7)5.3 Depots DomainDepots domain (illustrated Figure 5) contains locations, trucks, hoists, movablecrates, pallets whose locations fixed. Trucks move crates two locationscarry number crates time. Hoists distributed amonglocations load crates trucks stack crates surfaces (pallets crates).goal always bring crates certain configuration stacks,stack placed specific pallet.STRIPS. Depots domain combination two well-known planning domains,logistics domain blocks world. Therefore seems natural start takinglook existing control rules two domains, see whether rulescombined easily whether complex rules required due interactionsmoving stacking blocks.begin blocks world part problem. unbounded blocks worldused benchmark domain IPC-2000, TALplanner used modified versionrules Bacchus Kabanza (2000) ensure planner adds blocksgood towers, stacks already final positiondismantled later order remove block lower level. rules reusedDepots domain? One prerequisite availability temporary storage crates,since worst case every single stack crates must torn completelypossible start stacking crates top other. Fortunately, althoughlimited number pallets, trucks (somewhat counter-intuitively) contain numbercrates, planner use storage. minor changes requiredorder handle two separate types surfaces: Pallets crates.Continuing logistics part, one simple rule reused standardlogistics domain: unload crate goal location. dual rule, load crateneeds moved, required. blocks world rules ensure hoistlift block unless needs moved, therefore already impossible loadblocks truck.remains ensure vehicles drive locations use.standard logistics domain, truck drive another location package365fiKvarnstrom & MagnussonFigure 6: DriverLog problem instance (STRIPS problem 5)needs picked delivered there, due use stacks cratesdepots domain, rule must modified: vehicle may drive location (1)crate must moved another location, (2) crate muststacked differently, (3) crate truck needs location,destination ready, crate also locationtruck yet picked up.SimpleTime. SimpleTime version, lifting dropping crates still takes one unittime, loading takes three units, unloading four, driving ten. changes madeensure mutual exclusion. example, hoists lift one crate time. Also,driving-to fluent introduced keep track trucks headed, similar flying-toZenoTravel.Timed. Timed domain, time required loading unloading crate depends powerful hoist weight crate. time requireddriving two locations depends speed truck distancelocations. Again, minor changes required handle domains, althoughhigher quality plans could certainly produced taking timing accountdetermining hoists trucks use.5.4 DriverLog DomainDriverLog (illustrated Figure 6) yet another logistics domain, time introducingconcept truck drivers road maps. number packages transportedlocations trucks. two sets routes connecting locations: Links,trucks travel, paths, drivers walk along driving truck. truckone driver time load many packages needed.STRIPS. Several control rules used previous logistics domains useful DriverLogminor modifications. example, packages loaded trucksneed moved, unloaded reached final destination.hand, number changes necessary due use road maps.importantly, vehicles previously allowed drive locations immediately useful packages picked delivered. DriverLog366fiTALplanner IPC-2002: Extensions Control Rulesdomain may direct roads locations (specified predicatelink(from, to)), truck may move several intermediate locationsorder reach destination. Consequently control rules must relaxed allowtrucks visit locations useful themselves. Nevertheless, degreegoal-directedness still required. One possible method identify vehicleset locations vehicle might useful, require chooses onelocation takes shortest path chosen destination. method usedcompetition help built-in shortest path algorithm discussed Section 4.8 control rule stating step (each invocation drive walk) mustdecrease distance current destination. following definitions explainedbelow:#define [t] reasonable-truck-location(truck, location):// Omitted due space constraints#distfeature driving-distance-between(from, to) :domain integer :link link#mindistfeature driving-distance-to-location-satisfying-formula:distfeature driving-distance-between :domain integer#define [t] driving-distance-to-reasonable-destination(truck, location):driving-distance-to-location-satisfying-formula(location, to,[t] reasonable-truck-location(truck, to))boolean fluent reasonable-truck-location(truck, loc) defined terms logic formula,specifies whether given location reasonable destination given trucktimepoint evaluated. driving-distance-between function accesses shortestpath algorithm find length shortest path to, givenroad links specified link predicate. driving-distance-to-location-satisfyingformula function accesses another version shortest path algorithm useddriving-distance-to-reasonable-destination order find shortest distance locationlocation satisfies reasonable-truck-location. Since links cost,sufficient require whenever truck moves, driving-distance-to-reasonabledestination decreases.changes required due use drivers. may driverstrucks, packages loaded truck planner knows truckdriver. Drivers disembark still packages truck,goal truck must somewhere else. Drivers may walk alongpaths order reach truck, like trucks, drivers must select one useful destinationtake shortest path chosen destinations.Additional control rules ensure multiple trucks choose destinationunnecessarily, multiple drivers choose walk location.SimpleTime. SimpleTime version, loading unloading objects takes two unitstime, driving takes ten units, walking takes twenty units. operators changedaccordingly, going-to fluent introduced keep track drivers trucksmoving towards new location yet arrived. minor adjustments mustmade control rules.Timed. Timed version, time required walk drive two locations367fiKvarnstrom & Magnussondetermined pair functions specified problem instance. Since individual roadsegments different lengths, method used ensure drivers trucks usedshortest path current destination longer sufficient, must modifiedslightly. this, major changes Timed version.5.5 Rovers DomainRovers domain simulates simplified planetary exploration expedition. lander vesselcarries number rovers planet surface provides communication link backEarth. rover subset general capabilities, retrieving soil samples, retrievingrock samples capturing images using cameras support different imaging modes.cameras mounted rovers, storage compartments, one rover,hold one soil sample one rock sample. Data sample must sentlander communication link. missions revolve around navigating waypointsplanets surface collect samples take images specified objectivesvisible certain waypoints. terrain may prevent rovers going directlytwo waypoints different rovers handle different terrain list routes roveruse provided.STRIPS. Following control scheme similar one used DriverLog, limitmovements rovers locations perform useful action like collectingrock sample capturing image. problem finding path one waypointanother also solved way DriverLog, except roverset routes waypoints.SimpleTime. changes SimpleTime version trivial: Operator durationschanged, mutual exclusion relations need enforced, new fluent calibrating(camera) keeps track whether certain camera calibrated.Timed. Timed version introduces concept energy, rover limitedamount energy action consumes energy. similaruse fuel ZenoTravel domain, also major difference: roversequipped solar panels recharge rover, waypointsrover go directly exposed sun, requirement solarpanels work. airplanes ZenoTravel domain refuel anywhere, fuelusage relevant terms minimization resource usage, whereas rover usesenergy unwisely get stuck shade, unable anything go anywhere.prevent either let planner backtrack search better plan,introduce stricter rules keep energy levels mind deciding roverallowed do. latter approach taken below.critical point rover enough energy reach waypointsun recharge. Using shortest path algorithm possible control ruledetermine distance closest waypoint exposed sun. additionwaypoints previously allowed, also reasonable rover go waypointexposed sun rover enough energy perform actiongo recharge, exist waypoints affordablereasonable visit.368fiTALplanner IPC-2002: Extensions Control RulesFigure 7: Satellite problem instance (STRIPS problem 4)5.6 Satellite DomainSatellite domain number satellites orbit Earth, equipped setscientific imaging instruments. satellites turn space, targeting stars, planets interesting phenomena capture images using different instrument operation modes.modes include regular infrared imaging spectrographic thermographicreadings different problem. planners task schedule series observations satellites used efficiently. Figure 7 shows small example probleminstance, arrows showing directions satellites pointing.Directions represented explicit coordinates. Instead, satellites turnnew direction giving turn operator argument specifying star, planetphenomenon satellite point to. Instruments first need activated usingswitch on, calibrated calibration target calibrate operatorcapture images using take image. satellite enough power operate oneinstrument time, switching active instruments always initiated switchoperator deactivate first instrument.5.6.1 Satellite: STRIPSSince task consists collecting number images, begin restricting usetake image images mentioned goal.#control :name only-take-pictures-of-goals[t] image(direction, mode) [t+1] image(direction, mode)goal(have image(direction, mode))next step restrict directions satellites turn may actually help collecting images. task split control rule, only-point-ingoal-directions, definition goal directions. satellite allowed turn towardsdirection take picture, calibrate instrument goal specifies satellite369fiKvarnstrom & Magnussonpoint direction work left do.#define [t] goal direction(satellite, direction):[t] take image possible(satellite, direction)instrument [[t] power on(instrument) calibrated(instrument)[t] calibration target(instrument, direction) board(instrument, satellite) ]goal(pointing(satellite, direction)) [t] images collectedtake image possible function checks image collected alsoalready taken satellite necessary instrumentationready. active instrument calibrated, satellite may first turn towardsanother direction calibrate it.#define [t] take image possible(satellite, direction):mode [ goal (have image(direction, mode))[t] image(direction, mode)instrument [[t] power on(instrument) calibrated(instrument)[t] board(instrument, satellite) supports(instrument, mode) ]]switch switch operators still regulated control rulesplanner quickly takes habit repeatedly flipping power different instrumentsoff. instrument powered calibrated, using muchpossible switching another instrument seems reasonable. usefulness function,putting value usefulness particular instrument, helps decide instrumentpower first.#define [t] usefulness(instrument):value(t, $sum(<mode>, [t] supports(instrument, mode) mode needed goal(mode), 1))#define [t] mode needed goal(mode):direction [ goal(have image(direction, mode)) [t] image(direction, mode) ]Add one usefulness score instrument imaging mode supportsneeded goal. score used control rule choosessatellites useful instrument, any.#control :name use-the-most-useful-instrument[t] power on(instrument) [t+1] power on(instrument)[t] usefulness(instrument) > 0satellite, instrument2 [[t] usefulness(instrument2 ) > usefulness(instrument)[t] board(instrument, satellite) board(instrument2 , satellite) ]Switching instrument allowed instrument longer required.#control :name dont-switch-instrument-off-if-you-dont-have-to[t] power on(instrument) [t+1] power on(instrument))[t] mode [ supports(instrument, mode) mode needed goal(mode) ]370fiTALplanner IPC-2002: Extensions Control Rulesrun less obvious improvements, analyzing planner outputreveals one remaining inefficiency: satellites often simultaneously decide turndirection picture needs taken direction, despite factone satellite needs take picture. similar situation ZenoTraveldomain number aircraft may concurrently choose pick passenger,differences due fact reason satellite pointcertain direction order calibrate take image, makes tasksomewhat easier.Therefore problem solved different way, using resource mutualexclusion. resource, called point towards(direction) capacity 1,borrowed temporarily turn duration turn. one satellite turns towardsspecific direction d, satellite turn towards without causing resource conflict.still leaves one problem: first satellite finished turning, longerowns point towards(d) resource therefore another satellite immediately startturning towards d. longer possible one satellite turn towardsdirection once, first satellite taking pictures, satellitesturn direction one one, finally desired pictures takendirection goal direction sees longer valid reason pointtowards d. solved either changing definition goal direction lettingtake image borrow resource.Clearly, type swarming problem occurs quite often concurrent domainsprincipled solution investigated future.5.6.2 Satellite: SimpleTimeSimpleTime version changes duration operators. Turning takes five timeunits, switching instrument takes two units, calibrating takes five units taking picture takes seven units. couple helper fluents, turning towards, calibrating,image generalized (an image exists taken) power generalized (powerswitch action executed) keep track actions beguncompleted. affected control rules updated accordingly.5.6.3 Satellite: TimedTimed version Satellite domain includes two new functions. calibration timespecifies time required calibrate, slew time function represents timerequired satellite turn two directions. Neither changes promptssignificant changes SimpleTime control.5.6.4 Satellite: DiscussionSatellite domain provide real challenge long planner tryingfind correct plan. Finding short plan harder, especially Timed version,would require additional analysis determine order images collectedsatellites used image. using control rules seemedbit like overkill, especially since yet created control rules complexUMTranslog-2 domain. reason, decided satisfied done371fiKvarnstrom & Magnussonfar, surprised plans generated turned considerablylower quality produced planners.contest, informed reason, least main reason:automatic problem generator created problem instances randomized slew timesevery pair directions check geometrical consistency wouldpresent real world situation. subconsciously assumed problem instancessatisfied triangle inequality, case, planning teamsdiscovered this. example, handcoded problem 14, turning satellite directlyphenomenon86 groundstation4 takes 82.860 units time, turning twocarefully selected intermediate directions requires 1.183 units time.Initial testing shows taking consideration using built-inshortest path algorithm yields significantly shorter plans plan length measuredtime point goals satisfied.Another potential improvement would change last clause goal directionallow satellites turn towards direction specified goals soon one startedtaking last picture, rather waiting one finished taking last picture.5.7 UMTranslog-2 DomainUMTranslog-2 domain another logistics domain, 14 types, 38 predicates,24 functions 38 operators, size complexity incomparable previouslyencountered logistics domains contest.Since formal domain definition information provided domainhigh-level description, work informationdomain PDDL definition. major problem previousdomains, since generally quite simple easy understand, giveus problems UMTranslog-2. significant amount time spent tryingdetermine exactly packages allowed move loadedunloaded various kinds vehicles. retrospect, would probably betterteams did: Skip UMTranslog-2 domain completely spendtime Numeric Complex versions domains.domain. Trucks, trains aircraft transport packages locationsmust follow strict movement patterns. locations transportation hubs,transportation centers rest ordinary locations. package allowedmove hierarchy move two locationslayer once. longest possible route package thus ordinary locationtransportation center hub another hub transportation center finallyanother ordinary location.domain groups locations cities, grouped regions. Truckstravel two locations city existing road routetwo cities. Trains planes always use predefined routes transportation centershubs. great number restrictions complicate movements. Packages mustcompatible vehicle loaded into, vehicle must enough free space,loaded heavily wider, longer higher route destinationlocation accepts. Finally, locations, vehicles routes must available use.372fiTALplanner IPC-2002: Extensions Control RulesControl rules. previous domains, specify reasonable location limitvehicle movements destinations reasonable. truck might want pickdeliver package location or, truck cannot reach goal locationpackage, unload package transportation center picked another vehicle.control rules allow trucks pick several packages. makes findingoptimal solutions impossible general case simplifies search acceptablesolutions great deal. imminent risk packages truckcarrying end wrong location allowed travel about, pickingpackages along way. Since packages must move according specified patterntransportation centers hubs, moving package arrived locationtransportation center allowed package stuck there. Restrictingtrucks picking one package time avoids problem.also large group loading unloading rules controlling, amongthings, opening closing valves doors loading unloading packages.Finally, packages loaded vehicles actually able take usefullocation.Creating control rules meeting contest deadline left time get domainworking concurrent planning. Instead, make sequential planning.Given time, set control rules could definitely improved. planning speedless issue, search allowed higher quality plans generated.better problem instances would needed guidelines developing better controlrules since contest problems make full use intended transportation schemetransportation centers hubs.6. Improvements CompetitionThough planning competition ended AIPS-2002 conference April, 2002,work TALplanner naturally cease there. still many improvementsmade, couple related development new domainscontrol rules implemented summer 2002.6.1 Domain Visualizationdiscussed description ZenoTravel domain, process creating controlrules planning domain often involves incremental improvements. TALplanner runnumber problem instances using one set control rules, possibly without controlrules all, beginning resulting search tree analyzed order determinebad choices made avoided using new improved controlrules. repeated planner consistently finds plans good quality.process, one must study output planner alsostructure particular problem instance solved. example, DriverLogproblem may necessary draw road network used problem instanceusing pen paper, study paths taken trucks, people, packagesroad network, order discover whether improvements would possible.often particular inefficiency appears one large set probleminstances, tracing execution plan hand obviously tedious time373fiKvarnstrom & Magnussonconsuming task ought automated far possible.led development TPVis, generic graphical visualization frameworkTALplanner. TPVis framework used generate domain images article,provides animated display consisting set nodes, nodecontainer atomic object. Containers may represent vehicles (which containpackages), locations (since vehicles, packages objects location)similar concepts, atomic nodes may used packages, instrumentssatellite, type object displayed. Edges nodesindicate form relationship objects, obvious interpretationtwo location nodes connected transportation route. built-in layout enginegenerate layout automatically, manually adjust visual coordinatesnode.visualization framework used concrete plugins adapted specific planning domains. DriverLog plugin, example, displays locations container nodes,linked paths drivers walk links trucks drive. Trucks alsocontainers, contained within specific location, shown Figure 6 page 366.plan generated, TPVis animates actual movements objectslocations. creates better instinctive feel domain, two-dimensionalgraph display gives overview difficult provide using text output.addition animating graph, TPVis simultaneously lists partial plan leadingcurrent state problem goals planner tries satisfy. TPVis also provideslimited form interactive planning since it, point planning process, allowsuser force planner backtrack explore different search branch.development TPVis initiated planning contest.graphical visualization available work contest domains, wouldsaved lot time, possibly tree two.6.2 Automatic translation PDDL TALplannerAlthough obvious automatic translator PDDL TALplanners input format, always urgent features implemented,instead decided translate IPC-2002 domains hand. retrospect mistake. risk making error somewhere translation becomes imminentdealing complex domains UMTranslog-2, 38 operators,highly complex preconditions. Also, translating long formulas hand quite timeconsuming. semi-automatic translator therefore implemented decrease amountwork involved translation process reduce risk introducing errorsdefinition.7. Discussion Conclusionsthird International Planning Competition major step forward termsexpressibility required represent benchmark domains, provided numberinteresting challenges planner wanted participate competition.article described challenges affected TALplanner shown numberextensions made order meet challenges. article also includes374fiTALplanner IPC-2002: Extensions Control Rulesnumber domain-dependent control rules competition domains, ratherpresenting exhaustive list pre-packaged control rules, attempted placeemphasis explaining incremental analysis process eventually leads finalformulas, going particular detail ZenoTravel domain.could seen examples shown paper, control rules often simple,natural common-sense rules, difficult generate given basic knowledge planning domain. rules complex, still difficultunderstand verify someone spent effort generate them. then, unfortunately, rules quite unintuitive, rules complexeasily understood, rules occasionally forbid optimal plans.extent, rules might avoided gaining experience good practiceswriting control rules, extending expressivity language controlrules written complex conditions expressed succinctlynatural manner, simply spending little bit time control rulesavailable planning competition much time spent teachingworking planner implementation. However, another important causecomplexity certain rules probably attempting express search controlknowledge way: control rules prune search tree greatextent even simple depth-first search algorithm sufficient efficiently finding goodplans remainder tree.search control knowledge easily expressed manner, certainly mean control rules abandoned altogether. Instead,learn experience control rules might one multi-purposeplanning tool efficiently easily solve planning problems. Instead,like one would expect, one useful tool deserves place toolboxcombined approaches planning. mention one rather obviousexample, would possible devise heuristic forward-chaining planner whose searchtree would pre-pruned using control rule techniques TALplanner. Control rulescould written exclude plans heuristic gives suboptimal result, potentiallyproviding plans closer optimal, even domains heuristic searchfunction provides good plans may often efficient state number constraintsexplicit control rules.extensions TALplanner considered least since timesecond planning competition 2000, long clear us approach eventually examined explored. could start working this,though, strengths weaknesses control rules explored depth.now, work therefore focused mostly investigating far possibletake TALplanner current shape, explicit control rules meanscontrolling search process. work proved rather fruitful itself, TALplanner well IPC-2000 well IPC-2002. planner becoming reasonablymature, improvements made plannerreleased general use, might time take step back consider relationapproaches depth done previously order investigatepossible advantages hybrid approaches.course, mean nothing done within pure375fiKvarnstrom & MagnussonTALplanner framework. contrary, many additional topics pursued,including investigating application TALplanner plan optimization problems (wheresimplest approaches might involve applying standard optimal graph search algorithms pruned search tree generated TALplanner) extending plannerhandle incomplete knowledge non-deterministic operators. many topicsnext focus research yet determined.Acknowledgementsresearch supported part WITAS Project Wallenberg Foundation.ReferencesBacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116 (12), 123191.Doherty, P. (1994). Reasoning action change using occlusion. Cohn, A. G.(Ed.), Proceedings 11th European Conference Artificial Intelligence (ECAI94), pp. 401405. John Wiley Sons. Available ftp://ftp.ida.liu.se/pub/labs/kplab/people/patdo/ecai94.ps.gz.Doherty, P., Gustafsson, J., Karlsson, L., & Kvarnstrom, J. (1998). TAL: Temporal ActionLogics language specification tutorial. Electronic Transactions ArtificialIntelligence, 2 (34), 273306. Available http://www.ep.liu.se/ej/etai/1998/009/.Doherty, P., & Kvarnstrom, J. (1999). TALplanner: empirical investigation temporallogic-based forward chaining planner. Dixon, C., & Fisher, M. (Eds.), Proceedings6th International Workshop Temporal Representation Reasoning, pp. 4754. IEEE Computer Society. Available ftp://ftp.ida.liu.se/pub/labs/kplab/people/patdo/time99-final.ps.gz.Doherty, P., & Kvarnstrom, J. (2001). TALplanner: temporal logic-based planner. AIMagazine, 22 (3), 95102.Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporalplanning domains. Journal Artificial Intelligence Research, issue.Gustafsson, J., & Doherty, P. (1996). Embracing occlusion specifying indirect effectsactions. Aiello, L. C., Doyle, J., & Shapiro, S. C. (Eds.), Proceedings 5thInternational Conference Principles Knowledge Representation Reasoning(KR-96), pp. 8798, San Francisco. Morgan Kaufmann Publishers. Available ftp://ftp.ida.liu.se/pub/labs/kplab/people/patdo/final-kr96.ps.gz.Karlsson, L., & Gustafsson, J. (1999). Reasoning concurrent interaction. JournalLogic Computation, 9 (5), 623650.Kibler, D., & Morris, P. (1981). Dont stupid. Hayes, P. J. (Ed.), Proceedings7th International Joint Conference Artificial Intelligence (IJCAI-81), pp. 345347.Kvarnstrom, J., & Doherty, P. (2003). TALplanner project page. http://www.ida.liu.se/patdo/aiicssite1/kplab/projects/talplanner/.376fiTALplanner IPC-2002: Extensions Control RulesKvarnstrom, J., & Doherty, P. (2000). TALplanner: temporal logic based forward chainingplanner. Annals Mathematics Artificial Intelligence, 30, 119169.Kvarnstrom, J., Doherty, P., & Haslum, P. (2000). Extending TALplanner concurrencyresources. Horn, W. (Ed.), Proceedings 14th European ConferenceArtificial Intelligence (ECAI-2000), Vol. 54 Frontiers Artificial IntelligenceApplications, pp. 501505, Amsterdam. IOS Press. Available ftp://ftp.ida.liu.se/pub/labs/kplab/people/patdo/www-ecai.ps.gz.Kvarnstrom, J. (2002). Applying domain analysis techniques domain-dependent controlTALplanner. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), ProceedingsSixth International Conference Artificial Intelligence Planning Scheduling(AIPS-2002), pp. 101110. AAAI Press, Menlo Park, California.Long, D., & Fox, M. (2003). 3rd international planning competition: Resultsanalysis. Journal Artificial Intelligence Research, issue.377fiJournal Artificial Intelligence Research 20 (2003) 155-194Submitted 10/2002; published 12/2003Sapa: Multi-objective Metric Temporal PlannerMinh B.Subbarao KambhampatiBINHMINH @ ASU . EDURAO @ ASU . EDUDepartment Computer Science EngineeringArizona State University, Tempe AZ 85287-5406AbstractSapa domain-independent heuristic forward chaining planner handle durative actions, metric resource constraints, deadline goals. designed capable handlingmulti-objective nature metric temporal planning. technical contributions include (i)planning-graph based methods deriving heuristics sensitive cost makespan(ii) techniques adjusting heuristic estimates take action interactions metric resourcelimitations account (iii) linear time greedy post-processing technique improve execution flexibility solution plans. implementation Sapa using many techniquespresented paper one best domain independent planners domains metrictemporal constraints third International Planning Competition, held AIPS-02. describe technical details extracting heuristics present empirical evaluationcurrent implementation Sapa.1. Introductionsuccess Deep Space Remote Agent experiment demonstrated promise importance metric temporal planning real-world applications. HSTS/RAX, planner usedremote agent experiment, predicated availability domain- planner-dependentcontrol knowledge, collection maintenance admittedly laborious errorprone activity. obvious question whether possible develop domain-independentmetric temporal planners capable scaling domains. past experienceparticularly encouraging. Although ambitious attemptsincludingIxTeT (Ghallab & Laruelle, 1994) Zeno (Penberthy & Well, 1994), performanceparticularly satisfactory.encouraging signs however recent successes domain-independent heuristic planning techniques classical planning (c.f., Nguyen, Kambhampati, & Nigenda, 2001; Bonet, Loerincs, & Geffner, 1997; Hoffmann & Nebel, 2001). research aimed buildingsuccesses develop scalable metric temporal planner. first blush search control metrictemporal planners would seem simple matter adapting work heuristic planners classical planning (Bonet et al., 1997; Nguyen et al., 2001; Hoffmann & Nebel, 2001).adaptation however pose several challenges:Metric temporal planners tend significantly larger search spaces classical planners. all, problem planning presence durative actions metric resources subsumes classical planning certain class scheduling problems.c2003AI Access Foundation. rights reserved.fiD & K AMBHAMPATICompared classical planners, handle logical constraintsactions, metric temporal planners deal many additional types constraintsinvolve time continuous functions representing different types resources.contrast classical planning, objective find shortest length plans,metric temporal planning multi-objective. user may interested improving eithertemporal quality plan (e.g. makespan) cost (e.g. cumulative action cost, costresources consumed etc.), generally, combination thereof. Consequently, effectiveplan synthesis requires heuristics able track aspects evolving plan.Things complicated fact aspects often inter-dependent.example, often possible find cheaper plan achieving goals, allowedtime achieve them.paper, present Sapa, heuristic metric temporal planner currently developing address challenges. Sapa forward chaining planner, searchesspace time-stamped states Sapa handles durative actions well actions consuming continuous resources. main focus development heuristics focusing Sapasmulti-objective search. heuristics derived optimistic reachability informationencoded planning graph. Unlike classical planning heuristics (c.f., Nguyen et al., 2001)),need estimate length plan needed achieve set goals, Sapas heuristicsneed sensitive cost length (makespan) plans achieving goals.contributions include:present novel framework tracking cost literals (goals) function time.cost functions used derive heuristics capable directingsearch towards plans satisfy type cost-makespan tradeoffs.Sapa generalizes notion phased relaxation used deriving heuristics plannersAltAlt FF (Nguyen et al., 2001; Hoffmann & Nebel, 2001). Specifically,heuristics first derived relaxation ignores delete effects metric resourceconstraints, adjusted subsequently better account negative interactionsresource constraints.Sapa improves temporal flexibility solution plans post-processing plansproduce order constrained (o.c partially-ordered) plans. way, Sapa able exploitease resource reasoning offered position-constrained plans execution flexibility offered precedence-constrained plans. present linear time greedyapproach generate o.c plan better equal makespan value compared given p.cplan.Architecture Sapa: Figure 1 shows high-level architecture Sapa. Sapa uses forwardchaining A* search navigate space time-stamped states. evaluation function (thef (.) function multi-objective sensitive makespan action cost. statepicked search queue expanded, Sapa computes heuristic estimatesresulting children states. heuristic estimation state based (i) computing relaxedtemporal planning graph (RTPG) S, (ii) propagating cost achievement literals156fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERPlanning ProblemSelect statelowest f -valueGeneratestart stateQueue Time Stamped statesfCost & MakespancomponentsSatisfiesGoals?YesPartializep.c. planExpand stateapplyingactionsBuild RTPGPropagate CostfunctionsExtract relaxed planAdjustMutexes ; ResourcesReturno.c p.c plansHeuristicestimationFigure 1: Architecture SapaRTPG help time-sensitive cost functions (iii) extracting relaxed plan P r supportinggoals problem (iv) modifying structure P r adjust mutex resourcebased interactions. Finally, P r used basis deriving heuristic estimate S.search ends state 0 selected expansion satisfies goals. case, Sapa postprocesses position-constrained plan corresponding state convert orderconstrained plan. last step done improve makespan well execution flexibilitysolution plan.version Sapa using subset techniques discussed paper performed welldomains metric temporal constraints third International Planning Competition, heldAIPS 2002 (Fox & Long, 2002). fact, best planner terms solution qualitynumber problems solved highest level PDDL2.1 used competition domainsSatellite Rovers. domains inspired NASA applications.Organization: paper organized follows: Section 2 discuss details actionproblem representation, forward state space search algorithm used produce concurrentmetric temporal plans durative actions. Section 3, address problem propagatingtime cost information temporal planning graph. Section 4 shows propagatedinformation used estimate cost achieving goals given state. alsodiscuss section mutual exclusion relations resource information help improveheuristic estimation. improve quality solution, Section 6 discusses greedy157fiD & K AMBHAMPATIapproach building precedence-constrained plan position-constrained plan returnedSapa. Section 7 discusses implementation Sapa, presents empirical resultsSapa produces plans tradeoffs cost makespan, analyzes performance2002 International Planning Competition (IPC 2002). present discussion related workSection 9 conclude Section 10.2. Handling Concurrent Actions Forward State Space PlannerSapa addresses planning problems involve durative actions, metric resources, deadlinegoals. section, describe planning problems represented solvedSapa. first describe action representation, present forward chaining state searchalgorithm used Sapa.2.1 Action Representation & ConstraintsPlanning problem finding set actions start times execution satisfycausal, metric, resource constraints. section, briefly describe representation,extension action representation PDDL2.1 Level 3 (Fox & Long, 2001),expressive representation level used third international competition. extensionsPDDL2.1 are: (i) interval preconditions; (ii) delayed effects happen time pointsactions start end time points; (iii) deadline goals.shall start example illustrate action representation simple temporal planning problem. problem variations used running examples throughoutrest paper. Figure 2 shows graphically problem description. problem, groupstudents Tucson need go Los Angeles (LA). two car rental options. students rent faster expensive car (Car1), go Phoenix (PHX) Las Vegas(LV). However, decide rent slower cheaper Car2, use drivePhoenix directly LA. Moreover, reach LA, students also take train LVflight PHX. total, 6 movement actions domain: drive-car1-tucson-phoenixc1c1(Dtp, Dur = 1.0, Cost = 2.0), drive-car1-tucson-lv (D tlv, Dur = 3.5, Cost = 3.0), drive-car2c2c2tucson-phoenix (Dtp , Dur = 1.5, Cost = 1.5), drive-car2-tucson-la (D tla),Dur = 7.0, Cost =6.0, fly-airplane-phoenix-la (Fpla , Dur = 1.5, Cost = 6.0), use-train-lv-la (T lvla , Dur = 2.5,Cost = 2.5). move action (by car/airplane/train) two cities X requiresprecondition students X (at(X)) beginning A. also two temporaleffects: at(X) occurs starting time point at(Y ) end time point A. Drivingflying actions also consume different types resources (e.g fuel) different rates dependingspecific car airplane used. addition, refueling actions cars airplanes.durations refueling actions depend amount fuel remaining vehiclerefueling rate. summaries action specifications example shown rightside Figure 2. example, costs moving train airplane respective ticketprices, costs moving rental cars include rental fees gas (resource) costs.illustrated example, unlike actions classical planning, planning problemstemporal resource constraints, actions instantaneous durations. actionduration DA , starting time SA , end time (EA = SA + DA ). value DAstatically defined domain, statically defined particular planning problem,dynamically decided time execution. example, traveling domain discussed158fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERTrainLas VegasLATucsonCar1Car2PhoenixAirplaneFigure 2: travel exampleabove, boarding passenger always takes 10 minutes problems domain. Durationaction flying airplane two cities depends distance two citiesspeed airplane. distance two cities change time,duration particular flying action totally specified parse planning problem.However, refueling airplane duration depends current fuel level airplane.may able calculate duration given refueling action according fuel levelexact time instant action executed.action preconditions P re(A) may required either instantaneouslytrue time point SA EA , required true starting remain trueduration DA . logical effects Eff(A) divided two sets E (A), Ed (A)containing, respectively, instantaneous effects time points , delayed effects SA +d, DA . PDDL2.1, must equal DA durative preconditions delayed effects.Actions also consume produce metric resources preconditions may also dependvalues resources. resource related preconditions, allow several typesequality inequality checking including ==, <, >, <=, >=. resource-related effects, allowfollowing types change (update): assignment(=), increment(+=), decrement(-=), multiplication(*=), division(/=). essence, actions consume produce metric resourcesway specified PDDL2.1.2.2 Forward Chaining Search Algorithm metric temporal planningVariations action representation scheme described previous section usedpartial order temporal planners IxTeT (Ghallab & Laruelle, 1994) Zeno (Penberthy& Well, 1994). Bacchus Ady (2001) first propose forward chaining algorithmcapable using type action representation still allow concurrent execution actionsplan. adopt generalize search algorithm Sapa. main idea separatedecisions action apply time point apply action. Regularprogression search planners apply action state resulting applicationactions current prefix plan. means start time new action endtime last action prefix, resulting plan allow concurrent execution.contrast, Sapa non-deterministically considers (a) application new actions current time159fiD & K AMBHAMPATIstamp (where presumably actions already applied; thus allowing concurrency)(b) advancement current time stamp.Sapas search thus conducted space time stamped states. define timestamped state tuple = (P, M, , Q, t) consisting following structure:P = (hpi , ti | ti t) set predicates pi true ti last time instantachieved.set values continuous functions, may change course planning. Functions used represent metric-resources continuous values. Examples functions fuel levels vehicles.set persistent conditions, durative preconditions, need protectedspecific period time.Q event queue containing set updates scheduled occur specified timefuture. event e one three things: (1) change True/False valuepredicate, (2) update value function representing metric-resource, (3) endpersistence condition.time stamppaper, unless noted otherwise, say state mean time stamped state. Notetime stamped state stamp describes expected snapshot world timeexecution (as done classical progression planners), also delayed (but inevitable)effects commitments made (or before) time t.initial state Sinit time stamp = 0 empty event queue empty setpersistent conditions. completely specified terms function predicate values. goalsrepresented set 2-tuples G = (hp 1 , t1 i...hpn , tn i) pi ith goal titime instant pi needs achieved. Note PDDL2.1 allow specificationgoal deadline constraints.Goal Satisfaction: state = (P, M, , Q, t) subsumes (entails) goal G hp , tiG either:1. hpi , tj P , tj < ti event Q deletes p .2. e Q adds pi time instant te < ti , event Q deletes p .1Action Applicability: action applicable state = (P, M, , Q, t) if:1. logical (pre)conditions satisfied P.2. metric resource (pre)conditions satisfied M. (For example, conditionexecute action = move(truck, A, B) f uel(truck) > 500 executablevalue v f uel(truck) satisfies v > 500.)1. practice, conflicting events never put Q160fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER3. effects interfere persistent condition event Q.4. event Q interferes persistent preconditions A.Interference: Interference defined violation following conditions:1. Action add event e causes p another event currently Qcauses p. Thus, never state two events event queuecause opposite effects.2. deletes p p protected time point p , delete p tp .3. persistent precondition p, event gives p, eventoccur terminates.4. change value function currently accessed another unterminated action2 . Moreover, also access value functioncurrently changed unterminated action.first glance, first interference condition seems overly strong. However, argue necessary keep underlying processes cause contradicting state changesoverlapping other. example, suppose two actions 1 = build house,A2 = destroy house Dur(A1 ) = 10, Dur(A2 ) = 7. A1 effect house A2effect house end time points. Assuming 1 applied time = 0added event e = Add(has house) = 10. allowed apply 2 time = 0add contradicting event e0 = Delete(has house) = 7, unreasonable believestill house time = 10 anymore. Thus, even though current action modeling, state changes cause house house look happen instantaneouslyactions end time points, underlying processes (build/destroy house) spanwhole action durations make happen. prevent contradicting processes overlapping other, employ conservative approach letting Q contain contradictingeffects.3apply action state = (P, M, , Q, t), instantaneous effectsimmediately used update predicate list P metric resources database S. persistentpreconditions delayed effects put persistent condition set event queue QS.Besides normal actions, special action called advance-time useadvance time stamp time instant e earliest event e event queue Q S.advance-time action applicable state non-empty event queue. Upon2. Unterminated actions ones started time point current state yet finishedt.3. may argued cases process give certain effect, situationscontradicting processes allowed overlap. However, without ability explicitly specify processescharacteristics action representation, currently decided go conservative approach.also mention interference relations preclude condition establisheddeleted course plan long processes involved establishment deletion overlap.example above, legal first build house destroy it.161fiD & K AMBHAMPATIState Queue: SQ={Sinit }SQ6={}S:= Dequeue(SQ)Nondeterministically select applicable/* advance-time action */:= Apply(A,S)satisfies G PrintSolutionelse Enqueue(S,SQ)end while;Figure 3: Main search algorithmapplying action, state gets updated according events event queuescheduled occur te . Note apply multiple non-interfering actions given timepoint applying special advance-time action. allows concurrency final plan.Search algorithm: basic algorithm searching space time stamped states shownFigure 3. proceed applying applicable action current state put resultingstate sorted queue using Enqueue() function. Dequeue() function used takefirst state state queue. Currently, Sapa employs A* search. Thus, state queuesorted according heuristic function measures difficulty reaching goalscurrent state. Next several sections paper discuss design heuristic functions.Example: illustrate different data structures search state = (P, M, , Q, t)maintained search, use (simpler) variation ongoing example introducedend Section 2.1. variation, eliminate route Tucson Los Angeles (LA)going Las Vegas. Moreover, assume many students fit one cardivided two groups. first group rents first car, goes Phoenix (Phx),flies LA. second group rents second car drives directly LA.trip Tucson LA long, second car needs refueled driving.make problem simpler, eliminate boarding/un-boarding actions assumestudents reach certain place (e.g. Phoenix) means transportation (e.g. Car1)arrives there. Figure 4 shows graphically plan search state Ss components changego forward. example, assume ref uel(car) action refuels car maximum20 gallons. Drive(car, ucson, P hoenix) takes 8 gallons gas Drive(car, ucson, LA)takes 16 gallons. Note that, time point 1 , event e1 increases fuel level car2 20 gallons.However, immediately following application action 3 reduces f uel(car2) back lowerlevel 4 gallons.3. Propagating Time-sensitive Cost Functions Temporal Planning Graphsection, discuss issue deriving heuristics, sensitive time cost,guide Sapas search algorithm. important challenge finding heuristics support multiobjective search, illustrated example below, cost temporal aspectsplan often inter-dependent. Therefore, section, introduce approach tracking162fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERInit: at(Car1,T), at(Car2,T), at(Plane,Phx), fuel(Car1)=10, fuel(Car2)=10Activate: e1Apply: A3Activate: e2Apply: A4Activate: e4Apply:Activate: e3Apply:P: {(at(Car2,T),0),(at(Plane,Phx),0)}{(at(Plane,Phx),0)}{(at(Car1,Phx),t2)}{(at(Car1,Phx),t2),(at(Plane,LA),t3)}{(at(Car1,Phx),t2),(at(Plane,LA),t3),(at(Car2,LA),t4)}M: {fuel(Car1)=2,fuel(Car2)=10}{fuel(Car1)=2,fuel(Car2)=4}{fuel(Car1)=2,fuel(Car2)=4}{fuel(Car1)=2,fuel(Car2)=4}{fuel(Car1)=2,fuel(Car2)=4}3: {(fuel(Car1),t2),(fuel(Car2),t1),(at(Car2,T)}{(fuel(Car1),t2),(fuel(Car2),t4}{(fuel(Car2),t4)}{(fuel(Car2),t4)}{(fuel(Car2),t4)}Q: {e1:(fuel(Car2)=20,t1),e2:(at(Car1,Phx),t2)}{e2:(at(Car1,Phx),t2),e3:(at(Car2,LA),t4)}{e3:(at(Car2,LA),t4), {e3:(at(Car2,LA),t4)}e4:(at(Plane,LA),t3)}Activate:Apply: A1, A2A1 = Refuel(car2)A3 = Drive(car2,Tucson,LA)A2 = Drive(car1,Tucson,Phx)t=0{}t1A4 = Fly(Phx,LA)t2t3t4Figure 4: example showing different datastructures representing search state =(P, M, , Q) change advance time stamp, apply actions activate events.top row shows initial state. second row shows events actionsactivated executed given time point. lower rows show searchstate = (P, M, , Q) changes due action application. Finally, show graphicallydurative actions plan.costs achieving goals executing actions plan functions time. propagated costfunctions used derive heuristic values guide search Sapa.Example: Consider simpler version ongoing example. Suppose need goTucson Los Angeles two transport options: (i) rent car drive Tucson LosAngeles one day $100 (ii) take shuttle Phoenix airport fly Los Angeles3 hours $200. first option takes time (higher makespan) less money,second one clearly takes less time expensive. Depending specific weightsuser gives criterion, may prefer first option second vice versa. Moreover,users decision may also influenced constraints time cost imposedfinal plan. example, needs Los Angeles six hours, may forcedchoose second option. However, plenty time limited budget, maychoose first option.163fiD & K AMBHAMPATIsimple example shows makespan execution cost, nominally independent other, nevertheless related terms overall objectives userconstraints given planning problem. specifically, given makespan threshold (e.g.LA within six hours), certain estimated solution cost tied (shuttle feeticket price LA) analogously given cost threshold certain estimated time tiedit. Thus, order find plans good respect cost makespan, needdevelop heuristics track cost set (sub)goals function time.Given planning graph excellent structure represent relation factsactions (c.f., Nguyen et al., 2001), use temporal version planning graph structure,introduced TGP (Smith & Weld, 1999), substrate propagating costinformation. Section 3.1, start brief discussion data structures used costpropagation process. continue details propagation process Section 3.2,criteria used terminate propagation Section 3.3.3.1 Temporal Planning Graph Structureadapt notion temporal planning graphs, introduced Smith Weld (1999),action representation. temporal planning graph given problem bi-level graph,one level containing facts, containing actions planning problem.fact links actions supporting it, action links facts belongprecondition effect lists.4 Actions durative effects represented eventsoccur time actions start end time points. see detaillater parts section, build temporal planning graph incrementally increasingtime (makespan value) graph. given time point t, action activatedpreconditions achieved t. support delayed effects activated actions (i.e.,effects occur future time points beyond t), also maintain global event queueentire graph, Q = {e1 , e2 , ...en } sorted increasing order event time. event queuetemporal graph differs event queue search state (discussed previoussection) following ways:associated whole planning graph (rather single state).contains positive events. Specifically, negative effects resource-relatedeffects actions entered graphs queue.events Q event costs associated individual event (see below).event Q 4-tuple e = hf, t, c, Ai which: (1) f fact e add; (2)time point event occur; (3) c cost incurred enable executionaction causes e. action A, introduce cost function C(A, t) = v specifyestimated cost v incur enable execution time point t. words, C(A, t)estimate cost incurred achieve preconditions time point t. Moreover,action also execution cost (C exec (A)), cost incurred executing4. bi-level representation used classical planning save time space (Long & Fox, 1998),Smith & Weld (1999) show, makes even sense temporal planning domains actuallynotion level. set fact/action nodes, one encoding information earliest timepoint fact/action achieved/executed, lowest cost incurred achieve them.164fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERFunction Propagate CostCurrent time: tc = 0;Apply(Ainit , 0);Termination-Criteria 6= trueGet earliest event e = hfe , te , ce , Ae Q;tc = e ;ce < C(f, tc )Update: C(f, t) = ceaction A: f P recondition(A)N ewCostA = CostAggregate(A, tc );N ewCostA < C(A, tc )Update: C(A, t) = N ewCost(A), tc < ;Apply(A, tc );End Propagate Cost;Function Apply(A, t)effect add f SA +Q = Q {e = hf, + d, C(A, t) + Cexec (A), Ai};End Apply(A, t);Figure 5: Main cost propagation algorithm(e.g. ticket price fly action, gas cost driving car). fact f , similar cost functionC(f, t) = v specifies estimated cost v incurred achieve f time point (e.g. cost incurredLos Angeles 6 hours). also need additional function SA(f, t) = f specifyaction Af used support f cost v time point t.Since using relaxed planning graph constructed ignoring delete effects,resource effects, derived heuristics sensitive negative interactions resourcerestrictions. Sections 5.1 5.2 discuss heuristic measures adjusted takeinteractions account.3.2 Cost Propagation Procedurementioned above, general approach propagate estimated costs incurred achievefacts actions initial state. first step, need initialize cost functions C(A, t)C(f, t) facts actions. given initial state init , let F = {f1 , f2 ...fn } set0 , )}, set outstanding positivefacts true time point init {(f10 , t1 ), ...(fm0events specify addition facts f time points ti > tinit . introduce dummy actionAinit represent Sinit Ainit (i) requires preconditions; (ii) cost C exec (Ainit ) = 0(iii) causes events adding f tinit fi0 time points ti . beginning (t = 0),event queue Q empty, cost functions facts actions initialized as: C(A, t) =, C(f, t) = , 0 < , Ainit action applicable.Figure 5 summarizes steps cost propagation algorithm. main algorithm containstwo interleaved parts: one applying action activating event representingactions effect.165fiD & K AMBHAMPATIAction Introduction: action introduced planning graph, (1) augmentevent queue Q events corresponding effects, (2) update cost functionC(A, t) A.Event Activation: event e = hf e , te , Ce , Ae Q, represents effect eoccurring time point te adding fact fe cost Ce activated, cost function factfe updated Ce < C(fe , te ). Moreover, newly improved cost f e leads reductioncost function action f e supports (as decided function CostAggregate(A, t)line 11 Figure 5) (re)apply graph propagate f e new cost achievementcost functions effects.given time point t, C(A, t) aggregated cost (returned function CostAggregate(A, t))achieve preconditions. aggregation done different ways:1. Max-propagation:C(A, t) = ax{C(f, t) : f P recond(A)}2. Sum-propagation:PC(A, t) = {C(f, t) : f P recond(A)}first method assumes preconditions action depend costachieve equal cost achieve costliest one. rule leads underestimation C(A, t) value C(A, t) admissible. second method (sum-propagation)assumes facts independent thus inadmissible subgoals positive interactions. classical planning scenarios, sum combination proved effectiveadmissible much less informed max combination (Nguyen et al., 2001; Bonet et al., 1997).cost function one preconditions given action updated (lowered),CostAggregate(A, t) function called uses one methods described calculatecost required execute action improved (been reduced). 5 C(A, t) improved,re-apply (line 12-14 Figure 5) propagate improved cost C(A, t) costfunctions C(f, t) effects.remaining issue main algorithm illustrated Figure 5 termination criteria propagation, discussed detail Section 3.3. Notice wayupdate cost functions facts actions planning domains described showschallenges heuristic estimation temporal planning domains. actions effectsoccur instantaneously actions starting time, concurrent actions overlap many possibleways thus cost functions, represent difficulty achieving facts actionstime-sensitive.demonstrating cost propagation process ongoing example, make two observations propagated cost function:Observation 1: propagated cost functions facts actions non-increasing time.Observation 2: increase time steps going events event queue,cost functions facts actions step-functions, even though time measuredcontinuously.5. Propagation rule (2) (3) improve (lower) value C(A, t) cost function one preconditions improved. However, rule (1), value C(A, t) improved cost function costliestprecondition updated.166fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERFigure 6: Timeline represent actions earliest possible execution times relaxed temporal planning graph.Figure 7: Cost functions facts actions travel example.167fiD & K AMBHAMPATIfirst observation, estimated cheapest cost achieving given goal g time pointtg C(g, tg ). need look value C(g, t) time point < g . secondobservation helps us efficiently evaluating heuristic value objective function f involvingtime cost. Specifically, need compute f (finite number of)time pointscost function fact action changes. come back details heuristicestimation routines Section 4.Returning running example, Figure 6 shows graphically earliest time pointaction applied (C(A, t) < ) Figure 7 shows cost function facts/actionschange time increases. outline update process example: time pointc1c2c1c2= 0, four actions applied. tp, Dtp, Dtlv, Dtla. actions add 4 eventsc1c2i,event queue Q = {e1 = hat phx, = 1.0, c = 2.0, Dtp i, e2 = hat phx, 1.5, 1.5, Dtpc1c2e3 = hat lv, 3.5, 3.0, Dtlv i, e4 = hat la, 7.0, 6.0, Dtla i}. advance time =1.0, first event e1 activated C(at phx, t) updated. Moreover, phxprecondition Fpla , also update C(Fpla , t) te = 1.0 2.0 put evente = hat la, 2.5, 8.0, Fpla i, represents Fpla effect, Q. goc2second event hat phx, 1.5, 1.5, Dtplower cost fact phx action F pla . Evente = hat la, 3.0, 7.5, Fpla added result newly improved cost F pla . Continuingprocess, update cost function la time point = 2.5, = 3.0delayed effects actions Fpla occur. time point = 3.5, update cost value lvaction Tlvla introduce event e = hat la, 6.0, 5.5, lvla i. Notice final eventc2c2representing delayed effect action tlaapplied = 0e0 = hat la, 7.0, 6.0, Dtlacause cost update. cost function la updated valuec = 5.5 < ce0 time = 6.0 < te0 = 7.0.Besides values cost functions, Figure 7 also shows supporting actions (SA(f, t),defined Section 3.1) fact (goal) la. see action lvla gives best costC(at la, t) = 5.5 6.0 action F pla gives best cost C(at la, t) = 7.5 3.0 < 5.5C(at la, t) = 8.0 2.5 < 3.0. right graph Figure 7 shows similar costfunctions actions example. show cost functions actions lvlaFpla four actions already applicable time point init = 0 thuscost functions stabilize 0.3.3 Termination Criteria Cost Propagation Processsection, discuss issue terminate cost propagation process.first thing note cost propagation ways inherently complex makespanpropagation. example, set literals enter planning graph (and mutuallyexclusive), estimate makespan shortest plan achieving changecontinue expand planning graph. contrast, estimate cost cheapestplan achieving change planning graph levels off. needcarefully consider effect different criteria stopping expansion planning graphaccuracy cost estimates. first intuition stop propagationexist top level goals cost achievement still infinite (unreached goal).hand, given objective function finding cheapest way achieve goals,need continue propagation chance improve cost achieving168fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERgoals. intuitions, following several rules used determineterminate propagation:Deadline termination: propagation stop time point if: (1) goal G : Deadline(G)t, (2) goal G : (Deadline(G) < t) (C(G, t) = ).first rule governs hard constraints goal deadlines. impliespropagate beyond latest goal deadline (because cost estimation beyond point useless),achieve goal deadline.observation propagated costs change still eventsleft queue possibly change cost functions specific propositions,second general termination rule regarding propagation:Fix-point termination: propagation stop events decrease cost proposition.second rule qualification reaching fix-point gain costfunction fact action. analogous idea growing planning graphlevels-off classical planning.Stopping propagation according two general rules leads us best (lowestvalue) achievable cost estimation propositions given specific initial state. However,several situations may want stop propagation process earlier. First, propagationfix-point, gain cost function fact action, wouldcostly (c.f., Nguyen et al., 2001). Second, cost functions goals may reach fixpoint long full propagation process terminated according general rules discussedabove, costs propositions actions stabilize.Given motivations, introduce several different criteria stop propagationearlier entailed fix-point computation:Zero-lookahead approximation: Stop propagation earliest time pointgoals reachable (C(G, t) < ).One-lookahead approximation: earliest time point goals reachable,execute remaining events event queue stop propagation.One-lookahead approximation looks ahead one step (future) event queues one pathachieve goals relaxed assumption guaranteed hopes executingevents would explicate cheaper path achieve goals. 6Zero one-lookahead examples general k-lookahead approximation,extracting heuristic value soon goals reachable corresponds zero-lookaheadcontinuing propagate fix-point corresponds infinite (full) lookahead.rationale behind k-lookahead approximation goals appear, indication exists least one (relaxed) solution, look ahead one stepssee achieve extra improvement cost achieving goals (and thus leadlower cost solution).76. Note even none events directly related goals, executions still indirectly lead better(cheaper) path reach goals.7. backward planners need run propagation one time, infinite-lookahead higher levelslookahead may pay off, forward planners need evaluate cost goals single searchstate, lower values k may appropriate.169fiD & K AMBHAMPATIComing back travel example, zero-lookahead stops propagation process timepoint = 2.5 goal cost C(in la, 2.5) = 8.0. action chain giving costc1{Dtp, Fpla }. one-lookahead, find lowest cost achieving goal lac2C(in la, 7.0) = 6.0 given action (D tla). two-lookahead approximation,lowest cost la C(in la, 6.0) = 5.5 achieved cost propagation actionc1set {(Dtlv, Tlvla )}. example, two-lookahead effect fix-point propagation (infinite lookahead) deadline achieve la later = 6.0. earlier, sayDeadline(in la) = 5.5, one-lookahead effect infinite-lookaheadc2option gives cost C(in la, 3.0) = 7.5 action chain {D tphx, Fphxla }.4. Heuristics based Propagated Cost Functionspropagation process terminates, time-sensitive cost functions contain sufficient information estimate makespan cost-based heuristic value given state. Specifically,suppose planning graph grown state S. cost functions set goalsG = {(g1 , t1 ), (g2 , t2 )...(gn , tn )}, ti = Deadline(gi ) used derive following estimates:minimum makespan estimate (P ) plan starting given earliesttime point 0 goals reached finite cost C(g, t) < .minimum/maximum/summation estimate slack Slack(P ) plan startinggiven minimum/maximum/summation distances time pointgoal first appears temporal planning graph deadline goal.minimum cost estimate, (C(g, deadline(g))), plan starting state achieving set goals G, C(PS , ), computed aggregating cost estimatesachieving individual goals respective deadlines. 8 Notice usedenote time point cost propagation process stops. Thus, time pointcost functions individual goals C(f, ) lowest value.value : 0 < < , cost estimate plan C(PS , t), achieve goalswithin given makespan limit t, aggregation values C(g , t) goals gi .makespan cost estimates state used basis deriving heuristics.specific way estimates combined compute heuristic values course depend users ultimate objective function is. general case, objective wouldfunction f (C(PS ), (PS )) involving cost (C(PS )) makespan (T (PS )) valuesplan. Suppose objective function linear combination cost makespan:h(S) = f (C(PS ), (PS )) = .C(PS ) + (1 ).T (PS )user cares makespan value ( = 0), h(S) = (P ) = 0 . Similarly,user cares plan cost ( = 1), h(S) = C(P , ). general8. consider G set preconditions dummy action represents goal state, usepropagation rules (max/sum) discussed Section 3.2 directly estimate total cost achieving goalsgiven initial state.170fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERcase, 0 < < 1, find time point t, 0 , ht (S) =f (C(PS , t), t) = .C(PS , t) + (1 ).t minimum value.9ongoing example, given goal Los Angeles (at la), = 0, heuristic value h(S) = 0 = 2.5 earliest time point C(at la, t) < .c1heuristic value corresponds propagation action chain (D tp, Fpla ). = 1Deadline(AtLA ) 6.0, h(S) = 5.5, cheapest cost get timec1point = 6.0. heuristic value represents another solution (D tlv, Tlvla ). Finally,0 < < 1, say = 0.55, lowest heuristic value h(S) = .C(P , t) + (1 ).th(S) = 0.55 7.5 + 0.45 3.0 = 5.47 time point 2.5 < = 3.0 < 6.0. = 0.55,heuristic value h(S) = 5.47 corresponds yet another solution involving driving part wayc2flying rest: (Dtp, Fpla ).Notice general case 0 < < 1, even though time measured continuously,need check every time point t: 0 < < find value h(S) = f (C(PS , t), t)minimal. due fact cost functions facts (including goals) stepfunctions. Thus, need compute h(S) time points one cost functionsC(gi , t) changes value. example above, need calculate values h(S) 0 = 2.5,= 3.0 = 6.0 realize h(S) minimum value time point = 3.0 = 0.55.end section, note multiple goals several possibleways computing C(PS ) cost functions individual goals. consequencefact multiple rules propagate cost, also interactionssubgoals. Broadly, two different ways extract plan costs. either directly usecost functions goals compute C(P ), first extract relaxed plan temporalplanning graph using cost functions, measure C(P ) based relaxed plan.discuss two approaches below.4.1 Directly Using Cost Functions Estimate C(P )terminate propagation using criteria discussed Section 3.3, let G ={(g1 , t1 ), (g2 , t2 )...(gn , tn )}, ti = Deadline(gi ) set goals CG = {c1 , ...cn |ci =C(gi , Deadline(gi )} best possible achievement costs. consider G set preconditions dummy action represents goal state, use propagationrules (max/sum) discussed Section 3.2 directly estimate total cost achieving goalsgiven initial state. Among different combinations propagation rulesaggregation rules compute total cost set goals G, max-max (maxpropagation update C(gi , t), cost G maximum values C(g , Deadline(gi ))admissible. sum-sum rule, assumes total independence facts,combinations different options reflect dependencies facts planningproblem. tradeoffs evaluated empirically.171fiD & K AMBHAMPATIGoals: G = {(g1 , t1 ), (g2 , t2 )...(gn , tn )}Actions relaxed-plan: RP = {}Supported facts: SF = {f : f InitialStateS}G 6=Select best action support g1 t1RP = RP +tA = t1 Dur(A)Update makespan value (RP ) tA < (RP )f Ef f ect(A) addedduration tf starting pointSF = SF {(f, tA + tf )}f P recondition(A) s.t C(f, tA ) > 0G = G {(f, tA )}(gi , ti ) G, (gi , tj ) SF : tj < tiG = G \ {(gi , ti )}End while;Figure 8: Procedure extract relaxed plan4.2 Computing Cost Relaxed Plantake account positive interactions facts planning problems,backtrack-free search goals find relaxed plan. Then, total execution cost actionsrelaxed plan makespan used heuristic estimation. Besides providingpossibly better heuristic estimate, work FF (Hoffmann & Nebel, 2001) shows actionsrelaxed plan also used effectively focus search branches surroundingrelaxed solution. Moreover, extracting relaxed solution allows us use resource adjustmenttechniques (to discussed Section 5.2) improve heuristic estimations. challengeuse cost functions guide search best relaxed plan addressbelow.basic idea work backwards, finding actions achieve goals. action selected, add preconditions goal list remove goals achieved action.partial relaxed plan plan containing selected actions causal structurethem. remaining goals satisfied initial state S, complete relaxedplan extraction process finished. stage, action selected completerelaxed plan contains selected actions likely lowest estimated objective valuef (PS , TS ). given initial state objective function h(S) = f (C(P ), (PS )), Figure 8 describes greedy procedure find relaxed plan given temporal planning graph. First,let RP set actions relaxed plan, SF set time-stamped facts (f , ti )currently supported , G set current goals. Thus, SF collection facts supportedinitial state effects actions RP , G conjunction top level goals9. f (C(PS , t), t) estimates cost (cheapest) plan achieves goals makespan value(PS ) = t, minimum f (C(PS , t), t) (0 ) estimates plan P achieves goals stateP smallest value f (C(PS ), (PS )). value would heuristic estimation objectivefunction minimizing f (C(PS ), (PS )).172fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERset preconditions actions RP currently supported facts SF .estimated heuristic value current (partial) relaxed plan current goal set computedfollows: h(S) = h(RP ) + h(G) h(RP ) = f (C(RP ), (RP )). given setgoals G, h(G) = min0 <t< f (C(G, t), t) calculatedaccording approach discussedPprevious section (Section 4). Finally, C(RP ) = ARP Cexec (A) (RP ) makespanRP , actions RP aligned according causal relationship (see below).elaborate example shown later section.start, G set top level goals, RP empty SF contains facts initial state.Thus C(RP ) = 0, (RP ) = 0 h(S) = h(G). start extraction process backwardsearch least expensive action supporting first goal g 1 . least expensive, meancontributes smallest amount objective function h(S) = h(RP ) + h(G) addedcurrent relaxed plan. Specifically,action supports g 1 , calculate valuehA (S) = h(RP + A) + h((G \ Ef f ect(A)) P recond(A)) estimates heuristic valueadd relaxed plan. choose action smallest h (S) value.action chosen, put preconditions current goal list G, effectsset supported facts SF . Moreover, add precedence constraintaction A1 g1 precondition gives g 1 time point A1 needsit. Using ordering relations actions RP mutex orderings discussedSection 5.1, update makespan value (RP ) current (partial) relaxed plan.ongoing example, suppose objective function h(S) = f (C(P ), (PS )) =.C(PS )+(1).T (PS ), = 0.55 infinite-lookahead criterion used stop costpropagation process. start extracting relaxed plan, initial setting G = {at la},c2RP = SF = {at tucson}. Among three actions tla, Tlvla Fpla supportgoal la, choose action = Fplaadd relaxed plan RP ,estimated value hA (S) = h(RP + A) + h((G \ la) phx) = ( Cexec (Fpla ) + (1) Dur(Fpla )) + mint (f (C(at phx), t)) = (0.55*6.0 + 0.45*1.5) + (0.55*1.5 + 0.45*1.5) =5.475. turns smallest among three actions. add F pla relaxedplan, update goal set G = {at phx}. easy compare two actionsc2c1c2DtphxDtphxsee Dtphxcheaper achieving at-phx given value = 0.55.final cost C(PS ) = 6.0 + 1.5 = 7.5 makespan (PS ) = 1.5 + 1.5 = 3 finalrelaxed plan used final heuristic estimation h(S) = 0.55 7.5 + 0.45 3 = 5.475given state.Notice relaxed-plan extraction procedure, set time points goal setgoal deadlines, instead latest time points cost functions goalsstabilized. reason cost values facts actions monotonically decreasecosts time-sensitive. Therefore, later set time points goals start searchingrelaxed plan, better chance getting low-cost plan, especially usek-lookahead approximation approach k 6= . ongoing example, usezero-lookahead option stop propagation, find smallest cost C(in la) = 8.0= 2.5. search back relaxed plan combination (in la, 2.5) wouldc1find plan P1 = (Dtp, Fpla ). However, search goal deadline, say = 7.0,would realize lowest cost precondition phx F pla = 7.0 1.5 = 5.5c2time point = 2.0) thus final plan P 2 =C(in phx, 5.5) = 1.5 (caused Dtpc2(Dtp , Fpla ) cheaper P1 .173fiD & K AMBHAMPATI4.3 Origin Action Costspreceding discussion cost-based heuristics, implicitly assumed individual action costs specified directly part problem specification. reasonableassumption, also argued unlike duration, cost action implicitly dependent user interested optimizing. example, suppose, transportation domain,user declares objective function optimized as: 104 otalT ime + 0.005 otalF uelU sedwithout providing additional explicit information action costs. possible useobjective function assess costs individual actions (in terms much contributecost portion objective). Specifically, cost action set equal amountfuel used action. value (for combining cost makespan) set basedcoefficients objective function. course, type de-compilation objective function action costs possible objective function linear combination makespanresource consumption.5. Adjustments Relaxed Plan Heuristicnow, heuristic estimates calculated relaxing certain types constraintsnegative effects metric resource consumptions. section, discusscontraints used adjust improve final heuristic values.5.1 Improving Relaxed Plan Heuristic Estimation Static Mutex Relationsbuilding relaxed temporal planning graph (RTPG), ignored negative interactionsconcurrent actions. discuss way using static mutex relations help improve heuristic estimation extracting relaxed plan. Specifically, approach involvesfollowing steps:1. Find set static mutex relations ground actions planning problembased negative interactions. 112. extracting relaxed plan (Section 4.2), besides orderings actionscausal relationships (i.e one action gives effect supports actions preconditions), also post precedence constraints avoid concurrent execution actionsmutex. Specifically, new action added relaxed plan, use precalculated static mutexes establish ordering mutually exclusive action pairsexecuted concurrently. orderings selected wayviolate least number existing causal links relaxed plan.using mutex relations way, improve makespan estimation relaxed plan, thus heuristic estimation. Moreover, cases, mutex relations alsohelp us detect relaxed plan fact valid plan, thus lead early termination10. fact, metric specified first problem Zeno-Travel domain IPC 2003.11. Two actions static mutex delete effects one action intersect preconditions add effectsother.174fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERRelaxed solution mutex:Bmove(package1,airplane1,A,B)package 1move(package2,airplane1,A,C)Plane 1Plane 2Relaxed solution mutex:move(package1,airplane1,A,B)package 1package 2move(package2,airplane2,A,C)Cpackage 2Figure 9: Example mutex relaxed plansearch. Consider example Logistics domain illustrated Figure 9. example, need move two packages cityA cityB cityC two airplanes(plane1 , plane2 ) cityA used move them. Moreover, assume plane 1 1.5times faster plane2 uses amount resources fly two cities.two relaxed plansP1 = {move(package1 , plane1 , cityA, cityB), move(package2 , plane1 , cityA, cityC)}P2 = {move(package1 , plane1 , cityA, cityB), move(package2 , plane2 , cityA, cityC)}contain two actions. first one uses plane carry packages,second one uses two different planes. first one shorter makespan mutexesignored. However, consider mutex constraints, know two actions P 1executed concurrently thus makespan P 1 actually longer P2 . Moreover, static mutex relations also show even order two actions P 1 ,violation first action cuts causal link initial state second one. Thus, mutex information helps us simple case find better (consistent)relaxed plan use heuristic estimate. sketch relaxed plan P 2found. first action A1 = move(package1 , plane1 , cityA, cityB) selected supportgoal at(package1 , cityB), relaxed plan RP = A1 two potential actions support second goal at(package2 , cityC) A2 = move(package2 , plane1 , cityA, cityC)A02 = move(package2 , plane2 , cityA, cityC). mutex information, able chooseA02 A2 include final relaxed plan.5.2 Using Resource Information Adjust Cost Estimatesheuristics discussed Section 4 used knowledge durations actions deadline goals resource consumption. ignoring resource related effects buildingrelaxed plan, may miss counting actions whose purpose provide sufficient resourcerelated conditions actions. ongoing example, want drive car TucsonLA gas level low, totally ignoring resource related conditions, realizeneed refuel car drive. Consequently, ignoring resource constraints may reducequality heuristic estimate based relaxed plan. thus interested adjustingheuristic values discussed last two sections account resource constraints.175fiD & K AMBHAMPATImany real-world problems, actions consume resources, special actionsincrease levels resources. Since checking whether level resource sufficientallowing execution action similar checking predicate preconditions, one obviousapproach adjust relaxed plan including actions provide resource-related condition relaxed plan. However, many reasons, turns difficult decideactions added relaxed plan satisfy given resource conditions (Do & Kambhampati, 2001, gives detailed discussion difficulties). Therefore, introduceindirect way adjusting cost relaxed plan take account resource constraints.first pre-process problem specifications find resource R action Rincrease amount R maximally. Let R amount AR increases R, letC(AR ) cost value AR . Let Init(R) level resource R statewant compute relaxed plan, Con(R), P ro(R) total consumption productionR actions relaxed plan. Con(R) > Init(R) + P ro(R), increase costnumber production actions necessary make difference. precisely:X (Con(R) (Init(R) + P ro(R)))CC+C(AR )RRshall call adjusted cost heuristic. basic idea even though knowindividual resource-consuming action relaxed plan needs another action supportresource-related preconditions, still adjust number actions relaxed plan reasoning total resource consumption actions plan. know resourcesR consumed relaxed plan maximum production resources possibleindividual action domain, infer minimum number resource-increasing actions need add relaxed plan balance resource consumption. ongoingexample, car rented students Tucson enough fuel initial statemake trip Phoenix, LA, Las Vegas, approach discover planner needsadd refuel action relaxed plan.Currently, resource-adjustment technique discussed limited simple consumptionproduction resources using addition subtraction. common forms,evidenced fact metric temporal planning domains used competition, actionsconsume produce resources solely using addition (increase) subtraction (decrease). Modifications needed extend current approach deal types resource consumptionusing multiplication division.6. Post-Processing Improve Temporal Flexibilityimprove makespan execution flexibility plans generated Sapa, post-processconvert partially ordered plans. discuss details process section.start first differentiating two broad classes plans.Position Order constrained plans: position constrained plan (p.c.) planexecution time action fixed specific time point. order constrained (o.c.) planplan relative orderings actions specified.Note p.c. vs. o.c. distinction orthogonal whether concurrency allowedexecution. Indeed, distinguish two subclasses p.c. plansserial parallel.176fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER{Q}{G}A1:{G}RRQGA3:T1RRGR~RT3{Q}A2:QT4R~RA4:T2Figure 10: Examples p.c. o.c. plansserial position constrained plan, concurrency execution allowed. parallel positionconstrained plan, actions allowed execute concurrently. Examples serial p.c. plansones returned classical planners HSP (Bonet et al., 1997), AltAlt (Nguyen et al.,2001), FF (Hoffmann & Nebel, 2001), GRT (Refanidis & Vlahavas, 2001b). parallel p.c.plans ones returned Sapa (Do & Kambhampati, 2001), TP4 (Haslum & Geffner, 2001).Graphplan-based planners (STAN, Long & Fox, 1998; IPP, Koehler et al. 1997) temporalcousins (TGP, Smith & Weld, 1999; TPSYS, Garrido, Onaindia & Barber, 2001) also return parallelp.c plans. Examples planners output order constrained (o.c.) plans Zeno (Penberthy& Well, 1994), HSTS (Muscettola, 1994), IxTexT (Laborie & Ghallab, 1995), RePOP (Nguyen &Kambhampati, 2001), VHPOP (Younes & Simmons, 2003).mentioned above, plans returned Sapa position-constrained (p.c.). Searchingspace p.c. plans advantages presence metric resources (viz.,easy compute amount consumed resources every point partial plan). Positionconstrained plans however less desirable point view execution flexibilityhuman comprehension. latter uses, order (precedence) constrained plan (o.c plan)often better.Figure 10 shows valid parallel p.c. plan consisting four actions 1 , A2 , A3 , A4starting time points fixed T1 , T2 , T3 , T4 o.c plan consisting set actionsachieving goals. action, shaded regions show durationsprecondition effects hold actions execution time. darker ones representeffect lighter ones represent preconditions. example, action 1 preconditionQ effect R; action A3 preconditions two effects R S. arrows showrelative orderings actions. ordering relations represent o.c plan thusexecution trace violate orderings consistent p.c plan.Given p.c plan Ppc , interested computing o.c. plan P oc containsactions Ppc , also valid plan solving original problem. general,many o.c. plans. related work (Do & Kambhampati, 2003), discussconversion problem posed optimization problem subject variety optimizationmetrics based temporal quality flexibility. following discuss greedy strategyused competition version Sapa, finds o.c plan biased reasonablygood makespan. Specifically, extend explanation-based order generation method outlinedKambhampati Kedar (1994) first compute causal explanation p.c planconstruct o.c plan number orderings needed satisfy explanation.strategy depends heavily positions actions original p.c. plan. works basedfact alignment actions original p.c. plan guarantees causationpreservation constraints satisfied. following notation helps describing approach:177fiD & K AMBHAMPATI(pre)condition p action A, use [st pA , etpA ] represent duration phold (stpA = etpA p instant precondition).effect e action A, use et eA represent time point e occurs.resource r checked preconditions used action A, use[strA , etrA ] represent duration r accessed A.initial goal states represented two new actions AG . AI startsactions Ppc , precondition effects representing initialstate. AG starts actions Ppc , effect, top-level goalspreconditions.symbol 00 00 used throughout section denote relative precedence orderingstwo time points.Note values stpA , etpA , eteA , strA , etrA fixed p.c plan partiallyordered o.c plan. o.c plan P oc built p.c plan Ppc follows:Supporting Actions: precondition p action A, choose earliest possible actionA0 p.c plan support p:1. p Effect(A0 ) etpA0 < stpA p.c. plan Ppc .p2. action B that: p Effect(B) et pA0 < etpB < stA Ppc .3. action C also satisfies two conditions et pC < etpA0 .pA0 selected support p A, add causal link 0two time pointsetpA0 stpA o.c plan. Thus, ordering et pA0 stpA added Poc .Interference relations: pair actions A, 0 interfere other, orderfollows:pp1. p Delete(A0 ) Add(A), add ordering etpA etpA0 Poc etA < stA0ppPpc . Otherwise add etA0 etA Poc .pp2. p Delete(A0 ) P recond(A), add ordering et pA etpA0 Poc etA < etApppPpc . Otherwise, etA0 < stA original plan Ppc add ordering etA0 stpAfinal plan Poc .Resource relations: resource r checked (pre)condition action usedaction A0 , based actions fixed starting times original p.c plan P pc , addfollowing orderings resulting P oc plan follows:etrA < strA0 Ppc , ordering relation etrA strA0 added Poc .etrA0 < strA Ppc , ordering relation etrA0 strA added Poc .178fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERstrategy backtrack-free due fact original p.c. plan correct. (pre)conditions actions Ppc satisfied thus precondition p action A,always find action A0 satisfies three constraints listed support p. Moreover,one temporal constraints lead consistent ordering two interfering actions(logical resource interference) always satisfied p.c. plan consistentpair interfering actions overlap P pc . Thus, search backtrack-freeguaranteed find o.c. plan due existence one legal dispatch final o.c. plan P oc(which starting p.c. plan Ppc ). final o.c. plan valid causal-linkevery actions precondition, causal links safe, interfering actions overlap,resource-related (pre)conditions satisfied. Moreover, strategy ensures orderingsPoc consistent original Ppc . Therefore, p.c plan Ppc one among multiplep.c plans consistent o.c plan P oc , makespan Poc guaranteed equalbetter makespan Ppc .algorithm discussed section special case partialization problem metrictemporal planning. related work (Do & Kambhampati, 2003), systematic studygeneral partialization problem give CSOP (Constraint Satisfaction Optimization Problem)encodings solving them. current algorithm seen particular greedy variable/valueordering strategy CSOP encoding.7. Implementation SapaSapa system techniques described paper implemented Java.implementation includes:1. forward chaining algorithm (Section 2).2. cost sensitive temporal planning graph routines propagate cost informationextract heuristic value (Section 3).3. routines extract adjust relaxed plan using static mutex resource information(Section 4.2).4. Greedy post-processing routines convert p.c. plan o.c plan better makespanexecution flexibility (Section 6).default Sapa uses sum-propagation rule, infinite lookahead termination, resource-adjustedheuristics, converts solutions o.c. plans. Besides techniques described paper,also wrote JAVA-based parser PDDL2.1 Level 3, highest level usedThird International Planning Competition (IPC3).visualize plans returned Sapa relations actions plan (suchcausal links, mutual exclusions, resource relations), developed Graphical UserInterface (GUI)12 Sapa. Figure 11 12 shows screen shots current GUI. displaystime line final plan action shown actual duration starting timefinal plan. options display causal relations actions (found using greedyapproach discussed Section 6), logical resource mutexes actions. specifictimes individual goals achieved also displayed.179fiD & K AMBHAMPATIFigure 11: Screen shot Sapas GUI: PERT chart showing actions starting timesprecedence orderings them.Figure 12: Screen shots Sapas GUI: Gant chart showing different logical relationsgiven action actions plan.180fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERMakespan Variation603150292740MakespanTotal CostCost variation30201025232119170150.10.20.30.40.50.600.80.90.9510.1Alpha0.20.30.40.50.600.80.90.951AlphaFigure 13: Cost makespan variations according different weights given objective function. point graph corresponds average value 20 problems.implementation publicly available Sapa homepage 13 . Since plannerwell GUI JAVA, also provide web-based interactive access planner.8. Empirical Evaluationsubjected individual components Sapa implementation systematic empiricalevaluation (c.f. & Kambhampati, 2001, 2002, 2003). section, describe experiments conducted (Do & Kambhampati, 2001) show Sapa capable satisfyingvariety cost/makespan tradeoffs. Moreover, also provide results show effectivenessheuristic adjustment techniques, utility different termination criteria, utilitypost-processing. Comparison Sapa systems International Planning Competitionprovided next section.8.1 Component Evaluationfirst test suite experiments, used test Sapas ability produce solutions tradeoffstime cost quality, consisted set randomly generated temporal logistics problemsprovided Haslum Geffner (2001). set problems, need move packageslocations different cities. multiple ways move packages, option differenttime cost requirements. Airplanes used move packages airports different cities.Moving airplanes takes 3.0 time units, expensive, costs 15.0 cost units. Movingpackages trucks locations different cities costs 4.0 cost units, takes longertime 12.0 time units. also move packages locations inside city (e.g.offices airports). Driving locations city costs 2.0 units takes2.0 time units. Loading/unloading packages truck airplane takes 1.0 unit time costs1.0 unit.tested first 20 problems set objective function specified linear combination total execution cost makespan values plan. Specifically, objective12. GUI developed Dan Bryce13. http://rakaposhi.eas.asu.edu/sapa.html181fiD & K AMBHAMPATIfunction set= .C(P lan) + (1 ).T (P lan)tested different values : 0 1. Among techniques discussedpaper, used sum-propagation rule, infinite look-ahead, relax-plan extraction using staticmutex relations. Figure 13 shows average cost makespan values solution changeaccording variation value. results show total execution costsolution decreases increase value (thus, giving weight execution costoverall objective function). contrast, decreases, giving weight makespan,final cost solution increases makespan value decreases. results showapproach indeed produces solutions sensitive objective function involvestime cost. combinations {problem, }, 79% (173/220) solvable withincutoff time limit 300 seconds. average solution time 19.99 seconds 78.61%instances solved within 10 seconds.8.1.1 E VALUATIONIFFERENT ERMINATION C RITERIAFigure 14 shows comparison results zero, one, infinite lookahead set metrictemporal planning problems competition. take first 12 problems fourtemporal domains: ZenoTravel-Time, DriverLog-Time, Satellite-Time, RoversTime. set= 1 objective function, making entirely cost-based. action costs set 1 unit.discussed Section 3.3, zero-lookahead stops cost propagation process time pointsolution relaxed condition. K-lookahead spends extra effort go beyondtime point hope finding better quality (relaxed) solution use heuristic values guidesearch. running condition specified caption figure.problems three domains ZenoTravel-Time, DriverLog-Time, SatelliteTime, infinite-lookahead returns better quality solutions shorter time one-lookahead,turn generally better zero-lookahead. exception Rovers-Time domain,virtually difference running time solution quality different look-aheadoptions.following elaborate summary results Figure 14. top three figuresshow running time, cost, makespan comparisons ZenoTravel domain (Time setting).domain, within time memory limit, infinite-lookahead helps solve 3 problemsone-lookahead 2 zero-lookahead. one problem (problem 10), infinitelookahead returns equal (three) better (eight) cost solution zero-lookahead. Comparedone-lookahead, better five problems equal six others. makespan value, infinitelookahead generally better, consistent criteria. next three lower figuresshow comparison results DriverLog-Time domain. domain, infinite onelookahead solve one problem zero-lookahead, infinite-lookahead also fastertwo options one problem. costs (number actions) solutions returnedinfinite-lookahead also better two problems (in three solutionssame). One-lookahead also equal better zero-lookahead two problems.Satellite-Time domain, infinite one-lookahead solve three (of twelve) problemszero-lookahead, option consistently solves problems faster other. However,solution quality (cost) infinite one-lookahead consistently better zero-lookahead.Moreover, solution cost plans returned infinite-lookahead worse one-lookahead182fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERZenoTimeTime (ms)30002500La 0La 1La Inf2000150010005004060305020100011 2 3 4 5 6 7 8 9 10 11 12236781232344578910 11 12DriverLog Time67819 10 11 1223456789 10 11 1289 10 11 12ProblemsSatelliteTime5060040500MakespanCost (#Action)La 0La 1La Inf68007006005004003002001000SatelliteTimeSatelliteTime5ProblemProblemsProblems30201040030020010000Problems101MakespanLa 0La 1La Inf1 2 3 4 5 6 7 8 9 10 11 122009 10 11 12353025201510501 2 3 4 5 6 7 8 9 10 11 12Time (ms)530DriverLog TimeCost (#Action)Time (ms)DriverLog Time400000350000300000250000200000150000100000500000440ProblemProblem180000160000140000120000100000800006000040000200000ZenoTimeMakespan3500Cost (#Action)ZenoTime1234567Problems89 10 11 121234567ProblemsFigure 14: Comparison different lookahead options competition domains. experiments run Pentium III-750 WindowsXP machine 256MB RAM.time cutoff 600 seconds.183fiD & K AMBHAMPATIZenoTimeResadjno-resadj10001001040Makespan10000Cost (#Action)50100000Time (ms)ZenoTimeZenoTime1000000302010011357911 13Problems135791113Problems1401201008060402001 2 3 4 5 6 7 8 9 10 11 12 13 14ProblemsFigure 15: Utility resource adjustment technique ZenoTravel (time setting) domaincompetition. Experiments run WindowsXP Pentium III 750MHz 256MBRAM. Time cutoff 600 seconds.one problem slightly better 6 problems. domain, seems bigimprovement zero one look-ahead, infinite-lookahead slight improvementone-lookahead. (The plots Rovers domain shown figure differentlook-ahead options seem lead near identical results domain.) Finally, since heuristicbased completely cost ( =1), not, theory, expect see conclusive patternsmakespan values solutions produced different lookahead options.8.1.2 U TILITYR ESOURCE DJUSTMENT ECHNIQUEprevious work (Do & Kambhampati, 2001), show resource adjustment techniquelead significant quality search speed improvements problems metric temporal logistics domain several types resource consumption objects like trucksairplanes.competition, two domains test utility resource adjustment technique discussed Section 5.2. ZenoTravel domain Rovers domainactions consuming resources (refueling) actions renew them. these, resourceadjustment technique gives mixed results ZenoTravel domain effect Roversdomain. Therefore, show comparison ZenoTravel domain Figure 15.ZenoTravel domain, Sapa resource adjustment runs slightly faster 10 14 problems, returns shorter solutions 5 problems longer solutions 3 problems. solutionmakespan resource adjustment technique also generally better without adjustment technique. conclusion, resource adjustment technique indeed helps Sapa domain.contrast, Rovers domain, technique virtually help. Actually, Roversdomain, number search nodes without resource adjustmentsolved problems. One reason maybe Rovers domain, additional constraintsrecharge action carried certain location. Therefore, evenknow need add recharge action current relaxed plan, may able addplan visit right location.184fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERDriverLog TimeZeno Time (+Resource)Total-DurOrig-MSPP-MS80makespanmakespan100604020012345678800700600500400300200100019 10 11 12234Problems6789 10 11 12Rovers Time (+Resource)Satellite Complex (time+resource)3001000250800makespanmakespan5Problems60040020020015010050001234567819 10 11 12Problems23456789 10 11 12ProblemsFigure 16: Utility greedy post-processing approach problems domains ZenoTravelTime, DriverLog-Time, Satellite-Complex, Rovers-Time IPC3.8.1.3 U TILITYP OST- PROCESSING P.C. P LANSO.C. P LANSFigure 16 shows utility greedy post-processing technique discussed Section 6.test suite contains set problems used first test, first 12 problemsZenoTravel-Time, DriverLog-Time, Satellite-Complex, Rovers-Time domain. graphsFigure 16 show comparisons makespan values (i) total duration actionsplan (makespan serial plan); (ii) original parallel position-constrained (p.c) plans returnedSapa, (iii) order-constrained (o.c) plans returned post-processing. graphs showgreedy post-processing approach helps improving makespan values domains. average,improves makespan values original plans 32.4% ZenoTravel-Time domain,27.7% DriverLog-Time domain, 20.3% Satellite-Complex domain, 8.7%RoversTime domain. Compared serial plans, greedily partialized o.c plans improvedmakespan values 24.7%-38.9%.CPU times greedy partialization small. Specifically, less 0.1 seconds problems number actions ranging 1 68. Thus, using partializationalgorithm post-processing stage essentially preserves significant efficiency advantagesposition constrained planners Sapa, GRT MIPS, search space p.c. plans,improving temporal flexibility plans generated planners.related work (Do & Kambhampati, 2003), present additional results SimpleTime setting domains comparison optimal post-processing techniquediscussed paper.185fiD & K AMBHAMPATI8.2 Sapa 2002 International Planning Competitionentered implementation Sapa, using several techniques discussed paper,recent International Planning Competition. specific techniques used competition versionSapa infinite look-ahead termination cost propagation (Section 3.3), resource adjustment(Section 5.2), greedy post-processing (Section 6). competition, focused solelymetric/temporal domains.sophisticated support multi-objective search provided Sapa fully exploitedcompetition, since action cost part standard PDDL2.1 language usedcompetition.14 competition evaluate quality solution plans terms numberactions terms overall makespan. Given state affairs, assumed unit costactions, ran Sapa = 1, thus making search sensitive action costs. Infinitelookahead used cost propagation. strategy biased Sapa produce low cost plans (interms number actions). Although search sensitive makespan optimization,greedy post processing p.c. plans o.c. plans improved makespan solutions enoughmake Sapa one best planners terms overall quality solutions produced. 15competition results collected distributed IPC3s organizersfound competition website (Fox & Long, 2002). Detailed descriptions domains usedcompetition also available place. temporal planning domains competition came two sets, one containing two domains, Satellite Rovers (adapted NASAdomains), containing three domains: Depots, DriverLogistics Zeno Travel.planning competition, domain multiple versionsdepending whether actionsdurations whether actions use continuous resources. Sapa participated highest levelsPDDL2.1 (in terms complexity temporal metric constraints) five domainslisted above.Figures 17 18 show five planners (Sapa, LPG, MIPS, TP4, TPSYS) submittedresults timed setting three (Sapa, MIPS, TP4) able handle complexsetting Satellite domain. timed setting, action durations depend settinginstruments aboard particular satellite direction needs turn to. complex settingcomplicated fact satellite different capacity limitationstore certain amount image data. Goals involve taking images different planets starslocated different coordinate directions. achieve goals, satellite equipped rightset instruments turn right direction, calibrate take image.timed setting Satellite domain, Figure 17 shows among five planners,Sapa, LPG MIPS able solve 19 20 problems TP4 TPSYS ablesolve 2 3 problems respectively. quality comparison, LPG quality setting ablereturn solutions best quality, Sapa slightly better LPG speed settingmuch better MIPS. LPG speed setting generally fastest, followedMIPS Sapa LPG quality setting. complex setting, Figure 18 showsthat, among three planners, Sapa able solve problems (16), generated planshigher quality MIPS. TP4 produced highest quality solutions, able solve14. competition problems explicit objective functions, theory, could inferredaction costs objective functions (see discussion Section 4.3). yet done this, givenplan metric field PDDL2.1 fully standardized time competition.15. sure, makespan optimal planners TP4 produce much shorter plansbut search inefficientunable solve problems.186fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERSatellite Time7005001.E+06Speed (milisecs)600Quality (Makespan)Satellite Time1.E+07Sapa (19 solved)LPG.Quality (19 solved)LPG.Speed (19 solved)MIPS (19 solved)TP4 (2 solved)TPSYS (3 solved)4003002001.E+051.E+041.E+031.E+021.E+011001.E+000123456781 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 209 10 11 12 13 14 15 16 17 18 19 20ProblemsProblemsFigure 17: Results time setting Satellite domain (from IPC3 results).Satellite ComplexSatellite Complex7001.E+07MIPS (10 solved)500TP4 (3 solved)1.E+06Speed (milisecs)Quality (Makespan)Sapa (16 solved)6004003002001001.E+051.E+041.E+031.E+021.E+0101.E+00123456789 10 11 12 13 14 15 16 17 18 19 201Problems23456789 10 11 12 13 14 15 16 17 18 19 20ProblemsFigure 18: Results complex setting Satellite domain (from IPC3 results).187fiD & K AMBHAMPATIRovers TimeRovers Time3001.E+06Sapa (11 solved)1.E+05MIPS (9 solved)Speed (milisecs)Quality (Makespan)250200150100501.E+041.E+031.E+021.E+0101.E+0012345678910 11 12 13 14 15 161Problems2345678910 11 12 13 14 15 16ProblemsFigure 19: Results time setting Rover domain (from IPC3 results).Depots Time2000160014001.E+06Speed (milisecs)1800Quality (Makespan)Depots Time1.E+07Sapa (5 solved)LPG.Quality (18 solved)LPG.Speed (18 solved)MIPS (11 solved)TP4 (1 solved)120010008006004001.E+051.E+041.E+031.E+021.E+012001.E+000123456789 10 11 12 13 14 15 16 17 18 19 20 211 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21ProblemsProblemsFigure 20: Results time setting Depots domain (from IPC3 results).three smallest problems. solving times Sapa slightly higher MIPS, muchbetter TP4.timed version Rover domain requires set scientific analyses done usingnumber rovers. rover carries different equipment, different energy capacity.Moreover, rover recharge battery certain points sun (whichmay unreachable). Figure 19 shows Sapa MIPS able handle constraintsproblem set. Sapa solved problems (11 vs. 9) MIPS also returned betterequal quality solutions one case. solving time MIPS better Sapa 69 problems returns solutions.188fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERsecond set problems, come temporal constraints, three domains:Depots, DriverLogistics Zeno Travel. Sapa participated highest level,timed settings three domains. Figure 20 shows comparison Sapa threeplanners (LPG, MIPS, TP4) submitted results Depots domain. domain,need move crates (packages) different places. loading actions placecrates truck complicated fact need empty hoist. Thus, Depotdomain looks like combination original logistics blockworlds domains. Drive actiondurations depend distances locations speed trucks. Time loadingcrates depends power hoist use. resource consumptionhighest level. domain, Sapa able solve five problems, compared 11 MIPS18 LPG. TP4 solved one problem. five problems Sapa able solve,solution quality good planners. speed comparison, LPG speed settingclearly faster planners. speculate poor performance Sapa domain related two factors: (i) negative interactions subgoals, largely ignored Sapa,important consideration domain (ii) number ground actions domainparticularly high, making computation planning graph quite costly.Figure 21 shows Sapa performance compares planners competitiontime setting DriveLog domain. variation original Logistics domaintrucks rather airplanes move packages different cities. However, truck requiresdriver, driver must walk board truck move. Like Depot domain,resource consumption. durations walking driving depend specified timeto-walk time-to-drive. domain, Sapa solved 14 problems compared 20 LPG, 16MIPS 1 TP4. quality solutions different planners similar.speed comparison, LPG speed setting fastest, MIPS, Sapa LPG qualitysetting.Finally, Figure 22 shows performance Sapa ZenoTravel domain time setting.domain, passengers travel different cities airplanes. airplanes choosefly different speeds (fast/slow), consume different amounts fuel. Airplanesdifferent fuel capacity need refuel enough trip. domain,Sapa LPG solved 16 problems MIPS solved 20. solution quality Sapa MIPSsimilar general better LPG either speed quality setting. LPG speedsetting MIPS solved problems domain faster Sapa turn faster LPGquality setting.summary, problems involving metric temporal constraints IPC3, Sapa competitive planners LPG MIPS. particular, Sapa solved problemsreturned plans best solution quality highest setting two domains SatelliteRovers, adapted NASA domains. detailed analysis competitionresults presented Long Fox (2003).9. Related Work DiscussionAlthough several recent domain-independent heuristic planners aimed temporaldomains, aimed makespan optimization, ignoring cost aspects.example, TGP (Smith & Weld, 1999) well TP4 (Haslum & Geffner, 2001) focusmakespan optimization ignore cost aspects plan. argued paper,189fiD & K AMBHAMPATIDriverLog TimeSapa (14 solved)LPG.Quality (20 solved)LPG.Speed (20 solved)MIPS (16 solved)TP4 (2 solved)TPSYS (1 solved)600050001.E+06Speed (milisecs)7000Quality (Makespan)DriverLog Time1.E+0780004000300020001.E+051.E+041.E+031.E+021.E+01100001.E+00123456789 10 11 12 13 14 15 16 17 18 19 201234567Problems89 10 11 12 13 14 15 16 17 18 19 20ProblemsFigure 21: Results time setting DriverLog domain (from IPC3 results).ZenoTravel TimeZenoTravel Time16001.E+06Sapa (15 solved)LPG.Quality (16 solved)LPG.Speed (16 solved)MIPS (20 solved)12001.E+05Speed (milisecs)Quality (Makespan)140010008006004001.E+041.E+031.E+021.E+0120001.E+00123456789 10 11 12 13 14 15 16 17 18 19 20Problems123456789 10 11 12 13 14 15 16 17 18 19 20ProblemsFigure 22: Results time setting ZenoTravel domain (from IPC3 results).190fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERultimately, metric temporal planners need deal objective functions basedmakespan cost. One recent research effort recognizes multi-objective nature planningMO-GRT system (Refanidis & Vlahavas, 2001a). one hand, MO-GRT approachgeneral approach sense deals set non-combinable qualitymetrics. MO-GRT approach however treats time similar consumable resources (withinfinite capacity). Temporal constraints planning problems (such effectoccur course action), goal deadlines, concurrency ignored order scaleproblem classical planning assumptions. Metric-FF (Hoffmann, 2002) MIPS(Edelkamp, 2001) two forward state space planners handle resource constraints.generate sequential plans. MIPS handles durative actions putting actionduration post-processing sequential p.c plans. Multi-Pegg (Zimmerman, 2002) anotherrecent planner considers cost-time tradeoffs plan generation. Multi-Pegg basedGraphplan approach, focuses classical planning problems non-uniform cost actions.ASPEN (Chien et al., 2000) another planner recognizes multi-attribute nature planquality. ASPEN advocates iterative repair approach planning, assumes availabilityvariety hand-coded plan repair strategies characterization terms effectsvarious dimensions plan quality. LPG (Gerevini & Serina, 2002) another planneremploys local search techniques action-graph. Unlike ASPEN, LPG considers domainindependent repair strategies involve planning graph-based modifications.Although evaluated cost-sensitive heuristics context Sapa, forward chainingplanner, heuristics also used types planning algorithms.example, TGP made cost-sensitive making propagate cost functions partplanning graph expansion. cost functions used basis variable valueordering heuristics guide backward branch-and-bound search. similar approach classicalplanning shown successful Kambhampati Nigenda (2000).Besides Graphplan-based approaches, framework also used forwardbackward state-space partial order planners guide planning search. possible duefact directional searches (forward/backward) need evaluate distancesinitial state set temporal goals.work also related approaches use planning graphs basis derivingheuristic estimates Graphplan-HSP (Kambhampati & Nigenda, 2000), AltAlt (Nguyen et al.,2001), RePOP (Nguyen & Kambhampati, 2001), FF (Hoffmann & Nebel, 2001). contextefforts, contribution seen providing way track cost function timeplanning graphs. interesting observation cost propagation ways inherentlycomplex makespan propagation. example, set literals enter planning graph(and mutually exclusive), estimate makespan shortest plan achievingchange continue expand planning graph. contrast, estimatecost cheapest plan achieving change planning graph levels off.needed carefully consider effect different criteria stopping expansionplanning graph accuracy cost estimates (Section 3.3).Another interesting point within classical planning, often confusionnotions cost makespan. example, length plan terms number actionseither seen cost measure (if assume actions unit costs), makespanmeasure (if assume actions unit durations). notions get teased apart naturallymetric temporal domains.191fiD & K AMBHAMPATIpaper, concentrated developing heuristics sensitive multiple dimensions plan quality (specifically, makespan cost). orthogonal issue planningmultiple criteria various dimensions plan quality combined optimization. particular approach adopted empirical evaluationnamely, consideringlinear combination cost timeis means reasonable way. approachesinvolve non-linear combinations quality criteria, well tiered objective functions (e.g.rank plans terms makespan, breaking ties using cost). related issue help userdecide weights tiers different criteria. Often users may able articulate preferences various quality dimensions terms precise weights.standard way dilemma involves generating non-dominated Pareto-optimal plans 16 ,presenting user. Unfortunately, often set non-dominated plans exponential (c.f., Papadimitriou & Yannakakis, 2001). users expected pick planpalatable them. Unfortunately, users may actually able judge relativedesirability plans problems complex plans long. Thus, practicalapproach may involve resorting indirect methods preference elicitation techniques(c.f. Chajewska, Getoor, Norman, & Shahar., 1998).10. Conclusionpaper, presented Sapa, domain-independent heuristic forward chaining plannerhandle durative actions, metric resource constraints, deadline goals. Sapa forward-chainingplanner searches space time-stamped states. designed capable handlingmulti-objective nature metric temporal planning. technical contributions include (i)planning-graph based method deriving heuristics sensitive cost makespan(ii) easy way adjusting heuristic estimates take metric resource limitationsaccount (iii) way post-processing solution plans improve execution flexibility.described technical details extracting heuristics presented empirical evaluationcurrent implementation Sapa. implementation Sapa using subset techniquespresented paper one best domain independent planners domains metrictemporal constraints third International Planning Competition, held AIPS-02.extending Sapa several different directions. begin with, want make Sapasupport expressive domains, including exogenous events richer set temporal resource constraints (e.g rover recharge battery sunset). Another direction involvesextending multi-objective search involve quality metrics. considered costplan terms single monetary cost associated action, complex domains,cost may better defined vector comprising different types resource consumption.Further, addition cost makespan, may also interested measures planquality robustness execution flexibility plan. longer term goal supportplan generation sensitive extended set tradeoffs. end, plan extendmethodology derive heuristics sensitive larger variety quality measures. Finally, alsoplan consider issues planner-scheduler interactions context Sapa (c.f., Srivastava,Kambhampati, & Do, 2001).16. plan P said dominated P 0 quality P 0 strictly superior P least one dimension, better equal dimensions (Dasgupta, Chakrabarti, & DeSarkar., 2001; Papadimitriou &Yannakakis, 2001).192fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNERAcknowledgmentsthank Daniel Bryce developing GUI Sapa. specially thank David E. Smithmany insightful detailed comments paper. also thank JAIR reviewershelpful comments. research supported part NSF grant IRI-9801676,NASA grants NAG2-1461 NCC-1225.ReferencesBacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chainingapproach. Proceedings IJCAI-01.Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanismplanning. Proceedings AAAI-97.Chajewska, U., Getoor, L., Norman, J., & Shahar., L. (1998). Utility elicitation classificationproblem. Proceedings UAI-98.Chien, S., Rabideau, G., Knight, R., Sherwood, R., Engelhardt, E., Mutz, D., Estlin, T., Smith, B.,Fisher, F., Barrett, T., Stebbins, T., & Tran, T. (2000). ASPEN - automating space missionoperations using automated planning scheduling. Proceedings SpaceOps-2000.Dasgupta, P., Chakrabarti, P., & DeSarkar., S. (2001). Multiobjective Heuristic Search. ViewegSon/Morgan Kaufmann.Do, M., & Kambhampati, S. (2001). SAPA: domain independent heuristic metric temporal planner. Proceedings ECP-01.Do, M., & Kambhampati, S. (2002). Planning graph-based heuristics cost-sensitive temporalplanning. Proceedings AIPS-02.Do, M., & Kambhampati, S. (2003). Improving temporal flexibility position constrainedmetric temporal planning. Proceedings ICAPS-03.Edelkamp, S. (2001). First solutions PDDL+ planning problems. PlanSIG Workshop.Fox, M., & Long, D. (2001). PDDL2.1: extension PDDL expressing temporal planningdomains. Journal Artificial Intelligence Research, issue.Fox, M., & Long, D. (2002).Third International Planning Competition website:http://www.dur.ac.uk/d.p.long/competition.html.Garrido, A., Onaindia, E., & Barber, F. (2001). Time-optimal planning temporal problems.Proceedings ECP-01.Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphs.Proceedings AIPS-02.Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal planner.Proceedings AIPS-94.Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. ProceedingsECP-01.Hoffmann, J. (2002). Extending FF numerical state variables. Proceedings ECAI-02.193fiD & K AMBHAMPATIHoffmann, J., & Nebel, B. (2001). FF planning system: Fast plan generation heuristicsearch. Journal Artificial Intelligence Research, 14, 253302.Kambhampati, S., & Kedar, S. (1994). unified framework explanation-based generalizationpartially ordered partially instantiated plans. Artificial Intelligence, 67, 2970.Kambhampati, S., & Nigenda, R. (2000). Distance based goal ordering heuristics Graphplan.Proceedings AIPS-2000.Koehler, J., Nebel, B., Hoffmann, J., & Dimopoulos, Y. (1997). Extending planning graphsADL subset. Proceedings ECP-97.Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. ProceedingsIJCAI-95.Long, D., & Fox, M. (1998). Efficient implementation plan graph STAN. JournalArtificial Intelligence Research, 10, 87115.Long, D., & Fox, M. (2003). 3rd International Planning Competition: results analysis.Journal Artificial Intelligence Research, issue.Muscettola, N. (1994). HSTS: Integrating planning scheduling. Mark Fox & Monte Zweben(Eds.), Intelligent Scheduling. Morgan Kaufman.Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Proceedings IJCAI01.Nguyen, X., Kambhampati, S., & Nigenda, R. (2001). Planning graph basis derivingheuristics plan synthesis state space CSP search. Artificial Intelligence, 135, 73123.Papadimitriou, C., & Yannakakis, M. (2001). Multiobjective query optimization. ProceedingsACM Conference Principles Database Systems.Penberthy, S., & Well, D. (1994). Temporal planning continuous change. ProceedingsAAAI-94.Refanidis, I., & Vlahavas, I. (2001a). framework multi-criteria plan evaluation heuristicstate-space planning. Proceedings Workshop Planning Resources, IJCAI-01.Refanidis, I., & Vlahavas, I. (2001b). GRT planner: Backward heuristic construction forwardstate space planning. Journal Artificial Intelligence Research, 15, 115161.Smith, D., & Weld, D. (1999). Temporal planning mutual exclusion reasoning. ProceedingsIJCAI-99.Srivastava, B., Kambhampati, S., & Do, M. (2001). Planning project management way: Efficientplanning effective integration causal resource reasoning RealPlan. ArtificialIntelligence, 131(1-2), 73134.Younes, H., & Simmons, R. (2003). VHPOP: Versatile heuristic partial order planner. JournalArtificial Intelligence Research, issue.Zimmerman, T. (2002). Generating parallel plans satisfying multiple criteria anytime fashion.Proceedings Workshop Planning Scheduling Multiple criteria, AIPS-02.194fiJournal Artificial Intelligence Research 20 (2003) 133-137Submitted 09/03; published 12/03CommentaryImperfect Match: PDDL 2.1 Real ApplicationsMark Boddymark.boddy@adventiumlabs.orgAdventium Labs111 Third Avenue S.Minneapolis, MN 55401 USAAbstractpddl originally conceived constructed lingua franca InternationalPlanning Competition. pddl2.1 embodies set extensions intended supportexpression something closer real planning problems. objectivepartially achieved, due large part deliberate focus moving farclassical planning models solution methods.1. IntroductionFox Long (2003) describe set extensions pddl. claimextensions PDDL2.1 begins bridge gap basic research applicationsoriented planning providing expressive power necessary capture real problems.expressive extensions embodied pddl2.1 represent step right direction,authors claim true limited sense. rest commentary attemptmake qualifying reservations clear.2. Planning Real Applicationsthing real planning problem, thingreal mathematical programming problem. real problems, peoplefound useful construct models apply solution techniques generallyviewed planning models techniques (or math programming techniques, somethingelse entirely). Examples problems planning models may usefuldrawn manufacturing (e.g., batch manufacturing operations), high-levelcontrol complex mechanisms spacecraft. math programming, continuecomparison, disciplines Chemical Engineering, major branchconcerned model solve problems chemical manufacturing using variousflavors mathematical optimization. equivalent discipline planning,difficult characterize planning applications sense controlchemical processes may described application mathematical optimization.lack extensive history applications makes difficult assess relevanceparticular modeling solution techniques, including developed within planningresearch community. International Planning Competition (IPC), held AIPS-98,AIPS-00 AIPS-02, attempting provide data necessary makeassessments. Unfortunately, approach taken gets things backwards, implicitly askingc2003AI Access Foundation. rights reserved.fiMark Boddyextend models everybody particular community comfortable workingwith, closer think needed real application?planning research viewed discipline akin mathematics, kindextension known theoretical constructs makes sense. planning engineeringreal applications point, theoretical work emerge from, leasttested against, generalization abstractions real applications. classical planningapproach grew work theorem-proving dynamic logics, ever sincefruitfully applied domains involving minimal interaction physicalworld, describes planning domains (softbots software agent-basedapplications, example), vast majority them. systems cited FoxLongs Introduction applied real planning problems (SIPE, O-Plan,HSTS, IxTeT), none conventional classical planners constructing totally-orderedsequences operators. use combination methods drawn temporalnetwork planning HTN (task decomposition) planning. work applying planningmethods real applications, example ASPEN (Fukunaga et al., 1997), makemuch use classical planning techniques, either. Perhaps classical planning addressingwrong problem, wrong parts problem, real applications.3. Evaluating Languageargued long line people going back least Hendrix (1973), point-basedtemporal model instantaneous events effect changes world state usedbuild expressive models system dynamics, simply treating eventsstarting ending points intervals propositions hold processes changeworld state. past decade so, Reiter (2001) others extendedsemantics Situation Calculus (McCarthy & Hayes, 1969) encompass overlappingactions, metric quantities, continuous change, exogenous actions, limited knowledge, contingent action effects, actions uncertain effects, among things. presentedFox Long, pddl2.1 used express many things one might wantrepresent real problem. However, difference saying somethingexpressed given language, expression natural, intuitive, easyuse.Take modeling resources example: pddl2.1 expressive enough represent unary resources (trucks, tools), capacity resources (power, weight), consumableresources (fuel). easy way language refer propertiesresource itself. Everything encoded action representation, examplemodeling total-fuel-used example Figure 5. many real domains, resourcesprimary, sense hard part problem figuring resolveresource conflicts, within constraints problem statement.3.1 Form Follows Functionsignificance distinction expressed easilyexpressed manipulated depends roles language intended fill. pddl2.1origins current use language planning competition. longcurrent language permits (not necessarily terribly natural) expression required134fiImperfect Matchfeatures domain planning problem, perhaps problem. Competitorswish construct special-purpose data structures explicit representationsresources free so.pddl2.1 employed beyond IPC, role(s) intended? high-levelmodeling language real applications different requirements competitionstandard, different language used pass planning problems solutionsmachine-readable forms, different yet modular, locally-extensible languageused research tool, permitting researchers exchange example domainsable compare results using different techniques data.13.2 Specific Problems LanguageFinally, specific problems current semantics pddl2.1,addressed pretty much whatever use put to.3.2.1 Holdovers Classical ModelFox Long explicit made choices syntax semantics keepfamiliar feel language classical planning community. makes good senseobjective use language push boundaries done usingextending models methods currently popular research community,little support, may cases actively hinder, introduction features drawnreal applications.several problems resulting stance. First, language explicitlyrestricted ensure finite set ground actions, specifically planning algorithms require this. precludes modeling number different kinds domainfeatures, example explicit creation destruction objects (e.g., intermediate dataproducts, image-processing application), flexible solution continuous parameters(for example, trajectory optimization) within existing evolving plan. Shouldntmodels methods following requirements problems solved, ratherway round?second problem treatment durative actions atomic, rather treatingactivities like heating water lighting matches starting processes may proceedown, agent decides intervene. Consider heat-water actiondefined Figure 12 Section 5.3, whose duration defined precisely requiredraise water 100 C. curious result well-defined plan,duration heat-water must exactly time required, taking accountoverlapping actions may also affect temperature water, actionsmay specified heat-water action added plan.Finally, authors define semantics durative actions preconditionsrequired true beginning extent of, postconditionsasserted end of, intervals non-zero width open right. clean, clear,requires special constraints well-defined semantics, least totallyordered begin end-points. at-end preconditions mess up, furthermorewrong solution authors appear trying support, take1. summary previous attempts construct shared ontology planning, see Tate (1998).135fiMark Boddyimplicit expression complex structure within durative action (this action requires ptrue 2 minutes, start action). See Dave Smiths commentary, alsoissue, discussion complete model complex durative actionsmight look like, one less concerned staying close classical planning model.3.2.2 Problems Definition Continuous ModelSection 5.3, Fox Long introduce notation specifying durative actions continuous effects, claiming using #t notation, possible express varietydifferent nonlinear functions time. least presented section, #t construction appear permit definition, implicit otherwise, nonlinear continuousfunctions. example expressing effect acceleration position makingvelocity vary time, evaluating position #t multiplying #t time-varying velocity also evaluated #t result incorrect answer. required operationintegration, composition.Also section, authors say continuous durative actions dont supportexogenous events. dont understand cant, long endpointsexogenous events also appear plan. Incorporating capability would significantlyincrease range real (or realistic) problems could represented.3.2.3 IssuesTwo matters worth pointing well. First restriction numeric domainsfunctions, primary motivation cited previously-discussed objectivemaking possible construct finite extensional models set possible actions. Nonnumeric functions frequently useful real domains, example refer currentstate object (the current configuration piece communication equipment, say).Finally, authors decision support Undefined values numeric fluentsstatement intended allow actions determine fluent values setting them, priorvalue would unknown. Representing incomplete information, includingunknown propositional continuous states, important capability, oneaddressed directly. might deliberately left later extensionunderstand merits addressing incompletely way.4. Summary Conclusionsextensions embodied pddl2.1 definite step direction languagecomplex planning problems expressed. Fox Long done planningcommunity considerable service, first, designing implementing extensions,second, presenting motivating current paper. focus backwardcompatibility classical planning problematic, given expressed desire addressreal (or least realistic) applications, necessary cleanupslanguage, noted above.extensions pddl2.1 address likely fragmentingfield mutually incompatible sub-fields. logical end process seensurvey scheduling problems compiled Graham et al. (1977), minor136fiImperfect Matchdifferences problem statement lead different complexity classes. Classificationcomplexity class may less relevant field almost every interesting problemleast NP-hard, similar phenomenon arise fact problemsrequire different expressive capabilities others (resource constrained project schedulingproblems, versus manuever planning satellite constellations, example), hardsolve different ways (finding correct ordering plan steps, versus resolvingconflicts unary resource).Ultimately, techniques developed classical planning literature probably proveuseful addressing complex, real-world applications. However, believecases central solutions. classical planning focus individualactions, rather organizing synchronizing operations larger environment,discrete state changes, rather multiple, interacting asynchronous processes,propositional representations, rather constraints continuous quantities.methods brought bear address core complexities realplanning problems, involve complex resources forms synchronizedbehavior, exogenous events, temporal uncertainties agents actionsevents, cases, significant continuous dynamics.final comment, reservations regarding current state pddl2.1taken argument utility toy problems abstract languages, especiallypurposes IPC. However, simplifications abstractions employedpreserve appropriate structure, research results understanding gainedworking translate real problems. believe continuedfocus classical planning models methods problematic.ReferencesFox, M., & Long, D. (2003). Pddl2.1: extension pddl expressing temporal planningdomains. Journal Artificial Intelligence Research, ??Fukunaga, A., Rabideau, G., Chien, S., & Yan, D. (1997). Aspen: framework automated planning scheduling spacecraft control operations. Proc. International Symposium AI, Robotics Automation Space.Graham, R., Lawler, E., Lenstra, J., & Rinnooy Kan, A. (1977). Optimization approximation deterministic sequencing scheduling: survey. Proceedings DiscreteOptimization.Hendrix, G. (1973). Modeling simultaneous actions continuous processes. ArtificialIntelligence, 4, 145180.McCarthy, J., & Hayes, P. J. (1969). philosophical problems standpointartificial intelligence. Machine Intelligence, 4.Reiter, R. (2001). Knowledge Action: Logical Foundations Specifying Implementing Dynamic Systems. MIT Press, Cambridge, Mass.Tate, A. (1998). Roots spar - shared planning activity representation. KnowledgeEngineering Review, 13, 121128.137fiJournal Artificial Intelligence Research 20 (2003) 61-124Submitted 09/02; published 12/03pddl2.1 : Extension pddl Expressing TemporalPlanning DomainsMaria FoxDerek Longmaria.fox@cis.strath.ac.ukderek.long@cis.strath.ac.ukDepartment Computer Information SciencesUniversity Strathclyde, Glasgow, UKAbstractrecent years research planning community moved increasingly towardsapplication planners realistic problems involving time many types resources. example, interest planning demonstrated space research communityinspired work observation scheduling, planetary rover exploration spacecraftcontrol domains. temporal resource-intensive domains including logistics planning, plant control manufacturing also helped focus communitymodelling reasoning issues must confronted make planning technology meetchallenges application.International Planning Competitions acted important motivating forcebehind progress made planning since 1998. third competition(held 2002) set planning community challenge handling time numericresources. necessitated development modelling language capable expressingtemporal numeric properties planning domains. paper describelanguage, pddl2.1, used competition. describe syntaxlanguage, formal semantics validation concurrent plans. observepddl2.1 considerable modelling power exceeding capabilities current planningtechnology presents number important challenges research community.1. Introduction1998 Drew McDermott released Planning Domain Description Language, pddl (McDermott, 2000; McDermott & AIPS-98 Planning Competition Committee, 1998),since become community standard representation exchange planningdomain models. Despite dissatisfaction community featurespddl language enabled considerable progress made planning researchease systems sharing standard comparedenormous increase availability shared planning resources. introduction pddlfacilitated scientific development planning.Since 1998 decisive movement research community towards application planning technology realistic problems. propositional puzzle domainsold longer considered adequate demonstrating utility planning system modern planners must able reason time numeric quantities. Although several members community working applications planningreal domains nature time (Laborie & Ghallab, 1995; Ghallab & Laruelle,1994; Muscettola, 1994; Drabble & Tate, 1994; Wilkins, 1988) always gapc2003AI Access Foundation Morgan Kaufmann Publishers. rights reserved.fiFox & Longmodelling requirements domains expressed pddl.Application-driven planners come equipped modelling conventions blackarts and, consequence, difficult reproduce results make empiricalcomparisons approaches, essential scientific progressmade.pddl language provides foundation expressive standardconstructed, enabling domain models applications-driven community sharedmotivating development planning field towards realistic application.third International Planning Competition, took place 2002, objectiveclosing gap planning research application. organisers thirdcompetition authors therefore took first step defining expressive languagecapable modelling certain class temporal resource-intensive planning domains.done eye future awareness currentcapabilities planners (it possible language used memberscommunity, would competitors). paper describe resultinglanguage, pddl2.1, terms syntax, semantics modelling capabilities.pddl2.1 designed backward compatible fragment pddlcommon usage since 1998. compatibility supports developmentresources help establish scientific foundation field AI planning.Furthermore, McDermotts original pddl provides clean well-understood basisdevelopment embodies number design principles considered importantretain. pddl2.1 extends pddl principled ways achieve additional expressivepower following, far possible, McDermotts maxim physics, advice (McDermott,2000). take maxim mean language focus expressing physicalproperties world, advice planner search associatedsolution spaces. course, model physical systems makes simplifying assumptionsabstracts behaviours level, model claimed purely physicsfree decisions could influence use model. attemptmake strong judgements constitutes advice try implement maximkeeping language simple possible. make following two guaranteesbackward compatibility:1. existing pddl domains (in common usage) valid pddl2.1 domains.important enable existing libraries benchmark problems remain valid.2. Valid pddl plans valid pddl2.1 plans.important contribution made development pddl2.1 meansdomain designers provide alternative objective functions used judgevalue plan. use numbers domain provides platform measuringconsumption critical resources parameters. example metricmodelled energy consumption must minimized. important manypractical applications planning plan quality might dependent numberinteracting domain-dependent factors.organisation paper follows. Section 2 introduce non-specialistreaders pddl domain description language used planning research community.62fipddl2.1: Expressing Temporal Planning Domainsbackground given order provide foundations numeric durativeextensions made developing pddl2.1. paper focusses specific extensionsintroduced: numeric expressions durative actions. Section 3 start explainingsyntax numeric expressions use action descriptions. explain,Section 4, metrics provided part problem descriptionquality plan involving numeric change evaluated terms appropriateproblem domain. present syntax metrics expressed give examples.Section 5 paper introduces notion durative action way modellingtemporal properties planning domain. discretised continuous durative actionsconsidered. syntax described examples modelling power limitationspresented cases. given examples syntactic representation durativeactions present formal semantics discretised continuous actionsplans. Sections 6, 7, 8 9 provide details. semantics gives us way tacklingproblem confirming plan validity something becomes important issueface concurrent activity. Section 10 describe process plansvalidated competition discuss complexity validation questionpddl2.1. Finally, Section 11 describes related work temporal reasoningcommunity, order put contributions made pddl2.1 wider context. fullbnf description pddl2.1 found appendix.pddl2.1 developed use third International Planning Competitioncompeting planners demonstrated many discretized temporal metric modelsefficiently handled domain-independent planners using handtailored control rules. ease reference competition identified featurespddl2.1 series levels increasing expressive power. Thus, strips fragmentpddl2.1 referred level 1, numeric extensions comprised level 2, additiondiscretised durative actions resulted level 3, continuous durative actions resultedlevel 4 final level, level 5, comprised extensions pddl2.1 additionalcomponents support modelling spontaneous events physical processes. Level 5discussed paper details found earlier work Fox Long (2002).competition focussed use levels 1, 2 3 use levels 4 5planning technology stage sufficiently advanced handle additionalcomplexities. Despite fact level 4 used competition devotediscussion paper. feel level 4 presents important immediatechallenges planning community affect extent planningapplied real problems.purpose paper provide overview new features introducedpddl2.1, discuss rationale language choices explain issues arisen trying extend pddl. Although provided bnfpddl2.1 appendix, paper intended either language manual tutorial use language. examples use languagerelevant materials, readers consult archived resources currently heldhttp://www.dur.ac.uk/d.p.long/competition.html.63fiFox & Long2. pddl Backgroundpddl action-centred language, inspired well-known strips formulationsplanning problems. core simple standardisation syntax expressingfamiliar semantics actions, using pre- post-conditions describe applicabilityeffects actions. syntax inspired Lisp, much structure domaindescription Lisp-like list parenthesised expressions. early design decisionlanguage separate descriptions parameterised actions characterisedomain behaviours description specific objects, initial conditions goalscharacterise problem instance. Thus, planning problem created pairingdomain description problem description. domain descriptionpaired many different problem descriptions yield different planning problemsdomain. parameterisation actions depends use variablesstand terms problem instance instantiated objects specificproblem instance action grounded application. pre- post-conditionsactions expressed logical propositions constructed predicates argumentterms (objects problem instance) logical connectives.Although core pddl strips formalism, language extends beyond that.extended expressive power includes ability express type structure objectsdomain, typing parameters appear actions constraining typesarguments predicates, actions negative preconditions conditional effectsuse quantification expressing pre- post-conditions. extensionsessentially proposed adl (Pednault, 1989).Although original definition pddl syntax accompanied formal semantics, language really proposal standard syntax commonly acceptedsemantics little scope disagreement meaning languageconstructs. Two parts original language proposal claim failsattempt offer standard syntax describing hierarchical domain descriptions, suitablehtn planners subset language concerned expressing numeric-valuedfluents. former ambitious project construct syntax entire structure domains using hierarchical action decompositions could expressed. contraststrips-based planning, differences planners using hierarchical decompositionappear deeper, domain descriptions often containing structures go beyonddescription domain behaviours (for example, shop (Nau, Cao, Lotem, & MunozAvila, 1999) often uses mechanisms represent goal agendas solution-orientedstructures domain encoding). diversity undermined efforts standardisationhierarchical domain descriptions part language never successfullyexplored.syntax proposed expressing numeric-valued fluents tested firstuse language (in 1998 competition) and, indeed, underwent revision earlydevelopment language. second competition 2000 also avoided use numericvalued fluents, general agreement syntax semantics numericexpressivity language remained unnecessary. McDermotts original pddl providessupport numbers allowing numeric quantities assigned updated. syntaxnumeric-valued fluents changed pddl manuals 1.1 1.2 (McDermott &64fipddl2.1: Expressing Temporal Planning Domains(define (domain jug-pouring)(:requirements :typing :fluents)(:types jug)(:functors(amount ?j -jug)(capacity ?j -jug)- (fluent number))(:action empty:parameters (?jug1 ?jug2 - jug):precondition (fluent-test(>= (- (capacity ?jug2) (amount ?jug2))(amount ?jug1))):effect (and (change (amount ?jug1) 0)(change (amount ?jug2)(+ (amount ?jug1) (amount ?jug2))))))Figure 1: Pouring water jugs described AI Magazine article (McDermott,2000).AIPS-98 Planning Competition Committee, 1998) later AI Magazine articlepddl (McDermott, 2000). McDermott presented version numeric fluents usedpddl article AI Magazine (2000) could taken definitive statementsyntax. example using numeric fluents, presented McDermott (2000), shownFigure 1. action models action well-known jugs-and-water problem,allowing water one jug emptied second jug provided spacesecond jug large enough hold water first. effect discrete updatevalues current contents jugs assignment (denotedchange token).Even without numeric extensions, pddl expressive language, capable capturing wide variety interesting challenging behaviours. Figure 2 illustratespddl used capture domain vehicle move locations,consuming fuel so.seen example pddl includes syntactic representation levelexpressivity required particular domain descriptions use requirementsflags. gives opportunity planning system gracefully reject attemptsplan domains make use advanced features languageplanner handle. Syntax checking tools used confirm requirementsflags correctly set domain types features languagecorrectly employed. example problem description accompany vehicledomain shown Figure 3. example illustrates description initialstate requires exhaustive listing (atomic) propositions hold. Symmetrictransitive relations must modelled exhaustive explicit listing propositionshold. use domain axioms simplify description domains userelationships considered, remains untested part pddl therefore65fiFox & Long(define (domain vehicle)(:requirements :strips :typing)(:types vehicle location fuel-level)(:predicates (at ?v - vehicle ?p - location)(fuel ?v - vehicle ?f - fuel-level)(accessible ?v - vehicle ?p1 ?p2 - location)(next ?f1 ?f2 - fuel-level))(:action drive:parameters (?v - vehicle ?from ?to - location?fbefore ?fafter - fuel-level):precondition (and (at ?v ?from)(accessible ?v ?from ?to)(fuel ?v ?fbefore)(next ?fbefore ?fafter)):effect (and (not (at ?v ?from))(at ?v ?to)(not (fuel ?v ?fbefore))(fuel ?v ?fafter))))Figure 2: domain description pddl.unstable part syntax. pddl domains case-sensitive, somewhatanachronistic light standard practice modern programming languages.following sections review extensions made pddl developmentpddl2.1, version language used third International Planning Competition.3. Numeric Expressions, Conditions EffectsOne first decisions made development pddl2.1 propose definitivesyntax expression numeric fluents. based syntax version describedAI Magazine article (McDermott, 2000), minor revisions (discussed below).Numeric expressions constructed, using arithmetic operators, primitive numericexpressions, values associated tuples domain objects domain functions. Using proposed syntax expressing numeric assignments updatesexpress jug-pouring operator originally described pddl1.2 manual AIMagazine article (see Figure 1), pddl2.1, presented Figure 4. examplefunctions capacity amount associate jug objects numeric values corresponding capacity current contents respectively. seen example,used prefix syntax arithmetic operators, including comparison predicates,order simplify parsing. Conditions numeric expressions always comparisonspairs numeric expressions. Effects make use selection assignmentoperations order update values primitive numeric expressions. includedirect assignment relative assignments (such increase decrease). Numbersdistinguished possible roles, values represent, example, quantitiesresources, accumulating utility, indices counters.66fipddl2.1: Expressing Temporal Planning Domains(define (problem vehicle-example)(:domain vehicle)(:objectstruck car - vehiclefull half empty - fuel-levelParis Berlin Rome Madrid - location)(:init(at truck Rome)(at car Paris)(fuel truck half)(fuel car full)(next full half)(next half empty)(accessible car Paris Berlin)(accessible car Berlin Rome)(accessible car Rome Madrid)(acessible truck Rome Paris)(accessible truck Rome Berlin)(accessible truck Berlin Paris))(:goal (and (at truck Paris)(at car Rome))))Figure 3: problem instance associated vehicle domain.(define (domain jug-pouring)(:requirements :typing :fluents)(:types jug)(:functions(amount ?j - jug)(capacity ?j - jug))(:action pour:parameters (?jug1 ?jug2 - jug):precondition (>= (- (capacity ?jug2) (amount ?jug2)) (amount ?jug1)):effect (and (assign (amount ?jug1) 0)(increase (amount ?jug2) (amount ?jug1))))Figure 4: Pouring water jugs, pddl2.1 style.67fiFox & Longdifferences pddl2.1 syntax AI Magazine syntaxdeclaration functions use assign instead change. decidedallow numeric-valued functions, making declaration function return typessuperfluous. therefore simplified language requiring declarationfunction names argument types, required predicates. felt changeambiguous used alongside operations increase decrease assignwould clearer.Numeric expressions allowed appear terms language (that is,arguments predicates values action parameters). two justificationsdecision philosophical one pragmatic one. Philosophically takeview finite number objects world. Numbers existunique independent objects world, values attributes objects.models object-oriented sense actions seen methodsapply objects given parameters. object-oriented view directlyinform syntax representations, reflected way numbersmanipulated relationships objects identified namedinitial state. Pragmatically, many current planning approaches rely ableinstantiate action schemas prior planning, feasible finitenumber action instances. branching planners search space, choice pointscorresponding action selection, therefore always finite ranges. use numericfluent variables conflicts could occur arguments predicatewould define finite ranges.decision allow numbers used arguments actions rulesactions might seem intuitively reasonable. example, action fly certainaltitude might expected take altitude number-valued argument.possible pddl2.1 range numbers used finite. practicalpoint view think unlikely arduous constraint benefitskeeping logical state space finite compensates modelling awkwardnessresults.Functions pddl2.1 restricted type Objectn R, (finite) collection objects planning instance, Object finite function arity n. Later extensionspddl might introduce functions type Objectn Object, allowing Object extended application functions objects. advantage wouldallow objects referred relationships known objects. (For example,(onTopOf ?x) could used refer object currently top object instantiating ?x). Unfortunately, functions present various semantic problems. particular,interpretation quantified preconditions becomes significantly harder, since collection objects longer necessarily finite, extensional interpretations possible.difficulty identity problem objects manipulated actions,functional expressions refer also affected, implicitly. example,objects moved, (onTopOf A) change without action manipulating explicitly.Managing way functional terms map specific objects domain (whichmight might specific names own) appears introduce considerablecomplication semantics. believe important avoid extending pddlelements still poorly understood.68fipddl2.1: Expressing Temporal Planning Domains4. Plan Metricsadoption stable numeric extension pddl core allowed us introduceextension pddl2.1, namely new (optional) field within specificationproblems: plan metric. Plan metrics specify, benefit planner, basisplan evaluated particular problem. initial goalstates might yield entirely different optimal plans given different plan metrics. course,planner might choose use metric guide development solutionevaluate solution post hoc. approach might lead sub-optimal, possiblyeven poor quality plans, pragmatic approach handling metricsquite widely used competition. issue discussed companionpaper analysing results 3rd IPC issue (Long & Fox, 2003b).value total-time used refer temporal span entire plan.values must built primitive numeric expressions defined within domainmanipulated actions domain. consequence, plan metricsexpress non-temporal metrics pddl2.1 domains using numeric expressions. arithmetic expression used specification metric requirementexpression linear. domain designers responsibility ensure planmetrics well-defined (for example, involve divisions zero). example useplan metric shown Figure 5.implications introduced extension far-reaching alreadyhelped demonstrate important new challenges planning systems particularlyfully-automated systems. enriched descriptive power evaluation planscrucial extension practical use planners, since almost never case realplans evaluated solely number actions contain.Metrics described problem description, allowing modeller easily exploreeffect different metrics construction solutions problemsdomain. order define metric terms specific quantity necessaryinstrument quantity domain description. example, metric definedterms overall fuel use fuel-use quantity initialised zero initial stateupdated every time fuel consumed. domain shown Figure 5 possibleminimise linear combination fuel used vehicles as:(:metric minimize (+ (* 2 (fuel-used car)) (fuel-used truck)))However possible minimise distance covered since distance instrumented.would straightforward instrument desired, simply adding appropriate initialvalue incrementing effects domain description. Since actions cause quantitieschange, instrumenting value requires modification domain description itself,problem file.use plan metrics subtle dramatic impact planssought. Perhaps simplest case actions increase metric mustminimised, decrease one must maximised. case example shownFigure 5, use drive action worsen value plan metric(whether use metric shown figure maximising metric describedlast paragraph). situation might appear relatively straightforward: planner69fiFox & Long(define (domain metricVehicle)(:requirements :strips :typing :fluents)(:types vehicle location)(:predicates (at ?v - vehicle ?p - location)(accessible ?v - vehicle ?p1 ?p2 - location))(:functions (fuel-level ?v - vehicle)(fuel-used ?v - vehicle)(fuel-required ?p1 ?p2 - location)(total-fuel-used))(:action drive:parameters (?v - vehicle ?from ?to - location):precondition (and (at ?v ?from)(accessible ?v ?from ?to)(>= (fuel-level ?v) (fuel-required ?from ?to))):effect (and (not (at ?v ?from))(at ?v ?to)(decrease (fuel-level ?v) (fuel-required ?from ?to))(increase (total-fuel-used) (fuel-required ?from ?to))(increase (fuel-used ?v) (fuel-required ?from ?to)))))(define (problem metricVehicle-example)(:domain metricVehicle)(:objectstruck car - vehicleParis Berlin Rome Madrid - location)(:init(at truck Rome)(at car Paris)(= (fuel-level truck) 100)(= (fuel-level car) 100)(accessible car Paris Berlin)(accessible car Berlin Rome)(accessible car Rome Madrid)(accessible truck Rome Paris)(accessible truck Rome Berlin)(accessible truck Berlin Paris)(= (fuel-required Paris Berlin) 40)(= (fuel-required Berlin Rome) 30)(= (fuel-required Rome Madrid) 50)(= (fuel-required Rome Paris) 35)(= (fuel-required Rome Berlin) 40)(= (fuel-required Berlin Paris) 40)(= (total-fuel-used) 0)(= (fuel-used car) 0)(= (fuel-used truck) 0))(:goal (and (at truck Paris)(at car Rome)))(:metric minimize (total-fuel-used)))Figure 5: example domain problem instance describing plan metric.70fipddl2.1: Expressing Temporal Planning Domainsmust attempt use actions solve problem possible. fact, even caselittle complex appears rival plans one usesactions lower overall cost other. complex case arisesactions improve quality metric others degrade it. example, usemaximising metric also add refuel action domain driving degrade planquality (by reducing fuel level vehicle) refuelling improve plan quality (byincreasing fuel level vehicle). case, planner attempt use actionsimprove plan quality without actions actually contributing achieving goals.example, refuelling might necessary get vehicles destinations,adding refuelling actions would improve quality solution. process couldinvolve trading finite irreplaceable resources increased value plan.would case if, example, refuelling vehicle took fuel finite reservoir.Alternatively domain could allow plans arbitrarily high value constructedusing actions. would occur metric vehicles domain usingmaximising vehicles fuel level metric refuelling constrained, since domainimpose limit fuel capacities vehicles.case plans constrained finite availability resources, importantinteresting form planning problem, case plans arbitrarilyhigh utility constructed, obviously ill-defined problem, since optimal planexist. non-trivial determine whether planning problem providedmetric ill-defined. fact, Helmert shows (Helmert, 2002), introduction numericexpressions, even constrained way adopted pddl2.1, makesplanning problem undecidable. problem finding collection actionsconsume irreplaceable resources overall beneficial impact plan metricleast hard planning problem. Therefore clear determining whetherplanning problem even well-defined undecidable. make worthlessconsider planning metrics, course, demonstrates modelling problem,well planning problem, becomes even complex metrics introduced.One strategy available planners working problems subject plan metricsignore metric simply produce plan satisfy logical goals problemspecifies. case, plan quality simply value, according metric,plan happens constructed. strategy unsophisticated obviouslybetter planner construct plan guided specified metric. best usemetric expedite search process fully-automated planner still research issue.5. Durative Actionsrecent work temporal planning (Smith & Weld, 1999; Bacchus & Kabanza, 2000;& Kambhampati, 2001) based various forms durative action. orderfacilitate participation competition therefore developed two forms durativeaction allowing specification restricted forms timed conditions effectsdescription. Although constrained certain ways, durative actions are,nevertheless, expressive many proposals previously explored, particularlyway allow concurrency exploited. two forms discretiseddurative actions continuous durative actions.71fiFox & Long(:durative-action load-truck:parameters (?t - truck)(?l - location)(?o - cargo)(?c - crane):duration (= ?duration 5):condition (and (at start (at ?t ?l))(at start (at ?o ?l))(at start (empty ?c)(over (at ?t ?l))(at end (holding ?c ?o)):effect (and (at end (in ?o ?t))(at start (holding ?c ?o))(at start (not (at ?o ?l)))(at end (not (holding ?c ?o))))Figure 6: durative action loading truck. assume capacity constraints.forms rely basic durative action structure consisting logical changescaused application action. always consider logical change instantaneous,therefore continuous aspects continuous durative action refer numericvalues change interval action. Figure 6 depicts basic durative action,load-truck, numeric change.modelling temporal relationships discretised durative action done meanstemporally annotated conditions effects. conditions effects durative actionsmust temporally annotated. annotation condition makes explicit whetherassociated proposition must hold start interval (the point actionapplied), end interval (the point final effects actionasserted) interval start end (invariant durationaction). annotation effect makes explicit whether effect immediate (ithappens start interval) delayed (it happens end interval).time points accessible, discrete activity takes place identified startend points actions plan.Invariant conditions durative action required hold intervalopen ends (starting ending end points action). expressedusing construct seen Figures 6 8. one wants specify fact pholds closed interval duration durative action, three conditionsrequired: (at start p), (over p) (at end p).considered adopting convention constraints applystart end points well open interval inside durative action, decidedwould impossible express conditions actuallyrequired hold open interval. Examples actions conditionsinvariant open interval include action loading truck. truck mustremain loading location throughout loading interval, start moveaway simultaneously loading completed. reason start72fipddl2.1: Expressing Temporal Planning Domainsdrive action non-mutex end load reasonable interpretationplan driving starts instant loading completed. Actions affectinvariant condition (such location truck) executed simultaneouslyend point durative action invariant constrained hold trueend point itself. highlights important difference (over all) (overend). condition required end precondition well invariantcondition meaning action affects invariant must start endaction requiring invariant. example, make (at truck location) endprecondition load operator well invariant, consequence truckcannot drive away instant load completed.Note that, definition load-truck action Figure 6, chosen makecondition (holding ?c ?o) start effect end precondition invariantcondition. means crane could temporarily cease hold cargotime interval, long holding cargo time deposit endloading interval. makes action quite flexible, enabling exploitationconcurrent uses crane applicable.load-truck example shows logical change wrapped durativeactions encapsulate much detail involved achieving effect sequenceconnected activities. Naturally would useful able combine actionsconcurrently within plan. next section consider extent concurrencyallowed ways concurrent plans interpreted.5.1 Interpretation Concurrent planstime introduced modelling domain possible concurrent activityoccur plan. Prior introduction time pddl plans interpretedsequential even Graphplan-concurrent plans sequenced validatedconcurrency never issue. pddl2.1 plan validity depend exploitingconcurrency correctly. Actions overlap co-occur, giving rise questionsinterpretation synchronous behaviour. discuss problems arising precisesynchronization Section 10. explain constraints actions occurconcurrently within plan involving durative actions numeric conditions effects.key difference, durative actions pddl2.1 used planners priorcompetition, distinguish conditions effects startend points durative interval invariant conditions might specifiedhold interval. is, actions pre- postconditions localtwo end-points action, planner choose exploit durative actioneffects start end. Conditions invariant distinguishedpre-conditions, enabling exploitation higher degree concurrencypossible preconditions distinguished invariants, tgp (Smith & Weld,1999), tpsys (Garrido, Onainda, & Barber, 2001) tp4 (Haslum & Geffner, 2001).discuss consequences design decisions, together several examplesdurative actions, following sections.important observe view time point-based rather interval-based.is, see period activity terms intervals state separated time points73fiFox & Longstate-changing activities occur. logical state change occurs instantaneously,start end point durative action. Propositions true half-open intervalsclosed left open right. Activities might change logical statemight update values numeric variables. discretised view timeallow finite number activities (which call happenings) two timepoints, although time considered continuous actions scheduled begintime point.plan considered valid, logical condition asserted negatedinstant. impose constraint logical conditionrequired hold asserted instant. Although might seem overlystrong claim plan cannot guaranteed valid instantproposition required exactly instant asserted. require that,action precondition P start time t, must half open interval immediatelypreceding P holds. mathematically inconsistent P assertedinstant required. conservative view validitysimultaneous update access state proposition. example, twoinstantaneous actions, B, precondition P effects (not P ) Q,B precondition P Q effect R, consider attempt applyB simultaneously state P holds ill-defined. reason that, althoughswitches state one P holds one Q holds one mightsuppose precondition B secure, abstraction modelvalues P Q changing and, argue, reliance values pointchange unstable. adopt rule call moving targets, meantwo actions simultaneously make use value one two accessing valueupdate value moving target action access. rule createsbehaviour propositions planning state much like behaviourvariables shared memory protected mutex lock (such POSIX threads),difference read write access variable.Validity also requires numeric value accessed updated simultaneouslystart end point durative action. case discretised durative actions,numeric change modelled terms step functions numeric values accessed,updated, interval another durative action acting value (we provideexamples following section) provided updates consistent invariantproperties dependent value. case continuous durative actions, valuessimultaneously accessed updated continuous process change occurringinterval action. discretised continuous cases allow multiplesimultaneous updates provided update operations commutative.order implement mutual exclusion relation require non-zero-separationmutually exclusive action end points. view, end points nonconflicting treated though possible execute simultaneouslyeven though precise synchronicity cannot achieved world. However, endpoints mutually exclusive planner buffer co-occurrence pointsexplicitly separating them. way ensure concurrency planleast plausible world.74fipddl2.1: Expressing Temporal Planning Domains(:durative-action heat-water:parameters (?p - pan):duration (= ?duration (/ (- 100 (temperature ?p)) (heat-rate))):condition (and (at start (full ?p))(at start (onHeatSource ?p))(at start (byPan))(over (full ?p))(over (onHeatSource ?p))(over (heating ?p))(at end (byPan))):effect (and(at start (heating ?p))(at end (not (heating ?p)))(at end (assign (temperature ?p) 100))))Figure 7: simple durative action boiling pan water.Planners exploit considerable concurrency domain ensuring conflicting start end points actions separated non-zero amount. detailedspecification mutual exclusion relation pddl2.1 given Section 8.discuss implications non-zero separation Section 10.5.2 Numeric Change within Discretised Durative Actionssection explains continuous change sometimes modelled pddl2.1 usingdurative actions discrete effects. achieved using step functions describeinstantaneous changes beginnings ends durations actions. Appendixdetails language constructs involved.example durative action, illustrating use numeric update operations,shown Figure 7. example showing water heating action, conditions (full ?p)(onHeatSource ?p) must hold start interval well interval.model enter conditions start constraints.action achieves start effect water heating, condition maintainedinvariant whole interval action. example operatorachieves invariant condition, draws attention fact conditionshold interval open left (as well right).noted actions Figures 7 8 use fixed duration specifications.case water-boiling example means impossible adjust lengthtime pan heated impact contextaction used. particular, assign construct used update numericvalue, possible concurrent activity affect value else modelflawed. water heating example uses assign construct concurrentactivity affect temperature water. responsibility modellerensure temperature neither accessed updated intervalaction executing.75fiFox & Long(:durative-action navigate:parameters (?x - rover ?y - waypoint ?z - waypoint):duration (= ?duration (travel-time ?y ?z)):condition (and (at start (available ?x))(at start (at ?x ?y))(at start (>= (energy ?x)(* (travel-time ?y ?z) (use-rate ?x))))(over (visible ?y ?z))(over (can_traverse ?x ?y ?z))):effect (and (at start (decrease (energy ?x)(* (travel-time ?y ?z) (use-rate ?x))))(at start (not (at ?x ?y)))(at end (at ?x ?z))))(:durative-action recharge:parameters (?x - rover ?w - waypoint):duration (= ?duration (recharge-period ?x)):condition (and (at start (at ?x ?w))(at start (in-sun ?w))(at start (<= (energy ?x) (capacity ?x)))(over (at ?x ?w))):effect (at end (increase (energy ?x) (* ?duration (recharge-rate ?x)))))Figure 8: Discretised durative actions rover move locations recharge.decided leave modeller ensure correct behaviour assign construct want forbid modelling truly discontinuous updates.example, durative action models deposit cheque bank account mightduration three days, discontinuous update account balanceend interval would inappropriate prevent actions accessingbalance three day period. general, modelling continuous change discreteeffects open various pitfalls. price paid conveniencespecify details continuous processes.use discretised durative actions combination numeric (step-function)updates requires care modelling. particular, relies notion conservativeresource updating. updating resource levels conservative consumptionresource modelled happens start durative action, even thoughactually happens continuously duration action, production resourcemodelled happens end durative action even though, again, mightactually produced continuously interval.example discretised durative action, Figure 8 shows actionrover navigating two points modelled. local precondition startperiod rover start location. Local effects include roverconsumes appropriate amount energy destination. firstconservative therefore immediate, second logical effect occursend point. organisation ensures parallel activities consume energyalready committed navigation activity. Similarly, recharge action76fipddl2.1: Expressing Temporal Planning DomainsProjected energy productionActual energy profileInitial EnergyEnergy changingproductionconsumptionStep function modelenergy consumptiondig actionFinal stage digging actionFinal EnergyStep function modelenergy producedrecharge actionZero EnergyRecharge ActionDig ActionFigure 9: Using discrete actions model production consumption resource.reality, recharge activity produces energy continuously concurrent digactivity continuously consumes it. conservative model using step functionsrequires energy consumed digging must available startaction, despite yet updated model show additionalenergy accumulated part recharge action far executed.final energy level consistent used continuous model.makes new charge available conclusion action, charge gainedcannot exploited recharging complete. use conservative updatesensures model support invalid concurrency.Figure 9 illustrates recharging digging action (that consumes energy) wouldinteract conservative energy consumption model. model would allow concurrent actions consume energy provided consume energy leftconservative assumption dig action consumed demandsstart recharge action produced nothing end. Note exampleassumes energy constraints capacity constraint.use conservative updates subtle. capacity constraintenergy level rover one would need consider two separate resources: energyspace available storage energy. dig action would consume energystart produce space end, recharge action would consume spacestart produce charge end. Using combination would possibleensure plans consume either resource available.Durative actions conditional effects. antecedents consequentsconditional effect temporally annotated possible specify conditionchecked start end, effect asserted either points.77fiFox & Long(:durativeaction burnMatch:parameters (?m match ?l location):duration (and (< ?duration 5) (> ?duration 0)):condition (and (at start (have ?m))(at start (at ?l))):effect (and (when (at start (dark ?l))(and (at start (not (dark ?l)))(at start (light ?l))))(at start (not (have ?m)))(at start (burning ?m))(at end (not (burning ?m)))(when (at start (dark ?l))(and (at end (not (light ?l)))(at end (dark ?l))))))Actions(:action pickUp:parameters (?l location ?o object):precondition (and (at ?l)(onFloor ?o ?l)(light ?l)):effect (and (not (onFloor ?o ?l))(have ?o)))Initial state: (onFloor coin) (have aMatch) (at basement) (dark basement)Goal: (have coin)ProblemPlan: 0.1 (burnMatch aMatch basement) [0.2]0.2 (pickUp basement coin)pickUp coinStart burnMatchdark basementEnd burnMatchlight basement0.10.2dark basement0.3PlanFigure 10: example problem durative action useful start effects.burning match produces light necessary pick coin.semantics makes clear well-formed durative action conditional effects cannotrequire condition checked effect asserted. Conditional effectsarise pddl2.1 variants. discuss occurrence discretized durative actionsinterpreted Section 8.1.pddl2.1 allows specification duration inequalities enabling actions describedexternal factors involved determining temporal extent.match-burning example shown Figure 10 seen effect start pointone interest, planner would exploit action start ratherend effect. duration inequality specifies match burn longerspecified upper bound. model shows match put early plannerconsiders appropriate. discuss use duration inequalities Section 5.3.78fipddl2.1: Expressing Temporal Planning Domains5.3 Durative Actions Continuous Effectsobjective discrete durative actions abstract continuous change concentrate end points period change takes place. syntax allowsprecise specification discrete changes end points durative actions. However,plan needs manage continuously changing values, well discretely changingones, durative action language semantics need powerful. General durative actions continuous well discrete effects. increase, decrease,numeric variable according specified rate change time variable.determining achieve goal planner must able access valuescontinuous quantities arbitrary points time-line plan. use #t refercontinuously changing time start durative action execution.example, express fact fuel level plane, ?p, decreases continuously,function consumption rate ?p, write:(decrease (fuel-level ?p) (* #t (consumption-rate ?p)))distinctly different from:(at end (decrease(fuel-level ?p)(* (flight-time ?a ?b) (consumption-rate ?p))))latter single update happening end point flight action, whilstformer allows correct calculation fuel level plane pointinterval. former continuous effect, whilst latter discrete one. Continuouseffects temporally annotated evaluated timeinterval action. #t local durative action, durative actionaccess purely local clock. Another way interpret expression representingcontinuous change differential equation:(fuel-level ?p) = (consumption-rate ?p)dtchose use #t symbol instead differential equation possible twoconcurrent actions simultaneously modifying quantity. case, usedifferential equations would actually form inconsistent pair simultaneous equations,rather intended effect combined contribution changing valuequantity. Although expressions describing continuous change take formproduct #t quantity, possible express complex change usinginterdependent concurrent effects. example, acceleration arises simply increasingdistance using quantity describing velocity, time increasing velocityusing quantity describing acceleration. dependencies changing termsinclude mutual dependencies terms differential equations ariselead continuous change dictated exponential, logarithmic exponential functions.plan containing continuous durative actions assign to, consult, continuouslymodify numeric variables concurrently (see Example 1).Figures 12 14 discrete continuous actions heating pan waterpresented (this simple model ignores heat loss). discrete action presented Figure 12modifies version presented Figure 7 use duration inequality constraint.79fiFox & LongExample 1 flying refuelling example shown Figure 11 seeninvariant condition, fuel-level greater (or equal to) zeroflight, maintained whilst fuel continuously decreasing.could expressed discrete durative actions abstracting continuousdecrease making final value available end point flight. However,refuel operation happens flight time (in mid-air) fuel levelflight need calculated taking account continuousrate consumption refuel operation. discrete action could calculatefuel-level correctly would access distancesource destination flight, together rate consumption,determine final fuel level. order calculate fuel level correctlynecessary determine time refuel takes place, useremaining flight-time calculate fuel consumed. Discrete durative actionsgive access time points start end points.Discrete durative actions used express desired combinations flyingrefuelling providing additional durative actions, fly-and-refuel,encapsulate interactions described end calculating fuel levelcorrectly. However, approach requires domain designerplanner domain designer must anticipate every useful combinationbehaviours ensure appropriate encapsulations provided.contrast discrete form, continuous action, fuel consumption effect given terms #t, powerful enough express factmid-flight refuelling plane affects final fuel level way consistentmaintaining invariant fly action.(:durative-action fly:parameters (?p - airplane ?a ?b - airport):duration (= ?duration (flight-time ?a ?b)):condition (and (at start (at ?p ?a))(over (inflight ?p))(over (>= (fuel-level ?p) 0))):effect (and (at start (not (at ?p ?a)))(at start (inflight ?p))(at end (not (inflight ?p)))(at end (at ?p ?b))(decrease (fuel-level ?p)(* #t (fuel-consumption-rate ?p)))))(:action midair-refuel:parameters (?p):precondition (inflight ?p):effect (assign (fuel-level ?p) (fuel-capacity ?p)))Figure 11: continuous durative action flying.80fipddl2.1: Expressing Temporal Planning Domains(:durative-action heat-water:parameters (?p - pan):duration (at end (<= ?duration (/ (- 100 (temperature ?p))(heat-rate)))):condition (and (at start (full ?p))(at start (onHeatSource ?p))(at start (byPan))(over (full ?p))(over (onHeatSource ?p))(over (heating ?p))(at end (byPan))):effect (and(at start (heating ?p))(at end (not (heating ?p)))(at end (increase (temperature ?p)(* ?duration (heat-rate))))))Figure 12: discrete durative action heating pan water, using variable duration.Duration inequalities add significant expressive power duration equalities. Durationconstraints express inequalities associated additional requirements flagextended expressiveness fixed-duration discrete durative actions.actions, logical post-condition start period panheating. conditions pan heating, full heat source invariant,although presence agent (by pan) local precondition twoend-points invariant. first action duration modelled expressingfollowing duration inequality constraint:(at end (<= ?duration (/ (- 100 (temperature ?p)) (heat-rate))))effect end-point discrete durative action temperaturepan increased (* ?duration (heat-rate)) (where heat-rate domainconstant). continuous action Figure 14 duration constraint unnecessarysince invariant(over (<= (temperature ?p) 100))added ensure pan never exceeds boiling.durative action Figure 12 models heating pan face possible concurrent activities affecting temperature. duration inequality allows planneradapt duration take account temperature-affecting activity waypossible duration specified using equality constraint. durationconstraint ensures temperature never exceeds boiling checking, precondition updating activity, computed temperature increase executedwithout exceeding boiling point. temperature increase would exceed boilingplan invalid. temperature end interval execution computedcurrent temperature heating rate, together durationheating action active (see discussion Example 2).81fiFox & LongExample 2 plan attempts heat pan (say applying blowtorchpan), heat-water interval then, provided concurrent actionends end heat-water action, duration constraint seenviolated duration chosen overall increasetemperature would exceed boiling. concurrent activity ends simultaneouslyheat-water action no-moving-targets rule would violatedduration constraint would attempt access temperature timepoint concurrent action attempted update it.Figure 13 depicts two situations. figure, apply-blowtorch durativeaction applies heat object (in case, pan). part (a) figureduration constraint violated duration heat-water actionsufficient cause temperature increase beyond boiling combinedheat increase caused blowtorch case plan invalid.planner choose value duration avoids violation. part (b)plan determined invalid regardless duration actionno-moving-targets rule. Notice model attempt modelconsequences continued heating pan boiling point, plansactions cause occur simply invalid. However, pddl2.1 usedmodel physical situation, consequences explicitplanner choose exploit avoid accordingly.(a)(b)heatwaterapplyblowtorchheatwatercheck durationconstraintapplyblowtorchincrease temperaturepanSimultaneous changeconsultationtemperatureFigure 13: Heating pan discrete durative action, concurrently another heatingactivity.82fipddl2.1: Expressing Temporal Planning Domains(:durative-action heat-water:parameters (?p - pan):duration ():condition (and (at start (full ?p))(at start (onHeatSource ?p))(at start (byPan))(over (full ?p))(over (onHeatSource ?p))(over (heating ?p))(over (<= (temperature ?p) 100))(at end (byPan))):effect (and(at start (heating ?p))(at end (not (heating ?p)))(increase (temperature ?p) (* #t (heat-rate)))))Figure 14: continuous durative action heating pan water.use duration inequalities adds significant expressive power even using discrete durative actions. example, plan depicted part (a) Figure 13,illustrates use water-heating action shown Figure 12 concurrently heating pan blowtorch, considered valid provided durationvalue satisfies duration constraint water-heating action. brings usclose expressive power available continuous durative actions givesplanner power exploit concurrent interacting activities enacting changesnumeric valued variable (see Example 3). Attempting express continuous changeusing duration inequalities give precisely equivalent behaviour,discretisation forces actions access changing numeric values separated,small temporal interval, actions change values order resolvemutual exclusion. continuous model necessary true valuenumeric variable available consultation time continuous processchange.discrete semantics presented Section 8 exploit fact changesoccur plan executed points corresponding times happenings, plan checked looking activity focussed finite happeningsequence. fact, provided continuous effects restricted linear functions timefirst order effects (which requires continuous effects affect numericexpressions contributing rate change another numeric valued variable), invariants restricted linear functions changing quantities, still possible restrictattention happening sequence even using continuous actions.Non-linear effects higher-order rates change create difficulties since possibleinvariant satisfied end points interval, without necessarilysatisfied throughout interval. cases longer sufficient insertinvariant checking actions fixed mid-points happening sequence plan ordervalidate behaviour. However, provided effects first-order linear,invariants linear continuously changing values, then, despite fact arbitrary83fiFox & LongExample 3 possible discrete durative actions, duration inequalities,model effects adding egg heating water water at, say,90 degrees. applying two heat-water actions, around add-egg action, way overall duration two heat-water actions exactlyduration required boil water original temperature. However,way heat-water action currently modelled means heat turnedegg added, turned complete heating, sincetemperature updated durative action terminates. continuous durative actions egg added whilst single heat-water actionprogress since temperature pan continuously updated. So, discrete durative actions duration inequalities allow us approximate continuous activityappending finite sequence discrete intervals appropriate way.moving targets rule means end points intervals separatednon-zero, arbitrarily small, time gaps. required using continuousactions because, contrast step-function effects discrete actions, continuous effects localised single point.time points within action intervals accessible planner, necessary gainaccess numeric values start- end-points actions plan referthem, together finitely many mid-points invariant-checking actions. valuesrequired points. continuous durative actionssupport modelling exogenous events, necessary take accountexogenous activity environment determining validity plan.5.4 Related ApproachesTime important numerically varying quantity. simplest way reason timeadopt black box durative action model change happens endsdurative intervals. approach taken language used TGP (Smith &Weld, 1999), example, durative actions encapsulate continuous changecorrect values affected variables guaranteed end pointsimplied intervals. logical numeric effects durative action enactedend action undefined interval execution. undeletedpreconditions must remain true throughout interval. syntactic distinctionpreconditions invariant conditions action representation. simplisticway ensuring correct action application prevent concurrent actions referfacts, excludes many intuitively valid plans.sophisticated approach allows preconditions annotated time points,intervals, requirement condition true point,interval, within duration action expressed. approach takenSapa (Do & Kambhampati, 2001). example, using annotated preconditionwould possible express requirement chemical additive added withintwo minutes start tank-filling action. effects also specified occurarbitrary points within duration action possible express effects84fipddl2.1: Expressing Temporal Planning Domainsoccur end specified duration. also possible distinguishconditions local specific points duration actioninvariant throughout action.Allowing reference finitely many time points start end actionsmakes language complex without adding expressive power. timepoints strictly scheduled relative start action effect achieveduse sequence linked durative actions. decided keep pddl2.1simple restricting access end points actions.TLPlan (Bacchus & Ady, 2001) similar, constrained, approach adoptedactions applied instantaneously delayed effects. delayseffects arbitrary different effect. However, invariants cannot specifiedpreconditions checked instant application subsequent delayedeffects separated action initiated them.Several planners developed use networks temporal constraints (Ghallab& Laruelle, 1994; Jonsson, Morris, Muscettola, & Rajan, 2000; El-Kholy & Richards, 1996)handle temporal structure planning problems. Efficient algorithms exist handlingconstraints (Dechter, Meiri, & Pearl, 1991) make practical managinglarge networks. domain models constructed using pddl2.1 certainly lendtreatment similar techniques, constrained handled way.6. Introduction Semantics pddl2.1Sections 7 8 provide formal semantics numeric extension temporalextension pddl2.1. Together sections contain 20 definitions. lengthy treatmentnecessary semantics developed adds four significant extensionsclassical planning semantics Lifschitz developed strips (Lifschitz, 1986).are:introduction time, plans describe behaviour relative real time line;related first extension, treatment concurrency actions executedparallel, lead plans contain concurrent interacting processes(although processes encapsulated durative actions pddl2.1);extension handle numeric-valued fluents;use conditional effects, alone conjunctionextensions.semantics built familiar state-transition model. requirements semantics reduced four essential elements.1. define state. introduction time numeric values complicateusual definition state set atoms.2. define state satisfies propositional formula representing goal conditionprecondition action. extension usual interpretation statevaluation atom true atom state (the ClosedWorld Assumption) required order handle numeric values state.85fiFox & Long3. define state transition induced application action. update rulelogical state must supplemented explanation consequencesnumeric part state.4. define two actions applied concurrently concurrentapplication affects application actions individually.structure definitions follows. Definitions 1 15, given Section 7,define means plan valid plan consists non-durativeactions. Definitions 1 6 set basic terminology, foundational structuresframework handling conditional effects primitive numeric expressions. Definition 2 meets first requirement identified above, defining states. Definition 9 meetssecond requirement, defining goal description satisfied state. Definition 11defines simple plan, extending classical notion sequence actions addingtime. Definitions 12 meets fourth requirement, defining two actions cannotexecuted concurrently. Definition 13 meets third requirement, defining meanexecution actions, including concurrent execution actions. Definitions 14 15define execution plan means plan valid, given basis laidprevious definitions.Section 8 semantics extended give meaning durative actions. beginDefinition 16, defines ground durative actions analogously Definition 6simple (that is, non-durative) actions. Similarly, Definition 17 parallels definitionsimple plan (Definition 11) Definitions 19 20 parallel executionvalidity simple plans (Definitions 14 15). Definition 18 critical definitionsemantics plans durative actions, supplying transformation temporal planssimple plans, whose validity according semantics purely simple plans,used determine validity original temporally structured plans.7. Semantics Simple Planssemantics define section extends essential core Lifschitz strips semantics (1986) handle temporally situated actions, possibly occurring simultaneously,numeric conditional effects.Definition 1 Simple Planning Instance simple planning instance definedpair= (Dom, P rob)Dom = (F s, Rs, As, arity) 4-tuple consisting (finite sets ) function symbols,relation symbols, actions (non-durative), function arity mapping symbolsrespective arities. P rob = (Os, Init, G) triple consisting objectsdomain, initial state specification goal state specification.primitive numeric expressions planning instance, P N Es, terms constructed function symbols domain applied (an appropriate number )objects drawn Os. dimension planning instance, dim, numberdistinct primitive numeric expressions constructed instance.86fipddl2.1: Expressing Temporal Planning Domainsatoms planning instance, Atms, (finitely many) expressions formedapplying relation symbols Rs objects Os (respecting arities).Init consists two parts: Initlogical set literals formed atoms Atms.Initnumeric set propositions asserting initial values subset primitivenumeric expressions domain. assertions assign single primitivenumeric expression constant real value. goal condition propositioninclude atoms formed relation symbols objects planning instancenumeric propositions primitive numeric expressions numbers.collection action schemas (non-durative actions) expressed syntaxpddl. primitive numeric expression schemas atom schemas used actionschemas formed function symbols relation symbols (used appropriatearities) defined domain applied objects Os schema variables.semantics shows instantiated action schemas interpreted state transitions, similar way familiar state transition semantics defined Lifschitz.important difference states longer seen simply sets propositions,must also account numeric expressions appearing planning instancetime state holds. achieved extending notion state.Definition 2 Logical States States Given finite collection atoms planning instance I, AtmsI , logical state subset AtmsI . planning instancedimension dim, state tuple (R, P(AtmsI ), Rdim) R = R {}denotes undefined value. first value time state, secondlogical state third value vector dim values dim primitive numericexpressions planning instance.initial state planning instance (0, Initlogical , x) x vector valuesR corresponding initial assignments given Initnumeric (treating unspecifiedvalues ).Undefined values included numeric ranges domainsterms start undefined nevertheless initialised exploited actions.interpret actions state transition functions necessary achieve two steps.Firstly, since (in pddl2.1) plans ever constructed fully instantiated actionschemas, process instantiation affects constructs action schema mustdefined and, secondly, machinery links primitive numeric expressions elementsvector real values state allows interpretation numeric updatingbehaviours action effects must defined. Since mechanisms support secondsteps also affect process first, treatment numeric effects describedfirst.Definition 3 Assignment Proposition syntactic form numeric effect consistsassignment operator (assign, increase, decrease, scale-up scale-down), oneprimitive numeric expression, referred lvalue, numeric expression (whicharithmetic expression whose terms numbers primitive numeric expressions),referred rvalue.87fiFox & Longassignment proposition corresponding numeric effect formed replacingassignment operator equivalent arithmetic operation (that (increase p q)becomes (= p (+ p q)) on) annotating lvalue prime.numeric effect assignment operator either increase decreasecalled additive assignment effect, one operator either scale-upscale-down called scaling assignment effect others called simple assignmenteffects.numeric effect defines function numeric values state actionapplied determining value primitive numeric expression resulting state.convenience uniform treatment numeric expressions appearing pre-post-conditions, transform functions propositions assert equalitypost-condition value expression intended define it. is, ratherwriting effect (increase p q) function f (p) = p + q, write proposition(= p0 (+ p q)). priming distinguishes postcondition value primitive numericexpression precondition value (a convention commonly adopted describing statetransition effects numeric values). binding primitive numeric expressionsvalues states defined following definition.Definition 4 Normalisation Let planning instance dimension dimI letindexI : P N EsI {1, . . . , dim}(instance-dependent) correspondence primitive numeric expressions.integer indices elements vector dimI real values, Rdimnormalised form ground proposition, p, defined result substituting primitive numeric expression f p, literal XindexI (f ) . normalisedform p referred N (p). Numeric effects normalised first convertingassignment propositions. Primed primitive numeric expressions replacedcorresponding primed literals. X used represent vector hX1 . . . Xn i.Definition 4, replacement primitive numeric expressions indexed literalsallows convenient consistent substitution vector actual parametersvector literals X appearing state.machinery supporting treatment numeric expressions complete,possible consider process instantiating action schemas. process managedtwo steps. first step remove constructs treat syntactic sugardefinition domain. conditional effects quantified formulae. handledirect syntactic transformations action schema set actionschemas considered equivalent. transformation similar describedGazen Knoblock (1997). Although would possible give semantic interpretationapplication conditional effects directly, transformation allows us significantlysimplify question actions performed concurrently.Definition 5 Flattening Actions Given planning instance, I, containing actionschema AsI , set action schemas f latten(A), defined set S, initiallycontaining constructed follows:88fipddl2.1: Expressing Temporal Planning Domainscontains action schema, X, conditional effect, (when P Q), createtwo new schemas copies X, without conditional effect, conjoincondition P precondition one copy Q effects copy,conjoin (not P) precondition copy. Add modified copies S.contains action schema, X, formula containing quantifier, replaceX version quantified formula ( Q ( var1 . . . vark ) P) Xreplaced conjunction (if quantifier, Q, forall) disjunction (if Qexists) propositions formed substituting objects variablevar1 . . . vark P possible ways.steps repeated neither step applicable.flattened, actions grounded usual substitution objects parameters:Definition 6 Ground Action Given planning instance, I, containing action schemaAsI , set ground actions A, GAA , defined set structures,a, formed substituting objects schema variables schema, X,f latten(A) components are:Name name action schema, X, together values substitutedparameters X forming a.Prea , precondition a, propositional precondition a. set groundatoms appear Prea referred GPrea .Adda , positive postcondition a, set ground atoms assertedpositive literals effect a.Dela , negative postcondition a,is set ground atoms assertednegative literals effect a.NPa , numeric postcondition a, set assignment propositions corresponding numeric effects a.following sets primitive numeric expressions defined ground action,GAA :La = {f |f appears lvalue a}Ra = {f |f primitive numeric expression rvalue appears P rea }La = {f |f appears lvalue additive assignment effect a}comment appropriate last definition: action precondition mightconsidered two parts logical part numeric expression-dependent part.Unfortunately, interdependent. example:(or (clear ?x) (>= (room-in ?y) (space-for ?z)))89fiFox & Longmight precondition action. order handle conditions, need checkwhether satisfied given current logical state, also currentvalues domain numeric expressions. inclusion numeric componentstate makes necessary ensure correct substitution numeric valuesexpressions used action precondition. achieved using normalisation processDefinition 4 Definition 9. contrast, postcondition action cannot containinterlocked numeric logical effects, possible separate effectsdistinct numeric logical components.Definition 7 Valid Ground Action Let ground action. valid primitivenumeric expression appears lvalue one simple assignment effect,one different type assignment effect.Definition 7 ensures action attempt inconsistent updates numericvalue. Unlike logical effects action cannot conflict, possible writesyntactic definition action effects inconsistent, exampleassigning two different values primitive numeric expression.Definition 8 Updating Function Let valid ground action. updating functioncomposition set functions:dim{NPFp : RdimR | p N P }NPFp (x) = x0 primitive numeric expression x0i appearlvalue N (p), x0i = xi N (p)[X0 := x0 , X := x] satisfied.notation N (p)[X0 := x0 , X := x] read result normalising psubstituting vector actual values x0 parameters X0 actual values xformal parameters X.Definition 8 defines function describing update effects action. functionensures reals vector describing numeric state remain unchangedaffected action (this numeric-state equivalent persistenceachieved propositions strips assumption). values vector,normalisation process used substitute correctly indexed vector elementsprimitive numeric expressions appearing lvalues (which primed vector elementscorresponding values post-action state) rvalues (the unprimed values appearingpre-action state). tests must satisfied order ensure correct behaviourfunctions composition simply confirm arithmetic rvaluescorrectly applied arrive lvalues. requirement action valid ensurescomposition functions Definition 8 well-defined, since functionsset commute, composition carried order.various sets primitive numeric expressions defined Definition 6 allow usconveniently express conditions two concurrent actions might interfereone another. particular, concerned allow concurrent assignmentprimitive numeric expression, concurrent assignment inspection. allowconcurrent increase decrease primitive numeric expression. allow90fipddl2.1: Expressing Temporal Planning Domainsapply collections concurrent updating functions primitive numeric expressions. allowed provided functions commute. Additive assignmentscommute, updating operations cannot guaranteed so, exceptaffect primitive numeric expressions rely primitive numeric expressionsaffected concurrent assignment propositions. would possible makesimilar exception scaling effects, additive assignment effects particularlyimportant role durative actions shared scaling effects, simplicityallow concurrent updates effects. use three sets primitivenumeric expressions determine whether safe situation not. Within singleaction possible rvalues lvalues intersect. is, action updateprimitive numeric expressions using current values primitive numeric expressionsalso updated action. rvalues values take stateprior execution lvalues supply new values state follows.Definition 9 Satisfaction Propositions Given logical state, s, ground propositional formula pddl2.1, p, defines predicate Rdim, Num(s, p), follows:Num(s, p)(x)iff|= N (p)[X := x]|= q means q true interpretation atom, a,numeric comparison, assigned true iff s, numeric comparison interpretedusing standard equality ordering reals logical connectives given usualinterpretations. p satisfied state (t, s, X) Num(s, p)(X).Comparisons involving , including direct equality two values undefined, enclosing propositions also undefined satisfied state.Definition 10 Applicability Action Let ground action. applicablestate P rea satisfied s.7.1 Semantics Simple Plansimple plan, pddl2.1, sequence timed actions, timed actionfollowing syntactic form:: (action p1 . . . pn )notation positive rational number floating point syntax expression(action p1 . . . pn ) name actual parameters action executedpoint time. complex plans simple durative actions, without numericvalued effects preconditions, co-occur semantics plans discussedSection 8. special separators required separate timed actions sequenceactions required presented time-sorted order. possiblemultiple actions given time stamp, indicating executedconcurrently. emphasised earliest point activity occurs withinplan must strictly time 0. constraint follows decision makeinitial state state existing time 0, together decision, semantics,actions effects interval closed left, starting timeaction applied, preconditions tested interval openright precedes action.91fiFox & Longorder retain compatibility output current planners following concession made: plan presented sequence actions time points,inferred first action applied time 1 succeeding actions applysequence integral time points one unit apart.simple plan slight generalisation familiar strips-style classical plan,since actions labelled time executed.Definition 11 Simple Plan simple plan, SP , planning instance, I, consistsfinite collection timed simple actions pairs (t, a), rational-valuedtime action name.happening sequence, {ti }i=0...k SP ordered sequence times settimes appearing timed simple actions SP . ti must greater 0.possible sequence empty (an empty plan).happening time t, Et , happening sequence SP , set(simple) action names appear timed simple actions associated time SP .plan thus consists sequence happenings, set action names appliedconcurrently specific time, sequence ordered time. timeshappenings occur forms happening sequence. noted action namesambiguous action schemas contain conditional effects consequence flatteningsplit actions multiple actions identical names, differentiatedpreconditions. However, one set actions identical namesapplicable given logical state, since precondition action setnecessarily inconsistent precondition action set, dueway conditional effects distributed pairs action schemasinduce.order handle concurrent actions need define situationseffects actions consistent one another. issue first discussedSection 5.1. mutual exclusion rule pddl2.1 extension idea actionmutex conditions GraphPlan (Blum & Furst, 1995). extension handles two extrafeatures: extended expressive power language (to include arbitrary propositionalconnectives) introduction numeric expressions. make conservativecondition actions executed concurrently, ensures possibilityinteraction. rules cases intuition might suppose concurrencypossible. example, actions:(:action:precondition (or p q):effect (r))(:action b:precondition (p):effect (and (not p) (s)))could, one might suppose, executed simultaneously state p q hold.following definition asserts, however, two actions mutex. reasonchosen constrained definition checking mutex actions must92fipddl2.1: Expressing Temporal Planning Domainstractable handling case implied example would appear require checkingconsequence interleaving preconditions effects possible orderings.condition primitive numeric expressions already discussed determinesupdate effects executed concurrently affect valuestested preconditions (regardless whether results testsmatter satisfaction enclosing proposition). rule movingtargets: concurrent actions affect parts state relevant preconditiontests actions set, regardless whether effects might harmfulnot. might considered odd preconditions one action cannot refer literalsadd effects concurrent action. require preconditionsnegative, case interaction add effects analogous interactionpositive preconditions delete effects. moving targets rule makescost determining whether set actions applied concurrently polynomialsize set actions pre- post-conditions.Definition 12 Mutex Actions Two grounded actions, b non-interferingGP rea (Addb Delb ) = GP reb (Adda Dela ) =Adda Delb = Addb Dela =La Rb = Ra Lb =La Lb La Lbtwo actions non-interfering mutex.last clause definition asserts concurrent actions updatevalues additive assignment effects.ready define conditions simple plan valid.separate executability plan whether actually achieves intended goal.say plan valid executable achieves final goal. Executabilitydefined terms sequence states plan induces sequentially executinghappenings defines.Definition 13 Happening Execution Given state, (t, s, x) happening, H,activity H set grounded actionsAH = {a|the name H, valid P rea satisfied (t, s, x)}result executing happening, H, associated time tH , state (t, s, x)undefined |AH | =6 |H| pair actions AH mutex. Otherwise, state00(tH , , x )[[s0 = (s \Dela )AddaaAHx0aAHresult applying composition functions {NPFa | AH } x.Since functions {NPFa | AH } must affect different primitive numeric expressions,except represent additive assignment effects, functions commute93fiFox & Longtherefore order functions applied irrelevant. Therefore, valuex0 well-defined last definition. requirement activity happeningmust number elements happening simply constraintensures action name happening leads valid action applicableappropriate state. already seen conditional effects induce constructionfamilies grounded actions, one family applicablestate. none applicable given name, must meanprecondition unsatisfied, regardless conditional effects. case, assertingattempt apply action undefined interpretation.Definition 14 Executability simple plan, SP , planning instance, I, executabledefines happening sequence, {ti }i=0...k , sequence states, {Si }i=0...k+1S0 initial state planning instance = 0 . . . k, Si+1result executing happening time ti SP .state Sk+1 called final state produced SP state sequence {Si }i=0...k+1called trace SP . Note executable plan produces unique trace.Definition 15 Validity Simple Plan simple plan (for planning instance, I)valid executable produces final state S, goal specificationsatisfied S.8. Semantics Durative ActionsPlans durative actions discrete effects given semantics termssemantics simple plans. Handling durative actions continuous effectscomplex discuss Section 9.Durative actions appearing plan must given additional field indicatingduration. given syntax:: (action p1 . . . pn ) [d]rational valued duration, written floating point syntax.Durative actions introduced framework defined far generalisingDefinition 1 include durative action schemas. definition grounded action mustextended define form grounded durative actions. However, definitiongiven way associate durative action two simple (nondurative) actions, corresponding end points durative action. simpleactions can, together, simulate almost behaviour durative action.aspects captured pair simple actions duration durativeaction invariants must hold duration. two elements can,however, simply handled minor extension semantics simple plans,approach adopt. taking route avoid difficulties establishingeffects interactions durative actions handled semanticsconcurrent activity within simple plan. see, one difficulty accounthandling durative actions conditional effects contain conditions effectsassociated different times conditions must hold entire duration94fipddl2.1: Expressing Temporal Planning Domainsaction. Since cases complicate semantics postpone treatmentnext section begin durative actions without conditional effects.mapping durative actions non-durative actions important consequence mutex relation implied non-durative actions (advantageously)weaker strong mutex relation used in, example, TGP (Smith & Weld, 1999).Two durative actions applied concurrently provided end-points one actioninteract either end-points (if simultaneous) invariantsaction.Definition 16 Grounded Durative Actions Durative actions groundedway simple actions (see Definition 6), replacing formal parameters constants planning instance expanding quantified propositions. definitiondurative actions requires condition conjunction temporally annotated propositions. temporally annotated proposition form (at start p), (at end p)(over p), p unannotated proposition. Similarly, effects durative action (without continuous conditional effects) conjunction temporallyannotated simple effects.duration field DA defines conjunction propositions separatedDA DC DA , duration conditions start end DA, termsDCstartendarithmetic expressions ?duration. separation conducted obvious way,DA end conditions DC DA .placing start conditions DCstartendgrounded durative action, DA, continuous effects conditional effectsdefines two parameterised simple actions DAstart DAend , parameter?duration value, single additional simple action DAinv , follows.DAstart (DAend ) precondition equal conjunction set propositions, p, (at start p) ((at end p)) condition DA, togetherDA (DC DA ), effect equal conjunction simple effects, e,DCstartend(at start e) ((at end e)) effect DA (respectively).DAinv , defined simple action precondition equal conjunctionpropositions, p, (over p) condition DA. empty effect.Every conjunct condition DA contributes precondition precisely oneDAstart , DAend DAinv . Every conjunct effect DA contributes effectprecisely one DAstart DAend . convenience, DAstart (DAend , DAinv ) usedrefer entire (respective) simple action also name.actions DAstart DAend parameterised ?duration parametermust substituted correct duration value order arrive two simpleactions corresponding start end durative action.Definition 17 Plans plan, P , durative actions, planning instance, I, consistsfinite collection timed actions pairs, either form (t, a),rational-valued time simple action name action schema name togetherconstants instantiating arguments schema, form (t, a[t0 ]),rational-valued time, durative action name t0 non-negative rational-valuedduration.95fiFox & LongDefinition 18 Induced Simple Plan P plan happening sequence P{ti }i=0...k , ordered sequence time points formed set times1{t | (t, a) P (t, a[t0 ]) P (t t0 , a[t0 ]) P }induced simple plan plan P , simplify(P ), set pairs defined follows:(t, a) (t, a) P simple (non-durative) action name.(t, astart [?duration := t0 ]) (t + t0 , aend [?duration := t0 ]) (these expressionssimple timed actions square brackets denote substitution t0 ?durationcase) pairs (t, a[t0 ]) P , durative action name.((ti + ti+1 )/2, ainv ) pair (t, a[t0 ]) P ti < + t0 ,ti ti+1 happening sequence P .process transforming plan simple plan involves introducing actionsrepresent end points intervals durative actions planapplicable. Duration constraints convert simple preconditions start end actions,requiring substitution numeric value ?duration field complete conversion simple actions. complication process invariants cannotassociated end points, must checked throughout interval.achieved adding simple plan collection special actions responsible checking invariants. actions added pair happenings originalplan lying start end point durative action. semanticssimple plans requires preconditions actions plan satisfied, even thoughmight effects, consequence putting monitoring actionssimple plan ensure original plan judged valid invariants remaintrue, firstly, start durative action and, subsequently, happeningoccurs throughout duration durative action. One possibility makemonitoring actions occur times updating actions, would requirevalues accessed time might updated, violatingmoving targets rule. order avoid problem monitoring actions interleavedupdating actions inserting midway pairs successive happeningsinterval durative action executed. happenings original plan need considered carrying insertion, since invariant-checkingactions cannot effect states checked.Alternative treatments invariants possible, important advantageapproach taken semantics rests, finally, state-transition modelform familiar planning community. is, plans seen recipesstate-transition sequences, state-transition function currentstate world next. However, durative actions complicate picturerely commitment, durative action started, followcompletion. commitment involves sort communication across durationplan. communication managed structures outside plan, examine1. Care taken reading definition last disjunct allows time correspondingend execution durative action included happening time.96fipddl2.1: Expressing Temporal Planning Domainstrace, artificial modification plan ensure states carry extrainformation start end durative action. latter approachdisadvantage durative actions become complex artificial componentsmust added plan become intrusive. particularly apparenttreatment conditional effects require conditions tested start durativeaction, across duration, effects triggered end, since casesrequire sort memory state remember status tested conditionsstart durative action end point. memory conditions allowus avoid embedding entire execution history state substituting ad hocmemory history propositions times required.management conditional effects form, mapping durative actionssimple actions, discussed Section 8.1.conclude definitions supporting validity plan durativeactions.Definition 19 Executability Plan plan, P (for planning instance), executable induced simple plan P , simplify(P ) executable, producing trace{Si = (ti , si , vi )}i=0...k .Definition 20 Validity Plan plan, P (for planning instance), validexecutable goal specification satisfied final state produced inducedsimple plan.8.1 Durative Actions Conditional Effectsexplain mapping described previous section extended dealdurative actions containing conditional effects.First, observe temporally annotated conditions effects accumulated,temporal annotation distributes logical conjunction. Therefore,convert conditional effects conditions simple conjunctionsone start condition, one end condition one condition.noted allow logical connectives conjunction combining temporally annotated propositions. Allowing connectives would create significantcomplexity semantics create potentially paradoxical opportunitiescommunication future states earlier states. Similarly conditions, durative actioneffects reduced conjunction one start effect one endeffect. Treatment conditional effects divides three cases. first casestraightforward: effect durative action form (when (at p) (at q)),condition effect bear single temporal annotation, transformed simple conditional effect form (when p q) attached start endsimple action according whether start end. Since case straightforwardexplicitly extend previous definitions cope it. second case onecondition condition effect start conditions effect endeffects.Note consider conditional effects effects occur start,conditions dependent state end duration action,97fiFox & Longmeaningless. reverse expected behaviour causality, causeprecedes effect. attempt validate plan constructing trace reversedcausality would huge problem, since could determine initial effects applying durative action seen conditions held subsequent intervalconclusion activity, but, equally, could see effects activity interval would without seeing initial effects applying durative action.paradox created opportunity action change past.handle second case need modify state start durative action remember whether start conditions satisfied communicateend durative action simply looked (then) current statedetermine whether conditional effect applied. apply transformationconditional effects form (when (and (at start ps) (at end pe)) (at end q))conditional effect added start simple action, (when ps (Mps )), conditional effect added end simple action, (when (and pe (Mps )) q), Mpsspecial new proposition, unique particular conditional effect particular application durative action transformed. ensuring proposition uniqueway, possibility action plan interfering it,represents isolated memory fact ps held state durativeaction started. conditional effect end conditions, transformation applied, simply ignoring pe previous discussion. Figure 15 depictstransformation single durative action, A, conditional effect, collectionlevel 2 actions, complete appropriate memory proposition (in case calledP ).importance memory introduced transformation explained Figures 16 17. Figure 16 shows ambiguity results rememberingstate, trajectory plan, reached. figure illustrates onestate (P, Q, R) point durative action (as described Figure 15) ends,impossible determine state alone whether R added not.possible reached state (P, Q, R) least two different paths,least one path seen started state P held least one pathseen started state P hold (using action, achieve-P , Peffect). state (P, Q, R) contain information disambiguatepath used reach it, hence cannot determine correct value Rends.third, final, case durative action conditional effects form:(when (and (at start ps) (over pi) (at end pe)) (at end q)).Again, effect start end conditions following transformationapplied simply ignoring ps pe appropriate. case need construct transformation remembers whether ps held state durativeaction first applied, also whether pi holds throughout interval startend durative action. Unlike invariants durative actions, conditionsrequired hold plan valid, determine effects occurend durative action. idea use intervening monitoring actions, ratherinvariants definition 18. achieved adding effect start98fipddl2.1: Expressing Temporal Planning DomainsInitial Durative Action(:durative-action:parameters ():duration (= ?duration 2):condition ():effect (when (and (at start P) (at end Q))(at end R)))Transformation simple actions(:action A-start:parameters ():precondition ():effect (when P P*))(:action A-end:parameters ():precondition ():effect (when (and P* Q) R))Expansion conditional effects(:action A-start:parameters ():precondition (P):effect (P*))(:action A-start:parameters ():precondition (not P):effect ())(:action A-end:parameters ():precondition (and P* Q):effect (R))(:action A-end:parameters ():precondition (or (not P*) (not Q)):effect ())Transformation Plan Simple PlanPlanPlan1:A[2]1:A-start3:A-endFigure 15: Conversion durative action non-durative actions groundedforms.99fiFox & LongP,Q,~R1:A-start3:A-endP,Q,~RP,QR?1:A-start~P,Q2:achieve-P~P,Q~R~RFigure 16: Flawed state space resulting failure record path traversed conditional effects span interval durative action. arc labelled achieve-Pindicates possible application action achieves propositionP.1:A-startP,Q~R,~P*P*,PQ,~R3:A-end2:achieve P~P,Q~R,~P*1:A-start~P,Q~R,~P*P,QR,P*3:A-endP,Q,~R,~P*P,Q~R,~P*Figure 17: Correct state space showing use memory proposition P*. arc labelledachieve P indicates possible application action achievesproposition P.action: (Mpi ). Then, monitoring (simple) actions required precondition, single conditional effect: (when (and (Mpi ) (not pi)) (not (Mpi ))).again, Mpi special new proposition unique conditional effect applicationinstance durative action transformed. monitoring actions addedintermediate points used monitoring actions Definition 18.transformation used second case required start condition,ps, (when ps (Mps )) added conditional effect start simple action. Finally,add conditional effect end (simple) action: (when (and (Mps ) (Mpi ) pe) q).effect machinery ensure proposition pi becomes false timestart end durative action Mpi deleted, otherwiseend durative action Mps hold precisely ps held start actionMpi hold precisely pi held entire duration durative action.Therefore, conditional effect end action achieves intuitively correct behaviourasserting conditional effect precisely start condition held startdurative action, end condition holds end durative actioncondition held throughout duration action.addition new memory-checking actions means longer trueclaim added actions cannot change state. However, memory propositionsunique task communication single action instance, effectsmemory-checking actions might implications invariants.100fipddl2.1: Expressing Temporal Planning Domains9. Semantics Continuous Durative Actionsintroduction continuous durative actions complicates semantics. longerpossible handle invariants insertion simple actions happeningsplan test continued satisfaction. fact, continuous effects can, principle, causeinvariant satisfied parts interval others. Ignoringinvariants moment, updates numeric values caused continuous effectsapplied discrete updates time points within interval apply.updates behave slightly differently discrete updates seen durative actionsdiscrete effects, since possible continuous update affect variableconcurrently affected discrete update, examined precondition, without creatinginconsistency. example, water heating action Figure 14 appliedconcurrent addition egg pan precondition temperaturewater 90 95 degrees value temperature examinedmoment application action adding egg. temperaturechange actually happening interval start heatingpoint egg added, rather discrete update point eggadded. temperature actually changed instant addition egg.section summarise semantics continuous actions. semanticsdiscrete durative actions defined terms familiar state-transition semantics,continuous semantics introduces different formulation.Definition 21 Continuous Durative Action continuous effect effect expression includes symbol #t. continuous durative action durative actionleast one continuous effect.Definition 22 Continuous Update Function Let C set ground continuous effectsplanning instance, I, St = (t, S, X) state. continuous update functiondefined C state St function fC : R Rn , n dimI , that:dfC=gdtfC (0) = Xg update function generated action with:N Pa = { (<op> P Q) | (<op> P (* #t Q)) C}Definition 22 shows continuous effects several continuous durative actionscombined create single system simultaneous differential equations whose solution,given appropriate starting point, defines evolution continuously varying values.Definition 23 Induced Continuous Plan Let planning instance includescontinuous durative actions P plan I. induced continuous plan Ptriple, (S, Invs, Cts), simplif y(P ), Invs set invariant constraints:Invs = {(Q, t, + d) | (t, a[d]) P (over Q) invariant A}101fiFox & LongLet ti ti+1 two consecutive times happening sequence simplif y(P ).set active continuous effects (ti , ti+1 ) is:{Q | (t, a[d]) P, (ti , ti+1 ) [t, + d] Q continuous effect a}Cts set systems continuous effects:Cts = {(C, ti , ti+1 ) | C set active continuous effects (ti , ti+1 )}components continuous plan separate invariant conditions continuous effects rest simple plan order allow correct applicationcontinuous updates allow confirmation invariants hold facecontinuous effects.Definition 24 Trace Let planning instance includes continuous durative actions, P plan I, (SP, Inv, Cts) induced continuous plan P , {ti }i=0...khappening sequence S0 initial state I. trace Psequence states {Si }i=0...k+1 defined follows:element (C, ti , ti+1 ) Cts Si+1 state resulting applyinghappening ti simple plan SP state Si .(C, ti , ti+1 ) Cts let Ti state formed substituting f (ti+1 ti )numeric part state Si , f continuous update function defined Cstate Si . Si+1 state resulting applying happening tisimple plan SP state Ti . f undefined element Ctstrace.Definition 24 defines trace similar fashion traces simple plans plansdurative actions. key difference need apply continuous updates.handled solving systems simultaneous differential equations across intervalactive applying result update numeric values acrossinterval. course, easier describe do, since solving arbitrarysimultaneous differential equations algorithmically generally possible. certainconstraints semantics implemented order confirm validity planautomatically.Definition 25 Invariant Safe Let planning instance includes continuous durative actions, P plan I, (S, Inv, Cts) induced continuous plan P{Si }i=0...k+1 trace P . (C, ti , ti+1 ) Cts let fi continuous updatefunction defined C Si . P invariant safe if, fi defined(Q, t, u) Inv [(ti , ti+1 )] = (t, u), x I, Num(s, Q)(fi (x))logical state Si .definition, symbols [(..)] used mean interval closedopen either end.102fipddl2.1: Expressing Temporal Planning Domainssemantic point view, invariants must checked every point interval apply. interval contains finitely many discrete changesobligation met considering finite number pointschange occurs (a fact exploited discrete durative action plan semantics Definition 18). continuous change obligation much harder meet.practice, invariants checked examining possible roots function describing continuous change, finding roots difficult general. Again,suitable constraints forms differential equations expressed domain makevalidation problem tractable.last two definitions simply assemble components arrive analogous definitions executability validity simple plans plans durative actions.Definition 26 Executability Plan plan P containing continuous durative actions,planning instance I, induced continuous plan (S, Invs, Cts). P executabletrace P defined, {Si }i=0...k+1 , invariant safe.Definition 27 Plan Validity plan P containing durative actions, planning instancevalid executable, trace {Si }i=0...k+1 Sk+1 satisfies goal I.10. Plan ValidationPlan validation important part use pddl, particularly rolecompetition. approximately 5000 plans consider competition 2002,seen automation essential. validation problem tractable propositionalversions pddl plans finite validated simply simulationexecution. issue complicated pddl2.1 potential concurrentactivity, possibly face numeric change, makes necessary ensure invariantproperties protected concurrent activity non-interfering.durative actions used question whether planconsidered valid contain end points actions initiatedplan. action exploited plan effect end durationclear end point present plan, action selectedstart effect less clear. match-striking action performed start effect,order burned match end brief interval. could arguedthat, obtained desired start effect end action irrelevantplan terminate (as soon goals achieved) without ensuring initiatedactions end safely. Indeed, plan search process Sapa (Do & Kambhampati, 2001)terminate whilst still queued events awaiting advancement time. However,possible conceive situations end point action, incorporatedstart effect, introduces inconsistencies plan inclusion wouldmake plan invalid. cases seems plan validity could compromisedignoring end effects.order avoid resolve complexities, taken viewpddl2.1 plan valid action start end points explicit within plan.identified case proceed confirm happenings withinplan mutex-free.103fiFox & LongPlan validation decidable domains including discretized and, certain constraints, continuous durative actions activity encapsulated durativeactions explicitly identified plan. makes trace induced plan finitehence checkable. therefore observe validation problem pddl2.1 decidableeven actions contain duration inequalities. work determiningduration inequalities solved already completed finishedplan validation plan proceed simulation execution, casepddl plans. problem tractable domains without continuous effects,introduction continuous effects can, principle, allow expression domainscomplex functions describing numeric change (Howey & Long, 2002). assumptioncontinuous effects restricted description terms simple linear quadraticfunctions, without interactions concurrent continuous effects, plan validitytractable. cost practice increased however, since may necessary solvepolynomials order check invariants. Validation plans containing complexexpressions change explored.Although plan validity checking tractable, subtlety arisesneed represent plans syntactically difficulties involved expressing numbers arbitrary precision. principle, values required describevalid plans algebraic (assuming constrain continuous effects indicated above),therefore finitely representable. practice, expecting planners handle numbersalgebraic expressions seems unnecessarily complicated far reasonable assume numbers represented finite precision floating point values. Indeed,syntax adopted expression plans restricts planners expressing timesfinite precision floating point values. constraint, limitationsprecision floating point computations implementations plan validation systems,necessary take pragmatic view validation process acceptnumeric conditions evaluated certain tolerance. Otherwise, occurway report plan necessary degree accuracyvalid interpretation semantics defined Section 8. cases, planspecifies time points to, example, four significant digits, reasonable abstractionexecution time activity needed control flow system. plan specifytime points absolutely precisely, abstraction forced upon planner factworking models world physical world itself. problem, then,one relationship theoretical semantics pragmatic concernsautomated validation.Figure 18 relationship depicted terms kinds plans automatically validated. left side picture describes theoretical semantics,arrow indicating link plans interpretation theoreticalsemantics. example, possible constructdomain problem planrequires action happen time 2 meaningful semantic object,plan specifies theaction happen time 1.41 meaningful semantic object1.41 equal 2. two plans distinct, one correct (underassumed constraints). right side picture depicts pragmatic validationsyntactic plan objects. two control plans, though distinct semantics, mapsyntactic object assume validation subject tolerance 0.01.104fipddl2.1: Expressing Temporal Planning DomainsSemantic interpretation plansValidation plansmapping semantics pragmaticrealisation automated validation processSemantic plan objectsfifffiffmapping semantic plans syntacticcounterparts.Syntactic plan objectsspecific pair mappingsFigure 18: pragmatic mapping semantics plans validationautomated computational processes. shaded area contains plans cannotinterpreted within theoretical semantics. seen plancollection indistinguishable meaningful plan mappedsyntactic side picture.plans map syntactic object 1.41 approximates value 2.syntactic plan validated using pragmatic validation processes necessaryautomatic validation describable syntactic plans, check validity subjecttolerance 0.01. pragmatic constraints representations plans,expectations representations numeric values planners validatorsconsequences reasonable assumptions given models checkvalidity are, case, abstractions, non-zero tolerance, world. practice,problem accept plans specified tolerance levels pathological cases,arithmetic precision computer representations floats immediate negativeimpact one tries take stronger line plans acceptedstrictly valid according formally precise evaluation expressions.Finally, interesting philosophical issue arises discussed Henzinger co-authors (1997, 2000). is, fact, possible achieve exact precisionmeasurement time continuous numeric quantities. Henzinger et al.considered problem development robust automata. Robust automataaccept trace exists tube traces within distance > 0 originaltrace, acceptable original acceptance criteria. called fuzzytubes indicating time fuzzily, rather precisely, detectable. idea offers pathformal semantics closer defining plans robust imprecisionexecutives ability measure time. Unfortunately, checking fuzzy tubes intractable.currently compromise adopting value, used tolerance checkingnumeric values fulfil numeric constraints plan execution, also represent minimum separation conflicting end points within plans. consistent ideaplanner assumes executive willing abstract indicated tolerancelevel checking preconditions actions unreasonable supposeplan make use finer grained measurements determining actions105fiFox & Longapplied. moment value set validation process, communicated informally planner-engineers, might better allow domain designerdefine appropriate use particular domain. remain several issuesconcerning correct management buffers validation (particularly usualproblem concerning transitivity fuzzy closeness) important issuestemporal reasoning whole restricted planning context.yet solutions problems.11. Related Work: Representing Reasoning TimeRepresentation of, reasoning with, statements time temporal extentpropositions long subject research AI including planning research (Allen,1984; McDermott, 1982; Sandewall, 1994; Kowalski & Sergot, 1986; Laborie & Ghallab,1995; Muscettola, 1994; Bacchus & Kabanza, 2000). Important issues raisedextension pddl handle temporal features have, course, already examinedresearchers, example Shanahans work (1990) continuous change withinevent calculus, Shohams work (1985) Reichgelts work (1989) temporal reasoning work non-reified temporal systems (Bacchus, Tenenberg, & Koomen, 1991).Vila (1994) provides excellent survey work temporal reasoning AI. sectionbriefly review central issues addressed, treatmentliterature, set pddl2.1 context research temporal logics.Several researchers temporal logics considered problems reasoningconcurrency, continuous change temporal extent. works focussedproblem reasoning change world described using arbitrary logicalformulae, concerned making meta-level statements (sucheffect cannot precede cause). need handle complex logical formulae makesframe problem difficult resolve, approach based circumscription (McCarthy,1980) default reasoning (Reiter, 1980) typical. strips assumption providessimple solution frame problem states described using atomic formulae.classical planning assumption states described atomicallygeneral view modelling change. Although simplifying, assumptionsurprisingly expressive. bench mark domains introduced third InternationalPlanning Competition suggest atomic modelling powerful enough capturecomplex domains closely approximate real problems. temporal reasoning issuesconfront simplified consequence made simplifying assumptionstates updated. remain concerned major issues temporalreasoning: concurrency, continuous change temporal extent.development pddl2.1 made basic decision consider end pointsdurative actions instantaneous state transitions. allows us concentratetruth propositions points instead intervals. decision consider actionsway similar made many temporal reasoning researchers (Shanahan, 1990;McCarthy & Hayes, 1969; McDermott, 1982). context pddl2.1 approachadvantage smoothly integrating classical planning view actions statetransitions. Nevertheless, Allen shown temporal ontology based intervalsbasis planning (Allen, 1984, 1991) several planning systems106fipddl2.1: Expressing Temporal Planning Domainsstrongly influenced intervals approach (Muscettola, 1994; Rabideau, Knight, Chien,Fukunaga, & Govindjee, 1999). Allen later moved away initial position instantsrequired, introducing notion moments (Hayes & Allen, 1987),concept attempts reconcile stance nothing instantaneous (sointervals) observation changes values discrete-valued variables,propositional variables, apparently cannot avoid changing instants. viewconsistent approach take modelling continuous durative actions,view change consisting discrete continuous aspects (Henzinger,1996).remainder section compare pddl extensions proposeprevious work temporal reasoning considering three central issues identified above.objective claim extensions improve previous work, insteaddemonstrate implementation solutions three problems within pddlframework makes exploitation directly accessible planning wayembedded within logic accompanying proof theory.11.1 Continuous changeSeveral temporal reasoning frameworks began consideration discrete change and,later, extended handle continuous change. example, Shanahan (1990) extendedevent calculus Kowalski Sergot (1986) enable modelling continuouschange. process extension mirrors situation faced extending pddl,system modelling discrete change already existed. is, therefore, interesting compareuse pddl2.1 use systems extended event calculus.sink-filling example Shanahan (1990) discusses issues termination events(self-termination termination events), identification level watersink filling process effect rate change level watersink filled two sources simultaneously. behaviour fillingprocess effects state sink time modelled axioms wouldallow inference engine predict state sink points executionprocess.pddl2.1 allows representation complex interactions arise sinkfilled multiple independently controlled water sources means concurrent durativeactions continuous effects encapsulate initiation filling process,single water source, change level water sink terminationprocess water source turned off. model robust, since easilyaccommodates multiple water sources, simply modifying rate flow appropriatelycommutative updates. Since actions additive effects model providesrate water enters tank source, possible compute levelwater sink point filling interval concurrent action mightconsult level. contrast Shanahans extension event calculus, approachrequire filling process (at least point view logicalaxiomatisation) terminated restarted new rate water source openedclosed, since process simply remains active throughout. change rate filling107fiFox & Longreflected piecewise-linear profile depth water sink,Shanahans model.possible model multiple water sources situation filling processcompletely encapsulated within discretized durative action. discretized actiontrue level water accessible filling process end start.Step-function behaviour coarsely approximates true behaviour, consequencecomplex interactions cannot properly modelled.One important consequences continuous behaviour triggering events.Shanahans extensions achieved axiomatisation causal relationshipsevents distinguished syntactically actions, facthappening axiomatically consequence certain conditions. pddl2.1 events(such flooding sink filling continues capacity reached)modelled using combination conditional effects duration inequalities.However, events modelled way, since always possible predictspontaneous events occur. pddl2.1 could extended allow expressioncausal axioms, alternative approach modify language enablerepresentation events within action-oriented tradition. achievedbreaking continuous durative actions instantaneous start end pointsprocesses encapsulate. would enable execution process initiatedstart action ended instantaneous state transition either actioncontrol planner event. simple extension language neededdistinguish actions events prevent planner deliberately selectingevent. refer approach start-process-stop model, extendedpddl2.1 support (Fox & Long, 2002). resulting language, pddl+, difficultplan pddl2.1, still open questions, concerning complexityplan validation problem language, remain topics future work.11.2 Concurrencyopportunity concurrent activities complicates several aspects temporal reasoning.Firstly, necessary account actions concurrent secondlynecessary describe concurrent activities interact effects world.formalisms first points achieved relying underlying logicdeliver inconsistency attempt made apply two incompatible actions simultaneously. example, axioms event calculus yield simultaneoustruth falsity fluent incompatible actions applied simultaneously consequently yield inconsistency. Unfortunately, recognising inconsistency is, general,undecidable, sufficiently expressive language. pddl2.1 adopt solutionexploits restricted form action-centred formalism, defining circumstancestwo actions could lead inconsistency rejecting simultaneous applicationactions. favour conservative restriction compatibility actions (themoving targets rule), order support efficient determination incompatibility, ratherpermissive elusive ruling. alternative approach, adopted BacchusTLplan (2001), example, allow multiple actions occur instant,nevertheless executed sequence. find solution counter-intuitive and,108fipddl2.1: Expressing Temporal Planning Domainsimportantly, consider would impossible use plan sort instructionexecutive executive could equipped execute actions simultaneously yetspecified order. view order execution matters executivemust ensure actions sequenced within limitationscapability measure time react passing.Shanahan (1999) discusses Gelfonds (1991) example soup bowlproblem concerns raising soup bowl without spilling soup. Two actions, lift leftlift right, applied bowl. either applied soup spill, but,argued, applied simultaneously bowl raised tablesoup spills. Shanahan considers example within event calculus, usesexplicit assertion interaction lift left lift right actions ensurespillage effect cancelled pair executed together. assumptiontwo actions executed precisely moment reasonerrely successful simultaneity order exploit effect.pddl2.1 take view precise simultaneity outside controlphysical executive. plan interpreted instruction executive systemhold executive system capable measuring time controlling activityarbitrarily fine degrees accuracy. particular, possible executiveensure two actions must independently initiated executed simultaneously.plan rely precision measurement then, claim, couldexecuted reliable expectation success not, therefore, consideredvalid plan.pddl2.1 supports modelling soup bowl situation following way. Twodurative actions, lift left lift right, independently initiate tilting intervals which,complete, result spillage soup effects counteracted.Provided two lift actions start within appropriate tolerance one anothertilting corrected spillage avoided without need model cancellationeffects. argue executive execute two actions within finenon-zero tolerance one another, therefore successfully lift bowl. eventcalculus model presented Shanahan insists precise synchronization two actions,incorrectly allowing inferred soup spilled even timeelapses two lifts actually small enough allow correction tiltingbowl. Worse, Shanahans axioms would allow lack precise synchronizationexploited achieve spillage, using amount time smaller correctly describingphysical situation modelled.one considers unnecessary model precise interaction two lifts,one alternative pddl2.1 abstract interaction see soup-bowllifting action single discretized action achieves successful raising bowl.11.3 Temporal extentcommon concern temporal reasoning frameworks, discussed detail Vilaothers (Vila, 1994; van Bentham, 1983), divided instant problem. problemapparent considering happens moment transition from, say,truth falsity propositional variable. question must addressed whether109fiFox & Longproposition true, false, undefined inconsistently true false instanttransition. Clearly last possibilities undesirable. solution adoptcombination pragmatic philosophically principled. pragmatic elementchoose model actions instantaneous transitions effects beginninginstant application. Thus, actions mark end-points intervals persistencestate closed left open right. ensures intervals nesttogether without inconsistency truth values propositions always defined.half-open-half-closed solution adopted elsewhere. example, Shanahan (1999)observes similar approach used event calculus, although intervalsclosed right. Although two choices effectively equivalent, slightlyprefer closed-on-the-left choice since allows validation plan concludestate point execution final action, making determinationtemporal span plan unambiguous.philosophical point view truth value proposition instantapplication action cannot exploited action, virtuemoving targets rule position, outlined above, valid plan cannot dependprecise synchronisation actions. forces actions require propositionprecondition sit open end half-open interval proposition holds.11.4 Planning Timeclassical planning models, time treated relative. is, temporal structuring plan, reasoning plan, ordering actions.clearly emphasised issues dominated planning research late 1980searly 1990s, classical planning mainly characterised exploration partialplan spaces, planners tweak (Chapman, 1987), snlp (McAllester & Rosenblitt,1991) ucpop (Penberthy & Weld, 1992). Partial plans include collection actionsrepresenting activity thus far determined part possible plan settemporal constraints actions. temporal constraints used partial planform < B B time points corresponding applicationactions.Classical linear planners (Fikes & Nilsson, 1971; Russell & Norvig, 1995) relysimple fact total ordering points actions applied triviallyembedded time line. Again, duration actions considered. roletime planning becomes far significant metric time introduced. metrictime possible associate specific durations actions, set deadlines windowsopportunity. problems associated relative time still resolvedmetric time framework, new problems introduced. particular, durations becomeexplicit, necessary decide durations attach to: actions states. Further,explicit temporal extents make important confront issue concurrencyorder best exploit measured temporal resources available planner.contrast simple ordering constraints required relative time, metric timerequires powerful constraint management. metric time constraint handlersbuilt around foundations laid Dechter, Meiri Pearl (1991). example, IxTeTuses extensions temporal constraint networks (Laborie & Ghallab, 1995). language110fipddl2.1: Expressing Temporal Planning DomainsIxTeT uses represent planning domains similar pddl2.1 describedpaper, expressive allows access time points within intervaldurative action. added expressive power obtained cost increased semanticcomplexity and, consequently, increased difficulty validation plans. However,many similarities modelling discretised durative actions pddl2.1IxTeT, similar modelling conventions also found languages Sapa (Do &Kambhampati, 2001) Oplan (Drabble & Tate, 1994).One earliest planners consider use metric time Deviser (Vere, 1983),developed nonlin (Tate, 1977). Deviser, metric constraints timesactions could applied deadlines achievements goalsexpressible planner could construct plans respecting metric temporal constraintsinteractions actions. Cesta Oddi (1996) explored various developments temporal constraint network algorithms achieve efficient implementationplanning Galipienso Sanchis (2002) consider extensions manage disjunctivetemporal constraints efficiently, particularly valuable expressive element planconstruction observed above, since constraints preventing overlap intervals translate disjunctive constraints time points. hsts (Muscettola, 1994) also reliestemporal constraint manager.systems use continuous real-valued time possible make use linearconstraint solvers handle temporal constraints. particular, constraints dictatedrelative placement actions durations timeline approachedway (Long & Fox, 2003a). alternative timeline often used discretised linebased integers. advantage approach possible advance timenext value considering activity given time point. next modalityinterpreted continuous time framework taking mean state followingnext logical change, regardless time occurs (Bacchus & Kabanza, 1998).planning problems events occur actions dictatedplanner continuous change modelled, plans finite structures thereforechange occur finite number time points execution. makespossible embed execution plan integer-valued discrete time linewithout loss expressiveness.Various researchers considered problem modelling continuous change. Pednault (1986) proposes explicit description functions govern continuous changemetric parameters, attached actions effect instantaneous change initiateprocesses. However, approach easy use describing interacting continuousprocesses. example, water filling tank constant rate additionalwater source added increase rate filling action initiating secondprocess must combine effects two water sources. means secondaction cannot described simply terms direct effect world increaserate flow tank reference effects actionsalready affected rate change parameter. Shanahan (1990) also usesapproach, consequence processes modelled stopping restartingnew trajectories interacting action applied.Zeno (Penberthy & Weld, 1994), actions effects described termsderivatives. approach makes easier describe interacting processes, complicates111fiFox & Longmanagement processes making necessary solve differential equations.complication deterred authors taking approach: McDermott (2003)takes approach process planner.introduction continuous processes planning problem represents considerable complication, even model includes temporal features supportsconcurrency. area active research community yet agreedmatters representation, let alone semantics. remain many open problemsplanning community address, development languages planning algorithms also development plan verification tools embody widelyaccepted semantics.12. ConclusionsRecent developments AI planning research leading community closerapplication planning technology realistic problems. necessitateddevelopment representation language capable modelling domains temporalmetric features. approach taken towards development languageextend McDermotts pddl domain representation standard support temporalmetric models.development pddl sequence towards greater expressive power importantplanning community pddl provided common foundation greatdeal recent research effort. problems involved modelling behaviour domainsdiscrete continuous behaviours well explored temporal logicmodel checking communities widely adopted models withinplanning community. work pddl2.1 provides way making relevantdevelopments communities accessible planning. Furthermore, pddl2.1 beginsbridge gap basic research applications-oriented planning providingexpressive power necessary capture real problems.pddl2.1 expressive power represent class deterministic mixed discretecontinuous domains planning domains. language introduces form durative actionbased three connected parts: initiation interval numeric changemight occur explicit termination means action produces statecorresponding end durative interval. form action allows modellingdiscrete continuous behaviours discretized change representedmeans step functions, whilst continuous change modelled using #t variable.language provides solutions critical issues concurrency, continuous changetemporal extent. semantics language derived familiar statetransition semantics strips, extended interpret invariants holding intervalscontinuous functions might also active. semantics allows us interpretplans efficiently validate. describe criteria plan must satisfyorder practically verifiable.paper focussed primarily discussion numeric discretised temporal features pddl2.1. However, modelling capability discretized durative actionsrespects limited important planning community addresschallenges presented continuous change. Indeed, even using continuous actions112fipddl2.1: Expressing Temporal Planning Domainspddl2.1 possible model episodes change terminated spontaneousevents world rather deliberate choice planner. future goalscommunity include addressing domains require continuous actionspddl2.1, confronting challenges planning within dynamic environmentsintervals change terminated world well deliberate actionplanner. constitute important step towards planning within dynamicunpredictable environments.Acknowledgementswould like thank members committee third International PlanningCompetition. particular, discussions Drew McDermott, Fahiem Bacchus, DavidSmith Hector Geffner turns infuriated, intrigued delighted us contributedimmeasurably strengths paper. Many others offered commentsinsights allowed us develop work present here. would like thankJorg Hoffmann, Malte Helmert, Antonio Garrido, Stefan Edelkamp, Nicola Muscettola,Mark Boddy, Keith Golden, Jeremy Frank, Ari Jonsson, Julie Porteous, Alex Coddington,Stephen Cresswell, Luke Murray, Keith Halsey Richard Howey many helpfuldiscussions shared.113fiFox & LongAppendix A. BNF Specification pddl2.1appendix contains complete BNF specification pddl2.1 language.strict superset pddl1.x. example, use local variables within action schemasleft specification. widely used part languageused competition domains. interpretation local variablesproposed McDermott subtle, since demands confirmation unique instantiationexists variable. non-trivial confirm case planvalidation domains significant expressive power fact largelyignored suggests poorly understood. changes discussed followingsections.A.1 DomainsDomain structures remain essentially specified pddl1.x. main alterationsintroduce slightly modified syntax numeric fluent expressions removesyntax hierarchical expansions. latter necessarily abandoned, not,best knowledge, used publicly available planning systems evendomains. original pddl specification, distinction drawn strict pddlnon-strict pddl, strict pddl must follow ordering fields specified below,non-strict pddl restricted way. practice, relatively fieldsintuitive accept arbitrary orders natural expect declarationsprecede use symbols preconditions precede effects. However, declarationsconstants, predicates function symbols naturally ordered, currentdefinition pddl ordering fields must follow specification below,exception three fields legal order respect one another,although group must follow types (if any) precede action specifications.<domain>::= (define (domain <name>)[<require-def>][<types-def>]:typing[<constants-def>][<predicates-def>][<functions-def>]:fluents<structure-def> )<require-def>::= (:requirements <require-key>+ )<require-key>::= See Section A.5<types-def>::= (:types <typed list (name)>)<constants-def>::= (:constants <typed list (name)>)<predicates-def>::= (:predicates <atomic formula skeleton>+ )<atomic formula skeleton>::= (<predicate> <typed list (variable)>)<predicate>::= <name><variable>::= ?<name><atomic function skeleton>::= (<function-symbol> <typed list (variable)>)<function-symbol>::= <name><functions-def>::=:fluents (:functions <function typed list(atomic function skeleton)>)<structure-def>::= <action-def><structure-def>::=:durativeactions <durative-action-def>114fipddl2.1: Expressing Temporal Planning Domainsslight modification made type syntax longer possiblenest either expressions (a possibility never exploited, complicates parsing).Numbers longer considered implicit type extension numbershandled functional expressions. ensures finitely manyground action instances. desirable consequence action selection choice points neednever include choice arbitrary numeric ranges. use finite ranges integersspecifying actions useful (see Mystery FreeCell example) extensionstandard syntax allow convenient representation cases coulduseful. syntax function declarations allows functions declared types.present syntax restricted number types, since semanticsfunctions, syntax offers scope possible extension. types givenfunction results assumed numbers.<typed list (x)><typed list (x)><primitive-type><type><type>::= x::=:typing x+ - <type> <typed list(x)>::= <name>::= (either <primitive-type>+ )::= <primitive-type><function typed list (x)> ::= x<function typed list (x)> ::=:typing x+ - <function type><function typed list(x)><function type>::= numberA.2 ActionsBNF action definition given below. Again, simplified removinggenerally unused constructs (mainly hierarchical expansions). emphasisedremoval intended permanent exclusion hierarchical expansion syntaxproved difficult element language agree exploit.levels language stabilise hope return layer redevelop it.<action-def>::= (:action <action-symbol>:parameters ( <typed list (variable)> )<action-def body>)<action-symbol>::= <name><action-def body> ::= [:precondition <GD>][:effect <effect>]Goal descriptions extended include fluent expressions.<GD><GD><GD><GD>::= ()::= <atomic formula(term)>::=:negativepreconditions <literal(term)>::= (and <GD> )115fiFox & Long<GD><GD><GD><GD><GD><GD><f-comp><literal(t)><literal(t)><atomic formula(t)><term><term><f-exp><f-exp><f-exp><f-exp><f-head><f-head><binary-op><binary-op><binary-op><binary-op><binary-comp><binary-comp><binary-comp><binary-comp><binary-comp><number>::=:disjunctivepreconditions (or <GD> )::=:disjunctivepreconditions (not <GD>)::=:disjunctivepreconditions (imply <GD> <GD>)::=:existentialpreconditions(exists (<typed list(variable)> ) <GD> ):universalpreconditions::=(forall (<typed list(variable)> ) <GD> ):fluents::=<f-comp>::= (<binary-comp> <f-exp> <f-exp>)::= <atomic formula(t)>::= (not <atomic formula(t)>)::= (<predicate> )::= <name>::= <variable>::= <number>::= (<binary-op> <f-exp> <f-exp>)::= (- <f-exp>)::= <f-head>::= (<function-symbol> <term> )::= <function-symbol>::= +::=::=::= /::= >::= <::= =::= >=::= <=::= numeric literal(integers floats form n.n).Effects extended include functional expression updates. syntax proposed little different syntax proposed earlier version pddl.syntax conditional effects proposed Fahiem Bacchus AIPS 2000 adopted,nesting conditional effects supported. assignment operatorsprefix forms. Simple assignment called assign (previously change) operators corresponding C update assignments, + =, =, = / = given namesincrease, decrease, scale-up scale-down respectively. prefix formadopted preference infix form order preserve consistency Lisp-likesyntax non-C names help C C++ programmers rememberoperators used prefix form). prefer assign original changeintroduction increase makes nature change ambiguous.<effect><effect><effect><c-effect><c-effect><c-effect><p-effect><p-effect><p-effect>::= ()::= (and <c-effect> )::= <c-effect>::=:conditionaleffects (forall (<variable> ) <effect>)::=:conditionaleffects (when <GD> <cond-effect>)::= <p-effect>::= (<assign-op> <f-head> <f-exp>)::= (not <atomic formula(term)>)::= <atomic formula(term)>116fipddl2.1: Expressing Temporal Planning Domains<p-effect><cond-effect><cond-effect><assign-op><assign-op><assign-op><assign-op><assign-op>::=:fluents (<assign-op> <f-head> <f-exp>)::= (and <p-effect> )::= <p-effect>::= assign::= scale-up::= scale-down::= increase::= decreaseA.3 Durative ActionsDurative action syntax built relatively conservative extension existing actionsyntax.<durative-action-def> ::= (:durative-action <da-symbol>:parameters ( <typed list (variable)> )<da-def body>)<da-symbol>::= <name><da-def body>::= :duration <duration-constraint>:condition <da-GD>:effect <da-effect>conditions durative action executed complexstandard actions, specify conditions must hold pointexecution. also specify conditions must hold throughout durationdurative action also termination. distinguish components introducesimple temporal qualifier preconditions. use name precondition wouldsomewhat misleading given conditions described include constraintsmust hold action begun. motivated adoption :conditiondescribe collection constraints must hold order successfully applydurative action. logical form conditions durative actions restrictedconjunctions temporally annotated expressions, clearly scope futureextension allow complex formulae.<da-GD><da-GD><da-GD><timed-GD><timed-GD><time-specifier><time-specifier><interval>::=::=::=::=::=::=::=::=()<timed-GD>(and <timed-GD>+ )(at <time-specifier> <GD>)(over <interval> <GD>)startendduration (?duration) durative action specified equal givenexpression (which function numeric expressions), else constrainedinequalities. latter allows actions conclusion actionfreely determined executive without necessarily side-effects.example, walk two locations could made take long executive117fiFox & Longconsidered convenient, provided least long time taken walklocations fastest walking speed possible. Constraints specifyexact duration durative action might prove harder handle, introducedlabel (:duration-inequalities) signal domain makes use them. durationconstraint supplied dictate limit temporal extent durative action.duration implicit parameter durative action must supplied planuses durative actions. denote this, durative action denoted plant:(name arg1...argn)[d] (non-negative, rational valued) durationfloating point format (n.n). Duration constraints explicitly temporally annotatedindicate evaluated context start end point action,else left unannotated, case default evaluatedcontext start action (as indicated Definition 16).<duration-constraint><duration-constraint><duration-constraint><simple-duration-constraint><simple-duration-constraint><d-op><d-op><d-op><d-value><d-value>::=:durationinequalities(and <simple-duration-constraint>+ )()<simple-duration-constraint>(<d-op> ?duration <d-value>)(at <time-specifier><simple-duration-constraint>)::=:durationinequalities <=::=:durationinequalities >=::= =::= <number>::=:fluents <f-exp>::=::=::=::=addition logical effects, occur start end durative action,durative actions numeric effects refer literal ?duration. sophisticated durative actions also make use functional expressions describing effectsoccur duration action. allows functional expressions updatedcontinuous function time, rather step functions.<da-effect><da-effect><da-effect><da-effect><da-effect><da-effect><timed-effect><timed-effect><timed-effect><f-assign-da><f-exp-da><f-exp-da><f-exp-da><f-exp-da>::= ()::= (and <da-effect> )::= <timed-effect>::=:conditionaleffects (forall (<variable> ) <da-effect>)::=:conditionaleffects (when <da-GD> <timed-effect>)::=:fluents (<assign-op> <f-head> <f-exp-da>)::= (at <time-specifier> <a-effect>)::= (at <time-specifier> <f-assign-da>)::=:continuouseffects (<assign-op-t> <f-head> <f-exp-t>)::= (<assign-op> <f-head> <f-exp-da>)::= (<binary-op> <f-exp-da> <f-exp-da>)::= (- <f-exp-da>)::=:durationinequalities ?duration::= <f-exp>Note ?duration term used define functional expression updatingeffects duration constraints requirement set. casesduration value available expression, whereas duration constraints providedduration can, sometimes, freely selected within constrained boundaries.118fipddl2.1: Expressing Temporal Planning Domains<assign-op-t><assign-op-t><f-exp-t><f-exp-t><f-exp-t>::=::=::=::=::=increasedecrease(* <f-exp> #t)(* #t <f-exp>)#tsymbol #t used represent period time given durative actionactive. therefore local clock value duration, independent similarclocks duration. discussion members committeeuse expression using #t: proposed expression declaringrate change alone could used. decided groundsassertion rate change suggests rate change determined one processeffect alone. fact, intended multiple active processes affect fluenteffects accumulated. Using expression directly defines amountprocess contributes change fluent value time appearassert (inconsistently) fluent multiple simultaneous rates change.A.4 ProblemsPlanning problems specifications modified exclude several generally unusedconstructs (named initial situations expansion information). removedlength specification odds intention supply physics, advice.Furthermore, advice field offers over-emphasises coarse plan metric. Instead,introduced optional metric field, used supply expressionoptimized construction plan. field states whether metricminimized maximized. course, planner free ignore field makeassumption plans fewest steps considered good plans. However,consider extension crucial one development widely applicableplanning language. provided variable total-time takes valuetotal execution time plan. allows us conveniently express intentionminimize total execution time.anticipate extensions plan metric syntax prove necessarylonger term, believe version already provides significant new challengecommunity. Problem specifications still somewhat impoverished termsability easily specify temporal constraints goals non-standard featuresinitial goal states. Again, anticipate need extension, chosen leaveclean sheet future developments.<problem>::= (define (problem <name>)(:domain <name>)[<require-def>][<object declaration> ]<init><goal>[<metric-spec>][<length-spec> ])<object declaration> ::= (:objects <typed list (name)>)<init>::= (:init <init-el> )<init-el>::= <literal(name)>119fiFox & Long<init-el><goal><metric-spec><optimization><optimization><ground-f-exp><ground-f-exp><ground-f-exp><ground-f-exp><ground-f-exp><ground-f-exp><length-spec>::=:fluents (= <f-head> <number>)::= (:goal <GD>)::= (:metric <optimization> <ground-f-exp>)::= minimize::= maximize::= (<binary-op> <ground-f-exp> <ground-f-exp>)::= (- <ground-f-exp>)::= <number>::= (<function-symbol> <name> )::= total-time::= <function-symbol>::= (:length [(:serial <integer>)][(:parallel <integer>)])length-spec deprecated.A.5 Requirementstable requirements pddl2.1. requirements imply others;abbreviations common sets requirements. domain stipulates requirements,assumed declare requirement :strips.Requirement:strips:typing:negative-preconditions:disjunctive-preconditions:equality:existential-preconditions:universal-preconditions:quantified-preconditions:conditional-effects:fluents:adl:durative-actions:duration-inequalities:continuous-effectsDescriptionBasic STRIPS-style adds deletesAllow type names declarations variablesAllow goal descriptionsAllow goal descriptionsSupport = built-in predicateAllow exists goal descriptionsAllow forall goal descriptions= :existential-preconditions+ :universal-preconditionsAllow action effectsAllow function definitions use effects usingassignment operators arithmetic preconditions.= :strips + :typing+ :negative-preconditions+ :disjunctive-preconditions+ :equality+ :quantified-preconditions+ :conditional-effectsAllows durative actions.Note imply :fluents.Allows duration constraints durativeactions using inequalities.Allows durative actions affect fluentscontinuously duration actions.120fipddl2.1: Expressing Temporal Planning DomainsReferencesAllen, J. (1984). Towards general theory action time. Artificial Intelligence, 23,123154.Allen, J. (1991). Planning temporal reasoning. Proceedings KR-91, pp. 314.Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaining approach. Proceedings IJCAI01, pp. 417424.Bacchus, F., & Kabanza, F. (1998). Planning temporally extended goals. AnnalsMathematics Artificial Intelligence, 22, 527.Bacchus, F., & Kabanza, F. (2000). Using temporal logic express search control knowledgeplanning. Artificial Intelligence, 116(1-2), 123191.Bacchus, F., Tenenberg, J., & Koomen, J. (1991). non-reified temporal logic AI.Artificial Intelligence, 52, 87108.Blum, A., & Furst, M. (1995). Fast Planning Plan-graph Analysis. ProceedingsIJCAI-95.Cesta, A., & Oddi, A. (1996). Gaining efficiency flexibility simple temporal problem. Chittaro, L., Goodwin, S., Hamilton, H., & Montanari, A. (Eds.), ProceedingsTIME96.Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 29, 333377.Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49.Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Proceedings ECP-01.Drabble, B., & Tate, A. (1994). use optimistic pessimistic resource profilesinform search activity based planner. Proceedings AIPS-94. AAAI Press.El-Kholy, A., & Richards, B. (1996). Temporal resource reasoning planning:ParcPlan approach. Proceedings ECAI96.Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theoremproving problem-solving. Artificial Intelligence, 2 (3), 189208.Fox, M., & Long, D. (2002). PDDL+ : Planning time metric resources. Tech.rep. Department Computer Science, 21/02, University Durham, UK. Availableat: http://www.dur.ac.uk/d.p.long/competition.html.Galipienso, M., & Sanchis, F. (2002). Representation reasoning disjunction temporal constraints. Proceedings TIME02.Garrido, A., Onainda, E., & Barber, F. (2001). Time-optimal planning temporal problems. Proceedings ECP01.Gazen, B., & Knoblock, C. (1997). Combining expressivity UCPOP efficiencyGraphplan. Proceedings ECP-97, pp. 221233.Gelfond, M., Lifschitz, V., & Rabinov, A. (1991). limitations situationcalculus?. Boyer, R. (Ed.), Essays honor Woody Bledsoe, pp. 167179. KluwerAcademic.121fiFox & LongGhallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporalplanner. Proceedings AIPS94.Gupta, V., Henziner, T., & Jagadeesan, R. (1997). Robust timed automata. HART-97:Hybrid Real-time Systems, LNCS 1201, pp. 331345. Springer-Verlag.Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. ProceedingsECP01, Toledo.Hayes, P., & Allen, J. (1987). Short time periods. Proceedings IJCAI-87, pp. 981983.Helmert, M. (2002). Decidability undecidability results planning numericalstate variables. Proceedings AIPS-02.Henzinger, T. (1996). theory hybrid automata. Proceedings 11th Annual Symposium Logic Computer Science. Invited tutorial., pp. 278292. IEEEComputer Society Press.Henzinger, T., & Raskin, J.-F. (2000). Robust undecidability timed hybrid systems.Proceedings 3rd International Workshop Hybrid Systems: ComputationControl. LNCS 1790., pp. 145159. Springer-Verlag.Howey, R., & Long, D. (2002). Validating plans continuous effects. Tech. rep., Dept.Computer Science, University Durham.Jonsson, A., Morris, P., Muscettola, N., & Rajan, K. (2000). Planning interplanetaryspace: theory practice. Proceedings AIPS-00.Kowalski, R., & Sergot, M. (1986). logic-based calculus events. New GenerationComputing, 4, 6795.Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings IJCAI-95. Morgan Kaufmann.Lifschitz, E. (1986). semantics STRIPS. Proceedings 1986 Workshop:Reasoning Actions Plans.Long, D., & Fox, M. (2003a). Exploiting graphplan framework temporal planning.Proceedings ICAPS03.Long, D., & Fox, M. (2003b). overview analysis results 3rd InternationalPlanning Competition. Journal Artifical Intelligence Research, issue.McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. ProceedingsAAAI91, Vol. 2, pp. 634639, Anaheim, California, USA. AAAI Press/MIT Press.McCarthy, J. (1980). Circumscription form non-monotonic reasoning. ArtificialIntelligence, 13, 2739.McCarthy, J., & Hayes, P. (1969). philosophical problems standpointartificial intelligence. Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 4, pp.463502. Edinburgh University Press.McDermott, D. (1982). temporal logic reasoning processes plans. CognitiveScience, 6, 101155.McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2).122fipddl2.1: Expressing Temporal Planning DomainsMcDermott, D. (2003). Reasoning autonomous processes estimated-regressionplanner. Proceedings ICAPS-03.McDermott, D., & AIPS-98 Planning Competition Committee (1998).PDDLthe planning domain definition language.Tech. rep., Available at:www.cs.yale.edu/homes/dvm.Muscettola, N. (1994). HSTS: Integrating planning scheduling. Zweben, M., & Fox,M. (Eds.), Intelligent Scheduling, pp. 169212. Morgan Kaufmann, San Mateo, CA.Nau, D., Cao, Y., Lotem, A., & Munoz-Avila, H. (1999). SHOP: Simple hierarchical orderedplanner. Proceedings IJCAI99.Pednault, E. (1986). Formulating multiagent, dynamic-world problems classical planning framework. Georgeff, M., & Lansky, A. (Eds.), Proceedings TimberlineOregon Workshop Reasoning Actions Plans.Pednault, E. (1989). ADL: Exploring middle ground STRIPS situationcalculus. Proceedings KR-89, pp. 324332.Penberthy, J., & Weld, D. (1994). Temporal planning continuous change. ProceedingsAAAI-94. AAAI/MIT Press.Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial-order plannerADL. Proceedings KR92, pp. 103114, Los Altos, CA. Kaufmann.Rabideau, G., Knight, R., Chien, S., Fukunaga, A., & Govindjee, A. (1999). Iterative repairplanning spacecraft operations ASPEN system. International SymposiumArtificial Intelligence Robotics Automation Space (i-SAIRAS).Reichgelt, H. (1989). comparison first order modal theories time. Jackson,P., Reichgelt, H., & van Harmelen, F. (Eds.), Logic-based knowledge representation,pp. 143176. MIT Press.Reiter, R. (1980). logic default reasoning. Artificial Intelligence, 13, 81132.Russell, S., & Norvig, P. (1995). Artificial Intelligence: Modern Approach. Prentice Hall.Sandewall, E. (1994). Features fluents: representation knowledge dynamicalsystems, volume I. Oxford University Press.Shanahan, M. (1990). Representing continuous change event calculus. ProceedingsECAI90, pp. 598603.Shanahan, M. (1999). event calculus explained. Wooldridge, M., & Veloso, M.(Eds.), Artificial Intelligence Today, pp. 409430. Springer Lecture Notes ArtificialIntelligence no. 1600.Shoham, Y. (1985). Ten requirements theory change. New Generation Computing,3, 467477.Smith, D., & Weld, D. (1999). Temporal planning mutual exclusion reasoning.Proceedings IJCAI-99, Stockholm, pp. 326337.Tate, A. (1977). Generating project networks. Proceedings IJCAI77.van Bentham, J. (1983). logic time. Kluwer Academic Press, Dordrecht.123fiFox & LongVere, S. (1983). Planning time: Windows durations activities goals. IEEETransactions Pattern Analysis Machine Intelligence, 5.Vila, L. (1994). survey temporal reasoning artificial intelligence. AI Communications, 7, 428.Wilkins, D. (1988). Practical Planning: Extending Classical AI Planning Paradigm.Morgan Kaufmann Publishers Inc., San Francisco, CA.124fi