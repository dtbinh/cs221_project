Journal Artificial Intelligence Research 20 (2003) 405-430

Submitted 10/02; published 12/03

VHPOP: Versatile Heuristic Partial Order Planner
Hakan L. S. Younes
Reid G. Simmons

lorens@cs.cmu.edu
reids@cs.cmu.edu

School Computer Science, Carnegie Mellon University
Pittsburgh, PA 15213, USA

Abstract
VHPOP partial order causal link (POCL) planner loosely based UCPOP.
draws experience gained early mid 1990s flaw selection strategies
POCL planning, combines recent developments field domain independent planning distance based heuristics reachability analysis.
present adaptation additive heuristic plan space planning, modify
account possible reuse existing actions plan. also propose large set novel
flaw selection strategies, show help us solve problems previously possible POCL planners. VHPOP also supports planning durative actions
incorporating standard techniques temporal constraint reasoning. demonstrate
heuristic techniques used boost performance classical POCL planning effective domains durative actions well. result versatile
heuristic POCL planner competitive established CSP-based heuristic state space
planners.

1. Introduction
first half last decade, much research domain independent plan
generation focused partial order causal link (POCL) planners. two dominant POCL
planners SNLP (McAllester & Rosenblitt, 1991) UCPOP (Penberthy & Weld,
1992), large part planning research aimed scaling two planners.
promising attempts making POCL planning practical involved alternative flaw
selection strategies (Peot & Smith, 1993; Joslin & Pollack, 1994; Schubert & Gerevini, 1995;
Williamson & Hanks, 1996; Pollack, Joslin, & Paolucci, 1997). flaw POCL planning
either unlinked precondition (called open condition) action, threatened causal
link. flaw selection backtracking point search plan space
complete plan, order flaws resolved dramatic effect
number plans searched solution found. role flaw selection POCL
planning similar role variable selection constraint programming.
dramatic advances domain independent planning past seven
years, focus shifted POCL planning CSP-based planning algorithms
(Blum & Furst, 1997; Kautz & Selman, 1996) state space planning heuristic search
(Bonet & Geffner, 2001b; Hoffmann & Nebel, 2001). Recently, Nguyen Kambhampati (2001) showed techniques distance based heuristics reachability analysislargely responsible efficiency todays best domain independent
plannerscan also used dramatically improve efficiency POCL planners, thereby
initiating revival previously popular approach domain independent planning.
c
2003
AI Access Foundation. rights reserved.

fiYounes & Simmons

drawn experience, well experience flaw selection strategies
glory-days POCL planning, developing Versatile Heuristic Partial
Order Planner (VHPOP), result POCL planner able compete
well CSP-based heuristic state space planners 3rd International Planning
Competition (IPC3).
previously (Younes & Simmons, 2002) adapted additive heuristicproposed
Bonet, Loerincs, Geffner (1997) used HSP (Bonet & Geffner, 2001b)for
plan space search. paper present variation additive heuristic POCL
planning accounts possible reuse actions already part plan.
show accounting positive interaction often results effective plan
ranking heuristic. also present ablation studies demonstrate effectiveness
tie-breaking heuristic based estimated planning effort (defined total number
open conditions, current future, need resolved order complete
partial plan). results show using tie-breaking heuristic almost always improves
planner performance.
heuristics implemented VHPOP work either ground (fully instantiated) lifted (partially instantiated) actions, chose work ground actions
IPC3. shown elsewhere (Younes & Simmons, 2002) planning lifted
actions help reduce branching factor search space compared using ground
actions, reduction sometimes large enough compensate added
complexity comes keep track variable bindings. studies
needed, however, gain better understanding circumstances planning
lifted actions beneficial.
VHPOP efficiently implements common flaw selection strategies, DUnf
DSep (Peot & Smith, 1993), LCFR (Joslin & Pollack, 1994), ZLIFO (Schubert &
Gerevini, 1995). addition these, introduce numerous novel flaw selection strategies
paper, four used IPC3. claim resolved
issue global versus local flaw selectionmanifested conflicting claims made
Gerevini Schubert (1996) one hand, Pollack et al. (1997)
efficient way reduce number searched plans POCL planning
show combining ideas ZLIFO LCFR get efficient
flaw selection strategies. novel flaw selection strategies introduced paper
based heuristic cost, idea previously explored Ghallab Laruelle (1994).
also introduce conflict-driven flaw selection strategies aim expose possible
inconsistencies early search, show strategies based idea
effective domains previously thought particularly difficult POCL planners.
Ideally, would like one single flaw selection strategy dominates
strategies terms number solved problems. yet discover universal
strategy, instead use technique previously explored Howe, Dahlman, Hansen,
Scheetz, von Mayrhauser (1999) combining strengths different planning algorithms. idea run several planners concurrently, Howe et al. showed
problems solved running single planner. VHPOP
use basic POCL planning algorithm instances, use different flaw
selection strategies concurrently.
406

fiVHPOP

VHPOP extends capabilities classical POCL planners also supporting planning
durative actions. accomplished adding simple temporal network (STN)
(Dechter, Meiri, & Pearl, 1991) regular plan representation POCL planner.
STN records temporal constraints actions plan, supersedes simple
ordering constraints usually recorded POCL planners. use STNs permits actions
interval constraints duration (a feature utilized
domains IPC3 VHPOP could handle). approach take temporal POCL
planning essentially constraint-based interval approach described
Smith, Frank, Jonsson (2000), similar techniques handling durative actions
POCL framework traced back least Veres DEVISER (Vere, 1983).
contribution temporal POCL planning demonstrating heuristic
techniques shown boost performance classical POCL planning also effective
domains durative actions, validating feasibility POCL paradigm
temporal planning larger set benchmark problems done before.

2. Basic POCL Planning Algorithm
briefly review POCL planners work, introduce terminology used throughout
paper. thorough introduction POCL planning, refer reader
tutorial least commitment planning Weld (1994).
(partial) plan represented tuple hA, L, O, Bi, set actions,
L set causal links, set ordering constraints defining partial order set A,
B set binding constraints action parameters (B = ground actions
used). action instance action schema planning domain,
q
plan contain multiple instances action schema. causal link, ai aj ,
represents commitment planner precondition q action aj fulfilled
effect action ai .
q

open condition, ai , precondition q action ai yet linked
q
effect another action. unsafe link (or threat) causal link, ai aj , whose
condition q unifies negation effect action could possibly ordered
ai aj . set flaws plan union open conditions unsafe
links: F () = OC() U L().
POCL planner searches solution planning problem space partial
plans trying resolve flaws plan. Algorithm 1 shows generic procedure
POCL planning given planning problem returns plan solving problem (or failure
given problem lacks solution). planning problem set initial conditions
set goals G, represented initial plan two dummy actions a0 ,
effects a0 represent initial conditions problem preconditions
represent goals problem. procedure Make-Initial-Plan used
Algorithm 1 returns plan h{a0 , }, , {a0 }, i. set P generated,
yet visited, partial plans kept. stage planning process, plan selected
removed P, flaw selected plan. possible refinements
resolving flaw (returned procedure Refinements) added P,
process continues P empty (indicates failure) plan without flaws found.
407

fiYounes & Simmons

Algorithm 1 Generic POCL planning algorithm formulated Williamson Hanks
(1996).
Find-Plan(I, G)
P {Make-Initial-Plan(I, G)}
P 6=
element P plan selection
P P \ {}
F () =
return
else
f element F () flaw selection
P P Refinements(, f )
return failure (problem lacks solution)
q

open condition, ai , resolved linking q effect existing
q
new action. unsafe link, ai aj threatened effect p action ak , resolved
either ordering ak ai (demotion), ordering ak aj (promotion).
use lifted actions instead ground actions, threat also resolved adding binding
constraints p q cannot unified (separation).

3. Search Control
search complete plan, first select plan work on, given plan
select flaw repair. two choice points indicated Algorithm 1. Making
informed choice cases essential good planner performance,
following presentation choices made VHPOP.
3.1 Plan Selection Heuristic
VHPOP uses algorithm (Hart, Nilsson, & Raphael, 1968) search plan
space. algorithm requires search node evaluation function f (n) = g(n) + h(n),
g(n) cost getting n start node (initial plan) h(n)
estimated remaining cost reaching goal node (complete plan). want find plans
containing actions, take cost plan number actions it.
plan = hA, L, O, Bi therefore g() = |A|.
original implementations SNLP UCPOP used hf () = |F ()| heuristic cost function, i.e. number flaws plan. Schubert Gerevini (1995) consider
alternatives hf (), present empirical data showing counting open conditions (hoc () = |OC()|) often gives better results. big problem, however, using
number open conditions estimate number actions needs
added assumes uniform cost per open condition. ignores fact
open conditions linked existing actions (thus requiring additional actions),
open conditions resolved adding whole chain actions (thus
requiring one action).
408

fiVHPOP

Recent work heuristic search planning resulted informed heuristic cost
functions state space planners. previous work (Younes & Simmons, 2002)
adapted additive heuristicfirst proposed Bonet et al. (1997) subsequently used
HSP (Bonet & Geffner, 2001b)for plan space search also extended handle
negated disjunctive preconditions actions well actions conditional effects
lifted actions. heuristic cost function used VHPOP IPC3 variation
additive heuristic reuse actions taken account, coupled
tie-breaking rank (introduced Younes & Simmons, 2002) based estimated remaining
planning effort.
3.1.1 Additive Heuristic POCL Planning
key assumption behind additive heuristic subgoal independence. give
recursive definition additive heuristic POCL planning, starting level
literals working towards definition heuristic cost partial plan.
Given literal q, let GA(q) set ground actions effect unifies
q. cost literal q defined

q unifies literal holds initially
0
minaGA(q) hadd (a) GA(q) 6=
hadd (q) =
.


otherwise
positive literal q holds initially part initial conditions. negative literal q
holds initially q part initial conditions (the closed-world assumption).
cost action
hadd (a) = 1 + hadd (Prec(a)),
Prec(a) propositional formula negation normal form representing preconditions action a. propositional formula negation normal form negations
occur level literals. propositional formula transformed negation
normal form, done action preconditions VHPOP parsing domain
description file.
Existentially quantified variables action precondition treated additional
parameters action. cost existentially quantified precondition
simply defined follows:
hadd (x.) = hadd ()
deal universally quantified preconditions making fully instantiated
preprocessing phase, order complete definition heuristic cost action
preconditions need add definitions heuristic cost conjunctions
disjunctions. cost conjunction sum cost conjuncts:
^

hadd (

) =

X



hadd (i )



summation formula gives additive heuristic name.
definition based assumption subgoals independent, lead
409

fiYounes & Simmons

overestimation actual cost conjunctive goal (i.e. heuristic admissible).
cost disjunction taken cost disjunct minimal cost:
_
hadd ( ) = min hadd (i )




additive heuristic cost function POCL plans defined follows:
X
hadd () =
hadd (q)
q

ai OC()

cost function conjunction, definition easily lead overestimation number actions needed complete plan, since possible reuse ignored.
propose remedy below.
cost ground literals efficiently computed dynamic programming.
take conditional effects account cost computation. effect q conditioned p action a, add hadd (p) cost achieving q a. need
compute cost ground literals preprocessing phase, leaving little
overhead evaluating plans planning phase. working lifted actions,
extra overhead unification. also noted lifted literals
independently matched ground literals without considering interactions open
conditions action. example, two preconditions (a ?x) (b ?x)
action unified ground literals different matchings variable ?x.
3.1.2 Accounting Positive Interaction
additive heuristic take reuse actions (other dummy action a0 )
account, often overestimates actual number actions needed complete
plan. need take positive interaction account order obtain
accurate heuristic estimate recognized state space planning (Nguyen &
Kambhampati, 2000; Hoffmann & Nebel, 2001; Refanidis & Vlahavas, 2001) plan space
planning (Nguyen & Kambhampati, 2001). IPC3 used slight modification
additive heuristic address issue action reuse:

aj s.t. effect aj unifies q
0
X
hradd () =
ai aj 6

q
hadd (q) otherwise
ai OC()
q

underlying assumption heuristic cost function open condition ai
possibly resolved linking effect existing action aj give
rise new action resolved. course lead overly optimistic estimate
number actions required complete plan. modified heuristic still
admissible, however, since cost value used open conditions
cannot linked effects existing actions. words, account possible
reuse existing actions potential actions.
illustrate difference hadd () hradd () consider planning domain
two action schemas A1 A2 , A1 preconditions A2 single
410

fiVHPOP

Problem
DriverLog6
DriverLog7
DriverLog8
DriverLog9
DriverLog10
ZenoTravel6
ZenoTravel7
ZenoTravel8
ZenoTravel9
ZenoTravel10
Satellite6
Satellite7
Satellite8
Satellite9
Satellite10

MW-Loc
hadd
hradd
8.65
0.16
3.66
0.34
0.33
4.13
2.11
0.93
- 15.48
- 86.21
- 26.59
0.36
0.22
0.49
0.37
1.09
2.41
1.53
1.12

MW-Loc-Conf
hadd
hradd
4.41
0.13
0.63
0.17
110.26
1.48
0.28
0.71
0.76
17.41
2.90
37.81
37.99
11.53
21.22
0.37
0.24
0.54
0.84
1.29
0.84
2.11
1.95
1.11

LCFR-Loc
hadd
hradd
87.58
2.01
21.15
1.28
- 177.27
3.79
0.64
25.09
0.95
33.37
21.20
0.32
0.21
0.55
0.51
0.85
0.83
1.84
1.50
1.36

LCFR-Loc-Conf
hadd
hradd
1.16
1.57
0.22
2.05
1.30
0.83
11.24
2.82
33.10
6.45
26.33
9.49
18.22
0.40
0.24
0.62
1.25
0.68
2.50
2.08
1.37

Table 1: Planning times seconds using different flaw selection strategies selection
problems DriverLog, ZenoTravel, Satellite domains, showing impact
taking reuse account plan ranking heuristic. dash (-) means
planner ran memory (512 Mb).

precondition q. Assume q achieved action instance A1 .
heuristic cost literal q therefore 1 according additive heuristic. Consider
plan two unordered actions a1 a2 (ai instance action schema
q
Ai ) single open condition a2 . hadd () = hadd (q) = 1 corresponding
addition new instance action schema A1 achieve q, hradd () = 0
action (viz. a1 ) ordered a2 effect unifies q.
Table 1 shows taking reuse account significant impact planning time
practice. modified additive heuristic hradd clearly dominates hadd DriverLog
ZenoTravel domains despite incurring higher overhead per generated plan. results
Satellite domain mixed, hadd slight edge overall. show
planning times four flaw selection strategies used VHPOP IPC3.
novel flaw selection strategies discussed detail Section 3.2.2.
Hoffmann Nebel (2001) describe FF heuristic takes positive interaction actions account extracting plan relaxed planning graph1 , argue
accounting action reuse one contributing factors FFs performance
advantage HSP. FF heuristic take reuse potential actions account,
existing actions case modified additive heuristic.
result better estimate actual plan cost, requires plan extracted
1. relaxed planning graph planning graph action pairs marked mutex.

411

fiYounes & Simmons

relaxed planning graph every search node, could costly. would interesting
see FF heuristic performs used plan space planner.
heuristic cost function used RePOP (Nguyen & Kambhampati, 2001), heuristic
partial order planner working solely ground actions, defined using serial planning
graph.2 heuristic similar spirit FF heuristic, like FF heuristic
take reuse potential actions account. RePOP heuristic also takes account
reuse existing actions, seemingly without considering ordering constraints,
something modified additive heuristic. Furthermore, hradd heuristic
always takes reuse existing actions achieves literal q account,
RePOP heuristic considers existing action happens selected
serial planning graph action achieves q. results Table 2 indicate
RePOP heuristic may less effective additive heuristic (with without
reuse) certain domains.
3.1.3 Estimating Remaining Effort
want find plans consisting actions, also want
exploring plans possible. Schubert Gerevini (1995) suggest number
open conditions useful estimate number refinement steps needed
complete plan. take idea bit further.
computing heuristic cost literal, also record estimated effort
achieving literal. literal achieved initial conditions estimated
effort 1 (corresponding work adding causal link plan). cost
literal comes action a, estimated effort literal estimated effort
preconditions a, plus 1 linking a. Finally, estimated effort conjunction
sum estimated effort conjuncts, estimated effort disjunction
estimated effort disjunct minimal cost (not effort).
main difference heuristic cost estimated effort plan estimated effort assigns value 1 instead 0 literals unified initial
condition. illustrate difference, consider plan two open conditions p q
hold initial conditions. heuristic cost 0, estimated
effort 2. estimated effort basically heuristic estimate total number open
conditions resolved complete plan found, used
tie-breaker two plans 0 case f () = f ( 0 ). Consider alternative plan
0 number actions single open condition p. plan
heuristic cost 0 plan , estimated effort 1, 0 would
selected first estimated effort used tie-breaker. Table 2 shows using estimated
effort tie-breaker notable impact planner performance hadd
hradd . Estimated effort helps reduce number generated explored plans cases
one (when using hradd problem rocket-ext-a).
Estimated effort useful plan ranking heuristic, also heuristic flaw
selection soon see.
2. serial planning graph planning graph every pair non-noop actions level marked
mutex.

412

fiVHPOP

Problem
gripper-8
gripper-10
gripper-12
gripper-20
rocket-ext-a
rocket-ext-b
logistics-a
logistics-b
logistics-c
logistics-d

hadd
1636 / 705
3268 / 1359
5879 / 2359
33848 / 12204
34917 / 25810
27871 / 20034
503 / 301
857 / 488
766 / 422
3039 / 1398

effort
1089 / 449
1958 / 795
3224 / 1294
14386 / 5558
27846 / 20028
27277 / 19363
481 / 287
713 / 404
630 / 346
2950 / 1384

hradd
*
*
*
*
24507 / 15790
15919 / 9000
621 / 389
694 / 402
629 / 353
2525 / 1300

effort
*
*
*
*
31213 / 20321
10914 / 6705
530 / 317
584 / 326
438 / 227
1472 / 682

RePOP
*
*
*
*
30110 / 17768
85316 / 51540
411 / 191
920 / 436
4939 / 2468
*

Table 2: number generated/explored plans hadd hradd without
estimated effort tie-breaker. RePOP column contains numbers reported Nguyen Kambhampati (2001) RePOP using serial planning
graph heuristic. numbers included purpose showing
seems qualitative difference RePOP heuristic
heuristics used VHPOP. asterisk (*) means solution found
generating 100000 plans. Flaws selected LIFO order.

3.2 Flaw Selection Strategies
original implementations SNLP UCPOP threats selected open
conditions. one threat (or open condition) selected,
one added last selected first (LIFO order). Several alternative flaw selection strategies
proposed attempt improve performance exhibited POCL planners.
Peot Smith (1993) show number searched plans reduced
delaying resolution threats. successful proposed delay strategies
DSep, delays threats resolved separation, DUnf,
delays threats resolved one way.
Joslin Pollack (1994) suggest flaws treated uniformly,
flaw least number refinements selected first. flaw selection
strategy, LCFR, viewed instance most-constrained-variable heuristic used
simple search rearrangement backtracking (Bitner & Reingold, 1975; Purdom, 1983).
main disadvantage LCFR computing repair cost every flaw incur
large overhead flaw selection. lead longer planning times compared
using default UCPOP strategy, even number search nodes significantly
smaller LCFR. clever implementation LCFR can, however, reduce overhead
flaw selection considerably.
Schubert Gerevini (1995) argue LIFO strategy selecting open conditions
helps planner maintain focus achievement particular high-level goal.
ZLIFO strategy variation DSep strategy, difference open
conditions cannot resolved, resolved one way, selected
open conditions resolved one way. Gerevini Schubert (1996)
present results indicating ZLIFO often needs generate fewer plans LCFR
solution found, smaller overhead flaw selection. results
413

fiYounes & Simmons

disputed Pollack et al. (1997). instead attribute much power ZLIFO
delaying separable threats, propose variation LCFR, LCFR-DSep, also
delays separable threats. Since chose work ground actions IPC3, separability
issue us.
3.2.1 Notation Specifying Flaw Selection Strategies
order better understand differences various flaw selection strategies,
simplify comparative studies, Pollack et al. (1997) proposed unifying notation
specifying flaw selection strategies. adopt notation slight modifications.
flaw selection strategy ordered list selection criteria. selection criterion
form
{flaw types}max refinements ordering criterion,
applies flaws given types resolved max refinements
ways. limit number refinements, simply write
{flaw types}ordering criterion.
ordering criterion used order flaws selection criterion applies to. LIFO
order used ordering criterion cannot used distinguish two flaws.
Pollack et al. define flaw types (open condition), n (non-separable threat),
(separable threat). also define ordering criteria LIFO, FIFO, R
(random), LR3 (least refinements first), New. last one applies open
conditions, gives preference open conditions resolved adding new
action. rest apply open conditions threats.
Flaws matched selection criteria, required completeness every
flaw matches least one selection criterion flaw selection strategy. flaw
matches earliest selection criterion, ordered flaws matching
criterion (according ordering criterion), flaw gets selected
flaw selection strategy. Note always need test flaws. If, example,
first selection criterion {n, s}LIFO, found threat, need
consider flaws selection.
Using notation, specify many different flaw selection strategies concise
manner. Table 3 specifies flaw selection strategies mentioned earlier. summary
flaw types recognized VHPOP, including three new flaw types defined below, given
Table 4.
3.2.2 New Flaw Selection Strategies
propose several additional flaw types ordering criteria, use combination previous ones obtain novel flaw selection strategies. Four
new flaw selection strategies used IPC3 contributed success VHPOP
event.
3. original notation ordering criterion LC least (repair) cost, repair cost
defined number refinements. introduce new ordering criterion based
heuristic cost, choose rename ordering criterion.

414

fiVHPOP

Name
UCPOP
DSep
DUnf
LCFR
LCFR-DSep
ZLIFO

Specification
{n, s}LIFO / {o}LIFO
{n}LIFO / {o}LIFO / {s}LIFO
{n, s}0 LIFO / {n, s}1 LIFO / {o}LIFO / {n, s}LIFO
{n, s, o}LR
{n, o}LR / {s}LR
{n}LIFO / {o}0 LIFO / {o}1 New / {o}LIFO / {s}LIFO

Table 3: flaw selection strategies previously proposed planning literature.
Flaw Type
n



l
u

Description
non-separable threat
separable threat
open condition
static open condition
local open condition
unsafe open condition

Table 4: Summary flaw types recognized VHPOP.
Early Commitment Flaw Selection. shown (Younes & Simmons,
2002) giving priority static open conditions beneficial planning
lifted actions. Introducing new flaw type, t, representing static open conditions,
specify flaw selection strategy follows:
Static-First {t}LIFO / {n, s}LIFO / {o}LIFO
static open condition literal involves predicate occurring initial
conditions planning problem, effects operator planning
domain. means static open condition always linked initial
conditions, initial conditions consist solely ground literals. Resolving static
q
open condition ai therefore cause free variables q bound specific
objects. Resolving static open conditions flaws represents bias towards early
commitment parameter bindings. resembles search strategy inherent planners
using ground actions, without necessarily committing bindings parameters
action once. gain reduced branching factor compared planner using
ground actions, reduction compensate increased complexity comes
keep track variable bindings.
earlier results (Younes & Simmons, 2002) indicated despite reduction
number generated plans planning lifted actions, using ground actions
still faster domains. gripper domain, example, using lifted actions
resulted less half number generated plans compared using ground
actions, planning ground actions still twice fast. greatly
improved implementation planner handling variable bindings since
then. using latest version VHPOP gripper domain, planner
415

fiYounes & Simmons

roughly fast planning lifted actions giving priority static preconditions
planning ground actions.
Local Flaw Selection. retaining LIFO order selecting open conditions achievable multiple ways, Schubert Gerevini (1995) argue planner tends maintain focus particular higher-level goal regression, instead trying achieve multiple
goals breadth-first manner. goals achieve independent, maintaining focus single goal beneficial. problem LIFO-based flaw
selection strategy, however, pointed Williamson Hanks (1996),
highly sensitive order operator preconditions specified domain
description.
necessary, however, select recently added open condition order
keep focus achievement one goal. get effect selecting
open conditions, restrict choice recently added action. therefore
introduce new flaw type, l, representing local open conditions. local open condition
one belongs recently added action still remaining open conditions.
use ordering criterion select among local open conditions. Using new
flaw type, specify local variant LCFR:
LCFR-Loc {n, s, l}LR
One would expect strategy less sensitive precondition-order simple LIFO-based strategy. see evidence Table 5, also shows
maintained goal focus achieved local flaw selection strategies help solve
problems compared global flaw selection strategy.
Heuristic Flaw Selection. Distance based heuristics used extensively
ranking plans state space planners (e.g., HSP FF). Nguyen Kambhampati
(2001) show heuristics useful ranking plans POCL planners
well. also suggest heuristics could used flaw selection methods,
elaborate subject.
hard see, however, many plan rank heuristics could used
purpose selecting among open conditions, since often based estimating
cost achieving open conditions seen Section 3.1.1. giving priority open
conditions highest heuristic cost, build plans top-down manner
goals initial conditions. call ordering criterion MC (most cost first).
using opposite ordering criterion, LC, would instead tend build plans
bottom-up manner. Note two ordering criteria apply open conditions,
threats, would need use combination selection criteria
threats. define global local heuristic flaw selection strategies:
MC {n, s}LR / {o}MCadd
MC-Loc {n, s}LR / {l}MCadd
subscript MC indicates heuristic function use ranking open conditions,
case additive heuristic.
416

fiVHPOP

Problem
DriverLog6
DriverLog7
DriverLog8
DriverLog9
DriverLog10
ZenoTravel6
ZenoTravel7
ZenoTravel8
ZenoTravel9
ZenoTravel10
Satellite6
Satellite7
Satellite8
Satellite9
Satellite10

UCPOP
/|| n
0.20 20
0.23 20
0.28 17
0.62
7
0.33 16
0.27 20
0.23
8
0.29 11
0.22 17
0.26 18
0.20 19
0.54
9
0.35
8
0.34
7
0.32
9

LCFR
/|| n
0.01 20
0.10 20
0
0.00 10
0
0.03
7
0
0
0
0
0
0
0
0
0

LCFR-Loc
/||
n
0.01
20
0.32
20
0.00
1
0.45
14
0.07
20
0.22
20
0.18
16
0.15
19
0.21
18
0.22
17
0.02
20
0.03
20
0.02
20
0.00
1
0.01
20

MC
/|| n
0.18 20
0.13 18
0
0
0
0
0
0
0
0
0
0
0
0
0

MC-Loc
/|| n
0.23 20
0.25 20
0
0.01 20
0.08 20
0.00 20
0.16 16
0.18 20
0.19 20
0.15 19
0.02 20
0.07 20
0.07
4
0.00
1
0

MW
/|| n
0.02 20
0
0
0
0
0
0
0
0
0
0
0
0
0
0

MW-Loc
/||
n
0.02
20
0.05
20
0
0.01
20
0.08
20
0.00
20
0.16
16
0.18
20
0.19
20
0.15
19
0.02
20
0.07
20
0.07
4
0.00
1
0

Table 5: Relative standard deviation number generated plans (/||)
number solved problems (n) 20 instances problem random
precondition ordered. Low relative standard deviation indicates low sensitivity
precondition order. Results shown VHPOP using seven different flaw selection strategies. memory limit 512 Mb enforced, hradd estimated
effort tie-breaker used plan ranking heuristic.

Section 3.1.3, proposed estimate remaining planning effort
open condition counting total number open conditions would arise
resolving open condition. heuristic could also useful ranking open conditions,
often discriminating ordering criterion based heuristic cost.
therefore define two additional ordering criteria: MW (most work first) LW.
these, define additional flaw selection strategies:
MW

{n, s}LR / {o}MWadd

MW-Loc

{n, s}LR / {l}MWadd

planning problems listed Table 5, see MW-Loc sensitive
precondition order MC-Loc, MW-Loc never performing worse MC-Loc
first two problems performing clearly better.
IxTeT (Ghallab & Laruelle, 1994; Laborie & Ghallab, 1995) also uses heuristic techniques guide flaw selection, quite different way suggested here.
understanding IxTeT heuristic estimates, possible refinement r resolving flaw, amount change (commitment) would result applying r
current plan. open conditions, estimate obtained expanding tree
subgoal decomposition, principal regression-match graph (McDermott, 1999).
similar heuristic values computed using additive heuristic. However,
IxTeT considers number actions need added resolve open
condition also degree current variable domains would reduced possible
action orderings restricted. Furthermore, IxTeT uses heuristic values choose
417

fiYounes & Simmons

flaw single refinement stands least costly compared
refinements flaw. intended effect reduction amount
backtracking needed find solution, although aware evaluation
effectiveness technique.
Conflict-Driven Flaw Selection. Common wisdom implementing search heuristics
constraint satisfaction problems, e.g. propositional satisfiability, first make decisions
maximal consequences, inconsistencies detected early on, pruning large
parts search space.
flaw selection strategy follows principle would link unsafe open conditions open conditions. call open condition unsafe causal link
open condition would threatened. giving priority unsafe open conditions,
planner direct attention possible conflicts/inconsistencies plan early
stage. introduce flaw type u representing unsafe open conditions. Examples
conflict-driven flaw selection strategies using new flaw type following variations
LCFR, LCFR-Loc, MW-Loc:
LCFR-Conf {n, s, u}LR / {o}LR
LCFR-Loc-Conf {n, s, u}LR / {l}LR
MW-Loc-Conf {n, s}LR / {u}MWadd / {l}MWadd
first two conflict-driven strategies effective link-chain domain
constructed Veloso Blythe (1994). link-chain domain artificial domain
specifically constructed demonstrate weakness POCL planners certain domains.
makes domain hard SNLP UCPOP default flaw selection
strategies open conditions achieved several actions one
action right choice negative interaction. forces POCL planner
backtrack excessively link commitments, inconsistencies may immediately
detected many link alternatives. see Figure 1 VHPOP using
UCPOP flaw selection strategy performs poorly link-chain domain. Using
sophisticated flaw selection strategy LCFR improves performance somewhat.
However, two conflict-driven flaw selection strategies problems solved
less second. number generated explored plans fact identical
LCFR-Conf LCFR-Loc-Conf, LCFR-Loc-Conf roughly twice fast LCFRConf reduced overhead. demonstrates benefit local flaw selection
strategies. Note, however, LCFR faster LCFR-Loc link-chain domain,
local strategies always superior global strategies.
also see Table 1 conflict-driven flaw selection strategies work well
DriverLog Depots domains, hadd hradd heuristic function ranking
plans.

4. Temporal POCL Planning
classical planning, actions duration: effects action instantaneous.
Many realistic planning domains, however, require actions overlap time
different duration. version planning domain definition language (PDDL),
418

fiVHPOP

(s)
UCPOP
LCFR
LCFR-Loc
LCFR-Conf
LCFR-Loc-Conf

100
80
60
40
20
0

1

2

3

4

5

6

7
8
9 10
Number goals

11

12

13

14

15

Figure 1: Average planning time ten problems point different flaw selection strategies link-chain domain. Results shown VHPOP using
five different flaw selection strategies. points strategy solved
ten problems without running memory (512 Mb) shown. hf
heuristic used rank plans.

PDDL2.1, used IPC3 introduces notion durative actions. durative
action represents interval time, conditions effects associated
either endpoint interval. Durative actions also invariant conditions
must hold entire duration action.
use constraint-based interval approach temporal POCL planning described
Smith et al. (2000), essence approach used earlier temporal POCL
planners DEVISER (Vere, 1983), ZENO (Penberthy & Weld, 1994), IxTeT
(Ghallab & Laruelle, 1994). Like IxTeT, use simple temporal network (STN) record
temporal constraints. STN representation allows rapid response temporal queries.
ZENO, hand, uses integrated approach handling temporal
metric constraints, make use techniques optimized temporal reasoning.
following description VHPOP handles type temporal planning
domains expressible PDDL2.1.
planning durative actions, substitute partial order representation plan STN . action ai plan, except dummy actions
a0 , represented two nodes t2i1 (start time) t2i (end time) STN
, compactly represented d-graph (Dechter et al., 1991). d-graph
complete directed graph, edge ti tj labeled shortest temporal
distance, dij , two time nodes ti tj (i.e. tj ti dij ). additional time
419

fiYounes & Simmons





0

1 0
7
4 3 0








(a)


0
1 0
7

4 3 0

1 0
4
5 4 0
(b)









0
1 0
7
2
6

6 3 0 5 1

1 0
4
5 4 0
(c)

Figure 2: Matrix representation d-graph, = 1, STN (a) adding action
a1 duration constraint 1 7 1 3, (b) adding action a2 duration
constraint 2 = 4, (c) ordering end a2 end a1 . Explicitly
added temporal constraints boldface.

point, t0 , used reference point represent time zero. default, dij =
6= j (dii = 0), signifying upper bound difference tj ti .
Constraints added addition new action, linking open
condition, addition ordering constraint endpoints two actions.
duration, , durative action ai specified conjunction simple duration
constraints ./ c, c real-valued constant ./ set {=, , }.4
simple duration constraint gives rise temporal constraints time nodes t2i1
t2i adding ai plan hA, L, , Bi. temporal constraints, terms
minimum distance dij two time points, follows:
Duration




Constraint
=c
c
c

Temporal Constraints
d2i1,2i = c d2i,2i1 = c
d2i1,2i c
d2i,2i1 c

semantics PDDL2.1 durative actions dictates every action scheduled
strictly time zero. Let denote smallest fraction time required separate two
time points. ensure added action ai scheduled time zero, add
temporal constraint d2i1,0 addition temporal constraints due duration
constraints. Figure 2(a) shows matrix representation d-graph adding
action, a1 , duration constraint 1 7 1 3 null plan. rows columns
matrix correspond time point 0, start action a1 , end action a1
order. adding action a2 duration constraint 2 = 4, d-graph
represented matrix Figure 2(b). two additional rows columns correspond
start end action a2 order.
temporal annotation {s, i, e} added representation open conditions.
q@s

open condition ai represents condition must hold start durative
q@e

q@i

action ai , ai represents condition must hold end ai , ai
invariant condition ai . equivalent annotation added representation causal
4. contrast, Veres DEVISER handle duration constraints form = c.

420

fiVHPOP

q@

links. linking open condition ai effect associated time point tj
gives rise temporal constraint dkj (k = 2i = e, else k = 2i 1). Figure 2(c)
shows representation STN plan actions a1 a2 , before,
effect associated end a2 linked condition associated end a1 .
Unsafe causal links resolved basically way before, instead
adding ordering constraints actions add temporal constraints time
points ensuring one time point precedes another time point. ensure time
point ti precedes time point tj adding temporal constraint dji .
Every time add temporal constraint plan, update shortest paths dij
could affected added constraint. propagation constraints
carried O(|A|2 ) time.
plan without flaws found, need schedule actions plan, i.e. assign
start time duration action. schedule actions solution STN
, solution assigning earliest possible start time action readily available
d-graph representation. start time action ai set d2i1,0 (Corollary 3.2,
Dechter et al., 1991) duration d2i1,0 d2i,0 . Assuming Figure 2(c) represents
STN complete plan, would schedule a1 time 1 duration 5 a2
time 1 duration 4. easily verify schedule indeed consistent
duration constraints given actions, a2 ends a1 required.
non-durative action treated durative action fixed duration 0,
preconditions associated start time, effects associated end time,
without invariant conditions. allows frictionless treatment domains
durative non-durative actions.
Let us moment consider memory requirements temporal POCL planning
compared classical POCL planning. planning non-durative actions, store
bit-matrix representing transitive closure ordering constraints O.
partial plan n actions, requires n2 bits. n durative actions, hand,
need roughly 4n2 floating-point numbers represent d-graph . floatingpoint number requires least 32 bits modern machine, total need
100 times many bits represent temporal constraints regular ordering constraints
plan. note, however, refinement changes entries
d-graph, choosing clever representation matrices share storage
plans. upper left 3 3 sub-matrix Figure 2(b) example identical matrix
Figure 2(a). way store matrices VHPOP allows us exploit commonality
thereby reduce total memory requirements.
addition durative actions change basic POCL algorithm.
recording temporal constraints temporal annotations handled manner
transparent rest planner. search heuristics described Section 3, although
tuned specifically temporal planning, used durative actions.
need slightly modify definition literal action cost additive heuristic
temporal annotations associated preconditions effects durative
actions. Let GAs (q) denote set ground actions achieving q start, GAe (q)
421

fiYounes & Simmons

Name
MW-Loc
MW-Loc-Conf
LCFR-Loc
LCFR-Loc-Conf

Specification
{n, s}LR / {l}MWadd
{n, s}LR / {u}MWadd / {l}MWadd
{n, s, l}LR
{n, s, u}LR / {l}LR

Table 6: Flaw selection strategies used VHPOP IPC3.
set ground actions achieving q end.

0
minaGAt (q) hadd (a@t)
hadd (q) =



define cost literal q
q holds initially
GAt (q) 6=
,
otherwise

{s, e} cost durative action endpoint defined
hadd (a@t) = 1 + hadd (Prec (a)).
Prec (a) propositional formula representing invariant preconditions preconditions associated start a, Prec e (a) formula representing preconditions a.

5. VHPOP IPC3
VHPOP allows several flaw selection strategies used simultaneously roundrobin scheme. lets us exploit strengths different flaw selection strategies concurrently, essential success VHPOP IPC3 since yet find
single superior flaw selection strategy dominates flaw selection strategies
terms number solved problems within given time frame. technique
use VHPOP supporting multiple flaw selection strategies essence
technique proposed Howe et al. (1999) exploiting performance benefits several
planners meta-planner. Although meta-planner slower fastest
planner single problem, solve problems single planner.
used four different flaw selection strategies IPC3 (Table 6), preferring local flaw
selection strategies tend incur lower overhead global strategies
LCFR MW often appear effective global strategies maintained focused subgoal achievement. four strategies selected initial
experimentation problems competition domains.
use multiple flaw selection strategies thought running multiple
concurrent instances planner, separate search queue maintained
flaw selection strategy used. Similar HSP2.0 planning competition
2000 (Bonet & Geffner, 2001a), use fixed control strategy schedule multiple
instances planner. first time flaw selection strategy used, allowed
generate 1000 search nodes. second time flaw selection strategy
used, generate another 1000 search nodes, making total 2000 search nodes.
subsequent round i, flaw selection strategy permitted generate
422

fiVHPOP

Name
MW-Loc
MW-Loc-Conf
LCFR-Loc
LCFR-Loc-Conf

Order
1
2
3
4

STRIPS Limit
10000
100000
200000


Durative Limit
12000
100000
240000


Table 7: Execution order flaw selection strategies used IPC3, also search limits
used strategy domains without durative actions.

1000 2i2 additional nodes. maximum number nodes generated using specific flaw
selection strategy 1000 2i1 rounds. optional upper limit number
generated search nodes set flaw selection strategy. useful flaw
selection strategies typically solve problems quickly, solve within
reasonable time. Table 7 shows search limits used VHPOP IPC3. limits
determined initial trials competition problems. Note
set search limit last flaw selection strategy. Whenever three strategies
reached search limits without found solution, LCFR-Loc-Conf used
physical resource limits reached.
Table 8 shows number plans generated STRIPS Satellite domain
solution found four flaw selection strategies used IPC3, also number
generated plans combining four strategies using schedule Table 7.
better understand round-robin scheduling works, take closer look
numbers problem 15. Table 9 shows total number generated plans divided
rounds flaw selection strategies. Note although MW-Loc actually
best strategy problem, stopped already round 5. total number
generated plans exactly match actual number generated plans reported
Table 8. consider suspending use flaw selection strategy
refinements last selected plan added, limit round
exceeded slightly practice. numbers Table 9 represent idealized situation
flaw selection strategies switched number generated plans exactly
matches limit current round.
VHPOP solved 122 problems 224 attempted IPC3. quality plans,
terms number steps, generated VHPOP generally high. plain
STRIPS domains, VHPOPs plans typically within 10 percent best plans found
planner competition, 28 VHPOPs 68 STRIPS plans least
short best plans found and, POCL planner, VHPOP automatically exploits
parallelism planning domains, generating plans STRIPS domains low total plan
execution time (Table 10). Table 11 shows VHPOP also performed well terms
number solved problems four six STRIPS domains, competitive top
performers MIPS LPG (particularly Rovers domain).
423

fiYounes & Simmons

Problem
1
2
3
4
5
6
7
8
10
11
12
13
14
15
16
17
18

MW-Loc
118
229
172
738
448
636000
571
482000
1245
1172
3517
6241
2352
74738
533000
2975
1584

MW-Loc-Conf
118
229
172
843
723000
629000
745
874
1178
1172
3733
382000
2352
444000
529000
2975
1584

LCFR-Loc
118
249
172
822
1018
720
620
1017
1323
1172
525000
559000
2157
107375
3442
3438
1724

LCFR-Loc-Conf
118
249
172
1797
706000
834
688000
783
1275
1172
525000
544000
2157
465000
3571
3438
1724


118
229
172
738
448
2727
571
1874
4283
4172
9542
18265
8365
281387
13471
8981
4588

Table 8: Number generated plans STRIPS Satellite domain four different
flaw selection strategies used VHPOP IPC3. rightmost column
number plans generated VHPOP finding solution using
schedule Table 7. dagger () means planner ran memory
(800 Mb) generating least indicated number plans.

Round
1
2
3
4
5
6
7
8
Total

MW-Loc
1000
1000
2000
4000
2000
10000

MW-Loc-Conf
1000
1000
2000
4000
8000
16000
32000
36000
100000

LCFR-Loc
1000
1000
2000
4000
8000
16000
32000
43375
107375

LCFR-Loc-Conf
1000
1000
2000
4000
8000
16000
32000
64000

Total
4000
4000
8000
16000
26000
48000
96000
79375
281375

Table 9: closer look round-robin scheduling problem 15 STRIPS Satellite
domain. Italic entries indicate search limit flaw selection strategy
reached round.

424

fiVHPOP

Domain
DriverLog
ZenoTravel
Satellite
Rovers

# Solved
14
13
17
20

# Steps
1.09
1.04
1.07
1.08

# Best
5
7
7
7

Execution Time
1.15
1.20
1.25
1.08

# Best
4
5
5
13

Table 10: Relative plan quality STRIPS domains VHPOP solved
half problems. two plan quality metrics. Number steps
simply total number steps plan, execution time total
time required execute plan (counting parallel actions one time step).
table shows average ratio VHPOPs plan quality quality
best plan generated planner, number problems domain
VHPOP found best plan also shown.

Planner
FF
LPG
MIPS
Simplanner
Stella
VHPOP

Depots
22
21
10
22
4
3

DriverLog
15
18
15
11
10
14

ZenoTravel
20
20
16
20
18
13

Satellite
20
20
14
17
14
17

Rovers
20
12
12
9
4
20

FreeCell
20
18
19
12
0
1

Total
117
109
86
91
50
68

Table 11: Number problems solved top performing fully automated planners
STRIPS domains.

domains durative actions5 , total execution time given explicit plan
metric, objective minimize metric. specification explicit plan
metric feature PDDL2.1 present earlier versions PDDL. VHPOP currently ignores objective function always tries find plans steps,
come surprise quality VHPOPs plans domains durative actions
significantly worse quality best plans found (Table 12).6 VHPOP
still produced plans steps, however, 60 percent VHPOPs plans
domains durative actions fewest steps. plan selection heuristic
VHPOP uses tuned finding plans steps, would need modified
order find plans shorter total execution time. Table 13 shows LPG solved
far problems domains durative actions, VHPOP competitive
MIPS clearly outperformed TP4 TPSYS.
5. two types domains durative actions IPC3: SimpleTime domains actions
constant duration Time domains durations functions action parameters.
results durative actions presented paper SimpleTime domains currently
support durations functions action parameters VHPOP. would, principle,
hard add support though, expect future versions VHPOP it.
6. poor performance part also due use 1 (see Section 4) VHPOP,
planners used 0.01 less. Using 0.01 VHPOP reduces total execution time plans
15 percent.

425

fiYounes & Simmons

Domain
DriverLog
ZenoTravel
Satellite
Rovers

# Solved
14
13
17
7

# Steps
1.04
1.04
1.04
1.04

# Best
8
10
9
5

Execution Time
1.50
1.54
2.51
1.39

# Best
0
0
0
0

Table 12: information Table 10, domains durative actions.
Planner
LPG
MIPS
TP4
TPSYS
VHPOP

Depots
20
11
1
0
3

DriverLog
20
15
2
2
14

ZenoTravel
20
14
5
2
13

Satellite
20
9
3
2
17

Rovers
12
9
4
4
7

Total
92
58
15
10
54

Table 13: Number problems solved fully automated planners domains durative
actions.

VHPOP top performer IPC3 terms plan quality, far
top terms planning time. VHPOP typically orders magnitude slower
fastest planner. high planning times VHPOP part attributed
implementation details. Improvements code (e.g. using pointer comparison instead
string comparison whenever possible) since planning competition resulted 10
20 percent lower planning times using ground actions using lifted actions
planner twice fast before. reachability analysis still bottleneck,
however, improvements could definitely made there. important
remember, though, basically run four planners using four flaw selection
strategies concurrently. Table 14 shows average relative performance VHPOP
IPC3 compared performance VHPOP using best flaw selection strategy
problem. VHPOP best flaw selection strategy average two three
times faster VHPOP four concurrent strategies. Using several flaw selection
strategies simultaneously helps us solve problems, price reduced speed.
intelligently scheduling different flaw selection strategies depending domain
problem features, using fixed schedule problems, could potentially
increase planner efficiency significantly.

6. Discussion
McDermott (2000) finds absence POCL planners first planning competition
1998 striking, planners dominating planning research years earlier. seems doubtful arguments [POCL planners] favor wrong,
would interesting see partial-order planners compete future competitions, McDermott writes. two competitions without POCL planners, believe VHPOPs
performance IPC3 demonstrates POCL planningat least ground actions
competitive CSP-based heuristic state space planning. VHPOP also shows
426

fiVHPOP

Domain
DriverLog
ZenoTravel
Satellite
Rovers

STRIPS
2.52
2.76
1.78
2.32

Durative
2.66
2.86
2.01
3.37

Table 14: number table represents average ratio planning time
VHPOP using four flaw selection strategies concurrently planning
time VHPOP fastest flaw selection strategy.

temporal POCL planning made practical using heuristic techniques
developed classical planning. idea using POCL paradigm
temporal planning new goes back least Veres DEVISER (Vere, 1983),
first demonstrate effectiveness temporal POCL planning larger set
benchmark problems.
hope success VHPOP IPC3 inspire renewed interest plan
space planning, made source code VHPOP, written C++, available
research community online appendix others build effort.7
VHPOP performed well expectations IPC3, see several ways
improve planner. Speed, mentioned Section 5, principal
weakness VHPOP. code reachability analysis satisfactory, currently generates ground action instances performing reachability analysis.
often leads many ground action instances generated preconditions
finite heuristic cost (according additive heuristic). believe VHPOP
could profit code reachability analysis well-established planning systems
FF. could also improve speed better scheduling different flaw selection strategies.
would like see statistical studies, similar Howe et al. (1999), linking domain
problem features performance various flaw selection strategies.
far considered using different flaw selection strategies. However, running multiple instances VHPOP using different plan selection heuristics could equally
interesting. have, example, noticed using additive heuristic without accounting reuse helps us solve two problems Satellite domain. would also
interesting FF heuristic implemented VHPOP see well performs
plan space planner, possibly using local search techniques instead . likely,
however, results local search topology FF heuristic state space (Hoffmann, 2001) carry plan space. many benchmark planning domains
contain actions whose effects undone actions, plan operators causing
transitions search space plan space planner different actions defined
planning domain, effects plan space operator generally irreversible.
would likely need add transformational plan operators undo linking
ordering decisions. Incidentally, VHPOP started project adding transformational plan operators UCPOP, got side-tracked need better search
7. latest version VHPOP available download www.cs.cmu.edu/lorens/vhpop.html.

427

fiYounes & Simmons

control, research transformational POCL planning suspended.
recent improvements search control POCL planners, may worthwhile
consider adding transformational plan operators.
addition considering different search control heuristics, could also instances
VHPOP working lifted actions instead ground actions. Recent improvements
code significantly reduced overhead maintaining binding constraints,
making planning lifted actions look considerably favorable reported
earlier work (Younes & Simmons, 2002). Planning lifted actions could beneficial
problems high branching factor search space due large number objects.
would also like see support numeric effects preconditions future versions
VHPOP. would make VHPOP fully compatible PDDL2.1. also
mentioned need plan ranking heuristics better tailored temporal planning,
VHPOPs performance terms plan execution time domains durative
actions approach performance best temporal planners IPC3.

Acknowledgments
effort sponsored Defense Advanced Research Project Agency (DARPA)
Army Research Office (ARO), contract no. DAAD19-01-1-0485. U.S.
Government authorized reproduce distribute reprints Governmental purposes
notwithstanding copyright annotation thereon. views conclusions contained
herein authors interpreted necessarily representing
official policies endorsements, either expressed implied, DARPA, ARO,
U.S. Government.

References
Bitner, J. R., & Reingold, E. M. (1975). Backtrack programming techniques. Communications ACM, 18 (11), 651656.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90 (12), 281300.
Bonet, B., & Geffner, H. (2001a). Heuristic Search Planner 2.0. AI Magazine, 22 (3), 7780.
Bonet, B., & Geffner, H. (2001b). Planning heuristic search. Artificial Intelligence,
129 (12), 533.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism planning. Proceedings Fourteenth National Conference Artificial
Intelligence, pp. 714719, Providence, RI. AAAI Press.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49 (13), 6195.
Gerevini, A., & Schubert, L. (1996). Accelerating partial-order planners: techniques
effective search control pruning. Journal Artificial Intelligence Research, 5,
95137.
428

fiVHPOP

Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal
planner. Hammond, K. (Ed.), Proceedings Second International Conference
Artificial Intelligence Planning Systems, pp. 6167, Chicago, IL. AAAI Press.
Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). formal basis heuristic determination minimum cost paths. IEEE Transactions Systems Science Cybernetics,
SSC-4 (2), 100107.
Hoffmann, J. (2001). Local search topology planning benchmarks: empirical analysis.
Nebel, B. (Ed.), Proceedings Seventeenth International Joint Conference
Artificial Intelligence, pp. 453458, Seattle, WA. Morgan Kaufmann Publishers.
Hoffmann, J., & Nebel, B. (2001). FF planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Howe, A. E., Dahlman, E., Hansen, C., Scheetz, M., & von Mayrhauser, A. (1999). Exploiting competitive planner performance. Biundo, S., & Fox, M. (Eds.), Proceedings
5th European Conference Planning, Vol. 1809 Lecture Notes Computer
Science, pp. 6272, Durham, UK. Springer.
Joslin, D., & Pollack, M. E. (1994). Least-cost flaw repair: plan refinement strategy
partial-order planning. Proceedings Twelfth National Conference Artificial
Intelligence, pp. 10041009, Seattle, WA. AAAI Press.
Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings Thirteenth National Conference Artificial
Intelligence, pp. 11941201, Portland, OR. AAAI Press.
Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Mellish,
C. S. (Ed.), Proceedings Fourteenth International Joint Conference Artificial
Intelligence, pp. 16431649, Montreal, Canada. Morgan Kaufmann Publishers.
McAllester, D. A., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
Ninth National Conference Artificial Intelligence, pp. 634639, Anaheim,
CA. AAAI Press.
McDermott, D. (1999). Using regression-match graphs control search planning. Artificial Intelligence, 109 (12), 111159.
McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2),
3555.
Nguyen, X., & Kambhampati, S. (2000). Extracting effective admissible state space
heuristics planning graph. Proceedings Seventeenth National Conference Artificial Intelligence, pp. 798805, Austin, TX. AAAI Press.
Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Nebel, B.
(Ed.), Proceedings Seventeenth International Joint Conference Artificial Intelligence, pp. 459464, Seattle, WA. Morgan Kaufmann Publishers.
Penberthy, J. S., & Weld, D. S. (1992). UCPOP: sound, complete, partial order planner
ADL. Nebel, B., Rich, C., & Swartout, W. (Eds.), Proceedings Third
International Conference Principles Knowledge Representation Reasoning,
pp. 103114, Cambridge, MA. Morgan Kaufmann Publishers.
429

fiYounes & Simmons

Penberthy, J. S., & Weld, D. S. (1994). Temporal planning continuous change.
Proceedings Twelfth National Conference Artificial Intelligence, pp. 1010
1015, Seattle, WA. AAAI Press.
Peot, M. A., & Smith, D. E. (1993). Threat-removal strategies partial-order planning.
Proceedings Eleventh National Conference Artificial Intelligence, pp. 492
499, Washington, DC. AAAI Press.
Pollack, M. E., Joslin, D., & Paolucci, M. (1997). Flaw selection strategies partial-order
planning. Journal Artificial Intelligence Research, 6, 223262.
Purdom, Jr., P. W. (1983). Search rearrangement backtracking polynomial average
time. Artificial Intelligence, 21 (12), 117133.
Refanidis, I., & Vlahavas, I. (2001). GRT planning system: Backward heuristic construction forward state-space planning. Journal Artificial Intelligence Research,
15, 115161.
Schubert, L., & Gerevini, A. (1995). Accelerating partial order planners improving plan
goal choices. Proceedings Seventh International Conference Tools
Artificial Intelligence, pp. 442450, Herndon, VA. IEEE Computer Society Press.
Smith, D. E., Frank, J., & Jonsson, A. K. (2000). Bridging gap planning
scheduling. Knowledge Engineering Review, 15 (1), 4783.
Veloso, M. M., & Blythe, J. (1994). Linkability: Examining causal link commitments
partial-order planning. Hammond, K. (Ed.), Proceedings Second International
Conference Artificial Intelligence Planning Systems, pp. 170175, Chicago, IL.
AAAI Press.
Vere, S. A. (1983). Planning time: Windows durations activities goals. IEEE
Transactions Pattern Analysis Machine Intelligence, 5 (3), 246267.
Weld, D. S. (1994). introduction least commitment planning. AI Magazine, 15 (4),
2761.
Williamson, M., & Hanks, S. (1996). Flaw selection strategies value-directed planning.
Drabble, B. (Ed.), Proceedings Third International Conference Artificial
Intelligence Planning Systems, pp. 237244, Edinburgh, Scotland. AAAI Press.
Younes, H. L. S., & Simmons, R. G. (2002). role ground actions refinement
planning. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings Sixth
International Conference Artificial Intelligence Planning Scheduling Systems,
pp. 5461, Toulouse, France. AAAI Press.

430

fi
ff
fi
! #"$ %
'&)(*,+-(**.0/21 .354'166

789:; <)*30=
*.!>@?9 %&<A1 (0=
*.

BDCAEFEHGJILKNMPORQ
SUTVTXW

YPZ[A\U]_^,`ba2^Jcd^,egfh)f2i0jAelkmcRZonpjgqr`tsufvh)fvi0jge

wyzNx {}|~dLz)zN

d2dffff$dA$N

$oL0
;0ud
;0
mv0}@
55@N#@

)}2N
v0Pg8vgJ#,)}#-@R@g52Rg5;-@0P$ff
5;
-0!d}80gP}@5P;@A50dd)505v PP}ff
-@5 8@,}m;gP55P5ff!-@u!
5088}!ub-@P588@

mN0858;@0P}5@$
2t };,N

ff
fi$}
@}$8fifi
@fi

fi}A}$ $$$
fi
"!#8%$5&fi
'$fi$( }))*%+,
'fifi.-/0
'1*%
"+324fit}3
5fi
@$
@3+6}}87
$ff
924fi u5*9ff
',

'2:+0 6
*;}$
* 6<fi$ fi=>$ ?@
@
@
8Afi +6 }$
'>
}$B2"AA
'0
fi A1C $ A@

;Dfi
%+6 }$
'> 2E
AF-;/4t

}J =fiAmfi
@AGfiC *3*%@
&fi
H*%

0fi


'?fi$ fiI2J@
&fi% Kfi Lfi


"fi
}$ ff
O'N @QP RESTT!U $WVXA 0 }6'
Yfi

C *;*%@
KfiZ&fi [fi
'
Yd+ fi'\Bfi

5fi@
> }$]fi
@t
* fiA^ fi _R0fi

>$
=*}
0 ) ' *;t
* Nfi fiA*%
}$@ '>@
1NR }3fi
G
.fi
" }$$ ff
" ;fi

*%+,
'fifi _
u}$

` 3aMb<cedf c ff b<c Yg 2Fvh
R
/0
J( }$60ig*i
>+fim}$$ff
R( iGiPLjR#2R
'^
+,
@ fi
@8ff
k>
+0 l
*3 }$ }>fi6*3m}]k*%@
} D6_ *%+ >?Ln+,
' >
* }
m8vR }$Yt
*
9+ff
'A?7
AA1Ofi okp+0 q^5

]Nr *3t
* l
U $0fi fi 3+0 6A
*3IHfi
ut"$v(=w&7yxzL( } B)) Kfi
fim
NF{Y'i"
'
* fifi'RJSTTTKU -|(JiP
}j3v ~2E@
[D@
fi
9 r
* 5*9,
'

8?fi +6 }$
'>'R1
'fi

1 >6
'Jfi .fi
" } ff
42
@@ %fi
*%+,
'fifi .\t
* fiA1fi
Gw5fi>A+6;}$;tP
L7

'fiP @24fi|fi15+ff
-A@
fi>


*3'R,0D
'fi1C fi &fi'Rv}$u
8+
>Y
'^ fi
2E
'

fi6
@.#R } fi$ A1 $.Vfi
*
@Afi Kfi |fi
;( iGP
p5'6*%@
Km
fi Efi
;
$ *I7
+,
'fifi LNr '>5'RlSTTj~U )- fi
Gfi *%+,
'fifi _R56 }&fiJ
8fi@
E2J
'
&fi0 @

'?$

j-4*%
' AG6@
&fiNr }$6fi Zfi 3v N@
}Z6@
&fi U
S5-4tfi 424fi
fi
!5-4t"6Afi 1;+l }*%
'fi>A'
-) Kfi 5 4>$ }

/0
&fi0 N6fi 4fi

M@
fi>
+6+ff@
>@
[fi C,

@
[51Bfi)2 B
* e>fi
'> 8\%2"
'fi
'
fi
I36rF
fi
G
5fi@
> M,
fi0fi@
u'@
1 }$Z2"
'fi
'=fi
'1M,2 @@
6
Gfi



l

#

(**. N %% !<5

#

&0%% 0<

fi

ffff$


@ 3kp
@AAfi?%+06A
*3m8-u))*%+6fi0fi$ >
'fi6
'
*%
@fiC^
M+61
@


'90A
-C$
$
'
@_R2"A
fiIfi
MfiA*%
0fi
Z fi9*%+,
'fifi.RJw5fi>+lm}$et"iP+l}$$
2E
'
2J
?.$ $
'>fi }$
'^
' _ *3+6fi0fi$++0
0$}Z,
'
@
'^
+,
@.Rfi
fi
*%+,
'fifi LD@
fi@
L
8fi@
Gfi$

fi A*%@
Lfi +6

@&
fi
'2D fi $AAfi
4fi fi
'2) }K1

'v+ fi@
I+6 }$
'> I$ }$6
-{
+>
'A
1R246A
J *3+60fi fi $ +6+0 >
nJ @

24fiU
&*3
'>A6@
Kfi }$ fi @24fiU
fi 63$^
C,
'@
]fi @
@*3
|fiA*%
eND
- -R
5

'R jxxz594 &0fi }@
PK$ Afi'R jxxx5 .

* }$_R"STTS5m
v >A
CPG$ R jxx5
w8*3AfiPB
.Rjxxx5I} >.R4{ >A'R{|>
'fifi 8R0PA q }_RSTTT8g A*P
v
'R
STTj~U R_+ + A0
@
;24fi 6fi >1+6 }|*3
'fi>A'P}$C Kfi 5 G $ }
%$ ^
I,
'@

*
9
' @
2"fi


* }&fiA'0fi }24fi *%+l0fi fi [ND
- -R,{|'i
'>t
* fifi'R.STT!U w5
'fifi
'2o $ A@

4Zfi
>*
*

@

' fi15+,
+l }$ $90fi 80A

01
}$Yv
+ fi^
fi
96
.dR Afi Yfi
'u

>
fiP2E
AF-4t"$+6 }$6 R6AA
9t"$0fi
vRlAg
6 ZX

'+6$ }&fi'VR }$+ }
0 3>*A_ *3*$ Afi1ZAv$ $Zfi 3,
*%
9~y
2 }$ufifi
'>@




@ >
'% N5bb
fi L
JR
$ fi9fi
Mfi>$ l;R }$ Cfi fi9fi
M0fi AF
- 8'IA
A*%v+ 0fi }&fi'R }; 5'6J@fi
4 >A'J?<
'^@
Mt
*
GA*%v+ 0fi }&fi"Nr
'
fi
4+ }
EMw8tn/^8
"
*%+6
,
- -GE
'
Pw8A
* .RffSTT!U -t &fi 5 Dfi4 |fi
;X+60 6
*fi @,
90^@
.VR
24?
4q24 @
&
"
'8 Z =t
*
Gv+ ~2E
'r6t
*
A)}$++6?A fi J*1 Ab
'fi
'
fi
''* fi tl q24@

fi$ fi<?;

01I >6
'^5 +0 }>
'-n/0
=fi }>fi
w8tno
/ }$)0w8(H @
D0 *fi
@fi fi
@
ff,2 ;fi N;
* }&131@
>=lfi fi
'1;,2 @$ ~^

+0 61I0fi @
Z
* }K13
*
R,fi

G *3*9 fi
J$}$.VfiJ
'+)fi 8',;fi
" >A0+ 6
*3
fi3,
^@
_
'24A
R8>
A@

E*%
6ff
'>@
Kfi='
)}$M*%P



*
"d A0fi } fi
'>'- {
7
~^
'~R*%
3
* ~1|,
I2J
?7
' @
C

* }&fiA AA1u6P
fi fi *%+60fi fi $A1-4- -R Z2E

8+,
fi

'rv }$@

'8 _ *%+60fi fi $_*%
'fi =fi$ fi424AAl,2 >@ 9lB3r FqC{ fi0A
A1
fi'm
\ } ++0 O0fi l
>@
> $fit

}<24Afi *3 A** &6*,
'
fi 'R
* 1
fiI,

} e %@
Lfi

}2"fi*; A**
>
>*%+fi %24fi L
* 7
*r
* 5*9ff
'
}N '-@/4

;
* ~1B,
; *%+6
'fi
A1 ff
'@
&fi *%+l0fi fi $ +0 6
*;G
'^@

=fi


>A+fi [? ^
'1O?*3A @ND
- -R.fi fi v fi9
'+6 ' $ } }fi O>O51
*fi+6?A fi |>Y Yfi
fir$ fi ) ZA @
+0 } *MU - $y, @+l }$
'G }L0fi 8
3
@


'>?4+ 6
*3'RK2J
G 3+0 61I,
"+ff
)fi v fi fi
G5$ Afiyt
1 .fi
0Afi Jfi $'R
*tfiA1@A
A1R8AfiEA*~^8 0
*
Afi @fi %fi


8fi9ff8CNrF-
-R24fi

fiA
* fi
+l }L
fi U -3w8A*3A >1R62"A
fi fi>fi
P^@
L51|fi
%* ) fi B fi+60 ~^8


A*3+6m

}$++60 >$ lu

@

' A@ fi J' +6 }$ dR } }$ }}P}$Afi^
fi>W7
fi
32"A> fi Z fi
'+,@
$$,fi
1 @fiP

fi M6fi ?u@fi
W
@2"A>;fi

fi @A;
R5An
'
61
*
@'fi'-g *%
1R&fi
@'fi1 $6 +6 }

*
$ }@
.R6fiGfi
$

@'fi1Y L $ }NN
+fiA
* +6 }G@

R24fi$ P
fi }
+> >
4
fiA
* fi >R$
A=v$ @fi @
'
*%+6
'fi
+6 }Dfi
'A }fi
'~, Fr zl z5@~l#{z&<dou~d#{K#z {
/0
L}fi 5*%
'>AM6
@Kfi}sfiA*%
us(JiGigS5-Aju?O
@>6
Z*t~^
Yfi$fiA*;%fi
>+ 8 fi
0
@fi

Afi
@&fi 5*,
'J.+l}$
'>0ND
--R#
"P$A_Rljxx5lw8*3fi
PB
.Rffjxxx56 ;
',fi F-RSTTTKU - AA
0fi'VXfiJ+v6A
fi
8+
,6fi>1I6fi&fi
,
'fi2E
'@
fi g}$l G^ 6
GY*%

nfi

+6 }$
'>'Rfi
9 AD fi $AAfi
1 }$
*%+60fi fi $< $ A@

u
3fi
'>
-Mgt OA*%v+ 0fi }&

fi *3A>B O*91L^5A
'2AGfi

l
@


>q


fiJGG K8#}Cff=)lq}d

8+6AA'fi@8 >"
'+dfi
Z0*FfiH+
}$e+fi$fi6'-B0

%H>
@6A
}$*%
;+l }$ $Z15fi
*;@ND
- -RnA8 'R jxzz5=)=>A
;P
/ fi
R=jxx8jE +fiAfi
RR( +ff
RP
fi@
.R8STTj~U

@Mfi
'fi
'>*;
fi

'^
v E l'8W'l'Mfi$ fiAA q2J@
+ 6
*0- -R_AJ%)2
'>t

~^ 6
vR }$Cfi
'b


9Z0fi 8fi$ fiG
5
IS;)2
'>
@ .R.fi@
fi
* fi=P

! ,fi

"0fi 5E}3,

8
'fi@
Z '>@
Kfi1- fi
'24A
RKfi
0
>

'@
@
3

'@

fi
+ 'fiy1-[/0?9A}H
*%+6
C*96fi7 + 'fiy1R @

')2 6A
@
0>
) fi
'Ifi15+ff
b

>

u *3t
* ND
- -R= $1O
0>
'RE
* l
Z
>
R
'fi~U -H5$ s(JiGgi S5-AjR

>
P
'@
Cfi M,
9@
N@
5*%
'>? 6@
&fi'Rv}$Yfi
%1N&0fi <fiu

+,
' fi >Gfi0
*%A

ff
'@
;v+ &^@
Kfi 6Nrt
* >
v finfiA,
q2U R
'fi
'>*;
fi
4A
'^
ff 6'@
1
q2J@

_-<5$ *91Z^5A
'2 RfiA
>fi$ $fi
0fi
'
>@
'\
21
8 WrF>RE,

u
5+lAA'fi

3}Q,
Z
5+lfi
@Q*%+lfi0fi$AA1 B
fifi
@
'#&*3
'>A6
@&fi0}.Vfi'R

36rF>R",

C
8+6AA'fi;
>
M+~^8
}o'$&fi'>
@1Qfi$fiZA
>A*%+6
}$'A
@}.Rn*%
'fi$|fi$fiI}$fiI,
@0 vfifi
@>* 4'>
@1O
(JiGigHS5-AjG+6+l}.R}$
lWyffrDRff
6
%
5+lAA'fi"
>
R24fiYfiA*%
R+0~^8
fi
t$fi8#
@
'7
?@fiL}$|$6fi +6}$}$u
@?
'fi"0fi0fi424Afifi
fi4A>
-J4
>

9
@fi @
&fi0 fi

'^
6'@
1
*tB0
fi 5'\uA4
8+6AA'fiA1 ' *3t
* $fi@
fi
u }$ ff
REfi
'1 .Vfi3$ ~^
ufi ++,@
3
fi C+u

"v+ fi fi ufi

}FA- $>
>

@ @
46@
Kfi'Rfffi

+v+ fi

fi>
-</0
4
fiJA<fi$ fi'R$ 6
n
0>

fi
* fiA A13 @
KfiA@
%5
1
* }$18A'R
+> =*%
> }A*3}$ q2J
'v $ $2
'^
+ff@
$ }$A J>
>
END
- -R v >
RSTT!U
}.Vfi0,

@.

'24A
Rfi


' 6fi " '@
61O [fi
' *30

9A9fi }+@
&fi'-Ct
'
fi
fi J
};,

5
'fi@
@ '>@
Kfib
1 fi fi?*%
Alfi
>
>
,
'@
@
%519fi

fi ,
fi

8
'@
9fi
J d+ 'fim
1 ~^ ? 6
fi -<P
fi
fi
'$ }$.R# (JiP
S5-AjR 9 +l+6 }.Rqfi


'^
N 6 '@
1?
' @
A*%+6A?'fi1" fi
'>*;#lfi
" 6
6+)
}$v+ fi $fi '-
$
+l+6 }.R& =
*%+6
R8fiy,2 t+,
' fi >}Z,
"
5
'fi@
| '@
&fi1;A.fi
'1 _VfiE &fi
'D
'

24fiO@
> fi
'<F-
-R
&
uu
fi

'fi
;+>
$fi 6P9v+ fiA^
%
ff
fifi

fi
'( iGP
S5-Aj
5fi@
$6fiA
'd fi t5*,
' )2 ~15'R60fi 5 $3 Kfi ' Kfi0fi

fi
fi }$Mfi
&fi
'
^ ?~^
'0246A>M+
fi =$~^
fi %,
G+

'^@
_J- 4A*3+6AA'fiy1RK$WVXA
5' +6+6 }.VXfi 6'@
1 1RA@
^8 %fi


5fi@
>
) 6
'0fi
= 5>5" > }$ufiu
)

fi 4u#5KNrl>qU }uu#5&Nr6>q5U4fi$ fit
* ~^b


6 8uZD0 *Gfi Mu
}$|M
+ff
fiA^
1-)=@
1R6fi

ufi G}$$fi4,u


9 '>@
KfiA1
6 8%
}$fiJ,
0t
* ~^@
@fi fiy,2 b,
'@
&Jfi
fi $fi Jfi fi
"0*%
4fiA*%
-n/0
't
1
4 $
'@

*fi
: +l+6 }}'N }$( iGP
S5-Aj~U Zvfi$ ^
e+>
$fi Nr# Nr6>'UU@fi$ fifi
'1


'fi
-;<
'fi'R24K1L6

'fi $L+

$6fi } fi Y+6
'^@
K
fi } fi KD0 *
,

8
'fi@
'@
&fi1%fffi
fi MIfi
v

'fi
Jfi
0+6
$fi lZ/0
fiA6 fi
4fiAAfi 6'@
1u
'^
',
'@
u
* }
9
5+6?A'fi'-E5$ YG +6+6 }ufi02 A}$+fi@

,

;Afi @
>
fi$
fi
'> AA@ fi u
'u
fi '@
&fi'RR ++6AA lt

fi >

*
++6?A
6

}$H18
Hfi
u0*3

fiuNr=A*P >fi'RGjxxU -Q<
'fi'R=24&1H efi?%0*%

>fi
' Z,
fi

* fi4 &^@
@
&fi" Ifi>1M '@
&fi4
'fifi &
>



fi

ffff$

) 6
' ~2Hfi)
fi u#5KNrl>qU }$u#8KNr>>_U24A
)
gfi Kfi
'>
'
}R }$9fi5


'
*%
@3'>
@Kfi'-n/06AAJ
fi,*%+6fiIfi*
4A6fi
5*9,
';l0vfiJ>*;<A
@'
@KfiA1
R&6fi A<6
fifi
'24A
- .
4fi
4
@N6}@,
08
@351+l18
24fi;fig

+ff
'8 fi >'8
- -R 3fi
"+>

@g
9>
*R&fi
G~v5'q6~v5'3@
6 N )2
+0 q^5
Jfi
= >
Jfi *3+fi l '@
1R2"A
E fi
+

@
lfi
'
>*3'R>A*3A

@ R&t
*
4 &}^ ^@
.R&,2 6 %,
0v+ l)
J2E
AF-5$ }&13
R5fi
' $ &)fi , 6'@
1

@ fi Z &fi
'
'>@
g

'd @
; Z +6+6 }}@(JiP
OS5-AjG >A
J
'0fi M?*%+6AA'Afi
6*%+fi ,}$Mfi
G&
fi @? 24
'fi
'J2E
)
2 }&fi=fi
*
fi$
g>*%+fi 'R}@2"
'fi
'
fi
'
1
@
0$6

fi'/0b

' Ku
fi E '@
1Y
@ B>
>
A*
%fi }+d@
Kfi LfiAG
@
R }$
*
9
>AfiA9

* fi C 9 *%+6fi $MD@
l
9+l }*t
%
8+6A?'fi'-9/0

' $ Ku
fi
1
+0 q^5
t}NN

'


6?Afi1R fi $ u u
'0fi | &fi
5fi}$fi0>
'+6
fiu


'@


* >m

@

' fi8 KfiIND
- -R,fi M1ufi$ fi0 v Afi *34}$$fi A?

G }$gfi
'fi"fi N
'
qU

%MO b<cH ff
c
R
/0
ufi>A<( iGiPsS5-Aju
I*tfi^fffi
@Y&1fi
u} k'@fi
m+C,
'fi2E
'
@Y+l}$$


@ >b
}$b++6A? fi m8-w
fi
'1 }$fi 6@
,
++lAA fi R~fi
'1 +6

* l1*%@
}
fi$ fi"fi
'1)2 }&fi"(JiGgi sS5-Aj9fi @$ ~^

}Y 6@


|+l }$ $>

@>>_Rfft
* q^5 ;fi ~)2 ~1uD0 *
fi~1
* 6fiq)2 H>@
AAfiA ++6A? fi '-|A
Z } 8p
fiIfi Lt
* ~^
Zfi ~2 H@
?AfiA
++6?A
fi 'R51
'fi'R$Jfi ffRfi'VX
'rfffi %
'
'+| Z*3 @fi fiGXfi ~
1
* 6'V5 ^

'>^@
Zfi
t4$
(< 6
*Nw A^5 $Z *;*9$ 6fi1L^
'1B2E
AF\wA $@+6'
B"
>?fiA;w5@
> .Rfi
8 7 fi
'@

B)
) fi8 Kfiw fiA'fi .R.= 88 > L |(J }$ R6
'fi- /0
'1u$ ^
I+0 q^5 @
| 8''R2}$

'+fi A1>A*%+6
M+0 l
*3Ifi$

fi
u *3+60fi fi $?1 $ A@
%2J
?F-s/0AI*3- HA
&^@
@
&fi @
&fiD15 $E?*%+6
6fi,v+ ~2E
'r @
\
>?fiA
fiA

* fi >Rq+ fifi
'8 m$0fi
'R
fi8 Kfi+60 + fffi }$ , fi &fi'R$}$0t.-n$ ,

'^
GfiA=2)fi

8 R8D0 *
fiA+,
'>+ff
fiA^
R24
'fi
'J fi ~1I+0 6A
*A
0= 88n > 3?
8$ 6fi@
.-$yfiJ'@
>1
*
<
};+
'RK6fi $ ~^
42E
"@
8 @
%fi 90^
0fi
"+0 6
*}2E
AFR5 tm$
* 87
'+,@
$@
&fi' ff
$vP
$fi'R2J
C
* 1s,
|fi?A0*3A>O*3
|r$ $$*%@
&0fi 0 @
3fi$ fi
YAA
1Hfi [,

'@
@

>A
'0
'fifi $A%D@
fi> 3 *%+6
&fi
' fi 0ff
'fiy2J
'@
fi +6

}$v+ fi $6fi 'w8 +0 l
*3
[
* fiLDfi@
&fi 0fi 6
R1
'fiCfi
[+ff
'> >
* }
+o,
'fi2E
'@
@

'
+6 }
'>}$+,
' AA'@
:0^
'>Z

* 0
Rfi
++6?A 6AAAfi1 +6 }$ [fi
$ }1
24A?>

* OA?*3fi@
.-%/05246A
%fi A+vAfi^

}$

>01Lfi
*
;0 * B( iGP
o}$
fi
G( } 9)) *3+ff
'fiAfi 3
*
G *%+6
3+6 }$ }$ ff
}$@0fi 5R5$n,
AA
'^
4fi$ fi=fi
AA0

0>1Mfi @ @
&fi1 }$u
* &0fi LI 8'u*3

*%+l0fi fi $.+60 6
*3/0
; *%+,
'fifi }$[fi9+v+ fi }$ ff
? ^
@

@>
'>}$O+6 fi7
fi
' } @
fi
fi0fi

fi

.\24$ fi8 $ +0 6
*;E}uff

*
@
}$0^@
.R
24$ fi"5 $ }$C'u

<+0 l
*30}C,
9A^@
|2E
AFRl24$ Afi +6+0 >
"2)u,
fig}$Y24@
.R
}$ A0Z$
~2' fi q2fi
%
LAG+60 }
-9( 0 }
*%@
}6,
'fifi
' Afi 6B

fiA*%
R }9l u}fi .ffR *3*3fi*%@
&fifi P+fiA
* AAfi1 A*}
R+60 }
*%@
}*t>
Jv+ ~2E
'r

"!$#%'&)(+*-,.%0/#2134 65 #%'&7(*8 :9;*<:#=> *?&A@0B54C/:>@D/71EA1F@G*?/ HI@G5 #KJ @0/<LM/ *<%JE/& :*-HN &7
@0/ A1EA1;5'L;@0& %E*I#2(?9;%D=+2EE'O @G' E@0P1;&:#A@0 C5 #%'&7(*:RQIE8/:*<JE#SI*$P@D@0#2#PE:*<8@G& %E*IHN#2#
54C9"JE)T3-U9;#2@0/#SL'4 6@0/9V&A@GW54C</A@0A1W@0*X@Y/ *<%JE/& K@GP1ME:F@G##R@G& %E*?/AZ'J S/ 6@0/9[HN#2#
54?/:@0/71A1M@G*N96JE T\ &
>



fiJGG K8#}Cff=)lq}d

@0"+>$0
'4+>fifi
9
@ >|+
90D
1}$
,
fi^
1- ( /0
*3+ff
'fiAfi

I' <$ ~^
0 Kfi>A6fi@
Ifi fi

}?'R}$% fi?21R5$ ^
" Kfi>A6fi
@Ififi
=+0}>

fi

}$Zfi ;Afi=
*%+6>?
0 $ - w5fi?AFR& >
@,
G0fi @
u%fi fi0fi


>
}s,


~2 e0 * Dfi
*3+ff
'fiAfi t%2E
AF-et ?@>
&A
*%@
&fiI fi
+

@


+v~2E
'r6t
*
}$ ff
=6>
=(JiP
OS5-AjRA fi
'd+ fi
"fi
" >Ar$ fi $?fi
<&fi
,
'@

&fi0fi >5@fi$ fi4+l }$
'>Au

$fi4
'2 @
1Z51fi
" q^
' ff
R_6fi A@&1u q2
2E
A=fi
'1 H@
]' "0fi 8'-]t=fi;fi
u0*%
ufi?*%
ufi%)2 H,

'r=fi Afi A>
fi >5Efi$ fiE
'
fi=
* fi
"

@> M0 *fi >5Efi$ fiE@
fi
">

@>>
fi };@
13fi0ff
- gt $
+ +l $4fi
G 7
* ~^8 70fi 0
'fi<
V fi
0@
}bfiA'
RK$fi fi$ fin2J
0>
* &0fi
fi
3 8'[fi
uX >A%+0 l
*3Gfi|,
;0^@
.V }$[
Afi fi
;t"$0
3fi Ct
* ~^
Ofi
'2
+0 l
*30NL4fi

> $ff+0 6
*;=ff
Zfi ; ff-

] _c ^pc c

c
'>5'RE-4NFSTTj~U -s/0
uSTTTOt"$9(J}$Lw518fi
*3;)*%+,
'fifi.-a`r bJ'FCc 6Ded5lW
f[+dKE gDffNR h3hNF!U +fiAfi
Rn(-RnR( +ff
R )R- <-R<P fi@
.R-0NFSTTj~U j
- inrp6l km#'>a
nl >8DK dKo"`=lK
inWrD6C p=D dII du nl 8K dp=KA -E A&2J
'~E
'
R i- <-R P
wAt
* .R <- NFSTT!U /0
w8t"/7T! ) *%+,
'fifi .&fifi+_\q20242 -X>F-DW4 qG>At
* l# &fi
fiT!q
6fi
=A*Rt9-R#P >fi'R#{O-8NpjxxU - $fi+6 } Efi0 +6 }$ +6
}$A15?'-5$ Bpp~ >>DK
rscGtIiN`scGkAu\vR++-,+j w4! wxl+j w#KS5-{ 0 }Y r* }$.)=>>
Rl3-RP#/ fi
R_t9- Npjxx8j~U -;"7+6 }.\./0u

+,@
L+6 } >fi
fi

- `GWr bJ'F c 6'z k
d5lW8R v4hNpj~U RffKx x54z w5ffRJ{[-R<P
Rni-4NFSTT!U -H( iGP
S5-Aj\ gt e
5fi@
>Hfi B( iGP
%
8+
>Cfi
*%v+
+l }$ $
* '-{t8 l: rs`sc}|4W'> -=/0A=A>
gA*R(-RP
2
'R-NFSTTj~U -B4
AfiA%+l }$ $24fiOfi?*%
}[
0>
'-u
$ ~p=
8p V
in+ r'''l IA rsp=DK dlWiNp{kD4#R++_-_jS8Gj xlj!S5A,
* }.R=-NFSTTSU -J 5fi@
$6 Rfi 5*%
'>? 4fi0fi
Lff^ > 6
-5$ p= : rC
\v
8p V
in+ r'''l
`Wr bJr c lD d&'l
lWiN`scGkA h+qR++_-65Gj x55 6.Rt-RnL
}
{ >>A'R(-Rn{|6
'fifi 8Rn-RnP q0 }.R3-ENFSTTTKU -B( } u &fi
'+6 }
'0fi >1
+
\6/0
>1 }$u+ fiA
-<
$ ppE `scAp{n_k h\\R++_-_j~+ xlj4z w55

'Rn-0NpjxxzU -s( }$ C$ $
'I
0>
fi Kfi'-5$ ppE : r
4 =8pW
in+ r'''l 3 `cWiN`scGkAu4>qR6++_-8Kzx xKKx!5-,:AA
'1v
>A
R(-4NFSTT!U -]t }>Afi*3;+0 + fffi $B
>
u 6fi &fi%st"$+6 } }$
>>@
6A C- `r bE'F$ c 6'e d5lW R 'RRj8Gj xljzz5v
>A
R#(-RKPG$ _R{[-6NpjxxU -l(J }$ 424Afi>$ 6
E
>
nfi Kfi'-
$ %{u
?AA.R
)G-Nr .-U $R pp~ 8cGtiN`scGk:u\vR++_-_+j w#K! xl+j w#Kx5-_L
{ }Y

* }.

+$UE@De:#SLE /"9;:@G * P@DX@0-#2:@G*lX%G "%GOE9Y@G#*<%#JE%F*"408O/J EA134E2*?JP@D/7@G':62*? %G? ::1EA1MHN
?%OE9Y@0#2SzL}/:Z+JES/:9;:'* 1/%OEO4A13
>E

fi

ffff$

{Y'i"
' *tfifi'Ri-.NFSTTTKU -n/0
jxxzIt"$ ( }$Iw515fi
*3=)*%+,
'fifi.-?`GWr bJ'F_c 6Ded5lW
f[+ dKE gDffNR hNFSU R.! x54 w5{Y'i"
'
* fifi'Ri-JNFSTT!U -;/4
>
* n

* }&fiA'E+0 8

L(JiP
-%5$ ppE cPiN`p;n_kDP
Y0 q WH pCMMR8++_-6z+ x5x#4 K0fi }@
_R-RP$ $ fi'R59-_NpjxxxU - *%
'>Afi0fi
ff^ > l
JM 6fi &fip7
@Z+6 }$
$ ppE
=8 >V
in+ rff
p6 dlWiNp;k:u\u>qR++-_j'Tx xljS8jw8*3Afi.Ri-R P B
.R<i-0NpjxxxU -s/
*3+ 8 J+l }$ $|24fiH*fi$ E
'Ae@
0 -O
$
pp~ 8cGtiN`scGk:u\uR++_-6!4S wx5!!&A8 'R#i9-6NpjxzzU - pp~rr p6 d3oR ff d9 G'#>Wr `sc8 dI-_{[-
r
* }$.-

>~


fiJournal Arti cial Intelligence Research 20 (2003) 291-341

Submitted 10/02ff published 12/03

Metric-FF Planning System: Translating \Ignoring
Delete Lists" Numeric State Variables
Jorg Homann

Institut fur Informatik
Georges-Kohler-Allee, Geb. 52
79110 Freiburg
Germany

hoffmann@informatik.uni-freiburg.de

Abstract

Planning numeric state variables challenge many years,
part 3rd International Planning Competition (IPC-3). Currently one
popular successful algorithmic techniques STRIPS planning guide search
heuristic function, heuristic based relaxing planning task ignoring
delete lists available actions.
present natural extension \ignoring delete lists" numeric state variables,
preserving relevant theoretical properties STRIPS relaxation condition
numeric task hand \monotonic". identify subset numeric
IPC-3 competition language, \linear tasks", monotonicity achieved preprocessing. Based that, extend algorithms used heuristic planning system
FF linear tasks. resulting system Metric-FF is, according IPC-3 results
discuss, one two currently ecient numeric planners.

1. Introduction
planning community long aware fact purely propositional representation languages, particular STRIPS (Fikes & Nilsson, 1971), well suited
modeling various phenomena essential real-world problems. particular,
modeling context dependent e ects, concurrent execution actions di erent duration,
continuous resources awkward, impossible, within STRIPS language.
overcome
rst limitations, Pednault (1989) de
ned (nowadays widely accepted) ADL language, amongst things allows conditional e ects (e ects
occur condition holds true state execution). overcome
(one of) latter two limitations, various proposals made (e.g., Ghallab
& Laruelle, 1994 Koehler, 1998 Smith & Weld, 1999). recent e ort direction PDDL2.1 language de
ned Fox Long (2002) input language
3rd International Planning Competition (IPC-3). IPC series biennial challenge
planning community, inviting planning systems participate large scale publicly accessible evaluation. IPC-3 hosted AIPS-2002, stressed planning beyond
STRIPS formalism, featuring tracks temporal numeric planners. article
describes approach behind one planners participated IPC-3, Metric-FF.
Metric-FF extension FF system (that handle ADL) numeric constructs.
Currently one popular successful algorithmic techniques STRIPS
planning guide search (forward backward, state space plan space) heuristic
c 2003 AI Access Foundation. rights reserved.

fiHoffmann

function, heuristic based relaxing planning task ignoring delete
lists (i.e. negative e ects) available actions. heuristic value search
state framework (an estimate of) diculty extending state solution
using relaxed actions. idea
rst, independently, proposed McDermott
(1996) Bonet et al (1997), widely used huge number variations.
Examples planners use idea Unpop (McDermott, 1996, 1999), HSP
various con
gurations (Bonet & Ge ner, 1998, 1999, 2001), GRT (Refanidis & Vlahavas,
1999, 2001), MIPS (Edelkamp & Helmert, 2001), STAN4 (Fox & Long, 2001), RePOP
(Nguyen & Kambhampati, 2001), Sapa (Do & Kambhampati, 2001), FF (Ho mann,
2000 Ho mann & Nebel, 2001). search paradigms used planners include
forward backward state space search well partial-order planning. forward
state space planner FF especially successful IPC-2 (Bacchus, 2001). follows
extend heuristic idea STRIPS, ignoring delete lists, numeric state variables
way preserves relevant theoretical properties STRIPS relaxation.
phrase properties admissibility, basic informedness, polynomiality.
investigation takes place setting forward state space search used FF,
seems likely ideas also work search schemes plan-space
search (some outlook, Section 8). Sapa system also deals
numeric constructs. heuristic function, however, completely ignores numeric goals
thus lacks one relevant theoretical properties, basic informedness (we return
later). also numeric versions MIPS GRT. respective MIPS
version publication available time writing article (Edelkamp,
2003), reader referred to, appear JAIR special issue.
numeric version GRT, GRT-R (Refanidis & Vlahavas, 2000), allows restricted
form numeric variables expressions, basically limited form resource allocation
consumption. heuristic function considers resource consumption another form
state cost. This, like Sapa's heuristic, lacks basic informedness, see later.
numeric planning task, numeric constraints (in action preconditions
goal) numeric e ects (in action e ects). Constraints e ects
di erent types. example, constraint require value variable either
least high high given constant. numeric e ects can,
semantic perspective, either increase decrease value ected variable. Now,
delete e ects STRIPS decrease logical value propositional variables, idea
explore relax numeric task ignoring decreasing e ects. main diculty
idea ignoring decreasing e ects necessarily simplify task.
example, goal requires x < 0 x initially equal 0, decreasing
e ects needed solve task, relaxed task unsolvable. relaxation thus
adequate (preserves theoretical properties mentioned above) tasks
always preferable higher variable values. call tasks monotonic.1 observe
tasks belong subset numeric IPC-3 competition language, linear tasks
(in numeric variables used linear functions), brought
1. duality respect ignoring increasing eects decreasing eects.
lower variable values always preferable ignoring increasing eects adequate relaxation.
Whether one chooses one seem make much dierence. choose monotonicity
positive sense conceptually simpler.

292

fiTranslating \Ignoring Delete Lists" Numeric State Variables

normal form monotonic. Based that, extend heuristic algorithms used
FF, thereby whole system, linear tasks.
FF (Ho mann & Nebel, 2001) close relative HSP (Bonet & Ge ner, 2001). Search
takes place forward state space, i.e., starting initial state new states
explored goal state found. search process FF guided heuristic
function based solving, search state s, relaxed task starting s.
heuristic value number actions respective relaxed plan, i.e.,
number actions needed achieve goal assuming delete lists
empty. States lower heuristic value preferred. main obstacle extension
FF numeric state variables extend machinery solves relaxed task
search state. machinery de
ned, rest system translates
e ortlessly. evaluate resulting planning system Metric-FF discussing results
numeric domains used 3rd International Planning Competition. turns out,
Metric-FF LPG (Gerevini, Saetti, & Serina, 2003a) best performing numeric
planners competition.2
article structured follows. Throughout text refer related work
relevant.
rst give necessary background terms STRIPS notation,
techniques STRIPS version FF uses. Section 3 introduces notation
numeric state variables, i.e., numeric subset PDDL2.1. Section 4 describes
heuristic principle STRIPS, relaxation, extended numeric setting.
Section 5 de
nes algorithms solving relaxed numeric tasks. Section 6
lls
details relaxed plans used implement Metric-FF planning system,
briey describe ADL constructs handled, exible optimization
criteria taken account. IPC-3 results discussed Section 7. Section 8
concludes outlines future work. appendix contains proofs.

2. STRIPS Techniques
section, give background techniques FF system uses STRIPS
language. start examining relaxation underlies FF's heuristic function.
proceed algorithms used solve relaxed tasks.
nally describe
relaxed plans used implement actual FF system. discussion
little detailed would strictly necessary understand FF workings.
serves provide solid background come: Sections 4, 5, 6 will, turn
subtopics dealt section, show methodologies
extended numeric setting.
start, give notation STRIPS language. refer sets
mean
nite sets. consider propositional STRIPS language, constructs
based logical propositions. world state set (the true) propositions. action
given triple proposition sets, = (pre(a) e (a)+ e (a); ): a's precondition, add
list, delete list, respectively (we use somewhat unusual notation e (a)+ e (a);
makes extension numeric variables readable).
2. C source code Metric-FF available free download FF homepage
http://www.informatik.uni-freiburg.de/~hoffmann/ff.html.

293

fiHoffmann


rst specify semantics world states actions. Throughout article,
consider sequential planning only, single action time applied world
state.3 Actions induce state transitions follows. Given world state action
a, result executing (the action sequence consisting solely of) s, result(s hai),
result(s hai) := n e (a); e (a)+ action applicable s, pre(a) s. Otherwise,
result(s hai) unde
ned. result executing action sequence ha1 : : : state
recursively de
ned result(s ha1 : : : i) := result(result(s ha1 : : : am;1 i) ),
result(s hi) = s.
STRIPS task { use word \task" rather \problem" avoid confusion
complexity theoretic notion decision problems { tuple (P G):
set P logical propositions used task, set actions, initial state (a
world state), well goal G (a partial world state, see below). propositions
actions, initial state, goal taken P . Given task (P G), one
wants
nd plan. action sequence ha1 : : : 2 plan (P G)
G result(I ha1 : : : i). Since relation (not equality) used here, could
several goal states plan ends. exists least one plan task,
task solvable. Sometimes refer optimal plans. sequential framework, plan
optimal task plan task contains fewer actions.

2.1 Relaxing Strips Tasks

want inform search plan function estimates goal distance
search states. idea de
ne relaxation (i.e., simpli
cation) planning tasks,
solve, search state, relaxed task, take length relaxed solution
estimate long solution state hand really is. relaxation

rst proposed McDermott (1996) Bonet, Loerincs, & Ge ner (1997),
relax STRIPS tasks ignoring delete lists actions.

Denition 1 Assume STRIPS task (P G). relaxation a+ action 2 A,
= (pre(a) e (a)+ e (a); ), dened
a+ := (pre(a) e (a)+ ):
relaxation (P G) (P A+ G), A+ := fa+ j 2 Ag. action
sequence ha1 : : : 2 relaxed plan (P G) ha+1 : : : a+n plan
(P A+ G).

Ignoring delete lists simpli
es task action preconditions goal
positive. identify number desirable properties relaxation has.
later de
ne relaxations numeric variables properties.

Denition 2 Let RPLANSAT denote following problem.

Assume STRIPS task (P G). relaxation (P G) solvable?

3. opposed to, e.g., Graphplan-based approaches (Blum & Furst, 1997), nd sets actions
applied parallel.

294

fiTranslating \Ignoring Delete Lists" Numeric State Variables

Proposition 1 relaxation given Denition 1 adequate, i.e., following holds
true.

1. Admissibility: plan solves original task also solves relaxed task,
i.e., assuming STRIPS task (P G), plan (P G) also relaxed
plan (P G).
2. Basic informedness: preconditions goals trivially achieved
original task holds relaxed task, i.e., assuming
STRIPS task (P G), hi plan (P G) hi relaxed plan (P G), 2 A, result(I hi) pre(a)
result(I hi) pre(a+ ).
3. Polynomiality: relaxed task solved polynomial time, i.e., deciding
RPLANSAT P.

proof trivial { admissibility basic informedness follow directly
de
nitions, polynomiality proved earlier Bylander (1994). proof
found Appendix A.
want use length relaxed plans heuristic function, properties
stated Proposition 1 important following reasons. Admissibility tells us
optimal relaxed plan length admissible heuristic, since optimal real plan also
relaxed plan.4 Also, mistake solvable state dead end:
relaxed plan real plan either (more below). \only if" directions
basic informedness tell us relaxation give us constraints free
(for example, heuristic value zero goal states). heuristic
properties possibly parts problem must solved regions
heuristic information (like heuristic value already zero
goal state reached yet).5 Polynomiality tells us compute heuristic
function eciently.

2.2 Solving Relaxed Tasks

Ideally, given search state s, would like know many relaxed actions least
needed reach goal, i.e., would like know length optimal relaxed
plan (this would admissible heuristic, c.f. above).
nding optimal relaxed plans
still intractable (Bylander, 1994). instead compute arbitrary, i.e., necessarily
optimal, relaxed plans. done Graphplan-style algorithm (Blum & Furst,
1997 Ho mann & Nebel, 2001). Given search state STRIPS task (P G),

rst build relaxed planning graph starting s, i.e., task (P G).
extract relaxed plan graph. graph building algorithm depicted
Figure 1.
4. Note using term \admissibility" way slightly abuses notation, admissibility usually refers
property heuristic function, technique (relaxation, case) based on.
5. formulation basic informedness might seem unnecessarily complicated. chose general
formulation hand de nition easily transferred relaxation techniques, like
ones introduce later.

295

fiHoffmann

P0 :=
:= 0
G 6 Pt
:= fa 2 ASj pre(a) Pt g
Pt+1 := Pt a2A e
(a)+
Pt+1 = Pt fail endif
:= + 1


endwhile

finallayer := t, succeed

Figure 1: Building relaxed planning graph task (P G).
planning graph relaxed case simply represented sequence P0 A0 : : :
At;1 Pt proposition sets action sets. built incrementally obvious
fashion, starting P0 = initial layer, iteratively inserting add e ects
applicable actions. algorithm fails point reaching goals
new propositions come in. happens relaxed task unsolvable.

Proposition 2 Assume STRIPS task (P G), state s. algorithm depicted
Figure 1 fails, relaxed plan (P G).

proof Appendix A. main argument that, two consecutive proposition
layers identical, hold true later layers graph reached

xpoint.
case goals reached layer finallayer, call relaxed plan extraction
mechanism depicted Figure 2. level proposition p (action a)
rst
layer relaxed planning graph p (a) appears, i.e., minimum
p 2 Pt (a 2 At).


:= 1 : : : finallayer
Gt := fg 2 G j level(g) = tg

endfor
:= finallayer : : :
g 2 Gt

1

select a, level(a) = ; 1, g 2 e
(a)+
p 2 pre(a)
Glevel(p) = fpg

endfor
endfor
endfor

Figure 2: Extracting relaxed plan task (P G) (levels finallayer computed
algorithm Figure 1).
Relaxed plan extraction based sequence G1 : : : Gfinallayer goal sub-goal
sets. Goals sub-goals always inserted set respective level, i.e.,
296

fiTranslating \Ignoring Delete Lists" Numeric State Variables

position
rst appearance relaxed planning graph. goal sets initialized
inserting respective (top-level) goals. backwards loop selects, layer,
actions support respective goal set. goals sub-goals g supported,
preconditions respective actions become new sub-goals. way, upon termination
selected actions used form relaxed plan state hand.

Proposition 3 Assume STRIPS task (P G), state algorithm

depicted Figure 1 reaches goals. actions selected algorithm depicted
Figure 2 form relaxed plan (P G).

goals sub-goals supported, arranging actions selected layer
arbitrary order yields relaxed plan. proof Appendix A.

2.3 FF

Based relaxed plan information, heuristic state space planner easily implemented.
Choices must made use relaxed plans, arrange search strategy. describe speci
c methods used FF, ecient many STRIPS
ADL benchmarks (Ho mann & Nebel, 2001). extended system uses straightforward adaptions methods. de
ne heuristic function, search strategy,
pruning technique. heuristic estimates goal distances relaxed plan length.

Denition 3 Assume STRIPS task (P G), state s. FF heuristic value

h(s) denedPas follows. algorithm depicted Figure 1 fails, h(s) := 1.
Otherwise, h(s) := finallayer
jAt j set actions selected layer
t=1
algorithm depicted Figure 2.

relaxed plan state, heuristic value set 1.
justi
ed
rst property proved Proposition 1: relaxed plan
real plan either, i.e., state dead end sense goals
reached it. states pruned search. search scheme
use kind hill-climbing procedure using complete lookahead
nd better states.
See Figure 3.
Enforced hill-climbing, like (standard) hill-climbing, starts initial state
performs number search iterations trying improve heuristic value,
state zero value reached. normally, iterative improvement done selecting
one best direct successor current search state, enforced hill-climbing uses complete
breadth
rst search
nd strictly better, possibly indirect, successor. search cuts
states seen earlier iteration, expand states
heuristic function recognizes dead ends. strategy works well
better successors usually nearby, case many planning benchmarks
using FF heuristic function (Ho mann, 2001, 2002b). better successor
current search node, algorithm fails (more below).

nally de
ne pruning technique, selecting set promising successors
search state. unpromising successors ignored. promising successor
state generated action helpful following sense.
297

fiHoffmann

initialize current plan empty plan <>
:=
h(s) 6= 0
starting s, perform breadth rst search state s0 h(s0 ) < h(s),
avoiding repeated states using hash table,
expanding states s00 h(s00 ) = 1
state found fail endif
add actions path s0 end current plan
:= s0
endwhile

output current plan, succeed

Figure 3: enforced hill-climbing algorithm, task heuristic h.

Denition 4 Assume STRIPS task (P G), state algorithm
depicted Figure 1 reaches goals. set helpful actions H (s) dened

H (s) := fa 2 j e +(a) \ G1 6= g
G1 set sub-goals constructed layer 1 algorithm depicted Figure 2.

words, action considered helpful achieves least one lowest
level goals relaxed plan state hand. helpful actions information used
pruning technique. breadth
rst search iteration enforced hill-climbing,
expanding state s, states generated actions H (s) included
search space. Note states relaxed planning graph reach
goals h(s) = 1 get expanded anyway.
general, neither enforced hill-climbing helpful actions pruning maintain completeness. algorithm fails enforced hill-climbing gets caught dead end state.
happen search backtrack decisions, heuristic
function return value 1 dead end state. algorithm also fails helpful
actions pruning cuts important states, happen technique
non-admissible approximation usefulness. deal issue employing safetynet solution, i.e., enforced hill-climbing fails planner starts scratch using
complete heuristic search engine, without pruning technique. search engine used
Russel Norvig (1995) term greedy best-rst search. weighted strategy
weight wg node cost equation f (s) = wg g(s) + wh h(s) wg = 0,
i.e., search simply expands search nodes increasing order goal distance estimation.
Repeated states avoided obvious way keeping hash table visited states.

3. Numeric State Variables

introduce notation numeric part PDDL2.1 language (i.e., PDDL2.1 level
2) de
ned Fox Long (2002), used IPC-3. restrict STRIPS
readability reasons. Extensions ADL summarized Section 6.2. sets
assumed
nite unless stated otherwise.
298

fiTranslating \Ignoring Delete Lists" Numeric State Variables

addition propositions P , set V numeric variables. Notationally, say V = fv1 : : : vn g (throughout article, n denote number numeric
variables). state pair = (p(s) v(s)) p(s) P set propositions
v(s) = (v1 (s) : : : vn (s)) 2 Qn vector rational numbers (the obvious semantics
p(s) true propositions, vi (s) value vi ).6
expression arithmetic expression V rational numbers, using
operators +, ;, , =. numeric constraint triple (exp comp exp0 ) exp
exp0 expressions, comp 2 f<
= ff >g comparator. numeric e ect
triple (vi ass exp) vi 2 V variable, ass 2 f:= += -= = /=g assignment operator, exp expression (the e ect right hand side). condition pair
(p(con) v(con)) p(con) P set propositions v(con) set numeric
constraints. e ect triple (p(e )+ p(e ); v(e )) p(e )+ P p(e ); P
sets propositions (the add- delete-list), v(e ) set numeric e ects
6= j (vi ass exp) (vj ass0 exp0 ) 2 v(e ).7 action pair (pre(a) e (a))
pre(a) condition e (a) e ect.
semantics language straightforward. value exp(v) expression
exp variable value vector v (in s, v numeric part v(s) state s)
rational number expression simpli
es replacing variables
respective values, unde
ned division 0 occurs. constraint (exp comp exp0 ) holds
state s, written j= (exp comp exp0 ), values exp exp0 de
ned s,
stand relation comp other. condition con = (p(con) v(con)) holds
state s, j= con, p(con) p(s), numeric constraints v(con) hold s.
value (vi ass exp)(v) numeric e ect (vi ass exp) variable value vector v (in s,
v numeric part v(s) state s) outcome modifying value vi
value exp s, using assignment operator ass. numeric e ect applicable
value de
ned. e ect e = (p(e )+ p(e ); v(e )) applicable
numeric e ects v(e ) applicable s. e s, e (s) state
s0 p(s0) = p(s) n p(e ); p(e )+ , v(s0 ) value vector results
v(s) replacing vi (s) (vi ass exp)(s) (vi ass exp) 2 v(e ). Putting
de
nitions together, result executing action state result(s hai) =
e (a)(s) j= pre(a) e (a) applicable s, unde
ned otherwise.
rst case,
said applicable s. action sequence ha1 : : : i, result(s ha1 : : : i)
usual de
ned recursively result(s ha1 : : : i) = result(result(s ha1 : : : an;1 i) )
result(s hi) = s.
numeric task tuple (V P G) V P variables propositions
used, set actions, state, G condition. sequence actions
ha1 : : : 2 plan result applying yields state models G,
result(I ha1 : : : ani) j= G.
algorithmic framework, make distinctions di erent degrees expressivity allow numeric constraints e ects, i.e., di erent numeric
6. ignore, readability reasons, possibility given Fox Long's original language
variable unde ned value assigned one. methodology easily extended
{ fact implemented { deal case.
7. Fox Long (2002) make assumption implicitly, requiring outcome action
well-de ned { note commutative eects variable merged.

299

fiHoffmann

languages. numeric language tuple (Cons E -ass E -rh) Cons possibly

nite set numeric constraints, E -ass set assignment operators, E -rh
possibly
nite set expressions. task (V P G) belongs language constraints, assignment operators, e ect right hand sides members respective
sets.
next three sections contain technical part article. organized
follows.

1. Section 4 provides theory Metric-FF's heuristic function based.
relaxation, ignoring delete lists described Section 2.1, extended numeric
variables. Section 4.1 formalizes key idea restricted numeric language,
states extended relaxation ful
lls admissibility, basic informedness, polynomiality. Section 4.2 abstracts restricted language, identifying generalized
semantic properties make relaxation work. Section 4.3 introduces
language linear tasks, brought linear normal form (LNF)
semantic properties. Metric-FF's core planning algorithms implemented
LNF tasks.
2. Section 5 introduces algorithms implemented Metric-FF's heuristic function.
algorithms extensions relaxed Graphplan methods described Section 2.2. Section 5.1 describes algorithms restricted language, Section 5.2
extends LNF tasks. state formally algorithms complete
correct. also see algorithms are, theory, less ecient could
be. number relaxed planning graph layers built exponential
size task encoding, contrast polynomiality relaxation proved
Section 4. reason implementation lags behind theoretically
possible implementation work done theory fully developed. However, practical point view, least debatable important
potential exponentiality (the number relaxed planning graph layers built
bounded length shortest relaxed plan). Exploring issue depth
topic future work. details Sections 4.1 5.1.
3. Section 6 details relaxed plan information used implement Metric-FF
system. Section 6.1 explains extension basic FF architecture described
Section 2.3. Section 6.2 explains extension ADL, Section 6.3 describes
exible optimization criteria dealt with.

4. Relaxing Numeric State Variables
show relaxation technique STRIPS naturally extended numeric
context. proceed three steps outlined above.

4.1 Restricted Language

key idea relaxation becomes apparent one considers context
constraints compare variables constants via ff >, += -=
300

fiTranslating \Ignoring Delete Lists" Numeric State Variables

e ects, e ect right hand sides positive constants. formally, restricted
language is:
( f(vi comp c) j vi variable comp 2 fff >g c 2 Qg
f+= -=g
fc j c 2 Q c > 0g )
STRIPS, delete lists troublesome falsify propositions might
need preconditions goal. restricted numeric language here, -= e ects
troublesome diminish value ected variables. idea therefore
ignore e ects.

Denition 5 Assume restricted numeric task (V P G). relaxation a+
action 2 A, = (pre(a) (p(e (a))+ p(e (a)); v(e (a)))), dened
a+ := (pre(a) (p(e (a))+ f(vi += exp) j (vi += exp) 2 v(e (a))g)):
relaxation (V P G) (V P A+ G), A+ := fa+ j 2 Ag. action
sequence ha1 : : : 2 relaxed plan (V P G) ha+1 : : : a+n plan
(V P A+ G).

relaxation adequate restricted language, precise sense introduced Section 2.1.

Denition 6 Let RESTRICTED-RPLANSAT denote following problem.

Assume restricted numeric task (V P G). relaxation (V P G)
solvable?

Theorem 1 relaxation given Denition 5 adequate, i.e., following holds true.
1. Admissibility: assuming restricted numeric task (V P G), plan
(V P G) also relaxed plan (V P G).
2. Basic informedness: assuming restricted numeric task (V P G), hi plan
(V P G) hi relaxed plan (V P G), 2 A,
result(I hi) j= pre(a) result(I hi) j= pre(a+ ).
3. Polynomiality: deciding RESTRICTED-RPLANSAT P.

detailed proof found Appendix A. straightforward extension
STRIPS proof, exploiting correspondence pre/goal-conditions, add lists,
delete lists one hand, x ff >]c constraints, += e ects, -= e ects
hand. tricky part lies proving polynomiality, precisely handle
repeated increasing e ects variable. e ects might applied
exponential number times. Consider tasks, n 2 N0 , vi initially 0,
vi ff n goal, action e ect (vi += 1). task n, shortest relaxed
plan comprises n steps, exponentially long size non-unary encoding
301

fiHoffmann

n. trick one use decide relaxed solvability polynomial time simple
1 handling. polynomial decision process forward
xpoint procedure similar
building relaxed planning graph. soon appears action increases
variable vi , one assume vi 's value 1, reecting fact vi 's value
made arbitrarily high applying sucient number times. indicated earlier,
current implementation Metric-FF, describe Section 5, make
use 1 handling technique, may thus build exponential number relaxed
planning graph layers search state. Section 5.1.
words related work order here. one relaxes numeric tasks ignoring
numeric constructs, one gets admissibility polynomiality, basic
informedness. heuristic methods used Sapa (Do & Kambhampati, 2001) GRT-R
(Refanidis & Vlahavas, 2000) come quite close extreme case. fact, Sapa's heuristic
constructs relaxed plan completely ignores numeric part task.
\resource consumption" resulting relaxed plan (roughly, sum decreasing
e ects numeric variables) used estimate number actions would needed
re-produce resources, number added heuristic value state
hand. particular, method ignores numeric goals preconditions thus lacks
basic informedness. Similarly, heuristic technique used GRT-R considers resource
consumption another form state cost, take numeric precondition
goal constraints account. heuristic technique make explicit use relaxed
plans de
nitions directly applied. However, numeric constraints
considered, heuristic value purely numeric action precondition zero even
precondition true current state, technique thus also lacks basic
informedness.

4.2 Monotonicity, Dynamic Relaxation
look behind scenes relaxation technique used
restricted language. abstract syntax numeric constructs, focus
semantics instead. de
ne extension relaxation general context,
identify group semantic properties make relaxation adequate.
later focus syntactically restricted language, linear tasks, easier see
relaxation adequate. main intention abstract work subsection
provide theoretical background general characteristics relaxation
works.
Let us
rst ignore semantic issues, simply extend de
nition relaxation.
general, de
nition easy restricted case De
nition 5.
idea still ignore decreasing e ects, diculty whether e ect decreasing
depend context executed in.8 simple example, say action
numeric e ect (vi += vj ). vj negative value state a's execution,
e ect decreases value vi instead increasing it. statically relax
8. common practice refer += eects \increasing eects", -= eects \decreasing
eects". contrast that, distinguish syntax semantics using += / -= denote
syntax, increasing / decreasing denote semantics (of arbitrary numeric eects).

302

fiTranslating \Ignoring Delete Lists" Numeric State Variables

ignoring parts speci
cation. Instead, relaxation dynamic: relax
state transition function.

Denition 7 Assume state action = (pre(a) e (a)). relaxed result
executing result+ (s a) = s0 p(s0 ) = p(s) p(e (a))+ , v(s0 )

value vector results v(s) replacing vi (s) (vi ass exp)(s)
(vi ass exp) 2 v(e ) (vi ass exp)(s) > vi (s).

action sequence ha1 : : : i, result+(s ha1 : : : i) de
ned recursively
original result function Section 2. Note that, STRIPS restricted numeric
language, De
nition 7 comes exactly relaxations used before.
generalized relaxation, want know exactly situations
relaxation adequate. Obviously, ignoring decreasing e ects adequate
general. simple example, value variable vi initially 0, e ect
(vi -= 1), goal requires vi < 0, \relaxation" renders task unsolvable. Intuitively, relaxation adequate always preferable numeric
variables higher values. Formalizing intuition turns bit tricky.
Recall three conditions adequacy relaxation: admissibility (any real plan also
relaxed plan), basic informedness (the relaxation ignore precondition goal
constraints), polynomiality (solvability relaxation decided polynomial
time). Basic informedness obviously given relaxation here. admissibility
polynomiality. Say want make sure real plan also relaxed plan.
must numeric constraints prefer higher variable values, e ects must
also. example, say vi = vj = 0 initially, goal vi ff 1, action e ect
(vi -= vj ), action e ect (vj -= 1). ignore decreasing e ect vj ,
solve task e ect (vi -= vj ) better vj takes lower values.
Considering polynomiality, ensure relaxed solvability decided polynomial
time, kinds subtleties must handled. Say want shortcut repeated action
application 1 trick, i.e., assuming repeated application increasing e ects
makes ected variable diverge (as case restricted language above).
get trouble repeated (relaxed) application action makes value
ected variable converge.9 Similar diculties arise expression constraint
diverge variables. Finally, might constraint looks correct
inserting 1, never ful
lled
nite values. example
constraint vi ff vi + 1, ful
lled inserting 1 vi .
following de
nition, introduce number conditions sucient
ensure none diculties described appear. see \monotonic"
tasks real plan also relaxed plan, \strictly monotonic" tasks, given
:= e ects acyclic certain sense, relaxed plan existence decided polynomial
time.

Denition 8 Assume numeric task (V P G). task monotonic if, pairs
states s0 8vi : vi (s)
vi (s0 ), following holds.
9. example, initially 1 eect ( += 1 ; v2i ) repeated application

eect makes value converge 2 (the value applications 2 ; 12 n ).
v

v

v

v

303

n

fiHoffmann

(1) numeric constraints (exp comp exp0 ) occurring task:
j= (exp comp exp0) ) s0 j= (exp comp exp0 ):
(2) numeric e ects (vi ass exp) occurring task:
(vi ass exp)(s)
(vi ass exp)(s0 )

relation holds values dened.
task strongly monotonic following hold.
(3) states s0 above, numeric e ects (vi ass exp) occurring
task, ass 2 f+= -= = /=g:
(vi ass exp)(s) ; vi (s)
(vi ass exp)(s0 ) ; vi (s0 )

relation holds values dened.
(4) expressions exp occurring task:
8vi 2 v(exp) : lim exp = 1
vi !1

v(exp) denotes set variables contained exp.
(5) numeric constraints (exp comp exp0 ) occurring task:
9s : j= (exp comp exp0 ):

explanation lengthy de
nition order. Condition (1) ensures
numeric constraints prefer higher variable values. Condition (2) e ects,
requiring value e ect increase variables. particular,
value become unde
ned, i.e., division zero occurs variables
grow. two conditions suce make real plan relaxed plan, higher variable
values always preferable. Conditions (3) (5) aim making relaxed solvability easy
decide. Condition (3) stronger version condition (2). require value
e ect adds ected variable increases variables. ensures
repeated application e ect causes value ected variable diverge.
illustrate this, e ect (vi += ;vj + c) ful
lls condition (2) condition (3).
outcome e ect always c, monotonic (zero) variables ects
vi vi 's value becomes higher. Condition (4) postulates expressions
diverge variables, condition (5) postulates constraints
nite
variable assignment makes constraints true. Together condition (1)
requirements ensure constraints eventually ful
lled increasing
values variables.10

10. One could weaken conditions (1) (3) De nition 8 exploiting fact interested
reachable states. matter if, e.g., constraint monotonic region variable values
never reached due semantics task. Metric-FF implements analysis
techniques, except throwing away actions { them, numeric constraints eects { whose
preconditions reached relaxed planning graph initial state, ignoring
numeric constructs. Exploring topic depth future work.

304

fiTranslating \Ignoring Delete Lists" Numeric State Variables

:= e ects separated de
nition strong monotonicity, i.e.,
postulate condition (2) them, postulate condition (3). Postulating
condition (3) := e ects would also suce. condition hold even
simplest form := e ects, namely (vi := c), assigning constant variable. Note
principle e ect example given above, (vi += ;vj + c).
E ects kind common even limited suits benchmarks currently
available (e.g.,
lling tank, fuel level assigned maximum level).
identify di erent sucient criterion makes := e ects tractable, captures
common forms e ects. Computing maximum outcome set assignment
e ects, relaxation condition (2), becomes easy value changes
single variable propagated value. proof argument that,
if, transitively, change vi inuence vi 's value one needs
perform value propagation steps, step computing maximum assignment
available variable. many steps variables, values

xed. formalize possible value propagations straightforward graph
de
nition.

Denition 9 Assume numeric task (V P G). task acyclic := e ects
graph (V E ) cycle-free,

E = f(vi vj ) 2 V V j 9a 2 (vj := exp) 2 v(e (a)) : vi 2 v(exp)g
v(exp) denoting set variables contained exp.

state ways de
nitions imply adequacy ignoring decreasing e ects
relaxation. notation relaxed plan existence decision problem, abstract
syntactic issues, assume well-formed input task decision procedure
strongly monotonic acyclic := e ects.

Denition 10 Let STRONGLY-MONOTONIC-RPLANSAT denote following prob-

lem.
Assume numeric task (V P G). relaxed plan (V P G), provided
task strongly monotonic acyclic := e ects?

Theorem 2 relaxation given Denition 7 adequate strongly monotonic tasks
acyclic := e ects. Precisely following holds true.

1. Admissibility: assuming monotonic numeric task (V P G), plan
(V P G) also relaxed plan (V P G).
2. Basic informedness: assuming numeric task (V P G), hi plan
(V P G) hi relaxed plan (V P G), 2
result(I hi) j= pre(a) result+(I hi) j= pre(a).
3. Polynomiality: deciding STRONGLY-MONOTONIC-RPLANSAT P.
305

fiHoffmann

proof, given Appendix A, basically straightforward exploitation properties ensured de
nitions. Note Theorem 2 identi
es sucient criteria
make relaxation work. Interesting questions are, other, maybe weaker,
criteria? concrete example, seem certain cases cyclic assignment e ects
easily handled. exactly cases? Answering questions
topic future work.
Another thing dealt semantic constraints translate
syntax arithmetic expressions allowed PDDL2.1. consider
details base rest article subset PDDL2.1 required
semantic properties easily achieved { language Metric-FF system
actually implemented. Extending system richer languages open research topic.

4.3 Linear Tasks, LNF

Metric-FF system implemented deal call linear tasks.
language numeric tasks = /= e ects, numeric variables
used linear expressions. formally:
( f(exp comp exp0 ) j exp exp0 linear expression comp arbitraryg
f:= += -=g
fexp j exp linear expressiong )
Metric-FF's implementation allows tasks linear following preprocessing step. Assume given planning task (V P G). variable vi 2 V
task constant vi ected e ect action A. expression task
constant variables occurring task constants. pre-process replaces task
constants respective rational numbers resulting inserting initial variable
values.11
Linear tasks are, course, necessarily monotonic. fact, illustrative
counter examples given linear. linear functions monotonic,
precisely strictly monotonic diverging, variables, either positive
negative sense. idea introduce, variable vi used negative sense
point, inverted variable ;vi always takes value (;1) vi . One
replace vi ;vi points vi used negatively. done
variables, task (strictly) monotonic: variables used positive
sense (more details below). Introducing inverted variables viewed shortcut way
informing heuristic function places use variables positive
negative sense.12 return issue considering Metric-FF's heuristic
algorithms Section 5.2.
Given linear task, Metric-FF transforms task call linear normal
form (LNF). LNF task, expressions weighted sums variables,
weights greater 0. transformation process works follows. First, series
simple steps transforms task following language.
11. If, quotient (exp exp ), exp simpli es 0 expression unde ned respective
constraint never ful lled / respective action's eects never become applicable.
case one replace constraint \false"/ remove action.
12. David Smith, personal communication.
=

0

0

306

fiTranslating \Ignoring Delete Lists" Numeric State Variables

P

( f( j 2X cj vj + c ff >] 0) j cj c 2 Q cj 6= 0g
f:=
+=g
P
f j 2X cj vj + c j cj c 2 Q cj 6= 0g )

achieve language format, one replaces constraints (exp = exp0 ) (exp

exp0 ) (exp ff exp0), e ects (vi -= exp) (vi += ;exp). rest
matter normalizing linear functions. language format di ers LNF
variable weights may negative. This, course, makes di erence. Reconsider
example variable vi initially 0, action e ect (vi -= 1),
goal requires vi < 0. take running example following.
language format, a's e ect (vi += ;1), goal requires (;1) vi > 0.
Due negative weighting vi goal condition, ignoring decreasing e ects
viable.
way introduce inverted variables extension methodology eliminates negative preconditions STRIPS planning (a technique
rst introduced Gazen &
Knoblock, 1997). process works follows. Initialize set translated variables
:= . Iterate negative weights, otherwise select (arbitrary) occurrence cj vj , cj < 0, weighted sum.P Introduce new variable ;vj . Set
;vj (I ) := (;1) vj (I ). e ects (vj +=:=] Pj 2X cj vj + c), introduce (into
e ect set action) e ect (;vj +=:=] j 2X ((;1) cj ) vj + ((;1) c)). Set
:= fvj ;vj g. occurrences c v weighted sums c < 0 v 2
(where v may one original variables one introduced inverse variables),
replace c v ((;1) c) ;v (where ;v respective inverse counterpart v).
jV j iterations, weights positive process terminates. task
following linear normal form.

P

( f( j 2X cj vj + c ff >] 0) j cj c 2 Q cj > 0g
f:=
+=g
P
f j 2X cj vj + c j cj c 2 Q cj > 0g )
running example, LNF transformation following. two
variables, vj ;vj , initially 0. action two e ects, namely
(vi += ;1) (;vi += 1). goal condition expressed terms value
;vi , reads ;vi > 0. single application action achieves goal, also
relaxed transition function e ect ;vi increasing.13 general,
easy see LNF tasks strongly monotonic.

Proposition 4 Assume linear numeric task (V P G). task LNF,
strongly monotonic.

Proof: conditions De
nition 8 trivially ful
lled LNF tasks. examples,

condition (1) true compare expressions (positively) monotonic
variables constants via ff >. Condition (3) true +=
e ects whose right hand sides (positively) monotonic variables.
2
13. Note estimating maximum value ; estimating minimum value .
Section 5.2.
v

307

v

fiHoffmann

Proposition 4, LNF task (V P G) acyclic := e ects (remember
separated De
nition 8 condition (3)) task ful
lls prerequisites
Theorem 2, ignoring decreasing e ects adequate relaxation. thus feasible
use solutions relaxation means heuristic estimation.
:= e ects, one easily translate into, e.g., += e ects { (vi := exp)
translates (vi += ((;1) vi )+exp). reader might wonder bother treating
:= e ects all. point that, translated e ects behave equivalently
real transition function, behave di erently relaxation. running example
suppose second action a0 e ect (vi := 10). LNF transformation,
translated version e ect (vi += ;vi + 10). Say execute, result+ ,

rst (with e ects (vi += ;1) (;vi += 1)) a0 . original task, resulting
value vi 10. translated task, value 11 (because decreasing e ect vi
ignored). make di erence whether treat := e ects separately not.
open question whether, situations, di erence important planner
performance.
also remark that, Metric-FF implements introduction inverted variables
LNF tasks only, seems likely similar processes work richer languages,
functions strictly monotonic diverging variables.

5. Solving Relaxed Tasks

concentrate algorithms used FF, generally algorithms
used obtain heuristic information forward state space search. explain
solve relaxed numeric tasks.
rst consider restricted language, extend
methods LNF tasks. algorithms form basis Metric-FF implementation.

5.1 Restricted Tasks

implementation uses straightforward extension Graphplan-style algorithms
introduced Section 2.2. still use two-step process
rst builds relaxed planning
graph extracts relaxed plan (if graph succeeds reaching goals).
parallel structures keep track progress logical propositions,
structures keep track progress terms maximally possible variable
values. graph building mechanism outlined Figure 4.
parts algorithm concerned propositions work exactly
STRIPS case, c.f. Section 2.2. numeric variables, max value vector
layer speci
es current maximum value variables take on. vectors
updated obvious fashion, adding layer total sum increasing e ects
layer. termination condition checks whether maximum values
variables either changed, already higher needed: mneedi value
variable vi de
ned highest requirement variable, i.e.,
mneedi := max(;1 fc j (vi ff >] c) 2 v(G)
v(pre(a))g):
a2A

Note algorithm fails relaxed plan (V P G):
algorithm fails layer termination condition hold true later layers.
308

fiTranslating \Ignoring Delete Lists" Numeric State Variables

P0 := s, vi maxi0 := vi (s) endfor
:= 0
p(G) 6 Pt (v >] c) 2 v (G) maxit 6 6>]c
:= fa 2 j p(pre(a)) Pt
8(vi >] c) 2 v(pre(a)) : maxit >]cg

Pt+1 := Pt a2A p(e
(a))+ P
v maxit+1 := maxit + a2A (v += c)2v(e
(a)) c endfor
Pt+1 = Pt
8vi : maxit+1 = maxit maxit > mneedi






fail
endif

:= + 1

endwhile

finallayer :=

Figure 4: Building relaxed planning graph state restricted numeric task
(V P G).
Also, note
nite number layers numeric variables
increase eventually reach
nite mneed values. But, mentioned Section 4.1,
number layers exponential task encoding. Reconsider example where,
n 2 N0 , vi initially 0, vi ff n goal, action e ect (vi += 1).
number graph layers built example, n, exponential non-unary encoding
n, whereas one could easily decide solvability 1 trick outlined Section 4.1.
hand, appears unlikely implementation provably polynomial
decision procedure would better practice. graph building algorithm polynomial
length output (the minimal length relaxed plan). Also, possibly
exponential minimal length relaxed plan (exponential non-unary encoding
variable values) seem particularly relevant, least examples
speci
cally constructed provoke exponentiality. remains open question whether
implementation 1 handling achieve better performance realistic examples.
focus relaxed plan extraction. invoked relaxed planning graph
succeeds reaching goals. information graph provides us
levels actions, propositions, numeric goals. actions propositions level

rst graph layer appear, c.f. Section 2.2. numeric goals (vi ff >] c),
level graph layer goal
rst achieved, i.e., maxit ff >]c
holds
rst time. plan extraction mechanism outlined Figure 5.
Again, logical entities dealt exactly STRIPS case, c.f. Section 2.2.
addition propositional (sub-)goal set p(Gt ) layer set v(Gt )
numeric goals. Like STRIPS, goals sub-goals always inserted set

rst appearance relaxed planning graph, goal sets initialized
inserting respective (top-level) goals. backwards loop top
bottom layer, selecting actions support propositions numeric variables
respective goal sets. propositions supported before, di erence
309

fiHoffmann



:= 1 : : : finallayer
p(Gt ) := fg 2 p(G) j level(g) = tg
v(Gt ) := f(vi >] c) 2 v(G) j level(vi >] c) = tg

endfor
:= finallayer : : : 1
g 2 p(Gt )

select a, level(a) = ; 1, g 2 p(e
(a))+
p 2 p(pre(a)) (v >] c) 2 v (pre(a))
p(Glevel(p) ) = fpg
v(Glevel(v >] c)) = f(vi >] c)g


endfor
endfor
(v >] c) 2 v (Gt )
maxit;1 6 6>]c

select a, level(a) = ; 1, (vi += c0 ) 2 v(e
(a)),
previously selected while-loop
c := c ; c0
/* introduce a's preconditions */

endwhile
v(Gt;1 ) = f(vi
endfor
endfor

>] c)g

Figure 5: Extracting relaxed plan state restricted numeric task (V P G)
(levels finallayer computed algorithm Figure 4).
also numeric preconditions supporting actions must inserted
goal sets below. uniting sets numeric goals contain constraint
variable vi , stronger one constraints taken. numeric goals
(vi ff >] c) 2 v(Gt ) general enough select single action several actions
; 1 might contributed vi 's maximum value t. SoPsupporters selected
goal achieved one layer earlier. Note maxit ; a2A 1 (v += c)2v(e (a)) c =
maxit;1 , loop always terminate successfully. Note also one occurrence
action support di erent logical numeric goals di erent e ects,
used support numeric goal twice.
Upon termination plan extraction, selected actions used form relaxed plan: denoting actions selected layer t, arbitrary linearization
A0 : : : Afinallayer;1 relaxed plan task. Note one apply various simple
heuristics, like selecting += e ects maximum right hand side
rst, make relaxed
plans short possible.
t;



5.2 LNF Tasks
algorithms numeric tasks linear normal form di er restricted tasks
need take care := e ects, general expressions numeric
310

fiTranslating \Ignoring Delete Lists" Numeric State Variables

constraints e ect right hand sides. turns out, integrating extensions
overly dicult. issue becomes slightly involved exact termination
criterion relaxed graph building. solution issue assume,
theoretical analysis underlying Theorem 2, := e ects acyclic. outline
graph building mechanism shown Figure 6.
P0 := s, vi maxi0 := vi (s) endfor
:= 0
p(G) 6 Pt (exp >] 0) 2 v (G) exp(maxt ) 6 6>]0
:= fa 2 j p(pre(a)) Pt
S8(exp >] 0) 2 v(pre(a)) : exp(maxt) >]0g
Pt+1 := Pt a2A p(e
(a))+ P
v maxit+1 := maxit + a2A :(v += exp)2v(e
(a)) exp(max )>0 exp(maxt ) endfor
v maxit+1 := max(maxit+1 maxa2A (v := exp)2v(e
(a)) exp(maxt )) endfor
Pt+1 = Pt
8vi : maxit+1 = maxit maxit > mneedi (s)












fail
endif

:= + 1

endwhile

finallayer :=

Figure 6: Building relaxed planning graph state LNF task (V P G).
Compare Figure 6 Figure 4. deal expressions constraints
e ect right hand sides simply inserting respective max values variables,
computing respective outcome (recall exp(v) expression exp variable
value vector v denotes value exp inserting values v). += e ects
taken account obtain maxt+1 values exactly before, i.e., adding
combined contributions maxt (except value right hand sides must
computed using maxt values). := e ects taken account determining,
+= e ects contributed maxt+1 , whether := e ect graph
whose value, inserting maxt values, higher hitherto maxt+1 value.
case, maxt+1 (for respective variable) updated maximum assignment
possible.
part algorithm becomes somewhat complicated, comparison
algorithm restricted tasks, termination criterion. dicult part
computation mneed values, i.e., values variables longer
contribute anything relaxed solution. values depend state
start from. derive values, start static (non state-dependent) notion
solution-relevant variables. variable vi solution-relevant either occurs numeric
constraint, right hand side exp e ect (vj +=:=] exp) solution-relevant
variable vj . Note solution-relevance thus transfers transitively variables.
denote set solution-relevant variables rV . state-dependent aspects
relaxed task, provide notation value variable vi must least take
state order raise (or \support") value positively weighted sum
311

fiHoffmann

P

exp = j 2X cj vj + c constant c0 .

supvi (s exp c0 ) := (c0 ; c ;

X

i6=j 2X

cj vj (s)) = ci

course, support value supvi (s exp c0 ) de
ned vi 2 v(exp), i.e., vi
part weighted sum. reader easily convince him/herself, raise
value vi supvi (s exp c0 ) know value exp least c0 .
use concept determine point variable vi contributes suciently
constraints e ect right hand sides contribute to. constraints
(exp ff >] 0) vi 2 v(exp) point reached vi ff supvi (s exp 0) (then
constraint ful
lled). += e ect right hand sides (vj += exp) vi 2 v(exp)
vj 2 rV (vj may needed) point reached vi ff supvi (s exp 0) (the e ect
eventually increase vj arbitrarily high values). := e ect right hand
sides, e ect (vj := exp) vi 2 v(exp) vj 2 rV value vi sucient
vi ff supvi(s exp mneedj (s)): e ect high enough assign vj sucient value.
main complication want use supv values de
ne mneed
values de
nition := e ects recursive. constitute problem given
assumption := e ects acyclic. e ect, recursion guaranteed
terminate. Altogether, de
nition following.
8> ;1
>< fsupvi(s exp 0) j (exp >] 0) 2 v(G) Sa2A v(pre(a)) vi 2 v(exp)g

mneed (s) := max >
(s exp 0) j (v j += exp) 2

f
supv
) vj 2 rV g
:> fsupvi(s exp mneedj (s) j (vj := expa2)A2vS(e
a2(Aa))v(e
v (2a))v(exp
vi 2 v(exp) vj 2 rV g
Note that, de
nition, variables mneedi (s) = ;1 variables
solution-relevant.

Theorem 3 Assume linear numeric task (V P G) LNF acyclic
:= e ects. Assume state s. algorithm depicted Figure 6 fails,
relaxed plan (V P G).

main proof idea is, before, this: algorithm fails layer termination condition hold true later layers. argument concerning mneed(s)
values follows outlined above. full details bit lengthy. See Appendix A.
discussed restricted language, number graph layers built
termination
nite { eventually, variables either increase reach
nite
mneed values { exponential encoding length task. Again, one
could implement provably polynomial algorithm along lines method used
proof Theorem 2, debatable whether implementation would,
realistic examples, achieve signi
cant performance improvements existing
implementation.
interesting consider role inverted variables { introduced
Metric-FF LNF pre-processing, see Section 4.3 { play relaxed planning graph
process described above. Estimating maximum value inverted variable
estimating minimum value respective original variable. precisely,
Figure 6, vj inverted variable vi (;1) maxjt is, t, optimistic
312

fiTranslating \Ignoring Delete Lists" Numeric State Variables

approximation minimum value vi take steps: value
results one ignores increasing e ects vi , optimistic decreasing
e ects. sense, introduction inverted variable ;vi = vj viewed
way informing relaxed planner where, numeric constraints e ects,
use minimum maximum possible value vi , computing optimistic
approximation maximum minimum values.14
focus relaxed plan extraction. justi
ed Theorem 3, invoked
relaxed planning graph succeeds reaching goals. Also before, information
graph provides levels actions, propositions, numeric goals.
actions propositions de
nitions stay same, numeric goals (exp ff >] 0)
level graph layer goal
rst achieved, i.e., exp(maxt ) ff >]0
holds
rst time. outline plan extraction mechanism shown Figure 7.
Compared algorithm restricted tasks, shown Figure 5, novelties
Figure 7 complex numeric goals get split goals individual variables,
e ect right hand sides forced suciently high value, := e ects
handled.
rst issue, given numeric goal (exp ff >] 0), dealt simply
constraining variables vi 2 v(exp) take respective max value. Similarly,
e ect right hand sides (vi :=+=] exp) forced suciently high requiring
vj 2 v(exp) take respective max value. := e ects taken account
alternative way achieving numeric goal (vi ff >] c) 2 v(Gt ). e ect
(vi := exp) suciently high value, exp(maxt;1 ) ff >]c, respective action
selected. Otherwise set actions += e ects selected similar fashion
restricted tasks. Figure 5, uniting sets numeric goals contain
constraint variable vi , stronger one constraints taken. easy
see that, upon termination, selected actions used form relaxed plan
state hand.

Theorem 4 Assume linear numeric task (V P G) LNF acyclic :=

e ects. Assume state algorithm depicted Figure 6 reaches goals.
actions selected algorithm depicted Figure 7 form relaxed plan (V P G).

(straightforward) proof found Appendix A. conclude section
two additional remarks. One thing might also occurred reader one
necessarily need support goal (exp ff >] 0) requiring vi 2 v(exp)
take maximum possible value. Weaker requirements might already sucient.
holds true e ect right hand sides. One might able
nd shorter relaxed plans
using simple heuristics points. also seems plausible algorithms
speci
ed work strictly monotonic task uses += e ects acyclic
:= e ects, assuming mneed value computation modi
ed appropriately. Exploring
idea richer language classes left open topic future work. also left open
= e ects /= e ects could taken account.
14. insight pointed author David Smith comment submitted version
article. Optimistically estimating maximum minimum variable values, generally
multiple variable values, alternative viewpoint monotonicity paradigm explore here.
Investigating alternative viewpoint depth open topic.

313

fiHoffmann



:= 1 : : : finallayer
p(Gt ) := fg 2 p(G) j level(g) = tg
v(Gt ) := f(vi >] maxit ) j (exp >]0) 2 v(G) level(exp >] 0) = vi 2 v(exp)g

endfor
:= finallayer : : : 1
g 2 p(Gt )

select a, level(a) = ; 1, g 2 p(e
(a))+
p 2 p(pre(a)) (exp >] 0) 2 v (pre(a))
p(Glevel(p) ) = fpg
v(Glevel(exp >] 0)) = f(vi >] maxilevel(exp >] 0)) j vi 2 v(exp)g

endfor
endfor
(v >] c) 2 v (Gt )
9a, level(a) = ; 1, (v := exp) 2 v (e
(a)),
v(Gt;1 ) = f(vj maxjt;1) j vj 2 v(exp)g

exp(maxt;1 ) >]c

/* introduce a's preconditions */

else
maxit;1 6 6>]c

select a, level(a) = ; 1, (vi += exp) 2 v(e
(a)), exp(maxt;1 ) > 0
previously selected while-loop
c := c ; exp(maxt;1 )
/* introduce max constraints vars exp */
/* introduce a's preconditions */

endwhile
v(Gt;1 ) = f(vi
endif
endfor
endfor

>] c)g

Figure 7: Extracting relaxed plan state LNF task (V P G) (levels
finallayer computed algorithm Figure 1).

6. Metric-FF
section details theoretical algorithmic work described far used
implement heuristic planning system Metric-FF. Section 6.1 speci
es relaxed
plan information used de
ne basic architecture planner handles STRIPS
plus linear tasks acyclic := e ects. describe extensions integrated
system: Section 6.2 explains extension ADL handled, Section 6.3
explains exible optimization criteria taken account.

6.1 Basic Architecture
STRIPS case, techniques extracting relaxed plans, state
space planner easily implemented. given linear task transformed LNF
task using algorithms described Section 4.3. de
ne heuristic function, search
314

fiTranslating \Ignoring Delete Lists" Numeric State Variables

strategy, pruning technique analogous used STRIPS version FF, c.f.
Section 2.3. methods straightforward adaptions STRIPS techniques.
heuristic function still estimates goal distance number actions relaxed plan.

Denition 11 Assume linear numeric task (V P G) LNF acyclic
:= e ects, state s. Metric-FF heuristic value h(s) dened
follows.
P
finallayer
algorithm depicted Figure 6 fails, h(s) := 1. Otherwise, h(s) := t=1
jAt j
set actions selected layer algorithm depicted Figure 7.

search strategy remains exactly same, namely enforced hill-climbing depicted
Figure 3. di erence lies way avoid repeated states.
STRIPS case, simple hash table lookup procedure. straightforward adaption
would store visited states s, cut new state s0 identical state
visited before. can, however, derive weaker cuto criterion
important performance impact certain situations. might s0 di ers
solution-irrelevant numeric variables values. example,
di erence s0 might s0 execution time spent.
expand s0 iteratively might end
nite sequence succeeding states
nothing increase execution time (this phenomenon observed various
benchmark domains). avoid phenomena cutting new states s0
dominated stored state s. Given task (V P G), state s0 dominated
state propositions s0 same, vi 2 V , either vi
solution-relevant, vi 2 V n rV , vi (s0 )
vi (s) holds.15 s0 dominated s,
task hand monotonic sense De
nition 8, action sequences achieve
goal starting s0 starting s.

Proposition 5 Assume numeric task (V P G) monotonic. Assume two
states s0 . s0 dominated then, action sequences P 2 , result(s0 P ) j=
G result(s P ) j= G.
Proof: Say P = ha1 : : : action sequence result(s0 P ) j= G holds.
show that, solution-relevant variables vi 2 rV 0
j
n, vi (result(s0 ha1

: : : aj i))
vi(result(s ha1 : : : aj i)) holds. proves proposition: variables
goal constraints rV , goal constraints monotonic (De
nition 8 condition
(1)), goal constraints ful
lled result(s0 P ). claim
also ful
lled result(s P ). prove claim solution-relevant variable values
induction j . Base case j = 0: prerequisite, vi (s0 )
vi (s) holds vi 2 rV .
Inductive case j ! j +1. First, preconditions aj +1 ful
lled result(s ha1 : : : aj i)
due argument used goal constraints above. Second, variables
contained e ect right hand sides solution-relevant variables
solution-relevant de
nition induction hypothesis holds them. proves
claim monotonicity numeric e ects (De
nition 8 condition (2)).
2
15. Recall de nition solution-relevant variables , given Section 5.2: variables occur
numeric constraint, right hand side exp eect ( j ass exp) solution-relevant
variable j .
rV

v

v

315

fiHoffmann

LNF tasks monotonic. Proposition 5, solution plan s0 ,
solution plan s. Thus cutting s0 search space already contains
solution preserving. Consequently, search iteration performed enforced
hill-climbing, implementation keeps hash table states visited iteration,
skips new state dominated least one visited states.16 indicated
above, various benchmark examples prevents planner looping new
states nothing increase value solution-irrelevant variable like execution
time.17
extend STRIPS pruning technique, helpful actions actions
support either propositional numeric goal lowest layer relaxed
planning graph.

Denition 12 Assume linear numeric task (V P G) LNF acyclic
:= e ects, state algorithm depicted Figure 6 reaches goals.
set helpful actions H (s) dened

H (s) := f 2 j p(e (a))+ \ p(G1 ) 6= _
9(vi ff >]c) 2 v(G1 ) : 9(vi := exp) 2 v(e (a)) : exp(v(s)) ff >]c _
9(vi ff >]c) 2 v(G1 ) : 9(vi += exp) 2 v(e (a)) : exp(v(s)) > 0 g
G1 set sub-goals constructed layer 1 algorithm depicted Figure 7.

Supporting numeric goal means: := e ects, right hand side
e ect sucient ful
goal += e ects, respective right hand side
expression greater 0. Note right hand side value e ect lowest
layer relaxed planning graph exactly value state hand. search
iteration enforced hill-climbing, expanding state s, states generated
actions H (s) included search space. Note states relaxed
planning graph reach goals h(s) = 1 get expanded anyway.
STRIPS, algorithm fail either enforced hill-climbing gets trapped
dead end state helpful actions pruning cuts important states. observed
helpful actions pruning severe numeric domains. So, case enforced
hill-climbing fails try pruning technique turned , i.e., continue
hill-climbing procedure point failure without pruning. fails too, like
STRIPS employ safety net solution: complete greedy best-
rst strategy trying
solve task scratch. strategy expands search nodes increasing order
goal distance estimation. New states cut dominated already
visited state.
16. precisely, new state skipped dominant visited state hash
entry. value solution-relevant variables (like execution
time increased), implementation ensures case. Otherwise matter
chance. open question visited states could indexed order provide fast exact
answer query whether contain dominant state not.
17. consequence undecidability numeric planning (Helmert, 2002),
observed even seemingly benign benchmarks. nite state space course would
run risk entering nite loop.
0





0



316



fiTranslating \Ignoring Delete Lists" Numeric State Variables

6.2 ADL

ADL (Pednault, 1989) goes beyond STRIPS allows, action preconditions
goal, arbitrary equation-free
rst-order logical formulae, actions conditional
e ects { e ects occur e ect condition holds true. e ect condition
arbitrary (equation-free)
rst-order logical formula. numeric setting,
e ects contain updates numeric variables. numeric constraints appear
point logical formula logical atom allowed.
Like previous FF version (Ho mann & Nebel, 2001), Metric-FF compiles quanti
ers
disjunctions away pre-processing phase. Metric-FF compile conditional effects away. Metric-FF's internal language di ers STRIPS (with numeric constraints
e ects) actions conditional e ects, e ect conditions
conjunctions propositions (and numeric constraints). reason ADL compiled
language heuristic algorithms (i.e., relaxed planning graph)
implemented eciently restricted language format. compilation
exponentially costly general feasible when, one might expect formulation realistic planning scenario, logical formulae overly complex. reason
conditional e ects also compiled away (which could done principle)
that, Nebel (2000) proved, would imply another exponential blow given want
preserve solution length. Fortunately conditional e ects easily dealt
need compile away. following, give brief overview
compilation process, extended heuristic function implementation. Except
heuristic function, thing must adapted state transition function,
conceptually trivial.
compilation process largely implementation ideas proposed
Gazen Knoblock (1997), well Koehler Ho mann (2000b). extensions
handle numeric constructs straightforward. process starts usual
planner inputs, i.e., set parameterized operator schemata, initial state,
goal formula. compilation works follows.
1. Determine predicates numeric functions static sense operator e ect them. predicates functions common phenomenon
benchmark tasks. Examples, transportation context, would connections
locations given static (connected ?l1 ?l2) predicate, distances
locations given static (distance ?l1 ?l2) function. Static predicates
functions recognized simple sweep operator schemata.
2. Transform formulae quanti
er-free DNF. subdivided three steps:
(a) Pre-normalize logical formulae. Following Gazen Knoblock (1997),
process expands quanti
ers, translates negations. end formulae consist conjunctions, disjunctions, atoms containing variables
(where atoms numeric constraints).
(b) Instantiate parameters. simply done instantiating operator
e ect parameters type consistent constants one other.
process makes use knowledge static predicates, sense
317

fiHoffmann

instantiated formulae often simpli
ed (Koehler & Ho mann, 2000b).
example, instantiated static predicate (p ~a) occurs formula,
instantiation contained initial state, (p ~a) replaced
\false". another example, sides numeric constraint static
constraint replaced either \true" \false".
(c) Transform formulae DNF. postponed instantiation, costly, applied smallest formulae possible.
fully instantiated formula, likely many static predicate occurrences
(constant constraint occurrences) replaced \true" \false", resulting
much simpler formula structure.
3. Finally, DNF formula contains one disjunct, corresponding e ect, operator, goal condition gets split manner proposed
Gazen Knoblock (1997).
logical constructs normalized, numeric constructs task
transformed LNF manner analogous process described Section 4.3.
Integrating conditional e ects relaxed planning process easy matter.
relaxed planning graph di ers STRIPS counterpart keeps track
graph layers action's e ects
rst become applicable. relaxed plan
extraction process di ers STRIPS counterpart selects supporting
e ects propositional numeric goals.

6.3 Optimization Criteria

PDDL2.1, user specify optimization criterion task. criterion consists
arbitrary numeric expression together keyword \maximize" \minimize"
saying whether higher lower values expression preferred. semantics
solution plan optimal state leads maximal / minimal goal state
respect optimization expression. Metric-FF supports, run \optimization mode",
somewhat restrictive form optimization. accepts optimization criterion
criterion transformed, according certain schema, additive action cost
minimization. heuristic cost state summed cost actions
respective relaxed plan, search standard weighted weights
set via command line. Note methodology give guarantee
quality returned solution heuristic function provably admissible.
methodology obvious option given cost relaxed plan (in additive
setting) gives us remaining cost estimation technique free. open question
general optimization criteria dealt with. following, describe
implemented methodology little detail. start STRIPS setting,
outline changes made extension ADL.
Metric-FF rejects optimization expression linear. Otherwise, optimization keyword \maximize" expression isPmultiplied ;1 minimization
required. expression brought LNF, j 2X cj vj (the constant part
obviously skipped). notation, optimization criterion accepted (only)
action e ects variables vj 2 X increase optimization expression value
318

fiTranslating \Ignoring Delete Lists" Numeric State Variables

constant, i.e., e ects vj 2 X form (vj += c) c 2 Q, c ff 0.
action a, cost action de
ned

cost(a) :=

X

(vj += c)2v(e (a)) vj 2X

cj c

i.e., sum increases cost variables action, multiplied weight
optimization expression. cost action sequence set sum
individual costs. easy see that, setting,
nding goal state minimizes
optimization expression value equivalent
nding plan minimal cost. search
algorithm use is, stated above, standard weighted algorithm implementing
best-
rst search function f (s) = wg g(s) + wh h(s) g(s) cost
search path leads s, h(s) remaining cost estimate (i.e., cost relaxed
plan s), weights wg wh given command line. Since
remaining cost estimate general admissible,
rst plan found guaranteed
optimal. one would expect empirically better plans found.
see is, fact, case IPC-3 testing domains.
ADL, cost action state sum costs e ects appear,
cost action sequence sum costs actions respective states,
minimizing optimization expression equivalent minimizing plan cost.
Estimating remaining cost means relaxed plan becomes somewhat less obvious,
since choice made e ect costs counted result.
e ects selected support logical numeric goals relaxed plan
extraction, e ects get triggered actually executing relaxed
plan. chosen count costs former e ects. heuristic search
algorithm remains exactly STRIPS case.

7. Competition Results

briey examine IPC-3 competition data relevant Metric-FF. competition
featured domains spanning whole range STRIPS PDDL2.1 level 3, permits
combination logical, numeric, temporal constructs. FF participated STRIPS
domains numeric domains, demonstrating competitive performance.
discuss data numeric domains. discussion STRIPS results
found competition overview article Long Fox (2003).
six numeric domains used competition. domains,
include
gure showing runtime curves, discuss relative (runtime solution quality)
performance text. Like FF, MIPS LPG systems could con
gured either
favor speed quality, i.e., either
nd plan fast possible search
good plan sense optimization criterion. make graphs readable,
show runtime curves planners favor speed. discuss solution quality
behavior planners terms plan length, i.e., number steps. Note
planners take account optimization criterion anyway. planners
favor quality, discuss runtime solution quality behavior text. Given
optimization mode Metric-FF preliminary implementation, keep
discussions short. also give brief descriptions domain semantics.
319

fiHoffmann

details found overview article (Long & Fox, 2003). focus
six domains turn, give short summary Metric-FF's performance.

7.1 Depots

Depots domain combination well-known Logistics Blocksworld domains.
Objects must transported trucks Logistics, must arranged
stacks Blocksworld. numeric constructs de
ne fuel consumption trucks
hoists lift objects (in order stack somewhere). Objects weights
sum weights objects loaded onto truck time must lower
equal truck's capacity. Figure 8 shows runtime data 22 Depots
instances used competition.
10000
"FF.speed"
"LPG.speed"
"MIPS.plain"
"SemSyn"
1000

100

10

1

0.1

0.01
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

Figure 8: Runtime curves Depots instances planners favoring speed. Time
shown logarithmic scale, instance size scales left right.
four planners participating numeric version Depots Metric-FF, LPG,
MIPS, SemSyn. time writing, paper numeric version
planners published. LPG MIPS, reader referred respective
articles appear JAIR special issue (Gerevini et al., 2003a Edelkamp, 2003).
Figure 8 shows, SemSyn solve single smallest instance, MIPS solves 10
instances scattered across whole set. Metric-FF LPG solve instances
exhibit similar behavior. Metric-FF planner solve two largest
instances. stated above, show curves con
gurations favoring speed.
competition data, version Metric-FF called \FF.speed", version LPG
called \LPG.speed", version MIPS called \MIPS.plain".
320

fiTranslating \Ignoring Delete Lists" Numeric State Variables

assess relative plan quality behavior (i.e., plan length minimization expression
value), computed quotients follows. Given planners B, measure, instances solved planners, A's plan quality divided B's plan quality. Compute
average quotient. points need absolute measure comparison
participating planners domain, set planner B hypothetical \Best-of"
planner whose data obtained selecting best (i.e., lowest) results planners.
individual planners domain ranked comparing Best-of.
data obtained concerning plan length Depots, planners shown Figure 8,
this. FF.speed's plans average 1:23 times long Best-of's plans, LPG.speed's
plans average 1:25 times long Best-of's plans, MIPS.plain's plans
average 1:29 times long Best-of's plans. Thus plan lengths roughly similar here.
single instance SemSyn solves, plan 5 steps FF.speed's 10
steps, LPG.speed MIPS.plain 11 steps.
next comment algorithms used planner versions favoring quality.
MIPS, similar Metric-FF, optimization mode heuristic function becomes kind
relaxed plan cost algorithm. contrast, LPG optimization method starts

rst plan, continues search plans better. Metric-FF performs
best-
rst search function f (s) = wg g(s)+ wh h(s). competition, weights
set wg = 1 wh = 5. quality version MIPS simply called \MIPS"
competition data. improve readability call \MIPS.quality" here, similar
quality-favoring versions Metric-FF LPG, called \FF.quality" \LPG.quality".
optimization criterion Depots minimize overall fuel consumption. runtime, quality versions MIPS LPG behave slightly worse speed
versions. contrast, Metric-FF's quality version solves smallest 3 instances.
solution quality, fuel consumption FF.speed
rst 3 instances 22, 33, 35,
FF.quality 22, 33, 36. Thus optimization e ect observable.
instances, MIPS.quality
nds costly plans (32, 63, 44), LPG.quality's
plans slightly better (22, 33, 29). Across instances, LPG.quality's plans consume, average, 1:01 times fuel Best-of's plans consume, average value
1:46 MIPS.quality.

7.2 Driverlog
Driverlog domain variation Logistics trucks need drivers,
underlying map arbitrary undirected graph (as opposed fully connected graphs
standard version domain). Drivers move di erent paths trucks.
numeric constructs specify total time driven walked. Figure 9 shows
runtime data 20 Driverlog instances used competition.
Depots, participating planners Metric-FF, LPG, MIPS, SemSyn.
Again, SemSyn solved smallest instance. LPG.speed planner
solves instances. FF.speed solves one task MIPS.plain (the respective data
point almost hidden behind \SemSyn" top right corner), roughly fast
LPG.speed tasks solves. plan length, none planners
clearly superior. average quotients versus Best-of are: 1:34 FF.speed, 1:44
LPG.speed, 1:21 MIPS.plain. FF.speed's LPG.speed's plan lengths thus
321

fiHoffmann

100
"FF.speed"
"LPG.speed"
"MIPS.plain"
"SemSyn"

10

1

0.1

0.01
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Figure 9: Runtime curves Driverlog instances planners favoring speed. Time
shown logarithmic scale, instance size scales left right.
average somewhat longer MIPS.plain. di erence tendency
grow instance size, though. single instance solved SemSyn, SemSyn's plan
3 steps planners 8.
optimization criterion Driverlog minimize (instance-speci
c) linear
combination total time, driven distance, walked distance. FF.quality's runtime
behavior is, Depots, lot worse FF.speed, solving 5 smaller
instances. quality plans slightly better, though, 0:94 times FF.speed's values
average. MIPS.quality LPG.quality solve instances speed-favoring
counterparts. average comparison LPG.quality Best-of 1:00 (precisely 1:000411),
MIPS.quality 1:31 { single instance, MIPS.quality's plan consumes less fuel
(730 units) LPG.quality's plan (736 units).
competition also featured version Driverlog (\Hard-Numeric") driving
truck consumes fuel proportional square load, criterion minimize
instance-speci
c linear combination total time fuel consumption. Interestingly,
optimization criterion FF.quality slightly less ecient FF.speed, solving
instances speed-favoring version. come back phenomenon
outlook, discuss e ect optimization expressions runtime performance.
overall runtime performance planners similar domain version
described above. optimization expression, FF.quality's values average 0:77
times FF.speed (so optimization e ect observed). comparison
Best-of 1:59 FF.quality, 1:007 LPG.quality, 1:72 MIPS.quality.
322

fiTranslating \Ignoring Delete Lists" Numeric State Variables

7.3 Zenotravel
Zenotravel domain, used competition, rather classical transportation
domain, objects must transported via airplanes. planes use fuel,
either slow fast. Fast movement consumes fuel. numeric version
domain, fuel level plane overall fuel usage numeric variables.
addition, numeric variable counts passengers board plane, fast movement
allowed number passengers certain threshold. refuel operator
used set fuel level plane back maximum capacity. Without durations,
di erence e ects slow fast ying lie higher fuel consumption,
thus \fast" ying useless action. Figure 10 shows runtime data 20 Zenotravel
instances used competition.
1000
"FF.speed"
"LPG.speed"
"MIPS.plain"
"SemSyn"
100

10

1

0.1

0.01
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Figure 10: Runtime curves Zenotravel instances planners favoring speed. Time
shown logarithmic scale, instance size scales left right.
Again, participating planners Metric-FF, LPG, MIPS, SemSyn. SemSyn solves smallest three instances, planners solve whole test set.
FF.speed order magnitude faster LPG.speed MIPS.plain. plan length,
FF.speed MIPS.plain behave similarly, LPG.speed
nds somewhat longer plans.
quotient values versus Best-of 1:28 FF.speed, 1:45 LPG.speed, 1:22
MIPS. visualizing data, one
nds di erence LPG.speed's
FF.speed's plans grows instance size. SemSyn, again,
nds best (shortest) plans
instances solves. quotients FF.speed versus SemSyn 1:00, 2:72,
4:50 three instances solved SemSyn.
323

fiHoffmann

optimization criterion Zenotravel minimize (instance-speci
c) linear
combination total time fuel consumption. FF.quality's runtime behavior worse
FF.speed, solving smaller half test set. MIPS.quality solves

rst 16 instances, LPG.quality solves largest instance. optimization
criterion values FF.quality average 0:82 times FF.speed, optimization
e ect observed. quotient values versus Best-of 1:51 FF.quality, 1:39
LPG.quality, 1:14 MIPS.quality.

7.4 Satellite

Satellite, number Satellites must make number observations using installed
instruments. involves turning Satellites right direction, switching instruments , calibrating instruments, taking images. numeric version
domain, turning Satellites consumes (non-replenishable) fuel, images occupy
data memory, Satellites limited data memory capacity. Figure 11 shows
runtime data 20 problem instances used competition.
1000
"FF.speed"
"LPG.speed"
"MIPS.plain"
"TP4"
100

10

1

0.1

0.01
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Figure 11: Runtime curves Satellite instances planners favoring speed. Time
shown logarithmic scale, instance size scales left right.
domain, participating planners Metric-FF, LPG, MIPS, TP4
(Haslum & Ge ner, 2001). TP4 (which
nds plans optimal makespan) solves 3
smallest instances, MIPS.plain solves 7 smaller instances, LPG.speed solves 10
instances, FF.speed solves 14. Note, though, instances LPG.speed fails
solve FF.speed solves mainly smaller ones. plan length, quotients
versus Best-of 1:11 FF.speed, 1:04 LPG.speed MIPS.plain, 1:09 TP4.
324

fiTranslating \Ignoring Delete Lists" Numeric State Variables

plan lengths roughly similar, LPG.speed MIPS.plain seem slight
advantage FF.speed.
optimization criterion Satellite minimize overall fuel consumption.
FF.quality's (MIPS.quality's) runtime behavior lot worse FF.speed
(MIPS.plain), solving 2 (4) smallest instances. LPG.quality solves instances LPG.speed. fuel consumption FF.speed 2 instances FF.quality
solves 109 97. FF.quality 109 83, slight optimization
e ect one two instances. LPG.quality
nds best plans instances
solves (thus quotient versus Best-of constantly 1:00), comparison MIPS.quality
Best-of 2:54.
competition also featured version Satellite (\Hard-Numeric")
logical numeric goals all, optimization criterion maximize amount
stored data (i.e., memory occupied taken images). example
optimization criterion transformed action costs sense explained
Section 6.3. actions take images negative costs. Metric-FF thus rejects
optimization criterion reports, instances, trivially solved
empty plan. Similarly, plans returned MIPS.plain empty. MIPS.quality
version
nds non-trivial plans smaller half instances. LPG
data competition results domain version.

7.5 Rovers
Rovers, number planetary rovers must analyze number rock soil samples,
take number images. involves navigating rovers, taking dropping samples
(rovers hold one sample time), calibrating camera taking images,
communicating data lander. numeric version domain, activities
decrease energy available rover certain amount, energy recharge
operator applied rover located sunny spot. Figure 11 shows
runtime data 20 Rovers instances used competition.
participating planners domain Metric-FF, LPG, MIPS. None
planners solve whole test set, fact LPG, scales best, planner
solve larger instances.18 smaller instances solved quickly
three participants. FF.speed might slight plan length advantage. quotients
versus Best-of 1:02 FF.speed, 1:26 LPG.speed, 1:19 MIPS.plain.
optimization criterion Rovers minimize number recharge actions
applied plan (i.e., cost recharging 1, cost actions 0).
optimization criterion, FF.quality solve single instance (we return
outlook). MIPS.quality LPG.quality solve instances
speed-favoring counterparts. LPG.quality's plan quality 0 8 instances
MIPS.quality solves. MIPS.quality's plans contain 0 recharge actions three cases, 1
recharge action four cases, 2 recharge actions one case.
18. actual competition data, LPG failed solve 8 instances due implementation bug.
show corrected data provided Alfonso Gerevini.

325

fiHoffmann

100
"FF.speed"
"LPG.speed"
"MIPS.plain"

10

1

0.1

0.01
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Figure 12: Runtime curves Rovers instances planners favoring speed. Time
shown logarithmic scale, instance size scales left right.

7.6 Settlers
Settlers domain building infrastructure unsettled area. things
built include housing, railway tracks, sawmills, etc. lot operator
schemata encoding complex building process. raw materials, timber, stone, ore,
must
rst felled, broken, mined. One process timber wood coal,
process ore iron. Carts, trains, ships built transport materials. One
combine materials build docks, wharfs, rails, housing, etc. encoding makes
intensive use numeric variables domains. domains
numeric constructs mainly encode resource constraints action costs, Settlers
numeric variables play active part achieving goal. Indeed, many operator
schemata logical e ects all. example, felling timber increases amount
timber available respective location one unit. Loading (unloading) material
unit onto (from) vehicle encoded increasing (decreasing) respective material
availability vehicle decreasing (increasing) material's availability
respective location. building housing unit least one wood stone unit must
available, resulting increased housing units decreased wood stone units.
numeric variables playing active role domain encoding, Settlers
interesting benchmark numeric planners. Figure 11 shows runtime data 20
Settlers instances used competition.
Metric-FF MIPS (in versions favor speed) able solve
Settlers instances. LPG could participate domain operators
326

fiTranslating \Ignoring Delete Lists" Numeric State Variables

1000
"FF.speed"
"MIPS"

100

10

1

0.1

0.01
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Figure 13: Runtime curves Settlers instances planners favoring speed. Time
shown logarithmic scale, instance size scales left right.
make use universally quanti
ed e ects, LPG support. MIPS.plain solves
single instance FF.speed solves 6 smallest instances. noted
instances example suite appear rather large. FF.speed's plans
6 smallest instances contain 53, 26, 102, 67, 74, 81 actions respectively.
comparison, domains except Depots FF.speed's longest plan
rst 6
instances contains 26 steps. Depots numbers 10, 15, 35, 34, 75, 6th instance
isn't solved planner. plan MIPS.plain
nds second smallest instance
contains 36 steps (as stated FF.speed's plan instance contains 26 steps).
planner favoring quality solved Settlers instances.

7.7 Performance Summary
speed-favoring con
gurations, Metric-FF LPG perform best, terms
runtime solution length. runtime, Driverlog Rovers, LPG scales better
(solves instances). Zenotravel, Metric-FF scales better (an order magnitude
advantage runtime). Settlers, LPG could run, Metric-FF solve
rather large instances. Depots Satellite, slight advantage Metric-FF,
solves instances. MIPS lags behind Metric-FF LPG
domains except Zenotravel scales roughly similar LPG. solution length,
roughly similar LPG Metric-FF domains except Zenotravel,
LPG's plans longer. Satellite might slight advantage LPG,
327

fiHoffmann

Rovers might slight advantage Metric-FF. plan lengths MIPS
roughly similar Metric-FF across domains.
results Metric-FF optimization mode, FF.quality, less satisfying, least
far runtime behavior concerned. FF.quality solve single instance Rovers
Settlers, solves instances Depots, Driverlog (with normal,
i.e. \hard" optimization expression), Satellite. FF.quality's runtime behavior
reasonably good Zenotravel Driverlog (with \hard" optimization expression).
solution quality behavior mixed. cases observed FF.quality's
plans better sense optimization criterion FF.speed's plans are. Better
plan quality clearly observable Driverlog (with \hard" optimization expression)
Zenotravel. also observable Driverlog (with normal optimization expression)
Satellite, although small number instances solved domains.
Compared LPG.quality MIPS.quality, FF.quality quality-favoring planner
shows dramatically worse runtime behavior speed-favoring counterpart.
reasons must lie algorithmic di erences systems, concerning
way treat optimization expressions. outlook speculate reasons
FF.quality's poor runtime behavior, might done it.

8. Conclusion Outlook

presented natural extension popular heuristic technique STRIPS {
ignoring delete lists { numeric planning. straightforward implementation MetricFF based technique one two best performing numeric planning systems
IPC-3.
Let us summarize contributions work little detail.
important contribution \monotonicity" idea, i.e., numeric framework
main STRIPS concepts (pre/goal-conditions, add lists, delete lists) translate
naturally numeric concepts (monotonic constraints, increasing e ects, decreasing
e ects). monotonicity idea might useful many contexts beside speci
c
heuristic planner implementation focus article (some ideas given
outlook below). heuristic context considered here, have:
Abstracted desirable properties (admissibility, basic informedness, polynomiality) ignoring delete lists relaxation STRIPS.
De
ned natural extension relaxation numeric case provided suf
cient criteria identify numeric tasks relaxation preserves desirable
properties.
De
ned subset PDDL2.1 level 2, linear tasks, sucient criteria
achieved pre-processing technique.
De
ned algorithms solve relaxed tasks language thus provide heuristic function.
Implemented straightforward extension FF,
rst technique takes userspeci
ed optimization criteria account. FF extension (FF.speed) shows reasonable performance across number benchmark domains. Speci
cally performed
328

fiTranslating \Ignoring Delete Lists" Numeric State Variables

best, together LPG, numeric track 3rd International Planning Competition, terms runtime solution length.19 runtime behavior
optimization technique (FF.quality) unsatisfying, plan quality improvements
observed.
Various research topics left open:
background theory given Section 4.2 provides sucient criteria
numeric relaxation adequate. question is, weaker sucient criteria, one come complete analysis (i.e.,
nd exact borders
beyond ignoring decreasing e ects longer adequate)? Also,
identi
ed borderlines translate, syntactically, mathematical constructs allowed
PDDL2.1 level 2?
pre-processing algorithm given Section 4.3 (transforming linear tasks LNF
tasks) de
ned linear tasks only. extended richer language classes?
Similarly, algorithms given Section 5.2 work LNF. easy
extension richer language classes?
mentioned Section 4.3, various kinds numeric e ects easily translated
(e.g., := e ects += e ects vice versa), respective
translations behave di erently relaxation. one identify problem classes
one formulation yields better heuristic performance?
current optimization technique, FF.quality, restricted optimization criteria
transformed action cost minimization according certain simple
translation schema. general optimization criteria handled?
seen runtime performance FF.quality unsatisfying.
appears interaction (as exempli
ed two di erent quality metrics
Driverlog) form optimization (i.e., action cost minimization)
expression runtime behavior. explanation might degree \goaldirectedness" minimization expression. Intuitively, minimization expression
goal-directed closely correlated goal distance, i.e., lower expression
value nearer goal vice versa. maximally goal-directed minimization
expression goal distance (i.e., \total-time" sequential framework).
contrast, minimization expression Rovers, number recharge operations,
loosely connected goal distance. would worthwhile come
good formal notion goal-directedness, investigate connection
runtime performance (in Driverlog connection less obvious Rovers).
practical side, algorithms remain found show better performance
matter form optimization expression is. One option always
integrate, extent, current goal distance estimate (i.e., length
19. Note one easily imagine domains relaxed plans way Metric-FF uses would
likely yield good heuristic information. example, consider 15-puzzle, numeric variables
encoding positions tiles. situation, large degree interaction
numeric variables, relaxed plans presumably able capture interaction.

329

fiHoffmann

relaxed plan case) remaining cost estimation. Another option use
di erent search schemes. branch-and-bound like approach appears possible (
rst

nd plan quickly use cost plan upper bound
exploration search space).
would exciting explore impact monotonicity idea, i.e., correspondence brings pre/goal-conditions monotonic constraints, add lists
increasing e ects, well delete lists decreasing e ects, di erent contexts
planning research. Examples spring mind heuristic approaches, Graphplanbased numeric planning, goal ordering techniques. stimulate imagination
reader:
seems likely similar methods used heuristic approaches
relax task ignoring delete lists. example, techniques presumably adapted heuristic estimators partial order framework used RePOP
(Nguyen & Kambhampati, 2001), yielding heuristic numeric partial-order planner.
Also, appears feasible integrate techniques Sapa's (Do & Kambhampati, 2001) heuristic function, possibly making function accurate various
numeric situations. another possible avenue, one might able adapt techniques presented use LPG's heuristic precondition cost estimation process
(Gerevini, Serina, Saetti, & Spinoni, 2003b), making sensitive numeric
constructs, thereby { potentially { improving LPG's performance.
Koehler's extension IPP numeric context (Koehler, 1998) su ers complications backward search procedure, signi
cantly degrade runtime performance. diculties arise monotonic context?
Koehler Ho mann (2000a) argue reasonable ordering B

two goals B if, states achieved
rst, one must
delete order achieve B . monotonicity, straightforward translation
two numeric goals B ordered B
if, values
variables participate sucient achieve A, values must
decreased necessary value order achieve B . seems
Koehler Ho mann's techniques approximate STRIPS goal orderings transfer
easily situation. Similarly, seems monotonicity de
nitions
approximation techniques given landmarks (subgoals necessarily
arise planning) Porteous, Sebastia, Ho mann (2001) directly
transferred numeric goals.

Acknowledgments
article extended revised version paper (Ho mann, 2002a)
published ECAI-02. Metric-FF developed implemented author
visiting Durham Planning Group, Durham, UK. Thanks go Maria Fox Derek
Long discussions, making stay enjoyable. Thanks also go Malte Helmert
330

fiTranslating \Ignoring Delete Lists" Numeric State Variables

fruitful remarks relaxation theory. thank David Smith insights
nature inverted variables, many detailed comments language. Finally
thank anonymous reviewers comments, helped improve paper.

Appendix A. Proofs

appendix presents proofs theorems detail. three di erent classes
results, focus turn: relaxation adequacy, relaxed Graphplan completeness,
relaxed Graphplan correctness. Within classes, results given
languages increasing expressivity.

A.1 Relaxation Adequacy

STRIPS, restricted numeric language, numeric tasks general, prove
respective relaxations adequate (in general case, identify situations
relaxation adequate). proof STRIPS case trivial.

Proposition 1 relaxation given Denition 1 adequate, i.e., following holds
true.

1. Admissibility: plan solves original task also solves relaxed task,
i.e., assuming STRIPS task (P G), plan (P G) also relaxed
plan (P G).
2. Basic informedness: preconditions goals trivially achieved
original task holds relaxed task, i.e., assuming
STRIPS task (P G), hi plan (P G) hi relaxed plan (P G), 2 A, result(I hi) pre(a)
result(I hi) pre(a+ ).
3. Polynomiality: relaxed task solved polynomial time, i.e., deciding
RPLANSAT P.

Proof: 1. application action relaxed action sequence, least
propositions true true real sequence. action precondition,
goal, ful
lled.
2. Holds dropping precondition goal constraints. empty
plan hi plan (P G) G holds. true (P A+ G).
Similarly action preconditions.
3. proved Bylander (1994).
2
proof case restricted numeric language straightforward extension
STRIPS proof, exploiting correspondence pre/goal-conditions, add lists,
delete lists one hand, x ff >]c constraints, += e ects, -= e ects
hand.

Theorem 1 relaxation given Denition 5 adequate, i.e., following holds true.
331

fiHoffmann

1. Admissibility: assuming restricted numeric task (V P G), plan
(V P G) also relaxed plan (V P G).
2. Basic informedness: assuming restricted numeric task (V P G), hi plan
(V P G) hi relaxed plan (V P G), 2 A,
result(I hi) j= pre(a) result(I hi) j= pre(a+ ).
3. Polynomiality: deciding RESTRICTED-RPLANSAT P.

Proof: 1. application step relaxed plan, least propositions

true true real plan, values numeric variables least high
real plan. action preconditions goal require variable values
greater equal constant, constraints remain ful
lled.
2. Holds dropping precondition goal constraints. empty
plan hi plan (V P G) j= G holds. true
(V P A+ G). Similarly action preconditions.
3. following polynomial time algorithm decides RESTRICTED-RPLANSAT.

:= , := v(I )

remove, action preconditions goal, propositions
numeric constraints ful
lled mi values (i.e., mi ff >]c)
G 6=
:= fa 2 j pre(a) = g
0 := Sa2A p(e (a))+
m0 :=
2 f1 : : : ng mi 6= 1
9a 2 : (vi += c) 2 v(e (a)) (m0 )i := 1 endif

endfor
0 = m0 = fail endif
:= 0, := m0

remove, action preconditions goal, propositions
numeric constraints ful
lled mi values

endwhile
succeed

Remember n denotes number numeric variables. Denote action set
iteration algorithm. prove algorithm succeeds relaxed
plan, relaxed plan algorithm succeeds, algorithm takes
polynomial time size task.
relaxed plan ha1 : : : ak (V P G), 2 holds true
1

k: set (the values m) always include (are always least high as) true
facts relaxed plan (the variable values relaxed plan). algorithm succeeds
k iterations. fail earlier implies
xpoint contradiction
reachability goals.
direction, algorithm succeeds iteration k one construct
relaxed plan. Simply linearize (relaxations the) actions sets A1 : : : Ak
332

fiTranslating \Ignoring Delete Lists" Numeric State Variables

arbitrary order. action layer += e ect variable xi , repeatedly
execute action constraints xi removed iteration
ful
lled (as constraints form xi ff >]c, eventually happen).
actions applied way preconditions ful
lled empty
respective iteration, execution sequence makes constraints true
algorithm.
runtime, single iteration polynomial. upper bound number
iterations jV j + jP j. iteration, avoid failure, least one new proposition must
enter one new variable value must set 1.
2
Generalizing restricted language, ignoring decreasing e ects adequate
numeric constraints monotonic, numeric e ects strongly monotonic (plus
changes due := e ects propagate numeric variable's value). proof
generalizes, way, proof above.

Theorem 2 relaxation given Denition 7 adequate strongly monotonic tasks
acyclic := e ects, i.e., following holds true.

1. Admissibility: assuming monotonic numeric task (V P G), plan
(V P G) also relaxed plan (V P G).
2. Basic informedness: assuming numeric task (V P G), hi plan
(V P G) hi relaxed plan (V P G), 2
result(I hi) j= pre(a) result+(I hi) j= pre(a).
3. Polynomiality: deciding STRONGLY-MONOTONIC-RPLANSAT P.

Proof: 1. Say ha1 : : : ani plan (V P G). Executing sequence result,

precondition goal constraints ful
lled. Denote vi (t) value variable
execution action , denote vi (t)+ value variable execution
action result+. show vi (t)
vi (t)+ t. monotonicity
numeric constraints, De
nition 8 condition (1), suces. claim easily shown
induction t. = 1, vi (1)
vi (1)+ holds simply result+
identical result except e ects decrease value variable ignored.
+ 1, vi (t)
vi (t)+ vi (t + 1)
vi (t + 1)+ holds due
argument, plus monotonicity numeric e ects sense De
nition 8
condition (2): higher input numeric variables are, higher resulting value
ected variable becomes.
2. empty plan hi plan (V P G) j= G holds.
true hi relaxed plan, dropping goal constraints. Similarly
action preconditions.
3. following polynomial time algorithm decides relaxed solvability
strongly monotonic task acyclic := e ects.
1. := , := v(I )
2. remove, action preconditions goal, propositions
333

fiHoffmann

3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.

numeric constraints ful
lled mi values
G 6=
:= fa 2 ASj pre(a) = g
0 := a2A p(e (a))+
m0 :=
2 f1 : : : ng mi 6= 1
9a 2 (vi ass exp) 2 v(e (a)) :
ass 2 f+= -= = /=g (vi ass exp)(m) > mi (m0 )i := 1 endif

endfor
2 f1 : : : ng mi 6= 1
9a 2 (vi := exp) 2 v(e (a)) : (vi := exp)(m) > mi
(m0 )i := maxa2A (v := exp)2v(e (a)):(v := exp)(m)>m (vi := exp)(m)
endif
endfor
0 = m0 = fail endif
:= 0 , := m0






remove, action preconditions goal, propositions
numeric constraints ful
lled mi values

19. endwhile
20. succeed

Here, above, v(exp) expression exp denotes set variables contained
exp. value expression contains variables set
nity given
limit expression variables. Note assumption limits 1
(De
nition 8 condition (4)) can, particular, computed eciently. prove
algorithm succeeds relaxed plan, relaxed plan
algorithm succeeds, algorithm takes polynomial time size task.
Denote action set iteration algorithm. relaxed plan
ha1 : : : ak (V P G), 2 holds true 1

k: variable updates
performed algorithm always least high performed
result+ function. Note line 13 takes maximum available := e ects.
Note also e ects obey De
nition 8 condition (2), one needs consider
maximum input values order obtain maximum output value. consequence,
monotonicity numeric constraints sense De
nition 8 condition (1), algorithm
reaches goals succeeds k iterations. fail earlier
implies
xpoint contradiction reachability goals.
algorithm succeeds iteration k one construct relaxed plan
follows. Perform upwards loop 1 k. iteration t, repeatedly apply
actions constraints removed line 18, iteration t,
ful
lled. show point eventually reached. point
reached, one continue next higher value step succeeding
iteration k completed. actions applied way preconditions
ful
lled empty iteration actions applied, constructed relaxed plan always ful
lls constraints removed iteration,
De
nition 8 condition (1) constraints become false
334

fiTranslating \Ignoring Delete Lists" Numeric State Variables

true relaxed plan. reason goals ful
lled end iteration

k. remains show that, iteration t, repeatedly applying actions
eventually ful
constraints removed iteration. Denote set
variables got set, iteration t, 1 line 9, denote It0 set variables
got set 1 line 13, denote Ft set variables got set new value
1 line 13. show that:

1. one application actions variables Ft least values
constraint removal line 18.
2. repeated application actions variables It0 reach arbitrarily
high values.
suces constraints eventually ful
lled. Assume two claims hold
true. Then, monotonicity constraints (De
nition 8 condition (1)) variables
Ft contribute least much full
llment constraints iteration
decision algorithm. variables It0,
nite assignment
variables, higher previous values, makes respective constraints true
point. simple consequence De
nition 8 condition (1) (the constraints prefer
higher variable values), condition (4) (the expressions diverge variables), condition
(5) (existence
nite ful
lling assignment), fact constraints
true previous iteration became true setting variables It0 1.

rst claim follows simple fact actions responsible increasing
values variables Ft { actions ful
condition line 12 { are,
particular, contained . outcome might higher variables
respective e ect right hand side increased
rst negative interactions
variables considering relaxed transition function. argument
second claim follows. variables , contains respective
responsible action ful
lling condition lines 8 9. application action
increases, De
nition 8 condition (3), variable's value least much
previous application, repeated application diverges. Note that, again, relaxed
state transition, applying action worsen situation variables.
variables It0 , contains action ful
lling condition line 13,
(vi := exp) 2 v(e (a)), exp containing least one variable v0 2 v(exp) set 1
point (as (vi := exp)(m) = 1). Recursively, responsible action a0 setting v0 1 must
included previous iteration. e ect a0 v0 := e ect,
responsible action must included earlier, on. one point, responsible
action a00 respective ancestor variable v00 must included line 9. Repeated
application a00 causes value v00 diverge (with argument above),
e ect transitively causes value vi diverge.

nally remains show algorithm terminates polynomial time. Obviously
single iteration polynomial. number iterations bounded number
times 0 m0 di erent respectively m. Changes values occur
lines 5, 9, 13. overall number changes line 5 bound number
logical propositions, jP j. overall number changes line 9 bound number
numeric variables, jV j. exponential number iterations termination
335

fiHoffmann

would exponential number consecutive iterations changes occur
line 13. number consecutive iterations is, however, bound jV j jAj.
seen follows. Throughout entire sequence iterations, := e ects
contribute changes. := e ects acyclic assumption value
change propagate value, possible change
occur new action comes in. takes jV j iterations propagate changes
variables (this length longest possible propagation path), so,
least one new action comes iteration t, another new action comes
iteration + jV j latest. obvious bound number iterations new
actions come jAj, concludes argument.
2

A.2 Relaxed Graphplan Completeness

STRIPS LNF tasks prove respective relaxed Graphplan mechanisms
complete, i.e.,
nd relaxed plan one. proof STRIPS
case trivial.

Proposition 2 Assume STRIPS task (P G), state s. algorithm depicted

Figure 1 fails, relaxed plan (P G).
Proof: show contrapositive, i.e., relaxed plan (P G),
algorithm succeeds. Say relaxed plan P = ha1 : : : (P G).
algorithm applies,
rst layer, possible actions. particular, includes a1 ,
layer P1 least facts true true executing
rst step P .
argument inductively applied actions P , implying layer
2 , Pt contains facts true upon execution
rst actions
P . implies goals true layer m0
m, G Pm . Moreover,
algorithm fail layer m00 < m0 : follows
xpoint reached,
Pi = Pm > m00 , G 6 Pm , contradicts assumptions.
2
0

00

0

proof LNF tasks proceeds along line, requires care
details concerning values beyond numeric variables longer contribute
solution.

Theorem 3 Assume linear numeric task (V P G) LNF acyclic

:= e ects. Assume state s. algorithm depicted Figure 6 fails,
relaxed plan (V P G).
Proof: show contrapositive, i.e., relaxed plan (V P G),
algorithm succeeds. Say relaxed plan P = ha1 : : : (V P G).
algorithm applies,
rst layer, possible actions. particular, includes a1 ,
layer P1 least facts true true executing
rst step P ,
maxi1 values least high respective variable values. Together
fact e ect right hand sides positively monotonic (so inserting maxt
values increase outcome), argument inductively applied
actions P , implying layer 2 , Pt contains facts
true upon execution
rst actions P , maxit values least high
336

fiTranslating \Ignoring Delete Lists" Numeric State Variables

respective variable values. This, monotonicity numeric constraints,
implies goals reached layer m0
m, p(G) Pm
(exp ff >] 0) 2 v(G) : exp(maxm ) ff >]0. Moreover, algorithm fail
layer m00 < m0 . Assume does. m00 new propositions come in,
maxi values either changed, already maximum needed value.
Denote L set variables vi whose value still low, maxim
mneedi (s). Note
L rV holds since outside rV mneed values ;1. Pm +1 = Pm
and, vi 2 L, maxim +1 = maxim . show Pm +2 = Pm +1 and, vi 2 L,
maxim +2 = maxim +1 . proves claim: iterating argument, holds
true layers > m00 + 1, get contradiction goals reached m0
(note constraints variable V n L participates already ful
lled,
increasing variables reach new goal constraints). set propositions
could increase layer m00 +2 new action came in, i.e., 2 +1 , 62 .
value variable vi 2 L could increase layer m00 + 2 if: new action came
+= e ect right hand side expression (vi += exp) became positive +1 result
increasing V n L variable values m00 m00 + 1 := right hand side expression
(vi := exp) +1 became higher maxim +1 result increasing V n L
variable values m00 m00 + 1. None three cases occur de
nition
mneed values (that variables V n L reached).
rst case, +1
contain new action new precondition constraints became true
m00 m00 + 1 { V n L variable values increased, constraints
participate already ful
lled m00 . second case, (vi += exp) e ect
right hand sides V n L variables participate already 0 values
m00 (vi 2 L rV , mneed de
nition += e ects applies). third case,
occurred least one variable vj 2 V n L contained right hand
side responsible e ect (vi := exp). variable would ful
maxjm > mneedj (s),
thus exp(maxm ) > mneedi (s) would hold (vi 2 L rV , mneed de
nition :=
e ects applies), thus maxim +1 > mneedi (s) would hold (through application (vi := exp)
) contradiction assumptions. concludes argument.
2
0

0

00

00

00

00

00

00

00

00

00

00

00

00

00

00

00

00

00

00

00

A.3 Relaxed Graphplan Correctness
STRIPS LNF tasks prove respective relaxed Graphplan mechanisms
correct, i.e., actions select form relaxed plan. proof STRIPS
case trivial.

Proposition 3 Assume STRIPS task (P G), state algorithm

depicted Figure 1 reaches goals. actions selected algorithm depicted
Figure 2 form relaxed plan (P G).

Proof: First, note layer goal g 2 Gt, least one action
level(a) = ; 1, g 2 e (a)+, due way levels computed. Also,

action's preconditions always lower level action itself.
algorithm selects set layer t. arrange actions
sets arbitrary order obtain relaxed plan (P A+ G). goals
337

fiHoffmann

sub-goals layer achieved actions At;1 . delete e ects
ignored, least propositions true needed.
2
proof LNF tasks straightforward extension STRIPS proof.

Theorem 4 Assume linear numeric task (V P G) LNF acyclic :=

e ects. Assume state algorithm depicted Figure 6 reaches goals.
actions selected algorithm depicted Figure 7 form relaxed plan (V P G).

Proof: First, note layer goal g 2 Gt, least one action
level(a) = ; 1, g 2 e (a)+ , due way levels computed.
numeric goals (exp ff >] 0) 2 v(Gt ), always := e ect suciently high right

hand side value,

maxit ;

X

a2At :(vi += exp)2v(e (a)) exp(maxt 1 )>0

exp(maxt;1 ) = maxit;1

;

holds.
rst case loop entered, second case terminates
successfully. Note one occurrence action support di erent logical numeric
goals di erent e ects, used support numeric goal twice.
Denote, layer t, set actions selected algorithm layer.
arrange actions sets arbitrary order obtain relaxed plan
(A+ G). goals sub-goals layer t, logical numeric, achieved
actions At;1 . expressions numeric goals e ect right hand sides
always least high required constrain contained variables take
respective maximum values. delete e ects ignored, least propositions
true needed. decreasing e ects ignored monotonicity e ect
right hand sides, expression values constraints least high required. 2

References

Bacchus, F. (2001). AIPS'00 planning competition. AI Magazine, 22 (3), 47{56.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Articial
Intelligence, 90 (1-2), 279{298.
Bonet, B., & Ge ner, H. (1998). HSP: Heuristic search planner. AIPS-98 Planning
Competition, Pittsburgh, PA.
Bonet, B., & Ge ner, H. (1999). Planning heuristic search: New results. Biundo,
S., & Fox, M. (Eds.), Recent Advances AI Planning. 5th European Conference
Planning (ECP'99), pp. 60{72, Durham, UK. Springer-Verlag.
Bonet, B., & Ge ner, H. (2001). Planning heuristic search. Articial Intelligence, 129 (1{
2), 5{33.
Bonet, B., Loerincs, G., & Ge ner, H. (1997). robust fast action selection mechanism planning. Proceedings 14th National Conference American
Association Articial Intelligence (AAAI-97), pp. 714{719. MIT Press.
338

fiTranslating \Ignoring Delete Lists" Numeric State Variables

Bylander, T. (1994). computational complexity propositional STRIPS planning.
Articial Intelligence, 69 (1{2), 165{204.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric
temporal planner. Cesta, A., & Borrajo, D. (Eds.), Recent Advances AI Planning. 6th European Conference Planning (ECP'01), pp. 109{120, Toledo, Spain.
Springer-Verlag.
Edelkamp, S. (2003). Taming numbers durations model checking integrated
planning system. Journal Articial Intelligence Research. issue.
Edelkamp, S., & Helmert, M. (2001). MIPS: model checking integrated planning system.
AI Magazine, 22 (3), 67{71.
Fikes, R. E., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Articial Intelligence, 2, 189{208.
Fox, M., & Long, D. (2001). STAN4: hybrid planning strategy based subproblem
abstraction. AI Magazine, 22 (3), 81{84.
Fox, M., & Long, D. (2002). third international planning competition: Temporal
metric planning. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings
6th International Conference Articial Intelligence Planning Scheduling
(AIPS-02), pp. 333{335, Toulouse, France. Morgan Kaufmann.
Gazen, B. C., & Knoblock, C. (1997). Combining expressiveness UCPOP
eciency Graphplan. Steel, S., & Alami, R. (Eds.), Recent Advances
AI Planning. 4th European Conference Planning (ECP'97), Vol. 1348 Lecture
Notes Articial Intelligence, pp. 221{233, Toulouse, France. Springer-Verlag.
Gerevini, A., Saetti, A., & Serina, I. (2003a). Planning stochastic local search
temporal action graphs. Journal Articial Intelligence Research. issue.
Gerevini, A., Serina, I., Saetti, A., & Spinoni, S. (2003b). Local search techniques
temporal planning LPG. Proceedings 13th International Conference
Automated Planning Scheduling (ICAPS-03), Trento, Italy. Morgan Kaufmann.
Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal
planner. Proceedings 2nd International Conference Articial Intelligence
Planning Systems (AIPS-94), pp. 61{67, Chicago, IL. AAAI Press, Menlo Park.
Haslum, P., & Ge ner, H. (2001). Heuristic planning time resources. Cesta,
A., & Borrajo, D. (Eds.), Recent Advances AI Planning. 6th European Conference
Planning (ECP'01), pp. 121{132, Toledo, Spain. Springer-Verlag.
Helmert, M. (2002). Decidability undecidability results planning numerical
state variables. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings
6th International Conference Articial Intelligence Planning Scheduling
(AIPS-02), pp. 44{53, Toulouse, France. Morgan Kaufmann.
Ho mann, J. (2000). heuristic domain independent planning use enforced hill-climbing algorithm. Proceedings 12th International Symposium
Methodologies Intelligent Systems (ISMIS-00), pp. 216{227. Springer-Verlag.
339

fiHoffmann

Ho mann, J. (2001). Local search topology planning benchmarks: empirical analysis.
Nebel, B. (Ed.), Proceedings 17th International Joint Conference Articial
Intelligence (IJCAI-01), pp. 453{458, Seattle, Washington, USA. Morgan Kaufmann.
Ho mann, J. (2002a). Extending FF numerical state variables. Proceedings
15th European Conference Articial Intelligence (ECAI-02), pp. 571{575, Lyon,
France. Wiley.
Ho mann, J. (2002b). Local search topology planning benchmarks: theoretical analysis.
Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings 6th International Conference Articial Intelligence Planning Scheduling (AIPS-02), pp.
92{100, Toulouse, France. Morgan Kaufmann.
Ho mann, J., & Nebel, B. (2001). FF planning system: Fast plan generation
heuristic search. Journal Articial Intelligence Research, 14, 253{302.
Koehler, J. (1998). Planning resource constraints. Proceedings 13th European
Conference Articial Intelligence (ECAI-98), pp. 489{493, Brighton, UK. Wiley.
Koehler, J., & Ho mann, J. (2000a). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Articial Intelligence Research,
12, 338{386.
Koehler, J., & Ho mann, J. (2000b). instantiation ADL operators involving
arbitrary
rst-order formulas. Proceedings ECAI-00 Workshop New Results
Planning, Scheduling Design.
Long, D., & Fox, M. (2003). 3rd international planning competition: Results
analysis. Journal Articial Intelligence Research. issue.
McDermott, D. (1996). heuristic estimator means-ends analysis planning.
Proceedings 3rd International Conference Articial Intelligence Planning
Systems (AIPS-96), pp. 142{149. AAAI Press, Menlo Park.
McDermott, D. V. (1999). Using regression-match graphs control search planning.
Articial Intelligence, 109 (1-2), 111{159.
Nebel, B. (2000). compilability expressive power propositional planning
formalisms. Journal Articial Intelligence Research, 12, 271{315.
Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Nebel, B.
(Ed.), Proceedings 17th International Joint Conference Articial Intelligence
(IJCAI-01), pp. 459{464, Seattle, Washington, USA. Morgan Kaufmann.
Pednault, E. P. (1989). ADL: Exploring middle ground STRIPS situation calculus. Brachman, R., Levesque, H. J., & Reiter, R. (Eds.), Principles
Knowledge Representation Reasoning: Proceedings 1st International Conference (KR-89), pp. 324{331, Toronto, ON. Morgan Kaufmann.
Porteous, J., Sebastia, L., & Ho mann, J. (2001). extraction, ordering, usage
landmarks planning. Cesta, A., & Borrajo, D. (Eds.), Recent Advances AI
Planning. 6th European Conference Planning (ECP'01), pp. 37{48, Toledo, Spain.
Springer-Verlag.
340

fiTranslating \Ignoring Delete Lists" Numeric State Variables

Refanidis, I., & Vlahavas, I. (1999). GRT: domain independent heuristic STRIPS
worlds based greedy regression tables. Biundo, S., & Fox, M. (Eds.), Recent
Advances AI Planning. 5th European Conference Planning (ECP'99), pp. 47{59,
Durham, UK. Springer-Verlag.
Refanidis, I., & Vlahavas, I. (2000). Heuristic planning resources. Proceedings
14th European Conference Articial Intelligence (ECAI-00), pp. 521{525, Berlin,
Germany. Wiley.
Refanidis, I., & Vlahavas, I. (2001). GRT planning system: Backward heuristic construction forward state-space planning. Journal Articial Intelligence Research,
15, 115{161.
Russell, S., & Norvig, P. (1995). Articial Intelligence: Modern Approach. Prentice-Hall,
Englewood Cli s, NJ.
Smith, D. E., & Weld, D. S. (1999). Temporal planning mutual exclusion reasoning.
Proceedings 16th International Joint Conference Articial Intelligence
(IJCAI-99), pp. 326{337, Stockholm, Sweden. Morgan Kaufmann.

341

fi
fffi

fi fi


!



ff fi fi fi fffi
fi



fffi ff

ff
ff


ff

fiffff
ff

fi
ff


fffi fi
fi


! fi"



fffi ff ff ff ff ff


ff ff ff ff fi ffff


fffi ff ff ffff
ff

ff !ff "ffff # !"$ ff ff % ff %
ff ff ffff fi ff%

% ff &
ff



& ff ' ff (
#'

$
ff ff ff ff '
ff

fffi ff

ff ff
ff ff
)ff

!"
ff
ff



fffi & % * ff +
%

!" ff ff ff fi ff%
ff

&

fffi ff


fffi fi fffi ff fi fi fi
fi
fffi ff ff

ff fffiff fi ff fi fi fi ff ff fi
fi fi fi
fi fi fiff

ff
fi fi ff
! "ff
#$% &fi #'% ( ##% ) ff * + #,- ff ff fi ff
fifffi ff fi

fffi
fffi
fi fi
ff
! . *
+ #% / * 0fi fi
fi 1#% 2fi * 34ff 1#% /
* 3ff
11- .
fiff fi

fi
fi fi
fi
fffi
fi

ff
5fi fiff ff fi fi
ff fiff fi fi
fi

ff
fi

fffi fifffi fffi
fi
fi
fiff
fiff
fiff fi
fiff
fi ff $ff fffifi )fi
6
!)6- fiff fi fi fiff7 !24 fi * 8 1#- fi
fiffff ff !3ff * .fffi # 11-
ff
fi 9ff ff ff
fffi ff fi fiff
fi
!(fffi
-

fiff fiff fffi

fi fffi
ff
fffi !: * ; ff #<- &
ff
fiff fi fi


fifi fi
fi
ff fi ff fi ff fi ff
ff !3ff .fffi .fi * .
1$-
ff fi=ff
ff
fi fifi "
#
$#

fi fiffff fi

fi ff $ff )6 fi fi
9 ff fi fi


ff > fffi fi? fi fffi fi !; * 5 1$-
& fffi fiff ff
fiff fi fi fi fiff
ff ff
fiff !. fi 0fi @ * 6 #,- &

fffi
fi
ff ff fffi

!&(fffi
- fi
(fffi
fi fi
fiff
ff fi &(fffi
fi fiff fiff
fffi fi fi
fiff ffff
fi ff fi fi fiff fiff

fffi fi fi fiff ffff
fi
ff ( ffff fffi fifi ff fiff fi fi
fi fi ff
ff
fffi fffi
>fi fi? fffi
fi ffff
fi
& ff
fffifi ff fi !&(
fffi
- fiff ff fi ff fi ff ffff
&(fffi
& fi fi &(fffi
fi fi ff fiff

ff ff fffi fi !fi fi
fi- fi fi
fi fi fi
fi ff fi
fiff fi
ff fi
fi
fi fi
ff fi
ff )fi fi
fi
fffi fi fi ! ff fi ff
fffi
fffi
fi fi fffffi-
$ff )6 ff
fiff fffi
ffff fi fi fiff

ff ff

9ff fi fi

ff fi
ff fi fi fi
fiff fi
fffi ff
ff fi fffi fi


ff fi
ff
&
fi
ff fffi@ fi . 1
ff fi fi
fi ff
fffi

ff . $ ff fi fiff ff
ff ff
fffi fi fffi
fi ff

fffifi fi
fffi ff fi ff ffff
ff fi fffi fifffi fi ff fi
ff
ff
fi
fi . ,
ff ff fi
ff fi fifi

ff $ff )6 fi fffi ff fi

fffi
fi ff

fffi
fi . B fi ffff fi ff ff
;fi fi fi

ff fiff ff
fi
fffi ff fiff fi fi fi
ff fi
ff
ff . ,

ff

fi

ff

ff ff fffi
fi ff
fffi ff fi
fffi
fi
fi fi fi fi fffi
fi fffi
!: * ; ff #<-
ff
ff fffi
ff

(
fi fffi
fi ff fi fffi
fi ff
& fifffi fi fi fi fi fi fi fi
,-

fifi ff fffi
ff fi fi fi ff fi


fi fi ( fi fi fi ff
ff fi fi !fifi

fffiff- fi fi
fi fi
( fi fi fi ff
ff fi
ff

ffff
fi
ff ff ff fi fi
ff fi 4
ff ff fi fi
# & fi # ff
ff
fi
fi fi
fi
ff !ff fi fi fi
fi ff fi-
fi C
ff
!fi- ff
ff fi
!fi - & fi
fi fffi
fi fi fi

fiff fiff fi fi fi fi 7 ff ffff
ff
fi ff
ff
ff C D% ffff
fi
E# ff
ff
4 C D% ff ffffffff
fi E#
ff
ff fi 4 C Ffi fi fi fi fifi fi
fi fi fi ff
ff fi fi fi C fi

ff fi 4
& fi fi fiff fiff fi fi fffi

fi fi
ff ff !ffffffff- ff fi fi4 ff
!

ff ffff
- ff fi
ff fi fi
ff fiff
fiff fi fi !fiff ffff
-
&
ff
fi fi
ff
fiff fiff fi fi fi
fi
ff
C ff fiff fi fi fi C ff !fi fi
fi fi fi fiff fi fi fi fi fi
fi - + fi ff fi fiff fiff fi fi fi
fi ff fi fiff fffi !ff
fi -
3 fi
fi
ff G ffff

fi fffi
fi ff fi
ff fiff ff # fi
fi fiff !: * ; ff
#<- & fffi
ff fffi fi
ff
fi
ff fi fiff


ff fi ff fffi & ff ffff fffi

ff fi fffi fi ff ff fi
fi : fi ; ff ffff fi ff fffi
fi > 4?
& fffi
fi fffi
fi fffi fffi
7 fi fffi fi fi fffi fi fi
fifffi fi fi fi
ff fi fiHfi
fffi & fffi fi 9
fffi
fiff fi ff

ff
fiff fffi !; * 5 1- fi fi ff fffi

+ fffi fi fi fi fi fi ff
ff

ff
fi fi C fi fi fi fi
fi
fi 9ff ff
ff 4
fi fi C
9ff fi fi fi
fi
ff fi

fffi
fi
fiff fiff fffi
fi

ff
ff
fifffi
fi


ff
ff


































































ff





ff




ff ff





fffi fi
fi fi fi fi
fi
fi fi fi

,

fi fiffff fi

ff
ff ff

ff ffff
ff
ffff
ff fffi



ff ff ff

8 fi fi fi fffi
fi ff
ff fi fi
fi ff
ff ff
fffi fi fi

ffff
fi fi
ff
fi fiff
ff ff fi
fiff fi fi fffi fffi
fi
ff fi fi

ff fi fi fffi
ff !-
ff fi fi fi # ff
ff fi fi !
- 4 C ff !J # ! C fi
ff
fi fi- ( fi fffi

ff
ff fi fi
fi fi fi fi




ff

ff














ff
ff
ff
ff ffff
fiff ff ffffff ff



;ff fiff
fi
ff ff
fi fffi
fi
fi
fi ff

fi fi ff fffi ;ff
fffi ff
fiff ff
fiff fi fi fiff
ff ff
fi fi fiff (

( (
ff fi
fiff

fi
fi fffi
ff !0ff 8 24 fi * /

#<- fi
fffi ff ff ff fffi fffi ff
fi >fffifi? ff ff fffi 9

fffi
ffff ff
ff fi ff ff fi

ff fffi fffifi
& 9 fi fffi
fi

ff fi fi fi ffff
ff fi 4 fi fi fi fi fifi
ff
fifi
fffi
ff ffff

ff fi ffff fi

ff
fifi ! fi- ff fi fffi
fi fffi &


ff
fifi fi
ff
ff ff !3ff * .fffi 11-
fi fi fiff fiff
fi fi fi ff
fffi 9 fi fffi



ff
ff
ffff




ff ffff ff
ff ffff C C ffff










ff ffff
ff

ffff
ff ff
ff
fiff ff




ffff



. ff
fi
ff ff fi fffi

ff
fifi
fi fffi ff fi
fi fffi
!fi
fi


ff
fifi-

fiff fi
fi fffi
fiff ff fi
fffi
fi fffi
fi fi fi fffi fi
ffff fi fiff
ff fffi
fi
fiff
ff !: * ; ff #<-
ff !; * 5 # - fi !0ff fi #<- fiff fi ff
fffi

fiff fi fi fiff fi fi !0fi @ * . fi
#- ff !3ff * .fffi #- fiff fi fi fffi fiff
( ff
fffi fiff
fi ff @ fffi
ff fi fffi ff fiff ! fffi

fi
fiff fi fi fiff
-
,

fifi ff fffi
ff fi fi fi ff fi



ff fffi ff
ff

& 9ff ff !3ff * .fffi 11- fi fi fi fffi
ff fi
fi fi fi fiff fffiff ff fi fi fi 9
fi
fffi
& ff fi
fiff
fi $ff )6 fi ffff fi
fi fffi
fi ff
fifi fifi ff ff


ff fi ff
ff fi fi
fi ff
fffi
fiff fiff
fi fi fi fi
fffi fffi fi
ffH4 fffi
fi fi
9 !; * 5 1$-
fi
ff fi

fi ff
fffi fi ff
fiff fiff
ffff fi
ff
ff ! fi fi-
fiff
fi $ff )6
ffff

fffi
ff ff ff fi

ff
> ? !
ff fi ff fi
- fi 4
> ? ! 4 fi fi fi
- . $, fi ff

ff fi
4 fi $ff )6



ff ff
ff !
ff

ffff

fi
ff ff ffff
ff
fiff


fi


fffi fi fi fi fi fi 5(fffi


ff fffi
fifffi !
fifffi ffff-
fi fi ff fi 5(fffi

fi fi fffi fi
fifffi ffff
fi ff ffff fffi fiff !#-
fi fi !1-
fi fi ff ff ff
ff
fi
Kfiff 9ff fffi fi fiff fi
ff
C ffff ff C D% fffiff fffi fi fi 4 fi
!
ff
-

ff fi
ff C ffff
ff C & fi fi fffi fi
ff fi 4 fi fi
fiff fiff fi fi
fifffiffff
fi ! (ff * K
##% ) ff * + #1% 8 * 0fi fi
fi 1#-
fffi
fffi
ff fiff fi ff ff ff fi ff
fiff ! ff fi - fi fi fffi
fifffi

fi ff fffi

;ff
fffi fi ff fi fi fffi fi
fi fi fi

fi
fi fffiff fi ff fi ff fffi

fi ff ff fi
ff fiff fffi & ffff fffi


fi ffff fi ! fi fi fi fi fffi
ff fi ff fi fi fi -
. 5(fffi
ff fi fi ff fi fi ff
fi

ff
ff ff
fffi fi fififi
ff fffi (fffi
7
5(fffi
fi ff
ff
ff fifi ff ff fi fifi


ff
fifi 9fi fi fi ff
fi 4
ff
fifi ff




















fi

,

fi fiffff fi

5(fffi
ff

ff
fi ff fi fffifi ff fi

fi fiff fiff
ff (
ff
fffi ff fi fi


ff
fi ff fi fi ffff
fi fi

fi 5(fffi

fi ff fi ff
fffi
fi fi
fi ffff fi ffff
fi
fffi fi fi fi fi ffff
fi fffi

ff
ff fi fffi
ff
fi fi fi fi fi9 fi 5(fffi
!
ff- fi
4ff fi fiff ffff fi fi ff
( fi fi fi fi
ff fi 9 fi fiffff
fiff ff fffi fi fififi 5(fffi
ff
(fffi

@ ff
fffi ff fi 5(fffi
fi 9fi
fiffff fi ff ffff
(fffi
2ff fi
fi

ff fi @ 5(fffi
fi ff fi
ff ff ff
fiff%
;ff fi fffi fi ff
fiff ff
ff
fffi ff
fi fi fi fffi fi fi fi fi 5(fffi
fi
fi L ff

fi & fi fifi fi fi
! ! -- ff
ff fiff C ff fi
ff
ff
fi fi fffi L% fi fifi fi fi
! ! -- ff
ff fiff C fi ff fi &

fffi fi fiff ff ff fffi fi 5(fffi
fi ffff
fffi fi fiff fi L


! ff ff
ff "
ff L ffff


fi





fi





L






ff #


fiff ff ff
ff ff


ff ff

ffffff ff






#

& ffff fffi fi &(fffi
fiff
7 fffi fi
fi fiff
ffff fi fi ff ff
fi !

- fi
fffi fi fiff

fiff fi fi fi !


-

L fi fi fi
ff
!ff - L fi fiff fi
!
ff ff- . $,
ffff fffi fiff ff ff fiff 3
ff fi

fi
ff fi 4
fffi fi fi


































!
ff fi "# fi ff fi ff fi fi
fi fi $
fffi fi fi $ % ff fi

fffi fi & fi fffi fi fi
' ( )"# fi * ( + fi,

fi fi * - .
$$
/fi

0

,,

fifi ff fffi
ff fi fi fi ff fi


Level 1



Level 2

Level 3

Level 4

()



(0)
(50)






(0)

(0)








(50)




mutex



(50)
[50]

(0)







(120)
[70]
(0)





(0)


()

(120)













(50)





()

(120)

(120)







()

(220)


(160)







(0)







LJ




(0)

%



%




()

%




(220)
[100]
(220)

(220)





(160)
[40]

(120)



mutex



(160)

(50)





%





%



%






; ff #7 ( fi
&(fffi
/fi ff fi
fi fiff
fi K fffi fi
fffi fi fi fi
!ff- fi fi ! fiff- & ff fiff fffi
ff
ff fffi fi >!M-? fi fi ffff
fi


ff
ffff fffi !ff >? fi ff ff - fi fi C
ff fiff C &
fffi fi fi fi ! -
ff fi fi fi fi fffi


ff
! 9 ff fi ff
fffi fi fi
fi

ff
fffi fi ff
ff fi fi
9 fi ff fi fi
fffi fi fi
ff
fiff L
! - fffi % ff
! -
fffi fi fi fi ff
fffi fi
ff
fi
fffi fi fi fi
ff
; ff # fi fi
fi &(fffi
fi ff fi ! %- fi fffi
fi ff
ff ff fi .

ff fi
ff % %
L ! fiff ff - fi L fi fi fiff

ff ! fiff ff fi % - &
fffi fi fi
fi & fi 9ff @ff fi fi fi fi fi

ff

ff fi @ff fi
! - fffi .
! - fffi fi fi fi
ff L
ff
fffi fi
ff !@ff- fi ! - . fi $
,.














fi



fi





fi



fi



























fi



fi





fi















fi fiffff fi



ff fi

ff
ff
!
! - J
! - fi fffi .
ff %
! ff ffff fffi fi %-
! % - fi fi
ff
! - fi
fffi fi

ff
ff ! ' -

fffi % ;fi fi fi fi

ff % fi .
! ! % - fi fi
! - fi fi
! % -


" ff
ff
" L



!


ff L ff ff
L



ff ff fiff
ff ff L fiJ L fiJ
+ fi &(fffi
ffff
fffi fi
ff
ff fi
fi ffff ff fffi &(fffi
! fi
&(fffi
fi fiff ffff fiff ff fffi ff fi fiff
fi fi
fi fffi- &
fi ff fi fi fi fi ffff ff fffi
&(fffi
fi
ff fi fffi fiff fi

ff
fffi fi ff
fiff fi fi fiff
fiff fi

ff
fffi
ff
ff
ff ff
Nff fi
>ff? fffi fiff
fi
fi fi &(fffi
ffff
fi
fi ffff fi
ff
ff
fi fi ff ffff fffi L
;ff
fi fi fi ff ff @
fi fi
fi ! >& ?
>.
& ? >6
? fi >8 ff? fi >2fiff8 ff? fi
$ff )6- fi fiff
fi fi &(fffi
;ff fi ff
fffffi ! >.ff
? fi >8 ff? fi $ff )6- fiff
fi
ff 5(fffi
&

ff
fffi #
ff
fffi fi fffi fi fi
fifffi ff
fiff fi fi fffi fi fi
fffi fffi
fi fi fi

.fi
fffi fiff ff
fi ff
9 9 >
ff ?

fffiff ff
ff fiff

9 fi
ff fi
fi
9 fi fi
fi
ff ( fi


fi fffi fffi fiff fi fi ff fi $ff
)67 fiff
fffiff 9 fffi fi fi ff fi
fi fffi !
fffiff
fifffi ff fifi fi
9 fi
fi-
fi ff !fiff
fffiff
fifffi ff-
&
fi fi fffi
ff fi fi fi fiff ff
fi fiff fi fffi fi
fi ( fi
ff
fi ffff fi ff $ff )6 ff fffi
9

fffiff





fi

fi









fi

fi





fi

fi






fi



fi



fi













































& " fiff fi
fi fi1 )"# fi ff
fi fi fi1 "# fi fi ff ff2 3 - 4
$$

,/

fifi ff fffi
ff fi fi fi ff fi


&
ff
ffff fi ff ffff fi fi
fffiff fffi !-
9 fi fi ff
fiff fi
fi fffi fi fi
fi fifi ff fiff fi fi
fi fffi fi fi ff fi fi

.
$B ffA ff ff fi
fiff $ff )6 fi
fffi fi fifffi fi fffi
ff fi 4 2ff

fi
ff ff ff fffi fi fi
fi fi fi fffi fiff fi
Ffi fi fi
fi fi fifi fi fi fi fi4
fi fi
5 fi fffi fffi ff fi ff fi
ffff ff fi fi
ff
fi '

fi ff
9
ff ff
9 > ff? ;ff
fi
fi ff ff fi
ff
ff fi $ff
)6
ff ffffff ! " # ff " $ %


ff
fi fi
fi fi 9 fi fi
fi
fi & fi fi ff fi fi
fi
fi ff
ff fi 4
fi fi
fi ff
ff fi
9 fi fi fi fi
fffi fifffi ;ff ff fi fi fi

4
fi fffiHfffi fi ff ff fifffi
ff &
9 fi 4ff @ff ffff
ffff
fi fi fi ff
ff fi fi fi
fi 8 fi fi
fi fi ff
ff
fffi fi ff ff !
@ff
ff- fi
fffi fi

fi fi fifffi fi
fi fffi fi
ff fi
ff
ff
ff fi " $ %

& ff fi
fi % & ff ff&
ff %ff& $ff
)6 #$B' fi 4 fi fffi %


fi
" ff ff ff& '(
& J '< , J 1<#1
fffi ff fi
fi B 1<#1 J #$B'




















ff
ff ff ff


ff fiff + fiff fi ff

fffi fi fiff
fi fi fffi
& fffi

fffi fi fffi
fi fi ff
ff fi
ff
fi fffifi ff fi ff fifi &(fffi
ff
ff
fi ff fiff fi ff ff fi
fi ff fi ffff

fi fi fi C fi fi fi fi fi ff
ff




5 " fi fi
ff fi fi !


fffi fi 6
fi fi

6 fi fi

,0

fi fiffff fi

ff
fi ! fi

ff
fffi
ff
fffi fiff ff -
$ff
ff fi% &ff'ff
3 fi
fi fffi
fi fiff
ff fiff ff fi fi (fffi

! fi
fifffi
fi- fi fffiff fi fffi
! fi fi
fi- ff
fffi fi

fi fffi
9fi
ff ffff
fifffi
fi &
fi 9fi fi (fffi
fi fi ff
fi ff (fffi
ff fi fi !fi fffi -( ( fi

fiff
ff
ff fi (fffi
fi fi fi fi
ff ff ff fi fiff
ff ffff (fffi

& fffi ff fiff ff fi fffi
!fi 9fi fi fiff-
fi
& 9ff
fi fi@fi fiff ff
fi fi (fffi
&
fi fi fiff
ff
fi fi (fffi

fiff ff fi (fffi
+ fi fffi fi fi (fffi
fffi fi ; ff

fi fi
ffff
fi fi fi fi
fiff7
fi
(fffi
! fi
fi fi fi fi

fi fi
fi -% fi fffi fffi (fffi
% fi (fffi
ff fi

ff fi fiff

ff ff fi fi fffi%
fi fi (fffi
fi ff fi
fi fi

ff & fi


fiff fiff
fi
@fi
fi fi fi ff
fi
fifi
fi
ff !3ff * .fffi 1- ffff ff fi
fi@fi fffi
fi fffi
9
fi fi
fffi
; ffff fi fi@fi
fi fiffff
fi
ff

fi ff fi fiff fi fi fffi
!3ff * .fffi # 1-
fi
fi fi (fffi
fi fi fiff
fi
ffff (fffi
fi

ff fi ffff ff
! fi- fi ff fi fi fi fi

ff ff fi ff fi fi
fi fi fi fi
ff
fi fffi fi ff fi fffi 8
fi fi fi fi fi ff fffi ! fi ff
ff


ff
ff fi ff - ff fi
fi fi fi fi ff fffi &
fffi ff fi fi fi fi 9fi
fi
fffi
ffff fi ! fi fi fi
fifffi
ffff
fi )fi P * )fi #<% 3ff * . ff #'- ff

fiff fffi fffi fi fiff ffff & fi fffi fi
$ff )6 fi fi
ff
ff . ,
ffff
fi

fiff fi fiff fffi

3 fi fi fffi
fi fi ff ! -
(fffi
fi ff fi

fi fffi
9fi fi ff












7 " fi fi 6 3 4 $$
fi ff
fi


ff 2ff ff


,1

fifi ff fffi
ff fi fi fi ff fi


!G
$ 7 (
fi
ff G fi ff fiff


fi ff fiff fffiff
fi fiff ! #-
% 7 ( fffi
ff
ff fi
fi G ff %ff
# #
fi
1 fi fi (fffi
ff ff
fi fffi
G%
fi
$ #
,

fi fffi

B

'
fi %
<
! - ff ff %


ff ! - fi fi ff fi fi

! ff ff fi fffi
fffi #


##
fi ! - fffi
#1
! -%
#$ %ff


























ff





; ff 17 3fffi fffiff fi fffi fi
fi # & fi fi fi fffi
ff fi ff
fi fi fi fi fffi
9fi
fffi ff ffff fi fffi

( fi
fi fiff ff fiff fi fi
fiff fi fi ff fi fi fi fi
fi
(fffi
!fiff fi- & fi fi (fffi


fi ff fiff fi ff fi fi ff
fiff
ff ff
ff fffi fi ff
ff
fi
)
fi fi
fi
3ff fi .fffi !#-
ff
ff fffi fffi ff fi fiff7
fi
fi
ff
fffi $ff )6 fi fi
ff fi
ff .
, fiff
ff fi fi fi fiff ff
ff
fi
fi9fi
ff !. fi fi #,% 0fi @ * . fi #'-
ff (fffi
fi ff
ffff
ff &
ff
ffff (fffi
ff

ff 5

ff ff fffi fi
ff fiffff 3 fi (fffi
fi fi
ff fi 9fi ff fi fffi fi 9fi

ffff fi ff (fffi
fi (fffi
% ff








8 !
fi fi fi

fi fi
fffi 2 " fi
3 - 4
$$

,2

fi fiffff fi


ff fi fffi
! - fffi fi
ff fi #
(fffi
fiff fi fi fi
fi fffi
fffi fiff fi fffi ff fiff
!fi
ff
-
ffff (fffi
fi fi
ff
fiff fffi@ fi fiff ff
fi
fi ff
9 fi ff !fi ff

- ; ff 1 fi ff fi ff

fffiff
3ff fi .fffi !11-
ff
ff ff fi fi fiff
ff (fffi
fi
ff fifi
ff
ff ff ff 5(fffi
fi &(fffi
& fiff

fi ff ff
fiff fi ff $ff )6
(
)fi fffi *

ff
ff
& fiff ff ff fi fi 5(fffi
5(fffi

fi fi ff ff fi fi fi

ff ff ff fi

ff ! fiff fffi

fiff

ff

ff- ( fi

ff fi fi fi fi
ff
fi fi ff 4 ff ff fi
!fi fi ff
fi fffi
fi fi - & ff ff
fi fi fiff fi fffi
ff fi

. fi fi fi 5(fffi
ff fi fi fi !
fi ff

- ff fi fi
ff ffff
fi

>
? ! fi
- 5(fffi
fi fi=fi

fi ffff ff fi fffi fi fi fi fi
fi ffff
ff fi ff
fffi

+ fi fi fi fi fi
5(fffi

fi fi ff fiff fffiff fi fi
ff fi !; ff . $, fi fi
- ffff ff fi
fi ff ffff 5(fffi
fi fi ff fi fi

ff

ff . fiff fi ff fi

ff

ff fi +
ff fiff fi
ff fi
fifi fi
ff ff fi
fi ff
& ff fiff fi fi fiff fi ff

fi fi ! ! - - ff ff fi fi ! ! - -
fffi ff ff fi fi ff fi
fi
ffff
fi fi fiff fi4 fiHff fi 7
! - J
!-E
!-E
!! - J
!- J
!-E
!-E
!& 9ff ff fi fffi
fi !
-
fi !
- fi ff fi fffi







































































fi














fi




















fi

9 . fi fi fi fi fi
fi

.-

fifi ff fffi
ff fi fi fi ff fi


ff fiff
fffi fi fffi
!
- &
9 ff fiff ff fi@ fi ff fffi
fffi
! ff . $'-

fi ff ff fi
fffi fffi4 ff
fi fi fi fffi fi fi fi fi
fi fi
fiff
ff fi
fi fi > ? fi
ff fi fi fi fi fi fffi fi fi
fiff ff ff ff fi fi
ff fffi4 fi ff 9 fi fi

ff
fffi fifi
ff fi fi
fi
& fi fi ff fi

fiff fiff fffi
fi ff
fi fffi fi
ff ffff &(fffi

9ff ff fffi
fi fiff ff fi fi
fi ff
ff fiff 9 fffi
fi












ff ff ffff

.

fiff fi fi fi fi fi ffff fiff fi fffi

& ff ff fiff fffi fi
fi fffi
fi fi
fi fi fi ff fi !#-

ff
ff fi !1-
Q
ff ff fi 5(fffi
fi

ff
fi ! fi

ff
fifi ffff

ff

ff- &
fi fffi fi ff ff ff

ffff fi ff ff 4

fi ;ff fi
ff
!#- fi

ff
!1- & fffi
fi
ffff
fifffi
fi !
fi ff
ff - fi7
& fi ffff
fi fiff 9 fi fi fi ff
ff
fi
ff fi Q
fiff fiff fffi
fi
ff
ff
ff fi $'$" fi fi




fi
# ffff fiff ff ffff
&
fffi
fi ff fi Q
ff $'$" 9 4
fi fi ff fi fffi
fi
ff
ff

ff

ff ff fi fffi
fi fi fi ff

fi ffff
fi

ff fi
ff fi
fi fi fi
ffff fi fi
ff
fifi

& fi fi fi ffff fi ff
ff fi fffi
fi fi fi fi ff fi ff ff


ff
ff
!#- fi !1- fiff fi fiff
fffiff ffff fi fffi
fi fffi
! ff fi
-




















ff



ff







$ . fi
ff fi
fi /"# fi
fi fi # fi ff fi fi
: fifi

fi fi

.

fi fiffff fi

+ fi " ff
! -
ff fi fi


ff fi ! fiff ff fi
ff fi
ff fi fi fffi
fi- N fi fi fi
fifffiffff

fiff ! (ff * K ##% ) ff * + #1- " ff
! - fi
ff fi 9 fi
" ff
! - J fi
! - fi fiff %
ff fi

8 fi fiff ff ff
fffi

!!! -
ff
! -
; ff $ fi ff ff fiff ff
ff fffi
fi fi
fifi fi
! - fffi %
! -
ff % ! - !
- 4
%
! -
fi fi fiff ff fiff
fi fi fi
ff !ffff fiff ff -%
! -
fi fi ff fi ff ff fffi ff
! - !
! - fi fi ff- & ff

fffifi
ff . $$
3 fi fi fi fi fi fi $'$" fi fi

fi
fi
fi
fiff ( J
ff7
fi fi
fi ff fi fffi
fi fi ff $'$" % fi
fffi fi fi
fiff fi fi fiff fi & 9ff ( fi
! -
! -
( fi fi ff fi . $1$ fi fi
fi fi fi fi ff 7 9ff
fi fffi
fi ff

ff fi
fi ff fi
ff fi
ff ! " ff
! -- &
fi ffff
fffi
fi fi fi >ff ? fi fi fi
ff ff fi fffi
! -
ff
ff fi ff ff fi
ff fi " ff
! -
fi ff
ff fi fififf
ff ff
! -
fi fi fi ! -fi fi fi7 !- fi 4 % !- fi

ff
fiff fffifi ff $'$" % !- fffifi
ff

ff ff fi ff fi fi fi fi ff
ff fi ff ff

ff fi
ff
ff $'$" !

fi
! - ff fi
ff -% !- ff fi
ff

ff
ff ! @ " ff
! - fi-
ff ff fi


! - J
! -Efi
! -fi
















fi









fi



ff ff



!

"




#$$

$







$







%

#

ff

#& fi

#

%

#& fi

ff

%

#

'

$

'









#

#



'



( )

)



)



ff













ff





( )

#'%* +


* #,



fi

ff
4 fi ffff )"* fi
fi 4 fi fffifi
ff
-

)

#





fi fi

fi fi

.

fifi ff fffi
ff fi fi fi ff fi


fi !
$7 ( fi fi ! - fi fi fiff ff fiff fi
ffff &(fffi

!$'$" - fi

fi ! -%
%7 ( fi fi fi fffi ff fi fi fi fi ff ff
fi fi fiff fi fi fi fi ff

#
! -%
1
%
%
$
! -%
,
!- %
B

J
'
fi fi
%
<

! -%

fi ! !
-%

ff ff !
#
! -
! -E
!
-%
##
!
-

%
#1

! -%
! -E
!
-
%
#$


#,

% + + fiff #

%



#

ff

%

%

* #,
fi )


%

%

-

+ + fiff #& fi

#

#$$

* #,

* #, fi )


%

-

)

%



-

( )

'

"



fi

#& fi
-

#$$

-

$ '

#

'

+ + fiff #& fi

!



#$$
* #, $ '

!

#& fi

; ff $7 (ff ff
fi fffi
fi fi fi fi
ff
ff fi $'$"
fi
fiff fi ! -
! -
ff 9ff fi fi fi fi fi
fffi fi
! - fi fi fffi

ff fi ff

ff

'

#

'

( )

$ '
)

J ff fi ff ! - fi fi ff ! ! -

8 fi fi 9 fi
fffiff fi
fi
ff & fffi
! - ff

ff ! - fi ! - fi
ff
fi fiff fiff fifffi

ff ff fi ffff fffi
fi ff
ff
K ff !- fi !- ff 9
fiff Kfiff !fi !- ff fifffi ff fi fiff
fi fiff
fi fi fffi fi
ff fi fi fifffi fi fi
#



)

#$$



"



#

( )

"

-

"



-

(

fi fi

fffi ;
fi
ff fi fifi
fi fi fifi
fi ! ff fi fi
fi fi

.

fi fiffff fi

ff
ffff fi
fiff fiff fi fi
ff
ff fi ff ff

ff fi
ff
fi
ff fi fi ff fi fi fi fiff + fi
fi fi ff
ff !- ff
fi
! -fi +
9 ff fiff
fffi
ffff fi

fiff fi fifffi ff ff 6)N fi fi
fi

ff !fi ff
ff fiff fififi ff
fi -
.
# , fi #$ fi fi fiff ff ff fi fi fi
& ff ff 9 fi fi
!fi- fi fi fi fiff fifffi ff fi $'$" !
#-%
! - fi fiff ! - ff ff fi ff fi fi fi 4
fi fi ffff )"* !
,-%
!- fi fiff ff ff
fi

fi fi ff fi fi !
#$-
& ! - fiff

M# ff fffi
fi ff
fi 6fiff fiff ff fi fi ff ff ! -fi fffi
fi ff $'$" !
! - - ff fi

J ff
fi ff fi ! #1- ffff fi
ff fi

fiff
fi ff fi fi fi
fi
ff
H fi
ff ff fi
.

fiff fi fi fi ffff &(fffi
fffi ; ff
, ;ff fi fi fi fi
fi ; ff , fffi
fi ff
fffi fi !
ff

ff fi
ff
ff - &
fi ff fi fi $'$" @ff & fffi
fi fi
fiff fi ffff
fi ; ff , .
ff fi fiff ff
ff
ff fi fi
% ff
fi fiff ff
ff
ff fi fi fi fiff ff ff
fi fi
ff% 9fi fffi ff fi fiff ff
ff
ff
fi fi fi fiff fi
;ff ff fffi fi fffi
fi ff ! - fi
" ff
! -
!fi ! ! -- fi
J
!fi !
! J
-ff
& ff fffi fi fiff fi
!fi ! ! --

ff ! - fi fi


! - ff (ff ff +
! -
ff $'$" 9ff fi
1
ff ff . fi fiff fi fffi
ff .


fi ffff fi fi ff !ff fi
.,


(

fi

%

%

ff

fi )

)

(

%

%

fi





ff









fi



ff



"





#

" + + fiff



#

fi + + fiff

"

$







" + + fiff

"

"







%





ff





#

fifi ff fffi
ff fi fi fi ff fi






!

















fffiff



Unsupported
precondition

5


mutex



9

























$
7$
$$
&$
$
7$
$

"









,




!



.





/

mutex



,

.







/



0






1













r



r






fffi
$
7$
$$
$
9$



2



-





.

0

















; ff ,7 ( fi
fffi fi . fiff ff
ff fi
ff ff
ff fi % ffff

%
ffff

ff fi fi fi fiff ff
ff fi fi
ff% fffi fiff fi


! -
<- Ffi fi fi fi fi
ff ff fi fi fi


ff & ff fi
fifffi $'$" Kfiff ff
ff ! % -

fi
% fi fi & fi fi % fi

ff $'$" fiff fi fi ! ff ff fi fi
ff ff fi
fi -
Kfiff
ff fi fi fi fi & fi '
& fi fi fi
ff ! - fi fi 4 % fi fi
)"* ! fi fi fifffi fi ! ! -- & ff

ff fi $'$" . fi
! & -fi J fi fi
! '-fi J
#
! - & 6 !fi ! ! -- % &


" ff
! - ff (ff ff +
6ff fi ff " ff
! - fi !

%
fiff ( fi ) .
ff
&
-

fi fi ff fi


fi
4




fi
fi



! fffi
%
(
&
..
(









ff







ff









"



+ + fiff

fi

ff

(





#

fi

" + + fiff
















+ + fiff





#

fi fiffff fi


fi
ff
ff - fi " ff
! ( -
fi
fi

ff ( fi fi ff ff
fi % & (

"fffi , ff
!+ ff fi fi
fffi fi ff ff fi ! ! $'$" - (ff
fffi fi
9 fi ; ff , fi
fi
#
! - J 11 ( fffi fi fi ff ! - ff ff
fi fi
ff ! fi fi - fi
% ! fi fi % - fi fi
ff % fi
#
fi ! ! %- $'$" -- B fi fi ! fi
! - fi fiff ff ff B
fi fi
ff fi
# fi ! ! - $'$" -
! &- J #< fi
fi ! ! %- $'$" -- ff ff B

M# ! - BE# ! fffi % - fi fi
#$
#<
#
2 ff ff fi fi


ff ff
ff %
#< fi fi
#$ fi ! ! -
11 #<E
<
J 1,
( fi 9ff
fiff fi
fi

ff
! & - $'$" %
- fi


ff
& & ff ff fi !
& ff ff %
#< fi
ff & fi
$'$" ! - fi fi fi fifffi )"* ! % - ffff ! - J #B
fi
! - J #< fi & #< E $ J 1 (
#$
fi ! ! -
1, 1
fi
fi
% &
1,









"

"

ff

fi

"









"





ff

fi

fi





"

fi

"

fi



ff



ff





* #,









" + + fiff

* #,







"







ff









ff
fi

fi



" + + fiff



* #,





ff




( ff ff fi fi fi fiff

fffi ! -
fi ff fi
ff & ff fi fi
fffi fi fiff 9 fi ff fi fifi fiff
fi ff fi fi fi ffff &(fffi
ff ff
! *ff
ff - 8 fi fffi fi fi ff
fi fi ff fi ff fiff


ff fffi
&
ff ! - fi fi fiff
fi ff fi fi fi fiff fi
fi

ffff fi fffi
&
ff ! -
fi fi fiff fi
ff fi

ff
ff ff ffff fi fffi


ff fifi
&
ff ! - fi fi fifi fi
ff ff

fi

ff fi ff
fi fi ! ! -- &
ff ! - fi fiff













fi







fi
















&







/fi 2 ff ff ff fi 6
ff fi fi

./

fifi ff fffi
ff fi fi fi ff fi


! $ 7 ( fi fi ffff &(fffi

%7 (
fiff ff fi fi fi fi
fffi fi
! ! --%
#

1
fi ! ! -%
$


! - fi L fiJ

%
,

! -
%
B
!
-
%
'
fi !
!! - -%
< ! - E
! -




$

+ + fiff
'

" + + fiff

* #,

* #, fi

* #,

#

#

$





'

'



'

fi + + fiff

#

'

fi #

!

! $ 7 ( fi fi ffff &(fffi

%7 (
fiff ff fi fi fi fi
fffi fi
#

! ! --%
1
fi !
!-
$





+ + fiff
'

$

. + + fiff

'

; ff B7 (ff ff fi fiff fi
fffi ff
ff !- fi ff fi ! - fi fi
fi
fiff
! - ff 9ff fi
fi 9 ! - fi
fi fi fi
fffi fi


fi
fi 9 . $1#
! -

ff fi

ff ff ff


#

'

'

'

$

$ !

fi

.


ff
ff fi fi

ff ff
ff ffff fi fffi
ff ff fi 9 fi 7


!
J
!

!-
!-J
!! -
! - J fi !! --fi E fi
! -fi


!
J
! !

!-
!- J
! ! -
! - J fi ! ! --fi E fi
! -fi
ff fi fiff 9 ; ff B ff ff
fi 7 fi ! - fi fi fi fiff
- . fiff ff ff ff
fi ff fi !
.0











fi














fi














$



#

&













$

#











&





&





fi









fi




#

$





fi fiffff fi

fi fffi
fi fi
ff fi

ff
ff ff ff ff fi fi fiff fi

ff

ff & fffi
fi fi
fiff
fi fi ff . $1#
! -
1
(ff fi
fi $'$"
fi
fi fffi
fi ! - ff fi
ff
fi ff $'$" .
$M,
fi fi fiff fi
fi fi fi ff fi fi
ff
! - fi
! - ! - .
BM'
fi fffi
fi ff " ff
! - fi
fi fi fi 9ff fffi
fi

ff fi fi fi fi ff
fi ff fiff
ff

ff !
ff


ff
fifi 4- fi

ff
! -

ff fi fi fi ff
fi ff
fifi !

ff
ff fi fi-
. fiff fi fi fi fi

ff fi fffi
ff

ff
fifi
ff fi 2ff fi fi ff . $#

ff ff

ff ff fi fi fiff
ff 2 fi fi fi fifi
fi fiff ff ff fi
>4?
ff
fffi
ffff fffi
ff fifi fi
; ff , (
. $11
fiff fi

1 % &
1,
!
fiff fi ff ff fi ! ! -- (
$


fi 1$ ! fi
fffi fi fi fi
&(fffi
fi
ff 1$- .
,
1$ 1,
fi
fi !
$'$"
% &
- fi
' ff ff % & (

ff fi
fffi fi fi ff ff fiff fi
fi4 fi & fffi $

% & (
1, E $
#
+ffff)

, fffi ff ff

& ff
ff ff
fi fi fi
ff fffifi ff fi fi ff fi ff
ff fi fi fi ff $'$" !
! -- fi fiff ff fi
fi
ff
ff

! - ff J # fi fi fi
fi ff fi ff ff fi ff fi fi

fi
ff ff fiff fiff ;ff #
! - fi

ff fiff fi
fi fiff ffff &(fffi

!fi
ff - . ff fiff fi fi fi fi fi ff

fffi fi
fi
! - fi
; ff ' ff fi ff ff fiff ff

! #- ff fi fi fffi4 fi fi

.1






$

ff

'





ff



$

'









.

'





" + + fiff







ff

* #,



















ff



















+



fifi ff fffi
ff fi fi fi ff fi


ff fi ff ff! $7 & fi fi
fi
ff ff fffi ! - fi fi ff
fi
fffiff !-%
%7 ( fi ff fi !
- fi fiff
!
- ff ff fi fi fi ff
# ff fi 34
ff &%
ffffff
43
1

ff
! #- %
! #- %
! #- %
$
,

! #- #%
B
%
% %
'

J
<
%



J ff fi ! -



fi fi %
#
fi ! ff
!
! --%
##

! #-%
#1
ff ff ! ! #- ! E
! --
#$

ff
ff
! #- E
! -%
#,
#B

ff
ff
! #- ! E #-
#'
! #- E #%
#<
! #- %
#

!- %
#

%
+

+



fi

+





+



fi



#





-

+ -
-
-

+ #

#

- -

# "



-

#



+ "

* #, fi
fi




#$$





-
fi
!
fi



-

-




#$$






#

-
-
#
#


!



-

fi ! ff
! $7 ( fi fi fi fi
ff %
%7 ( fi ff fi ff ff fi fi fi
ff !)"*-
#
%
1

%
$
J
,
fi %
B

! #-%
'


%
<
!! -%

!fi
fi-
+ %

+

%

%

+

#& fi
%

%

+

%

)



%

# )

#& fi
%

%

#& fi



"

+

#$$

#& fi

; ff '7 (ff ff
ff ff fi fi fffifi fi
fi

.2

fi fiffff fi

fi
fifi 4ff ff & fi fiff ff !ff-

! - fiff fi fi ffHff fi%ff fi # ! # fi

fiff fi
! -- fi
! #-
ff fi ff ff ff ff ff fi fi
fiff
ff fi fffifi ff !
! #-- fi
! #- fi fi
fi
fffi fi ! ! -- fi

ff fi ff
ff fi
fi
! - 9 fi fi . 11 & fi fi ff fi fffi
fi fiff fiff fi fi

ff
ff
9 fi fi fi ff fi
ff 8 fi
! #-
fi fi fiff fi !ff ff ff - ffff
&(fffi

:ff fffi fi fiff ff
fffifi ff fi fi
ff
ff fi fi
ff
fffi fi fiff ff ( ff fi fffi

ff fi ff









$



+

fi

+





fi

fi





fi

fi



ff



ff

fi

;ff fiff 9ff ff
ff fi ff ff ff
fi
fi

#M,
! #- ff fi # ff !fi fi
fiff fi@
fffifi - &
BM# fffi ff fi fi fiff
fffifi ff fiff J fi ff fi fi ffff
fffiff
ff fi fi fi

fi
ff fiff
fi ffff & fififi fi fi@
fi
fi !
B- fi ff fiff fi fi fi

fi !
#- &
fffi
!
M#- fi

fi ffff
ff
fi fi

#


fi
fffi
ff
fi . fi fffi
fi ff fi 9
ff fi fifffi + fi fi ! fi ffff
fi fiff fi

fi - fi

fffifi ff fi ff 4 fiff ff
fi ;ff fi ff fi ff ff fi ! ff ff fi ! ff
!
#- &

fi
! #- ff fi 4 !
#1 #BM#'- fi

fi fi fi
! #-
ff fi ff E # fi ffff fi
! #- E # fi fi fifi ff ff&fi ffff
fi fi ff !
! #-- !
#<-
;ff fi fi fi fi fi
! #-
!
$- fi !
ff

ff ff fi fififf
ff fiff ff



fi





+



-

+

-

+

-

-

#

#

-

-

-

-

-

-



#

#

-



"

+























+

#





#

#





'


fffi

fi 0 < fi fi
fi fi
& fi fi
fffi ff
fffi
ff fi
fffifi 1 = > fi ff fi fi fi

fffi
fi fi fi fi
fi
fffi
! fi fi fi fi

/-

fifi ff fffi
ff fi fi fi ff fi


fi
ff ! - fi & ff ff fi ff
fi fi !)"*- fi fi fi
ff fi fifffi
!
- ( fi fffi ff fi
ff
fi fi fi ff fi ff 4 fi
fifffi !
<- &ff fi fi ! ff
fifffi fi ff
fffifi ff
! #-
fi fi fiff
! #- .
$ ff
fi ff ff fi@ ff fi fi fi fi & fi ff
fi

fi fi fi fffiff
ff ff fi fi fiff

ff fi

fi fi fi ff ffff fi

ff !
##- ;ff fi 4 fi fi ff ! fi
- ff fi fi fi
fffi fi ff fi
fffi
#$M#,
! #- ff fi ! fi fi fi ffff fffi
fi

fi ff -
&
ff fi ff ff
fi ff fi
fi fi
ff H fi ff fffi .
#


fiff !fifi- ff fi fi fi fifi
@ fi fi fffi
fi !
ff
!fifi- fi
ff fi ff ff
!fifi - 2ff fi
ff fi ff fi ff fi ! ff
ff
fi ff ff ff fiff fi fifi ! fi ff fffi fi
fiff
ffff fifi- ;fi ff fi ffff fi
fiff fi ff ff fi

fi fffiff
ff fi fi4
ff
ff ffff
fi fi fffi ffff
; ff < fffi fiff fi fi
.

fi fi fi
fi fiff ) fi fi fi fiff ( ff ff
fi
ffff
ffff fiff fi

fiff & 9ff fi fi
fiff fi

fiff fi fi ff
ff fiff fi
&
fi
ff @ff fi fi ! ff
fi


ff ff @ff fffi ff
fiff
fi fffifi
ff fi ff fi 4 fi
fiff fiff ff 4 fi
fi
fi
. fi fi ! - fi
fiff !fi- fi
#, fi #' ff .
fi fi
#,
! - # ! fffi - fi
#'
! - # ! @ff- ffff
! #-
#< & 4
fi fiff fi fiff
(
ff ff fi fi fi

fi fffi

ff fi
fi
&
fi fi fiff fi

fi % & '
6ff fi

fi % + fi
fi fi
# 1 fi fi ! ff
! ! % -- )"*

! fi ff
! #- J
! #- J fi fi
ff
fi fiff - &
! - ! fi
fffi fi
fi fi
ff % $
fffi %- fi
! - $ &
4 fi & fi ' fiff fi fi fiff fi 2ff ff
! &- 9ff $ fi & fi ff 1
fi
/
%

%

+

%

#

%

+

%

+

fi














-



fi





+

/

/

/

+











-

+











+



fi



fi










#





-

-

-



#





-



#





+ "



+

#

+









fi

#

















fi fiffff fi

' ff




.








0












6



fi

fi



fi
fi



fi
fi




fi



fi




fi

5 ff
..0.111,-



.

0



(2)

(7)

.












ff fi

-





2

.

(2)







(1)

(1)













/



(2)



-








(3)

(1)



(1)

,










(1)

(3)

(0)

-

,



1




(0)

1







.



/

0



1



; ff <7 ( fi
fffi ff fi ff ff & ff
fiff
fiff
fi J (
& ff
fi fi
ffff
ffff fi




000

fi ' (fi
! &- 9ff #1 fi ff
! #- 9ff & fi '
6ff
ff fi fi

fi fi ( fi ! ff
fi


! ( -
# ff ff ' fi )"* fi
ff % & '
.
## ff fi ff ff

! %- J #1 fi
fi ff 4 (
fi 'E#
#1E1


fi

# &









"



fi



fi





ff
fi ff ff

Iff ff fi fffi fi fi !ff fi fi- ff fi ff
fi fi fi
ff
fi
fiff
!: * 34ff
1#- !24 fi * 8 1#- fi !/ * 0fi fi
fi 11- +

fiff ff fi ff ff fi

fi fiff fi ff fffi
fi fi
fi
ff ff fi !
fi - & fffi
fi fiff
fi fi fi fiff fffi fi

fffi
fiff fi 9fi 4ff fi

/




fifi ff fffi
ff fi fi fi ff fi


: * 34ff
ff
fi ff ff

fi
!fiff- fi fi fi fi fi
fi ff fi fi ( 2fi fi 34ff !1-
fi fiff fi

ff fi
fi fi fffi
ff ff
4 fiff ff ff
fffi fi fi fi fi
fi
ff fiff fi fi fi ! fi fi -
fi ff fi fi 4 ff : * 34ff

fiff
fi
( 4ff fffiff
ff ff fiff ff

: * 34ff fffiff
ff
fifi ff
fi ff
ff
fifi ff
fi fi

fi ff
ff
fifi fi ff ff fi
!ff

fi

fi fi fi fi

ff
fffi ffff-
& ffff fi ff ff fffi fi fiff fi ff fi
fffifi : fi fi

#< fi # ff fi
ff ff fi fi ff fi fi
ff fi fi fi ff
fi fffi
ff
fifi 2ff
fi
ff
fi fffifi ff fi fi !ff-
fi ff fiff
(ff
fffi 4ff ff ff fi ! ff
fi

# ff fi fffi fi
ff fi ff
fi fi ff
ff ff ff
fi ff

fi fffi
fi ff fi ff
fi ff & fi fi fi ff fi fi

fffi ' fi
fi fi fi fi
fffi fi fi
;fi fiff 4ff ff fi fi fffiff
ff
+ ff !- fi fi
ff fi fiff : *
34ff fffiff
ff ff

fi fi & ff
ffff fi fi fi

ff fi
fi ff fi fffi
( ff 24 fi !1#- fffifi fiff fi

ff fffi fi

fiff ff fffifi ff fi fi
ff (ff 4ff ff
ff fi
ff fffi
fi + fi fi fi fffi fi
fffi
fi ff ffff fi fffi fffi
fi
fi
ff fi
4ff ff

fi fffifi ff fi fi
fi fi

fiff fi
fiff ff fi ff ff fi
fffifi !
fiff fiff fi ! ff
ff fi
fiff fi
ff
ff fi

fi fi fi fi
fffiff
ff fi fi ff ffff fi - (ff 9fi
4ff fi fffifi ff fi ff fi
fffi
ff ff fi ff fi fiff ( fi fi
fi
fi fiff !fi
ff ff fi
fi fiff
ff
- fi
fffi fffi
fi fiff
























#





%





%

















(

5 . fi ff $ ff fi + fi ,
fi fi
fi ff 1 fi
fi ff

/

fi fiffff fi

fi fi fi fi fi fi

fffi
fi ( fi=ff fi ff
ff fiff
fffi fiff fi fi
ff
fiff fi fi fi
fi fi fi
fi 9ff
fi ff fifi ff fi ff fi ff ff
ff 6)N ! ff fi
ff ff . $'-


-fiff
.fi
#ff
fffi ff /ff

ff fffi ff fiff fi ffff fffi
ffff &(fffi
fi
fi fi fi fiff

fffi fi
fifi fi fi fi ff fiff
fiff fi fi fi
ff

ff fi
ff fiff fi fi
L ffff ff fi fi fi
!! -
fi L ff !
!! -- fi L
fiff
ff ff fi ffff fffi ff ff L
& fiHff fi fi fi fi ff fi
ff ! -

fffi fi fi fi fi fi fi fi !ff ff ff-
ff ffff fffi L Ffi fiff ff ff

fffi fi fi
ffff fi
fffiff
ff
fifi fiff
ff 4 fi
fi fi !ff
fffi
ff fi 4 - fi fiff fffi L fiff fiff
ff
ff
fi ff 4
fi fi
ff ff

fffi ff ! - fi fi
ff

fffi fi fi !fi-
ff fi ! - fi
ff
fiff L
fffi & fi 4
fiff ff fiff fi

ff fi
ff ff

fffi fi ff fi fi fi ff fi

ff

! -
! - ;ff fi

fi ffff

ff

ff ( % &(fffi
; ff # ff fi & fi
, ! ; ff - & fi fffi ## fi
ff ) .
! )- J
#1
! ( - 1$
ff
fifi % fi 4
! % -
1< ! - ff 11 ! ! -- ! - ff 1< ! ! % --
! ) - ff fi #1 ! ! --
.
fffiff fi ff $ff )6 fi !
ff-

> ? ff > ? fi 4
> ? !; * 5 1$-
ff
fi fi ff fi fi fi 4 fi fiff ff fi
fi ff 9
fi fi
. 11 ff fi

ffH4 +
fi fi fi fi
ff
( 9
! -

!! - fi
! - + 9
!
ff
fiff fffi fi
ff











ff







ff






fi











fi











fi



fi











fi



fi

fi

fi

fi

fi

fi

fi

fi

fi



fi



!

fi

fi

fi

7 fi fffifi fi



fi
fi
2

/,

fifi ff fffi
ff fi fi fi ff fi


Level 1



Level 2

(0)

(50)
(50)
[50]



(0)








(50)





(0)





(120)
[70]



(0)





()







(0)









()





(0)





(0)







(270)
[40]
(230)





(120)









(120)









(120)



(220)




(220)


(220)




(220)
[100]

()



(50)



(220)



Level 5

(120)

(120)



mutex





(50)

(230)
[110]

(0)

()



(270)

mutex



Level 4

(50)




Level 3



()



(220)

(220)











LJ


%

%


%



%

& &

%

%


%





%


; ff 7 N
fi &(fffi
; ff # fiff fi fi & fi
,

ff
ff ( % /fi ff fi

fi fiff fi K fffi fi
fffi fi
fi fi !ff- fi fi ! fiff- &
ff fiff fffi ff
ff fi fffi >!M-? fi fi
ffff
fi

ff






fi fi fi fi 4
fi
! -

fi
! - fi ff !#-
! - ff fi fi


ff

fi
4



!1!
! - ff fi

fi

ff fi 4
fi !$- ! !! fi

ff fi fiff -
+
ff
4ff ff fi 4
4ff ff
fiff
ff fi
9fi fi fi fi
fiff
fi fffi
) & ff fi
fiff $ff )6 fi

fffi
fi fi
fiff fi fi fffi fifi
fi ffff
fffi fi fi fi fiff ff + fifi
fi fi ffff fi fffffi fi ff




fi

fi



fi







fi



!

fi

!



8 !

fifi


fi fi
fi
fi fi fi fi

ff fi

? fiff
fi fi fi
fi
fi ff

/.

fi fiffff fi

fiff fi
fi 2ff
ff $ff )6

fffi

fi fffiff fi
fi4
fffi
fi
fi 9fi K fi fffi fi
fiff
ffff fi
& fiff
fi ffff fffi 4ff
fi fi
fffi

fi F
ff fi ff .
& fifffi
)ff fi fi ff fffi
fi fiff fi #R
ff ! ff fi
fi- fi

ff ffff
fffi ff ff
fi fifi
fffi ff fi
fifffi ( fi ff

fffi ff fi fifi
ff fiff ff
fi
ff !3ff .fi * .fffi 1$-
! (
ff ff /ff
ff)
ffA ff fi
ff fi 4
fffi fi + fiff fi ff ff
fffi
ff fi
4 fi
fi ff
fffi fiff ff fi
ff fi
ff
ff fi fi
fi fi ff fi
fi fi fffi fifffi fi
fiff
! - ! - ff ! - fi ff fi !
fi- fi ! - J

fi
fffi ff ff
ff fi fffi fifffi
( fffi
ff fi fiff
ff ff fifffi fi
fffi ff ( fffi
ff fi ff

ff fi
fiff fffi
ff fi ff J
fi fffifi
fffiff ( fffi
4 fi ff

ff ff fi fifffi ff 7J EJ J J J
fi
fi
fffiff ! fi 6 fi- fi ff fi fffi
ff
ffff fi fffi fi fi &(fffi

fiff ff
ff
ff fi fffi fifffi ;ff fi
ffff fi fffi
fi fi fffi fifffi ff ff fi fffi fi
ff
ff fi ff fi & ff
fffi fi fi

! - & fi fiff ff fi

fi fi fi

ff

fiff
ff fi fi ffff ffff

& fi fffi fi fi fi
!- fiff
fffi ff fi ffff
fffi fifffi fi fi

fi
ff ff fffi . fiff fi fifi fi fi
! -- fi fi
ff
fi fi fiff ff !
fi fi 9 fi fffi fi J
!! - ff
fi
fi fi fi fi

ff fi
( fffi
ff
fi fi fi fi fi fffi










0 0 0





1








ff


1


























2



1















$



ff

$













ff



9 /fi ff ff fi fi
! fi
fi fi

fi ff fi fi ff fi 4

/"# fi
fi : ? fiff )"# fi ff fi

fi

//

fifi ff fffi
ff fi fi fi ff fi


Fff fi fi fiHff Hff fi fi

Hfffffi ff
fi 4 fi fi fi fifi fffi fi
fi & fi fiff
ff
fifi fffi

/ ff
ff
fifi fffi
ff fi

ff ff


ff ffff fi fi fffi fi fi4 fffi fi
fi fi
fi fffi fi
& fi fiff
ff fifi fi

ff fffi
ff

J
fi fi 9 fi fiff fi fffi
fi
ff ff

ff fi fi fi fi ffff
ff
>fi
? fi

fi fiff !


ff -
ff
ff fi fi fi fi ff ! ff
fi fi

ff
ff fi fi

ff fi fi
ff
- + fiff ffff fi ff

ff
fi fi fi fi
ff fi fi fffi
ff
+ ffA ff
fffi
fi fi
ff fffi fi & fi ff fi fi
fffi
ff fi ff
fi . ffff ff ff fi
ff ff ff fffi
ff ff
fi fifi
2 fi ! ff- fi

ff fi
fi ff fi fffi
ff 9
! - !
. $1#-
! - ff
fi # fi fi
fi fffi
ff fifi # !I ff fi ff fi

fi ff fi% fiff ffff ff fi ff
fiff ff
ff fi ff ff ff fffi
fi fffi
ff(ff 4ff 9
! - fi fi fffi
ff
fi ff fi

ff ff ff fi fi
fffi fi
fi
ff ff
& fffifi
fi
ff fi ff
fi 4 fiff ff ff
fi fi ! ff

fffi- fi fi ff fi fi fi fi

fi ff fffi fi + fiff ff fffi fi fi $'$" J

!! - fi ff fi fffi fifffi fi fi
fffi
fi ff ff $'$" ff H fi
fi fi fifffi fi fi fi fifffi fffi
fi &
fi fiff fi fffiHfffi ff fi fi fi fffi

fi .
9fi 9
fffi fi
fi fi fiff
! - fi 4 fi fi fffi
fi fffi
fi@
fi fi fifffi fi fi fffi
% fffi
fi fffi
/ ff ff fi fffi
fi
ff fi fffi
ff J


ff fi fi
ff
fi fi fi fi
fi fi fi






















)



( )



( )

)

)

)

ff

$



ff



















































$ . fi fi /fi
fi !
fi ; $$

fi fi ff fi fi
$ fi $
fi ff

/0

fi fiffff fi

fi
ff ff fi fffi fifffi ! J
-
ff fi fi H fi fi fifffi
fi ! fi fi fi fi
- . fiff
ff fiff fffifi
fffiff
" 0
1#

ff ff ff 2ff
,
( fi ff fi

fffi fi 4ff
fi fi fffffi ff
fi fi fi fffi & fi fi
fi fi
9 . $1 fiff fffi
fffi
fi
fffi fi fi ff fi@ ff

fiff .
9fi ff fi fi ff fi
fi ! fi fi ! - ff ff fi fi fifi -7
!-J
! -E
! -E #
!

ff fi fiff fi fi fffi
fffi
fi
fffi ff
&ff fi fi ff ff fi
fi fifi ff ff
ff 9
fi ff ff fi@fi

ff & fiff #
fi #
fiff ff fi@ ff
fi fi fi ff fi # & fi
9 fi
E

ff
! - fi fi 9ff !- ff ff fi &(
fffi
ff
ff ffff
fi fffi
%
9 fi fi fi
ff fi
fi
ffHff fi fi fi ff fffi & ff
fffi
fffi 9ff
@fi ff ffff
fi fi
fi fi fffi fiff fi

fffi fi fi
fi ! fi ffff fi
!-E
! -ff E
! - J *

E
!+ ff fi@fi 9ff ff ff fi
fi ff ff & fiff fiff fi
fi

fi fi ff fi fi fi fiff
ff
fffi ff fiff fffiff fi
@ fi fi
fi

fi ffff
fifffi
fi fi fi
ff
fiff fi
ff fi fi
fi ff fi
fi fi
ff

ff ff fi & 9ff
fi fffi fi@ fi
fiff ff fi
fi ff fi fi & fi
ff fi ff fi

ff fi
fi fi fiff fi

fi fi

fi
fiff !fi
fi fi ff fi 9 fi fi ff- +
fiff fi fiff fiff ff &(fffi
ff
ff

ff
fi fi ff &(fffi
fi@ fiff . fiff ff
fiff fffi fiff ff ffff &(fffi
fi fi
fi
fi
ff
fi
ff fiff fffi &
/1













































3






3










3



fi














3

2

2







3





3





4





4













3











0



3

fi






fifi ff fffi
ff fi fi fi ff fi


fi fi fi fi fiff ff ff fi fffi
ff !#-
fi

ff ff
ff fi !1- fi fi
ff


ff fi fi & fiff fi fi fi
fi
fffi ff fi ff
ff fi
ff
ff fi ff ff
ffff
fi fi fi ff
fi
fi fi
fi
$ff )6 ff fi
ff fi
ff 9ff fi
fi fffi 9 6)N & 9ff fi
fi ff
fiff fi % fi fi fi
9ff fi fi
fiff fi fi ff ff
ff 6)N fi 9ff & ff fi fi
fiff

fi fiff .
fiff ff
ff ff
fiff ff fi ff
ff fifi ff fi fi fi ff ff ff fi 6)N

fiff fiff fi fi fi fi !#-
9ff ff ff 6)N fi fi ff
fiff fi fi
ff fi ff
fiff fi !1- fi
fi
ffff fi fi ff
fiff ff ff ff 6)N 9 fi
ff fi ff fi fi ff
fiff
ff 6)N
'

'

3

3

'

3
3



( ff fiff
& ff 6 fi fififi
ff *ff*
ff(*ff
ff
ff fi
ff fffi
ff $ff )6 &

ff fffi fi fi fifffi fi 4ff
fi ff & fifffi fiff fi >.ff
? >.
& ? >& ? >6
?
>8 ff? fi >2fiff8 ff? fi fiff fi fi ff
fiff ;ff fi ff

fi fi fffi fifffi fffiff fi fi $ff
)6 !'''*
**
+* * ffff *-
( ff fi fi
fi ( / (
) #E !#B 2@- # 3 K( & ff ff ffff
fi
fi ff 9 ff ff fi
ff ff
& 6)N ff fi ff fi B
fiff ff fi fi ff 8 fi ff fi
ff ff
fiff fi fi fi fi ff
ff ff fi
ff fi ff ff fi ff fi fi fifi
fifi 2ff fffi ff fiff ff fiff



fi fi 2 fi @A fi ff
fi fi < ff fi
fi fi ffff fi fi fi
fi /"# fi
<fi fi A@%# ff ff
fi
fi fi fi ff <fi fi A@%# ff fi

fi
ff fi ff fi
/fi fi 5 fi ''

/2

fi fiffff fi

ff fi

fi ff

5)3
,,1
,'
,R
;;
1$<
1,
$R
.
fiff #
#11
<BR
.fi
fi

#11
''R
).
$$#
B
'BR
"2)I) #11
11,
B,R
.fi
B
#1
,R
&),
1'
1,
#$R
&).S.
#,
#1
#1R
. .
##
#,,
R
&fi #7 8 ff
ff fi
fi
fiff fi
fiff
$ff )6 ffff ff fffi & fifi ff
fiff
fiff
fiff ff fi $ff )6 & fifi ff
ff 1
ff )ff 2fiff8 ff fiff fi
ffff ff
fiff
ff fffi

fffi
ff )ff 6
fi fi ff
fi
ff fi ff
fiffff ff
fiff fi
fi fi 9 ff fiff

Ifffi ff
ff fi
ff
fiff fi ,'
!ff fi fi B
ff - fi fffi fi ,,R !
ff fi


ff ,1 fi fffi <R- ; ff # fifi
ff ff fi fi
fiff fi
fiff
& fffi
ff fi
fi

fiff
& ff fi
fffi fi fifffi
fiff fi fi fifi fi fiff 4 &
fi fi 9ff fiff
!24 fi * 8 1#-
& fi ff 9ff fiff fi fi fiff ,- & ,

ff fi ff fi
ff
fiff fiff 1
ff ) 8 ff
fi 1
ff )ff 2fiff8 ff & 9ff fi fi
fffiff
fffi fi9 4 fiff fi ffff ff
&
fi ff
ff fi ff ff fi @ fi
fi fffi fffi fifffi ff
ff fi ff fifi ! - fiff
fi ff fi
ff fi
ff
ff fi

ff ff ff fi fi
fiff

fi ff

fi @ff fi +
fi fi ff fi
ff ff
B ff fi fi 6 /fi ff
fi $
ff * .
ff fi 1
fifi fi 6 /fi # fi fi ff fi
fi $ ff
" ff
fi

0-

fifi ff fffi
ff fi fi fi ff fi


+ fffi fi fi ff ff
ff fi
! fi
ff fiff
fi fffiff ff fi ff fffi fi
fiff- fi fi 9 ff & fi fi fi
# 8 fi fi fi fi fi fi fifi fffiHfffi

fiff ff fiff
fifffi ff fi
fiff
fi ff fi fi fifi fffi fifffi fi
9fi fi B fiff
fi fi fi fi ff
&
fifffi ff fi fi fi fi ff fi fifi
!fiff-
fi ff
9
ff ff fi@fi
fiff fiff fi
# fi ff fifffi
ff


fi ff ;ff fi fi

fi ff fi
. 1 ff , fi ff fi
ff fi
,
fi ff fi
9 fi B fi
&
ffff fi fi ff 6)N ff ff 9 fi
!
- fi fi
fi
! fi- fi 9
6)N
; ff # ## fi #1 fi fi
ff
fi !
9 ff-% fi
ff 6)N fi
!fiff fi-
ff
fi fi fi fi

fi fffi fi ff
fi ff
ff ffff

ff

9fi 8 fi ff
fi fi fi ff ffff


fi fiff
; ff
ffff fi

fiff ff
ff
fifffi ff fi% fiff. .ff
fifffi fi
fiff
ff
ff fi fi
fi ff .
&

ffff ff
ff ff ff
ff fi
6)N ! ff
fiff fi ffff fi fiff- )ff 6


ffff fi ff
fi ff fiff
ff
;fi 8 ff fi
ffff fiff ff
fiff fi fiffff
ff
ff &
ff
ffff fi fi ff ff
fi fifffi fiff ; ff # & ff fi

ff
fiff fi fifi fiff ff ff fi ff fi ff

fiff & ff 4ff fiff )ff 6
ff fi

ff ff fi ff fi ff
ff
ffff ff fffi ff fi
ffff fi ff fi

fffi
ff
fi ff fi fi
fiff

fiff
ff ff
fiff + fi ff fi ff
ff
fi
fi >.
ff)fiff? ! - 6fiff
ffff fffi
ff fi .
ff)fiff fi fffi fi fi fi
ffff ff
fi ff fffi
fiff fi ff ff fi
ffff ff






3

3

3

3

3

3

3

fiff fi fi fi 1 fi fifi fi fi ff

fi
fi fi ff

' fi ffff ff
fi

0

fi fiffff fi

DriverLog-Strips

Milliseconds

LPG-speed (20 solved)
FF (Speed) (15 solved)
MIPS (15 solved)
MIPS (Plan) (15 solved)
SemSyn (1 solved)
Simplanner (11 solved)
Stella (10 solved)
VHPOP (14 solved)

1e+06

100000

ZenoTravel-SimpleTime

Milliseconds
1e+08

LPG-speed (19 solved)
IxTeT (8 solved)
MIPS (14 solved)
MIPS (Plan) (16 solved)
TP4 (5 solved)
TPSYS (2 solved)
VHPOP (13 solved)

1e+07

1e+06

100000
10000
10000
1000
1000
100
100

10

10
0

2

4

6

8

10

12

14

16

18

20

Satellite-Complex

Milliseconds
1e+07

2

4

6

8

10

12

14

16

18

20

14

16

18

20

Rovers-Numeric

Milliseconds

LPG-speed (20 solved)
MIPS (8 solved)
MIPS (Plan) (10 solved)
Sapa (16 solved)
TP4 (3 solved)

1e+06

0

LPG-speed (17 solved)
FF (Speed) (9 solved)
MIPS (8 solved)
MIPS (Plan) (8 solved)

1e+06

100000
100000
10000
10000
1000
1000

100

100

10

10
0

2

4

6

8

10

12

14

16

18

20

0

2

4

6

8

10

12

; ff 7 6)N fi ff
ff fi fi
fiff
$ff )6 ff fi fiff. .ff
.
& )ff
6
fi 8 ff
fiff
fi ff fi fffi
fiff fi fffi
ffff
ff fi
&
; ff ## fi #1
ff ff )ff fi
ff ff
fiff
ffff
fiff fiff
fffi fi 6
fifffi &

6)N ff
fi fi ffff

ff .
ff)fiff7 fi ff ff fi
ff ff fi

fiff ff fi ff fi fi
fiff fi fi ff ff

fiff fi
ff fi
fi ! ff fi fi fi fi

fiff ff fi
ff 4ff ff
fiff fi
ff fi
0

fifi ff fffi
ff fi fi fi ff fi


DriverLog-Strips
Number steps
1000
LPG-quality (20 solved)
FF (Quality) (15 solved)
MIPS (15 solved)
MIPS (Plan) (15 solved)
SemSyn (1 solved)
Simplanner (11 solved)
Stella (10 solved)
VHPOP (14 solved)

ZenoTravel-SimpleTime

Quality
4500

LPG-quality (19 solved)
IxTeT (8 solved)
MIPS (14 solved)
MIPS (Plan) (16 solved)
TP4 (5 solved)
TPSYS (2 solved)
VHPOP (13 solved)

4000
3500
3000

100

2500
2000
1500
1000

10

500
0
0

2

4

6

8

10

12

14

16

18

20

Satellite-Complex

Quality
700

4

6

8

10

12

14

16

18

20

18

20

Rovers-Numeric

Quality
9

LPG-quality (20 solved)
MIPS (8 solved)
MIPS (Plan) (10 solved)
Sapa (16 solved)
TP4 (3 solved)

600

2

0

LPG-quality (17 solved)
FF (Speed) (9 solved)
MIPS (8 solved)
MIPS (Plan) (8 solved)

8
7

500
6
400

5

300

4
3

200
2
100

1

0

0
0

2

4

6

8

10

12

14

16

18

20

0

2

4

6

8

10

12

14

16

; ff #7 fi
fi
fi fi
fiff $ff )6 ff
fi fiff. .ff
.
& )ff 6

fi & fi 8 ff ffff
ff fffifi
ff
fiff. )ff fiff fi
ff fi
ff - &
ff
fi fi ff ff fi
.
ff)fiff
& ff fi
fiff
fififf

fffi fi
fifffi
ff ff ffff fi fiff fi
.
ff)fiff .ff
fifffi .
ff)fiff fiff ff fi
ff
fffi ff ff fiff 8 ff fifffi .
ff)fiff
fiff ff
fiff
ff ff fi Kfiff fi fi
fifffi
)ff .ff
ff
fiff
ffff ff fi .
ff)fiff
.ff
fifffi fi
fi
ff fi fi

ff fi
fi fi fi
fi fffi .
ff)fiff
6ff fi

fi 6)N
ff ff fi fi fi ff . $'
fffi fi
0

fi fiffff fi

Satellite-Strips

Milliseconds
1e+06

Satellite-Strips

Number steps

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

100

100000
80

10000
60

1000
40

100

20

10

0
0

2

4

6

8

10

12

14

16

18

20

Satellite-SimpleTime

Milliseconds

2

4

6

8

10

12

14

16

18

20

12

14

16

18

20

12

14

16

18

20

Satellite-SimpleTime

Quality

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (19 solved)
SuperPlanner (Quality) (19 solved)

1e+06

0

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (19 solved)
SuperPlanner (Quality) (19 solved)

200

100000
150
10000
100
1000

50

100

0

10
0

2

4

6

8

10

12

14

16

18

20

Satellite-Time

Milliseconds
1e+07

2

4

6

8

10

Satellite-Time

Quality
700

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

1e+06

0

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

600

500
100000
400
10000
300
1000
200
100

100

10

0
0

2

4

6

8

10

12

14

16

18

20

0

2

4

6

8

10

; ff ##7 )ffff fi
!
- fi fi !ff
-
fiff
.
ff)fiff !
fi fi ff- )ff .ff
.

& fi &
0,

fifi ff fffi
ff fi fi fi ff fi


Satellite-Complex

Milliseconds
1e+07

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (17 solved)
SuperPlanner (Quality) (17 solved)

1e+06

Satellite-Complex

Quality
700

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (17 solved)
SuperPlanner (Quality) (17 solved)

600

500
100000
400
10000
300
1000
200
100

100

10

0
0

2

4

6

8

10

12

14

16

18

20

Satellite-Numeric

Milliseconds

2

4

6

8

10

12

14

16

18

20

Satellite-Numeric

Quality

LPG-speed (12 solved)
LPG-quality (12 solved)
SuperPlanner (Speed) (14 solved)
SuperPlanner (Quality) (14 solved)

1e+06

0

LPG-speed (12 solved)
LPG-quality (12 solved)
SuperPlanner (Speed) (14 solved)
SuperPlanner (Quality) (14 solved)

800
700
600

100000

500
10000
400
300

1000

200
100
100
0

10
0

2

4

6

8

10

12

14

16

18

0

2

4

6

8

10

12

14

16

18

; ff #17 )ffff fi
!
- fi fi !ff
-
fiff
.
ff)fiff !
fi fi ff- )ff 6
fi
8 ff

ff fifi ff fi fi ff fiff fiff

ff
ff fi ff
fi fi ff

ff ff

fi
fi ff fi fi fi 6)N ff ff fi ff fi
6)N ff ff
& fiff
fiff
fi fi
ff
!ff 6)N ff fi- fi
fi fi ff
ff
.
ff)fiff !ff 6)N ff fi ff .
ff)fiff-
3 fi fi ff ff fi fffi4
fi fi
fi
& ff 6)N
fiff fi ff ff fi
fffi fi fffi4
ff fi ff
9ff fi fi fi
fi ff
0.

fi fiffff fi

Satellite-SimpleTime-pfile15

Quality
180

160

Satellite-Time-pfile6

Quality

LPG (1st run, 8 solutions found)
LPG (2nd run, 9 solutions found)
LPG (3rd run, 12 solutions found)
LPG (4th run, 4 solutions found)
LPG (5th run, 6 solutions found)
SuperPlanner (1 solutions found)

LPG (1st run, 11 solutions found)
LPG (2nd run, 10 solutions found)
LPG (3rd run, 10 solutions found)
LPG (4th run, 11 solutions found)
LPG (5th run, 11 solutions found)
SuperPlanner (2 solutions found)

250

140

200

120
150

100

80
100
60

40
100

1000

10000

100000

1e+06

10

CPU Time

Quality
100

LPG (1st run, 7 solutions found)
LPG (2nd run, 4 solutions found)
LPG (3rd run, 5 solutions found)
LPG (4th run, 6 solutions found)
LPG (5th run, 5 solutions found)
SuperPlanner (3 solutions found)

36

1000

10000

100000

1e+06

CPU Time

Satellite-Strips-pfile9

Number steps
38

100

Satellite-Numeric-pfile3
LPG (1st run, 4 solutions found)
LPG (2nd run, 3 solutions found)
LPG (3rd run, 3 solutions found)
LPG (4th run, 4 solutions found)
LPG (5th run, 2 solutions found)
SuperPlanner (3 solutions found)

90
80

34
70
60

32

50
30
40
28
30
26

20
10

100

1000
CPU Time

10000

100000

10

100

1000

CPU Time

; ff #$7 )fi fi fi ffff
6)N !fiff fi- ff
!9 ff - fi .
ff)fiff ff ff
ff
)ff .ff
.
& & fi 8 ff
fi fi ff fi fffi fi fffi fi ff fi
fi fi fi ff fi ff fiff fi
fi fffi
.
ff)fiff fi ff ff ff ff 6)N fi .
ff)fiff
; ff #$

ff ff fi !fi fi fifi fi ff fi
fffi ff
fiff

fi
ff- &
9 ff
6)N fi fi fi
fi fffi !9 ff - fi .
ff)fi
ff ff
ff )ff fi )ff)ff ff %ff&$ fi
)ffff %ff/ !9ff
; ff #$- 9ff !
ff ff 6)N fi 9ff .
ff)fiff ff
fi fi
fiff ff fi fi

ff .
ff)fiff ! fi ffff

; ff ##
0/

fifi ff fffi
ff fi fi fi ff fi



fi fiff ff ff fi fi ff 9 ff - 2ff ; ff
#$ fi ff
ff
fffi fifi ff fi
fi fi fi ff fi .
ff)fiff fi fi
ff ff 6)N ffff ff fi ff
; ff #$ fi
)ff)ff %ff0 fi )ff
ff %ff1 .
ff)fiff fiff
fi
9 ff fi fi ff fi
.
ff)fiff 6)N fi .
ff)fiff fi fi
. ff fi
fi
ff
fffi
fi ff
fiff
fi .
ff)fiff & fifffi fi
fi & fi ff

fiff fiff (

: (
fi



fi fiff fi .
ff)fiff fi fifi fi fiffff ff
ff

ff ff
fiff
ff fi .
ff)fiff
&
ff fi fiff
fiff $ff )6 fi
ffff

fffi fi !Ffi
11- &
fffi
ff

B#R .
ff)fiff <<BR &
fffi
ff
ff
fiff fiff #,R
fffi ff #$<R
Kfiff fi fffi fi fi
fi
ff
ff
fiff fiff fi
fi fffi .
ff)fiff
9fi 4ff ff fi
ff .
ff)fiff

ffff ff fi )ff ff ff
fiff fifi
ffff ff Ifffi
& fifffi fi fi
fffi
ff ff
fiff

ff fi ffHff fi fiff fi fi
fffi
ff

fiffHff
+ fi fi fifi@
ffff fi ff
.
ff)fiff ff
fi ff fi fi
ff fi
(

6 fi / fiff ff &
( ff &
ff .
&
ff ff
ff fi
.
ff)fiff fi
fffi
ff
fi fi
ffff
ff fi .
ff)fiff fiff ff fi ffff

fffi ff &
fifffi 8 ff fi .ff

ff fifffi
fi
.
ff)fiff & fi fffi
ffff fi
fi 2ff fi fi fifffi ff fi .
ff)fiff
ff fi
.ff
ff
Ifffi ff fi
ff fi


ffff ffHff fi
.
ff)fiff BBH$#R
ff fi
ffff ffHff
<#H##'R
ff
;fi fffi ff
fiff fiff
ff fi ff
fi
fiff $ff )6
ff fi fi )6 )
B 2@ # 3 K( ff fi ff fi fi
ff fi
fiff ff


ff ff fi fi
fiff &
ff fi fi fi
fiff fiff ff
fiff
fi
; ff #,

fiff
ffff fi fi
fi

fiff ff
fffi fifffi $ ,
ff
& /fi fi ) ! $$
fi @A

00

fi fiffff fi

Rovers-SimpleTime-HandCoded

Milliseconds
1e+07

LPG-speed (20 solved)
LPG-quality (20 solved)
SHOP2 (20 solved)
TALPlanner (20 solved)
TLPlan (20 solved)

1e+06

Rovers-SimpleTime-HandCoded

Quality
450

LPG-speed (20 solved)
LPG-quality (20 solved)
SHOP2 (20 solved)
TALPlanner (20 solved)
TLPlan (20 solved)

400

350
100000
300

10000

250

200
1000
150
100
100

10

50
0

2

4

6

8

10

12

14

16

18

20

Rovers-Time-HandCoded

Milliseconds
1e+07

2

4

6

8

10

12

14

16

18

20

14

16

18

20

Rovers-Time-HandCoded

Quality

LPG-speed (18 solved)
LPG-quality (18 solved)
SHOP2 (20 solved)
TALPlanner (20 solved)
TLPlan (20 solved)

1e+06

0

LPG-speed (18 solved)
LPG-quality (18 solved)
SHOP2 (20 solved)
TALPlanner (20 solved)
TLPlan (20 solved)

800

700

600
100000
500

400
10000
300
1000

200

100
100
0

2

4

6

8

10

12

14

16

18

20

0

2

4

6

8

10

12

; ff #,7 )ffff fi
fffi fi ff fi
fiff

fi $ff )6 fi fi fi fi ff fi
ff fi fi ff
fiff

fi
ff
fi fi ff fi fffi
fi fi fiff fiff
fi fi
fi
fiff
fi )ff ff
2- ff fi fi fi ff
fi
fi

fiff
ffff ff fi
!8fi ( fi 0 ff
ff + * Sfi fi 1$- ff2-
fi

ff
ffff fi ff fi fi
ff ffff
fffiff fi ff fi
9fi fiff
fi
01

fifi ff fffi
ff fi fi fi ff fi


!ff
ff

fi " #ff$
+ fi
ff ff
fi fi fi fiff

fi ff fi !fi -
fiff
ff fffffi fi
fi
fi fi fififf ff >
ffff fi 9ff ffff? fi $ff ff
fifi )fi 6
fi fifi
ff fi ff
ff
fi
ff
ffff
ffff fi ff
Iff fffi fi fiff
ff ff
ff7 ffff fiff ff fi fi fi ff
fi fi fi fiff % 4ff fffi
fi fi fi fiff
% 5fifffi
ff fi fi fi
!3ff * .fffi 11 1$-
+ fi fifffi ff fi fiff
ff
ff ff
&
fiff fiff fi ff fiff ff
fffifi
ff fi fi fi fffi
ff fi fi !fi ff fffi
fi
ff
24 fi !1$-- fi ff fi fiff
fffi ff fi fffi
fi fi >fi ? !3ff * .fffi #-
fi ffff
fffi
9fi ff

ff
ff !3ff * .fffi 11- &
fi
fffi ff
ff
ff fi
fi fi
ff (ff

ff
ff fi
ff fi fi ff fi
fi fi + fiff fi fiff ff fi
fi ff fi
ff ff
ff fi
fffi fffi ff

ff ff
ff fiff & fiff fiff
fi ff
fi fifffi ff
ff
ff fi
ff
;fi ff ff ff
ff
fffi
fi ff fffi
fi ffff
fffi ff
fffi fi

ff fi ff
fi
fffi fi fi fffi
fffi fffi fi
fffi
fffi fi fiff fi fi fi ( fffi ( fffi
!( #$- ff .&)fffi !/ff ff * )fiff ##-
$
ff%fi&

&
fi fiffff fi fi

ff fffi ff
fffi fi &ff

fi fi ff fi ff

& fi ff
fffi + fi
fi fiff
5fi@@fiff fi .ff .
&fi fi ;fi ff@ ff "fiff 5ff fi .fi
Ifffi ff ff

ff ff
fi fi ( fi fi
Nff :fffi fi fi ff
ff= ;fi fi fifffi ;
fi /ff 5 ff ff fiff ff fffi@fi $ff )6 PUff 24 fi
fi ff fififi !
fiffff fi fifi ff ff fiff
fi PUff - fi /fi . fi fi ffff ff
ff

02

fi fiffff fi


fi ' ( ff


fi fi #ff$

ff
fi fffi ff

fi
ff fi
ff ; ff #B ff ! -
4 ! fi 4 fi ! -
ff ff "ff #ff

ff fi fffi fi fi fiff ff "ff ff


fi fffi fi & ffff fiff
= fi

fffi 9 fffi !: * ; ff #<-
ff "ff #ff
fffi ff fi ff fffi fi
fi
fi ff
fi
ff ff fffi ( fi fffi
ff ff
fi !
B-
fffi fi
fi
fffi !
<M##- fi
fifi ff
fi fffi fi fi
fifffi ff fi !
#1M#- & fiff ff fi fi
fi
fi ff ! J - fi
fi fffi fi fffi
! J - + fiff ff fi fi fi
ff fffi
fi ( fffi ff

ff ff fi fi fi
fffi ff fi fi
ff
fffiff fi ff
fffi fi fiff ff ( fffi 9

fi fffifi
fi fffi
fiff
ff
3 fi fi fi fi ff fi
fi fffi !#-
fi
4 fi ff fi fi 4 !
<M- ff !1-
fi
4 fi ff !
fi- fi fi
ff
!
< # fi ##- !#- fi fi fffi fi
@ fffi fi
fi 3ff fi . ff !#- !1- fi fffi fi fi
4 ff ! - ff ! - fi fi fi fi
ff ff fi

fi fi fffifi fi fi fi ff
(
fi fffi ff fi fi !#- ff
fi fi fi fi fi
4 !
#$M#,- ff ! -
fi fi4 fi fi ! - fi ! - !
fi- fi

ff !
#BM#- & 9ff fi
fi
fi fi fi
4 fi fi fi
ff fi fi ff fi fi


ff ff fi fi

ff ! fiff fi
4 -
8 fi fi fi
ff fi
ff
0ff ff !#<-

fi fi fififi fi fi fi fi fi
ff fi fifi
fffi ! - ! - fi ff fi fi
fi 4 ffff
! fifffi fi ! - fi ! - fiff -
& ff fi ffff ff fiff
ff "ff #ff
ff "ff ff
ff fiff
ff ff


#$$

!

"

*

-



-

*

-

*

*



*





















"



#$$











*

















































ff fiff ff
ffffff

ff
ffff

6ffff ff "ff ff
fi ff

9
ff fffi fi 6ffff ff "
ff #ff
ff ff fi
fi fffi fi
1-

fifi ff fffi
ff fi fi fi ff fi


ff "ff #ff
! $ 7 ( fi fi ! - fi fi ff
fffiff fi ! -%
% 7 (
ff fffi fi ! -
# % %
1 % % %
$
J J
,
% %
B ff ff fi ! - fi ! ff ! - ! - ff '
! - ! - %
<
ff ff !
ff ff ! ! - ! -
% HO )fi fffi OH

#
ff ! - ff fi ff ! - fi ff ! ! - ! -
% HO )fi fffi OH
##
#1

ff
#$
ff ff ! - fi ! - ff
! - ! -
% HO fi fffi OH
#,
#B
!! -%

#'
ff ! - ff fi ff
#<

ff ! - ! ff ! - ! - ff -
! - ! -
% HO fi fffi OH
#


#
! -%
1

%
1#
+

+

*

-

+ -

*

*

-

-

#

-

-

*

*

*

*



"

5

#$$





"



*

!
*





*

*



*

"



!



#



*





5

*



-

-

#$$

*

#$$


*

*

-

#

#

*

5



2 !

-







*



"



*



5



*

ff "ff ff
! $ 7 ( fffi fi ! - fi fi ff
fffiff fi ! -%
% 7 (
ff fffi fi ! -
# %
ff fi%
1 ff ! - ff
$ ff ff
fi ff !
,
ff ff fi ff ! B
! - ! -
% HO 6
OH
' ff ff
< ff ff !
ff ff fi ff !
! - ! -
% HO ffff OH
# ff ff ! ##
ff ff fi ff ! #1
! - ! -
% HO 4 OH
#$
*

*







*









"





"







"












#$$





!





!





; ff #B7 fiff ff
fffi
1

fi fiffff fi

fi fiff fi fi
ff fi fiff ff
fi fi

fffi fi fi ff fi fi
$
ff J fi fi fi

fi fi
fffi ff fi fi ! J - fi fiff fi ff fi
fffi fi fi fiff ff fi fi
$ ff

J .

fi fi

fi fi
fffi fi fi fffi fi

fi fi ! #-
$
ff J E # ( fi ff fi


fi fi fi fffi fi fi fffifi fi

fi E #
fi ! fi fi fi fiff ff - fi * fi
fi : fi
fi fi

!- fi
fiff
4
* ff !- ! - fi fi4
* ! -

* fi ! - ff fi ff * fi

6fi !- ff

#$M#, ff "ff ff
Kfiff fi !- fiff fi
fi fi fffifi !- fi ff ! - ff fi * fi fi

ff

ff * fi ! - ffff
fi
! - !! -- fi
fffi
fiff fi
fi fffi fi ! -
fi fi ff ff fi fffi fi ! -

#'M# ff ff fffiff ff fi
fi


&ff fi fiff fifffi fi ff fifi fi 9 fi
ff 4ff fi fi fi
fi fffi
. fi +
ff
>fffi ? !fffiff- fi fi fffi
fi
ff ff fi !. * + #- (ff ff 9 ff

ff fffi fi fi fi ff 6ff
fffi fi fi fi fi fi . fi + ff fi fi
4 fi fi ff fi
ff
: fi 34ff !1#-
ff
fi ff ff fi fffi
fi fi fi fiff ff : fiff fi
@
fi
fiff fi fi fiff
fi ff fiff
fffi
ff fi 4 fi 2ff ff fiff fi
9fi 4ff + : fi 34ff
fi fi fiff
fifi
fiff fi
ff ff "ff #ff
ff fi ff fi
ff9 ff fi fffiff
ff & ff fi
fiff fi
fiff 4ff ff ff "ff #ff
fffi !
fi

#- ffff ff fiff fffi fi
fiff
ff fi

fi fi ! fi fi
ff fi

ff- : fi 34ff ff ff
fffiff fi
;fi ff
fi
ff fi fiff fi fi 9fi > fi

fiff? fi ff ff fi
ff ffff
;ff
ff fi ff ff fi
ff
fffi

fifi ff
ffff
fi ff
fi fi

fiff ! ' - ff
fffi
1
6



6





6

*

+





*



6







*





























































*







*

*

*



*



*











*

*

*

*

*

-

*

*

fifi ff fffi
ff fi fi fi ff fi


fi fi fiff ! fi fi fi fi
fiff

ff
- )ff
ff ' fiff fi ff ff
ff fi fiff
ff ;ff fffi ffff ff

ff
ff
fi fffi
fi
ff & fi ff fi ff
ff $ff )6
ff fi fi
fiff ff
ff ff fi

fiff fi )ff 2fi6

fiff 6 ffff fiff fi fifffi ff
!
ff fffi ff fiff fi fi fifffi fi fifi ff
fi fifi fi ff !3ff * . ff #- ff !
!; * 5 #fi- ( fiff fi
ff
; fi 5 !1-
;fi ff fi fffi
ff fi 4
fffi fi
fiff ; ff #B
9 fffi ff ff fi ; fi 5 !1$-

1

fi fiffff fi


fi )'
fi


*
ff
ffff
fiff

Depots-Time

Milliseconds
1e+07

1e+06

Depots-Time

Quality

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (11 solved)
SuperPlanner (Quality) (11 solved)

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (11 solved)
SuperPlanner (Quality) (11 solved)

2500

2000
100000

1500
10000

1000

1000

500

100

0

10
0

5

10

15

20

DriverLog-Time

Milliseconds
1e+06

0

25

5

10

25

LPG-speed (18 solved)
LPG-quality (18 solved)
SuperPlanner (Speed) (16 solved)
SuperPlanner (Quality) (16 solved)

2500

100000

20

DriverLog-Time

Quality
3000

LPG-speed (18 solved)
LPG-quality (18 solved)
SuperPlanner (Speed) (16 solved)
SuperPlanner (Quality) (16 solved)

15

2000
10000
1500
1000
1000

100

500

10

0
0

2

4

6

8

10

12

14

16

18

20

Rovers-Time

Milliseconds
1e+06

0

2

4

6

8

10

12

14

16

18

20

12

14

16

18

20

Rovers-Time

Quality
1000

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (12 solved)
SuperPlanner (Quality) (12 solved)

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (12 solved)
SuperPlanner (Quality) (12 solved)

100000

800

10000

600

1000

400

100

200

0

10
0

2

4

6

8

10

12

14

16

18

0

20

1,

2

4

6

8

10

fifi ff fffi
ff fi fi fi ff fi


ZenoTravel-Time

Milliseconds
1e+07

LPG-speed (19 solved)
LPG-quality (19 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

1e+06

ZenoTravel-Time

Quality
1800

LPG-speed (19 solved)
LPG-quality (19 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

1600
1400

100000

1200
1000

10000
800
1000

600
400

100
200
10

0
0

2

4

6

8

10

12

14

16

18

20

Satellite-Time

Milliseconds
1e+07

2

4

6

8

10

12

14

16

18

20

12

14

16

18

20

Satellite-Time

Quality
700

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

1e+06

0

LPG-speed (20 solved)
LPG-quality (20 solved)
SuperPlanner (Speed) (20 solved)
SuperPlanner (Quality) (20 solved)

600

500
100000
400
10000
300
1000
200
100

100

10

0
0

2

4

6

8

10

12

14

16

18

20

0

1.

2

4

6

8

10

fi fiffff fi


fi !' !ffff
ff +fi
fi


& fi
ffff fi
fi .
ff)fiff ff fiff
fi ff fi ff fi fiff & fiff
fiff
ff 7 ff
ff !1 fi $ff -% ff
ff

fiffHff fi .
ff)fiff !,H' -% ff
ff

fiffHff fi .
ff)fiff !BH< - (
fi ff fiff fi ff 6)N ff ff
9ff fi fi fi ffff fi ff fi + fi
fiff fi
fi 9 fi ff ff 6)N fi ff 9
+
$
/
,+-

+
$ /
!1
+

,+
!1
+

,+- fi

!1
+

,+0
!1
+

,+- fi
0
!1
+




ff
fi



2
2
2
2
&2
2

2
& (&2
2
2
2
&#2

' (#2
( &2
% 2
' 2
2
#&2

2
& &2
2
&2
2
&#2

' (#(2
'2
% (2
% (2
2
(%#&2

& #(2
&2
&2
2
'2
#&2




ff
fi



&#&2
) 2
2
2
&2
'2

&2
' )2
&2
&2
' )2
(#'2

) )#)2
& (&2
( )&2
) 2
) 2
)#%2

% '#'2
' 2
'2
'2
%&2
&#2

#'2
&2
&2
&2
&2
)#)2

2
2
&2
&2
2
#2




ff
fi



#2
) 2
2
2
&2
&#2

&2
' )2
'2
2
2
((#&2

% '#'2
( )&2
) 2
&2
& (&2
)#%2

&%#&2
' 2
'&2
'2
2
%#2

' (#2
2
2
&2
& &2
#(2

#2
2
&2
2
&2
#2




ff
fi



&#&2
) 2
( )&2
'2
2
)#'2

#2
' )2
%&2
% (2
2
((#%2

) '#%2
( &2
&2
2
2
'#%2

#2
&2
) %2
2
2
%#(2

&%#&2
&2
( &2
% (2
2
'#)2

#2
&2
&2
& &2
& &2
(#'2

fi

2

( )&2

&2

% (2

&2

&2





2
%#'2

' )2
)#2

'2
&&#)2

& &2
#2

) %2
)#2

2
#'2

.









fffi



fi

1/

fifi ff fffi
ff fi fi fi ff fi



fi ,' !ffff
ff +- .
fi


& fi
ffff fi fi fi .
ff)fiff ff
fifffi ff fi ff fi fiff & fiff

fiff ff 7 ff
ff !1 fi $ff -% ff

ff fi
ffHff fi

.
ff)fiff !,H' -% ff
ff
fi ffHff fi .
ff)fiff
!BH< -
( ff fi ff ff fi

ff fi
ff ff ff fi fi fi
fi fi fi ff fi ! fi
ffff

ff - & fi fi
fi fi ff

fi ff fi
ff
9fi
ff .ff

ff ff

fi fi 9 fi ff fi fi
ff ff ff
fi ff
ff ff
fi












+
$
/
,+-

+
$ /
!1
+

,+
!1
+

,+- fi

!1
+

,+0
!1
+

,+- fi
0
!1
+




ff
fi



2
2
2
2
&2
2

2
& (&2
2
2
2
&#2

&%#&2
% (2
%&2
'&2
&2
&2

2
& &2
2
2
2
%#2

% )#2
2
&2
2
%&2
#(2

2
2
2
2
&2
#2




ff
fi



&#&2
) 2
2
2
&2
'2

&2
' )2
&2
&2
' )2
(#'2

)'#%2
( )&2
2
2
( )&2
#2

&2
&2
&2
( &2
&2
#2

%#&2
&2
2
2
2
#2

2
2
2
2
2
2




ff
fi



#2
) 2
2
2
&2
&#2

&2
' )2
'2
2
2
((#%2

( ((#2
( )&2
) 2
2
&&2
)#%2

%#2
% 2
) %2
& &2
2
&#&2

#2
&2
2
2
%&2
#(2

2
2
2
2
&2
#2




ff
fi



&#&2
) 2
( )&2
'2
2
)'#2

#2
' )2
%&2
% (2
2
((#%2

%&#&2
& (&2
) %2
'2
%&2
&#2

%#&2
2
) %2
( &2
&2
)#'2

) '#%2
2
2
% 2
' 2
(#'2

%#&2
2
2
% 2
&2
(#)2

fi

2

( )&2

&2

%&2

&2

2





2
%#'2

' )2
)#2

) 2
(2

& &2
#2

&2
#'2

2
#(2

.










fffi



fi

10

fi fiffff fi



( P !#$- fifi fi
fffi fffi )fifi ff
)- ./0 $1M,$
( P !##- &
fffi fffi fi
fi (ff
+


#M'
fffi 0fi fi .fi fi 6(
: ( * ; ff !#<- ;fi
fi ff
fi fffi
fifi
$ff ffff 12 1#M$
: : * 34ff 2 !1#- )fi fi ff fiff $ff ffff 0.1 !#
1- BM$$
/ff K ff * )fiff P !##- &
fffi fffi ff $ff
ffff 31 '#MB
/
* 3ff ( !11- &
fffi
fi ff ff
fffffi
7 fi
ff fiff ff
ff +ffff
ff 4 $ff )ffffff
+ ff
+ ff )
+ fifi )+2.
/ * 0fi fi
fi . !1#- .fi
fi7 ( fi
ff ff
fffi

fiff +ffff
ff * 4ff )ffffff + 4)+20
& .
fi .
ffff "fffi
/ * 0fi fi
fi . !11- )fi fffi
fi ff ff

fffi
fi * $ff )ffffff $ff ffff +
* ff $+*2. 5
+ "fffi +
Ffi
. !11-
ff
fi fi fffi
fi
fffi
fi " ff $ff )ffffff $ff ffff
+ * ff $+*2. 5
+ "fffi 6fi

; * 5 / !#fi- & fi fi ff fi fifffi & 7
$ff ffff (ff
ff 7$( 1 $'<M,1#
; * 5 / !# - F
fi )fi 3fffi
.&(8 7
$ff ffff (ff
ff 7$( 02 <M##B
; * 5 / !1- N@ fi fifi ffff fifffi fffi

ff fi fiff +ffff
ff 8 $ff )ffffff
$ff ffff + * ff $+*22

#1M### ((( )ff
; * 5 / !1$- )//51#7 fi )//5 ff
ff
fffi

fi fi 7 $ff ffff (ff
ff 7$(
3ff ( .fi ( * .fffi !1$- fifi
fffi ff fi ff fi
fffi fi 5)3 +ffff
ff 4 )ff

ff $


$ff ffff .
ffff !586.H58(- ;ff
11

fifi ff fffi
ff fi fi fi ff fi


3ff ( * . ff 5 !#'- (fffi )fifffiIffff )fiff7 . &
ff F4 .fiff 6ff fi )ff 7 $ff ffff (ff
ff
7$( 8 BM#$<
3ff ( * . ff 5 !#- ffff fi fffi ff fi


fi +ffff
ff 08 ' )ffffff ff fiff


$ff ffff $19

BM#1 ((( )ffH& &
ff
3ff ( * .fffi !#- ;fi
fi ff ff fi fffi
+ffff

ff 0/ ' )ffffff ff fiff

$ff ffff
$11

B$MB# ((( )ffH & )ff
3ff ( * .fffi !1- ;fi
fi fifi
fi ff
fi fffi
7 5fi
fi fi fiff +ffff
ff 8 $ff )ffffff
$ff ffff + * ff $+*22

##1M#1# (((
)ffH & )ff
3ff ( * .fffi !11- 5)37 (
fiff fi fi fiff ff
fi fffi

fi +ffff
ff / $ff )ffffff $
ff ffff + * ff $+*2.

1#M1 ((( )ffH & )ff
3ff ( * .fffi !1$- )fi fi
ff
fi 6.)7 ff +fifi fi
fiff ff fi fffi
)%'*"($'"* 9 !,-
3ff ( .fffi .fi ( * .
. !1$- 5fi fiff ff

fffi
fi 5)3 +ffff
ff 0: $ff )ffffff
fi ff + ; * ff $)+*2:

'1M<# ((( )ffH & )ff
2fi ) * 34ff 2 !1- ( ff ff
fi
fi +ffff

ff 8 $ff )ffffff $ff ffff + * ff
$+*22

#, #, ((( )ffH & )ff
2fi ) * 34ff 2 !1#- 2 ff
fi fi ff ff +ffff

ff * 4ff )ffffff + 4)+20 & .
fi .
ffff
"fffi
24 fi P !1$- & ff;;
fi 7 fffifi >ff ?
ff fi fifffi 7 $ff ffff (ff
ff 7$(
24 fi P !1#- ;;7 & fifffiff
fi $ - <ff .. !$- B<M'1
24 fi P * 8 : !1#- & ;;
fi 7 ;fi
fi fffi ff
ff fiff 7 $ff ffff (ff
ff 7$( 03 1B$M$1
0fi @ 2 * . fi : !#- N .(& fi fi fffi
fi
fi +ffff

ff 0/ $ff 7 )ffffff $ff ffff $7)$11


$#M$1B
12

fi fiffff fi

0fi @ 2 * . fi : !#'- )
7 )fi
ff
fi fi
fi fiff .ff 2 * .fiff & !F- +ffff
ff " ffff
' )ffffff ff fiff

$ff ffff $
1/

##,M#1# ((( )ff
0ff P 8 : 24 fi P * /
!#<- F
fi fffi

fi (/5 & ff
U ff ff fi ;ff ff 3ff fi
5 / * ; !1$- & $ff fffifi
fi
7 K fi
fifi 7 $ff ffff (ff
ff 7$(
(ff / * K / !##- . fi fiff
fi +ffff

ff ' ' )ffffff $ff ffff $10

'$,M'$
8fi / ( & fi 0 ff N ff P + / * Sfi fi ; !1$- .2I)17
fi 2&8
fi 7 $ff ffff (ff
ff 7$(

8 V * 0fi fi
fi . !1#- K
fifffi ffff
fi +ffff

ff 0= $ff 7 )ffffff $ff ffff $7)$20


,BM,''
) ff P * + / !#1- N6)I)7 (

fifffi ffff
fiff ff
(/5 +ffff
ff " $ff )ffffff + ff
>
ffff (ffff
ff (ff
>(?1.

#$M##, : ( fffi 0fi
fi
) ff P * + / !#,- &
fffi
fi fi +ffff

ff "ff ' )ffffff ff fiff


$ff ffff $13

##M##B .fi +( fffi 0fi fi
)fi P / * )fi !#<- ;fi fffi ff
fifffiffff

fi 7 $ff ffff (ff
ff 7$( / 11$M1'1
. fi : 0fi @ 2 * 6 : !#,- 8 fffi ff
ff fi fiff
+ffff
ff "ff ' )ffffff ff fiff


$ff ffff $13

$$<M$,$ .fi +( fffi 0fi fi
. / * + / !#- &
fffi
fi fi fffi
+ffff
ff 0/ 7 )ffffff $ff ffff $7)$11


$1'M$$<
&fi F !#'- )fi fffi fi
fffi fffi +ffff
ff = 4ff
)ffffff $ff ffff !F6('-

,<M,$
"ff . ( !#$- )fi 7 + fi fffi ff fi fi fi $444
"

+ ff

- ff $ff ffff 8 !$- 1,'M1'<

2-

fiJournal Artificial Intelligence Research 20 (2003) 149-154

Submitted 9/03; published 12/03

Commentary
Case Durative Actions: Commentary PDDL2.1
David E. Smith
NASA Ames Research Center
Computational Sciences Division, Mail Stop: 269-2
Moffett Field, CA 94035, U.S.A.

DESMITH@ARC.NASA.GOV

Abstract
addition durative actions PDDL2.1 sparked controversy. Fox Long
argued actions considered instantaneous, start stop processes.
Ultimately, limited notion durative actions incorporated language. argue
notion still impoverished, underlying philosophical position
regarding durative actions shorthand start action, process, stop action
ignores realities modelling execution complex systems.

1. Introduction
PDDL2.1 introduces limited notion time classical STRIPS planning framework.
particular, introduces notion durative actions, is, actions take time. However, notion durative action rather limited, somewhat begrudging. reflects
underlying philosophical position Fox Long actions really instantaneous,
initiate terminate continuous processes. According view, durative actions
seen shorthand start action, process, stop action. result, durative
actions lack important features, namely ability require (pre)conditions hold
specified intervals, effects take place arbitrary time points within
action. Fox Long argued features captured breaking durative action series smaller actions effects beginning end,
preconditions beginning, end, entire action. However,
representation exceptionally cumbersome, ignores fact agent may
separate control actions. addition, representation forces planner
additional work order connect actions.

2. Example
illustrate problems PDDL2.1 notion durative action, consider simple
example spacecraft must turn order point instrument particular target.
order turn spacecraft, thrusters reaction control system (RCS) fired order
supply angular velocity. spacecraft coasts pointing correct direction (or nearly so), RCS thrusters fire order stop rotation. Firing
thrusters consumes propellant, requires controller dedicated task.
addition, thrusters firing, vibration spacecraft, certain
operations cannot performed. thruster firings relatively quick, coasting
phase not. general, turning large spacecraft slow process may take several
minutes. reason speedy turns require greater acceleration deceleration,
therefore consume propellant.

fiS MITH

first question need answer is, best way model complex operation? could model turning operation initial action start spacecraft turning, another action stop turn, interspersed processes model
craft between. level detail, seems reasonable model
physics. However, may well turning guidance built primitive operations spacecraft, possibility starting stopping turns
independently. could model operation consisting instantaneous action
start turn, followed finite process terminates turn complete.
bother? fact is, interested effects process, initiated
starting turn. reasons, seems natural proper regard durative action, effects take place throughout action.
lets suppose want model operation durative action PDDL2.1.
could say something like:
(:durative-action turn
:parameters (?current-target ?new-target - target)
:duration
(= ?duration (/ (angle ?current-target ?new-target)1
(turn-rate)))
:condition
(and (at start (pointing ?current-target))
(at start (>= (propellant) propellant-required))
(at start (not (controller-in-use))))
:effect
(and (at start (not (pointing ?current-target)))
(at start (decrease (propellant) propellant-required))
(at start (controller-in-use))
(at start (vibration))
(at end (not (controller-in-use)))
(at end (not (vibration)))
(at end (pointing ?new-target))))

However, model action quite conservative. ties controller entire
turn operation, specifies vibration present entire operation. addition,
consumes required propellant beginning operation. reality, RCS
firing beginning end turn. result, controller needed two periods, vibration present two periods, propellant
consumed two periods. might matter coast phase relatively quick. However, indicated earlier, turning large spacecraft take several
minutes. Unfortunately, PDDL2.1 rather limited notion durative action cannot
specify action conditions effects times start end action.

3. Decomposition Sub-actions
Fox Long pointed out2 possible model durative action intermediate conditions effects breaking sequence sub-actions. turn
action would need three sub-actions illustrated below: start-turn action, coast
action, stop-turn action, together turn action bind together.

1. Note assumes precomputed provided angles possible pairs targets.
want this, must provide (vector) direction target planner would need
ability vector arithmetic trigonometry within formulas.
2. Personal communication.

150

fiT C ASE



URATIVE CTIONS : C OMMENTARY PDDL2.1

(:durative-action turn
:parameters (?current-target ?new-target - target)
:duration
(= ?duration (/ (angle ?current-target ?new-target)
(turn-rate)))
:condition
(and (at start (pointing ?current-target))
(at start (>= (propellant) propellant-required))
(at end (finished)))
:effect
(and (at start (not (pointing ?current-target)))
(at start (turning))
(at start (enabled-start-turn))
(at end (not (turning)))
(at end (not (finished-turning)))
(at end (pointing ?new-target))))
(:durative-action start-turn
:parameters ()
:duration
(= ?duration (start-turn-duration))
:condition
(and (at start (not (controller-in-use)))
(at start (>= (propellant) (/ propellant-required 2)))
(over (turning))
(over (enabled-start-turn)))
:effect
(and (at start (decrease (propellant) (/ propellant-required 2)))
(at start (controller-in-use))
(at start (vibration))
(at end (not (controller-in-use)))
(at end (not (vibration)))
(at end (not (enabled-start-turn)))
(at end (enabled-coast))))
(:durative-action coast
:parameters ()
:duration
(= ?duration (coast-duration))
:condition
(and (over (turning))
(over (enabled-coast)))
:effect
(and (at end (not (enabled-coast)))
(at end (enabled-stop-turn))))
(:durative-action stop-turn
:parameters ()
:duration
(= ?duration (RCS-duration))
:condition
(and (at start (not (controller-in-use)))
(at start (>= (propellant) (/ propellant-required 2)))
(over (turning))
(over (enabled-stop-turn)))
:effect
(and (at start (decrease (propellant) (/ propellant-required 2)))
(at start (controller-in-use))
(at start (vibration))
(at end (not (controller-in-use)))
(at end (not (vibration)))
(at end (not (enabled-stop-turn)))
(at start (finished))))

Figure 1 shows graphically actions tied together. goal pointing
particular target, turn action required. turn action end precondition
(finished), satisfied adding stop-turn action3. Stop-turn
151

fiS MITH

condition (enabled-stop-turn) satisfied end effect coast action.
Likewise, coast action condition (enabled-coast) satisfied end effect start-turn action. start-turn action condition
(enabled-start-turn) satisfied start effect turn action. result,
turn action forces three sub-actions plan, sub-action forces predecessor sub-actions turn action plan. three sub-actions
condition (turning) satisfied turn action. result, way
consistently achieved three sub-actions packed sequentially
turn action.
pointing(?current)
turning
enabled-start-turn

pointing(?target)
turning
finished

turn

pointing(?current)

finished

enabled-start-turn
enabled-coast

start-turn
turning
enabled-start-turn

coast
turning
enabled-coast

enabled-coast
enabled-stop-turn

finished

enabled-stop-turn

stop-turn
turning
enabled-stop-turn

Figure 1: Sub-actions Turn operation. Start, end, over-all conditions
shown action. interconnecting start end effects shown
action. simplicity, omitted effects concerning vibration, controller
use, propellant usage
two additional subtleties representation. first that, although
three sub-actions occur turn action, obvious requirement
occur turn action. Suppose tried place start-turn
action previous turn action. previous turn action would three subactions, wayward start-turn action would conflict sub-actions. Thus,
order make work, would push three sub-actions earlier turn
action, on. Realizing cannot work requires difficult induction argument.
seems unlikely existing planner could actually infer this, trial
error. result, process generating plans involving actions would incur significant computational overhead, engage needless search.
second subtlety overlooked decomposition computing
durations sub-actions bit tricky. reasonable assume start
stop turn actions fixed duration, duration coast action depends current
3. turns (finished) effect stop-turn must start effect rather end effect. reason
occur end effect, stop-turn action would need complete prior end turn
action, since (finished) effect mutex (not finished) end effect turn action. Despite
asymmetry representation, stop turn still forced occur wholly within turn action
overall condition (turning).

152

fiT C ASE



URATIVE CTIONS : C OMMENTARY PDDL2.1

target orientations spacecraft. fact, duration coast action must
duration turn action minus durations start stop turn actions.
way introduce additional numeric turn-duration function set
turn action, used compute duration coast action.
process decomposing action sub-actions complex convoluted? all, HTN planning paradigm done time. reason
generative planning adopted view, better worse, one allowed
directly specify action used actions connected other.
result, order force sub-actions abut fit within turn action, must
tricky things. One might argue need HTN capability order model
actions. Indeed, would certainly make things easier. However, another way.

4. Richer Durative Actions
One approach dealing modelling problem admit richer language
modelling durative actions. make convenient model actions like turn action,
need able specify conditions must hold various points intervals within
action, effects take place various points intervals within action.
many possible ways one could express conditions effects, one
straw-man possibility:
(:durative-action turn
:parameters (?current-target ?new-target - target)
:duration
(= ?duration (/ (angle ?current-target ?new-target) (turn-rate)))
:condition
(and (at start (pointing ?current-target))
(at start (>= (propellant) propellant-required))
(at start (not (controller-in-use)))
(at (- end RCS-duration) (>= (propellant) (/ propellant-required 2)))
(at (- end RCS-duration) (not (controller-in-use))))
:effect
(and (at start (not (pointing ?current-target)))
(at start (decrease (propellant) (/ propellant-required 2)))
(over [start (+ start RCS-duration)] (controller-in-use))
(over [start (+ start RCS-duration)] (vibration))
(at (- end RCS-duration) (decrease (propellant) (/ propellant-required 2)))
(over [(- end RCS-duration) end] (controller-in-use))
(over [(- end RCS-duration) end] (vibration))
(at end (pointing ?new-target))))

need explicitly construct actions starting stopping turn,
coasting. reason, need worry durations connecting
sub-actions. Instead, simply specified effects appropriate times
turn action. Note specified vibration controller use interval effects. seems
less cumbersome specifying two separate effects stating controller use
beginning interval, longer use end. However, also
fundamental difference two encodings: encoding above, possibility another independent action could somehow make controller available
interval use. Bedrax-Weiss et. al. (2003) argued introduction
explicit notion resource PDDL language. notion could
simplify encoding even further, specifying controller reusable
resource required turn action appropriate intervals. Vibration (or stability) could also treated resource, although somewhat less intuitive so.
153

fiS MITH

One final issue avoided notion continuous change. spacecraft
example, certainly continuous change going on. Propellant burned instantaneously, orientation spacecraft changes continuously. question is,
need model this? Certainly domains necessary reason continuous change. Fox Long point out, concurrent actions well simultaneous consumption production resources, may necessary reason
resources change course actions. example, Mars rover receives
energy solar panels time driving place place. Since battery minimum maximum capacity, one cannot model easily using discrete
consumption production effects. However, consumption production happen
simultaneously, one model continuous change taking place start end
action. sufficient spacecraft example since actions increase
propellant, one cannot perform two simultaneous actions affect spacecrafts
orientation.

5. Conclusion
Durative actions PDDL2.1 limited, expressing complex durative actions
decomposition sub-actions difficult clumsy. time, clear
modelling actions like turning spacecraft terms processes either necessary useful, particularly possibility process deliberately interrupted.
domains like this, richer, expressive notion durative action seems like right
modelling tool. Note would argue modelling processes completely
unnecessary. However, many practical planning applications overkill. results
complex representation planning process necessary.
cheating model complex processes durative actions? course is. modelling cheating. real world physics, nothing instantaneous indivisible,
cheating model anything instantaneous action. Yet, usually content model
action like turning light switch instantaneous indivisible, even though
take small amount time, complex processes behind it. durative action
different simply choosing model details process structure behind
action, even though may necessary model fact action takes time,
effects take place different times action. many practical applications, durative actions essential modelling tool, deserve richer treatment
provided PDDL2.1.

References
Bedrax-Weiss, T., McGann, C. & Ramakrishnan, S. (2003) Formalizing resources planning. Proceedings ICAPS-03 Workshop PDDL.
Fox, M. & Long, D. (2002) PDDL+: Modeling continuous time dependent effects. Proceedings 3rd International NASA Workshop Planning Scheduling Space.
Fox, M. & Long, D. (2003) PDDL2.1: extension PDDL expressing temporal planning domains. Journal Artificial Intelligence Research, issue.

154

fiJournal Artificial Intelligence Research 20 (2003) 379-404

Submitted 10/02; published 12/03

SHOP2: HTN Planning System
Dana Nau

nau@cs.umd.edu

Dept. Computer Science, Institute Systems Research
University Maryland, College Park, MD 20742 USA

Tsz-Chiu Au

chiu@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Okhtay Ilghami

okhtay@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Ugur Kuter

ukuter@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

J. William Murdock

murdockj@us.ibm.com

IBM Watson Research Center
19 Skyline Dr.
Hawthorne, NY 10532 USA

Dan Wu

dandan@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Fusun Yaman

fusun@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Abstract
SHOP2 planning system received one awards distinguished performance
2002 International Planning Competition. paper describes features
SHOP2 enabled excel competition, especially aspects SHOP2
deal temporal metric planning domains.

1. Introduction
SHOP2, Simple Hierarchical Ordered Planner 2 (Nau, Munoz-Avila, Cao, Lotem, & Mitchell,
2001), domain-independent planning system based Hierarchical Task Network (HTN)
planning. 2002 International Planning Competition, SHOP2 received one top
four awards, one two awards distinguished performance. paper describes
characteristics SHOP2 enabled excel competition.
Like predecessor SHOP (Nau, Cao, & Munoz-Avila, 1999), SHOP2 generates
steps plan order steps later executed, knows
current state step planning process. reduces complexity
reasoning eliminating great deal uncertainty world, thereby making
easy incorporate substantial expressive power planning system. Like SHOP,
c
2003
AI Access Foundation. rights reserved.

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

SHOP2 axiomatic inference, mixed symbolic/numeric computations, calls
external programs.
SHOP2 also capabilities go significantly beyond SHOP:
SHOP2 allows tasks subtasks partially ordered; thus plans may interleave
subtasks different tasks. often makes possible specify domain knowledge intuitive manner possible SHOP.
SHOP2 incorporates many features PDDL, quantifiers conditional
effects.
alternative ways satisfy methods precondition, SHOP2 sort
alternatives according criterion specified definition method.
gives convenient way author planning domain tell SHOP2 parts
search space explore first. principle, technique could used
planner plans forward initial state.
SHOP2 handle temporal planning domains, way translate
temporal PDDL operators SHOP2 operators maintain bookkeeping information multiple timelines within current state. principle, technique
could used non-temporal planner sufficient expressive power.
rest paper organized follows. Section 2 gives background HTN
planning, Section 3 describes SHOP2s features planning algorithm. Section 4
describes write domain descriptions SHOP2: particular, Section 4.1 discusses
basic problem-solving strategies, Sections 4.2 4.3 describe aspects SHOP2
specific handling temporal metric domain features. Section 5 discusses SHOP2s
performance competition, Section 6 discusses related work, Section 7 gives
summary conclusion. Appendix contains SHOP2 domain description one
problem domains planning competition.

2. HTN Planning
HTN planning like classical AI planning state world represented
set atoms, action corresponds deterministic state transition. However,
HTN planners differ classical AI planners plan for, plan
it.
objective HTN planner produce sequence actions perform
activity task. description planning domain includes set operators similar
classical planning, also set methods, prescription
decompose task subtasks (smaller tasks). Figure 1 gives simple example.
Given planning domain, description planning problem contain initial state
like classical planningbut instead goal formula, problem specification
contain partially ordered set tasks accomplish.
Planning proceeds using methods decompose tasks recursively smaller
smaller subtasks, planner reaches primitive tasks performed directly using planning operators. nonprimitive task, planner chooses
380

fiSHOP2: HTN Planning System

task:
preconditions:

task:

(transport ?p)

(at ?p ?x)
(destination p ?y)
(available-truck ?t)

(transport-two ?p ?q)

preconditions:

subtasks:

(package ?p)
(package ?q)

subtasks:

(dispatch ?t ?x) (load ?t ?p) (move ?t ?x ?y) (return ?t ?x)

task:

(transport ?p) (transport ?q)

task:

(dispatch ?t ?x)

subtasks: (reserve ?t) (move ?t home ?x)

(return ?t ?x)

subtasks: (move ?t ?x home)

(free ?t)

Figure 1: Methods transporting package ?p, transporting two packages ?p ?q,
dispatching truck ?t, returning truck. Arrows ordering constraints.
shaded subtasks primitive tasks accomplished following
planning operators: (load ?t ?p) loads ?p onto ?t; (move ?t ?x ?y) moves ?t
?x ?y; (reserve ?t) deletes (available-truck ?t) signal truck use;
(free ?t) adds (available-truck ?t) signal truck longer use.

(transport-two p1 p2)
(package p1)
(package p2)

(transport p1)

(transport p1)
(at p1 l1)
(destination p1 l3)
(available-truck t1)

(dispatch t1 l1)

(dispatch t2 l2)

(load t1 p1)
(reserve t1)

(at p2 l2)
(destination p2 l4)
(available-truck t2)

(return t1 l1)
(load t2,p2)

(move t1 l1 l3)

(reserve t2)

(move t1 home l1)

(move t2 home l2)

(return t2 l2)

(move t2 l2 l4)
(free t1)

(move t1 l3 home)

(free t2)
(move t2 l4 home)

Figure 2: plan accomplishing (transport-two p1 p2) following initial state:
{(package p1), (at p1 l1), (destination p1 l3), (available-truck t1), (at t1 home),
(package p2), (at p2 l2), (destination p2 l4), (available-truck t2), (at t2 home)}.
381

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

applicable method, instantiates decompose task subtasks, chooses
instantiates methods decompose subtasks even further, illustrated Figure 2.
plan later turns infeasible, planning system need backtrack
try methods.
HTN methods generally describe standard operating procedures one would
normally use perform tasks domain (e.g., see Figure 1) HTN practitioners
would argue representations appropriate many real-world domains
classical planning operators, better characterize way users think
problems.
Like HTN planners, SHOP2 hand-tailorable: planning engine
domain-independent, HTN methods may domain-specific, planner
customized work different problem domains giving different sets HTN
methods. ability use domain-specific problem-solving knowledge dramatically
improve planners performance, sometimes make difference solving
problem exponential time solving polynomial time (e.g., Gupta & Nau, 1992;
Slaney & Thiebaux, 2001). experimental studies (e.g., Nau et al., 1999, 2001; Bacchus
& Kabanza, 2000), hand-tailorable planners quickly solved planning problems orders
magnitude complicated typically solved fully automated planning
systems domain-specific knowledge consists planning operators.

3. Features SHOP2
section describes SHOP2s planning algorithm SHOP2s distinctive features.
3.1 Basic Elements Domain Description
domain description description planning domain, consisting set methods,
operators, axioms. describe briefly; additional details appear
Section 4.
3.1.1 Tasks
task represents activity perform. Syntactically, task consists task symbol
followed list arguments. task may either primitive compound. primitive
task one supposed accomplished planning operator: task symbol
name planning operator use, tasks arguments parameters
operator. compound task one needs decomposed smaller tasks
using method; method whose head unifies task symbol arguments
may potentially applicable decomposing task. details discussed
following subsections.
3.1.2 Operators
operator indicates primitive task performed. operators
similar PDDL operators: operator head head(o) consisting operators
name list parameters, precondition expression pre(o) indicating
382

fiSHOP2: HTN Planning System

(:method
; head
(transport-person ?p ?c2)
; precondition
(and
(at ?p ?c1)
(aircraft ?a)
(at ?a ?c3)
(different ?c1 ?c3))
; subtasks
(:ordered
(move-aircraft ?a ?c1)
(board ?p ?a ?c1)
(move-aircraft ?a ?c2)
(debark ?p ?a ?c2)))
Figure 3: SHOP2 method simplified version ZenoTravel domain.
true current state order operator applicable, delete list del(o)
add list add(o) giving operators negative positive effects. Like PDDL,
preconditions effects may include logical connectives quantifiers. operators
also numeric computations assignments local variables (an example appears
later Figure 11). PDDL, two operators name; thus
primitive task, applicable actions instances operator.
operator also optional cost expression (the default value 1). expression arbitrarily complicated use variables appear
operators head precondition. cost plan sum costs operator
instances.
3.1.3 Methods
method indicates decompose compound task partially ordered set
subtasks, compound primitive. simplest version method
three parts: task method used, precondition
current state must satisfy order method applicable, subtasks
need accomplished order accomplish task.
example, Figure 3 simplified version SHOP2 method one
domains AIPS-2002 Planning Competition, ZenoTravel domain. method
gives way transport person ?p aircraft one location ?c1 another location
?c2 aircraft already ?c1.1 :ordered keyword specifies subtasks
totally ordered: first move aircraft ?c1, board person, move
aircraft ?c2, debark person.2 specify unordered set subtasks, would
1. symbol begins question mark variable name.
2. method figure would meaning :ordered omitted. list subtasks
begin :ordered :unordered, SHOP2 assumes :ordered.

383

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:; head
(enough-fuel ?plane ?current-position ?destination ?speed)
; tail
(and (distance ?current-position ?destination ?dist)
(fuel ?plane ?fuel-level)
(fuel-burn ?speed ?rate)
(eval (>= ?fuel-level (* ?rate ?dist)))))
Figure 4: SHOP2 axiom simplified version ZenoTravel domain.
use keyword :unordered rather :ordered; complicated partial orderings
specified using nested combinations :ordered :unordered.3
generally, method may form
(:method head(m) p1 t1 p2 t2 . . .),
head(m) task called head m, pi precondition expression
ti partially ordered set subtasks. meaning analogous if-then-else:
tells SHOP2 p1 satisfied t1 used, otherwise p2 satisfied
t2 used, forth. keep descriptions paper simple,
assume without loss generality one precondition expression pre(m)
one set subtasks sub(m).
general, may several alternative ways accomplishing head(m). may
one method whose head head(m), one set variable bindings
satisfy pre(m), one ordering consistent sub(m), one
possible way accomplish subtasks sub(m). alternatives produce
branches SHOP2s search space.
3.1.4 Axioms
precondition method operator may include conjunctions, disjunctions, negations, universal existential quantifiers, implications, numerical computations, external function calls. Furthermore, axioms used infer preconditions
explicitly asserted current state. axioms generalized versions Horn clauses,
written Lisp-like syntax: example, (:- head tail) says head true tail true.
tail clause may contain anything may appear precondition
operator method.
example, axiom shown Figure 4 says plane enough fuel reach
?destination following conditions satisfied: distance travel ?dist, fuel
level ?fuel-level, burn rate ?rate, ?fuel-level less product ?rate
?distance. last conditions handled using external function call,
described below.
3. notation allow every possible possible partial ordering, problem
practice; notation less clumsy allow every possible partial ordering.

384

fiSHOP2: HTN Planning System

procedure SHOP2(s, T, D)
P = empty plan
T0 {t : task constrained precede t}
loop
= return P
nondeterministically choose T0
primitive task
{(a, ) : ground instance operator D, substitution unifies {head(a), t}, satisfies preconditions}
= return failure
nondeterministically choose pair (a, )
modify deleting del(a) adding add(a)
append P
modify removing applying
T0 {t : task constrained precede t}
else
{(m, ) : instance method D, unifies {head(m), t},
pre(m) true s, general possible}
= return failure
nondeterministically choose pair (m, )
modify removing t, adding sub(m), constraining task
sub(m) precede tasks preceded, applying
sub(m) 6=
T0 {t sub(m) : task constrained precede t}
else T0 {t : task constrained precede t}
repeat
end SHOP2
Figure 5: simplified version SHOP2 planning procedure.

tail clause (or precondition operator method) contains negation,
handled way Prolog: theorem prover takes (not a) true
cannot prove a.

3.1.5 External Function Calls
External function calls useful, example, numeric evaluations (e.g.,
ZenoTravel domain, check requirement available fuel must greater
equal product burn rate distance traveled). example,
competition, SHOP2 used graph-algorithm library compute shortest paths
graph. principle, would possible implement graph algorithms set
methods. However, writing external functions allows run faster, also
makes possible access predefined code libraries.
385

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

3.2 SHOP2 Algorithm
Figure 5 shows simplified version SHOP2 planning procedure. arguments
include initial state s, partially ordered set tasks , domain description D.
mentioned earlier, SHOP2 plans tasks order
executed. order this, nondeterministically chooses task
predecessors; first task SHOP2 start working on. point,
two cases.
first case primitive, i.e., accomplished directly using action
(i.e., instance planning operator). case, SHOP2 finds action
matches whose preconditions satisfied s, applies (if action
exists, branch search space fails).
second case compound, i.e., method needs applied
decompose subtasks. case, SHOP2 nondeterministically chooses method
instance decompose subtasks (if method instance exists,
branch search space fails).
solution plan involves m, actions P leaf nodes
decomposition tree DP tree shown Figure 2. precondition formula
pre(m) must true state immediately precedes first action DP
descendant m. order ensure pre(m) true correct state, SHOP2 needs
generate leftmost branch way bottom, evaluate pre(m)
state a. last three lines loop ensure happen,
telling SHOP2 current method subtasks, SHOP2 generate one
subtasks generating subtasks task network.
example, SHOP2 could begin generating plan Figure 2 first decomposing
(transport-two p1 p2) (transport p1) (transport p2), nondeterministically
choosing decompose (transport p1) {(dispatch t1 l1), (pickup t1 p1), (move t1 l1
l3)}. done that, SHOP2 would required decompose (dispatch t1 l11)
decomposing (transport p2), order guarantee (dispatch t1 l1) (reserve t1)
occur state world (available t1) evaluated. operator
(reserve t1) makes t1 unavailable, thus ensuring (transport p2) decomposed
later, decomposition use truck t2 rather t1.
3.3 Additional Features
SHOP2 several additional features addition basic ones described earlier.
section describes significant ones.
3.3.1 Sorting Variable Bindings
SHOP2 evaluates methods precondition, gets list possible sets
variable bindings satisfy expression current state. set variable
bindings lead different branch SHOP2s search tree. nondeterministic choice
implemented SHOP2 via depth-first backtracking. SHOP2 find good solution
find quickly, important decide set variable bindings try first.
purpose, SHOP2 sort-by construct sorts list variable bindings specified criterion. especially useful planning problem
386

fiSHOP2: HTN Planning System

(:method
; head
(transport-person ?p ?c2)
; precondition
(:sort-by ?cost #<
(and (at ?p ?c1)
(aircraft ?a)
(at ?a ?c3)
(different ?c1 ?c3)
(cost-of ?a ?c3 ?c1 ?cost)))
; subtasks
((move-aircraft ?a ?c1)
(board ?p ?a ?c1)
(move-aircraft ?a ?c2)
(debark ?p ?a ?c2)))
Figure 6: Using sort-by SHOP2 method simplified ZenoTravel domain.
optimization problem, e.g., problem objective find plan
least possible cost. sort-by construct, write heuristic function estimate
anticipated cost set variable bindings, sort sets variable bindings
according heuristic-function values SHOP2 try promising one first.
example, precondition
(and (at ?here) (distance ?here ?there ?d))
may several different combinations ?here, ?there, ?d satisfy
precondition. expression
(:sort-by ?d #> (and (at ?here) (distance ?here ?there ?d)))
cause SHOP2 consider variable bindings decreasing order value ?d.
complicated example, recall precondition method Figure 3.
may several sets variable bindings satisfy precondition current
state. reformulation precondition Figure 6 tells SHOP2 sort sets
variable bindings increasing order ?cost variable. way, SHOP2 look first
alternative lowest ?cost value.
3.3.2 Branch-and-Bound Optimization
SHOP2 allows option using branch-and-bound optimization search leastcost plan. option generally results spending additional planning time order
search plans superior quality. using branch-and-bound option, one also
specify time limit search. search takes longer time limit, SHOP2
terminates search returns best plan found far; functionality
partly inspired anytime algorithms (Boddy & Dean, 1989).
387

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

3.3.3 PDDL Operator Translation
SHOP2s planning procedure proved sound complete across large set
planning problems, sense set methods operators capable generating solution problem, planning procedure guaranteed generate
correct plan (Nau et al., 2001). However, proof tells us planning
algorithm work correctly domain description correct, tell us
whether domain description represents planning domain given set
PDDL planning operators.
AIPS-2000 planning competition, problem caused difficulty SHOP2s
predecessor SHOP. SHOP team developing domain descriptions SHOP purely
hand, made mistakes writing two domains. Thus SHOP found
incorrect solutions problems domains, judges disqualified
SHOP domains.
developing SHOP2, wrote translator program translate PDDL operators
SHOP2 domain descriptions. domain descriptions produced translator
program sufficient efficient planning SHOP2: need modified
hand order put domain knowledge, described Section 4. However,
translator program least provide correct starting point.

3.3.4 Debugging Facilities
SHOP2 also includes several debugging facilities. important tracing
mechanism: one tell SHOP2 trace set operators, methods, axioms.
example, Figure 8, given names (namely Case1 Case2) two different
clauses method. tell SHOP2 trace either clauses them;
SHOP2 print messages time enters exits clause traced.
Depending particular tracing options one selects, messages may include
things argument list, current state world, information
whether operator, method axiom succeeds fails.

3.3.5 Protected Conditions Anti-Interleaving
SHOP2s planning operators include way specify protected conditions. feature
described briefly Nau et al. (2001), bother describe
use planning competition. cases wanted protect
conditions possible threats, found convenient either make use flags
similar available-truck flag Figure 1, use following anti-interleaving
feature SHOP2.
method subtasks t1 , . . . , tk , ti begins keyword :immediate,
tells SHOP2 plan ti immediately ti1 finishes, without trying
interleave tasks ti1 ti . Several examples appear appendix.
388

fiSHOP2: HTN Planning System

task person: transport person his/her destination
(these tasks unordered; thus subtasks may interleaved)
task plane: transport plane destination
(these tasks unordered; thus subtasks may interleaved)
method transporting person:
person already desired destination nothing
else
select plane
plane persons current position move
hold plane current position
board person onto plane
move plane destination
debark person destination
method transporting plane:
plane already desired destination nothing
else move plane destination
Figure 7: Abstract tasks methods simplified version ZenoTravel domain.

4. Developing Domain Descriptions SHOP2
4.1 Basics
first step developing domain description SHOP2 formulate abstract
tasks methods constitute reasonable problem-solving strategy. example,
use simplified version ZenoTravel (one domains planning competition).
problem transport people current locations destination,
use available airplanes. Figure 7 shows set abstract tasks methods
transporting people moving airplanes.
abstract strategy like one Figure 7, implement
SHOP2 domain description consisting methods, operators axioms. example,
method transporting person shown Figure 8. may one
value ?p satisfies precondition (plane ?p). so, plane use
nondeterministic branching point SHOP2. nondeterministic branching points,
domain description may include heuristics guide SHOP2s search; Section 4.3
discusses ways write heuristics.
method transport-with-plane task, one preconditions whether
planes fuel level enough get plane current position destination.
Figure 4 shows axiom precondition.
Actions, boarding people onto planes, debarking planes, refueling
planes, modeled operators SHOP2. example, SHOP2 operator
boarding given Figure 9.
389

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:method
; head
(transport-person ?person ?destination)
Case1 ; label use debugging
; preconditions
(and (at ?person ?current-position)
(same ?current-position ?destination))
; subtasks
()
Case2 ; label use debugging
; preconditions
(and (at ?person ?current-position)
(plane ?p))
; subtasks
((transport-with-plane ?person ?p ?destination)))
Figure 8: SHOP2 implementation one methods Figure 7.
(:operator
; head
(board ?person ?plane)
; preconditions
(and (at ?person ?place) (at ?plane ?place))
; delete list
((at ?person ?place))
; add list
((in ?person ?plane)))
Figure 9: SHOP2 operator simplified ZenoTravel domain.

4.2 Writing Temporal Domains
SHOP2s operators least expressive Level 2 actions PDDL, SHOP2
explicitly support durative actions Level 3 PDDL, SHOP2
explicit mechanism reasoning durative concurrent actions.
However, SHOP2 still enough expressive power represent durative concurrent
actions, knows current state step planning process since
operators assign values variables numeric calculations. allowed
us develop preprocessing technique call Multi-Timeline Preprocessing (MTP).
MTP technique translating PDDL operators SHOP2 operators keep track
temporal information current state.
pseudocode Figure 10 algorithmic description MTP does.
principle, MTP could automatedbut practice, always done hand,
needs done planning domain.
390

fiSHOP2: HTN Planning System

every operator planning domain
add two parameters ?start ?duration
os precondition
add assignment ?duration
formula calculating os duration
add assignment ?start
formula takes maximum write times
dynamic properties os precondition read times
dynamic properties os effects
dynamic property p os effects
add effects change value write-time(p) ?start +?duration
dynamic property appears
add effects change read-time(p) maximum
read-time(p) ?start +?duration
Figure 10: Multi-timeline preprocessing (MTP).
keep description MTP simple, let us suppose state s, every atom
(p c1 . . . cn ) represents single-valued property, i.e., one cn (p c1
. . . cn1 cn ) true s. property dynamic operator may change value cn .
example, initial state contains (at plane1 city1) operator
moves plane1 different location, location plane1 dynamic.
property p changes time, MTP modifies operators keep track,
within current state, times property changes times
various preconditions depend property. idea dynamic property
p, current state contain two time-stamps: read-time(p), last time
action read value p, write-time(p), last time action
modified value p. MTP modifies operators way whenever
operator reads (i.e., accesses) dynamic property, operator update propertys
read-time, operator writes (i.e., modifies) dynamic property, update
propertys write-time. Thus, instead single global time, current state contain
many local times, namely read-time write-time dynamic property.
MTP also inserts preconditions action ensure action begins
read-time property writes write-time property
reads. prevents two actions overlapping time one writes
property reads it. example, boarding operator fly operator
plane may overlap, boarding operator requires plane
located particular city fly operator changes location plane.
Figure 11 shows one SHOP2 operators produced MTP ZenoTravel
domain. operator involves two dynamic properties: vehicles fuel level location.
operator reads properties, may start write times.
However, writes one (the fuel level), may start read time
vehicles location. Thus refueling may performed concurrently
actions depend vehicles location, cannot performed concurrently
actions modify fuel level modify vehicles location.
391

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:operator (!refuel ?plane ?city ?start ?duration)
; preconditions
((aircraft ?plane)
(city ?city)
(at ?plane ?city)
(fuel ?plane ?fuel-level)
(capacity ?plane ?fuel-cap)
(refuel-rate ?plane ?rate)
(assign ?duration (/ (- ?fuel-cap ?fuel-level) ?rate))
(write-time fuel ?plane ?t1)
(write-time ?plane ?t2)
(read-time fuel ?plane ?t3)
(assign ?start (eval (max ?t1 ?t2 ?t3)))
(assign ?end (eval (+ ?start ?duration)))
(read-time ?plane ?t4)
(assign ?new-value (eval (max ?t4 ?end))))
; delete list
((fuel ?plane ?fuel-level)
(write-time fuel ?plane ?t1)
(read-time fuel ?plane ?t3)
(read-time ?plane ?t4))
; add list
((fuel ?plane ?fuel-cap)
(write-time fuel ?plane ?end)
(read-time fuel ?plane ?end)
(read-time ?plane ?new-value)))
Figure 11: sample SHOP2 operator produced MTP.
4.3 Writing Domains Include Optimization
previous planning competitions, planning benchmarks compared speed
planners length output plans, domain designers concentrated trying
find reasonably short plan quickly possible. contrast, problems
years competition included linear objective function needed optimized:
best plan longer one minimizes number steps, instead
one minimized objective-function value. tried three approaches searching
optimal plans:
1. Structure SHOP2 methods way take SHOP2 more-or-less directly
toward plan minimizes objective function.
2. Write methods, operators, axioms generate plans quickly, use sort-by
feature tell SHOP2 sort alternatives try promising ones first.
3. Assign costs operators, use branch-and-bound search find best
plan within execution time limit.
392

fiSHOP2: HTN Planning System

first approach works well easy tell alternative best
node search space. example, know problem instances
objective minimize total fuel used, perfect heuristic ZenoTravel
domain always use fly action instead zoom action. However, approach
doesnt work well isnt immediately obvious alternative best. example,
objective minimize total time, naive approach would always use
zoom action rather fly action, since zoom action faster. However,
zoom action always best choice, requires fuel thus cause
delays refueling.
second approach extension first approach. Consider example
ZenoTravel domain objective minimize total fuel used. addition
making planes fly instead zoom; using closer plane transport person also
reduces total fuel used. set preference using sort-by feature SHOP2.
precondition method transporting person sort available planes
according fuel use order pick person. greedy approach.
decision point sort alternatives cost, go alternative
lowest objective-function value. Thus, approach guaranteed find
optimal solution. However, combined suitable heuristics, approach results
near-optimal plans. competition used technique extensively, produced
satisfactory plans even largest problems.
third approach makes use branch-and-bound optimization, explained Section
3.3.2. main idea quickly define methods let find plan may
poor quality let SHOP2 perform branch-and-bound search plan space
find least cost plan best plan find within execution time limit.
third approach, challenge setting cost operator.
example, objective function requires minimizing total time, order take
concurrency account, cost action always equal duration.
example, suppose latest event current partial plan plane arrive
airport time t, two passengers need board plane. need
add two boarding actions plan. Recall ZenoTravel domain, boarding
actions take amount time, tb , performed concurrently. However,
SHOP2 needs add actions plan one time. first boarding action
increase total time tb , cost tb . However, second boarding action
increase total time plan, cost 0. Now, suppose add refuel action
plan. action done concurrently boarding actions, cost
max(0, tr tb ), tr time needed refuel.
possible combine two approaches. However, experience, using optimization (the third approach) provide much benefit domain
descriptions already included two approaches. situations, SHOP2
would frequently find optimal nearly optimal plan even without optimization,
meant additional amount time needed branch-and-bound optimization would
produce little benefit. Branch-and-bound optimization would perhaps useful
planning domains cost plan something sum costs
operators; however, domains occur planning competition.
393

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

International Planning Competition, use optimization approach
official competition trial. competition domains, preliminary
testing SHOP2 optimization time limits, SHOP2 unable find solutions
within amount time willing let run, except smallest
problems. One way overcome difficulty would use time limits,
preliminary tests, never provided significant improvements cost across entire
problem set. One reason lack improvement spent great deal
effort crafting methods used competition. think third approach would
useful cases immediately clear implement first two
approaches, one want spend much time devising sophisticated domain
description.

5. Competition Results
Fourteen planning systems competed 2002 International Planning Competition.
SHOP2 received distinguished performance award, one top four awards.
SHOP2 (along TLPlan TALPlanner) one three planners solved
problems hand-tailored fully automated tracks. SHOP2 able
solve problems Strips, Numeric, HardNumeric, SimpleTime, Time, Complex
domains. SHOP2 solved problems planner competition:
solved 899 904 problems, 99% success ratio.
two hand-tailorable planners, TLPlan solved 894 problems, nearly many
SHOP2. Since TALPlanner didnt numeric domains, solved 610 problems,
still several hundred problems fully-automated planners solved.
general, SHOP2 tended slower TALPlanner TLPlanner, although
one domain (Satellite-HardNumeric) SHOP2 consistently fastest.
speeds three hand-tailorable planners generally appeared polynomially
related other, probably planners domain knowledge enabled
find solutions without much backtracking. three hand-tailorable planners
generally much faster fully-automated planners.
None three hand-tailorable planners dominated two terms plan
quality. them, situations solutions significantly better
significantly worse two.

6. Related Work
following subsections discuss HTN planning, ordered task decomposition,
hand-tailorable planners participated competition.
6.1 HTN Planning
HTN planning first developed 25 years ago (Sacerdoti, 1990; Tate, 1977).
Historically, HTN-planning researchers focused practical applications.
Examples include production-line scheduling (Wilkins, 1988), crisis management logistics (Currie & Tate, 1991; Tate, Drabble, & Kirby, 1994; Biundo & Schattenberg, 2001),
planning scheduling spacecraft (Aarup, Arentoft, Parrod, Stader, & Stokes, 1994;
394

fiSHOP2: HTN Planning System

Estlin, Chien, & Wang, 1997), equipment configuration (Agosta, 1995), manufacturability
analysis (Hebbar, Smith, Minis, & Nau, 1996; Smith, Hebbar, Nau, & Minis, 1997), evacuation planning (Munoz-Avila, Aha, Nau, Weber, Breslow, & Yaman, 2001), game
bridge (Smith, Nau, & Throop, 1998a, 1998b).
development formal semantics HTN planning (Erol, Nau, & Hendler, 1994;
Erol, Hendler, & Nau, 1996) shown strictly expressive classical
AI planning: problems expressed HTN planning problems
classical planning problems.4 Even one places restrictions HTN planning
restrict expressive power classical planning, generally much easier
translate classical planning problems HTN planning problems vice versa (Lotem,
Nau, & Hendler, 1999).
6.2 Ordered Task Decomposition
Ordered task decomposition (Nau, Smith, & Erol, 1998) special case HTN planning
planning algorithm always builds plans forward initial state world.
words, ordered-task-decomposition planner plans tasks order
tasks later performed. first applications ordered task decomposition
tailor-made specific application domains. best known example code
declarer play helped Bridge Baron win 1997 world championship computer
bridge (Smith et al., 1998b).
SHOP2 based SHOP (Nau et al., 1999), previous domain-independent orderedtask-decomposition planner requires subtasks method, also initial
set tasks planning problem, totally ordered rather partially ordered.
Thus SHOP, subtasks different tasks cannot interleaved. SHOP2 extends SHOP
allowing subtasks method partially ordered. Experiments shown
allow SHOP2 create plans efficiently SHOP, using domain descriptions
simpler needed SHOP (Nau et al., 2001). SHOP SHOP2
available open-source software hhttp://www.cs.umd.edu/projects/shopi.
6.3 TLPlan TALPlanner
Like SHOP2, TLPlan (Bacchus & Kabanza, 2000) TALPlanner (Doherty & Kvarnstrom, 2001) competed hand-tailored track AIPS-2002 planning competition.
TLPlan TALPlanner similar many respects. forward-chaining
search apply planning operators current state generate successors. Thus, like SHOP2, know current state world every step
planning process. control search, planners use control rules written
declaratively temporal logic. rules provide domain-specific knowledge tell
planner states bad states, planner backtrack try
4. specifically, HTN planning Turing-complete: even undecidable problems expressed
HTN planning problems. remains Turing-complete even restrict tasks logical atoms
purely propositional (i.e., arguments all). contrast, classical planning
represents planning problems solutions regular sets. Planners TLPlan (Bacchus
& Kabanza, 2000) TALPlanner (Doherty & Kvarnstrom, 2001) overcome limitation classical
planning extending formalism include function symbols.

395

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

paths search space. One difference TLPlan TALPlanner TLPlan
uses linear modal tense logic, TALPlanner use TAL, narrative-based linear temporal logic used reasoning action change incompletely specified dynamic
environments.
main difference planners SHOP2 kind control
knowledge use: TLPlan TALPlanner use temporal formulas tell
part search space avoided, whereas SHOP2 uses HTN methods tell
parts search space explored. SHOP2s search space consists
nodes reachable using HTN methods, whereas TLPlan TALPlanner
explore part search space avoids bad states successors.
hard say type control knowledge effective. Bacchus Kabanza
(2000) argue two types useful different situations combining
useful topic future research.

7. Summary Conclusions
primary difference SHOP2 HTN planners SHOP2 plans
tasks order executed, thus knows current state
step planning process. reduces complexity reasoning removing
great deal uncertainty world, made easy us incorporate substantial expressive power SHOP2. addition usual HTN methods
operators, SHOP2s domain descriptions may include axioms, mixed symbolic/numeric
conditions, external function calls. planning procedure Turing-complete,
sound complete large class planning problems (Nau et al., 2001).
Like HTN planning systems, SHOP2 plans decomposing tasks subtasks.
key idea using HTN planner design set methods encode something
akin standard operating procedures capture multi-step techniques refining
task. kinds domain characteristics much natural express HTN
formalism action-based formalism; see Lotem et al. (1999) description
issued involved.
example, consider UM-Translog-2 domain, wrote use problem
domain AIPS-2002 planning competition (Wu & Nau, 2002). UM-Translog-2
straightforward generalization UM Translog domain (Andrews, Kettler, Erol, &
Hendler, 1995); generalizations include numeric information distances, fuel
usage, forth. relatively straightforward formulate UM-Translog-2
HTN planning domain. However, much difficult figure formulate
UM-Translog-2 PDDL domain use competitors planning competition;
task took several months accomplish.
HTN planning systems, SHOP2s development originally motivated planning competition instead try solve practical planning
problems. example, JSHOP (a Java implementation SHOP2s predecessor SHOP)
generative-planning component HICAP system planning evacuation operations (Munoz-Avila et al., 2001), currently incorporating SHOP2 HICAP
replacement JSHOP. pleased SHOP2s capabilities also gave
ability excel International Planning Competition!
396

fiSHOP2: HTN Planning System

Acknowledgments
work supported part following grants, contracts, awards: Air Force
Research Laboratory F30602-00-2-0505, Army Research Laboratory DAAL0197K0135, Naval
Research Laboratory N00173021G005, University Maryland General Research
Board. opinions expressed paper authors necessarily
reflect opinions funders.
also wish thank anonymous reviewers, whose comments helped us make
significant improvements paper.

Appendix A. SHOP2 Domain Description ZenoTravel Domain
(Numeric Version)
AIPS-2002 Planning Competition, four different versions ZenoTravel
domain: Strips version, Numeric version, Simple Time version, Time
version. developed SHOP2 domain descriptions four versions.
follows domain description Numeric version ZenoTravel domain. operators domain description translated original PDDL
coding using rough approximation MTP process Figure 10.
(defdomain ZENOTRAVEL
(
(:- (same ?x ?x) ())
(:- (different ?x ?y) ((not (same ?x ?y))))
(:-(possible-person-in ?city)
((person ?p) (at ?p ?city) (goal ?p ?city2)
(different ?city2 ?city)))
(:operator (!!cost ?end)
((maxtime ?max)
(assign ?newmax (eval (if (< ?max ?end) ?end ?max))))
((maxtime ?max))
((maxtime ?newmax))
(- ?newmax ?max))
(:method (board ?p ?a ?c)
((write-time ?a ?start))
((!board ?p ?a ?c ?start 1)
(:immediate !!cost (call + ?start 1))))
(:operator (!board ?p ?a ?c ?start ?duration)
((person ?p) (aircraft ?a) (city ?c)
(at ?a ?c) (at ?p ?c) (onboard ?a ?num)
(read-time ?a ?pmax) (assign ?new-num (+ ?num 1))
(assign ?newpmax (max ?pmax (+ ?start ?duration 0.01L0))))
((onboard ?a ?num) (read-time ?a ?pmax) (at ?p ?c) (dest ?a ?c))
((onboard ?a ?new-num) (read-time ?a ?newpmax) (in ?p ?a))
397

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

0.001)
(:method (debark ?p ?a ?c)
((write-time ?a ?start))
((!debark ?p ?a ?c ?start 1)
(:immediate !!cost (call + ?start 1))))
(:operator (!debark ?p ?a ?c ?start ?duration)
((person ?p) (aircraft ?a) (city ?c)
(at ?a ?c) (in ?p ?a) (onboard ?a ?num)
(read-time ?a ?pmax) (assign ?new-num (- ?num 1))
(assign ?newpmax (max ?pmax (+ ?start ?duration 0.01L0))))
((onboard ?a ?num) (read-time ?a ?pmax) (in ?p ?a) (dest ?a ?c))
((onboard ?a ?new-num) (read-time ?a ?newpmax) (at ?p ?c))
0.001)
(:method (refuel ?a ?c)
((write-time ?a ?start) (read-time ?a ?pmax)
(capacity ?a ?cap) (fuel ?a ?fuel)
(eval (> ?cap ?fuel))
(assign ?duration 1)
(assign ?end (+ ?start ?duration 0.01L0))
(assign ?newpmax (max ?pmax ?end)))
((!!ra ((read-time ?a ?pmax))
((read-time ?a ?newpmax)))
(:immediate !refuel ?a ?c ?start ?duration)
(:immediate !!cost ?end)))
(:operator (!refuel ?a ?c ?start ?duration)
((aircraft ?a) (city ?c) (at ?a ?c)
(fuel ?a ?fuel) (capacity ?a ?cap))
((fuel ?a ?fuel))
((fuel ?a ?cap))
0.001)
(:method (zoom ?a ?c1 ?c2)
((write-time ?a ?astart) (read-time ?a ?pmax)
(distance ?c1 ?c2 ?dist)
(fuel ?a ?fuel) (fast-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?duration 1)
(assign ?start (max ?pmax ?astart))
(assign ?end (+ ?start ?duration 0.01L0)))
((!!ra ((write-time ?a ?astart) (read-time ?a ?pmax))
((read-time ?a 0) (write-time ?a ?end)))
(:immediate !zoom ?a ?c1 ?c2 ?start ?duration)
(:immediate !!cost ?end)))
(:operator (!zoom ?a ?c1 ?c2 ?start ?duration)
((aircraft ?a) (city ?c1) (city ?c2) (onboard ?a ?num)
(zoom-limit ?a ?limit) (eval (<= ?num ?limit))
398

fiSHOP2: HTN Planning System

(at ?a ?c1) (distance ?c1 ?c2 ?dist) (fast-burn ?a ?burn)
(total-fuel-used ?total-fuel)
(assign ?new-total (+ ?total-fuel (* ?dist ?burn)))
(fuel ?a ?fuel)
(assign ?new-fuel (- ?fuel (* ?dist ?burn))))
((at ?a ?c1) (total-fuel-used ?total-fuel) (fuel ?a ?fuel) )
((at ?a ?c2) (total-fuel-used ?new-total) (fuel ?a ?new-fuel))
0.001)
(:method (fly ?a ?c1 ?c2)
((write-time ?a ?astart) (read-time ?a ?pmax)
(distance ?c1 ?c2 ?dist)
(fuel ?a ?fuel) (slow-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?duration 1)
(assign ?start (max ?pmax ?astart))
(assign ?end (+ ?start ?duration 0.01L0)))
((!!ra ((write-time ?a ?astart) (read-time ?a ?pmax))
((read-time ?a 0) (write-time ?a ?end)))
(:immediate !fly ?a ?c1 ?c2 ?start ?duration)
(:immediate !!cost ?end)))
(:operator (!fly ?a ?c1 ?c2 ?start ?duration)
((aircraft ?a) (city ?c1) (city ?c2)
(at ?a ?c1) (distance ?c1 ?c2 ?dist) (slow-burn ?a ?burn)
(total-fuel-used ?total-fuel)
(assign ?new-total (+ ?total-fuel (* ?dist ?burn)))
(fuel ?a ?fuel)
(assign ?new-fuel (- ?fuel (* ?dist ?burn))))
((at ?a ?c1)(total-fuel-used ?total-fuel)(fuel ?a ?fuel))
((at ?a ?c2)(total-fuel-used ?new-total)(fuel ?a ?new-fuel))
0.001)
(:operator (!!preprocessing ?problem-name)
((totaltime-coeff ?tc) (fuelused-coeff ?fc)
(eval (setf *tc* ?tc))
(eval (setf *fc* ?fc)))
()
()
0)
(:operator (!!assert ?g )
()
()
?g
0)
(:operator (!!ra ?D ?A )
()
?D
?A
0)
399

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

;;;;
;;;;; Main Methods
;;;;;
(:method (transport-person ?p ?c)
Case1 ((at ?p ?c))
())
(:method (transport-person ?p ?c2)
Case2 (:sort-by ?num #>
((at ?p ?c1)
(at ?a ?c1)
(aircraft ?a)
(onboard ?a ?num)))
((!!assert ((dest ?a ?c1)))
(:immediate board ?p ?a ?c1)
(!!assert ((dest ?a ?c2)))
(:immediate upper-move-aircraft-no-style ?a ?c2)
(:immediate debark ?p ?a ?c2)))
(:method (transport-person ?p ?c2)
Case3 (:sort-by ?cost #<
((at ?p ?c1)
(aircraft ?a)
(at ?a ?c3)
(different ?c1 ?c3)
(forall (?c) ((dest ?a ?c)) ((same ?c ?c1)))
(imply ((different ?c3 ?c1))
(not (possible-person-in ?c3)))
(travel-cost-info ?a ?c3 ?c1 ?cost ?style)))
((!!assert ((dest ?a ?c1)))
(:immediate upper-move-aircraft ?a ?c1 ?style)
(:immediate board ?p ?a ?c1)
(!!assert ((dest ?a ?c2)))
(:immediate upper-move-aircraft-no-style ?a ?c2)
(:immediate debark ?p ?a ?c2)))
(:method (upper-move-aircraft ?a ?c ?style)
Case1 ((at ?a ?c))
()
Case2 ((at ?a ?somecity))
((move-aircraft ?a ?somecity ?c ?style)))
(:method (upper-move-aircraft-no-style ?a ?c)
Case1 ((at ?a ?c))
()
Case2 (:sort-by ?cost #<
((at ?a ?somecity)
(travel-cost-info ?a ?somecity ?c ?cost ?style)))
((move-aircraft ?a ?somecity ?c ?style)))
400

fiSHOP2: HTN Planning System

(:- (travel-cost-info ?a ?from ?to ?cost slow)
CASE1
((capacity ?a ?cap) (distance ?from ?to ?dist)
(slow-burn ?a ?burn) (eval (< ?cap (* ?dist ?burn)))
(assign ?cost most-positive-fixnum))
CASE2
((distance ?from ?to ?dist) (fuel ?a ?fuel)
(slow-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?cost (float (/
(+ *tc*
(* *fc*
(* ?dist ?burn)))
1))))
CASE3
((capacity ?a ?cap)(distance ?from ?to ?dist)
(slow-burn ?a ?burn)
(assign ?cost (float (/
(+ (* *tc* 2)
(* *fc*
(* ?dist ?burn)))
1)))))
(:- (travel-cost-info ?a ?from ?to ?cost fast)
CASE1
((capacity ?a ?cap) (distance ?from ?to ?dist)
(fast-burn ?a ?burn) (eval (< ?cap (* ?dist ?burn)))
(assign ?cost most-positive-fixnum))
CASE2
((distance ?from ?to ?dist) (fuel ?a ?fuel)
(zoom-limit ?a ?limit) (onboard ?a ?num) (eval (< ?num ?limit))
(fast-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?cost (float (/
(+ *tc*
(* *fc*
(* ?dist ?burn)))
1))))
CASE3
((capacity ?a ?cap)(distance ?from ?to ?dist)
(fast-burn ?a ?burn)
(zoom-limit ?a ?limit) (onboard ?a ?num) (eval (< ?num ?limit))
(assign ?cost (float (/
(+ (* *tc* 2)
(* *fc*
(* ?dist ?burn)))
1)))))

401

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:method (move-aircraft ?a ?c1 ?c2 slow)
((fuel ?a ?fuel) (distance ?c1 ?c2 ?dist)
(slow-burn ?a ?burn)
(eval (> ?fuel (* ?dist ?burn))))
((fly ?a ?c1 ?c2))
()
((refuel ?a ?c1)
(:immediate fly ?a ?c1 ?c2)))
(:method (move-aircraft ?a ?c1 ?c2 fast)
((fuel ?a ?fuel) (distance ?c1 ?c2 ?dist)
(fast-burn ?a ?burn)
(eval (> ?fuel (* ?dist ?burn))))
((zoom ?a ?c1 ?c2))
()
((refuel ?a ?c1)
(:immediate zoom ?a ?c1 ?c2)))
(:method (transport-aircraft ?a ?c)
((not (no-use ?a)))
((!!assert ((no-use ?a)))
(:immediate upper-move-aircraft-no-style ?a ?c)
(:immediate !!ra ((no-use ?a)) ())))

References
Aarup, M., Arentoft, M. M., Parrod, Y., Stader, J., & Stokes, I. (1994). OPTIMUM-AIV:
knowledge-based planning scheduling system spacecraft AIV. Intelligent
Scheduling, pp. 451469. Morgan Kaufmann.
Agosta, J. M. (1995). Formulation implementation equipment configuration
problem SIPE-2 generative planner. Proc. AAAI-95 Spring Symposium
Integrated Planning Applications, pp. 110.
Andrews, S., Kettler, B., Erol, K., & Hendler, J. (1995). UM Translog: planning domain
development benchmarking planning systems. Tech. rep. CS-TR-3487,
Dept. Computer Science, University Maryland.
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116.
Biundo, S., & Schattenberg, B. (2001). abstract crisis concrete relief. preliminary
report flexible integration nonlinear hierarchical planning. Proceedings
European Conference Planning.
Boddy, M., & Dean, T. (1989). Solving time-dependent planning problems. Sridharan,
N. S. (Ed.), Proceedings Eleventh International Joint Conference Artificial
Intelligence, pp. 979984, Detroit, MI, USA. Morgan Kaufmann.
Currie, K., & Tate, A. (1991). O-Plan: open planning architecture. Artificial Intelligence, 52 (1), 4986.
402

fiSHOP2: HTN Planning System

Doherty, P., & Kvarnstrom, J. (2001). TALplanner: temporal logic based planner. AI
Magazine, 22 (3), 95102.
Erol, K., Hendler, J., & Nau, D. (1996). Complexity results Hierarchical Task-Network
planning. Annals Mathematics Artificial Intelligence, 18, 6993.
Erol, K., Nau, D., & Hendler, J. (1994). HTN planning: Complexity expressivity.
AAAI-94.
Estlin, T. A., Chien, S. A., & Wang, X. (1997). argument hybrid HTN/operatorbased approach planning. Proc. Fourth European Conference Planning (ECP97), pp. 184196.
Gupta, N., & Nau, D. S. (1992). complexity blocks-world planning. Artificial
Intelligence, 56 (2-3), 223254.
Hebbar, K., Smith, S., Minis, I., & Nau, D. (1996). Plan-based evaluation designs
microwave modules. Proc. ASME Design Technical Conference.
Lotem, A., Nau, D., & Hendler, J. (1999). Using planning graphs solving HTN problems.
AAAI-99, pp. 534540.
Munoz-Avila, H., Aha, D., Nau, D., Weber, R., Breslow, L., & Yaman, F. (2001). SiN:
Integrating case-based reasoning task decomposition. IJCAI-2001.
Nau, D., Cao, Y., & Munoz-Avila, H. (1999). SHOP: Simple Hierarchical Ordered Planner.
IJCAI-99, pp. 968973.
Nau, D., Munoz-Avila, H., Cao, Y., Lotem, A., & Mitchell, S. (2001). Total-order planning
partially ordered subtasks. IJCAI-2001, Seattle.
Nau, D. S., Smith, S. J. J., & Erol, K. (1998). Control strategies HTN planning: Theory
versus practice. AAAI-98/IAAI-98 Proceedings, pp. 11271133.
Sacerdoti, E. D. (1990). nonlinear nature plans. Allen, J., Hendler, J., & Tate, A.
(Eds.), Readings Planning, pp. 162170. Morgan Kaufmann. Originally appeared
Proc. IJCAI-75, pp. 206-214.
Slaney, J., & Thiebaux, S. (2001). Blocks world revisited. Artificial Intelligence, 125 (1-2),
119153.
Smith, S. J., Hebbar, K., Nau, D., & Minis, I. (1997). Integrating electrical mechanical
design process planning. Mantyla, M., Finger, S., & Tomiyama, T. (Eds.),
Knowledge Intensive CAD, Vol. 2, pp. 269288.
Smith, S. J., Nau, D. S., & Throop, T. (1998a). Success spades: Using AI planning
techniques win world championship computer bridge. AAAI-98/IAAI-98,
pp. 10791086.
Smith, S. J. J., Nau, D. S., & Throop, T. (1998b). Computer bridge: big win AI
planning. AI Magazine, 19 (2), 93105.
Tate, A. (1977). Generating project networks. IJCAI-77, pp. 888893.
Tate, A., Drabble, B., & Kirby, R. (1994). O-Plan2: Architecture Command, Planning Control. Morgan Kaufmann.
403

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

Wilkins, D. E. (1988). Practical Planning: Extending Classical AI Planning Paradigm.
Morgan Kaufmann, San Mateo, CA.
Wu, D., & Nau, D. (2002). UM-Translog-2: planning domain designed AIPS-2002.
Tech. rep. CS-TR-4402, UMIACS-TR-2002-82, University Maryland.

404

fiJournal Artificial Intelligence Research 20 (2003) 1-59

Submitted 3/03; published 12/03

3rd International Planning Competition: Results
Analysis
Derek Long
Maria Fox

derek.long@cis.strath.ac.uk
maria.fox@cis.strath.ac.uk

Department Computer Information Sciences
University Strathclyde, Glasgow, UK

Abstract
paper reports outcome third series biennial international planning competitions, held association International Conference AI Planning
Scheduling (AIPS) 2002. addition describing domains, planners
objectives competition, paper includes analysis results. results
analysed several perspectives, order address questions comparative
performance planners, comparative difficulty domains, degree agreement
planners relative difficulty individual problem instances question well planners scale relative one another increasingly difficult problems.
paper addresses questions statistical analysis raw results
competition, order determine results considered adequately supported data. paper concludes discussion challenges future
competition series.

1. Introduction
Beginning 1998 international planning community held biennial event support direct comparison planning systems changing collection benchmark
planning problems. benefits series events significant: five
years, planning systems developed capable solving large complex
problems, using richly expressive domain models meeting advanced demands
structure quality solutions. competition series inspired many advances
planning research community well increasingly empirical methodology
growing interest application planners real problems.
paper describe structure, objectives outcomes third competition,
took place Toulouse 2002. competition colocated AI Planning
Scheduling (AIPS) conference. conference brief report presented
results achieved participating planners. begin presenting overview
main results presented conference, showing number problems attempted
solved planner identifying competition prize-winners. previous
years competition resulted collection large data set comprising data points
several different domains. certain comparative understanding obtained
examining data individual domains, conclusions drawn basis cannot
generalised across domains. One goals paper try reveal
insights cross boundaries domains allow general questions
answered. include: planners reveal consistent, stable performance
c
2003
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiLong & Fox

across domains? benefit obtained exploiting hand-coded control knowledge?
general agreement makes planning problem hard? particular
planning approaches best suited particular kinds problem domains?
accepted scientific methodology addressing questions frame precise
hypotheses prior collection data sets order control extraneous
variables might distort reality respect questions. date
practice planning community respect competitions.
third competition proceeded, previous years, collecting data prior detailed
consideration specific questions wished answer. community yet
agreed primary role competition provide carefully crafted platform
scientific investigation planners: indeed, main roles far motivate
researchers field, identify new research goals thereby push forward research
horizons, publicise progress wider community. However, competitions
winners natural tendancy draw conclusions competition data
sets state art. conclusions scientifically supported
misleading even erroneous. Therefore argument trying combine
two objectives, although admittedly tension might make
difficult combine successfully.
way planning competitions currently conducted,
analyses describe paper post hoc. conducted analyses
data collected competition period: run experiments
competition participants felt important data
submitted competition comprise evidence judged.
identified number analyses think provide interesting information
planning community and, following sections, explore theme
rigorous way possible within constraints data disposal.
difficult work fixed data set collected without precise experimental
questions mind, unable test many hypotheses occurred us
analyses data inappropriate incomplete. However, despite
limitations data set believe able pose answer
important questions comparative performances revealed competition.
phrase objectives analyses terms null alternative hyptheses
standard approach applying statistical tests. approach partly
inspired earlier work Howe Dahlman (2002). work raised standard
evaluation planners done compels planning community
decide whether future planning competitions conducted way supports
goals scientific investigation progress field.
rest paper organised follows. begin discussing context
competition series general form third competition, including
domains, competitors specific challenges raised. briefly summarise
results competition embarking detailed post hoc analysis competition results. analysis investigates relative performances planners, relative
difficulties problem sets used relative scaling behaviours competitors
across domains levels. provide appendix present summaries
competing planners details domains used.
2

fiThe 3rd International Planning Competition

2. International Planning Competition Series
first event held conjunction fourth international Artificial Intelligence
Planning Scheduling conference (AIPS98). organised Drew McDermott,
together committee senior members research community (McDermott,
2000). event took time organise, evolving agreement form
event, kinds planning systems compared, basis comparison
on. final event became direct comparison 5 strips-based planners, two
planners also attempting extended adl-based language (McDermott, 2000; Long,
2000). systems included three Graphplan-based systems, one forward heuristic search
system one planning-as-satisfiability satsolver planner. important outcome
first competition adoption pddl (McDermott & AIPS98 Planning
Competition Committee, 1998) common representation language planning.
Although opportunity offered competitors hand-code control knowledge
planners, fact planners fully-automated ran problem
instances without priming. entire event staged conference period
four days, involving intensive sessions generating checking solutions
attempting evaluate results. One idea tried, turned
problematic practice, score planners performances using function
attempted take account time taken generate plan, length plan
relative performance competitors problems. example,
planner produced plan faster competitors would rewarded based
much faster average problem. attempt score planners
using one-dimensional measure proved difficult, counter-intuitive results certain
cases. end abandoned favour two dimensions: length plan time
taken produce it. decision indicates that, even five systems relatively
small set problems, impossible make unequivocal decisions system
best. Nevertheless, community (and did) learn much data gathered,
offering variety interpretations data, ultimately inspired improve
every way possible.
second competition, chaired Fahiem Bacchus, 17 planners competed.
increase participation ambitions larger scale testing required event
spread much longer period. fact, testing spread couple months,
one final test carried conference site (AIPS00 Breckenridge).
second competition formal split systems, small number
using hand-coded control knowledge others fully-automated. also
split strips adl capable systems. larger number competitors included
wider range approaches: well Graphplan-based systems, forward heuristic search
satsolver, several planners based model-checking approaches using
bdds, one using planning-by-rewriting. Again, proved difficult compare planners
unequivocally, several important observations could made: advantages handcoded control rules domains could seen clearly (as would expected), although
remained important question difficulty generating writing
rules. fully-automated planners, forward heuristic search approach proved
particularly successful, dominating performance domains. Pure Graphplan-based
3

fiLong & Fox

planning seemed reached zenith first two competitions longer
appeared competitive.
third competition (and recent time writing) held association
AIPS02 Toulouse. Fourteen planners participated. primary objective
competition help push forward research temporal resource-intensive
planning. Extensions made pddl support modelling temporal numeric
domain features. resulted pddl2.1 language (Fox & Long, 2003). extensive
changes pddl2.1 ambitious objectives competition help account
fact fewer people participated 2002 2000. again, real testing
gathering data took place two months prior conference. Although initial
results presented conference, detailed analysis took place conference
itself. rest paper examines objectives third competition, results
future challenges series.

3. Overview: Third International Planning Competition
organisers Third International Planning Competition chose address several
new challenges believe important ambitions planning community: management problems metric constraints numerically valued variables,
temporal planning (including managing concurrency scheduling activities)
construction plans subject specified optimisation criteria simple count
numbers steps.
Setting goals obvious implications potential competitors terms
extended expressive power additional problem-solving required manage extensions. order control extent competitors would required handle
extensions successfully, constructed variants, levels, domains
used competition. domains included strips level, numeric
level (using strips metric variables only), simpletime level actions
duration metric values domain full temporal level, time,
using durative actions durations determined context usage (so duration
depends parameter values action name). simpletime
time levels involve numeric resources time. address combination
introduced additional domain variants, discuss below. four levels
corresponds particular degree expressive power pddl2.1, different
challenges posed versions domain level.
secondary goal assess relative effort generating encoding control
rules planners. Unfortunately, failed find way usefully quantify effort.
discuss question following sections.
3.1 Problem Domains
problem domains selected competitions been, become, benchmark
domains used much community empirical evaluation. domains
used often chosen probe specific detail performance.
sometimes meant domains representative general features planning
4

fiThe 3rd International Planning Competition

inappropriate use widespread testing. description domains
used competitions far found Appendix A.
third competition, eight families domains used, broadly divided
transportation domains (Depots, DriverLog ZenoTravel), applications-inspired domains
(Rovers Satellite) small collection others (Settlers, FreeCell UM-Translog2).
briefly summarise collection describe detail Appendix A.
Depots domain combines transportation style problem Logistics
well-known Blocks domain. Logistics domain exhibits high degree parallelism,
since separate vehicles utilised concurrently. contrast, Blocks domain
characterised significant goal interaction. intention
discover whether successes planners domains separately could
brought together problems combined.
DriverLog problem involves transportation, twist vehicles
must supplied driver move.
Zeno-travel Another transportation problem, inspired domain used testing
zeno planner developed Pemberthy Weld (1994), people must
embark onto planes, fly locations debark, planes consuming
fuel different rates according speed travel.
Satellite domain inspired problem scheduling satellite observations. problems involve satellites collecting storing data using different
instruments observe selection targets.
Rovers domain motivated 2003 Mars Exploration Rover (MER)
missions planned 2009 Mars Science Laboratory (MSL) mission. objective
use collection mobile rovers traverse waypoints planet,
carrying variety data-collection missions transmitting data back
lander. problem includes constraints visibility lander various
locations ability individual rovers traverse particular pairs
waypoints.
Settlers domain revolves around management resources, measured using
metric valued variables. Products must manufactured raw materials used
manufacture transportation materials. New raw materials
generated mining gathering. objective construct variety structures
various specified locations.
UM-Translog-2 domain pddl2.1 encoding new variant UMTranslog (Wu & Nau, 2002) domain. generated us Dan Wu
University Maryland. essentially transportation domain, one
significantly complex previous transportation benchmarks. fact,
domain introduced late competition little data collected.
therefore discussed paper.
5

fiLong & Fox

also reused Freecell domain second competition. domain presented
serious challenge participants 2000 interested see whether planning
technology surpassed challenge intervening two years. Although domain
produced interesting data attempt precisely measure extent
2002 performance surpassed 2000.
domain (other Settlers, Freecell UM-Translog-2) presented
competitors least four different levels previously identified: strips, numeric
simpletime time. problems presented levels comprised distinct
tracks competitors able choose tracks wished compete.
addition four main tracks also included two additional tracks, intended
explore particular ideas. tracks necessitate use additional expressive
power simply allowed existing expressiveness combined produce interesting
planning challenges. example, hardnumeric track consisted problems
Satellite domain logical goals. Plans evaluated metric based
amount data recorded rather determining whether specified logical goal
achieved. challenge planners respond plan metric include
actions would acquire data. complex track consisted problems combined
temporal numeric features. challenge reason resource consumption
parallel managing temporal constraints. total, defveloped 26 domains, 20
problem instances domain (a few, unintentially, ended 16 22 instances).
domains additional 20 instances large problems intended
hand-coded planners. total nearly 1000 problem instances solved,
half intended primarily fully-automated planners.
3.2 Competitors
population competing planning systems changed three competitions.
systems competed system appeared three competitions. part, reflection speed development planning systems, revealing
extent technology 1998 surpassed 2002. also
reflection growing interest series, encouraged competitors
come forward, work involved taking part discouraged previous
competitors repeating effort. Entering competition involves generating interesting efficient approaches solving planning problem: demands
ability construct system respond robustly reliably confronted
previously unseen challenges, including domains amongst used
development system. must sufficiently well-engineered performance
dominated poor programming rather real algorithmic effort solving
problem (careless choice data structure undermine opportunity show
clever new planning algorithm). systems use hand-coded rules guide
planning system additional demand: time required read understand
domains sufficiently construct sensible control knowledge encode test
knowledge achieve good performance. time-table testing relatively
compressed (the entire problem suite generated delivered competitors
two month period testing carried remotely single machine), using
6

fiThe 3rd International Planning Competition

hand-coded controls forced find time analyse domains, hypothesise test
rules intense sessions.
Details competing systems found Appendix B. summarise, many
fully-automated planners use relaxed plan heuristics guide heuristic search.
lpg (Gerevini, Saetti, & Serina, 2003) uses local search improve candidate plan structures formed Graphplan-style plan graph. Several planners (mips, ff sapa) also
extend use relaxed plan heuristics include numeric features. vhpop partialorder planner, demonstrating partial-order planning competitive
recently fashionable heuristic forward state-space search planners. various reasons,
several planners generated small collections results, disregarded
analysis.
competitors used one version planner, one
parameter setting. attempt enforce use unique versions, left
competitors ensure informed variations used. Multiple versions
ff, mips lpg used. ff submitted almost data version optimised
speed performance. small subset data submitted version optimised
quality, showing alternative criteria performance evaluated.
analyses report used data generated ff optimised
speed exclusively. mips also offered data two variants, using slightly different parameter
settings. analyses use data one variant (mips) exclusively, except case
Satellite hardnumeric problems used data variant
(mips.plain). lpg submitted data three versions: one based earliest plan produced,
one based best plan produced longer time span third represented
compromise speed quality. fact, since results version
optimised quality generated within minutes most, chose use data
exclusively analyses follow. borne mind reviewing
results comparative speed performance planners. performance lpg relies
certain parameter settings. cases, parameters used lpg automatically
set, cases parameters set hand. paper, appearing
issue, Gerevini, Saetti Serena (2003) give new results experiment testing
planner parameters set automatically. general observe significant
difference performance lpg respect data provided competition.
three hand-coded planners competed represent two alternative approaches
planning: forward state-space search using control rules prune bad choices promote
good choices, hierarchical task network (htn) planning.
508 problems available fully-automated planners mips
planner attempt them. 904 problems available hand-coded
planners shop2 planner attempt these, solving almost
solving problems overall. tlplan talplanner planners
solved problems attempted. planners attempted problems
equipped handle. particular, sapa attempt strips problems, although
capable solving them.
Although planning competitions great source data stateof-the-art planners encouragement catalyst progress field,
also lively exciting competition events. means must winners.
7

fiLong & Fox

Planner
FF
LPG
MIPS
SHOP2
Sapa
SemSyn
Simplanner
Stella
TALPlanner
TLPlan
TP4
TPSYS
VHPOP

Solved
237 (+70)
372
331
899
80
11
91
50
610
894
26
14
122

Attempted
284 (+76)
428
508
904
122
144
122
102
610
894
204
120
224

Success Ratio
83% (85%)
87%
65%
99%
66%
8%
75%
49%
100%
100%
13%
12%
54%

Tracks entered
S, N, HN
S, N, HN, ST,
S, N, HN, ST, T, C
S, N, HN, ST, T, C
T, C
S, N


S, ST,
S, N, HN, ST, T, C
N, ST, T, C
ST,
S, ST

Figure 1: Table showing problems attempted solved planners third
IPC. Tracks S: strips, N: numeric, HN: hardnumeric, ST: simpletime, T:
time C: complex. Note ff attempted 76 additional problems intended
handcoded planners solved 70 successfully. IxTeT solved
9 problems plans accepted validator attempted 10
problems producing plans could validated due differences
plan syntax used IxTeT defined pddl2.1.

8

fiThe 3rd International Planning Competition

choice winners left organisers must treated caution. summarising
results AIPS conference Toulouse, presented table results form
shown Figure 1, together selection graphs showing relative performance
planners terms speed quality plans several problem sets. hard
synthesise comprehensive view short time final data collection
presentation (a matter couple days, conference), initial assessments
based rather crude evaluation evidence. chose award prize lpg
best performer fully-automated planners: solved problems fullyautomated planners, showing excellent performance time tracks. also awarded
prize mips solved second problems widest coverage
fully-automated planners. clear ff produced exceptional performance
numeric level problems could well judged worthy prize that. chose
acknowledge great difficulty newcomers competition building system
sufficiently robust compete, especially team programmers
researchers support effort. reason awarded prize vhpop best
newcomer, creditable performance strips simpletime problems.
Turning hand-coded planners, awarded prize best performance tlplan,
tackled almost problems available, solved attempted
produced plans high quality dramatic speed. also rewarded shop2
fact attempted every problem produced plans planner.
quality plans consistently good performance highly competitive.
talplanner also performed outstandingly, often producing highest quality plans
tremendously efficiently, coverage restricted strips time
tracks. selecting prize winners chose emphasise breadth coverage, particularly
new challenges handling numeric temporal planning problems. Competitions
demand degree spectacle selection winners, measured evaluation
planners takes time. paper present various analyses data collected
competition leave community judge final rankings planners.
3.3 Additional Challenges
hardnumeric complex problems used competition easily fit
analysis conducted across results. problems raise interesting special
challenges planners. discuss challenges, presenting data below.
challenges explored one two problem sets, generalisations
performance planners based data collected inappropriate.
not, therefore, perform statistical analysis data, but, instead, present relevant
data simple graphical form.
3.3.1 hardnumeric Satellite Problems
hardnumeric Satellite problem instances contained logical goals almost
trivial. example, cases problems involved simply ensuring
satellites target specific observation site end plan. However, plan metric
used evaluate plans far informative: plans evaluated according
data collected satellites execution. Simply satisfying explicit
9

fiLong & Fox

Satellite-HardNumeric
6000
TLPlan (20 solved)
SHOP2 (20 solved)
MIPS (20 solved)
FF (Speed) (20 solved)

5000

Quality

4000

3000

2000

1000

0
0

2

4

6

8
10
12
Problem number

14

16

18

20

Figure 2: Plan quality Satellite hardnumeric problems. High values better
quality plans: quality amount data collected.

goals would generate correct plan, worthless one terms plan metric.
fully-automated planners, mips ff tackled problems. tlplan shop2
hand-coded planners attempted problems. instructive compare
qualities plans produced four planners problem set. Figure 2
shows quality plans produced hand-coded planners significantly
higher quality plans generated fully-automated planners. Indeed, ff
generates plans satisfy logical goals minimise plan size required
achieve that, lead data collection. careful adjustments, mips
able generate plans collect data, clearly rather limited
result. closeness results generated tlplan shop2 suggest
solving data collection problem level close optimal, applying similar
heuristic approaches problem generating similar locally optimal solutions.
domain clearly highlights advantage hand-coded planners exploitation
knowledge human domain-engineer bring bear.
3.3.2 Complex Satellite Domain
addition hardnumeric Satellite domain, complex Satellite domain also
considered. complexity domain arises fact combines temporal
actions, durations dependent parameters action, management
numerically measured resources (in case, data store available acquired data).
problem quality similar knapsack problem, data
packed limited stores appropriate satellites. combined temporal
optimisation problem, involves ensuring satellites efficiently deployed,
10

fiThe 3rd International Planning Competition

Satellite-Complex
2000
MIPS (8 solved)
TLPlan (20 solved)
SHOP2 (20 solved)
Sapa (16 solved)
LPG (Quality) (20 solved)

1800
1600
1400
Quality

1200
1000
800
600
400
200
0
0

2

4

6

8
10
12
Problem number

14

16

18

20

Figure 3: Plan quality Satellite complex problems. Low values represent better
plans, since quality measures makespan, minimised.

moving targets capturing data according capabilities, current
aspects available store. seen Figure 3, planners fullyautomated hand-coded produced plans quite widely varying quality (lower values
better, here, since quality measured makespan). general, tlplan produced
best quality plans, although lpg also produced high quality plans smaller
problems. seen problems 13, 16, 19 20, particularly, fully-automated
planners occasionally produced plans quality diverging significantly optimal
(we actually know optimal values problems,
obviously consider best value produced upper bound optimal value).
3.3.3 Settlers Domain
Settlers domain based resource-management computer games, resources
must accumulated used construct new resource centres, new specialised
production capabilities. interesting problem domain highlights
pddl2.1 family languages offer convenient way name objects
created execution plan. version used competition, overcame
problem selection names available outset initially
committed role. object constructed, unallocated name used
name it, assigning name properties new object marking name
used. important problem approach creates current planners
initial grounding actions involves creating possible ways names
could assigned objects used various roles within plan. leads
significant explosion size domain encoding. interesting observe
11

fiLong & Fox

6 20 problems solved (fully-automated) planner, ff
solved one problem. clear domain remains challenge planning
technology, also future development pddl2.1 necessary
review way object construction modelled.

4. Analysis Competition Performance
One important roles competition identify state art field,
terms variety measures, attempt answer broad questions
landscape research area. course, competition cannot last word
state art. might state art planning systems prevented,
whatever reason, taking part competition. However, competition
provide useful insights capabilities modern planning systems.
Planning performance measured terms speed solution problems
number quality solutions found. metrics might also identified.
different planning architectures heuristic evaluation functions well
different kinds domains problems. state art represented specific
exemplars architectures heuristic functions interesting explore
suitability different architectures use different domains, scaling behaviour
particular approaches, comparative performance different planning systems, etc.
address issues following sections.
perform three collections analyses ascertain comparative performance based
consideration raw speed quality data, extent domain influenced planner
behaviour scaling behaviour planners. first collection comparison
planners based raw competition performance. analyse data
point view consumer interested ranking planners according speed
plan quality. experiments aimed answering coarse level questions
form: planner buy? asking questions trying arrive
general basis comparison. course, investigation question constrained
metrics used competition. Furthermore, trade-off one makes time
quality depends context planner might deployed. Therefore,
cannot combine judgements relative speed relative plan quality performance
determine unequivocally planner buy. take basic assumption potential
users domain-independent planning technology interested primarily broad coverage
good behaviour across wide variety domains, rather restricted coverage
spectacular behaviour domains. raw performance analyses
based mainly Wilcoxon rank-sum matched-pairs test (see Appendix C), explained
below. advantage test non-parametric, meaning rely
assumptions shapes properties underlying population distributions.
also robust outliers.
second collection experiments concerned identifying whether
domains significantly easier (or harder). perform experiments
levels problems used competition determine whether agreement
amongst planners difficulty problems. part, assists us going
explore scalability issues also allows us determine whether problem
12

fiThe 3rd International Planning Competition

set presented competition contained interesting challenges. third collection
experiments compares way planners scale problem sets agree
problem difficulty.
4.1 Raw Performance Analysis
perform pairwise comparisons planners ascertain whether consistent
pattern identified relative speed plan quality. focus first comparing
fully-automated planners and, separately, hand-coded planners. perform
additional set analyses try determine raw performance benefit obtained
use hand-coded control knowledge. this, perform Wilcoxon test pairs
crossing boundary fully-automated hand-coded planner groupings.
conclusion improvement obtained significant, say
control rules yield improvement performance. cannot account price,
terms effort encode rules, must paid obtain improvement.
understanding involved writing useful control knowledge still anecdotal
remains important challenge community quantify precisely. One
important consequence use hand-crafted control knowledge speak
planner performance blurs distinction planning system
control rules produced support performance domain.
planner performs well impossible separate contributions planning
system, architecture system (and extent contributes ease
expressing good control rules) sophistication control rules
used. attempt distinguish planner control rules analysis
follows, least one competitor observed results would significantly
worse less time prepare, while, given time, results could
improved concentrating optimisation plan metrics rather simply
makespans. observation helps highlight fact that, planners exploiting handcoded control knowledge, competition format seen highly constrained
basis evaluation performance.
summarise, present hypotheses exploring section:
Null Hypothesis: basis pairwise distinction
performances planners terms either time taken plan quality
(according specified problem metrics) plans produced.
Alternative Hypothesis: planners partially ordered terms
time performances and, separately, quality performances.
4.2 Analytic Framework
perform pairwise comparisons, planners fully-automated hand-coded
groups, problems main four problem levels used competition.
include analyses complex hardnumeric tracks resulted
data points meaningful statistical conclusions drawn. perform
Wilcoxon rank-sum matched-pairs tests identify whether number times one planner
performed better indicates significant difference performance
13

fiLong & Fox

two. performed pairwise comparisons performances tracks
use results construct partial orderings speed quality performances
planners tracks. use 0.001 significance level wish
extrapolate collections pairwise comparisons infer confidence, p = 0.05
level, transitive relationships planners. strips track,
largest, perform 15 pairwise comparisons confidence level 951/15 = 0.003
required transitive picture. use confidence level 0.001, resulting
slightly conservative analysis.
use sufficiently large samples T-distribution, used Wilcoxon test,
approximately normal. therefore quote Z-values indicate significance
differences mean performances paired planners. compare
pairs planners: cases superiority planner another clear
examination raw data statistical testing obviated.
Wilcoxon test tells us one planner performs consistently better another
whether consistency statistically significant. tell us much better
one planner another. could little difference performance
perhaps discrepancy accounted mere implementation differences.
consistency difference occurs determines whether statistically
significant discrepancy performances planners. One planner perform
consistently better another even though wins time. example,
comparison B, planner might win frequently B
faster solving subset problems set even though much slower solving
another subset problems. Provided subset B sufficiently large
greater number wins due emerge significant. example, set 10
problems ranked according differences performance, first 7 problems
ranking last 3 B, obtain score 28 B score 27.
case significant difference emerges regardless magnitude difference
B last three problems (see Appendix C). rank-sum approach
benefit allowing large numbers small wins outweigh small numbers large wins.
desirable large win problems indication overall better
performance. interested trying measure consistency domain-independent
behaviour therefore comparing consistency performance across domains given
planners perform differently within domains.
size win need indicate complexity underlying problem
allow us make judgements scalability. Essentially test reveals
consistent patterns performance across range problems. consider
interest knowing one planner significantly consistently better another
helps us make objective judgement two planners performing better
across varied problem set. variability performances consistent
pattern emerges, hard perhaps impossible make judgement objectively.
cases, comparison using Wilcoxon test lead statistically
significant conclusions, proportion wins one planners higher
consistent null hypothesis equal performance. tested using Z-test
proportion (see Appendix C). test yields significant result report it,
14

fiThe 3rd International Planning Competition

described below. test less informative Wilcoxon test take
account wins distributed problem set.
performing pairwise comparisons must deal cases planner
solve problem. assign infinitely bad speed planner cases, ensuring
maximum possible benefit given planners solving problems, even slowly.
methodology valid Wilcoxon test based rank effect simply
push unsolved cases extreme ranking. case quality perform
initial collection tests using infinitely bad quality unsolved problems.
somewhat difficult decide means compare true quality result
infinitely bad quality assigned planner produced solution. conclusion
comparison may informative enough, addition perform Wilcoxon
test cases planners produced plan. refer cases
double hits.
4.3 Results Analysis
results performing Wilcoxon tests, order compare speed performance fully-automated planners, shown Figure 4. results similar tests
compare plan quality presented Figures 5 6. double hits data presented
Figure 6. corresponding tests hand-coded planners shown Figures 7
8.
tables rows corresponding four problem levels competition
gathered sufficient data analysis. are: strips, numeric, simpletime time.
many results fully-automated planners strips domains
split two rows, creating five rows tables. comparisons plan quality
report strips results using sequential plan length concurrent plan length separately.
data rows interpreted following way. cell, representing pair
planners compared, presents Z-value corresponding p-value identified
Wilcoxon statistical table. order planners names title cell
significant: first planner named one favoured comparison. Underneath
cell entry indicating size sample used. sample consists
problems least one planners compared produced solution:
results different sample sizes different comparisons. p-value
greater 0.001 difference mean performances obtained competing
planners statistically significant concluded planner column
significantly out-performing competitor. p-value greater 0.001 difference
significant, terms transitive view interested, null
hypothesis planners performing roughly equally cannot rejected. indicate
absence significance p < 0.001 level use bold font.
Wilcoxon test tells us significant difference mean behaviour
identify planner producing greater proportion wins cases
mean behaviour insignificantly different. Therefore, Wilcoxon tests reports
significant difference pair planners also report Z-value
proportion (see Appendix C), significant, provide missing information.
15

fiLong & Fox

Strips

FF-LPG
6.2
?
120

LPG-MIPS
5.3
?
118

LPG-Sim
1.9
0.06
118

Sim-MIPS
1.9 (3.1)
0.06 (?)
114

MIPS-VHPOP
3.4
?
98

VHPOP-Stella
0.11
0.92
59

Strips

Sim-Stella
7.2
?
83

LPG-VHPOP
7
?
117

FF-MIPS
8.9
?
117

FF-Sim
7.8
?
117

MIPS-Stella
4.7
?
80

Sim-VHPOP
4.3
?
108

FF-LPG
3.5
?
93

LPG-MIPS
3.8
?
86

Simple
Time

LPG-MIPS
5
?
100

MIPS-VHPOP
2
0.04
68

VHPOP-TP4
5.9
?
54

LPG-TP4
8.4
?
100

MIPS-TPSYS
5.9
?
47

TP4-TPSYS
2.6
< 0.01
14

Time

LPG-Sapa
3.3
?
95

MIPS-Sapa
0.72
0.67
72

LPG-MIPS
3.4
?
96

MIPS-TP4
5.1
?
36

Sapa-TP4
5.2
?
38

Numeric

FF-MIPS
8
?
85

Figure 4: Table showing results statistical tests comparison speeds planners.
Bolded results significant p = 0.001 level. cell
represents pair planners compared. presents Z-value corresponding p-value identified Wilcoxon statistical table. order
planners names title cell significant: first planner named
one favoured comparison. Underneath cell entry indicating
size sample used. ? indicates result less 0.001.

16

fiThe 3rd International Planning Competition

Strips
(Seq)

LPG-FF
0.21
0.84
120

LPG-MIPS
6.9
?
118

LPG-Sim
7.6
?
118

MIPS-Sim
0.38
0.7
114

Strips
(Seq)

Sim-Stella
5.6
?
83

LPG-VHPOP
7.7
?
117

FF-MIPS
7.2
?
117

FF-Sim
8.5
?
117

LPG-FF

MIPS-VHPOP
1.3
0.21
98

VHPOP-Stella
2.1 (3.3)
0.04 (?)
59

MIPS-Stella
5
?
80

Sim-VHPOP
0.45
0.65
108

Strips
(Conc)

6
?
120

LPG-MIPS
5.3
?
118

LPG-Sim
8.6
?
118

MIPS-Sim
2.4 (4.1)
0.01 (?)
114

MIPS-VHPOP
0.69
0.49
98

VHPOP-Stella
0.93
0.35
59

Strips
(Conc)

Sim-Stella
2.1
0.03
83

LPG-VHPOP
5.2
?
117

FF-MIPS
1.4
0.16
117

FF-Sim
8.5
?
117

MIPS-Stella
3.7
?
80

VHPOP-Sim
0.13
0.90
108

Numeric

LPG-FF
3 (4.5)
< 0.01 (?)
93

LPG-MIPS
6.1
?
86

FF-MIPS
3.5
?
85

Simple
Time

LPG-MIPS
8.7
?
100

MIPS-VHPOP
2.4 (3.5)
0.01 (?)
68

VHPOP-TP4
5.4
?
54

LPG-TP4
8.6
?
100

MIPS-TPSYS
5.6
?
47

TP4-TPSYS
2.7
< 0.01
14

LPG-Sapa
6.7
?
95

Sapa-MIPS
0.029
0.99
72

LPG-MIPS
6.6
?
96

LPG-TP4
6.6
?
57

MIPS-TP4

Time

5
?
36

Sapa-TP4
5.2
?
38

Figure 5: Table results statistical tests comparisons plan quality across problems
solved least one planner pair. Bolded results
significant p = 0.001 level. ? indicates result less 0.001.

17

fiLong & Fox

Strips
(Seq)

LPG-FF
0.24
0.83
114

LPG-MIPS
4.3
?
85

LPG-Sim
5.9
?
90

MIPS-Sim
1.4
0.16
63

VHPOP-MIPS
2.9
< 0.01
56

VHPOP-Stella
4.7
?
39

Strips
(Seq)

Sim-Stella
1.8
0.08
49

LPG-VHPOP
3.6
?
68

FF-MIPS
4.6
?
86

FF-Sim
7.1
?
91

MIPS-Stella
3.1
< 0.01
44

VHPOP-Sim
5.2
?
51

Strips
(Conc)

LPG-FF
6.5
?
114

LPG-MIPS
1.5
0.14
85

LPG-Sim
7.5
?
90

MIPS-Sim
6.3
?
63

VHPOP-MIPS
3.9
?
56

VHPOP-Stella
2.7
< 0.01
39

Strips
(Conc)

Stella-Sim
6
?
49

VHPOP-LPG
3
< 0.01
68

MIPS-FF
4.8
?
86

FF-Sim
7.1
?
91

MIPS-Stella
0.24
0.83
44

VHPOP-Sim
6.1
?
51

LPG-FF
3.8
?
69

LPG-MIPS
3.2
?
46

MIPS-FF
4.2
?
50

Simple
Time

LPG-MIPS
6.6
?
58

MIPS-VHPOP
2.9 (3.8)
< 0.01 (?)
44

TP4-VHPOP
3.4
?
15

LPG-TP4
1.3
0.19
15

TPSYS-MIPS
0.61
0.54
10

TP4-TPSYS
1.8
0.07
10

Time

LPG-Sapa
4.7
?
62

MIPS-Sapa
1.6
0.09
50

LPG-MIPS
4.2
?
55

LPG-TP4
1.9
0.06
5

TP4-MIPS
1.1
0.27
5

TP4-Sapa
1.3
0.19
5

Numeric

Figure 6: Table showing results statistical tests comparisons quality plans
pairs planners considering problems solved planners.
cell represents pair planners compared. presents Z-value
corresponding p-value identified Wilcoxon statistical table. order
planners names title cell significant: first planner named
one favoured comparison. Underneath cell entry indicating
size sample used. ? indicates result less 0.001.

18

fiThe 3rd International Planning Competition

Small Problems
Strips

Numeric

TL-TAL
6.8
?
102

TAL-SHOP2
0.028
0.99
102

Large Problems
TL-SHOP2
7.2
?
102

TL-SHOP2
6.5
?
102

TAL-TL
5.6
?
98

TAL-SHOP2
8.5
?
98

TL-SHOP2
8.2
?
98

TL-SHOP2
7.9
?
98

Simple
Time

TL-TAL
8.7
?
102

SHOP2-TAL
0.61
0.34
102

TL-SHOP2
7
?
102

TL-TAL
0.77
0.44
98

TAL-SHOP2
6.4
?
98

TL-SHOP2
8.4
?
98

Time

TL-TAL
8.8
?
102

TAL-SHOP2
0.2
0.84
102

TL-SHOP2
7.8
?
102

TL-TAL
3.1
?
98

TAL-SHOP2
7.3
?
98

TL-SHOP2
8
?
98

Figure 7: Table showing results statistical tests comparison speeds handcoded planners. ? indicates result less 0.001.

Small Problems

Large Problems

Strips
(Seq)

TL-TAL
2.3
0.01
102

TAL-SHOP2
2
0.04
102

TL-SHOP2
5.3
?
102

TAL-TL
0.89
0.38
98

TAL-SHOP2
4.4
?
98

TL-SHOP2
3.6
?
98

Strips
(Conc)

TAL-TL
8.6
?
102

TAL-SHOP2
4.3
?
102

SHOP2-TL
7
?
102

TAL-TL
8.6
?
98

TAL-SHOP2
7
?
98

SHOP2-TL
7.7
?
98

Numeric

TL-SHOP2
0.18
0.86
102
TL-TAL

Simple
Time

1
0.32
102
TL-TAL
4
?

Time
102

TL-SHOP2
0.15
0.88
98
TAL-SHOP2
4.5
?
102

TL-SHOP2
5.3
?
102

TAL-TL
0.76
0.44
98

TAL-SHOP2
5.5
?
98

TL-SHOP2
5.4
?

SHOP2-TAL
0.26
0.80
102

TL-SHOP2
3.9
?
102

TL-TAL
2.3
0.01
98

TAL-SHOP2
0.54
0.58
98

TL-SHOP2
5.7
?
98

Figure 8: Table showing results statistical tests comparative quality plans produced
hand-coded planners. table shows results problems solved least
one planners results restricted problems solved insignificantly different, since hand-coded planners solved almost problems
attempted. ? indicates result less 0.001.

19

fiLong & Fox

Z-value proportion, p-value, appear brackets following
Wilcoxon result.
4.4 Interpretation
results show null hypothesis rejected. Therefore, adopt alternative hypothesis discuss resulting partial orders inferred data.
data presented Figures 4 8 interpreted terms partial orderings
speed quality performances fully-automated hand-coded planners
four problem levels. done, level, simply putting ordering
pairs planners B Wilcoxon value pair reported
sub-column associated significant 0.001 level. results
shown Figures 9 12. figures sub-graphs associated
four problem levels identified. presence arrow graph indicates
statistically significant ordering exists. absence arrow B indicates
statistically significant relationship B found corresponding
problem level therefore transitive ordering depend relationship.
4.4.1 Partial orderings based speed
Figure 9 describes speed comparisons made fully-automated
planners according Wilcoxon test. observed ff significantly consistently faster fully-automated planners strips numeric levels (the
significance arrows figure sufficient support transitive reasoning).
Indeed, strips numeric levels interesting linear ordering ff,
lpg, mips vhpop (three prize-winners amongst fully-automated
planners) maintained lpg, mips vhpop simpletime level. Despite observation simplanner faster, significant proportion strips
problems mips, significant Wilcoxon relationship
four prize-winners comprise spine performance around planners
competing levels clustered. relationship breaks time level lpg, mips, sapa tp4 participated. data set seen mips
sapa indistinguishable, respect Wilcoxon test, lpg significantly
consistently faster both.
comparing hand-coded planners competition used collection small problems collection large problems problem level. large problems
beyond capabilities fully-automated planners. Interestingly, handcoded planners behaved differently small large problem collections.
marked Figure 10, strips level, performances tlplan
talplanner inverted small large problem sets. small simpletime
time problems tlplan consistently faster either talplanner shop2,
talplanner shop2 statistically indistinguishable data sets. tlplan
also consistently faster talplanner, turn consistently faster shop2,
large time problems.
20

fiThe 3rd International Planning Competition

numeric
LPG

FF

VHPOP

MIPS

SIMPLANNER

TP4

simple time
TPSYS

STELLA

strips

key:



B

consistently faster B.



B

faster B significant number
times.

SAPA
LPG

TP4
MIPS

time

Figure 9: partial order fully-automated planners terms relative speed
performances.

TAL
TL
SHOP2
strips (small)

TL
SHOP2

TAL

TL

SHOP 2
TAL

strips (large)

simple time (large)
TAL
TL
TL
numeric(small,large)

TAL

SHOP2

SHOP2
time (large)

simple time, time (small)

Figure 10: partial order hand-coded planners terms relative speed
performances.

21

fiLong & Fox

4.4.2 Partial orderings based quality
construction partial order quality performance strips level
fully-automated planners shown Figure 11. interpret figures depicting quality
performance noted that, problem levels except strips, specific quality
metrics provided plan quality must measured terms metrics.
strips level metrics provided quality measure plan length either
sequential concurrent. figures labelled arrows strips graphs
denote whether relationship exists terms sequential concurrent ordering,
both. ordering sequential concurrent quality arrow left
unlabelled. observed two planners might ordered one direction
sequential length concurrent length.
indicated above, comparison quality performance made difficult one
two planners compared solved many problems (this problem
arises fully-automated planners hand-coded planners failed solve
problems proportion unsolved problems affect tests). Using
infinite quality measure unsolved problems Wilcoxon test concludes planner
solving problems overall better quality words, one interested
overall solution quality one choose planner solves problems even
if, cases, produces worse quality plans competitor. However, also
want understand relationship two planners double hits case.
notice consideration problems sometimes inverts relationship detected
first test. example, Figure 11 observed that, simpletime
level, vhpop consistently produced better quality plans tp4 across whole problem
set but, double hits considered, tp4 produced consistently better plans
vhpop. suggests tp4 solving problems higher quality solutions,
price pays search find solutions high solves much smaller
set problems planners, vhpop. depict results using dotted
arrows graphs. Finally, arise Wilcoxon test detects significant
relationship two planners, difference proportion problems
solved two planners significant. indicate resulting weaker relationship using
dashed arrow.
Figure 11 shows lpg emerges fully-automated planner consistently producing
highest quality plans problem levels. relationship ff mips
complex because, whilst ff produced plans better sequential quality mips,
mips produced better quality concurrent plans ff considering double hits.
reason apparent discrepancy mips post-processes sequential plans
partially ordered plans exploiting available concurrency problem,
ff exploit. However, fails solve larger subset problems ff, giving
ff advantage quality overall.
strips problems simplanner solves problems stella hence
seen performing consistently higher sequential-plan quality level. double
hits considered stella outperforms simplanner concurrent-plan quality. Also,
double hits considered, seen vhpop consistently outperforms stella
22

fiThe 3rd International Planning Competition

LPG

FF

MIPS

FF
numeric
conc

LPG

MIPS

TPSYS

seq

LPG
conc

VHPOP

SIMPLANNER

TP4

simple time
MIPS

conc

SAPA

seq
conc

VHPOP

seq

TP4

LPG
MIPS

time

STELLA

key:

B consistently better
B.with confidence
least 99.9%.



seq

strips



B produces better plans
significantly often
B.



B

consistently better
B double.
hits considered.

Figure 11: fully-automated planners depicted terms relative quality performances.

strips (small)

seq
TL

TAL

conc

SHOP2

conc

TL

conc
seq

conc
TAL

SHOP2

seq

strips (large)
TL

SHOP2

TL

TAL

TAL
SHOP2
simple time (small, large)

time (small)

Figure 12: hand-coded planners depicted terms relative quality performances.

23

fiLong & Fox

sequential-plan quality simplanner cases. Interestingly, vhpop stella
Wilcoxon proportion test relationship problems considered.
mips outperforms vhpop tpsys simpletime problems, vhpop consistently better tp4. double hits considered tp4 outperforms vhpop
demonstrating tp4 produces better quality solutions problems solves.
Given available data seems tp4 tpsys performing significantly differently, may data set small draw conclusion confidence.
time data set significant consistent pattern relative performances
sapa mips. lpg consistently produces better quality plans.
fully-automated planners find speed comparisons
observed hold planners compared terms quality. Figure 12 shows
quality comparisons performed three competing hand-coded planners.
shows that, small strips problems tlplan consistently outperformed shop2 terms
sequential plan quality. small problems talplanner produces shorter makespan
plans tlplan shop2 shop2 produces shorter makespan plans
tlplan. tlplan produces sequential strips plans use post-processing
step introduce parallelism. result certain outperformed makespan
comparison planners capable producing parallel plans.
significant relationships emerged numeric problems. talplanner
compete numeric problems. significant Wilcoxon result established.
simpletime problems (both small large) quality performances tlplan
talplanner indistinguishable, consistently better shop2.
time problems tlplan emerges consistently better talplanner shop2.
4.4.3 Cross-boundary partial orderings
performed final collection comparisons try better understand advantages
obtained use hand-coded rather fully-automated planners, terms
speed quality. compare best-performing fully-automated planner
best-performing hand-coded planner categories: ff tlplan speed,
levels, lpg talplanner strips level, shop2 numeric level
tlplan remaining problem levels, quality.
tables Figures 14 15 show results tests. Figure 13 summarises
conclusions. observed tlplan consistently faster ff problem
levels participated, demonstrating control knowledge
exploited tlplan giving real speed advantage. remains seen exactly
case, given several strips domains control knowledge
usually described encoded appears prune additional states
already pruned ff-style heuristic measure used. reason added value
interesting question community consider trying evaluate advantages
disadvantages hand-coded approach.
also observed talplanner produces consistently better concurrent plans
lpg strips level. Again, result needs explained in-depth
analysis control information exploited talplanner. simpletime
level lpg produces plans consistently better quality tlplan.
24

fiThe 3rd International Planning Competition

TL

LPG

FF

levels (speed)

simple time (quality)
Key:

TAL

conc

TL



B

consistently faster/better quality B

Notes:
significant quality difference FF TLplan STRIPS level.
significant difference SHOP2 LPG numeric level.
significant difference TLPlan LPG time level.

LPG

strips (quality)

Figure 13: comparison best fully-automated planners best
hand-coded planners problem level.

Strips

TLPlan-FF
6.7
< 0.001
102

Numeric

SHOP2-LPG
8.2
< 0.001
102

SimpleTime

TLPlan-LPG
8.6
< 0.001
102

Time

TLPlan-LPG
8.7
< 0.001
102

TAL-LPG
7.8
< 0.001
102

TAL-VHPOP
8.5
< 0.001
102

Figure 14: Table results comparisons fully-automated hand-coded planners
terms speed. cell represents pair planners compared.
presents Z-value corresponding p-value identified Wilcoxon
statistical table. order planners names title cell
significant: first planner named one favoured comparison.
Underneath cell entry indicating size sample used.

25

fiLong & Fox

Problems solved least one

Problems solved

Strips
(Seq)

TLPlan-FF
0.57
0.57
102

LPG-TAL
1.8 (3.9)
0.08 (< 0.001)
102

TAL-VHPOP
2.9
< 0.01
102

FF-TLPlan
0.35
0.72
97

LPG-TAL
2.4 (4.2)
0.01 (< 0.001)
99

VHPOP-TAL
4.9
< 0.001
67

Strips
(Conc)

TLPlan-FF
0.57
0.57
102

TAL-LPG
5.9
< 0.001
102

TAL-VHPOP
6.4
< 0.001
102

FF-TLPlan
0.35
0.72
97

TAL-LPG
5.6
< 0.001
99

TAL-VHPOP
2.6
< 0.01
67

Numeric

SHOP2-LPG
1.9
0.06
102

LPG-SHOP2
1.6
0.11
83

Simple
Time

LPG-TLPlan
3.9
< 0.001
102

LPG-TLPlan
4.3
< 0.001
100

Time

TLPlan-LPG
0.093
0.92
102

LPG-TLPlan
1.6
0.11
93

Figure 15: Table results comparisons plan quality fully-automated
hand-coded planners.

interesting observe hand-coding control information appear lead
consistent improvement plan quality across data sets. seem lead
speed advantage must indicate that, general, control rules provide basis
efficient pruning weak general heuristic measures. Wilcoxon test
measure extent speed advantage obtained, measure extent
quality advantage obtained using fully-automated planner preference.
trade-offs need close analysis, interesting see fact
uniform advantage obtained hand-coded planners, least smaller problems
formed common foundation testing. course, development hand-coded
control knowledge prioritise different aspects solutions generated possible
development control rules might support construction heavily
optimised plans.

5. Tests Magnitude
complement Wilcoxon tests perform additional analyses identify whether,
given two planners compared, magnitude difference performance
two planners statistically significant. perform paired t-tests (see Appendix C)
using subset pairs planners. focus attention pairs consistent significant differences identified, consider meaningful
compare magnitude results planners consistent domination exhibited.
also restrict attention planners were, according Wilcoxon tests,
26

fiThe 3rd International Planning Competition

impressive performers competition levels. perform separate tests
speed quality.
investigating magnitude differences performances meaningful
include problems solved one planners compared. Using
infinite time quality measures would result magnitude value would grossly
distort true picture. magnitude tests therefore consider double hits.
price pay give undesirable emphasis smaller easier
problems since ones frequently solved planners.
borne mind interpreting data.
hypotheses considered section are:
Null Hypothesis: consistent magnitude difference performances planners.
Alternative Hypothesis: Planners demonstrate significant differences consistency performance also demonstrate corresponding magnitudes
differences performances.
5.1 Analytic Framework
t-tests performed using normalised performances two planners.
find magnitude difference performances two planners, p1 p2 ,
collection problem instances. example, given collection n problems, find
pairs results p1ri p2ri obtained instances = 1 = n. case normalise
values dividing mean pair. process establishes
range performances 0 2, 1 standing equal performance.
t-test results t-value representing difference mean normalised performances
two planners. perform 2-tailed tests p < 0.05 interested
individual results rather extrapolated partial orderings based magnitude.
want consider magnitude information relevant individual consistency
results.
5.2 Results Analysis
tables Figures 16 20 organised follows. Tables Figures 16, 18 20
contain speed results found fully-automated, hand-coded mixed pairs respectively. Tables Figures 17, 19 20 contain quality results three
groups. table row five competition levels (although empty
rows omitted). columns represent pairs planners compared.
cell five pieces data reported: mean normalised performance
planner; t-value computed degrees freedom used (which derived
number double hits level) resulting p-value. positive t-value means
magnitude difference favour planner identified second cell. negative
t-value favour planner identified first. resulting t-value indicates
difference magnitude significant p=0.05 level use bold font.
speed quality tests, average performance smaller 1 favourable
planner. interpretation value represents average proportion
27

fiLong & Fox

strips

numeric

simpletime

time

FF 0.4
LPG 1.6
-12.26,113
< 0.001
FF 0.23
LPG 1.77
-16.04,68
< 0.001
LPG 1.03
MIPS 0.97
0.35,57
0.73
LPG 1.25
MIPS 0.75
2.64,54
0.008

MIPS 1.21
LPG 0.79
2.69,84
0.007
MIPS 0.8
LPG 1.2
-1.84,45
0.06
MIPS 0.85
VHPOP 1.15
-1.43,43
0.15
LPG 1.16
Sapa 0.84
1.81,61
0.07

FF 0.22
MIPS 1.78
-21.30,85
< 0.001

LPG 0.76
VHPOP 1.24
-2.82,67
0.005

LPG 1.28
Sim 0.72
3.73,89
< 0.001

Sim 0.26
VHPOP 1.74
-15.19,50
< 0.001

MIPS 0.77
Sapa 1.23
-3.41,49
< 0.001

Figure 16: Magnitude comparisons fully-automated planners terms speed.
strips (seq)

strips (conc)

numeric

simpletime

time

MIPS 1.05
LPG 0.95
5.61,84
< 0.001
FF 1.18
LPG 0.82
9.70,113
< 0.001
FF 1.17
LPG 0.83
6.00,68
< 0.001
LPG 0.86
MIPS 1.14
-7.98,57
< 0.001
LPG 0.9
MIPS 1.1
-3.44,54
< 0.001

FF 0.95
MIPS 1.05
-5.39,85
< 0.001
FF 1.13
MIPS 0.87
6.81,85
< 0.001
FF 1.01
MIPS 0.99
0.14,49
0.89
MIPS 0.93
VHPOP 1.07
-3.97,43
< 0.001
LPG 0.86
Sapa 1.14
-4.99,61
< 0.001

LPG 0.98
VHPOP 1.02
-2.73,67
0.006
LPG 0.7
Sim 1.3
-12.95,89
< 0.001
MIPS 1.2
LPG 0.8
4.25,45
< 0.001

LPG 0.91
Sim 1.09
-7.21,89
< 0.001
Sim 1.33
VHPOP 0.67
14.37,50
< 0.001

Sim 1.08
VHPOP 0.92
6.01,50
< 0.001

Figure 17: Magnitude comparisons fully-automated planners terms quality.

mean performances pair planners test set. Thus, average performance
0.66 planner (which compare average performance 1.34
planner pair considered) means first planner is, average, twice
fast second.
5.3 Interpretation
results demonstrate null hypothesis rejected almost pairwisecomparisons planners Wilcoxon test shows significant consistent performance difference. cases null hypothesis cannot rejected,
implying consistent performance difference pair planners translate
statistical significance mean relative performances.
28

fiThe 3rd International Planning Competition

strips

numeric

simpletime

time

Small Problems
TLPlan 0.52
TLPlan 0.61
TAL 1.48
SHOP2 1.39
-12.98,101
-8.32,101
< 0.001
< 0.001
TLPlan 0.7
SHOP2 1.3
-6.21,101
< 0.001
TLPlan 0.43
TLPlan 0.67
TAL 1.57
SHOP2 1.33
-21.34,101
-7.79,101
< 0.001
< 0.001
TLPlan 0.44
TLPlan 0.59
TAL 1.56
SHOP2 1.41
-25.00,101
-10.14,101
< 0.001
< 0.001

TLPlan 1.32
TAL 0.68
7.74,97
< 0.001
TLPlan 0.31
SHOP2 1.69
-19.22,92
< 0.001
TLPlan 0.32
SHOP2 1.68
-24.27,97
< 0.001
TLPlan 0.82
TAL 1.18
-5.75,97
< 0.001

Large Problems
TLPlan 0.39
TAL 0.24
SHOP2 1.61
SHOP2 1.76
-17.41,97
-26.04,97
< 0.001
< 0.001

TAL 0.48
SHOP2 1.52
-11.28,97
< 0.001
TLPlan 0.31
SHOP2 1.69
-23.75,95
< 0.001

TAL 0.46
SHOP2 1.54
-12.81,95
< 0.001

Figure 18: Magnitude comparisons hand-coded planners terms speed.
Small Problems
strips (seq)

strips (conc)

simpletime

time

TLPlan 0.96
SHOP2 1.04
-5.48,101
< 0.001
TLPlan 1.38
TAL 0.62
21.10,101
< 0.001
TLPlan 0.89
SHOP2 1.11
-7.66,101
< 0.001
TLPlan 0.9
TAL 1.1
-4.39,101
< 0.001

TLPlan 1.27
SHOP2 0.73
11.81,101
< 0.001
TAL 0.93
SHOP2 1.07
-3.82,101
< 0.001
TLPlan 0.94
SHOP2 1.06
-4.08,101
< 0.001

TAL 0.88
SHOP2 1.12
-5.15,101
< 0.001

TLPlan 0.96
SHOP2 1.04
-3.82,97
< 0.001
TLPlan 1.7
TAL 0.3
48.66,97
< 0.001
TLPlan 0.85
SHOP2 1.15
-6.85,97
< 0.001
TLPlan 0.88
SHOP2 1.12
-6.46,95
< 0.001

Large Problems
TAL 0.98
SHOP2 1.02
-2.13,97
0.033
TLPlan 1.5
TAL 0.75
SHOP2 0.5
SHOP2 1.25
16.58,97
-8.94,97
< 0.001
< 0.001
TAL 0.87
SHOP2 1.13
-4.80,97
< 0.001

Figure 19: Magnitude comparisons hand-coded planners terms quality.
Speed
strips

simpletime

time

TLPlan 0.55
FF 1.45
-7.60,96
< 0.001
LPG 1.9
TLPlan 0.1
38.14,99
< 0.001
LPG 1.9
TLPlan 0.1
26.85,92
< 0.001

Quality
Seq
Conc
TLPlan 1
TAL 1.04
TAL 0.84 TLPlan 1.23
FF 1
LPG 0.96
LPG 1.16
LPG 0.77
0.54,96
3.89,98
-7.16,98
12.54,98
0.589
< 0.001
< 0.001
< 0.001
LPG 0.94
TLPlan 1.06
-3.89,99
< 0.001

Figure 20: Comparisons fully-automated hand-coded planners terms
speed quality.

29

fiLong & Fox

shown tables 16 20, reassuring consistency emerged results
Wilcoxon tests. is: significant consistency differences identified two
planners using Wilcoxon test, t-test magnitude generally reveals significant
magnitude difference well.

6. Dependence Performance Domain
consider important quantify difficulty problems used competition
provides basis deeper understanding relative planner performance.
explore investigate whether domains used uniformly
considered easy, hard, amongst fully-automated hand-coded planners. also
investigate whether, might expected case, strips problems generally
considered easier problems numeric temporal levels.
two questions lead two related investigations based bootstrapping techniques.
analyses show different planners experienced different domains levels difficult,
within fully-automated hand-coded categories.
first competition, 1998, reported (Long, 2000) planner solved
problem 25,000 ground actions 10,000 ground actions
marked limit beyond planner performance markedly unreliable. ground
action formed replacing action schema parameters objects correct types
selected problem instance. static preconditions preconditions whose
truth ascertained entirely initial state used filter ground
actions, plausibly applicable counted. Relevant ground
actions found applying reachability analysis initial state regression
analysis goals order identify subset ground actions could actually
play useful role plan. seems plausible number ground actions could
offer guide difficulty problems. fact, brief survey largest problems
third competition, Figure 21, reveals action counts vary widely across
domains. encouraging observe size problems solved
reasonable reliability, least domains, grown significantly, despite fact
still typical planners ground action set prior planning. also interest
observe size problems measured action counts strong indication
difficulty problems Rovers Satellite domains amongst found
harder many planners, despite small action counts.
summarise, hypotheses explored section are:
Null Hypothesis: domains used competition equally challenging planners levels.
Alternative Hypothesis: Domain/level combinations distinguished
terms relative difficulty posed different planners.
ease comparison results presented Sections 7 8 observe that,
section, specifically concerned cross-domain analysis whether
planners agreed domain/level combinations hard.
30

fiThe 3rd International Planning Competition

Domain
Depots
DriverLog
ZenoTravel
Rovers
Satellite
FreeCell
Settlers

Largest Ground Action Count
332,064
31,140
32,780
7,364
4,437
112,600
5,884

Largest Relevant Action Count
22,924
15,696
32,780
3,976
4,437
25,418
4,503

Figure 21: Counts ground action instances (generated using FF).

6.1 Analytic Framework
order explore two questions, used planners discover hard domains
levels were. planner, domain problem level plot number problem
instances left solve time milliseconds. results curve, area
taken measure difficulty experienced planner solving
problems given domain given problem level. order keep area
curve finite use cut-off time thirty minutes. extended cut-off time (fifteen
minutes used competition) results higher penalty paid planner
fails solve problems.
experiment used address first question, null hypothesis
planner finds problems specific level equally difficult across domains. test
constructed, using bootstrapping technique, ten thousand samples twenty values
collection timings obtained domains appropriate level. values
selected random performances planners competing domains, one
value collection randomly selected problems. example, problem one
chosen DriverLog, problem two Depots, problem three Rovers, problem
four Depots, etc., value associated problem one would produced
problem planner selected random competed DriverLog.
Similarly, value associated problem two would chosen planner
competed Depots, on. collection 20 values plotted number
problem instances left solve time, above. resulted sampling
distribution level-specific areas. Using bootstrap samples check whether
area calculated particular planner-domain-level combination lies extremes
distribution, not. lies first 2.5% distribution reject null
hypothesis grounds planner found problems level, domain,
significantly easy. lies top 2.5% distribution reject null
hypothesis conclude problems significantly hard planner.
testing relative hardness problem levels within domain (the second question),
perform similar experiments which, planner, bootstrapped samples
obtained sampling timings problem levels within domains. resulted
new sampling distribution level-independent area statistic. null hypothesis,
domain/level combination indicator difficulty, tested seeing whether
31

fiLong & Fox

Depots
DriverLog
ZenoTravel
Rovers
Satellite
FreeCell
Settlers

strips
[6]
1/3
0/1
3/0
2/1
4/0
1/2


Level-dependent
numeric simpletime
[3]
[3]
1/0
0/1
2/0
1/0
2/0
1/0
0/1
0/1
0/2
1/0


0/2


time
[3]
0/1
2/0
1/0
1/1
1/0



strips
[6]
2/2
1/0
4/0
3/1
4/0
2/2


Level independent
numeric simpletime
[3]
[3]
1/1
0/1
0/0
1/0
2/0
0/0
0/2
0/1
0/2
2/0


0/2


time
[3]
0/1
1/0
0/1
0/1
1/0



Figure 22: Comparisons performance domains fully-automated planners.

areas computed planner-domain-level combinations extreme respect
new sampling distribution.
6.2 Results Analysis
Figures 22 25 report results two experiments described above. Figures 22
23 describe level-specific level-independent comparisons made using
fully-automated planners hand-coded planners respectively. table handcoded planners divided two parts: first five rows correspond small
problems, latter five rows large problems. performance hand-coded
planners large problems measured using bootstrapped samples taken
large problem collection.
tables organised follows: rows correspond domains, labelled,
columns levels considered number planners used. number
planners varies columns different planners participated different
domain levels. example, planners participated strips level
others. planners produced little data justify statistical analysis
included tests. Thus, eleven fully-automated planners competition
seven produced enough data analysis experiments.
cells tables contain two integer values separated diagonal. value
left diagonal indicates number planners found problems
corresponding domain level significantly easy. value right indicates
number found problems significantly hard. Thus, seen Figure 22
six fully-automated planners participated strips level Depots
domain, one found problems easy three found hard. two
planners areas calculated using method explained found
sufficiently extreme rejection null hypothesis. Broadly speaking (we discuss
interpretation data detail below) four left-hand columns tell us whether
problems particular domain level easy hard relative problems
level; four right-hand columns tell us whether easy hard relative
problems. addition, rows allow us compare domains relative difficulty:
example, none planners found ZenoTravel hard level relative
problems level, whilst Depots Rovers found hard least one
competitor levels.
32

fiThe 3rd International Planning Competition

Depots
DriverLog
ZenoTravel
Rovers
Satellite
Depots (large)
DriverLog (large)
ZenoTravel (large)
Rovers (large)
Satellite (large)

strips
[3]
2/0
0/0
3/0
0/2
2/1
2/0
0/1
3/0
1/1
1/0

Level-dependent
numeric simpletime
[2]
[3]
2/0
1/0
2/0
0/0
1/0
3/0
0/1
0/3
0/1
2/1
2/0
2/0
1/0
0/1
1/0
3/0
0/0
1/1
0/1
2/0

time
[3]
3/0
3/0
3/0
0/2
0/1
3/0
1/1
3/0
1/0
0/2

strips
[3]
3/0
3/0
3/0
1/0
2/0
2/0
0/0
3/0
2/0
1/0

Level-independent
numeric simpletime
[2]
[3]
2/0
3/0
1/0
2/0
1/0
3/0
0/1
0/1
0/0
2/1
1/0
2/0
0/0
0/1
1/0
3/0
0/0
2/0
0/1
2/0

time
[3]
3/0
0/0
2/0
0/2
0/1
2/0
0/1
3/0
0/0
0/1

Figure 23: Comparisons performance domains using hand-coded planners.
level-independent tests reported exactly way right-hand halves
Figures 22 (for fully-automated comparison) 23 (for hand-coded comparison).
tables tell us whether problems particular domain level easy hard
relative problems domains irrespective level.
data presented Figures 24 25 show planners found domain-level
combinations easy hard discussed reference tables Figures 22 23.
information might contribute understanding planning approaches
likely suited kinds problems, although analysis would needed
pursue question.
tables organised follows. row individual planners,
indicating domain-level combinations found easy hard corresponding planner. Associated categorization combination easy hard
p-value indicating statistical significance finding. presented
findings significant 5% level. two-tailed test (we
priori knowledge help us determine whether problem would easy hard)
critical value easy end 0.025. hard end critical value 0.975. Figure 24
shows findings fully-automated planners. Figure 25 shows information
respect hand-coded planners.
6.3 Interpretation
results allow us reject null hypothesis cases, others.
able determine significant differences relative hardness domains determined
specific planners, also evidence lack consistency judgements
different planners. example, domain/level combinations found
hard certain planners others.
tables Figures 22 23 allow us determine domains presented
interesting challenges planners participating competition. Although
difficult draw firm conclusions data really indicative, interesting
patterns emerge. example, level-specific data Figure 22 shows none
fully-automated planners found ZenoTravel problems, levels, significantly hard
comparison problems drawn domains level. Satellite
33

fiLong & Fox

FF

LPG

MIPS

Sapa
Simplanner
Stella
VHPOP

Easy
Depots Numeric
Depots Strips
FreeCell Strips
Rovers Strips
Satellite HardNumeric
Satellite Strips
ZenoTravel Numeric
ZenoTravel Strips
Rovers Strips
Satellite SimpleTime
Satellite Strips
DriverLog HardNumeric
DriverLog SimpleTime
DriverLog Strips
DriverLog Time
FreeCell Strips
Satellite HardNumeric
ZenoTravel Numeric
ZenoTravel Strips
Satellite Time
Depots Strips
ZenoTravel Strips
Satellite Strips
ZenoTravel Strips
Rovers Strips
Satellite SimpleTime
Satellite Strips

0.015
0.012
0.017
0
0
0.0007
0.0026
0.0015
0.0007
0.019
0.0001
0.0046
0.0094
0.0088
0.0093
0
0
0.01
0.0021
0.0017
0.0003
0.013
0.016
0
0
0.0006
0.0004

Hard
Rovers Numeric
Settlers Numeric

1
1

Satellite Numeric
ZenoTravel Time

1
0.98

Depots Numeric
Rovers Numeric
Rovers Time
Satellite Complex
Satellite Numeric
Settlers Numeric

0.99
0.98
0.98
0.98
1
1

Depots Time
Rovers Strips
Depots Strips
FreeCell Strips
Depots SimpleTime
Depots Strips
FreeCell Strips
Rovers SimpleTime

Figure 24: Easy/hard boundaries fully-automated planners.

34

1
1
1
1
1
1
1
0.98

fiThe 3rd International Planning Competition

SHOP2

TALPlanner

TLPlan

Easy
Depots Numeric
Depots SimpleTime
Depots Strips
Depots Time
Depots HC SimpleTime
Depots HC Strips
Depots HC Time
DriverLog HardNumeric
DriverLog SimpleTime
DriverLog Strips
Satellite SimpleTime
Satellite Strips
Satellite HC SimpleTime
Satellite HC Strips
ZenoTravel Numeric
ZenoTravel SimpleTime
ZenoTravel Strips
ZenoTravel Time
ZenoTravel HC Numeric
ZenoTravel HC SimpleTime
ZenoTravel HC Strips
ZenoTravel HC Time
Depots SimpleTime
Depots Strips
Depots Time
Depots HC SimpleTime
Depots HC Strips
DriverLog Strips
Rovers Strips
Rovers HC SimpleTime
Rovers HC Strips
ZenoTravel SimpleTime
ZenoTravel Strips
ZenoTravel HC SimpleTime
ZenoTravel HC Strips
ZenoTravel HC Time
Depots Numeric
Depots SimpleTime
Depots Strips
Depots Time
Depots HC Numeric
Depots HC Time
DriverLog HardNumeric
DriverLog Numeric
DriverLog SimpleTime
DriverLog Strips
Rovers HC SimpleTime
Rovers HC Strips
Satellite SimpleTime
Satellite Strips
Satellite HC SimpleTime
ZenoTravel SimpleTime
ZenoTravel Strips
ZenoTravel Time
ZenoTravel HC SimpleTime
ZenoTravel HC Strips
ZenoTravel HC Time

0.0031
0.0057
0.0001
0.0088
0.0001
0
0.0006
0.015
0.015
0.019
0
0
0
0
0.0018
0.0003
0.0001
0.0043
0.0001
0
0
0.0001
0
0
0.013
0.0029
0
0
0.0026
0.0009
0
0
0
0
0
0.017
0.0009
0.01
0.0009
0.0003
0
0.0084
0.0051
0.0083
0.02
0.0009
0.0037
0.013
0
0
0.0001
0
0
0.0014
0
0
0

Hard
Rovers Numeric
Rovers Time

DriverLog HC SimpleTime
DriverLog HC Time
Rovers SimpleTime
Rovers Time
Satellite SimpleTime
Satellite Time
Satellite HC Time

Satellite HardNumeric
Satellite HC Complex
Satellite HC Numeric

1
1

1
1
0.99
1
0.98
1
1

1
1
1

Figure 25: Easy/hard boundaries hand-coded planners. Note: HC indicates larger
problems used hand-coded planners.

35

fiLong & Fox

strips problems significantly easy, comparison strips problems,
majority participating planners, hard them. hand
Satellite numeric problems found challenging relative numeric
problems. Figure 23 shows hand-coded planners found ZenoTravel problems easy
levels, comparison problems similar levels, remains true
large problem instances. Depots problems also easy hand-coded planners.
consider level-independent picture right-hand halves Figures 22
23 observe ZenoTravel emerges significantly easy fully-automated
planners, across levels, comparison problems irrespective level.
pattern broken one full-automated planner (lpg) finding problems hard
time problem level. Satellite domain similarly easy fully-automated
planners, levels except numeric. noted number planners finding
strips problems easy level-independent comparisons surprisingly high.
interpretation problems population whole much harder,
performance strips problems pushed extremes performance
problems. hand-coded planners found Depots ZenoTravel problems
uniformly easy levels.
Considering fully-automated hand-coded planners, DriverLog,
Rovers Satellite domains present varied picture, suggesting problems
domains presented greatest challenges overall. hand-coded planners
found simpletime Rovers problems significantly hard relative simpletime
problems, one found problems amongst hardest solve
overall. Interestingly, perceived difficulty small Rovers problems persist
large problems.
interesting comparison made results analysis strips
domains work Hoffmann (2003b) analysing topologies strips adl
versions common planning benchmark domains. Hoffmann examines behaviour
h+ function, measuring relaxed distances states state spaces
problems, order determine whether function offers reliable guide navigate
state space search plans. According Hoffmanns analysis, strips
versions Depots, DriverLog Rovers local minima function
arbitrarily wide plateaus (sequences states equal values h+ ). features
make problem instances domains hard planners relying h+ (or approximations it) guide search. includes fully-automated planners
competition. However, interestingly, several fully-automated planners found
one three domains easy strips level (although cases
found hard). Hoffmann points out, potential hardness domain
mean collections problem instances domain hard.
observations seem suggest competition collections posed instances tended
towards easy end spectrum. unintentional demonstrates
difficult obtain good spread challenges, particularly generating problems automatically. Satellite ZenoTravel domains have, contrast, constant-bounded
plateaus therefore h+ function reliable guide navigating state space
domains. Interestingly, analysis fully-automated planners found
domains either easy neither easy hard strips level.
36

fiThe 3rd International Planning Competition

7. Scaling Issues
Section 6 addressed issue relative difficulty problems without considering question whether planners agree difficulty specific problems. results
section allow us conclude overall consensus
competition domains levels found hard, allow us determine
planners agreed disagreed particular domains levels. order look
relative scaling behaviour planners need identify extent agreement.
examine scaling behaviour necessary scale measures
performance way meaningful planners comparison. analysis
described section therefore seeks establish statistical evidence agreement.
order evaluate scaling behaviour first explore whether competing planners
agree makes problem, within particular domain level, hard. Although
might seem straightforward ensure problem set consists increasingly difficult
problems (for example, generating instances increasing size) fact straightforward achieve this. appears problem size difficulty strongly correlated,
whether size taken measure number objects, number relations even
number characters problem description. Although coarse relationship
observed large instances take time parse ground small instances
sometimes present difficult challenges large instances. indicates
factors size appear important determining whether planners solve
individual instances.
summary, hypotheses explored section are:
Null Hypothesis: planners differ judgements
individual problem instances hard within given domain/level combination.
Alternative Hypothesis: planners demonstrate significant agreement
relative difficulties problem instances within given domain/level combination.
section specifically concerned within-domain/level analysis
whether planners agree relative difficulty problem instances within given
domain/level combination.
7.1 Analytic Framework
discussed Section 6, use planners judges determine
difficult individual problems were. Given competing planners proceeded
first grounding problem instance searching problem space using
variation theme relaxed distance estimate, seems little reason believe
planners would strongly diverge. particular instance, family instances,
proved difficult one planner might expected collection would
challenging competitors. avoid distracted impact hand-coded
control rules separate judgements fully-automated planners
hand-coded planners. domain/level combination hypothesis planners
37

fiLong & Fox

Fully
Automated
Depots
DriverLog
ZenoTravel
Rovers
Satellite
FreeCell
Settlers

Strips

Numeric

F21,110 = 5.3
F19,100 = 17.1
F19,100 = 21.7
F19,80 = 4.54
F19,100 = 7.36
F19,100 = 6.21

F21,44 = 5.48
F19,40 = 17.4
F19,40 = 14
F18,38 = 9.47
F15,48 = 1.74

HardNumeric

SimpleTime

Time

F19,20 = 11.8

F21,66 = 1.77
F19,60 = 4.44
F19,60 = 9.4
F19,60 = 4.25
F19,60 = 3.6

HardNumeric

SimpleTime

Time

Complex

F21,44 = 4.54
F19,40 = 5.34
F19,40 = 5.54
F19,40 = 28.3
F19,40 = 5

F21,44 = 6.21
F19,40 = 6.52
F19,40 = 4.22
F19,40 = 18
F19,40 = 20.6

F19,20 = 51.3

F19,40 = 4.05

F20,63
F19,60
F17,36
F19,40
F19,60

= 2.14
= 4.63
= 12.1
= 6.92
= 4.19

Complex

F19,60 = 3.78

F5,6 = 1.6

Hand-Coded
(Small)
Depots
DriverLog
ZenoTravel
Rovers
Satellite
Hand-Coded
(Large)
Depots
DriverLog
ZenoTravel
Rovers
Satellite

Strips

Numeric

F21,44 = 2.49
F19,40 = 2.58
F19,40 = 2.93
F19,40 = 4.5
F19,40 = 7.25

F21,22 = 2.19
F19,20 = 3.73
F19,20 = 8.3
F19,20 = 36.5
F19,20 = 38.7

Strips

Numeric

F21,44
F19,40
F19,40
F19,40
F15,32

= 11.4
= 61.4
= 3.14
= 17.2
= 20.8

F21,22
F19,20
F19,20
F19,20
F15,16

= 3.76
= 57.3
= 1.47
= 29.9
= 33.5

F19,20 = 6.45

F19,20 = 9.4
HardNumeric

F19,20 = 66.4

SimpleTime
F21,44 = 13.8
F19,40 = 91.6
F19,40 = 3.54
F19,40 = 33
F15,32 = 43.7

Time
F21,44
F19,40
F19,40
F19,40
F15,32

= 10.8
= 80.5
= 3.37
= 49.4
= 88.5

Complex

F15,16 = 152

Figure 26: F-values multiple judgments rank correlation tests.

tend agree relative difficulties problems presented within domain
level.
explore extent agreement exists perform rank correlation tests
agreement multiple judgements (Kanji, 1999) (we refer test MRC).
experiment judges planners subjects problem instances.
perform distinct MRC domain/level combination, showing case
planners ranked instances domain level. therefore perform 25 MRCs
fully-automated planners (there 25 distinct domain/level pairs fullyautomated planners competed), 23 hand-coded planners small problems (the
hand-coded planners compete Freecell strips Settlers numeric domains)
22 hand-coded planners large problems (amongst
Satellite hardnumeric instances). results tests shown Figure 26.
test n planners rank k problem instances order time taken solve.
Unsolved problems create difficulties pushed top end ranking.
MRC determines whether independent rankings made n planners agree.
test statistic follows F-distribution (k 1, k(n 1)) degrees freedom determining
whether critical value exceeded.
7.2 Results Analysis
cells Figure 26 report F values obtained (and degrees freedom used).
almost cases critical value exceeded null hypothesis non-agreement
could rejected least 0.05 level. cases (those reported bold
38

fiThe 3rd International Planning Competition

font) critical value exceeded statistical evidence therefore found
agreement planners difficulty instances corresponding
domain level. interesting note problematic cases within
numeric level, fully-automated hand-coded planners. Furthermore, case
comes closest critical boundary (the small Depots numeric problems,
hand coded table, F-value 2.19) also within numeric level.
7.3 Interpretation
results support rejection null hypothesis almost cases. therefore
adopt alternative hypothesis, observing many cases planners
agree relative difficulties problem instances within given domain/level combination.
competition observed talplanner disadvantage respect
hand-coded planners, terms comparative speed, running small
problems. probably java virtual machine start-up time becomes
significant relative actual solution time small instances. see effects startup time tables. Note that, domain/level combinations talplanner
competed (strips, simpletime time) see low level agreement amongst
hand-coded planners small problems (except case Rover domain).
talplanner disagrees planners ranking
actual problems, problems small enough variability
setup time throws noise ranking obscures true picture relative problem
difficulty. set large problems see anomaly removed
problems sufficiently challenging java startup time becomes insignificant
high level agreement ranking obtained. Interestingly, hand-coded planners
show consistently high level agreement ranking Rovers problems. fact
emerge fully-automated set may due larger number
judges fully-automated category.

8. Relative Scaling Behaviours
MRCs described Section 7 demonstrate planners agree, expected,
relative difficulty problem instances within domain/level combinations.
cases possible go explore domain level specific scaling behaviour
planners, go investigate section. cannot explore
scaling behaviour planners across domains because, discussed Section 6,
seem much across-the-board agreement concerning relative hardness
domains would unlikely see agreement multiple judgments across
domain boundaries.
ideal basis explore scaling behaviour would collection
problems canonical scaling difficulty compare performance
planners scaled progressively harder problems within collection. Unfortunately, many factors contribute making problems hard affect planners
uniformly. result, canonical measurement problem difficulty many domains. Instead, must determine relative difficulty problems using planners
39

fiLong & Fox

judges. means consider relative scaling behaviours
planners planners agree underlying ordering difficulty problems.
Thus, begin identifying appropriate sets problems given pair
planners agree relative hardness problems according analysis Section 7 proceed compare way planners pair scales
problems increase difficulty. first stage analysis considers order
two planners place problems within set, second stage examines
performance varies two planners progress problem
problem.
hypotheses explored section are:
Null Hypothesis: planners agree difficulty problems
given domain/level combination, exhibit scaling behaviour.
Alternative Hypothesis: planners agree difficulty
problems given domain/level combination, demonstrate different scaling behaviours, better scaling performance identified
data set.
section concerned question scaling behaviour within problem sets
specific domain/level combinations already determined agreement,
identified Section 7.
8.1 Analytic Framework
order test different scaling properties planners make pairwise comparisons
performance using domains planners agreed difficulty
problems. is, use domain comparison planners found hard,
found easy neither found hard easy.
rank problems order difficulty use results obtained bootstrapping experiment described Section 6. rankings level dependent, looked
scaling within four problem levels recorded results separately.
attempt combine results single overall conclusion scaling recognize different planners scale better problem levels others,
single planner therefore emerge scaling best overall.
compare two planners agreed difficulty least two domains.
gives us, case comparison made, data set 30 points.
planners agree least two domains conclude insufficient agreement constitutes problem difficulty
possible measure relative scaling behaviours meaningful way.
perform comparison two planners rank problems data set
order agreed difficulty rank differences performances
planners problems. explore whether ranking differences correlated ranking problems according difficulty. use ranks
cannot make assumptions shapes underlying problem distributions
functions truly describe performances planners compared,
results robust respect factors.
40

fiThe 3rd International Planning Competition

FF
strips
FF
LPG
MIPS
Sapa
VHPOP

LPG
numeric

0.36

N

J

strips
0.87
J

N
J

MIPS
numeric simple time
timeN
0.93
0.52
0.51
0.61

N

J
J

Sapa
time

N
0.58
J

VHPOP
strips simple
time
N
0.93
0.44 J 0.48

J
N

N

Figure 27: Table showing correlation values, fully-automated planners, problem
N
difficulty difference time performance, indicating scaling behaviour.
means one pairs planners produce data comparison
J
may drawn.
means insufficient agreement
planners difficulty domains ranking problems order
carry comparison.

Given two planners, p1 p2 , positive correlation rankings differences values p1 p2 problem difficulty ranking means
difference performance p1 p2 (that is, performance p1 minus performance
p2 ) increasing problems become difficult. curve p1 increasing
faster p2 scales better p1 . negative correlation means p1 scales better
p2 . zero (or near-zero) correlation means scaling behaviour two planners
insignificantly different. use Spearmans rank correlation test (see Appendix C)
identify critical value required confidence 0.05 level.
restrict attention planners solved problems overall two
categories. Thus, fully-automated planners compared ff, lpg, mips, vhpop
sapa. consider pairs hand coded planners. perform
cross-category tests evident raw data hand coded planners exhibit
better scaling behaviour fully-automated planners.
8.2 Results Analysis
table Figure 27 shows significant scaling differences found pairs
fully-automated planners levels. Figure 28 shows relative scaling
hand coded planners. sets tests, two planners could compared
levels competed, domains agreed either easy,
hard, neither easy hard. report results planner indexed row
one showing superior scaling behaviour. planners compete
N
tracks indicate symbol denoting incomparable. significant
difference scaling found indicate zero correlation. agreement
J
found support comparison use symbol
denoting disagreement. avoid
duplication data, place entries positive correlations cell corresponding
row planner favoured comparison omit corresponding negative
correlation cell row column planners reversed.
41

fiLong & Fox

TLPlan
strips time
TLPlan
SHOP2
TALPlanner

strips
0.77

0

0

0.86

SHOP2
numeric simple
time
0.93
0.85

N

0.46

time
0.83

TALPlanner
strips simple time
time
0
0.25
0

0.76

Figure 28: Table showing correlation values, hand-coded planners, problem
N
difficulty difference time performance, indicating scaling behaviour.
means one pairs planners produce data comparison
may drawn.

8.3 Interpretation
almost cases comparison could performed, significant difference
scaling behaviour found, supporting rejection null hypothesis.
used domains agreement relative
difficulty problems necessary restrict conclusions domaindependent. However, restricted collection data points disposal
must careful generalise picture. basis analyses
believe make tentative judgements planners scaling pairwise
comparisons within four competition levels.
fully-automated planners observed informally high degree consistency scaling behaviours particular planners across problem
levels competed. Although cannot draw overall conclusions data
set high level confidence observe ff exhibits best scaling behaviour
levels competed lpg exhibits best scaling behaviour temporal levels. remembered perform single-domain comparisons,
although might interesting point view exploring domain-specific scaling behaviour might produce interesting results. felt results would
interesting curiosities rather anything could support general conclusions.
hand coded planners also show high degree cross-level consistency.
observed informally tlplan scales much better shop2 across levels, whereas
scales marginally better talplanner strips domains significantly
level. talplanner scales better shop2 levels
competed. seen shop2 scaling well relative competitors, although
remembered quality plans produced shop2 superior
domains.
Formally tables allow us draw specific conclusions relative scaling
behaviours specific pairs planners, within specific problem levels, 0.05 level.

9. Conclusions
3rd International Planning Competition focussed issue temporal planning
numeric resource handling. competition structured around two categories:
42

fiThe 3rd International Planning Competition

fully-automated hand-coded planning systems, four main problem levels: strips,
numeric, simpletime time. eight domains, one intended
hand coded planners (the um-translog domain), two solely
fully-automated planners (the FreeCell Settlers domains). Fourteen competitors took
part, eleven fully-automated track three hand coded track. domain
description language used pddl2.1, extension pddl standard designed
modelling temporal resource-intensive domains. pddl2.1 described another paper
issue (Fox & Long, 2003).
collected data set five half thousand data points distributed
domains levels. initial plotting points, terms relative time
quality performances planners different domains, revealed number
interesting patterns. suggest characteristics relative performances
competitors within competition domains. patterns presented discussed
AIPS conference final competition events co-located. However,
patterns, indicating relative performances across domains
showing perceived difficulty competition domain/level combinations, invisible data presented way. paper presents results detailed
statistical analyses competition data, aimed identifying deeper patterns.
paper explores three experimental themes. first theme aimed answering
question: planner buy? question concerned planner
emerges strongest overall performer, rather produced best results
particular domain/level combination, asked point view
speed quality criteria. answer performed comparisons, based
Wilcoxon rank-sum matched-pairs test, enabling construction partial orders
competing planners terms time quality performances four levels
competition. partial orders concluded that, potential user
interested good behaviour across broad range temporal numeric problems
lpg, amongst fully-automated planners, tlplan, amongst hand-coded
planners, best choices. course, specialised coverage required speed
solution paramount choices might made.
second theme considers dependence planner performance domain structure. interested exploring extent competing planners agree
domain/level combinations hard easy. analysis
performed addressing first issues statistical complement theoretical
analysis domain topologies carried Hoffmann (2003b). considered
competition domains four levels used competition, whilst Hoffmann considers
strips subset competition domains (he also considers adl domains,
use competition). interesting note findings
broadly consistent conclusions.
third theme considered scaling behaviour competing planners. considered two related issues: extent competing planners agreed relative
difficulty problem instances within domain/level combinations extent
planners scaled similarly domain/level combinations agreement. intentions pursuing first issue provide objective scale
43

fiLong & Fox

would support efforts investigate relative scaling behaviours planners. found relatively little agreement perceived difficulty problems within
domain/level combinations able perform restricted comparison relative
scaling behaviour. However, consider results obtained make interesting
contribution deeper comparison planner performances available raw
domain-specific data.
many questions would interesting able answer.
Amongst questions extent hand-coding domain knowledge
really benefits planner amount (and value) effort involved encoding
knowledge. pressing question community one competition
series might well-suited try answer. However, order pursue future
competitions necessary carefully design controlled experiments aimed exploring precise hypotheses. restricted paper post hoc analysis
competition data, clearly restricted kinds questions
able ask answer. However, hope results methodologies
presented interest planning community help
encourage scientific evaluation performance field.

Acknowledgements
would like thank competitors 3rd International Planning Competition
contributing time enthusiasm event report providing
data made paper possible. would also like thank Adele Howe
contributed invaluable advice, comments huge support made possible
paper go far could hoped. would like thank David
Smith undertaking unenviable task coordinating editing special issue
Journal Artificial Intelligence Research immense patience, good
humour generous support. Finally, would like thank Martha Pollack first
proposed idea publishing assembled work special issue Journal
Artifical Intelligence Research. whole-hearted commitment project
vital successful conclusion.

44

fiThe 3rd International Planning Competition

Appendix A. Problem Domains
A.1 First International Planning Competition
first competition used following domains:
Logistics transportation problem involving aircraft trucks, trucks constrained movement within cities aircraft constrained movement
(inter-city) airports. domain allows considerable parallelism.
Mystery transportation domain vehicles limited capacity consuming limited stocks fuel.
MPrime variant Mystery domain also possible pipe fuel
locations order allow vehicles different movement options.
Grid problem single robot moves locations grid shaped
map. Locations may locked keys must collected gain access
locations. objectives problem instances involve transporting
keys particular locations.
Gripper simple domain, originally designed demonstrate limitations
Graphplan, collection identical balls must transported robot
two grippers one room adjacent room.
Movie simple domain intended explore use conditional effects. collection
snacks must assembled prior rewinding video watching movie.
Assembly complex adl domain challenging use quantified conditional
effects.
A.2 Second International Planning Competition
second competition introduced several new domains:
Blocks classic blocks-world problem, encoded without explicit reference
gripper. domain significant goal interaction.
Job-Schedule problem involving machining parts. problem exercises
adl features involving conditional quantified effects, although less complex Assembly domain.
Freecell classic solitaire card game widely available computer
game. encoding strips domain represents larger problem
previous benchmarks includes awkward addition encoded set integers.
Miconics Elevator domain inspired problem planning efficient call sequence elevator car travelling floors large building.
several variants, complex including numeric preconditions
well purely logical constraints. adl version offered complex preconditions
involving several different connectives strips version offered relatively simple
transportation problem.
45

fiLong & Fox

addition, Logistics domain reused provide calibration performance
comparison first competition.
A.3 Third International Planning Competition
A.3.1 Depots Domain
domain consists actions load unload trucks, using hoists available
fixed locations. loads crates stacked unstacked onto fixed set
pallets locations. trucks hold crates particular order,
act like table Blocks domain, allowing crates reordered.
domain devised foremost intention testing strips planners.
second competition demonstrated Logistics domain longer serious
challenge, that, planners using hand-coded controls, Blocks domain also
solved. fully-automated planners Blocks domain still represents challenge, although second competition showed planners solve quite large problems
(up twenty blocks) reasonably efficient plans within minutes. However, performance vary widely problems range prove unsolvable
planners. wanted see whether performance achieved
domains could successfully brought together one domain. interested
see fully-automated planners, interaction problems creates
additional family choice points addition appear transportation
block-tower-construction sub-problems. also interested see handcoded planners rules sub-problems obviously well-understood,
obvious whether rules combined single collection without
problems interaction.
metric version domain adds weight attributes crates weight capacities trucks. addition, trucks consume fuel travels plans must
minimise fuel use. Fuel use constant dependent locations. Fuel also consumed lifting crates, tradeoff considered crates must restacked
location. Either truck brought act table complex lifting
stacking performed using locally available pallets transfer space.
temporal versions allow concurrent activities trucks hoists (at
locations). full temporal variant makes time driving dependent truck
distance locations, makes time load unload crate dependent
weight crate power hoist. objective minimise
make-span (the overall duration plan).
A.3.2 DriverLog Domain
domain drivers walk locations trucks drive
locations. Walking requires traversal different paths used driving,
always one intermediate location footpath two road junctions.
trucks loaded unloaded packages (with without driver present)
objective transport packages locations, ending subset
packages, trucks drivers specified destinations.
46

fiThe 3rd International Planning Competition

domain produced explore power strips solutions transportation
problems transportation involves sub-problem acquiring driver. problem
one offers significant opportunity concurrency use drivers vehicles,
also interested see temporal variants handled.
metric variant domain adds costs walking driving problem instances required planner optimise linear combination total walking
cost total driving cost.
full temporal variant makes time spent driving walking locations dependent path traversed, durations dependent actions
(as simple temporal version). variants plan quality depends
make-span.
additional variant, hard numeric variant, complicates cost driving
making dependent load carried: additional package added truck
increases fuel consumption rate truck current value, making consumption increase quadratic function load.
A.3.3 Zeno-Travel Domain
domain actions embark disembark passengers onto aircraft fly
two alternative speeds locations. strips variant rather uninteresting
two speeds offer meaningful alternatives. metric variant
planes consume fuel different rates according speed travel (two alternatives)
distances locations vary. Problem instances require plans minimise
linear combination time fuel use.
temporal versions closer original zeno problem. involve durations
different means travel different levels fuel consumption. contrast
original zeno problem fuel consumption described continuous function,
discrete step functions applied end points durative actions. fact
fuel aircraft cannot affected multiple different concurrent actions
value relevant satisfying precondition actions could begin
continuous consumption replenishment fuel means discrete model fuel use
sufficient, demanding less expressive power planners use model.
A.3.4 Satellite Domain
satellite domain developed following discussions David E. Smith Jeremy
Franks nasa Ames Research Center. intended first model satellite
observation scheduling problem. full problem involves using one satellites
make observations, collecting data downlinking data ground station.
satellites equipped different (possibly overlapping) collections instruments,
different characteristics terms appropriate calibration targets, data productions,
energy consumption requirements warming cooling down. satellites
pointed different targets slewing different attitudes.
constraints targets accessible different satellites due occlusion
slewing capabilities. Instruments generate data must stored satellite
subsequently downlinked window communication opportunity opens
47

fiLong & Fox

ground station. Communication windows fixed. Data takes time downlink
could impossible downlink entire satellite store given time frame, downlinks
must scheduled around storage capacity, production data observations
opportunities downlink data arise. real problem additional
difficulties management energy use solar power maintenance operational temperatures periods shadow. order make problem
accessible planners competition (given time scales encoding domain,
writing problem generator testing competing planners) several important features
real problem simplified. Perhaps important real problem
targets visible particular time-windows, although elimination
problem downlinking data also significant simplification. Representing windows
opportunity possible pddl2.1, entirely straight-forward remains
area need development. Management power temperature
also simplified away.
strips version problem involves deciding efficient covering
observations given satellite capabilities. interesting combinatorial problem
satellites assumed free operate concurrently (in Graphplan-style parallel
activity), otherwise problem offers interesting choice points. strips version
based earlier Satellite domain contributed Patrik Haslum.
metric version problem introduces data capacities satellites fuel
use slewing targets. plans expected minimize fuel use obtaining
data. problem combines constrained bin-packing problem (getting data
limited stores satellites, subject constraints certain satellites
equipped obtain certain data) kind route planning problem (finding fuel-efficient
paths targets also considering combined costs fuel consumption
satellites).
temporal versions introduce duration make concurrency important. full
temporal problem includes different slew times different pairs targets.
problems involve minimising make-span times data acquisition. complex
version domain combines temporal metric features planners
required manage problem storing different sized data blocks limited capacity
satellite data stores.
variant Satellite domain, called hardnumeric version, represents
important departure traditional planning problems: logical goals describing
intended final state trivial (either empty simple final positions
satellites), metric plans declared evaluated quantity
data collected. problem interesting null (or nearly null) plan solve
instances, quality plans zero. produce good plan
necessary ensure satellites used collect data this, turn, requires
planner constructs reasonable data collection goals. hard problem
current planners particularly fully-automated planning systems. Nevertheless,
realistic demand many problems planner might required face:
uncommon specific final state less important effects actions
carried reaching it.
48

fiThe 3rd International Planning Competition

A.3.5 Rovers Domain
Rovers domain constructed simplified representation problem
confronts nasa Mars Exploration Rover missions launched 2003, Mars Science
Laboratory mission planned 2009 similar missions expected part
ESA AURORA project. strips version problem involves planning several
rovers, equipped different, possibly overlapping, sets equipment traverse
planet surface. rovers must travel waypoints gathering data transmitting
back lander. traversal complicated fact certain rovers restricted
travelling certain terrain types makes particular routes impassable
rovers. Data transmission also constrained visibility lander
waypoints.
metric version domain introduces energy cost associated actions
action allowing rovers recharge, provided sun. problems sought
solutions minimised numbers recharges, use energy required
efficient possible.
metric temporal variant domain involves energy time management,
although instances require planners optimise total duration. demand implies
need efficient energy use, since recharging action consumes considerable
amount time and, model, requires recharging rover remain one place
period recharging. opportunity careful division labour
rovers makes temporal variants complex interesting problems.
A.3.6 Settlers Domain
domain exists metric problem. problem inspired multitude
computer games involve managing resources, accumulating raw resources slowly
combining advanced processing plants structures
achieve sophisticated objectives. problem proposed Patrik Haslum.
interesting difficulty problem presents problem involves constructing new objects resources. easily represented pddl2.1. fact,
way capture domain pddl2.1 name objects could constructed give attribute indicating whether actually
constructed. leads cumbersome encoding and, moreover, represents particular problem planners ground actions prior planning, since multitude
potential objects must considered process, leading huge collection actions.
Many actions uninterestingly different, since specific choice names
objects created solving instance clearly irrelevant, alternative
constructed considered planning process.
A.3.7 UM-Translog-2 Domain
UM-Translog-2 (Wu & Nau, 2002) domain used hand-coded planners
incomplete set results collected due time constraints conclusion
testing period. domain significant challenge size
seen useful benchmark problem fully-automated planners challenges
grounding searching domain many action schemas.
49

fiLong & Fox

Appendix B. Competitors
B.1 Fully Automated Planners
eleven competitors category, representing least four distinct planning paradigms (forward search, model-checking, local search partial order planning).
Fully-automated planners accept pddl2.1 specifications domain, initial state
goal compute solutions solely basis specifications. additional control
knowledge guidance supplied. Fully-automated planners therefore depend sophisticated search control heuristics efficient storage alternative search branches.
popular current approach search control make use variants relaxed plan
idea originally proposed McDermott (1996) subsequently exploited Bonet
Geffner (1997) Hoffmann (2000).
IxTeT (Laborie & Ghallab, 1995) entered fully-automated planner, retrospect
might better classified hand-coded planner. ability hand-code
domain representations might alleviated problems arose making
competition domains accessible IxTeT. IxTeT currently accept domains
problems pddl format, necessary translate competition domains
representation language. automatic translator pddl IxTeT
input language yet exists clear translation automated.
Furthermore, plan representation IxTeT general insisted upon
use competition advantage given need automate
plan validation process. fact, several plans produced IxTeT could validated.
combination difficulties made impossible offer real insights
performance IxTeT competition domains. Nevertheless, pleased
attempt made enter IxTeT: important competition cause
fracture members research community interested entering
long-established alternative planning technology cannot easily
reengineered meet assumptions underlying competition.
B.1.1 FF
ff extremely successful influential planner since 2000 (Hoffmann & Nebel,
2000). based forward state space search using relaxed plans give heuristic guidance
choice possible steps space. Hoffmann extended original ff
system (Hoffmann, 2003a) include treatment metric domains relaxing metric
dimensions problem well logical dimensions.
B.1.2 IxTeT
IxTeT (Laborie & Ghallab, 1995) well known one first planners
reason time resource intensive domains. version participated parts
competition reimplementation original system described Ghallab
Laruelle (Ghallab & Laruelle, 1994). mentioned above, IxTeT experienced number
difficulties competition making difficult evaluate performance. However, seen
broader context planning research application IxTeT made many important
contributions development temporal resource-intensive planning approaches
50

fiThe 3rd International Planning Competition

and, powerful plan representation language, suited certain applications
simplified plan representation used competition inadequate.
B.1.3 LPG
lpg (Gerevini et al., 2003) based local-search strategy applied plan graphs (Blum
& Furst, 1995). approach generalised accommodate metric
temporal structure, making powerful flexible planner. use local search
allows planner configured trade-off time plan quality. Indeed, planner
exhibits time behaviour sense plans reported found and,
search allowed run longer, better quality plans might discovered.
B.1.4 MIPS
mips (Edelkamp, 2003) uses variety techniques, core model-checker
based ordered binary decision diagrams (obdds), used generate reachable
states. planner uses powerful technique compress state representations order
make obdds compact. Exhaustive search state space impractical
large problems mips uses heuristic evaluation function based relaxed plans order
restrict space explored states. mips tackles concurrency temporal planning
lifting partial orders totally ordered plans produced forward search.
mips also extended manage metric quantities, also using relaxation heuristic
predict behaviours metric quantities.
B.1.5 SAPA
sapa (Do & Kambhampati, 2003) forward search planner using relaxed temporal
plan heuristic (based use relaxed tgp-style (Smith & Weld, 1999) plan graph)
guide search. heuristic supplemented heuristic estimate resource
usage allowing planner handle metric quantities. Temporal structure managed
using delayed effects, that, durative action executed, end effects queued
event queue, pending application time advanced point
triggered. focus sapa development management metric
temporal structure. sapa attempt compete strips simpletime problems,
performed well complex problems.
B.1.6 SEMSYN
semsyn (Parker, 1999) Graphplan-based planner, extensions handle metric
adl features. general, Graphplan-based approaches have, exception lpg,
proven unequal challenge scaling meet latest sets benchmark problems.
suggests search strategy Graphplan must abandoned large problems
solved, underlying plan graph structure need source
scaling problems (in fact ff, vhpop, sapa lpg use plan graph structures
planning process).
51

fiLong & Fox

B.1.7 SIMPLANNER
simplanner (Onainda, Sapena, Sebastia, & Marzal, 2001) forward search planner
using relaxed plan heuristic. heuristic evaluation uses separate relaxed plans
top level goals, combining identify useful first action apply
current state. variant idea relaxed plans appears represent reinforcement
notion helpful actions developed ff, actions selected first
layer relaxed Graphplan-style plan favoured appropriate candidates next
step plan.
B.1.8 STELLA
stella (Sebastia, Onainda, & Marzal, 2001) uses forward heuristic search architecture,
modification plans built using landmarks (Porteous, Sebastia, &
Hoffmann, 2001). idea identify key states path plan planning
begins use stepping stones progress initial state
goal state.
B.1.9 TP4
tp4 (Haslum & Geffner, 2001) development hsp (Bonet et al., 1997) planning
approach, one first current generation rather successful heuristic
state-space search planners based relaxed plan heuristics. tp4 extends use
heuristic manage temporal plan structure. planner intended find optimal
plans (although, minor technical reasons, plans produces slightly suboptimal), using admissible heuristic, requires far greater search effort
planners constructing plans merely heuristically good.
B.1.10 TPSYS
tpsys (Garrido, Onainda, & Barber, 2001; Garrido, Fox, & Long, 2002) temporal
planner based Graphplan. technical differences tpsys tgp (Smith
& Weld, 1999), central use temporal plan graph similar, using graph
represent passage time, actions associated durations.
Graphplan-based approaches, search machinery appears scale badly.
B.1.11 VHPOP
Partial order planners suffered period unfashionable, supplanted Graphplan and, recently, relaxed-plan-based heuristic state-space search planners. vhpop (Younes & Simmons, 2003) represents interesting indication partial order
planning far defunct. particular, partial order framework offers powerful way handle temporal constraints. vhpop simple temporal network used
manage temporal constraints end points durative actions allows
planner successfully treat concurrency features temporal plan structure.
Within framework partial-order planner, vhpop makes use plan graph distance
estimates guide search.
52

fiThe 3rd International Planning Competition

B.2 Hand-coded Planners
three entrants category planners requiring hand-coded control knowledge. 2000 competition teams competing planners allowed
time reformulate domain descriptions include domain-specific control knowledge.
results show, control knowledge dramatically improve planner performance. However, difficult assess cost-effectiveness hand-coding control knowledge. Fahiem
Bacchus (2001) observed need quantify time effort required identify
encode useful control knowledge order better able judge trade-off
fully-automated hand-coded approaches. However, difficult measure
effort involved. principle possible bound time allowed domain
reformulation, differences team sizes experience team members
become important comparing achieved different participants.
third competition, like it, explore factors, impossible
make judgements relative effectiveness solutions problems offered
hand-coded planning systems. remains important open issue
future competitions address.
B.2.1 SHOP2
shop2 (Nau, Au, Ilghami, Kuter, Murdoch, Wu, & Yaman, 2003) Hierarchical Task
Network (htn) planner. Like htn planners, shop2 allows tasks subtasks
partially ordered. Thus plans may interleave subtasks different tasks
expansion tasks. However, unlike htn planners, shop2 generates steps
plan order steps later executed therefore
maintain representation current state stage planning process.
makes much easier incorporate substantial expressive power htns used
shop2. example, might include axioms, mixed symbolic numeric computation,
even calls external programs.
B.2.2 TALPLANNER
successful hand-coded planners 2000, talplanner (Kvarnstrom &
Magnusson, 2003) uses temporal action logic language describing planning domains
uses control rules guide planner making intelligent choices constructing
plans forward search idea originally developed tlplan. rules act
prune away search branches predicted (by human encoding rules) lead
solutions. Using idea, possible arrive collection rules that,
examination given state, guide planner choose actions effectively
virtually search required all.
B.2.3 TLPLAN
tlplan (Bacchus & Kabanza, 2000) also uses temporal logic language support
construction control rules guide plan search. tlplan preceded talplanner
use idea. tlplan adopts slightly different approach management tem53

fiLong & Fox

poral structure talplanner, also capable handling metric quantities.
extensions tlplan allow handle time described Bacchus Ady (2001).

54

fiThe 3rd International Planning Competition

Appendix C. Statistical Techniques
analysis conducted paper makes use several standard statistical tests.
Wilcoxon matched-pairs rank-sum test, proportion test, matched-pairs t-test,
Spearmans rank correlation test rank correlation test agreement multiple
judgements. benefit readers unfamiliar tests, briefly
summarise here. appendix constructed using Gopal K. Kanjis 100 Statistical
Tests (1999).
C.1 Proportion Test
test also known binomial distribution test. test used consider
proportion sample particular qualitative observation made.
example, proportion rolls die come 6. test examines far
expected proportion observed proportion, given assumed probability
observation. use paper, adopt null hypothesis two planners
win equal likelihood test proportion observed wins one planner
hypothesis. deviation observed proportion expected proportion
sufficiently high, null hypothesis rejected.
C.2 t-test
t-test parametric test: founded assumption underlying population samples drawn nearly normally distributed. reasonably
robust failures assumption, treated caution true distribution deviates normal. test considers means two samples tests
null hypothesis two samples drawn populations mean.
Variants available according known variance underlying populations. t-test conservative version Z-test, relies effect
confirmed Central Limit Theorem that, large samples, sampling ditribution
mean normal. t-test applied smaller samples, compensating
distortion distribution creates. paper, use variant
t-test observations drawn matched pairs: element pair test
result conducted close identical circumstances, different test subject (in
case, different planner).
n pairs observations, di difference pair mean
difference, variance, s, differences given by:
2

=

n
X
(di d)2
i=1

n1

x1 x2 means samples two populations,
statistic is:
x1 x2

t=
s/ n
n 1 degrees freedom.
55

fiLong & Fox

C.3 Wilcoxon Matched-Pairs Rank-Sum Test
use ranks releases statistical tests parametric assumptions underlying
distributions replacing actual observed values rank within ordered set
observed values. Wilcoxon matched-pairs test analogous matched-pairs t-test,
uses sum ranks values associated two test subjects.
pairs ordered according absolute values differences sum
ranks positive values compared sum ranks negative
values. two subjects exhibit particular pattern relative behaviours
positive negative values distributed roughly evenly ranks
thus rank-sums approximately equal. distortion rank-sums
indicates one subject consistently superior performance other.
test defined follows. Given collection n pairs data items, differences
pairs found ranked according absolute magnitude. sum
ranks formed negative positive differences separately. smaller
two rank sums. sufficiently large samples following value approximately
normally distributed:
n(n + 1)/4)
p
n(n + 1)(2n + 1)/24
C.4 Spearmans Rank Correlation Test
test correlation sequence pairs values. Using ranks eliminates
sensitivity correlation test function linking pairs values. particular,
standard correlation test used find linear relations test pairs, rank
correlation test restricted way.
Given n pairs observations, (xi , yi ), xi values assigned rank value and,
separately, yi values assigned rank. pair (xi , yi ), corresponding
difference, di xi yi ranks found. value R is:
R=

n
X

d2i

i=1

large samples test statistic then:
Z=

6R n(n2 1)

n(n + 1) n 1

approximately normally distributed.
C.5 Rank Correlation Test Agreement Multiple Judgements
tests significance correlation n series rank numbers, assigned
n judges K subjects. n judges give rank numbers K subjects compute:
S=

nK(K 2 1)
12
56

fiThe 3rd International Planning Competition

SD , sum squares differences subjects mean ranks overall
mean rank. Let:
D1 =

SD
D1
D2
, D2 = D1 , S12 =
, S22 =
n
K 1
K(n 1)

test statistic is:
F =

S12
S22

follows F distribution K 1, K(n 1) degrees freedom.

57

fiLong & Fox

References
Bacchus, F. (2001). AIPS00 planning competition. AI Magazine, 22(3), 4756.
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaining approach. Proceedings IJCAI-01, pp. 417424.
Bacchus, F., & Kabanza, F. (2000). Using temporal logic express search control knowledge
planning. Artificial Intelligence, 116(1-2), 123191.
Blum, A., & Furst, M. (1995). Fast Planning Plan-graph Analysis. Proceedings
IJCAI-95.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism
planning. Proceedings AAAI-97, pp. 714719. AAAI/MIT Press.
Do, M. B., & Kambhampati, S. (2003). Sapa: scalable, multi-objective, heuristic, metric,
temporal planner. Journal Artificial Intelligence Research, issue.
Edelkamp, S. (2003). Taming numbers durations model-checking integrated
planning system. Journal Artificial Intelligence Research, issue.
Fox, M., & Long, D. (2003). pddl2.1: extension pddl expressing temporal
planning domains. Journal Artificial Intelligence Research, issue.
Garrido, A., Fox, M., & Long, D. (2002). Temporal planning PDDL2.1. Proceedings
ECAI-02.
Garrido, A., Onainda, E., & Barber, F. (2001). Time-optimal planning temporal problems. Proceedings ECP-01.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs LPG. Journal Artificial Intelligence Research, issue.
Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal
planner. Proceedings AIPS-94.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP-01, Toledo.
Hoffmann, J. (2003a). Metric-FF planning system: Translating ignoring delete lists
numerical state variables. Journal Artificial Intelligence Research, issue.
Hoffmann, J. (2003b). ignoring delete-lists works: local search topology planning
benchmarks. Tech. rep. 185, Institut fur Informatik, Albert-Ludwigs Universitat,
Freiburg.
Hoffmann, J., & Nebel, B. (2000). FF planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Howe, A., & Dahlman, E. (2002). critical assessment benchmark comparison planning. Journal Artificial Intelligence Research, 17, 133.
Kanji, G. (1999). 100 Statistical Tests. Sage Publications.
Kvarnstrom, J., & Magnusson, M. (2003). Talplanner 3rd international planning
competition: Extensions control rules. Journal Artificial Intelligence Research,
issue.
58

fiThe 3rd International Planning Competition

Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings IJCAI-95. Morgan Kaufmann.
Long, D. (2000). AIPS98 Planning Competition: Competitors perspective. AI Magazine, 21 (2).
McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2).
McDermott, D., & AIPS98 Planning Competition Committee (1998). PDDLthe planning domain definition language. Tech. rep., Available at: www.cs.yale.edu/homes/dvm.
McDermott, D. (1996). heuristic estimator means ends analysis planning.
Proceedings AIPS-96, pp. 142149. AAAI Press.
Nau, D., Au, T.-C., Ilghami, O., Kuter, U., Murdoch, J., Wu, D., & Yaman, F. (2003).
SHOP2: HTN planning environment. Journal Artificial Intelligence Research,
issue.
Onainda, E., Sapena, O., Sebastia, L., & Marzal, E. (2001). SimPlanner: executionmonitoring system replanning dynamic worlds. Proceedings EPIA-01.
Parker, E. (1999). Making graphplan goal-directed. Proceedings ECP-99, pp. 333346.
Penberthy, J., & Weld, D. (1994). Temporal planning continuous change. Proceedings
AAAI-94. AAAI/MIT Press.
Porteous, J., Sebastia, L., & Hoffmann, J. (2001). extraction, ordering, usage
landmarks planning. Proceedings ECP-01.
Sebastia, L., Onainda, E., & Marzal, E. (2001). SteLLa: optimal sequential parallel
planner. Proceedings EPIA-01.
Smith, D. E., & Weld, D. S. (1999). Temporal planning mutual exclusion reasoning.
Proceedings IJCAI-99, pp. 326337.
Wu, D., & Nau, D. (2002). um-translog-2: planning domain designed AIPS-02. Tech.
rep. CS-TR-4402, University Maryland.
Younes, H., & Simmons, R. (2003). vhpop: Versatile heuristic partial order planner. Journal
Artificial Intelligence Research, issue.

59

fiJournal Artificial Intelligence Research 20 (2003) 195-238

Submitted 6/03; published 12/03

Taming Numbers Durations Model Checking
Integrated Planning System
Stefan Edelkamp

stefan.edelkamp@cs.uni-dortmund.de

Baroper Strae 301
Fachbereich Informatik, GB IV
Universitat Dortmund
44221 Dortmund
Germany

Abstract
Model Checking Integrated Planning System (MIPS) temporal least commitment heuristic search planner based flexible object-oriented workbench architecture.
design clearly separates explicit symbolic directed exploration algorithms
set on-line off-line computed estimates associated data structures.
MIPS shown distinguished performance last two international planning competitions. last event description language extended pure propositional
planning include numerical state variables, action durations, plan quality objective
functions. Plans longer sequences actions time-stamped schedules.
participant fully automated track competition, MIPS proven
general system; track every benchmark domain efficiently computed plans
remarkable quality. article introduces analyzes important algorithmic
novelties necessary tackle new layers expressiveness benchmark
problems achieve high level performance.
extensions include critical path analysis sequentially generated plans generate
corresponding optimal parallel plans. linear time algorithm compute parallel
plan bypasses known NP hardness results partial ordering scheduling plans
respect set actions imposed precedence relations. efficiency
algorithm also allows us improve exploration guidance: encountered planning
state corresponding approximate sequential plan scheduled.
One major strength MIPS static analysis phase grounds simplifies
parameterized predicates, functions operators, infers knowledge minimize
state description length, detects domain object symmetries. latter aspect
analyzed detail.
MIPS developed serve complete optimal state space planner,
admissible estimates, exploration engines branching cuts. competition
version, however, certain performance compromises made, including floating point
arithmetic, weighted heuristic search exploration according inadmissible estimate
parameterized optimization.

1. Introduction
Practical action planning model checking appear closely related. MIPS
project targets integration model checking techniques domain-independent
action planner. HSF-Spin experimental model checker (Edelkamp, Leue, & LluchLafuente, 2003) looking towards integration planning technology
c
2003
AI Access Foundation. rights reserved.

fiEdelkamp

existing model checker. Additional synergies exploited automated compilation
protocol software model checking problems planner inputs (Edelkamp, 2003).
Model checking (Clarke, Grumberg, & Peled, 1999) automated process verify
formal model system satisfies specified temporal property not. illustrative
example, take elevator control system together correctness property requires
elevator eventually stop every call passenger guarantees door
closed, elevator moving. Although success checking correctness limited,
model checkers found many errors current hardware software designs. Models
often consist many concurrent sub-systems. combination either synchronous,
often seen hardware design verification, asynchronous, frequently given communication security protocols, multi-threaded programming languages like Java.
Model checking requires exploration large state spaces containing reachable system states. problem known state explosion problem occurs even
sets generated states much smaller set reachable states.
error shows safety property violation, like deadlock failed assertion,
corresponds one set target nodes state space graph. Roughly speaking,
something bad occured. liveness property violation refers (seeded) cycle
graph. Roughly speaking, something good never occur. case elevator
example, eventually reaching target state request button pressed liveness
property, certifying closed doors refers safety property.
two main validation processes model checking explicit symbolic search.
explicit-state model checking state refers fixed memory location state
space graph implicitly generated successive expansions state.
symbolic model checking (McMillan, 1993; Clarke, McMillan, Dill, & Hwang, 1992),
(fixed-length) binary encodings system states used, state represented characteristic function representation. function evaluates true
Boolean state variables assigned bit values respect binary
encoding system state. Subsequently, characteristic function conjunction
literals plain variable 1 encoding negated variable 0. Sets
states expressed disjunction individual characteristic functions.
unique symbolic representation sets states Boolean formulae binary
decision diagrams (BDDs) (Bryant, 1992) often much smaller explicit one. BDDs
(ordered) read-once branching programs nodes corresponding variables, edges
corresponding variable outcomes, path corresponding assignment
variables resulting evaluation leaves. One reason succinctness
BDDs directed acyclic graphs may express exponentially many paths. transition
relation defined two state variable sets. evaluates true, operator
exists transforms state valid successor. sense, BDDs exploit regularities
state set often appear well suited regular hardware systems. contrast, many
software systems inherit highly asynchronous irregular structure, use
BDDs fixed variable ordering generally flexible enough.
symbolic exploration, set states combined transition relation
compute set possible successor states, i.e. image. Starting initial
state, iteration image computations eventually explores entire reachable state space.
196

fiTaming Numbers Durations MIPS

improve efficiency image computations, transition relations often provided
partitioned form.
correspondence action model checking (Giunchiglia & Traverso, 1999)
roughly characterized follows. Similar model checkers, action planners implicitly generate large state spaces, exploration approaches based applying
operators current state. States spaces model checking planning problems
often modelled Kripke structures, i.e. state space graphs states labelled propositional predicates. satisfaction specified property one side corresponds
complete exploration, unsolvable problem side. respect,
goal action planning cast error corresponding trail interpreted
plan. elevator example, goal planning task reach state,
doors open elevator moving. Action planning refers safety properties only,
since goal achievement traditional competition planning problems yet
extended temporal properties. However, temporally extended goals increasing
research interest (Kabanza, Barbeau, & St-Denis, 1997; Pistore & Traverso, 2001; Lago,
Pistore, & Traverso, 2002).
contrast model checkers perform either symbolic explicit exploration, MIPS
features both. Moreover, combines symbolic explicit search planning form
symbolic pattern databases (Edelkamp, 2002b). planner MIPS implements heuristic
search algorithms like A* (Pearl, 1985) IDA* (Korf, 1985) exploration, include
state-to-goal approximation search process rank states expanded next.
Heuristic search brought considerable gains planning (Bonet & Geffner, 2001;
Refanidis & Vlahavas, 2000; Hoffmann & Nebel, 2001; Bertoli, Cimatti, & Roveri, 2001a;
Jensen, Bryant, & Veloso, 2002; Feng & Hansen, 2002) model checking (Yang & Dill,
1998; Edelkamp et al., 2003; Groce & Visser, 2002; Bloem, Ravi, & Somenzi, 2000; Ruys,
2003).
Including resource variables, like fuel level vehicle distance two
different locations, well action duration relatively new aspects competitive
planning (Fox & Long, 2003). input format PDDL2.1 restricted variables
finite domain, also includes rational (floating-point) variables precondition
effects. Similar set atoms described propositional predicate, set numerical
quantities described set parameters. notation PDDL2.1,
refer parameterized numerical quantities functions. example, fuel level might
parameterized vehicle present problem instance file description.
competition, domains provided different tracks according different layers language expressiveness: i) pure propositional planning, ii) planning numerical
resources, iii) planning numerical resources constant action duration, iv) planning
numerical resources variable action duration, and, cases, v) complex problems usually combining time numbers interesting ways. MIPS competed
fully automated system performed remarkably well five tracks; solved large
number problems fully automated planner produced solutions
track every benchmark domain.
paper main algorithmic techniques taming rational numbers, objective
functions, action duration described. article structured follows. First,
review development MIPS system assert main contributions.
197

fiEdelkamp

address object-oriented heuristic search framework system. Subsequently,
introduce terminology allows us give formal definition syntax
semantics grounded mixed numerical propositional planning problem instance.
introduce core contributions: critical path scheduling concurrent plans,
efficient methods detecting using symmetry cuts. PERT scheduling produces
optimal parallel plans linear time given sequence operators precedence relation
among them. paper discusses pruning anomalies effect different optimization
criteria. analyze correctness efficiency symmetry detection detail.
article closes related work concluding remarks.

2. Development MIPS
competition version MIPS refers initial work (Edelkamp & Reffel, 1999a)
heuristic symbolic exploration planning domains cke model checker (Biere,
1997). approach effective sample puzzle solving (Edelkamp & Reffel, 1998)
hardware verification problems (Reffel & Edelkamp, 1999).
implementing propositional planner, first used BDD library called
StaticBdd, large node tables allocated prior use. implementation process changed BDD representation mainly improve performance
small planning problems. selected public domain c++ BDD package Buddy (LindNielsen, 1999), flexible. planning process semi-automated (Edelkamp
& Reffel, 1999b); variable encodings provided hand, representations
operators established enumerating possible parameter instances.
state space encoding action transition relation fixed, exploration form
symbolic breadth-first search state-space could executed. time,
aware work BDD-based planning work Cimatti et al.
(1997), likely first link planning via symbolic model checking. team used
model checker (nu)SMV basis atom-to-variable planning state encoding
scheme top it.
Later on, developed parser static analyzer automate inference state
encodings, generation transition relations, extraction solution paths.
order minimize length state encoding, new analyzer clustered atoms
groups (Edelkamp & Helmert, 1999). confirmed attempts (Weismuller, 1998),
started experimenting PDDL specification cke, state minimization fact
crucial. simple encoding using one variable atom appears competitive
respect Graphplan-based (Blum & Furst, 1995) SAT-plan based planners (Kautz
& Selman, 1996). Subsequently, MIPS first fully automated planning system based
symbolic model checking technology could deal large domain descriptions.
second international planning competition MIPS (Edelkamp & Helmert, 2001)
could handle STRIPS (Fikes & Nilsson, 1971) subset PDDL language (McDermott, 2000) additional features ADL (Pednault, 1989), namely negative
preconditions (universal) conditional effects. MIPS one five planning systems
awarded Distinguished Performance fully automated track. competition
version (Edelkamp & Helmert, 2000) already included explicit heuristic search algorithms
based bit-vector state representation relaxed planning heuristic (RPH) (Hoff198

fiTaming Numbers Durations MIPS

mann & Nebel, 2001) well symbolic heuristic search based HSP heuristic (Bonet
& Geffner, 2001) one-to-one atom derivative RPH. competition, used
breadth-first bi-directional symbolic search whenever single state heuristic search engine
got stuck exploration.
planning competitions, explicit (Edelkamp, 2001c) symbolic pattern
databases (Edelkamp, 2002b) proposed off-line estimators completely explored
problem abstractions. Roughly speaking, pattern database abstractions slice state vector fluents pieces adjust operators accordingly. completely explored
subspaces serve admissible estimates overall search competitive
relaxed planning heuristic several benchmark domains.
third planning competition new levels planning domain description language (PDDL) designed. Level 1 considers pure propositional planning. Level 2 also
includes numerical resources objective functions minimized. Level 3 additionally
allows specification actions durations. Consequently, MIPS extended
cope new forms expressiveness.
First results MIPS planning PDDL2.1 problems presented (Edelkamp,
2001b). preliminary treatment illustrates parsing process two simple benchmark domains. Moreover, propositional heuristics manual branching cuts applied
accelerate sequential plan generation. work extended (Edelkamp, 2002a),
presented two approximate exploration techniques bound fix numerical
domains, first results symmetry detection based fact groups, critical path scheduling,
any-time wrapper produce optimal plans, numerical extension RPH.

3. Architecture MIPS
Figure 1 shows main components MIPS data flow input definition
domain problem instance resulting temporal plan output.
shown shaded light gray, MIPS divided four parts: pre-compilation, heuristics,
search algorithms, post-compilation (scheduling). Henceforth, planning process
coarsely grouped three stages, pre-compilation, heuristic search planning,
construction temporal plans. problem domain description files fed
system, analyzed grounded. fixes state space problem solved.
intermediate result implicit, saved file use planners model
checkers. basics pre-compilation covered Section 3.2.
next stage defines planning process. object-oriented workbench design
planner allows different heuristic estimates combined different search
strategies access data structures. Possible choices listed Sections 3.3 3.4.
Temporal planning based (PERT) scheduling. issue rearranging sequential
(relaxed) plans addressed detail Section 4.3.
planning system developed spirit heuristic search framework,
HSF short (Edelkamp, 1999), allows attachment newly implemented problem
(puzzle) domains already compiled system. Similar approach took
model checking within HSF-Spin, kept extensible general design. fact
characterized action planning protocol validation single-agent challenges.
contrast model checking approach, planning devised hierarchy system
199

fiEdelkamp

domain.pddl

problem.pddl

Precompiler
static analyzer
ground

symmetry

cluster

intermediate representation
Heuristics
explicit PDBs

symbolic PDBs

numerical
RPH

Search Algorithms

relaxed plan

symbolic search

explicit search
RPH

BDDA*, BDD-BFS

A*, IDA*, EHC
scheduling
RPH

sequential plan

relaxed
temporal plan

Scheduler
Critical Path

temporal plan

PERT

Figure 1: Architecture MIPS.

states: implementation numerical states derived class one propositional
states.
Similarily, heuristic search algorithms based abstract search class.
main procedures provided search algorithm state expansion
procedure, heuristic search evaluation function, located one hierarchically organized heuristic estimator classes. sense, algorithms MIPS general
node expanding schemes adapted different problems. Additional data
structures horizon list Open visited list Closed constructed parameters appropriate search algorithms. result, implementations heuristic
search algorithms associated data structures planner MIPS almost match
model checker.
3.1 Example Problem
running example paper instance rather simple PDDL2.1 problem
Zeno-Travel. illustrated Figure 2. initial configuration drawn left
200

fiTaming Numbers Durations MIPS



Scott

B

Dan

C

1000



C



600

B

800

1000

800

1000

Ernie

600

1000



Scott
Ernie

Dan

Figure 2: instance Zeno-Travel domain initial state (left) goal state(s)
(right).

figure goal configuration right. global local numeric variable
assignments shown.
Figures 3 4 provide domain problem specifications1 . instance asks
temporal plan fly passengers (dan, scott, ernie) located somewhere small
map (including cities city-a, city-b, city-c, city-d) aircraft (plane)
respective target destinations. Boarding debarking take constant amount
time. plane fixed fuel capacity. Fuel time consumed according
distances cities travel speed. Fuel restored refueling
aircraft. result, total amount fuel also maintained numerical quantity.
3.2 Precompiler
static analyzer takes domain problem instance input, grounds propositional state information infers different forms planner independent static information.
Parsing simple Lisp parser generates tree Lisp entities. reads input files
recognizes domain problem name. cope variable typing, temporarily assert constant typed predicates removed together constant
predicates pre-compilation step. Thereby, infer type hierarchy
associated mapping objects types.
Indexing Based number counted objects, indices grounded predicates,
functions actions devised. Since example problem eight objects predicates two parameters, reserve 2 8 8 = 128
index positions. Similarly, function distance consumes 64 indices, fuel,
1. [...] denotes source fragments omitted sake brevity. given example
action definitions passenger debarking flying airplane.

201

fiEdelkamp

(define (domain zeno-travel)
(:requirements :durative-actions :typing :fluents)
(:types aircraft person city)
(:predicates (at ?x - (either person aircraft) ?c - city)
(in ?p - person ?a - aircraft))
(:functions (fuel ?a - aircraft) (distance ?c1 - city ?c2 - city)
(slow-speed ?a - aircraft) (fast-speed ?a - aircraft)
(slow-burn ?a - aircraft) (fast-burn ?a - aircraft)
(capacity ?a - aircraft)
(refuel-rate ?a - aircraft)
(total-fuel-used) (boarding-time) (debarking-time))
(:durative-action board
:parameters (?p - person ?a - aircraft ?c - city)
:duration (= ?duration boarding-time)
:condition (and (at start (at ?p ?c))
(over (at ?a ?c)))
:effect (and (at start (not (at ?p ?c)))
(at end (in ?p ?a))))
[...]
(:durative-action zoom
:parameters (?a - aircraft ?c1 ?c2 - city)
:duration (= ?duration (/ (distance ?c1 ?c2) (fast-speed ?a)))
:condition (and (at start (at ?a ?c1))
(at start (>= (fuel ?a) (* (distance ?c1 ?c2) (fast-burn ?a)))))
:effect (and (at start (not (at ?a ?c1)))
(at end (at ?a ?c2))
(at end (increase total-fuel-used
(* (distance ?c1 ?c2) (fast-burn ?a))))
(at end (decrease (fuel ?a)
(* (distance ?c1 ?c2) (fast-burn ?a))))))
(:durative-action refuel
:parameters (?a - aircraft ?c - city)
:duration (= ?duration (/ (- (capacity ?a) (fuel ?a)) (refuel-rate ?a)))
:condition (and (at start (< (fuel ?a) (capacity ?a)))
(over (at ?a ?c)))
:effect (at end (assign (fuel ?a) (capacity ?a))))
)

Figure 3: Zeno-Travel domain description PDDL2.1.

slow-speed, fast-speed, slow-burn, fast-burn, capacity, refuel-rate
reserve eight index positions. quantities total-fuel-used, boarding-time,
debarking-time single fact identifier needed. Last least model
duration additional quantity total-time. special variable one
overwritten least commitment planning approach scheduling plans
described Section 4.
202

fiTaming Numbers Durations MIPS

(define (problem zeno-travel-1)
(:domain zeno-travel)
(:objects plane - aircraft
ernie scott dan - person
city-a city-b city-c city-d - city)
(:init (= total-fuel-used 0) (= debarking-time 20) (= boarding-time 30)
(= (distance city-a city-b) 600) (= (distance city-b city-a) 600)
(= (distance city-b city-c) 800) (= (distance city-c city-b) 800)
(= (distance city-a city-c) 1000) (= (distance city-c city-a) 1000)
(= (distance city-c city-d) 1000) (= (distance city-d city-c) 1000)
(= (fast-speed plane) (/ 600 60)) (= (slow-speed plane) (/ 400 60))
(= (fuel plane) 750)
(= (capacity plane) 750)
(= (fast-burn plane) (/ 1 2))
(= (slow-burn plane) (/ 1 3))
(= (refuel-rate plane) (/ 750 60))
(at plane city-a) (at scott city-a) (at dan city-c) (at ernie city-c))
(:goal (and (at dan city-a) (at ernie city-d) (at scott city-d)))
(:metric minimize total-time)
)

Figure 4: Zeno-Travel problem instance.
Flattening Temporal Identifiers interpret action integral entity,
timed propositional numerical preconditions merged. Similarly,
effects merged, independent time happen. Invariant conditions
like (over (at ?a ?c)) action board added precondition set.
discuss rationale step Section 4.1.
Grounding Propositions Fact-space exploration relaxed enumeration planning
problem determine superset reachable facts. Algorithmically, FIFO fact
queue compiled. Successively extracted facts front queue matched
operators. time preconditions operator fulfilled, resulting
atoms according positive effect (add) list determined enqueued.
allows us separate constant facts fluents, since latter reached
exploration.
Clustering Atoms concise encoding propositional part separate fluents
groups, state planning space expressed conjunction (possibly trivial) facts drawn fact group (Edelkamp & Helmert,
1999). precisely, let #pi (o1 , . . . , oi1 , oi+1 , . . . , ) number objects oi
fact (p o1 . . . ) true. establish single-valued invariant
#pi (o1 , . . . , oi1 , oi+1 , . . . , ) = 1. allow better encoding, predicates
like merged. example, three groups determine unique position
persons (one five) one group determines position plane (one
four). Therefore, 3 dlog 5e + 1 dlog 4e = 11 bits suffice encode total 19
fluents.
203

fiEdelkamp

Grounding Actions Fact-space exploration also determines grounded operators.
preconditions met grounded, symbolic effect lists instantiated.
case determine 98 instantiated operators, which, simplifications
eliminate duplicates trivial operators (no-ops), reduced 43.
Grounding Functions Simultanous fact space exploration propositional part
problem, heads numerical formulae effect lists grounded.
example case three instantiated formulae fluent (vary time): (fuel
plane) initial value 750 well total-fuel-used total-time initialized zero. numerical predicates fact constants
substituted formula-bodies. example, effect (board dan city-a)
reduces (increase (total-time) 30), (zoom plane city-a city-b)
numerical effects (increase (total-time) 150),(increase (total-fuel-used)
300)), (decrease (fuel plane) 300). Refuelling, however, reduce
single rational number, example effects (refuel plane city-a)
simplify (increase (total-time) (/ (- (750 (fuel plane)) / 12.5)))
(assign (fuel plane) 750). evaluate former assignment especially forward chaining planner, variable (total-time) instantiated on-the-fly.
due fact value quantity (fuel plane) constant
changes time.
Symmetry Detection Regularities planning problem respect transposition domain objects partially determined static analyzer addressed
detail Section 5.
intermediate textual format static analyzer annotated grounded PDDLlike representation serves interface planners model checkers,
additional resource plan visualization. Figures 5 6 show parts intermediate
representation inferred Zeno-Travel example.
3.3 Heuristics
MIPS incorporates following heuristic estimates.
Relaxed planning heuristic (RPH) Approximation number planning steps
needed solve propositional planning problem delete effects removed (Hoffmann & Nebel, 2001). heuristic constructive, returns set
operators appear relaxed plan.
Numerical relaxed planning heuristic (numerical RPH) extension RPH
deal numbers combined propositional numerical approximation
scheme allowing multiple operator application.
Pattern database heuristic (explicit PDB) Different planning space abstractions
found greedy manner, yielding selection pattern databases fit main
memory. contrast RPH, pattern database designed disjoint yielding
admissible estimate needed optimal planning A* (Edelkamp, 2001c).
204

fiTaming Numbers Durations MIPS

(define (grounded zeno-travel-zeno-travel-1)
(:fluents
(at dan city-a)
(at dan city-b)
(at dan city-c)
(at dan city-d)
(at ernie city-a) (at ernie city-b) (at ernie city-c) (at ernie city-d)
(at plane city-a) (at plane city-b) (at plane city-c) (at plane city-d)
(at scott city-a) (at scott city-b) (at scott city-c) (at scott city-d)
(in dan plane)
(in ernie plane) (in scott plane))
(:variables (fuel plane) (total-fuel-used) (total-time))
(:init
(at dan city-c)
(at ernie city-c) (at plane city-a) (at scott city-a)
(= (fuel plane) 750) (= (total-fuel-used) 0) (= (total-time) 0))
(:goal (at dan city-a)
(at ernie city-d) (at scott city-d))
(:metric minimize (total-time) )
(:group dan
(at dan city-a)
(at dan city-b)
(at dan city-c)
(at dan city-d)
(in dan plane))
(:group ernie
(at ernie city-a) (at ernie city-b) (at ernie city-c) (at ernie city-d)
(in ernie plane))
(:group plane
(at plane city-a) (at plane city-b) (at plane city-c) (at plane city-d))
(:group scott
(at scott city-a) (at scott city-b) (at scott city-c) (at scott city-d)
(in scott plane))

Figure 5: Grounded representation Zeno-Travel domain.
Symbolic pattern database heuristic (symbolic PDB) Symbolic PDBs apply explicit symbolic heuristic search engines (Edelkamp, 2002b). Due succinct
BDD-representation sets states, symbolic PDBs often orders magnitudes
larger explicit ones.
Scheduling relaxed plan heuristic (scheduling RPH) Critical-path analysis
scheduling guide plan finding phase. Like RPH, computes length
greedily extracted sequential plan, scheduling RPH also takes relaxed sequence
operators account, searches suitable parallel arrangement,
turn defines estimator function.
3.4 Exploration Algorithms
algorithm portfolio includes three main explicit heuristic search algorithms.
A* A* algorithm (Hart, Nilsson, & Raphael, 1968) variant Dijkstras singlesource shortest path exploration scheme executed re-weighted state space graph.
lower bound heuristics, A* shown generate optimal plans (Pearl, 1985).
Weighting influence heuristic estimate may accelerate solution finding,
also affects optimality (Pohl, 1977).
205

fiEdelkamp

(:action board dan plane city-a
:condition
(and (at dan city-a) (at plane city-a))
:effect
(and (in dan plane) (not (at dan city-a))
(increase (total-time) (30.000000))))
[...]
(:action zoom plane city-a city-b
:condition
(and
(at plane city-a)
(>= (fuel plane) (300.000000)))
:effect
(and (at plane city-b) (not (at plane city-a))
(increase (total-time) (60.000000))
(increase (total-fuel-used) (300.000000))
(decrease (fuel plane) (300.000000))))
[...]
(:action refuel plane city-a
:condition
(and
(at plane city-a)
(< (fuel plane) (750.000000)))
:effect
(and
(increase (total-time) (/ (- (750.000000) (fuel plane)) (12.500000)))
(assign (fuel plane) (750.000000))))
[...]
)

Figure 6: Grounded representation Zeno-Travel domain (cont.).

Iterative-Deepening A* (IDA*) memory-limited variant A* suited large
exploration problems evaluation functions small integer range low time
complexity (Korf, 1985). IDA* extended bit-state hashing (Edelkamp &
Meyer, 2001) improve duplicate detection respect ordinary transposition
tables (Reinefeld & Marsland, 1994).
(Enforced) Hill Climbing (HC) approach another compromise exploration exploitation. Enforced HC searches improved evaluation
breadth-first manner commits established action selections final (Hoffmann,
2000). Enforced HC complete undirected problem graphs.
MIPS also features following two symbolic search algorithms2 .
2. non-deterministic domains, started implementing weak, strong strong cyclic exploration algorithms (Cimatti, Roveri, & Traverso, 1998).

206

fiTaming Numbers Durations MIPS

Bidirectional Symbolic Breadth-First-Search (BDD-BFS) implementation performs bidirectional blind symbolic search, choosing next search direction favor
faster execution previous iterations (Edelkamp & Helmert, 1999).
Symbolic A* (BDDA*) algorithm (Edelkamp & Reffel, 1998) performs guided symbolic search takes (possibly partitioned) symbolic representation heuristic
additional input.
3.5 Composition Competition Version
Figure 1 shaded parts actually used competition version
MIPS dark gray. used relaxed planning heuristic sequential plan generation.
scheduling relaxed planning heuristic used temporal domains. Level 2
problems use numerically extended RPH, since added system
final weeks competition. experimented (symbolic) pattern databases
mixed results. Since pattern databases purely propositional implementation
provide retrieval operators optimal abstract plan, include
competition version.
approach extend relaxed planning heuristic numerical information helps
find plans challenging numerical domains like Settlers influenced Hoffmanns work competing planner Metric-FF (Hoffmann, 2002a). builds relaxed
planning graph computing fixed-point state vector restricted monotonically
increasing propositional numerical variables. version integrating numbers
relaxed planning heuristic general Hoffmanns contribution: restricted
variable-to-constant comparisons lacks ability simplify linear constraints.
Therefore, omit algorithmic details paper.
decided employ (enforced) hill climbing explicit plan generation done
Metric-FF probably LPG. Instead applied A* weight 2, merit
states fixed f (S) = g(S) + 2 h(S). conservative plan generation
engine chosen avoid unrecognized dead-ends, expected present
benchmark problems. objective that, least, completeness preserved.
also avoided known incomplete pruning rules, like action relevance cuts (Hoffmann &
Nebel, 2001) goal ordering cuts (Koehler & Hoffmann, 2000).
MIPS, (weighted) A* accesses Dial Weak-Heap priority queue data
structure. former used propositional planning only, latter applies
general planning scheduling estimates. Dial priority queue (Dial, 1969) linear
run time behavior, maximal value w(u, v) + h(v) h(u) edges (u, v)
weighted state space graph (labelled heuristic h) bounded constant. WeakHeaps (Edelkamp & Stiegeler, 2002) simple efficient relaxations ordinary heaps.
Priority queues implemented dynamic tables double sizes
become filled. Moreover, MIPS stores generated expanded states hash table
chaining 3 . compression planning state space, variables
appear objective function neglected hash address calculations state
3. alternative storage structure collection persistent trees (Bacchus & Kabanza, 2000), one
predicate. best case, queries update times structure logarithmic number
represented atoms.

207

fiEdelkamp

comparisons. general, may lead sub-optimal pruning duplicates. However,
benchmark domains destroy optimality, since variables addressed
objective function frequently monotonic synonyms found later search
refer worse solutions.
price paid selecting A*, especially planning problems large branching factors, storing frontier nodes space consuming. Recent techniques
partial expansion horizon list (Yoshizumi, Miura, & Ishida, 2000) reduced storage
visited list (Korf & Zhang, 2000; Zhou & Hansen, 2003) included
system. cases, number expanded nodes often large,
computing relaxed planning estimate appeared computational bottleneck.
retrospect, domains chosen, dead-ends central, hill
climbers appeared effective finding solutions.
temporal domains introduced additional parameter scale influence
propositional estimates (fp (S) = gp (S) + 2 hp (S)) scheduled ones (fs (S) =
gs (S) + 2 hs (S)). precisely, altered comparison function priority queue,
comparison parallel length priorities invoked propositional difference
values larger IN0 . higher value refers higher influence
scheduling RPH, = 0 indicates scheduling all. competition produced
data = 0 (pure MIPS), = 2 (optimized MIPS). comparisons MIPS
planners plain version used, since produces solutions.
(Edelkamp, 2002a) experimented enumeration approach fix numerical
variables finite domain, any-time wrapper optimization objective
functions. options excluded competition version
unpredictable impact planners performance.
3.6 Visualization
Visualization important ease plan understanding quickly detect inefficiencies
plan generation module. visualization plans MIPS extended
animation system Vega (Hipke, 2000); Client-Server architecture runs annotated
algorithm server side, visualized client side Java frontend.
main purpose server make algorithms accessible TCP/IP. able
receive commands multiple clients time. extended Vega two
ways (cf. Figures 7 8).
Gannt Chart Visualization Gannt Charts representations schedules,
horizontal bars drawn activity, indicating estimated duration/cost.
user selects planner executed domain problem file,
interpreted command line options. Alternatively, established plans sent
directly visualizer void planner merely mirrors solution file.
Benchmark Visualization second extension program suite visualize competition domains. moment, sequential plans shown. temporal
plans, refined simulation required, like one produced PDDL2.1 plan
validator. Fortunately, MIPS temporal plan rescheduling sequential
one.
208

fiTaming Numbers Durations MIPS

Figure 7: Visualization plan Gannt Chart format.
images represent domain objects collected image web search
engine4 . generalize specific instances, advised MIPS planner export
propositional numeric state infomation established plan c-like syntax,
turn included header domain visualizer.

4. PDDL2.1 Planning
section elaborate metric temporal planning MIPS. give formal
description grounded planning instances introduce temporal model
4. used Google (cf. www.google.de) searched small GIFs

209

fiEdelkamp

Figure 8: Visualization planning problem instance Settlers.

chosen. Next look operator dependency resulting action precedence relation.
discuss optimality approach anomalies occur state
space pruning. Last least, turn treatment arbitrary plan objective
functions.
Table 1 displays basic terminology sets used paper. currently
successful planning system, MIPS grounds parameterized information present domain
description. set infer suitable index set, indicated bijective mapping
set finite domain. embedding important deal unique identifiers
entities instead textual internal representation. arrays containing
corresponding information accessed constant time.
210

fiTaming Numbers Durations MIPS

Set
OBJ
YPE
PRED
FUN C
ACT

F
V

Descriptor
objects
object types
predicates
functions
actions
operators
fluents/atoms
variables

Example(s)
dan, city-a, plane, . . .
aircraft, person, . . .
(at ?a ?c), (in ?p ?a), . . .
(fuel ?a), (total-time), . . .
(board ?a ?p), (refuel ?a), . . .
(board plane scott), . . .
(at plane city-b), . . .
(fuel plane), (total-time), . . .

Table 1: Basic set definitions.

Consequently, like several planning systems, MIPS refers grounded planning
problem representations.
Definition 1 (Grounded Planning Instance) grounded planning instance quadruple
P = hS, I, O, Gi, set planning states, initial state, G
set goal states. mixed propositional numerical planning problem state
space given
2F IR|V| ,
2F power set F. Therefore, state pair (Sp , Sn ) propositional
part Sp 2F numerical part Sn IR|V| .
sake brevity, assume operators normal form, means
propositional parts (preconditions effects) satisfy standard STRIPS notation (Fikes &
Nilsson, 1971) numerical parts given form arithmetic trees taken
set trees arithmetic operations nodes numerical variables
evaluated constants leaves. However, fundamental difference
general representation preconditions effects. current implementation MIPS
simplifies ADL expressions preconditions takes generic precondition trees
numerical parts, thereby including comparison symbols, logical operators arithmetic
subtrees5 .
Definition 2 (Syntax Grounded Planning Operators) operator normal form
= (, , , ) propositional preconditions F, propositional effects = (a , )
F 2 add list delete list , numerical preconditions , numerical effects .
numerical precondition c triple c = (hc , , tc ), hc V, {, <, =, >, },
tc , arithmetic tree. numerical effect triple =
(hm , , tm ), hm V, {, , } tm . case, call hm head
numerical effect.
5. newer versions MIPS mixing numerical logical preconditions form (or P (< F 3)),
P F F V fact feasible. Boolean expressions put negational normal form
disjunction precondition produce different action instantiations.

211

fiEdelkamp

Obviously, {, <, =, >, } represents associated comparison relation, denotes assignment variable, indicate respective increase decrease
operation.
Definition 3 (Constraint Satisfaction Modifier Update) Let index mapping
variables. vector Sn = (S1 , . . . , S|V| ) numerical variables satisfies numerical
constraint c = (hc , , tc ) S(hc ) eval(Sn , tc ) true, eval(Sn , tc ) IR
obtained substituting v V tc S(hc ) followed simplification tc .
0 ) modifier
vector Sn = (S1 , . . . , S|V| ) updated vector Sn0 = (S10 , . . . , S|V|
= (hm , , tm ) ,
0
S(h
= eval(Sn , tm ) = ,
m)
0
S(h
= S(hm ) + eval(Sn , tm ) = ,
m)
0
S(h
= S(hm ) eval(Sn , tm ) = .
m)

next formalize application planning operators given state.
Definition 4 (Semantics Grounded Planning Operator Application) operator =
(, , , ) applied state = (Sp , Sn ), Sp 2F Sn IR|V| , yields successor
state 0 = (Sp0 , Sn0 ) 2F IR|V| follows.
Sp Sn satisfies c Sp0 = (Sp \ ) vector Sn updated
.
propositional update Sp0 = (Sd \ ) defined standard STRIPS.
example take state = (Sp , Sn )
Sp = {(at ernie city-d), (at plane city-a), (at scott city-d), (in dan plane)}
Sn = {(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 710}.
successor Sn0 = (Sp0 , Sn0 ) due action (debark dan plane city-a)
Sp0 = {(at dan city-a), (at ernie city-d), (at plane city-a), (at scott city-d)}
Sn0 = {(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 730}.
effect lists order update operations important. example
refuelling aircraft ZenoTravel, cf. Figure 6, fuel level reset variable
total-time updated.
set goal states G often given G = (Gp , Gn ) partial propositional state
description Gp F, Gn set numerical conditions c = (hc , , tc ). Moreover,
arithmetic trees tc usually collapses simple leaves labelled numerical constants.
Hence, sake simplifying complexity analysis object symmetry
might assume |Gn | |V|. Complex goal description limitation planner,
since easily transformed preconditions goal-enabling opererator.
212

fiTaming Numbers Durations MIPS

4.1 Temporal Model
simplest approach solving temporal planning problem generate sequential
plan. course, option assumes temporal structure contributes
value plan correctness. is, assumes necessary
concurrency valid plan. cases actions achieve conditions start
points delete end points, example, concurrency necessary
part structure valid plan.
Definition 5 (Sequential Plan) solution planning problem P = hS, I, O, Gi
form sequential plan ordered sequence operators Oi O, {1, . . . , k},
transforms initial state one goal states G G, i.e., exists
sequence states Si S, {0, . . . , k}, S0 = I, Sk = G Si outcome
applying Oi Si1 , {1, . . . , k}.
time stamp ti durational operator Oi , {1, . . . , k} starting time.
Pi1
d(Oj ).
d(Oi ) duration operator Oi , ti = j=1
sequential plans, time stamps calculated MIPS using extra variable
total-time. variable updated scheduling operators. example sequential plan time stamps shown Figure 12.
Minimizing sequential plan length objective first second planning competitions. Since Graphplan-like planners (Blum & Furst, 1995) like IPP (Koehler,
Nebel, & Dimopoulos, 1997) STAN (Long & Fox, 1998) already produced parallel plans
(assuming action duration 1), indeed limiting factor evaluating plan quality.
important reason artificial restriction total-ordered plans
easier automatically validate, necessity checking correctness competition.
PDDL 2.1 domain descriptions include temporal modifiers start, all, end,
label start denotes preconditions effects invocation time
action, refers invariance condition end finalization conditions
consequences action.
Figure 9 show two different options flattening information simple
preconditions effects order derive semantic sequential plans. first
case (top right), compound operator split three smaller parts, one action
invocation, one invariance maintenance, one action termination.
semantics suggested (Fox & Long, 2003).
PDDL2.1 effects invariance pattern, i.e. B 0 = . action
board, quite natural code invariance form conditions (B) perform
actual status change: person boards aircraft city aircraft required
remain city throughout action. moving corridor, status
corridor could encoded invariant would change starting
time action execution.
Moreover, found benchmarks uncommon new effects at-start
preconditioned termination control invariance maintenance, i.e. A0 (B C) = .
Even though intersection conditions effects formally defined yet,
interpreted executing one construct interfere one. reflects
213

fiEdelkamp

pre: eff: pre: eff: pre: eff:
at-start

over-all

at-end

cond:



B

C

eff:

A0

B0

C0

A0

pre:

B B0

C C0

eff:

ABC

A0 B 0 C 0

Figure 9: Compiling temporal modifiers operators.
possible partition operator sub-operators A, B, C, A0 , B 0 , C 0 . Dependence
transposition separated conditions effects considered Section 4.2.
consider example problem more, observe, action board, A0
consists (person airplane) predicate. seen above, B requires plane stay
city boarding, C empty. action zoom, A0 contains effect
plane longer location flight started, B C empty.
cases A0 (B C) = .
B 0 = A0 (B C) = sequential execution sequence
sub-operators (A, A0 , B, B 0 , C, C 0 ) equal execution sequence (A, B, C, A0 , B 0 , C 0 ).
reasoning follows. Since B 0 = (A, A0 , B, B 0 , C, C 0 ) = (A, A0 , B, C, C 0 ).
Conditions A0 B = A0 C = allows us exchange order corresponding
items, (A, A0 , B, C, C 0 ) = (A, B, C, A0 , C 0 ). more, apply B 0 = derive
(A, B, C, A0 , C 0 ) = (A, B, C, A0 , B 0 , C 0 ). consequence remains valid condition
B 0 = weakened B 0 C = .
MIPS operator representation bottom right Figure 9 chosen. Note
intermediate format example problem Figures 5 6 implicitly assumed
temporal model. sequential planning competition benchmark domains
observed many deficiencies model6 .
However, applicability model exploiting parallelism limited. example
consider two people lift table two sides once, could done
one person alone. case parallel execution set actions
cannot totally ordered. allowed MIPS. may argued defining
action requires two different persons certain place would require
equality construct PDDL form numerical maintenance number
people room, found another (artificial) example planning problem
total order. Consider simple STRIPS planning problem domain = {B},
G = {{A, C}}, = {({B}, {A}, {B}), ({B}, {C}, {B})}. Obviously, operators
needed goal achievement, sequential plan length 2, since B
deleted operators. However, parallel plan could devised, since precondition
fulfilled first time step.
6. current versions MIPS refined model, at-start, all, at-end information
preserved grounding process attached action. approach allow
dependent operators overlap minimizes number gaps, start-start, start-end
end-end exclusions. domains, improvement yields much better solutions.

214

fiTaming Numbers Durations MIPS

4.2 Operator Dependency
definition operator dependency enables computing optimal schedules sequential
plans respect generated action sequence causal operator dependency
structure. operators dependent (or void respect optimizer function),
problem inherently sequential schedule leads improvement.
Definition 6 (Dependency/Mutex Relation) Let L(t) denote set leaf variables
tree . Two grounded operators = (, , , ) O0 = (0 , 0 , 0 , 0 )
dependent/mutex, one following three conflicts hold.
Propositional conflict propositional precondition set one operator nonempty intersection add delete list other, i.e., (a0 d0 ) 6=
(a ) 0 6= .
Direct numerical conflict head numerical modifier one operator contained
condition one, i.e. exists c0 = (h0c , , t0c ) 0
= (hm , , tm ) hm L(t0c ) {h0c } exists c = (hc , , tc )
m0 = (h0m , , t0m ) 0 h0m L(tc ) {hc }.
Indirect numerical conflict head numerical modifier one operator contained formula body modifier one, i.e., exists
= (hm , , tm ) m0 = (h0m , , t0m ) 0 hm L(t0m ) h0m L(tm ).
example, operators (board scott plan city-a) (fly plane city-a
city-c) propositional conflict fluent (at plane city-a), (refuel
plane-a city-a) (fly plane city-a city-c) direct numerical conflict
variable (fuel plane). Indirect conflicts subtle, appear
example problem.
use dependency find optimal concurrent arrangement operators
sequential plan. O2 dependent O1 O1 appears O2 sequential
plan, O1 invoked O2 starts. dependence relation reflexive, i.e.
conflict O0 O0 conflict O. Moreover, appears restrictive
compared PDDL 2.1 guidelines mutual exclusion (Fox & Long, 2003),
allows operators partially overlapping even dependent.
However, possible generalize approach. If, according model Fox
Long, two actions Oi represented (Ai , A0i , Bi , Bi0 , Ci , Ci0 ), {1, 2},
dependency violation O1 O2 located identifying sub-operators
interact. fact may identify eight possible refined conflicts (A1 A01 )
interacts (A2 A02 ), (A1 A01 ) interacts (B2 B20 ), (A1 A01 ) interacts
(C2 C20 ), (B1 B10 ) interacts (A2 A02 ), (B1 B10 ) interacts (C2 C20 ), (C1 C10 )
interacts (A2 A02 ), (C1 C10 ) interacts (A2 A02 ), (C1 C10 ) interacts
(A2 A02 ). asserting duration zero pair (Ai , A0i ), d(A) (Bi , Bi0 ), zero
pair (Ci , Ci0 ), one fix earliest start end time O2 respect O1 .
competition version MIPS, stick simplified temporal model.
competition domains, improving sequential plans according dependency relation
turned produce plans sufficient quality.
215

fiEdelkamp

implementation, dependence relation computed beforehand tabulated
constant time access. improve efficiency pre-computation, set leaf
variables maintained array, grounded operator constructed.
original Graphplan definition propositional mutex relation close ours.
fixes interference d0 (a ) 6= (a0 0 ) 6= .
Lemma 1 d0 0 , operator inference Graphplan model implied
propositional MIPS model dependence.
Proof: d0 0 , two independent operators = (, ) o0 = (0 , 0 ):
(a0 d0 ) = implies (a0 d0 ) = , turn yields d0 = . condition
a0 = inferred analogously.
notion dependency also related partial order reduction explicit-state model
checking (Clarke et al., 1999), two operators O1 O2 independent
state following two properties hold:
1. Neither O1 O2 disable execution other.
2. O1 O2 commutative, i.e. O1 (O2 (S)) = O2 (O1 (S)) S.
next result indicates state space enumeration approaches refer
property.
Theorem 1 (Commutativity) Two independent (STRIPS) operators = (, ) O0 =
(0 , 0 ) d0 0 commutative preserve enabled property (i.e.
O0 enabled enabled O0 (S) O0 enabled O(S)).
Proof: Since d0 0 , d0 = a0 = Lemma 1. Let
state ((S \ ) ) let 00 state ((S \ d0 ) a0 ). Since (a0 d0 ) = ,
enabled 00 , since (a ) 0 = , O0 enabled 0 . Moreover,
S0

O(O0 (S)) = (((S \ d0 ) a0 ) \ )
= (((S \ d0 ) \ ) a0 )
= \ (d0 ) (a0 )
= \ (d d0 ) (a a0 )
= (((S \ ) \ d0 ) ) a0
= (((S \ ) ) \ d0 ) a0 = O0 (O(S)).

consequence, operator independence indicates possible transpositions two operators O1 O2 prune exploration sequential plan generation. less restrictive
notion independence, several actions may occur time even one
deletes add-effect another provided (Knoblock, 1994). detect domains
parallelization leads improvement, utilize following sufficient criterion.
216

fiTaming Numbers Durations MIPS

Definition 7 (Inherent Sequential Domains) planning domain said inherently
sequential operator sequential plan either instantaneous (i.e. zero
duration) dependent immediate predecessor.
static analyzer checks testing operator pair. benchmark domains like DesertRats Jugs-and-Water inherently sequential, others like ZenoTravel
Taxi not.
Definition 8 (Parallel Plan) solution planning problem P = hS, I, O, Gi
form parallel plan c = ((O1 , t1 ), . . . , (Ok , tk )) arrangement operators Oi O,
{1, . . . , k}, transforms initial state one goal states G G,
Oi executed time ti IR0 .
example parallel plan ZenoTravel problem depicted Figure 12.
Backstom (1998) clearly distinguishes partially ordered plans (O1 , . . . , Ok , ),
relation {O1 , . . . , Ok }2 partial order (reflexive, transitive, antisymmetric), parallel plans (O1 , . . . , Ok , , #), # ( 1 ) (irreflexive, symmetric)
expressing, actions must executed parallel.
Definition 9 (Precedence Ordering) ordering induced operators O1 , . . . , Ok
defined
Oi Oj : Oi Oj dependent 1 < j k.
Precedence partial ordering, since neither reflexive transitive. computing
transitive closure relation, however, precedence could extended partial
ordering. sequential plan O1 , . . . , Ok produces acyclic set precedence constraints
Oi Oj , 1 < j k, set operators. also important observe,
constraints already topologically sorted according index order 1, . . . , k.
Definition 10 (Respecting Precedence Ordering Parallel Plan) let d(O)
IR0 duration operator sequential plan. parallel plan c = ((O1 , t1 ),
. . . , (Ok , tk )) respects , ti + d(Oi ) tj Oi Oj , 1 < j k.
optimizing plans (Backstrom, 1998) defines parallel execution time max{ti +
d(Oi ) | Oi {O1 , . . . , Ok }}, Oi Oj , ti + d(Oi ) tj , Oi #Oj ,
either ti + d(Oi ) tj tj + d(Oj ) ti . two possible choices # actually
apparent approach, since already precedence relation hand
seek optimal arrangement operators. Consequently assert one option,
namely ti + d(Oi ) tj true, reducing # . order find optimal schedules
sequential plans approach similar (Backstrom, 1998) would necessary.
would dramatically increase computational complexity, since optimal scheduling
set fixed-timed operators NP-hard. Therefore, decided restrict dependency
relation .
Definition 11 (Optimal Parallel Plan) optimal parallel plan respect sequence
operators O1 , . . . , Ok precedence ordering plan = ((O1 , t1 ), . . . , (Ok , tk ))
minimal parallel execution time OP = max{ti + d(Oi ) | Oi {O1 , . . . , Ok }} among
parallel plans c = ((O1 , t01 ), . . . , (Ok , t0k )) respect .
217

fiEdelkamp

Procedure Critical-Path
Input: Sequence operators O1 , . . . , Ok , precedence ordering
Output: Optimal parallel plan length max{ti + d(Oi ) | Oi {O1 , . . . , Ok }}
{1, . . . , k}
e(Oi ) d(Oi )
j {1, . . . , 1}
(Oj Oi )
e(Oi ) < e(Oj ) + d(Oi )
e(Oi ) e(Oj ) + d(Oi )
return max1ik e(Oi )

Figure 10: Algorithm compute critical path costs.
Many algorithms suggested convert sequential plans partially ordered
ones (Pednault, 1986; Regnier & Fade, 1991; Veloso, Perez, & Carbonell, 1990).
interpret totally ordered plan maximal constrained partial ordering =
{(Oi , Oj ) | 1 < j k} search less constrained plans. However, problem
minimum constraint deordering also proven NP-hard, unless so-called
validity check polynomial (Backstrom, 1998), deordering maintains validity
plan lessening constrainedness, i.e. 0 new ordering 0 .
Since explicit model dependency time, optimal parallel plans
change ordering relation all.
4.3 Critical Path Analysis
Project Evaluation Review Technique (PERT) critical path analysis algorithm
usually applied project management problems. critical path sequence activities
total time activities path greater equal
path operators. delay tasks critical path leads delay project.
heart PERT network tasks needed complete project, showing order
tasks need completed dependencies them.
shown Figure 10, PERT scheduling reduces variant Dijkstras shortest
path algorithm acyclic graphs (Cormen, Leiserson, & Rivest, 1990). matter fact,
algorithm returns length critical path inferred partially ordered
plan. However, obtaining temporal plan easy. algorithm, e(Oi ) tentative
earliest end time operator Oi , {1, . . . , k}, earliest starting times ti
operators optimal plan given ti = e(Oi ) d(Oi ).
Theorem 2 (PERT Scheduling) Given sequence operators O1 , . . . , Ok precedence ordering , optimal parallel plan = ((O1 , t1 ), . . . , (Ok , tk )) computed
optimal time O(k + | |).
Proof: proof induction {1, . . . , k}. induction hypothesis
iteration value e(Oi ) correct, e.g. e(Oi ) earliest end time operator
218

fiTaming Numbers Durations MIPS

Oi . clearly true = 1, since e(O1 ) = d(O1 ). assume hypothesis
true 1 j < look iteration i. two choices. Either j
{1, . . . , 1} Oj Oi . case inner loop completed, e(Oi )
set max{e(Oj ) + d(Oj ) | Oj Oi , j {1, . . . , 1}}. hand, e(Oi )
optimal, since Oi cannot start earlier max{e(Oj ) | Oj Oi , j {1, . . . , 1}}, since
values e(Oj ) already smallest possible induction hypothesis.
j {1, . . . , 1} Oj Oi , e(Oi ) = d(Oi ) base case. Therefore,
end, max1ik e(Oi ) optimal parallel path length.
time space complexity algorithm Critical-Path clearly O(k 2 ),
k length sequential plan. Using adjacency list representation
efforts reduced time space proportional number vertices edges
dependence graph, size O(k + | |). bound optimal, since
input consists (k) operators (| |) dependencies among them.
apply critical path scheduling, even consider temporal model Fox
Long, allowing overlapping operator execution dependent operators? answer
yes. already seen considering two dependent operators Oi Oj
Fox Long model, determine earliest start (and end) time Oj respect
fixed start time Oi . need. proof Theorem 2 shows
determine earliest end time operators sequentially.
4.4 Optimality MIPS
Since MIPS optimally schedules sequential plans, question remains, system
eventually find optimal plan? competition, system terminates
first sequential plan found. Since relaxed planning heuristic admissible,
A* variants cannot guarantee optimal (sequential parallel) plans. However, computing
optimal plans desirable, even due limited computational resources finding optimal
plans hard.
According temporal model, optimal parallel plan, operator either starts
ends start end time another operator. Therefore, least finite number
actions optimal plan, possibly exponential finite number possible
parallel plans.
immediately leads following naive plan enumeration algorithm: |O|i
operator sequences length i, IN, generate possible parallel plans, check
individual schedule transforms initial state one goals, take
sequence smallest parallel plan length. Since parallel plans computed, yields
complete optimal algorithm. seen example two persons lifting table,
approach expressive applying algorithm finds sequential
plans first. However, algorithm inefficient.
practice, natural assumption parallel plan corresponds least one
(possible many) sequential one(s). Conversely, partially ordered plan established
generating totally ordered plan first applying scheduling algorithm
find best partial-order.
algorithm Figure 11 indicates wrap forward chaining planner
any-time performance gradually improves plan quality. general state
219

fiEdelkamp

Procedure Any-Time
Input: Planning Problem hS, I, O, Gi
Output: Optimal parallel plan length

Open
(Open 6= )
Extract(Open)
0 expand(S)
(S 0 G)
cp Critical-Path (path(S 0 ), )
(cp < )
cp
else
Change(Open, 0 )
return
Figure 11: General any-time search algorithm.
expanding scheme maintains search horizon list Open. simplicity maintenance stored nodes list Closed shown. algorithm, current best
critical path cost bounds upcoming exploration process. turn updated
time plan found shorter critical path.
CriticalPath procedure above, algorithm returns execution time only,
established plan. compute plan meets returned value , also
store schedule generating sequence path(S 0 ) global record. cases,
storing 0 sufficient, since path PERT scheduling restored calling
procedure CriticalPath end procedure.
Assuming optimal parallel plan schedule sequential plan state
space finite, any-time extension cycle-avoiding enumeration strategy indeed
complete optimal. reason completeness finite graphs number
acyclic paths G finite every node expansion, algorithm adds new
links traversal tree. newly added link represents new acyclic path, that,
eventually, reservoir paths must exhausted.
also valid parallel plans cannot produced PERT scheduling
sequential plan? answer no. partial ordering algorithm terminates
optimal schedule, generate corresponding sequential plan preserving
dependency structure. Optimal PERT-scheduling plan respect set
operators imposed precedence relation yield optimal parallel plan.
sequential plans eventually generated, optimal parallel plan also found
PERT scheduling.
problem enumeration infinite state spaces infinite plateaus
plan objective function constant value. Normally increasing length
plan increases cost. However, true benchmark problems, since
220

fiTaming Numbers Durations MIPS

may infinite sequence events contribute plan objective.
example, loading unloading tanks pre-competition test domain DesertRats
affect total-fuel consumption, minimized one instances.
Enumeration schemes contradict known undecidability results numerical planning (Helmert, 2002). additional information like bound maximal
number actions plan number actions executed parallel,
cannot decide whether cycle-free enumeration terminate not. hand
solution, any-time algorithm eventually find it.
4.5 Pruning Anomalies
Acceleration techniques like duplicate detection sequential plan generation
chosen carefully maintain parallel plan length optimality. approach affect
parallel optimality, following example shows. ZenoTravel problem consider
sequences
(zoom city-a city-c plane), (board dan plane city-c),
(refuel plane city-c), (zoom city-c city-a plane),
(board scott plane city-a), (debark dan plane city-a), (refuel plane city-a),

(board scott plane city-a), (zoom city-a city-c plane),
(board dan plane city-c), (refuel plane city-c),
(zoom city-c city-a plane), (debark dan plane city-a), (refuel plane city-a)
two sets operators resulting (sequentially generated)
states. However, PERT schedule first sequence shorter schedule
second one, boarding scott done parallel final two actions
plan.
small problems, anomalies avoided omitting duplicate pruning.
example Figure 12 depicts sequential plan example problem instance
PERT schedule, turns overall optimal parallel plan. Another option
store resulting parallel plan state caching instead sequential one. Note
order ease generation sequential solutions large planning problem instances,
competition version MIPS used sequential state pruning.
4.6 Heuristic Search
main drawback blind path enumeration seemingly slow practical
planning. Heuristic search algorithms like A* IDA* reorder traversal states,
(assuming state caching) affect completeness optimality anytime wrapper. efficiency wrapper directly depends quality path
enumeration. competition version MIPS omitted any-time wrapping, since
optimal solutions required practical run-time behavior poor.
Instead used A* search engine, terminates first established solution.
question remains: still hope finding near optimal parallel plans? general
result also applicable infinite graphs established (Pearl, 1985): cost every
221

fiEdelkamp

0:
100:
130:
160:
200:
300:
320:
350:
390:
490:
530:
630:
650:

(zoom plane city-a city-c) [100]
(board dan plane city-c)
[30]
(board ernie plane city-c) [30]
(refuel plane city-c)
[40]
(zoom plane city-c city-a) [100]
(debark dan plane city-a)
[20]
(board scott plane city-a) [30]
(refuel plane city-a)
[40]
(zoom plane city-a city-c) [100]
(refuel plane city-c)
[40]
(zoom plane city-c city-d) [100]
(debark ernie plane city-d) [20]
(debark scott plane city-d) [20]

0: (zoom plane city-a city-c) [100]
100: (board dan plane city-c)
[30]
(board ernie plane city-c) [30]
100: (refuel plane city-c)
[40]
140: (zoom plane city-c city-a) [100]
240: (debark dan plane city-a)
[20]
(board scott plane city-a) [30]
(refuel plane city-a)
[40]
280: (zoom plane city-a city-c) [100]
380: (refuel plane city-c)
[40]
420: (zoom plane city-c city-d) [100]
520: (debark ernie plane city-d) [20]
(debark scott plane city-d) [20]

Figure 12: sequential plan Zeno-Travel (left) PERT schedule (right).

infinite path unbounded, A*s cost function f = g + h preserve optimality.
additional rationale choosing A*-like exploration MIPS instead hill climbing
best-first. breadth-first search, rising influence g-value crucial.
find adequate heuristic estimate parallel plans easy. fact
established competitive admissible heuristic, required optimal plan
finding A*. choice scheduling extension RPH. contrast RPH,
new heuristic takes relaxed sequence operators searches suitable parallel
arrangement, turn defines estimator function.
found adding PERT-schedules path state sequence
actions relaxed plan accurate PERT-schedule combined paths.
Therefore, classical merit function A*-like search engines f = g +h generating path
length g heuristic estimate h immediate correspondence parallel planning.
Consequently, define heuristic value scheduling RPH parallel plan length
combined path minus parallel plan length generating path.
4.7 Arbitrary Plan Objectives
PDDL 2.1 plan metrics minimizing total (parallel) execution time
specified. influences inferred solutions. Figure 13 depict two plans found
MIPS objective functions minimizing total-fuel-used, minimizing
compound (+ (* 10 (total-time)) (* 1 (total-fuel-used))).
first case computed optimal value 1,333.33, second case
established 7,666.67 optimized merit. optimizing time, ordering board
zoom actions important. optimizing total-fuel reduce speed save fuel
consumption 333.33 per flight may board first passenger immediately.
also save two refuel actions respect first case.
increasing importance time trade refueling actions time,
zooming flight actions chosen complex minimization criterion.
first attempt include arbitrary plan objectives alter PERT scheduling
process. However, results match ones produced validator (Long &
222

fiTaming Numbers Durations MIPS

0: (zoom plane city-a city-c) [100]
100: (board dan plane city-c)
[30]
(board ernie plane city-c) [30]
(refuel plane city-c)
[40]
140: (zoom plane city-c city-a) [100]
240: (debark dan plane city-a)
[20]
(board scott plane city-a) [30]
(refuel plane city-a)
[40]
280: (fly plane city-a city-c) [150]
430: (fly plane city-c city-d) [150]
580: (debark ernie plane city-d) [20]
(debark scott plane city-d) [20]

0: (board scott plane city-a) [30]
30: (fly plane city-a city-c) [150]
180: (board ernie plane city-c) [30]
(board dan plane city-c)
[30]
210: (fly plane city-c city-a) [150]
360: (debark dan plane city-a) [20]
(refuel plane city-a)
[53.33]
413.33: (fly plane city-a city-c) [150]
563.33: (fly plane city-c city-d) [150]
713.33: (debark ernie plane city-d)[20]
(debark scott plane city-d)[20]

Figure 13: Optimized plans Zeno-Travel according different plan objectives.
Fox, 2001), final time substituted objective function plan
built.
way MIPS evaluates objective functions time follows. First schedules
(relaxed final) sequential plan. Variable total-time temporarily substituted
critical path value objective formula evaluated. avoid conflicts subsequent
expansions, afterwards value total-time set back optimal one sequential
plan.

5. Object Symmetries
important feature parameterized predicates, functions action descriptions
domain specification file actions transparent different bindings parameters
objects. Disambiguating information present problem instance file.
case typed domains, many planners, including MIPS, compile type information additional predicates, attach additional preconditions actions enrich
initial states suitable object-to-type atoms.
consequence, symmetry viewed permutation objects present
current state, goal representation, transparent set operators.
n!, n = |OBJ |, possible permutations set objects. Taking
account type information reduces number possible permutation
n
t1 , 2 , . . . , k

!

=

n!
.
t1 !t2 ! . . . tk !

ti number objects type i, {1, . . . , k}. moderate sized logistic
domain 10 cities, 10 trucks, 5 airplanes, 15 packages, results 40!/(10! 10!
5! 15!) 1020 permutations.
reduce number potential symmetries tractable size restrict symmetries
object transpositions, n(n 1)/2 O(n2 ) candidates. Using
type information number reduces
k
X
ti
i=1

2

!

=

k
X

ti (ti 1)/2.

i=1

223

fiEdelkamp

following, set typed object transpositions denoted SYMM.
Logistics example, |SYMM| = 45 + 45 + 10 + 105 = 205.
5.1 Generating Object Symmetries Planning Problems
section compute subset SYMM includes object pairs
entire planning problem symmetric. start object transpositions smallest
entities planning problem.
Definition 12 (Object Transpositions Fluents, Variables, Operators) transposition objects (o, o0 ) SYMM applied fluent f = (p o1 , . . . , ok(p) ) F, written
f [o o0 ], defined (p o01 , . . . , o0k(p) ), o0i = oi oi
/ {o, o0 }, oi = o0 oi = o,
oi = oi = o0 , {1, . . . , k(p)}. Object transpositions [o o0 ] applied variable
v = (f o1 , . . . , ok(f ) ) V operator = (a o1 , . . . , ok(a) ) defined analogously.
example, ZenoTravel problem (at scott city-a)[scott dan] =
(at dan city-a).
Lemma 2 f F, v V, O, (o, o0 ) SYMM: f [o o0 ] = f [o0 o],
v[o o0 ] = v[o0 o], O[o o0 ] = O[o0 o], well f [o o0 ][o o0 ] = f ,
v[o o0 ][o o0 ] = v, O[o o0 ][o o0 ] = O.
brute-force time complexity computing f [o o0 ] F order O(k(p)),
k(p) number object parameters p. However, pre-computing O(|SYMM|
|F|) sized lookup table, containing index f 0 = f [o o0 ] (o, o0 ) SYMM,
time complexity reduced O(1).
Definition 13 (Object Transpositions States) Let mapping set
{1, . . . , |T |}. object transposition [o o0 ] applied state = (Sp , Sn )
Sn = (v1 , . . . , vk ), k = |V|, written S[o o0 ], equal (Sp [o o0 ], Sn [o o0 ])
Sp [o o0 ] = {f 0 F | f Sp f 0 = f [o o0 ]}
Sn [o o0 ] = (v10 , . . . , vk0 ) vi = vj0 1 (i)[o o0 ] = 1 (j) i, j {1, . . . , k}.
initial state example problem I[dan ernie] = I. definition
variables slightly difficult predicates, since, case, variable
contents, availability, must match.
time complexity compute Sn [o o0 ] O(k), since testing 1 (i)[o o0 ] =
1 (j) available time O(1) building another O(|SYMM| |V|) sized pre-computed
look-up table. Note times worst-case. terminate computation
object symmetry fluent variable contradictory. summarize complexity
results follows.
Lemma 3 worst-case time complexity compute S[o o0 ] state = (Sp , Sn )
(o, o0 ) SYMM O(|Sp | + |V|) using O(|SYMM| (|F| + |V|)) space.
next step lift concept object transposition planning problems.
224

fiTaming Numbers Durations MIPS

Definition 14 (Object Transpositions Domains) planning problem P = hS, O, I, Gi
symmetric respect object transposition [o o0 ], abbreviated P[o o0 ],
I[o o0 ] = G G: G[o o0 ] G.
Since goal descriptions partial, prefer writing G[o o0 ] G instead G G:
G[o o0 ] G. Moreover, assume goal description complexity G bounded
O(|Gp | + |V|).
ZenoTravel problem, goal descriptor purely propositional, containing three
facts target location dan, ernie, scott. initial state running
example planning problem contains object symmetry, since I[scott ernie] 6=
G[dan ernie] 6= G.
Applying Lemma 3 (o, o0 ) SYMM yields time complexity needed establish object symmetries.
Theorem 3 (Time Complexity Object Symmetry Detection) worst-case run-time
determine set object transpositions planning problem P = hS, O, I, Gi
symmetric O(|SYMM| (|Gp | + |Ip | + |V|)).
5.2 Including Goal Symmetry Conditions
Symmetries present initial state may vanish reappear exploration
forward chaining planner like MIPS. DesertRats domain, example, initial set
supply tanks indistinguishable one loaded truck.
fuel levels supply tanks decrease tanks transported another location,
previously existing symmetries broken. However, two tanks one location become
empty, considered symmetric.
Goal conditions, however, change time, initial state transforms
current state C. Therefore, pre-compiling phase refine set SYMM
SYMM0 (o, o0 ) SYMM | G[o o0 ] = G .




Usually, |SYMM0 | much smaller |SYMM|. ZenoTravel problem instance,
object symmetry left SYMM0 transposition scott ernie.
Therefore, efficiently compute set
SYMM00 (C) {(o, o0 ) SYMM0 | C[o o0 ] = C}
symmetries present current state. initial state example
problem Zeno-Travel SYMM00 (I) = , scott ernie share
location state C object pair would included SYMM00 (C).
definition requires C[o o0 ] = C. include symmetric paths
different states. Let C = {(at ernie city-c), (at scott city-d)}. possible
symmetric plan {(at ernie city-d), (at scott city-c)} common
goal. Viewed differently, complex object symmetries form [o1 o01 ][o2 o02 ]
detected. example observe C[scott ernie][city-c city-d] = C.
respect Theorem 3 additional restriction reduces time complexity
detect remaining object symmetries O(|SYMM0 | (|Cp | + |V|)).
225

fiEdelkamp

5.3 Pruning Operators
planning problem current state C symmetric respect operator
transposition [o o0 ] either application operator application
operator O[o o0 ] neglected, significantly reducing branching factor. Lemma 4
indicates symmetry used reduce exploration.
Lemma 4 operator applicable = S[o o0 ] O[o o0 ] applicable

O(S)[o o0 ] = O[o o0 ](S).
Proof: applicable O[o o0 ] applicable S[o o0 ]. Since =
S[o o0 ], O[o o0 ] applicable S,
O[o o0 ](S) = O[o o0 ](S[o o0 ]) = O(S)[o o0 ].

pre-computing O(|SYMM| |O|) sized table index (O0 ) operator O0 =
O[o o0 ] determined time O(1) (o, o0 ) SYMM0 .
Definition 15 (Pruning Set) Let index mapping set {1, . . . , |T |} let
(C) set operators applicable state C S. pruning set (C) (C)
defined set operators symmetric counterpart
minimal index. symmetry reduction 0 (C) (C) defined (C) \ (C).
Theorem 4 (Correctness Operator Pruning) Reducing operator set (C) 0 (C)
exploration planning problem P = hS, O, I, Gi preserves completeness7 .
Proof: Suppose expanded state C, reducing operator set (C) 0 (C)
exploration planning problem P = hS, O, I, Gi preserve completeness.
Furthermore, let C state property maximal exploration order.
sequential plan = (O1 . . . , Ok ) PC = hS, O, C, Gi associated
state sequence (S0 = C, . . . , Sk G). Obviously, Oi (Si1 ), {1, . . . , k}.
choice C O1 (S0 ) \ 0 (S0 ) = (S0 ). definition pruning set
(S0 ) exists O10 = O1 [o o0 ] minimal index applicable S0 .
Since PC = hS, O, C, Gi = PC [o o0 ] = hS, O, C[o o0 ] = C, G[o o0 ] = Gi ,
sequential plan O1 [o o0 ], . . . , Ok [o o0 ] state sequence (S0 [o o0 ] = S0 , S1 [o
o0 ], . . . , Sk [o o0 ] = Sk ) reaches goal G. contradicts assumption
reducing operator set (C) 0 (C) preserve completeness C.
Since plan objective refers instantiated predicates objects, similar
initial goal state, symmetry breaking. order preserve optimality, one
additionally check, see object exchange influence plan objective.
practice, objective functions often based non-parameterized predicates,
case optimal planning algorithm affected symmetry cuts.
7. Generally completeness means planner find legal plan. intended here.
use completeness terms discarding legal plans favor equally good symmetric plans.

226

fiTaming Numbers Durations MIPS

5.4 Symmetry Reduction MIPS
main purpose restricted implementation MIPS reduce run
time object symmetry detection losing effectiveness. Especially
impact quantity O(|SYMM0 | |Cp |) running time considerable.
key observation symmetries also present fact groups according
group representatives. shown Figure 5, fact group dan consists facts
(at dan city-a), (at dan city-b), (at dan city-c), (at dan city-d), (in dan
plane). Similarily, ernies group facts (at ernie city-a), (at ernie city-b), (at
ernie city-c), (at ernie city-d), (in ernie plane). ordering facts
groups chosen way that, except change group representative,
corresponding facts match. Together facts groups, operators change
facts groups, stored efficient dictionary.
Therefore, restrict object transpositions group representatives. reduces
set objects OBJ MIPS considers considerably smaller subset OBJ 0 .
example problem |OBJ | = 7, |OBJ 0 | = 4. Many objects, e.g. objects
type city ZenoTravel, selected representatives single attribute invariance
build group.
idea obtain possible transposition fact group representatives, followed
looking respective fact positions current goal state. may happen,
one group fixed representative OBJ 0 . case, link groups
representative common. symmetry detection test group chains
objects matching current goal position.
above, symmetries based non-matching goal predicates excluded beforehand. Let RSYMM number remaining symmetries object representatives.
Assume one representative per group yields running time propositional object
symmetry detection state C O(RSYMM + |Cp |). remaining comparisons variables v V implemented described previous section, performed
object pairs pass propositional check.
pruning operators, MIPS marks groups correspond object symmetry
larger index visited. guarantees operator least one
group executed. expanded state matching operator (S)
algorithm checks, whether applied operator present visited group, case
pruned. time complexity O(|(S)|), since operator group containment
preprocessed checked constant time.
Figure 14 shows effectiveness symmetry reduction planner MIPS DesertRats domain, scales respect total distance d, {300, 400, 500, 600},
passed (x-axis). direction, number expanded states A*
search MIPS object symmetry reduction (right bars) without symmetry reduction (left bars) shown logarithmic scale. expected, larger problems symmetry
reduction yields performance gains one order magnitude (d = 500). also
yields solutions problems algorithms without symmetry reduction fail due
memory restrictions (d = 600)8 .
8. memory bound used example set 1/2 GByte.

227

fiEdelkamp

Figure 14: Results symmetry pruning Desert Rats. Bars show number states
expanded without/with symmetry detection.

6. Related Work
STRIPS problems tackled different planning techniques, notably
SAT-planning (Kautz & Selman, 1996), IP-planning (Kautz & Walser, 1999), CSPplanning (Rintanen & Jungholt, 1999), graph relaxation (Blum & Furst, 1995), heuristic
search planning (Bonet & Geffner, 2001).
Solving planning problems numerical preconditions effects allowed Level 2
Level 3 problems undecidable general (Helmert, 2002). However, structures
provided benchmark problems simpler general problem class,
problems fact solvable.
6.1 Temporal Planning Approaches
system Metric-FF (Hoffmann, 2002a) extends FF (Hoffmann & Nebel, 2001)
forward chaining heuristic state space planner Level 2 problems. Although, MIPS plan
generator shares several ideas Metric-FF, Hoffmanns system yet extended
deal temporal domains.
Planner TP4 (Haslum & Geffner, 2001) fact scheduling system based grounded
problem instances. cases formula trees numerical conditions assignments
reduce constants. Utilizing admissible heuristics, TP4 minimizes plan objective
optimal parallel plan length. planner distinctive advantages: handles
numerical preconditions, instantiates numerical conditions fly cope
complex objective functions. Besides input restriction, competition, TP4
somewhat limited focus producing optimal solutions.
SAPA system (Do & Kambhampati, 2001) domain-independent time resource planner cope metrics concurrent actions. SAPAs general expressivity judged close MIPS. adapts forward chaining algorithm
(Bacchus & Ady, 2001). planning approaches instantiate actions fly
228

fiTaming Numbers Durations MIPS

therefore, principle, adapted handle flexible mixed propositional numerical planning problems. search algorithm SAPA extends partial concurrent plans
instead parallelizing sequential plans. uses relaxed temporal planning graph
yet unplanned events different heuristic evaluation functions. additional feature,
SAPA provides option specifying deadlines.
planner LPG (Gerevini & Serina, 2002) based local search planning graphs.
uses variant FF planner grounding initial plans generated random walk. subsequent search space LPG consists so-called action graphs (Gerevini
& Serina, 1999). temporal module performs action graph modifications transforming
action graph another one. fast plan generation algorithm LPG seems
best explanation speed advantage LPG respect MIPS,
higher number problems LPG solved domains. Optimization LPG governed
Lagrange multipliers. temporal domains, actions ordered using precedence graph
maintained search, uses refined dependency relation ours.
may partly explain plan quality fact consistently better MIPS.
IxTeT (Laborie & Ghallab, 1995) general constraint-based planning system
input format. planner searches space partial plans allows general
resource temporal constraints posed. internal representation consists
chronicles, time linearly ordered discrete set instants, multi-valued state
variables either rigid flexible (contingent, controllable, resources), predicates
temporally qualified expressions (events, assertions, resources), temporal atemporal
constraints. clear compare expressivity chronicles PDDL2.1
constructs. makes difficult link different temporal models determine
technique critical path scheduling applicable IxTeT not. opinion
unlikely, since IxTeT partial-order. Note IxTeT allows conjunction
predicates, subtasks, constraints conditional expressions, available
PDDL2.1. analysis partial plans drives planning process divided
three different modules: feasibility, satisfiability resource conflict resolution.
competition domains IxTeT able compete local search heuristic search
planners.
HSTS (Muscettola, 1994) constraint-based planning system based temporal activity networks, written LISP CRL. NASA used many projects
like Deep-Space One. already represent reason metric resources, parallel
activities, general constraints. IxTeT input format significantly different
PDDL2.1. HSTS yet adapted represent reason conditional
branches. However experiences HSTS planner showed partial-order planning
attractive metric/temporal problems, need better search control.
Although PDDL2.1 guidelines fact allow infinite branching, 2002 competition consisted finite branching problems. indicated earlier, paper
also concentrates finite branching problems. finite branching, execution time
action fixed, infinite branching, continous range actions available.
problems confronted (real-time) model checking long time.
subclasses infinite branching problems like timed automata exhibit finite partitioning symbolic representation states (Pettersson, 1999). technique
shortest-path reduction unique reduced normal form obtained.
229

fiEdelkamp

implemented temporal network structure, since main data structure
exploring timed automata done model checker Uppaal (Pettersson, 1999).
work, constraints must form xi xj c xi c. example,
set constraints x4 x0 1, x3 x1 2, x0 x1 1, x5 x2 8, x1 x2 2,
x4 x3 3, x0 x3 4, x1 x4 7, x2 x5 10, x1 x5 5 shortest-path
reduction x4 x0 1, x3 x1 2, x5 x2 8, x0 x3 4, x1 x4 7, x2 x5 10,
x1 x5 5. constraint set over-constrained, algorithm determine
unsolvability, otherwise feasible solution returned.
Critical path analysis timed precedence networks one simpler cases
scheduling. achieved simplification solving sequential path problem first.
Note many scheduling techniques apply presented critical path analysis
subcomponent (Syslo, Deo, & Kowalik, 1983).
6.2 Symmetry Detection Planning Model Checkers
previous results symmetry reduction planning, e.g. (Guere & Alami, 2001),
neglect combinatorial explosion possible symmetries least assume
information existing symmetries domain supplied user.
contrast, work shares similarities approach Fox & Long (1999,2002)
inferring object symmetry information fully automatically. Fox Longs work based
similarities established TIM inference module (Fox & Long, 1998). search
additional information current symmetry level form object transposition
matrix stored updated together state. approach different sense
efficiently computes object symmetries state scratch consumes
extra space per node expansion.
Model checking research long tradition symmetry reduction (Clarke et al., 1999).
recent work, Rintanen (2003) connects symmetry detection planning model checking
approaches transition systems SAT solving. Experiments provided SAT
encodings Gripper domain; prototypical example symmetry detection. (LluchLafuente, 2003), model checker HSF-Spin extended effectively combine heuristic
search symmetry detection. also reflects fact (HSF-)Spins exploration
modelled using (labelled) transition systems. Positive empirical results given
non-trivial examples like Petersons mutual exclusion algorithm Database Manager
protocol.
briefly review fundamental difference object symmetries (as considered
here) state space symmetries (as considered model checking).
latter approach constructs quotient state space problem (P/) based congruence relation, equivalence relation called congruence
s1 , s2 , s1 s1 s2 operator O(s1 ) = s01 s02
s01 s02 operator O0 O0 (s2 ) = s02 . [O][s] = [s0 ]
operator mapping s0 [s] s0 [s0 ].
bijection : said symmetry (I) = I, (G) G G G
s, s0 transition s0 exist transition (s)
(s0 ). set symmetries generates subgroup g(A) called symmetry group.
subgroup g(A) induces equivalence relation states, defined s0
230

fiTaming Numbers Durations MIPS

(s) = s0 g(A). equivalence relation called symmetry relation
P induced A. equivalence class called orbit s, denoted [s]A .
symmetry relation P congruence P. Moreover, reachable [s]A
reachable [I]A . reduces search goal G G finding state [G].
explore state space respect state (space) symmetry, function Canonicalize needed. time new successor node generated, determines representative
element equivalence class. Fixing canonical element trivial, many
systems approximate normal form. Automatically finding symmetries setting
also difficult cast computationally hard graph isomorphism problem.
Therefore approaches expect information kind symmetry present
state space graph. One example rotational symmetry, defined right shift
variables state vector.
6.3 Model Checking Planners
2000 competition, two symbolic planners took part: PropPlan (Fourman,
2000), BDDPlan (Holldobler & Stor, 2000). Although receive awards
performance, show interesting properties. PropPlan performs symbolic forward
breadth first search explore propositional planning problems propositions generalized action preconditions generalized action effects. performed well full
ADL Miconic-10 elevator domain (Koehler, 2000). ProbPlan written Poly/ML
implementation SML. BDD-Plan based solving entailment problem fluent calculus BDDs. time authors acknowledged concise domain
encoding symbolic heuristic search used MIPS improvements.
Model-Based Planner MBP paradigm planning symbolic model checking (Giunchiglia & Traverso, 1999) implemented non-deterministic planning
domains (Cimatti et al., 1998), classified weak, strong, strong-cyclic
planning, plans represented state-action tables. partially observable
planning, system faced exploring space belief states; power set
original planning space. Therefore, contrast successor set generation based action application, observations introduce nodes search tree (Bertoli, Cimatti,
Roveri, & Traverso, 2001b). Since approach hybrid symbolic representation
belief states explicit search within And-Or search tree, simple heuristics
applied guide search. need heuristics trade information gain
exploration effort also apparent conformant planning (Bertoli et al., 2001a). Recent
work (Bertoli & Cimatti, 2002) proposes improved heuristics belief space planning.
UMOP system parses non-deterministic agent domain language explicitly
defines controllable system uncontrollable environment (Jensen & Veloso, 2000).
planner also applies BDD refinement techniques automated transition function
partitioning. New results UMOP system extend weak, strong strong cyclic
planning adversarial planning, environment actively influences outcome
actions. fact, proposed algorithm combines aspects symbolic search
game playing. UMOP yet participated planning competition.
recent developments symbolic exploration expected influence automated
planning near future. SetA*, (Jensen et al., 2002) provide improved imple231

fiEdelkamp

mentation symbolic heuristic search algorithm BDDA* (Edelkamp & Reffel, 1998)
Weighted BDDA* (Edelkamp, 2001a). One improvement SetA* maintains finer
grained sets states search horizon. kept matrix according matching g- h- values. contrasts plain bucket representation priority
queue based f -values. heuristic function implicitly encoded value differences
grounded actions. Since sets states evaluated heuristics state
rather operator dependent remains shown general approach is.
above, planning benchmarks considered seemingly simple single-state heuristic search exploration (Hoffmann, 2002b; Helmert, 2001). (Hansen, Zhou, & Feng, 2002)
also re-implemented BDDA* suggest symbolic search heuristics exploration
algorithms probably better implemented algebraic decision diagrams (ADDs). Although authors achieved improvement (Edelkamp & Reffel, 1998) solving
(n2 1)-Puzzle, established generalization guide symbolic version LAO* exploration algorithm (Hansen & Zilberstein, 2001) probabilistic (MDP) planning results
remarkable improvement state-of-the-art (Feng & Hansen, 2002).

7. Conclusions
competition planning system MIPS, contributed flexible system
heuristic forward chaining, explicit symbolic search planner finds plans finitebranching numerical problems. planner parses, pre-compiles, solves, schedules
problem instances, including complex ones duration, resource variables different
objective functions. main contributions planner
object-oriented workbench architecture choose combine different heuristics different search algorithms storage structures. design includes
static analyzer applies efficient fact-space exploration distinguish constant
fluent quantities, clusters facts groups, infers static object
symmetries. static analyzer produces intermediate format grounded
simplified planning domain instances.
Optimal temporal planning enumeration algorithms, based precedence relation
PERT scheduling sequentially generated plans together concise analysis
correctness optimality, well integration PERT scheduling MIPS
computing refined heuristic estimate. guides search phase, favoring
states smaller parallel plan length. MIPS instantiates numerical pre- postconditions on-the-fly produces optimized parallel plans.
detection dynamic object symmetries, integration different pruning
methods hash transposition cuts, well different strategies optimizing objective functions implementation tricks made system
efficient.
paper analyzes theoretical properties contributions, sometimes slightly
abstracting actual implementation.
Essentially planning numerical quantities durative actions planning
resources time. given framework mixed propositional numerical planning
232

fiTaming Numbers Durations MIPS

problems presented intermediate format seen normal form temporal
metric planning. paper presents novel temporal planning scheme generates
sequential (totally ordered) plans efficiently schedules respect set
actions imposed causal structure, without falling known NP-hardness traps
optimized partial-ordering sequentially generated plans. smaller problems complete enumeration approach guarantees optimal solutions. improve solution quality
approximate enumeration, (numerical) estimate number operators replaced
scheduling relaxed plan state. addressed completeness optimality
different forms exploration. novel study time space complexity dynamic
object symmetry detection given.
Model checking always influenced development MIPS, e.g static analysis minimize state description length, symbolic exploration plan extraction,
dependence relation PERT schedules according given partial order, bit-state
hashing IDA*, importance symmetry detection, forth. Moreover,
successes planning MIPS exported back model checking, development heuristic search state model checkers parsing Promela protocol specifications
indicate.

Acknowledgments
author would like thank Derek Long Maria Fox helpful discussions concerning
paper Malte Helmert cooperation second planning competition.
list editors anonymous reviewers comments helped lot improve text.
work supported Deutsche Forschungsgemeinschaft (DFG) projects
Heuristic Search (Ed 74/3) Directed Model Checking (Ed 74/2).

References
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaning
approach. Proceedings IJCAI-01, pp. 417424.
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116, 123191.
Backstrom, C. (1998). Computational aspects reordering plans. Journal Artificial
Intelligence Research, 9, 99137.
Bertoli, P., & Cimatti, A. (2002). Improving heuristics planning search belief space.
Proceedings AIPS-02, pp. 143152.
Bertoli, P., Cimatti, A., & Roveri, M. (2001a). Heuristic search symbolic model checking =
efficient conformant planning. Proceedings IJCAI-01, pp. 467472.
Bertoli, P., Cimatti, A., Roveri, M., & Traverso, P. (2001b). Planning nondeterministic
domains partial observability via symbolic model checking. Proceedings
IJCAI-01, pp. 473478.
Biere, A. (1997). cke - efficient -calculus model checking. Proceedings CAV-97, pp.
468471.
233

fiEdelkamp

Bloem, R., Ravi, K., & Somenzi, F. (2000). Symbolic guided search CTL model checking.
Proceedings DAC-00, pp. 2934.
Blum, A., & Furst, M. L. (1995). Fast planning planning graph analysis.
Proceedings IJCAI-95, pp. 16361642.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (12), 533.
Bryant, R. E. (1992). Symbolic boolean manipulation ordered binary-decision diagrams. ACM Computing Surveys, 24 (3), 142170.
Cimatti, A., Giunchiglia, E., Giunchiglia, F., & Traverso, P. (1997). Planning via model
checking: decision procedure AR. Proceedings ECP-97, pp. 130142.
Cimatti, A., Roveri, M., & Traverso, P. (1998). Automatic OBDD-based generation
universal plans non-deterministic domains. Proceedings AAAI-98, pp. 875
881.
Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model Checking. MIT Press.
Clarke, E. M., McMillan, K. L., Dill, D. L., & Hwang, L. J. (1992). Symbolic model checking:
1020 states beyond. Information Computation, 98 (2), 142170.
Cormen, T. H., Leiserson, C. E., & Rivest, R. L. (1990). Introduction Algorithms.
MIT Press.
Dial, R. B. (1969). Shortest-path forest topological ordering. Communication
ACM, 12 (11), 632633.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Proceedings ECP-01, pp. 109120.
Edelkamp, S. (1999). Datenstrukturen und Lernverfahren der Zustandsraumsuche. Ph.D.
thesis, University Freiburg. DISKI, Infix.
Edelkamp, S. (2001a). Directed symbolic exploration application AI-planning.
Proceedings AAAI-01 Spring Symposium Model-based Validation Intelligence,
pp. 8492.
Edelkamp, S. (2001b). First solutions PDDL+ planning problems. Proceedings
PlanSIG-01, pp. 7588.
Edelkamp, S. (2001c). Planning pattern databases. Proceedings ECP-01, pp.
1324.
Edelkamp, S. (2002a). Mixed propositional numerical planning model checking integrated planning system. Proceeding AIPS-02 Workshop Temporal
Planning, pp. 4755.
Edelkamp, S. (2002b). Symbolic pattern databases heuristic search planning. Proceedings AIPS-02, pp. 274283.
Edelkamp, S. (2003). Promela planning. Proceedings SPIN-03, pp. 197212.
Edelkamp, S., & Helmert, M. (1999). Exhibiting knowledge planning problems minimize state encoding length. Proceeding ECP-99, pp. 135147.
234

fiTaming Numbers Durations MIPS

Edelkamp, S., & Helmert, M. (2000). implementation MIPS. Proceedings
AIPS-00 Workshop Model Theoretic Approaches Planning, pp. 1825.
Edelkamp, S., & Helmert, M. (2001). model checking integrated planning system MIPS.
AI-Magazine, 6771.
Edelkamp, S., Leue, S., & Lluch-Lafuente, A. (2003). Directed explicit-state model checking
validation communication protocols. International Journal Software Tools
Technology (STTT), appear.
Edelkamp, S., & Meyer, U. (2001). Theory practice time-space trade-offs memory
limited search. Proceedings KI-01, Lecture Notes Computer Science, pp.
169184. Springer.
Edelkamp, S., & Reffel, F. (1998). OBDDs heuristic search. Proceedings KI-98, pp.
8192.
Edelkamp, S., & Reffel, F. (1999a). Deterministic state space planning BDDs.
Proceedings ECP-99, Preprint, pp. 381382.
Edelkamp, S., & Reffel, F. (1999b). Deterministic state space planning BDDs. Tech.
rep. 121, University Freiburg.
Edelkamp, S., & Stiegeler, P. (2002). Implementing HEAPSORT n log n 0.9n
QUICKSORT n log n + 0.2n comparisons. ACM Journal Experimental Algorithms, 7 (5).
Feng, Z., & Hansen, E. (2002). Symbolic heuristic search factored markov decision
processes. Proceedings AAAI-02.
Fikes, R., & Nilsson, N. (1971). Strips: new approach application theorem
proving problem solving. Artificial Intelligence, 2, 189208.
Fourman, M. P. (2000). Propositional planning. Proceedings AIPS-00 Workshop
Model-Theoretic Approaches Planning, pp. 1017.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificial Intelligence Research, 9, 367421.
Fox, M., & Long, D. (1999). detection exploration symmetry planning
problems. Proceedings IJCAI-99, pp. 956961.
Fox, M., & Long, D. (2002). Extending exploitation symmetries planning.
Proceedings AIPS-02.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. Journal Artificial Intelligence Research, issue.
Gerevini, A., & Serina, I. (1999). Fast planning greedy action graphs. Proceedings
AAAI-00.
Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphs
action costs. Proceedings AIPS-02.
Giunchiglia, F., & Traverso, P. (1999). Planning model checking. Proceedings
ECP-99, pp. 119.
235

fiEdelkamp

Groce, A., & Visser, W. (2002). Model checking Java programs using structural heuristics.
Proceedings ISSTA-02.
Guere, E., & Alami, R. (2001). One action enough plan. Proceedings IJCAI-01.
Hansen, E., & Zilberstein, S. (2001). LAO*: heuristic search algorithm finds solutions
loops. Artificial Intelligence, 129, 3562.
Hansen, E. A., Zhou, R., & Feng, Z. (2002). Symbolic heuristic search using decision
diagrams. Proceedings SARA-02.
Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). formal basis heuristic determination
minimum path cost. IEEE Transactions Systems Science Cybernetics,
4, 100107.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP-01, pp. 121132.
Helmert, M. (2001). complexity planning transportation domains. Proceedings ECP-01, pp. 349360.
Helmert, M. (2002). Decidability undecidability results planning numerical
state variables. Proceedings AIPS-02, pp. 4453.
Hipke, C. A. (2000). Verteilte Visualisierung von Geometrischen Algorithmen. Ph.D. thesis,
University Freiburg.
Hoffmann, J. (2000). heuristic domain independent planning use enforced
hill climbing algorithm. Proceedings ISMIS-00, pp. 216227.
Hoffmann, J. (2002a). Extending FF numerical state variables. Proceedings ECAI02.
Hoffmann, J. (2002b). Local search topology planning benchmarks: theoretical analysis.
Proceedings AIPS-02, pp. 92100.
Hoffmann, J., & Nebel, B. (2001). Fast plan generation heuristic search. Journal
Artificial Intelligence Research, 14, 253302.
Holldobler, S., & Stor, H.-P. (2000). Solving entailment problem fluent calculus using binary decision diagrams. Proceedings AIPS-00 Workshop ModelTheoretic Approaches Planning, pp. 3239.
Jensen, R. M., Bryant, R. E., & Veloso, M. M. (2002). SetA*: efficient BDD-based
heuristic search algorithm. Proceedings AAAI-02.
Jensen, R., & Veloso, M. M. (2000). OBDD-based universal planning synchronized
agents non-deterministic domains. Journal Artificial Intelligence Research, 13,
189226.
Kabanza, F., Barbeau, M., & St-Denis, R. (1997). Planning control rules reactive agents.
Artificial Intelligence, 95 (1), 67113.
Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings AAAI-96, pp. 11941201.
Kautz, H., & Walser, J. (1999). State-space planning integer optimization. Proceedings
AAAI-99.
236

fiTaming Numbers Durations MIPS

Knoblock, C. (1994). Generating parallel execution plans partial order planner.
Proceedings AIPS-94, pp. 98103.
Koehler, J. (2000). Elevator control planning problem. Proceedings AIPS-00, pp.
331338.
Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Artificial Intelligence Research,
12, 338386.
Koehler, J., Nebel, B., & Dimopoulos, Y. (1997). Extending planning graphs ADL
subset. Proceedings ECP-97, pp. 273285.
Korf, R. E. (1985). Depth-first iterative-deepening: optimal admissible tree search.
Artificial Intelligence, 27 (1), 97109.
Korf, R. E., & Zhang, W. (2000). Divide-and-conquer frontier search applied optimal
sequence alignment. Proceedings AAAI-00, pp. 910916.
Laborie, P., & Ghallab, M. (1995). Planning sharable resources constraints. Proceedings IJCAI-95, pp. 16431649.
Lago, U. D., Pistore, M., & Traverso, P. (2002). Planning language extended
goals. Proceedings AAAI-02.
Lind-Nielsen, J. (1999). Buddy: Binary decision diagram package, release 1.7. Technical
Univeristy Denmark. Available jln@itu.dk.
Lluch-Lafuente, A. (2003). Symmetry reduction heuristic search error detection
model checking. Proceedings Workshop Model Checking Artificial
Intelligence (MoChart).
Long, D., & Fox, M. (1998). Efficient implementation plan graph STAN. Journal
Artificial Intelligence Research, 10, 87115.
Long, D., & Fox, M. (2001). Encoding temporal planning domains validating temporal plans. Workshop UK Planning Scheduling Special Interest Group
(PlanSIG).
McDermott, D. (2000). 1998 AI Planning Competition. AI Magazine, 21 (2).
McMillan, K. L. (1993). Symbolic Model Checking. Kluwer Academic Press.
Muscettola, N. (1994). HSTS: integrating planning scheduling. Zweben, M., & Fox,
M. S. (Eds.), Intelligent Scheduling, pp. 168212. Morgan Kaufmann.
Pearl, J. (1985). Heuristics. Addison-Wesley.
Pednault, E. (1986). Formulating multiagend, dynamic-world problems classical
framework. Reasoning Action Plans, pp. 4782. Morgan Kaufmann.
Pednault, E. (1989). ADL: Exploring middleground Strips situation calculus. Proceedings KR-89, pp. 324332. Morgan Kaufman.
Pettersson, P. (1999). Modelling Verification Real-Time Systems Using Timed Automata: Theory Practice. Ph.D. thesis, Department Computer Systems, Uppsala University.
237

fiEdelkamp

Pistore, M., & Traverso, P. (2001). Planning model checking extended goals nondeterministic domains. Proceedings IJCAI-01.
Pohl, I. (1977). Practical theoretical considerations heuristic search algorithms.
Machine Intelligence, 8, 5572.
Refanidis, I., & Vlahavas, I. (2000). Heuristic planning ressources. Proceedings
ECAI-00, pp. 521525.
Reffel, F., & Edelkamp, S. (1999). Error detection directed symbolic model checking.
Proceedings FM-99, pp. 195211.
Regnier, P., & Fade, B. (1991). Determination du parallelisme maximal et optimisation
temporelle dans les plans dactions lineaires. Revue dIntelligence Artificielle, 5 (2),
6788.
Reinefeld, A., & Marsland, T. (1994). Enhanced iterative-deepening search. IEEE Transactions Pattern Analysis Machine Intelligence, 16 (7), 701710.
Rintanen, J. (2003). Symmetry reduction SAT representations transition systems.
Proceedings ICAPS-03.
Rintanen, J., & Jungholt, H. (1999). Numeric state variables constraint-based planning.
Proceedings ECP-99, pp. 109121.
Ruys, T. C. (2003). Optimal scheduling using branch bound SPIN 4.0. Proceedings SPIN-03, pp. 117.
Syslo, M. M., Deo, N., & Kowalik, J. S. (1983). Discrete Optimization Algorithms
Pascal Programs. Prentice-Hall.
Veloso, M. M., Perez, M. A., & Carbonell, J. G. (1990). Nonlinear planning parallel
resource allocation. Innovative Approaches Planning, Scheduling Control,
pp. 207212.
Weismuller, M. (1998). Planen mit einem Modellprufer im -Kalkul . Masters thesis,
Universitat Ulm.
Yang, C. H., & Dill, D. L. (1998). Validation guided search state space.
Proceedings DAC-98, pp. 599604.
Yoshizumi, T., Miura, T., & Ishida, T. (2000). A* partial expansion large branching
factor problems. Proceedings AAAI-00, pp. 923929.
Zhou, R., & Hansen, E. (2003). Sparse-memory graph search. Proceedings IJCAI-03.

238

fiJournal Artificial Intelligence Research 20 (2003) 125132

Submitted 09/03; published 12/03

Commentary
Power Modelinga Response pddl2.1
Fahiem Bacchus

fbacchus@cs.toronto.edu

Department. Computer Science
6 Kings College Road
University Toronto
Toronto, Ontario
Canada, M5S 3H5.

Abstract
commentary argue although pddl2.1 useful standard
planning competition, design properly consider issue domain modeling.
Hence, would advocate use specifying planning domains outside context
planning competition. Rather, field needs explore different approaches
grapple directly problem effectively modeling utilizing
diverse pieces knowledge typically planning domains.

1. Introduction
Fox Long terrific job organizing 2002 Planning Competition. non-trivial
component work specifying extension pddl much interesting
range problems could addressed competition. Although extension represents
useful standard competition, design ignores power reality
domain modeling. argue new features pddl2.1 unnecessary:
similar effects easily captured robust modeling planning
domain.
Tlplan planning system competed 2002 planning competition. Despite
fact Tlplans specification language direct support features
pddl2.1, still able encode competition domains. Tlplan utilizes
language designed suitable robustly modeling planning domains.1
found many new features pddl2.1 used competition fact easy
capture simply robust modeling planning domain.
pddl2.1 takes approach adding new features language, rather
requiring domain robustly modeled, perhaps surprising given
dichotomy still persists AI planning field. dichotomy work
domain-independent planning control-intensive planning. work controlintensive planning tends ignore applicability power state-of-the-art search
algorithms planning, work domain-independent planning tends ignore power
gained, requirements imposed, domain modeling. planning researchers
freely acknowledge importance components, however, one rarely finds work
1. Tlplan also includes constructs expressing domain specific control information, referring
component language.

c
2003
AI Access Foundation. rights reserved.

fiBacchus

(:durative-action load-truck
:parameters (?t - truck)
(?l - location)
(?o - cargo)
(?c - crane)
:duration (= ?duration 5)
:precondition (and (at ?t ?l)
(at ?o ?l)
(empty ?c))
:effect
(and (loading ?t)
(at end (not loading ?t))
...
)
(:action move-truck
:parameters (?t - truck)
...
:precondition (and (not (loading ?t))
...)
)

Figure 1: Converting (over all) conditions
interface two issues, many researchers work
issues.2
rest commentary elaborate argument presenting examples
features approaches appearing pddl2.1 demonstrate insensitivity domain
modeling.

2. Coordinating Concurrent Actions
Section 5 pddl2.1 document various constructs presented support durative
actions. actions whose effects either immediate (like ordinary non-durative
actions) occur end fixed duration. duration either
constant specified functional term. obvious extension, used, e.g., Bacchus
& Ady (2001), action could range effects different future
timepoint, included pddl2.1.3 Without extension (at start) (at
end) specifiers reasonable ways specifying delayed effects.
non-instantaneous actions concurrency control becomes issue. achieve
kind control pddl2.1 provides :condition constructs (at start), (at end),
(over all). Tlplan provide (at end) (over all) constructs ((at
start) simply ordinary precondition). Yet still able model
planning domains without them. would argue general constructs
necessary.
2. guilty colleagues.
3. Instead one must ascend much complex specification continuous effects (presented
Section 5.3 pddl2.1 document) achieve degree flexibility.

126

fiA Response pddl2.1

2.1 (over all):
Consider load-truck action given Figure 6 pddl2.1 article. contains
condition (over (at ?t ?l)): i.e., truck must stay location
load. must moved? allowed move vehicle
loaded. Similarly, drive car refueled,
turn oven used bake cake, attempt tie
shoelaces running, etc. knowledge abounds common sense conditions.
natural language use progressive tenses refer ongoing activities. Similarly,
natural way model (over all) condition simply action assert
activity ongoing, use negation activity precondition actions
could interfere. resulting transformation load-truck action given
Figure 1.
Figure 1 load-truck action advertises initiated on-going loading
truck adding loading predicate state. end action predicate
deleted. Actions like move-truck could interfere loading blocked adding
(not loading) preconditions. Using technique able replace
(over all) conditions used competition domains. Interestingly replacements
made domain sensible readable.
Consider brief advantages modeling (over all) effects adding progressive
predicates state.
1. method realized without extending standard strip/adl semantics.
2. actions preconditions still encapsulates interactions actions. presence (over all) conditions, one would examine every
action see (over all) conditions interfered one
actions effects. Put another way, actions activation condition continues
Markovian, i.e., dependent current state. current state continues
carry information needed determine action applied;
(over all) conditions, one also needs examine currently active actionsthe
state longer encapsulates necessary information.
3. Finally, seems resulting domain models natural easier
understand.
2.1.1 Modularity
One concern approach avoiding (over all) conditions, appears
make adding new actions domain non-modular.4 Non-modularity potentially arises
adding new actions could interfered previous actions,
adding new actions could interfere previous actions.
first case arises add new actions like refuel, repair, change-tire, etc.,
interfered existing action move-truck. solution
adding non-interference preconditions would seem require modifying description
4. Thanks David Smith Martha Pollock pointing needed address issue
modularity.

127

fiBacchus

move-truck add (not (refueling)), (not (repairing)), (not (changing-tire)),
etc., preconditionsa new precondition every new action added.
second case arises add new action like tow-truck also changes
location truck. would ensure add preconditions
progressives required block interfering previously defined actions.
second case perhaps problematic, since require modifying
old actions. However, first case issue since one might want modify
definition previous actions already debugged.
using (over all) conditions need make changes old actions
worry effects new actions old. However, would argue
modularity exists syntactic levelit syntactically easy modify domain
description accommodate new actions. corresponding modularity
semantic level: interferences new action old still exists.
cases cannot simply ignore interactions, leaving planner (over
all) conditions resolve. found developing domains, many cases
new action added domain bug domain specification appears.
example, plans one would expect find longer found planner. Often bug
lies new action, often bug found specification old actions.
domain longer operates expected, one still left task unraveling
interactions specification. general, specifying rich domain requires understanding
possible interactions domain, task (over all) conditions
help.
could argued job planner unravel interactions
domain. argument, believe, trivializes job specifying planning domain.
planners job compute interactions actions sequence (or
complex composition) actions. Getting domain correctly specified difficult task,
requires least understanding actions interact statically, even one leave
dynamic interactions planner.
Fortunately, systems interactions actions relatively local:
typically relatively structured way actions interfere other.
makes specifying planning domains feasible.
One take advantage structure build robust domain models provide
advantages semantic well syntactic modularity. critical component building
good domain models ability use definitions (axioms), feature provided
pddl2.1. Tlplan, e.g., one define new predicate symbol using first-order
formula previous defined symbols. defining right high level constructs one
typically provide explicit representation structure interactions
domain. advantage one also obtains declarative representation
structure, thus achieving natural easier understand domain specification.
example above, one could define new predicate (must-be-stationary ?t)
disjunction
(or (loading ?t) (changing-tire ?t) (repairing ?t) (refueling ?t)).
(move-truck ?t ?l1 ?l2) action need single precondition (not
(must-be-stationary ?t)), new action requires truck station128

fiA Response pddl2.1

(:durative-action load-truck
:parameters (?t - truck)
(?l - location)
(?o - cargo)
(?c - crane)
:duration (= ?duration 5)
:precondition (and (at ?t ?l)
(at ?o ?l)
(empty ?c))
:effect
(and (loading ?t)
(at end (not loading ?t))
(holding ?c ?o)
(not (at ?o ?l))
(at end (when (holding ?c ?o) (in ?o ?t)))
(at end (when (holding ?c ?o) (not (holding ?c ?o))))
(at end (when (not (holding ?c ?o)) (load-failed))))
)

Figure 2: Converting (at end) conditions
ary accommodated simply adding new disjunct definition must-bestationary. approach advantage explicitly introducing new concept
must-be-stationary, helps understanding structuring domain. contrast, (over all) conditions one concept changing at.
simple example difference appears trivial, key idea
new concept like must-be-stationary domain, use build
complicated concepts.
Using explicit progressive preconditions also allows coordination far complex shared uses resource. example, specify refueling driving
require exclusive use truck, changing tire done concurrently
repairing truck concurrently loading. conditions accommodated action explicitly mention excluded activities precondition,
axioms grouping structuring activities complex conditions
using conditions action preconditions. either case result
explicit description domain easier understand, debug modify.
2.2 (at end):
(at end) strange condition. fact, appear competition
domains. would argue also needed; easily captured
constructs, rather unnatural would never appear reasonable
domain model. (at end) intended support flexibility whereby action
release condition actions might delete condition, long
condition subsequently restored time. Like (over all) condition effect
breaking Markovian nature normal action specifications. natural way
model situation, would claim, simply use conditional (at end) effects:
required condition holds end, desired effect created, otherwise bad
effect occur. modified load-truck action given Figure 2.

129

fiBacchus

(:durative-action burnMatch
:parameters (?m - match ?l - location)
:duration (= ?duration 5)
:precondition (and (have ?m)
(at ?l))
:effect
(and (when (no-other-light-source ?l)
(and (not (dark ?l)) (light ?l)))
(not (have ?m))
(burning ?m)
(at end (when (burning ?m) (not (burning ?m))))
(at end (when (and (no-other-light-source ?l)
(burning ?m))
(and (not (light ?l))
(dark ?l))))))
)
(:action blowOutMatch
:parameters (?m - match ?l - location)
:precondition (and (at ?l)
(burning ?m))
:effect
(and (not (burning ?m))
(when (no-other-light-source ?l)
(and (not (light ?l))
(dark ?l)))))
)

Figure 3: Alternate model burn-match
modification, instead (at end (holding ?c ?o)) condition, simply
changed effects action. (holding ?c ?o) holds end action,
action normal effects. Otherwise, adds state marker indicating
load failed. add (not (load-failed)) goal, planner would search
ways falsifying antecedent effect (assuming (load-failed) cannot
undone), i.e., planner would search ways ensuring (holding ?c ?o) true
end action. Note exactly planner would ensure
ordinary precondition holds. is, reduce construct
standard features.

3. Unspecified Durations
Another feature pddl2.1 ability specify ranges durations actions.
intent actual duration action might affected actions.
burnMatch heat-water actions (Figures 10 12 pddl2.1 document)
examples range utilized duration.
find flexible durations strange, make action dependent future
actions. Furthermore, convinced necessary. Rather think
natural way model situations would introduce two actions, one start
action (light match, start heating liquid), one end action (blow
match, take liquid heat). Figures 3 4 present alternate models.
burnMatch starts match burning (toggling lighting status location
light location). also posts default completion

130

fiA Response pddl2.1

(:durative-action heat-water
:parameters (?p - pan)
:duration (= ?duration (/ (- 100 (temperature ?p)) (heat-rate)))
:precondition (and (full ?p)
(onHeatSource ?p)
(byPan))
:effect (and (heating ?p)
(heating-start ?p (current-time))
(at end (when (and (byPan) (heating ?p)) (not (heating ?p))))
(at end (when (heating ?p)) (assign (temperature ?p) 100))
(at end (when (and (not (byPan)) (heating ?p)) (burn-pot ?p)))))
(:action take-off-heat
:parameters (?p - pan)
(?startt - time)
:precondition (and (heating ?p)
(heating-start ?p ?startt)
(byPan))
:effect (and (not (heating ?p))
(when (not (burn-pot ?p))
(increase (temperature ?p)
(* (- (current-time) ?startt) (heat-rate))))))

Figure 4: Alternate model heat-water
match burning maximum duration. match still burning end
maximum duration extinguished lighting status toggled (if match
source light). hand, match extinguished earlier
blowOutMatch action.
heat-water action starts water heating, like burn-match default
maximum duration. pan still heated end time raises
temperature pan 100 degrees, and, agent pan, takes pan
heat, otherwise pan continues heated causing become burnt (this
keeping previous discussion wanting (at end) preconditions). Note
pans temperature never rises 100 (we assuming water keeps boiling).
also marks time heating started ((current-time) time action
executed). take-off-heat action take pan heat time.
uses start time heating calculate temperature water (if pot
burnt, temperature remains 100, set heat-water).
suggesting alternate action specifications right models
(e.g., heat-water cannot account putting pot back heat taking
off). suggesting case variable durations made.
really necessary even natural domain modeling?

4. Conclusions
could list components pddl2.1 seem unnecessary,
believe point made. pddl2.1 essential planning competition,
certainly strong supporter usefulness competition furthering
planning research. However, would suggest outside context competition,
131

fiBacchus

issue features included planning domain specification language
needs grounded application languages. Planning domains, even
simplified ones designed research, modeled many different ways, believe
better produce robust models simpler languages develop
languages features really needed.
think many ideas contained pddl2.1 useful, e.g., way
continuous change treated. Nevertheless, would encourage anyone try
construct planning algorithms dealing features. Rather would encourage
development planning algorithms inspired issues arise interesting
domains. is, think incorporation new features planning languages
needs motivated compelling examples.

References
Bacchus, F., & Ady, M. (2001). Planning resources concurrency, forward chaining
approach. Proceedings International Joint Conference Artificial Intelligence (IJCAI), pp. 417424.

132

fiJournal Artificial Intelligence Research 20 (2003) 145-148

Submitted 9/03; published 12/03

Commentary
PDDL2.1 Art Possible?
Commentary Fox Long
Drew McDermott

drew.mcdermott@yale.edu

Dept Computer Science, Yale University,
PO Box 208285, New Haven, CT 065208285

Abstract
PDDL2.1 designed push envelope planning algorithms do,
succeeded. adds two important features: durative actions, take time (and
may continuous effects); objective functions measuring quality plans.
concept durative actions flawed; treatment semantics reveals
strong attachment way many contemporary planners work. Future PDDL
innovators focus producing clean semantics additions language,
let planner implementers worry coupling algorithms problems expressed
latest version language.

things considered, Fox Long done terrific job producing PDDL2.1. know
experience getting committee agree language requires delicate combination diplomacy decree. language extensions emerged 2002
competition exactly anyone wanted, apparently everyone live
them. PDDL2.1 serving sturdy basis evaluating comparing planning algorithms, prime purpose language first place. appears
next competition minor extensions, revisions, necessary.
top work negotiating syntax language, Fox Long also produced semantics, display paper, plus elaborate semantics fully
autonomous processes, make PDDL2.1, unfortunately. (I
2002 competition committee, and, explain below, enthusiastic others
committee concept durative actions.)
Probably important innovation PDDL2.1 introduction objective
functions plans, thus making plan quality important plan existence. far
planners able much objective functions, indicates thoroughly weve conditioned classical-planning framework. Objective functions
become much important future.
main defect PDDL2.1 syntax semantics tailored closely
currently popular style planner. example, functions allowed, exactly
one kind, namely, take non-numeric arguments denote time-varying numeric
quantities. is, (f ---args--- ), arg must identifier overall value
must number change situation situation. paradigmatic example
(amount-in tank1), might denote volume fuel tank1. term
(object-at-distance 3) allowed. restrictions? many planners
eliminate variables outset solution attempt instantiating terms
c
2003
AI Access Foundation. rights reserved.

fiMcDermott

possible combinations objects mentioned problem statement. tactic may
sound unpromising, many problems reasonable size works surprisingly well.
However, soon universe objects becomes infinite tactic stops working,
means numbers cant treated like ordinary objects. also means general
functions cant part language. function midpoint: Location
Location Location, would generate infinite set terms (midpoint
loc-a (midpoint loc-b loc-a)).
PDDL 1.0, problems arise functions language. main goal designing agree lowest-common-denominator notation many planners could obviously cope with, could become standard
problem statement. language succeeded quite well regard,1
also standard framework discussions go next. discussions,
several relevant considerations:
1. real-world problems need solved?
2. problems lie beyond solvable fringe current state art?
3. constructs given clean semantics? coherent semantics all?
4. constructs current planning algorithms cope with?
listed declining order importance, although grant
important. believe PDDL2.1 gives much weight consideration 4,
example functions good case point. Functions play several different roles
logical theory, PDDL domains are, get it. assemblyplanning domain, someone might want function top (top cylinder-3) denotes
top piece worked on. considerations come play?
1. Assembly planning real-world problem.
2. lies well beyond currently solvable, probably far beyond.
3. semantics functions mathematical logic well understood, use
solutions here.
4. Current planning algorithms cant cope functions, easily
extended handle functions like top, cant recursively nested.
Given answers, considering examples, seems clear adding functions PDDL good idea: would make language easier use realistic problems,
many cases would impose minimal burden current planners. presence
functions makes set problems unsolvable planning system, system
detect problem encountered go next one. wanted
to, could add :functions requirements flag language, hardly seems worth
trouble. But, said above, much weight attached abilities current
planners PDDL2.1 ended function declaration whose syntax functions
needlessly restricted whose semantics needlessly complex.
1. precise, succeeded well action-based planners, went nowhere hierarchical planners.

146

fiPDDL2.1 Art Possible?

see phenomenon durative actions, is, actions require
specified amount time execute. committee thrash compromise
things, mainly revolving around far go beyond state art. minority
(including me, well Fox Long) thought obvious next step
able model autonomous processes, differ actions two respects:
continuous effects, run whenever conditions true (precondition
quite right term), matter target agent (the one executing plans) does.
example boiling water: long water pot, water 100
degrees Celsius, water boil away, continuously decreasing volume. agent
make use processes making conditions true false appropriate times.
Unfortunately, majority committee thought putting processes PDDL
big leap, instead add durative actions. Fox Longs paper
shows, term durative action really refers two completely different species: actions
take fixed amount time matter what, traveling New York
London;2 actions whose duration partly control planner,
boiling water. difference flagged syntactically whether :duration field
durative action equality (species 1) inequality (species 2). agent executes
action species 1, loses freedom duration action.
agent sitting airplane, taking hike. seems unproblematic,
consider cleaning warehouse, might modeled taking amount time
proportional messiness warehouse. weird idealization imagine
robot might commit cleaning warehouse, essentially prisoner
decision warehouse clean.
Duratives species 2 avoid problem, essentially sneaking autonomous processes
theory strange form. allowed use autonomous processes,
long pretend target agent executing them. Rather connect process
directly condition, suppose agent decide stop process
point consistent constraints ?d, duration action. So, Figure 14
Fox Longs paper, rather autonomous process started
stopped changing truth value (onHeatSource pot ), say (onHeatSource
pot ) becomes true false agent starts stops heat-water action.
turn-on turn-off actions required.
first remark make difference action target agent
stop one must wait end marked syntactically. Suppose
possible agent get locked kitchen boiling water.
longer stop boiling. PDDL2.1, impossible sort thing
expressed. closest come make (over (in agent kitchen))
condition durative action, soon agent leaves kitchen must
bring heat-water action close, plan invalid.
impression planners handle duratives handle species
1, committee decided include duratives. seems clear
species 2 headed extinction favor straightforward autonomous processes.
2. Assuming flight time fixed may seem extreme idealization, allowing time vary
(probabilistically?) would push PDDL far beyond classical-planning roots; none controversies
mentioned ever question knowability future.

147

fiMcDermott

Fox Long define semantics duratives terms ordinary actions plus monitoring actions make sure conditions remain true intervals
theyre supposed true. possible know exactly monitoring actions
supposed inserted changes fluents linear. way specifying semantics, has, unfortunately, run course. Fox Long point out,
future increases complexity temporal constructs make harder express
semantics PDDL, harder verify plan correct.
details durative semantics echo issues arose connection
semantics functions. tricky part semantics actions incorporating
STRIPS assumption actions represented terms add lists delete lists,
turn requires assuming situations represented finite lists atomic
formulas. One might suppose numbers would complicate picture
infinite number them, fortunately numbers dont compromise
STRIPS world view. specify blocks location numerical coordinates, still
one location, moving involves deleting assertion stating old location
adding new one.
Why, then, Fox Long work hard keep numerical assertions strictly separate
non-numeric? flatten action definitions assigning semantics? quantifiers handled substituting possible terms variables?
answer questions odd restrictions functions: Many
current planners depend generating possible instances action.
usually clarifies semantics language greatly defined without direct
connection implementation reasoning system language. (McDermott,
2003) sketch formal semantics extension PDDL containing true autonomous
processes. fulcrum framework set truth conditions process definitions.
obvious link requirements planning algorithm, fact
semantics allows processes would quite difficult cope exploit. However,
hard find subsets process definitions, including corresponding durative
actions, current planners, slight extensions, could handle.
One key goals PDDL beginning put pressure
automated-planning community make planners handle realistic class planning
problems. new versions PDDL restricted ways congenial existing planners,
sends mixed message, urging us new territory, time reassuring us
algorithms might still basically correct. planning community doesnt really
need much reassurance; opt domain-definition language clear syntax
clean semantics find algorithms solve problems domains
language describes.

References
McDermott, D. (2003). formal semantics processes PDDL. Proceedings
ICAPS-03 Workshop PDDL.

148

fiJournal Artificial Intelligence Research 20 (2003) 343377

Submitted 12/02; published 12/03

TALplanner Third International Planning
Competition: Extensions Control Rules
Jonas Kvarnstrom
Martin Magnusson

jonkv@ida.liu.se
marma@ida.liu.se

Department Computer Information Science
Linkoping University
SE-581 83 Linkoping, Sweden

Abstract
TALplanner forward-chaining planner relies domain knowledge shape
temporal logic formulas order prune irrelevant parts search space. TALplanner recently participated third International Planning Competition,
clear emphasis increasing complexity problem domains used benchmark tests expressivity required represent domains planning system.
Like many planners, TALplanner support aspects increase expressivity, number changes planner required. short
introduction TALplanner, article describes changes made
competition. also describe process introducing suitable
domain knowledge several competition domains.

1. Introduction
Like planners, TALplanner (Kvarnstrom & Doherty, 2000; Doherty & Kvarnstrom,
1999; Kvarnstrom, Doherty, & Haslum, 2000; Doherty & Kvarnstrom, 2001; Kvarnstrom &
Doherty, 2003; Kvarnstrom, 2002) allows user specify goal shape set
atemporal logic formulas must satisfied final state results executing
plan. Unlike planners TALplanner also allows specification set temporal
logic formulas must satisfied entire state sequence generated plan.
Obviously, formulas used specify temporally extended goals,
safety maintenance goals must upheld throughout execution plan.
However, also possible specify constraints related traditional measures plan
quality, constraints forbid certain stupid actions taking place,
Blockhead blocks world planner Kibler Morris (1981) TLplan Bacchus
Kabanza (2000), initially inspired development TALplanner. example,
logistics domain one may specify temporally extended goal stating package
destination, never picked again, goal stating trucks driving
two locations always use shortest path. constraints processed
TALplanner order automatically extract control knowledge used
forward-chaining search process, opposed used filter candidate plan
generated. Given sufficiently strong constraints, planner efficiently prune
search tree, making easier find plan among remaining nodes. Often
(as article) search control aspect fact primary reason introducing
temporally extended goal, case goal usually referred control rule.
c
2003
AI Access Foundation. rights reserved.

fiKvarnstrom & Magnusson

Although forward-chaining planners may sometimes suffer lack goal-directedness
compared types planners, use explicitly represented domain-dependent
knowledge one way compensating deficiency. significantly, forward
chaining planner always complete description past current states,
facilitates use complex operator types complex preconditions conditional
effects. expressivity useful TALplanner participated third International Planning Competition (IPC-20021 ), clear emphasis increasing
complexity problem domains used benchmark tests expressivity required
represent domains planning system. fact, TALplanner already support
several new features present IPC-20002 , use numeric
state variables temporally extended actions variable duration.
Nevertheless, several extensions changes implemented
competition order accommodate semantics PDDL2.1, new version
PDDL (Planning Domain Definition Language, Fox & Long, 2003) used specify
problem domains problem instances. extensions changes first topic
article, introduction TALplanner (Sections 2 3), extensions
discussed Section 4. second topic describing domain-dependent
control rules used six benchmark problem domains hand-tailored
track competition, importantly, process generating rules
reasoning behind (Section 5). also describe new changes
made TALplanner competition (Section 6). Finally, conclude
discussion positive negative sides using search control knowledge
TALplanner together pointers towards possible future research topics.
Please see Long Fox (2003) information basic setup
competition, detailed descriptions planning domains used, timing plan
quality results.

2. Representation: Using TAL TALplanner
semantics TALplanner based extended version TAL-C (Karlsson &
Gustafsson, 1999; Doherty, Gustafsson, Karlsson, & Kvarnstrom, 1998), member
TAL (Temporal Action Logics) family narrative-based non-monotonic linear discrete
metric time logics reasoning action change. TAL-C developed
modeling domains may include use incomplete information, delayed effects
actions, finite infinite chains indirect effects, interacting concurrent actions, independent processes directly triggered action invocations. Consequently, seen
ideal choice initial version TALplanner also extensions
could conceivably implemented foreseeable future.
TAL narrative consists set labeled statements high-level macro language
L(ND), basic language number statement classes observations fluent
values (labeled obs), action descriptions (acs), action occurrences (occ), domain constraints
(dom), dependency constraints modeling causal relations indirect effects (dep).
formal semantics L(ND) defined translation order-sorted first-order
base language L(FL) circumscription policy providing solution frame
ramification problems (Doherty, 1994; Gustafsson & Doherty, 1996; Doherty et al., 1998).
1. http://www.dur.ac.uk/d.p.long/competition.html
2. http://www.cs.toronto.edu/aips2000/

344

fiTALplanner IPC-2002: Extensions Control Rules

L(ND) language designed easily extended different tasks, planning. extension may take shape new specialized macro new type
statement. illustrated Figure 1, TALplanner goal narrative uses version L(ND)
called L(ND) , contains standard classes L(ND) statements together
several new types planning-related statements. extensions accompanied
extensions translation function, new variation TAL still share
base language L(FL).
However, TALplanner use
L(ND)*
L(ND)

translation directly planTALPlanner
TAL
TAL
ning
process. Instead, makes direct use
Plan Narrative
Goal Narrative
higher level L(ND) goal narrative
forward-chaining search process
L(FL)
L(FL)
generates plan narrative set
1storder
1storder
timed action occurrences (corresponding
theory
theory
plan) added,
+ Circ(T)
+ Circ(T)
goal entailed final state.
L(FL)
+ Quantifier Elimination
L(FL)
+ Q.E.
section, attempt
1storder
1storder
provide intuitive understanding TAL
theory
theory Goal
used domain specifications using concrete examples
Figure 1: TAL/TALplanner relation
standard logistics planning domain,
set objects (packages) transported truck locations city
airplane airports different cities. next section contains information search process use control rules. See Doherty et al. (1998)
detailed description TAL, see Kvarnstrom Doherty (2000)
information TALplanner.
Notation. formulas L(ND) statements shown using input syntax
TALplanner, exception connectives quantifiers may written
using ordinary logical symbols increased clarity. free variables implicitly
universally quantified.
2.1 Types, Objects State Variables
Although planners restricted declaring unstructured set objects
representing types unary predicates, TAL order-sorted allows user specify
hierarchy object types (sorts). logistics domain modeled using standard
sort boolean = {true, false} together seven user-specified types: loc (location)
subtypes airport city, thing subtypes obj vehicle, latter
subtypes truck plane.
TALplanner also allows use numeric types. order keep semantics
types clear, integers fixed point numbers (that is, numbers fixed number
decimals) allowed, lower upper bounds must declared numeric
type. standard arithmetic operators available numeric types
given interpretation semantic attachment.
State variables represented using TAL fluents, restricted

345

fiKvarnstrom & Magnusson

predicates take values arbitrary user-specified sort. logistics domain,
one could use two boolean fluents, at(thing, loc) in(obj, vehicle), together cityvalued fluent city of(loc) denoting city containing location loc.
2.2 Initial State
Given fluents defined above, initial state logistics problem instance
specified using L(ND) observation statements:
#obs [0] city of(pos1) =
city1 city of(pos2) =
city2 . . .
#obs [0] at(obj11, pos1) at(truck1, pos1) . . .
observations consist TAL-C fixed fluent formulas, formulas form [ ] denoting fact fluent formula holds time . fluent formula boolean
combination elementary fluent formulas form f =
v (f==v input notation),
denoting fact fluent f takes value v. boolean fluents,
second observation, shorthand notation f f (!f input notation) allowed.
notation also extended open, closed, semi-open temporal intervals. addition
formulas, function value(, f ) denotes value f time .
2.3 Goal: Goal Statements Goal Expressions
statement class goals (labeled goal) added L(ND) . goal statement
consists fluent formula must hold goal state:
#goal at(obj11, airport1) at(obj23, pos1) . . .
ability test whether formula entailed (state-based) goal useful
temporally extended goals domain-dependent control rules. Therefore, new macro
added: goal expression goal() holds iff goal problem instance (the conjunction goal statements) entails fluent formula . Stated differently, goal() true
must true every goal state. translation L(FL) somewhat complex;
see Kvarnstrom Doherty (2000) information.
Note valid plan must end goal state. sufficient visit goal state
temporarily, could case operator effects multiple timepoints
first satisfying goal destroying concurrent plans
created. (If plans desired reason, would course easy modify
definition planner accordingly.)
2.4 Operator Definitions
Since TAL-C logic reasoning action change, notion actions
used modeling planning operators. Although TALplanner use
semantics, extended planning language L(ND) contains new operator macro
providing syntax facilitates use resource constraints planningoriented concepts present standard TAL-C. line standard
TAL practice preserving logical base language L(FL) semantics providing
different variations high-level macro language L(ND) adapted special
tasks.
346

fiTALplanner IPC-2002: Extensions Control Rules

examples demonstrate operator definition syntax using three six
logistics operators. examples shown IPC-2002 benchmark domains
discussed.
#operator load-truck(obj, truck, loc) :at
:precond [s] at(obj, loc) at(truck, loc)
:effects
[s+1] at(obj, loc) := false, [s+1] in(obj, truck) := true
#operator unload-truck(obj, truck, loc) :at
:precond [s] in(obj, truck) at(truck, loc)
:effects
[s+1] in(obj, truck) := false, [s+1] at(obj, loc) := true
#operator drive(truck, loc1 , loc2 ) :at
:precond [s] at(truck, loc1 ) city of(loc1 ) =
city of(loc2 ) loc1 6= loc2
:effects
[s+1] at(truck, loc1 ) := false, [s+1] at(truck, loc2 ) := true
Although used simple logistics operators above, TALplanner also allows
use context-dependent quantified effects well prevail conditions. Unlike pure
preconditions, prevail conditions limited invocation state operator
refer entire interval operator executed. interval
prevail condition must hold explicitly specified, provides additional flexibility
compared requiring precondition must always hold throughout execution
action.
2.5 Resources
TALplanner limited generating sequential plans, resource consumption production could handled using plain operator effects. example, loading truck
requires one unit space, amount available space could decreased follows:
#operator load-truck(obj, truck, loc) :at
:precond [s] at(obj, loc) at(truck, loc)
:effects
[s+1] space(truck) := value(s, space(truck)) 1, . . .
concurrent planning, clearly sufficient, since multiple parallel invocations
load-truck would still consume one unit space. reason, TALplanner
explicit support resources (Kvarnstrom et al., 2000).
Resources declared manner similar ordinary fluents:
parameters take values arbitrary integer fixed point domain. Unlike
planners, TALplanner provides one type resource, provides several types
resource effects. Resources produced consumed. also borrowed
(and automatically returned), either exclusively, meaning borrower exclusive
use resource specified interval, non-exclusively, multiple actions
borrow units certain resource concurrently. latter case may appear
strange, useful one wants use resource semaphore mutex.
Finally, resources assigned completely new value.

347

fiKvarnstrom & Magnusson

following example, loading truck always consumes one unit space.
#operator load-truck(obj, truck, loc) :at
:precond [s] at(obj, loc) at(truck, loc)
:effects
[s+1] at(obj, loc) := false, [s+1] in(obj, truck) := true
:resources [s+1] :consume space(truck) :amount 1
Unlike ordinary fluents, resource res multiple aspects queried used
formulas operator preconditions control rules. timepoint, initial amount available, $init(res). certain amount may consumed time
step ($consumed(res)), produced ($produced(res)), borrowed exclusively ($borrowed(res))
borrowed non-exclusively ($borrowed-nonex(res)). results remaining amount
available ($available(res)), must minimum ($minimum(res))
maximum ($maximum(res)) allowed. ability refer aspects directly allows
user specify complex resource constraints simple minimum maximum value resource, control rule defining maximum amount may
consumed per time step.
concludes description planning domain definitions TAL. following
sections show structure TALplanners forward-chaining search tree
search process constrained using control rules.

3. Search Control Rules
Like forward-chaining planner, TALplanner searches plan tree root
corresponds initial state outgoing edge corresponds one
operators applicable source node. Two trivial examples shown Figure 2,
notation [s,t] means action executed time time t.
sequential planning (Figure 2a), new action always added time step
previous action ended. concurrent planning (Figure 2b), TALplanner still adds single
action time plan, constraint time action executed
relaxed: action must start start existing action current
plan prefix end existing action. searching tree, preference
given actions invoked earlier timepoints. words, TALplanner tries add
many applicable actions possible timepoint stepping next
timepoint, Figure 2b subtree starting [0,4] A3, executing action A3
time 0 time 4, would explored backtracking subtree starting
[2,5] A3, A3 happens take slightly less time execute due differences
state action invoked. search process ends soon planner
found plan ending state satisfying goal. exact definition search tree
available Kvarnstrom Doherty (2000) sequential TALplanner Kvarnstrom
et al. (2000) concurrent TALplanner.
Although common view node search tree consisting single state,
operator function states states, sufficient TALplanner,
several reasons: single operator may generate multiple new states, evaluation
temporally extended goal domain-dependent control rule may require access
entire state history beginning initial state, concurrent planning future

348

fiTALplanner IPC-2002: Extensions Control Rules

Initial
node

[0,1] A1

[3,4] A1
[4,7] A3

[0,3] A2
[0,2] A3

0

1

Initial
node

[0,3] A2

3

4

[3,4] A1

[0,1] A1

[0,3] A2

[1,12] A4

[0,4] A3
[2,5] A3

[0,2] A3

Goal
node

2

[0,1] A1

0

5

Goal
node

1

2

3

4

5

[0,3] A2

[4,7] A3

[0,1] A1

[0,3] A2

(a) Sequential

[2,5] A3

(b) Concurrent

Figure 2: Forward-Chaining Search Space
state may modified several operators reaches final configuration.
reasons, convenient view node consisting state sequence,
(equivalently) logical model, indicated figure.
simple forward-chaining planner implemented searching tree using
standard search algorithm, iterative deepening depth first search. although
using complete search algorithm clearly enough make planner complete,
equally clear certain degree goal-directedness required make search process
efficient. achieved using domain-dependent control rules.
3.1 Using Domain-Dependent Control Rules
fully automated planning, planner generally supplied initial state,
set acceptable goal states (often specified using propositional first-order formulas
must hold goal state), set operators used plan.
planner determine search plan efficiently, possible exception
various command line options fine-tuned user.
However, cases user additional information planning domain
could use planner, information may difficult extract mechanically
simple domain specification. case, would make sense allow user
supply information planner. Although entails somewhat work
user, may also lead finding plans quickly finding plans higher quality.
course many different kinds additional information could given
planner. TALplanner (inspired TLplan, Bacchus & Kabanza, 2000) allows
user specify set first-order TAL formulas must entailed final plan.
serves two separate purposes. First, allows specification complex temporally
extended goals safety conditions must upheld throughout execution
plan, second, additional constraints final plan often allow planner
prune entire branches search tree, since proven leaf branch
violate least one goal. many cases pruning main reason
use formula, case often called control rule. (Allowing planner
prune branches efficiently requires additional analysis, described Kvarnstrom,
2002.)
349

fiKvarnstrom & Magnusson

3.2 Control Rules Logistics Domain
following control rules use logistics domain. control
rule examples given IPC-2002 benchmark domains discussed.
First, package loaded onto plane plane required move it,
i.e., goal requires location another city. Second, unloaded
package plane, package must arrived correct city satisfying goal.
Third, package destination, moved.
#control :name only-load-when-necessary
[t] in(obj, plane) at(obj, loc)
loc [ goal (at(obj, loc)) [t] city of(loc) =
6 city of(loc) ]
[t+1] in(obj, plane)
#control :name only-unload-when-necessary
[t] in(obj, plane) at(plane, loc)
loc [ goal (at(obj, loc)) [t] city of(loc) =
city of(loc) ]
[t+1] in(obj, plane)
#control :name objects-remain-at-destinations
[t] at(obj, loc) goal (at(obj, loc)) [t+1] at(obj, loc)
Note rules could course expressed various logically equivalent
forms. variations would identical performance, since TALplanner internally
normalizes many aspects control formulas domain analysis phase.

4. Third International Planning Competition
second international planning competition (IPC-2000), planning domains used
mainly STRIPS expressivity. Support typed objects required,
domains could use ADL-style quantified conditional effects, restricted STRIPS
versions also provided.
Although expect increase expressivity third competition (IPC2002), quite surprised extent changes. Fortunately, TALplanner
already supported many new requirements, others easily implemented. Despite make rather significant changes order handle
combination extensions efficiently. discuss
new requirements affected TALplanner together improvements
prompted domains used competition.
4.1 ADL-style Operator Definitions
Though STRIPS versions planning domains IPC-2002,
complex versions domains required use quantified conditional effects. Like
current planners, TALplanner limited STRIPS expressivity already
support this.

350

fiTALplanner IPC-2002: Extensions Control Rules

4.2 Numeric Types Arithmetic
IPC-2000 domains required numeric values emulated values using ordinary
objects. Miconic-10 elevator domain, example, floor numbers emulated using
objects named f0, f1, on. next floor calculated f + 1 using
explicitly defined predicate above(floor, floor).
approach taken simplest versions IPC-2002 domains,
also Numeric versions domains numeric types required
arithmetic operators used. already supported TALplanner,
unfortunately enough time write control rules domains.
4.3 Concurrency
Despite fact IPC-2000 domains provided potential using concurrent
actions, driving several trucks concurrently logistics domain,
reward exploiting potential. Plan quality measured terms number
operators plan, terms amount time required execute plan.
Consequently, several planners (including TALplanner) generated sequential plans,
even highly concurrent domains.
IPC-2002, plan quality mainly measured terms timepoint
last operator finished executing (the makespan plan, scheduling terms),
planner generating sequential plans would severely handicapped. Fortunately
concurrent version TALplanner already implemented, together support
resources (Kvarnstrom et al., 2000), could used competition.
Although concurrent TALplanner already applied number domains,
competition provided us varied set domains sometimes exploited
concurrency slightly different ways. provided us new ideas improvements
TALplanner, several minor enhancements TALplanners formula analysis algorithms
implemented first phase competition, allowing handle certain
types control formulas efficiently concurrent planning.
4.4 Operators Non-Unit Context-Dependent Duration
IPC-2000, plan operator used single time step. SimpleTime Timed
versions IPC-2002 planning domains, operators could non-unit duration,
(for example) walking requires time driving. already supported
TALplanner, changes required.
Timed versions IPC-2002 planning domains, durations operators could also context-dependent, could specified using arithmetic expressions,
requiring support numeric types already discussed above. example, time
required drive truck two locations could specified distance
locations divided speed particular truck. also already supported
TALplanner.
TALplanner also permits effects take place multiple timepoints within duration
action, although used competition.

351

fiKvarnstrom & Magnusson

4.5 Non-Integer Time
IPC-2002 contest domains required operator durations calculated
precision least three decimals, posed problem us. underlying TAL-C
logic based integer time, therefore true TALplanner. Introducing
non-integer time properly would required changes underlying TAL semantics,
could done time available, therefore simply multiplied
durations thousand. printing plan, time values divided thousand.
4.6 Operators Extended Duration
initial implementation TALplanner (in 19981999), assumed although
operators might extended durations, something interesting would happening
significant proportion discrete time steps within duration. example,
operator invoked might duration 5 time steps, effects take place
time + 1, time + 4, time + 5. assumption influenced
algorithms data structures TALplanner, appeared reasonable time,
since planning domains literature used single-step operators.
Nevertheless, always intention extend algorithms structures
handling plans sparse effects, discrete time steps contain effects all.
would difficult, partly reason
interesting research issues tackled instead continuously postponed.
IPC-2002 finally provided us compelling reason change data structures,
together number example domains could used test changes.
example, operator timed domain IPC-2002 might duration (say)
89.237, requiring 89237 discrete time steps, effects take place beginning
end action. led us implement new sparse state structure
change algorithms whose time complexity accidentally depended duration
operator rather number time steps something actually happened.
current version TALplanner allows state structures used depending
characteristics planning domain.
4.7 Moving Targets Rule
already mentioned, TALplanners semantics based use TAL, planning competition uses PDDL2.1. semantic differences two approaches usually major problem, trouble way
effects durative actions modeled PDDL2.1. essence, PDDL2.1 predicates
numerical fluents affected effects action considered moving
targets, preconditions another action allowed refer
timepoint. Instead, certain intermediate interval (arbitrarily chosen 0.001
units time) required assertion fact subsequent use
fact, even beginning plan actions cannot begin exactly time 0.
TAL, effects taking place time assumed give fluents new values exactly
timepoint, values immediately used. uncertainty
exact time effect takes place, one example explicitly state

352

fiTALplanner IPC-2002: Extensions Control Rules

value unknown inner part certain interval known end
interval (though yet implemented TALplanner).
Changing TALplanner use exact PDDL2.1 semantics question,
since would change fundamental assumptions planner. Instead
necessary come workaround let us simulate semantics.
several ways could done. One method would involve making minor changes
action definitions order assert final effects action slightly later (0.001
units time later, exact). competition instead implemented trivial
modification way plan printed: timepoint something happens
plan (for example, operator invoked), additional delay 0.001 inserted.
ensures plans safe according PDDL2.1 semantics sometimes leads
generating slightly worse plans necessary.
4.8 Finding Shortest Paths
Rover DriverLog domains, vehicles and/or people must travel along road networks, different roads may different costs (lengths) essential
take shortest path two points.
Although possible define shortest path algorithm using TALplanners input
language, formulas become somewhat complicated. Finding shortest path
two locations weighted graph places roads seems useful many domains,
therefore algorithm implemented directly planner.
fact, two algorithms implemented: One finding cost shortest
path two given locations, one finding distance closest location
satisfying given formula (for example closest location reasonable destination
certain truck DriverLog domain). functions called control
rules order ensure step one takes leads location shortest
path current destination.

5. Modeling Competition Domains
eight planning domains third International Planning Competition, six intended hand-tailored planners. Except final domain, UMTranslog-2, domains
exist least four different variations: STRIPS, Numeric (where numeric quantities
involved), SimpleTime (where operators take constant non-unit time), Timed (where
operator durations may depend actual parameters specific operator invocation).
TALplanner participated six domains, due lack time creating control
rules, limited participation STRIPS, SimpleTime, Timed versions
domains.
section describe domains translated PDDL2.1
TALplanner, discuss control rules created handle domains
efficiently. main focus two domains: ZenoTravel Satellite.
domains describe control rules used competition well
incremental process creating rules, omitting technical details
couple complex rules turned minimal impact planner performance
plan quality. remaining domains (Depots, DriverLog, Rovers, UMTranslog-2)
353

fiKvarnstrom & Magnusson

describe general intuitions behind control rules, omitting actual formulas
due space restrictions. First, though, begin comments process
formalizing planning domains.
5.1 Using Pre-defined PDDL Domains: Half Work Twice Time?
order create formal description real-world planning domain, course always
necessary thorough understanding domain plans
domain eventually going used. several reasons required,
reasons equally valid regardless whether formalization
eventually used input fully automated planner hand-tailored planner
like TALplanner.
First, understanding domain required order determine aspects
domain truly need modeled (as types, predicates functions) aspects
abstracted away. example, standard formalization logistics domain
model distances locations, allows trucks move two
locations one time step. sufficient purposes, plan optimal
given abstraction may extremely suboptimal actually carried real trucks,
usually lack teleportation abilities. Similarly, model package sizes
weights, cargo capacities trucks airplanes. Neither model truck drivers,
acceptable working hours drivers, additional costs incurred overtime pay, time
required maintenance activities changing winter tires year.
aspects need modeled depends much particular application one
mind.
Second, detailed understanding domain required order determine
operators available planner exactly preconditions effects
represented within abstract logical model domain.
finally, hand-tailored planners, domain must understood order
able guide search algorithm using domain-dependent heuristics control rules.
Usually aspects domain modeled time, much
information knowledge domain gathered order find suitable
set predicates operators needed even fully automated planner
reused development control rules heuristics hand-tailored planner.
planning competition, however, task divided two parts: organizers
define set domains using PDDL2.1, competitors handtailored track find suitable ways guiding planners. one way, one could say
competitors need half work, since formalization already done
task finding control rules remains. Unfortunately still necessary
understand domain thoroughly order write control rules.
complex domains, half work isolation might easily take twice time,
since constraints involved domain understood PDDL2.1
formalization rather talking domain experts. especially true
complex UMTranslog-2 logistics domain, significant amount time spent
trying determine exactly packages allowed move
loaded unloaded various kinds vehicle.

354

fiTALplanner IPC-2002: Extensions Control Rules

Figure 3: ZenoTravel problem instance (STRIPS problem 6)
Another problem caused use predefined formalization planning
domain degree detail used model determined advance. real
world would likely minimum level detail required, anything
level would acceptable. may seem like problem intuitively,
adding new details planning problem ought make harder, would best
remain minimum level detail. always true, especially
control rules involved. seen timed ZenoTravel domain, example,
control rules would simpler effective possible refuel
specific level, like real world, rather simple abstract refuel
operator unconditionally fills tank completely.
taken complaint organization competition
allowing different planners use different formalizations would course completely
infeasible. Nevertheless, present additional problems encountered
degree real-world domains deserve mentioned here.
5.2 ZenoTravel Domain
ZenoTravel domain, number aircraft fly people cities.
five actions available: Persons may board debark aircraft, aircraft may fly,
zoom (fly quickly, using fuel), refuel. restrictions many people
aircraft carry. Flying zooming equivalent except zooming generally
faster uses fuel. Figure 3 shows example problem, arrows pointing
goal locations.
5.2.1 ZenoTravel: STRIPS
show operator definitions STRIPS version ZenoTravel domain.
operators less directly translated PDDL representation.
main difference PDDL representation uses PDDL2.1 level 1, single-

355

fiKvarnstrom & Magnusson

step actions, stricter concept mutual exclusion TALplanner
automatically enforces certain invariants, fact aircraft leave
person boarding, location aircraft modified fly used
precondition board. TAL-C semantics used TALplanner similar
PDDL2.1 level 3 (with durative actions), invariant conditions must stated
explicitly. done using prevail conditions, considered separate
true pre-conditions. Note STRIPS formalization fly zoom take
amount time, since single-step actions possible.
#operator
:precond
:prevail
:effects

board(person, aircraft, city ) :at
[t] at(person, city ) at(aircraft, city )
[t+1] at(aircraft, city )
[t+1] at(person, city ) := false, [t+1] in(person, aircraft) := true

#operator
:precond
:prevail
:effects

debark(person, aircraft, city ) :at
[t] in(person, aircraft) at(aircraft, city )
[t+1] at(aircraft, city )
[t+1] in(person, aircraft) := false, [t+1] at(person, city ) := true

#operator fly(aircraft, city1 , city2 , flevel1 , flevel2 ) :at
:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 ) next(flevel2 , flevel1 )
:effects
[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,
[t+1] at(aircraft, city2 ) := true, [t+1] fuel-level(aircraft, flevel2 ) := true
#operator zoom(aircraft, city1 , city2 , flevel1 , flevel2 , flevel3 ) :at
:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 )
next(flevel2 , flevel1 ) next(flevel3 , flevel2 )
:effects
[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,
[t+1] at(aircraft, city2 ) := true, [t+1] fuel-level(aircraft, flevel3 ) := true
#operator
:precond
:prevail
:effects

refuel(aircraft, city , flevel, flevel1 ) :at
[t] fuel-level(aircraft, flevel) next(flevel, flevel1 ) at(aircraft, city )
[t+1] at(aircraft, city )
[t+1] fuel-level(aircraft, flevel) := false, [t+1] fuel-level(aircraft, flevel1 ) := true

translating operator definitions, time create set control rules.
basically two ways this: First, one sit think suitable
properties plan, write control rules ensure properties
hold. Second, one instruct planner show branch explored
search tree, observing output one identify obviously stupid choices made
planner, choosing action instance inevitably leads backtracking
performing actions useless given goals. Control rules written
prevent branches tree explored. approaches
covered here.
begin first method, attempting find number reasonable control rules
simply thinking properties ZenoTravel domain. Given experience
planning domains, fact quite easy. example, many domains
certain goals satisfied, one never allow
356

fiTALplanner IPC-2002: Extensions Control Rules

destroyed. ZenoTravel domain, people destinations never need
board aircraft, gives rise following control rule:
#control :name only-board-when-necessary
[t] in(person, aircraft) [t+1] in(person, aircraft)
city , city2 [ [t] at(person, city ) goal(at(person, city2 )) city 6= city2 ]
TAL formula states state transition person
aircraft time person aircraft time + 1, (that is, person
boarded aircraft), must reason allowed: person must
certain city must goal person another city.
noted previously control formulas usually written many different forms.
example, would equally valid state person city (and
therefore aircraft), required somewhere else, next
timepoint person still board aircraft:
#control :name only-board-when-necessary
[t] at(person, city ) city2 [ goal(at(person, city2 )) city 6= city2 ]
[t+1] in(person, aircraft)
Note although may first glance appear planner would extraordinarily stupid destroy goals already satisfied, also many cases
temporarily destroying goal necessary order satisfy goals. example, goal certain aircraft certain location already
reached destination, might still fly number people destinations
return destination.
Another natural idea (since aircraft follow predetermined routes ZenoTravel,
usually real life) would say people debark
reached final destination:
#control :name only-debark-when-in-goal-city
[t] in(person, aircraft) [t+1] in(person, aircraft)
city [ [t] at(aircraft, city ) goal(at(person, city )) ]
potential problem rule: cases optimal plan might require
number people debark one plane board number planes, could
fly destination concurrently, strictly forbidden only-debark-whenin-goal-city. common problem occurs many planning domains,
user determine depending requirements application
planner used.
number possible choices: could ignore problem accept suboptimal plans, skip rule completely let planner search vastly greater
search space order find plan guaranteed optimal, compromise,
attempt create weaker rule cut search space degree
gives optimal closer-to-optimal plans. planning competition conditions
somewhat artificial clearly stated would beneficial planner
spend ten times much effort finding plan plan five percent better,
average? guessed would case, consequently chose include
control rule stated above.
357

fiKvarnstrom & Magnusson

future, better solution would likely prefer plans person
debark reaching destination still allow plans. alternative
discussed detail conclusions.
Given two rules, might continue second approach finding
control rules. run TALplanner simple problem instance consider operator
sequences planner examines depth-first search process. beginning
sequence problem instance Figure 3. complete plan generated
planner contains 123 operators requires 60 time steps. shown IPC-2002
STRIPS result format timepoint action invoked followed
action instance.
0:
0:
1:
1:
2:
2:
3:
3:

(board person4 plane2 city1)
(board person5 plane1 city2)
(fly plane1 city2 city0 fl5 fl4)
(fly plane2 city1 city0 fl3 fl2)
(board person1 plane1 city0)
(board person2 plane2 city0)
(fly plane1 city0 city1 fl4 fl3)
(fly plane2 city0 city1 fl2 fl1)

4:
4:
5:
5:
6:
6:
7:
7:

(debark person2 plane2 city1)
(debark person5 plane1 city1)
(fly plane1 city1 city0 fl3 fl2)
(fly plane2 city1 city0 fl1 fl0)
(fly plane1 city0 city1 fl2 fl1)
(refuel plane2 city0 fl0 fl1)
(fly plane1 city1 city0 fl1 fl0)
(fly plane2 city0 city1 fl1 fl0)

8: (refuel plane1 city0 fl0 fl1)
8: (refuel plane2 city1 fl0 fl1)
9: (fly plane1 city0 city1 fl1 fl0)
9: (fly plane2 city1 city0 fl1 fl0)
10: (refuel plane1 city1 fl0 fl1)
11: (fly plane1 city1 city0 fl1 fl0)
11 : (refuel plane2 city0 fl0 fl1)
...

beginning operator sequence appears reasonable, time 4, airplanes
seem flying around randomly. control rules guiding them, apparently
mainly luck caused planes find reasonable cities fly time 1 3.
make airplanes goal-directed, identify three important reasons airplane
move city city2: goal asserts aircraft must end city2
plan complete, one passengers wants go city2,
person waiting picked airplane city2. following rule formalizes
three intuitions:
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] at(aircraft, city2 )
(goal(at(aircraft, city2 ))
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ]) ]
control rules, TALplanner quickly produce set plans 20 handcoded problems IPC-2002 competition, although plans optimal, nearly bad example given above. Together, plans require
total 7164 operators 618 time steps. plan example Figure 3 requires
20 operators 7 time steps.
Nevertheless, still improvements made. first criterion
admissible: allows plane visit destination even still needs pick
drop passengers. One way preventing would add condition
passengers must reached destinations:
#define [t] all-persons-arrived:
person, city [ goal(at(person, city )) [t] at(person, city ) ]

358

fiTALplanner IPC-2002: Extensions Control Rules

#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] at(aircraft, city2 )
([t] all-persons-arrived goal(at(aircraft, city2 ))
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ]) ]
improves plan quality slightly, TALplanner requires 7006 operators 575
time steps. new control rule fact strict, seen following
plan tail handcoded STRIPS problem number 3:
14:
14:
14:
14:
15:
15:
15:

(fly plane2 city4 city7 fl2 fl1)
(fly plane4 city8 city9 fl3 fl2)
(refuel plane1 city6 fl2 fl3)
(refuel plane3 city9 fl4 fl5)
(debark person24 plane4 city9)
(debark person28 plane4 city9)
(debark person34 plane2 city7)

15:
15:
15:
15:
16:
16:

(refuel plane1 city6 fl3 fl4)
(refuel plane2 city7 fl1 fl2)
(refuel plane3 city9 fl5 fl6)
(refuel plane4 city9 fl2 fl3)
(fly plane1 city6 city8 fl4 fl3)
(fly plane3 city9 city4 fl6 fl5)

example, plane1 plane3 wait passengers debarked
several planes could go final destinations, even though
clearly see real reason wait, potential passengers
already picked plane1 plane3 already enough fuel.
alter control rule according new insight: plane go final destination
passengers board plane headed towards destination
person left picked (that is, persons already arrived currently
board planes).
#define [t] all-persons-arrived-or-in-planes:
person, city [ goal(at(person, city )) [t] at(person, city ) aircraft [ in(person, aircraft) ] ]
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
[t+1] at(aircraft, city2 )
((goal(at(aircraft, city2 )) [t] all-persons-arrived-or-in-planes
person [ [t] in(person, aircraft) goal(at(person, city2)) ])
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ])]
yields another minor improvement, TALplanner requires 6918 operators
564 time steps. example used above, end plan looks follows:
14:
14:
14:
14:

(fly plane1 city6 city8 fl2 fl1)
(fly plane2 city4 city7 fl2 fl1)
(fly plane4 city8 city9 fl3 fl2)
(refuel plane3 city9 fl4 fl5)

15:
15:
15:
15:

(debark person24 plane4 city9)
(debark person28 plane4 city9)
(debark person34 plane2 city7)
(fly plane3 city9 city4 fl5 fl4)

study plans generated current set rules quickly identify
another obvious problem: number airplanes may fly location pick
person. again, necessary find reasonable balance finding
optimal plans finding plans quickly. contest, attempted find high quality
359

fiKvarnstrom & Magnusson

(but probably non-optimal) plan quickly possible. done ensuring
one airplane may go given place time, sole purpose
going pick person waiting:
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] at(aircraft, city2 )
((goal(at(aircraft, city2 )) [t] all-persons-arrived-or-in-planes
person [ [t] in(person, aircraft) goal(at(person, city2 )) ])
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ]
aircraft2 [ [t+1] at(aircraft2, city2) aircraft2 6= aircraft ])]
rule provides major improvement, complete set plans requires 5075
operators 434 time steps.
far, controlled airplanes fly, people board airplane,
debark. rules governing refueling, quick look plan one
larger problem instances reveals whenever aircraft nothing else do,
refuel. seems little bit wasteful, satisfied adding rule stating
airplanes must refuel tanks empty. rule perfect, since
airplane may miss opportunity pre-emptively refuel still refuel one fuel
level even going fly, provide significant improvement, bringing
number operators 4234. number time steps still 434.
minor adjustments made rules used competition. adjustments include modification only-board-when-necessary ensure
person must travel city city2 choose plane already needs
visit city city2 , possible, since less likely increase total
number flights.
One final change prompted fact intended differences timing
fly zoom cannot modelled correctly STRIPS version domain. Since
operators must take amount time, difference two
operators zoom uses twice much fuel. Although would possible
add control rule ensuring zoom used, easier simply remove
zoom operator domain definition.
5.2.2 ZenoTravel: SimpleTime
SimpleTime version ZenoTravel quite similar STRIPS version,
difference actions may non-unit duration certain preconditions
must hold throughout execution action. TALplanner operator definitions
changed accordingly. example, board fly operators changed follows:
#operator board(person, aircraft, city ) :at
:precond [t] at(person, city ) at(aircraft, city )
:prevail
[t+1, t+20] at(aircraft, city )
:duration 20
:effects
[t+1] at(person, city ) := false, [t+20] in(person, aircraft) := true

360

fiTALplanner IPC-2002: Extensions Control Rules

Figure 4: ZenoTravel problem instance (SimpleTime problem 3)
#operator fly(aircraft, city1 , city2 , flevel1 , flevel2 ) :at
:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 ) next(flevel2 , flevel1 )
:duration 180
:effects
[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,
[t+180] at(aircraft, city2 ) := true, [t+180] fuel-level(aircraft, flevel2 ) := true
run planner set SimpleTime problem instances, get almost immediate
results: planner claims plan instances. reason
is, course, control rules must satisfied valid plan, rules
designed underlying assumption actions unit duration. example,
consider planes-always-fly-to-goal, states plane leaves city time t,
meaningful destination t+1. fly action invoked plane must
city city1 , beginning next time step interval
aircraft present city all, finally arrives city2 180 time steps later.
words, planes-always-fly-to-goal ensures fly operator cannot used
all, quite originally intended.
One way solving problem would alter planes-always-fly-to-goal say
plane leaves city time t, meaningful destination t+180. Unfortunately, duration flight would encoded directly control rule instead
operator, would work Timed version, operators
variable durations fact, would even work SimpleTime, zoom
operator must also taken account.
Instead, domain model augmented new fluent flying-to(aircraft, city)
keeps track whether plane flying, so, destination is. ensure
fluent kept up-to-date, following added effects fly zoom operators:
[t+1] flying-to(aircraft, city2 ) := true, [t+180] flying-to(aircraft, city2 ) := false // fly
[t+1] flying-to(aircraft, city2 ) := true, [t+100] flying-to(aircraft, city2 ) := false // zoom
planes-always-fly-to-goal rule changed follows, stating
aircraft ceases city , must flying reasonable destination:
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] flying-to(aircraft, city2 ) . . . ]
problem arises boarding, new fluent boarding(person, aircraft) added
used whenever necessary. Given changes, following first steps
361

fiKvarnstrom & Magnusson

plan generated TALplanner problem instance Figure 4, shown IPC-2002
timed result format timepoint action invoked followed
action instance duration action:
0: (board person1 plane1 city0) [20]
20: (fly plane1 city0 city1 fl4 fl3) [180]
20: (zoom plane1 city0 city1 fl4 fl3 fl2) [100]
Intuitively, flying zooming plane1 time impossible,
forgotten specify planner. actions preconditions satisfied
time 20, prevail conditions, effects actions contradict
since take place different timepoints: fly ends time 200, zoom
ends time 120.
several ways specifying fly zoom mutually exclusive.
example, would possible introduce interval effect stating flying-to(aircraft,
city2 ) must hold throughout inner execution intervals actions, become false
end action:
[t+1,t+179] flying-to(aircraft, city2 ) := true, [t+180] flying-to(aircraft, city2 ) := false // fly
[t+1,t+ 99] flying-to(aircraft, city2 ) := true, [t+100] flying-to(aircraft, city2 ) := false // zoom
would also possible use semaphore resource: aircraft-specific resource
initial value 1, borrowed exclusively fly zoom actions.
one solutions used, TALplanner finally rewards us short correct plan:
0: (board person1 plane1 city0) [20]
20: (fly plane1 city0 city1 fl4 fl3) [180]
200: (board person3 plane1 city1) [20]
200: (debark person1 plane1 city1) [30]
230: (fly plane1 city1 city0 fl3 fl2) [180]
410: (debark person3 plane1 city0) [30]
;; Plan length 6, maxtime 440
improved? Remember STRIPS version never made use zoom
operator. SimpleTime version, flying takes 180 time steps uses one unit
fuel, zooming takes 100 time steps uses two units fuel, refueling one unit
takes 73 time steps. 180 + 73 100 + 2 73 therefore opposite
situation: zoom always better fly. Commenting unwanted fly operator yields
following plan:
0: (board person1 plane1 city0) [20]
20: (zoom plane1 city0 city1 fl4 fl3 fl2) [100]
120: (board person3 plane1 city1) [20]
120: (debark person1 plane1 city1) [30]
150: (zoom plane1 city1 city0 fl2 fl1 fl0) [100]
250: (debark person3 plane1 city0) [30]
;; Plan length 6, maxtime 280

362

fiTALplanner IPC-2002: Extensions Control Rules

5.2.3 ZenoTravel: Timed
Timed version complicates timing actions. Boarding disembarking times constant problem-specific defined respective problem
definition two new functions, boarding-time debarking-time. Refueling always fills
plane maximum capacity, consumes time relative amount fuel received
refuel-rate aircraft. aircraft also fast-speed slow-speed
corresponding fast-burn slow-burn fuel consumption. distances cities
specified using distance(city1, city2 ) function.
Timed version, operator durations correctly calculated precision
three decimals, prompting TALplanner changes discussed Sections 4.5 4.6.
extensions TALplanner implemented, changes needed
transform SimpleTime domain Timed version.
important difference perhaps fact depending speed fuel
consumption values defined problem situation operator used,
sometimes better use fly operator sometimes better use zoom operator,
unlike STRIPS version fly always better SimpleTime domain
zoom always better.
zooming better flying? may seem like would easy answer
question, given interested minimizing time: check whether
refueling aircraft sufficiently able zoom, followed zooming destination,
would faster refueling enough able fly flying slowly
destination. handled first clause use-fly-instead-of-zoom below.
precondition fly altered require use-fly-instead-of-zoom true,
precondition zoom requires use-fly-instead-of-zoom false. interested
minimizing combination time fuel usage, could also taken
account.
quite sufficient handle problems, though. airplane maximum
fuel capacity, destination distant, may able zoom. handled
second clause use-fly-instead-of-zoom.
Yet another problem possible tie one refueling action flight,
one would expect real world. two reasons problem.
First, airplanes may already fuel initial state, situations
plane might zoom destination without incurring additional cost, assuming
time required executing plan metric used plane
already enough fuel anyway never refuel.
Second, unlike SimpleTime version, airplane cannot refuel enough
refuel operator always fills tank completely. change likely introduced
order make planning task easier reducing number possible actions choose
(for example, planner needs create ground instances operator
might trouble refuel operator would take amount fuel floating
point argument). despite probable intention behind change, introduces new
problems control formulas. planes tank half full enough fuel
zoom B, might fill entire tank continuing C,
used fly operator, might able continue C without refueling all.

363

fiKvarnstrom & Magnusson

means one would take possible future flights account determining
whether fly zoom. domain modeled detail, problem would
existed.
Given two complications, guaranteeing optimal near-optimal plan using
control rule easy, indeed expected. competition decided
satisfied heuristic compromise, adding third clause use-fly-instead-of-zoom
ensuring zooming would require refueling immediately flying would not, fly
operator would used.
// Fly (probably) better zoom if:
#define [t] use-fly-instead-of-zoom(aircraft, city1, city2):
// fly faster wrt speed refueling.
([t] (10000 / slow-speed(aircraft) + 10000 * slow-burn(aircraft) / refuel-rate(aircraft)) <
(10000 / fast-speed(aircraft) +10000 * fast-burn(aircraft) / refuel-rate(aircraft)))
// zoom impossible across given distance.
([t] distance(city1 , city2 ) * fast-burn(aircraft) > capacity(aircraft))
// zoom refuel immediately fly not.
([t] fuel(aircraft) >= distance(city1 , city2 ) * slow-burn(aircraft)
fuel(aircraft) < distance(city1 , city2 ) * fast-burn(aircraft))
5.2.4 ZenoTravel: Discussion
Finding control rules yield good (but usually suboptimal) plans difficult
ZenoTravel domain. risks involved flying plane pick passengers
since passengers always fit plane refueling possible city.
words, really possible get stuck looking solution. Also, since
graph cities fully connected, route planning necessary.
fourth version ZenoTravel, called Numeric, available contest due
lack time decided compete domain.
Among things, numeric version contains additional constraint number passengers aircraft carry. first glance, constraint may seem
introduce new problems. However, enforced zoom operator, since
numeric domain make use durational operators, suffers problem
STRIPS domain: zoom operator consumes fuel limits number
passengers, deliver advantages faster flying.
real difficulty Numeric version comes use problem-specific metrics
measure quality solution. example, one problem planner may
required minimize total-time + 3 * total-fuel-used, another problem may
required minimize total-time only. now, usually satisfied finding
plans good optimal quality, done tuning control rules,
example introducing use-fly-instead-of-zoom function determine whether fly
zoom used, discussed above. tuning naturally done domain level
rather problem level. optimizing version TALplanner development.

364

fiTALplanner IPC-2002: Extensions Control Rules

Figure 5: Depots problem instance (STRIPS problem 7)
5.3 Depots Domain
Depots domain (illustrated Figure 5) contains locations, trucks, hoists, movable
crates, pallets whose locations fixed. Trucks move crates two locations
carry number crates time. Hoists distributed among
locations load crates trucks stack crates surfaces (pallets crates).
goal always bring crates certain configuration stacks,
stack placed specific pallet.
STRIPS. Depots domain combination two well-known planning domains,
logistics domain blocks world. Therefore seems natural start taking
look existing control rules two domains, see whether rules
combined easily whether complex rules required due interactions
moving stacking blocks.
begin blocks world part problem. unbounded blocks world
used benchmark domain IPC-2000, TALplanner used modified version
rules Bacchus Kabanza (2000) ensure planner adds blocks
good towers, stacks already final position
dismantled later order remove block lower level. rules reused
Depots domain? One prerequisite availability temporary storage crates,
since worst case every single stack crates must torn completely
possible start stacking crates top other. Fortunately, although
limited number pallets, trucks (somewhat counter-intuitively) contain number
crates, planner use storage. minor changes required
order handle two separate types surfaces: Pallets crates.
Continuing logistics part, one simple rule reused standard
logistics domain: unload crate goal location. dual rule, load crate
needs moved, required. blocks world rules ensure hoist
lift block unless needs moved, therefore already impossible load
blocks truck.
remains ensure vehicles drive locations use.
standard logistics domain, truck drive another location package
365

fiKvarnstrom & Magnusson

Figure 6: DriverLog problem instance (STRIPS problem 5)
needs picked delivered there, due use stacks crates
depots domain, rule must modified: vehicle may drive location (1)
crate must moved another location, (2) crate must
stacked differently, (3) crate truck needs location,
destination ready, crate also location
truck yet picked up.
SimpleTime. SimpleTime version, lifting dropping crates still takes one unit
time, loading takes three units, unloading four, driving ten. changes made
ensure mutual exclusion. example, hoists lift one crate time. Also,
driving-to fluent introduced keep track trucks headed, similar flying-to
ZenoTravel.
Timed. Timed domain, time required loading unloading crate depends powerful hoist weight crate. time required
driving two locations depends speed truck distance
locations. Again, minor changes required handle domains, although
higher quality plans could certainly produced taking timing account
determining hoists trucks use.
5.4 DriverLog Domain
DriverLog (illustrated Figure 6) yet another logistics domain, time introducing
concept truck drivers road maps. number packages transported
locations trucks. two sets routes connecting locations: Links,
trucks travel, paths, drivers walk along driving truck. truck
one driver time load many packages needed.
STRIPS. Several control rules used previous logistics domains useful DriverLog
minor modifications. example, packages loaded trucks
need moved, unloaded reached final destination.
hand, number changes necessary due use road maps.
importantly, vehicles previously allowed drive locations immediately useful packages picked delivered. DriverLog
366

fiTALplanner IPC-2002: Extensions Control Rules

domain may direct roads locations (specified predicate
link(from, to)), truck may move several intermediate locations
order reach destination. Consequently control rules must relaxed allow
trucks visit locations useful themselves. Nevertheless, degree
goal-directedness still required. One possible method identify vehicle
set locations vehicle might useful, require chooses one
location takes shortest path chosen destination. method used
competition help built-in shortest path algorithm discussed Section 4.8 control rule stating step (each invocation drive walk) must
decrease distance current destination. following definitions explained
below:
#define [t] reasonable-truck-location(truck, location):
// Omitted due space constraints
#distfeature driving-distance-between(from, to) :domain integer :link link
#mindistfeature driving-distance-to-location-satisfying-formula
:distfeature driving-distance-between :domain integer
#define [t] driving-distance-to-reasonable-destination(truck, location):
driving-distance-to-location-satisfying-formula(location, to,
[t] reasonable-truck-location(truck, to))
boolean fluent reasonable-truck-location(truck, loc) defined terms logic formula,
specifies whether given location reasonable destination given truck
timepoint evaluated. driving-distance-between function accesses shortest
path algorithm find length shortest path to, given
road links specified link predicate. driving-distance-to-location-satisfyingformula function accesses another version shortest path algorithm used
driving-distance-to-reasonable-destination order find shortest distance location
location satisfies reasonable-truck-location. Since links cost,
sufficient require whenever truck moves, driving-distance-to-reasonabledestination decreases.
changes required due use drivers. may drivers
trucks, packages loaded truck planner knows truck
driver. Drivers disembark still packages truck,
goal truck must somewhere else. Drivers may walk along
paths order reach truck, like trucks, drivers must select one useful destination
take shortest path chosen destinations.
Additional control rules ensure multiple trucks choose destination
unnecessarily, multiple drivers choose walk location.
SimpleTime. SimpleTime version, loading unloading objects takes two units
time, driving takes ten units, walking takes twenty units. operators changed
accordingly, going-to fluent introduced keep track drivers trucks
moving towards new location yet arrived. minor adjustments must
made control rules.
Timed. Timed version, time required walk drive two locations
367

fiKvarnstrom & Magnusson

determined pair functions specified problem instance. Since individual road
segments different lengths, method used ensure drivers trucks used
shortest path current destination longer sufficient, must modified
slightly. this, major changes Timed version.
5.5 Rovers Domain
Rovers domain simulates simplified planetary exploration expedition. lander vessel
carries number rovers planet surface provides communication link back
Earth. rover subset general capabilities, retrieving soil samples, retrieving
rock samples capturing images using cameras support different imaging modes.
cameras mounted rovers, storage compartments, one rover,
hold one soil sample one rock sample. Data sample must sent
lander communication link. missions revolve around navigating waypoints
planets surface collect samples take images specified objectives
visible certain waypoints. terrain may prevent rovers going directly
two waypoints different rovers handle different terrain list routes rover
use provided.
STRIPS. Following control scheme similar one used DriverLog, limit
movements rovers locations perform useful action like collecting
rock sample capturing image. problem finding path one waypoint
another also solved way DriverLog, except rover
set routes waypoints.
SimpleTime. changes SimpleTime version trivial: Operator durations
changed, mutual exclusion relations need enforced, new fluent calibrating(camera) keeps track whether certain camera calibrated.
Timed. Timed version introduces concept energy, rover limited
amount energy action consumes energy. similar
use fuel ZenoTravel domain, also major difference: rovers
equipped solar panels recharge rover, waypoints
rover go directly exposed sun, requirement solar
panels work. airplanes ZenoTravel domain refuel anywhere, fuel
usage relevant terms minimization resource usage, whereas rover uses
energy unwisely get stuck shade, unable anything go anywhere.
prevent either let planner backtrack search better plan,
introduce stricter rules keep energy levels mind deciding rover
allowed do. latter approach taken below.
critical point rover enough energy reach waypoint
sun recharge. Using shortest path algorithm possible control rule
determine distance closest waypoint exposed sun. addition
waypoints previously allowed, also reasonable rover go waypoint
exposed sun rover enough energy perform action
go recharge, exist waypoints affordable
reasonable visit.

368

fiTALplanner IPC-2002: Extensions Control Rules

Figure 7: Satellite problem instance (STRIPS problem 4)
5.6 Satellite Domain
Satellite domain number satellites orbit Earth, equipped set
scientific imaging instruments. satellites turn space, targeting stars, planets interesting phenomena capture images using different instrument operation modes.
modes include regular infrared imaging spectrographic thermographic
readings different problem. planners task schedule series observations satellites used efficiently. Figure 7 shows small example problem
instance, arrows showing directions satellites pointing.
Directions represented explicit coordinates. Instead, satellites turn
new direction giving turn operator argument specifying star, planet
phenomenon satellite point to. Instruments first need activated using
switch on, calibrated calibration target calibrate operator
capture images using take image. satellite enough power operate one
instrument time, switching active instruments always initiated switch
operator deactivate first instrument.
5.6.1 Satellite: STRIPS
Since task consists collecting number images, begin restricting use
take image images mentioned goal.
#control :name only-take-pictures-of-goals
[t] image(direction, mode) [t+1] image(direction, mode)
goal(have image(direction, mode))
next step restrict directions satellites turn may actually help collecting images. task split control rule, only-point-ingoal-directions, definition goal directions. satellite allowed turn towards
direction take picture, calibrate instrument goal specifies satellite

369

fiKvarnstrom & Magnusson

point direction work left do.
#define [t] goal direction(satellite, direction):
[t] take image possible(satellite, direction)
instrument [
[t] power on(instrument) calibrated(instrument)
[t] calibration target(instrument, direction) board(instrument, satellite) ]
goal(pointing(satellite, direction)) [t] images collected
take image possible function checks image collected also
already taken satellite necessary instrumentation
ready. active instrument calibrated, satellite may first turn towards
another direction calibrate it.
#define [t] take image possible(satellite, direction):
mode [ goal (have image(direction, mode))
[t] image(direction, mode)
instrument [
[t] power on(instrument) calibrated(instrument)
[t] board(instrument, satellite) supports(instrument, mode) ]]
switch switch operators still regulated control rules
planner quickly takes habit repeatedly flipping power different instruments
off. instrument powered calibrated, using much
possible switching another instrument seems reasonable. usefulness function,
putting value usefulness particular instrument, helps decide instrument
power first.
#define [t] usefulness(instrument):
value(t, $sum(<mode>, [t] supports(instrument, mode) mode needed goal(mode), 1))
#define [t] mode needed goal(mode):
direction [ goal(have image(direction, mode)) [t] image(direction, mode) ]
Add one usefulness score instrument imaging mode supports
needed goal. score used control rule chooses
satellites useful instrument, any.
#control :name use-the-most-useful-instrument
[t] power on(instrument) [t+1] power on(instrument)
[t] usefulness(instrument) > 0
satellite, instrument2 [
[t] usefulness(instrument2 ) > usefulness(instrument)
[t] board(instrument, satellite) board(instrument2 , satellite) ]
Switching instrument allowed instrument longer required.
#control :name dont-switch-instrument-off-if-you-dont-have-to
[t] power on(instrument) [t+1] power on(instrument))
[t] mode [ supports(instrument, mode) mode needed goal(mode) ]

370

fiTALplanner IPC-2002: Extensions Control Rules

run less obvious improvements, analyzing planner output
reveals one remaining inefficiency: satellites often simultaneously decide turn
direction picture needs taken direction, despite fact
one satellite needs take picture. similar situation ZenoTravel
domain number aircraft may concurrently choose pick passenger,
differences due fact reason satellite point
certain direction order calibrate take image, makes task
somewhat easier.
Therefore problem solved different way, using resource mutual
exclusion. resource, called point towards(direction) capacity 1,
borrowed temporarily turn duration turn. one satellite turns towards
specific direction d, satellite turn towards without causing resource conflict.
still leaves one problem: first satellite finished turning, longer
owns point towards(d) resource therefore another satellite immediately start
turning towards d. longer possible one satellite turn towards
direction once, first satellite taking pictures, satellites
turn direction one one, finally desired pictures taken
direction goal direction sees longer valid reason point
towards d. solved either changing definition goal direction letting
take image borrow resource.
Clearly, type swarming problem occurs quite often concurrent domains
principled solution investigated future.
5.6.2 Satellite: SimpleTime
SimpleTime version changes duration operators. Turning takes five time
units, switching instrument takes two units, calibrating takes five units taking picture takes seven units. couple helper fluents, turning towards, calibrating,
image generalized (an image exists taken) power generalized (power
switch action executed) keep track actions begun
completed. affected control rules updated accordingly.
5.6.3 Satellite: Timed
Timed version Satellite domain includes two new functions. calibration time
specifies time required calibrate, slew time function represents time
required satellite turn two directions. Neither changes prompts
significant changes SimpleTime control.
5.6.4 Satellite: Discussion
Satellite domain provide real challenge long planner trying
find correct plan. Finding short plan harder, especially Timed version,
would require additional analysis determine order images collected
satellites used image. using control rules seemed
bit like overkill, especially since yet created control rules complex
UMTranslog-2 domain. reason, decided satisfied done
371

fiKvarnstrom & Magnusson

far, surprised plans generated turned considerably
lower quality produced planners.
contest, informed reason, least main reason:
automatic problem generator created problem instances randomized slew times
every pair directions check geometrical consistency would
present real world situation. subconsciously assumed problem instances
satisfied triangle inequality, case, planning teams
discovered this. example, handcoded problem 14, turning satellite directly
phenomenon86 groundstation4 takes 82.860 units time, turning two
carefully selected intermediate directions requires 1.183 units time.
Initial testing shows taking consideration using built-in
shortest path algorithm yields significantly shorter plans plan length measured
time point goals satisfied.
Another potential improvement would change last clause goal direction
allow satellites turn towards direction specified goals soon one started
taking last picture, rather waiting one finished taking last picture.
5.7 UMTranslog-2 Domain
UMTranslog-2 domain another logistics domain, 14 types, 38 predicates,
24 functions 38 operators, size complexity incomparable previously
encountered logistics domains contest.
Since formal domain definition information provided domain
high-level description, work information
domain PDDL definition. major problem previous
domains, since generally quite simple easy understand, give
us problems UMTranslog-2. significant amount time spent trying
determine exactly packages allowed move loaded
unloaded various kinds vehicles. retrospect, would probably better
teams did: Skip UMTranslog-2 domain completely spend
time Numeric Complex versions domains.
domain. Trucks, trains aircraft transport packages locations
must follow strict movement patterns. locations transportation hubs,
transportation centers rest ordinary locations. package allowed
move hierarchy move two locations
layer once. longest possible route package thus ordinary location
transportation center hub another hub transportation center finally
another ordinary location.
domain groups locations cities, grouped regions. Trucks
travel two locations city existing road route
two cities. Trains planes always use predefined routes transportation centers
hubs. great number restrictions complicate movements. Packages must
compatible vehicle loaded into, vehicle must enough free space,
loaded heavily wider, longer higher route destination
location accepts. Finally, locations, vehicles routes must available use.
372

fiTALplanner IPC-2002: Extensions Control Rules

Control rules. previous domains, specify reasonable location limit
vehicle movements destinations reasonable. truck might want pick
deliver package location or, truck cannot reach goal location
package, unload package transportation center picked another vehicle.
control rules allow trucks pick several packages. makes finding
optimal solutions impossible general case simplifies search acceptable
solutions great deal. imminent risk packages truck
carrying end wrong location allowed travel about, picking
packages along way. Since packages must move according specified pattern
transportation centers hubs, moving package arrived location
transportation center allowed package stuck there. Restricting
trucks picking one package time avoids problem.
also large group loading unloading rules controlling, among
things, opening closing valves doors loading unloading packages.
Finally, packages loaded vehicles actually able take useful
location.
Creating control rules meeting contest deadline left time get domain
working concurrent planning. Instead, make sequential planning.
Given time, set control rules could definitely improved. planning speed
less issue, search allowed higher quality plans generated.
better problem instances would needed guidelines developing better control
rules since contest problems make full use intended transportation scheme
transportation centers hubs.

6. Improvements Competition
Though planning competition ended AIPS-2002 conference April, 2002,
work TALplanner naturally cease there. still many improvements
made, couple related development new domains
control rules implemented summer 2002.
6.1 Domain Visualization
discussed description ZenoTravel domain, process creating control
rules planning domain often involves incremental improvements. TALplanner run
number problem instances using one set control rules, possibly without control
rules all, beginning resulting search tree analyzed order determine
bad choices made avoided using new improved control
rules. repeated planner consistently finds plans good quality.
process, one must study output planner also
structure particular problem instance solved. example, DriverLog
problem may necessary draw road network used problem instance
using pen paper, study paths taken trucks, people, packages
road network, order discover whether improvements would possible.
often particular inefficiency appears one large set problem
instances, tracing execution plan hand obviously tedious time
373

fiKvarnstrom & Magnusson

consuming task ought automated far possible.
led development TPVis, generic graphical visualization framework
TALplanner. TPVis framework used generate domain images article,
provides animated display consisting set nodes, node
container atomic object. Containers may represent vehicles (which contain
packages), locations (since vehicles, packages objects location)
similar concepts, atomic nodes may used packages, instruments
satellite, type object displayed. Edges nodes
indicate form relationship objects, obvious interpretation
two location nodes connected transportation route. built-in layout engine
generate layout automatically, manually adjust visual coordinates
node.
visualization framework used concrete plugins adapted specific planning domains. DriverLog plugin, example, displays locations container nodes,
linked paths drivers walk links trucks drive. Trucks also
containers, contained within specific location, shown Figure 6 page 366.
plan generated, TPVis animates actual movements objects
locations. creates better instinctive feel domain, two-dimensional
graph display gives overview difficult provide using text output.
addition animating graph, TPVis simultaneously lists partial plan leading
current state problem goals planner tries satisfy. TPVis also provides
limited form interactive planning since it, point planning process, allows
user force planner backtrack explore different search branch.
development TPVis initiated planning contest.
graphical visualization available work contest domains, would
saved lot time, possibly tree two.
6.2 Automatic translation PDDL TALplanner
Although obvious automatic translator PDDL TALplanners input format, always urgent features implemented,
instead decided translate IPC-2002 domains hand. retrospect mistake. risk making error somewhere translation becomes imminent
dealing complex domains UMTranslog-2, 38 operators,
highly complex preconditions. Also, translating long formulas hand quite time
consuming. semi-automatic translator therefore implemented decrease amount
work involved translation process reduce risk introducing errors
definition.

7. Discussion Conclusions
third International Planning Competition major step forward terms
expressibility required represent benchmark domains, provided number
interesting challenges planner wanted participate competition.
article described challenges affected TALplanner shown number
extensions made order meet challenges. article also includes
374

fiTALplanner IPC-2002: Extensions Control Rules

number domain-dependent control rules competition domains, rather
presenting exhaustive list pre-packaged control rules, attempted place
emphasis explaining incremental analysis process eventually leads final
formulas, going particular detail ZenoTravel domain.
could seen examples shown paper, control rules often simple,
natural common-sense rules, difficult generate given basic knowledge planning domain. rules complex, still difficult
understand verify someone spent effort generate them. then, unfortunately, rules quite unintuitive, rules complex
easily understood, rules occasionally forbid optimal plans.
extent, rules might avoided gaining experience good practices
writing control rules, extending expressivity language control
rules written complex conditions expressed succinctly
natural manner, simply spending little bit time control rules
available planning competition much time spent teaching
working planner implementation. However, another important cause
complexity certain rules probably attempting express search control
knowledge way: control rules prune search tree great
extent even simple depth-first search algorithm sufficient efficiently finding good
plans remainder tree.
search control knowledge easily expressed manner, certainly mean control rules abandoned altogether. Instead,
learn experience control rules might one multi-purpose
planning tool efficiently easily solve planning problems. Instead,
like one would expect, one useful tool deserves place toolbox
combined approaches planning. mention one rather obvious
example, would possible devise heuristic forward-chaining planner whose search
tree would pre-pruned using control rule techniques TALplanner. Control rules
could written exclude plans heuristic gives suboptimal result, potentially
providing plans closer optimal, even domains heuristic search
function provides good plans may often efficient state number constraints
explicit control rules.
extensions TALplanner considered least since time
second planning competition 2000, long clear us approach eventually examined explored. could start working this,
though, strengths weaknesses control rules explored depth.
now, work therefore focused mostly investigating far possible
take TALplanner current shape, explicit control rules means
controlling search process. work proved rather fruitful itself, TALplanner well IPC-2000 well IPC-2002. planner becoming reasonably
mature, improvements made planner
released general use, might time take step back consider relation
approaches depth done previously order investigate
possible advantages hybrid approaches.
course, mean nothing done within pure
375

fiKvarnstrom & Magnusson

TALplanner framework. contrary, many additional topics pursued,
including investigating application TALplanner plan optimization problems (where
simplest approaches might involve applying standard optimal graph search algorithms pruned search tree generated TALplanner) extending planner
handle incomplete knowledge non-deterministic operators. many topics
next focus research yet determined.

Acknowledgements
research supported part WITAS Project Wallenberg Foundation.

References
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116 (12), 123191.
Doherty, P. (1994). Reasoning action change using occlusion. Cohn, A. G.
(Ed.), Proceedings 11th European Conference Artificial Intelligence (ECAI94), pp. 401405. John Wiley Sons. Available ftp://ftp.ida.liu.se/pub/labs/
kplab/people/patdo/ecai94.ps.gz.
Doherty, P., Gustafsson, J., Karlsson, L., & Kvarnstrom, J. (1998). TAL: Temporal Action
Logics language specification tutorial. Electronic Transactions Artificial
Intelligence, 2 (34), 273306. Available http://www.ep.liu.se/ej/etai/1998/009/.
Doherty, P., & Kvarnstrom, J. (1999). TALplanner: empirical investigation temporal
logic-based forward chaining planner. Dixon, C., & Fisher, M. (Eds.), Proceedings
6th International Workshop Temporal Representation Reasoning, pp. 47
54. IEEE Computer Society. Available ftp://ftp.ida.liu.se/pub/labs/kplab/people/
patdo/time99-final.ps.gz.
Doherty, P., & Kvarnstrom, J. (2001). TALplanner: temporal logic-based planner. AI
Magazine, 22 (3), 95102.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. Journal Artificial Intelligence Research, issue.
Gustafsson, J., & Doherty, P. (1996). Embracing occlusion specifying indirect effects
actions. Aiello, L. C., Doyle, J., & Shapiro, S. C. (Eds.), Proceedings 5th
International Conference Principles Knowledge Representation Reasoning
(KR-96), pp. 8798, San Francisco. Morgan Kaufmann Publishers. Available ftp:
//ftp.ida.liu.se/pub/labs/kplab/people/patdo/final-kr96.ps.gz.
Karlsson, L., & Gustafsson, J. (1999). Reasoning concurrent interaction. Journal
Logic Computation, 9 (5), 623650.
Kibler, D., & Morris, P. (1981). Dont stupid. Hayes, P. J. (Ed.), Proceedings
7th International Joint Conference Artificial Intelligence (IJCAI-81), pp. 345347.
Kvarnstrom, J., & Doherty, P. (2003). TALplanner project page. http://www.ida.liu.se/
patdo/aiicssite1/kplab/projects/talplanner/.

376

fiTALplanner IPC-2002: Extensions Control Rules

Kvarnstrom, J., & Doherty, P. (2000). TALplanner: temporal logic based forward chaining
planner. Annals Mathematics Artificial Intelligence, 30, 119169.
Kvarnstrom, J., Doherty, P., & Haslum, P. (2000). Extending TALplanner concurrency
resources. Horn, W. (Ed.), Proceedings 14th European Conference
Artificial Intelligence (ECAI-2000), Vol. 54 Frontiers Artificial Intelligence
Applications, pp. 501505, Amsterdam. IOS Press. Available ftp://ftp.ida.liu.se/
pub/labs/kplab/people/patdo/www-ecai.ps.gz.
Kvarnstrom, J. (2002). Applying domain analysis techniques domain-dependent control
TALplanner. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings
Sixth International Conference Artificial Intelligence Planning Scheduling
(AIPS-2002), pp. 101110. AAAI Press, Menlo Park, California.
Long, D., & Fox, M. (2003). 3rd international planning competition: Results
analysis. Journal Artificial Intelligence Research, issue.

377

fiJournal Artificial Intelligence Research 20 (2003) 155-194

Submitted 10/2002; published 12/2003

Sapa: Multi-objective Metric Temporal Planner
Minh B.
Subbarao Kambhampati

BINHMINH @ ASU . EDU
RAO @ ASU . EDU

Department Computer Science Engineering
Arizona State University, Tempe AZ 85287-5406

Abstract
Sapa domain-independent heuristic forward chaining planner handle durative actions, metric resource constraints, deadline goals. designed capable handling
multi-objective nature metric temporal planning. technical contributions include (i)
planning-graph based methods deriving heuristics sensitive cost makespan
(ii) techniques adjusting heuristic estimates take action interactions metric resource
limitations account (iii) linear time greedy post-processing technique improve execution flexibility solution plans. implementation Sapa using many techniques
presented paper one best domain independent planners domains metric
temporal constraints third International Planning Competition, held AIPS-02. describe technical details extracting heuristics present empirical evaluation
current implementation Sapa.

1. Introduction
success Deep Space Remote Agent experiment demonstrated promise importance metric temporal planning real-world applications. HSTS/RAX, planner used
remote agent experiment, predicated availability domain- planner-dependent
control knowledge, collection maintenance admittedly laborious errorprone activity. obvious question whether possible develop domain-independent
metric temporal planners capable scaling domains. past experience
particularly encouraging. Although ambitious attemptsincluding
IxTeT (Ghallab & Laruelle, 1994) Zeno (Penberthy & Well, 1994), performance
particularly satisfactory.
encouraging signs however recent successes domain-independent heuristic planning techniques classical planning (c.f., Nguyen, Kambhampati, & Nigenda, 2001; Bonet, Loerincs, & Geffner, 1997; Hoffmann & Nebel, 2001). research aimed building
successes develop scalable metric temporal planner. first blush search control metric
temporal planners would seem simple matter adapting work heuristic planners classical planning (Bonet et al., 1997; Nguyen et al., 2001; Hoffmann & Nebel, 2001).
adaptation however pose several challenges:
Metric temporal planners tend significantly larger search spaces classical planners. all, problem planning presence durative actions metric resources subsumes classical planning certain class scheduling problems.

c
2003
AI Access Foundation. rights reserved.

fiD & K AMBHAMPATI

Compared classical planners, handle logical constraints
actions, metric temporal planners deal many additional types constraints
involve time continuous functions representing different types resources.
contrast classical planning, objective find shortest length plans,
metric temporal planning multi-objective. user may interested improving either
temporal quality plan (e.g. makespan) cost (e.g. cumulative action cost, cost
resources consumed etc.), generally, combination thereof. Consequently, effective
plan synthesis requires heuristics able track aspects evolving plan.
Things complicated fact aspects often inter-dependent.
example, often possible find cheaper plan achieving goals, allowed
time achieve them.
paper, present Sapa, heuristic metric temporal planner currently developing address challenges. Sapa forward chaining planner, searches
space time-stamped states Sapa handles durative actions well actions consuming continuous resources. main focus development heuristics focusing Sapas
multi-objective search. heuristics derived optimistic reachability information
encoded planning graph. Unlike classical planning heuristics (c.f., Nguyen et al., 2001)),
need estimate length plan needed achieve set goals, Sapas heuristics
need sensitive cost length (makespan) plans achieving goals.
contributions include:
present novel framework tracking cost literals (goals) function time.
cost functions used derive heuristics capable directing
search towards plans satisfy type cost-makespan tradeoffs.
Sapa generalizes notion phased relaxation used deriving heuristics planners
AltAlt FF (Nguyen et al., 2001; Hoffmann & Nebel, 2001). Specifically,
heuristics first derived relaxation ignores delete effects metric resource
constraints, adjusted subsequently better account negative interactions
resource constraints.
Sapa improves temporal flexibility solution plans post-processing plans
produce order constrained (o.c partially-ordered) plans. way, Sapa able exploit
ease resource reasoning offered position-constrained plans execution flexibility offered precedence-constrained plans. present linear time greedy
approach generate o.c plan better equal makespan value compared given p.c
plan.
Architecture Sapa: Figure 1 shows high-level architecture Sapa. Sapa uses forward
chaining A* search navigate space time-stamped states. evaluation function (the
f (.) function multi-objective sensitive makespan action cost. state
picked search queue expanded, Sapa computes heuristic estimates
resulting children states. heuristic estimation state based (i) computing relaxed
temporal planning graph (RTPG) S, (ii) propagating cost achievement literals
156

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Planning Problem
Select state
lowest f -value

Generate
start state

Queue Time Stamped states

f
Cost & Makespan
components

Satisfies
Goals?

Yes


Partialize
p.c. plan

Expand state
applying
actions

Build RTPG
Propagate Cost
functions
Extract relaxed plan
Adjust
Mutexes ; Resources

Return
o.c p.c plans
Heuristic
estimation

Figure 1: Architecture Sapa
RTPG help time-sensitive cost functions (iii) extracting relaxed plan P r supporting
goals problem (iv) modifying structure P r adjust mutex resourcebased interactions. Finally, P r used basis deriving heuristic estimate S.
search ends state 0 selected expansion satisfies goals. case, Sapa postprocesses position-constrained plan corresponding state convert order
constrained plan. last step done improve makespan well execution flexibility
solution plan.
version Sapa using subset techniques discussed paper performed well
domains metric temporal constraints third International Planning Competition, held
AIPS 2002 (Fox & Long, 2002). fact, best planner terms solution quality
number problems solved highest level PDDL2.1 used competition domains
Satellite Rovers. domains inspired NASA applications.
Organization: paper organized follows: Section 2 discuss details action
problem representation, forward state space search algorithm used produce concurrent
metric temporal plans durative actions. Section 3, address problem propagating
time cost information temporal planning graph. Section 4 shows propagated
information used estimate cost achieving goals given state. also
discuss section mutual exclusion relations resource information help improve
heuristic estimation. improve quality solution, Section 6 discusses greedy

157

fiD & K AMBHAMPATI

approach building precedence-constrained plan position-constrained plan returned
Sapa. Section 7 discusses implementation Sapa, presents empirical results
Sapa produces plans tradeoffs cost makespan, analyzes performance
2002 International Planning Competition (IPC 2002). present discussion related work
Section 9 conclude Section 10.

2. Handling Concurrent Actions Forward State Space Planner
Sapa addresses planning problems involve durative actions, metric resources, deadline
goals. section, describe planning problems represented solved
Sapa. first describe action representation, present forward chaining state search
algorithm used Sapa.
2.1 Action Representation & Constraints
Planning problem finding set actions start times execution satisfy
causal, metric, resource constraints. section, briefly describe representation,
extension action representation PDDL2.1 Level 3 (Fox & Long, 2001),
expressive representation level used third international competition. extensions
PDDL2.1 are: (i) interval preconditions; (ii) delayed effects happen time points
actions start end time points; (iii) deadline goals.
shall start example illustrate action representation simple temporal planning problem. problem variations used running examples throughout
rest paper. Figure 2 shows graphically problem description. problem, group
students Tucson need go Los Angeles (LA). two car rental options. students rent faster expensive car (Car1), go Phoenix (PHX) Las Vegas
(LV). However, decide rent slower cheaper Car2, use drive
Phoenix directly LA. Moreover, reach LA, students also take train LV
flight PHX. total, 6 movement actions domain: drive-car1-tucson-phoenix
c1
c1
(Dtp
, Dur = 1.0, Cost = 2.0), drive-car1-tucson-lv (D tlv
, Dur = 3.5, Cost = 3.0), drive-car2c2
c2
tucson-phoenix (Dtp , Dur = 1.5, Cost = 1.5), drive-car2-tucson-la (D tla
),Dur = 7.0, Cost =
6.0, fly-airplane-phoenix-la (Fpla , Dur = 1.5, Cost = 6.0), use-train-lv-la (T lvla , Dur = 2.5,
Cost = 2.5). move action (by car/airplane/train) two cities X requires
precondition students X (at(X)) beginning A. also two temporal
effects: at(X) occurs starting time point at(Y ) end time point A. Driving
flying actions also consume different types resources (e.g fuel) different rates depending
specific car airplane used. addition, refueling actions cars airplanes.
durations refueling actions depend amount fuel remaining vehicle
refueling rate. summaries action specifications example shown right
side Figure 2. example, costs moving train airplane respective ticket
prices, costs moving rental cars include rental fees gas (resource) costs.
illustrated example, unlike actions classical planning, planning problems
temporal resource constraints, actions instantaneous durations. action
duration DA , starting time SA , end time (EA = SA + DA ). value DA
statically defined domain, statically defined particular planning problem,
dynamically decided time execution. example, traveling domain discussed
158

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Train
Las Vegas
LA

Tucson
Car1
Car2

Phoenix
Airplane

Figure 2: travel example
above, boarding passenger always takes 10 minutes problems domain. Duration
action flying airplane two cities depends distance two cities
speed airplane. distance two cities change time,
duration particular flying action totally specified parse planning problem.
However, refueling airplane duration depends current fuel level airplane.
may able calculate duration given refueling action according fuel level
exact time instant action executed.
action preconditions P re(A) may required either instantaneously
true time point SA EA , required true starting remain true
duration DA . logical effects Eff(A) divided two sets E (A), Ed (A)
containing, respectively, instantaneous effects time points , delayed effects SA +
d, DA . PDDL2.1, must equal DA durative preconditions delayed effects.
Actions also consume produce metric resources preconditions may also depend
values resources. resource related preconditions, allow several types
equality inequality checking including ==, <, >, <=, >=. resource-related effects, allow
following types change (update): assignment(=), increment(+=), decrement(-=), multiplication(*=), division(/=). essence, actions consume produce metric resources
way specified PDDL2.1.
2.2 Forward Chaining Search Algorithm metric temporal planning
Variations action representation scheme described previous section used
partial order temporal planners IxTeT (Ghallab & Laruelle, 1994) Zeno (Penberthy
& Well, 1994). Bacchus Ady (2001) first propose forward chaining algorithm
capable using type action representation still allow concurrent execution actions
plan. adopt generalize search algorithm Sapa. main idea separate
decisions action apply time point apply action. Regular
progression search planners apply action state resulting application
actions current prefix plan. means start time new action end
time last action prefix, resulting plan allow concurrent execution.
contrast, Sapa non-deterministically considers (a) application new actions current time

159

fiD & K AMBHAMPATI

stamp (where presumably actions already applied; thus allowing concurrency)
(b) advancement current time stamp.
Sapas search thus conducted space time stamped states. define time
stamped state tuple = (P, M, , Q, t) consisting following structure:
P = (hpi , ti | ti t) set predicates pi true ti last time instant
achieved.
set values continuous functions, may change course planning. Functions used represent metric-resources continuous values. Examples functions fuel levels vehicles.
set persistent conditions, durative preconditions, need protected
specific period time.
Q event queue containing set updates scheduled occur specified time
future. event e one three things: (1) change True/False value
predicate, (2) update value function representing metric-resource, (3) end
persistence condition.
time stamp
paper, unless noted otherwise, say state mean time stamped state. Note
time stamped state stamp describes expected snapshot world time
execution (as done classical progression planners), also delayed (but inevitable)
effects commitments made (or before) time t.
initial state Sinit time stamp = 0 empty event queue empty set
persistent conditions. completely specified terms function predicate values. goals
represented set 2-tuples G = (hp 1 , t1 i...hpn , tn i) pi ith goal ti
time instant pi needs achieved. Note PDDL2.1 allow specification
goal deadline constraints.
Goal Satisfaction: state = (P, M, , Q, t) subsumes (entails) goal G hp , ti
G either:
1. hpi , tj P , tj < ti event Q deletes p .
2. e Q adds pi time instant te < ti , event Q deletes p .1
Action Applicability: action applicable state = (P, M, , Q, t) if:
1. logical (pre)conditions satisfied P.
2. metric resource (pre)conditions satisfied M. (For example, condition
execute action = move(truck, A, B) f uel(truck) > 500 executable
value v f uel(truck) satisfies v > 500.)
1. practice, conflicting events never put Q

160

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

3. effects interfere persistent condition event Q.
4. event Q interferes persistent preconditions A.
Interference: Interference defined violation following conditions:
1. Action add event e causes p another event currently Q
causes p. Thus, never state two events event queue
cause opposite effects.
2. deletes p p protected time point p , delete p tp .
3. persistent precondition p, event gives p, event
occur terminates.
4. change value function currently accessed another unterminated action2 . Moreover, also access value function
currently changed unterminated action.
first glance, first interference condition seems overly strong. However, argue necessary keep underlying processes cause contradicting state changes
overlapping other. example, suppose two actions 1 = build house,
A2 = destroy house Dur(A1 ) = 10, Dur(A2 ) = 7. A1 effect house A2
effect house end time points. Assuming 1 applied time = 0
added event e = Add(has house) = 10. allowed apply 2 time = 0
add contradicting event e0 = Delete(has house) = 7, unreasonable believe
still house time = 10 anymore. Thus, even though current action modeling, state changes cause house house look happen instantaneously
actions end time points, underlying processes (build/destroy house) span
whole action durations make happen. prevent contradicting processes overlapping other, employ conservative approach letting Q contain contradicting
effects.3
apply action state = (P, M, , Q, t), instantaneous effects
immediately used update predicate list P metric resources database S. persistent
preconditions delayed effects put persistent condition set event queue Q
S.
Besides normal actions, special action called advance-time use
advance time stamp time instant e earliest event e event queue Q S.
advance-time action applicable state non-empty event queue. Upon
2. Unterminated actions ones started time point current state yet finished
t.
3. may argued cases process give certain effect, situations
contradicting processes allowed overlap. However, without ability explicitly specify processes
characteristics action representation, currently decided go conservative approach.
also mention interference relations preclude condition established
deleted course plan long processes involved establishment deletion overlap.
example above, legal first build house destroy it.

161

fiD & K AMBHAMPATI

State Queue: SQ={Sinit }
SQ6={}
S:= Dequeue(SQ)
Nondeterministically select applicable
/* advance-time action */
:= Apply(A,S)
satisfies G PrintSolution
else Enqueue(S,SQ)
end while;
Figure 3: Main search algorithm
applying action, state gets updated according events event queue
scheduled occur te . Note apply multiple non-interfering actions given time
point applying special advance-time action. allows concurrency final plan.
Search algorithm: basic algorithm searching space time stamped states shown
Figure 3. proceed applying applicable action current state put resulting
state sorted queue using Enqueue() function. Dequeue() function used take
first state state queue. Currently, Sapa employs A* search. Thus, state queue
sorted according heuristic function measures difficulty reaching goals
current state. Next several sections paper discuss design heuristic functions.
Example: illustrate different data structures search state = (P, M, , Q, t)
maintained search, use (simpler) variation ongoing example introduced
end Section 2.1. variation, eliminate route Tucson Los Angeles (LA)
going Las Vegas. Moreover, assume many students fit one car
divided two groups. first group rents first car, goes Phoenix (Phx),
flies LA. second group rents second car drives directly LA.
trip Tucson LA long, second car needs refueled driving.
make problem simpler, eliminate boarding/un-boarding actions assume
students reach certain place (e.g. Phoenix) means transportation (e.g. Car1)
arrives there. Figure 4 shows graphically plan search state Ss components change
go forward. example, assume ref uel(car) action refuels car maximum
20 gallons. Drive(car, ucson, P hoenix) takes 8 gallons gas Drive(car, ucson, LA)
takes 16 gallons. Note that, time point 1 , event e1 increases fuel level car2 20 gallons.
However, immediately following application action 3 reduces f uel(car2) back lower
level 4 gallons.

3. Propagating Time-sensitive Cost Functions Temporal Planning Graph
section, discuss issue deriving heuristics, sensitive time cost,
guide Sapas search algorithm. important challenge finding heuristics support multiobjective search, illustrated example below, cost temporal aspects
plan often inter-dependent. Therefore, section, introduce approach tracking

162

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Init: at(Car1,T), at(Car2,T), at(Plane,Phx), fuel(Car1)=10, fuel(Car2)=10
Activate: e1
Apply: A3

Activate: e2
Apply: A4

Activate: e4
Apply:

Activate: e3
Apply:

P: {(at(Car2,T),0),
(at(Plane,Phx),0)}

{(at(Plane,Phx),0)}

{(at(Car1,Phx),t2)}

{(at(Car1,Phx),t2),
(at(Plane,LA),t3)}

{(at(Car1,Phx),t2),
(at(Plane,LA),t3),
(at(Car2,LA),t4)}

M: {fuel(Car1)=2,
fuel(Car2)=10}

{fuel(Car1)=2,
fuel(Car2)=4}

{fuel(Car1)=2,
fuel(Car2)=4}

{fuel(Car1)=2,
fuel(Car2)=4}

{fuel(Car1)=2,
fuel(Car2)=4}

3: {(fuel(Car1),t2),
(fuel(Car2),t1),
(at(Car2,T)}

{(fuel(Car1),t2),
(fuel(Car2),t4}

{(fuel(Car2),t4)}

{(fuel(Car2),t4)}

{(fuel(Car2),t4)}

Q: {e1:(fuel(Car2)=20,t1),
e2:(at(Car1,Phx),t2)}

{e2:(at(Car1,Phx),t2),
e3:(at(Car2,LA),t4)}

{e3:(at(Car2,LA),t4), {e3:(at(Car2,LA),t4)}
e4:(at(Plane,LA),t3)}

Activate:
Apply: A1, A2

A1 = Refuel(car2)

A3 = Drive(car2,Tucson,LA)

A2 = Drive(car1,Tucson,Phx)

t=0

{}

t1

A4 = Fly(Phx,LA)

t2

t3

t4

Figure 4: example showing different datastructures representing search state =
(P, M, , Q) change advance time stamp, apply actions activate events.
top row shows initial state. second row shows events actions
activated executed given time point. lower rows show search
state = (P, M, , Q) changes due action application. Finally, show graphically
durative actions plan.

costs achieving goals executing actions plan functions time. propagated cost
functions used derive heuristic values guide search Sapa.
Example: Consider simpler version ongoing example. Suppose need go
Tucson Los Angeles two transport options: (i) rent car drive Tucson Los
Angeles one day $100 (ii) take shuttle Phoenix airport fly Los Angeles
3 hours $200. first option takes time (higher makespan) less money,
second one clearly takes less time expensive. Depending specific weights
user gives criterion, may prefer first option second vice versa. Moreover,
users decision may also influenced constraints time cost imposed
final plan. example, needs Los Angeles six hours, may forced
choose second option. However, plenty time limited budget, may
choose first option.

163

fiD & K AMBHAMPATI

simple example shows makespan execution cost, nominally independent other, nevertheless related terms overall objectives user
constraints given planning problem. specifically, given makespan threshold (e.g.
LA within six hours), certain estimated solution cost tied (shuttle fee
ticket price LA) analogously given cost threshold certain estimated time tied
it. Thus, order find plans good respect cost makespan, need
develop heuristics track cost set (sub)goals function time.
Given planning graph excellent structure represent relation facts
actions (c.f., Nguyen et al., 2001), use temporal version planning graph structure,
introduced TGP (Smith & Weld, 1999), substrate propagating cost
information. Section 3.1, start brief discussion data structures used cost
propagation process. continue details propagation process Section 3.2,
criteria used terminate propagation Section 3.3.
3.1 Temporal Planning Graph Structure
adapt notion temporal planning graphs, introduced Smith Weld (1999),
action representation. temporal planning graph given problem bi-level graph,
one level containing facts, containing actions planning problem.
fact links actions supporting it, action links facts belong
precondition effect lists.4 Actions durative effects represented events
occur time actions start end time points. see detail
later parts section, build temporal planning graph incrementally increasing
time (makespan value) graph. given time point t, action activated
preconditions achieved t. support delayed effects activated actions (i.e.,
effects occur future time points beyond t), also maintain global event queue
entire graph, Q = {e1 , e2 , ...en } sorted increasing order event time. event queue
temporal graph differs event queue search state (discussed previous
section) following ways:
associated whole planning graph (rather single state).
contains positive events. Specifically, negative effects resource-related
effects actions entered graphs queue.
events Q event costs associated individual event (see below).
event Q 4-tuple e = hf, t, c, Ai which: (1) f fact e add; (2)
time point event occur; (3) c cost incurred enable execution
action causes e. action A, introduce cost function C(A, t) = v specify
estimated cost v incur enable execution time point t. words, C(A, t)
estimate cost incurred achieve preconditions time point t. Moreover,
action also execution cost (C exec (A)), cost incurred executing
4. bi-level representation used classical planning save time space (Long & Fox, 1998),
Smith & Weld (1999) show, makes even sense temporal planning domains actually
notion level. set fact/action nodes, one encoding information earliest time
point fact/action achieved/executed, lowest cost incurred achieve them.

164

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Function Propagate Cost
Current time: tc = 0;
Apply(Ainit , 0);
Termination-Criteria 6= true
Get earliest event e = hfe , te , ce , Ae Q;
tc = e ;
ce < C(f, tc )
Update: C(f, t) = ce
action A: f P recondition(A)
N ewCostA = CostAggregate(A, tc );
N ewCostA < C(A, tc )
Update: C(A, t) = N ewCost(A), tc < ;
Apply(A, tc );
End Propagate Cost;
Function Apply(A, t)
effect add f SA +

Q = Q {e = hf, + d, C(A, t) + Cexec (A), Ai};
End Apply(A, t);

Figure 5: Main cost propagation algorithm
(e.g. ticket price fly action, gas cost driving car). fact f , similar cost function
C(f, t) = v specifies estimated cost v incurred achieve f time point (e.g. cost incurred
Los Angeles 6 hours). also need additional function SA(f, t) = f specify
action Af used support f cost v time point t.
Since using relaxed planning graph constructed ignoring delete effects,
resource effects, derived heuristics sensitive negative interactions resource
restrictions. Sections 5.1 5.2 discuss heuristic measures adjusted take
interactions account.
3.2 Cost Propagation Procedure
mentioned above, general approach propagate estimated costs incurred achieve
facts actions initial state. first step, need initialize cost functions C(A, t)
C(f, t) facts actions. given initial state init , let F = {f1 , f2 ...fn } set
0 , )}, set outstanding positive
facts true time point init {(f10 , t1 ), ...(fm

0
events specify addition facts f time points ti > tinit . introduce dummy action
Ainit represent Sinit Ainit (i) requires preconditions; (ii) cost C exec (Ainit ) = 0
(iii) causes events adding f tinit fi0 time points ti . beginning (t = 0),
event queue Q empty, cost functions facts actions initialized as: C(A, t) =
, C(f, t) = , 0 < , Ainit action applicable.
Figure 5 summarizes steps cost propagation algorithm. main algorithm contains
two interleaved parts: one applying action activating event representing
actions effect.

165

fiD & K AMBHAMPATI

Action Introduction: action introduced planning graph, (1) augment
event queue Q events corresponding effects, (2) update cost function
C(A, t) A.
Event Activation: event e = hf e , te , Ce , Ae Q, represents effect e
occurring time point te adding fact fe cost Ce activated, cost function fact
fe updated Ce < C(fe , te ). Moreover, newly improved cost f e leads reduction
cost function action f e supports (as decided function CostAggregate(A, t)
line 11 Figure 5) (re)apply graph propagate f e new cost achievement
cost functions effects.
given time point t, C(A, t) aggregated cost (returned function CostAggregate(A, t))
achieve preconditions. aggregation done different ways:
1. Max-propagation:
C(A, t) = ax{C(f, t) : f P recond(A)}
2. Sum-propagation:
P
C(A, t) = {C(f, t) : f P recond(A)}
first method assumes preconditions action depend cost
achieve equal cost achieve costliest one. rule leads underestimation C(A, t) value C(A, t) admissible. second method (sum-propagation)
assumes facts independent thus inadmissible subgoals positive interactions. classical planning scenarios, sum combination proved effective
admissible much less informed max combination (Nguyen et al., 2001; Bonet et al., 1997).
cost function one preconditions given action updated (lowered),
CostAggregate(A, t) function called uses one methods described calculate
cost required execute action improved (been reduced). 5 C(A, t) improved,
re-apply (line 12-14 Figure 5) propagate improved cost C(A, t) cost
functions C(f, t) effects.
remaining issue main algorithm illustrated Figure 5 termination criteria propagation, discussed detail Section 3.3. Notice way
update cost functions facts actions planning domains described shows
challenges heuristic estimation temporal planning domains. actions effects
occur instantaneously actions starting time, concurrent actions overlap many possible
ways thus cost functions, represent difficulty achieving facts actions
time-sensitive.
demonstrating cost propagation process ongoing example, make two observations propagated cost function:
Observation 1: propagated cost functions facts actions non-increasing time.
Observation 2: increase time steps going events event queue,
cost functions facts actions step-functions, even though time measured
continuously.
5. Propagation rule (2) (3) improve (lower) value C(A, t) cost function one preconditions improved. However, rule (1), value C(A, t) improved cost function costliest
precondition updated.

166

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Figure 6: Timeline represent actions earliest possible execution times relaxed temporal planning graph.

Figure 7: Cost functions facts actions travel example.

167

fiD & K AMBHAMPATI

first observation, estimated cheapest cost achieving given goal g time point
tg C(g, tg ). need look value C(g, t) time point < g . second
observation helps us efficiently evaluating heuristic value objective function f involving
time cost. Specifically, need compute f (finite number of)time points
cost function fact action changes. come back details heuristic
estimation routines Section 4.
Returning running example, Figure 6 shows graphically earliest time point
action applied (C(A, t) < ) Figure 7 shows cost function facts/actions
change time increases. outline update process example: time point
c1
c2
c1
c2
= 0, four actions applied. tp
, Dtp
, Dtlv
, Dtla
. actions add 4 events
c1
c2
i,
event queue Q = {e1 = hat phx, = 1.0, c = 2.0, Dtp i, e2 = hat phx, 1.5, 1.5, Dtp
c1
c2
e3 = hat lv, 3.5, 3.0, Dtlv i, e4 = hat la, 7.0, 6.0, Dtla i}. advance time =
1.0, first event e1 activated C(at phx, t) updated. Moreover, phx
precondition Fpla , also update C(Fpla , t) te = 1.0 2.0 put event
e = hat la, 2.5, 8.0, Fpla i, represents Fpla effect, Q. go
c2
second event hat phx, 1.5, 1.5, Dtp
lower cost fact phx action F pla . Event
e = hat la, 3.0, 7.5, Fpla added result newly improved cost F pla . Continuing
process, update cost function la time point = 2.5, = 3.0
delayed effects actions Fpla occur. time point = 3.5, update cost value lv
action Tlvla introduce event e = hat la, 6.0, 5.5, lvla i. Notice final event
c2
c2
representing delayed effect action tla
applied = 0
e0 = hat la, 7.0, 6.0, Dtla
cause cost update. cost function la updated value
c = 5.5 < ce0 time = 6.0 < te0 = 7.0.
Besides values cost functions, Figure 7 also shows supporting actions (SA(f, t),
defined Section 3.1) fact (goal) la. see action lvla gives best cost
C(at la, t) = 5.5 6.0 action F pla gives best cost C(at la, t) = 7.5 3.0 < 5.5
C(at la, t) = 8.0 2.5 < 3.0. right graph Figure 7 shows similar cost
functions actions example. show cost functions actions lvla
Fpla four actions already applicable time point init = 0 thus
cost functions stabilize 0.
3.3 Termination Criteria Cost Propagation Process
section, discuss issue terminate cost propagation process.
first thing note cost propagation ways inherently complex makespan
propagation. example, set literals enter planning graph (and mutually
exclusive), estimate makespan shortest plan achieving change
continue expand planning graph. contrast, estimate cost cheapest
plan achieving change planning graph levels off. need
carefully consider effect different criteria stopping expansion planning graph
accuracy cost estimates. first intuition stop propagation
exist top level goals cost achievement still infinite (unreached goal).
hand, given objective function finding cheapest way achieve goals,
need continue propagation chance improve cost achieving

168

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

goals. intuitions, following several rules used determine
terminate propagation:
Deadline termination: propagation stop time point if: (1) goal G : Deadline(G)
t, (2) goal G : (Deadline(G) < t) (C(G, t) = ).
first rule governs hard constraints goal deadlines. implies
propagate beyond latest goal deadline (because cost estimation beyond point useless),
achieve goal deadline.
observation propagated costs change still events
left queue possibly change cost functions specific propositions,
second general termination rule regarding propagation:
Fix-point termination: propagation stop events decrease cost proposition.
second rule qualification reaching fix-point gain cost
function fact action. analogous idea growing planning graph
levels-off classical planning.
Stopping propagation according two general rules leads us best (lowest
value) achievable cost estimation propositions given specific initial state. However,
several situations may want stop propagation process earlier. First, propagation
fix-point, gain cost function fact action, would
costly (c.f., Nguyen et al., 2001). Second, cost functions goals may reach fixpoint long full propagation process terminated according general rules discussed
above, costs propositions actions stabilize.
Given motivations, introduce several different criteria stop propagation
earlier entailed fix-point computation:
Zero-lookahead approximation: Stop propagation earliest time point
goals reachable (C(G, t) < ).
One-lookahead approximation: earliest time point goals reachable,
execute remaining events event queue stop propagation.
One-lookahead approximation looks ahead one step (future) event queues one path
achieve goals relaxed assumption guaranteed hopes executing
events would explicate cheaper path achieve goals. 6
Zero one-lookahead examples general k-lookahead approximation,
extracting heuristic value soon goals reachable corresponds zero-lookahead
continuing propagate fix-point corresponds infinite (full) lookahead.
rationale behind k-lookahead approximation goals appear, indication exists least one (relaxed) solution, look ahead one steps
see achieve extra improvement cost achieving goals (and thus lead
lower cost solution).7
6. Note even none events directly related goals, executions still indirectly lead better
(cheaper) path reach goals.
7. backward planners need run propagation one time, infinite-lookahead higher levels
lookahead may pay off, forward planners need evaluate cost goals single search
state, lower values k may appropriate.

169

fiD & K AMBHAMPATI

Coming back travel example, zero-lookahead stops propagation process time
point = 2.5 goal cost C(in la, 2.5) = 8.0. action chain giving cost
c1
{Dtp
, Fpla }. one-lookahead, find lowest cost achieving goal la
c2
C(in la, 7.0) = 6.0 given action (D tla
). two-lookahead approximation,
lowest cost la C(in la, 6.0) = 5.5 achieved cost propagation action
c1
set {(Dtlv
, Tlvla )}. example, two-lookahead effect fix-point propagation (infinite lookahead) deadline achieve la later = 6.0. earlier, say
Deadline(in la) = 5.5, one-lookahead effect infinite-lookahead
c2
option gives cost C(in la, 3.0) = 7.5 action chain {D tphx
, Fphxla }.

4. Heuristics based Propagated Cost Functions
propagation process terminates, time-sensitive cost functions contain sufficient information estimate makespan cost-based heuristic value given state. Specifically,
suppose planning graph grown state S. cost functions set goals
G = {(g1 , t1 ), (g2 , t2 )...(gn , tn )}, ti = Deadline(gi ) used derive following estimates:
minimum makespan estimate (P ) plan starting given earliest
time point 0 goals reached finite cost C(g, t) < .
minimum/maximum/summation estimate slack Slack(P ) plan starting
given minimum/maximum/summation distances time point
goal first appears temporal planning graph deadline goal.
minimum cost estimate, (C(g, deadline(g))), plan starting state achieving set goals G, C(PS , ), computed aggregating cost estimates
achieving individual goals respective deadlines. 8 Notice use
denote time point cost propagation process stops. Thus, time point
cost functions individual goals C(f, ) lowest value.
value : 0 < < , cost estimate plan C(PS , t), achieve goals
within given makespan limit t, aggregation values C(g , t) goals gi .
makespan cost estimates state used basis deriving heuristics.
specific way estimates combined compute heuristic values course depend users ultimate objective function is. general case, objective would
function f (C(PS ), (PS )) involving cost (C(PS )) makespan (T (PS )) values
plan. Suppose objective function linear combination cost makespan:
h(S) = f (C(PS ), (PS )) = .C(PS ) + (1 ).T (PS )
user cares makespan value ( = 0), h(S) = (P ) = 0 . Similarly,
user cares plan cost ( = 1), h(S) = C(P , ). general
8. consider G set preconditions dummy action represents goal state, use
propagation rules (max/sum) discussed Section 3.2 directly estimate total cost achieving goals
given initial state.

170

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

case, 0 < < 1, find time point t, 0 , ht (S) =
f (C(PS , t), t) = .C(PS , t) + (1 ).t minimum value.9
ongoing example, given goal Los Angeles (at la), = 0, heuristic value h(S) = 0 = 2.5 earliest time point C(at la, t) < .
c1
heuristic value corresponds propagation action chain (D tp
, Fpla ). = 1
Deadline(AtLA ) 6.0, h(S) = 5.5, cheapest cost get time
c1
point = 6.0. heuristic value represents another solution (D tlv
, Tlvla ). Finally,
0 < < 1, say = 0.55, lowest heuristic value h(S) = .C(P , t) + (1 ).t
h(S) = 0.55 7.5 + 0.45 3.0 = 5.47 time point 2.5 < = 3.0 < 6.0. = 0.55,
heuristic value h(S) = 5.47 corresponds yet another solution involving driving part way
c2
flying rest: (Dtp
, Fpla ).
Notice general case 0 < < 1, even though time measured continuously,
need check every time point t: 0 < < find value h(S) = f (C(PS , t), t)
minimal. due fact cost functions facts (including goals) step
functions. Thus, need compute h(S) time points one cost functions
C(gi , t) changes value. example above, need calculate values h(S) 0 = 2.5,
= 3.0 = 6.0 realize h(S) minimum value time point = 3.0 = 0.55.
end section, note multiple goals several possible
ways computing C(PS ) cost functions individual goals. consequence
fact multiple rules propagate cost, also interactions
subgoals. Broadly, two different ways extract plan costs. either directly use
cost functions goals compute C(P ), first extract relaxed plan temporal
planning graph using cost functions, measure C(P ) based relaxed plan.
discuss two approaches below.
4.1 Directly Using Cost Functions Estimate C(P )
terminate propagation using criteria discussed Section 3.3, let G =
{(g1 , t1 ), (g2 , t2 )...(gn , tn )}, ti = Deadline(gi ) set goals CG = {c1 , ...cn |ci =
C(gi , Deadline(gi )} best possible achievement costs. consider G set preconditions dummy action represents goal state, use propagation
rules (max/sum) discussed Section 3.2 directly estimate total cost achieving goals
given initial state. Among different combinations propagation rules
aggregation rules compute total cost set goals G, max-max (maxpropagation update C(gi , t), cost G maximum values C(g , Deadline(gi ))
admissible. sum-sum rule, assumes total independence facts,
combinations different options reflect dependencies facts planning
problem. tradeoffs evaluated empirically.

171

fiD & K AMBHAMPATI

Goals: G = {(g1 , t1 ), (g2 , t2 )...(gn , tn )}
Actions relaxed-plan: RP = {}
Supported facts: SF = {f : f InitialStateS}
G 6=
Select best action support g1 t1
RP = RP +
tA = t1 Dur(A)
Update makespan value (RP ) tA < (RP )
f Ef f ect(A) added
duration tf starting point

SF = SF {(f, tA + tf )}
f P recondition(A) s.t C(f, tA ) > 0

G = G {(f, tA )}
(gi , ti ) G, (gi , tj ) SF : tj < ti
G = G \ {(gi , ti )}
End while;

Figure 8: Procedure extract relaxed plan
4.2 Computing Cost Relaxed Plan
take account positive interactions facts planning problems,
backtrack-free search goals find relaxed plan. Then, total execution cost actions
relaxed plan makespan used heuristic estimation. Besides providing
possibly better heuristic estimate, work FF (Hoffmann & Nebel, 2001) shows actions
relaxed plan also used effectively focus search branches surrounding
relaxed solution. Moreover, extracting relaxed solution allows us use resource adjustment
techniques (to discussed Section 5.2) improve heuristic estimations. challenge
use cost functions guide search best relaxed plan address
below.
basic idea work backwards, finding actions achieve goals. action selected, add preconditions goal list remove goals achieved action.
partial relaxed plan plan containing selected actions causal structure
them. remaining goals satisfied initial state S, complete relaxed
plan extraction process finished. stage, action selected complete
relaxed plan contains selected actions likely lowest estimated objective value
f (PS , TS ). given initial state objective function h(S) = f (C(P ), (PS )), Figure 8 describes greedy procedure find relaxed plan given temporal planning graph. First,
let RP set actions relaxed plan, SF set time-stamped facts (f , ti )
currently supported , G set current goals. Thus, SF collection facts supported
initial state effects actions RP , G conjunction top level goals
9. f (C(PS , t), t) estimates cost (cheapest) plan achieves goals makespan value
(PS ) = t, minimum f (C(PS , t), t) (0 ) estimates plan P achieves goals state
P smallest value f (C(PS ), (PS )). value would heuristic estimation objective
function minimizing f (C(PS ), (PS )).

172

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

set preconditions actions RP currently supported facts SF .
estimated heuristic value current (partial) relaxed plan current goal set computed
follows: h(S) = h(RP ) + h(G) h(RP ) = f (C(RP ), (RP )). given set
goals G, h(G) = min0 <t< f (C(G, t), t) calculated
according approach discussed
P
previous section (Section 4). Finally, C(RP ) = ARP Cexec (A) (RP ) makespan
RP , actions RP aligned according causal relationship (see below).
elaborate example shown later section.
start, G set top level goals, RP empty SF contains facts initial state.
Thus C(RP ) = 0, (RP ) = 0 h(S) = h(G). start extraction process backward
search least expensive action supporting first goal g 1 . least expensive, mean
contributes smallest amount objective function h(S) = h(RP ) + h(G) added
current relaxed plan. Specifically,
action supports g 1 , calculate value
hA (S) = h(RP + A) + h((G \ Ef f ect(A)) P recond(A)) estimates heuristic value
add relaxed plan. choose action smallest h (S) value.
action chosen, put preconditions current goal list G, effects
set supported facts SF . Moreover, add precedence constraint
action A1 g1 precondition gives g 1 time point A1 needs
it. Using ordering relations actions RP mutex orderings discussed
Section 5.1, update makespan value (RP ) current (partial) relaxed plan.
ongoing example, suppose objective function h(S) = f (C(P ), (PS )) =
.C(PS )+(1).T (PS ), = 0.55 infinite-lookahead criterion used stop cost
propagation process. start extracting relaxed plan, initial setting G = {at la},
c2
RP = SF = {at tucson}. Among three actions tla
, Tlvla Fpla support
goal la, choose action = Fpla
add relaxed plan RP ,
estimated value hA (S) = h(RP + A) + h((G \ la) phx) = ( Cexec (Fpla ) + (1
) Dur(Fpla )) + mint (f (C(at phx), t)) = (0.55*6.0 + 0.45*1.5) + (0.55*1.5 + 0.45*1.5) =
5.475. turns smallest among three actions. add F pla relaxed
plan, update goal set G = {at phx}. easy compare two actions
c2
c1
c2
Dtphx
Dtphx
see Dtphx
cheaper achieving at-phx given value = 0.55.
final cost C(PS ) = 6.0 + 1.5 = 7.5 makespan (PS ) = 1.5 + 1.5 = 3 final
relaxed plan used final heuristic estimation h(S) = 0.55 7.5 + 0.45 3 = 5.475
given state.
Notice relaxed-plan extraction procedure, set time points goal set
goal deadlines, instead latest time points cost functions goals
stabilized. reason cost values facts actions monotonically decrease
costs time-sensitive. Therefore, later set time points goals start searching
relaxed plan, better chance getting low-cost plan, especially use
k-lookahead approximation approach k 6= . ongoing example, use
zero-lookahead option stop propagation, find smallest cost C(in la) = 8.0
= 2.5. search back relaxed plan combination (in la, 2.5) would
c1
find plan P1 = (Dtp
, Fpla ). However, search goal deadline, say = 7.0,
would realize lowest cost precondition phx F pla = 7.0 1.5 = 5.5
c2
time point = 2.0) thus final plan P 2 =
C(in phx, 5.5) = 1.5 (caused Dtp
c2
(Dtp , Fpla ) cheaper P1 .

173

fiD & K AMBHAMPATI

4.3 Origin Action Costs
preceding discussion cost-based heuristics, implicitly assumed individual action costs specified directly part problem specification. reasonable
assumption, also argued unlike duration, cost action implicitly dependent user interested optimizing. example, suppose, transportation domain,
user declares objective function optimized as: 10
4 otalT ime + 0.005 otalF uelU sed
without providing additional explicit information action costs. possible use
objective function assess costs individual actions (in terms much contribute
cost portion objective). Specifically, cost action set equal amount
fuel used action. value (for combining cost makespan) set based
coefficients objective function. course, type de-compilation objective function action costs possible objective function linear combination makespan
resource consumption.

5. Adjustments Relaxed Plan Heuristic
now, heuristic estimates calculated relaxing certain types constraints
negative effects metric resource consumptions. section, discuss
contraints used adjust improve final heuristic values.
5.1 Improving Relaxed Plan Heuristic Estimation Static Mutex Relations
building relaxed temporal planning graph (RTPG), ignored negative interactions
concurrent actions. discuss way using static mutex relations help improve heuristic estimation extracting relaxed plan. Specifically, approach involves
following steps:
1. Find set static mutex relations ground actions planning problem
based negative interactions. 11
2. extracting relaxed plan (Section 4.2), besides orderings actions
causal relationships (i.e one action gives effect supports actions preconditions), also post precedence constraints avoid concurrent execution actions
mutex. Specifically, new action added relaxed plan, use precalculated static mutexes establish ordering mutually exclusive action pairs
executed concurrently. orderings selected way
violate least number existing causal links relaxed plan.
using mutex relations way, improve makespan estimation relaxed plan, thus heuristic estimation. Moreover, cases, mutex relations also
help us detect relaxed plan fact valid plan, thus lead early termination
10. fact, metric specified first problem Zeno-Travel domain IPC 2003.
11. Two actions static mutex delete effects one action intersect preconditions add effects
other.

174

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Relaxed solution mutex:

B

move(package1,airplane1,A,B)

package 1

move(package2,airplane1,A,C)

Plane 1
Plane 2

Relaxed solution mutex:


move(package1,airplane1,A,B)
package 1
package 2

move(package2,airplane2,A,C)

C
package 2

Figure 9: Example mutex relaxed plan
search. Consider example Logistics domain illustrated Figure 9. example, need move two packages cityA cityB cityC two airplanes
(plane1 , plane2 ) cityA used move them. Moreover, assume plane 1 1.5
times faster plane2 uses amount resources fly two cities.
two relaxed plans
P1 = {move(package1 , plane1 , cityA, cityB), move(package2 , plane1 , cityA, cityC)}
P2 = {move(package1 , plane1 , cityA, cityB), move(package2 , plane2 , cityA, cityC)}
contain two actions. first one uses plane carry packages,
second one uses two different planes. first one shorter makespan mutexes
ignored. However, consider mutex constraints, know two actions P 1
executed concurrently thus makespan P 1 actually longer P2 . Moreover, static mutex relations also show even order two actions P 1 ,
violation first action cuts causal link initial state second one. Thus, mutex information helps us simple case find better (consistent)
relaxed plan use heuristic estimate. sketch relaxed plan P 2
found. first action A1 = move(package1 , plane1 , cityA, cityB) selected support
goal at(package1 , cityB), relaxed plan RP = A1 two potential actions support second goal at(package2 , cityC) A2 = move(package2 , plane1 , cityA, cityC)
A02 = move(package2 , plane2 , cityA, cityC). mutex information, able choose
A02 A2 include final relaxed plan.
5.2 Using Resource Information Adjust Cost Estimates
heuristics discussed Section 4 used knowledge durations actions deadline goals resource consumption. ignoring resource related effects building
relaxed plan, may miss counting actions whose purpose provide sufficient resourcerelated conditions actions. ongoing example, want drive car Tucson
LA gas level low, totally ignoring resource related conditions, realize
need refuel car drive. Consequently, ignoring resource constraints may reduce
quality heuristic estimate based relaxed plan. thus interested adjusting
heuristic values discussed last two sections account resource constraints.

175

fiD & K AMBHAMPATI

many real-world problems, actions consume resources, special actions
increase levels resources. Since checking whether level resource sufficient
allowing execution action similar checking predicate preconditions, one obvious
approach adjust relaxed plan including actions provide resource-related condition relaxed plan. However, many reasons, turns difficult decide
actions added relaxed plan satisfy given resource conditions (Do & Kambhampati, 2001, gives detailed discussion difficulties). Therefore, introduce
indirect way adjusting cost relaxed plan take account resource constraints.
first pre-process problem specifications find resource R action R
increase amount R maximally. Let R amount AR increases R, let
C(AR ) cost value AR . Let Init(R) level resource R state
want compute relaxed plan, Con(R), P ro(R) total consumption production
R actions relaxed plan. Con(R) > Init(R) + P ro(R), increase cost
number production actions necessary make difference. precisely:
X (Con(R) (Init(R) + P ro(R)))
CC+
C(AR )
R
R

shall call adjusted cost heuristic. basic idea even though know
individual resource-consuming action relaxed plan needs another action support
resource-related preconditions, still adjust number actions relaxed plan reasoning total resource consumption actions plan. know resources
R consumed relaxed plan maximum production resources possible
individual action domain, infer minimum number resource-increasing actions need add relaxed plan balance resource consumption. ongoing
example, car rented students Tucson enough fuel initial state
make trip Phoenix, LA, Las Vegas, approach discover planner needs
add refuel action relaxed plan.
Currently, resource-adjustment technique discussed limited simple consumption
production resources using addition subtraction. common forms,
evidenced fact metric temporal planning domains used competition, actions
consume produce resources solely using addition (increase) subtraction (decrease). Modifications needed extend current approach deal types resource consumption
using multiplication division.

6. Post-Processing Improve Temporal Flexibility
improve makespan execution flexibility plans generated Sapa, post-process
convert partially ordered plans. discuss details process section.
start first differentiating two broad classes plans.
Position Order constrained plans: position constrained plan (p.c.) plan
execution time action fixed specific time point. order constrained (o.c.) plan
plan relative orderings actions specified.
Note p.c. vs. o.c. distinction orthogonal whether concurrency allowed
execution. Indeed, distinguish two subclasses p.c. plansserial parallel.

176

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

{Q}

{G}
A1:

{G}

R
R



Q
G



A3:

T1

R
R

G

R

~R

T3

{Q}

A2:

Q



T4

R

~R

A4:



T2

Figure 10: Examples p.c. o.c. plans
serial position constrained plan, concurrency execution allowed. parallel position
constrained plan, actions allowed execute concurrently. Examples serial p.c. plans
ones returned classical planners HSP (Bonet et al., 1997), AltAlt (Nguyen et al.,
2001), FF (Hoffmann & Nebel, 2001), GRT (Refanidis & Vlahavas, 2001b). parallel p.c.
plans ones returned Sapa (Do & Kambhampati, 2001), TP4 (Haslum & Geffner, 2001).
Graphplan-based planners (STAN, Long & Fox, 1998; IPP, Koehler et al. 1997) temporal
cousins (TGP, Smith & Weld, 1999; TPSYS, Garrido, Onaindia & Barber, 2001) also return parallel
p.c plans. Examples planners output order constrained (o.c.) plans Zeno (Penberthy
& Well, 1994), HSTS (Muscettola, 1994), IxTexT (Laborie & Ghallab, 1995), RePOP (Nguyen &
Kambhampati, 2001), VHPOP (Younes & Simmons, 2003).
mentioned above, plans returned Sapa position-constrained (p.c.). Searching
space p.c. plans advantages presence metric resources (viz.,
easy compute amount consumed resources every point partial plan). Position
constrained plans however less desirable point view execution flexibility
human comprehension. latter uses, order (precedence) constrained plan (o.c plan)
often better.
Figure 10 shows valid parallel p.c. plan consisting four actions 1 , A2 , A3 , A4
starting time points fixed T1 , T2 , T3 , T4 o.c plan consisting set actions
achieving goals. action, shaded regions show durations
precondition effects hold actions execution time. darker ones represent
effect lighter ones represent preconditions. example, action 1 precondition
Q effect R; action A3 preconditions two effects R S. arrows show
relative orderings actions. ordering relations represent o.c plan thus
execution trace violate orderings consistent p.c plan.
Given p.c plan Ppc , interested computing o.c. plan P oc contains
actions Ppc , also valid plan solving original problem. general,
many o.c. plans. related work (Do & Kambhampati, 2003), discuss
conversion problem posed optimization problem subject variety optimization
metrics based temporal quality flexibility. following discuss greedy strategy
used competition version Sapa, finds o.c plan biased reasonably
good makespan. Specifically, extend explanation-based order generation method outlined
Kambhampati Kedar (1994) first compute causal explanation p.c plan
construct o.c plan number orderings needed satisfy explanation.
strategy depends heavily positions actions original p.c. plan. works based
fact alignment actions original p.c. plan guarantees causation
preservation constraints satisfied. following notation helps describing approach:
177

fiD & K AMBHAMPATI

(pre)condition p action A, use [st pA , etpA ] represent duration p
hold (stpA = etpA p instant precondition).
effect e action A, use et eA represent time point e occurs.
resource r checked preconditions used action A, use
[strA , etrA ] represent duration r accessed A.
initial goal states represented two new actions AG . AI starts
actions Ppc , precondition effects representing initial
state. AG starts actions Ppc , effect, top-level goals
preconditions.
symbol 00 00 used throughout section denote relative precedence orderings
two time points.
Note values stpA , etpA , eteA , strA , etrA fixed p.c plan partially
ordered o.c plan. o.c plan P oc built p.c plan Ppc follows:
Supporting Actions: precondition p action A, choose earliest possible action
A0 p.c plan support p:
1. p Effect(A0 ) etpA0 < stpA p.c. plan Ppc .
p
2. action B that: p Effect(B) et pA0 < etp
B < stA Ppc .

3. action C also satisfies two conditions et pC < etpA0 .
p

A0 selected support p A, add causal link 0
two time points
etpA0 stpA o.c plan. Thus, ordering et pA0 stpA added Poc .
Interference relations: pair actions A, 0 interfere other, order
follows:

p
p
1. p Delete(A0 ) Add(A), add ordering etpA etp
A0 Poc etA < stA0
p
p
Ppc . Otherwise add etA0 etA Poc .

p
p
2. p Delete(A0 ) P recond(A), add ordering et pA etp
A0 Poc etA < etA
p
p
p
Ppc . Otherwise, etA0 < stA original plan Ppc add ordering etA0 stpA
final plan Poc .
Resource relations: resource r checked (pre)condition action used
action A0 , based actions fixed starting times original p.c plan P pc , add
following orderings resulting P oc plan follows:
etrA < strA0 Ppc , ordering relation etrA strA0 added Poc .
etrA0 < strA Ppc , ordering relation etrA0 strA added Poc .

178

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

strategy backtrack-free due fact original p.c. plan correct. (pre)
conditions actions Ppc satisfied thus precondition p action A,
always find action A0 satisfies three constraints listed support p. Moreover,
one temporal constraints lead consistent ordering two interfering actions
(logical resource interference) always satisfied p.c. plan consistent
pair interfering actions overlap P pc . Thus, search backtrack-free
guaranteed find o.c. plan due existence one legal dispatch final o.c. plan P oc
(which starting p.c. plan Ppc ). final o.c. plan valid causal-link
every actions precondition, causal links safe, interfering actions overlap,
resource-related (pre)conditions satisfied. Moreover, strategy ensures orderings
Poc consistent original Ppc . Therefore, p.c plan Ppc one among multiple
p.c plans consistent o.c plan P oc , makespan Poc guaranteed equal
better makespan Ppc .
algorithm discussed section special case partialization problem metric
temporal planning. related work (Do & Kambhampati, 2003), systematic study
general partialization problem give CSOP (Constraint Satisfaction Optimization Problem)
encodings solving them. current algorithm seen particular greedy variable/value
ordering strategy CSOP encoding.

7. Implementation Sapa
Sapa system techniques described paper implemented Java.
implementation includes:
1. forward chaining algorithm (Section 2).
2. cost sensitive temporal planning graph routines propagate cost information
extract heuristic value (Section 3).
3. routines extract adjust relaxed plan using static mutex resource information
(Section 4.2).
4. Greedy post-processing routines convert p.c. plan o.c plan better makespan
execution flexibility (Section 6).
default Sapa uses sum-propagation rule, infinite lookahead termination, resource-adjusted
heuristics, converts solutions o.c. plans. Besides techniques described paper,
also wrote JAVA-based parser PDDL2.1 Level 3, highest level used
Third International Planning Competition (IPC3).
visualize plans returned Sapa relations actions plan (such
causal links, mutual exclusions, resource relations), developed Graphical User
Interface (GUI)12 Sapa. Figure 11 12 shows screen shots current GUI. displays
time line final plan action shown actual duration starting time
final plan. options display causal relations actions (found using greedy
approach discussed Section 6), logical resource mutexes actions. specific
times individual goals achieved also displayed.

179

fiD & K AMBHAMPATI

Figure 11: Screen shot Sapas GUI: PERT chart showing actions starting times
precedence orderings them.

Figure 12: Screen shots Sapas GUI: Gant chart showing different logical relations
given action actions plan.

180

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Makespan Variation

60

31

50

29
27

40

Makespan

Total Cost

Cost variation

30
20
10

25
23
21
19
17

0

15

0.1

0.2

0.3

0.4

0.5

0.6

0

0.8

0.9

0.95

1

0.1

Alpha

0.2

0.3

0.4

0.5

0.6

0

0.8

0.9

0.95

1

Alpha

Figure 13: Cost makespan variations according different weights given objective function. point graph corresponds average value 20 problems.

implementation publicly available Sapa homepage 13 . Since planner
well GUI JAVA, also provide web-based interactive access planner.

8. Empirical Evaluation
subjected individual components Sapa implementation systematic empirical
evaluation (c.f. & Kambhampati, 2001, 2002, 2003). section, describe experiments conducted (Do & Kambhampati, 2001) show Sapa capable satisfying
variety cost/makespan tradeoffs. Moreover, also provide results show effectiveness
heuristic adjustment techniques, utility different termination criteria, utility
post-processing. Comparison Sapa systems International Planning Competition
provided next section.
8.1 Component Evaluation
first test suite experiments, used test Sapas ability produce solutions tradeoffs
time cost quality, consisted set randomly generated temporal logistics problems
provided Haslum Geffner (2001). set problems, need move packages
locations different cities. multiple ways move packages, option different
time cost requirements. Airplanes used move packages airports different cities.
Moving airplanes takes 3.0 time units, expensive, costs 15.0 cost units. Moving
packages trucks locations different cities costs 4.0 cost units, takes longer
time 12.0 time units. also move packages locations inside city (e.g.
offices airports). Driving locations city costs 2.0 units takes
2.0 time units. Loading/unloading packages truck airplane takes 1.0 unit time costs
1.0 unit.
tested first 20 problems set objective function specified linear combination total execution cost makespan values plan. Specifically, objective
12. GUI developed Dan Bryce
13. http://rakaposhi.eas.asu.edu/sapa.html

181

fiD & K AMBHAMPATI

function set
= .C(P lan) + (1 ).T (P lan)
tested different values : 0 1. Among techniques discussed
paper, used sum-propagation rule, infinite look-ahead, relax-plan extraction using static
mutex relations. Figure 13 shows average cost makespan values solution change
according variation value. results show total execution cost
solution decreases increase value (thus, giving weight execution cost
overall objective function). contrast, decreases, giving weight makespan,
final cost solution increases makespan value decreases. results show
approach indeed produces solutions sensitive objective function involves
time cost. combinations {problem, }, 79% (173/220) solvable within
cutoff time limit 300 seconds. average solution time 19.99 seconds 78.61%
instances solved within 10 seconds.
8.1.1 E VALUATION



IFFERENT ERMINATION C RITERIA

Figure 14 shows comparison results zero, one, infinite lookahead set metric
temporal planning problems competition. take first 12 problems four
temporal domains: ZenoTravel-Time, DriverLog-Time, Satellite-Time, RoversTime. set
= 1 objective function, making entirely cost-based. action costs set 1 unit.
discussed Section 3.3, zero-lookahead stops cost propagation process time point
solution relaxed condition. K-lookahead spends extra effort go beyond
time point hope finding better quality (relaxed) solution use heuristic values guide
search. running condition specified caption figure.
problems three domains ZenoTravel-Time, DriverLog-Time, SatelliteTime, infinite-lookahead returns better quality solutions shorter time one-lookahead,
turn generally better zero-lookahead. exception Rovers-Time domain,
virtually difference running time solution quality different look-ahead
options.
following elaborate summary results Figure 14. top three figures
show running time, cost, makespan comparisons ZenoTravel domain (Time setting).
domain, within time memory limit, infinite-lookahead helps solve 3 problems
one-lookahead 2 zero-lookahead. one problem (problem 10), infinitelookahead returns equal (three) better (eight) cost solution zero-lookahead. Compared
one-lookahead, better five problems equal six others. makespan value, infinitelookahead generally better, consistent criteria. next three lower figures
show comparison results DriverLog-Time domain. domain, infinite onelookahead solve one problem zero-lookahead, infinite-lookahead also faster
two options one problem. costs (number actions) solutions returned
infinite-lookahead also better two problems (in three solutions
same). One-lookahead also equal better zero-lookahead two problems.
Satellite-Time domain, infinite one-lookahead solve three (of twelve) problems
zero-lookahead, option consistently solves problems faster other. However,
solution quality (cost) infinite one-lookahead consistently better zero-lookahead.
Moreover, solution cost plans returned infinite-lookahead worse one-lookahead

182

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

ZenoTime

Time (ms)

3000
2500

La 0
La 1
La Inf

2000
1500
1000
500

40

60

30

50

20
10
0

0

1

1 2 3 4 5 6 7 8 9 10 11 12

2

3

6

7

8

1

2

3

2

3

4

4

5

7

8

9

10 11 12

DriverLog Time

6

7

8

1

9 10 11 12

2

3

4

5

6

7

8

9 10 11 12

8

9 10 11 12

Problems

SatelliteTime

50

600

40

500

Makespan

Cost (#Action)

La 0
La 1
La Inf

6

800
700
600
500
400
300
200
100
0

SatelliteTime

SatelliteTime

5

Problem

Problems

Problems

30
20
10

400
300
200
100
0

0

Problems

10
1

Makespan

La 0
La 1
La Inf

1 2 3 4 5 6 7 8 9 10 11 12

20

0

9 10 11 12

35
30
25
20
15
10
5
0

1 2 3 4 5 6 7 8 9 10 11 12

Time (ms)

5

30

DriverLog Time

Cost (#Action)

Time (ms)

DriverLog Time

400000
350000
300000
250000
200000
150000
100000
50000
0

4

40

Problem

Problem

180000
160000
140000
120000
100000
80000
60000
40000
20000
0

ZenoTime

Makespan

3500

Cost (#Action)

ZenoTime

1

2

3

4

5

6

7

Problems

8

9 10 11 12

1

2

3

4

5

6

7

Problems

Figure 14: Comparison different lookahead options competition domains. experiments run Pentium III-750 WindowsXP machine 256MB RAM.
time cutoff 600 seconds.

183

fiD & K AMBHAMPATI

ZenoTime

Resadj
no-resadj

1000
100
10

40

Makespan

10000

Cost (#Action)

50

100000

Time (ms)

ZenoTime

ZenoTime

1000000

30
20
10
0

1
1

3

5

7

9

11 13

Problems

1

3

5

7

9

11

13

Problems

140
120
100
80
60
40
20
0
1 2 3 4 5 6 7 8 9 10 11 12 13 14

Problems

Figure 15: Utility resource adjustment technique ZenoTravel (time setting) domain
competition. Experiments run WindowsXP Pentium III 750MHz 256MB
RAM. Time cutoff 600 seconds.

one problem slightly better 6 problems. domain, seems big
improvement zero one look-ahead, infinite-lookahead slight improvement
one-lookahead. (The plots Rovers domain shown figure different
look-ahead options seem lead near identical results domain.) Finally, since heuristic
based completely cost ( =1), not, theory, expect see conclusive patterns
makespan values solutions produced different lookahead options.
8.1.2 U TILITY



R ESOURCE DJUSTMENT ECHNIQUE

previous work (Do & Kambhampati, 2001), show resource adjustment technique
lead significant quality search speed improvements problems metric temporal logistics domain several types resource consumption objects like trucks
airplanes.
competition, two domains test utility resource adjustment technique discussed Section 5.2. ZenoTravel domain Rovers domain
actions consuming resources (refueling) actions renew them. these, resource
adjustment technique gives mixed results ZenoTravel domain effect Rovers
domain. Therefore, show comparison ZenoTravel domain Figure 15.
ZenoTravel domain, Sapa resource adjustment runs slightly faster 10 14 problems, returns shorter solutions 5 problems longer solutions 3 problems. solution
makespan resource adjustment technique also generally better without adjustment technique. conclusion, resource adjustment technique indeed helps Sapa domain.
contrast, Rovers domain, technique virtually help. Actually, Rovers
domain, number search nodes without resource adjustment
solved problems. One reason maybe Rovers domain, additional constraints
recharge action carried certain location. Therefore, even
know need add recharge action current relaxed plan, may able add
plan visit right location.

184

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

DriverLog Time

Zeno Time (+Resource)
Total-Dur
Orig-MS
PP-MS

80

makespan

makespan

100

60
40
20
0
1

2

3

4

5

6

7

8

800
700
600
500
400
300
200
100
0
1

9 10 11 12

2

3

4

Problems

6

7

8

9 10 11 12

Rovers Time (+Resource)

Satellite Complex (time+resource)
300

1000

250

800

makespan

makespan

5

Problems

600
400
200

200
150
100
50
0

0
1

2

3

4

5

6

7

8

1

9 10 11 12

Problems

2

3

4

5

6

7

8

9 10 11 12

Problems

Figure 16: Utility greedy post-processing approach problems domains ZenoTravelTime, DriverLog-Time, Satellite-Complex, Rovers-Time IPC3.

8.1.3 U TILITY



P OST- PROCESSING P.C. P LANS



O.C. P LANS

Figure 16 shows utility greedy post-processing technique discussed Section 6.
test suite contains set problems used first test, first 12 problems
ZenoTravel-Time, DriverLog-Time, Satellite-Complex, Rovers-Time domain. graphs
Figure 16 show comparisons makespan values (i) total duration actions
plan (makespan serial plan); (ii) original parallel position-constrained (p.c) plans returned
Sapa, (iii) order-constrained (o.c) plans returned post-processing. graphs show
greedy post-processing approach helps improving makespan values domains. average,
improves makespan values original plans 32.4% ZenoTravel-Time domain,
27.7% DriverLog-Time domain, 20.3% Satellite-Complex domain, 8.7%
RoversTime domain. Compared serial plans, greedily partialized o.c plans improved
makespan values 24.7%-38.9%.
CPU times greedy partialization small. Specifically, less 0.1 seconds problems number actions ranging 1 68. Thus, using partialization
algorithm post-processing stage essentially preserves significant efficiency advantages
position constrained planners Sapa, GRT MIPS, search space p.c. plans,
improving temporal flexibility plans generated planners.
related work (Do & Kambhampati, 2003), present additional results SimpleTime setting domains comparison optimal post-processing technique
discussed paper.

185

fiD & K AMBHAMPATI

8.2 Sapa 2002 International Planning Competition
entered implementation Sapa, using several techniques discussed paper,
recent International Planning Competition. specific techniques used competition version
Sapa infinite look-ahead termination cost propagation (Section 3.3), resource adjustment
(Section 5.2), greedy post-processing (Section 6). competition, focused solely
metric/temporal domains.
sophisticated support multi-objective search provided Sapa fully exploited
competition, since action cost part standard PDDL2.1 language used
competition.14 competition evaluate quality solution plans terms number
actions terms overall makespan. Given state affairs, assumed unit cost
actions, ran Sapa = 1, thus making search sensitive action costs. Infinitelookahead used cost propagation. strategy biased Sapa produce low cost plans (in
terms number actions). Although search sensitive makespan optimization,
greedy post processing p.c. plans o.c. plans improved makespan solutions enough
make Sapa one best planners terms overall quality solutions produced. 15
competition results collected distributed IPC3s organizers
found competition website (Fox & Long, 2002). Detailed descriptions domains used
competition also available place. temporal planning domains competition came two sets, one containing two domains, Satellite Rovers (adapted NASA
domains), containing three domains: Depots, DriverLogistics Zeno Travel.
planning competition, domain multiple versionsdepending whether actions
durations whether actions use continuous resources. Sapa participated highest levels
PDDL2.1 (in terms complexity temporal metric constraints) five domains
listed above.
Figures 17 18 show five planners (Sapa, LPG, MIPS, TP4, TPSYS) submitted
results timed setting three (Sapa, MIPS, TP4) able handle complex
setting Satellite domain. timed setting, action durations depend setting
instruments aboard particular satellite direction needs turn to. complex setting
complicated fact satellite different capacity limitation
store certain amount image data. Goals involve taking images different planets stars
located different coordinate directions. achieve goals, satellite equipped right
set instruments turn right direction, calibrate take image.
timed setting Satellite domain, Figure 17 shows among five planners,
Sapa, LPG MIPS able solve 19 20 problems TP4 TPSYS able
solve 2 3 problems respectively. quality comparison, LPG quality setting able
return solutions best quality, Sapa slightly better LPG speed setting
much better MIPS. LPG speed setting generally fastest, followed
MIPS Sapa LPG quality setting. complex setting, Figure 18 shows
that, among three planners, Sapa able solve problems (16), generated plans
higher quality MIPS. TP4 produced highest quality solutions, able solve
14. competition problems explicit objective functions, theory, could inferred
action costs objective functions (see discussion Section 4.3). yet done this, given
plan metric field PDDL2.1 fully standardized time competition.
15. sure, makespan optimal planners TP4 produce much shorter plansbut search inefficient
unable solve problems.

186

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Satellite Time
700

500

1.E+06

Speed (milisecs)

600

Quality (Makespan)

Satellite Time
1.E+07

Sapa (19 solved)
LPG.Quality (19 solved)
LPG.Speed (19 solved)
MIPS (19 solved)
TP4 (2 solved)
TPSYS (3 solved)

400
300
200

1.E+05
1.E+04
1.E+03
1.E+02
1.E+01

100

1.E+00

0
1

2

3

4

5

6

7

8

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

9 10 11 12 13 14 15 16 17 18 19 20

Problems

Problems

Figure 17: Results time setting Satellite domain (from IPC3 results).

Satellite Complex

Satellite Complex

700

1.E+07

MIPS (10 solved)

500

TP4 (3 solved)

1.E+06

Speed (milisecs)

Quality (Makespan)

Sapa (16 solved)
600

400
300
200
100

1.E+05
1.E+04
1.E+03
1.E+02
1.E+01

0

1.E+00

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

1

Problems

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

Problems

Figure 18: Results complex setting Satellite domain (from IPC3 results).

187

fiD & K AMBHAMPATI

Rovers Time

Rovers Time
300

1.E+06

Sapa (11 solved)
1.E+05

MIPS (9 solved)

Speed (milisecs)

Quality (Makespan)

250
200
150
100
50

1.E+04
1.E+03
1.E+02
1.E+01

0

1.E+00
1

2

3

4

5

6

7

8

9

10 11 12 13 14 15 16

1

Problems

2

3

4

5

6

7

8

9

10 11 12 13 14 15 16

Problems

Figure 19: Results time setting Rover domain (from IPC3 results).

Depots Time
2000

1600
1400

1.E+06

Speed (milisecs)

1800

Quality (Makespan)

Depots Time
1.E+07

Sapa (5 solved)
LPG.Quality (18 solved)
LPG.Speed (18 solved)
MIPS (11 solved)
TP4 (1 solved)

1200
1000
800
600
400

1.E+05
1.E+04
1.E+03
1.E+02
1.E+01

200

1.E+00

0

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20 21

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21

Problems

Problems

Figure 20: Results time setting Depots domain (from IPC3 results).
three smallest problems. solving times Sapa slightly higher MIPS, much
better TP4.
timed version Rover domain requires set scientific analyses done using
number rovers. rover carries different equipment, different energy capacity.
Moreover, rover recharge battery certain points sun (which
may unreachable). Figure 19 shows Sapa MIPS able handle constraints
problem set. Sapa solved problems (11 vs. 9) MIPS also returned better
equal quality solutions one case. solving time MIPS better Sapa 6
9 problems returns solutions.

188

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

second set problems, come temporal constraints, three domains:
Depots, DriverLogistics Zeno Travel. Sapa participated highest level,
timed settings three domains. Figure 20 shows comparison Sapa three
planners (LPG, MIPS, TP4) submitted results Depots domain. domain,
need move crates (packages) different places. loading actions place
crates truck complicated fact need empty hoist. Thus, Depot
domain looks like combination original logistics blockworlds domains. Drive action
durations depend distances locations speed trucks. Time loading
crates depends power hoist use. resource consumption
highest level. domain, Sapa able solve five problems, compared 11 MIPS
18 LPG. TP4 solved one problem. five problems Sapa able solve,
solution quality good planners. speed comparison, LPG speed setting
clearly faster planners. speculate poor performance Sapa domain related two factors: (i) negative interactions subgoals, largely ignored Sapa,
important consideration domain (ii) number ground actions domain
particularly high, making computation planning graph quite costly.
Figure 21 shows Sapa performance compares planners competition
time setting DriveLog domain. variation original Logistics domain
trucks rather airplanes move packages different cities. However, truck requires
driver, driver must walk board truck move. Like Depot domain,
resource consumption. durations walking driving depend specified timeto-walk time-to-drive. domain, Sapa solved 14 problems compared 20 LPG, 16
MIPS 1 TP4. quality solutions different planners similar.
speed comparison, LPG speed setting fastest, MIPS, Sapa LPG quality
setting.
Finally, Figure 22 shows performance Sapa ZenoTravel domain time setting.
domain, passengers travel different cities airplanes. airplanes choose
fly different speeds (fast/slow), consume different amounts fuel. Airplanes
different fuel capacity need refuel enough trip. domain,
Sapa LPG solved 16 problems MIPS solved 20. solution quality Sapa MIPS
similar general better LPG either speed quality setting. LPG speed
setting MIPS solved problems domain faster Sapa turn faster LPG
quality setting.
summary, problems involving metric temporal constraints IPC3, Sapa competitive planners LPG MIPS. particular, Sapa solved problems
returned plans best solution quality highest setting two domains Satellite
Rovers, adapted NASA domains. detailed analysis competition
results presented Long Fox (2003).

9. Related Work Discussion
Although several recent domain-independent heuristic planners aimed temporal
domains, aimed makespan optimization, ignoring cost aspects.
example, TGP (Smith & Weld, 1999) well TP4 (Haslum & Geffner, 2001) focus
makespan optimization ignore cost aspects plan. argued paper,

189

fiD & K AMBHAMPATI

DriverLog Time
Sapa (14 solved)
LPG.Quality (20 solved)
LPG.Speed (20 solved)
MIPS (16 solved)
TP4 (2 solved)
TPSYS (1 solved)

6000
5000

1.E+06

Speed (milisecs)

7000

Quality (Makespan)

DriverLog Time
1.E+07

8000

4000
3000
2000

1.E+05
1.E+04
1.E+03
1.E+02
1.E+01

1000
0

1.E+00
1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

1

2

3

4

5

6

7

Problems

8

9 10 11 12 13 14 15 16 17 18 19 20

Problems

Figure 21: Results time setting DriverLog domain (from IPC3 results).

ZenoTravel Time

ZenoTravel Time

1600

1.E+06

Sapa (15 solved)
LPG.Quality (16 solved)
LPG.Speed (16 solved)
MIPS (20 solved)

1200

1.E+05

Speed (milisecs)

Quality (Makespan)

1400

1000
800
600
400

1.E+04
1.E+03
1.E+02
1.E+01

200
0

1.E+00
1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

Problems

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

Problems

Figure 22: Results time setting ZenoTravel domain (from IPC3 results).

190

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

ultimately, metric temporal planners need deal objective functions based
makespan cost. One recent research effort recognizes multi-objective nature planning
MO-GRT system (Refanidis & Vlahavas, 2001a). one hand, MO-GRT approach
general approach sense deals set non-combinable quality
metrics. MO-GRT approach however treats time similar consumable resources (with
infinite capacity). Temporal constraints planning problems (such effect
occur course action), goal deadlines, concurrency ignored order scale
problem classical planning assumptions. Metric-FF (Hoffmann, 2002) MIPS
(Edelkamp, 2001) two forward state space planners handle resource constraints.
generate sequential plans. MIPS handles durative actions putting action
duration post-processing sequential p.c plans. Multi-Pegg (Zimmerman, 2002) another
recent planner considers cost-time tradeoffs plan generation. Multi-Pegg based
Graphplan approach, focuses classical planning problems non-uniform cost actions.
ASPEN (Chien et al., 2000) another planner recognizes multi-attribute nature plan
quality. ASPEN advocates iterative repair approach planning, assumes availability
variety hand-coded plan repair strategies characterization terms effects
various dimensions plan quality. LPG (Gerevini & Serina, 2002) another planner
employs local search techniques action-graph. Unlike ASPEN, LPG considers domain
independent repair strategies involve planning graph-based modifications.
Although evaluated cost-sensitive heuristics context Sapa, forward chaining
planner, heuristics also used types planning algorithms.
example, TGP made cost-sensitive making propagate cost functions part
planning graph expansion. cost functions used basis variable value
ordering heuristics guide backward branch-and-bound search. similar approach classical
planning shown successful Kambhampati Nigenda (2000).
Besides Graphplan-based approaches, framework also used forward
backward state-space partial order planners guide planning search. possible due
fact directional searches (forward/backward) need evaluate distances
initial state set temporal goals.
work also related approaches use planning graphs basis deriving
heuristic estimates Graphplan-HSP (Kambhampati & Nigenda, 2000), AltAlt (Nguyen et al.,
2001), RePOP (Nguyen & Kambhampati, 2001), FF (Hoffmann & Nebel, 2001). context
efforts, contribution seen providing way track cost function time
planning graphs. interesting observation cost propagation ways inherently
complex makespan propagation. example, set literals enter planning graph
(and mutually exclusive), estimate makespan shortest plan achieving
change continue expand planning graph. contrast, estimate
cost cheapest plan achieving change planning graph levels off.
needed carefully consider effect different criteria stopping expansion
planning graph accuracy cost estimates (Section 3.3).
Another interesting point within classical planning, often confusion
notions cost makespan. example, length plan terms number actions
either seen cost measure (if assume actions unit costs), makespan
measure (if assume actions unit durations). notions get teased apart naturally
metric temporal domains.
191

fiD & K AMBHAMPATI

paper, concentrated developing heuristics sensitive multiple dimensions plan quality (specifically, makespan cost). orthogonal issue planning
multiple criteria various dimensions plan quality combined optimization. particular approach adopted empirical evaluationnamely, considering
linear combination cost timeis means reasonable way. approaches
involve non-linear combinations quality criteria, well tiered objective functions (e.g.
rank plans terms makespan, breaking ties using cost). related issue help user
decide weights tiers different criteria. Often users may able articulate preferences various quality dimensions terms precise weights.
standard way dilemma involves generating non-dominated Pareto-optimal plans 16 ,
presenting user. Unfortunately, often set non-dominated plans exponential (c.f., Papadimitriou & Yannakakis, 2001). users expected pick plan
palatable them. Unfortunately, users may actually able judge relative
desirability plans problems complex plans long. Thus, practical
approach may involve resorting indirect methods preference elicitation techniques
(c.f. Chajewska, Getoor, Norman, & Shahar., 1998).

10. Conclusion
paper, presented Sapa, domain-independent heuristic forward chaining planner
handle durative actions, metric resource constraints, deadline goals. Sapa forward-chaining
planner searches space time-stamped states. designed capable handling
multi-objective nature metric temporal planning. technical contributions include (i)
planning-graph based method deriving heuristics sensitive cost makespan
(ii) easy way adjusting heuristic estimates take metric resource limitations
account (iii) way post-processing solution plans improve execution flexibility.
described technical details extracting heuristics presented empirical evaluation
current implementation Sapa. implementation Sapa using subset techniques
presented paper one best domain independent planners domains metric
temporal constraints third International Planning Competition, held AIPS-02.
extending Sapa several different directions. begin with, want make Sapa
support expressive domains, including exogenous events richer set temporal resource constraints (e.g rover recharge battery sunset). Another direction involves
extending multi-objective search involve quality metrics. considered cost
plan terms single monetary cost associated action, complex domains,
cost may better defined vector comprising different types resource consumption.
Further, addition cost makespan, may also interested measures plan
quality robustness execution flexibility plan. longer term goal support
plan generation sensitive extended set tradeoffs. end, plan extend
methodology derive heuristics sensitive larger variety quality measures. Finally, also
plan consider issues planner-scheduler interactions context Sapa (c.f., Srivastava,
Kambhampati, & Do, 2001).
16. plan P said dominated P 0 quality P 0 strictly superior P least one dimension, better equal dimensions (Dasgupta, Chakrabarti, & DeSarkar., 2001; Papadimitriou &
Yannakakis, 2001).

192

fiS APA : ULTI -O BJECTIVE ETRIC EMPORAL P LANNER

Acknowledgments
thank Daniel Bryce developing GUI Sapa. specially thank David E. Smith
many insightful detailed comments paper. also thank JAIR reviewers
helpful comments. research supported part NSF grant IRI-9801676,
NASA grants NAG2-1461 NCC-1225.

References
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaining
approach. Proceedings IJCAI-01.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism
planning. Proceedings AAAI-97.
Chajewska, U., Getoor, L., Norman, J., & Shahar., L. (1998). Utility elicitation classification
problem. Proceedings UAI-98.
Chien, S., Rabideau, G., Knight, R., Sherwood, R., Engelhardt, E., Mutz, D., Estlin, T., Smith, B.,
Fisher, F., Barrett, T., Stebbins, T., & Tran, T. (2000). ASPEN - automating space mission
operations using automated planning scheduling. Proceedings SpaceOps-2000.
Dasgupta, P., Chakrabarti, P., & DeSarkar., S. (2001). Multiobjective Heuristic Search. Vieweg
Son/Morgan Kaufmann.
Do, M., & Kambhampati, S. (2001). SAPA: domain independent heuristic metric temporal planner. Proceedings ECP-01.
Do, M., & Kambhampati, S. (2002). Planning graph-based heuristics cost-sensitive temporal
planning. Proceedings AIPS-02.
Do, M., & Kambhampati, S. (2003). Improving temporal flexibility position constrained
metric temporal planning. Proceedings ICAPS-03.
Edelkamp, S. (2001). First solutions PDDL+ planning problems. PlanSIG Workshop.
Fox, M., & Long, D. (2001). PDDL2.1: extension PDDL expressing temporal planning
domains. Journal Artificial Intelligence Research, issue.
Fox, M., & Long, D. (2002).
Third International Planning Competition website:
http://www.dur.ac.uk/d.p.long/competition.html.
Garrido, A., Onaindia, E., & Barber, F. (2001). Time-optimal planning temporal problems.
Proceedings ECP-01.
Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphs.
Proceedings AIPS-02.
Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal planner.
Proceedings AIPS-94.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP-01.
Hoffmann, J. (2002). Extending FF numerical state variables. Proceedings ECAI-02.

193

fiD & K AMBHAMPATI

Hoffmann, J., & Nebel, B. (2001). FF planning system: Fast plan generation heuristic
search. Journal Artificial Intelligence Research, 14, 253302.
Kambhampati, S., & Kedar, S. (1994). unified framework explanation-based generalization
partially ordered partially instantiated plans. Artificial Intelligence, 67, 2970.
Kambhampati, S., & Nigenda, R. (2000). Distance based goal ordering heuristics Graphplan.
Proceedings AIPS-2000.
Koehler, J., Nebel, B., Hoffmann, J., & Dimopoulos, Y. (1997). Extending planning graphs
ADL subset. Proceedings ECP-97.
Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings
IJCAI-95.
Long, D., & Fox, M. (1998). Efficient implementation plan graph STAN. Journal
Artificial Intelligence Research, 10, 87115.
Long, D., & Fox, M. (2003). 3rd International Planning Competition: results analysis.
Journal Artificial Intelligence Research, issue.
Muscettola, N. (1994). HSTS: Integrating planning scheduling. Mark Fox & Monte Zweben
(Eds.), Intelligent Scheduling. Morgan Kaufman.
Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Proceedings IJCAI01.
Nguyen, X., Kambhampati, S., & Nigenda, R. (2001). Planning graph basis deriving
heuristics plan synthesis state space CSP search. Artificial Intelligence, 135, 73
123.
Papadimitriou, C., & Yannakakis, M. (2001). Multiobjective query optimization. Proceedings
ACM Conference Principles Database Systems.
Penberthy, S., & Well, D. (1994). Temporal planning continuous change. Proceedings
AAAI-94.
Refanidis, I., & Vlahavas, I. (2001a). framework multi-criteria plan evaluation heuristic
state-space planning. Proceedings Workshop Planning Resources, IJCAI-01.
Refanidis, I., & Vlahavas, I. (2001b). GRT planner: Backward heuristic construction forward
state space planning. Journal Artificial Intelligence Research, 15, 115161.
Smith, D., & Weld, D. (1999). Temporal planning mutual exclusion reasoning. Proceedings
IJCAI-99.
Srivastava, B., Kambhampati, S., & Do, M. (2001). Planning project management way: Efficient
planning effective integration causal resource reasoning RealPlan. Artificial
Intelligence, 131(1-2), 73134.
Younes, H., & Simmons, R. (2003). VHPOP: Versatile heuristic partial order planner. Journal
Artificial Intelligence Research, issue.
Zimmerman, T. (2002). Generating parallel plans satisfying multiple criteria anytime fashion.
Proceedings Workshop Planning Scheduling Multiple criteria, AIPS-02.

194

fiJournal Artificial Intelligence Research 20 (2003) 133-137

Submitted 09/03; published 12/03

Commentary
Imperfect Match: PDDL 2.1 Real Applications
Mark Boddy

mark.boddy@adventiumlabs.org

Adventium Labs
111 Third Avenue S.
Minneapolis, MN 55401 USA

Abstract
pddl originally conceived constructed lingua franca International
Planning Competition. pddl2.1 embodies set extensions intended support
expression something closer real planning problems. objective
partially achieved, due large part deliberate focus moving far
classical planning models solution methods.

1. Introduction
Fox Long (2003) describe set extensions pddl. claim
extensions PDDL2.1 begins bridge gap basic research applicationsoriented planning providing expressive power necessary capture real problems.
expressive extensions embodied pddl2.1 represent step right direction,
authors claim true limited sense. rest commentary attempt
make qualifying reservations clear.

2. Planning Real Applications
thing real planning problem, thing
real mathematical programming problem. real problems, people
found useful construct models apply solution techniques generally
viewed planning models techniques (or math programming techniques, something
else entirely). Examples problems planning models may useful
drawn manufacturing (e.g., batch manufacturing operations), high-level
control complex mechanisms spacecraft. math programming, continue
comparison, disciplines Chemical Engineering, major branch
concerned model solve problems chemical manufacturing using various
flavors mathematical optimization. equivalent discipline planning,
difficult characterize planning applications sense control
chemical processes may described application mathematical optimization.
lack extensive history applications makes difficult assess relevance
particular modeling solution techniques, including developed within planning
research community. International Planning Competition (IPC), held AIPS-98,
AIPS-00 AIPS-02, attempting provide data necessary make
assessments. Unfortunately, approach taken gets things backwards, implicitly asking

c
2003
AI Access Foundation. rights reserved.

fiMark Boddy

extend models everybody particular community comfortable working
with, closer think needed real application?
planning research viewed discipline akin mathematics, kind
extension known theoretical constructs makes sense. planning engineering
real applications point, theoretical work emerge from, least
tested against, generalization abstractions real applications. classical planning
approach grew work theorem-proving dynamic logics, ever since
fruitfully applied domains involving minimal interaction physical
world, describes planning domains (softbots software agent-based
applications, example), vast majority them. systems cited Fox
Longs Introduction applied real planning problems (SIPE, O-Plan,
HSTS, IxTeT), none conventional classical planners constructing totally-ordered
sequences operators. use combination methods drawn temporal
network planning HTN (task decomposition) planning. work applying planning
methods real applications, example ASPEN (Fukunaga et al., 1997), make
much use classical planning techniques, either. Perhaps classical planning addressing
wrong problem, wrong parts problem, real applications.

3. Evaluating Language
argued long line people going back least Hendrix (1973), point-based
temporal model instantaneous events effect changes world state used
build expressive models system dynamics, simply treating events
starting ending points intervals propositions hold processes change
world state. past decade so, Reiter (2001) others extended
semantics Situation Calculus (McCarthy & Hayes, 1969) encompass overlapping
actions, metric quantities, continuous change, exogenous actions, limited knowledge, contingent action effects, actions uncertain effects, among things. presented
Fox Long, pddl2.1 used express many things one might want
represent real problem. However, difference saying something
expressed given language, expression natural, intuitive, easy
use.
Take modeling resources example: pddl2.1 expressive enough represent unary resources (trucks, tools), capacity resources (power, weight), consumable
resources (fuel). easy way language refer properties
resource itself. Everything encoded action representation, example
modeling total-fuel-used example Figure 5. many real domains, resources
primary, sense hard part problem figuring resolve
resource conflicts, within constraints problem statement.
3.1 Form Follows Function
significance distinction expressed easily
expressed manipulated depends roles language intended fill. pddl2.1
origins current use language planning competition. long
current language permits (not necessarily terribly natural) expression required
134

fiImperfect Match

features domain planning problem, perhaps problem. Competitors
wish construct special-purpose data structures explicit representations
resources free so.
pddl2.1 employed beyond IPC, role(s) intended? high-level
modeling language real applications different requirements competition
standard, different language used pass planning problems solutions
machine-readable forms, different yet modular, locally-extensible language
used research tool, permitting researchers exchange example domains
able compare results using different techniques data.1
3.2 Specific Problems Language
Finally, specific problems current semantics pddl2.1,
addressed pretty much whatever use put to.
3.2.1 Holdovers Classical Model
Fox Long explicit made choices syntax semantics keep
familiar feel language classical planning community. makes good sense
objective use language push boundaries done using
extending models methods currently popular research community,
little support, may cases actively hinder, introduction features drawn
real applications.
several problems resulting stance. First, language explicitly
restricted ensure finite set ground actions, specifically planning algorithms require this. precludes modeling number different kinds domain
features, example explicit creation destruction objects (e.g., intermediate data
products, image-processing application), flexible solution continuous parameters
(for example, trajectory optimization) within existing evolving plan. Shouldnt
models methods following requirements problems solved, rather
way round?
second problem treatment durative actions atomic, rather treating
activities like heating water lighting matches starting processes may proceed
own, agent decides intervene. Consider heat-water action
defined Figure 12 Section 5.3, whose duration defined precisely required
raise water 100 C. curious result well-defined plan,
duration heat-water must exactly time required, taking account
overlapping actions may also affect temperature water, actions
may specified heat-water action added plan.
Finally, authors define semantics durative actions preconditions
required true beginning extent of, postconditions
asserted end of, intervals non-zero width open right. clean, clear,
requires special constraints well-defined semantics, least totallyordered begin end-points. at-end preconditions mess up, furthermore
wrong solution authors appear trying support, take
1. summary previous attempts construct shared ontology planning, see Tate (1998).

135

fiMark Boddy

implicit expression complex structure within durative action (this action requires p
true 2 minutes, start action). See Dave Smiths commentary, also
issue, discussion complete model complex durative actions
might look like, one less concerned staying close classical planning model.
3.2.2 Problems Definition Continuous Model
Section 5.3, Fox Long introduce notation specifying durative actions continuous effects, claiming using #t notation, possible express variety
different nonlinear functions time. least presented section, #t construction appear permit definition, implicit otherwise, nonlinear continuous
functions. example expressing effect acceleration position making
velocity vary time, evaluating position #t multiplying #t time-varying velocity also evaluated #t result incorrect answer. required operation
integration, composition.
Also section, authors say continuous durative actions dont support
exogenous events. dont understand cant, long endpoints
exogenous events also appear plan. Incorporating capability would significantly
increase range real (or realistic) problems could represented.
3.2.3 Issues
Two matters worth pointing well. First restriction numeric domains
functions, primary motivation cited previously-discussed objective
making possible construct finite extensional models set possible actions. Nonnumeric functions frequently useful real domains, example refer current
state object (the current configuration piece communication equipment, say).
Finally, authors decision support Undefined values numeric fluents
statement intended allow actions determine fluent values setting them, prior
value would unknown. Representing incomplete information, including
unknown propositional continuous states, important capability, one
addressed directly. might deliberately left later extension
understand merits addressing incompletely way.

4. Summary Conclusions
extensions embodied pddl2.1 definite step direction language
complex planning problems expressed. Fox Long done planning
community considerable service, first, designing implementing extensions,
second, presenting motivating current paper. focus backward
compatibility classical planning problematic, given expressed desire address
real (or least realistic) applications, necessary cleanups
language, noted above.
extensions pddl2.1 address likely fragmenting
field mutually incompatible sub-fields. logical end process seen
survey scheduling problems compiled Graham et al. (1977), minor

136

fiImperfect Match

differences problem statement lead different complexity classes. Classification
complexity class may less relevant field almost every interesting problem
least NP-hard, similar phenomenon arise fact problems
require different expressive capabilities others (resource constrained project scheduling
problems, versus manuever planning satellite constellations, example), hard
solve different ways (finding correct ordering plan steps, versus resolving
conflicts unary resource).
Ultimately, techniques developed classical planning literature probably prove
useful addressing complex, real-world applications. However, believe
cases central solutions. classical planning focus individual
actions, rather organizing synchronizing operations larger environment,
discrete state changes, rather multiple, interacting asynchronous processes,
propositional representations, rather constraints continuous quantities.
methods brought bear address core complexities real
planning problems, involve complex resources forms synchronized
behavior, exogenous events, temporal uncertainties agents actions
events, cases, significant continuous dynamics.
final comment, reservations regarding current state pddl2.1
taken argument utility toy problems abstract languages, especially
purposes IPC. However, simplifications abstractions employed
preserve appropriate structure, research results understanding gained
working translate real problems. believe continued
focus classical planning models methods problematic.

References
Fox, M., & Long, D. (2003). Pddl2.1: extension pddl expressing temporal planning
domains. Journal Artificial Intelligence Research, ??
Fukunaga, A., Rabideau, G., Chien, S., & Yan, D. (1997). Aspen: framework automated planning scheduling spacecraft control operations. Proc. International Symposium AI, Robotics Automation Space.
Graham, R., Lawler, E., Lenstra, J., & Rinnooy Kan, A. (1977). Optimization approximation deterministic sequencing scheduling: survey. Proceedings Discrete
Optimization.
Hendrix, G. (1973). Modeling simultaneous actions continuous processes. Artificial
Intelligence, 4, 145180.
McCarthy, J., & Hayes, P. J. (1969). philosophical problems standpoint
artificial intelligence. Machine Intelligence, 4.
Reiter, R. (2001). Knowledge Action: Logical Foundations Specifying Implementing Dynamic Systems. MIT Press, Cambridge, Mass.
Tate, A. (1998). Roots spar - shared planning activity representation. Knowledge
Engineering Review, 13, 121128.

137

fiJournal Artificial Intelligence Research 20 (2003) 61-124

Submitted 09/02; published 12/03

pddl2.1 : Extension pddl Expressing Temporal
Planning Domains
Maria Fox
Derek Long

maria.fox@cis.strath.ac.uk
derek.long@cis.strath.ac.uk

Department Computer Information Sciences
University Strathclyde, Glasgow, UK

Abstract
recent years research planning community moved increasingly towards
application planners realistic problems involving time many types resources. example, interest planning demonstrated space research community
inspired work observation scheduling, planetary rover exploration spacecraft
control domains. temporal resource-intensive domains including logistics planning, plant control manufacturing also helped focus community
modelling reasoning issues must confronted make planning technology meet
challenges application.
International Planning Competitions acted important motivating force
behind progress made planning since 1998. third competition
(held 2002) set planning community challenge handling time numeric
resources. necessitated development modelling language capable expressing
temporal numeric properties planning domains. paper describe
language, pddl2.1, used competition. describe syntax
language, formal semantics validation concurrent plans. observe
pddl2.1 considerable modelling power exceeding capabilities current planning
technology presents number important challenges research community.

1. Introduction
1998 Drew McDermott released Planning Domain Description Language, pddl (McDermott, 2000; McDermott & AIPS-98 Planning Competition Committee, 1998),
since become community standard representation exchange planning
domain models. Despite dissatisfaction community features
pddl language enabled considerable progress made planning research
ease systems sharing standard compared
enormous increase availability shared planning resources. introduction pddl
facilitated scientific development planning.
Since 1998 decisive movement research community towards application planning technology realistic problems. propositional puzzle domains
old longer considered adequate demonstrating utility planning system modern planners must able reason time numeric quantities. Although several members community working applications planning
real domains nature time (Laborie & Ghallab, 1995; Ghallab & Laruelle,
1994; Muscettola, 1994; Drabble & Tate, 1994; Wilkins, 1988) always gap
c
2003
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiFox & Long

modelling requirements domains expressed pddl.
Application-driven planners come equipped modelling conventions black
arts and, consequence, difficult reproduce results make empirical
comparisons approaches, essential scientific progress
made.
pddl language provides foundation expressive standard
constructed, enabling domain models applications-driven community shared
motivating development planning field towards realistic application.
third International Planning Competition, took place 2002, objective
closing gap planning research application. organisers third
competition authors therefore took first step defining expressive language
capable modelling certain class temporal resource-intensive planning domains.
done eye future awareness current
capabilities planners (it possible language used members
community, would competitors). paper describe resulting
language, pddl2.1, terms syntax, semantics modelling capabilities.
pddl2.1 designed backward compatible fragment pddl
common usage since 1998. compatibility supports development
resources help establish scientific foundation field AI planning.
Furthermore, McDermotts original pddl provides clean well-understood basis
development embodies number design principles considered important
retain. pddl2.1 extends pddl principled ways achieve additional expressive
power following, far possible, McDermotts maxim physics, advice (McDermott,
2000). take maxim mean language focus expressing physical
properties world, advice planner search associated
solution spaces. course, model physical systems makes simplifying assumptions
abstracts behaviours level, model claimed purely physics
free decisions could influence use model. attempt
make strong judgements constitutes advice try implement maxim
keeping language simple possible. make following two guarantees
backward compatibility:
1. existing pddl domains (in common usage) valid pddl2.1 domains.
important enable existing libraries benchmark problems remain valid.
2. Valid pddl plans valid pddl2.1 plans.
important contribution made development pddl2.1 means
domain designers provide alternative objective functions used judge
value plan. use numbers domain provides platform measuring
consumption critical resources parameters. example metric
modelled energy consumption must minimized. important many
practical applications planning plan quality might dependent number
interacting domain-dependent factors.
organisation paper follows. Section 2 introduce non-specialist
readers pddl domain description language used planning research community.
62

fipddl2.1: Expressing Temporal Planning Domains

background given order provide foundations numeric durative
extensions made developing pddl2.1. paper focusses specific extensions
introduced: numeric expressions durative actions. Section 3 start explaining
syntax numeric expressions use action descriptions. explain,
Section 4, metrics provided part problem description
quality plan involving numeric change evaluated terms appropriate
problem domain. present syntax metrics expressed give examples.
Section 5 paper introduces notion durative action way modelling
temporal properties planning domain. discretised continuous durative actions
considered. syntax described examples modelling power limitations
presented cases. given examples syntactic representation durative
actions present formal semantics discretised continuous actions
plans. Sections 6, 7, 8 9 provide details. semantics gives us way tackling
problem confirming plan validity something becomes important issue
face concurrent activity. Section 10 describe process plans
validated competition discuss complexity validation question
pddl2.1. Finally, Section 11 describes related work temporal reasoning
community, order put contributions made pddl2.1 wider context. full
bnf description pddl2.1 found appendix.
pddl2.1 developed use third International Planning Competition
competing planners demonstrated many discretized temporal metric models
efficiently handled domain-independent planners using handtailored control rules. ease reference competition identified features
pddl2.1 series levels increasing expressive power. Thus, strips fragment
pddl2.1 referred level 1, numeric extensions comprised level 2, addition
discretised durative actions resulted level 3, continuous durative actions resulted
level 4 final level, level 5, comprised extensions pddl2.1 additional
components support modelling spontaneous events physical processes. Level 5
discussed paper details found earlier work Fox Long (2002).
competition focussed use levels 1, 2 3 use levels 4 5
planning technology stage sufficiently advanced handle additional
complexities. Despite fact level 4 used competition devote
discussion paper. feel level 4 presents important immediate
challenges planning community affect extent planning
applied real problems.
purpose paper provide overview new features introduced
pddl2.1, discuss rationale language choices explain issues arisen trying extend pddl. Although provided bnf
pddl2.1 appendix, paper intended either language manual tutorial use language. examples use language
relevant materials, readers consult archived resources currently held
http://www.dur.ac.uk/d.p.long/competition.html.
63

fiFox & Long

2. pddl Background
pddl action-centred language, inspired well-known strips formulations
planning problems. core simple standardisation syntax expressing
familiar semantics actions, using pre- post-conditions describe applicability
effects actions. syntax inspired Lisp, much structure domain
description Lisp-like list parenthesised expressions. early design decision
language separate descriptions parameterised actions characterise
domain behaviours description specific objects, initial conditions goals
characterise problem instance. Thus, planning problem created pairing
domain description problem description. domain description
paired many different problem descriptions yield different planning problems
domain. parameterisation actions depends use variables
stand terms problem instance instantiated objects specific
problem instance action grounded application. pre- post-conditions
actions expressed logical propositions constructed predicates argument
terms (objects problem instance) logical connectives.
Although core pddl strips formalism, language extends beyond that.
extended expressive power includes ability express type structure objects
domain, typing parameters appear actions constraining types
arguments predicates, actions negative preconditions conditional effects
use quantification expressing pre- post-conditions. extensions
essentially proposed adl (Pednault, 1989).
Although original definition pddl syntax accompanied formal semantics, language really proposal standard syntax commonly accepted
semantics little scope disagreement meaning language
constructs. Two parts original language proposal claim fails
attempt offer standard syntax describing hierarchical domain descriptions, suitable
htn planners subset language concerned expressing numeric-valued
fluents. former ambitious project construct syntax entire structure domains using hierarchical action decompositions could expressed. contrast
strips-based planning, differences planners using hierarchical decomposition
appear deeper, domain descriptions often containing structures go beyond
description domain behaviours (for example, shop (Nau, Cao, Lotem, & MunozAvila, 1999) often uses mechanisms represent goal agendas solution-oriented
structures domain encoding). diversity undermined efforts standardisation
hierarchical domain descriptions part language never successfully
explored.
syntax proposed expressing numeric-valued fluents tested first
use language (in 1998 competition) and, indeed, underwent revision early
development language. second competition 2000 also avoided use numericvalued fluents, general agreement syntax semantics numericexpressivity language remained unnecessary. McDermotts original pddl provides
support numbers allowing numeric quantities assigned updated. syntax
numeric-valued fluents changed pddl manuals 1.1 1.2 (McDermott &
64

fipddl2.1: Expressing Temporal Planning Domains

(define (domain jug-pouring)
(:requirements :typing :fluents)
(:types jug)
(:functors
(amount ?j -jug)
(capacity ?j -jug)
- (fluent number))
(:action empty
:parameters (?jug1 ?jug2 - jug)
:precondition (fluent-test
(>= (- (capacity ?jug2) (amount ?jug2))
(amount ?jug1)))
:effect (and (change (amount ?jug1) 0)
(change (amount ?jug2)
(+ (amount ?jug1) (amount ?jug2)))))
)

Figure 1: Pouring water jugs described AI Magazine article (McDermott,
2000).

AIPS-98 Planning Competition Committee, 1998) later AI Magazine article
pddl (McDermott, 2000). McDermott presented version numeric fluents used
pddl article AI Magazine (2000) could taken definitive statement
syntax. example using numeric fluents, presented McDermott (2000), shown
Figure 1. action models action well-known jugs-and-water problem,
allowing water one jug emptied second jug provided space
second jug large enough hold water first. effect discrete update
values current contents jugs assignment (denoted
change token).
Even without numeric extensions, pddl expressive language, capable capturing wide variety interesting challenging behaviours. Figure 2 illustrates
pddl used capture domain vehicle move locations,
consuming fuel so.
seen example pddl includes syntactic representation level
expressivity required particular domain descriptions use requirements
flags. gives opportunity planning system gracefully reject attempts
plan domains make use advanced features language
planner handle. Syntax checking tools used confirm requirements
flags correctly set domain types features language
correctly employed. example problem description accompany vehicle
domain shown Figure 3. example illustrates description initial
state requires exhaustive listing (atomic) propositions hold. Symmetric
transitive relations must modelled exhaustive explicit listing propositions
hold. use domain axioms simplify description domains use
relationships considered, remains untested part pddl therefore
65

fiFox & Long

(define (domain vehicle)
(:requirements :strips :typing)
(:types vehicle location fuel-level)
(:predicates (at ?v - vehicle ?p - location)
(fuel ?v - vehicle ?f - fuel-level)
(accessible ?v - vehicle ?p1 ?p2 - location)
(next ?f1 ?f2 - fuel-level))
(:action drive
:parameters (?v - vehicle ?from ?to - location
?fbefore ?fafter - fuel-level)
:precondition (and (at ?v ?from)
(accessible ?v ?from ?to)
(fuel ?v ?fbefore)
(next ?fbefore ?fafter))
:effect (and (not (at ?v ?from))
(at ?v ?to)
(not (fuel ?v ?fbefore))
(fuel ?v ?fafter))
)
)

Figure 2: domain description pddl.
unstable part syntax. pddl domains case-sensitive, somewhat
anachronistic light standard practice modern programming languages.
following sections review extensions made pddl development
pddl2.1, version language used third International Planning Competition.

3. Numeric Expressions, Conditions Effects
One first decisions made development pddl2.1 propose definitive
syntax expression numeric fluents. based syntax version described
AI Magazine article (McDermott, 2000), minor revisions (discussed below).
Numeric expressions constructed, using arithmetic operators, primitive numeric
expressions, values associated tuples domain objects domain functions. Using proposed syntax expressing numeric assignments updates
express jug-pouring operator originally described pddl1.2 manual AI
Magazine article (see Figure 1), pddl2.1, presented Figure 4. example
functions capacity amount associate jug objects numeric values corresponding capacity current contents respectively. seen example,
used prefix syntax arithmetic operators, including comparison predicates,
order simplify parsing. Conditions numeric expressions always comparisons
pairs numeric expressions. Effects make use selection assignment
operations order update values primitive numeric expressions. include
direct assignment relative assignments (such increase decrease). Numbers
distinguished possible roles, values represent, example, quantities
resources, accumulating utility, indices counters.
66

fipddl2.1: Expressing Temporal Planning Domains

(define (problem vehicle-example)
(:domain vehicle)
(:objects
truck car - vehicle
full half empty - fuel-level
Paris Berlin Rome Madrid - location)
(:init
(at truck Rome)
(at car Paris)
(fuel truck half)
(fuel car full)
(next full half)
(next half empty)
(accessible car Paris Berlin)
(accessible car Berlin Rome)
(accessible car Rome Madrid)
(acessible truck Rome Paris)
(accessible truck Rome Berlin)
(accessible truck Berlin Paris)
)
(:goal (and (at truck Paris)
(at car Rome))
)
)

Figure 3: problem instance associated vehicle domain.

(define (domain jug-pouring)
(:requirements :typing :fluents)
(:types jug)
(:functions
(amount ?j - jug)
(capacity ?j - jug))
(:action pour
:parameters (?jug1 ?jug2 - jug)
:precondition (>= (- (capacity ?jug2) (amount ?jug2)) (amount ?jug1))
:effect (and (assign (amount ?jug1) 0)
(increase (amount ?jug2) (amount ?jug1)))
)

Figure 4: Pouring water jugs, pddl2.1 style.

67

fiFox & Long

differences pddl2.1 syntax AI Magazine syntax
declaration functions use assign instead change. decided
allow numeric-valued functions, making declaration function return types
superfluous. therefore simplified language requiring declaration
function names argument types, required predicates. felt change
ambiguous used alongside operations increase decrease assign
would clearer.
Numeric expressions allowed appear terms language (that is,
arguments predicates values action parameters). two justifications
decision philosophical one pragmatic one. Philosophically take
view finite number objects world. Numbers exist
unique independent objects world, values attributes objects.
models object-oriented sense actions seen methods
apply objects given parameters. object-oriented view directly
inform syntax representations, reflected way numbers
manipulated relationships objects identified named
initial state. Pragmatically, many current planning approaches rely able
instantiate action schemas prior planning, feasible finite
number action instances. branching planners search space, choice points
corresponding action selection, therefore always finite ranges. use numeric
fluent variables conflicts could occur arguments predicate
would define finite ranges.
decision allow numbers used arguments actions rules
actions might seem intuitively reasonable. example, action fly certain
altitude might expected take altitude number-valued argument.
possible pddl2.1 range numbers used finite. practical
point view think unlikely arduous constraint benefits
keeping logical state space finite compensates modelling awkwardness
results.
Functions pddl2.1 restricted type Objectn R, (finite) collection objects planning instance, Object finite function arity n. Later extensions
pddl might introduce functions type Objectn Object, allowing Object extended application functions objects. advantage would
allow objects referred relationships known objects. (For example,
(onTopOf ?x) could used refer object currently top object instantiating ?x). Unfortunately, functions present various semantic problems. particular,
interpretation quantified preconditions becomes significantly harder, since collection objects longer necessarily finite, extensional interpretations possible.
difficulty identity problem objects manipulated actions,
functional expressions refer also affected, implicitly. example,
objects moved, (onTopOf A) change without action manipulating explicitly.
Managing way functional terms map specific objects domain (which
might might specific names own) appears introduce considerable
complication semantics. believe important avoid extending pddl
elements still poorly understood.
68

fipddl2.1: Expressing Temporal Planning Domains

4. Plan Metrics
adoption stable numeric extension pddl core allowed us introduce
extension pddl2.1, namely new (optional) field within specification
problems: plan metric. Plan metrics specify, benefit planner, basis
plan evaluated particular problem. initial goal
states might yield entirely different optimal plans given different plan metrics. course,
planner might choose use metric guide development solution
evaluate solution post hoc. approach might lead sub-optimal, possibly
even poor quality plans, pragmatic approach handling metrics
quite widely used competition. issue discussed companion
paper analysing results 3rd IPC issue (Long & Fox, 2003b).
value total-time used refer temporal span entire plan.
values must built primitive numeric expressions defined within domain
manipulated actions domain. consequence, plan metrics
express non-temporal metrics pddl2.1 domains using numeric expressions. arithmetic expression used specification metric requirement
expression linear. domain designers responsibility ensure plan
metrics well-defined (for example, involve divisions zero). example use
plan metric shown Figure 5.
implications introduced extension far-reaching already
helped demonstrate important new challenges planning systems particularly
fully-automated systems. enriched descriptive power evaluation plans
crucial extension practical use planners, since almost never case real
plans evaluated solely number actions contain.
Metrics described problem description, allowing modeller easily explore
effect different metrics construction solutions problems
domain. order define metric terms specific quantity necessary
instrument quantity domain description. example, metric defined
terms overall fuel use fuel-use quantity initialised zero initial state
updated every time fuel consumed. domain shown Figure 5 possible
minimise linear combination fuel used vehicles as:
(:metric minimize (+ (* 2 (fuel-used car)) (fuel-used truck)))

However possible minimise distance covered since distance instrumented.
would straightforward instrument desired, simply adding appropriate initial
value incrementing effects domain description. Since actions cause quantities
change, instrumenting value requires modification domain description itself,
problem file.
use plan metrics subtle dramatic impact plans
sought. Perhaps simplest case actions increase metric must
minimised, decrease one must maximised. case example shown
Figure 5, use drive action worsen value plan metric
(whether use metric shown figure maximising metric described
last paragraph). situation might appear relatively straightforward: planner
69

fiFox & Long

(define (domain metricVehicle)
(:requirements :strips :typing :fluents)
(:types vehicle location)
(:predicates (at ?v - vehicle ?p - location)
(accessible ?v - vehicle ?p1 ?p2 - location))
(:functions (fuel-level ?v - vehicle)
(fuel-used ?v - vehicle)
(fuel-required ?p1 ?p2 - location)
(total-fuel-used))
(:action drive
:parameters (?v - vehicle ?from ?to - location)
:precondition (and (at ?v ?from)
(accessible ?v ?from ?to)
(>= (fuel-level ?v) (fuel-required ?from ?to)))
:effect (and (not (at ?v ?from))
(at ?v ?to)
(decrease (fuel-level ?v) (fuel-required ?from ?to))
(increase (total-fuel-used) (fuel-required ?from ?to))
(increase (fuel-used ?v) (fuel-required ?from ?to)))
)
)
(define (problem metricVehicle-example)
(:domain metricVehicle)
(:objects
truck car - vehicle
Paris Berlin Rome Madrid - location)
(:init
(at truck Rome)
(at car Paris)
(= (fuel-level truck) 100)
(= (fuel-level car) 100)
(accessible car Paris Berlin)
(accessible car Berlin Rome)
(accessible car Rome Madrid)
(accessible truck Rome Paris)
(accessible truck Rome Berlin)
(accessible truck Berlin Paris)
(= (fuel-required Paris Berlin) 40)
(= (fuel-required Berlin Rome) 30)
(= (fuel-required Rome Madrid) 50)
(= (fuel-required Rome Paris) 35)
(= (fuel-required Rome Berlin) 40)
(= (fuel-required Berlin Paris) 40)
(= (total-fuel-used) 0)
(= (fuel-used car) 0)
(= (fuel-used truck) 0)
)
(:goal (and (at truck Paris)
(at car Rome))
)
(:metric minimize (total-fuel-used))
)

Figure 5: example domain problem instance describing plan metric.
70

fipddl2.1: Expressing Temporal Planning Domains

must attempt use actions solve problem possible. fact, even case
little complex appears rival plans one uses
actions lower overall cost other. complex case arises
actions improve quality metric others degrade it. example, use
maximising metric also add refuel action domain driving degrade plan
quality (by reducing fuel level vehicle) refuelling improve plan quality (by
increasing fuel level vehicle). case, planner attempt use actions
improve plan quality without actions actually contributing achieving goals.
example, refuelling might necessary get vehicles destinations,
adding refuelling actions would improve quality solution. process could
involve trading finite irreplaceable resources increased value plan.
would case if, example, refuelling vehicle took fuel finite reservoir.
Alternatively domain could allow plans arbitrarily high value constructed
using actions. would occur metric vehicles domain using
maximising vehicles fuel level metric refuelling constrained, since domain
impose limit fuel capacities vehicles.
case plans constrained finite availability resources, important
interesting form planning problem, case plans arbitrarily
high utility constructed, obviously ill-defined problem, since optimal plan
exist. non-trivial determine whether planning problem provided
metric ill-defined. fact, Helmert shows (Helmert, 2002), introduction numeric
expressions, even constrained way adopted pddl2.1, makes
planning problem undecidable. problem finding collection actions
consume irreplaceable resources overall beneficial impact plan metric
least hard planning problem. Therefore clear determining whether
planning problem even well-defined undecidable. make worthless
consider planning metrics, course, demonstrates modelling problem,
well planning problem, becomes even complex metrics introduced.
One strategy available planners working problems subject plan metrics
ignore metric simply produce plan satisfy logical goals problem
specifies. case, plan quality simply value, according metric,
plan happens constructed. strategy unsophisticated obviously
better planner construct plan guided specified metric. best use
metric expedite search process fully-automated planner still research issue.

5. Durative Actions
recent work temporal planning (Smith & Weld, 1999; Bacchus & Kabanza, 2000;
& Kambhampati, 2001) based various forms durative action. order
facilitate participation competition therefore developed two forms durative
action allowing specification restricted forms timed conditions effects
description. Although constrained certain ways, durative actions are,
nevertheless, expressive many proposals previously explored, particularly
way allow concurrency exploited. two forms discretised
durative actions continuous durative actions.
71

fiFox & Long

(:durative-action load-truck
:parameters (?t - truck)
(?l - location)
(?o - cargo)
(?c - crane)
:duration (= ?duration 5)
:condition (and (at start (at ?t ?l))
(at start (at ?o ?l))
(at start (empty ?c)
(over (at ?t ?l))
(at end (holding ?c ?o))
:effect (and (at end (in ?o ?t))
(at start (holding ?c ?o))
(at start (not (at ?o ?l)))
(at end (not (holding ?c ?o)))
)

Figure 6: durative action loading truck. assume capacity constraints.

forms rely basic durative action structure consisting logical changes
caused application action. always consider logical change instantaneous,
therefore continuous aspects continuous durative action refer numeric
values change interval action. Figure 6 depicts basic durative action,
load-truck, numeric change.
modelling temporal relationships discretised durative action done means
temporally annotated conditions effects. conditions effects durative actions
must temporally annotated. annotation condition makes explicit whether
associated proposition must hold start interval (the point action
applied), end interval (the point final effects action
asserted) interval start end (invariant duration
action). annotation effect makes explicit whether effect immediate (it
happens start interval) delayed (it happens end interval).
time points accessible, discrete activity takes place identified start
end points actions plan.
Invariant conditions durative action required hold interval
open ends (starting ending end points action). expressed
using construct seen Figures 6 8. one wants specify fact p
holds closed interval duration durative action, three conditions
required: (at start p), (over p) (at end p).
considered adopting convention constraints apply
start end points well open interval inside durative action, decided
would impossible express conditions actually
required hold open interval. Examples actions conditions
invariant open interval include action loading truck. truck must
remain loading location throughout loading interval, start move
away simultaneously loading completed. reason start
72

fipddl2.1: Expressing Temporal Planning Domains

drive action non-mutex end load reasonable interpretation
plan driving starts instant loading completed. Actions affect
invariant condition (such location truck) executed simultaneously
end point durative action invariant constrained hold true
end point itself. highlights important difference (over all) (over
end). condition required end precondition well invariant
condition meaning action affects invariant must start end
action requiring invariant. example, make (at truck location) end
precondition load operator well invariant, consequence truck
cannot drive away instant load completed.
Note that, definition load-truck action Figure 6, chosen make
condition (holding ?c ?o) start effect end precondition invariant
condition. means crane could temporarily cease hold cargo
time interval, long holding cargo time deposit end
loading interval. makes action quite flexible, enabling exploitation
concurrent uses crane applicable.
load-truck example shows logical change wrapped durative
actions encapsulate much detail involved achieving effect sequence
connected activities. Naturally would useful able combine actions
concurrently within plan. next section consider extent concurrency
allowed ways concurrent plans interpreted.
5.1 Interpretation Concurrent plans
time introduced modelling domain possible concurrent activity
occur plan. Prior introduction time pddl plans interpreted
sequential even Graphplan-concurrent plans sequenced validated
concurrency never issue. pddl2.1 plan validity depend exploiting
concurrency correctly. Actions overlap co-occur, giving rise questions
interpretation synchronous behaviour. discuss problems arising precise
synchronization Section 10. explain constraints actions occur
concurrently within plan involving durative actions numeric conditions effects.
key difference, durative actions pddl2.1 used planners prior
competition, distinguish conditions effects start
end points durative interval invariant conditions might specified
hold interval. is, actions pre- postconditions local
two end-points action, planner choose exploit durative action
effects start end. Conditions invariant distinguished
pre-conditions, enabling exploitation higher degree concurrency
possible preconditions distinguished invariants, tgp (Smith & Weld,
1999), tpsys (Garrido, Onainda, & Barber, 2001) tp4 (Haslum & Geffner, 2001).
discuss consequences design decisions, together several examples
durative actions, following sections.
important observe view time point-based rather interval-based.
is, see period activity terms intervals state separated time points
73

fiFox & Long

state-changing activities occur. logical state change occurs instantaneously,
start end point durative action. Propositions true half-open intervals
closed left open right. Activities might change logical state
might update values numeric variables. discretised view time
allow finite number activities (which call happenings) two time
points, although time considered continuous actions scheduled begin
time point.
plan considered valid, logical condition asserted negated
instant. impose constraint logical condition
required hold asserted instant. Although might seem overly
strong claim plan cannot guaranteed valid instant
proposition required exactly instant asserted. require that,
action precondition P start time t, must half open interval immediately
preceding P holds. mathematically inconsistent P asserted
instant required. conservative view validity
simultaneous update access state proposition. example, two
instantaneous actions, B, precondition P effects (not P ) Q,
B precondition P Q effect R, consider attempt apply
B simultaneously state P holds ill-defined. reason that, although
switches state one P holds one Q holds one might
suppose precondition B secure, abstraction model
values P Q changing and, argue, reliance values point
change unstable. adopt rule call moving targets, mean
two actions simultaneously make use value one two accessing value
update value moving target action access. rule creates
behaviour propositions planning state much like behaviour
variables shared memory protected mutex lock (such POSIX threads),
difference read write access variable.
Validity also requires numeric value accessed updated simultaneously
start end point durative action. case discretised durative actions,
numeric change modelled terms step functions numeric values accessed,
updated, interval another durative action acting value (we provide
examples following section) provided updates consistent invariant
properties dependent value. case continuous durative actions, values
simultaneously accessed updated continuous process change occurring
interval action. discretised continuous cases allow multiple
simultaneous updates provided update operations commutative.
order implement mutual exclusion relation require non-zero-separation
mutually exclusive action end points. view, end points nonconflicting treated though possible execute simultaneously
even though precise synchronicity cannot achieved world. However, end
points mutually exclusive planner buffer co-occurrence points
explicitly separating them. way ensure concurrency plan
least plausible world.
74

fipddl2.1: Expressing Temporal Planning Domains

(:durative-action heat-water
:parameters (?p - pan)
:duration (= ?duration (/ (- 100 (temperature ?p)) (heat-rate)))
:condition (and (at start (full ?p))
(at start (onHeatSource ?p))
(at start (byPan))
(over (full ?p))
(over (onHeatSource ?p))
(over (heating ?p))
(at end (byPan)))
:effect (and
(at start (heating ?p))
(at end (not (heating ?p)))
(at end (assign (temperature ?p) 100)))
)

Figure 7: simple durative action boiling pan water.

Planners exploit considerable concurrency domain ensuring conflicting start end points actions separated non-zero amount. detailed
specification mutual exclusion relation pddl2.1 given Section 8.
discuss implications non-zero separation Section 10.
5.2 Numeric Change within Discretised Durative Actions
section explains continuous change sometimes modelled pddl2.1 using
durative actions discrete effects. achieved using step functions describe
instantaneous changes beginnings ends durations actions. Appendix
details language constructs involved.
example durative action, illustrating use numeric update operations,
shown Figure 7. example showing water heating action, conditions (full ?p)
(onHeatSource ?p) must hold start interval well interval.
model enter conditions start constraints.
action achieves start effect water heating, condition maintained
invariant whole interval action. example operator
achieves invariant condition, draws attention fact conditions
hold interval open left (as well right).
noted actions Figures 7 8 use fixed duration specifications.
case water-boiling example means impossible adjust length
time pan heated impact context
action used. particular, assign construct used update numeric
value, possible concurrent activity affect value else model
flawed. water heating example uses assign construct concurrent
activity affect temperature water. responsibility modeller
ensure temperature neither accessed updated interval
action executing.
75

fiFox & Long

(:durative-action navigate
:parameters (?x - rover ?y - waypoint ?z - waypoint)
:duration (= ?duration (travel-time ?y ?z))
:condition (and (at start (available ?x))
(at start (at ?x ?y))
(at start (>= (energy ?x)
(* (travel-time ?y ?z) (use-rate ?x))))
(over (visible ?y ?z))
(over (can_traverse ?x ?y ?z)))
:effect (and (at start (decrease (energy ?x)
(* (travel-time ?y ?z) (use-rate ?x))))
(at start (not (at ?x ?y)))
(at end (at ?x ?z))))
(:durative-action recharge
:parameters (?x - rover ?w - waypoint)
:duration (= ?duration (recharge-period ?x))
:condition (and (at start (at ?x ?w))
(at start (in-sun ?w))
(at start (<= (energy ?x) (capacity ?x)))
(over (at ?x ?w)))
:effect (at end (increase (energy ?x) (* ?duration (recharge-rate ?x)))))

Figure 8: Discretised durative actions rover move locations recharge.

decided leave modeller ensure correct behaviour assign construct want forbid modelling truly discontinuous updates.
example, durative action models deposit cheque bank account might
duration three days, discontinuous update account balance
end interval would inappropriate prevent actions accessing
balance three day period. general, modelling continuous change discrete
effects open various pitfalls. price paid convenience
specify details continuous processes.
use discretised durative actions combination numeric (step-function)
updates requires care modelling. particular, relies notion conservative
resource updating. updating resource levels conservative consumption
resource modelled happens start durative action, even though
actually happens continuously duration action, production resource
modelled happens end durative action even though, again, might
actually produced continuously interval.
example discretised durative action, Figure 8 shows action
rover navigating two points modelled. local precondition start
period rover start location. Local effects include rover
consumes appropriate amount energy destination. first
conservative therefore immediate, second logical effect occurs
end point. organisation ensures parallel activities consume energy
already committed navigation activity. Similarly, recharge action
76

fipddl2.1: Expressing Temporal Planning Domains

Projected energy production
Actual energy profile
Initial Energy

Energy changing
production
consumption

Step function model
energy consumption
dig action

Final stage digging action
Final Energy
Step function model
energy produced
recharge action

Zero Energy
Recharge Action
Dig Action

Figure 9: Using discrete actions model production consumption resource.
reality, recharge activity produces energy continuously concurrent dig
activity continuously consumes it. conservative model using step functions
requires energy consumed digging must available start
action, despite yet updated model show additional
energy accumulated part recharge action far executed.
final energy level consistent used continuous model.

makes new charge available conclusion action, charge gained
cannot exploited recharging complete. use conservative updates
ensures model support invalid concurrency.
Figure 9 illustrates recharging digging action (that consumes energy) would
interact conservative energy consumption model. model would allow concurrent actions consume energy provided consume energy left
conservative assumption dig action consumed demands
start recharge action produced nothing end. Note example
assumes energy constraints capacity constraint.
use conservative updates subtle. capacity constraint
energy level rover one would need consider two separate resources: energy
space available storage energy. dig action would consume energy
start produce space end, recharge action would consume space
start produce charge end. Using combination would possible
ensure plans consume either resource available.
Durative actions conditional effects. antecedents consequents
conditional effect temporally annotated possible specify condition
checked start end, effect asserted either points.
77

fiFox & Long

(:durativeaction burnMatch
:parameters (?m match ?l location)
:duration (and (< ?duration 5) (> ?duration 0))
:condition (and (at start (have ?m))
(at start (at ?l)))
:effect (and (when (at start (dark ?l))
(and (at start (not (dark ?l)))
(at start (light ?l))))
(at start (not (have ?m)))
(at start (burning ?m))
(at end (not (burning ?m)))
(when (at start (dark ?l))
(and (at end (not (light ?l)))
(at end (dark ?l))))))
Actions

(:action pickUp
:parameters (?l location ?o object)
:precondition (and (at ?l)
(onFloor ?o ?l)
(light ?l))
:effect (and (not (onFloor ?o ?l))
(have ?o)))

Initial state: (onFloor coin) (have aMatch) (at basement) (dark basement)
Goal: (have coin)
Problem
Plan: 0.1 (burnMatch aMatch basement) [0.2]
0.2 (pickUp basement coin)
pickUp coin

Start burnMatch
dark basement

End burnMatch
light basement

0.1

0.2

dark basement

0.3

Plan

Figure 10: example problem durative action useful start effects.
burning match produces light necessary pick coin.

semantics makes clear well-formed durative action conditional effects cannot
require condition checked effect asserted. Conditional effects
arise pddl2.1 variants. discuss occurrence discretized durative actions
interpreted Section 8.1.
pddl2.1 allows specification duration inequalities enabling actions described
external factors involved determining temporal extent.
match-burning example shown Figure 10 seen effect start point
one interest, planner would exploit action start rather
end effect. duration inequality specifies match burn longer
specified upper bound. model shows match put early planner
considers appropriate. discuss use duration inequalities Section 5.3.
78

fipddl2.1: Expressing Temporal Planning Domains

5.3 Durative Actions Continuous Effects
objective discrete durative actions abstract continuous change concentrate end points period change takes place. syntax allows
precise specification discrete changes end points durative actions. However,
plan needs manage continuously changing values, well discretely changing
ones, durative action language semantics need powerful. General durative actions continuous well discrete effects. increase, decrease,
numeric variable according specified rate change time variable.
determining achieve goal planner must able access values
continuous quantities arbitrary points time-line plan. use #t refer
continuously changing time start durative action execution.
example, express fact fuel level plane, ?p, decreases continuously,
function consumption rate ?p, write:
(decrease (fuel-level ?p) (* #t (consumption-rate ?p)))

distinctly different from:
(at end (decrease

(fuel-level ?p)
(* (flight-time ?a ?b) (consumption-rate ?p))))

latter single update happening end point flight action, whilst
former allows correct calculation fuel level plane point
interval. former continuous effect, whilst latter discrete one. Continuous
effects temporally annotated evaluated time
interval action. #t local durative action, durative action
access purely local clock. Another way interpret expression representing
continuous change differential equation:

(fuel-level ?p) = (consumption-rate ?p)
dt
chose use #t symbol instead differential equation possible two
concurrent actions simultaneously modifying quantity. case, use
differential equations would actually form inconsistent pair simultaneous equations,
rather intended effect combined contribution changing value
quantity. Although expressions describing continuous change take form
product #t quantity, possible express complex change using
interdependent concurrent effects. example, acceleration arises simply increasing
distance using quantity describing velocity, time increasing velocity
using quantity describing acceleration. dependencies changing terms
include mutual dependencies terms differential equations arise
lead continuous change dictated exponential, logarithmic exponential functions.
plan containing continuous durative actions assign to, consult, continuously
modify numeric variables concurrently (see Example 1).
Figures 12 14 discrete continuous actions heating pan water
presented (this simple model ignores heat loss). discrete action presented Figure 12
modifies version presented Figure 7 use duration inequality constraint.
79

fiFox & Long

Example 1 flying refuelling example shown Figure 11 seen
invariant condition, fuel-level greater (or equal to) zero
flight, maintained whilst fuel continuously decreasing.
could expressed discrete durative actions abstracting continuous
decrease making final value available end point flight. However,
refuel operation happens flight time (in mid-air) fuel level
flight need calculated taking account continuous
rate consumption refuel operation. discrete action could calculate
fuel-level correctly would access distance
source destination flight, together rate consumption,
determine final fuel level. order calculate fuel level correctly
necessary determine time refuel takes place, use
remaining flight-time calculate fuel consumed. Discrete durative actions
give access time points start end points.
Discrete durative actions used express desired combinations flying
refuelling providing additional durative actions, fly-and-refuel,
encapsulate interactions described end calculating fuel level
correctly. However, approach requires domain designer
planner domain designer must anticipate every useful combination
behaviours ensure appropriate encapsulations provided.
contrast discrete form, continuous action, fuel consumption effect given terms #t, powerful enough express fact
mid-flight refuelling plane affects final fuel level way consistent
maintaining invariant fly action.

(:durative-action fly
:parameters (?p - airplane ?a ?b - airport)
:duration (= ?duration (flight-time ?a ?b))
:condition (and (at start (at ?p ?a))
(over (inflight ?p))
(over (>= (fuel-level ?p) 0)))
:effect (and (at start (not (at ?p ?a)))
(at start (inflight ?p))
(at end (not (inflight ?p)))
(at end (at ?p ?b))
(decrease (fuel-level ?p)
(* #t (fuel-consumption-rate ?p)))))
(:action midair-refuel
:parameters (?p)
:precondition (inflight ?p)
:effect (assign (fuel-level ?p) (fuel-capacity ?p)))

Figure 11: continuous durative action flying.

80

fipddl2.1: Expressing Temporal Planning Domains

(:durative-action heat-water
:parameters (?p - pan)
:duration (at end (<= ?duration (/ (- 100 (temperature ?p))
(heat-rate))))
:condition (and (at start (full ?p))
(at start (onHeatSource ?p))
(at start (byPan))
(over (full ?p))
(over (onHeatSource ?p))
(over (heating ?p))
(at end (byPan)))
:effect (and
(at start (heating ?p))
(at end (not (heating ?p)))
(at end (increase (temperature ?p)
(* ?duration (heat-rate)))))
)

Figure 12: discrete durative action heating pan water, using variable duration.

Duration inequalities add significant expressive power duration equalities. Duration
constraints express inequalities associated additional requirements flag
extended expressiveness fixed-duration discrete durative actions.
actions, logical post-condition start period pan
heating. conditions pan heating, full heat source invariant,
although presence agent (by pan) local precondition two
end-points invariant. first action duration modelled expressing
following duration inequality constraint:
(at end (<= ?duration (/ (- 100 (temperature ?p)) (heat-rate))))

effect end-point discrete durative action temperature
pan increased (* ?duration (heat-rate)) (where heat-rate domain
constant). continuous action Figure 14 duration constraint unnecessary
since invariant
(over (<= (temperature ?p) 100))

added ensure pan never exceeds boiling.
durative action Figure 12 models heating pan face possible concurrent activities affecting temperature. duration inequality allows planner
adapt duration take account temperature-affecting activity way
possible duration specified using equality constraint. duration
constraint ensures temperature never exceeds boiling checking, precondition updating activity, computed temperature increase executed
without exceeding boiling point. temperature increase would exceed boiling
plan invalid. temperature end interval execution computed
current temperature heating rate, together duration
heating action active (see discussion Example 2).
81

fiFox & Long

Example 2 plan attempts heat pan (say applying blowtorch
pan), heat-water interval then, provided concurrent action
ends end heat-water action, duration constraint seen
violated duration chosen overall increase
temperature would exceed boiling. concurrent activity ends simultaneously
heat-water action no-moving-targets rule would violated
duration constraint would attempt access temperature time
point concurrent action attempted update it.
Figure 13 depicts two situations. figure, apply-blowtorch durative
action applies heat object (in case, pan). part (a) figure
duration constraint violated duration heat-water action
sufficient cause temperature increase beyond boiling combined
heat increase caused blowtorch case plan invalid.
planner choose value duration avoids violation. part (b)
plan determined invalid regardless duration action
no-moving-targets rule. Notice model attempt model
consequences continued heating pan boiling point, plans
actions cause occur simply invalid. However, pddl2.1 used
model physical situation, consequences explicit
planner choose exploit avoid accordingly.

(a)

(b)

heatwater

applyblowtorch

heatwater
check duration
constraint

applyblowtorch

increase temperature
pan

Simultaneous change
consultation
temperature

Figure 13: Heating pan discrete durative action, concurrently another heating
activity.

82

fipddl2.1: Expressing Temporal Planning Domains

(:durative-action heat-water
:parameters (?p - pan)
:duration ()
:condition (and (at start (full ?p))
(at start (onHeatSource ?p))
(at start (byPan))
(over (full ?p))
(over (onHeatSource ?p))
(over (heating ?p))
(over (<= (temperature ?p) 100))
(at end (byPan)))
:effect (and
(at start (heating ?p))
(at end (not (heating ?p)))
(increase (temperature ?p) (* #t (heat-rate))))
)

Figure 14: continuous durative action heating pan water.
use duration inequalities adds significant expressive power even using discrete durative actions. example, plan depicted part (a) Figure 13,
illustrates use water-heating action shown Figure 12 concurrently heating pan blowtorch, considered valid provided duration
value satisfies duration constraint water-heating action. brings us
close expressive power available continuous durative actions gives
planner power exploit concurrent interacting activities enacting changes
numeric valued variable (see Example 3). Attempting express continuous change
using duration inequalities give precisely equivalent behaviour,
discretisation forces actions access changing numeric values separated,
small temporal interval, actions change values order resolve
mutual exclusion. continuous model necessary true value
numeric variable available consultation time continuous process
change.
discrete semantics presented Section 8 exploit fact changes
occur plan executed points corresponding times happenings, plan checked looking activity focussed finite happening
sequence. fact, provided continuous effects restricted linear functions time
first order effects (which requires continuous effects affect numeric
expressions contributing rate change another numeric valued variable), invariants restricted linear functions changing quantities, still possible restrict
attention happening sequence even using continuous actions.
Non-linear effects higher-order rates change create difficulties since possible
invariant satisfied end points interval, without necessarily
satisfied throughout interval. cases longer sufficient insert
invariant checking actions fixed mid-points happening sequence plan order
validate behaviour. However, provided effects first-order linear,
invariants linear continuously changing values, then, despite fact arbitrary
83

fiFox & Long

Example 3 possible discrete durative actions, duration inequalities,
model effects adding egg heating water water at, say,
90 degrees. applying two heat-water actions, around add-egg action, way overall duration two heat-water actions exactly
duration required boil water original temperature. However,
way heat-water action currently modelled means heat turned
egg added, turned complete heating, since
temperature updated durative action terminates. continuous durative actions egg added whilst single heat-water action
progress since temperature pan continuously updated. So, discrete durative actions duration inequalities allow us approximate continuous activity
appending finite sequence discrete intervals appropriate way.
moving targets rule means end points intervals separated
non-zero, arbitrarily small, time gaps. required using continuous
actions because, contrast step-function effects discrete actions, continuous effects localised single point.

time points within action intervals accessible planner, necessary gain
access numeric values start- end-points actions plan refer
them, together finitely many mid-points invariant-checking actions. values
required points. continuous durative actions
support modelling exogenous events, necessary take account
exogenous activity environment determining validity plan.
5.4 Related Approaches
Time important numerically varying quantity. simplest way reason time
adopt black box durative action model change happens ends
durative intervals. approach taken language used TGP (Smith &
Weld, 1999), example, durative actions encapsulate continuous change
correct values affected variables guaranteed end points
implied intervals. logical numeric effects durative action enacted
end action undefined interval execution. undeleted
preconditions must remain true throughout interval. syntactic distinction
preconditions invariant conditions action representation. simplistic
way ensuring correct action application prevent concurrent actions refer
facts, excludes many intuitively valid plans.
sophisticated approach allows preconditions annotated time points,
intervals, requirement condition true point,
interval, within duration action expressed. approach taken
Sapa (Do & Kambhampati, 2001). example, using annotated precondition
would possible express requirement chemical additive added within
two minutes start tank-filling action. effects also specified occur
arbitrary points within duration action possible express effects
84

fipddl2.1: Expressing Temporal Planning Domains

occur end specified duration. also possible distinguish
conditions local specific points duration action
invariant throughout action.
Allowing reference finitely many time points start end actions
makes language complex without adding expressive power. time
points strictly scheduled relative start action effect achieved
use sequence linked durative actions. decided keep pddl2.1
simple restricting access end points actions.
TLPlan (Bacchus & Ady, 2001) similar, constrained, approach adopted
actions applied instantaneously delayed effects. delays
effects arbitrary different effect. However, invariants cannot specified
preconditions checked instant application subsequent delayed
effects separated action initiated them.
Several planners developed use networks temporal constraints (Ghallab
& Laruelle, 1994; Jonsson, Morris, Muscettola, & Rajan, 2000; El-Kholy & Richards, 1996)
handle temporal structure planning problems. Efficient algorithms exist handling
constraints (Dechter, Meiri, & Pearl, 1991) make practical managing
large networks. domain models constructed using pddl2.1 certainly lend
treatment similar techniques, constrained handled way.

6. Introduction Semantics pddl2.1
Sections 7 8 provide formal semantics numeric extension temporal
extension pddl2.1. Together sections contain 20 definitions. lengthy treatment
necessary semantics developed adds four significant extensions
classical planning semantics Lifschitz developed strips (Lifschitz, 1986).
are:
introduction time, plans describe behaviour relative real time line;
related first extension, treatment concurrency actions executed
parallel, lead plans contain concurrent interacting processes
(although processes encapsulated durative actions pddl2.1);
extension handle numeric-valued fluents;
use conditional effects, alone conjunction
extensions.
semantics built familiar state-transition model. requirements semantics reduced four essential elements.
1. define state. introduction time numeric values complicate
usual definition state set atoms.
2. define state satisfies propositional formula representing goal condition
precondition action. extension usual interpretation state
valuation atom true atom state (the Closed
World Assumption) required order handle numeric values state.
85

fiFox & Long

3. define state transition induced application action. update rule
logical state must supplemented explanation consequences
numeric part state.
4. define two actions applied concurrently concurrent
application affects application actions individually.
structure definitions follows. Definitions 1 15, given Section 7,
define means plan valid plan consists non-durative
actions. Definitions 1 6 set basic terminology, foundational structures
framework handling conditional effects primitive numeric expressions. Definition 2 meets first requirement identified above, defining states. Definition 9 meets
second requirement, defining goal description satisfied state. Definition 11
defines simple plan, extending classical notion sequence actions adding
time. Definitions 12 meets fourth requirement, defining two actions cannot
executed concurrently. Definition 13 meets third requirement, defining mean
execution actions, including concurrent execution actions. Definitions 14 15
define execution plan means plan valid, given basis laid
previous definitions.
Section 8 semantics extended give meaning durative actions. begin
Definition 16, defines ground durative actions analogously Definition 6
simple (that is, non-durative) actions. Similarly, Definition 17 parallels definition
simple plan (Definition 11) Definitions 19 20 parallel execution
validity simple plans (Definitions 14 15). Definition 18 critical definition
semantics plans durative actions, supplying transformation temporal plans
simple plans, whose validity according semantics purely simple plans,
used determine validity original temporally structured plans.

7. Semantics Simple Plans
semantics define section extends essential core Lifschitz strips semantics (1986) handle temporally situated actions, possibly occurring simultaneously,
numeric conditional effects.
Definition 1 Simple Planning Instance simple planning instance defined
pair
= (Dom, P rob)
Dom = (F s, Rs, As, arity) 4-tuple consisting (finite sets ) function symbols,
relation symbols, actions (non-durative), function arity mapping symbols
respective arities. P rob = (Os, Init, G) triple consisting objects
domain, initial state specification goal state specification.
primitive numeric expressions planning instance, P N Es, terms constructed function symbols domain applied (an appropriate number )
objects drawn Os. dimension planning instance, dim, number
distinct primitive numeric expressions constructed instance.
86

fipddl2.1: Expressing Temporal Planning Domains

atoms planning instance, Atms, (finitely many) expressions formed
applying relation symbols Rs objects Os (respecting arities).
Init consists two parts: Initlogical set literals formed atoms Atms.
Initnumeric set propositions asserting initial values subset primitive
numeric expressions domain. assertions assign single primitive
numeric expression constant real value. goal condition proposition
include atoms formed relation symbols objects planning instance
numeric propositions primitive numeric expressions numbers.
collection action schemas (non-durative actions) expressed syntax
pddl. primitive numeric expression schemas atom schemas used action
schemas formed function symbols relation symbols (used appropriate
arities) defined domain applied objects Os schema variables.
semantics shows instantiated action schemas interpreted state transitions, similar way familiar state transition semantics defined Lifschitz.
important difference states longer seen simply sets propositions,
must also account numeric expressions appearing planning instance
time state holds. achieved extending notion state.
Definition 2 Logical States States Given finite collection atoms planning instance I, AtmsI , logical state subset AtmsI . planning instance
dimension dim, state tuple (R, P(AtmsI ), Rdim
) R = R {}
denotes undefined value. first value time state, second
logical state third value vector dim values dim primitive numeric
expressions planning instance.
initial state planning instance (0, Initlogical , x) x vector values
R corresponding initial assignments given Initnumeric (treating unspecified
values ).
Undefined values included numeric ranges domains
terms start undefined nevertheless initialised exploited actions.
interpret actions state transition functions necessary achieve two steps.
Firstly, since (in pddl2.1) plans ever constructed fully instantiated action
schemas, process instantiation affects constructs action schema must
defined and, secondly, machinery links primitive numeric expressions elements
vector real values state allows interpretation numeric updating
behaviours action effects must defined. Since mechanisms support second
steps also affect process first, treatment numeric effects described
first.
Definition 3 Assignment Proposition syntactic form numeric effect consists
assignment operator (assign, increase, decrease, scale-up scale-down), one
primitive numeric expression, referred lvalue, numeric expression (which
arithmetic expression whose terms numbers primitive numeric expressions),
referred rvalue.
87

fiFox & Long

assignment proposition corresponding numeric effect formed replacing
assignment operator equivalent arithmetic operation (that (increase p q)
becomes (= p (+ p q)) on) annotating lvalue prime.
numeric effect assignment operator either increase decrease
called additive assignment effect, one operator either scale-up
scale-down called scaling assignment effect others called simple assignment
effects.
numeric effect defines function numeric values state action
applied determining value primitive numeric expression resulting state.
convenience uniform treatment numeric expressions appearing pre-
post-conditions, transform functions propositions assert equality
post-condition value expression intended define it. is, rather
writing effect (increase p q) function f (p) = p + q, write proposition
(= p0 (+ p q)). priming distinguishes postcondition value primitive numeric
expression precondition value (a convention commonly adopted describing state
transition effects numeric values). binding primitive numeric expressions
values states defined following definition.
Definition 4 Normalisation Let planning instance dimension dimI let
indexI : P N EsI {1, . . . , dim}
(instance-dependent) correspondence primitive numeric expressions

.
integer indices elements vector dimI real values, Rdim

normalised form ground proposition, p, defined result substituting primitive numeric expression f p, literal XindexI (f ) . normalised
form p referred N (p). Numeric effects normalised first converting
assignment propositions. Primed primitive numeric expressions replaced
corresponding primed literals. X used represent vector hX1 . . . Xn i.
Definition 4, replacement primitive numeric expressions indexed literals
allows convenient consistent substitution vector actual parameters
vector literals X appearing state.
machinery supporting treatment numeric expressions complete,
possible consider process instantiating action schemas. process managed
two steps. first step remove constructs treat syntactic sugar
definition domain. conditional effects quantified formulae. handle
direct syntactic transformations action schema set action
schemas considered equivalent. transformation similar described
Gazen Knoblock (1997). Although would possible give semantic interpretation
application conditional effects directly, transformation allows us significantly
simplify question actions performed concurrently.
Definition 5 Flattening Actions Given planning instance, I, containing action
schema AsI , set action schemas f latten(A), defined set S, initially
containing constructed follows:
88

fipddl2.1: Expressing Temporal Planning Domains

contains action schema, X, conditional effect, (when P Q), create
two new schemas copies X, without conditional effect, conjoin
condition P precondition one copy Q effects copy,
conjoin (not P) precondition copy. Add modified copies S.
contains action schema, X, formula containing quantifier, replace
X version quantified formula ( Q ( var1 . . . vark ) P) X
replaced conjunction (if quantifier, Q, forall) disjunction (if Q
exists) propositions formed substituting objects variable
var1 . . . vark P possible ways.
steps repeated neither step applicable.
flattened, actions grounded usual substitution objects parameters:
Definition 6 Ground Action Given planning instance, I, containing action schema
AsI , set ground actions A, GAA , defined set structures,
a, formed substituting objects schema variables schema, X,
f latten(A) components are:
Name name action schema, X, together values substituted
parameters X forming a.
Prea , precondition a, propositional precondition a. set ground
atoms appear Prea referred GPrea .
Adda , positive postcondition a, set ground atoms asserted
positive literals effect a.
Dela , negative postcondition a,is set ground atoms asserted
negative literals effect a.
NPa , numeric postcondition a, set assignment propositions corresponding numeric effects a.
following sets primitive numeric expressions defined ground action,
GAA :
La = {f |f appears lvalue a}
Ra = {f |f primitive numeric expression rvalue appears P rea }
La = {f |f appears lvalue additive assignment effect a}
comment appropriate last definition: action precondition might
considered two parts logical part numeric expression-dependent part.
Unfortunately, interdependent. example:
(or (clear ?x) (>= (room-in ?y) (space-for ?z)))
89

fiFox & Long

might precondition action. order handle conditions, need check
whether satisfied given current logical state, also current
values domain numeric expressions. inclusion numeric component
state makes necessary ensure correct substitution numeric values
expressions used action precondition. achieved using normalisation process
Definition 4 Definition 9. contrast, postcondition action cannot contain
interlocked numeric logical effects, possible separate effects
distinct numeric logical components.
Definition 7 Valid Ground Action Let ground action. valid primitive
numeric expression appears lvalue one simple assignment effect,
one different type assignment effect.
Definition 7 ensures action attempt inconsistent updates numeric
value. Unlike logical effects action cannot conflict, possible write
syntactic definition action effects inconsistent, example
assigning two different values primitive numeric expression.
Definition 8 Updating Function Let valid ground action. updating function
composition set functions:
dim
{NPFp : Rdim
R | p N P }

NPFp (x) = x0 primitive numeric expression x0i appear
lvalue N (p), x0i = xi N (p)[X0 := x0 , X := x] satisfied.
notation N (p)[X0 := x0 , X := x] read result normalising p
substituting vector actual values x0 parameters X0 actual values x
formal parameters X.
Definition 8 defines function describing update effects action. function
ensures reals vector describing numeric state remain unchanged
affected action (this numeric-state equivalent persistence
achieved propositions strips assumption). values vector,
normalisation process used substitute correctly indexed vector elements
primitive numeric expressions appearing lvalues (which primed vector elements
corresponding values post-action state) rvalues (the unprimed values appearing
pre-action state). tests must satisfied order ensure correct behaviour
functions composition simply confirm arithmetic rvalues
correctly applied arrive lvalues. requirement action valid ensures
composition functions Definition 8 well-defined, since functions
set commute, composition carried order.
various sets primitive numeric expressions defined Definition 6 allow us
conveniently express conditions two concurrent actions might interfere
one another. particular, concerned allow concurrent assignment
primitive numeric expression, concurrent assignment inspection. allow
concurrent increase decrease primitive numeric expression. allow
90

fipddl2.1: Expressing Temporal Planning Domains

apply collections concurrent updating functions primitive numeric expressions. allowed provided functions commute. Additive assignments
commute, updating operations cannot guaranteed so, except
affect primitive numeric expressions rely primitive numeric expressions
affected concurrent assignment propositions. would possible make
similar exception scaling effects, additive assignment effects particularly
important role durative actions shared scaling effects, simplicity
allow concurrent updates effects. use three sets primitive
numeric expressions determine whether safe situation not. Within single
action possible rvalues lvalues intersect. is, action update
primitive numeric expressions using current values primitive numeric expressions
also updated action. rvalues values take state
prior execution lvalues supply new values state follows.
Definition 9 Satisfaction Propositions Given logical state, s, ground propositional formula pddl2.1, p, defines predicate Rdim
, Num(s, p), follows:
Num(s, p)(x)

iff

|= N (p)[X := x]

|= q means q true interpretation atom, a,
numeric comparison, assigned true iff s, numeric comparison interpreted
using standard equality ordering reals logical connectives given usual
interpretations. p satisfied state (t, s, X) Num(s, p)(X).
Comparisons involving , including direct equality two values undefined, enclosing propositions also undefined satisfied state.
Definition 10 Applicability Action Let ground action. applicable
state P rea satisfied s.
7.1 Semantics Simple Plan
simple plan, pddl2.1, sequence timed actions, timed action
following syntactic form:
: (action p1 . . . pn )
notation positive rational number floating point syntax expression
(action p1 . . . pn ) name actual parameters action executed
point time. complex plans simple durative actions, without numericvalued effects preconditions, co-occur semantics plans discussed
Section 8. special separators required separate timed actions sequence
actions required presented time-sorted order. possible
multiple actions given time stamp, indicating executed
concurrently. emphasised earliest point activity occurs within
plan must strictly time 0. constraint follows decision make
initial state state existing time 0, together decision, semantics,
actions effects interval closed left, starting time
action applied, preconditions tested interval open
right precedes action.
91

fiFox & Long

order retain compatibility output current planners following concession made: plan presented sequence actions time points,
inferred first action applied time 1 succeeding actions apply
sequence integral time points one unit apart.
simple plan slight generalisation familiar strips-style classical plan,
since actions labelled time executed.
Definition 11 Simple Plan simple plan, SP , planning instance, I, consists
finite collection timed simple actions pairs (t, a), rational-valued
time action name.
happening sequence, {ti }i=0...k SP ordered sequence times set
times appearing timed simple actions SP . ti must greater 0.
possible sequence empty (an empty plan).
happening time t, Et , happening sequence SP , set
(simple) action names appear timed simple actions associated time SP .
plan thus consists sequence happenings, set action names applied
concurrently specific time, sequence ordered time. times
happenings occur forms happening sequence. noted action names
ambiguous action schemas contain conditional effects consequence flattening
split actions multiple actions identical names, differentiated
preconditions. However, one set actions identical names
applicable given logical state, since precondition action set
necessarily inconsistent precondition action set, due
way conditional effects distributed pairs action schemas
induce.
order handle concurrent actions need define situations
effects actions consistent one another. issue first discussed
Section 5.1. mutual exclusion rule pddl2.1 extension idea action
mutex conditions GraphPlan (Blum & Furst, 1995). extension handles two extra
features: extended expressive power language (to include arbitrary propositional
connectives) introduction numeric expressions. make conservative
condition actions executed concurrently, ensures possibility
interaction. rules cases intuition might suppose concurrency
possible. example, actions:
(:action
:precondition (or p q)
:effect (r))
(:action b
:precondition (p)
:effect (and (not p) (s)))

could, one might suppose, executed simultaneously state p q hold.
following definition asserts, however, two actions mutex. reason
chosen constrained definition checking mutex actions must
92

fipddl2.1: Expressing Temporal Planning Domains

tractable handling case implied example would appear require checking
consequence interleaving preconditions effects possible orderings.
condition primitive numeric expressions already discussed determines
update effects executed concurrently affect values
tested preconditions (regardless whether results tests
matter satisfaction enclosing proposition). rule moving
targets: concurrent actions affect parts state relevant precondition
tests actions set, regardless whether effects might harmful
not. might considered odd preconditions one action cannot refer literals
add effects concurrent action. require preconditions
negative, case interaction add effects analogous interaction
positive preconditions delete effects. moving targets rule makes
cost determining whether set actions applied concurrently polynomial
size set actions pre- post-conditions.
Definition 12 Mutex Actions Two grounded actions, b non-interfering
GP rea (Addb Delb ) = GP reb (Adda Dela ) =
Adda Delb = Addb Dela =
La Rb = Ra Lb =
La Lb La Lb
two actions non-interfering mutex.
last clause definition asserts concurrent actions update
values additive assignment effects.
ready define conditions simple plan valid.
separate executability plan whether actually achieves intended goal.
say plan valid executable achieves final goal. Executability
defined terms sequence states plan induces sequentially executing
happenings defines.
Definition 13 Happening Execution Given state, (t, s, x) happening, H,
activity H set grounded actions
AH = {a|the name H, valid P rea satisfied (t, s, x)}
result executing happening, H, associated time tH , state (t, s, x)
undefined |AH | =
6 |H| pair actions AH mutex. Otherwise, state
0
0
(tH , , x )
[
[
s0 = (s \
Dela )
Adda
aAH



x0

aAH

result applying composition functions {NPFa | AH } x.

Since functions {NPFa | AH } must affect different primitive numeric expressions,
except represent additive assignment effects, functions commute
93

fiFox & Long

therefore order functions applied irrelevant. Therefore, value
x0 well-defined last definition. requirement activity happening
must number elements happening simply constraint
ensures action name happening leads valid action applicable
appropriate state. already seen conditional effects induce construction
families grounded actions, one family applicable
state. none applicable given name, must mean
precondition unsatisfied, regardless conditional effects. case, asserting
attempt apply action undefined interpretation.
Definition 14 Executability simple plan, SP , planning instance, I, executable
defines happening sequence, {ti }i=0...k , sequence states, {Si }i=0...k+1
S0 initial state planning instance = 0 . . . k, Si+1
result executing happening time ti SP .
state Sk+1 called final state produced SP state sequence {Si }i=0...k+1
called trace SP . Note executable plan produces unique trace.
Definition 15 Validity Simple Plan simple plan (for planning instance, I)
valid executable produces final state S, goal specification
satisfied S.

8. Semantics Durative Actions
Plans durative actions discrete effects given semantics terms
semantics simple plans. Handling durative actions continuous effects
complex discuss Section 9.
Durative actions appearing plan must given additional field indicating
duration. given syntax:
: (action p1 . . . pn ) [d]
rational valued duration, written floating point syntax.
Durative actions introduced framework defined far generalising
Definition 1 include durative action schemas. definition grounded action must
extended define form grounded durative actions. However, definition
given way associate durative action two simple (nondurative) actions, corresponding end points durative action. simple
actions can, together, simulate almost behaviour durative action.
aspects captured pair simple actions duration durative
action invariants must hold duration. two elements can,
however, simply handled minor extension semantics simple plans,
approach adopt. taking route avoid difficulties establishing
effects interactions durative actions handled semantics
concurrent activity within simple plan. see, one difficulty account
handling durative actions conditional effects contain conditions effects
associated different times conditions must hold entire duration
94

fipddl2.1: Expressing Temporal Planning Domains

action. Since cases complicate semantics postpone treatment
next section begin durative actions without conditional effects.
mapping durative actions non-durative actions important consequence mutex relation implied non-durative actions (advantageously)
weaker strong mutex relation used in, example, TGP (Smith & Weld, 1999).
Two durative actions applied concurrently provided end-points one action
interact either end-points (if simultaneous) invariants
action.
Definition 16 Grounded Durative Actions Durative actions grounded
way simple actions (see Definition 6), replacing formal parameters constants planning instance expanding quantified propositions. definition
durative actions requires condition conjunction temporally annotated propositions. temporally annotated proposition form (at start p), (at end p)
(over p), p unannotated proposition. Similarly, effects durative action (without continuous conditional effects) conjunction temporally
annotated simple effects.
duration field DA defines conjunction propositions separated
DA DC DA , duration conditions start end DA, terms
DCstart
end
arithmetic expressions ?duration. separation conducted obvious way,
DA end conditions DC DA .
placing start conditions DCstart
end
grounded durative action, DA, continuous effects conditional effects
defines two parameterised simple actions DAstart DAend , parameter
?duration value, single additional simple action DAinv , follows.
DAstart (DAend ) precondition equal conjunction set propositions, p, (at start p) ((at end p)) condition DA, together
DA (DC DA ), effect equal conjunction simple effects, e,
DCstart
end
(at start e) ((at end e)) effect DA (respectively).
DAinv , defined simple action precondition equal conjunction
propositions, p, (over p) condition DA. empty effect.
Every conjunct condition DA contributes precondition precisely one
DAstart , DAend DAinv . Every conjunct effect DA contributes effect
precisely one DAstart DAend . convenience, DAstart (DAend , DAinv ) used
refer entire (respective) simple action also name.
actions DAstart DAend parameterised ?duration parameter
must substituted correct duration value order arrive two simple
actions corresponding start end durative action.
Definition 17 Plans plan, P , durative actions, planning instance, I, consists
finite collection timed actions pairs, either form (t, a),
rational-valued time simple action name action schema name together
constants instantiating arguments schema, form (t, a[t0 ]),
rational-valued time, durative action name t0 non-negative rational-valued
duration.
95

fiFox & Long

Definition 18 Induced Simple Plan P plan happening sequence P
{ti }i=0...k , ordered sequence time points formed set times1
{t | (t, a) P (t, a[t0 ]) P (t t0 , a[t0 ]) P }
induced simple plan plan P , simplify(P ), set pairs defined follows:
(t, a) (t, a) P simple (non-durative) action name.
(t, astart [?duration := t0 ]) (t + t0 , aend [?duration := t0 ]) (these expressions
simple timed actions square brackets denote substitution t0 ?duration
case) pairs (t, a[t0 ]) P , durative action name.
((ti + ti+1 )/2, ainv ) pair (t, a[t0 ]) P ti < + t0 ,
ti ti+1 happening sequence P .
process transforming plan simple plan involves introducing actions
represent end points intervals durative actions plan
applicable. Duration constraints convert simple preconditions start end actions,
requiring substitution numeric value ?duration field complete conversion simple actions. complication process invariants cannot
associated end points, must checked throughout interval.
achieved adding simple plan collection special actions responsible checking invariants. actions added pair happenings original
plan lying start end point durative action. semantics
simple plans requires preconditions actions plan satisfied, even though
might effects, consequence putting monitoring actions
simple plan ensure original plan judged valid invariants remain
true, firstly, start durative action and, subsequently, happening
occurs throughout duration durative action. One possibility make
monitoring actions occur times updating actions, would require
values accessed time might updated, violating
moving targets rule. order avoid problem monitoring actions interleaved
updating actions inserting midway pairs successive happenings
interval durative action executed. happenings original plan need considered carrying insertion, since invariant-checking
actions cannot effect states checked.
Alternative treatments invariants possible, important advantage
approach taken semantics rests, finally, state-transition model
form familiar planning community. is, plans seen recipes
state-transition sequences, state-transition function current
state world next. However, durative actions complicate picture
rely commitment, durative action started, follow
completion. commitment involves sort communication across duration
plan. communication managed structures outside plan, examine
1. Care taken reading definition last disjunct allows time corresponding
end execution durative action included happening time.

96

fipddl2.1: Expressing Temporal Planning Domains

trace, artificial modification plan ensure states carry extra
information start end durative action. latter approach
disadvantage durative actions become complex artificial components
must added plan become intrusive. particularly apparent
treatment conditional effects require conditions tested start durative
action, across duration, effects triggered end, since cases
require sort memory state remember status tested conditions
start durative action end point. memory conditions allow
us avoid embedding entire execution history state substituting ad hoc
memory history propositions times required.
management conditional effects form, mapping durative actions
simple actions, discussed Section 8.1.
conclude definitions supporting validity plan durative
actions.
Definition 19 Executability Plan plan, P (for planning instance), executable induced simple plan P , simplify(P ) executable, producing trace
{Si = (ti , si , vi )}i=0...k .
Definition 20 Validity Plan plan, P (for planning instance), valid
executable goal specification satisfied final state produced induced
simple plan.
8.1 Durative Actions Conditional Effects
explain mapping described previous section extended deal
durative actions containing conditional effects.
First, observe temporally annotated conditions effects accumulated,
temporal annotation distributes logical conjunction. Therefore,
convert conditional effects conditions simple conjunctions
one start condition, one end condition one condition.
noted allow logical connectives conjunction combining temporally annotated propositions. Allowing connectives would create significant
complexity semantics create potentially paradoxical opportunities
communication future states earlier states. Similarly conditions, durative action
effects reduced conjunction one start effect one end
effect. Treatment conditional effects divides three cases. first case
straightforward: effect durative action form (when (at p) (at q)),
condition effect bear single temporal annotation, transformed simple conditional effect form (when p q) attached start end
simple action according whether start end. Since case straightforward
explicitly extend previous definitions cope it. second case one
condition condition effect start conditions effect end
effects.
Note consider conditional effects effects occur start,
conditions dependent state end duration action,
97

fiFox & Long

meaningless. reverse expected behaviour causality, cause
precedes effect. attempt validate plan constructing trace reversed
causality would huge problem, since could determine initial effects applying durative action seen conditions held subsequent interval
conclusion activity, but, equally, could see effects activity interval would without seeing initial effects applying durative action.
paradox created opportunity action change past.
handle second case need modify state start durative action remember whether start conditions satisfied communicate
end durative action simply looked (then) current state
determine whether conditional effect applied. apply transformation
conditional effects form (when (and (at start ps) (at end pe)) (at end q))
conditional effect added start simple action, (when ps (Mps )), conditional effect added end simple action, (when (and pe (Mps )) q), Mps
special new proposition, unique particular conditional effect particular application durative action transformed. ensuring proposition unique
way, possibility action plan interfering it,
represents isolated memory fact ps held state durative
action started. conditional effect end conditions, transformation applied, simply ignoring pe previous discussion. Figure 15 depicts
transformation single durative action, A, conditional effect, collection
level 2 actions, complete appropriate memory proposition (in case called
P ).
importance memory introduced transformation explained Figures 16 17. Figure 16 shows ambiguity results remembering
state, trajectory plan, reached. figure illustrates one
state (P, Q, R) point durative action (as described Figure 15) ends,
impossible determine state alone whether R added not.
possible reached state (P, Q, R) least two different paths,
least one path seen started state P held least one path
seen started state P hold (using action, achieve-P , P
effect). state (P, Q, R) contain information disambiguate
path used reach it, hence cannot determine correct value R
ends.
third, final, case durative action conditional effects form:
(when (and (at start ps) (over pi) (at end pe)) (at end q)).

Again, effect start end conditions following transformation
applied simply ignoring ps pe appropriate. case need construct transformation remembers whether ps held state durative
action first applied, also whether pi holds throughout interval start
end durative action. Unlike invariants durative actions, conditions
required hold plan valid, determine effects occur
end durative action. idea use intervening monitoring actions, rather
invariants definition 18. achieved adding effect start
98

fipddl2.1: Expressing Temporal Planning Domains

Initial Durative Action
(:durative-action
:parameters ()
:duration (= ?duration 2)
:condition ()
:effect (when (and (at start P) (at end Q))
(at end R)))

Transformation simple actions
(:action A-start
:parameters ()
:precondition ()
:effect (when P P*))

(:action A-end
:parameters ()
:precondition ()
:effect (when (and P* Q) R))

Expansion conditional effects
(:action A-start
:parameters ()
:precondition (P)
:effect (P*))

(:action A-start
:parameters ()
:precondition (not P)
:effect ())

(:action A-end
:parameters ()
:precondition (and P* Q)
:effect (R))

(:action A-end
:parameters ()
:precondition (or (not P*) (not Q))
:effect ())

Transformation Plan Simple Plan
Plan

Plan

1:A[2]

1:A-start
3:A-end

Figure 15: Conversion durative action non-durative actions grounded
forms.

99

fiFox & Long

P,Q,~R

1:A-start
3:A-end
P,Q,~R

P,Q
R?

1:A-start
~P,Q

2:achieve-P

~P,Q
~R

~R

Figure 16: Flawed state space resulting failure record path traversed conditional effects span interval durative action. arc labelled achieve-P
indicates possible application action achieves proposition
P.
1:A-start
P,Q
~R,~P*

P*,P
Q,~R

3:A-end

2:achieve P
~P,Q
~R,~P*

1:A-start

~P,Q
~R,~P*

P,Q
R,P*
3:A-end
P,Q,
~R,~P*

P,Q
~R,~P*

Figure 17: Correct state space showing use memory proposition P*. arc labelled
achieve P indicates possible application action achieves
proposition P.

action: (Mpi ). Then, monitoring (simple) actions required precondition, single conditional effect: (when (and (Mpi ) (not pi)) (not (Mpi ))).
again, Mpi special new proposition unique conditional effect application
instance durative action transformed. monitoring actions added
intermediate points used monitoring actions Definition 18.
transformation used second case required start condition,
ps, (when ps (Mps )) added conditional effect start simple action. Finally,
add conditional effect end (simple) action: (when (and (Mps ) (Mpi ) pe) q).
effect machinery ensure proposition pi becomes false time
start end durative action Mpi deleted, otherwise
end durative action Mps hold precisely ps held start action
Mpi hold precisely pi held entire duration durative action.
Therefore, conditional effect end action achieves intuitively correct behaviour
asserting conditional effect precisely start condition held start
durative action, end condition holds end durative action
condition held throughout duration action.
addition new memory-checking actions means longer true
claim added actions cannot change state. However, memory propositions
unique task communication single action instance, effects
memory-checking actions might implications invariants.
100

fipddl2.1: Expressing Temporal Planning Domains

9. Semantics Continuous Durative Actions
introduction continuous durative actions complicates semantics. longer
possible handle invariants insertion simple actions happenings
plan test continued satisfaction. fact, continuous effects can, principle, cause
invariant satisfied parts interval others. Ignoring
invariants moment, updates numeric values caused continuous effects
applied discrete updates time points within interval apply.
updates behave slightly differently discrete updates seen durative actions
discrete effects, since possible continuous update affect variable
concurrently affected discrete update, examined precondition, without creating
inconsistency. example, water heating action Figure 14 applied
concurrent addition egg pan precondition temperature
water 90 95 degrees value temperature examined
moment application action adding egg. temperature
change actually happening interval start heating
point egg added, rather discrete update point egg
added. temperature actually changed instant addition egg.
section summarise semantics continuous actions. semantics
discrete durative actions defined terms familiar state-transition semantics,
continuous semantics introduces different formulation.
Definition 21 Continuous Durative Action continuous effect effect expression includes symbol #t. continuous durative action durative action
least one continuous effect.
Definition 22 Continuous Update Function Let C set ground continuous effects
planning instance, I, St = (t, S, X) state. continuous update function
defined C state St function fC : R Rn , n dimI , that:
dfC
=g
dt

fC (0) = X
g update function generated action with:
N Pa = { (<op> P Q) | (<op> P (* #t Q)) C}
Definition 22 shows continuous effects several continuous durative actions
combined create single system simultaneous differential equations whose solution,
given appropriate starting point, defines evolution continuously varying values.
Definition 23 Induced Continuous Plan Let planning instance includes
continuous durative actions P plan I. induced continuous plan P
triple, (S, Invs, Cts), simplif y(P ), Invs set invariant constraints:
Invs = {(Q, t, + d) | (t, a[d]) P (over Q) invariant A}
101

fiFox & Long

Let ti ti+1 two consecutive times happening sequence simplif y(P ).
set active continuous effects (ti , ti+1 ) is:
{Q | (t, a[d]) P, (ti , ti+1 ) [t, + d] Q continuous effect a}
Cts set systems continuous effects:
Cts = {(C, ti , ti+1 ) | C set active continuous effects (ti , ti+1 )}
components continuous plan separate invariant conditions continuous effects rest simple plan order allow correct application
continuous updates allow confirmation invariants hold face
continuous effects.
Definition 24 Trace Let planning instance includes continuous durative actions, P plan I, (SP, Inv, Cts) induced continuous plan P , {ti }i=0...k
happening sequence S0 initial state I. trace P
sequence states {Si }i=0...k+1 defined follows:
element (C, ti , ti+1 ) Cts Si+1 state resulting applying
happening ti simple plan SP state Si .
(C, ti , ti+1 ) Cts let Ti state formed substituting f (ti+1 ti )
numeric part state Si , f continuous update function defined C
state Si . Si+1 state resulting applying happening ti
simple plan SP state Ti . f undefined element Cts
trace.
Definition 24 defines trace similar fashion traces simple plans plans
durative actions. key difference need apply continuous updates.
handled solving systems simultaneous differential equations across interval
active applying result update numeric values across
interval. course, easier describe do, since solving arbitrary
simultaneous differential equations algorithmically generally possible. certain
constraints semantics implemented order confirm validity plan
automatically.
Definition 25 Invariant Safe Let planning instance includes continuous durative actions, P plan I, (S, Inv, Cts) induced continuous plan P
{Si }i=0...k+1 trace P . (C, ti , ti+1 ) Cts let fi continuous update
function defined C Si . P invariant safe if, fi defined
(Q, t, u) Inv [(ti , ti+1 )] = (t, u), x I, Num(s, Q)(fi (x))
logical state Si .
definition, symbols [(..)] used mean interval closed
open either end.
102

fipddl2.1: Expressing Temporal Planning Domains

semantic point view, invariants must checked every point interval apply. interval contains finitely many discrete changes
obligation met considering finite number points
change occurs (a fact exploited discrete durative action plan semantics Definition 18). continuous change obligation much harder meet.
practice, invariants checked examining possible roots function describing continuous change, finding roots difficult general. Again,
suitable constraints forms differential equations expressed domain make
validation problem tractable.
last two definitions simply assemble components arrive analogous definitions executability validity simple plans plans durative actions.
Definition 26 Executability Plan plan P containing continuous durative actions,
planning instance I, induced continuous plan (S, Invs, Cts). P executable
trace P defined, {Si }i=0...k+1 , invariant safe.
Definition 27 Plan Validity plan P containing durative actions, planning instance
valid executable, trace {Si }i=0...k+1 Sk+1 satisfies goal I.

10. Plan Validation
Plan validation important part use pddl, particularly role
competition. approximately 5000 plans consider competition 2002,
seen automation essential. validation problem tractable propositional
versions pddl plans finite validated simply simulation
execution. issue complicated pddl2.1 potential concurrent
activity, possibly face numeric change, makes necessary ensure invariant
properties protected concurrent activity non-interfering.
durative actions used question whether plan
considered valid contain end points actions initiated
plan. action exploited plan effect end duration
clear end point present plan, action selected
start effect less clear. match-striking action performed start effect,
order burned match end brief interval. could argued
that, obtained desired start effect end action irrelevant
plan terminate (as soon goals achieved) without ensuring initiated
actions end safely. Indeed, plan search process Sapa (Do & Kambhampati, 2001)
terminate whilst still queued events awaiting advancement time. However,
possible conceive situations end point action, incorporated
start effect, introduces inconsistencies plan inclusion would
make plan invalid. cases seems plan validity could compromised
ignoring end effects.
order avoid resolve complexities, taken view
pddl2.1 plan valid action start end points explicit within plan.
identified case proceed confirm happenings within
plan mutex-free.
103

fiFox & Long

Plan validation decidable domains including discretized and, certain constraints, continuous durative actions activity encapsulated durative
actions explicitly identified plan. makes trace induced plan finite
hence checkable. therefore observe validation problem pddl2.1 decidable
even actions contain duration inequalities. work determining
duration inequalities solved already completed finished
plan validation plan proceed simulation execution, case
pddl plans. problem tractable domains without continuous effects,
introduction continuous effects can, principle, allow expression domains
complex functions describing numeric change (Howey & Long, 2002). assumption
continuous effects restricted description terms simple linear quadratic
functions, without interactions concurrent continuous effects, plan validity
tractable. cost practice increased however, since may necessary solve
polynomials order check invariants. Validation plans containing complex
expressions change explored.
Although plan validity checking tractable, subtlety arises
need represent plans syntactically difficulties involved expressing numbers arbitrary precision. principle, values required describe
valid plans algebraic (assuming constrain continuous effects indicated above),
therefore finitely representable. practice, expecting planners handle numbers
algebraic expressions seems unnecessarily complicated far reasonable assume numbers represented finite precision floating point values. Indeed,
syntax adopted expression plans restricts planners expressing times
finite precision floating point values. constraint, limitations
precision floating point computations implementations plan validation systems,
necessary take pragmatic view validation process accept
numeric conditions evaluated certain tolerance. Otherwise, occur
way report plan necessary degree accuracy
valid interpretation semantics defined Section 8. cases, plan
specifies time points to, example, four significant digits, reasonable abstraction
execution time activity needed control flow system. plan specify
time points absolutely precisely, abstraction forced upon planner fact
working models world physical world itself. problem, then,
one relationship theoretical semantics pragmatic concerns
automated validation.
Figure 18 relationship depicted terms kinds plans automatically validated. left side picture describes theoretical semantics,
arrow indicating link plans interpretation theoretical
semantics. example, possible construct
domain problem plan

requires action happen time 2 meaningful semantic object,
plan specifies theaction happen time 1.41 meaningful semantic object
1.41 equal 2. two plans distinct, one correct (under
assumed constraints). right side picture depicts pragmatic validation
syntactic plan objects. two control plans, though distinct semantics, map
syntactic object assume validation subject tolerance 0.01.
104

fipddl2.1: Expressing Temporal Planning Domains

Semantic interpretation plans

Validation plans

mapping semantics pragmatic
realisation automated validation process

Semantic plan objects




fifffi








ff









mapping semantic plans syntactic
counterparts.



Syntactic plan objects

specific pair mappings

Figure 18: pragmatic mapping semantics plans validation
automated computational processes. shaded area contains plans cannot
interpreted within theoretical semantics. seen plan
collection indistinguishable meaningful plan mapped
syntactic side picture.

plans map syntactic object 1.41 approximates value 2.
syntactic plan validated using pragmatic validation processes necessary
automatic validation describable syntactic plans, check validity subject
tolerance 0.01. pragmatic constraints representations plans,
expectations representations numeric values planners validators
consequences reasonable assumptions given models check
validity are, case, abstractions, non-zero tolerance, world. practice,
problem accept plans specified tolerance levels pathological cases,
arithmetic precision computer representations floats immediate negative
impact one tries take stronger line plans accepted
strictly valid according formally precise evaluation expressions.
Finally, interesting philosophical issue arises discussed Henzinger co-authors (1997, 2000). is, fact, possible achieve exact precision
measurement time continuous numeric quantities. Henzinger et al.
considered problem development robust automata. Robust automata
accept trace exists tube traces within distance > 0 original
trace, acceptable original acceptance criteria. called fuzzy
tubes indicating time fuzzily, rather precisely, detectable. idea offers path
formal semantics closer defining plans robust imprecision
executives ability measure time. Unfortunately, checking fuzzy tubes intractable.
currently compromise adopting value, used tolerance checking
numeric values fulfil numeric constraints plan execution, also represent minimum separation conflicting end points within plans. consistent idea
planner assumes executive willing abstract indicated tolerance
level checking preconditions actions unreasonable suppose
plan make use finer grained measurements determining actions
105

fiFox & Long

applied. moment value set validation process, communicated informally planner-engineers, might better allow domain designer
define appropriate use particular domain. remain several issues
concerning correct management buffers validation (particularly usual
problem concerning transitivity fuzzy closeness) important issues
temporal reasoning whole restricted planning context.
yet solutions problems.

11. Related Work: Representing Reasoning Time
Representation of, reasoning with, statements time temporal extent
propositions long subject research AI including planning research (Allen,
1984; McDermott, 1982; Sandewall, 1994; Kowalski & Sergot, 1986; Laborie & Ghallab,
1995; Muscettola, 1994; Bacchus & Kabanza, 2000). Important issues raised
extension pddl handle temporal features have, course, already examined
researchers, example Shanahans work (1990) continuous change within
event calculus, Shohams work (1985) Reichgelts work (1989) temporal reasoning work non-reified temporal systems (Bacchus, Tenenberg, & Koomen, 1991).
Vila (1994) provides excellent survey work temporal reasoning AI. section
briefly review central issues addressed, treatment
literature, set pddl2.1 context research temporal logics.
Several researchers temporal logics considered problems reasoning
concurrency, continuous change temporal extent. works focussed
problem reasoning change world described using arbitrary logical
formulae, concerned making meta-level statements (such
effect cannot precede cause). need handle complex logical formulae makes
frame problem difficult resolve, approach based circumscription (McCarthy,
1980) default reasoning (Reiter, 1980) typical. strips assumption provides
simple solution frame problem states described using atomic formulae.
classical planning assumption states described atomically
general view modelling change. Although simplifying, assumption
surprisingly expressive. bench mark domains introduced third International
Planning Competition suggest atomic modelling powerful enough capture
complex domains closely approximate real problems. temporal reasoning issues
confront simplified consequence made simplifying assumption
states updated. remain concerned major issues temporal
reasoning: concurrency, continuous change temporal extent.
development pddl2.1 made basic decision consider end points
durative actions instantaneous state transitions. allows us concentrate
truth propositions points instead intervals. decision consider actions
way similar made many temporal reasoning researchers (Shanahan, 1990;
McCarthy & Hayes, 1969; McDermott, 1982). context pddl2.1 approach
advantage smoothly integrating classical planning view actions state
transitions. Nevertheless, Allen shown temporal ontology based intervals
basis planning (Allen, 1984, 1991) several planning systems
106

fipddl2.1: Expressing Temporal Planning Domains

strongly influenced intervals approach (Muscettola, 1994; Rabideau, Knight, Chien,
Fukunaga, & Govindjee, 1999). Allen later moved away initial position instants
required, introducing notion moments (Hayes & Allen, 1987),
concept attempts reconcile stance nothing instantaneous (so
intervals) observation changes values discrete-valued variables,
propositional variables, apparently cannot avoid changing instants. view
consistent approach take modelling continuous durative actions,
view change consisting discrete continuous aspects (Henzinger,
1996).
remainder section compare pddl extensions propose
previous work temporal reasoning considering three central issues identified above.
objective claim extensions improve previous work, instead
demonstrate implementation solutions three problems within pddl
framework makes exploitation directly accessible planning way
embedded within logic accompanying proof theory.
11.1 Continuous change
Several temporal reasoning frameworks began consideration discrete change and,
later, extended handle continuous change. example, Shanahan (1990) extended
event calculus Kowalski Sergot (1986) enable modelling continuous
change. process extension mirrors situation faced extending pddl,
system modelling discrete change already existed. is, therefore, interesting compare
use pddl2.1 use systems extended event calculus.
sink-filling example Shanahan (1990) discusses issues termination events
(self-termination termination events), identification level water
sink filling process effect rate change level water
sink filled two sources simultaneously. behaviour filling
process effects state sink time modelled axioms would
allow inference engine predict state sink points execution
process.
pddl2.1 allows representation complex interactions arise sink
filled multiple independently controlled water sources means concurrent durative
actions continuous effects encapsulate initiation filling process,
single water source, change level water sink termination
process water source turned off. model robust, since easily
accommodates multiple water sources, simply modifying rate flow appropriately
commutative updates. Since actions additive effects model provides
rate water enters tank source, possible compute level
water sink point filling interval concurrent action might
consult level. contrast Shanahans extension event calculus, approach
require filling process (at least point view logical
axiomatisation) terminated restarted new rate water source opened
closed, since process simply remains active throughout. change rate filling
107

fiFox & Long

reflected piecewise-linear profile depth water sink,
Shanahans model.
possible model multiple water sources situation filling process
completely encapsulated within discretized durative action. discretized action
true level water accessible filling process end start.
Step-function behaviour coarsely approximates true behaviour, consequence
complex interactions cannot properly modelled.
One important consequences continuous behaviour triggering events.
Shanahans extensions achieved axiomatisation causal relationships
events distinguished syntactically actions, fact
happening axiomatically consequence certain conditions. pddl2.1 events
(such flooding sink filling continues capacity reached)
modelled using combination conditional effects duration inequalities.
However, events modelled way, since always possible predict
spontaneous events occur. pddl2.1 could extended allow expression
causal axioms, alternative approach modify language enable
representation events within action-oriented tradition. achieved
breaking continuous durative actions instantaneous start end points
processes encapsulate. would enable execution process initiated
start action ended instantaneous state transition either action
control planner event. simple extension language needed
distinguish actions events prevent planner deliberately selecting
event. refer approach start-process-stop model, extended
pddl2.1 support (Fox & Long, 2002). resulting language, pddl+, difficult
plan pddl2.1, still open questions, concerning complexity
plan validation problem language, remain topics future work.
11.2 Concurrency
opportunity concurrent activities complicates several aspects temporal reasoning.
Firstly, necessary account actions concurrent secondly
necessary describe concurrent activities interact effects world.
formalisms first points achieved relying underlying logic
deliver inconsistency attempt made apply two incompatible actions simultaneously. example, axioms event calculus yield simultaneous
truth falsity fluent incompatible actions applied simultaneously consequently yield inconsistency. Unfortunately, recognising inconsistency is, general,
undecidable, sufficiently expressive language. pddl2.1 adopt solution
exploits restricted form action-centred formalism, defining circumstances
two actions could lead inconsistency rejecting simultaneous application
actions. favour conservative restriction compatibility actions (the
moving targets rule), order support efficient determination incompatibility, rather
permissive elusive ruling. alternative approach, adopted Bacchus
TLplan (2001), example, allow multiple actions occur instant,
nevertheless executed sequence. find solution counter-intuitive and,
108

fipddl2.1: Expressing Temporal Planning Domains

importantly, consider would impossible use plan sort instruction
executive executive could equipped execute actions simultaneously yet
specified order. view order execution matters executive
must ensure actions sequenced within limitations
capability measure time react passing.
Shanahan (1999) discusses Gelfonds (1991) example soup bowl
problem concerns raising soup bowl without spilling soup. Two actions, lift left
lift right, applied bowl. either applied soup spill, but,
argued, applied simultaneously bowl raised table
soup spills. Shanahan considers example within event calculus, uses
explicit assertion interaction lift left lift right actions ensure
spillage effect cancelled pair executed together. assumption
two actions executed precisely moment reasoner
rely successful simultaneity order exploit effect.
pddl2.1 take view precise simultaneity outside control
physical executive. plan interpreted instruction executive system
hold executive system capable measuring time controlling activity
arbitrarily fine degrees accuracy. particular, possible executive
ensure two actions must independently initiated executed simultaneously.
plan rely precision measurement then, claim, could
executed reliable expectation success not, therefore, considered
valid plan.
pddl2.1 supports modelling soup bowl situation following way. Two
durative actions, lift left lift right, independently initiate tilting intervals which,
complete, result spillage soup effects counteracted.
Provided two lift actions start within appropriate tolerance one another
tilting corrected spillage avoided without need model cancellation
effects. argue executive execute two actions within fine
non-zero tolerance one another, therefore successfully lift bowl. event
calculus model presented Shanahan insists precise synchronization two actions,
incorrectly allowing inferred soup spilled even time
elapses two lifts actually small enough allow correction tilting
bowl. Worse, Shanahans axioms would allow lack precise synchronization
exploited achieve spillage, using amount time smaller correctly describing
physical situation modelled.
one considers unnecessary model precise interaction two lifts,
one alternative pddl2.1 abstract interaction see soup-bowl
lifting action single discretized action achieves successful raising bowl.
11.3 Temporal extent
common concern temporal reasoning frameworks, discussed detail Vila
others (Vila, 1994; van Bentham, 1983), divided instant problem. problem
apparent considering happens moment transition from, say,
truth falsity propositional variable. question must addressed whether
109

fiFox & Long

proposition true, false, undefined inconsistently true false instant
transition. Clearly last possibilities undesirable. solution adopt
combination pragmatic philosophically principled. pragmatic element
choose model actions instantaneous transitions effects beginning
instant application. Thus, actions mark end-points intervals persistence
state closed left open right. ensures intervals nest
together without inconsistency truth values propositions always defined.
half-open-half-closed solution adopted elsewhere. example, Shanahan (1999)
observes similar approach used event calculus, although intervals
closed right. Although two choices effectively equivalent, slightly
prefer closed-on-the-left choice since allows validation plan conclude
state point execution final action, making determination
temporal span plan unambiguous.
philosophical point view truth value proposition instant
application action cannot exploited action, virtue
moving targets rule position, outlined above, valid plan cannot depend
precise synchronisation actions. forces actions require proposition
precondition sit open end half-open interval proposition holds.
11.4 Planning Time
classical planning models, time treated relative. is, temporal structuring plan, reasoning plan, ordering actions.
clearly emphasised issues dominated planning research late 1980s
early 1990s, classical planning mainly characterised exploration partial
plan spaces, planners tweak (Chapman, 1987), snlp (McAllester & Rosenblitt,
1991) ucpop (Penberthy & Weld, 1992). Partial plans include collection actions
representing activity thus far determined part possible plan set
temporal constraints actions. temporal constraints used partial plan
form < B B time points corresponding application
actions.
Classical linear planners (Fikes & Nilsson, 1971; Russell & Norvig, 1995) rely
simple fact total ordering points actions applied trivially
embedded time line. Again, duration actions considered. role
time planning becomes far significant metric time introduced. metric
time possible associate specific durations actions, set deadlines windows
opportunity. problems associated relative time still resolved
metric time framework, new problems introduced. particular, durations become
explicit, necessary decide durations attach to: actions states. Further,
explicit temporal extents make important confront issue concurrency
order best exploit measured temporal resources available planner.
contrast simple ordering constraints required relative time, metric time
requires powerful constraint management. metric time constraint handlers
built around foundations laid Dechter, Meiri Pearl (1991). example, IxTeT
uses extensions temporal constraint networks (Laborie & Ghallab, 1995). language
110

fipddl2.1: Expressing Temporal Planning Domains

IxTeT uses represent planning domains similar pddl2.1 described
paper, expressive allows access time points within interval
durative action. added expressive power obtained cost increased semantic
complexity and, consequently, increased difficulty validation plans. However,
many similarities modelling discretised durative actions pddl2.1
IxTeT, similar modelling conventions also found languages Sapa (Do &
Kambhampati, 2001) Oplan (Drabble & Tate, 1994).
One earliest planners consider use metric time Deviser (Vere, 1983),
developed nonlin (Tate, 1977). Deviser, metric constraints times
actions could applied deadlines achievements goals
expressible planner could construct plans respecting metric temporal constraints
interactions actions. Cesta Oddi (1996) explored various developments temporal constraint network algorithms achieve efficient implementation
planning Galipienso Sanchis (2002) consider extensions manage disjunctive
temporal constraints efficiently, particularly valuable expressive element plan
construction observed above, since constraints preventing overlap intervals translate disjunctive constraints time points. hsts (Muscettola, 1994) also relies
temporal constraint manager.
systems use continuous real-valued time possible make use linear
constraint solvers handle temporal constraints. particular, constraints dictated
relative placement actions durations timeline approached
way (Long & Fox, 2003a). alternative timeline often used discretised line
based integers. advantage approach possible advance time
next value considering activity given time point. next modality
interpreted continuous time framework taking mean state following
next logical change, regardless time occurs (Bacchus & Kabanza, 1998).
planning problems events occur actions dictated
planner continuous change modelled, plans finite structures therefore
change occur finite number time points execution. makes
possible embed execution plan integer-valued discrete time line
without loss expressiveness.
Various researchers considered problem modelling continuous change. Pednault (1986) proposes explicit description functions govern continuous change
metric parameters, attached actions effect instantaneous change initiate
processes. However, approach easy use describing interacting continuous
processes. example, water filling tank constant rate additional
water source added increase rate filling action initiating second
process must combine effects two water sources. means second
action cannot described simply terms direct effect world increase
rate flow tank reference effects actions
already affected rate change parameter. Shanahan (1990) also uses
approach, consequence processes modelled stopping restarting
new trajectories interacting action applied.
Zeno (Penberthy & Weld, 1994), actions effects described terms
derivatives. approach makes easier describe interacting processes, complicates
111

fiFox & Long

management processes making necessary solve differential equations.
complication deterred authors taking approach: McDermott (2003)
takes approach process planner.
introduction continuous processes planning problem represents considerable complication, even model includes temporal features supports
concurrency. area active research community yet agreed
matters representation, let alone semantics. remain many open problems
planning community address, development languages planning algorithms also development plan verification tools embody widely
accepted semantics.

12. Conclusions
Recent developments AI planning research leading community closer
application planning technology realistic problems. necessitated
development representation language capable modelling domains temporal
metric features. approach taken towards development language
extend McDermotts pddl domain representation standard support temporal
metric models.
development pddl sequence towards greater expressive power important
planning community pddl provided common foundation great
deal recent research effort. problems involved modelling behaviour domains
discrete continuous behaviours well explored temporal logic
model checking communities widely adopted models within
planning community. work pddl2.1 provides way making relevant
developments communities accessible planning. Furthermore, pddl2.1 begins
bridge gap basic research applications-oriented planning providing
expressive power necessary capture real problems.
pddl2.1 expressive power represent class deterministic mixed discretecontinuous domains planning domains. language introduces form durative action
based three connected parts: initiation interval numeric change
might occur explicit termination means action produces state
corresponding end durative interval. form action allows modelling
discrete continuous behaviours discretized change represented
means step functions, whilst continuous change modelled using #t variable.
language provides solutions critical issues concurrency, continuous change
temporal extent. semantics language derived familiar state
transition semantics strips, extended interpret invariants holding intervals
continuous functions might also active. semantics allows us interpret
plans efficiently validate. describe criteria plan must satisfy
order practically verifiable.
paper focussed primarily discussion numeric discretised temporal features pddl2.1. However, modelling capability discretized durative actions
respects limited important planning community address
challenges presented continuous change. Indeed, even using continuous actions
112

fipddl2.1: Expressing Temporal Planning Domains

pddl2.1 possible model episodes change terminated spontaneous
events world rather deliberate choice planner. future goals
community include addressing domains require continuous actions
pddl2.1, confronting challenges planning within dynamic environments
intervals change terminated world well deliberate action
planner. constitute important step towards planning within dynamic
unpredictable environments.

Acknowledgements
would like thank members committee third International Planning
Competition. particular, discussions Drew McDermott, Fahiem Bacchus, David
Smith Hector Geffner turns infuriated, intrigued delighted us contributed
immeasurably strengths paper. Many others offered comments
insights allowed us develop work present here. would like thank
Jorg Hoffmann, Malte Helmert, Antonio Garrido, Stefan Edelkamp, Nicola Muscettola,
Mark Boddy, Keith Golden, Jeremy Frank, Ari Jonsson, Julie Porteous, Alex Coddington,
Stephen Cresswell, Luke Murray, Keith Halsey Richard Howey many helpful
discussions shared.

113

fiFox & Long

Appendix A. BNF Specification pddl2.1
appendix contains complete BNF specification pddl2.1 language.
strict superset pddl1.x. example, use local variables within action schemas
left specification. widely used part language
used competition domains. interpretation local variables
proposed McDermott subtle, since demands confirmation unique instantiation
exists variable. non-trivial confirm case plan
validation domains significant expressive power fact largely
ignored suggests poorly understood. changes discussed following
sections.
A.1 Domains
Domain structures remain essentially specified pddl1.x. main alterations
introduce slightly modified syntax numeric fluent expressions remove
syntax hierarchical expansions. latter necessarily abandoned, not,
best knowledge, used publicly available planning systems even
domains. original pddl specification, distinction drawn strict pddl
non-strict pddl, strict pddl must follow ordering fields specified below,
non-strict pddl restricted way. practice, relatively fields
intuitive accept arbitrary orders natural expect declarations
precede use symbols preconditions precede effects. However, declarations
constants, predicates function symbols naturally ordered, current
definition pddl ordering fields must follow specification below,
exception three fields legal order respect one another,
although group must follow types (if any) precede action specifications.
<domain>

::= (define (domain <name>)
[<require-def>]
[<types-def>]:typing
[<constants-def>]
[<predicates-def>]
[<functions-def>]:fluents
<structure-def> )
<require-def>
::= (:requirements <require-key>+ )
<require-key>
::= See Section A.5
<types-def>
::= (:types <typed list (name)>)
<constants-def>
::= (:constants <typed list (name)>)
<predicates-def>
::= (:predicates <atomic formula skeleton>+ )
<atomic formula skeleton>
::= (<predicate> <typed list (variable)>)
<predicate>
::= <name>
<variable>
::= ?<name>
<atomic function skeleton>
::= (<function-symbol> <typed list (variable)>)
<function-symbol>
::= <name>
<functions-def>
::=:fluents (:functions <function typed list
(atomic function skeleton)>)
<structure-def>
::= <action-def>
<structure-def>
::=:durativeactions <durative-action-def>

114

fipddl2.1: Expressing Temporal Planning Domains

slight modification made type syntax longer possible
nest either expressions (a possibility never exploited, complicates parsing).
Numbers longer considered implicit type extension numbers
handled functional expressions. ensures finitely many
ground action instances. desirable consequence action selection choice points need
never include choice arbitrary numeric ranges. use finite ranges integers
specifying actions useful (see Mystery FreeCell example) extension
standard syntax allow convenient representation cases could
useful. syntax function declarations allows functions declared types.
present syntax restricted number types, since semantics
functions, syntax offers scope possible extension. types given
function results assumed numbers.
<typed list (x)>
<typed list (x)>
<primitive-type>
<type>
<type>

::= x
::=:typing x+ - <type> <typed list(x)>
::= <name>
::= (either <primitive-type>+ )
::= <primitive-type>

<function typed list (x)> ::= x
<function typed list (x)> ::=:typing x+ - <function type>
<function typed list(x)>
<function type>
::= number

A.2 Actions
BNF action definition given below. Again, simplified removing
generally unused constructs (mainly hierarchical expansions). emphasised
removal intended permanent exclusion hierarchical expansion syntax
proved difficult element language agree exploit.
levels language stabilise hope return layer redevelop it.
<action-def>

::= (:action <action-symbol>
:parameters ( <typed list (variable)> )
<action-def body>)
<action-symbol>
::= <name>
<action-def body> ::= [:precondition <GD>]
[:effect <effect>]

Goal descriptions extended include fluent expressions.
<GD>
<GD>
<GD>
<GD>

::= ()
::= <atomic formula(term)>
::=:negativepreconditions <literal(term)>
::= (and <GD> )

115

fiFox & Long

<GD>
<GD>
<GD>
<GD>
<GD>
<GD>
<f-comp>
<literal(t)>
<literal(t)>
<atomic formula(t)>
<term>
<term>
<f-exp>
<f-exp>
<f-exp>
<f-exp>
<f-head>
<f-head>
<binary-op>
<binary-op>
<binary-op>
<binary-op>
<binary-comp>
<binary-comp>
<binary-comp>
<binary-comp>
<binary-comp>
<number>

::=:disjunctivepreconditions (or <GD> )
::=:disjunctivepreconditions (not <GD>)
::=:disjunctivepreconditions (imply <GD> <GD>)
::=:existentialpreconditions
(exists (<typed list(variable)> ) <GD> )
:universalpreconditions
::=
(forall (<typed list(variable)> ) <GD> )
:fluents
::=
<f-comp>
::= (<binary-comp> <f-exp> <f-exp>)
::= <atomic formula(t)>
::= (not <atomic formula(t)>)
::= (<predicate> )
::= <name>
::= <variable>
::= <number>
::= (<binary-op> <f-exp> <f-exp>)
::= (- <f-exp>)
::= <f-head>
::= (<function-symbol> <term> )
::= <function-symbol>
::= +
::=
::=
::= /
::= >
::= <
::= =
::= >=
::= <=
::= numeric literal
(integers floats form n.n).

Effects extended include functional expression updates. syntax proposed little different syntax proposed earlier version pddl.
syntax conditional effects proposed Fahiem Bacchus AIPS 2000 adopted,
nesting conditional effects supported. assignment operators
prefix forms. Simple assignment called assign (previously change) operators corresponding C update assignments, + =, =, = / = given names
increase, decrease, scale-up scale-down respectively. prefix form
adopted preference infix form order preserve consistency Lisp-like
syntax non-C names help C C++ programmers remember
operators used prefix form). prefer assign original change
introduction increase makes nature change ambiguous.
<effect>
<effect>
<effect>
<c-effect>
<c-effect>
<c-effect>
<p-effect>
<p-effect>
<p-effect>

::= ()
::= (and <c-effect> )
::= <c-effect>
::=:conditionaleffects (forall (<variable> ) <effect>)
::=:conditionaleffects (when <GD> <cond-effect>)
::= <p-effect>
::= (<assign-op> <f-head> <f-exp>)
::= (not <atomic formula(term)>)
::= <atomic formula(term)>

116

fipddl2.1: Expressing Temporal Planning Domains

<p-effect>
<cond-effect>
<cond-effect>
<assign-op>
<assign-op>
<assign-op>
<assign-op>
<assign-op>

::=:fluents (<assign-op> <f-head> <f-exp>)
::= (and <p-effect> )
::= <p-effect>
::= assign
::= scale-up
::= scale-down
::= increase
::= decrease

A.3 Durative Actions
Durative action syntax built relatively conservative extension existing action
syntax.
<durative-action-def> ::= (:durative-action <da-symbol>
:parameters ( <typed list (variable)> )
<da-def body>)
<da-symbol>
::= <name>
<da-def body>
::= :duration <duration-constraint>
:condition <da-GD>
:effect <da-effect>

conditions durative action executed complex
standard actions, specify conditions must hold point
execution. also specify conditions must hold throughout duration
durative action also termination. distinguish components introduce
simple temporal qualifier preconditions. use name precondition would
somewhat misleading given conditions described include constraints
must hold action begun. motivated adoption :condition
describe collection constraints must hold order successfully apply
durative action. logical form conditions durative actions restricted
conjunctions temporally annotated expressions, clearly scope future
extension allow complex formulae.
<da-GD>
<da-GD>
<da-GD>
<timed-GD>
<timed-GD>
<time-specifier>
<time-specifier>
<interval>

::=
::=
::=
::=
::=
::=
::=
::=

()
<timed-GD>
(and <timed-GD>+ )
(at <time-specifier> <GD>)
(over <interval> <GD>)
start
end


duration (?duration) durative action specified equal given
expression (which function numeric expressions), else constrained
inequalities. latter allows actions conclusion action
freely determined executive without necessarily side-effects.
example, walk two locations could made take long executive
117

fiFox & Long

considered convenient, provided least long time taken walk
locations fastest walking speed possible. Constraints specify
exact duration durative action might prove harder handle, introduced
label (:duration-inequalities) signal domain makes use them. duration
constraint supplied dictate limit temporal extent durative action.
duration implicit parameter durative action must supplied plan
uses durative actions. denote this, durative action denoted plan
t:(name arg1...argn)[d] (non-negative, rational valued) duration
floating point format (n.n). Duration constraints explicitly temporally annotated
indicate evaluated context start end point action,
else left unannotated, case default evaluated
context start action (as indicated Definition 16).
<duration-constraint>
<duration-constraint>
<duration-constraint>
<simple-duration-constraint>
<simple-duration-constraint>
<d-op>
<d-op>
<d-op>
<d-value>
<d-value>

::=

:durationinequalities

(and <simple-duration-constraint>+ )
()
<simple-duration-constraint>
(<d-op> ?duration <d-value>)
(at <time-specifier>
<simple-duration-constraint>)
::=:durationinequalities <=
::=:durationinequalities >=
::= =
::= <number>
::=:fluents <f-exp>
::=
::=
::=
::=

addition logical effects, occur start end durative action,
durative actions numeric effects refer literal ?duration. sophisticated durative actions also make use functional expressions describing effects
occur duration action. allows functional expressions updated
continuous function time, rather step functions.
<da-effect>
<da-effect>
<da-effect>
<da-effect>
<da-effect>
<da-effect>
<timed-effect>
<timed-effect>
<timed-effect>
<f-assign-da>
<f-exp-da>
<f-exp-da>
<f-exp-da>
<f-exp-da>

::= ()
::= (and <da-effect> )
::= <timed-effect>
::=:conditionaleffects (forall (<variable> ) <da-effect>)
::=:conditionaleffects (when <da-GD> <timed-effect>)
::=:fluents (<assign-op> <f-head> <f-exp-da>)
::= (at <time-specifier> <a-effect>)
::= (at <time-specifier> <f-assign-da>)
::=:continuouseffects (<assign-op-t> <f-head> <f-exp-t>)
::= (<assign-op> <f-head> <f-exp-da>)
::= (<binary-op> <f-exp-da> <f-exp-da>)
::= (- <f-exp-da>)
::=:durationinequalities ?duration
::= <f-exp>

Note ?duration term used define functional expression updating
effects duration constraints requirement set. cases
duration value available expression, whereas duration constraints provided
duration can, sometimes, freely selected within constrained boundaries.
118

fipddl2.1: Expressing Temporal Planning Domains

<assign-op-t>
<assign-op-t>
<f-exp-t>
<f-exp-t>
<f-exp-t>

::=
::=
::=
::=
::=

increase
decrease
(* <f-exp> #t)
(* #t <f-exp>)
#t

symbol #t used represent period time given durative action
active. therefore local clock value duration, independent similar
clocks duration. discussion members committee
use expression using #t: proposed expression declaring
rate change alone could used. decided grounds
assertion rate change suggests rate change determined one process
effect alone. fact, intended multiple active processes affect fluent
effects accumulated. Using expression directly defines amount
process contributes change fluent value time appear
assert (inconsistently) fluent multiple simultaneous rates change.
A.4 Problems
Planning problems specifications modified exclude several generally unused
constructs (named initial situations expansion information). removed
length specification odds intention supply physics, advice.
Furthermore, advice field offers over-emphasises coarse plan metric. Instead,
introduced optional metric field, used supply expression
optimized construction plan. field states whether metric
minimized maximized. course, planner free ignore field make
assumption plans fewest steps considered good plans. However,
consider extension crucial one development widely applicable
planning language. provided variable total-time takes value
total execution time plan. allows us conveniently express intention
minimize total execution time.
anticipate extensions plan metric syntax prove necessary
longer term, believe version already provides significant new challenge
community. Problem specifications still somewhat impoverished terms
ability easily specify temporal constraints goals non-standard features
initial goal states. Again, anticipate need extension, chosen leave
clean sheet future developments.
<problem>

::= (define (problem <name>)
(:domain <name>)
[<require-def>]
[<object declaration> ]
<init>
<goal>
[<metric-spec>]
[<length-spec> ])
<object declaration> ::= (:objects <typed list (name)>)
<init>
::= (:init <init-el> )
<init-el>
::= <literal(name)>

119

fiFox & Long

<init-el>
<goal>
<metric-spec>
<optimization>
<optimization>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<length-spec>

::=:fluents (= <f-head> <number>)
::= (:goal <GD>)
::= (:metric <optimization> <ground-f-exp>)
::= minimize
::= maximize
::= (<binary-op> <ground-f-exp> <ground-f-exp>)
::= (- <ground-f-exp>)
::= <number>
::= (<function-symbol> <name> )
::= total-time
::= <function-symbol>
::= (:length [(:serial <integer>)]
[(:parallel <integer>)])
length-spec deprecated.

A.5 Requirements
table requirements pddl2.1. requirements imply others;
abbreviations common sets requirements. domain stipulates requirements,
assumed declare requirement :strips.
Requirement
:strips
:typing
:negative-preconditions
:disjunctive-preconditions
:equality
:existential-preconditions
:universal-preconditions
:quantified-preconditions
:conditional-effects
:fluents
:adl

:durative-actions
:duration-inequalities
:continuous-effects

Description
Basic STRIPS-style adds deletes
Allow type names declarations variables
Allow goal descriptions
Allow goal descriptions
Support = built-in predicate
Allow exists goal descriptions
Allow forall goal descriptions
= :existential-preconditions
+ :universal-preconditions
Allow action effects
Allow function definitions use effects using
assignment operators arithmetic preconditions.
= :strips + :typing
+ :negative-preconditions
+ :disjunctive-preconditions
+ :equality
+ :quantified-preconditions
+ :conditional-effects
Allows durative actions.
Note imply :fluents.
Allows duration constraints durative
actions using inequalities.
Allows durative actions affect fluents
continuously duration actions.

120

fipddl2.1: Expressing Temporal Planning Domains

References
Allen, J. (1984). Towards general theory action time. Artificial Intelligence, 23,
123154.
Allen, J. (1991). Planning temporal reasoning. Proceedings KR-91, pp. 314.
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaining approach. Proceedings IJCAI01, pp. 417424.
Bacchus, F., & Kabanza, F. (1998). Planning temporally extended goals. Annals
Mathematics Artificial Intelligence, 22, 527.
Bacchus, F., & Kabanza, F. (2000). Using temporal logic express search control knowledge
planning. Artificial Intelligence, 116(1-2), 123191.
Bacchus, F., Tenenberg, J., & Koomen, J. (1991). non-reified temporal logic AI.
Artificial Intelligence, 52, 87108.
Blum, A., & Furst, M. (1995). Fast Planning Plan-graph Analysis. Proceedings
IJCAI-95.
Cesta, A., & Oddi, A. (1996). Gaining efficiency flexibility simple temporal problem. Chittaro, L., Goodwin, S., Hamilton, H., & Montanari, A. (Eds.), Proceedings
TIME96.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 29, 333377.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Proceedings ECP-01.
Drabble, B., & Tate, A. (1994). use optimistic pessimistic resource profiles
inform search activity based planner. Proceedings AIPS-94. AAAI Press.
El-Kholy, A., & Richards, B. (1996). Temporal resource reasoning planning:
ParcPlan approach. Proceedings ECAI96.
Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theoremproving problem-solving. Artificial Intelligence, 2 (3), 189208.
Fox, M., & Long, D. (2002). PDDL+ : Planning time metric resources. Tech.
rep. Department Computer Science, 21/02, University Durham, UK. Available
at: http://www.dur.ac.uk/d.p.long/competition.html.
Galipienso, M., & Sanchis, F. (2002). Representation reasoning disjunction temporal constraints. Proceedings TIME02.
Garrido, A., Onainda, E., & Barber, F. (2001). Time-optimal planning temporal problems. Proceedings ECP01.
Gazen, B., & Knoblock, C. (1997). Combining expressivity UCPOP efficiency
Graphplan. Proceedings ECP-97, pp. 221233.
Gelfond, M., Lifschitz, V., & Rabinov, A. (1991). limitations situation
calculus?. Boyer, R. (Ed.), Essays honor Woody Bledsoe, pp. 167179. Kluwer
Academic.
121

fiFox & Long

Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal
planner. Proceedings AIPS94.
Gupta, V., Henziner, T., & Jagadeesan, R. (1997). Robust timed automata. HART-97:
Hybrid Real-time Systems, LNCS 1201, pp. 331345. Springer-Verlag.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP01, Toledo.
Hayes, P., & Allen, J. (1987). Short time periods. Proceedings IJCAI-87, pp. 981983.
Helmert, M. (2002). Decidability undecidability results planning numerical
state variables. Proceedings AIPS-02.
Henzinger, T. (1996). theory hybrid automata. Proceedings 11th Annual Symposium Logic Computer Science. Invited tutorial., pp. 278292. IEEE
Computer Society Press.
Henzinger, T., & Raskin, J.-F. (2000). Robust undecidability timed hybrid systems.
Proceedings 3rd International Workshop Hybrid Systems: Computation
Control. LNCS 1790., pp. 145159. Springer-Verlag.
Howey, R., & Long, D. (2002). Validating plans continuous effects. Tech. rep., Dept.
Computer Science, University Durham.
Jonsson, A., Morris, P., Muscettola, N., & Rajan, K. (2000). Planning interplanetary
space: theory practice. Proceedings AIPS-00.
Kowalski, R., & Sergot, M. (1986). logic-based calculus events. New Generation
Computing, 4, 6795.
Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings IJCAI-95. Morgan Kaufmann.
Lifschitz, E. (1986). semantics STRIPS. Proceedings 1986 Workshop:
Reasoning Actions Plans.
Long, D., & Fox, M. (2003a). Exploiting graphplan framework temporal planning.
Proceedings ICAPS03.
Long, D., & Fox, M. (2003b). overview analysis results 3rd International
Planning Competition. Journal Artifical Intelligence Research, issue.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
AAAI91, Vol. 2, pp. 634639, Anaheim, California, USA. AAAI Press/MIT Press.
McCarthy, J. (1980). Circumscription form non-monotonic reasoning. Artificial
Intelligence, 13, 2739.
McCarthy, J., & Hayes, P. (1969). philosophical problems standpoint
artificial intelligence. Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 4, pp.
463502. Edinburgh University Press.
McDermott, D. (1982). temporal logic reasoning processes plans. Cognitive
Science, 6, 101155.
McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2).
122

fipddl2.1: Expressing Temporal Planning Domains

McDermott, D. (2003). Reasoning autonomous processes estimated-regression
planner. Proceedings ICAPS-03.
McDermott, D., & AIPS-98 Planning Competition Committee (1998).
PDDLthe planning domain definition language.
Tech. rep., Available at:
www.cs.yale.edu/homes/dvm.
Muscettola, N. (1994). HSTS: Integrating planning scheduling. Zweben, M., & Fox,
M. (Eds.), Intelligent Scheduling, pp. 169212. Morgan Kaufmann, San Mateo, CA.
Nau, D., Cao, Y., Lotem, A., & Munoz-Avila, H. (1999). SHOP: Simple hierarchical ordered
planner. Proceedings IJCAI99.
Pednault, E. (1986). Formulating multiagent, dynamic-world problems classical planning framework. Georgeff, M., & Lansky, A. (Eds.), Proceedings Timberline
Oregon Workshop Reasoning Actions Plans.
Pednault, E. (1989). ADL: Exploring middle ground STRIPS situation
calculus. Proceedings KR-89, pp. 324332.
Penberthy, J., & Weld, D. (1994). Temporal planning continuous change. Proceedings
AAAI-94. AAAI/MIT Press.
Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial-order planner
ADL. Proceedings KR92, pp. 103114, Los Altos, CA. Kaufmann.
Rabideau, G., Knight, R., Chien, S., Fukunaga, A., & Govindjee, A. (1999). Iterative repair
planning spacecraft operations ASPEN system. International Symposium
Artificial Intelligence Robotics Automation Space (i-SAIRAS).
Reichgelt, H. (1989). comparison first order modal theories time. Jackson,
P., Reichgelt, H., & van Harmelen, F. (Eds.), Logic-based knowledge representation,
pp. 143176. MIT Press.
Reiter, R. (1980). logic default reasoning. Artificial Intelligence, 13, 81132.
Russell, S., & Norvig, P. (1995). Artificial Intelligence: Modern Approach. Prentice Hall.
Sandewall, E. (1994). Features fluents: representation knowledge dynamical
systems, volume I. Oxford University Press.
Shanahan, M. (1990). Representing continuous change event calculus. Proceedings
ECAI90, pp. 598603.
Shanahan, M. (1999). event calculus explained. Wooldridge, M., & Veloso, M.
(Eds.), Artificial Intelligence Today, pp. 409430. Springer Lecture Notes Artificial
Intelligence no. 1600.
Shoham, Y. (1985). Ten requirements theory change. New Generation Computing,
3, 467477.
Smith, D., & Weld, D. (1999). Temporal planning mutual exclusion reasoning.
Proceedings IJCAI-99, Stockholm, pp. 326337.
Tate, A. (1977). Generating project networks. Proceedings IJCAI77.
van Bentham, J. (1983). logic time. Kluwer Academic Press, Dordrecht.
123

fiFox & Long

Vere, S. (1983). Planning time: Windows durations activities goals. IEEE
Transactions Pattern Analysis Machine Intelligence, 5.
Vila, L. (1994). survey temporal reasoning artificial intelligence. AI Communications, 7, 428.
Wilkins, D. (1988). Practical Planning: Extending Classical AI Planning Paradigm.
Morgan Kaufmann Publishers Inc., San Francisco, CA.

124

fi
