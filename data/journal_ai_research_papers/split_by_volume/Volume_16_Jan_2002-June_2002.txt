Journal of Artificial Intelligence Research 16 (2002) 167-207

Submitted 3/01; published 3/02

Learning Geometrically-Constrained Hidden Markov Models for
Robot Navigation: Bridging the Topological-Geometrical Gap
Hagit Shatkay

hagit.shatkay@celera.com

Informatics Research Group,
Celera Genomics, Rockville, MD 20850

Leslie Pack Kaelbling

Artificial Intelligence Laboratory
Massachusetts Institute of Technology, Cambridge, MA 02139

lpk@ai.mit.edu

You will come to a place where the streets are not marked.
Some windows are lighted but mostly they're darked.
A place you could sprain both your elbow and chin!
Do you dare to stay out? Do you dare to go in?...
And if you go in, should you turn left or right...
or right-and-three-quarters? or, maybe, not quite?...
Simple it's not, I'm afraid you will find,
for a mind-maker-upper to make up his mind.

Oh, the Places You'll Go, Dr. Seuss.

Abstract
Hidden Markov models (hmms) and partially observable Markov decision processes
(pomdps) provide useful tools for modeling dynamical systems. They are particularly
useful for representing the topology of environments such as road networks and oce
buildings, which are typical for robot navigation and planning. The work presented
here describes a formal framework for incorporating readily available odometric information and geometrical constraints into both the models and the algorithm that learns
them. By taking advantage of such information, learning hmms/pomdps can be made
to generate better solutions and require fewer iterations, while being robust in the face
of data reduction. Experimental results, obtained from both simulated and real robot
data, demonstrate the effectiveness of the approach.

1 Introduction

This work is concerned with robots that need to perform tasks in structured environments.
A robot moving in the environment suffers from two main limitations: its noisy sensors prevent
it from confidently knowing where it is, while its noisy effectors prevent it from knowing with
certainty where its actions will take it. We concentrate here on structured environments, which
can in turn be characterized by two main properties: such environments consist of vast uneventful and uninteresting areas, and are interspersed with relatively few interesting positions or
situations. Consider for instance a robot delivering a bagel in an oce building. The interesting
situations are the doors and the intersections in the building hallways, as well as the various
c 2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiShatkay & Kaelbling

positions where the bagel might be with respect to the robot's arm (e.g., the robot is holding
the bagel, puts it down, etc.) Most other aspects of the environment, such as the desk positions
in the oces, are inconsequential for the bagel delivery task.
A natural way to represent the combination of such an environment and the robot's interactions
with it, is as a probabilistic automaton, in which states represent interesting situations, and
edges between states represent the actions leading from one situation to another. Probability
distributions over the transitions and over the possible observations the robot may perceive at
each situation model the robot's noisy effectors and sensors, respectively.
Such models are formally known as pomdp (partially observable Markov decision process) models, and have been proven useful for robot planning and acting under the inherent world uncertainty (Simmons & Koenig, 1995; Nourbakhsh, Powers, & Birchfield, 1995; Cassandra, Kaelbling, & Kurien, 1996).
Despite much work on using such models, the task of learning them directly and automatically
from the data has not been widely addressed. Research concerning this immediate topic to date
consists mostly of the work done by Simmons and Koenig (1996b). The assumption underlying
their work was that a human provides a rather accurate topological model of the states and
their connections, and the exact probability distributions are then learned on top of this model,
using a version of the Baum-Welch algorithm (Rabiner, 1989). Another interesting approach to
the acquisition of topological models is that of Thrun and Bucken (1996a,1996b; Thrun, 1999),
who focused on extracting deterministic topological maps from previously acquired geometricalgrid-based maps, where the latter were learned directly from the data. Further discussion of
related research on both the geometrical and the topological approaches, in their probabilistic
and deterministic versions, is given in the next section.
The work reported here is the first successful attempt we are aware of to learn purely probabilistictopological models, directly and completely from recorded data, without using previous humanprovided or grid-based models. It is based on using weak geometric information, recorded by
the robot, to help learn the topology of the environment, and represent it as a probabilistic
model. Therefore, it directly bridges the historically perceived gap between topological and
geometrical information, and addresses the claim presented in Thrun's work (1999) that the
main shortcoming of the topological approach is its failure to utilize the inherent geometry of
the learnt environment.
Most robots are equipped with wheel encoders that enable an odometer to record the change in
the robot's position as it moves through the environment. This data is typically very noisy and
inaccurate. The oors in the environment are rarely smooth, the wheels of the robot are not
always aligned and neither are the motors, the mechanics is imperfect, resulting in slippage and
drift. All these effects accumulate, and if we were to mark the initial position of the robot, and
try to estimate its current position based on summing a long sequence of odometric recordings,
the resulting estimate will be incorrect. That is, the raw recorded odometric information is
not an effective tool, in and of itself, for determining the absolute location of the robot in the
environment.
While our approach is not aimed at determining absolute locations, the idea underlying it is that
this weak odometric information, despite its noise and inaccuracy, still provides geometrical cues
that can help to distinguish between different states, as well as to identify revisitation of the
same state. Hence, such information enhances the ability to learn topological models. However,
168

fiLearning Geometrically-Constrained HMMs

the use of geometrical information requires careful treatment of geometrical constraints and
directional data. We demonstrate how the existing models and algorithms can be extended to
take advantage of the noisy odometric data and the geometrical constraints. The geometrical
information is directly incorporated into the probabilistic topological framework, producing a
significant improvement over the standard Baum-Welch algorithm, without the need for humanprovided model.
The rest of this paper is organized as follows: Section 2 provides a survey of previous work in
the area of learning maps for robot navigation, and briey refers to earlier work on learning
automata; Section 3 presents the formal framework for this work; Section 4 presents the main
aspects of our iterative learning algorithm, while Section 5 describes the strategies for selecting
the initial point from which the iterative process begins; Section 6 presents experimental results
obtained from both simulated and real robot data in traditionally hard-to-learn environments.
The experiments demonstrate that our algorithm indeed converges to better models with fewer
iterations than the standard Baum-Welch method, and is robust in the face of data reduction.

2 Approaches to Learning Maps and Models

The work presented here lies in the intersection between the theoretical area of learning computational models|in particular, learning automata from data sequences|and the applied area of
map acquisition for robot navigation. We concentrate here on surveying the work in the latter
area, pointing out the distinction between our approach and its predecessors. We briey review
some results from automata and computational learning theory. A more comprehensive review
of theoretical results is given by Shatkay (1999).

2.1 Modeling Environments for Robot Navigation

In the context of maps and models for robot navigation, a distinction is usually made between two
principal kinds of maps: geometric and topological. Geometric maps describe the environment
as a collection of objects or occupied positions in space, and the geometric relationships among
them. The topological framework is less concerned with the geometrical positions, and models
the world as a collection of states and their connectivity, that is, which states are reachable from
each of the other states and what actions lead from one state to the next.
We draw an additional distinction, between world-centric1 maps that provide an \objective"
description of the environment independent of the agent using the map, and robot-centric models
which capture the interaction of a particular \subjective" agent with the environment. When
learning a map, the agent needs to take into account its own noisy sensors and actuators and try
to obtain an objectively correct map that other agents could use as well. Similarly, other agents
using the map need to compensate for their own limitations in order to assess their position
according to the map. When learning a model that captures interaction, the agent acquiring the
model is the one who is also using it. Hence, the noisy sensors and actuators specific to the agent
are reected in the model. A different model is likely to be needed by different agents. Most
of the related work described below, especially within the geometrical framework, is centered
around learning objective maps of the world rather than agent-specific models. We shall point
out in this survey the work that is concerned with the latter kind of models.
Our work focuses on acquiring purely topological models, and is less concerned with learning
geometrical relationships between locations or objects, or objective maps, although geometrical
1. We thank Sebastian Thrun for the terminology.

169

fiShatkay & Kaelbling

relationships do serve as an aid in our acquisition process. The concept of a state used in this
topological framework is more general than the concept of a geometrical location, since a state
can include information such as the battery level, the arm position etc. Such information, which
is of great importance for planning, is non-geometrical in nature and therefore cannot be readily
captured in a purely geometrical framework. The following sections provide a survey of work
done both within the geometrical framework and within the topological framework, as well as
combinations of the two approaches.

2.2 Geometric Maps

Geometric maps provide a description of the environment in terms of the objects placed in it
and their positions. For example, grid-based maps are an instance of the geometric approach.
In a grid-based map, the environment is modeled as a grid (an array), where each position in
the grid can be either vacant or occupied by some object (binary values placed in the array).
This approach can be further refined to reect uncertainty about the world, by having grid cells
contain occupancy probabilities rather than just binary values. A lot of work has been done on
learning such grid-based maps for robot navigation through the use of sonar readings and their
interpretation, by Moravec and Elfes and others (Moravec & Elfes, 1985; Moravec, 1988; Elfes,
1989; Asada, 1991).
An underlying assumption when learning such maps is that the robot can tell (or find out)
where it is on the grid when it obtains a sonar reading indicating an object, and therefore can
place the object correctly on the grid. A similar localization assumption, requiring the robot
to identify its geometrical location, underlies other geometric mapping techniques by Leonard
et al. (1991), Smith et al. (1991), Thrun et al. (1998b) and Dissanayake et al. (2001), even
when an explicit grid is not part of the model. Explicit localization can be hard to satisfy.
Leonard et al. (1991) and Smith et al. (1991) address this issue through the use of geometrical
beacons to estimate the location of the robot. In what is known as the Kalman filter method, a
Gaussian probability distribution is used to model the robot's possible current location, based
on observations collected up to the current point, (without allowing the refinement of previous
position estimates based on later observations). Research in this area has recently been extended
in two directions: Leonard and Feder (2000) partition the task of learning one large map into
learning multiple smaller map-sections, thus addressing the issue of computational eciency.
Dissanayake et al. (2001) conduct a theoretical study of the approach and show its convergence
properties. The latter may lead to computational eciency by identifying the cases for which a
steady-state solution can be readily obtained, accordingly bounding the number of steps required
by the algorithms to reach a useful solution in these cases.
Work by Thrun et al. (1998a) uses a similar probabilistic approach for obtaining grid-based maps.
This work is refined (Thrun et al., 1998b) to first learn the location of significant landmarks in
the environment and then fill in the details of the complete geometrical grid, based on laser range
scans. The latter work extends the approach of Smith et al. , by using observations obtained
both before and after a location has been visited, in order to derive a probability distribution
over possible locations. To achieve this, the authors use a forward-backward procedure similar
to the one used in the Baum-Welch algorithm (Rabiner, 1989), in order to determine possible
locations from observed data. The approach resembles ours both in the use of the forwardbackward estimation procedure, and in its probabilistic basis, aiming at obtaining a maximum
likelihood map of the environment. It still significantly differs from ours both in its initial
assumptions and in its final results. The data assumed to be provided to the learner includes
170

fiLearning Geometrically-Constrained HMMs

both the motion model and the perceptual model of the robot. These consist of transition and
observation probabilities within the grid. Both of these components are learnt by our algorithm,
although not in a grid context but in a coarser-grained, topological framework. The end result of
their algorithm is a probabilistic grid-based map, while ours is a probabilistic topological model,
as further explained in the next section.
In addition to being concerned only with locations, rather than with the richer notion of state,
a fundamental drawback of geometrical maps is their fine granularity and high accuracy. Geometrical maps, particularly grid-based ones, tend to give an accurate and detailed picture of the
environment. In cases where it is necessary for a robot to know its exact location in terms of
metric coordinates, metric maps are indeed the best choice. However, many planning tasks do
not require such fine granularity or accurate measurements, and are better facilitated through a
more abstract representation of the world. For example, if a robot needs to deliver a bagel from
oce a to oce b, all it needs to have is a map depicting the relative location of a with respect to
b, the passageways between the two oces, and perhaps a few other landmarks to help it orient
itself if it gets lost. If it has a reasonably well-operating low-level obstacle avoidance mechanism
to help it bypass ower pots and chairs that it might encounter on its way, such objects do
not need to be part of the environment map. Just as a driver traveling between cities needs to
know neither his longitude and latitude coordinates on the globe, nor the location of the specific
houses along the way, the robot does not need to know its exact location within the building
nor the exact location of various items in the environment, in order to get from one point to
another. Hence, the effort of obtaining such detailed maps is not usually justified. In addition
the maps can be very large, which makes planning|even though planning is polynomial in the
size of the map|inecient.

2.3 Topological Maps and Models

An alternative to the detailed geometric maps are the more abstract topological maps. Such
maps specify the topology of important landmarks and situations (states), and routes or transitions (arcs) between them. They are concerned less with the physical location of landmarks,
and more with topological relationships between situations. Typically, they are less complex and
support much more ecient planning than metric maps. Topological maps are built on lowerlevel abstractions that allow the robot to move along arcs (perhaps by wall- or road-following),
to recognize properties of locations, and to distinguish significant locations as states; they are
exible in allowing a more general notion of state, possibly including information about the
non-geometrical aspects of the robot's situation.
There are two typical strategies for deriving topological maps: one is to learn the topological
map directly; the other is to first learn a geometric map, then to derive a topological model
from it through some process of analysis.
A nice example of the second approach is provided by Thrun and Bucken (1996a, 1996b; Thrun,
1999), who use occupancy-grid techniques to build the initial map. This strategy is appropriate
when the primary cues for decomposition and abstraction of the map are geometric. However,
in many cases, the nodes of a topological map are defined in terms of other sensory data (e.g.,
labels on a door or whether or not the robot is holding a bagel). Learning a geometric map first
also relies on the odometric abilities of a robot; if they are weak and the space is large, it is very
dicult to derive a consistent map.

171

fiShatkay & Kaelbling

In contrast, our work concentrates on learning a topological model directly, assuming that abstraction of the robot's perception and action abilities has already been done. Such abstractions
were manually encoded into the lower level of our robot navigational software, as described in
Section 6. Work by Pierce and Kuipers (1997) discusses an automatic method for extracting
abstract states and features from raw perceptual information.
Kuipers and Byun (1991) provide a strategy for learning deterministic topological maps. It works
well in domains in which most of the noise in the robot's perception and action is abstracted
away, learning from single visits to nodes and traversals of arcs. A strong underlying assumption
for these strategies, when building the map, is that the current state can be reliably identified
based on local information, or based on distance traversed from the previous well-identified
state. These methods are unable to handle situations in which long sequences of actions and
observations are necessary to disambiguate the robot's state.
Mataric (1990) provides an alternative approach for learning deterministic topological maps,
represented as distributed graphs. The learning process again relies on the assumption that the
current state can be distinguished from all other states based on local information which includes
compass and sonar readings. Uncertainty is not modeled through probability distributions.
Instead, matching of current readings to already existing states is not required to be exact, and
thresholds of tolerated error are set empirically. Another difference from the work presented
here, is that while we learn the complete probabilistic topology of the environment, in Mataric's
work the overall topology of the graph is assumed in advance to be a linear list, and additional
edges are added during the learning process. No probability distribution is associated with the
edges, and a mechanism for choosing which edge to take is determined as part of the goal seeking
process, and is not part of the model itself.
Engelson and McDermott (1992) learn \diktiometric" maps (topological maps with metric relations between nodes) from experience. The uncertainty model they use is interval-based rather
than probabilistic, and the learned representation is deterministic. Ad hoc routines handle problems resulting from failures of the uncertainty representation.
We prefer to learn a combined model of the world and the robot's interaction with the world;
this allows robust planning that takes into account likelihood of error in sensing and action. The
work most closely related to ours is by Koenig and Simmons (1996b, 1996a), who learn pomdp
models (stochastic topological models) of a robot hallway environment. They also recognize
the diculty of learning a good model without initial information; they solve the problem by
using a human-provided topological map, together with further constraints on the structure
of the model. A modified version of the Baum-Welch algorithm learns the parameters of the
model. They also developed an incremental version of Baum-Welch that can be used on-line.
Their models contain very weak metric information, representing hallways as chains of one-meter
segments and allowing the learning algorithm to select the most probable chain length. This
method is effective, but results in large models with size proportional to the hallways' length,
and strongly depends on the quality of the human-provided initial model.

2.4 Learning Automata from Data

Informally speaking, an automaton consists of a set of states and a set of transitions that lead
from one state to another. In the context of this work, the automaton states correspond to the
states of the modeled environments, and the transitions, to the state changes due to actions
performed in the environment. Each transition of the automaton is tagged by a symbol from an
172

fiLearning Geometrically-Constrained HMMs

input alphabet, , corresponding to the action or the input to the system that caused the state
transition. Classical automata theory (e.g., Hopcroft & Ullman, 1979) distinguishes between
deterministic and non-deterministic automata. If, for each alphabet symbol ff, there is a single
edge tagged by it, going out of each state, the automaton is deterministic. Otherwise, the
transition between states is not uniquely determined by the input symbol and the automaton is
non-deterministic. If we augment each transition edge of a non-deterministic automaton with a
probability of taking it given a certain input, ff, the resulting automaton is called probabilistic.
The basic problem of learning finite deterministic automata from given data can be roughly
described as follows: Given a set of positive and a set of negative example strings, S and T
respectively, over alphabet , and a fixed number of states k, construct a minimal deterministic
finite automaton with no more than k states that accepts S and does not accept T . This problem
has been shown to be np-complete (Gold, 1978). Despite the hardness, positive results have
been shown possible under various special settings. Angluin (1987) showed that if an oracle can
answer membership queries and provide counterexamples to conjectures about the automaton,
there is a polynomial time learning algorithm from positive and negative examples. Rivest
and Schapire (1987, 1989), provide several effective methods, that under various settings, learn
deterministic automata that are correct with high probability. While the above work deals with
learning from noise-free data, Basye, Dean and Kaelbling (1995) presented several algorithms
that, with high probability, learn input-output deterministic automata, when the data observed
by the learner is corrupted by various forms of noise.
In all these cases, the learned automaton is deterministic rather than probabilistic. The basic
learning problem in the probabilistic context is to find an automaton that assigns the same
distribution as the true one to data sequences, using training data S , that was generated by
the true automaton. Another form of a learning problem is that of finding a probabilistic
automaton  that assigns the maximum likelihood to the training data S ; that is, an automaton
that maximizes Pr(S j).
Abe and Warmuth (1992) show that finding a probabilistic automaton with 2 states, even when
a small error with respect to the true model is allowed with some probability (the probably
approximately correct, or PAC, learning model), cannot be done in polynomial time with polynomial number of examples, unless np = rp. From their work arises the broadly accepted
conjecture, which has not yet been proven, that learning hidden Markov Models is hard even
in the pac sense. There are two ways to address this hardness: one is to restrict the class of
probabilistic models learned, while the other is to learn unrestricted hidden Markov models with
good practical results but with no pac guarantees on the quality of the result.
Work by Ron et al. (1994, 1995, 1998) pursues the first approach, learning restricted classes of
automata, namely, acyclic probabilistic finite automata, and probabilistic finite sux automata.
Both classes are useful for various applications related to natural language processing, and can
be learned in polynomial time within the pac framework.
The second approach, which is the one predominantly taken in this work, is to learn a model that
is a member of the complete unrestricted class of hidden Markov models. Only weak guarantees
exist about the goodness of the model, but the learning procedure may be directed to obtain
practically good results. This approach is based on guessing an automaton (model), and using
an iterative procedure to make the automaton fit better to the training data. One algorithm
commonly used for this purpose is the Baum-Welch algorithm (Baum, Petrie, Soules, & Weiss,
1970), which is presented in detail by Rabiner (1989). The iterative updates of the model are
173

fiShatkay & Kaelbling

based on gathering sucient statistics from the data given the current automaton, and the
update procedure is guaranteed to converge to a model that locally maximizes the likelihood
function Pr(datajmodel). Since the maximum is local, the model might not be close enough
to the true automaton by which the data was generated, and a challenging problem is to find
ways to force the algorithm into converging to higher-likelihood maxima, or at least to make
it converge faster, facilitating multiple guesses of initial models, thus raising the probability
of converging to higher-likelihood maxima. Such an approach is the one taken in the work
presented here.
We assume, throughout this paper, that the number of states in the model we are learning is
known. This is not a very strong assumption since there are methods for learning the number of
states. Regularization methods for deciding on the number of states and other model parameters,
are discussed, for instance, in Vapnik's book (1995). We do not address this issue here.
The rest of the work describes our approach to learning topological models. We use noisy
odometric information that is readily available in most robots. This geometrical information is
typically not used by topological mapping methods. We demonstrate how a topological model
and the algorithm used to learn it can be extended to directly incorporate this weak odometric
information. We further show that by doing so, we can avoid the use of human-provided a priori
models and still learn stochastic environment models eciently and effectively.

3 Models and Assumptions
This section describes the formal framework for our work. It starts by introducing the classic
hidden Markov model. The model is then extended to accommodate noisy odometric information
in its most nave form, ignoring information about the robot's heading and orientation, and later
adapted to accommodate heading information.
We concentrate here on describing models and algorithms for learning hmms, rather than
pomdps. This means that the robot has no decisions to make regarding its next action at
every state; only one action can be executed at each state. In our experiments, a human operator gave the action command associated with each state to the robot when gathering the data.
Note that the action is not necessarily the same one for every state, e.g., the robot is told to
always turn right in state 1 and move forward at state 2. However, at each state only one action can be taken. The extension to complete pomdps, which we have implemented, is through
learning an hmm for each of the possible actions; it is straightforward although notationally
more cumbersome, thus we limit the discussion here to hmms.

3.1 HMMs { The Basics
A hidden Markov model consists of states, transitions, observations and probabilistic behavior,
and is formally defined as a tuple  = hS; O; A; B; i, satisfying the following conditions:

 S = fs0 ; : : : ; sN ,1 g is a finite set of N states.
 O = fo0 ; : : : ; oM ,1g is a finite set of M possible observation values.
174

fiLearning Geometrically-Constrained HMMs

 A is a stochastic transition matrix, with Ai;j = Pr(qt+1 = sj jqt = si), where 0  i; j  N ,1.
NX
,1
qt is the state at time t. For every state si ,

j =0

Ai;j = 1.

Ai;j holds the transition probability from state si to state sj .
 B is a stochastic observation matrix, with Bj;k = Pr(vt = ok jqt = sj ), where 0  j  N , 1;
MX
,1
0  k  M , 1. vt is the observation recorded at time t. For every state sj ,
Bj;k = 1.
Bj;k holds the probability of observing ok while being at state sj .

k=0

  is a stochastic initial distribution vector, with i = Pr(q0 = si), 0  i  N , 1.

NX
,1
i=0

i = 1.

i holds the probability of being in state si at time 0, when starting to record observations.
This model corresponds to a world whose actual state at any given time t, qt 2 S , is hidden
and not directly observable, but some observable aspects of the state, vt 2 O, are detected and
recorded when the state is visited at time t. An agent moves from one hidden state to the
next according to the probability distribution encoded in matrix A. The observed information
in each state is governed by the probability matrix B . Although our work is concerned with
discrete observations, the extension to continuous observations is straightforward and has been
well addressed in work on hidden Markov models (Liporace, 1982; Juang, 1985).
Simply stated, the problem of learning an hmm is that of \reverse engineering" a hidden Markov
model for a stochastic system from the sampled data, generated by the system. We formalize
the learning task in Section 4.1. The next section extends hmms to account for geometric
information.

3.2 Adding Odometry to Hidden Markov Models

The world is composed of a finite set of states. There is a fundamental distinction in our
framework between the term state and the term location. The state of the robot does not
directly correspond to its location. A state may include other information, such as the robot's
battery level or its orientation in that location. A robot standing in the entrance to oce 101
facing right is in a different state than a robot standing in the same place facing left; similarly,
a robot standing with a bagel in its arm is in a different state from the same robot being in the
same position without the bagel.
The dynamics of the world are described by state-transition distributions that specify the probability of making transitions from one state to the next as a result of a certain action. There
is a finite set of observations that can be perceived in each state; the relative frequency of each
observation is described by a probability distribution and depends only on the current state.
In our model, observations are multi-dimensional; an observation is a vector of values, each
chosen from a finite domain. That is, we factorize the observation associated with each state
into several components. For instance, as demonstrated in Section 6.1, we view the observation
recorded by the robot when standing in an oce environment as consisting of three components,
corresponding to the three cardinal directions: front, left and right. In this example, the observation vector is thus 3-dimensional. It is assumed that the vector's components are conditionally
independent, given the state.
175

fiShatkay & Kaelbling

In addition to the above components, each state is assumed to be associated with a position in a
metric space. Whenever a state transition is made, the robot records an odometry vector, which
estimates the position of the current state relative to the previous one. For the time being we assume that the odometry vector consists of readings along the x and y coordinates of a global coordinate system, and that these readings are corrupted with independent normal noise. The latter
independence assumption is not a strict one, and can be relaxed by introducing a complete covariance matrix, although we have not done this in this work. In Section 3.3 we extend the odometry vector to include information about the heading of the robot, and drop the global coordinate
framework.
Note that the odometric relationship characterizes a transition rather than a state and, as
described below, receives a different treatment than the observations that are associated with
states.
There are two important assumptions underlying our treatment of odometric relations between
states: First, that there is an inherent \true" odometric relation between the position of every
two states in the world; second, that when the robot moves from one state to the next, there
is a normal, 0-mean noise around the correct expected odometric reading along each odometric
dimension. This noise reects two kinds of odometric error sources:

{ The lack of precision in the discretization of the real world into states (e.g. there is a rather

large area in which the robot can stand which can be regarded as \the doorway of the AI
lab").
{ The lack of precision of the odometric measures recorded by the robot, due to slippage,
friction, disalignment of the wheels, imprecision of the measuring instruments, etc.

To formally introduce odometric information into the hidden Markov model framework, we
define an augmented hidden Markov model as a tuple  = hS; O; A; B; R; i, where:

 S = fs0 ; : : : ; sN ,1 g is a finite set of N states.
 O = Qli=1 Oi is a finite set of observation vectors of length l. The ith element of an

observation vector is chosen from the finite set Oi .
 A is a stochastic transition matrix, with Ai;j = Pr(qt+1 = sj jqt = si), 0  i; j  N , 1.
NX
,1
qt is the state at time t. For every state si , Ai;j = 1.
j =0

Ai;j holds the transition probability from state si to state sj .
 B is an array of l stochastic observation matrices, with Bi;j;k = Pr(Vt [i] = ok jqt = sj );
1  i  l; 0  j  N , 1; ok 2 Oi ; Vt is the observation vector at time t; Vt [i] is its ith

component.
Bi;j;k holds the probability of observing ok along the ith component of the observation
vector, while being at state sj .
 R is a relation matrix, specifying for each pair of states, si and sj , the mean and variance
of the D-dimensional2 odometric relation between them. (Ri;j [m]) is the mean of the mth

2. For the time being we consider D to be 2, corresponding to (x; y) readings.

176

fiLearning Geometrically-Constrained HMMs

component of the relation between si and sj and 2 (Ri;j [m]), the variance. Furthermore,
R is geometrically consistent: for each component m, the relation m (a; b) = (Ra;b [m])
must be a directed metric, satisfying the following properties for all states a, b, and c:
def

 m(a; a) = 0;
 m(a; b) = ,m(b; a) (anti-symmetry); and
 m(a; c) = m (a; b) + m(b; c) (additivity ) :
This representation of odometric relations reects the two assumptions, previously stated,
regarding the nature of the odometric information. The \true" odometric relation between
the position of every two states is represented as the mean. The noise around the correct
expected odometric relation, accounting for both the lack of precision in the real-world
discretization and the inaccuracy in measurement, is represented through the variance.

  is a stochastic initial probability vector describing the distribution of the initial state.
For simplicity it is assumed here to be of the form h0; : : : ; 0; 1; 0; : : : ; 0i, implying that there
is one designated initial state, si , in which the robot is always started.

This model extends the standard hidden Markov model described in Section 3.1 in two ways:
 It facilitates observations that are factored into components, and represented as vectors.
These components are assumed to be conditionally independent of each other given the
state. Such factorization, together with the conditional independence assumption, allows
for a simple calculation of the probability of the complete observation vector from the
probabilities of its components. It therefore results in fewer probabilistic parameters in
the learnt model than if we were to view each observation vector, consisting of a possible
combination of component-values as a single \atomic" observation.

 It introduces the odometric relation matrix R and constraints over its components. Using
R and the constraints over it, as explained in Section 4, has proven useful for learning the
other model parameters, as demonstrated in Section 6.

3.3 Handling Directional Data

We further extend the model to accommodate directional changes in addition to the positional
changes. There are two issues stemming from directional changes while moving in an environment: the need for non-traditional distributions to model directional changes, and the need
to correct for the cumulative rotational error which severely interferes with location estimation
within a global coordinate framework. A detailed discussion of these two problems and their
solution is given in an earlier paper by the authors (Shatkay & Kaelbling, 1998). For the sake
of completeness, we briey review these two issues here.
3.3.1 Circular Distributions

The robot's change in direction as it moves through the environment is expressed in terms of the
angular change with respect to its original heading. Since angular measures are inherently circular, treating them as \normally distributed", and using the standard procedures for obtaining
sucient statistics from the data is not adequate. As a trivial example, if we were to average
177

fiShatkay & Kaelbling
y

1

<x 1, y1>
<x 2, y2>
<x 3, y3>
1

173 0
179

0

-1

3

2

3
1

x

-1

Figure 1: Simple average of two angles, depicted

as vectors to the unit circle. The average angle is
formed by the dashed vector.

Figure 2: Directional data represented as angles
and as vectors on the unit circle.

the two angular readings, 173 and ,179 , using simple average we obtain the angle ,3 , which
is far from the intuitive  180 , as illustrated in Figure 1.
To address the circularity issue, we use the von Mises distribution, which is a circular version of
the normal distribution, to model the change in heading between two states, as explained below.
A collection of changes in heading within a two dimensional space can be represented in terms
of either Cartesian or polar coordinates. Using a Cartesian system, n changes in headings can
be recorded as a sequence of 2-dimensional vectors, (hx1 ; y1 i; : : : hxn ; yn i), on the unit circle,
as shown in Figure 2. The same changes can also be represented as the corresponding angles
between the radii from the center of the unit circle and the X axis, (1 ; : : : ; n ), respectively.
The relationship between the two representations is:
xi = cos(i ); yi = sin(i ) ; (1  i  n) :
The vector mean of the n points, hx; yi, is calculated as:
Pn cos( )
Pn sin( )
i
i :
i
=1
i=1
x=
y
=
;
n
n

(1)

Using polar coordinates, we can express the mean vector in terms of angle, , and length, a,
where (except for the case x = y = 0):

 = arctan( xy );

a = (x2 + y 2 ) :
1
2

The angle  is the mean angle, while the length a is a measure (between 0 and 1) of how
concentrated the sample angles are around . The closer a is to 1, the more concentrated the
sample is around the mean, which corresponds to a smaller sample variance.
Intuitively, a satisfactory circular version of the normal distribution would have a mean for
which the maximum likelihood estimate is the average angle as calculated above. In a way
analogous to Gauss' derivation of the Normal distribution, von Mises developed such a circular
version (Gumbel, Greenwood, & Durand, 1953; Mardia, 1972), which is defined as follows:
Definition: A circular random variable, , 0    2, is said to have the von Mises
distribution with parameters  and , where 0    2 and  > 0, if its probability density
178

fiLearning Geometrically-Constrained HMMs

function is:

f;() = 2I1 () e cos(,) ;
0

where I0 () is the modified Bessel function of the first kind and order 0:

I0 () =

1 1 1
X
2r
2 ( 2 ) :
r
!
r=0

(2)

The parameters  and  correspond to the distribution's mean and concentration respectively.
While other circular-normal distributions do exist, the von Mises has the desirable estimation
procedure alluded to earlier: Given a set of heading samples, angles 1 ; : : : n , from a von Mises
distribution, the maximum likelihood estimate  for  is:

 = arctan( xy ) ;

where y, x are as defined in Equation 1.
The maximum likelihood estimate for the concentration parameter, , is the  that satisfies:
n
I1 () = max[ 1 X
I0 ()
n i=1 cos(i , ); 0] ;

where I1 is the modified Bessel function of the first kind and order 1:

I1 () =

1
X

1 ( 1 )2r+1 :
r=0 r!(r + 1)! 2

(3)

Further information about the estimation procedure is beyond the scope of this paper and can
be found elsewhere (Gumbel et al., 1953; Mardia, 1972).
To conclude, we assume that the change in heading  is von Mises-distributed, around a mean
 with concentration parameter . This assumption is reected in the model learning procedures
as explained later in Section 4.2.3. The change in heading h (a; b);  (a; b)i between each pair
of states (a; b) completes the set of parameters included in the relation matrix R which was
introduced earlier in Section 3.2.
3.3.2 Cumulative Rotational Error

We tend to think about an environment as consisting of landmarks fixed in a global coordinate
system and corridors or transitions connecting these landmarks. This idea underlies the typical
maps constructed and used in everyday life. However, this view of the environment may be
problematic when robots are involved.
Conceptually, a robot has two levels at which it operates; the abstract level, in which it centers
itself through corridors, follows walls and avoids obstacles, and the physical level in which motors
turn the wheels as the robot moves. In the physical level many inaccuracies can manifest
themselves: wheels can be unaligned with each other resulting in a drift to the right or to the
left, one motor can be slightly faster than another resulting in similar drifts, an obstacle under
one of the wheels can cause the robot to rotate around itself slightly, or uneven oors may cause
179

fiShatkay & Kaelbling

 

- actual position
- recorded position

Figure 3: A robot moving along the solid arrow, while correcting for drift in the direction of the dashed
arrow. The dotted arrow marks its recorded change in position.

the robot to slip in a certain direction. In addition, the measuring instrumentation for odometric
information may not be accurate in and of itself. At the abstract level, corrective actions are
constantly executed to overcome the physical drift and drag. For example, if the left wheel is
misaligned and drags the robot leftwards, a corrective action of moving to the right is constantly
taken in the higher level to keep the robot centered in the corridor.
The phenomena described above have a significant effect on the odometry recorded by the robot,
if such data interpreted with respect to one global framework. For example, consider the robot
depicted in Figure 3. It drifts to the left , when moving from one state to the next, and
corrects for it by moving  to the right in order to maintain itself centered in the corridor.
Let us assume that states are 5 meters apart along the center of the corridor, and that the center
of the corridor is aligned with the Y axis of the global coordinate system. The robot steps back
and forth in the corridor from one state to the next. Whenever the robot reaches a state, its
odometry reading changes by hx; y; i along the hX; Y; headingi dimensions, respectively. As the
robot proceeds, the deviation with respect to the X axis becomes more and more severe. Thus,
after going through several transitions, the odometric changes recorded between every pair of
states, if taken with respect to a global coordinate system, become larger and larger. Similar
problems of inconsistent odometric changes recorded between pairs of states can arise along any
of the odometric dimensions. It is especially severe when such inconsistencies arise with respect
to the heading, since this can lead to mistakenly switching movement along the X and the Y
axes, as well as confusion between forwards and backwards movement (when the deviation in
the heading is around 90 or 180 respectively).
In early work (Shatkay & Kaelbling, 1997) we assumed perpendicularity of the corridors, which
was taken advantage of while the robot collected the data. Odometric readings were recorded
with respect to a global coordinate system, and the robot could re-align itself with the origin after
each turn. A trajectory of odometry recorded under this perpendicularity assumption by our
robot Ramona, along the x and y axes is given in Figure 4. The sequence shown was recorded
while the robot drove repeatedly around a loop of corridors. Further details about the data
gathering process are provided in Section 6. In contrast, Figure 5 shows a trajectory of another
sequence of odometric readings recorded by Ramona, driving through the same corridors, without
using the perpendicularity assumption. The data collected under the latter setting is subjected
to cumulative rotational error.
180

fiLearning Geometrically-Constrained HMMs
3000
1200

2500
1000

2000
800

1500

600

1000

400

200

500
200

400

600

800

1000

-2500 -2000 -1500 -1000 -500

Figure 4: Sequence gathered by Ramona, perpendicularity assumed.

500

1000

Figure 5: Sequence gathered by Ramona, no per-

pendicularity assumed.

Such data can be handled through state-relative coordinate systems (Shatkay & Kaelbling, 1998).
The latter implies that each state si has its own coordinate system, as shown in Figure 6: the
origin is anchored in si , the Y axis is aligned with the robot's heading in the state (denoted by
bold arrows in the figure), and the X axis is perpendicular to it. This is in contrast to a global
coordinate system which is anchored in the initial starting state. Within the global coordinate
system, the relations recorded may vary greatly among multiple instances of the same transition
between the same pair of states. By using the state-relative system, the recorded and learned
relationship between each pair of states, hsi ; sj i, is reliable, despite the fact that it is based on
multiple transitions recorded from si to sj .
Under state-relative coordinate systems, the geometric relation stored in Rij , (which was introduced in Section 3.2), is expressed for each pair of states, si and sj , with respect to the
coordinate system associated with state si. Accordingly, the constraints imposed over the x and
y components of the relation matrix must be specified with respect to the explicit coordinate
system used, as explained below.
Given a pair of states a and b, we denote by hx;yi (a; b) the vector h(Ra;b [x]); (Ra;b [y])i. Let
us define Tab to be the transformation that maps an hxa ; ya i point represented with respect to
the coordinate system of state a, to the same point represented with respect to the coordinate
system of state b, hxb ; yb i.
More explicitly, let ab be the mean change in heading from state a to state b. Applying Tab to
a vector h xyaa i results in the vector h xybb i as follows:

* +

* + *

xb
x
x cos(ab ) , ya sin(ab )
= Tab a = a
yb
ya
xa sin(ab ) + ya cos(ab )

+

:

The consistency constraints within this framework must be restated as:

 hx;yi(a; a) = h0; 0i;
 hx;yi(a; b) = ,Tba[hx;yi(b; a)] (anti-symmetry);
 hx;yi(a; c) = hx;yi (a; b) + Tba[hx;yi (b; c)] (additivity).
181

fiShatkay & Kaelbling
y

x
Sj
Si



y

x

Figure 6: A robot in state Si , faces in the Y -axis direction; the relation Si ,Sj is wrt Si 's coordinate
system.

These consistency constraints are the ones that need to be enforced by our learning algorithm
which constructs the hmm. It is important to note that the transformation T itself does not
constitute a set of additional parameters that need to be learnt. Rather, it is calculated in terms
of the heading-change parameter,  , which is already an integral part of the relation matrix we
have defined in Sections 3.2 and 3.3.1.
We have introduced the basic formal model that we use for representing environments and
the robot's interaction with them. In the following section we state the learning problem and
describe the basic algorithm for learning the model from data.

4 Learning HMMs with Odometric Information

This section formalizes the learning problem for hmms, and discusses how odometric information
is incorporated into the learning algorithm. An overview of the complete algorithm is provided
in the Appendix for this paper.

4.1 The Learning Problem

The learning problem for hidden Markov models can be generally stated as follows: Given an
experience sequence E, find a hidden Markov model that could have generated this sequence and
is \useful" or \close to the original" according to some criterion. An explicit common statistical
approach is to look for a model  that maximizes the likelihood of the data sequence E given
the model. Formally stated, it maximizes Pr(Ej). However, given the complicated landscape
of typical likelihood functions in a multi-parameter domain, obtaining a maximum likelihood
model is not feasible. All studied practical methods, and in particular the well-known BaumWelch algorithm (Rabiner (1989) and references therein) can only guarantee a local-maximum
likelihood model.
Another way of evaluating the quality of a learned model is by comparing it to the true model.
We note that stochastic models (such as hmms) induce a probability distribution over all observation sequences of a given length. The Kullback-Leibler (Kullback & Leibler, 1951) divergence
of a learned distribution from a true one is a commonly used measure for estimating how good a
182

fiLearning Geometrically-Constrained HMMs

learned model is. Obtaining a model that minimizes this measure is a possible learning goal. The
culprit here is that in practice, when we learn a model from data, we do not have any \ground
truth" model to compare the learned model with. Still, we can evaluate learning algorithms by
measuring how well they perform on data obtained from known models. It is reasonable to expect that an algorithm that learns well from data that is generated from a model we do have, will
perform well on data generated from an unknown model, assuming that the models indeed form
a suitable representation of the true generating process. We discuss the Kullback-Leibler (kl)
divergence in more detail in Section 6.2 in the context of evaluating our experimental results.
To summarize, the learning problem as we address it in this work is that of obtaining a model
by attempting to (locally) maximize the likelihood, while evaluating the results based on the
kl-divergence with respect to the true underlying distribution, when such a distribution is
available.

4.2 The Learning Algorithm

The learning algorithm starts from an initial model 0 and is given an experience sequence E;
it returns a revised model , which (locally) maximizes the likelihood P (Ej). The experience
sequence E is of length T ; each element, Et , for 0  t  (T , 1), is a pair hrt ; Vt i, where rt is the
observed relation vector along the x, y and  dimensions, between the states qt,1 and qt , and Vt
is the observation vector at time t.
Our algorithm extends the standard Baum-Welch algorithm to deal with the relational information and the factored observation sets. The Baum-Welch algorithm is an expectationmaximization (em) algorithm (Dempster, Laird, & Rubin, 1977); it alternates between
 the E-step of computing the state-occupation and state-transition probabilities,  and ,
at each time in the sequence given E and the current model , and
 the M-step of finding a new model, , that maximizes P (Ej; ; ),
providing monotone convergence of the likelihood function P (Ej) to a local maximum.
However, our extension introduces an additional component, namely, the relation matrix R. It
can be viewed as having two kinds of observations: state observations (as the ordinary hmm |
with the distinction that we observe integer vectors rather than integers) and transition observations (the odometry relations between states). The latter must satisfy geometrical constraints.
Hence, an extension of the standard update formulae, as described below, is required.
4.2.1 State-Occupation Probabilities

Following Rabiner (1989), we first compute the forward (ff) and backward (fi ) matrices. fft (i)
denotes the probability density value of observing E0 through Et and qt = si , given ; fit (i) is
the probability density of observing Et+1 through ET ,1 given qt = si and . Formally:
fft (i) = Pr(E0 ; : : : ; Et ; qt = sij) ;
fit (i) = Pr(Et+1 ; : : : ; ET ,1 jqt = si ; ) :
When some of the measurements are continuous (as is the case with R), these matrices contain
probability density values rather than probabilities.
The forward procedure for calculating the ff matrix is initialized with
( i
b if i = 1
ff0 (i) = 00 otherwise
;
183

fiShatkay & Kaelbling

and continued for 0 < t  T , 1 with
fft (j ) =

NX
,1
i=0

fft,1 (i)Ai;j f (rt jRi;j )bjt :

(4)

The expression f (rt jRi;j ) denotes the density at point rt according to the distribution represented
by the means and variances in entry i; j of Q
the relation matrix R, while bjt is the probability of
j
observing vector vt in state sj ; that is, bt = li=0 Bi;j;vt[i] .
The backward procedure for calculating the fi matrix is initialized with fiT ,1 (j )=1, and continued
for 0  t<T , 1 with
NX
,1
fit (i) = fit+1 (j )Ai;j f (rt+1 jRi;j )bjt+1 :
(5)
j =0

Given ff and fi , we now compute for each given time point t the state-occupation and statetransition probabilities,  and  . The state-occupation probabilities, t (i), representing the
probability of being in state si at time t given the experience sequence and the current model,
are computed as follows:
:
(6)
t (i) = Pr(qt = si jE; ) = PNff,t1(i)fit (i)
j =0 fft (j )fit (j )
Similarly, t (i; j ), the state-transition probabilities from state i to state j at time t given the
experience sequence and the current model, are computed as:
t (i; j ) = Pr(qt = si ; qt+1 = sj jE; )
fft (i)Ai;j bjt+1 f (rt+1 jRi;j )fit+1 (j )
:
(7)
=
NX
,1 NX
,1
i=0 j =0

fft (i)Ai;j bjt+1 f (rt+1 jRi;j )fit+1 (j )

These are essentially the same formulae appearing in Rabiner's tutorial (Rabiner, 1989), but
they also take into account the density of the odometric relations.
In the next phase of the algorithm, the goal is to find a new model, , that maximizes the likelihood conditioned on the current transition and observation probabilities, Pr(Ej; ;  ). Usually,
this is simply done using maximum-likelihood estimation of the probability distributions in A
and B by computing expected transition and observation frequencies. In our model we must also
compute a new relation matrix, R, under the constraint that it remain geometrically consistent.
Through the rest of this section we use the notation v to denote a reestimated value, where v
denotes the current value.
4.2.2 Updating Transition and Observation Parameters

The A and B matrices can be straightforwardly reestimated. Ai;j is the expected number of
transitions from si to sj divided by the expected number of transitions from si , and B i;j;k is the
expected number of times ok is observed along the ith dimension when in state sj , divided by
the expected number of times of being in sj :
PT ,1 
PT ,2  (i; j )
t
t
=0
; B i;j;k = t=0PT[V,t1[i]=ok ] t (j ) :
(8)
Ai;j = PT ,2
t=0 t (i)
t=0 t (i)
The expression c denotes an indicator function with value 1 if condition c is true and 0 otherwise.
184

fiLearning Geometrically-Constrained HMMs
7.5
P

Q

5

P

2.5

-8

-6

-4

-2

2

4

6

8

-2.5
-5

-6

-4

-2

2

4

6
-7.5

Q

Figure 7: Examples of two sets of normally distributed points with constrained means, in 1 and in 2
dimensions.

4.2.3 Updating Relation Parameters

When reestimating the relation matrix, R, the geometrical constraints induce interdependencies
among the optimal mean estimates as well as between optimal variance estimates and mean
estimates. Parameter estimation under this form of constraints is almost untreated in mainstream statistics (Bartels, 1984) and we found no previous existing solutions to the estimation
problem addressed here. As an illustration for the issues involved in estimation under constraints
consider the following estimation problem of 2 normal means:
Example 4.1 The data consists of two sample sets of points P = fp1; p2 ; : : : ; pn g and Q =
fq1; q2 ; : : : ; qk g, independently drawn from two distinct normal distributions with means P ; Q
and variances P2 ; Q2 , respectively. We are asked to find maximum likelihood estimates for the
two distribution parameters. Moreover, we are told that the means of the two distributions are
related, such that Q = ,P , as illustrated in Figure 7. If not for the latter constraint, the task
is simple (DeGroot, 1986), and we have:
Pn p
Pn
i ;  2 = i=1 (pi , P )2 ;
P = i=1
P
n
n

and similarly for Q and Q2 . However, the constraint P = ,Q requires finding a single mean, ,
and setting the other one to its negated value, ,. Intuitively, when choosing such a maximum
likelihood single mean, the more concentrated sample should have more effect, while the more
varied sample should be more \submissive." Thus, the overall sample deviation from the means
would be minimized and the likelihood of the data maximized. Therefore, there is a mutual
dependence between the estimation of the mean and the estimation of the variance.
Since the samples are independently drawn, their joint likelihood function is:
,(pi ,P )2

n
P
Y
f (P; QjP ; Q; P2 ; Q2 ) = e p
i=1 2P
2 2



Yk e
j =1

,(qj ,Q )2
Q

p

2 2

2Q

:

By taking the derivatives of this joint log-likelihood function, with respect to P , P and Q, and
equating them to 0, while using the constraint Q = ,P , we obtain the following set of mutual
equations for maximum likelihood estimators:
P
P
(Q2 ni=1 pi) , (P2 kj=1 qj )
P =
; Q = ,P ;
nQ2 + kP2
Pk (q +  )2
Pn (p ,  )2
i
P
i
=1
2
2
P =
; Q = j =1 j P :

n

k

185

fiShatkay & Kaelbling

By substituting the expressions for P and Q into the expression for P , we obtain a cubic equation which is cumbersome, but still solvable (in this simple case). The solution provides a maximum likelihood estimate for the mean and variance under the constraint Q = ,P :
2
We now proceed to the actual update of the relation matrix under constraints. For clarity, we
initially discuss only the first two geometrical constraints, and discuss the additivity constraint in
Section 4.3. Recall that we concentrate here on the enforcement of global constraints, appropriate
under the perpendicularity assumption, although the same idea is applied in the case of staterelative constraints.
Zero distances between states and themselves are trivially enforced, by setting all the diagonal
entries in the R matrix to 0, with a small variance.
Anti-symmetry within a global coordinate system is enforced by using the data recorded along
the transition from state sj to si as well as from state si to sj when reestimating (Ri;j ). As
demonstrated in Example 4.1, the variance has to be taken into account, leading to the following
set of mutual equations:



mi;j

=

( mi;j )2 =

PT ,2

rt[m]t (i;j ) , rt [m]t(j;i)
( m
( m
i;j )2
j;i )2

PT ,2 t(mi;j) + t(mj;i) 
t=0 (i;j )2 (j;i )2
PT ,2[ (i; j )(r [m] , m )2 ]
t=0 t
PT ,2 t(i; j ) i;j :
t=0 t
t=0

;

(9)
(10)

For the x and y dimensions, (m = x; y), this amounts to a complicated but still solvable cubic
equation. However, in the more general case, when accounting for the orientation of the robot,
and also when complete additivity is enforced, we do not obtain such closed form reestimation
formulae.
To avoid these hardships, we use a lag-behind update rule; the yet-unupdated estimate of the
variance is used for calculating a new estimate for the mean, and this new mean estimate is
used to update the variance, using Equation 10.3 Thus, the mean is updated using a variance
parameter that lags behind it in the update process, and the reestimation Equation (9) needs to
use m rather than m as follows: PT ,2 h rt [m]t (i;j) rt [m]t (j;i) i
m 2 , j;i
m )2
t=0
i :
(11)
mi;j = PT ,2(hi;jt ()i;j) t ((j;i
)
t=0

m )2 + (j;i
m )2
i;j

(

As we have shown (Shatkay, 1999), this lag-behind policy is an instance of generalized em (McLachlan & Krishnan, 1997). The latter guarantees monotone convergence to a local maximum of the
likelihood function, even when each \maximization" step increases rather than strictly maximizes the expected likelihood of the data given the current model.
Similarly, the reestimation formula for the von Mises mean () and concentration () parameters
of the heading change between states si and sj is the solution to the equations:

0 TX
1
,
BB [sin(rt [])(t (i; j )i;j , t(j; i)j;i)] CC
t
CC
= arctan B
B@ TX
,
A
[cos(rt [])(t (i; j )i;j + t (j; i)j;i )]
2

i;j

=0

2

t=0

3. A similar approach, termed one step late update, is taken by others applying em to highly non-linear optimization problems (McLachlan & Krishnan, 1997).

186

fiLearning Geometrically-Constrained HMMs

I1 [i;j ]
= max
I0 [i;j ]

" PT ,

#
2
(i; j ) cos(rt [] , i;j )]
t=0 [tP
; 0
T ,2  (i; j )
t=0 t

;

(12)

where I0 and I1 are the modified Bessel functions as defined by Equations 2 and 3 in Section 3.3.1.
Again, to avoid the need to solve the mutual equations, we take advantage of the lag-behind strategy, updating the mean using the current estimates of the concentration parameters, i;j ; j;i,
as follows:
PT ,2[sin(r [])( (i; j ) ,  (j; i) )] !
t
t
i;j t
j;i
i;j = arctan PTt=0
(13)
,2 [cos(r [])( (i; j ) +  (j; i) )] ;
t
t
i;j t
j;i
t=0
and then calculating the new concentration parameters based on the newly updated mean, as
the solution to Equation 12, through the use of lookup-tables.
A possible alternative to our lag-behind approach is to update the mean as though the assumption j;i = i;j holds. Under this assumption, the variance terms in Equation 9 cancel out, and
the mean update is independent of the variance once again. Then the variances are updated as
stated in Equation 10, without assuming any constraints over them. This approach was taken
in earlier stages of this work (Shatkay & Kaelbling, 1997, 1998). The lag-behind strategy is
superior, both according to our experiments, and due to its being an instance of generalized em.

4.3 Enforcing Additivity

Note that the additivity constraint directly implies the other two geometrical constraints4 . Thus,
enforcing it results in complete geometrical consistency. We present here the method for directly
enforcing additivity through the reestimation procedure along the x and y dimensions. For the
heading dimension we describe how complete geometrical consistency is achieved through the
projection of anti-symmetric estimates onto a geometrically-consistent space. As before, to
simplify the presentation, we focus on the case of global coordinate systems. The same basic
idea applies to state-relative coordinate systems, but the relationship used to recover the mean
ij from individual state coordinates is more complex.
4.3.1 Additivity in the x, y dimensions

The main observation underlying our approach is that the additivity constraint is a result of the
fact that states can be embedded in a geometrical space. That is, assuming we have N states,
s0; : : : ; sN ,1, there are points on the X , Y and  axes, x0 ; : : : ; xN ,1 , y0 ; : : : ; yN ,1 , 0 ; : : : ; N ,1,
respectively, such that each state, si , is associated with the coordinates hxi ; yi ; i i. Assuming
one global coordinate system, the mean odometric relation from state si to state sj can be
expressed as: hxj , xi ; yj , yi ; j , i i.
During the maximization phase of the em iteration, rather than try to maximize with respect
to N 2 odometric relation vectors, hXij , Yij , ij i, we reparameterize the problem. Specifically,
we express each odometric relation as a function of two of the N state positions, and maximize
with respect to the unconstrained, N state positions. For instance, for the X dimension, rather
than search for N 2 maximum likelihood estimates for xij , we use the maximization step to find
N 1-dimensional points, x0 ; : : : ; xN ,1 . We can then calculate xij = xj , xi . Moreover, since
all we are interested in is finding the best relationships between xi and xj , we can fix one of
4. f(a; a)= (a; a) + (a; a)g ) ((a; a)=0) ; f((a; a)=0) ; ((a; a)= (a; b)+(b; a))g ) ((a; b) = ,(b; a)).

187

fiShatkay & Kaelbling

the xi 's at 0 (e.g. x0 = 0), and find optimal estimates for the remaining N , 1 state positions.
The variance reestimation remains as before, and the lag-behind policy is used to eliminate the
interdependency between the update of the mean and the variance parameters.
4.3.2 Additive Heading Estimation

Unfortunately, the reparameterization described above is not feasible for estimation of changes
in heading, due to the von Mises distribution assumption over the heading measures. By reparameterizing ij as j , i and trying to maximize the likelihood function with respect to the 
parameters, we obtain a set of N,1 trigonometric equations with terms of the form cos(j ) sin(i )
which do not enable simple solution.
As an alternative, it is possible to use the anti-symmetric reestimation procedure described
earlier, followed by a perpendicular projection operator, mapping the resulting headings vector
h00 ; : : : ; ij ; : : : ; N ,1;N ,1i, 0  i; j  N ,1, which does not satisfy additivity, onto a vector of
headings within an additive linear vector space. Simple orthogonal projection is not satisfactory
within our setting, since it simply looks for the additive vector closest to the non-additive one.
This procedure ignores the fact that some of the entries in the non-additive vector are based on
a lot of observations, and are therefore more reliable, while other, less reliable ones, are based on
hardly any data at all. Intuitively, we would like to keep the estimates that are well accounted
for intact, and adapt the less reliable estimates to meet the additivity constraint. More precisely,
there are heading-change estimates between states that are better accounted for than others, in
the sense that the transitions between
these states have higher expected counts than transition
P
between other states (higher t t (i; j )). We would like to project the non-additive heading
estimates vector onto a subspace of the additive vector space, in which the vectors have the same
values as the non-additive
P vector in the entries that are well-accounted for, that is, those with
the highest values of t t (i; j ). The diculty is that the latter subspace is not a linear vector
space (for instance, it does not satisfy closure under scalar multiplication), and the projection
operator over linear spaces cannot be applied directly. Still, this set of vectors does form an
ane vector space, and we can project onto it using an algebraic technique, as explained below.5
Definition
A Rn is an n-dimensional ane space if for all vectors va2A, the set of vectors:
def
A , va = fua , va jua 2 Ag is a linear space.
Hence, we can pick a vector in an ane space, va 2A, and define the translation Ta : A ! V ,
where V is a linear space, V = A , va . This translation is trivially extended for any vector
v0 2 Rn , by defining Ta (v0 ) = v0 , va . In order to project any vector v 2 Rn onto A, we apply
the translation Ta to v and project Ta (v) onto V , which results in a vector P (Ta (v)) in V . By
applying the inverse transform Ta,1 to it, we obtain the projection of v on A, as demonstrated
in Figure 8. The linear space in the figure is the two dimensional vector space fhx; yij y = ,xg,
and the ane space is fhx; yij y = ,x + 4g. The transform Ta consists of subtracting the vector
h0; 4i. The solid arrow corresponds to the direct projection of the vector v onto the point P (v)
of the ane space. The dotted arrows represent the projection via translation of v to Ta (v), the
projection of the latter onto the linear vector space, and the inverse translation of the result,
P (Ta (v)), onto the ane space.
1

1

1

5. Many thanks to John Hughes for introducing us to this technique.

188

fiLearning Geometrically-Constrained HMMs

6
<x,-x+4>
4
P(v)

v

2

-2

2

-2

4
Ta (v)
P(Ta (v))

<x,-x>

-4

Figure 8: Projecting v onto the ane vector space fhx; yij y = ,x + 4g.
Although the procedure for preserving additivity over headings is not formally proven to preserve monotone convergence of the likelihood function towards a local maximum, our extensive
experiments consisting of hundreds of runs have shown that monotone convergence is preserved.

5 Choosing an Initial Model

Typically, in instances of the Baum-Welch algorithm, an initial model is picked uniformly at
random from the space of all possible models, perhaps trying multiple initial models to find different local likelihood maxima. An alternative approach we have reported (Shatkay & Kaelbling,
1997) was based on clustering the accumulated odometric information using the simple k-means
algorithm (Duda & Hart, 1973), taking the clusters to be the states in which the observations
were recorded, to obtain state and observation counts and estimate the model parameters.
If perpendicularity is assumed when collecting the data, as shown in Figure 4, the k-means
algorithm assigns the same cluster (state) to odometric readings recorded at close locations,
leading to reasonable initial models. However, when this assumption is dropped, as illustrated
in Figure 5, the cumulative rotational error distorts the odometric location recorded within a
global coordinate system, so that the location assigned to the same state during multiple visits
varies greatly and would not be recognized as \the same" by a simple location-based clustering
algorithm. To overcome this, we developed an alternative initialization heuristics, which we call
tag-based initialization. It is based directly on the recorded relations between states, rather than
on states' absolute location. For clarity, the description here consists mostly of an illustrative
example, and concentrates on the case where global consistency constraints are enforced.
Given a sequence of observations and odometric readings E, we begin by clustering the odometric
readings into buckets. The number of buckets is at most the number of distinct state transitions
recorded in the sequence. The goal at this stage is to have each bucket contain all the odometric
readings that are close to each other along all three dimensions.
To achieve this, we start by fixing a predetermined, small standard deviation value along the x,
y, and  dimensions. Denote these standard deviation values x ; y ;  respectively, (typically
x = y ). The first odometric reading is assigned to bucket 0 and the mean of this bucket is
set to be the value of this reading. Through the rest of the process the subsequent odometric
readings are examined. If the next reading is within 1:5 standard deviations along each of the
three dimensions from the mean of some existing non-empty bucket, add it to the bucket and
189

fiShatkay & Kaelbling

< 2, 94, 92 >
< -4, 102, 91 >

<1994, 0, 88 >
< 1998, -5, 90 >

< 3, -93, 86 >
< -2, -106, 91 >

< -1999, -1, 94 >
< -2003, 7, 87 >

1:

2:

3:

4:

<-1, 98, 91.5>

<1996, -2.5, 89>

<0.5, -99.5, 88.5>

<-2001, 3, 90.5>

3

4

1

2

Figure 9: The bucket assignment of the example sequence.
update the bucket mean accordingly. If not, assign it to an empty bucket and set the mean of
the bucket to be this reading.
Intuitively, by using this heuristic each of the resulting buckets is tightly concentrated about
its mean. We note that other clustering algorithms (Duda & Hart, 1973) could be used at the
bucketing stage.
Example 5.1 We would like to learn a 4-state model from a sequence of odometric readings,
hx; y; i as follows:
h2 94 92i; h1994 0 88i; h3 , 93 86i; h,1999 1 94i;
h,4 102 91i; h1998 , 5 90i; h,2 , 106 91i; h,2003 7 87i :
As a first stage we place these readings into buckets. Suppose the standard deviation constant is
20. The placement is as shown in Figure 9. The mean value associated with each bucket is shown
as well.
2
The next stage of the algorithm is the state-tagging phase, in which each odometric reading,
rt , is assigned a pair of states, si; sj , denoting the origin state (from which the transition took
place) and the destination state (to which the transition led), respectively. In conjunction, the
mean entries, ij , of the relation matrix, R, are populated.

Example 5.1 (cont.) Returning to the sequence above, the process is demonstrated in Figure 10. We assume that the data recording starts at state 0, and that the odometric change
through self transitions is 0, with some small standard deviation (we use 20 here as well). This
is shown on part A of the figure.
Since the first element in the sequence, h2 94 92i, is more than two standard deviations away
from the mean [0][0] and no other entry in the relation row of state 0 is populated, we pick 1
as the next state and populate the mean [0][1] to be the same as the mean of bucket 1, to which
h2 94 92i belongs. To maintain geometrical consistency the mean [1][0] is set to ,[0][1], as
shown in part B of the figure. We now have populated 2 off-diagonal entries, and the state
sequence is h0; 1i. The entry [0][1] in the matrix becomes associated with bucket 1, and this
information is recorded for helping with tagging future odometric readings belonging to the same
bucket.
The next odometric reading, h1994 0 88i, is a few standard deviations from any populated mean
in row 1 (where 1 is the current believed state). Hence, we pick a new state 2, and set the mean
[1][2] to be 2|the mean of bucket 2|to which the reading belongs (Figure 10 C). The entry
[1][2] is recorded as associated with bucket 2. To preserve anti-symmetry and additivity, [2][1]
is set to ,[1][2]. [0][2] is set to be the sum [0][1] + [1][2], and [2][0] is set to ,[0][2].
190

fiLearning Geometrically-Constrained HMMs
A
0
0

1

B
2

3

0

<0,0,0>

1

0
1

<0,0,0>

<0,0,0>

2

2

3

<-1,
<0,0,0> 98,
91.5>
< 1,
-98,
-91.5>

<0,0,0>

<0,0,0>

2
3

<0,0,0>

3

1

<0,0,0>

S: 0

S: 0. 1
Bucket(R[0][1]) = 1

C
0
0
1
2

1

D
2

3

0

<-1,
<1995,
95.5,
<0,0,0> 98,
91.5> -179.5>
<1996,
< 1,
-98,
<0,0,0> -2.5,
-91.5>
89>

0
1

<-1995, <-1996,
-95.5,
2.5,
<0,0,0>
179.5> -89>

3

2
3

<0,0,0>

S: 0, 1, 2

1

2

3

<-1,
<1995, <1995.5,
95.5,
-4,
<0,0,0> 98,
91.5> -179.5> -91>
<1996, <1996.5,
< 1,
-98,
-102,
<0,0,0> -2.5,
-91.5>
89>
177.5>
<-1995, <-1996,
< 0.5,
-95.5,
2.5,
<0,0,0> -99.5,
179.5> -89>
88.5>
<-1995.5, <-1996.5, <-0.5,
99.5, <0,0,0>
4,
102,
-177.5> -88.5>
91>

S: 0,1,2,3
Bucket(R[2][3]) = 3

Bucket(R[1][2]) = 2

S: 0,1,2,3,0
Bucket(R[3][0]) = 4
,..., S:0, 1, 2, 3, 0, 1, 2, 3, 0

Figure 10: Populating the odometric relation matrix and creating a state tagging sequence.
Similarly, [2][3] is updated to be the mean of bucket 3, causing the setting of [3][2], [1][3],
[0][3], [3][1], and [3][0]. Bucket 3 is associated with [2][3].
At this stage the odometric table is fully populated, as shown in part D of Figure 10. The state
sequence at this point is: h0; 1; 2; 3i. The next reading, h,1999 ,1 94i, is within one standard
deviation from [3][0] and therefore the next state is 0. Entry [3][0] is associated with bucket 4,
(the bucket to which the reading was assigned), and the state sequence becomes: h0; 1; 2; 3; 0i.
The next reading, being from bucket 1, is associated with the relation from state 0 that is tagged
by bucket 1, namely, state 1. By repeating this for the last two readings, the final state transition
sequence becomes h0; 1; 2; 3; 0; 1; 2; 3; 0i:
2
Note that the process described in the above illustration was simplified. In the general case,
we need to take into account the rotational error in the data, use state-relative coordinate
systems, and therefore populate the entries under the transformed anti-symmetry and additivity
constraints:
 hx;yi(a; b) = ,Tba [hx;yi(b; a)] ;
 hx;yi(a; c) = hx;yi(a; b) + Tba [hx;yi(b; c)],
as defined in Section 3.3.2.
191

fiShatkay & Kaelbling

It is possible that by the end of the tagging algorithm, some rows or columns of the relation
matrix are still unpopulated. This happens when there is too little data to learn from or when
the number of states provided to the algorithm is too large with respect to the actual model. In
such cases we can either \trim" the model, using the number of populated rows as the number
of states, or pick random odometric readings to populate the rest of the table, improving these
estimates later. Note that the first approach suggests a method for learning the number of states
in the model when this is not given, starting from a gross over-estimate of the number, and truncating it to the number of populated rows in the odometric table after initialization is performed.
Once the state-transition sequence is obtained, the rest of the initialization algorithm is the same
as it is for k-means based initialization, deriving state-transition counts from the state-transition
sequence, assigning the observations to the states under the assumption that the state sequence
is correct, and obtaining state-transition and observation probabilities. The initialization phase
does not incur much computational overhead, and is equivalent time-wise to performing one
additional iteration of the em procedure.

6 Experiments and Results

The goal of the work described so far is to use odometry to improve the learning of topological
models, while using fewer iterations and less data. We tested our algorithm in a simple robotnavigation world. Our experiments consist of running the algorithm both on data obtained
from a simulated model and on data gathered by our mobile robot, Ramona. The amount of
data gathered by Ramona is used here as a proof of concept but is not sucient for statistical
analysis. For the latter, we use data obtained from the simulated model. We gathered data and
used the algorithms both with and without the perpendicularity assumption (see Section 3.3.2),
and results are provided from both settings.

6.1 Robot Domain

The robot used in our experiments, Ramona, is a modified RWI B21 robot. It has a cylindrical
synchro-drive base, 24 ultrasonic sensors and 24 infrared sensors, situated evenly around its
circumference. The infrared sensors are used mostly for short-range obstacle avoidance. The
ultrasonic sensors are longer ranged, and are used for obtaining (noisy) observations of the
environment. In the experiments described here, the robot follows a prescribed path through
the corridors in the oce environment of our department. Thus, there is no decision-making
involved, and an hmm is a sucient model, rather than a complete pomdp.
Low-level software6 provides a level of abstraction that allows the robot to move through hallways
from intersection to intersection and to turn ninety degrees to the left or right. The software
uses sonar data to distinguish doors, openings, and intersections along the path, and to stop
the robot's current action whenever such a landmark is detected. Each stop|either due to the
natural termination of an action or due to a landmark detection|is considered by the robot to
be a \state".
At each stop, ultrasonic data interpretation allows the robot to perceive, in each of the three
cardinal directions, (front, left and right), whether there is an open space, a door, a wall, or
something unknown.
Encoders on the robot's wheels allow it to estimate its pose (position and orientation) with respect to its pose at the previous intersection. After recording both the sonar-based observations
6. The low-level software was written and maintained by James Kurien.

192

fiLearning Geometrically-Constrained HMMs
3

5

4

6

7

8
9

2

12
13

10
11

9
8

23

42

6 7
22 20
21

43
0
19

10

5
4

1

3

2 1
41

14 15
16

18
17

24
25

38
36
37

35
34
40

11

26 27

30 31

12

0
16

15

14

29
28

39

33
32

13

Figure 11: True model of the corridors Ramona traversed. Arrows represent the prescribed path direction.

Figure 12: True model of a prescribed path
through the simulated hallway environment.

and the odometric information, the robot goes on to execute the next prescribed action. The
action command is issued manually by a human operator. Of course, both the action performance and the perception routines are subject to error. The path Ramona followed consists of
4 connected corridors in our building, which include 17 states, as shown in Figure 11.
In our simulation, we manually generated an hmm representing a prescribed path of the robot
through the complete oce environment of our department, consisting of 44 states, and the
associated transition, observation, and odometric distributions. The transition probabilities
reect an action failure rate of about 5 , 10%. That is, the probability of moving from the
current state to the correct next state in the environment, under the predetermined action is
between 0:85 and 0:95. The probability of self transition is typically between 0:05 and 0:15.
Some small probability (typically smaller than 0:02) is sometimes assigned to other transitions.
Our experience with the real robot proves that this is a reasonable transition model, since
typically the robot moves to the next state correctly, and the only error that occurs with some
significant frequency is when it does not move at all, due to sonar interpretation indicating a
barrier when there is actually none. Once the action command is repeated the robot usually
performs the action correctly, moving to the expected next state. The observation distribution
typically assigns probabilities of 0:85 , 0:95 to the true observation that should be perceived
by the robot at each state, and probabilities of 0:05 , 0:15 to other observations that might be
perceived. For example, if a door should actually be perceived, a door is typically assigned a
probability of 0:85,0:9, a wall is assigned a probability of 0:09,0:1 and an open space is assigned
a probability of about 0:01 to be perceived. The standard deviation around odometric readings
is about 5% of the mean.
Figure 12 shows the hmm corresponding to the simulated hallway environment. Observations
and orientation are omitted from the figure for clarity. Nodes correspond to states in the
environment, while directed edges correspond to the corridors; the arrows point at the direction
in which the corridors were traversed. Further interpretation of the figures is provided in the
following section.
193

fiShatkay & Kaelbling

6.2 Evaluation Method

There are a number of different ways of evaluating the results of a model-learning algorithm.
None are completely satisfactory, but they all give some insight into the utility of the results.
In this domain, there are transitions and observations that usually take place, and are therefore
more likely than the others. Furthermore, the relational information gives us a rough estimate
of the metric locations of the states. To get a qualitative sense of the plausibility of a learnt
model, we can extract an essential map from the learnt model, consisting of the states, the
most likely transitions and the metric measures associated with them, and ask whether this map
corresponds to the essential map underlying the true world.
Figures 11 and 12 are such essential versions of the true models, while Figures 15 and 17, shown
later, are essential versions of representative learnt ones (obtained from sequences gathered
under the perpendicularity assumption). Black dots represent the physical locations of states,
and each state is assigned a unique number. Multiple state numbers associated with a single
location typically correspond to different orientations of the robot at that location. The larger
black circle represents the initial state. Solid arrows represent the most likely non-self transitions
between the states. Dashed arrows represent the other transitions when their probability is 0:2
or higher. Typically, due to the predetermined path we have taken, the connectivity of the
modeled environment is low, and therefore the transitions represented by dashed arrows are
almost as likely as the most likely ones. Note that the length of the arrows, within each plot, is
significant and represents the length of the corridors, drawn to scale.
It is important to note that the figures do not provide a complete representation of the models.
First, they lack observation and orientation information. We stress the fact that the figures
serve more as a visual aid than as a plot of the true model. We are looking for a good topological
model rather than a geometrical model. The figures provide a geometrical embedding of the
topological model. However, even when the geometry, as described by the relation matrix, is
different, the topology, as described by the transition and observation matrices, can still be valid.
Traditionally, in simulation experiments, the learnt model is quantitatively compared to the
actual model that generated the data. Each of the models induces a probability distribution
on strings of observations; the asymmetric Kullback-Leibler divergence (Kullback & Leibler,
1951) between the two distributions is a measure of how good the learnt model is with respect
to the true model. Given a true probability distribution P = fp1 ; :::; pn g and a learnt one
Q = fq1; :::; qn g, the kl divergence of Q with respect to P is:

D(P jjQ) =

def

n
X
i=1

pi log2 pqi :
i

We report our results in terms of a sampled version of the kl divergence, as described by Juang
and Rabiner (1985). It is based on generating sequences of sucient length (5 sequences of 1000
observations in our case) according to the distribution induced by the true model, and comparing
their log-likelihood according to the learnt model with the true model log-likelihood. The total
difference in log-likelihood is then divided by the total number of observations, accumulated
over all the sequences, giving a number that roughly measures the difference in log-likelihood
per observation. Formally stated, let M1 be the true model and M2 a learnt one. By generating
K sequences S1 ; : : : ; SK , each of length T , from the true model, M1 , the sampled kl-divergence,
Ds is:
K
X
[log(Pr(Si jM1 )) , log(Pr(Si jM2 ))]
i
=1
Ds(M1 jjM2 ) =
:
KT
194

fiLearning Geometrically-Constrained HMMs
1000
1200

500
1000

800

-1500 -1250 -1000 -750

-500

-250

600

-500
400

-1000
200

200

400

600

800

-1500

1000

Figure 13: Sequence gathered by Ramona,
perpendicularity assumed.

Figure 14: Sequence generated by our simulator, perpendicularity assumed.

We ignore the odometric information when applying the kl measure, thus allowing comparison
between purely topological models that are learnt with and without odometry.

6.3 Results within a Global Framework

We let Ramona go around the path depicted in Figure 11 and collect a sequence of about
300 observations, while assuming perpendicularity of the environment, that is, at every turning
point the angle of turn is 90 . Thus at each turn Ramona realigns its odometric readings with
its initial X and Y axes. Figure 13 plots the sequence of metric coordinates, gathered in this
way, while accumulating consecutive odometric readings, projected on hx; yi. We applied the
learning algorithm to the data 30 times. 10 of these runs were started from a k-means-based
initial model, 10 started from a tag-based initial model, and 10 started from a random initial
model. In addition we also ran the standard Baum-Welch algorithm, ignoring the odometric
information, 10 times. (Note that there is non-determinism even when using biased initial
models, since the k-means clustering starts from random seeds, and low7 random noise is added
to the data in all algorithms to avoid numerical instabilities, thus multiple runs give multiple
results). We report here the results obtained using the tag-based method, which is the most
appropriate initialization method in the general case. These results are contrasted with those
obtained when odometric information is not used at all. For a comparison of all four settings
the reader is referred to the complete report of this work (Shatkay, 1999).
Figure 15 shows the essential representations of typical learnt models starting from a tag-based
initial model. The geometry of the learnt model strongly corresponds to that of the true environment, and most of the states' positions were learnt correctly. Although the figure does
not show it, the learnt observation distributions at each state usually match well with the true
observations.
To demonstrate the effect of odometry on the quality of the learnt topological model, we contrast
the plotted models learnt using odometry with a representative topological model learnt without
7. A random number between -1cm and 1cm is added to recorded distances that are typically several meters
long.

195

fiShatkay & Kaelbling
3

4

5

6

3

4

5

6

7

8

7

8

5

9

0

7

9

22

12
8
1
10
10

9
11

16

2

15
3
11
11

13
14

16

11

12

16

12
15

0

14
14

0

mona traversed.

6

4

13

Figure 15: Learnt model of the corridors Ra15

13

Figure 16: The topology of a model learnt
without the use of odometry.

the use of odometric information. Figure 16 shows the topology of a typical model learnt without
the use of odometric information. In this case, the arcs represent only topological relationships,
and their length is not meaningful. The initial state is shown as a bold circle. It is clear that
the topology learnt does not match the characteristic loop topology of the true environment.

For obtaining statistically sucient information, we generated 5 data sequences, each of length
1000, using Monte Carlo sampling from the hidden Markov model whose projection is shown in
Figure 12. One of these sequences is depicted in Figure 14. The figure demonstrates that the
noise model used in the simulation is indeed compatible with the noise pattern associated with
real robot data. We used four different settings of the learning algorithm:

 starting from a biased, tag-based, initial model and using odometric information;
 starting from a biased, k-means-based, initial model and using odometric information;
 starting from an initial model picked uniformly at random, while using odometric information;
 starting from a random initial model without using odometric information (standard BaumWelch).

For each sequence and each of the four algorithmic settings we ran the algorithm 10 times. To
keep the discussion focused, we concentrate here on the first and the last of these settings and
the reader is referred to a more extensive report (Shatkay, 1999) for a complete discussion.
In all the experiments, N was set to be 44, which is the \correct" number of states; for generalization, it will be necessary to use cross-validation or regularization methods to select model
complexity. Section 5 also suggests one possible heuristic for obtaining an estimate of the number
of states.
Figure 17 shows an essential version of one learnt model, obtained from the sequence shown
in Figure 14, using tag-based initialization. We note that the learnt model is not completely
196

fiLearning Geometrically-Constrained HMMs
26
14

15
16 27

13
12

25
33
24
23

7

8

6

22

9
0

32 31 21

5
29 17
18
28

34

2 1
4 3

20
19 30

11
10

35 36

43 42

37
41

38
39

40

Figure 17: Learnt model of the simulated hallway environment.
accurate with respect to the true model. However, there is an obvious correspondence between
groups of states in the learnt and true models, and most of the transitions (as well as the
observations, which are not shown) were learnt correctly. The quality of the geometry of the
learnt model in this simulated large environment varies, and the geometrical results are not as
uniformly good as was the case when learning the smaller environment from real robot data.
As the environment gets large, the global relations between remote states, which are reected
in the geometrical consistency constraints, become harder to learn. Still, the topology of the
learnt model as demonstrated by our statistical experiments is good.
Table 1 lists the kl divergence between the true and learnt model, as well as the number
of runs until convergence was reached, for each of the 5 sequences for both the setting that
uses odometric information under tag-based initialization and the learning algorithm that does
not use odometric information, averaged over 10 runs per sequence. We stress that each kl
divergence measure is calculated based on new data sequences that are generated from the true
model, as described in Section 6.2. The 5 sequences from which the models were learnt do not
participate in the testing process.
The kl divergence with respect to the true model for models learnt using odometry, is about 5-6
times smaller than for models learnt without odometric data. The standard deviation around
the means is about 0.2 for kl distances for models learnt with odometry and 1.5 for the noodometry setting. To check the significance of our results we used the simple two-sample t-test.
The models learnt using odometric information have statistically significantly (p  0:0005) lower
average kl divergence than the others.

Seq. #
With kl
Odo Iter #
No
kl
Odo Iter #

1
0.981
16.70
6.351
124.1

2
1.290
20.90
4.863
126.0

3
1.115
22.30
5.926
113.0

4
1.241
12.70
6.261
107.4

5
1.241
27.50
4.802
122.9

Table 1: Average results of two learning settings with five training sequences.
197

fiShatkay & Kaelbling

In addition, the number of iterations required for convergence when learning using odometric
information is roughly 4-5 times smaller than that required when ignoring such information.
Again, the t-test verifies the significance of this result.
Under all three initialization settings, the models learnt are topologically somewhat inferior (and
this is with high statistical significance), in terms of the kl divergence, to those learnt without
enforcing additivity, reported in earlier papers (Shatkay & Kaelbling, 1997, 1998). This is likely
to be a result of the very strong constraints enforced during the learning process, which prevent
the algorithm from searching better areas of the learning-space, and restrict it to reach poor local
maxima. The geometry looks superior in some cases, but it is not significantly better. However,
there seems to be less variability in the quality of the geometrical models across multiple runs
when additivity is enforced.
While the details of an extensive comparison between the different initialization methods are
beyond the scope of this paper, we point out that our studies of both small and large models
show that when large models and long data sequences are involved, random initialization often
results in lower KL-divergence than the tag-based initialization. This again has to do with the
strong bias of tag-based initialization, which can lead to very peaked models compared with the
less-peaked distributions associated with the true model. Random initialization leads to atter
models. As the KL-divergence strongly penalizes models that are much more peaked than the
true ones, randomly initialized models are often closer, in terms of this measure, to the true
models than the very peaked ones learnt from other initial models. When learning small models,
where sucient training data is available, the tag-based initialization results in models that are
clearly superior to the random ones. Again, the reader is referred to the complete report of this
work (Shatkay, 1999) for a comparative study of all initialization methods under the various
settings.

6.4 Results within a Relative Framework

We applied the algorithm described in Section 4.3, extended to accommodate the state-relative
constraints (as listed in Section 3.3.2). The data used was gathered by the robot from the
same environment, and generated from the same simulated model as before (Figures 11, 12).
However, here the data is generated without assuming perpendicularity. This means that the x
and y coordinates are not realigned after each turn with the global x and y axes, but rather,
recorded \as-is." The evaluation methods stay as described above.
Figure 18 shows the projection of the odometric readings that Ramona recorded along the
x and y dimensions, while traversing this environment. For obtaining statistically sucient
information, we generated 5 data sequences, each of length 800, using Monte Carlo sampling
from the hidden Markov model whose projection is shown in Figure 12. One of these sequences
is depicted in Figure 19.
Figure 20 shows a typical model obtained by applying the algorithm enforcing the complete
geometrical consistency, to the robot data shown in Figure 18, using tag-based initialization.
We note that the rectangular geometry of the environment is preserved, although state 0 does
not participate in the loop. This is explained by observing the corresponding area of the true
environment as depicted in Figure 11, consisting of the 4 states clustered at the bottom left
corner (0, 14, 15 and 16). Due to the relatively large number of states that are close together in
that area of the true environment, it was not recognized that we ever returned particularly to
state 0 during the loop. Therefore, there was only one transition recorded from state 0 to state
198

fiLearning Geometrically-Constrained HMMs
3000

1500

2500

1000

2000

500

1500

-1500

-1000

-500

500

1000

-500

500

-1000

-1500

-2500 -2000 -1500 -1000 -500

500

1000

Figure 18: Sequence gathered by Ramona, no

Figure 19: Sequence generated by our simula-

perpendicularity assumed.

tor, no perpendicularity assumed.
15

14

16

1
13

12

2

11

3
4
0

5

10

6
7
9

8

Figure 20: Learnt model of the corridors Ramona traversed. Initialization is tag-based.
1 according to the expected transition counts calculated by the algorithm. When projecting the
angles to maintain additivity, (as described in Section 4.3.2), the angle from state 0 to 1 was
therefore compromised, allowing geometrical consistency to maintain the rectangular geometry
among the more regularly visited states.
For the purpose of quantitatively evaluating the learning algorithm we list in Table 2 the kl
divergence between the true and learnt model, as well as the number of iterations until convergence was reached, for each of the 5 simulation sequences with/without odometric information,
averaged over 10 runs per sequence. The table demonstrates that the kl divergence with respect to the true model for models learnt using odometric data, is about 8 times smaller than
for models learnt without it. To check the significance of our results we again use the simple
two-sample t-test. The models learnt using odometric information have highly statistically significantly (p  0:0005) lower average kl divergence than the others. In addition, the number of
199

fiShatkay & Kaelbling

Seq. #
With kl
Odo Iter #
No
kl
Odo Iter #

1
2
3
4
5
1.46 1.18 1.20 1.02 1.22
11.8 36.8 30.7 24.6 33.3
6.91 9.93 10.03 9.54 12.43
113.3 113.1 102.0 104.2 112.5

Table 2: Average results of 2 learning settings with 5 training sequences.
iterations required for convergence when learning using odometric information is smaller than
required when ignoring such information. Again, the t-test verifies the significance (p < 0:005)
of this result.
It is important to point out that the number of iterations, although much lower, does not automatically imply that our algorithm runs in less time than the non-odometric Baum-Welch. The
major bottleneck is caused by the need to compute within the forward-backward calculations,
as described in Section 4.2.1, the values of the normal and the von-Mises densities. These require the calculation of exponent terms rather than simple multiplications, slowing down each
iteration, under the current nave implementation. However, we can solve this by augmenting
the program with look-up tables for obtaining the relevant values rather than calculating them.
In addition, we can take advantage of the symmetry in the relations table to cut down on the
amount of calculation required. It is also possible to use the fact that many odometric relations remain unchanged (particularly in the later iterations of the algorithm) from one iteration
to the next, and therefore values can be cached and shared between iterations rather than be
recalculated at each iteration.

6.5 Reducing the Amount of Data
Learning hmms obviously requires visiting states and transitioning between them multiple times,
to gather sucient data for robust statistical estimation. Intuitively, exploiting odometric data
can help reduce the number of visits needed for obtaining a reliable model.
To examine the inuence of reduction in the length of data sequences on the quality of the learnt
models, we took one of the 5 sequences and used its prefixes of length 100 to 800 (the complete
sequence), in increments of 100, as training sequences. We ran the two algorithmic settings over
each of the 8 prefix sequences, 10 times repeatedly. We then used the kl-divergence as described
above to evaluate each of the resulting models with respect to the true model. For each prefix
length we averaged the kl-divergence over the 10 runs.
The plot in Figure 21 depicts the average kl-divergence as a function of the sequence length for
each of the two settings. It demonstrates that, in terms of the kl divergence, our algorithm,
which uses odometric information, is robust in the face of data reduction, (down to 200 data
points). In contrast, learning without the use of odometry quickly deteriorates as the amount
of data is reduced.
We note that the data sequence is twice as \wide" when odometry is used than when it is
not; that is, there is more information in each element of the sequence when odometry data is
recorded. However, the effort of recording this additional odometric information is negligible,
and is well rewarded by the fact that fewer observations and less exploration are required for
obtaining a data sequence sucient for adequate learning.
200

fiLearning Geometrically-Constrained HMMs
50

40

30

No Odometry

KL
20

10
Odometry Used
0

200

400
Seq. Length

600

800

Figure 21: Average kl divergence as a function of sequence length.

7 Conclusions
Odometric information, which is often readily available in the robotics domain, makes it possible
to learn hidden Markov models eciently and effectively, while using shorter training sequences.
More importantly, in contrast to the traditional perception of viewing the topological and the
geometric models as two distinct types of entities, we have shown that the odometric information
can be directly incorporated into the traditional topological hmm model, while maintaining
convergence of the reestimation algorithm to a local maximum of the likelihood function.
Our method uses the odometric information in two ways. We first choose an initial model,
based on the odometric information. An iterative procedure, which extends the Baum-Welch
algorithm, is then used to learn the topological model of the environment while learning an
additional set of constrained geometric parameters. The additional set of constrained parameters constitutes an extension to the basic hmm/pomdp model of transitions and observations.
Even though we are primarily interested in the underlying topological model (transition and
observation probabilities), our experiments demonstrate that the use of odometric relations can
reduce the number of iterations and the amount of data required by the algorithm, and improve
the resulting model.
The initialization procedure and the enforcement of the additivity constraint over relatively
small models prove helpful both topologically and geometrically. An extensive study (Shatkay,
1999) shows that for long data sequences, generated from large models, enforcing only antisymmetry rather than additivity, leads to better topological models. This is because in these
cases, initialization is not always good, and additivity may over-constrain the learning to an
unfavorable area. Learning large models may benefit from enforcing only anti-symmetry during
the first few iterations, and complete additivity in later iterations. Alternatively, we may use our
algorithm, enforcing additivity, to learn separate models for small portions of the environment,
combining them later into one complete model. A similar idea of combining small modelfragments into a complete map of an environments was applied, in the context of geometrical
maps, in recent work by Leonard and Feder (2000).
201

fiShatkay & Kaelbling

The work presented here demonstrates how domain-specific information and constraints can be
enforced as part of the statistical estimation process, resulting in better models, while requiring
shorter data sequences. We strongly believe that this idea can be applied in domains other than
robotics. In particular, the acquisition of hmms for use in molecular biology may greatly benefit
from exploiting geometrical (and other) constraints on molecular structures. Similarly, temporal
constraints may be exploited in domains in which pomdps are appropriate for decision-support,
such as air-trac control and medicine.

Acknowledgments
We thank Sebastian Thrun for his insightful comments throughout this work, John Hughes and Luis Ortiz
for their helpful advice, Anthony Cassandra for his code for generating random distributions, Bill Smart
for sustaining Ramona and Jim Kurien for providing the low level code for driving her. The presentation
in this paper has benefited from the comments made by the anonymous referees to whom we are grateful.
This work was done while both authors were at the Computer Science department at Brown University,
and was supported by DARPA/Rome Labs Planning Initiative grant F30602-95-1-0020, by NSF grants
IRI-9453383 and IRI-9312395, and by the Brown University Graduate Research Fellowship.

202

fiLearning Geometrically-Constrained HMMs

Appendix A. An Overview of the Odometric Learning Algorithm
The algorithm takes as input an experience sequence E = hr; V i, consisting of the odometric
sequence r and the observation sequence V , as defined in the beginning of Section 4.2. The
number of states is also assumed to be given.
Learn Odometric HMM(E)
1 Initialize matrices A; B; R
(See Section 5)
2 max change 1
3 while ( max change > )
4 do Calculate Forward probabilities, ff
(Equation 4)
5
Calculate Backward probabilities, fi
(Equation 5)
6
Calculate state-occupation probabilities,  (Equation 6)
7
Calculate State-transition probabilities, ; (Equation 7)
8
Old A A; Old B B
9
A Reestimate (A)
(Equation 8, left)
10
B Reestimate (B )
(Equation 8, right)
11
R Reestimate (R )
(Equations 12 and 13)
x
y
x
y
12
hR ; R i Reestimate(R ; R ) (Equations 10 and 11)
13
max change MAX(Get Max Change(A; Old A );
Get Max Change(B; Old B ))
The equations referenced in Step 12 correspond to updates under the perpendicularity assumption, where a global framework is used. See (Shatkay, 1999) for update formulae within a
state-relative framework.
If additivity is enforced, step 11 is followed by a projection of the reestimated R onto an additive
ane space, as described in Section 4.3.2. In addition, step 12 is substituted by the procedure
described in Section 4.3.1. The reader is referred again to (Shatkay, 1999) for further detail.
Get Max Change is a function that takes two matrices and returns the maximal element-wise
absolute difference between them.  is a constant set to denote the margin of error on changes
in parameters. When the change in parameters is \small enough", the model is regarded as
\unchanged".

203

fiShatkay & Kaelbling

References
Abe, N., & Warmuth, M. K. (1992). On the computational complexity of approximating distributions by probabilistic automata. Machine Learning, 9 (2), 205{260.
Angluin, D. (1987). Learning regular sets from queries and counterexamples. Information and
Computation, 75, 87{106.
Asada, M. (1991). Map building for a mobile robot from sensory data. In Iyengar, S. S., &
Elfes, A. (Eds.), Autonomous Mobile Robots, pp. 312{322. IEEE Computer Society Press.
Bartels, R. (1984). Estimation in a bidirectional mixture of von Mises distributions. Biometrics,
40, 777{784.
Basye, K., Dean, T., & Kaelbling, L. P. (1995). Learning dynamics: System identification for
perceptually challenged agents. Artificial Intelligence, 72 (1).
Baum, L. E., Petrie, T., Soules, G., & Weiss, N. (1970). A maximization technique occurring
in the statistical analysis of probabilistic functions of Markov chains. The Annals of
Mathematical Statistics, 41 (1), 164{171.
Cassandra, A. R., Kaelbling, L. P., & Kurien, J. A. (1996). Acting under uncertainty: Discrete
Bayesian models for mobile-robot navigation. In Proceedings of IEEE/RSJ International
Conference on Intelligent Robots and Systems.
DeGroot, M. H. (1986). Probability and Statistics (2nd edition). Addison-Wesley.
Dempster, A. P., Laird, N. M., & Rubin, D. B. (1977). Maximum likelihood from incomplete
data via the EM algorithm. Journal of the Royal Statistical Society, 39 (1), 1{38.
Dissanayake, G., Newman, P., Clark, S., Durrant-Whyte, H. F., & Csorba, M. (2001). A solution
to the simultaneous localization and map building (SLAM) problem. IEEE Transactions
on Robotics and Automation, 17 (3).
Duda, R. O., & Hart, P. E. (1973). Unsupervised Learning and Clustering, chap. 6. John Wiley
and Sons.
Elfes, A. (1989). Using occupancy grids for mobile robot perception and navigation. Computer,
Special Issue on Autonomous Intelligent Machines, 22 (6), 46{57.
Engelson, S. P., & McDermott, D. V. (1992). Error correction in mobile robot map learning.
In Proceedings of the IEEE International Conference on Robotics and Automation, pp.
2555{2560, Nice, France.
Gold, E. M. (1978). Complexity of automaton identification from given data. Information and
Control, 37, 302{320.
Gumbel, E. G., Greenwood, J. A., & Durand, D. (1953). The circular normal distribution:
Theory and tables. American Statistical Society Journal, 48, 131{152.
Hopcroft, J. E., & Ullman, J. D. (1979). Introduction to Automata Theory, Languages, and
Computation. Addison & Wesley.
204

fiLearning Geometrically-Constrained HMMs

Juang, B. H. (1985). Maximum likelihood estimation for mixture multivariate stochastic observations of Markov chains. AT&T Technical Journal, 64 (6).
Juang, B. H., & Rabiner, L. R. (1985). A probabilistic distance measure for hidden Markov
models. AT&T Technical Journal, 64 (2), 391{408.
Koenig, S., & Simmons, R. G. (1996a). Passive distance learning for robot navigation. In
Proceedings of the Thirteenth International Conference on Machine Learning, pp. 266{
274.
Koenig, S., & Simmons, R. G. (1996b). Unsupervised learning of probabilistic models for robot
navigation. In Proceedings of the IEEE International Conference on Robotics and Automation.
Kuipers, B., & Byun, Y.-T. (1991). A robot exploration and mapping strategy based on a semantic hierarchy of spatial representations. Journal of Robotics and Autonomous Systems,
8, 47{63.
Kullback, S., & Leibler, R. A. (1951). On information and suciency. Annals of Mathematical
Statistics, 22 (1), 79{86.
Leonard, J., Durrant-Whyte, H. F., & Cox, I. J. (1991). Dynamic map building for an autonomous mobile robot. In Iyengar, S. S., & Elfes, A. (Eds.), Autonomous Mobile Robots,
pp. 331{338. IEEE Computer Society Press.
Leonard, J. J., & Feder, H. J. S. (2000). A computationally ecient method for large-scale concurrent mapping and localization. In Hollerbach, J., & Kodischek, D. (Eds.), Proceedings
of the Ninth International Symposium on Robotics Research.
Liporace, L. A. (1982). Maximum likelihood estimation for multivariate observations of Markov
sources. IEEE Transactions on Information Theory, 28 (5).
Mardia, K. V. (1972). Statistics of Directional Data. Academic Press.
Mataric, M. J. (1990). A distributed model for mobile robot environment-learning and navigation. Master's thesis, MIT, Artificial Intelligence Laboratory.
McLachlan, G. J., & Krishnan, T. (1997). The EM Algorithm and Extensions. John Wiley &
Sons.
Moravec, H. P. (1988). Sensor fusion in certainty grids for mobile robots. AI Magazine, 9 (2),
61{74.
Moravec, H. P., & Elfes, A. (1985). High resolution maps from wide angle sonar. In Proceedings
of the International Conference on Robotics and Automation, pp. 116{121.
Nourbakhsh, I., Powers, R., & Birchfield, S. (1995). Dervish: An oce-navigating robot. AI
Magazine, 16 (1), 53{60.
Pierce, D., & Kuipers, B. (1997). Map learning with uninterpreted sensors and effectors. Artificial Intelligence, 92 (1-2), 169{227.
205

fiShatkay & Kaelbling

Rabiner, L. R. (1989). A tutorial on hidden Markov models and selected applications in speech
recognition. Proceedings of the IEEE, 77 (2), 257{285.
Rivest, R. L., & Schapire, R. E. (1987). Diversity based inference of finite automata. In
Proceedings of the IEEE Twenty Eighth Annual Symposium on Foundations of Computer
Science, pp. 78{87, Los Angeles, California.
Rivest, R. L., & Schapire, R. E. (1989). Inference of finite automata using homing sequences. In
Proceedings of the Twenty First Annual Symposium on Theory of Computing, pp. 411{420,
Seattle, Washington.
Ron, D., Singer, Y., & Tishbi, N. (1994). Learning probabilistic automata with variable memory length. In Proceedings of the Seventh Annual Workshop on Computational Learning
Theory, pp. 35{46.
Ron, D., Singer, Y., & Tishbi, N. (1995). On the learnability and usage of acyclic probabilistic
finite automata. In Proceedings of the Eighth Annual Workshop on Computational Learning
Theory, pp. 31{40.
Ron, D., Singer, Y., & Tishby, N. (1998). On the learnability and usage of acyclic probabilistic
finite automata. Journal of Computer and Systems Science, 56 (2).
Shatkay, H. (1999). Learning Models for Robot Navigation. Ph.D. thesis, Department of Computer Science, Brown University, Providence, RI.
Shatkay, H., & Kaelbling, L. P. (1997). Learning topological maps with weak local odometric
information. In Proceedings of the Fifteenth International Joint Conference on Artificial
Intelligence, Nagoya, Japan.
Shatkay, H., & Kaelbling, L. P. (1998). Heading in the right direction. In Proceedings of the
Fifteenth International Conference on Machine Learning, Madison, Wisconsin.
Simmons, R. G., & Koenig, S. (1995). Probabilistic navigation in partially observable environments. In Proceedings of the International Joint Conference on Artificial Intelligence.
Smith, R., Self, M., & Cheeseman, P. (1991). A stochastic map for uncertain spatial relationships. In Iyengar, S. S., & Elfes, A. (Eds.), Autonomous Mobile Robots, pp. 323{330. IEEE
Computer Society Press.
Thrun, S. (1999). Learning metric-topological maps for indoor mobile robot navigation. AI
Journal, 1, 21{71.
Thrun, S., & Bucken, A. (1996a). Integrating grid-based and topological maps for mobile robot
navigation. In Proceedings of the Thirteenth National Conference on Artificial Intelligence,
pp. 944{950.
Thrun, S., & Bucken, A. (1996b). Learning maps for indoor mobile robot navigation. Tech. rep.
CMU-CS-96-121, School of Computer Science, Carnegie Mellon University, Pittsburgh,
PA.
Thrun, S., Burgard, W., & Fox, D. (1998a). A probabilistic approach to concurrent map acquisition and localization for mobile robots. Machine Learning, 31, 29{53.
206

fiLearning Geometrically-Constrained HMMs

Thrun, S., Gutmann, J.-S., Fox, D., Burgard, W., & Kuipers, B. J. (1998b). Integrating topological and metric maps for mobile robot navigation: A statistical approach. In Proceedings
of the Fifteenth National Conference on Artificial Intelligence, pp. 989{995.
Vapnik, V. N. (1995). The Nature of Statistical Learning Theory. Springer.

207

fiJournal of Artificial Intelligence Research 16 (2002) 389-423

Submitted 2/02; published 6/02

The Communicative Multiagent Team Decision Problem:
Analyzing Teamwork Theories and Models

David V. Pynadath
Milind Tambe

Information Sciences Institute and Computer Science Department

pynadath@isi.edu
tambe@usc.edu

University of Southern California
4676 Admiralty Way, Marina del Rey, CA 90292 USA

Abstract

Despite the significant progress in multiagent teamwork, existing research does not address the optimality of its prescriptions nor the complexity of the teamwork problem. Without a characterization of the optimality-complexity tradeoffs, it is impossible to determine
whether the assumptions and approximations made by a particular theory gain enough
eciency to justify the losses in overall performance. To provide a tool for use by multiagent researchers in evaluating this tradeoff, we present a unified framework, the COMmunicative Multiagent Team Decision Problem (COM-MTDP). The COM-MTDP model
combines and extends existing multiagent theories, such as decentralized partially observable Markov decision processes and economic team theory. In addition to their generality
of representation, COM-MTDPs also support the analysis of both the optimality of team
performance and the computational complexity of the agents' decision problem. In analyzing complexity, we present a breakdown of the computational complexity of constructing
optimal teams under various classes of problem domains, along the dimensions of observability and communication cost. In analyzing optimality, we exploit the COM-MTDP's
ability to encode existing teamwork theories and models to encode two instantiations of
joint intentions theory taken from the literature. Furthermore, the COM-MTDP model
provides a basis for the development of novel team coordination algorithms. We derive a
domain-independent criterion for optimal communication and provide a comparative analysis of the two joint intentions instantiations with respect to this optimal policy. We have
implemented a reusable, domain-independent software package based on COM-MTDPs to
analyze teamwork coordination strategies, and we demonstrate its use by encoding and
evaluating the two joint intentions strategies within an example domain.
1. Introduction

A central challenge in the control and coordination of distributed agents is enabling them
to work together, as a team, toward a common goal. Such teamwork is critical in a vast
range of domains|for future teams of orbiting spacecraft, sensors for tracking targets, unmanned vehicles for urban battlefields, software agents for assisting organizations in rapid
crisis response, etc. Research in teamwork theory has built the foundations for successful
practical agent team implementations in such domains. On the forefront are theories based
on belief-desire-intentions (BDI) frameworks, such as joint intentions (Cohen & Levesque,
1991b, 1991a; Levesque, Cohen, & Nunes, 1990), SharedPlans (Grosz, 1996; Grosz & Kraus,
1996; Grosz & Sidner, 1990), and others (Sonenberg, Tidhar, Werner, Kinny, Ljungberg,
& Rao, 1994; Dunin-Keplicz & Verbrugge, 1996), that have provided prescriptions for coc 2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiPynadath & Tambe

ordination in practical systems. These theories have inspired the construction of practical, domain-independent teamwork models and architectures (Jennings, 1995; Pynadath,
Tambe, Chauvat, & Cavedon, 1999; Rich & Sidner, 1997; Tambe, 1997; Yen, Yin, Ioerger,
Miller, Xu, & Volz, 2001), successfully applied in a range of complex domains.
Yet, two key shortcomings limit the scalability of these BDI-based theories and implementations. First, there are no techniques for the quantitative evaluation of the degree of
optimality of their coordination behavior. While optimal teamwork may be impractical in
real-world domains, such analysis would aid us in comparison of different theories/models
and in identifying feasible improvements. One key reason for the diculty in quantitative
evaluation of most existing teamwork theories is that they ignore the various uncertainties and costs in real-world environments. For instance, joint intentions theory (Cohen &
Levesque, 1991b) prescribes that team members attain mutual beliefs in key circumstances,
but it ignores the cost of attaining mutual belief (e.g., via communication). Implementations that blindly follow such prescriptions could engage in highly suboptimal coordination.
On the other hand, practical systems have addressed costs and uncertainties of real-world
environments. For instance, STEAM (Tambe, 1997; Tambe & Zhang, 1998) extends joint
intentions with decision-theoretic communication selectivity. Unfortunately, the very pragmatism of such approaches often necessarily leads to a lack of theoretical rigor, so it remains
unanswered whether STEAM's selectivity is the best an agent can do, or whether it is even
necessary at all. The second key shortcoming of existing teamwork research is the lack
of a characterization of the computational complexity of various aspects of teamwork decisions. Understanding the computational advantages of a practical coordination prescription
could potentially justify the use of that prescription as an approximation to optimality in
particular domains.
To address these shortcomings, we propose a new complementary framework, the COMmunicative Multiagent Team Decision Problem (COM-MTDP), inspired by work in economic team theory (Marschak & Radner, 1971; Yoshikawa, 1978; Ho, 1980). While our
COM-MTDP model borrows from a theory developed in another field, we make several
contributions in applying and extending the original theory, most notably adding explicit
models of communication and system dynamics. With these extensions, the COM-MTDP
generalizes other recently developed multiagent decision frameworks, such as decentralized
POMDPs (Bernstein, Zilberstein, & Immerman, 2000).
Our definition of a team (like that in economic team theory) assumes only that team
members have a common goal and that they work selessly towards that goal (i.e., they
have no other private goals of their own). In terms of our decision-theoretic framework, we
assume that all of the team members share the same joint utility function|that is, each
team member's individual preferences are exactly the preferences of the other members and,
thus, of the team as a whole. Our definition may appear to be a \bare-bones" definition of
a team, since it does not include common concepts and assumptions from the literature on
what constitutes a team (e.g., the teammates form a joint commitment (Cohen & Levesque,
1991b), attain mutual belief upon termination of a joint goal, intend that teammates succeed in their tasks (Grosz & Kraus, 1996), etc.). From our COM-MTDP perspective, we
view these concepts as more intermediate concepts, as the means by which agents improve
their team's overall performance, rather than ends in themselves. Our hypothesis in this
investigation is that our COM-MTDP-based analysis can provide concrete justifications for
390

fiThe Communicative Multiagent Team Decision Problem

these concepts. For example, while mutual belief has no inherent value, our COM-MTDP
model can quantify the improved performance that we would expect from a team that
attains mutual belief about important aspects of its execution.
More generally, this paper demonstrates three new types of teamwork analyses made
possible by the COM-MTDP model. First, we analyze the computational complexity of
teamwork within subclasses of problem domains. For instance, some researchers have advocated teamwork without communication (Goldberg & Mataric, 1997). We use the COMMTDP model to show that, in general, the problem of constructing optimal teams without
communication is NEXP-complete, but allowing free communication reduces the problem
to be PSPACE-complete. This paper presents a breakdown of the complexity of optimal
teamwork over problem domains classified along the dimensions of observability and communication cost.
Second, the COM-MTDP model provides a powerful tool for comparing the optimality
of different coordination prescriptions across classes of domains. Indeed, we illustrate that
we can encode existing team coordination strategies within a COM-MTDP for evaluation.
For our analysis, we selected two joint intentions-based approaches from the literature: one
using the approach realized within GRATE* and the joint responsibility model (Jennings,
1995), and another based on STEAM (Tambe, 1997). Through this encoding, we derive the
conditions under which these team coordination strategies generate optimal team behavior,
and the complexity of the decision problems addressed by them. Furthermore, we also
derive a novel team coordination algorithm that outperforms these existing strategies in
optimality, though not in eciency. The end result is a well-grounded characterization of
the complexity-optimality tradeoff among various means of team coordination.
Third, we can use the COM-MTDP model to empirically analyze a specific domain of
interest. We have implemented reusable, domain-independent algorithms that allow one to
evaluate the optimality of the behavior generated by different prescriptive policies within a
problem domain represented as a COM-MTDP. We apply these algorithms in an example
domain to empirically evaluate the aforementioned team coordination strategies, characterizing the optimality of each strategy as a function of the properties of the underlying
domain. For instance, Jennings reports experimental results (Jennings, 1995) indicating
that his joint responsibility teamwork model leads to lower waste of community effort than
competing methods of accomplishing teamwork. With our COM-MTDP model, we were
able to demonstrate the benefits of Jennings' approach under many configurations of our example domain. However, in precisely characterizing the types of domains that showed such
benefits, we also identified domains where these competing methods may actually perform
better. In addition, we can use our COM-MTDP model to re-create and explain previous
work that noted an instance of suboptimality in a STEAM-based, real-world implementation (Tambe, 1997). While this previous work treated that suboptimality as anomalous, our
COM-MTDP re-evaluation of the domain demonstrated that the observed suboptimality
was a symptom of STEAM's general propensity towards extraneous communication in a
significant range of domain types. Both the algorithms and the example domain model are
available for public use in an Online Appendix 1.
Section 2 presents the COM-MTDP model's representation and places it in the context
of related multiagent models from the literature. Section 3 uses the COM-MTDP model to
define and characterize the complexity of designing optimal agent teams. Section 4 analyzes
391

fiPynadath & Tambe

the optimality of existing team coordination algorithms and derives a novel coordination
algorithm. Section 5 presents empirical results from applying our COM-MTDP algorithms
to an example domain. Section 6 summarizes our results, and Section 7 identifies some
promising future directions.
2. The COM-MTDP Model

This section defines and describes the COM-MTDP model itself and its ability to represent
the important aspects of multiagent teamwork. We begin in Section 2.1 by defining the
underlying multiagent team decision problem with no explicit communication. Section 2.2
defines the complete COM-MTDP model with its extension to explicitly represent communication. Section 2.3 provides an illustration of how the COM-MTDP model represents the
execution of a team of agents. Finally, Section 2.4 describes related models of multiagent
coordination and shows how the COM-MTDP model generalizes them.
2.1 Multiagent Team Decision Problems
Given a team of seless agents, ff, who intend to perform some joint task, we wish to evaluate
possible policies of behavior. We represent a multiagent team decision problem (MTDP)
model as a tuple, hS; Aff; P; 
ff ; Off ; Bff ; Ri. We have taken the underlying components of
this model from the initial team decision model (Ho, 1980), but we have extended them to
handle dynamic decisions over time and to more easily represent multiagent domains (in
particular, agent beliefs). We assume that the model is common knowledge to all of the
team members. In other words, all of the agents believe the same model, and they believe
that they all believe the same model, etc.
2.1.1 World States:

S

 S = 1      m: a set of world states, expressed as a factored representation (a

cross product of separate features).
The state of the world here is the state of the team's environment (e.g., terrain, location of
enemy). Thus, each i represents the domain of an individual feature of that environment,
while S represents the domain of all possible combinations of values over the individual
features.
2.1.2 Domain-Level Actions:

Aff

fAi gi2ff is a set of actions for each agent to perform to change its environment, implicitly
defining a set of combined actions, Aff  Qi2ff Ai (corresponding to team theory's decision
variables).
Extension to Dynamic Problem: P The original team decision problem focused on
a one-shot, static problem. We extend the original concept so that each component is a
time series of random variables. The effects of domain-level actions (e.g., a ying action
changes a helicopter's position) obey a probabilistic distribution, given by a function P :
S  Aff  S ! [0; 1]. In other words, for each initial state s at time t, combined action a
392

fiThe Communicative Multiagent Team Decision Problem

taken at time t, and final state s0 at time t + 1, Pr(S t+1 = s0jS t = s; Atff = a) = P (s; a; s0).
The given definition of P assumes that the world dynamics obey the Markov assumption.
2.1.3 Agent Observations: 
ff
f
igi2ff is a set of observations that each agent, i, can experience of its world, implicitly
defining a combined observation, 
ff  Qi2ff 
i. 
i may include elements corresponding
to indirect evidence of the state (e.g., sensor readings) and actions of other agents (e.g.,
movement of other helicopters). In the original team-theoretic framework, the information
structure that represented the observation process of the agents was a set of deterministic
functions, Oi : S ! 
i.
Extension of Allowable Information Structures: Off We extend the information
structure representation to allow for uncertain observations. We use a general stochastic
model, borrowed from the partially observable Markov decision process model (Smallwood &
Sondik, 1973), with a joint observation function: Off (s; a; !) = Pr(
tff = !jS t = s; Atff 1 =
a). This function models the sensors, representing any errors, noise, etc. In some cases,
we
Q
can separate this joint distribution into individual observation functions: Off  i2ff Oi ,
where Oi (s; a; !) = Pr(
ti = !jS t = s; Atff 1 = a). Thus, the probability distribution
specified by Off forms the richer information structure used in our model. We can make
useful distinctions between different classes of information structures:
Collective Partial Observability This is the general case, where we make no assumptions on the observations.
Collective Observability There is a unique world state fort the combined observations of
the team: 8! 2 
ff, 9s 2 S such that 8s0 6= s, Pr(
ff = !jS t = s0) = 0. The set
of domains that are collectively observable is a strict subset of the domains that are
collectively partially observable.
Individual Observability There is a unique world state for each individual agent's observations: 8! 2 
i, 9s 2 S such that 8s0 6= s, Pr(
ti = !jS t = s0) = 0. The set
of domains that are individually observable is a strict subset of the domains that are
collectively observable.
Non-Observability The agents receive no feedback from the world: 9! 2 
i, such that
8s 2 S and 8a 2 Aff , Pr(
ti = !jS t = s; Atff 1 = a) = 1. This assumption holds
in open-loop systems, which come under frequent consideration in classical planning (Boutilier, Dean, & Hanks, 1999).
2.1.4 Policy (Strategy) Space

iA is a domain-level policy (or strategy, in the original team theory specification) to map
an agent's belief state to an action. In the original formalism, the agent's beliefs correspond
directly to its observations (i.e., iA : 
i ! Ai).
Extension to Richer Belief State Space: Bff We generalize the set of possible strategies to capture the more complex mental states of the agents. Each agent, i 2 ff, forms a
belief state, bti 2 Bi, based on its observations seen through time t, where Bi circumscribes

393

fiPynadath & Tambe

the set of possible belief states for the agent. Thus, we define the set of possible domainlevel policies as mappings from belief states to actions, iA : Q
Bi ! Ai . We define the set
of possible combinedt belief states over all agents to be Bff  i2ff Bi. The corresponding
random variable, bff, represents the agents' combined belief state at time t. We elaborate
on different types of belief states and the mapping of observations to belief states (i.e., the
state estimator function) in Section 2.2.1.
2.1.5 Reward Function:

R

A common reward function is central to the notion of teamwork in a MTDP: R : S  Aff !
R. This function represents the team's joint preferences over states and the cost of domainlevel actions (e.g., destroying enemy is good, returning to home base with only 10% of
original force is bad). We assume that, as seless team members, each agent shares these
preferences at the individual level as well. Therefore, each team member wants exactly
what is best for the team as a whole.
2.2 Extension for Explicit Communication: ff
We make an explicit separation between domain-level actions (Aff) and communicative
actions. As defined in this section, communicative actions affect the receiving agents' individual belief states, but, unlike domain-level actions, they do not directly change the world
state. Although this distinction is sometimes blurry in real-world domains, we make this
explicit separation so as to isolate, as much as possible, the effects of the two types of
actions. The leverage gained from this separation provides the basis for the informative,
analytical results presented in the rest of this paper. To capture this separation, we extend
our initial MTDP model to be a communicative multiagent team decision problem (COMMTDP), that we define as a tuple, hS; Aff; ff ; P; 
ff; Off; B ff; Ri, with a new component,
ff, and an extended reward function, R.
2.2.1 Communication: ff
figi2ff is a set of possible messages for each agent, implicitly defining a set of combined
communications, ff  Qi2ff i. An agent, i, may communicate message x 2 i to its
teammates, who interpret the communication by updating their belief states in response. As
a first step in this work, we assume that all of the agents receive the messages instantaneously
and correctly (i.e., there is no lag or noise in the communication channels). This model is
common knowledge among all of the team members, so once an agent has sent a message,
it knows that its team members have received the message, and its team members know
that it knows that they have all received the message, and so on.
With communication, we divide each decision epoch into two phases: the pre-communication and post-communication phases, denoted by the subscripts  and , respectively.
In particular, the agents update their belief states at two distinct points within each decision epoch: once upon receiving observation 
ti (producing the pre-communication belief state bti ), and again upon receiving the other agents' messages (producing the postcommunication belief state bti). The distinction allows us to differentiate between the belief
state used by the agents in selecting their communication actions and the more \up-to-date"
belief state used in selecting their domain-level actions. We also distinguish between the
394

fiThe Communicative Multiagent Team Decision Problem

separate state-estimator functions used in each update phase:
b0i =SEi0 ()
(1)
t
t
1
t
bi =SEi (bi ; 
i )
(2)
t
t
t
bi =SEi (bi ; ff )
(3)
where SEi : Bi  
i ! Bi is the pre-communication state estimator for agent i, and
SEi : Bi  ff ! Bi is the post-communication state estimator for agent i. The initial
state estimator, SEi0 : ; ! Bi, specifies the agent's prior beliefs, before any observations
are made. For each of these, we also make the obvious definitions for the corresponding
estimators for the combined belief states: SE ff, SE ff, and SE 0ff.
In this paper, as a first step, we assume that the agents have perfect recall. In other
words, the agents recall all of their observations, as well as all communication of the other
agents. Thus, their belief states can representtheir entire histories as sequences of observations and received messages: Bi = 
i  ff, where X  denotes the set of all possible
sequences (of any length) of elements of X . The agents realize perfect recall through the
following state estimator functions:
SEi0 () = hi
(4)


 0 0 ff

 t 1 t 1 ffff t
SEi ( 
i ; ff ; : : : ; 
i ; ff
; 
i )


 0 0 ff

 t 1 t 1 ff 
 t ffff
=

 
i ; ffff ; : : :
; 
i ; ffff 
; 
iffff; 
(5)
0
0
t
1
t
1
t
t
SEi ( 
i ; ff ; : : : ; 
i ; ff ; 
i ;  ; ff )
= 


0i ; 0ffff ; : : : ; 

ti ; tffffff
(6)
In other words, SEi0 initializes agent i's belief state to be an empty history, SEi appends a
new observation to agent i's belief state, and SEi appends new messages to agent i's belief
state. Under this paper's assumptions of perfect recall, all three state-estimator functions
take only constant time. However, we can potentially allow more complex functions (though
the complexity results presented hold only if the state-estimator functions take polynomial
time). For instance, although we assume perfect, synchronous, instantaneous communication here, we could potentially use the post-communication state estimator to model any
noise, temporal delays, asynchrony, cognitive burden, etc. present in the communication
channel.
We extend our definition of a policy of behavior to include a communication policy,
i : Bi ! i , analogous to Section 2.1.4's domain-level policy. We define the joint policies,
ff and ffA , as the combined policies across all agents in ff.
2.2.2 Extended Reward Function:

R

We extend the team's reward function to also represent the cost of communicative acts (e.g.,
communication channels may have associated cost): R : S  Aff  ff ! R. We assume that
the cost of communication and of domain-level actions are independent of each other, so we
can decompose the reward function into two components: a communication-level reward,
R : S  ff ! R, and a domain-level reward, RA : S  Aff ! R. The total reward is
the sum of the two component values: R(s; a; ) = RA(s; a) + R(s; ). We assume that
395

fiPynadath & Tambe

communication has no inherent benefit and may instead have some cost, so that for all
states, s 2 S , and messages,  2 ff , the reward is never positive: R(s; )  0. However,
although we assign communication no explicit value, it can have significant implicit value
through its effect on the agents' belief states and, subsequently, on their future actions.
As with the observability function, we parameterize the communication costs associated
with message transmissions:
General Communication: We make no assumptions about communication.
Free Communication: R(s; ) = 0 for any  2 ff, and s 2 S . In other words,
communication actions have no effect on the agents' reward.
No communication: ff = ;, i.e., no explicit communication. Alternatively, communication may be prohibitively expensive, so that 8 2 ff , and s 2 S , R(s;  ) = 1.
The free-communication case appears in the literature, when researchers wish to focus
on issues other than communication cost. Although, real-world domains rarely exhibit
such ideal conditions, we may be able to model some domains as having approximately free
communication to a sucient degree. In addition, analyzing this extreme case gives us some
understanding of the benefit of communication, even if the results do not apply across all
domains. We also identify the no-communication case because such decision problems have
been of interest to researchers as well (Goldberg & Mataric, 1997). Of course, even if ff = ;,
it is possible that there are domain-level actions in Aff that have implicit communicative
value by acting as signals that convey information to the other agents. However, we still
label such agent teams as having no communication for the purposes of the work here, since
many of our results exploit an explicit separation between domain- and communication-level
actions.
2.3 Model Illustration
We can view the evolving state as a Markov chain with separate stages for domain-level
and communication-level actions. In other words, each agent team member, i 2 ff begins
in some initial state, S 0, with initial belief states, b0i = SEi0 (). Each agent receives an
observation 
0i drawn according to the probability distribution Off (S 0; null; 
0ff) (there are
no actions yet). Then, each agent updates its belief state, b0i = SEi (b0i ; 
0i ).
Next, each agent i 2 ff selects a message according to its communication policy, 0i =
i (b0i ), defining a combined communication, 0ff . Each agent interprets the communications of all of the others by updating its belief state, b0i = SEi (b0i ; 0ff ). Each
then selects an action
according
to
its
domain-level
policy,
A0i = iA(b0i ), defining a
combined action A0ff . By our central assumption of teamwork, each agent receives the
same joint reward, R0 = R(S 0 ; A0ff ; 0ff). The world then moves into a new state, S 1 ,
according to the distribution, P (S 0 ; A0ff ). Again, each agent i receives an observation 
1i
drawn from 
i according to the distribution Off (S 1 ; A0ff ; 
1ff), and it updates its belief state,
b1i = SEi (b0i ; 
1i ).
The process continues, with agents choosing communication- and domain-level actions,
observing the effects, and updating their beliefs. Thus, in addition to the time series of world
states, S 0; S 1 ; : : : ; S t , the agents themselves determine a time series of communication-level
396

fiThe Communicative Multiagent Team Decision Problem

and domain-level actions, 0ff ; 1ff ; : : : ; tff and A1ff; A1ff ; : : : ; Atff , respectively. We also have
a time series of observations for each agent i, 
0i ; 
1i ; : : : ; 
ti. Likewise, we can treat the
combined observations, 
0ff ; 
1ff; : : : ; 
tff, as a similar time series of random variables.
Finally, the agents receive a series of rewards, R0; R1 ; : : : ; Rt. We can define the value,
V , of the policies, ffA and  ff , as the expected reward received when executing those
policies. Over a finite horizon, T , this value is equivalent to the following:
VT

(ffA; ff ) = E

" T
X

t=0

fi
fi

Rt fifi 
fi

#

ffA ;  ff

(7)

2.4 Related Work
The COM-MTDP model subsumes many existing multiagent models, as presented in Table 1 (i.e., we can map any instance of these models into a corresponding COM-MTDP).
This generality enables us to perform novel analyses of real-world teamwork domains, as
demonstrated by Section 4's use of the COM-MTDP model for analyzing the optimality of
communication decisions.
2.4.1 Decentralized POMDPs

With its model of observability and world dynamics, our COM-MTDP model closely parallels the structure of the decentralized partially observable Markov decision process (DECPOMDP) (Bernstein et al., 2000). Following our notational conventions, a DEC-POMDP
is a tuple, hS; Aff ; P; 
ff; Off ; Ri. There is no set of possible messages, ff, so the DECPOMDP falls into the class of domains with no communication. The DEC-POMDP observational model, O, is general enough to capture collectively partially observable domains.
2.4.2 Partially Observable Identical Payoff Stochastic Games

Stochastic games provide a rich framework for multiagent decision making when the agents
may have their own individual goals and preferences. The identical payoff stochastic game
(IPSG) restricts the agents to share a single payoff function, appropriate for modeling
the single, global reward function of the team context. The partially observable IPSG
(POIPSG) (Peshkin, Kim, Meuleau, & Kaelbling, 2000) is a tuple, hS; Aff ; P; 
ff; Off; Ri,
very similar to the DEC-POMDP model. In other words, the observation function, Off , is
general enough to support collectively partially observable domains, and there is no communication.
2.4.3 Multiagent MDPs

Another relevant model is the multiagent Markov decision process (MMDP) (Boutilier,
1996), which is a tuple, hS; Aff; P; Ri, in our notation. Like the DEC-POMDP, the MMDP
has no communication. In addition, the MMDP is a multiagent extension to the completely
observable MDP model, so it assumes an environment that is individually observable.

397

fiPynadath & Tambe

Model
ff
Off
DEC-POMDP no communication collective partial observability
POIPSG
no communication collective partial observability
MMDP
no communication
individual observability
Xuan-Lesser general communication
collective observability
Table 1: Existing models as COM-MTDP subsets.
2.4.4 Xuan-Lesser Framework

The COM-MTDP's separation of communication from other actions is similar to previous
work on multiagent decision models (Xuan, Lesser, & Zilberstein, 2001), which supported
general communication. However, while the Xuan-Lesser model generalizes beyond individually observable environments, it supports only a subset of collectively observable environments. In particular, the Xuan-Lesser framework cannot represent agents who receive
local observations of a common world state, where the observations of different agents could
potentially be interdependent.
3. COM-MTDP Complexity Analysis

We can use the COM-MTDP model to prove some results about the complexity of constructing optimal agent teams (i.e., teams that coordinate to produce optimal behavior in
a problem domain). The problem facing these agents (or the designer of these agents) is
how to construct the joint policies, ff and ffA, so as to maximize their joint reward,
as represented by the expected value, V T (ffA; ff). In all of the results presented, we
assume that all of the values in a model instance (e.g., transition probabilities, rewards) are
rational numbers, so that we can express the particular instance as a finite-sized input.
Theorem 1 The decision problem of whether there exist policies, ff and ffA , for a given
COM-MTDP, under general communication and collective partial observability, that yield
a total reward at least K over some finite horizon T is NEXP-complete if jffj  2 (i.e.,
more than one agent).

Proof: To prove that the COM-MTDP decision problem is NEXP-hard, we reduce a DECPOMDP (Bernstein et al., 2000) to a COM-MTDP with no communication by copying
all of the other model features
from the given DEC-POMDP.
In other words, if we are


ff
i
m
i
m
given a DEC-POMDP, S; fA gi=1; P; f
 gi=1 ; O; R , we can construct a COM-MTDP,
hS 0 ; fA0i gmi=1 ; 0ff; P 0 ; f
0igmi=1 ; O0ff; B 0ff; R0 i, as follows:
S0 = S
A0i = Ai
0 = ;
P 0 (s; ha1 ; : : : ; am i ; s0 ) = P (s0 js; a1 ; : : : ; am )
398

fiThe Communicative Multiagent Team Decision Problem


0i = 
i
O0ff (s; ha1 ; : : : ; am i ; h!1 ; : : : ; !m i) = O(!1 ; : : : ; !m ja1 ; : : : ; am ; s)
Bi0 = [Tj=1(
i )j
(i.e., observation sequences of length no more than the finite horizon)
R0 (s; ha1 ; : : : ; am i ;  ) = R(s; a1 ; : : : ; am )
The DEC-POMDP assumes perfect recall, so we use the state estimator functions from
Equations 5 and 6. Since there is no communication for this COM-MTDP, we have a fixed
silent policy, ff. We can translate any domain-level policy, ffA, into a DEC-POMDP
joint policy, , as follows:


ff
i (oi1 ; : : : ; oit )  iA ( oi1 ; : : : ; oit )
(8)
The expected utility of following this joint policy, , within the DEC-POMDP is identical
to that of following ff and ffA within the constructed COM-MTDP. Thus, there exists
a policy with expected utility greater than K for the COM-MTDP if and only if there
exists one for the DEC-POMDP. The decision problem for a DEC-POMDP is known to be
NEXP-complete, so the COM-MTDP problem must be NEXP-hard.
To show that the COM-MTDP is in NEXP, our proof proceeds similarly to that of
the DEC-POMDP. In other words, we guess the joint policy, ff , and write it down in
exponential time (we assume that T  jS j). We can take the COM-MTDP plus the policy
and generate (in exponential time) a corresponding MDP where the state space is the space
of all possible combined belief states of the agents. We can then use dynamic programming
to determine (in exponential time) whether ff generates an expected reward of at least K .
2
In the remainder of this section, we examine the effect of communication on the complexity of constructing team policies that generate optimal behavior. We start by examining
the case under the condition of free communication, where we would expect the benefit of
communication to be the greatest. To begin with, suppose that each agent is capable of
communicating its entire observation (i.e., i  
i). Before we analyze the complexity of
the team decision problem, we first prove that the agents should exploit this capability and
communicate their true observation, as long as they incur no cost in doing so:
Theorem 2 Under free communication, consider a team of agents using a communication
policy: i (bti )  
ti . If the domain-level policy  ffA maximizes V T (ffA ;  ff ), then this
combined policy is dominant over any other policies. In other words, for all policies,  0ffA
and 0ff , V T ( ffA ; ff )  V T ( 0ffA ;  0ff ).
Proof: Suppose we have some other communication policy, 0ff, that specifies something
other than complete communication (e.g., keeping quiet, lying). Suppose that there is some
domain-level policy, 0ffA , that allows the team to attain some expected reward, K , when
used in combination with 0ff. Then, we can construct a domain-level policy, ffA , such
that the team attains the same expected reward, K , when used in conjunction with the
complete-communication policy, ff , as defined in the statement of Theorem 2.
Thet communication policy, 0ff, produces a different set of belief states (denoted b0 ti
and b0i) than those for ff (denoted bti and bti ). In particular, we use state estimator
399

fiPynadath & Tambe

functions, SEi0 and SEi0 as defined in Equations 5 and 6 to generate b0ti and b0ti .
Each belief state is a complete history of observation and communication pairs for each
agent. On the other hand, under the complete communication of ff, the state estimator
functions of Equations 5 and 6 reduce to:


ff


ff
SEi ( 
0ff ; : : : ; 
tff 1 ; 
ti ) = 
0ff ; : : : ; 
tff 1 ; 
ti
(9)

 0
ff


ff
SEi ( 
ff ; : : : ; 
tff 1 ; 
ti ; tff ) = 
0ff ; : : : ; 
tff 1 ; tff
= 

0ff ; : : : ; 
tff 1; 
tff ff
(10)
Thus, ffA is defined over a different set of belief states than 0ffA . In order to determine
an equivalent ffA, we must first define a recursive mapping, m, that translates the belief
states defined by ff into those defined by 0ff :


ff




ffff
mi (bti ) =mi bti1 ; 
tff = mi bti1 ; 
ti ; 
tff
*
*
++
D
D
EE
Y t
t
= mi(bti1 ); 
ti ; 0ff = mi(bti1 ); 
ti; 0j
=

*

(

mi bti1

*

); 
ti;

j 2ff

Y

j 2ff

(

( (

j0  SEj0  mj btj 1

); 
tj ))

++

(11)

Given this mapping, we then specify: iA(bti) = iA0 (mi(bti )). Executing this domainlevel policy, in conjunction with the communication policy, ff , results in the identical
behavior as execution of the alternate policies, 0ffA and 0ff . Therefore, the team following
the policies, ffA and ff will achieve the same expected value of K , as under 0ffA and
0ff . 2
Given this dominance of the complete-communication policy, we can prove that the
problem of constructing teams that coordinate optimally is simpler when communication is
free.
Theorem 3 The decision problem of determining whether there exist policies, ff and
ffA , for a given COM-MTDP with free communication under collective partial observability, that yield a total reward at least K over some finite horizon T is PSPACE-complete.
Proof: To prove that the problem is PSPACE-hard, we reduce the single-agent POMDP to
a COM-MTDP. In particular, if we are given a POMDP, hS; A; P; 
; O; Ri, we can construct
a COM-MTDP, hS 0 ; A01 ; 01; P 0 ; 
01; O10 ; B10 ; R0 i, for a single-agent team (i.e., ff = f1g):
S0 = S
A01 = A
01 = ;
P 0 (s; ha1 i ; s0 ) = P (s; a1 ; s0 )

01 = 

400

fiThe Communicative Multiagent Team Decision Problem
O10 (s; ha1 i ; h!1 i) = O(s; a1 ; !1 )

B10 =

[Tj=1(
)j
(i.e., observation sequences of length no more than the finite horizon)
RA0 (s; ha1 i) = R(s; a1 )

R0 (s;  ) =

0
This COM-MTDP satisfies our assumption of free communication. The POMDP assumes
perfect recall, so we use the state estimator functions from Equations 5 and 6. Just as in
the proof of Theorem 1, we can show that there exists a policy with expected utility greater
than K for this COM-MTDP if and only if there exists one for the POMDP. The decision
problem for the POMDP is known to be PSPACE-hard (Papadimitriou & Tsitsiklis, 1987),
so the COM-MTDP problem under free communication must be PSPACE-hard.
To show that the problem is in PSPACE, we take a COM-MTDP under free communication and reduce it to a single-agent POMDP. In particular, if we are given a COM-MTDP,
hS; Aff; ff ; P; 
ff; Off; B ff; Ri, we can construct a single-agent POMDP, hS 0; A0 ; P 0 ; 
0; O0 ;
R0 i, as follows:
S0 = S
A 0 = Aff
P 0 (s; a; s0 ) = P (s; a; s0 )

0 = 
ff
O0 (s; a; ! ) = Off (s; a; ! )
R0 (s; a) = RA (s; a)
From Theorem 2, we need to consider only the complete-communication policy for the
COM-MTDP and this policy has a zero reward. Therefore, the decision problem for the
COM-MTDP is simply to find a domain-level policy that produces an expected reward
exceeding K . Given full communication, the state estimator functions for the COM-MTDP
(as shown in the proof of Theorem 2) reduce to Equation 10. A policy for our POMDP
specifies an action for each and every history of observations: 0 : [Tj=1(
0 )j ! A0 . The
history of observations for the single-agent POMDP corresponds to the belief states of our
COM-MTDP under full communication. Therefore, we can translate a POMDP-policy, 0 ,
into an equivalent domain-level policy for the COM-MTDP:
A (h! 0 ; ! 1 ; : : : ; ! t i)  0 (h! 0 ; ! 1 ; : : : ; ! t i)
(12)
A team following A will perform the exact same domain-level actions as a single agent
following 0 . Thus, there exists a policy with expected utility greater than K for the COMMTDP if and only if there exists one for the POMDP. The decision problem for a POMDP
is known to be in PSPACE (Papadimitriou & Tsitsiklis, 1987), so the COM-MTDP problem
(under free communication) must be in PSPACE as well. 2
401

fiPynadath & Tambe

Theorem 4

The decision problem of determining whether there exist policies,  ff and
ffA , for a given COM-MTDP with free communication and collective observability, that
yield a total reward at least K over some finite horizon T is P-complete.

Proof: The proof follows that of Theorem 3, but with a reduction to and from the MDP
decision problem, rather than the POMDP. The MDP decision problem is P-complete (Papadimitriou & Tsitsiklis, 1987). 2
Theorem 5 The decision problem of determining whether there exist policies, ff and
ffA , for a given COM-MTDP with individual observability, that yield a total reward at
least K over some finite horizon T (given integers K and T ) is P-complete.

Proof: The proof follows that of Theorem 4, except that we can reduce the problem to
and from an MDP regardless of what communication policy the team uses. 2
Theorem 6 The decision problem of determining whether there exist policies, ff and
ffA , for a given COM-MTDP with non-observability, that yield a total reward at least K
over some finite horizon T (given integers K and T ) is NP-complete.

Proof: The proof follows that of Theorem 4, except that we can reduce the problem to and
from an single-agent non-observable MDP (NOMDP) regardless of what communication
policy the team uses. In particular, because the agents are all equally ignorant of the state,
communication has no effect. The NOMDP decision problem is NP-complete (Papadimitriou & Tsitsiklis, 1987). 2
Thus, we have used the COM-MTDP framework to characterize the diculty of problem
domains in agent teamwork along the dimensions of communication cost and observability.
Table 2 summarizes our results, which we can use in deciding where to concentrate our
energies in attacking teamwork problems. We can use these results to draw some conclusions
about the challenges to designers of multiagent teams:
 The greatest challenges lie in those domains with either collective observability or
collective partial observability and with nonzero communication cost.
 Under collective observability and collective partial observability, teamwork without
communication is highly intractable, but, with free communication, the complexity
becomes on par with that of single-agent planning problems.
 Agent team designers have much to gain by increasing the observational capabilities of
their team (e.g., by adding new sensor agents) because of the reduction in complexity
gained by making the domain collectively observable.
 Furthermore, the results from Theorems 3 and 4 hold in any domain where the result
from Theorem 2 holds (i.e., when complete communication is the dominant policy).
Therefore, while perfectly free communication may be rare, these results show that
investment in communication in teamwork can pay off with a significant simplification
of optimal teamwork.
402

fiThe Communicative Multiagent Team Decision Problem

Individually Collectively
Collectively
Observable Observable Partially Observable
No Comm. P-complete NEXP-complete NEXP-complete
General Comm. P-complete NEXP-complete NEXP-complete
Free Comm. P-complete P-complete
PSPACE-complete

NonObservable
NP-Complete
NP-Complete
NP-Complete

Table 2: Time complexity of COM-MTDPs.
 On the other hand, when the world is individually observable or non-observable, com-

munication makes no difference in performance.
 It should be noted that even under those conditions where the problem is P-complete,
the complexity of optimal teamwork is polynomial in the number of states of the
world, which may still be impractically high.
 The above complexity results pertain to finding policies that are optimal subject to
the domain properties. We will find different expected rewards of the optimal policies
under different observability and communication properties. For instance, cutting off
all of the agents' sensors makes the domain non-observable and reduces the complexity
of generating an optimal policy from NEXP to NP, but we would expect an associated
drop in the expected reward achieved by the team.

4. Evaluating Team Coordination

Table 2 shows that providing optimal domain-level and communication policies for teams is
a dicult challenge. Many systems alleviate this diculty by having domain experts provide the domain-level plans (Tambe, 1997; Tidhar, 1993). Then, the problem for the agents
reduces to generating the appropriate team coordination, ff , to ensure that they properly execute the domain-level plans, ffA. In this section, we demonstrate the COM-MTDP
framework's ability to analyze existing teamwork approaches in the literature. Our methodology for such analysis begins by encoding such a teamwork method as a communicationlevel policy. In other words, we translate the method into an algorithm that maps agent
beliefs (e.g., observation sequences) into communication decisions. To evaluate the performance of this policy, we then instantiate a COM-MTDP that represents the states,
transition probabilities, and reward function of a domain of interest. Our methodology
provides an evaluation of the policy in terms of the expected reward earned by the team
when following the policy in the specified domain.
We demonstrate this methodology by using our COM-MTDP framework to analyze joint
intentions theory (Cohen & Levesque, 1991b, 1991a; Levesque et al., 1990), which provides
a common basis for many existing approaches to team coordination. Section 4.1 models two
key instantiations of joint intentions taken from the literature (Jennings, 1995; Tambe, 1997)
as COM-MTDP communication policies. Section 4.2 analyzes the conditions under which
these policies generate optimal behavior and provides a third candidate policy that makes
communication decisions that are locally optimal within the context of joint intentions. In
403

fiPynadath & Tambe

addition to providing the results for the particular team coordination strategies investigated,
this section also illustrates a general methodology by which one can use our COM-MTDP
framework to encode and evaluate coordination strategies proposed by existing multiagent
research.
4.1 Joint Intentions in a COM-MTDP
Joint intention theory provides a prescriptive framework for multiagent coordination in a
team setting. It does not make any claims of optimality in its teamwork, but it provides
theoretical justifications for its prescriptions, grounded in the attainment of mutual belief
among the team members. We can use the COM-MTDP framework to identify the domain
properties under which attaining mutual belief generates optimal behavior and to quantify
precisely how suboptimal the performance will be otherwise.
Joint intentions theory requires that team members jointly commit to a joint persistent
goal, G. It also requires that when any team member privately believes that G is achieved
(or unachievable or irrelevant), it must then attain mutual belief throughout the team
about this achievement (or unachievability or irrelevance). To encode this prescription of
joint intentions theory within our COM-MTDP model, we first specify the joint goal, G, as
a subset of states, G  S , where the desired goal is achieved (or unachievable or irrelevant).
Presumably, such a prescription indicates that joint intentions are not specifically intended for individually observable environments. Upon achieving the goal in an individually
observable environment, each agent would simultaneously observe that S t 2 G. Because
of our assumption that the COM-MTDP model components (including Off) are common
knowledge to the team, each agent would also simultaneously come to believe that its teammates have observed that S t 2 G, and that its teammates believe that it believes that all
of the team members have observed that S t 2 G, and so on. Thus, the team immediately
attains mutual belief in the achievement of the goal under individual observability without
any additional communication necessary by the team.
Instead, the joint intention framework aims at domains with some degree of unobservability. In such domains, the agents must signal the other agents, either through communication or some informative domain-level action, to attain mutual belief. However, we can
also assume that joint intention theory does not focus on domains with free communication,
where Theorem 2 shows that we can simply have the agents communicate everything, all
the time, without the need for more complex prescriptions.
The joint intention framework does not specify a precise communication policy for the
attainment of mutual belief. In this paper, we focus on communication only in the case of
goal achievement, but our methodology extends to handle unachievability and irrelevance as
well. One well-known approach (Jennings, 1995) applied joint intentions theory by having
the agents communicate the achievement of the joint goal, G, as soon as they believe G to be
true. To instantiate the behavior of Jennings' agents within a COM-MTDP, we construct a
communication policy, Jff, that specifies that an agent sends the special message, G, when
it first believes that G holds. Following joint intentions' assumption of sincerity (Smith &
Cohen, 1996), we require that the agents never select the special G message in a belief
state unless they believe G to be true with certainty. With this requirement and with our
assumption of the team's common knowledge of the communication model, we can assume
404

fiThe Communicative Multiagent Team Decision Problem

that all of the other agents immediately accept the special message, G, as true, and that
the agents know that all their team members accept the message as true, and so on. Thus,
the team attains mutual belief that G is true immediately upon receiving the message, G.
We can construct the communication policy, Jff , in constant time.
The STEAM algorithm is another instantiation of joint intentions that has had success in
several real-world domains (Tambe, 1997; Pynadath et al., 1999; Tambe, Pynadath, Chauvat, Das, & Kaminka, 2000; Pynadath & Tambe, 2002). Unlike Jennings' instantiation, the
STEAM teamwork model includes decision-theoretic communication selectivity. A domain
specification includes two parameters for each joint commitment, G:  , the probability of
miscoordinated termination of G; and Cmt , the cost of miscoordinated termination of G. In
this context, \miscoordinated termination" means that some agents immediately observe
that the team has achieved G while the rest do not. STEAM's domain specification also
includes a third parameter, Cc, to represent the cost of communication of a fact (e.g., the
achievement of G). Using these parameters, the STEAM algorithm evaluates whether the
expected cost of miscoordination outweighs the cost of communication. STEAM expresses
this criterion as the following inequality:   Cmt > Cc. We can define a communication
policy, Sff based on this criterion: if the inequality holds, then an agent that has observed
the achievement of G will send the message, G; otherwise, it will not. We can construct
Sff in constant time.
4.2 Locally Optimal Policy
Although the STEAM policy is more selective than Jennings', it remains unanswered
whether it is optimally selective, and researchers continue to struggle with the question
of when agents should communicate (Yen et al., 2001). The few reports of suboptimal
(in particular, excessive) communication in STEAM characterized the phenomenon as an
exceptional circumstance, but it is also possible that STEAM's optimal performance is the
exception. We use the COM-MTDP model to derive an analytical characterization of optimal communication here, while Section 5 provides an empirical one by creating an algorithm
using that characterization.
Both policies, Jff, and Sff consider sending G only when an agent first believes that
G has been achieved. Once an agent has the relevant belief, they make different choices, and
we consider here what the optimal decision is at this point. The domain is not individually
observable, so certain agents may be unaware of the achievement of G. When not sending
the G message, these unaware agents may unnecessarily continue performing actions in
the pursuit of achieving G. The performance of these extraneous actions could potentially
incur costs and lead to a lower utility than one would expect when sending the G message.
The decision to send G or not matters only if the team achieves G and one agent
comes to know this fact. We define the random variable, TG, to be the earliest time at
which an agent knows this fact. We denote agent KG as the agent who knows of the
achievement at time TG . If KG = i, for some agent, i, and TG = t0 , then agent i has some
pre-communication belief state, bti0 = fi , that indicates that G has been achieved. To more
precisely quantify the difference between agent i sending the G message at time TG vs.

405

fiPynadath & Tambe

never sending it, we define the following value:
 (t0; i; fi ) E
T

"T t
X0

t=0
"T t
X0

E

fi
fi

 = G; TG = t0 ; KG =

Rt0 +t fifi ti0
fi

t=0

fi
fi
Rt0 +t fifi ti0
fi

i; bti0 

=fi

#

 = null; TG = t0 ; KG = i; bti0 = fi

#

(13)

We assume that, for all times other than TG, the agents follow some communication policy,
that never specifies G. Thus, T measures the difference in expected reward that
hinges on agent i's specific decision to send or not send G at time t0 . Given this definition,
it is locally optimal for agent i to send the special message, G, at time t0, if and only
if T  0. We define the communication policy, ff+ , as the communication policy
following ff for all agents at all times, except for agent i under belief state fi , when
agent i sends message . With this definition, ff+G , is the policy under which agent i
communicates the achievement of G, and ff+null is the policy under which it does not.
Therefore, we can alternatively describe agent i's decision criterion as choosing ff+G
over ff+null if and only if T  0.
Unfortunately, while Equation 13 identifies an exact criterion for locally optimal communication, this criterion is not yet operational. In other words, we can not directly implement
it as a communication policy for the agents. Furthermore, Equation 13 hides the underlying complexity of the computation involved, which is one of the key goals of our analysis.
Therefore, we use the COM-MTDP model to derive an operational expression of T  0.
For simplicity, we define notational shorthand for various sequences and combinations of
values. We define a partial sequence of random variables, X <t , to be the sequence of random variables for all times before t: X 0 , X 1 , : : : , X t 1 . We make similar definitions for the
>t , X t , etc.). The expression, (S )T , denotes the cross
other relational operators (i.e., XQ
product over states of the world, Tt=0 S , as distinguished from the time-indexed random
variable, S T , which denotes the value of the state at time T . The notation, st0 [t], specifies
the element in slot t within the vector st0 . We define the function, , as shorthand within
our probability expressions. It allows us to compactly represent a particular subsequence
of world and agent belief states occurring, conditioned on the current situation, as follows:
fi
Pr  
t; t0ff ; s; fi  Pr(S t;t0 = s; bff t;t0 = fi fiTG = t0 ; KG = i; bti0 = fi )
(14)
Informally, (ht; t0i ; s; fi ) represents the event that the world and belief states from time
t through t0 correspond to the specified sequences, s and fi , respectively, conditioned on
agent i being the first to know of G's achievement at time t0 with a belief state, fi . We define
the function, fi, to map a pre-communication belief state into the post-communication
belief state that arises from a communication policy:
fi (fi ; ff )  SE ff (fi ;  ff (fi ))
(15)
This definition of fi is a well-defined function because of the deterministic nature of the
policy, ff, and state-estimator function, SE ff .
 ff ,

406

fiThe Communicative Multiagent Team Decision Problem

Theorem 7

If we assume that, upon achievement of G, no communication other than G
is possible, then the condition T (t0 ,i,fi )  0 holds if and only if:
X

X

Pr((h0; t0 i ; st0 ; fit0 ))

t
t
st0 2(S )t0 fi
0 2B ff0
0

B
@



X

X

fi



Pr (ht0 ; T i ; st0 ; fit0 ) fifiti0 = G ; (h0; t0 i ; st0 ; fit0 )



t
T t +1
st0 2(S )T t0 +1 fi
0 2B ff 0
T




X
 RA st0 [t]; ffA fi fi t0 [t]; ff+G
t=t0
fi


X
X
Pr (ht0 ; T i ; st0 ; fit0 ) fifiti0 = null; (h0; t0 i ; st0 ; fit0 )
t
T t +1
st0 2(S )T t0 +1 fi
0 2B ff 0
!
T




X

t
 RA st0 [t]; ffA fi fi 0 [t]; ff+null
t=t0
X X

s2G fi2Bff

Pr ((ht0 ; t0 i ; s; fi)) R (s; G )

(16)

Proof: The complete proof of the following theorem appears in Online Appendix 1.
The definition of T in Equation 13 is the difference between two expectations, where each
expectation is a sum over the possible trajectories of the agent team. Each trajectory must
includes a sequence of possible world states, since the agents' reward at each point in time
depends on the particular state of the world at that time. The agents' reward also depends
on their actions (both domain- and communication-level). These actions are deterministic,
given the agents' policies, ffA and , and their belief states. Thus, in addition to summing
over the possible states of the world, we must also sum over the possible states of the agents'

407

fiPynadath & Tambe

beliefs (both pre- and post-communication):
T (t0; i; fi )
X
X
X
=
Pr S T = sT ; b T = fi T ; b T = fiT
sT 2(S )T fi T 2(B)T fi  T 2(B)T

jti0 = G; TG = t0; KG = i; bti0 = fi


X

X

X

T
X
t=0

sT 2(S )T fi  T 2(B)T fi  T 2(B)T





R(sT [t];  A (fi  T [t]);   (fi T [t]))

Pr

S T

= sT ; b T = fi T ; bT = fiT

jti0 = null; TG = t0; KG = i; bti0 = fi

T
X
t=0



R(sT [t];  A (fi  T [t]);   (fi T [t]))

(17)

We can rewrite these summations more simply using our various shorthand notations:
=

X

X

sT 2(S )T fi T 2(B)T

Pr((h0; T i ; s; fi T )jti0 = G)


X

X

T
X
t=0

sT 2(S )T fi  T 2(B)T



R(sT [t];  A (fi (fi T [t];  G ));  G (fi  T [t]))

Pr((h0; T i ; s; fi T )jti0 = null)

T
X
t=0

R(sT [t];  A (fi (fi T [t];  null));  null(fi T [t]))

(18)

The remaining derivation exploits our Markovian assumptions to rearrange the summations
and cancel like terms to produce the theorem's result. 2
Theorem 7 states, informally, that we prefer sending G whenever the the cost of execution after achieving G outweighs the cost of communication of the fact that G has been
achieved. More precisely, the outer summations on the left-hand side of the inequality
iterate over all possible past histories of world and belief states, producing a probability
distribution over the possible states the team can be in at time t0. For each such state, the
expression inside the parentheses computes the difference in domain-level reward, over all
possible future sequences of world and belief states, between sending and not sending G.
By our theorem's assumption that no communication other than G is possible after G has
been achieved, we can ignore any communication costs in the future. However, if we relax
this assumption, we can extend the left-hand side in a straightforward manner into a longer
408

fiThe Communicative Multiagent Team Decision Problem

Individually
Observable
No Comm.

(1)
General Comm.

(1)
Free Comm.

(1)

Collectively
Collectively
NonObservable Partially Observable Observable

(1)

(1)

(1)
T
T
O((jS j  j
ff j) )
O((jS j  j
ff j) )

(1)

(1)

(1)

(1)

Table 3: Time complexity of locally optimal decision.
expression that accounts for the difference in future communication costs as well. Thus, the
left-hand side captures our intuition that, when not communicating, the team will incur a
cost if the agents other than i are unaware of G's achievement. The right-hand side of the
inequality is a summation of the cost of sending the G message over possible current states
and belief states.
We can use Theorem 7 to derive the locally optimal communication decision across
various classes of problem domains. Under no communication, we cannot send G. Under
free communication, the right-hand side is 0, so the inequality is always true, and we know
to prefer sending G. Under no assumptions about communication, the determination is
more complicated. When the domain is individually observable, the left-hand side becomes
0, because all of the agents know that G has been achieved (and thus there is no difference
in execution when sending G). Therefore, the inequality is always false (unless under free
communication), and we prefer not sending G . When the environment is not individually
observable and communication is available but not free, then, to be locally optimal at time
t0 , agent i must evaluate Inequality 16 in its full complexity. Since the inequality sums
rewards over all possible sequences of states and observations, the time complexity of the
corresponding algorithm is O((jS jj
ffj)T ). While this complexity is unacceptable for most
real-world problems, it still provides an exponential savings over searching the entire policy
space for the globally optimal policy, where any agent could potentially send G at times
other than TG. Table 3 provides a table of the complexity required to determine the locally
optimal policy under the various domain properties.
We can now show that although Theorem 7's algorithm for locally optimal communication provides a significant computational savings over finding the global optimum, it still
outperforms existing teamwork models, as exemplified by our Jff and Sff policies. First,
we can use the criterion of Theorem 7 to evaluate the optimality of the policy, Jff . If
T (t0; i; fi )  0 for all possible times t0, agents i, and belief states fi that are consistent
with the achievement of the goal G, then the locally optimal policy will always specify
sending G. In other words, Jff will be identical to the locally optimal policy. However,
if the inequality of Theorem 7 is ever false, then Jff is not even locally, let alone globally,
optimal.
Second, we can also use Theorem 7 to evaluate STEAM by viewing STEAM's inequality,
  Cmt > Cc, as a crude approximation of Inequality 16. In fact, there is a clear correspondence between the terms in the two inequalities. The left-hand side of Inequality 16
computes an exact expected cost of miscoordination. However, unlike STEAM's monolithic
 parameter, the optimal criterion evaluates a complete probability distribution over all
possible states of miscoordination by considering all possible past sequences consistent with
409

fiPynadath & Tambe

the agent's current beliefs. Likewise, unlike STEAM's monolithic Cmt parameter, the optimal criterion looks ahead over all possible future sequences of states to determine the true
expected cost of miscoordination. Furthermore, we can view STEAM's parameter, Cc, as an
approximation of the communication cost computed by the right-hand side of Inequality 16.
Again, STEAM uses a single parameter, while the optimal criterion computes an expected
cost over all possible states of the world.
STEAM does have some exibility in its representation, because Cmt ,  , and Cc are
not necessarily fixed across the entire domain. For instance, Cmt may vary based on the
specific joint plan that the agents may have jointly committed to (i.e., there may be a
different Cmt for each goal G). Thus, while Theorem 7 suggests significant additional exibility in computing Cmt through explicit lookahead, the optimal criterion derived with the
COM-MTDP model also provides a justification for the overall structure behind STEAM's
approximate criterion. Furthermore, STEAM's emphasis on on-line computation makes the
computational complexity of Inequality 16 (as presented in Table 3) unacceptable, so the
approximation error may be acceptable given the gains in eciency. For a specific domain,
we can use empirical evaluation (as demonstrated in the next section) to quantify the error
and eciency to precisely judge this tradeoff.
5. Empirical Policy Evaluation

In addition to providing these analytical results over general classes of problem domains, the
COM-MTDP framework also supports the analysis of specific domains. Given a particular
problem domain, we can construct an optimal communication policy or, if the complexity of
computing an optimal policy is prohibitive, we can instead evaluate and compare candidate
approximate policies. To provide a reusable tool for such evaluations, we have implemented
the COM-MTDP model as a Python class with domain-independent methods for the evaluation of arbitrary policies and for the generation of both locally optimal policies using
Theorem 7 and globally optimal policies through brute-force search of the policy space.
This software is available in Online Appendix 1.
This section presents results of a COM-MTDP analysis of an example domain involving
agent-piloted helicopters, where we focus on the key communication decision faced by many
multiagent frameworks (as described in Section 4), but vary the cost of communication and
degree of observability to generate a space of distinct domains with different implications
for the agents' performance. By evaluating communication policies over various configurations of this particular testbed domain, we demonstrate a methodology by which one can
use the COM-MTDP framework to model any problem domain and to evaluate candidate
communication policies for it.
5.1 Experimental Setup
Consider two helicopters that must y across enemy territory to their destination, as illustrated in Figure 1. The first, piloted by agent Transport, is a transport vehicle with
limited firepower. The second, piloted by agent Escort, is an escort vehicle with significant
firepower. Somewhere along their path is an enemy radar unit, but its location is unknown
(a priori) to the agents. Escort is capable of destroying the radar unit upon encountering
it. However, Transport is not, but it can escape detection by the radar unit by traveling
410

fiThe Communicative Multiagent Team Decision Problem

Figure 1: Illustration of helicopter team scenario.
at a very low altitude (nap-of-the-earth ight), though at a lower speed than at its typical,
higher altitude. In this scenario, Escort will not worry about detection, given its superior
firepower; therefore, it will y at a fast speed at its typical altitude.
The two agents form a top-level joint commitment, GD , to reach their destination.
There is no incentive for the agents to communicate the achievement of this goal, since they
will both eventually reach their destination with certainty. However, in the service of their
top-level goal, GD , the two agents also adopt a joint commitment, GR, of destroying the
radar unit. We consider here the problem facing Escort with respect to communicating the
achievement of goal, GR. If Escort communicates the achievement of GR, then Transport
knows that it is safe to y at its normal altitude (thus reaching the destination sooner).
If Escort does not communicate the achievement of GR, there is still some chance that
Transport will observe the event anyway. If Transport does not observe the achievement
of GR , then it must y nap-of-the-earth the whole distance, and the team receives a lower
reward because of the later arrival. Therefore, Escort must weigh the increase in expected
reward against the cost of communication.
In the COM-MTDP model of this scenario (presented in Figures 2, 3 and 4), the world
state is the position (along a straight line between origin and destination) of Transport,
Escort, and the enemy radar. The enemy is at a randomly selected position somewhere
in between the agents' initial position and their destination. Transport has no possible
communication actions, but it can choose between two domain-level actions: ying nap-ofthe-earth and ying at its normal speed and altitude. Escort has two domain-level actions:
ying at its normal speed and destroying the radar. Escort also has the option of communicating the special message, GR , indicating that the radar has been destroyed. In the tables
of Figures 2, 3 and 4, the \" symbol represents a wild-card (or \don't care") entry.
If Escort arrives at the radar, then it observes its presence with certainty and can
destroy it to achieve GR. The likelihood of Transport's observing the radar's destruction is
a function of its distance from the radar. We can vary this function's observability parameter
411

fiPynadath & Tambe
ff
S

Aff

ff

= fEscort (E ); Transport (T )g
= E  T  R
Position of Escort: E = f0; 1; : : : ; 8; 9; Destinationg
Position of Transport: T = f0; 0:5; : : : ; 9; 9:5; Destination;
Destroyedg
Position of Radar: R = f1; 2; : : : ; 8; Destroyedg
= AE  AT = fy; destroy; waitg  fy-NOE; y-normal; waitg
= E  T = fclear (GR ); nullg  fnullg
E
0; : : : ; 9
0; : : : ; 9

T
a
0; : : : ; 9:5; Destroyed 

RA

0
Destination

rT
Destination 0; : : : ; 9:5; Destroyed  rE
Destination
 rE + rT
Destination
R (s; hnull; nulli) = 0
R (s; hGR ; nulli) = r 2 [0; 1]
Figure 2: COM-MTDP model of states, actions, and rewards for helicopter scenario.

RA (hE ; T ; R i ; a)

=

( in Figure 4) within the range [0; 1] to generate distinct domain configurations (0 means
that Transport will never observe the radar's destruction; 1 means Transport will always
observe it). If the observability is 1, then they achieve mutual belief of the achievement of
GR as soon as it occurs (following the argument presented in Section 4.1). However, for any
observability less than 1, there is a chance that the agents will not achieve mutual belief
simply by common observation. The helicopters receive a fixed reward for each time step
spent at their destination. Thus, for a fixed time horizon, the earlier the helicopters reach
there, the greater the team's reward. Since ying nap-of-the-earth is slower than normal
speed, Transport will switch to its normal ying as soon as it either observes that GR has
been achieved or Escort sends the message, GR . Sending the message is not free, so we
impose a variable communication cost (r in Figure 2), also within the range [0; 1].
We constructed COM-MTDP models of this scenario for each combination of observability and communication cost within the range [0; 1] at 0.1 increments. For each combination,
we applied the Jennings and STEAM policies, as well as a completely silent policy. For this
domain, the policy, Jff , dictates that Escort always communicate GR upon destroying
the radar. For STEAM, we vary the  and Cc parameters with the observability and communication cost parameters, respectively. We used two different settings (low and medium)
for the cost of miscoordination, Cmt . Following the published STEAM algorithm (Tambe,
1997), Escort sends message GR if and only if STEAM's inequality   Cmt > Cc, holds.
Thus, the two different settings, low and medium, for Cmt generate two distinct communication policies; the high setting is strictly dominated by the other two settings in this domain.
We also constructed and evaluated locally and globally optimal policies. In applying each
of these policies, we used our COM-MTDP model to compute the expected reward received
by the team when following the selected policy. We can uniquely determine this expected
reward given the candidate communication policy and the particular observability and communication cost parameters, as well as the COM-MTDP model specified in Figures 2, 3,
and 4.
412

fiThe Communicative Multiagent Team Decision Problem

 P (hE0; T 0; R0 i ; haE ; aT i ; hE1; T 1; R1 i) =
PE (E 0 ; aE ; E 1 )  PT (hT 0 ; R0 i ; aT ; T 1 )  PR (hE 0 ; R0 i ; aE ; R1 )

Escort: Initial distribution, Pr(0E = 0) = 1
E 0

aE

E 1

PE

Destination  Destination 1
0; : : : ; 8
y
E 0 + 1
1
0; : : : ; 8 destroy E0 + 1 1
9
y Destination 1
9
destroy Destination 1

wait
E 0
1
Transport: Initial distribution, Pr(0T = 0) = 1
T 0

R0

aT

Destination


Destroyed


0; : : : ; 9

y-NOE
9:5

y-NOE
0; : : : ; 8:5 Destroyed y-normal
9; 9:5
Destroyed y-normal

6= Destroyed y-normal


wait

T 1

Destination
Destroyed
T 0 + 0:5
Destination
T 0 + 1
Destination
Destroyed
T 0

PT

1
1
1
1
1
1
1
1

Radar: Initial distribution, 8 2 f1; 2; : : : ; 8g, P r(0R = ) = 0:125
E 0

R0

aE

R1

PR

 E0 destroy Destroyed 1

 6= destroy
R0
1
 6= E0

R0
1

Figure 3: COM-MTDP model of transition probabilities for helicopter scenario (excludes
zero probability rows).

413

fiPynadath & Tambe

 
ff = 
E  
T

{ 
E = E  T  
RE , where agent Escort's possible observations of the radar
consist of 
RE = fpresent; destroyed; nullg
{ 
T = E  T  
RT , where agent Transport's possible observations of the radar
consist of 
RT = fdestroyed; nullg
 Off (s; haE ; aT i ; h!E ; !T i) = OE (s; haE ; aT i ; !E )  OT (s; haE ; aT i ; !T )
{ OE (hE ; T ; R i ; haE ; aT i ; hE ; T ; !RE i) =
E

R

aE

!RE

OE

destroyed destroy destroyed 1
destroyed 6= destroy null
1
R 1; : : : ; 9

present 1
6= R 1; : : : ; 9

null
1
{ OT (hE ; T ; R i ; haE ; aT i ; hE ; T ; !RT i) =



T
R
0; : : : ; 9:5 
0; : : : ; 9:5 
0; : : : ; 9:5 

aE

!RT

destroy destroyed
destroy
null 1
6= destroy null
destroyed 

null

OT

e (R T )(1 )
e (R T )(1 )

1
1

 2 [0; 1]

Figure 4: COM-MTDP model of observability for helicopter scenario. These tables exclude
both zero probability rows and input feature columns from which O is independent. For example, both agents' observation functions are independent of the
transport's selected action, so neither table includes a aT column.

414

fiThe Communicative Multiagent Team Decision Problem

Figure 5: Suboptimality of silent and Jennings policies.

Figure 6: Suboptimality of STEAM policy under both low and medium costs of miscoordination.
5.2 Experimental Results
Figures 5 and 6 plot how much utility the team can expect to lose by following the Jennings,
silent, and the two STEAM policies instead of the locally optimal communication policy
(thus, higher values mean worse performance). We can immediately see that the Jennings
and silent policies are significantly suboptimal for many possible domain configurations. For
example, not surprisingly, the surface for the policy, Jff, peaks (i.e., it does most poorly)
when the communication cost is high and when the observability is high, while the silent
policy does poorly under exactly the opposite conditions.
Previously published results (Jennings, 1995) demonstrated that the Jennings policy
led to better team performance by reducing waste of effort produced by alternate policies
like our silent one. These earlier results focused on a single domain, and Figure 5 partially
confirms their conclusion and shows that the superiority of the Jennings policy over the
silent policy extends over a broad range of possible domain configurations. On the other
hand, our COM-MTDP results also show that there is a significant subclass of domains (e.g.,
when communication cost and observability are high) where the Jennings policy is actually
inferior to the silent policy. Thus, with our COM-MTDP model, we can characterize the
types of domains where the Jennings policy outperforms the silent policy and vice versa.
415

fiPynadath & Tambe

Figure 6 shows the expected value lost by following the two STEAM policies. We can
view STEAM as trying to intelligently interpolate between the Jennings and silent policies
based on the particular domain properties. In fact, under a low setting for Cmt , we see
two thresholds, one along each dimension, at which STEAM switches between following the
Jennings and silent policies, and its suboptimality is highest at these thresholds. Under
a medium setting for Cmt , STEAM does not exhibit a threshold along the dimension of
communication cost, due to the increased cost of miscoordination. Under both settings,
STEAM's performance generally follows the better of those two fixed policies, so its maximum suboptimality (0.587 under both settings) is significantly lower than that of the silent
(0.700) and Jennings' (1.000) policies. Furthermore, STEAM outperforms the two policies
on average, across the space of domain configurations, as evidenced by its mean suboptimality of 0.063 under low Cmt and 0.083 under medium Cmt . Both values are significantly
lower than the silent policy's mean of 0.160 and the Jennings' policy's mean of 0.161. Thus,
we have been able to quantify the savings provided by STEAM over less selective policies
within this example domain.
However, within a given domain configuration, STEAM must either always or never
communicate, and this inexibility leads to significant suboptimality across a wide range
of domain configurations. On the other hand, Figure 6 also shows that there are domain
configurations where STEAM is locally optimal. In this relatively small-scale experimental
testbed, there is no need to incur STEAM's suboptimality, because the agents can compute
the superior locally optimal policy in under 5 seconds. In larger-scale domains, on the other
hand, the increased complexity of the locally optimal policies may render its execution
infeasible. In such domains, STEAM's constant-time execution would potentially make it a
preferable alternative. This analysis suggests a possible spectrum of algorithms that make
different optimality-eciency tradeoffs.
To understand the cause of STEAM's suboptimality, we can examine its performance
more deeply in Figures 7 and 8, which plot the expected number of messages sent using
STEAM (with both low and medium Cmt ) vs. the locally optimal policy, at observability
values of 0.3 and 0.7. STEAM's expected number of messages is either 0 or 1, so STEAM
can make at most two (instantaneous) transitions between them: one threshold value each
along the observability and communication cost dimensions.
From Figures 7 and 8, we see that the optimal policy can be more exible than STEAM
by specifying communication contingent on Escort's beliefs beyond simply the achievement
of GR. For example, consider the messages sent under low Cmt in Figure 7, where STEAM
matches the locally optimal policy at the extremes of the communication cost dimension.
Even if the communication cost is high, it is still worth sending message GR in states where
Transport is still very far from the destination. Thus, the surface for the optimal policy,
makes a more gradual transition from always communicating to never communicating. We
can thus view STEAM's surface as a crude approximation to the optimal surface, subject
to STEAM's fewer degrees of freedom.
We can also use Figures 7 and 8 to identify the domain conditions under which joint
intentions theory's prescription of attaining mutual belief is or is not optimal. In particular,
for any domain where the observability is less than 1, the agents will not attain mutual belief
without communication. In both Figures 7 and 8, there are many domain configurations
where the locally optimal policy is expected to send fewer than 1 GR message. Each of
416

fiThe Communicative Multiagent Team Decision Problem

Figure 7: Expected number of messages sent by STEAM and locally optimal policies when
the observability is 0.3.

Figure 8: Expected number of messages sent by STEAM and locally optimal policies when
the observability is 0.7. Under both settings, STEAM sends 0 messages.

417

fiPynadath & Tambe

Figure 9: Suboptimality of locally optimal policy.
these configurations represents a domain where the locally optimal policy will not attain
mutual belief in at least one case. Therefore, attaining mutual belief is suboptimal in those
configurations!
These experiments illustrate that STEAM, despite its decision-theoretic communication
selectivity, may communicate suboptimally under a significant class of domain configurations. Previous work on STEAM-based, real-world, agent-team implementations informally
noted suboptimality in an isolated configuration within a more realistic helicopter transport domain (Tambe, 1997). Unfortunately, this previous work treated that suboptimality
(where the agents communicated more than necessary) as an isolated aberration, so there
was no investigation of the degree of such suboptimality, nor of the conditions under which
such suboptimality may occur in practice. We re-created these conditions within the experimental testbed of this section by using a medium Cmt . The resulting experiments (as shown
in Figure 7) illustrated that the observed suboptimality was not an isolated phenomenon,
but, in fact, that STEAM has a general propensity towards extraneous communication in
situations involving low observability (i.e., low likelihood of mutual belief) and high communication costs. This result matches the situation where the \aberration" occurred in the
more realistic domain.
The locally optimal policy is itself suboptimal with respect to the globally optimal
policy, as we can see from Figure 9. Under domain configurations with high observability,
the globally optimal policy has the escort wait an additional time step after destroying
the radar and then communicate only if the transport continues ying nap-of-the-earth.
The escort cannot directly observe which method of ight the transport has chosen, but
it can measure the change in the transport's position (since it maintains a history of its
past observations) and thus infer the method of ight with complete accuracy. In a sense,
the escort following the globally optimal policy is performing plan recognition to analyze
the transport's possible beliefs. It is particularly noteworthy that our domain specification
does not explicitly encode this recognition capability. In fact, our algorithm for finding the
globally optimal policy does not even make any of the assumptions made by our locally
observable policy (i.e., single agent is deciding whether to communicate or not, regarding
a single message, at a single point in time); rather, our general-purpose search algorithm
traverses the policy space and \discovers" this possible means of inference on its own. We
418

fiThe Communicative Multiagent Team Decision Problem

expect that such COM-MTDP analysis can provide an automatic method for discovering
novel communication policies of this type in other domains, even those modeling real-world
problems.
Indeed, by exploiting this discovery capability within our example domain, the globally
optimal policy gains a slight advantage in expected utility over the locally optimal policy,
with a mean difference of 0.011, standard deviation of 0.027, and maximum of 0.120. On the
other hand, our domain-independent code never requires more than 5 seconds to compute
the locally optimal policy in this testbed, while our domain-independent search algorithm
always required more than 150 minutes to find the globally optimal policy. Thus, through
Theorem 7, we have used the COM-MTDP model to construct a communication policy
that, for this testbed domain, performs almost optimally and outperforms existing teamwork theories, with a substantial computational savings over finding the globally optimal
policy. Although these results hold for an isolated communication decision, we expect the
relative performance of the policies to stay the same even with multiple decisions, where the
inexibility of the suboptimal policies will only exacerbate their losses (i.e., the shapes of
the graphs would stay roughly the same, but the suboptimality magnitudes would increase).
6. Summary

The COM-MTDP model is a novel framework that complements existing teamwork research
by providing the previously lacking capability to analyze the optimality and complexity of
team decisions. While grounded within economic team theory, the COM-MTDP's extensions to include communication and dynamism allow it to subsume many existing multiagent
models. We were able to exploit the COM-MTDP's ability to represent broad classes of
multiagent team domains to derive complexity results for optimal agent teamwork under
arbitrary problem domains. We also used the model to identify domain properties that can
simplify that complexity.
The COM-MTDP framework provides a general methodology for analysis across both
general domain subclasses and specific domain instantiations. As demonstrated in Section 4,
we can express important existing teamwork theories within a COM-MTDP framework and
derive broadly applicable theoretical results about their optimality. Section 5 demonstrates
our methodology for the analysis of a specific domain. By encoding a teamwork problem as
a COM-MTDP, we can use the leverage of our general-purpose software tools (available in
Online Appendix 1) to evaluate the optimality of teamwork based on potentially any other
existing theory, as demonstrated in this paper using two leading instantiations of joint
intentions theory. In combining both theory and practice, we can use the theoretical results
derived using the COM-MTDP framework as the basis for new algorithms to extend our
software tools, just as we did in translating Theorem 7 from Section 4 into an implemented
algorithm for locally optimal communication in Section 5. We expect that the COM-MTDP
framework, the theorems and complexity results, and the reusable software will form a basis
for further analysis of teamwork, both by ourselves and others in the field.

419

fiPynadath & Tambe
7. Future Work for COM-MTDP Team Analysis

While our initial COM-MTDP results are promising, there remain at least three key areas
where future progress in COM-MTDPs is critical. First, analysis using COM-MTDPs (such
as the one presented in Section 5) requires knowledge of the rewards, transition probabilities, and observation probabilities, as well as of the competing policies governing agent
behavior. It may not always be possible to have such a model of the domain and agents'
policies readily available. Indeed, other proposed team-analysis techniques (Nair, Tambe,
Marsella, & Raines, 2002b; Raines, Tambe, & Marsella, 2000), do not require a priori handcoding of such models, but rather acquire them automatically through machine learning
over large numbers of runs. Also, in the interests of combating computational complexity
and improved understandability, some researchers emphasize the need for multiple models
at multiple levels of abstraction, rather than focusing on a single model (Nair et al., 2002b).
For instance, one level of the model may focus on the analysis of the individual agents' actions in support of a team, while another level may focus on interactions among subteams
of a team. We can potentially extend the COM-MTDP model in both of these directions
(i.e., machine learning of model parameters, and hierarchical representations of the team to
provide multiple levels of abstraction).
Second, it is important to extend COM-MTDP analysis to other aspects of teamwork
beyond communication. For instance, team formation (where agents may be assigned specific roles within the team) and reformation (where failure of individual agents leads to role
reassignment within in the team) are key problems in teamwork that appear suitable for
COM-MTDP analysis. Such analysis may require extensions to the COM-MTDP framework (e.g., explicit modeling of roles). Ongoing research (Nair, Tambe, & Marsella, 2002a)
has begun investigating the impact of such extensions and their applications in domains
such as RoboCup Rescue (Kitano, Tadokoro, Noda, Matsubara, Takahashi, Shinjoh, & Shimada, 1999). Analysis of more complex team behaviors may require further extensions
to the COM-MTDP model to explicitly account for additional aspects of teamwork (e.g.,
notions of authority structure within teams).
Third, extending COM-MTDP analysis beyond teamwork to model other types of coordination may require relaxation of COM-MTDP's assumption of seless agents receiving
the same joint reward. More complex organizations may require modeling other non-joint
rewards. Indeed, enriching the COM-MTDP model in this manner may enable analysis of some of the seminal work in multiagent coordination in the tradition of PGP and
GPGP (Decker & Lesser, 1995; Durfee & Lesser, 1991). Such enriched models may first
require new advances in the mathematical foundations of our COM-MTDP framework, and
ultimately contribute towards the emerging sciences of agents and multiagent systems.
Acknowledgments

This article is a significantly extended version of a paper, \Multiagent Teamwork: Analyzing
the Optimality and Complexity of Key Theories and Models", by the same authors, in the
Proceedings of the International Joint Conference on Autonomous Agents and Multi-Agent
Systems, 2002. This article extends the initial content by providing proofs missing in the
original paper, as well as new theoretical results, a detailed description of our experimental
420

fiThe Communicative Multiagent Team Decision Problem

setup, new experimental results, and additional discussion and explanations of key points.
This research was supported by DARPA award No. F30602-98-2-0108, under the Control
of Agent Based Systems program, and managed by AFRL/Rome Research Site. We would
like to thank Daniel Bernstein, Ashish Goel, Daniel Marcu, Stacy Marsella, Ranjit Nair,
and Paul Rosenbloom for valuable discussion and feedback. We also thank the anonymous
reviewers for their helpful comments and suggestions.
References

Bernstein, D. S., Zilberstein, S., & Immerman, N. (2000). The complexity of decentralized
control of Markov decision processes. In Proceedings of the Conference on Uncertainty
in Artificial Intelligence, pp. 32{37.
Boutilier, C. (1996). Planning, learning and coordination in multiagent decision processes.
In Proceedings of the Conference on Theoretical Aspects of Rationality and Knowledge,
pp. 195{210.
Boutilier, C., Dean, T., & Hanks, S. (1999). Decision-theoretic planning: Structural assumptions and computational leverage. Journal of Artificial Intelligence Research,
11, 1{93.
Cohen, P. R., & Levesque, H. J. (1991a). Confirmation and joint action. In Proceedings of
the International Joint Conference on Artificial Intelligence.
Cohen, P. R., & Levesque, H. J. (1991b). Teamwork. Nous, 25 (4), 487{512.
Decker, K., & Lesser, V. (1995). Designing a family of coordination algorithms. In Proceedings of the International Conference on Multi-Agent Systems.
Dunin-Keplicz, B., & Verbrugge, R. (1996). Collective commitments. In International
Conference on Multi-Agent Systems, pp. 56{63.
Durfee, E., & Lesser, V. (1991). Partial global planning: a coordination framework for
distributed planning. IEEE transactions on Systems, Man and Cybernetics, 21 (5).
Goldberg, D., & Mataric, M. J. (1997). Interference as a tool for designing and evaluating multi-robot controllers. In Proceedings of the National Conference on Artificial
Intelligence, pp. 637{642.
Grosz, B. (1996). Collaborating systems. Artificial Intelligence Magazine, 17 (2), 67{85.
Grosz, B., & Kraus, S. (1996). Collaborative plans for complex group actions. Artificial
Intelligence, 86, 269{358.
Grosz, B. J., & Sidner, C. L. (1990). Plans for discourse. In Cohen, P. R., Morgan,
J., & Pollack, M. E. (Eds.), Intentions in Communication, pp. 417{444. MIT Press,
Cambridge, MA.
Ho, Y.-C. (1980). Team decision theory and information structures. Proceedings of the
IEEE, 68 (6), 644{654.
Jennings, N. (1995). Controlling cooperative problem solving in industrial multi-agent
systems using joint intentions. Artificial Intelligence, 75, 195{240.
421

fiPynadath & Tambe

Kitano, H., Tadokoro, S., Noda, I., Matsubara, H., Takahashi, T., Shinjoh, A., & Shimada,
S. (1999). Robocuprescue: Search and rescue for large-scale disasters as a domain for
multiagent research. In Proceedings of the IEEE International Conference on Systems,
Man and Cybernetics.
Levesque, H. J., Cohen, P. R., & Nunes, J. (1990). On acting together. In Proceedings of
the National Conference on Artificial Intelligence.
Marschak, J., & Radner, R. (1971). The Economic Theory of Teams. Yale University Press,
New Haven, CT.
Nair, R., Tambe, M., & Marsella, S. (2002a). Team formation for reformation for multiagent domains like robocup rescue. In Proceedings of the International Symposium on
RoboCup.
Nair, R., Tambe, M., Marsella, S., & Raines, T. (2002b). Automated assistants for analyzing
team behaviors. Journal of Autonomous Agents and Multiagent Systems, to appear.
Papadimitriou, C. H., & Tsitsiklis, J. N. (1987). The complexity of Markov decision processes. Mathematics of Operation Research, 12 (3), 441{450.
Peshkin, L., Kim, K.-E., Meuleau, N., & Kaelbling, L. P. (2000). Learning to cooperate via
policy search. In Proceedings of the Conference on Uncertainty in Artificial Intelligence, pp. 489{496.
Pynadath, D. V., & Tambe, M. (2002). An automated teamwork infrastructure for heterogeneous software agents and humans. Journal of Autonomous Agents and MultiAgent Systems: Special Issue on Infrastructure and Requirements for Building Research Grade Multi-Agent Systems, to appear.
Pynadath, D. V., Tambe, M., Chauvat, N., & Cavedon, L. (1999). Toward team-oriented
programming. In Jennings, N. R., & Lesperance, Y. (Eds.), Intelligent Agents VI:
Agent Theories, Architectures and Languages, pp. 233{247. Springer-Verlag.
Raines, T., Tambe, M., & Marsella, S. (2000). Automated agents that help humans understand team behaviors. In Proceedings of the International Conference on Autonomous
Agents.
Rich, C., & Sidner, C. (1997). COLLAGEN: When agents collaborate with people. In
Proceedings of the International Conference on Autonomous Agents.
Smallwood, R. D., & Sondik, E. J. (1973). The optimal control of partially observable
Markov processes over a finite horizon. Operations Research, 21, 1071{1088.
Smith, I. A., & Cohen, P. R. (1996). Toward a semantics for an agent communications
language based on speech-acts. In Proceedings of the National Conference on Artificial
Intelligence, pp. 24{31.
Sonenberg, E., Tidhar, G., Werner, E., Kinny, D., Ljungberg, M., & Rao, A. (1994). Planned
team activity. Tech. rep. 26, Australian AI Institute.
Tambe, M. (1997). Towards exible teamwork. Journal of Artificial Intelligence Research,
7, 83{124.
422

fiThe Communicative Multiagent Team Decision Problem

Tambe, M., Pynadath, D. V., Chauvat, N., Das, A., & Kaminka, G. A. (2000). Adaptive
agent integration architectures for heterogeneous team members. In Proceedings of
the International Conference on Multi-Agent Systems, pp. 301{308.
Tambe, M., & Zhang, W. (1998). Towards exible teamwork in persistent teams. In Proceedings of the International Conference on Multi-Agent Systems, pp. 277{284.
Tidhar, G. (1993). Team-oriented programming: Preliminary report. Tech. rep. 41, Australian Artificial Intelligence Institute.
Xuan, P., Lesser, V., & Zilberstein, S. (2001). Communication decisions in multi-agent
cooperation: Model and experiments. In Proceedings of the International Conference
on Autonomous Agents, pp. 616{623.
Yen, J., Yin, J., Ioerger, T. R., Miller, M. S., Xu, D., & Volz, R. A. (2001). CAST:
Collaborative agents for simulating teamwork. In Proceedings of the International
Joint Conference on Artificial Intelligence, pp. 1135{1142.
Yoshikawa, T. (1978). Decomposition of dynamic team decision problems. IEEE Transactions on Automatic Control, AC-23 (4), 627{632.

423

fiJournal of Artificial Intelligence Research 16 (2002) 359-387

Submitted 12/01; published 6/02

Collective Intelligence, Data Routing and Braess' Paradox

David H. Wolpert

NASA Ames Research Center, Mailstop 269-2
Moffett Field, CA 94035

Kagan Tumer

NASA Ames Research Center, Mailstop 269-3
Moffett Field, CA 94035

dhw@ptolemy.arc.nasa.gov
kagan@ptolemy.arc.nasa.gov

Abstract

We consider the problem of designing the the utility functions of the utility-maximizing
agents in a multi-agent system (MAS) so that they work synergistically to maximize a global
utility. The particular problem domain we explore is the control of network routing by
placing agents on all the routers in the network. Conventional approaches to this task have
the agents all use the Ideal Shortest Path routing Algorithm (ISPA). We demonstrate that
in many cases, due to the side-effects of one agent's actions on another agent's performance,
having agents use ISPA's is suboptimal as far as global aggregate cost is concerned, even
when they are only used to route infinitesimally small amounts of trac. The utility
functions of the individual agents are not \aligned" with the global utility, intuitively
speaking. As a particular example of this we present an instance of Braess' paradox in
which adding new links to a network whose agents all use the ISPA results in a decrease
in overall throughput. We also demonstrate that load-balancing, in which the agents'
decisions are collectively made to optimize the global cost incurred by all trac currently
being routed, is suboptimal as far as global cost averaged across time is concerned. This
is also due to \side-effects", in this case of current routing decision on future trac. The
mathematics of Collective Intelligence (COIN) is concerned precisely with the issue of
avoiding such deleterious side-effects in multi-agent systems, both over time and space.
We present key concepts from that mathematics and use them to derive an algorithm
whose ideal version should have better performance than that of having all agents use
the ISPA, even in the infinitesimal limit. We present experiments verifying this, and also
showing that a machine-learning-based version of this COIN algorithm in which costs are
only imprecisely estimated via empirical means (a version potentially applicable in the real
world) also outperforms the ISPA, despite having access to less information than does the
ISPA. In particular, this COIN algorithm almost always avoids Braess' paradox.
1. Introduction

There is a long history of AI research on the design of distributed computational systems,
stretching from Distributed AI (Huhns, 1987) through current work on multi-agent systems
(MAS's) (Claus & Boutilier, 1998; Hu & Wellman, 1998a; Jennings, Sycara, & Wooldridge,
1998; Sandholm, Larson, Anderson, Shehory, & Tohme, 1998; Sycara, 1998). When the
individual agents in such a system each have personal utility functions they are trying to
maximize and we also have a `world utility' that rates the possible dynamic histories of
the overall system, such a MAS constitutes a `collective'. In this paper we are particularly
concerned with agents that use machine learning techniques (e.g., Reinforcement Learning

c 2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiWolpert & Tumer
(RL) Kaelbing, Littman, & Moore, 1996; Sutton & Barto, 1998; Sutton, 1988; Watkins &
Dayan, 1992) to try to maximize their utilities.
The field of Collective Intelligence (COIN) is concerned with the central design problem
for collectives (Wolpert, Tumer, & Frank, 1999; Wolpert & Tumer, 1999): How, without
any detailed modeling of the overall system, can one set utility functions for the individual
agents in a COIN so that the overall dynamics reliably and robustly achieves large values
of the provided world utility? In other words, how can we leverage an assumption that
our learners are individually fairly good at what they do, to have the collective as a whole
perform well? 1
An example of where this question looms very large is the problem of how to optimize the
ow of certain entities (e.g., information packets, cars) from sources to destinations across
a network of routing nodes. Here we are concerned with the version of the problem in
which \optimization" consists of minimizing aggregate cost incurred by the entities owing
to their destinations, and where an agent controls the routing decisions of each node in
the network. This problem underlies the distributed control of a large array of real-world
domains, including internet routing, voice/video communication, trac ows, etc. From
the COIN perspective, the problem reduces to the question of what goals one ought to
provide to each router's agent so that each agent's self-interestedly pursuing its own utility
results in maximal throughput of the entire system (\incentive engineering").
In this paper we investigate the application of recently developed COIN techniques,
to this routing domain. Like all work concerning COINs, these techniques are designed
to be very broadly applicable, and in particular are not designed for the routing domain.
Accordingly, their performance in this domain serves as a good preliminary indication of
their more general usefulness.
To ground the discussion, we will concentrate on the telecommunications data routing
problem where the entities being routed are packets. Currently, many real-world algorithms
for this problem are based on the Shortest Path Algorithm (SPA). In this algorithm each
routing node in the network is controlled by an agent who maintains a \routing table" of the
\shortest paths" (i.e., sequences of links having minimal total incurred costs) from its node
to each of the possible destination nodes in the net. Then at each moment the agent satisfies
any routing requests for a particular destination node by sending all its packets down the
associated shortest path. Many Ideal SPA (ISPA) algorithms exist for eciently computing
the shortest path when agent-to-agent path-cost communication is available and the costs
for traversing each agent's node are unvarying in time, e.g., Dijkstra's Algorithm (Ahuja,
Magnanti, & Orlin, 1993; Bertsekas & Gallager, 1992; Deo & Pang, 1984; Dijkstra, 1959).
If a non-infinitesimal amount of trac is to be routed to a particular destination at some
moment by some agent, then that agent's sending all that trac down a single path will
not result in minimal cost, no matter how that single path is chosen. However if it must
choose a single path for all its trac, and if the routing decisions by all other agents are
fixed, then tautologically by using the ISPA the agent chooses the best such path, as far as
the trac it is routing is concerned. Accordingly, in the limit of routing an infinitesimally
1. The lack of detailed modeling ensures that we do not face the problems of \brittleness" that sometimes
accompany mismatch between the real world and the assumptions concerning it built into non-adaptive,
\hard-wired" agents in large MAS's. In turn, this lack of modeling is what causes us to concentrate on
adaptive, RL-based agents.

360

fiCollective Intelligence, Data Routing and Braess' Paradox
small amount of trac, with all other agents' strategies being a \background", the ISPA is
the optimal (least aggregate incurred cost) routing strategy for the trac of the associated
single agent considered individually.
One might hope that more generally, if the agent must allot all of its trac to a single
path and all other agents' trac decisions are fixed, then its choosing that path via the
ISPA would be the choice that minimizes total incurred cost of all trac across the net, at
least in the limit of infinitesimally little trac. This is not the case though, because in using
the SPA the agent is not concerned with the deleterious side-effects of its actions on the
costs to the trac routed by other agents (Korilis, Lazar, & Orda, 1997a; Wolpert et al.,
1999). The problem is made all the worse if the other agents are allowed to change their
decisions in response to our agent's decision. In the extreme case, as elaborated below, if
all agents were to try to minimize their personal costs via ISPA's, then the agents would
actually all receive higher cost than would be the case under an alternative set of strategies.
This is an instance of the famous Tragedy Of the Commons (TOC) (Hardin, 1968).
Deleterious side-effects need not be restricted to extend over space; they can also extend
over time. Indeed, consider the algorithm of having all agents at a given moment make
routing decisions that optimize global cost incurred by the trac currently being routed,
an algorithm often called \load-balancing" (LB) (Heusse, Snyers, Guerin, & Kuntz, 1998).
By definition, LB avoids the deleterious side-effects over space that can result in the TOC
for the costs incurred by the trac currently being routed. However, due to side-effects
over time, even conventional LB can be suboptimal as far as global cost averaged across
time is concerned. Intuitively, one would have to use \load-balancing over time" to ensure
truly optimal performance. So even if one could somehow construct a distributed protocol
governing the the agents that caused them to implement LB, still one would not have
gotten theme to all act in a perfectly coordinated fashion. Such diculties make this an
appropriate domain in which to investigate how well COIN techniques work in practice.
Real-world SPA's (RSPA) work by applying an ISPA to the estimated costs for traversing
each path of every agent. Typically those estimates will be in error because agent-to-agent
communication is not instantaneous, and therefore routing tables may be based on out of
date information. More generally though, even if that communication were instantaneous,
the cost to traverse an agent's node may be different by the time the packet arrives at
that node. Accordingly, in general the performance of RSPA's is bounded above by that
of the associated ISPA. In this paper we do not wish to investigate such topics, but rather
to highlight the issue of side-effects. Accordingly we \rig the game" in our experimental
comparisons in favor of the SPA, by using ISPA's rather than RSPA's.
In general, even without side-effects, determining the optimal solution to a ow problem
(e.g., determining what the loads on each link need to be to maximize throughput on a
non-cooperative data network) can be nontractable (Ahuja et al., 1993; Orda, Rom, & Sidi,
1993b). Therefore, we will concern ourselves with providing good solutions that avoid the
diculties the ISPA has with side-effects. It is not our aim here to present algorithms
that find the best possible (perfectly load-balanced over time) solution. Previous work on
using machine learning to improve routing has sometimes resulted in better performance
than (non-idealized) SPA's (Littman & Boyan, 1993; Boyan & Littman, 1994; Stone, 2000;
Marbach, Mihatsch, Schulte, & Tsisiklis, 1998). That work has not grappled with the
central COIN design problem however.
361

fiWolpert & Tumer
In Section 2 we discuss SPA's deficiencies and in particular their manifestations in
Braess' paradox. Then, in Section 3 we present the theory of collective intelligence, an
approach that promises to overcome those deficiencies. We then discuss the routing model
we will use in our experiments, and show how the theory of COINs can be applied to that
model to provide an alternative to shortest path algorithms in Section 3. In Section 5
we present simulation results with that model comparing ISPA to COINs. These results
demonstrate that in networks running ISPA, the per packet costs can be as much as 32
% higher than in networks running algorithms based on COIN theory. In particular, even
though it only has access to imprecise estimates of costs (a handicap that does not hold for
ISPA), the COIN-based algorithm almost always avoids Braess' paradox, in stark contrast
to the ISPA. In that the cost incurred with ISPA's is presumably a lower bound on that
of an SPA not privy to instantaneous communication, the implication is that COINs can
outperform such real-world SPA's. We conclude that the techniques of the field of collective
intelligence can be highly effective in designing the utility functions of the members of a MAS
to ensure they work in a coordinated and ecient manner to optimize overall performance.
2. Suboptimality of Shortest Path Routing and Braess Paradox

In this section we first demonstrate the suboptimality of an SPA when we have multiple
agents making simultaneous routing decisions, where no agent knows ahead of time the
other's choice, and therefore does not know ahead of time exactly what the costs will be.
We then demonstrate that such suboptimality can hold even when only one agent is making
a decision, and it knows what decisions the others have previously made. Next we present
Braess' paradox, a particularly pointed instance of these effects (for other discussion of
Braess' paradox in SPA routing, see Bass, 1992; Cohen & Kelly, 1990; Cohen & Jeffries,
1997; Hogg, 1995; Glance & Hogg, 1995; Korilis, Lazar, & Orda, 1999).

2.1 Suboptimality of SPA
Perhaps the simplest example of how individual greed on the part of all agents can lead
to their collective detriment occurs when two agents determine that their shortest path is
through a shared link with a limited capacity, while both have a second option that is slightly
less preferable. In such a case, their using the common link degrades the performance of
both parties, since due to limited capacity the performance of that link will quickly fall
below that of their second option.
More precisely, consider the case where the shared link has a cost given by x3 when
traversed by x packets, and where each router has an optional second link to the destination
where the cost for trac x to traverse such a second link is 2x. Acting alone, with a single
packet to send, they would both send that packet through the shared link (cost of 1).
However by both doing so, they incur a larger cost (cost of 8) than if they had both used
their second choices (cost of 4). Without knowing what each other will do ahead of time
(information not conventionally contained in routing tables), the agents will necessarily
have mistaken cost estimates and therefore make incorrect routing decisions. In this, even
in the limit of differentially small packets, use of SPA will lead to a wrong routing decision.
362

fiCollective Intelligence, Data Routing and Braess' Paradox
2.2 Suboptimality of ISPA
We now analyze a situation where the routers may know what the loads are but are each
acting to optimize the delays experienced by their packets alone. Consider the network
shown in Figure 1. Two source routers X and Y each send one packet at a time, with X
sending to either intermediate router A or B , and Y sending to either B or C . This type
of network may arise in many different topologies as a subnetwork. Accordingly, diculties
associated with this network can also apply to many more complex topologies.

y
JJ
J

y



 JJ

 J

A

B

JJ




JJ 


J
y

y

C

JJ

X

JJ 


J
y












Y

Figure 1: Independent decisions at the source
Let xA , xB , yB , and yC , be the packet quantities at a particular fixed time t, at A, B ,
or C , and originating from X or Y , as indicated. At t, each source has one packet to send.
So each of our variables is binary, with xA + xB = yB + yC = 1. Have Vi (zi ) be the cost,
per packet, at the single instant t, at router i, when the total number of packets at that
instant on that router is zi . So the total cost incurred by all packets at the time t, G(~x; ~y),
equals xA VA (xA ) + (xB + yB )VB (xB + yB ) + (yC )VC (yC ).
In an ISPA, X chooses which of xA or xB = 1 so as to minimize the cost incurred by
X's packet alone, gX (~x)  xA VA (xA ) + xB VB (xB + yB ). In doing this the ISPA ignores the
yB VB (xB + yB ) term, i.e., it ignores the \side effects" of X 's decision. Real-world SPA's
typically try to approximate this by having X choose either A or B according to whether
VA (0) or VB (yB ) is smaller, where those two values can be estimated via pings, for example.
The right thing to do from the point of view of minimizing the global cost of course
is instead to have X minimize G(~x; ~y), or more precisely, the components of G(~x; ~y) that
depend on X . Writing it out for this case, X ought to act to minimize xA VA (xA ) + (xB +
yB )VB (xB + yB ). Due to the constraint that xA + xB = 1, this means sending down A iff
VA (1) < (yB + 1)VB (yB + 1) yB VB (yB ), which differs from the ISPA result in that X is
concerned with the full cost of going through router B , not just the portion of that cost
that its packet receives.
In the context of this example, this G-minimizing algorithm constitutes \load-balancing"
(LB). Note that so long as sgn[VA (0) VB (yB ) yB VB0 (yB )] 6= sgn[VA (0) VB (yB )], even
in the limit of infinitesimally small trac (so that xA + xB equals some infinitesimal ),
ISPA and LB still disagree. LB considers side-effects of current routing decisions on other
trac currently being routed. However because it does not consider side-effects of routing
decisions on future trac, even LB may not optimize global cost averaged across all time,
363

fiWolpert & Tumer
depending on the details of the system. However through the use of \effect sets" COINs
can account even for such delayed side-effects2 .

2.3 Braess' Paradox
Let us conclude this section with an illustration of Braess' paradox (Bass, 1992; Cohen
& Kelly, 1990; Cohen & Jeffries, 1997; Glance & Hogg, 1995; Hogg, 1995; Korilis, Lazar,
& Orda, 1997b; Korilis et al., 1999), a phenomenon that dramatically underscores the
ineciency of the ISPA. This apparent \paradox" is perhaps best illustrated through a
highway trac example first given by Bass (Bass, 1992): There are two highways connecting
towns S and D. The cost associated with traversing either highway (either in terms of tolls,
or delays) is V1 + V2 , as illustrated in Net A of Figure 2. So when x = 1 (a single traveler) for
either path, total accrued cost is 61 units. If on the other hand, six travelers are split equally
among the two paths, they will each incur a cost of 83 units to get to their destinations. Now,
suppose a new highway is built connecting the two branches, as shown in Net B in Figure 2.
Further, note that the cost associated with taking this highway is not particularly high (in
fact for any load higher than 1, this highway has a lower cost than any other highway in the
system). The benefit of this highway is illustrated by the dramatically reduced cost incurred
by the single traveler: by taking the short-cut, one traveler can traverse the network at a
cost of 31 units (2 V1 + V3 ). Adding a new road has seemingly reduced the traversal cost
dramatically.

V2

V1

"y
bDb
"
"
bb
y"
"
byV1

V2

y
bb
"yV2
"
bb ""
b"
yS

V1

Net A
Figure 2: Hex network with V1 = 10x ;

"ybDb
"
"
bb
"y"
byV1

V3

y



yb
"yV2
bb
"
bb"yS""
V2

Net B
= 50 + x ;

V3

= 10 + x

However consider what happens when six travelers are on the highways in net B. If
each agent uses an ISPA, then at equilibrium each of the three possible paths contains two
travelers.3 Due to overlaps in the paths however, this results in each traveler incurring a
cost of 92 units, which is higher than than what they incurred before the new highway was
built. The net effect of adding a new road is to increase the cost incurred by every traveler.
This phenomenon is known as Braess' paradox.
2. A detailed discussion and proof of the suboptimality of LB is shown in appendix A. Since LB is not
used in current systems and is hard to imagine ever being used, our experiments do not consider it; it is
discussed here for pedagogical reasons.
3. We have in mind here the Nash equilibrium for this problem, where no traveler (or equivalently, no
router) can gain advantage by changing strategies.

364

fiCollective Intelligence, Data Routing and Braess' Paradox
3. Mathematics of Collective Intelligence

One common solution to these types of side-effect problems is to have particular agents
of the network (e.g., a \network manager" Korilis, Lazar, & Orda, 1995) dictate certain
choices to other agents. This solution can incur major brittleness and scaling problems
however. Another kind of approach, which avoids the problems of a centralized manager,
is to provide the agents with extra incentives that can induce them to take actions that are
undesirable to them from a strict SPA sense. Such incentive can be in the form of \taxes"
or \tolls" added to the costs associated with traversing particular links to discourage the
use of those links. Such schemes in which tolls are superimposed on the agents' goals are
a special case of the more general approach of replacing the goal of each agent with a new
goal. These new goals are specifically tailored so that if they are collectively met the system
maximizes throughput. A priori, a agent's goal need have no particular relation with the
SPA-type cost incurred by that agent's packets. Intuitively, in this approach, we provide
each agent with a goal that is \aligned" with the global objective, with no separate concern
for of that goal's relation to the SPA-type cost incurred by the trac routed by that agent.
In this section, we summarize the salient aspects of a Collective Intelligences (COIN) (Wolpert,
Wheeler, & Tumer, 2000; Wolpert & Tumer, 1999). In this paper we consider systems that
consist of a set of agents, connected in a network, evolving across a set of discrete, consecutive time steps, t 2 f0; 1; :::g. Without loss of generality, we let all relevant characteristics of
a agent  at time t | including its internal parameters at that time as well as its externally
visible actions | be encapsulated by a Euclidean vector  ;t with components  ;t;i . We
call this the \state" of agent  at time t, and let  ;t be the state of all agents at time t,
while  is the state of all agent across all time.
World utility, G( ), is a function of the state of all agents across all time. When 
is an agent that uses a Machine Learning (ML) algorithm to \try to increase" its private
utility, we write that private utility as g ( ), or more generally, to allow that utility to
vary in time, g; ( ).
We assume that  encompasses all physically relevant variables, so that the dynamics
of the system is deterministic (though of course imprecisely known to anyone trying to
control the system). Note that this means that all characteristics of an agent  at t = 0
that affects the ensuing dynamics of the system must be included in  ;0 . For ML-based
agents, this includes in particular the algorithmic specification of its private utility, typically
in the physical form of some computer code (the mathematics can be generalized beyond
ML-based agents, as elaborated in Wolpert & Tumer, 1999).
Here we focus on the case where our goal, as COIN designers, is to maximize world utility
through the proper selection of private utility functions. Intuitively, the idea is to choose
private utilities that are aligned with the world utility, and that also have the property
that it is relatively easy for us to configure each agent so that the associated private
utility
P
achieves a large value. In this paper, all utilities we consider are of the form t Rt ( ;t )
P
for reward functions Rt (simply t Rt ( ;t ) for non-time-varying utilities). From now on,
we will only consider world utilities whose associated set of fRt g are all time-translations of
one another. In particular, as shown below, overall network throughput is expressible this
way.
365

fiWolpert & Tumer
We need a formal definition of the concept of having private utilities be \aligned" with
Constructing such a formalization is a subtle exercise. For example, consider systems
where the world utility is the sum of the private utilities of the individual agents. This might
seem a reasonable candidate for an example of \aligned" utilities. However such systems
are examples of the more general class of systems that are \weakly trivial". It is well-known
that in weakly trivial systems each individual agent greedily trying to maximize its own
utility can lead to the tragedy of the commons (Hardin, 1968; Crowe, 1969) and actually
minimize G. In
particular, this can be the case when private
utilities are independent of
P
P
time and G =  g . Evidently, at a minimum, having G =  g is not sucient to ensure
that we have \aligned" utilities; some alternative formalization of the concept is needed.
Note that in the simple network discussed in Section 2.1, the utilities are weakly trivial,
since G(~x; ~y) = gX (~x) + gy (~y ). This provides another perspective on the suboptimality of
ISPA in that network.
G.

A more careful alternative formalization of the notion of aligned utilities is the concept
of \factored" systems. A system is factored at time  when the following holds for each
agent  individually: A change at time  to the state of  alone, when propagated across
time, will result in an increased value of g; ( ) if and only if it results in an increase for
G( ) (Wolpert & Tumer, 1999).
For a factored system, the side-effects of any change to 's t =  state that increases its
private utility cannot decrease world utility. There are no restrictions though on the effects
of that change on the private utilities of other agents and/or times. In particular, we don't
preclude an agent's algorithm at two different times from \working at cross-purposes" to
each other, so long as at both moments the agent is working to improve G. In game-theoretic
terms, in factored systems optimal global behavior corresponds to the agents' always being
at a private utility Nash equilibrium (Fudenberg & Tirole, 1991). In this sense, there can
be no tragedy of the commons for a factored system. As a trivial example, a system is
factored for g; = G 8, a system conventionally called a `team game'.

Furthermore, if our system is factored with respect to private utilities fg; g, we want
each agent to be in a state at time  that induces as high a value of the associated private
utility as possible (given the initial states of the other agents). Assume  is ML-based and
able to achieve fairly large values of most private utilities we are likely to set it for time
 , i.e., assume that given that private utility g; , the rest of the components of  ; are
set by 's algorithm in such a way so as to achieve a relatively high value of g; . So our
problem becomes determining for what fg; g the agents will best be able to achieve high
g (subject to each other's actions) while also causing dynamics that is factored for G and
the fg; g.

Define the effect set of the agent-time pair (;  ) at  , C(eff
; ) ( ), as the set of all agents
 0 ;t which under the forward dynamics of the system have non-zero partial derivative with
respect to the state of agent  at t =  . Intuitively, (;  )'s effect set is the set of the states
of all agents  0 ;t that would be affected by a change in the state of agent  at time  .
Next, for any set  of agents (0 ; t), define CL ( ) as the \virtual" vector formed by
clamping the components of the vector  delineated in  to an arbitrary fixed value, which
366

fiCollective Intelligence, Data Routing and Braess' Paradox
in this paper is set to 0. 4 This operation creates a new state vector (e.g., worldline) where
the clamped components of that worldline (e.g., one player's action at a particular time
step) are \zeroed" (e.g., removed from the system).
The value of the wonderful life utility (WLU for short) for  is defined as:
W LU ( )

 G( )

G(CL ( )):

(1)

In particular, we are interested in the WLU for the effect set of agent-time pair (;  ). This
WLU is the difference between the actual world utility and the virtual world utility where
all agent-time pairs that are affected by (;  ) have been clamped to a zero state while the
rest of  is left unchanged.
Since we are clamping to ~0, we can loosely view (;  )'s effect set WLU as analogous
to the change in world utility that would have arisen if (;  ) \had never existed", hence
the name of this utility - cf. the Frank Capra movie. Note however, that CL is a purely
\fictional", counter-factual operator, in that it produces a new  without taking into account
the system's dynamics. The sequence of states the agent-time pairs in  are clamped to
in constructing the WLU need not be consistent with the dynamical laws of the system.
This dynamics-independence is a crucial strength of the WLU. It means that to evaluate
the WLU we do not try to infer how the system would have evolved if agent 's state were
set to ~0 at time  and the system evolved from there. So long as we know  , extending over
all time, , and the function G, we know the value of WLU.
As mentioned above, regardless of the system dynamics, having g; = G 8 means the
system is factored at time  .

Theorem: Regardless of the system dynamics, setting
factored system at time  .

g;

=

W LUC eff

(; )

8 results in a

Proof: The second term, G(CLC eff ( )) is, by definition, independent of  ; . Therefore
(; )

a change to only the (;  ) component of  will only affect the first term, G( ). Therefore
the effect of such a change on the value of the world utility is the same as its effect on the
value of the wonderful life utility. QED.
Since factoredness does not distinguish the team game and wonderful life utilities, we
need some other means of deciding which to use as our choice of fg; g. To determine
this, note that since each agent is operating in a large system, it may experience diculty
discerning the effects of its actions on G when G sensitively depends on all the agents in the
system. Therefore each  may have diculty learning from past experience what to do to
achieve high g; when g; = G. In particular, in routing in large networks, having private
rewards given by the world reward functions means that to provide each router with its
reward at each time step we need to provide it the full throughput of the entire network
at that step. This is usually infeasible in practice. Even if it weren't though, using these
private utilities would mean that the routers face a very dicult task in trying to discern
4. The choice of the clamping parameter used in an associated COIN can affect its performance. However
within wide ranges, it doesn't affect whether such a COIN outperforms alternatives like team games.

367

fiWolpert & Tumer
the effect of their actions on their rewards, and therefore would likely be unable to learn
their best routing strategies.
This problem can be mitigated by using effect set WLU as the private utility, since the
subtraction of the clamped term removes much of the \noise" of the activity of other agents,
leaving only the underlying \signal" of how the agent in question affects the utility (this
reasoning is formalized as the concept of \learnability" in Wolpert & Tumer, 1999). Accordingly, one would expect that setting private utilities to WLU's ought to result in better
performance than having g; = G 8;  . This is the primary theoretical consideration that
we leverage in the COIN techniques investigated in this paper.
In practice, we will sometimes only be able to estimate the \primary", most prominent
portion of the effect set. Technically, the associated WLU is not the effect set WLU, and
therefore not exactly factored. However assuming that that associated WLU is close enough
to being factored, we would expect the advantage in learnability with such a WLU to still
result in better performance than would using g; = G 8;  (see Wolpert et al., 2000;
Wolpert & Tumer, 1999). Indeed, for the sake of improving learnability, sometimes we will
elect to exclude certain agent-time pairs from our estimate of the effect set of (;  ), even
if we are sure that that are affected by  ; . This will be the case if we expect that the
changes in G due to varying  ; that are \mediated" through those agent-time pairs are
relatively insignificant, and therefore effectively constitute noise for the learning process, so
that their effect on learnability is more important than their effect on factoredness.
4. Collective Intelligence for Network Routing

In this section, we use the theory summarized in Section 3 to derive individual goals for
each router, in the form of private utility functions to be maximized by appropriate choice
of routing decisions. The routers tried to achieve those maximizations by using algorithms
that only require limited knowledge of the state of the network (in particular knowledge
that is readily available to routers in common real data networks). In our simulations each
router used a Memory Based (MB) machine learning algorithm (nearest neighbor) to make
routing decisions. More precisely, for each potential routing decision, the routers look for
the past state that most closely closely matches their current state (e.g., load). They then
assign an "estimated" utility value to each potential routing decision and select the action
with the highest estimated utility value. We call this algorithm an MB COIN5 .

4.1 Model Description
To apply the COIN formalism to a network routing model, we must formally describe
that as a set of deterministically evolving vectors  ;t . In the model used in this paper, at
any time step all trac at a router is a set of pairs of integer-valued trac amounts and
associated ultimate destination tags. At each such time step t, each router r sums the
integer-valued components of its current trac at that time step (one component for each
5. Relatively minor details of the algorithm concerning exploration/exploitation issues along with a \steering" parameter are discussed at the end of this section.

368

fiCollective Intelligence, Data Routing and Braess' Paradox
ultimate destination) to get its instantaneous load. We write that load as:
zr (t)



X
d

xr;d (t);

where the index d runs over ultimate destinations, and xr;d (t) is the total trac at time
going from r towards d. After its instantaneous load at time t is evaluated, the router
sends all its trac to the next downstream routers, in a manner governed by the underlying
routing algorithm. We indicate such \next routers" by writing:
t

xr;d (t)

=

X
r0

xr;d;r0 (t);

where r0 is the next router for trac (r; d), i.e., the first stop on the path to be followed
from router r to ultimate destination d. After all such routed trac goes to those next
downstream routers, the cycle repeats itself, until all trac reaches its destinations.
In our simulations, for simplicity, trac was only introduced into the system (at the
source routers) at the beginning of successive disjoint waves of L consecutive time steps
each6 . We use (t) to indicate either the integer-valued wave number associated with time
t or the set of all times in that wave, as the context indicates.
In a real network, the cost of traversing a router depends on \after-effects" of recent
instantaneous loads, as well as the current instantaneous load. To simulate this effect, we
use time-averaged values of the load at a router rather than instantaneous load to determine
the cost a packet incurs in traversing that router. More formally, we define the router's
windowed load, Zr (t), as the running average of that router's load value over a window
of the previous W timesteps (W is always set to an integer multiple of L):
Zr (t)

 W1

t
X
t0 =t W +1

zr (t0 )

=

X
d

Xr;d (t);

where the value of Xr;d (t) is set by
Xr;d (t)

=

1

t
X

W 0
t =t W +1

xr;d (t0 )):

Intuitively, for large enough W , using such a window to determine costs across routers
means that typically those costs will only change substantially over time scales significantly
larger than that of the individual routing decisions. Formally, the windowed load is the
argument to a load-to-cost function, V (), which provides the cost accrued at time t by
each packet traversing the router at this timestep. That is, at time t, the cost for each
packet to traverse router r is given by V (Zr (t))7 . Note that in our model, the costs are
accrued at the routers, not the links. Also note that for simplicity we do not physically
instantiate the cost as a temporal delay in crossing a router. Different routers have different
6. L was always chosen to be the minimal number necessary for all trac to reach its destination before
the next wave of trac is initiated.
7. We also introduce \dummy routers" denoted by V0 () = 0 which help in translating the mathematics
into the simulations. Omitting them will have no effect on the simulations.

369

fiWolpert & Tumer
V (), to reect the fact that real networks have differences in router software and hardware
(response time, queue length, processing speed etc). For simplicity, W is the same for all
routers however. With these definitions, world utility is given by
G( )

=
=

X
t;r
X
t;r;d

=

X
t;r;d

=

X
t;r;d

zr (t) Vr (Zr (t))
xr;d (t)Vr (Zr (t))
0

xr;d (t)Vr @
xr;d (t)Vr

1

t
X

X

W 0
t =t W +1 d0

X
d0

1

xr;d0 (t0 )A

!

Xr;d0 (t)

(2)

:

Our equation for G explicitly demonstrates
that, as claimed above, in our representation
P
we can express G( ) as a sum of rewards, t Rt ( ;t ), where R( ;t ) can be written as function
of a pair of (r; d)-indexed vectors:
Rt (xr;d (t); Xr;d (t))

=

X
r;d

xr;d (t)Vr

X
d0

!

Xr;d0 (t)

:

Also as claimed, the Rt are temporal translations of one another.
Given this model, some of the components of  ;t must be identified with the values
xr;d;r0 (t) 8 r; d; r 0 and t, since those x's are set by the actions the agents will take. Since all
arguments of G must be components of  , we also include the Xr;d (t) 8r; d; t as components
of  ;t . Formally, for routing based on ML agents, the internal parameters of the ML agents
must also be included in  . This is because those parameters affect the routing, and in
turn are affected by it. So to have  evolve deterministically, since it includes the routing
variables, it must also contain internal parameters of the agents. We won't have any need
to explicitly delineate such variables here however, and will mostly phrase the discussion as
though there were no such internal parameters.
Now the values fxr;d;r0 (t 1)g 8r; d; r0 specify the values fxr;d (t)g 8r; d directly. Therefore, in concert with the fxr;d (t0 < t)g, they also set the fXr;d (t)g directly. Moreover in our
simulations the decisions fxr;d;r0 (t)g 8r; d; r0 fixed by the routing
algorithms at all times t
P
are given by a fixed function of the fxr;d (t)g and the fZr (t) = d0 Xr;d0 (t)g. So in point of
fact we can map the set of fxr;d;r0 (t 1); Xr;d0 (t)g 8r; d; r0 to the full set fxr;d;r0 (t)g 8r; d; r0 ,
not just to fxr;d (t)g. Accordingly, the xr;d;r0 undergo deterministic evolution. Since their
values across time set all the values of the Xr;d (t) across time, we see that the entire set of
the components of  ;t undergo deterministic evolution in this representation, as required.
For evaluating the wonderful life utility we will need to group the components of  ;t
into disjoint agents . Here we will have two types of agent, both types being indexed by
router-destination pairs. For each such agent index (r; d), the first agent type is the variable
Xr;d (t), and the second agent type is the Euclidean vector with components indexed by r 0 ,
(xr;d )r0 (t). In setting \actions" we are concerned with setting the states of the agents of
the second type. Accordingly, our learners will all be associated with agents of this second
370

fiCollective Intelligence, Data Routing and Braess' Paradox
type. Unless explicitly indicated otherwise, from now on we will implicitly have that second
type of agent in mind whenever we refer to a \agent" or use the symbol .

4.2 ISPA Routing and COIN Routing
Based on the COIN formalism presented in Section 3 and the model described above, we
now present the ISPA and COIN-based routing algorithms. At time step t, ISPA has access
to all the windowed loads at time step t 1 (i.e., it has access to Zr (t 1) 8r), and assumes
that those values will remain the same at all times  t. Note that for large window sizes
and times close to t, this assumption is arbitrarily accurate. Using this assumption, in
ISPA, each router sends packets along the path that it calculates will minimize the costs
accumulated by its packets.
The COIN-based routing algorithms, in contrast, do not have such direct access to the
Zr . So to evaluate the WLU for a agent (r; d) at any time  , such an algorithm must
estimate the (primary members of the) associated effect set. This means determining what
components of  ; will, under the dynamics of the system, be changed by altering any of the
components of the vector xr;d( ).
As a first approximation, we will ignore effects on trac that changing xr;d;r0 ( ) may
have that are \mediated" by the learning algorithms running in the system. That is, we
ignore changes that arise due to the the effects that changing xr;d;r0 ( ) has on rewards,
changes which induce changes in future training sets, which then in turn get mapped to
changes in the fxr;d;r0 (t)g (and therefore the fXr;d (t)g) via the learning algorithms running
on the agents.
As another approximation, we will ignore effects mediated by the routing algorithms'
observations of the state of the network. That is, we ignore changes in the fxr00 ;d0 ;r000 (t)g that
varying xr;d ( ) may cause due to associated changes in the state of the network perceived by
(r00 ; d0 )'s routing algorithm, changes that in turn cause that algorithm to modify its routing
decisions accordingly. We only consider the behavior of those routing algorithms that are
(potentially) directly affected by xr;d ( ) in that they (potentially) have to route packets
that, at time  , passed through r on the way to d. So in particular we ignore effects of
xr;d ( ) on the fxr00 ;d0 =
6 d;r000 (t)g.
Since all packets routed in a wave arrive at their destinations by the end of the wave,
these approximations mean that the only xr00 ;d00 ;r000 (t) that are in our estimate for xr;d ( )'s
effect set have t in the same wave as  . These are the only ones that are, potentially, directly
affected by the fxr;d;r0 (t)g by \chaining together" the sequence of xr00 ;d00 ;r000 (t) that get the
packets in xr;d (t) to their ultimate destination. Due to the wave nature of our simulations
though, the only xr00 ;d00 ;r000 (t) within  's wave that are affected by xr;d ( ) all have d00 = d.
For reasons of coding simplicity, we do not concern ourselves with whether t <  within a
given wave and then exclude some xr00 ;d00 ;r000 (t) accordingly. In other words, all t within  's
wave are treated equally.
So one set of members of xr;d ( )'s effect set is fxr00 ;d;r000 (t) 8r00; d; r000 ; t 2 ( )g. Note
that some of these members will be relatively unaffected by xr;d ( ) (e.g., those with r00 far
in the net away from r). Again for simplicity, we do not try to determine these and exclude
them. As with keeping the xr00 ;d;r000 (t <  ), this inclusion of extra agents in our estimate of
the effect set should hurt learnability, but in general should not hurt factoredness. Therefore
371

fiWolpert & Tumer
it should delay how quickly the learners determine their optimal policies, but it won't affect
the quality (for G) of those policies finally arrived at. Note also that trying to determine
whether some particular xr00 ;d;r000 (t 2 ( )) should be included in xr;d ( )'s effect set would
mean, in part, determining whether packets routed from (r; d) would have reached r00 if
(r; d) had made some routing decision different from the one it actually made. This would
be a non-trivial exercise, in general.
In contrast to the case with the xr00 ;d0 ;r000 (t), there are Xr00 ;d0 (t) with t in the future of  's
wave that both are affected by xr;d (t) and also are not excluded by any of our approximations
so far. In particular, the Xr00 ;d (t) with either r00 = r or r00 one hop away from r will be
1
directly affected by xr;d (t), for t 2 [W
i=0 ( + iL)) (cf. the definition of the X variables).
For simplicity, we restrict consideration of such Xr00 ;d variables to those with the same router
as r, r00 = r.
This final estimate for the effect set is clearly rather poor | presumably results better
than those presented below would accrue to use of a more accurate effect set. However it's
worth bearing in mind that there is a \self-stabilizing" nature to the choice of effect sets,
when used in conjunction with effect set WLU's. This nature is mediated by the learning
algorithms. If one assigns the same utility function to two agents, then the reward one
agent gets will be determined in part by what the other one does. So as it modifies its
behavior to try to increase its reward, that first agent will be modifying its behavior in a
way dependent on what the other agent does. In other words, if two agents are given the
same WLU because they are estimated to be in each other's effect set, then ipso facto they
will be in each other's effect set.
Using our estimate for the effect set, the WLU for (;  ) is given by the difference
between the total cost accrued in  's wave by all agents in the network and the cost accrued
by agents when all agents sharing 's destination are \erased." More precisely, any agent 
that has a destination d will have the following effect set WLU's, g; :
g; ( )=

=

G( )
X
t;r0 ;d0


=

G(CLC eff ( ))
(; )

xr0 ;d0 (t) Vr0
Vr0

X
d00

X
d0

!

X 

Xr0 ;d0 (t)

[ Xr0 ;d00 (t) (1

t;r0 ;d0

I (t

2[

xr0 ;d0 (t)(1

W 1
i=0 (

I (t

2 ( ))I (d0 = d))

+ iL))I (d00 = d)) ]

!

0
1
X
X
X
X
@
xr0 ;d0 (t) Vr0 (
Xr0 ;d00 (t))
xr0 ;d0 (t) Vr0 (
Xr0 ;d00 (t))A
d0
d00
d0 6=d
d00 6=d
t2( ) r0
0
1
X
X X
X
X
@
+
xr0 ;d0 (t) [Vr0 (
Xr0 ;d00 (t)) Vr0 (
Xr0 ;d00 (t))]A
(3)
0
0
00
00
W
1
r
d
d
d
=
6
d
t2[
( +iL)
X X

i=1

where I (:) is the indicator function that equals 1 if its argument is true, 0 otherwise.
To allow the learner to receive feedback concerning its actions in a wave immediately
following that wave rather than wait for  W L time steps, we will approximate the second
sum in that last equality, the one over times following  's wave, as zero. There is another
way we can view the resultant expression, rather than as an approximation to the effect
372

fiCollective Intelligence, Data Routing and Braess' Paradox
set WLU. That is to view it as the exact WLU of an approximation to the effect set, an
approximation which ignores effects on future windowed loads of clamping a current trac
level. Regardless of what view we adopt, presumably better performance could be achieved
if we did not implement this approximation.
Given this approximation, our WLU becomes a wave-indexed time-translation-invariant
WL \reward function" (WLR):
g; ( ;t2( ) )

X

X

t2( );r0

d0

=

X
d0 6=d

xr0 ;d0 (t) Vr0 (

xr0 ;d0 (t) Vr0 (

X
d00

X

d00 6=d

Xr0 ;d00 (t))
1

Xr0 ;d00 (t))A :

(4)

Notice that trac going from a router r0 6= r to a destination d0 6= d affects the value of
the WLR for agent (r; d). This reects the fact that WLR takes into account side-effects
of (r; d)'s actions on other agents. Note also that each r0 -indexed term contributing to the
WLR can be computed by the associated router r0 separately, from information available
to that router. Subsequently those terms can be propagated through the network to , in
much the same way as routing tables updates are propagated.
Given this choice of private utility, we must next specify how the COIN-based routing
algorithm collects the initial data that (in conjunction with this utility) is to be used to
guide the initial routing decisions that every agent with more than one routing option must
make. In our experiments that data was collected during a preliminary running of an ISPA.
In this preliminary stage, the routing decisions are made using the ISPA, but the resulting
actions are \scored" using the WLR given by Equation 3. We use the ISPA to generate the
routing decisions in the initial data since it is likely in practice that some kind of SPA will
be the routing algorithm running prior to \turning on" the COIN algorithm. Alternately
one can generate the initial data's routing decisions by having the routers make random
decisions, or by having them implement a sequence of decisions that \sweeps" across a grid
through the possible set of actions. The data collected in this stage provides us with initial
input-output training sets to be used by the machine learning algorithm on each agent: for
each router-destination agent, inputs are identified with windowed loads on outgoing links,
and the associated WLR values for the destination in question are the outputs.
After sucient initial data is collected using the ISPA, the system switches to using
the COIN algorithm to make subsequent routing decisions. In this stage, each agent routes
packets along the link that it estimates (based on the training set) would provide the best
WLR. To perform the estimation, the MB COIN makes use of a single-nearest-neighbor
algorithm as its learner. This algorithm simply guesses that the output that would ensue
from any candidate input is the same as the output of the element of the training set
that is the nearest neighbor (in input space) of that candidate input.8 In other words, the
learner finds the training set input-output pair whose input value (loads on outgoing links)
8. This is a very simple learning algorithm, and we use it here only to demonstrate the potential practical
feasibility of a COIN-based routing algorithm. The performance can presumably be improved if more
sophisticated learning algorithms (e.g., Q-learning Sutton & Barto, 1998; Watkins & Dayan, 1992) are
used.

373

fiWolpert & Tumer
is closest to that which would result from each potential routing decision. Then the learner
assigns the WLR associated with that training data pair as the estimate for what WLR
would result from said routing decision. These WLR values are then used to choose among
those potential routing decisions. The input-output data generated under this algorithm is
adding to the training set as it is generated.
In this routing algorithm, the routers only estimate how their routing decisions (as
reected in their loads at individual time steps) will affect their WLR values (based on
many agents' loads). It is also possible to calculate exactly how the routing decisions affect
the routers' WLR's if, unlike the MB COIN, we had full knowledge of the loads of all
agents in the system. In a way similar to ISPA, for each router we can evaluate the exact
WLR value that would ensue from each of its candidate actions, under the assumption
that windowed loads on all other routers are the same one wave into the future as they are
now. We call this algorithm for directly maximizing WLR (an algorithm we call the full
knowledge COIN, or FK COIN).
Note that under the assumption behind the FK COIN, the action  chooses in wave ( )
that maximizes WLR will also maximize the world reward. In other words, WL reward is
perfectly factored with respect to (wave-indexed) world reward, even though the associated
utilities are not related that way (due to inaccuracy in our estimate of the effect set). Due
to this factoredness, the FK COIN is equivalent to load balancing on world rewards. Since
LB in general results in inferior performance compared to LB over time, and since the FK
COIN is equivalent to LB, one might expect that its performance is suboptimal. Intuitively,
this suboptimality reects the fact that one should not choose the action only with regard
to its effect on current reward, but also with concern for the reward of future waves. In the
language of the COIN framework, this suboptimality can be viewed as a restatement of the
fact that for our inexactly estimated effect set, the system will not be perfectly factored.
The learning algorithm of the MB COIN as described is extraordinarily crude. In addition, the associated scheme for choosing an action is purely exploitative, with no exploration
whatsoever. Rather than choose some particular more sophisticated scheme and tune it to
fit our simulations, we emulated using more sophisticated algorithms in general. We did
this by modifying the MB COIN algorithm to occasionally have the FK COIN determine
a router's action rather than the purely greedy learner outlined above. The steering parameter discussed in Section 5.5 determines how often the routing decision is based on the
MB COIN as opposed to the FK COIN.
5. Simulation Results

In practice, it is very dicult to implement either FK COIN or LB. In this section we use
experiments to investigate behavior of algorithms that can conceivably be used in practice.
More precisely, based on the model and routing algorithms discussed above, we have performed simulations to compare the performance of ISPA and MB COIN across a variety of
networks, varying in size from five to eighteen routers. In all cases trac was inserted into
the network in a regular, non-stochastic manner at the sources. The results we report are
averaged over 20 runs. We do not report error bars as they are all lower than 0:05.
In Sections 5.1 - 5.4 we analyze trac patterns over four networks where ISPA suffers
from the Braess' paradox. In contrast, the MB COIN almost never falls prey to the paradox
374

fiCollective Intelligence, Data Routing and Braess' Paradox
for those networks (or for no networks we have investigated is the MB COIN significantly
susceptible to Braess' paradox). Then in Section 5.5 we discuss the effect on the MB
COIN's performance of the \steering" parameter which determines the intelligence of the
MB COIN.9

5.1 Bootes Network
The first network type we investigate is shown in Figure 3. It is in many senses a trivial
network, as in Net A, the sources do not even have any choices to make. The loads introduced at the sources do not change in time and are listed in Tables 1 and 2, along with the
performances of our algorithms.

y
@D@

V1

@
@@yV2
y
@@
AA
@y@V0
AyV0
AAy
@yS1
S2

y@D
@

V1

@@
y
@yV2
@@
AA
yV3 AyV0
@yV0
@@y
A
S1
S2 Ay

Net A

Net B
Figure 3: Bootes Network

Loads at (S1 ; S2 ) Net
1,1
A
B
2,1
A
B
2,2
A
B
4,2
A
B

ISPA MB COIN
6.35
6.35
8.35
5.93
8.07
8.07
10.40
7.88
9.55
9.55
10.88
9.71
10.41
10.41
11.55
10.41

Table 1: Average Per Packet Cost for BOOTES2 networks for V1 = 10 + log(1 + x) ;
4x2 ; V3 = log(1 + x) .

V2

=

The MB COIN results are identical to the ISPA results in the absence of the additional
link (Network A). However, Braess' paradox arises with ISPA, in that the addition of the
new link in network B degrades the performance of the ISPA in six of the eight trac
regimes and load-to-cost functions investigated. The MB COIN on the other hand is only
9. In Sections 5.1 - 5.4, the steering parameter is set at 0.5.

375

fiWolpert & Tumer

Loads at (S1 ; S2 ) Net ISPA MB COIN
1,1
A 30.35
30.35
B 20.35
20.35
2,2
A 35.55
35.55
B 40.55
34.99
4,2
A 41.07
41.07
B 50.47
44.13
6,3
A 44.63
44.63
B 51.40
44.63
Table 2: Average Per Packet Cost for BOOTES4 network for
10x ; V3 = log(1 + x) .

V1

= 50 + log(1 + x) ;

V2

=

hurt by the addition of the new link once, and manages to gainfully exploit it seven times.
When their behavior is analyzed infinitesimally, the MB COIN either uses the additional
link eciently or chooses to ignore it in those seven cases. Moreover, the MB COIN's
performance with the additional link is always better than the ISPA's. For example, adding
the new link causes a degradation of the performance by as much as 30 % (loads = f2; 1g)
for the ISPA, whereas for the same load vector MB COIN performance improves by 7 %.

5.2 Hex Network
In this section we revisit the network first discussed in Section 2.1 (redrawn in Figure 4 to
include the dummy agents). In Table 3 we give full results for the load-to-delay functions
discussed in that section. We then use load-to-cost functions which are qualitatively similar
to those discussed in Section 2.1, but which incorporate non-linearities that better represent
real router characteristics. That load-to-cost function and associated results are reported
in Table 4.

V2
V0
V1

"y
bDb
"
"
bb
y"
"
byV1
y
yV0
y
bb
"yV2
"
bb ""
b"
yS
Net A

V2
V0
V1

"ybDb
"
"
bb
"y"
byV1

y Vy3  yV0
yb
"yV2
bb
"
bb"yS""

Figure 4: Hex network

Net B

This network demonstrates that while the addition of a new link may be beneficial in
low trac cases, it leads to bottlenecks in higher trac regimes. For ISPA although the
376

fiCollective Intelligence, Data Routing and Braess' Paradox
per packet cost for loads of 1 and 2 drop drastically when the new link is added, the per
packet cost increases for higher loads. The MB COIN on the other hand uses the new
link eciently. Notice that the MB COIN's performance is slightly worse than that of the
ISPA in the absence of the additional link. This is caused by the MB COIN having to use
a learner to estimate the WLU values for potential actions whereas the ISPA simply has
direct access to all the information it needs (costs at each link).
Load Net ISPA MB COIN
1
A 55.50
55.56
B 31.00
31.00
2
A 61.00
61.10
B 52.00
51.69
3
A 66.50
66.65
B 73.00
64.45
4
A 72.00
72.25
B 87.37
73.41
Table 3: Average Per Packet Cost for HEX network for V1 = 50+ x ;
.

V2

= 10x ;

V3

= 10+ x

Load Net ISPA MB COIN
1
A 55.41
55.44
B 20.69
20.69
2
A 60.69
60.80
B 41.10
41.10
3
A 65.92
66.10
B 61.39
59.19
4
A 71.10
71.41
B 81.61
69.88
Table 4: Average Per Packet Cost for HEX network for
10x ; V3 = log(1 + x) .

V1

= 50 + log(1 + x) ;

V2

=

5.3 Buttery Network
The next network we investigate is shown in Figure 5. It is an extension to the simple
network discussed in Section 5.1. We now have doubled the size of the network and have
three sources that have to route their packets to two destinations (packets originating at
S1 go to D1 , and packets originating at S2 or S3 go to D2 ). Initially the two halves of the
network have minimal contact, but with the addition of the extra link two sources from the
two two halves of the network share a common router on their potential shortest path.
377

fiWolpert & Tumer

y

 TT

yD2

 TT
 T  T

TTy
TTy
y
V1 
V2
T
T
 V3
T
T yV1
V0 Ty
V0 Ty
T
T  @@
y @yS3
S1 Ty
S2 T
D1

y

 TT

yD2

 TT
 T  T

TTy
TTy
y
V1 
V2
T
T
 V3
T
 T
V0 Ty V3 y V0 Ty
y@V1
T 
T @
y S2 Ty @yS3
S1 T
D1

Net A

Net B
Figure 5: Buttery Network

Table 5 presents two sets of results: first we present results for uniform trac through
all three sources, and then results for asymmetric trac. For the first case, the Braess'
paradox is apparent in the ISPA: adding the new link is beneficial for the network at low
load levels where the average per packet cost is reduced by nearly 20%, but deleterious at
higher levels. The MB COIN, on the other hand, provides the benefits of the added link
for the low trac levels, without suffering from deleterious effects at higher load levels.
Loads (S1 ; S2 ; S3 ) Net ISPA MB COIN
1,1,1
A 112.1
112.7
B
92.1
92.3
2,2,2
A 123.3
124.0
B 133.3
122.5
4,4,4
A 144.8
142.6
B 156.5
142.3
3,2,1
A
81.8
82.5
B
99.5
81.0
6,4,2
A
96.0
94.1
B 105.3
94.0
9,6,3
A 105.5
98.2
B 106.7
98.8
Table 5: Average Per Packet Cost for BUTTERFLY network for V1 = 50+ log(1+ x) ;
10x ; V3 = log(1 + x).

V2

=

For the asymmetric trac patterns, the added link causes a drop in performance for the
ISPA, especially for low overall trac levels. This is not true for the MB COIN. Notice also
that in the high, asymmetric trac regime, the ISPA performs significantly worse than the
MB COIN even without the added link, showing that a bottleneck occurs on the right side
of network alone (similar to the Braess' paradox observed in Section 5.1).
378

fiCollective Intelligence, Data Routing and Braess' Paradox
5.4 Ray Network
In all the networks and trac regimes discussed so far the sources are the only routers with
more than one routing option. The final network we investigate is a larger network where
the number of routers with multiply options is significantly higher than in the previous
networks. Figure 6 shows the initial network (Net A) and the \augmented" network (Net
B), where new links have been added. The original network has relatively few choices for
the routers, as packets are directed toward their destinations along \conduits." The new
links are added in the augmented networks to provide new choices (crossing patterns) that
could be beneficial if certain of the original conduits experience large costs.

V2
V0
V1

bDb1 ""y
bDb2
"y
"
"
b"
b
y" V1 y"" bbyV1 bbyV2
"
y V0 y
yV0
yV0
yV
yV
y V2 y
JJ 


JJ 2 

 1
J 

J 

J%
yV3
V3 J
e
y
ee
%
%
e
y
y
%
S1
S2
Net A

V2
V0
V1

"ybDb1 ""ybDb2
"
"
"b
b
"yc" V1 "y" bbyV1 b#byV2
yVc3 cy yV0 V0 y #y#V3 yV0
y Vc2cyc ##yV#2
yV
JJ 

 c # JJ 

 1
J 
 #c#c J 

V3 J
e
ye #yV3 V3cy %J%
yV3
%
e
y
%
e
y
S2
S1

Figure 6: Ray network

Net B

Table 6 shows the simulation results for these networks (S1 and S2 send packets to D1
and D2 respectively). At low load levels both the ISPA and the MB COIN use the new links
effectively, although the MB COIN performs slightly worse. This is mainly caused by the
diculty encountered by the simple learner (single nearest neighbor algorithm) in quickly
learning the trac patterns in this large network. Unlike the ISPA however, the MB COIN
avoids the Braess' paradox in all cases except the very high trac regime. Moreover, even
there, the effect is significantly milder than that encountered by the ISPA.

5.5 Steering the MB COIN
The final aspect of COIN-based routing we investigate is the impact of the choice for the
value of the steering parameter. This parameter both controls the amount of exploration
the algorithm performs and determines the \intelligence" of the MB COIN at estimating
the surface directly calculated by the FK COIN. In Figures 7 - 8, the FK COIN results
correspond to setting the steering parameter of the MB COIN to 1:0. This provides an
upper bound on the performance that can be achieved though MB COIN.
For the HEX network (Figure 7), the performance at the worst setting for the MB COIN,
which corresponds to no steering, is comparable to ISPA. In contrast, with moderate steering
379

fiWolpert & Tumer

Loads at S1 andS2 ) Net ISPA MB COIN
2,2
A 143.6
143.7
B 124.4
126.9
3,3
A 154.6
154.9
B 165.5
151.0
4,4
A 165.4
166.0
B 197.7
165.6
6,6
A 186.7
187.4
B 205.1
191.6
Table 6: Average Per Packet Cost for RAY network for
10x ; V3 = 10 + log(1 + x).

= 50 + log(1 + x) ;

V2

=

180

80

Per Packet Delay

Per Packet Delay

85

V1

ISPA
FK COIN
MB COIN

75
70
65

ISPA
FK COIN
MB COIN

170
160
150
140

0

0.1 0.2 0.3 0.4
Steering Parameter

0.5

0

0.1 0.2 0.3 0.4
Steering Parameter

0.5

Figure 7: Impact of steering on Hex4 (left) and Ray4 (right) networks.
(0.5) the results are similar to that of the FK COIN, as the learner has more information
to work with (arising from the extra parts of the input space represented in the training
set due to the occasional use of the FK COIN), it bridges the gap between a suboptimal
algorithm susceptible to Braess' paradox and one which eciently avoids that paradox.
For the RAY network (Figure 7), the value of the steering parameter is more critical.
With no steering at all, the MB COIN performs poorly in this network | even worse than
ISPA. This is not surprising in that because there are many routing choices that affect
the performance, the simple memory-based learner needs proper \seeding" to be able to
perform well. Even with minimal steering though, the MB COIN quickly outperforms the
ISPA.
Finally, for both the Buttery and Bootes networks (Figure 8) the MB COIN needs
very little steering to perform well. Although for the Buttery network the performance of
MB COIN improves slightly with more information, it is significantly better than the ISPA
across the board.
380

fi105

Per Packet Delay

Per Packet Delay

Collective Intelligence, Data Routing and Braess' Paradox

ISPA
FK COIN
MB COIN

100

95

40
ISPA
FK COIN
MB COIN
35

90
0

0.1 0.2 0.3 0.4
Steering Parameter

0.5

0

0.1 0.2 0.3 0.4
Steering Parameter

0.5

Figure 8: Impact of steering on Buttery4 (left) and Bootes4 (right) networks.
6. Conclusion

Effective routing in a network is a fundamental problem in many fields, including data
communications and transportation. Using a shortest path algorithm (SPA) on each of the
routers to determine that router's decisions is a popular approach to this problem. However
under certain circumstances it suffers from a number of undesirable effects. One such effect is
Braess' paradox, where for the same pattern of introduced trac into a network, increasing
the capacity of that network results in lower overall throughput, due to the harmful sideeffects of the decisions made by each router on the trac in the rest of the system. Even
the theoretical load-balancing algorithm, which addresses some of these effects to produce
decisions that are optimal for any single moment of time, can still suffer from side-effects
that result in sub-optimal performance. This is because such effects extend across time
(i.e., what you do now affects performance later) as well as space.
The Collective Intelligence approach is a novel way of controlling distributed systems so
as to avoid deleterious side-effects of routing decisions. The central idea is to have learning
algorithms control the autonomous agents that constitute the overall distributed system.
In such a Collective Intelligence (COIN), the central issue is to determine the personal
objectives to be assigned to each of those autonomous agents. One wants to choose those
goals so that the greedy pursuit of those goals by the associated learning algorithms leads to
desirable behavior of the overall system. In this paper we have summarized the mathematics
of designing such goals and derived a routing algorithm based on that mathematics.
We ran computer simulations to compare a COIN-based algorithm with an ideal SPA
(whose performance upper-bounds all real-world SPA's) for routing. The COIN-based algorithm was severely handicapped. The estimation of the \effect sets" used by that algorithm
was exceedingly crude. In addition, the learning algorithms of the agents were particularly
unsophisticated, and therefore were not able to effectively maximize their individual performances. In contrast, the ideal SPA had access to more information concerning the state of
the system than the (real-world-implementable) COIN did, information that no real-world
SPA could access.
381

fiWolpert & Tumer
Despite these biases in favor of the ideal SPA, in our experiments the ideal SPA induced
average costs as much as 32 % higher than the COIN-based algorithm. Furthermore the
COIN-based algorithm almost always avoided the Braess' paradox that seriously diminished
the performance of the SPA.
These techniques have also been very successfully employed in many other, non-routing
domains, such as coordination of autonomous rovers (Tumer, Agogino, & Wolpert, 2002),
combinatorial optimization, \congestion games" (Wolpert & Tumer, 2001), and control of
data-upload from a planet (Wolpert, Sill, & Tumer, 2001). We conclude from these results
that the techniques of the field of collective intelligence can be highly effective in designing
the utility functions of the members of a MAS to ensure they work in a coordinated and
ecient manner to optimize overall performance. We are currently investigating extensions
of our COIN algorithm that involve novel goals for the agents, goals that are more \learnable" for the learning algorithms. We are also expanding the simulations to larger networks
using a commercial event driven simulator. Future work will focus on not making the approximation that current trac levels do not affect future windowed loads (Equation 3).
It will also involve investigating better estimates of effect sets, in particular not including
all agents with the same destination in one's effect set, and more generally using a more
\fine-grained" representation of the agents, for example including each packet's originating
source, to allow a more fine-grained effect set (and resultant WLU).
Acknowledgments

The authors thank Joe Sill and the reviewers for their helpful comments.
Appendix A. Suboptimality of Load-Balancing

In this appendix we we present an existence proof of the suboptimality of Load-Balancing
(LB) by explicitly constructing a situation where conventional LB is suboptimal.
Consider a system with discrete time, in which the source agent X under consideration
must route one packet to the (fixed) destination at each time step. Presume further that
no trac from any source agent other than X enters any of the agents X sends to, so that
trac coming from X is the sole source of any costs associated with X 's outbound links. Let
S (t) be the number of times our agent sent a packet down some link A in the W time steps
preceding t, and take s(t) = A; B to mean that the router uses link A or B , respectively, at
time t. Model queue backups and the like by having the cost to send a packet down link
A at time t be CA (S (t)=W ), and have the cost for our router to instead send the packet
down link B be CB (1 S (t)=W ), For simplicity we assume that both CA (:) and CB (:) are
monotonically increasing functions of their arguments.
Restrict attention to agents that work by having s(t) = A iff S (t)  k for some realvalued threshold k. The LB algorithm will choose s(t) = A iff CA (S (t)=W )  CB (1
S (t)=W ). So the LB algorithm's behavior is indistinguishable from this kind of threshold
algorithm, with k set so that CA (k=W ) = CB (1 k=W ). (We implicitly assume that CA (:)
and CB (:) are chosen so that such a solution exists for 1 < k < W 1.) The question is
382

fiCollective Intelligence, Data Routing and Braess' Paradox
what k should be to optimize total averaged cost across time, and in particular if that k is
the same as kLB , the k that LB uses.
Now as we go from one time step to the next, the routing decision made W time steps
ago drops out of the computation of S (t), while the routing decision just made is newly
included. In general, S (t + 1) = S (t) + 1 if the router just used A at time t and used link B
at the time W time steps into the past. On the other hand, S (t + 1) = S (t) 1 if the router
just used B and used A W time steps ago, while S (t + 1) = S (t) if the routing decision just
made is the same as the routing decision W time steps ago. So in general, S (t) can only
change by -1, 0, or +1 as we go from one time step to the next.
Consider cases where 1 < k < W 1, so that eventually the router must choose an A,
and at some subsequent time t the router switches from A to B . At that time s(t 1) = A
and s(t ) = B . This implies that S (t 1)  k; S (t ) > k. Define the value S (t 1) as k .
Note that S (t ) = k + 1, and k 1 < k  k.
Now for any time t0 , if S (t0 ) = k + 1, s(t0 + 1) = B , and the only possible next values
are S (t0 + 1) = k or S (t0 + 1) = k + 1, depending on the old decision s(t W ) that gets
dropped out of the window. Similarly, if S (t0 ) = k , s(t0 + 1) = A, and the only possible
next values are S (t0 + 1) = k or S (t0 + 1) = k + 1, again depending on the old decision
being dropped. So we see that once S (t0 ) 2 fk ; k + 1g, it stays there forever.
This means that because of the relationship between k and k , in any interval of W
consecutive time steps subsequent to t , the number of packets sent along A by router X
must be 2 (k 1; k +1]. (Note that it is possible to send k +1 packets along A, but not k 1
packets. Therefore the number sent along B must be 2 [W (k + 1); W (k 1)). Each
time that a packet is sent along A the cost incurred is the cost of link A with average trac
level S (t)=W , CA (S (t)=W ). Similarly, each time the link B is chosen, the cost incurred is
CB (1 S (t)=W ). Since S (t) 2 fk  ; k  + 1g, and both CA (:) and CB (:) are monotonically
increasing, the cost for sending the packet down link A 2 (CA ((k 1)=W ); CA ((k + 1)=W ],
and that for sending it down link B is contained in [CB (1 (k +1)=W ); CB (1 (k 1)=W )).
Now we know that the choice of A must have average frequency (across all time) between

k =W and (k  + 1)=W . Similarly, B will have average frequency between (1 (k  + 1)=W )
and 1 k =W . Accordingly, the average cost is bounded above by






k+1
k
k 1
k + 1
CA
+ 1
CB 1
;
(5)
W

W

W

W

where the first term provides the maximum possible average cost for using link A, while
the second term independently provides the maximum possible average cost for using link
B . Note that the actual cost will be lower since the two frequencies in this bound, one for
A and one for B , cannot both have the values indicated. Because k 1 < k   k and since
+1 , our upper bound is itself bounded above by
1 kW1 = 1 + W2 kW
k+1
W



CA

k+1
W



+



1+

2

k+1

W

W





CB

1+

2

k+1

W

W



:

(6)

The optimal k will result in an average cost lower than the minimum over all k of the
upper bound on average cost, given in Equation 6. So the average cost for the optimal
k is bounded above by the minimum over k of this upper bound. Lable this argmin of
Equation 6 k'.
383

fiWolpert & Tumer
Since other values of k besides kLB result in behavior equivalent to LB, it does not
suce to simply test if k' = kLB . Instead let us evaluate some lower bounds in a similar
fashion to how we evaluated upper bounds. Using the average frequencies discussed above,
the average cost is bounded below by:






k 1
1
k
k+1
k
CA
+ 1
CB 1
;
(7)
W

W

W

W

W

where the first term provides the minimum possible average cost for using link A, while the
second term provides the minimum possible average cost for using link B . Again, because
k 1 < k   k , the term is Equation 7 is further bounded below by
1

k
W



CA

1

k



W

+



1

2
W

1

k
W





CB

1

2

1

k

W



In particular this bound holds for the average cost of the LB algorithm:





kLB 1
kLB 1
2 kLB 1
2 kLB
CA
+ 1
CB 1
W

W

W

W

W

(8)

:

W

W

1



;

(9)

where as before kLB satisfies CA (kLB =W ) = CB (1 kLB =W ).
By appropriate choice of CA (:) and CB (:), we can ensure that the lower bound on the
cost with the LB algorithm (Equation 9 evaluated with k = kLB ) is higher than the upper
bound on the average cost incurred by the optimal algorithm (the minimum over k of Equation 6). That is, the best possible average cost achieved by load balancing will be worse
than the worst average cost that could arise through the optimal routing strategy. This
establishes that LB does not engage in optimal routing.

Example: Let CA (x) = x2 and CB (x) = x. Balancing the loads on A and B | setting

2
C
pA (S (t)=W ) = CB (1 S (t)=W ) | results in (S (t)=W ) = 1 S (t)=W , leading to kLB =W =
5 1 = :618. For W = 1000, the associated lower bound on average cost (Equation 9) is
2
(:618)3 + (:998 :618)2 = :380. On the other hand, with CA and CB given as above, Eq 6
k+1 2
is ( k+1 )3 + (1 + 2
) . Differentiating with respect to k and setting the result to
W

k0
W

W

1
3

W

1

p28+48=W

zero leads to
=
. For a window size of W = 1000, this yields
W +
6
k 0 =W = :548, a different result than kLB . Plugging into Equation 6, the upper bound on
the cost with k0 is (:549)3 + (1:002 :549)2 = :371, which is less than :380.
References

Ahuja, R. K., Magnanti, T. L., & Orlin, J. B. (1993). Network Flows. Prentice Hall, New
Jersey.
Bass, T. (1992). Road to ruin. Discover, 13 (5), 56{61.
Bertsekas, D., & Gallager, R. (1992). Data Networks. Prentice Hall, Englewood Cliffs, NJ.
Bonabeau, E., Henaux, F., Guerin, S., Snyders, D., Kuntz, P., & Theraulaz, G. (1999a).
Routing in telecommunications networks with \smart" and-like agents. (pre-print).
Bonabeau, E., Sobkowski, A., Theraulaz, G., & Deneubourg, J.-L. (1999b). Adaptive task
allocation inspired by a model of division of labor of social insects. (pre-print).
384

fiCollective Intelligence, Data Routing and Braess' Paradox
Boyan, J. A., & Littman, M. (1994). Packet routing in dynamically changing networks:
A reinforcement learning approach. In Advances in Neural Information Processing
Systems - 6, pp. 671{678. Morgan Kaufman.
Choi, S. P. M., & Yeung., D. Y. (1996). Predictive Q-routing: A memory based reinforcement
learning approach to adaptive trac control. In Touretzky, D. S., Mozer, M. C., &
Hasselmo, M. E. (Eds.), Advances in Neural Information Processing Systems - 8, pp.
945{951. MIT Press.
Claus, C., & Boutilier, C. (1998). The dynamics of reinforcement learning cooperative
multiagent systems. In Proceedings of the Fifteenth National Conference on Artificial
Intelligence, pp. 746{752, Madison, WI.
Cohen, J. E., & Jeffries, C. (1997). Congestion resulting from increased capacity in singleserver queueing networks. IEEE/ACM Transactions on Networking, 5 (2), 305{310.
Cohen, J. E., & Kelly, F. P. (1990). A paradox of congestion in a queuing network. Journal
of Applied Probability, 27, 730{734.
Crowe, B. L. (1969). The tragedy of the commons revisited. Science, 166, 1103{1107.
Deo, N., & Pang, C. (1984). Shortest path algorithms: Taxonomy and annotation. Networks,
14, 275{323.
Dijkstra, E. (1959). A note on two problems in connection with graphs. Numeriche Mathematics, 1 (269-171).
Fudenberg, D., & Tirole, J. (1991). Game Theory. MIT Press, Cambridge, MA.
Glance, N. S. (1993). Dynamics with Expectations. Ph.D. thesis, Stanford University.
Glance, N. S., & Hogg, T. (1995). Dilemmas in computational societies. In Lesser, V.
(Ed.), Proc. of the 1st International Conference on Multi-Agent Systems (ICMAS95),
pp. 117{124, Menlo Park, CA. AAAI Press.
Hardin, G. (1968). The tragedy of the commons. Science, 162, 1243{1248.
Heusse, M., Snyers, D., Guerin, S., & Kuntz, P. (1998). Adaptive agent-driven routing
and load balancing in communication networks. Advances in Complex Systems, 1,
237{254.
Hogg, T. (1995). Social dilemmas in computational ecosystems. In Proceedings of the
Fourteenth International Joint Conference on Artificial Intelligence, pp. 711{716, San
Mateo, CA. Morgan Kaufmann.
Hu, J., & Wellman, M. P. (1998a). Multiagent reinforcement learning: Theoretical framework and an algorithm. In Proceedings of the Fifteenth International Conference on
Machine Learning, pp. 242{250.
Hu, J., & Wellman, M. P. (1998b). Online learning about other agents in a dynamic multiagent system. In Proceedings of the Second International Conference on Autonomous
Agents, pp. 239{246.
Huberman, B. A., & Hogg, T. (1988). The behavior of computational ecologies. In The
Ecology of Computation, pp. 77{115. North-Holland.
385

fiWolpert & Tumer
Huberman, B. A., & Lukose, R. M. (1997). Social dilemmas and internet congestion. Science,
277 (5325), 535{537.
Huberman, B. A., & Hogg, T. (1993). The emergence of computational ecologies. In Nadel,
L., & Stein, D. (Eds.), 1992 Lectures in Complex Systems, Vol. V of SFI Studies in
the Sciences of Complexity, pp. 185{205. Addison-Wesley, Reading, MA.
Huhns, M. E. (Ed.). (1987). Distributed Artificial Intelligence. Pittman, London.
Jennings, N. R., Sycara, K., & Wooldridge, M. (1998). A roadmap of agent research and
development. Autonomous Agents and Multi-Agent Systems, 1, 7{38.
Kaelbing, L. P., Littman, M. L., & Moore, A. W. (1996). Reinforcement learning: A survey.
Journal of Artificial Intelligence Research, 4, 237{285.
Kelly, F. P. (1996). Modeling communication networks, present and future. Philosophical
Trends Royal Society of London A, 354, 437{463.
Korilis, Y. A., Lazar, A. A., & Orda, A. (1995). Architecting noncooperative networks.
IEEE Journal on Selected Areas in Communications, 13 (8), 1241{1251.
Korilis, Y. A., Lazar, A. A., & Orda, A. (1997a). Achieving network optima using Stackelberg routing strategies. IEEE/ACM Transactions on Networking, 5 (1), 161{173.
Korilis, Y. A., Lazar, A. A., & Orda, A. (1997b). Capacity allocation under noncooperative
routing. IEEE Transactions on Automatic Control, 42 (3), 309{325.
Korilis, Y. A., Lazar, A. A., & Orda, A. (1999). Avoiding the Braess paradox in noncooperative networks. Journal of Applied Probability, 36, 211{222.
Kumar, S., & Miikkulainen, R. (1997). Dual reinforcement Q-routing: An on-line adaptive
routing algorithm. In Artificial Neural Networks in Engineering, Vol. 7, pp. 231{238.
ASME Press.
Littman, M. L., & Boyan, J. (1993). A distributed reinforcement learning scheme for network
routing. In Proceedings of the 1993 International Workshop on Applications of Neural
Networks to Telecommunications, pp. 45{51.
Marbach, P., Mihatsch, O., Schulte, M., & Tsisiklis, J. (1998). Reinforcement learning for
call admission control and routing in integrated service networks. In Advances in
Neural Information Processing Systems - 10, pp. 922{928. MIT Press.
Orda, A., Rom, R., & Shimkin, N. (1993a). Competitive routing in multiuse communication
networks. IEEE/ACM Transactions on Networking, 1 (5), 510{521.
Orda, A., Rom, R., & Sidi, M. (1993b). Minimum delay routing in stochastic networks.
IEEE/ACM Transactions on Networking, 1 (2), 187{198.
Sandholm, T., Larson, K., Anderson, M., Shehory, O., & Tohme, F. (1998). Anytime coalition structure generation with worst case guarantees. In Proceedings of the Fifteenth
National Conference on Artificial Intelligence, pp. 46{53.
Sandholm, T., & Lesser, V. R. (1995). Issues in automated negotiations and electronic commerce: extending the contract net protocol. In Proceedings of the Second International
Conference on Multi-Agent Systems, pp. 328{335. AAAI Press.
386

fiCollective Intelligence, Data Routing and Braess' Paradox
Schaerf, A., Shoham, Y., & Tennenholtz, M. (1995). Adaptive load balancing: A study in
multi-agent learning. Journal of Artificial Intelligence Research, 162, 475{500.
Shenker, S. J. (1995). Making greed work in networks: A game-theoretic analysis of switch
service disciplines. IEEE Transactions on Networking, 3 (6), 819{831.
Stone, P. (2000). TPOT-RL applied to network routing. In Proceedings of the Seventeenth
International Machine Learning Conference, pp. 935{942. Morgan Kauffman.
Subramanian, D., Druschel, P., & Chen, J. (1997). Ants and reinforcement learning: A case
study in routing in dynamic networks. In Proceedings of the Fifteenth International
Conference on Artificial Intelligence, pp. 832{838.
Sutton, R. S. (1988). Learning to predict by the methods of temporal differences. Machine
Learning, 3, 9{44.
Sutton, R. S., & Barto, A. G. (1998). Reinforcement Learning: An Introduction. MIT Press,
Cambridge, MA.
Sycara, K. (1998). Multiagent systems. AI Magazine, 19 (2), 79{92.
Tumer, K., Agogino, A., & Wolpert, D. (2002). Learning sequences of actions in collectives
of autonomous agents. In Proceedings of the First International Joint Conference on
Autonomous Agents and Multi-Agent Systems, Bologna, Italy.
Tumer, K., & Wolpert, D. H. (2000). Collective intelligence and Braess' paradox. In
Proceedings of the Seventeenth National Conference on Artificial Intelligence, pp. 104{
109, Austin, TX.
Watkins, C., & Dayan, P. (1992). Q-learning. Machine Learning, 8 (3/4), 279{292.
Wolpert, D. H., Kirshner, S., Merz, C. J., & Tumer, K. (2000). Adaptivity in agent-based
routing for data networks. In Proceedings of the fourth International Conference of
Autonomous Agents, pp. 396{403.
Wolpert, D. H., Sill, J., & Tumer, K. (2001). Reinforcement learning in distributed domains:
Beyond team games. In Proceedings of the Seventeenth International Joint Conference
on Artificial Intelligence, pp. 819{824, Seattle, WA.
Wolpert, D. H., & Tumer, K. (1999). An Introduction to Collective Intelligence. Tech.
rep. NASA-ARC-IC-99-63, NASA Ames Research Center. URL:http://ic.arc.nasa.gov/ic/projects/coin pubs.html. To appear in Handbook of Agent Technology,
Ed. J. M. Bradshaw, AAAI/MIT Press.
Wolpert, D. H., & Tumer, K. (2001). Optimal payoff functions for members of collectives.
Advances in Complex Systems, 4 (2/3), 265{279.
Wolpert, D. H., Tumer, K., & Frank, J. (1999). Using collective intelligence to route internet
trac. In Advances in Neural Information Processing Systems - 11, pp. 952{958. MIT
Press.
Wolpert, D. H., Wheeler, K., & Tumer, K. (2000). Collective intelligence for control of
distributed dynamical systems. Europhysics Letters, 49 (6).

387

fiJournal of Artificial Intelligence Research 16 (2002) 259-292

Submitted 9/01; published 4/02

Efficient Reinforcement Learning Using
Recursive Least-Squares Methods
Xin Xu
Han-gen He
Dewen Hu

XUXIN_MAIL@263.NET
HEHANGEN@CS.HN.CN
DWHU@NUDT.EDU.CN

Department of Automatic Control
National University of Defense Technology
ChangSha, Hunan, 410073, P.R.China

Abstract
The recursive least-squares (RLS) algorithm is one of the most well-known algorithms used
in adaptive filtering, system identification and adaptive control. Its popularity is mainly due to its
fast convergence speed, which is considered to be optimal in practice. In this paper, RLS methods
are used to solve reinforcement learning problems, where two new reinforcement learning
algorithms using linear value function approximators are proposed and analyzed. The two
algorithms are called RLS-TD(  ) and Fast-AHC (Fast Adaptive Heuristic Critic), respectively.
RLS-TD(  ) can be viewed as the extension of RLS-TD(0) from  =0 to general 0  1, so it is
a multi-step temporal-difference (TD) learning algorithm using RLS methods. The convergence
with probability one and the limit of convergence of RLS-TD(  ) are proved for ergodic Markov
chains. Compared to the existing LS-TD(  ) algorithm, RLS-TD(  ) has advantages in
computation and is more suitable for online learning. The effectiveness of RLS-TD(  ) is
analyzed and verified by learning prediction experiments of Markov chains with a wide range of
parameter settings.
The Fast-AHC algorithm is derived by applying the proposed RLS-TD(  ) algorithm in the
critic network of the adaptive heuristic critic method. Unlike conventional AHC algorithm,
Fast-AHC makes use of RLS methods to improve the learning-prediction efficiency in the critic.
Learning control experiments of the cart-pole balancing and the acrobot swing-up problems are
conducted to compare the data efficiency of Fast-AHC with conventional AHC. From the
experimental results, it is shown that the data efficiency of learning control can also be improved
by using RLS methods in the learning-prediction process of the critic. The performance of
Fast-AHC is also compared with that of the AHC method using LS-TD(  ). Furthermore, it is
demonstrated in the experiments that different initial values of the variance matrix in RLS-TD(  )
are required to get better performance not only in learning prediction but also in learning control.
The experimental results are analyzed based on the existing theoretical work on the transient
phase of forgetting factor RLS methods.

1. Introduction
In recent years, reinforcement learning (RL) has been an active research area not only in machine
learning but also in control engineering, operations research and robotics (Kaelbling et al.,1996;
Bertsekas, et al.,1996; Sutton and Barto,1998; Lin,1992). It is a computational approach to
2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiXU, HE, & HU

understand and automate goal-directed learning and decision-making, without relying on
exemplary supervision or complete models of the environment. In RL, an agent is placed in an
initial unknown environment and only receives evaluative feedback from the environment. The
feedback is called reward or reinforcement signal. The ultimate goal of RL is to learn a strategy
for selecting actions such that the expected sum of discounted rewards is maximized.
Since lots of problems in the real world are sequential decision processes with delayed
evaluative feedback, the research in RL has been focused on theory and algorithms of learning to
solve the optimal control problem of Markov decision processes (MDPs) which provide an
elegant mathematical model for sequential decision-making. In operations research, many results
have been presented to solve the optimal control problem of MDPs with model information.
However, in reinforcement learning, the model information is assumed to be unknown, which is
different from the methods studied in operations research such as dynamic programming. In
dynamic programming, there are two elemental processes, which are the policy evaluation process and the policy improvement process, respectively. In RL, there are two similar processes.
One is called learning prediction and the other is called learning control. The goal of learning
control is to estimate the optimal policy or optimal value function of an MDP without knowing its
model. Learning prediction aims to solve the policy evaluation problem of a stationary-policy
MDP without any prior model and it can be regarded as a sub-problem of learning control.
Furthermore, in RL, learning prediction is different from that in supervised learning. As pointed
out by Sutton (1988), the prediction problems in supervised learning are single-step prediction
problems while those in reinforcement learning are multi-step prediction problems. To solve
multi-step prediction problems, a learning system must predict outcomes that depend on a future
sequence of decisions. Therefore, the theory and algorithms for multi-step learning prediction
become an important topic in RL and much research work has been done in the literature (Sutton,
1988; Tsitsiklis and Roy, 1997).
Among the proposed multi-step learning prediction methods, temporal-difference (TD)
learning (Sutton, 1988) is one of the most popular methods. It was studied and applied in the early
research of machine learning, including the celebrated checkers-playing program (Minsky, 1954;
Samuel, 1959). In 1988, Sutton presented the first formal description of temporal- difference
methods and the TD(  ) algorithm (Sutton,1988). Convergence results are established for tabular
temporal-difference learning algorithms where the cardinality of tunable parameters is the same
as that of the state space (Sutton, 1988; Watkins,et al.,1992; Dayan,et al., 1994; Jaakkola, et
al.,1994). Since many real-world applications have large or infinite state space, value function
approximation (VFA) methods need to be used in those cases. When combined with nonlinear
value function approximators, TD(  ) can not guarantee convergence and several results
regarding divergence have been reported in the literature (Tsitsiklis and Roy,1997). For TD(  )
with linear function approximators, also called linear TD(  ) algorithms, several convergence
proofs have been presented. Dayan (1992) showed the convergence in the mean for linear TD(  )
algorithms with arbitrary 0    1 . Tsitsiklis and Roy (1994) proved the convergence for a
special class of TD learning algorithms, known as TD(0), while in Tsitsiklis and Roy (1997), they
extended the early results to general linear TD(  ) case and proved the convergence with
probability one.
The above linear TD(  ) algorithms have rules for updating parameters similar to those in
gradient-descent methods. However, as in gradient-learning methods, a step-size schedule must
be carefully designed not only to guarantee convergence but also to obtain good performance. In
260

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

addition, there is inefficient use of data that slows the convergence of the algorithms. Based on
the theory of linear least-squares estimation, Brartke and Barto (1996) proposed two
temporal-difference algorithms called the Least-Squares TD(0) algorithm (LS-TD(0)) and the
Recursive Least- Squares TD(0) algorithm (RLS-TD(0)), respectively. LS-TD(0) and RLS-TD(0)
are more efficient in a statistical sense than conventional linear TD(  ) algorithms and they
eliminate the design of step-size schedules. Furthermore, the convergence of LS-TD(0) and
RLS-TD(0) has been provided in theory. The above two algorithms can be viewed as the
least-squares versions of conventional linear TD(0) methods. However, as has been shown in the
literature, TD learning algorithms such as TD(  ) with 0<  <1 that update predictions based on
the estimates of multiple steps are more efficient than Monte-Carlo methods as well as TD(0). By
employing the mechanism of eligibility traces, which is determined by  , TD(  ) algorithms
with 0<  <1 can extract more information from historical data. Recently, a class of linear
temporal-difference learning algorithms called LS-TD(  ) has been proposed by Boyan
(1999,2002), where least-squares methods are employed to compute the value-function estimation
of TD(  ) with 0   1. Although LS-TD(  ) is more efficient than TD(  ), it requires too much
computation per time-step when online updates are needed and the number of state features
becomes large.
In system identification, adaptive filtering and adaptive control, the recursive least-squares
(RLS) (Young,1984; Ljung, 1983; Ljung,1977) method, commonly used to reduce the
computational burden of least-squares methods, is more suitable for online estimation and control.
Although RLS-TD(0) makes use of RLS methods, it does not employ the mechanism of
eligibility traces. Based on the work of Tsitsiklis and Roy (1994, 1997), Boyan (1999,2002) and
motivated by the above ideas, a new class of temporal-difference learning methods, called the
RLS-TD(  ) algorithm, is proposed and analyzed formally in this paper. RLS-TD(  ) is superior
to conventional linear TD(  ) algorithms in that it makes use of RLS methods to improve the
learning efficiency in a statistical point of view and eliminates the step-size schedules.
RLS-TD(  ) has the mechanism of eligibility traces and can be viewed as the extension of
RLS-TD(0) from  =0 to general 0  1. The convergence with probability 1 of RLS-TD(  ) is
proved for ergodic Markov chains and the limit of convergence is also analyzed. In learning
prediction experiments for Markov chains, the performance of RLS-TD(  ) and TD(  ) as well as
LS-TD(  ) is compared, where a wide range of parameter settings is tested. In addition, the influence of the initialization parameters in RLS-TD(  ) is also discussed. It is observed that the
rate of convergence is influenced by the initialization of the variance matrix, which is a
phenomenon investigated theoretically in adaptive filtering (Moustakides, 1997; Haykin, 1996).
As will be analyzed in the following sections, there are two benefits of the extension from
RLS-TD(0) to RLS-TD(  ). One is that the value of  (0  1) will still affect the performance
of the RLS-based temporal-difference algorithms. Although for RLS-TD(  ), the rate of
convergence is mainly influenced by the initialization of the variance matrix, the bound of
approximation error is dominantly determined by the parameter  . The smallest error bound can
be obtained for  =1 and the worst bound is obtained for  =0. These bounds suggest that the
value of  should be selected appropriately to obtain the best approximation error. The second
benefit is that RLS-TD(  ) is more suitable for online learning than LS-TD(  ) since the
computation per time-step is reduced from O(K3) to O(K2), where K is the number of state
features.
The Adaptive-Heuristic-Critic (AHC) learning algorithm is a class of reinforcement learning
261

fiXU, HE, & HU

methods that has an actor-critic architecture and can be used to solve full reinforcement learning
or learning control problems. By applying the RLS-TD(  ) algorithm in the critic, the Fast-AHC
algorithm is proposed in this paper. Using RLS methods in the critic, the performance of learning
prediction in the critic is improved so that learning control problems can be solved more
efficiently. Simulation experiments on the learning control of the cart-pole balancing problem and
the swing-up of an acrobot are conducted to verify the effectiveness of the Fast-AHC method. By
comparing with conventional AHC methods which use TD(  ) in the critic, it is demonstrated that
Fast-AHC can obtain higher data efficiency than conventional AHC methods. Experiments on the
performance comparisons between AHC methods using LS-TD(  ) and Fast-AHC are also
conducted. In the learning control experiments, it is also illustrated that the initializing constant of
the variance matrix in RLS-TD(  ) influences the performance of Fast-AHC and different values
of the constant should be selected to get better performance in different problems. The above
results are analyzed based on the theoretical work on the transient phase of RLS methods.
This paper is organized as follows. In Section 2, an introduction on the previous linear
temporal-difference algorithms is presented. In Section 3, the RLS-TD(  ) algorithm is proposed
and its convergence (with probability one) is proved. In Section 4, a simulation example of the
value-function prediction for absorbing Markov chains is presented to illustrate the effectiveness
of the RLS-TD(  ) algorithm, where different parameter settings for different algorithms
including LS-TD(  ) are studied. In Section 5, the Fast-AHC method is proposed and the
simulation experiments on the learning control of the cart-pole balancing and the acrobot are
conducted to compare Fast-AHC with the conventional AHC method as well as the
LS-TD(  )-based AHC method. Some simulation results are presented and analyzed in detail. The
last section contains concluding remarks and directions for future work.

2. Previous Work on Linear Temporal-Difference Algorithms
In this section, a brief discussion on the conventional linear TD(  ) algorithm and RLS-TD(0) as
well as the LS-TD(  ) algorithm will be given. First of all, some mathematical notations are
presented as follows.
Consider a Markov chain whose states lie in a finite or countable infinite space S. The states
of the Markov chain can be indexed as {1,2,,n}, where n is possibly infinite. Although the
algorithms and the results in this paper are applicable to Markov chains with general state space,
the discussion in this paper will be restricted within the cases with a countable state space to
simplify the notation. The extension to Markov chains with a general state space only requires the
translation of the matrix notation into operator notation.
Let the trajectory generated by the Markov chain be denoted by {xt |t=0,1,2,; xt S}.The
dynamics of the Markov chain is described by a transition probability matrix P whose (i,j)-th
entry, denoted by pij, is the transition probability for xt+1=j given that xt=i. For each state transition
from xt to xt+1, a scalar reward rt is defined. The value function of each state is defined as follows:


V (i ) = E{  t rt x 0 = i}

(1)

t =0

where 0<   1 is a discount factor.
In the TD(  ) algorithm, there are two basic mechanisms which are the temporal difference
262

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

and the eligibility trace, respectively. Temporal differences are defined as the differences between
two successive estimations and have the following form.
~
~
 t = rt + Vt ( xt +1 )  Vt ( xt )
(2)
~
where xt+1 is the successive state of xt, V ( x) denotes the estimate of the value function V(x) and rt
is the reward received after the state transition from xt to xt+1.
The Eligibility trace can be viewed as an algebraic trick to improve learning efficiency
without recording all the data of a multi-step prediction process. This trick is based on the idea of
using the truncated return of a Markov chain. In temporal-difference learning with eligibility
traces, an n-step truncated return is defined as
~
Rtn = rt + rt +1 + ... +  n 1 rt + n 1 +  nVt ( s t + n )
(3)
For an absorbing Markov chain whose length is T, the weighted average of truncated returns
is
T t 1

Rt = (1   )

  n1 Rtn +  T t 1 RT

(4)

n =1

where 0    1 is a decaying factor and RT= rt + rt +1 + ... +  T rT is the Monte-Carlo return at
the terminal state. In each step of the TD(  ) algorithm, the update rule of the value function
estimation is determined by the weighted average of truncated returns defined above. The
corresponding update equation is
~
~
Vt ( s i ) =  t ( Rt  Vt ( s i ))
(5)
where t is a learning factor.
The update equation (5) can be used only after the whole trajectory of the Markov chain is
observed. To realize incremental or online learning, eligibility traces are defined for each state as
follows:

 z t ( s i ) + 1,
z t +1 ( s i ) = 
 z t ( s i ),

if s i = s t
if s i  s t

The online TD(  ) update rule with eligibility traces is
~
~
Vt +1 ( si ) = Vt ( si ) +  t  t z t +1 ( si )

(6)

(7)

where t is the temporal difference at time step t, which is defined in (2) and z0(s)=0 for all s.
Since the state space of a Markov chain is usually large or infinite in practice, function
approximators such as neural networks are commonly used to approximate the value function.
TD(  ) algorithms with linear function approximators are the most popular and well-studied ones.
Consider a general linear function approximator with a fixed basis function vector

 ( x ) = (1 ( x ),  2 ( x ),...,  n ( x ))T
The estimated value function can be denoted as

~
Vt ( x) =  T ( x)Wt
263

(8)

fiXU, HE, & HU

where Wt =(w1, w2,,wn)T is the weight vector.
The corresponding incremental weight update rule is

r
Wt +1 = Wt +  t (rt +  T ( xt +1 )Wt   T ( xt )Wt ) z t +1
r
where the eligibility trace vector z t ( s ) = ( z1t ( s ), z 2t ( s ),..., z nt ( s )) T is defined as
r
r
z t +1 = z t +  ( xt )

(9)

(10)

In Tsitsiklis and Roy (1997), the above linear TD(  ) algorithm is proved to converge with
probability 1 under certain assumptions and the limit of convergence W* is also derived, which
satisfies the following equation.
E 0 [ A( X t )]W *  E 0 [b( X t )] = 0

(11)

where Xt =(xt,xt+1,zt+1) (t=1,2,) form a Markov process, E0[] stands for the expectation with
respect to the unique invariant distribution of {Xt}, and A(Xt) and b(Xt) are defined as
r
A( X t ) = z t ( T ( xt )   T ( xt +1 ))
(12)

r
b( X t ) = z t rt

(13)

To improve the efficiency of linear TD() algorithms, least-squares methods are used with the
linear TD(0) algorithm, and the LS-TD(0) and RLS-TD(0) algorithms are suggested (Brartke and
Barto, 1996). In LS-TD(0) and RLS-TD(0), the following quadratic objective function is defined.
T 1

J =  [rt  ( tT   tT+1 )W ] 2

(14)

t =1

Thus, the aim of LS-TD(0) and RLS-TD(0) is to obtain a least-squares estimation of the real
value function which satisfies the following Bellman equation.
V ( xt ) = E[rt ( xt , xt +1 ) + V ( xt +1 )]

(15)

By employing the instrumental variables approach (Soderstrom and Stoica, 1983), the
least-squares solution of (14) is given as
T

T

t =1

t =1

W LS TD ( 0) = ( ( t ( t   t +1 ) T )) 1 (  t rt )

(16)

where  t is the instrumental variable chosen to be uncorrelated with the input and output noises.
In RLS-TD(0), recursive least-squares methods are used to decrease the computational burden of LS-TD(0). The update rules of RLS-TD(0) are as follows:
Wt +1 = Wt + Pt  t (rt  ( t  t +1 ) T Wt ) /(1 + ( t  t +1 ) T Pt  t )

(17)

Pt +1 = Pt  Pt  t ( t   t +1 ) T Pt /(1 + ( t   t +1 ) T Pt  t )

(18)

The convergence (with probability one) of LS-TD(0) and RLS-TD(0) is proved for periodic and
absorbing Markov chains under certain assumptions (Brartke and Barto,1996).
264

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

In Boyan (1999,2002), LS-TD(  ) is proposed by solving (11) directly and the model-based
property of LS-TD(  ) is also analyzed. However, for LS-TD(  ), the computation per time-step is
O(K3), i.e., the cubic order of the state feature number. Therefore the computation required by
LS-TD() increases very fast when K increases, which is undesirable for online learning.
In the next section, we propose the RLS-TD(  ) algorithm by making use of recursive
least-squares methods so that the computational burden of LS-TD(  ) can be reduced from O(K3)
to O(K2). We also give a rigorous mathematical analysis on the algorithm, where the convergence
(with probability 1) of RLS-TD(  ) is proved.

3. The RLS-TD(  ) Algorithm
For the Markov chain discussed above, when linear function approximators are used, the
least-squares estimation problem of (11) has the following objective function.
J=

T

T

t =1

t =1

 A( X t )W   b( X t )

2

(19)

where A( X t )  R nn , b( X t )  R n are defined as (12) and (13), respectively,  is a Euclid norm
and n is the number of basis functions.
In LS-TD(  ), the least-squares estimate of the weight vector W is computed according to the
following equation.
T

T

t =1

t =1

W LS TD (  ) = AT1bT = ( A( X t )) 1 ( b( X t ))

(20)

T
T
r
AT =  ( A( X t )) =  z t ( T ( xt )   T ( xt +1 ))

(21)

T
T
r
bT =  b( X t ) =  z t rt

(22)

where

t =0

t =0

t =0

t =0

As is well known in system identification, adaptive filtering and control, RLS methods are
commonly used to solve the computational and memory problems of least-squares algorithms. In
the sequel, we present the RLS-TD(  ) algorithm based on the above idea. First, the matrix inverse lemma is given as follows:
Lemma 1(Ljung, et al.,1983). If A  R nn , B  R n1 , C  R 1n and A is invertible, then

( A + BC ) 1 = A 1  A 1 B ( I + CA 1 B ) 1 CA 1

(23)

Pt = At1

(24)

Let

265

fiXU, HE, & HU

P0 = I

(25)

r
K t +1 = Pt +1 z t

(26)

where  is a positive number and I is the identity matrix.
Then the weight update rules of RLS-TD(  ) are given by
r
r
K t +1 = Pt z t /(  + ( T ( xt )   T ( xt +1 )) Pt z t )
Wt +1 = Wt + K t +1 (rt  ( T ( xt )   T ( xt +1 ))Wt )

Pt +1 =

1



r
r
[ Pt  Pt z t [  + ( T ( xt )   T ( xt +1 )) Pt z t )] 1 ( T ( xt )   T ( xt +1 )) Pt ]

(27)
(28)

(29)

where for the standard RLS-TD() algorithm, =1; for the general forgetting factor RLS-TD()
case, 0<1.
The forgetting factor  (0<1) is usually used in adaptive filtering to improve the
performance of RLS methods in non-stationary environments. The forgetting factor RLS-TD(  )
algorithm with 0<1 can be derived using similar techniques as in Haykin (1996). The detailed
derivation of RLS-TD() is referred to Appendix A.
In the follows, the descriptions of RLS-TD(  ) for two different kinds of Markov chains are
given. First, a complete description of RLS-TD(  ) for ergodic Markov chains is presented below.

Algorithm 1 RLS-TD(  ) for ergodic Markov chains

1: Given:
 A termination criterion for the algorithm.
 A set of basis functions {  j (i ) } (j=1,2,,n) for each state i, where n is the
number of basis functions.
2: Initialize:
(2.1) Let t=0.
(2.2) Initialize the weight vector Wt, the variance matrix Pt , the initial state x0.
r
(2.3) Set the eligibility traces vector z 0 =0.
3: Loop:
(3.1) For the current state xt, observe the state transition from xt to xt+1 and the
reward r(xt ,xt+1).
(3.2) Apply equations (27)-(29) to update the weight vector.
(3.3) t=t+1.
until the termination criterion is satisfied.

The RLS-TD(  ) algorithm for absorbing Markov chains is a little different from the above
algorithm in coping with the state features of absorbing states. Following is a description of
266

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

RLS-TD(  ) for absorbing Markov chains.

Algorithm 2 RLS-TD(  ) for absorbing Markov chains

1: Given:
 A termination criterion for the algorithm.
 A set of basis functions {  j (i ) } (j=1,2,,n) for each state i, where n is the
number of basis functions.
2: Initialize:
(2.1) Let t=0.
(2.2) Initialize the weight vector Wt, the variance matrix Pt , the initial state x0.
r
(2.3) Set the eligibility traces vector z 0 =0.
3: Loop:
(3.1) For the current state xt,
 If xt is an absorbing state, set  (xt+1)=0, r(xt)=rT, where rT is the terminal
reward.
 Otherwise, observe the state transition from xt to xt+1 and the reward
r(xt ,xt+1).
(3.2) Apply equations (27)-(29) to update the weight vector.
(3.3) If xt is an absorbing state, re-initialize the process by setting xt+1 to an initial
r
state and set the eligibility traces z t to a zero vector.
(3.4) t=t+1.
until the termination criterion is satisfied.

In the above RLS-TD(  ) algorithm for absorbing Markov chains, the weight updates in the
absorbing states are treated differently and the process is re-initialized in absorbing states to
transform the absorbing Markov chain into an equivalent ergodic Markov chain. So in the
following convergence analysis, we only focus on ergodic Markov chains.
Under similar assumptions as in Tsitsiklis and Roy (1997), we will prove that the proposed
RLS-TD(  ) algorithm converges with probability one.
Assumption 1. The Markov chain {xt}, whose transition probability matrix is P, is ergodic, and
there is a unique distribution  that satisfies



P = T
(30)
with  (i)>0 for all iS and is a finite or infinite vector, depending on the cardinality of S.
T

Assumption 2. Transition rewards r(xt,xt+1) satisfy

E 0 [r 2 ( xt , xt +1 )] < 

(31)

where E0[ ] is the expectation with respect to the distribution  .
Assumption 3. The matrix  = [1 ,  2 ,...,  n ]  R N n has full column rank, that is, the basis
267

fiXU, HE, & HU

functions  i (i=1,2,,n) are linearly independent.
Assumption 4. For every i (i=1,2,,n), the basis function  i satisfies
2

E 0 [ i ( xt )] < 

(32)

1 T
 A( X t )] is non-singular for all T>0.
T t =1
Assumptions 14 are almost the same as those for the linear TD() algorithms discussed in
Tsitsiklis and Roy (1997) except that in Assumption 1, ergodic Markov chains are considered.
Assumption 5 is specially needed for the convergence of the RLS-TD() algorithm.
Based on the above assumptions, the convergence theorem for RLS-TD() can be given as
follows:
Assumption 5. The matrix [ P01 +

Theorem 1. For a Markov chain which satisfies Assumptions 15, the asymptotic estimate found
by RLS-TD(  ) converges, with probability 1, to W* determined by (11).

For the proof of Theorem 1, please refer to Appendix B. The condition specified by
Assumption 5 can be satisfied by setting P0= I appropriately.
According to Theorem 1, RLS-TD(  ) converges to the same solution as conventional linear
TD(  ) algorithms do, which satisfies (11). So the limit of convergence can be characterized by
the following theorem.
Theorem 2 (Tsitsiklis and Roy ,1997) Let W* be the weight vector determined by (11) and V* be
the true value function of the Markov chain, then under Assumption 14, the following relation
holds.
1  
W *  V * 
(33)
V *  V *
D
D
1

where

X

D

=

X T DX ,  =  ( T D ) 1  T D .

For more explanations on the notations in Theorem 2, please refer to Appendix B.
As discussed by Tsitsiklis and Roy (1997), the above theorem shows that the distance of the
limiting function  W* from the true value function V* is bounded and the smallest bound of
approximation error can be obtained when =1. For every <1, the bound actually deteriorates as
 decreases. The worst bound is obtained when =0. Although this is only a bound, it strongly
suggests that higher values of  are likely to produce more accurate approximations of V*.
Compared to LS-TD(), there is an additional parameter in RLS-TD(), which is the value 
for the initial variance matrix P0. As was pointed out by Haykin (1996,pp.570), the exact value of
the initializing constant  has an insignificant effect when the data length is large enough. This
means that in the limit, the final solutions obtained by LS and RLS are almost the same. For the
influence of  on the transient phase, when the positive constant  becomes large enough or goes
to infinity, the transient behavior of RLS will be almost the same as that of LS methods (Ljung,
1983). But when  is initialized with a relatively small value, the transient phases of RLS and LS
will be different. In practice, it is observed that there is a variable performance of RLS as a
function of the initialization of  (Moustakides, 1997). In some cases, RLS can exhibit a
significantly faster convergence when initialized with a relatively small positive definite matrix
than when initialized with a large one (Haykin,1996; Moustakides, 1997; Hubing and Alexander,
268

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

1989). A first effort toward this direction is the statistical analysis of RLS for soft and exact
initialization but limits to the case that the number of iterations is less than the size of the
estimation vector (Hubing and Alexander, 1989). Moustakides (1997) provided a theoretical
analysis on the relation between the algorithmic performance of RLS and the initialization of .
By using the settling time as the performance measure, Moustakides proved that the well-known
rule of initialization with a relatively small matrix is preferable for cases of high and medium
signal-to-noise ratio (SNR), whereas for low SNR, a relatively large matrix must be selected for
achieving best results. In the following learning prediction experiments of RLS-TD(), as well as
the learning control simulation of Fast-AHC, it is observed that the value of the initializing
constant  also plays an important role in the convergence performance, and the above theoretical
analyses provide a clue to explain our experimental results.

4. Learning Prediction Experiments on Markov Chains
In this section, an illustrative example is given to show the effectiveness of the proposed
RLS-TD() algorithm. Furthermore, the algorithmic performance under the influence of the
initializing constant  is studied.
The example is a finite-state absorbing Markov chain called the Hop-World problem (Boyan,
1999). As shown in Figure 1, the Hop-World problem is a 13-state Markov chain with an
absorbing state.

Figure 1: The Hop-World Problem
In Figure 1, state 12 is the initial state for each trajectory and state 0 is the absorbing state.
Each non-absorbing state has two possible state transitions with transition probability 0.5. Each
state transition has reward 3 except the transition from state 1 to state 0 which has a reward of 2.
Thus, the true value function for state i (0i12) is 2i.
To apply linear temporal-difference algorithms to the value function prediction problem, a set
of four-element state features or basis functions is chosen, as shown in Figure 1. The state
features of states 12,8,4 and 0 are, respectively, [1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1] and the
state features of other states are obtained by linearly interpolating between these.
In our simulation, the RLS-TD(  ) algorithm as well as LS-TD() and conventional linear
TD(  ) algorithms are used to solve the above value function prediction problem without
knowing the model of the Markov chain. In the experiments, a trial is defined as the period from
the initial state 12 to the terminal state 0. The performance of the algorithms is evaluated by the
averaged root mean squared (RMS) error of value-function predictions over all the 13 states. For
each parameter setting, the performance is averaged over 20 independent Monte-Carlo runs.
Figure 2 shows the learning curves of RLS-TD() and conventional linear TD() algorithms with
three different parameter settings. The parameter  is set to 0.3 for all the algorithms and the
269

fiXU, HE, & HU

step-size parameter of TD() has the following form.

n = 0

N0 +1
N0 + n

(34)

The above step-size schedule is also studied in Boyan (1999). In our experiments, three
different settings are used, which are
(s1)  0 = 0.01 , N 0 = 10 6
(s2)  0 = 0.01 , N 0 = 1000
(s3)  0 = 0.1 , N 0 = 1000 .

(35)

Different from those in Boyan (1999), the linear TD() algorithms applied here are in their
online forms, which update the weights after every state transitions. So the parameter n in (34) is
the number of state transitions. In each run, the weights are all initialized to zeroes. In Figure 2,
the learning curves of conventional linear TD() algorithms with step-size schedules (s1), (s2)
and (s3) are shown by curves 1,2 and 3, respectively. For each curve, the averaged RMS errors of
value function predictions over all the states and 20 independent runs are plotted for each trial.
Curve 4 shows the learning performance of RLS-TD(). One additional parameter for RLS-TD()
is the initial value  of the variance matrix P0. In this experiment,  is set to 500, which is a
relatively large value. From Figure 2, it can be concluded that by making use of RLS methods,
RLS-TD() can obtain much better performance than conventional linear TD() algorithms and
eliminates the design problem of the step-size schedules. Other experiments for linear TD() and
RLS-TD() with different parameters  are also conducted and similar results are obtained when
the initial values  of RLS-TD() are large and the conclusion is confirmed.

Figure 2: Performance comparison between RLS-TD() and TD()
1,2,3 ---TD(0.3) with step-size parameters specified by (s1),(s2) and (s3)
4RLS-TD(0.3) with initial variance matrix P0=500I
We have done demonstrative experiments to investigate the influence of  on the performance
of the RLS-TD() algorithm. Figure 3 shows the performance comparison between RLS-TD()
270

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

algorithms using two different initial parameters of the variance matrix P0, which are P0=0.1I and
P0=1000I, respectively. The forgetting factor is =0.995. The performance of the suggested
algorithm is measured by the averaged RMS errors of the value function prediction in the first
200 trials over 20 independent runs and all the 13 states. In the experiments, 11 settings of the
parameter  are tested, which are 0.1n (n=0,1,,10).
In Figure 3, it is clearly shown that the performance of RLS-TD() with a large initial value
of  is much better than RLS-TD() with a small initial value of . In other experiments with
different parameter settings of  and , similar results are also obtained. We may refer this
phenomenon to the low SNR case of the forgetting factor RLS studied in Moustakides (1997).
For the Hop-World problem, the stochastic state transitions could introduce high equation
residuals A( X t )W  b( X t ) in (19), which corresponds to the additive noise with large variance,
i.e., the low SNR case. As has been discussed in Section 2, for the forgetting factor RLS in low
SNR cases, a relatively large initializing constant  must be selected for better results. A full
understanding of this phenomenon is yet to be found.

Figure 3: Performance comparison of RLS-TD() with different initial value of  (=0.995)
The performance of RLS-TD() with unit forgetting factor =1 is also tested in our
experiments. Although the initial value effect in RLS with =1 has not been discussed intensively
(Moustakides,1997), the same effects of  are observed empirically in the case of =1 as that in
<1, which is shown by Figure 4.
In our other experiments, it is also found that when  is initialized with a small value, the
performance is sensitive to the values of  and the parameter . In this case, the convergence
speed of RLS-TD() increases as  increases from 0 to 1, which is shown in Figure 3.
Furthermore, when  is fixed, the performance of RLS-TD() deteriorates as  becomes smaller,
as shown in Figure 5 .

271

fiXU, HE, & HU

Figure 4: Performance comparison of RLS-TD() with different initial value of  (=1)

Figure 5: Learning curves of LS-TD() and RLS-TD() with different  (=1)

In Figure 5, the learning curves of RLS-TD() with different initializing constants  are
shown and compared with that of LS-TD(). In the experiment,  is set to 0.5. From Figure 5, it is
shown that the performance of RLS-TD() approaches that of LS-TD() when  becomes large.
As is well known, when  becomes large enough, the performance of RLS and LS methods will
be almost the same. Figure 6 shows the performance comparison between LS-TD() and
RLS-TD() with a large value of . The initial variance matrix for RLS-TD() is set to 500I in
every runs, where I is the identity matrix.

272

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

Figure 6: Performance comparison of LS-TD() and RLS-TD() with =1 and large initial
value of 
Based on the above experimental results, it can be concluded that the convergence speed of
RLS-TD(  ) is mainly influenced by the initial value  of the variance matrix and the parameter
 . Detailed discussions on the properties of RLS-TD(  ) are given as follows:
(1) When  is relatively large, the effect of  becomes small. If  is large enough or goes to
infinity, the performance of RLS-TD(  ) and LS-TD(  ) will be almost the same, as was
discussed above. In such cases, the effect of  on the speed of convergence is insignificant,
which coincides with the discussion in Boyan (1999). However, as described in Theorem 2, the
value of  still affects the ultimate error bound of value function approximation.
(2) When  is relatively small, it is observed that the convergence performance of
RLS-TD() is different from that of LS-TD() and is influenced by the values of both  and . In
the experiments of the Hop-World problem, the results show that smaller values of  lead to
slower convergence. These results may be explained by the theoretical analysis on the transient
phase of the forgetting factor RLS (Moustakides,1997). According to the theory in Moustakides
(1997), larger values of  are needed for better performance in the cases of low SNR while
smaller  values are preferable for fast convergence in the cases of high and medium SNR. So
different values of  must be selected for faster convergence of RLS-TD(  ) in different cases.
Especially, in some cases, such as the high SNR case discussed in Moustakides (1997), RLS
methods with small values of  can obtain a very fast speed of convergence.
(3) Compared to conventional linear TD(  ) algorithms, the RLS-TD(  ) algorithm can
obtain much better performance by making use of RLS methods for value function prediction
problems. Furthermore, in TD(  ), a step-size schedule needs to be carefully designed to achieve
good performance, while in RLS-TD(  ), the initial value  of the variance matrix can be selected
according to the criterion of a large or a small value.
(4) For the comparison of LS-TD(  ) and RLS-TD(  ), which one is preferable depends on
the objective. In online applications, RLS-TD(  ) has advantages in computational efficiency
because the computation per step for RLS-TD(  ) is O(K2) and for LS-TD(  ), it is O(K3), where
273

fiXU, HE, & HU

K is the number of state features. Moreover, as will be seen later, RLS-TD(  ) can obtain better
transient convergence performance than LS-TD(  ) in some cases. On the other hand, LS-TD(  )
may be preferable to RLS-TD(  ) in the long-term convergence performance, as can be seen in
Figure 5. And from a system identification point of view, LS-TD(  ) can obtain unbiased
parameter estimates in face of white additive noises while RLS-TD(  ) with finite  would
possess large parameter discrepancies.

5. The Fast-AHC Algorithm and Two Learning Control Experiments
In this section, the Fast-AHC algorithm is proposed based on the above results on learning
prediction to solve learning control problems. Two learning control experiments are conducted to
illustrate the efficiency of Fast-AHC.
5.1 The Fast-AHC Algorithm

The ultimate goal of reinforcement learning is learning control, i.e., to estimate the optimal
policies or the optimal value functions of Markov decision processes (MDPs). Until now, several
reinforcement learning control algorithms including Q-learning (Watkins and Dayan,1992),
Sarsa-learning (Singh, et al.,2000) and the Adaptive Heuristic Critic (AHC) algorithm (Barto,
Sutton and Anderson,1983) have been proposed. Among the above methods, the AHC method is
different from Q-learning and Sarsa-learning which are value-function-based methods. In the
AHC method, value functions and policies are separately represented while in value-functionbased methods the policies are determined by the value functions directly. There are two
components in the AHC method, which are called the critic and the actor, respectively. The actor
is used to generate control actions according to the policies. The critic is used to evaluate the
policies represented by the actor and provide the actor with internal rewards without waiting for
delayed external rewards. Since the objective of the critic is policy evaluation or learning
prediction, temporal-difference learning methods are chosen as the critics learning algorithms.
The learning algorithm of the actor is determined by the estimation of the gradient of the policies.
In the following discussion, a detailed introduction on the AHC method is given.
Figure 7 shows the architecture of a learning system based on the AHC method. The learning
system consists of a critic network and an actor network. The inputs of the critic network include
the external rewards and the state feedback from the environment. The internal rewards provided
by the critic network are called the temporal-difference (TD) signals.
As in most reinforcement learning methods, the whole system is modeled as an MDP denoted
by a tuple {S,A,P,R},where S is the state set, A is the action set, P is the state transition probability
and R is the reward function. The policy of the MDP is defined as a function  :SPr(A), where
Pr(A) is a probability distribution in the action space. The objective of the AHC method is to
estimate the optimal policy * satisfying the following equation.


J = max J  = max E [  t rt ]
*





(36)

t =0

where  is the discount factor and rt is the reward at time-step tE[ ] stands for the expectation
with respect to the policy  and the state transition probabilities and J is the expected total
reward.

274

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

Figure 7: The AHC learning system
The value function for a stationary policy  and the optimal value function for the optimal
policy are defined as follows:


V  ( s ) = E [  t rt s 0 = s ]

(37)

V * ( s ) = E *[  t rt s0 = s ]

(38)

t =0


t =0

According to the theory of dynamic programming, the optimal value function satisfies the
following Bellman equation.
(39)
V * ( s ) = max[ R ( s, a ) + EV * ( s ' )]
a

where R(s,a) is the expected reward received after taking action a in state s.
In AHC, the critic uses temporal-difference learning to approximate the value function of the
current policy. When linear function approximators are used in the critic, the weight update
equation is
Wt +1 = Wt +  t [rt + V ( s t +1 )  V ( s t )]z t

(40)

where zt is the eligibility trace defined in (10).
The action selection policy of the actor is determined by the current state and the value
function estimation of the critic. Suppose a neural network with weight vector u=[u1, u2,, um] is
used in the actor, and the output of the actor network is

y t = f (u , st )

(41)

The action outputs of the actor are determined by the following Gaussian probabilistic distribution.
( y  y )2
p r ( y t ) = exp( t 2 t )
(42)

t

where the mean value is given by (41) and the variance is given by

 t = k1 /(1 + exp(k 2V ( s t ))

(43)

In the above equation, k1 and k2 are positive constants and V(st) is the value function es275

fiXU, HE, & HU

timation of the critic network.
To obtain the learning rule of the actor, an estimation of the policy gradient is given as
follows:
J y t
J 
y  y t y t
= 
 rt t
u
y t u
 t u

(44)

where rt is the internal reward or the TD signal provided by the critic:

rt = rt + V ( st +1 )  V ( st )

(45)

Since in the AHC method, the critic is used to estimate the value function of the actors policy
and provide the internal reinforcement using temporal-difference learning algorithms, the
efficiency of temporal-different learning or learning prediction will greatly influence the whole
learning systems performance. Although the policy of the actor is changing, it may change
relatively slowly especially when fast convergence of learning prediction in the critic can be
realized. In the previous sections, RLS-TD(  ) is shown to have better data efficiency than
conventional linear TD(  ) algorithms and a very fast convergence speed can be obtained when
the initializing constant is chosen appropriately. Thus, applying RLS-TD(  ) to the policy
evaluation in the critic network will improve the learning prediction performance of the critic and
is promising to enhance the whole systems learning control performance. Based on the above
idea, a new AHC method called the Fast-AHC algorithm is proposed in this paper. The efficiency
of the Fast-AHC algorithm is verified empirically and detailed analysis of the results is given.
Following is a complete description of the Fast-AHC algorithm.

Algorithm 3: The Fast-AHC algorithm
1: Given: a critic neural network and an actor neural network, which are both linear in
parameters, a stop criterion for the algorithm.
2: Initialize the state of the MDP and the learning parameters, set t=0.
3: While the stop criterion is not satisfied,
(3.1) According to the current state s t , compute the output of the actor network y t ,

(3.2)

determine the actual action of the actor by the probability distribution given by
(42).
Take the action y t on the MDP, and observe the state transition from s t to

s t +1 , set reward rt = r ( st , st +1 ) .
(3.3)
(3.4)

(3.5)

Apply the RLS-TD(  ) algorithm described in (27)-(29) to update the weights of
the critic network.
Apply the following equation to update the weights of the actor network,
J
at +1 = at +  t 
(46)
at
where t is the learning factor of the actor.
Let t=t+1, return to 3.

276

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

5.2 Learning Control Experiments on The Cart-Pole Balancing Problem
The balancing control of inverted pendulums is a typical nonlinear control problem and has been
widely studied not only in control theory but also in artificial intelligence. In the research of
artificial intelligence, the learning control of inverted pendulums is considered as a standard test
problem for machine learning methods, especially for RL algorithms. It has been studied in the
early work of Michies BOXES system (Michie,et al.,1968) and later in Barto and Sutton (1983),
where the learning controllers only have two output values: +10(N) and 10(N). In Berenji, et
al.(1992) and Lin, et al.(1994), AHC methods with continuous outputs are applied to the cart-pole
balancing problem. In this paper, the cart-pole balancing problem with continuous control values
is used to illustrate the effectiveness of the Fast-AHC method.
Figure 8 shows a typical cart-pole balancing control system, which consists of a cart moving
horizontally and a pole with one end fixed at the cart. Let x denote the horizontal distance
between the center of the cart and the center of the track, where x is negative when the cart is in
the left part of the track. Variable  denotes the angle of the pole from its upright position (in
degrees) and F is the amount of force (N) applied to the cart to move it towards its left or right. So
the control system has four state variables x, x& , ,& , where x& ,& are the derivatives of x and  ,
respectively.
In Figure 8, the mass of the cart is M=1.0kg, the mass of the pole is m=0.1kg, the half-pole
length is l=0.5m, the coefficient of friction of the cart on the track is c=0.0005 and the coefficient
of friction of the pole on the cart is p=0.000002. The boundary constraints on the state variables
are given as follows.
 12 o    12 o
(47)
 2.4m  x  2.4m
(48)
The dynamics of the control system can be described by the following equations.

 p (m + M )&
(m + M ) g sin   cos  [ F + ml& 2 sin    c sgn( x& )] 

ml
&& =

4
2
(49)

( M + m)l  ml cos 
3


F + ml (& 2 sin   && cos  )   c sgn( x& )
&x& =
M +m

where g is the acceleration due to the gravity, which is 9.8m/s2. The above parameters and
dynamics equations are the same as those studied in Barto et al. (1983).

Figure 8: The cart-pole balancing control system
277

fiXU, HE, & HU

In the learning control experiments of the pole-balancing problem, the dynamics (49) is
assumed to be unknown to the learning controller. In addition to the four state variables, the only
available feedback is a failure signal that notifies the controller when a failure occurs, which
means the values of the state variables exceed the boundary constraints prescribed by inequalities
(47) and (48). It is a typical reinforcement learning problem, where the failure signal serves as the
reward. Since an external reward may only be available after a long sequence of actions, the critic
in the AHC learning controller is used to provide the internal reinforcement signal to accomplish
the learning task. Learning control experiments on the pole-balancing problem are conducted
using conventional AHC method which uses linear TD() algorithms in the critic and the
Fast-AHC method proposed in this paper.
To solve the continuous state space problem in reinforcement learning, a class of linear
function approximators, which is called Cerebellar Model Articulation Controller (CMAC) is
used. As a neural network model based on the neuro-physiological theory about human
cerebellarCMAC was first proposed by Albus (1975) and has been widely used in automatic
control and function approximation. In CMAC neural networks, the dependence of adjustable
parameters or weights with respect to outputs is linear. For detailed discussion on the structure of
CMAC neural networks, one may refer to Albus (1975) and Sutton & Barto (1998).
In the AHC and Fast-AHC learning controllers, two CMAC neural networks with four inputs
and one output for each are used as the function approximators in the critic and the actor,
respectively. Each CMAC has C tilings and M partitions for every input. So the total physical
memory for each CMAC network is M4C. To reduce the computation and memory requirements,
a hashing technique described by the following equations is employed in our experiments. (For
detailed discussion on the parameters of the CMAC networks, please refer to Appendix C).
A( s ) =

4

 [a(i) + M i 1 ]

(50)

i =1

F(s)=A(s) mod K
(51)
In (50) and (51), s represents an input state vector, a(i) (0 a(i) M) is the activated tile for
the i-th element of s, K is the total number of the physical memory and F(s) is the physical
memory address corresponding to the state s, which is the remainder of A(s) divided by K.
In order to compare the performance of different learning algorithms, the initial parameters of
each learning controller are selected as follows: The weights of the critic are all initialized to 0
and the weights of the actor are initialized to random numbers in interval [0,0.1]. The other
parameters for the AHC and Fast-AHC algorithms are  = 0.95 , k1 = 0.4 and k 2 = 0.5 .
In all the experiments, a trial is defined as the period from an initial state to a failure state and
the initial state of each trial is set to a randomly generated state near the unstable equilibrium
(0,0,0,0) with a maximum distance of 0.05. Equation (49) is employed to simulate the dynamics
of the system using the Euler method, which has a time step of 0.02s. When a trial lasts for more
than 120,000 time steps, it is said to be successful and the learning controller is assumed to be
able to balance the pole. The reinforcement signal for the problem is defined as

 1, if failure occurs
rt = 
 0, otherwise

(52)

The performance of the Fast-AHC method is tested extensively, where different parameter
settings including  and the initial variance matrix P0 are chosen. In the experiments, the
278

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

forgetting factor of RLS-TD() in the critic is set to a value that is equal to 1 or very close to 1.
The learning control experiments using conventional AHC methods are also conducted for
comparison. The performance comparisons between the two algorithms are shown in Figure 9, 10
and 11.
In the above experiments, the initial variance matrixes of the Fast-AHC algorithm are all set
to P0=0.1I. The performance of Fast-AHC is compared with AHC for different . The numbers of
physical memories of the critic network and the actor network are chosen as 30 and 80,
respectively. For each parameter setting of the two algorithms, 5 independent runs are tested. The
performance is evaluated according to the trial number needed to successfully balance the pole.
The learning factors for the actor networks are all set to 0.5, which is a manually optimized value
for both algorithms. In all the experiments, 11 settings of  are tested.

Figure 9: Performance comparison between Fast-AHC and AHC with =0.01

Figure 10: Performance comparison between Fast-AHC and AHC with =0.03
279

fiXU, HE, & HU

Figure 11: Performance comparison between Fast-AHC and AHC with =0.05

In Figure 9, 10 and 11, the learning factors of the critic networks in AHC are chosen as
=0.01, 0.03 and 0.05, respectively. It is found that when <0.01, the performance of AHC
becomes worse. For the learning factors that are greater than 0.05, the AHC algorithm may
become unstable, and even when =0.03 and =0.05, the AHC algorithm becomes unstable for
=1. For the time-varying learning factors specified in (s1)-(s3), the performance is worse than
the above constant learning factors. So the above three settings of the learning factor  are typical
and near optimal for the AHC algorithm.
From the above experimental results, it can be concluded that by using RLS-TD() in the
critic network, the Fast-AHC algorithm can obtain better performance than conventional AHC
algorithms. Although Fast-AHC requires more computation per step than AHC, it is more
efficient than AHC in that less trials or data are needed to successfully balance the pole.
As has been discussed in the previous sections, the convergence performance of RLS-TD()
is influenced by the initial value of the variance matrix. This is also the case in Fast-AHC. In the
above learning control experiments, a small value =0.1 is selected. In other experiments, when 
is set to other small values, the performance of Fast-AHC is satisfactory and is better than AHC.
However, when  is equal to a relatively large value, for example =100 or 500, the performance
of Fast-AHC deteriorates significantly. Since RLS-TD() with a large initializing constant has
similar performance as LS-TD(), it can be deduced that the AHC method using LS-TD() in the
critic will also have bad performance in the cart-pole balancing problem. To verify this,
experiments are conducted using Fast-AHC with large initializing constant  and AHC using
LS-TD(). For each parameter setting, 5 independent runs are tested. In the experiments, the
maximum trials for each algorithm in one run is 200 so that if an algorithm fails to balance the
pole within 200 trials, its performance is set to 200.When using LS-TD() in the AHC method,
there may be computational problems in the matrix inversion during the first few steps of learning
and two methods are tried to avoid this problem. One is the usage of TD() in the first 60 steps of
updates. The other is that the actor is not updated in the early stage of learning until LS-TD() is
280

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

stable. However, similar results are found for the two methods. Figure 12 shows the experimental
results which clearly verify that the performance of Fast-AHC with a large initializing constant 
is similar to AHC using LS-TD() and it is much worse than Fast-AHC with a small . A detailed
discussion of this phenomenon is provided in subsection 5.4.

Figure 12: Performance comparison of Fast-AHC with different initial variance
In the following Figure 13 and Figure 14, the variations of the pole angle  and the control
force F are plotted, where a successfully trained Fast-AHC learning controller is used to control
the cart-pole system.

Figure 13: Variation of the pole angle

Figure 14: Variation of the control force

5.3 Learning Control Experiments of The Acrobot

In this subsection, another learning control example, which is the swing-up control of the acrobot
in minimum time, is presented. The learning control of the acrobot is a class of adaptive optimal
control problem that is more difficult than the pole-balancing problem. It has been investigated in
Sutton (1996), where CMAC-based Sarsa-learning algorithms were employed to solve it and only
the case of discrete control actions was studied. In our experiments, the case of continuous actions
281

fiXU, HE, & HU

is considered.
An acrobot moving in the vertical plane is shown in Figure 15, where OA and AB are the first
link and the second link, respectively. The control torque is applied at point A. The goal of the
swing-up control is to swing the tip B of the acrobot above the line CD which is higher than the
joint O by an amount of the length of one link.

Figure 15: The acrobot
The dynamics of the acrobot system is described by the following equations.

&&1 = (d 2&&2 + 1 ) / d1

(53)

&&2 = ( + d 21 / d1   2 )

(54)

d1 = m1l c21 + m2 (l12 + l c22 + 2l1l c 2 cos 2 ) + I 1 + I 2

(55)

d 2 = m2 (l c22 + l1l c 2 cos 2 ) + I 2

(56)

1 = m2 l1l c 2&22 sin  2  2m2 l1l c 2&1&2 sin  2 + (m1l c1 + m2 l1 ) g cos( 1   / 2) +  2

(57)

 2 = m2 l c 2 g cos( 1 +  2   / 2)

(58)

where

In the above equations, the parameters  i , &i , mi , li , I i , l ci are the angle, the angle velocity,
the mass, the length, the moment of inertia and the length of the center of mass for link i (i=1,2),
respectively.
Let sT denote the goal state of the swing-up control. Since the control aim is to swing up the
acrobot in minimum time, the reward function rt is defined as
1, if s = sT
rt = 
0, else

(59)

In the simulation experiments, the control torque  is continuous and is bounded by [-3N, 3N].
Similar to the cart-pole balancing problem, CMAC neural networks are applied to solve the above
282

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

learning control problem with continuous states and actions. In the CMAC-based actor-critic
controller, the actor network and the critic network both have C=4 tilings and M=7 partitions for
each input. In the actor network, uniform coding is employed and non-uniform coding is used in
the critic network. For details of the coding parameters, please refer to Appendix C. The sizes of
the physical memories for the actor network and the critic network are 100 and 80, respectively.
In the CMAC networks, the following hashing techniques are used. (For the definition of A(s),a(i)
and F(s), please refer to Subsection 5.2.)
4

A( s ) =  [ a(i )  M i 1 ]

(60)

i =1

F(s)=A(s) mod K
(61)
In the simulation, the parameters for the acrobot are chosen as m1=m2=1kg, I1=I2=1kgm2,
lc1=lc2=0.5m, l1=l2=1m and g=9.8m/s2. The time step for simulation is 0.05s and the time interval
for learning control is 0.2s. The learning parameters are =0.6, =0.90, =0.2, k1=0.4, k2=0.5. A
trial is defined as the period that starts from the stable equilibrium and ends when the goal state is
reached. After each trial, the state of the acrobot is re-initialized to its stable equilibrium. For each
parameter setting, 5 independent runs are tested. Each run consists of 50 trials and after 50-th trial,
the actor network is tested by controlling the acrobot alone, i.e., by setting the action variance
defined in (43) to zero. The performance of the algorithms is evaluated according to the steps
used by the actor networks to swing up the acrobot.
The performance comparisons between Fast-AHC and AHC are shown in Figure 16,17 and
18. In the experiments, both algorithms are tested with different  and AHC is also tested with
different learning factors of the critic networks.
From the results, it is also shown that Fast-AHC can achieve higher data efficiency than AHC.
However, in this example, a relatively large  is used, which is different from the previous
cart-pole balancing example. In other experiments, good performance is obtained with large
initializing constant and when  is very small, the performance deteriorates significantly. Thus
this problem may be referred to the low SNR case in Moustakides (1997), where large values of
 are preferable for best convergence rate of RLS methods.

Figure 16: Performance comparison between Fast-AHC and AHC with =0.02
283

fiXU, HE, & HU

Figure 17: Performance comparison between Fast-AHC and AHC with =0.05

Figure 18: Performance comparison between Fast-AHC and AHC with =0.1

The following Figure 19 shows the performance comparison between Fast-AHC with a large
(300) and a small (0.01) value of  , where 6 settings of the parameter  are tested for each
algorithm. The performance of AHC using LS-TD() is also shown. In Figure 20, a typical curve
of the angle of the first link is plotted, where the acrobot is controlled by the actor network of the
Fast-AHC method (=0.6) after 50 trials.

284

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

Figure 19: Performance comparison of Fast-AHC and AHC using LS-TD()

Figure 20: Variation of the angle of link 1(Controlled by Fast-AHC after 50 trials)

5.4

Analysis of The Experimental Results

Based on the above experimental results, it can be concluded that by using the RLS-TD()
algorithm in the critic network, the Fast-AHC algorithm can obtain better performance than
conventional AHC algorithms in that less trials or data are needed to converge to a near optimal
policy. As is well known, one difficulty for the applications of RL methods is their slow
convergence, especially in the cases where learning data are hard to be generated. For the
Fast-AHC algorithm, although more computation per step is required than conventional AHC
methods, it will not be a serious problem when the number of linear state features is small. In all
of our learning control experiments, hashing techniques are used to reduce the state features in
CMAC networks so that the computation of Fast-AHC can be reduced to an economical amount.
Nevertheless, when the state feature number is large, conventional AHC methods may be
preferable.
In the experiments, it is observed that the performance of Fast-AHC is affected by the
initializing constant . These results are consistent with the property of RLS-TD() and the RLS
285

fiXU, HE, & HU

method in adaptive filtering, which has been discussed in Section 4. In the learning control
experiments of the cart-pole balancing problem, better performance of Fast-AHC is obtained by
using small values of . While in the learning control of the acrobot, higher data efficiency is
achieved using Fast-AHC with a relatively large . These two different properties of Fast-AHC
may be referred to the different SNR cases for RLS methods (Moustakides,1997). A thorough
theoretical analysis on this problem is an interesting topic for future research.
In our experiments, the performance of the AHC method using LS-TD() is also tested. As
has been studied in Section 4, when the initializing constant  is large, the performance of
RLS-TD() and LS-TD() does not differ much. So the performance of AHC using LS-TD() is
similar to that of Fast-AHC with large values of .
As studied in Moustakides (1997), the RLS method can converge much faster than other
adaptive filtering methods if the environment is stationary and the initializing constant is selected
appropriately. In some cases, RLS may converge almost instantly. This is also verified in the
learning prediction experiments of the RLS-TD() algorithm. When applying RLS-TD() in an
actor-critic learning controller, although the policy of the actor will change over time, it can still
be assumed that the changing speed of the policy is slow when compared with the fast
convergence speed of RLS-TD(). Thus good performance of learning prediction can be obtained
in the critic. Moreover, since the learning prediction performance of the critic is important to the
policy learning of the actor, the improvement in learning prediction efficiency will contribute to
the whole performance improvement of the controller.
6. Conclusions and Future Work

Two new reinforcement learning algorithms using RLS methods, which are called RLS-TD(  )
and Fast-AHC, respectively, are proposed in this paper. RLS-TD(  ) can be used to solve learning
prediction problems more efficiently than conventional linear TD(  ) algorithms. The
convergence with probability 1 is proved for RLS-TD(  ) and the limit of convergence is also
analyzed. Experimental results on learning prediction problems show that the RLS-TD(  )
algorithm is superior to conventional TD(  ) algorithms in data efficiency and it also eliminates
the design problem of the step sizes in linear TD(  ) algorithms. RLS-TD(  ) can be viewed as
the extension of RLS-TD(0) from  =0 to general 0<  1. Although the effect of  on the
convergence speed of RLS-TD(  ) may not be significant in some cases, the usage of  >0 will
still affect the approximation error bound. Thus, when there are needs for value function
estimation with high precision, large values of  are preferable to  =0. Furthermore, RLSTD(  ) is superior to LS-TD(  ) in computation when the weight vector must be updated after
every observations.
Since learning prediction can be viewed as a sub-problem of learning control, we extend the
results in learning prediction to a learning control method called the AHC algorithm. Using
RLS-TD(  ) in the critic network, Fast-AHC can achieve better performance than conventional
AHC method in data efficiency. Simulation results on the learning control of the pole-balancing
problem and the acrobot system confirm the above analyses.
In the experiments, it is found that the performance of RLS-TD(  ) as well as Fast-AHC is
influenced by the initializing constant  of RLS methods. Different values of  are needed for best
performance in different cases. This is also a well-known phenomenon in RLS-based adaptive
286

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

filtering and the theoretical results in Moustakides (1997) provide some basis for the explanations
of our results. A complete investigation of this problem is our ongoing work.
The idea of using RLS-TD(  ) in the critic network may be applied to other reinforcement
learning methods with actor-critic architectures. In Konda and Tsitsiklis (1998), a new actor-critic
algorithm using linear function approximators is proposed and the convergence under certain
conditions is proved. One condition for the convergence of this algorithm is that the convergence
rate of the critic is much faster than that of the actor. Thus the application of RLS-TD(  ) in the
critic may be preferable in order to ensure the convergence of the algorithm. The theoretical and
empirical work on this problem deserves to be studied in the future.

Acknowledgements
This work is supported by the National Natural Science Foundation of China under Grants
60075020, 60171003 and China University Key Teachers Fellowship. We would very much like
to thank the anonymous reviewers and Associate Editor Michael L. Littman for their insights and
constructive criticisms, which have helped improve the paper significantly.

287

fiXU, HE, & HU

Appendix A. Derivation of the RLS-TD() Algorithm

For the derivation of RLS-TD(), there are two different cases, which are determined by the value
of the forgetting factor.
(1) RLS-TD() with a unit forgetting factor.
Since

Pt = At1

(62)

P0 = I

(63)

r
K t +1 = Pt +1 z t

(64)

According to Lemma 1,

Pt +1 = At+11

r
r
= Pt  Pt z t [1 + ( T ( xt )   T ( x t +1 )) Pt z t )] 1 ( T ( x t )   T ( xt +1 )) Pt

r
K t +1 = Pt +1 z t
r
r
= Pt z t /(1 + ( T ( xt )   T ( xt +1 )) Pt z t )

(65)

(66)

Wt +1 = At+11bt +1
t
r
= Pt +1 (  z i ri )

(67)

i =0

r
= Pt +1 ( Pt 1Wt + z t rt )
Thus

r
r
Wt +1 = Pt +1 [( Pt +11  z t ( T ( xt )   T ( x t +1 )))Wt + z t rt ]
r
r
= Wt + Pt +1 ( z t rt  z t ( T ( xt )   T ( x t +1 ))Wt )

(68)

= Wt + K t +1 [rt  ( T ( xt )   T ( xt +1 ))Wt ]
(2) RLS-TD() with a forgetting factor <1
The derivation of RLS-TD() with a forgetting factor <1 is similar to the exponentially weighted
RLS algorithm in Haykins (1996, pp.566-569). Here we only present the results:

Pt +1 =

1



r
r
K t +1 = Pt z t /(  + ( T ( x t )   T ( x t +1 )) Pt z t )

(69)

Wt +1 = Wt + K t +1 (rt  ( T ( x t )   T ( xt +1 ))Wt )

(70)

r
r
[ Pt  Pt z t [  + ( T ( xt )   T ( xt +1 )) Pt z t )]1 ( T ( xt )   T ( xt +1 )) Pt ]

288

(71)

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

Appendix B. Proof of Theorem 1
To study the steady property of the Markov chain defined in Section 3, we construct a stationary
process as follows. Let {xt} be a Markov chain that evolves according to the transition matrix P and is
already in its steady state, which means that Pr{xt=i}=  (i) for all i and t. Given any sample path of
the Markov chain, we define

r
zt =

t

 ( ) t   ( x )

(72)

 = 

r

Then X t = {xt , xt +1 , z t } is a stationary process, which is the same as that discussed in (Tsitsiklis
and Roy, 1997).
Let D denote a NN diagonal matrix with diagonal entries  (1),  (2),,  (N), where N is
the cardinality of state space X. Then Lemma 2 can be derived as follows.
Lemma 2. (Tsitsiklis and Roy, 1997) Under Assumption 1-4, the following equations hold.
1) E 0 [ ( xt ) ( xt + m )] =  T DP m  , for m>0

r
2) E 0 [ z t  T ( xt )] =

(73)



 ( ) m  T DP m  ,

(74)

m =0

r
3) E 0 [ z t rt ( xt , xt +1 )] =



 ( ) m  T DP m r

(75)

m =0

where r  R N , whose Nth component is equal to E[r ( xt , xt +1 ) xt = i ] .
According to Lemma 2, E0[A(Xt)] and E0[b(Xt)] are well defined and finite. Furthermore, E0[A(Xt)]
is negative definite, so it is invertible.
From equation (67),
T

T

WRLS TD (  ) = [ P01 +  A( X t )] 1 [ P01W0 +  b( X t )]
t =1

t =1

1
1
1
1 T
= [ P01 +  A( X t )] 1 [ P01W0 +  b( X t )]
T
T t =1
T
T t =1
T

(76)

Since

1 T
 A( X t )
T  T
t =1

(77)

1 T
 b( X t )
T  T
t =1

(78)

E 0 [ A( X t )] = lim

E 0 [b( X t )] = lim
and E0[A(Xt)] is invertible,
1

lim W RLS TD (  ) = E 0 [ A( X t )]E 0 [b( X t )] = W *

T 

289

(79)

fiXU, HE, & HU

Thus W RLS TD (  ) converges to W* with probability 1.

Appendix C. Some details of the coding structures of CMAC networks
In the following discussion, the coding structures of CMAC networks in the cart-pole balancing
problem and the acrobot control problem are presented.
(1) CMAC coding structures in the cart-pole balancing problem
In the CMAC networks, the state variables have the following boundaries.

  [12 o ,12 o ] ,

&  [50 deg/ s, 50 deg/ s]

x  [2.4, 2.4] ,
x&  [1,1]
For the critic network, C=4 and M=7. The hashing technique specified in equations (50) and (51)
is employed and the total memory size is 30.
For the actor network, C=4 and M=7. The hashing technique specified in equations (60) and (61)
is employed and the total memory size is 100.
(2) CMAC coding structures in the acrobot swing-up problem
In the simulation, the angles are bounded by [ ,  ] and the angular velocities are bounded by

&1  [4 ,4 ] , &2  [9 ,9 ] . The tiling numbers of the actor and the critic both are equal to 4
(C=4). The total memory sizes for the critic and the actor are 80 and 100, respectively. In the actor
network, each tiling partitions the range of each input into 7 equal intervals (M=7). In the critic
network, the partitions for each input are non-uniform, which are given by

 1 : { -, -1, -0.5, 0, 0.5, 1, },

&1 : {-4, -1.5, -0.5, 0, 0.5, 1.5, 4}

 2 : {-, -1, -0.5, 0, 0.5, 1, },

&2 : {-9, -2, -0.5,0, 0.5,2, 9}

290

fiEFFICIENT REINFORCEMENT LEARNING USING RLS METHODS

References
Albus,J.S.(1975). A new approach to manipulator control: the cerebellar model articulation
controller (CMAC). Journal of Dynamic Systems, Measurement, and Control, 97(3), 220-227.
Barto,A.G., Sutton R.S., & Anderson C.W. (1983). Neuronlike adaptive elements that can solve
difficult learning control problems. IEEE Transactions on System, Man, and Cybernetics,13,
834-846.
Bertsekas D.P. & Tsitsiklis J.N. (1996). Neurodynamic Programming. Belmont, Mass.: Athena
Scientific.
Berenji H.R. & Khedkar P. (1992). Learning and tuning fuzzy logic controllers through reinforcements, IEEE Trans.On Neural Networks, 3(5), 724-740.
Boyan. J.(1999). Least-squares temporal difference learning. In Bratko, I., and Dzeroski, S., eds.,
Machine Learning: Proceedings of the Sixteenth International Conference (ICML).
Boyan, J.(2002). Technical update: least-squares temporal difference learning. Machine Learning,
Special Issue on Reinforcement Learning, to appear.
Brartke. S.J. & Barto A. (1996). Linear least-squares algorithms for temporal difference learning.
Machine Learning, 22, 33-57.
Dayan P.(1992). The convergence of TD() for general . Machine Learning, 8, 341-362.
Dayan P.. & Sejnowski T.J. (1994). TD() converges with probability 1. Machine Learning, 14,
295-301.
Eleftheriou E. & Falconer,D.D. (1986). Tracking properties and steady state performance of RLS
adaptive filter algorithms. IEEE Transactions on Acoustics, Speech, and Signal Processing, 34,
1097-1110.
Eweda E. & Macchi, O. (1987). Convergence of the RLS and LMS adaptive filters. IEEE Trans.
Circuits and Systems, 34, 799-803.
Haykin S. (1996), Adaptive Filter Theory, 3rd edition, Englewood Cliffs, NJ: Prentice-Hall.
Hubing N.E. & Alexander S.T. (1989). Statistical analysis of the soft constrained initialization of
RLS algorithms. In Proc. of the IEEE International Conference on Acoustics, Speech and
Signal Processing.
Jaakkola T., Jordan M.I., & Singh S.P. (1994). On the convergence of stochastic iterative dynamic
programming algorithms. Neural Computation. 6(6), 1185-1201.
Kaelbling L.P., Littman M.L., & Moore A.W. (1996). Reinforcement learning: a survey. Journal
of Artificial Intelligence Research, 4, 237-285.
Konda V.R, & Tsitsiklis J.N. (2000). Actor-critic algorithms. In Neural Information Processing
Systems, 2000, MIT Press.
291

fiXU, HE, & HU

Lin L.J. (1992). Self-improving reactive agents based reinforcement learning, planning and
teaching. Machine Learning, 8(3/4), 293-321.
Lin C.T. & Lee C.S.G. (1994). Reinforcement structure/parameter learning for neural-networkbased fuzzy Logic control system. IEEE Transactions on Fuzzy System, 2(1), 46-63.
Ljung L. & Soderstron T. (1983). Theory and Practice of Recursive Identification. MIT Press.
Ljung L. (1977). Analysis of recursive stochastic algorithm. IEEE. Transactions on Automatic
Control, 22, 551.
Michie D. & Chambers R.A. (1968). BOXES: An experiment in adaptive control. Machine
Intelligence 2, Dale E. and Michie D., eds., Edinburgh: Oliver and Boyd, 137-152.
Minsky M.L. (1954). Theory of neural-analog reinforcement systems and its application to the
brain-model problem. Ph.D. Thesis, Princeton University.
Moustakides G.V. (1997). Study of the transient phase of the forgetting factor RLS. IEEE Trans.
on Signal Processing, 45(10), 2468-2476.
Samuel A.L. (1959). Some studies in machine learning using game of checkers. IBM Journal on
Research and Development, 3, 211-229.
Singh, S.P., Jaakkola T., Littman M.L., & Szepesvari C. (2000). Convergence results for singlestep on-policy reinforcement-learning algorithms. Machine Learning, 38, 287-308.
Sutton R. & Barto A. (1998). Reinforcement Learning, an Introduction. Cambridge MA, MIT
Press.
Sutton R. (1988). Learning to predict by the method of temporal differences. Machine Learning,
3(1), 9-44.
Tsitsiklis J.N. (1994). Asynchronous stochastic approximation and Q-learning. Machine Learning,
16, 185-202.
Tsitsiklis J.N. & Roy B.V. (1994). Feature-based methods for large scale dynamic programming.
Neural Computation. 6(6), 1185-1201.
Tsitsiklis J.N. & Roy B.V. (1997). An analysis of temporal difference learning with function
approximation. IEEE Transactions on Automatic Control. 42(5), 674-690.
Watkins C.J.C.H. & Dayan P. (1992). Q-Learning. Machine Learning. 8, 279-292.
Young P. (1984). Recursive Estimation and Time-Series Analysis. Springer-Verlag.

292

fiJournal of Artificial Intelligence Research 16 (2002) 1-58

Submitted 7/01; published 1/02

Fusions of Description Logics and
Abstract Description Systems
Franz Baader
Carsten Lutz

baader@cs.rwth-aachen.de
lutz@cs.rwth-aachen.de

Teaching and Research Area for Theoretical Computer Science,
RWTH Aachen, Ahornstrae 55, 52074 Aachen, Germany

Holger Sturm

holger.sturm@uni-konstanz.de

Fachbereich Philosophie, Universitat Konstanz,
78457 Konstanz, Germany

Frank Wolter

wolter@informatik.uni-leipzig.de

Institut fur Informatik, Universitat Leipzig,
Augustus-Platz 10-11, 04109 Leipzig, Germany

Abstract
Fusions are a simple way of combining logics. For normal modal logics, fusions have
been investigated in detail. In particular, it is known that, under certain conditions, decidability transfers from the component logics to their fusion. Though description logics
are closely related to modal logics, they are not necessarily normal. In addition, ABox
reasoning in description logics is not covered by the results from modal logics.
In this paper, we extend the decidability transfer results from normal modal logics to
a large class of description logics. To cover different description logics in a uniform way,
we introduce abstract description systems, which can be seen as a common generalization
of description and modal logics, and show the transfer results in this general setting.

1. Introduction
Knowledge representation systems based on description logics (DL) can be used to represent the knowledge of an application domain in a structured and formally well-understood
way (Brachman & Schmolze, 1985; Baader & Hollunder, 1991; Brachman, McGuinness,
Patel-Schneider, Alperin Resnick, & Borgida, 1991; Woods & Schmolze, 1992; Borgida,
1995; Horrocks, 1998). In such systems, the important notions of the domain can be described by concept descriptions, i.e., expressions that are built from atomic concepts (unary
predicates) and atomic roles (binary predicates) using the concept constructors provided
by the description logic employed by the system. The atomic concepts and the concept
descriptions represent sets of individuals, whereas roles represent binary relations between
individuals. For example, using the atomic concepts Woman and Human, and the atomic
role child, the concept of all women having only daughters (i.e., women such that all their
children are again women) can be represented by the description Woman u child.Woman,
and the concept of all mothers by the description Woman u child.Human. In this example,
we have used the constructors concept conjunction (u), value restriction (R.C), and existential restriction (R.C). In the DL literature, also various other constructors have been
considered. A prominent example are so-called number restrictions, which are available in
almost all DL systems. For example, using number restrictions the concept of all women
c
2002
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiBaader, Lutz, Sturm, & Wolter

having exactly two children can be represented by the concept description
Woman u ( 2child) u ( 2child).
The knowledge base of a DL system consists of a terminological component (TBox) and
an assertional component (ABox). In its simplest form, the TBox consists of concept
definitions, which assign names (abbreviations) to complex descriptions. More general TBox
formalisms allow for so-called general concept inclusion axioms (GCIs) between complex
descriptions. For example, the concept inclusion
Human u ( 3child) v entitled.Taxbreak
states that people having at least three children are entitled to a tax break. The ABox
formalism consists of concept assertions (stating that an individual belongs to a concept)
and role assertions (stating that two individuals are related by a role). For example, the
assertions Woman(MARY), child(MARY, TOM), Human(TOM) state that Mary is a woman,
who has a child, Tom, who is a human.
DL systems provide their users with various inference capabilities that allow them to
deduce implicit knowledge from the explicitly represented knowledge. For instance, the subsumption problem is concerned with subconcept-superconcept relationships: C is subsumed
by D (C v D) if, and only if, all instances of C are also instances of D, i.e., the first description is always interpreted as a subset of the second description. For example, the concept
description Woman obviously subsumes the concept description Woman u child.Woman.
The concept description C is satisfiable iff it is non-contradictory, i.e., it can be interpreted
by a nonempty set. In DLs allowing for conjunction and negation of concepts, subsumption can be reduced to (un)satisfiability: C v D iff C u D is unsatisfiable. The instance
checking problem consists of deciding whether a given individual is an instance of a given
concept. For example, w.r.t. the assertions from above, MARY is an instance of the concept
description Woman u child.Human. The ABox A is consistent iff it is non-contradictory,
i.e., it has a model. In DLs allowing for negation of concepts, the instance problem can be
reduced to (in)consistency of ABoxes: i is an instance of C w.r.t. the ABox A iff A{C(i)}
is inconsistent.
In order to ensure a reasonable and predictable behavior of a DL system, reasoning
in the DL employed by the system should at least be decidable, and preferably of low
complexity. Consequently, the expressive power of the DL in question must be restricted in
an appropriate way. If the imposed restrictions are too severe, however, then the important
notions of the application domain can no longer be expressed. Investigating this trade-off
between the expressivity of DLs and the complexity of their inference problems has thus
been one of the most important issues in DL research (see, e.g., Levesque & Brachman,
1987; Nebel, 1988; Schmidt-Schau, 1989; Schmidt-Schau & Smolka, 1991; Nebel, 1990;
Donini, Lenzerini, Nardi, & Nutt, 1991, 1997; Donini, Hollunder, Lenzerini, Spaccamela,
Nardi, & Nutt, 1992; Schaerf, 1993; Donini, Lenzerini, Nardi, & Schaerf, 1994; De Giacomo
& Lenzerini, 1994a, 1994b, 1995; Calvanese, De Giacomo, & Lenzerini, 1999; Lutz, 1999;
Horrocks, Sattler, & Tobies, 2000).
This paper investigates an approach for extending the expressivity of DLs that (in many
cases) guarantees that reasoning remains decidable: the fusion of DLs. In order to explain
2

fiFusions of Description Logics and Abstract Description Systems

the difference between the usual union and the fusion of DLs, let us consider a simple
example. Assume that the DL D1 is ALC, i.e., it provides for the Boolean operators u, t,
 and the additional concept constructors value restriction R.C and existential restriction
R.C, and that the DL D2 provides for the Boolean operators and number restrictions
( nR) and ( nR). If an application requires concept constructors from both DLs for
expressing its relevant concepts, then one would usually consider the union D1  D2 of D1
and D2 , which allows for the unrestricted use of all constructors. For example, the concept
description C1 := (R.A) u (R.A) u ( 1R) is a legal D1  D2 description. Note that this
description is unsatisfiable, due to the interaction between constructors of D1 and D2 . The
fusion D1 D2 of D1 and D2 prevents such interactions by imposing the following restriction:
one assumes that the set of all role names is partitioned into two sets, one that can be used
in constructors of D1 , and another one that can be used in constructors of D2 . Thus, the
description C1 from above is not a legal D1  D2 description since it uses the same role R
both in the existential restrictions (which are D1 -constructors) and in the number restriction
(which is a D2 -constructor). In contrast, the descriptions (R1 .A) u (R1 .A) u ( 1R2 )
and (R1 .( 1R2 )) are admissible in D1  D2 since they employ different roles in the D1 and D2 -constructors. If the concepts that must be expressed are such that they require
both constructors from D1 and D2 , but the ones from D1 for other roles than the ones from
D2 , then one does not really need the union of D1 and D2 ; the fusion would be sufficient.
What is the advantage of taking the fusion instead of the union? Basically, for the union
of two DLs one must design new reasoning methods, whereas reasoning in the fusion can be
reduced to reasoning in the component DLs. Indeed, reasoning in the union may even be
undecidable whereas reasoning in the fusion is still decidable. As an example, we consider
the DLs (i) ALCF, which extends the basic DL ALC by functional roles (features) and
the same-as constructor (agreement) on chains of functional roles (Hollunder & Nutt, 1990;
Baader, Burckert, Nebel, Nutt, & Smolka, 1993); and (ii) ALC +,,t , which extends ALC by
transitive closure, composition, and union of roles (Baader, 1991; Schild, 1991). For both
DLs, subsumption of concept descriptions is known to be decidable (Hollunder & Nutt,
1990; Schild, 1991; Baader, 1991). However, their union ALCF +,,t has an undecidable
subsumption problem (Baader et al., 1993). This undecidability result depends on the fact
that, in ALCF +,,t , the role constructors transitive closure, composition, and union can
be applied to functional roles that also appear within the same-as constructor. This is not
allowed in the fusion ALCF  ALC +,,t . Of course, failure of a certain undecidability proof
does not make the fusion decidable.
Why do we know that the fusion of decidable DLs is again decidable? Actually, in
general we dont, and this was our main reason for writing this paper. The notion fusion was introduced and investigated in modal logic, basically to transfer results like finite
axiomatizability, decidability, finite model property, etc. from uni-modal logics (with one
pair of box and diamond operators) to multi-modal logics (with several such pairs, possibly satisfying different axioms). This has led to rather general transfer results (see, e.g.,
Wolter, 1998; Kracht & Wolter, 1991; Fine & Schurz, 1996; Spaan, 1993; Gabbay, 1999
for results that concern decidability), which are sometimes restricted to so-called normal
modal logics (Chellas, 1980). Since there is a close relationship between modal logics and
DLs (Schild, 1991), it is clear that these transfer results also apply to some DLs. The question is, however, to which DLs exactly and to which inference problems. First, some DLs
3

fiBaader, Lutz, Sturm, & Wolter

allow for constructors that are not considered in modal logics (e.g., the same-as constructor
mentioned above). Second, some DL constructors that have been considered in modal logics, such as qualified number restrictions ( nR.C), ( nR.C) (Hollunder & Baader, 1991),
which correspond to graded modalities (Van der Hoek & de Rijke, 1995), can easily be
shown to be non-normal. Third, the transfer results for decidability are concerned with the
satisfiability problem (with or without general inclusion axioms). ABoxes and the related
inference problems are not considered. ABoxes can be simulated in modal logics allowing
for so-called nominals, i.e., names for individuals, within formulae (Prior, 1967; Gargov
& Goranko, 1993; Areces, Blackburn, & Marx, 2000). However, as we will see below, the
general transfer results do not apply to modal logics with nominals.
The purpose of this paper is to clarify for which DLs decidability of the component DLs
transfers to their fusion. To this purpose, we introduce so-called abstract description systems
(ADSs), which can be seen as a common generalization of description and modal logics.
We define the fusion of ADSs, and state four theorems that say under which conditions
decidability transfers from the component ADSs to their fusion. Two of these theorems
are concerned with inference w.r.t. general concept inclusion axioms and two with inference
without TBox axioms. In both cases, we first formulate and prove the results for the
consistency problem of ABoxes (more precisely, the corresponding problem for ADSs) and
then establish analogous results for the satisfiability problem of concepts.
From the DL point of view, the four theorems shown in this paper are concerned with
the following four decision problems:
(i) decidability of consistency of ABoxes w.r.t. TBox axioms (Theorem 17);
(ii) decidability of satisfiability of concepts w.r.t. TBox axioms; (Corollary 22);
(iii) decidability of consistency of ABoxes without TBox axioms (Theorem 29); and
(iv) decidability of satisfiability of concepts without TBox axioms (Corollary 34).
These theorems imply that decidability of the consistency problem and the satisfiability
problem transfers to the fusion for most DLs considered in the literature. The main exceptions (which do not satisfy the prerequisites of the theorems) are
(a) DLs that are not propositionally closed, i.e., do not contain all Boolean connectives;
(b) DLs allowing for individuals (called nominals in modal logic) in concept descriptions;
and
(c) DLs explicitly allowing for the universal role or for negation of roles.
Results from modal logic for problem (iv) usually require the component modal logics to
be normal. Our Theorem 29 is less restrictive, and thus also applies to DLs allowing for
constructors like qualified number restrictions.

2. Description logics
Before defining abstract description systems in the next section, we introduce the main
features of DLs that must be covered by this definition. To this purpose, we first introduce
4

fiFusions of Description Logics and Abstract Description Systems

ALC, the basic DL containing all Boolean connectives, and the relevant inference problems.
Then, we consider different possibilities for extending ALC to more expressive DLs.
Definition 1 (ALC Syntax). Let NC , NR , and NI be countable and pairwise disjoint sets
of concept, role, and individual names, respectively. The set of ALC concept descriptions
is the smallest set such that
1. every concept name is a concept description,
2. if C and D are concept descriptions and R is a role name, then the following expressions are also concept descriptions:
 C (negation), C u D (conjunction), C t D (disjunction),
 R.C (existential restriction), and R.C (value restriction).
We use > as an abbreviation of A t A and  as an abbreviation for A u A (where A is
an arbitrary concept name).
Let C and D be concept descriptions. Then C v D is a general concept inclusion axiom
(GCI). A finite set of such axioms is called a TBox.
Let C be a concept description, R a role name, and i, j individual names. Then C(i) is
a concept assertion and R(i, j) a role assertion. A finite set of such assertions is called an
ABox.
The meaning of ALC-concept descriptions, TBoxes, and ABoxes can be defined with
the help of a set-theoretic semantics.
Definition 2 (ALC Semantics). An ALC-interpretation I is a pair (I , I ), where I
is a nonempty set, the domain of the interpretation, and I is the interpretation function.
The interpretation function maps
 each concept name A to a subset AI of I ,
 each role name R to a subset RI of I  I ,
 each individual name i to an element iI of I such that different names are mapped
to different elements (unique name assumption).
For a role name R and an element a  I we define RI (a) := {b | (a, b)  RI }. The
interpretation function can inductively be extended to complex concepts as follows:
(C)I := I \ C I
(C u D)I := C I  DI
(C t D)I := C I  DI
(R.C)I := {a  I | RI (a)  C I 6= }
(R.C)I := {a  I | RI (a)  C I }
An interpretation I is a model of the TBox T iff it satisfies C I  DI for all GCIs C v D
in T . It is a model of the ABox A iff it satisfies iI  C I for all concept assertions C(i)  A
and (iI , j I )  RI for all role assertions R(i, j)  A. Finally, I is a model of an ABox
relative to a TBox iff it is a model of both the ABox and the TBox.
5

fiBaader, Lutz, Sturm, & Wolter

Given this semantics, we can now formally define the relevant inference problems.
Definition 3 (Inferences). Let C and D be concept descriptions, i an individual name,
T a TBox, and A an ABox. We say that C subsumes D relative to the TBox T (D vT C)
iff DI  C I for all models I of T . The concept description C is satisfiable relative to the
TBox T iff there exists a model I of T such that C I 6= . The individual i is an instance of
C in the ABox A relative to the TBox T iff iI  C I for all models of A relative to T . The
ABox A is consistent relative to the TBox T iff there exists a model of A relative to T .
These three inferences can also be considered without reference to a TBox: C subsumes
D (C is satisfiable) iff C subsumes D (C is satisfiable) relative to the empty TBox, and i
is an instance of C in A (A is consistent) iff i is an instance of C in A (A is consistent)
relative to the empty TBox.
We restrict our attention to DLs that are propositionally closed (i.e., allow for the
Boolean operators conjunction, disjunction, and negation). Consequently, subsumption
can be reduced to (un)satisfiability since C vT D iff C u D is unsatisfiable relative to T .
Conversely, (un)satisfiability can be reduced to subsumption since C is unsatisfiable relative
to T iff C vT . For this reason, it is irrelevant whether we consider the subsumption or the
satisfiability problem in our results concerning the transfer of decidability of these problems
from component DLs to their fusion (informally called transfer results in the following).
Similarly, the instance problem can be reduced to the (in)consistency problem and vice
versa: i is an instance of C in A relative to T iff A  {C(i)} is inconsistent relative to T ;
and A is inconsistent relative to T iff i is an instance of  in A relative to T , where i is an
arbitrary individual name. Consequently, it is irrelevant whether we consider the instance
problem or the consistency problem in our transfer results.
Finally, the satisfiability problem can be reduced to the consistency problem: C is satisfiable relative to T iff the ABox {C(i)} is consistent relative to T , where i is an arbitrary
individual name. However, the converse need not be true. It should be obvious that this
implies that a transfer result for the satisfiability problem does not yield the corresponding
transfer result for the consistency problem: from decidability of the consistency problem
for the component DLs we can only deduce decidability of the satisfiability problem in their
fusion. What might be less obvious is that a transfer result for the consistency problem need
not imply the corresponding transfer result for the satisfiability problem: if the satisfiability
problems in the component DLs are decidable, then the transfer result for the consistency
problem can just not be applied (since the prerequisite of this transfer result, namely, decidability of the consistency problem in the component DLs, need not be satisfied). However,
we will show that the method used to show the transfer result for the consistency problem
also applies to the satisfiability problem.
2.1 More expressive DLs
There are several possibilities for extending ALC in order to obtain a more expressive DL.
The three most prominent are adding additional concept constructors, adding role constructors, and formulating restrictions on role interpretations. In addition to giving examples
for such extensions, we also introduce a naming scheme for the obtained DLs. Additional
concept constructors are indicated by appending caligraphic letters to the language name,
role constructors by symbols in superscript, and restrictions on roles by letters in subscript.
6

fiFusions of Description Logics and Abstract Description Systems

We start with introducing restrictions on role interpretations, since we need to refer to
such restrictions when defining certain concept constructors.
2.1.1 Restrictions on role interpretations
These restrictions enforce the interpretations of roles to satisfy certain properties, such as
functionality, transitivity, etc. We consider three prominent examples:
1. Functional roles. Here one considers a subset NF of the set of role names NR ,
whose elements are called features. An interpretation must map features f  NF to
functional binary relations f I  I  I , i.e., relations satisfying a, b, c.f I (a, b) 
f I (a, c)  b = c. We will sometimes treat functional relations as partial functions,
and write f I (a) = b rather than f I (a, b). ALC extended with features is denoted by
ALC f .
2. Transitive roles. Here one considers a subset NR+ of NR . Role names R  NR+
are called transitive roles. An interpretation must map transitive roles R  NR+ to
transitive binary relations RI  I  I . ALC extended with transitive roles is
denoted by ALC R+ .
3. Role hierarchies. A role inclusion axiom is an expression of the form R v S with
R, S  NR . A finite set H of role inclusion axioms is called a role hierarchy. An
interpretation must satisfy RI  S I for all R v S  H. ALC extended with a role
hierarchy H is denoted by ALC H(H) . If H is clear from the context or irrelevant, we
write ALCH instead of ALC H(H) .
The above restrictions can also be combined with each other. For example, ALC HR+ is ALC
with a role hierarchy and transitive roles.
Transitive roles in DLs were first investigated by Sattler (1996). Features were introduced in DLs by Hollunder and Nutt (1990) and (under the name attributes) in the
CLASSIC system (Brachman et al., 1991), in both cases in conjunction with feature agreements and disagreements (see concept constructors below). Features without agreements
and disagreements are, e.g., used in the DL SHIF (Horrocks & Sattler, 1999), albeit in a
more expressive local way, where functionality can be asserted to hold at certain individuals, but not necessarily on the whole model. According to our naming scheme, we indicate
the presence of features in a DL by the letter f in subscript.1
A remark on role hierarchies is also in order: in our definition, if H1 and H2 are different
role hierarchies, then ALC H(H1 ) and ALC H(H2 ) are different DLs. In the DL literature,
usually only one logic ALCH is defined and role hierarchies are treated like TBoxes, i.e.,
satisfiability and subsumption are defined relative to TBoxes and role hierarchies (see, e.g.,
Horrocks, 1998). For our purposes, however, it is more convenient to define one DL per role
hierarchy since distinct role hierarchies impose distinct restrictions on the interpretation of
roles. The advantages of this approach will become clear later on when frames and abstract
description systems are introduced.
1. Note that some authors (e.g., Horrocks & Sattler, 1999) use an appended F to denote local features.
Following Hollunder and Nutt (1990), we will use F to denote a DL that allows for feature agreements
(see below).

7

fiBaader, Lutz, Sturm, & Wolter

Name
Unqualified
number restrictions
Qualified
number restrictions
Nominals
Feature agreement
and disagreement

Syntax
nR
nR
nR.C
nR.C
I
u1 u2
u1 u2

Semantics
{a  I | |RI (a)|  n}
{a  I | |RI (a)|  n}
{a  I | |RI (a)  C I |  n}
{a  I | |RI (a)  C I |  n}
I I  I with |I I | = 1
{a  I | b  I . uI1 (a) = b = uI2 (a)}
{a  I | b1 , b2  I .
uI1 (a) = b1 6= b2 = uI2 (b1 )}

Symbol
N
Q
O
F

Figure 1: Some description logic concept constructors.
2.1.2 Concept constructors
Concept constructors take concept and/or role descriptions and transform them into more
complex concept descriptions. In addition to the constructors available in ALC, various
other concept constructors are considered in the DL literature. A small collection of such
constructors can be found in Figure 1, where |S| denotes the cardinality of a set S. The
symbols in the rightmost column indicate the naming scheme for the resulting DL. As
mentioned above the name modifiers for concept constructors are not written in subscript,
they are appended to the language name. For example, ALC HR+ extended with qualified
number restrictions is called ALCQHR+ . The syntax of the extended DLs is as expected, i.e.,
the constructors may be arbitrarily combined. The semantics is obtained by augmenting
the semantics of ALC with the appropriate conditions, which can be found in the third
column in Figure 1. Nominals and feature (dis)agreements need some more explanation:
 Nominals. We consider a set NO of (names for) nominals, which is pairwise disjoint
to the sets NC , NR , and NI . Elements from NO are often denoted by I (possibly
with index). An interpretation must map nominals to singleton subsets of I . The
intention underlying nominals is that they stand for elements of , just like individual
names. However, since we want to use the nominal I  NO as a (nullary) concept
constructor, I must interpret them by a set, namely the singleton set consisting of
the individual that I denotes.
 Feature (dis)agreements. ALCF is the extension of ALC f with feature agreements
and disagreements. Beside the additional concept constructors, ALCF uses feature
chains as part of the (dis)agreement constructor. A feature chain is an expression of
the form u = f1      fn . The interpretation uI of such a feature chain is just the
composition of the partial functions f1I , . . . , fnI , where composition is to be read from
left to right.
DLs including nominals or feature (dis)agreements and additional concept constructors or
restrictions on role interpretations are defined (and named) in the obvious way.
Number restriction are available in almost all DL systems. The DL ALCN (i.e., ALC
extended with number restrictions) was first treated by Hollunder and Nutt (1990), as was
ALCF. The DL ALCQ was first investigated by Hollunder and Baader (1991), and ALCO
by Schaerf (1994).
8

fiFusions of Description Logics and Abstract Description Systems

Name
Role composition

Syntax
R1  R2

Semantics
{(a, b)  I  I |
c  I . (a, c)  R1I  (c, b)  R2I }
Role complement R
{(a, b)  I  I | (a, b) 
/ RI }
Role conjunction
R1 u R2 {(a, b)  I  I | (a, b)  R1I  (a, b)  R2I }
Role disjunction
R1 t R2 {(a, b)  I  I | (a, b)  R1I  (a, b)  R2I }
Inverse roles
R1
{(a, b)  I  I | (b, a)  RI }
Transitive closure R+
{(a, b)  I  I | (a, b)  (RI )+ }
Universal role
U
I  I
For a binary relation R, R+ denotes the transitive closure of R.

Symbol


u
t
1
+
U

Figure 2: Some description logic role constructors.
2.1.3 Role constructors
Role constructors allow us to build complex role descriptions. A collection of role constructors can be found in Figure 2. Again, the rightmost column indicates the naming scheme,
where name modifiers for role constructors are written in superscript and separated by
commas. For example, ALCQ with inverse roles and transitive closure is called ALCQ+,1 .
In DLs admitting role constructors, the set of role descriptions is defined inductively, analogously to the set of concept descriptions. The semantics of role constructors is given in
the third column of Figure 2. As with concept descriptions, it can be used to extend the
interpretation function from role names to role descriptions.
In a DL with role constructors, role descriptions can be used wherever role names may
be used in the corresponding DLs without role constructors. For example,
(R1 u R3 ).C u (R2 t R2 ).C
,u,t

is an ALC
-concept description. This concept description is unsatisfiable since R2 t R2
is equivalent to the universal role. Note that role descriptions can also be used within role
assertions in an ABox.
The DL ALC ,t,+ was first treated by Baader (1991) (under the name ALC trans ); Schild
(1991) has shown that this DL is a notational variant of propositional dynamic logic (PDL).
DLs with Boolean operators on roles were investigated by Lutz and Sattler (2000). The
inverse operator was available in the system CRACK (Bresciani, Franconi, & Tessaris,
1995), and reasoning in DLs with inverse roles was, for example, investigated by Calvanese
et al. (1998) and Horrocks et al. (2000). The universal role can be expressed using DLs with
Boolean operators on roles (see the above example), and it can in turn be used to simulate
general concept inclusion axioms within concept descriptions.
2.2 Restricting the syntax
Until now, constructors could be combined arbitrarily. Sometimes it makes sense to restrict
the interaction between constructors since reasoning in the restricted DL may be easier than
reasoning in the unrestricted DL. We will consider DLs imposing certain restrictions on

9

fiBaader, Lutz, Sturm, & Wolter

1. which roles may be used inside certain concept constructors,
2. which roles may be used inside certain role constructors,
3. the combination of role constructors, and
4. the role constructors that may be used inside certain concept constructors.
As an example for the first case, consider the fragment of ALCQR+ in which transitive roles
may be used in existential and universal restrictions, but not in number restrictions (see,
e.g., Horrocks et al., 2000).
As the result of taking the fusion of two DLs, we will obtain DLs whose set of roles NR
is partitioned. For example, the fusion of ALCQ with ALC 1 yields a fragment of ALCQ1
where NR is partitioned in two sets, say NR1 and NR2 . In this fragment, the inverse role
constructor and roles from NR2 may not be used within qualified number restrictions, while
roles from NR1 may not be used inside the inverse role constructor.2 Thus, this DL is an
example for the first, the second, and the fourth case.
Now consider the DL ALCF introduced above, which does not only extend ALC f with
feature (dis)agreement as a concept constructor, but also provides the role composition constructor. However, the role chains built using composition have to be comprised exclusively
of features and non-functional roles may not appear inside feature (dis)agreement. Hence,
ALCF is also an example for the first, second, and fourth case.
As an example for the third case, the fragment of ALC ,u in which role conjunction
may not be used inside the role complement constructor is considered by Lutz and Sattler
(2000).
For these restricted DLs, we do not introduce an explicit naming scheme. Note that,
in this paper, we do not deal with DLs in which the combinability of concept constructors
with each other is restricted since these DLs would not fit into the framework of abstract
description systems introduced in the next section. An example of such a DL would be
one with atomic negation of concepts, i.e., where negation may only be applied to concept
names (e.g., the DL AL discussed by Donini et al., 1997).

3. Abstract description systems
In order to define the fusion of DLs and prove general results for fusions of DLs, one needs
a formal definition of what are description logics. Since there exists a wide variety of DLs
with very different characteristics, we introduce a very general formalization, which should
cover all of the DLs considered in the literature, but also includes logics that would usually
not be subsumed under the name DL.
3.1 Syntax and semantics
The syntax of an abstract description system is given by its abstract description language,
which determines a set of terms, term assertions, and object assertions. In this setting,
concept descriptions are represented by terms that are built using the abstract description
2. This will become clearer once we have given a formal definition of the fusion.

10

fiFusions of Description Logics and Abstract Description Systems

language. General inclusion axioms in DLs are represented by term assertions and ABox
assertions in DLs are represented by object assertions.
Definition 4 (Abstract description language). An abstract description language (ADL)
is determined by a countably infinite set V of set variables, a countably infinite set X of
object variables, a (possibly infinite) countable set R of relation symbols of arity two,3 and
a (possibly infinite) countable set F of functions symbols f , which are equipped with arities
nf . All these sets have to be pairwise disjoint.
The terms tj of this ADL are built using the follow syntax rules:
tj

 x, t1 , t1  t2 , t1  t2 , f (t1 , . . . , tnf ),

where x  V , f  F, and the Boolean operators , ,  are different from all function
symbols in F. For a term t, we denote by var(t) the set of set variables used in t. The
symbol > is used as an abbreviation of x  x and  as an abbreviation for x  x (where
x is a set variable).
The term assertions of this ADL are
 t1 v t2 , for all terms t1 , t2 ,
and the object assertions are
 R(a, b), for a, b  X and R  R;
 (a : t), for a  X and t a term.
The sets of term and object assertions together form the set of assertions of the ADL.
From the DL point of view, the set variables correspond to concept names, object
variables to individual names, relation symbols to roles, and the Boolean operators as well
as the function symbols correspond to concept constructors. Thus, terms correspond to
concept descriptions. As an example, let us view concept descriptions of the DL ALCN u ,
i.e., ALC extended with number restrictions and conjunction of roles, as terms of an ADL.
Value restrictions and existential restrictions can be seen as unary function symbols: for
each role description R, we have the function symbols fR and fR , which take a term tC
(corresponding to the concept description C) and transform it into the more complex terms
fR (tC ) and fR (tC ) (corresponding to the concept descriptions R.C and R.C). Similarly,
number restrictions can be seen as nullary function symbols: for each role description R
and each n  N, we have the function symbols fnR and fnR . Hence, the ALCN u -concept
description A u (R1 u R2 ).(B u ( 2R1 )) corresponds to the term xA  f(R1 uR2 ) ((xB 
f(2R1 ) )). We will analyze the connection between ADLs and DLs more formally later on.
The semantics of abstract description systems is defined based on abstract description
models. These models are the general semantic structures in which the terms of the ADL
are interpreted. It should already be noted here, however, that an abstract description
system usually does not take into account all abstract description models available for the
language: it allows only for a selected subclass of these models. This subclass determines
the semantics of the system.
3. To keep things simpler, we restrict our attention to the case of binary predicates, i.e., roles in DL.
However, the results can easily be extended to n-ary predicates.

11

fiBaader, Lutz, Sturm, & Wolter

Definition 5. Let L be an ADL as in Definition 4. An abstract description model (ADM)
for L is of the form
D
E
W = W, F W = {f W | f  F}, RW = {RW | R  R} ,


ff
where W is a nonempty set, the f W are functions mapping every sequence X1 , . . . , Xnf
of subsets of W to a subset of W , and the RW are binary relations on W .
Since ADMs do not interpret variables, we need an assignment that assigns a subset
of W to each set variable, before we can evaluate terms in an ADM. To evaluate object
assertions, we need an additional assignment that assigns an element of W to each object
variable.
ff


Definition 6. Let L be an ADL and W = W, F W , RW be an ADM for L. An assignment
for W is a pair A = (A1 , A2 ) such that A1 is a mapping from the set of set variables V into
2W , and A2 is an injective4 mapping from the set of object variables X into W . Let W be
an ADM and A = (A1 , A2 ) be an assignment for W. With each L-term t, we inductively
associate a value tW,A in 2W as follows:
 xW,A := A1 (x) for all variables x  V ,
 t2W,A ,
, (t1  t2 )W,A := tW,A
 tW,A
 (t)W,A := W \ (t)W,A , (t1  t2 )W,A := tW,A
1
2
1
 f (t1 , . . . , tnf )W,A := f W (tW,A
, . . . , tW,A
nf ).
1
If x1 , . . . , xn are the set variables occurring in t, then we often write tW (X1 , . . . , Xn ) as
shorthand for tW,A , where A is an assignment with xA
i = Xi for 1  i  n.
The truth-relation |= between hW, Ai and assertions is defined as follows:
 hW, Ai |= R(a, b) iff A2 (a)RW A2 (b),
 hW, Ai |= a : t iff A2 (a)  tW,A ,
.
 tW,A
 hW, Ai |= t1 v t2 iff tW,A
2
1
In this case we say that the assertion is satisfied in hW, Ai. If, for an ADM W and a set of
assertions , there exists an assignment A for W such that each assertion in  is satisfied
in hW, Ai, then W is a model for .
There are two differences between ADMs and DL interpretations. First, in a DL interpretation, the interpretation of the role names fixes the interpretation of the function
symbols corresponding to concept constructors that involve roles (like value restrictions,
number restrictions, etc.). The interpretation of the concept names corresponds to an assignment. Thus, a DL model is an ADM together with an assignment, whereas an ADM
alone corresponds to what is called frame in modal logics. Second, in DL the roles used in
concept constructors may, of course, also occur in role assertions. In contrast, the definition
of ADMs per se does not enforce any connection between the interpretation of the function
symbols and the interpretation of the relation symbols. Such connections can, however, be
enforced by restricting the attention to a subclass of all possible ADMs for the ADL.
4. This corresponds to the unique name assumption.

12

fiFusions of Description Logics and Abstract Description Systems

Definition 7. An abstract description system (ADS) is a pair (L, M), where L is an ADL
and M is a class of ADMs for L that is closed under isomorphic copies.5
From the DL point of view, the choice of the class M defines the semantics of the
concept and role constructors, and it allows us, e.g., to incorporate restrictions on role
interpretations. In this sense, the ADS can be viewed as determining a (description) logic.
To be more concrete, in a DL interpretation the interpretation of the function symbols
is determined by the interpretation of the role names. Thus one can, for example, restrict
the class of models to ADMs that interpret a certain role as a transitive relation or as the
composition of two other roles. Another restriction that can be realized by the choice of
M is that nominals (corresponding to nullary function symbols) must be interpreted as
singleton sets.
Let us now define reasoning problems for abstract description systems. We will introduce
satisfiability of sets of assertions (with or without term assertions), which corresponds to
consistency of ABoxes (with or without GCIs), and satisfiability of terms (with or without
term assertions), which corresponds to satisfiability of concept descriptions (with or without
GCIs).
Definition 8. Given an ADS (L, M), a finite set of assertions  is called satisfiable in
(L, M) iff there exists an ADM W  M and an assignment A for W such that hW, Ai
satisfies all assertions in . The term t is called satisfiable in (L, M) iff {a : t} is satisfiable
in (L, M), where a is an arbitrary object variable.
 The satisfiability problem for (L, M) is concerned with the following question: given
a finite set of object assertions  of L, is  is satisfiable in (L, M).
 The relativized satisfiability problem for (L, M) is concerned with the following question: given a finite set of assertions  of L, is  is satisfiable in (L, M).
 The term satisfiability problem for (L, M) is concerned with the following question:
given a term t of L, is t satisfiable in (L, M).
 The relativized term satisfiability problem for (L, M) is concerned with the following
question: given a term t and a set of term assertions  of L, is {a : t}   satisfiable
in (L, M).
In the next section, we will define the fusion of two ADSs, and show that (relativized)
satisfiability is decidable in the fusion if (relativized) satisfiability in the component ADSs
is decidable. For these transfer results to hold, we must restrict ourselves to so-called local
ADSs.


ff
Wp , RWp over pairwise
Definition 9. Given a family (Wp )pP
 of ADMs W
p = Wp , F
ff
disjoint domains Wp , we say that W = W, F W , RW is the disjoint union of (Wp )pP iff
S
 W = pP Wp ,
5. Intuitively, this means that, if an ADM W belongs to M, then all ADMs that differ from it only w.r.t.
the names of the elements in its domain W also belong to M.

13

fiBaader, Lutz, Sturm, & Wolter

S
 f W (X1 , . . . , Xnf ) = pP f Wp (X1  Wp , . . . , Xnf  Wp ) for all f  F and
X1 , . . . , Xnf  W ,
S
 RW = pP RWp for all R  R.
An ADS S = (L, M) is called local iff M is closed under disjoint unions.
In the remainder of this section, we first analyze the connection between ADSs and DLs
in more detail, and then comment on the relationship to modal logics.
3.2 Correspondence to description logics
We will show that the DLs introduced in Section 2 correspond to ADSs. In order to do this,
we first need to introduce frames, a notion well-known from modal logic. Let L be one of
the DLs introduced in Section 2.
Definition 10 (Frames). An L-frame F is a pair (F , F ), where F is a nonempty set,
called the domain of F, and F is the interpretation function, which maps
 each nominal I to a singleton subset I F of F , and
 each role name R to a subset RF of F  F such that the restrictions for role
interpretations in L are satisfied. For example, in ALC R+ , each R  NR+ is mapped
to a transitive binary relation.
The interpretation function F can inductively be extended to complex roles in the obvious
way, i.e., by interpreting the role constructors in L according to their semantics as given in
Figure 2.
An interpretation I is based on a frame F iff I = F , RI = RF for all roles R  NR ,
and I I = I F for all nominals I  NO .
A frame can be viewed as an interpretation that is partial in the sense that the interpretation of individual and concept names is not fixed. Note that (in contrast to the case of
concept and individual names) the interpretation of nominals is already fixed in the frame.
The reason for this is that, if we do not interpret nominals in the frame, then we have to
treat them as set variables on the ADS side. These would, however, have to be variables
to which only singleton sets may be assigned. Since such a restriction is not possible in the
framework of ADSs as defined above, we interpret nominals in the frame. The consequence
is that they correspond to functions of arity 0 on the ADS side.
Now, we define the abstract description system S = (L, M) corresponding to a DL L.
It is straightforward to translate the syntax of L into an abstract description language L.
Definition 11 (Corresponding ADL). Let L be a DL with concept and role constructors
as well as restrictions on role interpretations as introduced in Section 2. The corresponding
abstract description language L is defined as follows. For every concept name A in L, there
exists a set variable xA in L, and for every individual name i in L there exists an object
variable ai in L. Let R be the set of (possibly complex) role descriptions of L. The set of
relation symbols of L is R, and the set of function symbols of L is the smallest set containing
1. for every role description R  R, unary function symbols fR and fR ,
14

fiFusions of Description Logics and Abstract Description Systems

2. if L provides unqualified number restrictions, then, for every n  N and every role
description R  R, function symbols fnR and fnR of arity 0,
3. if L provides qualified number restrictions, then, for every n  N and every role R  R,
unary function symbols fnR
and fnR
,


4. if L provides nominals, then, for every I  NO , a function symbol fI of arity 0,
5. if L provides feature agreement and disagreement, then, for every pair of feature chains
(u1 , u2 ), two function symbols fu1 u2 and fu1 u2 of arity 0.
For an L-concept description C, let tC denote the representation of C as an L-term,
which is defined in the obvious way: concept names A are translated into set variables xA ,
the concept constructors , u, and t are mapped to , , and , respectively, and all other
concept constructors are translated to the corresponding function symbols. Obviously, both
the sets of function and relation symbols of L may be infinite.
An example of the translation of concept descriptions into terms of an ADL was already
given above: the ALCN u -concept description A u (R1 u R2 ).(B u ( 2R1 )) corresponds
to the term xA  f(R1 uR2 ) ((xB  f(2R1 ) )).
We now define the set of abstract description models M corresponding to the DL L.
For every L-frame, M contains a corresponding ADM.
Definition 12 (Corresponding
Let
F = (F , F ) be a frame. The corresponding

 ADM).
ff
abstract description model W = W, F W , RW has domain W := F . The relation symbols
of L are just the role descriptions of L, and thus they are interpreted in the frame F. For
each relation symbol R  R we can hence define RW := RF .
To define F W , we need to define f W for every nullary function symbol f in L, and
W
f (X) for every unary function symbol f in L and every X  I . Let A be an arbitrary
concept name. For each X  F , let IX be the interpretation based on F mapping the
concept name A to X and every other concept name to .6 To define f W , we make a case
distinction according to the type of f :
W (X) := (R.A)IX ,
1. fR

W (X) := (R.A)IX ,
fR

W := (nR)I , f W := (nR)I ,
2. fnR
nR
W (X) := (nR.A)IX , f W (X) := (nR.A)IX ,
3. fnR


nR

4. fIW := I I ,
5. fuW1 u2 = (u1 u2 )I , fuW1 u2 = (u1 u2 )I .
The class of ADMs M thus obtained from a DL L is obviously closed under isomorphic copies since this also holds for the set of L-frames (independently of which DL L we
consider). Hence, the tuple S = (L, M) corresponding to a DL L is indeed an ADS.
As an example, let us view the DL ALCN u as an ADS. The ADL L corresponding to
ALCN u has already been discussed. Thus, we concentrate on the class of ADMs M induced
6. Taking the empty set here is arbitrary.

15

fiBaader, Lutz, Sturm, & Wolter

by the frames of ALCN u . Assume that F is such a frame, i.e., F consists
of a nonempty


ff
domain and interpretations RF of the role names R. The ADM W = W, F W , RW induced
by F is defined as follows. The set W is identical to the domain of F. Each role description
yields a relation symbol, which is interpreted in W just as in the frame. For example,
(R1 u R2 )W = R1F  R2F . It remains to define the interpretation of the function symbols.
We illustrate this on two examples. First, consider the (unary) function symbol f(R1 uR2 ) .
W
Given a subset X of W , the function f(R
maps X to
1 uR2 )
W
f(R
(X) := {w  W | v  X for all v with (w, v)  R1F  R2F },
1 uR2 )

i.e., the interpretation of the concept description (R1 u R2 ).A in the interpretations based
on F interpreting A by X. Accordingly, the value of the constant symbol f(2R) in W is
given by the interpretation of ( 2R) in the interpretations based on F.
It is easy to show that the interpretation of concept descriptions in L coincides with the
interpretation of the corresponding terms in S = (L, M).


ff
Lemma 13. Let F be a frame, W = W, F W , RW be the ADM corresponding to F, A =
(A1 , A2 ) be an assignment for W, C be a concept description, and let the concept names
used in C be among A1 , . . . , Ak . For all interpretations I based on F with AIi = A1 (xAi )
for all 1  i  k, we have that
C I = tW,A
.
C
As an easy consequence of this lemma, there is a close connection between reasoning
in a DL L and reasoning in the corresponding ADS. Given a TBox T and an ABox A of
the DL L, we define the corresponding set S(T , A) of assertions of the corresponding ADL
(L, M) in the obvious way, i.e., each GCI C v D in T yields a term assertion tC v tD , each
role assertion R(i, j) in A yields an object assertion R(ai , aj ), and each concept assertion
C(i) yields an object assertion ai : tC .
Proposition 14. The ABox A is consistent relative to the TBox T in L iff S(T , A) is
satisfiable in the corresponding ADS.
We do not treat non-relativized consistency explicitly since it is the special case of
relativized consistency where the TBox is empty.
As already mentioned above, our transfer results require the component ADSs to be
local. We call a DL L local iff the ADS (L, M) corresponding to L is local. It turns out
that not all DLs introduced in Section 2 are local.
Proposition 15. Let L be one of the DLs introduced in Section 2. Then, L is local iff L
does not include any of the following constructors: nominals, role complement, universal
role.
Proof. We start with the only if direction, which is more interesting since it shows why
ADSs corresponding to DLs with nominals, role complement, or the universal role are not
local. We make a case distinction according to which of these constructors L contains.
 Nominals. Consider the disjoint union W of the ADMs W1 and W2 , and assume
that W1 and W2 correspond to frames of a DL with nominals. By definition of the
16

fiFusions of Description Logics and Abstract Description Systems

disjoint union, we know that W1  W2 = . If I  NO is a nominal, then the
definition of the disjoint union implies that fIW = fIW1  fIW2 . Since nominals are
interpreted by singleton sets in W1 and W2 , and since the domains of W1 and W2
are disjoint, this implies that fIW is a set of cardinality 2. Consequently, W cannot
correspond to an ADM induced by a frame for a DL with nominals, since such frames
interpret nominals by singleton sets.
 Universal role. Again, consider the disjoint union W of the ADMs W1 and W2 , and
assume that W1 and W2 correspond to frames of a DL with the universal role. Let U
denote the universal role, i.e., a role name for which the interpretation is restricted to
the binary relation relating each pair of individuals of the domain. By the definition of
the disjoint union, we have U W = U W1 U W2 = W1 W1 W2 W2 6= W W .
Consequently, W cannot correspond to an ADM induced by a frame for a DL with
universal role, since such a frame would interpret U by W  W .
 Role complement. Again, consider the disjoint union W of the ADMs W1 and W2 ,
and assume that W1 and W2 correspond to frames of a DL with role negation. For an
W
W
W
arbitrary role name R, we have R = R 1  R 2 = (W1  W1 \ RW1 )  (W2 
W2 \ RW2 ) 6= (W1  W2 ) \ (RW1  RW2 ) = W \ RW .
It remains to prove the if direction. Assume that L is one of the DLs introduced in
Section 2 that does not allow for nominals, role complements, and
 the universal role.
Let
ff
(Fp )pP be a family of L-frames Fp = (Fp , Fp ) and let Wp = Wp , F Wp , RWp be the
ADMs corresponding to them. By definition, Fp = Wp for all p  P . Assume that the
domains (Wp )pP are pairwise disjoint. We must show that the disjoint union of (Wp )pP
also corresponds to an L-frame. To this purpose, we define the frame F = (F , F ) as
follows:
 F :=

S

 RF :=

S

pP

Fp and

pP

RFp for all R  NR .

ff


Let W = W, F W , RW  M be the
S ADM corresponding
S to F.WpBy Definition 12 (corW
responding ADM), we have W = pP Wp and R = pP R
for all R  NR . By
induction on the structure of complex roles, it is easy to show that this also holds for
all R  R, i.e., all complex role descriptions. For example, consider the role description
S
S
W
W
R1  R2 . By induction, we know that R1W = pP R1 p and R2W = pP R2 p . Since the
sets (Wp )pP are pairwise disjoint,
(R1  R2 )W = R1W  R2W =

[

pP

Wp

R1



[

Wp

R2

pP

=

[

pP

Wp

R1

Wp

 R2

=

[

(R1  R2 )Wp .

pP

Since RWp = RFp for all R  R and p  P , we obtain the following fact:
() For all p  P , a  Fp , and role descriptions R  R, the following holds: RF (a) =
RFp (a); in particular, RF (a)  Fp .
17

fiBaader, Lutz, Sturm, & Wolter

It remains to show that, for all n  0, all X1 , . . . , Xn  W , and all function symbols f of
arity n, we have
[
f W (X1 , . . . , Xn ) =
f Wp (X1  Wp , . . . , Xn  Wp ).
pP

This can be proved by making a case distinction according to the type of f . We treat two
cases exemplarily.
S
 f = fu1 u2 . Since W = pP Wp and the sets Wp are pairwise disjoint, fuW1 u2 is the
disjoint union of the sets fuW1 u2  Wp for p  P . It remains to show that fuW1 u2  Wp =
W

W

W

p
p
p
fu1 u
(p  P ). By definition of fu1 u
, we know that a  fu1 u
iff a  Fp , both
2
2
2

F

F

F

F

u1 p (a) and u2 p (a) are defined, and u1 p (a) = u2 p (a). By (), this is the case iff
a  Fp , both uF1 (a) and uF2 (a) are defined and uF1 (a) = uF2 (a), which is equivalent to
a  fuW1 u2  Wp .
S
W (X) is
 f = fnR
. Since W = pP Wp and the sets Wp are pairwise disjoint, fnR



W (X)  W for p  P . It remains to show that
the disjoint union of the sets fnR
p

W

W

W (X)  W = f p (X  W ) (p  P ). By definition of f p , we know that
fnR
p
p



nR
nR
W

p
a  fnR
(X  Wp ) iff a  Fp and |RFp (a)  (X  Wp )|  n. By (), this is the case iff


W (X)  W .
|RF (a)  (X  Wp )|  n iff |RF (a)  X|  n, and hence iff a  fnR
p




It should be noted that arguments similar to the ones used in the proof of the only
if direction show that, in the presence of the universal role or of role negation, function
symbols (e.g., fU ) may also violate the locality condition.
The transfer results for decidability that are developed in this paper only apply to fusions
of local ADSs. Hence, the only if direction of the proposition implies that our results
are not applicable to fusions of ADSs corresponding to DLs that incorporate nominals, role
complement, or the universal role.
3.3 Correspondence to modal logics
In this paper our concern are fusions of description logics and not modal logics. Nevertheless,
it is useful to have a brief look at the relationship between ADSs and modal logic. Standard
modal languages can be regarded as ADLs without relation symbols and object variables
(just identify propositional formulas with terms). Given such an ADL L, a set L of L-terms
is called a classical modal logic iff is contains all tautologies of classical propositional logic
and is closed under modus ponens, substitutions, and the regularity rule
x1  y1 , . . . , xnf  ynf
f (x1 , . . . , xnf )  f (y1 , . . . , ynf )
for all function symbols f of L. The minimal classical modal logic in the language with one
unary function symbol is known as the logic E (see Chellas, 1980).
Any ADS (L, M) based on L determines a classical modal logic L by taking the valid
terms, i.e., by defining
t  L iff tW,A = W for all W  M and assignments A in W.
18

fiFusions of Description Logics and Abstract Description Systems

The logic E is determined by the ADS with precisely one unary operator whose class
of ADMs consists of all models. Chellas formulates this completeness result (Theorem
9.8 in Chellas, 1980) for so-called minimal models (alias neighborhood-frames), which are,
however, just a notational variant of abstract description models with one unary operator
(Dosen, 1988). If the classical modal logic L is determined by an ADS with decidable term
satisfiability problem, then L is decidable since t  L iff t is unsatisfiable.
A classical modal logic L is called normal iff it additionally contains
f (x1 , . . . , xj1 , xj  yj , xj+1 , . . . , xnf )  f (x1 , . . . , xj1 , xj , xj+1 , . . . , xnf ) 
f (x1 , . . . , xj1 , yj , xj+1 , . . . , xnf )
and
f (>, , . . . , ), f (, >, , . . . , ), . . . , f (, . . . , , >),
for all function symbols f and all j with 1  j  nf (Jonsson & Tarski, 1951; Jonsson &
Tarski, 1952; Goldblatt, 1989). This definition of normal modal logics assumes that the
formulas (terms) are built using only necessity (box) operators.7 We will work here only
with necessity operators; the corresponding possibility-operators are definable by putting
f 3 (x1 , . . . , xnf ) = f (x1 , . . . , xnf ).
The minimal normal modal logic in the language with one unary operator is known as K
(Chellas, 1980).
We call a function F : W n  W normal iff for all 1  j  n and X1 , . . . , Xn , Yj  W
F (X1 , . . . , Xj1 , Xj  Yj , Xj+1 , . . . , Xn ) = F (X1 , . . . , Xj1 , Xj , Xj+1 , . . . , Xn ) 
F (X1 , . . . , Xj1 , Yj , Xj+1 , . . . , Xn ))
and
F (W, , . . . , ) = F (, W, , . . . , ) =    = F (, . . . , , W ) = W.
Note that a unary function F is normal iff F (W ) = W and F (X  Y ) = F (X)  F (Y ), for
any X, Y  W . A function symbol f is called normal in an ADS (L, M) iff the functions
f W are normal for all W  M.
For any role R of some DL, the function symbol fR is normal in the corresponding
ADS. To the contrary, it is readily checked that neither fnR
and fnR
nor their duals


3
3
fnR
and
f
are
normal.


nR
Obviously, an ADS (L, M) determines a normal modal logic iff all function symbols of
L are normal in (L, M). Completeness of K with respect to Kripke semantics (Chellas,
1980) implies that the logic K is determined by the ADS with one unary operator whose
class of ADMs consists of all models interpreting this operator by a normal function.
7. Note that some authors define normal modal logics using possibility (diamond) operators, in which case
the definitions are the duals of what we have introduced and thus at first sight look quite different.

19

fiBaader, Lutz, Sturm, & Wolter

4. Fusions of abstract description systems
In this section, we define the fusion of abstract description systems and prove two transfer theorems for decidability, one concerning satisfiability and the other one concerning
relativized satisfiability.
Definition 16. The fusion S1  S2 = (L1  L2 , M1  M2 ) of two abstract description
systems S1 = (L1 , M1 ) and S2 = (L2 , M2 ) over
 disjoint sets of function symbols F of L1 and G of L2 ,
 disjoint sets of relation symbols R of L1 and Q of L2 , and
 the same sets of set and object variables
is defined as follows: L1  L2 is the ADL based on
 the union F  G of the function symbols of L1 and L2 , and
 the union R  Q of the relation symbols of L1 and L2 ,
and M1  M2 is defined as
E
E
D
E D
D
{ W, F W  G W , RW  QW | W, F W , RW  M1 and W, G W , QW  M2 }.
As an example, consider the ADSs S1 and S2 corresponding to the DLs ALCF and
ALC +,,t introduced in Section 2. We concentrate on the function symbols provided by
their fusion. In the following, we assume that the set of role names employed by ALCF
and ALC +,,t are disjoint.
 The ADS S1 is based on the following function symbols: (i) unary functions symbol
fR and fR for every role name R of ALCF, (ii) nullary functions symbols corresponding to the same-as constructor for every pair of chains of functional roles of
ALCF.
 The ADS S2 is based on the following function symbols: (iii) unary functions symbol
fQ and fQ for every role description Q built from role names of ALC +,,t using
union, composition, and transitive closure.
Since we assumed that the set of role names employed by ALCF and ALC +,,t are disjoint,
these sets of function symbols are also disjoint. The union of these sets provides us both
with the symbols for the same-as constructor and with the symbols for value and existential restrictions on role descriptions involving union, composition, and transitive closure.
However, the role descriptions contain only role names from ALC +,,t , and thus none of
the functional roles of ALCF occurs in such descriptions. Thus, the fusion of ALCF and
ALC +,,t yields a strict fragment of their union ALCF +,,t .
4.1 Relativized satisfiability
We prove a transfer result for decidability of the relativized satisfiability problem, show that
this also yields a corresponding transfer result for the relativized term satisfiability problem,
and investigate how these transfer results can be extended to ADSs that correspond to DLs
providing for the universal role.
20

fiFusions of Description Logics and Abstract Description Systems

4.1.1 The transfer result
This section is concerned with establishing the following transfer theorem:
Theorem 17. Let S1 and S2 be local ADSs, and suppose that the relativized satisfiability
problems for S1 and S2 are decidable. Then the relativized satisfiability problem for S1  S2
is also decidable.
The idea underlying the proof of this theorem is to translate a given set of assertions 
of S1  S2 into a set of assertions 1 of S1 and a set of assertions 2 of S2 such that  is
satisfiable in S1  S2 iff 1 is satisfiable in S1 and 2 is satisfiable in S2 . The first (naive)
idea for how to obtain the set i (i = 1, 2) is to replace in  alien terms (i.e., subterms
starting with function symbols not belonging to Si ) by new set variables (the surrogate
variables introduced below). With this approach, satisfiability of  would in fact imply
satisfiability of the sets i , but the converse would not be true. The difficulty arises when
trying to combine the models of 1 and 2 into one for . To ensure that the two models
can indeed be combined, the sets i must contain additional assertions that make sure that
the surrogate variables in one model and the corresponding alien subterms in the other
model are interpreted in a compatible way. To be more precise, there are (finitely many)
different ways of adding such assertions, and one must try which of them (if any) leads to
a satisfiable pair 1 and 2 .
For the proof of Theorem 17, we fix two local ADSs Si = (Li , Mi ), i  {1, 2}, in which
L1 is based on the set of function symbols F and relation symbols R, and L2 is based on G
and Q. Let L = L1  L2 and M = M1  M2 .
In what follows, we use the following notation: for a set of assertions , denote by
term() and obj() the set of terms and object names in , respectively.
We start with explaining how alien subterms in the set  can be replaced by new set
variables. For each L-term t of the form h(t1 , . . . , tn ), h  F  G, we reserve a new variable
xt , which will be called the surrogate of t. We assume that the set of surrogate variables
is disjoint to the original sets of variables. As sketched above, the idea underlying the
introduction of surrogate variables is that the decision procedure for S1 (S2 ) cannot deal
with terms containing function symbols from G (F). Thus, these alien function symbols
must be replaced before applying the procedure. To be more precise, we replace the whole
alien subterm starting with the alien function symbol by its surrogate. For example, if the
unary symbol f belongs to F, and the unary symbol g belongs to G, then f (g(f (x))) is a
mixed L-term. To obtain a term of L1 , we replace the subterm g(f (x)) by its surrogate,
which yields f (xg(f (x)) ). Analogously, to obtain a term of L2 , we replace the whole term
by its surrogate, which yields xf (g(f (x))) . We now define this replacement process more
formally.
Definition 18. For an L-term t without surrogate variables, denote by sur1 (t) the L1 -term
resulting from t when all occurrences of terms g(t1 , . . . , tn ), g  G, that are not within the
scope of some g 0  G are replaced by their surrogate variable xg(t1 ,...,tn ) . For a set  of
terms, put sur1 () := {sur1 (t) | t  } and define sur2 (t) as well as sur2 () accordingly.
Denote by sub() the set of subterms of terms in , and by sub1 () the variables
occurring in  as well as the subterms of alien terms (i.e., terms starting with a symbol
21

fiBaader, Lutz, Sturm, & Wolter

from G) in . More formally, we can define
sub1 () := sub{t | xt  var(sur1 ())}  var().
Define sub2 () accordingly.
For example, let f  F be unary and g  G be binary. If t = f (g(x, f (g(x, y)))), then
sur1 (t) = f (xg(x,f (g(x,y))) ). Note that the restriction not within the scope of some g 0  G
is there to clarify that only the top-most alien subterms are to be replaced. For the term t
of this example, we have sub1 ({t}) = {g(x, f (g(x, y))), f (g(x, y)), g(x, y), x, y}.
Note that the Boolean operators occurring in terms are shared function symbols in
the sense that they are alien to neither L1 nor L2 . Thus, sur1 (f (x)g(x, y)) = f (x)xg(x,y)
and sur2 (f (x)  g(x, y)) = xf (x)  g(x, y).
Of course, when replacing whole terms by variables, some information is lost. For
example, consider the (inconsistent) assertion (R1 .((1 R2 )u(2 R2 )))(i) and assume that
R1 is a role of one component of a fusion, and R2 a role of the other component. Translated
into abstract description language syntax, the concept description R1 .((1 R2 ) u (2 R2 ))
yields the term t := fR1 (f(1 R2 )  f(2 R2 ) ), where fR1 is a function symbol of L1 and
the other two function symbols belong to L2 . Now, sur1 (t) = fR1 (x  y), where x is the
surrogate for f(1 R2 ) and y is the surrogate for f(2 R2 ) . If the decision procedure for the
first ADS only sees fR1 (x  y), it has no way to know that the conjunction of the alien
subterms corresponding to x and y is unsatisfiable. In fact, for this procedure x and y are
arbitrary set variables, and thus x  y is satisfiable. To avoid this problem, we introduce
so-called consistency set consisting of types, where a type says for each relevant formula
whether the formula itself or its negation is supposed to hold. The sets 1 and 2 will then
contain additional information that basically ensures that their models satisfy the same
types. This will allow us to merge these models into one for .
Definition 19. Given a finite set  of L-terms, we define the consistency set C() of  as
C() := {tc | c  }, where the type tc determined by c   is defined as
tc :=

^

{ |   c} 

^

{ |    \ c}.

Given a finite set  of assertions in L, we define subi () := subi (term()). We abbreviate
C i () := C(subi ()), for i  {1, 2}.
In the example above, we have
sub1 (fR1 (f(1 R2 )  f(2 R2 ) ) = {f(1 R2 ) , f(2 R2 ) },
and thus C 1 ({ai : fR1 (f(1 R2 )  f(2 R2 ) )}) consists of the 4 terms
f(1 R2 )
f(1 R2 )
f(1 R2 )
f(1 R2 )






f(2 R2 ) ,
f(2 R2 ) ,
f(2 R2 ) , and
f(2 R2 ) .
22

fiFusions of Description Logics and Abstract Description Systems

Given a set of terms , an element tc of its consistency set C() can indeed be considered
as the type of an element e of the domain of an ADM w.r.t. . Any such element e
belongs to the interpretations of some of the terms in , and to the complements of the
interpretations of the other terms. Thus, if c is the set of terms of  to which e belongs,
then e also belongs to the interpretation of tc and it does not belong to the interpretation
of any of the other terms in C(). In this case we say that e realizes the type tc .
We are now ready to formulate the theorem that reduces the relativized satisfiability
problem in a fusion of two local ADSs to relativized satisfiability in the component ADSs.
A proof of this theorem can be found in the appendix.
Theorem 20. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs in which L1 is based on
the set of function symbols F and relation symbols R, and L2 is based on G and Q, and
let L = L1  L2 and M = M1  M2 . If  is a finite set of assertions from L, then the
following are equivalent:
1.  is satisfiable in (L, M).
2. There exist
(a) a set D  C 1 (),
(b) for every term t  D an object variable at 6 obj(),
(c) for every a  obj() a term ta  D,
such that the union 1 of the following sets of assertions in L1 is satisfiable in
(L1 , M1 ):
W
(d) {at : sur1 (t) | t  D}  {> v sur1 ( D)},
(e) {a : sur1 (ta ) | a  obj()},

(f ) {R(a, b) | R(a, b)  , R  R},
(g) {sur1 (t1 ) v sur1 (t2 ) | t1 v t2  }  {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of assertions in L2 is satisfiable in (L2 , M2 ):
W
(h) {at : sur2 (t) | t  D}  {> v sur2 ( D)},
(i) {a : sur2 (ta ) | a  obj()},

(j) {Q(a, b) | Q(a, b)  , Q  Q}.
Intuitively, (2a) guesses a set D of types (i.e., elements of the consistency set). The
idea is that these are exactly the types that are realized in the model of  (to be constructed
when showing (2  1) and given when showing (1  2)). Condition (2b) introduces for
every type in D a name for an object realizing this type, and (2c) guesses for every object
variable occurring in  a type from D.
W Regarding (2d) and (2h), one should note that the set of assertions {at : t | t  D}{> v
D} states that every type in D is realized (i.e., there is an object in the model having
this type) and that every object has one of the types in D. The sets of assertions (2d) and
(2h) are obtained from this set through surrogation to make it digestible by the decision
procedures of the component logics.
23

fiBaader, Lutz, Sturm, & Wolter

The assertions in (2e) and (2i) state (again in surrogated versions) that the object
interpreting the variable a has type ta . This ensures that, in the models of 1 and 2
(given when showing (2  1)), the objects interpreting a have the same type ta from D.
Otherwise, these models could not be combined into a common one for .
The sets (2f) and (2j) are obtained from  by distributing its relationship assertions
between 1 and 2 , depending on the relation symbol used in the assertion.
The set (2g) contains (in surrogated version) the term assertions of the form t1 v t2 and
the membership assertions of the form a : s of .
Condition 2 is asymmetric in two respects. First, it guesses a subset of C 1 () rather than
a subset of C 2 (). Of course this is arbitrary, we could also have chosen index 2 instead
of 1 here. Second, the set 2 neither contains the assertions {sur2 (t1 ) v sur2 (t2 ) | t1 v
t2  } nor {a : sur2 (s) | (a : s)  }. If we added these assertions, the theorem would
still be true, but this would unnecessarily increase the amount of work to be done by the
combined decision procedure. In fact, since the other assertions in 1 and 2 enforce a tight
coordination between the models of 1 and 2 , the fact that the membership assertions and
term assertions of  are satisfied in the models of 1 implies that they are also satisfied in
the models of 2 (see the appendix for details).
To prove Theorem 17, we must show how Theorem 20 can be used to construct a
decision procedure for relativized satisfiability in S1  S2 from such decision procedures for
the component systems S1 and S2 . For a given finite set of assertions  of S1  S2 , the set
C 1 () is also finite, and thus there are finitely many sets D in (2a) and choices of types for
object variables in (2c). Consequently, we can enumerate all of them and check whether
one of these choices leads to satisfiable sets 1 and 2 . By definition of the sets i and of
the functions suri , the assertions in i are indeed assertions of Li , and thus the satisfiability
algorithm for (Li , Mi ) can be applied to i . This proves Theorem 17.
Regarding the complexity of the obtained decision procedure, the costly step is guessing
the right set D. Since the cardinality of the set sub1 () is linear in the size of , the
cardinality of C 1 () is exponential in the size of  (and each element of it has size quadratic
in ). Thus, there are doubly exponentially many different subsets to be chosen from. Since
the cardinality of the chosen set D may be exponential in the size of , also the size of 1
and 2 may be exponential in  (because of the big disjunction over D). From this, the
following corollary follows.
Corollary 21. Let S1 and S2 be local ADSs, and suppose that the relativized satisfiability
problems for S1 and S2 are decidable in ExpTime (PSpace). Then the relativized satisfiability problem for S1  S2 is decidable in 2ExpTime (ExpSpace).
p (n)

Proof. Assume that  has size n. Then we must consider 22 1 (for some polynomial p1 )
p (n)
different sets D in (2a). Each such set has size 2p1 (n) and thus we have of 22 2 choices
in (2c) (for some polynomial p2 ). Overall, this still leaves us with doubly exponentially
many choices. Now assume that the relativized satisfiability problems for S1 and S2 are
decidable in ExpTime. Since each call of these procedures is applied to a set of assertions of
p (n)
p (n)
exponential size, it may take double exponential time, say 22 3 and 22 4 (for polynomials
p3 and p4 ). Overall, we thus have a time complexity of
22

p1 (n)

 22

p2 (n)

 (22
24

p3 (n)

+ 22

p4 (n)

),

fiFusions of Description Logics and Abstract Description Systems

p(n)

which can clearly be majorized by 22
for an appropriate polynomial p. This shows
membership in 2ExpTime.
The argument regarding the space complexity is similar. Here one must additionally
take into account that doubly exponentially many choices can be enumerated using an
exponentially large counter.

4.1.2 The relativized term satisfiability problem
The statement of Theorem 17 itself does not imply a transfer result for the relativized term
satisfiability problem. The problem is that decidability of the relativized term satisfiability
problem in S1 and S2 does not necessarily imply decidability of the relativized satisfiability
problem in these ADSs, and thus the prerequisite for the theorem to apply is not satisfied.
However, if we consider the statement of Theorem 20, then it is easy to see that this theorem
also yields a transfer result for the relativized term satisfiability problem.
Corollary 22. Let S1 and S2 be local ADSs, and suppose that the relativized term satisfiability problems for S1 and S2 are decidable. Then the relativized term satisfiability problem
for S1  S2 is also decidable.
Proof. Consider the satisfiability criterion in Theorem 20. If we are interested in relativized term satisfiability, then  is of the form {a : t}  0 , where 0 is a set of term
assertions. In this case, the sets of assertions 1 and 2 do not contain object assertions
involving relations. Now, assume that i is of the form {a1 : t1 , . . . , an : tn }  0i , where 0i
is a set of term assertions. Since two assertions of the form b : s1 , b : s2 are equivalent to
one assertion b : s1  s2 , we may assume that the ai are distinct from each other. Since Si
is local, it is easy to see that the following are equivalent:
1. {a1 : t1 , . . . , an : tn }  0i is satisfiable in Si .
2. {aj : tj }  0i is satisfiable in Si for all j = 1, . . . , n.
Since (1  2) is trivial, it is enough to show (2  1). Given models Wj  Mi of {aj :
tj }  0i (j = 1, . . . , n), their disjoint union also belongs to Mi , and it is clearly a model of
{a1 : t1 , . . . , an : tn }  0i .
The second condition can now be checked by applying the term satisfiability test in Si
n times.

4.1.3 Dealing with the universal role
As stated above (Proposition 15), ADSs corresponding to DLs with the universal role are
not local, and thus Theorem 17 cannot be applied directly. Nevertheless, in some cases
this theorem can also be used to obtain a decidability result for fusions of DLs with the
universal role, provided that both of them provide for a universal role. (We will comment
on the usefulness of this approach in more detail in Section 5.4).
Definition 23. Given an ADS S = (L, M), we denote by S U the ADS obtained from S by
1. extending L with two function symbols fUS and fUS , and
25

fiBaader, Lutz, Sturm, & Wolter



ff
W and
2. extending every ADM W = W, F W , RW  M with the unary functions fU
S
W , where
fU
S
W (X) =  if X = , and f W (X) = W otherwise;
 fU
US
S
W (X) = W if X = W , and f W (X) =  otherwise.
 fU
US
S

For ADSs S corresponding to a DL L, the ADS S U corresponds to the extension of L
with the universal role, where the universal role can only be used within value and existential
restrictions.8 There is a close connection between the relativized satisfiability problem in S
and the satisfiability problem in S U .
Proposition 24. If S is a local ADS, then the following conditions are equivalent:
1. the relativized (term) satisfiability problem for S is decidable,
2. the (term) satisfiability problem for S U is decidable,
3. the relativized (term) satisfiability problem for S U is decidable.

Proof. We restrict our attention to the term satisfiability problem since the equivalences
for the satisfiability problem can be proved similarly.
The implication (3  2) is trivial, and (2  1) is easy to show. In fact, t is satisfiable in
S relative to the term assertions {s1 v t1 , . . . , sn v tn } iff tfUS .((t1 s1 ). . .(tn sn ))
is satisfiable in S U .
To show (1  3), we assume that the relativized term satisfiability problem for S is
decidable. Let S = (L, M) and S U = (LU , MU ). In the following, we use fU as an
abbreviation for fUS . Since we can replace equivalently in any term the function symbol
fUS by fU , we may assume without loss of generality that fUS does not occur in terms
of LU .
Suppose a set  = {a : s}   from LU is given, where  is a set of term assertions. We
want to decide whether  is satisfiable in some model W  MU . To this purpose, we transform  into a set of assertions not containing fU . The idea underlying this transformation
is that, given a model W  MU , we have fU (t)W  {W, }, depending on whether tW = W
or not. Consequently, if we replace fU (t) accordingly by > or , the evaluation of this term
in W does not change. However, in the satisfiability test we do not have the model W (we
are trying to decide whether one exists), and thus we must guess the right replacement.
A term t from LU is called a U -term iff it starts with fU . The set of U -terms that
occur (possibly as subterms) in  is denoted by U . Set, inductively, for any function
8. Note that it is not necessary to add the universal role U to the set of relation symbols since an assertion
of the form U (a, b) is trivially true. However, the use of the universal role within (qualified) number
restrictions is not covered by this extension.

26

fiFusions of Description Logics and Abstract Description Systems

 : U  {, >} and all subterms of terms in :
x := x,
(t1  t2 ) := t1  t2 ,
(t1  t2 ) := t1  t2 ,
(t) := t ,
(f (t1 , . . . , tn )) := f (t1 , . . . , tn ) for f 6= fU of arity n,
(fU (t)) := (fU (t)).
Thus, t is obtained from t by replacing all occurrences of U -terms in t by their image under
, i.e., by  or >. Define, for any such function ,
 := {t1 v t2 | t1 v t2  }  {a : s } 
{> v t | fU (t)  U and (fU (t)) = >} 
{at : t | fU (t)  U and (fU (t)) = },
where the at are mutually distinct new object variables. Note that  does not contain the
function symbol fU , and thus it can be viewed as a set of assertions of S. In addition, though
it contains more than one membership assertion, it does not contain assertions involving
relation symbols. Consequently, the satisfiability of  in S can be checked using the term
satisfiability test for S (see the proof of Corollary 22 above). Decidability of the relativized
term satisfiability problem for S U then follows from the following claim:
Claim.  is satisfiable in a member of MU iff there exists a mapping  : U  {, >}
such that  is satisfiable in a member of M.
To 
prove this claim, firstff suppose that  is satisfied under an assignment A in a member
W = W, F W  {fUW }, RW of MU . Define  by setting (fU (t)) = > if (fU (t))W,A =
W , and (fU (t))
 =  otherwise.
Obviously, this implies that  is satisfied under the
ff
W
W
assignment A in W, F , R , which is a member of M.
suppose  is satisfiable for some mapping . Take a member W =

 Conversely,
ff
W
W

0
ffand an assignment A such such that hW, Ai |=  . Set W :=

W, F W , R W of M
W
W, F  {fU }, R , and prove, by induction, for all terms t that occur in :
()

0

tW ,A = (t )W,A .

The only critical case is the one where t = fU (s). First, assume that (fU (s)) = (fU (s)) =
0
>. Then  contains > v s , and thus W = (s )W,A = sW ,A , where the second identity
0
0
holds by induction. However, sW ,A = W implies (fU (s))W ,A = W = >W,A . The case where
(fU (s)) = (fU (s)) =  can be treated similarly. Here the term assertion as : s ensures
that s (and thus by induction s) is not interpreted as the whole domain. Consequently,
applying fU to it yields the empty set.
Since hW, Ai |=  , the identity () implies that hW0 , Ai |= . This completes the proof
of the claim, and thus also of the proposition.

For normal modal logics, the result stated in this proposition was already shown by
Goranko and Passy (1992). The proof technique used there can, however, not be transfered
27

fiBaader, Lutz, Sturm, & Wolter

to our more general situation since it strongly depends on the normality of the modal
operators.
Using Proposition 24, we obtain the following corollary to our first transfer theorem.
Corollary 25. Let S1 , S2 be local ADSs and assume that, for i  {1, 2}, the relativized
(term) satisfiability problem for Si is decidable. Then the relativized (term) satisfiability
problem for S1U  S2U is decidable.
Proof. We know by Theorem 17 (Corollary 22) that the relativized (term) satisfiability
problem for S1  S2 is decidable. Hence, Proposition 24 yields that the relativized (term)
satisfiability problem for (S1  S2 )U is decidable. But S1U  S2U is just a notational variant
of (S1  S2 )U : the function symbols fUS1 and fUS2 can be replaced by fUS1 S2 (and
analogously for fUS1 S2 ) since all three have identical semantics.

4.2 Satisfiability
Note that Theorem 17 does not yield a transfer result for the unrelativized satisfiability
problem. Of course, if the relativized satisfiability problems for S1 and S2 are decidable,
then the theorem implies that the satisfiability problem for S1  S2 is also decidable (since
it is a special case of the relativized satisfiability problem). However, to be able to apply
the theorem to obtain decidability of the satisfiability problem in the fusion, the component
ADSs must satisfy the stronger requirement that the relativized satisfiability problemWis decidable. Indeed, the set i in Theorem 20 contains a term assertion (namely > v suri ( D))
even if  does not contain any term assertions.
There are cases where the relativized satisfiability problem is undecidable whereas the
satisfiability problem is still decidable. For example, Theorem 17 cannot be applied for
the fusion of ALCF and ALC +,,t since the relativized satisfiability problem for ALCF is
already undecidable (Baader et al., 1993). However, the satisfiability problem is decidable
for both DLs.
4.2.1 Covering normal terms
Before we can formulate a transfer result for the satisfiability problem, we need to introduce
an additional notion, which generalizes the notion of a normal modal logic.
Definition 26 (Covering normal terms). Let (L, M) be an ADS and f be a function
symbol of L of arity n. The term tf (x) (with one variable x) is a covering normal term for
f iff the following holds for all W  M:
 tW
f (W ) = W
W
W
 for all X, Y  W , tW
f (X  Y ) = tf (X)  tf (Y ), and

 for all X, X1 , . . . , Yn  W : X  Xi = X  Yi for 1  i  n implies
W
W
W
tW
f (X)  f (X1 , . . . , Xn ) = tf (X)  f (Y1 , . . . , Yn ).

An ADS (L, M) is said to have covering normal terms iff one can effectively determine a
covering normal term tf for every function symbol f of L.
28

fiFusions of Description Logics and Abstract Description Systems

Intuitively, the first two conditions state that the covering normal term behaves like a
value restriction (or box operator). Consider the term fR (x), where fR is the function
symbol corresponding to the value restriction constructor for the role R. Then fR (x)
obviously satisfies the first two requirements for covering normal terms. Note that the
second condition implies that the function induced by tf is monotonic, i.e., X  Y implies
W
tW
f (X)  tf (Y ). The third condition specifies the connection between the covering normal
term and the function symbol it covers. With respect to elements of tW
f (X), the values
W
W
of the functions f (X1 , . . . , Xn ) and f (Y1 , . . . , Yn ) agree provided that their arguments
agree on X. It is easy to see that fR (x) is a covering normal term for the function symbols
corresponding to the value, existential, and (qualified) number restrictions on the role R
(see Proposition 35 below).
Given covering normal terms tf for the function symbols f of a finite set of function
symbols E, one can construct a term tE that is a covering normal term for all the elements
of E.
Lemma 27. Suppose the ADS (L, M) has covering normal terms and L is based on a set
of function symbols F . Denote by tf the covering normal term for the function symbol f ,
for all f  F . Then, for every finite set E  F of function symbols, the term
tE (x) :=

^

tf (x)

f E

is a covering normal term for all f  E.
4.2.2 Correspondence to normal modal logics
The following result shows that any ADS in which every function symbol is normal has
covering normal terms. Hence, the notion of covering normal terms generalizes the notion
of normality in modal logics.
Proposition 28. Let (L, M) be an ADS, and assume that f is a normal function symbol
in (L, M). Then
tf (x) := f (x, , . . . , )  f (, x, . . . , )      f (, . . . , , x)
is a covering normal term for f . In particular, if f is nullary (unary), then tf (x) = >
(tf (x) = f (x)) is a covering normal term for f .
Proof. The first two conditions in the definition of covering normal terms immediately
follow from the definition of normal function symbols. Thus, we concentrate on the third
condition. Assume, for simplicity, that f is binary. Suppose W  M and X, X1 , X2 , Y1 , Y2 
W with X  Xi = X  Yi for i = 1, 2, and set F := f W . Then F (X  X1 , X  X2 ) =
F (X  Y1 , X  Y2 ). Since F is normal, we know that
F (X  X1 , X  X2 ) = F (X, X)  F (X, X2 )  F (X1 , X)  F (X1 , X2 ),
F (X  Y1 , X  Y2 ) = F (X, X)  F (X, Y2 )  F (Y1 , X)  F (Y1 , Y2 ),
29

fiBaader, Lutz, Sturm, & Wolter

and thus
F (X, X)  F (X, X2 )  F (X1 , X)  F (X1 , X2 ) =
F (X, X)  F (X, Y2 )  F (Y1 , X)  F (Y1 , Y2 ).
Since, by normality of F ,
F (X, X)  F (X, X2 )  F (X1 , X)  tW
f (X),
F (X, X)  F (X, Y2 )  F (Y1 , X)  tW
f (X),
W
this implies tW
f (X)  F (X1 , X2 ) = tf (X)  F (Y1 , Y2 ).



4.2.3 The transfer result
Using covering normal terms, we can now formulate the second transfer theorem, which is
concerned with the transfer of decidability of (non-relativized) satisfiability.
Theorem 29. Let S1 and S2 be local ADSs having covering normal terms, and suppose
that the satisfiability problems for S1 and S2 are decidable. Then the satisfiability problem
for S1  S2 is also decidable.
As in the proof of Theorem 17, we fix two local ADSs Si = (Li , Mi ), i  {1, 2}, in which
L1 is based on the set of function symbols F and relation symbols R, and L2 is based on G
and Q. Let L = L1  L2 and M = M1  M2 .
The proof of Theorem 29 follows the same general ideas as the proof of Theorem 17.
There are, however, notable differences in the way satisfiability in S1  S2 is reduced to
satisfiability in S1 and S2 . In Theorem 20 we had to guess a set D of types, and then
based on this set and some additional guesses, a pair of satisfiability problems 1 and 2 in
S1 and S2 , respectively, was generated. In the proof of Theorem 29, we do not need to guess
D. Instead, we can compute the right set. However, this computation requires us to solve
additional satisfiability problems in the fusion S1  S2 . Nevertheless, this yields a reduction
since the alternation depth (i.e., number of alternations between function symbols of S1
and S2 ) decreases when going from the input set  to these additional mixed satisfiability
problems.
Before we can describe this reduction in more detail, we must introduce someWnew
notation. In the case of relativized satisfiability, term assertions of the W
form > v suri ( D)
were used to assert that all elements of theW domain belong to suri ( D). Now, we use
covering normal terms to propagate suri ( D) into terms up to a certain depth. For a
set of function symbols E, define the E-depth dE (t) of a term t inductively:
dE (xi ) = 0
dE (t) = dE (t)
dE (t1  t2 ) = dE (t1  t2 ) = max{dE (t1 ), dE (t2 )}
dE (f (t1 , . . . , tn )) = max{dE (t1 ), . . . , dE (tn )} + 1 if f  E
dE (f (t1 , . . . , tn )) = max{dE (t1 ), . . . , dE (tn )} if f 6 E
30

fiFusions of Description Logics and Abstract Description Systems

If  is a finite set of assertions, then
dE () := max{dE (t) | t  term()}.
Put, for a term t(x) with one variable x, t0 (x) := x, tm+1 (x) := t(tm (x)), t0 (x) := x, and
tm+1 (x) := tm+1 (x)  tm (x).
We are now in the position to formulate the result that reduces satisfiability in the fusion
of two local ADSs with covering normal terms to satisfiability in the component ADSs.
Theorem 30. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs having covering normal
terms in which L1 is based on the set of function symbols F and relation symbols R, and
L2 is based on G and Q, and let L = L1  L2 and M = M1  M2 . Let  be a finite set
of object assertions from L. Put m := dF (), r := dG (), and let c(x) (d(x)) be a covering
normal term for all function symbols in  that are in F (G).
For i  {1, 2}, denote by i the set of all s  C i () such that the term s is satisfiable in
(L, M). Then the following three conditions are equivalent:
1.  is satisfiable in (L, M).
2. There exist
 for every t  1 an object variable at 6 obj()
 for every a  obj() a term ta  1
such that the union 1 of the following sets of object assertions is satisfiable in
(L1 , M1 ):
W
 {at : sur1 (t  cm (sur1 ( 1 )) | t  1 },
W
 {a : sur1 (ta  cm (sur1 ( 1 )) | a  obj()},
 {R(a, b) | R(a, b)  , R  R},
 {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of object assertions is satisfiable in (L2 , M2 ):
W
 {at : sur2 (t  dr (sur2 ( 1 )) | t  1 },
W
 {a : sur2 (ta  dr (sur2 ( 1 )) | a  obj()},
 {Q(a, b) | Q(a, b)  , Q  Q}.

3. The same condition as in (2) above, with 1 replaced by 2 .
The sets i in the above theorem are very similarWto the ones in Theorem 20. The
main difference is that
W the term assertion > v suri ( D) is no longer there. Instead,
the disjunction suri ( 1 ) is directly inserted into the terms using the covering normals
terms. As already mentioned above, another difference is that the set D, which had to be
guessed in Theorem 20, is replaced by the set 1 in (2) and 2 in (3). Actually, guessing the
set D is no
W longer possible in this case. In the proof of Theorem 30 we need to know that
> v suri ( D) is satisfiable in Si (i.e., holds in at least one model in Mi ). But we have no
way to check this effectively since we do not have an algorithm for relativized satisfiability
31

fiBaader, Lutz, Sturm, & Wolter

in Si . Taking the set i ensures that this property is satisfied (see the proof in the appendix
for details).
By definition, i is the set of all s  C i () such that the term s is satisfiable in (L, M).
Recall that the term s is satisfiable iff {a : s} is satisfiable in (L, M) for an arbitrary
object variable a. Since the elements of C i () are still mixed terms (i.e., terms of the
fusion), computing the set i actually needs a recursive call to the decision procedure for
satisfiability in (L, M). This recursion is well-founded since the alternation depth decreases.
Definition 31. For a term s of L, denote by a1 (s) and a2 (s) the 1-alternation and the
2-alternation depth of s, respectively. That is to say, a1 (s) is the length of the longest
sequence of the form (g1 , f2 , g3 , . . .) such that
g1 (. . . (f2 . . . (g3 . . .)))
with gj  G and fj  F appears in s. The 2-alternation depth a2 (s) is defined by exchanging
the roles of F and G. Put a(s) := a1 (s) + a2 (s), and call this the alternation depth. For a
finite set  of terms, a() is the maximum of all a(s) with s  .
Thus, a1 (s) counts the maximal number of changes between symbols from the first and
the second ADS, starting with the first symbol from S2 (i.e., the first symbol from S2
counts as a change, even if it does not occur inside the scope of a symbol from S2 ). The
2-alternation depth is defined accordingly. The alternation depth sums up the 1- and the
2-alternation depth.
Lemma 32. If a(term()) > 0, then a(C 1 ()) < a(term()) or a(C 2 ()) < a(term()).
Proof. We show that, if a(term()) > 0, then we have a(sub1 ()) < a(term()) or
a(sub2 ()) < a(term()), which, by definition of C i , clearly implies the lemma. First
note that, by definition of subi , we have
ai (subj ())  ai (term()) for all i, j.

()

We now make a case distinction as follows:
1. a1 (term())  a2 (term()). We want to show that a1 (sub2 ()) < a1 (term()),
since, by (), this implies a(sub2 ()) < a(term()). Assume to the contrary that
a1 (sub2 ())  a1 (term()). Then () implies a1 (sub2 ()) = a1 (term()). Hence,
there exists a term s  sub2 () and a sequence (g1 , f2 , g3 , . . . ) of function symbols
gi  G, fi  F of length a1 (term()) such that g1 (. . . (f2 . . . (g3 . . .))) occurs in s. By
definition of sub2 , this implies the existence of a term t  term() and a function
symbol f  F such that f (. . . g1 (. . . (f2 . . . (g3 . . .)))) occurs in t. Since the length of
(g1 , f2 , g3 , . . . ) is a1 (term()), this obviously yields a2 (term()) > a1 (term()) which
is a contradiction.
2. a1 (term())  a2 (term()). Similar to the previous case: just exchange the roles of
a1 and a2 , F and G, and sub1 and sub2 .

32

fiFusions of Description Logics and Abstract Description Systems

To prove Theorem 29, we must show how Theorem 30 can be used to construct a decision
procedure for satisfiability in S1  S2 from such decision procedures for the component
systems S1 and S2 . Let us first consider the problem of computing the sets 1 and 2 .
If a((term()) = 0, then  consists of Boolean combinations of set variables. In this
case, C i () consists of set variables, and i , i = 1, 2, can be computed using Boolean
reasoning. If a(term()) > 0, then Lemma 32 states that there is an i  {1, 2} such
that a(C i ()) < a(term()). By induction we can thus assume that i can effectively be
computed. Consequently, it remains to check Condition (i + 1) of Theorem 30 for i  {1, 2}.
Since i is finite, we can guess for every object variable a occurring in  a type ta in i . The
sets 1 and 2 obtained this way are indeed sets of assertions of L1 and L2 , respectively.
Thus, their satisfiability can effectively be checked using the decision procedures for S1 and
S2 . This proves Theorem 29.
The argument used above also shows why in Theorem 30 it was not sufficient to state
equivalence of (1) and (2) (as in Theorem 20). In fact, the induction argument used above
does not necessarily always apply to the computation of 1 . In some cases, the alternation
depth may not decreases for 1 , but only for 2 . It should be noted that Theorem 20 could
also have been formulated in this symmetric way. We have not done this since it was not
necessary for proving Theorem 17.
Regarding the complexity of the combined decision procedure, we must in principle also
consider the complexity of computing covering normal terms and the size of these terms.
In the examples from DL, these terms are just value restrictions, and thus their size and
the complexity of computing them is linear. Here, we assume a polynomial bound on both.
Under this assumption, we obtain the same complexity results as for the case of relativized
satisfiability. In fact, the complexity of testing Condition (2) and (3) of Theorem 30 agrees
with the complexity of testing Condition (2) of Theorem 20: it adds one exponential to the
complexity of the decision procedure for the single ADSs. In order to compute i , we need
exponentially many recursive calls to the procedure. Since the recursion depth is linear in
the size of , we end up with at most exponentially many tests of Condition (2) and (3).
Corollary 33. Let S1 and S2 be local ADSs having covering normal terms, and assume
that these covering normal terms can be computed in polynomial time. If the satisfiability
problems for S1 and S2 are decidable in ExpTime (PSpace), then the satisfiability problem
for S1  S2 is decidable in 2ExpTime (ExpSpace).
With the same argument as in the case of relativized satisfiability, we can extend the
transfer result also to term satisfiability.
Corollary 34. Let S1 and S2 be local ADSs having covering normal terms, and suppose
that the term satisfiability problems for S1 and S2 are decidable. Then the term satisfiability
problem for S1  S2 is also decidable.

5. Fusions of description logics
Given two DLs L1 and L2 , their fusion is defined as follows. We translate them into the
corresponding ADSs S1 and S2 , and then build the fusion S1  S2 . The fusion L1  L2
of L1 and L2 is the DL that corresponds to S1  S2 . Since the definition of the fusion of
ADSs requires their sets of function symbols to be disjoint, we must ensure that the ADSs
33

fiBaader, Lutz, Sturm, & Wolter

corresponding to L1 and L2 are built over disjoint sets of function symbols. For the DLs
introduced in Section 2, this can be achieved by assuming that the sets of role names of L1
and L2 are disjoint and the sets of nominals of L1 and L2 are disjoint. The DL L1  L2 then
allows the use of the concept and role constructors of both DLs, but in a restricted way.
Role descriptions are either role descriptions of L1 or of L2 . There are no role descriptions
involving constructors or names of both DLs. Concept descriptions may contain concept
constructors of both DLs; however, a constructor of Li may only use a role description of
Li (i = 1, 2).
Let us illustrate these restrictions by two simple examples. The fusion ALC +  ALC 1
of the two DLs ALC + and ALC 1 is the fragment of ALC +,1 whose set of role names is
partitioned into two sets NR1 and NR2 such that
 the transitive closure operator may only be applied to names from NR1 ;
 the inverse operator may only be applied to names from NR2 .
For example, if A is a concept name, R  NR1 and Q  NR2 , then R+ .A u Q1 .A is
a concept description of ALC +  ALC 1 , but R+ .A u R1 .A and (Q1 )+ .A are not.
Note that, although the two source DLs have disjoint sets of role names, in ALC +  ALC 1
role names from both sets may be used inside existential and value restrictions since these
concept constructors are available in both DLs.
The fusion ALCQ  ALC R+ of the two DLs ALCQ and ALC R+ is the fragment of
ALCQR+ whose set of role names NR (with transitive roles NR+  NR ) is partitioned into
two sets NR1 and NR2 with NR+  NR2 such that, inside qualifying number restrictions,
only role names from NR1 may be used. In particular, this means that transitive roles
cannot occur within qualified number restrictions.
In the following, we give examples that illustrate the usefulness of the transfer results
proved in the previous section. First, we will give an example for the case of satisfiability and
then for relativized satisfiability. Subsequently, we will consider a more complex example
involving so-called concrete domains. Here, our general transfer result can be used to prove
a decidability result that has only recently been proved by designing a specialized algorithm
for the fusion. Finally, we will give an example that demonstrates that the restriction to
local ADSs is really necessary.
5.1 Decidability transfer for satisfiability
In this subsection, we will give an example for an application of Theorem 29 where the
decidability result could not be obtained using Theorem 17.
Theorem 29 requires the ADSs to have covering normal terms. This is, however, satisfied
by all the DLs that yield local ADSs.
Proposition 35. Let L be one of the DLs introduced in Section 2, and let the corresponding
ADS S = (L, M) be local. Then S has covering normal terms, and these terms can be
computed in linear time.
Proof. For all function symbols f in L, the term tf has the form fR (x) for some role
description R. The semantics of value restrictions implies that terms of this form satisfy
34

fiFusions of Description Logics and Abstract Description Systems

the first two properties of Definition 26. This completes the proof for all function symbols
f of arity 0 since for these the third condition of Definition 26 is trivially satisfied. Thus,
for nullary function symbols, fR (x) for an arbitrary role name R does the job.
It remains to show that, for every unary function symbol f  {fR , fR , fnR
, fnR
},


the term fR (x) also satisfies the third property. This is an immediate consequence of the
W (X)  f W (Y ) = f W (X)  f W (X  Y )
fact that, for these function symbols f , we have fR
R
for all models W  M and X, Y  W .

In the following, we consider the two description logics ALCF and ALC +,,t . Hollunder
and Nutt (1990) show that satisfiability of ALCF-concept descriptions is decidable. The
same is true for consistency of ALCF-ABoxes (Lutz, 1999). Note, however, that relativized
satisfiability of ALCF-concept descriptions and thus also relativized ABox consistency in
ALCF is undecidable (Baader et al., 1993). For ALC +,,t , decidability of satisfiability is
shown by Baader (1991) and Schild (1991).9 Decidability of ABox consistency in ALC +,,t
is shown in Chapter 7 of (De Giacomo, 1995).
The unrestricted combination ALCF +,,t of the two DLs is undecidable. To be more precise, satisfiability of ALCF +,,t -concept descriptions (and thus also consistency of ALCF +,,t ABoxes) is undecidable. This follows from the undecidability of relativized satisfiability of
ALCF-concept descriptions and the fact that the role operators in ALCF +,,t can be used
to internalize TBoxes (Schild, 1991; Baader et al., 1993). In contrast to the undecidability
of ALCF +,,t , Theorem 29 immediately implies that satisfiability of concept descriptions
in the fusion of ALCF and ALC +,,t is decidable.
Theorem 36. Satisfiability of concept descriptions and consistency of ABoxes is decidable
in ALCF  ALC +,,t , whereas satisfiability of ALCF +,,t -concept descriptions is already
undecidable.
Taking the fusion thus yields a decidable combination of two DLs whose unrestricted
combination is undecidable. The price one has to pay is that the fusion offers less expressivity than the unrestricted combination. The concept f1 f2 u f1+ .C is an example of a
concept description of ALCF +,,t that is not allowed in the fusion ALCF  ALC +,,t .
5.2 Decidability transfer for relativized satisfiability
As an example for the application of Corollary 22 (and thus of Theorem 17), we consider the
DL ALC +,,u,t
. For this DL, satisfiability of concept descriptions is undecidable. However,
f
an expressive fragment with a decidable relativized satisfiability problem can be obtained
by building the fusion of the two sublanguages ALC +,,t
and ALC +,,t,u .
f
Theorem 37. Satisfiability of ALC +,,u,t
-concept descriptions is undecidable.
f
Undecidability can be shown by a reduction of the domino problem (Berger, 1966;
Knuth, 1973) (see, e.g., Baader & Sattler, 1999, for undecidability proofs of DLs using such
a reduction). The main tasks to solve in such a reduction is that one can express the 
grid and that one can access all points on the grid. One square of the grid can be expressed

N N

9. Note that ALC +,,t is a notational variant of test-free propositional dynamic logic (PDL) (Fischer &
Ladner, 1979).

35

fiBaader, Lutz, Sturm, & Wolter

by a description of the form (xyuyx).>, where x, y are features. In fact, this description
expresses that the points belonging to it have both an x  y and a y  x successor, and
that these two successors coincide. Accessing all point on the grid can then be achieved by
using the role description (x t y)+ .
Note that this undecidability result is also closely related to the known undecidability
of IDPDL, i.e., deterministic propositional dynamic logic with intersection (Harel, 1984).
However, the undecidability proof for IDPDL by Harel (1984) uses the test construct, which
is not available in ALC +,,u,t
.
f
Next, we show that relativized satisfiability in two rather expressive sublanguages of
ALC +,,u,t
is decidable.
f
Theorem 38. Relativized satisfiability of concept descriptions is decidable in ALC f+,,t and
ALC +,,t,u .
Proof sketch. In both cases, TBoxes can be internalized as described by Schild (1991)
and Baader et al. (1993). Thus, it is sufficient to show decidability of (unrelativized)
satisfiability.
, this follows from decidability of DPDL (Ben-Ari, Halpern, & Pnueli,
For ALC +,,t
f
1982), the known correspondence between PDL and ALC +,,t (Schild, 1991), and the fact
that non-functional roles can be simulated by functional ones in the presence of composition
and transitive closure (Parikh, 1980).
For ALC +,,t,u , decidability of satisfiability follows from decidability of IPDL, i.e., PDL
with intersection (Danecki, 1984).

Given this theorem, Corollary 22 now yields the following decidability result.
Corollary 39. Relativized satisfiability of concept descriptions is decidable in the fusion
ALC f+,,t  ALC +,,t,u .
5.3 A concrete example
Description logics with concrete domains were introduced by Baader and Hanschke (1991)
in order to allow for the reference to concrete objects like numbers, time intervals, spatial
regions, etc. when defining concepts. To be more precise, Baader and Hanschke (1991)
define the extension ALC(D) of ALC, where D is a concrete domain (see below). Under
suitable assumptions on D, they show that satisfiability in ALC(D) is decidable. One of the
main problems with this extension of DLs is that relativized satisfiability (and satisfiability in DLs where TBoxes can be internalized) is usually undecidable (Baader & Hanschke,
1992) (though there are exceptions, see Lutz, 2001). For this reason, Haarslev et al. (2001)
introduce a restricted way of extending DLs by concrete domains, and show that the corresponding extension of ALCN HR+ has a decidable relativized satisfiability problem.10 In
the following, we show that this result can also be obtained as an easy consequence of
10. To be more precise, they even show that relativized ABox consistency is decidable in their restricted
extension of ALCN HR+ by concrete domains. Here, we restrict ourself to satisfiability of concepts
since the ABoxes introduced by Haarslev et al. (2001) also allow for the use of concrete individuals and
for predicate assertions on these individuals, which is not covered by the object assertions for ADSs
introduced in the present paper.

36

fiFusions of Description Logics and Abstract Description Systems

our Theorem 17. Moreover, ALCN HR+ can be replaced by an arbitrary local DL with a
decidable relativized satisfiability problem.
Definition 40 (Concrete Domain). A concrete domain D is a pair (D , D ), where D
is a nonempty set called the domain, and D is a set of predicate names. Each predicate
name P  D is associated with an arity n and an n-ary predicate P D  nD . A concrete
domain D is called admissible iff (1) the set of its predicate names is closed under negation
and contains a name >D for D , and (2) the satisfiability problem for finite conjunctions
of predicates is decidable.
Given a concrete domain D and one of the predicates P  D (of arity n), one can
define a new concept constructor f1 , . . . , fn .P (predicate restriction), where f1 , . . . , fn are
concrete features.11 In contrast to the abstract features considered until now, concrete
features are interpreted by partial functions from the abstract domain I into the concrete
domain D . We consider the basic DL that allows for Boolean operators and these new
concept constructors only.
Definition 41 (B(D)). Let NC be a set of concept names and NFc be a set of names for
concrete features disjoint from NC , and let D be an admissible concrete domain. Concepts
descriptions of B(D) are Boolean combinations of concept names and predicate restrictions, i.e., expressions of the form f1 , . . . , fn .P where P is an n-ary predicate in D and
f1 , . . . , fn  NFc .
The semantics of B(D) is defined as follows. We consider an interpretation I, which
has a nonempty domain I , and interprets concept names as subsets of I and concrete
features as partial functions from I into D . The Boolean operators are interpreted as
usual, and
(f1 , . . . , fn .P )I = {a  I | x1 , . . . , xn  D .
fiI (a) = xi for all 1  i  n and (x1 , . . . , xn )  P D }.
Note that concept descriptions are interpreted as subsets of I and not of I  D .
Thus, if we go to the ADS corresponding to B(D), the concrete domain is not an explicit
part of the corresponding ADMs. It is only used to define the interpretation of the function
symbols corresponding to predicate restrictions. The predicate restriction constructor is
translated into a function symbol ff1 ,...,fn .P of arity 0, and, for an ADM W corresponding
W
to a frame F, ff
is defined as (f1 , . . . , fn .P )I , where I is the interpretation based
1 ,...,fn .P
on F that maps all concept names to the empty set.
Theorem 42. Let D be an admissible concrete domain. Then, B(D) is local and the
relativized satisfiability problem for B(D)-concept descriptions is decidable.
Proof. Given the family (Wi )iI of ADMs Wi corresponding to the frames Fi over pairwise
disjoint
domains Fi (i  I), we first build the union F of the frames: the domain of F is
S
F
i and it interprets the concrete features in the obvious way, i.e., f F (x) := f Fi (x) if
iI 
11. Note that the general framework introduced by Baader and Hanschke (1991) allows for feature chains in
predicate restrictions. Considering only feature chains of length one is the main restriction introduced
by Haarslev et al. (2001).

37

fiBaader, Lutz, Sturm, & Wolter

x  Fi . Let W be the ADM induced by F. ToSprove that W is in fact the disjoint union of
Wi
W
(Wi )iI , it remains to show that ff
= iI ff
. This is an easy consequence
1 ,...,fn .P
1 ,...,fn .P
of the semantics of the predicate restriction constructor, the interpretation of the concrete
features in F, and the fact that the domains Fi are pairwise disjoint.
Decidability of the unrelativized satisfiability problem is an immediate consequence of
the decidability results for ALC(D) given by Baader and Hanschke (1991). Since B(D) is a
very simple DL that does not contain any concept constructors requiring the generation of
abstract individuals, it is easy to see that a B(D)-concept description C0 is satisfiable relative
to the TBox C1 v D1 , . . . , Cn v Dn iff it is satisfiable in a one-element interpretation. But
then the TBox can be internalized in a very simple way: C0 is satisfiable relative to the
TBox C1 v D1 , . . . , Cn v Dn iff C0 u (C1 t D1 ) u . . . u (Cn t Dn ) is satisfiable.

Given this theorem, Corollary 22 now yields the following transfer result, which shows
that concrete domains with the restricted form of predicate restrictions introduced above can
be integrated into any local DL with a decidable relativized satisfiability problem without
losing decidability.
Corollary 43. Let D be an admissible concrete domain and L be a local DL for which
relativized satisfiability of concept descriptions is decidable. Then, relativized satisfiability
of concept descriptions in B(D)  L is also decidable.
5.4 Non-local DLs
By Proposition 15, DLs allowing for nominals, the universal role, or role negation are not
local. It follows that the decidability transfer theorems are not applicable to fusions of such
DLs. In the following, we try to clarify the reasons for this restricted applicability of the
theorems.
First, we show that there are DLs with decidable satisfiability problem such that their
fusion has an undecidable satisfiability problem. The culprit in this case is the universal
role (or role negation).
Theorem 44. Satisfiability of concept descriptions is decidable in ALC U and ALCF, but
undecidable in their fusion ALC U  ALCF.
Proof. Decidability of ALCF was shown by Hollunder and Nutt (1990) and of ALC U by
Baader et al. (1990) and Goranko and Passy (1992). Undecidability of ALC U  ALCF
(which is identical to ALCF U ) follows from the results by Baader et al. (1993) and the fact
that the universal role can be used to simulate TBoxes (see Proposition 24).

Note that role negation can be used to simulate the universal role: just replace U.C
by R.C u R.C and U.C by R.C t R.C. In addition, decidability of ALC  is known
to be decidable (Lutz & Sattler, 2000). Consequently, the theorem also holds if we replace
ALC U by ALC  .
It should be noted that the example given in the above theorem depends on the fact
that one of the two DLs allows for the universal role and the other becomes undecidable
if the universal role is added. In fact, Corollary 25 shows that decidability does transfer if
both DLs already provide for the universal role.
38

fiFusions of Description Logics and Abstract Description Systems

Concerning nominals, we do not have a counterexample to the transfer of decidability
in their presence. However, we think that it is very unlikely that there can be a general
transfer result in this case. In fact, note that for each DL L without nominals introduced in
Section 2, its fusion with ALCO is identical to L extended with nominals. Since (relativized)
satisfiability in ALCO is decidable, a general transfer result in this case would imply that
this extension is decidable provided that L is decidable. Consequently, this would yield a
general transfer result for adding nominals.

6. Conclusion
Regarding related work, the work that is most closely related to the one presented here is
(Wolter, 1998). There, analogs of our Theorems 20 and 30 are proved for normal modal
logics within an algebraic framework. The present results extend the ones from Wolter
(1998) in two directions. First, we have added object assertions, and thus can also prove
transfer results for ABox reasoning. Second, we can show transfer results for satisfiability in
non-normal modal logics as long as we have covering normal terms. This allows us to handle
non-normal concept constructors like qualified number restrictions (graded modalities) in
our framework.
We also think that the introduction of abstract description systems (ADSs) is a contribution in its own right. ADSs abstract from the internal structure of concept constructors
and thus allow us to treat a vast range of such constructors in a uniform way. Nevertheless, the model theoretic semantics provided by ADSs is less abstract than the algebraic
semantics employed by Wolter (1998). It is closer to the usual semantics of DLs, and thus
easier to comprehend for people used to this semantics. The results in this paper show
that ADSs in fact yield a good level of abstraction for proving general results on description logics. Recently, the same notion has been used for proving general results about
so-called E-connections of representation formalisms like description logics, modal spatial
logics, and temporal logics (Kutz, Wolter, & Zakharyaschev, 2001). In contrast to fusions,
in an E-connection the two domains are not merged but connected by means of relations.
Regarding complexity, our transfer results yield only upper bounds. Basically, they
show that the complexity of the algorithm for the fusion is at most one exponent higher
than of the ones for the components. We believe that the complexity of satisfiability in the
fusion of ADSs can indeed be exponentially higher than the complexity of satisfiability in
the component ADSs. However, we do not yet have matching lower bounds, i.e., we know
of no example where this exponential increase in the complexity really happens.
Note that Spaans results (1993) on the transfer of NP and PSpace decidability from
the component modal logics to their fusion are restricted to normal modal logics, and that
they make additional assumptions on the algorithms used to solve the satisfiability problem
in the component logics. Nevertheless, for many PSpace-complete description logics it is
easy to see that their fusion is also PSpace-complete. In this sense, the general techniques
for reasoning in the fusion of descriptions logics developed in this paper give only a rough
complexity estimate.

39

fiBaader, Lutz, Sturm, & Wolter

Appendix A. Proofs
In this appendix, we give detailed proofs of criteria for (relativized) satisfiability in the
fusion of local ADSs. Recall that, from these criteria, the transfer theorems for decidability
easily follow. We have deferred the proofs of these theorems to the appendix since they are
rather technical.
A.1 Proof of Theorem 20
Before we can prove this theorem, we need a technical lemma. In the proof of Theorem 20,
we are going to merge models W1  M1 and W2  M2 by means of a bijective function b
from the domain W1 of W1 onto the domain W2 of W2 in such a way that the surrogates
suri (t), t  C 1 (), are respected by b in the sense that
1

w  sur1 (t)W1 ,A  b(w)  sur2 (t)W2 ,A

2

for all w  W1 and t  C 1 (). The existence of such a bijection is equivalent to the condi1
1
2
2
tion that the cardinalities |sur1 (t)W1 ,A | of sur1 (t)W1 ,A and |sur2 (t)W2 ,A | of sur2 (t)W2 ,A
coincide for all t  C 1 (): if t 6= t0 for t, t0  C 1 (), then t contains a conjunct which is
i
(equivalent to) the negation of a conjunct of t0 ; hence, for all such t, t0 , we have suri (t)Wi ,A 
i
suri (t0 )Wi ,A =  for i  {1, 2}, which clearly yields the above equivalence. The following
lemma will be used to choose models in such a way that this cardinality condition is satisfied.
(We refer the reader to, e.g., Gratzer, 1979 for information about cardinals.)
Lemma 45. Let (L, M) be a local ADS and  a set of assertions satisfiable in (L, M).
Then there
exists aff cardinal  such that, for all cardinals 0  , there exists a model


W = W, F W , RW  M with |W | = 0 and an assignment A with hW, Ai |=  and
|sW,A |  {0, 0 } for all terms s.


ff
Proof. By assumption, there exists an ADM W0 = W0 , F W0 , RW0  M and an assignment B = hB1 , B2 i in it such that hW0 , Bi |= . Let  = max{0 , |W0 |}. We
show that
Let 0  . Take 0 disjoint isomorphic copies hW , B1 i,

  isWas required.
ff
W
W = W , F  , R 
 ,  < 0 , ffof hW0 , B1 i. (The first member of the list coincides
with W0 .) Let W = W, F W , RW be the disjoint union of the W ,  < 0 , and define
hW, A = hA1 , A2 ii by putting A2 (a) = B2 (a), for all a  X , and
[ 
A1 (x) =
B1 (x),
<0

for all x  V . Note that all object variables are interpreted in W0 . It follows from the
definitions of term semantics and disjoint unions that
[
sW,A =
sW ,B ,
()
<0

for all terms s. Hence |W | = 0 and hW, Ai |= . It remains to show that |sW,A |  {0, 0 }
for every term s. Suppose |sW,A | =
6 0. Then, by (), 0  |sW,A |    0 = 0 , which means
0
W,A
 = |s
|.

40

fiFusions of Description Logics and Abstract Description Systems

i

i

As noted above, the disjointness of the sets suri (t)Wi ,A and suri (t0 )Wi ,A (for t 6= t0 )
is required in order to ensure the existence of the bijection b. More precisely, in order to
i
merge models W1 , W2 , the sets suri (t)Wi ,A for t member of some relevant subset of C 1 ()
must form a partition of Wi s domain that satisfies a certain cardinality condition. This is
formalized by the following definition:
Definition 46. Let  be a cardinal. A set {X1 , . . . , Xn } is called a -partition of a set W
iff
1. |Xi | = , for all 1  i  n,
2. Xi  Xj =  whenever i 6= j, and
S
3. W = 1in Xi .
{X1 , . . . , Xn } is a -partition of an ADM W with domain W iff it is a -partition of W .
In the proof, we will enforce that Properties 1 and 3 hold by appropriate constructions,
while Property 2 holds by definition of C 1 ().
Before proving Theorem 20, we repeat its formulation.
Theorem 20. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs in which L1 is based on
the set of function symbols F and relation symbols R, and L2 is based on G and Q, and
let L = L1  L2 and M = M1  M2 . If  is a finite set of assertions from L, then the
following are equivalent:
1.  is satisfiable in (L, M).
2. There exist
(a) a set D  C 1 (),
(b) for every term t  D an object variable at 6 obj(),
(c) for every a  obj() a term ta  D,
such that the union 1 of the following sets of assertions in L1 is satisfiable in
(L1 , M1 ):
W
(d) {at : sur1 (t) | t  D}  {> v sur1 ( D)},
(e) {a : sur1 (ta ) | a  obj()},

(f ) {R(a, b) | R(a, b)  , R  R},
(g) {sur1 (t1 ) v sur1 (t2 ) | t1 v t2  }  {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of assertions in L2 is satisfiable in (L2 , M2 ):
W
(h) {at : sur2 (t) | t  D}  {> v sur2 ( D)},
(i) {a : sur2 (ta ) | a  obj()},

(j) {Q(a, b) | Q(a, b)  , Q  Q}.
41

fiBaader, Lutz, Sturm, & Wolter

sur1 (s1 )W1 ,A

b

1

b

W1 ,A1

sur1 (s2 )

sur2 (s1 )W2 ,A

2

sur2 (s2 )W2 ,A

2

.
.
.

.
.
.

sur1 (sk )W1 ,A

.
.
.

b

1

sur2 (sk )W2 ,A

W1

2

W2
Figure 3: The mapping b.

Proof. We start with the direction from (2) to (1). Take a set D  C 1 () satisfying
the properties listed in the theorem. Take

 cardinals

i1, i 1ffff{1, 2} 
as in Lemma

 245 2for
ffff
1
2
(Li , Mi ), put  = max{
1 , 2 }, and
take W1 , A = A1 , A2 and W2 , A = A1 , A2
ff
with Wi  Mi such that Wi , Ai |= i for i  {1, 2}. By Lemma 45, for i  {1, 2} we can
i
assume |Wi | =  and, |suri (s)Wi ,A |  {0, } for all s  D.
i
The sets {suri (s)Wi ,A : s  D}
are -partitions
of WiWfor i  {0, 1} since (i) for each s 
ff
i
D, we have (as : suri (s))  i , (ii) Wi , A |= > v suri ( D), and (iii) s, s0  D and s 6= s0
i
i
implies suri (s)Wi ,A  suri (s0 )Wi ,A by definition of D and C 1 . Moreover, obj(1 ) = obj(2 )
1
2
and, for all a  obj(1 ) and s  D, we have A12 (a)  sur1 (s)W1 ,A iff A22 (a)  sur2 (s)W2 ,A .
Together with the fact that A12 and A22 are injective, this implies the existence of a
bijection b from W1 onto W2 such that
1

2

{b(w) : w  sur1 (t)W1 ,A } = sur2 (t)W2 ,A ,
for all t  D, and

b(A12 (a)) = A22 (a),

for all a  obj(1 ). Figure 3, in which it is assumed that D = {s1 , . . . , sk }, illustrates the
mapping b.


ff
Define a model W = W, (F  G)W , (R  Q)W  M by putting
 W = W1 ,
 f W = f W1 , for f  F,
 for all g  G of arity n and all Z1 , . . . , Zn  W ,
g W (Z1 , . . . , Zn ) = b1 (g W2 (b(Z1 ), . . . , b(Zn ))),
where b(Z) = {b(z) : z  Z},
 RW = RW1 , for all R  R,
 QW (x, y) iff QW2 (b(x), b(y)), for all Q  Q.
42

fiFusions of Description Logics and Abstract Description Systems

Since M2 is closed under isomorphic copies, it is not hard to see that W  M1  M2 . Let
A = A1 . To prove the implication from (2) to (1) of the theorem it remains to show that
hW, Ai |= . To this end it suffices to prove the following claim:
Claim. For all terms t  sub1 (), we have
2

1

tW,A = sur1 (t)W1 ,A = b1 (sur2 (t)W2 ,A ).
Before we prove this claim, let us show that it implies hW, Ai |= . First note that, from
the claim, we obtain
1
tW,A = sur1 (t)W1 ,A for all t  term().
(1)
This may be proved by induction on the construction of t  term() from terms in sub1 ()
using the booleans and function symbols from L1 , only. The basis of induction (i.e., the
equality for members of sub1 ()) is stated in the claim and the induction step is straightforward.
We now show that hW, Ai |=  is a consequence of (1). Suppose R(a, b)  . Then
R(a, b)  1 and thus hW, Ai |= R(a, b). Similarly, Q(a, b)   implies Q(a, b)  2 and
1
hW, Ai |= Q(a, b). Suppose (a : t)  . Then (a : sur1 (t))  1 and so A12 (a)  sur1 (t)W1 ,A
which implies, by (1), A12 (a)  tW,A . Hence hW, Ai |= (a : t). If t1 v t2  , then
sur1 (t1 ) v sur1 (t2 )  1 and so, by (1), tW,A
 tW,A
. Hence hW, Ai |= t1 v t2 .
1
2
We come to the proof of the claim. It is proved by induction on the structure of t.
Due to the following equalities holding for all t  sub1 (), it suffices to show that tW,A =
1
sur1 (t)W1 ,A .
sur1 (t)W1 ,A

1

1

=

[

{sur1 (s)W1 ,A : s  D, t is a conjunct of s}

=

[

{b1 (sur2 (s)W2 ,A ) : s  D, t is a conjunct of s}

2

2

= b1 (sur2 (t)W2 ,A )
W
1
The first equality holds since sur1 ( D)W1 ,A = W1 and, for all s  D, either t or t
is a conjunct of s. The second equality is true by definition of b and the validity of the
thirdWequality can be seen analogously to the validity of the first one by considering that
2
sur2 ( D)W2 ,A = W2 .
1

Hence let us show tW,A = sur1 (t)W1 ,A . For the induction start, let t be a variable. The
1
equation tW,A = sur1 (t)W1 ,A is an immediate consequence of the fact that A = A1 . For
the induction step, we distinguish several cases:

 t = t1 . By induction hypothesis, tW,A
= sur1 (t1 )W1 ,A1 . Hence, tW,A = W \ tW,A
=
1
1
1
1
W
,A
W
,A
1
1
W \ sur1 (t1 )
= sur1 (t)
(since W = W1 ).
 t = t1  t2 . By induction hypothesis, tW,A
= sur1 (ti )W1 ,A1 for i  {1, 2}. Hence,
i
1
1
1
tW,A = tW,A
 tW,A
= sur1 (t1 )W1 ,A  sur1 (t2 )W1 ,A = sur1 (t)W1 ,A .
1
2
 t = t1  t2 . Similar to the above case.
43

fiBaader, Lutz, Sturm, & Wolter

1

 t = f (t1 , . . . , tn ). By induction hypothesis, tW,A
= sur1 (ti )W1 ,A for 1  i  n. Hence,
i
1
1
1
W,A
W,A
tW,A = f W (t1 , . . . , tn ) = f W (sur1 (t1 )W1 ,A , . . . , sur1 (tn )W1 ,A ) = sur1 (t)W1 ,A
(since f W = f W1 ).
 t = g(t1 , . . . , tn ). In this case, tW,A = b1 (g W2 (b(tW,A
), . . . , b(tW,A
))). Since, by the
n
1
2
2
1
W
,A
1
W
,A
1
2
above equalities, sur1 (t)
= b (sur2 (t)
), it remains to show that sur2 (t)W2 ,A =
2
2
2
g W2 (b(tW,A
), . . . , b(tW,A
)). Since we have sur2 (t)W2 ,A = g W2 (sur2 (t1 )W2 ,A , . . . , sur2 (tn )W2 ,A ),
n
1
2
this amounts to showing that b(tW,A
) = sur2 (ti )W2 ,A for 1  i  n. This, however,
i
follows by induction hypothesis together with the above equations.
This concludes the proof of the direction from (2) to (1).
It remains to prove the direction from (1) to (2). Suppose hW, Ai |= , for some W  M
and A = hA1 , A2 i. Put
D = {s  C 1 () : sW,A 6= }.
Note that the fusion of local ADLs is a local ADL again. Hence (L, M) is local and we may
assume, by Lemma 45, that the sets sW,A are infinite.
Take a new object name as 6 obj() for every s  D and let, for a  obj(),
^
^
ta = {t  sub1 () : A2 (a)  tW,A }  {t : t  sub1 (), A2 (a) 6 tW,A }.
We prove that set of assertions 1 based on D, ta , a  obj(), and as , s  D, is satisfiable
in (L1 , M1 ).
W
Let F W denote the restriction of (F  G)W to the
 symbols in F.
R
ff Similarly,

 1 is the
ff
W
W
W
1
restriction of (RQ) to the symbols in R. Set W1 = W, F , R
 M1 , A = A1 , A12 ,
where
A11 = A1  {xt 7 tW,A : t = g(t1 , . . . , tk )  sub1 ()},
A12 (a) = A2 (a), for a  obj(), and A12 (as )  sW,A , for all s  D. Note that we can choose
an injective function A12 because the sW,A are infinite. We show by induction that
sur1 (t)W1 ,A1 = tW,A for all t  term().

(2)

Let t = x be a variable. Then x is not a surrogate, and so A11 (x) = A1 (x). For the induction
step, we distinguish several cases:
 The inductive steps for t = t1 , t = t1  t2 , t = t1  t2 , and t = f (t1 , . . . , tn ), f  F,
are identical to the corresponding cases in the proof of Equation 1, which occurs in
the direction that (2) implies (1) above.
 t = g(t1 , . . . , tn ), where g  G. Then sur1 (t) = xt . Hence A11 (xt ) = tW,A and the
equation is proved.


ff


ff
From Equation 2,
 we obtain
W1 , A1 |= 1 : we prove W1 , A1 |= R(a, b) whenever
ff
R(a, b)  1 and W1 , A1 |= sur1 (t1 ) v sur1 (t2 ) whenever sur1 (t1 ) v sur1 (t2 )  1 . The
remaining formulas from 1 are left

 to theffreader. Suppose R(a, b)  1 . Then R(a, b)  
and so hW, Ai |= R(a, b). Hence W1 , A1 |= R(a, b). Suppose sur1 (t1 ) v sur1 (t2 )  1 .
44

fiFusions of Description Logics and Abstract Description Systems

 t2W,A . By Equation 2,
Then t1 v t2  . Hence hW, Ai |= t1 v t2 which means tW,A
1


ff
1
1
sur1 (t1 )W1 ,A  sur1 (t2 )W1 ,A which means W1 , A1 |= sur1 (t1 ) v sur1 (t2 ).
The construction of a model in M2 satisfying 2 is similar and left to the reader.

A.2 Proof of Theorem 30
As in the proof of Theorem 17, we fix two local ADSs Si = (Li , Mi ), i  {1, 2}, in which
L1 is based on the set of function symbols F and relation symbols R, and L2 is based on
G and Q. Let L = L1  L2 and M = M1  M2 . We assume that S1 and S2 have covering
normal terms.
Similarly to what was done in the previous section, we will merge models by means
1
of bijections which map points in sets sur1 (t)W1 ,A to points in the corresponding sets
2
sur2 (t)W2 ,A . For a finite set of object assertions  of L, let i () denote the set of all
s  C i () such that the term s is satisfiable in (L, M) (for i  {1, 2}). To ensure that
the merging of models succeeds, we must enforce that the elements of 1 () and 2 ()
form -partitions (for some appropriate ) of the models to be merged. For 1 (), this
is captured by the following lemma. Explicitly stating a dual of this lemma for 2 () is
omitted for brevity.
Lemma 47. Let  be a finite set of object assertions of L,  a cardinal satisfying the
conditions of Lemma 45 for (L, M) and , and 1 = 1 (). If 0  , then
1. there exists a model W  M1 and an assignment A such that
{sur1 (s)W,A | s  1 }
is a 0 -partition of W; and
2. there exists a model W  M2 and an assignment A such that
{sur2 (s)W,A | s  1 }
is a 0 -partition of W.
Proof. 1. By definition of 1 , for each s  1 , we find a model Ws  M and an
assignment As such that sWs ,As 6= . Since the fusion of two local ADSs is again local,
the set of models M is closed under disjoint unions. Hence, there exists a model W1
and an assignment A1 such that sW1 ,A1 6=  for all s  1 . It follows that the set
1 := D{as : s | s  1 } is satisfiable
E in (L, M). By Lemma 45, there thus exists a model
0
0
0
0
W
W
W = W , (F  G) , (R  Q)
 M and an assignment A0 such that W0 , A0 |= 1 and
0

0

{sW ,A | s  1 } is a 0 -partition of W 0 . Now let W denote the restriction of W0 to L1 and
define
0
0
A1 = A01  {xt 7 tW ,A | t = g(t1 , . . . , tk )  sub1 ()}.
0

0

Then hW, Ai is as required. To prove this note that sur1 (t)W,A = tW ,A for all t  term().
2. is similar and left to the reader.

45

fiBaader, Lutz, Sturm, & Wolter

We repeat the formulation of the theorem to be proved.
Theorem 30. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs having covering normal
terms in which L1 is based on the set of function symbols F and relation symbols R, and
L2 is based on G and Q, and let L = L1  L2 and M = M1  M2 . Let  be a finite set
of object assertions from L. Put m := dF (), r := dG (), and let c(x) (d(x)) be a covering
normal term for all function symbols in  that are in F (G).
For i  {1, 2}, denote by i the set of all s  C i () such that the term s is satisfiable in
(L, M). Then the following three conditions are equivalent:
1.  is satisfiable in (L, M).
2. There exist
 for every t  1 an object variable at 6 obj()
 for every a  obj() a term ta  1
such that the union 1 of the following sets of object assertions is satisfiable in
(L1 , M1 ):
W
 {at : sur1 (t  cm (sur1 ( 1 )) | t  1 },
W
 {a : sur1 (ta  cm (sur1 ( 1 )) | a  obj()},
 {R(a, b) | R(a, b)  , R  R},
 {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of object assertions is satisfiable in (L2 , M2 ):
W
 {at : sur2 (t  dr (sur2 ( 1 )) | t  1 },
W
 {a : sur2 (ta  dr (sur2 ( 1 )) | a  obj()},
 {Q(a, b) | Q(a, b)  , Q  Q}.

3. The same condition as in (2) above, with 1 replaced by 2 .
We start the proof with the direction from (1) to (2) and (1) to (3). The proofs are
dual to
so we onlyff give a proof for (1)  (2). Suppose hW, Ai |= , where

 each other,
W
W = W, (F  G) , (R  Q)W . By Lemma 45, we can assume that that, for every t  1 ,
|tW,A | is infinite. Take a new object name as 6 obj() for every s  1 and let, for
a  obj(),
^
^
ta = {t  sub1 () : A2 (a)  tW,A }  {t : t  sub1 (), A2 (a) 6 tW,A }.
We prove that the set 1 of assertions based on ta , a  obj(), and as , s  1 , is satisfiable
in (L1 , M1 ) (the proof is rather similar to the proof of the direction from (1) to (2) in the
proof of Theorem 20). Let F W (resp. G W ) denote the restriction of (F  G)W to the symbols
in F (resp. G). Similarly, RW and
 QW are theffrestrictions of 
(R  Q)ffW to the symbols in
R and Q, respectively. Set W1 = W, F W , RW  M1 , A1 = A11 , A12 , where
A11 = A1  {xt 7 tW,A | t = g(t1 , . . . , tk )  sub1 ()},
46

fiFusions of Description Logics and Abstract Description Systems

A12 (a) = A2 (a), for a  obj(), and A12 (at )  tW,A , for all t  1 (we can choose an injective
function for A12 since the sets tW,A are infinite).
As in the corresponding part of the proof of Theorem 20, it can show by induction that
sur1 (t)W1 ,A1 = tW,A for all t  term().


ff
Let us see now why W1 , A1 |= 1 follows from
For R(a, b)  1 we have

 this equation.
ff
1 |= R(a, b). We have hW, Ai |=
R(a,
b)


and
so
hW,
Ai
|=
R(a,
b).
Hence
W
,
A

 1 1ff
W
W
( 1 ) = > (by the definition
of

).
Hence
W1 , A |= sur1 ( 1 ) = > and so, by
1
ff


W
the definition of cm , W1 , A1 |= (cm (sur1 ( 1 ))) = >. It remains to observe that
A12 (a)  sur1 (ta )W1 ,A1 for all a  obj(), A12 (a)  sur1 (s)W1 ,A1 whenever (a : s)  , and
A12 (at )  sur1 (t)W1 ,A1 for all t  1 .
The construction of a model in M2 satisfying 2 is similar and left to the reader.
It remains to show the implications (2)  (1) and (3)  (1). They are similar, so
we concentrate on the first. In the proof of Theorem 20 it was possible to construct the
required model for  by merging models for 1 and 2 . The situation is different here. It
is not possible to W
merge models for 1 and
W 2 in one step, since we do not know whether
they satisfy sur1 ( 1 ) = > and sur2 ( 1 ) = >,
W respectively. We only know that
W they
satisfy the approximations a : sur1 (s)  cm (sur1 ( 1 )) and a : sur2 (s)  dr (sur2 ( 1 )),
respectively, for a : s  . To merge models of this type we have to distinguish various
pieces of the models and have to add new pieces as well. To define those pieces we need a
technical claim. As in the proof of Theorem 17, take cardinals i , i  {1, 2} as in Lemma 45
for (Li , Mi ) and put  = max{1 , 2 }.
Claim 1. Suppose (2) holds.


ff
(a) There exist W1 = W1 , F W , RW  M1 , an assignment A = hA1 , A2 i into W1 , and
a sequence X0 , . . . , Xm of subsets of W1 such that
[a1] A2 (a)  Xm , for all a  obj(1 ),
[a2] hW1 , Ai |= 1 ,
[a3] Xn+1  Xn  cW1 (Xn ), for all 0  n < m,
[a4] The set {sur1 (s)W1 ,A  Xm : s  1 } is a -partition of Xm ,
[a5] The sets
{sur1 (s)W1 ,A  (Xn  Xn+1 ) : s  1 }
are -partitions of Xn  Xn+1 , for 0  n < m.
[a6] |W1  X0 | = .


ff
(b) There exist W2 = W2 , G W , QW  M2 , an assignment B = hB1 , B2 i, and a sequence
Y0 , . . . , Yr of subsets of W2 such that
[b1] B2 (a)  Yr , for all a  obj(1 ),
[b2] hW2 , Bi |= 2 ,
47

fiBaader, Lutz, Sturm, & Wolter

A1 = W1  X0
A0 = X 0  X 1

..
.

..
.

Am2 = Xm2  Xm1
Am1 = Xm1  Xm
Xm

W1
Figure 4: The sets Xi .

[b3] Yn+1  Yn  dW2 (Yn ), for all 0  n < r,
[b4] The set {sur2 (s)M,A  Yr : s  1 } is a -partition of Yr ,
[b5] The sets
{sur2 (s)M,A  (Yn  Yn+1 ) : s  1 }
are -partitions of Yn  Yn+1 , for 0  n < r.
[b6] |W2  Y0 | = .
Figure 4 illustrates the relation between the sets Xi . (We set Ai = Xi  Xi+1 for 0  i < m
and A1 = W
W1  X0 .) Intuitively, Xm is the set of points for which we know that points in
W1  sur1 ( 1 )W1 ,A are very far away. For Xm1 they are possibly less far away, for
Xm2 possibly even less far, and so on for W
Xi , i < m  1. Finally, for members of A1 it
is not even known whether they are in sur1 ( 1 )W1 ,A or not. Note that all object names
are interpreted in Xm . We now come to the formal construction of the sets Xi .
Proof of Claim 1. We prove (a). Part (b) is proved
andffleft to the reader. By

 similarly
W
a
assumption and Lemma 45, we find an ADM Wa = Wa , F , RWa  M1 with |Wa | = 
and an assignment Aa = hAa1 , Aa2 i such that hWa , Aa i |= 1 .
Let
_
Zn = (cn (sur1 ( 1 )))Wa ,Aa ,
for 0 
 n  m. By Lemma
47 (1) we can take for every n with 1  n  m an ADM
ff
Wn = Wn , F Wn , RWn  M1 and assignments An such that
n

{sur1 (s)Wn ,A : s  1 }
48

fiFusions of Description Logics and Abstract Description Systems

are -partitions of Wn .
ff


Take the disjoint union W (with W = W, F W , RW ) of the Wn , 1  n  m, and Wa .
Define A = hA1 , A2 i in W by putting
[
A1 (x) = Aa1 (x) 
Ai1 (x),
1im

for all set variables x and A2 (b) = Aa2 (b), for all object variables b. Let, for 0  n  m,
[
Xn = Zn 
Wi .
nim

We show that hW, Ai and the sets Xn , 0  n  m, are as required.
[a1] We have hWa , Aa i |= 1 and so A2 (b) = Aa2 (b)  Zm for all b  obj(1 ). Hence
A2 (b)  Xm = Zm  Wm for all b  obj(1 ).
[a2] By the definition of disjoint unions and because hWa , Aa i |= 1 .
[a3] Firstly, we have, by the definition of cn t and since cW is monotone (it distributes
over intersections),
Zn+1  Zn  cW (Zn )  Xn  cW (Xn ).
(3)
Secondly, by the definition of disjoint unions, the first property of covering normal
terms, and since cW is monotone
[
[
[
[
Wi 
Wi 
Wi  cW (
Wi )  Xn  cW Xn .
(4)
n+1im

nim

nim

nim

From (3) and (4) we obtain
Xn+1 = Zn+1 

[

Wi  Xn  cW Xn .

(5)

n+1im

[a4] We show that the three properties from Definition 46 are satisfied. Since
{sur1 (s)Wm ,Am : s  1 }
is a -partition of Wm , we have |sur1 (s)Wm ,Am | =  for all s  1 . This implies
Property 1 since sur1 (s)W,A  Wm = sur1 (s)Wm ,Am , Wm  Xm , and |Xm |  .
Property 2 is an immediate consequence of the definition of 1 . As for Property 3,
we show that, for all w  Xm , we have w  sW,A for an s  1 . Fix a w  Xm . We
distinguish two cases: firstly, assume w  Wm . Then, by the fact that {sur1 (s)Wm ,Am :
s  1 } is a -partition of Wm , it is clear
W that there exists an s  1 as required.
m (sur (  )))Wa ,Aa . By definition of cm t, we have
Secondly, assume
w

Z
=
(c
m
1
1
W
w  (sur1 ( 1 ))Wa ,Aa and so again w  sur1 (s)W,A for some s  1 .
[a5] The proof is similar to that of Property [a4].
49

fiBaader, Lutz, Sturm, & Wolter

[a6] By definition.
This finishes the proof of Claim 1.
Suppose now that we have
E
D
E
D
W1 = W1 , F W1 , RW1 , A, Xm , . . . , X0 and W2 = W2 , G W2 , QW2 , B, Yr , . . . , Y0
satisfying the properties listed in Claim 1. We may assume that
(W1  Xm )  (W2  Yr ) = .
Using an appropriate bijection b from Xm onto Yr we may also assume that Xm = Yr ,
A2 (a) = B2 (a) for all object variables a  obj(1 ), and
sur1 (s)W1 ,A  Xm = sur2 (s)W2 ,B  Xm for all s  1 .

(6)

This follows from the fact that all object variables are mapped by A2 and B2 into Xm and
Yr ([a1], [b1]), respectively, the injectivity of the mappings A2 and B2 , and the conditions
[a4] and [b4] which state that {sur1 (s)W1 ,A  Xm : s  1 } and {sur2 (s)W2 ,B  Yr : s  1 }
both form -partitions of Xm = Yr . Some abbreviations are useful: set
 Ai = Xi  Xi+1 , for 0  i < m,
 Bi = Yi  Yi+1 , for 0  i < r,
 A1 = W1  X0 , B1 = W2  Y0 .
So far we have merged the Xm -part of W1 with the Yr -part of W2 . It remains to take care
of the sets Ai , 1  i < m, and Bi , 1  i < r: the sets Ai will be merged with new
models Wi  M2 and the sets Bi will be merged with new models Vi from M1 . Thus,
the final model will be obtained by merging the disjoint union of W1 and Wi , 1  i < m
with the disjoint union of W2 and Vi , 1  i < r. Figure 5 illustrates this merging. In the
figure, we assume that 1 = {s1 , . . . , sk }.
Of course, when merging Ai , i  0, with a new model Wi we have to respect the partition
{sur1 (t)W1 ,A  Ai | t  1 }
of Ai . And when merging Bi , i  0, with a new model Vi we have to respect the partition
{sur1 (t)W1 ,B  Bi | t  1 }
of Bi . Note that for A1 and B1 there is no partition
care
D to take
E of. We now proceed with
i
i
i
W
W
the formal construction. We find models W = Ai , G , Q
 M2 with assignments

 i iff
i
B = B1 , B2 , 1  i  m  1, such that, for 0  i  m  1,
i

i

sur2 (s)W ,B = sur1 (s)W1 ,A  Ai for all s  1 .
This follows from [a5], [a6], and Lemma 47 (2).
50

(7)

fiFusions of Description Logics and Abstract Description Systems

Xm Am1

...

A0 A1 Vr1

...

V0 V1

sur1 (s1 )

.
.
.

...

...

...
Wm1 . . .

...
...

sur1 (sk )

Yr

W0 W1 Br1

B0 B1

sur2 (s1 )

.
.
.

...

.. .

sur2 (sk )
Figure 5: The bijection.

D
E
i
i
We find, now using [b5], [b6], and Lemma 47 (1), models Vi = Bi , F V , RV  M1


ff
with assignments Ai = Ai1 , Ai2 , 1  i  r  1, such that, for 0  i  r  1,
i

i

sur1 (s)V ,A = sur2 (s)W2 ,B  Bi for all s  1 .
Let

(8)

D
E
0
0
W01 = W1  (W2  Yr ), F W1 , RW1  M1

be the disjoint union of the Vi , 1  i < r, and W1 , and let
D
E
0
0
W02 = W2  (W1  Xm ), G W2 , QW2  M2
be the disjoint union of the Wi , 1  i < m, and W2 . We assume Xm = Yr and so the
domain of both ADMs is
 W1  W2 .
ff
Define a model W = W, (F  G)W , (R  Q)W  M based on W = W1 W2 by putting
0

 RW = RW1 ,
0

 F W = F W1 ,
0

 QW = QW2 ,
0

 G W = G W2 .
51

fiBaader, Lutz, Sturm, & Wolter

Define an assignment C = hC1 , C2 i in W by putting
 C2 (a) = A2 (a)(= B2 (a)), for all a  obj(1 ).
S
 C1 (x) = A1 (x)  1i<r Ai1 (x), for all set variables x in term().
S
Notice that C1 (x) = B1 (x)  1i<m B1i (x), for all set variables x  term().
 C1 (xt ) = A1 (xt ) 

S

 C1 (xt ) = B1 (xt ) 

S

1i<r

Ai1 (xt ), for all t = g(t1 , . . . , tk )  sub1 ().

i
1i<m B1 (xt ),

for all t = f (t1 , . . . , tk )  sub1 ().

We will show that hW, Ci |= . Firstly, however, we make a list of the relevant properties
of hW, Ci:
Claim 2.
[c1] C2 (a)  Xm = Yr , for all a  obj();
[c2] hW, Ci |= 1  2 ;
[c3] sur1 (t)W,C  (X0  Y0 ) = sur2 (t)W,C  (X0  Y0 ), for all t  1 ;
[c4] sur1 (s)W,C  (X0  Y0 ) = sur2 (s)W,C  (X0  Y0 ), for all s  sub1 ();
[c5] Xn+1  Xn  cW (Xn ), for all 0  n < m;
[c6] Yn+1  Yn  dW (Yn ), for all 0  n < r;
[c7] for all g  G of arity l, 0  n < m, and all C1 , . . . , Cl  W :
g W (C1 , . . . , Cl )  Xn = g W (C1  Xn , . . . , Cl  Xn )  Xn ;
[c8] for all f  F of arity l, 0  n < r, and all C1 , . . . , Cl  W :
f W (C1 , . . . , Cl )  Yn = f W (C1  Yn , . . . , Cl  Yn )  Yn .
Proof of Claim 2. [c1] follows from [a1] and [b1] and the construction of hW, Ci. [c2] follows
from [a2] and [b2]. [c3] follows from the construction of hW, Ci and equations (6), (7), and
(8). [c4] follows from [c3]. [c5] and [c6] follow from [a3] and

 [b3], ffrespectively. It remains
to prove [c7] and [c8]. But [c7] follows from the fact that W, GW is the disjoint union of
structures based on Xn and W  Xn , for 0  n < m, and [c8] is dual to [c7]. Claim 2 is
proved.
We now show hW, Ci |= . To this end we first show the following:
Claim 3. For all k1 , k2 with 0  k1  m and 0  k2  r and all s  sub1 () with dF (s)  k1
and dG (s)  k2 we have, for Z  {Xk1 , Yk2 },
Z  sM,C = Z  sur1 (s)M,C = Z  sur2 (s)M,C .
52

fiFusions of Description Logics and Abstract Description Systems

Proof of Claim 3. By [c4] it suffices to prove the first equation. The proof is by induction
on the cardinal k1 + k2 . The induction base k1 = k2 = 0 follows from sur1 (s) = sur2 (s) for
dF (s) = dG (s) = 0.
Suppose the claim is proved for all Xk , Yk0 with k  m, k 0  r and k + k 0 < k1 + k2 . We
prove the claim for Xk1 , Yk2 . The proof is by induction on the construction of terms s with
dF (s)  k1 and dG (s)  k2 . The boolean cases are trivial.
Suppose s = f (s1 , . . . , sl ) with dF (s)  k1 and dG (s)  k2 . We have to show the
following two statements:
(i) Xk1  sW,C = Xk1  sur1 (s)M,C .
(ii) Yk2  sW,C = Yk2  sur1 (s)M,C .
Consider (i) first. The induction hypothesis yields
Xk1 1  sW,C
= Xk1 1  sur1 (si )W,C
i
for 1  i  l. We have
Xk1 1  cW (Xk1 1 )  sW,C = Xk1 1  cW (Xk1 1 )  f W (s1W,C , . . . , slW,C )
= Xk1 1  cW (Xk1 1 )  f W (sur1 (s1 )W,C , . . . , sur1 (sl )W,C )
= Xk1 1  cW (Xk1 1 )  sur1 (s)W,C .
The second equation is an immediate consequence of the third property of covering normal
terms as given in Definition 26. Now the equation follows from [c5], i.e. Xk1  Xk1 1 
cW (Xk1 1 ). (i) is proved.
(ii) Suppose first that k2 = r. Then Yk2 = Xm and the claim can be proved as above
since Xm  Xk1 and, by induction hypothesis, Xk1 1  sW,C
= Xk1 1  sur1 (si )W,C , for
i
1  i  l.
Assume now that k2 < r. By induction hypothesis,
Yk2  sW,C
= Yk2  sur2 (si )W,C ,
i
for 1  i  l. Hence
, . . . , Yk2  sW,C
) = f W (Yk2  sur2 (s1 )W,C , . . . , Yk2  sur2 (sl )W,C ).
f W (Yk2  sW,C
1
l
We intersect both sides of the equation with Yk2 and derive with the help of [c8]:
Yk2  f W (sW,C
, . . . , sW,C
) = Yk2  f W (sur2 (s1 )W,C , . . . , sur2 (sl )W,C ).
1
l
This means Yk2  sW,C = Yk2  sur2 (s)W,C , and the equation follows. The statements are
proved.
The case s = g(s1 , . . . , sl ) is dual and left to the reader. We have proved claim 3.
By induction (c.f. in the proof of Theorem 20 the proof of (1) from the corresponding
claim), we obtain from Claim 3:
Xm  sW,C = Xm  sur1 (s)M,C for all s  term().
53

(9)

fiBaader, Lutz, Sturm, & Wolter

Let us see how hW, Ai |=  follows from (9). We distinguish three cases: Suppose R(a, b) 
. Then R(a, b)  1 and therefore hW, Ci |= R(a, b). Similarly, Q(a, b)   implies
Q(a, b)  2 and hW, Ci |= Q(a, b). Suppose (a : t)  . Then (a : sur1 (t))  1 and so, by
[c2], C2 (a)  sur1 (t)W,C which implies, by (9), C2 (a)  tW,C . Hence hW, Ci |= (a : t). This
finishes the proof of Theorem 30.

References
Areces, C., Blackburn, P., & Marx, M. (2000). The computational complexity of hybrid
temporal logics. Logic Journal of the IGPL, 8 (5), 653679.
Baader, F. (1991). Augmenting concept languages by transitive closure of roles: An alternative to terminological cycles. In Proc. of the 12th Int. Joint Conf. on Artificial
Intelligence (IJCAI91).
Baader, F., Burckert, H.-J., Hollunder, B., Nutt, W., & Siekmann, J. H. (1990). Concept
logics. In Lloyd, J. W. (Ed.), Computational Logics, Symposium Proceedings, pp.
177201. Springer-Verlag.
Baader, F., Burckert, H.-J., Nebel, B., Nutt, W., & Smolka, G. (1993). On the expressivity
of feature logics with negation, functional uncertainty, and sort equations. J. of Logic,
Language and Information, 2, 118.
Baader, F., & Hanschke, P. (1991). A schema for integrating concrete domains into concept
languages. In Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI91),
pp. 452457.
Baader, F., & Hanschke, P. (1992). Extensions of concept languages for a mechanical engineering application. In Proc. of the 16th German Workshop on Artificial Intelligence
(GWAI92), Vol. 671 of Lecture Notes in Computer Science, pp. 132143, Bonn (Germany). Springer-Verlag.
Baader, F., & Hollunder, B. (1991). A terminological knowledge representation system with
complete inference algorithm. In Proc. of the Workshop on Processing Declarative
Knowledge (PDK91), Vol. 567 of Lecture Notes in Artificial Intelligence, pp. 6786.
Springer-Verlag.
Baader, F., & Sattler, U. (1999). Expressive number restrictions in description logics. J. of
Logic and Computation, 9 (3), 319350.
Ben-Ari, M., Halpern, J. Y., & Pnueli, A. (1982). Deterministic propositional dynamic logic:
Finite models, complexity, and completeness. J. of Computer and System Sciences,
25, 402417.
Berger, R. (1966). The undecidability of the dominoe problem. Mem. Amer. Math. Soc.,
66, 172.
Borgida, A. (1995). Description logics in data management. IEEE Trans. on Knowledge
and Data Engineering, 7 (5), 671682.
Brachman, R. J., McGuinness, D. L., Patel-Schneider, P. F., Alperin Resnick, L., & Borgida,
A. (1991). Living with CLASSIC: When and how to use a KL-ONE-like language. In
54

fiFusions of Description Logics and Abstract Description Systems

Sowa, J. F. (Ed.), Principles of Semantic Networks, pp. 401456. Morgan Kaufmann,
Los Altos.
Brachman, R. J., & Schmolze, J. G. (1985). An overview of the KL-ONE knowledge representation system. Cognitive Science, 9 (2), 171216.
Bresciani, P., Franconi, E., & Tessaris, S. (1995). Implementing and testing expressive description logics: Preliminary report. In Proc. of the 1995 Description Logic Workshop
(DL95), pp. 131139.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1999). Reasoning in expressive description
logics with fixpoints based on automata on infinite trees. In Proc. of the 16th Int.
Joint Conf. on Artificial Intelligence (IJCAI99), pp. 8489.
Calvanese, D., De Giacomo, G., & Rosati, R. (1998). A note on encoding inverse roles and
functional restrictions in ALC knowledge bases. In Proc. of the 1998 Description Logic
Workshop (DL98), pp. 6971. CEUR Electronic Workshop Proceedings, http://ceurws.org/Vol-11/.
Chellas, B. F. (1980). Modal logic. Cambridge University Press, Cambridge, UK.
Danecki, R. (1984). Nondeterministic Propositional Dynamic Logic with intersection is
decidable. In Proc. of the 5th Symp. on Computation Theory, Vol. 208 of Lecture
Notes in Computer Science, pp. 3453. Springer-Verlag.
De Giacomo, G. (1995). Decidability of Class-Based Knowledge Representation Formalisms.
Ph.D. thesis, Dipartimento di Informatica e Sistemistica, Universita di Roma La
Sapienza.
De Giacomo, G., & Lenzerini, M. (1994a). Boosting the correspondence between description
logics and propositional dynamic logics. In Proc. of the 12th Nat. Conf. on Artificial
Intelligence (AAAI94), pp. 205212. AAAI Press/The MIT Press.
De Giacomo, G., & Lenzerini, M. (1994b). Concept language with number restrictions and
fixpoints, and its relationship with -calculus. In Proc. of the 11th Eur. Conf. on
Artificial Intelligence (ECAI94), pp. 411415.
De Giacomo, G., & Lenzerini, M. (1995). Whats in an aggregate: Foundations for description logics with tuples and sets. In Proc. of the 14th Int. Joint Conf. on Artificial
Intelligence (IJCAI95), pp. 801807.
Donini, F. M., Hollunder, B., Lenzerini, M., Spaccamela, A. M., Nardi, D., & Nutt, W.
(1992). The complexity of existential quantification in concept languages. Artificial
Intelligence, 23, 309327.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991). Tractable concept languages. In
Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI91), pp. 458463,
Sydney (Australia).
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1997). The complexity of concept
languages. Information and Computation, 134, 158.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1994). Deduction in concept languages: From subsumption to instance checking. J. of Logic and Computation, 4 (4),
423452.
55

fiBaader, Lutz, Sturm, & Wolter

Dosen, K. (1988). Duality between modal algebras and neighbourhood frames. Studia
Logica, 48, 219234.
Fine, K., & Schurz, G. (1996). Transfer theorems for stratified modal logics. In Copeland,
J. (Ed.), Logic and Reality: Essays in Pure and Applied Logic. In Memory of Arthur
Prior, pp. 169213. Oxford University Press.
Fischer, M. J., & Ladner, R. E. (1979). Propositional dynamic logic of regular programs.
J. of Computer and System Sciences, 18, 194211.
Gabbay, D. M. (1999). Fibring Logics, Vol. 38 of Oxford Logic Guides. Clarendon Press,
Oxford.
Gargov, G., & Goranko, V. (1993). Modal logic with names. J. of Philosophical Logic, 22,
607636.
Goldblatt, R. I. (1989). Varieties of complex algebras. Annals of Pure and Applied Logic,
38, 173241.
Goranko, V., & Passy, S. (1992). Using the universal modality: Gains and questions. Journal
of Logic and Computation, 2 (1), 530.
Gratzer, G. (1979). Universal Algebra. Springer-Verlag, New York.
Haarslev, V., Moller, R., & Wessel, M. (2001). The description logic ALCN HR+ extended
with concrete domains: A practically motivated approach. In Proceedings of the International Joint Conference on Automated Reasoning IJCAR01, Lecture Notes in
Artificial Intelligence. Springer-Verlag.
Harel, D. (1984). Dynamic logic. In Handbook of Philosophical Logic, Vol. 2, pp. 497640.
D. Reidel, Dordrecht (Holland).
Hollunder, B., & Baader, F. (1991). Qualifying number restrictions in concept languages.
Tech. rep. RR-91-03, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI),
Kaiserslautern (Germany). An abridged version appeared in Proc. of the 2nd Int.
Conf. on the Principles of Knowledge Representation and Reasoning (KR91).
Hollunder, B., & Nutt, W. (1990). Subsumption algorithms for concept languages. Tech. rep.
RR-90-04, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Kaiserslautern (Germany).
Horrocks, I. (1998). Using an expressive description logic: FaCT or fiction?. In Proc. of the
6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR98),
pp. 636647.
Horrocks, I., & Sattler, U. (1999). A description logic with transitive and inverse roles and
role hierarchies. J. of Logic and Computation, 9 (3), 385410.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning for very expressive description logics. J. of the Interest Group in Pure and Applied Logic, 8 (3), 239264.
Jonsson, B., & Tarski, A. (1951). Boolean algebras with operators. I. American Journal of
Mathematics, 73, 891939.
Jonsson, B., & Tarski, A. (1952). Boolean algebras with operators. II. American Journal
of Mathematics, 74, 127162.
56

fiFusions of Description Logics and Abstract Description Systems

Knuth, D. E. (1973). The Art of Computer Programming, Vol. 3. Addison-Wesley, Mass.
Kracht, M., & Wolter, F. (1991). Properties of independently axiomatizable bimodal logics.
The Journal of Symbolic Logic, 56 (4), 14691485.
Kutz, O., Wolter, F., & Zakharyaschev, M. (2001). Connecting abstract description systems.
Submitted. Available from http://www.informatik.uni-leipzig.de/wolter/.
Levesque, H. J., & Brachman, R. J. (1987). Expressiveness and tractability in knowledge
representation and reasoning. Computational Intelligence, 3, 7893.
Lutz, C. (1999). Reasoning with concrete domains. In Dean, T. (Ed.), Proc. of the 16th
Int. Joint Conf. on Artificial Intelligence (IJCAI99), pp. 9095, Stockholm, Sweden.
Morgan Kaufmann, Los Altos.
Lutz, C. (2001). Interval-based temporal reasoning with general TBoxes. In Proc. of the
17th Int. Joint Conf. on Artificial Intelligence (IJCAI 2001), pp. 8994.
Lutz, C., & Sattler, U. (2000). Mary likes all cats. In Proc. of the 2000 Description
Logic Workshop (DL 2000), pp. 213226. CEUR Electronic Workshop Proceedings,
http://ceur-ws.org/Vol-33/.
Nebel, B. (1988). Computational complexity of terminological reasoning in BACK. Artificial
Intelligence, 34 (3), 371383.
Nebel, B. (1990). Terminological reasoning is inherently intractable. Artificial Intelligence,
43, 235249.
Parikh, R. (1980). Propositional logics of programs: Systems, models and complexity. In
Proc. of the 7th ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages (POPL80), pp. 186192, Las Vegas (USA).
Prior, A. N. (1967). Past, Present and Future. Oxford University Press.
Sattler, U. (1996). A concept language extended with different kinds of transitive roles. In
Gorz, G., & Holldobler, S. (Eds.), Proc. of the 20th German Annual Conf. on Artificial
Intelligence (KI96), No. 1137 in Lecture Notes in Artificial Intelligence, pp. 333345.
Springer-Verlag.
Schaerf, A. (1993). On the complexity of the instance checking problem in concept languages
with existential quantification. J. of Intelligent Information Systems, 2, 265278.
Schaerf, A. (1994). Reasoning with individuals in concept languages. Data and Knowledge
Engineering, 13 (2), 141176.
Schild, K. (1991). A correspondence theory for terminological logics: Preliminary report. In
Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI91), pp. 466471.
Schmidt-Schau, M. (1989). Subsumption in KL-ONE is undecidable. In Brachman, R. J.,
Levesque, H. J., & Reiter, R. (Eds.), Proc. of the 1st Int. Conf. on the Principles of
Knowledge Representation and Reasoning (KR89), pp. 421431. Morgan Kaufmann,
Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions with complements. Artificial Intelligence, 48 (1), 126.
57

fiBaader, Lutz, Sturm, & Wolter

Spaan, E. (1993). Complexity of Modal Logics. Ph.D. thesis, Department of Mathematics
and Computer Science, University of Amsterdam, The Netherlands.
Van der Hoek, W., & de Rijke, M. (1995). Counting objects. J. of Logic and Computation,
5 (3), 325345.
Wolter, F. (1998). Fusions of modal logics revisited. In Kracht, M., de Rijke, M., Wansing, H., & Zakharyaschev, M. (Eds.), Advances in Modal Logic, pp. 361379. CSLI
Publications.
Woods, W. A., & Schmolze, J. G. (1992). The KL-ONE family. In Lehmann, F. W. (Ed.),
Semantic Networks in Artificial Intelligence, pp. 133178. Pergamon Press. Published
as a special issue of Computers & Mathematics with Applications, Volume 23, Number
29.

58

fiJournal of Artificial Intelligence Research 16 (2002) 321357

Submitted 09/01; published 06/02

SMOTE: Synthetic Minority Over-sampling Technique
Nitesh V. Chawla

chawla@csee.usf.edu

Department of Computer Science and Engineering, ENB 118
University of South Florida
4202 E. Fowler Ave.
Tampa, FL 33620-5399, USA

Kevin W. Bowyer

kwb@cse.nd.edu

Department of Computer Science and Engineering
384 Fitzpatrick Hall
University of Notre Dame
Notre Dame, IN 46556, USA

Lawrence O. Hall

hall@csee.usf.edu

Department of Computer Science and Engineering, ENB 118
University of South Florida
4202 E. Fowler Ave.
Tampa, FL 33620-5399, USA

W. Philip Kegelmeyer

wpk@california.sandia.gov

Sandia National Laboratories
Biosystems Research Department, P.O. Box 969, MS 9951
Livermore, CA, 94551-0969, USA

Abstract
An approach to the construction of classiers from imbalanced datasets is described.
A dataset is imbalanced if the classication categories are not approximately equally represented. Often real-world data sets are predominately composed of normal examples
with only a small percentage of abnormal or interesting examples. It is also the case
that the cost of misclassifying an abnormal (interesting) example as a normal example is
often much higher than the cost of the reverse error. Under-sampling of the majority (normal) class has been proposed as a good means of increasing the sensitivity of a classier to
the minority class. This paper shows that a combination of our method of over-sampling
the minority (abnormal) class and under-sampling the majority (normal) class can achieve
better classier performance (in ROC space) than only under-sampling the majority class.
This paper also shows that a combination of our method of over-sampling the minority class
and under-sampling the majority class can achieve better classier performance (in ROC
space) than varying the loss ratios in Ripper or class priors in Naive Bayes. Our method
of over-sampling the minority class involves creating synthetic minority class examples.
Experiments are performed using C4.5, Ripper and a Naive Bayes classier. The method
is evaluated using the area under the Receiver Operating Characteristic curve (AUC) and
the ROC convex hull strategy.

1. Introduction
A dataset is imbalanced if the classes are not approximately equally represented. Imbalance
on the order of 100 to 1 is prevalent in fraud detection and imbalance of up to 100,000 to
c
2002
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiChawla, Bowyer, Hall & Kegelmeyer

1 has been reported in other applications (Provost & Fawcett, 2001). There have been
attempts to deal with imbalanced datasets in domains such as fraudulent telephone calls
(Fawcett & Provost, 1996), telecommunications management (Ezawa, Singh, & Norton,
1996), text classication (Lewis & Catlett, 1994; Dumais, Platt, Heckerman, & Sahami,
1998; Mladenic & Grobelnik, 1999; Lewis & Ringuette, 1994; Cohen, 1995a) and detection
of oil spills in satellite images (Kubat, Holte, & Matwin, 1998).
The performance of machine learning algorithms is typically evaluated using predictive
accuracy. However, this is not appropriate when the data is imbalanced and/or the costs of
dierent errors vary markedly. As an example, consider the classication of pixels in mammogram images as possibly cancerous (Woods, Doss, Bowyer, Solka, Priebe, & Kegelmeyer,
1993). A typical mammography dataset might contain 98% normal pixels and 2% abnormal
pixels. A simple default strategy of guessing the majority class would give a predictive accuracy of 98%. However, the nature of the application requires a fairly high rate of correct
detection in the minority class and allows for a small error rate in the majority class in
order to achieve this. Simple predictive accuracy is clearly not appropriate in such situations. The Receiver Operating Characteristic (ROC) curve is a standard technique for
summarizing classier performance over a range of tradeos between true positive and false
positive error rates (Swets, 1988). The Area Under the Curve (AUC) is an accepted traditional performance metric for a ROC curve (Duda, Hart, & Stork, 2001; Bradley, 1997; Lee,
2000). The ROC convex hull can also be used as a robust method of identifying potentially
optimal classiers (Provost & Fawcett, 2001). If a line passes through a point on the convex
hull, then there is no other line with the same slope passing through another point with a
larger true positive (TP) intercept. Thus, the classier at that point is optimal under any
distribution assumptions in tandem with that slope.
The machine learning community has addressed the issue of class imbalance in two ways.
One is to assign distinct costs to training examples (Pazzani, Merz, Murphy, Ali, Hume, &
Brunk, 1994; Domingos, 1999). The other is to re-sample the original dataset, either by oversampling the minority class and/or under-sampling the majority class (Kubat & Matwin,
1997; Japkowicz, 2000; Lewis & Catlett, 1994; Ling & Li, 1998). Our approach (Chawla,
Bowyer, Hall, & Kegelmeyer, 2000) blends under-sampling of the majority class with a
special form of over-sampling the minority class. Experiments with various datasets and
the C4.5 decision tree classier (Quinlan, 1992), Ripper (Cohen, 1995b), and a Naive Bayes
Classier show that our approach improves over other previous re-sampling, modifying loss
ratio, and class priors approaches, using either the AUC or ROC convex hull.
Section 2 gives an overview of performance measures. Section 3 reviews the most
closely related work dealing with imbalanced datasets. Section 4 presents the details of
our approach. Section 5 presents experimental results comparing our approach to other
re-sampling approaches. Section 6 discusses the results and suggests directions for future
work.

2. Performance Measures
The performance of machine learning algorithms is typically evaluated by a confusion matrix
as illustrated in Figure 1 (for a 2 class problem). The columns are the Predicted class and the
rows are the Actual class. In the confusion matrix, T N is the number of negative examples
322

fiSMOTE

Predicted
Negative

Predicted
Positive

Actual
Negative

TN

FP

Actual
Positive

FN

TP

Figure 1: Confusion Matrix
correctly classied (True Negatives), F P is the number of negative examples incorrectly
classied as positive (False Positives), F N is the number of positive examples incorrectly
classied as negative (False Negatives) and T P is the number of positive examples correctly
classied (True Positives).
Predictive accuracy is the performance measure generally associated with machine learning algorithms and is dened as Accuracy = (T P + T N )/(T P + F P + T N + F N ). In the
context of balanced datasets and equal error costs, it is reasonable to use error rate as a
performance metric. Error rate is 1  Accuracy. In the presence of imbalanced datasets
with unequal error costs, it is more appropriate to use the ROC curve or other similar
techniques (Ling & Li, 1998; Drummond & Holte, 2000; Provost & Fawcett, 2001; Bradley,
1997; Turney, 1996).
ROC curves can be thought of as representing the family of best decision boundaries for
relative costs of TP and FP. On an ROC curve the X-axis represents %F P = F P/(T N +F P )
and the Y-axis represents %T P = T P/(T P +F N ). The ideal point on the ROC curve would
be (0,100), that is all positive examples are classied correctly and no negative examples are
misclassied as positive. One way an ROC curve can be swept out is by manipulating the
balance of training samples for each class in the training set. Figure 2 shows an illustration.
The line y = x represents the scenario of randomly guessing the class. Area Under the ROC
Curve (AUC) is a useful metric for classier performance as it is independent of the decision
criterion selected and prior probabilities. The AUC comparison can establish a dominance
relationship between classiers. If the ROC curves are intersecting, the total AUC is an
average comparison between models (Lee, 2000). However, for some specic cost and class
distributions, the classier having maximum AUC may in fact be suboptimal. Hence, we
also compute the ROC convex hulls, since the points lying on the ROC convex hull are
potentially optimal (Provost, Fawcett, & Kohavi, 1998; Provost & Fawcett, 2001).

3. Previous Work: Imbalanced datasets
Kubat and Matwin (1997) selectively under-sampled the majority class while keeping the
original population of the minority class. They have used the geometric mean as a performance measure for the classier, which can be related to a single point on the ROC curve.
The minority examples were divided into four categories: some noise overlapping the positive class decision region, borderline samples, redundant samples and safe samples. The
borderline examples were detected using the Tomek links concept (Tomek, 1976). Another
323

fiChawla, Bowyer, Hall & Kegelmeyer

ROC

(100, 100)

100
Ideal point

Percent
True

y=x

Positive
increased undersampling
of the majority class moves
the operating point to the
upper right
original data set

0

Percent False Positive

100

Figure 2: Illustration of sweeping out a ROC curve through under-sampling. Increased
under-sampling of the majority (negative) class will move the performance from
the lower left point to the upper right.

related work proposed the SHRINK system that classies an overlapping region of minority (positive) and majority (negative) classes as positive; it searches for the best positive
region (Kubat et al., 1998).
Japkowicz (2000) discussed the eect of imbalance in a dataset. She evaluated three
strategies: under-sampling, resampling and a recognition-based induction scheme. We focus
on her sampling approaches. She experimented on articial 1D data in order to easily
measure and construct concept complexity. Two resampling methods were considered.
Random resampling consisted of resampling the smaller class at random until it consisted
of as many samples as the majority class and focused resampling consisted of resampling
only those minority examples that occurred on the boundary between the minority and
majority classes. Random under-sampling was considered, which involved under-sampling
the majority class samples at random until their numbers matched the number of minority
class samples; focused under-sampling involved under-sampling the majority class samples
lying further away. She noted that both the sampling approaches were eective, and she also
observed that using the sophisticated sampling techniques did not give any clear advantage
in the domain considered (Japkowicz, 2000).
One approach that is particularly relevant to our work is that of Ling and Li (1998).
They combined over-sampling of the minority class with under-sampling of the majority
class. They used lift analysis instead of accuracy to measure a classiers performance. They
proposed that the test examples be ranked by a condence measure and then lift be used as
the evaluation criteria. A lift curve is similar to an ROC curve, but is more tailored for the
324

fiSMOTE

marketing analysis problem (Ling & Li, 1998). In one experiment, they under-sampled the
majority class and noted that the best lift index is obtained when the classes are equally
represented (Ling & Li, 1998). In another experiment, they over-sampled the positive
(minority) examples with replacement to match the number of negative (majority) examples
to the number of positive examples. The over-sampling and under-sampling combination
did not provide signicant improvement in the lift index. However, our approach to oversampling diers from theirs.
Solberg and Solberg (1996) considered the problem of imbalanced data sets in oil slick
classication from SAR imagery. They used over-sampling and under-sampling techniques
to improve the classication of oil slicks. Their training data had a distribution of 42 oil
slicks and 2,471 look-alikes, giving a prior probability of 0.98 for look-alikes. This imbalance
would lead the learner (without any appropriate loss functions or a methodology to modify
priors) to classify almost all look-alikes correctly at the expense of misclassifying many of
the oil slick samples (Solberg & Solberg, 1996). To overcome this imbalance problem, they
over-sampled (with replacement) 100 samples from the oil slick, and they randomly sampled
100 samples from the non oil slick class to create a new dataset with equal probabilities.
They learned a classier tree on this balanced data set and achieved a 14% error rate on the
oil slicks in a leave-one-out method for error estimation; on the look alikes they achieved
an error rate of 4% (Solberg & Solberg, 1996).
Another approach that is similar to our work is that of Domingos (1999). He compares
the metacost approach to each of majority under-sampling and minority over-sampling.
He nds that metacost improves over either, and that under-sampling is preferable to minority over-sampling. Error-based classiers are made cost-sensitive. The probability of
each class for each example is estimated, and the examples are relabeled optimally with
respect to the misclassication costs. The relabeling of the examples expands the decision
space as it creates new samples from which the classier may learn (Domingos, 1999).
A feed-forward neural network trained on an imbalanced dataset may not learn to discriminate enough between classes (DeRouin, Brown, Fausett, & Schneider, 1991). The
authors proposed that the learning rate of the neural network be adapted to the statistics
of class representation in the data. They calculated an attention factor from the proportion
of samples presented to the neural network for training. The learning rate of the network
elements was adjusted based on the attention factor. They experimented on an articially
generated training set and on a real-world training set, both with multiple (more than two)
classes. They compared this to the approach of replicating the minority class samples to
balance the data set used for training. The classication accuracy on the minority class was
improved.
Lewis and Catlett (1994) examined heterogeneous uncertainty sampling for supervised
learning. This method is useful for training samples with uncertain classes. The training
samples are labeled incrementally in two phases and the uncertain instances are passed on
to the next phase. They modied C4.5 to include a loss ratio for determining the class
values at the leaves. The class values were determined by comparison with a probability
threshold of LR/(LR + 1), where LR is the loss ratio (Lewis & Catlett, 1994).
The information retrieval (IR) domain (Dumais et al., 1998; Mladenic & Grobelnik,
1999; Lewis & Ringuette, 1994; Cohen, 1995a) also faces the problem of class imbalance
in the dataset. A document or web page is converted into a bag-of-words representation;
325

fiChawla, Bowyer, Hall & Kegelmeyer

that is, a feature vector reecting occurrences of words in the page is constructed. Usually,
there are very few instances of the interesting category in text categorization. This overrepresentation of the negative class in information retrieval problems can cause problems
in evaluating classiers performances. Since error rate is not a good metric for skewed
datasets, the classication performance of algorithms in information retrieval is usually
measured by precision and recall:
recall =

TP
TP + FN

precision =

TP
TP + FP

Mladenic and Grobelnik (1999) proposed a feature subset selection approach to deal
with imbalanced class distribution in the IR domain. They experimented with various
feature selection methods, and found that the odds ratio (van Rijsbergen, Harper, & Porter,
1981) when combined with a Naive Bayes classier performs best in their domain. Odds
ratio is a probabilistic measure used to rank documents according to their relevance to the
positive class (minority class). Information gain for a word, on the other hand, does not
pay attention to a particular target class; it is computed per word for each class. In an
imbalanced text dataset (assuming 98 to 99% is the negative class), most of the features will
be associated with the negative class. Odds ratio incorporates the target class information in
its metric giving better results when compared to information gain for text categorization.
Provost and Fawcett (1997) introduced the ROC convex hull method to estimate the
classier performance for imbalanced datasets. They note that the problems of unequal
class distribution and unequal error costs are related and that little work has been done to
address either problem (Provost & Fawcett, 2001). In the ROC convex hull method, the
ROC space is used to separate classication performance from the class and cost distribution
information.
To summarize the literature, under-sampling the majority class enables better classiers
to be built than over-sampling the minority class. A combination of the two as done in
previous work does not lead to classiers that outperform those built utilizing only undersampling. However, the over-sampling of the minority class has been done by sampling with
replacement from the original data. Our approach uses a dierent method of over-sampling.

4. SMOTE: Synthetic Minority Over-sampling TEchnique
4.1 Minority over-sampling with replacement
Previous research (Ling & Li, 1998; Japkowicz, 2000) has discussed over-sampling with
replacement and has noted that it doesnt signicantly improve minority class recognition.
We interpret the underlying eect in terms of decision regions in feature space. Essentially,
as the minority class is over-sampled by increasing amounts, the eect is to identify similar
but more specic regions in the feature space as the decision region for the minority class.
This eect for decision trees can be understood from the plots in Figure 3.
326

fiSMOTE

2attributes, 10% data of the original Mammography dataset

2attributes, 10% data of the original Mammography dataset
450

200

400

350

150

Attribute 2

Attribute 2

300

250

200

100

150

100

50

50

0

0

2

4

6

8

10

12

14

0

16

1

2

3

4

Attribute 1

5

6

7

8

Attribute 1

(a)

(b)

2attributes, 10% data of the original Mammography dataset
200

Attribute 2

150

100

50

0

1

2

3

4

5

Attribute 1

6

7

8

(c)
Figure 3: a) Decision region in which the three minority class samples (shown by +) reside
after building a decision tree. This decision region is indicated by the solid-line
rectangle. b) A zoomed-in view of the chosen minority class samples for the same
dataset. Small solid-line rectangles show the decision regions as a result of oversampling the minority class with replication. c) A zoomed-in view of the chosen
minority class samples for the same dataset. Dashed lines show the decision region
after over-sampling the minority class with synthetic generation.

327

fiChawla, Bowyer, Hall & Kegelmeyer

The data for the plot in Figure 3 was extracted from a Mammography dataset1 (Woods
et al., 1993). The minority class samples are shown by + and the majority class samples
are shown by o in the plot. In Figure 3(a), the region indicated by the solid-line rectangle
is a majority class decision region. Nevertheless, it contains three minority class samples
shown by + as false negatives. If we replicate the minority class, the decision region for the
minority class becomes very specic and will cause new splits in the decision tree. This will
lead to more terminal nodes (leaves) as the learning algorithm tries to learn more and more
specic regions of the minority class; in essence, overtting. Replication of the minority
class does not cause its decision boundary to spread into the majority class region. Thus,
in Figure 3(b), the three samples previously in the majority class decision region now have
very specic decision regions.
4.2 SMOTE
We propose an over-sampling approach in which the minority class is over-sampled by creating synthetic examples rather than by over-sampling with replacement. This approach
is inspired by a technique that proved successful in handwritten character recognition (Ha
& Bunke, 1997). They created extra training data by performing certain operations on
real data. In their case, operations like rotation and skew were natural ways to perturb
the training data. We generate synthetic examples in a less application-specic manner, by
operating in feature space rather than data space. The minority class is over-sampled
by taking each minority class sample and introducing synthetic examples along the line
segments joining any/all of the k minority class nearest neighbors. Depending upon the
amount of over-sampling required, neighbors from the k nearest neighbors are randomly
chosen. Our implementation currently uses ve nearest neighbors. For instance, if the
amount of over-sampling needed is 200%, only two neighbors from the ve nearest neighbors are chosen and one sample is generated in the direction of each. Synthetic samples
are generated in the following way: Take the dierence between the feature vector (sample)
under consideration and its nearest neighbor. Multiply this dierence by a random number
between 0 and 1, and add it to the feature vector under consideration. This causes the
selection of a random point along the line segment between two specic features. This
approach eectively forces the decision region of the minority class to become more general.
Algorithm SMOTE , on the next page, is the pseudo-code for SMOTE. Table 4.2 shows
an example of calculation of random synthetic samples. The amount of over-sampling
is a parameter of the system, and a series of ROC curves can be generated for dierent
populations and ROC analysis performed.
The synthetic examples cause the classier to create larger and less specic decision
regions as shown by the dashed lines in Figure 3(c), rather than smaller and more specic
regions. More general regions are now learned for the minority class samples rather than
those being subsumed by the majority class samples around them. The eect is that decision trees generalize better. Figures 4 and 5 compare the minority over-sampling with
replacement and SMOTE. The experiments were conducted on the mammography dataset.
There were 10923 examples in the majority class and 260 examples in the minority class
originally. We have approximately 9831 examples in the majority class and 233 examples
1. The data is available from the USF Intelligent Systems Lab, http://morden.csee.usf.edu/chawla.

328

fiSMOTE

in the minority class for the training set used in 10-fold cross-validation. The minority class
was over-sampled at 100%, 200%, 300%, 400% and 500% of its original size. The graphs
show that the tree sizes for minority over-sampling with replacement at higher degrees of
replication are much greater than those for SMOTE, and the minority class recognition of
the minority over-sampling with replacement technique at higher degrees of replication isnt
as good as SMOTE.
Algorithm SMOTE (T, N, k)
Input: Number of minority class samples T ; Amount of SMOTE N %; Number of nearest
neighbors k
Output: (N/100) * T synthetic minority class samples
1. ( If N is less than 100%, randomize the minority class samples as only a random
percent of them will be SMOTEd. )
2. if N < 100
3.
then Randomize the T minority class samples
4.
T = (N/100)  T
5.
N = 100
6. endif
7. N = (int)(N/100) ( The amount of SMOTE is assumed to be in integral multiples of
100. )
8. k = Number of nearest neighbors
9. numattrs = Number of attributes
10. Sample[ ][ ]: array for original minority class samples
11. newindex: keeps a count of number of synthetic samples generated, initialized to 0
12. Synthetic[ ][ ]: array for synthetic samples
( Compute k nearest neighbors for each minority class sample only. )
13. for i  1 to T
14.
Compute k nearest neighbors for i, and save the indices in the nnarray
15.
Populate(N , i, nnarray)
16. endfor
Populate(N, i, nnarray) ( Function to generate the synthetic samples. )
17. while N = 0
18.
Choose a random number between 1 and k, call it nn. This step chooses one of
the k nearest neighbors of i.
19.
for attr  1 to numattrs
20.
Compute: dif = Sample[nnarray[nn]][attr]  Sample[i][attr]
21.
Compute: gap = random number between 0 and 1
22.
Synthetic[newindex][attr] = Sample[i][attr] + gap  dif
23.
endfor
24.
newindex++
25.
N = N 1
26. endwhile
27. return ( End of Populate. )
End of Pseudo-Code.

329

fiChawla, Bowyer, Hall & Kegelmeyer

Consider a sample (6,4) and let (4,3) be its nearest neighbor.
(6,4) is the sample for which k-nearest neighbors are being identied.
(4,3) is one of its k-nearest neighbors.
Let:
f1 1 = 6 f2 1 = 4 f2 1 - f1 1 = -2
f1 2 = 4 f2 2 = 3 f2 2 - f1 2 = -1
The new samples will be generated as
(f1,f2) = (6,4) + rand(0-1) * (-2,-1)
rand(0-1) generates a random number between 0 and 1.
Table 1: Example of generation of synthetic examples (SMOTE).

Pruned decision tree size vs the degree of minority oversampling
260

240

Decisiion tree size (Number of nodes)

220

200

180

160

140
Synthetic data
Replicated data
120

100

80

60

0

50

100

150

200
250
300
350
Degree of minority oversampling

400

450

500

Figure 4: Comparison of decision tree sizes for replicated over-sampling and SMOTE for
the Mammography dataset

330

fiSMOTE

% Minority Correct vs the Degree of Minority Oversampling
75

%Minority Correct

70

65

60

Synthetic data
Replicated data

55

50
0

50

100

150

200

250

300

350

400

450

500

Degree of Minority Oversampling

Figure 5: Comparison of % Minority correct for replicated over-sampling and SMOTE for
the Mammography dataset

4.3 Under-sampling and SMOTE Combination
The majority class is under-sampled by randomly removing samples from the majority class
population until the minority class becomes some specied percentage of the majority class.
This forces the learner to experience varying degrees of under-sampling and at higher degrees
of under-sampling the minority class has a larger presence in the training set. In describing
our experiments, our terminology will be such that if we under-sample the majority class at
200%, it would mean that the modied dataset will contain twice as many elements from the
minority class as from the majority class; that is, if the minority class had 50 samples and
the majority class had 200 samples and we under-sample majority at 200%, the majority
class would end up having 25 samples. By applying a combination of under-sampling and
over-sampling, the initial bias of the learner towards the negative (majority) class is reversed
in the favor of the positive (minority) class. Classiers are learned on the dataset perturbed
by SMOTING the minority class and under-sampling the majority class.

5. Experiments
We used three dierent machine learning algorithms for our experiments. Figure 6 provides
an overview of our experiments.
1. C4.5: We compared various combinations of SMOTE and under-sampling with plain
under-sampling using C4.5 release 8 (Quinlan, 1992) as the base classier.
331

fiChawla, Bowyer, Hall & Kegelmeyer

SMOTE
and Undersampling.

C4.5

Loss-Ratio
Modify costs of majority and minority
varied from 0.9 to 0.001.
classes by changing priors.

Ripper

Naive Bayes

ROCs generated for SMOTE, Undersampling
and Loss Ratio comparisons. Performance
evaluated with AUC and ROC convex hull.

ROCs generated for comparison between
SMOTE and Under-sampling using C4.5, and
SMOTE using C4.5 and Naive bayes.
Performance evaluated with AUC and ROC convex hull.

Figure 6: Experiments Overview

2. Ripper: We compared various combinations of SMOTE and under-sampling with
plain under-sampling using Ripper (Cohen, 1995b) as the base classier. We also
varied Rippers loss ratio (Cohen & Singer, 1996; Lewis & Catlett, 1994) from 0.9 to
0.001 (as a means of varying misclassication cost) and compared the eect of this
variation with the combination of SMOTE and under-sampling. By reducing the loss
ratio from 0.9 to 0.001 we were able to build a set of rules for the minority class.
3. Naive Bayes Classifier: The Naive Bayes Classier2 can be made cost-sensitive
by varying the priors of the minority class. We varied the priors of the minority
class from 1 to 50 times the majority class and compared with C4.5s SMOTE and
under-sampling combination.

These dierent learning algorithms allowed SMOTE to be compared to some methods
that can handle misclassication costs directly. %FP and %TP were averaged over 10-fold
cross-validation runs for each of the data combinations. The minority class examples were
over-sampled by calculating the ve nearest neighbors and generating synthetic examples.
The AUC was calculated using the trapezoidal rule. We extrapolated an extra point of TP
= 100% and FP = 100% for each ROC curve. We also computed the ROC convex hull
to identify the optimal classiers, as the points lying on the hull are potentially optimal
classiers (Provost & Fawcett, 2001).
2. The source code was downloaded from http://fuzzy.cs.uni-magdeburg.de/borgelt/software.html.

332

fiSMOTE

5.1 Datasets
We experimented on nine dierent datasets. These datasets are summarized in Table 5.2.
These datasets vary extensively in their size and class proportions, thus oering dierent
domains for SMOTE. In order of increasing imbalance they are:
1. The Pima Indian Diabetes (Blake & Merz, 1998) has 2 classes and 768 samples. The
data is used to identify the positive diabetes cases in a population near Phoenix,
Arizona. The number of positive class samples is only 268. Good sensitivity to
detection of diabetes cases will be a desirable attribute of the classier.
2. The Phoneme dataset is from the ELENA project3 . The aim of the dataset is to
distinguish between nasal (class 0) and oral sounds (class 1). There are 5 features.
The class distribution is 3,818 samples in class 0 and 1,586 samples in class 1.
3. The Adult dataset (Blake & Merz, 1998) has 48,842 samples with 11,687 samples
belonging to the minority class. This dataset has 6 continuous features and 8 nominal
features. SMOTE and SMOTE-NC (see Section 6.1) algorithms were evaluated on
this dataset. For SMOTE, we extracted the continuous features and generated a new
dataset with only continuous features.
4. The E-state data4 (Hall, Mohney, & Kier, 1991) consists of electrotopological state
descriptors for a series of compounds from the National Cancer Institutes Yeast AntiCancer drug screen. E-state descriptors from the NCI Yeast AntiCancer Drug Screen
were generated by Tripos, Inc. Briey, a series of about 60,000 compounds were
tested against a series of 6 yeast strains at a given concentration. The test was a
high-throughput screen at only one concentration so the results are subject to contamination, etc. The growth inhibition of the yeast strain when exposed to the given
compound (with respect to growth of the yeast in a neutral solvent) was measured.
The activity classes are either active  at least one single yeast strain was inhibited
more than 70%, or inactive  no yeast strain was inhibited more than 70%. The
dataset has 53,220 samples with 6,351 samples of active compounds.
5. The Satimage dataset (Blake & Merz, 1998) has 6 classes originally. We chose the
smallest class as the minority class and collapsed the rest of the classes into one as
was done in (Provost et al., 1998). This gave us a skewed 2-class dataset, with 5809
majority class samples and 626 minority class samples.
6. The Forest Cover dataset is from the UCI repository (Blake & Merz, 1998). This
dataset has 7 classes and 581,012 samples. This dataset is for the prediction of forest
cover type based on cartographic variables. Since our system currently works for binary classes we extracted data for two classes from this dataset and ignored the rest.
Most other approaches only work for only two classes (Ling & Li, 1998; Japkowicz,
2000; Kubat & Matwin, 1997; Provost & Fawcett, 2001). The two classes we considered are Ponderosa Pine with 35,754 samples and Cottonwood/Willow with 2,747
3. ftp.dice.ucl.ac.be in the directory pub/neural-nets/ELENA/databases.
4. We would like to thank Steven Eschrich for providing the dataset and description to us.

333

fiChawla, Bowyer, Hall & Kegelmeyer

Dataset
Pima
Phoneme
Adult
E-state
Satimage
Forest Cover
Oil
Mammography
Can

Majority Class
500
3818
37155
46869
5809
35754
896
10923
435512

Minority Class
268
1586
11687
6351
626
2747
41
260
8360

Table 2: Dataset distribution
samples. Nevertheless, the SMOTE technique can be applied to a multiple class problem as well by specifying what class to SMOTE for. However, in this paper, we have
focused on 2-classes problems, to explicitly represent positive and negative classes.
7. The Oil dataset was provided by Robert Holte and is used in their paper (Kubat et al.,
1998). This dataset has 41 oil slick samples and 896 non-oil slick samples.
8. The Mammography dataset (Woods et al., 1993) has 11,183 samples with 260 calcications. If we look at predictive accuracy as a measure of goodness of the classier
for this case, the default accuracy would be 97.68% when every sample is labeled noncalcication. But, it is desirable for the classier to predict most of the calcications
correctly.
9. The Can dataset was generated from the Can ExodusII data using the AVATAR
(Chawla & Hall, 1999) version of the Mustafa Visualization tool5 . The portion of
the can being crushed was marked as very interesting and the rest of the can was
marked as unknown. A dataset of size 443,872 samples with 8,360 samples marked
as very interesting was generated.
5.2 ROC Creation
A ROC curve for SMOTE is produced by using C4.5 or Ripper to create a classier for
each one of a series of modied training datasets. A given ROC curve is produced by rst
over-sampling the minority class to a specied degree and then under-sampling the majority
class at increasing degrees to generate the successive points on the curve. The amount of
under-sampling is identical to plain under-sampling. So, each corresponding point on each
ROC curve for a dataset represents the same number of majority class samples. Dierent
ROC curves are produced by starting with dierent levels of minority over-sampling. ROC
curves were also generated by varying the loss ratio in Ripper from 0.9 to 0.001 and by
varying the priors of the minority class from the original distribution to up to 50 times the
majority class for a Naive Bayes Classier.
5. The Mustafa visualization tool was developed by Mike Glass of Sandia National Labs.

334

fiSMOTE

Phoneme ROC
100

95

90

85

%TP

UnderC4.5
200 SMOTEC4.5
Naive Bayes
Hull

80

75

70

65
10

20

30

40

50

60

70

80

90

100

%FP

Figure 7: Phoneme. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes. SMOTEC4.5 dominates over Naive Bayes and Under-C4.5 in the ROC space. SMOTEC4.5 classiers are potentially optimal classiers.

Figures 9 through 23 show the experimental ROC curves obtained for the nine datasets
with the three classiers. The ROC curve for plain under-sampling of the majority class
(Ling & Li, 1998; Japkowicz, 2000; Kubat & Matwin, 1997; Provost & Fawcett, 2001) is
compared with our approach of combining synthetic minority class over-sampling (SMOTE)
with majority class under-sampling. The plain under-sampling curve is labeled Under,
and the SMOTE and under-sampling combination ROC curve is labeled SMOTE. Depending on the size and relative imbalance of the dataset, one to ve SMOTE and undersampling curves are created. We only show the best results from SMOTE combined with
under-sampling and the plain under-sampling curve in the graphs. The SMOTE ROC curve
from C4.5 is also compared with the ROC curve obtained from varying the priors of minority
class using a Naive Bayes classier  labeled as Naive Bayes. SMOTE, Under, and
Loss Ratio ROC curves, generated using Ripper are also compared. For a given family
of ROC curves, an ROC convex hull (Provost & Fawcett, 2001) is generated. The ROC
convex hull is generated using the Grahams algorithm (ORourke, 1998). For reference, we
show the ROC curve that would be obtained using minority over-sampling by replication
in Figure 19.
Each point on the ROC curve is the result of either a classier (C4.5 or Ripper) learned
for a particular combination of under-sampling and SMOTE, a classier (C4.5 or Ripper)
learned with plain under-sampling, or a classier (Ripper) learned using some loss ratio or
a classier (Naive Bayes) learned for a dierent prior for the minority class. Each point
represents the average (%TP and %FP) 10-fold cross-validation result. The lower leftmost
point for a given ROC curve is from the raw dataset, without any majority class under335

fiChawla, Bowyer, Hall & Kegelmeyer

Phoneme ROC with Ripper
100

95

%TP

90

85

UnderRipper
200 SMOTERipper
Loss Ratio
Hull

80

75

70

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 8: Phoneme. Comparison of SMOTE-Ripper, Under-Ripper, and modifying Loss
Ratio in Ripper. SMOTE-Ripper dominates over Under-Ripper and Loss Ratio
in the ROC space. More SMOTE-Ripper classiers lie on the ROC convex hull.

Pima ROC
100

95

90

85

%TP

80

75

UnderC4.5
100 SMOTEC4.5
Naive Bayes
Hull

70

65

60

55

50
10

20

30

40

50

60

70

80

90

100

%FP

Figure 9: Pima Indians Diabetes. Comparison of SMOTE-C4.5, Under-C4.5, and Naive
Bayes. Naive Bayes dominates over SMOTE-C4.5 in the ROC space.

336

fiSMOTE

Pima ROC with Ripper
100

95

90

85

%TP

80
UnderRipper
100 SMOTERipper
Loss Ratio
Hull

75

70

65

60

55
10

20

30

40

50

60

70

80

90

100

%FP

Figure 10: Pima Indians Diabetes. Comparison of SMOTE-Ripper, Under-Ripper, and
modifying Loss Ratio in Ripper. SMOTE-Ripper dominates over Under-Ripper
and Loss Ratio in the ROC space.

sampling or minority class over-sampling. The minority class was over-sampled at 50%,
100%, 200%, 300%, 400%, 500%. The majority class was under-sampled at 10%, 15%,
25%, 50%, 75%, 100%, 125%, 150%, 175%, 200%, 300%, 400%, 500%, 600%, 700%, 800%,
1000%, and 2000%. The amount of majority class under-sampling and minority class oversampling depended on the dataset size and class proportions. For instance, consider the
ROC curves in Figure 17 for the mammography dataset. There are three curves  one for
plain majority class under-sampling in which the range of under-sampling is varied between
5% and 2000% at dierent intervals, one for a combination of SMOTE and majority class
under-sampling, and one for Naive Bayes  and one ROC convex hull curve. The ROC
curve shown in Figure 17 is for the minority class over-sampled at 400%. Each point on
the SMOTE ROC curves represents a combination of (synthetic) over-sampling and undersampling, the amount of under-sampling follows the same range as for plain under-sampling.
For a better understanding of the ROC graphs, we have shown dierent sets of ROC curves
for one of our datasets in Appendix A.
For the Can dataset, we had to SMOTE to a lesser degree than for the other datasets
due to the structural nature of the dataset. For the Can dataset there is a structural
neighborhood already established in the mesh geometry, so SMOTE can lead to creating
neighbors which are under the surface (and hence not interesting), since we are looking at
the feature space of physics variables and not the structural information.
The ROC curves show a trend that as we increase the amount of under-sampling coupled
with over-sampling, our minority classication accuracy increases, of course at the expense
of more majority class errors. For almost all the ROC curves, the SMOTE approach dom337

fiChawla, Bowyer, Hall & Kegelmeyer

Satimage ROC
100

95

90

85
UnderC4.5
200 SMOTEC4.5
Naive Bayes
Hull

%TP

80

75

70

65

60

55

50

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 11: Satimage. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes. The
ROC curves of Naive Bayes and SMOTE-C4.5 show an overlap; however, at
higher TPs more points from SMOTE-C4.5 lie on the ROC convex hull.

Satimage ROC with Ripper
100

95

90

85

%TP

80
UnderRipper
300 SMOTERipper
Loss Ratio
Hull

75

70

65

60

55

50

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 12: Satimage. Comparison of SMOTE-Ripper, Under-Ripper, and modifying Loss
Ratio in Ripper. SMOTE-Ripper dominates the ROC space. The ROC convex
hull is mostly constructed with points from SMOTE-Ripper.

338

fiSMOTE

Covtype ROC
100

90

80

70

%TP

60
UnderC4.5
300 SMOTEC4.5
Naive Bayes
Hull

50

40

30

20

10

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 13: Forest Cover. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes.
SMOTE-C4.5 and Under-C4.5 ROC curves are very close to each other. However, more points from the SMOTE-C4.5 ROC curve lie on the ROC convex
hull, thus establishing a dominance.

inates. Adhering to the denition of ROC convex hull, most of the potentially optimal
classiers are the ones generated with SMOTE.
5.3 AUC Calculation
The Area Under the ROC curve (AUC) is calculated using a form of the trapezoid rule. The
lower leftmost point for a given ROC curve is a classiers performance on the raw data.
The upper rightmost point is always (100%, 100%). If the curve does not naturally end at
this point, the point is added. This is necessary in order for the AUCs to be compared
over the same range of %FP.
The AUCs listed in Table 5.3 show that for all datasets the combined synthetic minority over-sampling and majority over-sampling is able to improve over plain majority
under-sampling with C4.5 as the base classier. Thus, our SMOTE approach provides
an improvement in correct classication of data in the underrepresented class. The same
conclusion holds from an examination of the ROC convex hulls. Some of the entries are
missing in the table, as SMOTE was not applied at the same amounts to all datasets. The
amount of SMOTE was less for less skewed datasets. Also, we have not included AUCs
for Ripper/Naive Bayes. The ROC convex hull identies SMOTE classiers to be potentially optimal as compared to plain under-sampling or other treatments of misclassication
costs, generally. Exceptions are as follows: for the Pima dataset, Naive Bayes dominates
over SMOTE-C4.5; for the Oil dataset, Under-Ripper dominates over SMOTE-Ripper. For
the Can dataset, SMOTE-classifier (classifier = C4.5 or Ripper) and Under-classifier ROC
339

fiChawla, Bowyer, Hall & Kegelmeyer

Covtype ROC with RIPPER
100

98

96

%TP

94
UnderRipper
100 SMOTERipper
Loss Ratio
Hull

92

90

88

86

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 14: Forest Cover. Comparison of SMOTE-Ripper, Under-Ripper, and modifying
Loss Ratio in Ripper. SMOTE-Ripper shows a domination in the ROC space.
More points from SMOTE-Ripper curve lie on the ROC convex hull.

Oil ROC
100

90

80

70

%TP

60

50

40
UnderC4.5
500 SMOTEC4.5
Naive Bayes
Hull

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 15: Oil. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes. Although,
SMOTE-C4.5 and Under-C4.5 ROC curves intersect at points, more points from
SMOTE-C4.5 curve lie on the ROC convex hull.

340

fiSMOTE

Oil ROC with Ripper
100

90

80

%TP

70
UnderRipper
300 SMOTERipper
Loss Ratio
Hull

60

50

40

30

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 16: Oil. Comparison of SMOTE-Ripper, Under-Ripper, and modifying Loss Ratio
in Ripper. Under-Ripper and SMOTE-Ripper curves intersect, and more points
from the Under-Ripper curve lie on the ROC convex hull.

Mammography ROC
100

90

80

70
UnderC4.5
400 SMOTEC4.5
Naive Bayes
Hull

%TP

60

50

40

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 17: Mammography. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes.
SMOTE-C4.5 and Under-C4.5 curves intersect in the ROC space; however, by
virtue of number of points on the ROC convex hull, SMOTE-C4.5 has more
potentially optimal classiers.

341

fiChawla, Bowyer, Hall & Kegelmeyer

Mammography ROC with RIPPER
100

95

90

85

%TP

80
UnderRipper
400 SMOTERipper
Loss Ratio
Hull

75

70

65

60

55

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 18: Mammography. Comparison of SMOTE-Ripper, Under-Ripper, and modifying
Loss Ratio in Ripper. SMOTE-Ripper dominates the ROC space for TP > 75%.
Mammography ROC with C4.5
100

95

90

85

%TP

80

75

70
400 SMOTE
400 Replicate
Hull

65

60

55

50

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 19: A comparison of over-sampling minority class examples by SMOTE and oversampling the minority class examples by replication for the Mammography
dataset.

342

fiSMOTE

Estate ROC
100

90

80

70

%TP

60

50

40
UnderC4.5
500 SMOTEC4.5
Naive Bayes
Hull

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 20: E-state. (a) Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes.
SMOTE-C4.5 and Under-C4.5 curves intersect in the ROC space; however,
SMOTE-C4.5 has more potentially optimal classiers, based on the number
of points on the ROC convex hull.

Estate ROC with Ripper
100

90

80

70

%TP

60

50

40
UnderRipper
100 SMOTERipper
Loss Ratio
Hull

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 21: E-state. Comparison of SMOTE-Ripper, Under-Ripper, and modifying Loss
Ratio in Ripper. SMOTE-Ripper has more potentially optimal classiers, based
on the number of points on the ROC convex hull.

343

fiChawla, Bowyer, Hall & Kegelmeyer

Can ROC
100

90

80

70

%TP

60

50

40

UnderC4.5
100 SMOTEC4.5
Naive Bayes
Hull

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 22: Can. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes. SMOTEC4.5 and Under-C4.5 ROC curves overlap for most of the ROC space.

Can ROC with Ripper
100

90

80

70

%TP

60

50

40

UnderRipper
50 SMOTERipper
Loss Ratio
Hull

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 23: Can. Comparison of SMOTE-Ripper, Under-Ripper, and modifying Loss Ratio
in Ripper. SMOTE-Ripper and Under-Ripper ROC curves overlap for most of
the ROC space.

344

fiSMOTE

Dataset

Under

Pima
Phoneme
Satimage
Forest Cover
Oil
Mammography
E-state
Can

7242
8622
8900
9807
8524
9260
6811
9535

50
SMOTE

9560

100
SMOTE
7307
8644
8957
9832
8523
9250
6792
9505

200
SMOTE

300
SMOTE

400
SMOTE

500
SMOTE

8661
8979
9834
8368
9265
6828
9505

8963
9849
8161
9311
6784
9494

8975
9841
8339
9330
6788
9472

8960
9842
8537
9304
6779
9470

Table 3: AUCs [C4.5 as the base classier] with the best highlighted in bold.

curves overlap in the ROC space. For all the other datasets, SMOTE-classifier has more
potentially optimal classiers than any other approach.
5.4 Additional comparison to changing the decision thresholds
Provost (2000) suggested that simply changing the decision threshold should always be
considered as an alternative to more sophisticated approaches. In the case of C4.5, this
would mean changing the decision threshold at the leaves of the decision trees. For example,
a leaf could classify examples as the minority class even if more than 50% of the training
examples at the leaf represent the majority class. We experimented by setting the decision
thresholds at the leaves for the C4.5 decision tree learner at 0.5, 0.45, 0.42, 0.4, 0.35, 0.32,
0.3, 0.27, 0.25, 0.22, 0.2, 0.17, 0.15, 0.12, 0.1, 0.05, 0.0. We experimented on the Phoneme
dataset. Figure 24 shows the comparison of the SMOTE and under-sampling combination
against C4.5 learning by tuning the bias towards the minority class. The graph shows that
the SMOTE and under-sampling combination ROC curve is dominating over the entire
range of values.
5.5 Additional comparison to one-sided selection and SHRINK
For the oil dataset, we also followed a slightly dierent line of experiments to obtain results
comparable to (Kubat et al., 1998). To alleviate the problem of imbalanced datasets the
authors have proposed (a) one-sided selection for under-sampling the majority class (Kubat
& Matwin, 1997) and (b) the SHRINK system (Kubat et al., 1998). Table 5.5 contains the
results from (Kubat et al., 1998). Acc+ is the accuracy on positive (minority) examples and
Acc is the accuracy on the negative (majority) examples. Figure 25 shows the trend for
Acc+ and Acc for one combination of the SMOTE strategy and varying degrees of undersampling of the majority class. The Y-axis represents the accuracy and the X-axis represents
the percentage majority class under-sampled. The graphs indicate that in the band of
under-sampling between 50% and 125% the results are comparable to those achieved by
SHRINK and better than SHRINK in some cases. Table 5.5 summarizes the results for the
SMOTE at 500% and under-sampling combination. We also tried combinations of SMOTE
at 100-400% and varying degrees of under-sampling and achieved comparable results. The
345

fiChawla, Bowyer, Hall & Kegelmeyer

Phoneme: ROC comparison between SMOTE and C4.5 variation of decision thresholds
100

95

%TP

90
SMOTE
Varying C4.5 decision thresholds
Hull
85

80

75
10

20

30

40

50

60

70

80

90

100

%FP

Figure 24: SMOTE and Under-sampling combination against C4.5 learning by tuning the
bias towards the minority class

SMOTE and Undersampling
100

90

Accuracy

80

Accuracy on majority (negative class)
Accuracy on minority (positive class)

70

60

50

40

30

0

100

200

300
400
500
600
Percentage undersampling of majority class

700

800

Figure 25: SMOTE (500 OU) and Under-sampling combination performance

SHRINK approach and our SMOTE approach are not directly comparable, though, as they
see dierent data points. SMOTE oers no clear improvement over one-sided selection.
346

fiSMOTE

Method
SHRINK
One-sided selection

Acc+
82.5%
76.0%

Acc
60.9%
86.6%

Table 4: Cross-validation results (Kubat et al., 1998)

Under-sampling %
10%
15%
25%
50%
75%
100%
125%
150%
175%
200%
300%
400%
500%
600%
700%
800%

Acc+
64.7%
62.8%
64.0%
89.5%
83.7%
78.3%
84.2%
83.3%
85.0%
81.7%
89.0%
95.5%
98.0%
98.0%
96.0%
90.7%

Acc
94.2%
91.3%
89.1%
78.9%
73.0%
68.7%
68.1%
57.8%
57.8%
56.7%
55.0%
44.2%
35.5%
40.0%
32.8%
33.3%

Table 5: Cross-validation results for SMOTE at 500% SMOTE on the Oil data set.

347

fiChawla, Bowyer, Hall & Kegelmeyer

6. Future Work
There are several topics to be considered further in this line of research. Automated adaptive
selection of the number of nearest neighbors would be valuable. Dierent strategies for
creating the synthetic neighbors may be able to improve the performance. Also, selecting
nearest neighbors with a focus on examples that are incorrectly classied may improve
performance. A minority class sample could possibly have a majority class sample as its
nearest neighbor rather than a minority class sample. This crowding will likely contribute
to the redrawing of the decision surfaces in favor of the minority class. In addition to
these topics, the following subsections discuss two possible extensions of SMOTE, and an
application of SMOTE to information retrieval.
6.1 SMOTE-NC
While our SMOTE approach currently does not handle data sets with all nominal features,
it was generalized to handle mixed datasets of continuous and nominal features. We call this
approach Synthetic Minority Over-sampling TEchnique-Nominal Continuous [SMOTE-NC].
We tested this approach on the Adult dataset from the UCI repository. The SMOTE-NC
algorithm is described below.
1. Median computation: Compute the median of standard deviations of all continuous
features for the minority class. If the nominal features dier between a sample and
its potential nearest neighbors, then this median is included in the Euclidean distance
computation. We use median to penalize the dierence of nominal features by an
amount that is related to the typical dierence in continuous feature values.
2. Nearest neighbor computation: Compute the Euclidean distance between the feature
vector for which k-nearest neighbors are being identied (minority class sample) and
the other feature vectors (minority class samples) using the continuous feature space.
For every diering nominal feature between the considered feature vector and its
potential nearest-neighbor, include the median of the standard deviations previously
computed, in the Euclidean distance computation. Table 2 demonstrates an example.
F1 = 1 2 3 A B C [Let this be the sample for which we are computing nearest
neighbors]
F2 = 4 6 5 A D E
F3 = 3 5 6 A B K
So, Euclidean Distance between F2 and F1 would be:
Eucl = sqrt[(4-1)2 + (6-2)2 + (5-3)2 + Med2 + Med2 ]
Med is the median of the standard deviations of continuous features of the minority class.
The median term is included twice for feature numbers 5: BD and 6: CE,
which dier for the two feature vectors: F1 and F2.

Table 6: Example of nearest neighbor computation for SMOTE-NC.

348

fiSMOTE

3. Populate the synthetic sample: The continuous features of the new synthetic minority
class sample are created using the same approach of SMOTE as described earlier. The
nominal feature is given the value occuring in the majority of the k-nearest neighbors.
The SMOTE-NC experiments reported here are set up the same as those with SMOTE,
except for the fact that we examine one dataset only. SMOTE-NC with the Adult dataset
diers from our typical result: it performs worse than plain under-sampling based on AUC,
as shown in Figures 26 and 27. We extracted only continuous features to separate the eect
of SMOTE and SMOTE-NC on this dataset, and to determine whether this oddity was
due to our handling of nominal features. As shown in Figure 28, even SMOTE with only
continuous features applied to the Adult dataset, does not achieve any better performance
than plain under-sampling. Some of the minority class continuous features have a very high
variance, so, the synthetic generation of minority class samples could be overlapping with
the majority class space, thus leading to more false positives than plain under-sampling.
This hypothesis is also supported by the decreased AUC measure as we SMOTE at degrees
greater than 50%. The higher degrees of SMOTE lead to more minority class samples in
the dataset, and thus a greater overlap with the majority class decision space.
Adult SMOTENC
100

95

90

85

%TP

80
UnderC4.5
50 SMOTENCC4.5
Naive Bayes
Hull

75

70

65

60

55

50

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 26: Adult. Comparison of SMOTE-C4.5, Under-C4.5, and Naive Bayes. SMOTEC4.5 and Under-C4.5 ROC curves overlap for most of the ROC space.

6.2 SMOTE-N
Potentially, SMOTE can also be extended for nominal features  SMOTE-N  with the
nearest neighbors computed using the modied version of Value Dierence Metric (Stanll
& Waltz, 1986) proposed by Cost and Salzberg (1993). The Value Dierence Metric (VDM)
looks at the overlap of feature values over all feature vectors. A matrix dening the distance
349

fiChawla, Bowyer, Hall & Kegelmeyer

Adult ROC with Ripper
100

95

90

%TP

85

80

UnderRipper
50 SMOTERipper
Loss Ratio
Hull

75

70

65

60

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 27: Adult. Comparison of SMOTE-Ripper, Under-Ripper, and modifying Loss Ratio in Ripper. SMOTE-Ripper and Under-Ripper ROC curves overlap for most
of the ROC space.
Adult only continuous [C4.5]
100

90

%TP

80

70

Under
50 SMOTE

60

50

40

0

10

20

30

40

50
%FP

60

70

80

90

100

Figure 28: Adult with only continuous features. The overlap of SMOTE-C4.5 and UnderC4.5 is observed under this scenario as well.

350

fiSMOTE

between corresponding feature values for all feature vectors is created. The distance 
between two corresponding feature values is dened as follows.
(V1 , V2 ) =

n

C1i

|

i=1

C1



C2i k
|
C2

(1)

In the above equation, V1 and V2 are the two corresponding feature values. C1 is the total
number of occurrences of feature value V1 , and C1i is the number of occurrences of feature
value V1 for class i. A similar convention can also be applied to C2i and C2 . k is a constant,
usually set to 1. This equation is used to compute the matrix of value dierences for each
nominal feature in the given set of feature vectors. Equation 1 gives a geometric distance
on a xed, nite set of values (Cost & Salzberg, 1993). Cost and Salzbergs modied VDM
omits the weight term wfa included in the  computation by Stanll and Waltz, which has
an eect of making  symmetric. The distance  between two feature vectors is given by:

(X, Y ) = wx wy

N


(xi , yi )r

(2)

i=1

r = 1 yields the Manhattan distance, and r = 2 yields the Euclidean distance (Cost &
Salzberg, 1993). wx and wy are the exemplar weights in the modied VDM. wy = 1 for a
new example (feature vector), and wx is the bias towards more reliable examples (feature
vectors) and is computed as the ratio of the number of uses of a feature vector to the number
of correct uses of the feature vector; thus, more accurate feature vectors will have wx 
1. For SMOTE-N we can ignore these weights in equation 2, as SMOTE-N is not used for
classication purposes directly. However, we can redene these weights to give more weight
to the minority class feature vectors falling closer to the majority class feature vectors; thus,
making those minority class features appear further away from the feature vector under
consideration. Since, we are more interested in forming broader but accurate regions of the
minority class, the weights might be used to avoid populating along neighbors which fall
closer to the majority class. To generate new minority class feature vectors, we can create
new set feature values by taking the majority vote of the feature vector in consideration and
its k nearest neighbors. Table 6.2 shows an example of creating a synthetic feature vector.
Let F1 = A B C D E be the feature vector under consideration
and let its 2 nearest neighbors be
F2 = A F C G N
F3 = H B C D N
The application of SMOTE-N would create the following feature vector:
FS = A B C D N
Table 7: Example of SMOTE-N

351

fiChawla, Bowyer, Hall & Kegelmeyer

6.3 Application of SMOTE to Information Retrieval
We are investigating the application of SMOTE to information retrieval (IR). The IR problems come with a plethora of features and potentially many categories. SMOTE would have
to be applied in conjunction with a feature selection algorithm, after transforming the given
document or web page in a bag-of-words format.
An interesting comparison to SMOTE would be the combination of Naive Bayes and
Odds ratio. Odds ratio focuses on a target class, and ranks documents according to their
relevance to the target or positive class. SMOTE also focuses on a target class by creating
more examples of that class.

7. Summary
The results show that the SMOTE approach can improve the accuracy of classiers for
a minority class. SMOTE provides a new approach to over-sampling. The combination
of SMOTE and under-sampling performs better than plain under-sampling. SMOTE was
tested on a variety of datasets, with varying degrees of imbalance and varying amounts of
data in the training set, thus providing a diverse testbed. The combination of SMOTE and
under-sampling also performs better, based on domination in the ROC space, than varying
loss ratios in Ripper or by varying the class priors in Naive Bayes Classier: the methods
that could directly handle the skewed class distribution. SMOTE forces focused learning
and introduces a bias towards the minority class. Only for Pima  the least skewed dataset
 does the Naive Bayes Classier perform better than SMOTE-C4.5. Also, only for the Oil
dataset does the Under-Ripper perform better than SMOTE-Ripper. For the Can dataset,
SMOTE-classifier and Under-classifier ROC curves overlap in the ROC space. For all the
rest of the datasets SMOTE-classifier performs better than Under-classifier, Loss Ratio,
and Naive Bayes. Out of a total of 48 experiments performed, SMOTE-classifier does not
perform the best only for 4 experiments.
The interpretation of why synthetic minority over-sampling improves performance where
as minority over-sampling with replacement does not is fairly straightforward. Consider
the eect on the decision regions in feature space when minority over-sampling is done
by replication (sampling with replacement) versus the introduction of synthetic examples.
With replication, the decision region that results in a classication decision for the minority
class can actually become smaller and more specic as the minority samples in the region are
replicated. This is the opposite of the desired eect. Our method of synthetic over-sampling
works to cause the classier to build larger decision regions that contain nearby minority
class points. The same reasons may be applicable to why SMOTE performs better than
Rippers loss ratio and Naive Bayes; these methods, nonetheless, are still learning from
the information provided in the dataset, albeit with dierent cost information. SMOTE
provides more related minority class samples to learn from, thus allowing a learner to carve
broader decision regions, leading to more coverage of the minority class.

Acknowledgments
This research was partially supported by the United States Department of Energy through
the Sandia National Laboratories ASCI VIEWS Data Discovery Program, contract number
352

fiSMOTE

DE-AC04-76DO00789. We thank Robert Holte for providing the oil spill dataset used in
their paper. We also thank Foster Provost for clarifying his method of using the Satimage
dataset. We would also like to thank the anonymous reviewers for their various insightful
comments and suggestions.

353

fiChawla, Bowyer, Hall & Kegelmeyer

Appendix A. ROC graphs for Oil Dataset
The following gures show dierent sets of ROC curves for the oil dataset. Figure 29 (a)
shows the ROC curves for the Oil dataset, as included in the main text; Figure 29(b) shows
the ROC curves without the ROC convex hull; Figure 29(c) shows the two convex hulls,
obtained with and without SMOTE. The ROC convex hull shown by dashed lines and stars
in Figure 29(c), was computed by including Under-C4.5 and Naive Bayes in the family of
ROC curves. The ROC convex hull shown by solid line and small circles in Figure 29(c) was
computed by including 500 SMOTE-C4.5, Under-C4.5, and Naive Bayes in the family of
ROC curves. The ROC convex hull with SMOTE dominates the ROC convex hull without
SMOTE, hence SMOTE-C4.5 contributes more optimal classiers.
Oil

90

90

80

80

70

70

60

60

%TP

100

50

40

30

20

UnderC4.5
500 SMOTEC4.5
Naive Bayes

30

20

10

0

50

40
UnderC4.5
500 SMOTEC4.5
Naive Bayes
Hull

10

0

10

20

30

40

50
%FP

60

70

80

90

0

100

0

10

20

30

40

(a)

50
%FP

60

70

80

90

(b)
Oil ROC Convex Hulls
100

90

80

70

60

%TP

%TP

Oil ROC
100

50
Convex Hull with SMOTE
Convex Hull without SMOTE

40

30

20

10

0

0

10

20

30

40

50
%FP

60

70

80

90

100

(c)
Figure 29: ROC curves for the Oil Dataset. (a) ROC curves for SMOTE-C4.5, UnderC4.5, Naive Bayes, and their ROC convex hull. (b) ROC curves for SMOTEC4.5, Under-C4.5, and Naive Bayes. (c) ROC convex hulls with and without
SMOTE.

354

100

fiSMOTE

References
Blake, C., & Merz, C. (1998).
UCI Repository of Machine Learning Databases
http://www.ics.uci.edu/mlearn/MLRepository.html. Department of Information
and Computer Sciences, University of California, Irvine.
Bradley, A. P. (1997). The Use of the Area Under the ROC Curve in the Evaluation of
Machine Learning Algorithms. Pattern Recognition, 30(6), 11451159.
Chawla, N., Bowyer, K., Hall, L., & Kegelmeyer, P. (2000). SMOTE: Synthetic Minority
Over-sampling TEchnique. In International Conference of Knowledge Based Computer Systems, pp. 4657. National Center for Software Technology, Mumbai, India,
Allied Press.
Chawla, N., & Hall, L. (1999). Modifying MUSTAFA to capture salient data. Tech. rep.
ISL-99-01, University of South Florida, Computer Science and Eng. Dept.
Cohen, W. (1995a). Learning to Classify English Text with ILP Methods. In Proceedings of the 5th International Workshop on Inductive Logic Programming, pp. 324.
Department of Computer Science, Katholieke Universiteit Leuven.
Cohen, W. W. (1995b). Fast Eective Rule Induction. In Proc. 12th International Conference on Machine Learning, pp. 115123 Lake Tahoe, CA. Morgan Kaufmann.
Cohen, W. W., & Singer, Y. (1996). Context-sensitive Learning Methods for Text Categorization. In Frei, H.-P., Harman, D., Schauble, P., & Wilkinson, R. (Eds.), Proceedings
of SIGIR-96, 19th ACM International Conference on Research and Development in
Information Retrieval, pp. 307315 Zurich, CH. ACM Press, New York, US.
Cost, S., & Salzberg, S. (1993). A Weighted Nearest Neighbor Algorithm for Learning with
Symbolic Features. Machine Learning, 10 (1), 5778.
DeRouin, E., Brown, J., Fausett, L., & Schneider, M. (1991). Neural Network Training on
Unequally Represented Classes. In Intellligent Engineering Systems Through Artificial
Neural Networks, pp. 135141 New York. ASME Press.
Domingos, P. (1999). Metacost: A General Method for Making Classiers Cost-sensitive.
In Proceedings of the Fifth ACM SIGKDD International Conference on Knowledge
Discovery and Data Mining, pp. 155164 San Diego, CA. ACM Press.
Drummond, C., & Holte, R. (2000). Explicitly Representing Expected Cost: An Alternative
to ROC Representation. In Proceedings of the Sixth ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining, pp. 198207 Boston. ACM.
Duda, R., Hart, P., & Stork, D. (2001). Pattern Classification. Wiley-Interscience.
Dumais, S., Platt, J., Heckerman, D., & Sahami, M. (1998). Inductive Learning Algorithms and Representations for Text Categorization. In Proceedings of the Seventh
International Conference on Information and Knowledge Management., pp. 148155.
355

fiChawla, Bowyer, Hall & Kegelmeyer

Ezawa, K., J., Singh, M., & Norton, S., W. (1996). Learning Goal Oriented Bayesian
Networks for Telecommunications Risk Management. In Proceedings of the International Conference on Machine Learning, ICML-96, pp. 139147 Bari, Italy. Morgan
Kauman.
Fawcett, T., & Provost, F. (1996). Combining Data Mining and Machine Learning for Effective User Prole. In Proceedings of the 2nd International Conference on Knowledge
Discovery and Data Mining, pp. 813 Portland, OR. AAAI.
Ha, T. M., & Bunke, H. (1997). O-line, Handwritten Numeral Recognition by Perturbation
Method. Pattern Analysis and Machine Intelligence, 19/5, 535539.
Hall, L., Mohney, B., & Kier, L. (1991). The Electrotopological State: Structure Information
at the Atomic Level for Molecular Graphs. Journal of Chemical Information and
Computer Science, 31 (76).
Japkowicz, N. (2000). The Class Imbalance Problem: Signicance and Strategies. In Proceedings of the 2000 International Conference on Artificial Intelligence (IC-AI2000):
Special Track on Inductive Learning Las Vegas, Nevada.
Kubat, M., Holte, R., & Matwin, S. (1998). Machine Learning for the Detection of Oil
Spills in Satellite Radar Images. Machine Learning, 30, 195215.
Kubat, M., & Matwin, S. (1997). Addressing the Curse of Imbalanced Training Sets: One
Sided Selection. In Proceedings of the Fourteenth International Conference on Machine
Learning, pp. 179186 Nashville, Tennesse. Morgan Kaufmann.
Lee, S. (2000). Noisy Replication in Skewed Binary Classication. Computational Statistics
and Data Analysis, 34.
Lewis, D., & Catlett, J. (1994). Heterogeneous Uncertainity Sampling for Supervised Learning. In Proceedings of the Eleventh International Conference of Machine Learning, pp.
148156 San Francisco, CA. Morgan Kaufmann.
Lewis, D., & Ringuette, M. (1994). A Comparison of Two Learning Algorithms for Text
Categorization. In Proceedings of SDAIR-94, 3rd Annual Symposium on Document
Analysis and Information Retrieval, pp. 8193.
Ling, C., & Li, C. (1998). Data Mining for Direct Marketing Problems and Solutions. In
Proceedings of the Fourth International Conference on Knowledge Discovery and Data
Mining (KDD-98) New York, NY. AAAI Press.
Mladenic, D., & Grobelnik, M. (1999). Feature Selection for Unbalanced Class Distribution
and Naive Bayes. In Proceedings of the 16th International Conference on Machine
Learning., pp. 258267. Morgan Kaufmann.
ORourke, J. (1998). Computational Geometry in C. Cambridge University Press, UK.
Pazzani, M., Merz, C., Murphy, P., Ali, K., Hume, T., & Brunk, C. (1994). Reducing
Misclassication Costs. In Proceedings of the Eleventh International Conference on
Machine Learning San Francisco, CA. Morgan Kaumann.
356

fiSMOTE

Provost, F., & Fawcett, T. (2001). Robust Classication for Imprecise Environments. Machine Learning, 42/3, 203231.
Provost, F., Fawcett, T., & Kohavi, R. (1998). The Case Against Accuracy Estimation
for Comparing Induction Algorithms. In Proceedings of the Fifteenth International
Conference on Machine Learning, pp. 445453 Madison, WI. Morgan Kaumann.
Quinlan, J. (1992). C4.5: Programs for Machine Learning. Morgan Kaufmann, San Mateo,
CA.
Solberg, A., & Solberg, R. (1996). A Large-Scale Evaluation of Features for Automatic
Detection of Oil Spills in ERS SAR Images. In International Geoscience and Remote
Sensing Symposium, pp. 14841486 Lincoln, NE.
Stanll, C., & Waltz, D. (1986). Toward Memory-based Reasoning. Communications of
the ACM, 29 (12), 12131228.
Swets, J. (1988). Measuring the Accuracy of Diagnostic Systems. Science, 240, 12851293.
Tomek, I. (1976). Two Modications of CNN. IEEE Transactions on Systems, Man and
Cybernetics, 6, 769772.
Turney, P. (1996). Cost Sensitive Bibliography. http://ai.iit.nrc.ca/bibiliographies/costsensitive.html.
van Rijsbergen, C., Harper, D., & Porter, M. (1981). The Selection of Good Search Terms.
Information Processing and Management, 17, 7791.
Woods, K., Doss, C., Bowyer, K., Solka, J., Priebe, C., & Kegelmeyer, P. (1993). Comparative Evaluation of Pattern Recognition Techniques for Detection of Microcalcications
in Mammography. International Journal of Pattern Recognition and Artificial Intelligence, 7(6), 14171436.

357

fi	
fffi  	

 
  	 !#"$%%$&'%()**

+,-. /0$1%23,
  /.$1%$

46587:9;<9=.9>8?A@B9CEDFG?IH8JLKMCG>8CE?GJ ;<J >E7ONP97RQTSPJ#9>8UFEVRW.J ;<J >E7
XYJ#C V0>89>8?[Z]\_^85`J.VR9;<J >E7:aPNP97RQT7RQ8JcbcdIe[H[>gfGh8a7:J ;

i:j'klmRnRo'pqiRlm:rRs

tuv'wxu:yGz'{}| z'~'}~''u':~0| w

`R'
 ]  _}
Ylj:m:o_#lk}j:m

'#u':yGz'{}| '0| w

  G0IR.'}#II 
 G#.}
.}}'6}



Pls:j'o' YojpmR
 G0IR.'} 8G[
 G#.}
R :'O}
6jp}l.mPjo'p

#wu''{yGz{}| 'w'0| w

#u'w:yE'w{wu''z0| u}'0| z'~'

ERG` 0.
 . E



#:
#[IYEI}<}E[}`}}
R.0#} E}8}.I}I#[ 8
8E}'.YIIREY}8}8}
[80}8E}B.`}[[8YEG`G}
[I8E#}}I}8}80}O
}RR.I0E}[ GR  G#q}0#R
q:} 80:[0}.}8}#}G8#I
.}P[

R .## 
G	
fffi}ff''
ff'
fi
 '
 		fiff


!""#$"!%fifi

&(' )*#ff*
+,
%	%!"
-

} 	
-[
 /. !""
 	fi-ff#	fi	000!1
'	
	2
fifi&,'!fi
 !34 q	5'
fi ff'	

 ,-

 -
 
 [
 fffi
 	!6!2
 73
 +ff
} 0 
! 
 

/'
 	

 `	
 	&8$
#$
 `
9 " 	ff"
 
: 

 #7	 
	
 	,'
  ,"'
fi ;#$ ,#"

 fi
 	!2'
 '
fi ,
 *
 !*#;} 	3
 	
 ,  fifi

 <3/,	#4,
0'
fi 	2 	
 
= ">@?ff
A ffB	3
 *

 `
9 !C>$Dff*3<E<
 <3<FHG6} 	34IJJKLM,
 
 	
FOG
N 
 /34IJJPB	& ' 
,fi'
fi fffifi
 	
 	
 #$ [

 * 
 H> ffE7BRQST$UV"QT$W@XQY@YZ)  C'
 	

 	
 	2-fi
"
= +!
fi ;#$ 0#$8
'
 	 *'
fi ;#$ ff[
  ->$:
E 	
 <3/[4
 } 	
 
$37F1.
\ 	} 3]^^^LG6} 	3
_<[
 	3FH`0!  <3/IJJKB	&
 $%%$Rfi'fib/	 R	/c
aI

	4d:	ff-.	4e,
  ;ffi
 
} @g/f

fi'#u'Ewu''{
	fiffYu'w

A<I+G_		[,-`_<'<& .(!*8	fi2!
,I ff8  2
} ,":
: ) . 
 	
-
2E7"'
"
*,"
/&
> 
 -Y"W !#,T$%
U $& US
T '4(W &#*)(W #,+ff(T -.#(W &2(T -.#0/7Q2
V 1#*)T 3W@Y@4Y #,(W &)(T -.#,V"U)5&/W(&.6.7 B
A
] +Mff
2!-!-!- ff
  		2
 2E7"'
 
 *
0] %8.	&
A9+Mff
2!-!-!.   "
 *," 
 .
 
%9%8.	&
A.:684#$'
 2". 
 q
!  E7"'
 
 
0'
fi *
 *," 
 /&
8$0
 "[#
 0
 	

   GR
 !-
 )E7"'
 
 &
'  -!"#$ 
 -ff!*&
[4  ,
 "[
 0# 	/} 	-!*!
 <
 ; 

 
3 ;  =;
 3%
 ;

 &
:,N07&
A
P %N0/! , ) ,[
 
 "/
! >
_4
I4?I`	5fi,
,. 
2`_<'<&

? 
' fffi}*
"!c[	)`_<'<3/.0
	2. ff
 
fi[	)-fi
'

2`
 _<'

.G+
%_4
)I34. 
6! 	"'		(Aff
A C	"'		B%A &
8%

30!6
). 
%*fi'= '	R	
BC5 . !68"	fi%!,/
D 3
!1	,S+,#*0
) } ,W(/& W@T$W@QT$W(3*ff
# 
-fi

"
#$
-0}	

!	!

		+
<&< ,	fi	"
+		"!)'*	
	!6'	
	7&*8_	3
E	+ Z*	+ T# V<	+}""



*!)!
*"	
	
-fiFC [4"	[
0
! 
		-
./
D 3 	

"ff4"fi
'0
#$
-
	fi}	0-"/ff#}	


	ff
)`E	.@	!&?1fi,
".

 
"#< }	

!&4G(
	"#<	E	
G	
	#7! 



0

fi'
0!-'fi'+!-*,fifi'
	ff#4"''!
22
fi';#	ff?ffA"3
fifi

 #< 34. 	/4

  0#;	&4' 
.
 	
  #<
 



 0
  '
fi 	!
0,

 3< 2
00I	5fi ,#[
 	 #4
 `
9 ff'	

 *'
 	


 &
8 "0
 <3fi 	
  	
  		"0'
fi 	
 
: 

 -#<0

 ff
 
 [
 
fi
 	!)0 -

 ff'
 	

 )fi <
 4 	
 7
 

  #"!O G 	%>@.0
  I} 	


 " 	0
   

 0fi
 	!3
 


 	!"'
 	

 	*!,
 8	5'
fi B	3

 E	fi0 
	 		6. 
+
 ) ff
 } 	
2. 
)
 GR ff

 ,#!*37Y
 "'
 0#
	

 -[
 	
 	 E	 		#$0
 } 	"

 3
  
 GR 

   

!
	fi
 	%>@M, 
 	
4FHG
N 
 /3IJJPLA
 '
 
 <3<A*3'
 IH0
3 J
 	3/F ?  [
 3<IJJKL
Dff*34IJJPL<G6} 	37E<
 <3Dff*37FH?ff'
 	3IJJKB	&ffM,
 "*[	0# 	5'
fi 
[
 =


 <37
 !+2 #;# fi
 	
 	- -_
! 	5fi 	6
 +
 !)
 	5'
fi 
[
 &28.	3
 !
 "#, 
  -

 )fi
 	
 	2 -!fi
 !Cfi
 &C8 %
` _<'
 <34#$I
 	5fi 3
 ff
ff"  	-fi} ff#] K $ fi
7

 fi
 	3< . 
4'
 ,'
 	
 	)'
 	.,&
G." 
 		- ,

 ,fi
 	q
! 
 -'
 ff'
 	

 	)
 0#$
"

# L+,'
 	


 2fi
 	 	"(> L)M,[4B4
 2 	
 #$ [
  
 +> ffE7B0> J
 
 '*F E<
 /3
IJJ ML:
E 	
 ]	-$&3]^^^LG6} [
 	-$&30IJJKLA
 <3 G
D  3E<

 <3 F G6} 	30IJJJL
G6} 	3/]^^^B	3.0
 	2 ,'
 	[
 ""/*fifi} 	--
 !?ff8fi "0

 
 + 0 
 )*
fi -'

fi ;#$
 !)
 } 	

 ). 
)
8

 [
 *>$A)F

N5O*P

fi'# u'}~'w`u''uw#w'

J/3 IJJKL Dff} 	
 /30E<
 <3F L) 3 IJJ MB	& L) *'fi 	
 : !30<L)M,[HffE
#$
",	"2[	)#$fffi
"
=	
+
*fi
	
	#; fi-
-/3
  

 ) !%#  	*. 	 =;
	166fi  #"

 +'	
<& ' 	2#	

 	'
 +*#;} 	-ffE(
-'
 	

 	(_	'
fi )} #;!C. 
]
!C )>@
 	C-
?ff
A ffB	3/	
'
 
ff
 2[

 [
 *>@.0
 	2
 )
8
  "
ff fffifi

 B	3

 *'

 	! 	2 	. ,>@.0
 	2 0!fi
 <
 *fi} -

 ,!"B	& ' 
 ,
 2
 
 
#
,fifi} 	2
fffi
#$E
 	fi
)
 2fi


 -fi
 	!+. 

 +*"
 	
 4  	,fi} 3
 ff 	
 	!
 "'
 4#<
 
 "

 	&' 
 EffE*fifi} 	

" /*=`
9 	
 '  
.		} 	

 4 #;'
 	

 ,#/3.0
 0


 


 ,[
 	q
 		G
 
 ,fi
 	
 	&
G#$'	!3/fi} 	
4fifi

+##ffE+-#fi}2
5=
["fi	"!)	'
 		&*G(
*	!)#EffE%

*	73fi=
fi
 

 ff ff'
 -
"
	+" 	5	
	!*fi" 
`	$3fi'
0		<3
 [
 5=fi!
 6> & /&37> ? 
	ffF J/37IJ
J ML/R
' 	/3IJJPBB	&Mff

 
 
 [
 ff
fi =
 	 "*ff
 GR ,!'

fi # fi *3
 +.0
 	+2L)M,[("'
 	-.
 2!<
 

} 	

 %. 
%+fifi

 C#,
 % 3 
 
 ffER
* 	C+fi
"
= 22!<
 
fi ;#$ &ff_/ 
ff!'
'
fi "#fifi
 

 <3"'
 0#
 
 */
, 	
  	!2
"
	
!%) 
 [
 --6 %
 } 	. 
%2!*&R_<" 3	C#$
	5fi!/"" '
 , 	2. 
-8	-#$ff#;'
 	

 
 -!*3
$& .
& } 	`
 	
 
0! 0
 ,
 *"fi
 	
 	5 " } 0  ff
 - 	
 	5#;
, ,  0'
fi '
fi 	
 &
' 
fi'
fi ,fi 	 *'
 	
 	C[
 	!2#$,
 
 ffE%2fi
"
=--'	
+#0

-[,fi
	!6	+2
"
	6
}	
,. 
+)3_	5fi'
 =
 !*'
[
 "
 	 ,

!2#4,fifi} 	-
 *8	
 	5 #4,`_<'*!*&4?
2
) 	 	$34I
 ffE%[
 	!)
 
 	"	
 -# fififi
-'
fi ;#$
 


>@
$& &3 	. ,[
  	B 8
 	
	7#$<

 3'
 fi![
 4#/
 ff
 


 
 
!   	 '
 	
'
 	
! 	5fi!-

 "/3I	
 
 	

 *#
 <L)M,[
"'
 	7#4  fifi

 2 } 	

  
 GR 0}	

 `	
 	3/
 *, 	'
 fi![
  #4
!O
 -fffi
7

 "fi
 	!)} 	
 
0  	2 	
	2"'
 	$&
A 	


 +]-'
 	 
'
 	"[
 #
-fi
	!_	
	",-
*ff"
}&A	
I9	5fi
,. 	
#$[0
Y2'"	2fi
"
="	Y	
	

R)
: 	'
 	(

 +! . 
CR& A	
 :6'	
'	2+	
	2#
6
` _<'
 R!*30.0
 %
A 	

  P%'
 	 
'
 	+. 
` _<'
 (fi
"
= 	)
*

 %fi
 	!
#; 	5'
fi 
[
 !2
 	2

 ,/&
A 	

 IM" fiEfi

 4 	G	

'
fi ;#$ #
` _<'
  ,  	+

 -fi
 	!34
 +'
 "
 	00fffifi} 	

fi 	
` _<'
  G
 	fi 	

 -,>@0
 	 [
  #$4'
fi ;#$
  fi
"
=

 B	&
A 	


 IM-fi 	 0 	G	

 *ff
 } 	
!-#,  	I
 L)M,[3
 Y
 	fi 	
 '
fi ;#$ #/  	-fi
 	!"0 '
fi ;#$
 #//
 .
 =;'
 	

 	*fi
 	
 	

 )"
 0
& Hffff 	,fi
'
 fi

 #
 	
'
 -3/.0
 )fi'
fi !+fifi
 	70
3 ffE

 	 

 	!* -
!*
fi
 0ff'
fi ;#$
 0#4,fi} 

 ,!*&


fifffi fi!#"  $%&	')((#*+-,."  (#/ (01) $#&/ (01)/ 1)1) $/ fi	/ ($#	')*
$#3245&#*4" "675(989
 :fi:;<>=" 8+-fi13?>3896+-fi0fifi/@89ABfiB#
Cff

N5O#D

fi'#u'Ewu''{
	fiffYu'w

ASR
User

Dialogue
Policy

TTS
_4
,] ?

Database

	6
 fi	
%#"+fi}%
)!*&(' +

}	0-/,!*fi'
*,! 
7,*

,'
fi 	+ 	
 


 )! >@?ff
A ffB	&<' ! ,}	*--
-"	5 "'
fi 	%>$' ' AB!*&

 0	c  
ff
fi

0

   
  0 ff 
fiO

 Y 

8 6-!fi
fi})
-!
>@.G2
6	=;
 #$ 
+_4
-]B	37-
fi' !(
"
[ff 	fi"
fi3
0#;5=$#$O
  3
-'	
	0'	
	*
#$
#;H"}	=*	- ,/&4' 
 ,  '
fi 	,
4
 fi 		"ff
 "
4'
fi 	" 	
 
=  >@?ff
A ffB	3"!< 

  0 	fi
  	 E	
 
 	
! 	ff0 4
,ff	5 =;=;'
fi 	2>$' ' A0
B 	fi
 &
' 
 

 ff  7#<!1 	0
 W@QY5U 6.
S # UYW@XZffff'
 	
'
  .04! 
!+>@
 YffE)"
 !3.0
 	+QXT$W@
U &)
 2} B  } 	*fi
 0
*ff

 &
_/<fifi 	3 ff?ff
A  "'
 
 	. 	
 ,
'
fi ;# 	3
!, 7. 
,
 ,  
Cfi[
 	 D2>@YQ &.6S*Q 6#"V"*U #Y
 6)QV"V"
Q )B  
 2'
 ,'	2"
  <
 ff!'
fi 	 #
'
fi 	) 	
 


 )"
} 	ff'
 & 8 )


 2-
 !2'
fi  	

 	6	
 	 
 2"
 3
*?ff
A  + 	 -2 	 6>@!fi
 !% 		%) =;
} 	
 '
 '
 )
'
  L+
"'
 	B*

 R6 	
 _	
)[
# 	
 :/'
 6
 R+	
 	-#$'
 7& ' 
2 	 )


fi 
 *
 fi 	
-ff?ff
A 1 	&
Hff.G
 	
 	
 "
0.0
fi!'
fi 	4#/'
 	


 #;} 	"
 "

 
fi
 	!6'
 	

 <3+# .0
 	% -
 
! 	 	%!+?ff
A  #;} 	"
 &2' 
 :<,!'
fi 
#4'
 	


 37#4.0
 	*. " , !* )
 `	5fi 3<
ff. "
 	+(W &/W@T$W@QT$(W 3*#"ff!
2.(ff 
[
 	!3.0
 	0!  
 !

 -fi
  2fifi
  
 2- 	
 	!2'
fi ='
 	+ '">@#$* #  	2-,
S +,#*)"
 



 B0 - 	

 	!
 	
 	


 " ',> +	*Z +	T #V 
 



 B	&
' 
  	
 +!'
fi # 	
 -. 
 
 	
"
P
. 	
  

 ! %'
 
 
XU &,$)V"(W &.6 
0'
 '
 
 #, 	&4? #$
 0fifi
 	2ff?ff
A (" 
 3
 -
 	*ff

 0#$4[
 ff
 #7
  	,>#$4
 3G
. 
E7"'
 
 B	3
! "ff'	
'
 *.0
 	ffq	
 :< -'
fi  	

 	C
 . 
+- 	&-? #$ff
 ,   	fi
  %,I 
 "_4
 ,I3#$0
 	5fi 3
` _<'
 "4'	
'
 0.0
 	4

 	5fi
 	
!
XU &,$)V(
ff'
 '
 
 /3< 
 2
 	0A]
 )
A 9&
` _<'
 Y
 *-
fiY
! 	
 

 ,
 
. 
)-

 34,.0
 +
,
 	[
 8	5fi
 	

! 	
 :< ,- ff. 
 ff*:
: +
4. 
 
 	&4G(
  . "
fi
40	
 :<

 ,
'
 '	!ff#$
"
 	#/
?ff
A  	
 :/'
 34 _
 	!2#$ .1
 	3fi'
fi ff'
 :
: 


 "0
# C
.
 D2
 B
 C
. D
.+
'
 !6'
 -'
 	"
 	_
 fi

 !6#$  ff2>#$0
 37'
 '
fi 
 +
 
.0
 	 0'
 "
 `
9 !
 "fi 	
#
 	
5 	
 
 	B	3
 -"
4''
fi -
 ,4[
  
#4! 
 	&











N5O



fi'# u'}~'w`u''uw#w'

?0ff. 
''	
	%'	.,3<
)`_<')!*3<. "
'
 :	%!2
 GRff

	#$ .0
	2. ,. 	22Y4#Q)5&).0	0}"  !O



"#$ [	5
fifi&1A
"
!3,. 2
'
 :	1!C
 GR*
+	
R.0
	R. 2. 	R
 ).0
 	ffY	
 :< ?ff
A ='
fi  	

 	% ,
 37I
 ffY	
 :<*& $ G_
 ff
  
  *fi

	2'
 ff
 #
 	
 	0#
 



 
 Y
 	
 :<

 *"
 


 !O'
 	

 ->@G6} ffFHG(
} 	3IJJ^L/M,
 
 	
FOG
N 
 /34IJJP
L 0 ,F
L0!3IJJK3IJJJL<A"
<3IJJKL<G6} G
 	,$&34IJJKB	&0?0,-
fi `	5fi 37[
  
 !6!""[	
 :< #; 
 !#
3 	
 6
 #,'
 '	
!3 
 2
-fi
'
 	
 	
 :/'
 
ff!1
0'
 '
 
 ff 	&' 
 	 , G. 	 ='
 '
 q
 	
 	 
 .0
 	
 0
0"fi 	

 `
 	
  3.0
 	-
 fi 	
 	!*.0!. 0. 
-"3
 *"fi
 	
fi 	
. !3,fi
 	0#
 
 	`
 	
 	0
 *,
 .
# fi

 /&



   R 
fi   :

.

  

.R  0
	8  } 


8 R
*	
<30. )'	
'6+}	*[	!C. +fifi)%fifi!ffE 6
*=
"fi
	!)'	
<& 82[	50	
<3/. ff. 
4'	
'"
2'	
,


*#

 	!-
 *"
[
` _<'*!*&

fiff

8ff'<0fifi!IffE" '	
ff#
 fi
	!3
7
.	!ff '::+	T$QT# 1Q+,#5
fi	 

 *#$0

 	&EJ!2
,. "
fi!6[2,4ff"0#
#$

0,

 #;0
ff 	 	
 0#$ '	

2.0ff}	
*"! +}
	5 
G
 	
 
 	2
 2,
  "
=	
 `
 
!` 	)ff& HI,
0 
fi} 5=

0
 	
 "#$ 
ff,
,-  
fi0 !O*#[
 "

 37.0
 	).

	'
 *-
)-#;	37-
 	,	
 	6!)?ff
A "3<
 
 -"'
 	 	73
E	
 :/'
 0 	 	 	 	-!"?ff
A "3
 -'
fi fi
 !"
 
 

	&48 -fi} 	
3
. [	)	fi 	0
0,ff"
 	20fi
 
 fi 	 
-	0!*,

 	ff#
 	0#4#  	
. 
0
 *
 #$

 	!-#$0
 -)'
 	


 &
G_,
 	.1,'
 	

 2# 2fififi
,fffi} ,Q <YW@XQT$W@
U & # #*&#*&/T3<
 )#$
"
 	)! '
 	

 	&







ff 

N0
 	
 	#$0 #  	30!H'
 	

  
 -
 
-"#7ff
fi}3%fififi
}	
,2}"
_}	2&G_'::* W@QYU56S.# UYW@XZ,)'-
fifi
 -#; , 	0
# +	T$QT #,+"
 *,,fi} ,- 	0# QXT$W@
U &+&_/[,	3
fi'
fi "} 	

 62} -!6'
 Y	 *>#$ff
 3 	
)* "
 6-,37

 !
 "0/  .0
 -/
 #$

 <
	  
 
	/B	&_/44	3
 	1,
X -UW@5X # +	T$QT #,+34 2!6'
 )"
fi + 
  2} 	

  	
 	+>@
 	%
 	
 	#




 - 
 	
 :<

 B	&,\} 	2fifi
 *#;O
 	q
 	
 5=;	ff*-fi
,} 	

 

 ff

	

 ,fi
 	!&'!fi
 !- !1'
 	

   	
 


 -8	  ff'
 	
 	

}
 "ff} 
 [} 	[
 	
 5=;& Hff.
 ff
E = 	-fifi} 	"
ff
 -} 	 E	
 	
!)4Y #Q )5&/(W &.6<&



fiff

86fi
	34*
*! 8	5fi	}	
	
	
6*!
. !
*"fi
"
= ,
ff'
 
 !-
 }	
-. 
*fi	
,*&' ff!
	
  	. 
  ,'
fi ;#$H0 	#7fi	
 4
 
0
<&



Aff -" &0



3  1

(fi "  ( $

/(



&#>8-? fi/ &"

1)fi$#fi8fiff 0#ff 8






1)(

!# (#- &#" ' $#fi?fi

N5O



fi- fi!> '>$/ " fi0&3!>" /

fi&/  



2@,>/ 1)(98

 

$# / / (fi



(9896=" 8 
 :fi: Cff

fi'#u'Ewu''{
	fiffYu'w

_/0}	"
ff
}	
<3fffi';#$0[3	20) #*'4Q) 3
#	7& *
' 
 , 	


 I	fi 
0 	-[	
 
 	  )Q)!
U 30#X"W +	W@
U & )UX5#,+5+0>(L)M,[B4.0
	
"'
 	 0 * 
 } 	

 . 
0!*&GR

 fifi} 	<3fffi H#  
 
ff

 fffi
 	!-
 	/
 	-8	fi
,0fi
/fi
 	!#$0
 	
 } 	

 

" L)M,[
7
3!<
  7
4 } } 	

 0ff5
"
=  	5'
fi 		 	. 7&
' 
 E	fi

 "#< fi
<fi
 	E
! 6(W 3*#*&-   	E
 L)M,
[ 
 '
 0
 E`
9 	
 !-
 
/*'
! "
 "fi"
 
""> J#0FH'


3IJ
J MLA*fi
F J/3
IJJKB	&
A
 2


 `
9 *+fi 	
 	Y	5-}	

 34	3
 C 	. "
 C
 3. 2

2'
 	
 	 L)M,[ #; fi )

 	&(_/. 
 %A
 ]
 	*$&ff>IJJJB	34. q
 %
 	. 


 2"* 	!2
 +`	 +fi} -'
 	"
 	C!)-! } 	

 
 
   	fi
  	* 









 
	 fffi  $fifi	 ff
  *fifi	 ff


 	 ff 
 

E



. 
*
3'	5	
 
 
 	00 A$`	5	3ff!
}	

3/	
	+	. 
3/2*,G		2
& 8*E	5fi'
[0!
"
 7
"	 8=*	. &4Mff
,	0
	2#;H


/Y %'
 2 	6fi

!	
-*

6fi


	 >
B->@'

-fi

!6#0* 


 )2
3

 +ff-! . ff
 +
 6

 	

}
  B	37 ) 	. *#;'
 	

  > B">@'
 
*[	5'
fi 		6 	. )
 	73<

 
*)! . *
 R
 (%} 	


  B	&H_/`
 	5fi 3ff`
 	
)#"
 


 fi

!-

fi!G"'
 #7
[
 	3
 -/#7 

 	34 !
. ,
  34 /34 6
 	6
 
3

'
 	C!+Y"'
 ,# 
[
 	"! . ,
 
 6 %>$ 	 	"G

# 	5"B	&*' 
 	
	6
 


 6fi


	*
 % 	. 
#;'
 	

 `	
 
, 2L)M,[%"'
 	<#, fifi

  0
 } 	

 . 
-ff!*&48$
>$'
fi #;!E
B fi 	0	
ff'
 
#ff .0
 -
 } 	
. 
ff!*&
` 4
"'
 4,   8
! 	
 :/'
 ff
 "
"'
 	$3
 fi 0

 	 ! =
H"
  
 	* !fi
 ,} 	

 #;H
 !fi
 ff	3
 -fi # !-
 !

[
 	&28 +ff.37
 
 )/2""' # <Y
U )QT$
U )Z). 
6 	'
fi 	,2`	 
	  2} 	

 &8@#4. 8	 !-
 *. 	2} 	

 #;H[
 ff3. G
 'E	5'
fi 	0
 .% 

 0#7
 ff}	

 "
 4&0
[ fi0"4
#$. ,. !ff#

 [
 	5fi!"
 
 /0
,} 0} 	

  
 ".
! K&G(
 ff

0fifi} 	
. ff. 
7} ff
 2
` _<'
 <3
0
 	0. ,'
 8	
5 fi

 q
!  #;<
 *'
 	

 
 *,} 	

 
. 	68} 	
 	
 5=;3
 )'
 ff2
 "ff-
 <
 	
 	'
 -. !
 	 
 2"


 , 
 ,-
 * & >$G
D fi*
 2"
 *  ff
G
 
 	5fi

 -
 

 	
 5=;	ff.0
  -fififi
} 	

 )
" !+
 G
. )
 ):/
5 	6!)"!
 	

'
 	& E
B H0 fifi} 	
 	 " 
`
 	5fi!/ ,fi
 &
` 	537
 )
E
 L)M,[3<`	5'
fi 		 "

 * 	. C>@
3QY.S #B *> B # 
 
 	

}
  #;H

 *'
 8 	)
 *"#4 =;
 	ff#4
 		


 



"


$# ! 





"

"

 
 ! 



%





& 

-

+

  
 
. 

/
fi











#ff5=3$/  &

/ &

fi&(#/ 

"

#ff-'

$/ 

&#fi8# fi(

/

/ 



/ (

'  fi&(# 89($
!#??#/ " / /  

 '@-#/ - $

?/ (?#" 

/ 

fi1))fi 3/ " "
(

($#fi1% fi!#" fi/ (98/ 5/ (fi5!>fi/ ?#" 3/ (

1)




 

2 


1) fi&#3" fi8#?#&-/ (

' fi1.3 fi!>/ 1)(#" *@&#!98& 

10

&#31))'@((fi ff

/  $

('ff

*,

'@(



(

!>fi(#/ " " / 1



' / (#'  fi&(#3fi*

fi


3( 3 >

fi )fi)

!>(# 8 fi*
/ (

!/  ff

N*N5O

&#

!#

*) ! 



&#3 fi!>/ 1)(# $

fi-&*fi/ '@
/

/ (fi

fi

" fi8-($	&



1)

&#

(/ / (






/ "  
fi1

33 fi!#" 3" "9fi  fi&" "

-/ 3fi3fi fi3

/ (!/ 3/ " "5?>





!#"  / (9ff



'@(9ff



'@(/ " "5 fi
!#??#/ " / /  

'@

&#fi)()(/ / (

fi'# u'}~'w`u''uw#w'

State

Users
Utterances
DB access

ASR/DB
Reward

User utterances
log-likelihood
semantic tags

Dialogue Estimated
Policy
State
_4
 9 ?

State
Estimator


2! 
	. 	R- L)M,[&4' 2fifi
C#,		fiC
G

 [
 .00 
0",
 '::	2!0fi#

'
fi 	 	
 


 *>@?ffAffB7!1"/ff>@M JB	&' 

fi
 	!2'
 :
: 	ff 3,5=	
'
 :
: 	ff"
 *  3<2
/ ,} 	

 0 . 	4 "fi
 " 	0#' ' A*
 	0'
 :
: ,"
 * 
 	

}
 - 	&

#$. 
*
8
+>@G6
37IJKJLA*FfiJ/3<IJJKB,

)*> ! B 

#> ! B  >    ! B/ 5 )*>     B	


 
 ! 

>IB

+# ! 

.0 >
B4
#	
	-

-"'	7 > B4.	
	*	. -"'	$&
E 2^
I-
-2
	'"#;}	,"
 #ff	"+2*	-+*.6
	'
 	. 
	-4
-
[&G_ #$'-4#$`_<'fffi
	!-	-. 




0 
  .	
 	4#  ff #$4. 	[0
	'
/3 1I3	#$<.	5fi'
[
 fi	6

  &-' 
  =;
 	,'
 :
: 	C!)3
\ 

 %[
I 
 +'
 `	
	)*. 

 6*'
 	
 	
 	C
 + =;
 2 

 6# */ 3QY.
S #2W@T #*)QT$W@
U &R
 > J#
F '


3IJJ MB	3.0
 	2

 	!+fi/	0[	
,# *> B  	2
 28 
=; 	 R
# 	

 "	 -fi4.0
 "0fi/0!
 	 ff
 GR 04
 '
 	.R
 	7& HIff
 ff


 -
 	fi 		730fi
<

 ,fi
 	!6>$} 	
 ",
	
	6"'
 	B,
"
 	%!) 	 	
+-} 	

 +. 
+-5
" =;
 28} 	


 *&2'7)`	5",`	
	 L)M,[(
-
 6} -"'
 	#0* 
fifi

 <3/
0fi
"
= 	)fi
 	!2)5
"
= ", 	. -
 	*#; 	ST$.
S ) # &
G(
 +
2fifi} 	%
2	 	
!(fi'
fi 
 /30	*#,
 
 Cfi +
 


 	-} 	"
[
 	
 )
"
*
= *#0-fi} 3)"
 
"
= )/*fi
!
fi "3.0
 * 	
 
 q
 +
 #$

 2
 +"*  +
 +} "'
 	$&*8@#
fi -/*.  -
 :
: 
3
'
 
= 	R"
"
	'
 ,!+-

 **#;	3
*% !%'
 
 	C#  	)> & /&R?ff
A   	3  =;
} 	
  	 	* fi 	 
6?ff
A 
	
 :/'
 3/  
, !
3/, 	 #/  
 
 	'
3 	& B	& 8.	E	
 *"ff 	
*
 !)-.
 "'
 0#4#  	G
 
 *!
 	6
 q"0,fi} &0G(
 "ff
 
fifi 	@
 +	W@V"SYQT$(W &.62+ -
 } 	

 26
 ]C
 
 C/R>$:
E 	
 	*$&3
]^^^
L 84'
 /3 ]^^^B	3-fifi} 	6
*6.+
 	!C
 R+ff` #;!R'
 	

 	
	
	20fi}
 *>$A
 Y
 	0$&37IJJJB	3 G
. -
 *_4
 09& J!2
 *"
 

 fi 	 


 %6fifi5
22
 23)"'
 #,/+ 
 	R+  C
fi
7

 "fi
 	!*#$,  	I
 L)M,[%
 -
 "


 `
 2'
 ff !* 	/
 	7&


  


)
+,



 

1) ! 

,

,

fiff

N*N*N

fi'#u'Ewu''{
	fiffYu'w

' 
 I	
 


 2#4
0fifi' 
0fi

!)
/"
fffi}	
[	!-#$

6	
#$["
+ 1	SW@Y4*2
*! "fi
"
=	
'
,#;
 =	fi
 
 -
"/&482[	$3< fifi	2fifi}	-
*
I& ? +fififi
	. +["#$0
	34)fififi
-fi	

#$"
)	3%'	
R+
+fi
	!C-fi}	%*6+	#
 

  ,} 	

 &8 2 !-	 ,!*'
 ,
 !-
 " 
  ,} 	

 <&
]&J
)


5=	)T)QW(&/W(&.6"!H#	 `	5fi!"/,	,>@
,
 	34 !)
[
 	,#;<
 } 	_
 	
 5=;0
3 } 	+# *}	
,. -.6
}*
	
  "
 B	&7I
M 	fi
0'
 	
 8
 	5fi!3
4! -
/fi
'  '	
	

 ff#;'
 	

 
!&

9& 	

,
	ff
-8fi

L)M,[)"'	,fi}&4' 


#
)
L M,[6. 
7',"'	
-fffifi
 0}	
 2	. 
#$ff
0!O}	
&

:/& ? fifffffi
7
"fi
	!)}	

0	IL)M,[&
P&

G	
fi[0ff!O
-ff	2
fi
	!&

' 8	50	
-'	
ff,ff#4
ff[	!-'	
*,`_<'*!*&

  . 

ff 
fi

.

` _<'+
2 =;
[-fi}+
-! "fi
'	,. 
+
#$
+


"2)
6`E	. 	!&)`_<'+

-
6*fifi*fi#$ #$fffi}

!">$E:	
<3[4
}	

$34\.	}3/_<
=	
/3F `0!<37IJJJB	3/. 
2fifi
#$"/ 	#$
 '
fi 	* 	
 


 )>@?ff
A ffB	3fi} 
 
 ff'
 '
 
/3	5 =
=;'
fi 	H>$' ' AB	3/ )} 	3ff
 R

 6
 
 [
 &H
` _<'
 ( 	2)G6
 
'
fi 	+ 	
 
= 0. 
2	
,
 
 
 +'
 '
 
 )"'
 	ff
 	2#;c
 	5 =
fi ,   	,>$:
E 	
 Y	 $&3<IJJJL:
E 	
 2F [4
 } 	
 
$34IJJPB	3
 *"' ' A-!  	
 Y	

 
 "
fi
 '
! 	
->$Afi0F H0

 3IJJPB	
& Hffff"

5 	.
 =;
 



 -

 
  ". 
2
 6*
M L)M  
fi
6
 
 %>$:
E 	
 	-$&3ffIJJJB	&%' 
 2
` _<'
 
/ ,
,fifi	)#;O
". fi
 "`	
 
 2
 #$

 2ff,#$ =
. 
 } 	

!"!'
fi 	* 4" [
 fi3 
"
3 
 	3

 0
	3" "3fi3
3/. 
 
 	3 2=	&ff
` _<'
 2
 '
 	
5 	,
ff/ "
 * 
	*  } 	

!
!'
fi 3
 

 <3< *
[
 ff#4/!+>@.0
 	Y
 
 *[
 ff
 	," 
 /3/#$ 
 <3 	
 
 B	&
8 #$!30)
` _<'
 R

 6
 
 " 
 
! 
 
 	2) * 	
 %
 	

!3
}
 

 - 
[
 0
	3 	'
fi 	

 	!&
` _<'
 ":<40 #$E 

+>$ %fi
!6-"
	3'
 '
fi 
 6
 +-
 



 B	&68@#0` 

 *
 6

 *
 	73,
` _<'
 (-#$-+
R>$
 (fi
!(+

	B
 <&C8@#"
` _<'
 %
0
 	Y
 
 %)
 30
` _<'
 C"
 	"
 %)	5

>@B	&)G(
 	 
` _<'
 6
 	#;!%
 -2
 3
[
  	
 :< *
 3
"  
 "I	5 
>@B	&G(
 -
` _<'
 *:
: 

 	)} 

 -
	3
)
 
 	
0/ ">$
 -ff. 
'
 -#$#
 } 	-'
 
 	2
 
 B	&_/
 !

 -
 
 
#0 ,
	3 ff!-'
 ,"
fi ,/ 0	
 	3.0
 	-. 
'
 , 	 	


	fiff		

N*N

fi'# u'}~'w`u''uw#w'

Nff

G	
	


` G	
	


[fi 
' !fi'
Hfffi'
Mff
	

Mff	 0}0 
A!O8



  8



L)
5 	)8 


 

_4
:4MI::

*#8


,#$A!O[fi&

,	&' ff*#`_<'*
	,	#; Iff2I] 	0'#$,
/!&-?0)-`_<'+
	,#;
!+->@
*`_<'+ff#$ff

ff". 
 B	30
 #$

 -} 



 2fi#70

 ,

"
"" 
	fi 	5*
 	*  	<fi '
 6>@M,
 
 	
FHG
N 
 /37IJJPLA
 '
 
 `	0$&3<IJJKB	& (
?0ff
  	C 37ff[
 	!2#$,
 ) 	
 #$ [
 " 
 )*fi
"
= -
 =

 fi
 	!+ 
 	,ff4fi
} 	

 0#$E
 } 	*"'
 '
fi 	
 
: 	78
& G4ff
[
 "	0
,
8
 !*#$ff* 22} "[	 	,}	

 	
 )> & /&3/. "
  ff.  
"!O*'
  -! C/
! ,D-
 2"
 

43<ff
 2"
"

 ff# :
E 	
 
	 $&7>$]^^^BB	&7_
G ff'
 0
 

 ,fi
 	Y
! 	
 	 
 *
 3/
 * 	*  
 
 !
fi
"
= ",
 `
9 I	
 	->@G6}  	ff$&37IJJKB	&8 )
` _<'
 <3/. " 	
 		2"} 	

 
	
 	-%IB,*!'
fi -#ff
 


 2+ *.0
 C
 ) 
 )#$"
 6
3
 
]B,.0
 	"_	
 :<  6
*
 2
 2
 	7&%' 
 *fi
0} 	

 -!+!
. 
2

 "3< + , 	0*} 	

 "'
 "
 2,
 &,' 
 "} 	

 q	
 	

 "
` _<'
 2 ffG
. -
 *_4
 	ffP"
  M&
' 
 ff ff!'
fi 	 #4
 


 " ff!O 	0 ff'
 :
: 	2
 *_4
  :/3 	2
 -
	"
 

 2#".
 *#"! fifi>U #*&-
 0
 W() #XT$(W 3*#>$Dff*3IJJPBB ! 3
 2ff!'

fi ,#4
` _<'
 ) 	 /
 *?ff
A O> ) #,+	T )W@XT$(W 3*# 
  &/
U & ) #,+	T )W@XT$(W 3*#B	&' 
 
	5fi 	-
 6_4
 2P).
`_<'
 
 %)2 -:<".)
	

 2" !'
fi 	ff#
 


 &-8@# 
` _<'
 + 	"
 2'
fi 
 	

 ). 
)Y
 
 = 	
 	
 
	3/
ff
,
 6S +,#*)"(W &/W@T$W@QT$(W 3*#> & /&37Nff 	50B	&<' 
 
 = 	
 	

 
". !
 	R. 
R% 
 


 %fifi3 '
  +	
 )#") 	
 	

 )
 	
"}
   -
 68 &28@#ff
` _<'
 +
 % 	*
 	

 2fifi,. 
6) 	
 		
	3 !1

 E
 +	*Z +	T #VH(W &/W@T$W@QT$(W 3*#0> & /&3Nff 	AB	
& E   !6
 ?ff
A R
 
0  0
 0	
 
= 	
 !0fi

0[
 

 	

62fifi&+8@#,
` _<'
 % 	-2
 	

 
 	

 6. 
%
 
 = 	
 	

 *	3
"


 6V"W #52W(&/W@T$W@QT$(W 3*#37'
  
,. ff ff-} ""
 



 *!2fifi!
 
 	5

#$

 R> & /&R
3 G	?0/,I L+B	&7' 
 Y
 = 	
 	

 *0
"'
 	

 	%) 	
 
= 2
0
G	5fi
 	
!2[
 

 	-
  
 	

 ,fifi34. 	7
 #$

 " GR 	
 
, 
	& ' 
 ,0..  #4ff:/ ,. 0`_<'
 2. !0 	0!




 "#$"
)
3<'
  00fi
 ff" G
 
 *
 !)fi
'
 ,"
[
 
#4/!&





ff

&

ff 0



)&#!#!>



(#/ (&&&fi8

  
  1

' &#(

 

/ (" / 



&#" $



?>3 ($# $

/ (

 

(&13?>3'5 -& fi-

#ff5=	#/ "   fi   '$##(#/ (0	/ (#/ / fi/ fi 2@="  6 =	#/ 83
 :fi:fiB#<345&#*4" "36 75(98

 :fi:;fiC8#/ !>fi/ (" / fi/ (/  fi1)1)(#"  !#!#" /  $/ ( !>($/ " fi0&) 1) 2@,9fi/ ( "@ff 89
 :fi:fi:Cff
;ff
	fiff   fi) / -fi&#/ " (# )fi/ (0)'@#-fi/ ?#&fiff
" 0fi" / fi)$#fi?fi

($

&#!#!>-'@'@" " &#!

fi& / (?

N*N

& ff

fi'#u'Ewu''{
	fiffYu'w

?G	

Nff 	A

[fi
G_	 	[
 ff`_<'<&[4,!*}5=


![
  42
! ; 
 } 	


	* #$4

0#} 	


	ff8
 .(&
G_	 	[
 2
` _<'
 <E
&  .H!)80
 	fi
!
 
8 
 .
 " [
  fi3
 
"

3 
 	3<

 "
	3<"
 =
"30fi3 3 . 
 
 	+
 
=	& [4  R!H
 H} 	

!B[
 
#;H
0
&
[4  	[
 "-} 	

!2!'
fi 0
& 84

 ,	<[
  
 

 -
 
[
 &
[4  +!% [
 )#")G
. %
	
!- !* ff
 
 		*
 <&
[4  ,
 ,[
 ," ff
 #$

 <&
[4   	/[
 G[
 #<G
. ff
	
!- !* ff
 
 		*
 <&
[4  )	,[
 2)
 

 C-!
  
  		-
 <& 84
 
 "	7[
 
ff
[
 &
G( 
[
 ,#4ff/!--!-. 
 
.
Mff!-.   "
 2"" 
 /3
 
,#$ 
 <3
 *I	
 
 .
 

Nff	5
G	?0/IA

G	?0/I,L

?0]A
?0]
G	?0]A
G	?0]L

?0.9A
G	?0.9A

[ fi '!fi'


	


Nff
	
 	

 

fi'

	
	



	


	
	



	


	
	



	


	
	


fi'

 	


	
	



	


	
	



	


	
	



	


	
	


	
	


_4
,P08


I	
	0
ff`_<'<&'  :< 	-fi'	
 :	 I[	#
 	

}
 I
 	 	fi
 
 )*-fififf
+"	 	<&-' 
_	
'
fi 	
 
: 	"-fififf!'
fi 
 +"#$q	
 +fi'	
 :	"!fi'"#
 	7&4G
? 	

 0  *'
 ,} -
 *ff[
 ff, ff'
fi 	*
 		&

` _<'

 `*!-,}	
#$#	:<"
}	*
3/.G-
-_4
 M&8@#
`_<'2 , [	5fi
	
!)
 #$!2*
3
 
ff
 # <YW@XW@TXU&,$)V"QT$W@U&)>& /&3
\45fi ? 
 #;]#$ff
<3R	5fi
 :	R!+A]-
+_4
2IB	&"?0#	5fi
	
	:<
"
!(
 


 340 	
 	
 ! 	 0<
4 	73
 " 
 	,#;Rfi	&
_/E
 	5fi 3<fifi0`	
 :<O"
[
 
,
<
 CMff
)!*!*!*. 
  --
 

A
,D/37.0  
A

, fi} 	6!2'
fi  	

 	+
 #"
[
 

>$" 
 /3/#$ 
 <3 	 
 B	&8@#
` _<'
 *
 	I
  
 ,
 `
! 	
 :<

 *fifi3


ff
  &/U-XU &,$)V"QT$W@U &2>@,`  ? 
 #} 	

 B	&
A 	!2#$0-fifi 	,# 	
 
 )
ff'
fi 

 C>$fffifi 	+*"  
 /3.0
 	
. 
 
 -ff"[
 B	3
` _<'
 
  !-
 
 ff fi 	 

 "#< 

 03

  *U #*)QT$W@U &+%3*#XT$U )0#4,I :,
 	&]ff
 	 } 	ff.0
 	4 !H 		

& 

 	

 	



N*Nff


fi'# u'}~'w`u''uw#w'

?G	

\45fi ? #I

[ fi 'Rfi

Mff
,!0!0!ff
		,
ff


A.A  

[ fi0'!fi'


	


Nff
	
 	

 

`  ? 
 #
\45fi ? 
 #;]

Mff






	


	
	


!R!R!(. *RC
(


	


	
	


    	 

=



!

`  ? 
 #
\45fi ? 
 # 9

=

`  ? #

=

Mff


!O!

  A
	 B



1
		

  A 

_4
 M ? :<
q	
	
*2`_<'<&*' :<I	+fi'	
 :	`[	
#0*}	
		fi
6)*fifi"
%-	]	<&%' -

	
 %'
fi 	
 
: 	*)fifi!'
fi )
 %*#$ 	
 C'
fi 	
 
: 	*2!fi'*#
?
 	7&' 
 ,fifi#$"`  
 # >  =	
 :<

 B } 	

 *
E
 fi!&

ffRoj'k
fiRpo

8jfi:o'

0j:m:j'klRm

Nff	">;NffB
? 
->@?ffB
?  :/'  ? :<[	
>? B

 *> ffB
'
 	>$' B
Nffff(> L+B

^3I
I3 ]3 93 :
^3I3 ]3 93 :

 
!+>0B

^3I

G(	ff!O 		*,
G(
 	*
,
0'
 	
 *.}	-
^3I3 ]ff#$ .,3<[
 	
*3
 )
2?ff
A  	
 :/'&93 :
#$#
 	5fi
 	

! 	
 :<[
 	73/
 2
 	
 :<[
 	
G(
 	
 0'
 
 	"#$R
  

 .( !-
[
 	E
  0
,0'
 )} 	
G(
 	q
 
 = 	
 	

 62 	
 	

 6. 
 	
G(
 	 ff.  ,
 *
 !*fi 	
ff


^3I
^3I3 ]
^3I

_4
4A0#	0*	&
ff	3*.0
	*
 ff!1
E!*fi
,"
<&4_/.}	#
9*
	3
:2
	"}	*.0	ff"! ff
	6-
 ff*
.00"
 
37"!<
 G
 	
 :/'
 
 )")>@
 #
	/B	3<"'0#
[	
-! } 	+2 ""*
34
 %-!'
fi -# ?ff
A O,"
 !2 	2"#$,
&

' 
 #$4fi} H
 
 	C!6
` _<'
 )#$,*fifi 	"#0  
 +
"
 	

fi  +*'
fi 

 " 		34/
 *)-/2fi
!_	
  - !6
  	7&
' 
 2

 )-fi} B	
 
 -
 
! )
 	30
= 	R
 %_4
 
& H

	fi	,#;('
fi 

 4 	
 ,0
 .
 =;'
 	

 	*
*&4' 
 0C	Nff 	D#  
} 	.0
 	 !  		-ff 4 ff> ff^3
! 	 "IB	%
& C? 
,D,'
fi 	
 
: 	
.0
 	*
,
` _<'
 -
E
  !*fi
""
 -
 
 #$!)>$} 	

! "I3
 

  ff]3

[
  93/
 ,. 
)
	 %:B	& C ? 
 :/'
  ? 
 :<[
 	
 D* fi 	 08	
 :/'
 
` _<'

 6,#$0
 
 +-
 #$ff
 +
&' 
 
 	^3I3
 6]* fi 	 ,







N*N







fi'#u'Ewu''{
	fiffYu'w

. 	30"
%(
	2?ffA 	:/'+	&
' )	F9% :C)	-.0
? A  C!	D)ICD6#$"q	:<
%	
<&@C ,D+}	".0	`_<'
ff
0
	6"#$
*> ff^3<!	 "IB	&2C'
	D*}	 "'0#
[	
,`_<'
 6,} 	+- ,,-
& C	Nff D-} 	ff!fi'#?ffA
,>@  "'
 	B,"ff!) 	+-
 2
2>$^ I
 = 	
 	

 3
I ff 	
 	
 B	&_4
 !3 C5 
.
! Dff fi 	 .0
 	
` _<'
  0'
 '
 
 "
 0
 28
 ,fi0#4[	
 
 

 6>$ ff^3/ "IB	& _
G ""
0,#;4'
 :
: 


 <3
ff0
 `	5fi 3/.0
 2
` _<'
 2
0.
 
 -, 	
 )
->@
 

 B	3"
!

 0
 	,^ff
 #
` _<'
 
 	E
 
 0
 } 	

!3
 } 	

! #
 8
 	
 :/'
 

*ff
 3/E
 	'
 	).
 
 
 	ff"
 *,} 	

!&
G I0
 0 fi 	 

_
 <3
 -ff
  	#} fi
 -0 fi} ff$3
'	
'
 	!*

  	 fi
!*
 	fi#;7
 #$

 - 

 ff,#;	&7_/.
 	5fi 3
 
 ff#   	5fi
 	
!-} 	
 ff 
 
 ?ff
A C 	 
 4/ 4
 	4
#;	
3 4,. 0} fi
 #$

 ff.6#   
 	#$4fi 	
	& E . 	
 	3
"[
 

 	% 34
"2'
 	

 %*"fi} -"} 	8
 _
 




	

 0,fifi 
 /&' 
 ff ff# C 	/
 	 I"'
 #7	"
 E
! M]3
 
fifi 	
 
 	

 "#  L)M,[+"'
 	/4
 4fi . 
 	'
fi 	 0}3 	
 
 

"
	-
 
 ,/& % ' 
 fi}  .  

= ,
  3""
 
$3/. 
} ,
 


 '
 	


 " 	)
 *,
 	ff#
# 
 G
 	
5 	
 
 	37
 q
 	
 :<

 2'
 	
 =


 0 	*
 -?ff
A O	
 :/'
 , 	 	 
 *3
 		2
! 
  .2>@M,
 
 	

F G
N 
 /37IJJPLG6}  	0$&3<IJJK<LE<

 <3/G6} 	3/F1G
D  37IJJJB	&
GR
-,fffi} " )} 	

 `	
 	,fi 	
 	!2'
 :
: 	73<. I
 q.('
 	
 UYW@XZ
XYQ +5+8	5fi 	)
 2E
 	5'
fi 
[
 3<'
 :
: 	)*'
 ", 	0#'
 	"
 

-fifi
 0#;
,	 
 2.0
 	2,! 0
 	
 "--fi
	3/:/
5 	q
 	
 &ff' 
 , } 	

 
fifi
 % fi 	 
%
` _<'
  -

 )fi
 	]
! 	*\8 ? >$\45fi!)#$8 



 +
 
?  :<
 B4
G
. "
 _4
 ffK&_/0
 } 	
 	
 5=;3.  
0.I
 	
 	#} 	

 

 &*>$' 
 "} 	

 q	
 	,
 )#;} - ,"
 	G
 	
 !)
'
 
 
: 	%0fi
4!
*  
 %fi
 	3 C *
  	R
 6'
 	
 	& B A
 ) 2 E:
] 	
 5=;	
. 
R]6} 	

 	
 	q
 } 	<3)G
 "'
 #"'
 
 
 6fi
 	
 	)
 C
Y
 	*
2] K $ & 8 
 fi
 *. 
-8ffE6[
}
 	!-'
 	 
'
 	6
 3 <
0	fi"
 2
fi [
 
 "fifi5
	!,fi
/fi
 	!
 "
4

  	
 , 
4:
# ffE*fifi
 	-G	5fi!

 
 -

 	&
' 
 fffi
 	Y
! 	
 -_4
 ,Kff
 
 	2!-. 
 -8
 	
 ff#!1 
 



 
.0
 	 ,*! 	)), 2#$,
 6
3
 %!6. 
 6Y
 	
 *#
	
 :<"
 ff
fi!"
 0
 ,0E	5
.0
 	
 !  
 	
ff
  #$ 
&_/.
 	5fi 3
  
 

7.0
  00  !	 		
ff ff5> C	Nff 	D,0
 ,^B	30!H8
 	
 0#
 "0!1
 


 



















 

#ff 





  

&/


/



 

 
  


 

  
 
   fi

	
 0

&(

  
 
 


 


( $#(

' fi1%

( $#(

fi8-







+

fiff

&!#&

/ ( " &$# 

7fi $(	$#fi

" & / (#

(fi

)!#!#fi/ 1)fi"

!>" /




 B#ff A

/ ((

 fi8#

'@-)fi

3/ (#/ / "-$/ " fi0&

 fi

/ " " ( fi

fi

B




(

B)B



fi

fi0(#/

$

/ (0#8-?#&



B #ff



!/ / ( ff

fi& fiff - 

&#/ ()$/ " fi0&fiff

N*N5P



fi

fi / fi $

$# #( $	

1)!#!#/ (0



31)3/ (#'@1)fi/ (989& fi-
$#

 fi1





(fi-/ ( #&(



!#" fi890   B

& 8>" "5fifi -?> 0/ (#(#/ (0/ B

&#ff

" 	(

$# fi" !1)(# 8

fi-fi'@ fi&#  ff

&" " 

B)B



!>!#&#" fi $



 fi(#&"5$#fi?fi

(fi $

fi -fi



 fi&" "

:#ff -$/  & $?> fifi8>3  1.& -/ -!>fi/ (
" & 3' !# fi/ &3fi/ ?#& -'@

(#"

?/ ( $	$&#/ (0  1



/ (#"

2@fiff 0#ff



&"

' &&#3$/ " fi0&

	B




3B

!>fi/ ?#" )/ (
B




B



B C

fi'# u'}~'w`u''uw#w'

B

4



 /
*

fi 

B

B

B

0




B

B







B




B







B




B













B













B







A




B







A




B












.


B

B

B



B

B


B


B



B

.
B

B

B
B

B

B

B
B

B
B




A



A

B

B




A

B

B




A

B

B




A

B




B

B




A

B




B

B




A

B




B




A

B




B




A







B

B




A







B

B




A







B




A







B




A

A




B

B




A

A




B

B




A

A




B




A




B




A



A



A

.
.











-

-



B





B





B

B

B



B




B

B
B
B




B







B




B

B

B




B




B

B








B







B

B







B

B







B




B





B








B



B

B

A




B

B

A




B




A




B




B

A










B




B
B

B















B




B




B




B

B







B

B




B







B

A




B

B



.

B

B
B

A

B

B

B

.




B







_4
"K4\8 ?

45/


ff






B


B



/ (45/



 

ff-   / 8 	ff

fiff58 +->

4(#'8 ff
4(#'8 ff
4(#'8 ff
4(#'8 ff
!" 8 5# fi!>4(#'

!" 8 5# fi!>4(#'

+->
 / 8 +->

fiff5 8 +->

A / 8 ff$%

A / 8 ff$%

+-A / 8 fiff$%&
+-A / 8 fiff$%&
4(#'8 '$
4(#'8 '$
4(#'8 '$
4(#'8 5# fi!>4(#'A
4(#'8 '$
4(#'8 '$
!" 8 5# fi!>4(#'A
4(#'8 '$
!" 8 5# fi!>4(#'A
4(#'8 '$
!" 8 5# fi!>4(#'A
!" 8 5# fi!>4(#'A
fiff$%5 8 +-Aff
+-A / 8 +-Aff
+-A / 8 fiff$%&
+-A / 8 fiff$%&
4(#'8 5# fi!>4(#'4(#'8 5# fi!>4(#'!" 8 5# fi!>4(#'4(#'8 '(
4(#'8 '(
4(#'8 5# fi!>4(#'!" 8 5# fi!>4(#'4(#'8 '(
4(#'8 '(
4(#'8 5# fi!>4(#'!" 8 5# fi!>4(#'4(#'8 '(

[
	! ? &4MI::

0#$0#	 ff
*
*_4
&

fifiIC[4-!+6}	

!_[-ff! ; 
}	


	*#$,*
"#ff}	


	8ff.
& D), 
 


 "fifi2C5 .R!-8	fi*!,D+?00#	5fi3'	
	

	
 :<

 ) 
 -ff	 #$ .0
 	) C 
 ,D-#  "
-I&ff8 )	 "	3
-!  _	
[
 	
 :< *
-
 *
 	+#; -?ff
A "37"} fi"

 0
 
 2 )" 0
 -8	50
&

N*NfiD

fi'#u'Ewu''{
	fiffYu'w

'7I
 	50fffi
fi
	!
 fi
	!	\8 ? 3`_<'[		)Q&UV"YZ"'	. 
 .ff}	
4#$.0	0	
5=;0


<35
"
=	
[	5fi
--"

"
=5=

ff/ fi	.08		
ff
L)M,[)"'	$&4` /0 "
=

 	#$}	
	
3fffifi
-_4
	 P,<M" '	
	280G	
#fi
 } 	

 - 
 	&
A 

[
 ,-0O
^-I,^^^^^
I"I,]*I,^^^
Iff]]*I,^^*I
I 9]*I,^^*I

I :-^^^^^
%

?G	


'

G	.

Nff	5
`  ? 
 #
\45fi ? 
 #;]
\45fi ? 
 # 9
'R	

A<I

^

A]

^

=



^

A9
^

A.:

I

_4
"JNG
,
,
*_4
I&
_4
 "J
	,. "

 fi
 	
! 	ff
 2_4
 "K
 	0"

 "
 
_4
-I&\}	2.R

	ff,ff0`_<'2
0
<3/"}	
Y	5	2
2
03
	 	fi
 
 2 )
 )_4
 2I3
 + 	. + 	

 	7&*' 
 "
 

 fi 	 
-`_<'
 %. 
 :<-fi"+
 %
+I&C
` _<'
 	
5 	2Nff 	5 >$
ffG
. )
 +_4
 -K3Nff 	A)
")fi
 B	34
 
2":<,
 
 +_4
 2I&
? #$0- ,  , 	fi
  37	5," fi 	 ,ff`_<'
 68
 .1 		)- 
 2
 	)} 	

!*

 . 
)
q
 	
 :/'
 37!)
 2`
 
 = 	
 	

 "	&
` _<'

 %	 	-2`  ? 
 #,} 	

 <3+

 	Y
 -fi_	
 :< )} 	

!3
.0
 	
  	 I	  0 "fifi4"'
  
 	7&4' 
  
-  fi 	 
`_<'
 "
E
 .%.
 ff
 "  	
 -
,>@
 

 B	34
 !

 
. 
)

 	
 :/'
 )>@
 

 2. 0
 	). 
)} 	

!)#$  ,   :<,
 B	3
 6ff-


 *
!)
"7&  ' 
"
[
 -
` _<'
  	 	,-\45fi ? 
 #;]2} 	

 <3
 q

 	
 :<" ,
ff. 
*, 	
 2
` _<'
 )
 3/
 *ffI	
 
 	0
 <&
' 
 "fi
 	
 *#4
[
 ,
0
"
0 #
 

 <3/.0
 	2 ff
` _<'
 2ff:
: 73
.0
  *
fi';#$""2} 	

 BCR
' 	4 D(> 	 	fi
 
 +
 !
 +*/ 34fi 	 

, 	0, 	3< 2
 -,  -fi
'
 " 	. /B	&4` ff 
 2
` _<'
 <3/
 	. *
0. !0[

^ 	
5 fi0 ff"
 73 G
. -
 *ffE	
 *#4_4
 ,J&
_4
 -I^
	" 0
` _<'
 2

 0.  
 	+
 *\8 ? fi
 	!
	&`  4 

 	 
 _4
 	0I0
 )I^0
 
0.2
 W #*) #*&/T

 ,fi
 	
 	

+-\8 ? fi
 	! 	&-_/I
 	5fi 346
` _<'
 6'
 	
 +

 	"
 +":<
0
 *_4
 "K3
` _<'
 Y	
5 	,Nff 	5(
 *
 ff

 
 )Nff 	A-
 *ff	&

0  fi

     O
fi 	'   	8 

 

G_			 	5fi'
[
	,#$ff)

)+	
2ff!*&'72


 
 )
	34. 
fi[	C`_<'6
)-\8 ? 
*fi
	! 	"'	
'	




fi
fiff5+-

" "9fi5(#"







 5'@ fi&# 5/ (

&#(#5fi/ ?#&

/ (#'@1)fi/ ( 0fi$/ (0



!# fi/ &3fi/ ?#&  ff

N*N







 

-fififf  fi8-!>fi/ ( fi





(#/ (

fi'# u'}~'w`u''uw#w'

A<I+G_		["*`_<'<&ff[4"!22}	

!q["! ; 
,}	


	*/#$0
ff#
 	


	,8
}
 . &
,I ff8.2
} ,"

ff

 ,
,
 2A'fi ,
0"
/&
> 1UST <ST %'4US4Y *Y"W !#"T$U-(T -.# U2
U -"W +	T$
U )W@X +	W@T #,+ff(W &I+	T$
Q &-U # -W"+	T$U)W@XB
A
] +Mff
2!-!-!- ff
  		2
 *
 -"=	.
 
0] ff` /&
A968
 .(0" [
  fi3/ 
"
3 
 	3<

 ,
	3" "3/fi3
3. 
 
 	3< *=	&[4  ,!-
 *} 	

!q[
 0#;H
0
&
%9ff84.*
} ,"

0"

 ,
&0> (UST <ST %%'4US4Y *Y"W !#,T$E
U 3"W +	W@
T -"W +	T$
U )W@X +	W@T #,+B
A.:+Mff
2!-!-!- ff
  		2
 *
 -

 ,
*
:%8.	&
A
P 6[4  ,
 "[
 ," ff
 #$

 <&
0P  ;S +,#*)%+	Q*Z + &/U(T -(W &.6
AM6[4  0	<[
 0 
 

 4!  
  		-
 <& 84[
 
 -,	<[
   
[
 &
%M 0

,"

 &ff>  UST <ST  E-QT -"W +	T$U )W@XB
A +G( 
[
 ff#4,/!-!. 
 .
 
 ffA'fi &ff> &/0
U  UST <STB
A
K +Mff!-.  "
 *," 
 /3
 2,#$ 
 <3
 *I	
 
 .
 
0K %L) 
 /&
A
J +Mff
2!-!-!.   "
 *," 
 .
 
0J %8.	&
A<I
^ 8 #$'
 CII

 -
	"
 +E
` 	.  	!+, '
fi )
 +-" 
 /&*' 
 ":<09
&	&	& G+2!-
} "
  " *
,I^ ` /&
A<II '  -!#$ 
 *ff!*&[4  ,

 "[
 ff# 	/} 	*!-!
 I
 ; 

 
3 ;  =;
 3
%
 ;

 &
,II 4J7&











 



 	

_4
-I^?I 	 5fi,
". 
*`_<'<&

)A	
<:/&G_"	2	,
	ff-
6`fi

 L)M,[3/2Y	fi	2
fi
/

 fffi
 	!-
 
 L)M,[R>$4'
 	 
'
 	*
 *
A 	

 E9B	&8
	
".  '	
'
8
 	5'
fi 
[
 '
 	

 % 6-  	%

 2fi
 	!&68 6Y	5"	

 +. *fi	
 	#; 	
,4  	*fi
 	!*

 .C4

fi
 	I
 	fi 	

 -	3
fi ;#$ ,[
'
  ,. G	 ,"fi
"
= &
\45'
fi 
[
 4 	,.  "?' FffP
' fi
! 	[
 "
 	
	+. 
)-
` _<'
 +fi 	&
' 
  -.  *P :2 	,#$ff
 
 6
 %]I"#$,	
/&)A 	".  -

	%)

 
 - -	
fi .  ff
 	-#$4
 '
 	3#
\ 
2ff:<
 
 3
 `
 	5'
fi  =

 ". 
)fi} 2

 !"& $ '
 
 ) 	0.  "
 #$[
 	60'
 	
 '
 )#
[	5'
fi 
[
 ffff`_<'
 )"
G	
 
 "
ff'
 
0/
 *[	5'
fi 
[
 3<
* 	0#
.  = 	2
 
 	

 >@ ff?fffi'
fi 
52?ffB	&












Aff

/



&#? fi&(#



'@

 ff



("  



/ ($/ fi $



fi)  1



!>'@1)(

N*N



$/ $	(fi)$#!>($

/ 0(#/

 (#" 

(



( 	' 

fi'#u'Ewu''{
	fiffYu'w

')I& 84)  	+,["
 L)
.G-+-
!)#$<&  -`_<')
::)""O"/&
'2]& 84)

 ? fi'2L+!2+. 0*}"[,#;
,+q	
q
&
  ,
` _<'*"::* .0 !fi
0&
'E
 9& 842 ,
 	)
 2A'
fi ,#$ 
 !-
! 0ff[	0	*



"

-
	&*'7/!)!+"#	
+
&< -`_<'+*::6,.0ff!

 - ff
ff" 
 /&
'2:/& 84-#	7
!*2.  [,. 
	
-
*""
/&?ff,
!. 
 
	I	"!-! ff
2E7"'
*
'P&4? #$-/!-#. ?' Fff'R
-_4O[4/3!.*
},-	5
. 
2 Y	
2 ,& "`_<'2"::) 
 #
0
,fi
"-".
_4O[4/&



'EM& 84*
"
I	! ? 
!3<2. -fi'2"#$Y !
Y,
ff. 
0'
 #;$&?ffff,!*fiG!
_4
II4'
&



M,
 CR
 
 R (	
/30 	Y
	(*#;5=$#$T	
*. 

`_<'2	fi	,,
52fifi

) 
*_4
-II&_/ 	5fi3/,	5	
!)- ff
 +_4
 2I. ,'I
 :2
 +_4
2II&-A 	"_}	)*'	
fi
%!

 ++) fi*. %fi #$[
 } 	6C>$} 	
 2#; 2
 	5'
fi 
[
  . 
fi B	3Y 	+
` _<'
 -#;H	
 `
9 ,fi
 &? I2#4ff/3
` _<'
 )} 	-#$
#	/} 	,
 "	
#
 	5'
fi 
 -> & /&3
 0.
A :,
 _4
 ,IB	&   '
 fi"0fi
 
 ,:/ 	*4ff 4 	!,

 ,. <3G
. ,
 "_4
 ,I]&[
 0 	fi
  	4#$ 
 	

 
I +]- "G
. <&ff' 
  . ff-,:< 
 	

 C> 6U*U
+	U +	U 1Q B0 fi'fi 	)+I3
^37  =I37 	'
fi 	
 	!&-_/0 
 
 
 
 	

 3 ,
 
 	6"2#	

 [
 02-P-fi
 ffE<
} ff 2(> } 	/3/_/	3/F A
 #$73IJJ]B	3. 
* 	fi
  	
> +	T )U &.6YZ)*Q 6) #5# +	U0
V #*'-QT"*Q 6) #5# &#W@(T -.#*)**Q 6) #5# &/
U )<W"+	*Q 6) #5# +	U0
V #*'-Q0
T W"+	*Q 6) #5# +	T )
U &.6YZ
W"+	*Q 6) #5#B	3.0
 	2 ,fi'
fi 	2P")I3 	'
fi 	

 	!&
?0,
 		6!+Afi6]*#`ffEC[
 	!)'
 	 
'
 	%
 6
A 	

  937. ":<"

T )Q(W &/(W &.6) 
 6#0*!*34
 +2\8 ? -fi} 2 %} 	
  	
 	
 	C
 
-fi 	
 + 	

 <3" 	 )
Q &UV # <Y
U )QT$W@
U &<
& J!+
,. -[
 
 ),
6
 !)
#$.0
 	2. "2'
fi 	
 
: 	6[
 	
 "#!O} 	

 3/,
 
 -!c
 	 "
 "!
"
 +2. 	R} 	

 . 
%'
 
 #$ fi

!&R_
G 2
  fi
= )-#;} 	
*. 	 	
 	.  '
 	

 	%
 %*. !)8 	%"!)

 *
 	%!

[
 	5fi!2
 
 )! . ,
 


 	!6 
 *)2
 + 	34
 6'
fi "
	
ff
 	#;R
 	fi 	

 *#4 !-"ff!H. 
 '
 	)'
fi ;#$*&4E
` 	
 	 	3/


,
fi0Y"ff  	
ff"
fi `,*"!*3/
 
 ) ,!2
 
5GR	

 	
! 	5'
fi 
 	%"
fi -

 -fi
 	
 	2>$ff
 /
 	%!*-
 c
 	5fi

 B	3
.0
 "	  G
 	5'
fi 
 	+"
  3:/
5 	73/'
 	"
 

fi
 	!&



ff









& 

N*O





fi'# u'}~'w`u''uw#w'

[4,fi'>@
B!#	/}	*
E	
<&0>6UU*


+	Uff +	U

Mff
*!`	fi	,ff-*	 ff
#$
*!Y	'	C>Z#,+

1Q"B


&/U"B


8-
G	
<3
0.   !-"::2,fi},084. 	7&
8-
G	
<38	.(.008#	2!-E}	*fi
0
*ff
&
8-
G	
<3`_<'2''2.0084
7&

J	*-,!E	5fi'
". 
*
-`_<'<3/8 2,`_<'2	!-,::2
fi},".028 O. !,#;O,!`	fi	&
_4
-I]  	!&

	

' 

,fi#/ 	 5fi'
[		
09II.	fi	 
	0>4

	fi		)<B	3#$.0
	2`_<'-	*ff,#	*I		fi


	5	-}	
&4' 
 	4"	
	
	-290*II4	3

	fi'	
	!& 8-

	3I"'#fi	fffi'#$ff


4[	
	
 
^*I,^^"^^^
Nff	A "IPP
Nff	5 "IPM
I,]^^"^^^
?0]A ffJ 9
?0
] 
]
I,]^^"^^*I
?0]A 9M
?0
]  %:K
A
 	)/-
	"ff-  } 	

 	
 *[
 	+# 	5fi

 ) 	62#;
!
 	%} 	

 2



 6'
fi ff&,A
"
!344,fi} 3
 )"#;} 	ff
. 
 !+. 	6]2} 	

 	
 	'
fi ff37fi 	
 	%-/-fi 	"fi *&*' 
,


fi' 0 fi
/

 fffi
 	!
 	-
I
 ffE-
 '
  	
 ,4
#; 
 !


	2	&4' 
 0:< 0
 *_4
 ,K3ff
 

 #$ 	
 !-

 3.  ,"
#; 
 !"

	ff>@. 
09II

B	& HI!-K 	4.
  #<0

 
.  ff

	2 	0 )I^"
[
 	&
' 
   	-/ff. - 	-8	
 
 	Gfi

 
 L)M,[&?0. 0
 ff[
 

 	73
 [
  . #	  fi
"
=  
0
 !" 	. ff#;'
 	

 " 	"
 ff
 
 	fi
 
  "#`
[
 	fi 	

 <R
3  	 [lm:jp
R 0oklRm4370}
 	ff
 2
 2I"
 # 
` _<'
 

 
 	""/ 
 
 	5} 	!2-
	ff'
fi 	
 
: 	%
 +"*'
 	 
fi

 <34
  =I
. 
 &2A
 *! [
 	C'
 *	
 	+. 
+.0
 	6# -
5+ff* ,. 
fi
/37
". ,fi
 **
 	! 	fi"#; ! ,.0
 	,I
 ,
 4[
 	fi 		 /
& JI
! C	fi 		
 Dff.  [
 
 "
 
   
	0>$} 	

!
!'
fi 3
 

 <3 "
[
 #</!B7ff 	5} 	4
 	'
fi 	
 
: 	-
 "ff'
 	 
fi

 "

 "
 
"
 	
	2. 2fi & 8 2
0. !'
3 } 	2
 
 -

 ". 0
!2'
 	 	6!

Iff
 *I ff#48
 	fi 		2/3 ffIff. 
 &4_
G 80
0'
 :
: 


 *#4
	fi 	

 ) 	 0" ff
 )
 2
 !2"/ 8
 	ff	
 *
'
fi 	
 
: 

 E
& G	5

  #4
ff 	. 2[
  3/ . 	4 !'
fi 	0#[
  	
 	+ ff'
 ) 	)  	. 2[
  3/ ff
  	2
 *[	5  	

 <&
_4
 !34. 	fi	+fi


 *fi
 	!6
 +
"  	 L)M,[(
  =;
 



 +> #&
A 	

 I9B	&4' 
 ,} 	

 Y	
 	G
 	
 

ff  	)fi
 	!) ff
 2#;} 



















$,

NN

fi'#u'Ewu''{
	fiffYu'w


-_4
ffK&4`  E8	
ff. 4:/5	-#$4	/	ff>& /&3CI"I:^,^"^,^DB	3[

ff =;	". "
'
#$ -

<&"' 3:	).0+
2"	
fi
 	!37
` _<'
 *
7[	
[	G		0"!*'	. Y
*}	
2fi
&
8 


 	!3   	-fi
 	!!4 fi
 #<



0
,'	
". 





 3/-} 	" G2[	
"

5 	*!1
 



 ,.0
 * 
 ,#$
 -
&
` 3. 	 	34'
fi 	
 
: ff} 	 G*[
 	"
 GR4. 

,> & /&3!(
 



 
#$
ffI34!"

5 	
 



 #$
 ]B	&7GR
" 	'
fi 	4G	
 :<

 <3
fi
fi
 	!"
ff
 I
! 	
 :< . :
 	
 :/'
  
 	&?0
 <3. 	
 	3	fi
 
.0
  	
 :<

 6'
 	[
 	'
 '	!+
 GR"} "
	*> & /&:
3 	
 :/'
 * 	
 	]
#$"
)I3[
 	
[
 	". , 	
 	#$"
	]+
  9B	3
 %+'
 '
fi -
 
#  	#700'
 	
'
 	E
 	
 :/'
 *> & /&34
 *
!B	&4' 
0 0#7?ff
A 
	
 :/'
  !ff

  fi
 	!,
" 4fi

	"
 ,fi 	
4fifi} 	
 	3 & /&>$` 

"

FHD0!
$&3<IJJ MLE<
 2FH[4 <3/]^^^B	&4
` _<'
 Y
 *  *
 	:
: 5=;
 	)

	

 
  --fi
fi
 	!6
" 	6
'
 +Y
 	fi

 +#0] K $ fi
 Y	5fi!+fi
 	
 	&
Jff
 


 " Y
 	
 :<

 * 	 
 	ff'
 	
 '
 *#ff

 ,. 
ff"fi 
0#$
` _<'
 <&4_4
 "I0
0
 	5fi ff

 ,
 0fi
<fi
 	!&

,

  fi

.

     #  ]      O
fi 	 	8 

 

_/,-	
+fi3`_<'6. 	
fi[	%+*+>.H'	"


B	
fi
 	!&]I,	0 	ff)'
fi ;#$[	)"[,
52ff	+/
*

/3	


CI] :Y	fi 		,

 	&-' 
 -fi

! fi

 	ff# -fifi 	6[
 	!

3 I
# 	 3q	5*C

 

 
 
: 
 +#,2
fi
 [
 
C) 	
 	!
fi
"
= 	)[
  ->$
 !-[
 	fi 	

 B#;Hff
 
 "	 fifi

 &8 -#;} 	3
[
 	fi 	

 2 [
  	2! [lm:jp
R 0oklRm+
 	 
   3#; P
] H
 -
 
 
2M:H
 -	
/&' 
 0#$. 
  	

 0 ff'
 		-",
 !
 #4
 	3. 	7
	 7 		2	&








	

R

fiff

Rjp}lm:r_k}s:o_.ojpm:o'n

:l}]k 



k}s:o

ff

pjlmRlm:r

:l}

')I
=	"

)"	
)fi';#$#0`_<'<3#$ff
[	=


 6[
  	q
& G"
+<9II
 
 +

 	3
` _<'
 % 	C
 "_
! 	 
fi
 	
 	0
 ff\8 ? fi
 	`
! 	&8 "I] :ff	
"

 	3
` _<'
 * 	- 
  ff  	
fi
 	!&-?0)  	%fi
 	!+. fffi
"
= 	+#$0
 !)*
 	"[
   [l
m:jp
R 0oklRm437
 !*!'
fi 	0#[
  	ff
 "'
 + 	2`	"

 "!"
> & /&3/*
 	37

  
!R
3 `
9 	
 	!34

!R>@M,
 
 	
FOG
N 
 /3IJJPL7Dff
	 $&3<IJJKBB	&7_
G 0 	,ff'
fi ;#$
 0#ff  	2fi
 	!*. 
- 	'
fi 	 
ff

 4 	. *[
  " 2
 "'
  #4fi
 	. 2[
  	  . ff

 fi
"

= ,ff	 !H#$	&
[ fi,,",
fi"	 
= 	6
 6":<,.). ff#0' +I&
0
8 -0:< .,3. 0

= ,'
fi ;#$
  #$ [lm:jp
R 0oklRm6
 	. -[
  3

  	6
 )fi 	
 ) 	

 <&' 
 -
 
 ,
 #
" 	. +[
  	+} ff
9II,
 	ff 	+
 *" "
= 	+
 
 *!O. 0^ ^ :K2>$ 4"  

 ffI0-IB	3.0
 ff0   
 ff#7
[
 0[
  ff} 4"I] :,

 	0
 "
 	6	ff! . ff^ ] :/37 2
fi
 [
 ff,,2
fi =;
 -# ^ ^PJ
 +-/









N







fi'# u'}~'w`u''uw#w'



jfi:j'klRmO6oj
fiRpo


J
! ? fi	

G_ ? fi	




pjlm

^ ^ :K
I ]
] :K
^ IK
9 9K
9 I
9 :]
] K 



^ ] :
] IK





9 P]





 

 












9 M:






 



] 
 ]



jfi:o

^ ^PJ
^ ^]J
^ 
^ 9K
^ :]
^ JK
^ I
^ PK
^ PP









^ .
: M
^ IJ
^ ^ 
^ ^I
^ ^ 
^ I
^ IP



] M 
^ II
9 9J




^ ]]M





?ffA
G_#	/}	
\!
G(!
` _<'

 2'
 '
 
G




#o'k



'-I '
2ff	fffi';#$"#$ 
I	
+[	&,' ":<G	
fi 	 2
 GR -[ 	
 	
'	H>@*	5"#$,'	
B	L 2		 =

 2
ff"  ,
 "#"[
  "
 	)
 2"
 
 */L/,

	
 +
"-  "
 -
 	6
 +	,/L"#$	
 +. 
"
 GR '
 	. 2,	ff
 
 "
 2"
 2
 
 ->$-fi


 `"'
 

- C. 
 .D/3.0
 )_
 	

 Y"'
 
- C DB	L:#$ 	
 Cfi 	 


7

 
 
:  "
 ,
 	)
 -ff/* =;	&



.=;fi" =;	00 	,[& * ' 
,	8		fi,*)
fi[0#;
-P]c	fi	
)""-,

*
	,-EM:c	fi	
)""-
	


 	&
' 
 , 	
 ).(#' -I,.  0fi';#$
 "
fi
 	 #; 
 
 --	

#$ff`	 	!% 		%[
  `Poj
R 0oklRm KY
& Poj
R 0oklRmC
-2
 	
5 	
 


 ff#E
 	fi 	

 ff7
 	4fi
}  	
*
 #<
4
 	 .	
R
 	 	7
. 
'
 30
 ,
0 #7G	 	E"'
 #4
	& H0. 
 3/

0
0.0
 2> & /&3ff !0
 CE7"'
 
 ,D* ff! 
 0
 CL)
G
. .DB	3
 

 0
 =I&' 
 0"


 ,#$
"   :
: 	*[
  
	. 
 =I 
 
 	

 #$

 ,'
 	
 	". .
 .	
 
 	"
 ,/ #
 	fi 	 	"0  	3
.0
 
 =	
 2 	. %[
  ,*
 #$

 6'
 	
 	C. "fi 	 3fi'fi

 	C
 C) " 	#0
 	 	 -
""#$" 
 	-#02 	. 7&%' 
 *
 
 


 6  2#,.  	fi 	

 R. )I ]R>@.0
  2+
 
 )
 ffI) 9B	3 .0
 +
	,

 2  ". "] IK&*' ". *
 -*
 -
fi
 [
 3
"
[
 -

 
 
: 
 
ff-^ ^]J 	 	$&*_
G ff-fi
 	!6
 		6!)fi
"
=	
 )
 
 I
 L)M,[R#$

 `
! 	fi 	

 6>@.0
 	*. 
fi [
 	2
 *ff	!B	3
 *,fi
 	!2
 		2!
fi
"
=	
 -ff
 
 E
 L)M,[+#$. [
 	fi 	

 6>@.0
 	-. E
  
fi [
 	/B .  0
 !

"
	3/. 
*
 !- !*"
  
 GR 	0
 2} 	

 `	
 	&





 


 

2


 #ff4( fi(#/ (" " fi89)!#* " &
(	ff 
 B)


 #ff5=



!/ 1

 1

!#fi/

/



(/ $# $









.



 
 

	ff
fi 



 

' "  (	ff B 3/ 

/ ($/

fi

#/ )/ 

fi1

!#"  / (

fi/ fi

(/ $# $

?>

 

fi/ /

" " / 0(#/

'5)fi/ / "5($>ff



-/ (

fi/  8>

(0fi 5'@5 fi">$/ >(# " &fi/ (

(#"

" $# $

1) fi&# #/ 

N



fi1

!#"  / (/ (
/ (0" 

&#" $





   1





 (# 8

  1

fi

8>?#& fi1



#/ " 3!#* " & "  
fi)$# / 0( $



/ ( $!>'@1)(

" 3 fi?> ()& $)fi5&#5 $



1) fi&#fiff

fi'#u'Ewu''{
	fiffYu'w

' )[2
C2
(.,3qi234
2

%#



[lm:jp

0oklRm4&

R

 . 	 	3
*#R	
",	3qiB		
  
!&8-fi
	3

Hfifi5
	4fi'		

}}	!ff#$/)!3
.	fi	-!

qi


*I#$0}	[		
 ff*& P #$.	!,. 
'7&' 3
 #7 ff
,
. 
 	
Y0E7"'

2""
/3<2,! 
	ff,/ff#$ 
 	

!-
2`E	.B	!*
*,"
/3 [lm:jp
}
R 0oklRm =I3Poj
R 0oklRm "I3
 

 qi ff]&6' 6I-. ""2
 
 -
 2#0?ff
A  
   	%#; ] :K*/


 
 -*] M ,/
 *	
)>@.0
  ,"
 
 ff
,^"E9B	3/"

 
 
: 
 ff
fi
 [
 >
^ ^ :B	&"?0
 <37
"
fi [
 ff 	 	
 ))  	%fi
 	!% 	+#$0	

. E
  fi
"
= 	2#$
 qi2&
' 
 " [
  	I
 	
 
'
  	+-#;0 *.
U 1	,#XT$(W 3*#- 	. )[
  	3<
 )"  
- 	. )
"fi 	
 	!6'
 :
: 	%"#;'
 	

 +#! 2
 )*

 34
 _
 
 +'
 
	fi	2
 	!-#;H
0/&4_
G 8O
. 	5"
 ".('
fi ;#$
 8	
 
 	#;H
 
 
-	ff.0
 )- 	0%
# +	
S 1	,#XT$(W 3*#ff

!+[
  	->$fi
'
 	+!2
 )  #$. 
 
}
 	-

 B  I	
 
'
  	7#
& G< } 	-

 ,".  } 	fi
 
 	)!ff. 
 	!)
 +_4
 )I]&-' 
 -[
  `Po
fiffoo'n
Rj}%
"
 	+#; ":<
 	

 +
 

-
 	!(>$  2  *
 ffI*CIB	&C' 
 2[
  	
 Ej#
3  s:j'k k  j
3  ff fi0m
fi0mRnRo'p}k  Rn(
 
 o fiRo6 
 	+#; -,#$ 
 	

 2>$ *
 
 
*I
*PB	&0A
 . "
_
 fffi
"
= ,#$0
 !2#	 , 	

 -[
  	3/. "_
 +Q )W@U )W
	5'
fi 	

 ,#$ff
fi [
 ,ff'
 	/

 <&2' 
 -ff:/
 *. ff#0' +I. ,. 
 
#;} 	"
O
 ,::R !6

!%

 
 
: 
 `	
 
 	
 6)[
 
 6
  	

 	

 %#$
	 ff[
  	&  . 	 	3.   
 	*I
 
ffV"
U 3*#,T$U(T -.#,V"(W Y4#I5GR	
ff 
#;} 	

 -# 0Y
 	5[
 	!2fi


 , 	5[
 	q
! 	

 ff
 0"!* 	
!  -
) ,
 
 !*&4_4
 *I 93.0
 	*. 8
 ff



 
#4ff
 	0#$*ff
 * 2	 !"#$	 , 	

 ,[
  	3.  

 fi
"
=	
 " 	4!(#$ I
 	fi 	

 -[
  3.   1,
  	
 
!

 #$	-. 	
. !0#;1 
#<0 	

 0[
  	3
 . 4 
 [
 	


 	&(?0C. ) q+:<A
 	5fi
 

 %#$"
2fi
 [
 
 <3 
`	
 
	!1>@

 0"!
 -'

 	 0#$ P" 	

 "[
  	B
I
 	.!&
8 6*3[
 fi

 ff 	-
 *'
 "
 	%
fi
 [
 "
%*fi
"
= 	R
	fi 	

 %[
  3 %)
fi
 [
 "
6.
 
 =;fi
"
= 	1>$		/B, 	
 
  	&8 Y	
[
 3  	06
. 

!*

 
 
: 
 I	
 
 	#$ 
 "'
 #

 =;fi
"
= 	) 	
 "[
  	3ff-
  	
*"
 0,"
 [5GR	&



































  

ff

o'}k


0o'pklo

8 %

6)-=;
'fi''*fi';#$`		,#;


+2	
+fi
	!
"
	73*. *)=;'fi''-fi';#$Y		&)_/I	5fi3
. 26

 
 
:  )
} 	

 5GR	2'	. (fi
 	! 
 ( >$fi ff& ^IB-.0
 ('
fi ;#$
 


(
. `
 		R#$ [lm:jp
R 0oklRm4&
G )'
_
 	
 	
 6-
Y
 	 '
 )5GR	-#
 Y
 	5'
fi 
 6. 
C+! 
 %fi 	
).6
 	*q
 6 )'
fi ;#$
	fi!*`	5'
fi ff#$ 
 !*.>$DffB
 	ff$&3IJJKB	& A
 "   	+fi
 	!










 ff-&#- fi!>/ 1)(#"9$# / 0(



'@



!>" /



  

fiff

($

=
fi>ff

&





(/  $



 
   

'9'@



* (" / 

'



-/ #/ (#*0&#!

/ (

N




2

3



3C

 
 

'@





fi1

!#&

($



/ (#

?>  (#*0&#!
/ (


2 
 >

3?>  (

fi'# u'}~'w`u''uw#w'

>$B

>$B

0.7
Train
Test

0.45
Train
Test

0.4

0.6

0.35

0.5
0.3

0.4

0.25
0.2

0.3

0.15

0.2
0.1

0.1

0

>B

0.05

1

0

0

1

1

>@/B

0.7
Train
Test

2

3

4

5

0.45
Train
Test

0.4

0.6

0.35

0.5
0.3

0.4

0.25
0.2

0.3

0.15

0.2
0.1

0.1

0

>B

0.05

1

2

3

4

0

5

1

2

3

4

5

0.35
Train
Test
0.3

0.25

0.2

0.15

0.1

0.05

0

1

_4
I*9

2

3

4

5

 

 R}0_RG}

#0# 
  8  RYI' 
 0#}[}}  .

 

	 


N


fi'#u'Ewu''{
	fiffYu'w

_4
I,: 8 }	
5GR	-'	. %+Rfi
	!&(' )[	.O2
!
	fi	
) #$ff
5-">@
-,'	!*. ,fi		/B#$,	
 2
 2fi
 	
 	&,' 

 ,	fffi
 	!)'
fi ;#$
 ,
,'
 	#$, #$ 
.0
 )-
 %fi
 	!R'
fi ;#$
 *
-'
 	"
 +-:<.23fi

 
	
'
 " ff  	2	0fi
 	!2
 
!2fi
"
= 	*#$ 	5'
fi ff &

.  *	CC
5C. 
]}	R	3
*
2fi
+-2	 fi
	!R
*
!
fi
"
=	#$0	5fi'&'7I	5fi0
!fi	
3.  

'	*0	fi
,
	
. 
 C
 ,D6>@"I 6]Bff  C	5'
fi D6>@ 9*= MB0&"G_,#$'+0	
fi
 	!2
)
 *#;} 	  2- , 2

 
 
: 
 ff
fi
 [
  
  [lm:jp
R 0oklRm+#$
	5'
fi 34
  
 +Y"'
 ,E
# 	fi 		%

 	"#; :.M /
 +
 
 )FMJ 
/
 )	
C>$fi ff& ^^IB	&*8 _	
 3< -. "q
 
 =;

 
 
: 
 '	/

 2#$8
 
 	
>@
  MM*3	 ffPP *34fi ff& 9B	&+8 6fi
	3"G
. +
 6_4
 ),I :/3*	"[
  
.   *,
 2[
   #$ ff:<0.3/ff

  #$" #$& ' 


"fififi
,#$0-!Off, '
fi ,
 L. 	
  +
,'[ "0
! 
0fi

!) 	)Y
! 
 " 3ff!O"
G	2'
 " 	
 	7&













R

Rjp}l Rm





fiff

k Yj:mRn`o'lrRm:o'n

:llo'

?02	,fi		)-#; 

-2
fi[ #;O

*-	
/37
fi
 
"


 %

 %2 	#,fi
	
	*
62\8 ? 	*! '22'	
 	
 ,#$ 	fi

 *"   	)fi
 	!& ?1" ff/2
,.)'8	 =
fi

 -ff !*'
 	0 .
 =;'
 	

 	2:/
5 	)fi
 	!
&  . 	
 	3 ff
I
 - [
 
*

 R
3 0"
  3<0.00'
 	,
 .
 =;'
 	

 	6fi
 	!+"
ff
 
 <&CE
'
` 	 	 	3

`
 +6. ,fi
"
= 	R! 	fi 	")!"
fi!
 2"

 fi
 	!)fi
 	} 	+!2
 Y	5'
fi &?0*
fi [
 
)`
 "'
 
# .
 =fi
 	} 	+fi
 	
 	37
 

 	0#; *3/
 q
 	fi
   	)! =
O.)'
 "
[
 5=	
 "
 ) q
 	5'
fi 

 )>$
 2
 *#;} 	3
I
 	5} 	!2"
 )# '
fi 	73

 

fi [
  = .
 =;	 [
 	!,.    fi
ff, fi} B	3
 
 ,! =

fi
'
 	"
 	
  
 ,+
!)'
 +fi5!&ff8 )
ff 	

 2. ,.1

N*P

fi'# u'}~'w`u''uw#w'

-fi';#$#	%fi
	!6
"'	ff)	C/D-:/5	6fi
	
	3!
	fi
"0	. ,#$/  	
	4
Gfi

L)M,[)E	
. 

}
 	- 
 ,fi
 	!&' 
 <3/'
  I} 	-#7	 , 

 	 
 !*"
 #;70
# 	
 =

, 	
 	ff
 +2L)M,[3<
 +`	5,	

 +. -fi 	 "+
 !
,# 2L)M,
[ 
 } 	!&
}





A
 , 
 
 -
	ffff	)
I)Q&UVc	
	3<!-
"
*


,	4
 XU&+	W"+	T#*&/T<. 
"fffi
	!

,4fi
	!	fi
'	"'
	2L)
? -
# 
& J!q	
0. [*04"c	
	ff
2"

. 
" 
 		-! &7_
G E  
 0 	. 4
 7E	
 

 
 ,

 	

 * *'
 
 	q
 	
,#" 	 -# &

ff



:l}

'R	
A!` 	:<
A! ? :<
  ` 	:<
   ? :<
L)
5 	
P

ff 


I]
I I

pj



I




^ M 
^ 
^ K
^ M
^ ]
^ ] ] 
^ ^  

 
 
 


IP
I I

 

I*9



r



P



^ P9:
^ ^KP
^ ^
^ M
^ 
^ M:
^ 9]
^ 
^ M9

ff







8jfi:o




jfi:o



^ ^M
^ ^I
^ ^I
^ 9^
^ 
^ M






'"] ? fi
)2/6fi
	
	&FE-. 	fi-ff	"fi
	!6. 
+	
/6fi
	
	-
)2L) ? 2[	7&*' ":<I	6fi	,

 GR *fi
 	
 	q
 	
 
'
  	 >@ *	5#$"'	
B	L02	]	C. 
"'
 I
# 	
 
- 	
 	
 %2
 
 %/L2
]
 	
 C. 
fi

    	. )
 2	 	
 
, 	
 	L<"#$q	
 
. ff	
	6
 -#-fi
 	!%} 	
 )*ff  	 L)M,[37
 +
:#$_	
 6. ,-



 
 
: 
 %>$
fi =;
 B"# *fi
 	
!  . 

 	'
fi 	0",	 fi
 	!&







'*]Y	fi	,*fi';#$-# ff	%	,!*37+ [lm:jp
R
0oklRm(
 	. %[
  3)P*:/
5 	Cfi
 	
	-
68	""`	"	
	
6


 )!"-
 3 -.  2
 		C%2!%

 )! '
 	

 &
' 
 ffA!` 
 	
 :< fi
 	!2. ! 	 !1
 



 "
 Y
 	
 #
 	
 :<"LffA! ? 
 :<
fi
 	!C. !" 	! 
 



 )
  	
 :<"LI  ` 
 	
 :< fi
 	!C. ! 	
 0
 


 *  	 G
 	
 :<"L72   ? 
 :< fi
 	!6. !ff 	" 0
 



 *
 
	
 :<"L<0L)

5 	+fi
 	!+
 	ff"
 



 /
 2"

 &ff_/0ff2   =
?  :<Hfi
 	!3 	fi
 	!
 ' 	4. 
-ff
 
 :  844' 	.R0^ ^P0 	 	$3/ 
0
 GR ff. 
E   ? 
 :<1
E
 

 
 
: 
 &ff>$` fi

 !3 :/
5 	<
    ? 
 :<
fi
 	!) #; 	+'
 	ff
2
I
 	fi

 2
,"0
"
ff-fi
 	!). ,  	7& B+' 3

+


 2-fi
"
=	
 ) 0
 [	ff#fi
 	
! 	
 	,0
I
 	
 
'
 !6" " 5=
::	*
 
!fi
 $3ff 	
 #$ [
    
 -fifi} 	fi';#$"[
 "'
 .
# 
/2fi
 	
 	&



N#D

fi'#u'Ewu''{
	fiffYu'w

 [s:o





Rn.m:o'

ff

fiRp`P



ff

_4
!3. #, .0	7R	
#. }	!, 8	
<.0	7. 
  
fi!*'"#$'

3.0	4 L)M,[6"
ff}	!-'-"
fi fi 	
 	#4ff
 ,#}	
3/ . ,fifi'	2-I			G	*
)fi
 	!+q
! 	 &0?00[
 8	
 q
 	
'
 -
 0
ff
 	.,3<. , GR  	0#

fi 	5'
fi 
[
 ff
2.0
 	2. "
 "!*
 	)
 !6>@'
 	"
 

B,fi
 	
 	,
 2
fi
 	! 	&-_/G
 } 	)
 	6fi
 	!
37.  	6
 
 )

 	[
 	
 
". 


	fiff
 *'
 
 	<
 L)
  ? [
 	
	 "#I	5'
fi 		6>$
 `
! 	fi 	

 B  	 
#
> 	5}
 	!2 .  
 ff#$"
 .
 =fi
 	} 	B
 C	5'
fi D-fi
 	
 	,
 )' "]B	&' 
G
 	

. 4"fi
 	-. 
, 
  	,#
>#$7 B7
 "   	2
 L)M,[&8@#<L)M,[
.  ,'
fi ;# 	ff"'
 	7#4, 0fifi

  ff 	fi
  	0!O} 	

 3- L)
 
? [
 	
	 ".*
fi!2'
 ,*> 
!#
B 	
0# 	/3G	 	

 *'
 	. -	 
.	
 
 

	ff.+'
 "

 
 
:  ->$0#
# 	 ,'
 '
fi '
 ,*"'
  #fi 	ff
 
L)
  ? G
 	
B	3 , '
 	 =$:/4
  	

 
fi"."'
  
fi

! 	 
	 fiff
>@'
fi -I, 2
  fiff^B	3.0
   ff 
ff
 !*

	_
 
 ,
 ". 
*  
  6 6
 *'
[
  
 6"Y"'
 ,G
# 	
 
" 	
 	,
   	&)? "
I
 	5[
 3
 #ff
 L)M,[ 
 + 	

 +2* "fifi

   	fi
  	"2!
 	

}
 3 	 )  	).%'
 *'
 	 		734
 6-'
 	". 	62
 6"ff#0

 ,:/".%'
 	 
>@'
fi *
 %
  fi^B
,
34. 

   	+
 6
fi!
ff

"'
 	 	)[
 
 &2' 
 - 	"
= 	6
 6' <9*
 
 *ff. - -"
 	_
 	 
2#$[
 I
  - +-	& H0
 ,)I^^^*
  fi
 	
 	
,. 
 	73
8	 	

 )'
 	.  	 *  	-. 0fi


 -
 )  		)[!fi	
ff0

 	 -'
 	 		6. 	'
 	.H-^ ^I" 	
 	# 

 
 
: 
 L4#;" 37 
 	
 :/  '
fi E	
 `
9 	
 .	 "I ^0
 "0
! =;
  fi.	 ff^3fi 	
 		
!-ff
'
 
= 	_
  , &



#

#

#

#

# %
 #




#

#

#

#



#








$#

#







}'#}} 

8 *
fffifi'0. ,fi		)fi}	
4[	!-#$ fifi!
2	
#$[0
*
fffi #fi
"
=	

"fi
	!-'	
-
-fi}-
ff!"& Hff [	.=
!2}	ff-	
	!)."'ff##	5fi!*
	3)
	!	fi	ff
fifi 4fi
/fi
 	!. 

 -0fi} #7'
fi fi
 4#7fi
 	
 	3
 #7'
fi ;#$ =

)- 
 -#
fi [
 

 "#
 !+*
 #;# fi
,fi
 	
 	&*_
G 
  	

 [
 	-I	
 
 	 ff
 
 "
 

 #70
` _<'
 fi} 

 ff!*3
 - 
fi

 !C'
 "
 	6
fi 	C'
fi ;#$
 -
 C
` _<'
 %#$,fi
"
=

 <&68 %
 	
 =
 	q
 	5'
fi 
[
 0. 
2 * 0
 *
` _<'
 <3/. ff
 
 
: 	2

 
 
: 
 0
fi
 [
  
 
, 	. 2[
  0#$.0
 	*,fi
"
=

 *. 0'
fi ;#$[
 	7&4_
G ". 	*  
.  

 
 
:  
fi [
 4#$ 	
  	

 0 	. [
  	0> 	
 ""
	,fi
 	!+. 8
 fffi
"
= 	6#$0	 [
  	B	3[*
fi
 [
 0#$ff* 	ff#
 =
	

 [
  	>@'
 	fi
- *
  	
q
 	
 
 ,
 )	
0



 B	&ff_4
 !37. ,. 	
 ,  	)fi
 	!)
I
  
 !2'
 	 
 -[
 =;'
 	"
 

-\8 ? fi
 	q
! 	3<
+'
 	" +ff:/
5 	]
 	
 	-fifi 	%
 6*
 & Hff 	'
 "
 
0fifi
 

 *# 	
 #$ [
  
 -. 
 08fi

 !*fi
"
= ,ff!<
 


 ,fi
 	!2!  	
 "-,"
 	
   	fi} 0
 
 -'
 I	5fi 	*. 

" ff


 [
 	&





N

fi'# u'}~'w`u''uw#w'

C^

ff 


pj

CP

(I^
'09?



ff ff


I^^^
KMK
9MJ

:llo'







:p}p

^ 9I
^ 9J
^ P





:o

   



^ ^^
^ ^^
^ ^^







jfi:o

iR 0o



^ 
J P9
I ^PK
I II





mko'p





^ ^M
^ ^K
^ II










	#L)M,[%}}	!&4G_0	+I^^^ff'	"


fi
	
	,"!&4_/

##"'*
 
G	
	2}	
*
L)M,[34%
)	C+*	
	[	
. 
6
-
6*


}	2fi
	!2. 8	fi	)-fi




/&' 
 `"'
 ,# 	
 
, 	
	ff
	6. 
+fi
	!&2' ":<". 

#$,I^^^+fi
	
	30*	R. #$0fi
	
	2-R"*P	
 =
ff 	
 	37
 ),.(#$fffi
	
	",60-I^`	

 	
 	&)' 
 * 	


!C# `fi

 E
 	
-#ff)fi
 	!%
   	. 


  
 
 "'
 ff#
# 	
 
, 	
 	&ff' 
 "
_
 	
 +fi 	 ff[	 =
 	

  	
 `
9 	
 -'	. 6`fi

 0
  L)M,[ 
 	&6' 
 #$_	
 
fi 	 0,

7

 
 
: 
 #8	 	

 Y	
 `
9 	
 &0' 
 "
 ) 	

 !fi	
4	 .0 	#<
 	  '
 	 		
 
 "'
  '
 !
  		7&_4
 !34,.`
 	
 fi 	 ,'
fi -
 +
  fi	

#; ,'
 	 
  :/0'	. -,., 	 #4
 	&









G	
 #$ [
  
 *0'2fifi
	)"
,!"
2fi	
0./3 
fifi}	"
 GR#;1fi	
 .ff
	<	fi'	& J
'-*E<*>IJJMB
Y
	0	
 #$ [
 0 
 -
 )-
fi[	)!*3/2I	5fi'
[ff#E:	
q	0$&
>$]^^^B<

= 	
"	" "'
 	$&G6} :
 	$&>IJJK,B  /[
 	!ff

"
7 
 	-
  3
 "	
" 	
 #$ [
  
 ". 

 "
fi [
 	-! . 

  &
G6} 0
 	4$&/>IJJK:
B 	5fi 
 



 fffi
 	
 	 
 fi
 	
 	#$7
 #$

 "fi 	 

 ,
 "
fi} ff

 !C#$} 	
 G
 

 <fi
 &  . 	
 <7. 
 I
! 	5fi 	
fi
 	
! 	
 	  *I 90	4
  

 3.0
 	
 	
 	
`
! 	-
 0'
 	5fi 	-. 

" ff


 [
 	">$ 	fi 	2":[
] 	
 ,	 	5fi 	+
  B	&
G ff`
_
 ff  	)fi
 	!2'
 ff

 ,'
 	


 ff 	*
 -?ff
A O	
 :/'
 

	
  '
 	

 C. 
%,#  	3
 R+
 	R
 



 +
 ]
 	
 :<

 6'
 	


 
"-:
: ,
 + 6fi 	
"./L4,
 	<34ff  	Cfi
 	!6

 */6fi
 	!

 	
	)
 )

 ! 
 &,_/E
 	5fi 3. ,. ,
 fi 	
 		
8	fi 	52 2
  	
*} 	 =; G6fi
 	!). 
2 	'
fi 	0
 



 ".0
 2 
 #$  

&
Hff0!  
 	5'
fi 
[
 "
 "'
 	'
 )2/ 	ff[
 ,#[	 
 	"fi} 2
 =

 ,!"fffi 	 0-"fi 	

 )	!*
 +fifi
 

 ).
# ffER> & /&3/
 	
 2
	'
fi 	
8
 	
  4#< 6
 	5fi

 ,. 
" 0
 	5'
fi 
 0
  
: 	'
 	
 
 ,!*L
 fi
 *"fffi} "04fffi
 
 2'
}
  *} ,  
 */*=`
9 	
 3/.0
 
 	
 
 -7
 #$


 Y	!"#$'
 	


 =
 B	
&  . 	
 	3#
 	 
 	, 
 
-'
 "/ 	 	7&_
G ff`
 0fi
'
 ""
 [
 	!-#$ 	/
 	
 *fffffi} ,
, 
  0
= &_<" 3
 4.,  	E
 L)M,[6"'
 	<
 '	 
 fifi
5 =



 <3. -!)'
 -
 /
 	
 )-fi  # 
'
 6",fi
4 

!6
 



N

fi'#u'Ewu''{
	fiffYu'w

fi ##	
*fi
}	
ff
}	2&0_/ 

ff. 
)
'+"

 	 [ H%L)M,[C"'	<
0#$-",fififi
->$Dff}	
`	0$&3<IJJMB	&00!3[4
<3<
' '
 *>$]^^^B7 # 8
! 	5fi
 ,.0
 	40[ H%L)M,
[ =;!  fifi} 	I
 
 ,!
 	2
 L)M,
[ =;
} 
'
fi 	ff
 2fi} *

 "!H#$ 3.0
  ,ff
ff 	)- fi 	  " ,  



 ff *ff!<
  &



? ,#;*./34. *. 
66''%2#$[
	C	-+2 	

0
[	3	5fiff,fi
<
 GR"'	. -fi
"
=	
#$#	5fi' 0q
	3
E	
  #<fi}   - 	. ,#$7
0!"0>@.0
	"
"4[	 =
!"
 [
 	-"'
 0
 B	3
  	
00 0#,  	* 	. "#;'
 	

 +>@G6} .
 	$&3
IJJKB	3 Y
 	5fi ," ff#" ff
 #$

 8
 =;"
  	. &





 fffi

 

 

' 
 *,)_<F
2#$,

#5G7,
6
fi[
6`_<'<3GR
	
\.	}3/\40E:	
<3:0'*[4
}	

$3IL+=	
qff
 #$	
0	'
4	fi<3

 
 	' %#$* `
 	[
 *
 R6/#$*#"
2fi'
fi 	3ff
 (M,
 L	?0 		I
3 0
 	
A<3/\4 :
E 	
 2 q
 0'
 [4
 } 	
 
7#$ 
 	fi#;0
 	
 
 

 &

 




 #

 

ff fi0m

`om:o'pj



[s:o




  fi



 

 #  

Yo :o'p}o ff8j}ok   r


o'
R



omRnRo'p

`o'p}lRklRm

` _<'2
,Y	5fi'
[4fi}2
"!Off. 0!**}	,/ff#


ff,
-`E	. 	!"
,ff	fiG	
<&
84". 
7'0}	I<`_<'
2
 Mff
 GR 

& 84*!",8
 } 	"#
 `
9 	
 !*!<&4`  !
. 
'
 -'
fi 
 )2-
 GR "

 )# 
` _<'
 +/
 q
 } 	+fi
 `$34
 +,`_<'
 
"
E	
 *!-
0'
 
 . 

 2"
  fi
 I$&
8 
 	

 #$ 
 *
` _<'
 Y*'ff#$'2 }	-
/&[4,*
*
	
-'#$Y
/& HI%-
3!6!)	%fifi!+'%

.0*!$&' 
0

	ff 7
	,,!&8@#4
03/-fi2Y7	&
?0/3/[E7\4?ffA\CM H1%
` Hff@
' 0A\%?1A[\4?ffDff\.1[ %Hff`0\ &

? 0[)# } 	2/3/!*. 
'
 } 	)-! CD/3 C=;D/3/2CD+3<
2'
-fi
',#	/}	-*!0fi[. 
2`_<'<&0[E7\4?ffA\RM HH`%Hff'@ ?ff`ffN 0[R'0\
[ %Hff`0\BJ\4_ HGff\C[.%Hff8$M,8;`ffNH'08;A*_\\4M J? ? D"&/? #$!2*fi2"fi3<
. 
<"'
 0 # 	.R
 # 
 	

 4#$!,,
 . 	&\4"
 #`_<'	-'#$ !8	
	fi 	",/3<[E7\4?ffA\C_8;`08;
A H
' 0\R
A Eff\ 8H
 
 	
 

 "	50/
& HI
!+ ":
: 

 	%?ffE7EC# -3< -. 
 )'
 *
 )fifi'
!)#$ff!)2fi
'
 
#; 	[
 &
8@#<!" !"fi"/
,E	5fi'
[3/Mff
04J 
 9*= 9M^*=K9I,:/3	4A
'
 0J 9*= 9M*^ =IP:/&
' !#$fi
	
fi
*
*
E	5fi'
[*>

N*O

fi'# u'}~'w`u''uw#w'

#j]iR}om:jp}l:
84C M)6!6
C
`	5fi'
[&B84%R626-+
[3
C
fi	
'	)'	&? #$!"::
q}	-2fffi
'	2!#	/}	/3/fi*
fi
 "
 -:
: 
*ff	!"#$/& HI,!-0::
	2?ffE7E+#ff3fi
fi
'
 " !:
: R
 	[
 &

? 
	*ff!*'*I
? 
	*ff!*']
? 
	*ff!*'29
? 
	*ff!*'0:
? 
	*ff!*'P
? 
	*ff!*'2M
? 
	*ff-fi
'ff::R	[

   



  

J#3M&[&3FC'


3/&`,&>IJJMB	&#S.)UffffZ&/QV"W@X)U56)QV"V"W(&.6&?  A	

 :&
J
'<3<?"&/G1&3/FHE</3<[&L%&4>IJJMB	&' 8	fi

2#[		 
 2fi'	=;fi
	

}	
"!"&,8) UX5#5#5W(&.6ff
+ U T(-.#		
E5&/T#*)5&/QT$W@U&/QY
<ZV U+	W@SV U&FU!#*&
ffW@QYU56 S.# 3/fifi<&/J fiff<I^^&

ff

? = ? $3*/&3F J.G<3,L%&D"&>IJJ B	&'}	
0




I	


}5=

&8)UX5#5#5W(&.6+U T(-.#T(- &&/SQY! #5#T$W(&.6ffU T(-.#+5+	UXW@QT$W@U& 	U)UV <ST$QT$W@U&/QY
/ W(&.6 SW"	+ T$W@X,	+ 3fifi<&/]M ]fiff] ^&
4

ff

ff

ff

? 
	3'"&3FfiJ/3?"&>IJJMB	&8;fi
		0fi';#$,
*	
#$[ =

/&8) UX5#5#5W(&.6
+ % 
 3/fifi<&7I^I fiff<I^]9 &
M,
	
$3L%&37FONG
/3\ &>IJJPB	&L	
	0#$G	
)
	
	ff
6-fi}
  ,!*&08 )UX5#5#5W(&.6+ffU T(-.#		E%%% )W(&.6E<ZV U+	W@SV U&V <W()W@XQY
#(T -*U +,(W &ff"W +	XU.S )+,# 5&/T #*) ) #T$QT$W@U &)Q &#*&#*)QT$W@U &/3/fifi<& 9:ff 9J&



ff







L0!37A<& >IJJKB	&-Afi'	

 ? fi
"'	"#0"
5	.=;





}	
+>$fi,IB	&
+,#*) )U*#YW(&.6-Q&
+,#*) %Q <T#525&/T#*)QXT$W@U&/34>9*= :B	&

0	3A<&3F



ff



L0!37A<& >IJJJB	&-Afi'	

 ? fi
"'	"#0"
5	.=;





}	
+>$fi0]B	&
+,#*) )U*#YW(&.6-Q&
+,#*) %Q <T#525&/T#*)QXT$W@U&/3 	>I5=]B	&

0	3A<&3F



ff



}	/3.L%&3_/	3/& ? &3F1A
 #$73_ &G1&<>IJJ]B	&<8	
0
	 
-		5=
fiff
	&8 5/
& T#*)5/& QT$W@U/& QY!U& ,#*) #*&/X5#ffU&<U!#*&</7Q&.6SQ*6#")UX5#,+5+	W(&.6 fi /!3
fifi<& 
 IPff 
 IK&

	ff



NN

fi'#u'Ewu''{
	fiffYu'w

Dff}	
/3E4&[&3E<
<3L%&E4&3F L)3?"&G1&>IJJMB	&}G	
#$[4
?%	!&
U.
S )5&/QY7U %)T$W $XW@Q
Y 5&/T #Y@Y4W 6#*&/X5##,+,#Q)X,-33/]9 fiff]KP&

ff

Dff*3 ? &">IJJPB	&  )
;#;}	2#$2
%fifi

& 8603,M&30F GR
fi<30/&
>$\4& B	3/UW@X5#UV"V"S.&/W@XQT$W@U& 1#T' #5#*&ffSV"Q&+ffQ& )QX,-W(&#,+	3fifi<&:]]fiff.::]&`0

? '
G
 ,!*[ 	&

(

Dff*3 ? &3E<
<3M&3FCG6}	3L%&	?"&>IJJKB	&_<6
G	5fi'*' 
  5GR	#/
 =
4,0	5fi'
 . 
"fi},
 !"&8)UX5#5#5W(&.6+U (T -.#5&/T#*)5&/QT$W@U&/QY
U & ,#*) #*&/5X #ffU &I U !#*&</7Q&.6SQ*6#")UX5#,+5+	W(&.6 fi /!	&

	ff

ff



ff



E:	
<37\ &3/F [4
}	

$3R"&>IJJPB	& ? 3/[	50
<&08)UX74U 		2
 U !#*&</7Q&.6SQ*6# <Z*+	T#V +#X,-.&/UYU56Z *U)!*+5-U ffS+	T$W(&	# Q+	&







&



E:	
<3ff\ &3[4
}	

$3G"&3F \.	}3G1&0>$]^^^B	&C? 	
)"'	0#,C}	


 }	
)#$,
6
+	
	&   
)Q&+	QXT$W@U&+U&  #5#X,-)Q& ffS.W@U
 )U5X #,+5+	(W &.63 37II ff] 9&




E:	
<3\ &3[4
}	

$3#"&37\.	}37G1&37_<
=	
/3N"&7M&3FO`0!<37A<&>IJJJB	&Afi}
ff
_< 	!--fi}	
& 8)UX7   *U)!*+5-U %U&<ffST$UV"QT$W@X
 #5#,X -2#X5U 6&/W@T$W@U &*Q &&#*)+	T$Q&W(&.6  		&









E<
<3<M&/&3<F [4<3/A<&4>$]^^^B	& [	
	
2+/fi
-*fi fi'	)	

2
)
fi} "
 !*&<8)UX7/U 0T(-.#%#*3*#*&/T#5#*&/T(-"ffQT$W@U&/QYU& ,#*) #*&/X5# U&2)T$W $XW@QY
5&/T #Y@Y4W 6#*&/5X # %% fiff&

ff

ff



	ff

E<
<3M&./&3[4<3A<&3F G6}	3.L%&?"&7>IJJKB	&7\4
G	fi,A	
	
*,G_=
J 	2Afi} *Mff
,?0&48)UX5#5#5W(&.6+0U -W()T$Z2<W T(-2&&/SQY #5#T$W(&.6U "T(-.#
+5+	UXW@QT$W@U &2U UV <ST$QT$W@U &/Q

Y /4(W &.6S"W +	T$W@,X +	3fifi<& K^fiff K &

ff

ff



ff

&

E<
<3M&./&3G6}	3.L%&?"&3F1DG3.L%&/&7>IJJJB	&<?ff
 '		
-#4fifi'	
 	

 


 

   	 	$&78 
 )U5X #5#5W(&.6+U 0(T -.#-(W )T$Z%#*3*#*&/T(-&&/SQY #5#T$W(&.6
U ,(T -.# +5+	UXW@QT$W@U &2U UV <ST$QT$W@
U &/Q

Y /4(W &.6S"W +	T$W@,X +	3fifi<
& 9^Jfi
ff 9*I M&

ff

ff

ff



!

` 

"
$3 "
8 &3FOD0!
$&3
8"&>IJJMB	&"?  
	4	!)	+)*	


!6#
'
fi 	*	

<&48)UX7<U ,T(-.# 5 &/T#*)5&/QT$W@U&/QY<ZV U+	W@SV U&< U!#*&ffW@QYU56S.#3fifi<&
IP fiff<*I M^&

ff

0!3`,&3[4
<3./&3F





ff

' '
 <3A<&<>$]^^^B	&/Afi}
[#$&/8)UX5#5#5
W(&.6+ffU ,T(-.#	T(-E&&/SQY #5#T$W(&.6U "T(-.#+5+	UXW@QT$W@U& 	U)UV <ST$QT$W@U&/QY
/4W(&.6SW"+	T$W@X,+	&

ff

ff

ff



A'<3?"&3A*3 /&34' H03\ &3 J	3E4&3F ? [34?"& >IJJKB	&+\4
6#
2/	
 C
[
 	)
#$
%! '		fi'	 
C2?Gff8;A\Ofi 	&(8
5&/T #*)QXT$(W 3*#/UW@5X ##,X -.&/UY5U 6Z 	U )#4Y #XUV"V".S &/W@XQT$W@U&+% <YW@XQT$W@U&+ ,3/fifi<&JI ff
J M&

ff



A
<3A<&3<DG3L%&<A<&37E<
<3<M&/&37FHG6}	3L%&/?"&>IJJJB	&
#$fi} *

 ,!"&48 
 )UX 7 %  		&

N







G	
#$[ff


fi'# u'}~'w`u''uw#w'

A"
<3}"&G1&>IJJKB	&?I8	
,#/	
	7#$7		
	!"
 #$!
,[


 fffi}
 8  
/
& 5&/T #*)5&/QT$W@
U &/QY U.
S )5&/QYU ffSV"
Q & UV <ST #*)<T$.
S W(#,+	3
 
3 M] fi
ff M: &

ff

ff





Afi3'"&3F 0
H 
3/&>IJJPB	&4?I2fifi}	-	5 =;=;fi'	*!'	
&82D0	
 <37G1&J0&3
F1[4
. $ 3/D"&<D"&>$\4& B	3 #5#X,-U*W(&.6Q&2<Z&/T(-.#,+	W"+	3fifi<&MII ffM99&\4	
	&



	ff

A<3'"&A<&3/FfiJ/3?"&<N"&7>IJJKB	& #W(& 	U)X5#V0#*&/T/
#Q)5&/W(&.6&
L+8;'([	&
'R	/3N"&/&>IJJPB	&ff'Rfi
 GR-
)).=;"<&UV"V"S.&/W@XQT$W@U&+"U
(T -.# )33/PKfiff MK&

ff

G6}	3*L%&	?"&>$]^^^B	&	?I,fifi

,#/	
#$[
ff 
	!0		


 *,fi}
 -

 ,!1#$#
 
$
& U.
S )5&/QY7U %)T$W $XW@QY5&/T#Y@YW46#*&/X5#%#,+,#Q)X,-3 ff3
9K fi.ff :/*I M&

ff

G6}	3L%&?"&3_<[	3./& ? & 3FH`0!<3A<&>IJJKB	&E:
*fi
<
"5=

 	* ffB
?  !)# - fi})
*0#$G
$&*8)UX5#5#5W(&.6+"U T(-.#
T(&&/SQY #5#T$(W &.6U "(T -.# 5+ +	UXW@QT$W@U&2U UV <ST$QT$W@U&/QY
/4W(&.6SW"+	T$W@X,+  /. / 	3
fifi<&7*I 9:Pfiff<*I 9P]&

ff

ff

ff





G6}	3 L%&?"&3E<
<34M&/&3Dff*3 ? &?"&3F ?ff'	3?"& > IJJKB	&)\4
6fi}

,. 
*[/?G0?0M,8;A\'.[0
	&UV <ST#*)% #5#X,-Q&0/7Q&.6SQ*6#3
 ff4> 9B	&





G6}	3L%&3Rff".,3H"&34Fc0
$3
L%&>$]^^IB	&*Afi*,?O
-*fi'	&)8
 )U5X #5#5W(&.6+*U +(T -.#ffU)(T - ff0

V #*)W@X
Q &
#5#T$(W &.6%U +(T -.# +5+	UXW@QT$W@U & 	U )UV <ST$QT$W@U &/QY
/4(W &.6S"W +	T$W@,X +	&

ff

ff

ff



G6}	3L%&?"&3F G(
}	3A<&>IJJ^B	&
L)
5	*



"
*
4?I*
	

-


 	 , 	[
<&48)UX7 ffT(-E&&/SQY #5#T$W(&.6U ,T(-.#  /43fifi<& ^fiff J&

ff

84'/3A<&
/&@>$]^^^B	&,[

EL	,
6Afi})Mff
-A!"&&8 -W@YU+	U  -W@XQY
) Q&	+ QXT$W@U&0
+ U ,T(-.#0
 UZQY<
 UXW(# T$Z#*) W(#,+   fi
	 3<fifi<&7I*9 KJfiff<I,: ^]&

ff

ff

	ff

G6
3 ? &/&/>IJKJB	& )U*#Y + U #YQZ#5 #W(& 	U)X5#V0#*&/T/
#Q)5&/W(&.6&[<& M&	
3 ? "

G

!<&

N



fiJournal of Artificial Intelligence Research 16 (2002) 209-257

Submitted 5/01; published 4/02

Structured Knowledge Representation for Image Retrieval
Eugenio Di Sciascio
Francesco M. Donini
Marina Mongiello

disciascio@poliba.it
donini@poliba.it
mongiello@poliba.it

Dipartimento di Elettrotecnica ed Elettronica, Politecnico di Bari
Via Re David, 200  70125 BARI Italy

Abstract
We propose a structured approach to the problem of retrieval of images by content and
present a description logic that has been devised for the semantic indexing and retrieval of
images containing complex objects.
As other approaches do, we start from low-level features extracted with image analysis
to detect and characterize regions in an image. However, in contrast with feature-based approaches, we provide a syntax to describe segmented regions as basic objects and complex
objects as compositions of basic ones. Then we introduce a companion extensional semantics for defining reasoning services, such as retrieval, classification, and subsumption. These
services can be used for both exact and approximate matching, using similarity measures.
Using our logical approach as a formal specification, we implemented a complete clientserver image retrieval system, which allows a user to pose both queries by sketch and queries
by example. A set of experiments has been carried out on a testbed of images to assess the
retrieval capabilities of the system in comparison with expert users ranking. Results are
presented adopting a well-established measure of quality borrowed from textual information
retrieval.

1. Introduction
Image retrieval is the problem of selecting, from a repository of images, those images fulfilling to the maximum extent some criterion specified by an end user. In this paper, we
concentrate on content-based image retrieval, in which criteria express properties of the
appearance of the image itself, i.e., on its pictorial characteristics.
Most of the research in this field has till now concentrated in devising suitable techniques
for extracting relevant cues with the aid of image analysis algorithms. Current systems result
effective when the specified properties are so-called low-level characteristics, such as color
distribution, or texture. For example, systems such as IBMs QBIC1 can easily retrieve,
among others, stamps containing the picture of a brown horse in a green field, when asked
to retrieve images of stamps with brown central area over a greenish background.
Nevertheless, present systems fail at treating correctly high-level characteristics of an
image  such as, retrieve stamps with a galloping horse. First of all, most systems cannot
even allow the user to specify such queries, because they lack a language for expressing highlevel features. Usually, this is overcome with the help of examples: retrieve images similar
to this one. However, examples are quite ambiguous to interpret: which are the features
1. See e.g., http://wwwqbic.almaden.ibm.com/cgi-bin/stamps-demo
c
2002
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiDi Sciascio, Donini & Mongiello

in the example that should appear in retrieved images? This ambiguity produces a lot of
false positives, as any one can experience.
Even if relevant features are pointed out in the example, the system cannot tell whether
what is pointed out is the color distribution, or its interpretation  after all, a galloping
brown horse produces a color distribution which is more similar to a running brown fox than
to a galloping white horse. In this aspect, image retrieval faces the same problems of object
recognition, which is a central problem in robotics and artificial vision. The only effective
solution overcoming this problem is to associate to a query some significant keywords, which
should match keywords attached in some way to images in the repository. Here ambiguities
in image understanding are just transferred to text understanding, as now a brown portrait
of Crazy Horse  the famous Indian chief  could be considered relevant.
Resorting to human experts to specify the expected output of a retrieval algorithm can,
in our opinion, only worsen these ambiguities, since it makes the correctness of an approach
to depend from a subjective perception of what an image retrieval system should do. What
is needed is a formal, high-level specification of the image retrieval task. This need motivates
the research we report here.
1.1 Contributions of the Paper
We approach the problem of image retrieval from a knowledge representation perspective,
and in particular, we refer to a framework already successfully applied by Woods and
Schmolze (1992) to conceptual modeling and semantic data models in databases (Calvanese,
Lenzerini, & Nardi, 1998). We consider image retrieval as a knowledge representation
problem, in which we can distinguish the following aspects:
Interface: the user is given a simple visual language to specify (by sketch or by example)
a geometric composition of basic shapes, which we call description. The composite shape
description intuitively stands for a set of images (all containing the given shapes in their
relative positions); it can be used either as a query, or as an index for a relevant class of
images, to be given some meaningful name.
Syntax and semantics: the system has an internal syntax to represent the users
queries and descriptions, and the syntax is given an extensional semantics in terms of sets
of retrievable images. In contrast with existing image retrieval systems, our semantics is
compositional, in the sense that adding details to the sketch may only restrict the set of
retrievable images. Syntax and semantics constitute a Semantic Data Model, in which the
relative position, orientation and size of each shape component are given an explicit notation through a geometric transformation. The extensional semantics allows us to define
a hierarchy of composite shape descriptions, based on set containment between interpretations of descriptions. Coherently, the recognition of a shape description in an image is
defined as an interpretation satisfying the description.
Algorithms and complexity: based on the semantics, we prove that subsumption
between descriptions can be carried out in terms of recognition. Then we devise exact and
approximate algorithms for composite shapes recognition in an image, which are correct with
respect to the semantics. Ideally, if the computational complexity of the problem of retrieval
was known, the algorithms should also be optimal with reference to the computational
complexity of the problems. Presently, we solved the problem for exact retrieval, and
210

fiStructured Knowledge Representation for Image Retrieval

propose an algorithm for approximate retrieval which, although probably non-optimal, is
correct.
Experiments: while the study of the complexity of the problem is ongoing, the syntax,
semantics, and sub-optimal algorithms obtained so far are already sufficient to provide the
formal specification of a prototype system for the experimental verification of our approach.
The prototype has been used to carry out a set of experiments on a test database of images,
which allowed us to verify the effectiveness of the proposed approach in comparison with
expert users ranking.
We believe that a knowledge representation approach brings several benefits to research
in image retrieval. First of all, it separates the problem of finding an intuitive semantics for
query languages in image retrieval from the problem of implementing a correct algorithm
for a given semantics. Secondly, once the problem of image retrieval is semantically formalized, results and techniques from Computational Geometry can be exploited in assessing
the computational complexity of the formalized retrieval problem, and in devising efficient
algorithms, mostly for the approximate image retrieval problem. This is very much in the
same spirit as finite model theory has been used in the study of complexity of query answering for relational databases (Chandra & Harel, 1980). Third, our language borrows from
object modeling in Computer Graphics the hierarchical organization of classes of images
(Foley, van Dam, Feiner, & Hughes, 1996). This, in addition to an interpretation of composite shapes which one can immediately visualize, opens our logical approach to retrieval of
images of 3D-objects constructed in a geometric language (Paquet & Rioux, 1998), which is
still to be explored. Fourth, our logical formalization, although simple, allows for extensions
which are natural in logic, such as disjunction (OR) of components. Although alternative
components of a complex shape are difficult to be shown in a sketch, they could be used
to specify moving (i.e., non-rigid) parts of a composite shape. This exemplifies how our
logical approach can shed light to extensions of our syntax suitable for, e.g., video sequence
retrieval.
1.2 Outline of the Paper
The rest of the paper is organized as follows. In the next section, we review related work
on image retrieval. In Section 3 we describe our formal language, first its syntax, then its
semantics, and we start proving some basic properties. In the following section, we analyze
the reasoning problems and the semantic relations among them, and we devise algorithms
that can solve them. Then in Section 5 we illustrate the architecture of our system and
propose some examples pointing out distinguishing aspects of our approach. In Section 6
we present a set of experiments to assess retrieval capabilities of the system. Last section
draws the conclusions and proposes directions for future work.

2. Related Work
Content-Based Image Retrieval (CBIR) has recently become a widely investigated research
area. Several systems and approaches have been proposed; here we briefly report on some
significant examples and categorize them in three main research directions.
211

fiDi Sciascio, Donini & Mongiello

2.1 Feature-based Approaches
Largest part of research on CBIR has focused on low-level features such as color, texture,
shape, which can be extracted using image processing algorithms and used to characterize
an image in some feature space for subsequent indexing and similarity retrieval. In this
way the problem of retrieving images with homogeneous content is substituted with the
problem of retrieving images visually close to a target one (Hirata & Kato, 1992; Niblak
et al., 1993; Picard & Kabir, 1993; Jacobs, Finkelstein, & Salesin, 1995; Flickner et al.,
1995; Bach, Fuller, Gupta, Hampapur, Horowitz, Humphrey, Jain, & Shu, 1996; Celentano
& Di Sciascio, 1998; Cox, Miller, Minka, & Papathomas, 2000; Gevers & Smeulders, 2000).
Among the various projects, particularly interesting is the QBIC system (Niblak et al.,
1993; Flickner et al., 1995), often cited as the ancestor of all other CBIR systems, which
allows queries to be performed on shape, texture, color, by example and by sketch using as
target media both images and shots within videos. The system is currently embedded as a
tool in a commercial product, Ultimedia Manager. Later versions have introduced an
automated foreground/background segmentation scheme. Here the indexing of an image is
made on the principal shape, with the aid of some heuristics. This is an evident limitation:
most images do not have a main shape, and objects are often composed of various parts.
Other researchers, rather than concentrating on a main shape, which is typically assumed located in the central part of the picture, have proposed to index regions in images;
so that the focus is not on retrieval of similar images, but of similar regions within an
image. Examples of this idea are VisualSeek (Smith & Chang, 1996), NETRA (Ma
& Manjunath, 1997) and Blobworld (Carson, Thomas, Belongie, Hellerstein, & Malik,
1999). The problem is that although all these systems index regions, they lack of a higher
level description of images. Hence, they are not able to describe  and hence query for 
more than a single region at a time in an image.
In order to improve retrieval performances, much attention has been paid in recent
years to relevance feedback. Relevance feedback is the mechanism, widely used in textual
information systems, which allows improving retrieval effectiveness by incorporating the
user in the query-retrieval loop. Depending on the initial query the system retrieves a set
of documents that the user can mark either as relevant or irrelevant. The system, based on
the user preferences, refines the initial query retrieving a new set of documents that should
be closer to the users information need.
This issue is particularly relevant in feature-based approaches, as on one hand, the user
lacks of a language to express in a powerful way her information need, but on the other
hand, deciding whether an image is relevant or not takes just a glance. Examples of systems
using relevance feedback include MARS (Rui, Huang, & Mehrotra, 1997), DrawSearch
(Di Sciascio & Mongiello, 1999) and PicHunter (Cox et al., 2000).
2.2 Approaches Based on Spatial Constraints
This type of approach to the problem of image retrieval concentrates on finding the similarity of images in terms of spatial relations among objects in them. Usually the emphasis
is only on relative positions of objects, which are considered as symbolic images or icons,
identified with a single point in the 2D-space. Information on the content and visual appearance of images are normally neglected.
212

fiStructured Knowledge Representation for Image Retrieval

Chang, Shi, and Yan (1983) present the modeling of this type of images in terms of
2D-strings, each of the strings accounting for the position of icons along one of the two
planar dimensions. In this approach retrieval of images basically reverts to simpler string
matching.
Gudivada and Raghavan (1995) consider the objects in a symbolic image associated
with vertexes in a weighted graph. Edges  i.e., lines connecting the centroids of a pair of
objects  represent the spatial relationships among the objects and are associated with a
weight depending on their slope. The symbolic image is represented as an edge list. Given
the edge lists of a query and a database image, a similarity function computes the degree of
closeness between the two lists as a measure of the matching between the two spatial-graphs.
The similarity measure depends on the number of edges and on the comparison between
the orientation and slope of edges in the two spatial-graphs. The algorithm is robust with
respect to scale and translation variants in the sense that it assigns the highest similarity to
an image that is a scale or translation variant of the query image. An extended algorithm
includes also rotational variants of the original images.
More recent papers on the topic include those by Gudivada (1998) and by El-Kwae
and Kabuka (1999), which basically propose extensions of the strings approach for efficient
retrieval of subsets of icons. Gudivada (1998) defines R-strings, a logical representation of
an image. Such representation also provides a geometry-based approach to iconic indexing
based on spatial relationships between the iconic objects in an image individuated by their
centroid coordinates. Translation, rotation and scale variant images and the variants generated by an arbitrary composition of these three geometric transformations are considered.
The approach does not deal with object shapes, nor with other basic image features, and
considers only the sequence of the names of the objects. The concatenation of the objects is
based on the euclidean distance of the domain objects in the image starting from a reference
point. The similarity between a database and a query image is obtained through a spatial
similarity algorithm that measures the degree of similarity between a query and a database
image by comparing the similarity between their R-strings. The algorithm recognizes rotation, scale and translation variants of the image and also subimages, as subsets of the
domain objects. A constraint limiting the practical use of this approach is the assumption
that an image can contain at most one instance of each icon or object.
El-Kwae and Kabuka (1999) propose a further extension of the spatial-graph approach,
which includes both the topological and directional constraints. The topological extension of
the objects can be obviously useful in determining further differences between images that
might be considered similar by a directional algorithm that considers only the locations
of objects in term of their centroids. The similarity algorithm they propose extends the
graph-matching one previously described by Gudivada and Raghavan (1995). The similarity
between two images is based on three factors: the number of common objects, the directional
and topological spatial constraint between the objects. The similarity measure includes the
number of objects, the number of common objects and a function that determines the
topological difference between corresponding objects pairs in the query and in the database
image. The algorithm retains the properties of the original approach, including its invariance
to scaling, rotation and translation and is also able to recognize multiple rotation variants.
213

fiDi Sciascio, Donini & Mongiello

2.3 Logic-based and Structured Approaches
With reference to previous work on Vision in Artificial Intelligence, the use of structural
descriptions of objects for the recognition of their images can be dated back to Minskys
frames, and some work by Brooks (1981). The idea is to associate parts of an object (and
generally of a scene) to the regions an image can be segmented into. The hierarchical
organization of knowledge to be used in the recognition of an object was first proposed by
Marr (1982). Reiter and Mackworth (1989) proposed a formalism to reason about maps as
sketched diagrams. In their approach, the possible relative positions of lines are fixed and
highly qualitative (touching, intersecting).
Structured descriptions of three-dimensional images are already present in languages
for virtual reality like VRML (Hartman & Wernecke, 1996) or hierarchical object modeling. However, the semantics of such languages is operational, and no effort is made to
automatically classify objects with respect to the structure of their appearance.
Meghini, Sebastiani, and Straccia (2001) proposed a formalism integrating Description
Logics and image and text retrieval, while Haarslev, Lutz, and Moeller (1998) integrate
Description Logics with spatial reasoning. Further extensions of the approach are described
by Moeller, Neumann, and Wessel (1999). Both proposals build on the clean integration of
Description Logics and concrete domains of Baader and Hanschke (1991). However, neither
of the formalisms can be used to build complex shapes by nesting more simple shapes.
Moreover, the proposal by Haarslev et al. (1998) is based on the logic of spatial relations
named RCC8, which is enough for specifying meaningful relations in a map, but it is too
qualitative to specify the relative sizes and positions of regions in a complex shape.
Also for Hacid and Rigotti (1999) description logics and concrete domains are at the
basis of a logical framework for image databases aimed at reasoning on query containment.
Unfortunately, the proposed formalism cannot consider geometric transformations neither
determine specific arrangements of shapes.
More similar to our approach is the proposal by Ardizzone, Chella, and Gaglio (1997),
where parts of a complex shape are described with a description logic. However, the composition of shapes does not consider their positions, hence reasoning cannot take positions
into account.
Relative position of parts of a complex shape can be expressed in a constraint relational
calculus in the work by Bertino and Catania (1998). However, reasoning about queries
(containment and emptiness) is not considered in this approach. Aiello (2001) proposes a
multi-modal logic, which provides a formalism for expressing topological properties and for
defining a distance measure among patterns.
Spatial relation between parts of medical tomographic images are considered by Tagare,
Vos, Jaffe, and Duncan (1995). There, medical images are formed by the intersection of the
image plane and an object. As the image plane changes, different parts of the object are
considered. Besides, a metric for arrangements is formulated by expressing arrangements
in terms of the Voronoi diagram of the parts. The approach is limited to medical image
databases and does not provide geometrical constraints.
Compositions of parts of an image are considered in the work by Sanfeliu and Fu
(1983) for character recognition. However, in recognizing characters, line compositions
are closed, in the sense that one looks for the specified lines, and no more. Instead in our
214

fiStructured Knowledge Representation for Image Retrieval

framework, the shape F composed by three lines, is subsumed by the shape   something unacceptable in recognizing characters. Apart from the different task, this approach
does not make use of an extensional semantics for composite shapes, hence no reasoning is
possible.
A logic-based multimedia retrieval system was proposed by Fuhr, Govert, and Rolleke
(1998); the method, based on an object-oriented logic, supports aggregated objects but it
is oriented towards a high-level semantic indexing, which neglects low-level features that
characterize images and parts of them.
In the field of computation theories of recognition, we mention two approaches that have
some resemblance to our own: Biedermans structural decomposition and geometric constraints proposed by Ullman, both described by Edelmann (1999). Unfortunately, neither of
them appears suitable for realistic image retrieval: the structural decomposition approach
does not consider geometric constraints between shapes, while the approach based on geometric constraints does not consider the possibility of defining structural decomposition of
shapes, hence reasoning on them.
Starting with the reasonable assumption that the recognition of an object in a scene
can be eased by previous knowledge on the context, in the work by Pirri and Finzi (1999),
the recognition task, or the interpretation of an image, takes advantage of the information
a cognitive agent has about the environment, and by the representation of these data in a
high-level formalism.

3. Syntax and Semantics
In this section we present the formalism dealing with the definition of composite shape descriptions, their semantics, and some properties that distinguish our approach from previous
ones.
We remark that our formalism deals with image features, like shape, color, texture, but
is independent of the way features are extracted from actual images. For the interested
reader, the algorithms we used to compute image features in our implementation of the
formalism are presented in the Appendix.
3.1 Syntax
Our main syntactic objects are basic shapes, position of shapes, composite shape descriptions, and transformations. We also take into account the other features that typically
determine the visual appearance of an image, namely color and texture.
Basic shapes are denoted with the letter B, and have an edge contour e(B) characterizing
them. We assume that e(B) is described as a single, closed 2D-curve in a space whose origin
coincides with the centroid of B. Examples of basic shapes can be circle, rectangle, with
the contours e(circle) = , e(rectangle) =
, but also any complete, rough contour
 e.g., the one of a ship  is a basic shape. To make our language compositional, we
consider only the external contour of a region. For example, if a region is contained in
another, as in  , the contour of the outer region is just the external rectangle.
The possible transformations are the simple ones that are present in any drawing tool:
rotation (around the centroid of the shape), scaling and translation. We globally denote a
215

fiDi Sciascio, Donini & Mongiello

Figure 1: The graphical interface with a query by sketch.
rotation-translation-scaling transformation as  . Recall that transformations can be composed in sequences 1  . . . n , and they form a mathematical group.
The basic building block of our syntax is a basic shape component hc, t, , Bi, which
represents a region with color c, texture t, and edge contour  (e(B)). With  (e(B)) we
denote the pointwise transformation  of the whole contour of B. For example,  could
specify to place the contour e(B) in the upper left corner of the image, scaled by 1/2 and
rotated 45 degrees clockwise.
Composite shape descriptions are conjunctions of basic shape components  each one
with its own color and texture  denoted as
C = hc1 , t1 , 1 , B1 i u    u hcn , tn , n , Bn i
We do not expect end users of our system to actually define composite shapes with this
syntax; this is just the internal representation of a composite shape. The system can
maintain it while the user draws  with the help of a graphic tool  the complex shape by
dragging, rotating and scaling basic shapes chosen either from a palette, or from existing
images (see Figure 1).
For example, the composite shape lighted-candle could be defined as
lighted-candle = hc1 , t1 , 1 , rectanglei u hc2 , t2 , 2 , circlei
216

fiStructured Knowledge Representation for Image Retrieval

with 1 , 2 placing the circle as a flame on top of the candle, and textures and colors defined
accordingly to the intuition.
We remark that, to the best of our knowledge, the logic we present is the first one
combining shapes and explicit transformations in one language.
In a previous paper (Di Sciascio, Donini, & Mongiello, 2000) we presented a formalism
including nested composite shapes, as it is done in hierarchical object modeling (Foley et al.,
1996, Ch.7). However, nested composite shapes can always be flattened by composing their
transformations. Hence in this paper we focus on two levels: basic shapes and compositions
of basic shapes. Also, just to simplify the presentation of the semantics, in the following
section we do not present color and texture features, which we take into account from
Section 4.2 on.
3.2 Semantics
We consider an extensional semantics, in which syntactic expressions are interpreted as
subsets of a domain. For our setting, the domain of interpretation is a set of images , and
shapes and components are interpreted as subsets of . Hence, also an image database is
a domain of interpretation, and a complex shape C is a subset of such a domain  the
images to be retrieved from the database when C is viewed as a query.
This approach is quite different from previous logical approaches to image retrieval that
view the image database as a set of facts, or logical assertions, e.g., the one based on
Description Logics by Meghini et al. (2001). In that setting, image retrieval amounts to
logical inference. However, observe that usually a Domain Closure Assumption (Reiter,
1980) is made for image databases: there are no regions but the ones which can be seen in
the images themselves. This allows one to consider the problem of image retrieval as simple
model checking  check if a given structure satisfies a description2 .
Formally, an interpretation is a pair (I, ), where  is a set of images, and I is a
mapping from shapes and components to subsets of . We identify each image I with the
set of regions {r1 , . . . ,rn } it can be segmented into (excluding background, which we discuss
at the end of this section). Each region r comes with its own edge contour e(r). An image
I   belongs to the interpretation of a basic shape component h, BiI if I contains a
region whose contour matches  (e(B)). In formulae,
h, BiI = {I   | r  I : e(r) =  (e(B))}

(1)

The above definition is only for exact recognition of shape components in images, due to
the presence of strict equality in the comparison of contours; but it can be extended to
approximate recognition as follows. Recall that the characteristic function f S of a set S is a
function whose value is either 1 or 0; fS (x) = 1 if x  S, fS (x) = 0 otherwise. We consider
now the characteristic function of the set defined in Formula (1). Let I be an image; if I
belongs to h, BiI , then the characteristic function computed on I has value 1, otherwise
it has value 0. To keep the number of symbols low, we use the expression h, BiI also to
2. Obviously, a Domain Closure Assumption on regions is not valid in artificial vision, dealing with twodimensional images of three-dimensional shapes (and scenes), because solid shapes have surfaces that
will be hidden in their images. But this is outside the scope of our retrieval problem.

217

fiDi Sciascio, Donini & Mongiello

denote the characteristic function (with an argument (I) to distinguish it from the set).
I

h, Bi (I) =

(

1 if r  I : e(r) =  (e(B))
0
otherwise

Now we reformulate this function in order to make it return a real number in the range [0, 1]
 as usual in fuzzy logic (Zadeh, 1965). Let sim(, ) be a similarity measure from pairs of
contours into the range [0, 1] of real numbers (where 1 is perfect matching). We use sim(, )
instead of equality to compare edge contours. Moreover, the existential quantification can
be replaced by a maximum over all possible regions in I. Then, the characteristic function
for the approximate recognition in an image I of a basic component, is:
h, BiI (I) = max{sim(e(r),  (e(B)))}
rI

Note that sim depends on translations, rotation and scaling, since we are looking for regions
in I whose contour matches e(B), with reference to the position and size specified by  .
The interpretation of basic shapes, instead, includes a translation-rotation-scaling invariant recognition, which is commonly used in single-shape Image Retrieval. We define the
interpretation of a basic shape as
B I = {I   |  r  I : e(r) =  (e(B))}
and its approximate counterpart as the function
B I (I) = max max{sim(e(r),  (e(B)))}


rI

The maximization over all possible transformations max can be effectively computed by
using a similarity measure simss that is invariant with reference to translation-rotationscaling (see Section 4.2). Similarity of color and texture will be added as a weighted sum
in Section 4.2. In this way, a basic shape B can be used as a query to retrieve all images
from  which are in B I . Therefore, our approach generalizes the more usual approaches
for single-shape retrieval, such as Blobworld (Carson et al., 1999).
Composite shape descriptions are interpreted as sets of images that contain all components of the composite shape. Components can be anywhere in the image, as long as
they are in the described arrangement relative to each other. Let C be a composite shape
description h1 , B1 i u    u hn , Bn i. In exact matching, the interpretation is the intersection
of the sets interpreting each component of the shape:
C I = {I   |  : I  ni=1 h(  i ), Bi iI }

(2)

Observe that we require all shape components of C to be transformed into image regions
using the same transformation  . This preserves the arrangement of the shape components
relative to each other  given by each i  while allowing C I to include every image
containing a group of regions in the right arrangement, wholly displaced by  .
To clarify this formula, consider Figure 2: the shape C is composed by two basic shapes
B1 and B2 , suitably arranged by the transformations 1 and 2 . Suppose now that 
contains the image I. Then, I  C I because there exists the transformation  , which
218

fiStructured Knowledge Representation for Image Retrieval

Figure 2: An example of application of Formula (2).
globally brings C into I, that is,   1 brings the rectangle B1 into a rectangle recognized
in I, and   2 brings the circle B2 into a circle recognized in I, both arranged according
to C. Note that I could contain also other shapes, not included in C.
We can now formally define the recognition of a shape in an image.
Definition 1 (Recognition) A shape description C is recognized in an image I if for
every interpretation (I, ) such that I  , it is I  C I . An interpretation (I, ) satisfies
a composite shape description C if there exists an image I   such that C is recognized in
I. A composite shape description is satisfiable if there exists an interpretation satisfying it.
Observe that shape descriptions could be unsatisfiable: if two components define overlapping
regions, no image can be segmented in a way that satisfies both components. Of course, if
composite shape descriptions are built using a graphical tool, unsatisfiability can be easily
avoided, so we assume that descriptions are always satisfiable. Anyway, unsatisfiable shape
descriptions could be easily detected, from their syntactic form, since unsatisfiability can
only arise because of overlapping regions (see Proposition 4).
Observe also that our set-based semantics implies the intuitive interpretation of conjunction u  one could easily prove that u is commutative and idempotent.
For approximate matching, we modify definition (2), following the fuzzy interpretation
of u as minimum, and existential as maximum:
n

C I (I) = max {min {h(  i ), Bi iI (I)}}


i=1

(3)

Observe that our interpretation of composite shape descriptions strictly requires the presence of all components. In fact, the measure by which an image I belongs to the interpreta219

fiDi Sciascio, Donini & Mongiello

tion of a composite shape description C I is dominated by the least similar shape component
(the one with the minimum similarity). Hence, if a basic shape component is very dissimilar
from every region in I, this brings near to 03 also the measure of C I (I). This is more strict
than, e.g., Gudivada & Raghavans (1995) or El-Kwae & Kabukas (1999) approaches, in
which a non-appearing component can decrease the similarity value of C I (I), but I can be
still above a threshold.
Although this requirement may seem a strict one, it captures the way details are used
to refine a query: the dominant shapes are used first, and, if the retrieved set is still too
large, the user adds details to restrict the results. In this refinement process, it should not
happen that other images that match only some new details, pop up enlarging the set of
results that the user was trying to restrict. We formalize this refinement process through
the following definition.
Proposition 1 (Downward refinement) Let C be a composite shape description, and
.
let D be a refinement of C, that is D = C u h 0 , B 0 i. For every interpretation I, if shapes
are interpreted as in (2), then D I  C I ; if shapes are interpreted as in (3), then for every
image I it holds D I (I)  C I (I).
Proof. For (2), the claim follows from the fact that D I considers an intersection of the same
components as the one of C I , plus the set h(   0 ), B 0 iI . For (3), the claim analogously
follows from the fact that D I (I) computes a minimum over a superset of the values considered for C I (I).

The above property makes our language fully compositional. Namely, let C be a composite shape description; we can consider the meaning of C  when used as a query  as
the set of images that can be potentially retrieved using C. At least, this will be the meaning perceived by an end user of a system. Downward refinement ensures that the meaning
of C can be obtained by starting with one component, and then progressively adding other
components in any order. We remark that for other frameworks cited above (Gudivada &
Raghavan, 1995; El-Kwae & Kabuka, 1999) this property does not hold. We illustrate the
problem in Figure 3. Starting with shape description C, we may retrieve (among many
others) the two images I1 , I2 , for which both C I (I1 ) and C I (I2 ) are above a threshold t,
while another image I3 is not in the set because C I (I3 ) < t. In order to be more selective, we try adding details, and we obtain the shape description D. Using D, we may still
retrieve I2 , and discard I1 . However, I3 now partially matches the new details of D. If
Downward refinement holds, D I (I3 )  C I (I3 ) < t, and I3 cannot pop up. In contrast,
if Downward refinement does not hold (as in Gudivada & Raghavans approach) it can be
DI (I3 ) > t > C I (I3 ) because matched details in D raise the similarity sum weighted over
all components. In this case, the meaning of a sketch cannot be defined in terms of its
components.
Downward refinement is a property linking syntax to semantics. Thanks to the extensional semantics, it can be extended to an even more meaningful semantic relation, namely,
3. Not exactly 0, since every shape matches every other one with a very low similarity measure. Similarity
is often computed as the inverse of a distance. Similarity 0 would correspond to infinite distance.
Nevertheless, the recognition algorithm can force the similarity to 0 when it is below a threshold.

220

fiStructured Knowledge Representation for Image Retrieval

Figure 3: Downward refinement: the thin arrows denote non-zero similarity in approximate
recognition. The thick arrow denotes a refinement.

221

fiDi Sciascio, Donini & Mongiello

Figure 4: An example of subsumption hierarchy of shapes (thick arrows), and images in
which the shapes can be recognized (thin arrows).

subsumption. We borrow this definition from Description Logics (Donini, Lenzerini, Nardi,
& Schaerf, 1996), and its fuzzy extensions (Yen, 1991; Straccia, 2001).
Definition 2 (Subsumption) A description C subsumes a description D if for every
interpretation I, D I  C I . If (3) is used, C subsumes D if for every interpretation I and
image I  , it is D I (I)  C I (I).
Subsumption takes into account the fact that a description might contain a syntactic variant
of another, without both the user and the system explicitly knowing this fact. The notion
of subsumption extends downward refinement. It enables also a hierarchy of shape descriptions, in which a description D is below another C if D is subsumed by C. When C and
D are used as queries, the subsumption hierarchy makes easy to detect query containment.
Containment can be used to speed up retrieval: all images retrieved using D as a query can
be immediately retrieved also when C is used as a query, without recomputing similarities.
While query containment is important in standard databases (Ullman, 1988), it becomes
even more important in an image retrieval setting, since the recognition of specific features
in an image can be computationally demanding.
Figure 4 illustrates an example of subsumption hierarchy of basic and composite shapes
(thick arrows denote a subsumption between shapes), and two images in which shapes can
be recognized (thin arrows).
Although we did not consider a background, it could be added to our framework as a
special basic component hc, t, , backgroundi with the property that a region b satisfies the
222

fiStructured Knowledge Representation for Image Retrieval

background simply if their colors and textures match, with no check on the edge contours.
Also, more than one background could be added; in that case background regions should
not overlap, and the matching of background regions should be considered after the regions
of all the basic shapes recognized are subtracted to the background regions.

4. Reasoning and Retrieval
We envisage several reasoning services that can be carried out in a logic for image retrieval:
1. shape recognition: Given an image I and a shape description D, decide if D is recognized in I.
2. image retrieval: given a database of images and a shape description D, retrieve all
images in which D can be recognized.
3. image classification: given an image I and a collection of descriptions D 1 , . . . , Dn , find
which descriptions can be recognized in I. In practice, I is classified by finding the
most specific descriptions (with reference to subsumption) it satisfies. Observe that
classification is a way of preprocessing recognition.
4. description subsumption (and classification): given a (new) description D and a collection of descriptions D1 , . . . , Dn , decide whether D subsumes (or is subsumed by)
each Di , for i = 1, . . . , n.
While services 12 are standard in an image retrieval system, services 34 are less obvious,
and we briefly discuss them below.
The process of image retrieval is quite expensive, and systems usually perform off-line
processing of data, amortizing its cost over several queries to be answered on-line. As an
example, all document retrieval systems for the web4 , both for images and text, use spiders
to crawl the web and extract some relevant features (e.g., color distributions and textures
in images, keywords in texts), that are used to classify documents. Then, the answering
process uses such classified, extracted features of documents  and not the original data.
Our system can adapt this setting to composite shapes, too. In our system, a new
image inserted in the database is immediately segmented and classified in accordance with
the basic shapes that compose it, and the composite descriptions it satisfies (Service 3). Also
a query undergoes the same classification, with reference to the queries already answered
(Service 4). The more basic shapes are present, the faster will the system answer new
queries based on these shapes.
More formally, given a query (shape description) D, if there exists a collection of descriptions D1 , . . . , Dn and all images in the database were already classified with reference
to D1 , . . . , Dn , then it may suffice to classify D with reference to D1 , . . . , Dn to find (most
of) the images satisfying D. This is the usual way in which classification in Description
Logics  which amounts to a semantic indexing  can help query answering (Nebel, 1990).
For example, to answer the query asking for images containing an arch, a system may
classify arch and find that it subsumes threePortalsGate (see Figure 4). Then, the system
4. e.g., Altavista, QBIC, NETRA, Blobworld, but also Yahoo (for textual documents).

223

fiDi Sciascio, Donini & Mongiello

can include in the answer all images in which ancient Roman gates can be recognized,
without recomputing whether these images contain an arch or not.
The problem of computing subsumption between descriptions is reduced to recognition
in the next section, and then an algorithm for exact recognition is given. Then, we extend
the algorithm to realistic approximate recognition, reconsidering color and texture.
4.1 Exact Reasoning on Images and Descriptions
We start with a reformulation of (2), more suited for computational purposes.
Theorem 2 (Recognition as mapping) Let C = h1 , B1 i u    u hn , Bn i be a composite
shape description, and let I be an image, segmented into regions {r 1 , . . . ,rm }. Then C is
recognized in I iff there exists a transformation  and an injective mapping j : {1, . . . , n} 
{1, . . . , m} such that for i = 1, . . . , n it is
e(rj(i) ) =  (i (e(Bi )))
Proof. From (2), C is recognized in I iff
 [I 

n
\

h(  i ), Bi iI ] which is equivalent to  [

i=1

n
^

I  h(  i ), Bi iI ]

i=1

Expanding h(  i ), Bi iI with its definition (1) yields
 [

n
^

r  I.e(r) =  (i (e(Bi )))]

i=1

and since regions in I are {r1 , . . . ,rm } this is equivalent to
 [

m
n _
^

e(rj ) =  (i (e(Bi )))]

i=1 j=1

Making explicit the disjunction over j and conjunctions over i, we can arrange this conjunctive formula as a matrix:




(e(r1 ) =  (1 (e(B1 )))      e(rm ) =  (1 (e(B1 )))) ) 


..
.
..
 
.
 
.
 .. 
(e(r1 ) =  (n (e(Bn )))      e(rm ) =  (n (e(Bn )))) )

(4)

Now we note two properties in the above matrix of equalities:
1. For a given transformation, at most one region among r1 , . . . ,rm can be equal to each
component. This means that in each row, at most one disjunct can be true for a given
.
2. For a given transformation, a region can match at most one component. This means
that in each column, at most one equality can be true for a given  .
224

fiStructured Knowledge Representation for Image Retrieval

We observe that these properties do not imply that regions have all different shapes, since
the equality of contours depends on any translation, rotation, and scaling. We use equality
to represent true overlap, and not just equal shape.
Properties 12 imply that the above formula is true iff there is an injective function
mapping each component to one region it matches with. To ease the comparison with the
formulae above we use the same symbol j as a mapping j : {1, . . . , n}  {1, . . . , m}. Hence,
Formula (4) can be rewritten into the claim:
 [j : {1..n}  {1..m}

n
^

e(rj(i) ) =  (i (e(Bi )))]

(5)

i=1

Hence, even if in the previous section the semantics of a composite shape was derived from
the semantics of its components, in computing whether an image contains a composite shape
one can focus on groups of regions, one group rj(1) , . . . , rj(n) for each possible mapping j.
Observe that j injective implies m  n, as one would expect. The above proposition
leaves open which one between  or j must be chosen first. In fact, in what follows we
show that the optimal choice for exact recognition is to mix decisions about j and  . When
approximate recognition will be considered, however, exchanging quantifiers is not harmless.
In fact, it can change the order in which approximations are made. We return to this
issue in the next section, when we discuss how one can devise algorithms for approximate
recognition.
Subsumption in this simple logic for shape descriptions relies on the composition of
contours of basic shapes. Intuitively, to actually decide if D is subsumed by C, we check
if the sketch associated with D  seen as an image  would be retrieved using C as a
query. From a logical perspective, the existentially quantified regions in the semantics of
shape descriptions (1) are skolemized with their prototypical contours. Formal definitions
follow.
Definition 3 (Prototypical image) Let B be a basic shape. Its prototypical image is
I(B) = {e(B)}. Let C = h1 , B1 i u    u hn , Bn i be a composite shape description. Its
prototypical image is I(C) = {1 (e(B1 )), . . . , n (e(Bn ))}.
In practice, from a composite shape description one builds its prototypical image just applying the stated transformations to its components (and color/texture fillings, if present).
Recall that we envisage this prototypical image to be built directly by the user, with the
help of a drawing tool, with basic shapes and colors as palette items. The system will
just keep track of the transformations corresponding to the users actions, and use them in
building the (internal) shape descriptions stored with the previous syntax. The feature that
makes our proposal different from other query-by-sketch retrieval systems, is precisely that
our sketches have also a logical meaning. So, properties about description/sketches can be
proved, containment between query sketches can be stated in a formal way, and algorithms
for containment checking can be proved correct with reference to the semantics.
Prototypical images have some important properties. The first is that they satisfy (in
the sense of Definition 1) the shape description they exemplify  as intuition would suggest.
225

fiDi Sciascio, Donini & Mongiello

Proposition 3 For every composite shape description D, if D is satisfiable then the interpretation hI, {I(D)}i satisfies D.
Proof. From Theorem 2, using an identical transformation  and the identity mapping for
j.

A shape description D is satisfiable if there are no overlapping regions in I(D). Since
this is obvious when D is specified by a drawing tool, we just give the following proposition
for sake of completeness.
Proposition 4 A shape description D is satisfiable iff its prototypical image I(D) contains
no overlapping regions.
We now turn to subsumption. Observe that if B1 and B2 are basic shapes, either they
are equivalent (each one subsumes the other) or neither of the two subsumes the other. If we
adopt for the segmented regions an invariant representation, (e.g. Fourier transforms of the
contour) deciding equivalence between basic shapes, or recognizing whether a basic shape
appears in an image, is just a call to an algorithm computing the similarity between shapes.
This is what usual image recognizers do  allowing for some tolerance in the matching
of the shapes. Therefore, our framework extends the retrieval of shapes made of a single
component, for which effective systems are already available.
We now consider composite shape descriptions, and prove the main property of prototypical images, namely, the fact that subsumption between shape descriptions can be
decided by checking if the subsumer can be recognized in the sketch of the subsumee.
Theorem 5 A composite shape description C subsumes a description D if and only if C
is recognized in the prototypical image I(D).
Proof. Let C = h1 , B1 i u    u hn , Bn i, and let D = h1 , A1 i u    u hm , Am i. Recall that
I(D) is defined by I(D) = {1 (e(A1 )), . . . , m (e(Am ))}. To ease the reading, we sketch the
idea of the proof in Figure 5.
If. Suppose C is recognized in I(D), that is, I(D)  C I for every interpretation (I, )
such that I(D)  . Then, from Theorem 2 there exists a transformation  and a suitable
injective function j from {1, . . . , n} into {1, . . . , m} such that
e(rj(k) ) =   k (e(Bk ))

for k = 1, . . . , n

Since I(D) is the prototypical image of D, we can substitute each region with the basic
shape of D it comes from:
j(k) (e(Aj(k) )) =   k (e(Bk ))

for k = 1, . . . , n

(6)

Now suppose that D is recognized in an image J = {s1 , . . . ,sp }, with J  . We prove that
also C is recognized in J. In fact, if D is recognized in J then there exists a transformation
 and another injective mapping q from {1, . . . , m} into {1, . . . , p} selecting from J regions
{sq(1) , . . . , sq(m) } such that
e(sq(h) ) =   h (e(Ah ))
226

for h = 1, . . . , m

(7)

fiStructured Knowledge Representation for Image Retrieval

(prototypical image of) C


S

S

S
S S
 
S S
 
S S
 
S S
 
S S 

S S
    
S S 

 
S S
 
S

 

S


 



S






  







 



m











 


prototypical image I(D)



image J
Figure 5: A sketch of the If-proof of Theorem 5
Now composing q and j  that is, selecting the regions of J satisfying those components
of D which are used to recognize C  one obtains
e(sq(j(k)) ) =   j(k) (e(Aj(k) ))

for k = 1, . . . , n

(8)

Then, substituting equals for equals from (6), one finally gets
e(sq(j(k)) ) =     k (e(Bk ))

for k = 1, . . . , n

which proves that C too is recognized in J, using    as transformation of its components,
and q(j()) as injective mapping from {1, . . . , n} into {1, . . . , p}. Since J is a generic image,
it follows that D I  C I . Since (I, ) is generic too, C subsumes D.
Only if. The reverse direction is easier: suppose C subsumes D. By definition, this
amounts to D I  C I for every collection of images I. For every I that contains I(D), then
I(D)  D I for Proposition 3. Therefore, I(D)  C I , that is, C is recognized in I(D).

This property allows us to compute subsumption as recognition, so we concentrate on
complex shape recognition, using Theorem 2. Our concern is how to decide whether there
exists a transformation  and a matching j having the properties stated in Theorem 2.
It turns out that for exact recognition, a quadratic upper bound can be attained for the
possible transformations to try.

227

fiDi Sciascio, Donini & Mongiello

Theorem 6 Let C = h1 , B1 i u    u hn , Bn i be a composite shape description, and let I
be an image, segmented into regions {r1 , . . . ,rm }. Then, there are at most m(m  1) exact
matches between the n basic shapes and the m regions. Moreover, each possible match can
be verified by checking the matching of n pairs of contours.
Proof. A transformation  matching exactly basic components to regions is also an
exact match for their centroids. Hence we concentrate on centroids. Each correspondence
between a centroid of a basic component and a centroid of a region yields two constraints
for  . Now  is a rigid motion with scaling, hence it has four degrees of freedom (two
degrees for translations, one for rotation, and one for uniform scaling). Hence, if an exact
match  exists between the centroids of the basic components and the centroids of some of
the regions, then  is completely determined by the transformation of any two centroids of
the basic shapes into two centroids of the regions.
Fixing any pair of basic components B1 , B2 , let p1 , p2 denote their centroids. Also,
let rj(1) , rj(2) be the regions that correspond to B1 , B2 , and let vj(1) , vj(2) , denote their
centroids. There is only one transformation  solving the point equations (each one mapping
a point into another)
(
 (1 (p1 )) = vj(1)
 (2 (p2 )) = vj(2)
Hence, there are only m(m  1) such transformations. For the second claim, once a 
matching the centroids is found, one checks that the edge contours of basic components
and regions coincide, i.e., that  (1 (e(B1 ))) = e(rj(1) ),  (2 (e(B2 ))) = e(rj(2) ), and for
k = 3, . . . , n that  (k (e(Bk )) coincides with the contour of some region e(rj(k) ).
Recalling Formula (5) in the proof of Theorem 2, this means that we can eliminate the
outer quantifier in (5) using a computed  , and conclude that C is recognized in I iff:
j : {1..n}  {1..m}

n
^

e(rj(i) ) =  (i (e(Bi )))

i=1

Observe that, to prune the above search, once a  has been found as above, one can
check for k = 3, . . . , n that  (k (centr(Bk ))) coincides with a centroid of some region rj ,
before checking contours.
Based on Theorem 6, we can devise the following algorithm:
Algorithm Recognize (C,I);
input a composite shape description C = h1 , B1 i u    u hn , Bn i, and
an image I, segmented into regions r1 , . . . ,rm
output True if C is recognized in I, False otherwise
begin
(1) compute the centroids v1 , . . . ,vm of r1 , . . . ,rm
(2) compute the centroids p1 , . . . ,pn of the components of C
(3) for i, h  {1, . . . , m} with i < h do
compute the transformation  such that  (p1 ) = vi and  (p2 ) = vh ;
228

fiStructured Knowledge Representation for Image Retrieval

if for every k  {1, . . . , n}
 (k (e(Bk ))) coincides (for some j) with a region rj in I
then return True
endfor
return False
end
The correctness of Recognize (C,I) follows directly from Theorems 2 and 6. Regarding
the time complexity, step (1) requires to compute centroids of segmented regions. Several
methods for computing centroids are well known in the literature (Jahne, Haubecker, &
Geibler, 1999). Hence, we abstract from this detail, and assume there exists a function
f (Nh , Nv ) that bounds the complexity of computing one centroid, where Nh , Nv are the
horizontal and vertical dimensions of I (number of pixels). We report in the Appendix how
we compute centroids, and concentrate on the complexity in terms of n, m, and f (N h , Nv ).
Theorem 7 Let C = h1 , B1 i u    u hn , Bn i be a composite shape description, and let I be
an image with Nh  Nv pixels, segmented into regions {r1 , . . . ,rm }. Moreover, let f (Nh , Nv )
be a function bounding the complexity of computing the centroid of one region. Then C can
be recognized in I in time O(m  f (Nh , Nv ) + n + m2  n  Nh  Nv ).
Proof. From the assumptions, Step (1) can be performed in time O(mf (Nh , Nv )). Instead,
Step (2) can be accomplished by extracting the n translation vectors from the transformations 1 , . . . ,n of the components of C. Therefore, it requires O(n) time. Finally, the
innermost check in Step (3)  checking whether a transformed basic shape and a region
coincide  can be performed in O(Nh  Nv ), using a suitable marking of pixels in I with
the region they belong to. Hence, we obtain the claim.

Since subsumption between two shape descriptions C and D can be reduced to recognizing C in I(D), the same upper bound holds for checking subsumption between composite
shape descriptions, with the simplification that also Step (1) can be accomplished without
any further feature-level image processing.
4.2 Approximate Recognition
The algorithm proposed in the previous section assumes an exact recognition. Since the
target of retrieval are real images, approximate recognition is needed. We start by reconsidering the proof of Theorem 2, and in particular the matrix of equalities (4). Using
the semantics for approximate recognition (3), the expanded formula for evaluating C I (I)
becomes now the following:

max min




 max{sim(e(r1 ),  (1 (e(B1 )))),



..
.
max{sim(e(r1 ),  (n (e(Bn ))),



. . . , sim(e(rm ),  (1 (e(B1 ))))) } 

..
..
.
.
...,

sim(e(rm ),  (n (e(Bn ))))

}




Now Properties 12 stated for exact recognition can be reformulated as hypotheses about
sim, as follows.
229

fiDi Sciascio, Donini & Mongiello

1. For a given transformation, we assume that at most one region among r 1 , . . . ,rm is
maximally similar to each component. This assumption can be justified by supposing
its negation: if there are two regions both maximally similar to a component, then
this maximal value should be a very low one, lowering the overall value because of the
external minimization. This means that in maximizing each row, we can assume that
the maximal value is given by one index among 1, . . . , m.
2. For a given transformation, we assume that a region can yield a maximal similarity for
at most one component. Again, the rationale of this assumption is that when a region
yields a maximal similarity with two components in two different rows, this value can
be only a low one, which propagates along the overall minimum. This means that in
minimizing the maxima from all rows, we can consider a different region in each row.
We remark that also in the approximate case these assumptions do not imply that regions
have all different shapes, since sim is a similarity measure which is 1 only for true overlap,
not just for equal shapes with different pose. The assumptions just state that sim should
be a function near to plain equality.
The above assumptions imply that we can focus on injective mappings from {1..n} into
{1..m} also for the approximate recognition, yielding the formula
max


n

min{sim(e(rj(i) ),  (i (e(Bi ))))}

max

j:{1..n}{1..m} i=1

The choices of  and j for the two maxima are independent, hence we can consider groups
of regions first:
max

n

j:{1..n}{1..m}

max min{sim(e(rj(i) ),  (i (e(Bi ))))}


i=1

(9)

Differently from the exact recognition, the choice of an injective mapping j does not directly
lead to a transformation  , since now  depends on how the similarity of transformed shapes
is computed, that is, the choice of  depends on sim.
In giving a definition of sim, we reconsider the other image features (color, texture) that
were skipped in the theoretical part to ease the presentation of semantics. This will introduce weighted sums in the similarity measure, where weights are set by the user according
to the importance of the features in the recognition.
Let sim(r, hc, t, , Bi) be a similarity measure that takes a region r (with its color c(r)
and texture t(r)) and a component hc, t, , Bi into the range [0, 1] of real numbers (where 1
is perfect matching). We note that color and texture similarities do not depend on transformations, hence their introduction does not change Assumptions 12 above. Accordingly,
Formula (9) becomes
max

j:{1..n}{1..m}

n

max min{sim(rj(i) , hc, t, (  i ), Bi i)}


i=1

(10)

This formula suggests that from all the groups of regions in an image that might resemble
the components, we should select the groups that present the higher similarity. In artificially
constructed examples in which all shapes in I and C resemble each other, this may generate
an exponential number of groups to be tested. However, we can assume that in realistic
230

fiStructured Knowledge Representation for Image Retrieval

images the similarity between shapes is selective enough to yield only a very small number
of possible groups to try. We recall that in Gudivadas approach (Gudivada, 1998) an
even stricter assumption is made, namely, each basic component in C does not appear
twice, and each region in I matches at most one component in C. Hence our approach
extends Gudivadas one, also for this aspect  besides the fact that we consider shape,
scale, rotation, color and texture of each component.
In spite of the assumptions made, finding an algorithm for computing the best 
in Formula (10) proved for us a difficult task. The problem is that there is a continuous
spectrum of  to be searched, and that the best  may not be unique. We observed that
when only single points are to be matched  instead of regions and components  our
problem simplifies to Point Pattern Matching in Computational Geometry. However, even
recent results in that research area are not complete, and cannot be directly applied to
our problem. Cardoze and Schulman (1998) solve the nearly-exact point matching with
efficient randomized methods, but without scaling. They also observe that best match is
a more difficult problem than nearly-exact match. Also Chew, Goodrich, Huttenlocher,
Kedem, Kleinberg, and Kravets (1997) propose a method for best match of shapes, but
they analyze only rigid motions without scaling.
Therefore, we adopt some heuristics to evaluate the above formula. First of all, we
decompose sim(r, hc, t, , Bi) as a sum of six weighted contributions.
Three contributions are independent of the pose: color, texture and shape. The values of color and texture similarity are denoted by simcolor (c(r), c) and simtexture (t(r), t),
respectively. Similarity of the shapes (rotation-translation-scale invariant) is denoted by
simshape (e(r), e(B)). For each feature, and each pair (region, component) we compute a
similarity measure as explained in the Appendix. Then, we assign to all similarities of a
feature  say, color  the worst similarity in the group. This yields a pessimistic estimate
of Formula (10); however, for such estimate the Downward Refinement property holds (see
next Theorem 8).
The other three contributions depend on the pose, and try to evaluate how the pose
of each region in the selected group is similar to the pose specified by the corresponding
component in the sketch. In particular, simscale (e(r),  (e(B)) represents how similar in scale
are the region and the transformed component, while simrotation (e(r),  (e(B)) denotes how
e(r) and  (e(B) are similarly (or not) rotated with reference to the arrangement of the
other components. Finally, simspatial (e(r),  (e(B)) denotes a measure of how coincident are
the centroids of the region and the transformed component.
In summary, we get the following form for the overall similarity between a region and a
component:
sim(r, hc, t, , Bi) = simspatial (e(r),  (e(B))   +
simshape (e(r), e(B))   +
simcolor (c(r), c)   +
simrotation (e(r),  (e(B))   +
simscale (e(r),  (e(B))   +
simtexture (t(r), t)  
231

fiDi Sciascio, Donini & Mongiello

where coefficients , , , , ,  weight the relevance each feature has in the overall similarity
computation. Obviously, we impose  +  +  +  +  +  = 1, and all coefficients are greater
or equal to 0. The actual values given to these coefficients in the implemented system are
reported in Table 2 in Section 6.
Because of the difficulties in computing the best  , we do not compute a maximum over
all possible  s. Instead, we evaluate whether there can be a rigid transformation with scaling
from 1 (e(B1 )), . . . , n (e(Bn )) into rj(1) , . . . , rj(n) , through similarities simspatial , simscale ,
and simrotation . There is a transformation iff all these similarities are 1. If not, the lower
the similarities are, the less rigid the transformation should be to match components and
regions. Hence, instead of Formula (10) we evaluate the following simpler formula:
max

n

min{sim(rj(i) , hc, t, i , Bi i)}

j:{1..n}{1..m} i=1

(11)

interpreting pose similarities in a different way. We now describe in detail how we estimate
pose similarities.
Let C = hc1 , t1 , 1 , B1 i) u    u hcn , tn , n , Bn i), and let j be an injective function from
{1..n} into {1..m}, that matches components with regions {rj(1) , . . . , rj(n) } respectively.
4.2.1 Spatial Similarity
For a given component  say, component 1  we compute all angles under which the other
components are seen from 1. Formally, let i1h
c be the counter-clockwise-oriented angle with
vertex in the centroid of component 1, and formed by the lines linking this centroid with
the centroids of component i and h. There are n(n  1)/2 such angles.
Then, we compute the correspondent angles for region rj(1) , namely, angles j(i)j(1)j(h)
d
with vertex in the centroid of rj(1) , formed by the lines linking this centroid with the
centroids of regions rj(i) and rj(h) respectively. A pictorial representation of the angles is
given in Figure 6.
Then we let the difference spatial (e(rj(1) ), 1 (e(B1 )) be the maximal absolute difference
between correspondent angles:
spatial (e(rj(1) ), 1 (e(B1 )) =

max

i,h=2,...,n,i6=h

|}
{|i1h
d
c  j(i)j(1)j(h)

We compute an analogous measure for components 2,. . . ,n, and then we select the maximum
of such differences:
n

spatial [j] = max{spatial (e(rj(i) ), i (e(Bi ))}
i=1

(12)

where the argument j highlights the fact that this measure depends on the mapping
j. Finally, we transform this maximal difference  for which perfect matching yields 0
 into a minimal similarity  perfect matching yields 1  with the help of the function  described in the Appendix. This minimal similarity is then assigned to every
simspatial (e(rj(i) ), i (e(Bi )), for i = 1, . . . , n.
Intuitively, our estimate measures the difference in the arrangement of centroids between
the composite shape and the group of regions. If there exists a transformation bringing
components into regions exactly, every difference is 0, and so simspatial raises to 1 for every
232

fiStructured Knowledge Representation for Image Retrieval

f2

 214

f3

f2

213

f1

f1

f3

 215

f2

 314

f1

f3

 315

f4

 415

f4

f4

f5

f5

R2

R3

f5

R2

R3

R2

R3

 215
 214
 213
 315

R1
R4

 314

R4

R5

R1

R1
R4

R5

415

R5

Figure 6: Representation of angles used for computing spatial similarity of component 1
and region rj(1) .

233

fiDi Sciascio, Donini & Mongiello

R1

f1

 51u

 51h
 41h
 31h
 21h

f2

u

R2

h

 41u

 31u

F5

 21u

R5
R3

f3
R4

f4

Figure 7: Representation of angles used for computing rotation similarity of component 1
and region rj(1) .

component. The more an arrangement is scattered with reference to the other arrangement,
the higher its maximum difference. The reason why we use the maximum of all differences
as similarity for each pair component-region will be clear when we prove later that this
measure obeys Downward Refinement property.
4.2.2 Rotation Similarity
For every basic shape one can imagine a unit vector with origin in its centroid and oriented
horizontally on the right (as seen on the palette). When the shape is used as a component
 say, component 1  also this vector is rotated according to 1 . Let ~h denote such a
rotated vector. For i = 2, . . . , n let  c~ the counter-clockwise-oriented angle with vertex in
i1h
the centroid of component 1, and formed by ~h and the line linking the centroid of component

1 with the centroid of component i.
For region rj(1) , the analogous ~u of ~h can be constructed by finding the rotation phase
for which cross-correlation attains a maximum value (see Appendix). Then, for i = 2, . . . , n
let j(i)j(1)~
u and the line
d u be the angles with vertex in the centroid of rj(1) , and formed by ~
linking the centroid of rj(1) with the centroid of rj(i) . Figure 7 clarifies the angles we are
computing.
Then we let the difference rotation (e(rj(1) ), 1 (e(B1 )) be the maximal absolute difference
between correspondent angles:
rotation (e(rj(1) ), 1 (e(B1 )) = max {| c~  j(i)j(1)~
d u |}
i=2,...,n
i1h

If there is more than one orientation of rj(1) for which cross-correlation yields a maximum 
e.g., a square has four such orientations  then we compute the above maximal difference
for all such orientations, and take the best difference (the minimal one).
234

fiStructured Knowledge Representation for Image Retrieval

fi

mi

Ri

Mi

Dj
dj
Rj
fj

Figure 8: Sizes and distances for scale similarity computation of component 1 and region
rj(1) .

We repeat the process for components 2 to n, and we select the maximum of such
differences:
n

rotation [j] = max{rotation (e(rj(i) ), i (e(Bi ))}
i=1

(13)

Finally, as for spatial similarity, we transform rotation [j] into a minimal similarity with
the help of . This minimal similarity is then assigned to every simrotation (e(rj(i) ), i (e(Bi )),
for i = 1, . . . , n.
Observe that also these differences drop to 0 when there is a perfect match, hence the
similarity raises to 1. The more a region has to be rotated with reference to the other
regions to match a component, the higher the rotational differences. Again, the fact that
we use the worst difference to compute all rotational similarities will be exploited in the
proof of Downward Refinement.
4.2.3 Scale Similarity
We concentrate again on component 1 to ease the presentation. Let m 1 be the size of
component 1, computed as the mean distance between its centroid and points on the contour.
Moreover, for i = 2, . . . , n, let d1i be the distance between the centroid of component 1 and
the centroid of component i. In the image, let Mj(1) be the size of region rj(i) , and let
Dj(1)j(i) be the distance between centroids of regions j(1) and j(i). Figure 8 pictures the
quantities we are computing.
We define the difference in scale between e(rj(1) ) and 1 (e(B1 ) as:
)
(

min{Mj(1) /Dj(1)j(i) , m1 /d1i } 

scale (e(rj(1) ), 1 (e(B1 )) = max 1 

i=2,...,n 
max{Mj(1) /Dj(1)j(i) , m1 /d1i } 
235

fiDi Sciascio, Donini & Mongiello

We repeat the process for components 2 to n, and we select the maximum of such differences:
n

scale [j] = max{scale (e(rj(i) ), i (e(Bi ))}
i=1

(14)

Finally, as for the other similarities, we transform scale [j] into a minimal similarity with
the help of . This minimal similarity is then assigned to every simscale (e(rj(i) ), i (e(Bi )),
for i = 1, . . . , n.
4.2.4 Discussion of Pose Similarities
Using the same worst difference in evaluating pose similarities of all components may appear
a somewhat drastic choice. However, we were guided in this choice by the goal of preserving
the Downward Refinement property, even if we had to abandon the exact recognition of the
previous section.
Theorem 8 Let C be a composite shape description, and let D be a refinement of C, that
.
is, D = C uhc0 , t0 ,  0 , B 0 i. For every image I, segmented into regions r1 , . . . ,rm , if C I (I) and
DI (I) are computed as in (11) using similarities defined above, then it holds D I (I)  C I (I).
Proof. Every injective function j used to map components of C into I can be extended to
a function j 0 by letting j 0 (n + 1)  {1, . . . , m} be a suitable region index not in the range
of j. Since D I (I) is computed over such extended mappings, it is sufficient to show that
values computed in Formula (11) do not increase with reference to the values computed for
C.
Let j1 be the mapping for which the maximum value C I (I) is reached. Every extension
I
j10 of j1 leads to a minimum value minn+1
i=1 in Formula (11) which is lower than C (I). In fact,
all pose differences (12), (13), (14), are computed as maximums over a strictly greater set
of values, hence the pose similarities have either the same value, or a lower one. Regarding
color, texture, and shape similarities, adding another component can only worsen the values
for components of C, since we assign to all components the worst similarity in the group.
Now consider another injective mapping j2 that yields a non-maximum value v2 < C I (I)
in Formula (11). Using the above argument about pose differences (12), (13), (14), every
extension j20 leads to a minimum value v20  v2 . Since v2 < C I (I), also every extension of
every mapping j different from j1 yields a value which is less than C I (I). This completes
the proof.

5. A Prototype System
In order to substantiate our ideas we have developed a prototype system, written in C++.
The system is a client-server application working in a MS-Windows environment.
The client side avails of a graphical user interface that allows one to carry out all the
operations necessary to query the knowledge base, including a canvas for query by sketch
composition using basic shapes and a module for query by example using new or existing
images as queries. The client also allows a user to insert new shape descriptions and images
in the knowledge base. The client has the logical structure shown in Figure 9. It is made
up of three main modules: sketch, communication and configuration.
236

fiStructured Knowledge Representation for Image Retrieval

Figure 9: Architecture of the prototype system.

237

fiDi Sciascio, Donini & Mongiello

Figure 10: The process of reclassification of images when a new description is inserted: a)
before insertion of description (No. 9); b) after insertion.

The communication module manages the communication with the server side, using
a simple application-level protocol. The configuration module allows one to modify the
parameters relative to the preview of images and shapes transferred from the server and
placed in a cache managed with a FCFS policy for efficient display. The sketch module
allows a user to trace basic shapes as palette items, and properly insert and modify them
by varying the scale and rotation factor. The available shapes may be basic ones such as
ellipse, circle, rectangle, polygons or obtained by composing the basic shapes or complex
shapes defined during previous sessions of the application and inserted in the knowledge
base, but also shapes extracted from segmented images.
The system keeps track of the transformations corresponding to the users actions, and
uses them in building the (internal) shape descriptions stored with the previously described
syntax. The color and texture of the drawn shapes can be set according to the user requirements, as the client interface provides a color palette and the possibility to open images in
JPEG format with texture content. The user can also load images from the local disk and
transmit them to the server to populate the knowledge base. Finally, the user can define
new objects endowing them with a textual description and insert them into the knowledge
base.
The server side, which is also shown in Figure 9, is composed by concurrent threads
that manage the server-side graphical interface, the connections and communications with
the client applications and carry out the processing required by the client side. Obviously,
238

fiStructured Knowledge Representation for Image Retrieval

Figure 11: A query and the retrieved set of images.

239

fiDi Sciascio, Donini & Mongiello

the server also carries out all tasks related to the insertion of images in the knowledge base,
including segmentation, feature extraction and region indexing, and allows one to properly
set the various parameters involved. To this end, the server has three main subcomponents:
1. the image features extractor that contains an image segmentation module and a region
data extraction one;
2. the image classifier that is composed by a classifier module and a module used in the
image reclassification;
3. the database management system.
The feature extractor segments and processes images to extract relevant features from
each detected region, which characterize the images in the knowledge base. Image segmentation is carried out with an algorithm that starts with the extraction of relevant edges and
then carries out a region growing procedure that basically merges smaller regions into larger
ones according to their similarity in terms of color and texture. Detected regions obviously
have to comply with some minimal heuristics. Each region has associated a description of
the relevant features.
The classifier manages a graph that is used to represent and hierarchically organizes
shape descriptions: basic shapes, and more complex ones obtained by combining such elementary shapes and/or by applying transformations (rotation, scaling and translation).
The basic shapes have no parents, so they are at the top of the hierarchy. Images, when
inserted in the knowledge base after the segmentation process, are linked to the descriptions
in the structure depending on the most specific descriptions that they are able to satisfy.
The classifier module is invoked when a new description D has to be inserted in the
system or a new query is posed. The classifier carries out a search process in the hierarchy
to find the exact position where the new description D (a simple or a complex one) has to be
inserted: the position is determined considering the descriptions that the new description
is subsumed by. Once the position has been found, the image reclassifier compares D with
the images available in the database to determine those that satisfy it; all the images that
verify the recognition algorithm are tied to D. This stage only considers the images that
are tied to descriptions that are direct ancestors of D, as outlined in Figure 10.
As usual in Description Logics, also the query process consists of a description insertion,
as both a query Q and a new description D are treated as prototypical images: a query
Q to the system is considered a new description D and added to the hierarchical data
structure; all images that are connected either to Q or to descriptions below the query in
the hierarchical structure are returned as retrieved images.
The database management module simply keeps track of images and/or pointers to
images.
Using the system is a straightforward task. After logon a user can draw a sketch on
the canvas combining available basic shapes, and enrich the query with color and texture
content. After that the query can be posed to the server to obtain images ranked according
to their similarity. Figure 11 shows a query by sketch with two circles and the retrieved
set. The system correctly retrieves pictures of cars in which the two circles are recognized
in the same relative positions of the sketch and represent the wheels, but also a snow man
with black buttons.
240

fiStructured Knowledge Representation for Image Retrieval

Figure 12: Downward refinement (contd.): A more detailed query, picturing a car, and the
retrieved set of images.

241

fiDi Sciascio, Donini & Mongiello

Figure 13: A Subsumption example: increasing the number of objects in the query leads to
a correct reduction in the retrieved set.
242

fiStructured Knowledge Representation for Image Retrieval

The introduction of more details restricts the retrieved set: adding a chassis to the
previous sketch makes the query more precise, as well as the retrieval results, as it is shown
in Figure 12. This example points out how we expect a user will use the system. He/she will
start with a generic query with a few objects. If the number of images in the retrieved set is
still too large, he/she will increase the number of details obtaining a downward refinement.
Notice that the presence of regions/objects not included in the query is obviously accepted but not the lack of a region that was explicitly introduced in the query. The idea
underlying this approach is that there is an enormous amount of available images, and at
the current stage of research and technology no system can always ensure a complete recognition; yet we believe that the focus should be on reducing false positives, accepting without
much concern a higher ratio of false negatives. This basically means increasing precision,
even at the cost of a possibly lower recall. In other words we believe it is preferable for a
user looking for an image containing a yellow car, e.g., using the sketch in Figure 12, that
he/she receives as result of the query a limited subset of images containing almost for sure
a yellow car, than a large amount of images containing cars, but also several images with
no cars at all.
Subsumption is another distinguishing feature of our system. Figure 13 shows queries
composed of basic shapes that have been obtained by segmentation of an image picturing
aircrafts, i.e., the aircraft is now a basic shape for the system. Here, to better emphasize
the example, only shape and position contribute to the similarity value. The process of
subsumption is clearly highlighted: a query with just a single aircraft retrieves images with
one aircraft, but also with more than one aircraft. Adding other aircrafts in the graphical
query correctly reduces the retrieved set. The example also points out that the system is
able to correctly deal with the presence of more than one instance of an object in images,
which is not possible in the approaches by Gudivada and Raghavan (1995) and Gudivada
(1998). On the negative side it has to be noticed that the system did not recognize the
presence of a third aircraft (indeed a strange one, the B2-Spirit) in the second image of
Figure 13-b), which was not segmented at all and considered part of the background.
The ability of the system to retrieve complex objects also in images with several other
different objects, that is with no main shapes, can be anyway seen in Figure 14. Here a
real image is directly submitted as query. Notice that in this case the system has to carry
out the segmentation process on the fly, and detect the composing shapes.

6. Experiments and Results
In order to assess the performance of the proposed approach and of the system implementing
it, we have carried out an extensive set of experiments on a test dataset of images. It is
well known that evaluating performances of an image retrieval system is difficult because
of lack of ground truth measures. To ease the possibility of a comparison, we adopted the
approach first proposed by Gudivada and Raghavan (1995). The experimental framework is
hence largely based on the one proposed there, which relies on a comparison of the system
performances versus the judgement of human experts.
It should be noticed that in that work test images were iconic images, which were
classified only in terms of spatial relationships between icons; in our experiments images
243

fiDi Sciascio, Donini & Mongiello

Figure 14: A query by example and retrieved images.

244

fiStructured Knowledge Representation for Image Retrieval

Figure 15: A sample of the images used in the experiments.

245

fiDi Sciascio, Donini & Mongiello

are real and classification has been carried out on all image features, including color, texture,
shape, scale, orientation and spatial relationships.
The test data set consists of a collection of 93 images; a sample of them is shown in
Figure 15, while the complete set is available at URL:
http://www-ictserv.poliba.it/disciascio/jair images.htm.
Images have been acquired using a digital camera, combining 18 objects, either simple
objects (i.e., a single shape) or composite ones, of variable size and color. All images had
size 1080  720 pixels, 24 bits/pixel. It should be noticed that actually there were more
than 18 different objects, but we considered very similar variants of an object, e.g., two
pens with a different color, as a single test object.
We selected from the test data set 31 images to be used as queries. The query set formed
two logical groupings.
The first one (namely queries 1 through 15 and queries 27, 30 and 31) had as primary
objective testing the performance of the system using as query single objects composed by
various shapes. That is, assessing the ability of the system to detect and retrieve images
containing the same object, or objects similar to the query.
The query images in the second group (remaining images in the test data set) pictured
two or more objects and they were chosen to assess the ability of the system to detect and
retrieve images according to spatial relationships existing between the objects in the query.
Obviously the difference between queries containing single objects composed by several
shapes, and queries containing two or more objects, is just a cognitive one: for our system
all queries are composite shapes. However, we observed that performances changed for the
two groupings.
We then separately asked five volunteers to classify in decreasing order, according to
their judgment, the 93 images based on their similarity to each image of the selected query
set. The volunteers had never used the system and they were only briefly instructed that
rank orderings had to be based on the degree of conformance of the database images with
the query images. They were allowed to group images when considered equivalent, and for
each query, to discard images that were judged wholly dissimilar from the query.
Having obtained five classifications, which were not univocal, we created the final ranking
merging the previous similarity rankings according to a minimum ranking criterion. The
final ranking of each image with respect to a query was determined as the minimum one
among the five available.
As an example consider the classification of Query nr.1, which is shown in Table 1.
Notice that images grouped together in the same cell have been given the same relevance.
Here Image 2 was ranked in third position by users 1,4, and 5, but as users 2 and 3 ranked
it in fourth position, it was finally ranked in position four. Notice that for image 24 the
same criterion leads to its withdrawal from ranked images. This approach limits the weight
that images badly classified by single users have on the final ranking.
Then we submitted the same set of 31 queries to the system, whose knowledge base was
loaded only with the 93 images of the test set.
The behavior of the system obviously depends on the configuration parameters, which
determine the relevance of the various features involved in the similarity computation. The
configuration parameters fed to the system were experimentally determined on a test bed of
246

fiStructured Knowledge Representation for Image Retrieval

user
1
2
3
4
5
final

1st
1
1
1
1
1
1

2nd
44, 88
44, 88
44, 88
44, 88
44, 88
44, 88

ranking
3rd
2, 3, 68, 80
3, 68, 80
3, 68, 80
2, 3, 68, 80
2, 3, 68, 80
3, 68, 80

4th
26
2, 26
2, 26
26
24 26
2, 26

5th
24

24

Table 1: Users rankings for query nr.1
Parameter
Fourier descriptors threshold
Circular symmetry threshold
Spatial similarity threshold
Symmetry maxima threshold
Spatial similarity weight 
Spatial similarity sensitivity f x
spatial similarity sensitivity f y
shape similarity weight 
shape similarity sensitivity f x
shape similarity sensitivity f y
color similarity weight 
color similarity sensitivity f x
color similarity sensitivity f y
rotation similarity weight 
rotation similarity sensitivity f x
rotation similarity sensitivity f y
texture similarity weight 
texture similarity sensitivity f x
texture similarity sensitivity f y
scale similarity weight 
scale similarity sensitivity f x
scale similarity sensitivity f y
global similarity threshold

Value
0.98
0.99
0.30
0.10
0.30
90.0
0.40
0.30
0.005
0.20
0.11
110.0
0.40
0.11
90.0
0.40
0.07
110.0
0.40
0.11
0.50
0.40
0.70

Table 2: Configuration parameters, grouped by feature type.

approximately 500 images before starting the test phase. They are shown in Table 2. The
parameters reported here are described in the Appendix. Notice that, dealing with welldefined objects, we gave an higher relevance to shape and spatial features and a reduced
relevance to scale, rotation, color and texture.
The resulting classification gave us what was called a system-provided ranking. We then
adopted the Rnorm as quality measure of the retrieval effectiveness. Rnorm has been first
introduced in the LIVE-Project (Bollmann, Jochum, Reiner, Weissmann, & Zuse, 1985)
for the evaluation of textual information retrieval systems and it has been used in the
experiments of the above referenced paper by Gudivada and Raghavan. To make the paper
self-contained we recall here how Rnorm is defined.
Let G be a finite set of images with a user-defined preference relation  that is complete
and transitive. Let usr be the rank ordering of G induced by the user preference relation.
Also, let sys be a system-provided ranking. The formulation of Rnorm is:
Rnorm (sys ) =

1
S+  S
 (1 +
)
+
2
Smax

where S + is the number of image pairs where a better image is ranked by the system
ahead of a worse one; S  is the number of pairs where a worse image is ranked ahead of a
+
better one and Smax
is the maximum possible number of S + . It should be noticed that the
calculation of S + , S  , and S max is based on the ranking of image pairs in sys relative to
the ranking of corresponding image pairs in usr .
247

fiDi Sciascio, Donini & Mongiello

Query nr.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
Average Rnorm

Image nr.
1
2
3
4
5
6
7
10
11
12
13
14
15
18
20
25
26
27
28
31
33
34
35
36
37
39
41
42
50
78
79

Rnorm
0.92
0.92
0.93
0.95
0.99
0.94
0.93
0.93
0.95
0.74
0.60
0.84
0.83
0.99
0.91
0.89
0.80
1.00
0.74
1.00
1.00
0.99
0.91
0.89
1.00
0.99
0.93
0.98
1.00
0.88
1.00
0.92

Table 3: Rnorm values. (indicates single-object queries)

Rnorm values are in the range [0,1]; a value of 1 corresponds to a system-provided
ordering of the database images that is either identical to the one provided by the human
experts or has a higher degree of resolution, lower values correspond to a proportional
disagreement between the two.
Table 3 shows results for each query and the final average Rnorm =0.92. Taking a closer
look at results, for the first group of queries (single compound objects) the average value
was Rnorm =0.90, and Rnorm =0.94 for the second grouping (various compound objects).
(The complete set of result for users ranking and system ranking is available in the online
appendix).
As a comparison, the average Rnorm resulted 0.98 in the system presented by Gudivada
and Raghavan (1995), where 24 iconic images were used both as queries and database
images, and similarity was computed only on spatial relationships between icons. We remark
here that our system works on real images and computes similarity on several image features,
and we believe that results prove the ability of the system to catch to a good extent the
users information need, and make refined distinctions between images when searching for
composite shapes. Furthermore, our algorithm is able to correctly deal with the presence
of more than one instance of an object in images, which is not possible in other approaches
(Gudivada, 1998). It is also noteworthy that, though the parameters setting has been the
object of several experiments, it cannot be considered optimal yet, and we believe that there
is room for further improvement in the system performance, as it is also pointed out in the
following paragraph.
Obviously the system can fail when segmentation does not provide accurate enough
results. Figure 16 shows results for Query 11, which was the one with the worst R norm .
Here the system not only did not retrieve all images users had considered relevant, but
248

fiStructured Knowledge Representation for Image Retrieval

Figure 16: Query results for query 11, which had the lowest Rnorm =0.60.
more important wrongly confused the sugar-drop with a wrist-watch, which resulted in a
false positive. As a matter of fact in various images the sweet-drops resulted not properly
segmented. Nevertheless, highly relevant images were successfully retrieved and the wrongly
retrieved one was slightly above the selection threshold.
Another observation we made was that human users, when comparing a query with a
single object, were much more driven by the color than any other feature, including the
spatial positioning. This appeared in various queries and is again clearly visible using as
example results for Query 11. Here users selected in the highest relevance class only images
with the same color sugar-drop, and gave a lower ranking to images (with sugar-drops) with
closer spatial relationships but different colors. This observation may be significant in the
related field of object recognition.
A final comment. With reference to the system behavior in terms of retrieval time, we
did not carry out a systematic testing, as it depends on several variables: number of images
in the database, number of objects in the query, but more important depth in the hierarchy
- as the search time decreases as more basic shapes are available. Limiting our analysis
to the database loaded with the 93 test images, the system required on average 12 secs to
answer a query, on a machine with Celeron 400 MHz CPU and 128 MB RAM running both
the client and the server.
249

fiDi Sciascio, Donini & Mongiello

7. Conclusion
We proposed a Knowledge Representation approach to Image Retrieval. We started from
the observation that current sketch-based image retrieval systems lack of a compositional
query language  that is, they are not able to handle queries made by several shapes, where
the position, orientation and size of the shapes relative to each other is meaningful.
To recover this, we proposed a language to describe composite shapes, and gave an
extensional semantics to queries, in terms of sets of retrieved images. To cope with a
realistic setting from the beginning, we also generalized the semantics to fuzzy membership
of an image to a description. The composition of shapes is made possible by the explicit
use in our language of geometric transformations (translation-rotation-scale), which we
borrow form hierarchical object modeling in Computer Graphics. We believe that this
is a distinguishing feature of our approach, that significantly extends standard invariant
recognition of single shapes in image retrieval. The extensional semantics allows us to
properly define subsumption (i.e., containment) between queries.
Borrowing also from Structured Knowledge Representation, and in particular from Description Logics, we stored shape descriptions in a subsumption hierarchy. The hierarchy
provides a semantic index to the images in a database. The logical semantics allowed us
to define other reasoning services: the recognition of a shape arrangement in an image, the
classification of an image with reference to a hierarchy of descriptions, and subsumption
between descriptions. These tasks are aside, but can speed up, the main one, which is Image
Retrieval.
We proved that subsumption in our simple logic can be reduced to recognition, and
gave a polynomial-time algorithm to perform exact recognition. Then, for a realistic application of our setting we extended the algorithm to approximate recognition, weighting
shape features (orientation, size, position), color and texture.
Using our logical approach as a formal specification, we built a prototype system using
state-of-the-art technology, and set up experiments both to assess the efficacy of our proposal, and to fine tune all parameters and weights that show up in approximate retrieval.
The results of our experiments, although not exhaustive, show that our approach can catch
to a good extent the users information need and make refined distinctions between images
when searching for composite shapes.
We believe that this proposal opens at least three directions for future research. First,
the language for describing composite shapes could be enriched either with other logicoriented connectives  e.g., alternative components corresponding to an OR in compositions  or to sequences of shape arrangements, to cope with objects with internal movements in video sequence retrieval. Second, techniques from Computational Geometry could
be used to optimize the algorithms for approximate retrieval, while a study in the complexity of the recognition problem for composite shapes might prove the theoretical optimality
of the algorithms. Finally, large-scale experiments might prove useful in understanding the
relative importance attributed by end users to the various features of a composite shape.
Acknowledgements
We wish to thank our former students G. Gallo, M. Benedetti and L. Allegretti for their
useful comments and implementations, Marco Aiello for comments on an earlier draft,
250

fiStructured Knowledge Representation for Image Retrieval

Dino Guaragnella for discussions on Fourier transforms, and an anonymous referee for
constructive criticism that helped us improving the paper.
This research has been supported by the European Union, POP Regione Puglia sottomisura 7.4.1 (SFIDA 3), by the Italian Ministry of Education, University and Research
(MIUR, ex-MURST) projects CLUSTER22 subcluster Monitoraggio ambiente e territorio, workpackage: Sistema informativo per il collocamento dei prodotti ortofrutticoli
pugliesi and by Italian National Council for Research (CNR), projects LAICO, DeMAnD,
and Metodi di Ragionamento Automatico nella modellazione ed analisi di dominio.

Appendix A.
In this appendix we briefly revise the methods we used for the extraction of image features.
We also describe the smoothing function  and the way we compute similarity for the image
features that were introduced in Section 4.2.
A.1 Extraction of Image Features
In order to deal with objects in an image, segmentation is required to obtain a partition
of the image. Several segmentation algorithms have been proposed in the literature; our
approach does not depend on the particular segmentation algorithm adopted. It is anyway
obvious that the better the segmentation, the better our system will work. In our system
we used a simple algorithm that merges edge detection and region growing.
Illustration of this technique is beyond the scope of this paper; we limit here to the
description of image features computation, which assume a successful segmentation. To


make the description self-contained we start defining a generic color image as { I (x, y) | 1 
x  Nh , 1  y  Nv }, where Nh , Nv are the horizontal and vertical dimensions, respectively,


and I (x, y) is a three-components tuple (R, G, B). We assume that the image I has been
partitioned in m regions (ri ), i = 1, . . . , m satisfying the following properties:
 I=

S

(ri ), i = 1, 2, . . . , m

  i  {1, 2, . . . , m}, ri is a nonempty and connected set
 ri  rj =  iff i 6= j
 each region satisfies heuristic and physical requirements.
We characterize each region ri with the following attributes: shape, position, size, orientation, color and texture.
Shape. Given a connected region a point moving along its boundary generates a complex
function defined as: z(t) = x(t) + jy(t), t = 1, . . . , Nb , with Nb the number of boundary
sample points. Following the approach proposed by Rui, She, and Huang (1996) we define
the Discrete Fourier Transform (DFT) of z(t) as:
Z(k) =

Nb
X

z(t)e

j 2tk
N
b

t=1

with k = 1, . . . , Nb .
251

= M (k)ej(k)

fiDi Sciascio, Donini & Mongiello

In order to address the spatial discretization problem we compute the Fast Fourier
Transform(FFT) of the boundary z(t); use the first (2Nc + 1) FFT coefficients to form a
dense, non-uniform set of points of the boundary as:
zdense (t) =

Nc
X

Z(k)e

j 2tk
N
b

k=Nc

with t = 1, . . . , Ndense .
We then interpolate these samples to obtain uniformly spaced samples zunif (t), t =
0, . . . , Nunif . We compute again the FFT of zunif (t) obtaining Fourier coefficients Zunif (k),
k = Nc , . . . , Nc . The shape-feature of a region is hence characterized by a vector of 2N c +1
complex coefficients.
Position and Size. Position is determined as the region centroid computed via moment
invariants (Pratt, 1991). Size is computed as the mean distance between region centroid
and points on the contour.
Orientation. In order to quantify the orientation of each region r i we use the same
Fourier representation, which stores the orientation information in the phase values. We
obviously deal also with special cases when the shape of a region has more than one symmetry, e.g., a rectangle or a circle. Rotational similarity between a reference shape B and
a given region ri can then be obtained finding maximum values via cross-correlation:
C(t) =

2N
Xc
2
1
ZB (k)Zri (k)  ej 2Nc kn with t  0, . . . , 2Nc
2Nc + 1 k=0

Color. Color information of each region ri is stored, after quantization in a 112 values
color space, as the mean RGB value within the region:
Rri =

X

R(p)

G ri =

X

G(p)

B ri =

pri

pri

X

B(p)

pri

Texture. We extract texture information for each region ri with a method based on
the work by Pok and Liu (1999). Following this approach, we extract texture features
convolving the original grey level image I(x, y) with a bank of Gabor filters, having the
following impulse response:
h(x, y) =

2
2
1
 x +y
2 2
 ej2(U x+V y)

e
2 2

where (U, V ) represents the filter location in the frequency-domain,  is the central frequency,  is the scale factor, and  the orientation, defined as:
=

p

U2 + V 2

 = arctan U/V

The processing allows to extract a 24-components feature vector, which characterizes
each textured region.
252

fiStructured Knowledge Representation for Image Retrieval

A.2 Functions for Computing Similarities
Smoothing function . In all similarity measures, we use the function (x, f x, f y). The
role of this function is to change a distance x (in which 0 corresponds to perfect matching)
to a similarity measure (in which the value 1 corresponds to perfect matching), and to
smooth the changes of the quantity x, depending on two parameters f x, f y.
(x, f x, f y) =


x

 f y +"(1  f y)  cos( 2f x )

 fy  1 

arctan[

(xf x)(1f y)
]
f xf y



#

if 0  x < f x
if x > f x

where f x > 0 and 0 < f y < 1.

The input data to the approximate recognition algorithm are a shape description D,
containing n components hck , tk , k , Bk i and an image I segmented into m regions r1 , . . . ,rm .
The algorithm provides a measure for the approximate recognition of D in I.
The first step of the algorithm in Section 4.2 considers all the m regions the image is
segmented into and all the n components in the shape description D and finds  if any  all
the groups of n regions rj(k) satisfying the higher shape similarity with the shape components
of D. To this purpose we compute shape similarity, based on the Fourier representation
previously introduced, as vector of complex coefficients. Such measure denoted with sim ss
is invariant with respect to rotation, scale and translation and is computed as the cosine
distance between the two vectors. The similarity gives a measure in the range [0,1] assuming
the higher similarity simss = 1 for perfect matching.
Given the vectors X and Y of complex coefficients describing respectively the shape of
a region ri and the shape of a component Bk , X = (x1 , . . . , x2Nc ) and Y = (y1 , . . . , y2Nc )
P2Nc

l=1 xl yl
simss (Bk , ri ) = qP
P2Nc 2
2Nc 2
l=1 xl 
l=1 yl

Shape Similarity. The quantity simshape measures the similarity between shapes in
the composite shape description and the regions in the segmented image.
n

simshape = (max[1  simss (Bk , rj(k) )], f xshape , f yshape )
k=1

Color Similarity. The quantity simcolor measures the similarity in terms of color
appearance between the regions and the corresponding shapes in the composite shape description. In the following formula, color (k).R denotes the difference in the red color
component between the k-th component of D and the region rj(k) , and similarly for the
green and the blue color components.
color(k) =

q

[color (k).R]2 + [color (k).G]2 + [color (k).B]2

Then the function  takes the maximum of the differences to obtain a similarity:
n

simcolor = (max{color (k)}, f xcolor , f ycolor )
k=1

253

fiDi Sciascio, Donini & Mongiello

Texture Similarity. Finally, simtexture measures the similarity between the texture
features in the components of D and in the corresponding regions.
texture (k) denotes the sum of differences in the texture components between the k-th
component of D and the region rj(k) and dividing by the standard deviation of the elements.
n

simtexture = (max texture (k), f xtexture , f ytexture )
k=1

References
Aiello, M. (2001). Computing spatial similarity by games. In Esposito, F. (Ed.), Proceedings of the Eighth Conference of the Italian Association for Artificial Intelligence
(AI*IA99), No. 2175 in Lecture Notes in Artificial Intelligence, pp. 99110. SpringerVerlag.
Ardizzone, E., Chella, A., & Gaglio, S. (1997). Hybrid computation and reasoning for
artificial vision. In Cantoni, V., Levialdi, S., & Roberto, V. (Eds.), Artificial Vision,
pp. 193221. Academic Press.
Baader, F., & Hanschke, P. (1991). A schema for integrating concrete domains into concept
languages. In Proceedings of the Twelfth International Joint Conference on Artificial
Intelligence (IJCAI91), pp. 452457, Sydney.
Bach, R., Fuller, C., Gupta, A., Hampapur, A., Horowitz, B., Humphrey, R., Jain, R.,
& Shu, C. (1996). The Virage image search engine: an open framework for image
management. In Storage and Retrieval for Image and Video Databases, Vol. 2670, pp.
7687. SPIE.
Bertino, E., & Catania, B. (1998). A constraint-based approach to shape management in
multimedia databases. MultiMedia Systems, 6, 216.
Bollmann, P., Jochum, F., Reiner, U., Weissmann, V., & Zuse, H. (1985). The LIVEProject-Retrieval experiments based on evaluation viewpoints. In Proceedings of the
8th Annual International ACM SIGIR Conference on Research and Developement in
Information Retrieval (SIGIR 85), pp. 213214. ACM, New York.
Brooks, R. (1981). Symbolic reasoning among 3-D models and 2-D images. Artificial
Intelligence, 17, 285348.
Calvanese, D., Lenzerini, M., & Nardi, D. (1998). Description logics for conceptual data
modeling. In Chomicki, J., & Saake, G. (Eds.), Logics for Databases and Information
Systems, pp. 229264. Kluwer Academic Publisher.
Cardoze, D., & Schulman, L. (1998). Pattern matching for spatial point sets. In Proceedings of the Thirtyninth Annual Symposium on the Foundations of Computer Science
(FOCS98), pp. 156165, Palo Alto, CA.
Carson, C., Thomas, M., Belongie, S., Hellerstein, J. M., & Malik, J. (1999). Blobworld: A
system for region-based image indexing and retrieval. In Huijsmans, D., & Smeulders,
A. (Eds.), Lecture Notes in Computer Science, Vol. 1614, pp. 509516. Springer-Verlag.
Celentano, A., & Di Sciascio, E. (1998). Features integration and relevance feedback analysis
in image similarity evaluation. Journal of Electronic Imaging, 7 (2), 308317.
254

fiStructured Knowledge Representation for Image Retrieval

Chandra, A., & Harel, D. (1980). Computable queries for relational databases. Journal of
Computer and System Sciences, 21, 156178.
Chang, S., Shi, Q., & Yan, C. (1983). Iconic indexing by 2D strings. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 9 (3), 413428.
Chew, L., Goodrich, M., Huttenlocher, D., Kedem, K., Kleinberg, J., & Kravets, D. (1997).
Geometric pattern matching under euclidean motion. Computational Geometry, 7,
113124.
Cox, I., Miller, M., Minka, T., & Papathomas, T. (2000). The bayesian image retrieval
system, PicHunter. IEEE Transactions on Image Processing, 9 (1), 2037.
Di Sciascio, E., Donini, F. M., & Mongiello, M. (2000). A Description logic for image
retrieval. In Lamma, E., & Mello, P. (Eds.), AI*IA 99: Advances in Artificial Intelligence, No. 1792 in Lecture Notes in Artificial Intelligence, pp. 1324. Springer-Verlag.
Di Sciascio, E., & Mongiello, M. (1999). Query by sketch and relevance feedback for contentbased image retrieval over the web. Journal of Visual Languages and Computing,
10 (6), 565584.
Donini, F., Lenzerini, M., Nardi, D., & Schaerf, A. (1996). Reasoning in description logics.
In Brewka, G. (Ed.), Foundations of Knowledge Representation, pp. 191236. CSLIPublications.
Edelmann, S. (1999). Representation and Recognition in Vision. The MIT Press.
El-Kwae, E., & Kabuka, M. (1999). Content-based retrieval by spatial similarity in image
databases. ACM Transactions on Information Systems, 17, 174198.
Flickner, M., Sawhney, H., Niblak, W., Ashley, J., Huang, Q., Dom, B., Gorkani, M., Hafner,
J., Lee, D., Petkovic, D., Steele, D., & Yanker, P. (1995). Query by image and video
content: The QBIC system. IEEE Computer, 28 (9), 2331.
Foley, J., van Dam, A., Feiner, S., & Hughes, J. (1996). Computer Graphics. Addison
Wesley Publ. Co., Reading, Massachussetts.
Fuhr, N., Govert, N., & Rolleke, T. (1998). DOLORES: A system for logic-based retrieval
of multimedia objects. In Proceedings of the 21st Annual International ACM SIGIR
Conference on Research and Developement in Information Retrieval (SIGIR 98), pp.
257265, Melbourne, Australia.
Gevers, T., & Smeulders, A. (2000). Pictoseek: Combining color and shape invariant features
for image retrieval. IEEE Transactions on Image Processing, 9 (1), 102119.
Gudivada, V. (1998). R-string: A geometry-based representation for efficient and effective
retrieval of images by spatial similarity. IEEE Transactions on Knowledge and Data
Engineering, 10 (3), 504512.
Gudivada, V., & Raghavan, J. (1995). Design and evaluation of algorithms for image
retrieval by spatial similarity. ACM Transactions on Information Systems, 13 (2),
115144.
Haarslev, V., Lutz, C., & Moeller, R. (1998). Foundations of spatioterminological reasoning with description logics. In Proceedings of the Sixth International Conference on
Principles of Knowledge Representation and Reasoning (KR98), pp. 112123.
255

fiDi Sciascio, Donini & Mongiello

Hacid, M.-S., & Rigotti, C. (1999). Representing and reasoning on conceptual queries over
image databases. In Proceedings of the Twelfth International Symposium on Methodologies for Intelligent Systems (ISMIS99), No. 1609 in Lecture Notes in Artificial
Intelligence, pp. 340348, Warsaw, Poland. Springer-Verlag.
Hartman, J., & Wernecke, J. (1996). The VRML 2.0 Handbook. Addison-Wesley.
Hirata, K., & Kato, T. (1992). Query by visual example. In Pirotte, A., Delobel, C., &
Gottlob, G. (Eds.), Advances in Database Technology  Proc. 3rd Int. Conf. Extending Database Technology, EDBT, Vol. 580 of Lecture Notes in Computer Science, pp.
5671. Springer-Verlag.
Jacobs, C., Finkelstein, A., & Salesin, D. (1995). Fast multiresolution image querying. In
Proceedings of the 22nd Annual Conference on Computer Graphics and Interactive
Techniques (SIGGRAPH 95), pp. 277286.
Jahne, B., Haubecker, H., & Geibler, P. (1999). Handbook of Computer Vision and Applications. Academic Press.
Ma, W., & Manjunath, B. (1997). NETRA: A toolbox for navigating large image database.
In Proceedings of the IEEE International Conference on Image Processing (ICIP 97),
Vol. 1, pp. 568571, Santa Barbara.
Marr, D. (1982). Vision. W.H. Freeman and Co., Oxford.
Meghini, C., Sebastiani, F., & Straccia, U. (2001). A model of multimedia information
retrieval. Journal of the ACM, 48 (5), 909970.
Moeller, R., Neumann, B., & Wessel, M. (1999). Towards computer vision with description
logics: some recent progress. In Proceedings of the IEEE Integration of Speech and
Image Understanding, pp. 101115.
Nebel, B. (1990). Reasoning and Revision in Hybrid Representation Systems. No. 422 in
Lecture Notes in Artificial Intelligence. Springer-Verlag.
Niblak, W., Barder, R., Equitz, W., Flickner, M., Glasman, E., Petkovic, D., Yanker, P.,
& Faloustos, C. (1993). The QBIC project: Querying images by content using color,
texture, and shape. In Storage and Retrieval for Still Image and Video Databases,
Vol. 1980, pp. 173182. SPIE.
Paquet, E., & Rioux, M. (1998). A content-based search engine for VRML databases.
In Proceedings of IEEE International Conference on Computer Vision and Pattern
Recognition (CVPR98), pp. 541546, Santa Barbara, CA.
Picard, R., & Kabir, T. (1993). Finding similar patterns in large image databases. In
Proceedings of the IEEE International Conference on Acoustics Speech and Signal
Processing (ICASSP 93), pp. 161164, Minneapolis, MN.
Pirri, F., & Finzi, A. (1999). An approach to perception in theory of actions: part 1. In
Linkoping Electronic Articles in Computer and Information Science, No. 41. Linkoping University Electronic Press.
Pok, G., & Liu, J. (1999). Texture classification by a two-level hybrid scheme. In Storage
and Retrieval for Image and Video Databases VII, Vol. 3656, pp. 614622. SPIE.
256

fiStructured Knowledge Representation for Image Retrieval

Pratt, W. (1991). Digital Image Processing. J. Wiley & Sons Inc., Englewood Cliffs, NJ.
Reiter, R., & Mackworth, A. (1989). A logical framework for depiction and image interpretation. Artificial Intelligence, 41 (2), 125155.
Reiter, R. (1980). Equality and domain closure in first-order databases. Journal of the
ACM, 27 (2), 235249.
Rui, Y., Huang, T., & Mehrotra, S. (1997). Content-based image retrieval with relevance
feedback in MARS. In Proceedings of the IEEE International Conference on Image
Processing (ICIP 97), pp. 815818.
Rui, Y., She, A., & Huang, T. (1996). Modified Fourier descriptors for shape representation
- a practical approach. In Proceedings of 1st Workshop on Image Databases and
Multimedia Search, Amsterdam.
Sanfeliu, A., & Fu, K. (1983). A distance measure between attributed relational graphs for
pattern recognition. IEEE Transactions on Systems, Man, and Cybernetics, 13 (3),
353362.
Smith, J., & Chang, S. (1996). VisualSEEK: a fully automated content-based image query
system. In Proceedings of the fourth ACM International Conference on Multimedia
(Multimedia96), pp. 8798.
Straccia, U. (2001). Reasoning within fuzzy description logics. Journal of Artificial Intelligence Research, 14, 137166.
Tagare, H., Vos, F., Jaffe, C., & Duncan, J. (1995). Arrangement: A spatial relation between
parts for evaluating similarity of tomographic section. IEEE Transactions on Pattern
Analysis and Machine Intelligence, 17 (9), 880893.
Ullman, J. D. (1988). Principles of Database and Knowledge Base Systems, Vol. 1. Computer
Science Press, Potomac, Maryland.
Woods, W. A., & Schmolze, J. G. (1992). The KL-ONE family. In Lehmann, F. W. (Ed.),
Semantic Networks in Artificial Intelligence, pp. 133178. Pergamon Press. Published
as a special issue of Computers & Mathematics with Applications, Volume 23, Number
29.
Yen, J. (1991). Generalizing term subsumption languages to Fuzzy logic. In Proceedings of
the Twelfth International Joint Conference on Artificial Intelligence (IJCAI91), pp.
472477.
Zadeh, L. (1965). Fuzzy sets. Information and Control, 8, 338353.

257

fi	ff
fiff ff

 
  !"$#%&ff')(*,+.-//-10321-46521*4

789:; <=/*1>ff/"(?A@9
  &'<B/*1>ff/-

CEDGFH;IKJML1NOIPJQNORTS)L8UWVPX1HZY[NOIP\]H^V_FM`PaOXcbedaOVPfPJhg
FfKHiY[NjUWVkX1H]DlLffFnmoNORcpq`KX1H;JraOIKstY[NOIPJ3FudvaOL1IwFMJ

xzy|{%}~8z{%}$k{3uy

n%uuw3w

q{3yfi~8{%$ycqhM}]y|

uM%Mw3w

%=k6%,=u"hA_|=,
n

A|ff,ff6P	36	ff

=fiz
Bff	ff|	6|A6^1n.fi68wM|;68n)v|	;"fi]8686A
A.|h|nK	^ z)v8|6h)fifin,1fi686"))6
))6.8A"6A"uz;P68j.)||A6GA6
	nnfi86M
 
  w"86jlA)kAz16||z.,Gfifi8|"
fi1wA|6A	n8lffA| ))|q;6wnn86A%
  jfi1|
|wv
 |n,|)
 	6).,fi6|833|1|fiK8n86A|
 ff
A68A|G6.	6|||;l
 |j]AnA
 fi8]81.jA|))1fiwA
fi1.	"_|8
 1|8|1_|kfi8|6
 
 ,P^|"A6,8Kk68
 ff
8"=6]A6^81.fi^h=1fi^G1|filnfi^;.ffl6)
6)nG.AvffAffff
 ^|8w686B16|A| 1G|G)8BA68 "
)|Bfi|ff
  8	hhB8	.6|fi61G|Av),|6.A^8
fi6"_K"6.6w|B6QAz1|66ff]|
 	^|"

 fi!"#$ 
%&('*),+.-0/214357698:3-0;*<>=$%?@<BA;43,C+ED+,+.'F-08&(-G&9<:+,HI3(<J3>K'*&ML5N+,HO6+P8+.-08+,<+.'Q/:3/2RN&('S3'*HT8+M3(<&('0RU'06
V &H0+.5$W V 3/2;*+ V 3/2RN)M35U5UXZY[&(10'*H0+,HZD&(/2;\&('5N&(69RN),<]3'*HZ698:3-0;\/2;*+,&(82XF=$^&ML_3OWa`Mb9cdAfehg_;*&(1069;\/2;*+.X
;43,C+iD+,+.' V 3RU'05UXj<2/21*HORN+,Hk3(<l3I698:3-0;0RN)M35_RU'Q/+.8mY$3(),+\Yn&(8>5N&(69RN),<l&(8l3(<Z3IHORo3698:3 VV 3/2RN)T<2XO<2/+ V
&Y5N&(69RN),<I=pYn&(8ZRU'*<2/:3'*),+9Wq<+,+srt+.8 V +.5URU'06+.8MWu`Mb9b9vOWhY[&(8Z6+.'*+.8:35%?E<+,w10RUC(35N+.'/Z/&yx{zu|}AfWh/2;*+.RU8
698:3-0;O~$/2;*+,&(8+./2RN)uYn&(10'*H*3/2RN&('*<];43MC+D+,+.'5N+,<:<qRU'QC+,</2RU6Q3/+,He]y&9<2/qL&(82KO<RU'/2;0RN<_38+M3>38+5UR V RU/+,H
/&TfpaNl(a:G[O99mBafWG&(8@BaN9mBaT=$^&L3OW{`Mb9cd*%;*+.RU'S1069'0RN+.8MW}`Mb9b9AfW4L;0RN):;
),&(828+,<2-&('*HI/&/2;*+P-G&9<2RU/2RUC+9Wa),&('(10'*)./2RUC+l3'*HI+fORN<2/+.'Q/2Ro35Y8:36 V +.'/u&Y!x}zu|LRU/2;*&(10/JY[10'*)./2RN&('*<Me
g_;0RN< V &H0+.57;43(</2;08+,+EY[10'*H*3 V +.'Q/:35h);438:3()./+.82RN</2RN),<M
`9eJ&(DO2+,)./<38+\D0RU-4382/2RU/+yUQfU(2B4t='*&H0+,<>8+.-08+,<+.'/f4[[[nBT3'*HfU9[[90iD+./L+,+.'
/2;*+,<:+P+.'Q/2RU/2RN+,<BAf
Oe8+M3(<:&('0RU'06<38+@D43(<+,H&('F698:3-0;O~$/2;*+,&(8+./2RN)&(-+.8:3/2RN&('*<MW08+.5UXRU'06&('3lKRU'*HI&Yh698:3-0;I;*& V &~
V &(82-0;0RN< V )M35U5N+,Hsa2mM2,[n(h
 eRU/lRN<5N&(69RN)M35U5UXtYn&(10'*H0+,HWh8+M3(<&('0RU'06<ZDG+.RU'06y<&(10'*H3'*Hk),& V -05N+./+sLPe 8Me /Meyx}zu|<+ V 3'/2RN),<MW
1*<1435U5UXsDXiL_3,XI&Y{/2;*+@/28:3'*<25o3/2RN&(')M35U5N+,HyEe
 3RU'j+fO/+.'*<2RN&('*<&Y/2;*+\<R V -05N+\698:3-0;*< V &H0+.5$W{K+,+.-0RU'06698:3-0;;*& V & V &(82-0;0RN< V D43(<:+,Ht&(-O~
S
+.8:3/2RN&('*<@3'*H<:&(10'*Hy3'*Hy),& V -05N+./+Z<+ V 3'Q/2RN),<MW38+ip,ffaBlBNBF=$?@&9<2;yr1QL&('06<+9W!`Mb9b9vO
^O35UC93/]1069'0RN+.8MWa`Mb9b9O^O35UC93/MW*`Mb9b9cA!3'*HTGB.2E(2B4=$%;*+.RU'7W1069'0RN+.8MWQ^R V &('*+./MWa`Mb9b9cO
 8+.5U5N+.8MWO1069'0RN+.8MWO%;*+.RU'7W`Mb9b9cAfY[&(8_QfGf2(]_+,w10RUC935N+.'Q//&x}zu|]WO3'T&(82RU69RU'435H0+,HO1*)./2RN&('


-//-]u&&4	<	6 ff<_B!1ffzff":ff"|9
  &'"&|M
 
 !'&M&N1<

fi

3MfiuM%

<2XO<2/+ V =[@+.8HORU5N+,<MW0`Mb9b9A}),& V D0RU'*+,<]3'435UX/2RN)/:3D05N+M31OLRU/2;Z/2;*+_<2R V -05N+]698:3-0;*<h-08&2+,)./2RN&('7eq^& V +
KRU'*Hj&Y(*f[2(pai;43,C+sD+,+.'j-08&(-&9<+,H/&C935URNH*3/+s3IK'*&L5N+,HO6+sD43(<+i),& V -&9<+,H&Y<2R V -05N+
698:3-0;*<=[RU'*+M31RN<<:3(&(10R$W7`Mb9b4RUD0RN+9W0E3(+ VV +.825N9Wa|7&(RN<+M317W7`Mb9b9cAfe
rt+-08+,<+.'Q/;*+.8+3uY$3 V RU5UXZ&Y7+fO/+.'*<2RN&('*<]&Y/2;*+J<R V -05N+J698:3-0;*< V &H0+.5$ehg_;*+),& VV &('i698&(10'*H
Yn&(8/2;*+,<+F+f/+.'*<RN&('*<RN<Z/2;43/&(DO2+,)./<\38+j(U(2jBGU(mf48+.-08+,<+.'/2RU'06I,,fWfNB&(8
(*f[2(pafWq3'*Hk&(-G+.8:3/2RN&('*<38+iD43(<+,Hj10-&('k-08&m+,)./2RN&('7e?uRUC+.'3IK'*&ML5N+,HO6+sD43(<+s3'*H3
<2R V -05N+698:3-0;=L;0RN); V 3MX>8+.-08+,<+.'/!3uw1*+.82XW3J6&35$W4e,e,e,W9H0+.-G+.'*HORU'06@&('Z/2;*+3-0-05URN)M3/2RN&('aAfW9/2;*+
Q29O,[n(a2QfNf3(<2KO<{L;*+./2;*+.8)M3'lD+_H0+,HO1*),+,HlY8& V eh),),&(8HORU'06@/&u/2;*+KRU'*H0<h&YG&(DO2+,)./<
),&('*<2RNH0+.8+,HRU'WHOR+.8+.'Q/8+M3(<&('0RU'06 V &H0+.5N<38+&(D0/:3RU'*+,HW),& V -&9<2RU'06/2;*+Y$3 V RU5UXe!g_;*&(1069;
<2R V RU5o38q'*&(/2RN&('*<&Y82105N+,<3'*H),&('*</28:3RU'Q/<)M3'\DG+Yn&(10'*H\RU'/2;*+%?5URU/+.8:3/2108+9W/2;*+.RU8]),& V D0RU'43/2RN&('
RU'\8+M3(<&('0RU'06<];43(H'*+.C+.8]D+,+.'\<2/21*HORN+,He]z'*+RU'/+.8+,<2/&Y&(1083-0-08&3():;i/2;1*<q8+,<2RNH0+,<]RU'-08&MCRNHORU'06
3l10'0RY[XRU'06Y[8:3 V +.L&(82KF),& V D0RU'0RU'06i82105N+,<3'*H),&('*<2/28:3RU'Q/<RU'IHOR+.8+.'/L_3,XO<Me
 'F/2;0RN<J-43-+.8MW0L+@Y[&).1*<J&('I/2;*+EYn&(8 V 35H0+f*'0RU/2RN&('*<&Yh/2;*+,<:+ V &H0+.5N<MW*RU'*).5U1*HORU'06/2;*+.RU8&(-+.8:3~
/2RN&('435<+ V 3'Q/2RN),<3'*Hi8+.5o3/2RN&('*<;0RU-*<LRU/2;Fx}zu|qW*3'*HsL+E<2/21*HOX\/2;*+EH0+,).RNH*3D0RU5URU/XF3'*HT),& V -05N+fORU/X
&Y!/2;*+.RU8u3(<<:&).Ro3/+,HIH0+,).RN<RN&('-08&(D05N+ V <MW4'43 V +.5UXI),&('*<2RN<2/+.'*).X3'*HIH0+,HO1*)./2RN&('7eg_;*+,<+>8+,<2105U/<+f~
/+.'*H3'*H),& V -05N+./+I/2;*+F&('*+,<\35U8+M3(HOX-010D05URN<2;*+,HDX/2;*+I310/2;*&(8<y=[36+./1069'0RN+.8MW_99O`Afe
g_;*&(1069;yDG&(/2;y),&('*<2RN<2/+.'*).X3'*HH0+,HO1*)./2RN&('38+>10'*H0+,).RNH*3D05N+lRU'/2;*+ V &9<2/6+.'*+.8:35 V &H0+.5{&Yq/2;0RN<
Y$3 V RU5UXWL+\;43(Hj35U8+M3(HOX1*<+,H3FH0+,).RNH*3D05N+i<10D*<+./>&Y_82105N+,<>/&I<:&(5UC+/2;*+TG.{*7.:P-08&(D05N+ V W
3T/+,<2/m~$D+,Ht-08&(-&9<+,HRU'j/2;*+\K'*&ML5N+,HO6+T3(),wQ10RN<2RU/2RN&('k),& VV 10'0RU/X=[36+./MWh?E+.'*+,</MW}1069'0RN+.8MW
`Mb9b9bAfert+I-08+,<+.'Q/\;*+.8+FY[&(8/2;*+T*8</\/2R V +3SH0+./:3RU5N+,H3'435UXO<2RN<\&Y@),& V -05N+fORU/XL;*+.'L+I8+f~
<2/282RN)./_/2;*+uK'*&L5N+,HO6+@D43(<+u/&l/2;0RN<KRU'*HT&Y}82105N+,<P=[)M35U5N+,HS2(@Bf[fn,2T82105N+,<BAfehrt+@35N<&Z<2/21*HOX
-4382/2RN).105o38)M3(<:+,<J&Yh),&('*</28:3RU'Q/<Me
 '<+,)./2RN&('D43(<RN)FH0+f*'0RU/2RN&('*<3'*Hk8+,<2105U/<\3DG&(10/\<R V -05N+i698:3-0;*<i38+i8+,)M35U5N+,He^+,)./2RN&(' 
0- 8+,<+.'/<3'I&MC+.82CRN+.L&Yh/2;*+@_tY$3 V RU5UXe  'F-4382/2RN).105o38MW*L+P+f-05o3RU'L;QXsL+P),&('*<2RNH0+.8698:3-0;0RN)M35
Yn+M3/2108+,<J&Y/2;*+@<2R V -05N+E698:3-0;*< V &H0+.573(<+,<<+.'/2Ro35Y[&(8_K'*&ML5N+,HO6+ V &H0+.5URU'063'*HT-&(RU'Q/J&(10/_/2;43/
/2;*+,<+T-08&(-+.82/2RN+,<i38+T-08+,<+.82C+,HRU'/2;*+TY$3 V RU5UXe  ''*+fO/\<+,)./2RN&('*<L+I<2/21*HOXk/2;*+IHOR+.8+.'/
V + V D+.8<s&YE/2;*+IYn3 V RU5UXe105N+,<i38+IRU'/28&HO1*),+,HRU'<:+,)./2RN&('d*W_),&('*<2/28:3RU'Q/<sRU'<:+,)./2RN&('vOW3'*H
<+,)./2RN&('ti<2/21*HORN+,< V &H0+.5N<E),& V D0RU'0RU'06F82105N+,<@3'*HS),&('*<2/28:3RU'/<Me@<u<&&('S3(<82105N+,<@38+lRU'QC&(5UC+,HSRU'
8+M3(<&('0RU'06<MW/2;*+\3(<:<&).Ro3/+,HSH0+,).RN<2RN&('S-08&(D05N+ V <>38+l'*&(/@H0+,).RNH*3D05N+9WD010/@L+l+fO;0RUD0RU/>3i),&('*HORU/2RN&('
=p*'0RU/++fO-43'*<2RN&('<+./<BAl10'*H0+.8iL;0RN);),& V -010/:3/2RN&('*<T35UL_3,XO<i</&(-7e  '/2;*+I-4382/2RN).105o38T)M3(<+I&Y
2(Q2B.[Bn,2y82105N+,<Wa/2;*+Z),& V -05N+fORU/Xy&Y]/2;*+,<+-08&(D05N+ V <uYn35U5{RU'Q/&s/2;*+-G&(5UX'*& V Ro35h;0RN+.8:38);QXe
^+,)./2RN&('sRN<!H0+.C&(/+,H/&u/2;*+,<+H0+,).RNH*3D05N+J)M3(<:+,<Me  '<+,)./2RN&('cOW98+.5o3/2RN&('*<2;0RU-*<qLRU/2;&(/2;*+.8!L&(82KO<q38+
+,<2/:3D05URN<2;*+,He  'I-4382/2RN).105o38L+P-&(RU'Q/&(10/35U6&(82RU/2; V RN)>),&('0'*+,)./2RN&('*<LRU/2;),&('*<2/28:3RU'/<:3/2RN<mY$3()./2RN&('
-08&(D05N+ V <=$%^  Ai3'*H<2;*&L/2;43/s/2;*+I-08&(D05N+ V &Y@):;*+,)KRU'06/2;*+),&('*<2RN<2/+.'*).X&Y>3tK'*&L5N+,HO6+
D43(<+),& V -G&9<+,Hy&Yq<2R V -05N+698:3-0;*<u3'*Hy),&('*<2/28:3RU'Q/<=_7~),&('*<2RN</+.'*).X0AJRN<+,w10RUC(35N+.'//&i/2;43/&Y
H0+,).RNHORU'06/2;*+@),&('*<RN<2/+.'*).XF&Y!3 V R0+,H%^  =[ u ~^!g@WIxa38269RN+.8MW4|3'06*W4^);0RN+fW7`Mb9b9Afe
h\

z(#tz#$

  kqu!q4

rt+8+,)M35U5*RU'/2;0RN<<+,)./2RN&('\D43(<2RN)_'*&(/2RN&('*<3DG&(10/<2R V -05N+J),&('*),+.-0/214354698:3-0;*<=$^&ML3OW`Mb9cd*0%;*+.RU'i
1069'0RN+.8MW`Mb9b9Afe{g_;*+,<+]698:3-0;*<}38+]),&('*<RNH0+.8+,H3(<7/2;*+qK+.82'*+.5Yn&(8 V &9<2/K'*&ML5N+,HO6+8+.-08+,<+.'/:3/2RN&('
Yn&(8 V 35URN< V <JD010RU5U/10-&('y^&ML_3O<L&(82KGe]g_;*+.XT38+>35N<:&Z/2;*+@D43(<2RN) V &H0+.5Y[&(8/2;*+PY$3 V RU5UXe
M

fi M]|9M.tM=uwuMM3
 F

	ff
 y fi;}]}$k{%}

uA{M}h

3(<2RN)Z&('Q/&(5N&(69RN)M35qK'*&ML5N+,HO6+ZRN<E+.'*),&H0+,HSRU'S3s<2/2821*)./2108+)M35U5N+,H3BO9fnePxa3()./21435!K'*&L5N+,HO6+
RN<l+.'*),&H0+,HjRU'Q/&jBGUZ(2B4QS=$^0?E<BAfWhH0+f*'*+,HLRU/2;8+,<-G+,).//&3F69RUC+.'<210-0-&(82/MeI ^0?RN<Z3
D0RU-4382/2RU/+5o3D+.5U5N+,HZ698:3-0;=[<2/282RN)./25UX<-G+M3KRU'06*W9RU/hRN<q3lZ[9mBaW<2RU'*),+_/2;*+.8+)M3'D+_<+.C+.8:35*+,HO6+,<
D+./L+,+.'S/L&i'*&H0+,<BAfeuz'*+>).5o3(<<u&Yq'*&H0+,<8+.-08+,<+.'Q/<@+.'/2RU/2RN+,<MWa/2;*+&(/2;*+.8u).5o3(<<8+.-08+,<:+.'Q/<u8+.5o3~
/2RN&('*<2;0RU-*<]DG+./L+,+.'s/2;*+,<+J+.'Q/2RU/2RN+,<
e &H0+,<]38+5o3D+.5U5N+,H\DX+.5N+ V +.'Q/<_&YG/2;*+<210-0-&(82/Me  5N+ V +.'Q/:382X
8+M3(<&('0RU'06<u38+P),& V -010/+,HFDQXI3l698:3-0;I;*& V & V &(82-0;0RN< V )M35U5N+,HsGmmM2,[n(4e
 "%$'&)(+*,&.-+*0/1*324657&)( (a8
 &.-(T	 9]

 yfi;}]}  M <10-0-G&(82/soT ![aUZ#
O(.[n(p;:j(2Qf2 <q*[i,,>=PB$0,['?(f@:m),&('*),+.-0//X-G+,<y(a8+.5o3/2RN&('/X-+,<A5B&.-pP0(!
[[[[(2S4$yB*BM.C&E-8
D F6F6F &H- G ms2.9[n(	::*BTmF(f	:JI F6F6FLK 2B02,[M?f;:ON KQP ISRT5VU9]
fNff4l2>(o.[pG,qf0f,.(a(O(2QfNW5YX(mf:Z(Z&)((a[&)-92ZQ.a92IS:Z\
N^]\Q_2(*9`
 ]olif0,	 ::*\mY
 _R5+/pOM.JmtRU'*HORUCRNHO1435 V 382K+.8A< 5Y&.(a=&.-(Gb
 /
(PO( 9!p,s(pp,(4c 5 2p\BQap>f2(#
 /$8
 &)(d5eifa9FS :gfS0s6+.'*+.82RN) V 382K+.L8 =
9hOfC
 fgi h /j5  0(f[n(h(mfZ9k
 /JlmTfTn90BnQfBZfNff4m
 /_O9pS 9!oMpG(O(2QfN =
(ao
 fI@(29B.JfU.\.4c 5
5U5-4382/2Ro35&(8H0+.8<\LRU5U5DG+FH0+.'*&(/+,HDX\>W3'*HWRYu'*+,+,H0+,HWRU'*H0+f0+,HDQXk/2;*+F'43 V +I&Yu/2;*+
<+./Z&('L;0RN):;/2;*+.X38+TH0+f*'*+,He  'k/2;0RN<l-43-G+.8Z/2;*+iRU'Q/210RU/2RUC+ V +M3'0RU'06t&Y1]p\q_tRN<35UL_3,XO<r]
pZs02.n( t s9[[9kmY
 _GeEx{RU6*e`l-4382/2Ro35U5UXH0+,<).82RUD+,<@3s<210-0-G&(82/MWGL;0RN):;LRU5U5{D+1*<+,HyRU'Y[1082/2;*+.8
+f*3 V -05N+,<Me
uv
wyx>z,{y|>}~

u.

w3|,x,z

>|>|y,x}c>|,x

yL}|

 |  |,x

zx,S>06~,

>>,3|,x

3|3zyx3y6}3x3|3,,~Lz
0

>|y,>ywyx>z,{y|>}~

>|y,x
,3{3z0

& (

&.-"Vm6&H-  n

/"m7+TT3n
28"mL.3a.OyTg)p
n

x}RU69108+`9]^10-0-G&(82/

= QMq
< G(? fSfM0(f>
= pToq
< *[

 y fi;}]}  	 B`yB{ <R V -05N+F698:3-0;QCZ
f
O(.[Sl[(2B4$"$(*-4*L*465((aB-(0aMQS,.=\2B02,[M?f;:m
),&('*),+.-0/s'*&H0+,<(am8+.5o3/2RN&(''*&H0+,<A5 pF0l[oM.l2+,HO6+,<A5p
 MBa.nQf4Z(
f[[(aQs(2s$$(p;
: (2Qf2>
 0Sy
: (*\:f2fm(I
 $yOsQn92m\OaMW5  
2Mi*.22Z\
 .	
9 :fIfU9[n(GMQ[j
 (ay9a:GaMEI
 o\Qfa2S:$M*y3*3Wi
4 9a
nQf4[ 
< B>*0. *fNff4_mb5!
9 p( .T>,:ftM._mEB0fI[B
aNB65
 QfIaMQ>Olif('(? fST

: O\Ba5  2.9[n(aQH
 pPfU2ySF
: /X-+=M A>=
(tfNff42&)-]
= (U2s[>/X-+
= (aOlQn(mI
 Zf_Zy. 0(}$iO(B[	
: mS/X-+=M A65
U Q>{

=   i & - G =m$M*3*dW46$MA*>*W4 i En" K (GCmWS$MA*13*d64 i Enb"VmI* FtFtFK n5  :(a:

A

fi3MfiuM%



aMbp>UQfN2S:F>O(y=/X-+=	MAfW V 382K+.8=	,A2A>=d9hO.2\/X-G+=	MApl(jfNff4Jm1&)(a=(U2
[s/X-+ =>(a V 382K+.8	= MAsps(.UffaPm1/lmTfTnT=(U2t V 382K+.8A5Bp9>(.N'>RyoT(
a(M ?M[9O(\( (f1
 =]Of	 :B0 NRTp2.$M465
 ),&('*),+.-0/]'*&H0+_LRU/2;i3E6+.'*+.82RN) V 382K+.8RN<q)M35U5N+,H3PfGff[uGMQl=RU/!8+fY[+.8<]/&P3'\10'*<2-+,).R4+,H

+.'Q/2RU/X&Y@3S),+.82/:3RU'/X-+Af&(/2;*+.82LRN<+FRU/RN<)M35U5N+,H3'pG('?[(0(_aMj=RU/\8+fYn+.8</&t3S<2-+,).R4)
RU'*HORUCRNHO1435}H0+f*'*+,HRU'I/2;*+><210-0-&(82/BAfert+PLRU5U5h3(H0&(-0//2;*+EYn&(5U5N&MLRU'06T).5o3(<<2RN)M35{),&('QC+.'Q/2RN&('*<P3D&(10/
^0?E<Me  '/2;*+HO8:3,LRU'06k&YP3^0?ZWq),&('*),+.-0/'*&H0+,<38+8+.-08+,<+.'Q/+,HDQX8+,)./:3'0695N+,<s3'*H8+.5o3/2RN&('
'*&H0+,<DQXs&MC935N<Me  's/+fO/214357'*&(/:3/2RN&('7W08+,)./:3'0695N+,<u38+E8+.-05o3(),+,HFDQ
X i3'*HF&MC935N<DQ
X 6e]?E+.'*+.82RN)

3
2
8

K
.
+

8

<

3

8

+
&
U
R
2
/

/
,
+

H

e
_
g
Q
;
*
1
>
<
s
3

6
.
+
*
'
.
+
2
8
N
R
\
)
,
)
(
&
*
'
,
)
.
+
0
>
/
o
5

3
G
D
.
+
5
1
M
$
S

L
*

f
E
4
N
R
@
<
2
<
R
0
U
5
y
X
*
'
(
&

/
,
+
H
J
.

Z
e


'RU'*HORUCRNHO1435
V
V
V
),&('*),+.-0/5o3D+.k
5 $MS*y4lRN<'*&(/+,
H ter;*+.'RU'&(108+f*3 V -05N+,<L+I1*<+FD0RU'4382X8+.5o3/2RN&('*<MW_L+
,
3
s
X

8
.
+
0
o
5
(
3
,
)
E
+
Q
'
1
G
D
.
+

8

<
(
&
I
'
,
+
O
H

6
+,<_DQXTHORU8+,)./+,HI+,HO6+,<Mq3D0RU'4382Xs8+.5o3/2RN&('I'*&H0+uRN<_/2;*+.'IRU'*).RNH0+.'/J/&
V
V
+f*3()./25UX&('*+ZRU'*),& V RU'063'*H&('*+Z&(10/26&(RU'06I+,HO6+9ex{RU6*es<2;*&MLJ<E/L&j=[),&('0'*+,)./+,H4A@<2R V -05N+l698:3-0;*<
3'*H3(<<21 V +,HF/&ZD+PH0+f*'*+,HI&C+.8J/2;*+P<210-0-&(82/J&Y!x}RU6*e`9e
b

wyx>z,{y|>}~

w3|,x,z

 |  |,x

 |  |,x
>|>|y,x}c>|,x

 |  |,x

>|>|y,x}c>|,xV

>|>|y,x}c>|,xT

 |  |,x

wyx>z,{y|>}~

wyx>z,{y|>}~


0

0
yL}|TpLc,

w3|,x,z

 |  |,x

zx,S>06~,
0

zx,S>06~,

>|y,x

yL}|



x{RU69108+>O]^R V -05N+>698:3-0;*<Me
g ;*+@+.5N+ V +.'/:382Xs8+M3(<:&('0RU'06&(-G+.8:3/2RN&('7W*-08&m+,)./2RN&('7W0RN<J3lKRU'*HT&Y}698:3-0;I;*& V & V &(82-0;0RN< V /2;43/
_
-08+,<+.82C+,<_/2;*+-4382/2Ro357&(8H0+.8H0+f*'*+,Hs&('T5o3D+.5N<Meh|7+./_1*<*8<2/_-08+,).RN<+u/2;0RN<&(8H0+.8Yn&(8),&('*),+.-0/'*&H0+
5o3D+.5N<Mert+T;43,C+H0+f*'*+,H/2;*+sY[&(5U5N&LRU'06j-4382/2Ro35&(8H0+.8i&('/2;*+ V 382K+.8<+.j
/ /lmTfTnQJ
 fRN<Z/2;*+
698+M3/+,<2/l+.5N+ V +.'Q/F=pY[&(835U+
5  i /
W \fA@3'*H+.5N+ V +.'Q/<Z&
Y /38+-43RU82LRN<+\'*&('k),& V -438:3D05N+9e
g_;*+.'T/2;*+0(f[n((2QfP(9a:G]aMQ@f ERN</2;*+-08&HO1*)./&Y7/2;*+-4382/2Ro35&(8H0+.8<_&(' &)(3'*H
e $M*y4\$M  *y  4R
 \  3'*7
H \  e  'T&(/2;*+.8L&(8H0<MW43Z),&('*),+.-0/5o3DG+.a
5 $MS*y4RN<
 lgmTfTnQW0R$e+9H
5 $M  *y  4R
Y RN<3\<210D0/X-+P&
Y   3'*HW4R`
Y   "fffQW*/2;*+.g
'  )M3'
V &(8+><-G+,).R4)@/2;43'S3),&('*),+.-0/u5o3DG+.+
D+P3'QX V 382K+.8MW*&(/2;*+.82LRN<E
+  V 1*<2/D+P+,w1435/
& 7e
  E	 9]C
 }M <qG2(BO(.b
 5  -08&2+,)./2RN&('

 yfi;}]} , y}J .7(G[
fm(  pa$ pj\BQapfm( ( $$C4$J ( $[4y(aiB2( - $$E4$J - $[4g9hQnf
aB,.?f>MQBN$[hoEf
O(.[9mBa(\(\(4QpBYRl(H9fGEOf4ff=](al\:
$*2.n( ^ sZ:(a:_9a\fU9[n(SaMQ>UQf 6 
5$MA*y3*3W4 i r$$C4*$	$M4*y3*3$	W4y4 i r$[4>

W

fi M]|9M.tM=uwuMM3
 F

 5] i  $$E4*[$	$M])4y4d\O$M]4

rt+'*&(/+Z P =$<210D*<21 V +,j
< PAJRYq/2;*+.8++fORN<2/<3-08&2+,)./2RN&('Y[8& V RU'Q/&ZegqX-0RN)M35U5UXW
 8+.-08+,<+.'/<J3Pw1*+.82XW3PYn3()./MW03'*Hi-08&m+,)./2RN&('*<Y[8& V /&H0+f*'*+E3'*<2L+.8<_/&e  'sx{RU6*eqOW

<210-0-&9<+[JBM2(2fOf\J.:,(4WO/2;*+.'F/2;*+.8+ERN<&('*+E-08&2+,)./2RN&('TY8& V RU'/&8Zeqg_;*+ER V 36+@&Yq
DQXT/2;0RN<-08&2+,)./2RN&('IRN</2;*+><210D0698:3-0
;   &a
Y Ze







y{M}hhM]



[ 

g_;*+T<+ V 3'Q/2RN),< V 3-*<\^0?E<l/&/2;*+s+fORN<2/+.'/2Ro35_),&('(m10'*)./2RUC+I3'*Hk-G&9<RU/2RUC+\Y[8:36 V +.'Q/\&Yx{zu|qe
?uRUC+.'3I<210-0-G&(82/@uW}3F),&('*</:3'Q/PRN<l3(<<2RU69'*+,HS/&I+M3():;jRU'*HORUCRNHO1435 V 382K+.8l3'*Hj3' ~3(HORN)=8+,<2-7e
310'4382X0AJ-08+,HORN)M3/+lRN<u3(<<RU69'*+,H/&s+M3(); ~3(HORN)8+.5o3/2RN&('=8+,<-7e),&('*),+.-0/BA/X-+9ex*&(8E<2R V -05URN).RU/XW
L+u),&('*<2RNH0+.8_/2;43/_+M3();F),&('*<2/:3'Q/&(8-08+,HORN)M3/+u;43(<]/2;*+u<:3 V +'43 V +E3(</2;*+E3(<<&).Ro3/+,Hi+.5N+ V +.'/_&Y
/2;*+u<210-0-G&(82/Me!<+./&Y7Yn&(8 V 105o3(<Jj
 $d
 4!RN<3(<<RU69'*+,H/&Z3'QX<10-0-G&(82/W/28:3'*<25o3/2RU'06-4382/2Ro35&(8H0+.8<
&('/X-+,<Me\y&(8+<2-G+,).R4)M35U5UXW7Y[&(8>35U5HORN<2/2RU'*)./P/X-+,j
<  D 3'*J
H   <21*);j/2;43[
/   \V D W}&('*+Z;43(<@/2;*+
Yn&(8 V 105o7
3 ] D FtFtF ] $M  $M] D * FtFtF *y] 4
 $M] * FtFtF *y] 4y4fW}L;*+.8+ "IYn&(8),&('*),+.-0/l/X-G+,<MWh3'*H kRN<
D D
&(/2;*+.82LRN<+/2;*+382RU/X&Y/2;*+J8+.5o3/2RN&('i/X-G+9eq?uRUC+.'T3'QX^0
? W3uYn&(8 V 105o3lj
 $[4!RN<qD010RU5U/3(<qY[&(5U5N&LJ<Me
/+.8 V RN<3(<<RU69'*+,HT/&\+M3();y),&('*),+.-0/'*&H0+9]3ZHORN<2/2RU'*)./C9382Ro3D05N+EYn&(8J+M3();6+.'*+.82RN)P'*&H0+9W*3'*HF/2;*+
),&('*<2/:3'/P),&(828+,<2-G&('*HORU'06T/&sRU/< V 382K+.8P&(/2;*+.82LRN<+9ePg_;*+.'t3'3/& V 6$	W4Z=8+,<2-7e L$	 D * FtFtF *3 G 42ARN<
3(<<&).Ro3/+,Hs/&+M3():;I),&('*),+.-0/'*&H0+Z=8+,<2-7e8+.5o3/2RN&('F'*&H0H
+ &Yh382RU/X K AfWL;*+.8H
+ RN</2;*+/X-+u&Y/2;*+
'*&H0+9W*3'*7
H Z=8+,<-7e  $ARN<_/2;*+E/+.8 V 3(<<2RU69'*+,HT/&Z/2;0RN<_'*&H0+\=8+,<2-7e*3(<<RU69'*+,HT/&/2;*b
+ /2;F'*+.RU69;QD&(108
&`
Y Afe|7+./ $[4_D+@/2;*+P),&('(m10'*)./2RN&('&Yh/2;*+,<+>3/& V <ej
 $[4_RN<J/2;*+P+fORN<2/+.'Q/2Ro35{).5N&9<2108+P&Y +$E4fe
; Y4RU'ix{RU6*eq@RN< ] _$Jf,2(2fO.A $M]4 2mM2, $M_4
 e 6*eh/2;*+Y[&(8 V 105o33(<:<2RU69'*+,H/&>/2;*+<10D0698:3-07
JBM2(2fOf $ J4 \.\:f $M]*y_4 yffW $ *y_4 9]( M !9! $M]* B4y4fe
 8&2+,)./2RN&('jRN<><&(10'*Ht3'*Ht),& V -05N+./+\LPe 8Me /MeZ/2;*+<+ V 3'Q/2RN),<ZEW10-t/&I3T'*&(8 V 35URU/X),&('*HORU/2RN&('
Yn&(8),& V -05N+./+.'*+,<</2;*+la9B\(.(f&Y{3l^0
? RN</2;*+E^0?M`
 $[4q&(D0/:3RU'*+,HTDX V +.8269RU'06),&('*),+.-0/
'*&H0+,<;43MCRU'06E/2;*+]<B3 V +]RU'*HORUCRNHO1435 V 382K+.8Mehg_;0RN<q^0?35UL3,XO<h+fRN</<=n3'*HRN<}),& V -010/:3D05N+RU'l5URU'*+M38
/2R V +LRU/2;T3>'43RUC+u35U6&(82RU/2; V Afe]x}RU69108+  <2;*&MLJ<3P),&(10'/+.8m~+f03 V -05N+E/&-08&2+,)./2RN&('T),& V -05N+./+.'*+,<:<
L;*+.'t^0?E<38+'*&(/RU''*&(8 V 35Yn&(8 V 
 Yn&(8RU'*<2/:3'*),+lH0&+,<'*&(/-08&m+,).//& kW4+.C+.'yRY!DG&(/2;^0?E<
;43,C+/2;*+l<:3 V +P5N&(69RN)M35h<+ V 3'Q/2RN),<W4D010/uRU/-08&2+,)./</&M
 $ J4feJ^0?RU''*&(8 V 35}Y[&(8 V RN<<B3RNHI/&
D+Za(f9 e






	




	 fiff


	





 



 

 







r

s

t

t:a

r

t:a

s

t



!



r



s

t

t:a


"$#&%('*)+"$#-,.'*)0/21435#617'9835#6:;'<8=3>#6:4'98@?A#61CBD:;'<8FEG#61CBD:;'<8@HC#61CB:;'
%IKJMLF,ON4IPRQTSUIVQTWYXZR[Y\]IW
^`_aIJ4S`WbI^U[bXJdce^UN2f4SDSUIVQ$J4X_UV=IKW7geX_UV@hi;f;^^UN;Q>jIK_UQ([YJ4\5XVkMI_aIi4WYQ(ilj@k;_UXmQ5\n^U[bXJ
o


u

u

t:a

t:a

u

'OY3$[4+"'OYy$ J4

p

x{RU69108+  ]g_;*+E'*+,+,HTY[&(8'*&(8 V 35Y[&(8 V <

q

sr


t uvu w

xrzy {

*t Cu|u|}

hy|My  hyn }
qhM}]y|
 K}$MAy
 .\ (a
  M

	9] QM<]G2T(\fMQO(.j5kU0fF P ML$[4> >(Gi(4@:\ j$4*B[$[4 I[$$E465

~

2





:

fi

3MfiuM%

rt+y).5o3R V +,HRU'/2;*+RU'Q/28&HO1*)./2RN&('/2;43/^0?E<T38++,w10RUC(35N+.'/F/&j/2;*+-&9<2RU/2RUC+9W),&('(m10'*)./2RUC+
3'*Hj+fORN<2/+.'/2Ro35qY[8:36 V +.'Q/Z&Yx{zu|LRU/2;*&(10/Y10'*)./2RN&('*<s=5N+./>1*<H0+.'*&(/+\RU/>DXx}zu|]= _W *A2AfeFz'*+
+ V D+,H0HORU'06FRN<ER VV +,HORo3/+I=pY[8& V x{zu|/&I^0?E<BAfWD010/E8+,wQ10RU8+,<E/2;*+ZH0+f*'0RU/2RN&('t&Y3<210-0-&(82/E/2;43/
H0&+,<J'*&(/3(H0H3'X/2;0RU'06s/&/2;*+P<:+ V 3'Q/2RN),<u&Y{/2;*+>RU'QC&(5UC+,H698:3-0;*<Me] 9qfMQO(._RN<3<210-0-&(82/
L;*&9<+/28:3'*<25o3/2RN&('DQXSRN<E+ V -0/XWh 5W 5uL;*+.8+Z35U5hHORN</2RU'*).//X-+,<@38+>'*&('),& V -438:3D05N+9e  
Y  RN<
/2;*+JC&)M3D0105o382X=[),&('*<2/:3'/<3'*H\-08+,HORN)M3/+,<BA!Y[&(8_3P<+./&YY[&(8 V 105o3(<MWL+),&('*<RNH0+.8/2;*+ a3/<210-0-&(82/
 $r4"ff$'&.(+*,&)-+*0/4L;*+.8j
+ &)(RN<8+,<2/282RN)./+,H/&Z/2;*+P+.5N+ V +.'Q/ j(WO/2;*+@8+.5o3/2RN&('I/X-+,<J&
Y & - 38+
/2;*+@-08+,HORN)M3/+,<&Y!382RU/Z
X RU
' \W*3'*HI/2;*+@RU'*HORUCRNHO1435 V 382K+.8<&Y /38+E/2;*+P),&('*<2/:3'/<JRU
' e

U 

s



=





D;
 5 
  t 
d  =


  0 
D; ` fiD; 
2MmW|7+./
 D+F3Sx}zu|]=U_W*APY[&(8 V 105o3&MC+.83yC&)M3D0105o382Xekg_;*+^0?D;$`.4lH0+f*'*+,H&('
/2;*+P<210-0-&(82/J $r4RN<D010RU5U/u3(<Yn&(5U5N&MLJ<M!/&+M3();/+.8 V &Y(yL+3(<<&).Ro3/+P3),&('*),+.-0/'*&H0+@/X-+,H
 (=6+.'*+.82RN)@RYh/2;*+E/+.8 V RN<3lC9382Ro3D05N+9W0RU'*HORUCRNHO14357LRU/2;3 V 382K+.81uRYh/2;*+@/+.8 V RN</2;*+P),&('*<2/:3'/
j
MAfW3'*Hk/&S+M3();3/& V 6$M] * F6F6F *y]{W 4PL+I3(<<&).Ro3/+F38+.5o3/2RN&(''*&H0+Z/X-+,HfW]<21*);/2;43/MW!Yn&(8
I[\+\xO
 WO/2;*+j$/2;I'*+.RU69;DG&(D8&Y`ZRN</2;*+P),&('*),+.-0/J'*&H0+>3(<<:&).Ro3/+,HT/&]  e
g_;*+ V 3-0-0RU'06D;
 RN<_).5N+M3825UXRU'(2+,)./2RUC+9W05W5hRU/ V 3-*<HOR+.8+.'Q/_Yn&(8 V 105o3(<P='*&(/_RNH0+.'Q/2RN)M3510-T/&


I\BaZOM.
yn
_ }A _  UOfo\. M2,[n(
  y^ }$T  
m 
 N += R>.9BZT?fI?M:Qf(S: $SOiM.PmG(B\(+}iQ	<qG2(O 9
BO9f{ $r4EfO.9M=*,((:i	9],(fZU j(a =
k Ofo>Pa2mM2,[n(B2(
$ 4P4$
$ 465

C9382Ro3D05N+@8+.'43 V RU'06A_/&\HOR+.8+.'Q/E^0?E<>='*&(/JRNH0+.'/2RN)M35}10-F/&3'FRN<:& V &(82-0;0RN< V Afe]y&(8+,&MC+.8MW4RU/JRN<3
D0R 2+,)./2RN&('IRY{L+@8+,<2/282RN)./u^0?@</&Z/2;*&9<+@RU'I'*&(8 V 357Y[&(8 V e
|7+./!1*<h'*&L),&('*<2RNH0+.8!/2;*+x}zu|= _W *A7Yn&(8 V 105o3 " ] $ $ ] 4y4_=L;*+.8+ $ ] c4}RN<q3u),&('(m10'*)./2RN&('
&Y\3/& V <FL;*&9<+C9382Ro3D05N+,<FD+.5N&('06/& ] Afeg_;*+ ( ~+.'082RN);*+,HY[&(8 V 105o3&Y RN<I/2;*+SY[&(8 V 105o3
 $ .4k"
] $ $ ] 4
$ ] 4y4PL;*+.8+ +$ ] 4@RN<>/2;*+s),&('(m10'*)./2RN&('&Y/2;*+i3/& V < j($M]4fW{Yn&(8l+.C+.82X
/+.8 V ]yRU' he_rt+>'*&L-08&C+l/2;*+P-08&(-+.82/XIDXI-G&(RU'/2RU'06s&(10/u/2;43/MW{`A_Yn&(8 t3'*H T/L&Tx}zu|= _W
*A}Yn&(8 V 105o3(<W
ZR7
  $ .4 Z $ 4fWO3'*HiAhY[&(83'X\x}zu|]= _W *A}Yn&(8 V 105o3 hW  $ .4"[
 $ $ .4y4fW
3'*HI),&('*).5U1*H0+@1*<RU'06g_;7e7`9e
x*&(8E/2;*+l&(/2;*+.8@HORU8+,)./2RN&('7W/2;*+l3-0-438+.'/@-08&(D05N+ V RN<u/2;43/Y[&(8 V 105o3(<P3(<<2RU69'*+,H/&/2;*+Z<210-0-&(82/
DQX38+P10'0RUC+.8<:35U5UXIwQ143'/2R4+,H3'*H38+P1*<+,HFRU'I/2;*+PH0+,HO1*)./2RN&('-08&),+,<:<Mequ&ML+.C+.8MWaL+>)M3'H0&
LRU/2;*&(10/J/2;*+ V W4DQXT+.'*),&HORU'06\/2;*+P-4382/2Ro35&(8H0+.8&('I/X-+,<JHORU8+,)./25UXTRU'F/2;*+^0?E<Me

] ` fi|  ` |v  ( |v 


C+ 5 `  ] 
 5 

U C
z 
! || 

 v  ` |v 


= |v 


 0
U
fi ] ` `D; `


U 

  t 

C7

f!
6 UOfoMM2,[M?_Ba n9[n(
 yn   y^ }$   }AT  
aI0ZM.mZa(f\(}\QM<qG(TfM0(f] $OZ,.um
 N += Ru,(flUfO.
9M =.(S( :	 9]
 }
  (a
QM <q2(1
 =iOfSpyGmmM2,[n(B2(
4$B 

C7$[4!C7$J465



  



 <



2MmW|7+./CD+3i698:3-0;tH0+f*'*+,Ht&('t3T<210-0-G&(82/Eue>g_;*++fO-43'*<2RN&('&YdZW W] $E4fWRN<E/2;*+^0?
H0+f*'*+,H&('j/2;*+ a3/l<10-0-G&(82/ $Ci
4 =L;*+.8+ RN<>/2;*+iC&)M3D0105o382XY[&(8/2;*+\Yn&(8 V 105o3(<Z&Yuj$d42AfW
D010RU5U/@3(<JYn&(5U5N&MLJ<ME`A_Y[&(8u+.C+.82X),&('*),+.-0/'*&H0+[]" H h&YZ
 W W] $EJ
4 ),&('/:3RU'*<E3'3(<<&).Ro3/+,H
( T W0<Me /MeUWYn&(8J+M3();),&('*),+.-0/J/X-G+Y  i 698+M3/+.8&(8J+,w1435/&rf W*3l10'4382X
),&('*),+.-0/J'*&H0+b]  "
8+.5o3/2RN&('j'*&H0+\&Y/X-+h
 5URU'0K+,Hj/&7]]
 3'*HjAuY[&(8>+.C+.82X8+.5o3/2RN&(''*&H0+ok
] &YH =[&Y/X-+I
 3'*H
382RU/X K AfW4Yn&(8+.C+.82XF8+.5o3/2RN&('y/X-G+E  i <Me /Me8\  W4L+Z3(H0HIRU' 6] `$[
4 3\8+.5o3/2RN&(''*&H0+P/X-+,H
7
 LRU/2;<:3 V +'*+.RU69;QD&(8<>3(<Y}
] eurt+>'*&LH0+f*'*+l/2;*+Z3-0-05URN)M3/2RN&('
3(<P W] }W3'*HS),&('*).5U1*H0+
1*<2RU'06g_;7e`9W*'*&(/2RN).RU'06\/2;43/uj$  $k4y4" Oe



Y 





 

{ <

 <
7 @ <



;A




fi M]|9M.tM=uwuMM3
 F



<2RU'06\<2R V RU5o38/28:3'*<mYn&(8 V 3/2RN&('*<MWG3Z).5N&9<+E8+.5o3/2RN&('*<2;0RU-I/&Z/2;*+@-08&(D05N+ V &Yd.*fS:s94$(*f4
<2/21*HORN+,HsRU's/2;*+H*3/:3D43(<+4+.5NHs;43(<DG+,+.'T<2;*&L'7!);*+,)KRU'06\w1*+.82X),&('Q/:3RU' V +.'/Y[&(8'*&('T8+,).108<2RUC+
),&('(m10'*)./2RUC+FwQ1*+.82RN+,<lRN<Z+,wQ10RUC935N+.'Q/Z/&S);*+,):KRU'06-08&2+,)./2RN&('DG+./L+,+.'^0?E<F=$%;*+.RU'+./35$eUWJ`Mb9b9cO
1069'0RN+.8MW4999Afe
 

p

v`  q

hy 
 
y ]fiM} 



y

]$A{M}h{

q

< K

B`y $

x*&(8/2;*+E<:3K+E&Y}D08+.CRU/XWOL+@),&('*<2RNH0+.8_RU'FL;43/Y[&(5U5N&LJ</2;43/^0?E<J38+u69RUC+.'FRU's'*&(8 V 35Yn&(8 V W03'*H
-010/_RU'Q/&Z'*&(8 V 35Yn&(8 V RY'*+,+,H0+,HI3Y[/+.83 V &HOR4)M3/2RN&('7e]'*HWO<2RU'*),+@3Z^0?H0&+,<_'*&(/_'*+,+,HT/&lDG+@3
),&('0'*+,)./+,HI698:3-0;7W*L+P),&(' a3/+l3Z<+./&Y]^0?E<LRU/2;I/2;*+^0?&(D0/:3RU'*+,HIDQXs-+.8mY[&(8 V RU'06\/2;*+>HORN<[m&(RU'/
10'0RN&('&YhRU/<+.5N+ V +.'/<Me  'F/2;*+@Y[&(5U5N&LRU'06sH0+f*'0RU/2RN&('7W*Y[&(8JRU'*</:3'*),+9W*/2;*+^0?k8+.-08+,<+.'Q/<E3<+./&Y
^0?E<Me



*| B .(a>

x

 _{


 y fi;}]}

Q29O:@fm(  J P d5

@	9]r}uQM<]G29lBO(.j5(S:

% ;*+.RU'3'*H1069'0RN+.8\=m`Mb9b9A;43MC+Z<2;*&ML'y/2;43/-08&2+,)./2RN&(');*+,):KRU'06TRN<Y  ~),& V -05N+./+ZLRU/2;3

8+,HO1*)./2RN&('SY[8& V
 { e  wQ10RUC935N+.'*),+ZLRU/2;j%^  =[<:3/2RN<ma3D0RU5URU/Xy&Y3s),&('*<2/28:3RU'/@'*+./L&(82K0AL_3(<
35N<&l1*<+,Hs5o3/+.8>=[x*+,H0+.8 ]38HOR$W`Mb9b  *1069'0RN+.8%;*+.RU'7W`Mb9b9AfW43'*HsRU'*H0+.-G+.'*H0+.'/25UXTRU'3>C+.82X
<2R V RU5o38 V &H0+.5{DQXJ1*H0&(5Y=m`Mb9b9cA=[<+,+>-4382/@c\&Yq/2;0RN<u-43-+.8BAfeJrt+69RUC+>D+.5N&ML3'*&(/2;*+.8E-08&&Y]&Y
/2;0RN<u8+,<2105U/ED43(<+,Hy&('38+,HO1*)./2RN&('yY8& V  ~^!g@eg_;*&(1069; V &(8+Z),& V -05URN)M3/+,HS/2;43'y/2;*+l-08+.CRN&(1*<
&('*+,<MW0/2;0RN<J8+,HO1*)./2RN&('RN</2;*+ED43(<2RN<Y[&(8J&(/2;*+.8J8+,HO1*)./2RN&('*<-08+,<+.'/+,HI5o3/+.8JRU'F/2;0RN<-43-+.8Me
g_;*+lYn&(5U5N&MLRU'06I/2;*+,&(8+ V K+,+.-*<@RU'Q/&I3(),),&(10'/P/2;*+),& V -05N+fRU/X&Y),&('*),+.-0/3'*HS8+.5o3/2RN&('t/X-+
);*+,):KRU'06*W/2;*&(1069;\RU'/2;0RN<!-43-+.8!/2;0RN<!/+,<2/q)M3'i&(DQCRN&(1*<25UXD+_-+.8mY[&(8 V +,HZRU'-&(5UX'*& V Ro354/2R V +J<2RU'*),+
),&('*),+.-0/3'*HF8+.5o3/2RN&('/X-G+,<38+@&('05UXs5o3D+.5N<-4382/2Ro35U5UXF&(8H0+.8+,HIRU'3l;0RN+.8:38):;QXe

  

p

hy|My

q



hyn



sr
}

d


t  uvu  _K*{o1!(aN.samfU.C=\ 

qhM}]y|

	:B0lfO2LpTpifU($ H5

Kv { $

2MmW Zx{RU8<2/@<+,+l/2;43/@RY/X-+Z);*+,)KRU'06IRN<uRUB
'   WG/2;*+.'}   RN<P35N<&sRU'  3i-08&~
2+,)./2RN&('7Wq+.'082RN);*+,HDX),+.82/2R4)M3/+,<lYn&(835U5/X-+s):;*+,)KO<Z1*<+,HW!RN<3-G&(5UX'*& V Ro35),+.82/2R4)M3/+9etg_;*+
8+,).RU-08&)M357RN<J&(DQCRN&(1*<25UXT/2821*+9eqrt+E'*&L<2;*&L/2;43/MW*+.C+.'IRYh/X-+@);*+,)KRU'06i)M3'DG+@H0&('*+@RU' $,I4fW
}   jRN
<   ~),& V -05N+./+9e
|7+./1*<'*&ML D010RU5NH3y8+,HO1*)./2RN&('Y[8& V  ~^!g@e]g_;*+TRU'0-010/s&Y  ~^!gRN<i3Y[&(8 V 105o3
RU'  ~
),&('(m10'*)./2RUC+@'*&(8 V 35Yn&(8 V =  ~
% xqAfW0R$e+9eq3Z),&('(m10'*)./2RN&('&YhHORN<[10'*)./2RN&('*<l=[).5o31*<+,<BAfW0+M3():;ILRU/2;3/
V &9<2//2;08+,+@5URU/+.8:35N<W43'*HT/2;*+@wQ1*+,</2RN&('IRN<_L;*+./2;*+.8J/2;*+.8+@RN<3l/28210/2;3(<:<2RU69' V +.'Q/&Yh/2;*+EC9382Ro3D05N+,<
&Y <21*);T/2;43/ RN</2821*+9
e u&(/2RN),+u/2;*+E).5o3(<<2RN)M35  ~^!g-08&(D05N+ V ),&('*<2RNH0+.8<).5o31*<+,<_LRU/2;F+f03()./25UX
/2;08+,+@5URU/+.8:35N<MW*D010/Y[&(8_Y[1082/2;*+.8J-08&&Y[<_L+P-08+fYn+.8/&1*<+E/2;*+>3D&MC+PC(382Ro3'/Me
|7+./ q"
DG+>3'RU'*<2/:3'*),+>&Y  ~^!g@e*re 5$e&0e 6*e]L+P<210-0-&9<+@/2;43/+M3():;C9382Ro3D05N+
F6F6F
D
G
3-0-+M38<3/ V &9<2/&('*),+RU'i3E).5o31*<+9e!|7+./]1*<q).8+M3/+Yn&(108]),&('*),+.-0/q/X-+,<!Yn&(8q+M3();iC(382Ro3D05Nd
+ ]{ GW 4W
F3'*H aert+35N<:&\).8+M3/+>&('*+>8+.5o3/2RN&('/X-+ hYn&(8+M3():;y).5o31*<+ Wa3'*H38+.5o3/2RN&('/X-G+  0e
 3():;k),&('*),+.-0/l/X-G+ SRN<P698+M3/+.8l/2;43' 3'*H 4W}/2;*+,<+i38+/2;*+&('05UX-&9<<2RUD05N+),& V -4382RN<:&('*<
D+./L+,+.'yHORN<2/2RU'*)./J/X-+,<Me
rt+lD010RU5NHS/2;*+Z698:3-0
; $ 4@3(<uYn&(5U5N&MLJ<MY[&(8@+.C+.82XC(382Ro3D05Nr
+ ]tRU' IWL+Z;43MC+Z/2;08+,+),&('*),+.-0/
'*&H0+,Z
<  4
W  3'*Q
H  lRU7
' $ 43'*Hi/L&l8+.5o3/2RN&('s'*&H0+,</X-+,H  5URU'0KRU'06>/2;*+*8<2//&>/2;*+
5o3/2/+.8_&('*+,<u=RU'/210RU/2RUC+.5UXW0RU/ V +M3'*</2;43//2;*+JC9382Ro3D05N1
+ ]F)M3'sDG+C(35U143/+,HiDQX  &(
8  TAfeh|7+./

Kv { $







@  
9 +

U `


+

9

`



7
9 



;<


 <
 





 9



d 9




fi3MfiuM%



a

b

val

val

val

at

af

bt

c

val

bf

val

val

val

ct

cf

dt

2
1

2
3

C1

C1

C1

C1

C1

C1

C1

1

d

C2

C2

b

c

d

val

val

val

val

val

df

av

bv

cv

dv

...

3

C2

a

C2

C2

C2


C2



1

2

C1

2
3

1

3

C2

*|G*{$
1*<<B3,XF/2;43//2;*+>/28210/2;C935U1*+.9 =8+,<2-7e
QA_RN<u3(<<&).Ro3/+,HFLRU/2;ff`9y=8+,<-7eUAfe_g_;*+.'
Yn&(8+.C+.82X).5o31*<+"$--4ERU' =L;*+.8+!&0W&T3'*H&i38+5URU/+.8:35N<&C+.8C9382Ro3D05N+,<C]}W
_3'*HAfWGL+3(H0Hy/2;*+8+.5o3/2RN&(''*&H0+,<u/X-G+,H  Wa;43,CRU'063(<*8</E382691 V +.'/`9
 F&(8U 4W3(<
<+,),&('*HI382691 V +.'/`
&(8g`aWO3'*HF3(<_/2;0RU8HI382691 V +.'/U9 \&(8U aW/2;43/J),&(828+,<-G&('*Hs/&\3'
+.C935U143/2RN&('&Y!/2;*+P).5o31*<+@/&\/2821*+i= V &(8+@-08+,).RN<+.5UXW4RY!L+@8+.-05o3(),+>RU'I/2;*+>).5o31*<+h
 +M3():;-&9<2RU/2RUC+
=8+,<2-7e'*+.6Q3/2RUC+AE5URU/+.8:359WaI7\\OW7DXy/2;*+\/28210/2;jC935U1*+=8+,<2-7e\/2;*+\'*+.6Q3/2RN&('&Y_/2;*+/28210/2;
C935U1*+A3(<<&).Ro3/+,HTLRU/2;I/2;*+@5'*+.RU69;QD&(8&Yh/2;*+@8+.5o3/2RN&(''*&H0+9Wv}
 RN<+.C(35U143/+,H/&Z/2821*+Afe
x*&(8E).5o31*<+,<8+,<2/282RN)./+,H/&$    4J&(8k$  4fWaL+>-08&),+,+,Hy<2R V RU5o3825UXW3(H0HORU'06  D0RU'4382XI8+.5o3/2RN&('
'*&H0+,<u&(8E&('*+l10'4382XI8+.5o3/2RN&('S'*&H0+9ebu&(/+>/2;43/E;43MCRU'06 K ~).5o31*<+,<MWGL;*+.8+ K RN<E3i),&('*<2/:3'/MWRN<u&Y
-082R V 382XSR V -G&(82/:3'*),+/&F;43,C+s3T-&(5UX'*& V Ro35q/28:3'*<2Y[&(8 V 3/2RN&('7W{<2RU'*),+L+&(D0/:3RU' Gfi
 I8+.5o3/2RN&('
'*&H0+,<_Y[&(8J+M3():;).5o31*<+9e
 'i/2;*+698:3-0;o$ 4fWO/L&Z),&('*),+.-0/'*&H0+,<7` 3'*HQU9 \38+).8+M3/+,HsYn&(8+M3():;FC(382Ro3D05N+H]3'*H
3ZD0RU'4382Xs8+.5o3/2RN&(''*&H0+5 9 P5URU'0KO<g` /&U9 aeqx*&(8+M3():;).5o31*<+)
 " $-@-& 4fW*/2;*+.8+@RN<
&('*+P8+.5o3/2RN&('K7, 5URU'0K+,H/&OU9 4WHU9 T3'*HVU9 =n3'*H<R V RU5o3825UXTY[&(8u).5o31*<+,<LRU/2;S&('*+>&(8/L&
5URU/+.8:35N<BAfeIo$ 4@8+.-08+,<+.'Q/</2;*+w1*+,<2/2RN&(' RN<>/2;*+.8+i3FC935U143/2RN&('&Y/2;*+C9382Ro3D05N+,<l<21*);/2;43/l35U5
).5o31*<+,<J+.C935U143/+@/&d 9 9l
g_;0RN<u/28:3'*<mYn&(8 V 3/2RN&('SY8& V /2;*+  ~^!gY[&(8 V 105o3$0`
 W4 $UT T 4JRN<uRU5U5U1*<2/28:3/+,H
RU'tx{RU6*ed*e  '/2;*+Z698:3-0;ZW7'*&(/>35U5]+,HO6+,<PRN<<21*+,HyY[8& V /2;*+).5o31*<+,<P;43MC+DG+,+.'tHO8:3ML'7W7Yn&(8E/2;*+
<:3K+Z&Y8+M3(H*3D0RU5URU/Xe  /uRN<ER VV +,HORo3/+/&T);*+,):KS/2;43/MWY[&(8P3Yn&(8 V 105o3!I
 W/2;*+.8+ZRN<P3iC(35U143/2RN&('t&Y
RU/<_C9382Ro3D05N+,<J<21*);/2;43/J+M3();I).5o31*<+ERN<J+.C935U143/+,HT/&Z/2821*+ERYh3'*HF&('05UXsRY!8$ 4_)M3'FDG+u-08&2+,)./+,H
RU'Q/&Z$ 4fe

  7
  
u&(/+/2;43/l/2;*+i<10D*<21 V -0/2RN&('8+.5o3/2RN&('RU'*HO1*),+,HkDQXj-08&m+,)./2RN&('&MC+.8^0?E<RN<l3w143(<2R~&(8H0+.8MWhD010/
'*&(/l3'&(8H0+.8MlRU/RN<l3F8+R4 +fORUC+s3'*H/28:3'*<2RU/2RUC+iD010/>'*&(/3'Q/2R~<2X VV +./282RN)M35_8+.5o3/2RN&('7egL&^0?E<
x{RU69108+@d*  * 3 V -05N+>&Yh/28:3'*<mYn&(8 V 3/2RN&('FY[8& V  ~^!g/&

%AyM}

y ]]} ]{%}

3 8+P<:3RNHT/&\DG+y,M?(Nf4RYh/2;*+.Xs-08&m+,)./J/&+M3();&(/2;*+.8Me]^0?RN<<:3RNHF/&ZD+Z229aQ(4RYhRU/RN<
+,w10RUC(35N+.'//&&('*+u&Y{RU/<<2/282RN)./<210D0698:3-0;*<>=R$e+9e]3l<210D0698:3-0;F'*&(/+,w1435/&oRU/<+.5YfAfWO&(/2;*+.82LRN<+ERU/
RN<J<:3RNHT/&\DG+ZB2(a94ne

p

q

sr




t uvu

hy|My  hyn }
qhM}]y|
   J(G(aL :fOS p( 1!m(aN.ia2QS!
Nf85Jfyy.M?(Nfa:.(:>(Z[P*	,0ZNMt$io,(\($aQofYRlB2(a94{9mBa 5

g_;*+pf2(a(4*.(f&Y}3Z^0?V
 RN<_3'sRU828+,HO10'*H*3'Q/<210D0698:3-0;F&Y+,w10RUC935N+.'Q/_/&PRU/@=L;*+.'
RN<RU828+,HO10'*H*3'Q/MW4/2;0RN<_698:3-0;sRN<RU/<+.5Y2WO&(/2;*+.82LRN<+E/2;*+.8+ V 3,XsDG+u<+.C+.8:35<21*):;I<210D0698:3-0;*<MWD010/

/2;*+.XF38+>35U57RN<& V &(82-0;0RN)Afe

;

 

fi M]|9M.tM=uwuMM3
 F

h

 D#U_ 9 

qu

;

^

(#$

dh#as$s  O*

 
 F

 

"







g_;0RN<<+,)./2RN&('iRN<H0+.C&(/+,Hi/&l3's&MC+.82CRN+.L&Y7/2;*+HOR+.8+.'/ V &H0+.5N<),& V -G&9<RU'06/2;*+SY$3 V RU5UXehrt+
LRU5U5G*8<2/_&(10/25URU'*+E/2;*+ V 3RU' V &(/2RUC93/2RN&('*<Y[&(8_&(108_698:3-0;O~$D43(<+,HI3-0-08&3();I&Y}K'*&L5N+,HO6+E8+.-08+,<+.'O~
/:3/2RN&('7e

 C8  
  )   9o
 	

}h

y ]ynAyn}A{}[{%}

y hMy



y|{3M}]}hu

{h

x08& V 3 V &H0+.5URU'06ICRN+.L-G&(RU'/MW7L+\<+,+Z/L&I+,<<+.'/2Ro35q-08&(-+.82/2RN+,<PRU'
 ]y  }$ $y
M }
/2;*+Z<2R V -05N+l698:3-0; V &H0+.5$e@g_;*+FQM2,.W<2R V -05N+l698:3-0;*<MW738+l+M3(<2RU5UX10'*H0+.8<2/:3'*H*3D05N+ZDXy3'S+.'*H~
1*<+.8=n3sK'*&ML5N+,HO6+i+.'069RU'*+,+.8>&(8P+.C+.'3't+fO-G+.82/BAfe'*H2.(4p(i38++M3(<2RU5UX10'*H0+.8</:3'*H*3D05N+
/&&0W9Yn&(8q/L&>8+M3(<&('*<-08&2+,)./2RN&('iRN<3E698:3-0; V 3/):;0RU'06l&(-+.8:3/2RN&('7W/2;Q1*<+M3(<2RU5UXRU'Q/+.82-08+./:3D05N+E3'*H
CRN<21435URN<:3D05N+943'*HF/2;*+@<B3 V +@5o3'0691436+@RN<1*<+,H3/RU'Q/+.8mY$3(),+3'*HI&(-+.8:3/2RN&('43575N+.C+.5N<Me
5U/2;*&(1069;/2;*+.8+RN<3E6Q3-\D+./L+,+.'i/2;*+/2;*+,&(8+./2RN)M35aY[&(10'*H*3/2RN&('*<<2/21*HORN+,H\;*+.8+3'*Hi3u5o3'0691436+
1*<:3D05N+TRU'8+M353-0-05URN)M3/2RN&('*<MWL+IL&(105NH5URUK+T/&SD082RN+ *X V +.'Q/2RN&('/L&-08&2+,)./<RU'L;0RN):;/2;*+,<+
-08&(-+.82/2RN+,<;43MC+lDG+,+.'S+f;0RUD0RU/+,HeEg_;*+*8<2/u&('*+RN<E3'S+f-+.82R V +.'Q/ERU'SH0&).1 V +.'/@8+./282RN+.C(35hH0&('*+
DQX\?E+.'*+,<2/=n999Afe  'Z/2;0RN<!L&(82KWQ),&('*),+.-0/21435a698:3-0;*<]38+_1*<+,HZ/&@H0+f*'*+3u5o3'0691436+Y[&(8!RU'*H0+fORU'06
3'*HFw1*+.82XRU'06H0&).1 V +.'Q/<Me%&('*),+.-0//X-G+,<J38+u/:3K+.'TY[8& V /2;*+/2;*+,<B310821*<J&Y{  
=n3D&(10/
dQ9J99_/X-+,<BAfW(3H0&).1 V +.'Q/:382X@5o3'0691436+1*<+,H@RU' V &9<2/Y[8+.'*);-010D05URN)3'*H@10'0RUC+.8<RU/:382X@5URUD08:382RN+,<Me
g_;*+>+fO-+.82R V +.'Q/E-08&MC+,H/2;*+@Yn+M3(<2RUD0RU5URU/X&Yh/2;*+>-08&(-G&9<:+,H<2XO<2/+ V =LPe 8Me /Me),& V -010/2RU'06s/2R V +A3'*H
3'R V -08&C+,H8+.5N+.C93'*),+ILPe 8Me /Me/&/2;*++fRN</2RU'06j<2XO<2/+ V D43(<+,H10-&('   W V 3RU'05UXHO1*+
/&/2;*+1*<+&Y<+ V 3'/2RN)t8+.5o3/2RN&('*<IRU'*</+M3(H&YlK+.XL&(8H0<&('05UXe z'*+t<2RNH0++f+,)./IL3(<35N<&/&
-08&MC+y/2;*+RU'Q/+.8+,<2/F&Y><2R V -05N+698:3-0;*<iY8& V 3 V &H0+.5URU'06kCRN+.L-&(RU'Q/Me  '*H0+,+,HW/2;*+.RU8s698:3-0;0RN)M35
-08&(-+.82/2RN+,<+.'43D05N+,Hi/&@D010RU5NHi3'iRU'*H0+fRU'06 w1*+.82XRU'06/&&(5*/2;43/]L_3(<),&('*<RNH0+.8+,Hs3(<+M3(<2XZ/&P1*<+_Yn&(8
/2;*+RU'*H0+f0+.8<Mehg_;*+1*<+.8<!L+.8+ V 3(<2/+.8];Q1 V 3'0RU/2RN+,<_<2/21*H0+.'Q/<W'*&(/3ML38+Y[8& V ),&('*),+.-0/21435a698:3-0;*<
'*+.RU/2;*+.8Y8& V u   QLRU/2;i/2;*+u<&Y[/L_38+E3'*HT3'sRU'*H0+fRU'06l6910RNH0+9WO/2;*+.XDG+,)M3 V +Ew10RN)K5UX3D05N+
/&ZD010RU5NHIRU'*H0+f*3/2RN&('*<MW0/2;43/L+.8+P),&('*<2RNH0+.8+,H&Y{;0RU69;Iw1435URU/XTDXF3Z<:+.'0RN&(8J5URUD08:382Ro3'7e
g_;*+i<+,),&('*Hj-08&2+,)./>/:3K+,<-05o3(),+\RU'K'*&L5N+,HO6+T+.'069RU'*+,+.82RU'06=[_&9<MWh_&(/+.5U5o3OW} ]3'0;*+,+.69;*+9W
`Mb9b9Afe  /<q-01082-&9<+JRN<]/2;*+),&('*<2/2821*)./2RN&('F&Y/&&(5N<qY[&(8 V &H0+.5URU'063'*H<R V 105o3/2RU'06l;Q1 V 3'T&(826Q3'0R 3~
/2RN&('*<MW3(<E+ V +.826+.'*).X-08&),+,HO108+,<Y[&(8uRU'*<2/:3'*),+9ePz'*+ V 3RU'HOR ).105U/XRU'yK'*&L5N+,HO6++.'069RU'*+,+.82RU'06
RN<_/&ZC935URNH*3/+P3 V &H0+.5URU'06*WOR$e+9e!/&):;*+,)Ks/2;43//2;*+@+f-+.82/8+M3(<&('0RU'06RN<),&(828+,)./25UX V &H0+.5N+,Heqg_;0RN<
C935URNH*3/2RN&('yRN<E1*<1435U5UXH0&('*+lL;*+.'y/2;*+ZH0+,<2RU69'SRN<@3();0RN+.C+,HW7;*+.8+DX<2R V 105o3/2RU'06F/2;*+),&('*</2821*)./+,H
V &H0+.5URU'06>&YG/2;*+&(826Q3'0R 3/2RN&('7e]_/!/2;0RN<h*'4354<2/:36+9W V &HOR4)M3/2RN&('*<38+JC+.82Xl),&9<2/25UXehg_;*+_K+.XlRNH0+M3
&Y/2;*+J-08&2+,)./]RN<]/&>&MC+.8),& V +/2;0RN<HOR ).105U/X\DX69RUCRU'06P/2;*++f-+.82/]/2;*+u3D0RU5URU/X/&>1*<+J<2R V 105o3/2RN&('
RU'*<2RNH0+E/2;*+PH0+,<RU69'I).X).5N+P3(<3 V +M3'&Yh+.'082RN):;0RU'06s3'*HTD010RU5NHORU'06\;0RN< V &H0+.5URU'06*e]g_;0RN<JR V -05URN+,</2;43/
/2;*+@);*&9<:+.' V &H0+.5URU'065o3'0691436+P+.'43D05N+,</2;*+@+fO-G+.82//&lYn&(5U5N&ML8+M3(<:&('0RU'06<J<2/+.-FDQXT<2/+.-7W0HORU8+,)./25UX
&('I;0RN<&ML' V &H0+.5UR 3/2RN&('7e  /L3(<uH0+,).RNH0+,HI/&D010RU5NH<21*);S3Z5o3'0691436+P10-&('),&('*),+.-0/21435{698:3-0;*<Me
?E+.'*+.8:35q),&('*),+.-0/21435698:3-0;*<P+,wQ10RUC935N+.'Q/>/&sx{zu|L+.8+\'*&(/P),&('*<2RNH0+.8+,Hj3(<E6&&HS)M3'*HORNH*3/+,<PD+f~
)M31*<+/2;*+.X38+RU'*H0+,+,H\3EHORo3698:3 VV 3/2RN)<2X</+ V &YG5N&(69RN)/2;43/!RN<h'*&(/]3/{/2;*+_+fO-G+.82/!5N+.C+.5$e  '*<2/+M3(HW
/2;*+E5o3'0691436+EL3(<J698&(10'*H0+,HF10-G&('F<2R V -05N+E698:3-0;*<3'*Hs+fO/+.'*<2RN&('*<>=[<1*);3(<_'*+,<2/2RU'06<&Y{698:3-0;*<BA
K+,+.-0RU'06I/2;*+.RU8@8+M3(H*3D0RU5URU/Xez-G+.8:3/2RN&('*< V R0+,H<2R V -05N+Z698:3-0;tH0+,HO1*)./2RN&('=R$e+9e-08&2+,)./2RN&('aAuLRU/2;
'*&('H0+,).5o38:3/2RUC+>-08&),+,HO108+,<Me]x}RU8</J+f-+.82R V +.'Q/<L+.8+>),&('*).5U1*<RUC+9e

R










e

6



6

e

6



 <

B^A{M}h{ $y o } x08& V 3S),& V -010/:3/2RN&('435uCRN+.L-&(RU'Q/MWL+F/2;0RU'0K/2;43/\698:3-0;O~
D43(<+,Hj8+M3(<&('0RU'06<MWhD+.'*+f*/2/2RU'06Y[8& V 698:3-0;O~$/2;*+,&(8+./2RN)M358+,<2105U/<W{)M3'kD082RU'063'jRU'Q/+.8+,</2RU'06y-+.8m~
<2-+,)./2RUC+s/&5N&(69RN)s-08&(698:3 VV RU'06*ekX+f*3 V -05N+9W!/2;*+F+,wQ10RUC935N+.'*),+sDG+./L+,+.'^0?-08&2+,)./2RN&('3'*H

;A


fi

3MfiuM%

U 


H0+,HO1*)./2RN&('TRU'ix}zu|+$ * 4)M3'iD+<:+,+.'T3(<_3's35U/+.82'43/2RUC+uC+.8<2RN&('T&Y7/2;*+PO(\(\($aQof 02(f
=$%;43'*HO8:3k +.825URU'7W@`Mb99AfW),&('*<RNH0+.8+,H3(<Y[10'*H*3 V +.'Q/:35Yn&(8H*3/:3D43(<+w1*+.82RN+,<s&(-0/2R V R 3/2RN&('
=[D0RU/+.DG&(105$W105U5$W uRo3'Q17W>`Mb9b9vAfez/2;*+.8s8+,<2105U/<s38+&(D0/:3RU'*+,HY8& V ),&('*</28:3RU'Q/s-08&(698:3 V ~
 }  p 4
V RU'06*eSg_;*+T<2/28&('06+,wQ10RUC935N+.'*),+D+./L+,+.'{   3'*Hk/2;*+

=[<:+,+u^+,)./MeOcOWL;*+.8+/2;*+/28:3'*<mYn&(8 V 3/2RN&('*<1*<+,H\K+,+.-T35U5a<&(5U10/2RN&('*<3'*H-08+,<+.82C+
/2;*+J<2/2821*)./2108+&Y/2;*+),&('*<2/28:3RU'/]'*+./L&(82K\RU'\/2;*+wQ1*+.82X*A!35U5N&MLJ</&@/28:3'*<25o3/+/2;*+8+,<2105U/<&(D0/:3RU'*+,H
RU'/2;0RN<h5o3/2/+.8]),& VV 10'0RU/X=DQXZ+f*3 V -05N+9W9/28:3()./:3D05N+J)M3(<+,<hD43(<+,HZ10-&('/2;*+<2/2821*)./2108+J&YG/2;*+_698:3-0;7W
?E&(/2/25N&(D7W|+,&('*+9W^)M38),+.5U5N&0W4`Mb9b9bAfW(*8<2/h/&u} }  hWQ/2;*+.'Z/&EH0+,HO1*)./2RN&('RU'x}zua
| $ * 4fe
g_;*+T698:3-0;</2821*)./2108+F)M3'35N<&yDG+T1*<:+,H/&yH0+.C+.5N&(-+ ).RN+.'Q/s35U6&(82RU/2; V <RU' V &(8+F6+.'*+.8:35
V &H0+.5N<]&Y7/2;*+_yYn3 V RU5UX{RU'\/2;*+ V &H0+.54L+)M35U5a =[<+,+JD+.5N&MLAfW0%&(105N&('*HO8+u3'*HT^O35UC(3/E=m`Mb9b9cA
1*<+l/2;*+Z698:3-0;O~$D43(<+,H'*&(/2RN&('t&Y]a$2:/&sD010RU5NHt3't+ ).RN+.'Q/PD43():KL_38H~);43RU'0RU'0635U6&(82RU/2; V elg}&
+.'0;43'*),+P/2;*+PY[&(82L_38H~);43RU'0RU'0635U6&(82RU/2; V 1*<+,HIRU'I/2;*+ V &(8+P6+.'*+.8:35 V &H0+.5N<&Yh/2;*+>Y$3 V RU5UXW
36+./t=n99O`As+f-08+,<<:+,<sH0+.-+.'*H0+.'*).RN+,<TD+./L+,+.'82105N+,<I3'*H),&('*</28:3RU'Q/<TRU'/+.8 V <F&Yl3698:3-0;
;*& V & V &(82-0;0RN< V e
z108!3R V RN</2;Q1*<{/&JD010RU5NH>Y[&(8 V 35O+fO/+.'*<2RN&('*<}&Y4<R V -05N+),&('*),+.-0/21435698:3-0;*<MW(K+,+.-0RU'06u8+M3(H*3D0RU5URU/X
&Y]&(DO2+,)./<u3(<L+.5U5!3(<8+M3(<&('0RU'06<WG3'*H-08+fY[+.8:3D05UXWa5N&(69RN)M35U5UXFYn&(10'*H0+,Heg_;*+>kY$3 V RU5UXFRN<u3*8<2/
<2/+.-FRU'I/2;0RN<HORU8+,)./2RN&('7e

 $v$|


6

Kv { $

0F 2D{ D v ;

K* { $
R
R

 O ; <

U 

&

  z{T	

|7+./}1*<'*&LjRU'OYn&(8 V 35U5UXP-08+,<+.'Q/}/2;*+q_sYn3 V RU5UXe{g_;*+q6+.'*+.82RN)-08&(D05N+ V /&JD+q<&(5UC+,HW   hW
3(<2KO<MW(69RUC+.'3uK'*&ML5N+,HO6+JD43(<:+E=[@JA{3'*H\3u<2R V -05N+J698:3-0;iW9L;*+./2;*+.8)M3'DG+H0+,HO1*),+,HZY[8& V
e!),),&(8HORU'06>/&>/2;*+JKRU'*H0<]&Y7&(DO2+,)./<]),& V -&9<2RU'06W&('*+&(D0/:3RU'*</2;*+HOR+.8+.'Q/ V + V DG+.8<&Y/2;*+
Y$3 V RU5UXe  '\/2;*+D43(<2RN) V &H0+.5aWRN<]),& V -&9<+,Hs&Y73><+./t&Y<2R V -05N+J698:3-0;*<8+.-08+,<+.'Q/2RU'06lY$3()./<MW
3'*H<&(5UCRU'06   3 V &(10'Q/</&S);*+,):KL;*+./2;*+.8/2;*+.8+TRN<\3-08&2+,)./2RN&('Y[8& V RU'Q/&te
J105N+,<u3'*HI),&('*<2/28:3RU'/<E38+ V &(8+P),& V -05N+f&(DO2+,)./<D43(<+,HI10-G&('y<2R V -05N+@698:3-0;*<MWG3'*H&(-+.8:3/2RN&('*<
H0+M35URU'06\LRU/2;I/2;*+,<:+P&(DOm+,)./<38+@D43(<+,HF10-&('F-08&m+,)./2RN&('7e
g_;08&(1069;*&(10//2;0RN<J<+,)./2RN&('7W0L+@LRU5U571*<+@+f*3 V -05N+,<JRU'*<2-0RU8+,HsY[8& V 3 V &H0+.5UR 3/2RN&('&Yq3lK'*&L5~
+,HO6+\3(),w10RN<2RU/2RN&('j)M3(<+Z<2/21*HOXW7)M35U5N+,H*{*77,:.RU/@H0+,<).82RUD+,<>3i8+,<&(108),+35U5N&)M3/2RN&('-08&(D05N+ V W
L;*+.8+/2;*+\3R V RN<E/&I3(<<RU69't& ),+,<@/&T-G+.8<:&('*<@&Y_3s8+,<+M38):;t698&(10-L;0RU5N+ZY[105*5U5URU'06I<& V +),&('O~
<2/28:3RU'/<=[36+./+./35$eUW7`Mb9b9bAfe
 

}

My| $y

$y

* { 

v { $

6

4

 D

Office

near

Office

near

 

Office

adjoin

Office

adjoin

Office

near


	

Researcher

member

Project

x}RU69108+vOqJ105N+,<



C

BUs+fO-08+,<<+,<K'*&ML5N+,HO6+T&Y_Y[&(8 V RYfiffRN<>-08+,<+.'//2;*+.' )M3'kDG+s3(H0H0+,H :e  /PRN<
y|
+.'*),&H0+,HFRU'Q/&s3Z<2R V -05N+@698:3-0;I-08&CRNH0+,HLRU/2;I/L&),&(5N&(8<MW0/2;*+@*8<2/J),&(5N&(8<210D0698:3-0;yH0+f*'0RU'06\/2;*+

;

 M

fi M]|9M.tM=uwuMM3
 F



Office: #1

adjoin

Office: #2

adjoin

near



Office: #1

Office: #3

adjoin

near

adjoin

Office: #2

Office: #4

near

adjoin

Office: #3

near

near

near

near

adjoin

Office: #4

x{RU69108+>O!J105N+3-0-05URN)M3/2RN&('*<
;QX-&(/2;*+,<2RN<>3'*H/2;*+\<:+,),&('*H),&(5N&(8P/2;*+\),&('*).5U1*<2RN&('7e  'tHO8:3,LRU'06<WL+8+.-08+,<+.'Q//2;*+;QX-&(/2;*+,<2RN<
DQXyL;0RU/+'*&H0+,<MW3'*HS/2;*+),&('*).5U1*<2RN&('jDQXy698:3,X&('*+,<MeZx{RU69108+\vT<2;*&MLJ<@/2;08+,+\82105N+,<Me  D 3'*H  
8+.-08+,<+.'/PK'*&L5N+,HO6+3D&(10/P/2;*+TG2(s8+.5o3/2RN&('7W<10-0-G&9<+,Hy/&TD+H0+f*'*+,HD+./L+,+.'& ),+,<P&('05UXe
+ ]FRN<2(3'T& ),Y
+ _W/2;*+.Z
' _
 D +fO-08+,<<+,</2;43/_/2;*+E8+.5o3/2RN&('SG2(lRN<_<2X VV +./282RN)M35]= RY{3'F& ),b
RN<uG2(E
 ] AfW   /2;43/ RY}3'F& ),1
+ ]j2.(0@3's& ),Y
+ _/2;43/Pm,(0u3'F& ),+ l/2;*+.
' ]FRN<G2(
:eg_;*+P82105N+ 	 <:3,XO<J/2;43/E+.C+.82XI8+,<+M38):;*+.8ERN< V + V D+.8@&Y3-08&2+,)./Z= RYq/2;*+.8+RN<E38+,<+M38):;*+.8
]}WO/2;*+.8+PRN<3Z-08&2+,)./J&Y{L;0RN):g
; ]RN<3 V + V D+.8 Afe
105N+,<>38+1*<+,HS/&F+.'082RN):;tY$3()./<MERY/2;*+\;QX-G&(/2;*+,<2RN<>&Y3s82105N+\)M3'jDG+Z-08&2+,)./+,HRU'Q/&3^0?ZW
/2;*+.'F/2;*+E82105N+ERN<3-0-05URN)M3D05N+@/&Z/2;0RN<^0?W*3'*HTRU/<),&('*).5U1*<2RN&(')M3'FD+E3(H0H0+,HI/&Z/2;*+>^0?3(),),&(8HORU'06
/&/2;*+-08&2+,)./2RN&('7
e &(/2RN),+s/2;43/Z+M3();-08&m+,)./2RN&('&Y3<:3 V +i82105N+i/&S3S^0? H0+f*'*+,<\3HOR+.8+.'/
L3MX&Y3-0-05UXRU'06k/2;0RN<i82105N+S3'*HRN<i5URUK+.5UX/&k3(H0H'*+.LRU'OYn&(8 V 3/2RN&('/&j/2;*+S^0?Ze%&('*<2RNH0+.8Yn&(8
RU'*<2/:3'*),+@/2;*+l^0#
? &Y!x{RU6*eqOW0L;0RN);yH0+,<).82RUDG+,<<2-43/2Ro357RU'OYn&(8 V 3/2RN&('3DG&(10/& ),+,<MW43'*HF82105N+,<J&Y
x{RU69108+lvOe  D RN<E3-0-05URN)M3D05N+F=[<2RU'*),+sQm.9pB
 \G(9AfW3'*Hy<&\RN<   e|7+./E1*<u),&('*<2RNH0+.8   eg_;*+.8+
38+s/L&SL3,XO<&YE3-0-05UXRU'06S/2;0RN<Z82105N+9WqH0+.-+.'*HORU'06t&('kL;*+./2;*+.8RU/<l;X-&(/2;*+,<2RN<ZRN< V 3-0-G+,H&('/&
/2;*+P-43/2V
; T
 I6
  !"
 TT# $
 > %"$a
 &# s&(8&('Q/&/2;*+
-43/2; &# $
  !$
 TT  $
 > %$a
 T(' 4e  '/2;*+*8<2/
)M3(<+yYn&(8FRU'*<2/:3'*),+9W@3k8+.5o3/2RN&(''*&H0
+  tLRU/2;-08+,H0+,),+,<<&(V
8 T
 I63'*H<1*),),+,<<&(8
&# kRN<s3(H0H0+,H/&t/2;*+S^0?Za
e u&(/2RN),+I/2;43/iRU'/2;0RN<s+f03 V -05N+9WJ3-0-05UXRU'0635U582105N+,<iRU'35U5
-&9<<2RUD05N+@L_3,XO<u3(<5N&('06s3(<J/2;*+.X3(H0H'*+.LRU'OYn&(8 V 3/2RN&('RN<u3Z*'0RU/+P-08&),+,<<l=5N+M3(HORU'06i/&/2;*+>698:3-0;
&Yhx{RU69108+>AD010/RU/RN<'*&(//2821*+@RU'I6+.'*+.8:35$e
r;*+.'\/2;*+J@RN<q),& V -&9<+,H\&Y73@<+./&YaY$3()./<]3'*H3@<:+./q&Y82105N+,<&W/2;*+   -08&(DO~
5N+ V 3(<2KO<L;*+./2;*+.8@/2;*+.8+lRN<@3<:+,wQ1*+.'*),+Z&Y]82105N+3-0-05URN)M3/2RN&('*<P+.'082RN):;0RU'06F/2;*+>Y$3()./<E<21*);S/2;43/u/2;*+
6&35h)M3'D+@8+M3():;*+,HW4R$e+9e5N+M3(HORU'06s/&3698:3-0;RU'Q/&\L;0RN):;/2;*+Z^0?)M3'D+@-08&2+,)./+,He  e 6*e
),&('*<2RNH0+.8/2;*+_Yn3().
/ &Y7x{RU69108+OW3'*H5N+./D+_/2;*+u^0%
? &#(' $
 ) $a
 TTs= RN<
('u'*+M38h3'l& ),+ AfeqH0&+,<'*&(/{-08&m+,)./{RU'Q/&@WD010/h3-0-05UXRU'06u/2;*+]82105N+,<MW9&('*+_3(H0H0<}/2;*+]RU'OYn&(8 V 3~
/2RN&(
' T(' 
 ) T$
 TT F=n35N<& TT(' 
 T"
 TT# AfW
/2;Q1*<u3'*<2L+.82RU'06Fe

M

*



4

4

5

&

4

&

4 

4

4

4

d


d

d

d

v { $

4 AG

q

d



&



 (0.[m9p4>)M3'jD+-G&9<RU/2RUC+&(8>'*+.6Q3/2RUC+9W!+fO-08+,<<2RU'06K'*&L5N+,HO6+T&YYn&(8 V RY
M}h	A{% }A
ff ;*&(5NH0<MW<& V 1*<2/* :W&(8 RY+ff;*&(5NH0<MW, V 1*<2/s'*&(/ :e  /iRN<s35N<:&3D0RN),&(5N&(8+,H<2R V -05N+698:3-0;7

/2;*+l*8<2/@),&(5N&(8PH0+f*'*+,<@/2;*+),&('*HORU/2RN&('t-4382/=[&(8\[fUMQfAfW3'*HS/2;*+<+,),&('*H),&(5N&(8@/2;*+ V 3'*H*3/&(82X
=[&(8PYn&(82D0RNH0H0+.'aAE-4382/MeF ^0?  <:3/2RN<24+,<3F-&9<2RU/2RUC+i),&('*<2/28:3RU'Q/ RY2.j-08&m+,)./2RN&('Y[8& V /2;*+
),&('*HORU/2RN&('F-4382/J&Y RU'/o
& )M3'TDG+E+fO/+.'*H0+,Hi/&3-08&2+,)./2RN&('I&Y}/2;*+uL;*&(5N+ eh'*7
H <B3/2RN<m4+,<
3j'*+.6Q3/2RUC+y),&('*</28:3RU'Q/TRYa-08&2+,)./2RN&('&YP/2;*+y),&('*HORU/2RN&('&Y
RU'Q/
&  )M3'D+y+f/+.'*H0+,H/&
3-08&m+,)./2RN&('&Yu/2;*+TL;*&(5N+ etx{RU6*e<;*&MLJ<Z/L&t),&('*<2/28:3RU'/<Meg_;*+T'*+.6Q3/2RUC+F),&('*</28:3RU'Q/ D

fi d

T

0

5

;

 !-








fi

3MfiuM%

workswith

Person

HeadOfGroup

Secretary

in

in

Person

in

in
Office




D

Office

near

Office



x{RU69108+%&('*<2/28:3RU'/<

=

4 R
4
M


+fO-08+,<<+,</2;43/ /L&i-+.8<&('*<L&(82KRU'06s/&(6+./2;*+.8<2;*&(105NHF'*&(/u<2;438+>3'y& ),+ :eg_;*+Z^0? &Yqx{RU6
iH0&+,<u'*&(/@<:3/2RN<mY[XF/2;0RN<E),&('*<2/28:3RU'Q/@D+,)M31*<+ /2;*+.8+lRN<E38+,<+M38):;*+.8@L;*&iL&(82K<uLRU/2;S8+,<+M38):;*+.8
 s=-08&2+,)./2RN&('&Y]/2;*+),&('*HORU/2RN&('-4382/@&Y oIA 3'*Hy/2;*+.X<2;438+Z& ),+/.s`Md T=[+fO/+.'*<2RN&('&Yq/2;*+
-08&2+,)./2RN&('/&T3-08&2+,)./2RN&('y&Yq/2;*+L;*&(5N+ IAfeJg_;*+-G&9<RU/2RUC+),&('*<2/28:3RU'/  +f-08+,<:<+,</2;43//2;*+
& ),+P&Yq3l;*+M3(HI&Yh698&(10- V 1*<2/DG+E'*+M38J/2;*+>& ),+,<&Yq35U57<+,).8+./:382RN+,<Me
r;*+.'/2;*+F@RN<),& V -&9<+,H&Y@3<:+./\&YY$3()./<\3'*H3S<+./&YE),&('*<2/28:3RU'Q/<\hW]/2;*+i8&(5N+F&Y
),&('*<2/28:3RU'/<IRN<F/&H0+f*'*+S/2;*+t),&('*<RN<2/+.'*).X&Yl/2;*+SD43(<+9WuR$e+9e&YZeg_;*+D43(<+SRN<F<:3RNH/&D+
),&('*<2RN<2/+.'/RY35U5{),&('*<2/28:3RU'Q/<P38+<:3/2RN<m4+,He  8&MCRNH0+,H/2;43//2;*+>D43(<:+PRN<u),&('*<2RN<2/+.'Q/MWH0+,HO1*)./2RN&('yRN<
H0&('*+3(<uRU'__e  C+.'yRY/2;*+.Xy38+DG&(/2;SD0RN),&(5N&(8+,Hy698:3-0;*<MW),&('*<2/28:3RU'/<>38+>'*&(/E/&iDG+Z),&('OY[1*<+,H
LRU/2;I82105N+,<Me]%&('*<RNH0+.8JYn&(8RU'*<2/:3'*),+@/2;*+ED0RN),&(5N&(8+,HI698:3-0; 	 &Y!x{RU69108+PvO]3(<3l82105N+9W0RU/J<B3,XO</2;43/
+.C+.82Xt8+,<+M38):;*+.8ZRN<l3 V + V D+.8l&YE3F-08&2+,)./Meg{3K+/2;*+Yn3()./1
0 0T T2 ac3'*H/2;*+
w1*+.82Xi+
0 02 a$
 43 !35 "$a
 76 8   F= RN<e V + V D+.8&Y}3@-08&2+,)./ Afe  Y{RN<
3(<2K+,Hi&('
 "ff$n+
 *) "m  n4fW/2;*+3'*<2L+.8]RN< X+,< :
e u&MLPW<+,+  	 3(<3E-&9<2RU/2RUC+),&('*<2/28:3RU'/ \e  /
<:3MX<]/2;43/]+.C+.82XZ8+,<+M38);*+.8 V 1*<2/DG+J3 V + V D+.8&Y3E-08&2+,)./Me!
 "ff$n+
 *m
 "m kn4!RN<!RU'*),&('*<2RN<2/+.'/MW
/2;Q1*<'*&(/2;0RU'06)M3'ID+@H0+,HO1*),+,HFY[8& V RU/MW0RU'*).5U1*HORU'06s\eqg_;*+@@;43(</&ZD+@8+.-43RU8+,HT*8<2/Me


4



 
d
4



T ]

; &

G

4



q 

|7+./>1*<@),& V D0RU'*+\82105N+,<3'*H),&('*<2/28:3RU'Q/<>RU'8+M3(<&('0RU'06*e
 ^ }h }h y| {%}}$AA{% }A
rt+PHORN<2/2RU'06910RN<;I'*&MLD+./L+,+.'/L&\KRU'*H0<J&Yh82105N+,<M_M,.2fG:BNBl3'*HS?( O[n(SBUffe
 'OY[+.8+.'*),+Z82105N+,<P8+.-08+,<+.'Q/PR V -05URN).RU/>K'*&L5N+,HO6+/2;43/@RN< V 3(H0++f-05URN).RU/@DX82105N+\3-0-05URN)M3/2RN&('*<e
g_;0RN<PRN<>/2;*+\)M3(<+ZYn&(8P82105N+,<<+,+.'3D&MC+=[x{RU69108+svAfex43()./<Z3'*HRU'OYn+.8+.'*),+\82105N+,<>)M3'jDG+\<:+,+.'3(<
H0+,<).82RUD0RU'063sL&(825NHW}3'*Ht3-0-05UXRU'063s82105N+ V &HOR4+,<P/2;*+\+f-05URN).RU/PH0+,<:).82RU-0/2RN&('j&Y/2;*+ZL&(825NH=/2;*+
Y$3()./<BAfC
e u&MLPWRYL+),&('*<2RNH0+.83T@),& V -G&9<+,Hj&Y_3T<+./@&Y]Y$3()./<>W3T<+./@&YRU'OY[+.8+.'*),+82105N+,<9W
3'*H3y<+./l&YE),&('*<2/28:3RU'Q/<l!W!/2;*+s'*&(/2RN&('&Y),&('*<2RN</+.'*).Xj;43(<Z/&/:3K+T82105N+,<RU'/&t3(),),&(10'Q/Mex*&(8
RU'*<2/:3'*),+9W03(H0Hi/&>/2;*+@^0?Ed
< 3'*H
&Yx{RU69108+u>/2;*+Y[&(5U5N&LRU'06lRU'OYn&(8 V 3/2RN&('I3DG&(10/_& ),+E3(<<2RU69'O~
 ;:  T"< 8 "=24a
> $
 L!"
 TT#7
 I64
W 4?  T @7+
: 
 L!$
 TT 
V +.'Q/<o
3'*Q
H 4?  T @Aa
6 
 L!$
 TT 4eh|7+.
/   3'*H  D+/2;*+='*&(8 V 35pA_^0?E<&(D0/:3RU'*+,He
%&('*<2RNH0+.8P/2;*+\L&(825NHj),& V -&9<+,Ht&Y_/2;*+i^0? b[WRU'OY[+.8+.'*),+\82105N+,
< m  D *   n&Y_x{RU69108+ivOW{3'*HS/2;*+
-&9<2RU/2RUC+F),&('*<2/28:3RU'Q/  &YEx{RU69108+eg_;*+^0
?   35N&('*+IH0&+,<'*&(/\<:3/2RN<2YX/2;*+F),&('*<2/28:3RU'Q/
=D+,)M31*<+ /2;*+T;*+M3(Hk&Yu698&(10-|qehRN<lRU'& ),+B7
 I9W]3'*Hk/2;*+F<+,).8+./:382X  ehRN<lRU'& ),+B :W!D010/
RU/ZH0&+,<'*&(/Z;*&(5NHj/2;43/ %7
 IRN<'*+M38C Afe10/3Y/+.83),+.82/:3RU'k'1 V D+.8&Y82105N+s3-0-05URN)M3/2RN&('*<W
RU/>H0&+,<Mesg_;Q1*<P/2;*+i@RN<><:3RNHt/&FDG+),&('*<2RN<2/+.'Q/Me  't/2;0RN<>)M3(<:+RU/PRN<>+M3(<Xy/&H0+f*'*+i3'*Hj):;*+,)K
),&('*<2RN<2/+.'*).XDG+,)M31*<+>/2;*+>L&(825NHSH0+,<).82RU-0/2RN&('y)M3'yD+>),& V -05N+./+.5UX+fO-05URN).RU/+,HDQX3*'0RU/+Z^0? =/2;*+
 W7<:3RNH/&FD+EfaLPe 8Me /MeCTAfW/2;Q1*<PRU/P<1 ),+,<P/&I):;*+,)K/2;43/P/2;0RN<@698:3-0;RN<P),&('*<2RN<2/+.'/Me
698:3-0;
 '6+.'*+.8:35J)M3(<+9W!),&('*<RN<2/+.'*).Xj8+.5URN+,<&('kL;*+./2;*+.8\+M3(); ),&('*<2/28:3RU'/\CRN&(5o3/2RN&(' T)M3'D+s8+.-43RU8+,H

M 9



7



M 9

d



4

4
d;

4 ;





;

 





d

.

fi M]|9M.tM=uwuMM3
 F

DQXT82105N+l3-0-05URN)M3/2RN&('*<MWa3(<LRU5U5D+uY[&(8 V 35U5UXIH0+f*'*+,H5o3/+.8Meu<LRU/2;<R V -05N+.8JL&(825NH0<uH0+,<).82RUD+,HIDQX
Y$3()./<J&('05UXW*H0+,HO1*)./2RN&('RN<J'*&(/-G&9<<RUD05N+@&('IRU'*),&('*<2RN<2/+.'/K'*&ML5N+,HO6+PD43(<:+,<Me
Person

in

Office

x}RU69108+cO!82105N+
 C&(5U10/2RN&('j82105N+,<E8+.-08+,<+.'Q/P-&9<<2RUD05N+3()./2RN&('*<@5N+M3(HORU'06TY[8& V &('*+ZL&(825NHS/&F3'*&(/2;*+.8>&('*+9e  e 6*e
),&('*<2RNH0+.8/2;*+>),&(5N&(8+,HI698:3-0;y&Yqx}RU69108+lcOeu<3'RU'OY[+.8+.'*),+>82105N+9W*RU/L&(105NH35U5N&L/&\H0+,HO1*),+>/2;43/
35U5-G+.8<:&('*<_38+uRU'I35U5& ),+,<Mequ<3'T+.C&(5U10/2RN&('F82105N+9WRU/<:3MX<_/2;43/ L;*+.'T/2;*+.8+P38+@3>-+.8<&('F3'*H
3'I& ),+9W43l-&9<<2RUD05N+@3()./2RN&('IRN</&\3(<:<2RU69'T/2;0RN<J& ),+@/&Z/2;43/-+.8<&(' :e%&('*<2RNH0+.83Z@),& V -&9<+,H
&Y3i<+./&YqY$3()./<EW3<+./u&Y]+.C&(5U10/2RN&('S82105N+,<D]W3'*HS3\<+./E&Y]),&('*<2/28:3RU'Q/<u!eux43()./<EH0+,<).82RUDG+Z3'
RU'0RU/2Ro35{L&(825NH+.C&(5U10/2RN&('S82105N+,<8+.-08+,<:+.'Q/E-G&9<:<2RUD05N+P/28:3'*<2RU/2RN&('*<Y[8& V &('*+>L&(825NHy/&s&(/2;*+.8L&(825NH0<M
),&('*<2/28:3RU'/<H0+f*'*+u),&('*<2RN<2/+.'*).X\&Y+M3():;iL&(825NH03P<21*),),+,<<:&(8&Y}3P),&('*<RN<2/+.'Q/L&(825NHiRN<]&(D0/:3RU'*+,HsDQX
3'I+.C&(5U10/2RN&('I82105N+P3-0-05URN)M3/2RN&('7069RUC+.'3\^0?\WO/2;*+@H0+,HO1*)./2RN&('I-08&(D05N+ V 3(<2KO<_L;*+./2;*+.8J/2;*+.8+ERN<J3
-43/2;&Y!),&('*<2RN<2/+.'/JL&(825NH0<u+.C&(5UCRU'06\Y8& V /2;*+@RU'0RU/2Ro35}&('*+@/&\3ZL&(825NH<:3/2RN<mY[XRU'06i\e
g_;*+ V &9<2/l6+.'*+.8:35 V &H0+.5&YJ/2;*+sYn3 V RU5UXj),&('*<RNH0+.8<ZDG&(/2;kKRU'*H0<Z&Y82105N+,<W_0 5W 53<+./(
&Y]RU'OYn+.8+.'*),+Z82105N+,<MW3'*H3i<:+./ED&Y+.C&(5U10/2RN&('82105N+,<e  'y/2;*+l-4382/2RN).105o38P)M3(<+Z&Y]/2;*+i*{*77,:
V &H0+.5UR 3/2RN&('7WI3'*H9H0+,<).82RUD+!/2;*+qRU'0RU/2Ro35RU'OYn&(8 V 3/2RN&('Z3D&(10/}& ),+]5N&)M3/2RN&('*<MW-+.8<&('*<}3'*H>/2;*+
698&(10-&(826Q3'0R 3/2RN&('7eF35N<&@+.'*),&H0+,<q6+.'*+.8:354K'*&ML5N+,HO6+>=[<21*):;i3(<!-08&(-+.82/2RN+,<q&Y/2;*+P( i8+.5o3/2RN&('
-010/D+./L+,+.'/L&\),&('*),+.-0/J'*&H0+,<8+.-08+,<+.'Q/2RU'06iHORN<2/2RU'*)./+.'Q/2RU/2RN+,<fAfe!8+.-08+,<:+.'Q/<&(D05URU6Q3/2RN&('*<u3'*H
RU'Q/+.8HORN)./2RN&('*<H0+f*'0RU'06L;43/3(),),+.-0/:3D05N+t3(<<2RU69' V +.'/<38+=RU'*).5U1*HORU'06)M38HORU'435URU/X),&('*<2/28:3RU'/<
<21*):;j3(< 3-+.8<&('t)M3'0'*&(/@D+spk<+.C+.8:35!& ),+,< Z&(8 3s5o3826+& ),+)M3'0'*&(/P),&('/:3RU' V &(8+Z/2;43'
/L&-+.8<&('*< :W!1*<2RU'06/2;*+( 8+.5o3/2RN&('aAfeGD),&('*<2RN<2/<&YE&('*+T+.C&(5U10/2RN&('82105N+TL;*&9<+s8+,<2105U/RN<Z/&
-05o3(),+>3Z-+.8<&('IRU'/&3'& ),+s=RU/),&(105NH35N<&D+@),& V -&9<+,HI&Yq<+.C+.8:35782105N+,<),&('*<2RNH0+.82RU'06i<2-+,).R4)
-08+,),&('*HORU/2RN&('*<TD+fY[&(8+/282XRU'063'3(<<2RU69' V +.'/BAfeg_;*+6&358+.-08+,<+.'/<F3t<2RU/2143/2RN&('L;*+.8++M3():;
-+.8<&('&YP/2;*+698&(10-;43(<T3'& ),+9e <&(5U10/2RN&('/&t/2;*+-08&(D05N+ V RN<T3jL&(825NH&(D0/:3RU'*+,HY[8& V
/2;*+RU'0RU/2Ro35]&('*+\DQXt3T<+,w1*+.'*),+\&Y_& ),+i3(<<2RU69' V +.'Q/<WL;*+.8+\+M3():;t-+.8<&('t;43(<>3'j& ),+9WL;0RU5N+
<:3/2RN<mY[XRU'06/2;*+>35U5N&)M3/2RN&('),&('*<2/28:3RU'Q/<Me

4

4

6

 

p

4

5

4 5 

4

hy _



4

6





z{

4

4

4

4



	

|7+./J1*<J'*&ML<2-+,).RY[XsH0+f*'0RU/2RN&('*<u3'*HF'*&(/:3/2RN&('*<),&('*),+.82'0RU'06i/2;*+@jY$3 V RU5UXe

}



9 0f2 p

 yfi;}]}  uy   ),&(5N&(8+,Hj<2R V -05N+698:3-0;o\O( " $k)* H4oh
 9a/Hko\F\BQap@fm(  $[4\pa$Zm%I *WIn5UOZ*fB.M,[9$IGMQ\o(U2
}
Ol),&(5N&(8ZmPOPaMQW5 
e >fa9ZS: KJ ML OEf0$(mf4mH pa9O:TL:[3!:(922sGMQBW5UO
B*n(2B4 JON L Zf.9BE}
 $N p5 J
5 OG.02(Bum2.9[n(TaMEm
JPN L ZQ.}( .fU(
$ JON L RT5

fi

 







g ;*+E5o3/2/+.8),&('*HORU/2RN&('k= JON L V 1*<2/_Yn&(8 V 3\^0?PARN<_'*+,),+,<<B382XT3(<<&&('I3(<_L+P),&('*<RNH0+.882105N+,<3(<
_
),&(5N&(8+,HI^0?E<Mh<2;*&(105NHT3P82105N+'*&(/_<:3/2RN<mY[X/2;0RN<),&('*HORU/2RN&('7WORU/<3-0-05URN)M3/2RN&('F&('F3l^0?),&(105NHs6+.'*+.8:3/+
3l698:3-0;I/2;43/JRN<J'*&(/3\^0?Ze
 @RN<ZH0+.'*&(/+,HDX
 " $n+
 *)g
 *)
D *m
 4fW]L;*+.8+FRN<l3y<+./Z&Y<2R V -05N+i698:3-0;*<Z8+.-08+,<+.'/2RU'06
Y$3()./<MWWDj3'*HsS38+u/2;08+,+@<+./<_&Y{),&(5N&(8+,HF<R V -05N+E698:3-0;*<_8+,<2-G+,)./2RUC+.5UXi8+.-08+,<+.'Q/2RU'06pMMffa:
fNBfWS ?( [n(BUffW3'*H(*f[2(paI=-&9<2RU/2RUC+Z&('*+,<ERU'yRQ_WG'*+.6Q3/2RUC+\&('*+,<ERU'yTS}Afe?uRUC+.'j3

;

 

fi

3MfiuM%

@3'*Hi3E6&35\W/2;*+>Q(OM[[(amfU.3(<2KO<qL;*+./2;*+.8)M3'DG+JH0+,HO1*),+,H\Y8& V =L+'*&(/+
 P >Afe  YL+R V -G&9<:+<& V +J&Y7/2;*+<+./<&yWDS&(8!I/&PD+J+ V -0/XW&('*+&(D0/:3RU'*<<-G+,).R4)8+M3(<&('0RU'06
e u&(/+E/2;43/RU'F/2;*+>3D*<+.'*),+>&Yh),&('*<2/28:3RU'/<l=p
 " AfW*RU'OY[+.8+.'*),+>3'*H+.C&(5U10/2RN&('82105N+,<J;43MC+
V &H0+.5N<M
/2;*+P<:3 V +PDG+.;43MCRN&(8MW4/2;Q1*<fi 3'*HUDk)M3'IDG+@),&('OY[1*<+,Heg_;*+PjY$3 V RU5UXTRN</2;*+.'),& V -&9<+,HI&Yh/2;*+
<2RsY[&(5U5N&LRU'06 V &H0+.5N<Me



F  
/2;*+P V &H0+.5Yn&(8JW0 $n+*fig*XD*4
/2;*+P V &H0+.5Yn&(8JW0$n+* * *J.4
/2;*+P\ V &H0+.5Y[&(8JY0 $na*Eg*@ *4
/2;*+PD V &H0+.57Y[&(8JW0 $n+*F *fiD*_4

V /2;*+P V &H0+.57Y[&(8JW0 $n+* * * 4
V
V
V
V

V /2;*+PCD7 V &H0+.5Yn&(8JW0 $n+*Xg*,Da*.4

^RU'*),+3EYn3()./q;43(<q/2;*+J<:3 V +J<+ V 3'/2RN),<3(<3E82105N+LRU/2;i3'+ V -0/XZ;QX-G&(/2;*+,<2RN<W/2;*+J<+./RN<]1*<+,H
RU' V &H0+.5N<h'43 V +,<!&('05UXL;*+.'DG&(/2;Z82105N+_<+./<F3'*H(D38+_+ V -0/Xe!g_;*+;0RN+.8:38):;QX&Ya/2;*+,<+ V &H0+.5N<
NR <8+.-08+,<+.'Q/+,HyRU'x{RU6*eGbOe  /;0RU69;05URU69;Q/<u/2;*+lH0+,).RNH*3D0RU5URU/X-08&(-+.82/2RN+,<E3'*H/2;*+),& V -05N+fRU/X&Y!/2;*+
3(<<&).Ro3/+,HsH0+,HO1*)./2RN&('s-08&(D05N+ V ea&(/2RN),+L+uHORUCRNH0+'*&('TH0+,).RNH*3D05N+-08&(D05N+ V <_RU'/&i,fZM!Q2,[fU
3'*H[f; :GQ2.nQfN-08&(D05N+ V <Me  'T/2;*+*8<2/J)M3(<+9W03'3'*<2L+.8J)M3'FD+E),& V -010/+,HFRU's*'0RU/+E/2R V +
Yn&(835U57-G&9<RU/2RUC+@RU'*<2/:3'*),+,<JD010/'*&(/Y[&(835U5'*+.6Q3/2RUC+>&('*+,<Me  'F/2;*+P<:+,),&('*HI)M3(<+9W0/2;*+.8+@RN<J'*&Z*'0RU/+
-08&),+,HO108+9W0'*+.RU/2;*+.8JYn&(835U57-&9<2RU/2RUC+ERU'*<2/:3'*),+,<MW0'*&(8JY[&(835U5'*+.6Q3/2RUC+&('*+,<Me
Z[\%]

g782105UXT10'*H0+,).RNH*3D05N+

Z[F]
Z\!]

^+ V R~H0+,).RNH*3D05N+

Z[

_` ~),& V -05N+./+


Z8^]
Z8^

  ~),& V -05N+./+

x{RU69108+>bOqg_;*+@_tY$3 V RU5UX V &H0+.5N<3'*HI),& V -05N+fRU/XF&Y{/2;*+>3(<:<&).Ro3/+,HFH0+,HO1*)./2RN&('-08&(D05N+ V
aq



E

 cb"]$Mk]jEd

!]4





fi

B aUi(2B4fN=$^0?82105N+A+ V D+,H0<\K'*&ML5N+,HO6+y&YEY[&(8 V RY9ff /2;*+.'e :eg_;*+FY[&(5U5N&LRU'06
H0+f*'0RU/2RN&('3(<3),&(5N&(8+,H^0?RN<Z+,wQ10RUC935N+.'Q/Z/&/2;*+ V &(8+s/28:3(HORU/2RN&('435H0+f*'0RU/2RN&('&Y3I82105N+F3(<3'
&(DO2+,)./Z),& V -&9<+,H&Yu/L&j^0?@<Z8+.5o3/+,HLRU/2;),&(8+fYn+.8+.'*),+F5URU'0KO<l1*<+,HkDQX?@&9<2;3'*Hr1QL&('06<:+
=m`Mb9b9vAfW*&(8u^O35UC93/3'*HF1069'0RN+.8=m`Mb9b9Afe

;

 

fi M]|9M.tM=uwuMM3
 F

 	ff


yfi;}]}$k{%}

uA{M}h

oTt(U(2J
 {1
 5  JON L pT:(pN2tT;QX~
yn <2R V -05N+i698:3-0;82105N+ 

 yfi;}]}gf   
-&(/2;*+,<2RN<L=(a  J D L [),&('*).5U1*<2RN&('5
E+,HO1*)./2RN&('H0+.-G+.'*H0<i&('/2;*+F'*&(/2RN&('&Y>3BNfa [[[(hRU/\RN<i3S698:3-0;/28:3'*<mYn&(8 V 3/2RN&('
D43(<+,HF10-&('F-08&2+,)./2RN&('7e



 Z8}
 
= (a  ZifNW5  o3-0-05UR~
y .

 y fi;}]}ih  ` M{M} j{  
)M3D05N+S$7  \OfI)j9o.iGmmM2,[n(=u.T: =}f2(  JON L NO\:BO9OfBpsm  RI4$Z85gB
9,S
= OZBBmZOs3-0-05URN)M3/2RN&('j&Y  &('3(),),&(8HORU'06I/&plOr}  Q.$(G2SS:
\ sO(o.9p4]4[(mH (aTm>sBF
: m  J L N Ol(a. Bn(tm  Rq
= O.=4,(S?fS:
D
2M7$MA*y>*364>=jh
9 O.2k i  JPN L (a  i  J L @
= (S(2MQ!
9 O.9\*fF.	
9 f
D
$	W>
4 9asO>:BF
: md5+  oE.9[i$Fl(R VV +,HORo3/+  ~H0+.82RUC93/2RN&('TB2(qo5

H0+.82RUC(3/2RN&('RN<3I=-&9<<2RUD05UXi+ V -0/X0AJ<+,w1*+.'*),+@&Y{82105N+>3-0-05URN)M3/2RN&('*<




 yfi;}]}gk ,
 yn 3{M} .l lM.2@BUf>=(arl{151el(\~H0+.82RUC93/2RN&('
fm(  $  TMy.*fa:F2C{[ q
"  N * F6F6F *
"  fO.O9M=7.9rIZ\Vj\ K = p\(
G
l29[9  !mQff'?[[(lfm(  S D =h
9 Of  pPfN>pm5





g}&lH0+,HO1*),+E3Z^0?\WQL+ V 1*<2/_DG+u3D05N+/&lH0+.82RUC+@3l^0?RU'Q/&lL;0RN):;I)M3'sD+J-08&2+,)./+,Heqg_;0RN<
'*&(/2RN&('IRN<J)M3-0/2108+,HDQXs/2;*+EYn&(5U5N&MLRU'06iH0+f*'0RU/2RN&('7

Kv { $

u

  
  . " $n+*)4yonbX(atU.E :J}15 :(:

 y fi;}]}  2i
Q29O:fm(  N a9$9[n(t P n$ +*)4cR \OfF)j(pfi(pg!mQff'?9[[9sf2( $S}
B0fI9! P 5

 

MMM{

y 
 



{%}M

g_;*+<+ V 3'/2RN),<RN<@+f/+.'*H0+,HS/&s/28:3'*<25o3/+Z82105N+,<Mu69RUC+.'j3i82105N+  W5N+./  N 3'*H  D DG+l/2;*+l/L&
^0?E<8+,<-G+,)./2RUC+.5UX),&(828+,<2-&('*HORU'06j/&SRU/<;QX-G&(/2;*+,<2RN<i3'*HRU/<\),&('*).5U1*<2RN&('7W_R$e+9e  N "  JON L 3'*H
 D RN<i/2;*+S^0? &(D0/:3RU'*+,HY[8& V  J D L DQX3(H0HORU'06k/2;*+'*+.RU69;DG&(8<T&YP/2;*+8+.5o3/2RN&(''*&H0+,<i&Y  J D L
L;0RN);38+I),&('*),+.-0/s'*&H0+,<i&Y  JPN L eg_;*+.'[
 $  4Z" ] D FtFtF ] $ +$  N 4
_ FtFtF _ $  42A
D
D
N
N
L;*+.8+ $  4_3'*H +$  D 4_38+E/2;*+@),&('(m10'*)./2RN&('*<&Y!3/& V <3(<<&).Ro3/+,HTLRU/2;  3'*H  D W ] D FtFtF ]
38+i/2;*+C9382Ro3D05N+,<Z&Y +$  N 4>3'*
H _ D FtFtF _ \38+i/2;*+C9382Ro3D05N+,<Z&Y +$  D 4@/2;43/H0&'*&(/3-0-G+M38lRU'
$  N 4feFx4&(8>RU'*<2/:3'*),+9Wh),&('*<2RNH0+.8l/2;*+\82105N+ 	 RU'x{RU6*e}vOeTg_;*+.'[
 $ 	 4E"]`$JB,(m.OfA $M])4
_)$2m,,c $M_4 ff $M]*y_4y4y4fe ^;*&(105NHL+SRU'/+.82-08+.//2;*+),&(5N&(8+,H698:3-0;
RU'x{RU6*eJ3(<
D
3s82105N+9W7RU/<@Y[&(8 V 105o3FL&(105NHtDG+j
 $ D 4b"ff]_$y$J.:,( $M]4 JJ.:,( $M_4 9]( MS !c9![ $M]*y_4y4
$ rq: $ 4 p
 $M]* 4  $M_* 4y4y4f
e u&(/2RN),+9W10'05URUK+]RU'Z).5o31*<+,<MWC9382Ro3D05N+,<-08&(-+.8{/&J/2;*+),&('*).5U1*<2RN&('
38+P+fORN<2/+.'Q/2Ro35U5UXFw143'Q/2R4+,He
g_;*+EYn&(5U5N&MLRU'06s<&(10'*HO'*+,<<3'*H),& V -05N+./+.'*+,<<J8+,<2105U/RN<J&(D0/:3RU'*+,H







 R

p

+

 G


=



 G

 !r

C	 ` ff 


T
$

<



U


t Cuvu w  7t Cu|u


hy|My
qhM}]y|
f + { 3{  kJ .!
 { 3{

Zo}
 15UOf P $na*)74> j$4*Bj$n4*Bj$t74 I[$$E465



<

.ff
ff

"$n+*)74\\snYX(ai

u&(/2RN),+J/2;0RN<8+,<2105U/3(<<1 V +,<]/2;43/698:3-0;*<38+69RUC+.'RU'\'*&(8 V 35aY[&(8 V WO3'*HWRY'*+,+,H0+,HW-010/]RU'/&
/2;*+.RU8J'*&(8 V 35Yn&(8 V 3Y[/+.8J+M3();82105N+P3-0-05URN)M3/2RN&('7e

;A


	

fi3MfiuM%



  

`  v` 
%&(105N&('*HO8+J3'*H^O35UC(3/=m`Mb9b9cA-08&MC+,HZ/2;43/{K*{sRN<h<+ V R~H0+,).RNH*3D05N+_LRU/2;38+,HO1*)./2RN&('
Y[8& V /2;*+;*Q|C*v${9 <$vu(w/leig_;*+\8+,HO1*)./2RN&('69RUC+.'tDX_36+./T=n99O`A
=pY[8& V /2;*+(xRz
 y@v${9 $g u> { yi| 7* AJ-&(RU'Q/<u&(10//2;43/2 K* { 
RN<P3T),& V -010/:3/2RN&(' V &H0+.5$e>rt+Z69RUC+Z;*+.8+\3'*&(/2;*+.8@8+,HO1*)./2RN&('7W7Y8& V /2;*+~}$D
 *|{9 s
AN7
 .h2D PW7/2;43/@L+ZLRU5U5!1*<+\3(<E/2;*+<2/:382/2RU'06I-&(RU'Q/@RU'/2;*+Z-08&&Y&Y  8&(-7eq`MOeZg_;0RN<
8+,HO1*)./2RN&('IRN<35N<&lRU'Q/+.8+,</2RU'06\RU'FRU/<+.5Y}<2RU'*),+ERU/_-08&C+,</2;43/MW0+.C+.'FL;*+.'F82105N+,<J38+@&Y/2;*+uYn&(8 V  RY
O9Kk] D F6F6F ] G >
 /2;*+.'TOUk_ D F6F6F _  G: W02Kv { $t 8+ V 3RU'*<<+ V R~H0+,).RNH*3D05N+9e
y 
 

~>hy|Mh{

y



y

 7t Cu|u k 2Kv { $ pE,fZM!Q2,[fU5
2MmWFx{RU8<2/>):;*+,)Kt/2;43/i*|RN<'*&(/>/282105UX10'*H0+,).RNH*3D05N+S=5pW5F/2;*+.8+i+fORN<2/<l3'k35~
6&(82RU/2; V /2;43/P)M3'tH0+,).RNH0+ZRU'S*'0RU/+Z/2R V +ZRY_/2;*+\3'*<2L+.8@/&T/2;*+Z-08&(D05N+ V RN<F X+,<5 AfuL;*+.')M3'
p

hy|My

}q

r

}]y

{  3{
 

D+uH0+,HO1*),+,HFY8& V W*3lD08+M3(HO/2;O~n*8<2/<+M38);I&Yh/2;*+E/28+,+@&Yh35U57H0+.82RUC93/2RN&('*<_Y[8& V -08&MCRNH0+,</2;*+
3'*<2L+.8JRU'F*'0RU/+@/2R V +9e
rt+/2;*+.'-08&C+>/2;43/u'*&T35U6&(82RU/2; V RN<u+.'*<2108+,H/&;435U/uL;*+.'/2;*+l3'*<2L+.8E/&/2;*+>-08&(D05N+ V RN<
'*& :e|+./1*<'*&ML<2;*&ML/2;43/2   kRN<'*&(/H0+,).RNH*3D05N+lDQXFD010RU5NHORU'06I3\8+,HO1*)./2RN&('Y[8& V
/2;*+U}

 
 N 7 .h  =[g_;Q1*+9W@`MbO`.dAfeg_;0RN<-08&(D05N+ V L_3(<\-08&C+.'
<+ V R~H0+,).RNH*3D05N+>DQX  &9</=m`MbdW08+,HO1*)./2RN&('/&Z;0RN<),&(828+,<2-&('*H0+.'*),+  8&(D05N+ V Afe
g_;*+}

 )M3'DG+j+f-08+,<<:+,H3(<M5N+.g
/  3'*p
H 7ED+S/L&L&(8H0<W>3'*H "
m * F6F6F * nD+3@<+./]&Y82105N+,<MW+M3();i82105N+ D+.RU'06l3E-43RU8]&YL&(8H0Y
< $ ,* c4fRN<]/2;*+.8+3@H0+.82RUC93/2RN&('
D
G
Y[8& V  /Z
& 7 g_;*+.8+ZRN<P3'R VV +,HORo3/+\H0+.82RUC93/2RN&('Y[8& V  /
& 7=L+Z'*&(/r
+  7NARYmWGYn&(8
<& V ++ 9W %" D 6  3'*g
H   "p D 6  eJ QffM ?9[n(Y[8& V  /&   =L+l'*&(/C
+ Y   A

RN<3Z<+,w1*+.'*),j
+  " N  D

O
"

e
F6F6F

 4

B

Kv { $
$D *|{9   A ]  2D
$D *v${9


&
M
{
C
ff ff ff 	
% 
 
s

s

s

s

E

u

` ]*

s
s

$M4




ff

s

s

s

s

 $)4

#
A

s

u

s

$Dvv$|
RU'Q/&i*|
g_;0RN<_-08&(D05N+ V )M3'F+M3(<2RU5UXD+u+f-08+,<<:+,HiRU's/2;*+u V &H0+.5$ez'*+E),&('*),+.-0/_/X-G+9
 RN<J3(<<2RU69'*+,H
/&+M3():;Z5N+./2/+.8]  e}g_;*+.8+38+/2;08+,+&(/2;*+.8{),&('*),+.-0/h/X-G+,<M{=pYn&(8D D+.69RU' AfWZ=pY[&(8 +.'*HC A3'*H
 =pYn&(8
3'QX/2;0RU'06MAfeRN<!/2;*+J698+M3/+,<2/q),&('*),+.-0/]/X-+J3'*H35U5*&(/2;*+.8q/X-+,<]38+_-43RU82LRN<+'*&('O~),& V -438:3D05N+9e
g_;*+.8+RN<P&('*+\8+.5o3/2RN&('t/X-G+Z=pY[&(8;43(<<21*),),+,<<&(85 AfeL&(8HB " ] D F6F6F ] G RN<>3(<<&).Ro3/+,HS/2;*+
698:3-0;t$M4fW73'*H/&F3'XI82105N+B"$M_ D F6F6F _2	 *F D F6F6F AW 4RN<@3(<<:&).Ro3/+,Hy/2;*+698:3-0;y82105N+  $.4fW73(<
8+.-08+,<+.'/+,HRU'yx}RU6*e`MOeXI3<2/28:3RU69;/mY[&(82L_38Hy-08&&Y=n3Z8+,).10828+.'*),+l&('/2;*+P< V 35U5N+,<2/H0+.82RUC93/2RN&('
5N+.'069/2;aAfW9L+&(D0/:3RU'l/2;43/h/&E+.C+.82X>-43/2;lY[8& /2;*+'*&H0+/X-G+,H~/&/2;*+'*&H0+/X-+,H~=& D+.69RU'
 /&
+.'*HC A_RU'y3l698:3-0;B\~H0+.82RUC+,HIY8& V $M4fWaV ),&(828+,<2-&('*H0<3ZL&(8H=n3'*HF'*&(/3\<210DQL&(8H4AJH0+.82RUC93D05N+
Y[8& V tW43'*HT8+,).RU-08&)M35U5UXe  /_Yn&(5U5N&MLJ</2;43/ * $M  4 P $n$M4*  $4y4fe

x{RU69108+\`MOqg8:3'*<mY[&(8 V 3/2RN&('Y8& V /2;*+9}

;



fi M]|9M.tM=uwuMM3
 F



h

E



i 

fi#

 kqu2!q4

| +./J1*<'*&MLRU'Q/28&HO1*),+i(*f[2(pafW0L;0RN):;S38+@1*<:+,HF/&C935URNH*3/+@K'*&L5N+,HO6+9e_K'*&ML5N+,HO6+D43(<+
7
LRU5U57D+uC(35URNH*3/+,HFRYhRU/J<:3/2RN<m4+,<+.C+.82Xs),&('*<2/28:3RU'/MWa3'*HT'*&\H0+,HO1*)./2RN&('LRU5U57DG+@35U5N&L+,H10'05N+,<<_/2;*+
@;43(<_D+,+.'sC(35URNH*3/+,H!RU's-08+,<+.'*),+@&Y}),&('*</28:3RU'Q/<MW0H0+,HO1*)./2RN&('FRN<_H0+f*'*+,HT&('05UXi&('F3T(0fo.f4
K'*&ML5N+,HO6+PD43(<:+9e

}	ff


  K
y 6 
y ]{Ay 
 

yfi;}]}$k{%}

q

y|y|



+ N$B$)
 5'*+.6Q3/2RUC+SR),&('*<2/28:3RU'/
oF:(922{15

  M}h	A{% }AB -&9<2RU/2RUCO
JON L o(UO\/282RU696+.8imZO:(0f[2(4M = J D L o(U2[&(D05URU6Q3/2RN&('N$B$)5RU'/+.8HORN)./2RN&(' RT5
 #G~$CRN&(5o3/+,<EOf[M?8N$B$)5G$9[M?Ri(*f[2(pa  oPuGmmM2,[n(mEOP[fUMQf
 }
m pa$>OB2(a94Q,(fma
  N$B$.
 54$b
 HRP9h(*a{@)jfaQ2N2f$)5O9}9I:
)j9.aQ2S Rl$a2m,,[[9F2 (JE
 9h(NW 5CRN&(5o3/+,<  [ `!c?Mn(U9B ,(_.(ha2m,,[[9
a5 OfS 9!oM =`<:3/2RN<m4+,< 85

 y fi;}]}












=

t

r

t

t))%

r





t
t



r



x{RU69108+\`9`9]+,HO10'*H*3'*).XF3'*HI),&('*<2/28:3RU'Q/CRN&(5o3/2RN&('
r +T;43MC+F/&S-G&(RU'/&(10//2;*+FR V -&(82/:3'*),+I&Y/2;*+IRU828+,HO10'*H*3'*).X),&('*HORU/2RN&('&('/2;*+T698:3-0;/&
t
D+IC935URNH*3/+,HDQX-G&9<2RU/2RUC+),&('*<2/28:3RU'Q/<y<;*&(105NHL+FYn&(826+./i/2;0RN<i),&('*HORU/2RN&('7WJ/2;*+.8+ V 3MXD+F/L&
+,w10RUC(35N+.'/^0?E<W}<21*):;j/2;43/l&('*+<:3/2RN<m4+,<Z3F-&9<2RU/2RUC+\),&('*</28:3RU'Q/\3'*Ht/2;*+i&(/2;*+.8H0&+,<>'*&(/MeFx{RU6*e
`9`Z<2;*&MLJ<3'S+f*3 V -05N+&Y<1*);698:3-0;*<M
e  <:3/2RN<m4+,< \WD010/u/2;*++,w10RUC935N+.'Q/=8+,HO10'*H*3'Q/BA@698:3-0;
kW}&(D0/:3RU'*+,HDQX V 3KRU'06/2;*+HORN<nm&(RU'/>10'0RN&('&H
Y  3'*Ht/2;*+/282RU696+.8&Y W}H0&+,<>'*&(/Mesg}&y3MC&(RNH
HOR+.8+.'Q/}),&('*<RN<2/+.'*).XC935U1*+,<Yn&(87+,w10RUC(35N+.'/7698:3-0;*<MWL+!;43MC+]);*&9<:+.'P/&H0+f*'*+q-&9<2RU/2RUC+!),&('*<2/28:3RU'/
<:3/2RN<mY$3()./2RN&('LPe 8Me /Meh/2;*+RU828+,HO10'*H*3'Q/Yn&(8 V &Y}3l^0?ZeQg_;0RN<-08&(D05N+ V H0&+,<]'*&(/&),).108]LRU/2;s'*+.6Q3/2RUC+
),&('*<2/28:3RU'/<Me  '*H0+,+,HW5N+.E
/  D 3'*
H   D+l/L&+,wQ10RUC935N+.'Q/@698:3-0;*<>3'*H<10-0-G&9<o
+  D G~$CRN&(5o3/+,<>3
'*+.6Q3/2RUC+\),&('*<2/28:3RU'/ <2RU'*),+Z/2;*+.8+\+fORN<2/<P3i-08&m+,)./2RN&('Y[8& V  D RU'Q/
&   W7<:3M
X  D.
W  D HRN<P3
-08&2+,)./2RN&('FY8& V /&   WO/2;1*Y
<   35N<&ZCRN&(5o3/+,< \e
gL&T),&('*<2/28:3RU'Q/< D 3'*H  38+l<:3RNH/&iD+Ty ,M ?(Nf4RY3'QX698:3-0;/2;43/ECRN&(5o3/+,< D 35N<&
CRN&(5o3/+,<  3'*HT),&('C+.8<+.5UXe]'QXi'*+.6Q3/2RUC+P),&('*<2/28:3RU'Q/RN<+,w10RUC935N+.'Q/J/&l/2;*+E'*+.6Q3/2RUC+@),&('*<2/28:3RU'/
&(D0/:3RU'*+,HDQX),&(5N&(82RU'06k35U5RU/<'*&H0+,<\DX`9ex01082/2;*+.8 V &(8+9WJ'*+.6Q3/2RUC+y),&('*<2/28:3RU'Q/<T38+IRU'*H0+,+,H3
-4382/2RN).105o38)M3(<:+&Y-&9<2RU/2RUC+&('*+,<M{),&('*<2RNH0+.8q/2;*+J-G&9<2RU/2RUC+),&('*<2/28:3RU'Q/  &(D0/:3RU'*+,HY[8& V 3E'*+.6Q3/2RUC+
),&('*<2/28:3RU'/ DX),&(5N&(82RU'06\35U5G'*&H0+,<&Y DQXiOW/2;*+.'T3(H0HORU'06\3),&('*),+.-0/_'*&H0+u),&(5N&(8+,HsDQX`9WLRU/2;
/X-+8   *W9L;*+.8+, "  T ERN<qRU'*),& V -438:3D05N+JLRU/2;i35U5*&(/2;*+.8q/X-+,<]3'*H\H0&+,<h'*&(/3-0-+M38qRU'
3'QXT698:3-0;y&Y{/2;*+@uW4+fO),+.-0/JRU'),&('*<2/28:3RU'Q/<Meg_;*+.'y3\<2R V -05N+@698:3-0
; CRN&(5o3/+,</2;*+P),&('*<2/28:3RU'/
RY3'*H&('05UXRYqRU/CRN&(5o3/+,<  e  &9<2RU/2RUC+),&('*<2/28:3RU'Q/<E<2/282RN)./25UXRU'*).5U1*H0+'*+.6Q3/2RUC+Z),&('*<2/28:3RU'/<MWRU'
/2;*+J<+.'*<:+/2;43/q/2;*+3(<<:&).Ro3/+,H\),&('*<RN<2/+.'*).XZ-08&(D05N+ V <38+'*&(/]RU'\/2;*+J<:3 V +J),& V -05N+fORU/X\).5o3(<:<=/2;*+
-08&&Y}Yn&(5U5N&MLJ<JY8& V g_;7e4cAfe





@



 4UBB

yn

(Gf65

M








=

M










T

.



_ ` ! H+=aOB[[M?E(0.[m9p4E(2Pf[f[,Qffm9 ^sM9[n(2JGn['?


9



fi

3MfiuM%

^RU'*),+F'*+.6Q3/2RUC+),&('*<2/28:3RU'Q/<T38+TRU'*H0+,+,H3y-4382/2RN).105o38s)M3(<+I&YE-G&9<RU/2RUC+F&('*+,<MWL+FLRU5U5J'*&LPW
10'05N+,<<RU'*HORN)M3/+,H&(/2;*+.82LRN<+9WH0+.'*&(/+FDX 3<+./&YP),&('*<2/28:3RU'/< 3<+./&YE-G&9<RU/2RUC+I),&('*<2/28:3RU'Q/<
<& V +@&Yh/2;*+ V )M3'ID+@+,wQ10RUC935N+.'Q//&Z'*+.6Q3/2RUC+>&('*+,<Me



5

7


q

X "$n+*m.4ToI),&('*<2RN<2/+.'/I Z

 y fi;}]}   M}h	Ayn} F 
 y]fiM}  } _7  nY
.[oM
< Bi((*f[2(paim@a5  OfS9!p,=Epl,(njRU'*),&('*<RN<2/+.'Q/A5  } (H0+,HO1*),+,H
fm( JpP(0fo.f4_(aZ :(jZQ2(0:2@B2( d5
 &(/+P/2;43/3s^0?/2;43/CRN&(5o3/+,<3),&('*</28:3RU'Q/E&Y! V 3,XI<2/2RU5U5DG+PH0+,HO1*),+,HIY8& V
u
'*&(/ V 3/2/+.8<RU'*),+RN<J30(f[n({8+.-08+,<+.'Q/:3/2RN&('y&Y{K'*&ML5N+,HO6+H0+,HO1*).RUD05N+@Y[8& V e

e  /H0&+,<



}

y{M}hhM]

[MMM

E+,HO1*)./2RN&('FRU'FRN<+,<:<+.'Q/2Ro35U5UXi'*&(' V &('*&(/&('0RN)9e]H0HORU'06RU'OYn&(8 V 3/2RN&('F/&Zk)M3'T/282RU696+.83'*+.L
),&('*<2/28:3RU'/MW3'*H/2;1*<i)M3').8+M3/+3'*+.L CRN&(5o3/2RN&('7S<2RU'*),+I'*&(/2;0RU'06k)M3'DG+IH0+,HO1*),+,HY[8& V 3'
RU'*),&('*<2RN<2/+.'/K'*&ML5N+,HO6+D43(<+9W0-08+.CRN&(1*<H0+,HO1*)./2RN&('*<E38+@'*&5N&('06+.8C(35URNHeg_;43/JRN<JL;XiYn&(8
3'*H V &(8+Z6+.'*+.8:35 V &H0+.5N<\='*+fO/@<+,)./2RN&('*<BAfWRU/ERN<uR V -G&9<:<2RUD05N+l/&s&(D0/:3RU'8+,<105U/<@&YqY[&(8 V  )M3'
D+H0+,HO1*),+,HsY[8& V /2;*+uK'*&ML5N+,HO6+ED43(<+ERSj
 $[E
 4 Ij
 $$E
 4 E3(<RU/_L_3(<_/2;*+u)M3(<:+JYn&(8_3'*Hs2e
u&ML+.C+.8MWQ/2;*+'*&(/2RN&('s&Y),&('*<RN<2/+.'*).Xl)M3'DG+_/28:3'*<25o3/+,HRU'Q/&Px{zu|qeQx*&(8]'*+.6Q3/2RUC+J),&('*<2/28:3RU'Q/<W
/2;*+),&(828+,<2-&('*H0+.'*),+RN<!R VV +,HORo3/+9W3'*HZ8+.5URN+,<q&('-08&m+,)./2RN&('i<&(10'*HO'*+,<<]3'*H),& V -05N+./+.'*+,<<]LPe 8Me /Me
/2;*+l<+ V 3'Q/2RN),<> =/2;*+,&(8+ V `Afe  'Q/210RU/2RUC+.5UXW}3s^0? CRN&(5o3/+,<@3'*+.6Q3/2RUC+Z),&('*<2/28:3RU'Q/ ~SjRY3'*H
&('05UXRY}/2;*+RU'OYn&(8 V 3/2RN&('F8+.-08+,<+.'/+,HFDQX S RN<H0+,HO1*).RUD05N+uY[8& V /2;*+uRU'OY[&(8 V 3/2RN&('F8+.-08+,<+.'/+,HFDQX
Ze





a

fi



p



U



 U

 V M? n(U9BiGnQ9['?(F(0.[m9p4
"$  *H4 j$4*Bj$E4 j$  4>=
hy|MyfV }
9hOf b!pPOj}aQff;:
N(Glj$ j4PoPO>U(n(.(fZUs:,M.n92T$iQob}R5



d

U

F

%&('*<2RN</+.'*).Xl8+.5o3/2RUC+J/&@-G&9<RU/2RUC+),&('*<2/28:3RU'Q/<)M3'\D++f-05o3RU'*+,HLRU/2;ix}zu|qW/28:3'*<5o3/2RU'06 -08&~
2+,)./2RN&(' ]RU'Q/&@3'*&(/2RN&('Z&Y 5N&(69RN)M350<210D*</2RU/210/2RN&(' E=$%;*+.RU'1069'0RN+.8MW*`Mb9b9A7DG+./L+,+.'/2;*+]Y[&(8 V 105o3(<
3(<<&).Ro3/+,H/&F698:3-0;*<ert+\)M35U5_3'!B*Bf[[[[n(kY[8& V j$[4uRU'/&yj$ J4@3F<10D*<2/2RU/210/2RN&('&Y
/+.8 V <]&Y}j
 $E4{DQX/+.8 V <&Y7j
 $ J4!<1*);\/2;43/),&('*<2/:3'Q/<&Y[
 $[4q38+K+.-0/]RU'QC9382Ro3'Q/3'*HWYn&(8]3'QX
3/& V 6$ D * FtFtF * G 4&Y]j
 $[4fW*/2;*+.8+@RNd
<   \_<21*):;F/2;43
/   $
 $ D 4* FtFtF *
 $ G 4y4RN<3'3/& V &Yqj
 $ J4fe
g_;*+EYn&(5U5N&MLRU'06i-08&(-G+.82/Xs;*&(5NH0<





`



K







`

`







?. :a2m,,[[9f2( $
QM<]GBy(!B*Bf[[[O[[(B2(
yn
j$ J465  :fZs9
o@a9B\(9,(fC=qOl9?fB,Z( .9W5





j$[4$



2MmWJ|+./D+@3>-08&2+,)./2RN&('TY[8& V /& ke!x*&(8J+M3();TC9382Ro3D05N+b]&Yhj$E4fWO5N+./D+/2;*+u10'0RNw1*+
6+.'*+.82RN)),&('*),+.-0/i'*&H0+<21*);/2;43/8]" [$	64fW/2;*+.'g$M])4" j$	$	W4y4fe+,).RU-08&)M35U5UXW_-08&MCRNH0+,H
/2;43/
RN<RU'I'*&(8 V 357Yn&(8 V W*/2;*+l3-0-05URN)M3/2RN&('Y[8& V ),&('*),+.-0/u'*&H0+,<&Ya
 /&),&('*),+.-0/'*&H0+,<&Y kW
 /&>/2;*+u'*&H0+ba
 <21*);T/2;43/,$$ j$	W4y4a
" [$	q
4 RN<3>-08&2+,)./2RN&('sY8& V 
 /& eu
 &(/+
V 3-0-0RU'06\+M3();7
/2;43/MW010'05N+,<<
RN<RU''*&(8 V 35Y[&(8 V W  RN<'*&(/J10'0RNw1*+.5UXFH0+f*'*+,HFL;*+.'yj$	  
4 RN<3Z),&('*<2/:3'/Me



q

;



@

 

U

(



 V`!c?Mn(U9BE(0.[m(4  OH
 !B*Bf[[[[n(Tfm9j$ JPN L 44$
u	{3
  (2B4o
j$[4B.M.n92Z9![(4a9)j9fGQ2T$s(!$f0B.[[O[n(f2( j$ C4E4$l[$[465


U

fi M]|9M.tM=uwuMM3
 F

'*&(/2;*+.8]D082RNHO6+)M3'D+D010RU5U/]1*<2RU'06>82105N+,<Me  '*H0+,+,HWO3E698:3-0;<:3/2RN<m4+,<3E-&9<2RU/2RUC+J),&('*<2/28:3RU'/

RY03'*H&('05UX@RYmW),&('*<2RNH0+.82RU'063(<}3J82105N+9W35U5O3-0-05URN)M3/2RN&('*<{&Y|&('r-08&HO1*),+3J698:3-0;+,w10RUC(35N+.'/

/&8Zez8MW V &(8+P<2-+,).R4)M35U5UXG

 }

 



 =(*BnQffp
yn
 }  `!?M[99fFTOB[[M?I90f[2(4
BG n9[n(tm (:(2(pF$Eta2M(0:B(2B4IG9y,M?(Nf4_$o5








ISfN=0

2MmW|7+./ D+3i),&('*<2/28:3RU'Q/P3'*HJDG+Z3s^0?<21*):;y/2;43/[<:3/2RN<m4+,< e  Ya N RN<E3\-08&2+,)./2RN&('
Y[8& V
=[),&('*<2RNH0+.8+,H
JPN L RU'Q/&8WO5N+./1*<),&('*<RNH0+.8/2;*+698:3-0;bG&(D0/:3RU'*+,HTDX/2;*+P3-0-05URN)M3/2RN&('&Y
'*&ML3(<3\82105N+A&('J
 3(),),&(8HORU'06s/&8 N e|+./1*<J'*&LD010RU5NH/2;*+@Yn&(5U5N&MLRU'06s-08&2+,)./2RN&('  Y[8& V  
RU'Q/&7Z
 Yn&(8+M3():;'*&H0++GW0t$  4d
" TRY&TDG+.5N&('06<u/&Z
 &(/2;*+.82LRN<+9WsRN<E3\),&(-X&Y3'*&H0+&Y
XJ D L W3'*HZRY)T
 RN<q&('*+J&Y/2;*+-08&2+,)./2RN&('*<!Y[8& V RU'Q/&k
 /2;43/]+fO/+.'*H0< N W9L+J;43MC+  t$ 4a"Qt$ jf4 e
g_;*+.'B  RN<>3i-08&m+,)./2RN&('j&Y  RU'Q/&gZ
 W}3'*Ht<2RU'*),+o /282RUCRo35U5UX-08&2+,)./<@RU'Q/&  W/2;*+.XS38+Z/2;1*<





T



+,w10RUC(35N+.'/Me
g_;0RN<@-08&C+,<@/2;*+C -4382/P&Y-08&(-+.82/XvOelx*&(8@/2;*+C -4382/MWL+Z1*<:+Z/2;*+lY[&(5U5N&LRU'06F-08&(-G+.82/XW
-08&MC+,HtDQXS%&(69RN<3'*H?E10RU'435NH0&j=m`Mb9b9vAfe  'S/2;*+.RU8@-08&(-G+.82/X=-08&(-7eZs&Y/2;*+.RU8@-43-+.8BA/2;*+\^0?E<
),&('*<2RNH0+.8+,H38+>),&('0'*+,)./+,HI698:3-0;*<MW0D010//2;*+E-08&&Yh;*&(5NH0<Yn&(8'*&('),&('0'*+,)./+,HI698:3-0;*<e

 q !r

t uvu{}


 :H
 }(apf6 $[4(2][y .' ?9Ufa
yn f 
u
] }${M] 
 ,
 B2(a(aqf0n9mBaZN 1oEa9]2(G(4_OfyB6$[4a"YRT5UOfSOf)j(pf>iYn&(5NHORU'06
fm(  $FB6$[4>=J5pW5sGmmM2,[n( yB2( 4$TfL$[4>=fO.y9OZBf[fn,[[9km $
aMBm@B6 $[4PoPO>nQf4[[	 :gN ,(>S ?. :saMQ1
 ]m@B6 $[4>= $M])4"]R5




$



^10-0-&9<+'*&Lq G~$CRN&(5o3/+,< e^RU'*),+),&('*<2/28:3RU'Q/CRN&(5o3/2RN&('tRN<>H0+f*'*+,HLRU/2;t8+,<2-+,)./@/&T/2;*+
RU828+,HO10'*H*3'Q/Yn&(8 V &Y!3698:3-0;7W*L+>)M3'),&('*<2RNH0+.8MW*LRU/2;*&(10/5N&9<<J&Yh6+.'*+.8:35URU/XWa/2;43/YRN<RU828+,HO10'O~
H*3'Q/Me_rt+H0+.'*&(/+PDXY/2;*+P698:3-0;S&(D0/:3RU'*+,HIDXF/2;*+3-0-05URN)M3/2RN&('S&Y
=n36Q3RU'7WG),&('*<2RNH0+.8+,H'*&L
3(<3P82105N+Aq&(7
' 3(),),&(8HORU'06l/E
& !e{rt+-08&MC+/2;43/ A  +,w10RUC(35N+.'//r
&  5N+M3(H0<]/&l3P),&('Q/28:3(HORN)./2RN&('7e
Y   RN<]+,w10RUC(35N+.'/]/r
& ZW/2;*+.'i/2;*+.8++fORN<2/<3E-08&2+,)./2RN&('iY8& V   RU'Q/
& Zeh'*H\<RU'*),Y
+ RN<3'

RU828+,HO10'*H*3'Q/E<210D0698:3-0;&a
Y   WO/2;*+.8+P+fORN<2/<3u,(9p Y[8& V   RU'Q/Z
&  =-08&(-G+.82/XFAfe%&('*<2RNH0+.8
'*&ML   /2;*+I-08&2+,)./2RN&('Y[8& V
/&  H0+f*'*+,H3(<Yn&(5U5N&MLJ<MIY[&(8i3'X'*&H0
+ ]&Y JON L 
W   $M])4C0
$	$M]4y4fW&(/2;*+.82LRN<:+Z5N+.Y
/ ]  D+>/2;*+),&(-X&a
Y ]jRUB
'   WGL+Z;43,C
+   $M]4
0 $M]  4fe^RU'*),+lY[&(8@35U`
5 ]tRU'
< !ehg_;0RN<),&('/28:3(HORN)./<_/2;*+;X-&(/2;*+,<2RN< AG~$CRN&(5o3/+,< :ehg_;1*<
JON L W $	$M]4y4"Q$M])4fW 4+f/+.'*H0d
  RN<'*&(/+,w10RUC935N+.'Q/J/8
& Ze







 













fi

@



4

 }
 ,9[p'<BJOf[M?E90f[2(4 r=}OfI(:(2B4\TEm kn!mQff'?9[[9
yn eh p[
mHp>3.M?(Nf4_$o5


4

F

2MmW J|+.
/ "p N * FtFtF *H G D+@3m rn,~H0+.82RUC(3/2RN&('I&Y`eqx08& V -08&(-G+.82/XsvOWO+M3(); mWI[\\ K W
RN<J+,w10RUC(35N+.'/J/&  S D WO/2;1*<JDQXs/28:3'*<2RU/2RUCRU/XW4RN<J+,wQ10RUC935N+.'Q//& Ze
<2RU'06S<&(10'*HO'*+,<<3'*H),& V -05N+./+.'*+,<<&Y/2;*+i H0+,HO1*)./2RN&('7W]3'*Hk-08&(-+.82/2RN+,<\v3'*HW!&('*+
&(D0/:3RU'*<J/2;*+@Y[&(5U5N&LRU'06\8+.5o3/2RN&('LRU/2;x{zu|jH0+,HO1*)./2RN&('7e

p





F 



 Ofyj(o.}Y>B0f9
hy|Myp
h  {q ?Mn(BIOB[[M?y(0.[m(4
j$d4*Bj$[4*Bj$ C4 Ij$  4P(aG9j$4*B[$[4 I[$  4>=9h0f2uj$ C4uoEO@[2(0f[[(Sm
(*BnQf2I>BU5

U 



;



U

@

fi

3MfiuM%

g_;0RN<s/2;*+,&(8+ V )M3'DG+8+fY[&(8 V 105o3/+,HRU'/+.8 V <T&Yl3DHO1*)./2RUC+yRU'OY[+.8+.'*),+=1*<2RU'06kRU'Yn3()./sRU'O~
HORU8+,)./s3DHO1*)./2RN&('7W<+,+9WYn&(8+f03 V -05N+9W_&('*&(5URU6+9WP`Mb9b9Afe  '*H0+,+,HW69RUC+.'3D43()K698&(10'*H/2;*+,&(82X
 $d
 4*Bj
 $[43'*H3'&(D*<+.82C93/2RN&('%" ]j$ E4fWaCRN&(5o3/+,<
R/2;*+.8+TRN<\3'3DHO1*)./2RUC+
 " j
+fO-05o3'43/2RN&('IYn&(8E&Yh/2;*+uY[&(8 V \WOL;*+.8+9RN<3ZY[&(8 V 105o3ZDG+.5N&('069RU'06/&\x}zu|a$ * 4fe

}  q

]$A{M}h{



 U


q B` < K




y $

U 

l

g_;*+-08&(D05N+ V H0&+,<i3j69RUC+.'698:3-0;<:3/2RN<mY[X369RUC+.'),&('*<2/28:3RU'Q/
RN<i),&~c  ~),& V -05N+./+yRYP/2;0RN<
),&('*<2/28:3RU'/RN<'*+.6Q3/2RUC+t=[<RU'*),+iL+ V 1*<2/);*+,):K/2;*+T3D*<+.'*),+T&Y-08&2+,)./2RN&('aAfW!D010/ZD+,),& V +,< _ ` ~

),& V -05N+./+@Yn&(83l-&9<2RU/2RUC+P&('*+\= _ ` RN<),&~c 2  Afe


p

q

K$72D*4tp _

< K

   _
_
aN.> >9p90f[2(4(Pn9[M?R5
hy|Myk 

B`y $ [ }



` !m(aN.bNmfGp]! H!:(r!


2MmWSrRU/2;*&(10/i):;43'06+&Y>),& V -05N+fORU/XWJ&('*+)M3'),&('*<2RNH0+.8s/2;43/\RN<i),& V -G&9<:+,H&Y>&('05UX&('*+
-&9<2RU/2RUC+i),&('*</28:3RU'Q/MWq<:3MX eIx{RU8<2/8+,)M35U5/2;43/ZH0+,).RNHORU'06SL;*+./2;*+.8\3^0?  <B3/2RN<m4+,< RN<lH0&('*+
&('j/2;*+RU828+,HO10'*H*3'Q/lYn&(8 V &YHZ
 eTrt+<;435U5]),&('*<2RNH0+.8l/L&L3MX<l&YJRU'Q/+.698:3/2RU'06y/2;0RN<>Yn3()./RU't/2;*+
),& V -05N+fORU/XF&Y{_ 7
4]e_z'*+@L3MXTRN</&\3(<<21 V +E/2;43/J/2;*+ERU828+,HO10'*H*3'/Yn&(8 V &Ya
 RN<


K$ 2D*



),& V -010/+,HD+fY[&(8+Z/2;*+Z),&('*<2RN</+.'*).Xy):;*+,)Keg_;0RN<P)M3'DG+3():;0RN+.C+,HLRU/2;j3s'Q1 V DG+.8>&Y_)M35U5N<@/&I3
-08&2+,)./2RN&('S&(8:3().5N+5URU'*+M38ERU'/2;*+l<2R M+l&Y=[1069'0RN+.8MW!`Mb9b9vAfeu10/MWG<RU'*),+>L+>;43MC+/2;*+.'S/&s<&(5UC+
3\Y10'*)./2RN&('y-08&(D05N+ V =[),& V -010/+/2;*+lRU828+,HO10'*H*3'/EY[&(8 V &
Y PAJRU'*<2/+M3(H&Y_3H0+,).RN<2RN&('y-08&(D05N+ V =RN<
RU828+,HO10'*H*3'Q/ AfWL+l-08+fYn+.8E/&RU'/+.698:3/+ZRU828+,HO10'*H*3'*).XRU'Q/&T/2;*+l),&('*<2RN<2/+.'*).X);*+,)K/2;*+.'7W4Yn&(8
3-08&m+,)./2RN&(
'  N Y8& V /2;*+>/282RU696+.8@&Y RU'Q/
& ZWG/2;*+-08&m+,)./2RN&('Y[8& V /7
& L+>5N&&(KFYn&(8H0&+,<
'*&(/'*+,),+,<:<:382RU5UXF+f/+.'*H0H
<  N W*D010/+fO/+.'*H0<J/2;*+),& V -G&9<RU/2RN&('&Y]3Z-08&2+,)./2RN&('IY[8& V RU'/&&('*+P&Y
RU/<J<210D0698:3-0;*<l=-G&9<:<2RUD05UXs+,w1435/& RU/<:+.5YfA_3'*
H  N e
x{RU8<2/MW>G 7
4 D+.5N&('06<y/& _` <2RU'*),+RU/y),&(828+,<-G&('*H0</&/2;*+5o3'0691436+G "

mW] d_ _   $M]*_ *_  4>nQWL;*+.8+ ]+.'*),&H0+,<3'RU'*<2/:3'*),
+ $k* E4&Y\/2;*+k-08&(D05N+ V 3'*H
D
D
$M]*d_ D *d_  4 i  R
 _ D +.'*),&H0+,<3l-08&2+,)./2RN&(
'  N Y8& V XJPN L RU'Q/Z
& 3'*
H _  +.'*),&H0+,<3l-08&2+,)./2RN&('
Y[8& V RU'Q/&>&('*+&YRU/<<210D0698:3-0;*<3'*Hs3E-08&2+,)./2RN&(' TY[8& V RU'/k
& <Me /M`
e  JON L "Q ) N e
u&(/+E/2;43/JR
Y RN<RU'FRU828+,HO10'*H*3'Q/Yn&(8 V WO/2;*+.g
' RN<3'310/& V &(82-0;0RN< V e
u&MLPW@5N+./1*<),&('*<2RNH0+.8/2;*+-08&(D05N+ V ~ 69RUC+.'3DG&&(5N+M3'Yn&(8 V 105o3WP3'*H3-4382/2RU/2RN&('

m *9  ni&YRU/<@C(382Ro3D05N+,<W7RN<@RU/@/2821*+/2;43/EYn&(8>3'QXS/28210/2;3(<:<2RU69' V +.'Q/@Yn&(8@/2;*+ZC9382Ro3D05N+,<PRU'
D
D
/2;*+.8+>+fORN<2/<u3Z/28210/2;y3(<<RU69' V +.'Q/JYn&(8J/2;*+>C(382Ro3D05N+,<RU'B  <Me /Me@RN<J/2821*+ Sg_;0RN<-08&(D05N+ V RN< _ ` ~

),& V -05N+./+9W<RU'*),+ZRU/<@),& V -05N+ V +.'Q/:382X  RN<P<2;*&ML'/&TD+ ` ~),& V -05N+./+DQXt^/&)K V +.X+.8i=m`Mb99Afe

4]W*L+E1*<+P3l8+,<2/282RN)./2RN&('&Y{/2;0RN<
 'T&(8H0+.8/&ZD010RU5NHI3l-G&(5UX'*& V Ro358+,HO1*)./2RN&('I/&Z 7p
-08&(D05N+ V /& K ~
% ux*<MWOR$e+9e!),&('(m10'*)./2RN&('*<&YhHORN<[10'*)./2RN&('*<JLRU/2;3/ V &9<2/ K 5URU/+.8:35N<-G+.8J).5o31*<:+9e!|7+./
1*<u)M35U5  ~ F1
ff &E /2;*+><2-+,).Ro35})M3(<+>L;*+.8+~RN<E3  ~
% ux_W*RU'S&(/2;*+.8L&(8H0<@3'RU'*<2/:3'*),+l&Y  ~^!g@e

g_;*+.'  ~ F1
ff &E RN<J35N<& _ ` ~),& V -05N+./+9e  '*H0+,+,HW0RU'F/2;*+@<:3 V +E-43-+.8=[g_;7eOd*eU`AfWa^/&)K V +.X+.8<2;*&LJ<


/2;43/  LRU/2;8+,<2/282RN)./+,H/&3  ~HORN<n10'*)./2RUC+i'*&(8 V 35]Yn&(8 V =  ~b
 uxqAE8+ V 3RU'*< ` ~),& V -05N+./+9e

^RU'*),+l/2;*+>'*+.6Q3/2RN&('t&Y3  ~b
 uxRN<E3  ~
% ux_WaRU/Yn&(5U5N&MLJ<E/2;43/u/2;*+l),& V -05N+ V +.'/:382X-08&(D05N+ V ~

LRU/2;B8+,<2/282RN)./+,HI/&\3  ~
% uxkRN< _` ~),& V -05N+./+9e

|7+./]1*<!'*&ML8+,HO1*),+  ~ F1
ff &  /&@ 7p
4]eqg_;*+/28:3'*<2Y[&(8 V 3/2RN&('i1*<+,HZRN<!C+.82X<2R V R~

5o38q/&@/2;*+&('*+_Y8& V  ~^!g/&@}   k=-08&&Y7&Y/2;*+,&(8+ V AfWQRU5U5U1*<2/28:3/+,HRU'x{RU6*e{d*eh|7+./
D+3'sRU'*<2/:3'*),+&Y  ~^!g@eO|7+.
/ $r
 43'*HFo
 $r
 4!D+/2;*+E^0?E<&(D0/:3RU'*+,HsDQX/2;*+/28:3'*<mYn&(8 V 3/2RN&('
H0+,<).82RUD+,HZRU'/2;*+_-08&&Y&YGg_;7eOehg_;*+),&('*<2/28:3RU'/ o$r
 4"ff$$o
 $r
 4*)
H $t  4y4}RN<!&(D0/:3RU'*+,HDQX3(H0HORU'06
3u),&(5N&(8:3/2RN&('/&Po
 $k
 4fh35U5O8+.5o3/2RN&(''*&H0+,<h&(D0/:3RU'*+,HZY[8& V ).5o31*<+,<J='*&H0+,<h/X-+,H $A{3'*HZ35U5O'*&H0+,<





>~

6





K$ 2D*





K AD*

>~

>~

K AD*
Kv { $





Y  

A

d7

fi M]|9M.tM=uwuMM3
 F

a

b

val

val

val

at

af

bt

c

val

bf

val

val

val

ct

cf

dt

2
1

C1

C1

C1

C1

C1

C1

1

C1

C2

C2

C2

a

b

c

d

val

val

val

val

val

df

av

bv

cv

dv

...

3

2
3

d

C2

C2

C2




C2

>~

1

2

2
3

C1

1

K7pAD*4

3

C2

x{RU69108+\`MO  0 3 V -05N+>&Y{/28:3'*<mYn&(8 V 3/2RN&('IY[8& V  ~ Fff1&E /&_7


 @


0 

6


&(D0/:3RU'*+,HFY[8& V C9382Ro3D05N+,<JRU'  =[),&('*),+.-0/'*&H0+,<J/X-+,H T&(8 T3'*HF8+.5o3/2RN&(''*&H0+,</X-G+,H  QA
38+@),&(5N&(8+,HFDXy`\=R$e+9e!D+.5N&('06\/&Z/2;*+@&(D05URU6Q3/2RN&('aAfe_z'*),+>36Q3RU'7W0;43,CRU'06).5o31*<+,<&Y}D&(10'*H0+,HI<2R M+
5N+M3(H0<P/&3T-G&(5UX'*& V Ro35q/28:3'*<mYn&(8 V 3/2RN&('7eTg_;*+\<2R V -05N+698:3-0
;  3'*H/2;*+\-G&9<2RU/2RUC+),&('*<2/28:3RU'Q/
-08+,<+.'/+,HRU'x{RU6*e7`Mi38+P&(D0/:3RU'*+,HY8& V /2;*+  ~^!gYn&(8 V 105o
3 $
`W4 J$

43'*H
/2;*+@-4382/2RU/2RN&('K D "Vm * n*)  "VmA* nQe
 3():;t/28210/2;t3(<<2RU69' V +.'/>&Y]/2;*+ZC9382Ro3D05N+,<@&Y@ <Me /Me+RN<E/2821*+Z'43/2108:35U5UX69RUC+,<>3i-08&2+,)./2RN&('
Y[8& V RU'Q/
& W3'*H8+,).RU-08&)M35U5UX=n3(<RU'*HORN)M3/+,HRU'/2;*+F-08&&Yu&Y@g_;7eqAfex01082/2;*+.8 V &(8+9W3'QX
/28210/2;y3(<:<2RU69' V +.'Q/Y[&(8/2;*+>C(382Ro3D05N+,<&YT D '43/2108:35U5UXT69RUC+,<u3Z-08&m+,)./2RN&('Y8& V XJON L RU'Q/Z
& W43'*H
8+,).RU-08&)M35U5UXeqg_;Q1*<MW/2;*+uwQ1*+,</2RN&(' RN<RU/]/2821*+u/2;43/Y[&(8_3'QXi/28210/2;T3(<<RU69' V +.'Q/Y[&(8/2;*+uC(382Ro3D05N+,<RU'
 D /2;*+.8+l+fORN<2/<u3\/28210/2;S3(<:<2RU69' V +.'Q/Y[&(8u/2;*+PC9382Ro3D05N+,<uRU'B  <Me /MeX RN</2821*+ RN<u+,wQ10RUC935N+.'Q/E/&
/2;*+@w1*+,<2/2RN&(' RN<_RU//2821*+E/2;43/_Y[&(8J3'QXs-08&2+,)./2RN&(
'  N Y8& V
& /2;*+.8+@+fRN<2/<3l-08&2+,)./2RN&('
JPN L RU'Q/8
Y[8& V RU'Q/Z
& +fO/+.'*HORU'08
6  N :e
u&(/+l/2;43/@/2;0RN<E8+,HO1*)./2RN&('RN<E5N+,<<@<2/28:3RU69;Q/mYn&(82L38Ht/2;43'/2;*+l&('*+ZL+l-08&(-G&9<+,HSRU'=[36+./>
1069'0RN+.8MW499O`AfW0D010/JRU/JLRU5U5D+E1*<+,H3(<3lD43(<2RN<_Yn&(8/2;*+@-08&&Y!&Y!g_;7e7`MOe

A K



q



!



;

u	{3

0+  U( +T





l

AG





1 (OM[[(_o _` ! (aN.W5


h b"]u 

s 

fi#

 ZX&QXdpEdo&

' -08+,<:+.'*),+&Y),&('*<2/28:3RU'Q/<W7/2;*+l/L&FKRU'*H0<E&Y82105N+,<MWRU'OY[+.8+.'*),+Z82105N+,<9
y
H0+f*'*+@/L&i35U/+.82'43/2RUC+ V &H0+.5N<e
f 	ff
 y fi;}]}$k{%}

3'*HS+.C&(5U10/2RN&('t82105N+,<
D]W

uA{M}h

' 2DhWRN<<+,+.'3(<u/2;*+>RU'0RU/2Ro35hL&(825NHW8&&(/E&Y3-G&(/+.'/2Ro35U5UXRU'O*'0RU/+l/28+,+&Y-G&9<<RUD05N+>L&(825NH0<MW

3'*HoDH0+,<).82RUD+,<E/2;*+Z-G&9<:<2RUD05N+Z+.C&(5U10/2RN&('*<@Y[8& V &('*+ZL&(825NHS/&F&(/2;*+.8<Melg_;*+H0+,HO1*)./2RN&('t-08&(D05N+ V
3(<2KO<_L;*+./2;*+.8/2;*+.8+@RN<EOI2>(0fo.f4+
 9](BU!fm( $s8
 9]9BU,9[ppS :le

K* { $

}   .
 "#$na
 *)Da*m.4P+nbXd=!9alU,} >k}154 (S:
  D
Q 29O:@fm( POfo>(*D!mQff'?9[[9FB" N * F6F6F * G B0fI9M=4,(fiIo\\ K =+$ ,*m4
pP:(0Bpf.4(GZ9t:2(0:2@f2(q G 5


 y fi;}]}



 'hWy-08&MCRNH0+,HLRU/2; RN<]3*'0RU/+JH0+,<).82RU-0/2RN&('s&Y3E-&(/+.'Q/2Ro35U5UXRU'O*'0RU/+JL&(825NHW/2;43/q;43(<
/&TD+),&('*<2RN<2/+.'Q/Mei-0-05UXRU'063s82105N+/&I)M3't).8+M3/+\RU'*),&('*<2RN<2/+.'*).XW}D010/3iY1082/2;*+.8l3-0-05URN)M3/2RN&('
&Y3F82105N+ V 3,Xt8+,<2/&(8+i),&('*<2RN<2/+.'*).XeF|7+./l1*<@Yn&(8 V 35UR M+i/2;0RN<P'*&(/2RN&('&YP:(0Bpf.aL :y2B.$(29[[94e

6

$-

fi

3MfiuM%



U

^10-0-&9<+Z/2;*+.8+ZRN<P
3 G~$CRN&(5o3/2RN&('t&Y3s-G&9<RU/2RUC+l),&('*</28:3RU'Q/ RU'j/2;0RN<ECRN&(5o3/2RN&('O$ b*34uRN<@<:3RNH
/ &TD+~g!B.$(mfUiRY/2;*+.8+\+fORN<2/P3'\~H0+.82RUC93/2RN&('Y8& V RU'/&3I^0?
3'*Ht3s-08&m+,)./2RN&('
Y[8& V
RU'Q/&FRU828$ J4@<21*):;t/2;43/>/2;*+\-08&m+,)./2RN&('   Y&Y/2;*+/282RU696+.8&Y RU'/&IRU828$ J4@)M3'tD+
+fO/+.'*H0+,HI/&i3\-08&m+,)./2RN&('y&Y 3(<E3ZL;*&(5N+9eg_;*+PCRN&(5o3/2RN&('&Y3'*+.6Q3/2RUC+),&('*<2/28:3RU'/u)M3''*+.C+.8
D+Z8+,<2/&(8+,Hr
e &(/+Z/2;43/P/2;*+~~$8+,<2/&(8:3/2RN&('j)M3'j).8+M3/+Z'*+.LCRN&(5o3/2RN&('*<MW7/2;43/ V 1*<2/@/2;*+ V <:+.5UC+,<
D+E-08&MC+.'B~$8+,<2/&(8:3D05N+9e







K 2D*

 ! U

Kv {$ 


4 {%} \ 

 y fi;}]}    \
<2RN<2/+.'/ >
= .(I(:J}
 9l(Cg!mQff'?f2(
S? .:k`!cM? n(U9[[9Sm
 =+$ Y*34@p,g!2B.$(2QfNW5 
(*Bpff4_(aZ(jlQ29O:@fm( n$ a)* 7465

Integer: Zero


@

Integer

n X
Y
 " $n+
 *)
 *m.
 4pi),&('O~
 =,(S?fS:k:(0f[2(4
a
i =.(
}9lQ(OB2@fm9  p



successor

<R V -05N+@698:3-0;





Integer

),&(5N&(8+,Hy^0?

x{RU69108+\`  %&('*<2RN<2/+.'*).XTRU'FDh
% &('*<2RNH0+.8ZYn&(8ZRU'*<2/:3'*),+F3y@),&('/:3RU'0RU'06t/2;*+I^0? RU'x}RU6*e_`  Wq+fO-08+,<<2RU'06S/2;*+T+fORN<2/+.'*),+

&Y@/2;*+'1 V D+.8TOWJ3j),&('*<2/28:3RU'Q/F3'*H3t82105N+9W_DG&(/2;8+.-08+,<+.'Q/+,HDX/2;*+),&(5N&(8+,H^0? eg_;*+
),&('*<2/28:3RU'/l3(<<+.82/<P/2;43/J.9iS ?fS :4nf `=O.2ZQ.uT94nQ.  =B0:BB.(Tm qe  Y
/2;*+u82105N+ERN<3'I+.C&(5U10/2RN&('F82105N+9W RN<<+,+.'I3(<J3'sRU'*),&('*<RN<2/+.'Q/RU'0RU/2Ro35L&(825NHt=/2;*+.8+ERN<_'*&l<1*),),+,<<&(8
&YFRU
' PAP3'*Hj'*&(/2;0RU'06LRU5U5DG+iH0+,HO1*),+,HtY[8& V /2;0RN<@ue  Y/2;*+82105N+\RN<Z3'jRU'OYn+.8+.'*),+\82105N+9W{RU/<
3-0-05URN)M3/2RN&('yR VV +,HORo3/+.5UXF8+.-43RU8</2;*+P),&('*</28:3RU'Q/uCRN&(5o3/2RN&('7W4L;0RU5N+>).8+M3/2RU'06s3'*+.LRU'Q/+.6+.8MWa/2;43/
;43(<'*&<21*),),+,<<:&(8MW4/2;1*<u3\'*+.LCRN&(5o3/2RN&('7eJx{RU'435U5UXW+.C+.82XI),&('*<2/28:3RU'Q/ECRN&(5o3/2RN&('),&(105NHy+.C+.'Q/21435U5UX
D+E8+.-43RU8+,HIDQXF3Z82105N+P3-0-05URN)M3/2RN&('7W3'*HT/2;*+P@<2;*&(105NHFD+E-08&MC+.'y),&('*<2RN<2/+.'Q/Me
|7+./1*<]-&(RU'Q/&(10/]/2;43//2;*+J2 V &H0+.54RN<&(D0/:3RU'*+,H\Y[8& V 2\&(8]2DFL;*+.'FRN<+ V -0/XW03'*H
RN<J&(D0/:3RU'*+,HTY[8& V 2\=8+,<2-7e0D77AL;*+.'K =8+,<2-7eD{ARN<+ V -0/Xe
g_;*+CD7 V &H0+.5G),& V D0RU'*+,<DG&(/2;sH0+.82RUC(3/2RN&('T<):;*+ V +,<&Y/2;*+J2\3'*HD V &H0+.5N<M`
e &LPW
H0+,<).82RUD+,<3'RU'0RU/2Ro35JL&(825NHWRU'OYn+.8+.'*),+I82105N+,<&Y ),& V -05N+./+I/2;*+FH0+,<).82RU-0/2RN&('&Y@3'XL&(825NHW
),&('*<2/28:3RU'/<s&Yu+.C935U143/+I/2;*+),&('*<RN<2/+.'*).X&YP3L&(825NHWJ+.C&(5U10/2RN&('82105N+,<&YD/282X/& V 3K+3
),&('*<2RN<2/+.'/L&(825NH+.C&(5UC+>RU'Q/&i3\'*+.LPW4),&('*<2RN</+.'Q/&('*+9e_g_;*+PH0+,HO1*)./2RN&('y-08&(D05N+ V 3(<2K<JL;*+./2;*+.8E
)M3'+.C&(5UC+@RU'/&3),&('*<2RN</+.'Q/JL&(825NH<:3/2RN<mY[XRU'06l/2;*+P6&35$e

.



.

K* { 





   }
 Y{p(R VV +,HORo3/+CD7~+.C&(5U10/2RN&('\B2(C}
  CD7
 Of@)j(pfu9(!Q.BM?9[n(@fm(ffpa$b   (aZ(IR VV +,HORo3/+
Da!QffM?9[n(@B2(ff   4$
  5  CD~+.C&(5U10/2RN&('B2( o
 {
 $F8
 }p
   oiMy.*fa:imE}Y"V N * F6F6F * G "V 
B0ft9M =}.(9J
I \C\ K =Y$ ,*)g
 *m
 4o(*Bpff4u(a =}.(o
 I7\C\ K = Pp(Z2(n9
Ca
D !mS ?9 O[[9\B2(
  S D 5\_' ?(ft~b
n X
 " $na
 *)
 *R
D *m
 4>=_8
 }:(H0+,HO1*),+,HTf2( 
OfpP9ss
D !mS ?( O[n(IB
 "p N * F6F6F * G B0f9h :(jZQ2(0:2@B2( $ G *)7
 465

 y fi;}]}











r;*+.'KD" =8+,<2-7eF" AfW0&('*+P&(D0/:3RU'*<J/2;*+@2\ V &H0+.5=8+,<2-7ehDAfe


fi M]|9M.tM=uwuMM3
 F

q

f 

7

M}h	Ay}

 }

2\

{%}

Kv { $
K AD*

MMM

g&/28:3'*<25o3/+G   RU'5N&(69RN),<MWJ3<2/:382/2RU'06-&(RU'Q/T),&(105NHDG+/&j+fO/+.'*H/2;*+5N&(69RN)M35
/28:3'*<25o3/2RN&('&YE 7p
4
 69RUC+.'RU'g_;7e]/&j3y/28:3'*<25o3/2RN&('&YEG 7
4]e
u&ML+.C+.8MW4/2;*+EYn&(5U5N&MLRU'06/2;*+,&(8+ V -G(& RU'/<&(10/J/2;*+E5UR V RU/:3/2RN&('*<u&Y{/2;0RN<3-0-08&3();7e

p

K$ 2D*

u

4 EnbXY5p 0f2u)j(pfj}YB0fZ9aj$d4*Bj$n4*Bj$t4*
hy|My
 .*V"ffn$ +)* gm* 
j$p4
[$  4t(aa@[$4*Bj$n4*Bj$t74 j$  4>= 9hOf[$p.4pyO[m(*BU9[[9m0
(*f[2(paZm90BnQf2(fNB>
= Ofo>a90Bpffac5P9S?(f>=JO\(?.:Mp],(
M
yOQffm9h(,W5





2MmW irt+i*8<2/Z-08&MC+T/2;*+s-G&9<RU/2RUC+i-4382/&Y/2;0RN<Z/2;*+,&(8+ V e  YJ/2;*+.8+F+fORN<2/<Z<21*):;3698:3-0
;  W
/2;*+.'=[g_;7ehdA>/2;*+.8+TRN<\3$tlS.4~H0+.82RUC93/2RN&('=[),&('*<2RNH0+.82RU'06j/2;*+F),&(5N&(8+,H698:3-0;*<\&Y3(<82105N+,<BA
 " N * F6F6F * G <21*);y/2;43j

/ b-08&2+,)./</
&  G eu^+,+/2;43j
/  G )M3'0'*&(/D+lH0+,HO1*),+,HIY[8& V $n+
 *)7
 4fW
&(/2;*+.82LRN<7
+   L&(105NHk35N<&DG+iH0+,HO1*).RUD05N+iY8& V $na
 *)7
 4fe|7+./l1*<l),&('*<2RNH0+.8>/2;*+*8<2r
/  Y8& V /2;0RN<
H0+.82RUC93/2RN&('/2;43/sRN<s'*&(/sH0+,HO1*).RUD05N+yY[8& V $na
 *)7
 4feg_;*+.p
'  >RN<s&(D0/:3RU'*+,HY[8& V  S D =n3j698:3-0;
\~H0+,HO1*).RUD05N+FY8& V !ADQX3-0-05UXRU'06382105N+
' !e^RU'*),g
+  S D RN<
i Yn&(5U5N&MLRU'06k3-08&2+,)./2RN&(
H0+,HO1*).RUD05N+Y8& V $n+
 *)
 4fW/2;*+.'/2;*+.8++fORN<2/<T3698:3-0; ~H0+.82RUC(3D05N+Y[8& V <1*);/2;43
/  S D
-08&2+,)./<@RU'Q/& ke|+./@1*<@)M35U
5   <21*):;j3i-08&m+,)./2RN&('7W{3'*H),&('*<2RNH0+.8@/2;*+Z-08&m+,)./2RN&(B
'    "   H
&Y/2;*+l;X-&(/2;*+,<2RN< /282RU696+.8>&Y/2;*+Z82105N+ ),&('*<2/28:3RU'Q/
RU'Q/& ke@rt+Z'*&ML;43MC+Z/&s-08&MC+Z/2;43/\`A
  ~$CRN&(5o3/+,< W43'*HA/2;0RN<JCRN&(5o3/2RN&('IRN<'*&(/X\~$8+,<2/&(8:3D05N+9e^10-0-&9<+\`A&(8ARN<_Y$35N<+9e!g_;*+.'
/2;*+.8+L&(105NH+fORN<2/q3698:3-0;  ~H0+.82RUC+,HlY8& V
<1*);/2;43
/    )M3'ZDG++fO/+.'*H0+,HZ/&E3-08&2+,)./2RN&('
_ &Y 3(<J3>L;*&(5N+ERU's/2;*+uRU828+,HO10'*H*3'/Y[&(8 V &Y g[e!g_;0RN<_RN<3D*<2108HW0<2RU'*),+ _ RN<3-08&m+,)./2RN&('I&Y
 hRU'3Z698:3-0;K~H0+.82RUC(3D05N+@Y8& V e
g_;*+Z),&(10'Q/+.8+f*3 V -05N+\-08+,<:+.'Q/+,HSRU'x{RU6*e{`.dTRN<E<21 ).RN+.'/@/&i-08&C+Z/2;*+Z'*+.6Q3/2RUC+Z-4382/@&Y]/2;*+
/2;*+,&(8+ V e



(

F

0





1

t

O
  

A



T

2

s

t






t

t

r

F



1

82105N+ 



1

F

r

-&9<2RU/2RUC+@),&('*<2/28:3RU'/

698:3-0;

x{RU69108+\`.d*!),&(10'/+.8+f03 V -05N+/&g_;7e4b



 /RN<uR VV +,HORo3/+Z/&T);*+,):K/2;43/@+.C+.82X698:3-0;y/2;43/@)M3'SD+om  * rn,~H0+.82RUC+,HyY8& V  )M3't35N<&
D+[m  n,~H0+.82RUC+,HsY[8& V e!&L+.C+.8MW0/2;*+-08&m+,)./2RN&('F&Y/2;*+/282RU696+.8J&Y RU'Q/&l/2;*+10'0RNwQ1*+u'*&H0+&Y
H0+f*'*+,<3ZCRN&(5o3/2RN&('&Y /2;43/LRU5U57'*+.C+.8JD+E8+,<2/&(8+,He



$



r +@LRU5U5}<2/21*HOXTRU'I/2;*+@'*+fO/J<+,)./2RN&('k=[g_;7e7`9`AJ3Z-4382/2RN).105o38)M3(<+>&Y{82105N+,<L;*+.8+@/2;*+>),&('C+.8<+
t
&Y!g_;7e4blRN</2821*+9e

 	     )  
    | 
p   8q  <  Dh  DK*}{$Sp!,fZM!Q2,[fU5+X9JG
2D*4(GP2\*|(2[f;:aQ.[QQfNW5
f  Y}hy|Mh{
hy|My

^ 


  hy

AA |{Ay

y ] fiM}

y $ [}





y



fi3MfiuM%



2MmW lD7RU'*).5U1*H0+,<@2 /2;Q1*<@2Da~H0+,HO1*)./2RN&('RN<E'*&(/@H0+,).RNH*3D05N+9er;*+.'j RN<EH0+,HO1*).RUD05N+ZY[8& V
 W]3D08+M3(HO/2;O~n*8<2/\<+M38):;&Y/2;*+s/28+,+F&Yu35U5H0+.82RUC(3/2RN&('*<lY[8& V Wq+M3();698:3-0;D+.RU'06);*+,):K+,H

Yn&(8P),&('*<2RN<2/+.'*).XW{+.'*<2108+,<P/2;43/k G RN<@Y[&(10'*HRU't*'0RU/+/2R V +9ex*&(8>\!W7L+<2;*&L/2;43/>):;*+,)KRU'06
),&('*<2RN<2/+.'*).XsRN<_/282105UXs10'*H0+,).RNH*3D05N+9e]|7+./JD+@3@L;*+.8+u),&('Q/:3RU'*<3l-&9<2RU/2RUC+E),&('*<2/28:3RU'/ 9Q
3'*Hi3P'*+.6Q3/2RUC+),&('*</28:3RU'Q/ S WQD&(/2;LRU/2;T3's+ V -0/X/282RU696+.8Meqx*&(8-08&MCRU'06l),&('*<2RN</+.'*).XW&('*+;43(<
/&i-08&MC+Z/2;43/ SP  $n+
 *)
 4fW3'*H/2;*+35U6&(82RU/2; V H0&+,<u'*&(/E'*+,),+,<<:382RU5UX<2/&(-yRU'y/2;0RN<u)M3(<:+T=pY[8& V
<+ V R~H0+,).RNH*3D0RU5URU/X&YPH0+,HO1*)./2RN&('RU'TAfeg_;*+<:3 V +I;*&(5NH0<Y[&(8/2;*+),& V -05N+ V +.'Q/:382X-08&(D05N+ V
=-08&MCRU'06RU'*),&('*<RN<2/+.'*).X0A_/:3KRU'06 Q RU'*</+M3(HI&Y S W*;*+.'*),+@/2;*+@10'*H0+,).RNH*3D0RU5URU/Xe



@

.

!

6





u<s36+.'*+.8:35UR 3/2RN&('&Y>2\!WJH0+,HO1*)./2RN&('RU'CD7RN<s/282105UX10'*H0+,).RNH*3D05N+9e#u+f/s<+,)./2RN&('
<2/21*HORN+,<_3@H0+,).RNH*3D05N+Y8:36 V +.'/&YsDqWL;0RN):;iRU'\-4382/2RN).105o38_L_3(<<21 ).RN+.'/]Yn&(8q/2;*+P*{*77,:
V &H0+.5UR 3/2RN&('7e

6

2

  M0#v##







isq# 2 




kvfi#0"v

P

zu

 28 105N+F3-0-05URN)M3/2RN&(' V 3MX3(H0H8+,HO10'*H*3'/\RU'OYn&(8 V 3/2RN&('/&t3698:3-0;7e  '6+.'*+.8:35$WH0+./+,)./2RU'06t8+f~
HO10'*H*3'*).XSRN<@HOR ).105U/i=8+,)M35U5]H0+./+.8 V RU'0RU'06L;*+./2;*+.83s698:3-0;RN<@8+,HO10'*H*3'Q/RN<P3'B  ~),& V -05N+./+
-08&(D05N+ V AfWD010/E/2;*+.8+38+Z<& V +l/282RUCRo35!)M3(<+,<MWGL;0RN):;L+lLRU5U5h6+./u82RNHS&Y2W<2RU'*),+l/2;*+.X V 3,Xy).8+M3/+
382/2R4).Ro35U5UXRU'O*'0RU/+ZH0+.82RUC93/2RN&('*<MeEx{RU8<2/MWa&('*),+382105N+>;43(<uD+,+.'S3-0-05URN+,Hy/&T3\698:3-0;3(),),&(8HORU'06F/&
3F69RUC+.'k-08&2+,)./2RN&('7W!RU/)M3'kDG+s3-0-05URN+,Hk36Q3RU'k/&/2;*+8+,<2105U/2RU'06y698:3-0;7Wq3(),),&(8HORU'06y/&/2;*+s<:3 V +
-08&2+,)./2RN&('7Wq3'*Hj/2;0RN<lRU'*H0+f*'0RU/+.5UXeyg_;*+,<+\Y[1082/2;*+.83-0-05URN)M3/2RN&('*<&(DQCRN&(1*<25UXt-08&HO1*),+8+,HO10'*H*3'/
RU'OYn&(8 V 3/2RN&('7eg_;*+.X38+l<:3RNHI/&DG+QMfNB:.e'*&(/2;*+.8u)M3(<+&Yq/282RUCRo35{8+,HO10'*H*3'*).XRU'S3698:3-0;yRN<
/2;43/q&Y}	 9!8+.5o3/2RN&(''*&H0+,<MW(R$e+9e{LRU/2;\+f03()./25UX/2;*+_<:3 V +_'*+.RU69;QD&(8<!RU'Z/2;*+<:3 V +_&(8H0+.8Meq%&('*<2RNH0+.8
Yn&(8@RU'*<2/:3'*),+\3s82105N+&YKRU'*H R
Y $M]*j_4/2;*+.B
' $M]*b_4 :eZg_;0RN<@82105N+)M3'tD+Z3-0-05URN+,HtRU'*H0+f*'0RU/+.5UXW
+.C+.'SRY]1*<+.5N+,<<E3-0-05URN)M3/2RN&('*<>38+Z3,C&(RNH0+,HWD010/P35U5!3-0-05URN)M3/2RN&('*<P).8+M3/+l/LRU'S8+.5o3/2RN&('S'*&H0+,<e  '
L;43/{Y[&(5U5N&LJ<MW(L+),&('*<RNH0+.8{/2;43/h/2;*+),&('*<2/2821*)./2RN&('\&Y4/2;*+698:3-0;Z8+,<2105U/2RU'06uY8& V 382105N+3-0-05URN)M3/2RN&('
-08+.C+.'Q/<J/2;*+6+.'*+.8:3/2RN&('I&Y/LRU'T8+.5o3/2RN&('F'*&H0+,<MW03'*Hi/2;43/J3>H0+.82RUC93/2RN&('IH0&+,<'*&(/_),& V -082RN<+@3'QX
1*<+.5N+,<<J82105N+>3-0-05URN)M3/2RN&('7e
?uRUC+.'j3T<:+./E&Y82105N+,< 3'*Ht3'~H0+.82RUC(3/2RN&('5N+M3(HORU'06I/&F3I^0? kW
RN<@<B3RNHS/&iD+F.U,2
RY'*&82105N+,<&YX )M3'DG+T3-0-05URN+,Hk/&
RU'3'&(82RU69RU'435L3MXWqR$e+9e35U5J3-0-05URN)M3/2RN&('*<\&Yu3'Xt82105N+
&YX &('
38+i1*<+.5N+,<<e&(8+iYn&(8 V 35U5UXW
RN<Z).5N&9<+,HkLPe 8Me /Me 3'*HkLPe 8Me /Mej3'\~H0+.82RUC93/2RN&('
N  D FtFtF  G G " kWL;*+.8+ !,= IE\+\ K AhRN<q/2;*+J698:3-0;s&(D0/:3RU'*+,HDX/2;*+3-0-05URN)M3/2RN&('T&Y3E82105N+
&Y&('
'  W0RYhYn&(8+.C+.82XT82105N+  &YF W0Yn&(8+.C+.82XF-08&2+,)./2RN&('
S D 3(),),&(8HORU'06i/&\/2;*+P-08&2+,)./2RN&(
Y8& V  JON L RU'Q/& kW/2;*+.8++fRN<2/<@3i-08&2+,)./2RN&(B
'  qY[8& V  JON L /&
S D ,= I8\pY\ K AfW<1*);S/2;43/
g"Q e
?uRUC+.'I3<+./_&Y82105N+,<@ 3'*Hs3698:3-0g
; ZWRY}3l).5N&9<+,Hi698:3-0;sRN<@~H0+.82RUC(3D05N+uY[8& V W/2;*+.'TRU/RN<
10'0RNw1*+9eq&(8+,&C+.8MWORY}/2;0RN<_698:3-0;FRN<H0+.82RUC93D05N+ELRU/2; 82105N+P3-0-05URN)M3/2RN&('*<W0/2;*+.' yRN<_/2;*+ V 3OR V 35
5N+.'069/2;&Y!3'U\~H0+.82RUC93/2RN&('7W43'*HI35U57H0+.82RUC(3/2RN&('*<&Y}5N+.'069/2; S5N+M3(HT/&ZRU/Mehr;*+.'FRU/J+fRN<2/<WL+@)M35U5
RU//2;*+.Ufl&
Y LPe 8Me /MeWOL;0RN):;L+@'*&(/C
+ [ e
|7+./h1*<h35N<&uH0+f*'*+_3'*&(/2;*+.8h'*&(/2RN&('7W(8+.5o3/+,Hl/&/2;*+]Y$3()./{/2;43/}L+_38+RU'Q/+.8+,</+,HRU'lRU828+,HO10'*H*3'Q/
698:3-0;*<Me  '/2;0RN<{-+.8<2-G+,)./2RUC+9W(5N+./{1*<h<:3,X>/2;43/!3'ZRU828+,HO10'*H*3'/!698:3-0;
RN<afp*LPe 8Me /Meh3u<+./h&Y482105N+,<
RY!+.C+.82XT698:3-0;I/2;43/)M3'FD+P&(D0/:3RU'*+,HFDXI3-0-05UXRU'06s&('*+@&Yh/2;*&9<:+E82105N+,<&('
RN<J+,w10RUC(35N+.'//&
ke}u<<21 V RU'06@/2;43+
/ RN<q3'RU828+,HO10'*H*3'/]698:3-0;3'*HZ/2;43/q698:3-0;*<]&(D0/:3RU'*+,HDQXZ3u82105N+J3-0-05URN)M3/2RN&('
38+@-010/RU'/&\RU828+,HO10'*H*3'Q/Y[&(8 V W*RY!3Y[105U5698:3-0;)M3'FD+@H0+.82RUC+,HFY[8& V /2;*+.'IRU/RN<J10'0RNwQ1*+9e
 'OY[&(8 V 35U5UXW/2;*+Z'*&(/2RN&('j&Y_3T).5N&9<:+,H698:3-0;/28:3'*<25o3/+,<P/2;*+lY$3()./@/2;43/@'*&(/2;0RU'06)M3'D+\3(H0H0+,H
/2;43/u;43(<'*&(/uDG+,+.'S35U8+M3(HOX3(H0H0+,HWGL;*+.8+M3(<u/2;*+P'*&(/2RN&('&Y3ZY[105U5698:3-0;S<:3,XO</2;43/'*&(/2;0RU'06T)M3'

e



v

O
d


@

a





 

v

*



d



+



A

0

fi M]|9M.tM=uwuMM3
 F

D+\3(H0H0+,Ht/2;43/P8+M35U5UXt3(H0H0<@'*+.LRU'OY[&(8 V 3/2RN&('t/&I/2;*+698:3-0;7e\r;*+.'t/2;*+\).5N&9<2108+&YJ3s698:3-0;
+fORN<2/<MWO/2;*+.'/2;*+PRU828+,HO10'*H*3'Q/Y[&(8 V &Y!/2;0RN<J).5N&9<108+PRN<J+f*3()./25UXT/2;*+EY105U5698:3-0;H0+.82RUC93D05N+EY8& V Ze
10/'*&(/+/2;43/uL;*+.'/2;*+>Y105U5}698:3-0;+fRN<2/<W*/2;*+l).5N&9<2108+H0&+,<'*&(/'*+,),+,<<B382RU5UX+fRN</<l=[<+,+>-08&&Y
&Y  8&(-7e7`MAfe
h 	

 }hAy

 .



}

9

]{%}$}

yA

6

g_;*+'*&(/2RN&('s&Y3Y[105U5*698:3-0;\D+.RU'06 V &(8+6+.'*+.8:35a/2;43'\/2;*+'*&(/2RN&('i&Y73@).5N&9<2108+9WQL+J)M3'6+.'*+.8:35UR M+
/2;*+H0+f*'0RU/2RN&('&Y*'0RU/++fO-43'*<2RN&('k<+./<P1*<+,HjRU'k3I-08+.CRN&(1*<-43-G+.8T=[36+./l 1069'0RN+.8MW!99O`AfW
3'*H3(H0&(-0/J/2;*+@Y[&(5U5N&LRU'06&('*+9

 yfi;}]}   }]Ayy .h{%}hM}[AyATJ M.JmlBNBE o(U2F*'0RU/+Z+fO-43'*<2RN&('<+./
 >G= .(S?fS:}pC=Of)j9o.Z(K!Q.BM?9[n( F6F6F   B0f9_fL$  4p]f9+5N65oc5E5
e fa9ZS: [ Qp!B4(mf4 5


 Y RN<P3i*'0RU/+Z+fO-43'*<2RN&('t<+./\=pYme+9e<fAfWH0+,HO1*)./2RN&('tRU'S D+,),& V +,<PH0+,).RNH*3D05N+=D010/ERU/@RN<u'*&(/
3 G:B:,(S:t),&('*HORU/2RN&('jYn&(8>H0+,).RNH*3D0RU5URU/X*Afe  '*H0+,+,HWRU'k&(8H0+.8>/&IH0+./+.8 V RU'*+iL;*+./2;*+.83^0? RN<
S
H0+,HO1*).RUD05N+sY[8& V 3y@ $n+*)4fWqRU/<21 ),+,<Z/&S),& V -010/+I [ W!/2;*+.'/&S);*+,):K/2;*+T+fORN<2/+.'*),+T&YE3
-08&2+,)./2RN&('FY8& V /&\ [ e^R V RU5o3825UXW*),&('*<2RN</+.'*).XT):;*+,)KO<JRU'I2\t38+PH0&('*+P&(' [ e



k

<

  }hAycy .]{%}$} Ay|AJ . P " $na*)*m.4knbX 9hOfB pS<q*[
)jB0(0Bn(y,,c5kU0fs pP:(0Bpf.4q V$m [ n *m4@p>(0fo.f4M=(Gi8}9t:ZQ2(0:2
fm( $na*)7>
4  (jlQ2(0:2PB2( $m [ n64 5
yn







g_;0RN<-08&(-+.82/XI35U5N&LJ<J1*</&Z-08&C+@/2;43/J/2;*+P),&('C+.8<+P&Y!g_;7e*blRN</2821*+EL;*+.'KRN<J8+,<2/282RN)./+,H
/&\3l*'0RU/+P+fO-43'*<2RN&('<:+./Me

p

hy|My   , " $n+*)g*m4IBnbX=Y9hOf~ osk<]*FjBO(0f[9,.c5UOft p
a(0fo.f4l Ofj)j(pf } YB0fO9>j$4*B[$n`4*B[$t4*Bj$p4 j$Y4S(Gka9
j$d
 4*Bj
 $n
 4*Bj
 $t4 [$  4>=9hO.2j$p.4>pOZ[2(0f[[(j2O:(0f[2(4Z2J(0f[Q.22
@fNB6 5



0

=

2MmWj$74;*&(5NH0<u3(<u3-4382/2RN).105o38E)M3(<+P&Y]g_;7e4bOe|7+./1*<J'*&L-08&C+P/2;*+ $74_-4382/Me^RU'*),+>RN<
RU'*),&('*<2RN<2/+.'/MWQ/2;*+J-08+.CRN&(1*<]-08&(-G+.82/X3(<:<+.82/<!/2;43/H$m  [ nm* h
4 RN<!RU'*),&('*<2RN</+.'Q/Me!g_;7eE+.'*<108+,<!/2;43/
 j$ J4fe
/2;*+.8+_+fRN</<{3698:3-0; <21*);l/2;43/`A}j$ d4B* jn$  [ 4B* jp$ 4 Ij$ J4fW93'*HA}j$ d4B* jn$  [ 4 I
^RU'*),+ij$ d4B* jn$ 4B* jt$ 4 jn$  [ Z
4 =[g_;7e7dAfW7L+\&(D0/:3RU'kj$ d4B* jn$ 4B* jt$ 4B* [p$ .4 j$ 4fe|7+./
1*<E'*&ML<10-0-G&9<+/2;43/j$ d4B* jn$ 4B* jt$ 4 jj$ J4fW73'*HS-08&MC+Z/2;43/ERU/ERN<P3D*<2108He  'y/2;43/P)M3(<+9W
/2;*+.8+PL&(105NHID+>3Z698:3-0;J  \~H0+.82RUC93D05N+@Y[8& V <21*):;I/2;43/
-08&2+,)./<JRU'/&Z  =[g_;7e4di36Q3RU'aAfe
[
[
'*HF<2RU'*),+
P Y P  WOL+P<;*&(105NHF;43,C+[$ 4B* jn$  4 I[$ 4@=[g_;7e`Afh/2;0RN<JRN<3D*<2108He





 

.

 



( 

 

 



 &(8+E6+.'*+.8:35U5UXW4&('*+@&(D0/:3RU'*</2;*+@Y[&(5U5N&LRU'06H0+,).RNH*3D0RU5URU/XF8+,<2105U/<W0H0+.-G+.'*HORU'06&('FL;*+./2;*+.8XW
y
D]W0&(8fifflmDtRN<3*'0RU/++f-43'*<RN&('I<+./Me


 uq

yn

< 

y $

9.

fi;}hAyy

h{%}hM}

yAy|A

e 0f pZ@W5W5=Q2(0,[n(2 p2.nQfN=E:(0Bpf.aL:(aQ2(0,[n(p\
V s
92ZQ.[QQfN=_Q(OM[[(2CDoE,.lM!2.nQfNW5

;



fi

3MfiuM%

e 0fDoIW5W5=lQ29O,[n(tDpT2.nQfN=ifOPf\(p*T[f;:taQ2,[fU
V s
2CDa5

V es0f*lmDo>W5pW5U>=]Q(OM[[(2CDo>Q2,[fU5
2MmW]^10-0-&9<+E

NR <_3EY2e+9e<MehE+,).RNH*3D0RU5URU/Xs&Y7-08&(D05N+ V <RU'i 3'*Hi\FYn&(5U5N&MLJ<Y[8& V -08&(-+.82/X
cOe  'I2CD!W*L;*+.'/2;*+3'*<2L+.8RN<(fX+,<%(W*RU/)M3'DG+>&(D0/:3RU'*+,HIRU'I*'0RU/+>/2R V +9*L+P-08&),+,+,H3(<Yn&(8
D7=[<:+,+E-08&&Y!&Y!/2;*+,&(8+ V `MAD010/),&('*<2RN</+.'*).XT):;*+,)KO<38+PH0&('*+&('F/2;*+EY[105U57698:3-0;IRU'*<2/+M3(HI&Y
/2;*+@698:3-0;IRU/<:+.5Yme
u&MLPW<210-0-G&9<:+DRN<F3tYme+9e<Me \ +fORN<2/<MWJ/2;Q1*<T/2;*+yH0+.82RUC(3/2RN&('/28+,+yRU'DRN<*'0RU/+9Wu3'*H
),&('*<2RN<2/+.'*).X);*+,):K< V 3,X&('05UX).10/I<:& V +S-4382/<F&Yl/2;0RN<T/28+,+9eE+,HO1*)./2RN&('RU'sD8+ V 3RU'*<
10'*H0+,).RNH*3D05N+lDG+,)M31*<:+>L;*+.'p
D " OWa&('*+l&(D0/:3RU'*<u/2;*+>2\ V &H0+.5$WaRU'L;0RN);H0+,HO1*)./2RN&('SRN</282105UX
10'*H0+,).RNH*3D05N+9e
x{RU'435U5UXWRYRO
 l9DSRN<3EY2e+9e<MeUW [\ +fORN<2/<MW/2;Q1*</2;*+H0+.82RUC93/2RN&('T/28+,+JRN<]*'0RU/+9W3'*Hs),&('*<2RN<2/+.'*).X
);*+,):K< V 3,XF&('05UXT).10/J-4382/<&Yh/2;0RN</28+,+9e
u&(/+/2;43/_/2;*+E),&('*HORU/2RN&(' p
 l~DSRN<3P*'0RU/+u+fO-43'*<2RN&('T<+./ RN<_<2/28&('06+.8_/2;43' DG&(/2;m3'*HmD
38+E*'0RU/+P+fO-43'*<2RN&('<:+./< :e!g_;*+uY[&(5U5N&LRU'06-08&(-+.82/Xlm1*<2/2R4+,</2;0RN<),&('*HORU/2RN&('7







5

pS29
G2BB:,(B;:TQ.[QQfNW5
yn



!

5



!

K*}{$pFa9

(aBD (C<q*[yjBO(0f[9M.>=\O.k2CD

$D vv$|
  A ]  AD

2MmW rt+@D010RU5NH3Z8+,HO1*)./2RN&('Y8& V }

   N 7 t.{  =[g_;Q1*+9W}`MbO`.dA
/&lsDG   hW*L;*+.8+E/2;*+u&(D0/:3RU'*+,HT82105N+E<+./<@3'*HmDj38+uDG&(/2;s*'0RU/+E+fO-43'*<2RN&('F<+./<Me
g_;0RN<E8+,HO1*)./2RN&('S8+.5URN+,<@&('S/2;*+l&('*+lD010RU5U/uYn&(8-08&CRU'06F/2;*+l<+ V R~H0+,).RNH*3D0RU5URU/X&Y]2\~  
=/2;*+,&(8+ V vAfe
|7+./Z1*<*8<2/Z-08+,<+.'//2;*+i/L&yKRU'*Hk&Y*'0RU/+s+fO-43'*<2RN&('<+./<1*<+,HkRU'/2;0RN<l8+,HO1*)./2RN&('7eDRN<
3*'0RU/++f-43'*<RN&('S<:+./E<RU'*),+l&('05UX8+.5o3/2RN&(''*&H0+,<P38+l-08+,<+.'/@RU'S/2;*+),&('*).5U1*<2RN&('t&Y]82105N+,<MEDRN<
RU'*H0+,+,HF3P-4382/2RN).105o38J)M3(<:+&Y78:3'06+f~$8+,<2/282RN)./+,HI82105N+,<E=[<:+,+  8&(-7e`9`AfeFRN<_35N<&Z3P*'0RU/+u+fO-43'*<2RN&('
<+./P<2RU'*),+9WYn&(8P+.C+.82Xy82105N+\RU'W/2;*+Z;QX-G&(/2;*+,<2RN<>RN<PHORN<),&('0'*+,)./+,HjY8& V /2;*+),&('*).5U1*<2RN&('=L+\)M35U5
/2;*+,<+u82105N+,<@(p.(4G2,2*Af
e u&(/+/2;0RN</2R V +u/2;43/MWO/2;*&(1069;* RN</282RUCRo35U5UXT3@Y2e+9e<MeUW/2;*+E).5N&9<2108+E&Y{3
698:3-0;ILPe 8Me /MeH0&+,<J'*&(/J'*+,),+,<<:382RU5UXF+fORN<2/Me
+,)M35U5@/2;*+}

 /:3K+,<3(<TRU'0-010/F/L&L&(8H0
<  3'*
H 7@3'*H3<:+./T&Yl82105N+,<
 " m D * F6F6F * G nQWh+M3();k82105N+/ D+.RU'063F-43RU8&YJL&(8H0Z

< $ ,* c4fW!3'*H3(<2KO<PL;*+./2;*+.8Z/2;*+.8+\RN<Z3
H0+.82RUC93/2RN&('\Y[8& V  /j
& 7[ehg_;*+.8+JRN<]3'iR VV +,HORo3/+H0+.82RUC93/2RN&('\Y[8& V  /j
& 77=L+'*&(/d
+ 
7NA
RY2WhY[&(8Z<& V +s Q`
W  "  D W  3'*H   "  D 6  et Q.BM ?9[n(Y[8& V  /
&   =L+s'*&(/+

   ARN<3Z<+,w1*+.'*),j
+  " N
 D

"  e
F6F6F
rt+;43MC+\<2;*&L't;*&ML/2;0RN<P-08&(D05N+ V )M3'D++f-08+,<<:+,HRU'/2;*+ V &H0+.5$@/&I3FL&(8J
H  "
] F6F6F ] RN<3(<<&).Ro3/+,H/2;*+u698:3-0;I

$M4fW03'*Hi/&Z3'QXi82105N+E7

"ff$M_ F6F6F _ *
W
!
4
N
R

<
(
3

<

<

&
).Ro3/+,H
D
D
D F6F6F
G
/2;*+698:3-0;82105N+  $.
 4fW{3(<>8+.-08+,<+.'Q/+,HRU'jx{RU6*eq`Mvt=L;*+.8+
RN<P698+M3/+.8/2;43'k35U5]&(/2;*+.8l),&('*),+.-0/
/X-+,<BAfe!g_;*+.
' 
   Rt
 $M  4 P $n
 $M4*  $`
 4y4>=[<:+,+E-08&&Y!&Yhg_;7eavAfe
|7+./F1*<s'*&L <2-05URU/F+M3();&(D0/:3RU'*+,H82105N+  $)
 4RU'/&&('*+yHORN<:),&('0'*+,)./+,HRU'OY[+.8+.'*),+S82105N+p
 $.
 4
3'*H&('*+>8:3'06+f~$8+,<2/282RN)./+,HS+.C&(5U10/2RN&('82105N+++
D $)
 4feJrt+>HORN<2/2RU'06910RN<2;RU'/2;*+>;QX-G&(/2;*+,<2RN<u&Y+
D $)
 4/L&
<210D0698:3-0;*<MZ/2;*+y(f(4W}L;0RN);),&(828+,<2-&('*H0<>/&/2;*+\;X-&(/2;*+,<2RN<l&Y  $)
 4fWq3'*Hj/2;*+yBf[a9[n(4W
L;0RN);),&(828+,<-G&('*H0<F/&k/2;*+S),&('*).5U1*<2RN&('&Y(
 $)
 4fe  /TRN<T+M3(<2X/&k):;*+,)K/2;43/I&('*+y-4382/I&Y>/2;*+
3D&MC++,w10RUC(35N+.'*),+t</2RU5U5u;*&(5NH0<
    
 $M  4 P $n

 $M4*)
 $
 4Hl+
D $
 4y4feu&ML+.C+.8MW
/2;*+),&('QC+.8<:+tRN<F'*&5N&('06+.8IC935URNH);*+,):KDQX+fO+ V -05N+t/2;43/MWRY/ " m
 " $ *3W4>nQW@L+;43MC+

K* { 

$D *|{9


M
|

ff

C

` ]*

ff 	

ff



2

$-

>* { 

ff

2	 

;



fi M]|9M.tM=uwuMM3
 F

$M4

B

 $)4
u

s



s



s



s

%

s

s

s

s

s


A

s




E

u

s

u

Origin
s
s

s




D*v$|
RU'/&

s

s

s

s

s

s

s

s


A

A

$.4
D+$.4
u

s
s

Destination

x{RU69108+\`MvOqg8:3'*<mY[&(8 V 3/2RN&('*<Y[8& V /2;*+}



V &H0+.5N<&Y{/2;*+E_Yn3 V RU5UX

+

 Z=n3-0-05UXm$)4&('*),+9WO/2;*+.'F/L&Z/2R V +,<,D+$.41*<2RU'06
 $	W4 P $n$ 4*)$`4)l/D$4y4/2;*&(1069;


HOR+.8+.'Q/'*&H0+,<gT\D010//2;*+@<:3 V +@'*&H0+ByAOAfe
rt+/2;Q1*<{'*+,+,H/2;*+]'*&(/2RN&('Z&Ya3M3-0-05URN)M3/2RN&('&Ya382105N+2D+$)4fRU/}RN<{<21*);l/2;43/{/2;*+]-08&2+,)./2RN&('
&Y]RU/<EH0+,<2/2RU'43/2RN&('-4382/ERN<@3 V 3-0-0RU'06F/&F3i<210D0698:3-0;S/2;43/EL3(<@&(D0/:3RU'*+,HSDQXy3-0-05UXRU'06F/2;*+82105N+
$.
 4fW03'*H/2;43/L3(<'*+.C+.81*<+,H\/&-08&m+,).//2;*+uH0+,<2/2RU'43/2RN&('T-4382/&Y}3'X\82105N+&Y{
D $
 4fWRU'*).5U1*HORU'06
D+$.
 4_RU/<+.5Y2e]y&(8+,&MC+.8MWa/2;*+P&(82RU69RU'y3'*HH0+,<2/2RU'43/2RN&(' V 1*<2/D+E-08&2+,)./+,HIRU'Q/&iHORN<[2&(RU'Q/-43/2;*<l=R$e+9e
3S'*&H0+I&YE/2;*+I&(82RU69RU')M3'0'*&(/i;43,C+F/2;*+<:3 V +FR V 36+F;43(<s3S'*&H0+F&Y@/2;*+IH0+,</2RU'43/2RN&('aAfe  YuL+
8+,<2/282RN)./&(108<+.5UC+,<_RU'F<& V +uL3MX/&l6&&HT3-0-05URN)M3/2RN&('*<J&Y}82105N+,<_&YT+
D $
 4fW/2;*+.'TL+@)M3'TC+.82RY[X\/2;43/
 $M  4 P $n

 $M4*  $
 4y4R
 $M  4 P $n
 $M4*)
 $
 4l*+
D $
 4y4fe
g_;0RN<8+,<2/282RN)./2RN&('RN<&(D0/:3RU'*+,HDXT1*<2RU'06i),&('*<2/28:3RU'/<MWa/2;43/LRU5U5{35U5N&L+.C+.82XF6&&H3-0-05URN)M3/2RN&('
&Y>382105N+I&Y9
D $
 4fW3'*HD+FCRN&(5o3/+,HDXk/2;*+&(D0/:3RU'*+,H698:3-0;&(/2;*+.82LRN<+9e|7+./i1*<\'*&(/+K  $`
 4
3'*HD  $`
 4E/2;*+'*+.L<+./<&YJRU'OY[+.8+.'*),+82105N+,<l3'*H+.C&(5U10/2RN&('k82105N+,<eFg_;*+\'*+.L/28:3'*<2Y[&(8 V 3/2RN&('kRN<
H0+,<).82RUD+,HRU'x{RU6*e`MOe  /i35U5N&LJ<T/&j&(D0/:3RU'/2;*+IYn&(5U5N&MLRU'068+,<2105U/M
  7 
 $M74 P

$n  $M4*)  $
 4*)D  $`
 4*Lm Q * S n4fe!g_;*+J'43 V +,<_&Y78+.5o3/2RN&('s/X-G+,d
< "ZW i 3'*H
;43,C+uD+,+.'i):;*&9<+.'
/&Z69RUC+>3'IRU'/210RU/2RUC+PRNH0+M3Z&Yh/2;*+.RU8J8&(5N+@D010/J/2;*+.XF38+_m1*<2/_/X-G+,<3(<J&(/2;*+.8<Meq8+.5o3/2RN&('I'*&H08
+ $i 4
Y[8& V 3T'*&H0
+  6/&I3F'*&H0
+ ; 	 V +M3'*<>/2;43/P/2;*+\5N+./2/+.8 ;43(<>DG+,+.'&(D0/:3RU'*+,HtDQXt3-0-05UXRU'06
/2;*+@82105N+ e!8+.5o3/2RN&('I'*&H08
+ $ 4]Y[8& V  G /
&   V +M3'*<J/2;43/J/2;*+E5N+./2/+.
8 _ G D+.5N&('06</&Z/2;*+
<210DL&(8H&('L;0RN);\/2;*+82105N+, G;43(<!DG+,+.'s3-0-05URN+,Ha
e "RN<h1*<+,H/&ERU'*HORN)M3/+/2;43/q/L&>),&('*),+.-0/q'*&H0+,<
;43,C+/&PD+-08&2+,)./+,H&('\/2;*+<:3 V +'*&H0+>=RU'T%?/+.8 V <MWL+JL&(105NHs<+,+RU/3(<3@),&~$8+fYn+.8+.'*),+5URU'0K*Afe
g_;*+Z+.C&(5U10/2RN&('82105N+~.
D 0$ c4fW<2/:382/2RU'06sY8& V 3i-43/2;S8+.-08+,<+.'Q/2RU'06/2;*+l<10DQL&(8H 1*<+,Hy/&T3-0-05UX
 _3'*HY8& V /2;*+l8+.-08+,<+.'Q/:3/2RN&('j&Y ]6+.'*+.8:3/+,HSDXB  $ c4fW-08&HO1*),+,<u/2;*+/L&T8+.5o3/2RN&(''*&H0+,<
/X-+,HKP<2R V 105o3/2RU'06/2;*+P3-0-05URN)M3/2RN&('&Y  $ 4fWO/2;Q1*<, W03'*HF/2;*+E8+.5o3/2RN&('I'*&H0+,<_/X-G+,H
L;0RN):;
V 382KF/2;*+8+.-08+,<+.'Q/:3/2RN&('&Y ]3(<1*<+,HDQX3'S3-0-05URN)M3/2RN&('&YT 2eg_;*+>'*+.6Q3/2RUC+l),&('*<2/28:3RU'Q/ S
-08+.C+.'Q/<_3'i3-0-05URN)M3/2RN&('T&YD  $ 4hRU'\L;0RN);i/L&>'*&H0+,<&Y/2;*+J&(82RU69RU'i3'*HH0+,</2RU'43/2RN&('-4382/<q;43MC+
/2;*+P<:3 V +PR V 36+=n3Z'*&H0+@'*+,),+,<<:382RU5UXF&(D0/:3RU'*+,HIDXs<:& V +>3-0-05URN)M3/2RN&('y&Yh/2;*+@82105N+ 	$ c42Af0L;0RU5N+
/2;*+\-&9<2RU/2RUC+s),&('*<2/28:3RU'Q/ Q -08+.C+.'/<l<1*);3I<210D0698:3-0;k/&ID+\1*<+,Hj/LRN),+Y[&(8Z3-0-05UXRU'06pD  $ c4
LRU/2;HOR+.8+.'/@-08&m+,)./2RN&('*<@&YRU/<@&(82RU69RU'7RU/E<:3,XO<u/2;43/ERU'y/2;0RN<@)M3(<:+9Wa/2;*+l/L&T-08&2+,)./2RN&('*<@&Y]/2;*+
&(82RU69RU'*< V 1*<2/JD+E/2;*+P<:3 V +9e



U4

4 















h 

{%}$My

yn	A'Ay




Uff

*



fi



`



ff








C

0ff
C







y|

|7+./_1*<_'*&MLYn&).1*<&('T/2;*+u82105N+,<_/2;43/L+.8+E1*<:+,Hi/&Z<&(5UC+u/2;*+G.{*7.:-08&(D05N+ V eqD0RN),&(5N&(8+,H
698:3-0;=82105N+&(8]),&('*</28:3RU'Q/BA{RN<q<B3RNHZ/&EDG+E2(QB.[Bn,2=8Me 8Me
APRYRU/<!<+,),&('*H-4382/=[),&('*).5U1*<RN&('i&(8
&(D05URU6Q3/2RN&('aA_H0&+,<_'*&(/),& V -082RN<+P3'QXs6+.'*+.82RN)@),&('*),+.-0/'*&H0+9eqrt+1*<:+/2;0RN<+fO-08+,<<2RN&('FDXs3'435N&(69X

7

$-

fi3MfiuM%



  $M4

B


 $  4




=


 

=

s

s

s



s

s

#

s


s

=



=

4
=

x{RU69108+\`MOJ+,HO1*)./2RN&('TY8& V

u

=
s



E



=

u
u

S


s





s






=

u



s





s






s

s

s




=

#





u

s





s



#

s

Q

=

s

u

s

u




D.0$ c4





 

/2;*+}Dvv$|
/&2CDK*}{$hW*LRU/2;*Dj3'*HmY2e+9e<Me
s

s

s

s

LRU/2;T/2;*+<:&~)M35U5N+,Hi82105N+,<_RU'T@3/:35N&(6*WL;*+.8+E35U5C9382Ro3D05N+,<_&Y/2;*+u;*+M3(H V 1*<2/J3-0-G+M38_RU's/2;*+D&HOX
=[D0RU/+.DG&(105E+./s35$eUW@`Mb9b9vAfe^1*);82105N+,<T38+y35N<&j)M35U5N+,H.2,RU'/2;*+5URU/+.8:3/2108+9e%&('*<2RNH0+.8Yn&(8
RU'*<2/:3'*),+@/2;*+P82105N+,<J&Yhx{RU6*e4vO  D 3'*H   38+@8:3'06+@8+,</282RN)./+,HW0L;0RU5N+  	 RN<'*&(/Me
5N<&S'*&(/2RN),+I/2;43/s3S8:3'06+F8+,<2/282RN)./+,H82105N+  )M3'D+FH0+,),& V -G&9<:+,HRU'Q/&3'+,wQ10RUC935N+.'Q/s<+./
&Y]82105N+,<
7
 $  4LRU/2;+f*3()./25UX&('*+l'*&H0+lRU'S),&('*).5U1*<2RN&('=[+.RU/2;*+.8P3'SRU'*HORUCRNHO1435!),&('*),+.-0/@'*&H0+&(8P3
8+.5o3/2RN&('S'*&H0+AfeEg_;*+.8+lRN<E&('*+>82105N+>Yn&(8u+M3():;y'*&H0+Z&Yq/2;*+Z),&('*).5U1*<2RN&('&Y  _Y[&(8E+M3();SRU'*HORUCRNHO1435
'*&H0d
+ W&('*+_82105N+_LRU/2;<:3 V +_;X-&(/2;*+,<2RN<]3(<  3'*H\3E),&('*).5U1*<RN&('\8+,<2/282RN)./+,H/[
& (Y[&(8q+M3():;\8+.5o3/2RN&('
'*&H08
+ 0W{&('*+82105N+iL;*&9<+i;QX-G&(/2;*+,<2RN<lRN</2;*+HORN<[2&(RU'Q/Z10'0RN&('&YJ/2;*+;X-&(/2;*+,<2RN<l&Y  3'*H&Yu35U5
RU'*HORUCRNHO1435q),&('*),+.-0/@'*&H0+,<@&Y/2;*+l),&('*).5U1*<RN&('t&Y  W3'*H),&('*).5U1*<2RN&('RNb
< 0WGLRU/2;t<:3 V +l'*+.RU69;QD&(8<
3(<@RU'  eig_;*+5N&(69RN)M35]RU'/+.82-08+./:3/2RN&('&Y_<21*):;t82105N+,<38+y=pY10'*)./2RN&('tY8+,+Au8:3'06+8+,<2/282RN)./+,Hju&(82'
82105N+,<Me  Y]3^0?RN<H0+,HO1*).RUD05N+@Y[8& V 3<:+./&Y!8Me 8Me]82105N+,<XW*/2;*+.'RU/JRN<H0+,HO1*).RUD05N+PY8& V /2;*+P<+./&Y
/2;*+.RU8H0+,),& V -&9<2RU/2RN&('*<E
 $t7
 4fW43'*HI8+,).RU-08&)M35U5UXeu&ML+.C+.8MWG3(<<&&('3(<),&('*<2/28:3RU'Q/<E38+@RU'C&(5UC+,HW
/2;0RN<J+,w10RUC(35N+.'*),+>H0&+,<'*&(/;*&(5NH3'QX V &(8+9e




yn





M.2@m(Q2ff[f[,sBUfPo>1<q*[)jfO(0f[(yM.c5

2MmW I^RU'*),+I35U5_698:3-0;*<\38+T-010/ZRU'Q/&S'*&(8 V 35_Yn&(8 V W]3'RU'*HORUCRNHO1435 V 382K+.83-0-+M38<3/ V &9<2/
(& '*),+sRU'3698:3-0;7eSg_;*+'1 V D+.8\&YRU'*HORUCRNHO1435'*&H0+,<l).8+M3/+,HDXj/2;*+s<+./Z&YJ82105N+,<RN<lD&(10'*H0+,H
DQX "  r\j-  [   J D L  e^&I/2;*+'Q1 V D+.8&YJ8+.5o3/2RN&(''*&H0+,<l).8+M3/+,H='*&/LRU'8+.5o3/2RN&('
'*&H0+,<>38+).8+M3/+,H4AuRN<ED&(10'*H0+,HDQXo " G
 $3  ( $[46eV4  WL;*+.8+  RN<E/2;*+Z'1 V D+.8
&Y]8+.5o3/2RN&('S/X-+,<LRU/2;t369RUC+.'t382RU/X 3-0-+M3 82RUD'0 6sRU't382105N+Z),&('*).5U1*<2RN&('7W73'*H  K RN</2;*+l698+M3/+,<2/
382RU/XT&Y}<21*):;3P8+.5o3/2RN&('/X-G+9e]^&l/2;*+E).5N&9<2108+E&Yh3698:3-0;I)M3'TDG+E&(D0/:3RU'*+,HTLRU/2;I3lH0+.82RUC(3/2RN&('I&Y
5N+.'069/2;BO
 \e!rt+E/2;1*<&(D0/:3RU'S [ RU'T*'0RU/+P/2R V +9e
u&(/+]/2;43/MW9),&('/28:382X/&6+.'*+.8:35*'0RU/+_+f-43'*<2RN&('Z<+./<MW(+fORN<2/+.'*),+&Y4/2;*+).5N&9<108+_3'*Hl+fORN<2/+.'*),+
&Yh/2;*+uY105U5698:3-0;38+>+,wQ10RUC935N+.'Q/J'*&(/2RN&('*<JRU'I/2;*+@)M3(<+@&Yh8:3'06+@8+,<2/282RN)./+,HF82105N+,<Me  /_Yn&(5U5N&MLJ<Y[8& V
/2;*+q-08&&Y*&Y0-08&(-G+.82/X`9`q/2;43/}/2;*+q5N+.'069/2;&Y43H0+.82RUC(3/2RN&('>Y8& V T/& [ RN<RU'~
 $ G Q D 4fWL;*+.8+ \RN<
/2;*+<2R M+&
Y $n+
 *)
 4q3'*H K RN<q/2;*+_698+M3/+,<2/382RU/X&Y3u8+.5o3/2RN&('/X-+J3-0-G+M382RU'06PRU'3u82105N+),&('*).5U1*<2RN&('7e
g_;0RN<q8&(1069;10-0-G+.8qD&(10'*H),&(105NH\D+_8+f*'*+,HD010/qRU/]RN<q<21 ).RN+.'Q//&@&(D0/:3RU'/2;*+_Yn&(5U5N&MLRU'06>-08&(-G+.82/XW
L;0RN);LRU5U5DG+1*<+,H/2;08&(1069;*&(10/l/2;*+i-08&&Y[<l&Y),& V -05N+fRU/Xj8+,<2105U/<lRU'C&(5UCRU'06y8:3'06+s8+,<2/282RN)./+,H
82105N+,<Me

0



6



$-





fi M]|9M.tM=uwuMM3
 F



yn
   aQfOE:fG[n(T9{O\j(l 9B[	 :mfU9[[9I	 ::*BJoZ(*f$(4M =
(M?fSZm9QEB.[Bn,2,.qmufNB=!OuNf9Fmu(Cg!fBM?9[n(Pf2(pq0(@:(a9ln(@:
f2T$sOEft slmE
 $n+
 *)
 465



p

 'FL;43/Yn&(5U5N&MLJ<MW0L+>3(<<21 V +P/2;43//2;*+>382RU/XF&Yh8+.5o3/2RN&('/X-+,<RN<D&(10'*H0+,HFDQXF3Z),&('*<2/:3'Q/Me

q

hy|My


f[fn,2iBNB6

<  
p1
 !m(aN.W5

y $

V  2(0,[n(i2

 [{%}huyyn	A'Ay

y|

esO.CD9a


(2@m9QP2S!

_ ` !m(aN.W5
V !90BpffGL:i(asQ29O,[n(2\( E

V  2(0,[n(i2D(a>sDp `	 !m(aN.W5
2MmWkg_;*+Y[&(5U5N&LRU'06k8+,<105U/<T;*+M3,CRU5UX8+.5UX&('

 8&(-7eE`MO35U5EH0+.82RUC93/2RN&('*<TRU'QC&(5UC+,HD+.RU'06k&Y
-&(5UX'*& V Ro355N+.'069/2;7WO/2;*+.XF3(H V RU/3-G&(5UX'*& V Ro357),+.82/2R4)M3/+=/2;*+@<+,w1*+.'*),+E&Y}-08&2+,)./2RN&('*<1*<+,HT/&
D010RU5NHF/2;*+PH0+.82RUC93/2RN&('aAfe
H!9GU..GB:Pmq2g
 ! }  he]g_;*+-08&(D05N+ V D+.5N&('06<q/C
&   e  '*H0+,+,HW3@-G&(5UX'*& V Ro35
),+.82/2R4)M3/+RN<69RUC+.'DX3tH0+.82RUC(3/2RN&('Y8& V /&k3S698:3-0
;   WYn&(5U5N&ML+,HDQX3S-08&2+,)./2RN&('Y[8& V
/2;*+Z6&35h/g
& Y[ePr;*+.' " OW&('*+&(D0/:3RU'*<@~   =-08&m+,)./2RN&('t):;*+,)KRU'06AfW/2;1*<E/2;*+
  ~),& V -05N+./+.'*+,<<Me
 ! 
4(a\`
 !   !e\+,)M35U5h/2;*+),&('*<2RN<2/+.'*).X
_` !(aN.fB:imE2\`

);*+,):KRU'QC&(5UC+,<T/2;*+RU828+,HO10'*H*3'Q/TYn&(8 V &Ye  '&(8H0+.8s/&t5URU69;/+.'/2;*+-08&(D05N+ V Y[&(8 V 105o3/2RN&('7W
L+3(<<1 V +>;*+.8+l/2;43/P35U5]^0?E<@38+>RU828+,HO10'*H*3'/MW7D010/ERU828+,HO10'*H*3'*).X)M3'SD+>RU'/+.698:3/+,HLRU/2;*&(10/
RU'*).8+M3(<2RU'06E/2;*+),&('*<2RN<2/+.'*).X>):;*+,)K),& V -05N+fORU/X{<+,+q/2;*+-08&&Y4&Y*/2;*+,&(8+ V cOe}G 7
4
D+.5N&('06</& _ ` <2RU'*),+>RU/),&(828+,<2-&('*H0</&\/2;*+5o3'0691436+
 "#mW]_ D _   $M]*1_ D *1_  4>nQWaL;*+.8+

]S+.'*),&H0+,<u3'RU'*<2/:3'*),8
+ $n2)m.
 4&Yh/2;*+P-08&(D05N+ V 3'*H $M]*H_ D *1_  4 i  RJ
 _ D "$ D 3  N 4fW4L;*+.8+
N

N
R
\
<
y
3
0
H
.
+
2
8
U
R
9
C

3
2
/
N
R
(
&

'

Y

8
&



/
&
B

W
a

N
R
\
<

3
0

8

&
2

,
+
.
)
2
/
N
R
(
&

'

Y

8
&
2
/
*
;
T
+
2
/
2
8
U
R
9
6

6
.
+
\
8
&Y@3S),&('*<2/28:3RU'Q/
JPN L
V
V
D
RU'Q/7
&   W _  " $  3  D 4fW  RN<u3\H0+.82RUC93/2RN&('Y[8& V   /Z
&    3'*
H  D RN<u3-08&2+,)./2RN&('Y[8& V
RU'/&
Y !<Me /Mr
e  D% JON L; q
0  N e  RN<E-&(5UX'*& V Ro35U5UXH0+,).RNH*3D05N+3'*H-&(5UX'*& V Ro35U5UXyD435o3'*),+,H=[<2RU'*),+Z/2;*+
5N+.'069/2;*<J&Y D 3'*H  38+u-G&(5UX'*& V Ro35RU'F/2;*+@<2R M+E&Y}/2;*+ERU'0-010/BAfeqr;*+.'U
 " OW0&('*+E&(D0/:3RU'*</2;*+
-08&(D05N+ V _G 
4]WO/2;1*<q/2;*+ _` ~),& V -05N+./+.'*+,<<Me]^RU'*),+2\   ),&('*<2RN</<qRU'

<&(5UCRU'06@/L&@RU'*H0+.-G+.'*H0+.'/]-08&(D05N+ V <MWQG 
4= _ ` ~),& V -05N+./+Aq3'*HZ2\~  

	=   ~),& V -05N+./+AfWG3'*HF<RU'*),[
+   RN<RU'*).5U1*H0+,HIRU' _` WO\G~   jRN<35N<& _` ~),& V -05N+./+9e


 `	 !:(aU,fGBBZm2DG   heu<Y[&(82\=[<+,+P3D&MC+AfW0L+>3(<<21 V +@/2;43/u35U5}^0?E<
38+RU828+,HO10'*H*3'Q/Me]g_;*+uw1*+,<2/2RN&('iRN< 38+/2;*+.8+E3>H0+.82RUC(3/2RN&('sY[8& V t/&l3l^0
?   3'*HT3P-08&2+,)./2RN&('
Y[8& V RU'/k
& YnWQ<1*);\/2;43/!Yn&(835U5  &Y/2;0RN<]H0+.82RUC93/2RN&('7WQY[&(835U5a),&('*<2/28:3RU'Q/ 9W9Yn&(835U5*-08&2+,)./2RN&('
JPN L RU'/
kY[8& V
&  mW7/2;*+.8+\+fORN<2/<>3F-08&m+,)./2RN&(
'   Y[8& V
RU'/
&  <Me /Mo
e   JON L " :e 
RN<-G&(5UX'*& V Ro35U5UXH0+,).RNH*3D05N+3'*H-G&(5UX'*& V Ro35U5UXD435o3'*),+,H=[<2RU'*),+/2;*+<R M+&Y]/2;*+lH0+.82RUC93/2RN&('Y[8& V
/
&   RN<-G&(5UX'*& V Ro35U5UXF8+.5o3/+,H/&/2;*+<R M+>&Y!/2;*+PRU'0-010/BAfeg_;Q1*<MWaDG~   kRN<RU'  `	 e
 'T&(8H0+.8_/&l-08&MC+E/2;*+@),& V -05N+./+.'*+,<:<MWOL+uD010RU5NHI38+,HO1*)./2RN&('TY8& V 3l<2-+,).Ro35)M3(<+E&Y/2;*+E-08&(D05N+ V
 	 WQL;*+.8+/2;*+JYn&(8 V 105o3>RN<_3  ~
% ux=R$e+9eq3'RU'*<2/:3'*),+u&Y  ~^!gAf69RUC+.'T3@Y[&(8 V 105o3iWQL;0RN):;iRN<_3
),&('(m10'*)./2RN&('&Yh).5o31*<:+,<LRU/2;3/ V &9<2/  5URU/+.8:35N<W43'*HI3l-4382/2RU/2RN&(B
' m D *)  *) 	 n&Y{RU/<C9382Ro3D05N+,<MW
H0&+,<}/2;*+.8++fORN<2/!3/28210/2;3(<:<2RU69' V +.'Q/hYn&(8h/2;*+C9382Ro3D05N+,<hRU'~ D W9<21*);Z/2;43/hYn&(8h35U5O/28210/2;3(<<2RU69' V +.'/
Yn&(8q/2;*+C9382Ro3D05N+,<]&YR  W9/2;*+.8++fORN<2/<]3@/28210/2;s3(<<2RU69' V +.'/qYn&(8q/2;*+C9382Ro3D05N+,<]&YR 	 <21*):;/2;43/RN<
/2821*+ g_;0RN<-08&(D05N+ V RN< `	 ~),& V -05N+./+=$^/&):K V +.X+.8MW`Mb9W/2;*+,&(8+ V d*eU`Afe!|7+./1*<_)M35U5aRU/  ~^!g 	 e



`* { $

 2D*

>* { 
* | 

K$ 2D*








T







{


K 2D*


6

K* { 

F

K 2D*

>v { $
T

6

A

2

$-


6


* | 
>* { 
T

Y    l
>v { $

fi3MfiuM%



a

b

at

af

c

bt

bf

val

val

val

ct

cf

dt

2
1

2
3

C1

C1

C1

C1

C1

C1

1

C1

C2

a

b

c

d

val

val

val

val

val

df

av

bv

cv

dv

d

...

3

C2

C2

C2

C2

C2

C2

val

av

b

val

bv

Q

1

>~

2

C1




a




a

2
3

1

3

C2

val

av

K*}{$
b

val

bv

x}RU69108+`  03 V -05N+&Y{/28:3'*<2Y[&(8 V 3/2RN&('FY[8& V  ~ Fff1& 	 /&D
g_;*+/28:3'*<mY[&(8

3/2RN&('L+1*<+RN<PRU5U5U1*</28:3/+,HtRU'jx{RU6*eq`esg_;*+  ~^!gY[&(8 105o3F1*<+,HRN<l36Q3RU'

d 64T$UTV d=T4fWh3'*H/2;*+\-4382/2RU/2RN&('kRN<9 D " mA*Kn*)  " mAV n*) 	 " mAnQeFg_;*+
698:3-0;&(D0/:3RU'*+,HRN<u/2;*+l<:3 V +3(<RU'S/2;*+-08&&Y&Y]g_;7ecOWx{RU6*e{`MOWG+f0),+.-0/u/2;43/E),&('*),+.-0/E'*&H0+,<
`>),&(828+,<2-&('*HORU'06P/&@C9382Ro3D05N+,<!RU' D 38+'*&(/!5URU'0K+,H/&E/2;*+_'*&H0+,< `93'*HUP8+.-08+,<+.'/2RU'06
$

/2;*+.RU8J-&9<<2RUD05N+EC935U1*+,<Me
x{RU8<2/_);*+,):Ki/2;43/_RU's/2;0RN<RU'0RU/2Ro35L&(825NHWO'*&),&('*</28:3RU'Q/RN<CRN&(5o3/+,HWOD010//2;*+u6&35)M3'0'*&(/D+
<:3/2RN<m4+,HeXF3-0-05UXRU'06F&('*),+P/2;*+l+.C&(5U10/2RN&('S82105N+iW4L+>/282XI<& V +>C(35U143/2RN&('S&Yq/2;*+C(382Ro3D05N+,<uRU'
 D 3'*HI&(D0/:3RU'3lL&(825N
H  D WO/2;43/),&('Q/:3RU'*<E3'3'*<2L+.8/&eq10//2;0RN<JL&(825NHF;43(<J/&<B3/2RN<mYXi/2;*+
-&9<2RU/2RUC+),&('*<2/28:3RU'Q/ Q W9+fO-08+,<<2RU'06@/2;43/ $Yn&(8q+.C+.82X>C935U143/2RN&('&YG/2;*+_C(382Ro3D05N+,<!RU'~ D lE  W9/2;*+.8+
V 1*</+fORN<2/>3TC935U143/2RN&('&Y/2;*+C9382Ro3D05N+,<PRU' 	 <1*);t/2;43//2;*+ZY[&(8 V 105o3I+.C935U143/+,<>/&j[B* :e  Y
 <:3/2RN<m4+,</2;0RN<),&('*<2/28:3RU'/MW0RU/ V +M3'*<_/2;43/_L+E;43,C+Yn&(10'*Ht=DQXT3-0-05UXRU'06/lA3C935U143/2RN&('I&Y/2;*+
D
C9382Ro3D05N+,<RU'* D <1*);T/2;43/_Y[&(8J35U5C935U143/2RN&('*<J&Y}C9382Ro3D05N+,<RU'* D lC  =L;0RN);I)M3'FD+E<2R V -05UR4+,H
RU' $Yn&(835U5aC(35U143/2RN&('*<&YC(382Ro3D05N+,<RU'C  :W<2RU'*),+J/2;*+.8+RN<]&('05UX\&('*+<1*);C935U143/2RN&('iY[&(8& D AfWQ/2;*+.8+
RN<3FC(35U143/2RN&('&Y/2;*+C(382Ro3D05N+,<RU' 	 <1*);j/2;43//2;*+Yn&(8 V 105o3+.C(35U143/+,</&j[f0,esg_;*+.'/2;*+.8+
RN<3'3'*<L+.
8 :QBs/&/2;*+  ~ F1
ff & 	 -08&(D05N+ V ej%&('QC+.8<+.5UXW]<210-0-G&9<:+s3'3'*<2L+.8sG/&/2;*+sD
-08&(D05N+ V e  / V +M3'*<]/2;43/]Y[&(8+.C+.82XL&(825NZ
H  D /2;43/)M3'iDG+J&(D0/:3RU'*+,HiDQX\3-0-05UXRU'06>/2;*+82105N+XWQ/2;*+
),&('*<2/28:3RU'/ Q RN<CRN&(5o3/+,H=[&(/2;*+.82LRN<+>),&(105NHsD+-08&2+,)./+,HTRU'Q/o
&  D 3'*Hs/2;*+@3'*<2L+.8_L&(105NHTD+
:QBAfeg_;1*<E/2;*+.8+>RN<'*&T3(<<2RU69' V +.'Q/@&Yq/2;*+C(382Ro3D05N+,<uRU'p
B
<

3
2
/
N
R
<mYXRU'06/2;*+l),&('*<2/28:3RU'/MWh0 5W 5/2;*+
D
3'*<2L+.8J/&/2;*+  ~ F1
ff & 	 -08&(D05N+ V RN<@a9e
 !   hessD   <2/:3MX<>RU'/2;*+\<:3 V +).5o3(<<P&Y
	` !:(aU,fGBBsm@sD`
),& V -05N+fORU/Xi3(<D }  he  '*H0+,+,HW/2;*+w1*+,<2/2RN&('RN< 38+J/2;*+.8+E3'CsD~H0+.82RUC(3/2RN&('iY[8& V 
/C
& Y43'*Hs3E-08&2+,)./2RN&('Y[8& V /&3>^0
? YnWQ<21*):;/2;43/qYn&(835U5  7&Y/2;0RN<H0+.82RUC(3/2RN&('s+.RU/2;*+.8+,w1435
/&Zt&(8_&(D0/:3RU'*+,HTDQXi3'sR VV +,HORo3/+
D~H0+.82RUC93/2RN&('7WQYn&(835U)
5   &Y7/2;0RN<_H0+.82RUC(3/2RN&('FH0+.82RUC+,HiY8& V 
JPN L /&   W*/2;*+.8++fORN<2/<
DQX3'B\~H0+.82RUC93/2RN&('7W*Yn&(835U5}),&('*</28:3RU'Q/
W0Yn&(835U5-08&2+,)./2RN&(
' Y8& V
3'U\~H0+.82RUC93/2RN&('FY[8& V Y /&\3\^0#
? Y  3'*H3>-08&2+,)./2RN&(g
' aY8& V
@/8
& Y  <e /M
e  JON L "Q
3'*HT/2;*+u5N+.'069/2;*<J&Yh35U57H0+.82RUC93/2RN&('*<38+E-&(5UX'*& V Ro35RU'T/2;*+@<2R M+E&Y{/2;*+ERU'0-010/Me!r;*+.'* " OW0&('*+
&(D0/:3RU'*<J2D   !W4/2;1*<J/2;*+ `	 ),& V -05N+./+.'*+,<<Me
|7+./_1*<-G&(RU'/&(10//2;43/MWL;*+.8+M3(<RU'T6+.'*+.8:35)M3(<+9WH0+,HO1*)./2RN&('FRN< V &(8+uHOR ).105U/_RU's2\=/282105UX
10'*H0+,).RNH*3D05N+A\/2;43'RU'D=[<+ V R~H0+,).RNH*3D05N+AfW_/2;*+),&('QC+.8<+;*&(5NH0<ZY[&(8/2;*+F-4382/2RN).105o38i)M3(<+F&Y
8:3'06+f~$8+,<2/282RN)./+,H82105N+,<Me



d

$





>~

>~

K* { $

* | 



G

v { $


* | 

F


T 
6
e

. 

$-,


 Y  l

O


fi M]|9M.tM=uwuMM3
 F

q

h    {3M|{3 M}h	A{% }A
z'*+ V 3,X),&('*<2RNH0+.8u/2;*+>)M3(<:+>L;*+.8+'*&(/u&('05UXF82105N+,<D010/@35N<&),&('*<2/28:3RU'/<P38+>8+,</282RN)./+,He|7+./u1*<
*8<2/J),&('*<2RNH0+.8/2;*+ V +M3'0RU'06(Y105{)M3/+.6&(82XF&Y{'*+.6Q3/2RUC+P),&('*</28:3RU'Q/<Me

p

< 

q

hy|My



   y $  }$ynu{ My}$	A{%
fNBPsD(fig=fBi9*@:Gn9[M?Z90f[2(46

}A

eT[(OG9:uBBG[[99lO

K$72D*4:2(B!H!:(aU,W5
_K*{:2(B  !m(aN.W5
2\:$7
 2D** NNGK$7 2D*4 :!Ua2QfNfYRF:2(B,fZM!Q2,[fU5
2D*
 |  2f\(0@MfZ'!mQ2.nQfNW5
2\K*}
 { $ (a>sD* |  f\([B@:a2.nQfNW5

V _
V
V
V
V

2MmW
!! 1!m(aN.fGf:m_

`

K{$ Av
K* { $

7p
4@Y[8& V   ~),& V -05N+./+.'*+,<<J&Y{-08&m+,)./2RN&('F):;*+,)K~
RU'06=/2;7e*cAfe
 !:(aU,fGBBZm_ }  /2;0RN<J-08&(D05N+ V )M3'IDG+E+fO-08+,<<+,H3(< RN<JRU/J/2821*+E/2;43/
 )M3'D+F-08&m+,)./+,HRU'Q/&k3'*H/2;43/\'*&),&('*<2/28:3RU'Q/T&YE)M3'D+F-08&m+,)./+,HRU'Q/&k
/2;1*<
D+.5N&('06<I/&  1
e u&ML 5N+./I1*<),&('*<2RNH0+.8/2;43/I),&('Q/:3RU'*<S&('05UX&('*+j),&('*</28:3RU'Q/Me  8+,HO1*)./2RN&('
Y[8& V  ~^!g /&
 =[<:+,+TYme R$e/2;*+F-08&&Y@&Y@/2;7eAl-08&MCRNH0+,<s3t<2/28:3RU69;Q/mYn&(82L38H8+f~
HO1*)./2RN&('kY8& V ,u((Z,u /&_7 }  =[<+,+\Yme R$e  3-43(HOR V RU/282RN&(17W`Mb9bdAfWh/2;Q1*<l/2;*+
  ~),& V -05N+./+.'*+,<<Me
.lM !2.nQf [	 :l2!\:
7p
4
 Jg}&E-08&MC+/2;*+_RU'*),&('*<RN<2/+.'*).X&Y3E@EW(L+ V 1*<2/
*'*H<& V +CRN&(5o3/2RN&('&Y3E),&('*<2/28:3RU'Q//2;43/!LRU5U5*'*+.C+.8!DG+_8+,</&(8+,He!10/!'*&ECRN&(5o3/2RN&('&Y73u'*+.6Q3/2RUC+
),&('*<2/28:3RU'/})M3'>+.C+.8}DG+h8+,<2/&(8+,Hi=pY1082/2;*+.8}82105N+]3-0-05URN)M3/2RN&('*<})M3'&('05UX@3(H0HPRU'OY[&(8 V 3/2RN&('7W/2;Q1*< V &(8+
-&9<<2RUD05N+J-08&2+,)./2RN&('*<MWO3'*Hi)M3'0'*&(/8+ V &MC+u/2;*+).105U-082RU/&('*+Afe]^&L+u&('05UX;43,C+/&P-08&C+/2;43/&('*+
),&('*<2/28:3RU'/u&Yhj)M3'D+PH0+,HO1*),+,HY8& V $n+
 *)
 4fRU/RN<u3<+ V R~H0+,).RNH*3D05N+l-08&(D05N+ V e  a2.nQf [	 :
mSG   Yn&(5U5N&MLJ<L+ V 1*<2/u-08&MC+l/2;43/E)M3'yDG+H0+,HO1*),+,HIY[8& V $n+
 *)
 4fWD010//2;43/
'*&\),&('*<2/28:3RU'/&Y{)M3'7e
g_;*+j382691 V +.'/<-08&CRU'06<+ V R~H0+,).RNH*3D0RU5URU/X&YH0+,HO1*)./2RN&('RU'2D3'*H10'*H0+,).RNH*3D0RU5URU/X&Y
H0+,HO1*)./2RN&('RU'F2CDj38+E/2;*+P<B3 V +>3(</2;*+@&('*+,<J1*<:+,HTRU'F/2;*+@-08&&Y!&Y!g_;7e7`MOe
g_;*+8+,<2/282RN)./2RN&('/&j'*+.6Q3/2RUC+S),&('*<2/28:3RU'/<TH0+,).8+M3(<+,<T),& V -05N+fRU/X&YP-08&(D05N+ V <TRU'/2;*+I

&
0
H
+.5$WD010/RU/_H0&+,<'*&(/;*+.5U- V 1*);I3(<<:&&('F3(<]82105N+,<38+RU'QC&(5UC+,HW0<2RU'*),+/2;*+,<+-08&(D05N+ V <_8+ V 3RU'
V
10'*H0+,).RNH*3D05N+9e%& V D0RU'0RU'06t8:3'06+F8+,<2/282RN)./+,H82105N+,<\3'*H'*+.6Q3/2RUC+I),&('*<2/28:3RU'Q/<W]L+I&(D0/:3RU' V &(8+
RU'Q/+.8+,</2RU'06i),& V -05N+fORU/XF8+,<2105U/<M

v$G*{ $



Tl

K* { $
{$ Av

K* { 

p



 q  <      
& 

Bf[f[M2sBNB(aiGnQ9['?(Z(0.[m(4>(a2f,f4O[G9UMQ2MW
V 2\K{$7pAv429\fZ!`1!m(aN.W5
 { $ 29\f  !9GU.5
V 2\K*}
 |  (a>CD7K* {  ( ` !:(aU,W5
V 2D*
hy|My





y $

 [



 y|

$-%-

{%}

}hy|M{ y

|M}h	A{% }A

ps(*;:2(QS!

fi

condition

frontier

3MfiuM%

mandatory part
1

1
2

2

"<

<

2
3

3

1

1

1

3

3

U

2



U

 S $ C4

D+$ C4

3

2

1

1

U
K{$7pAv4/&3l8+,</282RN)./+,HID7GK$GK*}{$
<

o$ E4

2
3

2
3

x{RU69108+\`McO!g8:3'*<mYn&(8 V 3/2RN&('Y[8& V

2MmW  '*),&('*<2RN<2/+.'*).XRU't2\3(H V RU/<Z3T-G&(5UX'*& V Ro35),+.82/2R4)M3/+9Wq3IH0+.82RUC(3/2RN&('=[&Y-G&(5UX'*& V Ro35

5N+.'069/2;aAY[8& V 5N+M3(HORU'06I/&F3s698:3-0;RU'/&TL;0RN);3s),&('*<2/28:3RU'/>&Y])M3'DG+l-08&2+,)./+,HW3'*HS/2;0RN<
-08&2+,)./2RN&('7e  '*),&('*<2RN</+.'*).XRN<u/2;Q1*<ERU'  W3'*HS),& V -05N+./+.'*+,<<uY[&(5U5N&LJ<uY8& V /2;*+l-4382/2RN).105o38P)M3(<+
L;*+.' RN<P+ V -0/Xeix*&(8>H0+,HO1*)./2RN&('7W{L+ V 1*<2/P-08&C+\/2;43/P'*&F),&('*<2/28:3RU'/)M3'tD+H0+,HO1*),+,HY[8& V
$n+
 *)
 4fWQD010/!/2;43/)M3'7eq^&E/2;*+_-08&(D05N+ V RN<hRU'  ex*&(8q),& V -05N+./+.'*+,<:<MW8+ V 382Kl/2;43/!/2;*+_-08&(D05N+ V
RN<J<2/2RU5U57),& V -05N+./+>L;*+.'KRN<+ V -0/Xt=[g_;7eJ`  Afe
g}&-08&C+E/2;43/_D }  SLRU/2;s8Me 8Me!82105N+,<3'*Hi'*+.6Q3/2RUC+E),&('*<2/28:3RU'/<RN<  ` ~),& V -05N+./+9W

L+yLRU5U5u*8<2/F<2;*&L/2;43/TRU/sDG+.5N&('06<T/&  ` WJ/2;*+.'+fO;0RUD0RU/I3t8+,HO1*)./2RN&('Y[8& V 3 _ ` ~),& V -05N+./+


-08&(D05N+ V /&ZRU/<),&~$-08&(D05N+ V D7G G }  =[<2RU'*),+P),&~ ` 0 _` Afe
2DG   ),&(828+,<-G&('*H0</&I/2;*+i5o3'0691436+sff
 " mW]p _ D _   $M]*y_ D *y_  4>nQW{L;*+.8+ ]
+.'*),&H0+,<Z3'RU'*<2/:3'*),
+ $$~ $n+
 *)
D *m
 4y4Z&YJ/2;*+-08&(D05N+ V Wq3'*Q
H $M]*y_ D *y_  4 i  R
Y _ D +.'*),&H0+,<l3'GD~
H0+.82RUC93/2RN&('Y[8& V /
&   3'*Hk3-08&2+,)./2RN&('Y[8& V  /J
&   Wq3'*
H _  +.'*),&H0+,<3 V 3-0-0RU'06Y[8& V
<& V +s),&('*<2/28:3RU'Q/&YJ/
& Y]/2;43/lRN<'*&(/\3F-08&2+,)./2RN&('='*&(/+i/2;43/lRb
Y YH0&+,<l'*&(/lCRN&(5o3/+T3'QX
),&('*<2/28:3RU'/MW*/2;*+.'I'*&Z698:3-0;RU'F/2;*+PH0+.82RUC(3/2RN&('IY8& V /&   H0&+,<BAfe
rt+k+f;0RUD0RU/S'*&L 38+,HO1*)./2RN&('Y8& V /2;*+k6+.'*+.8:35ZG 7
4 -08&(D05N+ V /&D7G
G }  LRU/2;8Me 8Me82105N+,<F3'*H'*+.6Q3/2RUC+S),&('*<2/28:3RU'Q/<Me|7+.J
/ $n+
 *mq
 " m rn4D+y3'RU'O~
<2/:3'*),+u&Y 7p
4=LPe 5$e&0e 6*eUWOL+u8+,<2/282RN).//2;*+u-08&(D05N+ V /&),&('*<2RNH0+.8&('05UX&('*+u-&9<2RU/2RUC+
),&('*<2/28:3RU'/BAfetg_;*+s/28:3'*<mY[&(8 V 3/2RN&('L+s),&('*<RNH0+.8lD010RU5NH0<\3'kRU'*<2/:3'*),+T&Y2DG G  
$$o
 $ C4 $n+
 *)+
D $ E4*m S $ C4y4y4P3(<@Yn&(5U5N&MLJ<ert+\)M35U5/2;*+@fm(a[nfF&Y/2;*+-&9<2RU/2RUC+\),&('*<2/28:3RU'/ /2;*+
<+./l&Y_'*&H0+,<RU'j/2;*+\/282RU696+.8F= 5pW 5I),&(5N&(8+,HjDXjAE;43MCRU'063/>5N+M3(<2/l&('*+\'*+.RU69;DG&(8ZRU'j/2;*+i&(D05URU6Q3~
/2RN&('7ePg_;*+ZH0+f*'0RU/2RN&('t&Y),&(5N&(8+,HS698:3-0;*<ER V -05URN+,<E/2;43/EY[8&('Q/2RN+.8E'*&H0+,<P38+l),&('*),+.-0/@'*&H0+,<=/2;*+.RU8
'*+.RU69;QD&(8<i38+I/2;Q1*<8+.5o3/2RN&(''*&H0+,<BAfe|7+./1*<\H0+.'*&(/+F/2;*+,<+sY[8&('Q/2RN+.8i'*&H0+,<D
X I* F6F6F * K eg_;*+
+.C&(5U10/2RN&('S82105N++
D $ E4_;43(<Yn&(8;QX-&(/2;*+,<2RN<u/2;*+>/282RU696+.8E&Y WG3'*HIYn&(8),&('*).5U1*<2RN&('t3\8+.5o3/2RN&('y'*&H0+
/X-+,
H 8 4WGL;*+.8r
+  "FRN<@3\'*+.L K ~382X8+.5o3/2RN&('/X-+RU'*),& V -438:3D05N+LRU/2;t35U5h&(/2;*+.8E/X-+,<Me
g_;*C
+ 7M'*+.RU69;DG&(8@&Yq/2;0RN<'*&H0+RN</2;*+>),&('*),+.-0/E'*&H0E
+ :eu%;*+,):K/2;43/+
D $ E4RN<u38:3'06+8+,<2/282RN)./+,H
82105N+9eqg_;*+E'*+.6Q3/2RUC+P),&('*</28:3RU'Q/J S $ E4RN<_/2;*+@<210D0698:3-0;&Y ),& V -&9<+,HI&Y{RU/<J&(D05URU6Q3/2RN&('= XJ D L 4
3(H0H0+,HyLRU/2;S'*&H0+,<E&Y]/2;*+Y[8&('Q/2RN+.8P3'*Hy/2;*+>8+.5o3/2RN&(''*&H0+>/X-+,
H  "aW45URU'0K+,HS/&i/2;*+Y8&('/2RN+.8
'*&H0+,<JRU'/2;*+<:3 V +@L_3,X3(<u3DG&C+9ex}RU'435U5UXW4/2;*+l^0? o
 $ C4RN< V 3(H0+&Y!&('*+>8+.5o3/2RN&(''*&H0+P/X-+,H
 "i3'*HFRU/<'*+.RU69;DG&(8<JY8&('/2RN+.8'*&H0+,<Me!g_;0RN</28:3'*<mYn&(8 V 3/2RN&('RN<JRU5U5U1*<2/28:3/+,HFRU'x{RU6*e`McOe

K* { 

K* { $
K$ K* { $




K$ 2D*

$ K* { $
K AD*
U
U U
M

U

7





U

U

7

$-M

(

7

U

4
K$ Kv { $
d

U

fi M]|9M.tM=uwuMM3
 F

K AD*

re 5$e&0e 6*eEL+l)M3't3(<<21 V +/2;43/@RN<uRU828+,HO10'*H*3'Q/MRU'/2;43/@)M3(<+9WG 7p
4RN<E<2/2RU5U5
_ ` ~),& V -05N+./+@=[<+,+]/2;43/}/2;*+/28:3'*<mYn&(8 V 3/2RN&('Z1*<+,H>RU'/2;*+]-08&&Y4&Yag_;7ecJ-08&HO1*),+,<!3'>RU828+,HO10'*H*3'Q/


698:3-0;gPAfeu&ML<210-0-&9<+/2;43/j$n+* E4]RN<_),&('*<2RN<2/+.'/MhRU/ V +M3'*<_/2;43/+.RU/2;*+.8_/2;*+/282RU696+.8&Y H0&+,<
'*&(/u-08&m+,)./RU'Q/&FWG3'*HRU'/2;43/E)M3(<+9Wa/2;*+P82105N+D+$ E4JLRU5U5'*+.C+.8u-08&HO1*),+/2;*+'*+,+,H0+,HQ3 
'*&H0+9Wa&(8u+.C+.82Xj=[+fRN<2/2RU'06A-08&m+,)./2RN&('S&Yq/2;*+>),&('*HORU/2RN&('S&Y RU'Q/&T
 "$n`
 4J)M3'D+>+fO/+.'*H0+,H
/&>3E-08&2+,)./2RN&('i&Y 3(<]3EL;*&(5N+9e]^&P+.C+.82X3-0-05URN)M3/2RN&('s&Yr
D $ E4{-08&HO1*),+,<3ECRN&(5o3/2RN&('i&YG S $ E4fe
 $ C4_)M3'0'*&(/D+@H0+,HO1*),+,HFY[8& V /2;*+@K'*&ML5N+,HO6+D43(<+9e_%&('QC+.8<+.5UXWG<210-0-&9<+E/2;43/
 'IDG&(/2;I)M3(<:+,<uo
 G~$CRN&(5o3/+,< \W/2;*+.'k/2;*+i3-0-05URN)M3/2RN&('&Y,+

D $ C4uYn&(5U5N&MLRU'0J
6 -08&HO1*),+,<l3I698:3-0;j/2;43/ZH0&+,<>'*&(/
CRN&(5o3/+Ela
S $ C4fW*3'*HFL+P)M3'H0+,HO1*),+o
 $ C4fe
g_;*+I3D&MC+T/2;*+,&(8+ V <2;*&LJ<\3yH0+,).8+M3(<+TRU'),& V -05N+fRU/XL;*+.'6+.'*+.8:35-&9<2RU/2RUC+F),&('*<2/28:3RU'/<
38+S8+,<2/282RN)./+,H/&'*+.6Q3/2RUC+&('*+,<Me 7p
4Y$35U5N<sY8& V _` /&),&c~   3'*HWL;*+.'

35N<&i),&('*<2RNH0+.82RU'06i8:3'06+>8+,<2/282RN)./+,H82105N+,<MW*2\ 7p
4Yn35U5N<JY8& V _ ` /&i  W3'*HID7G

  Y$35U5N<Y[8& V `	 /& ,` e  /\L&(105NHDG+IRU'Q/+.8+,<2/2RU'06k/&j+fO;0RUD0RU/-4382/2RN).105o38T)M3(<+,<&Y

),&('*<2/28:3RU'/<MW V &(8+Z6+.'*+.8:35!/2;43''*+.6Q3/2RUC+&('*+,<MW7/2;43/ V 3K+Z/2;0RN<@),& V -05N+fRU/XY$35U5hRU'Q/&TRU'/+.8 V +f~
HORo382XF).5o3(<<+,<P=DXT+f*3 V -05N+P  3'*H ` Y[&(8_7 7p
4{AfeJ^& V +P<2X'Q/:3()./2RN)@8+,</282RN)./2RN&('*<

L+uH0+f*'*+,HY[&(882105N+,<38+6&&H)M3'*HORNH*3/+,<Mh/2;*&(1069;F3E*'0RU/+u+fO-43'*<2RN&('s<:+./&Y7),&('*<2/28:3RU'Q/<_;43(<'*&
<+.'*<+9W5N+./q1*<]),&('*<2RNH0+.8m(Q2ff[f[,\(0.[m9p4.eh|7+./]1*<]35N<:&PH0+f*'*+>(p.9*G2,(*f[2(pa
3(<E),&('*<2/28:3RU'Q/<EL;*+.8+l/2;*+l/282RU696+.8P3'*Hy/2;*+&(D05URU6Q3/2RN&('j38+'*&(/@),&('0'*+,)./+,H7<21*);),&('*<2/28:3RU'/<@RU'O~
).5U1*H0+@/2;*+ /&(-&(5N&(69RN)M35),&('*<2/28:3RU'/< P1*<+,HTRU'=[RU'*+M31RN<<:3(&(10R$W`Mb9b9Afe
g_;*+]Y[&(5U5N&LRU'06E-08&(-G+.82/XP;0RU69;05URU69;Q/<h/2;*+8+.5o3/2RN&('*<2;0RU-*<h&Y*/2;*+,<+-4382/2RN).105o38h)M3(<:+,<LRU/2;l'*+.6Q3/2RUC+
),&('*<2/28:3RU'/<M



U


U



U

U

v { $



U

U

T

M

U



K{$ Av
K{$ Av

K AD*



5





yn
  n9[M ?l(*f[2(pa@(O(.[[,U(>M>2P9s2(S!Bf[fn,2F(*f[2(pa
(as(p.9*G2,I(0.[m9p4W5



2MmW Pu<E'*&(/2RN),+,HtRU't<:+,)./2RN&('jvOW}3s'*+.6Q3/2RUC+\),&('*<2/28:3RU'/>RN<P+,w10RUC935N+.'Q/P/&I3s-&9<2RU/2RUC+),&('*<2/28:3RU'/
L;*&9<+F&(D05URU6Q3/2RN&('RN<),& V -&9<+,H&YE&('*+F),&('*),+.-0/\'*&H0+T&YE/X-G+m " T 0W]L;*+.8+*8 "yRN<
RU'*),& V -438:3D05N+lLRU/2;S35U5h&(/2;*+.8u/X-G+,<E3'*HH0&+,<'*&(/u3-0-+M38RU'3'QXy^0?+f0),+.-0/RU'=RU/RN</2;Q1*<@3
HORN<),&('0'*+,)./+,Hs),&('*<2/28:3RU'Q/BAfeqre 5$e&0e 6*eh/2;0RN<]'*&H0+)M3'D+5o3DG+.5N+,HDQX3'iRU'*HORUCRNHO1435 V 382K+.8u=L;0RN):;7W
3(<9   T *W{3-0-+M38<&('05UXSRU'j7AfW}/2;Q1*<5N+M3(HORU'06/&3I),&('*<2/28:3RU'/L;0RN):;RN<>DG&(/2;jHORN<:),&('0'*+,)./+,H
3'*HF8:3'06+f~$8+,<2/282RN)./+,He

M

7

p

M



} q

hy|My

 

< 

y $

(4G2,2(0.[m(4W

]W|M}]}$yfiAyM}h	A{% }A

esOfu(4$(0(4@:9oS!

K$72D*4:2(B!  !m(aN.W5
2\K{$7pAv4k(a2\*|2.9pZaQ2.nQ.U={.GK$72D*4

V

V _

:2(B!  !m(aN.r9hO.yfUB92>2(QS!2ff[f[,5

* | 

V 2D   f\(0MfZ'!mQ2.nQfN=fOi29\f  ` !m(aN.B9hOffNBt(
2(S!Bf[fn,25

K* { $

V 2CD } 
2(S !Bf[fn,25

f\(0aQ.[QQfN=t.(B ` !9GU.9hOffUB(


$-A

fi

$ 2D*

3MfiuM%

2MmW y:
7
*D+.5N&('06<Z/&y  W!<2RU'*),+sL+ V 1*</-08&MC+T/2;43/lY[&(8&('*+T),&('*<2/28:3RU'/
/2;*+.8+yRN<F3t-08&2+,)./2RN&('&Y>RU/<s/282RU696+.83'*H'*&k-08&2+,)./2RN&('&YRU/<s&(D05URU6Q3/2RN&('7e %& V -05N+./+.'*+,<<TRN<
-08&MC+,HyLRU/2;S3\8+,HO1*)./2RN&('Y8& V ^!g
E^!g=n3(<RU'-08&&Y]&Y]g_;7e`  Afe
7p
4RN<
/2;Q1*<),&~  ~),& V -05N+./+9e
82691 V +.'Q/<Y[&(810'*H0+,).RNH*3D0RU5URU/XI&Y!G 
4]WaG   k3'*HI2CD 
  !W73(<L+.5U5h3(<u<+ V R~H0+,).RNH*3D0RU5URU/XS&YqD7G   hW38+>/2;*+<B3 V +l3(<RU'/2;*+-08&&Y]&Y
g_;7e7`MOh/2;*+P),&('*</28:3RU'Q/<L+@1*<+,HTL+.8+35U8+M3(HOXFHORN<),&('0'*+,)./+,He
r;*+.'82105N+,<Z38+\8:3'06+f~$8+,</282RN)./+,HW!G:
7p
4D+.5N&('06<>/&  L+ V 1*<2/-08&C+
/2;43/P/2;*+Z/282RU696+.8>&Y/2;*+\),&('*<2/28:3RU'/>)M3'tD+lH0+,HO1*),+,HY8& V $n+
 *)
 4fW}D010/P'*&(/@RU/<P&(D05URU6Q3/2RN&('7W{3'*H
/2;*+,<+E-08&(D05N+ V <DG+.5N&('06\8+,<-G+,)./2RUC+.5UXs/
&   3'*HI),&c~   ea%& V -05N+./+.'*+,<<),& V +,<_Y[8& V /2;*+@-4382/2RN)f~
105o38)M3(<+EL;*+.8+9 RN<+ V -0/XeqG 7
4RN</2;1*<),&~  ~),& V -05N+./+9e
2DG   DG+.5N&('06<E/& ` L;*+.'S82105N+,<uRU'QC&(5UC+,H38+>8:3'06+f~$8+,<2/282RN)./+,Heg_;*&(1069;/2;0RN<

-08&(-+.82/XjH0&+,<l'*&(/l3-0-+M38lLRU/2;3'kR VV +,HORo3/+Yn&(8 V 105o3/2RN&('&YJ/2;*+i-08&(D05N+ V W!RU/lDG+,),& V +,<l&(DO~
CRN&(1*<L;*+.'/2;*+i-08&(D05N+ V RN<l</:3/+,H3(<Yn&(5U5N&MLJ<M H0&+,<l/2;*+.8+T+fRN</Z3<+,w1*+.'*),+i&Y698:3-0;*<
 "
 N * F6F6F *r * Q W{L;*+.8+T
 "  N * F6F6F *r RN<l3'D~H0+.82RUC93/2RN&('3'*
H  Q D RN<>/2;*+iHORN<[m&(RU'/
D
10'0RN&('t&1
Y  3'*H XJ D L W73s-08&m+,)./2RN&('Y[8& V /
&  3'*Ht3s-08&2+,)./2RN&('SY8& V XJ D L /&I3F^0?  G W
I \ K \ U

 IT<21*);/2;43/lY[&(8Z+.C+.82Xt698:3-0
;  ,*
I \q K 0W N0f6RTY[&(8Z+.C+.82X V 3-0-0RU'0B
6 &Y XJPN L
RU'Q/g
&  m)
W kRN<u'*&(/>3i-08&m+,)./2RN&(' :[
e u&(/2RN),+Z/2;43/E'*7
&  D+fY[&(8o
+  G RU'<21*);j3s<+,w1*+.'*),+l/282RU696+.8<
/2;*+Z),&('*<2/28:3RU'Q/s= XJON L H0&+,<E'*&(/@-08&m+,)./ERU'/g
&  A3'*Hy/2;43/>35Ua
5  2W  PK W<:3/2RN<mY[XIRU/\=[<2RU'*),+ XJ D L
-08&2+,)./<J/&  AfW0/2;1*<u35U`
5  q&Y!/2;*+P<+,w1*+.'*),+>38+>),&('*<2RN</+.'Q/M
e  Q D +.'*<2108+,</2;43/ XJ D L -08&2+,)./<
RU'Q/&\3/_5N+M3(<2/J&('*+u698:3-0;I&Y{/2;*+u<:+,wQ1*+.'*),+9WOL;0RN):;35U5N&MLJ</2;*+@3D&MC+uYn&(8 V 105o3/2RN&('&Y{/2;*+u-08&(D05N+ V e
%& V -05N+./+.'*+,<<JY[&(5U5N&LJ<Y[8& V /2;*+E-4382/2RN).105o38)M3(<+>&Y{'*+.6Q3/2RUC+P),&('*</28:3RU'Q/<Me
 8&&YY[&(8EsD   RU'/2;*+)M3(<+&Y8:3'06+8+,<2/282RN)./+,HS82105N+,<@RN<@<2R V RU5o38MERU'/2;*++f~
-08+,<<2RN&('&YG/2;*+-08&(D05N+ V 3D&MC+9W/2;*+H0+.82RUC(3/2RN&('RN<{'*&ML3
' $t1
D lfi
 4~H0+.82RUC93/2RN&('7W/2;*
+  ),&('*<2RNH0+.8+,H
38+J&('05UXZ/2;*+J&('*+,<&(D0/:3RU'*+,Hs3Y[/+.8q/2;*+3-0-05URN)M3/2RN&('s&Y73@82105N+_Y8& V D]W3'*B
H Nf6R $Yn&(8q+.C+.82X V 3-0-0RU'06
&Y JON L RU'Q/&  uRN<8+.-05o3(),+,HIDX $Yn&(8+.C+.82Xs698:3-0;I/2;43/)M3'ID+
\~H0+.82RUC+,HIY8& V  :e
'OY[&(82/210'43/+.5UXW*8:3'06+f~$8+,<2/282RN)./+,H),&('*<2/28:3RU'/<38+E/282RN):KRN+.8J/&</21*HOXG{RU'Q/210RU/2RUC+.5UXWG),&('*<2RN<2/+.'*).X
);*+,):KRU'06I<;*&(105NHD+,),& V ++M3(<2RN+.8u/2;43'LRU/2;S6+.'*+.8:35h),&('*</28:3RU'Q/<MWD010/E/2;*+l8&(5N+Z&Y]RU828+,HO10'*H*3'*).X
RN<s<2/2RU5U510'*).5N+M38Meg_;*&(1069;RU/iRN<i+M3(<Xk/&k);*+,):K/2;43/s   LRU/2;8:3'06+8+,<2/282RN)./+,H
),&('*<2/28:3RU'/<RN<3/5N+M3(<2/\  ~$;438H=/28:3'*<mYn&(8 V 3/2RN&('Y[8& V ^!g
E^!gA\3'*HL+;43,C+F-08&C+.'
=/2;*&(1069;RU/RN<J'*&(/JRU'*).5U1*H0+,HIRU'F/2;0RN<-43-+.8BA/2;43/JRU/RN<RU'B ` =R$e+9e
` AfWOL+>HORNHT'*&(/ V 3'436+P/&

+
3();0RN+.C+l3'I+f03()./),& V -05N+fRU/XF8+,<2105U/_Y[&(8/2;0RN<-08&(D05N+ V e
rt+iHORNHt'*&(/+.RU/2;*+.8 V 3'436+i/&3(<<2RU69'3I),& V -05N+fORU/Xj).5o3(<<PY[&(8>/2;*+\{. }  3'*H
s:   }  t-08&(D05N+ V <W0/2;*&(1069;D&(/2;F-08&(D05N+ V <J/282RUCRo35U5UXTDG+.5N&('06\/&   e
%& V -05N+fORU/X8+,<2105U/<]&(D0/:3RU'*+,H\RU'/2;0RN<!-43-+.838+<21 VV 382R M+,HRU'\/:3D05N+9e*`9e}rt+35N<&E-08+,<+.'/]RU'
x{RU6*e`Mb3 ),& V -05N+fORU/X V 3- E+ V -0;43(<2R ,RU'06\/2;*+E8+.5o3/2RN&('*<2;0RU-*<D+./L+,+.'I-08&(D05N+ V <Me  'T/2;0RN<*69108+9W
RY9 H0+.'*&(/+,<s3<:+./&Y@D0RN),&(5N&(8+,H698:3-0;*<S=82105N+,<i&(8i),&('*<2/28:3RU'Q/<BAfWX  W  W  8+,<-G+,)./2RUC+.5UX
H0+.'*&(/+sRU/<>8+,</282RN)./2RN&('k/&y3F*'0RU/+s+fO-43'*<2RN&('k<:+./MWh8:3'06+8+,<2/282RN)./+,H+.5N+ V +.'/<MWq&(8HORN<:),&('0'*+,)./+,H
+.5N+ V +.'Q/<e S H0+.'*&(/+,<@3i<+./u&Yq'*+.6Q3/2RUC+Z),&('*<2/28:3RU'/<Meu5U5{-08&(D05N+ V <u8+.-08+,<+.'Q/+,Ht38+),& V -05N+./+
Yn&(8P/2;*+.RU8>).5o3(<<Me  HO6+,<38+\HORU8+,)./+,HtY8& V DG&(/2/& V /&T/&(-7e'j+,HO6+ZY[8& V 3T-08&(D05N+ V  `/&3
-08&(D05N+ V   V +M3'*<\/2;43/  `TRN<\3-4382/2RN).105o38)M3(<+F&Y  Oey&(8+,&MC+.8MWRU'&(8H0+.8/2;43//2;*+ V 38+ V 3RU'*<_8+M3(H*3D05N+9W-08&(D05N+ V <_L;0RN);38+RU'Q/+.8 V +,HORo3/+ED+./L+,+.'F/L&Z-08&(D05N+ V <  `@3'*H  l&Y7/2;*+
<:3 V +),& V -05N+fORU/X).5o3(<<MWH0&T'*&(/>3-0-+M38@RU'/2;*+l*69108+9eZg_;*+),& V -05N+fRU/X&Y<21*):;-08&(D05N+ V <P)M3'
D+>&(D0/:3RU'*+,HyDQX ).5o3(<:<2RYXRU'06 @/2;*+ V RU'/2;*+;0RN+.8:38);QXeEx*&(8uRU'*<2/:3'*),+9WGD7G   kRN< V &(8+
6+.'*+.8:35G/2;43'i }  =L;0RN);sRN<&(D0/:3RU'*+,HiRY
 " A3'*H V &(8+<2-+,).R4)J/2;43'2  D7G

@ 

 | 

F

	 	
	 


U




	
	

F


l

	


	







* | 




=






* | 
@ 

K* { $




K

K$ 2D*

K* { 


K 2D*
Kv { $
Kv { $
 AD*

K AD*



6

6

M
K* { $



$-W

K* { $



Kv { $ 

F




fi M]|9M.tM=uwuMM3
 F



Z^
	
Z^] 	
Z^] 	
Z
[ 
	
Z[F] 	
Z[F] 
	
Z\!] 
	
Z[\!] 
	

[

ff

ff&
 |fi5 ff
 5 ff
  5 ff

&:; 5<2 
<"2 
<"2
&:; 5<2 
<"2

&

\

>

>

>
<2
<2 
<2 
>
&:; 5<2

>

&

>

>
>
>

>
<
"<2

[m&\

[&r\
 $

&
>
>
>
<
 
<
 
<
 
<
 
<
 

>
>
>

 5ff

 fi5 ff
  5fiff
  5ff
  5ff

]"

[&r\
] 

 $

>

 5ff
 5ff

ff5

>
ff5.&:; 5<2
"<2 
&:; 5<2 
"<2 

>

 | 5ff
5ff
 | 5ff
ff5  |
 5ff

 5ff
ff5

  5 ff
  5ff



[&r\

$  ]
>
fffi5 5ff



  5ff
ff5fi5ff

  5 ff
  5ff



g}3D05N+\`9^1 VV 382XF&Y]%& V -05N+fRU/XI+,<2105U/<

v{$=L;0RN);t3(H0H0</2;*+><+./   AfWG3'*HWG<2RU'*),+>/2;*+,<+P-08&(D05N+ V
<&ZRN<2D*
 | ! e

<@38+PD&(/2;<:+ V R~H0+,).RNH*3D05N+9W

h bS4M94"! $#;
z'*+RU'Q/+.8+,<2/2RU'06Z8+.5o3/2RN&('*<2;0RU-iY8& V 3's35U6&(82RU/2; V RN)uCRN+.L-G&(RU'/RN<LRU/2;s/2;*+E%^  Y[8:3 V +.L&(82Ke!+f~
)M35U5G/2;*+RU'0-010/_&Y{3),&('*<2/28:3RU'Q/J<B3/2RN<mYn3()./2RN&('s-08&(D05N+ V = P A!RN<3>),&('*<2/28:3RU'/_'*+./L&(82KW0),& V -&9<+,H
&Y3I<+./&Y_C9382Ro3D05N+,<MW{<+./<>&YJ-&9<<2RUD05N+\C(35U1*+,<PY[&(8P/2;*+C(382Ro3D05N+,<T=[)M35U5N+,Ht/2;*+.RU8ZH0& V 3RU'*<BA>3'*H3
<+./&Y]),&('*</28:3RU'Q/<uDG+./L+,+.'y/2;*+PC9382Ro3D05N+,<Meg_;*+>w1*+,<2/2RN&('RN<JL;*+./2;*+.8u/2;*+.8+PRN<E3<&(5U10/2RN&('y/&/2;*+
%^  W*R$e+9eq3'3(<<RU69' V +.'Q/&YhC935U1*+,</&Z/2;*+@C9382Ro3D05N+,<J/2;43/J<:3/2RN<m4+,<J/2;*+P),&('*<2/28:3RU'Q/<e
g_;*+Z),&('*<2/28:3RU'/<ERU'QC&(5UC+,HSRU'3i).5o3(<:<2RN)M35 > 38+Z<2R V -05N+.8u/2;43'&(108<MeE)./21435U5UXW P ),&(8m~
8+,<2-&('*H0</&/2;*+E_{   =-08&2+,)./2RN&('aA_-08&(D05N+ V e
^+.C+.8:35P310/2;*&(8<s'*&(/2RN),+,H/2;*+<2/28&('06+,w10RUC(35N+.'*),+yD+./L+,+.' P 3'*H
y }4
  F *7$ =$?uRUC+.'/L&y5o3D+.5N+,Hj698:3-0;*o
< 3'*H kW{RN<>/2;*+.8+T3;*& V & V &(82-0;0RN< V Y8& V 
/&
AfePu<uYn38@3(<EL+ZK'*&MLPW/2;*+l*8</u-43-+.8@&('S/2;0RN<@<210DOm+,)./EL_3(<=[x*+,H0+.8> ]38HOR$Wq`Mb9b  Afe  '
=[1069'0RN+.8MW_999A),&(828+,<2-G&('*H0+.'*),+,<s38+IH0+./:3RU5N+,HY[8& V

=$?uRUC+.'/L&k^0?EZ
<  3'*H
RN<Z/2;*+.8+3y-08&m+,)./2RN&('Y8& V /&
A/& P @Wh3'*H8+,).RU-08&)M35U5UX=[H0+.C+.5N&(-0RU'06j/2;*+I&('*+,<
-08+,<+.'/+,HTRU'S=[1069'0RN+.8J%;*+.RU'7W`Mb9b9A2Afeq|+./1*<_&(10/25URU'*+u/2;*+uRNH0+M3(<_&Y/2;*+u/28:3'*<mY[&(8 V 3/2RN&('TY[8& V
P /&
 hW)M35U5N+,H
e%&('*<RNH0+.8i3S),&('*<2/28:3RU'Q/i'*+./L&(82K
e
RN</28:3'*<mYn&(8 V +,H

RU'Q/&/L&y^0?E< 3'*H
3(<@Yn&(5U5N&MLJ<M e /28:3'*<25o3/+,</2;*+Ff[f0,[l&Y > +M3():;k
),&('*),+.-0/l'*&H0+RN<
6+.'*+.82RN)T3'*H),&(828+,<2-&('*H0<l/&y3IC(382Ro3D05N+T3'*Hk+M3();k8+.5o3/2RN&('k'*&H0+s),&(82 8+,<2-G&('*H0</&S3I),&('*<2/28:3RU'/

n {

* | 

  $


 { v$G*{ $


.

 {

   {

$ {
 { 7{*
9* T{ 


@|G*{ $

=RU/<[/2;t'*+.RU69;QD&(8>RN<>/2;*+\),&('*),+.-0/>'*&H0+\),&(828+,<2-&('*HORU'06/&F/2;*+o$/2;jC9382Ro3D05N+\&Y/2;*+\),&('*<2/28:3RU'/BAfe
8+.-08+,<+.'Q/</2;*+(*f[2(paQ	 <q*[[[(*fh/2;*+.8+PRN<&('*+@RU'*HORUCRNHO1435{),&('*),+.-0/'*&H0+uY[&(8+M3();C935U1*+
&Y_3sC9382Ro3D05N+\H0& V 3RU'7W{3'*H&('*+Z8+.5o3/2RN&('t'*&H0+lYn&(8P+M3();j/210-05N+&Y_),& V -43/2RUD05N+C935U1*+,<MeZ&(1069;05UX
<:3RNHWG/2;*+.8+lRN<P3<:&(5U10/2RN&('y/&
RY]/2;*+.8+lRN<@3 V 3-0-0RU'06iY[8& V C(382Ro3D05N+,<\=[),&('*),+.-0/E'*&H0+,<@&
Y PA/&

C935U1*+,<i=[),&('*),+.-0/>'*&H0+,<>&Y Au/2;43/<:3/2RN<24+,<@/2;*+),&('*<2/28:3RU'/<s= V 3-*<>8+.5o3/2RN&('j'*&H0+,<>&YH&('/&
8+.5o3/2RN&('k'*&H0+,<&Y AfW0 5W 5T3F-08&2+,)./2RN&('tY[8& V /& keig_;*+i<:3 V +\8+,<105U/P;43(<>D+,+.'3():;0RN+.C+,H
RU'*H0+.-+.'*H0+.'Q/25UXFRU'I/2;*+@_/2/282RUD010/+,HS?u8:3-0;y?u8:3 VV 38Yn&(8 V 35URN< V DXFJ1*H0&(5YJ=m`Mb9b9cAfe





0

 {

$ 2D*

z'*+\),&(105NH35N<&F<+,+ P 3(<3s-4382/2RN).105o38)M3(<+&Y_ 7
*>RU'*H0+,+,HW/2;*+.8+RN<>3
-08&2+,)./2RN&('Y[8& V 3s^0?RU'Q/&T3i^0?
RY]3'*H&('05UXFRY
<:3/2RN<m4+,</2;*+>-&9<2RU/2RUC+),&('*<2/28:3RU'Q/uLRU/2;
3'+ V -0/Xs/282RU696+.8u3'*H3(<RU/<&(D05URU6Q3/2RN&('7e



2

$-

fi

3MfiuM%

Z[\%]41A2*/

3 014%&657*/1,8%9

Z[F]  C*=>A2&

Z[F]  41A2*/

2>:(+* ;<*/1,81%9
Z[F]  B*/>A2&

Z[EDGFH4\!]41A2*/ :(+*-;<*=1,81%9
Z[41A2*/

Z J [\ L DGFH ]41A2*=

;<*=1,81%9

Z[ED9FH4]  C*/>A2&
$ %'&)(+*-,%.*/0,01.2&



Z[ID9FHJ41A2*/

Z[  \ c ]41A2*/

 



  
Z[  ]41A2*/
Z8^]41A2*=
Z8^] B*/>A2&

Z[  \#] 41A2*/
Z\ c ]  41A2*/

? 



 



? 

 

Z[ \  ]  41A2*/



2; $

Z[  ]C*/CA2&

Z[  ]K41A2*/

Z8^] C*/CA2&
2@ $

Z[  ]  B*/>A2&

; $

Z^]  41A2*=
Z[  41A2*/
Z8^
41A2*=

Z^]  B*/>A2&

x{RU69108+\`MbO%& V -05N+fORU/XF+,<2105U/<q3\?E+,&(698:3-0;QX

A



@ $

fi M]|9M.tM=uwuMM3
 F

u&MLPWRU'&(8H0+.8T/&H0+M35uLRU/2;RU'*),& V -05N+./+SK'*&L5N+,HO6+yxa38269RN+.8T+./F35$eE=m`Mb9b9AMLT+f/+.'*H/2;*+
% ^  Y8:3 V +.L&(82K/& V RO+,H~%^  e  '3 V R0+,H~%^  /2;*+<:+./i&YPC9382Ro3D05N+,<iRN<sH0+,),& V -&9<+,HRU'/&

),&('Q/28&(5U5o3D05N+T3'*HS10'*),&('Q/28&(5U5o3D05N+iC9382Ro3D05N+,<MW<:3MX 3'*HFeZg_;*+s|NPOX>f,uRQTSGU)VTWfiX1Y[Z)\9]+\

^`_ X1a _ X1S6ZbVTcedfZS9ghYPcji+XkKlJm`nKopcfi\rqU)ds\9cfi\9aGX1dta2u ^`_ cfiq _ q2ZdvVX6SGXw>U)S9YyxTWZaGXkzZ)\`w>U)WeWfiU ^ \2{|cfi\}cea~a9S9xsX
a _ ZayX1X1S9gz\GU)WexTa9cfiU)daGUha _ X\9xTVTdsX1a ^ U)S9]cedsk+xsqXkVtgq2ZdVXPXiKaGX1dskTXkaGUZM\GU)WexTa9cfiU)dUwa _ X
^`_ U)WfiXdsX1a ^ U)S9] IrlJnKcfi\`\ _ U ^ daGUVX6lBqU)YPQTWfiX1aGX
I _ cfi\`SGX\9xTWea`QTSGUcfikTX\~xs\}ZdsU)a _ X1S
QTSGUKUwUw`  lBqU)YPQTWfiX1aGX1dsX\G\yw>U)S6|lBqU)ds\9cfi\9aGX1dsq1gdskTXXkuZdgzYPcji+XkKlJm`nKoq2ZdVXba9SZds\9WZaGXk
cedtaGUZdceds\9aZdsqXzUwy'sfE\9cedTa _ X)[SGXk+xsq1a9cfiU)dkTX\Gq1S9ceVXkZVU2X
u}a _ X
YPcjiTXkKlJm`nKocfi\YZQTQXkaGUnT\h[Zdskcfi\a _ X1dpQTSGUcfikTXk ^ cea _ a ^ UqU)WfiU)SG\u`
cecedTZ
QU
\9cea9ceXIqU)ds\9a9SZceda<Pu ^`_ U
\GX<a9S9ce
X1Scfi\a _ XI\9xTVT
SZQ _ qU)S9SGX\9QU)dsk+cedT}aGU~a _ X\9xTVTdsX1a ^ U)S9]cedsk+xsqXk
Vtgh _ XYPcji+XkKlJm`nKocfi\bqU)ds\9cfi\9aGX1dacjwrZdskU)dTWegcjw}\Za9cfi\9fX\bv7ces
vceWeWexs\9a9SZaGX\a _ cfi\
a9SZds\w>U)S9YZa9cfiU)dE _ X6qU)ds\9a9SZceda}dsX1a ^ U)S9]Mcfi\~qU)YPQU
\GXkhUw7a _ Xa ^ UP
ZS9cZVTWfiX\GX1aG\22` 
Zdsk     Zdska _ SGXXqU)ds\9a9SZcedaG\v  u}  Zdsk|"  Zdsk  _ ZX\ZYXkTU)YZced
t)yKy  Zdskz>yZdsk  _ Z2XP\ZYXbkTU)YZcedy   _ XPqU)ds\9a9SZcedakTXsdTcea9cfiU)ds\ZSGXb
ceX1dced
a _ Xs
xTSGX
IrWeWqU)dsqX1QTa}agQX\}ZSGX6\9xTQTQU
\GXkhaGUbVXcedsqU)YPQfZSZVTWfiX




 



e

+

b a
a b

b 2 2
b 1 3
a 1 1

>


7


 

1

 
 

1

C

2

2

1

1 


 2
fiG

2

1
1
2

<

3

fi

fi 

3
1

1
1

<

2



2
2

1

7

3

2

>



2
3

  

fiKG

a 2
b 1



C
H

C

ce
xTSGX
+{SZds\w>U)S9YZa9cfiU)dvwSGU)YBIrlJnKaGUb|'sf
 X1ayxs\6SGX1WZaGXU)xTSkTXsdTcea9cfiU)ds\aGUvU)a _ X1SkTXsdTcea9cfiU)ds\UwqU)ds\9a9SZcedtaG\ywU)xTdskzceda _ Xm`RWeceaGX1SZl
a9xTSGX
rxTS~qU)ds\9a9SZcedaG\yWfiX1a`xs\`q2ZWeWa _ X1YnTrlBqU)ds\9a9SZcedaG\`ZSGXZQfZS9a9cfiq1xTWZS}q2Z)\GX6Uw7a _ XYPcedTceYZW
kTX\Gq1S9ceQTa9ceXqU)ds\9a9SZcedtaG\kTXsdsXkvcedceVTcfiXX1aZWCeu2

{`ZbYPcedTceYZW<kTX\Gq1S9ceQTa9ceXqU)ds\9a9SZcedtaq2Zd
VX~\GXX1dZ)\|Z6\GX1aEUwnTrlBqU)ds\9a9SZcedaG\ ^ cea _ a _ X~\ZYX}a9S9ce
X1S2tceaG\Ecedta9xTcea9ceX\GX1YZdta9cfiq\cfi\<Bcjw _ U)WfikT\
\GUYyxs\9a~  U)S  U)S6ee2nT\Za9cfi\fX\`ZYPcedTceYZWkTX\Gq1S9ceQTa9ceXqU)ds\9a9SZceda`cjwcea\Za9cfi\fX\~Za
WfiX2Z)\9a|U)dsXrX1WfiX1YX1daUwa _ X\GX1a2<U)aGX~a _ Za|a _ X`k+cfi\xTdsq1a9cfiU)d+rkTUKX\IdsU)a|cedsq1SGX2Z)\GXra _ XrqU)YPQTWfiXi+ceaBgUw
a _ XqU)ds\9cfi\9aGX1dsq1gbq _ Xq]SGX1WZa9ceXaGUnTrlBqU)ds\9a9SZcedaG\2 _ XQTSGUKUwUwa _ XU)SGX1YbqU)YPQTWfiXi+ceaBgPUwf|
'sf7rq2ZdVX6xs\GXkvaGU\ _ U ^ a _ ZaqU)ds\9cfi\9aGX1dsq1gUwYPcedTceYZW<kTX\Gq1S9ceQTa9ceXqU)ds\Ga9SZcedtaG\cfi\
ZWfi\GUr lBqU)YPQTWfiX1aGX
IceVTcfiXX1aZWC2

 _ Z2X}QU)cedtaGXkMU)xTaa _ ZaYPcedTceYZWkTX\Gq1S9ceQTa9ceXqU)ds\9a9SZcedaG\
X1dsX1SZWece2XYU
\9abqU)ds\9a9SZcedtaG\w>U)xTdskceda _ Xhm`WeceaGX1SZa9xTSGX
z`q1a9xfZWeWegua _ X\XWZa9aGX1SPqU)ds\9a9SZcedaG\
ZSGXyZWfi\GUbQfZS9a9cfiq1xTWZSq2Z)\GX\}UwEnTrlBqU)ds\9a9SZcedaG\'w>U)S`ceds\9aZdsqX
uZ)\}ZWeSGX2Z)k+gMdsU)a9cfiqXkusa _ X6aGU)QU)WfiU)
cfiq2ZW
qU)ds\9a9SZcedaG\`xs\GXkVtgvcedsX2Zxvcfi\\Z)U)xTcCu2

 ZSGX6k+cfi\qU)dTdsXq1aGXkvnTrlBqU)ds\9a9SZcedtaG\  X1axs\`Z)kTk
a _ Za2u7ceda _ X\GXMm` ^ U)S9]K\u7qU)ds\Ga9SZcedtaG\PZSGXxs\GXkaGUvq _ XqG]qU)ds\9cfi\GaGX1dsq1gUwrnT\y\GU)WfiX1WegZdskdsU)a


	fifffffi	fi!fi#"%$&	fiff'(fi")!fi*'+*
,-.

fi/1032547698;:=<>25?@A4B

UwS9cfiq _ X1S6]dsU ^ WfiXk+XbVfZ)\GX\6qU)YPQU
\GXkzUwS9xTWfiX\>Z)\cedzDCZdska _ X1gZSGXbdsU)acedtaGX1
SZaGXkcedaGU
YU)SGXqU)YPQTWfiXihSGX2Z)\GU)dTcedT\>Z)\`cedDEzU)S`cedFCGE
 _ X1SGX\ _ U)xTWfikVXU)a _ X1SMqU)dTdsXq1a9cfiU)ds\ ^ cea _^ U)S9]K\hZVU)xTaX1S9cjfq2Za9cfiU)dUw6]dsU ^ WfiXk+XVfZ)\GX\
qU)YPQU
\GXkUw6WfiU)
cfiq2ZW}S9xTWfiX\'wU)Sceds\GaZdsq=
X HrU)S9dS9xTWfiX\u|dfZYX1Weg ^ cea _ a _ X ^ U)S9]K\Uw  X1gZdsk
I U)xs\\GX1a2
7 Jusced ^`_ cfiq _ qU)ds\9a9SZcedtaG\rZSGX}6\ua _ xs\ _ ZXa _ X\ZYXrw>U)S9Ya _ ZdMU)xTSG\u+VTxTa ^ X
k+cfikhdsU)asdskk+ceSGXq1a}SGX1WZa9cfiU)ds\ _ ceQs\}VX1a ^ XX1dva _ X1ceS`wSZYX ^ U)S9]ZdskU)xTSG\
\MVU)a _ YUKkTX1Wfi\ZSGXzSGUU)aGXkced\GX1YZda9cfiqdsX1a ^ U)S9]K\uqU)YPQfZS9cedTqU)dsqX1QTa9xfZW
SZQ _ \Zdsk
kTX\Gq1S9ceQTa9cfiU)ds\bWfiU)
cfiq\bcfi\PZvQTSGU)VTWfiX1Y a _ Za _ Z)\PUwaGX1d VXX1dcfi\G\9xsXkL
 K`Z
Z)kTX1S2uIU)WeceaGU)S2u<ZdskU)VTcfiX\
2

 _ Z2XcfikTX1da9cjfXk ZwSZ
YX1dtaUwa _ X|pYUKkTX1Wr ^`_ X1SGX\9ceYPQTWfiX
SZQ _ \ZSGXPSGX\Ga9S9cfiq1aGXkaGU
a _ U
\GX _ ZKcedTbZa9SGXXlCWece]X\9a9S9xsq1a9xTSGX
uKVTxTa|qU)d)xTdsq1a9ceX}agQX\`ZSGXrZWeWfiU ^ Xkf ^ cea _ Z6WZdT
xfZXq2ZWeWfiXk

E&M
NDCPO {a _ cfi\RX QxTce)ZWfiX1dsqX _ Z)\WfiXkaGUZ`dsX ^ a9SZ)q1aZVTceWeceaBgySGX\GxTWeacedkTX\q1S9ceQTa9cfiU)dWfiU)
cfiq\

 HU ^ X1X1S2u
a9S9gKcedT}aGU`cfikTX1da9cjwgWZS9X1SwSZ
YX1daG\\XX1Y\aGU`VXEZ}kTX2Z)kKlBX1dsk{Z)\QU)cedtaGXkU)xTaVgvxT
dTcfiX1S>


u
QTSGU9Xq1a9cfiU)d q2ZdTdsU)a _ Zdsk+WfiXdsX1tZa9cfiU)dU)dQTS9ceYPcea9ceXaBgKQX\rda _ XU)a _ X1S _ ZdskuX1X1d a _ XPYU
\9a
Xi+QTSGX\G\9ceXkTX\Gq1S9ceQTa9cfiU)dhWfiU)
cfiq\`q2ZdTdsU)a`XiKQTSGX\\a _ X ^`_ U)WfiX6 F
 J
 SfiT  UVEwSZ
YX1dtay KU)S9
cfiksZ+u2
7
dsqUKk+cedT\GU)YXhXi+cfi\9a9cedTkTX\Gq1S9ceQTa9cfiU)dWfiU)
cfiq\cedtaGUYUKkTX1Wfi\Uwa _ XM|"w>ZYPceWegcfi\ZdcedtaGX1SGX\Ga9cedT
QX1SG\9QXq1a9ceX
uKa _ Za~qU)xTWfikhZWeWfiU ^ U)dsXaGUcfikTX1dta9cjwgdsX ^ kTXq1cfiksZVTWfiX6q1WZ)\\GX\|wU)SU)xTSYUkTX1Wfi\usZ)kTkagQX
Xi+QTSGX\G\9ceX1dsX\G\`aGUqU)dsqX1QTa9xfZW
SZQ _ \2usZdskhYZ2gMVX6q1g+q1WfiX\`ceda _ X6kTX\Gq1S9ceQTa9cfiU)dUw<  \}qU)dsqX1QTaG\2

WYX[Z]\
^D_3`baFcdfi\&^
e X _ ZXQTSGU)QU
\GXk Zw>ZYPceWegzUwYUKkTX1Wfi\6a _ Zayq2ZdVXP\GXX1dZ)\a _ XPVfZ)\9cfi\6Uw~ZX1dsX1S9cfiqPYUKkTX1WecedT

wSZYX ^ U)S9]6ZcedwX2Za9xTSGX\6Uwa _ cfi\}wSZYX ^ U)S9]zZSGXa _ Xw>U)WeWfiU ^ cedTs{Zq1WfiX2ZS6k+cfi\9a9cedsq1a9cfiU)dzVX1a ^ XX1d
k+)c fX1SGX1dta6]KcedskT\6UwE]dsU ^ WfiXk+X
ua _ Zasa ^ X1WeW ^ cea _ ceda9xTcea9ceXq2ZaGX1U)S9cfiX\2uZxTdTcjw>U)S9Y 
SZQ _ lCVfZ)\Xk
WZdT
xfZXba _ Za]XX1Qs\6X\G\GX1dta9cZW<QTSGU)QX1S9a9cfiX\UwEa _ XnT YUKkTX1WCudfZYX1WegvSGX2Z)ksZVTceWeceagUwU)V+9Xq1aG\6Z)\
^ X1WeWIZ)\rSGX2Z)\GU)dTcedT\2 e X
xsX\G\a _ cfi\}WZa9aGX1SQU)cedtacfi\}QfZS9a9cfiq1xTWZS9WegceYPQU)S9aZdawU)Sra _ Xxs\ZVTceWeceaBgvUw
Zdtg]KdsU ^ WfiXk+XVfZ)\GXk \9gK\GaGX1Yd U)xTSywSZYX ^ U)S9]uZWeW]cedskT\Uw~]dsU ^ WfiXk+XZSGX
SZQ _ \X2Z)\9ceWeg
cedtaGX1S9QTSGX1aGXkuZdskSGX2Z)\GU)dTcedT\q2ZdVXP
SZQ _ cfiq2ZWeWegSGX1QTSGX\GX1daGXkced ZhdfZa9xTSZW|YZdTdsX1Sxs\GcedTa _ X

SZQ _ \~a _ X1Y\X1WeX\2uTa _ xs\rXiKQTWZcedsXkaGUPa _ Xxs\GX1S}U)dhceaG\~U ^ dvYUKkTX1WeceZa9cfiU)d
Xq _ dTcfiq2ZWqU)dta9S9ceVTxTa9cfiU)ds\2u ^  S2 a2<QTSGX1KcfiU)xs\ ^ U)S9]+\EU)dqU)dsqX1QTa9xfZW
SZQ _ \2uq2ZdVX`\GxTYPYZS9ce2Xk
Z)\w>U)WeWfiU ^ \2{

g a _ XSGX1QTSGX\GX1daZa9cfiU)dUwk+c)fX1SGX1da<]cedskT\7Uws]dsU ^ WfiXk+X~Z)\qU)WfiU)SGXknT\{w>Z)q1aG\uced+w>X1SGX1dsqX|S9xTWfiX\2u
X1U)WexTa9cfiU)dS9xTWfiX\}ZdskqU)ds\9a9SZcedaG\2

g a _ XcedaGX1
SZa9cfiU)dvUwqU)ds\9a9SZcedaG\cedtaGUZySGX2Z)\GU)dTcedTPYUkTX1WCKYU)SGXU)SWfiX\G\\9ceYPceWZSdsU)a9cfiU)ds\`Uw7Z

qU)ds\Ga9SZcedta _ )
Z kzZWeSGX2Z)k+gVXX1dcedta9SGUKk+xsqXkVTxTa ^ X1SGXbU)dTWegxs\GXkaGUq _ XqG]vqU)ds\9cfi\GaGX1dsq1gvUw|Z
\GceYPQTWfiX
SZQ _ > Z)\cedha _ X|zYUkTX1W'I _ X6qU)YPQTWfiXi+ceaBghUw<qU)ds\9cfi\9aGX1dsq1gMq _ XqG]KcedT ^ Z)\`dsU)a
]KdsU ^ d

X U)VTaZcedsXkwCZYPceWegzUwYUKkTX1Wfi\ ^ cea _ 
Z qU)YPQTWfiXiKceagzq1WZ)\\9cjfq2Za9cfiU)d
g ZM\GgK\9aGX1YZa9cfiqb\9a9xsk+gzUwa _ P
UwEZ)\G\Uq1cZaGXkqU)ds\Gcfi\9aGX1dsq1g3hkTXk+xsq1a9cfiU)dQTSGU)VTWfiX1Y\2ufcedsq1Wexsk+cedTa _ 
X \Ga9xsk+gMUwQfZS9a9cfiq1xTWZSq2Z)\GX\
Uw<S9xTWfiX\rZdskhqU)ds\Ga9SZcedtaG\2u ^`_ cfiq _ QTSGUcfikTXcedtaGX1SGX\9a9cedTqU)YPQTWfiXiKceaghSGX\9xTWeaG\2

e XyZWfi\UPX\9aZVTWecfi\ _ XkMWecedT]+\`VX1a ^ XX1dqU)ds\9cfi\9aGX1dsq1gMq _ X qG]KcedTZdskv  kTXk+xsq1a9cfiU)dufa9SZds\9WZa9cedT
a _ XIqU)ds\9cfi\GaGX1dsq1g3
h kTXk+xsq1a9cfiU)dQTSGU)VTWfiX1Y\cedaGX1S9Y\Uw+  kTX k+xsq1a9cfiU)d<Ba\ _ )U xTWfik6VX<dsU)a9cfiqXka _ Zaa _ X
U)QX1SZa9cfiU)dfZW7\GX1YZda9cfiq\rUwYUKkTX1Wfi\}qU)YVTcedTcedTS9xTWfiX\ZdskvqU)ds\9a9SZcedaG\2ufdfZYX1WeghFCG
E uTFCZdsk
D
E <u+cfi\`X2Z)\9gaGUbxTdskTX1SG\9aZdskhVTxTa ^ X ^ X1SGX6dsU)a}ZVTWfiXaGU
ceXZ
WfiU)VfZWWfiU)
cfiq2ZW\GX1YZda9cfiq\2IdskTXXku
,-i

fijlk4Pm1n5oDprq47s5@)6utvn5wyx1<>q4rz{0>?>|}m1n5?>z~6B05@A?36z

a _ X1SGXcfi\IZdPxTdskTX1S9WegKcedTdsU)dPYU)dsU)aGU)dTcfiq`YXq _ ZdTcfi\GY ^`_ U
\GXWfiU)
cfiq2ZWscedaGX1S9QTSGX1aZa9cfiU)d\ _ )
U xTWfikbSGXRQxTceSGX
d U)dz\9aZdsksZSGkWfiU)
cfiq\2r _ XykTXsdTcea9cfiU)dUwEZWfiU)
cfiq2ZW<\GX1YZda9cfiq\}w>U)S}a _ X\XYUKkTX1Wfi\}cfi\ra _ s
s
x \ZdU)QX1d
QTSGU)VTWfiX1Y

 _r^#\5`fi>D&>^
cuX
e XZSGXMcedskTX1VTaGXkaGUcfiq _ X1Wm _ X1cedZdskX1dsX1Kc1XvnceYU)dsX1aPwU)SPa
X2ZS9WecfiX1S6X1SG\9cfiU)dUwEa _ cfi\ ^ U)S9]Zdsk _ X1WeQ+wxTWqU)YPYX1daG\2 e XbZWfi\GU ^ cfi\ _
Q xTcfi\2uTZ)\ ^ X1WeWZ)\|ZdsU)dgYU)xs\SGXw>X1SGXX\2uw>U)Sa _
I U)xs\\GX1a|ZdskocfiX1S9SGXZS

_ 1X ceSq2ZSGXwxTW`SGX2Z)k+cedTUwZd
aGUa _ ZdT]ZS9cfiXlJm _ S9cfi\Ga9cedsX
X1ceS|cedtaGX1SGX\9a9cedT\GxT
X\9a9cfiU)ds\

Zdsk\GU)YX6qU)S9SGXq1a9cfiU)ds\

 *>^F_>c
rVTceaGX1VU)xTWCuneu>H}xTWeWCu I eusrcZdxub2
7F5{7fiu'RE`kTk+cfi\U)d+l e

X\9WfiX1g

K`Z
Z)kTX1S2ueuU)WeceaGU)S2u I euU)VTcfiX\2unI2

SZ)q1aZVTWfiXZdskXq1cfiksZVTWfiXPsSZ
YX1dtaG\yUw~m|U)d+l
qX1QTa9xfZW7SZQ _ \2Id1**{l
 

5)
 usQTQ3t
 
rt
 7+
 nQTS9cedTX1S2
K`ZX1a2us lBeuX1dsX\9a2u

 eu 
b
xT
dTcfiX1S2u   l   2


dsU ^ WfiXk+X `qRQxTcfi\9cea9cfiU)d
Z
oxTSGX
SZQ _ lbK`Z)\GXk
dsU ^ WfiXk+X I X1QTSGX\GX1daZa9cfiU)d UkTX1W rQTQTWecfiq2Za9cfiU)d
^ cea _
aGU
a _ X
ncfi\9gKQ _ xs\9lB mZ)\GX
na9xsk+g
d
** 
Z2)ZceWZVTWfiX
Za
Z 9g-q2
Z h'ynK* h'6 e h'6 e 
hfZ'XG\ _ a9Y
_ a9a{h7h\GX9d xsq2ZWet'

K`ZX1a2u(s lBeu xT
dTcfiX2u l  >

+y _ Xb|ZYPceWeg{<i+aGX1ds\9c)ds\w`nceYyTWfiXm1)dsqXTa9xfZW
 Z' _ \IBd**{5{3 r)u3s
7K+2+
K`ZX1a2u(s lBI>

+b5R5b]r>5~75~]l>'rr3>3Rlu
 X1WeWecfiX
 5*RR7  Pu7LRr>>b }o _ -bsa _ X\9cfi\2u}dTceXG \GceaBg9 wE) dta
G

K9
cfiksZ+u2
7J7rda _ X{GX1WZa9ceXrXi3GX\G\9ceX1dsX\G\1wkTX\Gq9cATa9c)dW)
cfiq\|Zdsk]3GXk+cfiq2ZaGXrW)
cfiq\2
{ 1  >b  Ar55  utu>777JK
K
\2umeu5K)aA+u(KeuDd _ R 1 _ 
uo7<2

6Kk3ecedTdskncAyx3a9cedT=Hrx3Gd}K _ Kc
 a9x>'
 ~' _ 2 Id1{l
 >
{'u2u33sK

+nu39cedT2
 cea _ m1) dsqRT
m _ dsk~+u(Peueceduo7 I27
M{Ta9cAG'IcAy31dta~a9c)d)dqR)d)xTdsq1a9ceGQx9cR
ceP
d a9c )>
d '
k ~a y>R2<Bd*
'Dv>{(L[&[*{5u
u
35
 7K
+
m _ 1cedueu7

xT
dTc2 u  l  `2

m1)dsqRTa9x>'r~' _ 2{<7xTdsk'1dta~'r)a9c)d23
& >b  )r5~ 1  1u
u>7J7rt7J+

m _ 1cedufeufxT
dTc2uf l  euncA)d1a2uP2

`{RGak~' _ 2{ ~' _ lfi>k9d  jl
k+  I 3R1dt~a a9c )dpKk3  cea _   nGdta9cfiqR2Bd1*G9 tuY3D
''7's
 9r

 9
d x+w GdTd
m1)
c2ufeuf xTced>'fik3Tu2
7eced'rk3RGq9cATa`wqR)dsqRTa9x>'7~' _ dsk9qw
eg
d Pc'c _ c aR9a2d=1*Y*l
 r'
uRsu3T7J7K7Kfnu39cedT2
m1)x3)dsk
uKneu"n'ea2ut~2

ocqR I RexTa9c)d{l  'Gk3  '9oDq1a9ceRd[1
*{l
l 7
>7t3
u 3 )27+nu39cedT2

,-

fi/1032547698;:=<>25?@A4B

cATc
ulseuHy
ureu~  )cxurn2

 nGdta9cfiqv'ecfika9c)dwm1)dsqRTa9x>'
 ~' _ IB

d **{l
 &&{R>7u33s
K7+nu39cedT2
>'9
c2uHeu  dTsufeunKq _ ciu6I2
7Jbvcji3kqR)d9a~cedta~a9cwfi)q1a9c)d{w~'  w
k q1c 9c )d933~xTdsk3~cedsqRy31ad  k+
Ed1*#*{{{3 u
u32
+
3
k32u<6eu<D'Gk+cCu<2
7z)d)a)d)d>)k+cfiqhnKodskm1)dGa~cedtana9cwfi)q1a9c)dd
1~~u'*u7G
<
u 3
 J+2 J

+
R2uhb>




b37 
 	  r 7*5 5~!3  
& 7731off-bfiffR2usfie
A}G

7u





7ffu
Kmeu e x  T~
u
bE2
7hAqo#uw~oKqRk+x3wyfihm1sqRfi9x>'
 ~'fiff}o)7~'2E1D*{l
 r'&&{rsu3
)+nu3T2

ufbeu  R
uTeuTnKq'GqRATus2

<m1y>'=w<n9xsq9x3~'7m`nKoqRyl
ffKk321**{3 u3>
''

+

GkAR2u)b2

oq{fijfqoKqRk+x3w'3xm1sqRfi9x>'s~'fiff2
1*u
 F
 #
  R&
{'52 u3
 f+JK
 7
 +
e
u'P2
7J!+xsqeE"ffRR{jfq'
AesqR
K 15R  1Y5#  r
!5R>fi
 u3
 2

 
 +m`n  |oIx33 fiq  2 

 1%$uf&Peu I )x2us 'Jm2
7J#jfqLwD(  )+ KlRKl)zm1~'

m ffq%TsE1#{{3 )u3
7
+


*xu|b e euE*~)xfiCu I }2

"ff I 3R
~ wnG
fiqm1~
+
m sRq fi9x>'~'fiff`n$2,1**l
 
{{'32uu3f

+Tnu3T2
1

xT-fi2uK '  2
7~'ehnuq'eMw`m1sqRfi9x>'~'fiffDu7u5 
*.3G5fi  &R   F  >b  Ar~1D
u 
u 
7
 '7s
xT-fi2u '  <
 >


{(  )+ I 3R~} I ~fiT{>~)97~'fiffH'
fifffiE,1D*{l
 )u3)2
+nu3T2
xT-fi2u  '  eumffu2
7J I 3R
/3R6qRfi>~sqRR~fi2q03R
7~'fiffR21& >b  Ar5 Ffi  u
u57J+
oY'>A0)xumH2
'{5fi75  7  7
fi' e

R$

o72ut~  2'u
 I q1x3e~xfi~e'fiA$w33;w"fftx
Du  *>G  &u
'u}

 I 3)1{II%.=uE"ffm1Aq) e Gw60A  Io72u
K2A%ff>
x 2
u K72
'su33>
73'!++

oA2ueuvxT-fi2u  '  euRmffuf2

  )-fiqyw{R)~'fiff2y{5fi75 
>b  )u5~1Y
u  u>777K

I x3jw9ut2

4Ae)Tm1~
}nwfi)qlq5fffifiQtxR|w6q
}~'fiffoF
L
 GqfffiTssG1*>b575  5 7~}&{Fr  7**>
*73Ry~
&G
}Rs
 u3
 f7
 K
 7+
 
nu3 T2 

n'e72u~|2

"ffR 32%TvxTv7~'fiff~/8ffqRsqRfi9x>'|7~'fiffw9'
G'E, 1#*3 u3577J7J
+
n'e72u~eu)vxT-fi2u  '  K2
7JTn)xfiybm1y3Y  'y K)q~  'mff>fiT
wE
 ~'fiff I 3
x R2, **{l
 u
&{r7
u33'tK7J
+nu3T2

,-,

fijlk4Pm1n5oDprq47s5@)6utvn5wyx1<>q4rz{0>?>|}m1n5?>z~6B05@A?36z

n  +u&s|I2
'v75~b3  3RDR771~u959r1
 fi' e R$


nKq$2u  uf27
7"ff$%0':';A(fffi~'Gqff$&  {5bfi51u(u
 K
+

"fftx
uT2+o3(<315=39xfiT?>fiqff3ff*>)qffM1 I 1
7R(@u3577
  57&&
u )

e T2u<2
7ym1sqRfi9x>'~'fiffAA9'J{3  )-fiq
y,v11*l
 u'

rRs
 u3
 5
 77K

,-3B

fi
	ff
fi 
			 ! #"$ % 
'&)( *,+.-//-102-346574!( 3

89:;<  =)((?>
/!(@BA:	%&=DC1>
/-

EGFIHKJMLONPHKQ1R<NTS9SUWVYXZNTQ[\Q9[^]_Na`bXZJdc\S1efLONPHKQ1RhgiQ1NTSJ)]dF^ej`bXZelkmQRnHJMXpoqJ)X
NsrItuJ)v)e,[wgxQNTS1J)]dF^eyrzU|{2He,L

}p~$ffYn~2

,M92Z

#P~2#2'#u~$

q22M792

b~$B

$M92Z

Zff

6z7M92Z2

'u2ff'

2ffM92Z

TKBq
6
Bd ?,!l
 ?

 B?)

qq Zf! qB
9B

PqZ
B9.BqM?ff? !P M.?M
 !PB??q1!?, ^I 	?9\ff
.fi

7?B?  19#q| ff19
 q 	fn	?9#6B! qP ? !d
 <1
 9.d 9!? 6B?!"
7Z?9 .q! #
7.)$ !B?D?%9ZB .?
. 
 &1  6?q '&().)?9??*?96?  q?B?!9B 6B.,+-?%9q 
. q&+-?9!  d? !!   % 9B?!,ff qfi/1 q! . 01?M	

: 8< 7  =?
> ff@	AB 6B!q ? !C() 
  u
   87 9;
12	34 .Bq951   96<
+D % !B  . .BqC+D !1  $qE
% \.d9.B?q9Y   m ? 9&F  ?	

G 9  D ^ 6qH7
 , I qK?^,ff qJ  ?d5 B92
 5% ?9uq ,9  ^  
? ?9&F  qqqqP?^d#7
 ?K
%  Lff P M?9BP % !2
 q !
?u?
 9) 9&Ou
N    B M+D % 9B?! . .Bq8+D !!  )?q q  Bfi

% ?q% P7
 !B6 !5
? 6 D/n
 \RQS q!,.u  zq  !1 T?% 9q 
.Bq9UTV 4W d? 	
 6B?   | *% q?.	

XZY\[]

^)_a`fbH^

]

c dfhghiffjIkmlnhopfhqr'iGsStusSvSiffwMsZdyxRfwMlzsSi)iL{J|lpiffjv-nhjmkIjmnvRr'xnhonh||LiffsRs-vSfn*oznxRqhi~}nxlzivt$fh'lzj'fhxwMnvRlpfj
e
sSfr'x|Liffs\nhjmksSixR}ulz|Liffs&xRfwnhjtdymfj'ihcetusSvSiffwMs&vRmnv\sRr'dmdfhxRv&sR'fhxRv\r'vSvSixnhjm|Liffs,vSfsSiffopiff|LvMn
dynxRvRl|rmoznx\rmjm|LvRlpfjvRmxRfr'qnsSvRnvSiffw\iffjv6sRry|nhs;cun	t|LxRiffkmlpvM|nxk5|Lfoopiff|Lvfhx6d"ixsSfjuHvSf
dixsSfjmUnxi8sRnff}ulzj'qM|LfwMdynhjmlpiffs*wlzozozlpfjysGfh)k'fozoznxsadix*thiffnx	~idyopf	thiffkEsStusSvSiffwMsnhjyk0xRiffsSiffnx|
dmxRfhvSfhv tdiffsiL'lzsSvfhxGndmdyozlz|nvRlzfjms-srm|\nhsdixsSfjynhoiffwnhlzounhjmk,|nhopiffjmkmnxsffhvSxnff}hiffomnhjykCxiffsSvRnhr'xnhjv
lzj'fhxwMnvRlzfjZ"nhjykEdixsRfjmnhoynhjmgelzjmq5nqhqlznuKnhsSvRnqj'ixl/$nhjmlpiffozlHDffhhe-nhopghixff'xRfwMixff
nxnfftnhjmnhjPffhhePceiffj'iLUrmih~DfozlpxRfjml/)nf'aPivR'ixlzjmqhvSfjZ5fukmk'iffnhr~$oznhsRsPffhhe
cunhjmkmixwMnhjZcuvRr'xwOk'iffj$s$af}hiffsIUxRiffw\ixsCffhheM5eru5nxRxRfoo5nxd"iffjvSixff&ffhh
yL\! Giv$vR'ixRiCnxi&sSvRlozowMnhjtOxRiffsSiffnx||mnhozoziffj'qhiffs*|r'xRxiffjvsStesRvSiffwMsPnxi&ozlwMlpvSiffklzjvR'i
lzjvSixnh|LvRlpfjOvRmit0sr'dmdfhxRv5nhjmkOmxlzvSvRopilzjOwMnhjtJxiffsSdiff|LvRs
 ylzsdyndix~lzj}hiffsSvRlpqnvSiffsUw\ivR'fukms)et,mlz|MsSdfhghiffjMkmlznhozfhqr'isStusSvSiffwMsa|nhj zR vSf&sRr'dmdfhxRv
w\fhxRiMjynvRr'xnho)lzjvSixnh|LvRlpfjfjvR'i\ynhsRlzs$fhUvR'ifflpxdyxRi}elzfrmsiLedixlpiffjy|LihMj'i\Un	tvRmnvI|r'xRxRiffjv
sSdfhghiffjkmlznhopfhqr'i&sStusSvSiffwMs$nxRi,rmlzvSiCozlzwlpvSiffklzslzjvRmifflpxsRvSxnvSiqlpiffsfhxk'ivSiff|LvRlj'qJnhjykxRidnhlpxlzj'q
dmxRfhopiffwMsvRmnvInxlzsRi,lj|Lfj}hixsnvRlpfjZ-srm|nhsIwlzsRrmjmkmixsSvRnhjmkmlj'qskmrmi&vSfEsSdiiff|xRiff|LfhqjmlzvRlpfj
ixRxRfhx,fhxMwMlsRlzjvSixRdmxRivRnvRlpfjndmxRfhopiffw|nhji0k'ivSiff|LvSiffkZavR'iOsStesRvSiffw|nhjifflzvR'ix,vSxnhjmsSix
vR'i\|nhozo-vSfOnJermwMnhj|rmsSvSfwMixI|nxRi\nqhiffjvfhxw\fukmlptlpvRskmlznhopfhqr'i,sSvSxnvSiqhtlzjnhjnvSvSiffw\dmv$vSf


-//-n %%!=6T
=5D1
UZ
!fi;l
~:!	%&%		q&1%2%1 =

fi

2Zy222S2-



7M1m



72

xRidynhlzxvR'iMdmxRfhopiffwO,i6|nhjvSxnhlzjsStusSvSiffwMs8vSflzw\dmxf	}hi\vR'ifflpxInlzozlpv tvSfEkmivSiff|LvIdmxRfhyoziffwMs$t
iLudyopflpvRlzjmq6kmlznhozfhqr'iffs$|Lfozopiff|LvSiffklzjlzjvSixnh|LvRlpfjmslpvRermwMnhjrmsSixsmixRiCvRmi,ljmlpvRlznho-sSiqw\iffjvRs
fhZvR'iffsSiPkmlznhopfhqr'iffsanxRiPrysSiffk\vSf&vSxnhlzjMnCGxRfhyoziffwMnvRlz|*$lznhopfhqrmiGxRiffkylz|LvSfhxa5vSfI S/ff vRmnv
ndyxRfhyopiffwls8ozlpghiffoztvSfEfe||rmxff  'iMfrmvSdyr'vIfhKvR'iJ~$|nhjiJlzwMw\iffkmlnvSiffoptndydyozlpiffkvSfvR'i
sStusSvSiffwOsGkmiff|lzsRlpfj,fh"'ivR'ix~vSfvSxnhjmsSixGvR'i*|nhozomvSfInIrywMnhj\|rmsSvSfw\ixa|nxRinqhiffjvfhx~lzvG|Lfrmozk
dfhvSiffjvRlnhozopt"iMrysSiffknhs8n|r'iMvSfvRmisStusSvSiffwOs8$lznhozfhqr'inhjmnqhixCvSfw\fukmlptElpvRsiffmn	}elzfhxIvSf
xRidynhlzxKdmxRfhyopiffws'nhjmkOi}hiffjdixyndysuvSfMdmxRi}hiffjv*vR'iffw
jdmxRi}ulpfrmsPafhxRg"ZUi&xid"fhxvSiffkljmlpvRlznhoxRiffsRrmopvRsPfhxvSxnhlzjmlzjmq6n0~$rmsRlj'q6nJ}nxlpivtEfhakmlz
ixRiffjviffnvRr'xi8sSivRsC-nhj'qhgulzozk'ih'nhopghix	mxlpqvfhxlzjZy-lpvRwMnhjZffhhenhopghixff-nhj'qhgulzozk'ih
xlpqv$$fhxlzjZlpvRwnhjZhh"'iffj?nhjynhoptfflj'qvR'idixRfhxwMnhjm|LifhvR'irmooptnhr'vSf
wMnvRlz|,iffnvRr'xRi6sSivUi\iLunhwlzj'iffkml|mnhjmk'ozniffozopiffkEiffnvRr'xiffsIwMnhk'iMoznxqhi\d"ixfhxwnhjm|LiMlzw,
dmxRf}hiffw\iffjvRs"ryjmk'ix*vR'i&nhsRsRrmwMdmvRlpfjOvRmnvPrmvRr'xRiIUfhxRgOsR'frmokOfu|rmsfjk'i}hiffopfhdlzj'qnhr'vSfwnvRlz|
iffnvRr'xRiffsvRmnvCndmdmxRf	ulzwnvSi\vR'ilzj'fhxwMnvRlzfjEdyxRf	}ulzk'iffketEvRmiffsSiMmnhjmkuon"iffoopiffkiffnvRr'xRiffsff  'i
nhjmnhoptusRlzslzjmkylz|nvSiffkvRynvvRmi&mnhjykuozniffozopiffk'$D  *iffnvRr'xRihZml|Eiffjm|LfekmiffsPP'ivR'ix$vR'i
sSdfhghiffjoznhjmqrmnqhiMrmjmk'ixsSvRnhjmkmlzjmqHff-|Lfw\dfj'iffjvI|ndmvRr'xiffkvR'iMw\iffnhjmlj'qOfhaiffnh|iL'|mnhjmqhi
|LfhxRxRiff|LvRozth~'iffjvRmlsKmnhjmkuozniffozoziffk6iffnvRr'xRiClzsKnhkmk'iffkOvSf6vR'i8nhr'vSfwnvRlz|iffnvRr'xRiffsylzvlzw\dmxf	}hiffk
vR'i*dixRfhxwMnhjy|Li*fhvR'i~$t\nhozwMfsSvUJ  ylzsjmkylzj'q$opiffkMrms~vSf8k'i}hiffopfhdJnhjOu-   
dmxRiffkylz|LvSfhxnhopghixffKxlzqvKnhjmqhgelzok'ihUhhh|	Mnhjmknj'i}hixsRlpfjfh$vR'iavRmnv\Ui
xRidfhxRvafjJmixRih  'i$j'i}hixsRlpfjJfhvR'i$~$vRnghiffs*nhs5lzjmdyr'v~nCryozopt\nhr'vSfwMnvRlz|}hixslpfjJfhvR'i
u-   aiffnvRr'xRihmylz|0Ui8|nhozo   H u-   
i*vSxnhlzj\nhjmk,vSiffsSv)fhvR,vR'i   H  u-   dmxRiffkml|LvSfhxGnhjmk,vR'i*~$fjn|LfhxRdyrmsDfh"hh
kmlznhozfhqr'iffsI|Lfozopiff|LvSiffklzjnhjiLudixlzw\iffjvRnho)vSxlznhofhK    sC J       
	fiff 
sSdfhghiffjkmlznhopfhqr'iCsStesRvSiffwH$fhxlzjZ
 lz||nxkyl/ xlpqvffhPiffozoznMfhxlzj-ffhhe
 l||nxkml
 fhxljZuhhu
 *'wMwMlz|v* PozfjmsSf'ZffhhajJvRmlzsUvSxlznhoHvR'i  sStesRvSiffwUnhsKlzjysSvRnhozopiffk
nv\nhj    |rmsSvSfw\ix\|nxRiO|LiffjvSixff  nhjmsSUixRiffk|nhozozsCxfwolp}hi6|rmsRvSfw\ix,vSxn{6|0nhjmk
sRrm||LiffssSryozoptnhr'vSfwMnvSiffk?noznxRqhijermwC"ix,fh$|rmsSvSfw\ix\xiffr'iffsRvRs;jiL'nhw\dyopikmlnhopfhqr'iJvRmnv
 |Lfw\dyozivSiffk;srm||LiffsRsSrmozoptlzsCsR'fjljlpqr'xiE  'id'fj'i6jermwCixs)|nxk;jrmwCixs
nhjmkOdlzj0jrmwCixsKlzj0vR'iCsRnhw\dyopikmlnhopfhqr'iffs*nxRiCnxRvRl|lznhoH
eT
 T 
 4 

 4 
Vfi
 Vfi
 1 
 1 
 " 

 (K
Z
 (, 
 .q
#9?ffl$q2T89B.?9q?
 D
m
 LqD?ff%9  
! 2#
" 1 V 4 T%$ 3'& ! 2#P
" 1
Nql%n.|I.BD?IB(
& T 1 !#!)! 2$2$22+* ,.S- @q/
- !9 0
 D
m
 LqDBlffP%<Bq1
& T 1 !#!)! 2$2$22
()

q'

lpqrmxRiMUcunhw\dopi32fi4D )
5 
67698	$lznhopfhqr'i
PfhvSiCvRynv*vR'iCsRtesSvSiffwsr'vSvSixnhjy|LiClzjEcu|LfjmsRlzsRvRsKfhGn\xRidynhlzxlzjmlpvRlnvRlpfjZ'w\fhvRlp}nvSiffket0vR'i
sStusSvSiffwOsCnylzozlpv tvSfkmivSiff|LvIvRmnvIvR'i6rmsSixffsIrmvSvSixnhjm|Li:);05nhs8ozlpghiffoztvSfmn	}hiiiffjwMlzsrmjmk'ixS
sSvSfefek  miJqhfnho*fhPvR'i   H  u-   CdmxRiffkylz|LvSfhx\lzs,vSflzw\dmxf	}hiOvR'iOsStusSvSiffwOsMnlzozlpv tvSf
k'ivSiff|LvJsRrm|?wMlzsRryjmk'ixsSvRnhjykmlzj'qs  'iEkmlznhopfhqr'iffsMvRmnvmn	}hivR'ikmiffsRlpxRiffkfrmvR|Lfw\ih*lzjml|
i 24-< 5ff

 676=8"	kmlzn
 srm||LiffsRsSrmozopt6nhr'vSfwMnvSiffs*vRmiI|rmsSvSfw\ixffsK|nhoo/mnxRixRiixRxRiffk0vSfMnhsKvRm#
4ff3ff1

fi>

72

> 9?f7A@d.22

opfhqr'iffsff$lznhozfhqr'iffs~lzjMmlz|\vR'i  sStusSvSiffw kylzk\j'fhvasrm||LiffsRsSrmozopt&|Lfw\dyopivSiPvR'i|nhozozixffs)vRnhsSg
nxRiIxiixRxiffk0vSfnhC
s BEDF
Gy
 8  4E2  6  miffsSiInxRi8k'iffs|Lxlpiffk0lzj0rmxRvR'ix*k'ivRnhlzoiffopfI
 ylzs5dyndix*xRidfhxRvRsKxiffsRrmopvRs5xRfw iLudixlzw\iffjvRs5vRmnvPvSiffsSv*'ivRmixlpvlzs5dfsRslpyopi$vSfopiffnxjOvSf
nhr'vSfwMnvRl|nhozoptdmxRiffkmlz|Lv$vRmnvCnkmlznhopfhqrmi&PlzozoDi&dyxRfhyopiffwMnvRl|CfjvR'iMynhsRls$fhUlzjmfhxwnvRlpfjvR'i
sStusSvSiffwmnhs*	~iffnxoptljvR'i$kmlznhozfhqr'ihenhjyk/UlzjxRiffnho"vRlzw\ihivSxnhlzjJnhj0nhr'vSfwMnvRlz||oznhsRslyix
fhxdmxRiffkml|LvRlzj'q;dmxRfhyopiffwnvRlz|kmlznhopfhqr'iffsxRfw iffnvRr'xRiffsvRmnv|nhjinhr'vSfwnvRlz|nhozoptiLevSxnh|LvSiffk
xRfw vR'i  |LfhxRdyrmsffPsMkmiffsR|Lxlpiffknf	}hih5fj'ifhvR'iffsSiiffnvRr'xiffsMlzs\vR'iOfrmvSdyr'v\fh$vR'i
  H  u$D   dmxiffkmlz|LvSfhxffDvR'i   H u-   iffnvRr'xih)mlz|dmxRiffkml|LvRsI'ivRmixCfhx,j'fhv
vR'i0|r'xRxRiffjvCrmvSvSixnhjm|LiJUnhs,|LfhxRxRiff|LvRoztrmjmk'ixsSvSffuknhopghix\iv,nho/p~hhh|	  'i6xRiffsRrmozvRs8sR'f
vRmnv8lzv$ls$d"fssRlpyopi&vSfJ RR/ff dmxRfhyoziffwMnvRlz|,kmlznhopfhqrmiffsrmsRlzj'qJrmozoptnhrmvSfwMnvRlz|\iffnvRr'xRiffsPlpvRnhj
nh||r'xnh|LtExnhj'qlzjmqMxfw he vSfuH ;JZk'idiffjmkmlj'q\fj'ivR'ixvR'iCsRtesSvSiffwmnhssSiiffjfj'i&fhx
vUf,iLu|mnhj'qhiffs~ vUlzsGdfsRsRlzyopiKvSf y I dmxRfhyopiffwnvRlz|*kmlznhozfhqr'iffsGlzvRnhjJnh||r'xnh|Lt6rmdvSf\hJ
ceiff|LvRlzfjk'iffsR|Lxlpiffs  nhjmkvRmikmlznhopfhqr'i|LfhxRdyrys0vRmnvOvR'iiLedixlw\iffjvRsOnxinhsSiffk
fjZceiff|LvRlpfjJ;kmlsR|rmsRsSiffs8vR'iJvted"i6fhwMnh|mlzj'iJopiffnxjmlzjmqnhopqhfhxlpvRywnhk'fhdyvSiffkZ)jmnhw\iffoptKD  BEBE8ED
nhjmkqlz}hiffsnk'iffsR|LxlpdmvRlpfjfhvR'iiLudixlzw\iffjvRnhoKk'iffsRlpqj?ceiff|LvRlpfjqlz}hiffsnmxRiffnguk'fjfh$vR'i
iffnvRr'xRiffs5rmsSiffkJlzj6vR'iffsSiiLedixlzwMiffjvRs~ceiff|LvRlzfj08dmxRiffsRiffjvRsUvR'i$w\ivR'fukfhdmxRiffkmlz|LvRlj'qIvR'iiffnvRrmxRi
  H  u$D   5nhjmkOqlp}hiffsnh||r'xnh|Lt0xRiffsRrmozvRsaceiff|LvRlpfj&dyxRiffsSiffjvRs*w\ivR'fukms*rmsRiffk0fhxrmvRlzozlpfflzjmq
D  B=BE8ED;vSfvSxnhlzjvRmiMnhr'vSfwMnvRlz|M~xRfhyopiffwnvRlz|,lnhopfhqr'iMGxiffkmlz|LvSfhx8nhjmkqlz}hiffsvR'i\xRiffsRryopvRs,i
k'iffozn	t6frmx*kmlzsR|rmssRlpfj6fh-xRiffonvSiffk0afhxRgJvSf6ceiff|LvRlpfjC'iffjJaiC|nhj|Lfw\dynxRiIlzvUvSf\frmx*ndmdmxRfnh|Z
ceiff|LvRlpfjE\sRrmwMwnxlpiffs5vR'iIdnd"ix*nhjykk'iffsR|Lxlz"iffsUr'vRr'xRiUfhxRg"

LYNMPORQJSUT [SWVYX



 lzsn6sSdfhghiffjkmlnhopfhqr'i8sStusSvSiffw ynhsSiffkfjvR'i&j'fhvRlpfjfh -S  1Z H$fhxlzjiv$nho/pDffh
5eru5nxRxfozo 5nxRdiffjvSixff-ffhhjvRmi  |nhozo-xRfr'vRlj'q6sStusSvSiffwOsSixR}ulz|LiffsvRmnvvR'i,rmsSix
|nhjnh||LiffsRsCnxRi|oznhssRlyiffklzjvSfL|nvSiqhfhxlpiffsDdyozrysnO|nvSiqhfhxt|nhozopiffk h\u
[  fhxIvRnhsRgesvRynv8nxRi

j'fhv5|Lf	}hixRiffktMvRminhr'vSfwnvSiffkOsStesRvSiffwnhjykJw&rmsSvUivSxnhjysSixxRiffkvSf\n&rywMnhjfhdixnvSfhxIHfhxlzj
iv\nho/pffhhJ~nh||nvSiqhfhxRtk'iffsR|Lxlz"iffs&nkmlixRiffjvCvRnhsSg"asrm|nhs,dixsSfjuHvSfHdixsRfj;kylznhozlzj'q'
fhx8xiff|Lifflp}elj'q|LxRiffkmlzvIfhx&nwMlsRkmlznhopiffkjermwC"ix	  misStusSvSiffw k'ivSixwMlzj'iffs8mlz|vRnhsSgvR'iJ|nhozopix
lzs8xRiffrmiffsSvRlzj'qOfjvR'inhsRlzsfh*lpvRsCrmjmk'ixsSvRnhjmkmlzjmqJfhKvRmi|nhozopixffs8xRiffsSdfjmsSivSfvR'i6fhd"iffj'Hiffjmk'iffk
sStusSvSiffwqhxiivRlzj'^
q ]_a`b_ca O  L   e
 d0$jm|LivR'i\vRnhsSgmnhsiiffjkmivSixwMlzj'iffkvR'i
lzj'fhxwMnvRlzfjj'iiffk'iffkIfhx-|LfwMdyopivRlzj'qvR'i~|nhozopix	sxRiffer'iffsSvlsZfhmvRnhlzj'iffkCrmsRlzjmq5kylznhopfhqr'i~sr'yw\fukmrmopiffs
vRmnvnxi8sSdiff|l|fhx*iffnh|EvRnhsSgiffozon,fhxlzjZZffhh
 mi 
Cf sStusSvSiffw|LfjmslzsSvRs$fh5nhjnhr'vSfwMnvRlz|MsRd"iiff|xRiff|LfhqjmlzixffnOsSdfhghiffjoznhjmqrmnqhiMrmju
k'ixsRvRnhjmkmlzj'qMwMfekmryopihynkylznhopfhqr'i8wnhjmnqhixffnhjmkn6|Lfw\dyr'vSixvSiffopidy'fjt0dyoznvSfhxwOK$r'xlzjmqMvR'i
vSxlznhoHvR'iiffmnff}ulpfhxsUfhnhooyvR'isStusSvSiffww\fukmrmopiffsaUixRinhr'vSfwMnvRlz|nhozoztMxRiff|Lfhxk'iffk0lzjJn,opfhqCopih'nhjmk
oznvSix,vR'i0kmlznhopfhqrmiffsIUixRi6vSxnhjmsR|LxlpiffktermwMnhjys8nhjmk;ozniffozopiffklpvRfjmi6fhx\w\fhxRi6fh*vR'iff
vRnhsSg|nvSiqhfhxlpiffs)xRidmxiffsSiffjvRlj'qvR'i6vRnhsSgvRmnv&vR'iJ|nhozopix85nhs,nhsSgulzj'q  vSfdixRfhxwO-fj;n
dix8r'vSvSixnhjy|Li6ynhslzs  'iopfhqopiffs8nhosSflzjm|ormk'iffkozniffozslzjykmlz|nvRlzj'qOP'ivR'ix8vRmiMlpffnxkmnhk
vRnghiffjf}hix8vR'iM|nhozoDfhxIvRmi,rysSixImnhkermj'qOr'd&r'x$iLedixlzwMiffjvRsrmsRi&vRmiMopfhqJopiffsvSfOiLevSxnh|Lv
nhr'vSfwMnvRl|nhozopt0fhmvRnhlzjmnopiiffnvRrmxRiffsrmsRiffknhs*dmxiffkmlz|LvSfhxsnhjmkOvSf6kmiLj'ivR'i8|onhsRsSiffs*fh)kmlnhopfhqr'iffs
vRmnvaaiPUnhjv~vSf&opiffnxjMvSfCdmxRiffkml|Lv  'i*|LfhxRdyrms~fhZhh8kylznhopfhqr'iffsGrysSiffklzjMfr'x~iLudixlzw\iffjvRsG5nhs
|Lfozopiff|LvSiffkJlzj6sSi}hixnhoiLedixlzwMiffjvRnho'vSxlznhozsGfh 
Cf fjJozlp}hi|rysSvSfw\ixUvSxn{6|Cg Plz||nxkml" $fhxlzjZ
hhu=
 ewMwMlz|vK PozfjmsSf'ffhhynhjmk0lzsaxRiixxRiffkvSf\nhs5&lzjg lz||nxkml"fhxlzjZ'hh
4ff3"

fi

2Zy222S2-



7M1m



72

 i&kmlznhopfhqrmiffs*}nxRtlzjEopiffj'qhvRZZh nxRiIy}hi&iL'|mnhj'qhiffs$fhx$opiffsRsPlpvRh;fh~nhozovRmi&kmlnhopfhqr'iffs
 '
|LfjmsRlsSvRlzj'q,fhfjmopt6vUfiL'|mnhj'qhiffsff
sIw\iffjvRlpfj'iffknf	}hihDkmlznhopfhqrmiffsljmlz| 
Cf sRrm||LiffsRsRrmooptnhr'vSfwMnvSiffs8vR'iM|rmsSvSfwMixffs
|nhozo/5nhslozozrmsSvSxnvSiffklzjlpqr'xRiKnxRiExRiixRxRiffkvSfnhsA24- 5)
67698vR'ix6|nhoozsUmlz|nxRi
dmxRfhopiffwMnvRlz|ZnxRiMkmlz}elzkmiffklzjvSf0vR'xRiiM|nvSiqhfhxlpiffsff  miCxsSv$|nvSiqhfhxRth-xiixRxiffkEvSfnhs  4i
j
 BZ
xRiffsRryopvRsxRfwn0|rmsSvSfw\ix	sk'iff|lzsRlpfjEvSfOmnhj'q0r'dfjvR'i&sRtesSvSiffwI sRnhw\dopi  4i
j
 Bkylznhopfhqr'i
lzslzjlpqrmxRi&e|nhozopix$wMn	tEmnhj'qJr'd"iff|nhrysSi&ls k'i&ls*xrmsSvSxnvSiffklzvRvR'i,sStusSvSiffwOfr'xqhfnho
lzs5vSfJopiffnxj0xRfw vR'i8|Lfhxdyrms5ml|OsStusSvSiffw iffmn	}elzfhxsKopiffkOvSfMvRmiI|nhozopixffsKxrmsRvSxnvRlpfjZ
eT
 T 
 4 

 4 
Vfi
 Vfi
 1 

 (K
Z
 (, 
 .q
#9, !l!q?	
m 	Nq< * !q?I
7  *?9/
P
 .?'\
\
 6on  !< !Pff  n!9m
 ?	 99u ?G9  q!J !K
7T,G?^ffP%
%C1?|<9B q)n)<p"
n 
<.<PG?ffP% * , G=\, 1@d, ff 0
Nq)n#Tff%l q<qI.B9
s tRu%v   +
 rq;
lpqrmxRi8eUcunhw\dopi  4i

j 
B $lznhopfhqrmi

 mi5sRiff|Lfjmk,dmxRfhyoziffwMnvRlz|U|nvSiqhfhxRt\ w \x 4DyDhxRiffsRryopvRsDxRfwn$ermwMnhj,|rmsSvSfwMixG|nxRi*nqhiffjvs
k'iff|lzslpfjvSfvRnghif}hix8vR'i6|nhozo)xRfwvR'isStusSvSiffwO6aiff|nhrysSi  lzsiLud"ixlzw\iffjvRnho/Ziffnh|;|nhozo
kmr'xlzj'q5vR'iGiffozkIvSxlnhohUnhsDw\fjmlzvSfhxRiffkIetInermwMnhjCnqhiffjvsSixR}ulzj'qnhsDn*PlpffnxkIP'f|Lfrmozk8f	}hixRxlzk'i
vR'isRtesSvSiffw  'ixiMaixinjermw8ixIfhKnqhiffjvRs8P'fdynxRvRl|lpdynvSiffknhs8lpffnxkmskyr'xlzj'q0vR'ivSxlznho
fh  nhjykOiffnh|Elpffnxk05nhsslzw\dyoptvSfozkOvSfvRnghiCf	}hixvR'iI|nhozolzDzs kmiIdix|Lifflp}hiffkOdmxfhyopiffwMs
lpvR8vR'i5sStesRvSiffwOsDd"ixfhxwnhjm|Lih  mi~lpffnxkZs-kmiff|lzsRlpfj8Unhsopfhqhqhiffk&etvR'iaiLudixlzw\iffjvRnhosRivRr'd
xRiffsRryopvRlzj'q&lzj0ozniffozozlzj'q8vR'iI|nhozonhsKfj'i$vRmnvKvR'i$lzffnxkJvSffhgJf	}hixffK-|LfrmxsSi$aiI|nhj0fjyoptlzj'ix
mnvUwMlpqv~mn	}hiw\fhvRlz}nvSiffkJvR'iPlpffnxk\vSf&vRnghif	}hix5vR'i$|nhozo/r'vGUiPnhsRsRryw\ivRmnvavR'iPlpffnxk
mnhkqhffukxiffnhsSfjfhx$k'flzj'q6sSf'kmlznhozfhqr'iI'ixi8vR'iClpffnxkEk'iff|lzk'iffkvRmnvPvRmiCkmlznhozfhqr'i85nhs
dmxRfhopiffwMnvRlz|$nhjmkOvSfefhg0f	}hixvR'iI|nhozolsKsR'f	PjlzjOlpqr'xR3
i ;e
eT
 T 
 4 

 4 
Vfi
 Vfi
 1 
 1 
 " 

Z(K(,
* -{, 1
| }0

.q



 ?	"+9 K%?
~ z?2d*WndC.q1
SF  ?ffd?BZT & ff?9&qE(;(5
. dCnn?z.	1 $q(

()?|)Cq.	6'
mD Lq D?ff%9  
F  & ! 
T $Dqd 9Td.dffP%K & ! 2" 
2 "a1 V 4 
 ?	"
+ 9 D9?  6zq?ff
% <qB.'
Nas . 
( q-+ u
lpqr'xRi3;e5cunhw\dyopi)w

vSiffw

* ',.-?/|
?qfi,o!
0

gx 4Dylnhopfhqr'i

 iMvRmlpxkdmxRfhyopiffwnvRlz|\|nvSiqhfhxRthGvR'iP2fi4-<5
p4  D8kmlznhopfhqrmiffs-nxRiJ|nhsSiffsC'ixRiMvRmi6sStus
 m
|LfwMdyopivSiffkvR'iE|nhozo/~r'vM|nxRxlpiffkfr'vMnvRnhsSgvRmnvM5nhsjmfhvMvR'iOfj'ivRynvMvR'i|rmsRvSfw\ix
4ff3	2

fi>

> 9?f7A@d.22

72

5nhs8nh|LvRrmnhozoztxiffr'iffsRvRlzj'q'jiL'nhw\dyopi24-<5
<4  D8kmlznhopfhqr'iMlsqlp}hiffjlzjDlzqr'xRi\' 
Cf
lzjvSixRdmxRivSiffkEr'vSvSixnhjm|Lb
i :nhsnxRiffrmiffsSvvSfJwMnghiCnvRmlpxkuHdnxRvt0|nhozoZih q'KvSf 5HP,[ehM
 [eh"   vR'iffjnhsRghiffkvR'iJ|nhozopixIfhx8vR'i6lzj'fhxwMnvRlpfjlpvCj'iiffk'iffkvSf|nxRxRtfr'vIvRylzsvRnhsSg"
vR'i8|nhoopix*|Lfw\dyozlziffkZ'nhjmkOvR'i8sRtesSvSiffw|Lfw\dyopivSiffkvR'iI|nhozo/
eT
 T 
 4 

 4 
Vfi
 Vfi
 1 
 1 
 " 
 " 
 2 

Z(K(,
* -{, 1
| }0

.q



~

W

1

 ?	"+9 K%? z?2d* ndC.q
q6G )STC%F )n? m
Nql DffP
 %
 )n.||.B *qm%!I?
  T	
 1!? ff
 %
 

 ?	 #. -L
 D ql
 DffP
 %
 lBB.
T  ?9 4$4 $4

Nql
 %
 n.|I.BD?I
 B

 @ 
ff 
 =u@
44 	4
() q'
 



r



&



b



'")" )&)&

& $$ p"'" p&p&* fi|

C,

(

0

lpqr'xi'Ucunhw\dyozi#24-<5
<4  D8J$lznhozfhqr'i

Yb%Q  b Q]  XKQ  b ]
$r'x0iLudixlzw\iffjvRs0ndmdyoptvRmiwMnh|mlj'iopiffnxjmlzjmqdmxRfhqhxnh
w D  BEBE8=D
HUfmiffjZ&ffhheCffhhJvSf
hn r'vSfwMnvRl|nhozopt|oznhssRlptvR'ikmlznhopfhqr'iffsJnhs0dmxRfhopiffwMnvRlz|fhxsRrm||LiffsRsSrmo/D  B=BE8ED lzs6n;nhsSvOnhjmk
iL{6|lpiffjv*xryopiopiffnxjmlzjmq&sStusSvSiffw k'iffsR|Lxlpiffk0lzjOw\fhxiIk'ivRnhlzolzjH5f'iffjZffhhe-ffhh"Ui8k'iffsR|Lxlz"i
lpv*yxlpi ytJ'ixRiIfhxP|Lfw\dopivSiffj'iffsRs
 D  B=BE8EDlzsynhsSiffkOfjvR'i R yHRR  RL    y
 Z
/ C~5$nhopqhfhxlzvRmwk'iffsR|Lxlz"iffklzj?mr'xj'gexnhj' lzkyw\ixff~ffhA
 D  BEB=8EDlzw\dmxRf}hiffsfj/ Ca
lpvR0nhjlj'fhxwMnvRlpfjJqnhlzjOw\ivSxl|PvSf\qrylzk'i$xrmopidmxryjmlzj'q&nhjmkOn\Eljmlzw&rmwiffsR|LxlpdmvRlpfjOiffj'qhvR
fhx~$ZHynhsSiffk'iffr'xlzsRvRlz|Gfhx~k'ivSixwlzjmlzj'q'f	?wMnhjtCxrmopiffssRmfrmozk&i5oziffnxj'iffkOsSiiUfmiffjOffhhe
ffhhEfhx,w\fhxRi0k'ivRnhlzoslpghi6fhvR'ix\opiffnxj'ixse
 D  BEBE8EDvRnghiffs,nhs&lj'dyr'vvR'i0jmnhw\iffsCfh*nsSivCfh
p   avSf&i$opiffnxj'iffkvR'ijmnhwMiffsUnhjyk6xnhj'qhiffsUfh}nhozr'iffsUfhnCmuiffk6sSiv5fh Ih  S mnhjmk Sy
 Z
hH sSdiff|lptulzj'qvR'i\|oznhsRs$nhjmkEiffnvRr'xi&}nhozr'iffsfhx$iffnh|iL'nhw\dyopi,lzjn6vSxnhlzjmlzj'qJsSivvRsPfrmvSdyr'v
lzsUn ff   ahh
 Mff fhxUdmxRiffkmlz|LvRlj'qIvR'i$|oznhsRsUfhr'vRr'xRiiLunhw\dopiffsuiLedyxRiffsRsSiffkJnhs5nhj6fhxk'ixRiffk
sSiv*fhlpHvR'iffjOxryopiffs
opvR'fr'qnhjtfj'i\fhUn0jrmwCix$fhaopiffnxjmixs$|Lfrmozki&ndmdozlpiffkEvSfJvRylzsdmxRfhyopiffw"Ui\mnhkn
jermw8ixKfhDxRiffnhsSfjms*fhx|'fefsRlzj'N
q D  BEBE8ED)lpxsSvmlzvU5nhslw\dfhxRvRnhjv5vSfMinyopivSf6lzjvSiqhxnvSiIvR'i
xRiffsRryopvRs~fh-ndmdyoptulzj'qvR'i$opiffnxjmixaynh|g6lzjvSf8vRmi  sRd"fhghiffjJkmlznhozfhqr'iPsStusSvSiffwOG~xRi}ulpfrmsaafhxRg
sRr'qhqhiffsRvRs*vRmnv*vRmiIlpHvRmiffjOxrmopiffs5vRynC
v D  BEB=8EDrmsSiffsKvSfMiLudmxRiffssKvR'iIopiffnxjmiffk|oznhsRsRlp|nvRlpfjOw\fuk'iffo
nxRi5iffnhsSt&fhx)difhdyoziavSfIrmjyk'ixsSvRnhjmk0H5nvRopivSv"ffhu'5f'iffjZmffhhuwMngelj'qlzvDiffnhslpix)vSfIlzjvSiqhxnvSi
vR'iJopiffnxj'iffkxrmopiffsIljvSfvRmi  sStusSvSiffwOEceiff|Lfjmke
 D  BEBE8EDsr'dmdfhxRvRs|LfjvRlzjrmfrms)sStuw8fozlz|
nhjmkvSiLevRrynho~ynqsSivIiffnvRrmxRiffsOHUf'iffjZKffhhGylzopiMfhvR'ix,opiffnxjmixssRrm|;nhsM5oznhsRsl|nvRlpfj
nhjm
k *iqhxRiffsRslpfjMvSxRiiffsH5'
   *UxlziffwMnhjZmxlpiffkmwMnhju$ozs'iffjZ cevSfj'ihffhmk'fCj'fhvUsRr'dmdfhxRv
vSiLuvRrmnho~nqEiffnvRr'xRiffs  'ixRinxiJsSi}hixnho~vSiLuvRrmnhoUiffnvRrmxRiffsCljvRmlzsCkmnvRnhsSiv&vRmnv&dmxRf	}hi0rmsSirmo
lzj|oznhsRsRlztulzj'qvRmikylznhopfhqr'iffs $jmiEfhCvR'iEiffnvRr'xRiffs0vRynvJUilzsRmiffkvSfrmsSi5nhs6vRmisRvSxlzj'q
xRidmxiffsSiffjvRlj'q8vR'ixRiff|LfhqjmlzixffsKtedfhvR'iffsRlzsff  ylzsalsasRrmdmdfhxRvSiffklz
j D  BEB=8EDiff|nhrmsSivR'ixRilzsUj'f 
 h olzwMlpvRnvRlpfj$fjCvR'iUsRlpiGfh'vR'iUsSiv  'i~rmsRirmoj'iffsRsZfhuvR'iavSiLevRrmnhoiffnvRr'xRiffsDlzsiLuiffw\dyozlpyiffklzj
ceiff|LvRlpfj6eH ;e~lzjmnhozopthhdyxRi}elzfrmsafhxg&lzjMmlz|,aiynhkMndmdyozlziffkCfhvRmixaopiffnxjmixsvSf8vR'i   H u-
4ff3

!

fi

2Zy222S2-



7M1m



72

  8dmxRiffkylz|LvSfhxffGr'vRlzolpfflzj'qvRmiJiffsSv,dixRfhxwMlzjmqiffnvRrmxRisSiv,lpvRvR'i0vSiLevRrynho5ynqiffnvRrmxRiffs
xRiffw\f}hiffkZKsRr'qhqhiffsSvSiffk?vRmnvMUi|Lfrmokj'fhvMiLud"iff|Lv6nhjtsRlpqjyl|nhjv\d"ixfhxwnhjm|Lilzw\dmxf	}hiffw\iffjvRs
xRfw rmsRlj'q,fhvR'ixopiffnxjmixs8nhopghixPivPnho/pyhhh|	
 jIfhxkmixvSfvSxnhlzjIvRmi~dmxRfhopiffwMnvRlz|)kmlnhopfhqr'iGdmxiffkmlz|LvSfhxUa$UrD  BEBE8=DMrmsSiffs-nsSiv-fh'iffnvRr'xiffs
sakmlsR|rmsRsSiffk6nf	}hih'lzjmlpvRlnho'iLedixlw\iffjvRsasR'faiffkJvRmnvUvR'iPynhjmkuozniffozopiffkJ'$D  )iffnvRrmxRih
ml|iffjm|Lfuk'iffs-'ivR'ixDnhj8r'vSvSixnhjm|LiUynhsiiffj8wMlsRrmjmk'ixsSvSffukfhxDjmfhvlsmlpqmoztkmlsR|LxlzwMljmnvSfhxRt
lzjJlzk'iffjvRlptelzjmq8dmxRfhopiffwMnvRlz|Pkmlznhopfhqr'iffsffGfai}hixffnhozoyvRmiiffnvRr'xRiffsKrysSiffkJvSf\vSxnhlzj6vR'i~$w&rmsSv
iavSfhvRnhooptCnhr'vSfwnvRlz|KlpmUi*nxRi5vSfIrmsSi5vR'iK~$lj&nUfhxRgulzj'qsSdfhghiffj,kmlznhopfhqr'i5sStusSvSiffwOjCfhxk'ix
vSflzw\dmxRf}hivR'iJdixRfhxwMnhjm|LiMfhvR'irmozoptnhr'vSfwMnvRl|Ja$-DUiJk'i}hiffozfhd"iffknrmozoztnhr'vSfwnvRlz|
ndmdmxfff'lzwMnvRlpfjfh$vR'imnhjykuozniffozopiffkiffnvRrmxRih5mlz|ai|nhoo5vR'i   H  u$D   &iffnvRrmxRih
lzjsSidynxnvSiiLedixlw\iffjvRs0PlpvR
 D  BEBE8=D  mivSxnhlzjmlzjmqfh&vR'i   H  u$D   JiffnvRrmxRilzs
kmlzs|rmsRsSiffk0lzjEcuiff|LvRlpfje

~}elzkmiffjm|LiKxfwdmxRi}ulpfrmsvSxlnhozsfh 
Cf sRr'qhqhiffsRv~vRmnv~lzvGlzs)lzw\dfhxRvRnhjv)vSf8lzk'iffjvRlpt8dmxfhyopiffwMs
lpvRylzjn|Lfrmdyopi0fhPiL'|ynhj'qhiffsnhjmkhfhPvR'iOkmlnhopfhqr'iffs\lzj;vR'i|LfhxRdrms\nxRi0y}hiOiL'|mnhjmqhiffs
fhxCoziffsRs  ermsiffnvRr'xRiffs8fhxIvRmi\yxsSvv afiLu|mnhj'qhiffs&nxRiMiffjm|Lfuk'iffkslzjm|Li,vR'iMqhfnhoalzsvSf0 RRh	
nhlzozr'xRiffs&ifhxRi0vR'it;yndmdiffjZ  miJiLudixlzw\iffjvRnhoKnx|mlpvSiff|LvRr'xRiOfhvR'ialzs\lzozormsSvSxnvSiffk;lzj
lpqr'xRie  mlzs,sRmf	s\'f
 D  B=BE8EDlzs\rmsSiffk;yxsSvCvSfdmxRiffkmlz|Lv   H  u$D   &fhx\vRmi0yxsSv
nhjmk;sSiff|LfjmkiLu|mnhj'qhiffs  mlzs8iffnvRrmxRi6lzsCiffklzjvSfvR'i0~$nhopfj'qElpvRvR'i6fhvRmix&nhr'vSfwnvRlz|
iffnvRr'xRiffs  miPfr'vSdr'v~fhvRmi$a$k'ivSixwMlzjmiffs~mivR'ixavRmisStusSvSiffw|LfjvRlzjrmiffsufhx5lznCdyxRfhyopiffw
lzsDdmxRiffkylz|LvSiffkZvR'iK$lznhopfhqr'i*nhjmnqhix~wMn	tCnhkmndyvlzvRs)kmlznhopfhqr'i5sSvSxnvSiqht&fhx)vSxnhjmsRix)vR'iK|rmsRvSfw\ix
vSfnM|rysSvSfw\ixPnqhiffjv
culjm|Lih ; fhCvR'ikmlznhopfhqrmiffs6|LfjmslzsSvSiffkfhIfjmoztvUfiLu|mnhj'qhiffs$UiiLu|ozryk'iEvRmisRiff|Lfjmk
iL'|mnhj'qhiPiffnvRrmxRiffs)fhxGvR'fsSi*kmlnhopfhqr'iffs'ixiKvR'i*sSiff|Lfjmk\iL'|ynhj'qhiP|LfjmslzsSvRsfjmoptCfhvR'i*sStusSvSiffw
dyozn	telj'qn|opfsRlzj'qdyxRfw\dmvDinhozsSfiL'|ozrmkmiffk\nhjt,iffnvRr'xRiffs)vRmnvalzjmkmlz|nvSiffk&vSfIvRmi|oznhsRsRlpyixvRmnv
vR'i~sRiff|Lfjmk8iL'|ynhj'qhia5nhsvRmiaoznhsSviLu|mnhj'qhi5lzjvR'i~kylznhopfhqr'ih-iU|Lfw\dnxRiGxRiffsRryopvRsZfhx RRh	
 Z
dmxRfhopiffwMnvRlz|5kmlznhozfhqr'iffshlpvR,xiffsRrmopvRsDfhx Ly I
y
d
R
x
h
f
y

p
o
ff
i
M
w

n
R
v

l
U
|
y
k
z
l
h
n
p
o
h
f

q
'
r
ff
i

s
h

P

'

ff
i
,
j
R
v
'

*
i

|
z
o
h
n
R
s

s

l
y

ix
 Z
mnhs*nh||LiffssvSfMiffnvRr'xRiffsxRidmxRiffsRiffjvRlzjmq&vRmiI'fopikmlnhopfhqr'ih
 jfhxkmix8vSfvSiffsRvCvR'i   H '$D  dmxRiffkml|LvSfhxCnhs8lj'dyr'vvSfEvR'i6aD-aiyxsSv8kmiLj'iffk
nvSxnhlzjmlzj'qnhjykvSiffsSv,sSiv8fhx&vR'i6|LfwCylzj'iffkdmxRfhyoziffwO  'iMvSiffsSv,sSiv8fhx&vR'i   H  u-   
dmxRiffkylz|LvSfhx|LfjvRnhlzjms-vR'iGiL'|mnhj'qhiffsDvRmnv-fe||rmx-lzjvRmiakmlznhozfhqr'iffsZfhuvR'iaa$vSiffsSvsSivDiasSiffoziff|LvSiffk
n*xnhjmk'fwhkmlznhopfhqrmiffsnhsvRmi~vSiffsSvDsSiv-nhjmkIvR'iffjIiLuvSxnh|LvSiffk&vR'ia|LfhxxRiffsSdfjmkmlzjmqUiL'|ynhj'qhiffsK ;hhh
iL'|mnhj'qhiffsculzwlzoznxoptfhx6vSxnhlzjmlzjmq'UvRmi~$vSxnhlzjmlj'qsSiv0|LfjvRnhlzjyP
s ;hhhkmlznhopfhqrmiffsMml|
|LfhxRxRiffsRd"fjykms5vSfn\vSfhvRnhofh5ffh'8iLu|mnhj'qhiffsPfhxvSxnhlzjmlzjmq&vRmi   H '$D  5dmxRiffkmlz|LvSfhx	
 miMiffnvRrmxRi   H  u-   $lzs8dmxRiffkml|LvSiffkfhxCiffnh|r'vSvSixnhjy|Li6lzjvRmivSiffsSv&sSivvRrms8iffju
nyozlj'q6vRmiMsStesRvSiffwvSfOiMrmsSiffkfjj'i kmnvRnlpvR'fr'v$vR'iMjmiiffkfhx8ynhjmkuozniffozozlj'q'Ifai}hix	
vR'ixRi&nxRi&vUf6dfsRsRlzylzozlpvRlziffsafhxvR'i8fhxlzqlzjfh)vRmls*iffnvRr'xRiCljvR'iCvSxnhlzjmlzjmqsSiv  miIyxsRv*dfsRsRl
ylzolpvtlzs$fhxvR'i,vSxnhlzjylzj'q0sSivvSfnhozsSfO|LfjmsRlsSv$fhasSfopiffoztEnhr'vSfwMnvRl|,iffnvRr'xiffs  mlzsw\ivR'fukmnhs
vR'i,dfhvSiffjvRlnho)nhk'}nhjvRnqhiMvRmnvvRmi\vSxnhlzj'iffk~$PlzozoD|Lfw\diffjmsRnvSihlpaj'iff|LiffsRsRnxRthfhxynvSi}hix
j'flzsRiiL'lzsSvRslzj0vR'i   H  u$D   UdmxRiffkml|LvRlpfjmsxlpqvhh5PjOnhopvSixjmnvRlp}hiIvSfMvSxnhlzjmlzj'q
vR'iIafjOvR'iInhr'vSfwnvRlz|nhozopt0k'ixlp}hiffk   H u-   aiffnvRr'xRiIlzs5vSfvSxnhlzjOlpvKfjOvRmiImnhjmku
ozniffozopiffkEu-   aylzopi$sSvRlzozo"vSiffsSvRlzjmqlpv5fjvR'iInhrmvSfwMnvRlz|iffnvRr'xRih  mlzsKsSiff|Lfjmkw\ivR'fuklzs
xRiixRxRiffkOvSfJnhs6Synhjmkuozniffozopiffk'HvSxnhlzjmlzjmqIfhx [!  u$D     mlzsKwMn	tOdmxRf}elzkmiInw\fhxRiCnh||ru
xnvSi\w\fuk'iffo-yr'vPlzvwMn	tEj'fhv$|ndmvRr'xiCvR'i\|mnxnh|LvSixlzsRvRlz|s$fhGvR'i,nhr'vSfwMnvRlz|&iffnvRr'xRi\lzjEvR'i&vSiffsSv
sSiva
 iffsRrmopvRs*fhx*vRmiffsSiIvUfw\ivRmfekmsnxRiIdmxRiffsRiffjvSiffkljceiff|LvRlpfje '
4ff3p&

fi>

> 9?f7A@d.22

72

SLU Features
Exchange 1

SLU Features
Exchange 2

autoSLUsuccess
Feature Predictor
Exchange 1

autoSLUsuccess
Feature Predictor
Exchange 2

System
Continues

Yes
Automatic
Features
Exchange 1&2

PDP
P(Success)>T
No

lpqrmxRi8eUcetusSvSiffw

D

B

C

nx|mlpvSiff|LvRr'xi8rmsRlzjmq&iffnvRr'xRiffsxfw
autoSLUsuccess
predictor training and testing

A

A

B

C

D

PDP Training Set

Adapt DM
Transfer to
Human
Customer
Agent

vR'i$yxsRv,iLu|mnhj'qhiffs

A

B

C

D

Test

TEST
PDP Test set

lpqr'xRi8eanvRnfhxPsSiqw\iffjvRnvRlpfjErysRlzj'q\|LxRfsRsSH}nhozlkmnvRlpfj
 miCdmxfhyopiffw lpvRrmsRlzj'q   H  u$D  fhx$vSxnhlzjmlj'qvR'i\alzsvRynvvR'i&snhw\i\kmnvRn
zl sOrmsRiffkvSfvSxnhlzjvRmi   H  u$D  JdmxRiffkmlz|LvSfhx	  'ixRifhxRih$airysSiffkn|LxRfsRsSH}nhozlkmnvRlpfj
vSiff|yjmlzer'iEnhozsSfgej'fjnhs%Snh|gHgujml"j'qMifflzssC8rmozlpghfsSgul/~ffhu	)'ixitvR'ivSxnhlzjmlzj'q
sSivIlzs$dnxRvRlpvRlpfj'iffkljvSfOsSivRsff  'xRii,fh5vR'iffsSiMsSivRs8nxRirmsSiffkfhxvSxnhlzjylzj'qOnhjmkvR'i\fr'xRvRfhx
vSiffsSvRlzjmq'  'i&xRiffsRrmozvRsPfhxvR'i,fr'xRvRsSivnxRi\j'fhvSiffknhjmkvR'i,dmxRfu|LiffsRslzsxRidiffnvSiffkZZxfhvRnvRlzj'q0vR'i
sSivRsPxfw vSxnhlzjmlj'q\vSfvSiffsSvRlj'q'  mlzs5xRiffsRryopvRs*lzjn6|Lfw\dyopivSi&ozlzsSv5fh)dmxiffkmlz|LvSiffk   H  u-   
fhxKvR'ivSxnhlzjmlj'qCsSiv  'i$iffnvRrmxRiffsKfhxKvR'ivSiffsSv*sSivKiL'|mnhjmqhiffsnxRik'ixlz}hiffk0t6vSxnhlzjmlzjmb
q D  BEBE8ED
fjOvR'i8'fopi$vSxnhlzjylzj'q\sSiv  ylzs5dmxRfu|LiffsRs*lzsKlozozrmsSvSxnvSiffkJljODlzqr'xRi8e
 miCfozopflzj'qsRiff|LvRlpfjqlp}hiffs$n6yxRiffngekmf	jEfhGvR'i\lzj'dr'v*iffnvRr'xRiffsIceiff|LvRlpfjJk'iffsR|Lxlz"iffsvR'i
vSxnhlzjylzj'q6nhjykExiffsRrmopvRsPfhGvR'i   H  u$D   *dyxRiffkmlz|LvSfhxnhjmkceiff|LvRlpfj6xRidfhxRvRsPvR'i\nh||r'xnh|Lt
xRiffsRryopvRs5fhxvR'i8~$D

GYNMPORQJQ `l Q


4ff3	3

fi

2Zy222S2-



7M1m



72

 B\~#
 P

 xiff|Lfhq'xRiff|LfhqjermwCafhxkysnhsSxRkmr'xnvRlpfjkmvRw\"nq'xRqw\fukmnhozlpv thhxRqHqhxnhwMwnxffvSiffw\df
 Z~#
 n|Lfj'k'iffjm|LiOw\iffnhsRrmxRi0fhx\iffnh|fhvRmiffdfsRslpyopi6vRnhsSgesMvRmnv,vR'irmsSix\|Lfrmozki
vSxtelzjmq\vSfk'f

 snhozlpiffjm|LiL|Lf}hixnqhih ljm|LfjmsRlzsRvSiffjm|Lth|LfjvSiLuvsRmlpvvSfhdmHvRnhsSg 'j iLevSvSfhdmHvRnhsSgvSfhd'
|Lfj'k'iffjm|Lihykyl|Lfj'k'iffjm|Lihm|Lfj'dixRvRlzw\ih'sRnhozd"ixvRlzw\ih'nhr'vSfcu
*
: sRry||LiffsRs
J

9

~2 #}p~2#~$u~2#

 <BY2~#

 sRteson"iffoHurmvSvlzkZ'dmxRfwMdmv'xRidmxRfwMdmvm|LfjuyxwnvRlpfjZ'sRr'Zkmlznho

 xrmjmjmlzjmq;vRnhoozlpiffsjermw,r'vSvRsffIjrmw\HxRidmxRfw\dyvRs$d"ix|LiffjvHxRidyxRfw\dmvRsjermw,|LfjuxwMs
dix|Liffjv|LfjuyxwMsmjermw,sRr'Zkmlnhozsdix|LiffjvsRr'Zkmlnhozs

 P'fopiIkmlznhozfhqr'ihGkmlznhokyr'xnvRlpfjZ
 '#
 ~$
 
 Y~2#P~El
 vRs|LxlpdmvrywMnhjuozniffo/ nqhihqhiffjmkmixff rmsSixSw\fukmnhozlzvth|oziffnhjuHvRsR|Lxlpdyv|opvRs|Lxlpdmv
jermwCafhxkmscu
*
: sRry||LiffsRs
Dlzqr'xRiC~'iffnvRrmxRiffsfhxsSdfhghiffjkylznhopfhqr'iffs

kmlnhopfhqr'i|LfjmslzsSvRsGfhnCsSiffer'iffjm|LifhZiL'|ynhj'qhiffsU'ixRiPiffnh|JiLu|mnhj'qhi$|LfjmsRlzsRvRsGfhZfj'iPvRr'xj
etvRmisStusSvSiffwfozopfaiffktfj'iMvRrmxjetvRmirmsSixffP~nh|kmlnhopfhqr'iMnhjmkiLu|mnhj'qhi6lsiffjm|Lfuk'iffk
rmsRlj'q6vRmiMsSivIfhKh ;0iffnvRrmxRiffsIlzjlpqr'xRi6
 anh|iffnvRr'xRi\5nhsIifflzvR'ixInhr'vSfwMnvRlz|nhooptozfhqhqhiffkt
fj'iMfh5vR'i6sStesRvSiffww\fukmrmoziffsmnhjmkuon"iffoopiffktermwMnhjmsfhxCk'ixlz}hiffkxfwxn	 iffnvRr'xRiffs  'i
mnhjmk'ozniffozopiffk&iffnvRrmxRiffsanxiPrmsSiffkMvSfCdmxfekmry|Li*
n 2FBy  i8ZnhjMiffsRvRlzwMnvRlpfjfh'f	?aiffozonI|oznhsRslyix
|Lfrmozk0k'f,vRmnv*ynhkOnh||LiffsRsKvSf\dixRiff|Lv*lzj'fhxwMnvRlpfjZ  fMsSii'ivR'ix5fr'xKxiffsRrmopvRs5|nhjOqhiffj'ixnhozlpih
Ui&nhozsRf6iLudixlzw\iffjvlzvRrmsRlj'qnJsRr'ysSivPfhGiffnvRr'xRiffsvRmnv$nxRiCvRnhsRglzjyk'idiffjmk'iffjvPk'iffsR|Lxlpiffklzj
k'ivRnhlzo"iffozf	I
'iffnvRrmxRiffsopfhqhqhiffktvR'isStusSvSiffwnxRir'vRlozlpiffk"iff|nhrysSiOvR'itnxRi0dmxRfukmrm|Liffknhr'vSfwMnvRlz|nhoopth
nhjmkvRerms0|nhj"irmsSiffkkmrmxlzj'qxrmjvRlw\iEvSfnhopvSixOvRmi|LfrmxsSifh8vR'ikmlznhozfhqr'ih  'isStusSvSiffw
w\fukmrmopiffsGfhxamlz|opfhqhqlzjmq8lzj'fhxwMnvRlpfjMUnhsU|Lfozopiff|LvSiffk6aixivR'inh|LfrmsSvRlz|dmxRfu|LiffsRsSfhlx knhr'vSfwnvRlz|
sSdiiff|,xiff|Lfhqjmlpixg 4-< D~g Plz||nxkml'fhxlzjhhhvR'iKsSdfhghiffj,oznhj'qrmnqhiKrmjmkmixsSvRnhjmkmlj'qCH-
w\fukmrmopi8H$fhxlzj6ivanho/pffhhmnhjmkMvRmiP$lznhopfhqr'iEnhjynqhixg y  iffozon8 $fhxlzjZ"ffhha
 ~nh|
w\fukmrmopinhjmk0vRmiIiffnvRrmxRiffs*fhmvRnhlj'iffk0xfw lpv*nxRi8kmiffsR|LxlpiffkJiffopf	I
Aq9 ~\lff12#   'inhr'vSfwMnvRlz|OsRd"iiff|xRiff|LfhqjmlzixEg 4- DCvRnghiffs6nhs
lzj'dr'vIvR'iO|nhozopix	s&sRd"iiff|nhjmk;dmxRfukmrm|Liffs&nEdfhvSiffjvRlznhozoptixxRfhxRrmoGvSxnhjysR|LxlpdmvRlzfjfh*Pmnv&lzvCiL
ozlpi}hiffs*vR'i8|nhozopixPsRnhlzkZ  '
i 4- DiffnvRr'xRiffsfhxiffnh|EiLu|mnhj'qhiCljm|ozrmk'i$vR'i8fr'vSdyr'vKfhvR'i8sRd"iiff|
xRiff|Lfhqjmlzix RR} Z PvR'iEjermwCixfhUfhxkmsJlzjvR'iExRiff|Lfhqjmlpix0fr'vSdr'vE RR Z    &~h RvR'i
kmr'xnvRlpfjlzjsSiff|Lfjmkysfh5vR'ilzj'dr'vPvSfvR'iMxRiff|LfhqjmlzixJ        GA
n nqOfhx8vSfrm|vSfj'iJlzju
Vp$p$

fi>

72

> 9?f7A@d.22

dyr'v hgI o <Z vR'ilzj'dyrmvaw\fukmnhozlpv tMiLud"iff|LvSiffkt6vR'i$xRiff|LfhqjmlpixC Z  Mff! 8fj'ifhGj'fj'ih
sSdiiff|vSfrm|vSfj'ihsSdiiff|9$vSfrm|vSfj'ihDvSfrm|vSfj'iL|nxkZsSdiiff|vSfrm|vSfj'iL|nxk-vSfrm|vSfjmiL
kmnvSihsSdiiff|9
 vSfrm|vSfj'iLkynvSihfhxj'fj'iL/jynhoHdmxRfw\dyv"nhjmkvR'i,qhxnhwwMnxrmsSiffktvR'iCxiff|Lfhq
jmlpix\  Z  ZhSr +\h ,g Plz||nxkml$fhxlzjZhhi\nhozsRfJ|nhoz|ryoznvSiCn6iffnvRrmxRi&|nhoopiffk     t
kmlp}ulzkmlj'q8vR'i8}nhozrmifhvR'i       Sh/ iffnvRr'xiItJvR'i RR} Z    ,~S iffnvRr'xRih
i 4-< DiffnvRr'xRiffslzs&vRmnv\nhjt;fj'i0fhPvRmiffw wMnfft;xRi yiff|Lv,xRiff|LfhqjmlzvRlpfj
 mi0wMfhvRlp}nvRlzfjfhx\vR'
dixRfhxwMnhjm|Li6lpvRn|Lfjm|LfwMlzvRnhjv,iLiff|Lv&fjsSdfhghiffj;oznhj'qrmnqhi0rmjmkmixsSvRnhjmkmlj'q''fhx,iLunhwMdyopih
fhvR'ixPafhxRgOmnhsfryjmk       h/ vSfiI|LfhxRxiffoznvSiffklzvRlzjm|LfhxRxiff|Lv*xRiff|LfhqjmlpvRlzfjPlzxsR|ixRq'
lzvRwMnhjZceUixRvRsffhh  'iKjmnhw\iKfh"vR'iKqhxnhwwMnxP  Z  ZhSr +\h ~|Lfrmozk\nhozsRfi*n$dmxiffkmlz|LvSfhx
fh~ixRxRfhxssRlzjm|Li8lzv*lzsKUiffozoZguj'f	jvRmnvvR'iCoznxRqhix*vR'i8qhxnhwMwMnxlzsmvR'iCw\fhxRi8ozlzghiffopt6nh
j 4- D
ixRxRfhx-lzsjnhkmkmlzvRlpfjZffvR'i g Z  Zr +M iffnvRr'xRianhozsSfKiffjm|Lfuk'iffsZiLudiff|LvRnvRlpfjmsnfr'vrysSixr'vSvSixnhjy|Liffs
nv\vRmnv,dflzjv&lzj;vR'iOkmlnhopfhqr'ihGylz|;wMnfft|LfhxRxRiffonvSiOvSfkyl"ixiffjm|Liffs\lzjvR'iOiffnhsSiOlpvRml|
nhjtJfjmi8xRiff|LfhqjmlzixP|Lfrmozk|LfhxRxRiff|LvRoptrmjyk'ixsSvRnhjmk0vRmi8rmsSixffsxRiffsSdfjmsSihK$j'iIw\fhvRlz}nvRlpfjfhxPvR'i
    iffnvRrmxRiKlzsDvRmnv)dmxRi}ulpfrms-afhxgCsRr'qhqhiffsRvRs)vRmnvGrmsSixs-vSiffjyk,vSfIsRopf	k'fj,vR'ifflpx)sSdiiff|,'iffj
vR'i0sStusSvSiffwmnhs,wMlzsRrmjyk'ixsSvSfefekvR'iffw i}hf	8ffhhecu'xlpixRq'Dnhk'iha Gxlz|Lih*ffhh5vRmlzs
sSvSxnvSiqhtMnh|LvRrynhozopt\opiffnhkms~vSf8w\fhxRiPixRxRfhxsGslzjm|Li*vR'iPsSdiiff|Mxiff|LfhqjmlpixalsGj'fhv~vSxnhlzj'iffk\fjvRmlzs)v tdi
fh-sRd"iiff|Z  mi     iffnvRr'xRiIwMn	t6nhozsSfMljmkmlz|nvSi$'iffsRlpvRnvRlzfjmsudynhrmsSiffsffefhx*ljvSixRxr'dmvRlpfjmsffml|
|LfrmozknhozsRfopiffnhkvS
f 4-< DixxRfhxs$j;vR'i0fhvR'ixMynhjmkZ)vSfrm|vSfj'ilj'dyr'v&lzj|LfwCylzjynvRlpfj;lpvR
sSdiiff|unhs5iffjy|Lfek'iffk0etMvR'i$iffnvRr'xRi hg I o  < Z mwMlpqv5ljm|LxRiffnhsSivR'iozlpghiffozl'ffukMfhDrmjmk'ixsSvRnhjmkmlzjmq
vR'isRd"iiff|ZsRljm|LiOvR'iOvSfrm|vSfj'ilzj'dr'v&lsMrmjmnhwCylpqr'frys\lpvM|nhj|LfjmsSvSxnhlzjsSdfhghiffjonhj'qrmnqhi
rmjmkmixsSvRnhjmkmlj'q'
l2P~2#9#~$2##q~2#n'#   'iIqhfnho-fh)vR'iCsRd"fhghiffjEoznhj'qrmnqhi&rmjmk'ixsSvRnhjmkmlzjmq
H-Dw\fukmrmopiKlzsvSfClzk'iffjvRlptCmlz|,fhvRmi8ff$dfsRsRlpopiavRnhsRges~vR'i*rmsSix~ls)nvSvSiffw\dmvRlzj'qCnhjmk,iLevSxnh|Lv
xRfwvR'iIr'vSvSixnhjy|Li8nhjt0lpvSiffwMs5fhlzj'fhxwMnvRlzfj6vRynvnxRixRiffopi}nhjvKvSf|Lfw\dyopivRlj'q,vRmnvKvRnhsSg"mih q'
n\dymfj'ijrmwCix*lzs*j'iiffkmiffkOfhxvR'iIvRnhsSg / I
  
lpvSiiffjfhUvR'i\iffnvRrmxRiffsxRfwvR'i6ffw\fukmrmopi&xRidmxiffsSiffjvvRmiMkmlzsSvSxlzyr'vRlpfjfhxIiffnh|fhUvR'i
ffd"fssRlpyopi,vRnhsSgus&fhKvR'i0ff?w\fekyrmopihsI|Lfju"k'iffjm|Li6ljlpvRs8"iffolpiavRynv8vR'iJrmsSix,lzs8nvSvSiffw\dyvRlzj'q
vRmnvIvRnhsRgH$fhxlzjiv8nhoHpaffhhJi6nhozsSfljm|ozrmk'i\nOiffnvRr'xRi\vSfExRidmxRiffsRiffjvylz|vRnhsSgynhsvR'i
mlpqmiffsSvK|Lfjuk'iffjm|LisR|Lfhxi H  H  ffynhjmk0ml|JvRnhsSg0mnhs5vR'isSiff|Lfjmkylpq'iffsSv5|Lfjuk'iffjy|Li$s|LfhxRi
 " /H  H z ynhsUUiffozonhsUvR'i}nhozr'ifhvR'iylpq'iffsSvU|Lfjuk'iffjm|Li$sR|LfhxRi\ H  h< a nhjmk6vR'i
kmlixRiffjm|LiIlj0}nhozrmiffsKivUiiffjvR'ivSfhdnhjmkj'iLuvHvSfHvSfhd|Lfj'k'iffjm|LiIsR|LfhxiffsC    < UL 
vRmixJiffnvRr'xRiffsJxRidyxRiffsSiffjv6fhvR'ixnhsRd"iff|LvRsJfhCvR'iff dmxRfu|LiffsRsRlzjmqfhIvR'ir'vSvSixnhjy|Lih  'i
    L" iffnvRr'xRilzs\nhjlzjvSxnr'vSvSixnhjm|LiwMiffnhsRr'xRiOfh$sSiffwMnhjvRlz|Okmlp}hixsRlpvth5nh||Lfhxkmlj'qvSfn
vRnhsSgwMfek'iffofh)vR'i,k'fwMnhlzj;iffozozn6fhxlzjZ-ffhhIcefw\i&vRnhsSg|oznhssSiffsfe||r'xvSfhqhivR'ixIermlpvSi
jmnvRr'xnhozoptMlzvRmlzjJnMsRlzj'qozisSvRnvSiffwMiffjvPfhxKxRiffrmiffsSvmih q'GvR'i hfi
 IL3
 M vRnhsSg0lzsK|Lfw\dynvRlpopi$lpvR
vR'i zR	D vRnhsSg"r'v)lzsj'fhvG|Lfw\dynvRlpopi5lpvR&vR'
i  #
 Z,RR vRnhsSg"  'i h#HL  r hLS< Z
iffnvRr'xRi,w\iffnhsRr'xRiffsPvR'iCdmxRfhdfhxRvRlpfjfh)vR'i&rmvSvSixnhjm|Li&mlz|lzsP|Lf	}hixRiffketvR'i&sRnhozlpiffjvqhxnhwwMnx
xnqw\iffjvRs  mlzsCwMnfft;lzjm|ozrmkmiMvR'iJ'fopi6fhndy'fj'i6fhx,|nxk;jermwCix&lp*lzv8fu||r'xs&lpvRmljn
xnqw\iffjv  'i hy}   [ IL iffnvRr'xRiIlzsKnhjOljvSixSrmvSvSixnhjm|Li8w\iffnhsr'xRi$fh-vRmiiLevSiffjv*fhn&smlpvUfh
|LfjvSiLev*n	Un	tJxRfwvR'i|r'xRxiffjvUvRnhsSgfu|rms'|nhrmsSiffkJetvR'i$ndmdiffnxnhjm|Li$fh-snhozlpiffjvadymxnhsSiffsavRmnv
nxRi8ljm|Lfw\dynvRlpopiPPlpvROlpvmnh||Lfhxkmlj'qMvSfn\vRnhsRg0wMfek'iffofhDvR'i8kmfwMnhlzjZ
jnhkmkylpvRlpfjZsRlzwlzoznxOvSfvR'i5nfftUi;|nho|rmoznvSiffkvRmi     iffnvRr'xRihCai;j'fhxwMnhozlzivR'i
 h#HL  r hLS< Z nhjyk H  h< a iffnvRr'xRiffsPtOkmlz}elzkylzj'q,vR'iffw et        vSf6dmxRfukmrm|Li
vR'i h  \  nhjyk < I  \  iffnvRr'xRiffs  'i     nhjmk;vR'i p I  \  nhjmk   LLf 
iffnvRr'xRiffsnxiIrmsSiffkOfjmozt6fhx*dmxRiffkylz|LvRlzj'q   H  u$D  
Vp$T

fi

2Zy222S2-



7M1m



72

 mi5wMfhvRlp}nvRlzfj\fhx)vRmiffsSiJiffnvRr'xiffsGlzsvSf8wMnghi*rysSiKfh"lj'fhxwMnvRlpfj&vRmnv)vR'iPffOw\fukmrmopi
 nhs6nhsnxiffsRrmopv\fh$dmxRfu|LiffsRsRlj'qvR'ifrmvSdyr'vMfh#4-<DnhjmkvR'iE|r'xRxRiffjvkmlzs|Lfr'xsSi|LfjvSiLevmfhx
m
iL'nhw\dyopihfhxCr'vSvSixnhjy|LiffsCvRynvCfozopf vR'iyxsSv8rmvSvSixnhjm|Lih)vR'iO?w\fukmrmopiMguj'fsIynv8vRnhsSg
lpvOiffozlpi}hiffs0vRmi|nhozopixls0vSxRtelj'qvSf|Lfw\dyozivSih  'i y    [ I iffnvRr'xilzjm|LfhxRdfhxnvSiffsvRmlzs
guj'f	oziffk'qhifhKvR'iJkmlzsR|LfrmxsSiMmlzsRvSfhxRthlpvRvR'iJw\fhvRlp}nvRlpfjvRmnvClpKlpvCndmdiffnxsIvRmnv&vR'iJ|nhozopix
mnhs*|mnhj'qhiffkE'ixwMlzjykZuvR'iffjOvR'iCffw\fukmrmoziwMn	tOmnff}hi&wMlzsRrmjyk'ixsSvSfefekJnhjr'vSvSixnhjm|Lih
 ~22}p~2#~$2   'iJrmjm|LvRlpfj;fhvRmi0$lznhozfhqr'iOEnhjmnqhix6lzs&vSfvRnghiEnhs\lzj'dyr'vCvR'i
fr'vSdyrmvfhGvR'iMw\fukmrmozihk'iff|lzkmi8mnvPvRnhsSgvRmiCrmsSix$lzsPvSxRtulzj'qvSf0nh||Lfw\dyolzsRZ"k'iff|lzk'iCmnv
vR'iJsStesRvSiffwlzoo)sRnfftj'iLuv)nhjmkrmdkynvSi\vR'i6kmlsR|Lfr'xsSiMylzsSvSfhxRtP"iffoozn fhxlzjZaffhh  'i
$lznhopfhqr'i,nhjmnqhixIk'iff|lzk'iffsP'ivRmixlpviffozlpi}hiffsvR'ixRi,lzsPnJsRlzjmqopiCrmjynhw8ylzqr'frms*vRnhsRgvRmnv$vR'i
rmsSixPlzs5vSxRtulzj'q\vSfnh||Lfw\dozlzsRZ'nhjmk'f	vSfxRiffsSfop}hi8nhjtOnhw8lpqrmlpv th
'iffnvRrmxRiffsKynhsSiffk0fjOlj'fhxwMnvRlpfj6vRmnvKvR'i$lznhopfhqr'inhjmnqhixopfhqhqhiffkOnfr'vKlpvRsKk'iff|lsRlpfjmsafhx
iffnvRr'xRiffs*xidmxRiffsSiffjvRlzj'q\vR'iCfj'qhflzj'q6mlzsSvSfhxRt6fh)vR'i8kmlnhopfhqr'iIwMlpqv*iIrmsSirmodmxiffkmlz|LvSfhxsKfh~ff
ixRxRfhxs8fhx&vRnhsSgnhlzozr'xihcefw\i6fh*vR'idfhvSiffjvRlznhozoptljvSixRiffsRvRlzj'q$lznhopfhqrmiJnhjmnqhix\i}hiffjvRs&nxlzsSi
kmr'ivSfJopf	|Lfjuk'iffjy|Li8opi}hiffozsKPmlz|opiffnhkOvR'i&lnhopfhqr'i8nhjmnqhixvSf S  Sr    vR'i8rmsRix*fhx
h< Gl  lzvRsrmjmk'ixsRvRnhjmkmlzj'q'$ xidmxRfw\dmv$wMlpqv$i&nJ}nxlznhjvfhavR'i\sRnhw\i\er'iffsSvRlpfjvRmnv5nhs
nhsSghiffk"ifhxRihfhxUlpvG|Lfrmozk\ljm|ozrmk'i5nhsSgulzj'qvR'iPrmsSixGvSf8|'fefsSi*ivUiiffjMv afCvRnhsSges~vRmnv~mn	}hiiiffj
nhsRsRlzqj'iffksRlzwMlzonx|Lfjuk'iffjy|Liffs$tvRmiMff;w\fukmrmopih$'fhxiL'nhw\dyopihZlzjEvR'i\kmlznhopfhqrmi&lzjlpqr'xRi\
vR'i&sStesRvSiffw rmvSvSixnhjm|Li,lzj
c ;|LfrmjvRsnhsn6xRidmxRfw\dyviff|nhrmsSi&lpvPlzsPn}nxlznhjvfh)vRmi&er'iffsSvRlpfjElzj
r'vSvSixnhjy|Li&c'e
 mi&iffnvRr'xRiffs8vRmnvUi\iLevSxnh|LvCxfwvR'iM$lznhopfhqr'iMnhjmnqhixCnxi\vR'i\vRnhsSgHvted"i6ozniffo/  
p   mfsSisSivfh&}nhor'iffsOlzjm|ozryk'in}nhozrmivSf?lzjmkmlz|nvSimiffjvR'isStusSvSiffw mnhklzjmsRru{J|lpiffjv
lzj'fhxwMnvRlzfj0vSfk'iff|lzk'i$fjnsSdiff|l|vRnhsSgHvted"ihvR'iIr'vSvSixnhjy|Li8lzk0lpvRylzjJvR'i8kmlznhozfhqr'iM /  / 
vR'ijmnhw\i*fhZvR'idmxRfw\dmv~dyoznffthiffkvSfCvRmirmsSix$ h    ynhjmkMP'ivR'ixGvR'iPvtedifhdmxRfw\dyvGUnhsUn
xRidmxfw\dmv S  h    "n\|LfjuxwMnvRlpfj h< Gl  yfhx*n\sRr'Zkmlznhopfhqrmi*dmxRfw\dyv$n\sRrmd"ixsSivafh-vR'i
xRidmxfw\dmvRs)nhjmk\|LfjuxwMnvRlpfj,dmxfw\dmvRsK =
  h S  miP     L iffnvRr'xRi*lzs)lzjvSiffjmk'iffk&vSf8|ndyvRr'xRi
vR'iJnh|Lv,vRmnv,sSfw\iJvRnhsSgus,wMnfft"iJmnxk'ixCvRmnhj;fhvR'ixs  'iE /  / iffnvRr'xiJlzs&w\fhvRlp}nvSiffk;t
vR'ilk'iffn0vRmnvIvR'i6opiffj'qhvRfh5vR'ikylznhopfhqr'iMwMn	t"i6lzw\dfhxRvRnhjvdfsRsRlpyoztlzj|LfwCylzjmnvRlpfjlpvR
fhvR'ix$iffnvRr'xRiffsozlpghi6   p     'iCkmlp"ixRiffjvdmxRfw\dmvPiffnvRrmxRiffs$fhxlzjylpvRlznhodyxRfw\dmvRs"xRidmxfw\dmvRs
|LfjuyxwMnvRlpfjdmxRfwMdmvRs,nhjmksRr'Zkmlznhozfhqr'idmxfw\dmvRs\nxRiOw\fhvRlp}nvSiffketxiffsRrmopvRs,lzjmkylz|nvRlzj'qEvRmnv
xRidmxfw\dmvRs~nhjyk|LfjuyxwMnvRlpfj\dmxfw\dmvRs~nxixrmsSvSxnvRlj'qfhxU|nhozopixsanhjmkMvRynva|nhozopixs~nxRiozlpghiffopt&vSf
tdixnxRvRl|rmoznvSiP'iffjvRmitmnff}hivSf,xRidiffnvUvR'iffwMsSiffoz}hiffsumlz|xRiffsrmopvRsUlz
j 4D DixxRfhxs$Hcu'xlpixRq
ivnho/p-ffhhei}hfI-ffhhenhopghixff
 InhwMwOy-lpvRwMnhjZyhhhn
 miEkmlzs|Lfr'xsSiylzsSvSfhxRtiffnvRr'xRiffs0lzjm|ormk'iffkxrmjyjmlzj'qvRnhozolpiffsMfhx6vRmijermwC"ix6fhIxRidmxfw\dmvRs
     R  r    RDjermwCixPfh~|Lfj'yxwMnvRlpfjEdmxRfwMdmvRs\     h< Gl  Rnhjmkjryw8ixfhasRr'Zkmlp
nhopfhqr'iCdmxRfw\dyvRs8    E
  / RvRynvPmnhkOiiffjdyoznffthiffkifhxRi8vR'i8r'vSvSixnhjy|LiC|r'xRxiffjvRoptJifflzj'q
dmxRfu|LiffsRsSiffkPnhsOUiffozo$nhs0xrmjmjylzj'qdix|LiffjvRnqhiffs Ly  R  Sr     cM LSy  < Gl   c& Ly 
=
  h R  'i8rmsRiIfhxrmjmjmlj'qCvRnhoozlpiffs*nhjmkdix|LiffjvRnqhiffs$lzs*ynhsSiffkfjdmxRi}ulpfrmsKUfhxRgOsRr'qhqhiffsRvRlzj'q
vRmnv~jmfhxwMnhozlpiffk&iffnvRr'xRiffsGnxiw\fhxRi*ozlzghiffoptIvSfIdmxfekmry|LiUqhiffjmixnhozlpiffk,dmxiffkmlz|LvSfhxs*-lpvRwMnhjZnhozghixff
 iffnxjmsDffhhiffnvRr'xRi,nff}nhlzoznopiIfhx /L I

 Z dmxfhyopiffwMnvRlz|8kmlznhopfhqr'iffsPlzs h    h/
vRmnvlsKj'fhvnff}nhlzoznopifhxPlzjmlpvRlznhosSiqwMiffjvRsfh-vR'iCkmlznhopfhqr'ih
Y~2Y,~=l''' 	sw\iffjvRlpfj'iffkCn"f}hihvR'iGiffnvRr'xRiffsfhyvRnhlzj'iffkI}ulznKmnhjykuozniffozozlzjmqanxRiUrmsSiffk
vSf&dmxRf	}ulzk'i*+
n 2FBy  i8MnqnhlzjmsSvamlz|MvSf&|Lfw\dynxRivR'idixRfhxwMnhjy|Li*fhZvR'irmozoztCnhr'vSfwMnvRl|iffn
vRr'xRiffsff  miamnhjmk'ozniffozopiffkiffnvRr'xRiffslzjm|ormk'i~ermwMnhjCvSxnhjmsR|LxlpdmvRsfhyiffnh|\rmsSixr'vSvSixnhjy|Li      
nsSivfh$sRiffwMnhjvRl|ozniffozs,vRmnvnxi|opfsSiffoptxRiffonvSiffkvSfvR'isRtesSvSiffw vRnhsSgHvted"iozniffozs [  M 
Vp$ 4

fi>

72

> 9?f7A@d.22

p   "nqhi6 <Z 5nhjmk0qhiffjmkmixC ZL 5fhDvR'iIrmsRixff'vR'iInh|LvRrmnho-w\fekynhozlpvt6fh-vRmi8rmsSix*r'vSvSixnhjm|Li
e   Mff! fjmifh Gj'fhvRylzj'q'usSdiiff|ZuvSfrm|vSfj'ihsSdiiff|9vSfry|vSfj'ihyj'fjusRd"iiff|mnhjmk0n
|opiffnhj'iffk&vSxnhjysR|LxlpdmvlpvR&j'fjuHUfhxkCjmflzsSialj'fhxwMnvRlpfjIxiffw\f	}hiffk ffp       G'xRfwvR'iffsRiaiffn
vRr'xRiffsffUi|nho|rmoznvSiffk6vUf,kmixlp}hiffk6iffnvRr'xiffs  'iyxsSvaUnhsUvR'ijrmwCix~fhUfhxkmsUlzjvR'i|oziffnhj'iffk
vSxnhjms|Lxlpdmv8 ff!        ,~S SnqnhlzjfjvR'i&nhsRsRrmwMdmvRlpfj0vRmnvr'vSvSixnhjm|Li&opiffj'qhvRlzsPsSvSxRfj'qozt
|LfhxRxRiffonvSiffklpvR
 4- D;nhjmk;ixRxRfhxs  'i,sSiff|Lfjmkk'ixlz}hiffkEiffnvRr'xRi,5nhs$ynhsSiffkfj|nhoz|ryoznvRlzj'q
'ivRmixPvR'i [  M    L wMnvR|'iffs$vR'i6     L xfwvR'i,$lznhopfhqr'i,nhjmnqhix u$D   R
 mls5iffnvRr'xiIlzs*k'iffsR|LxlpiffkJljOk'ivRnhlzolzj0vRmiIj'iLevPsSiff|LvRlpfjZ
jvR'i,iLedixlw\iffjvRsff"vRmi\iffnvRr'xiffslzjDlzqr'xRiZiLu|ormkmlzj'qJvR'i\mnhjmk'ozniffozopiffkiffnvRr'xRiffsffnxRi
xRiixRxRiffkCvSfnhsDvR'
i 4
 2F  4E2  6CiffnvRr'xRi5sSiv  'iaiLedixlzwMiffjvRsvSiffsSv)'f	;aiffoowMlsRrmjmk'ixsSvRnhjmkmlzjmqs
|nhj\i*lzk'iffjvRlyiffk,nhjmk,P'ivR'ix)dmxRfhopiffwMnvRlz|5kmlznhozfhqr'iffs)|nhjMi5dmxRiffkml|LvSiffk\rmsRlzj'qvR'
i 4
 2F  4E2  6
iffnvRr'xRiffs)iI|Lfw\dnxRiPvRmiPdixRfhxwMnhjm|LifhvR')
i 4
 2F  4E2  6JiffnvRr'xRi$sSiv5vSf,vR'irmoomiffnvRr'xRi$sSiv
lzjm|ormkmlzj'qCvR'iImnhjmk'ozniffozopiffk6iffnvRr'xiffsnhjmk0vSfMvRmiIdixRfhxwMnhjm|Li$fhvR'
i 4
 2F  4E2  6iffnvRr'xiIsSiv
lpvR8nhjmkIlzvR'fr'vZvR'i   H u-   ZiffnvRr'xihDlpqr'xi~Kqlp}hiffsDnhjIiL'nhw\dyopi~fhevRmi~iffjm|Lfukmlzj'qKfh
sSfw\ifhZvR'inhr'vSfwMnvRl|*iffnvRr'xRiffsGfhx~vRmisSiff|LfjmkiLu|mnhj'qhifhvR'
i w \x 4Dykmlnhopfhqr'i*lzjMlpqrmxRC
i ;e
 'idyxRiLm   Mk'iffsRlzqjmnvSiffs*vR'iCsSiff|LfjmkOiL'|mnhjmqhihai&kmlzsR|rmssKsSi}hixnhofhvR'i8iffnvRr'xiffs*}nhozr'iffs
'ixRivSfiffjmsRrmxRiOvRmnvvRmixRiffnhk'ixJrmjmk'ixsRvRnhjmkms,vR'i5nfftljmlz|vR'iiffnvRr'xRiffs6nxRiErysSiffkZj
r'vSvSixnhjy|Li,c'lzjlpqr'xRb
i ;eyvR'i&sStesRvSiffw sRn	tes8   p    H  0L
 
 [e?
 MP
 [uL   u
jlpqrmxRiMeZvRmlzs$lzsiffjm|Lfuk'iffktsSi}hixnhoiffnvRr'xRiffs  'i&iffnvRr'xi    h    qlp}hiffs$vR'i\jmnhwMi&fh
vRmnvPdmxRfw\dmv
 h=11rrZ  'iIiffnvRr'xRi    S  Sr    sSdiff|lyiffs5vRmnvc'\lzs*nxRidmxRfwMdmvyn
sSiff|LfjmknvSvSiffw\dmvIetvR'isStusSvSiffwvSfEiffozlz|lpvnkmiffsR|LxlpdmvRlzfjfhUvRmiM|nhozopixffs8dmxRfhyopiffw  'i\iffnvRrmxRi
   < Gl  sSdiff|liffs*vRmnvIc'Mlsj'fhvn6|LfjuxwMnvRlpfjdmxRfw\dmv  'i8iffnvRr'xRi    =  h sSdiff|lyiffs
vRmnvGc'PlzjmlpvRlznvSiffs-n$sRr'ZkmlznhopfhqrmiGnhjmk        =
  h iffjy|Lfek'iffs-vRmnvvRmlzsDlzsvR'i~xsSv-sr'Zkmlznhopfhqr'i
sSf0nxffmlopi   z LSL E
  / $iffjm|Lfuk'iffs$vRmnvfr'vfhUnhozoDvR'i\sStusSvSiffwr'vSvSixnhjy|LiffsIsSf0nx	
fhvR'iffw lzjylpvRlznvSisRr'Zkmlznhozfhqr'iffs
s\w\iffjvRlpfj'iffkiffnxozlzixff)aiOnxRinhosSflzjvSixiffsSvSiffklzjqhiffj'ixnhozlpfflj'qEfrmx\dmxRfhyopiffwnvRlz|6kylznhopfhqr'i
dmxRiffkylz|LvSfhxMvSffhvR'ixJsStusSvSiffwMs  rmsff~UivSxnhlzj'iff
k D  BEBE8=DrysRlzj'qfjmopt;iffnvRr'xRiffsMvRynvnxRifhvR
nhr'vSfwMnvRl|nhozoptEnh|ermlpxnyopi,kmr'xlzjmqxrmjvRlzw\i,nhjmklzjyk'idiffjmk'iffjvfh~vRmi 
Cf vRnhsSg"  mi,sr'ysSiv
fhKiffnvRr'xRiffsCxRfwlpqr'xRiO0vRmnv8yv8vRmlsIrynhozl|nvRlpfjnxRi6ljlpqr'xRi0eOi6xRiix8vSfvR'iffwnhs
vR'N
i 4
 2Ft24-< 5  iy8EB=2iffnvRr'xRiMsSiv
 GunhwMdyopiffs$fh5iffnvRrmxRiffsvRmnv8nxij'fhvvRnhsSglzjmk'idiffjmkmiffjv
lzjm|ormk'i S} Z  Zr +M c5     L c r    nhjmkOvR'iCmnhjmkuozniffozoziffkiffnvRr'xRiffs
 `l^p^`, Q ff Q _~b?h^
Y 

 iJqhfnhoKfhPvR'i   H '$D  IdmxRiffkylz|LvSfhx\lzs&vSflzk'iffjvRlpth)fhx,iffnh|iL'|ynhj'qhihaP'ivR'ix,fhx
 '
j'fhv$vR'iMsStusSvSiffw|LfhxRxiff|LvRoptryjmk'ixsSvSfefukvR'iMrysSixffs$r'vSvSixnhjm|Lih\sw\iffjvRlpfj'iffknf	}hihP'iffjvR'i
kmlznhozfhqr'iffsKUixRi8vSxnhjysR|Lxlpiffk0et0ermwMnhjysnvSixPvR'iCkmnvRn|Lfozoziff|LvRlpfj5nhsP|LfwMdyopivSiffkZmvRmiCermwMnhj
ozniffopixsKjmfhv*fjmoptJvSxnhjmsR|Lxlpiffk0vR'i8rmsSixsyr'vSvSixnhjy|Liffsyyrmv*nhozsSfozniffozoziffk6iffnh|ErmvSvSixnhjm|Li8PlpvRn
sSiffwMnhjvRlz|&|nvSiqhfhxRtxidmxRiffsSiffjvRlzj'q6vR'i8vRnhsSgvRmnvPvRmi&rmsRix5nhsnhsRgelzjmq  vSfJd"ixfhxw  mlzs
ozniffols6|nhozoziffkvR'i [  M    L   'iEsRtesSvSiffwsJ$lznhozfhqr'inhjmnqhixk'iff|lk'iffsnhw\fjmqsRi}hixnho
kmlixRiffjvKtedfhvR'iffsSiffsKdmxfekmry|Liffk6etJvR'iCwMfekmryopih'nhjmkOopfhqs*lpvRsKted"fhvRmiffsRlzs5nfr'vKmnv5vRnhsSg
vR'irmsSixK5nhs*nhsSgulzj'q  vSf\dixRfhxwOuvR'i$lznhopfhqrmiIEnhjmnqhix	s*tedfhvR'iffsRlzs5lzsUguj'f	PjOnhsKvR'i
   p   iEkmlzsSvRlzjmqrmlzsRfr'xM|onhsRsSiffs\fh$sSdfhghiffjoznhj'qrmnqhiryjmk'ixsSvRnhjykmlzj'qEfr'vR|Lfw\iffsMnhsSiffk
fj|Lfw\dnxlzj'q\vR'i [  \h  p  L vR'i,     L nhjmkxRiff|LfhqjmlpvRlpfjxRiffsRrmopvRs5fhxP|nxknhjmkOvSiffopid'fj'i
jermw8ixsff	
 D67FDD8962-|LfhxRxiff|LvRoptlzk'iffjvRlyiffkvR'i&vRnhsSgEnhjmknhjtkmlpqlpvsSvSxlzjmqsUixRi,nhozsSf
Vp$	V

fi

2Zy222S2-



7M1m



72

}(f\gg{  
P'&
 Z&1&==P 
		ffN
 }(}(}{ H.{ %AB'&!5A	!%5.'&1! }(f\gg{( le{}\
(z(}{ H.{ %AB'&
{. {
(}{f{
{ "2A;<A!5'
;
}{g{l{.{ 
}.<({f =
	 5.fi5;<
}(<f\}1}<ge
}<g}..<({f 
}{ =g{1}<\

}({ o<gf\} / ///
}({f}
}(H<g{ go\<{ / ///
}({f{}
}g{ g}.(fz . / ///
}({f}{
<{<E A95( 5A
}({f
}(f<{<. A;<A!
}({f}{
( ze(f<}9<.g (
}({fz
}Hzg .(f<}9<.g / C
}({fz
}f\}
 
5!;
}({f}{
}( leg{
g /
}({f{
}lg .g{
g /
}({f}/
}\ \{o}  %:B=
	
}({f}}{
}( l
\ \{o} g (
}({f}{}
}zg \ \{o} g / C
}({f}}{
} . <.( l
1{{g ((
}({f}
(g{\  \ 
  	5pff
K"5zfi
}({f}}{
}.lz{ (  \  
5!fin=! %
}<{(H{
(.g pf<  ;!!nn?
		  (n&=!=P 
		+
} \} (.g p  ;9n< 
		(#&9!==P 
		+
Dlzqr'xRiIea'iffnvRrmxRiIiffjm|Lfukmlzj'q\fhxceiff|Lfjyk )
 '|mnhjmqhiIfhw

\x 4Dy

( /
/

{

* *
 !(
 !(




/
/
/
/
/

 !(
/
/
/
/
/
/
/
/
/
(

 .<

kmlznhopfhqrmih

 B\~#
 P

 xiff|Lfhq'-xRiff|LfhqjermwCafhxkms-nhsRxSkmr'xnvRlzfjZk'vRw\nq'xRqwMfekmnholpvtnh|LvRrmnhoGw\fukmnhozlzvtfh
vRmi8rmsSixrmvSvSixnhjm|Lih

 Z~#
 snhozlpiffjm|Li|Lf}hixnqhihClzjy|LfjmsRlzsSvSiffjy|Lth|LfjvSiLevsmlpvvSfhd |Lfjuk'iffjy|Lih$kyl|Lfj'k'iffjm|Lih
nhrmvSfcu
: sRrm||LiffsRsff
J

9

P~#

~2 #}p~2#~$

 rmvSvSixnhjm|Li8et0r'vSvSixnhjm|Lih~rmvSvlzkZ'xRidmxfw\dmvm|LfjuyxwMnvRlpfjZmsRrmkylznho

 xrmjmjmlzjmq;vRnhoozlpiffsjermw,r'vSvRsffIjrmw\HxRidmxRfw\dyvRs$d"ix|LiffjvHxRidyxRfw\dmvRsjermw,|LfjuxwMs
dix|Liffjv|LfjuyxwMsmjermw,sRr'Zkmlnhozsdix|LiffjvsRr'ZkmlnhozsukmlznhokmrmxnvRlpfj

lpqr'xRi8e~r'vSfwMnvRl|vRnhsSglzjmk'idiffjmk'iffjv5iffnvRrmxRiffs*nff}nhlzoznopiInv*xrmjvRlzw\ih

|LfhxRxRiff|LvRozt;xiff|LfhqjmlpiffkZ,/
 DBh4D2  4fi
   4E26  E|LfhxRxRiff|LvRozt;xiff|Lfhqjmlpiffk?vR'ivRnhsSgyr'vvR'ixRi
5nhsnhjixRxfhxMlzjxRiff|Lfhqjmlpfflj'qn|nhozozlj'q|nxkjermw8ix\fhxnd'fj'ijermw8ixffI;+D    4E26  
kmlkj'fhv&|LfhxRxRiff|LvRoptlk'iffjvRlztvR'i0rmsSixffs8vRnhsSg"
 i
F/D86FejGCvR'iJxRiff|Lfhqjmlzix,kylzkj'fhv&qhiv
nhjtElzj'dr'v*vSf0dmxRfu|LiffsRs$nhjmksSf0vR'iw\fukmrmoziCkmlzkj'fhvifflpvR'ixff  mlzs|nhjnxlzsSi&ifflpvR'ix$iff|nhrmsSi
vR'i0rmsSix&kmlzkjmfhv&sRn	tnhjtvRmlj'qfhx&iff|nhrmsSivRmi6xRiff|Lfhqjylpix,Unhs,j'fhv&ozlzsSvSiffjmlj'q'iffjvR'i0rmsSix
Vp$ 1

fi>

72

> 9?f7A@d.22

sSdfhghih  '
 i'D767FDD8962J|oznhsRsUnh||LfrmjvRs5fhx*u,;hez	afhZvR'iPiL'|ynhj'qhiffsKlzjMvRmiP|LfhxRdyrys  'i
DBh4D2  4fi   4E26  nh||LfrmjvRsGfhxK\uMDfhvR'i5iLu|mnhj'qhiffs  'i%D    4E26  |onhsRs)nh||LfrmjvRs
fhx~mff6/uM)fhvR'iiLu|mnhj'qhiffsUnhjmkMvR'
i i
F{D8967Fej|onhsRs~nh||LfrmjvRsafhx5hfi
 ;6fi
 ;ez	MGfhvR'i
iL'|mnhj'qhiffsff
 mi   H  u-   MdmxRiffkmlz|LvSfhx0lzs6vSxnhlzj'iffkrmsRlj'qrmozoptnhr'vSfwMnvRl|EiffnvRr'xRiffsff  'iffsSi
iffnvRr'xRiffsnxRiIvR'i&P|LfrmsRvRlzp| k 4- DiffnvRr'xiffsZffiffnvRr'xRiffsnhjmk$lznhozfhqr'iCnhjmnqhix$nhjmk$lzsR|LfrmxsSi
lzsSvSfhxRtJiffnvRrmxRiffsmqlp}hiffjlzjOlpqr'xRiCJaPnhjmk'ozniffozopiffk6iffnvRr'xiffs*UixRi8j'fhvrysSiffkZ
iMi}nhozrmnvSi\vRmi\fr'xRHUn	t   H  u-   |oznhsRslyix$txRidfhxRvRlzjmqJnh||r'xnh|Lth-dmxiff|lzsRlpfjZ
xRiff|nhozonhjmkOvR'i8|nvSiqhfhxlpffnvRlpfj|Lfj'rmsRlpfjOwMnvSxl"  mlzsK|onhsRsRlyix*lsKvSxnhlzj'iffkfjnhozoZvRmiIiffnvRrmxRiffs
fhx*vR'iImfopi$vSxnhlzjmlzjmq,sRivynhjmkOvR'iffjvSiffsSvSiffkfjOvRmi8'iffozkuHfrmvKvSiffsSvsSiv
 nyopiEsRrmwMwnxlpiffs\vR'iEf	}hixnhooPnh||r'xnh|LtxRiffsRrmopvRsMfhvR'iEsStusSvSiffw vSxnhlzj'iffkfjvR'iE'fopi
vSxnhlzjylzj'qsSivnhjmkvSiffsRvSiffkfjvR'ivSiffsRvsSivMk'iffsR|Lxlpiffk;ljceiff|LvRlpf
j ;e  mi0yxsSv\ozlzjmiJfh  nyopi
xRidmxiffsSiffjvRsCvR'i0nh||r'xnh|LtxRfwnhop5nfftusCqrmiffsRsRlzj'qEvR'i6wn fhxlzvt|oznhssJg i
F{D8967F
jDGvRmls8lzsCvR'i
G94- 8m  i8nqnhlzjmsSvIPmlz|vR'ifhvR'ixCxRiffsRrmozvRsIsR'frmok"i6|Lfw\dynxRiffkZ  'i6sSiff|Lfjmkxf	Iozniffozopiffk
4 2F  4E2  6ysRmf	svR'iCnh||r'xnh|LtynhsSiffkEfjrmslzj'qnhozovR'i8iffnvRr'xRiffsnff}nhlzoznyozi8xRfw vR'i&sStusSvSiffw
w\fukmrmopiffsff  ylzs*|oznhsRslyix|nhjlzk'iffjvRlptOffixxRfhxs*ivSvSixvRynhjvR'iCynhsSiffozlj'ihUjiLudixS
lzw\iffjv5nhsxrmjOvSf0sSii,lp)vR'i&|LxRfsRsH}nhozlzkmnvRlzfjw\ivR'fukk'iffsR|Lxlpiffkljceiff|LvRlpf
j ;d"ixfhxws*UfhxsSi
vRmnhjrmsRlzj'q0vR'i'fopikynvRnOfjvR'iJsRnhw\iMvSiffsRvCsSiv  mlzs$iLudixlzw\iffjvIsR'faiffkvRmnvIvRmixRi5nhs
ozlpvSvRozi$ozfsRsKfhnh||r'xnh|LtO'iffjOrysRlzj'q\|LxRfsRsSH}nhozlkmnvRlpfjuM

~#N B
G=D
4  m8   i
8 wMnSfhxlpv tO|oznhsRs
42F  4E2  6

Pfi#~=
fie
; z	


uz&

 nyopiMt*iffsRrmozvRs5fhxk'ivSiff|LvRlzj'qJff~xRxRfhxsKrmslzj'qD

 BEB=8ED

lpqr'xiJJsR'fs$sSfw\i&vSfhdd"ixfhxwlzj'q\xrmoziffsvRmnv)D  B=BE8EDoziffnxjmsP'iffjEqlp}hiffjnhozovRmiCiffn
vRr'xRiffsff  'iffsSi$xrmoziffsUkylpxRiff|LvRoptMxiyiff|LvKvR'iIrmsSirmozjmiffsRs~fh-vR'iCiffnvRr'xiffs~PfhvSiIvRmnvKsSfw\ifhDvR'i
xrmoziffsDrysSi4D D6iffnvRr'xiffsGlzj&|Lfw8yljmnvRlpfj,lpvR\JiffnvRr'xiffsGsRrm|&nhsK   LL\M GGxRi}ulpfrmssSvRrykmlpiffs
nhopghixKivKnho/pmhhh|	Umn	}hiInhozsSf,sR'f	Pj0ffEiffnvRr'xiffs5vSfCi$rmsSirmo/Di$ynhkJnhosSf&ted"fhvRmiffsRlpiffk
vRmnvKiffnvRr'xRiffsKxRfwvR'iI$lznhozfhqr'iEnhjmnqhixnhjmk0vR'ikmlzs|Lfr'xsSimlzsRvSfhxRtwMlpqv5i$rysSiryodyxRiffkmlz|
vSfhxs$fhUff;ixRxRfhxsZ'f	Ui}hixvR'iffsSi,iffnvRr'xRiffs$xnxRiffoztndmdiffnxlzjvRmiCxryopiffsPlpvRvRmi&iL'|LidmvRlpfjfh
   p     mlzslsPlzjnh||Lfhxkmnhjy|Li&PlpvRdyxRi}elzfrmsiLudixlzw\iffjvRsPmlz|EsRmf	 vRmnv$vR'iffsSi,iffnvRrmxRiffs
k'fj'fhvMnhkyksRlpqjml"|nhjvRoptvSfvR'iOdixRfhxwMnhjm|LiOfhvR'iE Fi  iffnvRr'xisSivEnhopghix6ivnho/p
hhh|	
iKnhozsSfxRidfhxRv-dmxRiff|lzsRlzfjCnhjmkCxRiff|nhozofhxDiffnh|\|nvSiqhfhxRt&fjCvRmiU'iffokuHfr'vvSiffsRvsRiv  'i~xRiffsrmopvRs
nxRiIsRmf	jOlzj  nyopiffs*Mnhjmk ;e  nyopiI,sR'fsKvRmnvKvR'iC|oznhsRsRl"|nvRlpfj0nh||r'xnh|Lt0xnvSi8lzsKn,xiffsRrmopv
fhnImlzqMxnvSiPfh|LfhxxRiff|LvU|onhsRsRl|nvRlzfjMfhx~vR'C
i D67FDD8692Jnhjm
k i
F/D86Fej|oznhsRsenvavR'iP|LfsSvafh
n0opf	Uix$xnvSi,fh#
x D    4E26  nhjy^
k DBh4D2  4   4E276    mlzsPlzsdmxRfhynoptOkmr'i&vSfJvRmiCnh|Lv$vRmnv
vR'ixRiCnxRiiUixiL'nhw\dyoziffsKfh-vRmiffsSi8|nvSiqhfhxlpiffslzj0vR'i8vSxnhlzjmlzjmq,sRiv
jsSfw\iMsRlpvRrynvRlpfjmsfj'i\wMlpqv$j'fhvIj'iiffkvSfkmlzsSvRlj'qrmlzsR"iv aiiffjvR'i\kmlixRiffjv$wMlzsrmjmk'ixS
sSvRnhjmkylzj'q|nvSiqhfhxlpiffsU
 ieF{D8967FejaD C   4E26  nhjmk DBh4D2  4fi
   4E26    'ixRifhxRih*iLudixl
w\iffjvRsGUixRidixRfhxw\iffkMvRmnv~|LfozozndsSiffkMvR'iffsR
i ;dmxfhyopiffwMnvRlz|K|nvSiqhfhxlpiffs5lzjvSf8fj'i|nvSiqhfhxRtEg D  i
Vp$

"

fi

2Zy222S2-



7M1m

72



PZ-)*5k'vRwMnq xRiff|Lfhq|LfjvRnhlzjys6xRfwMxiff|Lfhq
 sStesSozniffo
jermw8Ufhxkms  #   L  \H[
o P-)K^Uk'vRw\nq nhsRxSkmr'xnvRlzfj"!'#xRiff|LfhqHqhxnhwMwMnx
 sStesSozniff
5lzoozw\ivR'fukuHqhxnhw6#
 xRiff|Lfhq&|LfjvRnhlzjmsahw8tu$
 xRiff|LfhqjermwCafhxkys% #   L  \H[
v 	'
 sRnhopdixRvRlzw\(
i u&
 vSfhd'|Lfju"k'iffjm|L"
i uhu	 # l &  MhH [
 sSdfhghiffjukylpqlp&
v 	'
 sRnhopdixRvRlzw\(
i u&
 |Lfj'dixRvRlzw\)
i u # z ,  MhH [
 sSdfhghiffjukylpqlp&
v 	'
 vSfhd'|Lfjuk'iffjy|L"
i uh ;h  z ,  MhH [
 sSdfhghiffjukylpqlp&
v  	
 snhopdixRvRlzw\)
i u
 sStusozniff*
o 5P5'
 I  l & 
 sSdfhghiffjukmlpqlp
MhH [
j ! 
 r'vSvl,
k !   sStusozniff.
o ZD)
 K^
 U
  kmlp|Lfju"k'iffjm|Li
 nhsSxSkyr'xnvRlpf+
u#  z
 ,  MhH [

lpqr'xRiMuPsRr'sSiv~fhxrmopiffsUopiffnxj'iffk6t    'iffj6qlp}hiffjJvR'i$nhr'vSfwMnvRlz|iffnvRr'xRiffs5fhxUkmivSixS
wMlzjmlzjmq   H u-   

/

~$B

D6FDD8962
i
F{D8967Fej
D C   4E26 
DBh4D2  4 fi  4E26 

u~2'
he
he
u
he#h

0|1q

he

u
u

 iff|nhozoZfhx  iffsRvsSivrmslzj'q\PrmvSfwMnvRlz|iffnvRr'xRiffs
 nyopi8eUGxRiff|lsRlpfj0nhjmk 

67FDD8692Z  mlzsIxRiffsRrmopvSiffklzjnxRiff|LfhqjmlpvRlpfjnh||r'xnh|Ltfhhe 0GnEhe lzw\dmxf	}hiffw\iffjv8f}hix
vR'i$ynhsSiffolzj'ifhh; J'Pmlz|0lzs5vRmidix|LiffjvRnqhiIfheD  i
67FDD896O
2 iL'|mnhj'qhiffsff  'i$dmxRiff|lsRlpfj0nhjmk
xRiff|nhozowMnvSxl0lzsKqlp}hiffjlj  nyozi'

D67FDD8962
i
F{D8967F
j
D    4E26 
DBh4D2  4 fi  4E26 

D67FDDD8692





i
F/D86Fej


;fi;u
h;


D    4E26 
uh
h
ff
h

DBh4D2  4 


 
 

 nyozi3;eUUfj'rmsRlpfj0nvSxlOfhx  iffsRvsSivrmslzj'q\PrmvSfwMnvRlz|iffnvRr'xRiffs
Vp$ 2

fi>

72

/

> 9?f7A@d.22

1~2'

~$q

D 67FDD8692
D  i
67FDD8692

u
h;ez	

0z

heJ
'

 iff|nhozoZfhx  iffsRvsSivrmslzj'q\PrmvSfwMnvRlz|iffnvRr'xRiffs
 nyopi'UGxRiff|lsRlpfj0nhjmk 
1Y

^t Q hb? X bH^` Q  Q _~b h^

 iqhfnho-fhvR'i8alzsKvSf6dmxRiffkml|Lv'fjvR'iInhsRlzs5fhGlzj'fhxwMnvRlzfj0vRmnvlpvynhsKiffnxoptOlzj0vR'iCkmlzn
 '
opfhqr'ihhP'ivR'ixDfhxjmfhvDvRmiUsStusSvSiffwlozohiUnopi~vSf|Lfw\dyozivSiUvRmiUrmsRixffsDvRnhsSg  mi~fr'vSdyrmvD|oznhssSiffs
nxRi&ynhsSiffkEfjvR'iCfr'x$kmlznhopfhqrmiC|nvSiqhfhxlpiffskmiffsR|Lxlpiffknf}hih$Pf	Ui}hixffnhs  4iej
 B
w \x 4Dy
nhjm
k 24- 5e<4  
 D8nxRi,vSxRiffnvSiffknhs$iffermlp}nhopiffjvRoptdmxRfhopiffwMnvRlz|CtEvR'i\sStusSvSiffwOnhsIlzoozrmsSvSxnvSiffkElzj
lpqr'xRieuvR'iffsS
i ;&|nvSiqhfhxlpiffs*nxi$|LfoozndysSiffk0lzjvSb
f B=D7F
Gy
 8  4E2  6DPfhvSivRmnv5vRmlzsU|nvSiqhfhxlpffnvRlpfj
lzs*ljm'ixRiffjvRopt6jmflzsStJ"iff|nhrysSi8lpvls*lzw\dfsRsRlzyopivSfguj'f	 vR'iIxRiffnhoxRiffnhsSfjmst0n|nhoopixmnhj'qsPr'd
fhxnlzffnxkvRnghiffsMf}hixvR'i|nhozoH  mi0|nhoopixMwMnfftmnhjmqrmd"iff|nhrysSisR'iOlzs,xrmsSvSxnvSiffklpvR
vR'iJsStesRvSiffwO)fhx&s'i6wMn	tsRlzw\doptkylzsRozlpghiMnhrmvSfwMnvRlpfjZ)fhx,'ixC|mlzozkwMnfftmnff}hi0sSvRnxRvSiffk|LxRtulzj'q'
culzwlzoznxopthhfjmilpffnxkMwMnfft6mnff}hi$opf	|Lfjukmiffjm|LiPlzjMvR'iPsStusSvSiffwOsUnylzolpvt,vSf8xiff|Lf	}hixKxRfw ixRxfhxs
nhjmk,rmsSiKn$|LfjmsSix}nvRlp}hi*ndydmxRfnh|,vRynvDxiffsRrmopvRslzjCvRngelj'q$f	}hix~wMnhjtC|nhoozsmlzozianhj'fhvR'ix)Plpffnxk
wMn	tEi\w\fhxRi,lzoozlzj'qMvSfozivvRmiMsStesRvSiffwvSxRtEvSfOxiff|Lf	}hixff\Pi}hixRvR'iffopiffsRsffai\vRnghivR'iffsSiMermwMnhj
nh|LvRlpfjmsnhsnMermwMnhjOozniffozolzj'q8fhvR'iffsRiI|nhozozs*nhsKdyxRfhyopiffwMnvRl|a$lp}hiffjOvRmls5ylzjmnxRtJ|oznhsRsRlp|nvRlpfjZ
ndmdmxfff'lzwMnvSiffopA
t ;h;fh-vRmiI|nhozozsKlzj0vR'i|LfhxRdrms5fh-hhkmlznhopfhqrmiffsKnxR
i BEDFGfi
 8  4E2  60nhjykh
nxR
i 24-< 5ff

 676=8"	
2 4350z= 1

\ 

~

9

\

Apn

~2 #60zn q

 mlsKsSiff|LvRlpfjOdmxiffsSiffjvRs*xRiffsRrmopvRs5fhx*dmxiffkmlz|LvRlzj'q,dmxfhyopiffwMnvRlz|$kmlnhopfhqr'iffs  ngelj'qMlzjvSfMnh||LfrmjvPvR'i
 nh|LvCvRmnv,nEdmxRfhyopiffwnvRlz|kmlnhopfhqr'iw&rmsSv&iMdmxRiffkml|LvSiffknv,ndflzjv8lzjvR'i0kmlznhopfhqr'i6'ixRi6vR'i
sStusSvSiffw |nhjkmf6sSfw\ivRylzj'q6nfr'vlpv"ai,|Lfw\dynxRi8 RR/ff/ nh||r'xnh|LtEnvSixmn	}elj'q6sSiiffjfjmozt
vR'ixsSv*iL'|mnhjmqhi8fhxvR'iyxsRvKvUf6iL'|mnhjmqhiffslzvR Ly a nh||r'xnh|LtnvSix$mnff}ulzj'q6sSiiffj
vR'i5'foziakmlznhozfhqr'ihDmfhx)iffnh|\fhmvRmiffsSiKsRlpvRrmnvRlpfjysaiKnhozsSf$|Lfw\dynxiUxiffsRrmopvRsDfhxDvRm
i 4
 2F  4E2  6
iffnvRr'xRi,sSivMnhsk'iffsR|LxlpiffkiffnxozlpixKlpvRnhjmkElpvR'fr'vPvR'i   H '$D  *iffnvRr'xRi\nhjmkElpvR
vR'i8ynhjmkuozniffozopiffk6iffnvRr'xRi\u-   
 nyopiCMsRrmwMwMnxlpiffs5vR'iIf}hixnhozonh||rmxnh|LtOxRiffsRrmozvRs  'ivRmxRii8|LfozrmwjmsKdmxRiffsRiffjv*xiffsRrmopvRs5fhx

)'|ynhj'qhiJ7)'|ynhj'qhiffs,ffInhjykf}hixvRmi8'foziCkmlznhozfhqr'ih  'i8yxsSv*xf	 qlp}hiffsvR'i8ynhsRiffozlzj'i
xRiffsRryopvCPmlz|;xRidyxRiffsSiffjvRsCvRmiJdyxRiffkmlz|LvRlpfjnh||r'xnh|LtxRfwnhop5nfftus\qr'iffsRsRlj'qEvRmi0wn fhxlzvt|onhsRs
culzjy|Liz	fh5vR'ikylznhopfhqr'iffsInxi2fiD
4 )
5 
67698 	&kylznhopfhqr'iffsai|nhj;nh|ylpi}hiJz	 nh||r'xnh|Lt
xRfwsRlzw\dopt0qr'iffsRsRlzjmqA24 )
5 e6698 fhxiffnh|kmlznhopfhqr'ih  'i,sSiff|LfjmkxRfqlp}hiffsxRiffsRryopvRsPrysRlzj'q
fjmoptMnhrmvSfwMnvRlz|iffnvRrmxRiffsuyr'valpvR'fr'vUvR'i   H  u$D  GiffnvRr'xRih  miPvRmlzxkMxRfrmsSiffsUvR'i
sRnhw\iMnhrmvSfwMnvRlz|\iffnvRr'xRiffs$yrmv$nhkykmslzj   H  u$D    mlzsiffnvRrmxRiMlzsfhmvRnhlzj'iffkfhxIfhvR
vR'ivSxnhlzjmlj'q8nhjmk6vR'ivSiffsSvUsRivurysRlzj'qIvRmi|LxRfssH}nholzkmnvRlpfjJw\ivR'fuk6kylzsR|rmsRsRiffkMlzjOceiff|LvRlpfjA;e  'i
fr'xRvRnhjyk,yvRMxRfs~sRmf	xRiffsRrmopvRs~rmsRlzj'qvRmisRr'ysRivGfhZiffnvRrmxRiffsGvRmnvUnxRifhvRrmooptCnhr'vSfwnvRlz|
nhjmkOvRnhsRglzjyk'idiffjmk'iffjv5nhsk'iffsR|LxlpiffkOlzjcuiff|LvRlpfjO'
Vp$

!

fi

2Zy222S2-



7M1m



72

 mi0nhrmvSfwMnvRlz|JxRiffsRrmozvRsCqlz}hiffjlzj;xRf	nxRiOsRlpqjyl|nhjvRoptmlpq'ix,etndynhlpxiffkvHvSiffsRv\vRmnhj
vR'i,ynhsSiffolzj'i&fhxInhozoDvR'xii,sRiff|LvRlpfjms$fh~vRmiMkmlznhopfhqr'iOk'7hhev8ezd	$u;hek'7hheDv8Ie
d	$uh'km4 hhM8v ,< ;e 'y9
d $uh'	
f	s0nhjyksR'f	nh||r'xnh|Lt?lzw\dmxRf}hiffw\iffjvRsqnhlzjmiffketvR'iEnhkykmlpvRlpfjfhIynhjmkuozniffozopiffk
iffnvRr'xRiffs  miffsSixRf	sqlp}hi
n 2FBy  i8nqnhljmsSvOml|vSf|Lfw\dnxRivR'ixRiffsRryopvRsOlzjxRf	Pse
;eGnhjmkeW
 iffsRrmopvRs,rmsRlj'qEnhozoUvR'iOnhr'vSfwnvRlz|JiffnvRr'xiffs,dyozrmsCvR'iOmnhjmkuon"iffoopiffku-   
nxRi0qlp}hiffjlzj;xRfejvR'iffsSi0iLedixlw\iffjvRsff)vR'iOmnhjmkuozniffozoziffku-   IiffnvRr'xilzs,rmsSiffk
fhx6vSxnhljmlzj'qnhjykvSiffsSvRlj'q'5fw\dynxlzjmqvRmlzs6xRiffsRrmozvlpvRvR'isSiff|LfjmkxRf	sR'fsJvRmnv0lpfj'i
mnhkndixRiff|LvJdyxRiffkmlz|LvSfhx0fh   H u-   6lzj?vR'ivSxnhlzjylzj'qnhjyk?vRmivSiffsRvsSivPvRmiffjvRmlzs
iffnvRr'xRi\Ufrmozklzjm|LxRiffnhsRi,nh||rmxnh|Lttefh
x )'|mnhj'qhixRfw uz	vSfEeMt
fh)
x Gu|mnhj'qhiffs\ffIxRfwez	 vSfhe#hMnhjmketEe fhxvRmiCmfopi&kylznhopfhqr'i0/ vSf
heM  miffsSialzjy|LxRiffnhsSiffsDnxRiUslpqjml|nhjvetInPdynhlpxRiffkCvHvSiffsSv*k'7 hheh8v ezh	
d $uhh'ek'7 hhe
v8ez	
d $u ;hekm4 hhey8v e#m	
d $uh'	
UfwMdynxlzj'qvRmixRiffsRryopv~lzjxRf	IlzvR\vR'ixiffsRrmopv~lj\xRf	 ;Is'f	savRmnvavR'i   H  u-   
dmxRiffkylz|LvSfhxGvRmnvGUimn	}hi*vSxnhlzjmiffkM|nhjlzwMdmxRf	}hiKdixRfhxwMnhjy|Lihyr'vG|Lfrmok\dfsRsRlpyoztI'iffopdw\fhxiKlpvR
kmlixRiffjvvSxnhlzjmlj'qOw\ivR'fukmsMk'iffnhozopthvR'iMxRiffsRryopvlzjxRf
 ;e-fhx8nhr'vSfwnvRlz|MiffnvRr'xRiffs8dyozrms   H 
u-   sRmfrmozkEnhozoiv aiiffjvRmi,yqr'xRiffslzjxRfs80nhjmke-nhjmki,|ozfsSixIvSfOvR'i\xRiffsrmopvRs
lzj;xRfelpvRJ
 )'|mnhj'qhiffsffIeanhkmkylzj'q   H '$D  8xRiffsrmopvRs,lzj;nhjlzjm|LxRiffnhsSi0fh&z	
ml|lsCj'fhv,sRlpqjyl|nhjv6|Lfw\dynxRi0xRfs,nhjmJ
k ;'fh
x )'|mnhj'qhi6fjmopth
 D  B=BE8EDk'feiffs,j'fhv
rmsSi$vR'i   H  u-   GiffnvRr'xiIlzj6lzvRs5xrmopiffsSiv5nhjmk0k'feiffs5j'fhvKtelziffozk6nhj0lzwMdmxRf	}hiffwMiffjvKf}hix*vR'i
sStusSvSiffw vSxnhlzj'iffkfjmoptOfjEvR'iCnhr'vSfwnvRlz|8iffnvRr'xRiffsff  'i&sStesRvSiffwvSxnhlj'iffkfjEvR'i8P'fopiCkylznhopfhqr'i
lpvRnhr'vSfwMnvRlz|iffnvRr'xiffsGdyozrys   H '$D  )nhozsSf8k'feiffs~jmfhv~tulpiffozk\nhjlw\dmxRf}hiffw\iffjv~f	}hix5vR'i
sStusSvSiffw vSxnhlzj'iffk0lpvRmfr'v   H '$D  
:9;<=;<?>

4D 

5   iy8=BE8Eiy
8Ei2A@8E4E2"D8"

*fsaCnhjmkJqlp}hiPvR'i*xRiffsRryopvRs~rmslzj'qvR'i'4"
27Ft72fi4D 5
  iy8=B=26iffnvRr'xiPsSivUk'iffsR|Lxlpiffk\lzjDlzqr'xRi

ElpvR'frmvCnhjmk;lpvRvR'i   H  u$D  IiffnvRr'xRihGxiffsSdiff|LvRlp}hiffopth  'iffsSiJxRiffsRryopvRsCnxi0slpqjmlm
|nhjvRoptEnf	}hi\vRmi&nhsSiffozlzj'i,rmsRlj'q6n0dynhlzxRiffkvHvSiffsRvlpvR^)'|ynhj'qhiffsMffIJqlp}ulzj'qJnhjlzjm|LxRiffnhsRi&fh
< ;ez	 k'7 hhe-8v IeeD9d $uh'	IrysRlzj'
q 24- 5
  iy
8EB=2iffnvRr'xRiffsIPlpvR   H  u$D   Oat
|Lfw\dynxlzj'qxf	sPJnhjykefj'i&fhysSixR}hiffs$nhjlzjm|LxRiffnhsRi&lzjvR'+
i 4"

 27Ft24- 5
  iy
8EB=2iffnvRr'xRiffssSiv
'iffjvR'iiffnvRr'xRi   H  u$D  Glzsanhkmk'iffkJrmsRlzj'
q Gu|mnhj'qhiffs$ffI8nhjmkP'fopikmlnhopfhqr'ih  'i
lzjm|LxRiffnhsSi8fh'
x )'|mnhj'qhiffs,ffIMsR'f	PsnMvSxiffjmkk'7 hhe8v ,# 	
d $uZmixRiffnhs*vR'i,
lzjm|LxiffnhsSi$fhxKvR'i$mfopikmlznhopfhqr'i$lzs5sSvRnvRlzsRvRlz|nhozoptJsRlpqjml"|nhjvUtJn,dynhlpxRiffk6vHvSiffsSvCkm4 hhey8v #;eu
d	$uh ;
opvR'fr'qevRm3
i 2fi4-< 5  iy8EB92OiffnvRr'xRiIsSivRs*nxi8n\sRr'ysRivUfhDvR'fsSiiffnvRr'xRiffsrmsSiffkOlzjJxRf ;emlpv
lzsUdfsRsRlpopifhxKvR'iffwvSf\dixRfhxw"ivSvSixKiff|nhrmsRivRm3
i 2fi4-< 5  iy8EB920iffnvRrmxRiffs*nxRiw\fhxRiqhiffjmixnho/
nhjmk"iff|nhrysS3
i D  B=BE8EDrmsRiffsnMqhxiiffk'tnhopqhfhxlpvRyw vSf6kmlsR|Lf	}hix$lpvRs*xrmopiIsSivRs*mfh'
x Gu|mnhj'qhiffs&ffIe
vR'iMlzjy|LxRiffnhsSi\xRfwxRf	
 ;JvSfxRf	"fhvRfhUml|rmsSi   H u-   SlzsjmfhvIsRlpqjml"|nhjv
Ufw\dnxlzj'qCxRf	s*&nhjmkJ'mj'ifflzvR'ix5fhml|JrmsSi   H  u$D  efjmi$sRiiffsKn&sozlpqvUk'iqhxnhkmn
vRlpfjljExiffsRrmopvRs$fhxIvR'i\mfopi\kmlznhopfhqr'iMrysRlzj'
q 2fi4D 5
  iy8=B=2iffnvRr'xRiffsMPf	Ui}hixffvR'iMlzjy|LxRiffnhsSi
xRfwxRf	Ps~vSfCxRfw ez	vSf8uH ;fha
x Gu|mnhj'qhiffsPffI$lzs)sSvRnvRlzsRvRlz|nhozopt8slpqjml|nhjv*k'7 hhe
v8euD	
d $u  mlzs$sR'fsvRmnv8rysRlzj'q   H  u$D   $lzj|LfwCylzjmnvRlpfjPlpvRvR'iMsSivIfh
24- 5
  iy
8EB=2iffnvRr'xiffs*dmxRfukmrm|LiffsnMsSvRnvRlzsSvRl|nhozopt0sRlpqjml"|nhjvKlzjm|LxiffnhsSi8lzjOnh||r'xnh|LtOf	}hix$nMsSivfh
nhr'vSfwMnvRl|iffnvRrmxRiffs*vRmnvPk'fiffsj'fhvlzjm|ormk'ivRmlzs5iffnvRr'xRih
Vp$

&

fi>

uB




;






72

> 9?f7A@d.22

~#

UnhsRiffozlzj'i
4"

 27Fj'f   H  u-   S
4"

 27FU   H  u$D   
4"

 27Ft24-<5  iy8EB=2;j'f   H  u-   S
4"

 27Ft24-< 5  iy8EB=2   H  u-   
4"

 27FUu-   
4g 4
 2F nhjmkuozniffozopiffk"

CD#~2#2E3

z
uz
he
uz
he
e
hz

CDff~,3GFIH

z
ez
e
e 
uH ;
he#
he

y#

z

'
h;e 
he 
he
u#

 nyozi8e~P||rmxnh|LtxRiffsRrmozvRs5fhxPdmxRiffkmlz|LvRlj'qCdyxRfhyopiffwMnvRl|kylznhopfhqr'iffs
/

~$B

fi2 4D 5)
67698	
B=D7F
Gy8  4E2  6

JNfi#

6
;h;e6

0zn\q

u#6
ffeH ;J

1~2'
hez&
;u6

0z

 e6
he6

 iff|nhozoZlzvR)'|mnhj'qhiJPrmvSfwMnvRlz|I'iffnvRrmxRiffs
 nyozi8e~GxRiff|lsRlpfjOnhjmk 
 miwMnhlzj\dr'xRdfsSi5fhZvR'iffsSi*iLudixlzw\iffjvRs~ls)vSfCk'ivSixwMlzj'iKmivR'ixanIkylznhopfhqr'ilsD hyh!
dmxRfhopiffwMnvRlz|vR'ixRifhxRiMrmslzj'qJvR'i,'fopi,kmlznhopfhqrmi,lsjmfhvIrmsSirmo-ljn0k'tujmnhwMl|CsStusSvSiffwO+:sRlzj'q
)'|ynhj'qhiffsffIOdmxRfukmrm|Liffs$nh||r'xnvSi6xRiffsRrmopvRsnhjykafrmokiffjmnyopi\vR'iMsRtesSvSiffwvSfnhkmndmv8ljEfhxk'ix
vSf|Lfw\dopivSiIvR'i8kylznhopfhqr'ilzj0vR'iCndmdmxRfhdmxlznvSiwMnhjmj'ixff
:9;<=;KML

4iyS4G=8yfi8=y@8=4E2D8

*fPlzj&vRnyopi*qlp}hiffsvR'iKxiffsRrmopvRsrmsRlj'qynhjmkuozniffozopiffkCnhjmk,nhr'vSfwMnvRlz|5iffnvRr'xRiffs~lzjm|ozrmkylzj'q*fhvR

u-   Knhjyk   H  u-   Ut|Lfw\dnxlzj'qMxf	sMnhjyk"fj'i,|nhjsRiiCvRmnvPvR'ixRi,lzs
j fhvI}hixtw&rm|vSfi,qnhlzj'iffketnhkmkmlzj'qJvR'iMfhvRmixCmnhjmk'ozniffozopiffkEiffnvRr'xiffsqlp}hiffjljDlzqr'xRi6
'
vSfOvR'iMmnhjykuozniffozopiffkEnhjmku$D  iffnvRr'xRiMsRiv\$jyoptvR'i\lzjm|LxiffnhsSi,fhxGu|mnhj'qhi&xRfw
evSfhz	lzssRlzqjml|nhjvMk'4 Ihhe8v eH ;eD	
d $umfhx8vR'i\mfopi\r'vSvSixnhjm|LiMvRmixRiMlzs
nh|LvRrmnhozoztJnMkmiqhxnhkmnvRlpfjOfhxRiffsrmopvRs5xRfwhevSfJu#hJ
2 HN0z1q~2#

u~2'

 'i8d"ixfhxwnhjm|Li8fh)vR'i&sStusSvSiffwvRynvrmsRiffsnhr'vSfwMnvRl|8iffnvRr'xRiffs\lzjm|ormkmlzj'q   H  u-   S
 fhxIvR'i,yxsRvIr'vSvSixnhjm|Lils$qlp}hiffjlzj  nyopie  ylzs$sStesRvSiffw mnhsnhjf}hixnhozoanh||r'xnh|Ltfh5he0
 'iffsRi6xRiffsrmopvRs&sR'f	vRmnvaqlp}hiffj;vR'iJyxsSvCiLu|mnhj'qhihavR'i0xrmopiffsSivCdmxRiffkml|LvRsCvRynv0ffeH;fhPvR'i
kmlznhozfhqr'iffsMlozoKidmxfhyopiffwMnvRlz|5ylzop
i ;h;fhIvR'iffw nh|LvRrmnhozoptPlzozoKih vRmidmxRfhopiffwMnvRlz|
kmlznhozfhqr'iffslpv-|nhj&dmxRiffkylz|L

v ;u fh'vR'iffwOG$jm|LiUlpvdyxRiffkmlz|LvRsvRmnvDnkmlznhozfhqr'iGlzoohi~dmxRfhopiffwMnvRlz|
lpv*lzsK|LfhxxRiff|Lvhe fh-vRmiIvRlzw\ih
x )'|ynhj'qhiffsffI&lzsUsRrmw,
 miPdixRfhxwMnhjm|LiPfhvR'i$sStusSvSiffwvRmnvUrysSiffs5nhr'vSfwMnvRlz|iffnvRr'xRiffsUfh
wMnxlziffklzj  nyopi  'iffsSi0xRiffsrmopvRs,sR'f vRmnv~qlp}hiffjvRmi0yxsSv&vUfiL'|mnhj'qhiffsffavRmlsCxrmopiffsSiv
dmxRiffkylz|LvRsUvRmnv*fhvR'ikmlnhopfhqr'iffsUlzozoiPdyxRfhyopiffwMnvRl|ePmlzop)
i ;h;fhvR'iffw nh|LvRrmnhooptlozomih
vR'iKdmxRfhyoziffwMnvRlz|5kmlznhopfhqrmiffslpvG|nhj\dmxiffkmlz|LvDefh"vR'iffwOG$jm|Li*lpvdmxiffkmlz|LvRsvRmnv~nkylznhopfhqr'i
lzooZi8dmxRfhopiffwMnvRlz|lpv$lzs|LfhxRxiff|LvIe#hfhGvR'i&vRlzw\ih  mlzsP|oznhsRsRlixPmnhs$nhjlzw\dmxf	}hiffw\iffjvPfh
Vp$ 3

fi

2Zy222S2-



7M1m



72

i	sRnhozlpiffjm|LiL|Lf}hixnqhiOu#h( i	nhsSxSkyr'xnvRlpfjP!u(i	nhr'vSfcu
:*sRry||LiffsRsQieF
#  S  p \
 :*srm||LiffsR5
s  D C   4E276  R i	sStusozniffoA ZD)K^U? i	nhsSxR
 i	nhr'vSfcu

kmr'xnvRlpfS
j ! ;ezff     p Mh
i u#hS
  i	sRnhozlpiffjm|LiL|Lf}hixnqhi?u#T iHxRiff|Lfhq|LfjvRnhljms
 isnhozlpiffjm|LiL|Lf}hixnqh?
S'iffopdU
 inhsSxSkmrmxnvRlpfO
j  e h #  S  z Mh/
i  uhV
 i	nhr'vSfc'
 :sRrm||LiffsRW
s  D    4E26  (
  i	sStusozniff%
o 
 iHvSfhd'|Lfj'k'iffjm|L,
5P5'
 I #  S  p \
i  uh  i	kml"|Lfjuk'iffjy|LV
i uuff
 i	|Lfozoziff|L)
v  uh ;h i	
 iHvSfhd'|Lfjuk'iffjy|LX
nhsSxSkyr'xnvRlpfS
j ! eH ;h&
 i	kmlznhopHfhxSwM"
i !u     p Mh


D8967Fej-

lpqr'xRiMhPsr'ysSiv0fh,xrmopiffs0opiffnxj'iffket D  BEBE8ED
k'ivSixwMlzjylzj'q,dmxRfhyoziffwMnvRlz|$kmlznhopfhqrmiffs

'iffjqlz}hiffjvR'inhr'vSfwnvRlz|iffnvRr'xRiffsOfhx

i	HvSfhd'|Lfjukmiffjm|LiYuhh)i	nhsSxRkmr'xnvRlpfjP!u) i	nhrmvSfcu:sRrm||LiffsRsieF
#  S  p \
 :*srm||LiffsR"
s D C   4E26  &
 i	HxRiff|LfhqjermwCafhxkmsQh-i	nhsRxSkmr'xnvRlzfj!
 i	nhr'vSfcu

eh     p Mh
i uZ
 i	nhsSxSkyr'xnvRlpf[
j ! uZ
 i	lzjy|LfjmsRlzsSvSiffjy|L,
t ! uh\
 
 i	sRnholpiffjm|LiL|Lf	}hixnqhT
inhsSxSkyr'xnvRlpfA
j  ;eh%
 i	ljm|LfjmsRlzsRvSiffjm|L6
t ! uzff #  S  p \
i uhhS
  i	sRnhozlpiffjm|LiL|Lf}hixnqh?
i uhhT
  iHxRiff|Lfhq|LfjvRnhljms
 isnhozlpiffjm|LiL|Lf}hixnqh?
S'iffopdU
 inhsSxSkmrmxnvRlpfO
j H ;h #  S  z Mh/
i uh%
 i	kml"|Lfjukmiffjm|L"
i uuff%
 i	HxRiff|Lfhq6|LfjvRnhlzjmsMSwCtu'
 
 iHvSfhd'|Lfj'k'iffjm|LV
inhsSxSkyr'xnvRlpfA
j ! #  S  z Mh/
i  uh"
 inhsSxRkmr'xnvRlpf]
j !uV
 i	nhsRxSkmr'xnvRlzf]
j !eH ;h
 isRnhozlziffjm|LiL|Lf	}hixnqh+
#  S  z
 Mh/


D8967Fej-

lpqr'xRiMffePsRrmysSivfh~xrmoziffsoziffnxj'iffkt^D  BEB=8EDP'iffjqlp}hiffjvR'iN2fi4D
k'ivSixwMlzjylzj'q,dmxRfhyoziffwMnvRlz|$kmlznhopfhqrmiffs

5
  iy8=B=2iffnvRr'xRiffs$fhx

	 hljExiff|nhozo)nhjmkh;eljEdyxRiff|lzsRlpfj"fhxInhjf	}hixnhozoGlzw\dyxRf	}hiffw\iffjvIlzjnh||r'xnh|Ltfh5e
f	}hix$rmsRlj'q,vR'i$yxsSvKiL'|ynhj'qhiCnhopfjmih
2 _^`CD~=

A#Bq

'~aM#

 sRr'ysRiv*fhvR'i8xryopiffs5xfw vR'i8sRtesSvSiffw vRmnvrmsSiffs*nhr'vSfwnvRlz|IiffnvRr'xRiffsPfhx')'|mnhjmqhiffsCffInxRi

qlp}hiffj6lzj\lpqr'xRiIh&xRf	;evRnyopia$j'iKfhysSix}nvRlpfjxfwvR'iffsSited"fhvRmiffsSiffs~lzsvRmi|oznhsRsRlpyixffs
dmxRiixRiffjm|Li$fhx*vR'i        iffnvRr'xRif	}hixPvR'i$iffnvRrmxRifhxKvRmiIjrmwCix5fh-Ufhxkms5xRiff|Lfhqjylpiffk
 RR Z    &~h R$j'iKUfrmozk\iLudiff|Lv~opfj'qhixUr'vSvSixnhjm|Liffs~vSf8i*w\fhxRikyl{6|rmopvyr'v)vR'ioziffnxj'iffk
xrmoziffsSivRs,lzjmkmlz|nvSi0vRmnv\kmrmxnvRlpfjlzs,nivSvSixMw\iffnhsRr'xRi0fhr'vSvSixnhjm|LiopiffjmqhvRvRmnhjvR'iOjryw8ix
fhUafhxkys\Pj'fhvRmixIfhysSixR}nvRlpfjls$vR'iMrmsSirmozj'iffssPfhUvR'iJff|Lfju"k'iffjm|LiMsR|LfhxRiffs8nhjmkvR'i6ff
VTz$

fi>

/

~$B

fi2 4D 5)
67698	
B=D7F
Gy8  4E2  6

72

JNfi#

6
;h;e6

> 9?f7A@d.22

0zn\q

u0
u0

1~2'
 '6
e6

0z

ez&
e#

 iff|nhozolpvR)'|ynhj'qhiffI\r'vSfwMnvRl|I'iffnvRr'xRiffs
 nyopiC~~xRiff|lzsRlpfjOnhjyk *

Rs nhozlziffjm|LiL|Lf	}hixnqhiClzjdyxRiffkmlz|LvRlzjmqIdmxRfhyoziffwMnvRlz|kmlznhopfhqr'iffsff  'iffsSiiffnvRr'xiffsUsRiiffwvSf&dyxRf	}ulzk'iPqhffuk
qhiffj'ixnhoDlzjmkylz|nvSfhxsKfhvR'i&sStesRvSiffwOsPsrm||LiffsRslzjOxRiff|LfhqjmlzvRlpfjnhjmkErmjmk'ixsSvRnhjmkmlzjmq'  'i8nh|LvPvRmnv
vR'iUwMnhlzjIfu|rmsfh'vR'iaxrmopiffslzsk'ivSiff|LvRlj'
q 4-< DMnhjmk,ixRxRfhxs-nhjmkIvRynv-j'fj'iafh'vR'ity  "iffynff}ulpfhxs
nxRi8rysSiffknhsKdmxiffkmlz|LvSfhxs*nhosSfMlzjmkml|nvSiffsKvRmnvylzjnhozoZozlpghiffozl'ffukZevR'
i y  lzsKdixRfhxwMlj'q&nhsaiffoonhs
lpvI|nhjZ-qlp}hiffjvRmij'flzsStlzj'dyrmvvRynv8lpvIlzsqhivSvRlj'qxRfw 4-< Dnhjmk)MjnhopvSixjmnvRlz}hiM}elzi lzs
vRmnvKv afrmvSvSixnhjm|LiffsnxiIj'fhvKiffj'fr'q0vSf\dmxf	}ulzk'iw\iffnhjmlzjmqhrmo"kmlznhozfhqr'i$iffnvRr'xiffs*sRrm|nhsK|LfrmjvRs
nhjmkOdix|LiffjvRnqhiffs*fhxRidyxRfw\dmvRsm|Lfj'yxwMnvRlpfjysuivR|p
 jmi$|nhjOsRiivRynvKvR'i$vSfhdOvUf\xrmopiffs5rmsSi   H  u$D     'iyxsRvaxryopiynhslz|nhozoptsRvRnvSiffs
$
vRmnvOlpvR'ixilzs0j'f;xRiff|LfhqjmlzvRlpfjfhx0vR'isSiff|LfjmkiL'|mnhj'qhinhs0dyxRiffkmlz|LvSiffk?tvR'i   H u-
  S6vR'iffjvR'ikylznhopfhqr'ilzozonhlo/  'isSiff|Lfjmkxrmopilzs0w\fhxRilzjvSixRiffsSvRlzj'qnhsOlpvOsSvRnvSiffslz
nwMlzsrmjmk'ixsRvRnhjmkmlzj'qEmnhs,iiffjdmxRiffkmlz|LvSiffkfhx\vR'isSiff|LfjykiLu|mnhj'qhinhjykvR'isStusSvSiffwozniffo5lzs
b(cd)e @f)ghinhjmkvR'iMrmvSvSixnhjm|Lilzs$opfjmqJvRmiffjvR'i\sStusSvSiffwlzoonhlzo/CjfhvR'ixUfhxkmsffvR'i
sStusSvSiffwxRiffer'iffjvRoptwlzsRlzjvSixRdmxRivRsZozfj'q*r'vSvSixnhjm|Liffs-nhs b(c8d(e @$f)ghixRiffsRrmopvRlj'qKlzj$vRnhsSg$nhlozr'xRih
lpqr'xi0ffOqlp}hiffsIn0sRr'ysRivfhUvR'i\xryopiffsSiv$fhxvRm
i 2fi4-< 5  iy8EB92iffnvRr'xRiMsSivfhx)'|mnhjmqhiffs
ff Ie*$j'iI|nhjEsSii8nslzwMlzoznxlpvtMiv aiiffjvRmlzsKxryopiffsSiv*nhjmkOvRmiIfj'iIqlp}hiffjElzjlpqr'xiMh  ylzsKlzs
kmr'iCvSf6vRmi8nh|LvPvRmnv'iffjEnhozo-vR'iCnhr'vSfwnvRlz|8iffnvRr'xRiffs$nxRi,nff}nhlzoznopih9D  BEBE8EDynhsPn6vSiffjmk'iffjm|Lt
vSfdlz|RgJfr'vvRmi8w\fhxRiIqhiffjmixnhovRnhsSglzjmkmid"iffjyk'iffjvKfjmiffsmlpvRvR'iIiL'|LidmvRlpfjfh5     L afj'i
|Lfw\dynxiffs*vR'i&sSiff|LfjmkxrmopiIlzj0fhvROqr'xRiffs'fj'i&|nhjsSiiCvRmnC
v D  BEBE8EDrmsRiffs RR Z    &~h $nhs
nMsRrmysSvRlpvRr'vSi$fhx*vR'iIvRnhsRgsSdiff|l"|$iffnvRr'xi\   p   
2 kj

/

2ql~2'n~

E

}pZml|Y~2#9~ l'1q~2'#'#

}p#Z

s~w\iffjvRlpfj'iffk6n"f}hihenhj6nhopvSixjmnvRlz}hivSf8vSxnhlzjmlzj'q$vR'i~$fjMvR'inhrmvSfwMnvRlz|nhozopt\k'ixlp}hiffk   H 
u-   aiffnvRr'xRi8lzs*vSfMvSxnhlzjlzvKfjOvR'i8mnhjykuozniffozopiffku$D   Umlzozi$sRvRlzozo"vSiffsSvRlzj'q6lpvKfj
vR'i\nhr'vSfwMnvRl|,iffnvRr'xih  mlsPsSiff|Lfjykw\ivR'fuklsPxiixRxiffkEvSfnhsOSynhjmkuozniffozopiffk'HvSxnhlzjmlzjmqMnhjmk
vR'i6xRiffsRrmopvRlj'qOiffnvRrmxRi6lzs [ u-     ylzsIwMn	tdmxRf	}ulzk'i6nw\fhxRiJnh||r'xnvSiOw\fuk'iffo)yrmv8lpv
wMn	tj'fhvP|ndyvRr'xRi&vR'iC|mnxnh|LvSixlzsRvRlz|sfh)vR'iCnhr'vSfwnvRlz|&iffnvRr'xiClzjvR'i8vSiffsSv$sSiv  nyozi&qlp}hiffs
xRiffsRryopvRs~fhx5vR'i$vUfMw\ivR'fukms~$j'i$|nhjOsSii$xRfwvRmlzsUvRnyopivRmnv5vR'ixRilzsUn,sRozlpqveljmsRlpqjmlp|nhjv
lzjm|LxiffnhsSiKlzj,nh||r'xnh|Lt,fhR
x Gu|mnhj'qhiIKnhjmk,vRmiUP'fopiKkmlznhopfhqrmiUrmslzj'qvR'iKmnhjmkuozniffozoziffkuHvSxnhlzjmlj'q
w\ivR'fukZ)Pf	Ui}hixffuvR'ivSfhvRnhozoztMnhr'vSfwMnvSiffkJw\ivR'fukMtulpiffozkmsGn8ivSvSix~xRiffsRryopvPHe|Lfw\dynxRiffkvSf
h M-fh
x )'|mnhj'qhiffsKff8ehmlz|Cnhs)w\iffjvRlpfj'iffk,nf	}hihlzsvRmiUw\fsRvlw\dfhxRvRnhjv-xRiffsRrmozvfhxDvRmiffsSi
iLud"ixlzw\iffjvRs  mlslzjm|LxiffnhsSiCsRmf	snvSxiffjmkr'vlzsj'fhvPslpqjml|nhjv&km4 hhe8v ,e	
d uh
 'i8jmnhoxRf	 fhGvR'iCvRnyopi8qlz}hiffsPvRmi8xRiffsRryopvRsrmslzj'qMvR'i,mnhjmk'ozniffozopiffk0iffnvRr'xRiM'$D  *lzj
fhvROvR'ivSxnhljmlzj'q\nhjmkOvSiffsRvRlzj'qMnhjmkls5vRnghiffjEnhsKvRmiIvSfhdyozlzjmixiffsRrmopv
VT	T

fi

2Zy222S2-

~#



7M1m

CD#~2#2+3

5nhsSiffozlzj'i
4
 2F
4
 2FW [  u$D   
4
 2FW   H  u-   
4
 2FWu-   

z
uz
u 
he
e



72

CDff~2#2+3F6H

z
ez
h 
e
he#

y

z

he
'
he

 nyopi8e||r'xnh|Lt  xiffsRrmopvRsOlzjy|ozrmkmlzjmq 
[   u$D  0k'ixlp}hiffkrysRlzj'qvR'iynhjmkuozniffozopiffk'
vSxnhljmlzj'q\w\ivR'fuk

~#

5nhsSiffozlzjmi
4-< D

$lznhopfhqr'i
nhjmkuozniffozopiffk
] H  u$D   
 !  u$D   

C&Dff#~2,3

z
he#
#
he
e
he
he

CD#~2#2E3FIH

z
e
e
'
'#
u
'z

a#

z
he
e
he
he
hz
h

 nyozi8e~P||rmxnh|LtxRiffsRrmozvRs5fhxsRr'ysSivRs5fhiffnvRr'xRiffs

 Z
2 n#~ 
vlzslzjvSixRiffsSvRlj'qKvSf*iL'nhwMlzj'iGPmnvZvtediffsfhuiffnvRrmxRiffsnxRi~vR'i~w\fsSvDkmlzsR|LxlzwMlzjmnvSfhxtlzjk'ivSixwlzjmlzj'q
'ivRmixUnCkmlznhopfhqr'ilzsGdyxRfhyopiffwMnvRl|KfhxUjmfhvR
 D  BEBE8=DOUnhsUvSxnhlj'iffksSidnxnvSiffoptMfjJsSivRsafhiffnvRrmxRiffs
ynhsSiffkfjvR'iOqhxRfr'dys,qlz}hiffjlzjlpqr'xRi5jmnhw\iffopt;P|LfrysSvRlzp| k 4-< D5)a$lznhozfhqr'inhjmknhjmku
ozniffozopiffklzjy|ozrmkmlzjmqMu-   S  miffsSixRiffsRrmozvRsKnxRiIqlp}hiffjlj  nyozi8e
'fh
x Gu|mnhj'qhi*fjmoptvR'iiffnvRr'xRiffs*frmv6fhvR'inhr'vSfwMnvRl|iffnvRr'xRisSivRs*tulpiffozkysMnhj
lzw\dyxRf	}hiffw\iffjv\f	}hixvR'iOynhsSiffozlj'ihjvSixRiffsRvRlzj'qopthavSxnhlzjmlzjmqEvR'iOsStusSvSiffw fjvRmi 4- D?telziffozkms&vR'i
iffsSv,xRiffsRrmozv&frmv\fhPvR'inhrmvSfwMnvRlz|OiffnvRr'xRisSivRsMfhN
x Gu|mnhj'qhiffInhjykvR'iO'foziJkmlnhopfhqr'ih
 'iffsRisStusSvSiffwMsUfhx6iLunhwMdyopih5rmsSi       Shh jermw8ix\fh$xRiff|LfhqjmlziffkUfhxkmsKnhjmkv tdifh
xRiff|LfhqjmlzvRlpfjOqhxnhwMwnxnhs*iffnvRr'xRiffsPlzj0vR'ifflpxKxryopiffsSiv
lzjmnhoopthai\qlp}hi\xiffsRrmopvRsfhxvR'iMsStusSvSiffwvSxnhlzj'iffkfjmoztfj   H  u$D   $nhjmk [ u-
   $j'i|nhjsSiiEvRynv6vR'ixilzsJj'fhv0wCry|kmlixRiffjm|LilzjvR'ivUfsSivRs0fhIxRiffsrmopvRsmfhx
)'|ynhj'qhiffs5ffIevR'iasStusSvSiffw vSxnhlzj'iffk8fj [!  u$D   mnhs-nhjCnh||rmxnh|LtIml|8lssRlpqjyl|nhjvRopt
mlpqmixvRmnhj?vR'iEsRtesSvSiffw vSxnhlj'iffkfj   H  u$D  MetndnhlpxRiffkvHvSiffsRvk'7 hheP8v #;eu
d	$u ;$jiL'nhwMlzjmlj'qvR'iExrmopiffsSiv5fj'ijmkmsMvRmnv6vRmi [ '$D  MrmsSiff
s DBh4D2  4 

E
4

2
6


'


i
R
x
*
i
R
v
m

i


u

$

D











x
m
r
p
o
ff
i
R
s

i
G
v
'
k

f
ff
i
~
s
'
j
h
f

v

'


i
p
o

f
a


i
U
x
h
n

|

|
'
r

x
h
n
L
|
M
t
M
w
n	t,"i*kyr'iKvSf

H








 

vR'i,nh|LvvRynvvRmi   H u-   *dmxRiffkml|LvSfhx$ynhsn0opfxRiff|nhozonhjmkEdmxRiff|lzsRlzfjfh#
x DBh4D2  4 

E
4

2
6
h
n

s
S
s

i
ff
i

j

l
j

n
y

z
o
8
i
e



 

2  2po lmq%0z= 1

\ 

~



~22 

sw\iffjvRlpfj'iffkljceiff|LvRlpfjevR'ixinxRiU
; v tdiffsOfh,dmxfhyopiffwMnvRlz|kmlnhopfhqr'iffs24  5e<4  D8

w gx 4Dynhjmk  4i
jBZ&jfhxkmixvSfk'ivSixwMlzjmi&P'ivR'ixIsSfw\i\fhUvR'iffsSi\v tdiffsfhUdmxRfhopiffwMnvRlz|
VT 4

fi>

o r6rz~2g

24- 5)e6698
24  5e<4  D8
w gx 4Dy
 4i
jB
 fhvRnho

72

> 9?f7A@d.22

0zn\qpfiqsn

0z \q

e;
;u ;
he#h/u	
' h
uH ;	

'z	/
heH
mH ;fi ;
;he/h
e#h/hu	

n= 

 nopiMu~nvSxl0fhDxiff|Lfhqjmlpiffk24-<5ff
676=8"	Pnhjmk

o r#Irz~2g#

2fi4-<5ff
67698	
2fi4 <5
p4  D8

 fhvRnho

0z fqp
Bs#

uz	
uH ;
m

;he

 e/h
heffh

 nyopiMhPnvSxlOfh)xRiff|Lfhqjylpiffk2fi4-<5ff
67698	nhjmk^2fi4D
vSiffsRvRlzj'q

q$~2

z	 /hh
ffe 
ffe 
e  H r;
h / hh

24- 5e<4  D8

0|n\n9n

/h
/h ;
/h

\

~

f

~

o 2q~2

  
  
h / uff

5e<4  D8$rysRlzj'qMiffermnhovSxnhlzjmlzjmqnhjmk

kmlznhozfhqr'iffsMnxRiw\fhxikml{6|ryopv,vSfdmxRiffkml|Lv&vRynhjfhvR'ixsffaUi|Lfjmkmry|LvSiffkndfsSv'fu|nhjmnhoptusRlzs,fh
vR'i,dmxRfhdfhxRvRlzfjfh~dyxRiffkmlz|LvRlpfjnhlozr'xRiffsfhxiffnh|vted"i,fhGdyxRfhyopiffwMnvRl|8kmlznhozfhqr'ih8culzjm|Li&ai&UixRi
dmxlwMnxlzoptlzjvSixRiffsSvSiffklzjvRmi6dixRfhxwMnhjm|Li6fhKvR'i0~$rmsRlzjmqvR'irmozoanhr'vSfwMnvRlz|6iffnvRr'xRi0sSiv
nvSixCmn	}elzjmqsSiiffW
j Gu|mnhj'qhiffsJffIe-Ui|Lfjmkyrm|LvSiffkfr'xCnhjmnhoptusRlzs$fjvRylzs$}hixsRlpfjfhUvRmi~$D
 nyopi06sRmf	svR'i,kmlzsSvSxlpyr'vRlpfj0fh~vR'i,6v tdiffsfh~kmlznhozfhqr'iClzjEvR'i&vSiffsSvsSiv$nhjmkP'ivR'ix$vR'i
)'|ynhj'qhiffsffII~$5nhs~nyoziUvSf8dmxRiffkmlz|LvG|LfhxxRiff|LvRopt&vRmnvGvR'i*kmlnhopfhqr'iKUfrmozk,
i 2fi4-< 5ff

 67698	
fhR
x BEDFGfi 8  4E2  6)$j'i5|nhjMsSii5vRmnv)vR'i5UfhxsSv)dixRfhxwMlzj'q|nvSiqhfhxRt\lz
s 2fi4D 5e<4  
 D8&nhjmk&vRmnv
vR'i8a$dmxRiffkylz|LvRsKlzjm|LfhxRxiff|LvRopt6vRynvPhefhvR'
i 24-< 5
<4  
 D86kmlnhopfhqr'iffs*nxRb
i 2fi4-< 5ff

 67698	h
$jmiIxRiffnhsSfjEvRmnvvRylzs*wMlpqv*fu||r'x$lzsKvRmnvPvRmlzssr''|nvSiqhfhxRtOfhGkmlnhopfhqr'iffs*nxRi&wCry|w\fhxRi
kml{J|rmopv,vSfdmxiffkmlz|LvMsRlzjy|LilzjvRmlsM|nhsSivR'i  sStusSvSiffw mnhs6j'fljmkmlz|nvRlpfjvRynv6lpvMlzs6j'fhv
sRrm||Liiffkylzj'qlzj?vR'ivRnhsSg"Pf	Ui}hixffInhj'fhvR'ixOdfsRsRlzylzozlpv tlzsJvRmnvOvR'i~$ dixRfhxwMsJdffhxopt
fj?vRmlzsM|nvSiqhfhxRt?iff|nhrmsSivRmixRiEnxRiEiUixJiLunhw\dopiffslzjvR'ivSxnhljmlzj'qsSivPnhopvR'fr'q?lpvk'feiffs
ivSvSixfjvR'i  4i
j
 BsRr'ysRiv"Pmlz|lzs$nfr'vvR'i\sRnhw\i,dmxRfhdfhxRvRlpfjiM|nhjiffolzwMlzjmnvSiCvR'i
yxsRvUdfsRslpylzozlzvt,t6iLunhwlzjmlzj'q,'fn\opiffnxj'ixKdixRfhxwMsUmiffj6vSxnhlzj'iffk0fj0iffermnhodmxRfhdfhxRvRlpfjysafh
24- 5)

 67698nhjy
k 2fi4D 5e<4  
 D80kmlznhopfhqrmiffs)iC|Lfjmkyrm|LvSiffknhjOiLudixlzw\iffjv*rmsRlzjmq,nsRr'ysSivKfh
24- 5)

 67698&kmlznhopfhqr'iffs8lzjvR'iJsRnhw\idyxRfhdfhxRvRlpfjnh+
s 2fi4-< 5
p4  
 D8fhxCvR'iMvSxnhljmlzj'qnhjmkvR'i
vSiffsSvsSivPnhjmkvSxnhlzj'iffknsSiff|Lfjmk~$?rysRlzj'q,vR'iIrmozozt6nhr'vSfwMnvRl3
| )'|ynhj'qhi6ffIMiffnvRrmxRiffs  mlzs
xRiffsRryopvSiffklzjJnCvSxnhlzjmlzjmqIsSivafhDh&kylznhopfhqr'iffsUnhjmkJn8vSiffsSv5sSivUfh-uffe  miylzjynxRt\|oznhsRsRlixamnhsUnhj
nh||r'xnh|Ltfh-JvRmiP|LfhxRxRiffsRd"fjykmlzj'qxRiff|LfhqjylpvRlpfjwnvSxllzs)dyxRiffsSiffjvSiffk6lzjvRnyopi8h  'i*xRiffsrmopvRs
sR'f vRynvPiai#
x 24- 5e<4  
 D8InxRi8dyxRiffkmlz|LvSiffknhsPsrm||LiffsRsSrmo/"sRr'qhqhiffsSvRlzjmqvRmn#
v 2fi4D 5e<4  
 D8
nxRij'fhv6ljm'ixRiffjvRoptw\fhxRikml{6|ryopv\vSfdyxRiffkmlz|LvMvRynhj?fhvRmixJ|oznhssSiffsJfhdmxRfhyopiffwnvRlz|kmlnhopfhqr'iffs
Uiffopf	UikylzsR|rmsRsMvR'iEdfhvSiffjvRlznhoPfh8rmsRlzjmW
q D  BEB=8EDsopfssxnvRlzfvSf;aifflpqv0kmlixRiffjv6vtediffs6fh
|oznhsRsl|nvRlpfj0ixRxfhxs*lzj0r'vRr'xRiUfhxRg"
VTV

fi

t )
Y uQ

2Zy222S2-



7M1m



72

  Q _wv ^ffx

 'i&xRiffsSiffnx|xRidfhxRvSiffk'ixRi,lzsPvR'i&yxsSvvRmnv$Ui&guj'f fhavSfOnhr'vSfwMnvRlz|nhozoztnhjmnhoptei\nJ|Lfhxdyrms
fhopfhqsCxRfwnEsSdfhghiffjkylznhopfhqr'iJsStesRvSiffw fhx,vR'idyrmxRdfsSiMfh*opiffnxjylzj'qvSf RR/ff dmxRfhopiffwMnvRlz|
sRlpvRrynvRlpfjms  mlzs$UfhxRgyrylzozkmsfjv afsSvSxnhjykmsIfh5iffnxozlzixIxRiffsSiffnx|ZlpxsSvDvRmlzs8ndmdmxRfnh|5nhs
lzjmsRdylpxRiffk,et,afhxRg\fj6vR''
i Bh4D4y   8\i}nhozrmnvRlzfjMxnhw\iUfhxRg\fhxUsSdfhghiffj6kylznhopfhqr'i*sStusSvSiffwMsaml|
r'vRlzolpiffs0fhvRwCrmozvRlp}nxlznvSiozlzj'iffnxOxRiqhxiffsRsRlpfjnhjyk 5'
   vSfdmxRiffkml|Lv0rysSixsRnvRlzsRnh|LvRlpfjnhsn
rmjm|LvRlpfjfhnjrmwCix8fh*fhvRmix,wMivSxlz|s0nhopghixff~-lpvRwMnhjZ
 InhwMw~PiffozoznuKffhanhozghix
ivPnhoHphhhn
 *iffsSiffnx|rysRlzj'N
q Bh4D4y  < 8Omnhs*frmjmk0vRynvvRnhsSgO|Lfw\dyozivRlpfjlzs*nhozUn	tesnMwMn Sfhx
dmxRiffkylz|LvSfhxfhKrmsSixIsRnvRlzsRnh|LvRlpfj-nhjmkmnhsIiLunhwMlj'iffkdmxRiffkylz|LvSfhxs$fhUvRnhsSg|Lfw\dyopivRlpfj,PixRih-fr'x
qhfnhozsanxRiPsRlwMlzoznx)lzj,vRmnvaaiPnvSvSiffw\dmv~vSf&rmjmk'ixsSvRnhjmk,vR'i*nh|LvSfhxsavRmnvGdmxiffkmlz|Lv)vRnhsSg\|Lfw\dyozivRlpfjZ
ceiff|LfjmkyopthuvRmlzsaafhxRg6yrmlzokms)fj0iffnxozlzixaxRiffsRiffnx|Ofj0opiffnxjmlzj'qCvSf /y I kmlznhopfhqr'iffs5lzj6ml|JvR'i
rmsSixiLudixlpiffjm|Liffkdfefhx$sRd"iiff|xRiff|Lfhqjmlpix8d"ixfhxwnhjm|Li0-lpvRwMnhjivInho/pGffhhMUiff|nhrmsRi\vRmnv
UfhxRgOUnhsynhsSiffkEfjiffnvRr'xRiffssStujvR'iffslpiffkf}hixPvR'iCiffjvRlzxRi8kmlznhozfhqr'ihyvR'iCtedfhvR'iffsSiffs*vRynvUixRi
opiffnxjmiffk|Lfrmokj'fhv&i6rmsRiffkfhxCdyxRiffkmlz|LvRlpfjkmr'xlj'qxrmjvRlzw\ihjnhkmkmlzvRlpfjZlzj|LfjvSxnhsSv,vSfvR'i
|r'xRxiffjvsSvRrmk'th"vR'i8dyxRi}elzfrms*UfhxRgnhr'vSfwnvRlz|nhozoptndmdyxRfff'lzwMnvSiffkEvR'i,j'fhvRlpfjEfhGnqhfefekEfhx$ynhk
kmlznhozfhqr'irmsRlj'qInvR'xRiffs'fozk\fj6vR'i*dix|LiffjvRnqhiPfhZxiff|LfhqjmlpvRlpfjixRxRfhxs  mixRilzsGnCkmnhj'qhixafhZvRmlzs
ndmdmxfnh|ifflzj'q0|lpx|rmonxPmiffjxRiff|LfhqjmlpvRlpfjdixRfhxwMnhjm|Li\nv$vR'iMr'vSvSixnhjm|LiMopi}hiffolzs$n0dmxlzwnxRt
dmxRiffkylz|LvSfhxafhnCqhfefekJfhx5ynhkJkmlznhopfhqr'ihjMvRmls~UfhxRg"evRmiPj'fhvRlpfj6fhnCqhffuk 2fi4D 5)

 67698	Dnhjmk
ynhkg B=D7F
Gy
 8  4E2  6~kylznhopfhqr'i$5nhsozniffozopiffkJetJermwMnhjys
jdmxi}elpfrysafhxgKnhopghix,ivCnho/p)hh"IxRidfhxRvSiffkxiffsRrmopvRsxRfw vSxnhlzjmlzjmqndmxRfhopiffwMnvRlz|
kmlznhozfhqr'iIdmxRiffkylz|LvSfhxPlzjmlz|OvR'itjmfhvSiffkvR'iCiLevSiffjvvSf6ylz|OvRmi&mnhjykuozniffozopiffkEu-   
iffnvRr'xRi\lzw\dmxf	}hiffs$|oznhsRsRlpyixPdixRfhxwMnhjy|LihsnxiffsRrmopvfhGvRmlzsPdmxlzfhxnhjmnhoztesRls"ljvRmlsUfhxRgUi
xRidfhxRvPxRiffsRrmopvRsxfw vSxnhlzjylzj'qnhj   H  u$D  *|oznhsRslyixfhxiffnh|iLu|mnhj'qhi\nhjmkrmsRlzjmqlpvRs
dmxRiffkylz|LvRlpfjmsanhsanhj0lzj'dr'v)iffnvRrmxRiPvSf&vR'i$GxRfhopiffwMnvRlz|Plnhopfhqr'iP~xRiffkmlz|LvSfhx	  'ixRinxin&jryw8ix
fhydyxRi}elzfrmssSvRrmkmlpiffsDfj,dmxiffkmlz|LvRlzj'qPxRiff|LfhqjmlpvRlzfj,ixRxRfhxs)nhjmk\rysSix)|LfhxRxRiff|LvRlpfjmsGmlz|CnxRiKxiffoznvSiffk,vSf
vR'i   H  u$D  )dmxRiffkylz|LvSfhxavRynvaUiPxid"fhxv~fj0'ixRi,PlpxsR|ixRq8ivKnho/pffhhemPlzxsR|ixRq'
lzvRwMnhjZy ceUixRvRs"hhu"h'L"i}hf	8-ffhhelpvRwMnhjmPlpxsR|ixRq'y ceUixRvRsyhhuceUixRvRs
lzvRwMnhjZylpxsR|ixRq'yhh
lpxsR|ixRq,ivnhoHpffhh*ndmdyop
t D  BEBE8=DEvSf\dyxRiffkmlz|Lv5xRiff|LfhqjmlzvRlpfj0ixRxRfhxsKljOn\|LfhxRdyrmsUfh)
r'vSvSixnhjy|Liffsj|LfjvSxnhsRv6vSffr'xUfhxRg"KvR'itr'vRlzozlpiOdyxRfsSfukmlz|0iffnvRr'xRiffslj|LfwCylzjmnvRlpfjlpvR
nh|LfrmsSvRl|M|Lfjuk'iffjy|LiMsR|LfhxRiffs  mitxRidfhxRvnOiffsSv|oznhssRlyixnh||r'xnh|LtfhKhJPmlz|lsnL
lzw\dyxRf	}hiffw\iffjvGf}hixavR'ifflzxGynhsSiffozlj'i5fh0  mlzsxRiffsrmopv)|nhjMi*|Lfw\dynxiffkMlpvR,frmx~ylzjynxRt   H 
u-   5dyxRiffkmlz|LvSfhx,g D767FDD8962}es
 D  i
67FDD8962KkmlzsR|rmssSiffklzjceiff|LvRlpfje
 GunhwMljmnvRlpfj
fhmvR'i5xryopiffsopiffnxj'iffk8etIvR'ifflzxD|oznhssRlyixsRr'qhqhiffsSvRsvRynvDkmrmxnvRlpfjmnhoiffnvRrmxRiffsnxRiKlzw\dfhxRvRnhjvmlzopi
Ui~k'f*j'fhvrmsRiGnhw\dyozlpvRryk'ifhxKiffnvRrmxRiffsai~kmf*mnff}hi~nhj       Sh/ iffnvRrmxRiGml|lzsZopfhqhqhiffk8t
vR'ixRiff|Lfhqjmlpix	GlzvR'fr'v5nhjt6fhvR'i$fhvR'ix5dmxRfsSfukmlz|iffnvRrmxRiffsuvR'i   H  u$D  Gdmxiffkmlz|LvSfhx
mnhs&nhjnh||rmxnh|LtfhPhe JGnhe lzw\dmxf	}hiffw\iffjv8f}hix\vR'iynhsRiffozlzj'iMfhh ;0vClzs8d"fssRlpyopi
vRmnv~ljm|ozrmkmlj'qdmxfsSfekylz|UiffnvRr'xiffs~lzj,vR'i   H u-   DdyxRiffkmlz|LvSfhxG|Lfrmok\lzw\dmxRf}hi*vRmlzsxiffsRrmopv
i}hiffjr'xRvRmixff
~xRi}elzfrmssSvRrykmlpiffs*fjixRxfhx|LfhxRxiff|LvRlpfjxiff|LfhqjmlpvRlpfjnxRi,nhozsSfxiffoznvSiffkvSf6fr'x$w\ivR'fukfhawMlzs
rmjmkmixsSvRnhjmkmlj'q$xRiff|LfhqjmlpvRlpfjKi}hf	IZffhhandmdyolpiffkMsRlzwlzoznx)vSiff|yjmlzer'iffsGvSf&opiffnxjMvSf,kmlzsRvRlzj'qrmlzs
ivUiiffjr'vSvSixnhjm|Liffsljml|EvR'i\rmsSixfhxlpqlzjmnhoopt0dmxRf	}ulzk'iffkEsSfw\i\lzj'fhxwMnvRlzfjvSf0vR'i\sStusSvSiffwO
nhjmk RRff/ yylz|dmxRf	}ulzk'iffk6vR'i$sRnhw\ilzj'fhxwMnvRlzfjn,sSiff|LfjmkJvRlzw\ihefozopf	Plzj'qCn&wMlzsrmjmk'ixS
sSvRnhjmkylzj'q'  mlswMn	ti8w\fhxRi&xRiffoznvSiffkEvSf6frmxPxRiffsRiffnx|vRmnhjlpv*xsSvndmdiffnxssRlzjy|LiC|LfhxRxRiff|LvRlzfjms
VT 1

fi>

72

> 9?f7A@d.22

nxRi6fhvSiffjwMlzsrmjmk'ixsRvSffukkmr'iMvSftdixSnxRvRl|rmoznvRlpfjZOi}hf	Is&iLud"ixlzw\iffjvRsIvSxnhlzjnk'iff|lsRlpfj
vSxRii$rmsRlzjmqiffnvRr'xiffsasRry|JnhsakmrmxnvRlpfjZvSiffwMd"f'edylpvR|ZnhwMdyozlpvRrmkmihnhjmk6lpvRmlzj'r'vSvSixnhjm|LiKdynhrysSiffs
)'nhwMlzjynvRlpfjfh~vR'iCvSxnhlzj'iffkvSxii,ljvRmlzssSvRrmkmtnhozsSfJxRi}hiffnhozsvRmnvvR'i&kyr'xnvRlpfjmnhoiffnvRrmxRiffsnxRi
vR'i$w\fsSvUkmlzsR|LxlwMlzjmnvSfhxRthGculzwlzoznxoptClzjMfr'xUiLud"ixlzw\iffjvRs1
 D  BEBE8EDrmsSiffs       Sh/ xRiffer'iffjvRozt
lzj0vR'iCk'i}hiffopfhdiffk0xrmopisSivUi}hffhmvRnhlzjys*nhjnh||r'xnh|LtOxnvSiIfh) lpvROn\nhsSiffozlzj'i$fhGJ
HceUixRvRsaivUnhoHpehhanhjmkElpxs|"ixqIivUnhoHpuh'L"GdixRfhxw sRlzwlzoznxGsSvRrmkylpiffsGfhxanhr'vSfwnv
lz|nhozozt,lk'iffjvRlztulzj'qI|LfhxRxiff|LvRlpfjms5rmsRlzjmqIdmxRfsSfuk'th
 4- DiffnvRr'xiffsUnhjyk6kmlnhopfhqr'iP|LfjvSiLuvUUfhxRxRiff|LvRlzfjms
nxRiolpghiffopt&vSfIiwMlzsSxiff|LfhqjmlpiffkZkyr'iKvSfCtdixnxvRlz|rmoznvRlpfj  'it&fhysSix}hivRmnv~|LfhxxRiff|LvRlpfjms~vRmnv
nxRiw\fhxRiPkylzsSvRnhjv~xRfw vR'iPixRxRfhxUvR'itM|LfhxRxRiff|Lv'nxRiw\fhxRiozlpghiffopt&vSfCiL'mlplpv)dmxRfsSfukmlz|Kkyl"ixiffjm|Liffs
 'ifflzxsStusSvSiffw nhr'vSfwnvRlz|nhozoptkmlixRiffjvRlznvSiffs|LfhxxRiff|LvRlpfjmsxRfw j'fju|LfhxRxiff|LvRlpfjmsMPlpvRnhjixxRfhx
xnvSiMfh$ffe#JM$lznhopfhqrmiM|LfjvSiLuvClzsrysSiffklzjvR'iMsSvRryk'tet;lpxsR|ixRq'-lpvRwMnhjceUixRvRs
h'n5'ixRietvR'it;lzjm|LfhxRdfhxnvSi0mivR'ix,vR'iOrmsSix\lzs,nff5nxRifhnwlzsSvRnghiOnv\vR'iO|r'xRxRiffjv
r'vSvSixnhjy|LiPvSf,'iffopd6dmxRiffkmlz|LvawMlzsRrmjyk'ixsSvRnhjmkylzj'qs)nhjmk6wMlzsSxRiff|LfhqjylpvRlpfjMfhvR'idmxi}elpfrys~r'vSvSixnhjy|Liffs
 mlssSvRrmkmtlzssRlzwMlzonxvSfJfr'xs$lzjEvRmnv$vR'itrmsSi,nJdmxRiffkml|LvSiffkiffnvRr'xRi,nfr'vnhjr'vSvSixnhjm|LivR'i
nff5nxRihDiffnvRrmxRi$vSfdyxRiffkmlz|LvI|Lfjm|Lidyv8fhx8Ufhxknh||r'xnh|Lth)nhsIUirmsSi6nOdmxRiffkml|LvSiffkiffnvRrmxRi   H 
u-   alzj0vR'iIaDmPf	Ui}hixff"fr'x   H  u$D  UiffnvRr'xiIlzsKnhr'vSfwMnvRlz|nhooptJn	}nhloznyopi
nvKvR'i$vRlzw\i$vR'i$dmxiffkmlz|LvRlpfj0lzsUifflzj'q,wMnhk'ihu'ixiffnhs5vR'itJnxi$wngelzjmq&vRmidyxRiffkmlz|LvRlpfjys~xRivSxfnh|
vRlp}hiffopthj;nhkykmlpvRlpfjZDvR'itvSxnhlzjvRmifflpx&sRtesSvSiffwfj;vR'i0mnhjmkuon"iffoopiffkiffnvRr'xRiJxnvR'ix,vRmnhj;vR'i
dmxRiffkylz|LvSiffk0fj'iIylz|0vR'itOopiffn	}hi8nhs*r'xRvRmixKafhxRg"
g Ilzx|mmfD'h'	adixRfhxwMs~ixxRfhxK|LfhxRxRiff|LvRlpfj0lzk'iffjvRl|nvRlzfj6rmslzj'qIvRnhsSgJlzjmk'idiffjmkmiffjv~nh|Lfrys
vRlz|JnhjmkkmlzsR|LfrmxsSiM}nxlznyoziffs  mlzs8ls&nEvUf5nfftkylzsSvRlzjm|LvRlzfjivUiiffjd"fslpvRlp}hi6nhjyk;jmiqnvRlp}hi
ixRxRfhx|LfhxRxRiff|LvRlpfj*c''i8rmsSiffsvUfJ|nhs|nhk'iffkE|onhsRsRlyixs'vR'iIxsSvlzsnk'iff|lzslpfjOvSxRiiCvSxnhlzj'iffkrysRlzj'q
fhvR'ikmnvRnnhjyk}nholzkmnvRlzj'qfjJ
 GunhwMdyopiffs&vRmnvmn	}hi|Lfjukmiffjm|LisR|LfhxRiffs\iffopfn
vR'xRiffs'fozkqhf0lzjvSfJnhjiL'|LidmvRlpfjEvSxnhlzjmlj'qsSivfhxnJsSiff|Lfjmk|oznhsRsRlpyixff$r'xlj'qvSiffsSvRlj'q'"lzG|Lfjum
k'iffjm|Li,sR|LfhxRiffsnxiCiffopf n6vR'xRiffsRmfozkvRmiffjvR'i\r'vSvSixnhjm|Li&lsdynhssSiffkfjvSf0vR'i,sSiff|Lfjmk|oznhsRslyixff
cu'iIjmkmsvRmnvPvRmiCw\fsSvkmlzsR|LxlzwMlzjmnvSfhxt6iffnvRr'xRiffsnxRi,kmlznhopfhqr'iC|LfjvSiLuvMvR'iCv tdiCfh)dmxRi}ulpfrms
sStusSvSiffw rmvSvSixnhjm|Li$fozopfaiffktopiL'lz|nhoiffnvRr'xRiffsDlpvRdmxRfsSfukmlz|&iffnvRr'xRiffsIifflzjmqOvR'iopiffnhsSvCkmlzs
|LxlzwlzjmnvSfhxRth  'i6sStesRvSiffw xRiff|Lfhqjylpiffs8ixxRfhx&|LfhxxRiff|LvRlpfjmsClpvRnhj;nh||r'xnh|Ltfh|Lfw\dnxRiffk
vSf6nynhsSiffozlj'i$fh~uJ5jvRmlzs*sSvRryk'tg 8lpx|y'fD"h'	kmiffozlpixnvSiffopt6iffsR|'iPs*vR'i&rmsSiIfh)sStus
vSiffwsSdiff|l|iffnvRr'xRiffsffylzopi8lzjfr'xUfhxRg"aiCiLunhwMlj'i8vR'i,sSidynxnvSi&|LfjvSxlpyrmvRlpfjfhGkmlp"ixRiffjv
iffnvRr'xRiCsRivRsP$r'xPxRiffsRrmopvRssRr'qhqhiffsSvPvRmnvPvRmiCrmsSi8fhGw\fhxRi8qhiffjmixnhoiffnvRr'xRiffsk'feiffsPj'fhvPj'iqnvRlp}hiffopt
lzw\dnh|LvKd"ixfhxwnhjm|Lih
g xnhmw\ixffMceUixRvRs  'iffrmjmih, iiqhiffozsEffhhnnhjmk g xnhyw\ixffMceaixvRs  'iffrmj'ih,
iiqhiffozsffhhGopfefhgMnv5kmlixRiffjv~iffnvRr'xiffs~xRiffonvSiffkvSf&xRiffsSdfjmsSiffs~vSfCdyxRfhyopiffwMnvRl|*sStusSvSiffw vRrmxjms
 'i h  < ~z Mh/ IvR'itkmlzs|rmsRs$nxRiMxRiffsRd"fjysSiffs$vSfiLudyozlz|lpvfhx8lzwMdyozlz|lpvsStusSvSiffw}hixl"|nvRlpfj
er'iffsSvRlpfjmsff  mitfhysSixR}hi&vRmnvkmlzs|LfjuyxwMnvRlzfjmsnxRi,opfj'qhix	ynff}hi\n0wMnxRghiffkafhxkEfhxk'ixffZnhjmk
|LfjvRnhlzjsSdiff|l|8oziLulz|LfjsRry|nhsOSj'fujnhkmkmlzvRlpfjZyvRmixRi\nxRi&sRd"iff|lp|IdmxfsSfekylz|8|r'iffs$sRry|nhs
frmjmkmnxtvSfj'iffsMnhjmkdynhrmsSiffscefwMiOfhPvR'iffsRiOiffnvRr'xiffsMsRrm|nhsMopiffj'qhvRa|mflz|LifhafhxkysMnxRi
|ndmvRr'xiffklzj0fr'C
x D  BEBE8EDxryopiffsSiv*nhskylzsR|rmsRsRiffkJnf}hih
sk'iffs|Lxlpiffk0lzjEceiff|LvRlpfjEeyvUf6wMivR'fekmfopfhqlpiffsKUixRi8|Lfw\dnxRiffkfhxlzjm|Lfhxd"fhxnvRlzj'q,vR'iIiffn
vRr'xRiPu-   lzjvSfvR'i5~$D  'iayxsSv-UnhsvSfrmsSiUvR'i5mnhjmkuon"iffoopiffkiffnvRr'xRi5lzj8vRmiUvSxnhlzjmlzj'q
sSivmvRmi8sSiff|LfjmkvSfMdixRfhxw sSidynxnvSiIiLudixlzw\iffjvRsKvSfMdyxRiffkmlz|LvKvR'iiffnvRr'xRi8fhxPvR'ivSxnhlzjmlj'q\sSiv
sKvR'iiffnvRr'xRiffs*lzj0vRmivSxnhlzjmlzjmq&sSiv*nxiInhr'vSfwMnvRlz|nhozozt6dmxiffkmlz|LvSiffkZ'lpv*lzsKmfhd"iffkJvRmnvvR'iIsStusSvSiffw
Ufrmozk,dylz|gCr'd\vRmilzkmlpfsRtejm|LxnhsRlpiffs-fh"vRmi*j'flzsSt&kmnvRnu  mlzsDvSxnhljmlzj'q$w\ivR'fukMmnhs)iiffj\rmsRiffk,dmxRiL
}ulpfrmsRopt6lzjxlpqvhh5mixRinhr'vSfwMnvRlz|nhozozt6lzk'iffjvRlyiffk0lzjvSfjmnvRlpfj0i}hiffjv*iffnvRr'xRiffs*nxiIrmsSiffk
VT

"

fi

2Zy222S2-



7M1m



72

vSfvSxnhlzjnhjnhr'vSfwMnvRlz|CsSdiiff|unh|Lv$k'ivSiff|LvSfhxff  'iffsSi&nhr'vSfwMnvRlz|nhozozt0kmixlp}hiffkiffnvRr'xRiffsPdmxRf}elk'i8n
ivSvSix5vSxnhlzjmlzjmq8w\fuk'iffomvRmnhjJvR'i$mnhjmk'ozniffozopiffk,fj'iffs  mlzs~ls~vSxrmiPnhozsSf,lzjvR'i|rmxRxRiffjvUsSvRryk'tMnhs
kmlzs|rmsRsSiffk0lzjEcuiff|LvRlpfjez
yYNX

b?ff'`fffbH^ ]


] _

 `l`l Q
v

^zx

 mlsPdnd"ix$xRidfhxRvRs$xiffsRrmopvRs$fjnhr'vSfwnvRlz|nhozoptvSxnhlzjmlj'qJnO~xRfhyopiffwnvRlz|C$lznhozfhqr'iMGxRiffkylz|LvSfhxvSf
dmxRiffkylz|LvPdyxRfhyopiffwMnvRl|CermwMnhju|LfwMdyr'vSixkmlznhopfhqrmiffsrysRlzj'q0n0|LfhxRdyrms$fhahh0kmlznhopfhqr'iffs|Lfoopiff|LvSiffk
lpvRCvR'i h  L   sSdfhghiffj,kmlznhopfhqr'i5sStusSvSiffwO  'i5GxRfhopiffwMnvRlz|U$lznhopfhqr'iKGxiffkmlz|LvSfhx
|nhji6lzww\iffkmlznvSiffoptndydyozlpiffkvSfvRmi0sRtesSvSiffws&kmiff|lzsRlpfjfhmivR'ixCvSfvSxnhjysSix,vR'iO|nhozoavSfn
ermwMnhj|rmsSvSfw\ixO|nxRinqhiffjvPfhx0iErmsRiffk?nhs0n;|r'iEvSfvR'isStusSvSiffwOs0$lznhopfhqr'inhjmnqhixOvSf
w\fukmlptlpvRsM"iffynff}ulpfhxMvSfxRidnhlpx\vR'idmxfhyopiffwMs\lzkmiffjvRliffkZ  'ixRiffsrmopvRs\sR'f vRmnv	\EfsSv
iffnvRr'xRi,sSivRs$sRlpqjml"|nhjvRoptOlzwMdmxRf	}hi&f	}hixvRmiCynhsRiffozlzj'ih)/
 :PsRlj'q6nhr'vSfwnvRlz|8iffnvRr'xRiffsxRfw vR'i
'foziJkmlnhopfhqr'ihGUi|nhjlzk'iffjvRlptdmxRfhyopiffwnvRlz|6kylznhopfhqr'iffsMivSvSix\vRmnhjvR'iOnhsSiffozlzj'ih$ ;
{ rysSvvR'iCyxsRv*iLu|mnhj'qhi,dmxRf}elk'iffsPslpqjml|nhjvRopt0ivSvSixPdyxRiffkmlz|LvRlpfj; ;M*vRmnhjvR'i8ynhsRiffozlzj'ih)
 'isSiff|Lfjmk6iLu|mnhj'qhi$dmxRf}elk'iffs~nhjJnhkmkmlpvRlzfjmnhomsRlpqjyl|nhjvP< ;M~lzw\dmxRf}hiffw\iffjvZ/~|oznhsRslyix
ynhsSiffkJfj0vRnhsSglzjmkmid"iffjyk'iffjv5nhr'vSfwMnvRl|PiffnvRr'xRiffs5dixRfhxwMs5sRolpqvRozt\"ivSvSixKvRynhj6fjmivSxnhlzj'iffkJfj
vR'iIrmozonhr'vSfwnvRlz|iffnvRr'xRi8sSiv
 miGlzw\dmxRf}hiffkInylzolpvtPvSf*dmxRiffkml|Lv"dyxRfhyopiffwMnvRl|)kmlznhopfhqr'iffsZlslzw\dfhxRvRnhjvfhxZiffozkmlzj'q5vR'i 
Cf
sStusSvSiffw lpvR'frmvPvR'i,j'iiffkfhxvRmi&f}hixsRlpqvfh~n0ermwMnhj|rmsSvSfw\ixI|nxRi\nqhiffjv  'iffsRiCxRiffsrmopvRs
nxRi,dmxRfwlzsRlzj'qJnhjmkai,iLudiff|LvvSfOi,nyopi,vSfOlzw\dmxf	}hi\r'dfjvRmiffwOZdfsRsRlpyoztJetEljm|LfhxRdfhxnvRlzj'q
dmxRfsRfek't6lzjvSf\vRmiiffnvRr'xi$sRivCPlzxsR|ixRq,iv*nho/pffhhUfhx*iLudynhjmkylzj'q&fj0vR'iCEiffnvRr'xRiIsRivRs
j&nhkykmlpvRlpfjZvR'i5xRiffsrmopvRssRr'qhqhiffsSv)vRynvDvRmi*|r'xRxRiffjvDa$lzsozlpghiffopt8vSfqhiffj'ixnhozlpi5vSf$fhvR'ix~kylznhopfhqr'i
sStusSvSiffwMs
j\r'vRr'xRi5UfhxRgaidyoznhj,vSf8lzjvSiqhxnvSi*vRmiopiffnxj'iffk,xrmopiffsSivRsGljvSfvR'i 
Cf kmlznhozfhqr'i*sStusSvSiffw
nhjmkEi}nhormnvSiCvRmi&lzwMdynh|LvvRmnv$vRmls*Ufrmozkmnff}hi&fjvR'i&sRtesSvSiffwsPf}hixnhozoDdixRfhxwMnhjm|Lih  'ixRi
nxRi,sSi}hixnho-Un	tesUi&wlpqvPiCnyopiCvSfJs'f	 vRmlzs
 iffw\iffwC"ixvRmnvfj'i,rmsSi8fh)vRmiC~$lzsvSf
lzw\dyxRf	}hi5vR'iKsStusSvSiffwOsGkmiff|lzsRlpfjCfhP'ivR'ix)nhjmk,'iffj&vSfvSxnhjysSix)n|nhozoevSfvR'iKermwMnhj\|rmsRvSfw\ix
|nxRi\nqhiffjv  'i8fhvRmix$rysSiCUfrmozki&nhs$lzj'dr'v*vSfJvR'i&$lznhozfhqr'i&nhjmnqhixffskylznhopfhqr'i,sSvSxnvSiqht
sSiffopiff|LvRlzfjw\iff|mnhjmlzsRw~iffw\fjmsSvSxnvRlj'qMvR'i8rmvRlzozlpv tfhvR'i8a?fhxPkmlznhozfhqr'iIsSvSxnvSiqhtsSiffoziff|LvRlpfj
xRiffermlpxRiffsDiLudixlzw\iffjvRsvRmnv)vSiffsSvGfrmvGsSi}hixnhomkmlp"ixRiffjvUn	tesGvRmnv)vRmlzs)lzjmfhxwnvRlpfj,|Lfrmozk,iKrmsSiffk
et&vRmiP$lznhopfhqr'iEnhjynqhixff~iffw\fjmsSvSxnvRlzj'q8vRmir'vRlzozlzvt&fhZvR'iPa;fjvR'iPk'iff|lsRlpfj\vSfCvSxnhjmsSix
nJ|nhozoj'iff|LiffsRsRnxloptOlzj}hfoz}hiffsPiL'nhwMlzjylzj'qvRmiCvSxnhkmifsnhw\fjmqJkmlp"ixRiffjvgelzjykms*fhGixxRfhxs  mlzsPlzs
iff|nhrmsSiPi}hixRt6|nhozoyvRmnvUvR'i 
Cf sRtesSvSiffw|nhjJmnhjmkmozisRrm||LiffsRsRrmoopt\sRnff}hiffsKnC|Lfw\dynhjtMvR'i$|LfsSv
fhGrmsRlj'qMnMermwMnhj|rysSvSfw\ix$|nxRiCnqhiffjvPvSfJmnhjmkmozivR'iC|nhozoH  ermsyai&|nhjEnhsRsRfe|lznvSi&vRmlzs|LfsSv
lpvRvR'i6k'iff|lsRlpfjvRmnv  wMnghiffs&vSfvSxnhjmsRixCvR'i6|nhozoHJ'iffj Cf vSxnhjmsSixsIvR'iJ|nhozo
rmjmjmiff|LiffsRsRnxlzozthUi$|nhooyvRmlsa|LfsSv5vR'i p  ~  Hh \   UjvR'ifhvR'ix*mnhjykZi}hixRtJ|nhozovRmnv
 nvSvSiffw\dmvRs$vSfOmnhjykmopi8nhjmkEnhlzozsafrmokdfhvSiffjvRlznhozoptOnh||Lxr'i\nJkmlixRiffjvP|LfsSvjmnhwMiffoptOvR'i
opfsSvCxRi}hiffjer'i6xRfw|rmsSvSfw\ixs8mfiff|Lfw\i0lpxRxlpvRnvSiffklpvRnhrmozvt|rmsSvSfwMix,sRixR}el|Li6nhjmkvRnghi
vR'ifflpxrmsRlzj'iffssPiffosSi'ixRih,i|nhoovRmlzs|LfsSvIvRmi0     I  SJ   MjvR'i\xRiffsrmopvRs$vRmnvUi
dmxRiffsRiffjvSiffk'ixRih"ai&xRidfhxRvPfjmoptOf	}hixnhozonh||r'xnh|LtxRiffsrmopvRsnhjykvSxRiffnv p  *  Hh \   nhjmk
     I  S   nhsPiffermnhozozt|LfsSvRopthfai}hix	lzjnhjtdnxRvRlz|rmoznxlzjmsSvRnhooznvRlpfjfh~vR'i 
Cf
sStusSvSiffwO"vR'ixRi&wMnffti&kmlixRiffjm|Liffs*iv aiiffjvR'iffsSi,|LfsSvRsvRmnvPafrmokj'iiffkEvSf6i&nh||LfrmjvSiffkfhx
lzj\vRmi*vSxnhlzjmlj'q$fh"vRmi~$DvGUfrmozk\iKdfsRsRlpopi5vSf8rmsSC
i D  BEBE8ED0vSf&k'fvRmlzsfflp"vR'iffsSiP|LfsRvRsGUixRi
guj'f	j't0rmsRlzjmq,lzvRs*nylzozlzvtvSf}nxRtJvR'i8ozfsRsKxnvRlpf'
VT 2

fi>

72

> 9?f7A@d.22

j'fhvR'ixdfhvSiffjvRlznho)lzsRsRrmi8fhxr'vRrmxRiCUfhxRglzsvR'iMr'vRlzozlzvtOfhanOkylznhopfhqr'i,opi}hiffoDdmxRiffkml|LvSfhxffZih q'
vR'ia$-~}es?nhjr'vSvSixnhjm|Liopi}hiffoKdmxiffkmlz|LvSfhxffaih q'?vR'i   H u-   &dyxRiffkmlz|LvSfhxffafhx6vR'i
qhfnhofhanhrmvSfwMnvRlz|nhozoptEnhkmndmvRlzj'q0nJsStesRvSiffwOskmlznhopfhqrmi&sSvSxnvSiqhth  mlzslzs$sR'fjEvSfO"iCiL"iff|LvRlz}hi
lzj -lpvRwMnhj nhjZIhhC'ixRivR'itrmsSindmxRfhyopiffwnvRlz|kmlznhopfhqr'ikmivSiff|LvSfhxElzjfhxkmixvSf
nhkmndmvCvR'ikmlnhopfhqr'isSvSxnvSiqhtfhx&nvSxnhljiffjmermlpxRtsStusSvSiffwO0 v8afrmokiMdfsRsRlpyozihnhjmkfhvRmixs
mn	}hinxRqr'iffki}hf	8ffhheMPlzxsR|ixRqivnho/pMffhheN
 8lpx|y'fDh'	vRmnvvR'ikylznhopfhqr'i
wMnhjmnqhix	snhkmndmvRnvRlzfjk'iff|lzslpfjms\|nhjiwMnhkmifjvR'iynhsRlzs,fhopfu|nhoKiffmnff}ulpfhxff5l/ ihfjvR'i
ynhsRlsGfhZxRiff|Lfhqjmlzfflzj'q8vRynvavR'i|r'xRxRiffjvarmvSvSixnhjm|Li$mnhs~iiffjJwMlzsRryjmk'ixsSvSfefukZhfhxavRynvavR'i|r'xRxRiffjv
r'vSvSixnhjy|LilzsCn|LfhxRxiff|LvRlpfjZPf	Ui}hixffKlpv,lzsC|oziffnx\vRmnv\vR'i0k'iff|lzsRlpfj;vSfvSxnhjmsRix,vR'iO|nhozoUvSfn
ermwMnhjO|rmsSvSfwMix*|nxRiInqhiffjvP|nhjmj'fhvKiwMnhk'i$fjOvR'i$ynhsRls5fhfjmoptJopfu|nho"lj'fhxwMnvRlpfjJiff|nhrmsSi
vR'iJsStesRvSiffw|nhjfhvSiffjxRiff|Lf}hix&xRfwnsRlzjmqopi\ixRxRfhxff  ermsDUiiLud"iff|LvCvRmnv8vRmi6nylzolpvtvSfEi
nyopi,vSf0dmxRiffkylz|LvPvRmiMkmlznhopfhqr'i&fr'vR|Lfw\iMnhs$UiMk'fO'ixRi,lozo|LfjvRlzjer'i,vSfO"i,lzw\dfhxRvRnhjv$i}hiffjlzj
sStusSvSiffwMsKvRynvrmsSiIopfu|nhoZdmxiffkmlz|LvSfhxs5fhxrmjmkmixsSvRnhjmkmlj'q&nhjyk|LfhxRxRiff|LvRlpfj
|Y


zx

] ^a}^ Q _a

Qy]



f fj~xnhsRs$lznhjmilpvRwnhjZ
 l|mnxkc'r'vSvSfjZ-nfflzjKPnhmlzwnhjmkElz|mniffoRiffnxjms
 mnhjmges$vS
fhxkmlzsR|rysRsRlpfjmsUfjO}nxlpfrysKnhsSdiff|LvRs*fhvRmlzs5UfhxRg"
uQ~/Q 

Qy]  Q


P"iffooznuyCpfhxlzjy8)ffhhIUfjmsSvSxry|LvnhopqhimxnuKjEnhjynhoptvRl|nhow\ivR'fukEfhx$kmlznhopfhq6wMnhju
nqhiffwMiffjvm
j  SffR
 Z  / I _ [   L\ [ ] y  a
 Z/ I\ [u ] 	/hh^
 I
 h
  " H"  
 Z    / 
5nqhqlznuDp-5nhsSvRnqj'ixl/&p $nhjmlziffozl/)ffhhClpiffozk  xlznhozsPfhGvR'i, Rv nholznhjE'*Rc  x nhlzj
 lzw\ivRnyopiCcutesSvSiffw~j y	fhSm/ _ R [p}Zh#I _ LzRr+  yhh ]5 !/  
/ z c 
  _%_]Iudmdys e
UxlpiffwMnhj~Gp5'xlpiffkywMnhjZ { Cp*$ozsR'iffjRIGCp5cevSfjmih5 { KffhN    a"
  ZhR  / _ S GnhkmsSUfhxRvRnhjykUxRffhgusyEfjvSixRitE5nhozlpfhxjmlnu
5nvRopivSv


{ ffhu	GEiqnhlzjmkyrm|LvRlpfjZGvSiffsRvlpqvjX 	Z  /I\[u5Zr[e\[My"hh
h<ISM [  RmZ 

5eru5nxRxfozo/ { p'5nxRdiffjvSixff'ffhh)iff|LvSfhxSHnhsSiffkjmnvRr'xnhooznhjmqrmnqhi|nhooxfr'vRlzj'q'& h 
" H"  1Z       h7;hu81;h
Uf'iffj "ffhh-ynhsSv~iLiff|LvRlp}hixrmopiljmkmrm|LvRlpfjmj SffRZ  /I\[u
 h<ISM [  RmZ 

_ a IL\[,y"hh

Uf'iffj" ~ffhh,iffnxjmlj'q6vSxiiffsInhjmkxrmopiffsPlpvRsSivH}nhozr'iffkiffnvRr'xRiffsffIjO   Ly\[
IffLRL",/I8\[' ] L ]$ ffffh//I ]  affyL#Z 


 

*PwMwlz|veCe&puopfjmsSf'  ffhh8j'f	oziffk'qhi|Lfozopiff|LvRlzfjMfhxajmnvRr'xnhoyoznhj'qrynqhisSdfhghiffj
kylznhopfhq8sStusSvSiffwMsff"j 	Z  /P
I \'[ '  S  Rh  <ffI LRL"Ih h [  r+  m/
h _ [ "hZ  
VT!

fi

2Zy222S2-



7M1m



72

mr'xj'gxnhj'h { pmlzkmwMixff',Zffh~jm|Lxiffw\iffjvRnho"xRiffkyrm|LiffkJixRxRfhx5dmxrmjylzj'q'ZjX 	Z  /I
\ [' 5zy\[V8"  pIS,["  RmZ 
fhxljZCphlz||nxkml/&pxlzqv
 h-h< ;ff
{

effhh'fEn	tIiffozd8Gfrqm [


hb  m/h/ 

lpxsR|ixRq' { mpy-lpvRwMnhjZm& { p y ceUixRvRsm-ffhha~xRfsSfukmlz|$|r'iffsKvSfMxiff|LfhqjmlpvRlpfj0ixRxfhxs
6
j  ffG/I8\[' ] HrMh   [  }Zm/h  "L  H"1Z 	 [e 
lpxsR|ixRq' { pGlpvRwnhjZ)C { p)ceUixRvRs)*/hhiffj'ixnhozlzfflzj'qdmxfsSfekylz|Mdmxiffkmlz|LvRlpfj
fhsSdiiff|xRiff|LfhqjylpvRlpfjixRxRfhxsj 	Z  /IO\[uT\[Lh/  h<IS/I
     1
 Z  < Z  	  
 ZY -u K Gzff8 
lpxsR|ixRq' { upu-lpvRwMnhjZu& { p'cuaixRvRsffuZ/h'nGPivSiff|LvRlj'q\wMlzsSxRiff|LfhqjylpvRlpfjmsUnhjmkJ|LfhxS
xiff|LvRlpfjms)lzj&sSdfhghiffj\kmlznhopfhqrmiUsStusSvSiffwMsDxRfwnff5nxRihsRlzvSiffs'j" ff1Z  /I*\[uVh  [e 
h    ff0 h  [  } Zm;  "L  H"1
 Z 
lpxsR|ixRq' { DPpG-lpvRwMnhjZ& { pG ceUixRvRs)5/h'Lk'iffjvRlztulzj'qrysSixC|LfhxRxiff|LvRlpfjms,nhru
vSfwnvRlz|nhozoptlzjsSdfhghiffjkmlnhopfhqr'i\sStusSvSiffwO\j, SffRZ  /IM\[u  ffZ/I\['
CL\ [ ] L  [e  &/ IC\ [u ]$ ffff
 I  h " H"  Z    / 

Ilpx|m'fM/h'	e|Lfw\dynxlzsSfjfhu|oznhsRsRlp|nvRlpfjvSiff|mjmlzer'iffsZfhxvR'ianhr'vSfwMnvRlz|GkmivSiff|LvRlpfj8fh
ixxRfhx~|LfhxRxRiff|LvRlzfjms~lzj\ermwMnhj'|Lfw\dyr'vSixGkmlnhopfhqr'iffsjQ ff1Z  {
I \u[ 'CL\[ ] 
 L
]   	  e[    ]   HW$LZ        
ff0
Z /C
I \u[ - ]')
xnhyw\ixfffip'ceUixRvRsep  'iffrmjmihpeiiqhiffos'ffhhnGxRfhopiffw sSdfhvSvRlzj'qClzj\rywMnhju
wnh|mlzjmiIlzjvSixnh|LvRlpfjZGj6 Sff   S H R T
[ ff 
xnhyw\ixffp$ceUixRvRs$p  m iffrmj'ihPpiiqhiffozs8ffhh~xRfsSfukmlz||LfhxRxRiffoznvSiffsOfh
kylzsR|LfjuyxwMnvRlpfjmsj  #]  	 [e  hCyLSff\8p}Z  5C    ff      
nhjmqhgelzok'ihKpPnhopghixffKCpxlpqv { pfhxljZCplpvRwnhjZ*&ffhhPr'vSfwnvRlz|
dyxRiffkmlz|LvRlpfjfh*dmxRfhopiffwMnvRlz|6rmwnhju|Lfw\dyr'vSix,kmlznhozfhqr'iffsCljPf	 nfftIPiffopd;GfrqEj
 	
 Z  / I*\ ['aR  	 [u   ] Hr Mh/ h R [  } Zm/"    H 

 Z ce]$   z 
i}hfI& Cuffhhy5ynxnh|LvSixlpfflzjmqnhjmkIxiff|Lfhqjmlpfflzj'qsSdfhghiffj8|LfhxRxiff|LvRlpfjmsDlzj8ermwMnhju|LfwMdyr'vSix
kylznhopfhqr'ihUS
j  SffR
 Z  / IC\ [u  \ [ ] m  ff1
 ZO/ IC\ [u ]$ ffffh/{ I  r   H 
/h  
 Z    / 'dmdr ;h ue
lzvRwMnhjZm& { pPlpxsR|ixRq' { ypceaixvRsy-/hhKGxRiffkml|LvRlzj'q\nhr'vSfwMnvRlz|CsSdiiff|Oxiff|Lfhq
jylpvRlpfjd"ixfhxwnhjm|Li6rmslzj'qdyxRfsSfukmlz|M|r'iffsffj SffRZ  {IJ\[u    Z{I0\['
CL\ [ ] L  [e  &/ IC\ [u ]$ ffff
 I  h " H"  Z    / 
lzvRwMnhjZ& { pZ nhjZc"/hhGxRiffkml|LvRlzj'qnhjmknhkmndmvRlj'qvSfJdffhx$sSdiiff|ExRiff|LfhqjmlpvRlzfjElzjn
sRd"fhghiffjkmlznhopfhqr'i*sRtesSvSiffwyjV Sff/IP\[u  yy\[\8"  h<IS$h ]  aff
L# Z c]]']   Gzff 
lzvRwMnhjZuC { pnhopghix	m'Cp' iffnxjmsu { Zffhh)PrmvSfwMnvRlz|$k'ivSiff|LvRlpfj0fhdfefhxUsRd"iiff|
xiff|LfhqjmlpvRlpfj\nv)vR'i*kylznhopfhqr'i5opi}hiffo/'jQ SffRZ  /I*\[u _ [  hLy\[ ] y  ff1Z
{ I8\ [u ] 	/hh/ I  r   Hh/  Z     'dmd=;1;uffe
VT

&

fi>

72

> 9?f7A@d.22

l||nxkml/~&pGfhxlzjC*/hh;cedfhghiffjoznhj'qrmnqhiOnhkmndyvRnvRlpfj;f	}hixMvRlzwMi6nhjmksSvRnvSilzj;n
jynvRr'xnhoGsSdfhghiffjkylznhopfhqOsStusSvSiffwO R _ S  ff/   h 
]  /  Sff  Z 
[  
; u
 	
cunhjmkmixwMnhjZGCp5cevRrmxwO { p~k'iffj$st*paUf}hiffsKGpUUxiffw\ixs~CffhhG}nhozrmnvRlzfjfh
vRmikmrmvR|vSxnhlzj?vRlzw\ivRnyopilzj'fhxwMnvRlzfjsStusSvSiffw k'i}hiffopfhdiffklzjvRmi'*RcdmxRf Siff|Lv j
LSff\ 
 y _  [h} Z+
 IL _ pr +  mh/ ]5 !/h/ zc  _%_1]dydu8
he
ceiffj'iLc"peZr'ihCp-folpxfjml/ { pnf'u$pivR'ixlzj'qhvSfjZ~pfukmk'iffnhrZ&poznhsRs { 'ffhh
 'iMdmxRiffolzwMlzjmnxtk'i}hiffopfhdywMiffjvIfh*nkmlzsSdyonfftuopiffsRsa5$c:$csStesRvSiffwO6j ]  ]h   
 
 Z  p Z _ R [p} Zh
  	 [e 
cu'xlpixRq'ep)nhk'ihapa~xlz|LihGD*ffhhrmwMnhjuwMnh|mlzj'i6dmxRfhyoziffwsSfoz}elzjmqErmsRlj'qsSdf
ghiffjonhj'qrmnqhi,sStesRvSiffwMs\HcuDcmmnh|LvSfhxs8n"iff|LvRlzjmqJdixRfhxwMnhjy|LiCnhjmkrmsSix$sRnvRlzsRnh|LvRlpfjj
 	
 Z  / I8\ [u  ]  ] h R [E)
    	 [u ydyd' e'
ceUixRvRsKp*lpvRwMnhj5& { p*lpxsR|ixRq' { ~/hh UfhxxRiff|LvRlpfjms6lzjsSdfhghiffjkylznhopfhqr'i
sRtesSvSiffws
j  	Z  /I$\[u\[yLh/  h<IS&/I h   L  hZ  <Ze   
 5 Gffff 
  
 ZS -u*
nhopghixffZ8pmxRfw\ixff { ZpnxnfftnhjmnhjDc")ffhhCiffnxjmlzj'qJfhdmvRlzwMnhoDkmlznhozfhqr'i&sRvSxnvSiL
qlziffs8|nhsSisSvRryk'tEfhKnsRd"fhghiffjkmlznhopfhqr'iMnqhiffjv8fhxIiffwMnhlo/\j+ SffRZ  /I\[u  \[
] m  " ZO/ IC\ [u ]$ ffff;/ I  r   Hh/   Z     c&~ RQ ]) ff 
dyd< ; < ;hhe
nhopghixff'Cp18nhwMwOu$8p'-lpvRwMnhjZe& { /hhhn  f	5nxkmsUk'i}hiffopfhdylj'qIqhiffj'ixnhow\fuk'iffozs
fh"rmsRnylozlpvtPlpvRC'
 S
c mj Ch  S  hZ  <Ze$KZh"LZ h /e  )$  
 ff/&    6
 8p} Z        
nhopghixffa8p)-nhj'qhgelozk'ihpxlzqv { pG$fhxlzjZ)Cp~-lpvRwMnhjZ)&5/hhiffnxjmlzjmqvSf
~xRiffkmlz|LvUGxRfhopiffwMnvRlz|$culpvRrmnvRlpfjysGlzjn\cedfhghiffjJlnhopfhqr'i$cutesSvSiffwGedixlw\iffjvRs~lpvR6f
nfftEPiffopdGf	
r hY
j  SffRh
 Z  / I&\ ['Z
 C\ [ ] L
 Z{ I&\ [u ]$ ffff

"








I h  H"  Z  /
nhopghixffG8pG-lpvRwMnhjZ)&pRInhwMwO~D8p~ P"iffooznuDCKffhh'Sc- qhiffjmixnho
xnhw\iUfhxRgfhxi}nhozrynvRlzj'q6sRd"fhghiffjkmlnhopfhqr'iCnqhiffjvRsjY SffRhZ  /I&\['  h\[ ] m  
ff
 Z/ I6\ [u ]$ ffff/ I  r   Hh/h  
 Z    / c])  ]"  GdmdDe8
hu
nhopghixffmCpmxlpqv { py nhj'qhgulzozk'ihe/hhh|	t:sRlzj'q\jmnvRr'xnhoZoznhj'qrmnqhidmxfe|LiffsRslzj'q\nhjmk
kylzsR|Lfr'xsRiMiffnvRrmxRiffs8vSflzk'iffjvRlptrmjyk'ixsSvRnhjmkylzj'q0ixRxRfhxsClzjnEsSdfhghiffjkmlnhopfhqr'isStusSvSiffwOOj
 	
 Z  / I8\ [u   yy\ [6yLh/  < IffLRL", ["  m1
 Z 
ifflzsRsffIc*p8rmozlpghfsSgul/8ffhu	 h "       _ [uh  R q      a
h  S	h\ [eff  Ih   Hh  / c &  SCff c 
  [   m1Z c  R  LL
     KcunhjnvSif'5CyEfhxRqnh
j 8nhr'wnhjmjZ
xlpqvC$/hh 	L#Z    ff/;A8/Z  O<IzMh/UIL 
]  HrMh/ h R[
 R
 Zhmh UaZ&mvR'iffsRlsE:Pjylp}hixsRlpv tfh~kylzjr'xRqZ
VT 3

fiJournal of Artificial Intelligence Research 16 (2002) 135-166

Submitted 7/01; published 2/02

Improving the Eciency of Inductive Logic Programming
Through the Use of Query Packs
hendrik.blockeel@cs.kuleuven.ac.be

Hendrik Blockeel

Katholieke Universiteit Leuven, Department of Computer Science
Celestijnenlaan 200A, B-3001 Leuven, Belgium

luc.dehaspe@pharmadm.com

Luc Dehaspe
PharmaDM, Ambachtenlaan 54D, B-3001 Leuven, Belgium

Bart Demoen
Gerda Janssens
Jan Ramon

bart.demoen@cs.kuleuven.ac.be
gerda.janssens@cs.kuleuven.ac.be
jan.ramon@cs.kuleuven.ac.be

Katholieke Universiteit Leuven, Department of Computer Science
Celestijnenlaan 200A, B-3001 Leuven, Belgium

henk.vandecasteele@pharmadm.com

Henk Vandecasteele

PharmaDM, Ambachtenlaan 54D, B-3001 Leuven, Belgium

Abstract

Inductive logic programming, or relational learning, is a powerful paradigm for machine
learning or data mining. However, in order for ILP to become practically useful, the
eciency of ILP systems must improve substantially. To this end, the notion of a query pack
is introduced: it structures sets of similar queries. Furthermore, a mechanism is described
for executing such query packs. A complexity analysis shows that considerable eciency
improvements can be achieved through the use of this query pack execution mechanism.
This claim is supported by empirical results obtained by incorporating support for query
pack execution in two existing learning systems.
1. Introduction

Many data mining algorithms employ to some extent a generate-and-test approach: large
amounts of partial or complete hypotheses are generated and evaluated during the data
mining process. This evaluation usually involves testing the hypothesis on a large data set,
a process which is typically linear in the size of the data set. Examples of such data mining
algorithms are Apriori (Agrawal et al., 1996), decision tree algorithms (Quinlan, 1993a;
Breiman et al., 1984), algorithms inducing decision rules (Clark & Niblett, 1989), etc.
Even though the search through the hypothesis space is seldom exhaustive in practical
situations, and clever branch-and-bound or greedy search strategies are employed, the number of hypotheses generated and evaluated by these approaches may still be huge. This is
especially true when a complex hypothesis space is used, as is often the case in inductive
logic programming (ILP), where the sheer size of the hypothesis space is an important
contribution to the high computational complexity of most ILP approaches. This computational complexity can be reduced, however, by exploiting the fact that there are many
similarities between hypotheses.

c 2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
Most ILP systems build a hypothesis one clause at a time. This search for a single clause
is what we will be concerned with in the rest of this paper, and so the word \hypothesis"
further on will usually refer to a single clause. The clause search space is typically structured
as a lattice. Because clauses close to one another in the lattice are similar, the computations
involved in evaluating them will be similar as well. In other words, many of the computations
that are performed when evaluating one clause (which boils down to executing a query
consisting of the body of the clause) will have to be performed again when evaluating the
next clause. Storing certain intermediate results during the computation for later use could
be a solution (e.g., tabling as in the XSB Prolog engine, Chen & Warren, 1996), but may be
infeasible in practice because of its memory requirements. It becomes more feasible if the
search is reorganised so that intermediate results are always used shortly after they have
been computed; this can be achieved to some extent by rearranging the computations. The
best way of removing the redundancy, however, seems to be to re-implement the execution
strategy of the queries in such a way that as much computation as possible is effectively
shared.
In this paper we discuss a strategy for executing sets of queries, organised in so-called
query packs, that avoids the redundant computations. The strategy is presented as an adaptation of the standard Prolog execution mechanism. The adapted execution mechanism
has been implemented in ilProlog, a Prolog system dedicated to inductive logic programming. Several inductive logic programming systems have been re-implemented to make use
of this dedicated engine, and using these new implementations we obtained experimental
results showing in some cases a speed-up of more than an order of magnitude. Thus, our
work significantly contributes to the applicability of inductive logic programming to real
world data mining tasks. In addition, we believe it may contribute to the state of the art in
query optimisation in relational databases. Indeed, in the latter field there has been a lot of
work on the optimisation of individual queries or relatively small sets of queries, but much
less on the optimisation of large groups of very similar queries, which understandably did
not get much attention before the advent of data mining. Optimisation of groups of queries
for relational databases seems an interesting research area now, and we believe techniques
similar to the ones proposed here might be relevant in that area.
The remainder of this paper is structured as follows. In Section 2 we precisely describe
the ILP problem setting in which this work is set. In Section 3 we define the notion of a
query pack and indicate how it would be executed by a standard Prolog interpreter and what
computational redundancy this causes. We further describe an execution mechanism for
query packs that makes it possible to avoid the redundant computations that would arise if
all queries in the pack were run separately, and show how it can be implemented by making a
few small but significant extensions to the WAM, the standard Prolog execution mechanism.
In Section 4 we describe how the query pack execution strategy can be incorporated in two
existing inductive logic programming algorithms (Tilde and Warmr). In Section 5 we
present experimental results that illustrate the speed-up that these systems achieve by
using the query pack execution mechanism. In Section 6 we discuss related work and in
Section 7 we present conclusions and some directions for future work.

136

fiImproving the Efficiency of ILP through Query Packs
2. Inductive Logic Programming

Inductive logic programming (Muggleton & De Raedt, 1994) is situated in the intersection
of machine learning or data mining on the one hand, and logic programming on the other
hand. It shares with the former fields the goal of finding patterns in data, patterns that can
be used to build predictive models or to gain insight in the data. With logic programming
it shares the use of clausal first order logic as a representation language for both data
and hypotheses. In the remainder of this text we will use some basic notions from logic
programming, such as literals, conjunctive queries, and variable substitutions. We will use
Prolog notation throughout the paper. For an introduction to Prolog and logic programming
see Bratko (1990).
Inductive logic programming can be used for many different purposes, and the problem
statements found in ILP papers consequently vary. In this article we consider the so-called
learning from interpretations setting (De Raedt & Dzeroski, 1994; De Raedt, 1997). It
has been argued elsewhere that this setting, while slightly less powerful than the standard
ILP setting (it has problems with, e.g., learning recursive predicates), is sucient for most
practical purposes and scales up better (Blockeel et al., 1999).
We formulate the learning task in such a way that it covers a number of different problem
statements. More specifically, we consider the problem of detecting for a set of conjunctive
queries for which instantiations of certain variables each query succeeds. These variables
are called key variables, and a grounding substitution for them is called a key instantiation.
The intuition is that an example in the learning task is uniquely identified by a single key
instantiation.
The link with ILP systems that learn clauses is then as follows. The search performed
by an ILP system is directed by regularly evaluating candidate clauses. Let us denote such
a candidate clause by Head(X )
Body (X; Y ) where X represents a vector of variables
appearing in the head of the clause and Y represents additional variables that occur in the
body. We assume that the head is a single literal and that a list of examples is given, where
each example is of the form Head(X ) with  a substitution that grounds X . Examples
may be labelled (e.g., as positive or negative), but this is not essential in our setting. While
an example can be represented as a fact Head(X ) when learning definite Horn clauses, we
can also consider it just a tuple X. Both notations will be used in this paper.
Intuitively, when positive and negative examples are given, one wants to find a clause
that covers as many positive examples as possible, while covering few or no negatives.
Whether a single example Head(X ) is covered by the clause or not can be determined
by running the query ? Body(X; Y ). In other words, evaluating a clause boils down to
running a number of queries consisting of the body of the clause. For simplicity of notation,
we will often denote a conjunctive query by just the conjunction (without the ? symbol).
In some less typical ILP settings, the ILP algorithm does not search for Horn clauses
but rather for general clauses, e.g., Claudien (De Raedt & Dehaspe, 1997) or for frequent
patterns that can be expressed as conjunctive queries, e.g., Warmr(Dehaspe & Toivonen,
1999). These settings can be handled by our approach as well: all that is needed is a mapping
from hypotheses to queries that allow to evaluate these hypotheses. Such a mapping is
defined by De Raedt and Dehaspe (1997) for Claudien; for Warmr it is trivial.

137

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
Given a set of queries S and a set of examples E , the main task is to determine which
queries Q 2 S cover which examples e 2 E . We formalise this using the notion of a result
set:

Definition 1 (Result set) The result set of a set of queries S in a deductive database D
for key K and example set E , is
RS (S; K; D; E )

= f(K; i)jQi 2 S and K 2 E and Qi  succeeds in Dg

Similar to the learning from interpretations setting defined in (De Raedt, 1997), the
problem setting can now be stated as:

Given: a set of conjunctive queries S , a deductive database D, a tuple K of variables
that occur in each query in S, and an example set E
Find: the result set RS (S; K; D; E ); i.e., find for each query Q in S those ground
instantiations  of K for which K 2 E and Q succeeds in D.
Example 1 Assume an ILP system learning a definition for grandfather/2 wants to evaluate the following hypotheses:

grandfather(X,Y) :- parent(X,Z), parent(Z,Y), male(X).
grandfather(X,Y) :- parent(X,Z), parent(Z,Y), female(X).

Examples are of the form grandfather(gf ,gc) where gf and gc are constants; hence
each example is uniquely identified by a ground substitution of the tuple (X; Y ). So in the
above problem setting the set of Prolog queries S equals f(?- parent(X,Z), parent(Z,Y),
male(X)), (?- parent(X,Z), parent(Z,Y), female(X))g and the key K equals (X; Y ).
Given a query Qi 2 S , finding all tuples (x; y) for which ((x; y); i) 2 R (with R the result
set as defined above) is equivalent to finding which of the grandfather(x,y) facts in the
example set are predicted by the clause grandfather(X,Y) :- Qi .

The generality of our problem setting follows from the fact that once it is known which
queries succeed for which examples, the statistics and heuristics that typical ILP systems
use can be readily obtained from this. A few examples:






discovery of frequent patterns (Dehaspe & Toivonen, 1999): for each query Qi the
number of key instantiations for which it succeeds just needs to be counted, i.e.,
f req (Qi ) = jfK j(K; i) 2 Rgj with R the result set.
induction of Horn clauses (Muggleton, 1995; Quinlan, 1993b): the accuracy of a
clause H :- Qi (defined as the number of examples for which body and head hold,
divided by the number of examples for which the body holds) can be computed as
jfKj(K;i)2R^Dj=Hgj with R the result set.
jfKj(K;i)2Rgj
induction of first order classification or regression trees (Kramer, 1996; Blockeel &
De Raedt, 1998; Blockeel et al., 1998): the class entropy or variance of the examples
covered (or not covered) by a query can be computed from the probability distribution
of the target variable; computing this distribution involves simple counts similar to
the ones above.

138

fiImproving the Efficiency of ILP through Query Packs
After transforming the grandfather/2 clauses into
grandfather((X,Y)),I) :- parent(X,Z), parent(Z,Y), male(X), I = 1.
grandfather((X,Y)),I) :- parent(X,Z), parent(Z,Y), female(X), I = 2.

the result set can clearly be computed by collecting for all grounding 's where K 2 E the
answers to the query ?- grandfather(K,I) . In Section 3 the queries will have a literal
I = i at the end or another goal which by side-effects results in collecting the result set.
In practice, it is natural to compute the result set using a double loop: one over examples
and one over queries and one has the choice as to which is the outer loop. Both the \examples
in outer loop" and the \queries in outer loop" have been used in data mining systems; in
the context of decision trees, see for instance Quinlan (1993a) and Mehta et al. (1996). We
shall see further that the redundancy removal approach we propose uses the \examples in
outer loop" strategy. In both approaches however, given a query and a key instantiation, we
are interested only in whether the query succeeds for that key instantiation. This implies
that after a particular query has succeeded on an example, its execution can be stopped.
In other words: computing the result set defined above boils down to evaluating each
query on each example, where we are only interested in the existence of success for each such
evaluation. Computing more than one solution for one query on one example is unnecessary.
3. Query Packs

For simplicity, we make abstraction of the existence of keys in the following examples. What
is relevant here, is that for each query we are only interested in whether it succeeds or not,
not in finding all answer substitutions.
Given the following set of queries
p(X),
p(X),
p(X),
p(X),
p(X),

I = 1.
q(X,a),
q(X,b),
q(X,Y),
q(X,Y),

I = 2.
I = 3.
t(X), I = 4.
t(X), r(Y,1), I = 5.

we can choose to evaluate them separately. Since we are only interested in one { the first {
success for each query, we would evaluate in Prolog the queries
once((p(X),
once((p(X),
once((p(X),
once((p(X),
once((p(X),

I = 1)).
q(X,a), I = 2)).
q(X,b), I = 3)).
q(X,Y), t(X), I = 4)).
q(X,Y), t(X), r(Y,1), I = 5)).

The wrapper once/1 is a pruning primitive and prevents the unnecessary search for more
solutions. Its definition in Prolog is simply
once(Goal) :- call(Goal), !.

139

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
An alternative way to evaluate the queries consists in merging them into one (nested)
disjunction as in:
p(X), (I=1

;

q(X,a), I=2

;

q(X,b), I=3

;

q(X,Y), t(X), (I=4

;

r(Y,1), I=5)).

The set of queries can now be evaluated as a whole: the success of one branch in the
disjunctive query corresponds to the success of the corresponding individual query.
Compared to the evaluation of the individual queries, the disjunctive query has both an
advantage and a disadvantage:
+ all the queries have the same prefix p(X), which is evaluated once in each individual
query, while in the disjunctive query, the goal p(X) is evaluated only once; depending
on the evaluation cost of p/1, this can lead to arbitrary performance gains.
the usual Prolog pruning primitives are not powerful enough to prevent all the unnecessary backtracking after a branch in the disjunctive query has succeeded; this is
explained further in Example 2.

Example 2 In this example the literals

contribute to the discussion:

= i have been left out, because they do not

I

p(X), q(X).
p(X), r(X).

Evaluating these queries separately means evaluating
once((p(X), q(X))).
once((p(X), r(X))).

or equivalently
p(X), q(X), !.
p(X), r(X), !.

The corresponding disjunctive query is
p(X), (q(X) ; r(X)).

We can now try to place a pruning primitive in the disjunctive query: !/0 at the end of
each branch results in
p(X), (q(X), ! ; r(X), !)

The scope of the first cut is clearly too large: after the goal q(X) has succeeded, the cut
will prevent entering the second branch. It means that adding the cut in the disjunctive
query leads to a wrong result.
Using once/1 in the disjunctive query results in
p(X), (once(q(X)) ; once(r(X)))

140

fiImproving the Efficiency of ILP through Query Packs
This results in a correct query. However, both branches are still executed for every
binding that the goal p(X) produces, even if both branches have succeeded already.

The combination of the advantage of the disjunctive query with the advantage of the
individual query with pruning (once or cut) results in the notion of the query pack. Syntactically, a query pack looks like a disjunctive query where the ; control construct is
replaced by a new control construct denoted by or. So the query pack corresponding to the
disjunctive query above is
p(X), (I=1

or

q(X,a), I=2

or

q(X,b), I=3

or

q(X,Y), t(X), (I=4

or

r(Y,1), I=5))

This query pack can be represented as the tree in Figure 1. For a query pack Q such a
tree has literals or conjunctions of literals in the nodes. Each path from the root to a leaf
node represents a conjunctive query Q which is a member of Q, denoted Q 2 Q. The or
construct is implicit in the branching points.
p(X)
I=1

q(X,a),
I=2

q(X,b),
I=3

q(X,c),
I=4
I=5

q(X,Y), t(X)
r(Y,1),
I=6

r(Y,2),
I=7

Figure 1: A query pack.
The intended procedural behaviour of the or construct is that once a branch has succeeded, it is effectively pruned away from the pack during the evaluation of the query pack
on the current example. This pruning must be recursive, i.e., when all branches in a subtree
of the query pack have succeeded, the whole subtree must be pruned. Evaluation of the
query pack then terminates when all subtrees have been pruned or all of the remaining
queries fail for the example.
The semantics of the or construct and its ecient implementation is the subject of the
rest of this section. It should however be clear already now that in the case that all the
answers of each query are needed, pruning cannot be performed and the disjunctive query
is already sucient, i.e., query packs are useful when a single success per query suces.

3.1 Ecient Execution of Query Packs
In Section 3.1.2, a meta-interpreter is given that defines the behaviour of query packs. In
practice this meta-interpreter is not useful, because in many cases the meta-interpreter itself
causes more overhead than the use of query packs can compensate for. Indeed, previously
reported results (Demoen et al., 1999; Blockeel, 1998) indicate that the overhead involved
in a high-level Prolog implementation destroys the eciency gain obtained by redundancy
reduction. Moreover as discussed in Section 3.1.2, the meta-interpreter does not have the
desired time-complexity. This shows that the desired procedural semantics of or can be

141

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
implemented in Prolog itself, but not with the desired performance because Prolog lacks
the appropriate primitives.
The conclusion is that changes are needed at the level of the Prolog engine itself. This
requires an extension of the WAM (Warren Abstract Machine) which is the underlying
abstract machine for most Prolog implementations. The extended WAM provides the or
operator as discussed above: it permanently removes branches from the pack that do not
need to be investigated anymore. This extended WAM has become the basis of a new Prolog
engine dedicated to inductive logic programming, called ilProlog. This section continues
with the introduction of some basic terminology for query packs and explains at a high level
how query pack execution works. Next our meta-interpreter for the query pack execution
is given and finally the changes needed for the WAM are clarified.
3.1.1 Principles of Query Packs (Execution)

Before we discuss query pack execution in detail, note the following two points: (1) during
the pack execution, the pruning of a branch must survive backtracking; (2) when executing
a pack we are not interested in any variable instantiations, just in whether a member of the
pack succeeds or not. In our previous description we were interested in the binding to the
variable I. Since each branch can bind I to only one value { the query number { we collect
these values in practice by a side effect denoted in Section 3.2 by report success.
The starting point for the query pack execution mechanism is the usual Prolog execution
of a query Q given a Prolog program P . By backtracking Prolog will generate all the
solutions for Q by giving the possible instantiations  such that Q succeeds in P .
A query pack consists of a conjunction of literals and a set of alternatives, where each
alternative is again a query pack. Note that leaves are query packs with an empty set of
alternatives. For each query pack Q, conj (Q) denotes the conjunction and children(Q)
denotes the set of alternatives. A set of queries is then represented by a so-called root query
pack. For every query pack Q, there is a path of query packs starting from the root query
pack Qroot and ending at the query pack itself, namely < Qroot , Q1 , ..., Qn , Q >. The
query packs in this path are the predecessors of Q. Every query pack has a set of dependent
queries, dependent queries(Q). Let < Qroot , Qi1 , ..., Qin , Q > be the path to Q, then
dependent queries(Q) = fconj (Qroot ) ^ conj (Qi1 ) ^ : : : ^ conj (Qin ) ^ conj (Q) ^ conj (Qj1 ) ^
: : : ^ conj (Qjm ) ^ conj (Ql ) j < Q; Qj1 , ..., Qjm , Ql > is a path from Q to a leaf Ql g. Note
that dependent queries(Qroot ) are actually the members of the query pack as described
earlier.

Qroot is the root of the tree. conj (Qroot ) is
Qroot ) contains the 4 query packs which correspond to the trees

Example 3 For the query pack in Figure 1,
p(X ). The set children(

rooted at the 4 sons of the root of the tree. Suppose that these query packs are named (from
left to right) Q1 , Q2 , Q3 , and Q4 . Then conj (Q2 ) equals (q(X; a); I = 2), children(Q2 )
equals the empty set, conj (Q4 ) equals (q(X; Y ); t(X )), and dependent queries(Q4 ) equals
f(p(X ); q(X; Y ); t(X ); I = 4), (p(X ); q(X; Y ); t(X ); r(Y; 1); I = 5)g.

Execution of a root query pack Qroot aims at finding out which queries of the set
dependent queries(Qroot ) succeed. If a query pack is executed as if the ors were usual
disjunctions, backtracking occurs over queries that have already succeeded and too many

142

fiImproving the Efficiency of ILP through Query Packs
0
1
2
3
4
5
6
7
8
9
10
11

execute qp( pack Q, substitution ) f
while (  next solution( conj (Q))

f

for each Qchild in children(Q) do

f
g

g

if ( execute qp( Qchild , ) == success)
children(Q)
children(Q) n fQchild g

if ( children(Q) is an empty set) return(success)

return(fail)

g

Figure 2: The query pack execution algorithm.
successes are detected. To avoid this, it should be the case that as soon as a query succeeds,
the corresponding part of the query pack should no longer be considered during backtracking. Our approach realises this by reporting success of queries (and of query packs) to
predecessors in the query pack. A (non-root) query pack Q can be safely removed if all the
queries that depend on it (i.e., all the queries in dependent queries(Q)) succeeded once.
For a leaf Q (empty set of children), success of conj (Q) is sucient to remove it. For a
non-leaf Q, we wait until all the dependent queries report success or equivalently until all
the query packs in children(Q) report success.
At the start of the evaluation of a root query pack, the set of children for every query
pack in it contains all the alternatives in the given query pack. During the execution, query
packs can be removed from children sets and thus the values of the children(Q) change
accordingly. When due to backtracking a query pack is executed again, it might be the case
that fewer alternatives have to be considered.
The execution of a query pack Q is defined by the algorithm execute qp(Q; ) (Figure
2) which imposes additional control on the usual Prolog execution.
The usual Prolog execution and backtracking behaviour is modelled by the while loop
(line 1) which generates all possible solutions  for the conjunction in the query pack. If
no more solutions are found, fail is returned and backtracking will occur at the level of the
calling query pack.
The additional control manages the children(Q). For each solution , the necessary
children of Q will be executed. It is important to notice that the initial set of children of a
query pack is changed destructively during the execution of this algorithm. Firstly, when a
leaf is reached, success is returned (line 8) and the corresponding child is removed from the
query pack (line 6). Secondly, when a query pack that initially had several children, finally
ends up with an empty set of children (line 6), also this query pack is removed (line 8).
The fact that children are destructively removed, implies that when due to backtracking
the same query pack is executed again for a different , not all of the alternatives that
were initially there, have to be executed any more. Moreover, by returning success the

143

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
a qp(1)
ch(1)

ch(3)
ch(2)

b qp(2)
ch(1)

f

q(4)

g qp(3)
ch(1)

ch(3)
ch(2)

c q(1)

d q(2)

ch(3)
ch(2)

e q(3)

h q(5)

i q(6)

j

q(7)

Figure 3: Query pack numbers qp(i), Query numbers q(i) and Child numbers ch(i) in our
example.
backtracking over the current query pack conjunction conj (Q) is stopped: all branches
have reported success.
3.1.2 A Meta-interpreter for Query Packs

The first implementation of the query pack execution algorithm is the meta-interpreter
meta execute qp(Q). The meta-interpreter uses the following labelling in its representation
of a query pack:

 Query pack number All the non-leaf query packs in the tree are numbered, depth
first, from left to right (qp(i)).

 Query number Each leaf is numbered, from left to right. If the original queries were
numbered sequentially, then the numbers at the leaves correspond with these (q(i)).

 Child number For each non-leaf query pack with N children, all children are numbered
from 1 up to N sequentially (ch(i)).

Consider the query pack a, (b, (c or d or e) or f or g, (h or i or j)). Note that the
atoms in the example could in general be arbitrary conjunctions of non-ground terms. Its
labelling is shown in Figure 3.
A labelled query pack Q is then represented as a Prolog term as follows (with Qf the
father of Q):



A leaf

Q is represented by the term (c; leaf (qpnbf; chnb; qnb)) with c the conj (Q),
the query pack number of Qf , chnb the child number of Q w.r.t. Qf , and qnb
the query number of Q.



A non-leaf Q is represented by the term (c; or(cs; qpnbf; qpnb; chnb; totcs) with c the
conj (Q), cs the list children(Q), qpnbf the query pack number of Qf , qpnb the query
pack number of Q, chnb the child number of Q w.r.t. Qf , and totcs the total number
of children(Q)). The query pack number of the father of the root query pack is
assumed to be zero.

qpnbf

144

fiImproving the Efficiency of ILP through Query Packs
The example of Figure 3 has the following representation (as a Prolog term):
(a, or([(b,or([(c,leaf(2,1,1)),(d,leaf(2,2,2)),(e,leaf(2,3,3))],1,2,1,3)),
(f,leaf(1,2,4)),
(g,or([(h,leaf(3,1,5)),(i,leaf(3,2,6)),(j,leaf(3,3,7))],1,3,3,3))],
0,1,1,3))

During the execution of the meta-interpreter, solved/2 facts are asserted. Each fact
solved(qpnb, chnb) denotes that the child with number chnb from query pack with number

has succeeded. Such facts are asserted when reaching a leaf and also when all children
of a query pack have succeeded. The meta-interpreter only executes children for which no
solved/2 fact has been asserted.
Note that the time-complexity of this meta-interpreter is not yet as desired. Execution
of a query pack will always be dependent on the number of original children, instead of the
number of remaining (as yet unsuccessful) children.
qpnb

run QueryPack(Q) :preprocess(Q, Qlabeled, 0, 1, 1, 1, , ),
% The code for preprocessing is given in Appendix A
retractall(solved( , )),
meta execute qp(Qlabeled),
solved(0, ), !.
meta execute qp((A,B)) :- !,
call(A),
meta execute qp(B).
meta execute qp(or(Cs, QpNbF, QpNb, ChildNb, TotCs)) :!, % 'or' corresponds to a non-leaf query pack
handlechildren(Cs, QpNb, 1),
all solved(QpNb, 0, TotCs),
assert(solved(QpNbF,ChildNb)).
meta execute qp(leaf(QpNbF, ChildNb , QueryNb)) :!, % 'leaf' corresponds to the end of a query
write(succeed(QueryNb)), nl,
assert(solved(QpNbF,ChildNb)).
handlechildren([], , ).
handlechildren([C| ], QpNb, ChildNb) :not(solved(QpNb,ChildNb)),
once(meta execute qp(C)), fail.
handlechildren([ |Cs], QpNb, ChildNb) :ChildNb1 is ChildNb + 1,
handlechildren(Cs, QpNb, ChildNb1).
all solved(QpNb, ChildNb, TotCs) :(ChildNb = TotCs -> true
;
ChildNb1 is ChildNb + 1,
solved(QpNb, ChildNb1),
all solved(QpNb, ChildNb1, TotCs)
).

145

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
3.1.3 WAM Extensions

To fully exploit the potential of a query pack (shared computation and avoidance of unnecessary backtracking) changes have to be made at the level of the Prolog engine itself. The
explanation assumes a WAM-based Prolog engine (At-Kaci, 1991) but a short explanation
of the execution of disjunction in Prolog is given first, so that it becomes more easy to see
what was newly introduced in the WAM.
Assume that the body of a clause to be executed is a, (b,c ; d ; e). Assume also that
all predicates have several clauses. At the moment that execution has reached the first
clause of c, the choice point stack looks like Figure 4(a): there are choice points for the
activation of a, the disjunction itself, b and c. The choice points are linked together so that
backtracking can easily pop the top most one. Each choice point contains a pointer to the
next alternative to be tried: only for the disjunction choice point, this alternative pointer
is shown. It points to the beginning of the second branch of the disjunction. After all
alternatives for b and c have been exhausted, this second branch is entered and d becomes
active: this is the situation shown in Figure 4(b). At that point, the alternative of the
disjunction choice point refers to the last alternative branch of the disjunction. Finally,
once e is entered, the disjunction choice point is already popped.
a, (b, c ; d ; e)

a, (b, c ; d ; e)

a, (b, c ; d ; e)

a

a

a

;

;

e

b

d

c

(a) Choice points just
after entering c.

(b) Choice points just
after entering d.

(c) Choice points just
after entering e.

Figure 4: Illustration of execution of disjunction in the WAM.
When the goal a produces a new solution, all branches of the disjunction must be tried
again. It is exactly this we want to avoid for query packs: a branch that has succeeded once,
should never be re-entered. We therefore adapt the disjunction choice point to become an
or-choice point which is set up to point into a data structure that contains references to
each alternative in the or disjunction. This data structure is named the pack table. Figure
5(a) shows the state of the execution when it has reached c: it is similar to Figure 4(a). The
or-choice point now contains the information that the first branch is being executed. As the
execution proceeds, there are two possibilities: either this first branch succeeds or it fails.
We describe the failing situation for the first branch and explain what happens on success of

146

fiImproving the Efficiency of ILP through Query Packs
the second branch. If the first branch has no solution, backtracking updates the alternative
in the or-choice point, to point to the next branch in the pack table. The situation after
the second branch is entered is shown in 5(b) and is again similar to 4(b). Suppose now
that the branch with the goal d succeeds: the entry in the pack table with or-alternatives
is now adapted by erasing the second alternative branch, backtracking occurs, and the next
alternative branch of the or-choice point is taken. This is shown in 5(c).
When a produces a new solution and the or-disjunction is entered again, the pack table
does no longer contain the second alternative branch and it is never re-entered. The pack
table is actually arranged in such a way that entries are really removed instead of just erased
so that they cause no overhead later.
a, (b, c or d or e)

a, (b, c or d or e)

a, (b, c or d or e)

a

a

a

or

or

or

b

d

e

c

(a) The choice points just
after entering c.

(b) The choice points just
after entering d (the first
branch did not succeed).

(c) The choice points just
after entering e (d succeeded).

Figure 5: Illustration of execution of pack disjunction on the WAM.
Two more issues must be explained: first, the pack table with alternatives must be
constructed at runtime every time the query pack is entered for evaluation. This is done by
emitting the necessary instructions in the beginning of the code for the query pack. As an
example, we show the code for the query pack a, (b,c or d or e) in Figure 6.
Finally, in the example it is clear that at the moment that all alternatives of an ordisjunction have succeeded, a can stop producing more solutions. So the computation can
be stopped. In general - with nested query packs - it means that one pack table entry of
the next higher or-node can be erased and this in a recursive way. The recursive removal
of entries from the pack tables, is done by the instruction query pack prune.
We have implemented this schema in ilProlog. Section 5 presents some measurements
in ilProlog.

3.2 Using Query Packs
Figure 7 shows an algorithm that makes use of the pack execution mechanism to compute
the result set R as defined in our problem statement. The set S of queries is here typically

147

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
construct pack table @1, @2, @3
call a
query pack try
@1: call b
call c
query pack prune
@2: call d
query pack prune
@3: call e
query pack prune

Figure 6: Abstract machine code for a, (b,c or d or e) .
the set of all refinements of a given query, i.e., it does not correspond to the whole hypothesis
space. From a query pack Q containing all queries in S , a derived pack Q0 is constructed
by adding a report success/2 literal to each leaf of the pack; the (procedural) task of
report success(K,i) is simply to add (K; i) to the result set R. Obviously a specific
ILP system not interested in the result set itself could provide its own report success/2
predicate and thus avoid the overhead of explicitly building the result set.1
1 evaluate(set of examples E , pack Q, key K ) f
2
Q0 Q;
3
q
1;
4
for each leaf of Q0 do f
5
add report success(K, q) to the right of the conjunction in the leaf
6
increment q
7
g
8
C
(evaluate pack(K ) :- Q0 );
9
compile and load(C);
10
for each example e in E do f
11
evaluate pack(e);
12
g
13 g
Figure 7: Using query packs to compute the result set.
Note that the algorithm in Figure 7 follows the strategy of running all queries for each
single example before moving on to the next example: this could be called the \examples in
outer loop" strategy, as opposed to the \queries in outer loop" strategy used by most ILP
1. In our current implementation the result set is implemented as a bit-matrix indexed on queries and
examples. This implementation is practically feasible (on typical computers at the time of writing) even
when the number of queries in the pack multiplied by the number of examples is up to a billion, a bound
which holds for most current ILP applications.

148

fiImproving the Efficiency of ILP through Query Packs
systems. The \examples in outer loop" strategy has important advantages when processing
large data sets, mainly due to the ability to process them eciently without having all data
in main memory at the same time (Mehta et al., 1996; Blockeel et al., 1999).

3.3 Computational Complexity
We estimate the speedup factor that can be achieved using query pack execution in two
steps: first we consider one-level packs, then we extend the results towards deeper packs.
Lower and upper bounds on the speedup factor that can be achieved by executing a
one-level pack instead of separate queries can be obtained as follows. For a pack containing
n queries qi = (a; bi ), let Ti be the time needed to compute the first answer substitution of
qi if there are any, or to obtain failure otherwise. Let ti be the part of Ti spent within a
and t0i the part of Ti spent in bi . Then Ts = i (ti + t0i ) and Tp = max(ti ) + i t0i with Ts
representing the total time needed for executing all queries separately and Tp the total time
needed for executing the pack. Introducing c = i ti = i t0i , which roughly represents the
ratio of the computational complexity in the shared part over that in the non-shared part,
we have
0
c+1
Ts
i ti +
i ti
=
= maxi ti
(1)
0
Tp
maxi ti + i ti
+1
t0

P

P

P

P P

P
P

P

i i

Now defining K as the ratio of the maximal ti over the average ti , i.e.

we can rewrite Equation (1) as

Since

P

i ti
n

Pmaxt =nt
i i

K

=

Ts
Tp

=

i i

c+1

K
nc

(2)

+1

 max ti  Pi ti we know 1  K  n, which leads to the following bounds:
1

Ts
Tp



c+1

c
n

+1

< min(c + 1; n)

(3)

Thus the speedup factor is bounded from above by the branching factor n and by the
ratio c of computational complexity in the shared part over the computational complexity
of the non-shared part; and a maximal speedup can be attained when max ti ' ti =n (or,
K ' 1), in other words when the ti for all queries are approximately equal.
For multi-level packs, we can estimate the eciency gain as follows. Given a query qi ,
let Ti be defined as above (the total time for finding 1 answer to qi or obtaining failure).
Instead of ti and t0i , we now define ti;l as the time spent on level l of the pack when solving qi ;
counting the root as level 0 and denoting the depth of the pack with d we have Ti = dl=0 ti;l .
Further define Ti;l as the time spent on level l or deeper: Ti;l = dj=l ti;j with d the depth
of the pack. (Thus Ti = Ti;0 .). We will assume a constant branching factor b in the pack.
Finally, we define tl = i ti;l =n with n = bd . For simplicity, in the formulae we implicitly
assume that i always ranges from 1 to n with n the number of queries, unless explicitly

P

P

P

149

P

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
specified otherwise. We then have
Tp

= max ti;0
i

X
+ T
i

i;1

= max ti;0
i

X
+ (max t
b

j =1

2

i Gj

i;1

XT

+

2

i Gj

i;2

)

(4)

where j = 1 : : : b is the index of a child of the root and Gj is the set of indexes of the
queries belonging to that child. Now define K0 = maxi ti;0 =t0 and define K1 as the smallest
number such that maxi2Gj ti;1  K1 tj;1 with tj;1 = i2Gj ti;1 =b. Note 1  K0 ; K1  b. It
then follows that
b
b
max ti;1  K1 tj;1 = K1 bt1
(5)
i2Gj
j =1
j =1

P

X

X

which allows us to rewrite Equation (4) into
Tp

 K0t0 + K1 bt1 +

XT
i

(6)

i;2

where the equality holds if maxi2Gj ti;1 is equal in all Gj . The reasoning can be continued
up till the lowest level of the pack, yielding
Tp

 K0t0 + bK1t1 + b2K2 t2 +    + bd

and finally
Tp

 K0 t0 + bK1 t1 + b2 K2t2 +    + bd



1K

d 1 td 1

1K

+



d 1 td 1

Xt

i;d

(7)

i

+ bd td

(8)

with all Kl between 1 and b. We will further simplify the comparison with Ts by assuming
8l : Kl = 1; the Kl can then be dropped and the inequality becomes an equality (because
all maxima must be equal):
Tp

= t0 + bt1 + b2 t2 +    + bd 1 td

1

+ bd td

(9)

1

+ bd td

(10)

Note that for Ts we have
Ts

= bd t0 + bd t1 + bd t2 +    + bd td

It is clear, then, that the speedup will be governed by how the bd tk terms compare to the
bk tk terms. (In the worst case, where Kk = b, the latter become bk+1 tk .) We therefore
introduce Rl;m as follows:
m
bm tk
(11)
Rl;m = km=l k

k =l b tk

P
P

The R coecients are always between 1 (if tm dominates) and bm l (if tl strongly dominates);
for all tl equal, Rl;m is approximately m l.
Further, similar to c in our previous analysis, define

P =0 b t
c = P

= +1 b t
l

l
k

d
k l

150

k

k

k

k

(12)

fiImproving the Efficiency of ILP through Query Packs
Some algebra then gives

Ts
Tp

=

bd l cl R0;l + Rl+1;d
cl + 1

(13)

which needs to hold for all l. We can interpret this as follows: for a certain level l, cl roughly
reects the speedup gained by the fact that the part up till level l needs to be executed
only once; the R factors reect the speedup obtained within these parts because of the pack
mechanism.
This inequality holds for all l, hence we will find the best lower bound for the speedup factor by maximizing the right hand side. Note that cl increases and bd l decreases
monotonically with l. It is clear that if at some point cl becomes much larger than 1, a
speedup factor of roughly bd l is obtained. On the other hand, if cl is smaller than 1, then
the behaviour of bd l cl is crucial. Now,
bd l cl

tl + 1 tl 1 +    + b1l t0
=  1 b
:
td + b td 1 +    + bd 1l 1 tl+1

Our conclusion is similar to that for the one-level pack. If for some l, cl >> 1, i.e., if in
the upper part of the pack (up till level l) computations take place that are so expensive
that they dominate all computations below level l (even taking into account that the latter
are performed bd l times more often), then a speedup of bd l can be expected. If cl << 1,
which will usually be the case for all l except those near d, the speedup can roughly be
estimated as tl =td . The maximum of all these factors will determine the actual speedup.
4. Adapting ILP Algorithms to Use Query Packs

In this section we discuss how the above execution method can be included in ILP algorithms, and illustrate this in more detail for two existing ILP algorithms. Experimental
results concerning actual eciency improvements this yields are presented in the next section.

4.1 Refinement of a Single Rule
Many systems for inductive logic programming use an algorithm that consists of repeatedly
refining clauses. Any of these systems could in principle be rewritten to make use of a query
pack evaluation mechanism and thus achieve a significant eciency gain. We first show this
for a concrete algorithm for decision tree induction, then discuss the more general case.
4.1.1 Induction of Decision Trees

The first algorithm we discuss is Tilde (Blockeel & De Raedt, 1998), an algorithm that
builds first-order decision trees. In a first-order decision tree, nodes contain literals that
together with the conjunction of the literals in the nodes above this node (i.e., in a path
from the root to this node) form the query that is to be run for an example to decide which
subtree it should be sorted into. When building the tree, the literal (or conjunction of
literals) to be put in one node is chosen as follows: given the query corresponding to a path
from the root to this node, generate all refinements of this query (a refinement of a query

151

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
is formed by adding one or more literals to the query); evaluate these refinements on the
relevant subset of the data,2 computing, e.g., the information gain (Quinlan, 1993a) yielded
by the refinement; choose the best refinement; and put the literals that were added to the
original clause to form this refinement in the node.
At this point it is clear that a lot of computational redundancy exists if each refinement
is evaluated separately. Indeed all refinements contain exactly the same literals except those
added during this single refinement step. Organising all refinements into one query pack, we
obtain a query pack that essentially has only one level (the root immediately branches into
leaves). When Tilde's lookahead facility is used (Blockeel & De Raedt, 1997), refinements
form a lattice and the query pack may contain multiple (though usually few) levels.
Note that the root of these packs may consist of a conjunction of many literals, giving
the pack a broom-like form. The more literals in the root of the pack, the greater the benefit
of query pack execution is expected to be.

Example 4 Assume the node currently being refined has the following query associated with

it: ?- circle(A,C),leftof(A,C,D),above(A,D,E), i.e., the node covers all examples A
where there is a circle to the left of some other object which is itself above yet another object.
The query pack generated for this refinement could for instance be

circle(A,C), leftof(A,C,D), above(A,D,E),

triangle(A,F)
circle(A,H)
small(A,I)
large(A,J)
in(A,E,K)
in(A,D,L)
in(A,C,M)
above(A,E,N)
above(A,D,O)
above(A,C,P)
leftof(A,E,Q)
leftof(A,D,R)
leftof(A,C,S)

When evaluating this pack, all backtracking through the root of the pack (the \stick"
of the broom) will happen only once, instead of once for each refinement. In other words:
when evaluating queries one by one, for each query the Prolog engine needs to search once
again for all objects C , D and E fulfilling the constraint circle(A,C), leftof(A,C,D),
above(A,D,E); when executing a pack this search is done only once.
4.1.2 Other Algorithms Based on Rule Refinement

As mentioned, any ILP algorithm that consists of repeatedly refining clauses could in principle be rewritten to make use of a query pack evaluation mechanism and thus achieve a
significant eciency gain. Consider, e.g., a rule induction system performing an A search
through a refinement lattice, such as Progol (Muggleton, 1995). Since A imposes a certain order in which clauses will be considered for refinement, it is hard to reorganise the
computation at this level. However, when taking one node in the list of open nodes and
producing all its refinements, the evaluation of the refinements involves executing all of
them; this can be replaced by a pack execution, in which case a positive eciency gain is
guaranteed. In principle one could also perform several levels of refinement at this stage,
2. I.e., that subset of the original data set for which the parent query succeeded; or, in the decision tree
context: the examples sorted into the node that is being refined.

152

fiImproving the Efficiency of ILP through Query Packs
adding all of the refinements to A 's queue; part of the eciency of A is then lost, but
the pack execution mechanism is exploited to a larger extent. Which of these two effects
is dominant will depend on the application: if most of the first-level refinements would
be further refined anyway at some point during the search, clearly there will be a gain in
executing a two-level pack; otherwise there may be a loss of eciency. For instance, if
executing a two-level pack takes x times as much time as a one-level pack, it will bring an
eciency gain only if at least x of the first level refinements would afterwards be refined
themselves.

4.2 Level-wise Frequent Pattern Discovery
An alternative family of data mining algorithms scans the refinement lattice in a breadthfirst manner for queries whose frequency exceeds some user-defined threshold. The bestknown instance of these level-wise algorithms is the Apriori method for finding frequent
item-sets (Agrawal et al., 1996). Warmr (Dehaspe & Toivonen, 1999) is an ILP variant of
attribute-value based Apriori.
Query packs in Warmr correspond to hash-trees of item-sets in Apriori: both are used
to store a subgraph of the total refinement lattice down to level n. The paths from the root
down to level n 1 in that subgraph correspond to frequent patterns. The paths from root
to the leaves at depth n correspond to candidates whose frequency has to be computed.
Like hash-trees in Apriori, query packs in Warmr exploit massive similarity between
candidates to make their evaluation more ecient. Essentially the Warmr algorithm starts
with an empty query pack and iterates between pack evaluation and pack extension (see
Figure 8). The latter is achieved by adding all potentially frequent refinements3 of all leaves
in the pack, i.e., adding another level of the total refinement lattice.
5. Experiments

The goal of this experimental evaluation is to empirically investigate the actual speedups
that can be obtained by re-implementing ILP systems so that they use the pack execution
mechanism. At this moment such re-implementations exist for the Tilde and Warmr
systems, hence we have used these for our experiments. These re-implementations are
available within the ACE data mining tool, available for academic use upon request.4 We
attempt to quantify (a) the speedup of packs w.r.t. to separate execution of queries (thus
validating our complexity analysis), and (b) the total speedup that this can yield for an
ILP system.
The data sets that we have used for our experiments are the following:



The Mutagenesis data set : an ILP benchmark data set, introduced to the ILP community by Srinivasan et al. (1995), that consists of structural descriptions of 230
molecules that are to be classified as mutagenic or not. Next to the standard Mutagenesis data set, we also consider versions of it where each example occurs n times;

3. Refinements found to be specialisations of infrequent queries cannot be frequent themselves, and are
pruned consequently.
4. See http://www.cs.kuleuven.ac.be/~dtai/ACE/.

153

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele

circle(A,B)

triangle(A,B)

leftof(A,B,C) above(A,B,C) leftof(A,B,C)

EXPAND

circle(A,B)

leftof(A,B,C)

triangle(A,B)

above(A,B,C)

leftof(A,B,C)

circle(A,C)triangle(A,C) circle(A,C)triangle(A,C) circle(A,C)triangle(A,C)
EVALUATE
circle(A,B) triangle(A,B)
above(A,B,C)

leftof(A,B,C)

triangle(A,C) circle(A,C)triangle(A,C)

circle(A,B)

EXPAND

above(A,B,C)
triangle(A,C)

triangle(A,B)
leftof(A,B,C)

circle(A,C)

triangle(A,C)

leftof(A,C,D) leftof(A,C,D) above(A,C,D) leftof(A,C,D)

Figure 8: A sequence of 4 query packs in Warmr. Refinement of the above left query
pack results in the 3-level pack above right. Removal of queries found infrequent
during pack evaluation results in the bottom left pack. Finally, another level is
added in a second query expansion step to produce the bottom right pack. This
iteration between expansion and evaluation continues until the pack is empty.
this allows us to easily generate data sets of larger size where the average example
and query complexity are constant and equal to those of the original data set.



Bongard data sets : introduced in ILP by De Raedt and Van Laer (1995), the so-called
\Bongard problems" are a simplified version of problems used by Bongard (1970) for
research on pattern recognition. A number of drawings are shown containing each a
number of elementary geometrical figures; the drawings have to be classified according
to relations that hold on the figures in them. We use a Bongard problem generator
to create data sets of varying size.

The experiments were run on SUN workstations: a Sparc Ultra-60 at 360 MHz for
Tilde, a Sparc Ultra-10 at 333 Mhz for Warmr. Tilde and Warmr were run with their
default settings, except where mentioned differently.

5.1 Tilde
We consider three different ways in which Tilde can be run in its ilProlog implementation:
1. No packs: the normal implementation of Tilde as described by Blockeel and De Raedt
(1998), where queries are generated one by one and each is evaluated on all relevant
examples. Since queries are represented as terms, each evaluation of a query involves
a meta-call in Prolog.

154

fiImproving the Efficiency of ILP through Query Packs
2. Disjoint execution of packs: a query pack is executed in which all queries in the pack
are put beside one another; i.e., common parts are not shared by the queries. The
computational redundancy in executing such a pack is the same as that in executing
all queries one after another; the main difference is that in this case all queries are
compiled.
3. Packed execution of packs: a compiled query pack is executed where queries share as
much as possible.
The most interesting information is obtained by comparing (a) the actual query evaluation time in settings 2 and 3: this gives a view of the eciency gain obtained by the
removal of redundant computation itself (we will abbreviate this as exec in the tables);
and (b) the total execution time in settings 1 and 3: this provides an indication of how
much is gained by implementing packs in an ILP system, taking all other effects into account (re-implementation of the computation of heuristics via a bit matrix, use of compiled
queries instead of meta-calls, etc.), or in other words: what the net effect of the whole
re-implementation is (indicated as net in the tables).
In a first experiment we used Bongard problems, varying (1) the size of the data sets;
(2) the complexity of the target hypothesis; and (3) Tilde's lookahead parameter. The
complexity of the target hypothesis can be small, medium, or none. In the latter case the
examples are random, which causes Tilde to grow ever larger trees in an attempt to find
a good hypothesis; the size of the final tree then typically depends on the size of the data
set. The lookahead parameter is used to control the number of levels the pack contains;
with lookahead n, packs of depth n + 1 are generated.
Table 1 gives an overview of results for the Bongard problems. The total induction
time is reported, as well as (for pack-based execution mechanisms) the time needed for
pack compilation and pack execution. Note that the total time includes not only pack
compilation and execution, but also all other computations not directly related to packs
(e.g., the computation of heuristics from the bitmatrix). The results can be interpreted as
follows.
First of all, the table shows that significant speedups can be obtained by using the pack
mechanism; net speedups of over a factor 5.5 are obtained, while the execution itself is up
to 75 times faster compared to disjoint execution.
A further observation is that for more complex target hypotheses greater speedups are
obtained. This can be explained by the broom-like form of the packs in Tilde. Complex
target hypotheses correspond to deep trees, and refinement of a node at a lower level of
such a tree yields a pack with a long clause before the branching, which in accordance with
our previous analysis should yield a speedup closer to the branching factor b in the case
of lookahead 0 (and more generally, closer to bl+1 for lookahead l, although the latter is
much harder to achieve). Note that the maximum branching factor occurring in each pack
is included in the table in column bf .
Finally, deeper packs also yield higher speedups, and this effect is larger for more complex
theories. This is understandable considering the following. Let us call the clause that is
being refined c. With lookahead l, conjunctions of l + 1 literals are added to the clause. In
some cases the first of these l + 1 literals may fail immediately, which causes this branch of
the pack to have almost no execution time, while cutting away bl queries. Remember that

155

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
LA

bf

0
1
2
3

16
24
18
21

0
1
2
3

16
24
18
21

0
1
2
3

19
24
18
21

0
1
2
3

19
21
15
18

0
1
2
3

22
24
27
18

0
1
2
3

25
24
27
27

0
1
2
3

28
24
24
30

0
1
2
3

31
36
33
33

0
1
2
3

31
39
39
42

original

0.74
2.44
7.49
29.9

1.82
5.72
17.2
69.8

3.69
11.4
34.7
142

1.01
3.26
6.36
27.2

3.16
8.38
38.5
124

6.35
18.14
119
384

4.74
16.32
87.5
373

12.7
65.1
430
1934

25.3
154
1185
4256

disjoint
packed
comp exec total comp
Simple target hypothesis
1007 examples
0.62
0.14
0.13
0.49
0.05
1.64
0.35
0.45
1.09
0.14
4.07
0.8
1.57
2.15
0.27
16.52
3.65
7.26
7.18
1.26
2473 examples
1.43
0.17
0.34
1.13
0.07
3.34
0.34
1.17
2.24
0.11
8.45
0.78
3.95
4.4
0.27
33.0
3.57
17.5
13.7
1.13
4981 examples
2.72
0.29
0.67
2.16
0.12
6.22
0.35
2.41
4.17
0.13
16.0
0.74
8.14
8.24
0.25
62.4
3.61
36.5
24.9
1.09
Medium complexity target hypothesis
1031 examples
0.93
0.29
0.18
0.66
0.11
2.8
0.98
0.56
1.66
0.35
3.47
0.68
1.22
1.95
0.25
14.6
3.75
5.75
6.71
1.20
2520 examples
2.82
0.89
0.62
1.91
0.3
5.88
1.5
1.86
3.3
0.44
29.8
13.14 9.52
10.3
2.44
58.02
10.3
28.6
23.9
3.00
5058 examples
5.41
1.47
1.3
3.73
0.56
12.98
3.2
4.15
7.5
0.93
93.2
38.1
31.0
35.3
9.09
275
108
89.1
106
25.9
No target hypothesis
1194 examples
6.65
3.34
0.94
3.93
0.98
21.29
10.97 2.24 11.65 3.41
130
82.3
13.8
54.7
20.4
519
316
61.1
220
74.9
2986 examples
16.5
7.04
2.68
9.8
2.16
83.7
42.9
10.7
42.47
11.2
606
396
84
211.3
82.58
2592
1610
375
946
332
6013 examples
30.3
11.8
5.53
18.3
3.53
198
91.2
33.4
99.9
22.0
1733
1076
358
504
197
6932
4441 1091 2006
695
total

speedup

exec

net

exec

0.07

1.51

1.86

0.11

2.24

4.09

0.16

3.48

9.81

0.28

4.17

25.9

0.16

1.61

2.13

0.3

2.55

3.9

0.39

3.92

10.1

0.69

5.11

25.4

0.32

1.71

2.09

0.63

2.74

3.83

0.88

4.21

9.25

1.45

5.69

25.1

0.07

1.53

2.57

0.14

1.96

4

0.15

3.26

8.13

0.27

4.06

21.3

0.24

1.65

2.58

0.41

2.54

4.54

0.6

3.73

15.9

1.11

5.21

25.7

0.53

1.70

2.45

0.91

2.42

4.56

1.7

3.36

18.2

2.83

3.62

31.5

0.20

1.21

4.70

0.31

1.40

7.23

0.57

1.60

24.1

1.34

1.70

45.6

0.56

1.30

4.79

1.14

1.53

9.39

2.57

2.03

32.6

6.58

2.04

57.0

1.27

1.38

4.35

3.13

1.54

10.7

9

2.35

39.8

14.5

2.12

75.4

Table 1: Timings of Tilde runs on the Bongard data sets. LA = lookahead setting; bf =
maximum branching factor. Reported times (in seconds) are the total time needed
to build a tree, and the time spent on compilation respectively execution of packs.

156

fiImproving the Efficiency of ILP through Query Packs
LA original
0
1
2

31.5
194.99
2193

0
1
2

27.6
38.02
638

disjoint
packed
total comp exec total comp
Regression, 230 examples
52.9 1.96 25.5 45.5 1.02
248 55.9 109 107 12.6
{
{
{
891
192
Classification, 230 examples
27.3 1.83 4.71 25.4 1.13
40.3 7.55 9.09 30.6 3.11
{
{
{
149 74.3

Table 2: Timings of Tilde runs for Mutagenesis. A
ended prematurely.

exec

speedup ratio
net
exec

19.25 0.69
16.6 1.82
32.0 2.46

1.33
6.53
{

3.42
3.65
6.16

1.38
2.49
{

1.09
1.24
4.2

in the table indicates that that run

according to our analysis, the speedup can in the limit approximate bl if the complexity of
clause c dominates over the complexity of the rest of the pack; such \early failing branches"
in the pack cause the actual situation to approximate closer this ideal case.
We have also run experiments on the Mutagenesis data set (Table 2), both in a regression
and a classification setting. Here, query packs are much larger than for the Bongard data set
(there is a higher branching factor); with a lookahead of 2 the largest packs had over 20000
queries. For these large packs a significant amount of time is spent compiling the pack, but
even then clear net speedups are obtained.5 A comparison of execution times turned out
infeasible because in the disjoint execution setting the pack structures consumed too much
memory.

5.2 Warmr
5.2.1 Used Implementations

For Warmr we consider the following implementations:
1. No packs: the normal implementation of Warmr, where queries are generated, and
for all examples the queries are evaluated one by one.
2. With packs: An implementation where first all queries for one level are generated and
put into a pack, and then this pack is evaluated on each example.
5.2.2 Datasets

Mutagenesis We used the Mutagenesis dataset of 230 molecules, where each example is
repeated 10 times to make more accurate timings possible and to have a better idea of the
effect on larger datasets. We used three different language biases. 'small' is a language
5. In one case, with a relatively small pack, the system became slower. The timings indicate that this is
not due to the compilation time, but to other changes in the implementation which for this relatively
simple problem were not compensated by the faster execution of the packs.

157

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele

Level
1
2
3
4
5
6
7
8
9

small

Mutagenesis

medium

large

Queries Frequent Queries Frequent Queries Frequent
8
5
37
26
45
31
60
14
481
48
1071
211
86
24
688
114
3874
1586
132
31
699
253
37
21
697
533
29
18
1534
1149
23
15
{
{
17
12
{
{
4
4
{
{

Table 3: Number of queries for the Mutagenesis experiment with Warmr.
bias that was chosen so as to generate a limited number of refinements (i.e., a relatively
small branching factor in the search lattice); this allows us to generate query packs that are
relatively deep but narrow. 'medium' and 'large' use broader but more shallow packs.
Table 3 summarises the number of queries and the number of frequent queries found for
each level in the different languages.

Bongard We use Bongard-6013 for experiments with

Warmr as this system does not
construct a theory and hence the existence of a simple theory is not expected to make much
difference.
5.2.3 Results

In Tables 4, 5 and 6 the execution times of Warmr on Mutagenesis are given, with maximal
search depth varying from 3 for the large language to 9 levels for the small language. Here,
'total' is the total execution time and 'exec' is the time needed to test the queries against
the examples. In Table 7 the execution times of Warmr on Bongard are given.
5.2.4 Discussion

The execution time of Warmr has a large component that is not used to evaluate queries.
This is caused by the fact that Warmr needs to do a lot of administrative work. In
particular, theta-subsumption tests should be done on the queries to check wether a query
is equivalent to another candidate, or if a query is a specialisation of an infrequent one.
In the propositional case (the Apriori algorithm), these tests are very simple, but in the
first order case they require exponential time in the size of the queries. Of course, when
using larger datasets, the relative contribution of these administrative costs will decrease
proportionally. It can be observed that at deeper levels, these costs are less for the setting
using packs. One of the causes is the fact that the no-packs version also uses more memory
than the packs setting (and hence causes proportionally more memory management).
Here again, the most important numbers are the speedup factors for the execution of
queries. Speedup factors of query execution do not always increase with increasing depth of

158

fiImproving the Efficiency of ILP through Query Packs

Level
1
2
3
4
5
6
7
8
9

No packs
With packs ilProlog
total
exec
total
exec
0.35
0.23
0.18
0.15
6.27
5.60
4.56
4.12
36.93
31.49 14.01
9.87
117.33 84.45
45.14
16.27
215.95 104.36 129.37
20.78
336.35 111.28 249.41
22.39
569.14 115.80 497.86
24.63
902.72 120.99 831.30
25.98
1268.16 119.60 1148.23
32.28

speedup ratio
net
exec
1.94 1.53
1.38 1.36
2.64 3.19
2.60 5.19
1.67 5.02
1.35 4.97
1.14 4.70
1.09 4.66
1.10 3.71

Table 4: Results for Warmr on the Mutagenesis dataset using a small language.

Level
1
2
3
4
5
6

No packs
With packs ilProlog
total
exec
total
exec
2.58
2.27
2.16
2.09
112.98
42.32
34.35
13.39
735.19 128.67 262.83
34.70
4162.15 287.72 1476.06
54.10
17476.98 444.44 6870.16
73.11
65138.72 866.85 25921.73
104.81

speedup ratio
net
exec
1.19 1.09
3.29 3.16
2.80 3.71
2.82 5.32
2.54 6.08
2.51 8.27

Table 5: Results for Warmr on the Mutagenesis dataset using a medium language.

Level
1
2
3

No packs
With packs ilProlog
total
exec
total
exec
2.82
2.42
2.28
2.11
408.85
102.38 102.29
50.67
27054.33 1417.76 3380.19
370.44

speedup ratio
net
exec
1.24 1.15
4.00 2.02
8.00 3.83

Table 6: Results for Warmr on the Mutagenesis dataset using a large language.

159

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
Level
1
2
3
4
5
6
7
8
9
10

No packs
total
exec
0.24
0.22
0.83
0.75
3.28
2.82
11.56 9.31
38.34 28.11
75.51 46.97
135.64 71.60
186.23 84.93
210.82 88.97
216.61 89.38
Table 7:

With packs ilProlog
total
exec
0.24
0.23
0.77
0.68
2.34
1.92
6.08
4.28
16.20
8.15
36.57
12.22
68.96
15.59
102.46
17.82
120.76
18.52
125.84
18.88

Warmr

speedup ratio
net
exec
1.00 0.96
1.08 1.10
1.40 1.47
1.90 2.18
2.37 3.45
2.06 3.84
1.97 4.59
1.82 4.77
1.75 4.80
1.72 4.73

results on Bongard.

the packs, in contrast to Tilde where larger packs yielded higher speedups. At first sight
we found this surprising; however it becomes less so when the following observation is made.
When refining a pack into a new pack by adding a level, Warmr prunes away branches that
lead only to infrequent queries. There are thus two effects when adding a level to a pack:
one is the widening of the pack at the lowest level (at least on the first few levels, a new
pack typically has more leaves than the previous one), the second is the narrowing of the
pack as a whole (because of pruning). Since the speedup obtained by using packs largely
depends on the branching factor of the pack, speedup factors can be expected to decrease
when the narrowing effect is stronger than the widening-at-the-bottom effect. This can
be seen, e.g, in the small-mutagenesis experiment, where at the deepest levels queries are
becoming less frequent. For the mutagenesis experiment with the medium size language,
query execution speedup factors are larger as the number of queries increases much faster.
For the mutagenesis experiment with the large language, it is the total speedup that is large,
as the language generates so many queries that the most time-consuming part becomes the
administration and storage in memory. The packs version is much faster as it stores the
queries in trees, requiring significantly less memory.

5.3 Comparison with Other Engines
Implementing a new special-purpose Prolog engine, different from the already existing ones,
carries a risk: given the level of sophistication of popular Prolog engines, it is useful to check
whether the new engine performs comparably with these existing engines, at least for the
tasks under consideration here. The eciency gain obtained through query pack execution
should not be offset by a less ecient implementation of the engine itself.
Originally the Tilde and Warmr systems were implemented in MasterProLog.
In an attempt to allow them to run on other platforms, parts of these systems were reimplemented into a kind of \generic" Prolog from which implementations for specific Prolog engines (SICStus, ilProlog) can easily be derived (the low level of standardisation of
Prolog made this necessary). Given this situation, there are two questions to be answered:

160

fiImproving the Efficiency of ILP through Query Packs
Data set
LA
Bongard-1194 0
Bongard-2986 0
Bongard-6013 0
Bongard-1007 0
Bongard-2473 0
Bongard-4981 0
Bongard-1007 2
Bongard-2473 2
Bongard-4981 2
Table 8:

MasterProLog ilProlog(original) ilProlog(packs)
7.8
17.8
35
0.77
2.07
4.1
7.1
17.7
38

4.74
12.7
25
0.74
1.82
3.7
7.5
17.2
35

3.93
9.8
18
0.49
1.13
2.2
2.2
4.4
8.2

compared to other engines (times in seconds) for several data sets and
lookahead settings.

ilProlog

(a) does the move from MasterProLog to other Prolog engines inuence performance in
a negative way; and (b) does the performance loss, if any, reduce the performance improvements due to the use of packs?
Tilde and Warmr have been tuned for fast execution on MasterProLog and ilProlog but not for SICStus, which makes a comparison with the latter unfair; therefore
we just report on the former 2 engines. Table 8 shows some results. These confirm that
ilProlog is competitive with state-of-the-art Prolog engines.

5.4 Summary of Experimental Results
Our experiments confirm that (a) query pack execution in itself is much more ecient than
executing many highly similar queries separately; (b) existing ILP systems (we use Tilde
and Warmr as examples) can use this mechanism to their advantage, achieving significant
speedups; and c) although a new Prolog engine is needed to achieve this, the current state
of development of this engine is such that with respect to execution speed it can compete
with state-of-the-art engines. Further, the experiments are consistent with our complexity
analysis of the execution time of packs.
6. Related Work

The re-implementation of Tilde is related to the work by Mehta et al. (1996) who were
the first to describe the \examples in outer loop" strategy for decision tree induction. The
query pack execution mechanism, here described from the Prolog execution point of view,
can also be seen as a first-order counterpart of Apriori's mechanism for counting item-sets
(Agrawal et al., 1996).
Other lines of work on eciency improvements for ILP involves stochastic methods
which trade a certain amount of optimality for eciency by, e.g., evaluating clauses on a
sample of the data set instead of the full data set (Srinivasan, 1999), exploring the clause
search space in a random fashion (Srinivasan, 2000), or stochastically testing whether a

161

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
query succeeds on an example (Sebag & Rouveirol, 1997). The first of these is entirely
orthogonal to query pack execution and can easily be combined with it.
The idea of optimising sets of queries instead of individual queries has existed for a
while in the database community. The typical context considered in earlier research on
multi-query optimisation (e.g., Sellis, 1988) was that of a database system that needs to
handle disjunctions of conjunctive queries, or of a server that may receive many queries from
different clients in a brief time interval. If several of these queries are expected to compute
the same intermediary relations, it may be more ecient to materialise these relations
instead of having them recomputed for each query. Data mining provides in a sense a new
context for multi-query optimisation, in which the multi-query optimisation approach is at
the same time easier (the similarities among the queries are more systematic, so one need
not look for them) and more promising (given the huge number of queries that may be
generated at once).
Tsur et al. (1998) describe an algorithm for ecient execution of so-called query ocks
in this context. Like our query pack execution mechanism, the query ock execution mechanism is inspired to some extent by Apriori and is set in a deductive database setting.
The main difference between our query packs and the query ocks described by Tsur et al.
(1998) is that query packs are more hierarchically structured and the queries in a pack are
structurally less similar than the queries in a ock. (A ock is represented by a single query
with placeholders for constants, and is equal to the set of all queries that can be obtained
by instantiating the placeholders to constants. Flocks could not be used for the applications
we consider here.)
Dekeyser and Paredaens (2001) describe work on multi-query optimisation in the context
of relational databases. They also consider tree-like structures in which multiple queries are
combined; the main difference is that their trees are rooted in one single table from which
the queries select tuples, whereas our queries correspond to joins of multiple tables. Further,
Dekeyser and Paredaens define a cost measure for trees as well as operators that map trees
onto semantically equivalent (but less costly) trees, whereas we have considered only the
creation of packs and an ecient top-down execution mechanism for them. Combining both
approaches seems an interesting topic for further research.
Finally, other optimisation techniques for ILP have been proposed that exploit results
from program analysis (Santos Costa et al., 2000; Blockeel et al., 2000) or from propositional
data mining technology (Blockeel et al., 1999). These are complementary to our pack
execution optimisation. Especially the approach of Blockeel et al. (1999) can easily be
combined with our pack mechanism. The techniques discussed by Santos Costa et al.
(2000) and Blockeel et al. (2000) involve optimisations for single query execution, some of
which can to some extent be upgraded to the pack setting. This is future work.
7. Conclusions

There is a lot of redundancy in the computations performed by most ILP systems. In this
paper we have identified a source of redundancy and proposed a method for avoiding it:
execution of query packs. We have discussed how query pack execution can be incorporated
in ILP systems. The query pack execution mechanism has been implemented in a new
Prolog system called ilProlog and dedicated to data mining tasks, and two ILP systems

162

fiImproving the Efficiency of ILP through Query Packs
have been re-implemented to make use of the mechanism. We have experimentally evaluated
these re-implementations, and the results of these experiments confirm that large speedups
may be obtained in this way. We conjecture that the query pack execution mechanism can
be incorporated in other ILP systems and that similar speedups can be expected.
The problem setting in which query pack execution was introduced is very general, and
allows the technique to be used for any kind of task where many queries are to be executed
on the same data, as long as the queries can be organised in a hierarchy.
Future work includes further improvements to the ilProlog engine and the implementation of techniques that will increase the suitability of the engine to handle large data sets.
In the best case one might hope to combine techniques known from database optimisation
and program analysis with our pack execution mechanism to further improve the speed of
ILP systems.

Acknowledgements
Hendrik Blockeel is a post-doctoral fellow of the Fund for Scientific Research (FWO) of
Flanders. Jan Ramon is funded by the Flemish Institute for the Promotion of Scientific
Research in Industry (IWT). Henk Vandecasteele was funded in part by the FWO project
G.0246.99, \Query languages for database mining". The authors thank Luc De Raedt for
his inuence on this work, Ashwin Srinivasan for suggesting the term \query packs", the
anonymous reviewers for their useful comments, and Kurt Driessens for proofreading this
text. This work was motivated in part by the Esprit project 28623, Aladin.
Appendix A. Preparing the Query for the Meta-interpreter

Note that the following preprocessor assumes that the pack of the form a, (b, (c or d
or e) or f or g, (h or i or j)) was already transformed to the form a , or([(b,
or([c,d,e])), f, (g, or([h,i,j]))]).
preprocess((A,B),(A,NewB),PrevNode,NodeNr0,LeafNr0,BranchNr,NodeNr1,LeafNr1):- !,
preprocess(B,NewB,PrevNode,NodeNr0,LeafNr0,BranchNr,NodeNr1,LeafNr1).
preprocess(or(Querys),or(NQuerys,PrevNode,NodeNr0,BranchNr,Length),
PrevNode,NodeNr0,LeafNr0,BranchNr, NodeNr1,LeafNr1):- !,
NodeNr2 is NodeNr0 + 1,
preprocessbranches(Querys,NQuerys,NodeNr0,NodeNr2,LeafNr0,
1,NodeNr1,LeafNr1,Length).
preprocess(A,(A,leaf(PrevNode,BranchNr,LeafNr0)),
PrevNode,NodeNr0,LeafNr0, BranchNr,NodeNr0,LeafNr1):LeafNr1 is LeafNr0 + 1.
preprocessbranches([],[], ,NodeNr,LeafNr,BranchNr, NodeNr,LeafNr,BranchNr).
preprocessbranches([QueryjQuerys],[NewQueryjNewQuerys],PrevNode,
NodeNr0,LeafNr0,BranchNr, NodeNr1,LeafNr1,Length):preprocess(Query,NewQuery,
PrevNode,NodeNr0,LeafNr0,BranchNr, NodeNr2,LeafNr2),
BranchNr1 is BranchNr + 1,
preprocessbranches(Querys,NewQuerys, PrevNode,
NodeNr2,LeafNr2,BranchNr1, NodeNr1,LeafNr1,Length).

163

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele

References

Agrawal, R., Mannila, H., Srikant, R., Toivonen, H., & Verkamo, A. (1996). Fast discovery
of association rules. In Fayyad, U., Piatetsky-Shapiro, G., Smyth, P., & Uthurusamy,
R. (Eds.), Advances in Knowledge Discovery and Data Mining, pp. 307{328. The MIT
Press.
At-Kaci, H. (1991). Warren's Abstract Machine: A Tutorial Reconstruction. The MIT
Press, Cambridge, Massachusetts.
http://www.isg.sfu.ca/~hak/documents/wam.html.
Blockeel, H. (1998). Top-down induction of first order logical decision trees. Ph.D. thesis,
Department of Computer Science, Katholieke Universiteit Leuven.
http://www.cs.kuleuven.ac.be/~ml/PS/blockeel98:phd.ps.gz.
Blockeel, H., & De Raedt, L. (1997). Lookahead and discretization in ILP. In Proceedings
of the Seventh International Workshop on Inductive Logic Programming, Vol. 1297 of
Lecture Notes in Artificial Intelligence, pp. 77{85. Springer-Verlag.
Blockeel, H., & De Raedt, L. (1998). Top-down induction of first order logical decision trees.
Artificial Intelligence, 101 (1-2), 285{297.
Blockeel, H., De Raedt, L., Jacobs, N., & Demoen, B. (1999). Scaling up inductive logic programming by learning from interpretations. Data Mining and Knowledge Discovery,
3 (1), 59{93.
Blockeel, H., De Raedt, L., & Ramon, J. (1998). Top-down induction of clustering trees.
In Proceedings of the 15th International Conference on Machine Learning, pp. 55{63.
http://www.cs.kuleuven.ac.be/~ml/PS/ML98-56.ps.
Blockeel, H., Demoen, B., Janssens, G., Vandecasteele, H., & Van Laer, W. (2000). Two
advanced transformations for improving the eciency of an ILP system. In 10th
International Conference on Inductive Logic Programming, Work-in-Progress Reports,
pp. 43{59, London, UK.
Bongard, M. (1970). Pattern Recognition. Spartan Books.
Bratko, I. (1990). Prolog Programming for Artificial Intelligence. Addison-Wesley, Wokingham, England. 2nd Edition.
Breiman, L., Friedman, J., Olshen, R., & Stone, C. (1984). Classification and Regression
Trees. Wadsworth, Belmont.
Chen, W., & Warren, D. S. (1996). Tabled evaluation with delaying for general logic programs. Journal of the ACM, 43 (1), 20{74. http://www.cs.sunysb.edu/~sbprolog.
Clark, P., & Niblett, T. (1989). The CN2 algorithm. Machine Learning, 3 (4), 261{284.
De Raedt, L. (1997). Logical settings for concept learning. Artificial Intelligence, 95, 187{
201.
De Raedt, L., & Dehaspe, L. (1997). Clausal discovery. Machine Learning, 26, 99{146.

164

fiImproving the Efficiency of ILP through Query Packs
De Raedt, L., & Dzeroski, S. (1994). First order jk-clausal theories are PAC-learnable.
Artificial Intelligence, 70, 375{392.
De Raedt, L., & Van Laer, W. (1995). Inductive constraint logic. In Jantke, K. P., Shinohara, T., & Zeugmann, T. (Eds.), Proceedings of the Sixth International Workshop on
Algorithmic Learning Theory, Vol. 997 of Lecture Notes in Artificial Intelligence, pp.
80{94. Springer-Verlag.
Dehaspe, L., & Toivonen, H. (1999). Discovery of frequent datalog patterns. Data Mining
and Knowledge Discovery, 3 (1), 7{36.
Dekeyser, S., & Paredaens, J. (2001). Query pack trees for multi query optimization. Tech.
rep. 01-04, University of Antwerp. ftp://wins.uia.ac.be/pub/dekeyser/qpt.ps.
Demoen, B., Janssens, G., & Vandecasteele, H. (1999). Executing query flocks for ILP. In
Etalle, S. (Ed.), Proceedings of the Eleventh Benelux Workshop on Logic Programming,
pp. 1{14, Maastricht, The Netherlands. 14 pages.
Kramer, S. (1996). Structural regression trees. In Proceedings of the Thirteenth National
Conference on Artificial Intelligence, pp. 812{819, Cambridge/Menlo Park. AAAI
Press/MIT Press.
Mehta, M., Agrawal, R., & Rissanen, J. (1996). SLIQ: A fast scalable classifier for data
mining. In Proceedings of the Fifth International Conference on Extending Database
Technology.
Muggleton, S. (1995). Inverse entailment and Progol. New Generation Computing, Special
issue on Inductive Logic Programming, 13 (3-4), 245{286.
Muggleton, S., & De Raedt, L. (1994). Inductive logic programming : Theory and methods.
Journal of Logic Programming, 19,20, 629{679.
Quinlan, J. R. (1993a). C4.5: Programs for Machine Learning. Morgan Kaufmann series in
machine learning. Morgan Kaufmann.
Quinlan, J. (1993b). FOIL: A midterm report. In Brazdil, P. (Ed.), Proceedings of the 6th
European Conference on Machine Learning, Lecture Notes in Artificial Intelligence.
Springer-Verlag.
Santos Costa, V., Srinivasan, A., & Camacho, R. (2000). A note on two simple transformations for improving the eciency of an ILP system. In Proceedings of the Tenth
International Conference on Inductive Logic Programming, Vol. 1866 of Lecture Notes
in Artificial Intelligence, pp. 225{242. Springer-Verlag.
Sebag, M., & Rouveirol, C. (1997). Tractable Induction and Classification in First-Order
Logic via Stochastic Matching. In Proceedings of the 15th International Joint Conference on Artificial Intelligence. Morgan Kaufmann.
Sellis, T. (1988). Multiple-query optimization. ACM Transactions on Database Systems,
13 (1), 23{52.
Srinivasan, A. (1999). A study of two sampling methods for analysing large datasets with
ILP. Data Mining and Knowledge Discovery, 3 (1), 95{123.
Srinivasan, A. (2000). A study of two probabilistic methods for searching large spaces with
ILP. Tech. rep. PRG-TR-16-00, Oxford University Computing Laboratory.

165

fiBlockeel, Dehaspe, Demoen, Janssens, Ramon, & Vandecasteele
Srinivasan, A., Muggleton, S., & King, R. (1995). Comparing the use of background knowledge by inductive logic programming systems. In De Raedt, L. (Ed.), Proceedings of
the Fifth International Workshop on Inductive Logic Programming.
Tsur, D., Ullman, J., Abiteboul, S., Clifton, C., Motwani, R., Nestorov, S., & Rosenthal, A.
(1998). Query ocks: A generalization of association-rule mining. In Proceedings of
the ACM SIGMOD International Conference on Management of Data (SIGMOD-98),
Vol. 27,2 of ACM SIGMOD Record, pp. 1{12, New York. ACM Press.

166

fiJournal of Artificial Intelligence Research 16 (2002) 59-104

Submitted 5/01; published 2/02

Accelerating Reinforcement Learning by Composing
Solutions of Automatically Identified Subtasks
Chris Drummond

School of Information Technology and Engineering
University of Ottawa, Ontario, Canada, K1N 6N5

cdrummon@site.uottawa.ca

Abstract

This paper discusses a system that accelerates reinforcement learning by using transfer
from related tasks. Without such transfer, even if two tasks are very similar at some
abstract level, an extensive re-learning effort is required. The system achieves much of its
power by transferring parts of previously learned solutions rather than a single complete
solution. The system exploits strong features in the multi-dimensional function produced
by reinforcement learning in solving a particular task. These features are stable and easy
to recognize early in the learning process. They generate a partitioning of the state space
and thus the function. The partition is represented as a graph. This is used to index and
compose functions stored in a case base to form a close approximation to the solution of
the new task. Experiments demonstrate that function composition often produces more
than an order of magnitude increase in learning rate compared to a basic reinforcement
learning algorithm.

1. Introduction
A standard reinforcement learning algorithm, applied to a series of related tasks, could learn
each new task independently. It only requires knowledge of its present state and infrequent
numerical rewards to learn the actions necessary to bring a system to some desired goal
state. But this very paucity of knowledge results in a slow learning rate. This paper shows
how to exploit the results of prior learning to speed up the process while maintaining the
robustness of the general learning method.
The system proposed here achieves much of its power by transferring parts of previously
learned solutions, rather than a single complete solution. The solution pieces represent
knowledge about how to solve certain subtasks. We might call them macro-actions (Precup,
Sutton, & Singh, 1997), with the obvious allusion to macro-operators commonly found in
Artificial Intelligence systems. The main contribution of this work is in providing a way of
automatically identifying these macro-actions and mapping them to new tasks.
This work uses syntactic methods of composition much like in symbolic planning, but the
novelty arises in that the parts being composed are multi-dimensional real-valued functions.
These functions are learned using reinforcement learning as part of more complex functions
associated with compound tasks. The ecacy of this approach is due to the composition
occurring at a suciently abstract level, where much of the uncertainty has been removed.
Each function acts much like a funnel operator (Christiansen, 1992), so although individual
actions may be highly uncertain, the overall result is largely predictable.
c 2002 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiDrummond

The subtasks are identified on the basis of strong features in the multi-dimensional
function that arise during reinforcement learning. The features are not \in the world",
but in the system's interaction with the world. Here, \strong" means that the features are
stable (i.e. relatively insensitive to variations in the low level learning process) and easy
to recognize and locate accurately early in the learning process. One important aspect of
these features is that they largely dictate the shape of the function. If the features differ by
a small amount, one would expect the function to differ by a small amount.
The features generate a partitioning of the function. A popular technique in object
recognition, the snake (Kass, Witkin, & Terzopoulus, 1987; Suetens, Fua, & Hanson, 1992),
is used to produce this partition. In object recognition, the snake produces a closed curve
that lies along the boundary of an object, as defined by edges in an image. In this application, the snake groups together sets of features to define a region of the function. The
boundary of the region is a low order polygon, demarcating an individual subtask. This
is repeated until the whole function is covered. The polygons are converted into discrete
graphs, a vertex of the polygon becoming a node of the graph. Merging these graphs
produces a composite graph representing the whole task.
The composite graph is used to control the transfer by accessing a case base of previously
learned functions. The case base is indexed by graphs. The relevant function is determined
by matching a subgraph of the composite graph with one acting as an index to a case. The
associated functions are transformed and composed to form a solution to the new task. This
is used to reinitialize the lower level learning process. It is not necessary for the transfer to
produce an exact solution for the new task. It is sucient that the solution is close enough
to the final solution often enough to produce an average speed up. Reinforcement learning
will further refine the function and quickly remove any error.
This paper demonstrates the applicability of transfer in two different situations. In the
first, the system learns a task for a particular goal position and then the goal is moved.
Although the function itself will change significantly, the partition generated on the initial
task can be used to compose the function for the new task. In the second situation considered, the system is placed in a different environment within the same domain. Here, a new
partition has to be extracted to control the composition process.
This paper unifies and significantly extends previous work by the author (Drummond,
1997, 1998). Additional work has largely focussed on removing some of the limitations
inherent in the partitioning approach introduced in Drummond (1998). One limitation of
the original approach was that the snake could only extract polygons that were rectangles.
This paper relaxes this restriction, allowing it to be applied to a different environment
within the same domain and to a different task domain. Although lifting this restriction
removes some desirable bias, the experiments demonstrate that none of the ecacy of the
original system is lost. Further, the results are more broadly obtained on the larger set of
related tasks and in a different domain. Overall, the function composition approach often
produces more than an order of magnitude increase in learning rate when compared to a
basic reinforcement learning algorithm.
The rest of the paper begins with Section 2 giving a very high level discussion of the
approach taken. Section 3 gives a more in depth discussion of the techniques used. Sections 4 and 5 present and analyze the experimental results. Subsequent sections deal with
limitations and related research.
60

fiAccelerating Reinforcement Learning

2. An Overview
The intent of this section is to appeal to the intuitions of the reader, leaving much of the
detail to later sections in the paper. The subsections that follow will demonstrate in turn:
that there are features in the function produced by reinforcement learning; that graphs
based on these features can be used to control the composition of the function pieces; that
these features are easy to detect early in the learning process; that these features exist in
multiple domains.

2.1 Features in the Reinforcement Learning Function
This overview begins with a very high level introduction to reinforcement learning and the
function it produces. It will show that there are features in this function which can be
extracted and converted into a graphical representation.
One of the experimental test beds used is this paper is a simulated robot environment of
different configurations of interconnected rooms. The robot must learn to navigate eciently
through these rooms to reach a specified goal from any start location. Figure 1 shows one
example with 5 rooms and the goal in the top right corner. The robot's actions are small
steps in any of eight directions, as indicated by the arrows. Here, the location, or state,
is simply the robot's x and y coordinates. The thin lines of Figure 1 are the walls of the
rooms, the thick lines the boundary of the state space.
+1
Goal

Robot
10

Y

11

11
12

12
13

13

14

-1
X
-1

+1

Figure 1: Robot Navigating Through a Series of Rooms
61

fiDrummond

If each action is independent of preceding actions, the task becomes one of learning
the best action in any state. The best overall action would be one that takes the robot
immediately to the goal. But this is only possible in states close to the goal. Suppose
the robot is in a particular state and that the number of steps to goal from each of its
neighboring states is known, indicated by the numbered squares surrounding the robot in
Figure 1. Then a one step look ahead procedure would consider each step and select the
one that reaches the neighboring state with the shortest distance to goal. In Figure 1 the
robot would move to the state 10 steps from goal. If this process is repeated, the robot will
take the shortest path to goal. In practice we must, of course, learn such values. This can
be done using some type of reinforcement learning (Watkins & Dayan, 1992; Sutton, 1990)
which progressively improves estimates of the distance to goal from each state until they
converge to the correct values.
(-1.0,1.0)

(0.25,1.0)

(0.25,0.9) O

I
(-1.0,0.25)

(-0.9,0.25)
(0.25,0.25)

Figure 2: The Value Function Obtained Using Reinforcement Learning
The function shown in Figure 2 is called the value function. Subsequently, the term
function will mean the value function unless otherwise indicated. The function is the result
of reinforcement learning on the problem of Figure 1, but instead of it representing the
actual distance to goal, it represents essentially an exponential decay with distance to goal.
The reasons for this will be made clear in Section 3.1. The shaded areas represent large
gradients in the learned function. Comparing this to the environment shown in Figure 1, it
is apparent that these correspond to the walls of the various rooms. These are the strong
features discussed in this paper. They exist because of the extra distance for the robot
to travel around the wall to reach the inside of the next room on the path to the goal.
These features are visually readily apparent to a human, so it seems natural to use vision
processing techniques to locate them.
An edge detection technique called a snake is used to locate these features. The snake
produces a polygon, in this instance a rectangle, locating the boundary of each room. The
doorways to the room occur where the differential of the function, along the body of the
snake, is at a local minimum. The direction of the differential with respect to edges of
62

fiAccelerating Reinforcement Learning

the polygon, associated with the walls of the room, determines if it is an entrance or an
exit. A positive gradient into the room indicates an entrance; a positive gradient out of
the room indicates an exit. From this information, a plane graph, labeled with an (x; y)
coordinate for each node, is constructed. Figure 2 shows one such example, for the room
at the top left corner of the state space, subsequent graphs will not show the coordinates.
Nodes corresponding to the doorways are labeled \I" or \O" for in and out respectively;
their positions on the function are indicated by the dashed arrows.

2.2 Composing Function Pieces

This overview continues by showing how the graphs, extracted from the features in the
function learned by reinforcement learning, can be used to produce a good approximation
to the solution for a new goal position. The left hand side of Figure 3 shows plane graphs
for all the rooms (ignore the dashed lines and circles for now). The node representing the
goal is labeled \G". A directed edge is added from \I" to \O" or \I" to \G", as appropriate.
Associated with this edge is a number representing the distance between the nodes. This is
determined from the value of the function at the points of the doorways. Each individual
graph is then merged with its neighbor to produce a graph for the whole problem, the right
hand side of Figure 3. The doorway nodes have been relabeled to \D". The composite
graph represents the whole function. Each individual subgraph represents a particular part
of the function. This information is stored in a case base. Each subgraph is an index and
the corresponding part of the function is the case.

O

G

I

Extract
Graphs

G

I

Merge
Graphs

G

O

D

G

I
D
O

D

I
O

D

Figure 3: Graphical Representation
Now suppose the goal is moved from the top right corner to the top left corner of the
state space. Reinforcement learning in its most basic form would be required to learn the
new function from scratch. In this work if the goal is moved, once the new goal position
63

fiDrummond

is known, the node representing the goal can be relocated. The new goal position is shown
as the dashed circle in Figure 3. The edges connecting the doorways and the goal are
changed to account for the new goal position. The dashed lines representing the new edges
replace the arrows in the same subgraph. To produce a new function, the idea is to regress
backwards from the goal along these edges. For each edge, the small subgraph containing
the edge is extracted. The extracted subgraph is used to index the case base of functions.
The retrieved function is transformed and added to the appropriate region of the state space
to form the new function.
Rotate
Stretch

Rotate
I

G

Stretch

I

Figure 4: Function Composition
In this example, some of the existing subgraphs match the new configuration. The two
that do not are the subgraph originally containing the goal and the subgraph now containing
the goal. It is certainly possible to exchange these two, using an appropriate transform.
But other graphs in the case base may better match the new task. The best match for
the subgraph containing the new goal is, in fact, the subgraph for the goal in the original
problem. To fit this to the new task, the plane graph is rotated and stretched slightly in
the new x direction by changing the coordinates of its nodes, see Figure 4. Then this same
transformation is applied to the function. But for the room containing the original goal, a
case obtained when solving another task is a better match. The other three rooms use the
functions from the original problem, since changing the goal position has little effect on the
actions taken. In fact, only the height of the functions must be changed. This is simply
a multiplication by a value representing the distance to goal from the \O" doorway (this
is discussed in detail at the end of Section 3.3). Because the matching of the subgraphs
allows some error and asymmetric scaling may be used, the resulting function may not be
exact. But as the experiments will demonstrate, the function is often very close and further
reinforcement learning will quickly correct any error.
64

fiAccelerating Reinforcement Learning

The new position of the goal must be established before the graph can be modified and
function composition can occur. The system is not told that the goal has moved, rather it
discovers this by determining that it is no longer at the maximum of the existing function.
There is some uncertainty in the exact boundary of the original goal. The robot may reach
a state which it believes is part of the original goal region, but fail to detect it even if
the goal has not moved. To be reasonably certain that the goal has in fact moved, this is
required to occur ten times with no intervening occurrence of the goal being detected at
the maximum.
The system then composes a search function, by assuming a particular room contains
the goal. Search functions are also produced by composing previously learned functions.
However, for the room assumed to contain the goal the function is a constant. This does
not bias the search to any particular part of the room and allows some limited learning to
encourage exploration of the room. The search function drives the robot into the room from
anywhere else in the state space. If it fails to find the goal after a fixed number of steps,
a new search function is composed with another room assumed to contain the goal. This
process is repeated until the goal has been located ten times, this ensures a good estimate
of the \center of mass" of the goal. The \center of mass" is used as the new position of
the goal node in the composite graph. Requiring that the old goal or new goal positions
are sampled a fixed number of times has proven to be effective in the domains discussed in
this paper. Nevertheless, it is a somewhat ad hoc procedure and will be addressed in future
work, discussed in Section 6.2.

2.3 Detecting Features Early
In the previous section, the existing task and the new task were strongly related, the walls
and doorways were fixed and only the goal position was different. In this section, no such
relationship is assumed. The robot is faced with a brand new task and must determine
what, if any, relationship exists between the new task and any previous tasks.
The experimental testbed is again a simulated robot environment, but this time the
problem is simplified to just an inner rectangular room and an outer L-shaped room. Figures
5 and 6 show two possible room configurations. Again, the thin lines are the walls of the
room, the thick lines the boundary of the state space. Suppose the robot had already
learned a function for the \Old Task" of Figure 5. We would hope that we could adapt the
old solution to fit the closely related \New task" of Figure 6.
The steps, in this example, are essentially those in the previous one. But now as the
learning process is started afresh, there are no features and the system must wait until they
emerge through the normal reinforcement learning process. Then we can proceed much as
before. First a graph for the inner room is extracted. The best matching graph in the
case base from the old task is rotated and stretched to fit the new task. Next a matching
graph for the outer L-shaped room is rotated and stretched around the larger inner room.
The same transforms are then applied to the associated functions, any height adjustments
carried out and the functions composed to form an approximate solution to the new task.
In this example, the first step in the process is to locate the goal. As there is no
partition to aid the search, the initial value function is set to a mid-range constant value
(see Figure 7). This allows some limited learning which encourages the system to move
65

fiDrummond

Goal

Robot

Outer
Room

Inner
Room

Robot

Inner
Room

Outer
Room

Goal

Figure 5: The Old Task

Figure 6: The New Task

away from regions it has explored previously, to prevent a completely random walk through
state space. Once the goal is located, the learning algorithm is reinitialized with a function
for the same goal position but no walls (see Figure 8). If such a function does not exist in
the case base, any rough approximation could be used instead. The \no walls" function is
not used exactly as stored in the case base. The difference between the goal and the rest of
the state space is reduced by scaling the function then adding a constant. This reduces the
\bias" of the function, allowing the learning algorithm to alter it relatively easily as new
information becomes available.

Figure 7: Start Function

Figure 8: Intermediate Function

Figure 9 shows the resultant function about 3000 exploratory steps from the beginning
of the learning process. Again, the large gradients associated with the walls are readily
66

fiAccelerating Reinforcement Learning

apparent. Figure 10 shows the function for the new task if it had been allowed to converge
to a good solution. Both functions have roughly the same form, the large gradients are
in the same position, although learning the latter took some 200,000 steps. After the \no
walls" function is introduced the features take some time to clearly emerge. The snake will
typically filter out features that are too small and not well formed. Additional filtering at
the graphical level further constrains acceptable features. The total set of features must
produce a consistent composite graph, the doorways from different subgraphs must align
and the graph must overlay the complete state space. There must also be a matching case
in the case base for every subtask. Many of these checks and balances will be removed when
the iterative updating technique of Section 6.2 is incorporated.

Figure 9: Early Function

Figure 10: New Task Function

2.4 A Different Task Domain

The previous sections dealt with a simple robot navigation problem. This section demonstrates that these features also exist in a quite different domain, that of a two degrees of
freedom robot arm, as shown in Figure 11. The shoulder joint can achieve any angle between  radians, the elbow joint any angle between =2 radians, zero is indicated by the
arrows. If the arm is straight and the shoulder joint rotated, the elbow joint will describe
the inner dotted circle, the hand the outer dotted circle. There are eight actions, small
rotations either clockwise or anti-clockwise for each joint separately or together. The aim
is to learn to move the arm eciently from any initial position until the hand reaches the
goal on the perimeter of the arm's work space.
The state space, for the purposes of reinforcement learning, is the configuration space
for the arm, sometimes called the joint space (see Figure 12). The x-axis is the angle of the
shoulder joint, the y-axis the elbow joint. The eight actions when mapped to actions in the
configuration space become much like the actions in the robot navigation problem, as shown
by the shaded diamond (labeled Arm) in Figure 12. To map an obstacle in the work space
to the configuration space, one must find all pairs of shoulder and elbow angles blocked by
the obstacle. The obstacles in this space become elongated to form barriers much like the
67

fiDrummond

+/2

Shoulder

Hand

0

Elbow Angle

Obstacle

00
11
11
00
00
11
00
11
11
00

G
O
A
L

1111111
0000000
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111

Arm

0

Obstacle

Elbow
0

/2


Obstacle
00
11
11
00
00
11
00
11
11
00

Figure 11: Work Space

0000000
1111111
1111111
0000000
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111
0000000
1111111

Obstacle

G
O
A
L

0
Shoulder Angle

+

Figure 12: Configuration Space

walls in the experiments of the previous sections. If this is not clear, imagine straightening
the arm in the work space and rotating it such that it intersects one of the obstacles, the
middle dotted line in Figure 11. The arm can then be rotated at the shoulder joint with a
roughly linearly proportional rotation in the elbow joint, but in the opposite direction, such
as to keep it intersecting the obstacle. This produces the \wall" in the configuration space.
This linearity holds only for small objects not too far from the perimeter of the work space.
More complex, larger objects, would result in more complex shapes in the configuration
space. At the moment the feature extraction method is limited to these simpler shapes,
this will be discussed further in Section 6.
The reinforcement learning function produced by this problem is shown in Figure 13. As
before the features are shaded for clarity. The large gradient associated with the obstacle
on the left hand side of the configuration space can be clearly seen. There is a similar large
gradient associated with the obstacle on the right hand side of the configuration space.
Again, these features can be used to control the composition of functions if the goal is
moved or for a different task in the same domain.

3. Details of the Techniques Used
This section will discuss in more detail the techniques used. These include: reinforcement
learning to produce the initial function, snakes to extract the features producing the graph,
and the transformation and composition of the subgraphs, and their corresponding functions, to fit the new task.

3.1 Reinforcement Learning

Reinforcement learning typically works by refining its estimate of expected future reward.
In goal-directed tasks, such as the ones investigated here, this is equivalent to progressively
68

fiAccelerating Reinforcement Learning

Figure 13: The Robot Arm Function
improving the estimate of the distance to goal from each state. This estimate is updated
by the best local action, i.e. the one moving the robot, or arm, to the new state with the
smallest estimated distance. Early in the learning process, only states close to the goal are
likely to have accurate estimates of true distance. Each time an action is taken, the estimate
of distance at the new state is used to update the estimate at the old state. Eventually this
process will propagate back accurate estimates from the goal to all other states.
Rather than directly estimating Pthe distance to goal, the system uses the expected
t
discounted reward for each state E [ 1
t=1  rt ]. The inuence of rewards, rt , are reduced
progressively the farther into the future they occur by using a  less than one. In this work,
the only reward is for reaching the goal. So the farther the state is from the goal the smaller
the value. The use of an expectation allows the actions to be stochastic, so when the robot,
or arm, takes a particular action in a particular state, the next state is not always the same.
To carry out reinforcement learning, this research uses the Q-learning algorithm (Watkins
& Dayan, 1992). This algorithm assumes the world is a discrete Markov process, thus both
states and actions are discrete. For each action a in each state s, Q-learning maintains a
rolling average of the immediate reward r plus the maximum value of any action a0 in the
next state s0 (see Equation 1). The action selected in each state is usually the one with the
highest score. But to encourage exploration of the state space, this paper uses an -greedy
policy (Sutton, 1996) which chooses a random action a fraction  of the time. The only
effect that function composition has on the Q-learning algorithm is that the initial value
for each state-action pair is set to some value other than zero.
(1)
Qts;a+1 = (1 , ff)Qts;a + ff(r + maxa Qts ;a )
The Q-function over state and action is usually referred to as the action-value function.
In this paper, it is the action-value function that is transformed and composed to form a
solution to the new task. The value function, discussed in previous sections and shown in
0

69

0

0

fiDrummond

the figures, is the maximum value of the Q-function. It is used to generate the partition
and associated graphs needed to control the process.
Watkins and Dayan (1992) proved that Q-learning will converge to the optimal value
with certain constraints on the reward and the learning rate ff. The optimal solution is produced by taking the action with the greatest value in any state. So, for goal-directed tasks,
a greedy algorithm will take the shortest path to the goal, once learning is complete. The
extension to continuous spaces may be done using function approximation. The simplest
method, and the one used here, is to divide the state dimensions into intervals. The resulting action-value function has cells representing the average Q-value of taking each action
from somewhere within a region of the state space. In off-line learning, where any action
in any state can be executed, this representation has been proven to converge (Gordon,
1995). In on-line learning, where the current state is determined by the environment, this
approach is generally successful, but there exists no proof of its convergence.

3.2 Feature Extraction
Feature extraction uses a vision processing technique that fits a deformable model called
a snake (Kass et al., 1987) to edges in an image. After initializing the snake, the process
iterates until external forces, due to the edges, balance internal forces in the snake that
promote a smooth shape. Here, the external forces are due to steep gradients in the value
function. As a piecewise constant function approximator is used, a smoothed cubic b-spline
is fitted to the value-function and used to generate the necessary derivatives. The left hand
side of Figure 14 is the gradient of the value function shown in Figure 9 when extracting
features early in the learning process. The system has added a gradient around the border
to represent the state space boundary.
To locate the features, a curve is found that lies along the ridge of the hills, a local
maximum in the differential. On the right hand side of Figure 14, the dashed lines are
contour lines for the small inner room as indicated. The bold lines, on the right hand side
of Figure 14, are the snake at different stages of the process. The snake is first positioned
approximately in the center of the room, the innermost circle. It is then expanded until
it abuts on the base of the hills. Now to simplify the exposition, we can imagine that the
snake consists of a number of individual hill climbers spread out along the line representing
the snake, indicated by the small white circles. But instead of being allowed to climb
independently, their movement relative to each other is constrained to maintain a smooth
shape. When the snake reaches the top of the ridge, it is further constrained to be polygon
{ in this instance a quadrilateral { the outside dark line in Figure 14. At this point, it
will tend to oscillate around an equilibrium position. By limiting the step size the process
can be brought into a stationary state. A more detailed mathematical treatment of this
approach is given in Appendix A.
The polygon forms the \skeleton" for the graph, as shown at the top left of Figure 14.
Nodes in a graph correspond to vertices of the polygon and to the doorways and the goal.
Looking at the gradient plot, the doorways are regions with a small differential between
the ridges. Their locations can be determined from the magnitude of the gradient along
the boundary of the polygon. In this example, a node is added for the goal (labeled G)
and this is connected to the \in" doorway (labeled I). The polygon delimits a region of
70

fiAccelerating Reinforcement Learning

Graph

G

Polygon

I

Doorway

Figure 14: The Gradient and Resultant Polygon (Left) Extracted by the Snake (Right)
the state space, and therefore a region of the action-value function. This becomes a case
in the case base, and the corresponding graph its index. Constraining the snake to be a
polygon is done for two reasons. Firstly, the vertices are needed to produce nodes in the
plane graphs, which are important part of the matching process. Secondly, the additional
constraint results in a more accurate fit to the boundaries of the subtask. This, in turn,
results in a more accurate solution after function composition.

3.2.1 Three Extensions to the Snake Approach
This section introduces three extensions to the basic snake approach to facilitate the extraction of features.
The first extension affects the direction the snake moves when hill climbing the gradient.
In normal hill climbing, each step is taken in the direction of steepest ascent, the step size
being determined by the size of the differential. Roughly, this translates into forces at points
along the body of the snake. Each force points in the direction of steepest ascent locally, but
interacts with other forces through the various shape constraints. Looking at the gradient
function and contour lines of Figure 14, there is a steep slope leading to the top of each
ridge. But there is also a significant slope along each ridge away from the doorway towards
the boundary of the state space. Thus the force on a single point on the body of the snake
71

fiDrummond

is not directly towards the top of the ridge but turned towards its apex, as indicated by the
bold black arrow on the left hand side of Figure 15.
Snake

Steepest
Ascent
Tangent
Normal

Figure 15: Controlling Forces on the Snake
This force can be broken into two components with respect to the snake, a normal and
a tangential force. The latter force acts along the body of the snake. Once the shape is
constrained to be a quadrilateral, this will cause the relevant side to shrink. This effect will
be partially counteracted by the force towards the top of the ridge on the adjacent side of
the quadrilateral. But the net result will be a shrinking of the two sides associated with the
ridges inwards until the forces are balanced. This will push the corner of the quadrilateral
near the doorway inwards, as indicated by the thin black arrow in Figure 15. In an extreme
case, this might cause the snake to collapse into something close to a triangle. But the more
likely outcome will just be a degradation of the accuracy of registration of the ridges.
Drummond (1998) prevented this degradation of the accuracy by restricting the snakes
to rectangular shapes. But with the weakening of this constraint to more general polygons,
this effect again becomes a problem. This problem is addressed by removing the component
of the force tangential to the snake. Then hill climbing is always in the direction of the
normal. This does not significantly restrict the motion of the snake: all that is being removed
is the component along the body of the snake. Thus it mainly prevents the stretching and
shrinking of the snake due to the gradient.
The second extension controls the way the snake is expanded to reach the base of the
hills. Drummond (1998) used a ballooning force, as introduced by Cohen and Cohen (1993).
But problems arose when extending the system to deal with more general shapes than
rectangles, such as the outer L-shaped room in Figure 6. The ballooning force expands the
snake in directions normal to its body. One deleterious effect of this is if the snake contacts
a sharp external corner, such as that of the inner room, the force tends to push the snake
through the corner. This can be seen in Figure 16; the bold continuous lines are the snake;
the bold dashed lines are the ridges. If we imagine starting off with a circular snake in the
72

fiAccelerating Reinforcement Learning

middle of the L-shaped outer room, by the time it reaches the walls of the inner room the
sides of the snake are roughly perpendicular to the ridges. Thus there is little to restrain
the expansion of the snake and it passes completely through the walls of the inner room.
Ridge

Ballooning
Force

Ridge

Figure 16: Using the Ballooning Force
The approach adopted here is analogous to the ow of mercury. If we imagine starting
somewhere in the middle of the L-shaped room and progressively adding mercury, it would
tend to fill up the lower regions of the valley first and reach the bases of the hills roughly at
the same time. The analogy of mercury is used as it has a high surface tension preventing
it from owing through small gaps in the edges associated with doorways. To increase the
effectiveness of this idea, the absolute value of the differential of the gradient is thresholded,
values above the threshold being set to one those below to zero. It is then smoothed with
a truncated Gaussian, as shown in Figure 17. Smoothing and thresholding are commonly
used techniques in machine vision (Tanimoto, 1990). They are typically used to remove
noise, but here the aim is to strongly blur the thresholded image. This produces bowls
associated with each room. In this example, the smoothing has almost completely obscured
the presence of the doorway, although this is generally not the case.
The snake is initialized as a small circle at the minimum of one of these bowls. This
is shown as the circle in the middle of Figure 18, where the dashed lines are the contour
lines of this function. It then ows outwards, so as to follow the contour lines of the bowl;
the largest component of the ow being in the direction of the arrows in Figure 18. This
is achieved by varying the force normal to the body of the snake according to the height
difference with the average height of the snake. Thus points along the snake which are
higher than average tend to get pushed inwards, those lower pushed outwards. The surface
tension of the mercury is produced by various smoothing constraints on the first and second
differentials of the snake (see Appendix A).
The third extension limits changes in the shape of the snake as it expands from its initial
position to reach the base of the hills. The smoothness constraints on the snake, that give
the mercury-like properties, prevent the snake owing through the gaps associated with the
73

fiDrummond

Figure 17: Smoothed Function

Figure 18: Mercury Flow

doorways. But even this proved insucient if the width of the rooms and the width of
doorways were of similar sizes. In Figure 12, looking at the \room" on the left hand side
of the configuration space of the robot arm, the \doorway" and the \room" at the top are
of similar width. Increasing the surface tension of the mercury suciently to prevent ow
through the doorways also prevents the ow to the top of the room.
The solution is to limit the amount the snake can change its shape as it grows. This
is achieved by constraining how much the second differential of the snake can change from
step to step. In Figure 18, it is apparent that the snake takes up a good approximation
to the shape of the room some time before it reaches the ridges. If the shape can be
locked-in before reaching the ridges, the problem just described can be avoided. When
the snake is initialized, the only constraint is smoothness. As the snake is expanded, this
smoothness constraint is progressively weakened and the curvature constraint progressively
strengthened. This progressively locks in the shape while still allowing the snake to make
small local adjustments to better fit the features.
The extensions, discussed in this section, either modify the traditional forces that act
on the snake or add new ones. There are also forces associated with knot spacing and drag.
How the snake moves, with each iteration, depends on the vector addition of these forces.
The sum acts to accelerate the body of the snake which has both mass and velocity, and
therefore momentum. A schematic representation of these forces is shown in Figure 19; a
more detailed mathematical description is given in Appendix A. The dashed line represents
the body of the snake; the arrows are the forces applied to one point on the body. The snake
is a parameterized function, given by f^(s) = (x(s); y(s)) where x(s) and y(s) are individual
cubic b-splines giving the x and y coordinates associated with a variable s along the body
of the snake. The circles represent points equi-distant in s but not necessarily in x and y.
These points are kept roughly the same Euclidean distance apart in x and y due to the knot
spacing force. The momentum, although not strictly a force, encourages the point to move
74

fiAccelerating Reinforcement Learning

in constant direction; the drag opposes any motion. The stiffness encourages the snake to
maintain a smooth shape. The overall stiffness is reduced as the snake grows, to keep its
exibility per unit length roughly constant, and is also controlled locally to maintain its
shape.
Steepest Ascent

MercuryFlow
Momentum

Knot Spacing

Drag
Stiffness

Figure 19: The Forces on the Snake
The following is an algorithmic summary of the processing of the snake:

 Initialize the coecients to produce a circular snake in the middle of a room.
 Iterate until the forces are roughly in equilibrium and the snake oscillates around a
stationary value.

 Modify the stiffness to enforce the polygonal constraints
 Iterate for a further 25 steps increasing the momentum and drag at each step to reduce
the oscillation to a small value.

 Use the final position of the snake to form the polygon that delimits the boundary of
the room.

3.3 Transformation

This section discusses the matching process { how a subgraph is used to locate and transform
a function from the case base. The matching process first finds all subgraphs in the case base
isomorphic to the extracted subgraph and all possible isomorphic mappings between their
nodes, using a labeling algorithm (MacDonald, 1992). The number of isomorphic mappings
75

fiDrummond

is potentially exponential in the number of nodes. Here, the graphs typically have only
a few nodes and a few symmetries, so only a few isomorphic mappings. Associated with
each node of a subgraph is an (x; y) coordinate. An ane transform, Equation 2, is found
that minimizes the distances between the coordinates of the mapped nodes for each of the
isomorphic subgraphs. The advantage of this transform is its relative exibility while having
a simple form.

x0 = C0 x + C1 y + C2 y0 = C3 x + C4 y + C5
(2)
Ideally the transformed nodes would be positioned exactly over the mapped nodes, but
this is not usually possible. Even with simple rectangular shapes, the case base may not
contain a graph with exactly the same doorway positions. Using a graph that is not an
exact match will introduce some error in the composed function for the new task. By
weighting some nodes more than others where the error occurs can be controlled. One aim
is to minimize the introduction of errors that affect the overall path length. However, of
equal importance is that the errors introduced be easily correctable by normal reinforcement
learning.
1

1

2 4

1

2

1

Figure 20: Weighting Graph Nodes
The left hand side of Figure 20 shows the composite graph for the new task. The right
hand side shows the result of overlaying it with a graph from the case base. If the fit at the
doorway of the outer L-shaped room is in error, the robot will tend to miss the doorway
and collide with the wall on one side. The farther the doorway is out of position, the longer
normal reinforcement learning will take to correct the error. To encourage a good fit at
the doorway, a weight of 4 is used. Nodes adjacent to the doorway are given a weight of 2,
all other nodes have a weight of one. This is based on the intuition that more trajectories,
from different parts of the state space, will be pass through the region close to the doorway.
Any error here is likely to have a broader effect, and take longer for normal reinforcement
76

fiAccelerating Reinforcement Learning

learning to correct, than in regions far from the doorway. So the fit around the inner room
is improved by sacrificing fit far from the doorway.
The exact position of the doorway in the inner room is not critical and its weight is
set to 0.5. Whatever the position of the doorway, the shape of the function will be correct
inside the room as the goal is also in this room. However, the further the doorway is from
its correct position, the greater the error in the edge length. This will produce some error
in the composed function, but again the expectation is that this error will be small and
reinforcement learning will quickly correct it.
Not only should the fit be good, but we would also prefer that the amount of transformation be small. All transforms produce some error and this is particularly true of
asymmetric scaling, as discussed later in this section. Generally the transform produces
translation, reection, rotation, shearing and independent scaling in each dimension. In
the robot navigation domain, the distance between points in the state space is just the
normal Euclidean distance. The reinforcement learning function is an exponential decay
in the distance to goal. If the transformation does not change the Euclidean distance, the
transformed function should be directly applicable.

Affine  Similar  Symmetric
(3)
The ane transformation is just one family in a hierarchy of transformations. At the
bottom of this hierarchy, shown in Equation 3, are the symmetric transformations. These
solid body transformations do not change the Euclidean distance. The next step up in
the hierarchy introduces scaling, equal in each dimension. This will affect the Euclidean
distance but only by a multiplicative factor. Thus the only change needed to the transformed
function is to scale the height. The ane transformations allow the addition of asymmetric
scaling and shear, which will distort the Euclidean distance. To determine the amount
of distortion, the transformation is applied to the unit circle. The symmetric, rigid body,
transformations will not alter the circle, but the other transformations will. The symmetric
scaling transform just changes the diameter of the circle. The asymmetric scaling and shear
transformations change the circle into the ellipse. The amount of distortion of the Euclidean
distance introduced by the transform can be determined by the ratio of lengths of the major
and minor axes of the ellipse.
error = sqrt
(P
wi(
x2 + yi2 )) (node misalignment)
fi2 i
fi i

fi
(Euclidean Distortion)
+ log2 fifi rrmaj
(4)
minfi
2

j
r
+
r
j
maj
min
+ 0:05 log2
(scaling factor)
2
The error of fit of the transformed subgraph can be combined with the transformation
error using the lengths of the major and minor axes, rmaj and rmin respectively, of the
ellipse. There is a penalty for Euclidean Distortion from asymmetric scaling and shear.
The log factor is added directly to the error of fit as shown in Equation 4. Log factors are
used, so that the penalty functions are symmetric. There is a small penalty for symmetric
scaling. Once the best matching subgraph has been found, the same transformation can be
applied to the associated function. If no isomorphic graph is found with a total error less
than 1.5, a constant function will be used as a default. Where the new graph overlays the
old graph, values are assigned by using bilinear interpolation on the discrete values of the
77

fiDrummond

function. Where it does not, bilinear extrapolation is used, based on the closest values. In
both cases once the four values are selected, the value for the new point is calculated as
shown in Equation 5. As the action-value function is indexed by action as well as state, this
process is carried out for each action in turn. Any rotation or reection in the transform
is also applied to a predefined matrix of actions. This produces the necessary mapping of
actions from the original to the new action-value function.

v = c1 x + c2 y + c2 xy + c3

(5)

Finally, the height of the new action-value function must be adjusted to account for the
change in overall distance to goal. The height of the value function at an \out" doorway is
 dg where dg is the distance to goal and  the discount factor. The value at some random
point within the room is  dg+dd where dd is the distance to the doorway. The action-value
function is first normalized by dividing by  dg , the height of the function at the doorway
in the original problem. It is then multiplied by  dng , where dng is the distance to the
new goal; the value of the point becomes  dng+dd . Scaling will also affect the height of the
function. Assuming the scaling is symmetric then the new value function for anywhere in
the room will be  cdd where c is the scale factor. Thus raising the function to the power of c
i.e. ( dd )c will account for scaling. When scaling is symmetric the result is exact, assuming
distance is based on the linear combination of the two dimensions. With asymmetric scaling,
the result is not exact. But if the difference between the two scale factors is relatively small,
it is a useful approximation to use their maximum.
The following is an algorithmic summary of the whole matching process:

 SG = subgraph extracted from the new task.
 For each subgraph G acting as an index to the case base

{ For each isomorphic mapping of G to SG
 Find minimum weighted least squares fit of G to SG using mapping
 Ane transform = coecients of least squares fit
 Penalized fit = least squares error + transform penalty
 Keep graph and transform with lowest penalized fit
 Retrieve function associated with best graph from case base (if none use default)
 Apply ane transform to function
 Apply bilinear interpolation/extrapolation
 Adjust function height
 Add new function to existing function
78

fiAccelerating Reinforcement Learning

3.4 Composition

This section describes function composition, how the transformation is applied successively
to the series of subgraphs extracted from the composite graph. Function composition uses a
slightly modified form of Dijkstra's algorithm (Dijkstra, 1959) to traverse the edges between
doorway nodes. The left hand side of Figure 21 shows the composite graph after moving
the goal in the robot navigation example of Section 2.2. The right hand side shows the
graph traversed by Dijkstra's algorithm.

G

d2

G

D

d1

D

Gr3

Gr1

D

D

d3

D

Gr2
D

D

Gr5

D

Gr4

Figure 21: Using Dijkstra's Algorithm
To begin the process, the subgraph which contains the goal is extracted and the best
matching isomorphic subgraph is found. The edge lengths in the composite graph are
then updated using the scaled length of the corresponding edge in the matching isomorphic
subgraph, d1 and d2 in Figure 21. As d2 is less than d1, the next subgraph extracted,
Gr2, is the one sharing the doorway node with the edge of length d2. The best matching
isomorphic subgraph is found and the edge of length d3 updated. The shortest path is
again determined. As d1 is less than d2 + d3 subgraph, Gr3 is extracted. The process is
repeated until all subgraphs have been updated. At each stage when a subgraph is matched,
the corresponding transformed function is retrieved and added to the new function in the
appropriate region.
In this example, there is only a single path to the goal from each room. Often there will
be multiple paths. Suppose room 5 had an additional doorway in the lower left corner of
the room, labeled \B" on the left hand side of Figure 22, in addition to the original doorway
labeled \A". The graph, shown on the right hand side of Figure 22, would result. There are
now two possible paths to the goal of lengths d4 and d5. If the length across room 5, d6, is
greater than the absolute difference between d4 and d5, the choice of path from this room
will be determined by a decision boundary inside the room. This is produced by taking the
79

fiDrummond

0110
11111110 Room 3
000000
10
A
10
1111111
0000000
0
Room 2 1
1010
000 10 Room 5
111
000 10
111
Room 4 1
0
Room 1

d5
A
n2

d4

d6

n1

Gr5
B

B

n3

Figure 22: Multiple Paths to Goal
maximum of two functions as shown in Figure 23: one for entering by doorway \A" and
leaving by doorway \B"; one for entering by doorway \B" and leaving by doorway \A".
This principle can be repeated if there are more than two paths to the goal from a given
room.
If the cross-room distance, d6, had been smaller than the difference (jd4-d5j) the decision
boundary would have to be in another room. In general, we want to find the room in which
the cross-room distance is larger than the difference between the incident paths. This is
repeated for every cycle in the path graph. A cycle is detected when a node is visited twice,
indicating that it is reachable by two separate paths. Let us suppose this is node n3 in the
graph of Figure 22. As Dijkstra's algorithm is being used, we know that all previous nodes,
on either path, such as n1 and n2 are already closed. This must be true for both paths
to have reached n3. All the rooms on paths up to these nodes cannot contain the decision
boundary, so it must be in either room 4 or 5. To decide which remaining room it is in, we
compare the two path lengths. If d4 is longer than d5 + d6 then the decision boundary will
be in room 4; otherwise it will be in room 5.
Whichever room is selected, the decision boundary is produced from the maximum of two
functions. The heights of the two functions, when adjusted for their path lengths, determine
where the decision boundary occurs within the room. If the paths are of equal length, taking
the maximum will correctly put the decision boundary at the doorway. If there are no such
functions in the case base, functions that already include decision boundaries may be used.
This technique produces a correct decision boundary if the difference in the path lengths
entering the room is less than the difference between the heights of the function at the \out"
doorways. On the left hand side of Figure 24 there is a room with two doorways. As path
1 is significantly longer than path 2, the decision boundary is far to the left. The shortest
path to the goal from most of the room is via the right hand doorway. If this function is
combined with a mirror image of itself, it will produce a decision boundary in the middle
80

fiAccelerating Reinforcement Learning

Maximum
Decision
Boundary

Figure 23: Combining Two Functions

Decision
Boundary

Path 1
Path2

Room

Figure 24: Decision Functions

81

fiDrummond

of the room, as shown on the right hand side of Figure 25. This could be used for the new
problem shown on the left hand side of Figure 25 where the two paths are the same length.
Again the heights of the two functions can be changed to move the decision boundary. But
it cannot be moved to anywhere in the room. The decision boundary can be moved no
closer to a particular doorway than in the original function shown in Figure 24
Decision
Boundary
Path 1

Path2

Room

Figure 25: Combining Decision Functions

4. Experiments

This section compares learning curves for function composition and a simple baseline algorithm. Four sets of results are presented; one for each of the two types of related task
in each of the two domains. The learning curves represent the average distance to goal as
a function of the number of actions taken during learning. The distance is averaged over
64 different start positions, distributed uniformly throughout the state space, and over the
different experimental runs. To determine this distance, normal learning is stopped after a
fixed number of actions and a copy of the function learned so far is stored. One of the 64
start positions is selected, learning is restarted and the number of actions needed to reach
the goal is recorded. If a trial takes 2000 actions and has not yet reached the goal, it is
stopped and the distance to goal recorded as 2000. The function is then reinitialized with
the stored version and another start state selected. This is repeated 64 times. Then the
function is reinitialized once more and normal learning resumed.
The baseline algorithm and the underlying learning algorithm for the function composition system is the basic Q-learning algorithm, using a discrete function approximator as
discussed in Section 3.1. The learning rate ff is set to 0.1, the greedy policy uses an  of 0.1
(the best action is selected 90% of the time), the future discount  is 0.8 and a reward of 1.0
is received on reaching the goal. Although the state spaces for the different domains represent two quite different things { the robot's hx; yi location and the angle of the arm's two
joints { the actual representation is the same. The state space ranges between 1 for each
dimension. A step is 0:25 in each dimension either separately or together, giving the eight
possible actions. The actions are stochastic, a uniformly distributed random value between
0:125 being added to each dimension of the action. In the robot navigation examples if
82

fiAccelerating Reinforcement Learning

the robot hits the wall, it is positioned a small distance from the wall along the direction of
its last action. This has not been implemented for the robot arm as it is a somewhat more
complex calculation. Instead, if a collision with an obstacle occurs the arm is restored to
its position before taking the action.
Learning begins at a randomly selected start state and continues until the goal is reached.
Then a new start state is selected randomly and the process repeated. This continues until
the requisite total number of actions is achieved. Speed up is calculated by dividing the
number of learning steps at one specific point on the baseline learning curve by the number
of learning steps at an equivalent point on the function composition system's learning curve.
The knee of the function composition system's curve is used. This occurs where the low
level learning algorithm is initialized with the composed function. This is compared to the
approximate position of the knee of the baseline curve.

4.1 Robot Navigation, Goal Relocation
The first experiment investigates the time taken to correct a learned function when the goal
is relocated in the robot navigation domain. There are nine different room configurations,
as shown in Figure 26, the number of rooms varying from three to five and there are four
different goal positions. Each room has one or two doorways and one or two paths to the
goal. To initialize the case base, a function is learned for each of these configurations with
the goal in the position shown by the black square. The rooms are generated randomly,
with some constraints on the configuration of the rooms and doorways: a room can not
be too small or narrow, a doorway can not be too large. The case base also includes
functions generated for the experiments discussed in Section 4.3. This was necessary to
give a sucient variety of cases to cover most of the new tasks. Even with this addition,
not all subgraphs are matched. Constant valued default functions are used when there is
not a match. This reduces speed up significantly, but does not eliminate it altogether.

1

2

3

4

5

6

7

8

9

Figure 26: The Different Suites of Rooms
83

fiDrummond

Once the case base is loaded, the basic Q-learning algorithm is rerun on each room
configuration with the goal in the position shown. After 400,000 steps the goal is moved,
this is denoted as time t on the x-axis of Figure 27. The goal is moved to one of the
three remaining corners of the state space, a task not included in the case base. Learning
continues for a further 300,000 steps. At fixed intervals, learning is stopped and the average
number of steps to reach the goal is recorded. The curves in Figure 27 are the average of
27 experimental runs, three new goal positions for each of the nine room configurations.
Function Composition

Average No. of Steps to Goal

Q-Learning
Q-Learning (No Reinit)

10

10

3

2

1

10
t-400....t-100

t-50

t

t+50

t+100

t+150

t+200

t+250

t+300

t + No. of Learning Steps X 1000

Figure 27: Learning Curves: Robot Navigation, Goal Relocation
The basic Q-learning algorithm, the top curve of Figure 27, performs poorly because,
when the goal is moved, the existing function pushes the robot towards the old goal position.
A variant of the basic algorithm reinitializes the function to zero everywhere on detecting
that the goal has moved. This reinitialized Q-learning, the middle curve, performed much
better, but it still has to learn the new task from scratch.
The function composition system, the lowest curve, performed by far the best. The
precise position of the knee of this curve is dicult to determine due to the effect of using
default functions. If only those examples using case base functions are considered, the knee
point is very sharp at about 3000 steps. The average number of steps to goal at 3000 steps,
for all examples, is 40. The non-reinitialized Q-learning fails to reach this value within
300,000 steps giving a speed of over 100. The reinitialized Q-learning reaches this value
at about 120,000 steps, giving a speed up of about 40. Function composition generally
produces accurate solutions. Even if some error is introduced, further Q-learning quickly
refines the function towards the asymptotic value of about 17. After about 150,000 steps,
84

fiAccelerating Reinforcement Learning

normal Q-learning reaches an average value of 24 steps and then slowly refines the solution
to reach an average value of 21 after 300,000 steps.

4.2 Robot Arm, Goal Relocation
The second experiment is essentially a repeat of the first experiment but in the robot arm
domain. The initial number of steps, before the goal was moved, was reduced to 300,000
to speed up the experiments. As the arm has only two degrees of freedom, and with the
restrictions discussed in Section 2.4, the number of variations is small. So only three obstacle
configurations were used, constructed by hand, with two obstacles in each. To increase the
number of experiments, to allow for greater statistical variation, each configuration was
repeated with the goal in each of three possible positions, as shown in Figure 28. The
black diamonds represent the obstacles, the black rectangles the goal. Solutions to all these
tasks were loaded into the case base. When composing a function, however, the system is
prevented from selecting a case that comes from the same goal and obstacle configuration.

1

2

3

4

5

6

7

8

9

Figure 28: The Robot Arm Obstacle and Goal Positions
The curves in Figure 29 are the average of 18 experimental runs, two new goal positions
for each of the three original goal positions in the three obstacle configurations shown in
Figure 28. There are only two learning curves, non-reinitialized Q-Learning being dropped.
As in the first experiment, the function composition system, the lower curve, performed
much better than Q-learning. The knee of the function composition system occurs at 2000
steps, the knee of Q-learning at 50,000 steps, giving a speed up of 25. In this experiment,
the case base contained subgraphs that matched for all new tasks, so default functions were
not needed. The composed functions tend to be very accurate and little further refinement
is necessary.
85

fiDrummond

Function Composition

Average No. of Steps to Goal

Q-Learning

10

10

3

2

1

10
t-300....t-100

t-50

t

t+50

t+100

t+150

t+200

t+250

t+300

t + No. of Learning Steps X 1000

Figure 29: Learning Curves: Robot Arm, Goal Relocation

4.3 Robot Navigation, New Environment
The third experiment investigates the time taken to learn in a new, but related, environment
in the robot navigation domain. Nine different inner rooms were generated randomly, again
under some constraints. All have a single doorway, but the size and position of the room
and the location of the doorway are varied as shown in Figure 30. To initialize the case base,
a function is learned for each of these configurations with the goal inside the small room as
indicate by the dark square. Learning is then repeated on each of the room configurations
in turn. However, when composing the new function the system is prevented from selecting
a case learned from the same goal and room configuration. Experimental runs for the Qlearning algorithm and the function composition system are initialized with a at function
of zero and 0.75 everywhere respectively, denoted as zero on the x-axis. Learning continues
for 100,000 steps. To improve the statistical variation, experiments for each configuration
were repeated three times, each time with a new random seed. The curves in Figure 31 are,
therefore, the average across 27 experimental runs.
The top curve is the Q-learning algorithm, the bottom curve the function composition
system. For these experiments, locating the goal took typically between 400 and 1200 steps,
although some took 2000 steps. The function composition system then introduces the \no
walls" function and typically a further 800 to 4000 steps are taken before usable features are
generated. Again, certain experimental runs took longer, this will be discussed in Section
5.2. Due to these runs, the knee of the function composition system's curve occurs at 12,000
steps. The knee of the basic Q-learning curve occurs at approximately 54,000 steps giving
86

fi10

10

10

3

2

0

1

1

5

2

9

6

3

30

40

50

60

70

Q-Learning

80

90

Function Composition

Accelerating Reinforcement Learning

4

8

20

Figure 30: The Single Rooms

7

10

No. of Learning Steps X 1000

87

100

Figure 31: Learning Curves: Robot Navigation, New Environment

Average No. of Steps to Goal

fiDrummond

a speed up of 4.5. As in previous experiments once initialized the function is very accurate
and little further refinement is necessary. Basic Q-learning, on reaching the knee, takes a
long time to remove the residual error.

4.4 Robot Arm, New Environment

10

10

10

3

2

0

1

1

20

30

2

40

50

3

60

70

Q-Learning

80

90

Function Composition

Figure 32: The Different Obstacle Positions

10

No. of Learning Steps X 1000

Figure 33: Learning Curves: Robot Arm, New Environment
88

100

The fourth experiment is essentially the same as the third experiment except in the robot
arm domain. Here, three, hand crafted, configurations of a single obstacle with the goal in
a fixed position were used, as shown in Figure 32. To increase the statistical variation each
configuration was run five times with a different random seed. The curves in Figure 33 are
therefore the average across 15 experimental runs.

Average No. of Steps to Goal

fiAccelerating Reinforcement Learning

The top curve of Figure 31 is the Q-learning algorithm, the bottom curve the function
composition system. The knee of the function composition system's curve occurs at about
4400 steps. The knee of the basic Q-learning algorithm at about 68,000 steps giving a speed
up of about 15.

5. Analysis of Results

The experiments of the previous section have shown that function composition produces
a significant speed up across two different types of related task and across two domains.
In addition, the composed solutions tend to be very accurate and little further refinement
is required. This section begins by looking at possible concerns with the experimental
methodology that might affect the measurement of speed up. It then discusses various
properties of the task being solved that affect the speed up achieved by using function
composition.

5.1 Possible Concerns with the Experimental Methodology

The speed up obtained using function composition is suciently large that small variations
in the experimental set up should be unlikely to affect the overall result. Nevertheless, there
are a number of concerns that might be raised about the experimental methodology. Some
will be, at least partially, addressed in this section; others will be the subject of future work.
The first concern might be how the estimated value of speed up is measured. The
value represents the speed up of the average of a set of learning tasks, rather than the
average of the speed up in each of the tasks. One of the diculties of estimation, with
curves for single tasks, is that the average distance to goal may oscillate up and down as
learning progresses, even though the general trend is downwards. This makes judging the
position of the knee of the curves dicult, and any estimate of speed up questionable. Even
experimental runs using the same configuration, but with different random seeds, exhibit a
considerable variation. In some instances, the speed up measured on individual curves may
benefit the function composition system, in others, the baseline algorithm. Nevertheless,
probably overall most of these effects will cancel out.
The second concern might be the effect on speed up of the limit of 2000 steps when
measuring the distance to the goal. Comparing two averages of values limited in this way
is sometimes misleading (Gordon & Segre, 1996). But this limit primarily affects only the
baseline algorithm, and was only significant when the goal was moved and the function not
reinitialized. Estimation of speed up is principally concerned with comparing the position
of the knees of the different curves. Here, the average distance to goal is relatively small,
so limiting the value is likely to have little effect.
The third concern might be that the value of speed up is dependent on the configuration
of the baseline algorithm. Certainly, it is the experience of this author that the way the
function is initialized, and how actions are selected, can have an impact on the speed of
learning. In previous work (Drummond, 1998), the function was initialized to a constant
value of 0.75, a technique termed \optimistic initial values" by Sutton and Barto (1998).
Tie breaking between actions of the same value was achieved by adding a small amount of
noise (circa 5  10,5). It was expected that this would increase exploration early on in
the learning process and speed up learning overall. However, using an initial value of zero
89

fi3

2

0

1

50

Drummond

100

150

200

250

300

and a strict tie-breaker, randomly selecting amongst actions with the same value, turned
out to produce a significant speed up in the baseline learning algorithm. This configuration
was used for the preceding experiments, but on one experimental run this caused serious
problems for the baseline algorithm.

10

10

10

No. of Learning Steps X 1000

Figure 34: Learning Curves in a Partially Observable Domain

90

The upper learning curve of Figure 34 is for the baseline algorithm, for one run when
the goal was moved in the robot arm domain. As it had such a large impact on the average
learning curve, it was replaced by the lower curve, produced by repeating the experiment
with a different random seed. This very slow learning rate arises from the interaction
of the partial observability of the robot arm domain with the use of an initial value of
zero. Individual cells of the function approximator straddle the obstacles allowing a \leakthrough" of value from one side of the obstacle to the other. Starting with a zero value,
once an action receives some value it will remain the best action for some time. Continual
update of this action will decrease the value, but it can only asymptotically approach zero.
Until other actions for the same state are updated, it will always be selected as the greedy
action. This did not occur for higher initial values. It may be that in domains where there is
some degree of partial observability, small initial values are better than zero or some means
of improving exploration for very small values might be necessary.
Other variations in the parameters of the baseline algorithm have not been explored
in this paper. For instance, a constant learning rate of 0.1 was used. Alternatives, such
as starting with a higher rate and reducing it as learning progresses might also improve
the overall speed of the baseline algorithm. Some preliminary experiments were, however,

Average No. of Steps to Goal

fiAccelerating Reinforcement Learning

carried out using undiscounted reinforcement learning, the discounting being strictly unnecessary in goal-directed tasks. Room configuration 1 of Figure 26, with the goal in the
lower right hand corner, was used as the experimental task. The discounting, discussed in
Section 3.1, is turned off by setting  to 1. In addition, the value on reaching the goal state
is set to zero and a cost is associated with every action. This form of learning simplifies
function composition, normalization procedures needed to compensate for the value function's exponential form being no longer required. With normalization disabled, the snake
successfully partitioned the function, the most critical part of the process. However, the
baseline learner took considerably longer to learn the function than in the discounted case.
With discounting, the learner reached an average distance to goal of about 72 steps after
80,000 learning steps. Without discounting, the learner reached an average of 400 steps at
the same point in time and only an average of 80 steps after 300,000 learning steps. The
action-value function was initialized to zero, which appears to be the standard practice in
the literature. However, the experience with initialization in the discounted case suggests
this might be the part of problem and this will be investigated in future work.
The baseline Q-learning algorithm used is the most basic and a more sophisticated one
would unquestionably reduce the speed up experimentally obtained. For instance, some
form of reinforcement learning using eligibility traces (Singh & Sutton, 1996) might be
used. For the experiments when the goal was moved, a baseline such Dyna-Q+ (Sutton,
1990) which was specifically designed to deal with changing worlds would probably be a
better reference point.
The speed up obtained, by transferring pieces of an action-value function, has also not
been compared to alternatives, such as transferring pieces of a policy or transferring pieces
of a model. Transferring pieces of a policy would reduce memory requirements and not
require the rescaling applied to pieces of an action-value function. It does, however, have
two disadvantages. Firstly, a solution can not be directly composed, as the position of
decision boundaries can not be determined. Further learning would be necessary to decide
the appropriate policy for each room. Secondly, the policy only indicates the best action.
The action-value function orders the actions, indicating potentially useful small changes
to the policy which might improve the accuracy on a new task. Transferring pieces of a
model, would require first learning a model consisting of a probability distribution function
for each action in each state. The memory requirement is considerably larger, unless the
states reachable by an action are limited beforehand. Nevertheless, a model would need
less modification in a changing world, such as when the goal is moved. It also carries
more information which might speed up learning. The action-value function seems a good
compromise in terms of complexity versus information content, but this would need to be
empirically validated and is the subject of future work.

5.2 Performance Variation with Task Configuration
Generally, function composition outperforms the baseline learning algorithm by an amount
dependent on the complexity of the learning problem. In the robot navigation domain
when the goal was moved, the amount of speed up increased with more rooms and fewer
paths to goal. A speed up of 60, against an average speed up of 40, was obtained on the
configurations with five rooms and a single path to goal. Configurations with only three
91

fiDrummond

rooms had the least speed up, but this was not only due to the relative simplicity of the
problem.

10

10

10

3

2

0

1

50

6

100

Q-Learning

Function Composition

No. of Learning Steps X 1000

6

92

Figure 35: Failure in Robot Navigation Moving Goal

6

150

The top of Figure 35 shows the average of four learning curves for the three room
configurations. The bottom of Figure 35 shows one of the configurations that produced
these curves. Not only is it one of the easiest tasks (from the experimental set) for the
baseline algorithm, but also there are no solutions in the case base for the lowest room.
There are no isomorphic subgraphs of this form. Rather than not composing a solution,
the system introduces a constant value function for this room. This room represents almost
half the state space, so much additional learning is required. As the top of Figure 35 shows,
initially there is significant speed up. Further refinement reduces the advantage and for
a short while the baseline algorithm is better. But later, function composition gains the
upper hand and converges more quickly than the baseline algorithm towards the asymptotic
value.

Average No. of Steps to Goal

fiAccelerating Reinforcement Learning

In the robot navigation domain when learning a new task, the amount of speed up varied
with the size of the inner room. This was primarily due to the number of actions needed
before the features emerged with sucient clarity for the snake to locate them. Function
composition is most successful when the inner room is small. If a wall is long, the feature
takes more time to develop, more refinement by Q-learning is needed to make it apparent.
Very short walls are also hard to identify. The likelihood of the robot colliding with them
is small and it takes many exploratory actions for the features to emerge clearly.
The features may be suciently clear for the snake to form a partition, yet not be well
enough defined to precisely locate the doorways. A doorway may appear to be a bit wider
than it actually is. More importantly, it may appear to be displaced from its true position.
Typically, the error in the composed function is small and normal reinforcement learning
quickly eliminates it. In one of the experimental runs, configuration 2 in Figure 30, the
speed up was reduced by a factor of 2 due to the doorway being incorrectly positioned.
The feature representing the lower wall had not completely emerged when the partition
was generated. This made the doorway appear to be almost exactly at the corner. The
algorithm, in fact, positioned the doorway just on the wrong side of the corner. This resulted
in the significantly reduced speed up. But it is unclear why reinforcement learning took
so long to correct what seems, on the surface at least, to be a local error. This will be
investigated in future work.

6. Limitations

Limitations come in , roughly, two kinds: those arising from the overall approach and those
arising from the way it was implemented. In the former case, ways to address these limitations may be highly speculative, or impossible without abandoning some of the fundamental
ideas behind the approach. In the latter case, there is a reasonable expectation that future
work will address these limitations. The following sections will deal with these cases in
turn.

6.1 Limitations in the Approach

To explore the possible limitations in the approach, this section reviews the fundamental
assumptions on which it is based.
It is a fundamental assumption that features arise in the reinforcement learning function
that qualitatively define its shape. The features used in this paper are the violation of a
smoothness assumption, that neighboring states have very similar utility values. A wall, by
preventing transitions between neighboring states, typically causes such a violation. Other
things, such as actions with a significant cost, would have a similar effect. Smaller, and
much more varied costs, will not generate the features required by this approach, so it offers
little in the way of speed up in these cases. If there is a mixture of large and small costs,
it is expected that the system will capture features generated by the former, initialize the
function and normal reinforcement learning will address the latter.
The smoothness assumption is less clear if the dimensions are not numeric. The neighborhood relation, used here, is a predefined distance metric over a continuous space. In
nominal, binary or mixed domains it is not obvious how such a metric would be defined,
although there is some work on such metrics for other applications (Osborne & Bridge,
93

fiDrummond

1997). If the dimensions are mixed, feature location might be limited to the continuous
ones. If the dimensions are purely nominal or binary, a generalization of the snake may be
appropriate. The snake is, at an abstract level, a constrained hill climber. But whether or
not this idea would usefully generalize in this way is at present somewhat speculative.
It is a fundamental assumption that the features clearly delimit subtasks. In the domains discussed in this paper, the obstacles and walls subdivide the state space into regions
connected by small \doorways". The subtask of reaching one doorway is not greatly affected
by the subsequent subtask. In other domains this may not be the case. As the doorways
become larger, the context sensitivity increases. As long as the composed solution is reasonably accurate, reinforcement learning can easily correct the error although speed up will
be reduced. At some point however, due to a very large amount of context sensitivity, the
advantage of dividing the task into subtasks will become questionable. It would be possible
to account for some of the context dependency in the graph matching stage, looking at
larger units than subgraphs. If two adjacent subgraphs match the new problem, they might
be used as a pair, thereby including any contextual relationship between them. Even if
single subgraphs were used, the context in which they appear, i.e. the shape of neighboring
subgraphs, could be taken into account. In the limit, graph matching the whole task might
be used. But, as was argued in the introduction, this would considerably limit when transfer
is applicable, and thus its overall effectiveness.
It is a fundamental assumption that the absolute position of the features is unimportant, it is the shape of the delimited region that matters. To increase the likelihood of
transfer, solutions to subtasks have been subjected to a variety of transformations. In
some domains, many, if not all, of these transformations will be invalid. If actions cannot
be rotated or reected, or if many small costs affect different regions of the state space,
the effectiveness of transfer will be reduced. This would be, to some extent, addressed by
additional penalties for different transformations, but again this would limit the opportunities for transfer. Which transformations are appropriate, and whether or not this can be
determined automatically from the domain, will be the subject of future research.
It is a fundamental assumption that a vision processing technique can locate these
features in a timely fashion, even in very high dimensional domains. Learning in very high
dimensional domains is likely to be slow whatever technique is used. Normal reinforcement
learning will take time to navigate the much larger space, slowing down the emergence of
the features. Although the time taken to partition the function will increase, the frequency
with which partitioning is applicable will decrease. Thus the amortized cost will rise more
slowly. Further, as high dimensional spaces are generally problematical, methods such as
principal components analysis and projection pursuit (Nason, 1995) can be used to reduce
dimensionality. It may prove in practice that the dimensionality which is important, and is
the focus of feature extraction, is much smaller than the actual dimensionality of the space.

6.2 Limitations in the Implementation
If the assumptions of the previous section are met, it is expected that the remaining limitations are due to the present implementation. These limitations are likely to become
apparent when the system is applied to other domains. Certainly other domains may differ
from those presented in this paper in a number of ways.
94

fiAccelerating Reinforcement Learning

A domain may differ in that the dimensionality of the space is higher than the two
dimensions of the tasks investigated in this paper. The implementation of the snake has
been updated to work in higher dimensions. The bold lines at the top of Figure 36 are
one of the simpler tasks from the robot navigation domain. The task has been extended in
the Z-dimension. The snake starts out as a sphere and then expands outwards until it fills
the room. In this example, the polygonal constraint has not been used, but everything else
remains the same. Figure 37 shows the complete partition of the task.

Figure 36: Adding a Z-Dimension

Figure 37: The Complete 3D Partition

The mathematics behind the snake is not limited to three dimensions. There also seems
to be nothing in principle that would prevent other processes such as graph matching,
planning or transformation from working in higher dimensions. Speed is the main problem.
This is not a problem unique to this approach and there is a large body of research addressing
this issue. For instance, although graph matching is in general NP-complete, there is
much active research in speeding up matching on the average or in special cases (Gold &
Rangarajan, 1996; Galil, 1986). At present, the snake represents the principal restriction
on speed. This is an issue of great importance to the vision processing community. Current
research is investigating this problem, at least in two or three dimensions. One example is
hierarchical methods (Schnabel, 1997; Leroy, Herlin, & Cohen, 1996) which find solutions
for the snake at progressively finer and finer resolution scales. The results of such research
will undoubtedly be of importance here.
A domain may differ in that the value function learned might not produce features locatable by the snake with the present parameter settings. The values of the parameters
were empirically determined, using hand crafted examples from the robot navigation and
the robot arm domains. The obvious danger is that the parameters might be tuned to these
examples. To demonstrate that this is not the case, configurations for the experiments in
the robot navigation domain were generated randomly. As configurations for the robot arm
domain are more tightly constrained, the hand crafted examples were used in the experiments. Nevertheless, the experiments have shown that the parameters worked successfully
for random examples in the robot navigation domain. The same parameters also work successfully in the second domain, the robot arm. The following discussion demonstrates that
95

fiDrummond

they are also reasonably effective in a quite different domain, the \car on the hill". It is
anticipated that using the results of current research into snakes will automate the selection
of many parameters.
In the \car on the hill"domain (Moore, 1992), the task, simply stated, is to get a car
up a steep hill, Figure 38. If the car is stationary part way up the hill, in fact anywhere
within the dotted line, then it has insucient acceleration to make it to the top. So the
car must reverse down the hill and then achieve sucient forward velocity, by accelerating
down the other side, before accelerating up the hill. The state space, for the purposes of
reinforcement learning, is defined by two dimensions. These are the position and velocity
of the car, as shown in Figure 39. The goal is to reach the top of the hill with a small
positive or negative velocity. In this domain there are two possible actions: accelerate
forward, accelerate backwards. Unlike in previous domains, there is no clear mapping of
the actions onto the state space. The state achieved on applying an action is determined by
Newton's laws of motion. As the car has insucient acceleration to make it up the hill from
everywhere in the state space, a \wall" is effectively introduced, the bold line in Figure 39.
To reach the top of the hill, the car must follow a trajectory around this \wall", the dashed
line in Figure 39.
Goal

Velocity

+ve

Goal

0

y

cit

lo
Ve

-ve

0

Position

Figure 38: The Car on the Hill

Position

Figure 39: Car State Space

Figure 40 shows the reinforcement learning function. It exhibits the same steep gradient
as the other domains. The important point to note is that, unlike in the other domains,
no physical object causes this gradient. It is implicit in the problem itself, yet the features
still exist. Figure 41 shows the partition produced when applying the snake to the \car on
the hill" domain. The main difference from the previous examples is that the polygonal
constraint has not been used. When the snake initially comes to rest, the mercury force
is turned off and then the snake is allowed to find the minimum energy state. It was also
necessary to reduce the scaling of the edges, by about a factor of three quarters, to achieve
the accuracy of fit. The fit around the top left corner of the second snake, the dashed line,
96

fiAccelerating Reinforcement Learning

also has some problems: the snake is growing very slowly downwards and is, at present, only
stopped because it has reached the maximum number of iterations allowed. One diculty
in this example is that there is not such clear delimitation of the upper and lower regions
at the end of the feature. Future work will investigate altering the stopping condition to
eliminate this problem.

Figure 40: The Steep Gradient

Figure 41: The Regions Extracted

A domain may differ in that the shape of various regions in the partition is more complex than can be dealt with by the present snake. Fitting the snake to the task discussed in
the previous paragraphs goes some way towards mitigating that concern. Nevertheless, the
randomly generated examples of Section 4.1 were subject to certain constraints. Configurations with narrower rooms were tried informally, but the snake did not reliably locate the
features. The configurations in Section 4 represent the limit of the complexity of partition
the snake can produce at present. It is expected that using ideas from the large body of
already published research into snakes will go a long way towards addressing this limitation.
For complex regions, locating all the subtleties of the underlying shape may be unnecessary,
or even undesirable. The aim is to speed up low level learning. As long as the solution is
reasonably accurate, speed up should be obtained. Being too sensitive to minor variations
in shape may severely limit the opportunities for transfer and thus reduce speed up overall.
A domain may differ in that changes in the environment are more complex than those
investigated in this paper. At present, the system detects that the goal has moved by
counting how often a reward is received at the old goal position. Not only is this a rather
ad hoc approach, but it also does not account for other possible changes, such as paths
becoming blocked or short-cuts becoming available. At present, when learning a new task
the system is restarted and is not required to determine that its present solution is no longer
applicable. In future work, the system should decide when its model of the world is no longer
correct. It should also decide what, if any, relationship there is to the existing task and
how it might be best exploited. This will allow a more complex interaction of the function
composition system with reinforcement learning. For instance, the learning of a new task for
97

fiDrummond

the robot navigation domain used the relatively simple situation of two rooms. The function
composition system initialized the low level algorithm once on detecting suitable features. In
the future, to address more complex tasks, with many more rooms, an incremental approach
will be used. When a new task is being learned, the system will progressively build up a
solution by function composition as different features become apparent.
This approach also should handle any errors the system might make with feature extraction. In the experiments with these simple room configurations, the filtering discussed
in Section 2.3 proved sucient to prevent problems. But in more complex tasks, it is likely
that false \doorways" will be detected, simply because the system has not explored that
region of the state space. A composed function including that extra doorway will drive the
system into that region. It should then become quickly apparent that the doorway does not
exist and a new function can be composed.

7. Related Work
The most strongly related work is that investigating macro actions in reinforcement learning. Precup, Sutton and Singh (1997, 1998) propose a possible semantics for macro actions
within the framework of normal reinforcement learning. Singh (1992) uses policies, learned
to solve low level problems, as primitives for reinforcement learning at a higher level. Mahadevan and Connell (1992) use reinforcement learning in behavior based robot control.
To learn a solution to a new task, all these systems require a definition for each subtask
and their interrelationships in solving the compound task. The work presented here gives
one way that macro actions can be extracted directly from the system's interaction with
its environment, without any such hand-crafted definitions. It also shows how to determine
the interrelationships of these macro actions needed to solve the new task. Thrun's research (1994) does identify macro actions, by finding commonalities in multiple tasks. But
unlike the research presented here, no mapping of such actions to new tasks is proposed.
Hauskrecht et al. (1998) discuss various methods of generating macro actions. Parr (1998)
develops algorithms to control the caching of policies that can be used in multiple tasks.
But in both cases, they need to be given a partitioning over the state space. It is the
automatic generation of just such a partition that has been the focus of much of the work
presented in this paper. It may well be that this approach to generating partitions and to
determining the interrelationships between partitions of related tasks will prove useful to
this other work.
Another group of closely connected work is the various forms of instance based or case
based learning that have been used in conjunction with reinforcement learning. They have
been used to address a number of issues: (1) the economical representation of the state
space, (2) prioritizing states for updating and (3) dealing with hidden state. The first issue
is addressed by Peng (1995) and by Tadepalli and Ok (1996) who use learned instances
combined with linear regression over a set of neighboring points. Sheppard and Salzberg
(1997) also use learned instances, but they are carefully selected by a genetic algorithm. The
second issue is addressed by Moore and Atkeson (1993) who keep a queue of \interesting"
instances, predecessors of those states where learning produces a large change in values.
These are updated most frequently to improve the learning rate. The third issue is addressed
by McCallum (1995b) who uses trees which expand the state representation to include prior
98

fiAccelerating Reinforcement Learning

states, removing ambiguity due to hidden states. In further work, McCallum (1995a) uses
a single representation to address both the hidden state problem and the general problem
of representing a large state space by using a case base of state sequences associated with
various trajectories. Unlike this other research, in the work presented here the case is not
an example of the value function during learning. Instead, it is the result of a complete
learning episode, so the method should be complementary to these other approaches.
This work is also related to case based planning (Hammond, 1990; Veloso & Carbonell,
1993), firstly through the general connection of reinforcement learning and planning. But
it is analogous in other ways. When there is a small change to the world, such as the
goal being moved, a composite plan is modified by using sub-plans extracted from other
composite plans.
Last, but not least, is the connection with object recognition in vision research (Suetens
et al., 1992; Chin & Dyer, 1986). In the work presented here, many of the methods { if not
the final application { has come from that field. The features in the reinforcement learning
function are akin to edges in an image. These are located by finding the zero crossing point
of the Laplacian as introduced by Marr (1982). In the work presented here, it was proposed
that the features largely dictate the form of the function. Mallat and Zhong (1992) have
shown that a function can be accurately reconstructed from a record of its steep slopes.

8. Conclusions

This paper described a system that transfers the results of prior learning to significantly
speed up reinforcement learning on related tasks. Vision processing techniques are utilized
to extract features from the learned function. The features are then used to index a case
base and control function composition to produce a close approximation to the solution of
a new task. The experiments demonstrated that function composition often produces more
than an order of magnitude increase in learning rate compared to a basic reinforcement
learning algorithm.

Acknowledgements
The author would like to thank Rob Holte for many useful discussions and help in preparing
this paper. This work was in part supported by scholarships from the Natural Sciences and
Engineering Research Council of Canada and the Ontario Government.

Appendix A. Spline Representations

This appendix presents some of the underlying mathematics associated with spline representations and the snake. It is not meant to be an introduction to the subject. Rather it
is added for completeness to discuss certain important aspects of the system not addressed
elsewhere in this paper. Knowledge of these aspects is not necessary to understand the basic
principles of the approach discussed in this paper, but would be necessary if one wanted
to duplicate the system. More detailed explanation is given in Drummond (1999). Some
specific papers that address these ideas in much greater detail are: for splines (Terzopoulos,
1986) and for snakes (Cohen & Cohen, 1993; Leymarie & Levine, 1993).
99

fiDrummond

Splines are piecewise polynomials where the degree of the polynomial determines the
continuity and smoothness of the function approximation. Additional smoothing constraints
can be introduced by penalty terms which reduce the size of various differentials. One way
then to view spline fitting is in the form of an energy functional such as Equation 6.

Espline(f^) =

Z

R





Efit (f^) + Esmooth (f^) ds

(6)

Here, there is an energy associated with the goodness of fit, some measure of how close
the approximating function is to the input function. This is typically the least squares
distance between the functions. There is an energy associated with the smoothness of the
function. Two very commonly used smoothness controls produce the membrane and thin
plate splines by restricting the first and second differentials of the function respectively. To
fit the spline to the function, the total energy must be minimized. A necessary condition
for this is an Euler-Lagrange differential equation such as Equation 7. Here !t controls the
tension in the spline (the resistance to stretching) and !s the stiffness (the resistance to
bending). Often the error function will be based on individual data points and the left hand
side of Equation 7 would include delta functions.
^

2^

@ (! (s) @ f (s) ) + @ (! (s) @ f (s) ) = f (s) , f^(s)
, @s
t
in
@s
@s2 s @s2

(7)

In this work, such splines have been used for a number of purposes. When fitting the
snake, measures of the first and second differential are needed. A two dimensional quadratic
spline is fitted to the discrete representation of the maximum Q-values. An !t of 0.2 is used
(!s is zero) to limit overshoot (Drummond, 1996) to prevent false edges. Values from an
identical spline except using an !t of 2.0 are squared and then divided into the differential
values. This normalizes the differentials, so that the size of edges is not dependent on where
they occur in the function. The same type of spline is used to produce the bowls associated
with the rooms as discussed in Section 3.2.1. Here !t is 1.0 and !s is 0.5 giving roughly
Gaussian smoothing. The values used to produce this function are weighted. Values close
to one are given weights of 200, lower values a weight of 1. This prevents the sides of the
bowls from collapsing under smoothing.
A one dimensional cubic spline is used in locating the doorways. These are found by
steepest descent on the value of the differential along the body of the snake. This differential
contains many local minima not associated with doorways. These arise either from the
inherent noise in the process or from errors of fit in the snake. The aim is to remove the
ones not associated with doorways by smoothing and thresholding. This is achieved by
first sampling the gradient at points along the snake. The values are then normalized to lie
between zero and one. The spline has an !t of 0.15 (!s of 0.0). Here a weighted least mean
squares fit is used. The weighting function is the inverse square of the values, preventing
the spline from being overwhelmed by large values. Starting points for steepest descent are
changes in the sign of the coecients of the gradient of the spline. The initial step size
is set to slightly larger than a knot spacing and then decreased over time. When a local
minimum is found if the value exceeds a threshold (of 0.5), it is rejected.
To represent the snake, the model of the spline must be changed somewhat. The snake
itself is a one dimensional cubic spline. But the energy minimum that is being sought is
100

fiAccelerating Reinforcement Learning

in the differential of the Qmax function, subject to other constraints. The dynamics of the
snake are defined by the Euler-Langrange equation shown in Equation 8.
2 f^!!
2 f^!
2 f^
^ @ @
@
f
@
@
@
@
 @t2 +  @t + @t @s2 !c(s) @s2 + @s2 !tp (s) @s2 = F (f^)

(8)

An !c of 512 minimizes changes to the snake's shape as it grows, by penalizing the
difference in the second differential to the previous time step scaled by the ratio of their
lengths. An !s of 8.0 is the initial stiffness of the snake. This is reduced proportionately to
the snake's length to give the spline more degrees of freedom. A  of 96 and a  of 96 control
the momentum and the drag on the snake respectively. As in Cohen and Cohen (1993), a
factor is added to the energy associated with the differential that is in the direction normal
to the body of the snake, as shown in Equation 9. But instead of it being a constant, a
variable is used to produce the mercury model discussed in Section 3.2.1.
2
F (f^) = M (f^),!
n (s) + r(, fifirQmax(f^)fifi ),!
n (s)
fi

fi

(9)

The energy minimization process is carried out iteratively interleaving steps for the x
and y directions. The differential of r jQmax j2 for the x direction is given by Equation 10,
a similar equation is used for the y direction.
2
2 Qmax
@Qmax )( @ 2 Qmax )
)
+
(
, @ jrQ@xmax j = ,2 ( @Q@xmax )( @ @x
2
@y
@x@y
"

#

(10)

The snake grows under the forces of the mercury model until it reaches an approximately
stable position, subject only to small oscillations. It is then converted into a polygon by
 where n = 0 : : : 3). The
finding the corners (where the normal passes through (2n+1)
4
coecient !1 is set to zero everywhere. The coecient !2 is set to zero at the corners and
15 between them. This produces a polygon which is exible at its vertices.
To detect the features as early as possible in the learning process, as discussed in Section
2.4, the height of the gradient is scaled according to the signal to noise ratio. The noise
arises from variations in the low level learning process and the stochastic nature of the task.
Both the size of the features and the noise grow with time and are somewhat normalized by
this scaling process. The idea is to collect uniformly sampled values of the function shown
in Equation 10 for both the x and y directions and find the median of their absolute values.
The median is not strongly affected by extreme values and thus largely ignores the size of
the features, measuring only the noise of the regions in between.

References
Chin, C. H., & Dyer, C. R. (1986). Model-based recognition in robot vision. Computing
Surveys, 18 (1), 67{108.
Christiansen, A. D. (1992). Learning to predict in uncertain continuous tasks. In Proceedings
of the Ninth International Workshop on Machine Learning, pp. 72{81.
101

fiDrummond

Cohen, L. D., & Cohen, I. (1993). Finite element methods for active contour models and
balloons for 2-d and 3-d images. IEEE Transactions On Pattern Analysis And Machine
Intelligence, 15 (11), 1131{1147.
Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische
Mathematik, 1, 269{271.
Drummond, C. (1996). Preventing overshoot of splines with application to reinforcement
learning. Computer science technical report TR-96-05, School of Information Technology and Engineering, University of Ottawa, Ottawa, Ontario, Canada.
Drummond, C. (1997). Using a case-base of surfaces to speed-up reinforcement learning.
In Proceedings of the Second International Conference on Case-Based Reasoning, Vol.
1266 of LNAI, pp. 435{444.
Drummond, C. (1998). Composing functions to speed up reinforcement learning in a changing world. In Proceedings of the Tenth European Conference on Machine Learning,
Vol. 1398 of LNAI, pp. 370{381.
Drummond, C. (1999). A Symbol's Role in Learning Low Level Control Functions. Ph.D.
thesis, School of Information Technology and Engineering, University of Ottawa, Ottawa, Ontario, Canada.
Galil, Z. (1986). Ecient algorithms for finding maximum matching in graphs. ACM
Computing Surveys, 18 (1), 23{38.
Gold, S., & Rangarajan, A. (1996). A graduated assignment algorithm for graph matching.
IEEE Transactions On Pattern Analysis And Machine Intelligence, 18 (4), 377{388.
Gordon, G. J. (1995). Stable function approximation in dynamic programming. In Proceedings of the Twelfth International Conference of Machine Learning, pp. 261{268.
Gordon, G. J., & Segre, A. M. (1996). Nonparametric statistical methods for experimental evaluations of speedup learning. In Proceedings of the Thirteenth International
Conference of Machine Learning, pp. 200{206.
Hammond, K. J. (1990). Case-based planning: A framework for planning from experience.
The Journal of Cognitive Science, 14 (3), 385{443.
Hauskrecht, M., Meuleau, N., Boutilier, C., Kaelbling, L. P., & Dean, T. (1998). Hierarchical
solution for Markov decision processes using macro-actions. In Proceedings of the
Fourteenth Conference on Uncertainty In Artificial Intelligence, pp. 220{229.
Kass, M., Witkin, A., & Terzopoulus, D. (1987). Snakes: Active contour models. International Journal of Computer Vision, 1, 321{331.
Leroy, B., Herlin, I. L., & Cohen, L. D. (1996). Multi-resolution algorithms for active
contour models. In Proceedings of the Twelfth International Conference on Analysis
and Optimization of Systems, pp. 58{65.
102

fiAccelerating Reinforcement Learning

Leymarie, F., & Levine, M. D. (1993). Tracking deformable objects in the plane using
an active contour model. IEEE Transactions On Pattern Analysis And Machine
Intelligence, 15 (6), 617{634.
MacDonald, A. (1992). Graphs: Notes on symetries, imbeddings, decompositions. Tech.
rep. Electrical Engineering Department TR-92-10-AJM, Brunel University, Uxbridge,
Middlesex, United Kingdom.
Mahadevan, S., & Connell, J. (1992). Automatic programming of behavior-based robots
using reinforcement learning. Artificial Intelligence, 55, 311{365.
Mallat, S., & Zhong, S. (1992). Characterization of signals from multiscale edges. IEEE
Transactions On Pattern Analysis And Machine Intelligence, 14 (7), 710{732.
Marr, D. (1982). Vision: a Computational Investigation into the Human Representation
and Processing of Visual Information. W.H. Freeman.
McCallum, R. A. (1995a). Instance-based state identification for reinforcement learning. In
Advances in Neural Information Processing Systems 7, pp. 377{384.
McCallum, R. A. (1995b). Instance-based utile distinctions for reinforcement learning with
hidden state. In Proceedings of the Twelfth International Conference on Machine
Learning, pp. 387{395.
Moore, A. W., & Atkeson, C. G. (1993). Prioritized sweeping: Reinforcement learning with
less data and less real time. Machine Learning, 13, 103{130.
Moore, A. W. (1992). Variable resolution dynamic programming: Eciently learning action
maps in multivariate real-valued state spaces. In Proceedings of the Ninth International
Workshop on Machine Learning.
Nason, G. (1995). Three-dimensional projection pursuit. Tech. rep., Department of Mathematics, University of Bristol, Bristol, United Kingdom.
Osborne, H., & Bridge, D. (1997). Similarity metrics: A formal unification of cardinal
and non-cardinal similarity measures. In Proceedings of the Second International
Conference on Case-Based Reasoning, Vol. 1266 of LNAI, pp. 235{244.
Parr, R. (1998). Flexible decomposition algorithms for weakly coupled Markov decision
problems. In Proceedings of the Fourteenth Conference on Uncertainty In Artificial
Intelligence, pp. 422{430.
Peng, J. (1995). Ecient memory-based dynamic programming. In Proceedings of the
Twelfth International Conference of Machine Learning, pp. 438{439.
Precup, D., Sutton, R. S., & Singh, S. P. (1997). Planning with closed-loop macro actions.
In Working notes of the 1997 AAAI Fall Symposium on Model-directed Autonomous
Systems, pp. 70{76.
103

fiDrummond

Precup, D., Sutton, R. S., & Singh, S. P. (1998). Theoretical results on reinforcement
learning with temporally abstract options. In Proceedings of the Tenth European
Conference on Machine Learning, Vol. 1398 of LNAI, pp. 382{393.
Schnabel, J. A. (1997). Multi-Scale Active Shape Description in Medical Imaging. Ph.D.
thesis, University of London, London, United Kingdom.
Sheppard, J. W., & Salzberg, S. L. (1997). A teaching strategy for memory-based control.
Artificial Intelligence Review: Special Issue on Lazy Learning, 11, 343{370.
Singh, S. P., & Sutton, R. S. (1996). Reinforcement learning with replacing eligibility traces.
Machine Learning, 22, 123{158.
Singh, S. P. (1992). Reinforcement learning with a hierarchy of abstract models. In Proceedings of the Tenth National Conference on Artificial Intelligence, pp. 202{207.
Suetens, P., Fua, P., & Hanson, A. (1992). Computational strategies for object recognition.
Computing Surveys, 24 (1), 5{61.
Sutton, R. S. (1990). Integrated architectures for learning, planning, and reacting based
on approximating dynamic programming. In Proceedings of the Seventh International
Conference on Machine Learning, pp. 216{224.
Sutton, R. S. (1996). Generalization in reinforcement learning: Successful examples using
sparse coarse coding. In Advances in Neural Information Processing Systems 8, pp.
1038{1044.
Sutton, R. S., & Barto, A. G. (1998). Reinforcement Learning: An Introduction. MIT Press.
Tadepalli, P., & Ok, D. (1996). Scaling up average reward reinforcement learning by approximating the domain models and the value function. In Proceedings of the Thirteenth
International Conference of Machine Learning, pp. 471{479.
Tanimoto, S. L. (1990). The Elements of Artficial Intelligence. W.H. Freeman.
Terzopoulos, D. (1986). Regularization of inverse visual problems involving discontinuities.
IEEE Transactions On Pattern Analysis And Machine Intelligence, 8 (4), 413{423.
Thrun, S., & Schwartz, A. (1994). Finding structure in reinforcement learning. In Advances
in Neural Information Processing Systems 7, pp. 385{392.
Veloso, M. M., & Carbonell, J. G. (1993). Derivational analogy in prodigy: Automating
case acquisition, storage and utilization. Machine Learning, 10 (3), 249{278.
Watkins, C. J., & Dayan, P. (1992). Technical note: Q-learning. Machine Learning, 8 (3-4),
279{292.

104

fi