Journal Artificial Intelligence Research 15 (2001) 1-30

Submitted 11/00; published 7/01

Goal Recognition Goal Graph Analysis
j.hong@ulst.ac.uk

Jun Hong
School Information Software Engineering
University Ulster Jordanstown
Newtownabbey, Co. Antrim BT37 0QB, UK

Abstract
present novel approach goal recognition based two-stage paradigm graph
construction analysis. First, graph structure called Goal Graph constructed
represent observed actions, state world, achieved goals well
various connections nodes consecutive time steps. Then, Goal Graph
analysed time step recognise partially fully achieved goals
consistent actions observed far. Goal Graph analysis reveals valid
plans recognised goals part goals.
approach goal recognition need plan library. suer
problems acquisition hand-coding large plan libraries, neither
problems searching plan space exponential size. describe two algorithms
Goal Graph construction analysis paradigm. algorithms
provably sound, polynomial-time, polynomial-space. number goals recognised
algorithms usually small sequence observed actions
processed. Thus sequence observed actions well explained recognised goals
little ambiguity. evaluated algorithms UNIX domain,
excellent performance achieved terms accuracy, eciency, scalability.

1. Introduction
Plan recognition involves inferring intentions agent set observations.
typical approach plan recognition uses explicit representation possible plans
goals, often called plan library, conducts type reasoning basis set
observations identify plans goals plan library, could caused
observations.
Plan recognition useful many areas, including discourse analysis natural language question-answering systems, story understanding, intelligent user interfaces,
multi-agent coordination. Much early research plan recognition done natural language question-answering systems (Allen & Perrault, 1980; Allen, 1983; Sidner,
1985; Litman & Allen, 1987; Carberry, 1988; Pollack, 1990; Grosz & Sidner, 1990).
systems, plan recognition used support intelligent response generation;
understand sentence fragments, ellipsis indirect speech acts; track speakers ow
discourse; deal correctness completeness discrepancies
knowledge users systems.
Plan recognition enhance user interfaces. recognition users goals
plans interaction interface facilitates intelligent user help (Carver, Lesser,
& McCue, 1984; Hu & Lesser, 1988; Goodman & Litman, 1992; Bauer & Paul, 1993;
Lesh & Etzioni, 1995). Plan recognition enables interface assist user task
c
2001
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiHong

completion, error detection recovery (Wilensky & et al., 1988). interface
watching users shoulder infer goals plans. decide
help assistance user needs.
story understanding (Schank & Abelson, 1977; Wilensky, 1983; Charniak & Goldman,
1993), useful recognise goals plans characters described
actions order understand characters doing. multi-agent coordination,
ecient eective coordination among multiple agents requires modelling agents
goals plans (Huber, Durfee, & Wellman, 1994; Huber & Durfee, 1995).
Given set observations, plan recognition systems (Allen & Perrault, 1980;
Carberry, 1986; Litman & Allen, 1987; Kautz, 1987; Pollack, 1990)) search space
possible plan hypotheses candidate plans goals account observations.
form search space given domain, kind plan library required.
instance, Kautzs event hierarchy (Kautz, 1987), plan decompositions required
describe low-level actions make complex actions. Despite obvious advantage
expressive richness, use plan library limitations. First, able deal
new plans whose types appear plan library. Second, acquiring handcoding plan library large complex domain presents tedious impractical task.
Third, domains, knowledge plans might readily available.
attempts (Mooney, 1990; Forbes, Huang, Kanazawa, & Russell, 1995; Lesh &
Etzioni, 1996; Albrecht, Zukerman, & Nicholson, 1998; Bauer, 1998) recently
made apply machine learning techniques automated acquisition coding plan
libraries. Even leaving aside plan library consideration, searching plan space
can, however, exponentially expensive number possible plan hypotheses
exponential number actions (Kautz, 1987). plan recognition systems
developed domains peoples behaviour characterized fewer
100 plans goals (Lesh & Etzioni, 1996).
paper, focus goal recognition, special case plan recognition.
introduce novel approach goal recognition, graph construction analysis
used paradigm. approach signicantly diers plan recognition systems.
First, approach need plan library. Instead dene constitutes valid
plan goal. need consider observed actions organised plans.
Hence problems associated acquisition hand-coding
plan library large complex domain well availability planning knowledge
domain. plan recognition systems cannot recognise new plans whose types
appear plan library. Without using plan library, approach suer
limitation. Second, instead immediately searching plan plan space
plan recognition systems, approach explicitly constructs graph structure,
called Goal Graph, analysed recognise goals plans. approach
therefore problems searching plan space exponential size. Third,
approach recognises partially fully achieved goals consistent
actions observed far. number recognised goals usually small
sequence observed actions processed. Thus sequence observed actions
well explained recognised goals little ambiguity.
emphasised approach goal recognition, purpose recognising partially fully achieved goals explain past actions rather predicting
2

fiGoal Recognition Goal Graph Analysis

future actions. particularly useful problem areas story understanding,
software advisory systems, database query optimisation, customer data mining.
problem areas several specic characteristics. First, actions either described observed. Second, likely users intended goal partially
fully achieved actions. Third, recognising intended goal aims explaining past actions rather predicting future actions. Finally, distinguishing partially
fully achieved goals others greatly reduces ambiguity involved recognising
intended goal.
story understanding, actions characters described story. Recognising goals plans account described actions enables better understanding
characters doing. software advisory systems, user
observed issue sequence operations software application, system rst
recognise task user performed. system decide whether user
performed task suboptimal way, advice given user
better perform task. database query optimisation, user conducted sequence data retrieval manipulation operations, recognising underlying
query lead advice query optimisation query executed
optimal way. customer data mining, individual customers shopping goals
recognised logged customer on-line shopping data. form basis
performing customer data mining tasks.
algorithms Goal Graph construction analysis provably sound,
polynomial-time, polynomial-space. empirical results UNIX domain show
algorithms perform well terms accuracy, eciency, scalability.
show algorithms scaled applied domains tens
thousands possible goals plans. Though algorithm Goal Graph analysis
complete, recognised every goal intended successfully achieved
subject UNIX data set used evaluation. Since new graph-based
approach goal recognition fundamentally dierent existing methods plan
recognition, provides alternative methods new perspective plan
recognition problem.
rest paper organised follows. First, give overview novel
approach goal recognition. Section 3, discuss domain representation.
Section 4 dene Goal Graphs, valid plans, consistent goals. Section 5 present
goal recognition algorithms together analysis algorithms. Section 6
discuss empirical results. summarise paper discuss limitations future
work last section.

2. Novel Approach Goal Recognition
section, describe basic assumptions make goal recognition problem
outline approach. discuss previous work planning Planning Graphs
graph-based approach goal recognition. briey describe empirical results
favour approach.
3

fiHong

2.1 Basic Assumptions
start example UNIX domain. observe user types two
commands, cd papers ls, one another, able infer user
wants nd le subdirectory directory, papers, two reasons. First, goal
fully achieved. Second, relevant commands consistent way
sense rst command satises one preconditions second command
second command achieves recognised goal. recognised goal might
intermediate goal user. users intended goal might one le related
goals, instance, deleting le directory. Since commands
part plans almost le related goals, impossible us uniquely identify
users intended goal current time step. Yet goal nding le directory
well explains commands. user next types command, rm oldpaper.tex,
infer users goal delete le, oldpaper.tex, directory, papers,
goal fully achieved relevant commands observed
far consistent way sense rst command satises one preconditions
second third commands, second command satises one preconditions
third command, third command achieves recognised goal.
example highlights way new approach goal recognition works. make
following assumptions goal recognition problem. First, set actions
observed consecutive time steps.1 Second, initial state world immediately
set actions observed known.2 Third, domain knowledge
actions goals, is, know preconditions eects every observed action,
every possible goal explicitly specied set goal descriptions.
Given assumptions, action observed time step, want infer
goals partially fully achieved time step whether
achieved goals relevant strict majority actions observed far consistent
way sense actions organised plan structure goal
part it.
2.2 Goal Recognition Goal Graph
propose use graph structure, called Goal Graph, new approach goal
recognition. view goal recognition problem process graph construction
analysis. Goal Graph, action nodes represent actions observed consecutive time
steps; proposition nodes represent state world consecutive time steps,
changed initial state subsequent states observed actions; goal
nodes represent goals partially fully achieved consecutive time steps.
Edges Goal Graph explicitly represent relations actions propositions
well relations propositions goals. Based explicit relations
constructed Goal Graph, causal links either two actions action goal
recognised. recognised causal links, decided whether fully
partially achieved goal time step relevant strict majority observed
1. observed actions partially ordered sense one action observed
time step temporal ordering constraint actions.
2. approach however reasons state world subsequent time steps.

4

fiGoal Recognition Goal Graph Analysis

actions far consistent way sense relevant actions organised
plan structure goal part it. approach, extraneous, redundant,
partially ordered actions plans handled.
attempt use graph construction analysis paradigm goal recognition
spirit inuenced Blum Fursts eorts planning Planning Graphs (Blum
& Furst, 1997). introduced new graph-based approach planning STRIPS
domains, graph structure called Planning Graph rst constructed explicitly
rather searching immediately plan standard planning methods. Many useful
constraints inherent planning problem made explicitly available Planning
Graph reduce amount search needed. Planning Graph analysed
generate possible plans.
Goal-Graph-based approach goal recognition seen counterpart
planning Planning Graph. Though graph structures used approaches,
composed dierent kinds nodes edges. time step, Planning Graph
represents possible propositions either added actions previous time step
brought forward maintenance actions previous time step, possible
actions whose preconditions satised propositions time step.
hand, Goal Graph, time step, represents propositions either added
actions observed previous time step brought forward maintenance actions
previous time step, actions observed time step. addition, Goal
Graph, time step, represents possible goals, either fully partially achieved
time step, Planning Graph represent goal all. Accordingly,
Planning Graph represents relations actions propositions, Goal
Graph represents relations propositions goals.
analysis Planning Graph aims search possible subgraphs
Planning Graph, form valid plans given goal. hand,
analysis Goal Graph aims search every possible partially fully goal
exists subgraph Goal Graph, consisting strict majority observed
actions. subgraph forms valid plan goal part shows
strict majority observed actions relevant goal consistent way.
domain representation planning Planning Graph
goal recognition Goal Graph. regard, previous eorts handling
expressive representation languages (Gazen & Knoblock, 1997; Anderson, Smith, & Weld,
1998; Koehler, Nebel, Homann, & Dimopoulos, 1997) still useful goal recognition.
languages allow use disjunctive preconditions, conditional eects, universally
quantied preconditions (goal descriptions) eects action goal representation.
ADL-like domain representation actually based work, allows use
conditional eects, universally quantied eects, existentially universally quantied
preconditions goal descriptions action goal representation.
Goal-Graph-based approach extends Lesh Etzionis previous work
use graph representation actions goals goal recognition problem (Lesh &
Etzioni, 1995). used graph representation, called consistency graph, goal
recognition problem. consistency graph consists action goal nodes representing
possible actions goals, edges representing possible connections nodes
5

fiHong

graph. Initially, action goal nodes fully connected consistency
graph, inconsistent goals repeatedly pruned consistency graph.
number major dierences Lesh Etzionis approach ours.
First, two dierent graph representations used. Apart action goal nodes,
consistency graph nodes representing propositions model
state world changed observed actions. Therefore, consistency graph
explicitly reveal causal links actions goals. Neither system
know whether goal partially fully achieved observed actions. Goal
Graph consists action, goal, proposition nodes. explicitly reveals causal links
actions goals, hence system knows observed actions composed
valid plans recognised goals part goals. systems knows whether
goal partially fully achieved observed actions.
Second, goal consistency dened dierently. Lesh Etzionis approach, goal
consistent exists plan includes observed actions achieves
goal. approach, goal consistent partially fully achieved
observed actions relevant strict majority observed actions. Also, two
dierent recognition processes used. approach pruning process used
prune inconsistent goals consistency graph. pruning process guarantees
goals pruned consistency graph inconsistent goals. However, number
consistent goals, still remaining consistency graph pruning, usually large. Thus
ambiguity intended goal remains issue addressed. approach instead
uses graph analysis process directly recognise consistent goals fully
partially achieved goals. number consistent goals recognised Goal Graph
usually small. Third, approach requires every observed action relevant
goal, strict majority observed actions required relevant
goal approach.
developed two algorithms, GoalGraphConstructor GoalGraphAnalyser,
based two-stage paradigm Goal Graph construction analysis. GoalGraphConstructor algorithm takes set actions observed dierent time
steps constructs Goal Graph. GoalGraphAnalyser algorithm analyses constructed Goal Graph recognise consistent goals valid plans. prove
algorithms sound, polynomial-time, polynomial-space.
algorithms implemented Prolog tested UNIX domain
desktop Pentium III processor 600 MHz. used set data, collected
UNIX domain University Washington, domain representation 35 action
schemata 249 goal schemata. entire UNIX data set, average took
CPU seconds update Goal Graph observed action processed, usually
small number consistent goals remained sequence actions
observed. test cases intended goals successfully achieved
subjects, intended goals among remaining goals recognised
complete sequences actions observed. test scalability algorithms,
tested series spaces approximate 104 , 2 104 , 105 candidate goals
respectively UNIX domain, approximate linear time performance
achieved. empirical results show algorithms scaled applied
domains tens thousands possible goals plans.
6

fiGoal Recognition Goal Graph Analysis

3. Domain Representation
use ADL-like representation (Pednault, 1989), including actions conditional
universally quantied eects, existentially well universally quantied preconditions
goal descriptions. approach goal recognition, goal recognition problem
consists
set action schemata specifying primitive actions.
nite, dynamic universe typed objects objects either added
deleted action.
set propositions called Initial Conditions.
set goal schemata specifying possible goals.
set actions observed consecutive time steps.3
solution goal recognition problem consists set partially fully achieved
goals consistent set observed actions together valid plans
consisting observed actions recognised goals part them.
goal schema consists set goal descriptions (GDs) dened
following EBNF denitions.
<GD>
<GD>
<GD>
<GD>
<GD>
<GD>
<GD>
<GD>
<GD>

::=
::=
::=
::=
::=
::=
::=
::=
::=

<term>
(not <term>)
(neg <term>)
(and <GD>*)
(imply <GD> <GD>)
(exist <term> <GD>)
(forall <term> <GD>)
(eq <argument> <argument>)
(neq <argument> <argument>)

action schema consists set preconditions set eects. set
preconditions dened goal descriptions. set eects dened
following EBNF denitions.
<effect>
<effect>
<effect>
<effect>
<effect>

::=
::=
::=
::=
::=

<term>
(neg <term>)
(and <effect>*)
(when <GD> <effect>)
(forall <term> <effect>)

3. say observed action, mean action observed successfully executed.
ignore invalid actions. UNIX domain, instance, invalid actions issued
commands UNIX failed execute responded error messages.

7

fiHong

two sets EBNF denitions, <term> atomic expression form:
<term> ::= (<predicate-name> <argument>*)
<argument> ::= <constant-name>
<argument> ::= <variable-name>
use eq neq specify equality inequality constraints. two negation
connectives: neg not. use (neg A) specically mean truth value
made explicitly known false action. use (not A) mean truth value
known false either explicitly implicitly. latter kind representation
used necessary represent truth value explicitly known
false long known false. closed world assumption therefore
implemented follows. initial state world, explicitly represent
propositions known true Initial Conditions. proposition explicitly
represented state world implicitly known false. Actions however may
add propositions explicitly known false state world. proposition
become explicitly known false made explicitly known
false action. important represent propositions explicitly known
false, want explicitly represent eects actions causal links
either two actions action goal established.
goal action schemata parameterised typed variables represented
terms object type predicates. goal ground instance goal schema.
action ground instance action schema. set goal descriptions goal must
satised state world goal fully achieved.
goal descriptions satised instead, goal partially achieved. Positive literals
goal descriptions represent propositions true state world. Negative literals
goal descriptions represent propositions known false state world.
use imply specify dependency constraints goal descriptions. goal description GD2
implied another goal description GD1 , GD2 satised GD1 satised
GD1 satised without GD2 satised. goal description existentially
universally quantied dynamic universe objects.
set preconditions must satised state world action
executed. set preconditions syntax semantics
set goal descriptions. set eects taken state world
action executed. Positive literals eects represent propositions true state
world action executed. propositions added state
world. Negative literals eects represent propositions longer true state
world action executed. propositions deleted state
world, negations propositions added state world,
representing propositions explicitly known false state world
action executed. Furthermore, conditional eect consists antecedent
consequent, antecedent set preconditions consequent set
eects. eects consequent taken preconditions
antecedent satised state world action executed. eect
action schema universally quantied dynamic universe objects.
8

fiGoal Recognition Goal Graph Analysis

use simple example domain extended Pednaults famous example (Pednault,
1988). involves transportation two physical objects, dictionary, chequebook,
home oce using briefcase. assume one physical object
carried briefcase time. extended briefcase domain consists
special physical object: briefcase.
Two physical objects: dictionary chequebook.
Two locations: home oce.
Three action schemata:
Moving briefcase one location another,
Putting physical object briefcase,
Taking physical object briefcase.
Three goal schemata:
Moving physical object one location another,
Keeping physical object location,
Keeping physical object briefcase.
action goal schemata example domain shown Figure 1.
used throughout paper.
actual implementation goal recognition algorithms, universally quantied
preconditions eects, conditional eects action schemata eliminated;
equivalent schemata created. use particular approach call dynamic expansion.
Dynamic expansion involves two steps. rst step, universally quantied preconditions
eects action schema dynamically compiled corresponding Herbrand
bases, taking account universe objects current time step. universally
quantied preconditions eects dynamically compiled assume
universe objects dynamically changed. assumption needed
domain UNIX shell system destruction creation objects required.
assumption dynamic universe objects, object universe,
object type must declared time step immediately action
executed. object initial universe objects, type must declared
Initial Conditions. object either added deleted universe objects
action time step, eect either stating proposition new object
negating proposition existing object.
instance, suppose time step immediately instance action
schema mov-b shown Figure 1 executed, universe objects consists three physical
objects: B, C, D. Action schema mov-b dynamically compiled action schema
mov-b-1 follows.
9

fiHong

(:action mov-b
:paras (?l ?m - loc)
:pre (and (neq ?l ?m)(at B ?l))
:eff (and (at B ?m) (neg (at B ?l))
(forall (?z - physob)
(when (in ?z)
(and (at ?z ?m)
(neg (at ?z ?l)))))) )
(:action put-in
:paras (?x - physob ?l loc)
:pre (and (neq ?x B)(at ?x ?l)(at B ?l))
(forall (?z - physob)
(not (in ?z))))
:eff (in ?x) )
(:action take-out
:paras (?x - physob)
:pre (in ?x)
:eff (neg (in ?x)) )
(:goal move-object
:paras (?x - physob ?l ?m - loc)
:goal-des (and (neq ?l ?m)
(neq ?x B)
(imply (neg (at ?x ?l))
(at ?x ?m))) )
(:goal keep-object-at
:paras (?x - physob ?l - loc)
:goal-des (and (neq ?x B)
(imply (at ?x ?l)
(not (in ?x)))) )
(:goal keep-object-in
:paras (?x - physob)
:goal-des (in ?x) )
Figure 1: action goal schemata extended briefcase domain

10

fiGoal Recognition Goal Graph Analysis

(:action mov-b-1
:paras (?l ?m - loc)
:pre (and (neq ?l ?m) (at B ?l))
:eff (and (at B ?m) (neg (at B ?l))
(when (in B)
(and (at B ?m)
(neg (at B ?l))))
(when (in C)
(and (at C ?m)
(neg (at C ?l))))
(when (in D)
(and (at ?m)
(neg (at ?l))))) )
second step, conditional eects mov-b-1 eliminated. Assume
that, time step, following propositions true: (at B H), (at C H), (at H),
(in D). conditional eects mov-b-1, whose antecedents satised
time step, removed. therefore action schema mov-b-2.
(:action mov-b-2
:paras (?l ?m - loc)
:pre (and (neq ?l ?m) (at B ?l))
:eff (and (at B ?m) (neg (at B ?l))
(when (in D)
(and (at ?m)
(neg (at ?l))))) )
antecedent remaining conditional eect mov-b-2 already satised
time step moved existing preconditions. nally action schema
mov-b-3 current time step. Action schema mov-b-3 equivalent original
action schema mov-b current time step. mov-b-3 actually used
action schema, Moving briefcase one location another, time step.
(:action mov-b-3
:paras (?l ?m - loc)
:pre (and (neq ?l ?m) (at B ?l)
(in D))
:eff (and (at B ?m) (neg (at B ?l))
(at ?m) (neg (at ?l))))
universally quantied goal descriptions goal schema treated
way universally quantied preconditions action schema.

4. Goal Graphs, Valid Plans Consistent Goals
section, rst describe structure Goal Graph. dene
mean say set observed actions forms valid plan achieving goal given
11

fiHong

mov-b H

put-in H

mov-b H

Actions

B
H

B H
B

B H

B

B

B H

C H

H

H



C H

C H

H
C H




keep-object-at H

keep-object-at H

keep-object-at C H

keep-object-at C H
keep-object-in D*

Propositions

move-object H O*

keep-object-at C H

Goals

keep-object-at C H
keep-object-in
keep-object-at

Level 1

Level 2

Level 3

Level 4

Figure 2: Goal Graph example extended briefcase domain
Initial Conditions. nally dene mean say goal consistent
set observed actions.
4.1 Goal Graphs
Goal Graph represents actions observed, propositions true explicitly known
false, fully partially achieved goals consecutive time steps. Goal Graph
explicitly represents connections propositions, actions, goals graph.
Goal Graph directed, levelled graph. levels alternate proposition
levels containing proposition nodes (each labelled proposition negation proposition), representing state world consecutive time steps; goal levels containing
goal nodes (each labelled goal), representing goals fully partially achieved consecutive time steps; action levels containing action nodes (each labelled action),
representing actions observed consecutive time steps. levels Goal Graph start
proposition level time step 1, consisting one node proposition true
Initial Conditions. end goal level last time step, consisting
node goals either fully partially achieved actions observed far.
levels are: propositions true time step 1, goals achieved time step 1, actions
observed time step 1; propositions true explicitly known false time step 2,
goals achieved time step 2, actions observed time step 2; propositions true explicitly
known false time step 3, goals achieved time step 3, forth.
goal nodes goal-level connected description edges goal descriptions proposition-level i. action nodes action-level connected precondition
edges preconditions proposition-level i, eect edges eects
proposition-level + 1. proposition nodes proposition-level connected via
persistence edges corresponding proposition nodes proposition-level + 1,
truth values aected actions action-level i. persistence edges
represent eects maintenance actions simply bring forward proposition nodes
proposition-level i, aected actions action-level i, proposition-level + 1.
example shown Figure 2, three actions observed three consecutive time steps: (mov-b H), (put-in H), (mov-b H O). Initial Conditions
12

fiGoal Recognition Goal Graph Analysis

consist of: (at B O), (at H), (at C H). Action goal nodes top
bottom parts graph respectively. proposition nodes middle part
graph. edges connecting proposition nodes action node level
precondition edges. edges connecting action node one level propositions
subsequent level eect edges. edges connecting proposition nodes goal
nodes level description edges. edges connecting proposition nodes
one level proposition nodes subsequent level persistence edges. goal nodes
bold represent consistent goals, among goal nodes italics represent partially
achieved goals, others represent fully achieved goals. edges bold show
causal link paths. goal nodes asterisk represent recognised goals.
4.2 Valid Plans
dene mean say set observed actions forms valid plan
goal, given Initial Conditions.
Definition 1 (Causal Link) Let ai aj two observed actions time steps j
respectively, < j. exists causal link ai aj , written ai aj ,
one eects ai satises one preconditions aj .
instance, example shown Figure 2, exists causal link actions
(mov-b H) time step 1 (put-in H) time step 2, since one eects
rst action, (at B H), satised one preconditions second action.
goal treated action goal descriptions preconditions
empty set eects. Therefore, causal links established observed actions
goals.
instance, example shown Figure 2, exists causal link action
(mov-b H O) time step 3 goal (move-object H O) time step 4, since one
eects action, (at O), satised one goal descriptions goal.
valid plan goal dened basis temporal ordering constraints
causal links set observed actions. valid plan P goal g, given Initial
Conditions, represented 3-tuple, < A, O, L >, set observed actions,
set temporal ordering constraints A, L set causal links A.
Definition 2 (Valid Plan) Let g goal, P =< A, O, L >, set
observed actions, set temporal ordering constraints, {ai < aj }, A, L
set causal links, {ai aj }, A. Let Initial Conditions. P valid plan
g, given I,
1. actions executed order consistent O;
2. goal g fully achieved actions executed order
consistent O.
instance, example shown Figure 2, given Initial Conditions, = {(at
B O), (at H), (at C H)}, P = ({a1 = (mov-b H), a2 = (put-in H), a3 = (mov-b
H O)}, {a1 < a2 , a2 < a3 }, {a1 a2 , a1 a3 , a2 a3 }) valid plan goal g =
(move-object H O).
13

fiHong

4.3 Consistent Goals
dene mean say goal consistent set observed
actions. set observed actions represented 2-tuple, < A, >,
set observed actions set temporal ordering constraints, {ai < aj }, A.4
Definition 3 (Relevant Action) Given goal g set observed actions, < A, >,
action said relevant g context < A, >,
1. exists causal link, g;
2. exists causal link, b, b relevant g < b consistent
O.
Definition 4 (Consistent Goal) goal g consistent set observed actions,
< A, >, strict majority relevant g context
< A, >.
Proposition 1 (Valid Plan Consistent Goal) Let < A, > set observed
actions, Initial Conditions < A, >, g goal consistent < A, >.
exists set causal links, L = {ai aj }, given I, P =< A, O, L >
valid plan either g g fully achieved time step < A, >
observed achieved part g g partially achieved time step
< A, > observed.
Proof. g fully achieved time step set actions observed,
directly follows Denitions 3 4 exists set causal links, L = {ai aj },
A. follows Denition 2 given I, P =< A, O, L > valid plan g.
g partially achieved time step set actions observed,
let g achieved part g. g fully achieved time step set
actions observed, directly follows Denitions 2, 3 4 exists
set causal links, L = {ai aj }, given I, P =< A, O, L > valid plan
g. 2
instance, example shown Figure 2, < A, > = < {a1 = (mov-b
H), a2 = (put-in H), a3 = (mov-b H O)}, {a1 < a2 , a2 < a3 } >, g = (move-object
H O) fully achieved goal time step < A, > observed. According
Denition 3 4, g consistent < A, > exist causal links, a3 g
a3 g, a2 a3 a2 a3 , a1 a3 a1 a3 , a1 a2
a1 a2 . Let Initial Conditions < A, >, L = {a1 a2 , a1 a3 ,
a2 a3 }, according Proposition 1, P =< A, O, L > valid plan g. Furthermore,
causal link, a3 g, explains purpose a3 .
summary, according Denition 4 Proposition 1, say goal consistent
set observed actions, mean strict majority observed actions
relevant goal set observed actions forms valid plan goal
achieved part it.
4. assume actions observed consecutive time steps one action observed
time step.

14

fiGoal Recognition Goal Graph Analysis

5. Goal Recognition Algorithms
describe goal recognition algorithms. goal recognition algorithms run
two-stage cycle time step. rst stage, GoalGraphConstructor algorithm
takes actions observed time step tries extend Goal Graph. second
stage, GoalGraphAnalyser algorithm analyses constructed Goal Graph recognise
fully partially achieved goals, consistent actions observed far,
valid plans goals part them. two-stage cycle continues
action observed next time step.
5.1 Constructing Goal Graph
use 4-tuple < P, AO , GR , E > represent Goal Graph, P set proposition nodes, AO set action nodes, GR set goal nodes, E set edges.
proposition node represented prop(p, i), p positive negative ground literal,
time step. action node represented action(a, i), observed action
time step. goal node represented goal(g, i), g goal
time step. precondition edge represented precondition-edge(prop(p, i), action(a, i)),
eect edge represented eect-edge(action(a, i), prop(p, + 1)), description edge
represented description-edge(prop(p, i), goal(g, i)), persistence edge represented
persistence-edge(prop(p, 1), prop(p, i)).
GoalGraphConstructor algorithm consists two algorithms: goal expansion
algorithm action expansion algorithm. GoalGraphConstructor algorithm starts
Goal Graph, < P, {}, {}, {} >, consists proposition-level 1 nodes
representing Initial Conditions.
Given Goal Graph ending proposition-level i, goal expansion algorithm rst
extends Goal Graph goal-level i, nodes representing goals fully partially
achieved time step i. algorithm goes every possible ground instance goal
schemata. every goal instance, rst gets set goal descriptions. eliminates
universally quantied goal descriptions dynamic expansion get equivalent
set goal descriptions. goal node added onto goal-level represent achieved
goal, least one goal descriptions satised proposition-level i.
decided whether goal fully partially achieved, based whether
goal descriptions satised respectively proposition-level i. Meanwhile,
node proposition-level satises goal description, description edge connecting
proposition node goal node added onto Goal Graph. Figure 3 shows
goal expansion algorithm. algorithm takes Goal Graph < P, AO , GR , E > ending
proposition-level i, time step i, set goal schemata G input. returns
updated Goal Graph ending goal-level goal expansion.
actions observed time step i, action expansion algorithm extends Goal Graph ending goal-level i, action-level i, nodes representing
observed actions. time, algorithm extends Goal Graph
proposition-level + 1, nodes representing propositions true explicitly known
false actions observed.
every action observed time step i, algorithm rst instantiates action schema
observed action get precondition set eect set. eliminates
15

fiHong

Goal-Expansion(< P, AO , GR , E >, i, G)
1. every Gk G
every instance g Gk
a. Get set goal descriptions Sg .
b. Get equivalent set Sg , Sg .
c. every pg Sg , pg = not(pg ),
prop(neg(pg ), i) P ,
Add description-edge(prop(neg(pg), i), goal(g, i)) E.
d. every pg Sg , pg = not(pg ),
prop(pg , i) P ,
Add description-edge(prop(pg, i), goal(g, i)) E.
e. one goal descriptions g satised,
Add goal(g, i) GR .
2. Return < P, AO , GR , E >.
Figure 3: goal expansion algorithm

universally quantied preconditions eects, well conditional eects,
dynamic expansion get equivalent precondition eect sets. Meanwhile, node
proposition-level satises precondition action, precondition edge, connecting
proposition node action node, added onto Goal Graph. every eect
action, action expansion algorithm simply adds proposition node representing
eect proposition-level + 1. eect edge action node proposition
node added onto Goal Graph.
expansion, every proposition node proposition-level brought
forward proposition-level + 1 maintenance action, truth value
changed action observed time step (and added onto Goal Graph
action observed time step i).5 Persistence edges, connecting corresponding
proposition nodes two proposition levels, added onto Goal Graph.
Figure 4 shows action expansion algorithm. algorithm takes Goal Graph
< P, AO , GR , E > ending goal-level i, set actions observed time step i, Ai ,
time step i, set action schemata input. returns updated Goal Graph
ending proposition-level + 1 action expansion. expansion Goal
Graph proposition-level proposition-level + 1 simulates eects executing
actions observed time step i.
otherwise action observed time step i, GoalGraphConstructor algorithm nishes nodes goal-level i, representing possible goals either fully
partially achieved actions observed.

5. goal recognition algorithms allow redundant actions.

16

fiGoal Recognition Goal Graph Analysis

Action-Expansion(< P, AO , GR, E >, Ai , i, A)
1. every ai Ai
a. Add action(ai, i) AO .
b. Instantiate action schema ai get precondition set
SP , eect set SE .
c. Get equivalent sets SP SE , SP SE .
d. every pp SP , pp = not(pp ),
prop(neg(pp, i) P ,
Add precondition-edge(prop(neg(pp, i), action(ai, i)) E.
e. every pp SP , pp = not(pp ),
prop(pp, i) P ,
Add precondition-edge(prop(pp, i), action(ai, i)) E.
f. every pe SE
i. Add prop(pe, + 1) P .
ii. Add eect-edge(action(ai, prop(pe, + 1)) E.
2. every prop(p, i) P
prop(p, + 1)
/ P ,
prop(p, + 1)
/ P , Add prop(p, + 1) P ;
Add persistence-edge(prop(p, i), prop(p, + 1)) E.
3. Return < P, AO , GR , E >.
Figure 4: action expansion algorithm
Theorem 1 (Polynomial Size Time) Consider goal recognition problem
observed actions time steps, nite number objects time step, p propositions
Initial Conditions, goal schemata constant number parameters.
Let l1 largest number eects action schema, l2 largest number
goal descriptions goal schema. Let n largest number objects time
steps. Then, size Goal Graph + 1 levels created GoalGraphConstructor
algorithm, time needed create graph, polynomial n, m, p, l1 , l2 , s.
Proof. maximum number nodes proposition level O(p + l1 s). Let k
largest number parameters goal schema. Since goal schema
instantiated nk distinct ways, maximum numbers nodes edges
goal level O(mnk ) O(l2 mnk ) respectively. obvious time needed
create nodes edges level polynomial number nodes edges
level. 2
Theorem 2 GoalGraphConstructor algorithm sound: goal adds Goal
Graph time step one either fully partially achieved time step state
world. algorithm complete: goal either fully partially achieved
observed actions time step 1, algorithm add Goal Graph
time step i, assumption possible goals restricted categories
goal schemata.
17

fiHong

Proof (soundness). Proposition-level 1 Goal Graph consists Initial
Conditions, representing state world time step 1 action
observed. Goal Graph extended proposition-level 1 proposition-level i,
adding eects actions observed time step i1, bringing forward
proposition nodes aected actions proposition-level
1 proposition-level i. Therefore, proposition-level Goal Graph represents
state world time step i, changed Initial Conditions
actions observed time steps 1, ..., 1.
goal added Goal Graph time step algorithm fully partially
achieved goal proposition-level Goal Graph. Therefore, goal fully
partially achieved state world time step i.
Proof (completeness). Suppose goal either fully partially achieved
actions observed time steps 1, ..., 1. goal either fully partially achieved
proposition-level Goal Graph. Since goal-level Goal Graph consists
possible instances goal schemata, fully partially achieved
proposition-level Goal Graph, goal instance goal schema, one
fully partially achieved goal instances proposition-level i. algorithm
therefore add goal goal-level Goal Graph. 2
5.2 Recognising Consistent Goals Valid Plans
GoalGraphAnalyser algorithm analyses constructed Goal Graph recognise consistent goals valid plans. assume strict majority observed actions
relevant goal intended agent context agents actions. Therefore,
goal intended agent consistent set observed actions, goal
may intended goal consistent set observed actions. order
decide whether goal consistent set observed actions, is, whether
relevant strict majority observed actions, need recognise causal links
either two observed actions observed action goal. dene
two particular types paths, call causal link paths, constructed Goal Graph.
prove Theorems 3 4 causal links recognised identifying causal link
paths.
Definition 5 Given Goal Graph, let ai action observed time step gj
goal fully partially achieved time step j, < j. path connects ai gj
via eect edge, zero persistence edges, description edge, called causal
link path ai gj .
Theorem 3 Given Goal Graph, exists causal link, ai gj , action ai
time step goal gj time step j, < j, ai connected gj via causal
link path.
Proof. According Denition 5, causal link path ai gj consists
eect edge, zero persistence edges, description edge. eect edge
path connects ai proposition node proposition-level + 1, representing one
eects ai . j = + 1, persistence-edge path proposition
18

fiGoal Recognition Goal Graph Analysis

node connected gj description edge. j > + 1, proposition node
brought forward proposition-level j via j i1 persistence-edges j i1 maintenance
actions, brought-forward proposition node proposition-level j connected gj
description edge. either case, one eects ai satised one goal
descriptions gj . Since goal treated action goal descriptions
preconditions empty set eects, according Denition 1, exists causal
link ai gj . 2
Definition 6 Given Goal Graph, let ai aj two actions observed time steps
j respectively, < j. path connects ai aj via eect edge, zero
persistence edges, precondition-edge, called causal link path ai
aj .
Theorem 4 Given Goal Graph, exist causal link, ai aj , action ai
time step action aj time step j, < j, ai connected aj via
causal link path.
proof Theorem 4 similar Theorem 3. details proof omitted.
Given constructed Goal Graph < P, AO , GR , E > levels, GoalGraphAnalyser
algorithm shown Figure 5 recognises every consistent goal goals goal-level t,
deciding whether strict majority observed actions relevant it.
done rst nding relevant actions observed actions, connected
goal causal link paths. already-known relevant actions, algorithm
tries nd relevant actions observed actions, connected
causal link paths. continues relevant action found. consistent
goal recognised valid plan goal part represented 3-tuple,
< gt, < AO , O, La >, Lg >, gt goal, La set causal links observed
actions, Lg set causal links observed actions goal.
< AO , O, La > represents valid plan gt part it, Lg explains
purposes observed actions.
Proposition 2 GoalGraphAnalyser algorithm sound: goal g recognises
time step consistent observed actions far, plan organises g
part g valid.
Proof. GoalGraphAnalyser algorithm recognises goal g time step t,
strict majority observed actions connected g, either directly causal link
path indirectly chain causal link paths. observed action connected
g directly causal link path, according Theorem 3 Denition 3, exists
causal link observed action g, observed action relevant
g. observed action connected g indirectly chain causal link paths,
according Theorem 3, Theorem 4, Denition 3, chain causal links
observed action g, observed action relevant g. Since strict
majority observed actions relevant g, according Denition 4, g consistent
set observed actions. Furthermore, according Proposition 1, plan
GoalGraphAnalyser algorithm organises g part g, < AO , O, La >, valid plan.2
19

fiHong

GoalGraphAnalyser(< P, AO , GR , E >, t)
1. every gt GR goal-level
a. AO {}, {}, Lg {}, La {}.
b. every ai AO connected gt causal link path
Add ai gt Lg ;
Add ai AO ;
Add ai A.
c. = {} ai AO , ai AO ,
Get ordering constraints, O, AO ;
Add < gt , < AO , O, La >, Lg > GoalPlan.
d. = {},
Remove action aj A;
every ai AO connected aj causal link path
Add ai aj La ;
/ AO , Add ai AO , ai A;
ai
Go 1c.
2. Return GoalPlan.
Figure 5: GoalGraphAnalyser algorithm

example shown Figure 2, goal nodes bold represent three consistent
goals, among goal node italics represents partially achieved goal,
two represent two fully achieved goals. edges bold show causal link paths.

Theorem 5 (Polynomial Space Time) Consider t-level Goal Graph. Let l1
number fully partially achieved goals time step t, m1 largest number
goal descriptions goals, l2 number observed actions, m2
largest number preconditions actions. space size possible
causal link paths, connect goals observed actions connect observed
actions observed actions, time needed recognise consistent goals,
polynomial l1 , l2 , m1 , m2 .

Proof. Persistence edges branch Goal Graph. goals
goal-level t, maximum number paths searched observed actions,
connected goal causal link paths hence relevant it, O(m1 ).
relevant actions goal, maximum number paths searched observed
actions, connected relevant action causal link paths hence
relevant goal, O(m2 ). maximum l1 goals goal-level
l2 relevant actions goals. space size possible causal link paths
O(l1 (m1 + l2 m2 )). time needed recognise consistent goals polynomial
space size. 2
20

fiGoal Recognition Goal Graph Analysis

5.3 Goal Redundancy
GoalGraphAnalyser algorithm recognises fully partially achieved goals time step,
consistent actions observed far. Among consistent goals, fully
achieved goals better explain actions observed far. instance, example shown
Figure 2, two consistent goals recognised GoalGraphAnalyser algorithm time
step 4: (move-object H O) fully achieved (keep-object-at O) partially
achieved. two consistent goals, fully achieved goal better explains
observed actions far. If, instance, another action (take-out D) observed next
time step, (keep-object-at O) becomes fully achieved remains consistent
observed actions. time step, best explains observed actions. partially
achieved goal, consistent observed actions far, remain consistent
actions observed future becomes fully achieved. choosing
fully achieved goal making partially achieved goal redundant rule
possibility partially achieved goal remaining consistent becoming fully achieved
future. Based principle, make partially achieved consistent goal
time step redundant, satised goal descriptions implied satised goal
descriptions another fully partially achieved consistent goal.
Definition 7 partially achieved consistent goal time step redundant, set
satised goal descriptions either subset goal descriptions fully achieved consistent goal proper subset satised goal descriptions another partially achieved
consistent goal time step.
instance, time step 4 set satised goal descriptions (keep-object-at
O) subset goal descriptions (move-object H O). partial achievement
(keep-object-at O) implied full achievement (move-object H
O). (keep-object-at O) made redundant (move-object H O) time step
4.
fully achieved consistent goal time step, however, made redundant
goal descriptions implied goal descriptions another fully achieved consistent
goal time step.
Definition 8 fully achieved consistent goal time step redundant, set
goal descriptions subset goal descriptions another fully achieved consistent goal
time step.
5.4 Consistent Goals
redundant goals removed set consistent goals time
step, might still one consistent goal set. case,
numbers observed actions relevant remaining consistent goals
compared. remaining goals maximum number relevant actions
chosen consistent goals time step.
Definition 9 Given set consistent goals time step, consistent goal set
consistent goal set, maximum number relevant actions among
consistent goals set.
21

fiHong

instance, example shown Figure 2, another action (take-out D)
observed time step 4, (move-object H O) (keep-object-at O) consistent goals time step 5, neither redundant. (keep-object-at O)
relevant observed actions, (move-object H O) relevant
four observed actions. According Denition 9, (keep-object-at O)
consistent goal time step 5.
example shown Figure 2, goal nodes asterisk represent consistent
goals eventually remaining two processes removing redundant goals selecting
consistent goals.

6. Experimental Results
implemented goal recognition algorithms Prolog tested terms
accuracy, eciency, scalability desktop Pentium III processor 600 MHz.
tested algorithms set data UNIX domain collected University
Washington. collect data, subjects given goals described English rst
tried achieve goal executing UNIX commands. commands
issued UNIX subject responses UNIX commands
recorded data set. commands issued subject valid
could executed UNIX. responses UNIX invalid commands
actually error messages. goals subjects tried achieve,
indicated success failure regard achievement goal.
14 goals UNIX data set, goals tried 5 subjects
average. shown Table 1, goals classied four types. rst type
goals locating le properties, extension, size,
contents, ownership, date, word count, compression. second type goals
locating machine properties, load logged-in users.
third type goals locating printer properties,
print jobs paper. fourth type goals compressing large
les directory. fourth type goals, universally quantied goal descriptions
needed corresponding goal schemata. addition, two compound
goals, G3 G9 , conjunctions two goals second type.
test algorithms, sequences UNIX commands, recorded data set,
taken observed actions consecutive time steps. took valid commands,
successfully executed UNIX, ltered invalid commands,
UNIX failed execute responded error messages. created 35 action
schemata set commonly used UNIX commands, including executed
subjects. created 249 goal schemata, including 129 le-search goal schemata (for
goals locating le properties), 15 non-le-search goal schemata (for goals
locating machine printer properties goals compressing
large les directory) 105 goal schemata paired non-le-search goals.
14 goals UNIX data set instances goal schemata. rst
tested algorithms respect accuracy eciency, is, number goals
remaining sequence observed actions processed, average time
22

fiGoal Recognition Goal Graph Analysis

G1
G2
G3
G4
G5
G6
G7
G8
G9
G10
G11
G12
G13
G14

Find le named core.
Find le contains motivating whose name ends .tex.
Find machine low (< 1.0) load;
determine Oren Etzioni logged machine named chum.
Compress large (> 10,000 bytes) les Testgrounds subdirectory tree.
Compress les directory named backups [Dont use *].
Find large le (> 100,000 bytes) hasnt changed month.
Find le contains less 20 words.
Find laser printer Sieg Hall active print job.
Find Sun fourth oor low (< 1.0) load;
determine Dan Weld active machine named chum.
Find printer paper.
Find le named oldpaper neal/Testgrounds subdirectory.
Find le length 4 neal/Testgrounds subdirectory.
See Dan Weld logged chum.
Find machine Dan Weld logged into.

Table 1: 14 goals UNIX data set collected University Washington
taken construct Goal Graph, analyse constructed Goal Graph, run
cycle Goal Graph construction analysis, action observed time step.
Table 2 gives summary empirical results showing accuracy algorithms.
rst column shows goals subject tried achieve. achieved goals
goals fully partially achieved last observed action processed.
consistent goals fully partially achieved goals consistent
sequence observed actions.6 remaining goals goals remained
redundant goals removed consistent goals selected.
last column shows whether given goal among remaining goals.
shown Table 2, algorithms successfully recognised 13 14 given goals.
failed recognise one given goal, G10 , simply sequence commands
executed subject actually failed achieve goal. terms UNIX data set,
goal recognition occurs algorithms return single, consistent goal. occurred
G2 , G4 , G7 , G8 , G9 , G13 , G14 . G1 , G3 , G6 , G11 , G12 , one goal
recognised, including goal given subject. G1 , G6 , G11 , G12 ,
algorithms recognised subject tried nd one les properties
directory know le was. instance, G1 , intended
goal nd le named core. subject successfully found le named core
directory, other, executing command, ls, list les directory. Since
les, greenmouse, paper.tex, action.ps.Z, directory,
6. experiments UNIX data set, goal, two third observed actions
relevant, recognised consistent goal. threshold number relevant actions
dependent application domain though strict majority actions must relevant.
threshold high, algorithms might fail recognise intended goal. hand,
low, set recognised goals might large provide much value great ambiguity
intended goal.

23

fiHong

goal
G1
G2
G3
G4
G5
G6
G7
G8
G9
G10
G11
G12
G13
G14

achieved
goals
15
26
14
56
46
107
85
6
22
9
12
60
1
8

consistent
goals
15
6
4
18
33
47
4
4
5
0
12
44
1
2

remaining
goals
4
1
2
1
6
4
1
1
1
0
2
6
1
1

given goal
recognised















Table 2: Empirical results UNIX domain showing accuracy algorithms

les listed command, algorithms recognised four
goals, nding le named core, nding le named greenmouse, nding le named
paper extension tex, nding le named action extension ps
compressed. G3 , algorithms recognised subject tried nd one
users machine know was. good human
observer could simply could tell observed actions le
user subject trying nd. recognised goals generalised single,
consistent goal nding le directory nding user using machine,
variables allowed recognised goals.
G5 , algorithms recognised 6 consistent goals. Among goals, goals
nd les properties compression extension
directory named backups. Another goal gunzip les directory
named backups. human observer could probably better recognising goal
gunzipping les directory named backups, accounted better
gunzip command observed. unlikely subject gunzipped
les directory order nd le gunzip compression.
Among goals tested, G1 , G2 , G3 , G4 originally tested Lesh
Etzioni (1995). empirical results show signicant improvement accuracy
goal recogniser implemented terms remaining goals. algorithms
4, 1, 2, 1 remaining goals G1 , G2 , G3 , G4 respectively, goal
recogniser 155, 37, 1, 15 remaining goals G1 , G2 , G3 , G4 respectively,
last observed action processed. Furthermore, 4 2 remaining goals
algorithms G1 G3 generalised two single goals. results
show algorithms perform extremely well regard accuracy.
24

fiGoal Recognition Goal Graph Analysis

goal
G1
G2
G3
G4
G5
G6
G7
G8
G9
G10
G11
G12
G13
G14

length
observation
2.25
16
3.0
20.5
9
8.78
9.11
3.5
12
15
7
17
1
2

construction
time
0.535
0.382
0.021
1.036
0.426
12.185
16.473
0.014
0.034
0.018
0.051
0.821
0.010
0.013

analysis
time
0.013
0.102
0.009
3.609
0.565
4.143
8.581
0.002
0.050
0.007
0.020
0.774
0.001
0.004

time
per cycle
0.547
0.484
0.030
4.645
0.991
16.329
25.054
0.017
0.084
0.025
0.071
1.595
0.011
0.017

Table 3: Empirical results UNIX domain showing eciency algorithms

worth noting Lesh Etzionis algorithm converges last observed
action processed. algorithm works towards goal prediction, algorithms emphasise explanation observed actions, recognising fully partially
achieved goals consistent actions. algorithm quickly prune
inconsistent goals get converged set hypothesised goals, though number
hypothesised goals set sometimes large. next step work might
assign probabilities hypothesised goals dierentiate single goal
others, exists one intended goal. hand, less desirable
goals recognised algorithms dierentiated accuracy
algorithms usually high. algorithms, however, cannot recognise goal
fully partially achieved.
Table 3 gives summary empirical results showing eciency algorithms.
length observation average number observed actions executed
subjects achieve given goal. construction time average time took
construct Goal Graph time step. analysis time average time took
analyse constructed Goal Graph time step. time per cycle average
time took go two-stage cycle Goal Graph construction analysis,
observed action processed time step, including constructing Goal
Graph, recognising consistent goals, removing redundant goals, selecting
consistent goals. shown Table 3, average time step, took 2.287 CPU seconds
construct Goal Graph, 1.277 CPU seconds analyse Goal Graph, 3.564
CPU seconds process observed action. Since algorithms written
less ecient Prolog run desktop Pentium III processor 600 MHz,
eciency could achieved. construction time, analysis time, time per cycle could
25

fiHong

Average CPU Seconds

250
200

C-Time

150

A-Time
100

P-Time

50
0
10080

19790

29665

39540

49415

59290

69165

81015

90890 100765

Number Goals

Figure 6: Empirical results UNIX domain showing scalability algorithms

reduced well CPU second, algorithms coded ecient
programming language run faster machine.
Compared empirical results eciency goal recogniser implemented
Lesh Etzioni (1995), average, took 0.547, 0.484, 0.030, 4.645 CPU seconds
process observed action algorithms G1 , G2 , G3 , G4 respectively,
1.616, 1.643, 0.648, 1.610 CPU seconds taken goal recogniser process
observed action goals. average time process observed action
roughly around 1.4 CPU seconds desktop Pentium III processor
600 MHz algorithms coded Prolog SPARC 10 goal recogniser
coded Lisp. Given two dierent programming languages machines used
implementation two dierent systems, comparison hardly meaningful.
however apparent use ecient programming languages machines
signicantly speed algorithms.
tested scalability goal recognition algorithms UNIX domain.
tested eciency algorithms aected number possible goals,
turn aected number objects universe objects. created
series spaces approximate 104 , 2 104 , 3 104 , 105 possible goals respectively
based data recorded G7 UNIX data set.7 this, changed
les directories le hierarchy, well properties les, original
data set G7 , increase decrease number objects universe objects,
keeping les directories related intended goal properties
related les unchanged. sense part Initial Conditions
intended goal remained same, rest Initial Conditions changed create
7. number goal schemata remains unchanged.

26

fiGoal Recognition Goal Graph Analysis

appropriate number candidate goals. change le hierarchy reected
change complexity le hierarchy.
original sequences commands recorded data set used experiments, conjunction dierent sets Initial Conditions, creation
dierent spaces candidate goals. Figure 6 shows average CPU time taken
time step construct analyse Goal Graph (shown C-Time A-Time respectively Figure 6), process observed action whole (shown P-Time
Figure 6) approximately linear number candidate goals.

7. Conclusion Future Work
paper, presented new approach goal recognition graph structure
called Goal Graph constructed analysed goal recognition. described two
algorithms constructing analysing Goal Graph. algorithms recognise partially
fully achieved goals consistent observed actions, reveal valid plans
recognised goals part them. algorithms need plan library.
allow redundant, extraneous, partially ordered actions. sound, polynomialtime, polynomial-space.
empirical experiments show algorithms recognise goals great accuracy.
computationally ecient. scaled applied domains
tens thousands goals plans. Even though one goal recognition
algorithms, GoalGraphAnalyser algorithm, complete, recognised
intended goals UNIX data set successfully achieved subjects.
limitation goal recognition algorithms sometimes one goal
recognised, though number recognised goals usually small. algorithms
cannot tell goal probable one one intended goal.
instance, G5 UNIX data set, algorithms recognised 6 goals. Even though
intended goal, gunzipping les directory called backups, among goals,
probably likely one compared others, algorithms could
dierentiate others. Sometimes algorithms recognise unique goal
implies intended goal cannot make specic. instance, G7 UNIX
data set, algorithms recognised unique goal, nding le, index.tex, word
count extension. Even though achievement goal implied achievement
intended goal, nding le contains less 20 words, algorithms could
specic. problems due incomplete information
observed actions. G7 , observed actions indication likelihood
recognised goals intended goal. subject actually achieved G7
knew word count less 20 words knowing word count le,
observed action directly used achieve this.
Several attempts (Carberry, 1990; Charniak & Goldman, 1993; Huber et al., 1994;
Forbes et al., 1995; Pynadath & Wellman, 1995; Bauer, 1995; Albrecht et al., 1998)
made incorporate uncertainty representation reasoning techniques plan
recognition handling uncertain incomplete information, single plan
distinguished set candidate plans. However, systems rely heavily
availability planning knowledge certain extent use plan libraries. future
27

fiHong

work, intend investigate possibility incorporating uncertainty representation
reasoning mechanisms Goal-Graph-based approach goal recognition,
unique, specic goal recognised one intended goal,
good features Goal-Graph-based approach kept.
future work, intend explore extent Goal Graph representation used probabilistic goal recognition. particular, consider problem
settings eects actions probabilistic objective goal recognition
recognise consistent goals highest probability achievement.
Another area future work recognise goals even partially
fully achieved actions observed far. regard, current goal recognition
algorithms used recognise goals sequence actions large data
set achieve. sequence actions data set recognised goals
used acquire probabilistic model goal prediction machine learning method.
probabilistic model takes actions observed far predicts possible goals even
partially fully achieved.

Acknowledgments
paper revised extended version paper appeared Proceedings
AAAI-2000 (Hong, 2000). author wishes thank Neal Lesh providing UNIX
data set, anonymous referees insights constructive criticisms,
helped improve paper signicantly.

References
Albrecht, D. W., Zukerman, I., & Nicholson, A. E. (1998). Bayesian model keyhole
plan recognition adventure game. User Modeling User-Adapted Interaction,
8 (1-2), 547.
Allen, J. F. (1983). Recognizing intentions natural language utterances. Brady, M.,
& Berwick, B. (Eds.), Computational Models Discourse, pp. 107166. MIT Press,
Cambridge, MA.
Allen, J. F., & Perrault, C. R. (1980). Analyzing intention utterances. Articial Intelligence, 15, 143178.
Anderson, C., Smith, D. E., & Weld, D. (1998). Conditional eects Graphplan.
Proceedings 4th International Conference AI Planning Systems, pp. 4453.
Bauer, M. (1995). Dempster-Shafer approach modeling agent preferences plan recognition. User Modeling User-Adapted Interaction, 5 (3-4), 317348.
Bauer, M. (1998). Acquisition abstract plan descriptions plan recognition. Proceedings AAAI-98, pp. 936941.
Bauer, M., & Paul, G. (1993). Logic-based plan recognition intelligent help systems.
Backstrom, C., & Sandewall, E. (Eds.), Current Trends AI Planning, pp. 6073.
IOS Press.
28

fiGoal Recognition Goal Graph Analysis

Blum, A. L., & Furst, M. L. (1997). Fast planning Planning Graph analysis.
Articial Intelligence, 90, 281300.
Carberry, S. (1986). User models: problem disparity. Proceedings 11th
International Conference Computational Linguistics, pp. 2934.
Carberry, S. (1988). Modeling users plans goals. Computational Linguistics, 14 (3),
2337.
Carberry, S. (1990). Incorporating default inferences plan recognition. Proceedings
AAAI-90, pp. 471478.
Carver, N. F., Lesser, V. R., & McCue, D. L. (1984). Focusing plan recognition.
Proceedings AAAI-84, pp. 4248.
Charniak, E., & Goldman, R. P. (1993). Bayesian model plan recognition. Articial
Intelligence, 64, 5379.
Forbes, J., Huang, T., Kanazawa, K., & Russell, S. (1995). BATmobile: Towards
Bayesian automated taxi. Proceedings IJCAI-95, pp. 18781885.
Gazen, B., & Knoblock, C. (1997). Combining expressivity UCPOP eciency
Graphplan. Proceedings 4th European Conference Planning, pp. 221
233.
Goodman, B. A., & Litman, D. J. (1992). interaction plan recognition
intelligent interfaces. User Modeling User-Adapted Interaction, 2, 83115.
Grosz, B. J., & Sidner, C. L. (1990). Plans discourse. P. R. Cohen, J. M., & Pollack,
M. E. (Eds.), Intentions Communication, pp. 417444. MIT Press, Cambridge, MA.
Hong, J. (2000). Goal Graph construction analysis paradigm plan recognition.
Proceedings AAAI-2000, pp. 774779.
Huber, M. J., & Durfee, E. H. (1995). Deciding commit action
observation-based coordination. Proceedings First International Conference
Multi-Agent Systems, pp. 163170.
Huber, M. J., Durfee, E. H., & Wellman, M. P. (1994). automated mapping plans
plan recognition. Proceedings 10th Conference Uncertainty Articial
Intelligence, pp. 344351.
Hu, K., & Lesser, V. (1988). plan-based intelligent assistant supports software
development process. Proceedings ACM SIGSOFT/SIGPLAN Software Engineering Symposium Practical Software Development Environments, pp. 97106.
Kautz, H. A. (1987). Formal Theory Plan Recognition. PhD Thesis, University
Rochester.
Koehler, J., Nebel, B., Homann, J., & Dimopoulos, Y. (1997). Extending planning graphs
ADL subset. Proceedings 4th European Conference Planning, pp.
273285.
Lesh, N., & Etzioni, O. (1995). sound fast goal recognizer. Proceedings IJCAI95, pp. 17041710.
29

fiHong

Lesh, N., & Etzioni, O. (1996). Scaling goal recognition. Proceedings 5th
International Conference Principles Knowledge Representation Reasoning,
pp. 178189.
Litman, D. J., & Allen, J. F. (1987). plan recognition model sub-dialogues conversation. Cognitive Science, 11 (2), 163200.
Mooney, R. J. (1990). Learning plan schemata observation: Explanation-based learning
plan recognition. Cognitive Science, 14 (4), 483509.
Pednault, E. P. D. (1988). Synthesizing plans contain actions context-dependent
eects. Computational Intelligence, 4 (4), 356372.
Pednault, E. P. D. (1989). ADL: Exploring middle ground STRIPS
Situation Calculus. Proceedings 1st International Conference Knowledge
Representation Reasoning, pp. 324332.
Pollack, M. E. (1990). Plans complex mental attitudes. Cohen, P. R., Morgan,
J., & Pollack, M. E. (Eds.), Intentions Communication, pp. 77101. MIT Press,
Cambridge, MA.
Pynadath, D. V., & Wellman, M. P. (1995). Accounting context plan recognition,
application trac monitoring. Proceedings 11th Conference Uncertainty
Articial Intelligence, pp. 472481.
Schank, R., & Abelson, R. (1977). Scripts, Plans, Goals, Understanding. Erlbaum.
Sidner, C. L. (1985). Plan parsing intended response recognition discourse. Computational Intelligence, 1 (1), 110.
Wilensky, R. (1983). Planning Understanding. Addison-Wesley Publishing Company,
Reading, MA.
Wilensky, R., & et al. (1988). Berkeley unix consultant project. Computational Linguistics, 14 (4), 3584.

30


