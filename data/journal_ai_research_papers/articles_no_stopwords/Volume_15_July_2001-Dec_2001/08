journal artificial intelligence

submitted published

ecient methods qualitative spatial reasoning
renz dbai tuwien ac

jochen renz
institut f
ur informationssysteme technische universit
wien
favoritenstr wien austria

nebel informatik uni freiburg de

bernhard nebel
institut f
ur informatik albert ludwigs universit

flughafen freiburg germany

abstract

theoretical properties qualitative spatial reasoning rcc framework
analyzed extensively however empirical investigation made yet
experiments adaption used qualitative temporal
reasoning solve large rcc instances even phase transition region
provided one uses maximal tractable subsets rcc identified
us particular demonstrate orthogonal combination heuristic methods
successful solving almost apparently hard instances phase transition region
certain size reasonable time
introduction

representing qualitative spatial information reasoning information
important subproblem many applications natural language understanding document interpretation geographical information systems rcc calculus randell
cui cohn b well suited representing topological relationships spatial
regions inference full calculus however np hard grigni papadias papadimitriou renz nebel means unlikely large
instances solved reasonable time rule possibility
solve instances certain size reasonable time recently maximal tractable
subsets rcc identified renz nebel renz used
speed backtracking search general np complete reasoning reducing
search space considerably
address several questions emerge previous theoretical
rcc renz nebel renz size possible solve
instances reasonable time heuristic best really much ecient
use maximal tractable subsets solving instances np complete consistency
theoretical savings given smaller branching factors indicate
effect balanced forward checking power interleaved path consistency
computations case similar temporal pointisable vs ord horn
relations nebel possible combine different heuristics way
instances solved reasonable time heuristic alone
treat questions randomly generating instances solving
different heuristics particularly interested hardest randomly
c ai access foundation morgan kaufmann publishers rights reserved

firenz nebel

generated instances leads question phase transitions cheeseman kanefsky
taylor parameter randomly generating instances consistency
rcc phase transition behavior case
hardest instances mainly located phase transition region instances
contained phase transition region easily solvable order generate instances
harder higher probability generate two different kinds instances
one hand generated instances contain constraints rcc relations
hand generated instances contain constraints relations
contained maximal tractable subsets expect instances
harder average former instances
algorithmic techniques use solving randomly generated instances
borrowed similar work qualitative temporal reasoning nebel van beek
manchak ladkin reinefeld additionally make use fragments
rcc named hb q c permit polynomial time inferences renz nebel
renz backtracking used solve reasoning
full rcc decompose every disjunctive relation relations one
tractable subsets instead decomposing base relations reduces
average branching factor backtracking tree base relations
hb c q although theoretical savings
cannot observed experiments maximal tractable subsets instead
base relations leads significant performance improvements
structured follows section give brief sketch rcc
calculus used solving instances rcc section describe
procedure randomly generating instances different heuristics apply solving
instances measure quality heuristics section evaluate
different path consistency order ecient one used
forward checking backtracking search section observe phase transition
behavior randomly generated instances instances phasetransition region harder solve instances section report
outcome running different heuristics solving instances identify several
hard instances mainly located phase transition region section try
solve hard instances orthogonally combining different heuristics turns
effective leads ecient solution strategy finally section
evaluate strategy trying solve large instances
region connection calculus rcc

region connection calculus rcc first order language representation
reasoning topological relationships extended spatial regions randell et al
b spatial regions rcc non empty regular subsets topological space
internally connected e spatial region may consist different
disconnected pieces different relationships spatial regions defined
one dyadic relation connected relation c true topological closures
spatial regions share common point
b



b

programs available online appendix



fiefficient methods qualitative spatial reasoning






















x

x





dc x

x





x

tpp x tpp x

ec x

x

x



po x

x





x

ntpp x ntpp x

eq x

figure two dimensional examples eight base relations rcc
region connection calculus rcc constraint language formed eight
jointly exhaustive pairwise disjoint base relations dc ec po eq tpp ntpp tpp
ntpp definable rcc theory possible unions base relations
giving total number different relations base relations meaning
disconnected externally connected partial overlap equal tangential proper part
non tangential proper part converses examples relations shown
figure constraints written form
variables spatial
regions rcc relation write union base relations f g
union base relations universal relation written fg apart union
operations relations defined namely converse intersection
composition formal definitions operations
xry

x

r

r








x
x
x
x









x r



x r



xr





x r















xry

xs

xry

xs

yrx
z

xrz








zsy

composition base relations computed semantics relations
usually provided composition table randell cohn cui bennett
rcc composition table corresponds given extensional definition composition
universal region permitted bennett table compositions
disjunctive relations easily computed following sb denotes closure
set rcc relations composition intersection converse
finite set rcc constraints describing topological relationships different
regions represented matrix entry represents rcc
relation holding region region without loss generality feqg

assumed fundamental reasoning named rsat
framework deciding consistency set spatial formulas e whether
spatial configuration relations regions described
interesting reasoning reduced polynomial time golumbic
shamir unfortunately rsat np complete renz nebel e
unlikely polynomial deciding consistency however
shown nebel subsets rcc consistency
n

n



mji

n



j



mij



mij

mii

firenz nebel

written rsat decided polynomial time particular set
eight base relations b shown tractable follows bb consisting
relations tractable even larger tractable subset containing base relations
hb renz nebel contains rcc relations set
shown maximal respect tractability e rcc relation
added consistency becomes np complete renz made complete
analysis tractability rsat identifying maximal tractable subsets contain
base relations altogether three subsets hb q relations c relations
np set relations np completeness combined
set base relations contains following relations contained
one hb q c renz
np f j fpog fntppg ftppg
fntpp g ftpp g g
ffec ntpp eqg fdc ec ntpp eqg
fec ntpp eqg fdc ec ntpp eqgg
maximal tractable subsets contain following relations renz
hb rcc n np n f j feq ntppg ftppg
feq ntpp g ftpp g g
c rcc n np n f j fecg fpog
ftpp ntpp tpp ntpp eqg g
q rcc n np n f j feqg fpog
ftpp ntpp tpp ntpp g g




r

r

r

r

r



























r

r

r





r

r



r







r

r

r

r





r

r

r



r



relations q contained one hb c e hb c rcc n np
although hb smallest three maximal tractable subsets best decomposes
rcc relations decomposing rcc relation
sub relations one
maximal tractable subsets e one needs average hb relations
q relations c relations decomposing rcc relations renz
gives detailed enumeration relations three sets
r

r





si

sk

path consistency

area qualitative temporal reasoning allen interval calculus allen
path consistency montanari mackworth mackworth
freuder used approximate consistency realize forward checking
haralick elliot backtracking
path consistency checks consistency triples relations
eliminates relations impossible done iteratively performing following
operation

mij

mij

mik

mkj

strictly speaking applies systems regions require regularity



fiefficient methods qualitative spatial reasoning

path consistency
input set binary constraints variables x x x

n



represented matrix
path consistent set equivalent fail set
exist
n

output

n



f j

g
indicates th variable analogously

select delete path
revise


return fail

else f
j g
q

j k

k j



j k

n j k

k

j



j

k

q

p r q

q

p r q

mpq

q

q

p q

p q



n

p

q

function revise k j
input three labels k j indicating variables x x x
output true revised false otherwise
side effects revised operations


j

k

ij

ij

ji

constraints involving
xi

xk

xj

oldm


oldm return false


return true
mij

mij

mij

mj

mij

mik

mkj

mij



figure path consistency
triples regions
fixed point reached
pair
know inconsistent otherwise path consistent computing
done time see figure achieved queue triples
regions relations recomputed mackworth freuder pathconsistency imply consistency instance following set spatial constraints
path consistent consistent
j k

j



ij







n

lhh l
hhh
l hhhj l

x

dc tpp

z

tpp tpp
ec tpp
ec tpp

eq ntpp



ec ntpp

w

hand consistency imply path consistency since path consistency
form consistency logical sense form disjunctive non redundancy
nevertheless path consistency enforced consistent set constraints ap

firenz nebel

consistency
input set rcc constraints variables x x x

subset rcc contains base relations
decide sound complete decision
procedure
output true iff consistent
path consistency
contains empty relation return false
else choose unprocessed constraint

split

constraint split return decide
refinements

replace



consistency return true

n

xi rxj

r

sk

sl

xi rxj

l





sk

r

k

xi sl xj

figure backtracking deciding consistency
plying path consistency relations hb q c used however
path consistency sucient deciding consistency e path consistency
decides rsat hb rsat q rsat c renz nebel renz
backtracking

order solve instance rsat explore corresponding search space
sort backtracking experiments used backtracking
employed solving qualitative temporal reasoning nebel
proposed ladkin reinefeld see figure
necessary subset rcc consistency decided
sound complete preferably polynomial decision procedure decide contains
base relations thens relation rcc decomposed sub relations

size particular decomposition minimal number
sub relations used decompose backtracking successively
selects constraints backtracks sub relations constraints according
decomposition decides sub instances contain constraints
decide
optional procedure path consistency line used forward checking
restricts remaining search space nebel showed restriction
effect soundness completeness enforcing path consistency
sucient deciding rsat decide line necessary instead possible
return true
eciency backtracking depends several factors one
course size search space explored common way measuring
r

si

r



si

si

r



fiefficient methods qualitative spatial reasoning

size search space average branching factor search space e
average number branches node search space node recursive call

consistency average size search space computed


number constraints split variables
given backtracking described figure branching factor depends
average number relations split set relation split
less splits average better e expected eciency
backtracking depends split set branching factor another factor
search space explored backtracking figure offers two
possibilities applying heuristics one line next unprocessed constraint
chosen line next refinement chosen two
choices uence search space path search space
b

b

n

n

n

n

n

test instances heuristics measurement

previous work empirical evaluation reasoning rcc
benchmark known therefore randomly generated test instances
given number regions average label size average degree
constraint graph used two different sets relations generating test
instances set rcc relations set hard rcc relations np e
relations contained maximal tractable subsets hb c
q sets relations used two generate instances denoted
former model uses relations generate instances
latter relations np instances generated follows
constraint graph nodes average degree node generated
accomplished selecting possible edges
uniform distribution
edge th th node set universal
relation
otherwise non universal relation selected according parameter
average size relations selected edges accomplished selecting
one base relations uniform distribution remaining relations
one probability allowed relation e relation
np rcc relation assign relation
edge otherwise repeat process
reason generating instances relations np assume
instances dicult solve since every relation split
backtracking search even use maximal tractable subclass split set
generated instances average label size since case relations equally
distributed
n

n l

l



h n l

n



nd



n n

j



mij

mji

l

l

l



h n l

n l

l



method could assignment universal constraint selected link thereby changing
degree node however since probability getting universal relation low
ignore following



firenz nebel

way generating random instances similar way random csp instances finite domains usually generated gent macintyre prosser smith
walsh achlioptas et al found standard generating
random csp instances finite domains lead trivially awed instances
e instances become locally inconsistent without propagate constraints since
csp instances infinite domains achlioptas et al necessarily hold random instances therefore analyze following whether
instances trivially awed order obtain csp finite domain first transform constraint graph dual graph
edges
constraint graph corresponds node
dual graph moreover variables constraint graph corresponds
edges dual graph e dual graph contains edges
nodes dual graph node corresponds variable eight valued domain
fdc ec po tpp tpp ntpp ntpp eqg ternary constraints variables imposed composition table e composition rules


must hold connected
dual graph
triples nodes
n
connected triples dual graph


n n
overall number triples dual graph

unary constraints


domain variables given e nd triples dual graph
nodes restricted unary constraints therefore expected number
connected triples unary constraints given computed








expected number triples tends instances generated
according model probability unary constraints
assigned triple lead local inconsistency
possible assignments inconsistent since one locally inconsistent
triple makes whole instance inconsistent interested average degree
expected number locally inconsistent triples equal one model
occurs value
expected number locally inconsistent triples one
model none possible assignments triples leads
local inconsistency e triples randomly generated instances
model locally consistent analysis shows contrary achlioptas et
al found randomly generated csp instances finite domains model
model small suffer trivial local inconsistencies
n

n

n n



mij

n

n

n n













n n



mij

mik

mij mik mkj

j

n n



n

mkj



mij

mj



nd

mij

n
ct

e

n

nd

n



ec

n n

n



ec



n l









n
e


n l





e

















n

e





h n l

h n l

h n l

n l



similar csps finite domains restricting constraint type e g
equal constraints graph coloring used possible ensure cannot
trivially awed



fiefficient methods qualitative spatial reasoning

solve randomly generated instances backtracking described
previous section search space backtracking performed depends
split set e set sub relations allowed decompositions choosing
right split set uences search noticeably uences average branching factor
search space choose five different split sets three maximal tractable subsets
hb q c set base relations b closure set bb consists
relations sets following branching factors b b b hb
c q course worst case measure interleaved pathconsistency computations reduce branching factor considerably ladkin reinefeld

apart choice split set heuristics uence eciency search general best search strategy proceed constraint
constraining relation line figure least constraining choice
sub relation line figure investigated two different aspects choosing
next constraint processed nebel
static dynamic constraints processed according heuristic evaluation
constrainedness determined statically backtracking starts dynamically search
local global evaluation constrainedness local heuristic weight
criterion global heuristic criterion van beek manchak
gives us four possibilities combine five different split sets e
total number different heuristics evaluation constrainedness well
relations decomposed relations different split sets depends restrictiveness
relations heuristic criterion van beek manchak restrictiveness
relation measure relation restricts neighborhood instance
universal relation given constraint network restrict neighboring relations
composition relation universal relation universal
relation identity relation contrast restricts neighborhood lot every triple
variables one relation identity relation two relations must equal
therefore universal relation usually least restricting relation identity
relation usually restricting relation restrictiveness relations represented
weight range assigned every relation value
value least restricting relation discuss following section
detail restrictiveness weight relation determined
given weights assigned every relation compute decompositions estimate
constrainedness follows split set rcc relation compute
smallest decomposition sub relations e decomposition requires least number sub relations one possibility choose
decomposition least restricting sub relations line backtracking see figure least restricting sub relation decomposition processed
first local strategy constrainedness constraint determined size
decomposition different every split set weight choose
constraint smallest decomposition larger one




r

r



firenz nebel

one constraint one smallest weight reason choosing relation
smallest decomposition expected forward checking refines relations larger decomposition relations smaller decomposition reduces
backtracking effort global strategy constrainedness constraint

determined adding weights neighboring relations



weight idea behind strategy refining relation
restricted neighborhood inconsistency detected faster refining
relation less restricted neighborhood
order evaluate quality different heuristics measured run time used
solving instances well number visited nodes search space comparing
different approaches run time often reliable depends several
factors implementation used hardware current
load used machine makes sometimes reproducible reason
ran run time experiments machine sun ultra mb
main memory nevertheless suggest use run time mainly qualitatively
comparing different heuristics getting rough idea order magnitude
instances solved
contrast number visited nodes solving instance particular
heuristic every machine allows comparing path
search space taken single heuristics judge heuristic makes better
choices average however take account time needed make
choice single node computing local constrainedness constraint certainly
faster computing global constrainedness similarly computing constrainedness
statically faster computing dynamically furthermore larger instances
require time nodes smaller instances computing path consistency
computing constrainedness taking running time number visited nodes
together gives good indications quality heuristics
choice make evaluating measurements aggregate
measurements single instances total picture possibilities use
average different percentiles median e percentile
percentile value
obtained sorting measurements increasing
order picking measurement element e values less
value suppose instances low value e g running time
instances large value average might larger values
almost instances case median better indication distribution
values case percentile instance gives good indication
value hardest among normal instances chosen use average
value measurements well distributed use percentile
exceptional values distribution measurements
xry



r



xs z

zt

r







empirical evaluation path consistency

since eciency backtracking depends eciency underlying
path consistency first compare different implementations pathconsistency previous empirical investigations van beek manchak


fiefficient methods qualitative spatial reasoning

reasoning allen interval relations allen different methods computing
composition two relations evaluated mainly full composition
table interval relations contains entries large
time stored main memory setting simply use composition
table specifies compositions rcc relations table
consuming approximately kb main memory means composition
two arbitrary relations done simple table lookup
van beek manchak studied effect weighting relations
queue according restrictiveness process restricting relation first
restrictiveness measured base relation successively composing base
relation every possible label summing cardinalities e number base
relations contained composition suitably scaling
reason restricting relation restricts relations
average therefore decreases probability processed
restrictiveness complex relation approximated summing restrictiveness
involved base relations van beek manchak found method
weighting triples queue much ecient randomly picking arbitrary
triple relatively small number rcc relations computed exact
restrictiveness composing relation every relation summing
cardinalities resulting compositions scaled weights
restricting relation least restricting relations
gives us three different implementations path consistency one
entries queue weighted one approximated restrictiveness
done van beek manchak one exact restrictiveness order compare
implementations randomly generated instances regions
value average degree ranging stepping generated
different instances figure displays average cpu time different methods
applying path consistency generated instances
seen positive effect weighted queue much greater
temporal faster ordinary queue without
weights compared faster van beek manchak determining
weights every relation exact restrictiveness much advantage
approximating restrictiveness van beek manchak
however experiments used exact weights method
determining restrictiveness amounts one table lookup
mentioned previous section one way measuring quality heuristics
count number visited nodes backtrack search backtracking
path consistency enforced every visited node note adequate
multiply average running time enforcing path consistency instance
particular size number visited nodes order obtain approximation
required running time instance average running time enforcing pathconsistency given figure holds possible paths entered
queue beginning computation see line figure paths
weighted versions select path k j queue q line figure
according weights different paths q computed specified



firenz nebel

average cpu time pca different queue methods n



exact weights
approx weights
weights

cpu time sec
















nodes









figure comparing performance path consistency different
methods weighting queue instances data point






checked path consistency computation
backtracking search different however paths involving currently
changed constraint entered queue since paths might changes
constraint graph much faster full computation path consistency
done beginning backtrack search
phase transition rcc

randomly generating instances usually dependent parameter determines solubility instances one parameter range instances
underconstrained therefore soluble high probability another range
overconstrained soluble low probability
ranges phase transition region probability solubility changes abruptly
high low values cheeseman et al order study quality
different heuristics randomly generated instances np complete
important aware phase transition behavior
instances contained phase transition region often
easily solvable heuristics thus useful
comparing quality conversely hard instances better suited comparing
quality heuristics usually found phase transition region
section identify phase transition region randomly generated instances
rsat instances rcc relations instances
relations np similarly empirical analysis qualitative temporal reasoning
nebel turns phase transition depends strongly
average degree nodes constraint graph relations allowed phased



fiefficient methods qualitative spatial reasoning

probability satisfiability n

median cpu time n
cpu time

probability

















average degree




nodes








average degree






nodes



figure probability satisfiability median cpu time
hb static global heuristic instances per data point

n




transition around depending instance size see figure
theoretical analysis occurrence trivial aws see section
expected larger instance sizes phase transition behavior overlaid
mainly determined expected number locally inconsistent triples depends
average degree thus although seems phase transition shifts towards
larger values instance size increases phase transition asymptotically
theoretical value see section instances pathconsistent solved fast one application path consistency
without need backtracking looking median cpu times given
figure one notices sharp decline median cpu times phase
transition indicates values average degree higher
phase transition occurs least instances path consistent
hard relations e relations np phase transition appears
higher values namely see figure median
runtime shows instances much harder phase transition former
case previous case even strongly seems phase transition
shifts towards larger values instance size increases phasetransition region narrows
order evaluate quality path consistency method approximation
consistency counted number instances inconsistent path consistent
see figure e instances approximation path consistency consistency wrong first one notes instances close
phase transition region general case e constraints rcc relations
employed low percentage instances path consistent inconsistent
therefore figure looks erratic data points would required order
obtain smooth curve however important observations made
figure namely path consistency gives excellent approximation consistency even
instances large size except instances phase transition region
almost instances path consistent consistent picture changes












n











firenz nebel

probability satisfiability h n

median cpu time h n

probability

cpu time
















average degree










nodes




average degree






nodes



figure probability satisfiability median cpu time
hb static global heuristic instances per data point

h n

percentage points incorrect pca answers n




percentage points incorrect pca answers h n

pc failures
pc failures

































average degree


nodes










average degree




nodes



figure percentage points incorrect answers path consistency

n



h n



looking case almost instances phase transition
region many instances mostly insoluble region path consistent though
consistent
following evaluation different heuristics randomly generate instances average degree case
case covers large area around
phase transition expect instances phase transition region
particularly hard makes interesting comparing quality
different heuristics
h n









h n



n





h n



empirical evaluation heuristics

section compare different heuristics running randomly
generated instances instances ran different heuristics
n





fiefficient methods qualitative spatial reasoning

number hard instances n

number hard instances h n

hard instances

hard instances
































average degree




nodes








average degree




nodes



figure number instances visited nodes heuristic

n



h n



static dynamic local global combined five split sets b bb hb c q
randomly generated instances size instances
restricted instances regions larger
ones appeared dicult
first experiments found instances solved fast
less visited nodes search space one maximal tractable
subsets splitting however instances turned extremely hard could
solved within limit million visited nodes hours cpu
time therefore ran programs maximal number visited nodes
stored instances least one different heuristics used
visited nodes experiments see next section call instances
hard instances distribution hard instances shown figure turned
heuristics b split set heuristics dynamic
global evaluation constrainedness many instances hard
combinations heuristics therefore include figure hard instances
b dynamic global heuristic hard instances heuristics
b dynamic global heuristic
b split set b
figure shows almost hard instances phase transition region
instances per data point hard
almost instances phase transition hard altogether hard instances
total number generated instances hard
instances total number generated instances table
shows number hard instances heuristic except excluded
mentioned heuristics hb split set solve instances
heuristics split sets c q split set seem
improvement b b among different ways computing constrainedness static
global appears effective combination one maximal
tractable subsets split set split sets dynamic local seems


n

h n







n



n

n



h n

n



n





h n

h n







firenz nebel

heuristics

hb sta loc
hb sta glo
hb dyn loc
hb dyn glo
c sta loc
c sta glo
c dyn loc
c dyn glo
q sta loc
q sta glo
q dyn loc
q dyn glo
bb sta loc
bb sta glo
bb dyn loc
bb dyn glo
b sta loc
b sta glo
b dyn loc
b dyn glo
total



n

















































h n

h
























table number hard instances heuristic
effective combination combining dynamic global cases worst choice
respect number solved instances
figure compare percentiles different heuristics
give average run times since ran heuristics
visited nodes reduces real average run time values data point
average values took average different degrees
order cover whole phase transition region instances
size instances size different combinations
computing constrainedness ordering run times different split
sets b bb c hb q run times static local static global dynamic local
computing constrainedness almost combined split set
longer split sets dynamic global times longer
bb split set times longer split sets
percentile run times times longer percentile run
times thus even harder among normal instances solved easily e apart
hard instances instances solved eciently within size range
analyzed erratic behavior median curves aggregation
effect observed figure namely median elements
phase transition inconsistent easily solvable
n









n







n





fiefficient methods qualitative spatial reasoning

median cpu time static local n

percentile cpu time static local n




b split
b split
c split
h split
q split














nodes













median cpu time static global n









nodes









percentile cpu time static global n




b split
b split
c split
h split
q split



b split
b split
c split
h split
q split


cpu time sec


cpu time sec




























nodes











median cpu time dynamic local n









nodes









percentile cpu time dynamic local n




b split
b split
c split
h split
q split



b split
b split
c split
h split
q split


cpu time sec


cpu time sec





























nodes











median cpu time dynamic global n









nodes









percentile cpu time dynamic global n




b split
b split
c split
h split
q split



b split
b split
c split
h split
q split


cpu time sec


cpu time sec

b split
b split
c split
h split
q split


cpu time sec

cpu time sec

























nodes



















nodes









figure percentile cpu time different heuristics solving
instances per data point
n













firenz nebel

runtime studies noticed many hard instances
see figure almost instances phase transition region
hard see last column table table shows number hard instances
varies lot different heuristics therefore possible compare percentile
running times different heuristics see last column
table instance percentile element c dynamic global
heuristic element element element element
hb dynamic local heuristic sorted elements respectively
reason size see figure
took average different degrees order cover whole
phase transition region order run times different combinations
computing constrainedness b bb c q hb hb cases fastest
instances run times dynamic global much longer
combinations percentile run times static global combination
hb q dynamic local combination faster
combinations although median cpu times
percentile cpu times much longer already shown figure
evidence hard instances phase transition
region
h n

n



n

n

n



n





n







n



n

h n



orthogonal combination heuristics

previous section studied quality different heuristics solving randomly
generated rsat instances found several instances mainly located
phase transition region could solved heuristics within limit
visited nodes search space since different heuristics different search space
depending split set use different path search space determined
different possibilities computing constrainedness possible instances
hard heuristics easily solvable heuristics nebel observed
running different heuristics parallel solve instances particular hard set
temporal reasoning instances proposed van beek manchak single
heuristic alone solve altogether number visited nodes
heuristic alone open question nebel investigation nebel whether
case hard instances phase transition region
section evaluate power orthogonally combining different heuristics
solving rsat instances e running different heuristics instance parallel
one heuristics solves instance different ways simulating
parallel processing single processor machine one use time slicing
different heuristics another run heuristics fixed random order
certain number nodes search space visited unsuccessful try next
heuristic cf huberman lukose hogg possibility chosen
parameters e g order heuristics run number visited
nodes spent heuristic determines eciency single processor
simulation orthogonal combination order best parameters ran
heuristics visited nodes heuristic set hard instances


fiefficient methods qualitative spatial reasoning

median cpu time static local h n

percentile cpu time static local h n




b split
c split
b split
q split
h split

cpu time sec




b split
c split
b split
q split
h split


cpu time sec

























nodes









median cpu time static global h n




nodes







percentile cpu time static global h n




b split
c split
b split
q split
h split




b split
c split
b split
q split
h split


cpu time sec


cpu time sec

























nodes









median cpu time dynamic local h n




nodes







percentile cpu time dynamic local h n




b split
c split
b split
q split
h split




b split
c split
b split
q split
h split


cpu time sec


cpu time sec

























nodes









median cpu time dynamic global h n




nodes







percentile cpu time dynamic global h n




b split
c split
b split
q split
h split




b split
c split
b split
q split
h split


cpu time sec


cpu time sec

























nodes














nodes







figure percentile cpu time different heuristics solving
instances per data point
h n













firenz nebel

n
heuristics solved instances response


hb sta loc
hb sta glo


hb dyn loc


hb dyn glo


c sta loc


c sta glo


c dyn loc


c dyn glo


q sta loc


q sta glo


q dyn loc


q dyn glo




bb sta loc
bb sta glo


bb dyn loc


bb dyn glo


b sta loc


b sta glo


b dyn loc


b dyn glo


combined


h n
solved instances response










































table percentage solved hard instances heuristic percentage first response orthogonally running heuristics note sometimes different
heuristics equally fast therefore sum

identified previous section instances least one heuristic required
visited nodes compared behavior since ran heuristics
instances already experiments previous section evaluate
outcomes led surprising instances namely
hard instances except single one solved least one heuristics
less visited nodes table list percentage hard instances
could solved different heuristics percentage first response
running heuristics parallel e heuristic required smallest
number visited nodes solving instance turns heuristics hb
split set solve instances heuristics
often fastest finding solution although heuristics two
maximal tractable subsets q c split set solve significantly instances
heuristics b b much faster finding solution despite solving
least number instances heuristics b split set cases
fastest producing solution
n





fiefficient methods qualitative spatial reasoning

first response solving hard instances n

first response solving hard instances h n



number solved instances

number solved instances

inconsistent
consistent






inconsistent
consistent
















minimal number visited nodes








minimal number visited nodes



figure fastest solution hard instances running heuristics parallel
comparing minimal number visited nodes heuristics
hard instances found five inconsistent required
visited nodes particularly remarkable instances
phase transition region np hard e instances usually
considered dicult ones note pathconsistent instances inconsistent much higher usual cf figure
interestingly inconsistent instances solved faster consistent
instances point noted combining heuristics orthogonally
similar randomized search techniques restarts selman levesque mitchell
however contrast randomized search method determine whether
instance inconsistent figure chart number hard instances solved
smallest number visited nodes respect solubility due low number
hard instances figure left looks bit ugly one least
approximate behavior curves comparing second figure
right curve see oscillating behavior
inconsistent instances instances solved odd even number
visited nodes might due sizes instances generated instances
even number nodes dicult instance solved
b static global heuristic visited nodes
inconsistent b
heuristics one maximal tractable subsets split set failed solve even
allowed visit nodes search space
examination set hard instances
instances could solved different heuristics visited
nodes distribution shown figure similar hard instances
heuristics hb split set successful ones
solving hard instances shown table solved
hard instances heuristics produced fastest response
hard instances significant difference c q bb
split set neither number solved instances percentage first
response previous case computing constrainedness static global
dynamic local heuristics resulted successful paths search space
n



h n



n



h n

n





h n









firenz nebel

first response solving hard instances h n
number hard instances h n orthogonal combination
inconsistent
consistent

hard instances














average degree


nodes

number solved instances


















number visited nodes




b
figure hard instances orthogonal combination heuristic
shows distribution b shows fastest solution
visited nodes per heuristic
h n



instances solved within visited nodes combinations
average produced faster solutions combinations
observations made charting fastest solutions
hard instances see figure solved
instances inconsistent solved faster consistent
instances hard instances solved visited nodes
solved visited nodes since hb dynamic local heuristic
alone solves instances seems dicult combine different heuristics
way hard instances solved visited
nodes altogether however orthogonally combining two best performing heuristics
hb dynamic local hb static global allowing maximal number
visitable nodes solve hard instances
tried solve hard instances solvable
orthogonal combination heuristics visited nodes maximal
number visited nodes instances still solvable
solved instances inconsistent fastest response solved instances
charted figure b successful heuristics giving fastest response
hb dynamic local hb static global three heuristics
static global computation constrainedness combined q c bb split
set gave fastest response solved instances bb strategy
far best among three
n

h n





h n







combining heuristics solving large instances

previous section found combining different heuristics orthogonally solve
instances amount visited nodes heuristic alone solve
section use order identify size randomly generated instances


fiefficient methods qualitative spatial reasoning

almost especially phase transition region still
solved acceptable time since many instances already dicult
size see figure restrict analysis instances
study randomly generated instances size nodes
instances large size allowing maximal number visited nodes
search space much obtaining acceptable runtime visited nodes
instances size corresponds runtime seconds sun ultra
larger instances gets much slower therefore restrict maximal number
visited nodes order achieve acceptable runtime given multi processor machine
different heuristics run orthogonally different processors maximal
number visited nodes orthogonal combination different heuristics
simulated single processor machine maximal number nodes divided
number used heuristics obtain available number visitable nodes
heuristic thus different heuristics use less visitable nodes available
heuristic therefore order achieve best performance
combination heuristics solves instances within given number visitable
nodes chosen heuristics solve many instances alone
complement well e instances cannot solved one heuristic
solvable heuristic
started finding optimal combination heuristics set hard
instances empirical evaluation given section know
many visited nodes heuristic needs order solve hard instances
therefore computed number solved instances possible combinations
heuristics increasing maximal number visitable nodes heuristics
together since tried combination solves instances
computed quite fast given table
good performance obtained maximal number visited nodes
case four heuristics involved e visitable nodes spent four
heuristics since combination heuristics hb static global hb dynamic local
b static local best visitable nodes choose
c dynamic local b
combination analysis choose order processed
b static local according
hb dynamic local hb static global c dynamic local b
first response behavior given table note although two heuristics
b static local particularly good performance
c dynamic local b
running alone see table seem best complement two heuristics
next maximal number visitable nodes spend
heuristics ran best performing heuristic hb dynamic local instances
phase transition region varying sizes turned almost consistent
instances number visited nodes required solving slightly less twice
size instances inconsistent instances path consistent
thus solvable one visited node therefore ran four heuristics
following allowing visited nodes size instance e together
allow visitable nodes randomly generated test instances according
model size regions size regions
step regions instances size average degree ranging
h n



n

n

n

n

n



n

n

n

n



n

n





firenz nebel

max nodes solved instances

























combination heuristics
hb l
hb g
hb g hb l
hb g c l
hb g hb l c l
b
hb g hb l c l b l
b
b
b
h g h l c l b l
b
hb g hb l c l b l
b
b
b
h g h l c l b l
b b g
b
hb g hb l c l b l
b b g
b
hb g hb l b l
b
b
b
h g h l b l

table best performance combining different heuristics solving solvable hard
instances fixed maximal number visited nodes
n



probability satisfiability n

probability

average number visited nodes n

visited nodes



















average degree







nodes






average degree







nodes



figure probability satisfiability instances per data point
average number visited nodes path consistent instances
orthogonal combination four selected heuristics
n



step total number instances since solving
large instances backtracking requires lot memory solved instances
sun ultra gb main memory
generated instances display phase transition behavior continues one
given figure phase transition ranges
see figure apart instances instances generated solvable orthogonal combination four heuristics hb static global
b static local spending less n visited nodes
hb dynamic local c dynamic local b










n





n





fiefficient methods qualitative spatial reasoning

percentile cpu time orthogonal combination n

percentile cpu time orthogonal combination n
cpu time

cpu time














average degree









nodes








average degree







nodes



figure percentile cpu time orthogonal combination four different heuristics solving large randomly generated instances
n



figure give average number visited nodes path consistent
instances seen test instances average number visited nodes
linear size instances percentile cpu time instances
phase transition size regions seconds percentile cpu
time seconds size regions percentile cpu time
less minute see figure
test instances already solved hb static global heuristic
instances hb dynamic local heuristic required instances
c dynamic local heuristic produced solution none instances
b static local heuristic
solved one three heuristics solved b
tried solve instances heuristics maximal number
visited nodes best performing among heuristics c dynamic global
heuristic solved instances followed c static global heuristic
q dynamic global heuristic instances solved heuristic
within maximal number visited nodes
n

n

n

n

discussion

empirically studied behavior solving randomly generated rsat instances
different backtracking heuristics make use maximal tractable subsets
identified previous work generated instances according two different
general model allows rcc relations used hard
model allows relations contained maximal tractable
subsets theoretical analysis two showed model model
small average degree nodes constraint graph suffer trivial
local inconsistencies case similar generation procedures csps finite
domains achlioptas et al turned randomly generated instances
phase transition behavior depends strongly average
degree instances instances outside phase transition region


h

h





firenz nebel

solved eciently heuristics instances phase transition region
extremely hard instances general model path consistent instances
consistent conversely path consistency bad approximation consistency
instances hard model instances much harder solve instances
general model
comparing different heuristics found heuristics one
maximal tractable subsets split set much faster deciding consistency
rsat instances theoretical advantage given reduced average branching factor
resulting exponentially smaller size search space indicates
path consistency forward checking method considerably reduces search space
cases nevertheless one maximal tractable subsets split set
particular hb still leads much faster solution solves instances reasonable
time heuristics although two maximal tractable subsets q c
contain relations hb average branching factor lower e
hb one decompose relations two
sets relations respectively hb splits relations better
two sets relations decomposed two hb sub relations many
relations must decomposed three c sub relations three q sub relations
explains superior performance heuristics involving hb decomposition
among instances generated stored could solved
heuristics within maximum number visited nodes search space order
different heuristics perform hard instances found almost
hard instances located phase transition region many
hard instances hard model general model orthogonally combined
heuristics ran hard instances turned successful apart
one instance hard instances general model could solved
low number visited nodes hard instances hard model much
dicult many could solved heuristics nevertheless
many instances solved orthogonally combining heuristics
heuristic alone solved low number visited nodes
observations orthogonally combining different heuristics tried
identify combination heuristics successful eciently solving many
instances used combination solving large instances turned
best combination involves heuristics use maximal tractable subsets decomposition combination able solve almost randomly generated
instances phase transition region general model size regions
eciently seems impossible considering enormous size
search space average instances size hb
split set
despite np hardness able solve almost randomly generated rsat instances general model eciently neither due
low number different rcc relations instances generated according hard model
hard phase transition region generation procedure random
instances lead trivially awed instances asymptotically mainly due
maximal tractable subsets cover large fraction rcc lead
n

n



fiefficient methods qualitative spatial reasoning

extremely low branching factors since different maximal tractable subsets
allow choosing many different backtracking heuristics increases
eciency instances solved easily one heuristic instances
heuristics heuristics involving maximal tractable subclasses showed best behavior
instances solved faster tractable subsets used full classification tractable subsets gives possibility generating hard instances high
probability many randomly generated instances phase transition region
hard relations contained tractable subsets
consist regions next step developing ecient reasoning
methods rcc methods successful solving hard
instances hard model
n

empirical evaluation reasoning rcc suggest analyzing
computational properties reasoning identifying tractable subclasses
excellent way achieving ecient reasoning mechanisms particular
maximal tractable subclasses used develop ecient methods solving
full since average branching factor lowest refinement
method developed renz tractable subclasses set relations forming
relation algebra identified almost automatically method makes easy
develop ecient indication empirical evaluation
much effective even especially hard instances phase transition
region orthogonally combine different heuristics try get final epsilon
single heuristic answers question raised nebel whether orthogonal
combination heuristics useful phase transition region experiments
lead much better even simulating orthogonal combination different
heuristics single processor machine spending altogether resources
one heuristic alone contrast method time slicing different
heuristics started heuristic previous heuristic failed certain
number visited nodes search space order ran heuristics
depended performance well complemented
successful heuristics used first similar portfolios proposed
huberman et al heuristics perform better combination
successful one matter empirical evaluation depends particular
heuristics depending maximal tractable subclasses however lead
best performance
csps finite domains many theoretical localizing
phase transition behavior predicting hard instances located contrast basically theoretical csps infinite domains
used spatial temporal reasoning initial theoretical analysis shows theoretical csps finite domains necessarily extend csps infinite
domains would interesting develop general theory csps
infinite domains possibly similar williams hogg deep structure williams
hogg gent et al kappa theory gent macintyre prosser walsh


firenz nebel
acknowledgments

would thank ronny fehling assistance developing programs malte
helmert proof reading three anonymous reviewers
helpful comments
supported dfg part project fast qual space
part dfg special effort spatial cognition first author
partially supported marie curie fellowship european community programme
improving human potential contract number hpmf ct preliminary version appeared proceedings th european conference
artificial intelligence renz nebel
references

achlioptas kirousis l kranakis e krizanc molloy stamatiou
random constraint satisfaction accurate picture rd conference
principles practice constraint programming cp vol lncs pp
springer verlag
allen j f maintaining knowledge temporal intervals communications
acm
bennett b spatial reasoning propositional logic doyle j sandewall
e torasso p eds principles knowledge representation reasoning
proceedings th international conference pp bonn germany morgan
kaufmann
bennett b logical representations automated reasoning spatial relationships ph thesis school computer studies university leeds
cheeseman p kanefsky b taylor w really hard
proceedings th international joint conference artificial intelligence
pp sydney australia morgan kaufmann
gent macintyre e prosser p smith b walsh random constraint
satisfaction flaws structure constraints
gent macintyre e prosser p walsh constrainedness search
proceedings th national conference ai aaai pp
golumbic c shamir r complexity reasoning time
graph theoretic journal association computing machinery

grigni papadias papadimitriou c topological inference proceedings
th international joint conference artificial intelligence pp
montreal canada


fiefficient methods qualitative spatial reasoning

haralick r elliot g l increasing tree search eciency constraint
satisfaction artificial intelligence
huberman b lukose r hogg economics hard computational science
ladkin p b reinefeld effective solution qualitative interval constraint
artificial intelligence
ladkin p b reinefeld fast algebraic methods interval constraint annals mathematics artificial intelligence
mackworth k consistency networks relations artificial intelligence

mackworth k freuder e c complexity polynomial network
consistency constraint satisfaction artificial intelligence

montanari u networks constraints fundamental properties applications
picture processing information science
nebel b computational properties qualitative spatial reasoning first
wachsmuth rollinger c r brauer w eds ki advances artificial
intelligence vol lecture notes artificial intelligence pp bielefeld
germany springer verlag
nebel b solving hard qualitative temporal reasoning evaluating
eciency ord horn class constraints
randell cohn g cui z computing transitivity tables challenge
automated theorem provers proceedings th cade springer verlag
randell cui z cohn g b spatial logic regions
connection nebel b swartout w rich c eds principles knowledge
representation reasoning proceedings rd international conference pp
cambridge morgan kaufmann
renz j maximal tractable fragments region connection calculus complete analysis proceedings th international joint conference artificial
intelligence pp stockholm sweden
renz j qualitative spatial reasoning topological information ph thesis
institut fur informatik albert ludwigs universitat freiburg
renz j nebel b ecient methods qualitative spatial reasoning proceedings th european conference artificial intelligence pp amsterdam netherlands wiley


firenz nebel

renz j nebel b complexity qualitative spatial reasoning maximal
tractable fragment region connection calculus artificial intelligence
selman b levesque h j mitchell method solving hard satisfiability proceedings th national conference american
association artificial intelligence pp san jose ca mit press
van beek p manchak w design experimental analysis
temporal reasoning journal artificial intelligence
williams c p hogg exploiting deep structure constraint
artificial intelligence




