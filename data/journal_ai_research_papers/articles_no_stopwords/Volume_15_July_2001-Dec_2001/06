journal artificial intelligence

submitted published

rewriting
jose luis ambite
craig knoblock

ambite isi edu
knoblock isi edu

information sciences institute department computer science
university southern california
admiralty way marina del rey ca usa

abstract
domain independent hard combinatorial taking account
plan quality makes task even difficult article introduces rewriting pbr paradigm efficient high quality domain independent pbr
exploits declarative plan rewriting rules efficient local search techniques transform
easy generate possibly suboptimal initial plan high quality plan addition addressing issues efficiency plan quality framework offers
anytime implemented planner applied
several existing domains experimental pbr provides
significant savings effort generating high quality plans

introduction

process generating network actions plan achieves desired
goal initial state world many practical importance
cast instead crafting individual planner solve specific
long line focused constructing domain independent
domain independent accepts input descriptions
initial state goal particular instance declarative domain
specification set actions change properties state domainindependent makes development efficient allows
software domain reuse facilitates principled extension capabilities
planner unfortunately domain independent
computationally hard bylander erol nau subrahmanian backstrom
nebel given complexity limitations previous work domainindependent focused finding solution plan without careful consideration
plan quality usually simple cost functions length plan
used however many practical plan quality crucial
present paradigm rewriting pbr addresses
efficiency plan quality maintaining benefits domain independence
framework fully implemented present empirical several
domains
c

ai access foundation morgan kaufmann publishers rights reserved

fiambite knoblock

solution
two observations guided present work first one two sources
complexity
satisfiability difficulty finding solution regardless
quality solution
optimization difficulty finding optimal solution given cost metric
given domain facets may contribute differently complexity
particular many domains satisfiability
relatively easy complexity dominated optimization example
may many plans would solve finding one efficient
practice cost solution varies greatly thus finding optimal one
computationally hard refer domains optimization domains
optimization domains great practical interest query optimization manufacturing
process
second observation great deal structure plans
type graph strong semantics determined general properties
particular domain specification structure
exploited improve efficiency process
prompted previous observations developed novel efficient
optimization domains rewriting pbr framework works
two phases
generate initial solution plan recall optimization domains efficient
however quality initial plan may far optimal
iteratively rewrite current solution plan improving quality set declarative plan rewriting rules acceptable solution found resource
limit reached
motivation consider optimization domains distributed query processing
manufacturing process distributed query processing yu chang involves generating plan efficiently computes user query data resides
different nodes network query plan composed data retrieval actions diverse
information sources operations data relational algebra
join selection etc systems use general purpose planner solve
knoblock domain easy construct initial plan parse
query suffices transform gradient descent search reduce cost
plan transformations exploit commutative associative properties relational algebra operators facts group operators executed
together remote information source generally efficient figure
interestingly one widely studied domains blocks world property
domains analyzed section graphical examples rewriting process appear figure
query figure manufacturing process reader may want consult
figures even details explained point



fiplanning rewriting

shows sample transformations simple join swap transforms two join trees according commutative associative properties join operator remote join eval
executes join two subqueries remote source source able
simple join swap
retrieve q source retrieve q source retrieve q source
retrieve q source retrieve q source retrieve q source
remote join eval
retrieve q source retrieve q source capability source join
retrieve q q source
figure transformations query
manufacturing economical plan machining operations
implement desired features design feature nau gupta
regli possible enumerate actions involved building piece
analyzing cad model difficult ordering operations
setups optimize machining cost however similar query possible
incrementally transform possibly inefficient initial plan often order actions
affect design goal quality plan thus many actions commute
important minimize number setups fixing piece machine
rather time consuming operation interestingly grouping machining operations
setup analogous evaluating subquery remote information source
suggested examples many combine characteristics traditional satisfiability quality optimization domains
often exist natural transformations may used efficiently obtain high quality plans
iterative rewriting rewriting provides domain independent framework
allows plan transformations conveniently specified declarative plan rewriting
rules facilitates exploration efficient local search techniques
advantages rewriting
several advantages style pbr introduces first pbr
declarative domain independent framework facilitates specification
domains evolution principled extension planner capabilities moreover declarative rewriting rule language provides natural convenient
mechanism specify complex plan transformations
second pbr accepts sophisticated quality measures operates complete
plans previous approaches addressed quality issues
simple quality measures number steps plan partial
plans available process general partial plan cannot offer
enough information evaluate complex cost metric guide search
effectively


fiambite knoblock

third pbr use local search methods remarkably successful scaling
large aarts lenstra local search techniques high quality
plans efficiently generated fourth search occurs space solution plans
generally much smaller space partial plans explored planners
refinement search
fifth framework yields anytime dean boddy
planner solution offer point computation modulo initial
plan generation needs fast clear advantage traditional
approaches must run completion producing solution thus system
allows possibility trading effort plan quality example query
quality plan execution time may make sense keep
cost current plan small enough even cheaper one could
found discussion concrete examples advantages given throughout
following sections
contributions
main contribution development rewriting novel
domain independent paradigm efficient high quality first define language declarative plan rewriting rules present domain independent
plan rewriting rewriting rules provide natural convenient mechanism specify complex plan transformations techniques plan rewriting generalize traditional
graph rewriting graph rewriting rules need specify rule consequent complete
embedding replacement subplan introduce novel class partially specified
plan rewriting rules relax restriction taking advantage semantics
embedding automatically computed single partially specified rule
concisely represent great number fully specified rules rules easier
write understand fully specified counterparts second adapt local
search techniques gradient descent efficiently explore space plan rewritings optimize plan quality finally demonstrate empirically usefulness
pbr several domains
outline
remainder structured follows section provides background
rewriting local search fields upon pbr builds section
presents basic framework rewriting domain independent
local search section describes detail plan rewriting declarative rewriting rule
language section describes several application domains shows experimental
comparing pbr planners section reviews related work finally section
summarizes contributions discusses future work
although space rewritings explored complete search methods application domains
analyzed search space large experience suggests local search
appropriate however extent complete search methods useful rewriting
framework remains open issue focus local search



fiplanning rewriting

preliminaries rewriting local search
framework rewriting arises confluence several areas namely artificial intelligence graph rewriting local search
techniques section give background areas explain
relate pbr
ai
assume reader familiar classical ai section
highlight main concepts relate pbr framework weld
russell norvig provide excellent introductions ai
pbr follows classical ai representation actions transform state
state set ground propositions understood conjunctive formula pbr
ai planners follows closed world assumption proposition explicitly
mentioned state assumed false similarly negation failure semantics
logic programming propositions state modified asserted negated
actions domain actions domain specified operator schemas
operator schema consists two logical formulas precondition defines
conditions operator may applied postcondition specifies
changes state effected operator propositions mentioned
postcondition assumed change application operator type
representation initially introduced strips system fikes nilsson
language operators pbr sage knoblock b
extension ucpop penberthy weld operator description
language pbr accepts arbitrary function free first order formulas preconditions
operators conditional universally quantified effects disjunctive effects
addition operators specify resources use sage pbr address unit
non consumable resources resources fully acquired operator
completion action released reused
figure shows sample operator schema specification simple blocks world
domain representation accepted pbr domain two actions stack
puts one block top another unstack places block table
state described two predicates x denotes block x top
another block table clear x denotes x block
block top
example complex operator process manufacturing domain shown
figure operator describes behavior punch machine used
make holes parts punch operation requires available clamp
machine orientation width hole appropriate punch
executing operation part desired hole
illustrate basic concepts use examples simple blocks world domain
reader real world application techniques query section
stack x z read stack block x top block z
unstack x read lift block x top block put table
convention variables preceded question mark symbol x



fiambite knoblock

define operator stack
parameters x z
precondition
x z clear x clear
neq z neq x z neq x
neq x table neq table
effect x x z
clear z clear

define operator unstack
parameters x
precondition
x clear x neq x
neq x table neq table
effect x table clear
x

figure blocks world operators
define operator punch
parameters x width orientation
resources machine punch object x
precondition object x
punchable x width orientation
clamp punch
effect forall surf neq surf rough
surface condition x surf
surface condition x rough
hole x width orientation

figure manufacturing operator
rough surface note specification resources slot declaring machine punch
resource enforces operator use punch concurrently similarly
declaring part object x resource means one operation time
performed object examples operator specifications appear
figures
plan pbr represented graph spirit partial order causal link planners pocl ucpop penberthy weld nodes plan steps
instantiated domain operators edges specify temporal ordering relation among
steps imposed causal links ordering constraints causal link record
proposition established plan record contains proposition sometimes
called condition producer step consumer step producer step
plan asserts proposition proposition one effects consumer
step needs proposition proposition one preconditions
causality producer must precede consumer
ordering constraints needed ensure plan consistent arise
resolving operator threats resource conflicts operator threat occurs
step negates condition causal link ordered producer
consumer steps causal link prevent situation makes plan inconsistent pocl planners order threatening step producer demotion
consumer promotion posting appropriate ordering constraints
operator uses idiom combining universal quantification negated conditional effects enforce
attribute surface condition part single valued



fiplanning rewriting

unit non consumable resources considered steps requiring resource
sequentially ordered chain ordering constraints appear plan
example plan blocks world graph representation given
figure plan transforms initial state consisting two towers c
table b table final state consisting one tower b b c
c table initial state represented step preconditions
propositions initial state postconditions similarly goal state
represented step goal postconditions goal formula precondition
plan achieves goal two unstack steps disassemble two initial towers
three stack steps build desired tower causal links shown
solid arrows ordering constraints dashed arrows additional effects step
used causal links sometimes called side effects shown step
pointed thin dashed arrows negated propositions preceded note need
ordering link steps stack b c table stack b table
step could ordered concurrently step would negate precondition
clear b step making plan inconsistent similar situation occurs steps
another ordering link introduced

clear b

causal link
ordering constraint
side effect

table
c

clear

stack b table

unstack c
c table

c
clear c
table

table
clear b

clear c


clear b

b table
b
clear c
stack b c table
b c
c
stack c table
goal
clear
c table
clear


b

b

b table
unstack b
b
clear b

c

b

c







clear c
initial state

goal state

figure sample plan blocks world domain

rewriting
plan rewriting pbr related term graph rewriting term rewriting originated
context equational theories reduction normal forms effective way
perform deduction avenhaus madlener baader nipkow rewrite
system specified set rules rule corresponds preferred direction
equivalence theorem main issue term rewriting systems convergence
two arbitrary terms rewritten finite number steps unique normal form
pbr two plans considered equivalent solutions


fiambite knoblock

although may differ cost operators equivalent
respect satisfiability introduced however interested
rewriting rules prove equivalence instead framework uses rewriting
rules explore space solution plans
graph rewriting akin term rewriting refers process replacing subgraph
given graph conditions satisfied another subgraph graph rewriting
found broad applications high level programming languages database
data description query languages etc schurr presents good survey
main drawback general graph rewriting complexity graph matching
reduced sub graph isomorphism np complete nevertheless
restrictions graph rewriting performed efficiently dorr
rewriting adapts general graph rewriting semantics partial order
strips operator representation plan rewriting rule pbr specifies
replacement certain conditions subplan another subplan however
formalism rule need specify completely detailed embedding
consequent graph rewriting systems consistent embeddings rule consequent
generation edges necessary automatically computed according
semantics partial order ensures rewritten plans
remain valid section plan rewriting rules intended explore space
solution plans reach high quality plans
local search combinatorial optimization
pbr inspired local search techniques used combinatorial optimization
instance combinatorial optimization consists set feasible solutions
cost function solutions consists finding solution optimal
cost among feasible solutions generally addressed computationally
intractable thus approximation used one class approximation
surprisingly successful spite simplicity local search
methods aarts lenstra papadimitriou steiglitz
local search concept neighborhood neighborhood solution
p set solutions sense close p example
easily computed p share significant amount structure p
neighborhood generating function may may able generate optimal
solution neighborhood function generate global optima starting
initial feasible point called exact papadimitriou steiglitz page
local search seen walk directed graph whose vertices solutions
points whose arcs connect neighboring points neighborhood generating function
determines properties graph particular graph disconnected
neighborhood exact since exist feasible points would lead local optima
global optima pbr points solution plans neighbors plan
plans generated application set declarative plan rewriting rules
basic version local search iterative improvement iterative improvement starts
initial solution searches neighborhood solution lower cost solution solution found replaces current solution search continues


fiplanning rewriting

otherwise returns locally optimal solution figure shows graphical
depiction basic iterative improvement several variations basic first improvement generates neighborhood incrementally selects first
solution better cost current one best improvement generates complete
neighborhood selects best solution within neighborhood

neighborhood

local optima

local optima

basic iterative improvement

b variable depth search

figure local search
basic iterative improvement obtains local optima necessarily global optimum
one way improve quality solution restart search several initial points choose best local optima reached advanced
variable depth search simulated annealing tabu search attempt
minimize probability stuck low quality local optimum
variable depth search applying sequence steps opposed one
step iteration moreover length sequence may change iteration
iteration way system overcomes small cost increases eventually lead
strong cost reductions figure b shows graphical depiction variable depth search
simulated annealing kirkpatrick gelatt vecchi selects next point randomly lower cost solution chosen selected solution higher cost
chosen still selected probability probability decreased progresses analogously temperature physical annealing function
governs behavior acceptance probability called cooling schedule
proven simulated annealing converges asymptotically optimal solution unfortunately convergence requires exponential time practice simulated annealing
used faster cooling schedules guaranteed converge optimal thus
behaves approximation
tabu search glover accept cost increasing neighbors next solution
randomly chosen legal neighbor even cost worse current solution
neighbor legal limited size tabu list dynamically updated tabu list
prevents solution points considered period time intuition
decide consider solution higher cost least lie
unexplored part space mechanism forces exploration solution space
local minima
finally stress appeal local search relies simplicity good
average case behavior could expected number negative worst case example traveling salesman known exact neighborhoods


fiambite knoblock

depend instance must exponential size savage weiner
bagchi moreover improving move neighborhoods cannot found
polynomial time unless p np papadimitriou steiglitz nevertheless best
approximation traveling salesman local search
johnson

rewriting local search
rewriting viewed domain independent framework local search
pbr accepts arbitrary domain specifications declarative plan rewriting rules generate
neighborhood plan arbitrary local search methods therefore assuming
given combinatorial encoded pbr take
input experiment different neighborhoods search methods
describe main issues rewriting instantiation
local search idea typical combinatorial optimization
selection initial feasible point pbr phase consists efficiently generating
initial solution plan
generation local neighborhood pbr neighborhood plan set
plans obtained application set declarative plan rewriting rules
cost function minimize measure plan quality planner
optimizing plan quality function range simple domain independent
cost metric number steps complex domain specific ones
query evaluation cost total manufacturing time set parts
selection next point pbr consists deciding solution plan
consider next choice determines global space explored
significant impact efficiency variety local search strategies
used pbr steepest descent simulated annealing etc search
method yields best may domain specific
following subsections expand issues first discuss use
declarative rewriting rules generate local neighborhood plan constitutes
main contribution present syntax semantics rules
plan rewriting formal properties complexity analysis plan rewriting
rule taxonomy second address selection next plan associated
search techniques plan optimization third discuss measures plan quality
finally describe approaches initial plan generation
local neighborhood generation plan rewriting rules
neighborhood solution plan generated application set declarative
plan rewriting rules rules embody domain specific knowledge transformations solution plan likely higher quality solutions application
given rule may produce one several rewritten plans fail produce plan
rewritten plans guaranteed valid solutions first describe syntax


fiplanning rewriting

semantics rules second introduce two approaches rule specification third
present rewriting formal properties complexity plan rewriting
finally present taxonomy plan rewriting rules
plan rewriting rules syntax semantics
first introduce rule syntax semantics examples provide
formal description plan rewriting rule three components antecedent
field specifies subplan matched replace field identifies subplan
going removed subset steps links antecedent field
specifies replacement subplan figure shows two rewriting rules blocks world
domain introduced figure intuitively rule avoid move twice says whenever
possible better stack block top another directly rather first moving
table situation occurs plans generated simple first
puts blocks table build desired towers plan figure
rule avoid undo says actions moving block table back
original position cancel could removed plan
define rule name avoid move twice
operators n unstack b b
n stack b b table
links n b table n
constraints possibly adjacent n n
neq b b
replace operators n n
operators n stack b b b

define rule name avoid undo
operators
n unstack b b
n stack b b table
constraints
possibly adjacent n n
replace operators n n
nil

figure blocks world rewriting rules
rule manufacturing domain minton b shown figure
domain additional rewriting rules described detail section rule states
plan includes two consecutive punching operations order make holes two
different objects another machine drill press available plan quality may
improved replacing one punch operations drill press domain
plan quality parallel time manufacture parts rule helps parallelize
plan thus improve plan quality
define rule name punch drill press
operators n punch width orientation
n punch width orientation
links n n
constraints neq
possibly adjacent n n
replace operators n
operators n drill press width orientation

figure manufacturing process rewriting rule


fiambite knoblock

plan rewriting rule syntax described bnf specification given figure
bnf generates rules follow template shown figure next describe
semantics three components rule replace fields detail
rule define rule name name
graph spec constraints
replace graph spec
graph spec
graph spec constraints graph spec
constraints constraints
graph spec operators nodes
links edges nil
nodes node node nodes
edges edge edge edges
constraints constraint constraint constraints
node node var node predicate resource
edge node var node var
node var edge predicate node var
node var threat node var
constraint interpreted predicate
neq pred var pred var
node var pred var optional alternative

figure bnf rewriting rules

define rule name rule name
operators nv np resource
links nv lp threat nv
constraints ip
replace operators nv
links nv lp threat nv
operators nv np resource
links nv lp nv
nv node variable np node predicate optional
lp causal link predicate ip interpreted predicate

alternative

figure rewriting rule template
antecedent field specifies subplan matched current
plan graph structure subplan defined operators links fields
operators field specifies nodes operators graph links field
specifies edges causal ordering links finally constraints field specifies
set constraints operators links must satisfy
operators field consists list node variable node predicate pairs
step number steps plan match given node predicate would
correspondingly bound node variable node predicate interpreted
two ways step action resource used step example node
specification n stack b b table antecedent avoid move twice
figure shows node predicate denotes step action node specification
collect tuples composed step number n blocks b b obtained matching
steps whose action stack block b table moved top
another block b node specification applied plan figure would


fiplanning rewriting

three matches c b c b variables n b b respectively
optional keyword resource present node predicate interpreted one
resources used plan step opposed describing step action example
rule matches resources operator given figure node
specification n machine x resource match steps use resource
type machine collect pairs step number n machine object x
define rule name resource swap
operators n machine x resource
n machine x resource
links n threat n
replace links n n
links n n

figure resource swap rewriting rule
links field consists list link specifications language admits link
specifications three types first type specified pair node variables
example n n figure specification matches temporal ordering link
plan regardless imposed causal links resolution threats
second type link specification matches causal links causal links specified
triples composed producer step node variable edge predicate consumer
step node variable semantics causal link producer step asserts
effects predicate turn needed preconditions consumer step
example link specification n b table n figure matches steps n
put block b table steps n subsequently pick block
link specification applied plan figure would matches c
b variables n b n
third type link specification matches ordering links originating resolution
threats coming resource conflicts operator conflicts links
selected keyword threat place condition example
resource swap rule figure uses link specification n threat n ensure
steps ordered involved threat situation matched
helps identify critical steps reasons e
causal links order therefore rule may attempt reorder
useful plan quality depends degree parallelism plan
different ordering may help parallelize plan recall threats solved
promotion demotion reverse ordering may produce valid plan
often case conflict among resources rule figure
interpreted predicates built user defined specified constraints
field predicates implemented programmatically opposed obtained
matching components plan built predicates currently implemented
inequality neq comparison arithmetic predicates
user add arbitrary predicates corresponding programmatic implementa equality denoted sharing variables rule specification



fiambite knoblock

tions interpreted predicates may act filters previous variables introduce
variables compute values example user defined predicate
possibly adjacent rules figure ensures steps consecutive
linearization plan plan figure extension possibly adjacent
predicate goal
user easily add interpreted predicates including function definition
implements predicate rule matching passes arguments calls
functions appropriate current plan passed default first argument
interpreted predicates order provide context computation predicate
ignored figure skeleton lisp implementation
possibly adjacent less interpreted predicates
defun possibly adjacent plan node node
necessarily adjacent
node
node
accesses current plan
plan ordering plan

defun less plan n n
declare ignore plan
numberp n numberp n
n n
nil true
nil false

figure sample implementation interpreted predicates
consequent composed replace fields replace field
specifies subplan going removed plan subset
steps links identified antecedent step removed links refer
step removed field specifies replacement subplan
see sections replacement subplan need completely
specified example field avoid move twice rule figure
specifies addition stack step step embedded plan
links rest plan automatically computed rewriting process
plan rewriting rules full versus partial specification
pbr gives user total flexibility defining rewriting rules section describe two
approaches guaranteeing rewriting rule specification preserves plan correctness
produces valid rewritten plan applied valid plan
full specification rule specifies steps links involved
rewriting rule antecedent identifies anchoring points operators
consequent embedding replacement subplan unambiguous
valid plan burden proving rule correct lies upon user automated
rule defining procedure cf section kind rules ones typically used
graph rewriting systems schurr
partial specification rule defines operators links constitute gist plan transformation rule prescribe precise
interpreted predicate possibly adjacent makes link expression antecedent avoid move twice redundant unstack puts block b table picked
stack operator thus causal link n b table n already implied operators
constraints specification could removed rule specification



fiplanning rewriting

embedding replacement subplan burden producing valid plan lies upon
system pbr takes advantage semantics domain independent accept
relaxed rule specification fill details produce valid rewritten plan
moreover user free specify rules may necessarily able compute
rewriting plan matches antecedent necessary condition
checked antecedent partially specified rule may overgeneral
may seem undesirable often rule may cover useful cases naturally
specified form rule may fail rarely occurring plans effort
defining matching complete specification may worthwhile case
plan rewriting ensures application rewriting rule generates
valid plan fails produce plan theorem section
example two approaches rule specification consider figure
shows avoid move twice full rule fully specified version avoid move twice
rule figure reprinted convenience avoid move twice full rule
complex less natural specify avoid move twice importantly
avoid move twice full making commitments avoid move twice particular avoid move twice full fixes producer clear b n n
n known valid candidate general several alternative producers
precondition replacement subplan consequently many possible embeddings
different fully specified rule needed capture embedding number rules
grows exponentially permutations embeddings enumerated however
partial specification express general plan transformation
single natural rule
define rule name avoid move twice full
operators n unstack b b
n stack b b table
links n clear b n
n b b n
n clear b n
n b table n
n clear b n
n clear b n
n b b n
constraints possibly adjacent n n
neq b b
replace operators n n
operators n stack b b b
links n clear b n
n clear b n
n b b n
n b b n

define rule name avoid move twice
operators
n unstack b b
n stack b b table
links n b table n
constraints
possibly adjacent n n
neq b b
replace operators n n
operators
n stack b b b

figure fully specified versus partially specified rewriting rule
summary main advantage full specification rules rewriting
performed efficiently embedding consequent already specified
disadvantages number rules represent generic plan transformation
may large resulting rules quite lengthy may decrease


fiambite knoblock

performance match rule specification error prone written
user conversely main advantage partial specification rules single
rule represent complex plan transformation naturally concisely rule
cover large number plan structures even may occasionally fail partial
specification rules much easier specify understand users system
seen pbr provides high degree flexibility defining plan rewriting rules
plan rewriting
section first describe basic plan rewriting pbr second
prove sound discuss formal properties rewriting finally
discuss family plan rewriting depending parameters
language defining plan operators specification language rewriting rules
requirements search method
plan rewriting shown figure takes two inputs
valid plan p rewriting rule r qm pr pc qm antecedent query pr
replaced subplan pc replacement subplan output valid rewritten
plan p matching antecedent rewriting rule qm determines rule
applicable identifies steps links interest line matching seen
subgraph isomorphism antecedent subplan current plan
filtered applying constraints however take different
pbr implements rule matching conjunctive query evaluation implementation keeps
relational representation steps links current plan similar node
link specifications rewriting rules example database plan
figure contains one table unstack steps schema n b b tuples
c b another table causal links involving clear condition
schema n n b tuples c b c b c b
similar tables operator link types match
process consists interpreting rule antecedent conjunctive query interpreted
predicates executing query relational view plan structures
running example analyze application avoid move twice rule figure
plan figure matching rule antecedent identifies steps
precisely considering antecedent query single tuple c
variables n b b n b
choosing match work line instantiates subplan
specified replace field pr according match line removes
instantiated subplan pir original plan p line edges incoming
emanating nodes replaced subplan removed effects
replaced plan pir achieving remainder plan p pir usefuleffects pir
achieved replacement subplan steps p pir order
facilitate process addflaws procedure records effects open conditions
pocl planners operate keeping track repairing flaws found partial plan open conditions operator threats resource threats collectively called flaws penberthy weld
addflaws f p adds set flaws f plan structure p



fiplanning rewriting

procedure rewriteplan
input valid partial order plan p
rewriting rule r qm pr pc v ariables pr v ariables qm
output valid rewritten partial order plan p failure
atch qm p
match rule antecedent qm field p set substitutions
variables qm
return failure
choose match
pir pr
instantiate subplan removed pr replace field according
pri addflaws usefuleffects pir p pir
remove instantiated subplan pir plan p add usefuleffects pir
open conditions resulting plan pri incomplete
pic pc
instantiate replacement subplan pc field according
pci addf laws p reconditions pic f indt hreats pri pic pri pic
add instantiated replacement subplan pic pri threats open
conditions add flaws pci potentially incomplete several flaws
need resolved
p rp op pci
complete plan partial order causal link restricted
step reuse step addition order resolve threats open conditions
rp op returns failure valid plan found
return p
figure plan rewriting
partial plan pri line continuing example figure shows
plan resulting removing steps plan figure
finally embeds instantiated replacement subplan pic remainder original plan lines rule completely specified simply
adds already instantiated replacement subplan plan work
necessary rule partially specified computes embeddings
replacement subplan remainder original plan three stages first
adds instantiated steps links replacement plan pic line
current partial plan pri line figure b shows state example
pic stack step incorporated plan note open conditions
clear c second findthreats procedure computes possible threats
operator threats resource conflicts occurring pri pic partial plan line
example threat situation clear c proposition step figure b threats preconditions replacement plan pic recorded
addflaws resulting partial plan pci finally completes plan
rpop partial order causal link procedure restricted reuse steps e


fiambite knoblock

step addition line rpop allows us support expressive operator language
flexibility computing one embeddings one rewriting needed
rpop stops first valid plan otherwise continues exhausting alternative ways satisfying open preconditions resolving conflicts produces valid
rewritings running example one embedding possible resulting plan
figure c stack step produces clear c
preconditions satisfied ordering ensures plan valid
rewriting figure sound sense produces valid plan
input valid plan outputs failure input plan cannot rewritten
given rule since elementary plan rewriting step sound sequence rewritings
performed pbrs optimization search sound
lemma soundness rpop partial order causal link pocl without
step addition rp op sound
proof pocl precondition step plan achieved
inserting step snew reusing step sreuse already present current plan
steps effect unifies precondition forbidding step addition decreases
set available steps used satisfy precondition step found
rpop proceeds general pocl since pocl completion partial plan sound
penberthy weld rp op sound
theorem soundness plan rewriting rewriteplan figure produces
valid plan input p valid plan outputs failure input plan cannot
rewritten given rewriting rule r qm pr pc
proof assume plan p solution goals g initial
state pocl plan valid iff preconditions steps supported
causal links goals g preconditions goal step initial state
conditions effects initial step operator threatens causal link
mcallester rosenblitt penberthy weld
rule r match plan p trivially returns failure line assuming
match removing p steps links specified pir including
links causal ordering incoming outgoing steps pir open
conditions exist resulting plan pri pir achieving line
adding instantiated replacement subplan pic introduces open conditions
partial plan preconditions steps pic line sources
open conditions
since plan p valid initially operator resource threats present
plan pci line caused removal subplan pir line addition
subplan pic line threats may occur operators causal links pri pic
regardless whether operator causal link initially pri pic threats
combined plan pri pic effectively computed finding relative positions
steps comparing causal link steps may ordered
producer consumer condition causal link findthreats line
point shown plan pci flaws threats
open conditions explicitly recorded addflaws lines since rp op sound
lemma conclude rp op complete pci output valid plan p output
failure flaws plan cannot repaired


fiplanning rewriting

clear b

removed subplan

table
c

causal link
ordering constraint
side effect

clear

unstack c
c
clear c
table

table
clear b

stack b table
c table
stack b c table

clear c
stack c table



b table
b
clear c
b c
c
goal

clear
clear b

c table

clear



b

b

b table
unstack b
b
clear b

c

b

c







clear c
initial state

goal state

application rewriting rule removing subplan
clear b

causal link
ordering constraint
open conditions

table

clear
clear c
table


c
clear b

stack b table
b table
b
clear c
b c

stack b c table
clear c

clear

c
clear

b

table
clear b

c

stack c

c
clear
c

goal


clear

b

b table
unstack b
b

clear b

c

b

c







clear c
initial state

goal state

b application rewriting rule adding replacement subplan
table
clear b

table

stack b table

clear b
clear

table
c

stack b c table

clear c



stack c
clear b

b table
b
clear c
b c
c
goal

clear
c

clear

causal link
ordering constraint
side effect

b
b table
unstack b
b
clear b


b

c

b

c







clear c
initial state

goal state

c rewritten plan
figure plan rewriting applying rule avoid move twice figure plan figure


fiambite knoblock

corollary soundness pbr search optimization search pbr sound
proof induction assume initial valid plan single step rewriting search
theorem output valid rewritten plan failure output failure
search trivially sound assume valid plan pn n rewriting steps
according theorem applying single rewriting rule plan pn produces valid
plan pn failure thus arbitrary number rewritings produces valid plan
plan pbrs search sound
although rewriteplan sound may certainly produce plans
minimal number steps faced arbitrary rules example imagine
consequent rewriting rule specified two identical steps
effects e e flaws pci exactly open conditions e e
sound non step minimal plan would satisfy e
satisfy e although step could satisfy open conditions pbr
discard plan make restriction types acceptable cost
functions cost function took robustness plan account
plan steps may desirable
cannot guarantee pbrs optimization search complete sense
optimal plan would found pbr uses local search well known general
local search cannot complete even pbr exhaustively explores space plan
rewritings induced given initial plan set rewriting rules still cannot prove
solution plans reached property initial plan generator
set rewriting rules semantics domain rewriting rules pbr
play similar role traditional declarative search control completeness
search may traded efficiency perhaps techniques inferring invariants
domain gerevini schubert fox long rintanen proving
convergence term graph rewriting systems baader nipkow conditions
completeness plan rewriting search given domain could obtained
design plan rewriting depends several parameters language
operators language rewriting rules choice full specification partialspecification rewriting rules need rewritings one rewriting required
search method
language operators affects way initial rewritten plans
constructed framework supports expressive operator definition language described
section provide support language standard techniques causal
link establishment threat checking sage knoblock ucpop
penberthy weld
language antecedents rewriting rules affects efficiency matching
system implements conjunctive query language described section
however system could easily accommodate expressive query language
rule antecedent relationally complete language e conjunction disjunction
safe negation abiteboul hull vianu recursive language datalog
stratified negation without significantly increasing computational complexity
important way discuss section
choice fully versus partially specified rewriting rules affects way
replacement plan embedded current plan rule completely specified


fiplanning rewriting

embedding already specified rule consequent replacement subplan
simply added current plan rule partially specified
compute valid embeddings
choice one versus rewritings affects antecedent matching
embedding rule consequent rule matches computed
time bottom evaluation logic databases one time prolog depending whether search strategy requires one rewritings rule fully specified
one embedding per match possible rule partially specified multiple
embeddings may single match search strategy requires one rewriting must provide mechanism choosing rule applied match
computed embedding generated rpop stop first embedding
compute embeddings implemented rewriting modular design
support different combinations choices
complexity plan rewriting
complexity plan rewriting pbr originates two sources matching rule
antecedent plan computing embeddings replacement plan
order analyze complexity matching plan rewriting rules introduce following
database theoretic definitions complexity abiteboul et al
data complexity complexity evaluating fixed query variable database inputs
expression complexity complexity evaluating fixed database instance
queries specifiable given query language
data complexity measures complexity respect size database
expression complexity measures complexity respect size queries
taken given language case database steps links plan
queries antecedents plan rewriting rules
formally language rule antecedents described section conjunctive
queries interpreted predicates worst case combined data expression complexity conjunctive queries exponential abiteboul et al size
query rule antecedent size database plan grow simultaneously
little hope matching efficiently fortunately relationally complete languages data
complexity contained logarithmic space turn contained polynomial time
abiteboul et al thus conjunctive query language complexity
encouraging shows cost evaluating fixed query grows
slowly database size increases pbr means matching antecedent
rules strongly affected size plans moreover experience
useful rule antecedents large contain many constant labels least
node edge predicate names help reduce size intermediate
improve efficiency matching indicates could extend
language antecedent relationally complete without affecting significantly
performance system another possible extension use datalog stratified
negation polynomial time data complexity graph theoretic properties
figure section proposes example rule relationally complete antecedent
appropriate syntax



fiambite knoblock

plans could easily described datalog example possibly adjacent interpreted predicate figure could described declaratively datalog program instead
piece code summary rule match moderately sized rules even quite expressive
languages large plans remains tractable made efficient production
match forgy query optimization techniques sellis
second source complexity computing embeddings replacement plan
given consequent plan rewriting rule definition full specification rules
embedding completely specified rule thus suffices simply remove
undesired subplan directly add replacement subplan linear size
consequent
partial specification rules computing embeddings replacement subplan
exponential size plan worst case however occurs
pathological cases example consider plan figure going
compute embeddings step x remainder plan order satisfy open
precondition g step x preconditions two effects b g step
plan proposition b effect therefore step x conflicts every step
plan n ordered respect steps unfortunately
exponential number orderings effect orderings imposed adding step
x correspond partitions set steps n two sets one ordered
x one figure b shows one possible orderings subplan
embedding contained several steps contained similar conflicts would
compounded even deciding single embedding exists np hard example
add two additional effects g operator x valid embedding
worst case solving first flaws induced conflicts proposition b
explore exponential number positions step x plan end
failure nevertheless given quasi decomposability useful domains expect
number conflicts relatively small useful rewriting rules specify
replacement subplans small compared plan embedding
experience indicates plan rewriting partial specification rules performed
efficiently shown section
b

b





g





b

g
b





g
g
b





g



g


b

x

g

g

x

g



n

gn

gn



b

n

embedding

b

b one possible embedding

figure exponential embeddings



fiplanning rewriting

taxonomy plan rewriting rules
order guide user defining plan rewriting rules domain help designing
may automatically deduce rules domain specification see
section helpful know kinds rules useful identified
following general types transformation rules
reorder rules algebraic properties operators commutative associative distributive laws example commutative rule reorders
two operators need resource figure join swap rule figure
combines commutative associative properties relational algebra
collapse rules replace subplan smaller subplan example
several operators replaced one remote join eval rule figure
rule replaces two remote retrievals information source local join
operation single remote join operation remote source capability
performing joins example application rule query plan shown
figure examples blocks world rules figure replace unstack
stack operators equivalent single stack operator empty plan
expand rules replace subplan bigger subplan although may
appear counter intuitive initially easy imagine situation expensive
operator replaced set operators cheaper whole interesting
case operators already present plan synergistically reused rule type domains analyzed far backstrom
presents framework adding actions improves quality plans
quality metric plan execution time similarly manufacturing domain section figure shows example domain adding actions improves
quality backstrom example removing link bm c
inserting action shortens significantly time execute plan
p

rn

r

r


c

c
r

p

p

q

qm

b

rn
cn

p

rn
cn

p
q

rn

r

r


b

bm

bm qm

qm

qm

low quality plan

b high quality plan

figure adding actions improve quality
parallelize rules replace subplan equivalent alternative subplan
requires fewer ordering constraints typical case redundant alternative resources operators use example rule punch drill press
figure another example rule figure suggests could seen
combination expand parallelize types


fiambite knoblock

selection next plan search strategies
although space rewritings explored systematically rewriting
framework better suited local search techniques typical combinatorial optimization characteristics domain initial plan generator
rewriting rules determine local search method performs best first discuss
initial plan generator affects choice local search methods second consider impact rewriting rules third discuss role domain knowledge
search process finally describe several local search methods work pbr
important difference pbr traditional combinatorial
generation feasible solutions usually combinatorial optimization exists
effective procedure generate feasible solutions e g permutations schedule
thus even local search graph disconnected choosing appropriate initial
solution generator e g random could fall component graph contains
global optimum pbr cannot assume powerful initial plan generators even
optimization domains efficient initial plan generators may
guarantees coverage solution space provide therefore optimal plan
may reachable applying rewriting rules starting initial plans
available generator nevertheless many domains initial plan generator
provides good sample solution space sufficient multiple restart search methods
escape low quality local minima provide high quality solutions
plan rewriting rules define neighborhood function may exact cf
section example query domain define set
rules completely generate space solution plans properties
relational algebra domains may hard prove exact set
rules limitations initial plan generation plan rewriting rules affect
possibility theoretically reaching global optimum surprising since many
regardless whether cast formalisms
converging local search e g papadimitriou steiglitz nevertheless
practice good local optima still obtained many domains
many local search methods first best improvement simulated annealing
tabu search variable depth search applied straightforwardly pbr
experiments section used first best improvement performed
well next describe details application two methods pbr
section discuss ideas variable depth plan rewriting
first improvement generates rewritings incrementally selects first plan
better cost current one order implement method efficiently use
tuple time evaluation rule antecedent similarly behavior prolog
rule instantiation generate one embedding test cost resulting plan
better current plan repeat choice generating another
embedding rule instantiation generate another instantiation rule
generate match different rule
best improvement generates complete set rewritten plans selects best
method requires computing matches embeddings match
matches obtained evaluating rule antecedent set time database


fiplanning rewriting

query discussed section query evaluation quite efficient
experience computing plan embeddings usually expensive computing
rule matches
rewriting choice initial plan generator rewriting rules
search methods intertwined initial plan generator fixed determines
shape plans would modified rewriting rules according
neighborhood appropriate search mechanism chosen pbr
modular design facilitate experimentation different initial plan generators sets
rewriting rules search strategies
plan quality
practical domains quality plans crucial one
motivations rewriting pbr user defines measure
plan quality appropriate application domain quality metric could
range simple domain independent cost metric number steps
complex domain specific ones example query domain measure
plan quality usually estimation query execution cost size
database relations data manipulation operations involved answering query
cost network transfer decentralized environment cost metric may involve
actual monetary costs information sources require payments jobshop scheduling domain simple cost functions schedule length
parallel time finish pieces sum times finish piece
sophisticated manufacturing domain may include variety concerns cost
reliability precision operator process costs resources materials used
operators utilization machines etc reader detailed
examples quality metrics domains sections
significant advantage pbr complete plan available assess quality
generative planners complete plan available search solution
completed usually simple plan quality metrics number steps
used work incorporate quality concerns generative planners estlin
mooney borrajo veloso perez systems automatically
learn search control rules improve efficiency quality
resulting plans pbr rewriting rules seen post facto optimization search
control opposed guiding search generative planner towards high quality
solutions information available partial plans pbr improves quality
complete solution plans without restriction types quality metrics moreover
plan cost additive plan refinement strategy impractical since may need
exhaustively explore search space optimal plan example nonadditive cost function appears unix domain etzioni weld
plan transfer files two machines may cheaper files compressed
initially uncompressed arrival plan includes compression
necessary uncompression operations cost effective plan refinement
search would naturally lead complete plans pbr accurately assess
arbitrary measures quality


fiambite knoblock

initial plan generation
fast initial plan generation domain specific nature requires user specify
efficient mechanism compute initial solution plan general generating initial
plan may hard generating optimal plan however crucial intuition behind
practical quasi decomposable simon
interactions among parts limited interactions
pervasive puzzle operator representation classical little use would behave search
solver fortunately many practical indeed quasi decomposable
intuition suggests finding initial plan generators may
hard appears system solve subproblems independently
combine simplest way example concatenating solutions sequentially moreover many circumstances may easily transformed
state minimizes interactions solving state much easier
example blocks world state blocks table minimizes
interactions simple design solves blocks world
passing intermediate state methods initial plan generator may
produce suboptimal initial plans reasonable cost
ideas constructing initial plan generators embodied two general ways
implemented system first one bootstrap
general purpose strong search control bias second one
provide user convenient high level facilities describe plan construction
programmatically
biased generative planners
variety ways control search generic planner planners
accept search control rules others accept heuristic functions built search
control present examples techniques
general way efficiently constructing plans use domain independent
generative planner accepts search control rules example prodigy carbonell
knoblock minton ucpop penberthy weld sage knoblock
planners setting type search providing strong bias means
search control rules planner quickly generate valid although possibly suboptimal
initial plan example manufacturing domain minton analyzed
detail section depth first search goal selection heuristic abstraction
hierarchies knoblock quickly generates feasible plan often quality
plan defined time required manufacture objects suboptimal
tlplan bacchus kabanza efficient forward chaining planner
uses search control expressed temporal logic forward chaining complete
state available much refined domain control knowledge specified
preferred search strategy used tlplan depth first search although finds plans
efficiently plans may low quality note generative planner
explores partial sequences steps cannot use sophisticated quality measures


fiplanning rewriting

hsp bonet loerincs geffner bonet geffner forward search
planner performs variation heuristic search applied classical ai
built heuristic function relaxed version computes
number required steps reach goal disregarding negated effects operators
metric computed efficiently despite simplicity heuristic
admissible scales surprisingly well many domains plans generated
according fixed heuristic function planner cannot incorporate quality metric
types planners quite efficient practice although often produce suboptimal plans excellent candidates generate initial plans
subsequently optimized pbr
facilitating algorithmic plan construction
many domains simple domain dependent approximation provide good
initial plans example query domain system easily generate
initial query evaluation plans randomly greedily parsing given query
blocks world straightforward generate solution linear time naive
put blocks table build desired towers bottom
produces plans length worse twice optimal makes
already good approximation however interest blocks world
traditionally optimal solutions np hard gupta nau
system facilitates creation initial plans freeing user specifying detailed graph structure plan user needs specify
produces sequence instantiated actions action names ground
parameters action takes example user defined naive
blocks world domain described applied figure produces
sequence unstack c unstack b stack c table stack b c table
stack b table system automatically converts sequence actions
fully detailed partial order plan operator specification domain resulting plan conforms internal data structures pbr uses process includes
creating nodes fully detailed operators preconditions effects adding
edges represent necessary causal links ordering constraints blocks
world example resulting plan figure
transforms user defined sequence actions partial order
plan presented figure first constructs causal structure plan
lines adds necessary ordering links avoid threats lines
user needs specify action names corresponding instantiated action
parameters consults operator specification preconditions
effects instantiate construct causal links check operator threats
operator threats resolved favor ordering given user input
plan reason input plan may overconstrained total order
assumed valid therefore processing step last first orderings
indeed avoid threats included partial order plan
accepts extra ordering constraints addition sequence available
initial plan generator



fiambite knoblock

procedure po
input valid total order plan
output equivalent partial order plan
n

p preconditions ai

choose k

p positiveeffects ak

l k l p negativeeffects al

add order ak ai

p negativeeffects ai

j

p preconditions aj

add order aj ai
return
figure converting total order partial order plans
extension greedy presented veloso perez carbonell explores non deterministically producers proposition line opposed taking latest producer sequence
explored exhaustively produces partially ordered causal
structures consistent input sequence generalization stems criticism
backstrom b veloso et al desire able
produce alternative initial plans
transforming sequence steps least constrained plan analyzed
backstrom b several natural definitions optimality definitions
least constrained plan shortest parallel execution np hard backstrom
shows velosos although polynomial conform natural definitions greedy suffer drawbacks
pointed backstrom moreover purposes need optimal initial plans
space partial orders explored rewriting process
regardless method producing initial plans generators provide multiple
plans preferable different initial plans used conjunction multiple restart
search techniques order escape low quality local minima

empirical
section broad applicability rewriting analyzing four
domains different characteristics process manufacturing domain minton b
transportation logistics domain blocks world domain used examples
throughout domain distributed query
implement enough replace line figure
max k



fiplanning rewriting

manufacturing process
task manufacturing process domain plan manufacture
set parts implemented pbr translation domain specification minton
b domain contains variety machines lathe punch spray painter
welder etc total ten machining operations operator specification shown
figures features part described set predicates
temperature painted hole etc features changed operators
predicates state clamp drillable etc set initial state

example behavior operator consider polish operator figure
requires part manufacture cold polisher clamp secure
part machine effect applying operator leave surface
part polished attributes part surface condition single valued
others hole multivalued note drill press punch
operators figure prevent several hole conditions asserted
part interesting operators weld bolt operators join two
parts particular orientation form part operations performed
separate parts joined
measure plan cost schedule length parallel time manufacture
parts domain machining operations assumed take unit time
machines objects parts modeled resources order enforce one
part placed machine time machine operate single
part time except bolt weld operate two parts simultaneously
already shown types rewriting rules domain figures
set rules used experiments shown figure top
eight rules quite straightforward one becomes familiar domain two
top rules explore space alternative orderings originated resource conflicts
machine swap rule allows system explore possible orderings operations
require machine rule finds two consecutive operations machine
swaps order similarly rule object swap allows system explore
orderings operations object two rules use interpreted predicate
adjacent critical path focus attention steps contribute cost
function adjacent critical path checks two steps consecutive along one
critical paths schedule critical path sequence steps take longest
time accomplish words critical path one sequences steps
determine schedule length
next six rules exchange operators equivalent respect achieving
effects rules ip sp sp ip propose exchange immersion paint
spray paint operators examining operator definitions figure
readily noticed operators change value painted predicate similarly
pu dp dp pu exchange drill press punch operators produce
hole predicate finally roll lathe lathe roll exchange roll lathe
operators make parts cylindrical focus search promising


fiambite knoblock

define operator polish
parameters x
resources machine polisher object x
precondition object x
temperature x cold
clamp polisher
effect
forall surf
neq surf polished
surface condition x surf
surface condition x polished

define operator grind
parameters x
resources machine grinder object x
precondition object x
effect
forall color
painted x color
forall surf
neq surf smooth
surface condition x surf
surface condition x smooth

define operator lathe
parameters x
resources machine lathe object x
precondition object x
effect
forall color
painted x color
forall shape
neq shape cylindrical
shape x shape
forall surf
neq surf rough
surface condition x surf
surface condition x rough
shape x cylindrical

define operator roll
parameters x
resources machine roller object x
precondition object x
effect
forall color
painted x color
forall shape
neq shape cylindrical
shape x shape
forall temp
neq temp hot
temperature x temp
forall surf
surface condition x surf
forall width orientation
hole x width orientation
temperature x hot
shape x cylindrical

define operator drill press
parameters x width orientation
resources machine drill press
object x
precondition
object x
bit width
drillable x orientation
effect hole x width orientation

define operator punch
parameters x width orientation
resources machine punch object x
precondition
object x
clamp punch
punchable x width orientation
effect
forall surf
neq surf rough
surface condition x surf
surface condition x rough
hole x width orientation

figure operators manufacturing process

exchanges rules match operators critical path means interpreted
predicate critical path
six bottom rules figure sophisticated lathe sp sp rule
takes care undesirable effect simple depth first search used initial plan
generator domain order spray paint part part must regular shape
cylindrical regular shape therefore initial planner may decide make
part cylindrical lathing order paint however may necessary
part may already regular shape example could rectangular
regular shape thus lathe sp sp substitutes pair spray paint lathe
single spray paint operation supporting regular shapes interpreted predicate


fiplanning rewriting

define operator immersion paint
parameters x color
resources machine immersion painter
object x
precondition
object x
paint immersion color
effect painted x color

define operator spray paint
parameters x color shape
resources machine spray painter
object x
precondition object x
sprayable color
temperature x cold
regular shape shape
shape x shape
clamp spray painter
effect painted x color

define operator bolt
define operator weld
parameters x obj orient width
parameters x obj orient
resources machine bolter
resources machine welder
object x object
object x object
precondition
precondition
object x object
object x object
composite object obj orient x
composite object obj orient x
hole x width orient
welded x orient
hole width orient
effect temperature obj hot
bolt width width
joined x orient
bolted x orient
object x
effect object x
object
object
joined x orient

figure operators manufacturing process ii

enumerates regular shapes rules partially specified
guaranteed produce rewriting nevertheless often successful
producing plans lower cost
remaining rules explore bolting two parts bolts different size fewer operations may needed plan developed rules analyzing differences
quality optimal plans rewritten plans example consider
providers diff bolt rule rule states parts bolted already
compatible holes better reuse operators produced
holes initial plan generator may drilled punched holes whose purpose
bolt parts however goal may already require holes
performed parts joined reusing available holes produces economical plan rules hole x diff bolt add pu hole x diff bolt add dp
hole diff bolt add pu hole diff bolt add dp address cases
one holes reused thus additional punch drill press
operation needs added
illustration rewriting process manufacturing domain consider figure plan top figure simple initial plan generator
solves part independently concatenates corresponding subplans although
plan generated efficiently poor quality requires six time steps manufacture parts figure shows application two rewriting rules machine swap
ip sp improve quality plan operators matched rule antecedent shown italics operators introduced rule consequent shown
bold first machine swap rule reorders punching operations parts b


fiambite knoblock

define rule name machine swap
operators n machine x resource
n machine x resource
links n threat n
constraints
adjacent critical path n n
replace links n n
links n n

define rule name object swap
operators n object x resource
n object x resource
links n threat n
constraints
adjacent critical path n n
replace links n n
links n n

define rule name sp ip
define rule name ip sp
operators n spray paint x c
operators n immersion paint x c
constraints critical path n
constraints regular shapes
replace operators n
critical path n
operators n immersion paint x c
replace operators n
operators n spray paint x c
define rule name dp pu
define rule name pu dp
operators n drill press x w
operators n punch x w
constraints critical path n
constraints critical path n
replace operators n
replace operators n
operators n punch x w
operators n drill press x w
define rule name roll lathe
operators n roll x
constraints critical path n
replace operators n
operators n lathe x

define rule name lathe roll
operators n lathe x
constraints critical path n
replace operators n
operators n roll x

define rule name providers diff bolt
define rule name lathe sp sp
operators n bolt x z w
operators
links n hole x w n
n lathe x
n hole w n
n spray paint x color shape
n hole x w n
constraints regular shapes shape
n hole w n
replace operators n n
constraints neq w w
operators
n spray paint x color shape replace operators n n n
operators n bolt x z w
links n hole x w n
n hole w n
define rule name hole x diff bolt add dp
define rule name hole x diff bolt add pu
operators n bolt x z w
operators n bolt x z w
links n hole x w n
links n hole x w n
n hole w n
n hole w n
n hole x w n
n hole x w n
constraints neq w w
constraints neq w w
replace operators n n n
replace operators n n n
operators n bolt x z w
operators n bolt x z w
n drill press w
n punch w
links n hole x w n
links n hole x w n
n hole w n
n hole w n
define rule name hole diff bolt add dp
define rule name hole diff bolt add pu
operators n bolt x z w
operators n bolt x z w
links n hole x w n
links n hole x w n
n hole w n
n hole w n
n hole w n
n hole w n
constraints neq w w
constraints neq w w
replace operators n n n
replace operators n n n
operators n bolt x z w
operators n bolt x z w
n drill press x w
n punch x w
links n hole x w n
links n hole x w n
n hole w n
n hole w n

figure rewriting rules manufacturing process


fiplanning rewriting

lathe

ipaint red

punch

punch c

ipaint c blue

roll b

ipaint b red

reorder parts machine
lathe

ipaint red
punch c

cost

punch

cost

ipaint c blue

ipaint b red

roll b

immersion paint spray paint
lathe
roll b

ipaint red

punch

punch c

ipaint c blue

cost

spray paint b red

figure rewriting manufacturing domain
breaks long critical path resulted simple concatenation respective
subplans schedule length improves six four time steps still three parts
b c use painting operation immersion paint immersion painter
process one piece time three operations must done serially fortunately domain another painting operation spray paint ip sp
rule takes advantage fact substitutes immersion paint operation part b
spray paint operation parallelizes plan obtaining schedule length
three time steps optimal plan
compare four planners ipp initial two configurations pbr
ipp one efficient domain independent planners koehler nebel hoffman dimopoulos competition held fourth international
conference artificial intelligence systems aips ipp optimized reimplementation extension graphplan blum furst ipp produces
shortest parallel plans manufacturing domain exactly schedule length
cost function optimizing
initial initial plan generator uses divide conquer heuristic order generate
plans fast possible first produces subplans part joined goals
independently subplans generated sage depth first search without
regard plan cost concatenates subsequences actions merges
facilities section
pbr present two configurations pbr refer pbr
pbr configurations use first improvement gradient search strategy
random walk cost plateaus rewriting rules used figure
pbr starts search plan generated initial two configurations
differ many total plateau plans allowed pbr allows considering
plans improve cost without terminating search similarly pbr

fiambite knoblock

allows plateau plans note limit across plateaus encountered
search plateau
tested four systems machining parts ranging
goals goals distributed randomly parts goal average goals per part shown figure
graphs data point average given number goals
provably unsolvable initial pbr solved
proved unsolvable ipp solved total goals
goals goals ipp could solve goals
cpu seconds time limit
figure shows average time solvable set
four planners figure b shows average schedule length solved
planners solved ipp goals
fastest planner initial produces plans cost twice optimal ipp
produces optimal plans cannot solve goals two
configurations pbr scale much better ipp solving producing good
quality plans pbr matches optimal cost ipp plans except one
reason difference interesting explain faster pbr
stays close optimal less average cost difference
figure c shows average schedule length solved
planners goal range pbr configurations scale gracefully across
range improving considerably cost plans generated initial additional
exploration pbr allows improve plans even reason
difference pbr ipp goal complexity level cost
ipp could solve pbr initial
average shown figure b pbr matches cost
optimal plans produced ipp
figure shows average number operators plans solved
three planners goals figure e shows average number operators
plans solved planner across whole range
plans generated initial use additional operators pbr ipp
produce plans require fewer steps interestingly ipp sometimes produces plans
use operations pbr ipp produces shortest parallel plan one
minimum number steps particular observed ipp plans
suffer initial ipp would lathe part order paint
opposed initial would affect optimal schedule
length surprisingly adding additional steps domain may improve schedule
length albeit fairly rare situations case ipp
produced better schedule pbr could introduced rewriting rule
substituted immersion paint operator lathe spray paint operators
cases however rule low utility sense minton b
expands rewriting search space adds cost match random
search provides benefit rarely


fiplanning rewriting

average time cpu seconds


pbr
initial
ipp






















number blocks







average time


average plan cost schedule length

average plan cost schedule length


pbr
pbr
initial
ipp









b








number goals
















average plan cost
solved

c











number goals







average plan cost
solved





pbr
pbr
initial
ipp



average number plan operators

average number plan operators

pbr
pbr
initial
ipp



















pbr
pbr
initial
ipp





















number goals









number plan operators
solved

e









number goals

number plan operators
solved

figure experimental manufacturing process









fiambite knoblock

experiment illustrates flexibility pbr specifying complex rules domain benefits finding suboptimal initial plan quickly
efficiently transforming improve quality
logistics
task logistics domain transport several packages initial location
desired destinations used version logistics strips domain
aips competition restricted trucks planes
domain shown figure package transported one location another
loading truck driving truck destination unloading truck
truck load number packages cost function parallel time deliver
packages measured number operators critical path plan
define operator load truck
parameters obj truck loc
precondition
obj obj truck truck location loc
truck loc obj loc
effect obj loc
obj truck

define operator unload truck
parameters obj truck loc
precondition
obj obj truck truck location loc
truck loc obj truck
effect obj truck
obj loc

define operator drive truck
parameters truck loc loc city
precondition truck truck location loc location loc city city
truck loc city loc city city loc city
effect truck loc truck loc

figure operators logistics
compare three planners domain
ipp

ipp koehler et al produces optimal plans domain

initial initial plan generator picks distinguished location delivers packages
one one starting returning distinguished location example assume
truck distinguished location l package p must delivered location
l location l plan would drive truck l l c load truck p l
drive truck l l c unload truck p l drive truck l l c
initial plan generator would keep producing circular trips remaining packages
although efficient produces plans low quality
pbr pbr starts plan produced initial uses plan rewriting rules shown
figure optimize plan quality loop rule states driving location
returning back immediately useless fact operators must adjacent
important implies intervening load unload performed
vein triangle rule states better drive directly two
locations third point operation performed point
logistics domain aips moving packages plane among different cities
truck among different locations city isomorphic focused one better
analyze rewriting rules learned ambite knoblock minton



fiplanning rewriting

load earlier rule captures situation package loaded truck
first time packages location visited occurs initial planner
concerned trip another package unload later rule captures dual case
pbr applies first improvement search strategy one run restarts
define rule name loop
operators
n drive truck l l c
n drive truck l l c
links n n
constraints
adjacent critical path n n
replace operators n n
nil

define rule name triangle
operators
n drive truck l l c
n drive truck l l c
links n n
constraints
adjacent critical path n n
replace operators n n
operators
n drive truck l l c

define rule name unload later
define rule name load earlier
operators
operators
n drive truck l l c
n drive truck l l c
n unload truck p l
n drive truck l l c
n drive truck l l c
n load truck p l
links n n
links n n
constraints
constraints
adjacent critical path n n
adjacent critical path n n
n n
n n
replace operators n
replace operators n
operators n unload truck p l
operators n load truck p l
links n n
links n n

figure logistics rewriting rules



pbr
initial
ipp



pbr
initial
ipp



average plan cost

average time cpu seconds
























number packages









average time











number packages







b average plan cost

figure experimental logistics scaling number packages
compared performance ipp initial pbr set logistics
involving packages instance number packages
locations goals single truck single city performance
shown figure graphs data point average
given number packages satisfiable ipp could solve


fiambite knoblock

packages solved packages
packages shown figure figure shows average
time figure b shows average cost packages range
similar previous experiment initial efficient highly suboptimal pbr
able considerably improve cost plans optimal
blocks world
implemented classical blocks world domain two operators figure
domain two actions stack puts one block top another unstack
places block table start tower plan quality domain simply
number steps optimal domain np hard gupta nau
however trivial generate correct suboptimal plan linear time
naive put blocks table build desired towers bottom
compare three planners domain
ipp experiment used gam goal ordering heuristic koehler koehler
hoffmann tested blocks world good scaling
initial planner programmatic implementation naive
facilities introduced section
pbr configuration pbr starts plan produced initial uses
two plan rewriting rules shown figure optimize plan quality pbr applies first
improvement strategy one run restarts
generated random blocks world scaling number blocks
set consists random
blocks total may multiple towers initial
state goal state
figure shows average time block quantity
ipp cannot solve blocks within time limit cpu
seconds solving behavior ipp interesting ipp solved given
fast timed example able solve block seconds timed seconds remaining
seems typical behavior complete search gomes
selman kautz local search pbr allows scale much better solve

figure b shows average plan cost number blocks increases pbr
improves considerably quality initial plans optimal quality known
small pbr approximates achieve ran sage
less blocks larger plans know optimal cost however
slaney thiebaux performed extensive experimental analysis blocks world
domain comparison among different approximation
found initial plan generator unstack stack achieves empirically
quality around optimal range sizes analyzed figure
slaney thiebaux value average initial plans divided suggests


fiplanning rewriting

quality optimal plans quality achieved pbr comparable value
fact slightly better may due relatively small number
tested per block size skew random generator interestingly
plans found ipp actually low quality due fact ipp produces
shortest parallel plans means plans constructed fewest time
steps ipp may introduce actions time step required
summary experiments previous sections across variety
domains pbr scales large still producing high quality plans


average plan cost number operators

average time cpu seconds


pbr
initial
ipp






















number blocks





pbr
initial
ipp
initial















average time








number blocks







b average plan cost

figure experimental blocks world scaling number blocks

query
query considerable practical importance central traditional
database mediator systems section present distributed query
highlight use pbr domain complex cost function detailed
description query including novel query processing mediators
pbr extensive experimental analysis appear ambite knoblock
ambite
query involves generating plan efficiently computes user query
relevant information sources plan composed data retrieval actions distributed information sources data manipulation operations relational algebra join selection union etc specification operators query
encoding information goals first introduced
knoblock sample information goal shown figure goal asks send
output device mediator names airports tunisia two sample
operators shown figure retrieve operator executes query remote
information source transports data mediator provided source
operation source available source capable processing query
source acceptable query join operator takes two subqueries available
locally mediator combines conditions produce joined
query


fiambite knoblock

available sims retrieve ap name
airport aport
country name aport tunisia
port name aport ap name

figure sample information goal
define operator retrieve
parameters source query
resources processor source
precondition source available source
source acceptable query query source
effect available sims query
define operator join
parameters join conds query query query b
precondition available sims query
available sims query b
join query query join conds query query b
effect available sims query

figure query operators
quality distributed query plan estimation execution cost
function size intermediate cost performing data manipulation
operations transmission network intermediate
remote sources mediator system estimates plan cost statistics
obtained source relations number tuples relation number
distinct values attribute maximum minimum values numeric
attributes silberschatz korth sudarshan chapter sources accessed
type ordering data processing operations critical plan cost
rewriting rules derived properties distributed environment
relational algebra first set rules rely fact distributed environment
generally efficient execute group operations together remote information source transmit data network execute operations
local system example consider remote join eval rule figure shown
pbr syntax shown algebraically figure rule specifies
plan exist two retrieval operations remote database whose
consequently joined remote source capable performing joins system
rewrite plan one contains single retrieve operation pushes join
remote database
second class rules derived commutative associative distributive
properties operators relational algebra example join swap rule
figure cf figure specifies two consecutive joins operators reordered
allows planner explore space join trees since query
mediators rules address resolution semantic heterogeneity necessary see
ambite knoblock ambite details



fiplanning rewriting

define rule name remote join eval
define rule name join swap
operators
operators
n retrieve query source
n join q jc sq sq b
n retrieve query source
n join q jc sq sq b
n join query jc query query
links n n
constraints
constraints
capability source join
join swappable
replace operators n n n
q jc sq sq b

operators
q jc sq sq b

n retrieve query source
q jc sq sq b

q jc sq sq b

replace operators n n
operators
n join q jc sq sq b
n join q jc sq sq b
links n n

figure query rewriting rules
domain queries expressed complex terms knoblock pbr rules use
interpreted predicates constraints field manipulate query expressions
example join swappable predicate checks queries two join operators
exchanged computes subqueries
figure shows example local search space query plan rewritings simple distributed domain describes company figure shows alternative
query evaluation plans conjunctive query asks names employees
salaries projects working three relations requested query
employees payroll project distributed among two databases one companys headquarters hq db another branch branch db assume
leftmost plan initial plan plan first retrieves employee relation hq db
project relation branch db joins two tables employee name finally plan retrieves payroll relation hq db joins
ssn previous join although valid plan initial plan suboptimal applying join swap rule initial plan generates two rewritings one
involves cross product expensive operation system following gradient descent search strategy prefers plan system applies
remote join eval rule generates rewritten plan evaluates join
employee project tables remotely headquarters database final plan
much better quality
compare efficiency plan quality four query planners
sage original query planner knoblock sims mediator
performs best first search heuristic commonly used query optimization
explores space left join trees sage refinement planner kambhampati
knoblock yang generates optimal left tree query plans
dp implementation dynamic programming bottom enumeration
query plans ono lohman optimal plan since distributed
domain subqueries execute parallel cost function reflects preference


fiambite knoblock

name sal proj emp name ssn payroll ssn sal projects name proj

hq db
emp name ssn
payroll ssn sal

name ssn

branch db
project name proj

ret emp
hq db
ret payroll ret project
hq db branch db

ssn

name

ret payroll
hq db

join
swap

name

remote
join
eval
name

ret emp ret project
hq db branch db

ssn

ret project
branch db

ret emp ret payroll
hq db hq db

ret project
branch db
ret emp
hq db

payroll

figure rewriting query
dp considers bushy join trees however improve time dp
applies heuristic avoiding cross products join enumeration thus rare
cases dp may produce optimal plan
initial initial plan generator pbr generates query plans according
random depth first search parse query non random choice places
selections soon executed fastest planner may produce
low quality plans
pbr used remote join eval join swap rules defined figure
two rules sufficient optimize queries test set tested two gradientdescent search strategies pbr first improvement four random restarts pbr
steepest descent three random restarts pbr sd
experiment compare behavior sage dp initial pbr pbr sd
distributed query domain size queries increases generated
synthetic domain sims mediator defined set conjunctive queries involving
relations queries one selection attribute table
information source contains two relations perform remote operations therefore
optimal plans involve pushing operations evaluated remotely sources
experiment shown figure figure shows
time logarithmic scale sage dp initial pbr pbr sd query size
grows times pbr include generation random initial plans
rewriting times initial average initial plan construction across
restarts query sage able solve queries involving relations larger


fiplanning rewriting

queries cannot solved within search limit partial plan nodes dp scales
better sage cannot solve queries relations second time
limit configurations pbr scale better sage dp first improvement
search strategy pbr faster steepest descent pbr sd
figure b shows cost query plans five planners cost initial
average initial plans across restarts query plan cost
estimate query execution cost logarithmic scale used increasingly
larger absolute values plan costs conjunctive chain queries high
cost initial plans pbr rewrites poor quality plans generated initial
high quality plans pbr dp produce better plans sage range
tractable sage experiment happens searching larger
space bushy query trees take greater advantage parallel execution plans pbr
produces plans quality comparable dp tractable range beyond range
pbr scales gracefully two configurations pbr produce plans similar cost though
pbr needed less time pbr sd pbr sd generates plans local
neighborhood order select cheapest one pbr generates portion
neighborhood since chooses first plan cheaper cost pbr faster
average figure shows empirically domain locally optimal moves
steepest descent translate final solutions better cost produced
first improvement strategy



e
sage
dp
initial
pbr
pbr sd



e
e



plan cost

time cpu seconds

e


sage
dp
initial
pbr
pbr sd



e
e
e













query size









time






query size







b plan quality

figure experimental distributed query

related work
section review previous work related rewriting framework
first discuss work disciplines upon pbr builds namely classical ai
local search graph rewriting discuss work related planrewriting


fiambite knoblock

ai
pbr designed balance among requirements efficiency high quality
plans flexibility extensibility great amount work ai focused
improving average case efficiency given general cases computationally hard
erol et al one possibility incorporate domain knowledge form search
control recent example tlplan bacchus kabanza forward search
planner shown remarkable scalability control knowledge expressed temporal logic systems automatically learn search control given domain
even specific instances minton b shows deduce search control rules
solver applying explanation learning solving traces
discusses impact utility utility simply stated says
computational benefits additional knowledge must outweigh cost
applying pbr plan rewriting rules subject utility quality
improvement obtained adding rewriting rules pbr planner may
worth performance degradation another automatically generating search
control analyzing statically operators etzioni inferring invariants
domain gerevini schubert fox long rintanen abstraction provides yet another form search control knoblock presents system
automatically learns abstraction hierarchies domain particular
instance order speed plan rewriting rules learned techniques
analogous used learn search control ambite knoblock minton present
automatically learn plan rewriting rules comparing initial
optimal plans example alternatively analyzing operators
combinations operators equivalent respect achievement
goals lead automatic generation rewriting rules
local search used improve efficiency although
somewhat indirect way reduced solving series propositional
satisfiability kautz selman thus kautz selman used
efficient satisfiability testing local search solve sat encodings
proved efficient specialized
believe power stems use local search
pbr directly applies local search plan structures opposed translating first
larger propositional representation
although approaches improve efficiency specifically address plan quality else consider simple cost metrics
number steps systems learn search control addresses efficiency
plan quality estlin mooney borrajo veloso perez however
reported experimental pbr appears scalable moreover pbr
provides anytime approaches must run completion
local search
local search long tradition combinatorial optimization aarts lenstra
papadimitriou steiglitz local improvement ideas found application many


fiplanning rewriting

domains general work relevant pbr constraint satisfaction
scheduling satisfiability testing heuristic search
constraint satisfaction local search techniques able solve
orders magnitude complex respective complete backtracking approaches
minton et al minton johnston philips laird minton developed simple
repair heuristic min conflicts could solve large constraint satisfaction scheduling
scheduling operations hubble space telescope minconflicts heuristic selects variable value assignment minimizes number
constraints violated heuristic used cost function gradient descent
search informed backtracking search
satisfiability testing similar method gsat introduced selman levesque
mitchell gsat solves hard satisfiability local search
repairs consist changing truth value randomly chosen variable cost function
number clauses satisfied current truth assignment scales
much better corresponding complete method davis putnam procedure
work scheduling rescheduling zweben daun deale define set
general fixed repair methods use simulated annealing search space
schedules plans networks actions opposed metric time totally ordered
tasks easily specify different rewriting rules general specific suit
domain opposed fixed strategies
work inspired approaches several differences first pbr
operates complex graph structures partial order plans opposed variable assignments second repairs declaratively specified may changed
domain opposed general fixed repair strategies third pbr accepts arbitrary measures quality constraint violations min conflicts number
unsatisfied clauses gsat finally pbr searches space valid solution plans
opposed space variable assignments may internally inconsistent
iterative repair ideas used heuristic search ratner pohl
present two phase similar pbr first phase initial valid
sequence operators approximation second phase perform
local search starting initial sequence cost function plan length
local neighborhood generated identifying segments current solution sequence
attempting optimize repair consists heuristic search initial
state beginning segment goal end segment shorter
path found original sequence replaced shorter segment significant
difference pbr state space search pbr planspace search least committed partial order nature pbr allows optimize
plans ways cannot achieved optimizing linear subsequences
graph rewriting
pbr builds ideas graph rewriting schurr plan rewriting rules
pbr extension traditional graph rewriting rules taking advantage
semantics pbr introduces partially specified plan rewriting rules
rules need specify completely detailed embedding consequent pure


fiambite knoblock

graph rewriting nevertheless several techniques transfer graph
rewriting rewriting particularly fully specified rules dorr
defines abstract machine graph isomorphism studies set conditions
traditional graph rewriting performed efficiently perhaps similar abstract
machine plan rewriting defined idea rule programs appears
field implemented progres system schurr
plan rewriting
work closely related plan rewriting plan merging foulser li
yang foulser et al provide formal analysis exploiting positive
interactions within plan across set plans however work considers
case set operators replaced one operator provides
effects rest plan consumes fewer preconditions focus
optimal approximate type operator merging plan rewriting
pbr seen generalization operator merging subplan replace
another subplan difference pbr concerned finding optimal merge
rewritten plan single pass optimization
pbr interested generating possible plan rewritings rewriting phase
optimal one optimization occurs local search progresses
case e g kambhampati veloso nebel koehler
hanks weld munoz avila solves modifying previous solution
two phases case first one identifies plan library
similar current second phase previous plan adapted
solve pbr modifies solution current
need retrieval phase associated similarity metrics plan rewriting pbr
seen type adaptation solution alternate solution
plan rewriting rule pbr identifies pair subplans
replaced replacement subplans may interchangeable
veloso describes general case derivational
analogy works three steps first retrieval phase selects similar
plan library second parts plan irrelevant current
removed finally system searches completion plan selecting much
possible decisions old plan sense knowledge
encoded previous solution transferred generation solution plan
plan rewriting partially specified rules pbr seen strongly
constrained version pbr subplan rule consequent fixes
steps added repair plan could use technique respecting
previous choice points completing plan way ensuring
structure plan repair maintained could useful
constrain number rewritten plans large rewriting rules
nebel koehler present computational analysis case
context worst case complexity plan modification better
plan generation point limitations reuse methods related
pbr framework embedding replacement subplan partially specified rules


fiplanning rewriting

explained section may pathological cases number
embeddings exponential size plan deciding embedding exists
np hard however often interested finding rewritings example
following first improvement search strategy experience average case behavior
seems much better presented section
systematic case hanks weld invert
decisions done refinement path solution similar old
rewriting rules pbr indicate transform
solution another solution plan domain knowledge opposed generic
inversion refinement operations plan rewriting pbr done constrained
way instead open search space partial plans however rules
pbr may search space rewritings non systematically effect ameliorated
local search

discussion future work
presented rewriting paradigm efficient high quality
domain independent pbr adapts graph rewriting local search techniques
semantics domain independent partial order basic idea pbr
consists transforming easy generate possibly suboptimal initial plan
high quality plan applying declarative plan rewriting rules iterative repair style
several important advantages pbr first pbr
declarative domain independent framework brings benefits reusability
extensibility second addresses sophisticated plan quality measures work
domain independent addressed quality simple ways
third pbr scalable uses efficient local search methods finally pbr
anytime allows balancing effort plan quality order
maximize utility process
rewriting provides domain independent framework local search pbr
accepts declarative domain specifications expressive operator language declarative
plan rewriting rules generate neighborhood plan complex quality metrics interchangeable initial plan generators arbitrary local search methods
rewriting well suited mixed initiative mixed initiative
user planner interact defining plan example user
specify available preferred actions moment change quality criteria interest etc fact domains approached mixed initiative
example quality metric expensive evaluate
geometric analysis manufacturing user must guide planner towards good quality
plans way small number plans generated evaluated another example
plan quality metric multi objective changes time several characteristics pbr support mixed initiative first pbr offers complete plans
user easily understand plan perform complex quality assessment second
rewriting rule language convenient mechanism user propose modifications plans third selecting rules apply order application
user guide planner


fiambite knoblock

framework achieves balance domain knowledge expressed plan rewriting
rules general local search techniques proved useful many hard combinatorial expect ideas push frontier solvable
many practical domains high quality plans anytime behavior needed
style introduced pbr opens several areas future
great potential applying machine learning techniques pbr important issue
generation plan rewriting rules conceptually plan rewriting rules arise
chosen plan equivalence relation valid plans achieve given goals finite
number steps e solution plans satisfiability equivalent rule arises
theorem states two subplans equivalent purposes achieving
goals addition conditions indicate context rule
usefully applied plan rewriting rules generated automated procedures
methods range static analysis domain operators analysis sample
equivalent plans achieve goals different costs note similarity
methods automatically infer search control domain invariants minton b
etzioni gerevini schubert fox long rintanen
need deal utility ambite knoblock minton present
learning plan rewriting rules comparing initial optimal plans
sample
beyond learning rewriting rules intend develop system automatically learn optimal planner configuration given domain
distribution manner analogous mintons multi tac system minton
system would perform search configuration space pbr planner proposing
candidate sets rewriting rules different search methods testing proposed
configuration training set simple system would hill climb
configuration space order arrive useful rewriting rules search strategies
given domain distribution
many advanced techniques local search literature adapted
extended framework particular idea variable depth rewriting leads
naturally creation rule programs specify set rules applied
plan already seen query could transformations
better specified program simple rewriting rules example sequence
join swap transformations may put two retrieve operators database together
query tree remote join eval would collapse explicit join operator
two retrieves single retrieval remote join cherniack zdonik
present complex examples sort programs rewriting rules context
query optimizer object oriented databases
discussed sections language antecedent rewriting rules expressive conjunctive queries still remaining computationally efficient example figure shows rule manufacturing domain
section relationally complete antecedent rule matches subplan contains spray paint operator contain punch drill press operators
create holes diameter smaller millimeter case rule replaces
spray paint operator immersion paint operator rule would useful
situation painting immersion could clog small holes


fiplanning rewriting

define rule name sp ip small holes
operator n spray paint x c
operator n punch x w
operator n drill press x w
less w mm
replace operators n
operator n immersion paint x c

figure rule relationally complete antecedent
another area interplay plan rewriting plan execution
sometimes best transformations plan may known portion
plan executed information obtained run time guide planner
select appropriate rewritings example query plans may contain
information gathering actions ashish knoblock levy depend run time
conditions yields form dynamic query optimization interleaved
execution necessary order deal effectively unexpected situations
environment database network failures
open area relax framework accept incomplete plans
rewriting process expands search space considerably benefits
pbr anytime property lost domains shortest path
rewritings initial plan optimal may pass incomplete inconsistent
plans idea could embodied style combines characteristics
generative rewriting reminiscent plan critics
sacerdoti sussman resulting plan rewriting rules seen
declarative specifications plan critics plan refinements partial order
kambhampati et al hierarchical task network erol nau
hendler easily specified plan rewriting rules
applying pbr domains surely provide challenges possibility
discovering transferring general techniques one domain another
hope local search methods used pbr help techniques scale
large practical conversely domain independent nature pbr
help analysis principled extension local search techniques

acknowledgments
extended version ambite knoblock
reported supported part fulbright ministerio educacion
ciencia spain scholarship part defense advanced projects agency
darpa air force laboratory air force materiel command usaf
agreement number f part national science foundation
grant number iri part rome laboratory air force systems command defense advanced projects agency darpa contract numbers f c f f f part
united states air force contract number f part
integrated media systems center national science foundation engineering


fiambite knoblock

center cooperative agreement eec u government authorized
reproduce distribute reports governmental purposes notwithstanding copyright
annotation thereon views conclusions contained herein authors
interpreted necessarily representing official policies endorsements
expressed implied organizations person connected


references
aarts e lenstra j k local search combinatorial optimization john wiley
sons chichester england
abiteboul hull r vianu v foundations databases addison wesley
ambite j l rewriting ph thesis university southern california
ambite j l knoblock c rewriting efficiently generating
high quality plans proceedings fourteenth national conference artificial
intelligence pp providence ri
ambite j l knoblock c flexible scalable cost query
mediators transformational artificial intelligence
ambite j l knoblock c minton learning plan rewriting rules
proceedings fifth international conference artificial intelligence
scheduling systems breckenridge co
ashish n knoblock c levy information gathering plans sensing
actions steel alami r eds recent advances ai th
european conference ecp springer verlag york
avenhaus j madlener k term rewriting equational reasoning formal
techniques artificial intelligence pp elsevier north holland
baader f nipkow term rewriting cambridge university
press
bacchus f kabanza f temporal logic control search forward
chaining planner proceedings rd european workshop
bacchus f kabanza f temporal logics express search control knowledge artificial intelligence
backstrom c executing parallel plans faster adding actions cohn g
ed proceedings eleventh european conference artificial intelligence pp
amsterdam netherlands john wiley sons
backstrom c b finding least constrained plans optimal parallel executions
harder thought backstrom c sandewell e eds current trends
ai proceedings nd european workshop ewsp
pp vadstena sweeden ios press amsterdam


fiplanning rewriting

backstrom c nebel b complexity sas computational
intelligence
blum l furst l fast graph analysis
proceedings fourteenth international joint conference artificial intelligence
montreal canada
blum l furst l fast graph analysis artificial
intelligence
bonet b geffner h heuristic search proceedings
fifth european conference ecp durham uk
bonet b loerincs g geffner h robust fast action selection mechanism proceedings fourteenth national conference artificial
intelligence pp providence ri
borrajo veloso lazy incremental learning control knowledge
efficiently obtaining quality plans ai review
bylander computation complexity propositional strips artificial intelligence
carbonell j g knoblock c minton prodigy integrated architecture learning vanlehn k ed architectures intelligence
pp lawrence erlbaum hillsdale nj
cherniack zdonik b rule languages internal algebras rule
optimizers sigmod record acm special interest group management data

cherniack zdonik b changing rules transformations rulebased optimizers proceedings acm sigmod international conference
management data pp seattle wa
dean boddy analysis time dependent proceedings
seventh national conference artificial intelligence pp saint paul mn
dorr h efficient graph rewriting implementation vol lecture notes
computer science springer verlag inc york ny usa
erol k nau hendler j umcp sound complete procedure
hierarchical task network proceedings second international
conference artificial intelligence systems pp chicago il
erol k nau subrahmanian v decidability undecidability
domain independent artificial intelligence
estlin mooney r j learning improve efficiency quality
proceedings fifteenth international joint conference artificial
intelligence pp nagoya japan


fiambite knoblock

etzioni acquiring search control knowledge via static analysis artificial intelligence
etzioni weld softbot interface internet communications acm
fikes r e nilsson n j strips application
theorem proving solving artificial intelligence
forgy c l rete fast many pattern many object pattern
match artificial intelligence
foulser e li yang q theory plan merging artificial
intelligence
fox long automatic inference state invariants tim journal
artificicial intelligence
gerevini schubert l inferring state constraints domain independent
proceedings fifteenth national conference artificial intelligence pp madison wi
glover f tabu searchpart orsa journal computing
gomes c p selman b kautz h boosting combinatorial search
randomization proceedings fifteenth national conference artificial intelligence madison wi
gupta n nau complexity blocks world artificial
intelligence
hanks weld domain independent plan adaptation
journal artificicial intelligence
johnson local optimization traveling salesman paterson
ed automata languages programming proc th international
colloquium pp springer york
kambhampati validation structure theory plan modification
reuse artificial intelligence
kambhampati knoblock c yang q refinement search
unified framework evaluating design tradeoffs partial order
artificial intelligence
kautz h selman b satisfiability neumann b ed proceedings th european conference artificial intelligence pp vienna
austria john wiley sons


fiplanning rewriting

kautz h selman b pushing envelope propositional logic
stochastic search proceedings thirteenth national conference artificial
intelligence pp portland
kirkpatrick gelatt c vecchi p optimization simulated annealing
science
knoblock c automatically generating abstractions artificial
intelligence
knoblock c b generating parallel execution plans partial order planner proceedings second international conference artificial intelligence
systems chicago il
knoblock c executing sensing replanning information gathering proceedings fourteenth international joint conference artificial
intelligence montreal canada
knoblock c building planner information gathering report
trenches proceedings third international conference artificial intelligence systems edinburgh scotland
koehler j solving complex tasks extraction subproblems
simmons r veloso smith eds proceedings fourth international
conference artificial intelligence systems pp pittsburgh pa
koehler j hoffmann j reasonable forced goal orderings use
agenda driven journal artificial intelligence

koehler j nebel b hoffman j dimopoulos extending graphs
adl subset steel alami r eds proceedings fourth european
conference ecp recent advances ai vol
lnai pp berlin springer
mcallester rosenblitt systematic nonlinear proceedings
ninth national conference artificial intelligence anaheim ca
minton learning effective search control knowledge explanation
ph thesis computer science department carnegie mellon university
minton b learning search control knowledge explanation
kluwer boston
minton minimizing conflicts heuristic repair method constraintsatisfaction scheduling artificial intelligence
minton automatically configuring constraint satisfaction programs case
study constraints


fiambite knoblock

minton johnston philips b laird p solving large scale constraint satisfaction scheduling heuristic repair method proceedings eighth national conference artificial intelligence pp boston

munoz avila h integrating twofold case retrieval complete decision replay
caplan cbc ph thesis university kaiserslautern
nau gupta k regli w c ai versus manufacturingoperation case study proceedings fourteenth international
joint conference artificial intelligence montreal canada
nebel b koehler j plan reuse versus plan generation theoretical
empirical analysis artificial intelligence
ono k lohman g measuring complexity join enumeration query
optimization mcleod sacks davis r schek h j eds th international conference large data bases pp brisbane queensland
australia morgan kaufmann
papadimitriou c h steiglitz k complexity local search
traveling salesman siam
papadimitriou c h steiglitz k combinatorial optimization
complexity prentice hall englewood cliffs nj
penberthy j weld ucpop sound complete partial order planner
adl third international conference principles knowledge representation
reasoning pp cambridge
perez representing learning quality improving search control knowledge
proceedings thirteenth international conference machine learning bari
italy
ratner pohl joint lpa combination approximation search
proceedings fifth national conference artificial intelligence philadelphia
pa
rintanen j iterative synthesizing invariants proceedings
seventeenth national conference artificial intelligence austin tx
russell norvig p artificial intelligence modern prentice hall
sacerdoti e nonlinear nature plans proceedings fourth
international joint conference artificial intelligence pp tbilisi georgia
ussr
savage weiner p bagchi neighborhood search guaranteeing optimal traveling salesman tours must inefficient journal computer
system sciences


fiplanning rewriting

schurr introduction progres attribute graph grammar specification language nagl ed graph theoretic concepts computer science
vol lecture notes computer science pp
schurr programmed graph replacement systems rozenberg g ed
handbook graph grammars foundations vol pp world scientific
singapore
sellis k multiple query optimization acm transactions database systems

selman b levesque h mitchell method solving hard satisfiability
proceedings tenth national conference artificial intelligence
aaai pp san jose california aaai press
silberschatz korth h f sudarshan database system concepts third
edition mcgraw hill
simon h sciences artificial mit press
slaney j thiebaux linear time near optimal blocks world
proceedings thirteenth national conference artificial intelligence
eighth innovative applications artificial intelligence conference pp
menlo park aaai press mit press
sussman g j computer model skill acquisition american elsevier
york
veloso learning analogical reasoning springer verlag
veloso perez carbonell j g nonlinear parallel
resource allocation proceedings workshop innovative approaches
scheduling control pp san diego ca
weld introduction least commitment ai magazine
weld recent advances ai ai magazine
yu c chang c distributed query processing acm computing surveys

zweben daun b deale scheduling rescheduling iterative
repair intelligent scheduling pp morgan kaufman san mateo ca




