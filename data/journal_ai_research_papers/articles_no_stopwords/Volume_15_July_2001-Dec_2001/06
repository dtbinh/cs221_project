Journal Artificial Intelligence Research 15 (2001) 207-261

Submitted 5/00; published 9/01

Planning Rewriting
Jose Luis Ambite
Craig A. Knoblock

ambite@isi.edu
knoblock@isi.edu

Information Sciences Institute Department Computer Science,
University Southern California,
4676 Admiralty Way, Marina del Rey, CA 90292, USA

Abstract
Domain-independent planning hard combinatorial problem. Taking account
plan quality makes task even difficult. article introduces Planning Rewriting (PbR), new paradigm efficient high-quality domain-independent planning. PbR
exploits declarative plan-rewriting rules efficient local search techniques transform
easy-to-generate, possibly suboptimal, initial plan high-quality plan. addition addressing issues planning efficiency plan quality, framework offers
new anytime planning algorithm. implemented planner applied
several existing domains. experimental results show PbR approach provides
significant savings planning effort generating high-quality plans.

1. Introduction

Planning process generating network actions, plan, achieves desired
goal initial state world. Many problems practical importance
cast planning problems. Instead crafting individual planner solve specific
problem, long line research focused constructing domain-independent planning
algorithms. Domain-independent planning accepts input, descriptions
initial state goal particular problem instance, declarative domain
specification, is, set actions change properties state. Domainindependent planning makes development planning algorithms efficient, allows
software domain reuse, facilitates principled extension capabilities
planner. Unfortunately, domain-independent planning (like planning problems)
computationally hard (Bylander, 1994; Erol, Nau, & Subrahmanian, 1995; Backstrom
& Nebel, 1995). Given complexity limitations, previous work domainindependent planning focused finding solution plan without careful consideration
plan quality. Usually simple cost functions, length plan,
used. However, many practical problems plan quality crucial. paper
present new planning paradigm, Planning Rewriting (PbR), addresses
planning efficiency plan quality maintaining benefits domain independence.
framework fully implemented present empirical results several planning
domains.
c
2001
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiAmbite & Knoblock

1.1 Solution Approach
Two observations guided present work. first one two sources
complexity planning:
Satisfiability: difficulty finding solution planning problem (regardless
quality solution).
Optimization: difficulty finding optimal solution given cost metric.
given domain, facets may contribute differently complexity
planning. particular, many domains satisfiability problem
relatively easy complexity dominated optimization problem. example,
may many plans would solve problem, finding one efficient
practice, cost solution varies greatly, thus finding optimal one
computationally hard. refer domains optimization domains.
optimization domains great practical interest query optimization manufacturing
process planning.1
second observation planning problems great deal structure. Plans
type graph strong semantics, determined general properties
planning particular domain specification. structure
exploited improve efficiency planning process.
Prompted previous observations, developed novel approach efficient
planning optimization domains: Planning Rewriting (PbR). framework works
two phases:
1. Generate initial solution plan. Recall optimization domains efficient.
However, quality initial plan may far optimal.
2. Iteratively rewrite current solution plan improving quality using set declarative plan-rewriting rules, either acceptable solution found resource
limit reached.
motivation, consider optimization domains distributed query processing
manufacturing process planning.2 Distributed query processing (Yu & Chang, 1984) involves generating plan efficiently computes user query data resides
different nodes network. query plan composed data retrieval actions diverse
information sources operations data (such relational algebra:
join, selection, etc). systems use general-purpose planner solve problem
(Knoblock, 1996). domain easy construct initial plan (any parse
query suffices) transform using gradient-descent search reduce cost.
plan transformations exploit commutative associative properties (relational algebra) operators, facts group operators executed
together remote information source generally efficient so. Figure 1
1. Interestingly, one widely studied planning domains, Blocks World, property.
2. domains analyzed Section 4. Graphical examples rewriting process appear Figure 30
query planning Figure 21 manufacturing process planning. reader may want consult
figures even details explained point.

208

fiPlanning Rewriting

shows sample transformations. Simple-join-swap transforms two join trees according commutative associative properties join operator. Remote-join-eval
executes join two subqueries remote source, source able so.
Simple-Join-Swap:
retrieve(Q1, Source1) 1 [retrieve(Q2, Source2) 1 retrieve(Q3, Source3)]
retrieve(Q2, Source2) 1 [retrieve(Q1, Source1) 1 retrieve(Q3, Source3)]
Remote-Join-Eval:
(retrieve(Q1, Source) 1 retrieve(Q2, Source)) capability(Source, join)
retrieve(Q1 1 Q2, Source)
Figure 1: Transformations Query Planning
manufacturing, problem find economical plan machining operations
implement desired features design. feature-based approach (Nau, Gupta,
& Regli, 1995), possible enumerate actions involved building piece
analyzing CAD model. difficult find ordering operations
setups optimize machining cost. However, similar query planning, possible
incrementally transform (possibly inefficient) initial plan. Often, order actions
affect design goal, quality plan, thus many actions commute.
Also, important minimize number setups fixing piece machine
rather time consuming operation. Interestingly, grouping machining operations
setup analogous evaluating subquery remote information source.
suggested examples, many problems combine characteristics traditional planning satisfiability quality optimization. domains
often exist natural transformations may used efficiently obtain high-quality plans
iterative rewriting. Planning Rewriting provides domain-independent framework
allows plan transformations conveniently specified declarative plan-rewriting
rules facilitates exploration efficient (local) search techniques.
1.2 Advantages Planning Rewriting
several advantages planning style PbR introduces. First, PbR
declarative domain-independent framework. facilitates specification planning
domains, evolution, principled extension planner new capabilities. Moreover, declarative rewriting rule language provides natural convenient
mechanism specify complex plan transformations.
Second, PbR accepts sophisticated quality measures operates complete
plans. previous planning approaches either addressed quality issues
simple quality measures, number steps plan, partial
plans available planning process. general, partial plan cannot offer
enough information evaluate complex cost metric and/or guide planning search
effectively.
209

fiAmbite & Knoblock

Third, PbR use local search methods remarkably successful scaling
large problems (Aarts & Lenstra, 1997).3 using local search techniques, high-quality
plans efficiently generated. Fourth, search occurs space solution plans,
generally much smaller space partial plans explored planners based
refinement search.
Fifth, framework yields anytime planning algorithm (Dean & Boddy, 1988).
planner always solution offer point computation (modulo initial
plan generation needs fast). clear advantage traditional planning
approaches, must run completion producing solution. Thus, system
allows possibility trading planning effort plan quality. example, query
planning quality plan execution time may make sense keep
planning cost current plan small enough, even cheaper one could
found. discussion concrete examples advantages given throughout
following sections.
1.3 Contributions
main contribution paper development Planning Rewriting, novel
domain-independent paradigm efficient high-quality planning. First, define language declarative plan-rewriting rules present algorithms domain-independent
plan rewriting. rewriting rules provide natural convenient mechanism specify complex plan transformations. techniques plan rewriting generalize traditional
graph rewriting. Graph rewriting rules need specify rule consequent complete
embedding replacement subplan. introduce novel class partially-specified
plan-rewriting rules relax restriction. taking advantage semantics
planning, embedding automatically computed. single partially-specified rule
concisely represent great number fully-specified rules. rules easier
write understand fully-specified counterparts. Second, adapt local
search techniques, gradient descent, efficiently explore space plan rewritings optimize plan quality. Finally, demonstrate empirically usefulness
PbR approach several planning domains.
1.4 Outline
remainder paper structured follows. Section 2 provides background
planning, rewriting, local search, fields upon PbR builds. Section 3
presents basic framework Planning Rewriting domain-independent approach
local search. section describes detail plan rewriting declarative rewriting rule
language. Section 4 describes several application domains shows experimental results
comparing PbR planners. Section 5 reviews related work. Finally, Section 6
summarizes contributions paper discusses future work.
3. Although space rewritings explored complete search methods, application domains
analyzed search space large experience suggests local search
appropriate. However, extent complete search methods useful Planning Rewriting
framework remains open issue. paper focus local search.

210

fiPlanning Rewriting

2. Preliminaries: Planning, Rewriting, Local Search
framework Planning Rewriting arises confluence several areas research, namely, artificial intelligence planning algorithms, graph rewriting, local search
techniques. section give background areas explain
relate PbR.
2.1 AI Planning
assume reader familiar classical AI planning, section
highlight main concepts relate PbR framework. Weld (1994, 1999)
Russell & Norvig (1995) provide excellent introductions AI planning.
PbR follows classical AI planning representation actions transform state.
state set ground propositions understood conjunctive formula. PbR,
AI planners, follows Closed World Assumption, is, proposition explicitly
mentioned state assumed false, similarly negation failure semantics
logic programming. propositions state modified, asserted negated,
actions domain. actions domain specified operator schemas.
operator schema consists two logical formulas: precondition, defines
conditions operator may applied, postcondition, specifies
changes state effected operator. Propositions mentioned
postcondition assumed change application operator. type
representation initially introduced STRIPS system (Fikes & Nilsson, 1971).
language operators PbR Sage (Knoblock, 1995, 1994b),
extension UCPOP (Penberthy & Weld, 1992). operator description
language PbR accepts arbitrary function-free first-order formulas preconditions
operators, conditional universally quantified effects (but disjunctive effects).
addition, operators specify resources use. Sage PbR address unit
non-consumable resources. resources fully acquired operator
completion action released reused.
Figure 2 shows sample operator schema specification simple Blocks World
domain,4 representation accepted PbR. domain two actions: stack,
puts one block top another, unstack, places block table.5
state described two predicates: (on ?x ?y)6 denotes block ?x top
another block ?y (or Table), (clear ?x) denotes ?x block
block top it.
example complex operator process manufacturing domain shown
Figure 3. operator describes behavior punch, machine used
make holes parts. punch operation requires available clamp
machine orientation width hole appropriate using punch.
executing operation part desired hole
4. illustrate basic concepts planning, use examples simple Blocks World domain.
reader find real-world application planning techniques, query planning, Section 4.4.
5. (stack ?x ?y ?z) read stack block ?x top block ?y ?z.
(unstack ?x ?y) read lift block ?x top block ?y put Table.
6. convention, variables preceded question mark symbol (?), ?x.

211

fiAmbite & Knoblock

(define (operator STACK)
:parameters (?X ?Y ?Z)
:precondition
(:and (on ?X ?Z) (clear ?X) (clear ?Y)
(:neq ?Y ?Z) (:neq ?X ?Z) (:neq ?X ?Y)
(:neq ?X Table) (:neq ?Y Table))
:effect (:and (on ?X ?Y) (:not (on ?X ?Z))
(clear ?Z) (:not (clear ?Y))))

(define (operator UNSTACK)
:parameters (?X ?Y)
:precondition
(:and (on ?X ?Y) (clear ?X) (:neq ?X ?Y)
(:neq ?X Table) (:neq ?Y Table))
:effect (:and (on ?X Table) (clear ?Y)
(:not (on ?X ?Y))))

Figure 2: Blocks World Operators
(define (operator PUNCH)
:parameters (?x ?width ?orientation)
:resources ((machine PUNCH) (is-object ?x))
:precondition (:and (is-object ?x)
(is-punchable ?x ?width ?orientation)
(has-clamp PUNCH))
:effect (:and (:forall (?surf) (:when (:neq ?surf ROUGH)
(:not (surface-condition ?x ?surf))))
(surface-condition ?x ROUGH)
(has-hole ?x ?width ?orientation)))

Figure 3: Manufacturing Operator
rough surface.7 Note specification resources slot. Declaring (machine PUNCH)
resource enforces operator use punch concurrently. Similarly,
declaring part, (is-object ?x), resource means one operation time
performed object. examples operator specifications appear
Figures 18, 19, 28.
plan PbR represented graph, spirit partial-order causal-link planners (POCL) UCPOP (Penberthy & Weld, 1992). nodes plan steps,
is, instantiated domain operators. edges specify temporal ordering relation among
steps imposed causal links ordering constraints. causal link record
proposition established plan. record contains proposition (sometimes
called condition), producer step, consumer step. producer step
plan asserts proposition, is, proposition one effects. consumer
step needs proposition, is, proposition one preconditions.
causality, producer must precede consumer.
ordering constraints needed ensure plan consistent. arise
resolving operator threats resource conflicts. operator threat occurs
step negates condition causal link ordered producer
consumer steps causal link. prevent situation, makes plan inconsistent, POCL planners order threatening step either producer (demotion)
consumer (promotion) posting appropriate ordering constraints.
7. operator uses idiom combining universal quantification negated conditional effects enforce
attribute surface-condition part single-valued.

212

fiPlanning Rewriting

unit non-consumable resources considered, steps requiring resource
sequentially ordered, chain ordering constraints appear plan.
example plan Blocks World using graph representation given
Figure 4. plan transforms initial state consisting two towers: C A,
Table, B D, Table; final state consisting one tower: B, B C,
C D, Table. initial state represented step 0 preconditions
propositions initial state postconditions. Similarly, goal state
represented step goal postconditions goal formula precondition.
plan achieves goal using two unstack steps disassemble two initial towers
using three stack steps build desired tower. causal links shown
solid arrows ordering constraints dashed arrows. additional effects step
used causal links, sometimes called side effects, shown step
pointed thin dashed arrows. Negated propositions preceded . Note need
ordering link steps 2, stack(B C Table), 3, stack(A B Table).
step 3 could ordered concurrently step 2, would negate precondition
clear(B) step 2, making plan inconsistent. similar situation occurs steps
1 2 another ordering link introduced.

clear(B)

Causal Link
Ordering Constraint
Side Effect

on(A Table)
on(C A)

clear(A)

3 STACK(A B Table)

4 UNSTACK(C A)
on(C Table)

on(C A)
clear(C)
on(D Table)

on(A Table)
clear(B)

clear(C)

0
clear(B)

on(B Table)
on(A B)
clear(C)
2 STACK(B C Table)
on(B C)
on(C D)
1 STACK(C Table)
GOAL
clear(D)
on(C Table)
clear(D)


on(B D)

B

on(B Table)
5 UNSTACK(B D)
on(B D)
clear(B)

C

B

C







clear(C)
Initial State

Goal State

Figure 4: Sample Plan Blocks World Domain

2.2 Rewriting
Plan rewriting PbR related term graph rewriting. Term rewriting originated
context equational theories reduction normal forms effective way
perform deduction (Avenhaus & Madlener, 1990; Baader & Nipkow, 1998). rewrite
system specified set rules. rule corresponds preferred direction
equivalence theorem. main issue term rewriting systems convergence, is,
two arbitrary terms rewritten finite number steps unique normal form.
PbR two plans considered equivalent solutions problem,
213

fiAmbite & Knoblock

although may differ cost operators (that is, equivalent
respect satisfiability introduced above). However, interested using
rewriting rules prove equivalence. Instead, framework uses rewriting
rules explore space solution plans.
Graph rewriting, akin term rewriting, refers process replacing subgraph
given graph, conditions satisfied, another subgraph. Graph rewriting
found broad applications, high-level programming languages, database
data description query languages, etc. Schurr (1997) presents good survey.
main drawback general graph rewriting complexity. graph matching
reduced (sub)graph isomorphism problem NP-complete. Nevertheless,
restrictions graph rewriting performed efficiently (Dorr, 1995).
Planning Rewriting adapts general graph rewriting semantics partial-order
planning STRIPS-like operator representation. plan-rewriting rule PbR specifies
replacement, certain conditions, subplan another subplan. However,
formalism rule need specify completely detailed embedding
consequent graph rewriting systems. consistent embeddings rule consequent,
generation edges necessary, automatically computed according
semantics partial-order planning. algorithm ensures rewritten plans always
remain valid (Section 3.1.3). plan-rewriting rules intended explore space
solution plans reach high-quality plans.
2.3 Local Search Combinatorial Optimization
PbR inspired local search techniques used combinatorial optimization.
instance combinatorial optimization problem consists set feasible solutions
cost function solutions. problem consists finding solution optimal
cost among feasible solutions. Generally problems addressed computationally
intractable, thus approximation algorithms used. One class approximation
algorithms surprisingly successful spite simplicity local search
methods (Aarts & Lenstra, 1997; Papadimitriou & Steiglitz, 1982).
Local search based concept neighborhood. neighborhood solution
p set solutions sense close p, example
easily computed p share significant amount structure p.
neighborhood generating function may, may not, able generate optimal
solution. neighborhood function generate global optima, starting
initial feasible point, called exact (Papadimitriou & Steiglitz, 1982, page 10).
Local search seen walk directed graph whose vertices solutions
points whose arcs connect neighboring points. neighborhood generating function
determines properties graph. particular, graph disconnected,
neighborhood exact since exist feasible points would lead local optima
global optima. PbR points solution plans neighbors plan
plans generated application set declarative plan rewriting rules.
basic version local search iterative improvement. Iterative improvement starts
initial solution searches neighborhood solution lower cost solution. solution found, replaces current solution search continues.
214

fiPlanning Rewriting

Otherwise, algorithm returns locally optimal solution. Figure 5(a) shows graphical
depiction basic iterative improvement. several variations basic algorithm. First improvement generates neighborhood incrementally selects first
solution better cost current one. Best improvement generates complete
neighborhood selects best solution within neighborhood.

Neighborhood

Local Optima

Local Optima

(a) Basic Iterative Improvement

(b) Variable-Depth Search

Figure 5: Local Search
Basic iterative improvement obtains local optima, necessarily global optimum.
One way improve quality solution restart search several initial points choose best local optima reached them. advanced
algorithms, variable-depth search, simulated annealing tabu search, attempt
minimize probability stuck low-quality local optimum.
Variable-depth search based applying sequence steps opposed one
step iteration. Moreover, length sequence may change iteration
iteration. way system overcomes small cost increases eventually lead
strong cost reductions. Figure 5(b) shows graphical depiction variable-depth search.
Simulated annealing (Kirkpatrick, Gelatt, & Vecchi, 1983) selects next point randomly. lower cost solution chosen, selected. solution higher cost
chosen, still selected probability. probability decreased algorithm progresses (analogously temperature physical annealing). function
governs behavior acceptance probability called cooling schedule.
proven simulated annealing converges asymptotically optimal solution. Unfortunately, convergence requires exponential time. So, practice, simulated annealing
used faster cooling schedules (not guaranteed converge optimal) thus
behaves approximation algorithm.
Tabu search (Glover, 1989) accept cost-increasing neighbors. next solution
randomly chosen legal neighbor even cost worse current solution.
neighbor legal limited-size tabu list. dynamically updated tabu list
prevents solution points considered period time. intuition
decide consider solution higher cost least lie
unexplored part space. mechanism forces exploration solution space
local minima.
Finally, stress appeal local search relies simplicity good
average-case behavior. could expected, number negative worst-case results. example, traveling salesman problem known exact neighborhoods,
215

fiAmbite & Knoblock

depend problem instance, must exponential size (Savage, Weiner,
& Bagchi, 1976). Moreover, improving move neighborhoods cannot found
polynomial time unless P = NP (Papadimitriou & Steiglitz, 1977). Nevertheless, best
approximation algorithm traveling salesman problem local search algorithm
(Johnson, 1990).

3. Planning Rewriting Local Search
Planning Rewriting viewed domain-independent framework local search.
PbR accepts arbitrary domain specifications, declarative plan-rewriting rules generate
neighborhood plan, arbitrary (local) search methods. Therefore, assuming
given combinatorial problem encoded planning problem, PbR take
input experiment different neighborhoods search methods.
describe main issues Planning Rewriting instantiation
local search idea typical combinatorial optimization algorithms:
Selection initial feasible point: PbR phase consists efficiently generating
initial solution plan.
Generation local neighborhood : PbR neighborhood plan set
plans obtained application set declarative plan-rewriting rules.
Cost function minimize: measure plan quality planner
optimizing. plan quality function range simple domain-independent
cost metric, number steps, complex domain-specific ones,
query evaluation cost total manufacturing time set parts.
Selection next point: PbR, consists deciding solution plan
consider next. choice determines global space explored
significant impact efficiency planning. variety local search strategies
used PbR, steepest descent, simulated annealing, etc. search
method yields best results may domain problem specific.
following subsections expand issues. First, discuss use
declarative rewriting rules generate local neighborhood plan, constitutes
main contribution paper. present syntax semantics rules,
plan-rewriting algorithm, formal properties complexity analysis plan rewriting,
rule taxonomy. Second, address selection next plan associated
search techniques plan optimization. Third, discuss measures plan quality.
Finally, describe approaches initial plan generation.
3.1 Local Neighborhood Generation: Plan-Rewriting Rules
neighborhood solution plan generated application set declarative
plan-rewriting rules. rules embody domain-specific knowledge transformations solution plan likely result higher-quality solutions. application
given rule may produce one several rewritten plans fail produce plan,
rewritten plans guaranteed valid solutions. First, describe syntax
216

fiPlanning Rewriting

semantics rules. Second, introduce two approaches rule specification. Third,
present rewriting algorithm, formal properties, complexity plan rewriting.
Finally, present taxonomy plan-rewriting rules.
3.1.1 Plan-Rewriting Rules: Syntax Semantics
First, introduce rule syntax semantics examples. Then, provide
formal description. plan-rewriting rule three components: (1) antecedent (:if
field) specifies subplan matched; (2) :replace field identifies subplan
going removed, subset steps links antecedent; (3) :with field
specifies replacement subplan. Figure 6 shows two rewriting rules Blocks World
domain introduced Figure 2. Intuitively, rule avoid-move-twice says that, whenever
possible, better stack block top another directly, rather first moving
table. situation occurs plans generated simple algorithm first
puts blocks table build desired towers, plan Figure 4.
rule avoid-undo says actions moving block table back
original position cancel could removed plan.
(define-rule :name avoid-move-twice
:if (:operators ((?n1 (unstack ?b1 ?b2))
(?n2 (stack ?b1 ?b3 Table)))
:links (?n1 (on ?b1 Table) ?n2)
:constraints ((possibly-adjacent ?n1 ?n2)
(:neq ?b2 ?b3)))
:replace (:operators (?n1 ?n2))
:with (:operators (?n3 (stack ?b1 ?b3 ?b2))))

(define-rule :name avoid-undo
:if (:operators
((?n1 (unstack ?b1 ?b2))
(?n2 (stack ?b1 ?b2 Table)))
:constraints
((possibly-adjacent ?n1 ?n2))
:replace (:operators (?n1 ?n2))
:with NIL))

Figure 6: Blocks World Rewriting Rules
rule manufacturing domain (Minton, 1988b) shown Figure 7.
domain additional rewriting rules described detail Section 4.1. rule states
plan includes two consecutive punching operations order make holes two
different objects, another machine, drill-press, available, plan quality may
improved replacing one punch operations drill-press. domain
plan quality (parallel) time manufacture parts. rule helps parallelize
plan thus improve plan quality.
(define-rule :name punch-by-drill-press
:if (:operators ((?n1 (punch ?o1 ?width1 ?orientation1))
(?n2 (punch ?o2 ?width2 ?orientation2)))
:links (?n1 ?n2)
:constraints ((:neq ?o1 ?o2)
(possibly-adjacent ?n1 ?n2)))
:replace (:operators (?n1))
:with (:operators (?n3 (drill-press ?o1 ?width1 ?orientation1))))

Figure 7: Manufacturing Process Planning Rewriting Rule
217

fiAmbite & Knoblock

plan-rewriting rule syntax described BNF specification given Figure 8.
BNF generates rules follow template shown Figure 9. Next, describe
semantics three components rule (:if, :replace, :with fields) detail.
<rule> ::= (define-rule :name <name>
:if (<graph-spec-with-constraints>)
:replace (<graph-spec>)
:with (<graph-spec>))
<graph-spec-with-constraints> ::= {<graph-spec>}
{:constraints (<constraints>)}
<graph-spec> ::= {:operators (<nodes>)}
{:links (<edges>)} | NIL
<nodes> ::= <node> | <node> <nodes>
<edges> ::= <edge> | <edge> <edges>
<constraints> ::= <constraint> | <constraint> <constraints>
<node> ::= (<node-var> {<node-predicate>} {:resource})
<edge> ::= (<node-var> <node-var>) |
(<node-var> <edge-predicate> <node-var>) |
(<node-var> :threat <node-var>)
<constraint> ::= <interpreted-predicate> |
(:neq <pred-var> <pred-var>)
<node-var> <pred-var> = , {} = optional, | = alternative

Figure 8: BNF Rewriting Rules

(define-rule :name <rule-name>
:if (:operators ((<nv> <np> {:resource}) ...)
:links ((<nv> {<lp>|:threat} <nv>) ...)
:constraints (<ip> ...))
:replace (:operators (<nv> ...)
:links ((<nv> {<lp>|:threat} <nv>) ...))
:with (:operators ((<nv> <np> {:resource}) ...)
:links ((<nv> {<lp>} <nv>) ...)))
<nv> = node variable, <np> = node predicate, {} = optional
<lp> = causal link predicate, <ip> = interpreted predicate,

| = alternative

Figure 9: Rewriting Rule Template
antecedent, :if field, specifies subplan matched current
plan. graph structure subplan defined :operators :links fields.
:operators field specifies nodes (operators) graph :links field
specifies edges (causal ordering links). Finally, :constraints field specifies
set constraints operators links must satisfy.
:operators field consists list node variable node predicate pairs.
step number steps plan match given node predicate would
correspondingly bound node variable. node predicate interpreted
two ways: step action, resource used step. example, node
specification (?n2 (stack ?b1 ?b3 Table)) antecedent avoid-move-twice
Figure 6 shows node predicate denotes step action. node specification
collect tuples, composed step number ?n2 blocks ?b1 ?b3, obtained matching
steps whose action stack block ?b1 Table moved top
another block ?b3. node specification applied plan Figure 4 would result
218

fiPlanning Rewriting

three matches: (1 C D), (2 B C), (3 B), variables (?n2 ?b1 ?b3) respectively.
optional keyword :resource present, node predicate interpreted one
resources used plan step, opposed describing step action. example
rule matches resources operator given Figure 10, node
specification (?n1 (machine ?x) :resource) match steps use resource
type machine collect pairs step number ?n1 machine object ?x.
(define-rule :name resource-swap
:if (:operators ((?n1 (machine ?x) :resource)
(?n2 (machine ?x) :resource))
:links ((?n1 :threat ?n2)))
:replace (:links (?n1 ?n2))
:with (:links (?n2 ?n1)))

Figure 10: Resource-Swap Rewriting Rule
:links field consists list link specifications. language admits link
specifications three types. first type specified pair node variables.
example, (?n1 ?n2) Figure 7. specification matches temporal ordering link
plan, regardless imposed causal links resolution threats.
second type link specification matches causal links. Causal links specified
triples composed producer step node variable, edge predicate, consumer
step node variable. semantics causal link producer step asserts
effects predicate, turn needed preconditions consumer step.
example, link specification (?n1 (on ?b1 Table) ?n2) Figure 6 matches steps ?n1
put block ?b1 Table steps ?n2 subsequently pick block.
link specification applied plan Figure 4 would result matches: (4 C 1)
(5 B 2), variables (?n1 ?b1 ?n2).
third type link specification matches ordering links originating resolution
threats (coming either resource conflicts operator conflicts). links
selected using keyword :threat place condition. example,
resource-swap rule Figure 10 uses link specification (?n1 :threat ?n2) ensure
steps ordered involved threat situation matched.
helps identify critical steps reasons (i.e.
causal links) order, therefore rule may attempt reorder them.
useful plan quality depends degree parallelism plan
different ordering may help parallelize plan. Recall threats solved either
promotion demotion, reverse ordering may produce valid plan,
often case conflict among resources rule Figure 10.
Interpreted predicates, built-in user-defined, specified :constraints
field. predicates implemented programmatically opposed obtained
matching components plan. built-in predicates currently implemented
inequality8 (:neq), comparison (< <= > >=), arithmetic (+ - * /) predicates.
user add arbitrary predicates corresponding programmatic implementa8. Equality denoted sharing variables rule specification.

219

fiAmbite & Knoblock

tions. interpreted predicates may act filters previous variables introduce
new variables (and compute new values them). example, user-defined predicate
possibly-adjacent rules Figure 6 ensures steps consecutive
linearization plan.9 plan Figure 4 extension possibly-adjacent
predicate is: (0 4), (0 5), (4 5), (5 4), (4 1), (5 1), (1 2), (2 3), (3 Goal).
user easily add interpreted predicates including function definition
implements predicate. rule matching algorithm passes arguments calls
functions appropriate. current plan passed default first argument
interpreted predicates order provide context computation predicate
(but ignored). Figure 11 show skeleton (Lisp) implementation
possibly-adjacent less-than interpreted predicates.
(defun possibly-adjacent (plan node1 node2)
(not (necessarily-not-adjacent
node1
node2
;; accesses current plan
(plan-ordering plan)))

(defun less-than (plan n1 n2)
(declare (ignore plan))
(when (and (numberp n1) (numberp n2))
(if (< n1 n2)
(nil) ;; true
nil))) ;; false

Figure 11: Sample Implementation Interpreted Predicates
consequent composed :replace :with fields. :replace field
specifies subplan going removed plan, subset
steps links identified antecedent. step removed, links refer
step removed. :with field specifies replacement subplan.
see Sections 3.1.2 3.1.3, replacement subplan need completely
specified. example, :with field avoid-move-twice rule Figure 6
specifies addition stack step step embedded plan.
links rest plan automatically computed rewriting process.
3.1.2 Plan-Rewriting Rules: Full versus Partial Specification
PbR gives user total flexibility defining rewriting rules. section describe two
approaches guaranteeing rewriting rule specification preserves plan correctness,
is, produces valid rewritten plan applied valid plan.
full-specification approach rule specifies steps links involved
rewriting. rule antecedent identifies anchoring points operators
consequent, embedding replacement subplan unambiguous results
valid plan. burden proving rule correct lies upon user automated
rule defining procedure (cf. Section 6). kind rules ones typically used
graph rewriting systems (Schurr, 1997).
partial-specification approach rule defines operators links constitute gist plan transformation, rule prescribe precise
9. interpreted predicate possibly-adjacent makes link expression antecedent avoid-move-twice redundant. Unstack puts block ?b1 table picked
stack operator, thus causal link (?n1 (on ?b1 Table) ?n2) already implied :operators
:constraints specification could removed rule specification.

220

fiPlanning Rewriting

embedding replacement subplan. burden producing valid plan lies upon
system. PbR takes advantage semantics domain-independent planning accept
relaxed rule specification, fill details, produce valid rewritten plan.
Moreover, user free specify rules may necessarily able compute
rewriting plan matches antecedent necessary condition
checked antecedent. is, partially-specified rule may overgeneral.
may seem undesirable, often rule may cover useful cases naturally
specified form. rule may fail rarely occurring plans, effort
defining matching complete specification may worthwhile. case,
plan-rewriting algorithm ensures application rewriting rule either generates
valid plan fails produce plan (Theorem 1, Section 3.1.3).
example two approaches rule specification, consider Figure 12
shows avoid-move-twice-full rule, fully-specified version avoid-move-twice
rule (of Figure 6, reprinted convenience). avoid-move-twice-full rule
complex less natural specify avoid-move-twice. But, importantly,
avoid-move-twice-full making commitments avoid-move-twice. particular, avoid-move-twice-full fixes producer (clear ?b1) ?n3 ?n4
?n7 known valid candidate. general, several alternative producers
precondition replacement subplan, consequently many possible embeddings.
different fully-specified rule needed capture embedding. number rules
grows exponentially permutations embeddings enumerated. However,
using partial-specification approach express general plan transformation
single natural rule.
(define-rule :name avoid-move-twice-full
:if (:operators ((?n1 (unstack ?b1 ?b2))
(?n2 (stack ?b1 ?b3 Table)))
:links ((?n4 (clear ?b1) ?n1)
(?n5 (on ?b1 ?b2) ?n1)
(?n1 (clear ?b2) ?n6)
(?n1 (on ?b1 Table) ?n2)
(?n7 (clear ?b1) ?n2)
(?n8 (clear ?b3) ?n2)
(?n2 (on ?b1 ?b3) ?n9))
:constraints ((possibly-adjacent ?n1 ?n2)
(:neq ?b2 ?b3)))
:replace (:operators (?n1 ?n2))
:with (:operators ((?n3 (stack ?b1 ?b3 ?b2)))
:links ((?n4 (clear ?b1) ?n3)
(?n8 (clear ?b3) ?n3)
(?n5 (on ?b1 ?b2) ?n3)
(?n3 (on ?b1 ?b3) ?n9))))

(define-rule :name avoid-move-twice
:if (:operators
((?n1 (unstack ?b1 ?b2))
(?n2 (stack ?b1 ?b3 Table)))
:links (?n1 (on ?b1 Table) ?n2)
:constraints
((possibly-adjacent ?n1 ?n2)
(:neq ?b2 ?b3)))
:replace (:operators (?n1 ?n2))
:with (:operators
(?n3 (stack ?b1 ?b3 ?b2))))

Figure 12: Fully-specified versus Partially-specified Rewriting Rule
summary, main advantage full-specification rules rewriting
performed efficiently embedding consequent already specified.
disadvantages number rules represent generic plan transformation
may large resulting rules quite lengthy; problems may decrease
221

fiAmbite & Knoblock

performance match algorithm. Also, rule specification error prone written
user. Conversely, main advantage partial-specification rules single
rule represent complex plan transformation naturally concisely. rule
cover large number plan structures even may occasionally fail. Also, partial
specification rules much easier specify understand users system.
seen, PbR provides high degree flexibility defining plan-rewriting rules.
3.1.3 Plan-Rewriting Algorithm
section, first describe basic plan-rewriting algorithm PbR. Second,
prove algorithm sound discuss formal properties rewriting. Finally,
discuss family algorithms plan rewriting depending parameters
language defining plan operators, specification language rewriting rules,
requirements search method.
plan-rewriting algorithm shown Figure 13. algorithm takes two inputs:
valid plan P , rewriting rule R = (qm , pr , pc ) (qm antecedent query, pr
replaced subplan, pc replacement subplan). output valid rewritten
plan P 0 . matching antecedent rewriting rule (qm ) determines rule
applicable identifies steps links interest (line 1). matching seen
subgraph isomorphism antecedent subplan current plan (with
results filtered applying :constraints). However, take different approach.
PbR implements rule matching conjunctive query evaluation. implementation keeps
relational representation steps links current plan similar node
link specifications rewriting rules. example, database plan
Figure 4 contains one table unstack steps schema (?n1 ?b1 ?b2) tuples
(4 C A) (5 B D), another table causal links involving clear condition
schema (?n1 ?n2 ?b) tuples (0 1 C), (0 2 B), (0 2 C), (0 3 B), (0 4 C), (0 5 B), (4
3 A) (5 1 D), similar tables operator link types. match
process consists interpreting rule antecedent conjunctive query interpreted
predicates, executing query relational view plan structures.
running example, analyze application avoid-move-twice rule Figure 6
plan Figure 4. Matching rule antecedent identifies steps 1 4.
precisely, considering antecedent query, result single tuple (4 C 1 D)
variables (?n1 ?b1 ?b2 ?n2 ?b3).
choosing match work (line 3), algorithm instantiates subplan
specified :replace field (pr ) according match (line 4) removes
instantiated subplan pir original plan P (line 5). edges incoming
emanating nodes replaced subplan removed. effects
replaced plan pir achieving remainder plan (P pir ), UsefulEffects pir ,
achieved replacement subplan (or steps P pir ). order
facilitate process, AddFlaws procedure records effects open conditions.10
10. POCL planners operate keeping track repairing flaws found partial plan. Open conditions, operator threats, resource threats collectively called flaws (Penberthy & Weld, 1992).
AddFlaws(F,P) adds set flaws F plan structure P .

222

fiPlanning Rewriting

procedure RewritePlan
Input: valid partial-order plan P
rewriting rule R = (qm , pr , pc ), V ariables(pr ) V ariables(qm )
Output: valid rewritten partial-order plan P 0 (or failure)
1. := atch(qm , P )
Match rule antecedent qm (:if field) P . result set substitutions
= {..., , ...} variables qm .
2. = return failure
3. Choose match
4. pir := pr
Instantiate subplan removed pr (the :replace field) according .
5. Pri := AddFlaws(UsefulEffects(pir ), P pir )
Remove instantiated subplan pir plan P add UsefulEffects pir
open conditions. resulting plan Pri incomplete.
6. pic := pc
Instantiate replacement subplan pc (the :with field) according .
7. Pci := AddF laws(P reconditions(pic ) F indT hreats(Pri pic ), Pri pic )
Add instantiated replacement subplan pic Pri . Find new threats open
conditions add flaws. Pci potentially incomplete, several flaws
need resolved.
8. P 0 := rP OP (Pci )
Complete plan using partial-order causal-link planning algorithm (restricted
step reuse, step addition) order resolve threats open conditions.
rP OP returns failure valid plan found.
9. Return P 0
Figure 13: Plan-Rewriting Algorithm
result partial plan Pri (line 5). Continuing example, Figure 14(a) shows
plan resulting removing steps 1 4 plan Figure 4.
Finally, algorithm embeds instantiated replacement subplan pic remainder original plan (lines 6-9). rule completely specified, algorithm simply
adds (already instantiated) replacement subplan plan, work
necessary. rule partially specified, algorithm computes embeddings
replacement subplan remainder original plan three stages. First,
algorithm adds instantiated steps links replacement plan pic (line 6)
current partial plan Pri (line 7). Figure 14(b) shows state example
pic , new stack step (6), incorporated plan. Note open conditions
(clear A) on(C D). Second, FindThreats procedure computes possible threats,
operator threats resource conflicts, occurring Pri pic partial plan (line 7);
example, threat situation clear(C) proposition step 6 2 Figure 14(b). threats preconditions replacement plan pic recorded
AddFlaws resulting partial plan Pci . Finally, algorithm completes plan using
rPOP, partial-order causal-link planning procedure restricted reuse steps (i.e.,
223

fiAmbite & Knoblock

step addition) (line 8). rPOP allows us support expressive operator language
flexibility computing one embeddings. one rewriting needed,
rPOP stops first valid plan. Otherwise, continues exhausting alternative ways satisfying open preconditions resolving conflicts, produces valid
rewritings. running example, one embedding possible resulting plan
Figure 14(c), new stack step (6) produces (clear A) on(C D),
preconditions satisfied, ordering (6 2) ensures plan valid.
rewriting algorithm Figure 13 sound sense produces valid plan
input valid plan, outputs failure input plan cannot rewritten using
given rule. Since elementary plan-rewriting step sound, sequence rewritings
performed PbRs optimization search sound.
Lemma 1 (Soundness rPOP) Partial-order causal-link (POCL) planning without
step addition (rP OP ) sound.
Proof: POCL planning, precondition step plan achieved either
inserting new step snew reusing step sreuse already present current plan (the
steps effect unifies precondition). Forbidding step addition decreases
set available steps used satisfy precondition, step found
rPOP proceeds general POCL. Since, POCL completion partial-plan sound
(Penberthy & Weld, 1992), rP OP sound. 2
Theorem 1 (Soundness Plan Rewriting) RewritePlan (Figure 13) produces
valid plan input P valid plan, outputs failure input plan cannot
rewritten using given rewriting rule R = (qm , pr , pc ).
Proof: Assume plan P solution planning problem goals G initial
state I. POCL planning, plan valid iff preconditions steps supported
causal links (the goals G preconditions goal step, initial state
conditions effects initial step), operator threatens causal link
(McAllester & Rosenblitt, 1991; Penberthy & Weld, 1992).
rule R match plan P , algorithm trivially returns failure (line 2). Assuming
match , removing P steps links specified pir (including
links causal ordering incoming outgoing steps pir ), open
conditions exist resulting plan Pri pir achieving (line 5).
Adding instantiated replacement subplan pic introduces open conditions
partial plan: preconditions steps pic (line 7). sources
open conditions algorithm.
Since plan P valid initially, (operator and/or resource) threats present
plan Pci (line 7) caused removal subplan pir (line 3) addition
subplan pic (line 7). threats may occur operators causal links Pri pic
regardless whether operator causal link initially Pri pic . threats
combined plan Pri pic effectively computed finding relative positions
steps comparing causal link steps may ordered
producer consumer condition causal link (FindThreats, line 7).
point, shown plan (Pci ) flaws (threats
open conditions) explicitly recorded (by AddFlaws lines 5 7). Since rP OP sound
(Lemma 1), conclude rP OP complete Pci output valid plan P 0 , output
failure flaws plan cannot repaired. 2
224

fiPlanning Rewriting

clear(B)

REMOVED SUBPLAN

on(A Table)
on(C A)

Causal Link
Ordering Constraint
Side Effect

clear(A)

4 UNSTACK(C A)
on(C A)
clear(C)
on(D Table)

on(A Table)
clear(B)

3 STACK(A B Table)
on(C Table)
2 STACK(B C Table)

clear(C)
1 STACK(C Table)

0

on(B Table)
on(A B)
clear(C)
on(B C)
on(C D)
GOAL

clear(D)
clear(B)

on(C Table)

clear(D)



on(B D)

B

on(B Table)
5 UNSTACK(B D)
on(B D)
clear(B)

C

B

C







clear(C)
Initial State

Goal State

(a) Application Rewriting Rule: Removing Subplan
clear(B)

Causal Link
Ordering Constraint
Open conditions

on(A Table)

clear(A)
clear(C)
on(D Table)
0

on(C A)
clear(B)

3 STACK(A B Table)
on(B Table)
on(A B)
clear(C)
on(B C)

2 STACK(B C Table)
clear(C)

clear(A)

on(C A)
clear(D)

on(B D)

on(A Table)
clear(B)

on(C D)

6 STACK(C A)

on(C D)
clear(D)
on(C A)

GOAL


clear(D)

B

on(B Table)
5 UNSTACK(B D)
on(B D)

clear(B)

C

B

C







clear(C)
Initial State

Goal State

(b) Application Rewriting Rule: Adding Replacement Subplan
on(A Table)
clear(B)

on(A Table)

3 STACK(A B Table)

clear(B)
clear(A)

on(D Table)
on(C A)

2 STACK(B C Table)

clear(C)

0

6 STACK(C A)
clear(B)

on(B Table)
on(A B)
clear(C)
on(B C)
on(C D)
GOAL

clear(D)
on(C A)

clear(D)

Causal Link
Ordering Constraint
Side Effect

on(B D)
on(B Table)
5 UNSTACK(B D)
on(B D)
clear(B)


B

C

B

C







clear(C)
Initial State

Goal State

(c) Rewritten Plan
Figure 14: Plan Rewriting: Applying rule avoid-move-twice Figure 6 plan Figure 4
225

fiAmbite & Knoblock

Corollary 1 (Soundness PbR Search) optimization search PbR sound.
Proof: induction. Assume initial valid plan single step rewriting search.
Theorem 1, output either valid rewritten plan failure. output failure,
search trivially sound. Assume valid plan Pn1 n 1 rewriting steps.
According Theorem 1, applying single rewriting rule plan Pn1 produces valid
plan Pn failure. Thus, arbitrary number rewritings produces valid plan (or
plan), PbRs search sound. 2
Although RewritePlan sound, may certainly produce plans
minimal number steps faced arbitrary rules. example, imagine
consequent rewriting rule specified two identical steps s1 s2 (both
effects e1 e2) flaws Pci exactly open conditions e1 e2.
Then, sound non step-minimal plan would using s1 satisfy e1 using s2
satisfy e2 (although step could satisfy open conditions). PbR
discard plan make restriction types acceptable cost
functions. cost function took robustness plan account,
plan steps may desirable.
cannot guarantee PbRs optimization search complete sense
optimal plan would found. PbR uses local search well known that, general,
local search cannot complete. Even PbR exhaustively explores space plan
rewritings induced given initial plan set rewriting rules, still cannot prove
solution plans reached. property initial plan generator,
set rewriting rules, semantics planning domain. rewriting rules PbR
play similar role traditional declarative search control completeness
search may traded efficiency. Perhaps using techniques inferring invariants
planning domain (Gerevini & Schubert, 1998; Fox & Long, 1998; Rintanen, 2000) proving
convergence term graph rewriting systems (Baader & Nipkow, 1998), conditions
completeness plan-rewriting search given planning domain could obtained.
design plan-rewriting algorithm depends several parameters: language
operators, language rewriting rules, choice full-specification partialspecification rewriting rules, need rewritings one rewriting required
search method.
language operators affects way initial rewritten plans
constructed. framework supports expressive operator definition language described
Section 2.1. provide support language using standard techniques causal
link establishment threat checking Sage (Knoblock, 1995) UCPOP
(Penberthy & Weld, 1992).
language antecedents rewriting rules affects efficiency matching.
system implements conjunctive query language described Section 3.1.1.
However, system could easily accommodate expressive query language
rule antecedent, relationally complete language (i.e., conjunction, disjunction,
safe negation) (Abiteboul, Hull, & Vianu, 1995), recursive language datalog
stratified negation, without significantly increasing computational complexity
approach important way, discuss Section 3.1.4.
choice fully versus partially specified rewriting rules affects way
replacement plan embedded current plan. rule completely specified,
226

fiPlanning Rewriting

embedding already specified rule consequent, replacement subplan
simply added current plan. rule partially specified, algorithm
compute valid embeddings.
choice one versus rewritings affects antecedent matching
embedding rule consequent. rule matches computed either
time, bottom-up evaluation logic databases, one-at-a-time Prolog, depending whether search strategy requires one rewritings. rule fully-specified
one embedding per match possible. But, rule partially-specified multiple
embeddings may result single match. search strategy requires one rewriting, must provide mechanism choosing rule applied, match
computed, embedding generated (rPOP stop first embedding
compute embeddings). implemented rewriting algorithm modular design
support different combinations choices.
3.1.4 Complexity Plan Rewriting
complexity plan rewriting PbR originates two sources: matching rule
antecedent plan, computing embeddings replacement plan.
order analyze complexity matching plan-rewriting rules, introduce following
database-theoretic definitions complexity (Abiteboul et al., 1995):
Data Complexity: complexity evaluating fixed query variable database inputs.
Expression Complexity: complexity evaluating, fixed database instance,
queries specifiable given query language.
Data complexity measures complexity respect size database.
Expression complexity measures complexity respect size queries
(taken given language). case, database steps links plan
queries antecedents plan-rewriting rules.
Formally, language rule antecedents described Section 3.1.1 conjunctive
queries interpreted predicates. worst-case combined data expression complexity conjunctive queries exponential (Abiteboul et al., 1995). is, size
query (rule antecedent) size database (plan) grow simultaneously,
little hope matching efficiently. Fortunately, relationally-complete languages data
complexity contained Logarithmic Space, is, turn, contained Polynomial Time
(Abiteboul et al., 1995). Thus conjunctive query language complexity.
encouraging result shows cost evaluating fixed query grows
slowly database size increases. PbR means matching antecedent
rules strongly affected size plans. Moreover, experience
useful rule antecedents large contain many constant labels (at least,
node edge predicate names) help reduce size intermediate results
improve efficiency matching. result indicates could extend
language antecedent relationally complete without affecting significantly
performance system.11 Another possible extension use datalog stratified
negation, polynomial time data complexity. Graph-theoretic properties
11. Figure 32 Section 6 proposes example rule relationally-complete antecedent using
appropriate syntax.

227

fiAmbite & Knoblock

plans could easily described datalog. example, possibly-adjacent interpreted predicate Figure 7 could described declaratively datalog program instead
piece code. summary, rule match moderately sized rules, even quite expressive
languages large plans, remains tractable made efficient using production
match (Forgy, 1982) query optimization techniques (Sellis, 1988).
second source complexity computing embeddings replacement plan
given consequent plan-rewriting rule. definition full-specification rules,
embedding completely specified rule itself. Thus, suffices simply remove
undesired subplan directly add replacement subplan. linear size
consequent.
partial-specification rules, computing embeddings replacement subplan
exponential size plan worst case. However, occurs
pathological cases. example, consider plan Figure 15(a) going
compute embeddings step x remainder plan order satisfy open
precondition g0. Step x preconditions two effects b g0. step
plan proposition b effect. Therefore, new step x conflicts every step
plan (1 n) ordered respect steps. Unfortunately,
exponential number orderings. effect, orderings imposed adding step
x correspond partitions set steps (1 n) two sets: one ordered
x one after. Figure 15(b) shows one possible orderings. subplan
embedding contained several steps contained similar conflicts problem would
compounded. Even deciding single embedding exists NP-hard. example,
add two additional effects g1 operator x, valid embedding.
worst case (solving first flaws induced conflicts proposition b)
explore exponential number positions step x plan, end
failure. Nevertheless, given quasi-decomposability useful planning domains expect
number conflicts relatively small. useful rewriting rules specify
replacement subplans small compared plan embedding into.
experience indicates plan rewriting partial-specification rules performed
efficiently shown results Section 4.
b

b

1

1

g1





b

g1
b

2

2

g2
g0
b



0

g

0

g2


b

x

g

g0

x

g0



n

gn

gn



b

n

(a) embedding

b

(b) One possible embedding

Figure 15: Exponential Embeddings

228

fiPlanning Rewriting

3.1.5 Taxonomy Plan-Rewriting Rules
order guide user defining plan-rewriting rules domain help designing
algorithms may automatically deduce rules domain specification (see
Section 6), helpful know kinds rules useful. identified
following general types transformation rules:
Reorder: rules based algebraic properties operators, commutative, associative distributive laws. example, commutative rule reorders
two operators need resource Figure 10, join-swap rule Figure 29
combines commutative associative properties relational algebra.
Collapse: rules replace subplan smaller subplan. example,
several operators replaced one, remote-join-eval rule Figure 29.
rule replaces two remote retrievals information source local join
operation single remote join operation, remote source capability
performing joins. example application rule query plan shown
Figure 30. examples Blocks World rules Figure 6 replace unstack
stack operators either equivalent single stack operator empty plan.
Expand: rules replace subplan bigger subplan. Although may
appear counter-intuitive initially, easy imagine situation expensive
operator replaced set operators cheaper whole. interesting
case operators already present plan synergistically reused. find rule type domains analyzed far, Backstrom
(1994a) presents framework adding actions improves quality plans.
quality metric plan execution time, similarly manufacturing domain Section 4.1. Figure 16 shows example planning domain adding actions improves
quality (from Backstrom, 1994a). example, removing link Bm C1
inserting new action shortens significantly time execute plan.
P

Rn1

R1

R0


C1

C1
R0

P

P

Q1

Qm

B1

Rn
Cn

P

Rn
Cn

P
Q1

Rn1

R1

R0


B1

Bm

Bm Qm

Qm1

Qm1

(a) Low Quality Plan

(b) High Quality Plan

Figure 16: Adding Actions Improve Quality
Parallelize: rules replace subplan equivalent alternative subplan
requires fewer ordering constraints. typical case redundant alternative resources operators use. example, rule punch-by-drill-press
Figure 7. Another example rule Figure 16 suggests could seen
combination expand parallelize types.
229

fiAmbite & Knoblock

3.2 Selection Next Plan: Search Strategies
Although space rewritings explored systematically, Planning Rewriting
framework better suited local search techniques typical combinatorial optimization algorithms. characteristics planning domain, initial plan generator,
rewriting rules determine local search method performs best. First, discuss
initial plan generator affects choice local search methods. Second, consider impact rewriting rules. Third, discuss role domain knowledge
search process. Finally, describe several local search methods work PbR.
important difference PbR traditional combinatorial algorithms
generation feasible solutions. Usually, combinatorial optimization problems exists
effective procedure generate feasible solutions (e.g., permutations schedule).
Thus, even local search graph disconnected, choosing appropriate initial
solution generator (e.g., random) could fall component graph contains
global optimum. PbR cannot assume powerful initial plan generators. Even
optimization domains, efficient initial plan generators, may
guarantees coverage solution space provide. Therefore, optimal plan
may reachable applying rewriting rules starting initial plans
available generator. Nevertheless, many domains initial plan generator
provides good sample solution space sufficient multiple-restart search methods
escape low-quality local minima provide high-quality solutions.
plan-rewriting rules define neighborhood function, may exact (cf.
Section 2.3) not. example, query planning domain define set
rules completely generate space solution plans (because properties
relational algebra). domains may hard prove exact set
rules. limitations initial plan generation plan-rewriting rules affect
possibility theoretically reaching global optimum. surprising since many
problems, regardless whether cast planning formalisms,
converging local search algorithms (e.g., Papadimitriou & Steiglitz, 1977). Nevertheless,
practice, good local optima still obtained many domains.
Many local search methods, first best improvement, simulated annealing,
tabu search, variable-depth search, applied straightforwardly PbR.
experiments Section 4 used first best improvement, performed
well. Next, describe details application two methods PbR.
Section 6, discuss ideas using variable-depth plan rewriting.
First improvement generates rewritings incrementally selects first plan
better cost current one. order implement method efficiently use
tuple-at-a-time evaluation rule antecedent, similarly behavior Prolog. Then,
rule instantiation, generate one embedding, test cost resulting plan,
better current plan, repeat. choice generating another
embedding rule instantiation, generate another instantiation rule,
generate match different rule.
Best improvement generates complete set rewritten plans selects best.
method requires computing matches embeddings match.
matches obtained evaluating rule antecedent set-at-a-time database
230

fiPlanning Rewriting

query. discussed Section 3.1.4 query evaluation quite efficient.
experience, computing plan embeddings usually expensive computing
rule matches.
Planning Rewriting choice initial plan generator, rewriting rules,
search methods intertwined. initial plan generator fixed, determines
shape plans would modified rewriting rules, according
neighborhood, appropriate search mechanism chosen. PbR
modular design facilitate experimentation different initial plan generators, sets
rewriting rules, search strategies.
3.3 Plan Quality
practical planning domains quality plans crucial. one
motivations Planning Rewriting approach. PbR user defines measure
plan quality appropriate application domain. quality metric could
range simple domain-independent cost metric, number steps,
complex domain-specific ones. example, query planning domain measure
plan quality usually estimation query execution cost based size
database relations, data manipulation operations involved answering query,
cost network transfer. decentralized environment, cost metric may involve
actual monetary costs information sources require payments. jobshop scheduling domain simple cost functions schedule length (that is,
parallel time finish pieces), sum times finish piece.
sophisticated manufacturing domain may include variety concerns cost,
reliability, precision operator/process, costs resources materials used
operators, utilization machines, etc. reader find detailed
examples quality metrics domains Sections 4.1 4.4.
significant advantage PbR complete plan available assess quality.
generative planners complete plan available search solution
completed, usually simple plan quality metrics, number steps,
used. work incorporate quality concerns generative planners (Estlin
& Mooney, 1997; Borrajo & Veloso, 1997; Perez, 1996). systems automatically
learn search control rules improve efficiency planning quality
resulting plans. PbR rewriting rules seen post facto optimization search
control. opposed guiding search generative planner towards high-quality
solutions based information available partial plans, PbR improves quality
complete solution plans without restriction types quality metrics. Moreover,
plan cost additive, plan refinement strategy impractical since may need
exhaustively explore search space find optimal plan. example nonadditive cost function appears UNIX planning domain (Etzioni & Weld, 1994)
plan transfer files two machines may cheaper files compressed
initially (and uncompressed arrival). is, plan includes compression
(and necessary uncompression) operations cost effective, plan refinement
search would naturally lead it. using complete plans, PbR accurately assess
arbitrary measures quality.
231

fiAmbite & Knoblock

3.4 Initial Plan Generation
Fast initial plan generation domain-specific nature. requires user specify
efficient mechanism compute initial solution plan. general, generating initial
plan may hard generating optimal plan. However, crucial intuition behind
planning algorithms practical problems quasi-decomposable (Simon, 1969),
is, interactions among parts problems limited. interactions
problem pervasive, 8-puzzle, operator-based representation algorithms classical planning little use. would behave search based
problem solver. Fortunately, many practical problems indeed quasi-decomposable.
intuition suggests finding initial plan generators planning problems may
hard appears, system solve subproblems independently,
combine simplest way, example, concatenating solutions sequentially. Moreover, many circumstances problems may easily transformed
state minimizes interactions solving problem state much easier.
example, Blocks World state blocks table minimizes
interactions. simple design algorithm solves Blocks World problem
passing intermediate state. Using methods initial plan generator may
produce suboptimal initial plans reasonable planning cost.
ideas constructing initial plan generators embodied two general ways,
implemented system. first one bootstrap results
general purpose planning algorithm strong search control bias. second one
provide user convenient high-level facilities describe plan construction
algorithms programmatically.
3.4.1 Biased Generative Planners
variety ways control search generic planner. planners
accept search control rules, others accept heuristic functions, built-in search
control. present examples techniques.
general way efficiently constructing plans use domain-independent
generative planner accepts search control rules. example, Prodigy (Carbonell,
Knoblock, & Minton, 1991), UCPOP (Penberthy & Weld, 1992) Sage (Knoblock, 1995)
planners. setting type search providing strong bias means
search control rules, planner quickly generate valid, although possibly suboptimal,
initial plan. example, manufacturing domain (Minton, 1988a), analyzed
detail Section 4.1, depth-first search goal selection heuristic based abstraction
hierarchies (Knoblock, 1994a) quickly generates feasible plan, often quality
plan, defined time required manufacture objects, suboptimal.
TLPlan (Bacchus & Kabanza, 1995, 2000) efficient forward-chaining planner
uses search control expressed temporal logic. forward chaining complete
state available, much refined domain control knowledge specified.
preferred search strategy used TLPlan depth-first search, although finds plans
efficiently, plans may low quality. Note generative planner
explores partial sequences steps, cannot use sophisticated quality measures.
232

fiPlanning Rewriting

HSP (Bonet, Loerincs, & Geffner, 1997; Bonet & Geffner, 1999) forward search
planner performs variation heuristic search applied classical AI planning.
built-in heuristic function relaxed version planning problem: computes
number required steps reach goal disregarding negated effects operators.
metric computed efficiently. Despite simplicity heuristic
admissible, scales surprisingly well many domains. plans generated
according fixed heuristic function, planner cannot incorporate quality metric.
types planners quite efficient practice although often produce suboptimal plans. excellent candidates generate initial plans
subsequently optimized PbR.
3.4.2 Facilitating Algorithmic Plan Construction
many domains, simple domain-dependent approximation algorithms provide good
initial plans. example, query planning domain, system easily generate
initial query evaluation plans randomly (or greedily) parsing given query.
Blocks World straightforward generate solution linear time using naive
algorithm: put blocks table build desired towers bottom up.
algorithm produces plans length worse twice optimal, makes
already good approximation algorithm. However, interest Blocks World
traditionally optimal solutions, NP-hard problem (Gupta & Nau, 1992).
system facilitates creation initial plans freeing user specifying detailed graph structure plan. user needs specify algorithm
produces sequence instantiated actions, is, action names ground
parameters action takes.12 example, (user-defined) naive algorithm
Blocks World domain described applied problem Figure 4 produces
sequence: unstack(C A), unstack(B D), stack(C Table), stack(B C Table),
stack(A B Table). Then, system automatically converts sequence actions
fully detailed partial-order plan using operator specification domain. resulting plan conforms internal data structures PbR uses. process includes
creating nodes fully detailed operators preconditions effects, adding
edges represent necessary causal links ordering constraints. Blocks
World example resulting plan Figure 4.
algorithm transforms user-defined sequence actions partial-order
plan presented Figure 17. algorithm first constructs causal structure plan
(lines 2 6) adds necessary ordering links avoid threats (lines 7 10).
user needs specify action names corresponding instantiated action
parameters. algorithm consults operator specification find preconditions
effects, instantiate them, construct causal links, check operator threats.
Operator threats always resolved favor ordering given user input
plan. reason input plan may overconstrained total order,
assumed valid. Therefore, processing step last first, orderings
indeed avoid threats included partial-order plan.
12. algorithm accepts extra ordering constraints addition sequence available
initial plan generator.

233

fiAmbite & Knoblock

procedure TO2PO
Input: valid total-order plan (a1 , ..., )
Output: equivalent partial-order plan
1. := n 1
2.
p Preconditions(ai )
3.
choose k <
4.
1. p PositiveEffects(ak )
5.
2. 6 l k < l < p NegativeEffects(al )
6.
add order ak ai
7.
p NegativeEffects(ai )
8.
j := (i 1) 1
9.
p Preconditions(aj )
10.
add order aj ai
11. return ((a1 , ..., ), )
Figure 17: Algorithm Converting Total-order Partial-order Plans
algorithm extension greedy algorithm presented Veloso, Perez, & Carbonell (1990). algorithm explores non-deterministically producers proposition (line 3), opposed taking latest producer sequence algorithm.13
is, algorithm explored exhaustively, produces partially-ordered causal
structures consistent input sequence. generalization stems criticism
Backstrom (1994b) algorithm Veloso et al. (1990) desire able
produce alternative initial plans.
problem transforming sequence steps least constrained plan analyzed
Backstrom (1994b) several natural definitions optimality. definitions
least-constrained plan shortest parallel execution problem NP-hard. Backstrom
shows Velosos algorithm, although polynomial, conform natural definitions. algorithm greedy, suffer drawbacks
pointed Backstrom. Moreover, purposes need optimal initial plans.
space partial orders explored rewriting process.
Regardless method producing initial plans, generators provide multiple
plans preferable. different initial plans used conjunction multiple restart
search techniques order escape low-quality local minima.

4. Empirical Results
section show broad applicability Planning Rewriting analyzing four
domains different characteristics: process manufacturing domain (Minton, 1988b),
transportation logistics domain, Blocks World domain used examples
throughout paper, domain distributed query planning.
13. implement algorithm enough replace line 3 Figure 17 with:
find max k <

234

fiPlanning Rewriting

4.1 Manufacturing Process Planning
task manufacturing process planning domain find plan manufacture
set parts. implemented PbR translation domain specification (Minton,
1988b). domain contains variety machines, lathe, punch, spray painter,
welder, etc, total ten machining operations. operator specification shown
Figures 18 19. features part described set predicates,
temperature, painted, has-hole, etc. features changed operators.
predicates state, has-clamp, is-drillable, etc, set initial state
problem.
example behavior operator, consider polish operator Figure 18.
requires part manufacture cold polisher clamp secure
part machine. effect applying operator leave surface
part polished. attributes part, surface-condition, single-valued,
others, has-hole, multivalued. Note drill-press punch
operators Figure 18 prevent several has-hole conditions asserted
part. interesting operators weld bolt. operators join two
parts particular orientation form new part. operations performed
separate parts joined.
measure plan cost schedule length, (parallel) time manufacture
parts. domain machining operations assumed take unit time.
machines objects (parts) modeled resources order enforce one
part placed machine time machine operate single
part time (except bolt weld operate two parts simultaneously).
already shown types rewriting rules domain Figures 7
10. set rules used experiments shown Figure 20. top
eight rules quite straightforward one becomes familiar domain. two
top rules explore space alternative orderings originated resource conflicts.
machine-swap rule allows system explore possible orderings operations
require machine. rule finds two consecutive operations machine
swaps order. Similarly, rule object-swap allows system explore
orderings operations object. two rules use interpreted predicate
adjacent-in-critical-path focus attention steps contribute cost
function. Adjacent-in-critical-path checks two steps consecutive along one
critical paths schedule. critical path sequence steps take longest
time accomplish. words, critical path one sequences steps
determine schedule length.
next six rules exchange operators equivalent respect achieving
effects. Rules IP-by-SP SP-by-IP propose exchange immersion-paint
spray-paint operators. examining operator definitions Figure 19,
readily noticed operators change value painted predicate. Similarly,
PU-by-DP DP-by-PU exchange drill-press punch operators, produce
has-hole predicate. Finally, roll-by-lathe lathe-by-roll exchange roll lathe
operators make parts cylindrical. focus search promising
235

fiAmbite & Knoblock

(define (operator POLISH)
:parameters (?x)
:resources ((machine POLISHER) (is-object ?x))
:precondition (:and (is-object ?x)
(temperature ?x COLD)
(has-clamp POLISHER))
:effect
(:and (:forall (?surf)
(:when (:neq ?surf POLISHED)
(:not (surface-condition ?x ?surf)))
(surface-condition ?x POLISHED)))

(define (operator GRIND)
:parameters (?x)
:resources ((machine GRINDER) (is-object ?x))
:precondition (is-object ?x)
:effect
(:and (:forall (?color)
(:not (painted ?x ?color)))
(:forall (?surf)
(:when (:neq ?surf SMOOTH)
(:not (surface-condition ?x ?surf))))
(surface-condition ?x SMOOTH)))

(define (operator LATHE)
:parameters (?x)
:resources ((machine LATHE) (is-object ?x))
:precondition (is-object ?x)
:effect
(:and (:forall (?color)
(:not (painted ?x ?color)))
(:forall (?shape)
(:when (:neq ?shape CYLINDRICAL)
(:not (shape ?x ?shape))))
(:forall (?surf)
(:when (:neq ?surf ROUGH)
(:not (surface-condition ?x ?surf))))
(surface-condition ?x ROUGH)
(shape ?x CYLINDRICAL)))

(define (operator ROLL)
:parameters (?x)
:resources ((machine ROLLER) (is-object ?x))
:precondition (is-object ?x)
:effect
(:and (:forall (?color)
(:not (painted ?x ?color)))
(:forall (?shape)
(:when (:neq ?shape CYLINDRICAL)
(:not (shape ?x ?shape))))
(:forall (?temp)
(:when (:neq ?temp HOT)
(:not (temperature ?x ?temp))))
(:forall (?surf)
(:not (surface-condition ?x ?surf)))
(:forall (?width ?orientation)
(:not (has-hole ?x ?width ?orientation)))
(temperature ?x HOT)
(shape ?x CYLINDRICAL)))

(define (operator DRILL-PRESS)
:parameters (?x ?width ?orientation)
:resources ((machine DRILL-PRESS)
(is-object ?x))
:precondition
(:and (is-object ?x)
(have-bit ?width)
(is-drillable ?x ?orientation))
:effect (has-hole ?x ?width ?orientation))

(define (operator PUNCH)
:parameters (?x ?width ?orientation)
:resources ((machine PUNCH) (is-object ?x))
:precondition
(:and (is-object ?x)
(has-clamp PUNCH)
(is-punchable ?x ?width ?orientation))
:effect
(:and (:forall (?surf)
(:when (:neq ?surf ROUGH)
(:not (surface-condition ?x ?surf))))
(surface-condition ?x ROUGH)
(has-hole ?x ?width ?orientation)))

Figure 18: Operators Manufacturing Process Planning (I)

exchanges rules match operators critical path (by means interpreted
predicate in-critical-path).
six bottom rules Figure 20 sophisticated. lathe+SP-by-SP rule
takes care undesirable effect simple depth-first search used initial plan
generator. domain, order spray paint part, part must regular shape.
cylindrical regular shape, therefore initial planner may decide make
part cylindrical lathing order paint it! However, may necessary
part may already regular shape (for example, could rectangular,
regular shape). Thus, lathe+SP-by-SP substitutes pair spray-paint lathe
single spray-paint operation. supporting regular-shapes interpreted predicate
236

fiPlanning Rewriting

(define (operator IMMERSION-PAINT)
:parameters (?x ?color)
:resources ((machine IMMERSION-PAINTER)
(is-object ?x))
:precondition
(:and (is-object ?x)
(have-paint-for-immersion ?color))
:effect (painted ?x ?color))

(define (operator SPRAY-PAINT)
:parameters (?x ?color ?shape)
:resources ((machine SPRAY-PAINTER)
(is-object ?x))
:precondition (:and (is-object ?x)
(sprayable ?color)
(temperature ?x COLD)
(regular-shape ?shape)
(shape ?x ?shape)
(has-clamp SPRAY-PAINTER))
:effect (painted ?x ?color))

(define (operator BOLT)
(define (operator WELD)
:parameters (?x ?y ?new-obj ?orient ?width)
:parameters (?x ?y ?new-obj ?orient)
:resources ((machine BOLTER)
:resources ((machine WELDER)
(is-object ?x) (is-object ?y))
(is-object ?x) (is-object ?y))
:precondition
:precondition
(:and (is-object ?x) (is-object ?y)
(:and (is-object ?x) (is-object ?y)
(composite-object ?new-obj ?orient ?x ?y)
(composite-object ?new-obj ?orient ?x ?y)
(has-hole ?x ?width ?orient)
(can-be-welded ?x ?y ?orient))
(has-hole ?y ?width ?orient)
:effect (:and (temperature ?new-obj HOT)
(bolt-width ?width)
(joined ?x ?y ?orient)
(can-be-bolted ?x ?y ?orient))
(:not (is-object ?x))
:effect (:and (:not (is-object ?x))
(:not (is-object ?y))))
(:not (is-object ?y))
(joined ?x ?y ?orient)))

Figure 19: Operators Manufacturing Process Planning (II)

enumerates regular shapes. rules partially specified
guaranteed always produce rewriting. Nevertheless, often successful
producing plans lower cost.
remaining rules explore bolting two parts using bolts different size fewer operations may needed plan. developed rules analyzing differences
quality optimal plans rewritten plans. example, consider
both-providers-diff-bolt rule. rule states parts bolted already
compatible holes them, better reuse operators produced
holes. initial plan generator may drilled (or punched) holes whose purpose
bolt parts. However, goal problem may already require holes
performed parts joined. Reusing available holes produces economical plan. rules has-hole-x-diff-bolt-add-PU, has-hole-x-diff-bolt-add-DP,
has-hole-y-diff-bolt-add-PU, has-hole-y-diff-bolt-add-DP address cases
one holes reused, thus additional punch drill-press
operation needs added.
illustration rewriting process manufacturing domain, consider Figure 21. plan top figure result simple initial plan generator
solves part independently concatenates corresponding subplans. Although
plan generated efficiently, poor quality. requires six time-steps manufacture parts. figure shows application two rewriting rules, machine-swap
IP-by-SP, improve quality plan. operators matched rule antecedent shown italics. operators introduced rule consequent shown
bold. First, machine-swap rule reorders punching operations parts B.
237

fiAmbite & Knoblock

(define-rule :name machine-swap
:if (:operators ((?n1 (machine ?x) :resource)
(?n2 (machine ?x) :resource))
:links ((?n1 :threat ?n2))
:constraints
(adjacent-in-critical-path ?n1 ?n2))
:replace (:links (?n1 ?n2))
:with (:links (?n2 ?n1)))

(define-rule :name object-swap
:if (:operators ((?n1 (is-object ?x) :resource)
(?n2 (is-object ?x) :resource))
:links ((?n1 :threat ?n2))
:constraints
(adjacent-in-critical-path ?n1 ?n2))
:replace (:links (?n1 ?n2))
:with (:links (?n2 ?n1)))

(define-rule :name SP-by-IP
(define-rule :name IP-by-SP
:if (:operators (?n1 (spray-paint ?x ?c ?s))
:if (:operators (?n1 (immersion-paint ?x ?c))
:constraints ((in-critical-path ?n1)))
:constraints ((regular-shapes ?s)
:replace (:operators (?n1))
(in-critical-path ?n1)))
:with (:operators (?n2 (immersion-paint ?x ?c))))
:replace (:operators (?n1))
:with (:operators (?n2 (spray-paint ?x ?c ?s))))
(define-rule :name DP-by-PU
(define-rule :name PU-by-DP
:if (:operators ((?n1 (drill-press ?x ?w ?o)))
:if (:operators (?n1 (punch ?x ?w ?o))
:constraints ((in-critical-path ?n1)))
:constraints ((in-critical-path ?n1)))
:replace (:operators (?n1))
:replace (:operators (?n1))
:with (:operators (?n2 (punch ?x ?w ?o))))
:with (:operators (?n2 (drill-press ?x ?w ?o))))
(define-rule :name roll-by-lathe
:if (:operators ((?n1 (roll ?x)))
:constraints ((in-critical-path ?n1)))
:replace (:operators (?n1))
:with (:operators (?n2 (lathe ?x))))

(define-rule :name lathe-by-roll
:if (:operators ((?n1 (lathe ?x)))
:constraints ((in-critical-path ?n1)))
:replace (:operators (?n1))
:with (:operators (?n2 (roll ?x))))

(define-rule :name both-providers-diff-bolt
(define-rule :name lathe+SP-by-SP
:if (:operators ((?n3 (bolt ?x ?y ?z ?o ?w1)))
:if (:operators
:links ((?n1 (has-hole ?x ?w1 ?o) ?n3)
((?n1 (lathe ?x))
(?n2 (has-hole ?y ?w1 ?o) ?n3)
(?n2 (spray-paint ?x ?color ?shape1)))
(?n4 (has-hole ?x ?w2 ?o) ?n5)
:constraints ((regular-shapes ?shape2)))
(?n6 (has-hole ?y ?w2 ?o) ?n7))
:replace (:operators (?n1 ?n2))
:constraints ((:neq ?w1 ?w2)))
:with (:operators
((?n3 (spray-paint ?x ?color ?shape2))))) :replace (:operators (?n1 ?n2 ?n3))
:with (:operators ((?n8 (bolt ?x ?y ?z ?o ?w2)))
:links ((?n4 (has-hole ?x ?w2 ?o) ?n8)
(?n6 (has-hole ?y ?w2 ?o) ?n8))))
(define-rule :name has-hole-x-diff-bolt-add-DP
(define-rule :name has-hole-x-diff-bolt-add-PU
:if (:operators ((?n3 (bolt ?x ?y ?z ?o ?w1)))
:if (:operators ((?n3 (bolt ?x ?y ?z ?o ?w1)))
:links ((?n1 (has-hole ?x ?w1 ?o) ?n3)
:links ((?n1 (has-hole ?x ?w1 ?o) ?n3)
(?n2 (has-hole ?y ?w1 ?o) ?n3)
(?n2 (has-hole ?y ?w1 ?o) ?n3)
(?n4 (has-hole ?x ?w2 ?o) ?n5))
(?n4 (has-hole ?x ?w2 ?o) ?n5))
:constraints ((:neq ?w1 ?w2)))
:constraints ((:neq ?w1 ?w2)))
:replace (:operators (?n1 ?n2 ?n3))
:replace (:operators (?n1 ?n2 ?n3))
:with (:operators ((?n8 (bolt ?x ?y ?z ?o ?w2))
:with (:operators ((?n8 (bolt ?x ?y ?z ?o ?w2))
(?n6 (drill-press ?y ?w2 ?o)))
(?n6 (punch ?y ?w2 ?o)))
:links ((?n4 (has-hole ?x ?w2 ?o) ?n8)
:links ((?n4 (has-hole ?x ?w2 ?o) ?n8)
(?n6 (has-hole ?y ?w2 ?o) ?n8))))
(?n6 (has-hole ?y ?w2 ?o) ?n8))))
(define-rule :name has-hole-y-diff-bolt-add-DP
(define-rule :name has-hole-y-diff-bolt-add-PU
:if (:operators ((?n3 (bolt ?x ?y ?z ?o ?w1)))
:if (:operators ((?n3 (bolt ?x ?y ?z ?o ?w1)))
:links ((?n1 (has-hole ?x ?w1 ?o) ?n3)
:links ((?n1 (has-hole ?x ?w1 ?o) ?n3)
(?n2 (has-hole ?y ?w1 ?o) ?n3)
(?n2 (has-hole ?y ?w1 ?o) ?n3)
(?n6 (has-hole ?y ?w2 ?o) ?n7))
(?n6 (has-hole ?y ?w2 ?o) ?n7))
:constraints ((:neq ?w1 ?w2)))
:constraints ((:neq ?w1 ?w2)))
:replace (:operators (?n1 ?n2 ?n3))
:replace (:operators (?n1 ?n2 ?n3))
:with (:operators ((?n8 (bolt ?x ?y ?z ?o ?w2))
:with (:operators ((?n8 (bolt ?x ?y ?z ?o ?w2))
(?n4 (drill-press ?x ?w2 ?o)))
(?n4 (punch ?x ?w2 ?o)))
:links ((?n4 (has-hole ?x ?w2 ?o) ?n8)
:links ((?n4 (has-hole ?x ?w2 ?o) ?n8)
(?n6 (has-hole ?y ?w2 ?o) ?n8))))
(?n6 (has-hole ?y ?w2 ?o) ?n8))))

Figure 20: Rewriting Rules Manufacturing Process Planning
238

fiPlanning Rewriting

Lathe

IPaint Red

Punch 2

Punch C 1

IPaint C Blue

Roll B

IPaint B Red

Reorder Parts Machine
Lathe

IPaint Red
Punch C 1

Cost: 6

Punch 2

Cost: 4

IPaint C Blue

IPaint B Red

Roll B

Immersion-Paint => Spray-Paint
Lathe
Roll B

IPaint Red

Punch 2

Punch C 1

IPaint C Blue

Cost: 3

Spray-Paint B Red

Figure 21: Rewriting Manufacturing Domain
breaks long critical path resulted simple concatenation respective
subplans. schedule length improves six four time-steps. Still, three parts
A, B, C use painting operation (immersion-paint). immersion-painter
process one piece time, three operations must done serially. Fortunately, domain another painting operation: spray-paint. IP-by-SP
rule takes advantage fact substitutes immersion-paint operation part B
spray-paint operation. parallelizes plan obtaining schedule length
three time-steps, optimal plan.
compare four planners (IPP, Initial, two configurations PbR):
IPP: one efficient domain-independent planners (Koehler, Nebel, Hoffman, & Dimopoulos, 1997) planning competition held Fourth International
Conference Artificial Intelligence Planning Systems (AIPS-98). IPP optimized reimplementation extension Graphplan (Blum & Furst, 1995, 1997). IPP produces
shortest parallel plans. manufacturing domain, exactly schedule length,
cost function optimizing.
Initial: initial plan generator uses divide-and-conquer heuristic order generate
plans fast possible. First, produces subplans part joined goals
independently. subplans generated Sage using depth-first search without
regard plan cost. Then, concatenates subsequences actions merges
using facilities Section 3.4.2.
PbR: present results two configurations PbR, refer PbR-100
PbR-300. configurations use first improvement gradient search strategy
random walk cost plateaus. rewriting rules used Figure 20.
problem PbR starts search plan generated Initial. two configurations
differ many total plateau plans allowed. PbR-100 allows considering
100 plans improve cost without terminating search. Similarly, PbR239

fiAmbite & Knoblock

300 allows 300 plateau plans. Note limit across plateaus encountered
search problem, plateau.
tested four systems 200 problems, machining 10 parts, ranging
5 50 goals. goals distributed randomly 10 parts. So, 50goal problems, average 5 goals per part. results shown Figure 22.
graphs data point average 20 problems given number goals.
10 provably unsolvable problems. Initial PbR solved 200 problems (or
proved unsolvable). IPP solved 65 problems total: problems 5 10 goals,
19 15 goals, 6 20 goals. IPP could solve problem 20 goals
1000 CPU seconds time limit.
Figure 22(a) shows average time solvable problems problem set
four planners. Figure 22(b) shows average schedule length problems solved
planners, is, 65 problems solved IPP 20 goals.
fastest planner Initial, produces plans cost twice optimal. IPP
produces optimal plans, cannot solve problems 20 goals. two
configurations PbR scale much better IPP solving problems producing good
quality plans. PbR-300 matches optimal cost IPP plans, except one problem
(the reason difference interesting explain below). faster PbR-100
stays close optimal (less 2.5% average cost difference).
Figure 22(c) shows average schedule length problems solved
planners 50 goal range. PbR configurations scale gracefully across
range improving considerably cost plans generated Initial. additional
exploration PbR-300 allows improve plans even further. reason
difference PbR IPP 20-goal complexity level cost results
IPP 6 problems could solve, results PbR Initial
average 20 problems (as shown Figure 22(b), PbR matches cost
6 optimal plans produced IPP).
Figure 22(d) shows average number operators plans problems solved
three planners (up 20 goals). Figure 22(e) shows average number operators
plans problems solved planner across whole range 50 problems.
plans generated Initial use 2-3 additional operators. PbR IPP
produce plans require fewer steps. Interestingly, IPP sometimes produces plans
use operations PbR. IPP produces shortest parallel plan, one
minimum number steps. particular, observed IPP plans
suffer problem Initial. IPP would lathe part order paint
it, opposed Initial would affect optimal schedule
length. Surprisingly, adding additional steps domain may improve schedule
length, albeit fairly rare situations. case problem IPP
produced better schedule PbR-300. could introduced rewriting rule
substituted immersion-paint operator lathe spray-paint operators
cases. However, rule low utility (in sense Minton, 1988b).
expands rewriting search space, adds cost match, random
search provides benefit rarely.
240

fiPlanning Rewriting

Average Planning Time (CPU Seconds)

1000
PbR-FI
Initial
IPP

100

10

1

0.1

0.01
0

10

20

30

40
50
60
70
Number Blocks

80

90

100

(a) Average Planning Time
40

Average Plan Cost (Schedule Length)

Average Plan Cost (Schedule Length)

9
PbR-300
PbR-100
Initial
IPP

8
7
6
5
4
3
2

(b)

6

8

10
12
14
Number Goals

16

18

30
25
20
15
10
5

20

5

Average Plan Cost
(Problems Solved All)

(c)

24

10

15

20
25
30
35
Number Goals

40

45

50

Average Plan Cost
(Problems Solved Each)

60

22

PbR-300
PbR-100
Initial
IPP

20

Average Number Plan Operators

Average Number Plan Operators

PbR-300
PbR-100
Initial
IPP

0
4

18
16
14
12
10
8
6
4

55
50
45
40
35

PbR-300
PbR-100
Initial
IPP

30
25
20
15
10
5

4

(d)

35

6

8

10
12
14
Number Goals

16

18

20

5

Number Plan Operators
(Problems Solved All)

(e)

10

15

20
25
30
35
Number Goals

Number Plan Operators
(Problems Solved Each)

Figure 22: Experimental Results: Manufacturing Process Planning

241

40

45

50

fiAmbite & Knoblock

experiment illustrates flexibility PbR specifying complex rules planning domain. results show benefits finding suboptimal initial plan quickly
efficiently transforming improve quality.
4.2 Logistics
task logistics domain transport several packages initial location
desired destinations. used version logistics-strips planning domain
AIPS98 planning competition restricted using trucks planes.14
domain shown Figure 23. package transported one location another
loading truck, driving truck destination, unloading truck.
truck load number packages. cost function (parallel) time deliver
packages (measured number operators critical path plan).
(define (operator LOAD-TRUCK)
:parameters (?obj ?truck ?loc)
:precondition
(:and (obj ?obj) (truck ?truck) (location ?loc)
(at ?truck ?loc) (at ?obj ?loc))
:effect (:and (:not (at ?obj ?loc))
(in ?obj ?truck)))

(define (operator UNLOAD-TRUCK)
:parameters (?obj ?truck ?loc)
:precondition
(:and (obj ?obj) (truck ?truck) (location ?loc)
(at ?truck ?loc) (in ?obj ?truck))
:effect (:and (:not (in ?obj ?truck))
(at ?obj ?loc)))

(define (operator DRIVE-TRUCK)
:parameters (?truck ?loc-from ?loc-to ?city)
:precondition (:and (truck ?truck) (location ?loc-from) (location ?loc-to) (city ?city)
(at ?truck ?loc-from) (in-city ?loc-from ?city) (in-city ?loc-to ?city))
:effect (:and (:not (at ?truck ?loc-from)) (at ?truck ?loc-to)))

Figure 23: Operators Logistics
compare three planners domain:
IPP:

IPP (Koehler et al., 1997) produces optimal plans domain.

Initial: initial plan generator picks distinguished location delivers packages
one one starting returning distinguished location. example, assume
truck t1 distinguished location l1, package p1 must delivered location
l2 location l3. plan would be: drive-truck(t1 l1 l2 c), load-truck(p1 t1 l2),
drive-truck(t1 l2 l3 c), unload-truck(p1 t1 l3), drive-truck(t1 l3 l1 c).
initial plan generator would keep producing circular trips remaining packages.
Although algorithm efficient produces plans low quality.
PbR: PbR starts plan produced Initial uses plan rewriting rules shown
Figure 24 optimize plan quality. loop rule states driving location
returning back immediately useless. fact operators must adjacent
important implies intervening load unload performed.
vein, triangle rule states better drive directly two
locations third point operation performed point.
14. logistics domain AIPS98, problems moving packages plane among different cities
truck among different locations city isomorphic, focused one better
analyze rewriting rules learned (Ambite, Knoblock, & Minton, 2000).

242

fiPlanning Rewriting

load-earlier rule captures situation package loaded truck
first time packages location visited. occurs initial planner
concerned trip another package. unload-later rule captures dual case.
PbR applies first improvement search strategy one run (no restarts).
(define-rule :name loop
:if (:operators
((?n1 (drive-truck ?t ?l1 ?l2 ?c))
(?n2 (drive-truck ?t ?l2 ?l1 ?c)))
:links ((?n1 ?n2))
:constraints
((adjacent-in-critical-path ?n1 ?n2)))
:replace (:operators (?n1 ?n2))
:with NIL)

(define-rule :name triangle
:if (:operators
((?n1 (drive-truck ?t ?l1 ?l2 ?c))
(?n2 (drive-truck ?t ?l2 ?l3 ?c)))
:links ((?n1 ?n2))
:constraints
((adjacent-in-critical-path ?n1 ?n2)))
:replace (:operators (?n1 ?n2))
:with (:operators
((?n3 (drive-truck ?t ?l1 ?l3 ?c)))))

(define-rule :name unload-later
(define-rule :name load-earlier
:if (:operators
:if (:operators
((?n1 (drive-truck ?t ?l1 ?l2 ?c))
((?n1 (drive-truck ?t ?l1 ?l2 ?c))
(?n2 (unload-truck ?p ?t ?l2))
(?n2 (drive-truck ?t ?l3 ?l2 ?c))
(?n3 (drive-truck ?t ?l3 ?l2 ?c)))
(?n3 (load-truck ?p ?t ?l2)))
:links ((?n1 ?n2))
:links ((?n2 ?n3))
:constraints
:constraints
((adjacent-in-critical-path ?n1 ?n2)
((adjacent-in-critical-path ?n2 ?n3)
(before ?n2 ?n3)))
(before ?n1 ?n2)))
:replace (:operators (?n2))
:replace (:operators (?n3))
:with (:operators ((?n4 (unload-truck ?p ?t ?l2)))
:with (:operators ((?n4 (load-truck ?p ?t ?l2)))
:links ((?n3 ?n4))))
:links ((?n1 ?n4))))

Figure 24: Logistics Rewriting Rules

250

PbR
Initial
IPP

1000

PbR
Initial
IPP

200

Average Plan Cost

Average Planning Time (CPU Seconds)

10000

100
10
1

150

100

50

0.1
0.01

0
0

5

10

15 20 25 30 35
Number Packages

40

45

50

0

(a) Average Planning Time

5

10

15

20
25
30
35
Number Packages

40

45

50

(b) Average Plan Cost

Figure 25: Experimental Results: Logistics, Scaling Number Packages
compared performance IPP, Initial, PbR set logistics problems
involving 50 packages. problem instance number packages,
locations, goals. single truck single city. performance results
shown Figure 25. graphs data point average 20 problems
given number packages. problems satisfiable. IPP could solve
243

fiAmbite & Knoblock

problems 7 packages (it solved 10 20 8 packages, 1 20
9 packages, shown figure). Figure 25(a) shows average
planning time. Figure 25(b) shows average cost 50 packages range. results
similar previous experiment. Initial efficient highly suboptimal. PbR
able considerably improve cost plans approach optimal.
4.3 Blocks World
implemented classical Blocks World domain two operators Figure 2.
domain two actions: stack puts one block top another, and, unstack
places block table start new tower. Plan quality domain simply
number steps. Optimal planning domain NP-hard (Gupta & Nau, 1992).
However, trivial generate correct, suboptimal, plan linear time using
naive algorithm: put blocks table build desired towers bottom
up. compare three planners domain:
IPP: experiment used GAM goal ordering heuristic (Koehler, 1998; Koehler
& Hoffmann, 2000) tested Blocks World problems good scaling results.
Initial: planner programmatic implementation naive algorithm using
facilities introduced Section 3.4.2.
PbR: configuration PbR starts plan produced Initial uses
two plan-rewriting rules shown Figure 6 optimize plan quality. PbR applies first
improvement strategy one run (no restarts).
generated random Blocks World problems scaling number blocks. problem
set consists 25 random problems 3, 6, 9, 12, 15, 20, 30, 40, 50, 60, 70, 80, 90, 100
blocks total 350 problems. problems may multiple towers initial
state goal state.
Figure 26(a) shows average planning time 25 problems block quantity.
IPP cannot solve problems 20 blocks within time limit 1000 CPU
seconds. problem solving behavior IPP interesting. IPP either solved given
problem fast timed out. example, able solve 11 25 20block problems 100 seconds, timed 1000 seconds remaining 14
problems. seems typical behavior complete search algorithms (Gomes,
Selman, & Kautz, 1998). local search PbR allows scale much better solve
problems.
Figure 26(b) shows average plan cost number blocks increases. PbR
improves considerably quality initial plans. optimal quality known
small problems, PbR approximates it, achieve (we ran Sage
problems less 9 blocks). larger plans know optimal cost. However,
Slaney & Thiebaux (1996) performed extensive experimental analysis Blocks World
planning using domain ours. comparison among different approximation
algorithms found initial plan generator (unstack-stack) achieves empirically
quality around 1.22 optimal range problem sizes analyzed (Figure 7
Slaney & Thiebaux, 1996). value average initial plans divided 1.22 suggests
244

fiPlanning Rewriting

quality optimal plans. quality achieved PbR comparable value.
fact slightly better may due relatively small number problems
tested (25 per block size) skew random problem generator. Interestingly
plans found IPP actually low quality. due fact IPP produces
shortest parallel plans. means plans constructed fewest time
steps, IPP may introduce actions time step required.
summary, experiments previous sections show across variety
domains PbR scales large problems still producing high-quality plans.
180

Average Plan Cost (Number Operators)

Average Planning Time (CPU Seconds)

1000
PbR-FI
Initial
IPP

100

10

1

0.1

0.01
0

10

20

30

40
50
60
70
Number Blocks

80

90

PbR-FI
Initial
IPP
Initial/1.22

160
140
120
100
80
60
40
20
0

100

0

(a) Average Planning Time

10

20

30

40 50 60 70
Number Blocks

80

90

100

(b) Average Plan Cost

Figure 26: Experimental Results: Blocks World, Scaling Number Blocks

4.4 Query Planning
Query Planning problem considerable practical importance. central traditional
database mediator systems. section present results distributed query
planning highlight use PbR domain complex cost function. detailed
description query planning, including novel query processing algorithm mediators
based PbR, extensive experimental analysis appear (Ambite & Knoblock,
2000; Ambite, 1998).
Query planning involves generating plan efficiently computes user query
relevant information sources. plan composed data retrieval actions distributed information sources data manipulation operations, relational algebra: join, selection, union, etc. specification operators query
planning encoding information goals using first introduced
Knoblock (1996). sample information goal shown Figure 27. goal asks send
output device mediator names airports Tunisia. Two sample
operators shown Figure 28. retrieve operator executes query remote
information source transports data mediator, provided source
operation (source-available) source capable processing query
(source-acceptable-query). join operator takes two subqueries, available
locally mediator, combines using conditions produce joined
query.
245

fiAmbite & Knoblock

(available sims (retrieve (?ap_name)
(:and (airport ?aport)
(country-name ?aport "Tunisia")
(port-name ?aport ?ap_name))))

Figure 27: Sample Information Goal
(define (operator retrieve)
:parameters (?source ?query)
:resources ((processor ?source))
:precondition (:and (source-available ?source)
(source-acceptable-query ?query ?source))
:effect (available sims ?query))
(define (operator join)
:parameters (?join-conds ?query ?query-a ?query-b)
:precondition (:and (available sims ?query-a
(available sims ?query-b)
(join-query ?query ?join-conds ?query-a ?query-b))
:effect (available sims ?query))

Figure 28: Query Planning Operators
quality distributed query plan estimation execution cost,
function size intermediate results, cost performing data manipulation
operations, transmission network intermediate results
remote sources mediator. system estimates plan cost based statistics
obtained source relations, number tuples relation, number
distinct values attribute, maximum minimum values numeric
attributes (Silberschatz, Korth, & Sudarshan, 1997, chapter 12). sources accessed,
type ordering data processing operations critical plan cost.
rewriting rules derived properties distributed environment
relational algebra.15 first set rules rely fact that, distributed environment,
generally efficient execute group operations together remote information source transmit data network execute operations
local system. example consider Remote-Join-Eval rule Figure 29 (shown
PbR syntax, shown algebraically Figure 1). rule specifies
plan exist two retrieval operations remote database whose results
consequently joined remote source capable performing joins, system
rewrite plan one contains single retrieve operation pushes join
remote database.
second class rules derived commutative, associative, distributive
properties operators relational algebra. example, Join-Swap rule
Figure 29 (cf. Figure 1) specifies two consecutive joins operators reordered
allows planner explore space join trees. Since query planning
15. mediators, rules address resolution semantic heterogeneity necessary. See
(Ambite & Knoblock, 2000; Ambite, 1998) details.

246

fiPlanning Rewriting

(define-rule :name remote-join-eval
(define-rule :name join-swap
:if (:operators
:if (:operators
((?n1 (retrieve ?query1 ?source))
((?n1 (join ?q1 ?jc1 ?sq1a ?sq1b))
(?n2 (retrieve ?query2 ?source))
(?n2 (join ?q2 ?jc2 ?sq2a ?sq2b)))
(?n3 (join ?query ?jc ?query1 ?query2)))
:links (?n2 ?n1)
:constraints
:constraints
((capability ?source join)))
(join-swappable
:replace (:operators (?n1 ?n2 ?n3))
?q1 ?jc1 ?sq1a ?sq1b
;;
:with (:operators
?q2 ?jc2 ?sq2a ?sq2b
;;
((?n4 (retrieve ?query ?source))))
?q3 ?jc3 ?sq3a ?sq3b
;;
?q4 ?jc4 ?sq4a ?sq4b))
;;
:replace (:operators (?n1 ?n2))
:with (:operators
((?n3 (join ?q3 ?jc3 ?sq3a ?sq3b))
(?n4 (join ?q4 ?jc4 ?sq4a ?sq4b)))
:links (?n4 ?n3)))

Figure 29: Query Planning Rewriting Rules
domain queries expressed complex terms (Knoblock, 1996), PbR rules use
interpreted predicates :constraints field manipulate query expressions.
example, join-swappable predicate checks queries two join operators
exchanged computes new subqueries.
Figure 30 shows example local search space query plan rewritings simple distributed domain describes company. figure shows alternative
query evaluation plans conjunctive query asks names employees,
salaries, projects working on. three relations requested query
(Employees, Payroll, Project) distributed among two databases (one companys headquarters HQ-db another branch Branch-db). Assume
leftmost plan initial plan. plan first retrieves Employee relation HQ-db
Project relation Branch-db, joins two tables employee name. Finally, plan retrieves Payroll relation HQ-db joins
ssn result previous join. Although valid plan, initial plan suboptimal. Applying join-swap rule initial plan generates two rewritings. One
involves cross-product, expensive operation, system, following gradient descent search strategy, prefers plan. system applies
remote-join-eval rule generates new rewritten plan evaluates join
employee project tables remotely headquarters database. final plan
much better quality.
compare planning efficiency plan quality four query planners:
Sage: original query planner (Knoblock, 1995, 1996) SIMS mediator,
performs best-first search heuristic commonly used query optimization
explores space left join trees. Sage refinement planner (Kambhampati,
Knoblock, & Yang, 1995) generates optimal left-tree query plans.
DP: implementation dynamic-programming bottom-up enumeration
query plans (Ono & Lohman, 1990) find optimal plan. Since distributed
domain subqueries execute parallel cost function reflects preference,
247

fiAmbite & Knoblock

a(name sal proj) :- Emp(name ssn) ^ Payroll(ssn sal) ^ Projects(name proj)

HQ-db
Emp(name ssn)
Payroll(ssn sal)

name ssn

Branch-db
Project(name proj)

Ret Emp
@ HQ-db
Ret Payroll Ret Project
@ HQ-db @ Branch-db

ssn

name

Ret Payroll
@ HQ-db

Join
Swap

name

Remote
Join
Eval
name

Ret Emp Ret Project
@ HQ-db @ Branch-db

ssn

Ret Project
@ Branch-db

Ret Emp Ret Payroll
@ HQ-db @ HQ-db

Ret Project
@Branch-db
Ret (Emp
@HQ-db

Payroll)

Figure 30: Rewriting Query Planning
DP algorithm considers bushy join trees. However, improve planning time, DP
applies heuristic avoiding cross-products join enumeration. Thus, rare
cases DP may produce optimal plan.
Initial: initial plan generator PbR. generates query plans according
random depth-first search parse query. non-random choice places
selections soon executed. fastest planner may produce
low quality plans.
PbR: used Remote-Join-Eval Join-Swap rules defined Figure 29.
two rules sufficient optimize queries test set. tested two gradientdescent search strategies PbR: first improvement four random restarts (PbR-FI),
steepest descent three random restarts (PbR-SD).
experiment compare behavior Sage, DP, Initial, PbR-FI, PbR-SD
distributed query planning domain size queries increases. generated
synthetic domain SIMS mediator defined set conjunctive queries involving
1 30 relations. queries one selection attribute table.
information source contains two relations perform remote operations. Therefore,
optimal plans involve pushing operations evaluated remotely sources.
results experiment shown Figure 31. Figure 31(a) shows planning
time, logarithmic scale, Sage, DP, Initial, PbR-FI, PbR-SD query size
grows. times PbR include generation random initial plans
rewriting. times Initial average initial plan construction across
restarts query. Sage able solve queries involving 6 relations, larger
248

fiPlanning Rewriting

queries cannot solved within search limit 200,000 partial-plan nodes. DP scales
better Sage, cannot solve queries 9 relations 1000 second time
limit. configurations PbR scale better Sage DP. first-improvement
search strategy PbR-FI faster steepest descent PbR-SD.
Figure 31(b) shows cost query plans five planners. cost Initial
average initial plans across restarts query. plan cost
estimate query execution cost. logarithmic scale used increasingly
larger absolute values plan costs conjunctive chain queries high
cost initial plans. PbR rewrites poor quality plans generated Initial
high-quality plans. PbR DP produce better plans Sage (in range
tractable Sage) experiment. happens searching larger
space bushy query trees take greater advantage parallel execution plans. PbR
produces plans quality comparable DP tractable range beyond range
PbR scales gracefully. two configurations PbR produce plans similar cost, though
PbR-FI needed less planning time PbR-SD. PbR-SD generates plans local
neighborhood order select cheapest one, PbR-FI generates portion
neighborhood since chooses first plan cheaper cost, PbR-FI faster
average. Figure 31 shows empirically domain locally optimal moves
steepest descent translate final solutions better cost produced
first-improvement strategy.

1000

1e+18
Sage
DP
Initial
PbR-FI
PbR-SD

100

1e+14
1e+12

10

Plan Cost

Planning Time (CPU seconds)

1e+16

1
Sage
DP
Initial
PbR-FI
PbR-SD

0.1

1e+10
1e+08
1e+06
10000
100

0.01

1
0

5

10

15
Query Size

20

25

30

0

(a) Planning Time

5

10

15
Query Size

20

25

30

(b) Plan Quality

Figure 31: Experimental Results: Distributed Query Planning

5. Related Work
section review previous work related Planning Rewriting framework.
First, discuss work disciplines upon PbR builds, namely, classical AI
planning, local search, graph rewriting. Then, discuss work related planrewriting algorithm.
249

fiAmbite & Knoblock

5.1 AI Planning
PbR designed find balance among requirements planning efficiency, high quality
plans, flexibility, extensibility. great amount work AI Planning focused
improving average-case efficiency given general cases computationally hard
(Erol et al., 1995). One possibility incorporate domain knowledge form search
control. recent example TLPlan (Bacchus & Kabanza, 1995, 2000), forward-search
planner shown remarkable scalability using control knowledge expressed temporal logic. systems automatically learn search control given planning domain
even specific problem instances. Minton (1988b) shows deduce search control rules
problem solver applying explanation-based learning problem-solving traces.
discusses impact utility problem. utility problem, simply stated, says
(computational) benefits using additional knowledge must outweigh cost
applying it. PbR plan-rewriting rules subject utility problem. quality
improvement obtained adding rewriting rules PbR-based planner may
worth performance degradation. Another approach automatically generating search
control analyzing statically operators (Etzioni, 1993) inferring invariants
planning domain (Gerevini & Schubert, 1998; Fox & Long, 1998; Rintanen, 2000). Abstraction provides yet another form search control. Knoblock (1994a) presents system
automatically learns abstraction hierarchies planning domain particular problem
instance order speed planning. plan-rewriting rules learned techniques
analogous used learn search control. Ambite, Knoblock, & Minton (2000) present
approach automatically learn plan-rewriting rules based comparing initial
optimal plans example problems. Alternatively, analyzing planning operators
combinations operators equivalent respect achievement
goals lead automatic generation rewriting rules.
Local search algorithms used improve planning efficiency although
somewhat indirect way. Planning reduced solving series propositional
satisfiability problems (Kautz & Selman, 1992). Thus, Kautz & Selman (1996) used
efficient satisfiability testing algorithm based local search solve SAT encodings
planning problem. approach proved efficient specialized planning
algorithms. believe power approach stems use local search.
PbR directly applies local search plan structures, opposed translating first
larger propositional representation.
Although approaches improve efficiency planning, specifically address plan quality, else consider simple cost metrics (such
number steps). systems learn search control addresses planning efficiency
plan quality (Estlin & Mooney, 1997; Borrajo & Veloso, 1997; Perez, 1996). However,
reported experimental results, PbR appears scalable. Moreover, PbR
provides anytime algorithm approaches must run completion.
5.2 Local Search
Local search long tradition combinatorial optimization (Aarts & Lenstra, 1997;
Papadimitriou & Steiglitz, 1982). Local improvement ideas found application many
250

fiPlanning Rewriting

domains. general work relevant PbR constraint satisfaction,
scheduling, satisfiability testing, heuristic search.
constraint satisfaction, local search techniques able solve problems
orders magnitude complex respective complete (backtracking) approaches.
Minton et al. (Minton, Johnston, Philips, & Laird, 1990; Minton, 1992) developed simple
repair heuristic, min-conflicts, could solve large constraint satisfaction scheduling
problems, scheduling operations Hubble Space Telescope. minconflicts heuristic selects variable value assignment minimizes number
constraints violated. heuristic used cost function gradient-descent
search informed backtracking search.
satisfiability testing similar method, GSAT, introduced Selman, Levesque,
& Mitchell (1992). GSAT solves hard satisfiability problems using local search
repairs consist changing truth value randomly chosen variable. cost function
number clauses satisfied current truth assignment. approach scales
much better corresponding complete method (the Davis-Putnam procedure).
work scheduling rescheduling, Zweben, Daun, & Deale (1994) define set
general, fixed, repair methods, use simulated annealing search space
schedules. plans networks actions opposed metric-time totally-ordered
tasks. easily specify different rewriting rules (general specific) suit
domain, opposed fixed strategies.
work inspired approaches several differences. First, PbR
operates complex graph structures (partial-order plans) opposed variable assignments. Second, repairs declaratively specified may changed problem
domain, opposed general fixed repair strategies. Third, PbR accepts arbitrary measures quality, constraint violations min-conflicts, number
unsatisfied clauses GSAT. Finally, PbR searches space valid solution plans,
opposed space variable assignments may internally inconsistent.
Iterative repair ideas used heuristic search. Ratner & Pohl (1986)
present two-phase approach similar PbR. first phase, find initial valid
sequence operators using approximation algorithm. second phase, perform
local search starting initial sequence. cost function plan length.
local neighborhood generated identifying segments current solution sequence
attempting optimize them. repair consists heuristic search initial
state beginning segment goal end segment. shorter
path found, original sequence replaced new shorter segment. significant
difference PbR state-space search, PbR planspace search. least-committed partial-order nature PbR allows optimize
plans ways cannot achieved optimizing linear subsequences.
5.3 Graph Rewriting
PbR builds ideas graph rewriting (Schurr, 1997). plan-rewriting rules
PbR extension traditional graph rewriting rules. taking advantage
semantics planning PbR introduces partially-specified plan-rewriting rules,
rules need specify completely detailed embedding consequent pure
251

fiAmbite & Knoblock

graph rewriting. Nevertheless, several techniques transfer graph
rewriting Planning Rewriting, particularly fully-specified rules. Dorr (1995)
defines abstract machine graph isomorphism studies set conditions
traditional graph rewriting performed efficiently. Perhaps similar abstract
machine plan rewriting defined. idea rule programs appears
field implemented PROGRES system (Schurr, 1990, 1997).
5.4 Plan Rewriting
work closely related plan-rewriting algorithm plan merging (Foulser, Li, &
Yang, 1992). Foulser et al. provide formal analysis algorithms exploiting positive
interactions within plan across set plans. However, work considers
case set operators replaced one operator provides
effects rest plan consumes fewer preconditions. focus
optimal approximate algorithms type operator merging. Plan rewriting
PbR seen generalization operator merging subplan replace
another subplan. difference PbR concerned finding optimal merge
(rewritten plan) single pass optimization algorithm approach does.
PbR interested generating possible plan rewritings rewriting phase,
optimal one. optimization occurs (local) search progresses.
Case-based planning (e.g., Kambhampati, 1992; Veloso, 1994; Nebel & Koehler, 1995;
Hanks & Weld, 1995; Munoz-Avila, 1998) solves problem modifying previous solution.
two phases case-based planning. first one identifies plan library
similar current problem. second phase previous plan adapted
solve new problem. PbR modifies solution current problem,
need retrieval phase associated similarity metrics. Plan rewriting PbR
seen type adaptation solution problem alternate solution
problem. is, plan rewriting rule PbR identifies pair subplans (the
replaced replacement subplans) may interchangeable.
Veloso (1994) describes general approach case-based planning based derivational
analogy. approach works three steps. First, retrieval phase selects similar
plan library. Second, parts plan irrelevant current problem
removed. Finally, system searches completion plan selecting much
possible decisions old plan did. sense planning knowledge
encoded previous solution transferred generation new solution plan.
plan-rewriting algorithm partially-specified rules PbR seen strongly
constrained version approach. PbR subplan rule consequent fixes
steps added repair plan. could use technique respecting
previous choice points completing plan way ensuring
structure plan repair maintained. could useful
constrain number rewritten plans large rewriting rules.
Nebel Koehler (1995) present computational analysis case-based planning.
context show worst-case complexity plan modification better
plan generation point limitations reuse methods. related problem
PbR framework embedding replacement subplan partially specified rules.
252

fiPlanning Rewriting

explained Section 3.1.4 may pathological cases number
embeddings exponential size plan deciding embedding exists
NP-hard. However, often interested finding rewritings, example
following first improvement search strategy. experience average case behavior
seems much better presented Section 4.
Systematic algorithms case-based planning (such Hanks & Weld, 1995) invert
decisions done refinement planning find path solution similar old
problem new problem. rewriting rules PbR indicate transform
solution another solution plan based domain knowledge, opposed generic
inversion refinement operations. Plan rewriting PbR done constrained
way instead open search space partial plans. However, rules
PBR may search space rewritings non systematically. effect ameliorated
using local search.

6. Discussion Future Work
paper presented Planning Rewriting, new paradigm efficient high-quality
domain-independent planning. PbR adapts graph rewriting local search techniques
semantics domain-independent partial-order planning. basic idea PbR
consists transforming easy-to-generate, possibly suboptimal, initial plan
high-quality plan applying declarative plan-rewriting rules iterative repair style.
several important advantages PbR planning approach. First, PbR
declarative domain-independent framework, brings benefits reusability
extensibility. Second, addresses sophisticated plan quality measures, work
domain-independent planning addressed quality simple ways.
Third, PbR scalable uses efficient local search methods. Finally, PbR
anytime planning algorithm allows balancing planning effort plan quality order
maximize utility planning process.
Planning Rewriting provides domain-independent framework local search. PbR
accepts declarative domain specifications expressive operator language, declarative
plan-rewriting rules generate neighborhood plan, complex quality metrics, interchangeable initial plan generators, arbitrary (local) search methods.
Planning Rewriting well suited mixed-initiative planning. mixed-initiative
planning, user planner interact defining plan. example, user
specify available preferred actions moment, change quality criteria interest, etc. fact, domains approached mixed-initiative
planning. example, quality metric expensive evaluate,
geometric analysis manufacturing, user must guide planner towards good quality
plans way small number plans generated evaluated. Another example
plan quality metric multi-objective changes time. Several characteristics PbR support mixed-initiative planning. First, PbR offers complete plans,
user easily understand plan perform complex quality assessment. Second,
rewriting rule language convenient mechanism user propose modifications plans. Third, selecting rules apply order application
user guide planner.
253

fiAmbite & Knoblock

framework achieves balance domain knowledge, expressed plan-rewriting
rules, general local-search techniques proved useful many hard combinatorial problems. expect ideas push frontier solvable problems
many practical domains high quality plans anytime behavior needed.
planning style introduced PbR opens several areas future research.
great potential applying machine learning techniques PbR. important issue
generation plan-rewriting rules. Conceptually, plan-rewriting rules arise
chosen plan equivalence relation. valid plans achieve given goals finite
number steps, i.e. solution plans, (satisfiability) equivalent. rule arises
theorem states two subplans equivalent purposes achieving
goals, addition conditions indicate context rule
usefully applied. plan-rewriting rules generated automated procedures.
methods range static analysis domain operators analysis sample
equivalent plans achieve goals different costs. Note similarity
methods automatically infer search control domain invariants (Minton, 1988b;
Etzioni, 1993; Gerevini & Schubert, 1998; Fox & Long, 1998; Rintanen, 2000),
need deal utility problem. Ambite, Knoblock, & Minton (2000) present
results learning plan rewriting rules based comparing initial optimal plans
sample problems.
Beyond learning rewriting rules, intend develop system automatically learn optimal planner configuration given planning domain problem
distribution manner analogous Mintons Multi-TAC system (Minton, 1996).
system would perform search configuration space PbR planner proposing
candidate sets rewriting rules different search methods. testing proposed
configuration training set simple problems, system would hill-climb
configuration space order arrive useful rewriting rules search strategies
given planning domain distribution problems.
many advanced techniques local search literature adapted
extended framework. particular, idea variable-depth rewriting leads
naturally creation rule programs, specify set rules applied
plan. already seen query planning could find transformations
better specified program simple rewriting rules. example, sequence
Join-Swap transformations may put two retrieve operators database together
query tree Remote-Join-Eval would collapse explicit join operator
two retrieves single retrieval remote join. Cherniack & Zdonik (1996, 1998)
present complex examples sort programs rewriting rules context
query optimizer object-oriented databases.
discussed Sections 3.1.3 3.1.4 language antecedent rewriting rules expressive conjunctive queries still remaining computationally efficient. example, Figure 32 shows rule manufacturing domain
Section 4.1 relationally-complete antecedent. rule matches subplan contains spray-paint operator, contain either punch drill-press operators
create holes diameter smaller 1 millimeter. case, rule replaces
spray-paint operator immersion-paint operator. rule would useful
situation painting immersion could clog small holes.
254

fiPlanning Rewriting

(define-rule :name SP-by-IP-no-small-holes
:if (:and (:operator ?n1 (spray-paint ?x ?c ?s))
(:not (:and (:or (:operator ?n2 (punch ?x ?w ?o))
(:operator ?n3 (drill-press ?x ?w ?o)))
(:less ?w 1mm))))
:replace (:operators (?n1))
:with (:operator ?n4 (immersion-paint ?x ?c)))

Figure 32: Rule Relationally-Complete Antecedent
Another area research interplay plan rewriting plan execution.
Sometimes best transformations plan may known portion
plan executed. information obtained run-time guide planner
select appropriate rewritings. example, query planning plans may contain
information gathering actions (Ashish, Knoblock, & Levy, 1997) depend run-time
conditions. yields form dynamic query optimization. Interleaved planning
execution necessary order deal effectively unexpected situations
environment database network failures.
open area research relax framework accept incomplete plans
rewriting process. expands search space considerably benefits
PbR, anytime property, lost. domains shortest path
rewritings initial plan optimal may pass incomplete inconsistent
plans. idea could embodied planning style combines characteristics
generative planning Planning Rewriting. reminiscent plan critics
approach (Sacerdoti, 1975; Sussman, 1975). resulting plan-rewriting rules seen
declarative specifications plan critics. plan refinements partial order
planning (Kambhampati et al., 1995) Hierarchical Task Network Planning (Erol, Nau,
& Hendler, 1994) easily specified plan-rewriting rules.
Applying PbR domains surely provide new challenges possibility
discovering transferring general planning techniques one domain another.
hope local-search methods used PbR help planning techniques scale
large practical problems conversely domain-independent nature PbR
help analysis principled extension local search techniques.

Acknowledgments
paper extended version (Ambite & Knoblock, 1997).
research reported supported part Fulbright/Ministerio Educacion
Ciencia Spain scholarship, part Defense Advanced Research Projects Agency
(DARPA) Air Force Research Laboratory, Air Force Materiel Command, USAF,
agreement number F30602-00-1-0504, part National Science Foundation
grant number IRI-9313993, part Rome Laboratory Air Force Systems Command Defense Advanced Research Projects Agency (DARPA) contract numbers F30602-94-C-0210, F30602-97-2-0352, F30602-97-2-0238, F30602-98-2-0109, part
United States Air Force contract number F49620-98-1-0046, part
Integrated Media Systems Center, National Science Foundation Engineering Research
255

fiAmbite & Knoblock

Center, Cooperative Agreement No. EEC-9529152. U.S.Government authorized
reproduce distribute reports Governmental purposes notwithstanding copyright
annotation thereon. views conclusions contained herein authors
interpreted necessarily representing official policies endorsements,
either expressed implied, organizations person connected
them.

References
Aarts, E., & Lenstra, J. K. (1997). Local Search Combinatorial Optimization. John Wiley
Sons, Chichester, England.
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations Databases. Addison-Wesley.
Ambite, J. L. (1998). Planning Rewriting. Ph.D. thesis, University Southern California.
Ambite, J. L., & Knoblock, C. A. (1997). Planning rewriting: Efficiently generating
high-quality plans. Proceedings Fourteenth National Conference Artificial
Intelligence, pp. 706713 Providence, RI.
Ambite, J. L., & Knoblock, C. A. (2000). Flexible scalable cost-based query planning
mediators: transformational approach. Artificial Intelligence, 118 (1-2), 115161.
Ambite, J. L., Knoblock, C. A., & Minton, S. (2000). Learning plan rewriting rules.
Proceedings Fifth International Conference Artificial Intelligence Planning
Scheduling Systems Breckenridge, CO.
Ashish, N., Knoblock, C. A., & Levy, A. (1997). Information gathering plans sensing
actions. Steel, S., & Alami, R. (Eds.), Recent Advances AI Planning: 4th
European Conference Planning, ECP97. Springer-Verlag, New York.
Avenhaus, J., & Madlener, K. (1990). Term rewriting equational reasoning. Formal
Techniques Artificial Intelligence, pp. 143. Elsevier, North Holland.
Baader, F., & Nipkow, T. (1998). Term Rewriting That. Cambridge University
Press.
Bacchus, F., & Kabanza, F. (1995). Using temporal logic control search forward
chaining planner. Proceedings 3rd European Workshop Planning.
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116 (12), 123191.
Backstrom, C. (1994a). Executing parallel plans faster adding actions. Cohn, A. G.
(Ed.), Proceedings Eleventh European Conference Artificial Intelligence, pp.
615619 Amsterdam, Netherlands. John Wiley Sons.
Backstrom, C. (1994b). Finding least constrained plans optimal parallel executions
harder thought. Backstrom, C., & Sandewell, E. (Eds.), Current Trends
AI Planning: Proceedings 2nd European Workshop Planning (EWSP-93),
pp. 4659 Vadstena, Sweeden. IOS Press (Amsterdam).
256

fiPlanning Rewriting

Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11 (4), 625655.
Blum, A. L., & Furst, M. L. (1995). Fast planning planning graph analysis.
Proceedings Fourteenth International Joint Conference Artificial Intelligence
Montreal, Canada.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90 (12), 281300.
Bonet, B., & Geffner, H. (1999). Planning heuristic search: New results. Proceedings
Fifth European Conference Planning (ECP-99) Durham, UK.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism planning. Proceedings Fourteenth National Conference Artificial
Intelligence, pp. 714719 Providence, RI.
Borrajo, D., & Veloso, M. (1997). Lazy incremental learning control knowledge
efficiently obtaining quality plans. AI Review, 11, 371405.
Bylander, T. (1994). computation complexity propositional strips. Artificial Intelligence, 69 (1-2), 165204.
Carbonell, J. G., Knoblock, C. A., & Minton, S. (1991). PRODIGY: integrated architecture planning learning. VanLehn, K. (Ed.), Architectures Intelligence,
pp. 241278. Lawrence Erlbaum, Hillsdale, NJ.
Cherniack, M., & Zdonik, S. B. (1996). Rule languages internal algebras rule-based
optimizers. SIGMOD Record (ACM Special Interest Group Management Data),
25 (2), 401412.
Cherniack, M., & Zdonik, S. B. (1998). Changing rules: Transformations rulebased optimizers. Proceedings ACM SIGMOD International Conference
Management Data, pp. 6172 Seattle, WA.
Dean, T., & Boddy, M. (1988). analysis time-dependent planning. Proceedings
Seventh National Conference Artificial Intelligence, pp. 4954 Saint Paul, MN.
Dorr, H. (1995). Efficient graph rewriting implementation, Vol. 922 Lecture Notes
Computer Science. Springer-Verlag Inc., New York, NY, USA.
Erol, K., Nau, D., & Hendler, J. (1994). UMCP: sound complete planning procedure
hierarchical task-network planning. Proceedings Second International
Conference Artificial Intelligence Planning Systems, pp. 249254 Chicago, IL.
Erol, K., Nau, D., & Subrahmanian, V. S. (1995). Decidability undecidability results
domain-independent planning. Artificial Intelligence, 76 (1-2), 7588.
Estlin, T. A., & Mooney, R. J. (1997). Learning improve efficiency quality
planning. Proceedings Fifteenth International Joint Conference Artificial
Intelligence, pp. 12271233 Nagoya, Japan.
257

fiAmbite & Knoblock

Etzioni, O. (1993). Acquiring search-control knowledge via static analysis. Artificial Intelligence, 62 (2), 255302.
Etzioni, O., & Weld, D. S. (1994). softbot-based interface Internet. Communications ACM, 37 (7).
Fikes, R. E., & Nilsson, N. J. (1971). STRIPS: new approach application
theorem proving problem solving. Artificial Intelligence, 2 (3/4), 189208.
Forgy, C. L. (1982). Rete: fast algorithm many pattern/many object pattern
match problem. Artificial Intelligence, 19, 1737.
Foulser, D. E., Li, M., & Yang, Q. (1992). Theory algorithms plan merging. Artificial
Intelligence, 57 (23), 143182.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificicial Intelligence Research, 9, 367421.
Gerevini, A., & Schubert, L. (1998). Inferring state constraints domain-independent
planning. Proceedings Fifteenth National Conference Artificial Intelligence, pp. 905912 Madison, WI.
Glover, F. (1989). Tabu searchPart I. ORSA Journal Computing, 1 (3), 190206.
Gomes, C. P., Selman, B., & Kautz, H. (1998). Boosting combinatorial search
randomization. Proceedings Fifteenth National Conference Artificial Intelligence Madison, WI.
Gupta, N., & Nau, D. S. (1992). complexity blocks-world planning. Artificial
Intelligence, 56 (23), 223254.
Hanks, S., & Weld, D. S. (1995). domain-independent algorithm plan adaptation.
Journal Artificicial Intelligence Research, 2, 319360.
Johnson, D. S. (1990). Local optimization traveling salesman problem. Paterson,
M. S. (Ed.), Automata, Languages Programming: Proc. 17th International
Colloquium, pp. 446461. Springer, New York.
Kambhampati, S. (1992). validation-structure-based theory plan modification
reuse. Artificial Intelligence, 55 (2-3), 193258.
Kambhampati, S., Knoblock, C. A., & Yang, Q. (1995). Planning refinement search:
unified framework evaluating design tradeoffs partial order planning.
Artificial Intelligence, 76 (1-2), 167238.
Kautz, H., & Selman, B. (1992). Planning satisfiability. Neumann, B. (Ed.), Proceedings 10th European Conference Artificial Intelligence, pp. 359363 Vienna,
Austria. John Wiley & Sons.
258

fiPlanning Rewriting

Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings Thirteenth National Conference Artificial
Intelligence, pp. 11941201 Portland, OR.
Kirkpatrick, S., Gelatt, C. D., & Vecchi, M. P. (1983). Optimization simulated annealing.
Science, 220, 671680.
Knoblock, C. A. (1994a). Automatically generating abstractions planning. Artificial
Intelligence, 68 (2), 243302.
Knoblock, C. A. (1994b). Generating parallel execution plans partial-order planner. Proceedings Second International Conference Artificial Intelligence
Planning Systems Chicago, IL.
Knoblock, C. A. (1995). Planning, executing, sensing, replanning information gathering. Proceedings Fourteenth International Joint Conference Artificial
Intelligence Montreal, Canada.
Knoblock, C. A. (1996). Building planner information gathering: report
trenches. Proceedings Third International Conference Artificial Intelligence Planning Systems Edinburgh, Scotland.
Koehler, J. (1998). Solving complex planning tasks extraction subproblems.
Simmons, R., Veloso, M., & Smith, S. (Eds.), Proceedings Fourth International
Conference Artificial Intelligence Planning Systems, pp. 6269 Pittsburgh, PA.
Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Artificial Intelligence Research,
12, 338386.
Koehler, J., Nebel, B., Hoffman, J., & Dimopoulos, Y. (1997). Extending planning graphs
ADL subset. Steel, S., & Alami, R. (Eds.), Proceedings Fourth European
Conference Planning (ECP-97): Recent Advances AI Planning, Vol. 1348
LNAI, pp. 273285 Berlin. Springer.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
Ninth National Conference Artificial Intelligence Anaheim, CA.
Minton, S. (1988a). Learning Effective Search Control Knowledge: Explanation-Based
Approach. Ph.D. thesis, Computer Science Department, Carnegie Mellon University.
Minton, S. (1988b). Learning Search Control Knowledge: Explanation-Based Approach.
Kluwer, Boston, MA.
Minton, S. (1992). Minimizing conflicts: heuristic repair method constraintsatisfaction scheduling problems. Artificial Intelligence, 58 (1-3), 161205.
Minton, S. (1996). Automatically configuring constraint satisfaction programs: case
study. Constraints, 1 (1), 743.
259

fiAmbite & Knoblock

Minton, S., Johnston, M. D., Philips, A. B., & Laird, P. (1990). Solving large-scale constraint satisfaction scheduling problems using heuristic repair method. Proceedings Eighth National Conference Artificial Intelligence, pp. 1724 Boston,
MA.
Munoz-Avila, H. (1998). Integrating Twofold Case Retrieval Complete Decision Replay
CAPlan/CbC. Ph.D. thesis, University Kaiserslautern.
Nau, D. S., Gupta, S. K., & Regli, W. C. (1995). AI planning versus manufacturingoperation planning: case study. Proceedings Fourteenth International
Joint Conference Artificial Intelligence Montreal, Canada.
Nebel, B., & Koehler, J. (1995). Plan reuse versus plan generation: theoretical
empirical analysis. Artificial Intelligence, 76 ((1-2)), 427454.
Ono, K., & Lohman, G. M. (1990). Measuring complexity join enumeration query
optimization. McLeod, D., Sacks-Davis, R., & Schek, H.-J. (Eds.), 16th International Conference Large Data Bases, pp. 314325 Brisbane, Queensland,
Australia. Morgan Kaufmann.
Papadimitriou, C. H., & Steiglitz, K. (1977). complexity local search
traveling salesman problem. SIAM, 6 (1), 7683.
Papadimitriou, C. H., & Steiglitz, K. (1982). Combinatorial Optimization: Algorithms
Complexity. Prentice Hall, Englewood Cliffs, NJ.
Penberthy, J. S., & Weld, D. S. (1992). UCPOP: sound, complete, partial order planner
ADL. Third International Conference Principles Knowledge Representation
Reasoning, pp. 189197 Cambridge, MA.
Perez, M. A. (1996). Representing learning quality-improving search control knowledge.
Proceedings Thirteenth International Conference Machine Learning Bari,
Italy.
Ratner, D., & Pohl, I. (1986). Joint LPA*: Combination approximation search.
Proceedings Fifth National Conference Artificial Intelligence Philadelphia,
PA.
Rintanen, J. (2000). iterative algorithm synthesizing invariants. Proceedings
Seventeenth National Conference Artificial Intelligence Austin, TX.
Russell, S., & Norvig, P. (1995). Artificial Intelligence: Modern Approach. Prentice Hall.
Sacerdoti, E. D. (1975). nonlinear nature plans. Proceedings Fourth
International Joint Conference Artificial Intelligence, pp. 206214 Tbilisi, Georgia,
USSR.
Savage, S., Weiner, P., & Bagchi, A. (1976). Neighborhood search algorithms guaranteeing optimal traveling salesman tours must inefficient. Journal Computer
System Sciences, 12 (1), 2535.
260

fiPlanning Rewriting

Schurr, A. (1990). Introduction PROGRES, attribute graph grammar based specification language. Nagl, M. (Ed.), Graph-Theoretic Concepts Computer Science,
Vol. 411 Lecture Notes Computer Science, pp. 151165.
Schurr, A. (1997). Programmed graph replacement systems. Rozenberg, G. (Ed.),
Handbook Graph Grammars: Foundations, Vol. 1, pp. 479546. World Scientific,
Singapore.
Sellis, T. K. (1988). Multiple-query optimization. ACM Transactions Database Systems,
13 (1), 2352.
Selman, B., Levesque, H., & Mitchell, D. (1992). new method solving hard satisfiability
problems. Proceedings Tenth National Conference Artificial Intelligence
(AAAI-92), pp. 440446 San Jose, California. AAAI Press.
Silberschatz, A., Korth, H. F., & Sudarshan, S. (1997). Database System Concepts (Third
edition). McGraw-Hill.
Simon, H. (1969). sciences artificial. MIT Press.
Slaney, J., & Thiebaux, S. (1996). Linear time near-optimal planning blocks world.
Proceedings Thirteenth National Conference Artificial Intelligence
Eighth Innovative Applications Artificial Intelligence Conference, pp. 12081214
Menlo Park. AAAI Press / MIT Press.
Sussman, G. J. (1975). Computer Model Skill Acquisition. American Elsevier, New
York.
Veloso, M. (1994). Planning Learning Analogical Reasoning. Springer Verlag.
Veloso, M. M., Perez, M. A., & Carbonell, J. G. (1990). Nonlinear planning parallel
resource allocation. Proceedings Workshop Innovative Approaches
Planning, Scheduling Control, pp. 207212 San Diego, CA.
Weld, D. S. (1994). introduction least commitment planning. AI Magazine, 15 (4).
Weld, D. S. (1999). Recent advances AI planning. AI Magazine, 20 (2).
Yu, C., & Chang, C. (1984). Distributed query processing. ACM Computing Surveys, 16 (4),
399433.
Zweben, M., Daun, B., & Deale, M. (1994). Scheduling rescheduling iterative
repair. Intelligent Scheduling, pp. 241255. Morgan Kaufman, San Mateo, CA.

261


