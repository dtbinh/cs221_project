Journal Artificial Intelligence Research 41 (2011) 155-229

Submitted 01/11; published 06/11

Analyzing Search Topology Without Running Search:
Connection Causal Graphs h+
Jorg Hoffmann

joerg.hoffmann@inria.fr

INRIA
Nancy, France

Abstract
ignoring delete lists relaxation paramount importance satisficing
optimal planning. earlier work, observed optimal relaxation heuristic
h+ amazing qualities many classical planning benchmarks, particular pertaining
complete absence local minima. proofs hand-made, raising
question whether proofs lead automatically domain analysis techniques.
contrast earlier disappointing results analysis method exponential runtime
succeeds two extremely simple benchmark domains herein answer
question affirmative. establish connections causal graph structure
h+ topology. results low-order polynomial time analysis methods, implemented
tool call TorchLight. 12 domains absence local minima
proved, TorchLight gives strong success guarantees 8 domains. Empirically, analysis
exhibits strong performance 2 domains, plus 4 domains
local minima may exist rare. way, TorchLight distinguish easy domains
hard ones. summarizing structural reasons analysis failure, TorchLight
provides diagnostic output indicating domain aspects may cause local minima.

1. Introduction
ignoring delete lists relaxation since decade, still is, paramount
importance effective satisficing planning (e.g., McDermott, 1999; Bonet & Geffner, 2001;
Hoffmann & Nebel, 2001a; Gerevini, Saetti, & Serina, 2003; Helmert, 2006; Richter &
Westphal, 2010). recently, heuristics making relaxation shown
boost optimal planning (Karpas & Domshlak, 2009; Helmert & Domshlak, 2009).
planners using relaxation approximate, variety ways, optimal relaxation
heuristic h+ NP-hard compute (Bylander, 1994). observed
earlier work (Hoffmann, 2005), h+ rather amazing qualities many classical
planning benchmarks. Figure 1 gives overview results.1
results divide domains classes along two dimensions. herein ignore horizontal dimension, pertaining dead ends, domain analysis already available:
easy-to-test powerful criteria implying task undirected/harmless known
(e.g., Hoffmann, 2005). vertical dimension divides domains three classes,
respect behavior exit distance, defined 1 distance state
strictly smaller h+ value. easiest bottom class, exist constant upper
1. omit ADL domains, add recent IPC benchmarks Elevators Transport (without
action costs), properties trivial prove based earlier results. Blocksworld-Arm
classical blocksworld, Blocksworld-NoArm variant allowing move B C directly.
c
2011
AI Access Foundation. rights reserved.

fiHoffmann

PipesworldTank
PipesworldNoTank
PSR

Rovers
OpticalTelegraph

Mystery
Mprime
Freecell
Airport

Hanoi [0]
BlocksworldNoArm [0]
Grid [0]
Transport [0]
bench ed <= c

local minima ed <= c

BlocksworldArm
Depots
Driverlog

Elevators [0,1]
Logistics [0,1]
Ferry [0,1]
Gripper [0,1]
undirected

Tyreworld [0,6]
Satellite [4,4]
Zenotravel [2,2]
MiconicSTRIPS [0,1]
Movie [0,1]
SimpleTsp [0,0]
harmless

DiningPhil. [31,31]

recognized

unrecognized

Figure 1: Overview h+ topology (Hoffmann, 2005).
bounds exit distance both, states local minima states benches (flat regions). figure, bounds given square brackets. example, Logistics,
bound local minima 0 meaning local minima exist bound
benches 1. middle class, bound exists local minima; bound
0 (no local minima all) domains shown. hardest top class, local
minima benches may take arbitrarily many steps escape.
proofs underlying Figure 1 hand-made. dealing unseen domains,
question arises whether design domain analysis methods leading proofs
automatically. potential uses analysis methods manifold; discuss
end paper. now, note addressing question formidable challenge.
trying automatically infer properties characterizing informativeness (or lack
thereof ) heuristic function. wish based static analysis, actually
running search. Formally characterizing informativeness heuristic function
is, cases, hardly possible even experienced researchers, explains perhaps
no-one far even attempted automatically. single exception,
best authors knowledge, analysis method mentioned side
authors earlier work (Hoffmann, 2005). analysis method builds exponentially
large tree structure summarizing ways relaxed plans may generate facts.
tree size, therewith analysis runtime, explodes quickly task size. Worse,
analysis succeeds Movie Simple-TSP arguably two simplistic planning
benchmarks existence.2
contrast, TorchLight tool developed herein low-order polynomial runtime
usually terminates split seconds. Distinguishing global (per task) local (per
state) analysis, proves global absence local minima Movie, Simple-TSP, Logistics,
Miconic-STRIPS. gives strong guarantee local analysis succeed every state
Ferry, Gripper, Elevators, Transport. Taking success rate fraction
states local analysis succeeds, TorchLight empirically exhibits strong performance
delivering high success rates Zenotravel, Satellite, Tyreworld, Grid, Driverlog,
2. Simple-TSP encodes TSP fully connected graph uniform edge cost. domain
introduced Fox Long (1999) benchmark symmetry detection.

156

fiAnalyzing Search Topology Without Running Search

Rovers. Thus TorchLights success rates tend high easy domains Figure 1,
low hard ones, serving automatically distinguish two
groups.3 summarizing structural reasons analysis failure, TorchLight finally provides
diagnostic output indicating problematic aspects domain, i.e., operator effects
potentially cause local minima h+ .
key performance boost? Consider Logistics Blocksworld-Arm.
level PDDL domain descriptions, difference evident
delete effects, Blocksworld-Arm hurt Logistics dont?
trick move finite-domain variable representation (e.g., Jonsson &
Backstrom, 1998; Helmert, 2006, 2009) consider associated structures, notably
causal graph (e.g., Knoblock, 1994; Jonsson & Backstrom, 1995; Domshlak & Dinitz,
2001; Helmert, 2006) capturing precondition effect dependencies variables.
causal graph Blocksworld-Arm contains cycles. Logistics doesnt. Looking
this, surprisingly easy derive following basic result:
causal graph acyclic, every variable transition invertible,
local minima h+ .
result certainly interesting that, first time, establishes connection
causal graph structure h+ topology. However, result much
weak domain analysis considered benchmarks, applies Logistics. devise generalizations approximations yielding analysis results described
above. Aside significance domain analysis, techniques interesting
respect research causal graphs. Whereas traditional methods (e.g., Jonsson &
Backstrom, 1995; Brafman & Domshlak, 2003; Jonsson, 2009; Gimenez & Jonsson, 2009a)
seek execution paths solving overall task, seek execution paths decreasing
value h+ . local analysis, enables us consider small fragments causal
graph, creating potential successfully analyze states tasks whose causal graphs
otherwise arbitrarily complex.
next section gives brief background planning finite-domain variables,
associated notions causal graphs definition h+ topology. Section 3 gives illustrative example explaining basic result, Section 4 provides
synopsis full technical results relating causal graphs h+ topology. Sections 5
6 present results detail, explaining first analyze state
provided given optimal relaxed plan input, thereafter providing
criteria causal graph structure implying analysis always succeed. evaluate domain analysis technique proving number domain-specific performance
guarantees Section 7, reporting large-scale experiment TorchLight Section 8. point related work within context appropriate, discuss details
Section 9. close paper discussion future work Section 10. improve
readability, main text omits many technical details outlines proofs.
full details including proofs Appendix A.
3. extent, particular result achieved simpler means (limited search probing).
discuss along experiments Section 8.

157

fiHoffmann

2. Background
adopt terminology notation Helmert (2006), number modifications
suiting purposes. (finite-domain variable) planning task 4-tuple (X, sI , sG , O). X
finite set variables, x X associated finite domain Dx . partial
state X function subset Xs X, s(x) Dx x Xs ; state
Xs = X. initial state sI state. goal sG partial state. finite set
operators. pair = (preo , eff ) partial states, called precondition
effect. simple non-restricting sanity conditions, assume |Dx | > 1 x X,
preo (x) 6= eff (x) x Xpreo Xeff .
identify partial states sets variable-value pairs, often refer
facts. state space task directed graph whose vertices states
X, arc (s, s0 ) iff exists preo s, eff s0 , s(x) = s0 (x)
x X \ Xeff . plan path leading sI state sG s.
next define two basic structures analysis: domain transition graphs
causal graphs. former, diverge Helmerts definition (only)
introduce additional notations indicating operator responsible transition, well
side effects transition, i.e., variable values set executing
responsible operator. detail, let x X. domain transition graph DT Gx x
labeled directed graph vertex set Dx following arcs.
x Xpreo Xeff c := preo (x) c0 := eff (x), DT Gx contains arc (c, c0 ) labeled
responsible operator rop(c, c0 ) := o, conditions cond(c, c0 ) := preo \ {(x, c)},
side effects seff(c, c0 ) := eff \ {(x, c0 )}. x Xeff \ Xpreo
c0 := eff (x), every c Dx c 6= c0 , DT Gx contains arc (c, c0 ) labeled
rop(c, c0 ) := o, cond(c, c0 ) := preo , seff(c, c0 ) := eff \ {(x, c0 )}.
reader familiar causal graphs may wondered introduced notion
side effects, seeing causal graphs acyclic operators unary (affect
single variable). reason handle cases operators nonunary. variant causal graphs use still acyclic cases, indeed
happens benchmark domains, specifically Simple-TSP, Movie, MiconicSTRIPS, Satellite. define support graph SG directed graph vertex
set X, arc (x, y) iff DT Gy relevant transition (c, c0 )
x Xcond(c,c0 ) .
0
0
Here, transition (c, c ) variable x called relevant iff (x, c ) sG oO preo .
definition modifies commonly used one uses relevant transitions
only, introduce arcs variables co-occurring operator
effect (unless variables occur precondition). Transitions side effects
handled separately analysis. Note irrelevant transitions occur naturally,
domains non-unary operators. example, unstacking block induces irrelevant
transition making arm non-empty, departing passenger Miconic-STRIPS makes
passenger not-boarded.4
Consider definition h+ . common Boolean-variable setting
PDDL, defined length shortest plan solving problem ignoring
4. remark relevant transitions correspond called requestable values
works, (e.g., Jonsson & Backstrom, 1998; Haslum, 2007). Fast Downwards implementation,
causal graph includes precondition-effect arcs, similarly support graph defined here.

158

fiAnalyzing Search Topology Without Running Search

delete lists, i.e., negative operator effects (Bylander, 1994; McDermott, 1999; Bonet
& Geffner, 2001). raises question h+ actually is, finite-domain variable
planning, delete lists. question easily answered. Ignoring
deletes essentially means act true remain true forever.
finite-domain variable setting, simply means over-write values
variables previously. knowledge, generalization first described
Helmert (2006). Consider directed graph + whose vertices sets s+ variable+
+
value pairs X, arc (s+
1 , s2 ) iff exists preo s1
+
+
+
s2 = s1 eff . state, relaxed plan path leading
s+ sG s+ . h+ (s) denote length shortest relaxed plan s,
h+ (s) = plan exists. easy see definition corresponds
common Boolean one: translate finite-domain variables Boolean ones
creating one Boolean variable is-(x, c)-true? every fact (x, c), standard h+
Boolean task identical h+ finite-domain variable task.
Bylander (1994) proved intractable compute h+ . Many state-of-the-art
planners approximate h+ , variety ways (e.g., McDermott, 1999; Bonet & Geffner,
2001; Hoffmann & Nebel, 2001a; Gerevini et al., 2003; Helmert, 2006; Richter, Helmert,
& Westphal, 2008; Richter & Westphal, 2010). popular approximation satisficing
planning gives guarantees quality relaxed plan returned
so-called relaxed plan heuristic first proposed system (Hoffmann & Nebel, 2001a),
approximates h+ terms length necessarily shortest relaxed plan.
relaxed plans computed low-order polynomial time using techniques inspired
Graphplan (Blum & Furst, 1997).
next introduce relevant notations pertaining search space topology h+ .
Let state 0 < h+ (s) < . exit state s0 reachable
S, h+ (s0 ) = h+ (s) exists neighbor s00 s0 h+ (s00 ) < h+ (s0 )
(and thus h+ (s00 ) < h+ (s)). exit distance ed(s) length shortest path
exit, ed(s) = exit exists. path called monotone iff exist
two consecutive states s1 s2 h+ (s1 ) < h+ (s2 ). say local
minimum exists monotone path exit.
topology definitions, adapted authors previous work (Hoffmann, 2005),
specific h+ sake simplicity (we herein consider heuristics
h+ ).5 States infinite heuristic value ignored correctly
identified, heuristic, dead ends (relaxed-plan based approximations
identify cases). heuristic value 0 already reached
goal, case safely ignored. Note force exit paths
monotone, i.e., talk exit distances situations may
local minimum. necessary capture structure domains Satellite
Zenotravel, local minima exist exit distance bounded. Also,
analysis methods guarantee upper bound length exit path only,
heuristic values path decrease monotonically.
5. remark original definitions significantly involved, e.g., defining local minima
based individual states based strongly connected sub-graphs state space. None
complications relevant results herein.

159

fiHoffmann

Finally, let us say words domain analysis. Generally speaking, domain analysis
aims automatically obtaining non-trivial information domain planning task.
analysis long tradition planning (e.g., Nebel, Dimopoulos, & Koehler, 1997;
Fox & Long, 1998; Gerevini & Schubert, 1998; Edelkamp & Helmert, 1999; Rintanen,
2000). often, information sought pertains reachability relevance properties,
i.e., entities combinations thereof reachable initial state/relevant
goal. notable exception work Long Fox (2000) automatically
recognizes certain generic types domains, transportation. However, exists
prior work trying automatically infer topological properties heuristic function.
single exception aforementioned disappointing results reported (as aside)
authors previous work (Hoffmann, 2005). method builds structure called
fact generation tree, enumerating ways facts may support
non-redundant relaxed plan. conflict h+ exact solution distance.
Clearly, far strong property applicable reasonably complex domain.
considered benchmarks, property applies Simple-TSP. slightly
general property, identified work, applies Movie well trivial Logistics
tasks 2 locations, 1 truck, 1 package.
worth noting analyzing topology h+ computationally hard:
Theorem 1. PSPACE-complete decide whether state space given
planning task contains local minimum, given integer K PSPACE-complete
decide whether states ed(s) K. Further, PSPACE-complete
decide whether given state local minimum, given integer K
PSPACE-complete decide whether ed(s) K.
results hardly surprising, stated anywhere yet. membership results Theorem 1 easy prove based guess-and-check arguments similar
given Bylander (1994), exploiting fact NPSPACE=PSPACE. hardness results still hold restricting input solvable tasks/states. proofs work
reducing plan existence, respectively bounded plan existence (with bound non-unary
representation). Given task whose plan existence wish decide, flatten h+
new operator always achieve goal fatal side effect. give
planner choice solving task, solving new alternative task. latter task designed local minimum exists/that exit distance exceeds bound
iff planner must choose alternative task, i.e., iff original task unsolvable/iff
cannot solved within given number steps. full proof Appendix A.1.
practice, computational hardness particularly challenging because,
applications domain analysis, willing run worst-case exponential search.
all, analysis actually solve problem. Consequently, present
research, restrict analysis methods low-order polynomial runtime.
reader noticed state-specific analysis problems Theorem 1.
distinguish global analysis per-task, local analysis per-state. precisely,
herein devise three kinds analyses:
(I) Guaranteed global analysis. Taking input planning task description,
analysis returns yes, state space contain local minima
exit distance state bounded d.
160

fiAnalyzing Search Topology Without Running Search

(II) Guaranteed local analysis. Taking input planning task description
state s, analysis returns yes, local minimum, exit
distance bounded d.
(III) Approximate local analysis. Taking input planning task description
state s, analysis returns yes, indicate local minimum,
exit distance bounded d. may wrong, i.e., analysis
guaranteed sound. Compared analysis (II), trades soundness
ability successfully analyze states.
Domain analysis traditionally considers global variant (I), even generalizing
variants looking PDDL domain file. global once-and-for-all analysis
holy grail work, local analysis strong advantages. planning task
contain local minima one would expect typically case interesting
domains analysis (I) useless. simply answer no. contrast, local analysis
(II,III) may still detect individual states, sample randomly experiments,
local minima. percentage states, refer success rate,
deliver useful information matter structure planning task is. Note
that, contrast PSPACE-hard problem low-order polynomial
analysis runtime necessarily implies analyses incomplete, local analyses
chance ameliorate averaging outcome set sample states.

3. Illustrative Example
basic connection identify causal graphs h+ topology precisely,
support graphs, domain transition graphs, h+ topology quite simple.
instructive understand first, delving full results. Figure 2 shows
fragments domain transition graphs (DTGs) three variables x0 , x1 , x2 .
DTG transitions assumed invertible, side effects.
t0

x0
g0
T2

T1

x1

L1

L2

L3

s1 R1

R2

R3

x2
c1

c2

s2

Figure 2: example illustrating basic result.
imaginative reader invited think x0 car whose battery currently
empty therefore requires help two people, x1 x2 , order push-start
it. people may, solve different parts task, required purposes too,
consider sub-problem achieving goal x0 = g0 . wish take
161

fiHoffmann

x0 transition t0 , two conditions c1 c2 . conditions currently
fulfilled. state hand, x1 s1 x2 s2 . must move different
state, s0 , x1 = c1 x2 = c2 . happen h+ along way?
Say optimal relaxed plan P + (s) moves x1 c1 along path marked T1 ,
moves x2 c2 along path marked T2 clearly, paths taken
P + (s). Key observation (1) similar phenomenon known transportation
benchmarks. moving x1 x2 , whichever state s0 in, long s0 remains
within boundaries values traversed T1 T2 , construct relaxed plan
P + (s0 ) s0 |P + (s0 )| |P + (s)|. Namely, obtain P + (s0 ), simply replace


respective move sequence
P + (s), = 1, 2, inverse
. example, say


0
got 1 = hR1, R2, R3i moving x1 c1 , indicated Figure 2. wlog
P + (s) form hR1, R2, R3i P . define P + (s0 ) := hL3, L2, L1i P . postfix P
relaxed plans same; end prefix, set values achieved x1 ,
namely s1 , c1 , two values between, same. Thus P + (s0 ) relaxed

plan s0 .6 true general, i.e.,
1 necessarily applicable s0 , achieve,

+
0
within relaxed execution P (s ), set facts achieved
1 P + (s). Thus
h+ (s0 ) h+ (s) state s0 , including state s0 after.
Key observation (2) pertains leaf variable, x0 . Say x0 moves
sake, i.e., car position important goal. executing t0
s0 delete anything needed anywhere else. Thus remove rop(t0 )
relaxed plan P + (s0 ) s0 constructed per observation (1) obtain relaxed plan
state s1 results executing t0 s0 . Hence h+ (s1 ) < h+ (s). observation
(1), heuristic values along path s1 h+ (s). know least one
state s00 path heuristic value strictly smaller h+ (s): happens
latest s00 = s1 , may happen earlier case relaxed plan P + (s00 ) constructed
optimal (cf. Footnote 6). Let s00 earliest state h+ (s00 ) < h+ (s)
path, let s0 state preceding s00 . s0 exit s, path
exit monotone. Thus local minimum. exit distance, worst
case s00 = s1 s0 = s0 , ed(s) bounded length path s0 .
difficult imagine works preconditions need
established recursively, long cyclic dependencies exist. third person may
needed first persuade x1 x2 , third person may need take bus, on.
length path s0 may grow exponentially x1 depends x3
move x1 may require several moves x3 , forth still able
construct P + (s0 ) inverting moves variables individually. Further, inverting
transitions may conditions, too, provided conditions required
original moves. example, above, inverting operator L1 may
arbitrary condition p condition required R1 . conditions
required original moves (like p R1 ) established P + (s), thus
established P + (s0 ) time inverse moves (like L1 ).
6. Note P + (s0 ) may optimal relaxed plan s0 . P + (s) move x1 anything
attaining c1 , postfix P alone relaxed plan s0 : need insert
inverted prefix hL3, L2, L1i. cases this, obtain exit state already path s0 ; get
back below.

162

fiAnalyzing Search Topology Without Running Search

Now, say support graph acyclic, transitions invertible
side effects. Given state s, unless already goal state, variable x0
moving sake necessarily exists. then, within optimal relaxed plan
s, situation exists, therefore monotone exit path, Q.E.D.
local minima h+ .
execution path construction discussed different known results
exploiting causal graph acyclicity notions connectedness invertibility domain
transition graphs (e.g., Jonsson & Backstrom, 1995; Williams & Nayak, 1997).
new connection h+ .
remark hand-made analysis h+ (Hoffmann, 2005) uses notion operators respected relaxation. operator respected relaxation iff,
whenever starts optimal plan s, starts optimal relaxed plan s.
core property many hand-made proofs operators respected
relaxation. motivated speculation recognizing property automatically
could key domain analysis recognizing absence local minima h+ .
explore option herein, however note even basic result outlined
contains cases covered property. Even acyclic support graph invertible
transitions without side effects, examples operator respected
relaxation. give construction Example 1, Appendix A.4.

4. Synopsis Technical Results
technical results follows structured way similar proof argument
outlined previous section. results structured two parts, (A) (B).
(A), Section 5, identify circumstances deduce optimal
relaxed plan monotone exit path exists. (B), Section 6, devise support-graph
based sufficient criteria implying analysis (A) always succeed. Technique (B)
underlies TorchLights conservative analysis methods, i.e., guaranteed global analysis (I)
guaranteed local analysis (II) described end Section 2. feeding technique
(A) usual relaxed plans computed, e.g., FFs heuristic function, obtain
TorchLights approximate local analysis (III). analysis give guarantee,
(and because) FFs relaxed plans guaranteed optimal.
ease reading, give brief synopsis results obtained (A)
(B), provide analysis methods (I)(III). synopsis contains sufficient
information understand rest paper, reader may choose skip Sections 5
6, moving directly evaluation.
analysis method based particular kind sub-graph support graph.
Table 1 overviews these. role parts (A) (B) follows:
(A) Given optimal relaxed plan P + (s) state s, optimal rplan dependency graph
oDG+ sub-graph SG single leaf variable x0 transition t0
example (rop(t0 ) frequently referred o0 ). arc (x, x0 ) oDG+
P + (s) relies x0 achieve conditions t0 , P + (s) relies x moving x0 .
say oDG+ successful acyclic, involved transitions usable
exit path construction (e.g., harmful side effects), deletes t0
163

fiHoffmann

Name
Support graph

Symbol
SG

Analysis

Approximate
local analysis (III)
Theorem 2

Optimal rplan
dependency graph

oDG+

Local
dependency graph

lDG

Guaranteed
local analysis (II)
Theorem 3

Global
dependency graph

gDG

Guaranteed
global analysis (I)
Theorem 4

Leaves

Single leaf x0 s.t. applying
t0 affect
remainder P + (s)
Single leaf x0 XsG ,
s(x0 ) 6= sG (x0 ) x0
transitive SG successor
property
Single leaf x0 XsG

Arcs

(x, x0 ) x used
P + (s) support x0
obtaining cond(t0 )
(x, x0 )
s(x) 6= cond(t0 )(x);
(x, x0 ) x0 lDG
(x, x0 ) SG
(x, x0 ) x 6= x0 ;
(x, x0 ) x0 gDG
(x, x0 ) SG

Table 1: Overview different support graph sub-graphs underlying results.
either relevant P + (s) all, recovered inside P + (s). main
result, Theorem 2, states local minimum exists successful oDG+
s. derives exit distance bound oDG+ . Approximating Theorem 2
applying relaxed plan computed FFs heuristic yields analysis (III).
(B) Given state s, local dependency graph lDG sub-graph SG single leaf
variable x0 , whose goal value yet unachieved, whose transitive successors
SG already attained goal values. setting, x0 moves
sake example. graph lDG simply includes SG predecessors x0 ,
single exception pertaining arcs (x, x0 ) x0 itself, inserted
corresponding condition t0 already satisfied s. say lDG successful
acyclic, involved transitions usable exit path construction, t0
relevant deletes. implies exists successful oDG+
contained lDG, thus Theorem 3, stating local minimum
giving corresponding exit distance bound. result underlies analysis (II).
global dependency graph gDG sub-graph SG identifies goal variable
x0 , includes SG predecessors x0 . successful defined
way lDGs. gDGs successful, Theorem 3 apply every state
lDG contained successful gDG. Thus Theorem 4, stating
state space contain local minima. exit distance bound
obtained maximizing gDGs. result underlies analysis (I).
understanding practical performance TorchLight, important note
(A) minimal result would suffice prove (B). cases identified
Theorem 2 much richer actually infer support graphs.
reason, analysis (III), sound due use potentially non-optimal relaxed
plans, able analyze much larger class states analysis (II). little detail,
difference two methods pertains (1) whether P + (s) relies values
x moving x0 , (2) whether deletes t0 recovered inside P + (s).
Neither (1) (2) visible support graph, rely details
form relaxed plan P + (s). example, consider Gripper domain. Notion (1)
important support graph contains arcs (carry-ball-b, free-gripper)
due dropping ball b (free-gripper, carry-ball-b) due picking ball b.
Thus, looking SG, seems carry-ball-b may support (free gripper
164

fiAnalyzing Search Topology Without Running Search

dropping ball want pick up). course, doesnt happen optimal
relaxed plan. Notion (2) important operators (picking ball)
harmful side effects (making gripper hand non-empty), side effects always
recovered inside relaxed plan (when dropping ball later on). remains future
work extend analyses (I,II) detect kinds phenomenona.

5. Analyzing Optimal Relaxed Plans
consider state optimal relaxed plan P + (s) s. describe circumstances
monotone exit path guaranteed exist, need number notations
pertaining properties transitions etc. introduce notations along way,
rather front, hope makes easier digest.
+
+
Given o0 P + (s), P<0
(s) P>0
(s) denote parts P + (s) front o0
+
behind o0 , respectively. P (s, x) denote sub-sequence P + (s) affecting
x. capture dependencies variables used P + (s) achieving
precondition o0 , follows:
Definition 1. Let (X, sI , sG , O) planning task, let 0 < h+ (s) < , let
P + (s) optimal relaxed plan s, let x0 X, let o0 P + (s) operator
taking relevant transition form t0 = (s(x0 ), c).
optimal rplan dependency graph P + (s), x0 o0 , optimal rplan dependency
graph P + (s) brief, graph oDG+ = (V, A) unique leaf vertex x0 ,
x V (x, x0 ) either: x0 = x0 , x Xpreo , preo0 (x) 6= s(x); x 6= x0
0
+
(s) taking relevant transition x0 x Xpreo
V \ {x0 } exists P<0
preo (x) 6= s(x).
x V \ {x0 }, oDT G+
x denote sub-graph DT Gx includes
+
(s, x), relevant transitions using operator
values true point P<0
+
P<0 (s, x), least one relevant inverse relevant inverse exists.
+
(s, x) transitions original, inverse transitions induced.
refer P<0
transition t0 responsible operator o0 candidate reaching
exit state, t0 Figure 2. oDG+ collects variables x connected variable x0
+
insofar P<0
(s) uses operator preconditioned x order move x0 .
variables need move, x1 x2 Figure 2, obtain state s0 t0
taken. variable x, oDT G+
x captures domain transition graph fragment
+
P<0
(s) traverses within stay, T1 T2 Figure 2.
+
Note need consider operators P>0
(s) behind o0 , simply
operators used order establish o0 precondition. paramount
importance practice. example Gripper situation mentioned above. o0 picks
+
ball b Gripper, P + (s) contain behind o0 , i.e., P>0
(s)
0
0
+
operator dropping b. considered Definition 1, oDG would contain
mentioned cycle assuming o0 used making gripper hand free picking b.
TorchLights approximate local analysis, whenever consider operator o0 ,
build oDG+ re-order P + (s) moving operators behind o0 possible. minimizes
+
P<0
(s), oDG+ thus indeed contains necessary variables arcs.
165

fiHoffmann

circumstances t0 actually job? sufficient criterion
identify rather complex. provide overview criterion, next state definition. items definition explained below.
Definition 2. Let (X, sI , sG , O), s, P + (s), x0 , o0 , t0 , oDG+ = (V, A) Definition 1. say oDG+ successful following holds:
(1) oDG+ acyclic.
(2) either:
+
(a) oDG+ -relevant deletes t0 P>0
(s)-recoverable;
+
(b) s(x0 ) oDG -relevant, t0 replaceable side effect deletes;
(c) s(x0 ) oDG+ -relevant, t0 recoverable side effect deletes.

(3) x V \ {x0 }, oDT G+
x transitions either self-irrelevant deletes,
invertible/induced irrelevant side effect deletes side effects V \{x0 }.
already outlined, exit path construction works staying within ranges
oDT G+
x , x V \ {x0 }, reached state s0 transition t0
taken. make little precise, consider topological order xk , . . . , x1 V \ {x0 }
respect oDG+ order exists due Definition 2 condition (1). (If
cycles, moving variable may involve moving first place,
covered exit path construction.) consider, 0 k, d-abstracted
task. original task except that, every transition one graphs
oDT G+
xi d, remove condition (xj , c) cond(t) j > d. exit
path construction understood induction d, proving existence


execution path
whose end t0 taken. construct
exclusively
,

x

V
\
{x
}.


base case,
operators responsible transitions oDT G+
0
x
0-abstracted task, t0 directly applicable. inductive case, constructed


suitable path
d-abstracted task, suitable path
d+1 + 1
abstracted task constructed follows. Assume operator
,


precondition (xd+1 , c) true current state. Then, d+1 ,
front simply insert path oDT G+
xd+1 ends c. Note that,
construction, (xd+1 , c) condition transition oDT G+
xi , < + 1.
+
+
taken P<0
(s, x), (xd+1 , c) must achieved P<0
(s) thus c node
+
oDT G+
xd+1 . induced transition inverting transition taken P<0 (s, x)
case unless inverse may introduce new outside conditions. thus need
exclude case, leading following definition invertibility:
Let = (c, c0 ) transition variable x. say invertible iff exists
transition (c0 , c) DT Gx cond(c0 , c) cond(c, c0 ).
transition invertible go back without introducing new conditions (e.g.,
driving trucks Logistics). subtle differences previous definitions invertible
operators, authors (Hoffmann, 2005). allow new conditions even

actually established operator rop(t) responsible t. because,
,
necessarily execute executing inverse may got endpoint
via different path oDT G+
x . hand, definition generous
166

fiAnalyzing Search Topology Without Running Search

common ones because, per se, care side effects inverse
transition may (side effects constrained separately stated Definition 2).
Consider Definition 2 condition (3). Apart constraints conditions induced


transitions, oDT G+
x transitions taken , must make sure
harmful side effects. Obviously, case if, example Section 3,
transitions side effects all. However, easily generalize condition. Let
= (c, c0 ) transition variable x.
context set ctx(t) facts may deleted side effects t.
(y, d) seff(t), (y, cond(t)(y)) ctx(t) condition defined; else
Dy values 6= inserted.

say irrelevant side effect deletes iff ctx(t) (sG oO preo ) = .

say self-irrelevant side effect deletes iff ctx(t) (sG rop(t)6=oO preo ) =
.
say tShas self-irrelevant deletes iff self-irrelevant side effect deletes
(x, c) 6 sG rop(t)6=oO preo .
Irrelevant side effect deletes capture case side effect delete occurs goal
precondition operator. Self-irrelevant side effect deletes slightly
generous allow delete conditions needed responsible operator
rop(t) itself. Self-irrelevant deletes, finally, extend latter notion ts delete.
nutshell, need postulate irrelevant side effect deletes transitions may
executed again, path. Examples irrelevant side effect deletes transitions
side effects all, move Simple-TSP, whose side effect, x0 =at,
deletes target locations not-visited. example operator selfirrelevant side effect deletes, irrelevant side effect deletes, departing passenger
Miconic-STRIPS, whose side effect, x0 =served, deletes boarded(passenger)
used purpose departure. fact, transition selfirrelevant deletes effect deletes not-served(passenger) obviously
irrelevant. Another example self-irrelevant deletes inflating spare wheel Tyreworld
wheel longer not-inflated.


Clearly, oDT G+
x transitions may using irrelevant side effect
deletes, then, far invalidating facts needed elsewhere concerned,
good side effects all. understand need require ts
side effect used move another variable x0 V \ {x0 }, recall that, states s0

visited
, construct relaxed plans P + (s0 ) |P + (s0 )| |P + (s)| inverting
transitions t. Now, say ts side effect used move another variable x0 V \ {x0 }.
may invert transitions separately (with different operators), thus
would |P + (s0 )| > |P + (s)|.
Regarding delete t, may important two reasons. First, deleted
fact may needed relaxed plan s0 . Second, x may traverse oDT G+
x several
times, thus may need traverse deleted value later on. covered
invertible, earlier assumed transitions. Now, invertible?
constitute problem case self-irrelevant deletes: case,
167

fiHoffmann

deletes irrelevant except maybe responsible operator itself. Therefore,
obtain P + (s0 ), simply remove rop(t) relaxed plan constructed
predecessor state s00 . Thus |P + (s0 )| < |P + (s)| reached exit

need continue construction
. example, consider inflates spare wheel
W Tyreworld. deletes not-inflated(W), thus self-irrelevant deletes
(not-inflated(W) irrelevant goal operator). Say
state s00 relaxed plan P + (s00 ) constructed described. |P + (s00 )| |P + (s)|.
rop(t) =inflate-W P + (s00 ), inflate-W P + (s),
inflate-W executed yet path, hence removed
relaxed plan. Applying inflate-W s00 , get state s0 identical s00 except W
inflated. Clearly, relaxed plan s0 longer needs apply inflate-W,
rest relaxed plan P + (s00 ) still works unchanged. Thus P + (s0 ) obtained
removing inflate-W P + (s00 ), yielding |P + (s0 )| < |P + (s)| desired.
Consider endpoint transition t0 responsible operator o0 . previously
demanded x0 moves sake, i.e., x0 goal value
important achieving goal. unnecessarily restrictive. example,
Miconic-STRIPS, board passenger h+ decreases remove
boarding operator relaxed plan. However, boarding means serving
passenger later on, variable x0 goal. Driverlog, driver may
goal needed drive vehicles, still t0 moving driver results
decreased h+ location moved away actually needed anymore. latter
example immediately leads definition capturing first one: want
deletes t0 needed rest relaxed plan. remove o0
relaxed plan s0 , reached exit desired.
make precise, recall situation addressing. reached state s0
t0 = (s(x0 ), c) applied, yielding state s1 . relaxed plan P + (s0 )
s0 |P + (s0 )| |P + (s)|, P + (s0 ) constructed P + (s) replacing
+
(s) operators responsible induced oDT G+
operators P<0
x transitions
x V \ {x0 }. construct P1+ removing o0 P + (s0 ), need P1+
relaxed plan s1 . facts possibly needed P1+ ? safe approximation
union sG , precondition o0 6= P + (s), oDT G+
x values needed
7 Denote set R+ . values potentially deleted
induced oDT G+
transitions.
x
1
t0 contained C0 := {(x0 , s(x0 ))} ctx(t0 ). Thus R1+ C0 =
fine. Simple examples given already. Miconic-STRIPS,
delete o0 boarding passenger P not-boarded(P), contained
operator precondition goal thus intersection R1+ C0 = {notboarded(P)} empty. Driverlog, C0 = {at(D,A)} delete o0 moving driver
away location A. location irrelevant rest task,
at(D,A)6 R1+ thus, again, R1+ C0 = .

sharpen further. Consider set facts F0 := oP + (s) eff
<0

+
true relaxed execution P<0
(s). Say p 6 F0 . p needed

7. understand latter two items, note first operators preceding o0 P + (s), i.e., operators
+
P<0
(s), may still contained P1+ thus suffice include preconditions
+
+
operators P>0
(s). oDT G+
x values needed induced oDT Gx transitions, may needed
+
+
P1 P<0
(s).

168

fiAnalyzing Search Topology Without Running Search

P1+ relaxed plan s1 . see this, note first p needed part
+
+
P1+ pertaining P<0
(s). precisely, p cannot operator precondition P<0
(s)
+
condition would satisfied (relaxed) execution P (s). Also, p
cannot start value induced oDT G+
x transition because, definition,
+
values added operators P<0 (s). Now, part P1+ pertaining
+
+
P>0
(s)? Assume p either goal, operator precondition P>0
(s). Then,
+
+
since p 6 F0 P (s) relaxed plan, either o0 operator P>0 (s) must establish
+
p. o0 , effects true s1 anyway. P>0
(s), remains unchanged
+
P1 thus part covered, too. Altogether, thus suffices R1+ C0 F0 = .
example helps Satellite domain. Say o0 switches instrument I.
deletes calibration, i.e., calibrated(I) C0 . purpose switching
take images it, thus calibrated(I) R1+ C0 . However, instrument
may actually calibrated s. so, need switch
calibrated calibration operator requires power
thus calibrated(I) false relaxed execution P + (s), least o0 .
particular, calibrated(I)6 F0 thus R1+ C0 F0 = .
Even condition R1+ C0 F0 = still sharpened. Say exists


+
(s)
o0 guaranteed applicable
(possibly empty) sub-sequence
o0 P>0


+
start P1 , o0 re-achieves facts R1+ C0 F0 (both easy

define test). moving
o0 start P1+ job. say case
+
+
(s)-recoverable Definition 2 condition (2a).
oDG -relevant deletes t0 P>0
example, consider o0 picks ball b Gripper domain. operator deletes
fact p =free-gripper may needed remainder relaxed plan, thus

+
(s) necessarily contain sub-sequence
o0 moves
p R1+ C0 F0 . However, P>0


+
another room puts b again. re-order P1 put o0 right
start, re-achieving p. Similar patterns occur transportation domain capacity
constraints, generally domains renewable resources.
Finally, identified two simple alternative sufficient conditions t0
suitable, Definition 2 conditions (2b) (2c). sake brevity, sketch
here. require s(x0 ), i.e., start value t0 , contained R1+
defined above. say case s(x0 ) oDG+ -relevant. Note that, then,
R1+ C0 = unless t0 side effects. Side effects hurt t0 replaceable side
effect deletes, i.e., operator whose precondition may deleted replaced
alternative operator o0 applicable effect (this happens, e.g.,
Simple-TSP). Another possibility t0 recoverable side effect deletes:
exists operator o0 necessarily applicable directly execution t0 ,
recovers relevant side effect deletes. happens quite frequently, example Rovers
taking rock/soil sample fills store, free store simply
emptying anywhere. replace o0 o0 obtain relaxed plan P1+ s1 (and
thus h+ (s1 ) h+ (s)). apply o0 , yielding state s2 h+ (s2 ) < h+ (s)
obtain relaxed plan s2 removing o0 P1+ .
length exit path be? one move x0 . nonleaf variable x must provide new value every move variable x0
depending it, i.e., (x, x0 ) A. new value reached oDT G+
x
traversal. Denote maximum length traversal, i.e., diameter oDT G+
x,
169

fiHoffmann

8 Now, may diam(oDT G+ ) > diam(DT G ) oDT G+
diam(oDT G+
x
x ).
x
x
removes vertices arcs. may short-cuts traversed P + (s).
certain circumstances safe take short-cuts, namely if:

(*) oDT G+
x transitions invertible/induced irrelevant side effect deletes
side effects V \ {x0 }, DT Gx transitions either irrelevant,
empty conditions irrelevant side effect deletes.
traversing short-cut condition, soon reach end shortcut, back region states s0 relaxed plan P + (s0 ) constructed
before. rest exit path construction remains unaffected. Thus,
denote V
P
subset V \ {x0 } (*) holds. define costd (oDG+ ) := xV costd (x),
costd (x) :=

1



P
0
diam(oDT G+
x)
x0 :(x,x0 )A cost (x )


min(diam(oDT G+ ), diam(DT G )) P
x

x

x = x0
x 6= x0 , x 6 V
x0 :(x,x0 )A cost

(x0 )

x 6= x0 , x V

Note costd (.) exponential depth graph. artifact
length estimation. easy construct examples exit distance exponential
parameter. because, hinted, variable may move several times
value required variables depending it. See Example 6 Appendix A.4
construction (following earlier construction Domshlak & Dinitz, 2001).
said, course costd (.) may over-estimate length shortest exit path.
assumes that, whenever variable x0 (x, x0 ) makes move, x must move
entire oDT G+ respectively DT G. conservative: (1) may
move x0 actually condition x; (2) even condition exists,
x may need less steps order reach it. One might able ameliorate (1) making
fine-grained distinctions part costd (x0 ) pertains moves conditioned
x. leave open future work. now, note over-estimation
exponential even due (2), i.e., costd (oDG+ ) may exponentially larger
length shortest exit path even if, (x, x0 ) A, moves x0 depend x.
shown simple variant Example 6; discuss Appendix A.4.
Exit paths using short-cuts described way may non-monotone. Example 5
Appendix A.4 contains construction showing this. intuitive understanding,
imagine line l0 , . . . , ln current task, achieve precondition another
operator, move l0 ln . Say locations line need visited,
relaxed plan, e.g. need load unload something locations.
Say shortcut via l0 needs visited. move l0 h+
increases made 1 step costly relaxed plan reach
locations l0 , . . . , ln . reason, costd (oDG+ ) upper bound length
shortest monotone exit path. shown Example 5, construct
8. precisely, diam(.) diameter graph maximum distance vertex v vertex
v 0 exists path v v 0 .

170

fiAnalyzing Search Topology Without Running Search

situation shortest monotone exit path longer costd (oDG+ ).9 obtain
bound monotone exit paths, simply set V := definition costd .
Definition 2 condition (2a) (2b), exit distance bounded
costd (oDG+ ) 1 costd (oDG+ ) counts last step reducing h+ .
Definition 2 condition (2c), last step need 1 additional operator reduce
h+ , exit distance bounded costd (oDG+ ). Putting pieces together yields
main result section:
Theorem 2. Let (X, sI , sG , O), s, P + (s), oDG+ Definition 1. oDG+ successful, local minimum, ed(s) costd (oDG+ ). Definition 2
condition (2a) (2b), ed(s) costd (oDG+ ) 1.
full proof Appendix A.2. pointed earlier, approximate local analysis
(III) simply feed Theorem 2 relaxed plans returned FFs heuristic function
(Hoffmann & Nebel, 2001a). important note that, way, give
guarantees, i.e., Theorem 2 hold P + (s) optimal, even P + (s)
non-redundant parallel-optimal computed FF. end exit
path may obtain relaxed plan shorter P + (s) shorter h+ (s).
nutshell, reason parallel-optimal relaxed plan generally, relaxed
plan minimizing number operators may take different decisions
sequentially-optimal relaxed plan, thus constructing exit path leading wrong
direction. Example 8 Appendix A.4 gives full construction proving this.
Feeding Theorem 2 non-optimal relaxed plans course imprecise
direction, i.e., Theorem 2 may apply although apply optimal
relaxed plan. Thus good cases may go unrecognized. demonstrate simple
modification Example 8, explained example Appendix A.4. Importantly,
point Section 8, empirical results suggest weakness
tend occur practice, least far represented benchmarks.

6. Conservative Approximations
identify sufficient criteria guaranteeing prerequisites Theorem 2 hold
true. consider local case particular state given, global
case criterion implies prerequisites Theorem 2 every state task
hand. approximate optimal rplan dependency graphs follows:
Definition 3. Let (X, sI , sG , O) planning task, let 0 < h+ (s) < , let
x0 XsG , let t0 = (s(x0 ), c) relevant transition DT Gx0 o0 := rop(t0 ).
local dependency graph s, x0 , o0 , local dependency graph brief,
graph lDG = (V, A) unique leaf vertex x0 , x V (x, x0 ) either:
x0 = x0 , x Xpreo , preo0 (x) 6= s(x); x0 V \ {x0 } (x, x0 ) arc SG.
0
global dependency graph x0 o0 , global dependency graph brief,
graph gDG = (V, A) unique leaf vertex x0 , x V (x, x0 ) either:
x0 = x0 x0 6= x Xpreo ; x0 V \ {x0 } (x, x0 ) arc SG
0

9. remark that, due mentioned sources over-estimation costd , constructing example
requires fairly awkward constructs appear likely occur practice.

171

fiHoffmann

optimal relaxed plan P + (s) contains o0 , oDG+ per Definition 1
sub-graph lDG gDG defined here. simply optimal rplan
dependency graph arcs (x, x0 ) contained support graph task.10
previously indicated, support graph may contain lot arcs actually necessary.
SG captures may ever support else, support else optimal
relaxed plan. Consider earlier point that, constructing oDG+ , take account
operators front o0 P + (s). information contained SG, thus
Gripper get aforementioned cycle dropping ball support free-gripper
picking ball.
reader waded cumbersome details previous section
delighted hear defining lDG respectively gDG successful
involve additional notation:
Definition 4. Let (X, sI , sG , O), s, x0 , t0 , o0 , G = lDG G = gDG
Definition 3. say G = (V, A) successful following hold:
(1) G acyclic.
(2) G = lDG sG (x0 ) 6= s(x0 ), exists transitive successor x0 x0
SG x0 XsG sG (x0 ) 6= s(x0 ).
(3) t0 either:
(a) self-irrelevant side effect deletes;
(b) replaceable side effect deletes;
(c) recoverable side effect deletes.
(4) x V \ {x0 }, DT Gx transitions either irrelevant, self-irrelevant
deletes, invertible irrelevant side effect deletes side effects
V \ {x0 }.
Consider first local dependency graphs G = lDG; discuss G = gDG below.
Assume optimal relaxed plan P + (s) contains o0 , thus oDG+
sub-graph lDG. condition (1) obviously implies Definition 2 condition (1).
Condition (4) implies Definition 2 condition (3) oDT G+
x contain
irrelevant transitions. Condition (2) implies (*) s(x0 ) oDG+ -relevant, i.e., s(x0 )
needed rest relaxed plan. simply un-achieved
goal depends x0 . (*), condition (3a) implies Definition 2 condition (2a),
R1+ C0 = , notation introduced previously. Conditions (3b) Definition 2
condition (2b), respectively (3c) Definition 2 condition (2c), equivalent given (*).
Regarding exit distance, know parts domain transition graphs
variables x V \ {x0 } traversed P + (s). obvious bound diam(oDT G+
x)
length maxPath(DT Gx ) longest non-redundant path graph (a path
visiting vertex once). Unfortunately, cannot compute maxPath(.) efficiently. Hamiltonian path (Garey & Johnson, 1979) exists graph G = (V, A) iff
10. gDG, note preo0 (x0 ), defined, = s(x0 ) thus x0 need recorded
predecessor.

172

fiAnalyzing Search Topology Without Running Search

maxPath(G) = |V | 1. Thus corresponding decision problem NP-hard. TorchLight over-approximates maxPath(G) simply |V | 1. However, sometimes use
diam(DT Gx ) instead maxPath(DT Gx ), namely certain x one
variables V used definition costd (oDG+ ). certain if:
(**) DT Gx transitions either irrelevant, invertible empty
conditions, irrelevant side effect deletes, side effects V \ {x0 }.
Note strictly stronger requirement Definition 4 condition (4). Clearly,
implies Definition 2 condition (3) well condition (*) SectionP5. Denote V
subset V \ {x0 } (**) holds. define costD (G) := xV costD (x),
costD (x) :=

1
x = x0



P

0
maxPath(DT Gx ) x0 :(x,x0 )A cost (x ) x 6= x0 , x 6 V


diam(DT G ) P
costD (x0 )
x 6= x , x V
x

0

x0 :(x,x0 )A

x0 must move attain goal every optimal relaxed plan must take
least one transition leaving s(x0 ). Thus, Theorem 2 above, that:
Theorem 3. Let (X, sI , sG , O) planning task, let state 0 < h+ (s) <
. Say x0 X that, every o0 = rop(s(x0 ), c) DT Gx0 (s(x0 ), c)
relevant, lDGo0 successful local dependency graph. local minimum,
ed(s) maxo0 costD (lDGo0 ). If, every lDGo0 , Definition 4 condition (3a)
(3b), ed(s) maxo0 costD (lDGo0 ) 1.
Theorem 3 tool guaranteed local analysis (II). guaranteed global analysis
(I), simply look set global dependency graphs gDG, requiring
successful. particular, gDG acyclic, difficult deduce
non-goal state variable x0 fulfilling Definition 4 (2). x0 ,
apply Theorem 3 thus get:
Theorem 4. Let (X, sI , sG , O) planning task. Say global dependency graphs
gDG successful. contain local minima and, state
0 < h+ (s) < , ed(s) maxgDG costD (gDG). If, every gDG, Definition 4
condition (3a) (3b), ed(s) maxgDG costD (gDG) 1.
full proofs Theorems 3 4 Appendix A.3. SG acyclic
transitions invertible side effects, Theorem 4 applies, whereby
particular proved basic result. Vice versa, note that, Theorem 4 applies,
SG acyclic. far local minima concerned, one may thus reformulate Theorem 4
simpler terms relying notion successful dependency graphs. Apart
allowing determine exit distance bound, present formulation already paves
way future research: gDG defined relative concrete variable x0 operator
o0 , may thus allow accurate analysis variables may actually
become important x0 o0 , optimal relaxed plan.
use diam(DT Gx ) instead maxPath(DT Gx ) costD (.), variables
V , rather significant effect quality bounds computed many
173

fiHoffmann

benchmarks. typical example transportation domain vehicle positions leaf
variables SG whose transitions side effects. variables qualify V . Using
maxPath(DT Gx ) instead, would obtain exceedingly large bounds even trivial road
maps. example, consider Logistics road map fully connected.
diam(DT Gx ) = 1 thus costD (.) delivers correct bound 1. Using maxPath(DT Gx )
instead get bound N 1, N total number locations DT Gx .
Note that, within scope Theorem 4, i.e., class planning tasks
Theorem 4 applies, plan existence tractable. Namely, exists plan task iff
exists relaxed plan initial state. because, starting optimal
relaxed plan, guaranteed able construct exit path; iterating argument
gets us goal. view, tractability weakness form global
analysis. analysis apply intractable classes tasks contain
local minima. Note classes exist, cf. Theorem 1. hand, plan
existence tractable known benchmark domains local minima absent,
practice appear major limitation. Also, note plan construction,
well optimal planning, still intractable within scope Theorem 4. Plan
construction intractable plans may exponentially long, cf. Example 6
Appendix A.4. optimal planning, consider Logistics Miconic-STRIPS.
see shortly (Proposition 1, next section) fully covered Theorem 4.
However, them, deciding bounded plan existence NP-hard (Helmert, 2003).
Interestingly, fact Theorem 2, therewith indirectly Theorem 4, rely
optimal relaxed plans source intractability plan construction here. Theorem 4
applies, non-redundant relaxed plan P + successful oDG+ , enabling us
construct path state particular relaxed plan (although necessarily
optimal relaxed plan) shortened. Iterating argument gives us constructive
method obtaining plan, worst-case exponential behavior lies
length individual path segments. said, course plan constructed
way may highly non-optimal. Indeed, shown Example 7 Appendix A.4,
plan may exponentially longer optimal plan. Thus, even Theorem 4 applies
need optimality guarantee, running planner still makes sense.
discuss relation scope Theorem 4 known tractable classes
Section 9. basic fact one construct local minima even small examples
involving two variables complying basic result except either
support graph cyclic (Example 2, Appendix A.4), non-invertible transition
whose delete relevant (Example 3, Appendix A.4), transition
relevant side effect delete (Example 4, Appendix A.4). examples contained
many known tractable classes, thus underlining automatic analysis h+ topology
identification tractable classes different (although related) enterprises.

7. Benchmark Performance Guarantees
state guarantees analyses (I)(III) give benchmark domains.
underlying finite-domain variable formalizations straightforward, correspond
174

fiAnalyzing Search Topology Without Running Search

formulations found automatically Fast Downward. listed
Appendix A.5, give proofs following two simple observations.11
four benchmark domains, guaranteed global analysis (I) always succeed :
Proposition 1. Let (X, sI , sG , O) planning task Logistics, Miconic-STRIPS,
Movie, Simple-TSP domain. Theorem 4 applies, bound delivered
1, 3, 1, 1 respectively.
follows trivially Proposition 1 guaranteed local analysis (II) succeeds
domains well. state one four listed domains, Theorem 3
applies s, bound delivered stated.
Note bounds Logistics Movie correct ones, i.e., tight.
Miconic-STRIPS, over-estimation actual bound (which 1, 3) arises
analysis realize boarding passenger used leaf
variable x0 . Simple-TSP, correct bound 0 (since h+ exact goal distance).
over-estimation arises because, every goal variable x0 =visited(location), gDG
includes variable at, realizing value matter
location visited one.
transportation benchmarks involving capacity constraints, approximate local
analysis (III) always succeed, provided suitable optimal relaxed plans:
Proposition 2. Let (X, sI , sG , O) planning task Elevators, Ferry, Gripper,
Transport domain, let S. Ferry Gripper, every optimal relaxed plan
P + (s) exists oDG+ Theorem 2 applies, bound 1. Elevators
Transport, exists least one P + (s) oDG+ Theorem 2 applies,
bound 1 Elevators road map diameter Transport.
relevant deletes t0 , cases, due effects decreasing remaining vehicle capacity, free-gripper Gripper domain. decrease capacity
always due load type operator, matched unload type operator
later inside relaxed plan. Thus deletes always recovered inside P + (s) (we
Definition 2 condition (2a)). Further, relaxed plans never use unload action
free capacity loading object, thus oDG+ cycle-free. Hence
oDG+ successful, Theorem 2 applies. Elevators Transport, Proposition 2
slightly weaker vehicle may capacity > 1, allowing forcing
relaxed plans use unloading operators recovering capacity actually present.
note similar patterns likely occur domain renewable resources,
recognized Definition 2 condition (2a) way.
Proposition 2 hold Theorems 3 4, i.e., lDGs gDGs. due
two deficiencies (cf. discussion end Section 4). First, SG contains cycles
unloading object order free capacity loading it. Second, Definition 2
condition (3a) restrictive Definition 2 condition (2a), postulating deletes
t0 entirely irrelevant. way removing deficiencies,
guaranteed analyses (I,II) would succeed four domains Proposition 2.
11. say found automatically Fast Downwards translator deterministic, i.e.,
may return different finite-domain variable encodings even run several times planning
task. encodings correspond domain formalizations. Elevators,
give full definition because, without action costs, merely variant Transport.

175

fiHoffmann

8. Experiments
report large-scale experiment TorchLight. fill details TorchLights implementation, describe simple alternative analysis technique based
search probing. explain experiments set-up, report runtime results different
stages TorchLight, describe TorchLights analysis results per-domain basis.
assess quality analysis terms predictive capability. finally summarize
outcome TorchLights diagnosis facility benchmarks.
8.1 TorchLight
TorchLight implemented C based FF.12 TorchLight currently handles STRIPS only,
i.e., ADL domains. uses Fast Downwards translator (Helmert, 2009) find finitedomain variables. Establishing correspondence variables (respectively
values) FFs internally used ground facts mostly straightforward.
details take care of; omit brevity.
parsing Fast Downwards variables, TorchLight creates data structures representing support graph domain transition graphs. enters phase refer
static analysis, determines fixed properties as, every transition t,
whether irrelevant, invertible, etc. next step guaranteed global analysis (I),
checking preconditions Theorem 4 enumerating global dependency graphs
testing whether successful. able report percentage successful gDGs,
stop first unsuccessful one.
local analysis techniques guaranteed local analysis (II) using Theorem 3
approximate local analysis (III) using Theorem 2 run set LS states comprising
initial state well number R sample states obtained random walks starting
sI . set LS identical analyses, run technique state
LS regardless outcome running respective technique is.
Given s, analysis (II) checks Theorem 3 constructing local dependency graph
every suitable variable x0 every transition t0 leaving s(x0 ). find non-successful
t0 , stop considering x0 . minimize exit distance bounds across different x0 .
Analysis (III) checks Theorem 2 relaxed plan P + (s) computed FFs heuristic
function. case relaxed plan exists s, analysis reports failure. Otherwise,
analysis proceeds operators o0 P + (s), start end, variables
x0 affected o0 . pair o0 , x0 build optimal rplan dependency graph oDG+
per Definition 1. skip variables x0 eff o0 (x0 ) actually used precondition
goal, rest P + (s). oDG+ successful, stop. (Relaxed plans big
large examples, continuing analysis exit bound minimization sometimes
costly.) mentioned Section 5, build oDG+ re-order P + (s) moving
operators behind o0 possible. paramount importance avoids including
unnecessary variables oDG+ . re-ordering process straightforward. starts
direct predecessor o0 , tests whether P + (s) still relaxed plan moving
directly behind o0 . yes, arrangement kept. iterate predecessor
o, forth. easy see that, way, oDG+ contain exactly variables
12. source code TorchLight online appendix paper. available download
http://www.loria.fr/~hoffmanj/TorchLight.zip.

176

fiAnalyzing Search Topology Without Running Search

transitions used P + (s) achieve preo0 . Finally, check whether oDG+ +
relevant deletes t0 P>0
(s)-recoverable, use simple technique allowing recognize
situations failure due one operator avoided replacing alternative
operator. example, Transport o0 loading operator reducing capacity level k
k 1, P + (s) may still contain unloading operator relying level k. Thus level k
contained R1+ C0 , causing failure. However, unloading well
performed based capacity level k 1, removing difficulty. catch cases
construction R1+ . Whenever find whose precondition overlaps C0 , test
whether replace similar operator.
local analyses return simple statistics, namely minimum, mean, maximal
exit distance bound found, well success rate, i.e., fraction sample states
guaranteed local analysis (II)/approximate local analysis (III) succeeded. Analysis
(III) success rates main focus, turn informative.
run R = 1, 10, 100, 1000 experiment. length random walk
chosen uniformly 0 5 hFF (sI ), i.e., 5 times heuristic value
initial state. play parameter 5. important, however,
parameter chosen small. domains many dead ends one may
things fatally wrong likely bad things happen
sufficiently large number random choices. Consequently, dead-end rate, i.e.,
fraction sample states relaxed plan exists, tends larger longer
random walks. Since analysis (III) fails states relaxed plan, exerts
important influence analysis (III) success rates. illustrate comparing
results sampled states results obtained using initial states only.
8.2 Search Probing
approximate analysis sample states, exists simple (and rather obvious) alternative TorchLights causal graph based technology. One use search determine
whether given sample state local minimum, exit distance is. Since
cannot compute h+ effectively, search-based analysis necessarily approximate.
straightforward method replace h+ relaxed-plan based approximation.
Herein, replace h+ hFF , i.e., FFs heuristic function. Precisely, given state
s, run single iteration FFs Enforced Hill-Climbing, i.e., breadth-first search
state better heuristic value. search, does, use helpful actions
pruning avoid huge search spaces. Unlike FF, focus detection states
local minima, allow monotone paths (thus restricting search space states s0
hFF (s0 ) = hFF (s)). refer technique search probing, SP brief.
experiment variant imposing 1 second runtime cut-off search. refer
limited search probing, SP1s brief. SP SP1s run set LS
states TorchLights local analyses (II,III).
turns out, empirically present benchmarks SP SP1s competitive TorchLights analysis (III). Since analysis main focus experiments,
relevant understand commonalities differences techniques.
far analysis quality guarantees concerned, 3 techniques analysis (III),
SP, SP1s similar properties: guarantees whatsoever. may report
177

fiHoffmann

success although local minimum (false positives), may fail although
local minimum (false negatives). cases, false positives due use
non-optimal relaxed plans (hFF instead h+ ). False negatives inherent analysis (III)
covers certain special cases; inherent SP1s due search
limit. SP false negatives due helpful actions pruning, however could
principle turned off; fundamental source false negatives non-optimal
relaxed plans. responsible lack connections across techniques.
implication trivial one SP1s success state implies SP success
s. particular, analysis (III) correctly identifies local minimum,
imply SP well. causal graph analysis may less affected
irregularities hFF surface. happens, example, Transport domain
IPC 2008, resulting higher success rates analysis (III).
obvious important differences regarding runtime performance
danger false negatives. SP runtime worst-case exponential size
(grounded) input, whereas analysis (III) SP1s runtime low-order polynomial
size. SP, decreasing number R sample states merely reduces chance hitting
bad state (a sample state large flat region), whereas analysis (III) SP1s scale
linearly R. hand, analysis (III) SP1s buy efficiency
incompleteness, i.e., increased danger false negatives. Analysis (III) simply recognizes
special cases. SP1s effectively bounds lookahead depth, i.e., search depth
exit states detected.
indicated, SP SP1s turn competitive benchmarks. Large search
spaces rare SP. success rates SP SP1s similar, far predictive
capability concerned similarly informative analysis (III). Thus goodquality success rates obtained much simpler techniques TorchLight.13
notwithstanding, (a) TorchLight functions guaranteed analyses (I,II)
well diagnosis cannot simulated, (b) results benchmarks ever
pertain examples. TorchLights analysis (III) offers unlimited lookahead depth
low-order polynomial cost. appear matter much present benchmarks,
natural cases matter. get back below.
8.3 Experiments Set-Up
run experiments set 37 domains. include domains investigated
hand-made analysis h+ topology (Hoffmann, 2005), shown Figure 1,
include domains international planning competitions (IPC) IPC 2004.
remaining domains STRIPS (versions the) domains IPC 2006 IPC
2008, except IPC 2008 Cyber-Security omit due parsing difficulties.14 test
instances collected IPC collection(s) applicable (removing action cost
constructs IPC 2008 domains), randomly generated elsewhere. total,
test set contains 1160 instances.
13. particular, search probing appears rather useful technique, raising question
techniques yet used performance prediction purposes. Roberts Howe (2009),
example, use simple features only. get back conclusion.
14. instances large FFs parser standard configuration. tweaking bison allow
larger parse trees, obtained segmentation fault even smallest instance IPC 2008.

178

fiAnalyzing Search Topology Without Running Search

tool/phase
FD Translator
SG/DTG
Static Analysis
Analysis (I)
Sample States
Analysis (II)
Analysis (III)
TorchLight total
TorchLight (III)
TorchLight (III) FD
SP
SP total
SP1s
SP1s total

LAMA

single-shot/R = 1
mean
max
6.12
690.59
0.14
6.91
0.25
31.42
0.40
53.29
0.01
0.53
0.00
0.18
0.02
1.31
6.92
727.63
6.52
724.54
0.40
33.95
0.06
58.02
0.07
58.03
0.01
1.08
0.01
1.48
268.20

185.05


R = 10
mean
max

0.08
0.01
0.03
7.04
6.64
0.49
0.23
0.32
0.07
0.15

4.81
1.11
2.46
736.98
732.98
40.50
138.54
138.59
4.46
9.27

R = 100
mean
max

0.76
0.10
0.23
8.00
7.51
1.37
5.47
6.23
0.66
1.42

50.35
9.56
20.09
807.70
795.16
103.67


56.18
106.53

R = 1000
mean
max

7.50
0.98
2.15
17.57
16.19
10.04
26.24
33.74
5.89
13.39

491.20
94.59
194.79
1510.74
1413.23
719.27


391.59
882.79

Table 2: Summary runtime data. Mean/max instances domains.
empty fields, respective tool/phase single-shot, i.e., depend R.
dash means time-out, 1800 seconds, inserted runtime respective instance mean computation. Rows FD Translator . . . Analysis
(III) time different stages TorchLight. TorchLight total overall runtime, TorchLight (III) run analyses (II) (III), TorchLight (III)
FD latter disregarding translation costs. SP determines success rate (fraction sample states deemed local minima) via search
probing, i.e., search around sample state; SP1s imposes 1 second time-out
searches. SP total SP1s total include time generating
sample states.
experiments run 1.8 GHZ CPU, 30 minute runtime 2 GB
memory cut-off. run 4 different planners/tools. Apart TorchLight (and SP/SP1s ),
include (Hoffmann & Nebel, 2001a), LAMA (Richter et al., 2008; Richter
& Westphal, 2010). purpose running planners assess extent
TorchLights output particular analysis (III) success rate predict planner success
failure. examine plain planner, run version uses
goal ordering techniques, runs Enforced Hill-Climbing, without resorting
best-first search fails. refer planner EHC follows.
8.4 Runtime
code currently optimized much readability speed. Still, TorchLight
fast. R = 100, bottleneck Fast Downwards translator. R = 1, 10, 100,
actual analysis takes much time translator 99.74%, 99.74%,
96.21% instances respectively. assess detail, consider Table 2
gives timing different stages TorchLight, planners/tools.
translation runtime sometimes hurts considerably, peak 690.59 seconds
costly instance Scanalyzer domain. rather exceptional, however.
second costly domain Blocksworld-NoArm, peak 138.33 seconds.
179

fiHoffmann

20 37 domains, costly instance translated less 10 seconds.
57.24% instances, Fast Downwards translator takes 1 second.
static analysis, peak behavior 31.42 seconds (also Scanalyzer) even
exceptional: 95.34% instances, static analysis takes 1 second. second
highest domain peak 7.88 seconds Pipesworld-Tankage. Similarly, analysis (I)
takes peak 53.29 seconds Blocksworld-NoArm 96.12% instances
completes 1 second. domain Blocksworld-NoArm
peak instance takes 10 seconds Airport, peak 41.71 seconds; next
highest domain peaks Pipesworld-Tankage (6.8), Scanalyzer (2.91), Logistics (1.89),
Woodworking (1.17). domains, analysis (I) always completes within second.
Turning focus local analyses, see even effective. particular, concentrate mostly approximate local analysis (III). see
R = 1000 offer advantages R 100 far information obtained
goes, mostly concentrate R 100. R = 1, 10, 100, analysis (III) completes 1 second 99.66%, 99.40%, 95.60% instances respectively.
R = 1000 still holds 76.55% instances. peak runtime 20.09 seconds
R = 100 occurs Scanalyzer. next highest domain peaks Blocksworld-NoArm
(9.23), Pipesworld-Tankage (4.24), Ferry(3.21), Logistics (2.99), Blocksworld-Arm (2.77),
Optical-Telegraph (1.97), Airport (1.41). 29 domains, analysis (III)
R = 100 always completes within second.
bottleneck local analysis generation sample states. costly
involves repeated computation applicable operators random
walks. R 100 peak 50.35 seconds Scanalyzer domain. However,
again, peak behavior exceptional. R = 1, 10, 100, sampling completes
within 1 second 100%, 98.28%, 87.41% instances respectively.
main competitor TorchLight analysis (III) success rates search probing, i.e.,
SP SP1s . Consider moment analysis methods themselves, i.e., row
Analysis (III) vs. rows SP SP1s Table 2. Compared SP1s , analysis (III)
consistently advantage (except maximum runtime R = 1), difference
dramatic. expected, given SP1s trades completeness small
fixed maximum runtime. Compared complete search SP, analysis (III) consistently
significant advantage. However, R 10 mean runtime SP tolerable,
even maximum runtime bad. Further, bad runtime behavior exceptional.
R = 1, 10, SP completes 1 second 99.83% 98.45% instances
respectively. 35 (R = 1) respectively 32 (R = 10) 37 domains even maximum
runtime 1 second. R = 100, SP two time-outs, Blocksworld-Arm.
R = 1000, 11 time-outs, Blocksworld-Arm, Blocksworld-NoArm, Freecell,
Pipesworld-NoTankage. R = 100, maximum runtime 10 seconds
7 domains; R = 1000, 12. However, R = 100, 1000, SP still completes
1 second 92.33% 71.98% instances respectively (compared 95.60%
76.55% analysis (III), cf. above).
Neither analysis (III) search probing stand-alone methods. former requires
TorchLight except analyses (I,II). latter requires sampling random states.
respective total data given rows TorchLight (III) SP total/ SP1s total
Table 2. picture changes dramatically favor SP especially SP1s .
180

fiAnalyzing Search Topology Without Running Search

noted, though, mostly due overhead translation finite-domain
variables. overhead artifact implementation. approach defined
finite-domain variables, benchmarks not, even though finite-domain
representation cases natural Boolean one. Further, many planners
(notably Fast Downward quickly growing set derivatives) use translation
anyway. runtimes without translation given row TorchLight (III) FD.
one would hope expect, analysis methods much faster actual planners. LAMA 112 time-outs test suite, 173.
8.5 Analyzing Domains
discuss actual analysis outcomes, per-domain basis. first consider
TorchLight, give details comparison analysis (III) success rates
obtained search probing. begin, words order regarding
comparison SP SP1s . R = 1, 10, 100, 1000, success rates identical
99.83%, 99.14%, 97.5%, 94.66% 1160 benchmark instances respectively; 99.83%,
99.14%, 99.31%, 98.97% instances, success rates differ 5%. Thus,
small runtime cut-off adversely affect success rates search probing (because
long searches rare). so, henceforth discuss data SP vs.
SP1s separately. compare TorchLights analysis (III) success rates SP only.
guarantees Proposition 1 confirmed, i.e., guaranteed global analysis (I) succeeds described Logistics, Miconic-STRIPS, Movie, Simple-TSP. never succeeds
domain, though. domains, fractions gDGs successful. Precisely, maximum fraction successful gDGs 97% Satellite, 50% Ferry, 33.33%
TPP, 22.22% Driverlog, 20% Depots, 13.33% Tyreworld, 12.5% BlocksworldArm. However, fraction 100% nothing proved, data may
best used give indication aspects domain good-natured.
Guaranteed local analysis (II) generally much applicable global analysis.
Thus concentrate approximate local analysis (III) exclusively.
Proposition 2 backed impressively. Even R = 1000, analysis (III) succeeds
every single sample state Ferry, Gripper, Elevators, Transport.15 indicates
strongly potentially sub-optimal relaxed plans result loss information
here. Indeed, analysis yields high success rates almost domains local minima
non-present limited. case domains, thus TorchLight
distinguish domains easy h+ topology hard ones. Consider Figure 3,
showing mean analysis (III) success rates per-domain R = 1. (The picture similar
R = 10, 100, 1000; cf. Table 3 below.)
domains whose h+ topology known shown separately right hand
side Figure 3. domains, see quite nicely harder domains tend
lower success rates. particular, easiest domains bottom class
100% success rates (95% case Zenotravel), whereas hardest domains
top right corner around 50% less. latter domains, extent
15. Historically, observation preceded Proposition 2, well h+ topology categorization Elevators Transport per Figure 1. is, hand-made analyses motivated observing
TorchLights analysis outcome.

181

fiHoffmann

PipesTank [40]
PipesNoTank [76]
PSR [50]

Rovers [100]
OptTele [7]

Mystery [39]
Mprime [49]
Freecell [55]
Airport [0]

Hanoi [0]
BlocksNoArm [57]
Grid [80]
Transport [+,100]
bench ed <= c

local minima ed <= c

BlocksArm [30]
Depots [82]
Driverlog [100]

Elevators [+,100]
Logistics [*,100]
Ferry [+,100]
Gripper [+,100]
undirected

Woodwork [13]
Trucks [0]
TPP [80]
Storage [93]
Sokoban [13]
Scanalyzer [30]

Tyreworld [100]
DinPhil [24]
Satellite [100]
Zenotravel [95]
MiconicSTR [*,100]
Movie [*,100]
SimpleTsp [*,100]
harmless

recognized

PegSol [0]
Pathways [10]
ParcPrinter [3]
Openstacks [0]
unrecognized

Figure 3: Overview TorchLight domain analysis results. *: guaranteed global analysis
(I) always succeeds. +: approximate local analysis (III) always succeeds
provided optimal relaxed plan. Numbers shown mean success rates per
domain, approximate local analysis (III) R = 1, i.e., sampling
single state per domain instance.
low success rates result recognition dead ends FFs heuristic function.
example, random sampling make random vehicle moves consuming fuel,
Mystery Mprime, course chances end state fuel
scarce even relaxed plan exist anymore. pronounced
Airport, sample states infinite heuristic values. However, capabilities
analysis go far beyond counting states recognized dead ends. Blocksworld-Arm,
example, dead ends still success rate 30%, clearly
indicating domain difficult topology.
extent, based success rates even distinguish Pipesworld-Tankage
Pipesworld-NoTankage, Mprime Mystery (in Mprime, fuel transferred
locations). relatively high success rate Depots probably relates transportation aspects. Grid, 20% cases analysis strong enough recognize
reasons behind non-existence local minima; reasons quite complicated
(Hoffmann, 2003). Dining-Philosophers really favorable h+ topology.
rather excessive bound 31 due particular domain structure philosophers
behave strictly symmetrical ways (Hoffmann, 2005). Apart this, strong
outliers Driverlog, Rovers, Hanoi, Blocksworld-NoArm. problems hand-made analysis TorchLights. Driverlog Rovers, deep local
minima exist, awkward situations dont tend arise IPC instances. Thus hand-made analysis, worst-case nature, pessimistic
here. opposite happens Hanoi Blocksworld-NoArm, absence local
minima due rather idiosyncratic reasons. example, Hanoi reason h+
always equal number discs yet goal position relaxation, one
always accomplish remaining goals one-by-one, regardless constraints entailed
positioning. Hanoi Blocksworld-NoArm actually easy solve
182

fiAnalyzing Search Topology Without Running Search

domain
Airport
Blocks-Arm
Blocks-NoArm
Depots
Din-Phil
Driverlog
Elevators
Ferry
Freecell
Grid
Gripper
Hanoi
Logistics
Miconic
Movie
Mprime
Mystery
Opt-Tele
Pipes-NoTank
Pipes-Tank
PSR
Rovers
Satellite
Simple-TSP
Transport
Tyreworld
Zenotravel
Openstacks
Parc-Printer
Pathways
Peg-Sol
Scanalyzer
Sokoban
Storage
TPP
Trucks
Woodworking

sI
(III)
96.0
38.3
70.0
100
100
100
100
100
97.5
60.0
100
0.0
100
100
100
74.3
75.0
0
40.0
34.0
66.0
100
85
100
100
100
90
100
100
100
0
0
30.0
100
100
56.3
100

R=1
(III)
SP
0.0
0.0
30.0 93.3
56.7
100
81.8
100
24.1 27.6
100
100
100
100
100
100
55.0 60.0
80.0
100
100
100
0.0 33.3
100
100
100
100
100
100
48.6 74.3
39.3 42.9
7.1 14.3
76.0 98.0
40.0 92.0
50.0 62.0
100
100
100
100
100
100
100 93.3
100
100
95
100
0
4.4
3.3
6.7
10.0 10.0
0
10
30.0 96.7
13.3 33.3
93.3 96.7
80.0 80.0
0
0
13.3 13.3

R = 10
(III)
SP
2.0
2.0
28.2 94.5
57.2
100
85.9 99.1
22.8 23.1
97.5
100
100
100
100
100
57.4 62.8
74.0 92.0
100
100
11.1 44.4
100
100
100
100
100
100
61.1 76.3
37.1 43.9
1.4
2.9
75.4 97.4
50.6 90.0
57.6 69.8
100 99.5
98.5
100
100
100
100 93.0
95.6
100
94.5 99.5
14.8 21.3
8.0
8.3
6.0
6.0
13.3 22.7
33.0 99.7
20.3 38.3
89.0 96.3
68.0 67.0
2.5
3.1
14.3 14.3

R = 100
(III)
SP
2.8
2.9
26.9 91.7
55.9 99.9
86.3 99.7
22.8 22.9
97.4 99.9
100
100
100
100
57.9 63.5
69.0 93.8
100
100
10.2 41.9
100
100
100
100
100
100
64.3 79.0
37.6 45.6
0.9
1.4
75.2 97.4
49.4 88.1
58.3 71.1
100 99.8
98.4
100
100
100
100 94.8
96.3
100
95.8 98.4
17.7 22.0
6.3
7.2
5.4
5.4
13.1 22.3
33.5 97.9
19.1 38.2
89.8 96.8
65.4 63.8
1.9
2.9
15.3 15.4

(III)
2.9
26.5
56.2
86.2
22.0
97.9
100
100
58.0
69.5
100
10.6
100
100
100
64.1
36.3
1.1
75.1
48.7
57.0
100
98.0
100
100
95.5
95.4
16.6
6.0
4.6
12.6
33.9
18.5
89.3
65.5
1.4
15.3

R = 1000
SP
3.0
82.1
98.3
99.6
22.3
99.8
100
100
63.2
93.5
100
41.9
100
100
100
78.2
44.4
1.7
95.4
88.2
70.4
99.8
99.8
100
94.4
100
98.2
20.8
6.8
4.6
22.2
98.5
37.7
96.9
63.9
2.7
15.4

DE
97.0
0
0
0
77.2
0
0
0
35.4
0
0
0
0
0
0
7.2
46.8
98.3
0
8.7
0
0
0
0
0
0
0
79.1
93.0
95.3
75.2
0
54.2
0
34.5
97.3
84.6

Table 3: Mean success rates per domain. Upper part: domains whose h+ topology previously examined hand (Hoffmann, 2005) trivial examine based
results; lower part: IPC 2006/2008 domains case. Columns
sI show data analyzing initial state only, columns R = 1, 10, 100, 1000
analyzing respective number sample states. Columns (III) give data
approximate local analysis (III), columns SP give data search probing,
column DE gives dead-end rates R = 1000.
FF, sense, practical perspective, low success rates TorchLights
analysis (III) provide accurate picture.
Table 3 gives complete account per-domain averaged success rates data, including
domains, values R, rates obtained initial states, using SP instead
TorchLight. serves answer three questions:
(1) important sample random states, rather analyzing initial state?
(2) important sample many random states?
183

fiHoffmann

(3) competitive analysis (III) respect search-based analysis?
answer question (1) clear yes. importantly, pertains domains
dead ends, cf. brief discussion above. clear Table 3 that, domains,
analyzing sI results tendency optimistic. see this, consider entries
Airport, Dining-Philosophers, Freecell, Mystery, Openstacks, Parc-Printer, Pathways,
TPP, Trucks, Woodworking. domains dead ends, variety reasons.
dead ends occur frequently initial state level, occur frequently
random walks cf. column DE Table 3. (Interestingly, domains notably
two Pipesworlds opposite happens, i.e., success rates lower sI
sample states. clear us causes phenomenon.)
simply compare sI column R = 1000 column analysis (III),
find result lot different 10% 22 37 domains.
extent, difference initial states sample states may due
way benchmarks designed. Often, initial states every instance similar
certain ways (no package loaded yet, etc). hand, seems quite natural,
least offline problems, initial state different states deeper
state space (consider transportation problems card games, example).
answer question (2) clear no. example, compare R = 1
R = 1000 columns analysis (III). difference greater 10% 6
37 domains. peak difference Openstacks, 16.6% R = 1000 vs. 0%
R = 1. average difference domains 4.17%. Similarly, comparing R = 1
R = 1000 columns SP results 5 37 domains difference greater
10%, peak Openstacks, 20.8% R = 1000 vs. 4.4% R = 1.
average difference domains 3.7%.
answer question (3) bit complicated. Look columns analysis
(III) respectively SP R = 1000. number domains difference larger
10% 11 37, peak 64.6% difference Scanalyzer. one
hand, still means 26 37 domains analysis result get close
search (average difference 2.18%), without actually running search!
hand, happens 11 domains? these, success rate SP
higher TorchLight. surprising basically means TorchLights
analysis strong enough recognize states local minima.
Interestingly, weakness turn unexpected advantage. 11 domains
question, 8 domains Blocksworld-Arm, Depots, Mprime, Pipesworld-Tankage, PipesworldNoTankage, PSR, Scanalyzer, Sokoban contain deep local minima.16 Thus,
8 domains, would wish analysis return small success rates. TorchLight grants
wish much SP does. Consider happens using SP instead analysis
(III) Figure 3. Mystery, PSR, Sokoban, change dramatic. However,
Blocksworld-Arm marked average success rate 93 instead 30, putting almost
par very-simple-topology domains bottom class. Similarly, PipesworldTankage, Pipesworld-NoTankage, Scanalyzer put almost par these. Depots
16. Sokoban unrecognized dead-ends (in relaxation, blocks pushed across other)
therefore local minima. Scanalyzer, analyzing plants misplaces side effect, bringing
back start position, across large circle conveyor belts, may take arbitrarily many steps.
See Figure 3 6 domains.

184

fiAnalyzing Search Topology Without Running Search

actually receives 100, putting exactly par them. Thus SP analysis outcome
actually looks quite bit worse, 5 domains.
causes undesirably high success rates SP? authors best guess that,
many domains, chance randomly finding state local minimum low.
large-scale experiments measuring statistics search space surface FFs heuristic
function (Hoffmann, 2003), observed many sampled states local minima
themselves, contained valleys. Within valley, monotonically
decreasing path goal state. state may local minimum because,
because, one descend deeper valley. seems SP correctly identifies
valley states local minima, thus counting good many states actually
located difficult regions search space. weakness SP, success
rate search space feature.17 weakness manifest much
analysis (III)? analysis picky takes good states
qualify particular special cases. tend occur often difficult domains.
course, easy construct examples turning discussed strength real
weakness TorchLights analysis quality. seem happen lot
present benchmarks. Now, said that, present benchmarks arent well suited
bring theoretical advantage analysis (III) either. analysis offers unlimited
lookahead depth low-order polynomial cost. However, even R = 1000, 23 37
domains highest exit distance bound returned 0, i.e., every exit path identified consists
single operator. cases could handled much simpler variant analysis
(III), looking operators o0 directly applicable s, thus removing
entire machinery pertaining SG predecessors x0 . Still, machinery matter
cases quite natural. highest exit distance bound returned 10 Grid 7
Transport. generally, transportation domain non-trivial road-map,
easy construct relevant situations. example, say road map Transport forms N
cities, diameter least one vehicle, distances cities large
relative D. Then, typical state, around N vehicle moves considered helpful
FF: least 1 per city since local vehicles preferred relaxed plan.
successor states identical h+ package loaded/unloaded. typical
number steps required grow D. If, example, vehicle
outskirts packages city center, around D/2 steps required,
finding exit takes runtime around N D/2 . small values N already
render search probing either devoid information (if runtime cut-off small),
computationally infeasible (recall probing quick pre-process
actual planning). contrast, analysis (III) easily delivers correct success rate 100%.
8.6 Predicting Planner Performance
direct measure predictive quality success rates, conducted preliminary
experiments examining behavior primitive classifiers, runtime distributions
large vs. small success rates. consider first classifiers. predict, given
planning task, whether EHC/FF/LAMA succeed solving task, within given
17. Note cannot use valley rate instead, cheap domain analysis, since determining whether
lies valley implies finding plan thus solving task side effect.

185

fiHoffmann

time memory limits. classifiers answer yes iff success rate threshold
0, 10, . . . , 100. Obviously, this, need R > 1. consider follows
R = 10 R = 100 because, shown above, R = 1000 costly.
EHC, TorchLight analysis (III) SP deliver fairly good-quality predictions,
considering actual machine learning involved. prediction quality TorchLight good sometimes slightly better search. Whether use
R = 10 R = 100 make big difference. EHC solves 60.69% instances,
rate correct predictions trivial baseline classifier always answering yes.
R = 10, best rate correct predictions 71.90% TorchLight (with = 80)
70.17% SP (with = 90). R = 100, numbers 71.76% (T = 60)
71.16% (T = 100). Dead-end rate bad predictor. best prediction
baseline classifier = 0, second best classifier (T = 100) 36.79% correct.
Interestingly, major differences different sets domains.
domains previously analyzed hand (Hoffmann, 2005; Figure 1 without Elevators
Transport), best prediction 75.75% correct TorchLight = 70,
74.07% correct SP = 100, vs. baseline 63.81%. IPC 2006 domains,
numbers 57.98% 61.34% vs. baseline 55.46%, = 10 cases, i.e.,
best classifier close baseline. IPC 2008, hand, appears
exceptionally good-natured, numbers 79.52% (T = 60) 82.38% (T = 80) vs.
baseline 51.90%. clear us causes phenomena.18
summary, quality prediction always clearly baseline, around 10%
looking domains, even 30% looking IPC 2008 domains
only. comparison, using state-of-the-art classification techniques simple features, Roberts Howe (2009) get 69.47% correctness vs. baseline 74% (for saying no),
unseen testing domains FF. said that, setting considered
learning, actually distinguish learning data
testing data. Roberts Howes unseen testing domains IPC 2006 (in
different setting including ADL test suites). set
domains 2006 (Figure 1 without Elevators Transport), get
best prediction = 70 TorchLight = 100 SP. setting ,
prediction correctness IPC 2006 suite 29.41% respectively 51.26% only, vs.
baseline 55.46%. hand, seems pertain IPC 2006 specifically.
IPC 2008, = 70 respectively = 100 good settings, giving 76.67% respectively
76.19% correctness vs. baseline 51.90%.
Importantly, Roberts Howe predicting performance EHC
FF, complex algorithm. LAMA, prediction quality
TorchLight SP rather bleak, using described primitive classifiers. cases,
best prediction correctness obtained always answering yes. best
said success rate still predicts much better dead-end rate. give
example data, R = 10 across domains FF, baseline 85.09% correct.
= 10, goes 77.50% TorchLight, 79.31% SP, 34.57% dead-end
rate. LAMA, baseline 90.26% correct, = 10 goes 81.81%
18. bad prediction quality IPC 2006 domains might related fact fully grounded,
potentially impeding ability Fast Downwards translator find useful finite-domain variables.

186

fiAnalyzing Search Topology Without Running Search

TorchLight, 83.97% SP, 29.91% dead-end rate. LAMA,
growing prediction quality decreases monotonically cases.
prediction quality much worse EHC,
main building block FF? Whereas EHC typically fails tasks whose h+ topology
favorable, FFs LAMAs complete search algorithms able solve many
cases, too. example, TorchLight success rates R = 10, EHC solves
34.07% tasks success rate 0, solves less 50% success rate 70%.
contrast, LAMA solve 74.18% respectively 76.92% tasks success rate
0, solve least 70% success rates.
Despite this, success rates far devoid information LAMA. Setting
threshold 10, . . . , 100, look distribution planner runtime instance
subset (A) success rate < , vs. instance subset (B) success rate .
Taking null hypothesis means two runtime distributions
same, run Students T-test unequal sample sizes determine confidence
null hypothesis rejected. is, determine confidence
distribution (B) lower mean distribution (A). Using TorchLights success rate
runtimes, R = 10 R = 100, 10 settings , get confidence
least 99.9%. difference means data, i.e., mean runtime
(A) minus mean runtime (B), tends grow . peaks 336 respectively 361
seconds R = 10 respectively R = 100; average difference values 239
respectively 240. Likewise, LAMA runtimes settings R yield confidence
99.9%, average differences 242 respectively 235. results SP comparable
LAMA. slightly worse FF, though. R = 10 confidence 99.9%
= 10, 20; confidence 95% values . difference peaks 241
seconds (vs. 336 TorchLight), average 150 seconds (vs. 239). R = 100,
thresholds = 30, 40, 50, 100 yield 99.9% confidence, average difference 160.
perhaps little surprisingly, simpler planner EHC runtime distributions behave differently. TorchLight success rates, get several cases
confidence < 95%, average differences around 80 seconds. SP, cases
get 99.9% confidence mean (B) larger (A). Again, reason
simple. many tasks unfavorable h+ topology, enforced hill-climbing quickly exhausts space states reachable FFs helpful actions. EHC gives solving
task, although consumed little runtime peculiar behavior one would
certainly expect planner trying competitive.
Summing up, success rates planning task feature provide good coverage
predictor EHC even without significant learning. LAMA, things
easy, however consideration runtime distributions clearly shows
feature highly informative. Exploiting informativeness predicting planner performance presumably requires combination features, actual machine learning
techniques, along lines Roberts Howe (2009). topic future research.
8.7 Diagnosis
Let us finally consider TorchLights diagnosis facility. idea behind facility
summarize reasons analysis failure. Testing sufficient criteria absence local
187

fiHoffmann

minima, diagnosis guaranteed identify domain features causing presence.
Still, least analysis using Theorem 2, diagnosis quite accurate.
current diagnosis facility merely first-shot implementation based reporting
pairs (operator o0 , variable x) caused oDG+ o0 successful. is,
report pair (o0 , x) o0 effect x, context fact (x, c) transition
t0 taken o0 contained R1+ C0 F0 , recoverable sub-sequence
+
P>0
(s). brief, record (o0 , x) o0 harmful effect x. perform test
whether main effect o0 , i.e., x0 , invertible; case record
x0 since problem appear side effects. avoid redundancies reporting,
record grounded operator o0 name action schema (load
instead load(package1 truck7)). Similarly, option record x name
predicate underlying fact (x, c). configuration, diagnosis comes
form action-name, predicate-name, direct match high-level PDDL
input files. measure parts diagnosis important,
associate pair count occurrences, weigh pairs frequency.
Zenotravel, diagnosis output always form fly, fuel-level zoom,
fuel-level, indicating correctly fuel consumption causing local
minima. Mprime Mystery, cause local minima same, however
diagnosis reliable specific structure domain, associating fuel
locations instead vehicles. sometimes causes diagnosis conclude
effect changing locations causing trouble. Concretely, R = 1000
Mystery, fuel consumption top-weighted diagnosis 17 28 tasks;
Mprime, happens 30 35 tasks. Satellite Rovers, diagnosis
always takes form switch-on, calibrated respectively take-image, calibrated, thus
reporting problem switching instrument, respectively taking image,
deletes calibration. precisely reason local minima exist here.19
Tyreworld, often diagnosis reports problem jacking hub results
longer jack (which needed elsewhere, too). actually
cause local minima (there none), indeed appears crucial aspect domain.
Similarly, Grid frequent diagnosis picking key results arm
longer empty again, actually cause local minima, critical resource
domain. Blocksworld-Arm, dominant diagnoses block longer
clear stack something top it, hand longer empty picking
block. Similarly, Freecell, dominant diagnoses send-to-free, cellspace
send-to-new-col, colspace.
One could make list much longer, however seems clear already
diagnosis facility, although yet primitive, potential identify interesting aspects
domain. Note making use one information sources
TorchLight. many things recorded, pertaining reasons
analysis failure, support graph cycles etc, reasons analysis success,
successful gDGs x0 , o0 pairs yielding successful oDG+ s. appears promising try
improve diagnosis combining information sources. combination
19. Since analysis failure rare two domains, often diagnosis give output all.
R = 1000, output non-empty 10 instances Satellite 8 instances Rovers. R = 100
reduces 4 instances Satellite, single one Rovers.

188

fiAnalyzing Search Topology Without Running Search

domain analysis techniques, landmarks invariants extraction, could
useful. direction future work.20

9. Related Work
prior work aforementioned one author (Hoffmann, 2005)
trying automatically infer topological properties heuristic function. Thus work
relate strongly domain analysis techniques. closest relation
techniques relying causal graphs. follows discuss detail, along
connections arising context.
local analysis succeeds, construct path exit identified. this,
work relates work macro-actions (e.g., Botea, Muller, & Schaeffer, 2004; Vidal,
2004). distinguishing feature macro-action (would be) constructed
targeted analytical way, even giving guarantee, conservative case, make
progress towards goal. machinery behind analysis based causal graphs,
shares similarities known causal-graph based execution path generation methods
(e.g., Jonsson & Backstrom, 1995; Williams & Nayak, 1997; Brafman & Domshlak, 2003).
distinguishing feature focus h+ individual states rather
whole task. allows us consider small fragments otherwise arbitrarily complex
planning tasks look oDG+ instead SG. Note ability quite powerful
far applicability goes. seen Section 8, success rate (local)
approximate analysis therewith fraction states would able
generate macro-action non-zero almost benchmark domains. course,
broad applicability comes prize. traditional causal graph methods guarantee
reach goal, worst case macro-actions may lead h+ local minima. Still,
may interesting look whether other, traditional, causal-graph based methods
localized (or similar) manner well.
Global analysis, focus whole planning task thus whole causal
graph, even closely related research causal graphs based tractability analysis.
major difference tractability analysis h+ topology analysis, principle,
tractability absence local minima orthogonal properties general,
neither one implies other. Now, pointed end Section 6, global
analysis imply tractability (of plan existence). Vice versa, restrictions made
known tractable classes imply absence local minima? many cases, answer
question definite no; interesting questions open; single case
corresponding basic result answer yes.
Example 3 Appendix A.4 shows one construct local minimum 2
variables domain size 3, 1-arc SG, unary operators, strongly connected DTGs
single non-invertible transition. example (and various scaling extensions breaking
respective conditions) falls variety known tractable classes. example
20. particular, Fast Downwards translator always perfect detecting finite-domain variables
underlying benchmarks. example, Satellite often detect electricity available
exactly one instruments mounted satellite. lead pointless diagnosis output,
handled using simple notion predicates exchanged every operator.
things principled manner, invariants analysis would useful.

189

fiHoffmann

tractable class F
n identified Domshlak Dinitz (2001), every transition
dependent variable depends variable. example Helmerts (2004,
2006) SAS+ -1 class strongly connected DTGs. example solved, i.e., reduced
empty task, Haslums (2007) simplification techniques (also, techniques
solve tasks Satellite domain, contain local minima). example
fork inverted fork causal graph, bounded domain size 1-dependent actions
(actions 1 prevail condition), thus qualifies tractable classes
identified Katz Domshlak (2008b). examples causal graph chain,
thus particular polytree bounded indegree, corresponding tractable class
identified Brafman Domshlak (2003) except that, there, variables restricted
binary (domain size 2). open question whether plan existence chain causal
graphs domain size 3 tractable; strongest known result NP-hard
domain size 5 (Gimenez & Jonsson, 2009b).21 Similarly, example fits prerequisites
stated Katz Domshlak (2008a) except binary variables only;
open question whether local minima exist tractable classes identified there.
Finally, example, suitable scaling extension, obviously qualifies two theorems
stated Chen Gimenez (2010). Theorem 3.1 (more precisely, first part
theorem) requires constant bound size connected components
undirected graph induced causal graph. first part Theorem 4.1
requires constant bound size strongly connected components causal
graph, pertains notion reversible tasks requiring always go back
initial state.
Next, consider line works restricting causal graph DTGs
task (Backstrom & Klein, 1991; Backstrom & Nebel, 1995; Jonsson & Backstrom, 1998).
simplest class identified here, contained classes, SAS+ -PUBS
fact achieved one operator (post-unique, P), operators unary
(U), variables binary (B), variables one value required
condition transition variable (single-valued, S). Now, Example 2
Appendix A.4 shows local minimum example U properties.
example two variables, x y, local minimum arises cyclic
dependency prevents attaining goal value dn via shortest path taken
optimal relaxed plan. remove two values domain y, remove
alternative way reaching dn ,22 example still contains local minimum
P B properties. remark modified example unsolvable.
remains open question whether solvable SAS+ -PUBS tasks local minima exist;
generally, question open even larger SAS+ -PUS class, (yet larger)
SAS+ -IAO class identified Jonsson Backstrom (1998).
Another open question whether 3S class Jonsson Backstrom (1995)
contains local minima. class works binary variables only; requires unary operators
acyclic causal graphs, however allows facts splitting instead reversible.
p splitting then, intuitively, task decomposed three independent subtasks respect p; open question whether local minima constructed
21. Although, course, clear that, DTGs strongly connected case, deciding
plan existence tractable matter domain size is.
22. modification given detail example Appendix A.4.

190

fiAnalyzing Search Topology Without Running Search

satisfying property. Disallowing splitting option 3S, obtain single
positive case, known tractable class contain local minima.
class corresponds basic result acyclic causal graphs invertible transitions
except variables restricted binary. Williams Nayak (1997) mention
restrictions (but make formal claims regarding tractability) corresponding exactly
basic result except allow irreversible repair actions. latter actions
defined relative specialized formal framework control systems, spirit
similar term transitions self-irrelevant deletes herein.
Finally, easy see that, Bylanders (1994) three tractability criteria, two
allowing several effects imply absence local minima. third criterion,
restricting action effects single literal preconditions positive literals (but allowing
negative goals), leave open question whether local minima exist.
remark criterion apply benchmark aware of.
close section, certainly wish claim identification
tractable classes contribution work, note scope Theorem 4
tractable class, cf. covered known tractable classes.23
tractable cases identified Bylander (1994) obviously cover Logistics,
Miconic-STRIPS, Movie, Simple-TSP. Many causal graph based tractability results
require unary operators (Jonsson & Backstrom, 1995; Domshlak & Dinitz, 2001; Brafman & Domshlak, 2003; Helmert, 2004, 2006; Katz & Domshlak, 2008a, 2008b; Jonsson,
2009; Gimenez & Jonsson, 2008, 2009a), cover Miconic-STRIPS, Movie,
Simple-TSP. work Chen Gimenez (2010), Theorem 4.1 requires reversibility given either Movie, Miconic-STRIPS, Simple-TSP,
Theorem 3.1 requires constant bound size connected components
undirected graph induced causal graph, given none Logistics, MiconicSTRIPS, Simple-TSP. known tractability results make different restrictions
DTGs (Backstrom & Klein, 1991; Backstrom & Nebel, 1995; Jonsson & Backstrom,
1998). Even general tractable class identified there, SAS+ -IAO, covers none
Miconic-STRIPS, Logistics, Simple-TSP (because vehicle variables acyclic
respect requestable values), neither cover Movie (because rewinding
movie neither unary irreplaceable: side effect un-setting counter,
breaking DTG counter two disjoint components).
far coverage benchmarks goes, strongest competitor Theorem 4
Haslums (2007) simplification techniques. iteratively remove variables
paths relevant attaining required conditions free, i.e., traversed using transitions neither conditions side effects. Haslums Theorem 1 states
removal done without jeopardizing solution existence, i.e., plan original
task reconstructed easily plan simplified task. particular,
task solved simplified completely, empty task plan constructed
polynomial time. Haslum combines basic technique number domain reformulation techniques, e.g., replacing action sequences macros certain conditions.
choice combination techniques apply fully automated, parts
23. true basic result, explained essentially covered works Jonsson
Backstrom (1995) Williams Nayak (1997). Formally, prerequisites imply (the
first part of) Theorem 4.1 work Chen Gimenez (2010), namely, postulated bound 1.

191

fiHoffmann

techniques fully described, making comparison Theorem 4 difficult.
Haslum reports techniques solve tasks Logistics, Miconic-STRIPS, Movie,
plus Gripper Satellite. Haslum experiment Simple-TSP. Theorem 1,
stated form, solve Simple-TSP, transitions root
variable side effects (with irrelevant deletes). Extending theorem cover
irrelevant deletes straightforward. subtle weakness Haslums Theorem 1 relative Theorem 4 pertains reaching required values externally caused
values. Haslum requires moves free, whereas, definition recoverable
side effect deletes, Theorem 4 allows recovering operators affect several variables
take precondition prevails effects o0 .

10. Conclusion
identified connection causal graphs h+ , devised tool allowing
analyze search space topology without actually running search. tool yet
automatic Hoffmann, analysis quality impressive even compared
unlimited search probing.
generic level, conclusion work that, sometimes, possible
automatically infer topological properties heuristic function. interesting question
future work whether done heuristics h+ (cf.
comments regarding causal graph research below). Methodologically, noteworthy
analysis based syntactic restrictions problem description, traditionally used identify tractable fragments (of planning computationally
hard problems). present work showcases similar techniques apply
analysis search spaces general problem solvers.
main open question whether global analysis tightly approximate scope
Theorem 2. indicated, good starting point appears trying include, gDG
operator o0 , variable dependencies induced operators may actually precede
o0 optimal relaxed plan. approach automatically recognizing operators could
possibly developed along lines Hoffmann Nebel (2001b), using simplified
version aforementioned fact generation tree analysis technique (Hoffmann, 2005).
Additionally, would great recognize situations harmful side effects o0
making hand non-empty pick ball Gripper necessarily
recovered inside relaxed plan. Possibly, analysis could based variant
action landmarks (Hoffmann, Porteous, & Sebastia, 2004; Karpas & Domshlak, 2009).
Another interesting line research start results given individual states
local analysis, extract reasons success s, generalize reasons
determine generic property success guaranteed. Taken extreme,
might possible automatically identify domain sub-classes, i.e., particular combinations
initial state goal state, absence local minima proved.
work highlights two new aspects causal graph research. First, shows that,
certain situations, one localize causal graph analysis, consider causal
graph fragment relevant solving particular state. Second, one use causal graphs
constructing paths global goal, state value heuristic h
decreased. former enables analysis succeed tasks whose causal graphs
192

fiAnalyzing Search Topology Without Running Search

otherwise arbitrarily complex, thus potential greatly broaden scope
applicability. latter necessarily limited h+ simple example,
obvious similar constructions made trivial heuristic counting number
unsatisfied goals thus opens completely new avenue causal graph research.
Another possibility planner performance prediction, along lines Roberts
Howe (2009). experimental results indicate TorchLights problem features,
search probing, highly informative. potential significantly
improve results Roberts Howe unseen domains currently use
simple features, counts predicates action schemes, hardly capture domainindependent structure relevant planner performance. limited search probing (SP1s ),
TorchLight generates features without jeopardizing runtime, thus enabling automatic
planner configuration. Unlike search probing, may even work on-line search:
single relaxed plan already deliver interesting information. example, one might
make search less greedy choosing different search strategy, switching helpful
actions off, etc. depending outcome checking Theorem 2.
mentioned Section 9, direction worth trying use local analysis generating
macro-actions. domains high success rate, seems likely macro-actions
would lead goal search all. priori clear, though, whether
approach would significantly strengthen, least present benchmarks, existing
techniques executing (parts of) relaxed plan (e.g., Vidal, 2004).
One could use TorchLights diagnosis facility basis abstraction technique
deriving search guidance, much currently done relaxation/abstraction
techniques. diagnosis pin-point operator effects causing problems
search. remove enough harmful effects end task Theorem 4
applies, abstracted problem tractable. example, transportation domains,
process could abstract away fuel consumption. abstract much,
information provided may still outweigh effort abstract planning, i.e.,
using actual planner inside heuristic function. example, Grid abstract task
could problem variant allowing carry several keys once. One could focus
construction different heuristics based ignoring deletes harmful effects.
Finally, interesting research line domain reformulation. well known,
domain formulation make huge difference planner performance. However,
difficult choose good formulation, given planner. black art even
reformulation done developer planner question. lack guidance
one main open problems identified Haslum (2007) automatic reformulation
approach. frequent question author asked non-expert users
model domain handle easily.
TorchLights diagnosis facility, pin-pointing problematic effects, might instrumental
addressing difficulties. case reformulation done computer,
one possibility use analysis outcome could produce macro-actions hiding
within operators harmful effects. Another possibility could precompose variable subsets touched harmful effects.
case reformulation done human user, sky limit.
name one example, local minima Satellite could removed allowing
switch instrument pointing direction instrument
193

fiHoffmann

calibrated. generally, note end-user PDDL modeling writing PDDL
non-expert user wanting solve problem using off-the-shelf planners quite
different PDDL modeling planning experts developing benchmarks.
example, expert models transportation benchmark fuel consumption,
may seem quite pointless TorchLight determine fuel consumption hurt
planner performance. Indeed may reason fuel consumption included
first place. contrast, end-user (a) information may come surprise,
(b) user may actually choose omit fuel consumption may yield
better point trade-off planner performance plan usability. Generally
speaking, approach could give user guidance designing natural hierarchy
increasingly detailed increasingly problematic domain formulations. could
help making planning technology accessible, thus contribute challenge
taken much seriously planning community.

Acknowledgments
would thank anonymous reviewers both, article hand ICAPS
2011 short version, constructive comments. particular, one reviewers
proved completeness results Theorem 1, another reviewer suggested future
research line trying generalize reasons success local analysis.
thank Carmel Domshlak discussions, feedback early stages work contributing particular d-abstracted task construction proof Lemma 3
executive summary status quo causal graph research.
special thanks goes Carlos Areces Luciana Benotti, inspiring
work first place. long ago given problem. Carlos
Lucianas insistence finally made see connection causal graphs trying
convince analysis impossible.

Appendix A. Technical Details Proofs
give full proofs and, needed, fill technical definitions. first
prove complexity result (Appendix A.1, Theorem 1), result pertaining
analysis optimal relaxed plans (Appendix A.2, Theorem 2), result pertaining
conservative approximations (Appendix A.3, Theorems 3 4). construct number
examples relevant kinds analysis (Appendix A.4), giving proofs
domain-specific performance guarantees (Appendix A.5, Propositions 1 2).
A.1 Computational Complexity
Theorem 1. PSPACE-complete decide whether state space given
planning task contains local minimum, given integer K PSPACE-complete
decide whether states ed(s) K. Further, PSPACE-complete
decide whether given state local minimum, given integer K
PSPACE-complete decide whether ed(s) K.
194

fiAnalyzing Search Topology Without Running Search

Proof. Throughout proof, since PSPACE closed complementation,
distinguish mentioned PSPACE-complete decision problems complements.
membership results easy prove. Note first that, given state s,
compute h+ (s) within polynomial space: generate potentially non-optimal relaxed plan,
length n, known methods; iteratively decrement n test value
whether relaxed plan length still exists; stop test answers no.
test bounded relaxed plan existence NP thus PSPACE. here,
prove membership results simple modifications guess-and-check argument
showing PLANSAT, problem deciding whether given planning task solvable,
NPSPACE hence PSPACE (Bylander, 1994). argument works
starting initial state, guessing actions, terminating successfully goal state
reached. Unsuccessful termination occurs guessed path longer trivial
upper bound B := xX |Dx | number different states. able check
condition polynomial space, path length maintained binary counter.
decide whether given state (not) local minimum, run guess-and-check
algorithm s, modified to: compute h+ encountered state; terminate unsuccessfully bound B exceeded h+ increases operator application;
terminate successfully h+ decreases operator application. decide whether
ed(s) K, use algorithm except bound B replaced bound K,
increases h+ permitted, success occurs h+ decreases h+ (s) h+ (s)1.
decide whether state space entire planning task contains local minima, whether
states state space ed(s) K, simply run Bylanders guess-and-check
algorithm way enumerating reachable states, individual state
run modified guess-and-check algorithms described. Clearly, algorithms
run non-deterministic polynomial space, shows part claim.
show PSPACE-hardness results. first consider problem deciding whether given state local minimum. proof works reducing
PLANSAT, known PSPACE-hard propositional STRIPS (Bylander,
1994), trivially follows PLANSAT PSPACE-hard finitedomain variable planning tasks use herein.
Let (X, sI , sG , O) planning task whose solvability wish decide. design
modified task (X 0 , s0I , s0G , O0 ) starting (X, sI , sG , O) making following
modifications:
Add new variable ChooseT ask X 0 ,
s0I (ChooseT ask) = nil, s0G (ChooseT ask) undefined.

domain

{nil, org, alt},

role variable give planner choice whether solve
original task (X, sI , sG , O), whether solve alternative task custom-designed
proof.
Add new variable DistAlt X 0 , domain {0, 1}, s0I (DistAlt) = 1,
s0G (DistAlt) = 1.
variable simply serves control length solution alternative task.
solution length 1 plus number steps needed bring DistAlt
195

fiHoffmann

value 0 goal value. (Here, 1 step needed so; later
proof, increase distance.)
Add two new operators oOrg = ({(ChooseT ask, nil)}, {(ChooseT ask, org)})
oAlt = ({(ChooseT ask, nil)}, {(ChooseT ask, alt), (DistAlt, 0)}).
implements choice planning task. Note that, choose alternative
task, DistAlt set 0, thus forcing solution bridge distance.
contrast, original task, variable keeps residing goal value
already assigned s0I (DistAlt).
Add new operator oDistAlt = ({(ChooseT ask, alt), (DistAlt, 0)}, {(DistAlt, 1)}).
allows bridge distance intended solution alternative task.
Add new operator osG Alt = ({(ChooseT ask, alt), (DistAlt, 1)}, sG ).
allows us accomplish original goal, final step solving alternative task.
Add (ChooseT ask, org) new precondition original operators, i.e.,
taken O.
forces planner choose original task, executing operators.
Add new variable StillAlive X, domain {yes, no}, s0I (StillAlive) = yes,
sG (StillAlive) = yes. Add new operator osG Dead = (, sG {(StillAlive, no)}).
osG Dead operator allows us accomplish original goal single step,
matter task chosen solve, new initial state s0I already.
However, operator sets new variable StillAlive value no, whereas
goal value variable yes. value cannot re-achieved, thus
operator leads dead-end. function proof flatten value
h+ original task, s0I , constantly 1 unless goal state.
extreme flattening happen alternative task because, there,
distance variable DistAlt needs handled.
summary, (X 0 , s0I , s0G , O0 ) designed setting:
X 0 := X {ChooseT ask, DistAlt, StillAlive}
s0I := sI {(ChooseT ask, nil), (DistAlt, 1), (StillAlive, yes)}
s0G := sG {(DistAlt, 1), (StillAlive, yes)}
O0 := {(pre {(ChooseT ask, org)}, eff) | (pre, eff) O} {oOrg , oAlt , oDistAlt , osG Alt ,
osG Dead }
consider new initial state s0I . exactly three successor states: sDead produced osG Dead , sOrg produced oOrg , sAlt produced oAlt . h+ (sDead ) =
sDead (StillAlive) = no. h+ (s0I ) = h+ (sOrg ) = 1 due relaxed
196

fiAnalyzing Search Topology Without Running Search

plan hosG Dead i. Finally, h+ (sAlt ) = 2 oAlt sets DistAlt variable 0
whereas goal 1. Thus shortest relaxed plan sAlt hoDistAlt , osG Alt i.
this, clearly follows s0I local minimum iff sOrg monotone
path state h+ (s) < h+ (sOrg ). Since h+ (sOrg ) = 1, latter equivalent
existence monotone path sOrg goal state, i.e., path goal state
h+ constantly 1. Since, states reachable sOrg , single-step sequence
hosG Dead relaxed plan, equivalent existence path sOrg goal
state. Clearly, latter equivalent solvability original task (X, sI , sG , O). Thus
s0I local minimum iff (X, sI , sG , O) solvable, shows part claim.
next prove PSPACE-hardness deciding whether given planning task
contains local minimum. follows easily above. Observe alternative
task contain local minima. described, h+ (sAlt ) = 2. apply
oDistAlt sAlt , obtain state sAltDist h+ (sAltDist ) = 1 relaxed
plan hosG Alt i. Applying osG Alt sAltDist yields goal state, thus sAlt sAltDist
better evaluated neighbors. states descending sAlt must produced
osG Dead thus h+ value . So, (X 0 , s0I , s0G , O0 ) contains local minimum iff
part state space descended sOrg does. Since states h+ value 1 unless
goal states, cf. above, latter equivalent unsolvability (X, sI , sG , O)
shows part claim.
Assume given integer K need decide individual state
whether ed(s) K. reduce Bounded-PLANSAT, problem deciding whether
given planning task solvable within given number steps. Bounded-PLANSAT
known PSPACE-complete bound given non-unary representation.
modify task (X 0 , s0I , s0G , O0 ) given above, way increases solution length
alternative task K. introduce binary counter using dlog2 (K 2)e new binary
variables Biti 0 sI . introduce operator bit, allowing set
bit 1 lower bits already 1, effect setting lower bits back
O. operator additional precondition (ChooseT ask, alt),
effect modifying bits. modify operator oDistAlt adding new
preconditions encoding counter position K 2. construction, clearly h+ (sAlt ) > 1,
distance goal sAlt K: plan count K 2, apply oDistAlt ,
apply osG Alt . Thus, shortest exit path sI via oAlt length K + 1. then,
above, ed(sI ) K iff (X, sI , sG , O) plan length K 1,
concludes part claim.
Finally, say need decide whether not, S, ed(s) K. Note
first sAlt successors necessarily exit distance K (the goal
reached many steps), exit distance sOrg successors
equal length shortest plan corresponding state (X, sI , sG , O).
latter length may, states (X, sI , sG , O), longer K even shortest
plan (X, sI , sG , O) (i.e., original initial state) length K. thus introduce
another binary counter, time counting K 1, conditioned (ChooseT ask, org),
new operator whose precondition demands new counter K 1
achieves goals. Then, clearly, sOrg descendants exit distance
K. Thus state may exit distance greater K s0I precisely,
197

fiHoffmann

ed(s0I ) = K + 1 iff new counter shortest plan sOrg , obviously
case iff (X, sI , sG , O) plan length K 1. concludes argument.
A.2 Analyzing Optimal Relaxed Plans
need fill notations. sake self-containedness section, first
re-state definitions given Section 5:
Definition 1. Let (X, sI , sG , O) planning task, let 0 < h+ (s) < , let
P + (s) optimal relaxed plan s, let x0 X, let o0 P + (s) operator taking
relevant transition form t0 = (s(x0 ), c).
optimal rplan dependency graph P + (s), x0 o0 , optimal rplan dependency
graph P + (s) brief, graph oDG+ = (V, A) unique leaf vertex x0 ,
x V (x, x0 ) either: x0 = x0 , x Xpreo , preo0 (x) 6= s(x); x 6= x0
0
+
(s) taking relevant transition x0 x Xpreo
V \ {x0 } exists P<0
preo (x) 6= s(x).
x V \ {x0 }, oDT G+
x denote sub-graph DT Gx includes
+
(s, x), relevant transitions using operator
values true point P<0
+
P<0 (s, x), least one relevant inverse relevant inverse exists.
+
(s, x) transitions original, inverse transitions induced.
refer P<0
Definition 2. Let (X, sI , sG , O), s, P + (s), x0 , t0 , oDG+ = (V, A) Definition 1.
say oDG+ successful following holds:
(1) oDG+ acyclic.
(2) either:
+
(s)-recoverable;
(a) oDG+ -relevant deletes t0 P>0
+
(b) s(x0 ) oDG -relevant, t0 replaceable side effect deletes;
(c) s(x0 ) oDG+ -relevant, t0 recoverable side effect deletes.

(3) x V \ {x0 }, oDT G+
x transitions either self-irrelevant deletes,
invertible/induced irrelevant side effect deletes side effects V \{x0 }.
next define two general notions helpful state proofs.
prevail condition prevo operator results restricting preo
set variables Xpreo \ Xeff .
Let x X, let (c, c0 ) transition DT Gx , let (y, d) seff(c, c0 ) side
effect transition. context (y, d) (c, c0 ) ctx(c, c0 , y, d) :=
(
(y, prerop(c,c0 ) (y))
Xprerop(c,c0 )
{(y, d0 ) | d0 Dy , d0 6= d} 6 Xprerop(c,c0 )
context (c, c0 ) set ctx(c, c0 ) partial variable assignments that,
every (y, d) seff(c, c0 ), X (y, (y)) ctx(c, c0 , y, d). identify ctx(c, c0 )
set facts occur assignments.
198

fiAnalyzing Search Topology Without Running Search

Note definition ctx(c, c0 ) over-writes previous one Section 5,
sense distinguish possible tuples context values,
rather collecting overall set. need fine-grained definition
precisely formulate Definition 2 condition (2c), i.e., conditions transition
recoverable side effect deletes. Namely, Definition 2 conditions (2b) (2c)
formalized follows:
transition (c, c0 ) replaceable side effect deletes iff ctx(c, c0 )sG = and, every
rop(c, c0 ) 6= preo ctx(c, c0 ) 6= exists o0 eff o0 = eff
preo0 prevrop(c,c0 ) eff rop(c,c0 ) .
transition (c, c0 ) recoverable side effect deletes iff following two conditions
hold:
Either (c, c0 ) irrelevant side effect deletes or, every ctx(c, c0 ),
exists recovering
operator preo prevrop(c,c0 ) eff rop(c,c0 ) eff ,
eff (sG rop(c,c0 )6=o0 preo0 ).
Every (y, d) seff(c, c0 ) goal appears operator precondition
possibly recovering operators.
t0 replaceable side effect deletes, upon execution remove o0
relaxed plan operator relying deleted facts replaced. t0
recoverable side effect deletes, then, due first clause definition, matter
state s0 apply t0 matter context holds s0
recovering operator applicable t0 re-achieves relevant facts. Due
second clause, delete facts relevant elsewhere relaxed plan (note
anything deleted must side effect t0 ).
Finally, formally define notion used Definition 2 condition (2a) oDG+ +
(s)-recoverable assume surroundings pertaining
relevant deletes t0 P>0
Theorem 2, i.e., (X, sI , sG , O) planning task, state, P + (s) optimal relaxed
plan s, oDG+ = (V, A) optimal rplan dependency graph leaf variable x0
transition t0 = (s(x0 ), c) responsible operator o0 . considering state s0
t0 executed, reaching state s1 , examining relaxed plan P1+ s1
+
constructed P + (s) removing o0 , replacing operators P<0
(s)
+
operators responsible induced oDT Gx transitions x V \ {x0 }.
C0 := {(x0 , s(x0 ))} ctx(t0 ) denote values potentially deleted t0 .
R1+ denote union sG , precondition P + (s) operator
o0 , precondition operator responsible operator
induced transition oDT G+
x , x V \ {x0 }. discussed Section 5,
super-set facts possibly needed P1+ .

F0 := oP + (s) eff denote set facts true relaxed execution
<0

+
P<0
(s) s. discussed Section 5, p 6 F0 p needed s1 P1+
relaxed plan.

199

fiHoffmann

S1 denote union of: (1) prevo0 eff o0 ; (2) set facts (x, c)
+
exists x Xeff either o0 P<0
(s) responsible
+
operator induced transition oDT Gx , x V \ {x0 }; (3) set F defined
F := {(x, c) | (x, c) F0 , x V \ {x0 }} Xeff o0 (V \ {x0 }) = , else F := . Here,
(1) (2) facts certain true s1 ; (3) set
facts able achieve start P1+ , appropriately re-ordering
operators.

+ (s), relaxed-plan macro-precondition

= ho1 , . . . , sub-sequence
P
Sn
i1


+
defined pre
:= i=1 (preoi \ j=1
eff oj ). relaxed-plan macro-effect


n




+
defined eff
:= i=1 eff oi . empty sets default empty


set. notions simply capture outside needs effects relaxed plan
sub-sequence.
+
+
(s)-recoverable iff P>0
(s) contains sub oDG+ -relevant deletes t0 P>0


+
+
+
sequence o0 pre



eff

C

F
.

first condition

R



1
0
0
1
o0
o0


ensures o0 applicable appropriate point within P1+ . second

o0 .
clause ensures facts relevant P1+ re-achieved

proceed exit path construction. follows, first consider
part path leading s0 , i.e., move non-leaf variables x V \{x0 }.
show construct relaxed plans P + (s0 ) states s0 visited path.
First, note assume P + (s) sorted according optimal rplan
dependency graph oDG+ = (V, A). Precisely, let xk , . . . , x1 topological ordering
V \ {x0 } according arcs A. Due construction (V, A) per Definition 1,
previous values never removed relaxed state space, re-order
+
+
(s, x1 ) P . is, perform moves
(s, xk ) P<0
P + (s) take form P<0
+
within oDT Gx front, order conforming A. henceforth assume,
wlog, P + (s) form.
+
Recall follows original oDT G+
x transitions taken P<0 (s),
whereas induced oDT G+
x transitions included inverse original tran

sition. path
p invertible transitions traversing hc0 , . . . , cn i, inverse path
p


traverses hcn , . . . , c0 replacing transition inverse. rop( p ) denote
operator sequence responsible path.
say state s0 invertible surroundings according oDG+ s0

reachable executing sequence
responsible operators invertible/induced
+
transitions oDT Gx x V \ {x0 }. adapted relaxed plan s0 , denoted
P + (ss0 ), constructed follows. Let xk , . . . , x1 topological ordering V \ {x0 }
according A, denote P + (s) = P + (s, xk ) P + (s, x1 ) P . Initialize P + (ss0 ) :=

P + (s). Then, xi V \ {x0 }, let
p path original invertible transitions

+
0
oDT Gxi leading s(xi ) (xi ) clearly, path must exist. Remove rop(
p )


+
0
+
0
P (ss ), insert rop( p ) start P (ss , xi ).
next show adapted relaxed plans indeed relaxed plans, restricting
conditions correspondence Definition 2 condition (3):
Lemma 1. Let (X, sI , sG , O) planning task, let state 0 < h+ (s) < ,
let P + (s) optimal relaxed plan s. Say oDG+ = (V, A) optimal rplan
200

fiAnalyzing Search Topology Without Running Search

dependency graph P + (s) where, every x V \ {x0 }, invertible/induced oDT G+
x
transitions irrelevant side effect deletes side effects V \ {x0 }. Let s0
state invertible surroundings according oDG+ . P + (ss0 ) relaxed
plan s0 , |P + (ss0 )| |P + (s)|.
+
+
Proof. definition, know P + (s) takes form P<0
(s, xk ) P<0
(s, x1 ) P ,
+
+
+
0
0
0
P (ss ) takes form P<0 (s , xk ) P<0 (s , x1 ) P , xk , . . . , x0
topological ordering V , P operator sequence common both,
whose content important proof. simplicity, denote rest
proof P + (ss0 ) P + (s0 ), leave away < 0 subscripts.

Consider first (relaxed) execution P + (s, xk ) P + (s0 , xk ). Say
p
+ (s0 ), i.e., path original invertible
path oDT G+
considered


definition

P
xk


0
transitions oDT G+
xi leading s(xk ) (xk ). Clearly, ho1 , . . . , := rop( p )

sub-sequence P + (s, xk ). Say
p visits vertices s(xk ) = c0 , . . . , cn = s0 (xk ); denote
C := {c0 , . . . , cn }. Assume wlog P + (s, xk ) starts ho1 , . . . , note
re-order P + (s, xk ) (and relaxed plans general) way want long
violate operator preconditions. latter case because: ho1 , . . . ,
constitutes path oDT G+
xk ; operators depending value C

ordered occur later P + (s, xk ); because, since transitions
p side
effects V \{x0 }, construction (V, A) per Definition 1 operators ho1 , . . . ,
support way, P + (s), affecting variable xk .
Given above, wlog P + (s, xk ) form ho1 , . . . , P1 . construction,



+
P (s0 , xk ) form rop(
pS
) P1 =: h

n , . . . , o1 PS
1 . Consider endpoints
n
+
+
0
prefixes, i.e., s1 := i=1 eff oi s2 := 1i=n eff
oi . Clearly, since

transitions
p irrelevant side effect deletes, relevant part
contained s0 . then, far variables outside V \ {x0 , xk } concerned,
+
relevant part s+
1 contained s2 : relevant side effects ho1 , . . . , already
0
contained ; values C obviously true s+
2 ; induced transitions side


+

effects, increase fact set s2 . Further, sequence h
n , . . . , o1
applicable relaxation. see this, note first preconditions xk


satisfied definition, h

n , . . . , o1 constitutes path DT Gxk . side effects,
occur, harmful old values over-written relaxation.
preconditions variables, due invertibility outside conditions
oi contained oi subset ho1 , . . . , i. Hence, Definition 1
since xk incoming edges oDG+ , preconditions satisfied s.
satisfied s0 (vk root oDG+ ) variables x
contained V hence s0 (x) = s(x) prerequisite note precondition facts
cannot deleted side effects whose deletes irrelevant prerequisite.
shown relevant part outcome relaxed execution
P + (s, xk ) contained outcome relaxed execution P + (s0 , xk ) s0 ,
variables outside V \ {x0 , xk }. iterate argument. Assume induction
hypothesis already shown relevant part outcome relaxed
execution P + (s, xk ) . . . P + (s, xi+1 ) contained outcome relaxed execution
P + (s0 , xk ) P + (s0 , xi+1 ) s0 , variables outside V \ {x0 , xk , . . . , xi+1 }.
consider P + (s, xi ) P + (s0 , xi ). thing changes respect xk
may preconditions variables xj true s; j >

201

fiHoffmann

preconditions must belong predecessors xi oDG+ Definition 1.
Since P + (s) = P + (s, xk ) P + (s, x1 ) P relaxed plan s, conditions
established relaxed execution P + (s, xk ) P + (s, xi+1 ) s. Given this,
induction hypothesis conditions clearly irrelevant established
relaxed execution P + (s0 , xk ) P + (s0 , xi+1 ) s0 , concludes argument
inductive case. = 1, follows relevant part outcome relaxed
execution P + (s, xk ) P + (s, x1 ) contained (on variables) outcome
relaxed execution P + (s0 , xk ) P + (s0 , x1 ) s0 . this, claim follows trivially
P + (s) relaxed plan s, remainder P operator sequences
identical.
second part claim follows because, 6= j, original
transitions use xi respectively xj operators common. because,
argued above, relevant operators side effects V \ {x0 }. Since
operators affects variable xi , cannot affect variable V \ {x0 }. Thus,
inverse transition introduce via inverse operator, P + (s) contains separate
operator. this, obviously get |P + (ss0 )| |P + (s)|.
Lemma 1 captures second case Definition 2 condition (3), transitions
invertible/induced irrelevant side effect deletes side effects V \ {x0 }.
next lemma captures first case Definition 2 condition (3):
Lemma 2. Let (X, sI , sG , O) planning task, let state 0 < h+ (s) < ,
let P + (s) optimal relaxed plan s. Say oDG+ = (V, A) optimal rplan
dependency graph P + (s) where, every x V \ {x0 }, invertible/induced oDT G+
x
transitions irrelevant side effect deletes side effects V \ {x0 }. Let s0
state invertible surroundings according oDG+ . Let s00 state reached
s0 P + (ss0 , x) operator constituting transition (c, c0 ) x V , s0 (x) = c,
self-irrelevant deletes. removing P + (ss0 ) yields relaxed plan
s00 .
Proof. Lemma 1, P + (ss0 ) relaxed plan s0 . Now, upon execution o, s00 ,
effects true, i.e., (x, c0 ) side effects (if present). hand,
obviously facts (z, e) true s0 s00 ctx(c, c0 ){(x, c)}. Since,
prerequisite, transition (c, c0 ) self-irrelevant deletes, facts ctx(c, c0 ){(x, c)}
either irrelevant rop(c, c0 )-only relevant, meaning goal occur
operator precondition than, possibly, itself. claim follows directly
that.
remark much easily formulated, general, version Lemma 2
could proved simply associating notion self-irrelevant deletes operators
rather transitions, postulating used P + (s). argument
corresponds part (A) proof Lemma 3 authors previous work (Hoffmann,
2005). state argument particular form since form
need below.
almost ready prove main lemma behind exit path construction.
need one last notation, capturing simpler form cost function costd (oDG+ )
202

fiAnalyzing Search Topology Without Running Search

considered Section 5. simpler function make use shortcut construction;Pthat construction introduced separately below. define
costd (oDG+ ) := xV costd (x), costd (x) :=
(
1
x = x0
P
+

0
diam(oDT Gx ) x0 :(x,x0 )A cost (x ) x 6= x0
Lemma 3. Let (X, sI , sG , O) planning task, let state 0 < h+ (s) < ,
let P + (s) optimal relaxed plan s. Say oDG+ = (V, A) successful

optimal rplan dependency graph P + (s). exists operator sequence

that:

(I)
constitutes monotone path state s1 h+ (s) > h+ (s1 ).

(II) length
costd (oDG+ ) Definition 2 condition (2a)
(2b), costd (oDG+ ) + 1 Definition 2 condition (2c).
Proof. Let xk , . . . , x1 topological ordering V \{x0 } according arcs A. Consider
state s0 every x V \ {x0 } s0 (x) vertex oDT G+
x ,
every variable x outside V \ {x0 } s0 (x) = s(x) unless s(x) irrelevant. Say
preo0 s0 . Note first state s0 exists. definition, either
preo0 (x0 ) undefined preo0 (x0 ) = s(x0 ) = s0 (x0 ). (Note every variable
x outside V \ {x0 } s0 (x) = s(x) unless s(x) irrelevant covers
case transition V \ {x0 } side effect x0 , whose delete must
prerequisite irrelevant thus either side effect x0 := s(x0 ) o0 actually
preconditioned x0 .) Definition 1 P + (s) relaxed plan s,
variable x Xpreo contained V unless preo0 (x) = s(x). reasons,
0
+
construction oDT G+
x , preo0 (x) vertex oDT Gx .
Now, consider state s1 results applying o0 s0 . first consider
situation s0 invertible surroundings according oDG+ ; opposite
case discussed below. apply Lemma 1 s0 , hence relaxed
+
(s, x), x
plan P + (ss0 ) s0 results replacing, P + (s), moves P<0
+
+
+
0
V \ {x0 }, inverses. particular, h (s) h (s0 ), P (ss0 , x ) = P + (s, x0 )
x0 6 V . relaxed plan s1 ? distinguish Definition 2 condition (2)
cases (a), (b), (c).

+
case (a), definition P>0
(s) contains sub-sequence
o0 pre+



o0
+
+
+
S1 eff
R1 C0 F0 . implies remove o0 P (s s0 )

o0
obtain relaxed plan P1+ s1 , thus getting h+ (s) > h+ (s1 ). precisely, construct

P1+ by: removing o0 P + (ss0 ); Xeff o0 (V \ {x0 }) 6= moving
o0 occur


+
+
start P1 ; Xeff o0 (V \ {x0 }) = moving o0 occur start P>0
(s)
+
(which unchanged P (ss0 )).

Observe first o0 P + (s s0 )
o0 sub-sequence P + (s s0 ) since
adaptation pertains exclusively operators precede o0 P + (s). Second, course
values established o0 true s1 .

Third,
o0 applicable (in relaxation) assigned point P1+ . see this,
consider first case Xeff o0 (V \ {x0 }) 6= . Then, definition S1 , pre+




0

203

fiHoffmann

contained (prevo0 eff o0 ) set facts (x, c) exists
+
x Xeff either o0 P<0
(s) responsible operator inverse
+
0
transition taken operator P<0
(s). facts true s1 .
obvious prevo0 eff o0 follows facts true
cannot affected operator path s1 . Consider case
Xeff o0 (V \ {x0 }) = . definition S1 , pre+
contained previous sets facts,


o0
plus {(x, c) | (x, c) F0 , x V \ {x0 }}. latter facts, far relevant, true

start
o0 P1+ . execution o0 affect execution
+
P (ss0 ), thus P1+ , point. then, argued Lemma 1,
outcome execution s0 contains, variables V \ {x0 },
+
relevant part outcome P<0
(s) is, relevant part F0 . Since o0
affect variables, true s1 , concludes point.
Finally, consider facts (z, e) true s0 s1 , may

needed P1+ behind
o0 , i.e., either goal precondition
operators. Observe that, since inverse operators performed transitions
variables V \ {x0 }, since include new outside preconditions,
(z, e) contained R1+ .24 Now, say first (z, e) F0 . Then, above,
(z, e) (ctx(s(x0 ), c){(x0 , s(x0 ))})F0 R1+ thus (z, e) eff +
prerequisite


o0
+
(s) else,
done. (z, e) 6 F0 ? Note that, then, (z, e) 6 preo P<0
+
precondition would true relaxed execution P (s) thus P + (s) would
+
(s), thus (z, e) needed
relaxed plan. Neither (z, e) added P<0
+
precondition inverse operator used P (s s0 ) operators
introduce new outside preconditions, course use own-preconditions previously
added operators affecting respective variable. Thus reason (z, e)
+
could needed P1+ either (z, e) sG (z, e) preo P>0
(s).
+
(z, e) sG certainly, since P (s) relaxed plan, achieved operator
P + (s). cannot = o0 since effect o0 true s1 , cannot
+
+
(s), thus contained P1+
(s) since (z, e) 6 F0 . Thus P>0
P<0
+
(s), arguments apply, i.e., must
done. (z, e) preo0 o0 P>0
+
0
P>0 (s), ordered , adds (z, e). concludes proof case (a).
Consider case (b), s(x0 ) 6 R1+ , transition (s(x0 ), c) replaceable
side effect deletes, i.e., ctx(s(x0 ), c) sG = and, every o0 6= preo
ctx(s(x0 ), c) 6= exists o0 eff o0 = eff preo0 prevo0 eff o0 .
obtain relaxed plan P1+ removing o0 P + (s s0 ), replacing
operators respective o0 needed. Precisely, say (z, e) true s0
s1 . z = x0 e = s(x0 ) needed P1+ construction. every z,
must (z, e) ctx(s(x0 ), c). (z, e) goal prerequisite. operator
P1+ (z, e) precondition, replace postulated operator o1
obviously applicable s1 effect. concludes case.
Consider last case (c), definition s(x0 ) 6 R1+ , transition (s(x0 ), c)
recoverable side effect deletes. Here, guarantee decrease h+ obtained s1
24. Note particular special case inverse transitions non-leaf variables x, may
precondition x added by, needed prerequisite of, operators P + (s, x).
preconditions preconditions may needed P + (ss0 ) thus P1+ ,
P + (s). reason include facts definition R1+ .

204

fiAnalyzing Search Topology Without Running Search

itself, successor state s2 s1 . Namely, let o0 operator recovering relevant
side effect deletes (s(x0 ), c). Precisely, let ctx(s(x0 ), c) s0 (such exists
definition ctx(s(x0 ), c)). Then,
let o0 operator preo0 (prevo0 eff o0 )
eff o0 , eff o0 (sG o0 6=o0 preo0 ) (such operator exists case (b)). Say
obtain P1+ replacing, P + (ss0 ), o0 o0 . P1+ relaxed plan
s1 . see this, note first o0 applicable s1 virtue preo0 (prevo0 eff o0 ).
Further, note values deleted o0 plus (x0 , s0 (x0 )). Since
s0 (x0 ) = s(x0 ), s(x0 ) 6 R1+ know s0 (x0 ) 6SR1+ thus delete
consequence. , virtue eff o0 (sG o0 6=o0 preo0 ) facts could
possibly relevant re-achieved o0 . Finally, values established o0 true
s1 .
Now, say obtain s2 applying o0 s1 . removing o0 P1+ yields relaxed
plan s2 . simply established effects true s2 , virtue
eff o0 facts deletes side-effects transition (s(x0 ), c). case (c),
relevant anything except possibly recovering operators. recovering
operator o0 removed P1+ . recovering
operators
could still contained P1+ , since eff eff o0 (sG o0 6=o0 preo0 ),
relevant facts could possibly achieve already true s2 thus remove
well. Hence, overall, h+ (s) > h+ (s2 ).
cases (a) (b) prove (I) constructing monotone path s1 , case (c)
true s2 . (Of course, show (II), constructing path
specified length; ignore issue moment.) difficulty
constructing path achieving preconditions o0 . preconditions may
satisfied s, need reach state s0 satisfied. need
without ever increasing value h+ . Note that, decrease value h+ somewhere
along way, already reached exit monotone path, done. Thus
follows show upper bound h+ (s). Lemma 1, bounding
accomplished starting s, always taking oDT G+
x transitions variables
x V pertaining second case Definition 2 condition (3), i.e., transitions
invertible/induced irrelevant side effect deletes side effects V \ {x0 }.
follows will, brevity, refer transitions case2. Note that,
way, reach states invertible surroundings according oDG+ .

operator sequence
, Lemma 1 know h+ (s) h+ (s0 ) states
0
along way. Now, cannot reach s0 using sequence, i.e.,
0
would take non-case2 oDT G+
x transition (c, c ) variable x, state
s0 ? prerequisite know transition (c, c0 ) self-irrelevant deletes. apply
Lemma 2 because: s0 invertible surroundings according oDG+ ; since
following transition path, clearly s0 (x) = c, i.e., value relevant variable s0
start value last transition taking; construction, P + (ss0 ) changes
P + (s) case2 transitions, thus responsible operator rop(c, c0 ) (which
case2) guaranteed contained P + (ss0 ). Note rop(c, c0 ) cannot
used case2 transitions V \ {x0 } variable might taken
path s0 , prerequisite transitions side effects V \ {x0 },
contradiction constituting transition variable x hand. Thus know
h+ (s) > h+ (s0 ) already constructed desired monotone path exit
205

fiHoffmann



stop. Else, reach s0 sequence
, above,
ho0


(respectively ho0 , o0 i, case (c)) constitutes desired path.

remains show exactly construct operator sequence
. Consider
topological ordering V , xk , . . . , x1 . follows, consider depth indices k
0, say variable x V depth d, written depth(x) = d, iff x = xd .
characterizes d-abstracted planning task identical original planning
task except (and only) outside preconditions, oDT G+
x transitions
variables x depth(x) d, removed pertain values variables x0
depth(x0 ) > d. prove induction that:

(*) d-abstracted task, exists operator sequence
that:


(a) either (1)
ho0 execution path applicable s, (2)
execution path

0
applicable s, last transition (c, c ) variable x taken
relevant,
self-irrelevant deletes, responsible operator contained adapted relaxed
plan state s0 applied to, s0 (x) = c;

(b)
, except last step case (2) (a), uses case2 oDT G+
x transitions
variables x 1 depth(x) d;

(c) number operators
ho0 pertaining x V costd (x).

desired path
results setting := k. see this, note kabstracted planning task identical original planning task. claim follows
discussion above: (a) (b) together mean h+ decreases monotonically




+

P less dthan h (s) end. Given (c), length bounded
xV,depth(x)d cost (x). proves claim adding trivial observation that,
Definition 2 condition (2) case (c) discussed above, need add one
additional operator end path.

give proof (*). base case, = 0, trivial. set
0 empty.
construction (V, A) per Definition 1, construction 0-abstracted
task, outside preconditions o0 either true removed. (a)
(case (1)), (b), (c) obvious.

Inductive case, + 1. Exploiting induction hypothesis, let
operator




sequence per (*). turn requested sequence d+1 + 1abstracted planning task.
remainder proof, consider oDT G+
x , x V \ {x0 },
contain irrelevant transitions, i.e., omit restriction Definition 1.
simplify argumentation show, oDT G+
x paths consider
contain irrelevant transitions, hence contained actual oDT G+
x per
Definition 1.

Let first operator
ho0 i. may applicable s, +
1-abstracted planning task. reason that, however, may precondition
removed d-abstracted planning task removed + 1abstracted planning task. construction, precondition must pertain xd+1 . Say
precondition (xd+1 , c). induction hypothesis, know contained
+
P<0
(s), responsible inverse transition operator. cases, since
inverse transitions introduce new outside preconditions, (xd+1 , c) precondition
206

fiAnalyzing Search Topology Without Running Search

+
operator P<0
(s). Thus c vertex oDT G+
xd+1 trivial (xd+1 , c) true
(which actually cannot case else would applicable
+ 1-abstracted planning task), (xd+1 , c) true follows P + (s)
relaxed plan must thus achieve (xd+1 , c) needed precondition.

+
Hence, P<0
(s, xd+1 ) must contain shortest path
q oDT G+
xd+1 s(xd+1 ) c.
transitions path irrelevant. see this, note first endpoint
operator precondition construction, thus last transition (c1 , c) irrelevant.
then, neither previous transition, (c2 , c1 ): was, (xd+1 , c1 ) would
+
operator precondition; then, rop(c1 , c) contained P<0
(s) construction

+
would constitute transition (c2 , c) oDT Gxd+1 thus
q would


shortest path contradiction. Iterating argument, q contain irrelevant
transitions. Thus, since depth(xd+1 ) = + 1, Definition 1 (which includes nonsatisfied preconditions relevant transitions) construction + 1-abstracted

planning task, outside preconditions used rop(
q ) either true


removed. Hence execute rop( q ). either reached end
sequence, last transition taken oDT G+
xd+1 case2, hence
self-irrelevant deletes prerequisite. latter case, since following path
since discussed adapted relaxed plan exchanges operators pertaining
case2 transitions thus last one executed, clearly attained (a)

case (2) stop part rop(
q ) executed is, own, operator

sequence
d+1 desired. former case, reach state s0 s0 (xd+1 ) = c (and
nothing else relevance deleted, due non-existence relevant side-effect
deletes). s0 , applied, leading state s00 .

Let o0 second operator
ho i. above, o0 applicable s00 ,


0

reason may unsatisfied precondition form (xd+1 , c0 ). above,
+
(s), hence c0 vertex oDT G+
o0 inverse contained P<0
xd+1 . Likewise,
00
+
(xd+1 ) = c vertex oDT Gxd+1 . Now, yet used non-case2
transition oDT G+
xd+1 , else wouldnt get here. means still
invertible surroundings around s(xd+1 ) oDT G+
xd+1 . Clearly, implies
+
0
exists path oDT Gxd+1 c c (we could simply go back s(xd+1 ) move

c0 there). Taking shortest path
q , clearly path length bounded
+
diameter oDT Gxd+1 . path contain irrelevant transitions
endpoint c0 selected operator precondition, values
part shortest path oDT G+
xd+1 , thus argument given applies.

Thus outside preconditions used operators constituting
q either true
removed follows construction (V, A) per Definition 1
+
construction + 1-abstracted planning task operators P<0
(s), follows
inverses thereof inverse operators introduce new outside preconditions. Hence

execute
q s00 . either reached end path,
last transition taken case2, hence self-irrelevant deletes prerequisite.
Consider latter case. state s0 last transition reached
case2 transitions, since transition oDT G+
xd+1 case2, responsible
+
operator must contained P (s) adapted relaxed plan P + (ss0 )
s0 recall that, pointed above, since case2 transitions postulated
207

fiHoffmann

side effects V \{x0 }, responsible operator cannot used them. Further,
clearly since following path transitions, value xd+1 s0
start value transition. Hence attained (a) case (2) stop.
former case, reached state o0 applied (and nothing relevance
deleted, due postulated non-existence relevant side-effect deletes, case2

transitions). Iterating argument, get state last operator
ho0
applied, induction hypothesis reaching state s1 desired (a) case (1).
Properties (a) (b) clear construction. property (c), support

operator
ho0 i, clearly apply diam(oDT G+
xd+1 ) operators
pertaining xd+1 (or stop sequence earlier that). Note that,

operators
ho0 unsatisfied preconditions xd+1 above, pertains
variable x (xd+1 , x) A. consequence construction (V, A)
per Definition 1, fact inverse transitions introduce new outside

preconditions. Thus, comparison
ho0 i, overall execute
X
diam(oDT G+
k(x)
xd+1 )
x:(xd+1 ,x)A



additional operators
d+1 ho0 i, k(x) number operators
ho0
pertaining variable x. induction hypothesis, property (c) (*), k(x)
costd (x), x depth(x) < + 1, thus x (xd+1 , x) A. Hence
get, newly inserted steps affecting xd+1 , upper bound
X
diam(oDT G+
)

costd (x)
xd+1
x:(xd+1 ,x)A

identical costd (xd+1 ). concludes argument.
next note improve exit distance bound case insist
monotone exit paths:
Lemma 4. Let (X, sI , sG , O) planning task, let state 0 < h+ (s) < ,
let P + (s) optimal relaxed plan s. Say oDG+ = (V, A) successful
optimal rplan dependency graph P + (s). Let V V \ {x0 } that, every x V ,
oDT G+
x transitions invertible/induced irrelevant side effect deletes
side effects V \{x0 }, DT Gx transitions either irrelevant, empty

conditions irrelevant side effect deletes. exists operator sequence

that:

(I)
constitutes path state s1 h+ (s) > h+ (s1 ).

(II) length
costd (oDG+ ) Definition 2 condition (2a)
(2b), costd (oDG+ ) + 1 Definition 2 condition (2c).
Proof. simple adaptation Lemma 3, adopt follows terminology proof lemma. thing changes bound imposed
exit path length sharper, insist path monotone.
level proof mechanics, happens that, whenever xd+1 V , choose
208

fiAnalyzing Search Topology Without Running Search


path
q achieve next open precondition operator already chosen participate


ho0 i, restrict paths within oDT G+
xd+1 , allow
shortest path DT Gxd+1 . shortest path DT Gxd+1 value occurs

operator precondition,
q contains irrelevant transitions (same argument

proof Lemma 3). Further,
q executable prerequisite alternative
(non-oDT G+
)
transitions


outside conditions; original/induced transitions,
x
precondition achievement works exactly before. Note important property
open preconditions achieved xd+1 ever pertain values contained
oDT G+
xd+1 . trivial see induction alternative transitions
outside preconditions. Since prerequisite deletes alternative transitions
irrelevant, executing harm need minor extension Lemma 1,
allowing s0 identical state s00 invertible surroundings s, modulo
set irrelevant values hold s00 s; obvious extension
valid. extension, obvious arguments pertaining s0 s1

remain valid. Finally, consider case
q involves non-case2 oDT G+
xd+1 transition.
state transition applied invertible surroundings s.
holds x 6 V construction remains same. holds
x V because, first, alternative transitions outside conditions, hence cause
higher-depth transitions inserted between, hence value lower-depth
+
variables x oDT G+
x ; second, prerequisite, oDT Gx contain non-case2
transitions, thus value x clearly reached case2 transitions.
Theorem 2. Let (X, sI , sG , O), s, P + (s), oDG+ Definition 1. oDG+ successful, local minimum, ed(s) costd (oDG+ ). Definition 2
condition (2a) (2b), ed(s) costd (oDG+ ) 1.
Proof. direct consequence Lemmas 3 4.
note prerequisites Lemma 4 could weakened allowing, x V ,
outside conditions already true s. extension obviously break
proof arguments. omitted make lemma prerequisite even
awkward already is.
indicated, exit path constructed Lemma 4 necessarily monotone. Example 5 Appendix A.4 contains construction showing this.
A.3 Conservative Approximations
sake self-containedness section, re-state definitions given Section 6:
Definition 3. Let (X, sI , sG , O) planning task, let 0 < h+ (s) < , let
x0 XsG , let t0 = (s(x0 ), c) relevant transition DT Gx0 o0 := rop(t0 ).
local dependency graph s, x0 , o0 , local dependency graph brief,
graph lDG = (V, A) unique leaf vertex x0 , x V (x, x0 ) either:
x0 = x0 , x Xpreo , preo0 (x) 6= s(x); x0 V \ {x0 } (x, x0 ) arc SG.
0

209

fiHoffmann

global dependency graph x0 o0 , global dependency graph brief,
graph gDG = (V, A) unique leaf vertex x0 , x V (x, x0 ) either:
x0 = x0 x0 6= x Xpreo ; x0 V \ {x0 } (x, x0 ) arc SG.
0

Definition 4. Let (X, sI , sG , O), s, t0 , o0 , G = lDG G = gDG Definition 3.
say G = (V, A) successful following holds:
(1) G acyclic.
(2) G = lDG sG (x0 ) 6= s(x0 ), exists transitive successor x0 x0
SG x0 XsG sG (x0 ) 6= s(x0 ).
(3) t0 either:
(a) self-irrelevant side effect deletes;
(b) replaceable side effect deletes;
(c) recoverable side effect deletes.
(4) x V \ {x0 }, DT Gx transitions either irrelevant, self-irrelevant
deletes, invertible irrelevant side effect deletes side effects
V \ {x0 }.
Lemma 5. Let (X, sI , sG , O) planning task, let state 0 < h+ (s) <
. Say x0 X and, every o0 = rop(s(x0 ), c) DT Gx0 t0 = (s(x0 ), c)
relevant, lDGo0 successful local dependency graph s, x0 , o0 . Then, least
one o0 , exist optimal relaxed plan P + (s) s, successful optimal rplan
dependency graph oDG+ P + (s), x0 , o0 , oDG+ sub-graph lDGo0 .
Proof. Observe first Definition 4 property (2) forces relaxed plan P + (s) move
x0 , i.e., P + (s, x0 ) non-empty. particular, P + (s, x0 ) takes path

DT Gx0 s(x0 ) sG (x0 ). Let
q shortest path taken P + (s, x0 ), let

o0 responsible operator first transition
q . Clearly, transition
form (s(x0 ), c), i.e., o0 one operators o0 claim. Lying shortest path
s(x0 ) sG (x0 ) sub-graph DT Gx0 taken P + (s, x0 ), transition (s(x0 ), c)
irrelevant. seen exactly argument given proof

Lemma 3 transitions paths
q constructed there, except endpoint
goal instead operator precondition.
Next, observe optimal P + (s) contains one operator x0 Xpreo
preo (x0 ) = s(x0 ). follows Definition 4 property (2): x0 cannot become important non-achieved goal, i.e., P + (s) operator outside P + (s, x0 ) relies precondition x0 . see this, assume operator exist.
Then, since P + (s) optimal, exists reason inclusion o. Precisely,
must achieve least one fact needed terms Hoffmann Nebel
(2001b): fact either goal precondition another operator o0
behind P + (s). Iterating argument o0 (if necessary), obtain sequence
= o1 , (x1 , c1 ), o2 , (x2 , c2 ), . . . , , (xn , cn ) (xn , cn ) goal fact satisfied
oi achieves (xi , ci ) P + (s). Obviously, SG contains path x0 xn ,
xn XsG sG (xn ) 6= s(xn ), contradiction Definition 4 property (2). Thus
exist. argument, follows every operator P + (s, x0 )
210

fiAnalyzing Search Topology Without Running Search

either side effect used elsewhere relaxed plan, precondition x0 .
Thus operators P + (s, x0 ) preconditioned x0 serve transform
s(x0 ) sG (x0 ). course, then, single one operators relies s(x0 )
else P + (s) optimal.
Say follows lDGo0 = (V, A). Denote (V 0 , A0 ) result backchaining
+
Definition 1 o0 P<0
(s). Definition 3 include variables arcs included
Definition 1. see this, note arcs (x, x0 ) included Definition 1 due
relevant transitions. Hence (V 0 , A0 ) sub-graph (V, A). particular, since (V, A)
acyclic, (V 0 , A0 ) acyclic well.
next observation that, assuming Definition 4 condition (2) holds true, Definition 4 condition (3a) implies Definition 2 condition (2a), Definition 4 condition (3b) implies
Definition 2 condition (2b), Definition 4 condition (3c) implies Definition 2 condition
(2c).
Consider first case (a) t0 self-irrelevant side effect deletes. show
+
R1 C0 = . Recall notations Appendix A.2 C0 = {(x0 , s(x0 ))} ctx(t0 ),
R1+ super-set set facts need relaxed plan removing o0 .
variables except x0 , clear fact intersection: facts
ctx(t0 ) irrelevant o0 -only relevant prerequisite, thus contained R1+ .
Hence, (x0 , s(x0 )) remains possible content R1+ C0 . show follows
(x0 , s(x0 )) 6 R1+ , thus (x0 , s(x0 )) 6 R1+ C0 latter intersection empty,
desired. Recall R1+ denotes union sG , precondition o0 6= P + (s),
precondition operator responsible operator induced
transition oDT G+
x , x V \ {x0 }. Definition 4 condition (2), (x0 , s(x0 )) 6 sG .
argued above, o0 operator P + (s) may preconditioned s(x0 )
thus precondition o0 6= P + (s). Lastly, say p precondition
responsible operator induced transition oDT G+
x , corresponding original
transition t. Then, since inverse transitions introduce new conditions,
+
(s). then, since
p cond(t) thus p prerop(t) where, definition, rop(t) P<0
+
o0 6= rop(t) P (s), (x0 , s(x0 )) 6 prerop(t) , implies p 6= (x0 , s(x0 )).
Thus (x0 , s(x0 )) 6 R1+ needed show.
Consider case (b) t0 recoverable side effect deletes. show Definition 2
condition (2b) o0 = rop(t0 ), need prove s(x0 ) oDG+ -relevant,
i.e., s(x0 ) 6 R1+ . already shown above.
case (c), t0 replaceable side effect deletes. Again, show Definition 2 condition
(2c) t0 ), need prove s(x0 ) oDG+ -relevant.
Consider finally conditions imposed non-leaf variables x V \ {x0 }, i.e., Definition 4 condition (4) Definition 2 condition (3). Definition 4 condition (4),
DT Gx transitions every x V \ {x0 } either irrelevant, self-irrelevant deletes,
invertible irrelevant side effect deletes side effects V \ {x0 }.
DT Gx transitions irrelevant cannot oDT G+
x , thus 2nd 3rd case
+
0
true oDT Gx transitions every x V \ {x0 }. concludes argument.
Theorem 3. Let (X, sI , sG , O) planning task, let state 0 <
h+ (s) < . Say x0 X that, every o0 = rop(s(x0 ), c) DT Gx0
(s(x0 ), c) relevant, lDGo0 successful local dependency graph. local
211

fiHoffmann

minimum, ed(s) maxo0 costD (lDGo0 ). If, every lDGo0 , Definition 4
condition (3a) (3b), ed(s) maxo0 costD (lDGo0 ) 1.
Proof. Lemma 5, choice o0 = rop(s(x0 ), c) exists optimal relaxed
plan P + (s) successful optimal rplan dependency graph oDG+ = (V 0 , A0 ) P + (s),
oDG+ sub-graph lDGo0 unique leaf vertex x0 . apply
Lemma 3 obtain local minimum.
see part claim, let V defined Section 6, i.e., V subset
V \ {x0 } DT Gx transitions either irrelevant, invertible
empty conditions, irrelevant side effect deletes, side effects V \ {x0 }. Then,
DT Gx transition x V , satisfies restriction required Lemma 4
+
oDT G+
x transitions irrelevant, cannot oDT Gx , else invertible
irrelevant side effect deletes side effects V \ {x0 } restriction
required Lemma 4 transitions either irrelevant, empty conditions
irrelevant side effect deletes. hence apply Lemma 4 oDG+ , obtain (not
necessarily monotone) path exit, length bound costd (oDG+ ) (s(x0 ), c)
irrelevant side effect deletes replaceable side effect deletes, costd (oDG+ ) + 1
(s(x0 ), c) recoverable side effect deletes. thus suffices show costD (lDGo0 )
costd (oDG+ ). That, however, obvious V V 0 , costD (x) 0 x,
0
maxPath(DT Gx ) diam(oDT G+
x ) x V .
Theorem 4. Let (X, sI , sG , O) planning task. Say global dependency graphs
gDG successful. contain local minima and, state
0 < h+ (s) < , ed(s) maxgDG costD (gDG). If, every gDG, Definition 4
condition (3a) (3b), ed(s) maxgDG costD (gDG) 1.
Proof. Let state. need prove local minimum. h+ (s) = 0
h+ (s) = , nothing show. Else, assume variables X topologically
ordered according strongly connected components SG, let x0 X
uppermost variable x0 XsG sG (x0 ) 6= s(x0 ); obviously, x0 exists. Clearly,
chance x0 satisfy Definition 4 condition (2) exists transitive
successor x0 x0 SG x0 XsG sG (x0 ) 6= s(x0 ) exists x0
strongly connected SG component, x0 XsG (and sG (x0 ) 6= s(x0 )).
then, exists transition t0 DT Gx0 outside condition eventually leading,
backwards chaining SG, x0 . Let gDG0 global dependency graph x0
rop(t0 ) (such gDG0 exists x0 XsG ). Since Definition 3 includes transitive
SG-predecessors x0 pertaining conditions t0 , gDG0 includes x0 . then, since
x0 x0 lie strongly connected component, Definition 3 eventually reaches
x0 . Thus gDG0 contains cycle, contradiction prerequisite. follows
strongly connected SG component x0 contains x0 , thus Definition 4 condition
(2) holds true.
Now, say o0 responsible relevant transition form (s(x0 ), c) DT Gx0 .
exists local dependency graph lDG s, x0 , o0 lDG sub-graph
gDG. follows simple observation Definition 3 include, gDG,
variables arcs include lDG. (Note precondition o0
212

fiAnalyzing Search Topology Without Running Search

x0 , present, satisfied o0 = rop(s(x0 ), c), thus Definition 3
include x0 predecessor achieving o0 preconditions lDG.)
Obviously, given above, lDG successful. Since works choice notirrelevant (s(x0 ), c), apply Theorem 3. claim follows directly
fact costD (gDG) costD (lDG). latter obvious costD increases
monotonically adding additional variables.
A.4 Example Constructions
first example shows that, even within scope basic result, operators
necessarily respected relaxation, i.e., operator may start optimal real plan yet
occur optimal relaxed plan.
Example 1. Consider planning task Figure 4. Variables shown (in dark green)
left hand side respective DTG. Circles represent variable values, lines
represent DTG transitions. Transitions condition longer lines, condition
inscribed line (in blue). variable, dashed arrow indicates value
initial state sI . goal value defined, indicated circled value.
needed, refer operators responsible transition terms respective
variable followed indices start end value. example, operator moving
x c1 c2 referred x12. abbreviate states {(x, c), (y, d)} (c, d).
stick conventions throughout section.

x

d1

c1

c2

d3

c3

d7


d1

d2

d3

d7

Figure 4: Planning task underlying Example 1.
shown Figure 4, DTG x consists three vertices whose connection requires
conditions d1 d3 , alternatively d7 shortcut. domain line
length 6 requiring conditions.
Clearly, support graph planning task acyclic, transitions DTGs
side effects invertible. However, operator y34 (for example) respected
relaxation. see this, note first h+ (sI ) = 4: optimal relaxed plan
hy32, y21, x12, x23i relaxed plan ignores need move back d3 operator x23. hand, optimal (real) plan sI hy34, y45, y56, y67, x17i.
choose use y32 instead, optimal relaxed plan does, end
sequence hy32, y21, x12, y12, y23, x23i 1 step longer. Hence, sI , y34 starts
optimal plan, start optimal relaxed plan.
213

fiHoffmann

next give three examples showing local minima arise simple situations generalizing basic result minimally. consider, order: cyclic support
graphs; non-invertible transitions; transitions side effects.
Example 2. Consider planning task Figure 5.

x
c1

d1

c2


d1

d2

dn1

dn

c1

Figure 5: Planning task underlying Example 2.
DTG x two vertices whose connection requires condition d1 .
domain line length n requiring conditions, shortcut d1
dn requires c1 condition. Clearly, transitions DTGs side effects
invertible. However, SG contains cycle x mutually
depend other. show mutual dependence causes initial state
sI = {(x, c1 ), (y, d1 )} local minimum, n 5. abbreviate, before, states
{(x, c), (y, d)} (c, d). h+ (sI ) = 2: optimal relaxed plan hx12, y1ni.
consider operators applicable sI = (c1 , d1 ):
Execute x12, leading s1 = (c2 , d1 ) h+ (s1 ) = 2 due hx21, y1ni. here,
new state reached via y12, giving s2 = (c2 , d2 ) h+ (s2 ) = 3 due
hy21, x21, y1ni. (Note n 2 3 prerequisite, relaxed plan composed
yi(i + 1) operators 3 steps.) h+ (s2 ) > h+ (sI ) way
cannot reach exit monotone path.
Execute y12, leading s3 = (c1 , d2 ) h+ (s3 ) = 3 due hy21, x12, y1ni. (Note
n 2 3 prerequisite, relaxed plan moving ypp operators
4 steps.) Again, path monotone.
Execute y1n, leading s4 = (c1 , dn ) h+ (s4 ) = 2 due hyn1, x12i. here,
new state reached via yn(n1), giving s5 = (c1 , dn1 ) h+ (s5 ) = 3
due hy(n1)n, yn1, x12i. (Note n2 3 prerequisite, relaxed plan
moving d1 via dn2 , . . . , d2 3 + 2 steps.) Again, path monotone.
operators applicable sI , thus explored states reachable sI
monotone paths. None states exit, proving sI local minimum (as
s1 s4 ). is, fact, single state h+ (s) = 1, namely = (c2 , dn1 ).
Clearly, reaching sI takes n 1 steps: first apply x12, traverse d2 , . . . , dn2 .
exit distance sI n 3, thus distance unbounded.
214

fiAnalyzing Search Topology Without Running Search

Section 9, following modification Example 2 considered. set n := 2, i.e.,
domain reduced two values d1 , d2 ; remove line d2 , . . . , dn2 ,
i.e., move via previously short-cut. modified example falls
SAS+ -PUBS tractable class identified Backstrom Klein (1991), still
contains local minimum (the example unsolvable, though).
Example 3. Consider planning task Figure 6.

x
c1

d2

c2

d1

c3


d1

d2

dn

Figure 6: Planning task underlying Example 3. arrow d1 d2 indicates
respective DTG transition directed, i.e., exists transition d2
d1 .
DTG x three vertices whose connection requires (starting initial value
c1 ) first condition d2 , condition d1 . domain circle length n requiring
conditions, invertible except arc d1 d2 .
Clearly, support graph acyclic transitions DTGs side effects.
However, non-invertible arc d1 d2 causes initial state sI = (c1 , d1 )
local minimum n 3. easy see. h+ (sI ) = 3 due
optimal relaxed plan hy12, x12, x23i. Note relaxed plan
move back (y, d1 ) still true executing y12. Now, operators applicable
sI y12 y1n. latter, reaching state sn = (c1 , dn ), immediately increases
value h+ . because, n 3, y1n get closer d2 , moving
farther away d1 (both need achieved). shortest relaxed sn
hyn1, y12, x12, x23i. Alternatively, say apply y12 sI , reaching state s2 = (c1 , d2 ).
h+ (s2 ) = n + 1: need apply, relaxation, x12, n 1 steps complete
circle d2 back d1 , x23. Thus, n 3, s2 larger h+ value sI .
follows sI local minimum. nearest exit sI sn1 = (c2 , dn1 ): sn1
relaxed plan hy(n 1)n, yn1, x23i length 3, applying y(n 1)n get h+
value 2. Reaching sn1 sI takes 1 step moving x n 2 steps moving y.
exit distance sI n 1, thus distance unbounded.
Example 4. Consider planning task Figure 7.
DTG x consists two kinds transitions. First, line c1 , . . . , cn
transitions requiring conditions. Second, direct links, called short-cuts
follows, cn every ci , conditioned value d1 y. DTG contains
two vertices connected unconditionally. Moving d1 d2 side-effect
cn . (That side-effect responsible towards-cn direction short-cuts
DTG x.)
215

fiHoffmann

d1
d1

x
c1

c2

cn

cn


d1

d2

Figure 7: Planning task underlying Example 4. (red) inscription cn line
d1 d2 indicates transition d1 d2 side effect
cn .
support graph acyclic. arc goes x, due short-cuts
DTG x, due operator y12 effect x precondition y.
transitions invertible; particular short-cut both, direction towards
cn vice versa. However, side-effect y12 causes initial state sI = (c1 , d1 )
local minimum n 3.
h+ (sI ) = 1 due optimal relaxed plan hy12i. Note
relaxed plan care side effect y12, c1 still true afterward.
Now, apply operator sI leaves c1 , clearly increase h+ 1:
matter move make, relaxed plan must include y12 move back c1 .
available option sI apply y12. get state s1 = (cn , d2 ). There,
h+ (s1 ) = 2 well, relaxed plan needs re-achieve c1 . Since n 3,
via unconditional sequence cn , . . . , c1 takes 2 steps. alternative use
short-cut xn1 cn c1 ; involves applying y21 first place, giving us
relaxed plan length 2. Hence direct successors sI heuristic value > 1,
sI local minimum. Note exit distance sI grows n. nearest
exit state goal reached single step. Clearly,
state (c2 , d2 ). shortest path state, sI , applies y12 moves along
unconditional line cn , . . . , c2 , taking 1 + (n 2) = n 1 steps.
next show exit path constructed using short-cuts, leading improved
bound costd instead costd , may non-monotone, improved bound may
indeed under-estimate length shortest monotone exit path.
Example 5. Consider planning task Figure 8.
example, optimal relaxed plan initial state moves z along
path e0 , . . . , e2n note values needed moving moves
d2k+2n , moves x c1 . gives total h+ (sI ) = 2n + (2k + 2n) + 1 = 4n + 2k + 1
steps.
operators applicable sI move z. move along line e0 , . . . , e2n ,
h+ remains constant: always need include moves back order achieve
goal z. reach e2n , move one step, need move z back,
etc. moves, state = d2k+2n , long z stays within
216

fiAnalyzing Search Topology Without Running Search

x
c0


d0

e 2n

d1

e0

e0

e 2n

d2

d2k+2n

c1

d2k

e1

d2k+1 e2

e 2n

d2k+2n

z
e0

e1

e 2n1

e 2n

e

Figure 8: Planning task underlying Example 5.
e0 , . . . , e2n , h+ remains constant. see this, observe first course suffices
relaxed plan reach once, z, values line, taking 2n moves wherever
line; moves before. Second, observe indeed moves
needed: wherever line d0 , . . . , d2k+2n , needs move d2k+2n order
suit x, needs move d0 suit goal. Every value e0 , . . . , e2n appears
condition least one moves. Thus, sI , nearest exit reached
way state = d2k+2n z = e2n : there, move x c1

decreases h+ 4n + 2k. length exit path
described, sI s,
obviously 2k (2n + 1) + 2n 2 = 4kn + 2k + 4n.
happens move z e0 ? Consider first sI . h+ increases
4n + 2k + 2: need reach values line e0 , . . . , e2n , e0 takes one

step more. argument applies state traversed
, because, argued,

state still need reach values line e0 , . . . , e2n . Thus

shortest monotone path exit.
optimal rplan dependency graph oDG+ sI entire SG, oDT G+
z
contains DT Gz except e0 . global dependency graph gDG entire SG.
Clearly, sI , next required value reach variable e2n , construction
proof Theorem 2 first try reach value. using short-cuts
accounted costd (.), exit path constructed move e2n via e0 rather via
line e0 , . . . , e2n , thus claimed exit path monotone.
Finally, consider bound returned costd (oDG+ ). Obviously, costd (oDG+ ) =
costD (gDG). obtain bound (1) + costd (oDG+ ) = (1) + 1[costd (x)] + 1 (2k +

2n)[costd (x) diam(oDT G+
)] + (2k + 2n) (n + 1)[cost (y) diam(DT Gz )]. Note
diam(DT Gz ) = n + 1 DT Gz circle 2n + 2 nodes. Overall,
(1)+costd (oDG+ ) = (2k+2n)(n+2) = 2kn+4k+2n2 +4n. sufficiently large k,
less 4kn+2k +4n, claimed. detail, 4kn+2k +4n > 2kn+4k +2n2 +4n
n2
iff 2kn 2k > 2n2 iff kn k > n2 iff k > n1
. holds, example, set n := 2
k := 5.
reader noticed Example 5 contrived. reason need
complicated unrealistic example costd , costd , contains two
sources over-estimation, cf. discussion Section 5. particular, every move non217

fiHoffmann

leaf variables supposed take whole oDT G+ /DT G diameter. show costd
general upper bound length monotone exit path, thus need presented
construction around k under-estimation considering diam(DT Gz ) instead
diam(oDT G+
z ) outweighs over-estimation. Importantly, constructing examples
short-cuts temporarily increase h+ (but costd nevertheless delivers upper bound
monotone exit path length) much easier. needs happen that, whatever
reason, variable z here, currently required value (e2n Example 5)
reached oDT G+
z values along unnecessarily long path whose values needed
relaxed plan. happens quite naturally, e.g., transportation domains
vehicle needs load/unload objects along longer path.
demonstrate that, case analyses apply, exit distance may
exponential.
Example 6. Consider planning task Figure 9.

x0
c 10

x1
c 11

c 52

c 21

c 12

c 51

c 31

c 20

c 52

c 12

c 41

c 51

xn
c 1n

c 2n

c 3n

c 4n

c 5n

Figure 9: Planning task underlying Example 6.
DTG x0 two vertices whose connection conditioned c15 .
variables xi , five vertices line, alternatingly requiring last vertex ci+1

5
i+1
xi+1 first vertex c1 xi+1 . Clearly, optimal rplan dependency graph
oDG+ sI , global dependency graph gDG task full support
graph SG. acyclic, transitions invertible side effects, thus
analyses apply.
h+ (sI ) ed(sI )? relaxed plan, need move x0 c02 . Due
conditioning, variable extreme values left right hand side
required need 4 moves xi 1 n. Thus h+ (sI ) = 1 + 4n.
Now, consider state s(x0 ) = c01 . construct relaxed plan, obviously
still need 1 move x0 . still need 4 moves variable. Consider x1 .
s(x1 ) = c11 need move c15 order able move x0 . s(x1 ) = c12
need move c15 order able move x0 , c11 goal,
forth. cases, four transitions must taken relaxed plan. Due
conditioning, recursively true variables. Thus, h+ (s) = 1 + 4n.
218

fiAnalyzing Search Topology Without Running Search

means nearest exit state s0 x0 value c01 x1 value c15 :
s0 , move x0 afterward, definitely, 4n steps suffice relaxed plan.
distance state s0 ? need move x1 four times. Lets denote d(x1 ) = 4.
move requires 4 moves x2 , d(x2 ) = 16. sequence moves x2 inverses
direction three times. points, x3 need move d(x3 ) = (d(x2 ) 3) 4.
Generalizing this, get d(xi+1 ) = [d(xi ) ( d(x4 ) 1)] 4 = 3d(xi ) + 4, growth
n exponential.
Obviously, Example 6 shows plan length exponential cases
Theorem 4 applies. remark Example 6 similar example given
Domshlak Dinitz (2001). difference Domshlak Dinitzs example
uses different conditions transitions left/to right, enables
use smaller DTGs 3 nodes. setting, cannot use different conditions
need transitions invertible. causes loss exit path steps
situations next lower variable inverses direction thus relies
outside condition previous step. Indeed, DTGs size 3, loss
steps results polynomially bounded exit distance. recursive formula d(xi )
becomes d(xi+1 ) = [d(xi ) ( d(x2 ) 1)] 2 = d(xi ) + 2, resulting ed(sI ) = n2 + n.
hand, costd costD still remain exponential case,
consider loss incurred inversing
directions. Precisely, easy see
P
costd (oDG+ ) = costD (gDG) = 1 + ni=1 2i = 2n+1 1. proves bounds
over-estimate exponential amount.
next example shows exit path constructed (implicitly) analyses may
exponentially longer optimal plan task.
Example 7. Consider planning task Figure 10.

x0
c 10

c 51

c 20

c10

x1
c 11

c 52

c 21

0
c4n+1

c 12

c 31

c 52

c 12

c 41

xn
c 1n

c 2n

c 3n

c 4n

c 5n

Figure 10: Planning task underlying Example 7.
219

c 51

fiHoffmann

example, optimal relaxed plan initial state
Example 6, alternative route via c001 , . . . , c00(4n+1) takes 1 + 4n + 1 = 4n + 2 >
4n + 1 steps. Thus exit path constructed remains same, too, length exponential
n. However, length shortest plan 4n + 2.
Note Example 7 observed weakness guided wrong direction
caused weakness optimal relaxed planning, rather weakness
analysis. relaxation overlooks fact moving via x1 , . . . , xn incur high costs
due need repeatedly undo re-do conditions achieved beforehand. Note
that, example too, get exponential over-estimation exit distance.
finally show feeding Theorem 2 non-optimal relaxed plans give
guarantees:
Example 8. Consider planning task Figure 11.

x
c1
g21

d2

c2

g2n+2

c

v1


d1

en

d2

g11

g21

g1n+2

g2n+2

v n+2

z
e1

e n1

en

Figure 11: Planning task underlying Example 8. arrow en1 en indicates
respective DTG transition directed, i.e., exists transition
en en1 .
two ways achieve goal c2 : either via moving z, moving
v1 , . . . , vn+2 . optimal relaxed plan chooses former option, giving h+ (sI ) = n+1.
soon n 3, however, parallel-optimal relaxed plan P + (sI ) chooses latter
option moving z results n + 1 sequential moves, whereas v1 , . . . , vn+2
moved parallel, giving parallel length 3.
Consider happens h+ either options. move z, h+ remains
constant need move z back goal. soon reach z = en ,
h+ = last transition uni-directional longer achieve
goal z. Thus exit path, particular monotone exit path, via
option.
Say move v1 , . . . , vn+2 instead. first move (whichever vi choose), h+
increases shortest option undo move go via z: takes
n + 2 steps whereas completing vi moves going via c0 takes (n + 1) + 2 = n + 3 steps.
220

fiAnalyzing Search Topology Without Running Search

Thus monotone exit path via option either, sI local minimum.
completing n + 2 moves vi moving x = c0 , h+ = (n + 2) + 1 due
shortest relaxed plan moves back vi moves x = c2 . reduce heuristic
value initial value h+ (sI ) = n + 1, need execute 2 steps.
state reached better evaluated neighbor, exit distance n + 5.
Consider effect feeding Theorem 2 parallel-optimal plan P + (sI ).
Clearly, optimal rplan dependency graph oDG+ constructed P + (sI ) consists x
vi variables, include z. Thus theorem applies,
wrongly concludes sI local minimum.
exit distance bound computed
P
(1

1)[costd (x) diam(DT Gvi )] = n + 2.
(1) + costd (oDG+ ) = (1) + 1[costd (x)] + n+2
i=1
less actual distance ed(sI ) = n + 5, thus result wrong.
Say modify Example 8 making last transition z undirected, making
one vi transitions unidirectional right. v1 , . . . , vn+2 option leads
dead end, whereas y, z option succeeds. particular, Theorem 2 apply
oDG+ constructed parallel-optimal relaxed plan P + (sI ), thus example
using non-optimal relaxed plans results loss information.
A.5 Benchmark Performance Guarantees
give definitions 7 domains mentioned Propositions 1 2. domain,
explain respective property claimed holds true. domains,
assume static properties used PDDL capture unchanging things
shape road network transportation domain. assume follows
static predicates removed prior analysis, i.e., prior testing
prerequisites Theorem 4.
Definition 5. Logistics domain set planning tasks = (V, O, sI , sG ) whose
components defined follows. V = P V P set package-location variables
p, Dp = L V L set representing possible locations, V set
vehicle-location variables v, Dv = Lv subset Lv L locations. contains
three types operators: move, load, unload, move(v, l1, l2) = ({v =
l1}, {v = l2}) l1 6= l2, load(v, l, p) = ({v = l, p = l}, {p = v}), unload(v, l, p) =
({v = l, p = v}, {p = l}). sI assigns arbitrary value variables, sG
assigns arbitrary value subset variables.
Every global dependency graph gDG Logistics either package p leaf
variable x0 , vehicle variable v leaf variable x0 . latter case gDG
consists x0 , arcs. former case, o0 preconditioned single vehicle
v only, leading single non-leaf variable v. cases, gDG acyclic, involved
transitions side effects, involved transitions invertible. Thus
apply Theorem 4. costD (gDG) = 1 + 1 1 packages costD (gDG) = 1
vehicles, thus overall obtain correct bound 1.
Definition 6. Miconic-STRIPS domain set planning tasks =
(V, O, sI , sG ) whose components defined follows. V = B {e}
|O| = |D| = |B| = |S| and: set passenger-origin variables o, = L L
221

fiHoffmann

set representing possible locations (floors); set passenger-destination
variables Dd = L; B set passenger-boarded variables b Db = {1, 0};
set passenger-served variables Ds = {1, 0}; e elevator-location variable
De = L. contains three types operators: move, board, depart,
move(l1, l2) = ({e = l1}, {e = l2}) l1 6= l2, board(l, i) = ({e = l, oi = l}, {bi = 1}),
depart(l, i) = ({e = l, di = l, bi = 1}, {bi = 0, si = 1}). sI assigns arbitrary locations
variables O, D, e, assigns 0 variables B S. sG assigns 1 variables
S.
Passenger-origin passenger-destination variables static, i.e., affected
operator. Thus common pre-processes remove variables, using
statically prune set operators reachable. assume follows
removal taken place.
Every global dependency graph gDG Miconic-STRIPS passenger-served variable
si leaf variable x0 . leads non-leaf variables bi e, arcs e
variables bi si . Clearly, gDG acyclic. transitions e
invertible side effects. transition (0, 1) bi (is invertible since
departing different condition e but) irrelevant own-delete bi = 0
occur anywhere goal preconditions side effects thus irrelevant
side effect deletes. transition (1, 0) bi (is invertible but) irrelevant bi = 0
doesnt occur anywhere. transition (0, 1) leaf variable si self-irrelevant side
effect deletes bi = 1 occurs precondition transitions responsible
operator rop(0, 1) = depart(ld , i). Hence apply Theorem 4. delivers bound
costD (gDG) 1 = 1 + 1[si ] + (1 1)[costD (si ) maxPath(DT Gbi )] + (2 1)[(costD (si ) +
costD (bi )) diam(DT Ge )] = 3.
Definition 7. Simple-TSP domain set planning tasks = (V, O, sI , sG )
whose components defined follows. V = {p} V where: p position variable,
Dp = L L set representing possible locations; V , |V | = |L|,
set location-visited variables v, Dv = {1, 0}. contains single type
operators: move(l1, l2) = ({p = l1}, {p = l2, vl2 = 1}) l1 6= l2. sI assigns arbitrary
value p assigns 0 variables V . sG assigns 1 variables V .
Every global dependency graph gDG Simple-TSP location-visited variable vi
leaf variable x0 . leads single non-leaf variable p. Clearly, gDG acyclic.
Every transition (0, 1) vi considered, induced o0 = move(l1, li), replaceable side
effect deletes. operator = move(l1, x) replaced equivalent operator
move(li, x) unless x = li. latter case, o0 = excluded
definition replaceable side effect deletes. Every transition (l1, l2) p clearly invertible;
irrelevant side effect delete vl2 = 0; side effect vl2
non-leaf variable gDG. Hence apply Theorem 4. delivers bound
costD (gDG) 1 = 1 + 1[vi ] + (1 1)[costD (vi ) diam(DT Gp )] = 1.
consider extended version Movie domain, sense that, whereas
original domain version considers fixed range snacks (and thus state space
constant across domain instances), allow scale number different snacks.25
25. original domain version allows scale number operators adding snack.
operators identical, removed trivial pre-processes.

222

fiAnalyzing Search Topology Without Running Search

Definition 8. Movie domain set planning tasks = (V, O, sI , sG )
whose components defined follows. V = {c0, c2, re} H. Here, c0 counterat-zero variable, Dc0 = {1, 0}; c2 counter-at-two-hours variable,
Dc2 = {1, 0}; movie-rewound variable, Dre = {1, 0}; H have-snack
variables h Dh = {1, 0}. contains four types operators: rewindTwo, rewindOther, resetCounter, getSnack, rewindT wo = ({c2 = 1}, {re = 1}),
rewindOther = ({c2 = 0}, {re = 1, c0 = 0}), resetCounter = (, {c0 = 1}),
getSnack(i) = (, {hi = 1}). sI assigns arbitrary value variables. sG assigns
re, c0, H variables 1.
Note that, depending value static variable c2, operator set
different: sI (c2) = 1 rewindOther removed, sI (c2) = 0 rewindT wo
removed. refer former case (a) latter case (b).
Every global dependency graph gDG consists single (leaf) variable. transitions
h variable side effects thus irrelevant side effect deletes.
transition (0, 1) c0 side effects thus irrelevant side effect deletes.
transition (1, 0) c0 irrelevant. case (a), transition (0, 1) side
effects thus irrelevant side effect deletes apply Theorem 4. case (b),
transition (0, 1) side effect c0 = 0. Observe (1) fact
irrelevant; (2) ctx(0, 1) {c0 = 1}, := resetCounter satisfies
= preo (prevrop(0,1) eff rop(0,1) ) = {re = 1, c0 = 0}, {c0
= 1} = eff = {c0 = 1},
{c0 = 1} = eff {(y, d) | (y, d) , (y, d) sG rop(c,c0 )6=o0 preo0 } = {c0 = 1}.
Thus transition recoverable side effect deletes, apply Theorem 4.
case (a), gDGs bound costD (gDG) 1 applies. Obviously, costD (gDG) = 1
thus obtain correct bound 0. case (b), bound costD (gDG) applies,
costD (gDG) = 1 obtain correct bound 1.
Definition 9. Ferry domain set planning tasks = (V, O, sI , sG ) whose
components defined follows. V = C {f, e} where: C set car-location
variables c, Dc = L {f } L set representing possible locations; f
ferry-location variable Df = L; e ferry-empty variable De = {1, 0}.
contains three types operators: sail, board, debark, sail(l1, l2) =
({f = l1}, {f = l2}) l1 6= l2, board(l, c) = ({f = l, c = l, e = 1}, {c = f, e = 0}),
debark(l, c) = ({f = l, c = f }, {c = l, e = 1}). sI assigns 1 variable e, assigns
arbitrary value variable f , assigns arbitrary value f variables
C. sG assigns arbitrary value 6= f (some subset ) variables C f .
Let arbitrary reachable state 0 < h+ (s) < , let P + (s)
arbitrary optimal relaxed plan s. always apply Theorem 2. show this,
distinguish three cases: (a) s(e) = 1, o0 = board(l, c) first board operator P + (s),
set x0 = c; (b) s(e) = 0, o0 = debark(l, c) first debark operator P + (s),
set x0 = c; (c) P + (s) contains board debark operator set o0
first operator, sail(l1, l2), P + (s), x0 = f . Obviously, exactly one cases
hold s. Let oDG+ = (V, A) sub-graph SG including x0 variables/arcs
included per Definition 1. Let t0 transition taken o0 .
case (a), obviously reorder P + (s) either board(l, c) first operator
P + (s), predecessors sail operators. oDG+ either (1) includes new
223

fiHoffmann

(non-leaf) variables all, (2) includes f . f , clearly transitions
invertible side effects. transition t0 effect (c, f ) deleting (c, l)
clearly needed rest P + (s). side effect e = 0 deleting e = 1.
latter fact may needed board operators P + (s). However, necessarily
P + (s) contains operator form debark(l0 , c), applicable board(l, c)
sequence moves P + (s) must contain l l0 ; debark(l0 , c) recovers e = 1.
+
Thus oDG+ -relevant deletes t0 P>0
(s)-recoverable. case (b), similarly
+
reorder P (s) either (1) debark(l, c) first operator P + (s), (2)
predecessors sail operators. transition t0 effect (c, l) deleting (c, f )
clearly needed rest P + (s); side effect e = 1 deleting e = 0
clearly needed rest P + (s). Thus, again, oDG+ -relevant deletes
+
+
t0 P>0
(s)-recoverable (the recovering sub-sequence P>0
(s) empty
+
recovery required). case (c), finally, oDG contains f , t0 side effects,
delete (f, l1) needed anymore (in fact, case l2 must goal
f , P + (s) contains single operator o0 ). Hence, cases, apply
Theorem 2. costd (oDG+ ) = 1 cases (a1), (b1), (c) get bound 0.
costd (oDG+ ) = 1 + diam(DT Gf ) = 2 cases (a2) (b2) get bound 1.
Definition 10. Gripper domain set planning tasks = (V, O, sI , sG )
whose components defined follows. V = {ro, f1 , f2 } B. Here, ro robotlocation variable, Dro = {L, R}; f1 , f2 gripper-free variables, Df1 = Df2 =
{1, 0}; B ball-location variables, Db = {L, R, 1, 2}. contains three types
operators: move, pickup, drop, move(l1, l2) = ({ro = l1}, {ro = l2})
l1 6= l2, pickup(g, b, l) = ({ro = l, b = l, fg = 1}, {b = g, fg = 0}), drop(g, b, l) = ({ro =
l, b = g}, {b = l, fg = 1}). sI assigns L ro, assigns 1 f1 f2 , assigns L
variables B. sG assigns R variables B.
Let arbitrary reachable state 0 < h+ (s) < , let P + (s)
arbitrary optimal relaxed plan s. always apply Theorem 2. distinguish
two cases: (a) exists b B s(b) = g g {1, 2}, o0 = drop(g, b, R),
set x0 = b; (b) exists b B s(b) = g g {1, 2}, o0 = pickup(g, b, L)
b B P + (s), set x0 = b. Obviously, exactly one cases
hold s. Let oDG+ = (V, A) sub-graph SG including x0 variables/arcs
included per Definition 1. Let t0 transition taken o0 .
case (a), obviously reorder P + (s) either drop(g, b, R) first
operator P + (s), predecessor move(L, R). oDG+ either (1) includes
new (non-leaf) variables all, (2) includes ro. ro, clearly transitions
invertible side effects. transition t0 effect (b, R) deleting
(b, g) clearly needed rest P + (s); side effect fg = 1 deleting
fg = 0 clearly needed rest P + (s). Thus oDG+ -relevant deletes
+
t0 P>0
(s)-recoverable. case (b), similarly reorder P + (s) either (1)
pickup(g, b, L) first operator P + (s), (2) predecessor move(R, L).
transition t0 effect (b, g) deleting (b, L) clearly needed rest
P + (s). side effect fg = 0 deleting fg = 1; latter fact may needed
pickup operators P + (s). However, necessarily P + (s) contains operators move(L, R)
drop(g, b, R), applicable board(l, c); drop(g, b, R) recovers fg = 1. Thus,
224

fiAnalyzing Search Topology Without Running Search

+
again, oDG+ -relevant deletes t0 P>0
(s)-recoverable. Hence, cases,

+
apply Theorem 2. cost (oDG ) = 1 cases (a1) (b1), get bound 0.
costd (oDG+ ) = 1 + diam(ro) = 2 cases (a2) (b2) get bound 1.

Definition 11. Transport domain set planning tasks = (V, O, sI , sG )
whose components defined follows. V = P V E C where: P set packagelocation variables p, Dp = L V E L set representing possible
locations; V E set vehicle-location variables v, Dv = L; C set
vehicle-capacity variables cv , Dcv = {0, . . . , K} K maximum capacity.
contains three types operators: drive, pickup, drop, where: drive(v, l1, l2) =
({v = l1}, {v = l2}) (l1, l2) R GR = (L, R) undirected graph roads
L; pickup(v, l, p, c) = ({v = l, p = l, cv = c}, {p = v, cv = c 1}), drop(v, l, p, c) =
({v = l, p = v, cv = c}, {p = l, cv = c + 1}). sI assigns arbitrary value L
variables P V E, assigns K variables C. sG assigns arbitrary value
L subset variables P V E.
Note use numbers addition/subtraction. are, course, part
planning language consider here. However, easily encoded (on
finite set number {0, . . . , K}) via static predicates. pre-processing, effect
resulting task isomorphic one obtained simple arithmetic above,
thus choose reduce notational clutter.
Let arbitrary reachable state 0 < h+ (s) < . exists
optimal relaxed plan P + (s) apply Theorem 2. distinguish three
cases: (a) exists p P s(p) = v v V E, o0 = drop(v, l, p, c)
s(cv ) = c P + (s), set x0 = p; (b) exists p P s(p) = v
v V E, o0 = pickup(v, l, p, K) p P P + (s), set x0 = p; (c) P + (s)
contains drop pickup operator set o0 first operator, drive(v, l1, l2),
P + (s), x0 = v. Obviously, choose P + (s) exactly one cases
hold (the choice P + (s) arbitrary (b) (c), (a) may exist optimal
relaxed plans s(cv ) 6= c). Let oDG+ = (V, A) sub-graph SG including x0
variables/arcs included per Definition 1. Let t0 transition taken o0 .
case (a), obviously reorder P + (s) either o0 = drop(v, l, p, c) first
operator P + (s), predecessors drive operators. oDG+ either (1) includes
new (non-leaf) variables all, (2) includes v. v, clearly transitions
invertible side effects. transition t0 effect (p, v) deleting
(p, l) clearly needed rest P + (s). side effect cv = c+1 deleting
cv = c. latter fact may needed operators P + (s), either taking form
drop(v, l0 , p0 , c) form pickup(v, l0 , p0 , c). Clearly, P + (s) contains operators
replace drop(v, l0 , p0 , c + 1) pickup(v, l0 , p0 , c + 1) respectively
value (cv , c + 1) true point (relaxed) execution. Thus
choose P + (s) P + (s)-relevant deletes t0 P + (s)-recoverable V \ {x0 }.
case (b), similarly reorder P + (s) either (1) o0 = pickup(v, l, p, K)
first operator P + (s), (2) predecessors drive operators. transition t0
effect (p, v) deleting (p, l) clearly needed rest P + (s).
side effect cv = K 1 deleting cv = K. latter fact may needed
operators P + (s), taking form pickup(v, l0 , p0 , K). However, necessarily P + (s)
225

fiHoffmann

contains operator form drop(v, l0 , p, c0 ). c0 6= K 1 replace
operator drop(v, l0 , p, K 1) since, clearly, value (cv , K 1) true
point (relaxed) execution. Now, drop(v, l0 , p, K 1) applicable pickup(v, l, p, K)
sequence drive operators P + (s) must contain l l0 ; drop(v, l0 , p, K 1)
recovers cv = K. Thus, again, choose P + (s) P + (s)-relevant deletes
t0 P + (s)-recoverable V \ {x0 }. case (c), finally, oDG+ contains v, t0
side effects, delete (v, l1) needed anymore. Hence, cases,
apply Theorem 2. costd (oDG+ ) = 1 cases (a1), (b1), (c) get bound
0. costd (oDG+ ) = 1 + min(diam(oDT G+
v ), diam(DT Gv )) cases (a2) (b2)
bound diameter road map GR .
ignoring action costs, Elevators domain IPC 2008 essentially variant
Transport. variant general (a) vehicle (each elevator) may
maximal capacity, (b) vehicle reach subset locations, i.e.,
vehicle individual road map. hand, Elevators restricted
Transport (c) vehicle road map fully connected (every reachable floor
navigated directly every reachable floor), (d) goals exist
packages (passengers, is), vehicles. Even ignoring restrictions (c) (d),
trivial see arguments given Transport still hold true. Therefore,
whenever reachable state 0 < h+ (s) < , exists optimal relaxed plan
P + (s) apply Theorem 2. before, bound diameter
road map. Due (c), diameter 1.

References
Backstrom, C., & Klein, I. (1991). Planning polynomial time: SAS-PUBS class.
Computational Intelligence, 7 (4).
Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11 (4), 625655.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90 (1-2), 279298.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (1
2), 533.
Botea, A., Muller, M., & Schaeffer, J. (2004). Using component abstraction automatic
generation macro-actions. Koenig et al. (Koenig, Zilberstein, & Koehler, 2004),
pp. 181190.
Brafman, R., & Domshlak, C. (2003). Structure complexity planning unary
operators. Journal Artificial Intelligence Research, 18, 315349.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69 (12), 165204.
Cesta, A., & Borrajo, D. (Eds.), ECP01 (2001). Recent Advances AI Planning. 6th
European Conference Planning (ECP01), Lecture Notes Artificial Intelligence,
Toledo, Spain. Springer-Verlag.
226

fiAnalyzing Search Topology Without Running Search

Chen, H., & Gimenez, O. (2010). Causal graphs structurally restricted planning. Journal Computer System Sciences, 76 (7), 579592.
Domshlak, C., & Dinitz, Y. (2001). Multi-agent offline coordination: Structure complexity. Cesta & Borrajo (Cesta & Borrajo, 2001), pp. 3443.
Edelkamp, S., & Helmert, M. (1999). Exhibiting knowledge planning problems minimize state encoding length. Biundo, S., & Fox, M. (Eds.), Recent Advances AI
Planning. 5th European Conference Planning (ECP99), Lecture Notes Artificial
Intelligence, pp. 135147, Durham, UK. Springer-Verlag.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificial Intelligence Research, 9, 367421.
Fox, M., & Long, D. (1999). detection exploitation symmetry planning
problems. Pollack, M. (Ed.), Proceedings 16th International Joint Conference Artificial Intelligence (IJCAI99), pp. 956961, Stockholm, Sweden. Morgan
Kaufmann.
Garey, M. R., & Johnson, D. S. (1979). Computers IntractabilityA Guide
Theory NP-Completeness. Freeman, San Francisco, CA.
Gerevini, A., Howe, A., Cesta, A., & Refanidis, I. (Eds.), ICAPS09 (2009). Proceedings
19th International Conference Automated Planning Scheduling (ICAPS9),
Thessaloniki, Greece. AAAI.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs. Journal Artificial Intelligence Research, 20, 239290.
Gerevini, A., & Schubert, L. (1998). Inferring state-constraints domain independent
planning. Mostow, J., & Rich, C. (Eds.), Proceedings 15th National Conference American Association Artificial Intelligence (AAAI98), pp. 905912,
Madison, WI, USA. MIT Press.
Gimenez, O., & Jonsson, A. (2008). complexity planning problems simple
causal graphs. Journal Artificial Intelligence Research, 31, 319351.
Gimenez, O., & Jonsson, A. (2009a). influence k-dependence complexity
planning. Gerevini et al. (Gerevini, Howe, Cesta, & Refanidis, 2009), pp. 138145.
Gimenez, O., & Jonsson, A. (2009b). Planning chain causal graphs variables
domains size 5 NP-hard. Journal Artificial Intelligence Research, 34, 675706.
Haslum, P. (2007). Reducing accidental complexity planning problems. Veloso, M.
(Ed.), Proceedings 20th International Joint Conference Artificial Intelligence
(IJCAI07), pp. 18981903, Hyderabad, India. Morgan Kaufmann.
Helmert, M. (2003). Complexity results standard benchmark domains planning.
Artificial Intelligence, 143, 219262.
Helmert, M. (2004). planning heuristic based causal graph analysis.. Koenig et al.
(Koenig et al., 2004), pp. 161170.
Helmert, M. (2006). fast downward planning system. Journal Artificial Intelligence
Research, 26, 191246.
227

fiHoffmann

Helmert, M. (2009). Concise finite-domain representations PDDL planning tasks. Artificial Intelligence, 173 (5-6), 503535.
Helmert, M., & Domshlak, C. (2009). Landmarks, critical paths abstractions: Whats
difference anyway? Gerevini et al. (Gerevini et al., 2009), pp. 162169.
Hoffmann, J. (2003). Utilizing Problem Structure Planning: Local Search Approach,
Vol. 2854 Lecture Notes Artificial Intelligence. Springer-Verlag.
Hoffmann, J. (2005). ignoring delete lists works: Local search topology planning
benchmarks. Journal Artificial Intelligence Research, 24, 685758.
Hoffmann, J., & Nebel, B. (2001a). planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Hoffmann, J., & Nebel, B. (2001b). RIFO revisited: Detecting relaxed irrelevance. Cesta
& Borrajo (Cesta & Borrajo, 2001), pp. 325336.
Hoffmann, J., Porteous, J., & Sebastia, L. (2004). Ordered landmarks planning. Journal
Artificial Intelligence Research, 22, 215278.
Jonsson, A. (2009). role macros tractable planning. Journal Artificial Intelligence Research, 36, 471511.
Jonsson, P., & Backstrom, C. (1995). Incremental planning. European Workshop
Planning.
Jonsson, P., & Backstrom, C. (1998). State-variable planning structural restrictions:
Algorithms complexity. Artificial Intelligence, 100 (1-2), 125176.
Karpas, E., & Domshlak, C. (2009). Cost-optimal planning landmarks. Boutilier, C.
(Ed.), Proceedings 21st International Joint Conference Artificial Intelligence
(IJCAI09), pp. 17281733, Pasadena, CA, USA. Morgan Kaufmann.
Katz, M., & Domshlak, C. (2008a). New islands tractability cost-optimal planning.
Journal Artificial Intelligence Research, 32, 203288.
Katz, M., & Domshlak, C. (2008b). Structural patterns heuristics via fork decomposition.
Rintanen, J., Nebel, B., Beck, J. C., & Hansen, E. A. (Eds.), Proceedings
18th International Conference Automated Planning Scheduling (ICAPS08),
pp. 182189, Sydney, Australia. AAAI.
Knoblock, C. (1994). Automatically generating abstractions planning. Artificial Intelligence, 68 (2), 243302.
Koenig, S., Zilberstein, S., & Koehler, J. (Eds.), ICAPS04 (2004). Proceedings
14th International Conference Automated Planning Scheduling (ICAPS04),
Whistler, Canada. AAAI.
Long, D., & Fox, M. (2000). Automatic synthesis use generic types planning.
Chien, S., Kambhampati, R., & Knoblock, C. (Eds.), Proceedings 5th International Conference Artificial Intelligence Planning Systems (AIPS00), pp. 196205,
Breckenridge, CO. AAAI Press, Menlo Park.
McDermott, D. V. (1999). Using regression-match graphs control search planning.
Artificial Intelligence, 109 (1-2), 111159.
228

fiAnalyzing Search Topology Without Running Search

Nebel, B., Dimopoulos, Y., & Koehler, J. (1997). Ignoring irrelevant facts operators
plan generation. Steel, S., & Alami, R. (Eds.), Recent Advances AI Planning. 4th
European Conference Planning (ECP97), Vol. 1348 Lecture Notes Artificial
Intelligence, pp. 338350, Toulouse, France. Springer-Verlag.
Richter, S., Helmert, M., & Westphal, M. (2008). Landmarks revisited. Fox, D., & Gomes,
C. (Eds.), Proceedings 23rd National Conference American Association
Artificial Intelligence (AAAI08), pp. 975982, Chicago, Illinois, USA. MIT Press.
Richter, S., & Westphal, M. (2010). LAMA planner: Guiding cost-based anytime
planning landmarks. Journal Artificial Intelligence Research, 39, 127177.
Rintanen, J. (2000). iterative algorithm synthesizing invariants. Kautz, H. A.,
& Porter, B. (Eds.), Proceedings 17th National Conference American
Association Artificial Intelligence (AAAI00), pp. 806811, Austin, TX, USA.
MIT Press.
Roberts, M., & Howe, A. (2009). Learning planner performance. Artificial Intelligence,
173, 636561.
Vidal, V. (2004). lookahead strategy heuristic search planning. Koenig et al.
(Koenig et al., 2004), pp. 150160.
Williams, B. C., & Nayak, P. P. (1997). reactive planner model-based executive.
Pollack, M. (Ed.), Proceedings 15th International Joint Conference Artificial
Intelligence (IJCAI97), pp. 11781185, Nagoya, Japan. Morgan Kaufmann.

229


