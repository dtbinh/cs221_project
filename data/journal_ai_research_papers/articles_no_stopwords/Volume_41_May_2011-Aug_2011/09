journal artificial intelligence

submitted published

sequential diagnosis abstraction
sajjad siddiqi
national university sciences technology
nust islamabad pakistan

sajjad ahmed seecs edu pk

jinbo huang
nicta australian national university
canberra australia

jinbo huang nicta com au

abstract
system behaves abnormally sequential diagnosis takes sequence measurements system faults causing abnormality identified goal
reduce diagnostic cost defined number measurements propose
measurement points previous work employs heuristic reducing entropy
computed set diagnoses generally good performance terms
diagnostic cost fail diagnose large systems set diagnoses
large focusing smaller set probable diagnoses scales generally
leads increased average diagnostic costs propose diagnostic
framework employing four techniques scales much larger systems good
performance terms diagnostic cost first propose heuristic measurement
point selection computed efficiently without requiring set diagnoses
system modeled bayesian network compiled logical form known
dnnf second extend hierarchical diagnosis technique system abstraction previous work handle probabilities applied sequential
diagnosis allow larger systems diagnosed third largest systems
even hierarchical diagnosis fails propose novel method converts system
one smaller abstraction whose diagnoses form superset
original system system diagnosed mapped back
original system finally propose novel cost estimation function
used choose abstraction system likely provide optimal average
cost experiments iscas benchmark circuits indicate scales
circuits suite except one flat structure susceptible useful
abstraction

introduction
system behaves abnormally task diagnosis identify reasons
abnormality example combinational circuit figure given inputs
p q r output v actually due faults gates j
b given system comprising set components knowledge base modeling
behavior system along abnormal observed values system variables
consistency diagnosis set components whose failure assuming
components healthy together observation logically consistent
system model example v k j b diagnoses given
c

ai access foundation rights reserved

fisiddiqi huang



buffer


p


q








j


b








v


k


r

figure faulty circuit

observation general number diagnoses exponential number
system components one correspond set actual faults
therefore consider sequential diagnosis de kleer
williams sequence measurements system variables taken
actual faults identified goal reduce diagnostic cost defined
number measurements propose measurement points state art gde general
diagnosis engine framework de kleer williams de kleer raiman shirley
de kleer considers heuristic reducing entropy set computed
diagnoses generally good performance terms diagnostic cost
fail diagnose large systems set diagnoses large de kleer williams
de kleer et al de kleer focusing smaller set probable diagnoses
scales generally leads increased average diagnostic costs de kleer

propose diagnostic framework employing four techniques scales
much larger systems good performance terms diagnostic cost first propose
heuristic require computing entropy diagnoses instead consider
entropies system variables measured well posterior probabilities
component failures idea select component highest posterior
probability failure heckerman breese rommelse variables
component measure one highest entropy compute probabilities
exploit system structure joint probability distribution faults
system variables represented compactly bayesian network pearl
compiled deterministic decomposable negation normal form dnnf darwiche
darwiche marquis dnnf logical form exploit structure present
many systems achieve compactness used compute probabilistic queries
efficiently specifically required posterior probabilities exactly computed
evaluating differentiating dnnf time linear dnnf size darwiche



fisequential diagnosis abstraction

second extend hierarchical diagnosis technique previous work siddiqi
huang handle probabilities applied sequential diagnosis
allow larger systems diagnosed specifically self contained subsystems called cones
treated single components diagnosed found faulty
top level diagnosis significantly reduces number system components allowing
larger systems compiled diagnosed example subcircuit dotted box
figure cone output p inputs contains fault first
cone whole determined faulty compiled separately
diagnosed previous work siddiqi huang dealt task
computing diagnoses involve measurements probabilities present
present several extensions allow technique carry sequential
diagnosis
third abstraction system still large compiled diagnosed
use novel structure technique called cloning systematically modifies
structure given system c obtain system c smaller abstraction
whose diagnoses form super set original system system
diagnosed mapped back original system idea select
system component g part cone hence cannot abstracted away
hierarchical diagnosis create one clones g distribute gs parents
graph point view among clones way g clones become parts
cones disappear abstraction repeated applications operation
allow otherwise unmanageable system small enough abstraction diagnosis
succeed
finally propose novel cost estimation function predict expected
diagnostic cost given abstraction system used diagnosis aim
abstraction system likely give optimal average cost
purpose use function abstractions system different
abstractions obtained destroying different cones system destroying
cone mean overlook fact cone include components
abstraction abstraction lowest predicted cost used actual
diagnosis
experiments iscas benchmark circuits brglez fujiwara indicate
solve first time nontrivial multiple fault diagnostic cases benchmarks good diagnostic costs except one circuit flat structure susceptible
useful abstraction cost estimation function often accurately predict
abstraction likely give optimal average cost

background previous work
suppose system diagnosed formally modeled joint probability distribution p r x h set variables partitioned x h variables x
whose values observed measured variables h health variables one component describing health mode joint probability distribution
p r x h defines set system states


fisiddiqi huang

diagnosis starts initial belief state
p r x h xo xo



values xo variables xo x boldface uppercase letters mean
sets vectors given observation wish reach goal state
p r x h xo xo xm xm



measuring values xm variables xm x xo xm n one time
boldface denote vectors
hf h p r hf xo xo xm xm
p r hf h hf xo xo xm xm
goal state set components hf known faulty certainty
logical inconsistency arises components assumed healthy
types goal conditions possible example health states components
determined certainty condition p r h xo xo xm xm
h h goals possible reach strong fault given
strong fault explicit descriptions abnormal behavior opposed
weak fault normal behavior known
two special cases worth mentioning initial state satisfies goal
condition hf observation normal diagnosis required
initial state satisfies goal condition hf observation
abnormal diagnosis already completed assuming able check
probabilities necessary words sequence length solves
following de kleer williams assume measurements unit
cost hence objective reach goal state fewest measurements possible
classical gde framework receiving abnormal observation xo xo considers
shannons entropy probability distribution set computed diagnoses
set minimum cardinality diagnoses set probable leading diagnoses proposes measure variable x whose value reduce entropy
average idea probability distribution diagnoses reflects
uncertainty actual faults entropy captures amount uncertainty
measurement taken entropy updated updating posterior probabilities
diagnoses potentially reducing
reported de kleer et al involving single fault cases iscas
circuits indicate method leads measurement costs close optimal
policies however major drawback impractical number
diagnoses large e g set minimum cardinality diagnoses exponentially
large focusing smaller set probable diagnoses scales increase
likelihood irrelevant measurements generally leads increased average diagnostic
costs de kleer
shall use combinational circuits example type systems
wish diagnose however applies well types systems


fisequential diagnosis abstraction

p



p



p









okj









okj


j









okj



j p okj









figure bayesian network circuit figure left cpts nodes p j
okj right

long probabilistic model given defines behavior system sections
present techniques introduced significantly enhance
scalability sequential diagnosis start however presenting following section
system modeling compilation method underlies diagnostic system

system modeling compilation
order define joint probability distribution p r x h system behavior
first assume prior probability failure p r h given component
h h part input diagnosis task de kleer williams example
small table two entries top right figure gives prior probability
failure gate j
conditional probability tables
prior fault probabilities alone define joint probability distribution p r x h
addition need specify component output related inputs
health mode conditional probability table cpt component job
cpt shown bottom right figure example defines behavior
gate j entry gives probability output j particular value given
value input p value health variable okj case okj
probabilities behavior healthy gate deterministic
case okj defines fault model gate part input
diagnosis task example assume output values probability
gate broken simplicity assume gates two health modes


fisiddiqi huang

e health variable binary encoding compilation described later
however allows arbitrary number health modes
given tables joint probability distribution circuit behavior
obtained realizing gates circuit satisfy independence property known
markov property given inputs health mode output gate independent
wire descendant gate wire x descendant gate x
reached following path output circuit direction towards
circuit outputs means circuit effectively treated bayesian
network straightforward way node wire health variable
edge going input gate output health
variable gate output figure shows translation circuit
figure
joint probability distribution encoded bayesian network provides basis
computing posterior probabilities may need proposing measurement
points chain rule however provide efficient way
specifically computing posterior p r x x given values variables
known values involves summing variables x
complexity exponential number variables done naively
propositional modeling
known bayesian network encoded logical formula compiled
dnnf successful allows posterior probabilities variables computed efficiently darwiche purposes sequential diagnosis encode
bayesian network follows
consider subcircuit dotted box figure example
modeled following formula
okj j p oka j
specifically signal circuit translates propositional variable
p j gate extra variable introduced model health oka okj
formula health variables true remaining variables
constrained model functionality gates general component x
okx normalbehavior x
note formula fails encode half cpt entries okj
order complete encoding cpt node j introduce extra boolean variable
j write okj j j finally health variables oka okj associated
probabilities respective gates healthy experiments
variable j associated probability corresponding gate giving
output broken experiments thus assuming output faulty
gate probabilistically independent inputs
encoding circuit similar encoding bayesian networks described darwiche following way according encoding darwiche
every node bayesian network every value indicator variable
similarly every conditional probability network parameter variable


fisequential diagnosis abstraction

encoding variables wires analogous network indicators
encoding optimized single indicator values wire
encoding exploits logical constraints generate network parameters
zeros ones cpt finally encoding node represents health variable optimized need single ok variable serves
indicator network parameter
components encoded described union conjunction
formulas compiled dnnf required probabilities exactly computed
evaluating differentiating dnnf time linear size darwiche
details compilation process discussed darwiche computation
probabilities described appendix
present hierarchical diagnosis propose measurement
selection heuristic

hierarchical sequential diagnosis
optimal solution sequential diagnosis would policy plan measurements conditioned previous measurement outcomes path plan leads
diagnosis system heckerman et al computing optimal policies
intractable general follow heuristic measurement point selection
previous work
start definition shannons entropy defined respect
probability distribution discrete random variable x ranging values x x xk
formally
k
x
x
p r x xi log p r x xi



entropy measures amount uncertainty value random variable
maximal probabilities p r x xi equal minimal one
probabilities corresponding nicely intuitive notion degree uncertainty
gde entropy computed probability distribution set computed
diagnoses e value random variable x ranges set diagnoses
mentioned earlier entropy difficult compute number diagnoses
large de kleer williams de kleer
baseline
able compute probabilities efficiently exactly following successful dnnf compilation propose two part heuristic circumvents limitation scalability
first consider entropy candidate variable measured
heuristic entropy variable
since wire x two values entropy written
x px log px px log px




fisiddiqi huang

px p r x px p r x posterior probabilities
x values respectively given values wires whose values
known
x captures uncertainty value variable interpret
expected amount information gain provided measuring variable hence
first idea consider selecting variable maximal entropy measurement
step
improving heuristic accuracy
idea alone however work well initial experiments would
confirmed subsequent experiments largely due fact implicit space
diagnoses generally large include large number unlikely diagnoses
tends compromise accuracy information gain provided entropy
experiments confirm explanation follows
dnnf compilation produced used compute probabilities prune dnnf graph satisfying variable assignments
corresponding diagnoses k broken components removed set
initial k number actual faults experiments observed significant
reduction diagnostic cost resulted almost cases improved performance apparently due fact pruning updates posterior probabilities variables
making accurate since many unlikely diagnoses eliminated
practice however number faults known beforehand choosing
appropriate k pruning nontrivial note k need exactly
number actual faults pruning help interestingly following heuristic
one actually use appears achieve similar performance gain
automatic way select component highest posterior probability failure
idea heckerman et al see section variables
component measure one highest entropy heuristic require
pruning dnnf appears improve diagnostic cost similar
extent focusing measurement selection component likely broken
empirical effect given discussed section

start encoding system logical formula discussed section
subset variables associated numbers representing prior fault probabilities
probabilities involved fault components compiled
dnnf
overall sequential diagnosis process propose summarized
inputs system c dnnf compilation set faults empty
used hierarchical set known values variables
integer k specifying fault cardinality bound running model pruning
experiments described section required diagnosis final
complete pruning easy however approximation achieved time linear dnnf
size variant minimization procedure described darwiche see appendix b



fisequential diagnosis abstraction

probabilistic sequential diagnosis
function psd c k
inputs c system dnnf measurements k fault cardinality ordered set
known faults
output pair
reduce k changed
given variables evaluate obtain p r
differentiate obtain p r x variables x
deduce fault x p r okx
changed meetscriteria

return
measure variable x best given heuristic
add measured value x x go back line

heuristic reduce pruning line fault cardinality bound
k given function reduce k reduce accepts arguments
current dnnf set known faults upper bound given k
cardinality remaining faults whereas returns pruned dnnf reduce excludes
known faults computing minimum cardinality uses k
bound remaining faults explained appendix b reduced first
time psd called later time changed e component found
faulty evaluate line differentiate line see appendix select
measurement point take measurement line repeat process line
stopping criteria met line
stopping criteria line given earlier section goal condition e
stop abnormal observation explained faulty components already
identified assuming components healthy faulty component x identified
p r okx values variables already known
mentioned earlier probabilities obtained variables simultaneously
dnnf differentiation process finally condition current set faulty
components health modes hf explains observation satisfied p r hf
h hf checked single evaluation original dnnf
returns actual faults together set known values variables
line
hierarchical
scale handle larger systems idea abstraction
hierarchical diagnosis siddiqi huang basic idea compilation
system model dnnf efficient scalable number
system components reduced achieved abstraction subsystems
known cones treated single components example cone depicted
figure objective use single health variable failure probability
entire cone hence significantly reducing size encoding difficulty
compilation cone identified faulty top level diagnosis
compiled diagnosed recursive fashion


fisiddiqi huang

give formal definition abstraction previous work
abstraction system
abstraction upon structural dominators kirkland mercer system
component x dominates component x called dominator path
output system contains x cone corresponds precisely set
components dominated component cone may contain cones leading
hierarchy cones
system abstracted treating maximal cones black boxes maximal
cone one contained cone contained exactly one cone
whole system example cone treated virtual gate
two inputs p output abstraction system formally defined

definition abstraction system given system c let c c c single
output otherwise let c c augmented dummy component collecting outputs
c let output c abstraction ac system c set
components x c x dominated c component x

example ac b k v j ac j cannot reach output without
passing dominator j
previous work siddiqi huang dealt task computing minimum cardinality diagnoses involve probabilities measurement
selection context sequential diagnosis several additional techniques
introduced particularly computation prior failure probabilities cones
way measurement points selected outlined
propositional encoding
start discussion hierarchical encoding probabilistic reasoning
similar hierarchical encoding presented previous work siddiqi huang
specifically diagnosis abstraction ac given system c health variables
associated components ac ic gates b k v
example ic stands set inputs system c thus gate j figure
associated health variable j wire internal cone rooted
consequently nodes representing components ac ic health
nodes associated corresponding bayesian network hence node okj
removed bayesian network figure
addition define failure cone outputs wrong value
introduce extra clauses model abnormal behavior cone example
encoding given section cone figure dotted box follows
j p oka j oka j
first part formula encodes normal behavior gate j without health
variable next encodes normal behavior cone last encodes


fisequential diagnosis abstraction

cone outputs wrong value fails gates roots cones
abstraction ac encoded normally described section
note formulas components cone together encode single cpt
whole cone provides conditional probability cones output given
health inputs cone instead health inputs component
root cone example encoding meant provide conditional
probability given p oka instead j oka oka represents
health mode whole cone associated prior failure probability
initially unknown us computed cones explained
encoding whole system provides joint probability distribution variables
ac ic h h okx x ac ic
prior failure probabilities cones
cone treated single component prior probability failure whole
computed given prior probabilities components cones inside
creating two copies h f cone h healthy behavior
cone without health variables f includes faulty behavior well e
full encoding described section outputs h f collected
xor gate x output xor gate x equals inputs forced
different value compute probability p r x giving probability
outputs h f different probability computed compiling
encoding dnnf evaluating x
note procedure abstraction hierarchical performed
bottom probabilities inner cones computed outer
ones note performed per system pre processing step
measurement point selection stopping criteria
principle heuristic select variables measurement stopping criteria
baseline however couple details worth mentioning
first diagnosing abstraction given system cone c measurement
candidates restricted variables ac ic ignoring internal variables maximal
conesthose measured cone whole found faulty
second generally important full knowledge values cones inputs
final diagnosis cone concluded diagnosis cone concluded
partial knowledge inputs may include faults vital validity
global diagnosis reason diagnosis cone assumes unknown
inputs take value reality values may become fixed variables
parts system measured causing diagnosis certain cones become
invalid possibly requiring affected cones diagnosed meet
global stopping criteria see line
avoid situation retaining effectiveness heuristic modify
measurement point selection follows diagnosing cone selecting component
highest probability failure consider variables component plus
inputs cone measure one highest entropy conclude


fisiddiqi huang

hierarchical probabilistic sequential diagnosis
function hpsd c uc k
inputs c system uc obs across system k fault cardinality
local variables b set components z ug set measurements k integer
output pair uc
compile ddnnf ac uc
uc
b psd c b k
b

g element b

g cone

z implications

ug x x z x ig og

k k b

ug hpsd dg ig ug k

ug

evaluate differentiate

else

g
z implications
uc uc x x z x ic oc
meetscriteria c

return uc
else

goto line

diagnosis cone values inputs become known measurement
deduction except health components cone determined
without knowing inputs cone possible identify faulty component
strong fault healthy component without knowing inputs
note restriction measure inputs cone lead significant
increase cost compared cost baseline especially number
inputs cone large discussed detail section

pseudocode hierarchical given recursive function
inputs system c set known values uc variables inputs ic
outputs oc system optional integer k specifying fault cardinality
bound purpose experimenting effect model pruning start
dnnf compilation abstraction given system line use
function psd get diagnosis b abstraction line assuming
measurement point selection stopping criteria modified
according described section abstract diagnosis b used
get concrete diagnosis loop lines specifically component g b
root cone added line otherwise cone g recursively
diagnosed line added line recursively diagnosing


fisequential diagnosis abstraction

cone g subsystem contained g represented dg ig dg set
components dominated g ig set inputs cone g
recursively diagnosing cone g compute abnormal observation ug
inputs output ig g cone g values gs inputs output
measured deduced current set measurements value
variable x implied x measurements p r x x
easy check differentiated function implications
lines implements operation used compute partial abnormal
observation ug line fault cardinality bound k cone g inferred line
called recursively diagnose g given ug k
recursive call returns faults inside cone g together updated
observation ug observation ug may contain measurement regarding
variables ig g added set measurements abstraction
line measurement obtained inside cone ignored due reasons
explained section concrete diagnosis augmented faults found
inside cone line evaluated differentiated light
measurements line
loop ends variable uc updated known values inputs
ic outputs oc system c line stopping criteria checked
diagnosis line met function returns pair uc line otherwise
measurements taken stopping criteria line met
since contain faults inside cones compilation cannot used
check stopping criteria note change parameters function
meetscriteria line probabilistic information regarding variables inside cones
available criteria checked follows instead maintain depth
level every component system outputs system depth level
rest components assigned depth levels upon length shortest
route output system example figure gates b j depth
level depth level hence b j deeper first propagate
values inputs system propagate fault effects components
one one flipping values abnormal ones propagating towards
system outputs way deeper faults propagated first siddiqi huang
check values system outputs obtained equality
observation
example
suppose diagnose abstraction circuit figure observation
uc p q r v take sequence measurements
k concluded abstract system model given values
p value abnormal concludes fault note
q suggests presence another fault besides triggering
measurement gate b found faulty abstract diagnosis b meets
stopping criteria respect abstract circuit


fisiddiqi huang


p


q




e

j


b









v


k


r

figure faulty circuit faults b j

p


j


e





b

q


b






v


k


r

figure creating clone b b according
enter diagnosis cone recursive call observation ua p
b diagnosis cone immediately reveals cone e
faulty hence make recursive call order diagnose e observation
ue p b e unknown wire j measured gate j found
faulty explains observation outputs cones e well given
inputs p b recursion terminates abstract diagnosis b b generates
concrete diagnosis j b meets stopping criteria
terminates

component cloning
preceding section proposed abstraction sequential diagnosis reduces complexity compilation diagnosis reducing number
system components diagnosed take one step aiming handle
systems large remain intractable even abstraction case
largest circuits iscas benchmark suite
solution novel method systematically modifies structure system
reduce size abstraction specifically select component g parents p
component x parent component child x output
input x part cone hence cannot abstracted away hierarchical


fisequential diagnosis abstraction

diagnosis create clone g according parents p p sense
g inherits children g feeds p g longer feeds p see
figures example idea create sufficient number clones g
g clones become part cones hence abstracted away
repeated applications operation allow otherwise unmanageable system
small enough abstraction compilation diagnosis succeed hierarchical
extended diagnose system mapped
original system solve almost benchmark circuits

go details method differentiate technique
known node splitting choi chavira darwiche used solve mpe
queries bayesian network node splitting breaks enough number edges
nodes network mpe query resulting network becomes easy
solve broken edge replaced root variable uniform prior resulting
network relaxation approximation original mpe solution
may computed compilation gives upper bound mpe solution
original network depth first branch bound search searches
optimal solution bounds prune search space similar
used solve weighted max sat pipatsrisawat darwiche
version node splitting directly applicable present setting
following reasons edges system broken redirected root variables
primary inputs resulting system represents different input output function
original system abnormal observation original system may hence
become normal one system edges fault propagates
broken eliminating basis diagnosis technique component cloning
viewed version node splitting introduces clones component instead
primary inputs preserves input output function system
system relaxation original diagnoses superset
original
formally define component cloning
definition component cloning let g component system c parents
p say g cloned according parents p p system c
system c follows
edges going g parents p removed
component g functionally equivalent g added system
g shares inputs g feeds p
figures example creating clone b b according
circuit whose abstraction contains gates k v whereas
abstraction original circuit contains gate b
choices component cloning
two choices made component cloning components clone
many clones create split parents


fisiddiqi huang

since goal cloning reduce abstraction size clear wish
clone components lie abstraction e within cones among
cloning root cone cannot reduce abstraction size destroy existing
cone reintroducing components inside cone abstraction
example cloning according k figure produce circuit clone
abstracted away b longer dominated hence reintroduced
abstraction therefore final candidates cloning precisely components
abstract system roots cones note order
candidates processed unimportant cloned produce equal
reduction namely reduction precisely abstraction size
remains determine candidate many clones create
connect parents understand final method helps consider
naive method simply creates p clones p set parents
clone well original feed exactly one parent way every parent
component becomes root cone component clones
abstracted away figure example b three parents e naive
method would create two clones b total three instances gate split
three parents would abstraction figure
trick number clones reduced knowing parents
component may lie cone single clone component according
parents sufficient clone abstracted away example
figure parents e b lie cone would suffice create
single clone b according e resulting efficient cloning
figure
formally partition parents component g subsets p p pq
parents g lie cone placed subset
rest separate ones create q clones g according q
subsets resulting g clones abstracted away process repeated
candidate component abstraction size small enough reduction
possible
diagnosis component cloning
system functionally equivalent original smaller abstraction
equivalent original diagnostic purposes model allows
component clones fail independently relaxation
original model diagnoses system form superset
original specifically diagnosis system assigns health state
component clones components corresponds diagnosis original
system diagnoses spurious ignored
core diagnosis process given continues applicable
system two minor modifications necessary first spurious diagnoses
implicitly filtered assuming health state clones including
original component soon health state one known second
whenever measurement clone component proposed actual measurement


fisequential diagnosis abstraction

c
number cone inputs




















cones

figure cones iscas circuits

taken original component original system obvious reasons words
system used reasoning original measurements
principle presence spurious diagnoses model potentially skew
measurement point selection heuristic least early stages diagnosis
spurious diagnoses gradually filtered however smaller benchmarks
could diagnosed without cloning conducted empirical analysis
indicates interestingly overall diagnostic cost slightly affected
discuss detail section

diagnostic cost estimation
address interesting issue stemming observation made conducting experiments detailed next section system abstraction beneficial
compilation diagnostic cost improve associated hierarchical
diagnosis one hand hierarchical diagnosis help cases
otherwise high costs baseline quickly finding faulty portions
system represented set faulty cones directing sequential diagnosis
take measurements inside cones resulting useful measurements
hand introduce overhead cases needlessly go hier

fisiddiqi huang

archies locate actual faults measure inputs cones involved baseline
version directly efficiently
overhead hierarchical quite high faults lie cones
large number inputs example graphs figure number inputs
represented dots cones iscas circuits note cones
small number inputs however cones inputs especially
c circuits beyond c contribute increased diagnostic cost
several cases increase cost due cones confirmed separate set
experiments large set systematically generated combinational circuits detailed
appendix c avoid potential high cost diagnosis faults lie cone
large number inputs tempting destroy cone compilation
fault directly found however due associated increase
abstraction size destroying cones may cause increased costs cases could
previously solved efficiently thus may negative impact overall
calls automatic mechanism predict effect destroying certain cones
overall diagnostic cost subject section
propose novel cost estimation function predict average diagnostic cost
given abstraction system considered diagnosis different abstractions
obtained destroying different cones system since cones destroyed
automatically function used automatically propose abstraction system used diagnosis likely give optimal average cost function
uses hierarchical structure given abstraction predict cost
take account parameters may contribute cost probabilities addition function limited single fault cases therefore expected
cost computed function indicative cannot correct however
experiments function often quite useful proposing abstraction
system likely give optimal cost discussed next section
estimate expected diagnostic cost assume composed two quantities
namely isolation cost abstraction cost inversely proportional
isolation cost captures well given system abstraction isolate
faulty portions system therefore isolation cost minimum complete
abstraction system used e cones considered generally increases
cones destroyed abstraction cost captures overhead cost due introduction
cones hence abstraction cost minimum zero abstraction considered
generally increases cones introduced
define isolation cost diagnosis considering abstraction system
average cost required isolate single fault system abstraction
similarly define abstraction cost diagnosis average overhead cost required
diagnose single fault system abstraction expected average
cost diagnosis abstraction system considered diagnosis sum
isolation abstraction costs abstraction different cones destroyed
given abstraction system expect changes values abstraction
isolation costs determine whether overall cost go changes
uneven stay constant changes even idea obtain abstraction


fisequential diagnosis abstraction

system strike balance two quantities get overall optimal cost
discuss isolation abstraction costs estimated
noted experiments baseline heuristic
isolate single fault system cost average comparable log
number measurement points system provided us basis
computing isolation cost hierarchical fault lies inside cone
one first estimate isolation cost diagnosing cone separately add
isolation cost diagnosing abstract system get average isolation cost
single faults lie cone example cones considered
cost isolating fault circuit figure log values p q r
v already known however cones considered cost isolating fault
lies inside cone sum isolation cost abstract circuit
isolation cost subcircuit inside cone log log similarly
get average isolation cost single faults system hierarchical
one add isolation cost diagnosing abstract system average
isolation costs diagnosing abstract components isolation cost
abstract component cone zero note isolation cost
diagnosing cone computed taking abstraction cone
estimate abstraction cost diagnosis given abstraction first need
estimate overhead cost involved individual component system
abstraction estimate overhead cost possibly faulty component one
take union inputs outputs cones component lies
number measurement points approximately constitutes required overhead
cost component component lie cone overhead cost
component zero example circuit figure diagnosed
hierarchical gate j faulty one must first cone
faulty cone e faulty gate j faulty overhead
cost gate j case e measure wires b e
j assuming q known abstraction cost diagnosis given abstraction
system average overhead costs system components
abstraction
give formal definitions related cost estimation function let pu c
set measurement points system c whose values unknown
pu g set inputs output abstract concrete component g whose
values unknown let p number abstract components abstraction ac
system c let gi ac abstract component concrete component cone
abstraction concrete component abstraction regarded trivial
cone containing component let dgi subsystem dominated gi
agi abstraction subsystem
isolation cost ic c ac abstraction ac system c considered
diagnosis sum log pu ac average isolation costs computed
similar manner subsystems contained abstract components ac


fisiddiqi huang


pp
log pu ac p
ic dgi agi pu ac
ic c ac pp
otherwise
ic dgi agi
p



ic dgi agi recursively computes isolation cost subsystem contained
abstract component gi equation taking abstraction agi note
computing ic dgi agi assume inputs output gi already
measured thus pu dgi excludes inputs output cone gi gi
concrete
component ic dgi agi cones considered ac c
pp
ic
gi agi isolation cost simply equal log pu c

compute abstraction cost diagnosing system given abstraction
first compute overhead costs diagnosing individual cones abstraction
multiply abstraction cost cone number components contained
cone get total overhead cost components cone adding
overhead costs computed way cones abstraction dividing
number total number concrete components whole system gives us
average overhead cost per component call abstraction cost formally let
q cones ac abstraction cost ac c ac abstraction ac
system c considered diagnosis given

ac c ac

q
x
dgi pu gi ac dgi agi gi ac cone
n





dgi number concrete components contained cone gi pu gi
ac dgi agi recursively computes abstraction cost diagnosing cone gi
equation taking abstraction agi abstraction cost gi multiplied
dgi effectively add cost measuring cone inputs output overhead cost
every component inside cone note computing ac dgi agi
assume variables pu gi already measured thus pu dgi
excludes inputs output cone gi
finally total expected cost edc c ac diagnosing system c abstraction ac system considered diagnosis given
edc c ac ic c ac ac c ac



experimental
section provides empirical evaluation diagnostic system referred
sda sequential diagnosis abstraction implements baseline hierarchical
cloning approaches described sections cost estimation function
described section experiments conducted cluster computers consisting two types comparable cpus intel core duo ghz amd athlon
x dual core processor gb ram running linux time limit


fisequential diagnosis abstraction

hours memory limit gb imposed test case dnnf compilation done publicly available dnnf compiler c darwiche
cnf simplified compilation given observation allowed us
compile circuits expense requiring fresh compilation per observation
see line
generated single multiple fault scenarios iscas benchmark circuits
scenario set gates assumed faulty single fault cases circuits
c simulated equal prior probability faults generating n fault scenarios
circuit n equals number gates circuit scenario contains
different faulty gate randomly generated test cases abnormal observations
n scenarios multiple fault scenarios would practical
due large number combinations circuit c respectively larger
c simply generated respectively random scenarios given
fault cardinality random test case scenario
thus test case faulty circuit gate gates give incorrect
outputs inputs outputs circuit observed values internal wires
computed propagating inputs normal circuit towards outputs followed
propagating outputs assumed faulty gates one one deeper faults
propagated first obtained values internal wires used simulate
taking measurements use p r okx gates x circuit
note cases gates fail equal probability conceivably harder
solve diagnoses tend less differentiable gate two output
values given equal probability gate faulty tend make
cases harder solve due high degree uncertainty circuit fault
cardinality report cost number measurements taken time including
compilation time cpu seconds locate faults averaged test cases solved
present experiments four subsections demonstrating effectiveness
four techniques proposed namely heuristic hierarchical sequential
diagnosis component cloning cost estimation function
effectiveness heuristic
start comparison baseline sda gde sda
achieves similar diagnostic costs scales much larger circuits hence illustrating
effectiveness heuristic along way compute probabilities
comparison gde
could obtain tutorial version gde forbus de kleer comparison downloadable http www qrg northwestern edu bps readme html gde uses
atcon constraint language developed lisp programming language represent diagnostic cases detailed account language given forbus
de kleer employs interactive user interface proposes measurement points respective costs lets user enter outcomes measurements
purpose comparison translated descriptions language accepted gde modified gde automatically read measurement outcomes


fisiddiqi huang

size system






gde
sda
gde
sda
gde
sda
gde
sda
gde
sda

single fault
cost time














double fault
cost time





















triple fault
cost time















table comparison gde
input description compiled lisp code machine dependent
binary code native c compiler improve run time performance
version gde developed tutorial purposes computes set minimal diagnoses instead probable diagnoses makes comparison less informative nevertheless able make reasonable comparison terms diagnostic cost set
minimal diagnoses serve large set probable diagnoses components
equal prior probabilities according de kleer availability diagnoses
aids heuristic accuracy whereas focusing smaller set probable diagnoses
computationally efficient increase average diagnostic cost
version gde fact unable solve circuit iscas enable
useful comparison extracted set small subcircuits iscas circuits
circuits size circuits size circuit randomly generated single fault double fault triple fault scenarios one test
case input output vector fault scenario comparison gde sda
baseline benchmarks given table shows sda performs well gde
terms diagnostic cost
larger benchmarks
evaluate performance sda larger iscas circuits conducted three sets experiments time involving single double five faults respectively version gde available us unable handle circuits order
provide systematic reference point comparison implemented random strategy random order measurement points generated circuit used
test cases strategy uses dnnf check whether stopping
criteria met
table shows comparison random strategy sda baseline
two different heuristics one entropies wires alone ew
failure probabilities fp three systems ran
set experiments without pruning dnnf known fault cardinality
described section indicated third column table test
cases first four circuits could solved circuits failure occurred
compilation phase hence affected random strategy sda


fisequential diagnosis abstraction

circuit system pruning
c

rand

gates

sda ew
sda fp

c

rand

gates

sda ew
sda fp

c

rand

gates

sda ew
sda fp

c

rand

gates

sda ew
sda fp


yes

yes

yes

yes

yes

yes

yes

yes

yes

yes

yes

yes

single fault
cost time



































double fault
cost time











































five fault
cost time

























table effectiveness heuristic
clear diagnostic cost significantly lower heuristics sda
random strategy whether pruning used interesting
note pruning significantly reduces diagnostic cost random sda ew
strategies much less effect sda fp except cases c single fault
moreover sda fp generally dominates sda ew without pruning
may observe five fault cases sda fp without pruning
much lower diagnostic cost sda ew pruning ii double fault cases two
largely comparable iii single faults cases comparison reversed
indicates fault cardinality rises combination failure probabilities wire
entropies appears achieve effect similar pruning sda ew pruning
performs better sda fp without pruning single fault cases attributed
fact cases pruning exact hence likely maximum
benefit
effectiveness abstraction
report table repeating experiments sda fp
hierarchical
notably running time generally reduces cases able
handle two circuits namely c c solving cases c
single double five fault cases cases c


fisiddiqi huang

circuit

pruning

c


yes

yes

yes

yes

yes

yes

cones

c
cones

c
cones

c
cones

c
cones

c
cones

single fault
cost time

























double fault
cost
time

























five fault
cost time













table effectiveness abstraction

circuit
c
c
c
c
c
c
c
c
c
c

total
gates











abstraction
size











cloning
time











total
clones











abstraction size
cloning











table preprocessing step cloning

single double five fault cases failures occurred
compilation phase note observations cause sufficient simplification
theory successfully compiled even abstraction terms diagnostic
cost cases hierarchical comparable baseline
c baseline consistently performs better hierarchical fault
cardinality reverse true c note pruning helps reduce
diagnostic cost degrees baseline
discussed earlier confirm main advantage hierarchical
larger circuits solved circuits solved baseline
hierarchical may help reduce diagnostic cost quickly finding
faulty portions circuit represented set faulty cones directing
measurements inside useful measurements e g case
c hand may suffer cases needlessly go
hierarchies locate actual faults baseline version directly
efficiently e g case c discussed section


fisequential diagnosis abstraction

circuit
c
c

single fault
cost
time





double fault
cost
time





five fault
cost time





table effect component cloning diagnostic performance
circuit
c
c
c
c
c
c
c

single fault
cost
time















double fault
cost
time















five fault
cost
time














table hierarchical sequential diagnosis component cloning c c omitted already easy diagnose cloning lead reduced
abstraction

effectiveness component cloning
subsection discuss experiments component cloning cloning
significantly affect diagnostic cost allows us solve much larger circuits
particular nearly circuits iscas suite
table shows pre processing step cloning circuit
columns give name circuit total number gates circuit size
abstraction circuit cloning time spent cloning total number
clones created circuit abstraction size circuit obtained cloning
circuits except c c c significant reduction abstraction size
achieved c appears extreme case large abstraction
lacks hierarchy gates abstractions c c roots cones
affording opportunities reduction note two circuits already
simple easy diagnose
start investigating effect component cloning diagnostic performance
isolate effect component cloning use baseline version sda e without
abstraction without pruning table summarizes performance baseline sda
cloning circuits c c comparing corresponding entries table shows overall diagnostic cost slightly affected
cloning observed significant number cases proposed measurement sequence change cloning cases changed
insubstantially moreover number cases although substantially different
sequence measurements proposed actual diagnostic cost change much
finally note diagnosis time case c reduced cloning
ascribed general reduction complexity compilation due smaller
abstraction


fisiddiqi huang

circuit
c

c

c

c

c

c

total max cone abstraction measurement
ac ic edc
cases inputs
size
points



































































































































cases
solved
































single fault
cost time










































table effectiveness diagnostic cost estimation
final set experimental iscas circuits summarized table
illustrates performance hierarchical sequential diagnosis component cloning
scalable version sda test cases circuits c
solved largest circuits benchmark suite could handled cases
c cases c single double five fault
cases cases c single double fivefault cases solved terms diagnostic cost cloning generally resulted slight
improvement terms time difference insignificant c c
larger circuits c c diagnosis cloning clearly order
magnitude faster
effectiveness diagnostic cost estimation
finally demonstrate effectiveness cost estimation function
often possible destroy different cones obtain different abstractions system


fisequential diagnosis abstraction

successfully compiled cost estimation function select
abstraction used diagnosis likely give optimal average cost
help explain cases hierarchical causes diagnostic cost
increase compared baseline
experiments use sda cloning include circuits c considering single fault test cases include largest circuits analysis
circuits often could compiled cones destroyed therefore possible obtain overall picture actual cost circuits test
cases circuits c used whereas circuits c
c time use complete set cases done smaller circuits specifically generate n fault scenarios circuit n equals number gates
circuit scenario contains different faulty gate randomly generate
test case n scenarios cases could obtain test case
reasonable time corresponding scenarios used
experiments summarized table circuit first row
shows cones considered subsequent rows
cones specified number inputs column
destroyed value column get trivial abstraction cones
destroyed equivalent baseline last two
columns actual average cost time diagnosing circuit given
abstraction columns labeled ac ic edc values obtained
equations respectively given abstraction
often able destroy several cones still able
compile circuit successfully however quite naturally compilation time increases
cones destroyed point circuits start fail compile
stop destroying cones actual diagnostic cost different circuits different
trends time cones destroyed example c shows significant
improvement reverse true c remaining circuits actual cost shows
somewhat mixed trends however relative increase decrease costs generally
less significant
comparison isolation abstraction costs e ic ac respectively
abstractions confirms time cones destroyed isolation cost
increases abstraction cost decreases potentially imbalanced change
two costs determines whether cost might go cones
destroyed example case c abstraction cost drops rapidly
isolation cost increases cones destroyed case c two
costs change almost pace
comparison predicted costs edc actual costs shows c
c c c predicted costs often quite close actual costs
demonstrates relative accuracy circuits
cost estimation function accurately predict abstraction likely give
optimal cost example correctly suggests one use baseline
c two circuits c c predicted actual costs
significantly different cost estimation function fails give good predictions c


fisiddiqi huang

seems special case actual diagnostic cost increases quite rapidly
cones destroyed reason interesting topic future work

related work
et al considered two kinds hierarchical discussed automatic
methods constructing abstractions first kind components given
detailed model aggregated single components abstract model every
diagnosis detailed model refined diagnosis abstract model guaranteed
valid thus need check validity detailed diagnoses afterwards
second kind abstract model constructed possible
determine unique diagnosis every level hierarchy reasonable cost
measurements less costly make appear abstract model
costly measurements appear detailed model techniques automatic
abstraction system observability discussed torta torasso
papers provide alternative techniques automatic abstraction however
address sequential diagnosis
idea testing likely failing component comes heckerman et al
testing component considered unit operation components
tested decreasing order likelihood failure computed assuming
single fault assumption could compromise quality measurement sequence
multiple fault cases authors pointed case contrast testing
variable component unit operation calling complex heuristic
order minimize number tests need assume single fault
work goes scalability several structure techniques compilation
abstraction component cloning
chittaro ranon considered computation diagnoses hierarchical
method takes hierarchical decomposition system input
sets components aggregated units computes set diagnoses
abstract level refined hierarchically detailed level feldman
van gemund developed hierarchical diagnosis tested reverse
engineered iscas circuits hansen yalcin hayes available highlevel form idea decompose system hierarchies way minimize
sharing variables done well engineered
formed hierarchies hand iscas circuits system represented
hierarchical logical formula hierarchy represented traditional cnf
formula representation translated fully hierarchical dnf fully flattened
dnf partially flattened dnf dictated depth parameter hierarchical
search employed diagnoses hierarchical aspect two
approaches similar however require hierarchical decomposition
system given part input obtained hand
searches hierarchies automatically another major difference consider
computation diagnoses address sequential diagnosis
gde framework de kleer studied sensitivity diagnostic
cost called policy policy quantifies posterior


fisequential diagnosis abstraction

probabilities diagnoses estimated gde computes heuristic
case probabilities diagnoses required probabilities
required computed exactly evaluating differentiating dnnf
nevertheless sensitive initial probabilistic model given
sensitivity analysis regard may lead interesting findings
recently flesch lucas van der weide proposed framework integrate
probabilistic reasoning model diagnosis framework upon notion
conflict measure originated tool detection conflicts
observation given bayesian network jensen system modeled
bayesian network diagnostic reasoning possible use conflict measure
differentiate diagnoses according degree consistency given set
observations work however address sequential diagnosis
e locating actual faults taking measurements
recently feldman provan van gemund proposed related method
reducing diagnostic uncertainty work attempts identify actual faults
fewest individual measurements heuristic aimed reducing number
diagnoses fewest test vectors

conclusion
presented system sequential diagnosis called sda employs four
structure techniques scale diagnosis larger systems specifically uses
heuristic measurement selection computed efficiently dnnf
compilation system diagnose larger systems automatically computes structural abstraction system performs diagnosis hierarchical fashion
employs structure technique reducing abstraction size system
scales diagnosis largest benchmark systems finally automatically
select abstraction system likely give optimal average cost

acknowledgments
thank anonymous reviewers comments nicta funded australian
government represented department broadband communications
digital economy australian council ict centre excellence
program part work appeared kr siddiqi huang another
part work carried julyseptember first author
visiting nicta

appendix computing probabilities dnnf
briefly describe computation probabilities dnnf compilations
bayesian networks dnnf graph representation nested expression
negation appears next variables children every node disjoint sets
variables decomposability children every node pairwise logically inconsistent


fisiddiqi huang




















oka






















j









oka

p



okj







j j





j


okj


figure dnnf compilation subcircuit dotted figure given observation
p computation posterior probability j

determinism example figure shows dnnf compilation subcircuit
dotted box figure observation p
given dnnf compilation probability p r e e instantiation e set
variables e obtained following linear time procedure set variables e
boolean constants according instantiation e ii set literals e
true except numbers associated negative literals associated
minus corresponding numbers positive literals iii evaluate ddnnf bottom treating true false remaining leaves associated
numbers nodes additions nodes multiplications number root
p r e e example figure shows computation probability j
given observation p thus e p j dnnf
set p j j rest literals given values
associated discussed section
furthermore second traversal dnnf top effectively
differentiate dnnf updated probabilities computed every
possible change value variable e g unknown known darwiche
useful measurement point selection need update entropies
candidate measurement points

appendix b cardinality model pruning
present technique referred section used remove significantly large number diagnoses cardinality k dnnf
value k must greater equal minimum cardinality dnnf
pruning occur k equal minimum cardinality dnnf
diagnoses cardinality k removed minimization procedure described


fisequential diagnosis abstraction

figure pruning dnnf improve heuristic accuracy
darwiche however k greater minimum cardinality dnnf
need similar modified minimization make sure remove
diagnoses cardinality k
complete pruning difficult achieve general approximation possible
naive one may remove every child l every node n minimumcardinality mc l greater k sound never remove
diagnoses cardinality k may little pruning many cases
increase amount pruning performed computing local value k n every node n
given global k whole dnnf top traversal dnnf
every node n suggests value k l child l largest values accepted
final value k l essential avoid possibly removing diagnoses cardinality
k pruning occur way k n often less global
k k n computed every node every child l every node n
mc l k l pruned
give pruning performs two pass traversal
dnnf mc n updated upward traversal represents minimumcardinality diagnoses node n whereas k n updated downward
traversal represents upper bound fault cardinality node used
prune branches emanating node whose mc n exceeds k n
two passes procedure follows initialize mc n k n
least possible value n traverse dnnf children visited
parents every leaf node set mc n n negated health variable
otherwise every node set mc n minimum values mc children
every node set mc n sum values mc children traverse
dnnf parents visited children set k n root node
value k every node remove every child p n mc p k n
every remaining child v set k v k n k n k v every child p every node
let tp sum values mc children set k p value tp
tp k p
procedure conditions k n k v tp k p updating k
node ensure safe value k set example shown figure
mc left k right values shown node branches labeled


fisiddiqi huang



g


g

c

g


g
g
g
c

figure combinational circuit generated randomly set components consisting
gates g g g cones c c processed order
g c g g g c g g

n

















total
gates

















average
depth

















approx
treewidth

















abstraction
size

















total
clones

















abstraction size
cloning

















table randomly generated combinational circuits n

subgraphs associated hypothetical values mc figure shows
minimum cardinality every node mc less equal bound k except
branch labeled gets pruned accordingly

appendix c randomly generated combinational circuits
section use novel method systematically generate series combinational
circuits structure size controlled enables evaluation
techniques circuits iscas benchmarks helped us identify
factors affect diagnostic cost leading us cost estimation function given
section specifically observe circuits similar structure diagnostic cost
generally increases circuit size helped us devise notion isolation cost


fisequential diagnosis abstraction

circuit size held constant diagnostic cost generally increases number
cones circuit helped us devise notion abstraction cost
circuits generated composing set pre formed building blocks latter
consist gates cones gates taken pool six gates types
nand buffer cones pool eight cones
gates extracted iscas benchmark circuits
composition method inspired method generating random bayesian
networks described marinescu kask dechter circuits generated
according formula n p n number components building blocks
use p percentage cones components maximum number inputs
gate generate n components randomly pick p n cones
repetition pool cones n p n gates repetition
pool gates place random order number inputs gate set
randomly except buffer gate one
input
process component follows suppose components placed
order c c cn let pi set components precede ci
order process component ci connect every input ci output
randomly chosen component pi two inputs ci connected
component input ci cannot connected pi empty
components pi used treated primary input circuit
example circuit figure randomly generated according formula
components shown boxes represent cones
varying parameters n p obtain circuits varying size structure
first fix p vary n generate range circuits increasing size
n generate circuits circuits summarized table numbers
columns averaged circuits given size rounded generally
n increased see increase abstraction size well estimated treewidth
corresponding increase perceived difficulty circuit e g note
largest circuit set smaller c estimated treewidth c much
lower actual compilation indeed harder former circuit
circuit randomly generate single fault double fault five fault scenarios
single test case scenario
experiments circuits given tables
baseline hierarchical cloning techniques respectively generally
consistent obtained iscas circuits baseline sda could
solve circuit beyond hierarchical sda solved circuits could
solve circuit beyond scalable version sda component
cloning solved much larger circuits
note general trend increase diagnostic cost increase n
consistent ones intuitive expectation diagnostic uncertainty would increase
system size note diagnostic cost often significantly higher hierarchical
baseline discussed earlier attributed
fact hierarchical often go hierarchies cones reach
faulty gate baseline may able reach directly


fisiddiqi huang

total
single fault
double fault
five fault
pruning
gates
solved cost time solved cost time solved cost
time







yes










yes










yes













yes














yes














yes






n

table baseline heuristic randomly generated circuits n
total
single fault
double fault
five fault
pruning
gates
solved cost time solved cost time solved cost
time





yes










yes








yes









yes












yes














yes














yes






n

table hierarchical heuristic randomly generated circuits n
observe pruning leads general improvement diagnostic cost
improvement significant hierarchical explained
fact effect pruning much greater abstract model branch
pruned correspond large part original system
perform another set experiments study impact hierarchy
controlled manner time hold size circuits less constant
vary percentage cones specifically generate large number random
circuits p ranging value p generated circuits
contain gates average
experiments circuits summarized table note p increases
estimated treewidth circuits decreases would expected actual
compilation time indeed decreases diagnostic cost hand increases
steadily p remains less flat afterwards confirms potential


fisequential diagnosis abstraction

n



















total
single fault
double fault
five fault
gates solved cost
time solved cost
time solved cost
time



























































































































table component cloning randomly generated circuits n
p








total
single fault
treewidth
circuits
cost time





























double fault
cost
time















five fault
cost time








table component cloning randomly generated circuits n p
negative impact hierarchy diagnostic cost hypothesized p increases
likelihood fault occurring inside cone increases thus average one
take measurements many inputs cones locate fault diagnostic cost
increase p consistent observation since
circuit size fixed roughly cone contributes gates circuit
p increases point gates lying outside cones hence
likelihood fault occurring cone less plateaued

references
brglez f fujiwara h neutral netlist combinational benchmark circuits target translator fortran proceedings ieee international
symposium circuits systems iscas pp
chittaro l ranon r hierarchical model diagnosis structural
abstraction artificial intelligence


fisiddiqi huang

choi chavira darwiche node splitting scheme generating upper bounds bayesian networks proceedings rd conference
uncertainty artificial intelligence uai pp
darwiche marquis p knowledge compilation map journal artificial
intelligence
darwiche decomposable negation normal form journal acm

darwiche differential inference bayesian networks journal
acm
darwiche advances compiling cnf decomposable negation normal form proceedings th european conference artificial intelligence
ecai pp
darwiche c compiler user manual tech rep computer science
department ucla http reasoning cs ucla edu c
de kleer j williams b c diagnosing multiple faults artificial intelligence

de kleer j focusing probable diagnosis readings model diagnosis
pp morgan kaufmann publishers inc san francisco ca usa
de kleer j improving probability estimates lower diagnostic costs th
international workshop principles diagnosis dx
de kleer j raiman shirley one step lookahead pretty good
readings model diagnosis pp morgan kaufmann publishers inc
san francisco ca usa
feldman van gemund two step hierarchical modelbased diagnosis proceedings st aaai conference artificial intelligence
aaai pp
feldman provan g van gemund j c fractal efficient fault
isolation active testing proceedings st international joint conference
artificial intelligence ijcai pp
flesch lucas p van der weide conflict diagnosis adding uncertainty model diagnosis proceedings th international joint
conference artificial intelligence ijcai pp
forbus k de kleer j building solvers mit press cambridge
usa
hansen c yalcin h hayes j p unveiling iscas benchmarks
case study reverse engineering ieee design test computers


fisequential diagnosis abstraction

heckerman breese j rommelse k decision theoretic troubleshooting
communications acm
jensen f v bayesian networks decision graphs springer verlag york
inc secaucus nj usa
kirkland mercer r topological search atpg
proceedings th conference design automation dac pp
marinescu r kask k dechter r systematic vs non systematic
solving mpe task proceedings th conference uncertainty
artificial intelligence uai pp
j van rikxoort r bakker r construction hierarchic
annals mathematics artificial intelligence
pearl j probabilistic reasoning intelligent systems networks plausible inference morgan kaufmann publishers inc san francisco ca usa
pipatsrisawat k darwiche clone solving weighted max sat reduced
search space proceedings th australian joint conference artificial
intelligence ai pp
siddiqi huang j hierarchical diagnosis multiple faults proceedings
th international joint conference artificial intelligence ijcai pp

siddiqi huang j advances sequential diagnosis proceedings
twelfth international conference principles knowledge representation
reasoning kr pp
torta g torasso p automatic abstraction component diagnosis driven
system observability proceedings th international joint conference
artificial intelligence ijcai pp
torta g torasso p symbolic component abstraction modelbased diagnosis th international workshop principles diagnosis dx




