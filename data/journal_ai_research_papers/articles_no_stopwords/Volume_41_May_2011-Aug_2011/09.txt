Journal Artificial Intelligence Research 41 (2011) 329-365

Submitted 02/11; published 06/11

Sequential Diagnosis Abstraction
Sajjad Siddiqi
National University Sciences Technology
(NUST) Islamabad, Pakistan

sajjad.ahmed@seecs.edu.pk

Jinbo Huang
NICTA Australian National University
Canberra, Australia

jinbo.huang@nicta.com.au

Abstract
system behaves abnormally, sequential diagnosis takes sequence measurements system faults causing abnormality identified, goal
reduce diagnostic cost, defined number measurements. propose
measurement points, previous work employs heuristic based reducing entropy
computed set diagnoses. approach generally good performance terms
diagnostic cost, fail diagnose large systems set diagnoses
large. Focusing smaller set probable diagnoses scales approach generally
leads increased average diagnostic costs. paper, propose new diagnostic
framework employing four new techniques, scales much larger systems good
performance terms diagnostic cost. First, propose new heuristic measurement
point selection computed efficiently, without requiring set diagnoses,
system modeled Bayesian network compiled logical form known
d-DNNF. Second, extend hierarchical diagnosis, technique based system abstraction previous work, handle probabilities applied sequential
diagnosis allow larger systems diagnosed. Third, largest systems
even hierarchical diagnosis fails, propose novel method converts system
one smaller abstraction whose diagnoses form superset
original system; new system diagnosed result mapped back
original system. Finally, propose novel cost estimation function
used choose abstraction system likely provide optimal average
cost. Experiments ISCAS-85 benchmark circuits indicate approach scales
circuits suite except one flat structure susceptible useful
abstraction.

1. Introduction
system behaves abnormally, task diagnosis identify reasons
abnormality. example, combinational circuit Figure 1, given inputs
P Q R, output V 0, actually 1 due faults gates J
B. Given system comprising set components, knowledge base modeling
behavior system, along (abnormal) observed values system variables,
(consistency-based) diagnosis set components whose failure (assuming
components healthy) together observation logically consistent
system model. example, {V }, {K}, {A}, {J, B} diagnoses given
c
2011
AI Access Foundation. rights reserved.

fiSiddiqi & Huang



BUFFER

1
P

1
Q



1

1


J

1
B



1

1


V

1
K

0
R

Figure 1: faulty circuit.

observation. general, number diagnoses exponential number
system components, one correspond set actual faults.
paper, therefore, consider problem sequential diagnosis (de Kleer &
Williams, 1987), sequence measurements system variables taken
actual faults identified. goal reduce diagnostic cost, defined
number measurements. propose measurement points, state-of-the-art gde (general
diagnosis engine) framework (de Kleer & Williams, 1987; de Kleer, Raiman, & Shirley, 1992;
de Kleer, 2006) considers heuristic based reducing entropy set computed
diagnoses. approach generally good performance terms diagnostic cost,
fail diagnose large systems set diagnoses large (de Kleer & Williams,
1987; de Kleer et al., 1992; de Kleer, 2006). Focusing smaller set probable diagnoses
scales approach generally leads increased average diagnostic costs (de Kleer,
1992).
propose new diagnostic framework employing four new techniques, scales
much larger systems good performance terms diagnostic cost. First, propose
new heuristic require computing entropy diagnoses. Instead consider
entropies system variables measured well posterior probabilities
component failures. idea select component highest posterior
probability failure (Heckerman, Breese, & Rommelse, 1995) variables
component, measure one highest entropy. compute probabilities,
exploit system structure joint probability distribution faults
system variables represented compactly Bayesian network (Pearl, 1988),
compiled deterministic decomposable negation normal form (d-DNNF) (Darwiche, 2001;
Darwiche & Marquis, 2002). d-DNNF logical form exploit structure present
many systems achieve compactness used compute probabilistic queries
efficiently. Specifically, required posterior probabilities exactly computed
evaluating differentiating d-DNNF time linear d-DNNF size (Darwiche,
2003).
330

fiSequential Diagnosis Abstraction

Second, extend hierarchical diagnosis, technique previous work (Siddiqi
& Huang, 2007), handle probabilities applied sequential diagnosis
allow larger systems diagnosed. Specifically, self-contained subsystems, called cones,
treated single components diagnosed found faulty
top-level diagnosis. significantly reduces number system components, allowing
larger systems compiled diagnosed. example, subcircuit dotted box
Figure 1 cone (with output {P, D} inputs) contains fault. First,
cone A, whole, determined faulty. compiled separately
diagnosed. previous work (Siddiqi & Huang, 2007) dealt task
computing diagnoses, involve measurements probabilities; present
paper, present several extensions allow technique carry sequential
diagnosis.
Third, abstraction system still large compiled diagnosed,
use novel structure based technique called cloning, systematically modifies
structure given system C obtain new system C0 smaller abstraction
whose diagnoses form super-set original system; new system
diagnosed result mapped back original system. idea select
system component G part cone hence cannot abstracted away
hierarchical diagnosis, create one clones G, distribute Gs parents (from
graph point view) among clones, way G clones become parts
cones disappear abstraction. Repeated applications operation
allow otherwise unmanageable system small enough abstraction diagnosis
succeed.
Finally, propose novel cost estimation function predict expected
diagnostic cost given abstraction system used diagnosis. aim
find abstraction system likely give optimal average cost.
purpose, use function various abstractions system different
abstractions obtained destroying different cones system (by destroying
cone mean overlook fact cone include components
abstraction). abstraction lowest predicted cost used actual
diagnosis.
Experiments ISCAS-85 benchmark circuits (Brglez & Fujiwara, 1985) indicate
solve first time nontrivial multiple-fault diagnostic cases benchmarks, good diagnostic costs, except one circuit flat structure susceptible
useful abstraction, new cost estimation function often accurately predict
abstraction likely give optimal average cost.

2. Background Previous Work
Suppose system diagnosed formally modeled joint probability distribution P r(X H) set variables partitioned X H. Variables X
whose values either observed measured, variables H health variables, one component describing health mode. joint probability distribution
P r(X H) defines set system states.
331

fiSiddiqi & Huang

Diagnosis starts initial (belief) state
I0 = P r(X H | Xo = xo )

(1)

values xo variables Xo X (we using boldface uppercase letters mean
sets vectors) given observation, wish reach goal state
= P r(X H | Xo = xo , Xm = xm )

(2)

measuring values xm variables Xm X\Xo , |Xm | = n, one time,
(the boldface 0 1 denote vectors 0s 1s):
Hf H, P r(Hf = 0 | Xo = xo , Xm = xm ) = 1
P r(Hf = 0, H\Hf = 1 | Xo = xo , Xm = xm ) > 0.
is, goal state set components Hf known faulty certainty
logical inconsistency arises components assumed healthy.
types goal conditions possible. example, health states components
determined certainty, condition P r(H = 0 | Xo = xo , Xm = xm )
0 1 H H (such goals possible reach strong fault models given,
strong fault models explicit descriptions abnormal behavior, opposed
weak fault models normal behavior known).
Two special cases worth mentioning: (1) initial state I0 satisfies goal
condition Hf = observation normal diagnosis required. (2)
initial state I0 satisfies goal condition Hf 6= , observation
abnormal diagnosis already completed (assuming able check
probabilities necessary); words, sequence length 0 solves problem.
Following de Kleer Williams (1987) assume measurements unit
cost. Hence objective reach goal state fewest measurements possible.
classical gde framework, receiving abnormal observation Xo = xo , considers
Shannons entropy probability distribution set computed diagnoses,
either set minimum-cardinality diagnoses set probable/leading diagnoses. proposes measure variable X whose value reduce entropy most,
average. idea probability distribution diagnoses reflects
uncertainty actual faults, entropy captures amount uncertainty.
measurement taken entropy updated updating posterior probabilities
diagnoses, potentially reducing 0.
results reported de Kleer et al. (1992) involving single-fault cases ISCAS-85
circuits indicate method leads measurement costs close optimal
policies. However, major drawback impractical number
diagnoses large (e.g., set minimum-cardinality diagnoses exponentially
large). Focusing smaller set probable diagnoses scales approach increase
likelihood irrelevant measurements generally leads increased average diagnostic
costs (de Kleer, 1992).
on, shall use combinational circuits example type systems
wish diagnose. approach, however, applies well types systems
332

fiSequential Diagnosis Abstraction

P
1
0

P
0.5
0.5

P
1
1
1
1
0
0
0
0

okJ
1
1
0
0
1
1
0
0

okJ
1
0
J
1
0
1
0
1
0
1
0

okJ
0.9
0.1

J|P,okJ
0
1
0.5
0.5
1
0
0.5
0.5

Figure 2: Bayesian network circuit Figure 1 (left). CPTs nodes P , J,
okJ (right).

long probabilistic model given defines behavior system. Sections 4
5 present new techniques introduced significantly enhance
scalability sequential diagnosis. start, however, presenting following section
system modeling compilation method underlies new diagnostic system.

3. System Modeling Compilation
order define joint probability distribution P r(X H) system behavior,
first assume prior probability failure P r(H = 0) given component
H H part input diagnosis task (de Kleer & Williams, 1987). example,
small table two entries top-right Figure 2 gives prior probability
failure gate J 0.1.
3.1 Conditional Probability Tables
Prior fault probabilities alone define joint probability distribution P r(X H).
addition, need specify component output related inputs
health mode. conditional probability table (CPT) component job.
CPT shown bottom (right) Figure 2, example, defines behavior
gate J: entry gives probability output (J) particular value given
value input (P ) value health variable (okJ). case okJ = 1,
probabilities always 0 1 behavior healthy gate deterministic.
case okJ = 0 defines fault model gate, part input
diagnosis task. example, assume output values probability 0.5
gate broken. simplicity assume gates two health modes
333

fiSiddiqi & Huang

(i.e., health variable binary); encoding compilation described later,
however, allows arbitrary number health modes.
Given tables, joint probability distribution circuit behavior
obtained realizing gates circuit satisfy independence property, known
Markov property: Given inputs health mode, output gate independent
wire descendant gate (a wire X descendant gate X
reached following path output circuit direction towards
circuit outputs). means circuit effectively treated Bayesian
network straightforward way, node wire health variable,
edge going input gate output, health
variable gate output. Figure 2 shows result translation circuit
Figure 1.
joint probability distribution encoded Bayesian network provides basis
computing posterior probabilities may need proposing measurement
points (by chain rule). However, provide efficient way so.
Specifically, computing posterior P r(X = x | = y) given values variables
known values involves summing variables X Y,
complexity exponential number variables done naively.
3.2 Propositional Modeling
known Bayesian network encoded logical formula compiled
d-DNNF, which, successful, allows posterior probabilities variables computed efficiently (Darwiche, 2003). purposes sequential diagnosis, encode
Bayesian network follows.
Consider subcircuit dotted box Figure 1 example,
modeled following formula:
okJ (J P ), okA (A (J D)).
Specifically, signal circuit translates propositional variable (A, D,
P , J), gate, extra variable introduced model health (okA, okJ).
formula health variables true remaining variables
constrained model functionality gates. general, component X,
okX NormalBehavior(X).
Note formula fails encode half CPT entries, okJ = 0.
order complete encoding CPT node J, introduce extra Boolean variable
J , write okJ (J J ). Finally, health variables (okA, okJ) associated
probabilities respective gates healthy (0.9 experiments),
-variable (J ) associated probability corresponding gate giving
output 1 broken (0.5 experiments; thus assuming output faulty
gate probabilistically independent inputs).
encoding circuit similar encoding Bayesian networks described Darwiche (2003) following way: According encoding Darwiche,
every node Bayesian network every value indicator variable.
Similarly every conditional probability network parameter variable.
334

fiSequential Diagnosis Abstraction

encoding, variables wires analogous network indicators,
encoding optimized single indicator values wire. Also,
encoding exploits logical constraints generate network parameters
zeros ones CPT. Finally, encoding node represents health variable optimized need single ok-variable serves
indicator network parameter.
components encoded described above, union (conjunction)
formulas compiled d-DNNF. required probabilities exactly computed
evaluating differentiating d-DNNF time linear size (Darwiche, 2003).
Details compilation process discussed Darwiche (2004), computation
probabilities described Appendix A.
present hierarchical diagnosis approach propose new measurement
selection heuristic.

4. Hierarchical Sequential Diagnosis
optimal solution sequential diagnosis would policy, is, plan measurements conditioned previous measurement outcomes, path plan leads
diagnosis system (Heckerman et al., 1995). computing optimal policies
intractable general, follow approach heuristic measurement point selection
previous work.
start definition Shannons entropy , defined respect
probability distribution discrete random variable X ranging values x1 , x2 , . . . , xk .
Formally:
k
X
(X) =
P r(X = xi ) log P r(X = xi ).
(3)
i=1

Entropy measures amount uncertainty value random variable.
maximal probabilities P r(X = xi ) equal, minimal one
probabilities 1, corresponding nicely intuitive notion degree uncertainty.
gde entropy computed probability distribution set computed
diagnoses (i.e., value random variable X ranges set diagnoses).
mentioned earlier, entropy difficult compute number diagnoses
large (de Kleer & Williams, 1987; de Kleer, 2006).
4.1 Baseline Approach
Able compute probabilities efficiently exactly following successful d-DNNF compilation, propose new two-part heuristic circumvents limitation scalability.
First, consider entropy candidate variable measured.
4.1.1 Heuristic Based Entropy Variable
Since wire X two values, entropy written as:
(X) = (px log px + px log px )
335

(4)

fiSiddiqi & Huang

px = P r(X = 1 | = y) px = P r(X = 0 | = y) posterior probabilities
X values 1 0, respectively, given values wires whose values
known.
(X) captures uncertainty value variable, interpret
expected amount information gain provided measuring variable. Hence
first idea consider selecting variable maximal entropy measurement
step.
4.1.2 Improving Heuristic Accuracy
idea alone, however, work well initial experiments. would
confirmed subsequent experiments, largely due fact (implicit) space
diagnoses generally large include large number unlikely diagnoses,
tends compromise accuracy information gain provided entropy.
experiments confirm explanation follows.
d-DNNF compilation produced, used compute probabilities, prune d-DNNF graph models (satisfying variable assignments)
corresponding diagnoses k broken components removed.1 set
initial k number actual faults experiments, observed significant
reduction diagnostic cost resulted almost cases. improved performance apparently due fact pruning updates posterior probabilities variables,
making accurate since many unlikely diagnoses eliminated.
practice, however, number faults known beforehand choosing
appropriate k pruning nontrivial (note k need exactly
number actual faults pruning help). Interestingly, following heuristic,
one actually use, appears achieve similar performance gain
automatic way: select component highest posterior probability failure
(an idea Heckerman et al., 1995; see Section 8), variables
component, measure one highest entropy. heuristic require
pruning d-DNNF, appears improve diagnostic cost similar
extent focusing measurement selection component likely broken
(empirical results effect given discussed Section 7.1).
4.1.3 Algorithm
start encoding system logical formula discussed Section 3,
subset variables associated numbers representing prior fault probabilities
probabilities involved fault models components, compiled
d-DNNF .
overall sequential diagnosis process propose summarized Algorithm 1.
inputs system C, d-DNNF compilation , set faults (which empty
used hierarchical approach), set known values variables,
integer k specifying fault cardinality bound (this running model pruning
experiments described Section 4.1.2, required diagnosis using final
1. complete pruning easy; however, approximation achieved time linear d-DNNF
size, variant minimization procedure described Darwiche (2001); see Appendix B.

336

fiSequential Diagnosis Abstraction

Algorithm 1 Probabilistic sequential diagnosis
function psd(C, , D, y, k)
inputs: {C: system}, {: d-DNNF}, {y: measurements}, {k: fault cardinality}, {D: ordered set
known faults}
output: {pair< , >}
1: Reduce ( , D, k |D| ) changed
2: Given variables Y, Evaluate (, y) obtain P r(y)
3: Differentiate () obtain P r(X = 1, y) variables X
4: Deduce fault = {X : P r(okX = 1, y) = 0}
5: changed && MeetsCriteria(,D,y)
6:
return < , >
7: Measure variable X best given heuristic
8: Add measured value x X y, go back line 1

heuristic). reduce pruning models (line 1) fault cardinality bound
k given, using function reduce(, D, k |D|). reduce accepts arguments
current DNNF , set known faults D, upper bound given k
cardinality remaining faults, whereas returns pruned DNNF. Reduce excludes
known faults computing minimum cardinality , uses k |D|
bound remaining faults (explained Appendix B). reduced first
time psd called later time changed (i.e., component found
faulty). evaluate (line 2) differentiate (line 3) (see Appendix A), select
measurement point take measurement (line 7), repeat process (line 8)
stopping criteria met (line 5).
stopping criteria line 5 given earlier Section 2 goal condition, i.e.,
stop abnormal observation explained faulty components already
identified assuming components healthy. faulty component X identified
P r(okX = 1, y) = 0 values variables already known,
mentioned earlier probabilities obtained variables simultaneously
d-DNNF differentiation process. Finally, condition current set faulty
components, health modes Hf , explains observation satisfied P r(Hf =
0, H\Hf = 1, y) > 0, checked single evaluation original d-DNNF.
algorithm returns actual faults together new set known values variables
(line 6).
4.2 Hierarchical Approach
scale approach handle larger systems using idea abstraction-based
hierarchical diagnosis (Siddiqi & Huang, 2007). basic idea compilation
system model d-DNNF efficient scalable number
system components reduced. achieved abstraction, subsystems,
known cones, treated single components. example cone depicted
Figure 1. objective use single health variable failure probability
entire cone, hence significantly reducing size encoding difficulty
compilation. cone identified faulty top-level diagnosis,
compiled diagnosed, recursive fashion.
337

fiSiddiqi & Huang

give formal definition abstraction previous work:
4.2.1 Abstraction System
Abstraction based upon structural dominators (Kirkland & Mercer, 1987) system.
component X dominates component , X called dominator , path
output system contains X. cone corresponds precisely set
components dominated component. cone may contain cones leading
hierarchy cones.
system abstracted treating maximal cones black boxes (a maximal
cone one either contained cone contained exactly one cone
whole system). example, cone treated virtual gate
two inputs {P, D} output A. abstraction system formally defined
as:
Definition 1 (Abstraction System). Given system C, let C0 = C C single
output; otherwise let C0 C augmented dummy component collecting outputs
C. Let output C0 . abstraction AC system C set
components X C X dominated C0 component X
O.
example, AC = {A, B, D, K, V }. J 6 AC J cannot reach output without
passing A, dominator J.
previous work (Siddiqi & Huang, 2007), dealt task computing minimum-cardinality diagnoses, involve probabilities measurement
selection. context sequential diagnosis, several additional techniques
introduced, particularly computation prior failure probabilities cones
way measurement points selected, outlined below.
4.2.2 Propositional Encoding
start discussion hierarchical encoding probabilistic reasoning,
similar hierarchical encoding presented previous work (Siddiqi & Huang, 2007).
Specifically, diagnosis abstraction AC given system C, health variables
associated components AC \IC , gates {A, B, D, K, V }
example (IC stands set inputs system C). Thus gate J Figure 1
associated health variable, J wire internal cone rooted
A. Consequently, nodes representing components AC \IC health
nodes associated corresponding Bayesian network. Hence node okJ
removed Bayesian network Figure 2.
addition, define failure cone outputs wrong value,
introduce extra clauses model abnormal behavior cone. example,
encoding given Section 3.2 cone Figure 1 (in dotted box) follows:
J P, okA (A (J D)), okA (A 6 (J D))
first part formula encodes normal behavior gate J (without health
variable); next encodes normal behavior cone; last encodes
338

fiSequential Diagnosis Abstraction

cone outputs wrong value fails. gates (that roots cones)
abstraction AC encoded normally described Section 3.2.
Note formulas components cone together encode single CPT
whole cone, provides conditional probability cones output given
health inputs cone, instead health inputs component
root cone. example, encoding meant provide conditional
probability given P , D, okA (instead J, D, okA), okA represents
health mode whole cone associated prior failure probability,
initially unknown us computed cones (explained below).
encoding whole system provides joint probability distribution variables
AC IC H, H = {okX | X AC \IC }.
4.2.3 Prior Failure Probabilities Cones
cone treated single component, prior probability failure whole
computed given prior probabilities components cones inside it.
creating two copies h f cone, h models healthy behavior
cone (without health variables), f includes faulty behavior well (i.e.,
full encoding described Section 3.2). outputs h f collected
XOR-gate X(when output XOR-gate X equals 1, inputs forced
different value). compute probability P r(X = 1) giving probability
outputs h f different. probability computed compiling
encoding d-DNNF evaluating X = 1.
Note procedure abstraction-based hierarchical, performed
bottom-up probabilities inner cones computed outer
ones. note performed per system pre-processing step.
4.2.4 Measurement Point Selection Stopping Criteria
principle, heuristic select variables measurement stopping criteria
baseline approach; however, couple details worth mentioning.
First, diagnosing abstraction given system (or cone) C, measurement
candidates restricted variables AC IC , ignoring internal variables maximal
conesthose measured cone whole found faulty.
Second, generally important full knowledge values cones inputs
final diagnosis cone concluded. diagnosis cone concluded
partial knowledge inputs may include faults vital validity
global diagnosis. reason diagnosis cone assumes unknown
inputs take either value, reality values may become fixed variables
parts system measured, causing diagnosis certain cones become
invalid, possibly requiring affected cones diagnosed meet
global stopping criteria (see line 17 Algorithm 2).
avoid situation retaining effectiveness heuristic, modify
measurement point selection follows diagnosing cone. selecting component
highest probability failure, consider variables component plus
inputs cone, measure one highest entropy. conclude
339

fiSiddiqi & Huang

Algorithm 2 Hierarchical probabilistic sequential diagnosis
function hpsd(C, uC , k)
inputs: {C : system},{uC : obs. across system} {k: fault cardinality}
local variables: {B, D, : set components} {y, z, uG : set measurements} {i, k 0 : integer}
output: {pair< , uC >}
1: Compile2dDNNF (AC , uC )
2: 0 , , uC
3: < B, > psd (C, , B, y, k)
4: {; < |B|; + +}
5:
G Element (B, i)
6:
G cone
7:
z Implications (, y)
8:
uG {x : x z, X IG OG }
9:
k 0 k |D| |B| + + 2
10:
< T, uG > hpsd(DG IG , uG , k 0 )
11:
uG ,
12:
Evaluate (, y), Differentiate ( )
13:
else
14:
{G}
15: z Implications (, y)
16: uC uC {x : x z, X IC OC }
17: MeetsCriteria (C, D, y)
18:
return < , uC >
19: else
20:
goto line 3

diagnosis cone values inputs become known (through measurement
deduction), except health components cone determined
without knowing inputs cone (it possible identify faulty component,
strong fault models healthy component, without knowing inputs).
Note restriction measure inputs cone lead significant
increase cost compared cost baseline approach; especially number
inputs cone large. discussed detail Section 6.
4.2.5 Algorithm
Pseudocode hierarchical approach given Algorithm 2 recursive function.
inputs system C, set known values uC variables inputs IC
outputs OC system, optional integer k specifying fault cardinality
bound purpose experimenting effect model pruning. start
d-DNNF compilation abstraction given system (line 1) use
function psd Algorithm 1 get diagnosis B abstraction (line 3), assuming
measurement point selection stopping criteria Algorithm 1 modified
according described Section 4.2.4. abstract diagnosis B used
get concrete diagnosis loop (lines 414). Specifically, component G B
root cone, added (line 14); otherwise cone G recursively
diagnosed (line 10) result added (line 11). recursively diagnosing
340

fiSequential Diagnosis Abstraction

cone G, subsystem contained G represented DG IG , DG set
components dominated G IG set inputs cone G.
recursively diagnosing cone G, compute abnormal observation uG
inputs output (IG {G}) cone G. values Gs inputs output
either measured deduced current set measurements. value
variable X implied x measurements P r(X = x, y) = 0,
easy check differentiated y. function Implications(, y)
(lines 7 15) implements operation, used compute partial abnormal
observation uG (line 8). fault cardinality bound k 0 cone G inferred (line 9),
algorithm called recursively diagnose G, given uG k 0 .
recursive call returns faults inside cone G together updated
observation uG . observation uG may contain new measurement results regarding
variables IG {G}, added set measurements abstraction
(line 11); measurement results obtained inside cone ignored due reasons
explained Section 4.2.4. concrete diagnosis augmented faults found
inside cone (line 11), evaluated differentiated light new
measurements (line 12).
loop ends, variable uC updated known values inputs
IC outputs OC system C (line 16). stopping criteria checked
diagnosis (line 17) met function returns pair < D, uC > (line 18); otherwise
measurements taken stopping criteria (line 17) met.
Since contain faults inside cones, compilation cannot used
check stopping criteria (note change parameters function
MeetsCriteria line 17) probabilistic information regarding variables inside cones
available . criteria checked follows instead: maintain depth
level every component system. outputs system depth level 1
rest components assigned depth levels based upon length shortest
route output system. example, Figure 1 gates B J depth
level 3, depth level 2. Hence, B J deeper A. first propagate
values inputs system, propagate fault effects components
D, one one, flipping values abnormal ones propagating towards
system outputs way deeper faults propagated first (Siddiqi & Huang,
2007), check values system outputs obtained equality
observation (y).
4.2.6 Example
Suppose diagnose abstraction circuit Figure 1, observation
uC = {P = 1, Q = 1, R = 0, V = 1}, take sequence measurements = {D =
1, K = 1, = 1}. concluded, abstract system model, given values
P D, value 1 abnormal. algorithm concludes fault A. Note
Q = 1 = 1 suggests presence another fault besides A, triggering
measurement gate B, found faulty. abstract diagnosis {A, B} meets
stopping criteria respect abstract circuit.
341

fiSiddiqi & Huang

1
P

1
Q

1

1
E

J

1
B

1


1

1


V

1
K

0
R

Figure 3: faulty circuit faults B J.
1
P

1
J

1
E

1


1
B
1
Q

1
B'

1

1


V

1
K

0
R

Figure 4: Creating clone B 0 B according D.
enter diagnosis cone recursive call observation uA = {P =
1, B = 1, = 1}. diagnosis cone immediately reveals cone E
faulty. Hence make recursive call order diagnose E observation
uE = {P = 1, B = 1, E = 1}. unknown wire J measured gate J found
faulty, explains observation outputs cones E well A, given
inputs P B. recursion terminates abstract diagnosis B = {A, B} generates
concrete diagnosis = {J, B}, meets stopping criteria algorithm
terminates.

5. Component Cloning
preceding section, proposed abstraction-based approach sequential diagnosis, reduces complexity compilation diagnosis reducing number
system components diagnosed. take one step further, aiming handle
systems large remain intractable even abstraction, case
largest circuits ISCAS-85 benchmark suite.
solution novel method systematically modifies structure system
reduce size abstraction. Specifically, select component G parents P (a
component X parent component , child X, output
input X) part cone hence cannot abstracted away hierarchical
342

fiSequential Diagnosis Abstraction

diagnosis, create clone G0 according parents P0 P sense
G0 inherits children G feeds P0 G longer feeds P0 (see
Figures 3 4 example). idea create sufficient number clones G
G clones become part cones hence abstracted away.
Repeated applications operation allow otherwise unmanageable system
small enough abstraction compilation diagnosis succeed. hierarchical
algorithm extended diagnose new system result mapped
original system. show solve almost benchmark circuits, using
approach.
go details new method, differentiate technique
known node splitting (Choi, Chavira, & Darwiche, 2007), used solve MPE
queries Bayesian network. Node splitting breaks enough number edges
nodes network MPE query resulting network becomes easy
solve. broken edge replaced root variable uniform prior. resulting
network relaxation approximation original MPE solution,
may computed compilation, gives upper bound MPE solution
original network. depth-first branch bound search algorithm searches
optimal solution using bounds prune search space. similar approach
used solve Weighted Max-SAT problems (Pipatsrisawat & Darwiche, 2007).
version node splitting directly applicable present setting
following reasons. edges system broken redirected new root variables
(primary inputs), resulting system represents different input-output function
original system. abnormal observation original system may hence
become normal one new system (if edges fault propagates
broken), eliminating basis diagnosis. technique component cloning,
viewed version node splitting, introduces clones component instead
primary inputs preserves input-output function system. Also, new
system relaxation original diagnoses superset
original.
formally define component cloning:
Definition 2 (Component Cloning). Let G component system C parents
P. say G cloned according parents P0 P system C results
system C0 follows:
edges going G parents P0 removed.
new component G0 functionally equivalent G added system
G0 shares inputs G feeds P0 .
Figures 3 4 show example creating clone B 0 B according {D}
results new circuit whose abstraction contains gates {A, D, K, V }, whereas
abstraction original circuit contains gate B.
5.1 Choices Component Cloning
two choices made component cloning: components clone,
many clones create split parents?
343

fiSiddiqi & Huang

Since goal cloning reduce abstraction size, clear wish
clone components lie abstraction (i.e., within cones). Among these,
cloning root cone cannot reduce abstraction size destroy existing
cone reintroducing components inside cone abstraction.
example, cloning according K Figure 4 produce circuit clone
abstracted away B 0 longer dominated hence reintroduced
abstraction. Therefore, final candidates cloning precisely components
abstract system roots cones. Note order
candidates processed unimportant cloned produce equal
reduction, namely reduction precisely 1 abstraction size, any.
remains determine candidate many clones create
connect parents. understand final method, helps consider
naive method simply creates |P| 1 clones (where P set parents)
clone, well original, feed exactly one parent. way every parent
component becomes root cone component clones
abstracted away. Figure 3, example, B three parents {E, A, D}, naive
method would create two clones B total three instances gate split
three parents, would result abstraction Figure 4.
trick number clones reduced knowing parents
component may lie cone single clone component according
parents sufficient clone abstracted away. example
Figure 3, again, parents E, B lie cone would suffice create
single clone B according {E, A}, resulting same, efficient cloning
Figure 4.
formally, partition parents component G subsets P1 , P2 , . . . , Pq
parents G lie cone placed subset
rest separate ones. create q 1 clones G according q 1
subsets, resulting G clones abstracted away. process repeated
candidate component abstraction size small enough reduction
possible.
5.2 Diagnosis Component Cloning
new system functionally equivalent original smaller abstraction,
equivalent original diagnostic purposes. new model allows
component clones fail independently other, relaxation
original model diagnoses new system form superset
original. Specifically, diagnosis new system assigns health state
component clones components corresponds diagnosis original
system; diagnoses spurious ignored.
core diagnosis process given Algorithm 2 continues applicable new
system, two minor modifications necessary. First, spurious diagnoses
(implicitly) filtered assuming health state clones (including
original) component soon health state one known. Second,
whenever measurement clone component proposed, actual measurement
344

fiSequential Diagnosis Abstraction

c7552
Number Cone Inputs

60
50
40
30
20
10
0
0

500

1000

1500

2000

2500

Cones

Figure 5: Cones ISCAS-85 circuits.

taken original component original system, obvious reasons (in words,
new system used reasoning original measurements).
principle, presence spurious diagnoses model potentially skew
measurement point selection heuristic (at least early stages diagnosis,
spurious diagnoses gradually filtered out). However, using smaller benchmarks
could diagnosed without cloning, conducted empirical analysis
indicates, interestingly, overall diagnostic cost slightly affected.
discuss detail Section 7.3.

6. Diagnostic Cost Estimation
address interesting issue stemming observation made conducting experiments (to detailed next section): system abstraction always beneficial
compilation, diagnostic cost always improve associated hierarchical
diagnosis. one hand, hierarchical diagnosis approach help cases
otherwise result high costs using baseline approach quickly finding faulty portions
system, represented set faulty cones, directing sequential diagnosis
take measurements inside cones, resulting useful measurements.
hand, introduce overhead cases needlessly go hier345

fiSiddiqi & Huang

archies locate actual faults, measure inputs cones involved, baseline
version find directly efficiently.
overhead hierarchical approach quite high faults lie cones
large number inputs. example, graphs Figure 5 show number inputs,
represented dots, various cones ISCAS-85 circuits. Note cones
small number inputs; however, cones 30 inputs, especially
c432 circuits beyond c1908, contribute increased diagnostic cost
several cases (such increase cost due cones confirmed separate set
experiments using large set systematically generated combinational circuits, detailed
Appendix C). avoid potential high cost diagnosis faults lie cone
large number inputs tempting destroy cone compilation
fault directly found. However, due associated increase
abstraction size, destroying cones may cause increased costs cases could
previously solved efficiently, thus may show negative impact, overall.
calls automatic mechanism predict effect destroying certain cones
overall diagnostic cost, subject section.
propose novel cost estimation function predict average diagnostic cost
given abstraction system considered diagnosis, different abstractions
obtained destroying different cones system. Since cones destroyed
automatically, function used automatically propose abstraction system, used diagnosis, likely give optimal average cost. function
uses hierarchical structure given abstraction predict cost
take account parameters may contribute cost, probabilities. addition function limited single fault cases only. Therefore, expected
cost computed function indicative cannot always correct. However,
experiments show function often quite useful proposing abstraction
system likely give optimal cost (to discussed next section).
estimate expected diagnostic cost assume composed two quantities
namely isolation cost abstraction cost, inversely proportional
other. isolation cost captures well given system abstraction isolate
faulty portions system. Therefore isolation cost minimum complete
abstraction system used (i.e., cones considered) generally increases
cones destroyed. abstraction cost captures overhead cost due introduction
cones. Hence, abstraction cost minimum (zero) abstraction considered
generally increases cones introduced.
define isolation cost diagnosis considering abstraction system
average cost required isolate single fault system using abstraction.
Similarly, define abstraction cost diagnosis average overhead cost required
diagnose single fault system using abstraction. expected average
cost diagnosis abstraction system considered diagnosis sum
isolation abstraction costs abstraction. different cones destroyed
given abstraction system expect changes values abstraction
isolation costs, determine whether overall cost go (if changes
uneven) stay constant (if changes even). idea obtain abstraction
346

fiSequential Diagnosis Abstraction

system strike balance two quantities get overall optimal cost.
discuss isolation abstraction costs estimated.
noted experiments using baseline approach heuristic
isolate single fault system cost average comparable log2
number measurement points system, provided us basis
computing isolation cost. hierarchical approach, fault lies inside cone
one first estimate isolation cost diagnosing cone, separately, add
isolation cost diagnosing abstract system get average isolation cost
(single) faults lie cone. example, cones considered
cost isolating fault circuit Figure 3 log2 (6) = 2.58 (values P , Q, R
V already known). However, cones considered cost isolating fault
lies inside cone sum isolation cost abstract circuit
isolation cost subcircuit inside cone A, log2 (4) + log2 (1) = 2. Similarly,
get average isolation cost single faults system, using hierarchical
approach, one add isolation cost diagnosing abstract system average
isolation costs diagnosing abstract components (where isolation cost
abstract component cone zero). Note isolation cost
diagnosing cone computed taking abstraction cone.
estimate abstraction cost diagnosis given abstraction first need
estimate overhead cost involved individual component system
abstraction. estimate overhead cost a, possibly faulty, component one
take union inputs outputs cones component lies,
number measurement points (approximately) constitutes required overhead
cost component. component lie cone overhead cost
component zero. example, circuit Figure 3 diagnosed using
hierarchical approach, find gate J faulty one must first find cone
faulty cone E faulty gate J faulty. overhead
cost gate J case 1 + 2 + 1 = 4 (i.e., measure wires A, B, E,
J, assuming Q known). abstraction cost diagnosis given abstraction
system average overhead costs system components
abstraction.
give formal definitions related cost estimation function. Let Pu (C)
set measurement points system C whose values unknown,
Pu (G) set inputs output abstract concrete component G whose
values unknown. Let p number abstract components abstraction AC
system C. Let Gi AC abstract component (either concrete component cone
abstraction; concrete component abstraction regarded trivial
cone containing component itself). Let DGi subsystem dominated Gi
AGi abstraction subsystem.
isolation cost IC(C, AC ) abstraction AC system C considered
diagnosis sum log2 (|M Pu (AC )|) average isolation costs computed,
similar manner, subsystems contained abstract components AC :
347

fiSiddiqi & Huang

(
Pp
log2 (|M Pu (AC )|) + p1
i=1 IC(DGi , AGi ), |M Pu (AC )| > 0
IC(C, AC ) = 1 Pp
otherwise
i=1 IC(DGi , AGi )
p

(5)

IC(DGi , AGi ) recursively computes isolation cost subsystem contained
abstract component Gi , using Equation 5, taking abstraction AGi . Note
computing IC(DGi , AGi ) assume inputs output Gi already
measured. Thus Pu (DGi ) excludes inputs output cone Gi . Gi
concrete
component IC(DGi , AGi ) = 0. cones considered (AC = C)
Pp
IC(D
Gi , AGi ) = 0 isolation cost simply equal log2 (|M Pu (C)|).
i=1
compute abstraction cost diagnosing system given abstraction
first compute overhead costs diagnosing individual cones abstraction.
multiply abstraction cost cone number components contained
cone get total overhead cost components cone. Adding
overhead costs computed way cones abstraction dividing
number total number concrete components whole system gives us
average overhead cost per component, call abstraction cost. Formally: Let
q cones AC . abstraction cost AC(C, AC ) abstraction AC
system C considered diagnosis given as:

AC(C, AC ) =

q
1 X
|DGi | {M Pu (Gi ) + AC(DGi , AGi )} : Gi AC cone
n

(6)

i=1

|DGi | number (concrete) components contained cone Gi , Pu (Gi )+
AC(DGi , AGi ) recursively computes abstraction cost diagnosing cone Gi , using
Equation 6, taking abstraction AGi . abstraction cost Gi multiplied
|DGi | effectively add cost measuring cone inputs output overhead cost
every component inside cone. note computing AC(DGi , AGi )
assume variables Pu (Gi ) already measured. Thus Pu (DGi )
excludes inputs output cone Gi .
Finally total expected cost EDC(C, AC ) diagnosing system C abstraction AC system considered diagnosis given as:
EDC(C, AC ) = IC(C, AC ) + AC(C, AC ).

(7)

7. Experimental Results
section provides empirical evaluation new diagnostic system, referred
sda (sequential diagnosis abstraction), implements baseline, hierarchical,
cloning-based approaches described Sections 4 5, cost estimation function
described Section 6. experiments conducted cluster 32 computers consisting two types (comparable) CPUs, Intel Core Duo 2.4 GHz AMD Athlon 64
X2 Dual Core Processor 4600+, 4 GB RAM running Linux. time limit 2
348

fiSequential Diagnosis Abstraction

hours memory limit 1.5 GB imposed test case. d-DNNF compilation done using publicly available d-DNNF compiler c2d (Darwiche, 2004, 2005).
CNF simplified compilation using given observation, allowed us
compile circuits, expense requiring fresh compilation per observation
(see Algorithm 2, line 1).
generated single- multiple-fault scenarios using ISCAS-85 benchmark circuits,
scenario set gates assumed faulty. single-fault cases circuits
c1355 simulated equal prior probability faults generating n fault scenarios
circuit, n equals number gates circuit: scenario contains
different faulty gate. randomly generated 5 test cases (abnormal observations)
n scenarios. multiple-fault scenarios would practical
due large number combinations, circuit c1355 (respectively, larger
c1355) simply generated 500 (respectively, 100) random scenarios given
fault cardinality random test case scenario.
Thus test case faulty circuit gate gates give incorrect
outputs. inputs outputs circuit observed. values internal wires
computed propagating inputs normal circuit towards outputs followed
propagating outputs assumed faulty gates one one deeper faults
propagated first. obtained values internal wires used simulate
results taking measurements. use P r(okX = 1) = 0.9 gates X circuit.
Note cases, gates fail equal probability, conceivably harder
solve diagnoses tend less differentiable. Then, gate, two output
values given equal probability gate faulty. Again, tend make
cases harder solve due high degree uncertainty. circuit fault
cardinality, report cost (number measurements taken) time (including
compilation time, CPU seconds) locate faults, averaged test cases solved.
present experiments four subsections demonstrating effectiveness
four techniques proposed paper, namely new heuristic, hierarchical sequential
diagnosis, component cloning, cost estimation function.
7.1 Effectiveness Heuristic
start comparison baseline algorithm sda gde show sda
achieves similar diagnostic costs scales much larger circuits, hence illustrating
effectiveness new heuristic (along new way compute probabilities).
7.1.1 Comparison gde
could obtain tutorial version gde (Forbus & de Kleer, 1993) comparison, downloadable http://www.qrg.northwestern.edu/BPS/readme.html. gde uses
ATCON, constraint language developed using LISP programming language, represent diagnostic problem cases. detailed account language given Forbus
de Kleer (1993). Further, employs interactive user interface proposes measurement points respective costs lets user enter outcomes measurements.
purpose comparison translated problem descriptions language accepted gde, modified gde automatically read measurement outcomes
349

fiSiddiqi & Huang

size system
13
14
15
16
17

gde
sda
gde
sda
gde
sda
gde
sda
gde
sda

single-fault
cost time
3.6
2.0
3.6 0.01
3.5 6.66
4.2 0.01
3.4
111
3.9 0.01
3.3
398
3.5 0.01
3.7 2876
3.8 0.01

double-fault
cost time
3.8
1.81
3.4
0.01
3.3
15.1
2.9
0.01
3.5
88
3.4
0.01
3.5
556
3.3
0.01
4.6
4103
4.2
0.01

triple-fault
cost time
4.0
1.9
2.8 0.01
3.0
14
2.9 0.01
4.3
299
3.7 0.01
3.2
509
2.8 0.01
4.5 2067
4.2 0.01

Table 1: Comparison gde.
input problem description. compiled LISP code machine dependent
binary code using native C compiler improve run-time performance.
version gde, developed tutorial purposes, computes set minimal diagnoses instead probable diagnoses. makes comparison less informative. Nevertheless, able make reasonable comparison terms diagnostic cost set
minimal diagnoses serve large set probable diagnoses components
equal prior probabilities. According de Kleer (1992) availability diagnoses
aids heuristic accuracy, whereas focusing smaller set probable diagnoses
computationally efficient increase average diagnostic cost.
version gde fact unable solve circuit ISCAS-85. enable
useful comparison, extracted set small subcircuits ISCAS-85 circuits:
50 circuits size 13, 14, 15 16, 10 circuits size 17. circuit randomly generated 5 single-fault, 5 double-fault, 5 triple-fault scenarios, one test
case (input/output vector) fault scenario. comparison gde sda
(baseline) benchmarks given Table 1 shows sda performs well gde
terms diagnostic cost.
7.1.2 Larger Benchmarks
evaluate performance sda larger ISCAS-85 circuits, conducted three sets experiments, time involving single, double, five faults, respectively. version gde available us unable handle circuits, order
provide systematic reference point comparison implemented random strategy random order measurement points generated circuit used
test cases. strategy uses d-DNNF check whether stopping
criteria met.
Table 2 shows comparison random strategy sda using baseline
approach two different heuristics, one based entropies wires alone (ew)
based failure probabilities (fp). three systems ran
set experiments without pruning d-DNNF (using known fault cardinality
described Section 4.1.2), indicated third column table. test
cases first four circuits could solved. circuits failure occurred
compilation phase, hence affected random strategy sda.
350

fiSequential Diagnosis Abstraction

circuit system pruning
c432

rand

(160 gates)

sda(ew)
sda(fp)

c499

rand

(202 gates)

sda(ew)
sda(fp)

c880

rand

(383 gates)

sda(ew)
sda(fp)

c1355

rand

(546 gates)

sda(ew)
sda(fp)


yes

yes

yes

yes

yes

yes

yes

yes

yes

yes

yes

yes

single-fault
cost time
92.3 20.7
4.5 11.4
42.0 16.6
3.7 11.1
6.7 11.7
4.3 11.0
109.6 0.8
5.5
0.2
58.1 0.7
3.6
0.2
6.5
0.2
4.8
0.2
221.0 1.9
5.4
0.2
26.8 0.3
4.0
0.2
10.8 0.2
5.6
0.2
327.2 4.3
7.4
0.4
82.6 1.3
4.9
0.4
34.1 0.8
8.0
0.4

double-fault
cost time
97.7 23.2
36.8 12.4
42.5 21.3
8.6
12.0
6.4
12.5
5.0
12.3
120.6 1.2
20.1
0.2
54.0
0.5
3.7
0.2
4.3
0.2
3.0
0.2
251.3 1.9
47.3
0.3
32.8
0.4
6.8
0.2
9.2
0.2
6.7
0.2
365.7 5.7
59.0
1.0
91.2
1.5
5.5
0.4
14.8
0.5
9.4
0.6

five-fault
cost time
117.8 26.5
99.7 17.2
68.4 25.5
33.8 12.8
9.4 13.0
9.1 12.6
150.0 1.4
104.9 0.7
95.8 0.8
35.7 0.3
7.2 0.2
7.1 0.2
306.4 2.3
205.7 1.3
79.0 0.7
30.5 0.4
15.8 0.3
14.0 0.3
437.4 5.6
328.6 3.5
203.9 3.4
65.9 1.1
19.3 0.8
18.4 0.6

Table 2: Effectiveness heuristic.
clear diagnostic cost significantly lower heuristics sda
random strategy whether pruning used. interesting
note pruning significantly reduces diagnostic cost random sda-ew
strategies, much less effect sda-fp except cases (c1355 single-fault).
Moreover, sda-fp generally dominates sda-ew, without pruning.
may observe (i) five-fault cases, sda-fp without pruning results
much lower diagnostic cost sda-ew pruning; (ii) double-fault cases, two
largely comparable; (iii) single-faults cases, comparison reversed.
indicates fault cardinality rises, combination failure probabilities wire
entropies appears achieve effect similar pruning. sda-ew pruning
performs better sda-fp without pruning single-fault cases attributed
fact cases pruning always exact hence likely result maximum
benefit.
7.2 Effectiveness Abstraction
report, Table 3, results repeating experiments sda-fp using
hierarchical approach.
notably, running time generally reduces cases able
handle two circuits, namely c1908 c2670, solving 139 300 cases c1908 (25
single-, 15 double-, 99 five-fault cases) 258 300 cases c2670 (100
351

fiSiddiqi & Huang

circuit

pruning

c432


yes

yes

yes

yes

yes

yes

(64 cones)

c499
(90 cones)

c880
(177 cones)

c1355
(162 cones)

c1908
(374 cones)

c2670
(580 cones)

single-fault
cost time
15.4
0.4
4.9
0.3
7.3
0.1
4.5
0.1
9.5
0.1
5.6
0.1
9.3
0.3
5.8
0.2
11.0
222
3.0
214
16.3
213
6.5
196

double-fault
cost
time
15.8
0.5
10.4
0.4
5.8
0.1
3.9
0.1
10.2
0.1
7.6
0.1
8.2
0.2
6.3
0.2
17.1
587
8.5
463
19.2
172
13.3
90

five-fault
cost time
22.2 0.5
21.5 0.4
10.5 0.2
9.6 0.2
17.4 0.2
16.3 0.2
14.0 0.3
14.4 0.3
34.9 505
32.4 383
25.4 58
24.3 45

Table 3: Effectiveness abstraction.

circuit
c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552

total
gates
160
202
383
58
880
1193
1669
2307
2416
3512

abstraction
size
59
58
77
58
160
167
353
385
1456
545

cloning
time
0.03
0.02
0.1
0.05
0.74
0.77
5.64
3.6
0.16
6.68

total
clones
27
0
24
0
237
110
489
358
0
562

abstraction size
cloning
39
58
57
58
70
116
165
266
1456
378

Table 4: Results preprocessing step cloning.

single-, 60 double-, 98 five-fault cases). failures occurred
compilation phase. Note observations cause sufficient simplification
theory successfully compiled even abstraction. terms diagnostic
cost, cases hierarchical approach comparable baseline approach.
c432, baseline approach consistently performs better hierarchical fault
cardinality, reverse true c1355. Note pruning helps reduce
diagnostic cost various degrees baseline approach.
discussed earlier, results confirm main advantage hierarchical approach
larger circuits solved. circuits solved baseline
approach, hierarchical approach may help reduce diagnostic cost quickly finding
faulty portions circuit, represented set faulty cones, directing
measurements inside them, result useful measurements (e.g. case
c1355). hand, may suffer cases needlessly go
hierarchies locate actual faults, baseline version find directly
efficiently (e.g. case c432). discussed Section 7.4.
352

fiSequential Diagnosis Abstraction

circuit
c432
c880

single-fault
cost
time
7.2
10.3
11.2
0.2

double-fault
cost
time
6.6
7.8
9.3
0.2

five-fault
cost time
9.6
9.7
16.2
0.3

Table 5: Effect component cloning diagnostic performance.
circuit
c432
c880
c1908
c2670
c3540
c5315
c7552

single-fault
cost
time
15.2
0.1
8.8
0.1
13.6
2.8
13.5
4.5
27.8
382
7.2
2.5
70.6
1056

double-fault
cost
time
14.8
0.1
9.3
0.1
18.3
5.0
15.3
0.7
30.5
72.5
21.1
5.9
43.1
129.0

five-fault
cost
time
20.2
0.1
15.8
0.2
35.4
5.1
20.1
2.3
36.1
108.6
24.4
6.6
104.8 1108

Table 6: Hierarchical sequential diagnosis component cloning (c499 c1355 omitted already easy diagnose cloning lead reduced
abstraction).

7.3 Effectiveness Component Cloning
subsection discuss experiments component cloning. show cloning
significantly affect diagnostic cost allows us solve much larger circuits,
particular, nearly circuits ISCAS-85 suite.
Table 4 shows result pre-processing step cloning circuit.
columns give name circuit, total number gates circuit, size
abstraction circuit cloning, time spent cloning, total number
clones created circuit, abstraction size circuit obtained cloning.
circuits except c499, c1355, c6288, significant reduction abstraction size
achieved. c6288 appears extreme case large abstraction
lacks hierarchy; gates abstractions c499 c1355 roots cones,
affording opportunities reduction (note two circuits already
simple easy diagnose).
start investigating effect component cloning diagnostic performance.
isolate effect component cloning use baseline version sda (i.e., without
abstraction), without pruning. Table 5 summarizes performance baseline sda
cloning circuits c432 c880. Comparing results corresponding entries Table 2 shows overall diagnostic cost slightly affected
cloning. observed significant number cases proposed measurement sequence change cloning, cases changed
insubstantially. Moreover, number cases, although substantially different
sequence measurements proposed, actual diagnostic cost change much.
Finally, note diagnosis time case c432 reduced cloning,
ascribed general reduction complexity compilation due smaller
abstraction.
353

fiSiddiqi & Huang

circuit
c432

c499

c880

c1355

c1908

c2670

total max. cone abstraction measurement
AC IC EDC
cases inputs
size
points
38
39
32
11.51 5.67 17.1
800
18
49
42
5.22 6.05 11.2
14
52
45
4.87 6.11 10.9
9
53
46
4.64 6.14 10.8
4
104
97
2.11 6.72 8.8
0
187
180
0.00 7.50 7.5
8
58
26
3.77 5.32 9.0
1010
5
74
42
3.13 5.91 9.0
3
170
138
0.71 7.10 7.8
0
202
170
0.0 7.40 7.4
16
57
31
6.54 5.42 11.9
1915
14
74
48
5.75 6.02 11.7
10
105
79
4.22 6.72 10.9
6
170
144
2.70 7.48 10.1
0
407
381
0.0 8.57 8.5
8
58
26
3.59 6.34 9.9
2730
5
98
66
2.74 7.20 9.9
4
114
82
2.47 7.27 9.7
3
266
234
1.43 8.23 9.6
2
426
394
0.43 8.77 9.2
0
546
514
0.0 9.00 9.0
40
70
45
14.37 7.07 21.4
859
29
76
51
12.85 7.15 20.0
28
80
55
12.70 7.23 19.9
27
82
57
12.62 7.27 19.8
20
138
113
8.36 7.82 16.2
18
150
125
7.79 7.92 15.7
55
56
52
17.84 6.40 24.2
989
34
58
57
16.19 6.53 22.7
33
128
64
15.63 6.68 22.3
25
178
114
11.52 7.44 18.9

cases
solved
800
800
800
800
800
800
1010
1010
1010
1010
1915
1915
1915
1915
1915
2730
2730
2730
2730
2730
2730
859
859
859
859
859
859
989
989
989
970

single-fault
cost time
15.2 0.06
11.0 0.1
11.0 0.1
10.7 0.1
8.8
0.3
7.3
7.3
7.3
0.1
7.7
0.1
9.4
0.1
6.4
0.1
8.7
0.1
8.5
0.1
8.0
0.1
8.6
0.1
10.8 0.2
9.30 0.1
12.55 0.2
12.39 0.2
22.5 0.3
33.5 0.4
34.0 0.4
18.7 2.6
17.8 5.8
18.3 5.9
18.2 5.9
17.7 15.0
17.7 47.5
19.2 0.7
19.1 0.8
18.6 0.8
16.1 79.0

Table 7: Effectiveness diagnostic cost estimation.
final set experimental results ISCAS-85 circuits, summarized Table 6,
illustrates performance hierarchical sequential diagnosis component cloning
scalable version sda. test cases circuits c1908 2670
solved, largest circuits benchmark suite could handled: cases
c5315, 164 300 cases c3540 (34 single-, 65 double-, 65 five-fault
cases), 157 300 cases c7552 (60 single-, 26 double-, 71 fivefault cases) solved. terms diagnostic cost cloning generally resulted slight
improvement. terms time difference insignificant c432 c880,
larger circuits (c1908 c2670) diagnosis cloning clearly order
magnitude faster.
7.4 Effectiveness Diagnostic Cost Estimation
Finally, demonstrate effectiveness cost estimation function. show
often possible destroy different cones obtain different abstractions system
354

fiSequential Diagnosis Abstraction

successfully compiled, then, using cost estimation function, select
abstraction used diagnosis likely give optimal average cost.
results help explain cases hierarchical approach causes diagnostic cost
increase compared baseline approach.
experiments, use sda cloning include circuits c2670, considering single-fault test cases. include largest circuits analysis
circuits often could compiled cones destroyed; therefore possible obtain overall picture actual cost circuits. Test
cases circuits c1355 used before, whereas circuits c1908
c2670, time, use complete set cases done smaller circuits. Specifically, generate n fault scenarios circuit, n equals number gates
circuit: scenario contains different faulty gate. randomly generate
1 test case n scenarios (in cases, could obtain test case
reasonable time corresponding scenarios used).
results experiments summarized Table 7. circuit first row
shows results cones considered subsequent rows show results
cones specified number inputs (in column 3)
destroyed. value column 3 0 get trivial abstraction, cones
destroyed, equivalent using baseline approach. last two
columns show (actual) average cost time diagnosing circuit using given
abstraction. columns labeled AC, IC, EDC show values obtained using
equations 6, 5, 7, respectively, given abstraction.
results show often able destroy several cones still able
compile circuit successfully. However, quite naturally, compilation time increases
cones destroyed point circuits start fail compile,
stop destroying cones. actual diagnostic cost different circuits show different
trends time cones destroyed. example, c432 shows significant
improvement reverse true c1355. remaining circuits actual cost shows
somewhat mixed trends; however, relative increase decrease costs generally
less significant.
Comparison isolation abstraction costs (i.e., IC AC, respectively)
various abstractions confirms time cones destroyed isolation cost
increases abstraction cost decreases. potentially imbalanced change
two costs determines whether cost might go cones
destroyed. example, case c432 abstraction cost drops rapidly
isolation cost increases cones destroyed, case c1355 two
costs change almost pace.
Comparison predicted costs EDC actual costs shows c432,
c499, c1908, c2670 predicted costs often quite close actual costs,
demonstrates relative accuracy approach. result, circuits
cost estimation function accurately predict abstraction likely give
optimal cost. example, correctly suggests one use baseline approach
c432. two circuits, c880 c1355, predicted actual costs
significantly different, cost estimation function fails give good predictions. c1355
355

fiSiddiqi & Huang

seems special case actual diagnostic cost increases quite rapidly
cones destroyed, reason interesting topic future work.

8. Related Work
et al. (1994) considered two kinds hierarchical models discussed automatic
methods constructing abstractions. first kind, components given
detailed model aggregated single components abstract model, every
diagnosis detailed model, refined diagnosis abstract model, guaranteed
valid. Thus need check validity detailed diagnoses afterwards.
second kind, abstract model constructed always possible
determine unique diagnosis every level hierarchy reasonable cost,
measurements less costly make appear abstract model
costly measurements appear detailed model. techniques automatic
abstraction-based system observability discussed Torta Torasso (2003, 2008).
papers provide alternative techniques automatic abstraction; however,
address sequential diagnosis.
idea testing likely failing component comes Heckerman et al. (1995),
testing component considered unit operation components
tested decreasing order likelihood failure, computed assuming
single fault (this assumption could compromise quality measurement sequence
multiple-fault cases authors pointed out). case, contrast, testing
variable component unit operation, calling complex heuristic
order minimize number tests; also, need assume single fault.
work goes scalability using several structure-based techniques: compilation,
abstraction, component cloning.
Chittaro & Ranon (2004) considered computation diagnoses using hierarchical
algorithm. method takes hierarchical decomposition system input,
sets components aggregated units, computes set diagnoses
abstract level, refined hierarchically detailed level. Feldman &
van Gemund (2006) developed hierarchical diagnosis algorithm tested reverse
engineered ISCAS-85 circuits (Hansen, Yalcin, & Hayes, 1999) available highlevel form. idea decompose system hierarchies way minimize
sharing variables them. done well engineered problems
formed hierarchies hand ISCAS-85 circuits. system represented
hierarchical logical formula hierarchy represented traditional CNF
formula. representation translated fully hierarchical DNF, fully flattened
DNF, partially flattened DNF dictated depth parameter, hierarchical
search algorithm employed find diagnoses. hierarchical aspect two
approaches similar ours; however, require hierarchical decomposition
system either given part input, obtained hand, approach
searches hierarchies automatically. Another major difference consider
computation diagnoses address problem sequential diagnosis.
Based gde framework, de Kleer (2006) studied sensitivity diagnostic
cost called -policy, policy quantifies posterior
356

fiSequential Diagnosis Abstraction

probabilities diagnoses estimated gde computes heuristic.
case, probabilities diagnoses required all, probabilities
required computed exactly evaluating differentiating d-DNNF.
Nevertheless, algorithm sensitive initial probabilistic model given
sensitivity analysis regard may lead interesting findings.
Recently, Flesch, Lucas, & van der Weide (2007) proposed new framework integrate
probabilistic reasoning model-based diagnosis. framework based upon notion
conflict measure, originated tool detection conflicts
observation given Bayesian network (Jensen, 2001). system modeled
Bayesian network diagnostic reasoning, possible use conflict measure
differentiate diagnoses according degree consistency given set
observations. work, however, address problem sequential diagnosis,
i.e., locating actual faults taking measurements.
recently, Feldman, Provan, van Gemund (2009) proposed related method
reducing diagnostic uncertainty. work attempts identify actual faults
fewest individual measurements, heuristic aimed reducing number
diagnoses fewest test vectors.

9. Conclusion
presented new system sequential diagnosis, called sda, employs four
new structure-based techniques scale diagnosis larger systems. Specifically, uses
heuristic measurement selection computed efficiently d-DNNF
compilation system. diagnose larger systems, automatically computes structural abstraction system performs diagnosis hierarchical fashion.
employs structure-based technique reducing abstraction size system,
scales diagnosis largest benchmark systems. Finally, automatically
select abstraction system likely give optimal average cost.

Acknowledgments
thank anonymous reviewers comments. NICTA funded Australian
Government represented Department Broadband, Communications
Digital Economy Australian Research Council ICT Centre Excellence
program. Part work appeared KR 2010 (Siddiqi & Huang, 2010); another
part work carried JulySeptember 2010 first author
visiting NICTA.

Appendix A. Computing Probabilities d-DNNF
briefly describe computation probabilities based d-DNNF compilations
Bayesian networks. d-DNNF graph representation nested and/or expression
negation appears next variables, children every and-node disjoint sets
variables (decomposability), children every or-node pairwise logically inconsistent
357

fiSiddiqi & Huang



0.0475

0.0475




1





0.0475

0.95

okA
0.9



0

0.1



1


1


1



0.95

J



0

0.05

0.05

okA

P

0

okJ

0.5

0.1

0.05

J J

0.5

1

J
0.5

okJ
0.9

Figure 6: d-DNNF compilation subcircuit (dotted) Figure 1 given observation
P computation posterior probability J = 1.

(determinism). example, Figure 6 shows d-DNNF compilation subcircuit
dotted box Figure 1 observation P D.
Given d-DNNF compilation, probability P r(E = e) instantiation e set
variables E obtained following linear-time procedure: (i) Set variables E
Boolean constants according instantiation e, (ii) set literals (not E)
true except numbers associated (negative literals associated
1 minus corresponding numbers positive literals), (iii) evaluate dDNNF bottom-up treating true 1, false 0, remaining leaves associated
numbers, or-nodes additions, and-nodes multiplications. number root
P r(E = e). example, Figure 6 shows computation probability J = 1
given observation P D. Thus e = {A = 1, P = 1, = 1, J = 1}. d-DNNF,
set = 1, P = 1, = 1, J = 1, J = 0. rest literals given values
associated (discussed Section 3.2).
Furthermore, second traversal d-DNNF, top down, effectively
differentiate d-DNNF updated probabilities computed every
possible change value variable (e.g., unknown known) (Darwiche, 2003).
useful measurement point selection need update entropies
candidate measurement points.

Appendix B. Cardinality-based Model Pruning
present technique referred Section 4 used remove significantly large number (if all) diagnoses cardinality > k d-DNNF.
value k must greater equal minimum-cardinality d-DNNF
pruning occur. k equal minimum-cardinality d-DNNF
diagnoses cardinality > k removed using minimization procedure described
358

fiSequential Diagnosis Abstraction

Figure 7: Pruning d-DNNF improve heuristic accuracy.
Darwiche (2001). If, however, k greater minimum-cardinality d-DNNF
need similar modified minimization algorithm make sure remove
diagnoses cardinality k.
complete pruning difficult achieve general, approximation possible.
naive approach, one may remove every child l every or-node n minimumcardinality (mc) l greater k, sound never remove
diagnoses cardinality k may result little pruning many cases.
increase amount pruning performed computing local value k(n) every node n
given global k whole d-DNNF using top-down traversal d-DNNF:
Every node n suggests value k(l) child l largest values accepted
final value k(l) (this essential avoid possibly removing diagnoses cardinality
k). pruning occur way k(n) often less global
k. k(n) computed every node, every child l every or-node n
mc(l) > k(l) pruned.
give pruning algorithm performs two pass traversal
d-DNNF. mc(n) updated upward traversal represents minimumcardinality diagnoses node n, whereas k(n) updated downward
traversal represents upper bound fault-cardinality node used
prune branches emanating node whose mc(n) exceeds k(n).
two passes procedure follows: Initialize mc(n) 0 k(n) -
(least possible value) n. Traverse d-DNNF children visited
parents every leaf node, set mc(n) 1 n negated health variable 0
otherwise; every or-node, set mc(n) minimum values mc children;
every and-node set mc(n) sum values mc children. traverse
d-DNNF parents visited children set k(n) root node
value k; every or-node, remove every child p n mc(p) > k(n)
every remaining child v set k(v) k(n) k(n) > k(v); every child p every and-node,
let tp sum values mc children set k(p) value tp
tp > k(p).
procedure conditions k(n) > k(v) tp > k(p) updating k
node ensure safe value k set. example shown Figure 7.
mc (left) k (right) values shown node. branches labeled , , ,
359

fiSiddiqi & Huang

I1

G1

I2
G2

C1

G3

I3
G5
G4
G6
C2

Figure 8: combinational circuit generated randomly set components consisting
gates G1 , G2 , . . . , G6 cones C1 , C2 , processed order:
G1 , C1 , G2 , G3 , G4 , C2 , G5 , G6 .

N
32
40
48
56
64
72
80
88
96
104
112
120
128
136
144
152

total
gates
104
130
156
182
208
234
260
286
312
338
364
390
416
442
468
494

average
depth
26.9
31.6
30.3
34.8
37.6
41.1
39.3
41.6
46.3
43.4
41.8
48.5
48.1
50.7
48.2
50.8

approx.
treewidth
13
16
17
21
24
26
29
32
34
36
39
43
45
48
51
51

abstraction
size
26
31
38
45
51
59
66
71
79
82
90
97
104
112
116
123

total
clones
32
42
69
68
84
108
128
158
172
177
194
218
194
243
265
272

abstraction size
cloning
17
20
24
28
32
38
41
42
48
49
57
61
65
72
70
78

Table 8: Randomly generated combinational circuits (N, 25, 5).

subgraphs associated hypothetical values mc. figure shows
minimum-cardinality every node (mc) less equal bound (k) except
branch labeled , gets pruned accordingly.

Appendix C. Randomly Generated Combinational Circuits
section use novel method systematically generate series combinational
circuits structure size controlled. enables evaluation
techniques circuits ISCAS-85 benchmarks, helped us identify
factors affect diagnostic cost, leading us cost estimation function given
Section 6. Specifically, observe circuits similar structure, diagnostic cost
generally increases circuit size, helped us devise notion isolation cost;
360

fiSequential Diagnosis Abstraction

circuit size held constant, diagnostic cost generally increases number
cones circuit, helped us devise notion abstraction cost.
circuits generated composing set pre-formed building blocks. latter
consist gates cones. gates taken pool six gates types OR,
NOR, AND, NAND, NOT, BUFFER, cones pool eight cones,
10 gates extracted ISCAS-85 benchmark circuits.
composition method inspired method generating random Bayesian
networks described Marinescu, Kask, Dechter (2003). circuits generated
according formula (N, P, I), N number components (building blocks)
use, P percentage cones components, maximum number inputs
gate have. generate N components randomly pick (P/100) N cones (with
repetition) pool cones N (P/100) N gates (with repetition)
pool gates place random order. number inputs gate set
randomly 2 I, except BUFFER gate one
input.
process component follows: Suppose components placed
order C1 , C2 , . . . , CN . Let Pi set components precede Ci
order. process component Ci connect every input Ci output
randomly chosen component Pi two inputs Ci connected
component. input Ci cannot connected (either Pi empty
components Pi used) treated primary input circuit.
example, circuit Figure 8 randomly generated according formula
(8, 25, 2), components shown boxes represent cones.
varying parameters (N, P, I) obtain circuits varying size structure.
First fix P = 25, = 5 vary N generate range circuits increasing size.
N generate 10 circuits. circuits summarized Table 8. numbers
columns averaged circuits given size, rounded off. Generally,
N increased see increase abstraction size well estimated treewidth,
corresponding increase perceived difficulty circuit (e.g., note
largest circuit set smaller c1355, estimated treewidth c1355 much
lower, 25; actual compilation indeed harder former circuit).
circuit randomly generate 10 single-fault, 10 double-fault, 10 five-fault scenarios
single test case scenario.
results experiments circuits given Tables 9, 10, 11, using
baseline, hierarchical, cloning techniques, respectively. results generally
consistent obtained using ISCAS-85 circuits. baseline sda could
solve circuit beyond (72, 25, 5). hierarchical sda solved circuits could
solve circuit beyond (80, 25, 5). scalable version sda, component
cloning, solved much larger circuits, (168, 25, 5).
Note general trend increase diagnostic cost increase N .
consistent ones intuitive expectation diagnostic uncertainty would increase
system size. note diagnostic cost often significantly higher hierarchical
approach baseline approach. discussed earlier, attributed
fact hierarchical approach often go hierarchies cones reach
faulty gate, baseline approach may able reach directly.
361

fiSiddiqi & Huang

total
single-fault
double-fault
five-fault
pruning
gates
solved cost time solved cost time solved cost
time
32 104

100 5.86 0.56
100 6.34 0.57
100
9.19
0.60
yes
100 4.81 0.54
100 5.24 0.55
100
8.22
0.59
40 130

100 5.82 4.31
100 7.05 4.51
100 11.53 5.09
yes
100
4.5
4.16
100 5.08 4.28
100 10.35 4.93
48 156

100 6.58 32.43
100 8.72 32.75
100 11.19 34.87
yes
100 4.73 31.27
100
5.9 31.14
100
9.46 33.84
56 182

80
5.26 190.99
80
6.9 192.69
80
11.05 202.4
yes
80
3.58 185.32
80
5.62 190.25
80
8.325 197.05
64 208

50
5.58 532.82
50
6.9 540.31
50
13.94 581.11
yes
50
5.02 527.24
50
4.72 525.02
50
9.84 558.79
72 234

10
6.2 207.89
10
9.5 230.72
10
27.5 354.80
yes
10
6.2 207.49
10
5.8 205.41
10
11.4 248.20
N

Table 9: Baseline heuristic randomly generated circuits (N, 25, 5).
total
single-fault
double-fault
five-fault
pruning
gates
solved cost time solved cost time solved cost
time
32 104

100 7.81 0.15
100 8.78 0.16
100 12.59 0.18
yes
100 3.42 0.15
100 5.87 0.16
100 11.88 0.17
40 130

100
7.2
0.71
100 8.19 0.72
100 13.77 0.75
yes
100 3.07 0.70
100 5.18 0.71
100 12.94 0.73
48 156

100 7.03 4.10
100 8.12 4.14
100 12.78 4.26
yes
100 3.18 4.01
100 4.96 4.02
100 11.51 4.08
56 182

100 7.81 42.63
100
9.1 43.58
100 11.92 43.64
yes
100 2.98 41.60
100 6.31 42.23
100
11.1 42.19
64 208

80
8.35 108.61
80
9.11 107.96
80
14.85 111.04
yes
80
3.31 107.05
80
5.35 106.31
80
13.56 107.71
72 234

30
7.56 120.59
30
9.83 122.50
30
12.66 123.81
yes
30
2.8 118.35
30
5.53 118.57
30
11.2 119.93
80 260

10
6.9 190.66
10
9.2 193.58
10
12.4 197.29
yes
10
2.8 188.95
10
4.6 189.73
10
10.5 190.07
N

Table 10: Hierarchical heuristic randomly generated circuits (N, 25, 5).
observe that, again, pruning leads general improvement diagnostic cost.
improvement significant hierarchical approach, explained
fact effect pruning much greater abstract model, branch
pruned correspond large part original system.
perform another set experiments study impact hierarchy
controlled manner. time hold size circuits less constant
vary percentage cones them. Specifically, generate large number random
circuits P ranging 0 50, value P generated circuits
contain 120 gates average.
experiments circuits summarized Table 12. Note P increases
estimated treewidth circuits decreases, would expected, actual
compilation time indeed decreases. diagnostic cost, hand, increases
steadily P = 25 remains less flat afterwards. confirms potential
362

fiSequential Diagnosis Abstraction

N
32
40
48
56
64
72
80
88
96
104
112
120
128
136
144
152
160
168

total
single-fault
double-fault
five-fault
gates solved cost
time solved cost
time solved cost
time
104
100
7.86
0.04
100
8.78
0.05
100 12.13 0.06
130
100
8.12
0.05
100
9.6
0.06
100 13.58 0.08
156
100
8.25
0.07
100
9.34
0.08
100
12.6
0.10
182
100
9.03
0.12
100
10.4
0.13
100 13.37 0.15
208
100 10.06 0.45
100 10.73 0.46
100 15.41 0.49
234
100
9.15
0.78
100 11.38 0.80
100 15.44 0.84
260
100
9.78
0.83
100 11.38 0.85
100
15.5
0.89
286
100
9.56
0.78
100 10.87 0.79
100
16.6
0.84
312
100
10.4
1.85
100 10.81 1.87
100 17.87 1.97
338
100 10.03 4.23
100 11.79 4.26
100 16.95 4.34
364
100 10.44 29.20
100 11.76 29.39
100 17.62 29.93
390
100 10.36 39.88
100
13.6 40.15
100 20.76 41.17
416
90
11.17 98.70
90
13.73 99.08
90
19.33 100.73
442
90
11.82 220.41
90
13.76 221.63
89
20.25 225.58
468
80
12.08 207.69
80
15.05 207.68
80
19.92 210.86
494
40
12.7 256.43
40
14.72 257.5
40
23.02 260.41
520
40
12.5 476.93
40
14.15 479.33
40
18.5 479.83
546
10
8.7
84.16
10
10.1 84.44
10
15.1 85.27

Table 11: Component cloning randomly generated circuits (N, 25, 5).
P
0
5
10
15
20
25
50

total
single-fault
treewidth
circuits
cost time
1000
32
5.7
8.8
600
23
6.7
0.9
900
21
7.5
0.5
1000
18
7.7
0.1
1100
17
8.0
0.1
1300
15
9.2
0.1
800
12
8.6
0.06

double-fault
cost
time
7.7
8.8
8.0
0.9
8.7
0.5
9.1
0.1
9.4
0.1
10.3
0.1
10.0
0.07

five-fault
cost time
13.5 9.0
13.0 0.9
13.2 0.5
12.2 0.1
12.3 0.1
13.6 0.1
12.4 0.1

Table 12: Component cloning randomly generated circuits (N ,P ,5).
negative impact hierarchy diagnostic cost hypothesized: P increases
likelihood fault occurring inside cone increases thus average one
take measurements, many inputs cones, locate fault. diagnostic cost
increase P = 25 consistent observation since
circuit size fixed roughly 120 cone contributes 10 gates circuit,
P increases point, gates lying outside cones hence
likelihood fault occurring cone less plateaued.

References
Brglez, F., & Fujiwara, H. (1985). neutral netlist 10 combinational benchmark circuits target translator Fortran. Proceedings IEEE International
Symposium Circuits Systems (ISCAS), pp. 695698.
Chittaro, L., & Ranon, R. (2004). Hierarchical model-based diagnosis based structural
abstraction. Artificial Intelligence, 155 (1-2), 147182.
363

fiSiddiqi & Huang

Choi, A., Chavira, M., & Darwiche, A. (2007). Node splitting: scheme generating upper bounds Bayesian networks. Proceedings 23rd Conference
Uncertainty Artificial Intelligence (UAI), pp. 5766.
Darwiche, A., & Marquis, P. (2002). knowledge compilation map. Journal Artificial
Intelligence Research, 17, 229264.
Darwiche, A. (2001). Decomposable negation normal form. Journal ACM, 48 (4),
608647.
Darwiche, A. (2003). differential approach inference Bayesian networks. Journal
ACM, 50 (3), 280305.
Darwiche, A. (2004). New advances compiling CNF decomposable negation normal form. Proceedings 16th European Conference Artificial Intelligence
(ECAI), pp. 328332.
Darwiche, A. (2005). c2d compiler user manual. Tech. rep. D-147, Computer Science
Department, UCLA. http://reasoning.cs.ucla.edu/c2d/.
de Kleer, J., & Williams, B. C. (1987). Diagnosing multiple faults. Artificial Intelligence,
32 (1), 97130.
de Kleer, J. (1992). Focusing probable diagnosis. Readings model-based diagnosis,
pp. 131137. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.
de Kleer, J. (2006). Improving probability estimates lower diagnostic costs. 17th
International Workshop Principles Diagnosis (DX).
de Kleer, J., Raiman, O., & Shirley, M. (1992). One step lookahead pretty good.
Readings model-based diagnosis, pp. 138142. Morgan Kaufmann Publishers Inc.,
San Francisco, CA, USA.
Feldman, A., & van Gemund, A. (2006). two-step hierarchical algorithm modelbased diagnosis. Proceedings 21st AAAI Conference Artificial Intelligence
(AAAI), pp. 827833.
Feldman, A., Provan, G. M., & van Gemund, A. J. C. (2009). FRACTAL: Efficient fault
isolation using active testing. Proceedings 21st International Joint Conference
Artificial Intelligence (IJCAI), pp. 778784.
Flesch, I., Lucas, P., & van der Weide, T. (2007). Conflict-based diagnosis: Adding uncertainty model-based diagnosis. Proceedings 20th International Joint
Conference Artificial Intelligence (IJCAI), pp. 380385.
Forbus, K. D., & de Kleer, J. (1993). Building problem solvers. MIT Press, Cambridge,
MA, USA.
Hansen, M. C., Yalcin, H., & Hayes, J. P. (1999). Unveiling ISCAS-85 benchmarks:
case study reverse engineering. IEEE Design Test Computers, 16 (3), 7280.
364

fiSequential Diagnosis Abstraction

Heckerman, D., Breese, J. S., & Rommelse, K. (1995). Decision-theoretic troubleshooting.
Communications ACM, 38 (3), 4957.
Jensen, F. V. (2001). Bayesian networks decision graphs. Springer-Verlag New York,
Inc., Secaucus, NJ, USA.
Kirkland, T., & Mercer, M. R. (1987). topological search algorithm ATPG.
Proceedings 24th Conference Design Automation (DAC), pp. 502508.
Marinescu, R., Kask, K., & Dechter, R. (2003). Systematic vs. non-systematic algorithms
solving MPE task. Proceedings 19th Conference Uncertainty
Artificial Intelligence (UAI), pp. 394402.
Out, D.-J., van Rikxoort, R., & Bakker, R. (1994). construction hierarchic models.
Annals Mathematics Artificial Intelligence, 11 (1-4), 283296.
Pearl, J. (1988). Probabilistic reasoning intelligent systems: Networks plausible inference. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.
Pipatsrisawat, K., & Darwiche, A. (2007). Clone: Solving weighted Max-SAT reduced
search space. Proceedings 20th Australian Joint Conference Artificial
Intelligence (AI), pp. 223233.
Siddiqi, S., & Huang, J. (2007). Hierarchical diagnosis multiple faults. Proceedings
20th International Joint Conference Artificial Intelligence (IJCAI), pp. 581
586.
Siddiqi, S., & Huang, J. (2010). New advances sequential diagnosis. Proceedings
Twelfth International Conference Principles Knowledge Representation
Reasoning (KR), pp. 1725.
Torta, G., & Torasso, P. (2003). Automatic abstraction component-based diagnosis driven
system observability. Proceedings 18th International Joint Conference
Artificial Intelligence (IJCAI), pp. 394402.
Torta, G., & Torasso, P. (2008). symbolic approach component abstraction modelbased diagnosis. 19th International Workshop Principles Diagnosis (DX).

365


