journal artificial intelligence

submitted published

analyzing search topology without running search
connection causal graphs h
jorg hoffmann

joerg hoffmann inria fr

inria
nancy france

abstract
ignoring delete lists relaxation paramount importance satisficing
optimal earlier work observed optimal relaxation heuristic
h amazing qualities many classical benchmarks particular pertaining
complete absence local minima proofs hand made raising
question whether proofs lead automatically domain analysis techniques
contrast earlier disappointing analysis method exponential runtime
succeeds two extremely simple benchmark domains herein answer
question affirmative establish connections causal graph structure
h topology low order polynomial time analysis methods implemented
tool call torchlight domains absence local minima
proved torchlight gives strong success guarantees domains empirically analysis
exhibits strong performance domains plus domains
local minima may exist rare way torchlight distinguish easy domains
hard ones summarizing structural reasons analysis failure torchlight
provides diagnostic output indicating domain aspects may cause local minima

introduction
ignoring delete lists relaxation since decade still paramount
importance effective satisficing e g mcdermott bonet geffner
hoffmann nebel gerevini saetti serina helmert richter
westphal recently heuristics making relaxation shown
boost optimal karpas domshlak helmert domshlak
planners relaxation approximate variety ways optimal relaxation
heuristic h np hard compute bylander observed
earlier work hoffmann h rather amazing qualities many classical
benchmarks figure gives overview
divide domains classes along two dimensions herein ignore horizontal dimension pertaining dead ends domain analysis already available
easy test powerful criteria implying task undirected harmless known
e g hoffmann vertical dimension divides domains three classes
respect behavior exit distance defined distance state
strictly smaller h value easiest bottom class exist constant upper
omit adl domains add recent ipc benchmarks elevators transport without
action costs properties trivial prove earlier blocksworld arm
classical blocksworld blocksworld noarm variant allowing move b c directly
c

ai access foundation rights reserved

fihoffmann

pipesworldtank
pipesworldnotank
psr

rovers
opticaltelegraph

mystery
mprime
freecell
airport

hanoi
blocksworldnoarm
grid
transport
bench ed c

local minima ed c

blocksworldarm
depots
driverlog

elevators
logistics
ferry
gripper
undirected

tyreworld
satellite
zenotravel
miconicstrips
movie
simpletsp
harmless

diningphil

recognized

unrecognized

figure overview h topology hoffmann
bounds exit distance states local minima states benches flat regions figure bounds given square brackets example logistics
bound local minima meaning local minima exist bound
benches middle class bound exists local minima bound
local minima domains shown hardest top class local
minima benches may take arbitrarily many steps escape
proofs underlying figure hand made dealing unseen domains
question arises whether design domain analysis methods leading proofs
automatically potential uses analysis methods manifold discuss
end note addressing question formidable challenge
trying automatically infer properties characterizing informativeness lack
thereof heuristic function wish static analysis actually
running search formally characterizing informativeness heuristic function
cases hardly possible even experienced researchers explains perhaps
one far even attempted automatically single exception
best authors knowledge analysis method mentioned side
authors earlier work hoffmann analysis method builds exponentially
large tree structure summarizing ways relaxed plans may generate facts
tree size therewith analysis runtime explodes quickly task size worse
analysis succeeds movie simple tsp arguably two simplistic
benchmarks existence
contrast torchlight tool developed herein low order polynomial runtime
usually terminates split seconds distinguishing global per task local per
state analysis proves global absence local minima movie simple tsp logistics
miconic strips gives strong guarantee local analysis succeed every state
ferry gripper elevators transport taking success rate fraction
states local analysis succeeds torchlight empirically exhibits strong performance
delivering high success rates zenotravel satellite tyreworld grid driverlog
simple tsp encodes tsp fully connected graph uniform edge cost domain
introduced fox long benchmark symmetry detection



fianalyzing search topology without running search

rovers thus torchlights success rates tend high easy domains figure
low hard ones serving automatically distinguish two
groups summarizing structural reasons analysis failure torchlight finally provides
diagnostic output indicating problematic aspects domain e operator effects
potentially cause local minima h
key performance boost consider logistics blocksworld arm
level pddl domain descriptions difference evident
delete effects blocksworld arm hurt logistics dont
trick move finite domain variable representation e g jonsson
backstrom helmert consider associated structures notably
causal graph e g knoblock jonsson backstrom domshlak dinitz
helmert capturing precondition effect dependencies variables
causal graph blocksworld arm contains cycles logistics doesnt looking
surprisingly easy derive following basic
causal graph acyclic every variable transition invertible
local minima h
certainly interesting first time establishes connection
causal graph structure h topology however much
weak domain analysis considered benchmarks applies logistics devise generalizations approximations yielding analysis described
aside significance domain analysis techniques interesting
respect causal graphs whereas traditional methods e g jonsson
backstrom brafman domshlak jonsson gimenez jonsson
seek execution paths solving overall task seek execution paths decreasing
value h local analysis enables us consider small fragments causal
graph creating potential successfully analyze states tasks whose causal graphs
otherwise arbitrarily complex
next section gives brief background finite domain variables
associated notions causal graphs definition h topology section gives illustrative example explaining basic section provides
synopsis full technical relating causal graphs h topology sections
present detail explaining first analyze state
provided given optimal relaxed plan input thereafter providing
criteria causal graph structure implying analysis succeed evaluate domain analysis technique proving number domain specific performance
guarantees section reporting large scale experiment torchlight section point related work within context appropriate discuss details
section close discussion future work section improve
readability main text omits many technical details outlines proofs
full details including proofs appendix
extent particular achieved simpler means limited search probing
discuss along experiments section



fihoffmann

background
adopt terminology notation helmert number modifications
suiting purposes finite domain variable task tuple x si sg x
finite set variables x x associated finite domain dx partial
state x function subset xs x x dx x xs state
xs x initial state si state goal sg partial state finite set
operators pair preo eff partial states called precondition
effect simple non restricting sanity conditions assume dx x x
preo x eff x x xpreo xeff
identify partial states sets variable value pairs often refer
facts state space task directed graph whose vertices states
x arc iff exists preo eff x x
x x xeff plan path leading si state sg
next define two basic structures analysis domain transition graphs
causal graphs former diverge helmerts definition
introduce additional notations indicating operator responsible transition well
side effects transition e variable values set executing
responsible operator detail let x x domain transition graph dt gx x
labeled directed graph vertex set dx following arcs
x xpreo xeff c preo x c eff x dt gx contains arc c c labeled
responsible operator rop c c conditions cond c c preo x c
side effects seff c c eff x c x xeff xpreo
c eff x every c dx c c dt gx contains arc c c labeled
rop c c cond c c preo seff c c eff x c
reader familiar causal graphs may wondered introduced notion
side effects seeing causal graphs acyclic operators unary affect
single variable reason handle cases operators nonunary variant causal graphs use still acyclic cases indeed
happens benchmark domains specifically simple tsp movie miconicstrips satellite define support graph sg directed graph vertex
set x arc x iff dt gy relevant transition c c
x xcond c c


transition c c variable x called relevant iff x c sg oo preo
definition modifies commonly used one uses relevant transitions
introduce arcs variables co occurring operator
effect unless variables occur precondition transitions side effects
handled separately analysis note irrelevant transitions occur naturally
domains non unary operators example unstacking block induces irrelevant
transition making arm non empty departing passenger miconic strips makes
passenger boarded
consider definition h common boolean variable setting
pddl defined length shortest plan solving ignoring
remark relevant transitions correspond called requestable values
works e g jonsson backstrom haslum fast downwards implementation
causal graph includes precondition effect arcs similarly support graph defined



fianalyzing search topology without running search

delete lists e negative operator effects bylander mcdermott bonet
geffner raises question h actually finite domain variable
delete lists question easily answered ignoring
deletes essentially means act true remain true forever
finite domain variable setting simply means write values
variables previously knowledge generalization first described
helmert consider directed graph whose vertices sets variable

value pairs x arc
iff exists preo



eff state relaxed plan path leading
sg h denote length shortest relaxed plan
h plan exists easy see definition corresponds
common boolean one translate finite domain variables boolean ones
creating one boolean variable x c true every fact x c standard h
boolean task identical h finite domain variable task
bylander proved intractable compute h many state art
planners approximate h variety ways e g mcdermott bonet geffner
hoffmann nebel gerevini et al helmert richter helmert
westphal richter westphal popular approximation satisficing
gives guarantees quality relaxed plan returned
called relaxed plan heuristic first proposed system hoffmann nebel
approximates h terms length necessarily shortest relaxed plan
relaxed plans computed low order polynomial time techniques inspired
graphplan blum furst
next introduce relevant notations pertaining search space topology h
let state h exit state reachable
h h exists neighbor h h
thus h h exit distance ed length shortest path
exit ed exit exists path called monotone iff exist
two consecutive states h h say local
minimum exists monotone path exit
topology definitions adapted authors previous work hoffmann
specific h sake simplicity herein consider heuristics
h states infinite heuristic value ignored correctly
identified heuristic dead ends relaxed plan approximations
identify cases heuristic value already reached
goal case safely ignored note force exit paths
monotone e talk exit distances situations may
local minimum necessary capture structure domains satellite
zenotravel local minima exist exit distance bounded
analysis methods guarantee upper bound length exit path
heuristic values path decrease monotonically
remark original definitions significantly involved e g defining local minima
individual states strongly connected sub graphs state space none
complications relevant herein



fihoffmann

finally let us say words domain analysis generally speaking domain analysis
aims automatically obtaining non trivial information domain task
analysis long tradition e g nebel dimopoulos koehler
fox long gerevini schubert edelkamp helmert rintanen
often information sought pertains reachability relevance properties
e entities combinations thereof reachable initial state relevant
goal notable exception work long fox automatically
recognizes certain generic types domains transportation however exists
prior work trying automatically infer topological properties heuristic function
single exception aforementioned disappointing reported aside
authors previous work hoffmann method builds structure called
fact generation tree enumerating ways facts may support
non redundant relaxed plan conflict h exact solution distance
clearly far strong property applicable reasonably complex domain
considered benchmarks property applies simple tsp slightly
general property identified work applies movie well trivial logistics
tasks locations truck package
worth noting analyzing topology h computationally hard
theorem pspace complete decide whether state space given
task contains local minimum given integer k pspace complete
decide whether states ed k pspace complete
decide whether given state local minimum given integer k
pspace complete decide whether ed k
hardly surprising stated anywhere yet membership theorem easy prove guess check arguments similar
given bylander exploiting fact npspace pspace hardness still hold restricting input solvable tasks states proofs work
reducing plan existence respectively bounded plan existence bound non unary
representation given task whose plan existence wish decide flatten h
operator achieve goal fatal side effect give
planner choice solving task solving alternative task latter task designed local minimum exists exit distance exceeds bound
iff planner must choose alternative task e iff original task unsolvable iff
cannot solved within given number steps full proof appendix
practice computational hardness particularly challenging
applications domain analysis willing run worst case exponential search
analysis actually solve consequently present
restrict analysis methods low order polynomial runtime
reader noticed state specific analysis theorem
distinguish global analysis per task local analysis per state precisely
herein devise three kinds analyses
guaranteed global analysis taking input task description
analysis returns yes state space contain local minima
exit distance state bounded


fianalyzing search topology without running search

ii guaranteed local analysis taking input task description
state analysis returns yes local minimum exit
distance bounded
iii approximate local analysis taking input task description
state analysis returns yes indicate local minimum
exit distance bounded may wrong e analysis
guaranteed sound compared analysis ii trades soundness
ability successfully analyze states
domain analysis traditionally considers global variant even generalizing
variants looking pddl domain file global analysis
holy grail work local analysis strong advantages task
contain local minima one would expect typically case interesting
domains analysis useless simply answer contrast local analysis
ii iii may still detect individual states sample randomly experiments
local minima percentage states refer success rate
deliver useful information matter structure task note
contrast pspace hard low order polynomial
analysis runtime necessarily implies analyses incomplete local analyses
chance ameliorate averaging outcome set sample states

illustrative example
basic connection identify causal graphs h topology precisely
support graphs domain transition graphs h topology quite simple
instructive understand first delving full figure shows
fragments domain transition graphs dtgs three variables x x x
dtg transitions assumed invertible side effects


x
g




x

l

l

l

r

r

r

x
c

c



figure example illustrating basic
imaginative reader invited think x car whose battery currently
empty therefore requires help two people x x order push start
people may solve different parts task required purposes
consider sub achieving goal x g wish take


fihoffmann

x transition two conditions c c conditions currently
fulfilled state hand x x must move different
state x c x c happen h along way
say optimal relaxed plan p moves x c along path marked
moves x c along path marked clearly paths taken
p key observation similar phenomenon known transportation
benchmarks moving x x whichever state long remains
within boundaries values traversed construct relaxed plan
p p p namely obtain p simply replace


respective move sequence
p inverse
example say



got hr r r moving x c indicated figure wlog
p form hr r r p define p hl l l p postfix p
relaxed plans end prefix set values achieved x
namely c two values thus p relaxed

plan true general e
necessarily applicable achieve



within relaxed execution p set facts achieved
p thus
h h state including state
key observation pertains leaf variable x say x moves
sake e car position important goal executing
delete anything needed anywhere else thus remove rop
relaxed plan p constructed per observation obtain relaxed plan
state executing hence h h observation
heuristic values along path h know least one
state path heuristic value strictly smaller h happens
latest may happen earlier case relaxed plan p constructed
optimal cf footnote let earliest state h h
path let state preceding exit path
exit monotone thus local minimum exit distance worst
case ed bounded length path
difficult imagine works preconditions need
established recursively long cyclic dependencies exist third person may
needed first persuade x x third person may need take bus
length path may grow exponentially x depends x
move x may require several moves x forth still able
construct p inverting moves variables individually inverting
transitions may conditions provided conditions required
original moves example inverting operator l may
arbitrary condition p condition required r conditions
required original moves p r established p thus
established p time inverse moves l
note p may optimal relaxed plan p move x anything
attaining c postfix p alone relaxed plan need insert
inverted prefix hl l l cases obtain exit state already path get
back



fianalyzing search topology without running search

say support graph acyclic transitions invertible
side effects given state unless already goal state variable x
moving sake necessarily exists within optimal relaxed plan
situation exists therefore monotone exit path q e
local minima h
execution path construction discussed different known
exploiting causal graph acyclicity notions connectedness invertibility domain
transition graphs e g jonsson backstrom williams nayak
connection h
remark hand made analysis h hoffmann uses notion operators respected relaxation operator respected relaxation iff
whenever starts optimal plan starts optimal relaxed plan
core property many hand made proofs operators respected
relaxation motivated speculation recognizing property automatically
could key domain analysis recognizing absence local minima h
explore option herein however note even basic outlined
contains cases covered property even acyclic support graph invertible
transitions without side effects examples operator respected
relaxation give construction example appendix

synopsis technical
technical follows structured way similar proof argument
outlined previous section structured two parts b
section identify circumstances deduce optimal
relaxed plan monotone exit path exists b section devise support graph
sufficient criteria implying analysis succeed technique b
underlies torchlights conservative analysis methods e guaranteed global analysis
guaranteed local analysis ii described end section feeding technique
usual relaxed plans computed e g ffs heuristic function obtain
torchlights approximate local analysis iii analysis give guarantee
ffs relaxed plans guaranteed optimal
ease reading give brief synopsis obtained
b provide analysis methods iii synopsis contains sufficient
information understand rest reader may choose skip sections
moving directly evaluation
analysis method particular kind sub graph support graph
table overviews role parts b follows
given optimal relaxed plan p state optimal rplan dependency graph
odg sub graph sg single leaf variable x transition
example rop frequently referred arc x x odg
p relies x achieve conditions p relies x moving x
say odg successful acyclic involved transitions usable
exit path construction e g harmful side effects deletes


fihoffmann

name
support graph

symbol
sg

analysis

approximate
local analysis iii
theorem

optimal rplan
dependency graph

odg

local
dependency graph

ldg

guaranteed
local analysis ii
theorem

global
dependency graph

gdg

guaranteed
global analysis
theorem

leaves

single leaf x applying
affect
remainder p
single leaf x xsg
x sg x x
transitive sg successor
property
single leaf x xsg

arcs

x x x used
p support x
obtaining cond
x x
x cond x
x x x ldg
x x sg
x x x x
x x x gdg
x x sg

table overview different support graph sub graphs underlying
relevant p recovered inside p main
theorem states local minimum exists successful odg
derives exit distance bound odg approximating theorem
applying relaxed plan computed ffs heuristic yields analysis iii
b given state local dependency graph ldg sub graph sg single leaf
variable x whose goal value yet unachieved whose transitive successors
sg already attained goal values setting x moves
sake example graph ldg simply includes sg predecessors x
single exception pertaining arcs x x x inserted
corresponding condition already satisfied say ldg successful
acyclic involved transitions usable exit path construction
relevant deletes implies exists successful odg
contained ldg thus theorem stating local minimum
giving corresponding exit distance bound underlies analysis ii
global dependency graph gdg sub graph sg identifies goal variable
x includes sg predecessors x successful defined
way ldgs gdgs successful theorem apply every state
ldg contained successful gdg thus theorem stating
state space contain local minima exit distance bound
obtained maximizing gdgs underlies analysis
understanding practical performance torchlight important note
minimal would suffice prove b cases identified
theorem much richer actually infer support graphs
reason analysis iii sound due use potentially non optimal relaxed
plans able analyze much larger class states analysis ii little detail
difference two methods pertains whether p relies values
x moving x whether deletes recovered inside p
neither visible support graph rely details
form relaxed plan p example consider gripper domain notion
important support graph contains arcs carry ball b free gripper
due dropping ball b free gripper carry ball b due picking ball b
thus looking sg seems carry ball b may support free gripper


fianalyzing search topology without running search

dropping ball want pick course doesnt happen optimal
relaxed plan notion important operators picking ball
harmful side effects making gripper hand non empty side effects
recovered inside relaxed plan dropping ball later remains future
work extend analyses ii detect kinds phenomenona

analyzing optimal relaxed plans
consider state optimal relaxed plan p describe circumstances
monotone exit path guaranteed exist need number notations
pertaining properties transitions etc introduce notations along way
rather front hope makes easier digest


given p p
p
denote parts p front

behind respectively p x denote sub sequence p affecting
x capture dependencies variables used p achieving
precondition follows
definition let x si sg task let h let
p optimal relaxed plan let x x let p operator
taking relevant transition form x c
optimal rplan dependency graph p x optimal rplan dependency
graph p brief graph odg v unique leaf vertex x
x v x x x x x xpreo preo x x x x


taking relevant transition x x xpreo
v x exists p
preo x x
x v x odt g
x denote sub graph dt gx includes

x relevant transitions operator
values true point p

p x least one relevant inverse relevant inverse exists

x transitions original inverse transitions induced
refer p
transition responsible operator candidate reaching
exit state figure odg collects variables x connected variable x

insofar p
uses operator preconditioned x order move x
variables need move x x figure obtain state
taken variable x odt g
x captures domain transition graph fragment

p
traverses within stay figure

note need consider operators p
behind simply
operators used order establish precondition paramount
importance practice example gripper situation mentioned picks

ball b gripper p contain behind e p




operator dropping b considered definition odg would contain
mentioned cycle assuming used making gripper hand free picking b
torchlights approximate local analysis whenever consider operator
build odg order p moving operators behind possible minimizes

p
odg thus indeed contains necessary variables arcs


fihoffmann

circumstances actually job sufficient criterion
identify rather complex provide overview criterion next state definition items definition explained
definition let x si sg p x odg v definition say odg successful following holds
odg acyclic


odg relevant deletes p
recoverable

b x odg relevant replaceable side effect deletes
c x odg relevant recoverable side effect deletes

x v x odt g
x transitions self irrelevant deletes
invertible induced irrelevant side effect deletes side effects v x
already outlined exit path construction works staying within ranges
odt g
x x v x reached state transition
taken make little precise consider topological order xk x v x
respect odg order exists due definition condition
cycles moving variable may involve moving first place
covered exit path construction consider k abstracted
task original task except every transition one graphs
odt g
xi remove condition xj c cond j exit
path construction understood induction proving existence


execution path
whose end taken construct
exclusively


x

v

x



base case
operators responsible transitions odt g

x
abstracted task directly applicable inductive case constructed


suitable path
abstracted task suitable path

abstracted task constructed follows assume operator



precondition xd c true current state
front simply insert path odt g
xd ends c note
construction xd c condition transition odt g
xi


taken p
x xd c must achieved p
thus c node

odt g
xd induced transition inverting transition taken p x
case unless inverse may introduce outside conditions thus need
exclude case leading following definition invertibility
let c c transition variable x say invertible iff exists
transition c c dt gx cond c c cond c c
transition invertible go back without introducing conditions e g
driving trucks logistics subtle differences previous definitions invertible
operators authors hoffmann allow conditions even

actually established operator rop responsible

necessarily execute executing inverse may got endpoint
via different path odt g
x hand definition generous


fianalyzing search topology without running search

common ones per se care side effects inverse
transition may side effects constrained separately stated definition
consider definition condition apart constraints conditions induced


transitions odt g
x transitions taken must make sure
harmful side effects obviously case example section
transitions side effects however easily generalize condition let
c c transition variable x
context set ctx facts may deleted side effects
seff cond ctx condition defined else
dy values inserted

say irrelevant side effect deletes iff ctx sg oo preo

say self irrelevant side effect deletes iff ctx sg rop oo preo

say tshas self irrelevant deletes iff self irrelevant side effect deletes
x c sg rop oo preo
irrelevant side effect deletes capture case side effect delete occurs goal
precondition operator self irrelevant side effect deletes slightly
generous allow delete conditions needed responsible operator
rop self irrelevant deletes finally extend latter notion ts delete
nutshell need postulate irrelevant side effect deletes transitions may
executed path examples irrelevant side effect deletes transitions
side effects move simple tsp whose side effect x
deletes target locations visited example operator selfirrelevant side effect deletes irrelevant side effect deletes departing passenger
miconic strips whose side effect x served deletes boarded passenger
used purpose departure fact transition selfirrelevant deletes effect deletes served passenger obviously
irrelevant another example self irrelevant deletes inflating spare wheel tyreworld
wheel longer inflated


clearly odt g
x transitions may irrelevant side effect
deletes far invalidating facts needed elsewhere concerned
good side effects understand need require ts
side effect used move another variable x v x recall states

visited
construct relaxed plans p p p inverting
transitions say ts side effect used move another variable x v x
may invert transitions separately different operators thus
would p p
regarding delete may important two reasons first deleted
fact may needed relaxed plan second x may traverse odt g
x several
times thus may need traverse deleted value later covered
invertible earlier assumed transitions invertible
constitute case self irrelevant deletes case


fihoffmann

deletes irrelevant except maybe responsible operator therefore
obtain p simply remove rop relaxed plan constructed
predecessor state thus p p reached exit

need continue construction
example consider inflates spare wheel
w tyreworld deletes inflated w thus self irrelevant deletes
inflated w irrelevant goal operator say
state relaxed plan p constructed described p p
rop inflate w p inflate w p
inflate w executed yet path hence removed
relaxed plan applying inflate w get state identical except w
inflated clearly relaxed plan longer needs apply inflate w
rest relaxed plan p still works unchanged thus p obtained
removing inflate w p yielding p p desired
consider endpoint transition responsible operator previously
demanded x moves sake e x goal value
important achieving goal unnecessarily restrictive example
miconic strips board passenger h decreases remove
boarding operator relaxed plan however boarding means serving
passenger later variable x goal driverlog driver may
goal needed drive vehicles still moving driver
decreased h location moved away actually needed anymore latter
example immediately leads definition capturing first one want
deletes needed rest relaxed plan remove
relaxed plan reached exit desired
make precise recall situation addressing reached state
x c applied yielding state relaxed plan p
p p p constructed p replacing

operators responsible induced odt g
operators p
x transitions
x v x construct p removing p need p
relaxed plan facts possibly needed p safe approximation
union sg precondition p odt g
x values needed
denote set r values potentially deleted
induced odt g
transitions
x

contained c x x ctx thus r c
fine simple examples given already miconic strips
delete boarding passenger p boarded p contained
operator precondition goal thus intersection r c notboarded p empty driverlog c delete moving driver
away location location irrelevant rest task
r thus r c

sharpen consider set facts f op eff



true relaxed execution p
say p f p needed

understand latter two items note first operators preceding p e operators

p
may still contained p thus suffice include preconditions


operators p
odt g
x values needed induced odt gx transitions may needed


p p




fianalyzing search topology without running search

p relaxed plan see note first p needed part


p pertaining p
precisely p cannot operator precondition p


condition would satisfied relaxed execution p p
cannot start value induced odt g
x transition definition

values added operators p part p pertaining


p
assume p goal operator precondition p



since p f p relaxed plan operator p must establish

p effects true anyway p
remains unchanged

p thus part covered altogether thus suffices r c f
example helps satellite domain say switches instrument
deletes calibration e calibrated c purpose switching
take images thus calibrated r c however instrument
may actually calibrated need switch
calibrated calibration operator requires power
thus calibrated false relaxed execution p least
particular calibrated f thus r c f
even condition r c f still sharpened say exists




guaranteed applicable
possibly empty sub sequence
p



start p achieves facts r c f easy

define test moving
start p job say case


recoverable definition condition
odg relevant deletes p
example consider picks ball b gripper domain operator deletes
fact p free gripper may needed remainder relaxed plan thus


necessarily contain sub sequence
moves
p r c f however p



another room puts b order p put right
start achieving p similar patterns occur transportation domain capacity
constraints generally domains renewable resources
finally identified two simple alternative sufficient conditions
suitable definition conditions b c sake brevity sketch
require x e start value contained r
defined say case x odg relevant note
r c unless side effects side effects hurt replaceable side
effect deletes e operator whose precondition may deleted replaced
alternative operator applicable effect happens e g
simple tsp another possibility recoverable side effect deletes
exists operator necessarily applicable directly execution
recovers relevant side effect deletes happens quite frequently example rovers
taking rock soil sample fills store free store simply
emptying anywhere replace obtain relaxed plan p
thus h h apply yielding state h h
obtain relaxed plan removing p
length exit path one move x nonleaf variable x must provide value every move variable x
depending e x x value reached odt g
x
traversal denote maximum length traversal e diameter odt g
x


fihoffmann

may diam odt g diam dt g odt g
diam odt g
x
x
x
x
removes vertices arcs may short cuts traversed p
certain circumstances safe take short cuts namely

odt g
x transitions invertible induced irrelevant side effect deletes
side effects v x dt gx transitions irrelevant
empty conditions irrelevant side effect deletes
traversing short cut condition soon reach end shortcut back region states relaxed plan p constructed
rest exit path construction remains unaffected thus
denote v
p
subset v x holds define costd odg xv costd x
costd x





p

diam odt g
x
x x x cost x


min diam odt g diam dt g p
x

x

x x
x x x v
x x x cost

x

x x x v

note costd exponential depth graph artifact
length estimation easy construct examples exit distance exponential
parameter hinted variable may move several times
value required variables depending see example appendix
construction following earlier construction domshlak dinitz
said course costd may estimate length shortest exit path
assumes whenever variable x x x makes move x must move
entire odt g respectively dt g conservative may
move x actually condition x even condition exists
x may need less steps order reach one might able ameliorate making
fine grained distinctions part costd x pertains moves conditioned
x leave open future work note estimation
exponential even due e costd odg may exponentially larger
length shortest exit path even x x moves x depend x
shown simple variant example discuss appendix
exit paths short cuts described way may non monotone example
appendix contains construction showing intuitive understanding
imagine line l ln current task achieve precondition another
operator move l ln say locations line need visited
relaxed plan e g need load unload something locations
say shortcut via l needs visited move l h
increases made step costly relaxed plan reach
locations l ln reason costd odg upper bound length
shortest monotone exit path shown example construct
precisely diam diameter graph maximum distance vertex v vertex
v exists path v v



fianalyzing search topology without running search

situation shortest monotone exit path longer costd odg obtain
bound monotone exit paths simply set v definition costd
definition condition b exit distance bounded
costd odg costd odg counts last step reducing h
definition condition c last step need additional operator reduce
h exit distance bounded costd odg putting pieces together yields
main section
theorem let x si sg p odg definition odg successful local minimum ed costd odg definition
condition b ed costd odg
full proof appendix pointed earlier approximate local analysis
iii simply feed theorem relaxed plans returned ffs heuristic function
hoffmann nebel important note way give
guarantees e theorem hold p optimal even p
non redundant parallel optimal computed end exit
path may obtain relaxed plan shorter p shorter h
nutshell reason parallel optimal relaxed plan generally relaxed
plan minimizing number operators may take different decisions
sequentially optimal relaxed plan thus constructing exit path leading wrong
direction example appendix gives full construction proving
feeding theorem non optimal relaxed plans course imprecise
direction e theorem may apply although apply optimal
relaxed plan thus good cases may go unrecognized demonstrate simple
modification example explained example appendix importantly
point section empirical suggest weakness
tend occur practice least far represented benchmarks

conservative approximations
identify sufficient criteria guaranteeing prerequisites theorem hold
true consider local case particular state given global
case criterion implies prerequisites theorem every state task
hand approximate optimal rplan dependency graphs follows
definition let x si sg task let h let
x xsg let x c relevant transition dt gx rop
local dependency graph x local dependency graph brief
graph ldg v unique leaf vertex x x v x x
x x x xpreo preo x x x v x x x arc sg

global dependency graph x global dependency graph brief
graph gdg v unique leaf vertex x x v x x
x x x x xpreo x v x x x arc sg


remark due mentioned sources estimation costd constructing example
requires fairly awkward constructs appear likely occur practice



fihoffmann

optimal relaxed plan p contains odg per definition
sub graph ldg gdg defined simply optimal rplan
dependency graph arcs x x contained support graph task
previously indicated support graph may contain lot arcs actually necessary
sg captures may ever support else support else optimal
relaxed plan consider earlier point constructing odg take account
operators front p information contained sg thus
gripper get aforementioned cycle dropping ball support free gripper
picking ball
reader waded cumbersome details previous section
delighted hear defining ldg respectively gdg successful
involve additional notation
definition let x si sg x g ldg g gdg
definition say g v successful following hold
g acyclic
g ldg sg x x exists transitive successor x x
sg x xsg sg x x

self irrelevant side effect deletes
b replaceable side effect deletes
c recoverable side effect deletes
x v x dt gx transitions irrelevant self irrelevant
deletes invertible irrelevant side effect deletes side effects
v x
consider first local dependency graphs g ldg discuss g gdg
assume optimal relaxed plan p contains thus odg
sub graph ldg condition obviously implies definition condition
condition implies definition condition odt g
x contain
irrelevant transitions condition implies x odg relevant e x
needed rest relaxed plan simply un achieved
goal depends x condition implies definition condition
r c notation introduced previously conditions b definition
condition b respectively c definition condition c equivalent given
regarding exit distance know parts domain transition graphs
variables x v x traversed p obvious bound diam odt g
x
length maxpath dt gx longest non redundant path graph path
visiting vertex unfortunately cannot compute maxpath efficiently hamiltonian path garey johnson exists graph g v iff
gdg note preo x defined x thus x need recorded
predecessor



fianalyzing search topology without running search

maxpath g v thus corresponding decision np hard torchlight approximates maxpath g simply v however sometimes use
diam dt gx instead maxpath dt gx namely certain x one
variables v used definition costd odg certain
dt gx transitions irrelevant invertible empty
conditions irrelevant side effect deletes side effects v x
note strictly stronger requirement definition condition clearly
implies definition condition well condition sectionp denote v
subset v x holds define costd g xv costd x
costd x


x x



p


maxpath dt gx x x x cost x x x x v


diam dt g p
costd x
x x x v
x



x x x

x must move attain goal every optimal relaxed plan must take
least one transition leaving x thus theorem
theorem let x si sg task let state h
say x x every rop x c dt gx x c
relevant ldgo successful local dependency graph local minimum
ed maxo costd ldgo every ldgo definition condition
b ed maxo costd ldgo
theorem tool guaranteed local analysis ii guaranteed global analysis
simply look set global dependency graphs gdg requiring
successful particular gdg acyclic difficult deduce
non goal state variable x fulfilling definition x
apply theorem thus get
theorem let x si sg task say global dependency graphs
gdg successful contain local minima state
h ed maxgdg costd gdg every gdg definition
condition b ed maxgdg costd gdg
full proofs theorems appendix sg acyclic
transitions invertible side effects theorem applies whereby
particular proved basic vice versa note theorem applies
sg acyclic far local minima concerned one may thus reformulate theorem
simpler terms relying notion successful dependency graphs apart
allowing determine exit distance bound present formulation already paves
way future gdg defined relative concrete variable x operator
may thus allow accurate analysis variables may actually
become important x optimal relaxed plan
use diam dt gx instead maxpath dt gx costd variables
v rather significant effect quality bounds computed many


fihoffmann

benchmarks typical example transportation domain vehicle positions leaf
variables sg whose transitions side effects variables qualify v
maxpath dt gx instead would obtain exceedingly large bounds even trivial road
maps example consider logistics road map fully connected
diam dt gx thus costd delivers correct bound maxpath dt gx
instead get bound n n total number locations dt gx
note within scope theorem e class tasks
theorem applies plan existence tractable namely exists plan task iff
exists relaxed plan initial state starting optimal
relaxed plan guaranteed able construct exit path iterating argument
gets us goal view tractability weakness form global
analysis analysis apply intractable classes tasks contain
local minima note classes exist cf theorem hand plan
existence tractable known benchmark domains local minima absent
practice appear major limitation note plan construction
well optimal still intractable within scope theorem plan
construction intractable plans may exponentially long cf example
appendix optimal consider logistics miconic strips
see shortly proposition next section fully covered theorem
however deciding bounded plan existence np hard helmert
interestingly fact theorem therewith indirectly theorem rely
optimal relaxed plans source intractability plan construction theorem
applies non redundant relaxed plan p successful odg enabling us
construct path state particular relaxed plan although necessarily
optimal relaxed plan shortened iterating argument gives us constructive
method obtaining plan worst case exponential behavior lies
length individual path segments said course plan constructed
way may highly non optimal indeed shown example appendix
plan may exponentially longer optimal plan thus even theorem applies
need optimality guarantee running planner still makes sense
discuss relation scope theorem known tractable classes
section basic fact one construct local minima even small examples
involving two variables complying basic except
support graph cyclic example appendix non invertible transition
whose delete relevant example appendix transition
relevant side effect delete example appendix examples contained
many known tractable classes thus underlining automatic analysis h topology
identification tractable classes different although related enterprises

benchmark performance guarantees
state guarantees analyses iii give benchmark domains
underlying finite domain variable formalizations straightforward correspond


fianalyzing search topology without running search

formulations found automatically fast downward listed
appendix give proofs following two simple observations
four benchmark domains guaranteed global analysis succeed
proposition let x si sg task logistics miconic strips
movie simple tsp domain theorem applies bound delivered
respectively
follows trivially proposition guaranteed local analysis ii succeeds
domains well state one four listed domains theorem
applies bound delivered stated
note bounds logistics movie correct ones e tight
miconic strips estimation actual bound arises
analysis realize boarding passenger used leaf
variable x simple tsp correct bound since h exact goal distance
estimation arises every goal variable x visited location gdg
includes variable realizing value matter
location visited one
transportation benchmarks involving capacity constraints approximate local
analysis iii succeed provided suitable optimal relaxed plans
proposition let x si sg task elevators ferry gripper
transport domain let ferry gripper every optimal relaxed plan
p exists odg theorem applies bound elevators
transport exists least one p odg theorem applies
bound elevators road map diameter transport
relevant deletes cases due effects decreasing remaining vehicle capacity free gripper gripper domain decrease capacity
due load type operator matched unload type operator
later inside relaxed plan thus deletes recovered inside p
definition condition relaxed plans never use unload action
free capacity loading object thus odg cycle free hence
odg successful theorem applies elevators transport proposition
slightly weaker vehicle may capacity allowing forcing
relaxed plans use unloading operators recovering capacity actually present
note similar patterns likely occur domain renewable resources
recognized definition condition way
proposition hold theorems e ldgs gdgs due
two deficiencies cf discussion end section first sg contains cycles
unloading object order free capacity loading second definition
condition restrictive definition condition postulating deletes
entirely irrelevant way removing deficiencies
guaranteed analyses ii would succeed four domains proposition
say found automatically fast downwards translator deterministic e
may return different finite domain variable encodings even run several times
task encodings correspond domain formalizations elevators
give full definition without action costs merely variant transport



fihoffmann

experiments
report large scale experiment torchlight fill details torchlights implementation describe simple alternative analysis technique
search probing explain experiments set report runtime different
stages torchlight describe torchlights analysis per domain basis
assess quality analysis terms predictive capability finally summarize
outcome torchlights diagnosis facility benchmarks
torchlight
torchlight implemented c torchlight currently handles strips
e adl domains uses fast downwards translator helmert finitedomain variables establishing correspondence variables respectively
values ffs internally used ground facts mostly straightforward
details take care omit brevity
parsing fast downwards variables torchlight creates data structures representing support graph domain transition graphs enters phase refer
static analysis determines fixed properties every transition
whether irrelevant invertible etc next step guaranteed global analysis
checking preconditions theorem enumerating global dependency graphs
testing whether successful able report percentage successful gdgs
stop first unsuccessful one
local analysis techniques guaranteed local analysis ii theorem
approximate local analysis iii theorem run set ls states comprising
initial state well number r sample states obtained random walks starting
si set ls identical analyses run technique state
ls regardless outcome running respective technique
given analysis ii checks theorem constructing local dependency graph
every suitable variable x every transition leaving x non successful
stop considering x minimize exit distance bounds across different x
analysis iii checks theorem relaxed plan p computed ffs heuristic
function case relaxed plan exists analysis reports failure otherwise
analysis proceeds operators p start end variables
x affected pair x build optimal rplan dependency graph odg
per definition skip variables x eff x actually used precondition
goal rest p odg successful stop relaxed plans big
large examples continuing analysis exit bound minimization sometimes
costly mentioned section build odg order p moving
operators behind possible paramount importance avoids including
unnecessary variables odg ordering process straightforward starts
direct predecessor tests whether p still relaxed plan moving
directly behind yes arrangement kept iterate predecessor
forth easy see way odg contain exactly variables
source code torchlight online appendix available download
http www loria fr hoffmanj torchlight zip



fianalyzing search topology without running search

transitions used p achieve preo finally check whether odg
relevant deletes p
recoverable use simple technique allowing recognize
situations failure due one operator avoided replacing alternative
operator example transport loading operator reducing capacity level k
k p may still contain unloading operator relying level k thus level k
contained r c causing failure however unloading well
performed capacity level k removing difficulty catch cases
construction r whenever whose precondition overlaps c test
whether replace similar operator
local analyses return simple statistics namely minimum mean maximal
exit distance bound found well success rate e fraction sample states
guaranteed local analysis ii approximate local analysis iii succeeded analysis
iii success rates main focus turn informative
run r experiment length random walk
chosen uniformly hff si e times heuristic value
initial state play parameter important however
parameter chosen small domains many dead ends one may
things fatally wrong likely bad things happen
sufficiently large number random choices consequently dead end rate e
fraction sample states relaxed plan exists tends larger longer
random walks since analysis iii fails states relaxed plan exerts
important influence analysis iii success rates illustrate comparing
sampled states obtained initial states
search probing
approximate analysis sample states exists simple rather obvious alternative torchlights causal graph technology one use search determine
whether given sample state local minimum exit distance since
cannot compute h effectively search analysis necessarily approximate
straightforward method replace h relaxed plan approximation
herein replace h hff e ffs heuristic function precisely given state
run single iteration ffs enforced hill climbing e breadth first search
state better heuristic value search use helpful actions
pruning avoid huge search spaces unlike focus detection states
local minima allow monotone paths thus restricting search space states
hff hff refer technique search probing sp brief
experiment variant imposing second runtime cut search refer
limited search probing sp brief sp sp run set ls
states torchlights local analyses ii iii
turns empirically present benchmarks sp sp competitive torchlights analysis iii since analysis main focus experiments
relevant understand commonalities differences techniques
far analysis quality guarantees concerned techniques analysis iii
sp sp similar properties guarantees whatsoever may report


fihoffmann

success although local minimum false positives may fail although
local minimum false negatives cases false positives due use
non optimal relaxed plans hff instead h false negatives inherent analysis iii
covers certain special cases inherent sp due search
limit sp false negatives due helpful actions pruning however could
principle turned fundamental source false negatives non optimal
relaxed plans responsible lack connections across techniques
implication trivial one sp success state implies sp success
particular analysis iii correctly identifies local minimum
imply sp well causal graph analysis may less affected
irregularities hff surface happens example transport domain
ipc resulting higher success rates analysis iii
obvious important differences regarding runtime performance
danger false negatives sp runtime worst case exponential size
grounded input whereas analysis iii sp runtime low order polynomial
size sp decreasing number r sample states merely reduces chance hitting
bad state sample state large flat region whereas analysis iii sp scale
linearly r hand analysis iii sp buy efficiency
incompleteness e increased danger false negatives analysis iii simply recognizes
special cases sp effectively bounds lookahead depth e search depth
exit states detected
indicated sp sp turn competitive benchmarks large search
spaces rare sp success rates sp sp similar far predictive
capability concerned similarly informative analysis iii thus goodquality success rates obtained much simpler techniques torchlight
notwithstanding torchlight functions guaranteed analyses ii
well diagnosis cannot simulated b benchmarks ever
pertain examples torchlights analysis iii offers unlimited lookahead depth
low order polynomial cost appear matter much present benchmarks
natural cases matter get back
experiments set
run experiments set domains include domains investigated
hand made analysis h topology hoffmann shown figure
include domains international competitions ipc ipc
remaining domains strips versions domains ipc ipc
except ipc cyber security omit due parsing difficulties test
instances collected ipc collection applicable removing action cost
constructs ipc domains randomly generated elsewhere total
test set contains instances
particular search probing appears rather useful technique raising question
techniques yet used performance prediction purposes roberts howe
example use simple features get back conclusion
instances large ffs parser standard configuration tweaking bison allow
larger parse trees obtained segmentation fault even smallest instance ipc



fianalyzing search topology without running search

tool phase
fd translator
sg dtg
static analysis
analysis
sample states
analysis ii
analysis iii
torchlight total
torchlight iii
torchlight iii fd
sp
sp total
sp
sp total

lama

single shot r
mean
max

































r
mean
max























r
mean
max























r
mean
max























table summary runtime data mean max instances domains
empty fields respective tool phase single shot e depend r
dash means time seconds inserted runtime respective instance mean computation rows fd translator analysis
iii time different stages torchlight torchlight total overall runtime torchlight iii run analyses ii iii torchlight iii
fd latter disregarding translation costs sp determines success rate fraction sample states deemed local minima via search
probing e search around sample state sp imposes second time
searches sp total sp total include time generating
sample states
experiments run ghz cpu minute runtime gb
memory cut run different planners tools apart torchlight sp sp
include hoffmann nebel lama richter et al richter
westphal purpose running planners assess extent
torchlights output particular analysis iii success rate predict planner success
failure examine plain planner run version uses
goal ordering techniques runs enforced hill climbing without resorting
best first search fails refer planner ehc follows
runtime
code currently optimized much readability speed still torchlight
fast r bottleneck fast downwards translator r
actual analysis takes much time translator
instances respectively assess detail consider table
gives timing different stages torchlight planners tools
translation runtime sometimes hurts considerably peak seconds
costly instance scanalyzer domain rather exceptional however
second costly domain blocksworld noarm peak seconds


fihoffmann

domains costly instance translated less seconds
instances fast downwards translator takes second
static analysis peak behavior seconds scanalyzer even
exceptional instances static analysis takes second second
highest domain peak seconds pipesworld tankage similarly analysis
takes peak seconds blocksworld noarm instances
completes second domain blocksworld noarm
peak instance takes seconds airport peak seconds next
highest domain peaks pipesworld tankage scanalyzer logistics
woodworking domains analysis completes within second
turning focus local analyses see even effective particular concentrate mostly approximate local analysis iii see
r offer advantages r far information obtained
goes mostly concentrate r r analysis iii completes second instances respectively
r still holds instances peak runtime seconds
r occurs scanalyzer next highest domain peaks blocksworld noarm
pipesworld tankage ferry logistics blocksworld arm
optical telegraph airport domains analysis iii
r completes within second
bottleneck local analysis generation sample states costly
involves repeated computation applicable operators random
walks r peak seconds scanalyzer domain however
peak behavior exceptional r sampling completes
within second instances respectively
main competitor torchlight analysis iii success rates search probing e
sp sp consider moment analysis methods e row
analysis iii vs rows sp sp table compared sp analysis iii
consistently advantage except maximum runtime r difference
dramatic expected given sp trades completeness small
fixed maximum runtime compared complete search sp analysis iii consistently
significant advantage however r mean runtime sp tolerable
even maximum runtime bad bad runtime behavior exceptional
r sp completes second instances
respectively r respectively r domains even maximum
runtime second r sp two time outs blocksworld arm
r time outs blocksworld arm blocksworld noarm freecell
pipesworld notankage r maximum runtime seconds
domains r however r sp still completes
second instances respectively compared
analysis iii cf
neither analysis iii search probing stand alone methods former requires
torchlight except analyses ii latter requires sampling random states
respective total data given rows torchlight iii sp total sp total
table picture changes dramatically favor sp especially sp


fianalyzing search topology without running search

noted though mostly due overhead translation finite domain
variables overhead artifact implementation defined
finite domain variables benchmarks even though finite domain
representation cases natural boolean one many planners
notably fast downward quickly growing set derivatives use translation
anyway runtimes without translation given row torchlight iii fd
one would hope expect analysis methods much faster actual planners lama time outs test suite
analyzing domains
discuss actual analysis outcomes per domain basis first consider
torchlight give details comparison analysis iii success rates
obtained search probing begin words order regarding
comparison sp sp r success rates identical
benchmark instances respectively
instances success rates differ thus
small runtime cut adversely affect success rates search probing
long searches rare henceforth discuss data sp vs
sp separately compare torchlights analysis iii success rates sp
guarantees proposition confirmed e guaranteed global analysis succeeds described logistics miconic strips movie simple tsp never succeeds
domain though domains fractions gdgs successful precisely maximum fraction successful gdgs satellite ferry
tpp driverlog depots tyreworld blocksworldarm however fraction nothing proved data may
best used give indication aspects domain good natured
guaranteed local analysis ii generally much applicable global analysis
thus concentrate approximate local analysis iii exclusively
proposition backed impressively even r analysis iii succeeds
every single sample state ferry gripper elevators transport indicates
strongly potentially sub optimal relaxed plans loss information
indeed analysis yields high success rates almost domains local minima
non present limited case domains thus torchlight
distinguish domains easy h topology hard ones consider figure
showing mean analysis iii success rates per domain r picture similar
r cf table
domains whose h topology known shown separately right hand
side figure domains see quite nicely harder domains tend
lower success rates particular easiest domains bottom class
success rates case zenotravel whereas hardest domains
top right corner around less latter domains extent
historically observation preceded proposition well h topology categorization elevators transport per figure hand made analyses motivated observing
torchlights analysis outcome



fihoffmann

pipestank
pipesnotank
psr

rovers
opttele

mystery
mprime
freecell
airport

hanoi
blocksnoarm
grid
transport
bench ed c

local minima ed c

blocksarm
depots
driverlog

elevators
logistics
ferry
gripper
undirected

woodwork
trucks
tpp
storage
sokoban
scanalyzer

tyreworld
dinphil
satellite
zenotravel
miconicstr
movie
simpletsp
harmless

recognized

pegsol
pathways
parcprinter
openstacks
unrecognized

figure overview torchlight domain analysis guaranteed global analysis
succeeds approximate local analysis iii succeeds
provided optimal relaxed plan numbers shown mean success rates per
domain approximate local analysis iii r e sampling
single state per domain instance
low success rates recognition dead ends ffs heuristic function
example random sampling make random vehicle moves consuming fuel
mystery mprime course chances end state fuel
scarce even relaxed plan exist anymore pronounced
airport sample states infinite heuristic values however capabilities
analysis go far beyond counting states recognized dead ends blocksworld arm
example dead ends still success rate clearly
indicating domain difficult topology
extent success rates even distinguish pipesworld tankage
pipesworld notankage mprime mystery mprime fuel transferred
locations relatively high success rate depots probably relates transportation aspects grid cases analysis strong enough recognize
reasons behind non existence local minima reasons quite complicated
hoffmann dining philosophers really favorable h topology
rather excessive bound due particular domain structure philosophers
behave strictly symmetrical ways hoffmann apart strong
outliers driverlog rovers hanoi blocksworld noarm hand made analysis torchlights driverlog rovers deep local
minima exist awkward situations dont tend arise ipc instances thus hand made analysis worst case nature pessimistic
opposite happens hanoi blocksworld noarm absence local
minima due rather idiosyncratic reasons example hanoi reason h
equal number discs yet goal position relaxation one
accomplish remaining goals one one regardless constraints entailed
positioning hanoi blocksworld noarm actually easy solve


fianalyzing search topology without running search

domain
airport
blocks arm
blocks noarm
depots
din phil
driverlog
elevators
ferry
freecell
grid
gripper
hanoi
logistics
miconic
movie
mprime
mystery
opt tele
pipes notank
pipes tank
psr
rovers
satellite
simple tsp
transport
tyreworld
zenotravel
openstacks
parc printer
pathways
peg sol
scanalyzer
sokoban
storage
tpp
trucks
woodworking

si
iii






































r
iii
sp


























































r
iii
sp






















































r
iii
sp




















































iii






































r
sp






































de






































table mean success rates per domain upper part domains whose h topology previously examined hand hoffmann trivial examine
lower part ipc domains case columns
si data analyzing initial state columns r
analyzing respective number sample states columns iii give data
approximate local analysis iii columns sp give data search probing
column de gives dead end rates r
sense practical perspective low success rates torchlights
analysis iii provide accurate picture
table gives complete account per domain averaged success rates data including
domains values r rates obtained initial states sp instead
torchlight serves answer three questions
important sample random states rather analyzing initial state
important sample many random states


fihoffmann

competitive analysis iii respect search analysis
answer question clear yes importantly pertains domains
dead ends cf brief discussion clear table domains
analyzing si tendency optimistic see consider entries
airport dining philosophers freecell mystery openstacks parc printer pathways
tpp trucks woodworking domains dead ends variety reasons
dead ends occur frequently initial state level occur frequently
random walks cf column de table interestingly domains notably
two pipesworlds opposite happens e success rates lower si
sample states clear us causes phenomenon
simply compare si column r column analysis iii
lot different domains
extent difference initial states sample states may due
way benchmarks designed often initial states every instance similar
certain ways package loaded yet etc hand seems quite natural
least offline initial state different states deeper
state space consider transportation card games example
answer question clear example compare r
r columns analysis iii difference greater
domains peak difference openstacks r vs
r average difference domains similarly comparing r
r columns sp domains difference greater
peak openstacks r vs r
average difference domains
answer question bit complicated look columns analysis
iii respectively sp r number domains difference larger
peak difference scanalyzer one
hand still means domains analysis get close
search average difference without actually running search
hand happens domains success rate sp
higher torchlight surprising basically means torchlights
analysis strong enough recognize states local minima
interestingly weakness turn unexpected advantage domains
question domains blocksworld arm depots mprime pipesworld tankage pipesworldnotankage psr scanalyzer sokoban contain deep local minima thus
domains would wish analysis return small success rates torchlight grants
wish much sp consider happens sp instead analysis
iii figure mystery psr sokoban change dramatic however
blocksworld arm marked average success rate instead putting almost
par simple topology domains bottom class similarly pipesworldtankage pipesworld notankage scanalyzer put almost par depots
sokoban unrecognized dead ends relaxation blocks pushed across
therefore local minima scanalyzer analyzing plants misplaces side effect bringing
back start position across large circle conveyor belts may take arbitrarily many steps
see figure domains



fianalyzing search topology without running search

actually receives putting exactly par thus sp analysis outcome
actually looks quite bit worse domains
causes undesirably high success rates sp authors best guess
many domains chance randomly finding state local minimum low
large scale experiments measuring statistics search space surface ffs heuristic
function hoffmann observed many sampled states local minima
contained valleys within valley monotonically
decreasing path goal state state may local minimum
one descend deeper valley seems sp correctly identifies
valley states local minima thus counting good many states actually
located difficult regions search space weakness sp success
rate search space feature weakness manifest much
analysis iii analysis picky takes good states
qualify particular special cases tend occur often difficult domains
course easy construct examples turning discussed strength real
weakness torchlights analysis quality seem happen lot
present benchmarks said present benchmarks arent well suited
bring theoretical advantage analysis iii analysis offers unlimited
lookahead depth low order polynomial cost however even r
domains highest exit distance bound returned e every exit path identified consists
single operator cases could handled much simpler variant analysis
iii looking operators directly applicable thus removing
entire machinery pertaining sg predecessors x still machinery matter
cases quite natural highest exit distance bound returned grid
transport generally transportation domain non trivial road map
easy construct relevant situations example say road map transport forms n
cities diameter least one vehicle distances cities large
relative typical state around n vehicle moves considered helpful
least per city since local vehicles preferred relaxed plan
successor states identical h package loaded unloaded typical
number steps required grow example vehicle
outskirts packages city center around steps required
finding exit takes runtime around n small values n already
render search probing devoid information runtime cut small
computationally infeasible recall probing quick pre process
actual contrast analysis iii easily delivers correct success rate
predicting planner performance
direct measure predictive quality success rates conducted preliminary
experiments examining behavior primitive classifiers runtime distributions
large vs small success rates consider first classifiers predict given
task whether ehc lama succeed solving task within given
note cannot use valley rate instead cheap domain analysis since determining whether
lies valley implies finding plan thus solving task side effect



fihoffmann

time memory limits classifiers answer yes iff success rate threshold
obviously need r consider follows
r r shown r costly
ehc torchlight analysis iii sp deliver fairly good quality predictions
considering actual machine learning involved prediction quality torchlight good sometimes slightly better search whether use
r r make big difference ehc solves instances
rate correct predictions trivial baseline classifier answering yes
r best rate correct predictions torchlight
sp r numbers
dead end rate bad predictor best prediction
baseline classifier second best classifier correct
interestingly major differences different sets domains
domains previously analyzed hand hoffmann figure without elevators
transport best prediction correct torchlight
correct sp vs baseline ipc domains
numbers vs baseline cases e
best classifier close baseline ipc hand appears
exceptionally good natured numbers vs
baseline clear us causes phenomena
summary quality prediction clearly baseline around
looking domains even looking ipc domains
comparison state art classification techniques simple features roberts howe get correctness vs baseline saying
unseen testing domains said setting considered
learning actually distinguish learning data
testing data roberts howes unseen testing domains ipc
different setting including adl test suites set
domains figure without elevators transport get
best prediction torchlight sp setting
prediction correctness ipc suite respectively vs
baseline hand seems pertain ipc specifically
ipc respectively good settings giving respectively
correctness vs baseline
importantly roberts howe predicting performance ehc
complex lama prediction quality
torchlight sp rather bleak described primitive classifiers cases
best prediction correctness obtained answering yes best
said success rate still predicts much better dead end rate give
example data r across domains baseline correct
goes torchlight sp dead end
rate lama baseline correct goes
bad prediction quality ipc domains might related fact fully grounded
potentially impeding ability fast downwards translator useful finite domain variables



fianalyzing search topology without running search

torchlight sp dead end rate lama
growing prediction quality decreases monotonically cases
prediction quality much worse ehc
main building block whereas ehc typically fails tasks whose h topology
favorable ffs lamas complete search able solve many
cases example torchlight success rates r ehc solves
tasks success rate solves less success rate
contrast lama solve respectively tasks success rate
solve least success rates
despite success rates far devoid information lama setting
threshold look distribution planner runtime instance
subset success rate vs instance subset b success rate
taking null hypothesis means two runtime distributions
run students test unequal sample sizes determine confidence
null hypothesis rejected determine confidence
distribution b lower mean distribution torchlights success rate
runtimes r r settings get confidence
least difference means data e mean runtime
minus mean runtime b tends grow peaks respectively
seconds r respectively r average difference values
respectively likewise lama runtimes settings r yield confidence
average differences respectively sp comparable
lama slightly worse though r confidence
confidence values difference peaks
seconds vs torchlight average seconds vs r
thresholds yield confidence average difference
perhaps little surprisingly simpler planner ehc runtime distributions behave differently torchlight success rates get several cases
confidence average differences around seconds sp cases
get confidence mean b larger reason
simple many tasks unfavorable h topology enforced hill climbing quickly exhausts space states reachable ffs helpful actions ehc gives solving
task although consumed little runtime peculiar behavior one would
certainly expect planner trying competitive
summing success rates task feature provide good coverage
predictor ehc even without significant learning lama things
easy however consideration runtime distributions clearly shows
feature highly informative exploiting informativeness predicting planner performance presumably requires combination features actual machine learning
techniques along lines roberts howe topic future
diagnosis
let us finally consider torchlights diagnosis facility idea behind facility
summarize reasons analysis failure testing sufficient criteria absence local


fihoffmann

minima diagnosis guaranteed identify domain features causing presence
still least analysis theorem diagnosis quite accurate
current diagnosis facility merely first shot implementation reporting
pairs operator variable x caused odg successful
report pair x effect x context fact x c transition
taken contained r c f recoverable sub sequence

p
brief record x harmful effect x perform test
whether main effect e x invertible case record
x since appear side effects avoid redundancies reporting
record grounded operator name action schema load
instead load package truck similarly option record x name
predicate underlying fact x c configuration diagnosis comes
form action name predicate name direct match high level pddl
input files measure parts diagnosis important
associate pair count occurrences weigh pairs frequency
zenotravel diagnosis output form fly fuel level zoom
fuel level indicating correctly fuel consumption causing local
minima mprime mystery cause local minima however
diagnosis reliable specific structure domain associating fuel
locations instead vehicles sometimes causes diagnosis conclude
effect changing locations causing trouble concretely r
mystery fuel consumption top weighted diagnosis tasks
mprime happens tasks satellite rovers diagnosis
takes form switch calibrated respectively take image calibrated thus
reporting switching instrument respectively taking image
deletes calibration precisely reason local minima exist
tyreworld often diagnosis reports jacking hub
longer jack needed elsewhere actually
cause local minima none indeed appears crucial aspect domain
similarly grid frequent diagnosis picking key arm
longer empty actually cause local minima critical resource
domain blocksworld arm dominant diagnoses block longer
clear stack something top hand longer empty picking
block similarly freecell dominant diagnoses send free cellspace
send col colspace
one could make list much longer however seems clear already
diagnosis facility although yet primitive potential identify interesting aspects
domain note making use one information sources
torchlight many things recorded pertaining reasons
analysis failure support graph cycles etc reasons analysis success
successful gdgs x pairs yielding successful odg appears promising try
improve diagnosis combining information sources combination
since analysis failure rare two domains often diagnosis give output
r output non empty instances satellite instances rovers r
reduces instances satellite single one rovers



fianalyzing search topology without running search

domain analysis techniques landmarks invariants extraction could
useful direction future work

related work
prior work aforementioned one author hoffmann
trying automatically infer topological properties heuristic function thus work
relate strongly domain analysis techniques closest relation
techniques relying causal graphs follows discuss detail along
connections arising context
local analysis succeeds construct path exit identified
work relates work macro actions e g botea muller schaeffer vidal
distinguishing feature macro action would constructed
targeted analytical way even giving guarantee conservative case make
progress towards goal machinery behind analysis causal graphs
shares similarities known causal graph execution path generation methods
e g jonsson backstrom williams nayak brafman domshlak
distinguishing feature focus h individual states rather
whole task allows us consider small fragments otherwise arbitrarily complex
tasks look odg instead sg note ability quite powerful
far applicability goes seen section success rate local
approximate analysis therewith fraction states would able
generate macro action non zero almost benchmark domains course
broad applicability comes prize traditional causal graph methods guarantee
reach goal worst case macro actions may lead h local minima still
may interesting look whether traditional causal graph methods
localized similar manner well
global analysis focus whole task thus whole causal
graph even closely related causal graphs tractability analysis
major difference tractability analysis h topology analysis principle
tractability absence local minima orthogonal properties general
neither one implies pointed end section global
analysis imply tractability plan existence vice versa restrictions made
known tractable classes imply absence local minima many cases answer
question definite interesting questions open single case
corresponding basic answer yes
example appendix shows one construct local minimum
variables domain size arc sg unary operators strongly connected dtgs
single non invertible transition example scaling extensions breaking
respective conditions falls variety known tractable classes example
particular fast downwards translator perfect detecting finite domain variables
underlying benchmarks example satellite often detect electricity available
exactly one instruments mounted satellite lead pointless diagnosis output
handled simple notion predicates exchanged every operator
things principled manner invariants analysis would useful



fihoffmann

tractable class f
n identified domshlak dinitz every transition
dependent variable depends variable example helmerts
sas class strongly connected dtgs example solved e reduced
empty task haslums simplification techniques techniques
solve tasks satellite domain contain local minima example
fork inverted fork causal graph bounded domain size dependent actions
actions prevail condition thus qualifies tractable classes
identified katz domshlak b examples causal graph chain
thus particular polytree bounded indegree corresponding tractable class
identified brafman domshlak except variables restricted
binary domain size open question whether plan existence chain causal
graphs domain size tractable strongest known np hard
domain size gimenez jonsson b similarly example fits prerequisites
stated katz domshlak except binary variables
open question whether local minima exist tractable classes identified
finally example suitable scaling extension obviously qualifies two theorems
stated chen gimenez theorem precisely first part
theorem requires constant bound size connected components
undirected graph induced causal graph first part theorem
requires constant bound size strongly connected components causal
graph pertains notion reversible tasks requiring go back
initial state
next consider line works restricting causal graph dtgs
task backstrom klein backstrom nebel jonsson backstrom
simplest class identified contained classes sas pubs
fact achieved one operator post unique p operators unary
u variables binary b variables one value required
condition transition variable single valued example
appendix shows local minimum example u properties
example two variables x local minimum arises cyclic
dependency prevents attaining goal value dn via shortest path taken
optimal relaxed plan remove two values domain remove
alternative way reaching dn example still contains local minimum
p b properties remark modified example unsolvable
remains open question whether solvable sas pubs tasks local minima exist
generally question open even larger sas pus class yet larger
sas iao class identified jonsson backstrom
another open question whether class jonsson backstrom
contains local minima class works binary variables requires unary operators
acyclic causal graphs however allows facts splitting instead reversible
p splitting intuitively task decomposed three independent subtasks respect p open question whether local minima constructed
although course clear dtgs strongly connected case deciding
plan existence tractable matter domain size
modification given detail example appendix



fianalyzing search topology without running search

satisfying property disallowing splitting option obtain single
positive case known tractable class contain local minima
class corresponds basic acyclic causal graphs invertible transitions
except variables restricted binary williams nayak mention
restrictions make formal claims regarding tractability corresponding exactly
basic except allow irreversible repair actions latter actions
defined relative specialized formal framework control systems spirit
similar term transitions self irrelevant deletes herein
finally easy see bylanders three tractability criteria two
allowing several effects imply absence local minima third criterion
restricting action effects single literal preconditions positive literals allowing
negative goals leave open question whether local minima exist
remark criterion apply benchmark aware
close section certainly wish claim identification
tractable classes contribution work note scope theorem
tractable class cf covered known tractable classes
tractable cases identified bylander obviously cover logistics
miconic strips movie simple tsp many causal graph tractability
require unary operators jonsson backstrom domshlak dinitz brafman domshlak helmert katz domshlak b jonsson
gimenez jonsson cover miconic strips movie
simple tsp work chen gimenez theorem requires reversibility given movie miconic strips simple tsp
theorem requires constant bound size connected components
undirected graph induced causal graph given none logistics miconicstrips simple tsp known tractability make different restrictions
dtgs backstrom klein backstrom nebel jonsson backstrom
even general tractable class identified sas iao covers none
miconic strips logistics simple tsp vehicle variables acyclic
respect requestable values neither cover movie rewinding
movie neither unary irreplaceable side effect un setting counter
breaking dtg counter two disjoint components
far coverage benchmarks goes strongest competitor theorem
haslums simplification techniques iteratively remove variables
paths relevant attaining required conditions free e traversed transitions neither conditions side effects haslums theorem states
removal done without jeopardizing solution existence e plan original
task reconstructed easily plan simplified task particular
task solved simplified completely empty task plan constructed
polynomial time haslum combines basic technique number domain reformulation techniques e g replacing action sequences macros certain conditions
choice combination techniques apply fully automated parts
true basic explained essentially covered works jonsson
backstrom williams nayak formally prerequisites imply
first part theorem work chen gimenez namely postulated bound



fihoffmann

techniques fully described making comparison theorem difficult
haslum reports techniques solve tasks logistics miconic strips movie
plus gripper satellite haslum experiment simple tsp theorem
stated form solve simple tsp transitions root
variable side effects irrelevant deletes extending theorem cover
irrelevant deletes straightforward subtle weakness haslums theorem relative theorem pertains reaching required values externally caused
values haslum requires moves free whereas definition recoverable
side effect deletes theorem allows recovering operators affect several variables
take precondition prevails effects

conclusion
identified connection causal graphs h devised tool allowing
analyze search space topology without actually running search tool yet
automatic hoffmann analysis quality impressive even compared
unlimited search probing
generic level conclusion work sometimes possible
automatically infer topological properties heuristic function interesting question
future work whether done heuristics h cf
comments regarding causal graph methodologically noteworthy
analysis syntactic restrictions description traditionally used identify tractable fragments computationally
hard present work showcases similar techniques apply
analysis search spaces general solvers
main open question whether global analysis tightly approximate scope
theorem indicated good starting point appears trying include gdg
operator variable dependencies induced operators may actually precede
optimal relaxed plan automatically recognizing operators could
possibly developed along lines hoffmann nebel b simplified
version aforementioned fact generation tree analysis technique hoffmann
additionally would great recognize situations harmful side effects
making hand non empty pick ball gripper necessarily
recovered inside relaxed plan possibly analysis could variant
action landmarks hoffmann porteous sebastia karpas domshlak
another interesting line start given individual states
local analysis extract reasons success generalize reasons
determine generic property success guaranteed taken extreme
might possible automatically identify domain sub classes e particular combinations
initial state goal state absence local minima proved
work highlights two aspects causal graph first shows
certain situations one localize causal graph analysis consider causal
graph fragment relevant solving particular state second one use causal graphs
constructing paths global goal state value heuristic h
decreased former enables analysis succeed tasks whose causal graphs


fianalyzing search topology without running search

otherwise arbitrarily complex thus potential greatly broaden scope
applicability latter necessarily limited h simple example
obvious similar constructions made trivial heuristic counting number
unsatisfied goals thus opens completely avenue causal graph
another possibility planner performance prediction along lines roberts
howe experimental indicate torchlights features
search probing highly informative potential significantly
improve roberts howe unseen domains currently use
simple features counts predicates action schemes hardly capture domainindependent structure relevant planner performance limited search probing sp
torchlight generates features without jeopardizing runtime thus enabling automatic
planner configuration unlike search probing may even work line search
single relaxed plan already deliver interesting information example one might
make search less greedy choosing different search strategy switching helpful
actions etc depending outcome checking theorem
mentioned section direction worth trying use local analysis generating
macro actions domains high success rate seems likely macro actions
would lead goal search priori clear though whether
would significantly strengthen least present benchmarks existing
techniques executing parts relaxed plan e g vidal
one could use torchlights diagnosis facility basis abstraction technique
deriving search guidance much currently done relaxation abstraction
techniques diagnosis pin point operator effects causing
search remove enough harmful effects end task theorem
applies abstracted tractable example transportation domains
process could abstract away fuel consumption abstract much
information provided may still outweigh effort abstract e
actual planner inside heuristic function example grid abstract task
could variant allowing carry several keys one could focus
construction different heuristics ignoring deletes harmful effects
finally interesting line domain reformulation well known
domain formulation make huge difference planner performance however
difficult choose good formulation given planner black art even
reformulation done developer planner question lack guidance
one main open identified haslum automatic reformulation
frequent question author asked non expert users
model domain handle easily
torchlights diagnosis facility pin pointing problematic effects might instrumental
addressing difficulties case reformulation done computer
one possibility use analysis outcome could produce macro actions hiding
within operators harmful effects another possibility could precompose variable subsets touched harmful effects
case reformulation done human user sky limit
name one example local minima satellite could removed allowing
switch instrument pointing direction instrument


fihoffmann

calibrated generally note end user pddl modeling writing pddl
non expert user wanting solve shelf planners quite
different pddl modeling experts developing benchmarks
example expert transportation benchmark fuel consumption
may seem quite pointless torchlight determine fuel consumption hurt
planner performance indeed may reason fuel consumption included
first place contrast end user information may come surprise
b user may actually choose omit fuel consumption may yield
better point trade planner performance plan usability generally
speaking could give user guidance designing natural hierarchy
increasingly detailed increasingly problematic domain formulations could
help making technology accessible thus contribute challenge
taken much seriously community

acknowledgments
would thank anonymous reviewers article hand icaps
short version constructive comments particular one reviewers
proved completeness theorem another reviewer suggested future
line trying generalize reasons success local analysis
thank carmel domshlak discussions feedback early stages work contributing particular abstracted task construction proof lemma
executive summary status quo causal graph
special thanks goes carlos areces luciana benotti inspiring
work first place long ago given carlos
lucianas insistence finally made see connection causal graphs trying
convince analysis impossible

appendix technical details proofs
give full proofs needed fill technical definitions first
prove complexity appendix theorem pertaining
analysis optimal relaxed plans appendix theorem pertaining
conservative approximations appendix theorems construct number
examples relevant kinds analysis appendix giving proofs
domain specific performance guarantees appendix propositions
computational complexity
theorem pspace complete decide whether state space given
task contains local minimum given integer k pspace complete
decide whether states ed k pspace complete
decide whether given state local minimum given integer k
pspace complete decide whether ed k


fianalyzing search topology without running search

proof throughout proof since pspace closed complementation
distinguish mentioned pspace complete decision complements
membership easy prove note first given state
compute h within polynomial space generate potentially non optimal relaxed plan
length n known methods iteratively decrement n test value
whether relaxed plan length still exists stop test answers
test bounded relaxed plan existence np thus pspace
prove membership simple modifications guess check argument
showing plansat deciding whether given task solvable
npspace hence pspace bylander argument works
starting initial state guessing actions terminating successfully goal state
reached unsuccessful termination occurs guessed path longer trivial
upper bound b xx dx number different states able check
condition polynomial space path length maintained binary counter
decide whether given state local minimum run guess check
modified compute h encountered state terminate unsuccessfully bound b exceeded h increases operator application
terminate successfully h decreases operator application decide whether
ed k use except bound b replaced bound k
increases h permitted success occurs h decreases h h
decide whether state space entire task contains local minima whether
states state space ed k simply run bylanders guess check
way enumerating reachable states individual state
run modified guess check described clearly
run non deterministic polynomial space shows part claim
pspace hardness first consider deciding whether given state local minimum proof works reducing
plansat known pspace hard propositional strips bylander
trivially follows plansat pspace hard finitedomain variable tasks use herein
let x si sg task whose solvability wish decide design
modified task x g starting x si sg making following
modifications
add variable chooset ask x
chooset ask nil g chooset ask undefined

domain

nil org alt

role variable give planner choice whether solve
original task x si sg whether solve alternative task custom designed
proof
add variable distalt x domain distalt
g distalt
variable simply serves control length solution alternative task
solution length plus number steps needed bring distalt


fihoffmann

value goal value step needed later
proof increase distance
add two operators oorg chooset ask nil chooset ask org
oalt chooset ask nil chooset ask alt distalt
implements choice task note choose alternative
task distalt set thus forcing solution bridge distance
contrast original task variable keeps residing goal value
already assigned distalt
add operator odistalt chooset ask alt distalt distalt
allows bridge distance intended solution alternative task
add operator osg alt chooset ask alt distalt sg
allows us accomplish original goal final step solving alternative task
add chooset ask org precondition original operators e
taken
forces planner choose original task executing operators
add variable stillalive x domain yes stillalive yes
sg stillalive yes add operator osg dead sg stillalive
osg dead operator allows us accomplish original goal single step
matter task chosen solve initial state already
however operator sets variable stillalive value whereas
goal value variable yes value cannot achieved thus
operator leads dead end function proof flatten value
h original task constantly unless goal state
extreme flattening happen alternative task
distance variable distalt needs handled
summary x g designed setting
x x chooset ask distalt stillalive
si chooset ask nil distalt stillalive yes
g sg distalt stillalive yes
pre chooset ask org eff pre eff oorg oalt odistalt osg alt
osg dead
consider initial state exactly three successor states sdead produced osg dead sorg produced oorg salt produced oalt h sdead
sdead stillalive h h sorg due relaxed


fianalyzing search topology without running search

plan hosg dead finally h salt oalt sets distalt variable
whereas goal thus shortest relaxed plan salt hodistalt osg alt
clearly follows local minimum iff sorg monotone
path state h h sorg since h sorg latter equivalent
existence monotone path sorg goal state e path goal state
h constantly since states reachable sorg single step sequence
hosg dead relaxed plan equivalent existence path sorg goal
state clearly latter equivalent solvability original task x si sg thus
local minimum iff x si sg solvable shows part claim
next prove pspace hardness deciding whether given task
contains local minimum follows easily observe alternative
task contain local minima described h salt apply
odistalt salt obtain state saltdist h saltdist relaxed
plan hosg alt applying osg alt saltdist yields goal state thus salt saltdist
better evaluated neighbors states descending salt must produced
osg dead thus h value x g contains local minimum iff
part state space descended sorg since states h value unless
goal states cf latter equivalent unsolvability x si sg
shows part claim
assume given integer k need decide individual state
whether ed k reduce bounded plansat deciding whether
given task solvable within given number steps bounded plansat
known pspace complete bound given non unary representation
modify task x g given way increases solution length
alternative task k introduce binary counter dlog k e binary
variables biti si introduce operator bit allowing set
bit lower bits already effect setting lower bits back
operator additional precondition chooset ask alt
effect modifying bits modify operator odistalt adding
preconditions encoding counter position k construction clearly h salt
distance goal salt k plan count k apply odistalt
apply osg alt thus shortest exit path si via oalt length k
ed si k iff x si sg plan length k
concludes part claim
finally say need decide whether ed k note
first salt successors necessarily exit distance k goal
reached many steps exit distance sorg successors
equal length shortest plan corresponding state x si sg
latter length may states x si sg longer k even shortest
plan x si sg e original initial state length k thus introduce
another binary counter time counting k conditioned chooset ask org
operator whose precondition demands counter k
achieves goals clearly sorg descendants exit distance
k thus state may exit distance greater k precisely


fihoffmann

ed k iff counter shortest plan sorg obviously
case iff x si sg plan length k concludes argument
analyzing optimal relaxed plans
need fill notations sake self containedness section first
state definitions given section
definition let x si sg task let h let
p optimal relaxed plan let x x let p operator taking
relevant transition form x c
optimal rplan dependency graph p x optimal rplan dependency
graph p brief graph odg v unique leaf vertex x
x v x x x x x xpreo preo x x x x


taking relevant transition x x xpreo
v x exists p
preo x x
x v x odt g
x denote sub graph dt gx includes

x relevant transitions operator
values true point p

p x least one relevant inverse relevant inverse exists

x transitions original inverse transitions induced
refer p
definition let x si sg p x odg v definition
say odg successful following holds
odg acyclic


recoverable
odg relevant deletes p

b x odg relevant replaceable side effect deletes
c x odg relevant recoverable side effect deletes

x v x odt g
x transitions self irrelevant deletes
invertible induced irrelevant side effect deletes side effects v x
next define two general notions helpful state proofs
prevail condition prevo operator restricting preo
set variables xpreo xeff
let x x let c c transition dt gx let seff c c side
effect transition context c c ctx c c

prerop c c
xprerop c c
dy xprerop c c
context c c set ctx c c partial variable assignments
every seff c c x ctx c c identify ctx c c
set facts occur assignments


fianalyzing search topology without running search

note definition ctx c c writes previous one section
sense distinguish possible tuples context values
rather collecting overall set need fine grained definition
precisely formulate definition condition c e conditions transition
recoverable side effect deletes namely definition conditions b c
formalized follows
transition c c replaceable side effect deletes iff ctx c c sg every
rop c c preo ctx c c exists eff eff
preo prevrop c c eff rop c c
transition c c recoverable side effect deletes iff following two conditions
hold
c c irrelevant side effect deletes every ctx c c
exists recovering
operator preo prevrop c c eff rop c c eff
eff sg rop c c preo
every seff c c goal appears operator precondition
possibly recovering operators
replaceable side effect deletes upon execution remove
relaxed plan operator relying deleted facts replaced
recoverable side effect deletes due first clause definition matter
state apply matter context holds
recovering operator applicable achieves relevant facts due
second clause delete facts relevant elsewhere relaxed plan note
anything deleted must side effect
finally formally define notion used definition condition odg
recoverable assume surroundings pertaining
relevant deletes p
theorem e x si sg task state p optimal relaxed
plan odg v optimal rplan dependency graph leaf variable x
transition x c responsible operator considering state
executed reaching state examining relaxed plan p

constructed p removing replacing operators p


operators responsible induced odt gx transitions x v x
c x x ctx denote values potentially deleted
r denote union sg precondition p operator
precondition operator responsible operator
induced transition odt g
x x v x discussed section
super set facts possibly needed p

f op eff denote set facts true relaxed execution



p
discussed section p f p needed p
relaxed plan



fihoffmann

denote union prevo eff set facts x c

exists x xeff p
responsible

operator induced transition odt gx x v x set f defined
f x c x c f x v x xeff v x else f
facts certain true set
facts able achieve start p appropriately ordering
operators

relaxed plan macro precondition

ho sub sequence
p
sn




defined pre
preoi j
eff oj relaxed plan macro effect


n





defined eff
eff oi empty sets default empty


set notions simply capture outside needs effects relaxed plan
sub sequence


recoverable iff p
contains sub odg relevant deletes p





sequence pre



eff

c

f


first condition

r











ensures applicable appropriate point within p second


clause ensures facts relevant p achieved

proceed exit path construction follows first consider
part path leading e move non leaf variables x v x
construct relaxed plans p states visited path
first note assume p sorted according optimal rplan
dependency graph odg v precisely let xk x topological ordering
v x according arcs due construction v per definition
previous values never removed relaxed state space order


x p perform moves
xk p
p take form p

within odt gx front order conforming henceforth assume
wlog p form

recall follows original odt g
x transitions taken p
whereas induced odt g
x transitions included inverse original tran

sition path
p invertible transitions traversing hc cn inverse path
p


traverses hcn c replacing transition inverse rop p denote
operator sequence responsible path
say state invertible surroundings according odg

reachable executing sequence
responsible operators invertible induced

transitions odt gx x v x adapted relaxed plan denoted
p ss constructed follows let xk x topological ordering v x
according denote p p xk p x p initialize p ss

p xi v x let
p path original invertible transitions



odt gxi leading xi xi clearly path must exist remove rop
p






p ss insert rop p start p ss xi
next adapted relaxed plans indeed relaxed plans restricting
conditions correspondence definition condition
lemma let x si sg task let state h
let p optimal relaxed plan say odg v optimal rplan


fianalyzing search topology without running search

dependency graph p every x v x invertible induced odt g
x
transitions irrelevant side effect deletes side effects v x let
state invertible surroundings according odg p ss relaxed
plan p ss p


proof definition know p takes form p
xk p
x p






p ss takes form p xk p x p xk x
topological ordering v p operator sequence common
whose content important proof simplicity denote rest
proof p ss p leave away subscripts

consider first relaxed execution p xk p xk say
p
e path original invertible
path odt g
considered


definition

p
xk



transitions odt g
xi leading xk xk clearly ho rop p

sub sequence p xk say
p visits vertices xk c cn xk denote
c c cn assume wlog p xk starts ho note
order p xk relaxed plans general way want long
violate operator preconditions latter case ho
constitutes path odt g
xk operators depending value c

ordered occur later p xk since transitions
p side
effects v x construction v per definition operators ho
support way p affecting variable xk
given wlog p xk form ho p construction




p xk form rop
ps
p h

n ps
consider endpoints
n



prefixes e eff oi n eff
oi clearly since

transitions
p irrelevant side effect deletes relevant part
contained far variables outside v x xk concerned

relevant part
contained relevant side effects ho already

contained values c obviously true
induced transitions side




effects increase fact set sequence h
n
applicable relaxation see note first preconditions xk


satisfied definition h

n constitutes path dt gxk side effects
occur harmful old values written relaxation
preconditions variables due invertibility outside conditions
oi contained oi subset ho hence definition
since xk incoming edges odg preconditions satisfied
satisfied vk root odg variables x
contained v hence x x prerequisite note precondition facts
cannot deleted side effects whose deletes irrelevant prerequisite
shown relevant part outcome relaxed execution
p xk contained outcome relaxed execution p xk
variables outside v x xk iterate argument assume induction
hypothesis already shown relevant part outcome relaxed
execution p xk p xi contained outcome relaxed execution
p xk p xi variables outside v x xk xi
consider p xi p xi thing changes respect xk
may preconditions variables xj true j



fihoffmann

preconditions must belong predecessors xi odg definition
since p p xk p x p relaxed plan conditions
established relaxed execution p xk p xi given
induction hypothesis conditions clearly irrelevant established
relaxed execution p xk p xi concludes argument
inductive case follows relevant part outcome relaxed
execution p xk p x contained variables outcome
relaxed execution p xk p x claim follows trivially
p relaxed plan remainder p operator sequences
identical
second part claim follows j original
transitions use xi respectively xj operators common
argued relevant operators side effects v x since
operators affects variable xi cannot affect variable v x thus
inverse transition introduce via inverse operator p contains separate
operator obviously get p ss p
lemma captures second case definition condition transitions
invertible induced irrelevant side effect deletes side effects v x
next lemma captures first case definition condition
lemma let x si sg task let state h
let p optimal relaxed plan say odg v optimal rplan
dependency graph p every x v x invertible induced odt g
x
transitions irrelevant side effect deletes side effects v x let
state invertible surroundings according odg let state reached
p ss x operator constituting transition c c x v x c
self irrelevant deletes removing p ss yields relaxed plan

proof lemma p ss relaxed plan upon execution
effects true e x c side effects present hand
obviously facts z e true ctx c c x c since
prerequisite transition c c self irrelevant deletes facts ctx c c x c
irrelevant rop c c relevant meaning goal occur
operator precondition possibly claim follows directly

remark much easily formulated general version lemma
could proved simply associating notion self irrelevant deletes operators
rather transitions postulating used p argument
corresponds part proof lemma authors previous work hoffmann
state argument particular form since form
need
almost ready prove main lemma behind exit path construction
need one last notation capturing simpler form cost function costd odg


fianalyzing search topology without running search

considered section simpler function make use shortcut construction pthat construction introduced separately define
costd odg xv costd x costd x


x x
p



diam odt gx x x x cost x x x
lemma let x si sg task let state h
let p optimal relaxed plan say odg v successful

optimal rplan dependency graph p exists operator sequence




constitutes monotone path state h h

ii length
costd odg definition condition
b costd odg definition condition c
proof let xk x topological ordering v x according arcs consider
state every x v x x vertex odt g
x
every variable x outside v x x x unless x irrelevant say
preo note first state exists definition
preo x undefined preo x x x note every variable
x outside v x x x unless x irrelevant covers
case transition v x side effect x whose delete must
prerequisite irrelevant thus side effect x x actually
preconditioned x definition p relaxed plan
variable x xpreo contained v unless preo x x reasons


construction odt g
x preo x vertex odt gx
consider state applying first consider
situation invertible surroundings according odg opposite
case discussed apply lemma hence relaxed

x x
plan p ss replacing p moves p




v x inverses particular h h p ss x p x
x v relaxed plan distinguish definition condition
cases b c


case definition p
contains sub sequence
pre







eff
r c f implies remove p


obtain relaxed plan p thus getting h h precisely construct

p removing p ss xeff v x moving
occur




start p xeff v x moving occur start p


unchanged p ss

observe first p
sub sequence p since
adaptation pertains exclusively operators precede p second course
values established true

third
applicable relaxation assigned point p see
consider first case xeff v x definition pre








fihoffmann

contained prevo eff set facts x c exists

x xeff p
responsible operator inverse


transition taken operator p
facts true
obvious prevo eff follows facts true
cannot affected operator path consider case
xeff v x definition pre
contained previous sets facts



plus x c x c f x v x latter facts far relevant true

start
p execution affect execution

p ss thus p point argued lemma
outcome execution contains variables v x

relevant part outcome p
relevant part f since
affect variables true concludes point
finally consider facts z e true may

needed p behind
e goal precondition
operators observe since inverse operators performed transitions
variables v x since include outside preconditions
z e contained r say first z e f
z e ctx x c x x f r thus z e eff
prerequisite




else
done z e f note z e preo p

precondition would true relaxed execution p thus p would

thus z e needed
relaxed plan neither z e added p

precondition inverse operator used p operators
introduce outside preconditions course use preconditions previously
added operators affecting respective variable thus reason z e

could needed p z e sg z e preo p


z e sg certainly since p relaxed plan achieved operator
p cannot since effect true cannot


thus contained p
since z e f thus p
p

arguments apply e must
done z e preo p


p ordered adds z e concludes proof case
consider case b x r transition x c replaceable
side effect deletes e ctx x c sg every preo
ctx x c exists eff eff preo prevo eff
obtain relaxed plan p removing p replacing
operators respective needed precisely say z e true
z x e x needed p construction every z
must z e ctx x c z e goal prerequisite operator
p z e precondition replace postulated operator
obviously applicable effect concludes case
consider last case c definition x r transition x c
recoverable side effect deletes guarantee decrease h obtained
note particular special case inverse transitions non leaf variables x may
precondition x added needed prerequisite operators p x
preconditions preconditions may needed p ss thus p
p reason include facts definition r



fianalyzing search topology without running search

successor state namely let operator recovering relevant
side effect deletes x c precisely let ctx x c exists
definition ctx x c
let operator preo prevo eff
eff eff sg preo operator exists case b say
obtain p replacing p ss p relaxed plan
see note first applicable virtue preo prevo eff
note values deleted plus x x since
x x x r know x sr thus delete
consequence virtue eff sg preo facts could
possibly relevant achieved finally values established true

say obtain applying removing p yields relaxed
plan simply established effects true virtue
eff facts deletes side effects transition x c case c
relevant anything except possibly recovering operators recovering
operator removed p recovering
operators
could still contained p since eff eff sg preo
relevant facts could possibly achieve already true thus remove
well hence overall h h
cases b prove constructing monotone path case c
true course ii constructing path
specified length ignore issue moment difficulty
constructing path achieving preconditions preconditions may
satisfied need reach state satisfied need
without ever increasing value h note decrease value h somewhere
along way already reached exit monotone path done thus
follows upper bound h lemma bounding
accomplished starting taking odt g
x transitions variables
x v pertaining second case definition condition e transitions
invertible induced irrelevant side effect deletes side effects v x
follows brevity refer transitions case note
way reach states invertible surroundings according odg

operator sequence
lemma know h h states

along way cannot reach sequence e

would take non case odt g
x transition c c variable x state
prerequisite know transition c c self irrelevant deletes apply
lemma invertible surroundings according odg since
following transition path clearly x c e value relevant variable
start value last transition taking construction p ss changes
p case transitions thus responsible operator rop c c
case guaranteed contained p ss note rop c c cannot
used case transitions v x variable might taken
path prerequisite transitions side effects v x
contradiction constituting transition variable x hand thus know
h h already constructed desired monotone path exit


fihoffmann



stop else reach sequence

ho


respectively ho case c constitutes desired path

remains exactly construct operator sequence
consider
topological ordering v xk x follows consider depth indices k
say variable x v depth written depth x iff x xd
characterizes abstracted task identical original
task except outside preconditions odt g
x transitions
variables x depth x removed pertain values variables x
depth x prove induction

abstracted task exists operator sequence




ho execution path applicable
execution path


applicable last transition c c variable x taken
relevant
self irrelevant deletes responsible operator contained adapted relaxed
plan state applied x c

b
except last step case uses case odt g
x transitions
variables x depth x

c number operators
ho pertaining x v costd x

desired path
setting k see note kabstracted task identical original task claim follows
discussion b together mean h decreases monotonically






p less dthan h end given c length bounded
xv depth x cost x proves claim adding trivial observation
definition condition case c discussed need add one
additional operator end path

give proof base case trivial set
empty
construction v per definition construction abstracted
task outside preconditions true removed
case b c obvious

inductive case exploiting induction hypothesis let
operator




sequence per turn requested sequence abstracted task
remainder proof consider odt g
x x v x
contain irrelevant transitions e omit restriction definition
simplify argumentation odt g
x paths consider
contain irrelevant transitions hence contained actual odt g
x per
definition

let first operator
ho may applicable
abstracted task reason however may precondition
removed abstracted task removed abstracted task construction precondition must pertain xd say
precondition xd c induction hypothesis know contained

p
responsible inverse transition operator cases since
inverse transitions introduce outside preconditions xd c precondition


fianalyzing search topology without running search


operator p
thus c vertex odt g
xd trivial xd c true
actually cannot case else would applicable
abstracted task xd c true follows p
relaxed plan must thus achieve xd c needed precondition


hence p
xd must contain shortest path
q odt g
xd xd c
transitions path irrelevant see note first endpoint
operator precondition construction thus last transition c c irrelevant
neither previous transition c c xd c would

operator precondition rop c c contained p
construction


would constitute transition c c odt gxd thus
q would


shortest path contradiction iterating argument q contain irrelevant
transitions thus since depth xd definition includes nonsatisfied preconditions relevant transitions construction abstracted

task outside preconditions used rop
q true


removed hence execute rop q reached end
sequence last transition taken odt g
xd case hence
self irrelevant deletes prerequisite latter case since following path
since discussed adapted relaxed plan exchanges operators pertaining
case transitions thus last one executed clearly attained

case stop part rop
q executed operator

sequence
desired former case reach state xd c
nothing else relevance deleted due non existence relevant side effect
deletes applied leading state

let second operator
ho applicable




reason may unsatisfied precondition form xd c

hence c vertex odt g
inverse contained p
xd likewise


xd c vertex odt gxd yet used non case
transition odt g
xd else wouldnt get means still
invertible surroundings around xd odt g
xd clearly implies


exists path odt gxd c c could simply go back xd move

c taking shortest path
q clearly path length bounded

diameter odt gxd path contain irrelevant transitions
endpoint c selected operator precondition values
part shortest path odt g
xd thus argument given applies

thus outside preconditions used operators constituting
q true
removed follows construction v per definition

construction abstracted task operators p
follows
inverses thereof inverse operators introduce outside preconditions hence

execute
q reached end path
last transition taken case hence self irrelevant deletes prerequisite
consider latter case state last transition reached
case transitions since transition odt g
xd case responsible

operator must contained p adapted relaxed plan p ss
recall pointed since case transitions postulated


fihoffmann

side effects v x responsible operator cannot used
clearly since following path transitions value xd
start value transition hence attained case stop
former case reached state applied nothing relevance
deleted due postulated non existence relevant side effect deletes case

transitions iterating argument get state last operator
ho
applied induction hypothesis reaching state desired case
properties b clear construction property c support

operator
ho clearly apply diam odt g
xd operators
pertaining xd stop sequence earlier note

operators
ho unsatisfied preconditions xd pertains
variable x xd x consequence construction v
per definition fact inverse transitions introduce outside

preconditions thus comparison
ho overall execute
x
diam odt g
k x
xd
x xd x



additional operators
ho k x number operators
ho
pertaining variable x induction hypothesis property c k x
costd x x depth x thus x xd x hence
get newly inserted steps affecting xd upper bound
x
diam odt g


costd x
xd
x xd x

identical costd xd concludes argument
next note improve exit distance bound case insist
monotone exit paths
lemma let x si sg task let state h
let p optimal relaxed plan say odg v successful
optimal rplan dependency graph p let v v x every x v
odt g
x transitions invertible induced irrelevant side effect deletes
side effects v x dt gx transitions irrelevant empty

conditions irrelevant side effect deletes exists operator sequence




constitutes path state h h

ii length
costd odg definition condition
b costd odg definition condition c
proof simple adaptation lemma adopt follows terminology proof lemma thing changes bound imposed
exit path length sharper insist path monotone
level proof mechanics happens whenever xd v choose


fianalyzing search topology without running search


path
q achieve next open precondition operator already chosen participate


ho restrict paths within odt g
xd allow
shortest path dt gxd shortest path dt gxd value occurs

operator precondition
q contains irrelevant transitions argument

proof lemma
q executable prerequisite alternative
non odt g

transitions


outside conditions original induced transitions
x
precondition achievement works exactly note important property
open preconditions achieved xd ever pertain values contained
odt g
xd trivial see induction alternative transitions
outside preconditions since prerequisite deletes alternative transitions
irrelevant executing harm need minor extension lemma
allowing identical state invertible surroundings modulo
set irrelevant values hold obvious extension
valid extension obvious arguments pertaining

remain valid finally consider case
q involves non case odt g
xd transition
state transition applied invertible surroundings
holds x v construction remains holds
x v first alternative transitions outside conditions hence cause
higher depth transitions inserted hence value lower depth

variables x odt g
x second prerequisite odt gx contain non case
transitions thus value x clearly reached case transitions
theorem let x si sg p odg definition odg successful local minimum ed costd odg definition
condition b ed costd odg
proof direct consequence lemmas
note prerequisites lemma could weakened allowing x v
outside conditions already true extension obviously break
proof arguments omitted make lemma prerequisite even
awkward already
indicated exit path constructed lemma necessarily monotone example appendix contains construction showing
conservative approximations
sake self containedness section state definitions given section
definition let x si sg task let h let
x xsg let x c relevant transition dt gx rop
local dependency graph x local dependency graph brief
graph ldg v unique leaf vertex x x v x x
x x x xpreo preo x x x v x x x arc sg




fihoffmann

global dependency graph x global dependency graph brief
graph gdg v unique leaf vertex x x v x x
x x x x xpreo x v x x x arc sg


definition let x si sg g ldg g gdg definition
say g v successful following holds
g acyclic
g ldg sg x x exists transitive successor x x
sg x xsg sg x x

self irrelevant side effect deletes
b replaceable side effect deletes
c recoverable side effect deletes
x v x dt gx transitions irrelevant self irrelevant
deletes invertible irrelevant side effect deletes side effects
v x
lemma let x si sg task let state h
say x x every rop x c dt gx x c
relevant ldgo successful local dependency graph x least
one exist optimal relaxed plan p successful optimal rplan
dependency graph odg p x odg sub graph ldgo
proof observe first definition property forces relaxed plan p move
x e p x non empty particular p x takes path

dt gx x sg x let
q shortest path taken p x let

responsible operator first transition
q clearly transition
form x c e one operators claim lying shortest path
x sg x sub graph dt gx taken p x transition x c
irrelevant seen exactly argument given proof

lemma transitions paths
q constructed except endpoint
goal instead operator precondition
next observe optimal p contains one operator x xpreo
preo x x follows definition property x cannot become important non achieved goal e p operator outside p x relies precondition x see assume operator exist
since p optimal exists reason inclusion precisely
must achieve least one fact needed terms hoffmann nebel
b fact goal precondition another operator
behind p iterating argument necessary obtain sequence
x c x c xn cn xn cn goal fact satisfied
oi achieves xi ci p obviously sg contains path x xn
xn xsg sg xn xn contradiction definition property thus
exist argument follows every operator p x


fianalyzing search topology without running search

side effect used elsewhere relaxed plan precondition x
thus operators p x preconditioned x serve transform
x sg x course single one operators relies x
else p optimal
say follows ldgo v denote v backchaining

definition p
definition include variables arcs included
definition see note arcs x x included definition due
relevant transitions hence v sub graph v particular since v
acyclic v acyclic well
next observation assuming definition condition holds true definition condition implies definition condition definition condition b implies
definition condition b definition condition c implies definition condition
c
consider first case self irrelevant side effect deletes

r c recall notations appendix c x x ctx
r super set set facts need relaxed plan removing
variables except x clear fact intersection facts
ctx irrelevant relevant prerequisite thus contained r
hence x x remains possible content r c follows
x x r thus x x r c latter intersection empty
desired recall r denotes union sg precondition p
precondition operator responsible operator induced
transition odt g
x x v x definition condition x x sg
argued operator p may preconditioned x
thus precondition p lastly say p precondition
responsible operator induced transition odt g
x corresponding original
transition since inverse transitions introduce conditions

since
p cond thus p prerop definition rop p

rop p x x prerop implies p x x
thus x x r needed
consider case b recoverable side effect deletes definition
condition b rop need prove x odg relevant
e x r already shown
case c replaceable side effect deletes definition condition
c need prove x odg relevant
consider finally conditions imposed non leaf variables x v x e definition condition definition condition definition condition
dt gx transitions every x v x irrelevant self irrelevant deletes
invertible irrelevant side effect deletes side effects v x
dt gx transitions irrelevant cannot odt g
x thus nd rd case


true odt gx transitions every x v x concludes argument
theorem let x si sg task let state
h say x x every rop x c dt gx
x c relevant ldgo successful local dependency graph local


fihoffmann

minimum ed maxo costd ldgo every ldgo definition
condition b ed maxo costd ldgo
proof lemma choice rop x c exists optimal relaxed
plan p successful optimal rplan dependency graph odg v p
odg sub graph ldgo unique leaf vertex x apply
lemma obtain local minimum
see part claim let v defined section e v subset
v x dt gx transitions irrelevant invertible
empty conditions irrelevant side effect deletes side effects v x
dt gx transition x v satisfies restriction required lemma

odt g
x transitions irrelevant cannot odt gx else invertible
irrelevant side effect deletes side effects v x restriction
required lemma transitions irrelevant empty conditions
irrelevant side effect deletes hence apply lemma odg obtain
necessarily monotone path exit length bound costd odg x c
irrelevant side effect deletes replaceable side effect deletes costd odg
x c recoverable side effect deletes thus suffices costd ldgo
costd odg however obvious v v costd x x

maxpath dt gx diam odt g
x x v
theorem let x si sg task say global dependency graphs
gdg successful contain local minima state
h ed maxgdg costd gdg every gdg definition
condition b ed maxgdg costd gdg
proof let state need prove local minimum h
h nothing else assume variables x topologically
ordered according strongly connected components sg let x x
uppermost variable x xsg sg x x obviously x exists clearly
chance x satisfy definition condition exists transitive
successor x x sg x xsg sg x x exists x
strongly connected sg component x xsg sg x x
exists transition dt gx outside condition eventually leading
backwards chaining sg x let gdg global dependency graph x
rop gdg exists x xsg since definition includes transitive
sg predecessors x pertaining conditions gdg includes x since
x x lie strongly connected component definition eventually reaches
x thus gdg contains cycle contradiction prerequisite follows
strongly connected sg component x contains x thus definition condition
holds true
say responsible relevant transition form x c dt gx
exists local dependency graph ldg x ldg sub graph
gdg follows simple observation definition include gdg
variables arcs include ldg note precondition


fianalyzing search topology without running search

x present satisfied rop x c thus definition
include x predecessor achieving preconditions ldg
obviously given ldg successful since works choice notirrelevant x c apply theorem claim follows directly
fact costd gdg costd ldg latter obvious costd increases
monotonically adding additional variables
example constructions
first example shows even within scope basic operators
necessarily respected relaxation e operator may start optimal real plan yet
occur optimal relaxed plan
example consider task figure variables shown dark green
left hand side respective dtg circles represent variable values lines
represent dtg transitions transitions condition longer lines condition
inscribed line blue variable dashed arrow indicates value
initial state si goal value defined indicated circled value
needed refer operators responsible transition terms respective
variable followed indices start end value example operator moving
x c c referred x abbreviate states x c c
stick conventions throughout section

x



c

c



c












figure task underlying example
shown figure dtg x consists three vertices whose connection requires
conditions alternatively shortcut domain line
length requiring conditions
clearly support graph task acyclic transitions dtgs
side effects invertible however operator example respected
relaxation see note first h si optimal relaxed plan
hy x x relaxed plan ignores need move back operator x hand optimal real plan si hy x
choose use instead optimal relaxed plan end
sequence hy x x step longer hence si starts
optimal plan start optimal relaxed plan


fihoffmann

next give three examples showing local minima arise simple situations generalizing basic minimally consider order cyclic support
graphs non invertible transitions transitions side effects
example consider task figure

x
c



c






dn

dn

c

figure task underlying example
dtg x two vertices whose connection requires condition
domain line length n requiring conditions shortcut
dn requires c condition clearly transitions dtgs side effects
invertible however sg contains cycle x mutually
depend mutual dependence causes initial state
si x c local minimum n abbreviate states
x c c h si optimal relaxed plan hx ni
consider operators applicable si c
execute x leading c h due hx ni
state reached via giving c h due
hy x ni note n prerequisite relaxed plan composed
yi operators steps h h si way
cannot reach exit monotone path
execute leading c h due hy x ni note
n prerequisite relaxed plan moving ypp operators
steps path monotone
execute n leading c dn h due hyn x
state reached via yn n giving c dn h
due hy n n yn x note n prerequisite relaxed plan
moving via dn steps path monotone
operators applicable si thus explored states reachable si
monotone paths none states exit proving si local minimum
fact single state h namely c dn
clearly reaching si takes n steps first apply x traverse dn
exit distance si n thus distance unbounded


fianalyzing search topology without running search

section following modification example considered set n e
domain reduced two values remove line dn
e move via previously short cut modified example falls
sas pubs tractable class identified backstrom klein still
contains local minimum example unsolvable though
example consider task figure

x
c



c



c






dn

figure task underlying example arrow indicates
respective dtg transition directed e exists transition

dtg x three vertices whose connection requires starting initial value
c first condition condition domain circle length n requiring
conditions invertible except arc
clearly support graph acyclic transitions dtgs side effects
however non invertible arc causes initial state si c
local minimum n easy see h si due
optimal relaxed plan hy x x note relaxed plan
move back still true executing operators applicable
si n latter reaching state sn c dn immediately increases
value h n n get closer moving
farther away need achieved shortest relaxed sn
hyn x x alternatively say apply si reaching state c
h n need apply relaxation x n steps complete
circle back x thus n larger h value si
follows si local minimum nearest exit si sn c dn sn
relaxed plan hy n n yn x length applying n n get h
value reaching sn si takes step moving x n steps moving
exit distance si n thus distance unbounded
example consider task figure
dtg x consists two kinds transitions first line c cn
transitions requiring conditions second direct links called short cuts
follows cn every ci conditioned value dtg contains
two vertices connected unconditionally moving side effect
cn side effect responsible towards cn direction short cuts
dtg x


fihoffmann




x
c

c

cn

cn






figure task underlying example red inscription cn line
indicates transition side effect
cn
support graph acyclic arc goes x due short cuts
dtg x due operator effect x precondition
transitions invertible particular short cut direction towards
cn vice versa however side effect causes initial state si c
local minimum n
h si due optimal relaxed plan hy note
relaxed plan care side effect c still true afterward
apply operator si leaves c clearly increase h
matter move make relaxed plan must include move back c
available option si apply get state cn
h well relaxed plan needs achieve c since n
via unconditional sequence cn c takes steps alternative use
short cut xn cn c involves applying first place giving us
relaxed plan length hence direct successors si heuristic value
si local minimum note exit distance si grows n nearest
exit state goal reached single step clearly
state c shortest path state si applies moves along
unconditional line cn c taking n n steps
next exit path constructed short cuts leading improved
bound costd instead costd may non monotone improved bound may
indeed estimate length shortest monotone exit path
example consider task figure
example optimal relaxed plan initial state moves z along
path e e n note values needed moving moves
k n moves x c gives total h si n k n n k
steps
operators applicable si move z move along line e e n
h remains constant need include moves back order achieve
goal z reach e n move one step need move z back
etc moves state k n long z stays within


fianalyzing search topology without running search

x
c




e n



e

e

e n



k n

c

k

e

k e

e n

k n

z
e

e

e n

e n

e

figure task underlying example
e e n h remains constant see observe first course suffices
relaxed plan reach z values line taking n moves wherever
line moves second observe indeed moves
needed wherever line k n needs move k n order
suit x needs move suit goal every value e e n appears
condition least one moves thus si nearest exit reached
way state k n z e n move x c

decreases h n k length exit path
described si
obviously k n n kn k n
happens move z e consider first si h increases
n k need reach values line e e n e takes one

step argument applies state traversed
argued

state still need reach values line e e n thus

shortest monotone path exit
optimal rplan dependency graph odg si entire sg odt g
z
contains dt gz except e global dependency graph gdg entire sg
clearly si next required value reach variable e n construction
proof theorem first try reach value short cuts
accounted costd exit path constructed move e n via e rather via
line e e n thus claimed exit path monotone
finally consider bound returned costd odg obviously costd odg
costd gdg obtain bound costd odg costd x k

n costd x diam odt g
k n n cost diam dt gz note
diam dt gz n dt gz circle n nodes overall
costd odg k n n kn k n n sufficiently large k
less kn k n claimed detail kn k n kn k n n
n
iff kn k n iff kn k n iff k n
holds example set n
k
reader noticed example contrived reason need
complicated unrealistic example costd costd contains two
sources estimation cf discussion section particular every move non

fihoffmann

leaf variables supposed take whole odt g dt g diameter costd
general upper bound length monotone exit path thus need presented
construction around k estimation considering diam dt gz instead
diam odt g
z outweighs estimation importantly constructing examples
short cuts temporarily increase h costd nevertheless delivers upper bound
monotone exit path length much easier needs happen whatever
reason variable z currently required value e n example
reached odt g
z values along unnecessarily long path whose values needed
relaxed plan happens quite naturally e g transportation domains
vehicle needs load unload objects along longer path
demonstrate case analyses apply exit distance may
exponential
example consider task figure

x
c

x
c

c

c

c

c

c

c

c

c

c

c

xn
c n

c n

c n

c n

c n

figure task underlying example
dtg x two vertices whose connection conditioned c
variables xi five vertices line alternatingly requiring last vertex ci



xi first vertex c xi clearly optimal rplan dependency graph
odg si global dependency graph gdg task full support
graph sg acyclic transitions invertible side effects thus
analyses apply
h si ed si relaxed plan need move x c due
conditioning variable extreme values left right hand side
required need moves xi n thus h si n
consider state x c construct relaxed plan obviously
still need move x still need moves variable consider x
x c need move c order able move x x c
need move c order able move x c goal
forth cases four transitions must taken relaxed plan due
conditioning recursively true variables thus h n


fianalyzing search topology without running search

means nearest exit state x value c x value c
move x afterward definitely n steps suffice relaxed plan
distance state need move x four times lets denote x
move requires moves x x sequence moves x inverses
direction three times points x need move x x
generalizing get xi xi x xi growth
n exponential
obviously example shows plan length exponential cases
theorem applies remark example similar example given
domshlak dinitz difference domshlak dinitzs example
uses different conditions transitions left right enables
use smaller dtgs nodes setting cannot use different conditions
need transitions invertible causes loss exit path steps
situations next lower variable inverses direction thus relies
outside condition previous step indeed dtgs size loss
steps polynomially bounded exit distance recursive formula xi
becomes xi xi x xi resulting ed si n n
hand costd costd still remain exponential case
consider loss incurred inversing
directions precisely easy see
p
costd odg costd gdg ni n proves bounds
estimate exponential amount
next example shows exit path constructed implicitly analyses may
exponentially longer optimal plan task
example consider task figure

x
c

c

c

c

x
c

c

c


c n

c

c

c

c

c

xn
c n

c n

c n

c n

c n

figure task underlying example


c

fihoffmann

example optimal relaxed plan initial state
example alternative route via c c n takes n n
n steps thus exit path constructed remains length exponential
n however length shortest plan n
note example observed weakness guided wrong direction
caused weakness optimal relaxed rather weakness
analysis relaxation overlooks fact moving via x xn incur high costs
due need repeatedly undo conditions achieved beforehand note
example get exponential estimation exit distance
finally feeding theorem non optimal relaxed plans give
guarantees
example consider task figure

x
c
g



c

g n

c

v




en



g

g

g n

g n

v n

z
e

e n

en

figure task underlying example arrow en en indicates
respective dtg transition directed e exists transition
en en
two ways achieve goal c via moving z moving
v vn optimal relaxed plan chooses former option giving h si n
soon n however parallel optimal relaxed plan p si chooses latter
option moving z n sequential moves whereas v vn
moved parallel giving parallel length
consider happens h options move z h remains
constant need move z back goal soon reach z en
h last transition uni directional longer achieve
goal z thus exit path particular monotone exit path via
option
say move v vn instead first move whichever vi choose h
increases shortest option undo move go via z takes
n steps whereas completing vi moves going via c takes n n steps


fianalyzing search topology without running search

thus monotone exit path via option si local minimum
completing n moves vi moving x c h n due
shortest relaxed plan moves back vi moves x c reduce heuristic
value initial value h si n need execute steps
state reached better evaluated neighbor exit distance n
consider effect feeding theorem parallel optimal plan p si
clearly optimal rplan dependency graph odg constructed p si consists x
vi variables include z thus theorem applies
wrongly concludes si local minimum
exit distance bound computed
p


costd x diam dt gvi n
costd odg costd x n

less actual distance ed si n thus wrong
say modify example making last transition z undirected making
one vi transitions unidirectional right v vn option leads
dead end whereas z option succeeds particular theorem apply
odg constructed parallel optimal relaxed plan p si thus example
non optimal relaxed plans loss information
benchmark performance guarantees
give definitions domains mentioned propositions domain
explain respective property claimed holds true domains
assume static properties used pddl capture unchanging things
shape road network transportation domain assume follows
static predicates removed prior analysis e prior testing
prerequisites theorem
definition logistics domain set tasks v si sg whose
components defined follows v p v p set package location variables
p dp l v l set representing possible locations v set
vehicle location variables v dv lv subset lv l locations contains
three types operators move load unload move v l l v
l v l l l load v l p v l p l p v unload v l p
v l p v p l si assigns arbitrary value variables sg
assigns arbitrary value subset variables
every global dependency graph gdg logistics package p leaf
variable x vehicle variable v leaf variable x latter case gdg
consists x arcs former case preconditioned single vehicle
v leading single non leaf variable v cases gdg acyclic involved
transitions side effects involved transitions invertible thus
apply theorem costd gdg packages costd gdg
vehicles thus overall obtain correct bound
definition miconic strips domain set tasks
v si sg whose components defined follows v b e
b set passenger origin variables l l


fihoffmann

set representing possible locations floors set passenger destination
variables dd l b set passenger boarded variables b db
set passenger served variables ds e elevator location variable
de l contains three types operators move board depart
move l l e l e l l l board l e l oi l bi
depart l e l di l bi bi si si assigns arbitrary locations
variables e assigns variables b sg assigns variables

passenger origin passenger destination variables static e affected
operator thus common pre processes remove variables
statically prune set operators reachable assume follows
removal taken place
every global dependency graph gdg miconic strips passenger served variable
si leaf variable x leads non leaf variables bi e arcs e
variables bi si clearly gdg acyclic transitions e
invertible side effects transition bi invertible since
departing different condition e irrelevant delete bi
occur anywhere goal preconditions side effects thus irrelevant
side effect deletes transition bi invertible irrelevant bi
doesnt occur anywhere transition leaf variable si self irrelevant side
effect deletes bi occurs precondition transitions responsible
operator rop depart ld hence apply theorem delivers bound
costd gdg si costd si maxpath dt gbi costd si
costd bi diam dt ge
definition simple tsp domain set tasks v si sg
whose components defined follows v p v p position variable
dp l l set representing possible locations v v l
set location visited variables v dv contains single type
operators move l l p l p l vl l l si assigns arbitrary
value p assigns variables v sg assigns variables v
every global dependency graph gdg simple tsp location visited variable vi
leaf variable x leads single non leaf variable p clearly gdg acyclic
every transition vi considered induced move l li replaceable side
effect deletes operator move l x replaced equivalent operator
move li x unless x li latter case excluded
definition replaceable side effect deletes every transition l l p clearly invertible
irrelevant side effect delete vl side effect vl
non leaf variable gdg hence apply theorem delivers bound
costd gdg vi costd vi diam dt gp
consider extended version movie domain sense whereas
original domain version considers fixed range snacks thus state space
constant across domain instances allow scale number different snacks
original domain version allows scale number operators adding snack
operators identical removed trivial pre processes



fianalyzing search topology without running search

definition movie domain set tasks v si sg
whose components defined follows v c c h c counterat zero variable dc c counter two hours variable
dc movie rewound variable dre h snack
variables h dh contains four types operators rewindtwo rewindother resetcounter getsnack rewindt wo c
rewindother c c resetcounter c
getsnack hi si assigns arbitrary value variables sg assigns
c h variables
note depending value static variable c operator set
different si c rewindother removed si c rewindt wo
removed refer former case latter case b
every global dependency graph gdg consists single leaf variable transitions
h variable side effects thus irrelevant side effect deletes
transition c side effects thus irrelevant side effect deletes
transition c irrelevant case transition side
effects thus irrelevant side effect deletes apply theorem case b
transition side effect c observe fact
irrelevant ctx c resetcounter satisfies
preo prevrop eff rop c c
eff c
c eff sg rop c c preo c
thus transition recoverable side effect deletes apply theorem
case gdgs bound costd gdg applies obviously costd gdg
thus obtain correct bound case b bound costd gdg applies
costd gdg obtain correct bound
definition ferry domain set tasks v si sg whose
components defined follows v c f e c set car location
variables c dc l f l set representing possible locations f
ferry location variable df l e ferry empty variable de
contains three types operators sail board debark sail l l
f l f l l l board l c f l c l e c f e
debark l c f l c f c l e si assigns variable e assigns
arbitrary value variable f assigns arbitrary value f variables
c sg assigns arbitrary value f subset variables c f
let arbitrary reachable state h let p
arbitrary optimal relaxed plan apply theorem
distinguish three cases e board l c first board operator p
set x c b e debark l c first debark operator p
set x c c p contains board debark operator set
first operator sail l l p x f obviously exactly one cases
hold let odg v sub graph sg including x variables arcs
included per definition let transition taken
case obviously reorder p board l c first operator
p predecessors sail operators odg includes


fihoffmann

non leaf variables includes f f clearly transitions
invertible side effects transition effect c f deleting c l
clearly needed rest p side effect e deleting e
latter fact may needed board operators p however necessarily
p contains operator form debark l c applicable board l c
sequence moves p must contain l l debark l c recovers e

thus odg relevant deletes p
recoverable case b similarly

reorder p debark l c first operator p
predecessors sail operators transition effect c l deleting c f
clearly needed rest p side effect e deleting e
clearly needed rest p thus odg relevant deletes


p
recoverable recovering sub sequence p
empty

recovery required case c finally odg contains f side effects
delete f l needed anymore fact case l must goal
f p contains single operator hence cases apply
theorem costd odg cases b c get bound
costd odg diam dt gf cases b get bound
definition gripper domain set tasks v si sg
whose components defined follows v ro f f b ro robotlocation variable dro l r f f gripper free variables df df
b ball location variables db l r contains three types
operators move pickup drop move l l ro l ro l
l l pickup g b l ro l b l fg b g fg drop g b l ro
l b g b l fg si assigns l ro assigns f f assigns l
variables b sg assigns r variables b
let arbitrary reachable state h let p
arbitrary optimal relaxed plan apply theorem distinguish
two cases exists b b b g g drop g b r
set x b b exists b b b g g pickup g b l
b b p set x b obviously exactly one cases
hold let odg v sub graph sg including x variables arcs
included per definition let transition taken
case obviously reorder p drop g b r first
operator p predecessor move l r odg includes
non leaf variables includes ro ro clearly transitions
invertible side effects transition effect b r deleting
b g clearly needed rest p side effect fg deleting
fg clearly needed rest p thus odg relevant deletes

p
recoverable case b similarly reorder p
pickup g b l first operator p predecessor move r l
transition effect b g deleting b l clearly needed rest
p side effect fg deleting fg latter fact may needed
pickup operators p however necessarily p contains operators move l r
drop g b r applicable board l c drop g b r recovers fg thus


fianalyzing search topology without running search


odg relevant deletes p
recoverable hence cases


apply theorem cost odg cases b get bound
costd odg diam ro cases b get bound

definition transport domain set tasks v si sg
whose components defined follows v p v e c p set packagelocation variables p dp l v e l set representing possible
locations v e set vehicle location variables v dv l c set
vehicle capacity variables cv dcv k k maximum capacity
contains three types operators drive pickup drop drive v l l
v l v l l l r gr l r undirected graph roads
l pickup v l p c v l p l cv c p v cv c drop v l p c
v l p v cv c p l cv c si assigns arbitrary value l
variables p v e assigns k variables c sg assigns arbitrary value
l subset variables p v e
note use numbers addition subtraction course part
language consider however easily encoded
finite set number k via static predicates pre processing effect
resulting task isomorphic one obtained simple arithmetic
thus choose reduce notational clutter
let arbitrary reachable state h exists
optimal relaxed plan p apply theorem distinguish three
cases exists p p p v v v e drop v l p c
cv c p set x p b exists p p p v
v v e pickup v l p k p p p set x p c p
contains drop pickup operator set first operator drive v l l
p x v obviously choose p exactly one cases
hold choice p arbitrary b c may exist optimal
relaxed plans cv c let odg v sub graph sg including x
variables arcs included per definition let transition taken
case obviously reorder p drop v l p c first
operator p predecessors drive operators odg includes
non leaf variables includes v v clearly transitions
invertible side effects transition effect p v deleting
p l clearly needed rest p side effect cv c deleting
cv c latter fact may needed operators p taking form
drop v l p c form pickup v l p c clearly p contains operators
replace drop v l p c pickup v l p c respectively
value cv c true point relaxed execution thus
choose p p relevant deletes p recoverable v x
case b similarly reorder p pickup v l p k
first operator p predecessors drive operators transition
effect p v deleting p l clearly needed rest p
side effect cv k deleting cv k latter fact may needed
operators p taking form pickup v l p k however necessarily p


fihoffmann

contains operator form drop v l p c c k replace
operator drop v l p k since clearly value cv k true
point relaxed execution drop v l p k applicable pickup v l p k
sequence drive operators p must contain l l drop v l p k
recovers cv k thus choose p p relevant deletes
p recoverable v x case c finally odg contains v
side effects delete v l needed anymore hence cases
apply theorem costd odg cases b c get bound
costd odg min diam odt g
v diam dt gv cases b
bound diameter road map gr
ignoring action costs elevators domain ipc essentially variant
transport variant general vehicle elevator may
maximal capacity b vehicle reach subset locations e
vehicle individual road map hand elevators restricted
transport c vehicle road map fully connected every reachable floor
navigated directly every reachable floor goals exist
packages passengers vehicles even ignoring restrictions c
trivial see arguments given transport still hold true therefore
whenever reachable state h exists optimal relaxed plan
p apply theorem bound diameter
road map due c diameter

references
backstrom c klein polynomial time sas pubs class
computational intelligence
backstrom c nebel b complexity sas computational
intelligence
blum l furst l fast graph analysis artificial
intelligence
bonet b geffner h heuristic search artificial intelligence

botea muller schaeffer j component abstraction automatic
generation macro actions koenig et al koenig zilberstein koehler
pp
brafman r domshlak c structure complexity unary
operators journal artificial intelligence
bylander computational complexity propositional strips
artificial intelligence
cesta borrajo eds ecp recent advances ai th
european conference ecp lecture notes artificial intelligence
toledo spain springer verlag


fianalyzing search topology without running search

chen h gimenez causal graphs structurally restricted journal computer system sciences
domshlak c dinitz multi agent offline coordination structure complexity cesta borrajo cesta borrajo pp
edelkamp helmert exhibiting knowledge minimize state encoding length biundo fox eds recent advances ai
th european conference ecp lecture notes artificial
intelligence pp durham uk springer verlag
fox long automatic inference state invariants tim journal
artificial intelligence
fox long detection exploitation symmetry
pollack ed proceedings th international joint conference artificial intelligence ijcai pp stockholm sweden morgan
kaufmann
garey r johnson computers intractabilitya guide
theory np completeness freeman san francisco ca
gerevini howe cesta refanidis eds icaps proceedings
th international conference automated scheduling icaps
thessaloniki greece aaai
gerevini saetti serina stochastic local search
temporal action graphs journal artificial intelligence
gerevini schubert l inferring state constraints domain independent
mostow j rich c eds proceedings th national conference american association artificial intelligence aaai pp
madison wi usa mit press
gimenez jonsson complexity simple
causal graphs journal artificial intelligence
gimenez jonsson influence k dependence complexity
gerevini et al gerevini howe cesta refanidis pp
gimenez jonsson b chain causal graphs variables
domains size np hard journal artificial intelligence
haslum p reducing accidental complexity veloso
ed proceedings th international joint conference artificial intelligence
ijcai pp hyderabad india morgan kaufmann
helmert complexity standard benchmark domains
artificial intelligence
helmert heuristic causal graph analysis koenig et al
koenig et al pp
helmert fast downward system journal artificial intelligence



fihoffmann

helmert concise finite domain representations pddl tasks artificial intelligence
helmert domshlak c landmarks critical paths abstractions whats
difference anyway gerevini et al gerevini et al pp
hoffmann j utilizing structure local search
vol lecture notes artificial intelligence springer verlag
hoffmann j ignoring delete lists works local search topology
benchmarks journal artificial intelligence
hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
hoffmann j nebel b b rifo revisited detecting relaxed irrelevance cesta
borrajo cesta borrajo pp
hoffmann j porteous j sebastia l ordered landmarks journal
artificial intelligence
jonsson role macros tractable journal artificial intelligence
jonsson p backstrom c incremental european workshop

jonsson p backstrom c state variable structural restrictions
complexity artificial intelligence
karpas e domshlak c cost optimal landmarks boutilier c
ed proceedings st international joint conference artificial intelligence
ijcai pp pasadena ca usa morgan kaufmann
katz domshlak c islands tractability cost optimal
journal artificial intelligence
katz domshlak c b structural patterns heuristics via fork decomposition
rintanen j nebel b beck j c hansen e eds proceedings
th international conference automated scheduling icaps
pp sydney australia aaai
knoblock c automatically generating abstractions artificial intelligence
koenig zilberstein koehler j eds icaps proceedings
th international conference automated scheduling icaps
whistler canada aaai
long fox automatic synthesis use generic types
chien kambhampati r knoblock c eds proceedings th international conference artificial intelligence systems aips pp
breckenridge co aaai press menlo park
mcdermott v regression match graphs control search
artificial intelligence


fianalyzing search topology without running search

nebel b dimopoulos koehler j ignoring irrelevant facts operators
plan generation steel alami r eds recent advances ai th
european conference ecp vol lecture notes artificial
intelligence pp toulouse france springer verlag
richter helmert westphal landmarks revisited fox gomes
c eds proceedings rd national conference american association
artificial intelligence aaai pp chicago illinois usa mit press
richter westphal lama planner guiding cost anytime
landmarks journal artificial intelligence
rintanen j iterative synthesizing invariants kautz h
porter b eds proceedings th national conference american
association artificial intelligence aaai pp austin tx usa
mit press
roberts howe learning planner performance artificial intelligence

vidal v lookahead strategy heuristic search koenig et al
koenig et al pp
williams b c nayak p p reactive planner model executive
pollack ed proceedings th international joint conference artificial
intelligence ijcai pp nagoya japan morgan kaufmann




