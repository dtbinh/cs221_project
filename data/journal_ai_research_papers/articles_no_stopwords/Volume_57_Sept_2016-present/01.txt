Journal Artificial Intelligence Research 57 (2016) 39-112

Submitted 4/16; published 9/16

PDT Logic: Probabilistic Doxastic Temporal Logic
Reasoning Beliefs Multi-agent Systems
Karsten Martiny
Ralf Moller

karsten.martiny@uni-luebeck.de
moeller@uni-luebeck.de

Institute Information Systems,
Universitat zu Lubeck
Lubeck, Germany

Abstract
present Probabilistic Doxastic Temporal (PDT) Logic, formalism represent
reason probabilistic beliefs temporal evolution multi-agent systems.
formalism enables quantification agents beliefs probability intervals
incorporates explicit notion time. discuss time agents dynamically
change beliefs facts, temporal rules, agents beliefs respect
new information receive. introduce appropriate formal semantics PDT Logic
show decidable. Alternative options specifying problems PDT Logic
possible. problem specifications, develop different satisfiability checking
algorithms provide complexity results respective decision problems. use
probability intervals enables formal representation probabilistic knowledge without
enforcing (possibly incorrect) exact probability values. incorporating explicit notion
time, PDT Logic provides enriched possibilities represent reason temporal
relations.

1. Introduction
Logical analysis knowledge belief active topic research diverse fields
philosophy (Hintikka, 1962), economics (Aumann, 1976), game theory (Harsanyi,
1967, 1968a, 1968b), computer science (Fagin, Halpern, Moses, & Vardi, 1995). Numerous extensions modal epistemic logic made reason knowledge
multi-agent settings (Fagin et al., 1995; Baltag & Moss, 2004), add probabilistic knowledge (Fagin & Halpern, 1994; Cripps, Ely, Mailath, & Samuelson, 2008), analyze
dynamic evolution knowledge (van Ditmarsch, van der Hoek, & Kooi, 2007).
realistic scenarios, agent incomplete inaccurate information
actual state world, thus considers several different worlds actually
possible. receives new information (e.g., observes facts currently
hold), update beliefs possible worlds consistent
new information. updates example result regarding (previously
considered possible) worlds impossible judging worlds likely
before. Thus, addition analyzing set worlds agent believes possible,
useful quantify beliefs terms probabilities. provides means
specify fine-grained distinctions range worlds agent considers possible
highly unlikely, worlds seem almost certainly actual world.
c
2016
AI Access Foundation. rights reserved.

fiMartiny & Moller

multiple agents involved setting, agent may varying
beliefs regarding facts actual world, regarding beliefs agents.
many scenarios, actions one agent depend belief ontic facts
(i.e., facts actual world), beliefs agents beliefs.
illustrate reasoning agents beliefs yield significant advantages
practical scenarios, start following informal description application
cyber security domain (a formal analysis example using PDT Logic
presented Martiny, Motzek, & Moller, 2015): Suppose adversary trying
break computer system. usually done attack graph detect
exploit potential vulnerabilities system. attack graph specifies set
paths (i.e., sequences actions) carry attack. Several paths attack graph
might used parallel, potentially different agents (for instance, number infected
computers controlled botnet). Usually, attack patterns specified one attack graph
used multiple times, two important ramifications: adversary learn
experience paths yield high probability successfully breaking
system. Defenders turn able gain knowledge attack graph
repeated observation certain patterns. Thus, system attack, defender
beliefs chosen attack paths adversarys belief regarding
success respective path. Thus, defender choose countermeasures effectively
reacting paths nested beliefs high indeed pose threat
according systems mission impact model.
formalize reasoning beliefs multi-agent settings, present Probabilistic Doxastic Temporal (PDT) Logic. PDT Logic builds upon recent work Annotated
Probabilistic Temporal (APT) Logic (Shakarian, Parker, Simari, & Subrahmanian, 2011;
Shakarian, Simari, & Subrahmanian, 2012) provides formalism enables representing reasoning dynamically changing quantified temporal multi-agent beliefs
probability intervals incorporates subset epistemic actions (Baltag & Moss,
2004). Using concepts APT Logic semantic foundation, PDT Logic merges work
epistemic logic recent work temporal logic Shakarian et al. Apart
reasoning imprecise probabilities, introduces temporal concept frequency
functions epistemic temporal logic.
Quantifying probabilistic knowledge probability intervals instead single probability values yields two main advantages. one hand, using probability intervals
significantly eases task formally representing existing knowledge human domain
expert. cases, domain expert give reasonable probability estimates
knowledge, inevitably fail giving correct precise numerical values probabilities. Consider instance weather forecast: people find easy give coarse
probabilistic quantifications chance rain high, virtually nobody
could quantify exact numerical value. Employing exact numerical values
formal representation would inevitably introduce errors probability model.
Thus, use probability intervals provides means express probabilistic knowledge
precisely possible without enforcing unrealistic precision. hand,
many scenarios probabilities (and even rough estimates them) simply unavailable, bounds values may known. illustrate this, consider scenario
described Ellsberg (1961):
40

fiPDT Logic

Example 1.1 (The Ellsberg paradox, Ellsberg, 1961). Imagine urn known contain
30 red balls 60 black yellow balls, latter unknown proportion. One ball
drawn random urn; following actions considered: Action
bet red, II bet black.
Now, easy see rational agent would believe action successful
probability 1/3. action II, quantification possible
respective probability unknown. Yet omitting probabilistic information action
II altogether would ignore available information unknown probability value,
namely somewhere 0 2/3. example exhibits two different types
uncertainty: former action subject risk, i.e., outcome unknown,
occurs known probability, later action subject ambiguity (also known
Knightian uncertainty), probability unknown (Bradley, 2015).
probability intervals, PDT Logic able work imprecise probabilities.
width probability interval give additional information certainty
probability quantification. Naturally, narrow interval associated high certainty
respective probability vice versa, wide interval associated low certainty.
PDT Logic employs explicit notion time thereby facilitates expression
richer temporal relations. allows analysis temporal doxastic problems
beyond scope previous work. resulting framework provides means reason
temporal evolution beliefs multi-agent systems. Two different applications
framework possible: First, agent respective multi-agent system
employ framework online run system reason beliefs.
analyzing nested beliefs introduced above, gives agent means reason
probable evolutions agents belief states. Second, framework used
offline external observer analyze whether desired evolutions given system
possible.
remainder work structured follows: next section presents related
work knowledge multi-agent systems APT Logic. Then, Section 3,
syntax PDT Logic introduced, followed definition formal semantics. Decision
algorithms complexity results PDT Logic discussed Section 4.
formally defined semantics based precise probability values, section shows
satisfiability PDT Logic decided even imprecise probabilities given.
Finally, paper concludes Section 5.

2. Related Work
Approaches formalize reasoning knowledge belief date back Hintikkas work
epistemic logic (Hintikka, 1962). Hintikka proposed represent knowledge sets
states worlds, together binary relation every agent, determine worlds
indistinguishable agent. approach sparked multiple branches research
epistemic logic, still active topics research today. branches research
broadly classified four (not mutually exclusive) areas relevant
work: multi-agent epistemic logic, probabilistic epistemic logic, epistemic temporal logic,
41

fiMartiny & Moller

dynamic epistemic logic.1 following, give overview key contributions
area discuss existing approaches merge fields research.
Early research epistemic logic culminated influential work Reasoning
Knowledge (Fagin et al., 1995), provides unified presentation various preceding
contributions epistemic logic. work uses so-called interpreted systems approach
represent knowledge multi-agent systems, time represented runs.
run sequence systems global states thus identifies state system
every time point. Among contributions, work provides notions multiagent epistemic modalities nested knowledge, distributed knowledge, common
knowledge.
Several works extended epistemic logic represent dynamic evolutions knowledge. direction research known Dynamic Epistemic Logic (DEL). first formal
analysis dynamics knowledge presented Plaza (1989; reprinted Plaza,
2007). contribution, Plaza introduces public communication events (now commonly
known public announcements) analyze dynamic evolution knowledge groups
upon truthful public announcements facts group agents. Independently
Plaza, related approach public announcement logic proposed Gerbrandy
Groeneveld (1997). Baltag, Moss, Solecki (1998) Baltag Moss (2004) generalize dynamic approach epistemic logic incorporate variety complex epistemic
actions. Here, epistemic updates represented Kripke models.
extends dynamic epistemic logic represent variety additional epistemic actions
private group announcements (i.e., announcements agents outside receiving
group unaware announcement), lies (i.e., untruthful announcements), combinations thereof. PDT Logic, use public private group announcements,
assume announcements truthful. thorough treatment dynamic epistemic
logic given van Ditmarsch et al. (2007). Van Eijck (2014) provides recent overview
field.
alternative approach modeling evolution knowledge combine epistemic
logic temporal system. One example aforementioned interpreted
systems Fagin et al. (1995). Another approach modeling temporal aspects epistemic logic proposed Parikh Ramanujam (2003). approach known
Epistemic Temporal Logic (ETL). Here, possible situations represented sets
histories, local histories every agent, represent respective agents previous
observations. Based histories, knowledge based semantics messages defined,
shown messages vary meaning, depending respective context
messages receiver. temporal model employ PDT Logic closely related
epistemic temporal logic. Instead specifying local histories every agent, define
semantics PDT Logic respect global history. However, local contexts
1. simplify following discussion, explicitly distinguish epistemic doxastic
logics section, use epistemic general term. Strictly speaking, epistemic formalisms
deal knowledge, doxastic formalisms deal beliefs. usual axiomatic definition
knowledge literature uses Truth Axiom, stipulates agent know true
facts. Omitting axiom leads notion belief. Even though unanimously accepted
(cf. e.g., Halpern, Samet, & Segev, 2009), axiom usually considered key distinction
knowledge belief.

42

fiPDT Logic

sense ETL easily extracted global history filtering history
respective agents observations.
traditional work epistemic logic discussed far allow quantify
agents degree belief certain facts; specified whether agent
know (resp. believe) fact. remove limitation, several approaches
proposed combine logics knowledge belief probabilistic quantifications.
Fagin Halpern (1994) laid foundation combination seminal paper.
define belief operator quantify lower bounds probabilities agent
assigns formula. modeled associating probability space state
agent. framework, generally guaranteed formulae define
measurable sets, present properties guarantee measurability
sets. contrast, semantics defined PDT Logic always produces events
measurable probabilities. special case framework introduced Fagin Halpern
presented Milch Koller (2000). PDT Logic, formalism
assumed (i) exists common prior probability distribution set worlds
(ii) agents local probability distribution world derived
global distribution conditioned respective set worlds agent considers possible.
additional feature Milch Koller models represented Bayesian
networks find probabilities defined formulae. Van der Hoek (1997) introduces
logic PF D, later extended de Carvalho Ferreira, Fisher, van der Hoek
(2008). Fagin Halpern, framework introduces operator quantify
lower bounds probabilistic beliefs. Probabilistic values work semantically
restricted finite base set probability values, yielding logically compact framework
enables efficient implementations.
variety approaches proposed extend probabilistic epistemic logics
dynamic frameworks: Kooi (2003) restricts probabilistic epistemic logic Fagin
Halpern (1994) finite settings combines dynamic epistemic logic
Gerbrandy Groeneveld (1997) create Probabilistic Dynamic Epistemic Logic
(PDEL). work analyzes effects probabilistic beliefs upon public announcements.
framework based dynamic epistemic logic, capabilities
represent temporal relationships; features regarding past cannot expressed all,
features regarding future expressed limited extent result
certain actions. Van Benthem (2003) extends framework analyze results
various epistemic actions described Baltag et al. (1998). Another extension
framework proposed van Benthem, Gerbrandy, Kooi (2009b), different
sources probabilities distinguished. simplification approach presented
van Eijck Schwarzentruber (2014). paper distinguishes work
probabilistic epistemic logic certainty equated knowledge. works
make explicit distinction belief probability 1 knowledge. difference
two concepts often illustrated repeatedly throwing fair coin:
event coin shows head least 1 infinite number repetitions.
Yet agent know example coin eventually show head. PDT
Logic works countable models finite time frames, adopt view
van Eijck Schwarzentruber consider certainty knowledge equivalent
models. Deviating approaches extend epistemic logic probabilities, PDT
43

fiMartiny & Moller

Logic provides belief operator probability interval quantifications, lower
upper bounds probability values specified explicitly. provides
natural means represent imprecise probabilities discussed introduction.
Another direction probabilistic extensions discussed Halpern Pucella (2006)
Doder, Markovic, Ognjanovic, Perovic, Raskovic (2010), example. approaches consider problem estimating unknown prior probabilities based given
evidence. Essentially, unknown priors represented set hypotheses,
likelihood hypothesis given specific observations estimated. approaches,
hypotheses represent possible configurations world thus satisfiable.
contrast, aim PDT Logic verify whether possible assignment priors exists
given set formulae satisfiable.
dynamic epistemic logic, possible reason step-wise changes
future. order reason temporal relations, Sack (2008) extends update
mechanism dynamic epistemic logic temporal operators, namely previous-time
next-time operators. Sack (2009) extends approach probabilistic frameworks augmenting work probabilistic dynamic epistemic logic (Kooi, 2003)
previous-time operator ability reason continuous probabilities.
approaches enrich dynamic epistemic logic ability reason events
past. Van Benthem, Gerbrandy, Hoshi, Pacuit (2009a) give systematic precise
comparison ETL (called TEL van Benthem, Gerbrandy, Hoshi, Pacuit)
DEL shown approaches merged single framework.
Shakarian et al. (2011) Shakarian et al. (2012) introduce APT Logic, framework
represent probabilistic temporal evolutions worlds threads. APT Logic assigns
prior probabilities every thread uses probabilities determine probabilities
events occurring specific threads. represent temporal relationships events,
APT Logic introduces concept frequency functions. utilize approach APT
Logic create doxastic multi-agent framework supports explicit reasoning
temporal relationships adoption frequency functions. explicit
notion time formalism increases complexity decision problems, significantly
enhances expressibility temporal relations. instance, contrast approaches
implicit representations time, PDT Logic able specify events occur
within certain time interval (cf. introduction frequency functions below).

3. PDT Logic: Syntax Semantics
section, discuss beliefs multi-agent systems formalized. start
defining syntax PDT Logic, discuss employed model time, provide
formal semantics. proposed formalism enables expression different types
beliefs quantify beliefs using imprecise probabilities. introducing suitable
update rule show agents beliefs evolve time agents update
beliefs new information correctly integrated belief state.
44

fiPDT Logic

3.1 Syntax
assume existence function-free quantifier-free fragment first order logic2
language L finite sets constant symbols Lcons predicate symbols Lpred ,
infinite set variable symbols Lvar . Every predicate symbol p Lpred arity. term
member set Lcons Lvar . term called ground term member
Lcons . t1 , .., tn (ground) terms, p predicate symbol Lpred arity n,
p(t1 , ..., tn ) (ground) atom. (ground) atom, (ground)
literals. former called positive literal, latter called negative literal. set
ground literals denoted Llit . usual, B denotes Herbrand Base L, i.e.,
set ground atoms formed Lpred Lcons .
Time modeled discrete steps assume agents reason arbitrarily large, fixed-size window time. set time points given = {1, ..., tmax }.
set agents denoted A. Again, assume set may arbitrarily large,
finite size. describe agents observe, define observation atoms follows.
Definition 3.1 (Observation atoms). non-empty group agents G
ground literal l Llit , ObsG (l) observation atom. set observation atoms
denoted Lobs .
Intuitively, meaning statement form ObsG (l) agents group
G observe fact l holds. Note l may negative literal therefore
explicitly specify observations certain facts false (such raining).
assume agents G observe l holds, agent G
aware agents G make observation. line Baltag Moss
(2004), observations viewed effects private group announcements fact
l group G (i.e., l becomes common knowledge within G, agents outside G
remain entirely oblivious observation): represents epistemic action, i.e., alters
belief states agents G (as formally defined below), influence
ontic facts respective world.
Definition 3.2 (Formulae). atoms observation atoms formulae. F G
formulae, F G, F G, F formulae. formula ground atoms
formula ground.
Example 3.1 (Coin toss). Consider two agents 1, 2 coin tossed. event
coin lands heads denoted primitive proposition Head, accordingly,
coin lands tails denoted Head. Let us assume coin actually lands heads.
Then, sets possible observations scenario {Obs{1} (Head)}, {Obs{2} (Head)},
{Obs{1} (Head), Obs{2} (Head)}, {Obs{1,2} (Head)}.
Note difference third fourth set: former
scenario, agents observe outcome coin throw unaware
agent actually made observation. latter scenario, agents observe
outcome aware agent observes same. Since allow
2. use first order structure language definition syntactically convenient way
representing observations. Apart this, propositional logic could used base language.

45

fiMartiny & Moller

nesting observations (i.e., expressions ObsG1 (ObsG2 (l))) PDT Logic,
subset epistemic actions discussed Baltag Moss (2004) represented
formalism. limits expressivity epistemic actions extent,
ensure resulting set possible observations Lobs always finite therefore
show PDT Logic decidable (as shown Section 4). Further, note
formal concept observations limited express passive acts observing facts,
instead used model wide range actions: instance, example
one could use Obs{1,2} (Head) model act one agent telling
outcome coin throwthe ramifications communication act exactly
would shared observation (assuming agents lie).
express temporal relationships, define temporal rules following approach
APT rules Shakarian et al. (2011). definition temporal rules already relies
concept frequency functions, even though defined next section.
still introduce temporal rules enable clearly separated presentation syntax
semantics PDT Logic.
Definition 3.3 (Temporal rules). Let F, G two ground formulae, time interval,
fr (F, G)
fr name frequency function (as defined Section 3.2.5). rt
called temporal rule.
Frequency functions provide information temporal connections events.
fr (F, G) understood F followed G
meaning expression rt
time units w.r.t. frequency function fr. Frequency functions enable specification
various types temporal relations. example, used determine often
F followed G within time units often F followed G exactly
time units. usage fr syntax temporal rules used specify set possible
names employed types frequency function.
`,u
`,u
Now, define belief operator Bi,t
0 express agents beliefs. Intuitively, Bi,t0 ()
means time t0 , agent believes fact true probability p [`, u].
Particularly, intuitive meaning belief temporal rule agent believes
fr (F, G), given F holds time point. call
G hold according rt
probability interval [`, u] quantification agent belief. use Ft denote
formula F holds time and, accordingly, ObsG (l)t denote observation
ObsG (l) occurs time t. call expressions time-stamped formulae timestamped observation atoms, respectively.
Definition 3.4 (Belief formulae). Let agent, t0 time point, [`, u] [0, 1].
Then, belief formulae inductively defined follows:
`,u
1. F ground formula time point, Bi,t
0 (Ft ) belief formula.
fr (F, G) temporal rule, B `,u (r fr (F, G)) belief formula.
2. rt
i,t0
`,u
3. F G belief formulae, Bi,t
0 (F ), F G , F G , F .
`,u
belief Bi,t
0 () something, call belief object. Belief operators
`,u
atomic elements PDT Logic, i.e., expression Bi,t
0 () (including possibly nested belief

46

fiPDT Logic

formulae) called atom. use script fonts (e.g., F ) distinguish belief formulae
standard formulae. Note ontic facts observation atoms
standard formulae (cf. Definition 3.2) therefore agents beliefs
possible observations.
use probability intervals [`, u] provides option represent imprecise probabilities (Bradley, 2015): using imprecise probabilities, usually assumed
degree belief proposition represented using single probability function p(), instead set P functions. Then, belief state P ()
proposition represented set
P () = {p() : p P }.
set probabilities P (), so-called lower upper envelopes defined P () =
inf P () P () = sup P (), respectively. belief quantifications belief operator
represent imprecise probabilities ` u values probabilistic belief
considered lower upper envelopes P P respective imprecise probability.
`,u
Remark 3.1. decided index belief operators Bi,t
0 () facts Ft appearing
belief objects time stamps allow concise representation temporal
relations. Alternatively, one could use traditional approach (cf. Sack, 2009
example) introduce previous-time next-time operators language express
`,u
temporal relationships t0 Bi,t
0 (Ft ). Then, could omit temporal
0
index belief operator instead evaluate whether belief holds time t0
model. However, merely syntactic considerations impact
underlying formalism. Thus decided encode time explicitly belief operators
avoid introduction additional temporal operators. Moreover, belief operators
used express general temporal relationships modeled domain.
illustrate point detail Section 4.

3.2 Semantics
section, provide formal semantics PDT Logic captures intuitions
explained above. ease understanding presentation, start introduction
example, return repeatedly introducing various concepts
semantics. illustration formalisms features, use simplified exemplary
domain. practical use example somewhat limited, serves illustrate
PDT Logic applied, especially analysis multi-agent beliefs
yield valuable information deciding meaningful actions. resulting insights
easily applied sophisticated domains.
Example 3.2 (Trains). Let Alice Bob two agents living two different cities CA
CB , respectively. Suppose Alice wants take train visit Bob. Unfortunately,
direct connection cities CA CB , Alice change trains
third city CC . assume train T1 connects CA CC , train T2 connects CC
CB . trains usually require 2 time units trip, might running late
arrive one time unit later scheduled. Alice requires one time unit change trains
city CC . T1 runs time, direct connection T2 , otherwise wait
47

fiMartiny & Moller

two time units next train T2 leaves city CC . train running late,
call Bob let know. calls modeled shared observations
Alice Bob. instance, Alice wants tell Bob train T1 running late (i.e., T1
arrive CC expected time), modeled Obs{AB} (at(T1 , CC ))
expected arrival time.
3.2.1 Possible Worlds
Ontic facts corresponding observations (e.g., described example) form
worlds (or states terminology Fagin et al., 1995). world consists set
ground atoms set observation atoms, i.e., 2BLobs .3 use
ObsG (l) denote atom a, resp. observation atom ObsG (l), holds world .
Since agents observe facts actually hold respective world, define
admissibility conditions worlds w.r.t. set observations:
Definition 3.5 (Admissible worlds). world admissible, iff every observation atom
ObsG (l)
1. observed fact holds, i.e., x l positive literal x, x 6 l negative
literal x,
2. every subgroup G 0 G, ObsG 0 (l) .
use adm() denote world admissible.
set possible worlds denoted set admissible worlds .
following discussion section assume specification given.
possible employ usual definition set combinations
ground atoms observation atoms ( = 2BLobs ), maximum subset
complying Definition 3.5, usually contains vast number worlds
blatantly impossible according respective problem modeled. Therefore, assume
succinct specification set admissible worlds depending respective domain
given. main reason assumption simplify following presentationwe
describe method obtain set algorithmically Section 4.
Remark 3.2. already discussed Section 3.1, group observations ObsG (l) every
agent G aware agents G observed fact. Together
Definition 3.5, semantics observations equivalent usual semantics
common knowledge. Fagin et al. (1995) give definition common knowledge
fixed-point axiom: fact l common knowledge among group G members
G know l true common knowledge. Thus, could equivalently use
established common knowledge operator CG (l) instead previously defined observation
3. formalisms epistemic logic encode facts directly worlds, instead use set
named states s1 , s2 , ... valuation function (si ) determine facts hold world si (cf.
Fagin et al., 1995). mainly done obtain option multiple worlds si , sj
facts hold (i.e., (si ) = (sj )), knowledge states agents differ. described below,
PDT Logic worlds appear within threads, thus possible worlds valuation
appear time point multiple threads. Thus, formalism encode facts directly
possible worlds save valuation function without limiting epistemic expressivity.

48

fiPDT Logic

atoms ObsG (l). However, concept common knowledge usually used describe
emergent states agents knowledge. hand, context approach,
observations extrinsic feature result emergence belief states.
keep clear distinction intended use operator, therefore continue
use ObsG (l) instead CG (l).
Example 3.3 (Trains continued). Example 3.2, ground terms A, B, CA , CB ,
CC , T1 , T2 , representing Alice, Bob, three cities, two trains. Furthermore,
atoms on(y, x) indicating person train x, at(x, z) indicating train x
city z. Finally, observation atoms kind ObsG (at(x, z)), indicating
agents G observe train x station z. possible world example
1 = {at(T1 , CA ), on(A, T1 ), Obs{A} (at(T1 , CA ))}, indicating train T1 city CA
boarded train.
define satisfaction ground formula F world usual way (Lloyd,
1987):
Definition 3.6 (Satisfaction ground formulae). Let F, F 0 , F 00 ground formulae
world. Then, F satisfied (denoted |= F ) if:
case F = ground atom a:
.
case F = F 0 ground formula F 0 :

case F = F 0 F 00 formulae F 0 F 00 :

case F = F 0 F 00 formulae F 0 F 00 :

6|= F 0 .

|= F 0 |= F 00 .

|= F 0 |= F 00 .

say formula F tautology |= F admissible worlds .
say formula F contradiction world |= F . use
usual symbols > denote tautologies contradictions, respectively.
3.2.2 Threads
model temporal evolutions problem domain use definition threads
Shakarian et al. (2011):
Definition 3.7 (Thread). thread h mapping set time points
set admissible worlds: h :
Thus, thread sequence worlds h(t) identifies actual world time
according thread h. set possible threads (i.e., possible sequences constructible ) denoted . Again, refrain directly working
, instead assume meaningful problem specification gives information
possible temporal evolutions system. use represent set relevant possible threads. notational convenience, assume additional prior world
h(0) every thread.
Following Definition 3.6, use h |= Ft denote thread h satisfies formulae F
time (i.e., h |= Ft h(t) |= F ). Accordingly, use |= Ft denote every
thread h satisfies formula F time t.
49

fiObs{A}
at(T1 , CC )
(at(T1 , Cc ))
on(A, T1 ) on(A, T1 ) on(A, T1 ) on(A, T1 )

Obs{A,B}
at(T1 , CC )
(at(T1 , Cc ))
on(A, T1 ) on(A, T1 ) on(A, T1 ) on(A, T1 )

Obs{A}
at(T1 , CC )
(at(T1 , Cc ))
on(A, T1 ) on(A, T1 ) on(A, T1 ) on(A, T1 )

1 2 h7

1 2 h6

h5

h4

1

1

hi

h1

2 h2
on(A, T1 )
at(T1 , CC )
on(A, T1 )

on(A, T1 ) on(A, T1 )
at(T1 , CA )
on(A, T1 ) on(A, T1 )

3

at(T1 , CC )

at(T1 , CA )

2

on(A, T1 )

on(A, T1 ) on(A, T1 )

1

at(T1 , CC )

at(T1 , CA )

at(T1 , CA )

at(T1 , CA )

at(T1 , CA )

at(T1 , CA )

on(A, T2 )

on(A, T2 )

on(A, T2 )

on(A, T2 )

4
1

5

on(A, T2 ) on(A, T2 )

at(T2 , CC )

at(T2 , CC )

6

on(A, T2 )

at(T2 , CB )

7

Obs{A}
at(T2 , CB )
(at(T2 , CB ))
on(A, T2 ) on(A, T2 ) on(A, T2 ) on(A, T2 )

at(T2 , CC )

8

at(T2 , CB )

at(T2 , CC )
on(A, T2 )

at(T2 , CB )
on(A, T2 )

9



Obs{A}
at(T2 , CB )
(at(T2 , CB ))
on(A, T2 ) on(A, T2 )
on(A, T2 )

Obs{A}
at(T2 , CB )
(at(T2 , CB ))
on(A, T2 ) on(A, T2 )
on(A, T2 )

Obs{A,B}
at(T2 , CB )
(at(T2 , CB ))
on(A, T2 ) on(A, T2 )
on(A, T2 )

Obs{A,B}
at(T2 , CB )
(at(T2 , CB ))
on(A, T2 ) on(A, T2 )
on(A, T2 )

at(T2 , CC )

on(A, T2 )

at(T2 , CC )

on(A, T2 )

at(T2 , CC )

on(A, T2 )

at(T2 , CC )

on(A, T2 )

at(T2 , CC )

Obs{A,B}
at(T2 , CB )
(at(T2 , CB ))
on(A, T2 ) on(A, T2 ) on(A, T2 ) on(A, T2 )

Obs{A,B}
at(T1 , CC )
(at(T1 , Cc ))
on(A, T1 ) on(A, T1 ) on(A, T1 ) on(A, T1 )

2 h3

Obs{A}
at(T1 , CC )
(at(T1 , Cc ))
on(A, T1 ) on(A, T1 ) on(A, T1 ) on(A, T1 )

1 2 h8

at(T1 , CA )

Obs{A,B}
at(T1 , CC )
(at(T1 , Cc ))
on(A, T1 ) on(A, T1 ) on(A, T1 ) on(A, T1 )

at(T1 , CA )

1 2 h9

Martiny & Moller

Figure 1: Visualization possible threads hi Example 3.2. easier distinction, shared observations B marked blue, single observations
marked red, situations Alice train 1 train 2
marked green orange, respectively. Note train running late
(the respective threads marked according circles), always two
possible threads: one observes one share
observation.
50

fiPDT Logic

assume system synchronous, i.e., agents global clock. Thus,
even agent observe anything world h(t), still aware time passing
therefore distinguish worlds h(t) h(t 1).
Example 3.4 (Trains continued). description Example 3.2 (p. 47) yields
set possible threads depicted Figure 1. Note manually specified set
threads containing threads comply description Example 3.2.
set possible threads would contain vast number additional threads
irrelevant described scenario.
3.2.3 Kripke Structures
definition threads, use slightly modified version Kripke structures
(Kripke, 1963). usual, define Kripke structure tuple h, K1 , ..., Kn i,
set admissible worlds binary relations Ki every agent A. Thus,
Kripke relation (also called possibility relation) agent world defined
Ki () = { 0 : (, 0 ) Ki }

(1)

Intuitively, (, 0 ) Ki specifies world , agent considers 0 possible
world. words, current information agent unable distinguish worlds
0 .
initialize Kripke structure threads considered possible time
= 0:
[
h : Ki (T h(0)) =
{T h0 (0)},
(2)
h0

evolution time, agent eliminate worlds comply
respective observations. elimination worlds, agent reduce
set threads considers possible (ifdue observationa world considered
impossible time point t, threads h h(t) = considered impossible).
assume agents perfect recall therefore consider thread
possible considered impossible one point. Thus, Ki updated w.r.t.
agents respective observations, considers threads possible comply
current observations considered possible previous time point:

Ki (T h(t)) = h0 (t) : h0 (t 1) Ki (T h(t 1))

{ObsG (l) h(t) : G} = {ObsG (l) h0 (t) : G}
(3)
following two corollaries describe key properties Ki follow immediately
definitions (2) (3):
Corollary 3.1 (Equivalence relation). Ki defines equivalence relation possible
worlds Ki (T h(t)) time points .
Corollary 3.2 (Reduction considered threads). set threads h0 considered possible
w.r.t. Ki narrowing smaller smaller subset time, i.e., {T h0 : h0 (t)
Ki (T h(t))} {T h0 : h0 (t 1) Ki (T h(t 1))} h .
51

fiMartiny & Moller

Note updates Ki defined new information incorporated instantaneously, i.e., time agent observes fact, updates possibility relations
already time considers every world impossible comply
observation time t.
Example 3.5 (Trains continued). Figure 1, obtain time 1,
possible world {at(T1 , CA ), on(A, T1 )}, contained possible threads. Thus,
Ki (T hj (1)) contains exactly world agents threads j. Consequently,
agents consider threads possible time 1.
Now, assume time evolves two steps actual thread h4 (i.e., train
T1 running late, inform B this). agents update
possibility relations accordingly, yielding
KA (T h4 (3)) = {{Obs{A} (at(T1 , CC )), on(A, T1 )}}

KB (T h4 (3)) = {{at(T1 , CC ), on(A, T1 )}, {Obs{A} (at(T1 , CC )), on(A, T1 )}},
i.e., knows T1 time, B unaware T1 late, since still
considers situation possible train T1 city CC time = 3.
3.2.4 Subjective Posterior Temporal Probabilistic Interpretations
agent probabilistic beliefs expected evolution time. expressed subjective temporal probabilistic interpretations:
Definition 3.8 (Subjective posterior probabilistic temporal interpretation). Given set
possible threads , thread Th , time point t0 > 0 agent i, function
Th : [0, 1] specifies subjective posterior probabilistic temporal interpretation
Ii,t
0
agent point view time t0 thread Th, i.e., probability distribution possible
P
Th (T h) = 1. Since probabilistic interpretations possible threads
threads: hT Ii,t
0
depend respective perspective agent i, Th marks point view subjective

interpretation. Thus, call Th point view (pov) thread interpretation h0 .
i,t

concept point view threads seen conditional probabilities: subjecTh specifies agent probabilistic interpretation
tive posterior probabilistic interpretation Ii,t
0
time t0 given Th actual thread. Different threads yield different evolutions
world andsince every possible thread taken pov thread may induce
different probabilistic interpretations agent. Thus, notion pov threads allows
reason hypothetical beliefs agent, instance possible future beliefs
analyzed nested beliefs evaluated.
Th vector occasionally represent probabilistic
simplify notation, see Ii,t
0


h vector possible threads vector well, jth
interpretation Ii,t
0


h refers probability assigned thread h .
element Ii,t
0
j



h (T h). Since
prior probabilities agent threads given Ii,0
threads indistinguishable priori, single prior distribution needed

52

fiPDT Logic

0



0

h (T h) = h (T h)). Furthermore, order
agent (i.e., h, Th, Th : Ii,0
i,0
able reason nested beliefs (as discussed below), assume prior
probability assessments agents commonly known (i.e., agents know
agents assess prior probabilities thread). turn requires
agents exactly prior probability assessment possible threads: two
agents different, commonly known prior probability assessments, essentially
instance Aumanns well-known problem agreeing disagree (Aumann,
1976). Intuitively, differing priors commonly known, common knowledge
(at least) one agents fault revise probability assessments.
result, one prior probability distribution viewpoints,
denoted I. Note directly corresponds concept temporal probabilistic
interpretations Shakarian et al. (2011).

Remark 3.3. could use prior probability distribution alternative method
distinguish set possible threads set threads relevant
specific problem domain. so, simply assign unwanted threads h 6
probability zero.
Example 3.6 (Trains continued). meaningful prior interpretation

I(T ) = 0.7 0.02 0.09 0.02 0.09 0.01 0.02 0.02 0.03 ,
assigns highest probability h1 (no train running late), lower probabilities
threads one train running late informs B (T h3 h5 ), even lower
probabilities events either trains running late informs B (T h7 ,
h8 , h9 ) one train running late inform B (T h2 h4 ),
lowest probability thread trains running late
inform B (T h6 ). Note represents prior interpretation train example
thus every agent every possible pov thread Th.
Even though single prior probability distribution set possible
threads, still necessary distinguish viewpoints different agents different
threads, following definition interpretation updates shows.
Whenever agent updates Kripke relations according Equation (3) (p. 51),
necessary update probabilistic interpretations agent match new
knowledge. intuitive way update probabilities conditioning remaining
worlds agents Kripke structure. want point conditioning suitable
choice PDT Logic, although known produce undesired incorrect results
many cases, notably Monty Hall problem (vos Savant, 1990). Grunwald
Halpern (2003) discuss naive conditioning tends produce errors updates
carried simplified space several events collapsed since seemingly
one event. one uses so-called sophisticated conditioning instead (i.e., conditioning
sophisticated space, means possible events represented), probabilities
updated correctly. semantics PDT Logic based exhaustive specification
relevant threads, conditioning proper specification relevant threads inherently
sophisticated sense Grunwald Halpern therefore produce correct
results. One easily verify following update rule, well-known probability
53

fiMartiny & Moller

puzzles Monty Hall Problem correctly represented PDT Logic. Thus,
use following conditioning-based update rule:
Definition 3.9 (Interpretation update). Let agent, t0 time point, Th pov
thread. Then, system actually thread Th time t0 , agent probabilistic
interpretation set possible threads given update rule:

Th (T h) h(t0 ) K (Th(t0 ))
1 Ii,t
0 1

h
Th

0
i,t
Ii,t0 (T h) =
(4)
0
h(t0 ) 6 Ki (Th(t0 ))


1
h

i,t0

normalization factor ensure


X

Th
i,t
0 =

hT ,

P



hT

h (T h) = 1:
Ii,t
0



Th
Ii,t
0 1 (T h)

(5)

h(t0 )Ki (Th(t0 ))

invocation Ki update rule yields obvious ramifications evolution
interpretations, stated following corollary:
Corollary 3.3 (Nonzero probabilities). subjective temporal probabilistic interpretation
Th agent assigns nonzero probabilities exactly set threads still
Ii,t
0

considers possible time t0 , i.e., h0 (T h) > 0 iff (T h(t), Th(t)) Ki
i,t

Essentially, update rule assigns impossible threads probability zero
scales probabilities remaining threads proportional
probabilities previous time point. given prior probability distribution
Th specific pov thread
set possible threads, subjective posterior probabilities Ii,t
0
0

h agents time points induced respective observations contained


Th. use h denote set subjective posterior interpretations h0 induced
i,t

pov thread Th.

Example 3.7 (Trains continued). Applying update rule (4) situation
described Example 3.5 (p. 52), given Example 3.6, yields updated
interpretation A:


h4
IA,3
= 0 0 0 0.4 0 0.2 0 0.4 0



(6)

i.e., considers exactly threads possible, train running late
inform B (threads h4 , h6 , h8 ). Due lack new information, B
eliminate situations indeed inform late time
point 3, thus Bs interpretation updated to:

Th4
IB,3
0.82 0.02 0.10 0.02 0 0.02 0 0.02 0 .
54

(7)

fiPDT Logic

h(1)

h(2)

h(3)

h(4)

h(5)

h(6)

h(7)

h(8)

F

G

F

G

G

F

G

F

Figure 2: Example thread h = {1, ..., 8}, adopted Shakarian et al. (2011).
figure shows world satisfies formula F formula G.

3.2.5 Frequency Functions
represent temporal relationships within threads, adapt concept frequency functions introduced Shakarian et al. (2011). Frequency functions provide flexible way
representing temporal relations occurrences specific events. illustrate
motivation behind using frequency functions, consider exemplary thread h depicted
Figure 2. thread, one events F G occurs every time point = 1
= 8. discussed Shakarian et al., multiple ways characterizing temporal
relationships events F G: instance, one might specify often event
F followed event G in, say, exactly 2 time points. According Figure 2, happens
one four occurrences F h. might prove meaningful exclude final
occurrence F h determining frequency, naturally occurrence
F tmax cannot followed subsequent occurrence G. Excluding final
occurrence F would yield one three desired frequency. Alternatively, one
could specify often F followed G within next two time points.
exemplary thread Figure 2, would produce frequencies 1 0.75 respectively,
depending whether final occurrence F included.
example illustrates already four different possible definitions temporal relations
events. maintain flexibility expressing temporal relations, commit specific definitions PDT Logic, instead adapt axiomatic definition
frequency functions:
Definition 3.10 (Frequency functions, adapted Shakarian et al., 2011). Let h
thread, F , F 0 , G, G0 ground formulae, 0 integer. frequency
function fr maps quadruples form (T h, F, G, t) [0, 1] following
axioms hold:
(FF1) (F G) tautology, fr(T h, F, G, t) = 1.
(FF2) (F G) contradiction, fr(T h, F, G, t) = 0.
(FF3) (F G) neither tautology contradiction, exist threads h1 ,
h2 fr(T h1 , F, G, t) 6= fr(T h2 , F, G, t).
(FF4) F F 0 G G0 , fr(T h, F, G, t) = fr(T h, F 0 , G0 , t).
Axioms (FF1) (FF2) ensure special casesi.e., (G >), (F ),
(F >, G )frequency functions behave temporal implications premise
F conclusion G. Axiom (FF3) enforces non-trivial frequency functions requiring
cases covered first two axioms, must least two threads
55

fiMartiny & Moller

differing frequency values. Axiom (FF4) ensures fr congruent logical
equivalence. Examples frequency functions satisfying axioms introduced below.
Remark 3.4. definition mostly corresponds definition frequency functions
Shakarian et al. (2011), except require > 0. work
Shakarian et al., frequency functions intended express temporal relationships
therefore limited nonzero values. additionally allowing = 0, obtain
concise framework express temporal relationships static constraints
within one time point. exploited next section, decision procedures
PDT Logic discussed.
illustrate concept frequency functions, present formal definitions
point existential frequency functions adapted Shakarian et al. represent
informal descriptions frequencies above:
point frequency function pfr expresses frequently event F followed
another event G exactly time units:
pfr(T h, F, G, t) =

|{t : h(t) |= F h(t + t) |= G}|
|{t : (t tmax t) h(t) |= F }|

(8)

denominator zero, define pfr 1. denominator counts total number
occurrences F given thread h numerator counts number occurrences
F followed G exactly time units. Thus, ratio pfr expresses frequently
F followed G exactly time units. Note denominator considers
occurrences F time tmax t. done reflect previously discussed
intuition occurrences F last time points excluded
frequency, possibility followed subsequent G
time units.
existential frequency function efr expresses frequently event F followed
another event G within next time units:
efr(T h, F, G, t) =
efn(T h, F, G, t, 0, tmax )
,
|{t : (t tmax t) h(t) |= F }| + efn(T h, F, G, t, tmax t, tmax )

(9)


efn(T h, F, G, t, t1 , t2 ) =|{t : (t1 < t2 ) h(t) |= F

t0 [t, min(t2 , + t)] (T h(t0 ) |= G)}|

function ef n counts number occurrences F followed subsequent occurrence
G within next time units. first summand denominator counts
total number occurrences F time point tmax t. second summand
denominator, additional occurrences F followed G within time units.
intuition definition exclude occurrences F final time units
followed G. Since G may occur within range t, range cannot
fully considered final time points, occurrences F according
subsequent occurrence G considered final time points. Consequently,
56

fiPDT Logic

ratio efr expresses frequently event F followed G within next time
units without letting single occurrences F final time points decrease ratio.
Returning exemplary thread h Figure 2, evaluate frequency
functions given thread: Suppose want determine often F followed
G exactly two time steps. expressed point frequency function:
1
pfr(T h, F, G, 2) = .
3
instead want know often F followed G within next two time steps,
use existential frequency function:
efr(T h, F, G, 2) =

3
=1
3

noted frequency functions used model temporal relationships
usually expressed temporal operators. instance, pfr = 1 reflects
next operator efr = tmax reflects future operator. meaning
additional temporal operators captured definition
additional frequency functions, required.
3.2.6 Semantics Belief Operator
Now, definitions subjective posterior probabilistic temporal interpretations
introduction frequency functions, provide formal semantics belief operators defined Section 3.1. semantics extends definitions Shakarian
et al. (2011) satisfiability static interpretations obtain formal definition
probabilistic multi-agent beliefs. start providing definition semantics
atomic belief operators three different types beliefs. Semantics compound belief
formulae (i.e., involving connectives , , ) defined Definition 3.16.
Definition 3.11 (Belief Semantics atomic belief operator). Let agent
Th agent interpretation time t0 pov thread Th. Then, follows
Ii,t
0
interpretation agent believes time t0 probability range [`, u]
1. (Belief ground formulae)
Th |= B `,u (F )) iff
formula F holds time (denoted Ii,t
0

i,t0
`

X
hT ,T h(t)|=F



Th
Ii,t
0 (T h) u.

(10)

2. (Belief rules)
fr (F, G) holds (denoted Th |= B `,u (r fr (F, G))) iff
temporal rule rt
i,t0
i,t0
`

X
hT



Th
Ii,t
0 (T h) fr(T h, F, G, t) u.

57

(11)

fiMartiny & Moller

3. (Nested beliefs)
` ,u
belief Bj,tj j () agent j holds time t0 (denoted


` ,u

h |= B `,u (B j j ())) iff
Ii,t
0
j,t
i,t0

`



X
hT
` ,u
h |=B j j ()
Ij,t
j,t

Th
Ii,t
0 (T h) u.

(12)

intuition behind semantics follows. beliefs ground formulae Ft ,
Th (T h) agent time t0 pov thread Th
subjective posterior probabilities Ii,t
0
added threads h satisfy F time t. Thus, sum (10) represents
Th assigns F . sum within specified boundaries [`, u],
exact probability Ii,t
0

`,u
respective belief B 0 (Ft ) holds agent time t0 pov thread Th.
i,t



h (T h) every thread
beliefs rules, subjective posterior probabilities Ii,t
0
fr (F, G). Thus,
weighted corresponding frequency fr(T h, F, G, t) rule rt

h (T h) (11) represents exact probability Th assigns
weighted sum Ii,t
0
i,t0
temporal relation F G according frequency function fr. beliefs
fr (F, G) contains information type frequency
rules, belief object rt
function fr, constraints respective frequency values given belief
quantification [`, u], i.e., agent probabilistic beliefs specific frequency
values.

Remark 3.5. noted semantics beliefs rules (11) together
axiomatic definition frequency functions Definition 3.10 (p. 55) yields certain
fr (F, G). G tautology F contradiction
constraints satisfiable beliefs rules rt
(i.e., Definition 3.10 FF1 satisfied), holds respective frequency function
`,u fr
fr(T h, F, G, t) = 1 every possible thread h, thus, belief Bi,t
0 (rt (F, G))
satisfiable belief quantified u = 1, regardless set threads
Th . Analogously, F tautology G
corresponding interpretation Ii,t
0
`,u fr
contradiction (i.e., FF2 satisfied), belief Bi,t
0 (rt (F, G)) satisfiable ` = 0.
` ,u

`,u
j j
nested beliefs Bi,t
()), expression unnested first determining
0 (Bj,t
` ,u

` ,u

possible pov threads h agent j Bj,tj j () satisfied. Bj,tj j () corresponds
belief fact rule, (10) respectively (11) used identify threads h
h |= B `j ,uj (). Otherwise, represents another belief formula, belief
Ij,t
j,t
unnested recursively innermost belief expression obtained. Then,
h |= B `j ,uj (), agent subjective posterior probabilities Th (T h)
threads h Ij,t
j,t
i,t0
added determine whether outer belief holds. Note agent
know actual beliefs agent j. However, due assumption common equal
priors discussed Section 3.2.4, agent able reason agent js hypothetical
interpretation updates given system specific thread. Thus, agent able
compute (12) without knowing js exact beliefs.
Example 3.8 (Trains continued). use point frequency function express beliefs
punctuality trains. Assume B judge probability
58

fiPDT Logic

train running late (i.e., arriving 3 instead 2 time units, expressed
temporal rule r3pfr (at(T1 , CA ), at(T1 , CC ))) 0.4. yields following
belief formulae
0,0.4 pfr
Bi,0
(r3 (at(T1 , CA ), at(T1 , CC )))

,
0,0.4 pfr
Bi,0
(r3 (at(T2 , CC ), at(T2 , CB )))

{A, B}.

(13)

temporal rules expressed belief formulae, obtain following frequencies
Figure 1 (p. 50):
pfr(T h, at(T1 , CA ), at(T1 , CC ), 3) = 0
pfr(T h, at(T1 , CA ), at(T1 , CC ), 3) = 1
pfr(T h, at(T2 , CC ), at(T1 , CB ) , 3) = 0
pfr(T h, at(T2 , CC ), at(T1 , CB ), 3) = 1

h {T h1 , ..., h3 }

h {T h4 , ..., h9 }

h {T h1 , h4 , h5 }

h {T h2 , h3 , h6 , ..., h9 }

Combining frequency values prior interpretation

I(T ) = 0.7 0.02 0.09 0.02 0.09 0.01 0.02 0.02 0.03 ,
given Example 3.6 (p. 53) yields sum
X
I(T h) pfr(T h, F, G, 3) = 0.19
hT

F = at(T1 , CA ), G = at(T1 , CC ) F = at(T2 , CC ), G = at(T2 , CB ). sum
within belief quantification [`, u] = [0, 0.4], belief formulae (13) valid. Note
prior probabilities Example 3.6 specified trains
late probability, thus respective sums frequencies
same.
definitions, use belief fact F quantify
belief negation fact F :

`,u
Corollary 3.4 (Belief negated facts). Let Bi,t
0 (Ft ) agents quantified temporal belief
fact F according Definition 3.11. Then, agents belief negation
`0 ,u0
0
0
fact F given Bi,t
0 (F ) ` = 1 u u = 1 `.

3.3 Evolution Time
order completely specify problem PDT Logic, introduce concept doxastic
systems. following, assume syntactical objects finite.
|A||T |

Definition 3.12 (Doxastic system). Let set agents, set threads, A0
matrix prior probability distributions across every agent A, F
|A||T |

set frequency functions. Then, call quadruple = hA, , F, A0
system.
59

doxastic

fiMartiny & Moller

Note several parameters discussed explicitly specified
doxastic system: neither set possible worlds , set ground atoms B, set
observation atoms Lobs , set time points explicitly specified. However,
relevant information regarding parameters already contained specification
.

Remark 3.6. Since agents share common prior, rows A0 same. Thus,
one could obtain parsimonious problem specification providing single
unique row vector prior probabilities. choice using matrix A0 nonetheless
notational purposes only: simplify presentation interpretation update
operations later on.
|A||T |

Definition 3.13 (Admissibility doxastic systems). Let = hA, , F, A0

doxastic system. called admissible iff every world (implicitly) defined admissible
|A||T |

(according Definition 3.5, p. 48) rows A0

sum one.

identify specific situations doxastic system time passed
observations occurred, furthermore define pointed doxastic systems:
|A||T |

Definition 3.14 (Pointed doxastic system, pds). Let = hA, , F, A0
doxastic
system H set time-stamped observation atoms observation atoms
H occur least one worlds (implicitly) defined . call pair
hD, Hi pointed doxastic system.
Definition 3.15 (Admissibility pointed doxastic systems). Let hD, Hi pointed
doxastic system, set threads D. hD, Hi called admissible iff
admissible exists thread h ObsG (l)t H : ObsG (l) h(t)
(i.e., must contain least one thread complies timed observations H).
Intuitively, set timed observations specified pds points certain situation
doxastic system. One could view t(H) = max{t : ObsG (l)t H} present time
pds: recent observation occurred t(H), observations actually occurred
past (t < t(H)) specified H (and thus deterministic retrospective),
information future observations > t(H) given. sense, H specifies
certain history t(H) doxastic system points last event history.
Example 3.9 (Trains continued). doxastic system train example specified

= h{A, B}, {T h1 , ..., h9 }, {pfr, efr}, A0 i,




0.7 0.02 0.09 0.02 0.09 0.01 0.02 0.02 0.03
A0 =
.
0.7 0.02 0.09 0.02 0.09 0.01 0.02 0.02 0.03

identify situation described Example 3.5 (p. 52, T1 running late), specify
following pointed doxastic system:
hD, {Obs{A} (at(T1 , CC )3 )}i
60

fiPDT Logic

3.3.1 Evolution Probabilistic Interpretations
accordance prior probability matrix A0 Definition 3.12, define

interpretation matrix ATt h store interpretations agents (with n denoting
number agents |A|) across threads h1 , ..., hm given doxastic system
pov thread Th time t:


Th (T h ) . . . Th (T h )
I1,t

1
1,t



..
..
..

(14)
ATt h =
.
.
.






h (T h ) . . . h (T h )
In,t

1
n,t

definition Ki Equation (3) (p. 51), update rule Equation (4)
(p. 54), using prior probability matrix A0 Definition 3.12, provide

update matrix UtT h calculate interpretation matrix pov thread Th
time point ( denotes element-wise multiplication matrices):






h
ATt h = ATt1
UtT h



(uTt h )ij

=


0
1

Th

i,t0

hj (t) 6 Ki (Th(t))
hj (t) Ki (Th(t))

(15)

(16)



h normalization factor defined Equation (5) (p. 54).
i,t
0
time-stamped observations specified history H pds hD, Hi induce
updated set reachability relations Ki (T h(t)) every thread h complies
given observations (for threads h comply given observations
Ki (T h (t)) = ). updated reachability relations turn yield updated interpre
tations ATt h . complete state interpretations time point every possible
pov thread Th1 , ..., Thm specified block matrix, call belief
state (bs) pds time t:



bs(hD, Hi, t) = ATt h1 , ..., ATt hm
(17)

use bs(hD, Hi) denote sequence belief states bs(hD, Hi, t) = 1
= tmax .
definition belief states seen specification conditional probabilities:
kth entry bs(hD, Hi, t) specifies interpretations agents across threads
time given system pov thread Thk . Thusas every thread considered
potential pov threada full specification agents belief state threads requires
conditional probabilities every time point t. general representation
belief states allow easy evaluation subjective posterior interpretations
arbitrary time points pov threads intuitive definition belief state updates.
However, general definition contains redundant information. leveraging certain properties semantics PDT Logic, identify means obtain compressed
representations belief state following.
61

fiMartiny & Moller





Corollary 3.5 (Null vectors ATt hk ). Due definition (16), ith row ATt hk
~0 iff agent actual observations (as specified H) match observations specified
thread hk .
Proposition 3.6 (Belief state compression). Let hD, Hi pointed doxastic system
let time point t(H). Then, without loss information, belief
state bs(hD, Hi, t) time represented

(18)
bs(hD, Hi, t)0 = ~v1,t , ..., ~vn,t
one probability distribution vector ~vi,t per agent i.


Proof. follows directly Corollaries 3.3 (p. 54) 3.5 matrices ATt hk
bs(hD, Hi, t) nonzero rows exactly correspond threads considered
possible agent time t.
properties Ki given Corollary 3.1 (p. 51) follows worlds h0 (t)
Ki t(H) indistinguishable agent therefore associated
interpretation. Thus, nonzero ith rows matrices bs identical. Defining ~vi,t
unique nonzero rows bs, obtain representation (18). Information
impossible pov threads (as described Corollary 3.5) still maintained
assigned probability 0 ~vi,t .
important note compressed representation applicable time
points t(H), retrospective agent able classify threads two
categories: comply observations far (i.e., considered
possible), not. time points > t(H) classification possible
Ki (T h(t)) depends future observations therefore lead branching
several distinct interpretations depending respective observations.
3.3.2 Evolution Beliefs
order analyze temporal evolution beliefs, use update rule (15)
update belief states. Since different possible observations yield different branches
evolution beliefs, update every thread belief state individually, using

respective update matrices UtT h defined (16):




bs(hD, Hi, t) = bs(hD, Hi, 1) (UtT h1 , ..., UtT hm )

(19)

Furthermore, analyze satisfiability validity arbitrary finite belief expressions
`,u
~
Bi,t
0 () w.r.t. given pds hD, Hi, define auxiliary belief vector b() different beliefs
`,u
B 0 (). vector ~b() contains one entry (~b())j every possible thread hj
i,t

defined follows:
a)

`,u
Bi,t
0 (Ft )

b)

`,u fr
Bi,t
0 (rt (F, G)) :

c)

`,u
`k ,uk
Bi,t
()) :
0 (Bk,t

:

(
1 hj (t) |= F
(~b(Ft ))j =
0 hj (t) 6|= F

fr
(~b(rt
(F, G)))j = fr(T hj , F, G, t)
(
Th
`k ,uk
1 Ik,t j |= Bk,t
()
`
,u
k k
~
(b(Bk,t ()))j =
hj
`k ,uk
0 Ik,t 6|= Bk,t ()

62

(20)

fiPDT Logic

Note case nested beliefs, respective entries (~b())j set one
inner belief holds thread hj , i.e., assumed hj point view thread
`k ,uk
() satisfied thread.
agent k checked whether ks belief Bk,t


Using (19) (20), determine matrix Pt0 () probabilities pTi,th0 k ()
agent assigns time t0 event , possible pov threads
Th1 , ..., Thm :4




h1

p1,t0
.
Pt0 () = bs(hD, Hi, t0 ) ~b(), ..., ~b() =
..


pTn,th01



. . . pT1,th0m
..
..

.
. ()

. . . pTn,th0m

(21)

n agents threads, results n matrix. rows matrix
seen conditional probabilities: agent believes time t0 fact true

probability pTi,th0 k () given system pov thread Thk .
Remark 3.7. Computation Pt0 () straightforward cases 20.a) 20.b). compute
probabilities nested beliefs 20.c), start computing innermost belief
(which instance case 20.a) case 20.b) since assume finite expressions),
compute nested beliefs iteratively.
Using Definition 3.11 (p. 57) Equation (21), provide definition
satisfiability validity beliefs:
Definition 3.16 (Validity satisfiability beliefs). Let B belief formula defined
Definition 3.4 (p. 46), hD, Hi pointed doxastic system, Pt0 () corresponding
matrix probabilities time t0 defined (21). B satisfiable (valid) w.r.t. hD, Hi iff
`,u
1. B = Bi,t
0 ():

least one (all) thread(s) Thk , entries row Pt0 () satisfy `




hk
hk
pi,t
0 () u pi,t0 ().

`,u
2. B = Bi,t
0 ():

least one (all) thread(s) Thk , entries row Pt0 () satisfy ` >




hk
hk
pi,t
0 () u < pi,t0 ().

3. B = B1 B2 :
least one (all) thread(s) Thk , entries corresponding rows
Pt0 () satisfy B1 B2 .
4. B = B1 B2 :
B1 satisfiable (valid) B2 satisfiable (valid).


4. Since consider every possible pov thread Thk , multiply every matrix ATt h


bs(hD, Hi, t) ~b(), thus need use vector ~b(), ..., ~b()
rows.

63

fiMartiny & Moller

Remark 3.8. distinction valid satisfiable belief formulae interest
beliefs time > t(H). time points t(H) agents belief uniquely determined given observations (cf. Proposition 3.6), resulting single probability
associated belief. Therefore, invalid belief formulae t(H) unsatisfiable.
Definition 3.4 (p. 3.4) follows belief object atomic belief formula B
Definition 3.16-1 arbitrary belief formula. inner belief formula
B 0 one cases defined Definition 3.16, validity satisfiability entire
`,u
0
expression B = Bi,t
0 (B ) follows inductively definition: least one
(all) thread(s) Thk , inner belief formula B 0 satisfied limits
`,u
0
outer belief respective thread satisfied, entire belief formula B = Bi,t
0 (B )
satisfiable (valid).
Definition 3.16 gives rise important property belief operator, following
lemma shows:
`,u
Lemma 3.7 (Distributivity belief operator). Let B = Bi,t
0 (1 2 ) belief
formula belief object (1 2 ) connective {, }. Then, express
`,u
`,u
B equivalently B 0 = Bi,t
0 (1 ) Bi,t0 (2 ).

Proof. result follows immediately validity satisfiability beliefs Definition 3.16:
`,u
formula B = Bi,t
0 (1 2 ) satisfiable (valid) iff least one (all) thread(s)


hk holds hk |= 1 Thk |= 2 respective entries Pt0 () satisfy

`,u
Definition 3.16-1. former case, Bi,t
0 (1 ) satisfiable (valid) well,
`,u
latter case Bi,t
0 (2 ) satisfiable (valid), reflects exactly definition disjunctive
`,u
`,u
belief formulae Definition 3.16-4. Thus, B 0 = Bi,t
0 (1 ) Bi,t0 (2 ) satisfiable (valid)

`,u
iff B = Bi,t
0 (1 2 ) satisfiable (valid).

`,u
Similarly, formula B = Bi,t
0 (1 2 ) satisfiable (valid) iff least one (all)

thread(s) hk holds Thk |= 1 Thk |= 2 hold respective
`,u
`,u
entries Pt0 () satisfy Definition 3.16-1. Then, Bi,t
0 (1 ) Bi,t0 (2 ) satisfiable
`,u
`,u
(valid) thus, formula B 0 = Bi,t
0 (1 ) Bi,t0 (2 ) satisfiable (valid) according
`,u
`,u
definition Definition 3.16-3. Thus, B 0 = Bi,t
0 (1 ) Bi,t0 (2 ) satisfiable (valid) iff
`,u
B = Bi,t
0 (1 2 ) satisfiable (valid).

illustrate evolution beliefs, finish train example analysis
expected arrival times.
Example 3.10 (Trains continued). D, specified Example 3.9 (p. 60),
infer Bob (and course Alice, too) safely assume time 1 Alice arrive
time 8 latest probability range [0.9, 1], expressed belief
formula
0.9,1 ef r
BB,t = BB,t
(r7 (on(A, T1 ), (at(T2 , CB ) on(A, T2 ))))

64

(22)

fiPDT Logic

= 1. rule, obtain frequencies
efr(T h, at(T1 , CA ), (at(T2 , CB ) on(A, T2 )), 7) = 1

efr(T h, at(T1 , CA ), (at(T2 , CB ) on(A, T2 )), 7) = 0

h {T h1 , ..., h5 },

h {T h6 , ..., h9 },

i.e., threads h1 , ..., h5 Figure 1 (p. 50), event (at(T2 , CB ) on(A, T2 )) occurs
within 7 time points following event on(A, T1 ) time = 1 (and thus time = 8
latest), threads h6 , ..., h9 , event (at(T2 , CB ) on(A, T2 )) occurs
time = 9, outside scope r7efr thus yields frequency zero.
time point 1, Bob still considers threads possible, thus Bobs subjective
posterior probabilistic interpretation

Th
IB,1
(T ) = 0.7 0.02 0.09 0.02 0.09 0.01 0.02 0.02 0.03
equal prior interpretation given Example 3.6 (p. 53) possible pov threads
Th. Combining interpretation frequencies given yields sum
X
Th
IB,1
(T h) efr(T h, at(T1 , CA ), (at(T2 , CB ) on(A, T2 )), 7) = 0.92
hT

thus formula BB,1 valid.
Now, consider previously described situation, T1 running late
inform B it. leads updated interpretations given (6) (7)
page 54, i.e.,


h4
IA,3
=(

Th4
IB,3

0

0

0

0.4 0

0.2 0

0.4 0 ),



( 0.82 0.02 0.10 0.02 0 0.02 0 0.02 0 ).

updates lead significant divergence belief expected arrival time:
corresponding sum respect Alices updated interpretation
X
h4
IA,3
(T h) efr(T h, at(T1 , CA ), (at(T2 , CB ) on(A, T2 )), 7) = 0.4,
(23)
hT

(24)
obtained Alices subjective posterior probability assignment thread h4 ,
nonzero summand sum; threads h either impossible
h4
Alices point view (i.e., IA,3
(T h) = 0 threads h {T h1 , h2 , h3 , h5 , h7 , h9 }),
corresponding frequency zero (for threads h6 h8 ). Thus, Alices belief
arriving time point 8 latest drastically reduced, lower bound ` Alices
belief may exceed 0.4. instance,

0.4,1 ef r
BA,3
r8 (on(A, T1 ), (at(T2 , CB ) on(A, T2 ))) ,
(25)
valid belief formula. corresponding sum Bobs belief time point 3
X
h4
IB,3
(T h) efr(T h, at(T1 , CA ), (at(T2 , CB ) on(A, T2 )), 7) = 0.96,
(26)
hT

65

fiMartiny & Moller

obtained summing Bobs subjective posterior interpretations threads h1 , ..., h4 ;
remaining threads contribute zero summands either Bobs probability assignment corresponding frequency zero threads. Thus, Bobs
previous belief (expressed (22)) remains valid time point = 3, denoted BB,3 .
Even though Alices beliefs changed significantly, aware Bob maintains
beliefs conflicting own, shown following valid expression nested
beliefs:
1,1
BA,3
(BB,3 )
verify nested belief holds, need consider threads Alice considers
possible (T h4 , h6 , h8 ) determine Bobs hypothetical beliefs would
threads. h4 , already analyzed (26). Since threads h4 , h6 ,
h8 indistinguishable Bob time point 3, analysis results hold
three threads. Consequently, BB3 holds every thread Alice considers possible
therefore sum nested belief
X
Th
Ii,t
0 (T h) = 1,
hT

h |=B
IB,3
B,3

i.e., Alice knows Bobs belief outdated.
Finally, consider pointed doxastic system hD, Obs{AB} (at(T1 , CC ))3 i, i.e.,
situation difference Alice shares observation
delayed train Bob. immediately follows Bob updates beliefs
way Alice, turn yields update Alices beliefs Bobs beliefs
following expression valid (because 1 valid lower bound longer):
1,1
(BB,3 )
BA,3

example shows Alice reason influence actions
Bobs belief state therefore decide actions improve Bobs utility (as
wait vain).

4. Satisfiability Checking PDT Logic
section describe procedures check whether exists model
given set belief formulae B. discussions chapter, assume models
sets formulae finite. start formally defining satisfiability checking
problem PDT Logic. Using semantics previous section, derive model
checking algorithm based fully specified doxastic systems. Afterwards, show set
belief formulae used specify problem PDT Logic andtogether given
set threadshow transformed mixed integer linear program order
employ existing solvers decide satisfiability PDT Logic formulae. Finally, show
suitable threads derived given set belief formulae automatically. Using
transformations linear programs established approach deciding satisfiability
probabilistic logics, discussed example Fagin, Halpern, Megiddo (1990).
However, priors given, established decision procedures probabilistic logics
66

fiPDT Logic

applicable PDT Logic due formalisms update mechanism (cf. update rule
Definition 3.9, p. 54). update mechanism
fully specified doxastic system hD, Hi given, define problem checking
whether set belief formulae B satisfiable respect doxastic system

follows. Recall Section 3.2.4 use h denote set subjective
Th induced prior interpretation pov thread Th.
posterior interpretations Ii,t
0
Definition 4.1 (Satisfiability Checking PDT Logic). Let hD, Hi pointed doxastic
system set threads according prior interpretation specified hD, Hi,
B set belief formulae. say B satisfiable w.r.t. hD, Hi exists
thread Th corresponding interpretations satisfy belief formulae B
B:



sat(B, hD, Hi) Th : B B : h |= B
(27)
specification given, checking satisfiability B respect hD, Hi corresponds checking whether hD, Hi model B. continue introducing model
checking procedure fully specified input. Afterwards, discuss satisfiability
set belief formulae B decided prior probabilities, neither threads
prior probabilities given.
4.1 Model Checking Algorithm
first approach developing algorithm check whether given set belief formulae
B satisfied given pointed doxastic system hD, Hi (i.e., checking whether hD, Hi
model B) obtained direct application semantics belief
operator given Definition 3.11 (p. 57). Algorithm 1 shows resulting model checking
procedure. starts computing belief states possible evolutions world
= 1 tmax . Afterwards, iterates belief formulae B B potential
pov threads Thk determine whether interpretation respective pov thread
able satisfy current belief formula. thread unable satisfy belief formula,
excluded set potential pov threads subsequent checks. least one
potential pov thread remains belief formulae checked (i.e.,
least one thread Thk belief formulae B B satisfied), hD, Hi model
B.
Theorem 4.1 (Soundness completeness Algorithm 1). decision procedure Algorithm 1 sound complete therefore model checking procedure PDT Logic.
Proof. Since presented algorithm essentially inductive application Definition 3.16
(p. 63), easy see yields sound complete decision procedure PDT
`,u
`,u fr
Logic. Basic belief formulae (Bi,t
0 (Ft ) Bi,t0 (rt (F, G))) return satisfiability results
directly using respective semantic definitions (10) (11) calculation rules.
`,u
`,u
0
00
every possible compound belief formula PDT Logic (Bi,t
0 (), Bi,t0 (B), B B ,
0
00
B B ), procedure provides appropriate rule according Definition 3.16 break
formulae iteratively base formulae obtained, decided
above.
67

fiMartiny & Moller

Algorithm 1 Model Checking
procedure ModelChecking(hD, Hi, B)
h1
hm
bs(hD, Hi, 0) (AT
, ...,
)
0
0
1, tmax
bs(hD, Hi, t) bs(hD, Hi, 1) (UtT h1 , ..., UtT hm )
B B
Thk
Check(bs(hD, Hi), Thk , B))
\ {Thk }
=
return false
return true

. compute belief states

. check B satisfied Thk
. otherwise remove Thk threads check
. exit Th satisfy B
. success nonempty checking B B

function Check(bs(hD, Hi), Thk , B)
switch (B)
. check formulae according Def. 3.16
`,u
case Bi,t
0 ():
= B 0
. check nested belief formulae recursively (B 0 belief formula)
0

Check(bs(hD, Hi), hk , B ))
return false
Th
Pt0 bs(hD, Hi, t0 ) ~b()
. use ~b() (20) compute Pt0 elements pi,t0k
Th

Th

Th

. true pi,t0k [`, u]

return (` pi,t0k u pi,t0k )
`,u
case Bi,t
0 ():

Pt0 bs(hD, Hi, t0 ) ~b()
Th

Th

Th

. true pi,t0k 6 [`, u]

return (` pi,t0k u pi,t0k )
case B 0 B 00 :
return (Check(bs(hD, Hi), Thk , B 0 )
Check(bs(hD, Hi), Thk , B 00 ))
case B 0 B 00 :
return (Check(bs(hD, Hi), Thk , B 0 )
Check(bs(hD, Hi), Thk , B 00 ))

68

fiPDT Logic

asymptotic complexity Algorithm 1 depends number belief operators
`,u
Bi,t
0 () contained B:
Theorem 4.2 (Time complexity Algorithm 1). Let B set belief formulae let
k number belief operators contained within B. Then, using Algorithm 1 check
whether given pointed doxastic system hD, Hi threads model B time
complexity O(k m).
Proof. given pds threads k belief formulae B, main procedure calls
check function k times. B base formula single belief
`,u
operator Bi,t
0 (), single call check function return result. Otherwise,
`,u
belief formula B contains one belief operator Bi,t
0 (), check function
called recursively, base formulae obtained. Thus, k belief operators B,
satisfaction checks performed k times, yielding time complexity
O(k m).

Theorem 4.2 immediately obtain complexity result model checking
problem PDT Logic:
Corollary 4.3 (Complexity model checking PDT Logic). model checking problem
PDT Logic PTIME.
result shows model checking set belief formulae w.r.t. given pointed
doxastic system done polynomial time. fully specified pds (and thereby
exhaustive specification set possible threads ) given, result shows
Algorithm 1 presents tractable procedure perform model checking task. However,
approach significant drawback assumes exhaustive specification
together precise prior probability assignments I(T ). Although problem
domains actually come specification (e.g., cf. cyber security scenario
described introduction), assumption renders Algorithm 1 infeasible
problem domains. overcome problem, proceed discussing different
approach, enables satisfiability checking without requiring specification exact
probabilities. Moreover, show representative threads respect set belief
formulae B constructed automatically, positive satisfiability results
potentially obtained without requiring full materialization possible threads .
4.2 Compact Problem Specification
used (pointed) doxastic system specify problem domain model
checking set belief formulae B PDT Logic. following sections, show
reformulate problem extended set belief formulae together
value tmax used. main idea approach background knowledge regarding target domain given explicit specification possible threads
according probabilities, instead sets rules B describe target
domain may evolve time. approach several advantages: scenarios,
compared requiring exhaustive set possible threads, specifying set rules (which
expressed prior beliefs) gives natural means specifying background
69

fiMartiny & Moller

knowledge problem domain (e.g., cf. Example 3.2 page 47, actually starts
verbal description rules later introduces corresponding set possible
threads). Furthermore, using set rules describe problem domain fairly established approach therefore approach provide options simplify transformation
existing problem specifications PDT Logic. Finally, since set possible threads
grows exponentially every additional time point set time points every
additional ground atom language L, exhaustive problem specification
set possible threads quickly becomes infeasible, situation could
described succinctly small set rules. Even though succinct specification shifts exponential nature problem required input specification
computational efforts, show exponential effect curtailed heuristics
constructing possible threads automatically.
4.2.1 Identification Key Parameters Set Belief Formulae
simplify following discussion, restrict temporal rules use point
frequency function pfr. Recall point frequency functions used specify
event F followed another event G exactly time points, existential
frequency functions efr used specify event F followed another event G
within time interval t. existential frequency functions required specify problem
domain, rewrite disjunctions point frequency functions, following
proposition shows. frequency functions defined, presented techniques
easily adapted.
Proposition 4.4 (efr rewriting). existential frequency function efr equivalently
represented disjunction point frequency functions pfr:
efr
(F, G)
rt

_

pfr
rt
(F, G)

0tt

t:

Recall that, according Definitions 3.12 3.14 page 59, specification pds
consists set agents A, set threads , set frequency functions F, matrix
|A||T |

prior probability distributions A0
, set time-stamped observations H.
Since use point frequency functions following, set frequency
functions F always fixed {pfr}, thus need specify set separately.
Instead explicitly specifying set agents A, determine
`,u
belief expressions Bi,t
0 () contained set belief formulae B. slight abuse
`,u
`,u
notation, use Bi,t
0 () B denote belief operator Bi,t0 () appears somewhere
set belief formulae B. Then, define set agents AB specified set
belief formulae B
`,u
AB = {i : Bi,t
(28)
0 () B}

Generally, possible explicit specification set agents larger
set AB . However, obvious beliefs expressed agent (i.e.,
6 AB ), agent influence satisfiability checking results whatsoever.
Thus, agent simply disregarded and, consequently, suffices use set AB .
70

fiPDT Logic

Similarly, instead specifying set ground atoms language L
sets predicates Lpred constants Lcons , define set event formulae FB
representing belief objects occurring set belief formulae B
n

`,u
`,u fr
`,u fr
FB = F : Bi,t
.
(29)
0 (Ft ) B Bi,t0 (rt (F, G)) B Bi,t0 (rt (G, F )) B
definition gives rise potential definition set possible worlds
Herbrand base B FB FB (resp. set admissible worlds complying
Definition 3.5 (p. 48). However, show later, options constrain
sets possible worlds allow concise problem representation.
Note according Definition 3.2 (p. 45), formulae may include atoms
observation atoms. Consequently, FB specify ontic facts possible worlds,
possible observations ontic facts. approach, occurrences
observations limited ones specified FB . seen specification
sensor model groups agents G AB .
Remark 4.1. strict application (29) would prohibit simple specifications group observations ObsG (l) |G| > 1 B. ensure set admissible worlds
actually
V
contains worlds ObsG (l), full specification observation G 0 G ObsG 0 (l)
B would required (otherwise might world B FB |= ObsG (l)
satisfies second property definition possible worlds (cf. Definition 3.5)).
However, required full specification observation admissible worlds determined solely simple observation specification ObsG (l). order keep
specification B compact possible,
allow simple specifications ObsG (l)
V
assume expanded G 0 G ObsG 0 (l) creating FB .
alternative approach would construct FB ontic facts appearing
B create set admissible worlds combining ontic facts possible
admissible observations w.r.t. Definition 3.5. approaches differ requirements
observation specifications: former requires specify every possible observation explicitly, latter requires exclude every impossible observation explicitly. Since
scenarios set observations actually possible (w.r.t. problem domain)
significantly smaller set admissible observations, presented approach
usually yield compact problem specification. desired, one could employ
latter approach instead without impacting functionality following methods.
Background knowledge regarding target domainthat given explicit
representation possible threads beforecan specified prior beliefs (i.e.,
`,u
beliefs Bi,0
()) B. Recall Section 3.2.4 assume commonly known prior


h equal agents . belief semantics defined
distribution Ii,t
B


h (cf. Definition 3.11, p. 57), follows
respect probabilistic interpretations Ii,t
0

`,u
every prior belief Bi,0
() common knowledge well. Consequently, express
background knowledge prior beliefs arbitrary agent AB .
`,u fr
pointed Section 3, satisfiability beliefs temporal rules Bi,t
0 (rt (F, G))

certain properties independent respective set threads associated
interpretation I(T ) (cf. Remark 3.5, p. 58): respective frequency function corresponds
71

fiMartiny & Moller

FF1 FF2 Definition 3.10 (i.e., F contradiction, G tautology, F tautology G contradiction), beliefs either trivially satisfied quantifications
u = 1 (resp. ` = 0) generally unsatisfiable. former case, trivially satisfiable beliefs
disregarded without influencing satisfiability results, latter case satisfiability checking terminate immediately negative result. Thus, following
assume B contains beliefs rules correspond frequency function
axioms FF1 FF2.
Example 4.1 (Trains revisited). informal verbal description train problem
given Example 3.2 (p. 47) corresponding formal specification set
possible threads Example 3.4 (p. 51)and probability assignments Example 3.6 (p. 53).
Using considerations expression background knowledge beliefs rules,
reformulate verbal rules given Example 3.2 together probabilistic
information Example 3.6 set formal beliefs B according explanations
below:



1,1
1,1


B1 = BA,0
at(T
,
C
)

B
on(A,

)
,
1
1
1
1


A,0







.81,.81 pfr


(B20 )
r0 (at(T1 , CA ), punct(T1 ))
BA,0


B
=

2


.81,.81 pfr

BA,0
r0 (at(T2 , CC ), punct(T2 )) ,
(B200 )









1,1


r3pfr ( punct(T1 ) at(T1 , CA ), at(T2 , CC ) on(A, T2 )) (B30 )
BA,0


B3 =



1,1 pfr

BA,0
(r5 (punct(T1 ) at(T1 , CA ), at(T2 , CC ) on(A, T2 )) , (B300 )







1,1
B=
r2pfr ( punct(T2 ) at(T2 , CC ), at(T2 , CB ) on(A, T2 )) (B40 )
BA,0

B4 =



1,1


BA,0
r3pfr (punct(T2 ) at(T2 , CC ), at(T2 , CB ) on(A, T2 )) , (B400 )








1,1


B5 = BA,0
r0pfr (punct(train) at(train, city), Obs{A} (punct(train))) ,









.93,.93 pfr

B6 = BA,0
r2 (Obs{A} (punct(train)), Obs{AB} (punct(train))) ,









train {T1 , T2 },




city {C , C }


B













































































Note beliefs expressed time = 0, i.e., prior beliefs
definition commonly known among agents. beliefs expressed example
assigned A, could equivalently assigned B both.
B1 states train T1 city CA time = 1 Alice train. B2
states agents believe trains punctual (denoted punct(train))
probability 0.81. probability values example obtained summing
probabilities given Example 3.6 threads given Example 3.4 respective
belief object satisfied. equivalent representation previous example,
72

fiPDT Logic

use exact probability values (i.e., ` = u) instead intervals. Note punct(train)
additional predicate variable train helps formulate background knowledge
concise way. Formula B2 yet specify consequences non-punctual
train are, train expected punctual certain probability. B3 states
Alice able board train T2 three time steps train T1 punctual
Alice wait two additional time points otherwise. B4 states train T2
arrive city CB two time points city CC . Otherwise arrive one
time point later. B5 states Alice always notice train leaves city
punctually. example sensor model specification discussed above. Finally,
B6 states Alice call Bob probability 0.93 train punctual.
Example 4.2 (Trains continued). definition set belief formulae B
example, specify set event formulae FB required model
possible scenarios described B:






at(T
,
C
),
at(T
,
C
),
at(T
,
C
),
at(T
,
C
),
1
1
2
2

B
B
C






on(A, ), on(A, ), punct(T ), punct(T ),

1
2
1
2
FB =


Obs{A} (punct(T1 )), Obs{AB} (punct(T1 )),








Obs (punct(T2 )), Obs

(punct(T
))
2
{A}
{AB}
simplify following discussion, assume conjunctive formulae B = B 0
B replaced individual formulae respective conjuncts: B = B \
{B} {B 0 , B 00 }. impact satisfiability checking properties B
formulae B satisfied simultaneously order return positive result
thus, B 0 B 00 satisfied, regardless representation two
individual formulae one conjunction.
Now, remains determined set threads , corresponding prior
B 00

|A||T |

probability distribution I(T ) (resp. matrix prior probability distributions A0
,
every row formed I(T )), possibly set time-stamped observation atoms
H. tasks determining H treated jointly: since set relevant
threads needs determined anyway, simply create |= H.
next section show transform set PDT Logic belief formulae
B together given set threads linear program order determine
satisfiability B respect . Afterwards, discuss suitable set
threads represent information contained B constructed automatically.
Using results, possible model problem domain PDT Logic solely
set belief formulae B together specification maximum time point tmax .
key parameters domainsuch set agents set ground
atomscan extracted B automatically.
4.3 Representing Satisfiability Problem Linear Program

considerations previous section show parameters problem
specification extracted given set belief formulae B. section,
assume set belief formulae B together set possible threads given.
73

fiMartiny & Moller

B satisfiable respect (denoted sat(B, )) prior interpretation I(T )
found belief formulae B satisfied. extracting linear constraints
I(T ) B, show satisfiability problem transformed linear
program. Checking satisfiability B respect equivalent checking
whether corresponding linear program feasible solution.
given set threads unknown prior interpretation I(T ), satisfiability
checking task significantly increases complexity compared model checking task.
Formulation satisfiability checking problem Definition 4.1 (p. 67) might somewhat delusive: existence single thread context interpretation
suffices verify satisfiability set belief formulae B, appears intuitive develop
method construct threadif possibleand neglect threads, or, vice
versa, start entire set threads iteratively prune threads fail satisfy formula B. fact, pruning approach used Algorithm 1 (p.68)
check whether given set threads model set belief formulae. Unfortunately,
approaches inapplicable prior interpretation unknown. semantics
belief operators (cf. Definition 3.11 (p. 57) relies subjective posterior probabilistic interpretations (i.e., probability assignments multiple threads), generally possible
find single thread Th satisfying satisfiability checking problem Definition 4.1
without determining probabilities threads. Vice versa, generally possible
discard thread, determining whether satisfies belief formula
done respective probability assignment known. Instead, show belief
formulae equivalently expressed sets linear constraints unknown prior
interpretation I(T ). Then, checking satisfiability B equivalent checking whether
possible assignment I(T ) constraints satisfied.
use xk denote unknown prior probability thread hk , i.e., contains
threads, unknown prior probability assignment represented
I(T ) = x1 , , xm



.

(30)

goal following methods provide constraints xk belief
formulae B B satisfied. Since variables represent probability distribution
set threads, two obvious constraints begin with:
0 xk 1, k {1, ..., m}



X

xk = 1

(31)

(32)

k=1

4.3.1 Representation Subjective Posterior Probabilities
Since semantics beliefs defined terms respective agents subjective probability assignments respective pov thread, need means express subjective
Th agent terms prior probability
posterior probabilistic interpretations Ii,t
0
values xk . interpretations change time point whenever observation Obs{i} (l)t
possible agent i. observation possible agent, partition set
threads two sets: one partition containing set threads agent observe
74

fiPDT Logic

respective fact l one partition agent observe respective fact.
subjective probability assignments need updated within partition reflect
information observation occurrences: Taking every thread within partition
possible pov thread, probability assignments threads within partition
need scaled according update rule Definition 3.9 pov thread specific
probability assignments threads outside respective partition need set
zero.
Generally, leads one vector subjective probabilities threads every
possible pov thread (cf. Definition belief states Equation (17), p. 61). However,
leverage semantic properties PDT Logic obtain parsimonious representation
updated subjective probabilities without representing every pov thread explicitly.
Note threads within one partition described indistinguishable agent
respective time point (i.e., threads within one partition exhibit exactly
set observations agent time point t) therefore receive probability
assignment every possible pov thread within partition (cf. Proposition 3.6, p. 62).
Consequently, updated probability assignments every thread receive
one two different types value assignments: scaled version threads previous
probability assignment according Definition 3.9 (p. 54), zero, depending whether
agent actually observes fact l not. following proposition shows
need consider cases zero probabilities order perform satisfiability checking
tasks.


h subjective posterior
Proposition 4.5 (Irrelevance zero-interpretations). Let Ii,t
0
0
probability interpretation time agent pov thread Th (i.e., interpreta-

tion determined prior interpretation interpretation updates corresponding
pov thread Th). interpretation assigns probability zero thread h (i.e.,
Th (T h) = 0), satisfiability subsequent nontrivial belief B 00 () t00 > t0
Ii,t
0
i,t


h (T h).
independent Ii,t
0

`,u
Proof. Every belief Bi,t
0 () ` > 0 fact another belief (i.e., = Ft
` ,u

= Bj,tj j ()) requires needs least one thread h nonzero


h (T h) = 0 clearly
probability h |= . Therefore, thread h Ii,t
0
`,u
00
0
prove satisfiability belief Bi,t
00 () . negative satisfiability result (i.e., B

unsatisfiable w.r.t. ) cannot obtained zero assignment either,
consistent interpretation (i.e., probability assignments threads sum one)
needs assign nonzero probability least one thread, could possibly
`,u
satisfy belief. considerations hold beliefs Bi,t
0 () ` = 0 u < 1:


h (T h) = 0 satisfies lower bound ` = 0, upper bound u < 1
Although thread Ii,t
0


h (T h0 ) > 0
requires existence another thread h0 nonzero probability Ii,t
0


h (T h) = 0 prove satisfiability beliefs B `,u ()
h0 |= . Consequently, Ii,t
0
i,t0
` = 0 u = 1. trivial beliefs satisfied every thread
every possible probability assignment thus, satisfiability proven without
Th (T h) = 0, too.
Ii,t
0

75

fiMartiny & Moller

`,u fr
Analogous considerations hold beliefs rules: belief Bi,t
0 (rt (F, G)) ` > 0
requires existence thread nonzero probability fr(T h, F, G, t) > 0,
Th (T h) = 0 cannot prove satisfiability belief. Satisfiaand thus thread h Ii,t
0
`,u fr
bility belief Bi,t
0 (rt (F, G)) ` = 0 u < 1 depends respective frequencies
0
fr(T h , F, G, t) additional threads h0 nonzero probabilities.

result proposition, merge nonzero entries cases (agent
observes fact l agent observe fact l) single probability
distribution vector agent time point t. yields modified version
update rule Definition 3.9. use modified update rule determine linear
constraints unknown prior probabilities xk .
Definition 4.2 (Modified update rule). Let agent, t0 time point observation Obs{i} (l) occur h thread. Then, compressed subjective posterior
probability assignment Ii,t0 (T h) agent time t0 thread h given
Ii,t0 (T h) =

1
Ii,t0 1 (T h)
Th
i,t
0

(33)

h normalization factor ensure probabilities threads
i,t
0
agent considers possible sum one:
X
Th
Ii,t0 (T h0 )
i,t
0 =
h0 (t0 )Ki (T h(t0 ))

Example 4.3 (Modified update rule). illustrate modified update rule, return
situation described Example 3.7 (p. 54). example assumed train T1
running late inform B it. resulted following updated
interpretation A:

Th8
Th6
Th4
= 0 0 0 0.4 0 0.2 0 0.4 0
= IA,3
= IA,3
IA,3
given example, two additional hypothetical partitions set threads
possible Alice time point = 3 . train T1 running late inform
B it, threads h5 , h7 , h9 indistinguishable A, yielding updated
subjective interpretation

Th5
Th7
Th9
IA,3
= IA,3
= IA,3
= 0 0 0 0 0.14 0 0.65 0 0.21
T1 time, Alice considers threads h1 , h2 , h3 possible. corresponding
subjective interpretation

Th1
Th2
Th3
IA,3
= IA,3
= IA,3
= 0.86 0.03 0.11 0 0 0 0 0 0
three different subjective interpretations nonzero entries exactly threads
partitions respective pov thread. Since partitions overlapping, merge nonzero entries single probability vector

IA,3 = 0.86 0.03 0.11 0.4 0.14 0.2 0.65 0.4 0.21 .
76

fiPDT Logic

Note modified update rule, update pov thread specify interpretations threads anymore, instead reflexive interpretations
thread h, given h pov thread, used. discussed above,
satisfiability problem still sufficient representation posterior probabilities,
potential pov threads Th respective partition indistinguishable
agent therefore yield exactly interpretations. noted however Ii,t0 (T h) probabilistic vector anymore, i.e., elements sum
one. Compared representation belief states Section 3.3.1 (p. 61), information
distinguishable worlds lost. Thus, reconstruction agents belief state
representation possible additional specification respective relations
Ki .
Returning problem representation (30) (p. 74), use modified update rule obtain inductive definition subjective posterior probabilities based

respective (unknown) prior probabilities xk . I(T ) = x1 , , xm prior interpretation set threads, agent compressed subjective posterior interpretations
Ii,t0 time point t0 first possible interpretation represented
Ii,t0 (T ) =



1
1i,t0

x1 , ,

1

i,t0

xm



0



,

(34)

k determined
update factors i,t
0

1
i,t
0



i,t
1,1



.


i,t
x
,



,
x
=

0
1

..


..
.

0

i,t
m,1

i,t0

j,k


0
i,t
1,m
..

. ,
0

i,t
m,m

(
1 hk (t0 ) Ki (T hj (t0 ))
=
0 hk (t0 ) 6 Ki (T hj (t0 ))
0

(symmetric) matrix indicators i,t
j,k denoting whether agent considers thread
0
hk possible thread hj time . Using (34) base case, define
interpretation updates next possible observation time t00 inductively
Ii,t00 (T ) =



1
1i,t00



1
1i,t0

x1 , ,

1


i,t00



1


i,t0

xm



(35)

simplify notation, following use single factor aki,t0 represent agk k ...) observations occur
gregated sequence scaling factors (i,t
i,t2
1
time points t1 , t2 , ... = 1 = t0 agent i, i.e., agent subjective posterior
interpretations Ii,t0 (T ) time t0 given
Ii,t0 (T ) = a1i,t0 x1 , ,
i,t0 xm



.

(36)

Note potential interpretation updates agent occur time point
observation Obs{i} (l) possible time point. Hence, time
interval two possible observations, subjective interpretations constant:
77

fiMartiny & Moller

Proposition 4.6 (Piecewise constant interpretations). Let t1 t2 t1 < t2 two
time points observations agent possible t1 t2 , time
point t1 t2 . Then, compressed subjective interpretation Ii,t0 (T )
constant time points t1 < t2 :
[t1 , t2 1] : Ii,t (T ) = Ii,t1 (T )
proposition states constraints identified following section
restrict subjective interpretations single time points, instead restrict
interpretations respective time interval two possible observations.
4.3.2 Extracting Linear Constraints Belief Formulae
established representation (36) subjective posterior interpretations
terms unknown prior probabilities xk , use representation extract linear
constraints xk set belief formulae B.
assume distributive property belief operator Lemma 3.7 (p. 64)
`,u
applied whenever possible, i.e., belief formulae Bi,t
0 (B1 B2 ) {, }
`,u
`,u
separated Bi,t
0 (B1 )Bi,t0 (B2 ). Furthermore, without loss generality, assume
conjunctive formulae B = B1 B2 replaced B \ {B} {B1 , B2 }
trivial beliefs (with ` = 0 u = 1) removed B.
Moreover, assume belief formulae B B represented negation normal
form (NNF), i.e., negation operator applied atoms. Since arbitrary logic
formula equivalently expressed formula NNF (cf. e.g., Baaz, Egly, Leitsch,
Goubault-Larrecq, & Plaisted, 2001), assumption restrict B either.
assumptions, following types belief formulae B occur B:
`,u
atomic belief formulae B = Bi,t
0 ()
`,u
negated atomic belief formulae B = Bi,t
0 ()

disjunctive belief formulae B = B1 B2
types, show respective formula expressed
set linear constraints prior probabilities xk .
Atomic Belief Formulae Using parsimonious representation subjective posterior
interpretations Ii,t0 (T h) given modified update rule Definition 4.2 requires
adaption deciding satisfiability belief formulae. Before, satisfaction belief
formula given pov thread could determined summing respective subjective interpretations threads belief object satisfied. Threads
agent consider possible anymore w.r.t. given pov thread automatically
excluded probability assignment zero. compressed representation,
respective probability assignments threads considered impossible overloaded
different probability assignments given agent another pov thread, illustrated
Example 4.3. obtain adapted version satisfiability testing explicitly ensuring
interpretations threads summed still considered possible
w.r.t. respective pov thread. additional constraint excludes summands
78

fiPDT Logic

zero-values, original semantics still maintained. Thus, use equivalence classes
1 , C 2 , ...} represent set distinguishable situations agent time t0 .
Ci,t0 = {Ci,t
0
i,t0
Naturally, two threads h1 , h2 indistinguishable therefore equivalence
class agent time t0 , exhibit exactly observations agent
time points {1, .., t0 }. threads outside particular equivalence class receive
probability zero every pov thread Th within respective equivalence class andas
discussed previous sectiontherefore contribute satisfiability properties. Then, belief semantics Definition 3.11 (p. 57), instead summing
k : (Th C k )
threads h certain properties, restrict range h Ci,t
i,t
maintaining original semantics. Naturally, belief formula satisfiable
exists least one equivalence class satisfies respective beliefs. instance,
`,u
belief fact Bi,t
0 (Ft ) satisfiable respect agent compressed subjective
posterior interpretation Ii,t0 time t0 iff
k
Ci,t
0 Ci,t0 : `

X
n:

k h (t)|=F )
(T hn Ci,t
n
0

ani,t0 xn u

(37)

constraint equivalently expressed set linear inequalities
conjunctive disjunctive connectives, leading alternative representation
satisfiability problem.
Corollary 4.7 (Alternative satisfiability representation atomic beliefs). Let Ii,t0 (T ) =


a1i,t0 x1 , ,
Ij,t (T ) = a1j,t x1 , ,
compressed
j,t xm
i,t0 xm
representation agent js respective subjective posterior probabilities time t0
t, respectively, given (36), let Ci,t0 Cj,t sets worlds agent
agent j distinguish respective time point. Then, atomic belief expression B
satisfiable w.r.t. Ii,t0 (T )
`,u
1. belief fact B = Bi,t
0 (Ft ) iff



_
k C
Ci,t
0
i,t0

X
k
(T hn Ci,t
0

n:
hn (t)|=F )

ani,t0



xn `



X
k
(T hn Ci,t
0

n:
hn (t)|=F )

ani,t0


xn u

!
(38)

`,u pfr
2. belief rule B = Bi,t
0 (rt (F, G)) iff

_



k C
Ci,t
0
i,t0

X
k )
n: (T hn Ci,t
0




X
n:

k )
(T hn Ci,t
0


ani,t0 xn pfr(T hn , F, G, t) `
ani,t0 xn pfr(T hn , F, G, t)

79


u

!
(39)

fiMartiny & Moller

` ,u

`,u
j j
3. nested belief B = Bi,t
()) iff
0 (Bj,t

_



k C
Ci,t
0
i,t0

X
k )
n: (T hn Cj,t
k
k }6=)
hn |= ({Cj,t Ci,t
0




X
k )
n: (T hn Cj,t
k C k }6=)
hn |= ({Cj,t
i,t0




X

X
n:

anj,t xn

ani,t0 xn

k C k }
hn {Cj,t
0
i,t0



uj

ani,t0 xn `

k C k }
n: hn {Cj,t
i,t0
hn |=




anj,t xn `j

u







!
(40)

hn |=

discussed above, representations satisfiability beliefs facts (38) beliefs
rules (39) obtained directly replacing range threads sum
k considered possible agent time t0 . inequalities
respective set threads Cj,t
0
nested beliefs (40) obtained ensuring first two lines every situation
agent conceives possible situation agent j (expressed constraint
k ) C k C k 6= ), agent js belief respective fact (expressed
n : (T hn Cj,t
j,t
i,t0
constraint hn |= ) within [`j , uj ]. latter two lines ensure
respective situations, outer belief agent satisfied, well. Note
belief object (40) might contain additional belief operators, i.e., beliefs multiple
levels nesting expressed. case, evaluation h |= first two lines
(40) yields additional constraints type (38)(40), formula evaluated
recursively.
Negated Atomic Belief Formulae satisfy negated atomic belief formula B =
`,u
Bi,t
0 (), accumulated probabilities threads satisfy belief object
k must either lower ` higher u, i.e., individual
equivalence class Ci,t
0
disjuncts
(38)(40) negated. pushing negations inward using
X
( ) representative respective sums defined (38) (39) express


satisfiability atomic beliefs, represent negations according beliefs expressed
(38) (39)
!
X
X

_

( ) < `
( ) < u .
(41)
k C
Ci,t
0
i,t0





nested beliefs defined (40) contain negated belief operators, expressed
accordingly replacing conjunctive constraints ` u (resp. `j uj )
corresponding disjunctive constraints (41) negated atomic belief formulae.
80

fiPDT Logic

Disjunctive Belief Formulae inequalities, required constraints
disjunctive formula B = B1 B2 easily expressed additional disjunction
inequalities. Let C1 C2 sets inequalities express satisfiability B1 B2
according (38)(41), respectively. Then, constraints B expressed
C1 C2

(42)

Example 4.4 (Trains continued). Example 4.1 (p. 72), set belief formulae B
given train example. illustrate extraction linear constraints
set, continue use set threads depicted Figure 1 (p. 50) minor
modification: reflect model specified B Example 4.1, assume
predicate punct(train) explicitly encoded respective threads. Moreover,
sake example assume prior probabilistic interpretations yet unknown.
use x1 , ..., x9 denote unknown probabilities. Note example,
dealing prior beliefs, i.e., one equivalence class C =
scaling factors ani,t0 equal one. significantly eases presentation
example. course, general deal multiple equivalence classes
multiple varying scaling factors. highly increases complexity presentation,
refrain giving explicit examples cases. constraints B extracted
follows:

.81,.81 pfr
r0 (at(T1 , CA ), punct(T1 )) :
belief B20 = BA,0
pfr(T h, at(T1 , CA ), punct(T1 ), 0) = 1 h {T h1 , ..., h3 }

pfr(T h, at(T1 , CA ), punct(T1 ), 0) = 0 h {T h4 , ..., h9 }

thus application rule (39) yields constraints
x1 x2 x3 0.81
x1 + x2 + x3

0.81

special case ` = u, simplify constraint
x1 + x2 + x3 =

0.81

Since rules exhibit property, slightly deviate (39)
give equivalent equality constraints subsequent rules order simplify
presentation.

.81,.81 pfr
Accordingly, belief B200 = BA,0
r0 (at(T2 , CC ), punct(T2 )) obtain:
pfr(T h, at(T2 , CC ), punct(T2 ), 0) = 1 h {T h1 , h4 , h5 }

pfr(T h, at(T2 , CC ), punct(T2 ), 0) = 0 h {T h2 , h3 , h6 ..., h9 }

corresponding constraints
x1 + x4 + x5 =
81

0.81

fiMartiny & Moller


.93,.93 pfr
belief B6 = BA,0
r2 (Obs{A} (punct(train)), Obs{AB} (punct(train))) :
h {T h1 , h3 , h5 , h9 } :

pfr(T h, punct(train), Obs{AB} (punct(train)), 2) = 1,

h {T h2 , h4 , h6 } :

pfr(T h, punct(train), Obs{AB} (punct(train)), 2) = 0,

h {T h7 , h8 } :

pfr(T h, punct(train), Obs{AB} (punct(train)), 2) = 0.5

thus application rule (39) yields constraint
x1 + x3 + x5 + 0.5 x7 + 0.5 x8 + x9 = 0.93
remaining beliefs, respective belief objects satisfied every thread
thus obtain redundant constraints
9
X

xk = 1.

k=1

One easily verify prior probabilistic interpretation given Example 3.6, i.e.,

x = 0.7 0.02 0.09 0.02 0.09 0.01 0.02 0.02 0.03
indeed solution respect constraints. course, given
example, solution expected, B defined exactly reflects
situation described examples previous section.
4.3.3 Transformation Disjunctive Program
every belief formula B B, extractions linear constraints yield set
inequalities form
ai,1 x1 + ai,2 x2 + ... + ai,m xm bi ,

(43)

xj representing unknown prior probabilities threads h1 , ..., hm , coefficients
ai,j set respective values ani,t0 contribute constraint set zero
otherwise, value b1 set respective limit obtained ` u.
Corollary 4.7 shows, every belief formula B B yields disjunctive set inequality
constraints, i.e., every belief formula B introduces branches set linear constraints.
collecting inequalities form (43) constrain single branch, express
constraints matrix form:
Ax b,
(44)




a1,1
..
A= .
an,1


..
.





a1,m
x1
b1
.. , x = , b =
.
xm
bm
an,m
82

fiPDT Logic

form representation close connection linear programming (LP). Linear
programming (e.g., Murty, 1983) solution method optimization problems
linear function set continuous variables xk optimized respect given
set linear constraints. task satisfiability checking require
optimization thus actually solving linear program required work,
exploit similarities sets linear constraints LP order show
satisfiability problem solved.
standard form LP problem (Murty, 1983) gives set constraints exactly
form (44). Every solution x satisfies constraints called feasible
entire solution space (44) called feasible region. Thus, checking whether set belief
formulae B satisfiable equivalent checking whether corresponding LP problem
non-empty feasible region. standard LP problems constraints form
(44), feasible region convex polytope, allows performing check little
computational effort (Garey & Johnson, 1979).
Unfortunately, extracting linear constraints set belief formulae B described
Section 4.3.2 yield single set constraints form (44), instead
disjunction different sets constraints. gives rise representation
satisfiability checking problem disjunctive program (DP) (Balas, 1998):
Corollary 4.8 (Satisfiability Checking Disjunctive Program). Let B set belief
formulae, let set threads let set disjunctive branches linear
constraints extracted B according extraction rules (38)-(42). Then,
satisfiability checking problem formulated disjunctive program (Balas, 1998):
_
Ad x bd
(45)
dD

B satisfiable respect , denoted sat(B, ), (45) solution.
disjunctive program called bounded, range every variable xk restricted
lower upper bounds. Since rely bounded property subsequently,
state following result:
Lemma 4.9 (Satisfiability Checking Bounded DP). Let B set belief formulae
set threads. Checking satisfiability B respect represented
bounded disjunctive program.
Proof. straightforward result: Corollary 4.8 shows satisfiability checking
PDT Logic represented disjunctive program form (45). Since
every variable xk (45) represents probability value, xk naturally bounded
0 xk 1.
disjunctive program, feasible region cannot guaranteed convex anymore,
guaranteed solution space even represents connected region.
significantly increases complexity determining whether nonempty solution space
exists. analyze problem detail show connections established
solution approaches, discuss next section disjunctive program
form (45) transformed.
83

fiMartiny & Moller

4.3.4 Transformation 0-1 Mixed Integer Linear Program
concept linear programs continuous variables xk subject linear constraints
form (43) extended so-called mixed integer linear programs (MILPs) (Schrijver,
1986). Opposed standard linear programming, MILPs required
variables xk continuous domain. Instead, MILPs use mix continuous
integer variables. several equivalent ways representing MILP, adopt
representation Fischetti, Glover, Lodi (2005), specifies constraints
MILP
Ax b

xj integer

j

index set indicating variables xj integer variables. special
case MILPs 0-1 mixed integer linear programs (Williams, 2009), integer
variables xj restricted binary values:
Ax b

xj {0, 1}

(46)
j

augmenting set variables x binary switching variables xj every possible
disjunction, possible represent disjunctive programs form (45) 0-1 MILPs
form (46) (Balas, 1985). leads central result satisfiability checking
PDT Logic:
Theorem 4.10 (Satisfiability Checking 0-1 MILP). Let B set belief formulae
set threads. problem checking satisfiability B respect
transformed corresponding 0-1 mixed integer linear program B
satisfiable respect iff feasible solution.
Proof. Lemma 4.9 shows satisfiability checking PDT Logic represented
bounded disjunctive program, set belief formulae B satisfiable iff
corresponding bounded disjunctive program feasible solution. proof Theorem
4.4 Balas (1985) shows every bounded disjunctive program equivalently
represented 0-1 mixed integer program . Consequently, satisfiability checking
PDT Logic equivalent checking whether feasible solution.
leverage Theorem 4.10 obtain complexity results satisfiability problem
PDT Logic:
Theorem 4.11 (Complexity PDT SAT w.r.t. given set threads). Checking satisfiability set PDT Logic belief formulae B respect given set threads
NP-complete.
Proof. generally known checking whether bounded 0-1 mixed integer linear
program feasible solution NP-complete (cf. Bienstock, 1996). Theorem 4.10
shows satisfiability checking PDT Logic respect given set threads
reformulated 0-1 MILP bounded variables xk (cf. Lemma 4.9), follows
84

fiPDT Logic

satisfiability checking set belief formulae B respect given set threads
NP.
Arbitrary propositional formulae F (cf. Definition 3.2, p. 45) expressed PDT
1,1
Logic using belief object strict prior belief Bi,0
(F ). Since well known
boolean satisfiability problem (SAT) NP-complete (Cook, 1971), follows
problem NP transformed satisfiability checking problem PDT Logic.
Hence, satisfiability checking problem PDT Logic NP-hard consequently NPcomplete.
NP-completeness result shows problem NP therefore immediately obtain another important property satisfiability problem PDT Logic:
Corollary 4.12 (Decidability PDT SAT). Checking satisfiability set PDT Logic
belief formulae B decidable.
MILPs subject extensive research decades, thus ample variety
solving methods proposed (e.g., Balas, Ceria, & Cornuejols, 1993, Balas, Ceria,
& Cornuejols, 1996, Balas & Perregaard, 2002, name notable work
MILP solving, especially Fischetti et al., 2005 Bertacco, Fischetti, & Lodi, 2007
find feasible solutions MILPs). research gave rise various efficient implementations
MILP solvers, commercial (e.g., ILOG, 2016, Gurobi Optimization, Inc., 2016)
non-profit products (e.g., Gnu Project, 2016, Computational Infrastructure Operations
Research (COIN-OR) Project, 2016). given set threads, PDT Logic satisfiability
checking reformulated 0-1 MILP problem, thus state-of-the-art
MILP solvers exploited relatively fast satisfiability checks instances
PDT Logic belief formulae B respect given set threads .
results section show satisfiability set PDT Logic belief formulae B decided respect given set threads, even specific prior
probability assignment specified. overall goal section design
decision procedure requires set belief formulae B input, continue
discussion satisfiability testing development method automatically
construct set threads representing background knowledge specified B.
4.4 Prior Constraints Possible Threads
determine whether set belief formulae B satisfiable, need obtain set
possible threads reflects background knowledge specified B. section,
describe identify certain constraints set possible threads prior
actually starting generate threads represent information specified B.
identify prior constraints, discuss different properties belief formulae contained B. Using properties, create taxonomy belief formulae depending
respective impact set possible threads . Beliefs certain properties
used constrain search space sets possible threads prior actually search sets. discussing prior constraints section, use
results Section 4.5 develop decision procedure PDT Logic requires neither
specification probabilities specification possible threads.
85

fiMartiny & Moller

4.4.1 Taxonomy Belief Formulae
set belief formulae B may contain beliefs various features different
impacts sets admissible worlds specific time points t. discuss
features show yield taxonomy belief formulae. taxonomy
allows classification beliefs three different types respect impact
sets admissible worlds. particular, identify beliefs independent
specific probability assignment Kripke relations Ki . classification
technical purposes: beliefs depend neither specific probability assignments
specific Kripke relations used derive initial constraints sets possible
worlds time points tmax . use B denote set worlds
admissible respect set belief formulae B, use B (t) denote set
admissible worlds respect set belief formulae B time t.
Recall three different kinds beliefs: beliefs facts, beliefs rules,
beliefs beliefs. before, differentiate prior beliefs hold time point
= 0 (and therefore commonly known among agents) posterior beliefs hold
time points > 0.
`,u pfr
distinguish beliefs rules Bi,t
0 (rt (F, G)) respect t: call
pfr
pfr
(F, G) dynamic rule > 0. Accordingly,
(F, G) static rule = 0 call rt
rt
separate beliefs rules beliefs static rules beliefs dynamic rules,
respectively. beliefs differ respect temporal impact: static rule
constrain possible worlds instantaneously, i.e., r0pfr (F, G) states
world |= F 6|= G hold. dynamic rule hand requires
whenever world |= F occurs, must another world 0 0 |= G
time steps.
Finally, classify beliefs respect probabilistic quantifications: call
`,u
belief Bi,t
0 () strict, ` = u = 0 ` = u = 1. sake simplicity,
following assume without loss generality strict beliefs always represented
0,0
1,1
` = u = 1. strict belief Bi,t
() easily rewritten Bi,t
().5 call belief
trivial ` = 0 u = 1. Obviously, beliefs trivially satisfied arbitrary
interpretation, thus impact satisfiability checking results therefore
removed B.
Remark 4.2. definition belief semantics (Definition 3.11, p. 57) follows
1,1
special case strict beliefs Bi,t
() (i) agent considers occurrence belief
objects complement impossible (ii) occurrence indeed impossible.
Thus, strict beliefs comply common definitions knowledge justified true belief
belief stable respect truth (cf. e.g., Shoham & Leyton-Brown, 2009,
page 433). Consequently, could refer strict belief knowledge equivalently
use established knowledge operator Ki () instead Bi1,1 ().
1,1
Remark 4.3. Note concept strict beliefs applies positive beliefs Bi,t
().
1,1
negation belief, Bi,t (), follows Definition 3.16 (p. 63)
fr
fr
5. belief object temporal rule rt
(F, G), represent rt
(F, G). possible
need consider frequency functions correspond axioms FF1 FF2
Definition 3.10 (p. 55) use point frequency functions pfr. frequency functions used,
negations need defined accordingly.

86

fiPDT Logic

least one thread satisfy belief object , turn implies ` < 1.
1,1
Consequently, beliefs Bi,t
() considered non-strict following discussion.

Using features, create taxonomy beliefs depicted Figure 3
identify prior constraints set possible threads. taxonomy obtained
successively distinguishing strict non-strict, prior posterior beliefs,
beliefs facts, rules nested beliefs, finally beliefs static dynamic
rules. Nested beliefs considered strict (prior) beliefs, involved beliefs
strict (prior), otherwise considered non-strict (posterior). nested belief
actually strict prior, unnest belief consider innermost belief
expression: since prior beliefs commonly known therefore identical agents
AB , evident strict belief agent i, agents know agent
strict belief. Consequently, strict prior beliefs nested arbitrary depth
without introducing constraints: satisfied exactly innermost
belief satisfied. Thus, need consider nested strict prior beliefs explicitly.
taxonomy gives rise three different types belief formulae respect
impact sets admissible worlds:
Definition 4.3 (Belief formula typification). set belief formulae B categorized
three different types beliefs:
Type 0: beliefs restrict set admissible worlds B (t) every
time point . Thus, type 0 beliefs highest impact
exploited prune set admissible worlds B globally. evaluation
beliefs relies neither specific probability assignment given Kripke
structures Ki .
Type 1: beliefs restrict sequences possible worlds. Moreover,
potentially restrict sets admissible worlds B (t) specific time points.
Thus, type 1 beliefs less impact type 0 beliefs
exploited prune sets admissible worlds B (t) locally. Again, evaluation
beliefs relies neither specific probability assignment given
Kripke structures Ki .
Type 2: type encompasses remaining beliefs B neither type 0
type 1 beliefs. beliefs situation-specific cannot used prune
sets admissible worlds priori. Satisfiability beliefs depends suitable
probability assignment evaluation Kripke structures respective
threads.
use Tk (B) denote set type k beliefs B.
main goal belief formula taxonomy identify constraints possible
worlds possible threads h evaluated prior searching suitable
probability assignment, namely using belief formulae T0 (B) T1 (B) prune
search space possible sets threads may show satisfiability B.
noted existence thread h violating belief T0 (B) T1 (B)
technically preclude satisfiability B respect , special
87

fiMartiny & Moller

beliefs

non-strict beliefs
`<1

strict beliefs
`=1

` = 1,
innermost beprior beliefs
lief interest

posterior beliefs
t0 > 0

0

=0
belief 0 beliefs
1,1
` ,u0
Bi,0
(Bj,t
())

belief beliefs
`,u
1,1
B1,1
0 (Bj,t ())
TF
1 (B)

belief rules
1,1 fr
Bi,0
(rt (F, G))

belief facts
1,1
Bi,0
(Ft )

disjunctive belief
formulae
1,1
1,1
Bi,0
(1 ) Bi,0
(2 )

belief dynamic rules
> 0

belief facts
1,1
Bi,t
0 (Ft )
belief rules
1,1 fr
Bi,t
0 (rt (F, G))

disjunctive belief
formulae
1,1
1,1
Bi,0
(1 ) Bi,0
(2 )

belief dynamic rules
> 0

T1 (B)

belief static rules
= 0
T0 (B)

Type 0: beliefs
highest impact,
restrict every
world every time point.

belief static rules
= 0

Type 1: beliefs restrict threads independently probabiliy assignment.
Moreover, potentially restrict possible worlds individual time points.

Figure 3: Taxonomy belief formulae

88

T2 (B)

Type 2: remaining beliefs;
treated way.

fiPDT Logic

case suitable probability assignment: thread h
belief B T0 (B) B T1 (B) satisfied, could still suitable probability
assignments I(T ) sat(B, ) holds iff I(T h) = 0. effect excluding
thread h assigning prior probability I(T h) zero (cf. Remark 3.3,
p. 53), i.e., respective thread marked impossible. Since aim reducing
search space possible threads input satisfiability check sat(B, ),
exploit belief formulae T0 (B) T1 (B) exclude impossible threads prior searching
suitable probability assignments.
Type 0 belief formulae depicted Figure 3, set type 0 belief formulae
1,1 pfr
formed formulae strict prior beliefs static rules Bi,0
(r0 (F, G)) B. Since
prior beliefs represent background knowledge since follows definition
strict beliefs cannot violated world, clear rule r0pfr (F, G)
always satisfied. static rule, satisfied every world
B . define set type 0 beliefs
1,1 pfr
T0 (B) = {B B : B = Bi,0
(r0 (F, G))}

(47)

arbitrary formulae F G.
Type 1 belief formulae set type 1 beliefs contains strict prior beliefs
set T0 (B). contributions set T1 (B) twofold: T1 (B)
comprises strict prior beliefs, every thread potential set threads satisfy
beliefs B T1 (B). Moreover, constraints T1 (B) may constrain sets worlds
B (t) individual time points regardless specific thread. According
Figure 3, define set type 1 beliefs

1,1
T1 (B) = B B :
B = Bi,0
(Ft )
1,1 pfr
B = (Bi,0
(rt (F, G)) > 0)

1,1
1,1
B = (Bi,0
(1 ) Bi,0
(2 ) )



(48)

potential set possible threads , beliefs specified set T1 (B)
satisfied every thread h . Note satisfiability beliefs dynamic rules
disjunctive belief formulae generally depends worlds multiple time points thus
satisfiability T1 (B) cannot ensured constraining sets worlds single time
points. However, analyzing strict prior beliefs facts potential interplay
dynamic rules derive constraints sets worlds B (t) specific time points
follows.
1,1
Strict prior beliefs facts B = Bi,0
(Ft ) restrict set admissible worlds B (t)
time enforcing F holds every world B (t). following, use TF1 (B)
denote strict prior beliefs facts F certain time points t. Moreover, use
1,1
B |= Ft shorthand Bi,0
(Ft ) B denote B enforces F time t.
interplay existing constraints sets possible worlds B (t) individual
time points t, strict beliefs dynamic rules yield additional constraints: belief
1,1 pfr
formula B = Bi,0
(rt (F, G)), > 0, additional constraints might derived, depending
type belief respective rules premise F : (T0 (B) TF1 (B)) |= Ft given,
89

fiMartiny & Moller

1,1
extract strict prior belief fact B 0 = Bi,0
(Gt+t ), restricts
set possible worlds time point + therefore added TF1 (B).
Since dynamic rules considered temporal implications (cf. Definition 3.10
Section 3), rules applied backwards obtain additional constraints:
1,1 pfr
belief formula B = Bi,0
(rt (F, G)), > 0 given rules negated conclusion G
already enforced time point (i.e., (T0 (B) TF1 (B)) |= Gt ), rules premise
1,1
F cannot satisfied time t. Thus, add belief B 0 = Bi,0
(Ftt )
F
additional constraint T1 (B).
Extending set type 1 beliefs dynamic rules may lead chained ex1,1 pfr
tension: belief dynamic rule Bi,0
(rt (F, G)) corresponding belief
1,1
1,1
F
Bi,0 (Ft ) T1 (B), lead additional belief Bi,0
(Gt+t ) TF1 (B),
1,1 pfr
turn might trigger another dynamic rule Bi,0
(rt (G, G0 )). Analogously, additional
belief TF1 (B) could trigger backward rule applications.
capture constraints emerge forward backward chaining strict
dynamic rules, define set TF1 (B) following fix-point set:6

TF1 (B) =

1,1
{Bi,0
(Ft ) B}
1,1
{Bi,0
(Gt+t ) :

1,1 pfr
> 0 Bi,0
(rt (F, G)) B

(T0 (B) T1 (B)) |= Ft }

1,1
{Bi,0
(Ftt ) :

1,1 pfr
> 0 Bi,0
(rt (F, G)) B

(T0 (B) T1 (B)) |= Gt }

(49)

determined constraints individual time points, reduce
1,1
set TF1 (B) contains one belief Bi,0
(Ft ) every time point t.
1,1
1,1
F
T1 (B) contains multiple beliefs Bi,0 (Ft ), Bi,0 (Gt ) regarding time point t,
1,1
replace joint belief Bi,0
(Ft0 ) F 0 = F G. Note substitution
uses Lemma 3.7 (p. 64) merge different belief expressions one expression
conjunctive belief object. still assume belief formulae conjunctions belief
operators separated atomic belief formulae.
Type 2 belief formulae set type 2 belief formulae consists beliefs B
neither type 0 type 1 beliefs. Thus define set
T2 (B) = (B \ T0 (B)) \ T1 (B)

(50)

6. representation, considered influence temporal rules set TF
1 (B).
1,1
1,1
principle, information disjunctive formulae B = Bi,0
(1 ) Bi,0
(n ) T1 (B) could yield
additional constraints sets B (t): TF
1 (B) enforces n1 disjuncts B false, remaining
disjunct must satisfied. belief objects respective disjuncts might dynamic rules again,
formal representation consideration would result rather intricate specification. Since
ensure potential thread satisfies beliefs T1 (B) anyways, omitting disjunctive formulae
construction TF
1 (B) impact satisfiability results. Yet actual implementation
described procedures could exploit consideration obtain additional pruning conditions special
cases.

90

fiPDT Logic

Example 4.5 (Trains continued). Continuing set belief formulae B Example 4.1 (p. 72) assuming conjunctive formulae B = B 0 B 00 treated
individual formulae B 0 B 00 , obtain following sets typed belief formulae:
1,1 pfr

T0 (B) = BA,0
r0 (punct(train) at(train, city), Obs{A} (punct(train)))
(B5 )
1,1

T1 (B) = BA,0
at(T1 , CA )1 ,

1,1
BA,0
on(A, T1 )1 ,

(B10 )
(B100 )


1,1
BA,0
r3pfr ( punct(T1 ) at(T1 , CA ), at(T2 , CC ) on(A, T2 )) ,

1,1 pfr
BA,0
(r5 (punct(T1 ) at(T1 , CA ), at(T2 , CC ) on(A, T2 )) ,

1,1
BA,0
r2pfr ( punct(T2 ) at(T2 , CC ), at(T2 , CB ) on(A, T2 ))

1,1
BA,0
r3pfr (punct(T2 ) at(T2 , CC ), at(T2 , CB ) on(A, T2 )) ,
1,1

TF1 (B) = BA,0
at(T1 , CA )1 ,

1,1
BA,0
on(A, T1 )1 ,

(B30 )
(B300 )
(B40 )
(B400 )
(B10 )
(B100 )

T2 (B) = B \ T0 (B) \ T1 (B)

.81,.81 pfr
= {BA,0
r0 (at(T1 , CA ), punct(T1 )) ,

.81,.81 pfr
BA,0
r0 (at(T2 , CC ), punct(T2 )) ,

.93,.93 pfr
BA,0
r2 (Obs{A} (punct(train)), Obs{AB} (punct(train))) }

(B20 )
(B200 )
(B6 )

taxonomy belief formulae provides means construct sets admissible worlds
B (t) every time point . Type 0 beliefs (i.e., beliefs highest impact)
constrain global set possible worlds B . Certain beliefs type 1materialized
set TF1 (B)can give additional constraints specific time points t,
subsets B (t) B need considered possible worlds time t. sets
T0 (B) T1 (B) together provide satisfiability conditions independent
specific probability assignments. Then, beliefs type 2 need considered
probabilistic constraints check whether B satisfied respect , i.e.,
satisfiability problem sat(B, ) previous section reduced sat(T2 (B), ),
unsatisfiability B yet shown constraints T0 (B) T1 (B).
Since prior constraints define necessary conditions potential thread, give
rise definition thread soundness respect given set belief formulae B:
Definition 4.4 (Thread soundness). Let B set belief formulae, let T0 (B)
T1 (B) set type 0 type 1 belief formulae set, respectively. Then,
thread h sound respect B (denoted snd(T h, B)) satisfies belief formulae
T0 (B) T1 (B):
snd(T h, B) B (T0 (B) T1 (B)) : h |= B
91

(51)

fiMartiny & Moller

Accordingly, use snd(T , B) denote threads h sound.
Note definition relies strict prior beliefs soundness property
therefore verified every thread individually, without consider threads
probability assignments. Thus, simplified version model checking procedure
Section 4.1 used verify soundness. intuition behind property
verify easily prior checking sat(B, ) therefore obtain reduced version
satisfiability problem:
Theorem 4.13 (Reduced satisfiability checking). Let B set belief formulae, let
T2 (B) set type 2 beliefs B according (50), let set sound
threads. Then, B satisfiable respect iff T2 (B) satisfiable respect :
sat(B, ) snd(T , B) sat(T2 (B), )

(52)

Proof. follows directly Definition 4.4: snd(T , B) defined satisfies
belief formulae sets T0 (B) T1 (B). Consequently, sets resemble tautologies
respect therefore impact satisfiability checking
properties. Thus, instead checking B satisfiability, suffices check set (B \
T0 (B)) \ T1 (B), exactly definition T2 (B).
4.4.2 Constraining Possible Worlds Individual Time Points
Using classification beliefs B three different types, continue
constructing sets possible worlds B (t) every time point . main goal
section identification obvious pruning conditions possible worlds specific
time points. Since process searching set possible threads
satisfies set belief formulae B, constraints sets B (t) potential
significantly reduce later used search space. Thus, results section highlight
possible optimizations implementation PDT Logic sat solver. Even following constraints notor partiallyapplied, search possible threads
described subsequent Section 4.5 carried out, yet potentially larger search
space.
Since set type 0 beliefs satisfied every admissible world, define
global set admissible worlds B follows:
Definition 4.5 (Global set admissible worlds). Let B set belief formulae,
corresponding sets belief objects FB type 0 beliefs T0 (B). Then, set
admissible worlds B w.r.t. B given
n


1,1 pfr
B = B FB : adm() Bi,0
(r0 (F, G)) T0 (B) : |= (F G) .
(53)
Remark 4.4. definition uses adm() ensure worlds B admissible
defined external Definition 3.5 (p. 48). Alternatively, could use existing
formalism encode admissibility conditions directly strict prior beliefs B:
1,1 pfr
1,1 pfr
Bi,0
(r0 (ObsG (l), l)) G 0 G : Bi,0
(r0 (ObsG (l), ObsG 0 (l))) represent conditions 1
2 Definition 3.5, respectively. However, since conditions independent
respective problem modeled, include problem-specific belief
set B, use external constraints.
92

fiPDT Logic

Example 4.6 (Trains continued). global set worlds B admissible respect
B Example 4.1 (p. 72) automatically constructed combinations
events FB shown Example 4.2 (p. 73), given combinations admissible
respect Definition 3.5 satisfy type 0 beliefs T0 (B) Example 4.4
(p. 81). refrain enumerating worlds explicitly instead describe
worlds excluded Herbrand base B FB FB : FB follows
possible shared observation B fact train punctual
(Obs{AB} (punct(train))). every possible world observation occurs, admissibility conditions require agents B observe respective train
punctual train indeed punctual. Furthermore, beliefs T0 (B)
require corresponding observation every possible world
train punctual (which incidentally enforces admissibility conditions
observations).
Next, build upon set globally admissible worlds B use set
type 1 beliefs prune set admissible worlds B (t) individual time points
t:
Definition 4.6 (Local sets admissible worlds). Let B set belief formulae
corresponding sets admissible worlds B , TF1 (B) set materialized strict
prior beliefs induced T0 (B) T1 (B), set time points. Then, set
admissible worlds B (t) w.r.t. B time given
n


1,1
F
B (t) = B : Bi,0 (Ft ) T1 (B) : |= F
.
(54)
Example 4.7 (Trains continued). obtain scenario original Example 3.2,
assume tmax = 9. set TF1 (B) identified Example 4.5, restrict set
worlds time 1
n

B (1) = B : |= (at(T1 , CA ) on(A, T1 ))
time points, options restrictions, thus respective
local sets B (t) possible worlds time points 6= 1 remain B .
Using Definition 4.6, formulate constraints set sound threads :
h , : h(t) B (t).

(55)

Note constraint provides necessary sufficient condition thread
soundness. illustrate this, consider Example 4.5 again: set TF1 (B) requires
{at(T1 , CA ), on(A, T1 )} holds every possible world time = 1 thus constrain B (1) shown Example 4.7, thread violating constraint
inherently unsound. hand, thread according (55) may contain
fact, say punct(T1 ) h(1), whichaccording B30 yields sound thread
{at(T2 , CC ), on(A, T2 )} h(4) holds well. Thus, (55) provides general constraints
set threads respect beliefs T0 (B) TF1 (B), additional beliefs
T1 (B) discard individual threads catching potential unsatisfiable interplay
possible worlds different time points.
93

fiMartiny & Moller

course, general possible methods discussed far result special
cases: one thing, possible B induces set T0 (B) TF1 (B) inconsistent
beliefs, i.e., contain beliefs contradict other. Then, B B (t)
empty. precludes creation set threads I(T ) |= B.
case, satisfiability checking terminate immediately negative result.
another, possible simplification process result empty set
T2 (B). case, probabilistic constraints could impact satisfiability
B thus unnecessary search suitable probability assignment. case,
needs checked whether threads compliance (55) sound according
Definition 4.4. thread found, satisfiability checking terminate
immediately positive result, otherwise B unsatisfiable. Verifying soundness
single thread done simplified version model checking procedure
Section 4.1 therefore PTIME (cf. Corollary 4.3). However, number threads
satisfying condition (55) grow exponentially number ground atoms
number time points, problem finding sound thread complex:
Theorem 4.14 (Complexity finding sound thread). Let B set belief formulae
included formulae grounded. Deciding whether exists sound thread
respect B, defined Definition 4.4, NP-complete.
Proof. According Definition 4.4, set sound satisfies formulae set
T0 (B) T1 (B). treating belief objects atoms F time points individual
variables Ft , transform beliefs facts belief rules T0 (B) T1 (B)
boolean sat problem follows:7
1,1
Bi,0
(Ft )

Ft

1,1 pfr
Bi,0
(rt (F, G))

tmax
^t
t=0

(Ft Gt+t )

Accordingly, disjunctive belief formulae expressed transforming every
disjunct individually. transformation requires tmax conjuncts every belief
operator therefore performed linear time. Since boolean sat problem
known NP-complete (Cook, 1971), follows searching sound thread
respect B NP.
NP-hardness problem already shown proof Theorem 4.11
(p. 84) consequently follows searching sound thread respect B
NP-complete.
noted result analyzes worst-case complexity problem,
practice finding sound thread usually dominated worst case.
cases, sound thread found easily employing principle least effort:
1,1 pfr
belief temporal rules Bi,0
(rt (F, G)), choosing worlds |= F ensures
consequences rule evaluated time points. Accordingly,
7. transformation defined temporal rules point frequency functions pfr.
frequency functions used, transformation adapted accordingly.

94

fiPDT Logic

disjunctive rules disjunct selected temporal rule triggered
fact. course, heuristic may give sound thread immediately
every input B, represents feasible approach problems. illustrate
approach example subsequently.
work, consider ground formulae PDT Logic. general, formalism
introduced Section 3 allows treatment non-ground formulae well. However,
non-ground formulae complexity result Theorem 4.14 hold,
transformation boolean sat problem exponential number possible
groundings. Finding sound thread requires use sophisticated grounding procedures, (e.g., Dal Palu, Dovier, Pontelli, & Rossi, 2009 Faber, Leone, & Perri, 2012),
beyond scope work.
sets possible worlds identified every time point , proceed
creating sets representative threads respect constraints. aim
following discussion successive generation set representative threads
sat(B, ) decided.
4.5 Representative Threads
Using Definition 4.4 constraint (55) gives rise potential definition set
possible threads constructing possible combinations sound world sequences
B (t) . However, would still result unnecessarily large set possible
threads. Instead constructing threads explicitly, heuristically create
representative threads represent excerpts situations modeled T2 (B).
approach uses heuristics successively expand set representative threads. soon
suitable set threads (i.e., model B) found, decision procedure terminate
positive result. set representative threads show satisfiability
B, additional threads created either positive satisfiability result obtained
possible threads created. Consequently, heuristic search models
constitutes complete decision procedure PDT Logic.
following discussion, assume set T2 (B) nonempty, i.e.,
additional constraints need satisfied generated set threads. Otherwise,
set T2 (B) empty, satisfiability could already determined checking whether
sound thread respect B exists, discussed previous section
would need generate specific set threads.
`,u
`0 ,u0
beliefs facts Bi,t
0 (Ft ) B, dual belief negated fact Bi,t0 (Ft )
`0 = 1 u u0 = 1 ` (cf. Corollary 3.4, p. 59) satisfied well.
`,u fr
beliefs rules Bi,t
0 (rt (F, G)), satisfiability depends accumulated subjective posterior interpretations threads weighted respective frequencies. goal
`,u
following procedure successively create threads every belief fact Bi,t
0 (Ft )
T2 (B), obtain representatives set threads (i) satisfy
respective fact Ft set threads satisfy Ft , (ii) exhibit varying fre`,u fr
quencies beliefs temporal rules Bi,t
0 (rt (F, G)) T2 (B). Consequently, belief
formulae considered splitting rules application generate representative threads results procedure similar tableau-based methods. However, beliefs
temporal rules induce splits forward backward time thusunlike con95

fiMartiny & Moller

ventional tableau-based methodsthe following procedure create tree structure,
instead set sequences represent possible threads. key difference
generation representative threads logical sat solvers PDT Logic
virtually impossible discard generated potential thread: probabilistic nature semantics requires threads considered given formula
holds, threads not. Thus, even threads violating objects given
belief formulae usually required show satisfiability corresponding set belief
formulae B. following discussion provides general outline decision procedure
PDT Logic set belief formulae B given. actual implementation
methods possible, obtain feasible run times practical problems, various
optimization techniques research logic reasoning implementations would need
implemented, beyond scope work.
4.5.1 Generating Representative Threads
`,u
Since existence non-strict belief fact Bi,t
0 (Ft ) requires existence
least two threadsone, respective belief object satisfied one,
not8 start creating two threads hB (1), ..., B (tmax )i obtain
set = hT h1 , h2 h1 |= h2 |= belief objects = Ft contained
set T2 (B) obtain minimal set set threads belief formulae
B T2 (B) potentially satisfied. set subsequently expanded
additional threads either suitable set threads show satisfiability T2 (B)
found, additional threads created.
allow concise notation, following adapt frequency notation
belief objects use (1 ) denote true, (0 ) denote false,
generally (x ) denote holds frequency x. course, values 0 < x < 1
occur belief objects represent temporal rules. notation, try
create initial sound threads
^
h1 |= (1 j ),
(56)
j

h2 |=

^
j

(0 j )

(57)

holds respective belief objects j belief formulae Bj T2 (B).9
initial set = {T h1 , h2 } meant represent two extreme choices possible
threads respect T2 (B) provide suitable starting point subsequently
employed search heuristic. general, necessarily possible create extreme
threads compliance (56) (57) every possible set belief formulae T2 (B).
`,u
`,u
instance, T2 (B) might contain conflicting beliefs facts Bi,t
0 (Ft ) Bi,t0 (Ft ). Obviously,
single thread satisfy belief objects simultaneously, might still possible
`,u
8. Technically, non-strict belief Bi,t
0 () could satisfied single thread h h |=
beliefs quantification upper bound u = 1. might give rise optimizations
actual implementation, sake simplicity, consider case explicitly.
`,u
`,u
0
00
9. notation slightly simplified: disjunctive belief formulae Bj = Bi,t
0 (j ) Bi,t0 (j ), use j
0
00
abbreviation j j .

96

fiPDT Logic

create set threads thattogether suitable probability assignmentboth
beliefs satisfied. Thus, (56) (57) characterize intended goal creating
initial threads h1 , h2 , represent hard constraints threads.
find suitable threads match constraints, employ principle least
`,u
effort adding facts possible thread: every belief fact Bi,t
0 (Ft ),
add explicit constraints F h1 (t) F 6 h2 (t), h1 represents
thread belief objects true h2 represents set belief objects
`,u fr
false. beliefs rules Bi,t
0 (rt (F, G)) add G h1 (t + t) (resp. F h1 (t t))
whenever another constraint enforces F h1 (t) (resp. G h2 (t)). occurrence
fr (F, G) trivially satisfied frequency
F respectively G enforced h1 , rule rt
1 (i.e., occurrences F followed G steps)
constraints need added. Analogously, h2 need ensure F holds
least whenever F h2 (t) holds, G h2 (t + t) holds, well.
`,u
`,u
disjunctive belief formulae Bi,t
0 (1 ) Bi,t0 (2 ), need ensure belief object 1
2 holds thread h1 , described above, 1 2 holds thread h2 .
possible, respective belief object 1 2 thread h1 chosen
additional beliefs triggered (we say belief triggered fact F , existence
F enforces another constraint belief temporal rule disjunctive belief
formula). Nested belief formulae treated respect innermost belief
object. constraint cannot applied conflict previously added
constraints T2 (B), simply skipped stage. creation h1 h2
initialization step heuristic search possible set threads, skipped constraints
still considered later subsequent expansions.
Whenever constraint regarding fact F added h1 h2 , necessary
check whether triggers additional rules set type 1 beliefs T1 (B). necessary,
resulting facts added respective threads. application works analogously
construction set TF1 (B) described Section 4.4.1. Finally, belief
formulae processed, search sound thread respect created
constraints. Usually, sound thread found easily choosing facts
yet unconstrained h1 h2 trigger additional beliefs.
Especially, possible worlds h(t) unconstrained, choose h(t) = B
contain belief rules purely negative preconditions disjunctive belief
formulae satisfiable . generally, principle least effort
employed worlds selected belief formulae need
considered. selection impossible addition F F
world triggers additional beliefs. Then, consequences adding respective fact
need evaluated, well. resulting set = {T h1 , h2 } provides minimal
set representative threads used check sat(T2 (B), ).
following, show principle least effort used obtain representative threads efficiently possible. constraints used following example
provide minimal number constraints need enforced obtain representative threads desired threads h1 h2 . worlds without specific
constraints, simply use = . One easily verify indeed yields threads
compliance (56) (57).

97

fiMartiny & Moller

Example 4.8 (Trains continued). continue train example sets typed
belief formulae specified Example 4.5 (p.91). Example 4.7 (p. 93), shown
set worlds time 1 B (1) restricted {at(T1 , CA ), on(A, T1 )}
every world B (1). set T2 (B) contains three non-strict belief formulae, namely

.81,.81 pfr
T2 (B) = {BA,0
r0 (at(T1 , CA ), punct(T1 )) ,
(B20 )

.81,.81 pfr
BA,0
r0 (at(T2 , CC ), punct(T2 )) ,
(B200 )

.93,.93 pfr
BA,0
r2 (Obs{A} (punct(train)), Obs{AB} (punct(train))) }
(B6 )
evaluating belief formulae, obtain constraints possible worlds
threads h1 h2 . visualization following steps given Figure 4.
Analysis belief formula B20 results constraints punct(T1 ) h1 (1)
punct(T1 ) 6 h2 (1). facts turn trigger rules B30 B300 , respectively:

1,1
BA,0
r3pfr ( punct(T1 ) at(T1 , CA ), at(T2 , CC ) on(A, T2 ))

1,1 pfr
BA,0
(r5 (punct(T1 ) at(T1 , CA ), at(T2 , CC ) on(A, T2 )) ,

(B30 )
(B300 )

resulting additional constraints {at(T2 , CC ), on(A, T2 )} h1 (4) {at(T2 , CC ),
on(A, T2 )} h2 (6).
Application belief formula B200 yields additional facts punct(T2 ) h1 (4)
punct(T2 ) 6 h2 (6). Again, triggers rules T1 (B):

1,1
(B40 )
r2pfr ( punct(T2 ) at(T2 , CC ), at(T2 , CB ) on(A, T2 ))
BA,0

1,1 pfr
(B400 )
(r3 (punct(T2 ) at(T2 , CC ), at(T2 , CB ) on(A, T2 )) ,
BA,0
resulting additional constraints h1 (6) = at(T2 , CB ), on(A, T2 ) h2 (9) =
at(T2 , CB ), on(A, T2 ).
Note belief formula

1,1
BA,0
r0pfr (punct(train) at(train, city), Obs{A} (punct(train)))
(B5 )
T0 (B) provides global constraint set possible worlds B
Obs{A} (punct(train)) holds every world punct(train) holds, thus obtain
thread h2 additional facts Obs{A} (punct(T1 )) h2 (1) Obs{A} (punct(T1 ))
h2 (6).
Finally, rule

.93,.93 pfr
BA,0
r2 (Obs{A} (punct(train)), Obs{AB} (punct(train)))
(B6 )

98

fiPDT Logic

00
h2 B2
B5
0
h1 B2

at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )

B300

B200
B5

B30

B200

at(T2 , CC ), on(A, T2 )
punct(T2 )



1

B40


4

at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CB ), on(A, T2 )

6

B400



at(T2 , CB ), on(A, T2 )

9



1

Figure 4: Visualization representative thread set generation train example.
threads start given facts at(T1 , CA ), on(A, T1 ). Applications
formulae T2 (B)such h1 contains positive belief objects h2
contains negative belief objectsare marked blue, additional constraints
T0 (B) T1 (B) marked red.

change created threads h1 , h2 : h1 rules precondition never
enforced satisfied thus resulting frequency one, lack
observation h2 even though nonpunctual trainsensures resulting
frequency zero.
trying solve resulting problem sat(T2 (B), {T h1 , h2 }), non-strict belief
formulae yield following constraints h1 :
B20 :
B200

:

B6 :

0.81 I(T h1 ) 0.81

0.81 I(T h1 ) 0.81

0.93 I(T h1 ) 0.93

Clearly, constraints cannot satisfied simultaneously therefore set =
{T h1 , h2 } insufficient show satisfiability T2 (B) (and therefore B).
created set threads fails show satisfiability T2 (B), additional threads
created continue searching expanded set T2 (B) satisfied
respect . Based existing thread h, additional thread h0 created
ensuring one conjunct h1 h2 (56) (57) satisfied anymore,
i.e., given thread h existing constraints (xk k ), new thread h0
obtained substitution
^
^
h |= (xj j ) h0 |=
(xj j ) x0k k , x0k 6= xk .
(58)
j

j6=k

Every substitution one conjunct new constraint provides choice point
direct continuation search suitable set threads. constraint notation
58 used provide formal characterization choice points. practice, new thread
h0 satisfying constraint usually created easily addition new
modification existing facts h follows. simplify following discussion,
assume expansion keeps history expansion steps resulting consequences,
effects adding additional F undone respective fact F
changed newly created thread.
99

fiMartiny & Moller

Definition 4.7 (Principle least effort (ple) expansion). Let set threads let
T2 (B) set type 2 belief formulae. principle least effort expansion creates
expanded set 0 = {T h0 } according single application one following rules.
`,u
(possibly negated) belief fact Bi,t
0 (Ft ) T2 (B): exists thread

h F h(t) (resp. F 6 h(t)) yet enforced, h0 created
duplication h additional constraint F h(t) (resp. F
6 h(t)).

`,u fr
belief temporal rule Bi,t
0 (rt (F, G)) T2 (B): exists thread

h F h(t) G h(t + t) (resp. G
6 h(t + t))
0
yet enforced, h created duplication h additional constraint
G h(t + t) (resp. G 6 h(t + t)).

`,u
`,u
disjunctive belief formula B = (Bi,t
0 (1 ) Bi,t0 (2 ) ) T2 (B): possible,
`,u
expansion carried respect one belief Bi,t
0 () described two
previous steps.

Nested beliefs treated respect innermost belief object.
new thread h0 created h addition F h0
fact F time point F 6 h enforced original thread h,
consequences adding F 6 h undone new thread h0 .

Then, created thread h0 , additional belief formulae T1 (B)
triggered modification need evaluated obtain sound thread,
described creation initial threads h1 , h2 .

intuition behind ple-expansion create additional threads satisfy
alternative set belief objects contained set T2 (B) little effort possible.
general, possible add constraints arbitrary facts arbitrary time points
continue successive expansion based thread. However, would result
rather aimless exploration exponential search space. Following ple-expansion
instead helps direct search suitable model guided rules specified
T2 (B). illustrate this, consider Figure 4 previous example: Possible pleexpansions could example result additional thread altering punctuality
train T2 . Clearly, resulting situations intended model, already
considered original thread specification (cf. Figure 1, p. 50). hand,
deviating ple-expansion, one could add additional factssay at(T1 , CA ), on(A, T1 )
arbitrary time points > 1. could give rise multiple subsequent expansions
resulting thread may actually serve generate model B,
situation intended specification B. example train punctuality
illustrates requirement undo operation: fact punct(T2 ) h1 (4) produced
additional constraint {at(T2 , CB ), on(A, T2 )} time = 6. Clearly, constraint
enforced longer ifbased h1 new thread h0 created
punct(T2 ) 6 h0 (4).
information violated constrains linear program corresponding
sat(T2 (B), {T h1 , h2 }), perform dependency-directed selection choice points:
100

fiPDT Logic

`,u
lower bound belief Bi,t
0 (k ) cannot satisfied current set threads,
0
additional thread h created existing constraints h1 h2
substituting respective constraint k , shown (58).
dependency choice points violated lower bounds best illustrated
results previous example: Clearly, upper bounds induced B20 B200
lower bound induced B6 hinder satisfiability T2 (B) respect created
threads. Using belief object formula B20 (or B200 ) create additional thread h3
yields updated constraint

B20 :

0.81 I(T h1 ) + x I(T h3 ) 0.81

factor x depending frequency respective belief object h3 ,
constraint induced B6 remains unchanged. result, new constraint allows
lower values I(T h1 ), thus lower bound induced B6 remains unsatisfiable.
Using belief object formula B6 create additional thread instead yields
constraint
B6 :

0.93 I(T h1 ) + x I(T h3 ) 0.93,

whichthrough nonzero values x I(T h3 )potentially allows lower values
I(T h1 ). Note example uses atomic belief formulae. disjunctive belief
`,u
`,u
formulae B = (Bi,t
0 (1 )Bi,t0 (2 ) ), respective belief objects violated
lower bound used direct selection subsequent choice points (given
disjunct B satisfiable, course).
Combining information violated lower bounds principle least effort
provides multi-stage heuristic proceed dependency-directed selection choice
points:
Definition 4.8 (Dependency-directed search heuristic). Let T2 (B) set type 2 belief
formulae let set threads sat(T2 (B), ) holds. Then, enable
dependency-directed search expanded set 0 sat(T2 (B), 0 ) holds,
expanded additional thread h0 6 according following rules.
1. existing set threads fails satisfy lower bounds constraints induced
belief formula B belief object additional thread h0 obtained
one ple-expansion respect , expanded 0 = {T h0 }.
2. Otherwise, dependency-directed ple-expansion possible, another ple-expansion
applied , possible.
3. Finally, ple-expansion possible , additional thread h0 created
adding constraint F h(t) (resp. F 6 h(t)) arbitrary facts F
yet constrained h(t).
intuition behind heuristic information violated probabilistic constraints used select suitable next expansion step, possible. Otherwise,
possible ple-expansion steps performed use rules T2 (B) guide
101

fiMartiny & Moller

search. ple-expansions possible, additional constraints employed continue search. Restricting possible expansions respect criterion 1
one step follows principle least effort, again: illustrate this, consider Example 4.8:
shown created set threads {T h1 , h2 } fails satisfy lower bound
belief formula B6 . thread h1 , world h1 (t) |= Obs{A} (punct(train))
precondition rule B6 satisfied. Consequently, single step
ple-expansion h1 could change constraints induced B6 . hand,
h2 provides two choice points therefore preferred expansion. Note
soundness requirement determine choices unconstrained facts. Thus,
general proposed expansion may produce threads already contained
constraining facts determined before. consider scenario
explicitly instead assume cases, expansion steps performed
additional thread created.
4.5.2 Thread Generation Example
illustrate expansion set threads respect dependency-directed
search heuristic Definition 4.8, following resume train example.
Example 4.9 (Trains continued). previous example, set threads = {T h1 , h2 }
created fails show satisfiability T2 (B). Consequently, heuristic
Definition 4.8 used iteratively expand set expanded set threads
0 created model B obtained expansions 0 possible.
Belief formula

.93,.93 pfr
r2 (Obs{A} (punct(train)), Obs{AB} (punct(train)))
B6 = BA,0
already identified belief formula yields constrains unsatisfiable
lower bound therefore used guide subsequent expansion.
already discussed before, single-step ple-expansion h1 possible influence
constraints induced B6 . Therefore continue expansion based thread h2 .
visualization following steps given Figure 5.
two worlds h2 Obs{A} (punct(train)) satisfied, namely
Obs{A} (punct(T1 )) h2 (1) Obs{A} (punct(T2 )) h2 (6). occurrences allow ple-expansion. choose h2 (1) perform expansion. yields
new thread h3 additional constraint Obs{A,B} (punct(T1 )) h3 (3),
constraints h2 remain intact, since constraints need undone
adding Obs{A,B} h3 (3).
expanded set 0 = {T h3 } used check sat(T2 (B), 0 ). thread
h3 , rule contained B6 satisfied one two occurrences Obs{A} (punct(train))
therefore yields frequency 0.5. Consequently, transformation linear
program obtain constraints
B20 :
B200

:

B6 :

0.81

I(T h1 )

0.81

0.93

I(T h1 ) + 0.5 I(T h3 )

0.93

0.81

I(T h1 )

102

0.81

fiPDT Logic

h4

h3

00
h2 B2
B5
0
h1 B2

at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
1

Obs{A,B} (punct(T1 ))

Obs{A,B} (punct(T1 ))
B6
B300

B200
B5

B30



at(T2 , CC ), on(A, T2 )
punct(T2 )

B200
3

B40

4
1

Obs{A,B} (punct(T2 ))

at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CB ), on(A, T2 )



6

B6

at(T2 , CB ), on(A, T2 )

B400



8

9



Figure 5: Visualization ple-expansions train example. Applications formulae
T2 (B) marked blue, additional constraints T0 (B) T1 (B)
marked red. Expansion steps marked green.

Apparently, B6 allows lower values I(T h1 ) set 0 . constraints
induced B20 (resp. B200 ) still obtain I(T h1 ) = 0.81. Then, constraint induced
B6 requires I(T h3 ) = 0.24 (since 0.81 + 0.5 0.24 = 0.93). still suitable
probability assignment since sum priors exceeds one. Consequently, thread
set expansion continues. constraints show thataccording condition 1
search heuristicthread h3 suitable candidate expansion respect
belief object B6 .
Thus, based h3 , create additional thread h4 ple-expansion.
case, possible expansion step Obs{A,B} h4 (8), results frequency
one rule contained B6 . Thus, testing sat(Tk (B), 0 ) expanded
set 0 yields following constraints:
B20 :
B200

:

B6 :

0.81

I(T h1 )

0.81

0.93

I(T h1 ) + 0.5 I(T h3 ) + 1 I(T h4 )

0.93

0.81

I(T h1 )

0.81

constraints satisfiable, instance

I(T 0 ) = 0.81, 0.07, 0, 0.12 .
Thus, sat(T2 (B), 0 ) returns positive result satisfiability checking B terminate
result.
result concludes satisfiability testing set belief formulae B originally
specified Example 4.1 (p. 72). Nevertheless, illustration purposes show result
applications ple-expansion steps Figure 6. Changes additionally
created threads obtained respectively different application belief
formula T2 (B), marked blue respective threads. Worlds h(t) remain
unconstrained saturated application ple-expansions marked /.
worlds give rise expansions according step 3 search heuristic.
103

fi104

0
h1 B2

00
h2 B2
B5

h3

h4

h5

h6

h7

h8

h9

1

at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )

at(T1 , CA ), on(A, T1 )
punct(T1 )

at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )
Obs{A} (punct(T1 ))
at(T1 , CA ), on(A, T1 )
punct(T1 )

B30

2

/

/

/

/

/

/

B200
B5

B6

3

/

/

B300

B200

Obs{A,B} (punct(T1 ))

Obs{A,B} (punct(T2 ))

/

/

/

/

Obs{A,B} (punct(T2 ))
B6

/

4

B200

00
/ B2
B5

/

1

5

at(T2 , CC ), on(A, T2 )
B40
punct(T2 )
/

/

/

/

/

at(T2 , CC ), on(A, T2 )
punct(T2 )
/
Obs{A} (punct(T2 ))
at(T2 , CC ), on(A, T2 )
punct(T2 )
/
Obs{A} (punct(T2 ))

/

/

/

6

at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CC ), on(A, T2 )
punct(T2 )
Obs{A} (punct(T2 ))
at(T2 , CB ), on(A, T2 )

B400

B6

Obs{A,B} (punct(T2 ))

at(T2 , CC ), on(A, T2 )
punct(T2 )

at(T2 , CC ), on(A, T2 )
punct(T2 )

/

7

/

/

/

/

/

B400

8

/

/

/

Obs{A,B} (punct(T2 ))
B6

9

/


at(T2 , CB ), on(A, T2 )

at(T2 , CB ), on(A, T2 )

at(T2 , CB ), on(A, T2 )

at(T2 , CB ), on(A, T2 )

Obs{A,B} (punct(T2 ))
B6

/

/

/

/

/

at(T2 , CB ), on(A, T2 )

/

at(T2 , CB ), on(A, T2 )

at(T2 , CB ), on(A, T2 )

at(T2 , CB ), on(A, T2 )

B40

/

Martiny & Moller

Figure 6: Visualization continued ple-expansions train example. Applications
formulae T2 (B) marked blue, additional constraints T0 (B)
T1 (B) marked red. Expansion steps originating h1 h2
marked green orange, respectively. Unconstrained worlds marked
/.

fiPDT Logic

comments resulting set threads example necessary. Comparing final threads depicted Figure 6 original set threads introduced
Figure 1 shows expansion result largely corresponds original specification
(except differing thread labels). notable differences however.
First all, additional predicate punct(train), introduced
Example 4.1 (p. 72) allow concise specification background knowledge.
concept nonpunctual trains (and especially respective ramifications)
implicitly encoded Figure 1 well, change properties
modeled example.
explicit representation train punctuality, observations nonpunctual
trains expressed explicitly example, previous example uses
ramifications nonpunctual trains model observations. Since rules B3
B4 assert ramifications punctual respectively nonpunctual trains common
knowledge among Alice Bob, modeling alternatives preserve intended
meaning example.
Another difference timing Alices observations. original example
assumed observation occurs time point train supposed
arrive destination city. current example assume Alice already
observes train punctual leaving departure city. reason
change solely illustration purposes: specifying rule B5 Alice
immediately observes nonpunctual train yields type 0 belief thus serves
illustrate additional facts obtained global constraints. Since rule
B6 ensures potential calls Bob (i.e., shared observations) occur two time points
Alices original observation, intended model original example still
maintained.
points concerned specific details modeled domain.
Comparing set threads Figure 1 threads Figure 6 shows
general modeling problem: instance, analyzing worlds time point 2
Figure 6 shows Alice (necessarily) train T1 , train
previous time point later time points. Naturally, one expect
Alice train intermediate time points boarding exiting
train. instance frame problem (e.g., Reiter, 2001) occurs
specifying dynamic systems logic formulae. Generally, frame problem
concerned finding suitable set axioms describe adequate evolutions
world. modeling perspective, evolutions Alice vanishes reappears
train ride obviously adequate evolutions world. application
final step search heuristic could yield tremendous blow-up
considered set threads. modeled problem, would clearly result
unintended models, resulting models could still serve show satisfiability
respective set belief formulae B, even though result might desired.
problem could fixed adding successor state axioms style Reiter,
e.g., specifying Alice train, remains next time point
unless explicitly exits train.
105

fiMartiny & Moller

4.5.3 Properties Representative Thread Generation
section, provide results connect set representative threads satisfiability problem PDT Logic discuss complexity generating representative
threads.
Theorem 4.15 (PDT Logic Decision Procedure). Let B set PDT Logic belief
formulae, let = {T h1 , h2 } initial set threads length tmax obtained
B according Equations (56) (57). Iteratively expanding set according
search heuristic Definition 4.8 testing sat(T2 (B), 0 ) expanded sets 0
(i) sat(T2 (B), 0 ) returns positive result, (ii) 0 fully expanded respect
search heuristic yields sound complete decision procedure sat(B, tmax ).
Proof. initial set threads = {T h1 , h2 } expanded sets 0 obtained ple-expansion steps defined sound threads according
Definition 4.4 considered. Theorem 4.13 (p. 92) states decision problem
sat(T2 (B), ) equivalent sat(B, ) set contains threads sound
respect B. positive result sat(B, ) threads length tmax shows
model B thus sat(B, tmax ) follows. Consequently, positive result
sat(T2 (B), 0 ) always proofs B satisfiable tmax time points.
hand, model B found possible create
additional threads according search heuristic Definition 4.8 (p. 101), search
space fully explored. follows model B tmax time points
exists therefore B unsatisfiable tmax time points. Consequently, follows
PDT Logic decision procedure sound.
properties, completeness result straightforward: arbitrary
input B tmax , either model found non-existence model
proven full exploration search space, thus completeness procedure
follows.
following, analyze complexity generating representative threads
set belief formulae B.
Theorem 4.16 (Complexity representative thread generation). Let B set belief
formulae. Creating set expanded representative threads 0 B EXPSPACE.
Proof. maximum number possible threads given set belief formulae B
determined size |FB | maximum time point tmax . Recall Equation (29) (p. 71) use FB identify event formulae B use set
ground atoms construct possible worlds. Since every PDT Logic formula contains
two event formulae, obtain constraint |FB | 2 |B|. largest set possible
threads obtained sequences combinations possible worlds
time points, yielding 22tmax |B| possible threads. worst case, |FB | 2 |B| representative threads created obtaining satisfiability result. Consequently, creating
possible representative threads complexity class DSPACE(2p(n) ),
class EXPSPACE.
theorem, immediately obtain complexity results satisfiability problem sat(B, tmax ).
106

fiPDT Logic

Corollary 4.17 (Complexity PDT SAT without given set threads). Checking satisfiability set PDT Logic belief formulae B without specification possible threads
EXPSPACE.
Proof. generation representative threads EXPSPACE, shown Theorem 4.16. given set threads Theorem 4.11 shows satisfiability checking
PDT Logic NP. Thus, increase complexity PDT sat problem without given set threads follows problem EXPSPACE.
comments results necessary. Since decision procedure outlined
Theorem 4.15 yields exponential expansion possible threads 0 need
fed decision problem sat(T2 (B), 0 )the exponential space requirement
evident. However, illustrated example, positive satisfiability results
possibly already obtained small sets possible threads 0 diminutive
size compared entire search space. Moreover, discussion train example
shown major part search space stems insufficient rule specifications.
specific problem formalism presented decision procedure, general
problem rule-based modeling approaches, namely aforementioned frame problem.
incomplete model specification leads generation unintended models,
serve show satisfiability modeled problem, intended
respective modeler. could lead worst caseboth complexity
model perspectivethat exponential execution decision procedure,
result shows input specification specify intended model.
problem addressed modeling side providing additional axioms ensure
unintended model generated. However, leads significant increase
specification size difficult ensure rule specifications indeed every
unintended model prevented.
ple-expansion steps could used heuristic discriminate intended
unintended models: shown train example, applying ple-expansion steps
results relatively small set threads, indeed corresponds intention
model, expansions inherently leads exponential growth
set threads introduces additional unintended models. Thus, omitting final
step search heuristic would give significantly faster termination decision
procedure, even though resulting procedure cannot prove unsatisfiable sets formulae
longer. However, one could use expansion procedure create set intended
threads first andpossibly inspection modelercontinue use set
perform satisfiability checks respect intended model.
runtime expansion procedure resulting satisfiability checks clearly
tilted towards positive side: set belief formulae satisfiable, good
chance satisfiability shown small number steps. Negative results
hand obtained exhaustive exploration search space.
However, many applications negative satisfiability results required. instance,
checking entailment B |= B checked reformulation sat(B B).
applications relying reformulation, presented procedure unfavorable
positive entailment results never obtained efficiently. One could overcome
problem sketched generating set intended threads first use
107

fiMartiny & Moller

set perform subsequent satisfiability testsonce set threads given, decision
problems complexity significantly decreases, shown Section 4.3.

5. Conclusion
work, extending APT Logic dynamic scenarios multiple agents,
developed general framework represent reason belief change multiagent systems. Next lifting single-agent case APT Logic multiple agents,
provided suitable semantics temporal evolution beliefs. resulting
framework extends previous work dynamic multi-agent epistemic logics enabling
quantification agents beliefs probability intervals. explicit notion temporal relationships provided temporal rules building concept frequency
functions.
quantification beliefs probability intervals instead precise values
advantage domain experts model problem, provide
background knowledge problem domain, specify certainty
respective specifications. Narrow interval quantifications reflect high certainty
vice versa. significant advantage compared probabilistic approaches,
approaches, sharp probability values required human
usually express precise values thus rely guesses. Specifying precise
values, actually precisely known yield misleading results. PDT Logic
exposed problem, required guess sharp values specify
problem.
shown two alternative ways specifying problems PDT Logic,
either explicit enumerations possible threads set appropriate
rules. approaches exhibit specific advantages drawbacks: many problem
domains, requiring exhaustive enumeration possible threads poses severe obstacle
modeling respective scenarios, combinatorial blow-up renders specification
practically unmanageable. hand, problem domains (e.g., attack
graphs cyber security scenarios) come explicit specification anyways.
types problems, shown possible check satisfiability
models efficiently.
overcome modeling disadvantages thread-based approach, shown
problem domain solely specified set PDT Logic belief formulae.
problem domains, natural way specifying problem. Also,
provides means easily adapt many existing problemsthat specified formal
languages sets rulesto PDT Logic. hand, waiving requirement
exhaustive thread specification according probabilities extremely increases
problem complexity checking satisfiability set PDT Logic formulae. Nevertheless,
even imprecise probabilities given, resulting problem remains decidable
increased complexity might curtailed search heuristics.
Combinations approaches possible well: exhaustive specification
possible threads given, probability intervals specified beliefs
imprecise probabilities, satisfiability problem transformed 0-1 mixed
integer linear program. variety efficient solvers available class
108

fiPDT Logic

problems, transformation provides means exploit existing optimizations check
satisfiability PDT Logic formulae.

References
Aumann, R. J. (1976). Agreeing Disagree. Annals Statistics, 4 (6), 12361239.
Baaz, M., Egly, U., Leitsch, A., Goubault-Larrecq, J., & Plaisted, D. (2001). Normal Form
Transformations. Robinson, A., & Voronkov, A. (Eds.), Handbook Automated
Reasoning, chap. 5, pp. 273 333. MIT Press.
Balas, E. (1985). Disjunctive Programming Hierarchy Relaxations Discrete
Optimization Problems. SIAM Journal Algebraic Discrete Methods, 6 (3), 466
486.
Balas, E. (1998). Disjunctive Programming: Properties Convex Hull Feasible
Points. Discrete Applied Mathematics, 89 (1), 344.
Balas, E., Ceria, S., & Cornuejols, G. (1993). Lift-and-project Cutting Plane Algorithm
Mixed 0-1 Programs. Mathematical Programming, 58 (3), 295324.
Balas, E., Ceria, S., & Cornuejols, G. (1996). Mixed 0-1 Programming Lift-and-project
Branch-and-cut Framework. Management Science, 42 (9), 12291246.
Balas, E., & Perregaard, M. (2002). Lift-and-project Mixed 0-1 Programming: Recent
Progress. Discrete Applied Mathematics, 123 (1), 129154.
Baltag, A., & Moss, L. S. (2004). Logics Epistemic Programs. Synthese, 139 (2), 165224.
Baltag, A., Moss, L. S., & Solecki, S. (1998). Logic Public Announcements, Common
Knowledge, Private Suspicions. Proceedings Seventh Conference
Theoretical Aspects Rationality Knowledge, TARK 98, pp. 4356.
Bertacco, L., Fischetti, M., & Lodi, A. (2007). Feasibility Pump Heuristic general
Mixed-Integer Problems. Discrete Optimization, 4 (1), 6376.
Bienstock, D. (1996). Computational Study Family Mixed-Integer Quadratic Programming Problems. Mathematical Programming, 74 (2), 121140.
Bradley, S. (2015). Imprecise probabilities. Zalta, E. N. (Ed.), Stanford Encyclopedia
Philosophy (Summer 2015 edition).
Computational Infrastructure Operations Research (COIN-OR) Project, T. (2016).
CBC (Coin-or branch cut) user guide. http://www.coin-or.org/Cbc/index.html.
accessed: 2016-04-15.
Cook, S. A. (1971). Complexity Theorem-proving Procedures. Proceedings
Third Annual ACM Symposium Theory Computing, STOC 71.
Cripps, M. W., Ely, J. C., Mailath, G. J., & Samuelson, L. (2008). Common Learning.
Econometrica, 76 (4), 909933.
Dal Palu, A., Dovier, A., Pontelli, E., & Rossi, G. (2009). Gasp: Answer set programming
lazy grounding. Fundamenta Informaticae - Advances Computational Logic,
96 (3), 297322.
109

fiMartiny & Moller

de Carvalho Ferreira, N., Fisher, M., & van der Hoek, W. (2008). Specifying Reasoning
Uncertain Agents. International Journal Approximate Reasoning, 49 (1),
3551.
Doder, D., Markovic, Z., Ognjanovic, Z., Perovic, A., & Raskovic, M. (2010). Probabilistic Temporal Logic Model Reasoning Evidence. Foundations
Information Knowledge Systems: 6th International Symposium, FoIKS 2010.
Ellsberg, D. (1961). Risk, Ambiguity, Savage Axioms. Quarterly Journal
Economics, 75 (4), 643669.
Faber, W., Leone, N., & Perri, S. (2012). intelligent grounder DLV. Correct
Reasoning: Essays Logic-Based AI Honour Vladimir Lifschitz. Springer.
Fagin, R., & Halpern, J. Y. (1994). Reasoning Knowledge Probability. Journal
ACM, 41 (2), 340367.
Fagin, R., Halpern, J. Y., & Megiddo, N. (1990). Logic Reasoning Probabilities.
Information Computation, 87 (1), 78128.
Fagin, R., Halpern, J. Y., Moses, Y., & Vardi, M. Y. (1995). Reasoning Knowledge.
MIT Press.
Fischetti, M., Glover, F., & Lodi, A. (2005). Feasibility Pump. Mathematical Programming, 104 (1), 91104.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability; Guide Theory
NP-Completeness. W. H. Freeman & Co.
Gerbrandy, J., & Groeneveld, W. (1997). Reasoning Information Change. Journal
Logic, Language Information, 6 (2), 147169.
Gnu

Project, T. (2016).
GLPK: GNU Linear Programming
http://www.gnu.org/software/glpk/glpk.html. accessed: 2016-04-15.

Kit.

Grunwald, P. D., & Halpern, J. Y. (2003). Updating Probabilities. Journal Artificial
Intelligence Research, 19 (1), 243278.
Gurobi Optimization, Inc. (2016).
Gurobi optimizer reference
http://www.gurobi.com/documentation/. accessed: 2016-04-15.

manual.

Halpern, J. Y., & Pucella, R. (2006). Logic Reasoning Evidence. Journal
Artificial Intelligence Research, 26 (1), 134.
Halpern, J. Y., Samet, D., & Segev, E. (2009). Defining Knowledge Terms Belief:
Modal Logic Perspective. Review Symbolic Logic, 2 (3), 469487.
Harsanyi, J. C. (1967). Games Incomplete Information Played Bayesian Players.
Part I. Basic Model. Management Science, 14 (3), 159182.
Harsanyi, J. C. (1968a). Games Incomplete Information Played Bayesian Players.
Part II. Bayesian Equilibrium Points. Management Science, 14 (5), 320324.
Harsanyi, J. C. (1968b). Games Incomplete Information Played Bayesian Players.
Part III. Basic Probability Distribution Game. Management Science, 14 (7),
486502.
110

fiPDT Logic

Hintikka, J. (1962). Knowledge Belief: Introduction Logic Two Notions.
Cornell University Press.
ILOG,
I.
(2016).
CPLEX
Optimizer.
01.ibm.com/software/commerce/optimization/cplex-optimizer/.
04-15.

http://wwwaccessed: 2016-

Kooi, B. P. (2003). Probabilistic Dynamic Epistemic Logic. Journal Logic, Language
Information, 12 (4), 381408.
Kripke, S. A. (1963). Semantical Considerations Modal Logic. Acta Philosophica Fennica,
16, 8394.
Lloyd, J. W. (1987). Foundations Logic Programming, 2nd Edition. Springer.
Martiny, K., Motzek, A., & Moller, R. (2015). Formalizing Agents Beliefs Cyber-Security
Defense Strategy Planning. CISIS 2015 - Proceedings 8th International Conference Computational Intelligence Security Information Systems, Burgos,
Spain, 15-17 June, 2015.
Milch, B., & Koller, D. (2000). Probabilistic Models Agents Beliefs Decisions.
Proceedings Sixteenth Annual Conference Uncertainty Artificial Intelligence, UAI 00. Morgan Kaufmann Publishers Inc.
Murty, K. G. (1983). Linear Programming. John Wiley & Sons.
Parikh, R., & Ramanujam, R. (2003). Knowledge Based Semantics Messages. Journal
Logic, Language Information, 12 (4), 453467.
Plaza, J. (1989). Logics public communications. Proceedings Fourth International
Symposium Methodologies Intelligent Systems: Poster session program, ISMIS
89. Oak Ridge National Laboratory.
Plaza, J. (2007). Logics Public Communications. Synthese, 158 (2), 165179.
Reiter, R. (2001). Knowledge Action: Logical Foundations Specifying Implementing Dynamical Systems. MIT Press.
Sack, J. (2008). Temporal Languages Epistemic Programs. Journal Logic, Language
Information, 17 (2), 183216.
Sack, J. (2009). Extending Probabilistic Dynamic Epistemic Logic. Synthese, 169 (2), 241
257.
Schrijver, A. (1986). Theory Linear Integer Programming. John Wiley & Sons.
Shakarian, P., Parker, A., Simari, G., & Subrahmanian, V. S. (2011). Annotated Probabilistic Temporal Logic. ACM Transactions Computational Logic, 12 (2), 14:114:44.
Shakarian, P., Simari, G. I., & Subrahmanian, V. S. (2012). Annotated Probabilistic Temporal Logic: Approximate Fixpoint Implementation. ACM Transactions Computational Logic, 13 (2), 13:113:33.
Shoham, Y., & Leyton-Brown, K. (2009). Multiagent Systems: Algorithmic, GameTheoretic, Logical Foundations. Cambridge University Press.
van Benthem, J. (2003). Conditional Probability Meets Update Logic. Journal Logic,
Language Information, 12 (4), 409421.
111

fiMartiny & Moller

van Benthem, J., Gerbrandy, J., Hoshi, T., & Pacuit, E. (2009a). Merging Frameworks
Interaction. Journal Philosophical Logic, 38 (5), 491526.
van Benthem, J., Gerbrandy, J., & Kooi, B. (2009b). Dynamic Update Probabilities.
Studia Logica, 93 (1), 6796.
van der Hoek, W. (1997). Considerations Logic PFD: Logic combining
Modality Probability. Journal Applied Non-Classical Logics, 7 (3), 287307.
van Ditmarsch, H., van der Hoek, W., & Kooi, B. (2007). Dynamic Epistemic Logic.
Springer.
van Eijck, J. (2014). Dynamic epistemic logics. Johan van Benthem Logical
Informational Dynamics, chap. 7, pp. 175202. Springer.
van Eijck, J., & Schwarzentruber, F. (2014). Epistemic Probability Logic Simplified.
Gore, R., Kooi, B. P., & Kurucz, A. (Eds.), Advances Modal Logic 10, invited
contributed papers tenth conference Advances Modal Logic,, AiML
14. College Publications.
vos Savant, M. (1990). Ask Marilyn. Parade Magazine, 16.
Williams, H. P. (2009). Logic Integer Programming. Springer.

112


