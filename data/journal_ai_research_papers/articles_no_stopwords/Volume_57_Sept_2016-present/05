journal artificial intelligence

submitted published

goal probability analysis mdp probabilistic
exploring enhancing state art
marcel steinmetz
jorg hoffmann

steinmetz cs uni saarland de
hoffmann cs uni saarland de

saarland university
saarland informatics campus
saarbrucken germany

olivier buffet

olivier buffet loria fr

inria universite de lorraine cnrs
nancy france

abstract
unavoidable dead ends common many probabilistic e g actions may fail operating resource constraints important objective settings
maxprob determining maximal probability goal reached policy
achieving probability yet maxprob probabilistic severely underexplored extent scant evidence empirical state art actually
close gap comprehensive empirical analysis design explore large space
heuristic search systematizing known contributing several variants consider maxprob well weaker objectives baptize atleastprob
requiring achieve given goal probabilty threshold approxprob requiring compute
maximum goal probability given accuracy explore general case
may reward cycles practically relevant special case acyclic
limited action cost budget design suitable termination criteria search variants dead end pruning methods classical heuristics node selection
strategies design benchmark suite comprising instances adapted
ippc resource constrained simulated penetration testing evaluation clarifies
state art characterizes behavior wide range heuristic search
demonstrates significant benefits variants

introduction
many probabilistic contain unavoidable dead ends e g kolobov mausam
weld geffner teichteil konigsbuch vidal infantes kolobov mausam weld
teichteil konigsbuch e policy guarantees eventually circumstances
attain goal examples resource constraints limited budget situations
actions may fail eventually run options one important objective
maxprob determining maximal probability goal reached identifying
policy achieving probability maxprob partly underlies international probabilistic competition ippc younes littman weissman asmuth bryce buffet
coles coles garca olaya jimenez linares lopez sanner yoon planners evaluated often reach goal online policy execution time limit
ippc setting mixes maxprob bias towards policies reaching goal quickly
c

ai access foundation rights reserved

fis teinmetz h offmann b uffet

relates proposals kolobov et al teichteil konigsbuch asking
cheapest policy among maximizing goal probability proposal chatterjee
chmelik gupta kanodia asking cheapest policy ensuring target state
reached almost surely partially observable setting
consider mdp probabilistic factored probabilistic extensions
strips whose state spaces may large build explicitly focus optimal offline
setting e solving maxprob exactly setup objective certainly relevant
little work towards developing solvers main effort made kolobov et al
discuss detail hou yeoh varakantham consider several variants
topological vi dai mausam weld goldsmith solving maxprob necessitating
build entire reachable state space works addressing goal probability maximization
aim guaranteeing optimality e g teichteil konigsbuch kuter infantes camacho
muise mcilraith
mdp heuristic search barto bradtke singh hansen zilberstein bonet
geffner b mcmahan likhachev gordon smith simmons bonet
geffner potential optimal policies without building entire state space
kolobov et al authors addressing optimal maxprob heuristic search
part reason lack heuristic search maxprob following two major obstacles first mdp heuristic search successful expected cost minimization
suffers lack admissible upper bounding heuristic estimators goal probability
best known possibility detect dead ends set initial heuristic estimate
trivial upper bound elsewhere second maxprob fit stochastic shortest path ssp
framework bertsekas due reward cycles pointed kolobov et al
maxprob equivalent non discounted reward maximization non goal cycles
receive reward thus improper policies accumulate reward
address second kolobov et al devised fret revise eliminate traps framework admits heuristic search yet requires several iterations complete
searches heuristic search iterations fret eliminates reward cycles traps fret iterates cycles persist kolobov et al contribution mainly theoretical considering maxprob much larger class generalized ssps empirical evaluation
serves merely proof concept experiment single domain explodingblocks
run one configuration search lrtdp bonet geffner b one possibility
dead end detection thus non trivial initial heuristic estimates sixthsense kolobov mausam
weld outperform value iteration vi dead end detection used
vi remains unclear extent improvement due actual heuristic search
rather state pruning
summary heuristic search maxprob challenging addressed
kolobov et al limited experiments given
actually empirical state art heuristic search maxprob
known variants thereof work better
explore large design space indeed variants work
much better
ii simpler yet still relevant special cases weaker objectives may easier
solve


fig oal p robability nalysis p robabilistic p lanning

indeed practically relevant cases necessitate fret weaker objectives
enable refer early termination
elaborate first ii state space task hand acyclic clearly fret
needed cycles particular reward cycles state space
finite execution end goal non goal absorbing state implies
within realm ssps special case however still practically relevant illustration
acyclic state spaces occur even standard ippc benchmarks namely triangletireworld
domain moves made one direction importantly limited
action cost budget limited budget acyclic state spaces action costs non
strictly decreasing remaining budget similar class scenarios every action consumes non amount non replenishable resource another example recently proposed
simulated penetration testing per hoffmann mdp network
intrusion point view attacker state space acyclic exploit
attempted trying exploit network configuration would
yield outcome states thus need remember remaining action set every action
application strictly reduces set
regarding weaker objectives alternatives maxprob reasonable ask whether
maximum goal probability exceeds given threshold require computing maximum goal
probability given accuracy refer objectives atleastprob approxprob
respectively example penetration testing atleastprob naturally assesses level network security attacker reach target host probability greater given security
margin e g customer data server compromised probability greater
atleastprob approxprob allow early termination maintaining lower pessimistic bound v l upper admissible optimistic bound v u especially promising
atleastprob terminate lower bound already good enough v l
upper bound already proves infeasibility v u good anytime behavior
bounds translates early termination
let us elaborate exploring state art beyond design
space characterized
search design variants ao nilsson lrtdp bonet geffner
b depth first oriented heuristic searches bonet geffner maintaining
upper lower bounds early termination
b fret design variant fret better suited uninformative initial
upper bounds
c bisimulation reduction design probabilistic state space reduction method via bisimulation relative outcomes determinization e g bonet geffner b yoon fern
givan little thiebaux
atleastprob relates mdp model checking one typically wants validate given pctl probabilistic
computation tree logic formula valid probability baier groer leucker bollig ciesinski
kwiatkowska parker qu kwiatkowska norman parker b relates constrained mdps
altman enforcing minimum success probability could expressed constraint particular
quantity chance constrained pomdps santana thibaux williams different atleastprob
constraint probability remain safe states reach goal states



fis teinmetz h offmann b uffet

dead end pruning method employ classical heuristic functions dead end detection probabilistic via outcomes determinization previously done
teichteil konigsbuch et al especially promising limited budget
prune state admissible classical estimate exceeds remaining
budget
e node selection strategy design comprehensive arsenal simple strategies biasing tie
breaking action state selection manners targeted fostering early termination
implemented techniques within fast downward fd helmert thus contributing side effect work ideal implementation basis exploiting classical
heuristic search techniques mdp heuristic search
dimensions e orthogonal excepting dependencies particular
bisimulation reduction subsumes dead end pruning explore behavior resulting
design space large benchmark suite design purpose suite includes domains
ippc resource constrained penetration testing limitedbudget version unlimited budget version suite comprises benchmark instances
total amongst things observe
heuristic search yields substantial benefits even trivial admissible heuristic setting
initial estimate everywhere total coverage across benchmarks
admissible heuristics dead end detection
early termination yields substantial benefits e g atleastprob

fret variant yields dramatic benefits total coverage cyclic benchmarks
bisimulation reduction yields optimal maxprob solver excells triangletireworld
even surpassing prob prp muise mcilraith beck camacho et al
standard version goal achieved certainty hence
prob prp optimal limited budget version
side discover landmarks compilation per domshlak mirkis employed
dead end pruning oversubscription setting actually equivalent
pruning remaining budget standard admissible landmark heuristic
relevant work otherwise compilation would canonical candidate
dead end pruning setting indeed started investigation
organized follows section describes model syntax semantics goal
probability analysis without action cost budget limit section specifies search
fret variants b section describes bisimulation reduction method c
section describes dead end pruning methods section describes node selection
strategies e present experiments section conclude section
two appendices giving additional technical details sketch main text appendix b
source code available http fai cs uni saarland de downloads fd prob tar bz

benchmark
suite

available

http fai cs uni saarland de downloads
ppddl benchmarks acyclic tar bz acyclic cases http fai cs uni saarland
de downloads ppddl benchmarks cyclic tar bz cyclic cases



fig oal p robability nalysis p robabilistic p lanning

regarding domshlak mirkis landmarks compilation appendix regarding depthfirst oriented heuristic searches

mdp
consider ppddl style younes et al precisely probabilistic extensions
strips employ two formalism variants without limited action cost budget
specify first unlimited budget version tasks tuples f g consisting
finite set f facts finite set actions initial state f goal g f
pair pre pre f precondition finite set
outcomes tuple p add del
p outcome probability p add list
add f delete list del f require oo p
given task state space probabilistic transition system p
set states associated set f true facts initial state
set goal states contains g f transitions transition
probability function p defined follows action applicable state
pre f goal states absorbing see denote
set actions applicable given outcome sjok denote
outcome e f sjok f add del define p p
applicable sjok otherwise define p transition
absorbing states outgoing transitions applicable actions set non goal
absorbing states lost states denoted
limited budget extend follows limited budget task tuple
f g b including budget b r
associating


addition


true
facts
f

states
action outcome cost c r

associated remaining budget b r states negative remaining budget b
legal may occur lost due following definitions goal states
action applicability transitions goal states g f
b e must reach goal remaining budget actions applicable
pre f least one outcome fits within remaining budget e
exists c b outcome states sjok outcomes cost deduced
remaining budget e b sjok b c
notes order regarding limited budget c state
space viewed directed graph arc whenever action mapping
non probability acyclic every transition strictly reduces remaining budget
state space infinite due continuous state variable b reachable part
consider finite note remaining budget local state
states policy violate budget parts policy even outcomes
action still continue trying reach goal differs constrained mdps altman
budget bound applied globally expected cost policy note
extension previous conference steinmetz hoffmann buffet cover larger
space including depth first oriented heuristic searches provide comprehensive explanations
discussions present experiments detail
assume leads different outcome state simplify notation
implementation make assumption



fis teinmetz h offmann b uffet

single budget considered sake simplicity framework
straightforwardly extend multiple budget variables
limited budget explored deterministic oversubscription setting objective maximize reward achieved soft goals subject budget domshlak
mirkis classical variant would relate resource constrained e g
haslum geffner nakhost hoffmann muller coles coles fox long
single consumed resource probabilistic variant previously considered
hou et al prior work probabilistic resources e g marecki
tambe meuleau benazera brafman hansen mausam coles often
assumed limited budgets non consumption dealt uncertain continuous resource
consumption contrast discrete fixed budget consumed action costs
though relatively restricted limited budget probabilistic quite natural decision
making often constrained finite budget furthermore non costs often reasonable
assume applies example penetration testing asking achieve goal within
given number steps e g finite horizon goal probability maximization special case
let us define solutions tasks well objectives wish
achieve policy partial function mapping non absorbing
state within domain action applicable dont care symbol
symbol used policies already achieve sufficient goal probability elsewhere
need elaborate act descendants still require closed
policies see use explicitly indicate special cases actions may chosen
arbitrarily formally extends domain picking every reachable
undefined arbitrary action applicable setting
policy closed state every state reachable
defined closed closed initial state proper every state
defined eventually reaches absorbing state probability
following kolobov et al formulate goal probability maximal non discounted
expected reward reaching goal gives reward rewards value
v policy closed state




v p



p v otherwise
optimal value state
v

max

closed

v



observe difference kolobov et al consider general maxprob dont need exclude improper maximization
negative rewards e policies cannot gain anything infinite cycles
given value function v function mapping states r bellman update operator
defined usual maximization actions relative current values given v
keep mind absorbing states setting e goal states lost states ssp
policy considered valid executions end goal state finding shortest path
implies path exists maxprob policy valid executions end absorbing goal non goal
state executions may fail need terminate



fig oal p robability nalysis p robabilistic p lanning





v
p

maxaa p v otherwise



difference v prior update updated value according right hand
side called bellman residual
greedy policy value function v selects non absorbing state action obtaining maximum right hand side equation note greedy policy unique
tie breaking refer state space subgraph induced states reachable
greedy policy greedy graph v greedy graph refer
state space subgraph induced states reachable greedy policy v e
allowing state choose action greedy v
acyclic state spaces every run ends absorbing state finite number steps
facing ssp subject definition absorbing states cf
bellman update operator unique fixed point v converges initial v
cyclic state spaces pointed kolobov et al bellman update operator may
multiple sub optimal fixed points updates optimistic upper bound initialization
v guaranteed converge optimum v one use pessimistic lowerbound initialization v updates guaranteed converge v one use
kolobov et al fret method described earlier
consider three different objectives algorithmic goal probability analysis
maxprob optimal policy e closed v v
atleastprob policy guaranteeing user defined goal probability threshold e
closed v prove exist
approxprob policy optimal user defined goal probability accuracy e
closed v v
define family addressing cover search bisimulation reduction dead end pruning node selection strategies order

search
use value iteration vi baseline design variants ao lrtdp well family
depth first oriented heuristic searches systematizing parameters underlying improved
lao ilao hansen zilberstein heuristic dynamic programming bonet
geffner learning depth first search bonet geffner furthermore design
variant fret better suited uninformative initial upper bounds
vi
pre process vi make one forward pass building reachable state space actually
pruned subgraph see section initialize value function pessimistically simply
everywhere acyclic cases perform single backward pass bellman updates starting
absorbing states updating children parents thus computing optimal value function
updating every state exactly


fis teinmetz h offmann b uffet

procedure goalprob ao
initialize consist initialize
loop
maxprob v l
atleastprob v l
approxprob v l v u v l
return l endif early termination positive
atleastprob v u
return impossible endif early termination negative
ex leaf state reachable u
select state
else return u endif regular termination
p
already contained
insert child initialize
else insert parent
endif
endfor
backwardsupdate
endloop
procedure
initialize

u
v
otherwise

l
v
otherwise
l endif

figure ao search maxprob atleastprob approxprob indicated acyclic state
spaces u current greedy policy v u l current greedy policy v l
backwardsupdate procedure updates v u u v l l states may
several parents first make backwards sweep collect sub graph ending
update v u u greedy sub graph v u suffices update
reverse topological order
general cyclic case assume convergence parameter likewise addressing case compute consistent value function bellman
residual every state efficient value iteration employ topological vi per
dai et al strongly connected components scc state space handle
scc individually children sccs parent sccs vi scc stops every state
consistent
dai et al introduce focused topological vi eliminates sub optimal actions
pre process obtain smaller sccs much runtime effective still
requires building entire state space experiments runtime memory exhaustion
process e building state space reason vi failures
consider focused topological vi
ao
ao restrict acyclic case overhead repeated value iteration
fixed points inherent lao hansen zilberstein disappears ilao variant


fig oal p robability nalysis p robabilistic p lanning

issue addressed depth first orientation covered part
depth first oriented heuristic search family introduced section
figure shows pseudo code goalprob ao variant incrementally constructs subgraph state space handling duplicates simple identifying search
nodes states state space acyclic reason simple backward updating
suffices maintain value function adopting ideas prior work e g mcmahan et al
little aberdeen thiebaux smith simmons kuter hu maintain
two value functions namely upper bound v u lower bound v l goal probability
lack heuristic estimators goal probability value functions initialized trivially
v u v l except absorbing states exact value known dead end
detection simple non trivial v u initialization discussed section nevertheless
bounds useful search early termination v l v u detecting
sub optimal parts state space v u observe latter note refute action
may suffice reduce v u one outcomes hence even trivial initialization v u
may allow disregard parts search space usual way admissible heuristic functions
shall see kind behavior occurs frequently practice reflected benchmarks
regarding early termination lower bound enables positive early termination
already guarantee sufficient goal probability namely maxprob atleastprob approxprob upper bound enables negative early termination atleastprob v u
approxprob clearly terminate v u v l relevant observation
v l maxprob v l approxprob criteria redundant
maintaining upper bound e heuristic search v l trivially
v u v l v l search branch achieving goal certainty
v u well search terminates regularly configurations maintaining v u
however criteria useful reduce search
correctness goalprob ao easy establish standard properties bellman
updates point time execution state
v l v v u e v l v u lower respectively upper bounds goal
probability indeed bounds monotone bertsekas tsitsiklis
precisely v l
p
u
l
v exact absorbing states satisfy v maxaa p v l respectively
p
v u maxaa p v u non absorbing ones v l v u
initialized functions trivially satisfying properties properties invariant
bellman updates non absorbing states given monotonicity v l grow v u
decrease thanks monotonicity arguments given lao hansen
zilberstein get v u converges v finite time u greedy graph
finally need prove case early termination returning l greedy policy l
v l actually achieves want e l closed l provides sufficient goal
l
probability e v v l l closed policy applies
dont care symbol non absorbing leaf states note applied l
l
states states v v l
claim trivial states l never updated v l
states claim follows simple inductive reasoning maximal distance
l
absorbing state l greedy graph absorbing states v v l v
p
l
l
claim trivially satisfied induction step v p l v
l
l
definition v induction hypothesis v v l states


fis teinmetz h offmann b uffet

procedure goalprob lrtdp
initialize
loop
early termination criteria exactly goalprob ao
labeled solved
lrtdp trial
else return u endif regular termination
endloop
procedure lrtdp trial
p empty stack
labeled solved
push onto p
break endif
cyclic consistent break endif
p
initialize endif
endfor
update v u u v l l
sample according p u
endwhile
p empty
pop p
acyclic checksolved break endif
cyclic checksolved break endif
endwhile

figure lrtdp maxprob atleastprob approxprob acyclic general cyclic state
spaces u current greedy policy v u l current greedy policy v l
checksolved procedure exactly specified bonet geffner b
visits states reachable u initializing previously visited stopping
consistent performs updates bottom labeling solved iff
descendants consistent change update v l l along v u
u
p
l
p l words v p l v l plugging
definition l monotonicity property easy conclude
l
v v l desired
lrtdp
figure shows pseudo code goalprob lrtdp variant applicable general case cyclic
well acyclic assume cyclic cases run within fret
framework main change original version lrtdp consists maintaining lower
bound addition upper optimistic bound adding early termination criteria
goalprob ao correctness early termination follows arguments e
v l v u monotone lower respectively upper bounds l closed policy
note true even general cyclic case e early termination applies
terminate overall fret process
change make additional stopping criterion trials cyclic case
namely current state consistent kolobov et al use criterion keep trials


fig oal p robability nalysis p robabilistic p lanning

procedure goalprob dfhs

loop
early termination criteria exactly goalprob ao
label labeled solved
vi u changed running vi u greedy graph
dfhs exploration
clean visited markers
else return u endif regular termination
endloop
procedure dfhs exploration
initialize endif
labeled solved
label solved
return
endif
f lag
fw
v u consistent f lag endif
update v u u v l l
consist f lag return endif
endif
mark visited
foreach p u
visited f lag dfhs exploration f lag endif
done
f lag fw
v u consistent f lag endif
update v u u v l l
endif
label f lag label solved endif
return f lag

figure depth first heuristic search dfhs acyclic maxprob atleastprob approxprob cyclic version shown appendix uses tarjans scc procedure
instead depth first search vi label fw consist boolean parameters see text recall u greedy graph set states reachable
current greedy policy u f lag returned dfhs exploration used inside
recursion ignored top level calls decide whether backward update
state forward updates use

getting trapped reward non goal cycles criterion preserves property upon
regular termination states reachable u consistent

cyclic case v u fixed point found lrtdp may sub optimal use
fret acyclic case use single call lrtdp suffices


fis teinmetz h offmann b uffet

depth first heuristic search
finally consider systematic heuristic searches trials lrtdp strong
depth first orientation intuitively orientation especially beneficial context
likely lead absorbing states thus states non trivial heuristic function initialization
quickly refer depth first heuristic search dfhs known instances
ilao hansen zilberstein heuristic dynamic programming hdp bonet geffner
learning depth first search ldfs bonet geffner commonality lies
conducting depth first searches dfs state space subgraph defined actions greedy
current upper bound v u updated backwards dfs termination criterion applies differ depth first branches terminated overall
terminated whether updates performed forward direction systematize parameters obtaining dfhs family containing previous
family members
figure gives pseudo code description dfhs family simplicity
figure considers acyclic cyclic instead dfs use
tarjans depth first scc tarjan order detect sccs time
exploration updates suggested bonet geffner knowing
sccs required correct solved labeling general case pseudo code description
dfhs family general cyclic case given appendix
search u greedy graph variant would instead search v u greedy graph variant employed ldfs effective goal probability analysis
v u everywhere initially v u greedy graph entire dead end pruned reachable
state space hence omit option therewith ldfs dfhs family matters may
change better admissible heuristic functions identified future work cf section
update values backward direction leaving state fw
parameter true value updates done forward direction entering state
consistently yields small advantages empirically switch fw true
configurations except one corresponding known ilao use
technique detecting whether optimal solution found done two ways
label maintaining solved labels dfs vi running value iteration u greedy graph dfs terminated u optimal initial state labeled solved
one terminate greedy policy change vi use forward updates
already check bellman residual anyway additional option consist
stop search inconsistent states opposed stopping absorbing states overall
run different parameter settings dfhs overviewed table
correctness early termination follows arguments
correctness regular termination need fixed point policy obtained e upon
regular termination u greedy graph contains inconsistent states holds
variants fit bonet geffners revise schema finite state
space monotone optimistic bound search iteration update
updates trials difference original lrtdp formulation related trial stopping guarantee
goal probability maximization turn consistently yield small advantages empirically keep

brief description ilao hansen zilberstein thus depth first orientation subject
interpretation design follows bonet geffner mgpt tool



fig oal p robability nalysis p robabilistic p lanning

acronym
dfhsvi
dfhsfwd
vi
dfhsfwdcons
vi
dfhsfwd
lab
dfhsfwdcons
lab

termination
vi
vi
vi
label
label

fw

yes
yes
yes
yes

cons


yes

yes

known
yes ilao hansen zilberstein
variant
variant
variant
yes hdp bonet geffner


table depth first heuristic search dfhs family overview include ldfs bonet
geffner due considering v u greedy graph rather u greedy
graph ldfs work well maxprob see text
least one inconsistent state condition met given depth first search respectively
tarjans general case clear holds true regarding obvious
vi termination option used holds label termination option state
labeled solved descendant states u greedy graph consistent
done table usually omit goalprob names keep mind
though differ original ones particular terms early termination
depends objective maxprob atleastprob approxprob study termination
benefits lower vs upper bound switch bound individually
x denotes one search denote x u x l variants x maintaining
v u respectively v l sometimes write x lu make explicit bounds
used early termination criteria involving non maintained bound disabled x u
leaves negative criterion v u atleastprob x l still positive criteria
test version x l x ao canonical representative non vi blind search
ao l non absorbing leaf states open rather reachable u
case regular termination return l
fret
previously hinted kolobov et al fret performs iteration complete searches
starts upper bound approximation v u v continuously updated throughout
fret process within fret iteration heuristic search runs termination
e finding fixed point policy iterations fret runs trap elimination
step finds traps v u greedy graph fret forces next search iteration
include traps fret terminates v u greedy graph contain trap
trap elimination step works follows trap subset non absorbing states
greedy policy remain indefinitely e outgoing transitions v u greedy
graph lead another trap state trap removed collapsing states
single state st incoming transitions st incoming state
outgoing transitions transitions states exiting note transitions
construction contained v u greedy graph
transformation obviously prevents occuring later iterations preserves

v trap states identical v values trap states non absorbing reach
states reach reward transitions note holds regardless
note acyclic case full vi actually needed could simplified leave way
used ilao general case simplicity presentation



fis teinmetz h offmann b uffet

v u e holds parts state space v u yet converged
finite number possible traps state space fret eventually finds v u whose v u greedy graph contain trap graph v u greedy policy extracted
contain traps hence proper trap collapsed state space hence optimal
state space optimal policy original task constructed acting within
collapsed traps way exit taken eventually reached certainty
correctness argument given kolobov
variant fret differs original version terms state space
subgraph considered instead v u greedy graph use u greedy graph e consider
actions selected current greedy policy cf discussion dfhs
refer design fret u refer kolobov et al design fret v u
easy see fret u still correct arguments remain intact stated
fret v u potentially eliminates traps iteration may hence require fewer iterations yet traps may actually need eliminated might eventually optimal
policy entering trap elimination step may much costly particular
goal probability analysis fret v u typically ineffective similarly discussed
dfhs first fret step v u often almost everywhere v u greedy graph
almost entire reachable state space shall see fret u clearly outperforms fret v u

state space reduction via determinized bisimulation
bisimulation known method reduce state space size mdps probabilistic e g
dean givan idea essentially group equivalent sets states together block
states solve smaller mdp block states observe fruitfully combined state art classical techniques namely mergeand shrink heuristics drager finkbeiner podelski helmert haslum hoffmann nissim allow effectively compute bisimulation determinized state space
determinized bisimilar states bisimilar probabilistic state space well identifies practical special case probabilistic bisimulation given factored strips
specification
let us spell little detail given task without budget limit
probabilistic bisimulation partitioning p b bn state set
every bi bj every action every bi following two properties satisfied
dean givan
applicable iff applicable
p
p
ii applicable oo sjokbj p oo tjokbj p
dean givan optimal solution bisimulation mdp induces optimal
solution mdp words suffices work block states bi
denote det outcomes determinization e g yoon et al little
thiebaux separate action adet
every inheriting preo
condition os adds deletes cost determinized bisimulation partitioning
p b bn states every bi bj every determinized action adet

every bi following two properties satisfied milner helmert et al
det
adet
applicable iff ao applicable



fig oal p robability nalysis p robabilistic p lanning

det
det
b adet
applicable sjao k bj iff tjao k bj

easy see b bn probabilistic bisimulation since action
adet
applicable state iff corresponding action original mdp applicable
directly implies b know every action applicable
det
outcome sjadet
k bj iff tjao k bj obviously implies ii
restrictive needed insists subset outcomes sides rather
summed probability
compute determinized bisimulation nave solution build state
space front computing determinized bisimulation one potentially much
better though merge shrink widely employed shrinking strategies
bisimulation nissim hoffmann helmert katz hoffmann helmert helmert
et al nutshell framework constructs abstraction starting
collection abstractions considering single state variable iteratively merging
two abstractions replacing synchronized product single abstraction
left shrinking abstractions bisimulation thereof every merging step
shall see experiments often still incurs prohibitive overhead feasible
lead substantial state space size reductions cases tremendous performance
improvements

dead end pruning
refer states v e goal cannot reached dead ends
one detects via dead end detection technique one treat exactly lost
state except setting l need act non absorbing states constitutes
pruning method useful search state space needs
longer explored apart pruning heuristic search dead end
detection provides non trivial initialization v u initialize v u instead
v u detected dead end informed initial upper bound typically
leads additional search reductions
detect dead ends kolobov et al employ sixthsense kolobov et al
learns dead end detection rules generalizing information obtained classical planner instead exploit power classical heuristic functions readily
available fd implementation framework run outcomes determinization
especially promising limited budget use lower bounds determinized
remaining cost detect states insufficient remaining budget observe natural
effective admissible remaining cost estimators yet would impractical actual classical planner would need optimal thus prohibitively slow unlimited budget
case use heuristic function able detect dead ends returning applies
known heuristics indeed merge shrink heuristics recently shown extremely competitive dead end detectors hoffmann kissmann torralba
make concrete consider state task denote det alloutcomes determinization let h classical heuristic function h guarantees
return dead ends h det exists sequence action
outcomes achieving goal v limited budget task h admissible
h b cannot achieve goal within budget thus v


fis teinmetz h offmann b uffet

experiment state art heuristic functions namely admissible landmark
heuristic per karpas domshlak b lm cut helmert domshlak c several
variants merge shrink heuristics hmax bonet geffner simple
canonical option turned perform consistently worse b report
b
limited budget considered adopting reformulation domshlak mirkis oversubscription reduces budget b landmarks
exchange allows traversing yet unused landmarks reduced cost search turns
however pruning states whose reformulated budget equivalent much simpler method pruning states whose heuristic exceeds original reformulated remaining
budget added value domshlak mirkis reformulation thus lies pruning per se
compilation language resulting combinability heuristics
give full details appendix b get intuition domshlak mirkis reformulation
per se equivalent assume simplicity l set disjoint disjunctive action landmarks initial state assume actions unit costs say prune reduced budget b reduced initial budget b b l reduced costs allow applying member actions yet non used landmarks cost non used landmarks given search
path l l touched path consider state reached path denote
non used landmarks l cost saved thanks reformulation exactly
used landmarks l l hence b b l l b l l l b l
pruned reformulation b iff b l iff b l latter
condition however exactly pruning condition simple method instead

node selection strategies
good anytime behavior v l v u may translate early termination
explore potential fostering via biasing tie breaking selection best
actions u greedy respect v u biasing respectively outcome state sampling
trials lrtdp choice expanded leaf states ao precise regarding
latter usual maintain state open flags ao true state open descendants within
u greedy graph select leaf state expand going forward u
action one open outcome state select best according bias note
relevant dfhs every iteration dfs explores outcomes anyhow
hence dfhs use u tie breaking criteria explained follows
experimented variety strategies follows strategy specifies one
setting default strategy strategy corresponds
commonly used settings uses arbitrary tie breaking fixed manner changing
u action becomes strictly better suggested bonet geffner
b lrtdp bias outcome states ao open outcome state selected
arbitrarily bias lrtdp outcome probability tried prob outcome
bias strategy ao likely open outcome state selected
h bias strategy prefers states smaller h value heuristic h one
used dead end pruning specifically action selection tie breaking actions
experimented strategy merge shrink determinized action costs set negated
logarithm outcome probability compare e g jimenez coles smith compelling theory



fig oal p robability nalysis p robabilistic p lanning

p
u
maximizing optimistic expected
pgoal probability p v select minimizing expected heuristic value p h outcome state bias obtained

renormalizing weighed probabilities h
p prefer high probability outcomes
small h value
inspired brtdp mcmahan et al experiment gap bias strategy biasing
u
l
search towards states large
precisely break ties favor actions
pv v gaps
maximizing expected gap p v u v l renormalize weighed
probabilities v u v l p
inspired common methods classical e g hoffmann nebel helmert
richter helmert experiment preferred actions strategy
u action participating delete relaxed determinized plan
prefers set p
maximizing p v u exists
ao l special case maintain upper bound thus selection
actions u greedy respect v u apply node selection strategies directly
set leaf states current search graph default strategy depth first
rationale try reach absorbing states quickly h bias strategy selects deepest leaf
minimal h value preferred actions strategy selects deepest open leaf reachable
preferred actions furthermore experiment breadth first strategy comparison

experiments
implemented fast downward fd helmert ran experiments
extensive suite benchmarks evaluation first summarize acyclic
benchmarks fret needed ones cyclic benchmarks fret
needed
experiments setup
start giving details implementation describing benchmark suite used
experiments
mplementation
model pertains goal directed mdps limited number explicitly listed outcomes
per action naturally use ppddl younes et al rather rddl sanner coles
et al surface level language fds pre processes extended handle ppddl
added support specifying numeric budget limit
given fd implementation framework contrast previous works optimal probabilistic
implemented scratch fret closely followed original
implementation details specified kolobov et al personal communication andrey kolobov kolobovs original source code available anymore
plays role state art comparison see next
bisimulation heuristic corresponds exact goal probability best outcome sequence
state yet already pointed computing heuristic often infeasible
source code available online appendix downloaded http fai cs unisaarland de downloads fd prob tar bz



fis teinmetz h offmann b uffet

given scant prior work optimal goal probability analysis cf section state art
represented topological vi lrtdp u dead end pruning acyclic
fret v u lrtdp u dead end pruning cyclic configurations
particular points space configurations explore comparison state art
part comparison across configurations thing missing particular form
dead end detection sixthsense prior work kolobov et al
sixthsense complex method advanced dead end pruning via heuristic functions readily
available framework implement sixthsense discussion cyclic
section includes detailed comparison kolobov et al
ippc explodingblocks domain kolobov et al considered
note providing quality guarantees important property study reason
sake clarity compare unbounded suboptimal approaches
discounted criterion assigning large finite penalties dead ends
teichteil konigsbuch et al kolobov et al
furthermore atleastprob special case mdp model checking one may wonder
probabilistic model checking tools e g prism kwiatkowska et al b would fare
benchmarks investigate question would entail
translation ppddl model checking language non trivial makes direct
comparison taking different inputs problematic one may speculate given
focus blind searches model checking tools inferior heuristic search approaches
fare well remains question future work
b enchmark uite
aim comprehensively explore relevant space designed broad suite
benchmarks instances total domains ippc resource constrained
penetration testing pentesting
ippc selected pddl domains strips format moderate nonstrips constructs easily compilable strips resulted domains ippc
ippc selected recent benchmark suite
resource constrained adopted nomystery rovers tpp benchmarks
nakhost et al precisely suites single consumed resource fuel energy money correspond limited budget created probabilistic versions
adding uncertainty underlying road map akin canadian traveler scenario
road segment present given probability encoded separate probabilistic action attempting segment first time simplicity set probability
throughout
pentesting general objective exploits compromise computers network one another specific targets reached action available modified
pomdp generator sarraute buffet hoffmann test scenario used core security http www coresecurity com output ppddl encodings
hoffmanns attack asset mdp pentesting network configura make benchmarks feasible optimal probabilistic reduce size parameters number
locations etc scaled parameters number chosen get instances borderline
feasibility vi



fig oal p robability nalysis p robabilistic p lanning

tion known fixed exploit callable succeeds fails probability generator uses network consisting exposed part sensitive part user part
allows scale numbers h hosts e exploits sarraute et al pomdp model
solver sarsop see kurniawati hsu lee guarantee optimality scale
h e benchmarks fixed h e simplicity obtain number
instances similar benchmark domains scaled instances without
budget limit budget limit
benchmark tasks except pentesting ones already
generated separate limited budget version anyway obtained several limited budget benchmarks follows set outcome costs otherwise specified determined
minimum budget bmin required achieve non goal probability resource constrained
benchmarks bmin determined generator minimum amount resource required
reach goal deterministic domain version benchmarks ran fd
lm cut outcomes determinization failed skipped otherwise
read bmin cost optimal plan created several limited budget tasks c differing
constrainedness level c namely following nakhost et al set global budget b
c b c bmin c factor available budget exceeds minimum
needed able reach goal let c range
atleastprob let range pointless approxprob
let range pointless cyclic convergence
parameter set value used kolobov et al experiments
run cluster intel e machines running ghz time memory cut offs
minutes gb
acyclic
consider first acyclic pertains budget limited benchmarks pentesting
without budget limit well ippc triangletireworld moves made
one direction state space acyclic consider objectives maxprob atleastprob
approxprob run search variants vi ao lrtdp dfhs variants
subsets bounds applicable node selection strategies explained deadend pruning run lm cut well merge shrink state art shrinking
strategies bisimulation abstraction size bound n data n
n k tried n k k k resulted similar behavior run
variants without dead end pruning use deterministic bisimulation db reduced state space
vi bisimulation successfully computed block state mdp easily
solved simplest given db require dead end pruning
dead ends already removed reduced state space
overall yields different possible configurations actually test
configurations course interesting needed make essential
observations instead organize experiment terms three parts focusing
particular issue interest consider table gives overview configurations
considered experiment design experiments follows
modeling solving entire network domain dependent decomposition al
trading accuracy performance sarraute et al scale much



fis teinmetz h offmann b uffet

experiment

search


pruning

node selection

configs



ao u
maxprob search prun vi ao l
default
lrtdp

dfhs
u
u
ing
vi db
vi ao l
ao u

atleastprob approx ao lu
lrtdp u

lm cut
default
prob parameters
lrtdp lu
hdp u
hdp lu vi db
vi ao l
ao u


lrtdp u
atleastprob approx ao lu

lm cut respeclrtdp lu
hdp u
prob node selection
tively
hdp lu vi db








table overview tested acyclic section numbers brackets give
number options number obvious note total
number configurations gets multiplied atleastprob vs approxprob
different configurations different termination criteria hdp
member dfhs family corresponding bonet geffners
dfhsfwdcons
lab
hdp
first evaluate different search dead end pruning methods maxprob fixing
node selection strategy default
omit x lu variants explained earlier maxprob heuristic search
maintaining v l redundant early termination dominated regular termination
default node selection strategy makes sense node selection strategies
relevant anytime performance e early termination plays minor role
maxprob whose early termination possibility exceptional case initial state
lower bound becomes v l
next fix best performing dead end pruning method analyze search performance atleastprob approxprob function parameter respectively
fix node selection strategy default leaving examination experiment

finally let node selection strategies range keeping otherwise setting experiment

conclude discussion additional data illustrating typical anytime behavior
part experiment described separate sub section follows
earch lgorithms p runing ethods ax p rob
table shows coverage data e number benchmark tasks maxprob solved
within given time memory limits
pruning methods lm cut clearly stands every search yields
far best overall coverage substantial advantages rectangletireworld
nomystery b note n overall coverage worse pruning
due prohibitive overhead domains computing bisimulation
determinized state space invested effort pays use bisimulation


fig oal p robability nalysis p robabilistic p lanning

domain



triatire



blocksw b
boxworl b
drive b
elevator b
expbloc b
random b
rectire b
tirewor b
triatire b
zenotra b












nomystery b
rovers b

tpp b

pentest b
pentest
p





domain



triatire



blocksw b
boxworl b
drive b
elevator b
expbloc b
random b
rectire b
tirewor b
triatire b
zenotra b












nomystery b
rovers b

tpp b

pentest b
pentest
p





dfhsfwd
dfhsfwdcons
u
dfhsfwd
vi u
vi
lab u
lm
lm
lm

n
n
n
ippc benchmarks



ippc benchmarks budget limit














probabilistic resource constrained benchmarks budget limit



pentesting benchmarks







dfhsvi u
lm
n

hdp u
lm
n






























ao l
ao u
lrtdp u
hdp u
lm
lm
lm
lm
n
n
n
n
ippc benchmarks


ippc benchmarks budget limit














probabilistic resource constrained benchmarks budget limit



pentesting benchmarks







vi
lm
n












vi

db


















table acyclic maxprob coverage number tasks solved within time memory
limits best values within table boldface top dfhs variants recall hdp
dfhsfwdcons
member dfhs family dfhsvi ilao bottom remaining
lab
search including overall best dfhs variant domains b modified
budget limit number instances pruning else pruning
remaining budget b domains h domains lm lm cut
merge shrink n size bound n k size bound vi db
vi run reduced deterministic bisimulated state space default node selection



fis teinmetz h offmann b uffet









lrtdp u lm cut

lrtdp u

reduced mdp state space vi db rather dead end pruning extreme
example latter triangletireworld far beyond standard benchmarks table triangleside length vi db scales side length original domain limited budget
version comparison hitherto best solver far prob prp camacho et al
scales side length original domain optimal goal probability e
presence strong cyclic plans holds original domain limited budget
version could actually run prob prp limited budget domain version prob prp
natively support budget hard coding budget ppddl resulted encodings
large pre process
comparing different dfhs u variants configuration clearly stands
overall perform equally well though fwdcons variants cutting exploration
inconsistent states rather absorbing states slight edge difference mainly comes
triangletireworld explodingblocks tpp b fwdcons configurations solve
instances zenotravel b fwdcons configurations perform slightly worse counterparts termination parameter vi vs label almost effect coverage due
gives best coverage
similarity dfhs configurations dfhsfwdcons
lab


representative


dfhs
family

remaining discussion
use dfhsfwdcons
lab
fwdcons
corresponds hdp simplicity refer name
dfhslab
ao l better vi case early termination v l full certainty
policy found visiting entire state space happens rarely ao l
dominated vi changes atleastprob see figures failures vi
due memory runtime exhaustion building reachable state space lrtdp u clearly
outperforms ao u presumably tends absorbing states quickly lrtdp u
hdp u par lm cut solve exact number instances though
exactly instances otherwise hdp u solves slightly fewer tasks lrtdp u
gauge efficiency heuristic search vs blind search maxprob compare lrtdp u vs
vi table contrary intuition good initial goal probability estimator required
heuristic search useful lrtdp u clearly superior advantage grow quality
initialization lm cut yields largest coverage increase far however even without
dead end pruning e trivial initialization v u lrtdp u dominates vi throughout
improves coverage domains




















vi
















vi lm cut





figure acyclic number states visited vi x vs lrtdp u pruning
left respectively lm cut pruning right default node selection
next shed additional light comparing search space sizes runtime values
tables provide aggregate data figure gives scatter plot canonical comparison


fig oal p robability nalysis p robabilistic p lanning

ao u
lrtdp u
lm


lm

n

n

ippc benchmarks





ippc benchmarks budget limit











k
k

k k



k
k k




k



k k k
k k



probabilistic resource constrained benchmarks budget limit
k k k
k k
k
k k k
k k k
k

k k k
pentesting benchmarks






domain



triatire
h




blocksw b

drive b

elevator b

expbloc b

non trivial
h

random b

non trivial
h

rectire b

non trivial
triatire b

non trivial
h

zenotra b

non trivial
nomystery b
h

rovers b

non trivial
h

tpp b

non trivial
pentest b

non trivial
pentest

non trivial

vi
lm

n






hdp u
lm

n









k


k




k
k


k
k

k
k

k






table acyclic maxprob geometric mean search space size number states visited
multiples gives size instance basis namely instances solved
shown configurations skipping instances solved second configurations non trivial uses instances solved vi second
h uses instances commonly solved ao u lrtdp u hdp u
solved vi rows empty instance basis skipped default node selection
vi lrtdp u data ao l shown coverage dominated vi cf
table goes runtime search space include non trivial rows
tables behavior interesting instances averages skewed
many small instances domains include h rows elucidate
behavior challenging instances beyond reach vi
clear message table figure heuristic search apart
exceptions visit much fewer states vi even trivial upper bound initialization search spaces reduced domains except rectangletireworld pentest
instance lrtdp u instead vi gain around order magnitude many
instances larger gains orders magnitude occur rare cases giving
heuristic search additional information earlier dead end detection differences become even larger


fis teinmetz h offmann b uffet

domain



triatire
h




blocksw b

drive b

elevator b

expbloc b

non trivial
h

random b

non trivial
h

rectire b

non trivial
triatire b

non trivial
h

zenotra b

non trivial
nomystery b
h

rovers b

non trivial
h

tpp b

non trivial
pentest b

non trivial
pentest

non trivial

ao u
lrtdp u
hdp u
lm
lm
lm
n

n

n

ippc benchmarks









ippc benchmarks budget limit



















































probabilistic resource constrained benchmarks budget limit











pentesting benchmarks



















vi
lm
n



table acyclic maxprob geometric mean runtime cpu seconds setup
presentation table
previously hinted observations made clarity
kolobov et al report lrtdp beat vi maxprob consider single domain experiment trivially initialized v u use dead end pruning
vi lrtdp already benefits smaller state space impact heuristic search
remains unclear
even though search space heuristic search many cases small
fraction whole dead end pruned state space necessarily reflected runtime
instances solved vi typically fast often faster heuristic search rarely
outperformed significantly despite larger search spaces e heuristic search
visit less states suffers updates recall vi updates
visited state exactly significant runtime advantages vi non trvial rows
obtained heuristic search explodingblocksb randomb triangletireworldb
comparing heuristic search conclusions fine grained overall
similar concluded coverage lrtdp u dominates ao u almost throughout
note even though search space size ao u lrtdp u almost similar ao u
requires lot time lrtdp u performs updates across nontrivial commonly solved instances tables geometric mean number updates done


fig oal p robability nalysis p robabilistic p lanning

ao u times higher lrtdp u lrtdp u hdp u non trivial
value initialization give similar terms coverage terms
runtime search space size lrtdp u however effective domains e g
rectangletireworld zenotravel additional dead end detection method used
hand hdp u slight edge probabilistic resource constrained domains one notable
case lrtdp u consistently outperforms hdp u triangletireworld
impact dead end pruning vi typically moderate gains heuristic search
much pronounced thanks stronger heuristic function initialization especially ao u
benefits lot lrtdp u hdp u benefit well smaller extent partly
already effective first place comparing across different dead end pruning methods
although n clearly yields largest search space reductions necessarily
recognizes dead ends overhead bisimulation computation outweighs search space
reduction cases terms pruning power n k lm cut
heuristic overall roughly similar yet lm cut edge runtime
l east p rob pprox p rob parameter nalysis
turn weaker objectives atleastprob approxprob fix lm cut almost
effective dead end pruning examine power early termination different
search node selection strategies best viewed function goal probability threshold atleastprob desired goal probability accuracy approxprob vi
forms baseline independent consider figure
vi
lrtdp u



vi

lrtdp lu

ao lu

hdp u

hdp lu





solved instances

solved instances



ao l

ao u







ao l

ao u

lrtdp lu

ao lu

hdp u

hdp lu


















lrtdp u





b
figure acyclic total coverage atleastprob function approxprob function b configurations use default node selection lm cut
dead end pruning
atleastprob figure interesting region benchmark instances feasible
vi yet sometimes feasible search one clear feature superiority
lrtdp ao hdp one see smaller values lrtdp able
update v l much effectively hdp resulting larger coverage lrtdp region


fis teinmetz h offmann b uffet

smaller values ao l exhibits strikingly strong behavior small values approaching
one case surpassing performance lrtdp u evidently depth first expansion
strategy quite effective anytime behavior v l thus termination via v l
way effective heuristic search ao lu shall see figure
often effective lrtdp general v l clear advantage
small larger maintaining v l become burden yet v u advantage due early
termination v u bounds exhibit easy hard easy pattern
spike left hand side figure e significantly worse performance
outlier due pentest domains without domains ao lu
lrtdp lu hdp lu exhibit strict easy hard easy pattern contrast typical probabilistic scenarios penetration testing goal probability chance
successful attack typically small indeed benchmarks searches
upper bound quickly obtain v u terminating early v u
takes long time obtain v u
approxprob figure b smaller values consistently worse performance
see superiority lrtdp ao hdp relatively compared ao lu
strong behavior ao l regions allowing aggressive early termination key
lrtdp beating hdp clearly due lrtdp updating v l much effectively hdp lu
improve hdp u small margin nonetheless see superiority
bounds dont
n ode election trategies
figure shows different node selection strategies atleastprob relative performance node
selection strategies approxprob include separate figure
lrtdp lu def
ao l bfs



solved instances



ao lu def
ao lu h

ao l dfs
ao l h

ao lu prob
hdp lu def

vi












figure acyclic total coverage atleastprob function varying node
selection strategy configurations use lm cut dead end pruning
readability competitive base ao l ao lu lrtdp lu
hdp lu well vi baseline lrtdp hdp default node selection consistently works basically well alternatives ao l see


fig oal p robability nalysis p robabilistic p lanning

depth first strategy important way beyond breadth first worse vi
h bias strategy marginally consistently better depth first ao lu h bias
prob outcome bias helpful substantially improving default strategy
h bias consistently improves bit default ao gap bias preferred actions strategies
shown consistently slightly worse apparently gap bias leads
breadth first style behavior preferred actions mainly cause runtime overhead
n llustration ypical nytime b ehavior
conclude discussion acyclic figure exemplifies typical anytime behavior e
development v l v u bounds initial state value function runtime
lrtdp lu ao l


lrtdp v u lm cut

lrtdp v l

lrtdp v l lm cut

ao

ao

l



l lm cut


probability

probability



lrtdp v u


















time











lrtdp v u

lrtdp v u lm cut

lrtdp v l

lrtdp v l lm cut

ao l

ao l lm cut



time





b

figure acyclic anytime behavior lrtdp lu v v l ao l v l
function runtime elevators instance without pruning lm cut pruning
constrainedness level c respectively c b default node selection
u

benefit lm cut pruning evident observe ao l way effective
lrtdp quickly improving lower bound indeed runs shown optimal policy
quickly across benchmarks solved ao l lrtdp omitting
took second cases ao l finds optimal policy faster lrtdp geometric average ao l takes time taken lrtdp purpose downside
unless v ao l must explore entire state space runs figure exhaust memory
maxprob summary heuristic search much stronger proving maximum goal
probability found often distracting improving v l quickly
parts figure use base instance different constrainedness levels c
draw conclusions effect surplus budget budget actions
applied reaching absorbing states adversely affects upper bound consistently
across experiments takes much longer time decrease lower bound
hand often increases quickly higher c easier goal states


fis teinmetz h offmann b uffet

cyclic fret
consider cyclic pertaining standard ippc benchmarks probabilistic
nomystery rovers tpp without budget resource limit run lrtdp dfhs
ao restricted acyclic state spaces use two different variants fret described earlier
fret v u per kolobov et al variant fret u consider objectives
dead end pruning methods lm cut returns iff cheaper heuristic hmax
use hmax vary node selection strategies seen
lrtdp dfhs bring notable advantage default strategy use
deterministic bisimulation db reduced state space base differences
emerge difference acyclic case vi need
run fret given db require dead end pruning
overall yields different possible configurations
interesting instead organize experiment terms parts focusing issues
interest specifically parts maxprob atleastprob approxprob
node selection strategies relevant previous part considering
integrate data illustrating anytime behavior discussion table gives
overview tested configurations
experiment
fret variant
search
pruning
configs
maxprob search prun

fret v u fret u vi lrtdp u dfhs db
ing


vi
atleastprob approxu
u lrtdp

fret v

fret
lu
prob parameters
hdp lu

lrtdp u
hdp u

hmax



table overview tested cyclic section note vi require hence combined fret denote fret
note number configurations gets multiplied atleastprob
vs approxprob different configurations different termination
criteria configurations tested use default node selection
earch lgorithms p runing ethods ax p rob
table shows coverage data dfhs family shown top remaining
search including competitive dfhs hdp
shown bottom vary fret variant top space reasons
fret v u coverage differences across dfhs family members
similarly acyclic case dfhs configurations stopping exploration inconsistent
states give slightly better stopping absorbing states termination
parameter almost effect coverage hdp e dfhsfwdcons
solves one task
lab
explodingblocks dfhsfwdcons


otherwise

coverage


akin
vi
acyclic case lrtdp hdp perform equally well though hdp slight edge
combination fret u
running search deterministic bismulation state space less effective cyclic
benchmarks acyclic ones gives clear advantage rovers


fig oal p robability nalysis p robabilistic p lanning


domain



blocksworld
boxworld
drive
elevators
explodingblocks
random
rectangletireworld
tireworld
zenotravel
nomystery
rovers
tpp
p

domain
blocksworld
boxworld
drive
elevators
explodingblocks
random
rectangletireworld
tireworld
zenotravel
nomystery
rovers
tpp
p

















fret u
dfhsvi u
dfhsfwdcons
u
dfhsfwd
hdp u
vi
lab u
hmax
hmax hmax hmax
n bs
n bs
n bs
n bs
n
ippc benchmarks

























probabilistic resource constrained benchmarks
















dfhsfwd
vi u
hmax
























































fret v u
fret u
lrtdp u
hdp u
lrtdp u
hdp u
hmax hmax hmax hmax
n db
n db
n db
n
ippc benchmarks



























probabilistic resource constrained benchmarks

















vi
hmax
n db


bs















db














table cyclic maxprob coverage best values within table boldface fretv u per kolobov et al fret u modified version top dfhs variants
member dfhs family dfhsvi ilao
recall hdp dfhsfwdcons
lab
showing dominating fret version fret u bottom remaining search varying fret version including overall best dfhs variant
dead end pruning variants none else heuristic value hmax respectively merge shrink n size bound n k size bound db run
reduced deterministic bisimulated state space default node selection
striking far fret u outperforms vi fret v u substantially note domains except explodingblocks rovers advantage vi
obtained even without dead end pruning e trivial initialization v u strongly confirms
power heuristic search even absence good admissible goal probability estimators
shed additional light coverage search space size runtime
data figure compares search space sizes vi vs fret u non trivial initialization
hmax useful gains orders magnitude possible even without
table provides aggregate search space size runtime data data shown configuration fret v u hdp data almost identical fret v u lrtdp









fret u hmax

fret u

teinmetz h offmann b uffet



















vi
















vi hmax





figure cyclic number states visited vi x vs fret u lrtdp u
pruning left respectively hmax pruning right
fret v u
fret u
lrtdp u
lrtdp u

hmax

hmax


n

n

n

ippc benchmarks




























































probabilistic resource constrained benchmarks









ippc benchmarks

































k k k





















k k k





k k k k k k











probabilistic resource constrained benchmarks
k k k k k k
k k k k k k
k k k k k k
k k k k k k

vi
hmax
domain



blocksworld
drive
elevators
explodingblocks
non trivial
rectangletireworld
non trivial
tireworld
non trivial
zenotravel


































nomystery
rovers
tpp
non trivial
















blocksworld
drive
elevators
explodingblocks
non trivial
rectangletireworld
non trivial
tireworld
non trivial
zenotravel











k






k k
k k


nomystery
rovers
tpp
non trivial






k
k
k
k

k
k
k
k

hdp u
hmax

n





























































table cyclic top maxprob geometric mean runtime cpu seconds bottom
maxprob geometric mean search space size number states visited multiples
similar setup presentation table gives size instance basis
default commonly solved instances skipping trivial ones non trivial uses
instances solved vi second h shown see text



fig oal p robability nalysis p robabilistic p lanning

search space sizes exactly runtimes differ seconds difference
tables include h rows would interesting
fret v u hardly solves instances vi would excluded rows
data would compare lrtdp vs hdp perform similarly anyway
striking table consistency extent fret u visits
less states competitors lrtdp hdp advantage typically yields better
runtimes well notable exception nomystery larger number fret iterations substantial slow despite much smaller search space fret v u
lrtdp requires fret iterations average nomystery instances commonly
solved fret u lrtdp latter configuration requires iterations average similarly hdp
impact dead end pruning notably smaller acyclic case search spaces
reduced substantially single domain explodingblocks domains
reduction minor moderate one
vi kolobov
vi
vi hmax
fret v u kolobov
fret v u hmax
fret u hmax






time

states visited







































b
figure cyclic explodingblocks shown kolobov et al fret
vs vi number states visited b runtime cpu seconds function
ippc instance index different variants included comparison data kolobov
et al taken code available anymore hence runtime
comparison modulo different computational platforms treated
care shown fret configurations use lrtdp u default node selection
explodingblocks happens single domain kolobov et al experimented
figure provides detailed comparison kolobov et al data state art
measure provided previous work use exact runtime search space size data reported
kolobov et al recall source code available anymore
kolobov et al ran vi pruning vs fret v u lrtdp pruning
sixthsense kolobov et al observed coverage former
latter identical vi vs fret v u lrtdp hmax give


fis teinmetz h offmann b uffet

detail figure shows number states visited total runtime terms plots ippc
instance index done kolobov et al
consider first figure search space size difference vi kolobov
vi different task state representation resulting respective implementation
framework fd framework somewhat effective substantially better performance
vi hmax dead end pruning shows omission kolobov et al study
dead end pruning fret vi indeed obfuscates possible conclusions regarding
effect heuristic search vs effect state pruning hmax pruning vi almost
effective fret v u pruning kolobov et al fret v u close
except exploring significantly less states large instances latter shows especially
given effective representation fd sixthsense stronger dead end detector
hmax hardly surprising considering information sources sixthsense outcomes
determinized classical guidance h graphplan validity tests
hand sixthsenses information sources much time intensive hmax
presumably reason runtime picture figure b latter qualitatively
similar except fret v u kolobov significantly worse rather better
largest instance last conclusion taken grain salt though given different
computational environments
certainly given clarity fret u advantage search space size runtime one
conclude variant fret substantially improves previous state art
l east p rob pprox p rob parameter nalysis
weaker objectives atleastprob approxprob examine coverage function respectively figure shows data
fret v u behavior figure similar acyclic case figure
particular maintaining upper lower bound fret v u exhibits easy hardeasy pattern due advantages early termination
fret u though curves flat observation small advantage
v l addition v u due scaling benchmarks combined extreme
performance loss point scaling domain instance number x
x fret u solve instances completely e solving maxprob x
neither v l v u improved remaining respectively time memory
limit smaller instances get expected anytime behavior figure exemplifies
easy hard easy pattern would thus emerge smaller runtime memory limits

conclusion
optimal goal probability analysis probabilistic notoriously hard
extent amount work addressing limited investigation contributes comprehensive design space known adapted addressing designing several
variants along way establishing fd implementation basis supporting tight
integration mdp heuristic search classical techniques experiments clarify
figure b considers largest instance feasible hmax pruning figure considers secondlargest instance feasible without pruning largest one feasible without pruning namely instance maximum goal probability anytime curve v u interesting



fig oal p robability nalysis p robabilistic p lanning

fret v u lrtdp u

fret u lrtdp u

fret v u lrtdp u

fret u lrtdp u

fret v u lrtdp lu
fret v u hdp u
fret v u hdp lu
vi

fret u lrtdp lu
fret u hdp u
fret u hdp lu

fret v u lrtdp lu
fret v u hdp u
fret v u hdp lu
vi

fret u lrtdp lu
fret u hdp u
fret u hdp lu


solved instances

solved instances



















b








probability

probability

figure cyclic total coverage atleastprob function approxprob function b configurations use default node selection hmax
dead end pruning



















time











time



b
fret u

figure cyclic anytime behavior
lrtdp lu hdp lu
default node selection without pruning explodingblocks instance b
hmax pruning instance
empirical state art exhibit substantial improvements thanks techniques technique combinations furthermore showcase opportunities arising naturally acyclic
early termination criteria weaker maximum goal probability
hope encouraging implementation basis inspire renewed
interest important many promising future directions
would emphasize
advanced admissible goal probability estimators could obtained e g abstractions interpreted bounded parameter mdps givan leach dean promis

fis teinmetz h offmann b uffet

ing extend state art classical abstraction techniques pattern
databases edelkamp haslum botea helmert bonet koenig merge andshrink helmert et al cartesian abstractions seipp helmert
probabilistic setting
hybrids heuristic search monte carlo tree search appears promising option
improve anytime behavior respect upper lower bound thus foster
early termination inspiration could taken existing hybrids geared toward
purposes keller eyerich bonet geffner keller helmert
exploiting dominance relations goal probability higher dominating states
raising opportunity prune dominated regions transfer upper lower bounds across
states state domination ubiquitous limited budget resource constrained
general domination relations shown exist many
classical torralba hoffmann transfer techniques probabilistic case via outcomes determinization straightforward
last least simulated penetration testing application worth
right basic idea exploit particular structure specifically
partially delete relaxed behavior characterizing property simulated penetration testing
action applicable remains applicable first executed attacker gets
position enabling exploit exploit remains enabled hence delete relaxed
optimal solution navely branch action every state ever
combat least three interesting directions following pommerening helmerts
methods computing h different branching schemes might apply challenge
maintain value function correctness following gefen brafmans methods computing h partial order reduction could adapted challenge deal action
interference entailed shared budget finally methods specific probabilistic setting may
apply intuitively preserve optimality certain actions need attempted alternate
goal path failed suggests identify branch particular critical points along
search path

acknowledgments
work partially supported german foundation dfg grant ho
critically constrained via partial delete relaxation well federal ministry education bmbf funding center security
privacy accountability cispa grant kis thank christian muise
probabilistic pddl extension fd parser thank andrey kolobov discussions
thank anonymous reviewers whose comments helped improve

appendix depth first heuristic search cyclic
pseudo code family depth first heuristic search dfhs general cyclic
probabilistic shown figure


fig oal p robability nalysis p robabilistic p lanning

procedure goalprob dfhs

loop
early termination criteria exactly goalprob ao
label labeled solved
vi u changed running vi u greedy graph
index
dfhs exploration
set idx visited states
clean stack visited
else return u endif regular termination
endloop
procedure dfhs exploration
initialize endif
labeled solved
label solved
return
endif
f lag
fw
v u consistent f lag endif
update v u u v l l
consist f lag return endif
endif
idx index lowlink index
push onto stack mark visited
index index
foreach p u
idx
f lag dfhs exploration f lag
idx lowlink lowlink lowlink lowlink endif
else stack idx lowlink lowlink idx endif
done
f lag fw
v u consistent f lag endif
update v u u v l l
endif
label f lag idx lowlink
forever
stack pop
label solved
break endif
done
endif
return f lag

figure depth first heuristic search dfhs general cyclic maxprob atleastprob
approxprob

appendix b landmarks pruning admissible heuristic vs budget reduction
stated domshlak mirkis reformulation pruning states global
budget reduced disjunctive action landmarks equivalent regarding states pruned
method much simpler method landmarks pruning


fis teinmetz h offmann b uffet

remaining original budget give argument previously made unit costs
pairwise disjoint landmarks general setting assume classical setup
simplicity arguments probabilistic oversubscription setups essentially
assume strips task f g action costs c global
budget b use notation following admissible landmark heuristics per karpas domshlak
let l set disjunctive action landmarks e every l l every
action sequence leading goal touches l exists l used let
furthermore
cp l r
cost partitioning e function satisfying
p
c l p
c denote h l minal cp l subset l l landmarks
denote h l h l intuitively landmark l l assigned weight h l via cp
admissible heuristic value h l obtained summing weights
describe domshlak mirkis pruning technique terms domshlak
mirkis formulation terms compilation language complicated equivalent formulation far pruning concerned
domshlak mirkis technique maintains non used landmarks part states namely
state reached path l l non used iff touch l denote set nonused landmarks l obviously l l landmarks note l
part state even two search paths lead end state use different landmarks
end states considered different restriction arises compilation
book keeping landmarks must happen inside language e inside states one
could formulate pruning technique without restriction get back
pruning technique arises interplay reduced global budget reduced
action costs depending non used landmarks define reduced global budget b b h l
action denote l set landmarks participates e l l l l
l state search applicable action transition
reduced cost namely cost c h l l words reduce cost
summed weight non used landmarks participates
consider state search denote remaining reduced budget b
say prune iff b consider path ending non used landmarks
part state paths must touch
p subset landmarks l namely
l l denote actual cost c c relative cost cost saved
thanks cost reduction exactly h l l weight touched landmarks therefore
b b c
h l l p b h l c h l l p
definition h
p
equals b h l c l h l equals b c h l
b c h l thus pruned b iff b c h l latter condition
b h l exactly pruning condition resulting h l
admissible heuristic function pruning remaining budget
non compilation setting one could indeed customary admissible landmark heuristics handle landmarks path dependent manner non used landmarks maintained
domshlak mirkis maintain remaining budget part state instead prune g
b obviously equivalent except duplicate detection powerful compares states
facts f purpose discussion make difference note
probabilistic setting distinguish states f b goal probability depends
maintaining best way reaching f suffice compute exact goal probability
initial state



fig oal p robability nalysis p robabilistic p lanning

annotations states rather part multiple search paths may end state
use different landmarks set remaining landmarks l union
individual path l l non used iff exists least one path
touch l still suffices l landmark landmark heuristic per karpas domshlak kind book keeping uses admissible
heuristic value h l
one apply domshlak mirkis reformulation technique without maintaining
landmarks part state notion transition cost reduction would become
complicated lest one loses information reached reduced
cost due touching landmark l later another path touch l
l actually still valid landmark therefore need reduce cost
account would revise path costs posthoc every time path
becomes available revisions cost reduction path exactly
h l l weight non used landmarks l longer subtracted weight
landmarks l l subtracted every definition every touches every
l l l cost saved every path relative exactly h l l
point arguments apply pruning equivalent pruning
via b h l stronger pruning method would get without posthoc
path cost revision
summary reduced remaining budget b equivalent pruning
original remaining budget vs landmark heuristic b h l noted though
pruning benefit domshlak mirkis reformulation technique
technique allows compute another complementary admissible heuristic h reformulated task domshlak mirkis point part motivation
practice perspective landmark heuristic h used additively
admissible pruning remaining budget additivity achieved method
generalizing cost partitionings cost reduced variant action applied
h abstract away constraint h uses action twice employs
reduced cost yet pays full cost second time exploring kind generalized
cost partitioning detail interesting line future work

references
altman e constrained markov decision processes crc press
baier c groer leucker bollig b ciesinski f controller synthesis
probabilistic systems extended abstract pp springer us boston
barto g bradtke j singh p learning act real time dynamic programming artificial intelligence
bertsekas dynamic programming optimal control volumes athena scientific
bertsekas tsitsiklis j neurodynamic programming athena scientific
bonet b geffner h heuristic search artificial intelligence



fis teinmetz h offmann b uffet

bonet b geffner h faster heuristic search uncertainty
full feedback gottlob g ed proceedings th international joint conference artificial intelligence ijcai pp acapulco mexico morgan kaufmann
bonet b geffner h b labeled rtdp improving convergence real time dynamic
programming giunchiglia e muscettola n nau eds proceedings th
international conference automated scheduling icaps pp
trento italy morgan kaufmann
bonet b geffner h mgpt probabilistic planner heuristic search journal
artificial intelligence
bonet b geffner h learning depth first search unified heuristic search
deterministic non deterministic settings application mdps long
smith eds proceedings th international conference automated
scheduling icaps pp ambleside uk morgan kaufmann
bonet b geffner h action selection mdps anytime ao versus uct hoffmann j selman b eds proceedings th aaai conference artificial intelligence aaai toronto canada aaai press
bryce buffet th international competition uncertainty part proceedings th international competition ipc
camacho muise c mcilraith fond robust probabilistic computing compact policies bypass avoidable deadends coles coles
edelkamp magazzeni sanner eds proceedings th international
conference automated scheduling icaps aaai press
chatterjee k chmelik gupta r kanodia optimal cost almost sure reachability pomdps bonet b koenig eds proceedings th aaai conference
artificial intelligence aaai pp aaai press
chatterjee k chmelik gupta r kanodia optimal cost almost sure reachability pomdps artificial intelligence
coles j opportunistic branched plans maximise utility presence resource
uncertainty raedt l ed proceedings th european conference artificial
intelligence ecai pp montpellier france ios press
coles j coles fox long hybrid lp rpg heuristic modelling
numeric resource flows journal artificial intelligence
coles j coles garca olaya jimenez linares lopez c sanner yoon
survey seventh international competition ai magazine
dai p mausam weld goldsmith j topological value iteration
journal artificial intelligence
dean l givan r model minimization markov decision processes kuipers
b j webber b eds proceedings th national conference american
association artificial intelligence aaai pp portland mit press


fig oal p robability nalysis p robabilistic p lanning

domshlak c mirkis v deterministic oversubscription heuristic search
abstractions reformulations journal artificial intelligence
drager k finkbeiner b podelski directed model checking distancepreserving abstractions international journal software tools technology transfer

edelkamp pattern databases cesta borrajo eds proceedings th european conference ecp pp springer verlag
gefen brafman r pruning methods optimal delete free bonet
b mccluskey l silva j r williams b eds proceedings nd international
conference automated scheduling icaps aaai press
givan r leach dean bounded parameter markov decision processes artificial intelligence
hansen e zilberstein lao heuristic search finds solutions
loops artificial intelligence
haslum p botea helmert bonet b koenig domain independent construction pattern database heuristics cost optimal howe holte
r c eds proceedings nd national conference american association
artificial intelligence aaai pp vancouver bc canada aaai press
haslum p geffner h heuristic time resources cesta
borrajo eds proceedings th european conference ecp pp
springer verlag
helmert fast downward system journal artificial intelligence
helmert domshlak c landmarks critical paths abstractions whats difference anyway gerevini howe cesta refanidis eds proceedings
th international conference automated scheduling icaps pp
aaai press
helmert haslum p hoffmann j nissim r merge shrink abstraction method
generating lower bounds factored state spaces journal association computing machinery
hoffmann j simulated penetration testing dijkstra turing test brafman r domshlak c haslum p zilberstein eds proceedings th international conference automated scheduling icaps aaai press
hoffmann j kissmann p torralba distance cares tailoring merge andshrink heuristics detect unsolvability schaub ed proceedings st european
conference artificial intelligence ecai prague czech republic ios press
hoffmann j nebel b system fast plan generation heuristic
search journal artificial intelligence
hou p yeoh w varakantham p revisiting risk sensitive mdps
chien fern ruml w eds proceedings th
international conference automated scheduling icaps aaai press


fis teinmetz h offmann b uffet

jimenez coles smith probabilistic domains deterministic
numeric planner proceedings th workshop uk scheduling
special interest group plansig
karpas e domshlak c cost optimal landmarks boutilier c ed
proceedings st international joint conference artificial intelligence ijcai
pp pasadena california usa morgan kaufmann
katz hoffmann j helmert relax bisimulation bonet b mccluskey l silva j r williams b eds proceedings nd international conference automated scheduling icaps pp aaai press
keller eyerich p prost probabilistic uct bonet b
mccluskey l silva j r williams b eds proceedings nd international
conference automated scheduling icaps aaai press
keller helmert trial heuristic tree search finite horizon mdps
borrajo fratini kambhampati oddi eds proceedings rd international conference automated scheduling icaps rome italy aaai
press
kolobov scalable methods expressive uncertainty
ph thesis university washington
kolobov mausam weld sixthsense fast reliable recognition dead ends
mdps fox poole eds proceedings th national conference
american association artificial intelligence aaai atlanta ga usa aaai press
kolobov mausam weld theory goal oriented mdps dead ends
de freitas n murphy k p eds proceedings th conference uncertainty
artificial intelligence uai pp catalina island ca usa auai press
kolobov mausam weld geffner h heuristic search generalized stochastic
shortest path mdps bacchus f domshlak c edelkamp helmert eds
proceedings st international conference automated scheduling
icaps aaai press
kurniawati h hsu lee w sarsop efficient point pomdp
approximating optimally reachable belief spaces robotics science systems iv
kuter u hu j computing lower upper bounds action elimination
mdp miguel ruml w eds proceedings th international symposium abstraction reformulation approximation sara vol lecture
notes computer science whistler canada springer verlag
kwiatkowska parker qu h incremental quantitative verification markov
decision processes ieee ifip st international conference dependable systems
networks dsn pp
kwiatkowska z norman g parker b prism verification probabilistic
real time systems gopalakrishnan g qadeer eds proceedings rd international conference computer aided verification cav vol lecture notes
computer science pp springer


fig oal p robability nalysis p robabilistic p lanning

little aberdeen thiebaux prottle probabilistic temporal planner veloso
kambhampati eds proceedings th national conference american association artificial intelligence aaai pp pittsburgh pennsylvania usa aaai press
little thiebaux probabilistic vs replanning icaps workshop
international competition past present future
marecki j tambe towards faster continuous resources stochastic
domains fox gomes c eds proceedings rd national conference
american association artificial intelligence aaai pp chicago illinois
usa aaai press
mcmahan h b likhachev gordon g j bounded real time dynamic programming rtdp monotone upper bounds performance guarantees proceedings
nd international conference machine learning icml
meuleau n benazera e brafman r hansen e mausam heuristic search
continuous resources stochastic domains journal artificial
intelligence
milner r operational algebraic semantics concurrent processes van leeuwen j
ed handbook theoretical computer science b formal sematics
pp elsevier mit press
muise c j mcilraith beck j c improved non deterministic
exploiting state relevance bonet b mccluskey l silva j r williams b eds
proceedings nd international conference automated scheduling
icaps aaai press
nakhost h hoffmann j muller resource constrained monte carlo
random walk bonet b mccluskey l silva j r williams b eds
proceedings nd international conference automated scheduling
icaps pp aaai press
nilsson n j solving methods artificial intelligence mcgraw hill
nissim r hoffmann j helmert computing perfect heuristics polynomial time
bisimulation merge shrink abstraction optimal walsh ed
proceedings nd international joint conference artificial intelligence ijcai
pp aaai press ijcai
pommerening f helmert optimal delete free tasks incremental
lm cut bonet b mccluskey l silva j r williams b eds proceedings
nd international conference automated scheduling icaps aaai
press
richter helmert preferred operators deferred evaluation satisficing gerevini howe cesta refanidis eds proceedings th
international conference automated scheduling icaps pp
aaai press


fis teinmetz h offmann b uffet

sanner relational dynamic influence diagram language rddl language description
available http users cecs anu edu au ssanner ippc rddl
pdf
santana p thibaux williams b rao chance constrained
pomdps schuurmans wellman eds proceedings th aaai conference artificial intelligence aaai pp aaai press
sarraute c buffet hoffmann j pomdps make better hackers accounting
uncertainty penetration testing hoffmann j selman b eds proceedings
th aaai conference artificial intelligence aaai pp toronto
canada aaai press
seipp j helmert counterexample guided cartesian abstraction refinement
borrajo fratini kambhampati oddi eds proceedings rd international conference automated scheduling icaps pp
rome italy aaai press
seipp j helmert diverse additive cartesian abstraction heuristics chien
fern ruml w eds proceedings th international conference
automated scheduling icaps aaai press
smith simmons r g focused real time dynamic programming mdps squeezing heuristic gil mooney r j eds proceedings st
national conference american association artificial intelligence aaai pp
boston massachusetts usa aaai press
steinmetz hoffmann j buffet revisiting goal probability analysis probabilistic coles coles edelkamp magazzeni sanner eds
proceedings th international conference automated scheduling
icaps aaai press
tarjan r e depth first search linear graph siam journal computing

teichteil konigsbuch f stochastic safest shortest path hoffmann j
selman b eds proceedings th aaai conference artificial intelligence
aaai toronto canada aaai press
teichteil konigsbuch f kuter u infantes g incremental plan aggregation generating policies mdps van der hoek w kaminka g lesperance luck
sen eds proceedings th international conference autonomous agents
multiagent systems aamas pp ifaamas
teichteil konigsbuch f vidal v infantes g extending classical heuristics
probabilistic dead ends burgard w roth eds proceedings
th national conference american association artificial intelligence aaai
san francisco ca usa aaai press
torralba hoffmann j simulation admissible dominance pruning yang
q ed proceedings th international joint conference artificial intelligence
ijcai pp aaai press ijcai


fig oal p robability nalysis p robabilistic p lanning

yoon w fern givan r replan baseline probabilistic
boddy fox thiebaux eds proceedings th international conference
automated scheduling icaps pp providence rhode island
usa morgan kaufmann
younes h l littman l weissman asmuth j first probabilistic track
international competition journal artificial intelligence





