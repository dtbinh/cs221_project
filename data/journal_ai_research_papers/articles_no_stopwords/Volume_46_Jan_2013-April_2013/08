journal artificial intelligence

submitted published

boolean equi propagation concise efficient sat
encodings combinatorial
amit metodi
michael codish

amit metodi gmail com
mcodish cs bgu ac il

department computer science
ben gurion university negev israel

peter j stuckey

pjs csse unimelb edu au

department computer science software engineering
nicta victoria laboratory
university melbourne australia

abstract
present propagation sat encoding combinatorial boolean equi propagation constraints modeled boolean functions
propagate information equalities boolean literals information
applied simplify cnf encoding constraints key factor considering
small fragment constraint model one time enables us apply stronger
even complete reasoning detect equivalent literals fragment detected
equivalences apply simplify entire constraint model facilitate reasoning
fragments equi propagation combination partial evaluation constraint simplification provide foundation powerful sat finite
domain constraint solving introduce tool called bee ben gurion equi propagation
encoder ideas demonstrate variety benchmarks leads considerable reduction size cnf encodings subsequent
speed ups sat solving times

introduction
recent years boolean sat solving techniques improved dramatically todays sat
solvers considerably faster able manage larger instances yesterdays moreover encoding modeling techniques better understood increasingly innovative
sat currently applied solve wide variety hard practical combinatorial often outperforming dedicated general idea encode typically
np hard instance boolean formula satisfying assignments correspond solutions given encoding sat solver
applied solve
tailgating success sat technology variety tools applied
specify compile instances corresponding sat instances general
objective tools facilitate process providing high level descriptions
constraint hand solved typically constraint modeling
language introduced used model instances drawing analogy programming languages given description compiler provide low level executable
c

ai access foundation rights reserved

fimetodi codish stuckey

underlying machine namely context formula underlying sat
smt solver
example cadoli schaerf introduce np spec logic specification
language allows specifying combinatorial declarative way core
system component translates specifications cnf formula similarly sugar
tamura taga kitagawa banbara sat constraint solver solve
finite domain constraint satisfaction first modeled constraint language
called sugar encoded cnf formula solved minisat
solver een sorensson minizinc nethercote stuckey becket brand duck
tack constraint modeling language compiled variety solvers
low level target language flatzinc exist many solvers particular
flatzinc instances solved fzntini huang encoding cnf
fzn smt encoding smt lib barrett stump tinelli
simplifying cnf formulae prior application sat solving utmost
importance wide range techniques applied achieve
goal see example work li een biere heule jarvisalo
biere manthey references therein work
techniques exhibit clear trade amount simplification obtained
time requires moreover stronger techniques become prohibitive sat model
involves hundreds thousands variables millions clauses cnf simplification
tools time limits simplification techniques imposed approximations used
takes cnf simplification typically cnf random collection clauses rather structure derived application specific
domain sat solving applied encode solve finite domain constraint
original constraint model manifest structure usually constraints discarded encoded cnf advocate maintaining constraints
provides important structural information applied drive process cnf
simplification specific constraints model induce partitioning cnf
encoding conjunction sub formulae call portions
novelty cnf simplification instead considering cnf
whole assume partitioned conjunction smaller portions
simplification repeatedly applied individual portions facilitates propagationbased process simplification one portion propagates information
portions information may trigger simplification portions
portions typically much smaller entire cnf effectively apply
stronger simplification introduce notion equi propagation similar
unit propagation inferring unit clauses applied simplify
cnf formulae equi propagation inferring equational consequences literals
boolean constants
wide body cnf simplification applied implement
equi propagation sometimes called equivalent literal substitution example
gelder techniques typically involve binary clause simplifications among
others hyper binary resolution binary implication graphs see example work
heule et al references therein guiding principle works


fiboolean equi propagation

techniques must simple efficient prohibitive size cnf
must apply
different focus far richer forms inference even related
cnf structure formula one extreme apply complete equi propagation
detects equivalences implied formula clearly complete equi propagation
np hard however complete equi propagators feasible apply small
portions formula complete equi propagation slow consider ad hoc
techniques forms equi propagation common driven
cnf structure e g binary clauses rather underlying constraint structure
cnf generated
rest structured follows section introduces modeling language
finite domain constraints consists constraint constructs sufficient
illustrate contribution argue constraints model induce
natural partition cnf encoding smaller portions partition
used drive simplification cnf encoding section presents equi propagation
first ingredient contribution equi propagation learning information apply simplify cnf encodings section describes practical basis
implementing equi propagation section introduces second ingredient partial evaluation given information derived equi propagation partial evaluation applies
simplify constraints particular remove boolean variables cnf
encodings section describes tool called bee metodi codish ben gurion
equi propagation encoder equi propagation partial evaluation
introduce full constraint language similar sugar subset
flatzinc relevant finite domain constraint spell special
treatment different constraint bee section demonstrates application
bee section presents experimental evaluation finally section presents
conclusion
extends earlier work presented metodi codish lagoon stuckey
first introduced equi propagation bee tool metodi
codish bee tool available download metodi

constraint boolean modeling
section provides basis contribution constraint modeling language
together boolean interpretation constraint language enables us
view constraint model conjunction boolean formulae provides structure
drives subsequent encoding cnf
first introduce simple small fragment typical finite domain constraint
modeling language serves illustrate later section
full language discuss several options boolean representation integers
adopt particular unary representation called order encoding
contribution independent choice although equi propagation works well
finally finish section constraints language fragment
viewed boolean formula constraint model conjunction


fimetodi codish stuckey







int c c
int neq
alldiff
int plus
int array plus

c c

v
j ii ij



figure core constraint language
constraint language fragment
focus small fragment typical constraint modeling language detailed figure
serves present main ideas constraint declaring finite
domain integer variables range c c simplicity presentation
assume c constraints difference integer variables
constraints sums integer variables syntactic sugar allow
writing integer constants constraints example int neq short
int int neq
modeling kakuro example
kakuro puzzle n board black white cells black cells contain hints
white cells filled numbers bound often
generalized larger value r hints specify constraints sums values
blocks white cells right hint numbers assigned white
cells block required different figure illustrates kakuro
puzzle left solution right
model kakuro puzzle view set blocks white cells block
b set integer variables associated corresponding integer value hint b
block b associated two constraints integers b must sum hint b
must different figure illustrates constraints corresponding kakuro
instance figure
representing integers
fundamental design choice encoding finite domain constraints concerns representation integer variables gavanelli surveys several possible choices

figure kakuro puzzle right solution left


fiboolean equi propagation









int
int
int
int
int
int
int

int
int
int
int
int
int

array
array
array
array
array
array

plus
plus
plus
plus
plus
plus

alldiff
alldiff
alldiff
alldiff
alldiff
alldiff

figure constraints kakuro instance figure

direct support log encodings introduces log support encoding given choice
representation constraints bit blasted interpreted boolean formulae focus
use unary representation called order encoding see e g crawford
baker bailleux boufkhad many nice properties applied
small finite domains
order encoding integer variable x domain n represented
bit vector x x xn bit xi interpreted x particular bit
sequence x constitutes monotonic non increasing boolean sequence example
value interval represented bits
important property boolean representation finite domain integers
ability represent changes set values variable take well known
order encoding facilitates propagation bounds consider integer variable
x x xn values interval n restrict x take values range
b b n sufficient assign xa xb b n
variables xa xb b b n determined true false
respectively unit propagation example given x x x assigning x
x propagates give x x x signifying dom x
observe additional property order encoding x x xn ability
specify variable cannot take specific value v n domain equating
two variables xv xv indicates order encoding well suited
propagate lower upper bounds represent integer variables arbitrary
finite set domain example given x x x equating x x imposes
x likewise x x x x impose x x applying
equalities x gives x x x x x x x x x x note repeated literals
signifying dom x
order encoding many additional nice features exploited simplify
constraints encodings cnf illustrate one consider constraint form
b b integer values range represented
order encoding bit level order encoding
b b b constraint satisfied precisely b instead
encoding constraint cnf substitute bits b b literals
remove constraint section formalize process discovering equalities
literals implied constraint simplify cnf encodings


fimetodi codish stuckey

bit blasting
given constraint model decision represent finite domain integer variables
bit level chose order encoding bit blasting process instantiating integer variables corresponding bit vectors interpreting constraints boolean
formulae
integer variable declared constraint form int c c
c c represented bit vector xc xc may view
constraint model consisting boolean variables constraint c corresponds
boolean formula denoted c bit blasted version c specific definition
important illustration note one could define

int c c
xi xi
c c

xc xc well
int neq

n


xi xor yi



simplify presentation assume x xn yn
represented number bits mapping extends natural way apply
conjunctions constraints given constraint model one figure
integer variables instantiated unary order encoding bit vectors constraint
viewed boolean formula constraint model takes boolean representation
conjunction formulae

boolean equi propagation
section present propagation sat encoding boolean equipropagation propagates information equalities boolean literals
constants prove boolean equi propagation stronger unit propagation
determines least many fixed literals unit propagation demonstrate
example power equi propagation leads considerable reduction
size cnf encoding
boolean equi propagation
let b set boolean variables literal boolean variable b b negation
b negation literal denoted defined b b b b
boolean constants represent true false respectively set literals
denoted l l l set free boolean variables appear
boolean formula denoted vars extend vars function sets formulae
natural way
assignment partial mapping
boolean
constants often


variables


viewed following set literals b b b b formula
b b denote b likewise b formula obtained substituting


fiboolean equi propagation

occurrences b b true false notation extends natural way
sets literals say satisfies vars vars evaluates true
boolean satisfiability sat consists boolean formula determines
exists assignment satisfies
boolean equality constraint l equi formula e set
boolean equalities understood conjunction set boolean equalities denoted
leq
set equi formulae denoted e
example suppose b x z l x x z x example
assignment x z b x z assignment since includes
given formula x z x formula z
equivalently z formula equivalent true
satisfy since vars x z x z vars example equi formula b
x z equivalently x z
equi propagation
process inferring equational consequences boolean formula given equational information equi propagator formula extensive function e e
defined e e

n


e e e leq
e e
conjunction equalities least strong
true e say
n e made
eq fifi
equi propagator complete e e l e e denote
complete equi propagator assume equi propagators monotonic
e e e e particular follows definition complete
equi propagators section discuss several methods implement complete
incomplete equi propagators
example consider constraint
c int x int int neq x
corresponding boolean representation c bit representation
x x x x x
assume setting
e







signifying e e x x indicating x occurs
since e equivalent x x x x x x x x x x
e x x
following theorem states complete equi propagation least powerful
unit propagation


fimetodi codish stuckey

theorem let complete equi propagator boolean formula
literal made true unit propagation clausal representation
equations e determined true e
proof let boolean formula e equi formula let c ce clausal
representations e respectively clearly c e ce let b
positive literal determined unit propagation c ce correctness unit
propagation c ce b hence e b thus e b case
negative literal b except infer b
following example illustrates equi propagation powerful unit
propagation
example consider x x x x x x x clausal
representation x x x x x x x x x unit propagation
possible since unit clauses equi propagation additional equational
information gives x x x
boolean unifiers
sometimes convenient view equi formula e generic solved form boolean
substitution e general unifier equations e boolean substitutions generalize assignments variables bound literals boolean

substitution idempotent mapping b l dom b b b b
finite note particular idempotence implies b b every b b
note defined b domain dom includes elements

non identity
boolean substitution viewed set



b b b dom



apply another substitution obtain substifi

tution b b b dom dom unifier equi formula e
substitution e e e general unifier e
substitution unifier e exists substitution
example consider equi formula e b b b b b b b b b
b b unifier e b b b b b b b b b b
note e trivially true equi formula b b b b b b b b

consider enumeration l b b b b let total strict
order l b b b b define canonical general
unifier unifye satisfiable equi formula e



unifye b min l e b
substitution unifye maps b smallest literal equivalent b given
e compute unifye almost linear amortized time variation
union tarjan
example equi formula e substitution example
unifye


fiboolean equi propagation

following proposition provides foundation equi propagation boolean
simplification allows us apply equational information simplify given formula
particular e equi formula literals occurring unifye smaller
contains fewer variables
proposition let boolean formula e e satisfiable equi formula
e unifye e
b e satisfiable unifye satisfiable
c satisfying assignment unifye unifye satisfying assignment
e
proof let unifye assume satisfying assignment e
view substitution unifier e hence since general unifier
exists substitution clearly b b variables b range
hence agree variables implies
meaning satisfying assignment e
satisfying assignment e b direction follows
direction c c assume satisfying assignment unifye clearly
unifye satisfies construction unifye satisfies e since unifye e
trivial hence unifye satisfying assignment e
equi propagation process
equi propagation process presented central theme let
n partitioning boolean formula n portions let n corresponding equi propagators take initial e satisfiability determined
follows
long possible select e e update e e
finally equi propagators apply check unifye satisfiable
satisfying assignment unifye unifye satisfying assignment

typically apply equi propagation theme boolean representation
n constraint model c c cn ci require
ci small conjunction constraints typically integer variables referred
ci declared ci sometimes requires duplicating variable
declarations individual constraint c denote c conjunction constraints
including c declarations integer variables refers specifics
declarations clear context
example let c following constraint model

int x int int z
c
int plus x int plus z int neq z





fimetodi codish stuckey

int plus x int plus x int x int
int plus z int plus z int int z
int neq z int neq z int int z
basis equi propagation take int plus x
int plus z int neq z denoting x x x
z z z applying corresponding complete equi propagators
starting e
e e e x x
e e e z z
e e e
point equi propagation applies unifye x x
z z unifye tautology boolean variables
determent equi propagation
following theorem clarifies order equi propagators applied
equi propagation process influence final
theorem equi propagation process confluent
proof let n boolean formula n corresponding equipropagators let e ir ir e js js j
two different applications equi propagation process construction
given equi propagators property e e e e
assume contradiction e e w l g exists e e e
e swap roles e e e e e e let us focus first
step equi propagation process leading e introduced equation e e
introduced e exists e j j j e
e e e e e e monotonicity
e e hence e e contradiction construction
property
following proposition provides alternative efficient implement definition
complete equi propagation
proposition let boolean formula complete equi propagator
define e e
n


unify e
e e e leq
e

e e implements complete equi propagator


fiboolean equi propagation

proof forthefi first direction
definition e e
e e unifye e
proposition e unifye
e e direction let e e e e proof
straightforward otherwise let unifye e assume contrary e e
words e e means exists assignment
satisfies e satisfy e lemma satisfies unifye e
particular satisfies unifye assumption unifye e
satisfies e contradiction
computing considerably efficient since simply examine
formula application unifye determine boolean equality consequences
finally comment intention equi propagation process applied
make sat instance smaller obtain easier solve representation
however decreasing size cnf main objective fact often explicitly
introduce redundancies improve sat encoding example consider thenelse construct xite f propositional variable indicates selector
indicates true branch f indicates false branch x indicates
corresponding cnf x x f x f x een sorensson
propose add redundant clauses f x f x comment
improves encoding observe redundant clauses often introduced
achieve arc consistency sat encoding given clausal encoding
formula application equi propagation strengthen unit propagation
theorem let c set clauses suppose c e e equi formula
unit propagation unifye c least strong unit propagation c
proof unit propagation c starting assignment repeatedly chooses clause
c l c l l c ai sets ai ai l unit propagation terminates
ak clauses occur note failure detected ak contains
literal negation
order unit propagation unifye c determined
occurs c starting assignment b unifye obtain assignment
bi bi unifye ai proof induction unit propagation steps c
base case holds construction
assume c l c l l c ai induction bi unifye ai
unifye l l c unifye l bi case set bi bi
induction holds unifye l bi since c l c unifye l l
c unifye l unifye c hence unit propagation unifye c bi obtain
bi bi unifye l hence induction holds
given unit propagation reaches unique fixpoint unit propagation order
unifye end assignment b b bk unify ak
power equi propagation
illustrate impact equi propagation come back kakuro example
section recall figure fact solving puzzles via sat encodings quite easy
without equi propagation example viewed illustrating


fimetodi codish stuckey



b

c

figure applying complete equi propagation kakuro instance different

impact equi propagation size encoding compare different
give different equi propagation
consider baseline discussion following boolean representation
derived constraint model declarations specified explicitly
form int h h smallest hint block includes
number smaller



int neq ii ij
int array sum b hint b
ik blocks
j k

b blocks

notice one int neq conjunct pair white cells block
one int array sum conjunct block applying equi propagation process
complete equi propagators determines six integer values depicted figure
figure b illustrates impact applying equi propagation process
equi propagators alldiff constraints instead individual int neq constraints determines seven integer variables formalized taking following
boolean representation constraint model introducing equi propagator
conjunct



alldiff b
int array sum b hint b
b blocks

b blocks

figure c illustrates impact applying equi propagation process equipropagators pairs consisting alldiff constraint together corresponding sum constraint form equi propagation powerful fixes integer
values white cells example stress equi propagation reasons
equalities boolean literals constants take model



alldiff b int array sum b hint b
b blocks

demonstrate impact equi propagation table provides data
additional instances categorized easy medium hard first two columns
table indicate instance category id five columns headed integer
instances available http c ucc ie hcambaza page page page html generated helmut
simonis



fihard

medium

easy

boolean equi propagation

id
















integer variables
init bee
init



























average compilation time sec

boolean variables




































bee

















table applying sat complete equi propagation kakuro encoding
variables first four specify number unassigned white cells initial stage
three complete equi propagation processes described five
columns headed boolean variables first four indicate corresponding information
regarding number boolean variables bit representations integers
smaller number table variables removed due equipropagation particular model completely solves instances two
columns titled bee corresponding information obtained weaker form
equi propagation described section last row table indicates
average time takes perform equi propagation seconds three
schemes weaker scheme titled bee come back discuss
later detailing equi propagation performed table indicate
clear benefit performing equi propagation coarser portions model
implementing equi propagators
implement complete equi propagators need infer boolean equalities implied
given boolean formula equi formula e proposition sufficient
test condition
unifye

consider three techniques sat solver bdds ad hoc rules
applied boolean representations individual constraints
straightforward implement complete equi propagator sat solver
test condition consider formula satisfiable
condition holds way condition checked relevant equations


fimetodi codish stuckey

involving variables unifye constants major obstacle satbased testing single equivalence least hard testing
satisfiability fact testing unsatisfiability typically expensive
hence importance assumption small fragment cnf
interest practice sat equi propagation surprisingly fast illustration
last row table average times sat complete equi propagation
different indicated columns interesting observe
strongest technique fastest fewer
larger conjuncts hence fewer queries sat solver
implement complete equi propagator binary decision diagrams bdds
follows construct bdd formula beginning equi propagation
equational information e added e simplify bdd conjoining
bdd bdd e projecting variables longer appear
unifye note simplification increase size bdd practice
rather two steps use restrict operation coudert madre
bdd simplify somenzi create bdd efficiently
given bdd unifye explicitly test condition standard
bdd containment test e g bddleq somenzi sat test performed relevant equations involving variables unifye
constants alternately use method bagnara schachte
extended extract literal equalities opposed variable equalities extract
fixed literals equivalent literal consequences bdd
example consider bdd shown figure represents formula
int int b int neq b figure b depicts bdd
unifye e b b b easy see equipropagation determines let e e figure c shows
simplified bdd unifye
major obstacle bdd concerns size formula
unifye constraints corresponding bdd guaranteed polynomial size constraint following holds arbitrary constraint
holds unifye
proposition let c constraint k integer variables represented n bits
order encoding number nodes bdd representing c bound
nk
proof sketch n legitimate states n bit unary variable
bdd cannot nodes possible states
constraints int int neq int plus involve integer variables
hence bdd complete equi propagators polynomially bounded however
case global constraints alldiff int array plus
arity fixed moreover well known alldiff constraint
polynomial sized bdd bessiere katsirelos narodytska walsh


fiboolean equi propagation











b
b









r rrr
r
r

r r
rr
rrr rrrr

r






b l
b
b
b
llb


l

l


lll


l






l

l
l l l




b
b



































































bdd int nequ b

b simpld wrt b

c simpld wrt

figure bdds int int b int neq b b
unifye e b b b c unifye e
e full dashed lines correspond true false edges edges
false node f omitted brevity

given potential exponential run time performing sat equi propagation
potential exponential size bdd equi propagators consider third
implement equi propagation collection ad hoc transition rules
type constraint complete equations
implied constraint detected implementation fast works well
practice topic next section

ad hoc equi propagation
consider rule define equi propagators definition given
set ad hoc rules specified type constraint novelty
cnf previous works rather driven bit blasted constraints
encoded cnf presentation focuses case finite domain
integers represented order encoding integer x x xn often
write x denote equation xi x denote equation xi x
denote equation xi xi x denote pair equations xi xi
moreover simplify notation specifying rules view x x xn
larger vector padded sentinel cells cells left x take value
cells right xn take value basically facilitates specification
end cases formalism consider constraints
language fragment presented section


fimetodi codish stuckey

c int x xn n
e
add c e
xi x xi
xi xi xn



c int neq x
x x xn yn

e
add c e
x

xi yi yi xi
x
xi yi yi xi
x
b

figure ad hoc rules int b int neq
c int plus x z x x xn
ym z z zn

c alldiff z z z zn
e
add c e
z z j

z
z zk
zk
j k

e
x j
x j
z k x
z k x
x
z k



add c e
z j
z j
ki
ki
zi zi ym
x yk xk
b

figure ad hoc rules alldiff b int plus

two rules figure derive monotonicity order encoding
representation basically correspond unit propagation constraint level
first rule figure b considers cases x constant symmetric
case handled exchanging x two rules capture templates
commonly arise equi propagation process illustrate justification
third rule consider possible truth values variables xi xi xi
xi integers relation take form violating
specification ordered possible b xi xi
numbers take form equal violating neq constraint
possible bindings xi xi xi xi
figure illustrate single rule alldiff constraint considers
hall sets size zi represents integer order encoding focus
case z z restricted equations e take two possible
values j expressed e x xn j j means
xk k xk xk k j xk j k n z z
means adding single equation xi yi z z take two values
addition rule apply rules int neq zi zj pair integers zi
zj constraint


fiboolean equi propagation




z z
e
z z
x x x x x x

z
e e
x x x x x x

z
e e x x
x x x

z

x
x


int neq

z x


int plus

z


int plus

z


int plus

e e
x x x x x x

z

e e x
x x x x x

z

e e x x
x x x x x
x x x x
z




int

x


int



e e x x
x x x x x
x x x x
z

figure ad hoc equi propagation described example
first four rules figure b capture standard propagation behavior
interval arithmetics last two rules apply one integers relation
constant symmetric cases replacing role x
special ad hoc rules equi propagation int array plus constraint simply viewed decomposition set int plus constraints
simplification performed level rules int plus decomposition
int array plus explained section
example ad hoc equi propagation consider following partial constraint model
context kakuro example section represent variables x
z x x x z z z assume previous equi propagation constraints determined current equi formula e
specify integer variable z

c

int x int int z
int plus x z int neq x



figure illustrates step step equi propagation process c ad hoc rules
defined step corresponds application one defined ad hoc
equi propagation rules indicated label transition stage illustrate
derived equations top part application unifier state variables
x z lower part


fimetodi codish stuckey

c ordered x xn int

replace
n
true
x
ordered x xn
xn
ordered x xn
xn

xi xi ordered x xi
xi
figure simplification rules int crossed elements removed
summarize let us come back table numbers presented two columns
headed bee specify number variables remaining application ad hoc equipropagation observe definition ad hoc equi propagation trivially
monotonic

constraint model partial evaluation
partial evaluation together equi propagation second important component
compile constraint cnf partial evaluation simplifying given constraint model view information becomes available due equipropagation typically constraint simplification process apply alternating steps
equi propagation partial evaluation examples partial evaluation include constant
elimination removing constraints tautologies section detail
partial evaluation rules apply five constraint types defined language
fragment presented section
int c c constraint specifies integer x xn represented
order encoding particular corresponding bit sequence sorted
increasing denote ordered x xn partial evaluation focuses
aspect constraint ignores bounds c c specified constraint table
figure specifies four simplification rules apply first rule identifies tautologies
second third rules remove leading ones trailing zeros fourth removes
one two equated bits figure subsequent crossed element
sequence indicates removed sequence
simplification rules int neq constraint shown figure symmetric
exchanging role x first two rules identify tautologies third
rule x equal bit position corresponding bits
removed representation x resulting shorter list bits
representations last two rules removing leading ones trailing zeroes
illustrated following example
example figure b shows two steps partial evaluation int neq constraint
first removing leading ones removing trailing zeroes



fiboolean equi propagation

c int neq x
x x xn yn

replace
x
true
xi yi
true
int neq
x
x
xi yi
xn
yi yn

int neq xi xn
xi
yi yi yn
int neq x xi
xi
yi yi




int neq
x x p e

int neq



int neq
x x p e

int neq



int neq
x x




b

figure simplification rules int neq b example application
c alldiff z zn
zi zi zi n

replace
n
true
dom z
alldiff z zn
dom zk
k

dom zi
alldiff z zn



k

zk

alldiff
z
z
z

zn
zn
zn

figure simplification rules alldiff

four rules simplifying alldiff constraints illustrated figure first
detecting tautologies second identifies cases one integers
constraint assume z domain disjoint others rule captures
case z constant third rule removes hall set size assume z z
constraint note corresponding equi propagation rule detects
values z zn different values z z next fourth rule
applies fourth rule case none integers constraint take
certain value rule captures case numbers leading
ones trailing zeroes last two rules illustrated example
simplification rules shown figure symmetric exchanging
role x first two apply least one x z constant
already applied equi propagation constraint tautology see
example last two rules apply remove leading ones trailing zeroes


fimetodi codish stuckey

c int plus x z x x xn
ym z z zn

replace
x
true
z k
true
int plus xi xn
x z
zi zn
int plus x xi
x z
z zi

figure simplification rules int plus
int plus k
b alldiff
c int array plus k
figure constraint model examples
simplification rules int array plus constraint straightforward generalizations
ones int plus see example
summarise rule apply equi propagation partial evaluation
present following sequence three examples focus simplification
three constraints given figure integer variables defined
range k
example consider equi propagation constraint figure e specifies
k




k k
k k


k
z













k
z
e e

e

k


int plus



given e constraint tautology removed partial evaluation



int plus

p e




int plus




example consider equi propagation constraint b figure given e
example
e







int neq



e e



fiboolean equi propagation

given e equi propagation rule alldiff detects hall set
two variables take values adds e set equations e specify
e e e step gives
following bindings impact e underlined




















given e partial evaluation constraint first removes hall set
p e

alldiff alldiff
alldiff

applies remove three redundant bits underlying representation
remaining integer equal











alldiff















p e

alldifferent














alldiff


















example consider equi propagation constraint c figure given e
example rules apply derive decomposition int array plus
constraint int plus parts dictate
e











int array
plus

e





e





applying partial evaluation simplifies constraint follows







int array plus











p e


int array
plus








int array plus












summarize examples observe initial constraint model constraints
integers represented bits constraint simplification constraints
remain integers represented bits





















fimetodi codish stuckey

compiling constraints bee
bee ben gurion equi propagation encoder tool applies encode finite domain
constraint cnf bee first introduced metodi codish
encoding process bee performs optimizations equi propagation partial
evaluation improve quality target cnf bee implemented swi prolog
applied conjunction cryptominisat solver soos
prolog interface codish lagoon stuckey cryptominisat offers direct support
xor clauses bee takes advantage feature bee downloaded metodi
one examples others
source language bee compiler called bee constraint modeling
language similar flatzinc nethercote et al focus subset
language relevant finite domain constraint five constraint constructs
bee language introduced section full language presented
table
bee boolean constants true false viewed integer values
constraints represented list prolog terms boolean integer variables
represented prolog variables may instantiated simplifying constraints
table x xs possibly subscripts denote literal boolean variable
negation vector literals possibly subscript denotes integer variable
c possibly subscript denotes integer constant right column
table brief explanations regarding constraints table introduces constraint
templates
constraints variable declarations booleans integers constraint
expresses boolean integer value constraints boolean reified
boolean statements special cases constraint bool array x xn
bool array xor x xn facilitate specification clauses xor clauses
supported directly cryptominisat solver soos constraint specifies
sorting bit pair x x decreasing order pair x x basic
building block construction sorting networks batcher used encode cardinality linear boolean constraints compilation described asn nieuwenhuis
oliveras rodrguez carbonell codish zazon ivry constraints integer relations operations constraints
linear boolean pseudo boolean integer operations constraints
lexical orderings boolean integer arrays
main design choice bee integer variables represented orderencoding bee suitable integer variables take small
medium sized values compilation constraint model cnf bee goes
three phases
unary bit blasting integer variables constants represented bit vectors
order encoding
constraint simplification three types actions applied equi propagation partial
evaluation decomposition constraints simplification applied repeatedly
rule applicable


fiboolean equi propagation

declaring variables




declare boolean x
declare integer c c
x x

bool x
int c c
bool int x

op xor iff

boolean reified statements






bool eq x x bool eq x x
bool array op x xn
bool array op reif x xn x
bool op reif x x x
comparator x x x x

x x x x
x op x op xn
x op x op xn x
x op x x
sort x x x x

integer relations reified
rel leq geq eq lt gt neq
arithmetic
op plus times div mod max min op plus times max min







int
int
int
int
int
int

rel
rel reif x
array alldiff
abs
op
array op

rel

v rel x
j ii ij

op
op op

linear constraints







rel leq geq eq lt gt

bool array sum rel x xn
bool array pb rel c cn x xn
bool array sum modk x xn c
int array sum rel
int array lin rel c cn
int array sum modk c

xi rel
ci xi rel
xi mod c
ii rel
ci ii rel
ii mod c

lexical order







bool arrays lex xs xs
bool arrays lexlt xs xs
bool arrays lex reif xs xs x
bool arrays lexlt reif xs xs x
int arrays lex
int arrays lexlt

xs precedes leq xs lex order
xs precedes lt xs lex order
x xs precedes leq xs lex order
x xs precedes lt xs lex order
precedes leq lex order
precedes lt lex order

table syntax bee constraints
cnf encoding best suited encoding technique applied simplified constraints
bit blasting equi propagation bee follow general descriptions sections bit blasting implemented prolog unification declaration form int c c triggers unification xc xc
ease presentation assume integer variables represented positive interval
starting limitation practice bee supports negatives
integers bee applies ad hoc equi propagators described section equality
form x l variable literal constant detected equipropagation implemented unifying x l unification applies occurrences
x sense propagates constraints involving x
decomposition replacing complex constraints example arrays
simpler constraints example array elements consider instance constraint int array plus sum decomposed list int plus constraints applying
straightforward divide conquer recursive definition base case


fimetodi codish stuckey

c alldiff z z z zn
e
add c e
dom z

dom zk k

z authors

j dom zk
k

dom z j
dom z j
z z
zk zk j
k

figure simplification rules alldiff
constraint replaced constraint form int eq sum equates bits
sum replaced int plus sum general
case split two halves constraints generated sum halves
additional int plus constraint introduced sum two sums
another example consider int plus constraint one supported bee decomposes constraint odd even merger context
odd even sorting networks batcher sorted sequences bits
merged obtain sum model n log n comparator
constraints later encoding n log n clauses another
supported bee decompose constraint encodes directly cnf
size n context called totalizers bailleux boufkhad hybrid
leaves choice bee depending size domains variables
involved finally note user configure bee fix way compiles
constraint others
cnf encoding last phase compilation constraint model
remaining simplified bit blasted constraints encoded directly cnf encodings
standard similar applied tools bee encodings similar
applied sugar tamura et al
different constraint bee
different constraint specifies set integer variables take different values
specified domains constraint received much attention literature
see example survey van hoeve bee provides special treatment
constraint
many applications different constraints applied model special case
constraint permutation namely different may
take precisely n different values bee identifies special case applies two additional
ad hoc equi propagation rules case table figure illustrates rules
annotate constraint emphasize detected
permutation first rule case one integer assume z
take value second rule case variables except two assume z
z cannot take two values assume j constraint permutation


fiboolean equi propagation

determine z z must take two values j illustrate second
rule consider following example
example consider constraint alldiff integer variables taking values interval exactly values e specifies cannot take
values therefore introduce equations restrict take
values corresponding ad hoc rule permutation applies
e








x x
x x



x x
x x
x x
x x
x x
x x

dom ik
k




alldiff

e








x x
x x
e


x x
x
x
x x
x x
x x

facilitate implementation ad hoc equi propagation different constraints
bee adopts dual representation integer variables occurring constraints combining order encoding called direct encoding essentially
encoding proposed gent nightingale declaring integer variable bit blast order encoding applies corresponding unification
x xn encountering alldiff constraint additional bit blast
introduces dn direct encoding channeling formula channel
introduced
direct encoding unary representation dn bit di true
exactly one bits takes value true example value
interval represented bits dual representation
following channeling formula captures relation two representations
integer variable x xn dn

channel x xn dn

x
dn xn




n


di xi xi



consider alldiff constraint integer variables take different values n constraint simplification alldiff im constraint
viewed direct encoding bit matrix row consists bits
di din ii direct encoding element dij true iff ii takes value j
j th column specifies ii take value j hence one variable
column may take value true representation one main advantage
direct encoding decompose alldiff im conjunction n constraints one column j n form bool array sum leq j dmj
arc consistent soon di j ii j di j ii j

j j contrast
order encoding alone decomposition constraints
int neq ii ij j
arc consistent illustrate advantage dual
encoding alldiff constraint section


fimetodi codish stuckey

use module bee compiler bcompile
use module sat solver sat
solve instance solution encode instance map constraints
bcompile constraints cnf
sat cnf
decode map solution

figure generic application bee

bee
typical bee application form depicted figure predicate solve
takes instance provides solution specifics application
call encode given instance generates constraints solve
together map relating instance variables constraint variables calls
bcompile sat compile constraints cnf solve applying sat solver
instance solution sat solver binds constraint variables accordingly
call decode map provides solution terms instance
variables definitions encode decode application dependent provided user predicates bcompile sat part tool provide
interface bee underlying sat solver
example bee application magic graph labeling
illustrate application bee prolog modeling language solve graph
labeling graph labeling finding assignment integers vertices
edges graph subject certain conditions graph labellings introduced
hundreds papers wide variety related published
since see example survey gallian references
graph labellings many applications instance radars x ray crystallography
coding theory etc
focus vertex magic total labeling vmtl one
graph g v e labeling one one map v e v
e property sum labels vertex incident edges
constant k independent choice vertex instance takes form
vmtl g k specifying graph g constant k context figure
query solve vmtl g k solution poses question exist vmtl labeling
g magic constant k binds solution indicate labeling one exists
unsat otherwise figure illustrates example instance together
solution
figure illustrates prolog program implements encode predicate
vmtl call predicate declareints introduces constraints
declare integer variables vertex edge graph generates
map call predicate sumtok introduces constraints require sum
labels vertex incident edges equals k auxiliary predicate


fiboolean equi propagation

instance
instance vmtl g k
g v e
v
e

k

graph









solution




v
v

v
v






e
e
e
e








figure vmtl instance solution
encode vmtl vs es k map constraints append vs es ves length ves n
declareints ves n map constraints cs
sumtok vs es map k cs cs
getvars ves map vars
cs int array alldiff vars
declareints cs cs
declareints id ids n id x map int x n csh cst declareints ids n map csh cst
sumtok cs cs
sumtok vid vs es map k int array plus vars k csh cst findall x member x es x vid vid esids
getvars vid esids map vars
sumtok vs es map k csh cst
getvars
getvars id ids map var vars member id var map
getvars ids map vars

figure encode predicate vmtl application bee
map
e v
e v
e v
e v

constraints
int v int e int array plus v e e k
int v int e int array plus v e e k
int v int e int array plus v e e e k
int v int e int array plus v e k
int k alldiff v v v v e e e e

figure vmtl instance constraints map generated encode

getvars receives list identifiers vertices edges extracts corresponding
list integer variables map
given vmtl instance figure call predicate encode figure
generates map constraints detailed figure


fimetodi codish stuckey

solving constraints figure binds map follows indicating solution
unary order encoding

























bee compile constraints figure generates cnf contains
clauses boolean variables encoding set constraints without applying
simplification rules generates larger cnf contains clauses boolean
variables
section report bee enables us solve interesting instances
vmtl previously solvable techniques
bumblebee
bee distribution includes command line solver call bumblebee
bumblebee enables one specify bee model input file line contains
single constraint model last line specifies type goal bumblebee
reads input file compiles constraint model cnf solves cnf
embedded cryptominisat solver soos outputs set bindings declared
variables model message indicating constraints satisfiable
figure contains left bumblebee input file vmtl instance
figure right bumblebee output solution constraint
model example last line input file specifies goal solver
options
solve satisfy solve single satisfying assignment constraint model
solve satisfy c solve c satisfying assignments constraint model
c integer value c option solve solutions
solve minimize solve solution minimizes value integer
variable solver outputs intermediate solutions decreasing values
encountered search minimum value
solve maximize similar minimize maximizes
details examples found bee distribution metodi codish


experiments
report experience applying bee appreciate ease use reader
encouraged view example encodings available tool metodi codish
experiments run intel core duo e ghz cpu gb memory
linux ubuntu lucid kernel generic bee written prolog run


fiboolean equi propagation

content bumblebee input file
int v
int v
int v
int v
int e
int e
int e
int e
int array plus v e e
int array plus v e e
int array plus v e e e
int array plus v e
int array alldiff v v v v e e e e
solve satisfy

bumblebee output

v
v
v
v
e
e
e
e



figure solving vmtl instance bumblebee

swi prolog v bits comparisons sugar v use
identical constraint apply sat solver cryptominisat v run
machine times reported seconds
quasigroup completion
quasigroup completion qcp proposed gomes selman crato
constraint satisfaction benchmark given n n board integer variables
range n assigned integer values task assign values
variables column row contains value twice constraint model
conjunction alldiff constraints ansotegui del val dotu fernandez manya
argue advantage direct encoding qcp
consider instances csp competition table considers three
settings bee dual encoding alldiff constraints bee order
encoding equivalent int neq constraints instead alldiff sugar
table shows instance identifier sat unsat compilation time comp seconds
clauses encoding clauses variables encoding vars sat solving time
sat seconds
indicate application bee dual representation
alldiff times faster produces times fewer clauses average
order encoding alone despite need maintain two encodings without
dual representation solving encodings generated bee slightly faster
sugar bee still generates cnf encodings times smaller average
generated sugar observe instances found unsatisfiable bee indicated
http www cril univ artois fr cpai competition instances specified binary disequalities use model alldiff



fimetodi codish stuckey

instance

sat
sat
sat
sat
sat
sat
sat
sat
sat
sat
unsat
unsat
unsat
unsat
unsat
total

bee dual
comp clauses
sec



















encoding
vars
sat
sec
































bee order
comp clauses
sec
















encoding
vars
sat
sec
































clauses

sugar
vars

































sat
sec

















table qcp instances holes
cnf single clause variables comment sugar pre processing
times higher bee indicated table
word design dna
csplib seeks largest parameter n exists
set n eight letter words alphabet c g following
properties word exactly symbols c g pair
distinct words differ least positions every x xr reverse
x c word obtained replacing c g vice versa
differ least positions
mancini micaletto patrizi cadoli provide comparison several stateof art solvers applied dna word variety encoding techniques
best reported solution dna words obtained seconds
opl van hentenryck model lexicographic order break symmetry frutos
liu thiel sanner condon smith corn present strategy solve
four letters modeled bit pairs eight letter word
viewed combination part bit vector part
bit vector authors report solution composed two pairs
part part sets
forms set dna words marc van dongen
reports larger solution words
building described frutos et al pose conditions sets
parts parts cartesian product
satisfy requirements original three conditions
required satisfy required satisfy set
notions part part slightly different
see http www cs st andrews ac uk ianm csplib



fiboolean equi propagation

bit vectors v conditions bit vector v sums pair
distinct bit vectors v differ least positions pair bit vectors
necessarily distinct u v v ur reverse u v c complement v
differ least positions equivalent requiring ur c differs v
least positions
strategy model bee encoding instance takes form
dna n n signifying numbers bit vectors n n sets without
loss generality impose remove symmetries lexicographically
ordered solution cartesian product
bee fraction second sets parts size parts
size provides solution size dna word running
comet v word solution seconds model hakan
kjellerstrand bee prove exist set parts
seconds set parts seconds facts unknown prior bee
proving solution dna word words
without restriction two part strategy still open
vertex magic total labeling
macdougall miller slamin wallis conjecture n vertex complete graph
kn n vertex magic total labeling magic constants specific range
values k determined n conjecture proved correct odd n verified
brute force n address cases n n involve instances
different values k n different values k n starting
simple constraint model illustrated example figure add additional
constraints exploit fact graphs symmetric assume edge
smallest label e assume labels edges incident v
ordered hence introduce constraints e e e n assume
label edge e smaller labels edges incident v except e
introduce constraints accordingly setting bee solve except instances
hour timeout sugar solve except
table gives hardest instances k hardest instances k
hour time bee compilation times order sec instance k
sec instance k sugar encoding times slightly larger instances
indicated magic constant k columns bee sugar indicate sat solving
times seconds bottom two lines indicate average encoding sizes numbers clauses
variables
indicate sugar encodings average larger
average sat solving time bee encodings times faster average excluding instances sugar times
address two vmtl instances solvable bee described
k magic labels partition fixing values e
e maintaining constraints analysis symmetry breaking
constraints indicates instances two cases
see http www hakank org comet word design dna co



fimetodi codish stuckey

instance
bee
k
k
sat sec




















average cnf size
clauses

vars


sugar
sat sec











instance
bee
k
k
sat sec








































average cnf size
clauses

vars





sugar
sat sec























table vmtl k k hour timeout

original vmtl instance solved one instances solved solve
parallel fixing e e fuels compiler encodings considerably
smaller instance k solved seconds e e
compilation time seconds encoding consists million clauses
thousand variables
best knowledge hard instances suite beyond reach
previous approaches program search magic labels sat
presented jager cannot handle comparison sugar indicates
impact compiler
balanced incomplete block designs
csplib bibd instance defined tuple positive
integers v b r k requires partition v distinct objects b blocks
block contains k different objects exactly r objects occur block every two
distinct objects occur exactly blocks
personal communication gerold jager march



fiboolean equi propagation

figure bibd symmetry breaking
naive model bibd instance v b r k introduces following constraints
v b boolean incidence matrix exactly r ones row exactly k ones
column exactly ones scalar product two different rows
model contain sufficient degree information trigger equipropagation process order take advantage bee simplifications added
symmetry breaking described frisch jefferson miguel illustrated
figure row viewed sequence four parts sizes r
r b r first row fixed assigning parts b ones
marked black parts c zeros marked white second row
fixed assign parts c ones marked black parts b zeros
marked white third subsequent rows marked gray sum constraints decomposed summing part summing
follows b c c r b r ensures
row contains exactly r ones scalar product first second row
denote constraint model symb symmetry breaking
instance
v b r k











total sec

comp
sec












bee symb
clauses
sat
sec























sugar symb
comp
clauses
sat
sec
sec






























satelite symb
comp
clauses sat
sec
sec
























table bibd sec timeout
table shows comparing bee compilation time clauses encoding sat
solving time sugar symb model compare bee satelite een


fimetodi codish stuckey

biere cnf minimizer input satelite cnf encoding
symb model generated bee without applying simplifications compilation
time comp indicates satelite pre processing time final row indicates total
compilation sat solving time entire suite cases
time measured seconds
experiment indicates bee generates significantly smaller cnf sugar
affects sat solving time moreover sugar compilation time extremely
long comparing bee satelite see output cnf
similar size satelite applied entire cnf instances
compilation time significantly longer solving time
instance
v b r k











total

bee symb
comp
sat





































minion
symb













symb













table bibd comparison minion times seconds sec timeout
table shows comparing bee symb model minion constraint
solver gent jefferson miguel consider three different minion
indicates bibd model described gent et al symb uses
model use sat symb enhanced symmetry breaking
model tricks applied model columns
timeouts total times bee includes compile time sat solving note
clever modeling improved previous run times
minion
experiment indicates bee significantly faster minion bibd
tailoring symb model minion becomes competitive

combining bee satelite
demonstrate impact combining bee satelite describe experiments involving two benchmarks satelite applied simplify output
bee idea first apply powerful local techniques performed bee
reduces size cnf fast apply satelite takes global
considerations cnf whole wish determine smaller simplified


fiboolean equi propagation

cnf amenable simplification satelite indicate
although cnf size slightly decreased solving times often increased sometimes
drastically
tables tables four columns bee
heading indicate bee compilation time size encoding clauses variables
subsequent sat solving time similarly four columns satelite heading
indicate application satelite output bee satelite processing time
size resulting cnf clauses variables subsequent sat solving time
table illustrates bibd benchmark section table
hardest vmtl instances k k described section observe
applying satelite output bee decreases cnf size slightly
improve sat solving time fact contrary cases renders cnf
takes time solve several cases sat solving time increases drastically
introduce timeout
instance
v b r k












comp
sec












bee
clauses
vars
























sat
sec












comp
sec












satelite
clauses
vars
























sat
sec












table bibd bee combined satelite sec timeout
demonstrate application satelite remove redundancies
cnf often non beneficial presumably difference see application
satelite cnf benchmarks fact bee produces highly
optimized cnf output many cnf benchmarks significant inefficiency
original encoding bee removes variable cnf instantiates
variable constant equivalent variable remove
potential propagations encoding captured theorem

conclusion
considerable body work cnf simplification techniques clear trade
amount reduction achieved invested time approaches determine binary clauses implied cnf certainly enough determine boolean
equalities determining binary clauses implied cnf
prohibitive sat model may involve many hundreds thousands variables


fimetodi codish stuckey

instance

k

k






















comp
sec





















bee
clauses
vars










































sat
sec





















comp
sec





















satelite
clauses
vars










































sat
sec





















table vtml bee combined satelite hour timeout

typically implied binary clauses determined visible
unit propagation trade regulated choice techniques applied infer
binary clauses considering power cost see example work een biere
references therein approaches li detect use
boolean equalities run time complementary
beast tamed introducing notion locality
consider full cnf instead maintaining original representation conjunction
constraints viewed boolean formula apply powerful reasoning techniques
separate parts model maintain efficient pre processing
end introduce bee compiler follows encode finite
domain constraints cnf applying optimizations ad hoc equi propagation
partial evaluation rules high level view allows us simplify
aggressively possible cnf representation resulting cnf
significantly smaller resulting straight translation
well understood making cnf smaller ultimate goal often smaller
cnfs harder solve indeed one often introduces redundancies improve sat
encodings removing counterproductive experience bee reduces
size encoding way productive subsequent sat solving
particular removing variables determined compile time definitely
equal definitely different solution


fiboolean equi propagation

bee uses ad hoc equi propagation partial evaluation rules keeps compilation
times typically small measured seconds even instances several millions
cnf clauses reduction sat solving time larger orders magnitude
hence believe boolean equi propagation makes important contribution
encoding csps sat
bee currently tuned represent integers order encoding ongoing work
aims extend bee binary additional number representations mixed radix
bases considered een sorensson codish fekete fuhs
schneider kamp
acknowledgments
thank vitaly lagoon many insightful discussions concerning
nicta funded australian government represented department
broadband communications digital economy australian council ict centre excellence program

references
ansotegui c del val dotu fernandez c manya f modeling choices
quasigroup completion sat vs csp mcguinness l ferguson g eds
aaai pp san jose california usa aaai press mit press
asn r nieuwenhuis r oliveras rodrguez carbonell e cardinality
networks theoretical empirical study constraints
bagnara r schachte p factorizing equivalent variable pairs robddbased implementations pos haeberer ed algebraic methodology
software technology th international conference amast amazonia brasil
january proceedings vol lecture notes computer science pp

bailleux boufkhad efficient cnf encoding boolean cardinality constraints rossi f ed cp vol lncs pp kinsale ireland
springer
barrett c stump tinelli c satisfiability modulo theories library
smt lib www smt lib org
batcher k e sorting networks applications afips spring joint
computing conference vol afips conference proceedings pp atlantic city nj usa thomson book company washington c
bessiere c katsirelos g narodytska n walsh circuit complexity
decompositions global constraints proceedings ijcai pp
cadoli schaerf compiling specifications sat artificial
intelligence


fimetodi codish stuckey

codish fekete fuhs c schneider kamp p optimal base encodings
pseudo boolean constraints abdulla p leino k r eds tacas
vol lecture notes computer science pp springer
codish lagoon v stuckey p j logic programming satisfiability
tplp
codish zazon ivry pairwise cardinality networks clarke e
voronkov eds lpar dakar vol lecture notes computer science
pp springer
coudert madre j c unified framework formal verification
sequential circuits iccad pp
crawford j baker b experimental application satisfiability scheduling hayes roth b korf r e eds
aaai vol pp seattle wa usa aaai press mit press
een n biere effective preprocessing sat variable clause
elimination bacchus f walsh eds sat vol lecture notes
computer science pp springer
een n sorensson n extensible sat solver giunchiglia e tacchella eds sat vol lecture notes computer science pp
springer
een n sorensson n translating pseudo boolean constraints sat jsat

frisch jefferson c miguel symmetry breaking prelude implied
constraints constraint modeling pattern proc th euro conf ai
pp press
frutos g liu q thiel j sanner w condon e smith l
corn r demonstration word design strategy dna computing
surfaces journal nucleic acids
gallian j dynamic survey graph labeling electronic journal
combinatorics
gavanelli log support encoding csp sat bessiere c ed
cp vol lncs pp providence ri usa springer
gelder v toward leaner binary clause reasoning satisfiability solver ann
math artif intell
gent p jefferson c miguel minion fast scalable constraint solver
brewka g coradeschi perini traverso p eds ecai vol
frontiers artificial intelligence applications pp ios press
gent p nightingale p encoding alldifferent sat proceedings
rd international workshop modeling reformulating constraint satisfaction http www users cs york ac uk frisch reformulation
proceedings pdf


fiboolean equi propagation

gomes c p selman b crato n heavy tailed distributions combinatorial
search smolka g ed cp vol lncs pp springer
heule jarvisalo biere efficient cnf simplification binary
implication graphs sakallah k simon l eds sat vol lecture
notes computer science pp springer
huang j universal booleanization constraint cp vol
lecture notes computer science pp
jager g effective sat encoding magic labeling faigle u schrader r
herrmann eds ctw pp
li c equivalent literal propagation dll procedure discrete applied
mathematics
macdougall j miller slamin wallis w vertex magic total labelings
graphs utilitas mathematica
mancini micaletto patrizi f cadoli evaluating asp commercial
solvers csplib constraints
manthey n coprocessor flexible cnf simplifier tool presentation
cimatti sebastiani r eds sat vol lecture notes computer
science pp springer
metodi bee http amit metodi bee
metodi codish compiling finite domain constraints sat bee
tplp
metodi codish lagoon v stuckey p j boolean equi propagation
optimized sat encoding lee j h ed cp vol lncs pp
springer
nethercote n stuckey p j becket r brand duck g j tack g
minizinc towards standard cp modeling language bessiere c ed cp
vol lecture notes computer science pp providence ri usa
springer verlag
somenzi f cudd colorado university decision diagram package online
accessed april http vlsi colorado edu fabio cudd
soos cryptominisat v http www msoos org cryptominisat
tamura n taga kitagawa banbara compiling finite linear csp
sat constraints
tarjan r efficiency good linear set union jacm

van hentenryck p opl optimization programming language mit press
van hoeve w j alldifferent constraint survey corr http arxiv org
abs cs pl




