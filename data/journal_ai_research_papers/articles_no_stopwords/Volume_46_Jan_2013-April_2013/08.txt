Journal Artificial Intelligence Research 46 (2013) 303341

Submitted 09/12; published 03/13

Boolean Equi-propagation Concise Efficient SAT
Encodings Combinatorial Problems
Amit Metodi
Michael Codish

amit.metodi@gmail.com
mcodish@cs.bgu.ac.il

Department Computer Science
Ben-Gurion University Negev, Israel

Peter J. Stuckey

pjs@csse.unimelb.edu.au

Department Computer Science Software Engineering
NICTA Victoria Laboratory
University Melbourne, Australia

Abstract
present approach propagation-based SAT encoding combinatorial problems, Boolean equi-propagation, constraints modeled Boolean functions
propagate information equalities Boolean literals. information
applied simplify CNF encoding constraints. key factor considering
small fragment constraint model one time enables us apply stronger,
even complete, reasoning detect equivalent literals fragment. detected,
equivalences apply simplify entire constraint model facilitate reasoning
fragments. Equi-propagation combination partial evaluation constraint simplification provide foundation powerful approach SAT-based finite
domain constraint solving. introduce tool called BEE (Ben-Gurion Equi-propagation
Encoder) based ideas demonstrate variety benchmarks approach leads considerable reduction size CNF encodings subsequent
speed-ups SAT solving times.

1. Introduction
recent years, Boolean SAT solving techniques improved dramatically. Todays SAT
solvers considerably faster able manage larger instances yesterdays. Moreover, encoding modeling techniques better understood increasingly innovative.
SAT currently applied solve wide variety hard practical combinatorial problems, often outperforming dedicated algorithms. general idea encode (typically,
NP) hard problem instance, , Boolean formula, , satisfying assignments correspond solutions . Given encoding, SAT solver
applied solve .
Tailgating success SAT technology variety tools applied
specify compile problem instances corresponding SAT instances. general
objective tools facilitate process providing high-level descriptions
(constraint) problem hand solved. Typically, constraint-based modeling
language introduced used model instances. Drawing analogy programming languages, given description, compiler provide low-level executable
c
2013
AI Access Foundation. rights reserved.

fiMetodi, Codish, & Stuckey

underlying machine. Namely, context, formula underlying SAT
SMT solver.
example, Cadoli Schaerf (2005) introduce NP-SPEC, logic-based specification
language allows specifying combinatorial problems declarative way. core
system component translates specifications CNF formula. Similarly Sugar
(Tamura, Taga, Kitagawa, & Banbara, 2009) SAT-based constraint solver. solve
finite domain constraint satisfaction problem first modeled constraint language
(also called Sugar) encoded CNF formula solved using MiniSAT
solver (Een & Sorensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, &
Tack, 2007) constraint modeling language compiled variety solvers
low-level target language FlatZinc exist many solvers. particular,
FlatZinc instances solved fzntini (Huang, 2008) encoding CNF
fzn2smt encoding SMT-LIB (Barrett, Stump, & Tinelli, 2010).
Simplifying CNF formulae prior application SAT solving utmost
importance wide range techniques applied achieve
goal. See example work Li (2003), Een Biere (2005), Heule, Jarvisalo,
Biere (2011), Manthey (2012), references therein work.
techniques exhibit clear trade-off amount simplification obtained
time requires. Moreover, stronger techniques become prohibitive SAT model
involves hundreds thousands variables millions clauses. CNF simplification
tools, time limits simplification techniques imposed and/or approximations used.
paper takes new approach CNF simplification. Typically, CNF random collection clauses, rather structure derived application specific
problem domain. SAT solving applied encode solve finite domain constraint
problems, original constraint model manifest structure. Usually, constraints discarded encoded CNF. advocate maintaining constraints
provides important structural information applied drive process CNF
simplification. specific, constraints model induce partitioning CNF
encoding conjunction sub-formulae call portions.
novelty approach CNF simplification instead considering CNF
whole, assume partitioned conjunction smaller portions.
simplification repeatedly applied individual portions. facilitates propagationbased process simplification one portion propagates information
portions information may trigger simplification portions.
portions typically much smaller entire CNF effectively apply
stronger simplification algorithms. introduce notion equi-propagation. Similar
unit propagation inferring unit clauses applied simplify
CNF formulae, equi-propagation inferring equational consequences literals
(and Boolean constants).
wide body research CNF simplification applied implement
equi-propagation sometimes called equivalent literal substitution, example
Gelder (2005). Techniques typically involve binary clause based simplifications using, among
others, hyper binary resolution binary implication graphs. See example, work
Heule et al. (2011) references therein. guiding principle works
304

fiBoolean Equi-propagation

techniques must simple efficient prohibitive size CNF
must apply.
approach different focus far richer forms inference even related
CNF structure formula. one extreme apply complete equi-propagation
detects equivalences implied formula. Clearly complete equi-propagation
NP-hard. However, complete equi-propagators feasible apply small
portions formula. complete equi-propagation slow consider ad-hoc
techniques. forms equi-propagation common driven
CNF structure (e.g. binary clauses) rather underlying constraint structure
CNF was, being, generated.
rest paper structured follows. Section 2 introduces modeling language
finite domain constraints consists 5 constraint constructs sufficient
illustrate contribution paper. argue constraints model induce
natural partition CNF encoding smaller portions partition
used drive simplification CNF encoding. Section 3 presents equi-propagation
first ingredient contribution. Equi-propagation learning information apply simplify CNF encodings. Section 4 describes practical basis
implementing equi-propagation. Section 5 introduces second ingredient: partial evaluation. Given information derived using equi-propagation, partial evaluation applies
simplify constraints particular remove Boolean variables CNF
encodings. Section 6 describes tool, called BEE (Metodi & Codish, 2012) (Ben-Gurion
Equi-propagation Encoder) based equi-propagation partial evaluation.
introduce full constraint language similar Sugar subset
FlatZinc relevant finite domain constraint problems. spell special
treatment all-different constraint BEE. Section 7 demonstrates application
BEE. Section 8 presents experimental evaluation. Finally Section 9 presents
conclusion.
paper extends earlier work presented Metodi, Codish, Lagoon, Stuckey
(2011), first introduced equi-propagation, BEE tool paper (Metodi &
Codish, 2012). BEE tool available download (Metodi, 2012).

2. Constraint Based Boolean Modeling
section provides basis contribution: constraint-based modeling language,
together Boolean interpretation constraint language. enables us
view constraint model conjunction Boolean formulae provides structure
drives subsequent encoding CNF.
first introduce simple small fragment typical finite domain constraint-based
modeling language. serves illustrate approach. Later, Section 6, show
full language. discuss several options Boolean representation integers.
paper adopt particular unary representation, called order encoding.
contribution independent choice, although equi-propagation works well it.
Finally finish section constraints language fragment
viewed Boolean formula, constraint model conjunction.
305

fiMetodi, Codish, & Stuckey

(1)
(2)
(3)
(4)
(5)

new int(I, c1 , c2 )
int neq(I1 , I2 )
allDiff([I1 , . . . , ])
int plus(I1 , I2 , I)
int array plus([I1 , . . . , ], I)

0 c1 c2
I1 6= I2
V
i<j Ii 6= Ij
I1 + I2 =
I1 + + =

Figure 1: core constraint language
2.1 Constraint Language Fragment
focus small fragment typical constraint modeling language detailed Figure 1.
serves present main ideas paper. Constraint (1) declaring finite
domain integer variables range [c1 ...c2 ]. simplicity presentation
assume c1 0. Constraints (23) difference integer variables,
constraints (45) sums integer variables. syntactic sugar allow
writing integer constants constraints. example, int neq(I, 5) short
new int(I0 , 5, 5), int neq(I, I0 ).
2.2 Modeling Kakuro: Example
Kakuro puzzle n board black white cells. black cells contain hints
white cells filled numbers 1 9 (the bound 9 often
generalized larger value r). hints specify constraints sums values
blocks white cells right and/or hint. numbers assigned white
cells block required different. Figure 2 illustrates 4 4 Kakuro
puzzle (left) solution (right).
model Kakuro puzzle view set blocks (of white cells) block
B set integer variables associated corresponding integer value, hint(B).
block B associated two constraints: integers B must sum hint(B)
must all-different. Figure 3 illustrates constraints corresponding Kakuro
instance Figure 2.
2.3 Representing Integers
fundamental design choice encoding finite domain constraints concerns representation integer variables. Gavanelli (2007) surveys several possible choices (the

Figure 2: 4 4 Kakuro puzzle (right) solution (left).
306

fiBoolean Equi-propagation

new
new
new
new
new
new
new

int(I1 , 1, 9)
int(I2 , 1, 9)
int(I3 , 1, 9)
int(I4 , 1, 9)
int(I5 , 1, 9)
int(I6 , 1, 9)
int(I7 , 1, 9)

int
int
int
int
int
int

array
array
array
array
array
array

plus([I1 , I2 ], 13)
plus([I1 , I3 ], 5)
plus([I3 , I4 , I5 ], 12)
plus([I2 , I4 , I6 ], 19)
plus([I6 , I7 ], 3)
plus([I5 , I7 ], 4)

allDiff([I1 , I2 ])
allDiff([I1 , I3 ])
allDiff([I3 , I4 , I5 ])
allDiff([I2 , I4 , I6 ])
allDiff([I6 , I7 ])
allDiff([I5 , I7 ])

Figure 3: Constraints Kakuro instance Figure 2.

direct-, support- log- encodings) introduces log-support encoding. Given choice
representation constraints bit-blasted interpreted Boolean formulae. focus
use unary representation, so-called, order-encoding (see, e.g. Crawford
& Baker, 1994; Bailleux & Boufkhad, 2003) many nice properties applied
small finite domains.
order-encoding, integer variable X domain [0, . . . , n] represented
bit vector X = [x1 , . . . , xn ]. bit xi interpreted X particular bit
sequence X constitutes monotonic non-increasing Boolean sequence. example,
value 3 interval [0, 5] represented 5 bits [1, 1, 1, 0, 0].
important property Boolean representation finite domain integers
ability represent changes set values variable take. well-known
order-encoding facilitates propagation bounds. Consider integer variable
X = [x1 , . . . , xn ] values interval [0, n]. restrict X take values range
[a, b] (for 1 b n), sufficient assign xa = 1 xb+1 = 0 (if b < n).
variables xa0 xb0 0 a0 > b < b0 n determined true false,
respectively, unit propagation. example, given X = [x1 , . . . , x9 ], assigning x3 = 1
x6 = 0 propagates give X = [1, 1, 1, x4 , x5 , 0, 0, 0, 0], signifying dom(X) = {3, 4, 5}.
observe additional property order-encoding X = [x1 , . . . , xn ]: ability
specify variable cannot take specific value 0 v n domain equating
two variables: xv = xv+1 . indicates order-encoding well-suited
propagate lower upper bounds, represent integer variables arbitrary,
finite set, domain. example, given X = [x1 , . . . , x9 ], equating x2 = x3 imposes
X 6= 2. Likewise x5 = x6 x7 = x8 impose X 6= 5 X 6= 7. Applying
equalities X gives, X = [x1 , x2 , x2 , x4 , x5 , x5 , x7 , x7 , x9 ] (note repeated literals),
signifying dom(X) = {0, 1, 3, 4, 6, 8, 9}.
order-encoding many additional nice features exploited simplify
constraints encodings CNF. illustrate one, consider constraint form
+ B = 5 B integer values range 0 5 represented
order-encoding. bit level (in order encoding) have: = [a1 , . . . , a5 ]
B = [b1 , . . . , b5 ]. constraint satisfied precisely B = [a5 , . . . , a1 ]. Instead
encoding constraint CNF, substitute bits b1 , . . . , b5 literals a5 , . . . , a1 ,
remove constraint. section 3 formalize process discovering equalities
literals implied constraint using simplify CNF encodings.
307

fiMetodi, Codish, & Stuckey

2.4 Bit Blasting
Given constraint model decision represent finite domain integer variables
bit level (we chose order encoding), bit-blasting process instantiating integer variables corresponding bit vectors interpreting constraints Boolean
formulae.
integer variable, I, declared constraint form new int(I, c1 , c2 )
0 c1 c2 represented bit-vector = [1, . . . , 1, Xc1 +1 , . . . , Xc2 ]. So, may view
constraint model consisting Boolean variables constraint c corresponds
Boolean formula denoted [[c]], bit-blasted version c. specific definition
[[]] important. illustration, note one could define
^
[[new int(I, c1 , c2 )]] =
(xi+1 xi )
c1 i<c2

= [1, . . . , 1, Xc1 +1 , . . . , Xc2 ] well
[[int neq(I1 , I2 )]] =

n
_

(xi xor yi )

i=1

simplify presentation assume I1 = [x1 , . . . , xn ] I2 = [y1 , . . . , yn ]
represented number bits. mapping [[]] extends natural way apply
conjunctions constraints. So, given constraint model one Figure 3,
integer variables instantiated unary (order encoding) bit vectors constraint
viewed Boolean formula. constraint model takes Boolean representation
conjunction formulae.

3. Boolean Equi-propagation
section present approach propagation-based SAT encoding, Boolean equipropagation, propagates information equalities Boolean literals (and
constants). prove Boolean equi-propagation stronger unit propagation
determines least many fixed literals unit propagation. demonstrate,
example, power equi-propagation show leads considerable reduction
size CNF encoding.
3.1 Boolean Equi-propagation
Let B set Boolean variables. literal Boolean variable b B negation
b. negation literal `, denoted `, defined b ` = b b ` = b.
Boolean constants 1 0 represent true false, respectively. set literals
denoted L L0,1 = L {0, 1}. set (free) Boolean variables appear
Boolean formula denoted vars(). extend vars function sets formulae
natural way.
assignment, A, partial mapping
Boolean
constants, often


variables


viewed following set literals: b A(b) = 1 b A(b) = 0 . formula
b B, denote [b] (likewise [b]) formula obtained substituting
308

fiBoolean Equi-propagation

occurrences b B true (false). notation extends natural way
sets literals. say satisfies vars() vars(A) [A] evaluates true.
Boolean Satisfiability (SAT) problem consists Boolean formula determines
exists assignment satisfies .
Boolean equality constraint ` = `0 `, `0 L0,1 . equi-formula E set
Boolean equalities understood conjunction. set Boolean equalities denoted
Leq
0,1 set equi-formulae denoted E.
Example 1. Suppose B = {x, y, z}. L0,1 = {0, 1, x, x, y, y, z, x}. example
assignment = {x, z}, B = {x, y, z, y} assignment (since includes
{y, y}). Given formula = x (y z) [x] formula 0 (y z)
equivalently z. formula [A] = 1 (y 1) equivalent true,
satisfy since vars() = {x, y, z} 6 {x, z} = vars(A). example equi-formula B
{x = 0, = z} equivalently x (y z).
3.1.1 Equi-propagation
process inferring equational consequences Boolean formula given equational information. equi-propagator formula extensive function : E E
defined E E,

n


E (E) e Leq
0,1 E |= e
is, conjunction equalities, least strong
true E. say
n E, made
eq fifi
equi-propagator complete (E) = e L0,1 E |= e . denote
complete equi-propagator . assume equi-propagators monotonic:
E1 E2 (E1 ) (E2 ). particular, follows, definition, complete
equi-propagators. Section 3.3 discuss several methods implement complete
incomplete equi-propagators.
Example 2. Consider constraint
C = new int(X, 0, 4) new int(Y, 0, 4) int neq(X, Y)
corresponding Boolean representation = [[C]] bit representation
X = [x1 , x2 , x3 , x4 ] = [y1 , y2 , y3 , y4 ]
Assume setting
E=



y1 = 1, y2 = 1, y3 = 0, y4 = 0



signifying = 2. Then, (E) = E {x2 = x3 } indicating X 6= 2. occurs
since E equivalent (x2 x1 ) (x3 x2 ) (x4 x3 ) (x1 x2 x3 x4 )
E |= x2 = x3 .
following theorem states complete equi-propagation least powerful
unit propagation.
309

fiMetodi, Codish, & Stuckey

Theorem 3. Let complete equi-propagator Boolean formula . Then,
literal made true unit propagation clausal representation using
equations E determined true (E).
Proof. Let Boolean formula, E equi-formula, let C CE clausal
representations E respectively. Clearly |= C E |= CE . Let b
positive literal determined unit propagation C CE . correctness unit
propagation, C CE |= b. Hence, E |= b thus (E) |= b = 1. case
negative literal b same, except infer b = 0.
following example illustrates equi-propagation powerful unit
propagation.
Example 4. Consider = (x1 x2 ) (x1 x2 ) (x1 x2 x3 ). clausal
representation (x1 x2 )(x1 x2 )(x1 x2 )(x1 x2 x3 ) unit propagation
possible, since unit clauses. Equi-propagation (with additional equational
information) gives: () = {x1 = 1, x2 = 1, x3 = 0}.
3.1.2 Boolean Unifiers
sometimes convenient view equi-formula E generic solved-form Boolean
substitution, E , (most general) unifier equations E. Boolean substitutions generalize assignments variables bound literals.fi Boolean

substitution idempotent mapping : B L0,1 dom() = b B (b) 6= b
finite. Note particular idempotence implies (b) 6= b every b B.
Note defined B domain, dom(), includes elements

non-identity.
Boolean substitution, , viewed set =



b 7 (b) b dom()
.


apply another substitution 0 , obtain substifi

tution ( 0 ) = b 7 (0 (b)) b dom() dom(0 ) . unifier equi-formula E
substitution |= (e), e E. most-general unifier E
substitution unifier 0 E, exists substitution 0 = .
Example 5. Consider equi-formula E {b1 = b2 , b3 = b4 , b5 = b6 , b6 = b4 , b7 =
1, b8 = b7 } unifier E {b2 7 b1 , b4 7 b3 , b5 7 b3 , b6 7 b3 , b7 7 1, b8 7 0}.
Note (E) trivially true equi-formula {b1 = b1 , b3 = b3 , b3 = b3 , b3 = b3 , 1 =
1, 0 = 1}.
Consider enumeration L0,1 = {0, 1, b1 , b1 , b2 , b2 , . . .} let total (strict)
order L0,1 0 1 b1 b1 b2 b2 . define canonical most-general
unifier unifyE satisfiable equi-formula E where:



unifyE (b) = min ` L0,1 E |= b = `
is, substitution unifyE maps b smallest literal equivalent b given
E. compute unifyE almost linear (amortized) time using variation
union-find algorithm (Tarjan, 1975).
Example 6. equi-formula E substitution Example 5
unifyE = .
310

fiBoolean Equi-propagation

following proposition provides foundation equi-propagation based Boolean
simplification. allows us apply equational information simplify given formula.
particular, E equi-formula literals occurring unifyE () smaller
contains fewer variables.
Proposition 1. Let Boolean formula E E satisfiable equi-formula. Then,
a. E unifyE () E;
b. E satisfiable unifyE () satisfiable;
c. satisfying assignment unifyE () unifyE satisfying assignment
E.
Proof. (a) Let = unifyE assume satisfying assignment E,
view substitution, unifier E. Hence, since general unifier,
exists substitution = . Clearly (b) = (b) variables b range
. Hence, agree variables () implies (()) = (())
meaning (()) = (). So, satisfying assignment () E
satisfying assignment E. (b) () direction follows (a)
() direction (c). (c) Assume satisfying assignment unifyE (). Clearly
unifyE satisfies construction. unifyE satisfies E since unifyE (E)
trivial. Hence unifyE satisfying assignment E.
3.1.3 Equi-propagation Process
equi-propagation process presented central theme paper: Let =
1 n partitioning Boolean formula n portions, let 1 , . . . , n corresponding equi-propagators, take initial E = . Satisfiability determined
follows:
1. long possible, select (E) ) E update E = (E).
2. Finally, equi-propagators apply more, check unifyE () satisfiable.
3. satisfying assignment unifyE () unifyE satisfying assignment
.
typically apply equi-propagation theme Boolean representation =
1 n constraint model C = C1 Cn = [[Ci ]]. require
Ci small conjunction constraints. Typically, integer variables referred
Ci declared Ci (sometimes requires duplicating variable
declarations). individual constraint c denote c+ conjunction constraints
including c declarations integer variables refers to. specifics
declarations clear context.
Example 7. Let C following constraint model:

new int(X, 1, 3) new int(Y, 1, 3) new int(Z, 1, 3)
C=
int plus(X, Y, 3) int plus(Y, Z, 4) int neq(Y, Z)

311



fiMetodi, Codish, & Stuckey

1. int plus+ (X, Y, 3) = int plus(X, Y, 3) new int(X, 1, 3) new int(Y, 1, 3),
2. int plus+ (Y, Z, 4) = int plus(Y, Z, 4) new int(Y, 1, 3) new int(Z, 1, 3),
3. int neq+ (Y, Z) = int neq(Y, Z) new int(Y, 1, 3) new int(Z, 1, 3).
basis equi-propagation take = 1 2 3 1 = [[int plus+ (X, Y, 3)]],
2 = [[int plus+ (Y, Z, 4)]], 3 = [[int neq+ (Y, Z)]]. Denoting X = [1, x2 , x3 ], =
[1, y2 , y3 ], Z = [1, z2 , z3 ] applying corresponding complete equi-propagators
starting E0 = have:
1. E1 = 1 (E0 ) = E0 {x3 = 0, y3 = 0, x2 = y2 };
2. E2 = 2 (E1 ) = E1 {z2 = 1, y2 = z3 };
3. E3 = 3 (E2 ) = E2 {y2 = 0}.
point equi-propagation applies more, unifyE3 = {x2 7 1, x3 7 0, y2 7
0, y3 7 0, z2 7 1, z3 7 1} . Now, unifyE3 () tautology (all Boolean variables
determent equi-propagation).
following theorem clarifies order equi-propagators applied
equi-propagation process influence final result.
Theorem 8. equi-propagation process confluent.
Proof. Let = 1 n Boolean formula 1 , . . . , n corresponding equipropagators. Let E1 = ir (ir1 (. . . i1 () . . .)) E2 = js (js1 (. . . j1 () . . .))
two different applications equi-propagation process. construction,
given equi-propagators, property (?): (E1 ) = E1 (E2 ) = E2 .
assume, contradiction, E1 6= E2 . w.l.o.g. exists e E2 e
E1 (swap roles E1 E2 E2 E1 ). E1 ( E2 . Let us focus first
step equi-propagation process leading E2 introduced equation e E2
introduced E1 : So, exists ` < E = j` (j`1 (. . . j1 () . . .)) E1
e `+1 (E) e 6 E1 . But, E E1 , monotonicity `+1 ,
`+1 (E) `+1 (E1 ) hence e `+1 (E1 ) contradiction construction
property (?).
following proposition provides alternative, efficient implement, definition
complete equi-propagation.
Proposition 2. Let Boolean formula complete equi-propagator .
Define E E,
n


unify () |= e
(E) = E e Leq
E
0,1
Then, (E) = (E). is, implements complete equi-propagator .
312

fiBoolean Equi-propagation

Proof. Forthefi first direction, ():
definition, (E) E.
(E) e unifyE () |= e
Proposition 1(a) E |= unifyE (). So,
(E) (E). direction, (): Let e (E). e E proof
straightforward. Otherwise, let unifyE () |= e assume contrary e 6 (E),
words E 6|= e. means exists assignment
satisfies E satisfy e. Lemma 1(a), satisfies unifyE () E
particular satisfies unifyE (). assumption unifyE () |= e
satisfies e. Contradiction.
Computing considerably efficient since simply examine
formula application unifyE determine new Boolean equality consequences.
Finally comment: intention equi-propagation process applied
make SAT instance smaller obtain easier solve representation.
However, decreasing size CNF main objective. fact, often explicitly
introduce redundancies improve SAT encoding. example, consider if-thenelse construct, xITE(s,t,f), propositional variable: indicates selector,
indicates true branch, f indicates false branch, x indicates result.
corresponding CNF {{s, t, x}, {s, t, x}, {s, f, x}, {s, f, x}}. Een Sorensson
(2006) propose add redundant clauses, {t, f, x} {t, f, x}. comment
improves encoding observe redundant clauses often introduced
achieve arc-consistency SAT encoding. show given clausal encoding
formula , application equi-propagation strengthen unit propagation.
Theorem 9. Let C set clauses, suppose C |= E E equi-formula.
unit propagation unifyE (C) least strong unit propagation C.
Proof. Unit propagation C starting assignment A0 repeatedly chooses clause
c {l} C {l0 | l0 c} Ai sets Ai+1 := Ai {l}. Unit propagation terminates
Ak clauses occur. Note failure detected Ak contains
literal negation.
show using order unit propagation unifyE (C) determined
occurs C starting assignment B0 = unifyE (A0 ) always obtain assignment
Bi Bi unifyE (Ai ). proof induction unit propagation steps C.
base case holds construction.
Assume c {l} C {l0 | l0 c} Ai . induction Bi unifyE (Ai )
{unifyE (l0 ) | l0 c}. Either unifyE (l) Bi case set Bi+1 = Bi
induction holds. unifyE (l) 6 Bi . since c {l} C {unifyE (l0 ) | l0
c}{unifyE (l)} unifyE (C). Hence unit propagation unifyE (C) Bi obtain
Bi+1 := Bi {unifyE (l)}. Hence induction holds.
Given unit propagation reaches unique fixpoint unit propagation order
unifyE (A0 ) end assignment B B Bk unify(Ak )
3.2 Power Equi-propagation
illustrate impact equi-propagation come back Kakuro example
Section 2.2 (recall Figure 2). fact solving puzzles via SAT encodings quite easy,
without equi-propagation. example viewed illustrating
313

fiMetodi, Codish, & Stuckey

a. 1

b. 2

c. 3

Figure 4: Applying complete equi-propagation Kakuro Instance using different models

impact equi-propagation size encoding. compare 3 different models
problem, give different equi-propagation.
consider, baseline discussion, following Boolean representation
derived constraint model declarations specified explicitly
form new int(I, 1, h) h smallest hint block includes
number 9 smaller.
^
^
1 =
[[int neq+ (Ii , Ij )]]
[[int array sum+ (B, hint(B))]]
{I1 , . . . , Ik } Blocks
1i<j k

B Blocks

Notice one int neq conjunct pair white cells block,
one int array sum conjunct block. Applying equi-propagation process
1 complete equi-propagators determines six integer values depicted Figure 4(a).
Figure 4(b) illustrates impact applying equi-propagation process
equi-propagators allDiff constraints instead individual int neq constraints. determines seven integer variables formalized taking following
Boolean representation constraint model (and introducing equi-propagator
conjunct).
^
^
2 =
[[allDiff+ (B)]]
[[int array sum+ (B, hint(B))]]
B Blocks

B Blocks

Figure 4(c) illustrates impact applying equi-propagation process equipropagators pairs, consisting allDiff constraint together corresponding sum constraint. form equi-propagation powerful. fixes integer
values white cells (in example). stress equi-propagation reasons
equalities Boolean literals constants. take model as:
^

3 =
[[allDiff+ (B)]] [[int array sum+ (B, hint(B))]]
B Blocks

demonstrate impact equi-propagation, Table 1 provides data 15
additional instances,1 categorized as: easy, medium hard. first two columns
table indicate instance category ID. five columns headed Integer
1. Instances available http://4c.ucc.ie/~hcambaza/page1/page7/page7.html (generated Helmut
Simonis).

314

fihard

medium

easy

Boolean Equi-propagation

ID
168
169
170
171
172
188
189
190
191
192
183
184
185
186
187

Integer Variables
init 1 2 3 BEE
init
484 439 280
0 385 3872
467 456 440
0 440 3736
494 485 469
0 469 3952
490 406 393
0 422 3920
506 495 484
0 492 4048
476 461 455
0 461 3808
472 437 425
62 449 3776
492 481 480
0 480 3936
478 452 448 161 448 3824
499 481 478 136 478 3992
490 365 345
0 371 3920
506 489 484
23 486 4048
482 482 455 206 467 3856
472 466 454
0 466 3776
492 475 473
69 473 3936
Average compilation time sec.

Boolean Variables
1
2
3
1440
843
0
1823 1682
0
1961 1798
0
1280 1148
0
1676 1573
0
1939 1915
0
2017 1911
81
1998 1920
0
1864 1821
197
2455 2417
214
1151 1059
0
1613 1495
21
2181 2111
220
2115 2062
0
1991 1959
48
3.739 2.981 0.916

BEE
1170
1692
1805
1341
1634
1934
1976
1936
1828
2420
1168
1545
2144
2086
1960
0.477

Table 1: Applying SAT-based complete equi-propagation Kakuro encoding
Variables, first four specify number unassigned white cells initial stage
three complete equi-propagation processes described above. five
columns headed Boolean variables, first four indicate corresponding information
regarding number Boolean variables bit representations integers. So,
smaller number table, variables removed due equipropagation. particular, 3 model completely solves 9 15 instances. two
columns titled BEE show corresponding information obtained using weaker form
equi-propagation described Section 4 below. last row table indicates
average time takes perform equi-propagation (in seconds) using three
schemes, 1 , 2 , 3 , weaker scheme titled BEE. come back discuss
later detailing equi-propagation performed. results table indicate
clear benefit performing equi-propagation based coarser portions model.
3.3 Implementing Equi-propagators
implement complete equi-propagators need infer Boolean equalities implied
given Boolean formula, , equi-formula, E. Based Proposition 2, sufficient
test condition
unifyE () |= (`1 `2 )
(1)
consider three techniques: using SAT solver, using BDDs, using ad-hoc rules
applied Boolean representations individual constraints.
straightforward implement complete equi-propagator using SAT solver.
test Condition (1) consider formula = (`1 6 `2 ). satisfiable,
Condition (1) holds. way, Condition (1) checked relevant equations
315

fiMetodi, Codish, & Stuckey

involving variables unifyE () (and constants 0,1). major obstacle SATbased approach testing single equivalence, `1 `2 , least hard testing
satisfiability . fact testing unsatisfiability typically expensive.
Hence importance assumption small fragment CNF
interest. practice SAT-based equi-propagation surprisingly fast. illustration,
last row Table 1 average times SAT-based complete equi-propagation
different models indicated columns 1 , 2 , 3 . interesting observe
strongest technique, using 3 , fastest. fewer (but
larger) conjuncts hence fewer queries SAT solver.
implement complete equi-propagator using binary decision diagrams (BDDs)
follows. construct BDD formula beginning equi-propagation.
new equational information E 0 added E simplify BDD conjoining
BDD BDD E 0 projecting variables longer appear
unifyE (). Note simplification increase size BDD. practice,
rather two steps, use Restrict operation Coudert Madre
(1990) (bdd simplify Somenzi, 2009) create new BDD efficiently.
Given BDD unifyE (), explicitly test Condition (1) using standard
BDD containment test (e.g., bddLeq Somenzi, 2009). SAT-based approach, test performed relevant equations involving variables unifyE ()
(and constants 0,1). Alternately use method Bagnara Schachte (1998)
(extended extract literal equalities opposed variable equalities) extract
fixed literals equivalent literal consequences BDD.
Example 10. Consider BDD shown Figure 5(a) represents formula:
new int(A, 0, 3) new int(B, 0, 3) int neq(A, B). Figure 5(b) depicts BDD
unifyE () E = {B1 = 1, B2 = 1, B3 = 0 }. easy see equipropagation determines A2 = A3 . Let E 0 = E {A2 = A3 }. Figure 5(c) shows
simplified BDD unifyE 0 ().
major obstacle BDD-based approach concerns size formula
unifyE (). constraints, corresponding BDD guaranteed polynomial (in size constraint). following result holds arbitrary constraint
, holds unifyE ().
Proposition 3. Let c constraint k integer variables represented n bits
order encoding. Then, number nodes BDD representing [[c]] bound
O(nk ).
Proof. (Sketch) n + 1 legitimate states n bit unary variable,
BDD cannot nodes possible states.
Constraints new int, int neq, int plus involve 3 integer variables
hence BDD-based complete equi-propagators polynomially bounded. However,
case global constraints allDiff int array plus
arity fixed. Moreover, well known allDiff constraint
polynomial sized BDD (Bessiere, Katsirelos, Narodytska, & Walsh, 2009).
316

fiBoolean Equi-propagation
7654
0123
A1:

:

:
7654
0123
7654
0123
B1
B1




0123
7654
0123 7654
7654
0123
r 2 rrr A2: A2
r
r
:
r r
rr
rrr rrrr
:
r
0123 7654
0123
0123
0123
7654
0123
B2 L 7654
B2
B2: 7654
B2: 7654
, LLB 2

::
L
:
L
:
,
LLL
::
:
, L
7654
0123
7654
0123
0123
,
A3: A3 l 7654
A3
, : l -ll
, l l : l
7654
0123
7654
0123
B3
B3;; - ;;
S;-

7654
0123
A1
.
.
.

.

.

0123
7654
0123
7654
A2
A2
.

.

.
.
.
0123
0123
7654
A3.
A3 > 7654
>>
>> .
>> .
>> .
>>
>.

7654
0123
A1
+
+







+



+

+
7654
0123
A2







(a) BDD int nequ (A, B)

(b) Simpld wrt B=[1, 1, 0]

(c) Simpld wrt A2 =A3

Figure 5: BDDs (a) new int3 (A, [0, 3]) new int3 (B, [0, 3]) int neq(A, B) (b)
unifyE () E = {B1 =1, B2 =1, B3 =0} (c) unifyE 0 () E 0 =
E {A2 =A3 }. Full (dashed) lines correspond true (false) edges. Edges
false node F omitted brevity.

Given potential exponential run-time performing SAT-based equi-propagation,
potential exponential size BDD-based equi-propagators, consider third
approach implement equi-propagation collection ad-hoc transition rules
type constraint. approach complete equations
implied constraint detected implementation fast, works well
practice. topic next section.

4. Ad-hoc Equi-Propagation
consider rule-based approach define equi-propagators. definition given
set ad-hoc rules specified type constraint. novelty approach
based CNF, previous works, rather driven bit blasted constraints
encoded CNF. presentation focuses case finite domain
integers represented order encoding. integer X = [x1 , . . . , xn ], often
write: X denote equation xi = 1, X < denote equation xi = 0, X 6=
denote equation xi = xi+1 , X = denote pair equations xi = 1, xi+1 = 0.
Moreover, simplify notation specifying rules below, view X = [x1 , . . . , xn ]
larger vector padded sentinel cells cells left x1 take value 1
cells right xn take value 0. Basically facilitates specification
end cases formalism. consider 5 constraints
language fragment presented Section 2.
317

fiMetodi, Codish, & Stuckey

c = new int([x1 , . . . , xn ], 0, n)
E
add c (E)
xi = 1 x1 = 1, . . . , xi1 = 1
xi = 0 xi+1 = 0, . . . , xn = 0

(a)

c = int neq(X, )
X = [x1 , . . . , xn ] = [y1 , . . . , yn ]

E
add c (E)
X=i
6=
xi = yi+1 , yi = xi+1
X 6= i, 6=
xi = yi+1 , yi = xi+1
X 6= i, 6=
(b)

Figure 6: Ad-hoc rules (a) new int (b) int neq
c = int plus(X, Y, Z) X = [x1 , . . . , xn ],
= [y1 , . . . , ym ], Z = [z1 , . . . , zn+m ]

c = allDiff([Z1 , Z2 , Z3 , . . . , Zn ])
E
add c (E)
Z1 , Z2 {i, j}

Z1 =
6 Z2 , Zk 6=
Zk =
6 j (k > 2)

E
X i, j
X < i, < j
Z k, X <
Z < k, X
X=i
Z=k

(a)

add c (E)
Z i+j
Z <i+j1
ki
<ki
zi+1 = y1 , . . . , zi+m = ym
x1 = yk , . . . , xk = y1
(b)

Figure 7: Ad-hoc rules (a) allDiff (b) int plus

(1) two rules Figure 6(a) derive monotonicity order encoding
representation. basically correspond unit propagation, constraint level.
(2) first rule Figure 6(b) considers cases X constant (the symmetric
case handled exchanging X ). two rules capture templates
commonly arise equi-propagation process. illustrate justification
third rule consider possible truth values variables xi xi+1 : (a) xi = 0
xi+1 = 1 integers relation take form [. . . , 0, 1, . . .] violating
specification ordered, possible. (b) xi = 1 xi+1 = 0
numbers take form [1, . . . , 1, 0, . . . , 0] equal, violating neq constraint.
possible bindings xi xi+1 xi = xi+1 .
(3) Figure 7(a) illustrate single rule allDiff constraint considers
Hall sets size 2. Zi represents integer order encoding focus
case Z1 Z2 restricted equations E take two possible
values, j. expressed E [x1 , . . . , xn ] {i, j} (for < j) means
xk = 1 k < i, xk = xk+1 k < j, xk = 0 j < k n. Z1 6= Z2
means adding single equation xi = yi (because Z1 Z2 take two values).
addition rule, apply rules int neq(Zi , Zj ) pair integers Zi
Zj constraint.
318

fiBoolean Equi-propagation




z1 =1, . . . , z4 =1,
E0 =
z5 =0, . . . , z18 =0
X = [x1 , . . . , x4 , x5 , x6 , . . . , x9 ],
= [y1 , . . . , y4 , y5 , y6 , . . . , y9 ],
Z = [1, 1, 1, 1, 0, . . . , 0]
E2 = E1 {y6 =0, . . . , y9 =0}
X = [x1 , . . . , x4 , x5 , x6 , . . . , x9 ],
= [y1 , . . . , y4 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]
E4 = E3 {x6 =0, . . . , x9 =0}
X = [x1 , . . . , x4 , 0, . . . , 0],
= [y1 , . . . , y4 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

x2 =y3 ,
y2 =x3


int neq

Z<5, X0


int plus

Z<5, 0


int plus

Z=4


int plus

E1 = E0 {y5 =0}
X = [x1 , . . . , x4 , x5 , x6 , . . . , x9 ],
= [y1 , . . . , y4 , 0, y6 , . . . , y9 ],
Z = [1, 1, 1, 1, 0, . . . , 0]

E3 = E2 {x5 =0}
X = [x1 , . . . , x4 , 0, x6 , . . . , x9 ],
= [y1 , . . . , y4 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

E5 = E4 {x1 =y4 , . . . , x4 =y1 }
X = [x1 , x2 , x3 , x4 , 0, . . . , 0],
= [x4 , x3 , x2 , x1 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

y5 =0


new int

x =0

5
new int



E6 = E5 {x2 =x3 }
X = [x1 , x2 , x2 , x4 , 0, . . . , 0],
= [x4 , x2 , x2 , x1 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

Figure 8: Ad-hoc equi-propagation described Example 11
(4) first four rules Figure 7(b) capture standard propagation behavior
interval arithmetics. last two rules apply one integers relation
constant. symmetric cases replacing role X .
(5) special ad-hoc rules equi-propagation int array plus constraint. simply viewed decomposition set int plus constraints.
simplification performed level using rules int plus. decomposition
int array plus explained Section 6.
Example 11 (ad-hoc equi-propagation). Consider following (partial) constraint model,
context Kakuro example Section 2.2, represent variables X,
Z X = [x1 , . . . , x9 ], = [y1 , . . . , y9 ] Z = [z1 , . . . , z18 ] assume previous equi-propagation (on constraints) determined current equi-formula E0
specify integer variable Z = 4:

C=

new int(X, 0, 9) new int(Y, 0, 9) new int(Z, 0, 18)
int plus(X, Y, Z) int neq(X, Y)



Figure 8 illustrates, step-by-step, equi-propagation process C using ad-hoc rules
defined above. step corresponds application one defined ad-hoc
equi-propagation rules indicated label transition. stage illustrate
derived equations (top part) application (as unifier) state variables
X, Z (lower part).
319

fiMetodi, Codish, & Stuckey

c = ordered([x1 , . . . , xn ]) (new int)

replace
n1
true
x1 = 1
ordered([1, x2 . . . , xn ])
xn = 0
ordered([x1 , . . . , xn1 , 0])
, . . . , xn ])

xi = xi+1 ordered([x1 , . . . , xi ,
xi+1
Figure 9: Simplification rules new int (crossed elements removed).
summarize, let us come back Table 1. numbers presented two columns
headed BEE specify number variables remaining application ad-hoc equipropagation. observe definition ad-hoc equi-propagation trivially
monotonic.

5. Constraint Model Partial Evaluation
Partial evaluation, together equi-propagation, second important component
approach compile constraint models CNF. Partial evaluation simplifying given constraint model view information becomes available due equipropagation. Typically, constraint simplification process, apply alternating steps
equi-propagation partial evaluation. Examples partial evaluation include constant
elimination removing constraints tautologies. section detail
partial evaluation rules apply five constraint types defined language
fragment presented Section 2.
(1) new int(I, c1 , c2 ) constraint specifies integer = [x1 , . . . , xn ] represented
order encoding particular corresponding bit sequence sorted (not
increasing). denote ordered([x1 , . . . , xn ]). Partial evaluation focuses
aspect constraint ignores bounds c1 , c2 specified constraint. table
Figure 9 specifies four simplification rules apply. first rule identifies tautologies,
second third rules remove leading ones trailing zeros, fourth removes
(one two) equated bits. figure, subsequent, crossed element
sequence, indicates removed sequence.
(2) simplification rules int neq constraint shown Figure 10(a) symmetric
exchanging role X . first two rules identify tautologies. third
rule X equal bit position i. corresponding bits
removed representation X , resulting shorter list bits
representations. last two rules removing leading ones trailing zeroes
illustrated following example.
Example 12. Figure 10(b) shows two steps partial evaluation, int neq constraint,
first removing leading ones, removing trailing zeroes.

320

fiBoolean Equi-propagation

c = int neq(X, )
X = [x1 , . . . , xn ] = [y1 , . . . , yn ]

replace
X = i, 6=
true
xi = yi
true
int neq(
x
[x1 , . . . ,
xi = yi
, . . . , xn ],
yi , . . . , yn ])
[y1 , . . . ,
int neq([1, xi+1 , . . . , xn ],
Xi2
[yi , yi+1 , . . . , yn ])
int neq([x1 , . . . , xi , 0],
Xi
[y1 , . . . , yi , yi+1 ])




int neq(
[x1 , . . . , x4 , 0, 0, 0], P.E

int neq
[1, 1, 1, y4 , . . . , y7 ])


int neq(
[x3 , x4 , 0, 0, 0], P.E

int neq
[1, y4 , . . . , y7 ])


int neq(
[x3 , x4 , 0],
[1, y4 , y5 ])

(a)

(b)

Figure 10: (a) Simplification rules int neq (b) example application.
c = allDiff([Z1 , . . . , Zn ])
Zi = [zi,1 , . . . , zi,m ] (1 n)

replace
n1
true
^ dom(Z1 )
allDiff([Z2 , . . . , Zn ])
dom(Zk ) =
k>1 [
|
dom(Zi )| = 2
allDiff([Z3 , . . . , Zn ])
i{1,2}

^
k

Zk 6=

allDiff(
[z1,1 , . . . ,
z1,i+1
, . . . , z1,m ]
...
[zn,1 , . . . ,
zn,i+1
, . . . , zn,m ])

Figure 11: Simplification rules allDiff

(3) Four rules simplifying allDiff constraints illustrated Figure 11. first,
detecting tautologies. second, identifies cases one integers
constraint (assume Z1 ) domain disjoint others. rule captures
case Z1 constant. third rule removes Hall set size 2 (assume {Z1 , Z2 })
constraint. Note corresponding equi-propagation rule detects
values Z3 , . . . , Zn different values {Z1 , Z2 } next fourth rule
applies. fourth rule case none integers constraint take
certain value i. rule captures case numbers leading
ones trailing zeroes. last two rules illustrated Example 14.
(4 & 5) simplification rules shown Figure 12 symmetric exchanging
role X . first two apply (at least) one X, Z constant.
already applied equi-propagation constraint, tautology. See
Example 13. last two rules apply remove leading ones trailing zeroes.
321

fiMetodi, Codish, & Stuckey

c = int plus(X, Y, Z) X = [x1 , . . . , xn ],
= [y1 , . . . , ym ], Z = [z1 , . . . , zn+m ]

replace
X=i
true
Z=k
true
int plus([xi+1 , . . . , xn ], Y,
X i, Z
[zi+1 , . . . , zn+m ])
int plus([x1 , . . . , xi ], Y,
X i, Z +
[z1 , . . . , zi+m ])

Figure 12: Simplification rules int plus.
(a) int plus(I1 , I2 , K)
(b) allDiff([I1 , I2 , I3 , I4 , I5 , I6 , I7 , I8 ])
(c) int array plus([I2 , I3 , I4 , I5 ], K)
Figure 13: Constraint Model Examples 1315
simplification rules int array plus constraint straightforward generalizations
ones int plus. See Example 15.
summarise rule based approach apply equi-propagation partial evaluation
present following sequence three examples focus simplification
three constraints given Figure 13 integer variables I1 , . . . , I8 defined
range 1 8 K = 14.
Example 13. Consider equi-propagation constraint (a) Figure 13 E0 specifies
K = 14:




k1 =1, . . . , k14 =1
k15 = 0, k16 = 0
I1 = [1, i1,2 , . . . , i1,8 ],
I2 = [1, i2,2 , . . . , i2,8 ],
K = [1, 1, . . . , 1, 0, 0]
| {z }



14

i1,2 =1, . . . , i1,6 =1,

i2,2 =1, . . . , i2,6 =1,


i1,7 =i2,8 , i1,8 =i2,7
I1 = [1, 1, 1, 1, 1, 1, i1,7 , i1,8 ],
I2 = [1, 1, 1, 1, 1, 1, i1,8 , i1,7 ],
K = [1, 1, . . . , 1, 0, 0]
| {z }
E1 = E0

E0 =

K=14


int plus

14

Given E1 , constraint tautology removed partial evaluation:



int plus(

P.E


[1, 1, 1, 1, 1, 1, i1,7 , i1,8 ],

int plus
[1, 1, 1, 1, 1, 1, i1,8 , i1,7 ], 14)



Example 14. Consider equi-propagation constraint (b) Figure 13 given E1
Example 13:
E1
I1 = [1, 1, 1, 1, 1, 1, i1,7 , i1,8 ],
I2 = [1, 1, 1, 1, 1, 1, i1,8 , i1,7 ]

i1,7 =i2,8 ,
i2,7 =i1,8


int neq

322

E2 = E1 {i1,7 =i1,8 }
I1 = [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
I2 = [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]

fiBoolean Equi-propagation

Given E2 , equi-propagation rule allDiff detects {I1 , I2 } Hall set (where
two variables take values 6 8). adds E2 set equations, E 0 , specify
I3 , I4 , I5 , I6 , I7 , I8 6= 6, 8. result E3 = E2 E 0 result step gives
following bindings (where impact E 0 underlined):
I1
I2
I3
I4

= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, i3,2 , i3,3 , i3,4 , i3,5 , i3,7 , i3,7 , 0]
= [1, i4,2 , i4,3 , i4,4 , i4,5 , i4,7 , i4,7 , 0]

I5
I6
I7
I8

= [1, i5,2 , i5,3 , i5,4 , i5,5 , i5,7 , i5,7 , 0]
= [1, i6,2 , i6,3 , i6,4 , i6,5 , i6,7 , i6,7 , 0]
= [1, i7,2 , i7,3 , i7,4 , i7,5 , i7,7 , i7,7 , 0]
= [1, i8,2 , i8,3 , i8,4 , i8,5 , i8,7 , i8,7 , 0]

Given E3 , partial evaluation constraint first removes Hall set:
P.E

[allDiff([I1 , I2 , I3 , I4 , I5 , I6 , I7 , I8 ])] [allDiff([I3 , I4 , I5 , I6 , I7 , I8 ])]
allDiff

applies remove three redundant bits underlying representation
remaining integer (which equal 0, 6, 8):











allDiff([
[1, i3,2 , i3,3 , i3,4 , i3,5 , i3,7 , i3,7 , 0],
[1, i4,2 , i4,3 , i4,4 , i4,5 , i4,7 , i4,7 , 0],
[1, i5,2 , i5,3 , i5,4 , i5,5 , i5,7 , i5,7 , 0],
[1, i6,2 , i6,3 , i6,4 , i6,5 , i6,7 , i6,7 , 0],
[1, i7,2 , i7,3 , i7,4 , i7,5 , i7,7 , i7,7 , 0],
[1, i8,2 , i8,3 , i8,4 , i8,5 , i8,7 , i8,7 , 0]])









P.E

allDifferent














allDiff([
[i3,2 , i3,3 , i3,4 , i3,5 , i3,7 ],
[i4,2 , i4,3 , i4,4 , i4,5 , i4,7 ],
[i5,2 , i5,3 , i5,4 , i5,5 , i5,7 ],
[i6,2 , i6,3 , i6,4 , i6,5 , i6,7 ],
[i7,2 , i7,3 , i7,4 , i7,5 , i7,7 ],
[i8,2 , i8,3 , i8,4 , i8,5 , i8,7 ]])












Example 15. Consider equi-propagation constraint (c) Figure 13 given E3
Example 14. rules apply derive decomposition int array plus
constraint int plus parts. dictate I3 , I4 , I5 5:
E3
I2
I3
I4
I5

= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
= [1, i3,2 , i3,3 , i3,4 , i3,5 , i3,7 , i3,7 , 0],
= [1, i4,2 , i4,3 , i4,4 , i4,5 , i4,7 , i4,7 , 0],
= [1, i5,2 , i5,3 , i5,4 , i5,5 , i5,7 , i5,7 , 0]


int array
plus

E4
I2
I3
I4
I5

= E3 {i3,7 =0, i4,7 =0, i5,7 =0}
= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
= [1, i3,2 , i3,3 , i3,4 , i3,5 , 0, 0, 0],
= [1, i4,2 , i4,3 , i4,4 , i4,5 , 0, 0, 0],
= [1, i5,2 , i5,3 , i5,4 , i5,5 , 0, 0, 0]

Applying partial evaluation simplifies constraint follows:







int array plus([
[1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
[1, i3,2 , i3,3 , i3,4 , i3,5 , 0, 0, 0],
[1, i4,2 , i4,3 , i4,4 , i4,5 , 0, 0, 0],
[1, i5,2 , i5,3 , i5,4 , i5,5 , 0, 0, 0]], 14 )







P.E


int array
plus








int array plus([
[i1,7 , i1,7 ],
[i3,2 , i3,3 , i3,4 , i3,5 ],
[i4,2 , i4,3 , i4,4 , i4,5 ],
[i5,2 , i5,3 , i5,4 , i5,5 ]], 5 )








summarize Examples 1315 observe initial constraint model 3 constraints
8 integers represented 56 bits. constraint simplification 2 constraints
remain 8 integers represented using 28 bits:
I1
I2
I3
I4

= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, i3,2 , i3,3 , i3,4 , i3,5 , 0, 0, 0]
= [1, i4,2 , i4,3 , i4,4 , i4,5 , 0, 0, 0]

I5
I6
I7
I8
323

= [1, i5,2 , i5,3 , i5,4 , i5,5 , 0, 0, 0]
= [1, i6,2 , i6,3 , i6,4 , i6,5 , i6,7 , i6,7 , 0]
= [1, i7,2 , i7,3 , i7,4 , i7,5 , i7,7 , i7,7 , 0]
= [1, i8,2 , i8,3 , i8,4 , i8,5 , i8,7 , i8,7 , 0]

fiMetodi, Codish, & Stuckey

6. Compiling Constraints BEE
BEE (Ben-Gurion Equi-propagation Encoder) tool applies encode finite domain
constraint models CNF. BEE first introduced Metodi Codish (2012).
encoding process, BEE performs optimizations based equi-propagation partial
evaluation improve quality target CNF. BEE implemented (SWI) Prolog
applied conjunction CryptoMiniSAT solver (Soos, 2010)
Prolog interface (Codish, Lagoon, & Stuckey, 2008). CryptoMiniSAT offers direct support
xor clauses, BEE takes advantage feature. BEE downloaded (Metodi,
2012) one find examples paper others.
source language BEE compiler called BEE. constraint modeling
language similar FlatZinc (Nethercote et al., 2007), focus subset
language relevant finite domain constraint problems. Five constraint constructs
BEE language introduced Section 2.1. full language presented
Table 2.
BEE Boolean constants true false viewed (integer) values 1 0.
Constraints represented (a list of) Prolog terms. Boolean integer variables
represented Prolog variables, may instantiated simplifying constraints.
Table 2, X Xs (possibly subscripts) denote literal (a Boolean variable
negation) vector literals, (possibly subscript) denotes integer variable,
c (possibly subscript) denotes integer constant. right column
table brief explanations regarding constraints. table introduces 26 constraint
templates.
Constraints (1-2) variable declarations: Booleans integers. Constraint (3)
expresses Boolean integer value. Constraints (4-8) Boolean (and reified
Boolean) statements. special cases Constraint (5) bool array or([X1 , . . . , Xn ])
bool array xor([X1 , . . . , Xn ]) facilitate specification clauses xor clauses
(supported directly CryptoMiniSAT solver Soos, 2010). Constraint (8) specifies
sorting bit pair [X1 , X2 ] (decreasing order) results pair [X3 , X4 ]. basic
building block construction sorting networks (Batcher, 1968) used encode cardinality (linear Boolean) constraints compilation described Asn, Nieuwenhuis,
Oliveras, Rodrguez-Carbonell (2011) Codish Zazon-Ivry (2010). Constraints (9-14) integer relations operations. Constraints (15-20)
linear (Boolean, Pseudo Boolean, integer) operations. Constraints (21-26)
lexical orderings Boolean integer arrays.
main design choice BEE integer variables represented orderencoding. So, BEE suitable problems integer variables take small
medium sized values. compilation constraint model CNF using BEE goes
three phases.
1. Unary bit-blasting: integer variables (and constants) represented bit vectors
order-encoding.
2. Constraint simplification: three types actions applied: equi-propagation, partial
evaluation, decomposition constraints. Simplification applied repeatedly
rule applicable.
324

fiBoolean Equi-propagation

Declaring Variables
(1)
(2)
(3)

declare Boolean X
declare integer I, c1 c2
(X = 1) (X = 0)

new bool(X)
new int(I, c1 , c2 )
bool2int(X, I)

op {or, and, xor, iff}

Boolean (reified) Statements
(4)
(5)
(6)
(7)
(8)

bool eq(X1 , X2 ) bool eq(X1 , X2 )
bool array op([X1 , . . . , Xn ])
bool array op reif([X1 , . . . , Xn ], X)
bool op reif(X1 , X2 , X)
comparator(X1 , X2 , X3 , X4 )

X1 = X2 X1 = X2
X1 op X2 op Xn
X1 op X2 op Xn X
X1 op X2 X
sort([X1 , X2 ]) = [X3 , X4 ]

Integer relations (reified)
rel {leq, geq, eq, lt, gt, neq}
arithmetic
op {plus, times, div, mod, max, min}, op0 {plus, times, max, min}
(9)
(10)
(11)
(12)
(13)
(14)

int
int
int
int
int
int

rel(I1 , I2 )
rel reif(I1 , I2 , X)
array allDiff([I1 , . . . , ])
abs(I1 , I)
op(I1 , I2 , I)
array op0 ([I1 , . . . , ], I)

I1 rel I2

V1 rel I2 X
i<j Ii 6= Ij
|I1 | =
I1 op I2 =
I1 op0 op0 =

Linear Constraints
(15)
(16)
(17)
(18)
(19)
(20)

rel{leq, geq, eq, lt, gt}

bool array sum rel([X1 , . . . , Xn ], I)
bool array pb rel([c1 , . . . , cn ], [X1 , . . . , Xn ], I)
bool array sum modK([X1 , . . . , Xn ], c, I)
int array sum rel([I1 , . . . , ], I)
int array lin rel([c1 , . . . , cn ], [I1 , . . . , ], I)
int array sum modK([I1 , . . . , ], c, I)

( Xi ) rel
( ci Xi ) rel
(( Xi ) mod c) =
( Ii ) rel
( ci Ii ) rel
(( Ii ) mod c) =

Lexical Order
(21)
(22)
(23)
(24)
(25)
(26)

bool arrays lex(Xs1 , Xs2 )
bool arrays lexLt(Xs1 , Xs2 )
bool arrays lex reif(Xs1 , Xs2 , X)
bool arrays lexLt reif(Xs1 , Xs2 , X)
int arrays lex(Is1 , Is2 )
int arrays lexLt(Is1 , Is2 )

Xs1 precedes (leq) Xs2 lex order
Xs1 precedes (lt) Xs2 lex order
X Xs1 precedes (leq) Xs2 lex order
X Xs1 precedes (lt) Xs2 lex order
Is1 precedes (leq) Is2 lex order
Is1 precedes (lt) Is2 lex order

Table 2: Syntax BEE Constraints.
3. CNF encoding: best suited encoding technique applied simplified constraints.
Bit-blasting equi-propagation BEE follow general descriptions Sections 2.4 3.1. Bit-blasting implemented Prolog unification. declaration form new int(I, c1 , c2 ) triggers unification = [1, . . . , 1, Xc1 +1 , . . . , Xc2 ] (to
ease presentation assume integer variables represented positive interval
starting 0 limitation practice BEE supports negatives
integers). BEE applies ad-hoc equi-propagators described Section 4. equality
form X = L (between variable literal constant) detected, equipropagation implemented unifying X L. unification applies occurrences
X sense propagates constraints involving X.
Decomposition replacing complex constraints (for example arrays)
simpler constraints (for example array elements). Consider, instance, constraint int array plus(As, Sum). decomposed list int plus constraints applying
straightforward divide conquer recursive definition. base case, As=[A]
325

fiMetodi, Codish, & Stuckey

c = allDiff ([Z1 , Z2 , Z3 , . . . , Zn ])
E
add c (E)
dom(Z1 )

/ dom(Zk ) (k > 1)

Z1 = authors

{i, j} dom(Zk ) =
(k > 2)

dom(Z1 ) {i, j}
dom(Z2 ) {i, j}
Z1 6= Z2
Zk 6= i, Zk 6= j
(k > 2)

Figure 14: Simplification rules allDiff .
constraint replaced constraint form int eq(A,Sum) equates bits
Sum, = [A1 , A2 ] replaced int plus(A1 , A2 , Sum). general
case split two halves, constraints generated sum halves,
additional int plus constraint introduced sum two sums.
another example, consider int plus(A1 , A2 , A) constraint. One approach, supported BEE, decomposes constraint odd-even merger (from context
odd-even sorting networks) (Batcher, 1968). Here, sorted sequences bits A1 A2
merged obtain sum A. results model O(n log n) comparator
constraints (and later encoding O(n log n) clauses). Another approach,
supported BEE, decompose constraint encodes directly CNF
size O(n2 ), context so-called totalizers (Bailleux & Boufkhad, 2003). hybrid
approach, leaves choice BEE, depending size domains variables
involved. Finally, note user configure BEE fix way compiles
constraint (and others).
CNF encoding last phase compilation constraint model.
remaining simplified (bit-blasted) constraints encoded directly CNF. encodings
standard similar applied various tools. BEE encodings similar
applied Sugar (Tamura et al., 2009).
6.1 All-Different Constraint BEE
all-different constraint specifies set integer variables take different values
specified domains. constraint received much attention literature
(see example survey van Hoeve, 2001). BEE provides special treatment
constraint.
many applications, all-different constraints applied model special case
constraint permutation. Namely, [I1 , . . . , ] different may
take precisely n different values. BEE identifies special case applies two additional
ad-hoc equi-propagation rules case. table Figure 14 illustrates rules.
annotate constraint * emphasize detected
permutation. first rule case one integer (assume Z1 )
take value i. second rule case variables except two, assume Z1 ,
Z2 , cannot take two values, assume i, j. Now, constraint permutation,
326

fiBoolean Equi-propagation

determine Z1 Z2 must take two values j. illustrate second
rule consider following example.
Example 16. Consider constraint allDiff(I1 , . . . , I5 ) 5 integer variables taking values interval [0, 4] (exactly 5 values) E0 specifies I3 , I4 I5 cannot take
values 0 1. Therefore introduce equations restrict I1 I2 take
values 0 1, corresponding ad-hoc rule permutation applies:
E0
I1
I2
I3
I4
I5



x3,1 =1, x4,1 =1,
x5,1 =1, x3,2 =1,
=


x4,2 =1, x5,2 =1
= [x1,1 , . . . , x1,4 ],
= [x2,1 , . . . , x2,4 ],
= [1, 1, x3,3 , x3,4 ],
= [1, 1, x4,3 , x4,4 ],
= [1, 1, x5,3 , x5,4 ]

dom(Ik ) {0, 1}=
k>2




allDiff

E1
I1
I2
I3
I4
I5



x1,2 =0, . . . , x1,4 =0,
x2,2 =0, . . . , x2,4 =0
= E0


x1,1 =x2,1
= [x1,1 , 0, . . . , 0],
= [x1,1 , 0, . . . , 0],
= [1, 1, x3,3 , x3,4 ],
= [1, 1, x4,3 , x4,4 ],
= [1, 1, x5,3 , x5,4 ]

facilitate implementation ad-hoc equi-propagation all-different constraints,
BEE adopts dual representation integer variables occurring constraints combining order encoding the, so-called, direct encoding. essentially
encoding proposed Gent Nightingale (2004). declaring integer variable I, bit-blast order encoding applies corresponding unification
= [x1 , . . . , xn ]. encountering allDiff constraint, additional bit-blast
introduces I0 = [d0 , . . . , dn ] direct encoding, channeling formula channel(I, I0 )
introduced.
direct encoding unary representation I0 = [d0 , . . . , dn ] bit di true
I0 = i. So, exactly one bits takes value true. example, value
3 interval [0, 5] represented 6 bits [0, 0, 0, 1, 0, 0]. dual representation
following channeling formula captures relation two representations
integer variable = [x1 , . . . , xn ] I0 = [d0 , . . . , dn ].

channel([x1 , . . . , xn ], [d0 , . . . , dn ]) =

d0 = x1
dn = xn




n1
^

(di xi xi+1 )

i=1

Consider allDiff constraint integer variables take different values 0 n. constraint simplification, allDiff([I1 , . . . , Im ]) constraint
viewed direct encoding bit matrix row consists bits
[di0 , . . . , din ] Ii direct encoding. element dij true iff Ii takes value j.
j th column specifies Ii take value j hence, one variable
column may take value true. representation one main advantage:
direct encoding decompose allDiff([I1 , . . . , Im ]), conjunction n + 1 constraints, one column 0 j n, form bool array sum leq([d1j , . . . , dmj ], 1),
arc-consistent. soon di,j = 1 (Ii = j) di,j 0 = 0 (Ii 6= j 0 )
2
j0 6= j. contrast
order encoding alone decomposition O(m ) constraints
int neq(Ii , Ij ) < j
arc-consistent. illustrate advantage dual
encoding allDiff constraint Section 8.1.
327

fiMetodi, Codish, & Stuckey

:- use module(bee compiler, [bCompile/2]).
:- use module(sat solver, [sat/1]).
solve(Instance, Solution) :encode(Instance, Map, Constraints),
bCompile(Constraints, CNF),
sat(CNF),
decode(Map, Solution).

Figure 15: generic application BEE.

7. Using BEE
typical BEE application form depicted Figure 15 predicate solve/2
takes problem Instance provides Solution. specifics application
call encode/3 given Instance generates Constraints solve
together Map relating instance variables constraint variables. calls
bCompile/2 sat/1 compile constraints CNF solve applying SAT solver.
instance solution, SAT solver binds constraint variables accordingly.
Then, call decode/2, using Map, provides Solution terms Instance
variables. definitions encode/3 decode/2 application dependent provided user. predicates bCompile/2 sat/1 part tool provide
interface BEE underlying SAT solver.
7.1 Example BEE Application: Magic Graph Labeling
illustrate application BEE using Prolog modeling language solve graph
labeling problem. Graph labeling finding assignment integers vertices
edges graph subject certain conditions. Graph labellings introduced
60s hundreds papers wide variety related problems published
since then. See example survey Gallian (2011) 1200 references.
Graph labellings many applications. instance radars, X-ray crystallography,
coding theory, etc.
focus vertex-magic total labeling (VMTL) problem one
find graph G = (V, E) labeling one-to-one map V E {1, 2, . . . , |V | +
|E|} property sum labels vertex incident edges
constant K independent choice vertex. problem instance takes form
vmtl(G, K) specifying graph G constant K. context Figure 15,
query solve(vmtl(G, K), Solution) poses question: exist vmtl labeling
G magic constant K? binds Solution indicate labeling one exists,
unsat otherwise. Figure 16 illustrates example problem instance together
solution.
Figure 17 illustrates Prolog program implements encode/3 predicate
VMTL problem. call predicate declareInts/4 introduces constraints
declare integer variables vertex edge graph, generates
map. call predicate sumToK/5 introduces constraints require sum
labels vertex incident edges equals K. auxiliary predicate
328

fiBoolean Equi-propagation

Instance
Instance = vmtl(G, K),
G = (V, E),
V = [1, 2, 3, 4],
E = [(1, 2), (1, 3),
(2, 3), (3, 4)],
K = 14

Graph
4

2

36
666



Solution


1

V1
V2

V3
V4

= 4,
= 5,
= 1,
= 6,

E(1,2)
E(1,3)
E(2,3)
E(3,4)


= 7,
= 3,

= 2,
=8

Figure 16: VMTL instance solution.
encode(vmtl((Vs,Es),K),Map,Constraints):append(Vs,Es,VEs), length(VEs,N),
declareInts(VEs,N,Map,Constraints-Cs2),
sumToK(Vs,Es,Map,K,Cs2-Cs3),
getVars(VEs,Map,Vars),
Cs3=[int array allDiff(Vars)].
declareInts([], , ,Cs-Cs).
declareInts([ID|IDs],N,[(ID,X)|Map],[new int(X,1,N)|CsH]-CsT):declareInts(IDs,N,Map,CsH-CsT).
sumToK([], , , ,Cs-Cs).
sumToK([VID|Vs],Es,Map,K,[int array plus(Vars,K)|CsH]-CsT):findall((X,Y),(member((X,Y),Es),(X=VID ; Y=VID)),EsIDs),
getVars([VID|EsIDs],Map,Vars),
sumToK(Vs,Es,Map,K,CsH-CsT).
getVars([], ,[]).
getVars([ID|IDs],Map,[Var|Vars]):member((ID,Var),Map),
getVars(IDs,Map,Vars).

Figure 17: encode/3 predicate VMTL application BEE
Map
((1, 2), E1 ),(1, V1 ),
((1, 3), E2 ),(2, V2 ),
((2, 3), E3 ),(3, V3 ),
((3, 4), E4 ),(4, V4 )

Constraints
new int(V1 , 1, 8), new int(E1 , 1, 8), int array plus([V1 , E1 , E2 ], K),
new int(V2 , 1, 8), new int(E2 , 1, 8), int array plus([V2 , E1 , E3 ], K),
new int(V3 , 1, 8), new int(E3 , 1, 8), int array plus([V3 , E2 , E3 , E4 ], K),
new int(V4 , 1, 8), new int(E4 , 1, 8), int array plus([V4 , E4 ], K),
new int(K, 14, 14), allDiff([V1 , V2 , V3 , V4 , E1 , E2 , E3 , E4 ])

Figure 18: VMTL instance constraints map generated encode/3.

getVars/3 receives list identifiers (vertices edges) extracts corresponding
list integer variables map.
Given VMTL instance Figure 16, call predicate encode/3 Figure 17
generates map constraints detailed Figure 18.
329

fiMetodi, Codish, & Stuckey

Solving constraints Figure 18 binds Map follows, indicating solution
(in unary order encoding):


(1,
(2,
=
(3,
(4,

[1, 1, 1, 1, 0, 0, 0, 0]),
[1, 1, 1, 1, 1, 0, 0, 0]),
[1, 0, 0, 0, 0, 0, 0, 0]),
[1, 1, 1, 1, 1, 1, 0, 0]),

((1, 2),
((1, 3),
((2, 3),
((3, 4),



[1, 1, 1, 1, 1, 1, 1, 0]),
[1, 1, 1, 0, 0, 0, 0, 0]),
[1, 1, 0, 0, 0, 0, 0, 0]),
[1, 1, 1, 1, 1, 1, 1, 1])

Using BEE compile constraints Figure 18 generates CNF contains 301
clauses 48 Boolean variables. Encoding set constraints without applying
simplification rules generates larger CNF contains 642 clauses 97 Boolean
variables.
Section 8.3 report using BEE enables us solve interesting instances
VMTL problem previously solvable techniques.
7.2 BumbleBEE
BEE distribution includes command line solver, call BumbleBEE.
BumbleBEE enables one specify BEE model input file line contains
single constraint model last line specifies type goal. BumbleBEE
reads input file, compiles constraint model CNF, solves CNF using
embedded CryptoMiniSAT solver (Soos, 2010) outputs set bindings declared
variables model (or message indicating constraints satisfiable).
Figure 19 contains left BumbleBEE input file VMTL instance
Figure 16 right BumbleBEE output, solution constraint
model. example, last line input file specifies goal solver.
options are:
1. solve satisfy: solve single satisfying assignment constraint model;
2. solve satisfy(c): solve (at most) c satisfying assignments constraint model
c integer value. c 0 option solve solutions.
3. solve minimize(I): solve solution minimizes value integer
variable I. solver outputs intermediate solutions (with decreasing values
I) encountered search minimum value I.
4. solve maximize(I): similar minimize, maximizes.
details examples found BEE distribution (Metodi & Codish,
2012).

8. Experiments
report experience applying BEE. appreciate ease use reader
encouraged view example encodings available tool (Metodi & Codish,
2012). experiments run Intel Core 2 Duo E8400 3.00GHz CPU 4GB memory
Linux (Ubuntu lucid, kernel 2.6.32-24-generic). BEE written Prolog run
330

fiBoolean Equi-propagation

Content BumbleBEE input file
new int(V1, 1, 8)
new int(V2, 1, 8)
new int(V3, 1, 8)
new int(V4, 1, 8)
new int(E1, 1, 8)
new int(E2, 1, 8)
new int(E3, 1, 8)
new int(E4, 1, 8)
int array plus([V1, E1, E2], 14)
int array plus([V2, E1, E3], 14)
int array plus([V3, E2, E3, E4], 14)
int array plus([V4, E4], 14)
int array allDiff([V1, V2, V3, V4, E1, E2, E3, E4])
solve satisfy

BumbleBEE output

V1 = 4
V2 = 5
V3 = 1
V4 = 6
E1 = 7
E2 = 3
E3 = 2
E4 = 8

==========

Figure 19: Solving VMTL instance using BumbleBEE.

using SWI Prolog v6.0.2 64-bits. Comparisons Sugar (v1.15.0) based use
identical constraint models, apply SAT solver (CryptoMiniSAT v2.5.1), run
machine. Times reported seconds.
8.1 Quasigroup Completion Problems
Quasigroup Completion Problem (QCP) proposed Gomes, Selman, Crato (1997)
constraint satisfaction benchmark, given n n board integer variables (in
range [1, n]) assigned integer values. task assign values
variables, column row contains value twice. constraint model
conjunction allDiff constraints. Ansotegui, del Val, Dotu, Fernandez, Manya
(2004) argue advantage direct encoding QCP.
consider 15 instances 2008 CSP competition.2 Table 3 considers three
settings: BEE dual encoding allDiff constraints, BEE using order
encoding (equivalent using int neq constraints instead allDiff), Sugar.
table shows: instance identifier (sat unsat), compilation time (comp) seconds,
clauses encoding (clauses), variables encoding (vars), SAT solving time
(SAT) seconds.
results indicate that: (1) Application BEE using dual representation
allDiff 38 times faster produces 20 times fewer clauses (in average)
using order-encoding alone (despite need maintain two encodings); (2) Without
dual representation, solving encodings generated BEE slightly faster
Sugar BEE still generates CNF encodings 4 times smaller (on average)
generated Sugar. Observe 3 instances found unsatisfiable BEE (indicated
2. http://www.cril.univ-artois.fr/CPAI08/. competition instances specified using binary disequalities, use model allDiff.

331

fiMetodi, Codish, & Stuckey

instance

25-264-0 sat
25-264-1 sat
25-264-2 sat
25-264-3 sat
25-264-4 sat
25-264-5 sat
25-264-6 sat
25-264-7 sat
25-264-8 sat
25-264-9 sat
25-264-10 unsat
25-264-11 unsat
25-264-12 unsat
25-264-13 unsat
25-264-14 unsat
Total

BEE (dual
comp clauses
(sec)
0.23 6509
0.20 7475
0.21 6531
0.21 6819
0.21 7082
0.21 7055
0.21 7712
0.21 7428
0.21 6603
0.21 6784
0.21 6491
0.12
1
0.16
1
0.12
1
0.23 5984

encoding)
vars
SAT
(sec)
1317
0.33
1508
3.29
1329
0.07
1374
0.83
1431
0.34
1431
3.12
1551
0.34
1496
0.13
1335
0.18
1350
0.19
1296
0.04
0
0.00
0
0.00
0
0.00
1210
0.07
8.93

BEE (order
comp clauses
(sec)
0.36 33224
0.30 34323
0.30 35238
0.29 32457
0.29 32825
0.30 33590
0.33 39015
0.30 36580
0.27 31561
0.27 35404
0.30 33321
0.28 37912
0.29 39135
0.29 35048
0.28 31093

encoding)
vars
SAT
(sec)
887
8.95
917
97.50
905
2.46
899
18.52
897
19.08
897
46.15
932
69.81
937
19.93
896
10.32
903
34.08
930
10.92
955
0.09
984
0.08
944
0.09
885
11.60
349.58

clauses

Sugar
vars

126733
127222
127062
127757
126777
126973
128354
127106
124153
128423
126999
125373
127539
127026
126628

10770
10798
10787
10827
10779
10784
10850
10794
10687
10853
10785
10744
10815
10786
10771

SAT
(sec)
34.20
13.93
8.06
44.03
85.92
41.04
12.67
7.01
9.69
38.80
57.75
0.47
0.57
0.56
15.93
370.63

Table 3: QCP results 25 25 instances 264 holes
CNF single clause variables). comment Sugar pre-processing
times higher BEE indicated table.
8.2 Word Design DNA
Problem 033 CSPLib seeks largest parameter n, exists
set n eight-letter words alphabet = {A, C, G, } following
properties: (1) word exactly 4 symbols {C, G}; (2) pair
distinct words differ least 4 positions; (3) every x, S: xR (the reverse
x) C (the word obtained replacing , C G, vice versa)
differ least 4 positions.
Mancini, Micaletto, Patrizi, Cadoli (2008) provide comparison several stateof-the-art solvers applied DNA word problem variety encoding techniques.
best reported result solution 87 DNA words, obtained 554 seconds, using
OPL (van Hentenryck, 1999) model lexicographic order break symmetry. Frutos,
Liu, Thiel, Sanner, Condon, Smith, Corn (1997) present strategy solve problem
four letters modeled bit-pairs [t, m]. eight-letter word
viewed combination t-part, [t1 , . . . , t8 ], bit-vector, m-part,
[m1 , . . . , m8 ], bit-vector. authors report solution composed two pairs
(t-part m-part) sets3 [T1 , M1 ] [T2 , M2 ] |T1 | = 6, |M1 | = 16, |T2 | = 2,
|M2 | = 6. forms set (6 16) + (2 6) = 108 DNA words. Marc van Dongen
reports larger solution 112 words.4
Building approach described Frutos et al. (1997), pose conditions sets
t-parts m-parts, , Cartesian product =
satisfy requirements original problem. three conditions below,
required satisfy (10 ) (20 ), required satisfy (20 ) (30 ). set
3. notions t-part m-part slightly different ours.
4. See http://www.cs.st-andrews.ac.uk/~ianm/CSPLib/.

332

fiBoolean Equi-propagation

bit-vectors V , conditions are: (10 ) bit-vector V sums 4; (20 ) pair
distinct bit-vectors V differ least 4 positions; (30 ) pair bit-vectors
(not necessarily distinct) u, v V , uR (the reverse u) v C (the complement v)
differ least 4 positions. equivalent requiring (uR )C differs v
least 4 positions.
strategy model BEE encoding. instance takes form
dna(n1 , n2 ) signifying numbers bit-vectors, n1 n2 sets . Without
loss generality, impose, remove symmetries, lexicographically
ordered. solution Cartesian product = .
Using BEE, find, fraction second, sets t-parts size 14 m-parts
size 8. provides solution size 14 8 = 112 DNA word problem. Running
Comet (v2.0.1) find 112 word solution 10 seconds using model Hakan
Kjellerstrand.5 Using BEE, prove exist set 15 t-parts (0.15
seconds), set 9 m-parts (4.47 seconds). facts unknown prior BEE.
Proving solution DNA word problem 112 words,
without restriction two part t-m strategy, still open problem.
8.3 Vertex Magic Total Labeling
MacDougall, Miller, Slamin, Wallis (2002) conjecture n vertex complete graph,
Kn , n 5 vertex magic total labeling magic constants specific range
values k, determined n. conjecture proved correct odd n verified
brute force n = 6. address cases n = 8 n = 10 involve 15 instances
(different values k) n = 8, 23 (different values k) n = 10. Starting
simple constraint model (illustrated example Figure 16), add additional
constraints exploit fact graphs symmetric: (1) assume edge
smallest label e1,2 ; (2) assume labels edges incident v1
ordered hence introduce constraints e1,2 < e1,3 < < e1,n ; (3) assume
label edge e1,3 smaller labels edges incident v2 (except e1,2 )
introduce constraints accordingly. setting BEE solve except 2 instances
4 hour timeout Sugar solve except 4.
Table 4 gives results 10 hardest instances K8 20 hardest instances K10
4 hour time-out. BEE compilation times order 0.5 sec/instance K8
2.5 sec/instance K10 . Sugar encoding times slightly larger. instances
indicated magic constant, k; columns BEE Sugar indicate SAT solving
times (in seconds). bottom two lines indicate average encoding sizes (numbers clauses
variables).
results indicate Sugar encodings (in average) 60% larger,
average SAT solving time BEE encodings 2 times faster (average excluding instances Sugar times-out).
address two VMTL instances solvable using BEE models described
(K10 magic labels 259 258), partition problem fixing values e1,2
e1,3 maintaining constraints. Analysis symmetry breaking
constraints indicates results 198 new instances two cases.
5. See http://www.hakank.org/comet/word_design_dna1.co.

333

fiMetodi, Codish, & Stuckey

instance
BEE
K8
k
SAT (sec)
143
1.26
142
10.14
141
7.64
140
14.68
139
25.60
138
12.99
137
22.91
136
14.46
135
298.54
134
331.80
Average CNF size:
clauses
248000
vars
5688

Sugar
SAT (sec)
2.87
1.62
2.94
6.46
6.67
2.80
298.58
251.82
182.90


instance
BEE
K10
k
SAT (sec)
277
5.31
276
7.11
275
13.57
274
4.93
273
45.94
272
22.74
271
7.35
270
6.03
269
5.20
268
94.44
267
88.51
266
229.80
265
1335.31
264
486.09
263
236.68
262
1843.70
261
2771.60
260
4873.99
259

258

Average CNF size:
clauses
1229000
vars
15529

402000
9370

Sugar
SAT (sec)
9.25
9.91
19.63
9.24
9.03
86.45
9.49
55.94
11.05
424.89
175.70
247.56
259.45
513.61
648.43
6429.25
7872.76



1966000
25688

Table 4: VMTL results K8 K10 (4 hour timeout)

original VMTL instance solved one 198 instances solved. So, solve
parallel. Fixing e1,2 e1,3 fuels compiler encodings considerably
smaller. instance k = 259 solved 1379.50 seconds e1,2 = 1 e1,3 = 6.
compilation time 2.09 seconds encoding consists 1 million clauses
15 thousand variables.
best knowledge, hard instances suite beyond reach
previous approaches program search magic labels. SAT based approach
presented Jager (2010) cannot handle these.6 comparison Sugar indicates
impact compiler.
8.4 Balanced Incomplete Block Designs
Problem 028 CSPlib (BIBD) instance defined 5-tuple positive
integers [v, b, r, k, ] requires partition v distinct objects b blocks
block contains k different objects, exactly r objects occur block, every two
distinct objects occur exactly blocks.
6. Personal communication (Gerold Jager), March 2012.

334

fiBoolean Equi-propagation

Figure 20: BIBD symmetry breaking.
naive model BIBD instance [v, b, r, k, ] introduces following constraints
v b Boolean incidence matrix: (1) exactly r ones row, (2) exactly k ones
column, (3) exactly ones scalar product two (different) rows.
model contain sufficient degree information trigger equipropagation process. order take advantage BEE simplifications added
symmetry breaking described Frisch, Jefferson, Miguel (2004) illustrated
Figure 20: row viewed sequence four parts . . . sizes , (r ),
(r ), (b 2r + ). first row fixed assigning parts B ones
(marked black) parts C zeros (marked white). second row
fixed assign parts C ones (marked black) parts B zeros
(marked white). third subsequent rows (marked gray), sum constraints decomposed summing part (A . . . D) summing results
follows: + B = , + C = , C + = r , B + = r . ensures
row contains exactly r ones scalar product first (and second) row
. denote constraint model SymB (for symmetry breaking).
instance
[v, b, r, k, ]
[7, 420, 180, 3, 60]
[7, 560, 240, 3, 80]
[12, 132, 33, 3, 6]
[15, 45, 24, 8, 12]
[15, 70, 14, 3, 2]
[16, 80, 15, 3, 2]
[19, 19, 9, 9, 4]
[19, 57, 9, 3, 1]
[21, 21, 5, 5, 1]
[25, 25, 9, 9, 3]
[25, 30, 6, 5, 1]
Total (sec)

comp
(sec)
1.65
3.73
0.95
0.51
0.56
0.81
0.23
0.34
0.02
0.64
0.10

BEE (SymB)
clauses
SAT
(sec)
698579
1.73
1211941 13.60
180238
0.73
116016
8.46
81563
0.39
109442
0.56
39931
0.09
113053
0.17
0
0.00
92059
1.33
24594
0.06
36.66

Sugar (SymB)
comp
clauses
SAT
(sec)
(sec)
12.01 2488136 13.24
11.74 2753113 36.43
83.37 1332241
7.09
4.24
466086

23.58
540089
1.87
64.81
623773
2.26
2.27
125976
0.49



31.91
3716
0.01
42.65
569007
8.52
16.02
93388
0.42
> 722.93

SatELite (SymB)
comp
clauses SAT
(sec)
(sec)
1.67
802576 2.18
2.73 1397188 5.18
1.18
184764 0.57
0.64
134146

1.02
79542 0.20
1.14
105242 0.35
0.4
44714 0.09
10.45
111869 0.14
0.01
0 0.00
1.01
97623 8.93
1.2
23828 0.05
> 219.14

Table 5: BIBD results (180 sec. timeout)
Table 5 shows results comparing BEE (compilation time, clauses encoding, SAT
solving time) Sugar using SymB model. compare BEE SatELite (Een
335

fiMetodi, Codish, & Stuckey

& Biere, 2005), CNF minimizer, input SatELite CNF encoding
SymB model generated BEE without applying simplifications. compilation
time (comp) indicates SatELite pre-processing time. final row indicates total
compilation SAT solving time entire suite approach. cases
time measured seconds.
experiment indicates BEE generates significantly smaller CNF Sugar
affects SAT solving time. Moreover, Sugar compilation time extremely
long. comparing BEE SatELite see output CNF
similar size SatELite applied entire CNF, instances
compilation time significantly longer solving time.
instance
[v, b, r, k, ]
[7, 420, 180, 3, 60]
[7, 560, 240, 3, 80]
[12, 132, 33, 3, 6]
[15, 45, 24, 8, 12]
[15, 70, 14, 3, 2]
[16, 80, 15, 3, 2]
[19, 19, 9, 9, 4]
[19, 57, 9, 3, 1]
[21, 21, 5, 5, 1]
[25, 25, 9, 9, 3]
[25, 30, 6, 5, 1]
Total

BEE (SymB)
comp
SAT
1.65
1.73
3.73 13.60
0.95
0.73
0.51
8.46
0.56
0.39
0.81
0.56
0.23
0.09
0.34
0.17
0.02
0.00
0.64
1.33
0.10
0.06
36.66

[M06]
0.54
0.66
5.51

12.22
107.43
53.23

1.26


>900.00

Minion
SymB
1.36
1.77


1.42
13.40
38.30
1.71
0.67

1.37
>600.00

SymB+
0.42
0.52
1.76
75.87
0.31
0.35
0.31
0.35
0.15
0.92
0.31
81.24

Table 6: BIBD results, comparison Minion (times seconds; 180 sec. timeout).
Table 6 shows results comparing BEE using SymB model Minion constraint
solver (Gent, Jefferson, & Miguel, 2006). consider three different models Minion:
[M06] indicates results using BIBD model described Gent et al. (2006), SymB uses
model use SAT approach, SymB+ , enhanced symmetry breaking
model tricks applied [M06] model. columns
timeouts show total times (for BEE includes compile time SAT solving). Note
using clever modeling problem improved previous run-times
Minion.
experiment indicates BEE significantly faster Minion BIBD
models ([M06]). tailoring SymB model, Minion becomes competitive
ours.
8.5 Combining BEE SatELite
demonstrate impact combining BEE SatELite. describe experiments involving two benchmarks SatELite applied simplify output
BEE. idea first apply powerful, local, techniques, performed BEE.
reduces size CNF fast. apply SatELite takes global
considerations CNF whole. wish determine smaller, simplified,
336

fiBoolean Equi-propagation

CNF amenable simplification using SatELite. results indicate
although CNF size slightly decreased, solving times often increased, sometimes
drastically.
Tables 7 8 show results. tables four columns BEE
heading indicate: BEE compilation time, size encoding (clauses variables),
subsequent SAT solving time. Similarly, four columns SatELite heading
indicate application SatELite output BEE: SatELite processing time,
size resulting CNF (clauses variables), subsequent SAT solving time.
Table 7 illustrates results BIBD benchmark Section 8.4 Table 8, results
10 hardest VMTL instances K8 K10 described Section 8.3. Observe
applying SatELite output BEE decreases CNF size slightly
improve SAT solving time. fact, contrary, cases renders CNF
takes time solve. several cases, SAT solving time increases drastically
introduce timeout.
instance
[v, b, r, k, ]
[7, 420, 180, 3, 60]
[7, 560, 240, 3, 80]
[12, 132, 33, 3, 6]
[15, 45, 24, 8, 12]
[15, 70, 14, 3, 2]
[16, 80, 15, 3, 2]
[19, 19, 9, 9, 4]
[19, 57, 9, 3, 1]
[21, 21, 5, 5, 1]
[25, 25, 9, 9, 3]
[25, 30, 6, 5, 1]

comp
(sec)
1.65
3.73
0.95
0.51
0.56
0.81
0.23
0.34
0.02
0.64
0.10

BEE
clauses
vars
698579
1211941
180238
116016
81563
109442
39931
113053
0
92059
24594

41399
58445
31947
19507
19693
26223
9273
6576
0
22098
2160

SAT
(sec)
1.73
13.60
0.73
8.46
0.39
0.56
0.09
0.17
0.00
1.33
0.06

comp
(sec)
1.88
3.14
1.20
0.66
0.98
1.13
0.38
12.49
0.00
0.97
1.14

SatELite
clauses
vars
696914
1209788
179700
115938
78630
104760
39805
112314
0
91736
24028

38749
54043
28351
17642
15877
21116
7988
6230
0
18540
1926

SAT
(sec)
3.41
6.97
0.91

0.35
0.50
0.16
0.37
0.00
10.34
0.09

Table 7: BIBD results, BEE combined SatELite (180 sec. timeout)
results demonstrate application SatELite remove redundancies
CNF often non-beneficial. Presumably difference see application
SatELite CNF benchmarks results fact BEE produces highly
optimized CNF output, many CNF benchmarks significant inefficiency
original encoding. BEE removes variable CNF, instantiates
variable, either constant equivalent variable, remove
potential propagations encoding, captured Theorem 9.

9. Conclusion
considerable body work CNF simplification techniques clear trade-off
amount reduction achieved invested time. approaches determine binary clauses implied CNF, certainly enough determine Boolean
equalities. problem determining binary clauses implied CNF
prohibitive SAT model may involve many (hundreds of) thousands variables.
337

fiMetodi, Codish, & Stuckey

instance

K8

K10

143
142
141
140
139
138
137
136
135
134
267
266
265
264
263
262
261
260
259
258

comp
(sec)
0.51
0.27
0.20
0.19
0.18
0.18
0.18
0.18
0.18
0.18
0.65
0.65
0.65
0.65
0.65
0.65
0.65
0.65
0.65
0.65

BEE
clauses
vars
248558
248414
248254
248078
247886
247678
247454
247214
246958
246686
1228962
1228660
1228338
1227996
1227634
1227252
1226850
1226428
1225986
1225524

5724
5716
5708
5700
5692
5684
5676
5668
5660
5652
15529
15529
15529
15529
15529
15529
15529
15529
15529
15529

SAT
(sec)
1.26
10.14
7.64
14.68
25.6
12.99
22.91
14.46
298.54
331.8
88.51
229.8
1335.31
486.09
236.68
1843.7
2771.6
4873.99



comp
(sec)
2.60
2.59
2.59
2.60
2.59
2.60
2.59
2.59
2.58
2.59
3.02
3.01
3.02
3.02
3.01
3.02
3.04
3.02
3.03
3.01

SatELite
clauses
vars
248250
248107
247947
247771
247579
247371
247147
246907
246651
246379
1228368
1228066
1227744
1227402
1227040
1226658
1226256
1225834
1225392
1224930

5452
5445
5437
5429
5421
5413
5405
5397
5389
5381
14990
14990
14990
14990
14990
14990
14990
14990
14990
14990

SAT
(sec)
0.98
3.22
32.81
3.50
6.18
12.18
77.16
97.69
705.48

430.00
259.55
540.48
63.74
1008.06
1916.73





Table 8: VTML results, BEE combined SatELite (4 hour timeout)

Typically implied binary clauses determined, visible
unit propagation. trade-off regulated choice techniques applied infer
binary clauses, considering power cost. See example work Een Biere
(2005) references therein. approaches (Li, 2003) detect use
Boolean equalities run-time, complementary approach.
approach, beast tamed introducing notion locality.
consider full CNF. Instead, maintaining original representation, conjunction
constraints, viewed Boolean formula, apply powerful reasoning techniques
separate parts model maintain efficient pre-processing.
end, introduce BEE, compiler follows approach encode finite
domain constraints CNF. Applying optimizations based ad-hoc equi-propagation
partial evaluation rules high level view problem allows us simplify problem
aggressively possible CNF representation. resulting CNF models
significantly smaller resulting straight translation.
well-understood making CNF smaller ultimate goal: often smaller
CNFs harder solve. Indeed, one often introduces redundancies improve SAT
encodings: removing counterproductive. experience BEE reduces
size encoding way productive subsequent SAT solving.
particular, removing variables determined compile time definitely
equal (or definitely different) solution.
338

fiBoolean Equi-propagation

BEE uses ad-hoc equi-propagation partial evaluation rules keeps compilation
times typically small (measured seconds) even instances result several millions
CNF clauses. reduction SAT solving time larger orders magnitude.
Hence, believe Boolean equi-propagation makes important contribution
encoding CSPs SAT.
BEE currently tuned represent integers order encoding. Ongoing work
aims extend BEE binary additional number representations mixed radix
bases considered Een Sorensson (2006) Codish, Fekete, Fuhs,
Schneider-Kamp (2011).
Acknowledgments
thank Vitaly Lagoon many insightful discussions concerning research.
NICTA funded Australian Government represented Department
Broadband, Communications Digital Economy Australian Research Council ICT Centre Excellence Program.

References
Ansotegui, C., del Val, A., Dotu, I., Fernandez, C., & Manya, F. (2004). Modeling choices
quasigroup completion: SAT vs. CSP. McGuinness, D. L., & Ferguson, G. (Eds.),
AAAI, pp. 137142, San Jose, California, USA. AAAI Press / MIT Press.
Asn, R., Nieuwenhuis, R., Oliveras, A., & Rodrguez-Carbonell, E. (2011). Cardinality
networks: theoretical empirical study. Constraints, 16 (2), 195221.
Bagnara, R., & Schachte, P. (1998). Factorizing equivalent variable pairs ROBDDbased implementations Pos. Haeberer, A. M. (Ed.), Algebraic Methodology
Software Technology, 7th International Conference, AMAST 98, Amazonia, Brasil,
January 4-8, 1999, Proceedings, Vol. 1548 Lecture Notes Computer Science, pp.
471485.
Bailleux, O., & Boufkhad, Y. (2003). Efficient CNF encoding Boolean cardinality constraints. Rossi, F. (Ed.), CP, Vol. 2833 LNCS, pp. 108122, Kinsale, Ireland.
Springer.
Barrett, C., Stump, A., & Tinelli, C. (2010). Satisfiability Modulo Theories Library
(SMT-LIB). www.SMT-LIB.org.
Batcher, K. E. (1968). Sorting networks applications. AFIPS Spring Joint
Computing Conference, Vol. 32 AFIPS Conference Proceedings, pp. 307314, Atlantic City, NJ, USA. Thomson Book Company, Washington D.C.
Bessiere, C., Katsirelos, G., Narodytska, N., & Walsh, T. (2009). Circuit complexity
decompositions global constraints. Proceedings IJCAI 2009, pp. 412418.
Cadoli, M., & Schaerf, A. (2005). Compiling problem specifications SAT. Artificial
Intelligence, 162 (1-2), 89120.
339

fiMetodi, Codish, & Stuckey

Codish, M., Fekete, Y., Fuhs, C., & Schneider-Kamp, P. (2011). Optimal base encodings
pseudo-Boolean constraints. Abdulla, P. A., & Leino, K. R. M. (Eds.), TACAS,
Vol. 6605 Lecture Notes Computer Science, pp. 189204. Springer.
Codish, M., Lagoon, V., & Stuckey, P. J. (2008). Logic programming satisfiability.
TPLP, 8 (1), 121128.
Codish, M., & Zazon-Ivry, M. (2010). Pairwise cardinality networks. Clarke, E. M., &
Voronkov, A. (Eds.), LPAR (Dakar), Vol. 6355 Lecture Notes Computer Science,
pp. 154172. Springer.
Coudert, O., & Madre, J. C. (1990). unified framework formal verification
sequential circuits. ICCAD, pp. 126129.
Crawford, J. M., & Baker, A. B. (1994). Experimental results application satisfiability algorithms scheduling problems. Hayes-Roth, B., & Korf, R. E. (Eds.),
AAAI, Vol. 2, pp. 10921097, Seattle, WA, USA. AAAI Press / MIT Press.
Een, N., & Biere, A. (2005). Effective preprocessing SAT variable clause
elimination. Bacchus, F., & Walsh, T. (Eds.), SAT, Vol. 3569 Lecture Notes
Computer Science, pp. 6175. Springer.
Een, N., & Sorensson, N. (2003). extensible SAT-solver. Giunchiglia, E., & Tacchella, A. (Eds.), SAT, Vol. 2919 Lecture Notes Computer Science, pp. 502518.
Springer.
Een, N., & Sorensson, N. (2006). Translating pseudo-Boolean constraints SAT. JSAT,
2 (1-4), 126.
Frisch, A. M., Jefferson, C., & Miguel, I. (2004). Symmetry breaking prelude implied
constraints: constraint modeling pattern. Proc. 16th Euro. Conf. AI, 171175,
pp. 171175. Press.
Frutos, A. G., Liu, Q., Thiel, A. J., Sanner, A. M. W., Condon, A. E., Smith, L. M., &
Corn, R. M. (1997). Demonstration word design strategy DNA computing
surfaces. Journal Nucleic Acids Research, 25 (23), 47484757.
Gallian, J. A. (2011). dynamic survey graph labeling. Electronic Journal
Combinatorics, 18.
Gavanelli, M. (2007). log-support encoding CSP SAT. Bessiere, C. (Ed.),
CP, Vol. 4741 LNCS, pp. 815822, Providence, RI, USA. Springer.
Gelder, A. V. (2005). Toward leaner binary-clause reasoning satisfiability solver. Ann.
Math. Artif. Intell., 43 (1), 239253.
Gent, I. P., Jefferson, C., & Miguel, I. (2006). Minion: fast scalable constraint solver.
Brewka, G., Coradeschi, S., Perini, A., & Traverso, P. (Eds.), ECAI, Vol. 141
Frontiers Artificial Intelligence Applications, pp. 98102. IOS Press.
Gent, I. P., & Nightingale, P. (2004). new encoding alldifferent SAT. Proceedings
3rd International Workshop Modeling Reformulating Constraint Satisfaction Problems, http://www-users.cs.york.ac.uk/frisch/Reformulation/04/
proceedings.pdf.
340

fiBoolean Equi-propagation

Gomes, C. P., Selman, B., & Crato, N. (1997). Heavy-tailed distributions combinatorial
search. Smolka, G. (Ed.), CP, Vol. 1330 LNCS, pp. 121135. Springer.
Heule, M., Jarvisalo, M., & Biere, A. (2011). Efficient CNF simplification based binary
implication graphs. Sakallah, K. A., & Simon, L. (Eds.), SAT, Vol. 6695 Lecture
Notes Computer Science, pp. 201215. Springer.
Huang, J. (2008). Universal Booleanization constraint models. CP2008, Vol. 5202
Lecture Notes Computer Science, pp. 144158.
Jager, G. (2010). effective SAT encoding magic labeling. Faigle, U., Schrader, R.,
& Herrmann, D. (Eds.), CTW, pp. 97100.
Li, C. (2003). Equivalent literal propagation DLL procedure. Discrete Applied
Mathematics, 130 (2), 251276.
MacDougall, J., Miller, M., Slamin, M., & Wallis, W. (2002). Vertex-magic total labelings
graphs. Utilitas Mathematica, 61, 321.
Mancini, T., Micaletto, D., Patrizi, F., & Cadoli, M. (2008). Evaluating ASP commercial
solvers CSPLib. Constraints, 13 (4), 407436.
Manthey, N. (2012). Coprocessor 2.0 - flexible CNF simplifier - (tool presentation).
Cimatti, A., & Sebastiani, R. (Eds.), SAT, Vol. 7317 Lecture Notes Computer
Science, pp. 436441. Springer.
Metodi, A. (2012). BEE. http://amit.metodi.me/research/bee/.
Metodi, A., & Codish, M. (2012). Compiling finite domain constraints SAT BEE.
TPLP, 12 (4-5), 465483.
Metodi, A., Codish, M., Lagoon, V., & Stuckey, P. J. (2011). Boolean equi-propagation
optimized SAT encoding. Lee, J. H.-M. (Ed.), CP, Vol. 6876 LNCS, pp. 621636.
Springer.
Nethercote, N., Stuckey, P. J., Becket, R., Brand, S., Duck, G. J., & Tack, G. (2007).
Minizinc: Towards standard CP modeling language. Bessiere, C. (Ed.), CP2007,
Vol. 4741 Lecture Notes Computer Science, pp. 529543, Providence, RI, USA.
Springer-Verlag.
Somenzi, F. (2009). CUDD: Colorado University Decision Diagram package. (Online,
accessed 13 April 2011). http://vlsi.colorado.edu/~fabio/CUDD/.
Soos, M. (2010). CryptoMiniSAT, v2.5.1. http://www.msoos.org/cryptominisat2.
Tamura, N., Taga, A., Kitagawa, S., & Banbara, M. (2009). Compiling finite linear CSP
SAT. Constraints, 14 (2), 254272.
Tarjan, R. (1975). Efficiency good linear set union algorithm. JACM, 22 (2),
215225.
van Hentenryck, P. (1999). OPL Optimization Programming Language. MIT Press.
van Hoeve, W. J. (2001). alldifferent constraint: survey.. CoRR:http://arxiv.org/
abs/cs.PL/0105015.

341


