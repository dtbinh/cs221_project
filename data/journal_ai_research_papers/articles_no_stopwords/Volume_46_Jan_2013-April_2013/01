journal artificial intelligence

submitted published

optimal rectangle packing
absolute placement
eric huang

ehuang parc com

palo alto center
coyote hill road
palo alto ca usa

richard e korf

korf cs ucla edu

ucla computer science department
e boelter hall
university california los angeles
los angeles ca usa

abstract
consider finding enclosing rectangles minimum area
contain given set rectangles without overlap rectangle packer chooses xcoordinates rectangles coordinates transform
perfect packing empty space adding additional rectangles determine coordinates branch different rectangles
placed empty position packer allows us extend known solutions
consecutive square benchmark squares introduce three benchmarks avoiding properties make benchmark easy rectangles shared
dimensions third benchmark consists rectangles increasingly high precision
pack efficiently limit rectangles coordinates bounding box dimensions
set subset sums rectangles dimensions overall represent
current state art outperforming orders
magnitude depending benchmark

introduction
given set rectangles enclosing rectangles minimum area
contain without overlap refer enclosing rectangle bounding box
avoid confusion optimization np hard deciding
whether set rectangles packed given bounding box np complete via
reduction bin packing korf consecutive square benchmark simple set
increasingly difficult benchmarks task bounding
boxes minimum area contain set squares dimensions
n n korf example figure optimal solution n
use benchmark explain many ideas techniques
limited packing squares apply rectangles
rectangle packing many practical applications including modeling scheduling tasks require resources allocated contiguous chunks
example consider task scheduling allocating contiguous memory addresses
programs width rectangle represents length time program runs
c

ai access foundation rights reserved

fihuang korf

figure optimal solution n consecutive square benchmark packing
squares dimensions bounding box minimum
area



fioptimal rectangle packing absolute placement

height represents amount contiguous memory needs rectangle packing solution
tells us programs run well memory addresses
assigned similar include scheduling ships different length
berthed along single long wharf li leong quek well allocation scheduling radio frequency spectra usage mitola maguire rectangle
packing appears loading set rectangular objects pallet without stacking
cutting stock layout contain rectangle packing subproblems
overview
remainder article organized follows first introduce benchmarks section specifically define rectangle packing instances solve
section review state art rectangle packers techniques
provides foundation upon present work follow section
data collected compare work previous state art previous
benchmarks compare difficulty previous benchmarks ones
section present benchmark rectangles successively higher precision
dimensions solution techniques handle follow experimental
compare methods competing search spaces used packing highprecision rectangles methods remain competitive
sections explain avenues future work concluding article
summarizing contributions previously published much
work several conference papers huang korf

benchmarks
several reasons motivating benchmarks first benchmarks describe
instances single parameter n allowing researchers easily reproduce instances
second instances unique optimal solutions reported easily
validated others advantages many real world instance libraries
randomly generated ones third benchmarks define infinite set instances
successive instance harder previous solver superior another solver
solve instance faster larger instance amount time
contrast comparison library instances may require counting number
instances completed within given time limit furthermore instance libraries
often one solver performs well one subset instances competing solver performs
well different subset making comparisons inconclusive
believe benchmarks capture difficult instances rectangle
packer may face investigate modeling generation random
although clautiaux et al others used random instances non random
benchmarks used korf simonis osullivan better facilitated
comparison state art packers however comprehensive overviews
refer reader numerous surveys available lodi martello vigo lodi
martello monaci dowsland dowsland sweeney paternoster


fihuang korf

previous benchmarks
several previous benchmarks used literature shown easier
benchmarks propose part due fact benchmarks solvers
may improved ensure cover properties
rectangles addition providing easy way compare performance among different
packers measure progress
consecutive square benchmark korf simple set increasingly difficult
instances task bounding boxes minimum area contain set
squares sizes n n prior work many recent stateof art packers used popular benchmark measure performance including
moffitt pollack korf moffitt pollack simonis osullivan
date largest instance solved n shown figure
packer huang korf consider packing squares
square benchmark gets much easier size increases due
large differences areas consecutive square bounding boxes
unoriented consecutive rectangle benchmark korf et al instance
set rectangles sizes n n rectangles may
rotated degrees subsequently explain fact many pairs
rectangles instance share equal dimensions causes optimal solutions
leave empty space making benchmark easy solve include benchmark
completeness note effective measure comparing different packers
finding first optimal solution another benchmark simonis osullivan
used conjunction instances unoriented consecutiverectangle benchmark contrast finding optimal solutions
measure time takes first optimal solution makes much
difficult reliably compare solvers unless focus value
ordering tie breaking among bounding boxes equal area
example simonis osullivan report first solution
n takes hours minutes seconds shown table page
six solutions n
requiring solver cpu times
respectively smaller bounding boxes needed test optimal
solution empty space used simonis osullivans termination criteria
returned first optimal solution would need seconds therefore finding
minimum bounding boxes instead first one benchmark produces
harder larger n better facilitates program comparisons
properties easy benchmarks avoid
motivate benchmarks explain previous benchmarks tended
much easier comparison constructed benchmarks
describe instances consisting rectangles unique dimensions without duplicates
without area occupied rectangles


fioptimal rectangle packing absolute placement

solution bounding
box unoriented instance


b solution bounding
box unoriented instance


figure examples solutions instances rectangles equal dimensions

rectangles equal dimensions
unoriented consecutive rectangle benchmark rectangles share dimension
another rectangle example figure optimal solution n optimal
solutions rectangles equal dimensions tend line next forming larger
rectangles leaving little empty space figure line
fact solutions
benchmark much smaller percentage empty space similar sized instances
consecutive square benchmark rectangles unique dimensions
notice benchmarks duplicate rectangles figure b solved
quickly
rectangles small area small dimensions
figure b example perfect packing empty space
solution perfect packings tend easy two reasons one
test bounding boxes increasing order area test fewer boxes since never test
box minimum area required second
rather deciding rectangle go bounding box
efficient decide cell empty space rectangle occupy


fihuang korf

soon small region empty space created cant accomodate remaining
rectangles backtrack
consecutive square unoriented rectangle benchmarks large
rectangles capture much total area instance thus packer search
deeply allowable empty space little empty space early
backtracking likely since cannot place next rectangle therefore
small rectangles benchmarks insignificant impact search effort
previous benchmarks consecutive square benchmark retangles
largest area largest dimensions making obvious rectangles
place first largest rectangles constrained impose
constraints remaining rectangles
contrast benchmarks trade rectangles large
dimensions large area widest rectangle oriented equal perimeter benchmark described smallest branching factor search xcoordinates however least area search wont constrain
placement remaining rectangles much raises non trivial question best
variable ordering non square rectangles
benchmarks
propose several benchmarks difficult comparing instances
number rectangles experimental make use following
benchmarks addition consecutive square unoriented consecutive rectangle
benchmarks described
equal perimeter rectangles
first present oriented equal perimeter rectangle benchmark instance
set rectangles sizes n n n n rectangles may
rotated see figure given n rectangles unique perimeter n
experiments benchmark much difficult consecutive square
benchmark unoriented consecutive rectangle benchmark korf et al
number rectangles tested state art packer huang korf
old benchmarks n oriented equal perimeter benchmark
took nine hours solve n consecutive square unoriented
consecutive rectangle benchmarks took one second six seconds respectively
second present unoriented double perimeter rectangle benchmark instances described set rectangles n n n n
n n rectangles may rotated degrees rectangles unique
perimeter n benchmark difficult benchmarks
used previously literature benchmark difficult oriented
one introduced previous paragraph experiments techniques
n took two days solve
far benchmarks discussed low precision integer dimensions
property poses packer enumerates integer coordinate locations rectangle may placed high precision values however


fioptimal rectangle packing absolute placement

figure optimal solution n oriented equal perimeter benchmark packing
oriented rectangles dimensions bounding box
minimum area



fihuang korf

number distinct positions increases dramatically motivates study packing rectangles high precision dimensions particular propose unoriented
high precision rectangle benchmark instances described set rectangles





n n methods used solve benchmark quite
different used low precision case

solution techniques
section describe previous solution strategies well techniques
use rectangle packer first describe techniques apply consecutive square benchmark oriented equal perimeter benchmark unoriented
double perimeter benchmark work unoriented high precision rectangle benchmark included methods significantly different deferred
section
previous work
earlier work focused optimal methods packing set rectangles
given bounding box motivated pallet loading dowsland
used depth first search abstract graph representation search space solve
optimally sets modeled real world pallet box dimensions
although instances contained average rectangles
benchmarks far easier consider rectangles
size significant amount empty space solutions bhattacharya
et al extended work additional lower bounds pruning techniques
dominance conditions demonstrated work benchmarks
examining rectangle packing instances rectangles different dimensions
onodera et al used depth first search branching point search
space commitment particular non overlap constraint two rectangles
lower bound graph reduction techniques applied prune search space allowing optimally solve six rectangles
chan markovs blobb packer used branch bound order
minimum area bounding box contain set rectangles solver could handle
eleven rectangles observed instances duplicate rectangles
much easier causing packer cluster rectangles together optimal solution
lesh et al solver used depth first search placing rectangle first bottommost left position fit bottom left heuristic see chazelle
determine whether set rectangles packed given enclosing rectangle
able handle twenty nine rectangles ten minutes average
testbed consisted instances whose optimal solutions empty space
clautiaux et al presented branch bound method x coordinates rectangles computed prior coordinates assigning
x coordinates method uses relaxation similar cumulative constraint aggoun
beldiceanu requires sum heights rectangles overlapping
particular x coordinate cannot exceed height bounding box coordinates
determined search space derived bottom left heuristic chazelle


fioptimal rectangle packing absolute placement

optimized data structures martello vigo beldiceanu
carlsson applied plane sweep used computational geometry detect violations non overlap constraints later adapted technique geometric
constraint kernel beldiceanu carlsson poder sadek truchet lipovetskii
proposed branch bound placed rectangles lower left hand positions
prior state art due korf simonis osullivan
divide rectangle packing containment minimal
bounding box former tries pack given set rectangles given bounding
box latter finds bounding box least area contain given set
rectangles packers minimal bounding box calls
containment subroutine
overall search strategy
korf et al minimum bounding box solver calls
containment solver simonis osullivan assign x coordinates
prior coordinates
although use simonis osullivans ideas take
constraint programming constraints specified general purpose
solver prolog instead implemented program scratch c allowing us
flexibly choose constraints use time naturally encode
search space use coordinates implemented chronological backtracking
dynamic variable ordering works five stages goes
root search tree leaves
minimum bounding box generates initial candidate set bounding
boxes widths heights
containment solver called bounding box order increasing area
infeasible bounding box insert another back candidate set
bounding boxes height one unit greater packing found continue
testing boxes equal area optimal solutions terminating
containment solver first works x coordinates model variables
rectangles values x coordinate locations dynamic variable ordering
constraint detects infeasible subtrees
x coordinate solution found transformed perfect packing instance
searches set coordinates model variables empty corners
values rectangles
describe detail steps


fihuang korf

minimum bounding box
one way solve minimum bounding box minimum maximum
areas describing set candidate potentially optimal bounding boxes boxes
sizes generated areas within range tested non decreasing order
area solutions smallest area found lower bound area
sum areas given rectangles upper bound area determined
bounding box greedy solution found setting bounding box height
tallest rectangle placing rectangles first available position
scanning left right column scanning bottom top
several techniques korf use prune set bounding
boxes review first generate set widths bounding boxes
starting width widest rectangle width greedy solution
described width generate feasible height lower bounds
subsequently describe resulting bounding boxes used initialize
min heap sorted non decreasing order area search proceeds calling
containment solver bounding box minimal area heap box infeasible
increase height box one insert box back min heap
given bounding box width initialize height maximum following
lower bounds first height must least height tallest rectangle
instance second height must large enough accommodate total area
rectangles instance third every pair rectangles sum widths
exceed width bounding box bounding box height must least
sum heights since cant appear side side one must top
fourth set rectangles whose widths greater half width
bounding box must stacked vertically including rectangle smallest height
whose width exactly half width bounding box finally certain properties
exist given rectangle packing instance force height greater equal
width break symmetry example one sufficient property instance
consisting squares since solution w h bounding box easily transforms
another one h w bounding box another sufficient property every rectangle
dimensions w h correspond another one dimensions h w
unoriented instances given bounding box width certain rectangles may forced
one orientation improving lower bound bounding box height note
break symmetry bounding box dimensions every unoriented instance
anytime
instance many rectangles immediate solution required
korf provides anytime bounding box replacing one
described calls containment solver first greedy
solution bounding box whose height equal tallest rectangle described
previous section repeatedly call containment solver following
way previous attempt given bounding box resulted packing area
greater area best solution seen far decrease width
one unit attempt solve resulting bounding box instead previous


fioptimal rectangle packing absolute placement

attempt infeasible increase height bounding box one unit
terminates width current bounding box less width
widest rectangle
containment
korfs absolute placement modeled rectangles variables positions
bounding box values rectangles placed turn depth first search
possible locations tested rectangle contrast simonis osullivans
packer assigned x coordinates rectangles coordinates
suggested clautiaux et al well cumulative constraint aggoun
beldiceanu improving performance orders magnitude cumulative
constraint adds height rectangles overlap given x coordinate location
pruning values exceed height bounding box constraint
checked exploring x coordinates exploring coordinates later
improved exploring coordinates differently modeling candidate locations
variables rectangles values huang korf made packer
order magnitude faster simonis osullivans
simonis osullivan furthermore applied least commitment principle yap
constraint processing first committing placement rectangles
interval x coordinates instead single x coordinate value x intervals
explored turn constrain candidate individual x coordinates explored later
works committing x interval induce pruning via cumulative constraint
example picking x interval b size smaller width
rectangle wr implies regardless x coordinate rectangle eventually takes
must contribute height x coordinate within interval b wr finally
height bounding box constrains cumulative heights rectangles
given x coordinate similar ideas beldiceanu et al larger intervals
weaker constraint propagation less pruning smaller branching factor smaller
intervals stronger constraint propagation larger branching factor size
intervals experimentally determined
example rectangle x coordinates restricted interval contributes height x coordinates even prior deciding exact x coordinate
value compulsory part lahrichi constrains cumulative height rectangles may overlap x coordinates solution interval assignments
infeasible searching individual x values futile however
set interval assignments still search set single x coordinate
values simonis osullivan assigned x intervals single x coordinates intervals
single coordinates order
assigning x intervals x coordinates
x coordinates propose pruning constraint adapted korfs wastedspace pruning heuristic dynamic variable order replace beldiceanus fixed ordering method optimize values assigned x interval variables


fihuang korf

figure test violations cumulative constraint remaining space
placing rectangle x represented vector h

pruning infeasible subtrees
present constraint formulation korfs two dimensional wasted space
pruning adapted one dimensional case given partial solution korfs
computed lower bound amount wasted space used
prune upper bound contrast compute numerical bounds
instead detect infeasibility single constraint
rectangles placed bounding box remaining empty space gets chopped
small irregular regions eventually empty space segmented small enough
chunks cannot accommodate remaining unplaced rectangles
point backtrack assigning x coordinates bounding box height h
keep histogram hv v vh vi number empty cells units empty
space empty columns height example assume figure
assigned x coordinates rectangle bounding box resulting
histogram would h since cells empty columns height empty
cells columns height cells empty columns height
assume left place rectangle assign
six cells rectangle empty cells v leaving us remaining
empty cells h point cannot assign area
empty cells accommodate height need prune
general set unplaced rectangles r bounding box height h

h

x

wr hr

rr hr h

h
x


vi



h

rectangle r r dimensions wr hr every given height h
amount space accommodate rectangles height h greater must least
cumulative area rectangles height h greater check constraint
x coordinate assignment


fioptimal rectangle packing absolute placement

x dominated position
square

b x undominated position
square

figure example dominance conditions

pruning dominance conditions
korf introduced set dominance conditions prune positions large rectangles close sides bounding box example imagine must pack
squares figure placement square leaves
gap left side bounding box square cannot fit
squares fit within gap fact placed
entirely within gap notice solution arrangement figure
rearrange figure b without disturbing squares thus
need try placing square x long tried placing
x general rectangle placement dominated leaves gap rectangles
individually fit packed together gap without protruding
although korf hard coded dominance rules consecutive square benchmark
dynamically generate every instance insignificant preprocessing overhead
variable ordering
following subsections consider two variable orders work together packer
use fixed ordering governs rectangle assigned next ordering used
x intervals independently use single x coordinate variables
point time must choose whether assign next x interval next
single x coordinate variable since ordering x intervals single x coordinate
variables simpler present technique first
ordering x intervals x coordinates area variable order
observation placing rectangles larger area constraining
placing smaller area times choose assign single
x coordinate rectangle previously assigned x interval
assign x interval rectangle yet made assignments shown
figure assignments decrease amount empty space represented
cumulative constraint vector pick next variable
least remaining space


fihuang korf

ordering among rectangles branching factor natural variable order
arises consecutive square unoriented consecutive rectangle benchmarks strategy picking constrained variable next example
consecutive square benchmark largest rectangle clearly largest height
width area however benchmarks rectangle largest width
smallest height largest area making good variable ordering non obvious
propose variable order rectangles aspect ratios picking
variable fewest number values first favor smaller branching factor closer
root search tree oriented equal perimeter benchmark recall
assign intervals x coordinates individual x coordinates simonis
sullivan use constant factor times rectangle width define interval
size branching factor x interval variables given rectangle

bw rw

bw
b



crw
c rw
c
bw bounding box width rw rectangle width c constant chosen
experimentally numerator bw rw number x coordinate values
rectangle still fitting bounding box denominator crw
size interval assigning given rectangle example c
would assign intervals size three rectangle
may drop translational constant c well positive scalar bw c since
interested relative ordering rectangles leaving us rw
means oriented benchmark place rectangles order decreasing
width unoriented double perimeter benchmark packer first tries values
particular x interval rotates rectangle degrees trying another set
x interval values case branching factor


bw rw
bw
bw rh


b





crw
crh
c rw
rh
c
mentioned drop scalar translational constant giving us

rw rh





rw
rh
rw rh
rectangles given instance perimeter definition
numerator equation constant therefore unoriented benchmark
place rectangles order decreasing area
determining sizes x intervals
consecutive square benchmark packer used interval size times
width given rectangle found larger interval sizes improve performance
packer equal perimeter benchmarks use value c instead
assign larger intervals short wide rectangles x interval variables
rectangles tend branching factors three less balance
sizes intervals values assigned equally constraining subtrees
example consider c rectangle width set possible x coordinate


fioptimal rectangle packing absolute placement

values without balancing sizes intervals packer would explore interval
sizes c x x finally remaining domain values
small interval x small compulsory parts therefore
large search subtrees first two branches large compulsory part thus
small search subtree third
since must explore three branches anyway balance sizes interval
assignments exploring x x x eventual effect better
balance size search subtrees amongst branches packer first computes
branching factor induced global interval parameter c rectangle
balances number values interval assignment
interactions interval assignment dominance conditions consecutive square instances squares several positions following x
dominated therefore packer first branches assigning degenerate interval x exploring interval assignments undominated positions although
technique increased performance packer fivefold compared leaving
strategy slowed performance fivefold oriented unoriented doubleperimeter benchmark reason degradation performance follows
equal perimeter benchmarks n rectangle partially fit gaps
left rectangles must protrude gaps thereby eliminating
dominance conditions previously described without dominated positions
account simply applying strategy used consecutive squares
benchmarks packer committing single x coordinate values situations
desirable include positions larger interval assignment
avoid packer detects dominated positions dynamically
chooses whether assign degenerate interval x coordinate assignment
immediately begin interval assignments
perfect packing transformation
every complete x coordinate solution transform instance perfect
packing instance working coordinates perfect packing instance
rectangle packing property solution empty space
transformation done adding original set rectangles number
rectangles necessary increase total area rectangles bounding box
although rectangles increase size hope ease
solving perfect packing instances offset difficulty packing rectangles next
describe search space perfect packing methods rely
perfect packing property empty space
assigning coordinates
alternative asking rectangle go ask rectangle
go former model rectangles variables empty locations
values whereas latter empty locations variables rectangles values
coordinates search latter model use bitmap draw placed rectangles


fihuang korf

test overlap backtrack positions cannot accommodate remaining
rectangles required korfs wasted space pruning rule
empty corner model
perfect packing solutions every rectangles lower left corner fits lower left
empty corner formed rectangles sides bounding box combination
model one variable per empty corner final solution since
rectangle goes exactly one empty corner number empty corner variables
equal number rectangles perfect packing instance set values
set unplaced rectangles
search space interesting property variables dynamically created
search x coordinates empty corner known
rectangles create placed furthermore placing rectangle empty corner
assigns x coordinates
note empty corner model describe perfect packing solutions given
perfect packing solution list unique sequence rectangles scanning
left right bottom top lower left corners rectangles sequence
corresponds sequence assignments root search space leaf
tree property bounds maximum size search space n n
number rectangles performed perfect packing transformation
duplicate rectangles
due additional rectangles perfect packing transformation
introduced additional redundancy simple way handle
follows particular empty corner never place rectangle duplicate one
already tried position method handling duplicates applies
duplicate rectangles original instance

experimental
benchmarked packers linux ghz amd opteron gb ram
packer call kmp korf et al benchmarked machine
quote published include data relative placement
packer competitive simonis osullivans packer
call ss quoted obtained sicstus prolog windows
ghz intel xeon gb ram since machine faster
comparisons conservative estimate relative performance
previous benchmarks
consecutive square benchmark unoriented consecutive rectangle
benchmarks korf et al used literature measure performance
include data collected two benchmarks


fioptimal rectangle packing absolute placement

size
n

kmp
time

ss
time

fixedorder
time











































hk
time














table cpu times required packers consecutive square benchmark
task pack squares n n

consecutive squares
table compares cpu runtimes four packers consecutive square benchmark
first column specifies instance size number squares
size largest one remaining columns specify cpu times required
optimal solutions format days hours minutes
seconds multiple boxes minimum area n listed table
appendix report total time required optimal bounding boxes
two reasons first finding minimum area bounding boxes removes
question bounding box test first one area second
providing optimal solutions researchers working rectangle packing use
information verify correctness programs
hk includes wasted space pruning rule x coordinates dynamic variable
ordering x intervals x coordinates perfect packing transformation
related search space inference rules named packer consistent
previous work huang korf ss refers previous state art
packer simonis osullivan largest previously solved n
took ss hours solved minutes solved five
open n kmp refers korf et al absolute placement
packer fixedorder assigns x intervals single x coordinates includes
ideas hk dynamic variable ordering x coordinates order
magnitude faster fixedorder n order magnitude improvement
fixedorder ss likely due use perfect packing assigning ycoordinates include timing packer perfect packing disabled
competitive e g n took hours


fihuang korf

size
n













x coordinate
solutions













seconds
x













seconds














ratio
x













table cpu times spent searching x coordinates consecutive square
benchmark

table second column number complete x coordinate assignments
packer found entire run particular instance third column
total time spent searching x coordinates fourth column total time
spent performing perfect packing transformation searching coordinates
columns represent total cpu time entire run given instance
last column ratio time third column fourth interestingly
almost time spent x coordinates opposed coordinates
suggests could efficiently enumerate x coordinate solutions could
efficiently solve rectangle packing confirmed relatively x coordinate
solutions exist even large instances data table obtained linux
ghz intel core duo e machine separate experiment table
total time spent given instance different
unoriented consecutive rectangles
table compares cpu times packer unoriented consecutive rectangles
benchmark korf et al although techniques due simonis
osullivan outperform korf et al consecutive square benchmark
previously published benchmark besides korf et al
benchmark easier consecutive square benchmark break
contributions techniques differences delineated
clearly previous section primary differentiating feature benchmark
rectangles unoriented
first column gives size instance second column gives
performance previous state art packer benchmark korf et al
code third column gives performance packer benchmark


fioptimal rectangle packing absolute placement

size
n

kmp
time

hk
time










































table cpu times required two packers unoriented consecutive rectangle benchmark task pack unoriented rectangles sizes n n

data table collected linux ghz intel core duo e machine
except n n collected linux ghz intel xeon e
gb ram experiments revealed faster former
machine
benchmark techniques allowed us extend known solutions
n n allowed us solve n times faster previous
state art benchmark
oriented equal perimeter unoriented double perimeter rectangles
section uses benchmarks compare techniques developed
non square instances techniques discuss including dynamic adjustment
interval sizes generalized variable order branching factor largely
affect performance packer consecutive square benchmark fact
tested packer benchmark see effects extra overhead added
improvements packer resulted five percent speedup compared
packer without changes consecutive square benchmark likely due minor
improvements data structures balancing interval sizes therefore compare
effects techniques benchmarks techniques
developed benchmarks improve performance oriented unoriented
cases discuss together
table compares performance packers oriented equal perimeter benchmark table compares packers unoriented double perimeter
benchmark first column refers size instance number


fihuang korf

size
n

boxes
tested

hk
time

optdom
time

brfactor
time

c
time

hk
time














































































table cpu times required packers oriented equal perimeter rectangle
benchmark task pack oriented rectangles sizes n n
n n

size
n

boxes
tested

hk
time

optdom
time

brfactor
time

c
time

hk
time



























































table cpu times required packers unoriented double perimeter rectangle benchmark task pack unoriented rectangles sizes n
n n n n n



fioptimal rectangle packing absolute placement

rectangles second column gives number bounding boxes tested order
optimal solutions remaining columns represent cpu times different
versions packer format days hours minutes seconds wrote
packer c collected data linux ghz intel core duo e machine
left right successive packer improves previous one including
additional technique column called hk data collected techniques
developed specifically consecutive square packing include perfect packing
transformation related inference rules dynamic variable ordering single
x coordinates x intervals wasted space pruning rule x coordinates
huang korf compare variable ordering rectangles
aspect ratios used order decreasing area default hk
optdom improves upon hk dynamically detecting dominance rules apply
inapplicable optimizes x interval assignments knowledge brfactor
improves upon optdom orders oriented equal perimeter benchmark decreasing width unoriented double perimeter benchmark decreasing area c
improves upon brfactor use interval size instead c
consecutive square benchmark finally hk improves upon c
knowledge branching factor rebalance sizes interval assignments
x coordinates
notice optdom brfactor c introduce techniques reduce
branching factor greater effect performance hk whose
technique seeks make intervals assigned equally constraining experiments
reveal techniques interact one another note without including
dominated positions intervals performance gained techniques
appears muted interaction tune global interval parameter c
including techniques affect branching factor
ordering branching factor improved performance oriented equal perimeter
benchmark unoriented benchmark latter case seen table
technique ordering branching factor prescribes ordering decreasing area
gave packer reasonable default therefore difference
performance optdom brfactor columns table
note unoriented double perimeter benchmark requires packer try
twice many bounding boxes given parameter n required oriented benchmark due n largest dimension unoriented
benchmark n largest dimension oriented benchmark larger
rectangles introduce higher precision must try bounding
boxes containment unoriented instance space
factor n larger oriented instance due two orientations
rectangle thus instance n rectangles benchmark incomparable
instance n squares consecutive square benchmark evaluating benchmark
difficulty
summary techniques together solve n oriented
equal perimeter benchmark times faster n unoriented doubleperimeter benchmark times faster techniques presented optimized
consecutive squares


fihuang korf

size

boxes tested

cpu time

n

squares

perimeter

squares

perimeter









































































table number bounding boxes tested cpu time required solve given instance
consecutive square oriented equal perimeter benchmarks



fioptimal rectangle packing absolute placement

comparing easy hard benchmarks
following tables compare difficulty benchmarks packer huang
korf optimizations enabled
consecutive squares vs equal perimeter rectangles
table first column indicates number rectangles instance second
third columns labeled boxes tested give number bounding boxes
tested finding optimal solutions consecutive square benchmark
oriented equal perimeter benchmark respectively fourth fifth columns give
performance rectangle packer benchmarks well data point
table collected linux ghz intel core duo e one process one
thread one core
notice given instance number rectangles oriented equalperimeter benchmark significantly harder consecutive square benchmark
due fact given size consecutive square benchmark contains
many little squares typically easy place property missing equalperimeter benchmark fact n packer requires four orders magnitude
time optimal solutions benchmark compared instance
number items consecutive square benchmark
unoriented consecutive rectangles vs unoriented double perimeter
rectangles
table shows removing certain properties successively difficult benchmarks start unoriented consecutive rectangle benchmark korf et al
contains many easy properties doubly scaled column pack
n n rectangles simply scales unoriented consecutive rectangle benchmark factor two benchmark difficult integers
higher magnitude lead x coordinates search turn increases branching factor unique dimensions column pack rectangles
sizes n n differs previous benchmark
dimensions unique last column distributes area among rectangles
uniformly avoid consolidating area first rectangles
column culmination difficult properties identified
rectangle packing benchmark call unoriented double perimeter benchmark
data points table collected linux ghz intel core duo e
machine without parallelization except n n collected
linux ghz intel xeon e machine gb ram estimate
thirty percent faster
bounding boxes minimum area
section list optimal bounding boxes benchmarks found
program optimizations enabled notice duplicate data


fihuang korf

size
n



















unoriented
consecutiverectangles



















doubly
scaled
















unique
dimensions














unoriented
doubleperimeter








table cpu time required optimized packer benchmarks increasing
difficulty



fioptimal rectangle packing absolute placement

unoriented high precision rectangle benchmark leave table section
since discussion refers data
first column tables refer size instance
respective benchmarks columns called optimal solution give dimensions
optimal bounding boxes given instance next column called empty space gives
percent empty space optimal solution next column gives number
bounding boxes tested order optimal solutions given instance

absolute placement high precision instances
meir moser first proposed finding smallest square
contain infinite series rectangles sizes etc rectangles
cannot overlap unoriented unit square exactly enough area since total
area rectangles infinite series one hand space
wasted suggesting task infeasible inspired propose last
benchmark developed several techniques
introduce unoriented high precision rectangle benchmark task
bounding boxes minimum area contain finite set unoriented rectangles
sizes n n example n one must pack rectangles
sizes alternatively one may try pack rectangles sizes
square original instance
scaled factor least common multiple rectangle denominators
strategy required broad class recent rectangle packers explore domain
integer x coordinates rectangles quickly break higher n
example optimal solution n billion unique coordinate pairs
rectangles assigned benchmark complements rather replaces
current low precision benchmarks neglected high precision instances
remainder section organized follows first review previous
work proposing solution techniques may unaffected precision rectangle
dimensions describe several adaptations low precision techniques
high precision case along techniques developed specifically high precision
rectangle instances finally follow experimental
previous work
relative placement moffitt pollack rectangle packing
similar types search spaces used resource constrained scheduling weglarz
promises immune high precision rectangle instances however since
many techniques described previous sections cannot
extended packer working relative placement search space decided
stay within absolute placement framework attempt mitigate
introduced high precision numbers


fihuang korf

consecutive squares

consecutive rectangles

size
n

optimal
solutions

empty
space

boxes
tested

optimal
solutions

empty
space

boxes
tested






































































































































































































































table optimal solutions consecutive square benchmark task
pack squares sizes n n unoriented consecutive rectangle
benchmark task pack unoriented rectangles sizes
n n



fioptimal rectangle packing absolute placement

oriented equal perimeter

unoriented double perimeter

size
n

optimal
solutions

empty
space

boxes
tested

optimal
solutions

empty
space

boxes
tested

































































































































































table optimal solutions oriented equal perimeter rectangle benchmark
task pack oriented rectangles sizes n n n
n unoriented double perimeter rectangle benchmark task
pack unoriented rectangles sizes n n n n
n n



fihuang korf



b

figure examples mapping solutions one rectangles left
bottom positions

overall strategy
given instance high precision benchmark described rational numbers
multiply values least common multiple denominators get instance
integer dimensions apply absolute placement solution techniques
improvements subsequently explain order optimal solutions
found divide x coordinates describing optimal solutions initial
scaling constant order obtain optimal solutions original
note map every solution one rectangles slid
left bottom much possible chazelle example solution
figure transformed figure b since rectangles propped
left rectangles rectangles x coordinate sum
subset widths rectangles rectangles coordinate
sum subset heights rectangles similarly width height
bounding box must sum subset widths heights rectangles
respectively
following subsections first explain techniques respect oriented
instances follow handle unoriented case
minimum bounding box
since build initial set bounding boxes pairwise combinations widths
heights within given ranges space pruned considering bounding box
widths heights equal subset sums rectangle widths subset sums
rectangle heights respectively recall section every bounding box
width compute lower bound height modify rounding
resulting bound next subset sum rectangle heights


fioptimal rectangle packing absolute placement

precomputing subset sums
compute set subset sums prior searching oriented rectangles
cannot rotated compute two sets one heights rectangles
representing candidate coordinates one widths representing
candidate x coordinates distinction generates fewer subset sums compared
single set subset sums generated widths heights
pruning combinations widths heights
reject bounding boxes certain width height combinations
infeasible pruning technique relies observation certain cases may
one unique set rectangles generate specific width height bounding
box
example consider bounding box width generated unique
set rectangles assume heights set rectangles uniquely
determine subset sum specific bounding box height say combination
bounding box width height incompatible reason set rectangles
way bounding box given width implies set
rectangles must appear solution laid horizontally one another thus
set rectangles cannot appear stacked vertically solution contradicts
implications bounding box given height note particular example
compatible height maximum height rectangles
learning infeasible attempts
recall solving minimal bounding box repeatedly calls
solve containment bounding boxes tested order
non decreasing area first boxes solutions found learn
infeasible attempts
example consider pack n rectangles r r rn note use
pre computed variable order rectangles let rd n rectangle corresponding
deepest search tree depth first search able go entire
search effort given bounding box containmnet solver says bounding box
infeasible next bounding box height consider next
greatest subset sum smaller set r r rd instead considering n
rectangles intuition behind since containment solver failed even
arrangement first rectangles doesnt make sense involve
remaining rectangles rd rn next largest subset sum bounding box
height
method resembles conflict directed backtracking implementation
consider effect pruning wasted space heuristic well
containment
similar low precision methods first assign x coordinates rectangles
conduct perfect packing transformation finally work coordinates huang


fihuang korf

korf main difference high precision methods lowprecision methods instead considering possible integers domain
x coordinates consider smaller set subset sums widths heights
rectangles methods x intervals remain unchanged
describe search individual x coordinates
assigning x coordinates
oriented rectangles choose x coordinates set subset sums rectangle
widths instead precomputing set minimal bounding box
generate dynamically every node search prior branching
x coordinate value assignments set computed follows
initialize set value represents placing rectangle
left side bounding box
every rectangle r already assigned x coordinate point search
insert set sum x coordinate width represents placing
rectangle right side r
every rectangle x coordinate still unassigned add width every
element set insert sums back set
perfect packing transformation
assigning x coordinates create number rectangles account
empty space original instance transformation instance
empty space consists original rectangles plus rectangles
given empty corner partial solution ask original unplaced rectangles
might fit rectangle essentially modeling empty corners variables
rectangles values
high precision benchmark solving n requires creating billion
rectangles scaled large number packer
simply requires much memory time avoid creating fewer
much larger rectangles account empty space
widening existing rectangles assume figure task pack three
rectangles rectangle bounding
box assume assigned x coordinates coordinates given
x coordinates already assigned resulting packing solution space right
rectangle must empty thus replace rectangle
rectangle effectively widening original rectangle likewise replace
rectangle rectangle rectangle rectangle
figure b packer greedily attempts widen rectangles towards right
widening towards left solving return
rectangles back original widths avoids creating many rectangles
perfect packing transformation represent empty space


fioptimal rectangle packing absolute placement

partial solution xcoordinates known

b widening rectangles

figure widening existing rectangles

b solution without rectangles empty space

partial solution xcoordinates known

figure consolidating empty space horizontal strips

turning empty space large rectangles partial solution figure
assigned x coordinates rectangles bounding box instead
creating three hundred rectangles represent empty space indicated
single hash marks use ten rectangles without losing packing solutions
similarly represent doubly hashed empty space twenty rectangles instead
six hundred rectangles note cannot use rectangles empty
space since would inadvertently prune potential solution figure b
assigning coordinates
perfect packing transformation assign coordinates asking rectangle
placed given empty corner enforce constraint ycoordinate rectangle must subset sum rectangle heights note
rectangles create via perfect packing transformation included subset
sum calculations since represent empty space
handling unoriented instances
unoriented instances computing initial bounding box widths heights
generate single set subset sums widths heights rectangles
instance instead keeping widths separated heights likewise
generating set candidate x coordinates must add fourth step


fihuang korf

size
n

optimal
solution

lcm

bits
precision

hk
boxes

subsets
boxes

mutex
boxes

hk
boxes




























































































































table minimum area bounding boxes number bounding boxes tested
packing unoriented rectangles n n

bulleted list subsection add height every rectangle
yet placed every element set subset sums represents possibility
rotating rectangle
experimental
present two different data tables one relating improvements minimal bounding
box measured number bounding boxes tested another one
overall cpu time solving entire rectangle packing separate
experiments way solution schema decouples minimal bounding box
containment
minimum bounding box
table shows optimal solutions unoriented high precision rectangle benchmark
along properties corresponding instances first two columns give
size dimensions optimal solutions respectively third gives
least common multiple first n integers fourth number bits required
represent area minimal bounding box note one optimal
solutions width since first rectangle much larger others
n larger required precision exceeds bit integer
fifth eighth columns compare number bounding boxes
packers test optimal solutions unoriented high precision rectangle bench

fioptimal rectangle packing absolute placement

size
n











hk
time

empty space
time

dynamic
time

hk
time



































table cpu times packers minimum area bounding boxes containing
unoriented rectangles n n
mark column going left right add one technique minimal
bounding box
hk number bounding boxes required simply scaling
instance described completely integers column called subsets improves upon
second testing bounding boxes whose dimensions constrained
subset sums technique column called mutex improves upon third rejecting
bounding boxes subset sum corresponding width mutually exclusive
subset sum corresponding height hk improves upon previous packer
information learned infeasible attempt reject future bounding boxes
improvements n test times fewer bounding boxes compared
previous state art instance hk ran memory last
bounding box sheer number rectangles created perfect
packing transformation introduction prime number denominator
instance responsible increased difficulty n n
containment
table compares performance packers techniques
decoupled minimal bounding box containment
table use optimizations minimal bounding box
compare individual techniques applied containment therefore
performance data reported required solve overall
containment packers
first column gives size instance high precision rectangle
benchmark previous tables successive column left right improves upon
previous column additional technique column called hk corresponds
previous state art improved minimal bounding box
column called empty space improves upon hk precomputing subset


fihuang korf

sums prior searching x coordinates uses techniques consolidate empty
space coordinates column called dynamic improves upon previous one
dynamically computing subset sums finally last column called hk adds
ability learn unplaced rectangles exclude subset sums computation
exploring infeasible subtree data collected linux eight core ghz
intel xeon x without parallelization
n scaled times dimensions requiring hk
create units empty space perfect packing transformation
causing run memory empty space could complete n within
day sheer number subset sums must explored x
coordinates avoided dynamic
comparison relative placement
interesting note number bounding boxes appears increasing exponentially mostly likely due exponential growth number subset sums
introduced successive rectangle high precision benchmark difficulty
unoriented high precision rectangle benchmark compounded fact
precision increases branching factor single x coordinate values
containment increases
contrast absolute placement technique moffitt pollacks relative
placement techniques enumerate different exact locations rectangles
therefore promise immune high precision rectangles used
variable every pair rectangles represent relations left right
search required least one non overlapping constraints
true every pair rectangles meta csp modeled work
dechter meiri pearl solving binary constraint satisfaction
included pruning techniques model reduction symmetry breaking
graph pruning heuristics korf et al solve minimum bounding box
branch bound evaluating size bounding box
non overlapping relationships determined keeping track bounding
box smallest area seen far
note contrast solver tests bounding boxes order non decreasing area
size formulation uses n variables use n finally
packer returns one optimal solution opposed work
returning optimal solutions
able benchmark code machine order provide
kind comparison methods crude comparison
cannot run packer unoriented high precision rectangle benchmark since
hard coded packer unoriented consecutive rectangle benchmark much
easier benchmark shown table
first column table refers size second column called mp
gives cpu time required moffitt pollacks code instances
unoriented consecutive rectangle benchmark uses low precision rectangles third
column called hk gives cpu time required packer instances


fioptimal rectangle packing absolute placement

size
n

mp
time

hk
time






















table cpu times required moffitt pollacks packer unoriented consecutiverectangle packer unoriented high precision rectangle benchmarks

unoriented high precision rectangle benchmark data point table
collected eight core ghz intel xeon x linux without parallelization note
packs number rectangles somewhat faster moffit
pollacks
summary high precision rectangles
section proposed benchmark consisting instances rectangles
high precision dimensions well techniques subset sums limit number
positions must considered rules filter subset sums minimal
bounding box containment methods learn infeasible subtrees
ways reduce number rectangles created perfect packing transformation
techniques exploit special properties benchmark useful
rectangles high precision dimensions
methods solved six n benchmark compared low precision packer scaled instance packer
two orders magnitude faster n previous state art tests
times fewer bounding boxes cursory comparison state art
relative placement search space shows perform slightly faster
moffitt pollacks packer benchmark previously shown section
significantly difficult unoriented consecutive rectangle benchmark
moffitt pollacks program run

future work
humans solve jigsaw puzzles asking particular piece go well
asking piece go empty region packer makes use
former x coordinates latter coordinates would
interesting see applicable dual formulation packing layout
scheduling currently work x coordinates asking
go work coordinates asking goes location
method reduced time spent coordinates much time spent


fihuang korf

working x coordinates orders magnitude greater time spent working
coordinates suggests performance might improved considering
simultaneously
another direction continued work data indicates number bounding
boxes explored minimum bounding boxes solver main bottleneck solving
larger instances unoriented high precision rectangle benchmark observation
make across many bounding boxes partial solutions
explored resulting much redundant computation consequently branch bound
method starts large bounding box gradually reduces dimensions
packings explored would promising avenue

conclusions
presented several improvements previous state art optimal
rectangle packing within schema assigning x coordinates prior coordinates
introduced dynamic variable order x coordinates constraint adapts
korfs wasted space pruning heuristic one dimensional case ycoordinates work perfect packing transformation original
model assigns rectangles empty corners inference rules reduce
variables
improvements search coordinates helped us solve n consecutive square benchmark order magnitude faster previous state ofthe art improvements search x coordinates gave us another order
magnitude speedup n compared leaving optimizations
techniques times faster previous state art largest
solved date allowing us extend known solutions consecutive square
benchmark n n furthermore data little time spent
searching coordinates suggesting rectangle packing may largely reduced
determining x coordinates
techniques presented pick coordinates tightly coupled dual
view asking must go empty location furthermore searching xcoordinates pruning rule analysis irregular regions empty space
dynamic variable order rests observation less empty space leads
constrained success techniques rectangle packing make
worth exploring many packing layout scheduling
introduced two benchmarks one oriented one unoriented
include rectangles aspect ratios benchmarks avoid properties
easy instances identified shown much harder
side side comparison benchmarks state art packer
proposed several search strategies improve performance benchmarks improved upon strategies used handle dominance conditions proposed
variable ordering heuristic increasing branching factor generalizes previous
strategies tuned global interval parameter introduced method balance sizes
intervals assigned x coordinate variables


fioptimal rectangle packing absolute placement

experiments revealed takes orders magnitude time solve
benchmarks compared instances consecutive square benchmark
number rectangles therefore advocate inclusion difficult
benchmarks suite benchmarks used optimal rectangle packing finally techniques together solved n oriented equal perimeter
benchmark times faster n unoriented double perimeter benchmark times faster simply methods tuned consecutive squares
order test limits rectangle packer presented high precision benchmark specifically capturing pathological case successive rectangle
quickly increases precision required represent coordinate locations presented
techniques adapt absolute placement handle types instances including dynamically subset sums limit number coordinate values
must tested mutex reasoning allows us reject certain combinations subset
sums used bounding boxs width height general method rejecting future subset sums previously infeasible search finally memory efficient adaptation
perfect packing transformation high precision rectangle instances
solved n high precision benchmark half minute times faster
basic version packer augmented high precision version perfect
packing inference rules run memory first instance
requiring precision exceeding capacity bit integer techniques allowed us
solve n compared n largest instance low precision techniques
alone could solve methods reduced number bounding boxes generated
factor point solving require minimum bits
precision meet requirements many real world
provided comparison state art relative placement packer showing
absolute placement packer remains competitive even rectangles high precision reported promising avenues may potentially give absolute
placement clear competitive edge relative placement methods
although mainly focused obtaining optimal solutions benchmarks
work may easily adapted applications requiring quick suboptimal solutions
simply replacing minimum bounding box alternatives
anytime described section
comparison constraint programming methodologies
clearly tradeoffs taking ground programming c
taking constraint programming latter provides quick prototyping
reuse constraint libraries researchers already implemented
forces expressed abstract constraint language abstract
layer turns add unnecessary overhead data structures
one naturally uses solve optimal rectangle packing
example previously described cumulative constraint simply add
constant consecutive range integer array assign x coordinate
rectangle backtrack scan array subtract constant
scanning manipulating arrays iteration fast pushing popping program


fihuang korf

stack recursive precisely operations modern computer hardware
optimized significant explore two trillion search nodes
n square packing benchmark fact solver spends
time array manipulation operations alone explain
orders magnitude speedup processing x coordinate solutions array
instead bitmap korf move arrays bitmaps
abstract representations variables values constraint programming patterns
computation data structures simply become distant underlying
hardware optimized
optimal rectangle packing happens data structures
naturally solve map nicely form function hardware modern
computers note one may port code constraint module may
called constraint solver still computational indirection
module backtracking control logic constraint solver sacrifice make
however fact solver tailored specifically rectangle
packing defined would require implementation effort
reconfigure heuristics slightly different rectangle packing
hope however latter ameliorated disciplined object oriented
modular software design

broader lessons
beyond specific rectangle packing broader lessons learn
work believe several
one main applications rectangle packing scheduling described
introduction rectangle packing abstraction scheduling
different tasks take different amounts time require different amounts onedimensional resource must allocated contiguously memory computer
width bounding box becomes total time height total amount
resource available job becomes rectangle width equal time duration
height equal amount resource required
found however vast majority time used rectangle packer
assigning x coordinates rectangles subject cumulative constraint
every x coordinate bounding box sum heights rectangles overlap x coordinate cannot exceed height bounding box
important subpart rectangle packing much general
known resource constrained scheduling scheduling
described without constraint resource allocated contiguously example scheduling tasks planetary rover limited power budget
sum power requirements tasks active given time cannot
exceed total power budget rover thus subpart rectangle packer
used tackle general scheduling
another general lesson learned work absolute placement
packing two three dimensions may effective
even high precision dimensions one might expect absolute placement


fioptimal rectangle packing absolute placement

would competitive relative placement approaches
key success area instead considering possible placements
consider placements correspond subset sums relevant dimensions
guarantee work high precision packing
shown least worth considering may effective
perhaps largest lesson learned encouraging discouraging
rectangle packing extremely simple understood played
game children yet last decade described shows
efficient quite complex best simple
complex likely best complex
even complex discouraging part encouraging part
history shown idea order magnitude
improvement previous state art larger suggesting
still significant progress made extension others

acknowledgments
wish thank reza ahmadi adnan darwiche adam meyerson advice
work thank michael moffitt making packer available funded part national science foundation grant number iis source code optimal rectangle packer open sourced available
http code google com p rectpack

references
aggoun beldiceanu n extending chip order solve complex scheduling
placement mathematical computer modelling
beldiceanu n carlsson sweep generic pruning technique applied
non overlapping rectangles constraint cp proceedings th international
conference principles practice constraint programming pp london uk springer verlag
beldiceanu n carlsson poder e filtering cumulative constraint
context non overlapping rectangles perron l trick eds
cpaior vol lecture notes computer science pp springer
beldiceanu n carlsson poder e sadek r truchet c generic geometrical constraint kernel space time handling polymorphic k dimensional
objects bessiere c ed cp vol lecture notes computer science
pp springer
bhattacharya roy r bhattacharya exact depth first
pallet loading european journal operational
chan h h markov l practical slicing non slicing block packing without
simulated annealing glsvlsi proceedings th acm great lakes
symposium vlsi pp york ny usa acm


fihuang korf

chazelle b bottomn left bin packing heuristic efficient implementation
ieee transactions computers c
clautiaux f carlier j moukrim exact method twodimensional orthogonal packing european journal operational

dechter r meiri pearl j temporal constraint networks artificial intelligence
dowsland k exact pallet loading european
journal operational
dowsland k dowsland w b packing european journal
operational
huang e korf r e improvements optimal rectangle packing
boutilier c ed ijcai pp
huang e korf r e optimal rectangle packing non square benchmarks
aaai proceedings th national conference artificial intelligence pp
aaai press
huang e korf r e optimal packing high precision rectangles burgard
w roth eds aaai aaai press
korf r e optimal rectangle packing initial giunchiglia e muscettola
n nau eds icaps pp aaai
korf r e optimal rectangle packing zilberstein koehler j
koenig eds icaps pp aaai
korf r e moffitt pollack e optimal rectangle packing annals
operations
lahrichi scheduling notions hump compulsory parts use
cumulative comptes rendus de academie des sciences paris
lesh n marks j mcmahon mitzenmacher exhaustive approaches
rectangular perfect packings information processing letters
li c leong h w quek k approximation dynamic storage allocation chwa k munro j eds cocoon
vol lecture notes computer science pp springer
lipovetskii geometrical computation optimal solution
rectangle packing american mathematical society translations

lodi martello monaci two dimensional packing survey
european journal operational
lodi martello vigo recent advances two dimensional bin packing
discrete applied mathematics
martello vigo exact solution two dimensional finite bin packing
management science


fioptimal rectangle packing absolute placement

meir moser l packing squares cubes journal combinatorial
theory
mitola j maguire g cognitive radio making software radios personal
ieee personal communications magazine
moffitt pollack e optimal rectangle packing meta csp
long smith f borrajo mccluskey l eds icaps pp
aaai
onodera h taniguchi tamaru k branch bound placement building
block layout dac proceedings th acm ieee design automation
conference pp york ny usa acm
simonis h osullivan b search strategies rectangle packing stuckey
p j ed cp vol lecture notes computer science pp springer
simonis h osullivan b almost square packing achterberg beck
j c eds cpaior vol lecture notes computer science pp
springer
sweeney p e paternoster e r cutting packing categorized
application orientated bibliography journal operational
society
weglarz j project scheduling recent applications springer
kluwer
yap r h c constraint processing rina dechter morgan kaufmann publishers
hard cover isbn xx theory pract log program





