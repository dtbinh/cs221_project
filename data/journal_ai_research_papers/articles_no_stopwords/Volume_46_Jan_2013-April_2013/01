Journal Artificial Intelligence Research 46 (2012) 47-87

Submitted 07/12; published 01/13

Optimal Rectangle Packing:
Absolute Placement Approach
Eric Huang

ehuang@parc.com

Palo Alto Research Center
3333 Coyote Hill Road
Palo Alto, CA 94304 USA

Richard E. Korf

korf@cs.ucla.edu

UCLA Computer Science Department
4532E Boelter Hall
University California, Los Angeles
Los Angeles, CA 90095-1596 USA

Abstract
consider problem finding enclosing rectangles minimum area
contain given set rectangles without overlap. rectangle packer chooses xcoordinates rectangles y-coordinates. transform
problem perfect-packing problem empty space adding additional rectangles. determine y-coordinates, branch different rectangles
placed empty position. packer allows us extend known solutions
consecutive-square benchmark 27 32 squares. introduce three new benchmarks, avoiding properties make benchmark easy, rectangles shared
dimensions. third benchmark consists rectangles increasingly high precision.
pack efficiently, limit rectangles coordinates bounding box dimensions
set subset sums rectangles dimensions. Overall, algorithms represent
current state-of-the-art problem, outperforming algorithms orders
magnitude, depending benchmark.

1. Introduction
Given set rectangles, problem find enclosing rectangles minimum area
contain without overlap. refer enclosing rectangle bounding box,
avoid confusion. optimization problem NP-hard, problem deciding
whether set rectangles packed given bounding box NP-complete, via
reduction bin-packing (Korf, 2003). consecutive-square benchmark simple set
increasingly difficult benchmarks problem, task find bounding
boxes minimum area contain set squares dimensions 1 1, 2 2, ...,
N N (Korf, 2003). example, Figure 1 optimal solution N =32.
use benchmark explain many ideas paper, techniques
limited packing squares, apply rectangles.
Rectangle packing many practical applications, including modeling scheduling problems tasks require resources allocated contiguous chunks.
example, consider task scheduling allocating contiguous memory addresses
programs. width rectangle represents length time program runs,
c
2012
AI Access Foundation. rights reserved.

fiHuang & Korf

Figure 1: optimal solution N =32 consecutive-square benchmark, packing
squares dimensions 1 1, 2 2, ..., 31 31, 32 32 bounding box minimum
area, 85 135.

48

fiOptimal Rectangle Packing: Absolute Placement Approach

height represents amount contiguous memory needs. rectangle packing solution
tells us programs run, well memory addresses
assigned. Similar problems include scheduling ships different length
berthed along single, long wharf (Li, Leong, & Quek, 2004), well allocation scheduling radio frequency spectra usage (Mitola & Maguire, 1999). Rectangle
packing appears loading set rectangular objects pallet without stacking
them. cutting stock layout problems contain rectangle packing subproblems.
1.1 Overview
remainder article organized follows. first introduce various benchmarks Section 2 specifically define rectangle packing instances solve.
Section 3, review state-of-the-art rectangle packers techniques,
provides foundation upon present new work. follow Section 4
data collected compare work previous state-of-the-art using previous
benchmarks. compare difficulty previous benchmarks new ones.
Section 5, present benchmark rectangles successively higher precision
dimensions, new solution techniques handle this, follow experimental results.
compare methods competing search spaces used packing highprecision rectangles, show methods remain competitive.
Sections 6 7 explain various avenues future work, concluding article
summarizing contributions results. previously published much
work several conference papers (Huang & Korf, 2009, 2010, 2011).

2. Benchmarks
several reasons motivating benchmarks. First, benchmarks describe
instances single parameter N , allowing researchers easily reproduce instances.
Second, instances unique, optimal solutions reported easily
validated others. advantages many real-world instance libraries
randomly generated ones. Third, benchmarks define infinite set instances
successive instance harder previous. solver superior another solver
solve instance faster, larger instance amount time.
contrast, comparison using library instances may require counting number
instances completed within given time limit. Furthermore, instance libraries,
often one solver performs well one subset instances competing solver performs
well different subset, making comparisons inconclusive.
believe benchmarks capture difficult instances rectangle
packer may face investigate modeling generation random problems.
Although Clautiaux et al. (2007) others used random instances, non-random
benchmarks used Korf (2003) Simonis OSullivan (2008) better facilitated
comparison state-of-the-art packers. However, comprehensive overviews,
refer reader numerous surveys available (Lodi, Martello, & Vigo, 2002; Lodi,
Martello, & Monaci, 2002; Dowsland & Dowsland, 1992; Sweeney & Paternoster, 1992).
49

fiHuang & Korf

2.1 Previous Benchmarks
Several previous benchmarks used literature shown easier
benchmarks propose. Part due fact benchmarks, solvers,
may improved research, ensure cover various properties
rectangles, addition providing easy way compare performance among different
packers measure progress.
consecutive-square benchmark (Korf, 2003), simple set increasingly difficult
instances, task find bounding boxes minimum area contain set
squares sizes 1 1, 2 2, ..., N N . Prior work, many recent stateof-the-art packers used popular benchmark measure performance, including
Moffitt Pollack (2006), Korf, Moffitt, Pollack (2010), Simonis OSullivan
(2008). date, largest instance solved problem N =32, shown Figure 1,
using packer (Huang & Korf, 2009). consider problem packing squares
square benchmark gets much easier problem size increases, due
large differences areas consecutive square bounding boxes.
unoriented consecutive-rectangle benchmark (Korf et al., 2010), instance
set rectangles sizes 1 2, 2 3, ..., N (N + 1), rectangles may
rotated 90-degrees. subsequently explain, fact many pairs
rectangles instance share equal dimensions causes optimal solutions
leave empty space, making benchmark easy solve. include benchmark
completeness, note effective measure comparing different packers.
Finding first optimal solution another benchmark Simonis OSullivan
(2011) used conjunction problem instances unoriented consecutiverectangle benchmark. contrast problem finding optimal solutions,
measure time takes find first optimal solution, makes much
difficult reliably compare solvers unless focus research value
ordering tie-breaking among bounding boxes equal area.
example, Simonis OSullivan (2011) report find first solution
N =26 takes 3:28:20 (3 hours, 28 minutes, 20 seconds). shown Table 8 page
72, six solutions N =26: 42 156, 52 126, 56 117, 63 104, 72 91, 78 84,
requiring solver CPU times 0:32, 41:40, 53:19, 1:55:04, 1:33:22, 8:53:01,
respectively. smaller bounding boxes needed test optimal
solution empty space, used Simonis OSullivans termination criteria
returned first optimal solution, would need 32 seconds. Therefore, finding
minimum bounding boxes instead first one benchmark produces
harder problems larger N , better facilitates program comparisons.
2.2 Properties Easy Benchmarks Avoid
motivate new benchmarks, explain previous benchmarks tended
much easier comparison, constructed new benchmarks
describe instances consisting rectangles unique dimensions, without duplicates,
without area occupied rectangles.
50

fiOptimal Rectangle Packing: Absolute Placement Approach

(a) Solution 21 35 bounding
box unoriented instance 1 2,
2 3, ..., 11 12, 12 13.

(b) Solution 14 26 bounding
box unoriented instance 1
12, 2 11, ..., 11 2, 12 1.

Figure 2: Examples solutions instances rectangles equal dimensions.

2.2.1 Rectangles Equal Dimensions
unoriented consecutive-rectangle benchmark, rectangles share dimension
another rectangle. example, Figure 2a optimal solution N =12. optimal
solutions, rectangles equal dimensions tend line next other, forming larger
rectangles leaving little empty space. Figure 2a, 8 9 7 8 line up,
5 6 4 5, 3 4 2 3. fact, solutions
benchmark much smaller percentage empty space similar-sized instances
consecutive-square benchmark, rectangles unique dimensions.
notice benchmarks duplicate rectangles, Figure 2b, solved
quickly.
2.2.2 Rectangles Small Area Small Dimensions
Figure 2b example perfect packing, empty space
solution. Problems perfect packings tend easy two reasons. One
test bounding boxes increasing order area, test fewer boxes, since never test
box minimum area required. second problems,
rather deciding rectangle go bounding box,
efficient algorithm decide cell empty space rectangle occupy
51

fiHuang & Korf

it. soon small region empty space created cant accomodate remaining
rectangles, algorithm backtrack.
consecutive-square unoriented rectangle benchmarks, large
rectangles capture much total area instance. Thus, packer search
deeply using allowable empty space. little empty space, early
backtracking likely since cannot find place next rectangle. Therefore,
small rectangles benchmarks insignificant impact search effort.
previous benchmarks, consecutive-square benchmark, retangles
largest area largest dimensions, making obvious rectangles
place first, largest rectangles constrained, impose
constraints remaining rectangles.
contrast, new benchmarks trade-off rectangles large
dimensions large area. widest rectangle oriented equal-perimeter benchmark, described below, smallest branching factor search xcoordinates. However, least area, search wont constrain
placement remaining rectangles much. raises non-trivial question best
variable ordering non-square rectangles.
2.3 New Benchmarks
propose several new benchmarks difficult comparing instances
number rectangles. experimental results make use following
benchmarks, addition consecutive-square unoriented consecutive-rectangle
benchmarks described above.
2.3.1 Equal-Perimeter Rectangles
First, present oriented equal-perimeter rectangle benchmark, instance
set rectangles sizes 1 N , 2 (N 1), ..., (N 1) 2, N 1, rectangles may
rotated (see Figure 3). Given N , rectangles unique perimeter 2N +2.
experiments, benchmark much difficult either consecutive-square
benchmark unoriented consecutive-rectangle benchmark (Korf et al., 2010)
number rectangles. tested state-of-the-art packer (Huang & Korf, 2010)
old new benchmarks. N =22 oriented equal-perimeter benchmark
took nine hours solve, N =22 consecutive-square unoriented
consecutive-rectangle benchmarks took one second six seconds, respectively.
Second, present unoriented double-perimeter rectangle benchmark, instances described set rectangles 1 (2N 1), 2 (2N 2), ..., (N 1) (N + 1),
N N , rectangles may rotated 90-degrees. rectangles unique
perimeter 4N . benchmark difficult benchmarks
used previously literature, benchmark difficult oriented
one introduced previous paragraph. experiments using techniques,
N =18 took two days solve.
far, benchmarks discussed low-precision integer dimensions.
property poses problem packer, enumerates various integer coordinate locations rectangle may placed. high-precision values, however,
52

fiOptimal Rectangle Packing: Absolute Placement Approach

Figure 3: optimal solution N =23 oriented equal-perimeter benchmark, packing
oriented rectangles dimensions 1 23, 2 22, ..., 22 2, 23 1 bounding box
minimum area, 38 61.

53

fiHuang & Korf

number distinct positions increases dramatically. motivates study packing rectangles high-precision dimensions. particular, propose unoriented
high-precision rectangle benchmark, instances described set rectangles
1
1 1
1
1
1
1 2 , 2 3 , ..., N N +1 . methods used solve benchmark quite
different used low-precision case.

3. Solution Techniques
section describe previous solution strategies well various new techniques
use rectangle packer. first describe techniques apply consecutive-square benchmark, oriented equal-perimeter benchmark, unoriented
double-perimeter benchmark. work unoriented high-precision rectangle benchmark included methods significantly different, deferred
Section 5.
3.1 Previous Work
earlier work focused optimal methods packing set rectangles
given bounding box motivated problem pallet loading. Dowsland (1987)
used depth-first search abstract graph representation search space solve
problem optimally problem sets modeled real-world pallet box dimensions.
Although problem instances contained average 30 rectangles 50,
benchmarks far easier consider here, rectangles
size, significant amount empty space solutions. Bhattacharya
et al. (1998) extended work additional lower bounds pruning techniques based
dominance conditions demonstrated work benchmarks.
examining rectangle packing instances rectangles different dimensions,
Onodera et al. (1991) used depth-first search, branching point search
space commitment particular non-overlap constraint two rectangles.
Lower bound graph reduction techniques applied prune search space, allowing optimally solve problems six rectangles.
Chan Markovs BloBB (2004) packer used branch-and-bound order find
minimum area bounding box contain set rectangles. solver could handle
eleven rectangles, observed instances duplicate rectangles
much easier, causing packer cluster rectangles together optimal solution.
Lesh et al.s solver (2004) used depth-first search, placing rectangle first bottommost left-most position fit (the bottom-left heuristic, see Chazelle, 1983),
determine whether set rectangles packed given enclosing rectangle.
able handle twenty-nine rectangles ten minutes average,
testbed consisted instances whose optimal solutions empty space.
Clautiaux et al. (2007) presented branch-and-bound method x-coordinates rectangles computed prior y-coordinates. assigning
x-coordinates, method uses relaxation similar cumulative constraint (Aggoun
& Beldiceanu, 1993) requires sum heights rectangles overlapping
particular x-coordinate cannot exceed height bounding box. y-coordinates
determined using search space derived bottom-left heuristic (Chazelle,
54

fiOptimal Rectangle Packing: Absolute Placement Approach

1983), using optimized data structures Martello Vigo (1998). Beldiceanu
Carlsson (2001) applied plane sweep algorithm used computational geometry detect violations non-overlap constraints, later adapted technique geometric
constraint kernel (Beldiceanu, Carlsson, Poder, Sadek, & Truchet, 2007). Lipovetskii (2008)
proposed branch-and-bound algorithm placed rectangles lower-left hand positions.
prior state-of-the-art, due Korf (2003, 2004) Simonis OSullivan (2008),
divide rectangle packing problem containment problem minimal
bounding box problem. former tries pack given set rectangles given bounding
box, latter finds bounding box least area contain given set
rectangles. packers algorithm minimal bounding box problem calls
algorithm containment problem subroutine.
3.2 Overall Search Strategy
Korf et al.s (2010) algorithm, minimum bounding box solver calls
containment problem solver, Simonis OSullivan (2008), assign x-coordinates
prior y-coordinates.
Although use Simonis OSullivans (2008) ideas, take
constraint programming approach constraints specified general-purpose
solver Prolog. Instead, implemented program scratch C++, allowing us
flexibly choose constraints use time naturally encode
search space use y-coordinates. implemented chronological backtracking
algorithm dynamic variable ordering. algorithm works five stages goes
root search tree leaves:
1. minimum bounding box algorithm generates initial candidate set bounding
boxes various widths heights.
2. containment solver called bounding box order increasing area,
infeasible bounding box, insert another back candidate set
bounding boxes height one unit greater. packing found, continue
testing boxes equal area find optimal solutions terminating.
3. containment solver first works x-coordinates model variables
rectangles values x-coordinate locations, using dynamic variable ordering
constraint detects infeasible subtrees.
4. x-coordinate solution found, problem transformed perfect packing instance.
5. searches set y-coordinates model variables empty corners
values rectangles.
describe detail steps.
55

fiHuang & Korf

3.3 Minimum Bounding Box Problem
One way solve minimum bounding box problem find minimum maximum
areas describing set candidate potentially optimal bounding boxes. Boxes
sizes generated areas within range, tested non-decreasing order
area solutions smallest area found. lower bound area
sum areas given rectangles. upper bound area determined
bounding box greedy solution found setting bounding box height
tallest rectangle, placing rectangles first available position
scanning left right, column scanning bottom top.
several techniques (Korf, 2003, 2004) use prune set bounding
boxes, review here. first generate set widths bounding boxes,
starting width widest rectangle width greedy solution
described above. width, generate feasible height using lower bounds
subsequently describe. resulting bounding boxes used initialize
min-heap sorted non-decreasing order area. search proceeds calling
containment solver bounding box minimal area heap. box infeasible,
increase height box one, insert new box back min-heap.
given bounding box width, initialize height maximum following
lower bounds. First, height must least height tallest rectangle
instance. Second, height must large enough accommodate total area
rectangles instance. Third, every pair rectangles, sum widths
exceed width bounding box, bounding box height must least
sum heights, since cant appear side-by-side, one must top
other. Fourth, set rectangles whose widths greater half width
bounding box must stacked vertically, including rectangle smallest height
whose width exactly half width bounding box. Finally, certain properties
exist given rectangle packing instance, force height greater equal
width break symmetry. example, one sufficient property instance
consisting squares, since solution W H bounding box easily transforms
another one H W bounding box. Another sufficient property every rectangle
dimensions w h correspond another one dimensions h w.
unoriented instances, given bounding box width, certain rectangles may forced
one orientation, improving lower bound bounding box height. Note
break symmetry bounding box dimensions every unoriented instance.
3.3.1 Anytime Algorithm
problem instance many rectangles, immediate solution required,
Korf (2003) provides anytime algorithm bounding box problem, replacing one
described above, calls containment problem solver. first find greedy
solution bounding box whose height equal tallest rectangle, described
previous section. repeatedly call containment problem solver following
way. previous attempt given bounding box resulted packing area
greater area best solution seen far, decrease width
one unit attempt solve resulting bounding box problem. instead previous
56

fiOptimal Rectangle Packing: Absolute Placement Approach

attempt infeasible, increase height bounding box one unit.
algorithm terminates width current bounding box less width
widest rectangle.
3.4 Containment Problem
Korfs (2003) absolute placement approach modeled rectangles variables positions
bounding box values. Rectangles placed turn depth-first search,
possible locations tested rectangle. contrast, Simonis OSullivans
(2008) packer assigned x-coordinates rectangles y-coordinates,
suggested Clautiaux et al. (2007), well using cumulative constraint (Aggoun
& Beldiceanu, 1993), improving performance orders magnitude. cumulative
constraint adds height rectangles overlap given x-coordinate location,
pruning values exceed height bounding box. constraint
checked exploring x-coordinates exploring y-coordinates later on.
improved exploring y-coordinates differently, modeling candidate locations
variables, rectangles values (Huang & Korf, 2009), made packer
order magnitude faster Simonis OSullivans.
Simonis OSullivan (2008) furthermore applied least-commitment principle (Yap,
2004) constraint processing, first committing placement rectangles
interval x-coordinates instead single x-coordinate value. x-intervals
explored turn, constrain candidate individual x-coordinates explored later.
works committing x-interval induce pruning via cumulative constraint.
example, picking x-interval [a, b] size smaller width
rectangle wr , implies regardless x-coordinate rectangle eventually takes,
must contribute height x-coordinate within interval [b, + wr ]. Finally,
height bounding box constrains cumulative heights rectangles
given x-coordinate, similar ideas Beldiceanu et al. (2008). Larger intervals result
weaker constraint propagation (less pruning) smaller branching factor, smaller
intervals result stronger constraint propagation larger branching factor. size
intervals experimentally determined.
example, 4 2 rectangle x-coordinates restricted interval [0,2] contributes height 2 x-coordinates 2 3 even prior deciding exact x-coordinate
value. compulsory part (Lahrichi, 1982) constrains cumulative height rectangles may overlap x-coordinates 2 3 solution. interval assignments
infeasible, searching individual x-values futile. However, find
set interval assignments, still search set single x-coordinate
values. Simonis OSullivan (2008) assigned x-intervals, single x-coordinates, y-intervals,
single y-coordinates, order.
3.5 Assigning X-Intervals X-Coordinates
x-coordinates, propose pruning constraint adapted Korfs (2003) wastedspace pruning heuristic, dynamic variable order replace Beldiceanus (2008) fixed ordering, method optimize values assigned x-interval variables.
57

fiHuang & Korf

Figure 4: test violations cumulative constraint, remaining space
placing 3 2 rectangle x=2 represented vector h3, 3, 1, 1, 1, 3i.

3.5.1 Pruning Infeasible Subtrees
present constraint-based formulation Korfs (2003) two-dimensional wasted space
pruning algorithm, adapted one-dimensional case. Given partial solution, Korfs
algorithm computed lower bound amount wasted space, used
prune upper bound. contrast, compute numerical bounds
instead detect infeasibility single constraint.
rectangles placed bounding box, remaining empty space gets chopped
small irregular regions. Eventually empty space segmented small enough
chunks cannot accommodate remaining unplaced rectangles,
point backtrack. assigning x-coordinates bounding box height H,
keep histogram hv1 , v2 , . . . , vH i, vi number empty cells (units empty
space) empty columns height i. example, assume Figure 4
assigned x-coordinates 3 2 rectangle 6 3 bounding box. resulting
histogram would h3, 0, 9i, since 3 cells empty columns height 1, empty
cells columns height 2, 9 cells empty columns height 3.
Assume left place 2 3 2 2 rectangle. assign
six cells 2 3 rectangle empty cells v3 =9, leaving us remaining
empty cells h3, 0, 3i. point, cannot assign area 2 2,
3 empty cells accommodate height need 4, prune.
general, set unplaced rectangles R bounding box height H,

h,

X

wr hr

rR,hr h

H
X


vi ,

(1)

i=h

rectangle r R dimensions wr hr . is, every given height h,
amount space accommodate rectangles height h greater must least
cumulative area rectangles height h greater. check constraint
x-coordinate assignment.
58

fiOptimal Rectangle Packing: Absolute Placement Approach

(a) x=2 dominated position
4 4 square.

(b) x=0 undominated position
4 4 square.

Figure 5: Example dominance conditions.

3.5.2 Pruning Dominance Conditions
Korf (2003) introduced set dominance conditions prune positions large rectangles close sides bounding box. example, imagine must pack
squares 44, 33, 22, 11. Figure 5a, placement 44 square leaves
2 4 gap left side bounding box 3 3 square cannot fit.
2 2 1 1 squares fit within gap, fact placed
entirely within gap. Notice solution arrangement Figure 5a,
always rearrange Figure 5b without disturbing squares. Thus,
need try placing 4 4 square x=2 long tried placing
x=0. general, rectangle placement dominated leaves gap rectangles
individually fit packed together gap without protruding
it. Although Korf hard-coded dominance rules consecutive-square benchmark,
dynamically generate every instance insignificant preprocessing overhead.
3.5.3 Variable Ordering
following subsections consider two variable orders work together packer.
use fixed ordering governs rectangle assigned next. ordering used
x-intervals independently use single x-coordinate variables.
point time, must choose whether assign next x-interval next
single x-coordinate variable. Since ordering x-intervals single x-coordinate
variables simpler, present technique first.
Ordering X-Intervals X-Coordinates Area variable order
based observation placing rectangles larger area constraining
placing smaller area. times either choose assign single
x-coordinate rectangle previously assigned x-interval,
assign x-interval rectangle yet made assignments for. shown
Figure 4, either assignments decrease amount empty space represented
cumulative constraint vector. always pick next variable results
least remaining space.
59

fiHuang & Korf

Ordering Among Rectangles Branching Factor natural variable order
arises consecutive-square unoriented consecutive-rectangle benchmarks using strategy picking constrained variable next. example,
consecutive-square benchmark, largest rectangle clearly largest height,
width, area. However, new benchmarks rectangle largest width
smallest height, largest area, making good variable ordering non-obvious.
propose variable order rectangles various aspect ratios picking
variable fewest number values first, favor smaller branching factor closer
root search tree. oriented equal-perimeter benchmark, recall
assign intervals x-coordinates individual x-coordinates, Simonis
Sullivan (2008) use constant factor times rectangle width define interval
size. branching factor x-interval variables given rectangle

Bw rw
1
Bw 1
b=
,
(2)
=
Crw
C rw
C
Bw bounding box width, rw rectangle width, C constant chosen
experimentally. numerator Bw rw number x-coordinate values
rectangle still fitting bounding box, denominator Crw
size interval assigning given rectangle. example, C=0.75
would assign intervals size three 4 2 rectangle.
may drop translational constant 1/C well positive scalar Bw /C since
interested relative ordering rectangles, leaving us 1/rw
means oriented benchmark place rectangles order decreasing
width. unoriented double-perimeter benchmark, packer first tries values
particular x-interval, rotates rectangle 90-degrees trying another set
x-interval values. case branching factor


Bw rw
Bw 1
Bw rh
1
2
b=
=
+
+
.
(3)
Crw
Crh
C rw
rh
C
mentioned before, drop scalar translational constant, giving us
1
rw + rh
1
=
+
.
(4)
rw
rh
rw rh
rectangles given instance perimeter definition,
numerator result Equation 4 constant. Therefore unoriented benchmark,
place rectangles order decreasing area.
3.5.4 Determining Sizes X-Intervals
consecutive-square benchmark, packer used interval size 0.35 times
width given rectangle. found larger interval sizes improve performance
packer new equal-perimeter benchmarks, use value C=0.55 instead.
assign larger intervals short wide rectangles, x-interval variables
rectangles tend branching factors three less. balance
sizes intervals values assigned equally constraining subtrees.
example, consider C=0.55, rectangle width 20, set possible x-coordinate
60

fiOptimal Rectangle Packing: Absolute Placement Approach

values [0,23]. Without balancing sizes intervals, packer would explore interval
sizes 20C = 11, x=[0,10], x=[11,21], finally remaining domain values
small interval x=[22,23]. results small compulsory parts therefore
large search subtrees first two branches, large compulsory part thus
small search subtree third.
Since must explore three branches anyway, balance sizes interval
assignments exploring x=[0,7], x=[8,15], x=[16,23]. eventual effect better
balance size search subtrees amongst branches. packer first computes
branching factor induced global interval parameter C=0.55 rectangle,
balances number values interval assignment.
Interactions Interval Assignment Dominance Conditions consecutive-square instances, squares several positions following x=0
dominated. Therefore, packer first branches assigning degenerate interval x=[0,0] exploring interval assignments undominated positions. Although
technique increased performance packer fivefold compared leaving out,
strategy slowed performance fivefold oriented unoriented doubleperimeter benchmark. reason degradation performance follows.
equal-perimeter benchmarks, 1 N rectangle always partially fit gaps
left rectangles, must always protrude gaps, thereby eliminating
dominance conditions previously described. Without dominated positions
account for, simply applying strategy used consecutive-squares new
benchmarks results packer committing single x-coordinate values situations
desirable include positions larger interval assignment.
avoid this, packer detects dominated positions dynamically
chooses whether assign degenerate interval x-coordinate assignment,
immediately begin interval assignments.
3.6 Perfect Packing Transformation
every complete x-coordinate solution, transform problem instance perfect
packing problem instance working y-coordinates. perfect packing instance
rectangle packing problem property solution empty space.
transformation done adding original set rectangles number 1 1
rectangles necessary increase total area rectangles bounding box.
Although new 1 1 rectangles increase problem size, hope ease
solving perfect packing instances offset difficulty packing rectangles. Next
describe search space perfect packing. show, methods rely
perfect packing property empty space.
3.7 Assigning Y-Coordinates
alternative asking rectangle go? ask rectangle
go here? former model, rectangles variables empty locations
values, whereas latter, empty locations variables rectangles values.
y-coordinates, search latter model. use 2D bitmap draw placed rectangles
61

fiHuang & Korf

test overlap, backtrack positions cannot accommodate remaining
rectangles, required Korfs (2003) wasted space pruning rule.
3.7.1 Empty Corner Model
perfect packing solutions, every rectangles lower-left corner fits lower-left
empty corner formed rectangles, sides bounding box, combination
both. model, one variable per empty corner. final solution, since
rectangle goes exactly one empty corner, number empty corner variables
equal number rectangles perfect packing instance. set values
set unplaced rectangles.
search space interesting property variables dynamically created
search x- y-coordinates empty corner known
rectangles create placed. Furthermore, placing rectangle empty corner
assigns x- y-coordinates.
Note empty corner model describe perfect packing solutions. Given
perfect packing solution, list unique sequence rectangles scanning
left right, bottom top lower-left corners rectangles. sequence
corresponds sequence assignments root search space leaf
tree. property bounds maximum size search space N 0 ! N 0
number rectangles performed perfect packing transformation.
3.7.2 Duplicate Rectangles
Due additional 1 1 rectangles perfect packing transformation,
introduced additional redundancy problem. simple way handle
follows. particular empty corner, never place rectangle duplicate one
already tried position. method handling duplicates applies
duplicate rectangles original problem instance.

4. Experimental Results
benchmarked packers Linux 2GHz AMD Opteron 246 2GB RAM.
packer call KMP10 (Korf et al., 2010) benchmarked machine,
quote published results. include data relative placement
packer competitive. Results Simonis OSullivans packer (2008),
call SS08, quoted, obtained SICStus Prolog 4.0.2 Windows
3GHz Intel Xeon 5450 3.25GB RAM. Since machine faster ours,
comparisons conservative estimate relative performance.
4.1 Previous Benchmarks
consecutive-square benchmark unoriented consecutive-rectangle
benchmarks (Korf et al., 2010) used literature measure performance,
include data collected using two benchmarks.
62

fiOptimal Rectangle Packing: Absolute Placement Approach

Size
N

KMP10
Time

SS08
Time

FixedOrder
Time

20
21
22
23
24
25
26
27
28
29
30
31
32

1:32
9:54
37:03
3:15:23
10:17:02
2:02:58:36
8:20:14:51
34:04:01:03

:02
:07
:51
3:58
5:56
40:38
3:41:43
11:30:02

:00
:03
:02
:14
:40
2:27
10:25
1:08:55
2:18:12:13

HK09
Time
:00
:03
:02
:12
:37
2:14
9:39
35:12
4:39:31
8:06:03
2:17:32:52
4:16:03:42
33:11:36:23

Table 1: CPU times required various packers consecutive-square benchmark,
task pack squares 1 1 N N .

4.1.1 Consecutive Squares
Table 1 compares CPU runtimes four packers consecutive-square benchmark.
first column specifies instance size, number squares
size largest one. remaining columns specify CPU times required various
algorithms find optimal solutions format days, hours, minutes,
seconds. multiple boxes minimum area, N =27 listed Table
8 Appendix 4.4, report total time required find optimal bounding boxes.
two reasons. First, finding minimum area bounding boxes removes
question bounding box test first one area. Second,
providing optimal solutions, researchers working rectangle packing use
information verify correctness programs.
HK09 includes wasted space pruning rule x-coordinates, dynamic variable
ordering x-intervals x-coordinates, perfect packing transformation,
related search space inference rules. named packer consistent
previous work (Huang & Korf, 2009). SS08 refers previous state-of-the-art
packer (Simonis & OSullivan, 2008). largest problem previously solved N =27
took SS08 11 hours. solved problem 35 minutes solved five
open problems N =32. KMP10 refers Korf et al.s (2010) absolute placement
packer. FixedOrder assigns x-intervals single x-coordinates, includes
ideas. HK09s dynamic variable ordering x-coordinates order
magnitude faster FixedOrder N =28. order magnitude improvement
FixedOrder SS08 likely due use perfect packing assigning ycoordinates. include timing packer perfect packing disabled
competitive (e.g., N =20 took 2.5 hours).
63

fiHuang & Korf

Size
N
21
22
23
24
25
26
27
28
29
30
31
32

X-Coordinate
Solutions
665
283
391
870
193
1,026
244
2,715
11,129
10,244
73,614
37,742

Seconds
X
0.35
0.95
6.54
19.41
73.38
313.81
1,181.53
8,987.36
15,677.20
124,399.74
214,575.08
1,916,312.67

Seconds

1.04
0.18
0.31
1.08
0.14
1.39
0.60
23.40
28.82
17.97
254.42
102.59

Ratio
X:Y
0.3
5.3
21.1
18.0
524.1
225.8
1,969.2
384.1
544.0
6,922.6
843.4
18,679.3

Table 2: CPU times spent searching x- y-coordinates consecutive-square
benchmark

Table 2 second column number complete x-coordinate assignments
packer found entire run particular problem instance. third column
total time spent searching x-coordinates. fourth column total time
spent performing perfect packing transformation searching y-coordinates.
columns represent total CPU time entire run given problem instance.
last column ratio time third column fourth. Interestingly,
almost time spent x-coordinates opposed y-coordinates,
suggests could efficiently enumerate x-coordinate solutions, could
efficiently solve rectangle packing. confirmed relatively x-coordinate
solutions exist even large instances. data Table 2 obtained Linux
2.93GHz Intel Core 2 Duo E7500 machine separate experiment Table 1,
total time spent given instance different.
4.1.2 Unoriented Consecutive Rectangles
Table 3 compares CPU times packer unoriented consecutive-rectangles
benchmark Korf et al. (2010). Although techniques due Simonis
OSullivan (2008) outperform Korf et al. consecutive-square benchmark,
previously published results benchmark besides Korf et al.
benchmark easier consecutive-square benchmark, break
contributions techniques, differences delineated
clearly previous section. primary differentiating feature benchmark
rectangles unoriented.
first column gives size problem instance. second column gives
performance previous state-of-the-art packer benchmark, using Korf et al.s
code (2010). third column gives performance packer benchmark.
64

fiOptimal Rectangle Packing: Absolute Placement Approach

Size
N

KMP10
Time

HK10
Time

16
17
18
19
20
21
22
23
24
25
26
27
28
29

:01
:05
:17
:07
8:11
15:00
1:09:45
8:51:46
11:53:17
7:17:00:03

:00
:00
:00
:00
:05
:06
:17
:47
13:38
2:21:10
6:31:51
4:07:37:08
1:16:43:02
6:04:47:06

Table 3: CPU times required two packers unoriented consecutive-rectangle benchmark, task pack unoriented rectangles sizes 12, 23, ..., N (N +1).

data table collected Linux 2.93GHz Intel Core 2 Duo E7500 machine,
except N =28 N =29, collected Linux 2.53GHz Intel Xeon E5630
12GB RAM, experiments revealed 20% faster former
machine.
benchmark techniques allowed us extend known solutions
N =25 N =29 allowed us solve N =25 80 times faster previous
state-of-the-art benchmark.
4.2 Oriented Equal-Perimeter Unoriented Double-Perimeter Rectangles
section uses new benchmarks compare techniques developed
non-square instances. techniques discuss here, including dynamic adjustment
interval sizes generalized variable order based branching factor, largely
affect performance packer consecutive-square benchmark. fact,
tested packer benchmark see effects extra overhead added
improvements. new packer resulted five percent speedup compared
packer without changes consecutive-square benchmark, likely due minor
improvements data structures, balancing interval sizes. Therefore, compare
effects techniques new benchmarks. techniques
developed new benchmarks improve performance oriented unoriented
cases, discuss together.
Table 4 compares performance packers oriented equal-perimeter benchmark Table 5 compares packers using unoriented double-perimeter
benchmark. first column refers problem size instance, number
65

fiHuang & Korf

Size
N

Boxes
Tested

HK09
Time

OptDom
Time

BrFactor
Time

C=0.55
Time

HK10
Time

13
14
15
16
17
18
19
20
21
22
23

7
7
10
9
8
12
12
11
9
15
16

:01
:02
:16
:57
5:56
1:06:32
6:35:48
1:18:51:34
3:21:31:46

:00
:01
:05
:16
1:21
14:47
1:26:16
7:36:09
13:33:16

:00
:00
:01
:02
:27
6:15
31:23
1:51:10
4:22:49

:00
:00
:00
:00
:03
:32
3:34
13:06
20:49
14:22:03

:00
:00
:00
:00
:02
:22
2:15
7:51
11:20
9:12:37
3:22:50:38

Table 4: CPU times required various packers oriented equal-perimeter rectangle
benchmark, task pack oriented rectangles sizes 1 N , 2 (N 1), ...,
(N 1) 2, N 1.

Size
N

Boxes
Tested

HK09
Time

OptDom
Time

BrFactor
Time

C=0.55
Time

HK10
Time

11
12
13
14
15
16
17
18

12
17
13
17
21
35
27
35

:01
:20
1:45
28:48
1:43:01
1:16:46:44

:00
:04
:21
4:53
11:36
4:13:34
1:12:40:14

:00
:04
:21
4:53
11:36
4:13:34
1:12:40:14

:00
:01
:06
1:19
3:33
1:16:02
9:44:14

:00
:01
:06
1:15
2:34
1:01:54
7:53:50
2:02:10:38

Table 5: CPU times required various packers unoriented double-perimeter rectangle benchmark, task pack unoriented rectangles sizes 1 (2N 1),
2 (2N 2), ..., (N 1) (N + 1), N N .

66

fiOptimal Rectangle Packing: Absolute Placement Approach

rectangles. second column gives number bounding boxes tested order
find optimal solutions. remaining columns represent CPU times different
versions packer format days, hours, minutes, seconds. wrote
packer C++ collected data Linux 2.93GHz Intel Core 2 Duo E7500 machine.
left right, successive packer improves previous one including
additional technique. column called HK09 data collected using techniques
developed specifically consecutive-square packing, include perfect packing
transformation related inference rules, dynamic variable ordering single
x-coordinates x-intervals, wasted space pruning rule x-coordinates
(Huang & Korf, 2009). compare new variable ordering rectangles
various aspect ratios, used order decreasing area default HK09.
OptDom improves upon HK09 dynamically detecting dominance rules apply
inapplicable, optimizes x-interval assignments knowledge. BrFactor
improves upon OptDom orders oriented equal-perimeter benchmark decreasing width unoriented double-perimeter benchmark decreasing area. C=0.55
improves upon BrFactor use interval size 0.55 instead C=0.35
consecutive-square benchmark. Finally, HK10 improves upon C=0.55 using
knowledge branching factor rebalance sizes interval assignments
x-coordinates.
Notice OptDom, BrFactor, C=0.55 introduce techniques reduce
branching factor, greater effect performance HK10, whose
new technique seeks make intervals assigned equally constraining. experiments
reveal techniques interact one another, note without including
dominated positions intervals, performance gained techniques
appears muted. interaction tune global interval parameter C
including techniques affect branching factor.
Ordering branching factor improved performance oriented equal-perimeter
benchmark unoriented benchmark. latter case, seen Table 5,
technique ordering branching factor prescribes ordering decreasing area,
gave packer reasonable default. Therefore, difference
algorithm performance OptDom BrFactor columns Table 5.
Note unoriented double-perimeter benchmark requires packer try
twice many bounding boxes given parameter N required oriented benchmark. due 2N -1 largest dimension unoriented
benchmark N largest dimension oriented benchmark. larger
rectangles introduce higher precision problem, must try bounding
boxes. containment problem unoriented instance problem space
factor 2N larger oriented instance due two orientations
rectangle. Thus, instance N rectangles benchmark incomparable
instance N squares consecutive-square benchmark evaluating benchmark
difficulty.
summary, using techniques together, solve N =21 oriented
equal-perimeter benchmark 500 times faster N =16 unoriented doubleperimeter benchmark 40 times faster techniques presented optimized
consecutive squares.
67

fiHuang & Korf

Size

Boxes Tested

CPU Time

N

Squares

Perimeter

Squares

Perimeter

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

10
5
14
12
14
20
17
19
19
17
21
22
30
27
21
30
36

9
8
12
12
11
9
15
16

:00
:00
:00
:00
:00
:01
:01
:07
:20
1:14
5:15
19:42
2:30:11
4:21:46
1:10:33:38
2:11:40:29
22:04:20:15

:00
:02
:22
2:15
7:51
11:20
9:12:37
3:22:50:38

Table 6: Number bounding boxes tested CPU time required solve given instance
consecutive-square oriented equal-perimeter benchmarks.

68

fiOptimal Rectangle Packing: Absolute Placement Approach

4.3 Comparing Easy Hard Benchmarks
following tables compare difficulty various benchmarks using packer (Huang
& Korf, 2010) optimizations enabled.
4.3.1 Consecutive Squares vs. Equal-Perimeter Rectangles
Table 6, first column indicates number rectangles instance. second
third columns labeled Boxes Tested give number bounding boxes
tested finding optimal solutions consecutive-square benchmark
oriented equal-perimeter benchmark, respectively. fourth fifth columns give
performance rectangle packer benchmarks well. data point
table collected using Linux 2.93GHz Intel Core 2 Duo E7500 using one process, one
thread, one core.
Notice given instance number rectangles, oriented equalperimeter benchmark significantly harder consecutive-square benchmark.
due fact given problem size, consecutive-square benchmark contains
many little squares typically easy place property missing equalperimeter benchmark. fact, N =23 packer requires four orders magnitude
time find optimal solutions new benchmark compared instance
number items consecutive-square benchmark.
4.3.2 Unoriented Consecutive-Rectangles vs. Unoriented Double-Perimeter
Rectangles
Table 7 shows removing certain properties results successively difficult benchmarks. start unoriented consecutive-rectangle benchmark (Korf et al., 2010)
contains many easy properties. Doubly Scaled column pack 2 4, 4 6,
68, ..., (2N )(2N +2) rectangles, simply scales unoriented consecutive-rectangle benchmark factor two. benchmark difficult integers
higher magnitude lead x-coordinates search, turn increases branching factor problem. Unique Dimensions column pack rectangles
sizes 1 2, 3 4, 5 6, ..., (2N 1) (2N ), differs previous benchmark
dimensions unique. last column distributes area among rectangles
uniformly avoid consolidating area first rectangles.
column culmination difficult properties identified
rectangle packing benchmark, call unoriented double-perimeter benchmark.
data points table collected using Linux 2.93GHz Intel Core 2 Duo E7500
machine without parallelization, except N =28 N =29, collected
Linux 2.53GHz Intel Xeon E5630 machine 12GB RAM, estimate
thirty percent faster.
4.4 Bounding Boxes Minimum Area
section list optimal bounding boxes various benchmarks found
program optimizations enabled. Notice duplicate data
69

fiHuang & Korf

Size
N
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

Unoriented
ConsecutiveRectangles
:00
:00
:00
:00
:00
:00
:00
:00
:05
:06
:17
:47
13:38
2:21:10
6:31:51
4:07:37:08
1:16:43:02
6:04:47:06

Doubly
Scaled
:00
:00
:00
:00
:00
:00
:01
:01
:09
:10
:29
1:13
27:37
6:41:20
1:02:12:06

Unique
Dimensions
:00
:00
:01
:00
:01
:01
:03
:11
:50
3:00
15:34
3:21:36
12:23:37

Unoriented
DoublePerimeter
:01
:06
1:15
2:34
1:01:54
7:53:50
2:02:10:38

Table 7: CPU time required optimized packer various benchmarks increasing
difficulty.

70

fiOptimal Rectangle Packing: Absolute Placement Approach

unoriented high-precision rectangle benchmark, leave Table 10, Section 5.5.2,
since discussion refers data.
first column tables 8 9 refer size problem instance
respective benchmarks. columns called Optimal Solution give dimensions
optimal bounding boxes given instance. next column called Empty Space gives
percent empty space optimal solution. next column gives number
bounding boxes tested order find optimal solutions given instance.

5. Absolute Placement High-Precision Instances
Meir Moser (1968) first proposed problem finding smallest square
contain infinite series rectangles sizes 11 12 , 12 31 , 13 14 , ..., etc. rectangles
cannot overlap unoriented. unit square exactly enough area since total
area rectangles infinite series one. hand, space
wasted, suggesting task infeasible. Inspired problem, propose last
benchmark developed several new techniques.
introduce unoriented high-precision rectangle benchmark, task find
bounding boxes minimum area contain finite set unoriented rectangles
sizes 11 12 , 12 13 , ..., N1 N 1+1 . example, N =4 one must pack rectangles
sizes 11 12 , 21 13 , 13 41 , 14 51 . Alternatively, one may try pack rectangles sizes
60 30, 30 20, 20 15, 15 12 60 60 square, original instance
scaled factor 60, least common multiple rectangle denominators.
strategy required broad class recent rectangle-packers explore domain
integer x- y-coordinates rectangles quickly break higher N .
example, optimal solution N =15 400 billion unique coordinate pairs
rectangles assigned to. benchmark complements rather replaces
current low-precision benchmarks, neglected high-precision instances.
remainder section organized follows. first review previous
work proposing solution techniques may unaffected precision rectangle
dimensions. describe several adaptations low-precision techniques
high-precision case, along new techniques developed specifically high-precision
rectangle instances, finally follow experimental results.
5.1 Previous Work
relative placement approach Moffitt Pollack (2006) rectangle packing,
similar types search spaces used resource-constrained scheduling (Weglarz, 1999),
promises immune problem high-precision rectangle instances. However, since
many techniques described previous sections cannot
extended packer working relative placement search space, decided
stay within absolute placement framework attempt mitigate problems
introduced high-precision numbers.
71

fiHuang & Korf

Consecutive Squares

Consecutive Rectangles

Size
N

Optimal
Solutions

Empty
Space

Boxes
Tested

Optimal
Solutions

Empty
Space

Boxes
Tested

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

11
23
35
57
512
911
1114, 722
1415
1520
1527
1927
2329
2238
2345
2355
2854, 2756
3946
3169
4753
3485
3888
3998
6468
5688
43129
7089

0.00%
16.7%
6.67%
14.3%
8.33%
8.08%
9.09%
2.86%
5.00%
4.94%
1.36%
2.55%
2.03%
1.93%
1.98%
1.06%
0.50%
1.40%
0.84%
0.69%
0.99%
0.71%
0.64%
0.58%
0.40%
0.47%

1
1
1
1
1
1
3
2
4
5
3
6
5
8
13
10
5
14
12
14
20
17
19
19
17
21

0.00%
0.00%
0.00%
0.00%
0.00%
1.75%
0.00%
0.00%
1.79%
0.45%
0.00%
0.95%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.20%
0.00%
0.00%
0.00%
0.00%
0.00%

1
1
1
2
2
2
2
1
5
5
2
4
1
2
1
2
2
3
2
4
2
2
3
4
5
7

27
28
29
30
31
32

47148, 7494
63123
81106
51186
91110
85135

0.37%
0.45%
0.36%
0.33%
0.33%
0.31%

22
30
27
21
30
36

12
24
45
58, 410
514
619
1214
1516
1621, 1424
1726
2226
2135
2635
3235, 2840
3440
3251
3457
3076
3576, 3870
3588, 4470, 5556
3991
4492
40115, 46100
40130, 52100, 6580
45130, 6590, 7578
42156, 52126, 56117,
63104, 7291, 7884
63116
56145, 70116
62145

0.00%
0.00%
0.00%

3
3
2

Table 8: optimal solutions consecutive-square benchmark, task
pack squares sizes 11, 22, ..., N N , unoriented consecutive-rectangle
benchmark, task pack unoriented rectangles sizes 1 2, 2 3, ...,
N (N + 1).

72

fiOptimal Rectangle Packing: Absolute Placement Approach

Oriented Equal Perimeter

Unoriented Double Perimeter

Size
N

Optimal
Solutions

Empty
Space

Boxes
Tested

Optimal
Solutions

Empty
Space

Boxes
Tested

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

11
23
34
46
67
610
811
816
1116
1121
1421
1329
1629
1930, 1538
2429
2336

0.00%
33.3%
16.7%
16.7%
16.7%
6.67%
4.55%
6.25%
6.25%
4.76%
2.72%
3.45%
1.94%
1.75%
2.30%
1.45%

1
1
1
1
4
2
2
5
6
8
6
7
7
7
10
9

0.00%
22.2%
8.33%
7.41%
6.86%
5.85%
3.08%
1.59%
1.50%
0.69%
1.15%
1.37%
0.71%
0.67%
0.67%
0.83%

1
1
2
2
8
9
11
8
13
8
12
17
13
17
21
35

17
18
19
20
21
22
23

2441
2448
3242, 2456
3742
3551
3460
3861

1.52%
1.04%
1.04%
0.90%
0.78%
0.78%
0.78%

8
12
12
11
9
15
16

11
33
38
69
617
919
1320
1821
1341
2430
2933
2159
3841
3851, 17114
4454
4564, 3096,
4072, 4860
3988, 5266
5574

0.44%
0.57%

27
35

Table 9: optimal solutions oriented equal-perimeter rectangle benchmark,
task pack oriented rectangles sizes 1 N , 2 (N 1), ..., (N 1) 2,
N 1, unoriented double-perimeter rectangle benchmark, task
pack unoriented rectangles sizes 1 (2N 1), 2 (2N 2), ..., (N 1) (N + 1),
N N.

73

fiHuang & Korf

(a)

(b)

Figure 6: Examples mapping solutions one rectangles left-most,
bottom-most positions.

5.2 Overall Strategy
Given instance high-precision benchmark described rational numbers,
multiply values least common multiple denominators get instance
integer dimensions. apply absolute placement solution techniques,
improvements subsequently explain, order find optimal solutions.
found, divide x- y-coordinates describing optimal solutions initial
scaling constant order obtain optimal solutions original problem.
Note map every solution one rectangles slid
left bottom much possible (Chazelle, 1983). example, solution
Figure 6a transformed Figure 6b. Since rectangles propped
left rectangles, rectangles x-coordinate sum
subset widths rectangles rectangles y-coordinate
sum subset heights rectangles. Similarly, width height
bounding box must sum subset widths heights rectangles,
respectively.
following subsections first explain techniques respect oriented
instances, follow handle unoriented case.
5.3 Minimum Bounding Box Problem
Since build initial set bounding boxes pairwise combinations widths
heights within given ranges, space pruned considering bounding box
widths heights equal subset sums rectangle widths, subset sums
rectangle heights, respectively. Recall Section 4.4 every bounding box
width, compute lower bound height. modify rounding
resulting bound next subset sum rectangle heights.
74

fiOptimal Rectangle Packing: Absolute Placement Approach

5.3.1 Precomputing Subset Sums
compute set subset sums prior searching. oriented rectangles
cannot rotated compute two sets: one based heights rectangles
representing candidate y-coordinates, one based widths representing
candidate x-coordinates. distinction generates fewer subset sums compared
single set subset sums generated widths heights.
5.3.2 Pruning Combinations Widths Heights
reject bounding boxes certain width height combinations
infeasible. pruning technique relies observation certain cases, may
one unique set rectangles generate specific width (height) bounding
box.
example, consider bounding box width generated unique
set rectangles. assume heights set rectangles uniquely
determine subset sum specific bounding box height. say combination
bounding box width height incompatible. reason set rectangles
way bounding box given width, implies set
rectangles must appear solution laid horizontally one another. Thus,
set rectangles cannot appear stacked vertically solution. contradicts
implications bounding box given height. Note particular example,
compatible height maximum height rectangles.
5.3.3 Learning Infeasible Attempts
Recall algorithm solving minimal bounding box problem repeatedly calls
algorithm solve containment problem. Bounding boxes tested order
non-decreasing area first boxes solutions found. learn
infeasible attempts.
example, consider pack N rectangles {r1 , r2 , ..., rN }. Note use
pre-computed variable order rectangles. Let rd , < N rectangle corresponding
deepest search tree depth-first search able go, entire
search effort given bounding box. containmnet solver says bounding box
infeasible, next bounding box height consider next
greatest subset sum based smaller set {r1 , r2 , ..., rd+1 } instead considering N
rectangles. intuition behind since containment solver failed even
find arrangement first + 1 rectangles, doesnt make sense involve
remaining rectangles {rd+2 , ...rN } next largest subset sum bounding box
height.
method resembles conflict-directed backtracking. implementation,
consider effect pruning using wasted space heuristic well.
5.4 Containment Problem
Similar low-precision methods, first assign x-coordinates rectangles,
conduct perfect packing transformation, finally work y-coordinates (Huang
75

fiHuang & Korf

& Korf, 2010). main difference high-precision methods lowprecision methods instead considering possible integers domain
x- y-coordinates, consider smaller set subset sums widths heights
rectangles. methods using x-intervals remain unchanged
describe search individual x-coordinates here.
5.4.1 Assigning X-Coordinates
oriented rectangles, choose x-coordinates set subset sums rectangle
widths. Instead precomputing set minimal bounding box problem,
generate dynamically every node search prior branching
various x-coordinate value assignments. set computed follows:
1. Initialize set value 0, represents placing rectangle
left side bounding box.
2. every rectangle r already assigned x-coordinate point search,
insert set sum x-coordinate width. represents placing
rectangle right side r.
3. every rectangle x-coordinate still unassigned, add width every
element set, insert new sums back set.
5.4.2 Perfect Packing Transformation
assigning x-coordinates, create number 1 1 rectangles account
empty space original instance. transformation results new instance,
empty space, consists original rectangles plus new 1 1 rectangles.
given empty corner partial solution, ask original unplaced rectangles
might fit there, 1 1 rectangle, essentially modeling empty corners variables
rectangles values.
high-precision benchmark, solving N =15 requires creating 1.5 billion 1 1
rectangles scaled problem large number. packer
simply requires much memory time. avoid problem creating fewer
much larger rectangles account empty space.
Widening Existing Rectangles Assume Figure 7a task pack three
rectangles. 10 20, 20 10, 40 10 rectangle 60 50 bounding
box, assume assigned x-coordinates y-coordinates. Given
x-coordinates already assigned, resulting packing solution space right
40 10 rectangle must always empty. Thus, replace 40 10 rectangle
60 10 rectangle, effectively widening original rectangle. Likewise, replace
20 10 rectangle 30 10 rectangle, 10 20 rectangle 30 20 rectangle,
Figure 7b. packer greedily attempts widen rectangles towards right
widening towards left. solving problem return
rectangles back original widths. avoids creating many 1 1 rectangles
perfect packing transformation represent empty space.
76

fiOptimal Rectangle Packing: Absolute Placement Approach

(a) partial solution xcoordinates known.

(b) result widening rectangles.

Figure 7: Widening existing rectangles.

(b) solution without 60 1 rectangles empty space.

(a) partial solution xcoordinates known.

Figure 8: Consolidating empty space horizontal strips.

Turning Empty Space Large Rectangles partial solution Figure 8a,
assigned x-coordinates rectangles 60 40 bounding box. Instead
creating three hundred 1 1 rectangles represent empty space indicated
single hash marks, use ten 30 1 rectangles without losing packing solutions.
Similarly, represent doubly-hashed empty space twenty 301 rectangles instead
six hundred 1 1 rectangles. Note cannot use 60 1 rectangles empty
space since would inadvertently prune potential solution Figure 8b.
5.4.3 Assigning Y-Coordinates
perfect packing transformation, assign y-coordinates asking rectangle
placed given empty corner. before, enforce constraint ycoordinate rectangle must subset sum rectangle heights. Note
rectangles create via perfect packing transformation included subset
sum calculations, since represent empty space.
5.4.4 Handling Unoriented Instances
unoriented instances, computing initial bounding box widths heights,
generate single set subset sums using widths heights rectangles
instance instead keeping widths separated heights. Likewise,
generating set candidate x- y-coordinates, must add fourth step
77

fiHuang & Korf

Size
N

Optimal
Solution

LCM

Bits
Precision

HK10
Boxes

Subsets
Boxes

Mutex
Boxes

HK11
Boxes

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

1/21
1/24/3
1/219/12
5/61, 1/25/3
1/217/10
1/2107/60
1/2107/60
1/2163/90
1/2163/90
1/21817/990
1/27367/3960
1/267/36
1/2185/99
1/2169/90
1/279/42

2
6
12
60
60
420
840
2,520
2,520
27,720
27,720
360,360
360,360
360,360
720,720

2
6
8
12
12
18
20
23
23
30
30
37
37
37
39

1
1
2
30
20
1,979
4,033
39,357
13,571
2,682,948

1
1
2
5
7
59
151
693
1,083
7,489
31,196
66,425
289,217
549,135
1,171,765

1
1
2
4
7
44
107
465
755
4,901
22,822
38,827
162,507
382,059
651,041

1
1
2
4
7
29
46
124
192
585
1,641
2,366
5,027
9,548
15,334

Table 10: minimum-area bounding boxes number bounding boxes tested
packing unoriented rectangles 11 21 , 12 13 , 31 41 , ..., N1 N 1+1 .

bulleted list subsection 5.4.1 add height every rectangle
yet placed, every element set subset sums, represents possibility
rotating rectangle.
5.5 Experimental Results
present two different data tables, one relating improvements minimal bounding
box problem measured number bounding boxes tested, another one
overall CPU time solving entire rectangle-packing problem. separate
experiments way solution schema decouples minimal bounding box
problem containment problem.
5.5.1 Minimum Bounding Box Problem
Table 10 shows optimal solutions unoriented high-precision rectangle benchmark
along various properties corresponding instances. first two columns give
problem size dimensions optimal solutions, respectively. third gives
least common multiple first N +1 integers. fourth number bits required
represent area minimal bounding box. Note one optimal
solutions width 12 , since first rectangle much larger others.
N =12 larger, required precision exceeds 32-bit integer.
fifth eighth columns compare number bounding boxes various
packers test find optimal solutions unoriented high-precision rectangle bench78

fiOptimal Rectangle Packing: Absolute Placement Approach

Size
N
6
7
8
9
10
11
12
13
14
15

HK10
Time

Empty Space
Time

Dynamic
Time

HK11
Time

:00
:02
1:11
1:51

:00
:00
:00
:03
1:57
41:40
7:30:26

:00
:00
:00
:00
:02
:57
6:38
2:20:12
1:05:56:14

:00
:00
:00
:00
:01
:18
:33
16:41
46:56
4:28:20

Table 11: CPU times various packers find minimum-area bounding boxes containing
unoriented rectangles 11 12 , 21 13 , 13 41 , ..., N1 N 1+1 .
mark. column going left right, add one new technique minimal
bounding box problem.
HK10 number bounding boxes required simply scaling problem
instance described completely integers. column called Subsets improves upon
second testing bounding boxes whose dimensions constrained
subset sums technique. column called Mutex improves upon third rejecting
bounding boxes subset sum corresponding width mutually exclusive
subset sum corresponding height. HK11 improves upon previous packer using
information learned infeasible attempt reject future bounding boxes.
Using improvements, N =10 test 4,500 times fewer bounding boxes compared
previous state-of-the-art. instance HK10 ran memory last
bounding box sheer number 1 1 rectangles created perfect
packing transformation. introduction prime number 11 denominator
problem instance responsible increased difficulty N =9 N =10.
5.5.2 Containment Problem
Table 11 compares performance various packers using techniques.
decoupled minimal bounding box problem containment problem,
table use optimizations minimal bounding box problem,
compare individual techniques applied containment problem. Therefore,
performance data reported required solve overall problem using various
containment problem packers.
first column gives size problem instance high-precision rectangle
benchmark. previous tables, successive column left right improves upon
previous column additional technique. column called HK10 corresponds
using previous state-of-the-art improved minimal bounding box algorithm.
column called Empty Space improves upon HK10 precomputing subset
79

fiHuang & Korf

sums prior searching x-coordinates, uses techniques consolidate empty
space y-coordinates. column called Dynamic improves upon previous one
dynamically computing subset sums. Finally, last column called HK11 adds
ability learn unplaced rectangles exclude subset sums computation
exploring infeasible subtree. data collected using Linux eight core 3GHz
Intel Xeon X5460 without parallelization.
N =10, problem scaled 27,720 times dimensions, requiring HK10
create 6,597,361 1 1 units empty space perfect packing transformation
causing run memory. Empty Space could complete N =13 within
day sheer number subset sums must explored x-
y-coordinates, problem avoided Dynamic.
5.5.3 Comparison Relative Placement
interesting note number bounding boxes appears increasing exponentially, mostly likely due exponential growth number subset sums
introduced successive rectangle high-precision benchmark. difficulty
unoriented high-precision rectangle benchmark compounded fact
precision increases, branching factor single x- y-coordinate values
containment problem increases.
contrast absolute placement technique, Moffitt Pollacks (2006) relative
placement techniques enumerate different exact locations rectangles,
therefore promise immune problem high-precision rectangles. used
variable every pair rectangles represent relations above, below, left, right.
search algorithm required least one non-overlapping constraints
true every pair rectangles. meta-CSP approach modeled work
Dechter, Meiri, Pearl (1991) solving binary constraint satisfaction problems,
included various pruning techniques model reduction, symmetry breaking,
graph-based pruning heuristics (Korf et al., 2010). solve minimum bounding box
problem branch-and-bound algorithm, evaluating size bounding box
non-overlapping relationships determined, keeping track bounding
box smallest area seen far.
Note contrast, solver tests bounding boxes order non-decreasing area.
Also, size formulation uses N 2 variables use N . Finally,
packer returns one optimal solution opposed ours, work
returning optimal solutions.
able benchmark code machine order provide
kind comparison methods ours. crude comparison,
cannot run packer unoriented high-precision rectangle benchmark since
hard-coded packer unoriented consecutive-rectangle benchmark, much
easier benchmark shown Table 7.
first column Table 12 refers problem size. second column called MP06
gives CPU time required Moffitt Pollacks code problem instances
unoriented consecutive-rectangle benchmark, uses low-precision rectangles. third
column called HK11 gives CPU time required packer problem instances
80

fiOptimal Rectangle Packing: Absolute Placement Approach

Size
N

MP06
Time

HK11
Time

10
11
12
13
14
15

:03
:13
2:26
17:40
1:48:09
7:27:42

:01
:18
:33
16:41
46:56
4:28:20

Table 12: CPU times required Moffitt Pollacks packer unoriented consecutiverectangle packer unoriented high-precision rectangle benchmarks.

unoriented high-precision rectangle benchmark. data point table
collected using eight core 3GHz Intel Xeon X5460 Linux without parallelization. Note
algorithm packs number rectangles somewhat faster Moffit
Pollacks.
5.6 Summary High-Precision Rectangles
section proposed new benchmark consisting instances rectangles
high-precision dimensions well techniques using subset sums limit number
positions must considered, rules filter subset sums minimal
bounding box containment problems, methods learn infeasible subtrees,
ways reduce number rectangles created perfect packing transformation.
techniques exploit special properties benchmark, useful
rectangles high-precision dimensions.
Using methods, solved six problems N =15 new benchmark compared using low-precision packer scaled instance. packer
two orders magnitude faster N =9 previous state-of-the-art, tests
4,500 times fewer bounding boxes. cursory comparison state-of-the-art using
relative placement search space shows perform slightly faster
Moffitt Pollacks packer, benchmark previously shown Section
4.3.2 significantly difficult unoriented consecutive-rectangle benchmark
Moffitt Pollacks program run on.

6. Future Work
Humans solve jigsaw puzzles asking particular piece go, well
asking piece go empty region. packer makes use
models, former x-coordinates latter y-coordinates. would
interesting see applicable dual formulation packing, layout,
scheduling problems. Currently, work x-coordinates asking
go?, work y-coordinates asking goes location?
method reduced time spent y-coordinates much time spent
81

fiHuang & Korf

working x-coordinates orders magnitude greater time spent working
y-coordinates. suggests performance might improved considering
models simultaneously.
another direction continued work, data indicates number bounding
boxes explored minimum bounding boxes solver main bottleneck solving
larger instances unoriented high-precision rectangle benchmark. observation
make across many bounding boxes, partial solutions
explored, resulting much redundant computation. Consequently, branch-and-bound
method starts large bounding box, gradually reduces dimensions
various packings explored would promising avenue research.

7. Conclusions
presented several new improvements previous state-of-the-art optimal
rectangle packing. Within schema assigning x-coordinates prior y-coordinates,
introduced dynamic variable order x-coordinates, constraint adapts
Korfs (2003) wasted space pruning heuristic one-dimensional case. ycoordinates work perfect packing transformation original problem,
using model assigns rectangles empty corners, inference rules reduce
models variables.
improvements search y-coordinates helped us solve N =27 consecutive-square benchmark order magnitude faster previous state-ofthe-art, improvements search x-coordinates gave us another order
magnitude speedup N =28, compared leaving optimizations out.
techniques, 19 times faster previous state-of-the-art largest
problem solved date, allowing us extend known solutions consecutive-square
benchmark N =27 N =32. Furthermore, data show little time spent
searching y-coordinates, suggesting rectangle packing may largely reduced
problem determining x-coordinates.
techniques presented pick y-coordinates tightly coupled dual
view asking must go empty location. Furthermore, searching xcoordinates, pruning rule based analysis irregular regions empty space,
dynamic variable order rests observation less empty space leads
constrained problem. success techniques rectangle packing make
worth exploring many packing, layout, scheduling problems.
introduced two new benchmarks, one oriented one unoriented,
include rectangles various aspect ratios. new benchmarks avoid various properties
easy instances, identified, shown much harder
side-by-side comparison various benchmarks using state-of-the-art packer.
proposed several search strategies improve performance new benchmarks. improved upon strategies used handle dominance conditions, proposed
variable ordering heuristic based increasing branching factor generalizes previous
strategies, tuned global interval parameter, introduced method balance sizes
intervals assigned x-coordinate variables.
82

fiOptimal Rectangle Packing: Absolute Placement Approach

experiments revealed takes orders magnitude time solve new
benchmarks compared instances consecutive-square benchmark
number rectangles. therefore advocate inclusion new, difficult
benchmarks suite benchmarks used research optimal rectangle packing. Finally, using techniques together, solved N =21 oriented equal-perimeter
benchmark 500 times faster, N =16 unoriented double-perimeter benchmark 40 times faster simply using methods tuned consecutive-squares.
order test limits rectangle packer, presented new high-precision benchmark specifically capturing pathological case successive rectangle
quickly increases precision required represent coordinate locations. presented
various techniques adapt absolute placement approach handle types instances, including dynamically using subset sums limit number coordinate values
must tested, mutex reasoning allows us reject certain combinations subset
sums used bounding boxs width height, general method rejecting future subset sums based previously infeasible search, finally memory-efficient adaptation
perfect packing transformation high-precision rectangle instances.
solved N =12 high-precision benchmark half minute, 800 times faster
basic version packer augmented high-precision version perfect
packing inference rules run memory. first instance
requiring precision exceeding capacity 32-bit integer. techniques allowed us
solve N =15 compared N =9, largest instance low-precision techniques
alone could solve. methods reduced number bounding boxes generated
factor 4,500. point solving problems require minimum 39 bits
precision, meet requirements many real-world problems.
provided comparison state-of-the-art relative placement packer showing
absolute-placement packer remains competitive even rectangles high-precision, reported promising avenues research may potentially give absolute
placement approach clear competitive edge relative-placement methods.
Although mainly focused obtaining optimal solutions benchmarks,
work may easily adapted applications requiring quick suboptimal solutions
simply replacing algorithm minimum bounding box problem alternatives
anytime algorithm described Section 3.3.1.
7.1 Comparison Constraint Programming Methodologies
clearly tradeoffs taking ground-up programming approach C++
taking constraint programming approach. latter provides quick prototyping
reuse constraint libraries researchers already implemented,
forces problem expressed abstract constraint language. abstract
layer turns add unnecessary overhead algorithms data structures
one naturally uses solve problem optimal rectangle packing.
example, previously described, cumulative constraint, simply add
constant consecutive range integer array assign x-coordinate
rectangle. backtrack, scan array subtract constant.
Scanning manipulating arrays, iteration, fast pushing popping program
83

fiHuang & Korf

stack recursive algorithms precisely operations modern computer hardware
optimized for. significant explore two trillion search nodes
N =32 square-packing benchmark, fact solver spends 75%
time array manipulation operations alone. explain
orders magnitude speedup processing x-coordinate solutions 1D array
instead 2D bitmap Korf (2003). move 1D arrays, 2D bitmaps,
abstract representations variables values constraint programming, patterns
computation data structures simply become distant underlying
hardware optimized for.
optimal rectangle packing, happens algorithms data structures
naturally solve problem map nicely form function hardware modern
computers. Note one may always port code constraint module may
called constraint solver, still computational indirection
module backtracking control logic constraint solver. sacrifice make
approach, however, fact solver tailored specifically rectangle
packing problem defined it, would require implementation effort
reconfigure algorithms heuristics slightly different rectangle packing problem.
hope, however, latter problem ameliorated disciplined object-oriented,
modular software design.

8. Broader Lessons
Beyond specific problem rectangle packing, broader lessons learn
work? believe several.
One main applications rectangle packing scheduling. described
introduction, rectangle packing problem abstraction scheduling problem
different tasks take different amounts time, require different amounts onedimensional resource must allocated contiguously, memory computer.
width bounding box becomes total time, height total amount
resource available, job becomes rectangle width equal time duration,
height equal amount resource required.
found, however, vast majority time used rectangle packer
assigning x-coordinates rectangles, subject cumulative constraint,
every x-coordinate bounding box, sum heights rectangles overlap x-coordinate cannot exceed height bounding box.
important subpart rectangle-packing problem models much general problem
known resource-constrained scheduling problem. scheduling
problem described above, without constraint resource allocated contiguously. example, scheduling tasks planetary rover limited power budget,
sum power requirements tasks active given time cannot
exceed total power budget rover. Thus, subpart rectangle packer
used tackle general scheduling problem.
Another general lesson learned work absolute placement
approach various packing problems two, three, dimensions may effective
even problems high precision dimensions. One might expect absolute placement
84

fiOptimal Rectangle Packing: Absolute Placement Approach

would competitive relative placement approaches problems,
key success area instead considering possible placements,
consider placements correspond subset sums relevant dimensions.
guarantee approach work high-precision packing problems,
shown least worth considering, may effective.
Perhaps largest lesson learned encouraging discouraging.
problem rectangle packing extremely simple, understood played
game children. Yet research last decade described shows
efficient algorithms quite complex. best algorithms simple
problem complex, likely best algorithms complex problems
even complex, discouraging part. encouraging part
history research shown new idea result order magnitude
improvement previous state art larger problems, suggesting
still significant progress made problem, extension others it.

Acknowledgments
wish thank Reza Ahmadi, Adnan Darwiche, Adam Meyerson advice
work. thank Michael Moffitt making packer available. research funded part National Science Foundation grant number IIS0713178. source code optimal rectangle packer open sourced available
http://code.google.com/p/rectpack.

References
Aggoun, A., & Beldiceanu, N. (1993). Extending chip order solve complex scheduling
placement problems. Mathematical Computer Modelling, 17 (7), 5773.
Beldiceanu, N., & Carlsson, M. (2001). Sweep generic pruning technique applied
non-overlapping rectangles constraint. CP 01: Proceedings 7th International
Conference Principles Practice Constraint Programming, pp. 377391, London, UK. Springer-Verlag.
Beldiceanu, N., Carlsson, M., & Poder, E. (2008). New filtering cumulative constraint
context non-overlapping rectangles. Perron, L., & Trick, M. A. (Eds.),
CPAIOR, Vol. 5015 Lecture Notes Computer Science, pp. 2135. Springer.
Beldiceanu, N., Carlsson, M., Poder, E., Sadek, R., & Truchet, C. (2007). generic geometrical constraint kernel space time handling polymorphic k-dimensional
objects. Bessiere, C. (Ed.), CP, Vol. 4741 Lecture Notes Computer Science,
pp. 180194. Springer.
Bhattacharya, S., Roy, R., & Bhattacharya, S. (1998). exact depth-first algorithm
pallet loading problem. European Journal Operational Research, 110 (3), 610625.
Chan, H. H., & Markov, I. L. (2004). Practical slicing non-slicing block-packing without
simulated annealing. GLSVLSI 04: Proceedings 14th ACM Great Lakes
symposium VLSI, pp. 282287, New York, NY, USA. ACM.
85

fiHuang & Korf

Chazelle, B. (1983). bottomn-left bin-packing heuristic: efficient implementation.
IEEE Transactions Computers, C-32 (8), 697707.
Clautiaux, F., Carlier, J., & Moukrim, A. (2007). new exact method twodimensional orthogonal packing problem. European Journal Operational Research,
183 (3), 11961211.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49 (1-3), 6195.
Dowsland, K. A. (1987). exact algorithm pallet loading problem. European
Journal Operational Research, 31 (1), 7884.
Dowsland, K. A., & Dowsland, W. B. (1992). Packing problems. European Journal
Operational Research, 56 (1), 214.
Huang, E., & Korf, R. E. (2009). New improvements optimal rectangle packing.
Boutilier, C. (Ed.), IJCAI, pp. 511516.
Huang, E., & Korf, R. E. (2010). Optimal rectangle packing non-square benchmarks.
AAAI10: Proceedings 24th National Conference Artificial intelligence, pp.
317324. AAAI Press.
Huang, E., & Korf, R. E. (2011). Optimal packing high-precision rectangles. Burgard,
W., & Roth, D. (Eds.), AAAI. AAAI Press.
Korf, R. E. (2003). Optimal rectangle packing: Initial results. Giunchiglia, E., Muscettola,
N., & Nau, D. S. (Eds.), ICAPS, pp. 287295. AAAI.
Korf, R. E. (2004). Optimal rectangle packing: New results. Zilberstein, S., Koehler, J.,
& Koenig, S. (Eds.), ICAPS, pp. 142149. AAAI.
Korf, R. E., Moffitt, M. D., & Pollack, M. E. (2010). Optimal rectangle packing. Annals
Operations Research, 179 (1), 261295.
Lahrichi, A. (1982). Scheduling: notions hump, compulsory parts use
cumulative problems. Comptes Rendus de Academie des Sciences, Paris, 294, 209211.
Lesh, N., Marks, J., McMahon, A., & Mitzenmacher, M. (2004). Exhaustive approaches
2d rectangular perfect packings. Information Processing Letters, 90 (1), 714.
Li, S. C., Leong, H. W., & Quek, S. K. (2004). New approximation algorithms dynamic storage allocation problems. Chwa, K.-Y., & Munro, J. I. (Eds.), COCOON,
Vol. 3106 Lecture Notes Computer Science, pp. 339348. Springer.
Lipovetskii, A. I. (2008). geometrical approach computation optimal solution
rectangle packing problem. American Mathematical Society Translations, 222,
93110.
Lodi, A., Martello, S., & Monaci, M. (2002). Two-dimensional packing problems: survey.
European Journal Operational Research, 141 (2), 241252.
Lodi, A., Martello, S., & Vigo, D. (2002). Recent advances two-dimensional bin packing
problems. Discrete Applied Mathematics, 123 (1-3), 379396.
Martello, S., & Vigo, D. (1998). Exact solution two-dimensional finite bin packing
problem. Management Science, 44 (3), 388399.
86

fiOptimal Rectangle Packing: Absolute Placement Approach

Meir, A., & Moser, L. (1968). packing squares cubes. Journal Combinatorial
Theory, 5 (2), 126134.
Mitola, J., & Maguire, G. (1999). Cognitive radio: making software radios personal.
IEEE Personal Communications Magazine, 6 (4), 1318.
Moffitt, M. D., & Pollack, M. E. (2006). Optimal rectangle packing: meta-csp approach.
Long, D., Smith, S. F., Borrajo, D., & McCluskey, L. (Eds.), ICAPS, pp. 93102.
AAAI.
Onodera, H., Taniguchi, Y., & Tamaru, K. (1991). Branch-and-bound placement building
block layout. DAC 91: Proceedings 28th ACM/IEEE Design Automation
Conference, pp. 433439, New York, NY, USA. ACM.
Simonis, H., & OSullivan, B. (2008). Search strategies rectangle packing. Stuckey,
P. J. (Ed.), CP, Vol. 5202 Lecture Notes Computer Science, pp. 5266. Springer.
Simonis, H., & OSullivan, B. (2011). Almost square packing. Achterberg, T., & Beck,
J. C. (Eds.), CPAIOR, Vol. 6697 Lecture Notes Computer Science, pp. 196209.
Springer.
Sweeney, P. E., & Paternoster, E. R. (1992). Cutting packing problems: categorized,
application-orientated research bibliography. Journal Operational Research
Society, 43 (7), 691706.
Weglarz, J. (1999). Project scheduling: recent models, algorithms applications. Springer,
Kluwer.
Yap, R. H. C. (2004). Constraint processing rina dechter, morgan kaufmann publishers,
2003, hard cover: Isbn 1-55860-890-7, xx + 481 pages. Theory Pract. Log. Program.,
4 (5-6), 755757.

87


