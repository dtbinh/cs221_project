Journal Artificial Intelligence Research 46 (2013) 687-716

Submitted 12/12; published 04/13

NuMVC: Efficient Local Search Algorithm
Minimum Vertex Cover
Shaowei Cai

SHAOWEICAI . CS @ GMAIL . COM

Key Laboratory High Confidence Software Technologies
Peking University, Beijing, China

Kaile Su

K . SU @ GRIFFITH . EDU . AU

Institute Integrated Intelligent Systems
Griffith University, Brisbane, Australia

Chuan Luo

CHUANLUOSABER @ GMAIL . COM

Key Laboratory High Confidence Software Technologies
Peking University, Beijing, China

Abdul Sattar

. SATTAR @ GRIFFITH . EDU . AU

Institute Integrated Intelligent Systems
Griffith University, Brisbane, Australia

Abstract
Minimum Vertex Cover (MVC) problem prominent NP-hard combinatorial
optimization problem great importance theory application. Local search proved
successful problem. However, two main drawbacks state-of-the-art MVC local
search algorithms. First, select pair vertices exchange simultaneously, timeconsuming. Secondly, although using edge weighting techniques diversify search,
algorithms lack mechanisms decreasing weights. address issues, propose two
new strategies: two-stage exchange edge weighting forgetting. two-stage exchange
strategy selects two vertices exchange separately performs exchange two stages.
strategy edge weighting forgetting increases weights uncovered edges,
decreases weights edge periodically. two strategies used designing
new MVC local search algorithm, referred NuMVC.
conduct extensive experimental studies standard benchmarks, namely DIMACS
BHOSLIB. experiment comparing NuMVC state-of-the-art heuristic algorithms
show NuMVC least competitive nearest competitor namely PLS
DIMACS benchmark, clearly dominates competitors BHOSLIB benchmark. Also,
experimental results indicate NuMVC finds optimal solution much faster current
best exact algorithm Maximum Clique random instances well structured ones.
Moreover, study effectiveness two strategies run-time behaviour
experimental analysis.

1. Introduction
Minimum Vertex Cover (MVC) problem consists of, given undirected graph G = (V, E),
finding minimum sized vertex cover, vertex cover subset V every
edge G least one endpoint S. MVC important combinatorial optimization problem
many real-world applications, network security, scheduling, VLSI design industrial
machine assignment. equivalent two well-known combinatorial optimization problems:
Maximum Independent Set (MIS) problem Maximum Clique (MC) problem,
c
2013
AI Access Foundation. rights reserved.

fiC AI , U , L UO & ATTAR

wide range applications areas information retrieval, experimental design, signal
transmission, computer vision, bioinformatics problems aligning DNA protein
sequences (Johnson & Trick, 1996). Indeed, three problems seen three different
forms problem, viewpoint practical algorithms. Algorithms MVC
directly used solve MIS MC problems. Due great importance theory
applications, three problems widely investigated last several decades
(Carraghan & Pardalos, 1990; Evans, 1998; Pullan & Hoos, 2006; Richter, Helmert, & Gretton,
2007; Cai, Su, & Chen, 2010; Li & Quan, 2010b; Cai, Su, & Sattar, 2011).
Theoretical analyses indicate three problems MVC, MIS, MC computationally
hard. NP-hard associated decision problems NP-complete (Garey &
Johnson, 1979). Moreover, hard solve approximately. NP-hard approximate
MVC within factor smaller 1.3606 (Dinur & Safra, 2005), although one achieve
approximation ratio 2 o(1) (Halperin, 2002; Karakostas, 2005). Besides inapproximability
MVC, Hastad shows MIS MC approximable within |V |1 > 0,
unless NP=ZPP1 (Hastad, 1999, 2001). Recently, conclusion enhanced MC
approximable within |V |1 > 0 unless NP=P (Zuckerman, 2006), derived
derandomization Hastads result. Moreover, currently best polynomial-time approximation
algorithm MC guaranteed find clique within factor O(n(loglogn)2 /(logn)3 )
optimum (Feige, 2004).
algorithms solve MVC (MIS, MC) fall two types: exact algorithms heuristic
algorithms. Exact methods mainly include branch-and-bound algorithms (Carraghan &
Pardalos, 1990; Fahle, 2002; Ostergard, 2002; Regin, 2003; Tomita & Kameda, 2009; Li &
Quan, 2010b, 2010a), guarantee optimality solutions find, may fail give
solution within reasonable time large instances. Heuristic algorithms, mainly include local
search algorithms, cannot guarantee optimality solutions, find optimal
satisfactory near-optimal solutions large hard instances within reasonable time. Therefore,
appealing use local search algorithms solve large hard MVC (MC, MIS) instances.
Early heuristic methods Maximum Clique designed initial responses
Second DIMACS Implementation Challenge (Johnson & Trick, 1996), Maximum Clique
one three challenge problems. that, huge amount effort devoted designing
local search algorithms MVC, MC MIS problems (Aggarwal, Orlin, & Tai, 1997; Battiti &
Protasi, 2001; Busygin, Butenko, & Pardalos, 2002; Shyu, Yin, & Lin, 2004; Barbosa & Campos,
2004; Pullan, 2006; Richter et al., 2007; Andrade, Resende, & Werneck, 2008; Cai et al., 2010,
2011). review heuristic algorithms three problems found recent paper
MVC local search (Cai et al., 2011).
work devoted efficient local search algorithm MVC. Typically, local search
algorithms MVC solve problem iteratively solving k-vertex cover problem. solve
k-vertex cover problem, maintain current candidate solution size k, exchange
two vertices iteratively becomes vertex cover. However, observe two drawbacks
state-of-the-art MVC local search algorithms. First, select pair vertices exchanging
simultaneously according heuristic (Richter et al., 2007; Cai et al., 2010, 2011),
rather time-consuming, explained Section 3. second drawback edge
weighting techniques. basic concept edge weighting increase weights uncovered
1. ZPP class problems solved expected polynomial time probabilistic algorithm zero
error probability.

688

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

edges diversify search. Previous MVC local search algorithms utilize different edge weighting
schemes. example, COVER (Richter et al., 2007) increases weights uncovered edges
step, EWLS (Cai et al., 2010) EWCC (Cai et al., 2011) increase weights uncovered
edges reaching local optima. However, algorithms mechanism
decrease weights. believe deficient weighting decisions made long
ago may mislead search.
address two issues MVC local search algorithms, paper proposes two new
strategies, namely two-stage exchange edge weighting forgetting. two-stage exchange
strategy decomposes exchanging procedure two stages, i.e., removing stage
adding stage, performs separately. first selects vertex removes current
candidate solution, selects vertex random uncovered edge adds it. twostage exchange strategy yields efficient two-pass move operator MVC local search,
first pass linear-time search vertex-to-remove, second pass lineartime search vertex-to-add. contrast standard quadratic, all-at-once move
operator. Moreover, two-stage exchange strategy renders algorithm flexible
employ different heuristics different stages. Indeed, NuMVC algorithm utilizes
highly greedy heuristic removing stage, adding stage, makes good use
diversifying heuristic within framework similar focused random walk (Papadimitriou, 1991).
second strategy propose edge weighting forgetting. increases weights
uncovered edges one step. Moreover, averaged edge weight achieves
threshold, reduces weights edges multiplying constant factor (0 < < 1) forget
earlier weighting decisions. best knowledge, first time forgetting
mechanism introduced local search algorithms MVC.
two strategies combined design new local search algorithm called NuMVC.
carry detailed experimental study investigate performance NuMVC, compare
PLS (Pullan, 2006), COVER (Richter et al., 2007) EWCC (Cai et al., 2011),
leading heuristic algorithms MVC (MC, MIS). Experimental results show NuMVC
competes well solvers DIMACS benchmark, shows dramatic improvement
existing results whole BHOSLIB benchmark. parts work published
early version paper (Cai, Su, & Sattar, 2012).
paper, additionally carry experimental analyses provides
insights two strategies NuMVC. compare NuMVC exact algorithm
MaxCLQdyn+EFL+SCR (Li & Quan, 2010a), best exact Maximum Clique algorithm
found literature. Experimental results indicate NuMVC finds optimal solution
much faster exact algorithm random instances well structured ones.
importantly, conduct experimental investigations study run-time behaviour NuMVC
effectiveness two new strategies NuMVC.
remainder paper organized follows. next section, introduce
definitions notations used paper. present two strategies: two-stage exchange
edge weighting forgetting. Section 5, describe NuMVC algorithm. Section 6
presents experimental study NuMVC comparative results algorithms, including
heuristic exact algorithms. followed detailed investigations run-time
behaviour NuMVC effectiveness two new strategies Section 7. Finally,
conclude paper summarizing main contributions future directions.
689

fiC AI , U , L UO & ATTAR

2. Preliminaries
undirected graph G = (V, E) consists vertex set V edge set E V V ,
edge 2-element subset V . edge e = {u, v}, say vertices u v
endpoints edge e. Two vertices neighbors belong common
edge. denote N (v) = {u V |{u, v} E}, set neighbors vertex v.
undirected graph G = (V, E), independent set subset V pairwise nonadjacent elements clique subset V pairwise adjacent elements. maximum
independent set maximum clique problems find maximum sized independent set
clique graph, respectively.
note three problems MVC, MIS MC seen three different forms
problem, viewpoint experimental algorithms. vertex set independent
set G V \S vertex cover G; vertex set K clique G V \K
vertex cover complementary graph G. find maximum independent set graph
G, one find minimum vertex cover Cmin G return V \Cmin . Similarly, find

maximum clique graph G, one find minimum vertex cover Cmin
complementary

graph G, return V \Cmin
.
Given undirected graph G = (V, E), candidate solution MVC subset vertices.
edge e E covered candidate solution X least one endpoint e belongs
X. search procedure, NuMVC always maintains current candidate solution.
convenience, rest paper, use C denote current candidate solution. state
vertex v denoted sv {1, 0}, sv = 1 means v C, sv = 0 means v
/ C.
step neighboring candidate solution consists exchanging two vertices: vertex u C
removed C, vertex v
/ C put C. age vertex number steps since
state last changed.
state-of-the-art MVC local search algorithms, NuMVC utilizes edge weighting
scheme. edge weighting local search, follow definitions notations EWCC (Cai
et al., 2011). edge weighted undirected graph undirected graph G = (V, E) combined
weighting function w edge e E associated non-negative integer number
w(e) weight. use w denote mean value edge weights.
Let w weighting function G. candidate solution X, set cost X
X

cost(G, X) =

w(e)

eE e covered X

indicates total weight edges uncovered X. take cost(G, X) evaluation
f unction, NuMVC prefers candidate solutions lower costs.
vertex v V ,
dscore(v) = cost(G, C) cost(G, C )
C = C\{v} v C, C = C {v} otherwise, measuring benefit changing
state vertex v. Obviously, vertex v C, dscore(v) 0, greater dscore
indicates less loss covered edges removing C. vertex v
/ C,
dscore(v) 0, higher dscore indicates greater increment covered edges adding
C.
690

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

3. Two-Stage Exchange
section, introduce two-stage exchange strategy, adopted NuMVC
algorithm exchange pair vertices.
state-of-the-art MVC local search algorithms, NuMVC iterated k-vertex
cover algorithm. finding k-vertex cover, NuMVC removes one vertex current
candidate solution C goes search (k 1)-vertex cover. sense, core
NuMVC k-vertex cover algorithm given positive integer number k, searching k-sized
vertex cover. find k-vertex cover, NuMVC begins candidate solution C size k,
exchanges two vertices iteratively C becomes vertex cover.
local search algorithms MVC select pair vertices exchange simultaneously
according certain heuristic. example, COVER selects pair vertices maximize
gain(u, v) (Richter et al., 2007), EWLS (Cai et al., 2010) EWCC (Cai et al., 2011) select
random pair vertices score(u, v) > 0. strategy selecting two vertices exchange
simultaneously leads quadratic neighborhood candidate solutions. Moreover, evaluation
pair vertices depends evaluations (such dscore) two vertices,
involves relationship two vertices, belong edge. Therefore,
rather time-consuming evaluate candidate pairs vertices.
contrast earlier MVC local search algorithms, NuMVC selects two vertices
exchanging separately exchanges two selected vertices two stages. iteration,
NuMVC first selects vertex u C highest dscore removes it. that, NuMVC
selects uniformly random uncovered edge e, chooses one endpoint v e higher
dscore restrictions adds C. Note two-stage exchange strategy
resembles respect min-conflicts hill-climbing heuristic CSP (Minton, Johnston,
Philips, & Laird, 1992), shows surprisingly good performance N-queens problem.
Selecting two vertices exchanging separately may cases miss greedier
vertex pairs consist two neighboring vertices. However, usual local search
algorithms, trade-off accuracy heuristics complexity per step.
Let R denote set candidate vertices removing adding separately. time
complexity per step selecting exchanging vertex pair simultaneously |R| |A|;
complexity per step selecting two vertices separately, NuMVC, |R| + |A|.
worthy note that, heuristics local search algorithm often based intuition
experience rather theoretically empirically derived principles insights, cannot say
certain less greedy good thing (Hoos & Stutzle, 2004). hand,
lower time complexity always desirable.

4. Edge Weighting Forgetting
section, present new edge weighting technique called edge weighting forgetting,
plays important role NuMVC.
proposed strategy edge weighting forgetting works follows. edge
associated positive integer number weight, edge weight initialized one.
iteration, edge weights uncovered edges increased one. Moreover,
average weight achieves threshold, edge weights reduced forget earlier weighting
decisions using formula w(e) := w(e), constant factor 0 1.
691

fiC AI , U , L UO & ATTAR

Note edge weighting techniques MVC local search, including one work,
fall general penalty idea optimization problems, dates back Morris
breakout method (Morris, 1993) widely used local search algorithms constraint
optimization problems SAT (Yugami, Ohta, & Hara, 1994; Wu & Wah, 2000; Schuurmans,
Southey, & Holte, 2001; Hutter, Tompkins, & Hoos, 2002). results therefore provide
evidence effectiveness general applicability algorithmic technique.
Edge weighting techniques successfully used improve MVC local search
algorithms. example, COVER (Richter et al., 2007) updates edge weights step,
EWLS (Cai et al., 2010) EWCC (Cai et al., 2011) update edge weights reaching local
optima. However, previous edge weighting techniques mechanism decrease
weights, limits effectiveness. strategy edge weighting forgetting
work introduces forgetting mechanism reduce edge weights periodically, contributes
considerably NuMVC algorithm.
intuition behind forgetting mechanism weighting decisions made long ago
longer helpful may mislead search, hence considered less important
recent ones. example, consider two edges e1 e2 w(e1 ) = 1000 w(e2 ) =
100 step. use w(e) denote increase w(e). According evaluation
function, next period time, algorithm likely cover e1 frequently e2 ,
may assume period w(e1 ) = 50 w(e2 ) = 500, makes w(e1 ) =
1000 + 50 = 1050 w(e2 ) = 100 + 500 = 600. Without forgetting mechanism, algorithm
would still prefer e1 e2 covered future search. reasonable,
period e2 covered much fewer steps e1 is. Thus, e2 take priority covered
sake diversification. let us consider case forgetting mechanism (assuming
= 0.3 setting experiments). Suppose w(e1 ) = 1000 w(e2 ) = 100
algorithm performs forgetting. forgetting mechanism reduces edge weights
w(e1 ) = 10000.3 = 300 w(e2 ) = 1000.3 = 30. period time, w(e1 ) = 50
w(e2 ) = 500, w(e1 ) = 300 + 50 = 350 w(e2 ) = 30 + 500 = 530. case,
algorithm prefers cover e2 rather cover e1 future search, expect.
Although inspired smoothing techniques clause weighting local search algorithms
SAT, forgetting mechanism NuMVC differs smoothing techniques SAT
local search algorithms. According way clause weights smoothed, three
main smoothing techniques clause weighting local search algorithms SAT best
knowledge: first pull clause weights mean value using formula wi :=
wi + (1 ) w, ESG (Schuurmans et al., 2001), SAPS (Hutter et al., 2002) Swcca
(Cai & Su, 2012); second subtract one clause weights greater
one, DLM (Wu & Wah, 2000) PAWS (Thornton, Pham, Bain, & Jr., 2004); last
employed DDWF (Ishtaiwi, Thornton, Sattar, & Pham, 2005), transfers weights
neighbouring satisfied clauses unsatisfied ones. obvious forgetting mechanism
NuMVC different smoothing techniques.
Recently, forgetting mechanism proposed vertex weighting technique significant
MC local search algorithm DLS-MC (Pullan & Hoos, 2006), important sub-algorithm
PLS (Pullan, 2006) CLS (Pullan, Mascia, & Brunato, 2011). DLS-MC algorithm employs
vertex weighting scheme increases weights vertices (by one) current clique
reaching local optimum, periodically decreases weights (by one) vertices
currently penalty. Specifically, utilizes parameter pd (penalty delay) specify
692

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

number penalty increase iterations must occur algorithm performs forgetting
operation. However, Pullan Hoos observed DLS-MC sensitive pd
parameter, optimal value pd varies considerably among different instances. Indeed,
performance DLS-MC given optimizing pd parameter. contrast, forgetting
mechanism NuMVC much less sensitive parameters (as shown Section 7.4),
thus robust.
notice formula used forgetting mechanism NuMVC adopted
long-term frequency-based learning mechanisms tabu search (Taillard, 1994). However,
Taillars algorithm, parameter (using term work) always greater one,
formula used penalizing move rather forgetting penalties.

5. NuMVC Algorithm
section, present NuMVC algorithm, utilizes strategies two-stage
exchange edge weighting forgetting.
Algorithm 1: NuMVC
1

2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20

NuMVC (G,cutoff)
Input: graph G = (V, E), cutoff time
Output: vertex cover G
begin
initialize edge weights dscores vertices;
initialize confChange array all-1 array;
construct C greedily vertex cover;
C := C;
elapsed time < cutoff
uncovered edge
C := C;
remove vertex highest dscore C;
continue;
choose vertex u C highest dscore, breaking ties favor oldest
one;
C := C\{u}, confChange(u) := 0 confChange(z) := 1 z N (u);
choose uncovered edge e randomly;
choose vertex v e confChange(v) = 1 higher dscore, breaking ties
favor older one;
C := C {v}, confChange(z) := 1 z N (v);
w(e) := w(e) + 1 uncovered edge e;
w w(e) := w(e) edge e;
return C ;
end

better understanding algorithm, first describe strategy called configuration checking
(CC), used NuMVC. CC strategy (Cai et al., 2011) proposed handling
693

fiC AI , U , L UO & ATTAR

cycling problem local search, i.e., revisiting candidate solution visited recently
(Michiels, Aarts, & Korst, 2007). strategy successfully applied local search
algorithms MVC (Cai et al., 2011) well SAT (Cai & Su, 2011, 2012).
CC strategy NuMVC works follows: vertex v
/ C, neighboring vertices
never change states since last time v removed C, v added
back C. CC strategy seen prohibition mechanism, shares spirit
differs well-known prohibition mechanism called tabu (Glover, 1989).
implementation CC strategy maintain Boolean array confChange vertices.
search procedure, vertices confChange value 0 forbidden
add C. confChange array initialized all-1 array. that, vertex v
removed C, confChange(v) reset 0, vertex v changes state,
z N (v), confChange(z) set 1.
outline NuMVC algorithm Algorithm 1, described below. beginning, edge
weights initialized 1, dscores vertices computed accordingly; confChange(v)
initialized 1 vertex v; current candidate solution C constructed iteratively
adding vertex highest dscore (ties broken randomly), becomes vertex
cover. Finally, best solution C initialized C.
initialization, loop (lines 7-18) executed given cutoff time reached.
search procedure, uncovered edge, means C vertex cover,
NuMVC updates best solution C C (line 9). removes one vertex highest
dscore C (line 10), breaking ties randomly, go search vertex cover
size |C| = |C | 1. note that, C, vertex highest dscore minimum
absolute value dscore since dscores negative.
iteration loop, NuMVC swaps two vertices according strategy two-stage
exchange (lines 12-16). Specifically, first selects vertex u C highest dscore
remove, breaking ties favor oldest one. removing u, NuMVC chooses uncovered
edge e uniformly random, selects one es endpoints add C follows:
one endpoint whose confChange 1, vertex selected; confChange values
endpoints 1, NuMVC selects vertex higher dscore, breaking ties
favor older one. exchange finished adding selected vertex C. Along
exchanging two selected vertices, confChange array updated accordingly.
end iteration, NuMVC updates edge weights (lines 17-18). First, weights
uncovered edges increased one. Moreover, NuMVC utilizes forgetting mechanism
decrease weights periodically. detail, averaged weight edges achieves threshold
, edge weights multiplied constant factor (0 < < 1) rounded
integer edge weights defined integers NuMVC. forgetting mechanism forgets
earlier weighting decision extent, past effects generally longer helpful
may mislead search.
conclude section following observation, guarantees executability
line 15.
Proposition 1. uncovered edge e, least one endpoint v edge e
confChange(v) = 1.
Proof: Let us consider arbitrary uncovered edge e = {v1 , v2 }. proof includes two cases.
(a) least one v1 v2 never changes state initialization. Without
694

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

loss generality, assume v1 vertex. initialization, confChange(v1 ) set
1. that, removing v1 C (which corresponds vs state sv changing 0
1) make confChange(v1 ) 0, v1 never changes state initialization,
confChange(v1 )= 1.
(b) v1 v2 change states initialization. e uncovered, v1
/ C
v2
/ C. Without loss generality, assume last removing v1 happens last
removing v2 . last time v1 removed, v2 C holds. Afterwards, v2 removed,
means v2 changes state, confChange(v1 ) set 1 v1 N (v2 ).

6. Empirical Results
section, present detailed experimental study evaluate performance NuMVC
standard benchmarks literature, i.e., DIMACS BHOSLIB benchmarks. first
introduce DIMACS BHOSLIB benchmarks, describe preliminaries
experiments. Then, divide experiments three parts. purpose first part
demonstrate performance NuMVC detail. second compare NuMVC state-ofthe-art heuristic algorithms. Finally, last part compare NuMVC state-of-the-art exact
algorithms.
6.1 Benchmarks
good set benchmarks fundamental demonstrate effectiveness new solvers.
use two standard benchmarks MVC (MIS, MC) research, DIMACS benchmark
BHOSLIB benchmark. DIMACS benchmark includes instances industry
generated various models, BHOSLIB instances random ones high difficulty.
6.1.1 DIMACS B ENCHMARK
DIMACS benchmark taken Second DIMACS Implementation Challenge
Maximum Clique problem (1992-1993)2 . Thirty seven graphs selected organizers
summary indicate effectiveness algorithms, comprising Second DIMACS Challenge
Test Problems. instances generated real world problems coding theory,
fault diagnosis, Kellers conjecture Steiner Triple Problem, etc, random graphs
various models, brock p hat families. instances range size less
50 vertices 1,000 edges greater 4,000 vertices 5,000,000 edges. Although
proposed two decades ago, DIMACS benchmark remains popular benchmark
widely used evaluating heuristic algorithms MVC (Richter et al., 2007; Pullan, 2009;
Cai et al., 2011; Gajurel & Bielefeld, 2012), MIS (Andrade et al., 2008; Pullan, 2009) MC
algorithms (Pullan, 2006; Katayama, Sadamatsu, & Narihisa, 2007; Grosso, Locatelli, & Pullan,
2008; Pullan et al., 2011; Wu, Hao, & Glover, 2012). particular, DIMACS benchmark
used evaluating COVER EWCC. convenient us use benchmark
conduct experiments comparing NuMVC COVER EWCC. Note DIMACS
graphs originally designed Maximum Clique problem, MVC algorithms tested
complementary graphs.
2. ftp://dimacs.rutgers.edu/pub/challenges

695

fiC AI , U , L UO & ATTAR

6.1.2 BHOSLIB B ENCHMARK
BHOSLIB3 (Benchmarks Hidden Optimum Solutions) instances generated randomly
phase transition area according model RB (Xu, Boussemart, Hemery, & Lecoutre,
2005). Generally, phase-transition instances generated model RB proved
hard theoretically (Xu & Li, 2006) practically (Xu & Li, 2000; Xu, Boussemart,
Hemery, & Lecoutre, 2007). SAT version BHOSLIB benchmark extensively used
SAT competitions4 . Nevertheless, SAT solvers much weaker MVC solvers
problems, remains justifiable referring results SAT Competition 2011
benchmark. BHOSLIB benchmark famous hardness influential enough
strongly recommended MVC (MC, MIS) community (Grosso et al., 2008; Cai et al., 2011).
widely used recent literature reference point new local search solvers
MVC, MC MIS5 . Besides 40 instances, large instance frb100-40 4,000
vertices 572,774 edges, designed challenging MVC (MC, MIS) algorithms.
BHOSLIB benchmark designed MC, MVC MIS, graphs
benchmark expressed two formats, i.e., clq format mis format. BHOSLIB
instance, graph clq format one mis format complementary other. MC
algorithms tested graphs clq format, MVC MIS algorithms tested
mis format.
6.2 Experiment Preliminaries
discuss experimental results, let us introduce preliminary information
experiments.
NuMVC implemented C++. codes NuMVC EWCC publicly available
first authors homepage6 . codes COVER downloaded online7 , PLS
kindly provided authors. four solvers compiled g++ -O2 option.
experiments carried machine 3 GHz Intel Core 2 Duo CPU E8400 4GB
RAM Linux. execute DIMACS machine benchmarks8 , machine requires 0.19
CPU seconds r300.5, 1.12 CPU seconds r400.5 4.24 CPU seconds r500.5.
NuMVC, set = 0.5|V | = 0.3 runs, except challenging instance
frb100-40, = 5000 = 0.3. Note parameters state-ofthe-art MVC (MC, MIS) algorithms, DLS-MC (Pullan & Hoos, 2006) EWLS (Cai et al.,
2010). Moreover, parameters DLS-MC EWLS vary considerably different instances.
instance, algorithm performed 100 independent runs different random seeds,
run terminated upon reaching given cutoff time. cutoff time set 2000
seconds instances except challenging instance frb100-40, cutoff
time set 4000 seconds due significant hardness.
NuMVC, report following information instance:
optimal (or minimum known) vertex cover size (V C ).
3.
4.
5.
6.
7.
8.

http://www.nlsde.buaa.edu.cn/kexu/benchmarks/graph-benchmarks.htm
http://www.satcompetition.org
http://www.nlsde.buaa.edu.cn/kexu/benchmarks/list-graph-papers.htm
http://www.shaoweicai.net/research.html
http://www.informatik.uni-freiburg.de/srichter/
ftp://dimacs.rutgers.edu/pub/dsj/clique/

696

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

number successful runs (suc). run said successful solution size V C
found.
VC size shows min (average, max) vertex cover size found NuMVC
100 runs.
averaged run time 100 runs (time). run time successful run
time find V C solution, failed run considered cutoff time.
instances NuMVC achieve 100% success rate, report averaged
run time successful runs (suc time). run time measured CPU seconds.
inter-quartile range (IQR) run time 100 runs. IQR difference
75th percentile 25th percentile sample. IQR one famous robust
measures data analysis (Hoaglin, Mosteller, & Tukey, 2000), recommended
measurement closeness sampling distribution community experimental
algorithms (Bartz-Beielstein, Chiarandini, Paquete, & Preuss, 2010).
number steps averaged 100 runs (steps). steps successful run
needed find V C solution, steps failed run executed
running cut off. instances NuMVC achieve 100% success
rate, report averaged steps successful runs (suc steps).
successful runs instance, time steps columns marked
n/a. success rate solver instance less 75%, 75th percentile
run time sample cutoff time represent real 75th percentile. case,
report IQR, instead mark n/a corresponding column. Actually,
success rate solver certain instance less 75%, solver considered
robust instance given cutoff time.
6.3 Performance NuMVC
section, report detailed performance NuMVC two benchmarks.
6.3.1 P ERFORMANCE N U MVC



DIMACS B ENCHMARK

performance results NuMVC DIMACS benchmark displayed Table 1. NuMVC
finds optimal (or best known) solutions 35 37 DIMACS instances. Note 2 failed
instances brock graphs. Furthermore, among 35 successful instances, NuMVC
consistently (i.e., 100 runs) 32 instances, 24 solved within 1 second.
Overall, NuMVC algorithm exhibits excellent performance DIMACS benchmark except
brock graphs. Remark brock graphs artificially designed defeat greedy
heuristics explicitly incorporating low-degree vertices optimal vertex cover. Indeed,
algorithms preferring higher-degree vertices GRASP, RLS, k-opt, COVER EWCC
failed graphs.
6.3.2 P ERFORMANCE N U MVC



BHOSLIB B ENCHMARK

Table 2, illustrate performance NuMVC BHOSLIB benchmark. NuMVC
successfully solves BHOSLIB instances terms finding optimal solution, size
697

fiC AI , U , L UO & ATTAR

Graph
Instance Vertices
brock200 2
brock200 4
brock400 2
brock400 4
brock800 2
brock800 4
C125.9
C250.9
C500.9
C1000.9
C2000.5
C2000.9
C4000.5
DSJC500.5
DSJC1000.5
gen200 p0.9 44
gen200 p0.9 55
gen400 p0.9 55
gen400 p0.9 65
gen400 p0.9 75
hamming8-4
hamming10-4
keller4
keller5
keller6
MANN a27
MANN a45
MANN a81
p hat300-1
p hat300-2
p hat300-3
p hat700-1
p hat700-2
p hat700-3
p hat1500-1
p hat1500-2
p hat1500-3

200
200
400
400
800
800
125
250
500
1000
2000
2000
4000
500
1000
200
200
400
400
400
256
1024
171
776
3361
378
1035
3321
300
300
300
700
700
700
1500
1500
1500

V C

suc

VC size

188

100
100
96
100
0
0
100
100
100
100
100
1
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
27
100
100
100
100
100
100
100
100
100

188
183
371(371.16,375)
367
779
779
91
206
443
932
1984
1920(1921.29,1922)
3982
487
985
156
145
345
335
325
240
984
160
749
3302
252
690
2221(2221.94,2223)
292
275
264
689
656
638
1488
1435
1406

183
371
367
776
774
91
206
443
932
1984
1920
3982
487
985
156
145
345
335
325
240
984
160
749
3302
252
690
2221
292
275
264
689
656
638
1488
1435
1406

NuMVC
time(suc time)
0.126
1.259
572.390(512.906)
4.981
n/a
n/a
< 0.001
< 0.001

0.128
2.020
2.935
1994.561(1393.303)
252.807
0.012
0.615
< 0.001
< 0.001

0.035
< 0.001
< 0.001
< 0.001

0.062
< 0.001

0.038
2.51
< 0.001

86.362
1657.880(732.897)
0.003
< 0.001

0.001
0.011
0.006
0.008
3.751
0.071
0.060

steps(suc steps)
137610
1705766
645631471(585032783)
6322882
n/a
n/a
136
3256
133595
1154155
231778
777848959(564895994)
7802785
3800
134796
1695
69
38398
1522
203
1
23853
42
15269
384026
6651
90642150
571607432(251509010)
100
98
1863
1248
1103
2868
445830
5280
10668

Table 1: NuMVC performance results, averaged 100 independent runs, DIMACS
benchmark instances. VC column marked asterisk means minimum
known vertex cover size proved optimal.

698

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

worst solution finds never exceeds V C + 1. NuMVC finds optimal solutions 100%
success rate 33 40 instances, averaged success rate remaining 7
instances 82.57%. results dramatically better existing results literature
benchmark. Also, NuMVC finds sub-optimal solution size V C + 1 BSHOSLIB
instances quickly, always less 30 seconds. indicates NuMVC used
approximate MVC problem efficiently even limited time.
Besides 40 BHOSLIB instances Table 2, challenging instance frb100-40,
hidden minimum vertex cover size 3900. designer BHOSLIB benchmark
conjectured instance solved PC less day within next two
decades9 . latest record challenging instance 3902-sized vertex cover found
EWLS, EWCC.
run NuMVC 100 independent trials within 4000 seconds frb100-40, = 5000
= 0.3 (this parameter setting yields best performance among combinations
= 2000, 3000, ..., 6000 = 0.1, 0.2, ..., 0.5). Among 100 runs, 4 runs find 3902-sized
solution averaged time 2955 seconds, 93 runs find 3903-sized solution (including
3902-sized) averaged time 1473 seconds. Also, interesting note NuMVC
locate rather good approximate solution hard instance quickly: size vertex
covers NuMVC finds within 100 seconds 3903 3905.
Generally, finding (k+1)-vertex cover much easier k-vertex cover. Hence,
NuMVC, well MVC local search algorithms solve MVC problem
solving k-vertex cover problem iteratively, majority running time used finding
best vertex cover C (of run), trying, without success, find vertex cover size
(|C | 1).
6.4 Comparison Heuristic Algorithms
recent literature five leading heuristic algorithms MVC (MC, MIS), including
three MVC algorithms COVER (Richter et al., 2007), EWLS (Cai et al., 2010) EWCC (Cai
et al., 2011), two MC algorithms DLS-MC (Pullan & Hoos, 2006) PLS (Pullan, 2006).
Note EWCC PLS improved versions EWLS DLS-MC respectively, show
better performance original versions DIMACS BHOSLIB benchmarks. Therefore,
compare NuMVC PLS, COVER EWCC.
comparing NuMVC heuristic algorithms, report V C , suc, time well
IQR. averaged run time successful runs (suc time) cannot indicate comparative
performance algorithms correctly unless evaluated algorithms close success rates,
f (100suc)
calculated time100cutof
, report statistics. results
suc
bold indicate best performance instance.
6.4.1 C OMPARATIVE R ESULTS



DIMACS B ENCHMARK

comparative results DIMACS benchmark shown Table 3. DIMACS instances
easy solved solvers 100% success rate within 2 seconds, thus
reported table. Actually, fact DIMACS benchmark reduced 11
useful instances really emphasizes need make new benchmark.
9. http://www.nlsde.buaa.edu.cn/kexu/benchmarks/graph-benchmarks.htm

699

fiC AI , U , L UO & ATTAR

Graph
Instance Vertices
frb30-15-1
frb30-15-2
frb30-15-3
frb30-15-4
frb30-15-5
frb35-17-1
frb35-17-2
frb35-17-3
frb35-17-4
frb35-17-5
frb40-19-1
frb40-19-2
frb40-19-3
frb40-19-4
frb40-19-5
frb45-21-1
frb45-21-2
frb45-21-3
frb45-21-4
frb45-21-5
frb50-23-1
frb50-23-2
frb50-23-3
frb50-23-4
frb50-23-5
frb53-24-1
frb53-24-2
frb53-24-3
frb53-24-4
frb53-24-5
frb56-25-1
frb56-25-2
frb56-25-3
frb56-25-4
frb56-25-5
frb59-26-1
frb59-26-2
frb59-26-3
frb59-26-4
frb59-26-5

450
450
450
450
450
595
595
595
595
595
760
760
760
760
760
945
945
945
945
945
1150
1150
1150
1150
1150
1272
1272
1272
1272
1272
1400
1400
1400
1400
1400
1534
1534
1534
1534
1534

V C
420
420
420
420
420
560
560
560
560
560
720
720
720
720
720
900
900
900
900
900
1100
1100
1100
1100
1100
1219
1219
1219
1219
1219
1344
1344
1344
1344
1344
1475
1475
1475
1475
1475

suc

VC size

NuMVC
time (suc time)

steps (suc steps)

100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
95
100
100
86
100
100
100
100
100
97
100
100
100
88
38
96
79
100

420
420
420
420
420
560
560
560
560
560
720
720
720
720
720
900
900
900
900
900
1100
1100
1100(1100.05,1101)
1100
1100
1219(1219.14,1220)
1219
1219
1219
1219
1344
1344(1344.03,1345)
1344
1344
1344
1475(1475.12,1476)
1475(1475.62,1476)
1475(1475.04,1476)
1475(1475.21,1476)
1475

0.045
0.053
0.191
0.049
0.118
0.515
0.447
0.178
0.563
0.298
0.242
4.083
1.076
2.757
10.141
2.708
4.727
13.777
3.973
10.661
38.143
176.589
606.165(532.805)
7.89
19.529
895.006(715.123)
205.352
51.227
266.871
39.893
470.682
658.961(617.485)
121.298
49.446
26.761
843.304(687.845)
1677.801(1160.020)
644.831(580.032)
1004.550(741.208)
61.907

37963
44632
173708
41189
105468
386287
334255
129279
422638
218800
208115
3679770
959874
2473081
9142719
2029588
3605881
10447444
3000680
8059236
24628019
113569606
386342329(343518242)
5092072
12690957
514619149(416394360)
117980833
29376406
152982736
22817023
259903023
350048132(326853745)
67043078
26030031
14109165
440874471(350993718)
875964146(592010913)
325417225(295226277)
517521634(375976753)
31682895

Table 2: NuMVC performance results, averaged 100 independent runs, BHOSLIB
benchmark instances. BHOSLIB instances hidden optimal vertex cover,
whose size shown VC column.

indicated Table 3, NuMVC outperforms COVER EWCC instances,
competitive complementary PLS. eight hard instances least one
solver fails achieve 100% success rate, PLS dominates brock graphs NuMVC
dominates others, including two putatively hardest instances C2000.9 MANN a81
(Richter et al., 2007; Grosso et al., 2008; Cai et al., 2011), well keller6 MANN a45.
700

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

Graph
Instance

V C

suc

PLS
time (IQR)

suc

brock400 2
brock400 4
brock800 2
brock800 4
C2000.9
C4000.5
gen400 p0.9 55
keller6
MANN a45
MANN a81
p hat1500-1

371
367
776
774
1920
3982
345
3302
690
2221
1488

100
100
100
100
0
100
100
92
1
0
100

0.15 (0.16)
0.03 (0.03)
3.89 (3.88)
1.31 (1.52)
n/a
67 (59)
15.17 (17)
559 (515)
1990 (n/a)
n/a
2.36 (3.07)

3
82
0
0
0
100
100
100
94
1
100

COVER
time (IQR)
1947 (n/a)
960 (988)
n/a
n/a
n/a
658 (290)
0.35 (0.1)
68 (6)
714 (774)
1995 (n/a)
18.10 (17.23)

suc

EWCC
time (IQR)

suc

NuMVC
time (IQR)

20
100
0
0
0
100
100
100
88
1
100

1778 (n/a)
25.38 (25.96)
n/a
n/a
n/a
739 (903)
0.05 (0.04)
3.76 (3.57)
763 (766)
1986 (n/a)
9.79 (9.77)

96
100
0
0
1
100
100
100
100
27
100

572 (646)
4.98 (6.14)
n/a
n/a
1994 (n/a)
252 (97)
0.03 (0.01)
2.51 (0.76)
86 (95)
1657 (n/a)
3.75 (3.19)

Table 3: Comparison NuMVC state-of-the-art heuristic algorithms DIMACS
benchmark. VC column marked asterisk means minimum known
vertex cover size proved optimal.

C2000.9, NuMVC finds 1920-sized solution, finds 1921-sized solution
70 runs, number 31, 6 32 PLS, COVER, EWCC respectively. Note
PLS performs well brock family comprises three sub-algorithms, one
favors lower degree vertices.
Table 3 indicates C2000.9 MANN a81 remain difficult modern algorithms,
none algorithms solve good success rate reasonable time.
hand, instances solved quickly (in less 100 seconds) least one algorithm, PLS
NuMVC, low IQR value (always less 100), indicates quite stable performance.
6.4.2 C OMPARATIVE R ESULTS



BHOSLIB B ENCHMARK

Table 4, present comparative results BHOSLIB benchmark. concentrating
considerable gaps comparisons, report results two groups small instances
(frb30 frb35), solved within several seconds solvers.
results Table 4 illustrate NuMVC significantly outperforms algorithms
BHOSLIB instances, terms success rate averaged run time,
demonstrated Figure 1. take look comparison NuMVC EWCC,
EWCC performs obviously better PLS COVER benchmark. NuMVC solves 33
instances 40 100% success rate, 4 instances EWCC does. instances
solved algorithms 100% success rate, overall averaged run time 25 seconds
NuMVC 74 seconds EWCC. instances, averaged success rate 90%
NuMVC, compared 50% EWCC.
excellent performance NuMVC underlined large gaps NuMVC
solvers hard instances. example, instances solvers fail
find optimal solution 100% success rate, NuMVC achieves overall averaged success
rate 82.57%, dramatically better PLS, COVER EWCC, 0.85%,
17.43% 35.71% respectively. Obviously, experimental results show NuMVC delivers
701

fiC AI , U , L UO & ATTAR

Graph
Instance

V C

suc

PLS
time (IQR)

suc

frb40-19-1
frb40-19-2
frb40-19-3
frb40-19-4
frb40-19-5
frb45-21-1
frb45-21-2
frb45-21-3
frb45-21-4
frb45-21-5
frb50-23-1
frb50-23-2
frb50-23-3
frb50-23-4
frb50-23-5
frb53-24-1
frb53-24-2
frb53-24-3
frb53-24-4
frb53-24-5
frb56-25-1
frb56-25-2
frb56-25-3
frb56-25-4
frb56-25-5
frb59-26-1
frb59-26-2
frb59-26-3
frb59-26-4
frb59-26-5

720
720
720
720
720
900
900
900
900
900
1100
1100
1100
1100
1100
1219
1219
1219
1219
1219
1344
1344
1344
1344
1344
1475
1475
1475
1475
1475

100
100
100
100
95
100
100
21
100
100
30
3
2
100
79
1
6
20
21
10
1
0
0
11
27
0
0
3
0
30

10.42 (10.38)
85.25 (72.75)
9.06 (10.21)
77.39 (90.56)
496 (529.25)
52.31 (55.5)
170 (202.2)
1737 (n/a)
111 (130)
261 (300)
1658 (640)
1956 (n/a)
1989 (n/a)
93 (80)
967 (1305)
1982 (n/a)
1959 (n/a)
1771 (n/a)
1782 (n/a)
1955 (n/a)
1993 (n/a)
n/a
n/a
1915 (n/a)
1719 (n/a)
n/a
n/a
1978 (n/a)
n/a
1708 (420)

100
100
100
100
100
100
100
100
100
100
100
48
39
100
100
17
50
99
48
95
24
17
97
93
100
16
9
21
3
98

COVER
time (IQR)
1.58 (0.55)
17.18 (16.09)
5.06 (4)
11.79 (8.67)
124 (131)
14.34 (12.8)
38 (35.4)
110 (121)
21 (18)
105 (103 )
268 (305)
1325 (n/a)
1486 (n/a)
33 (25)
168 (246)
1796 (n/a)
1279 (n/a)
273 (223)
1428 (n/a)
423 (315)
1698 (n/a)
1598 (n/a)
537 (692)
476 (460)
168 (128)
1607 (n/a)
1881 (n/a)
1768 (n/a)
1980 (n/a)
431 (476)

suc

EWCC
time (IQR)

suc

100
100
100
100
100
100
100
100
100
100
100
82
56
100
100
30
81
100
81
100
56
52
100
100
100
21
7
64
20
100

0.55 (0.48)
11.30 (14.21)
2.97 (2.35)
13.79 (16.05)
41.71 (39.08)
9.07 (9.3)
15 (14.1)
56 (70.4)
15 (12.5)
42 (40.1)
124 (135)
905 (1379)
1348 (n/a)
24 (27)
85 (97)
1696 (n/a)
1006 (1270)
117 (136)
900 (1480)
125 (115)
1268 (n/a)
1387 (n/a)
285 (250)
183 (188)
80 (81)
1778 (n/a)
1930 (n/a)
1294 (n/a)
1745 (n/a)
174 (182)

100
100
100
100
100
100
100
100
100
100
100
100
95
100
100
86
100
100
100
100
100
97
100
100
100
88
37
96
79
100

NuMVC
time (IQR)
0.24 (0.18)
4.08 (3.77)
1.07 (1.03)
2.76 (2.83)
10.14 (10.54)
2.71 (2.6)
5 (5.1)
14 (11.9)
4 (4.3)
11 (10.9)
38 (46)
177 (149)
606 (788)
8 (7)
19 (19)
895 (1099)
205 (200)
51 (48)
266 (311)
40 (44)
470 (466)
659 (780)
121 (118)
50 (49)
27 (23)
843 (849)
1677 (n/a)
636 (788)
1004 (1391)
62 (70)

Table 4: Comparison NuMVC state-of-the-art local search algorithms
BHOSLIB benchmark. BHOSLIB instances hidden optimal vertex cover,
whose size shown VC column.

702

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

100

2000

90

1800

80

1600

70

1400
average run time (s)

average success rate

best performance hard random benchmark, vastly improving existing performance
results. observe that, NuMVC always minimum IQR value instances,
indicates apart efficiency, robustness NuMVC better solvers.

60
50
40
30
20

1200
1000
800

PLS
COVER
EWCC
NuMVC

600
400

10
0
760(frb40)

PLS
COVER
EWCC
NuMVC

200
945(frb45)

0
760(frb40)

1150(frb50)1272(frb53) 1400(frb56) 1534(frb59)
number vertices graph

945(frb45)

1150(frb50)1272(frb53) 1400(frb56) 1534(frb59)
number vertices graph

Figure 1: Comparison NuMVC local search algorithms BHOSLIB benchmark
terms success rate (left) averaged run time (right)
compare NuMVC COVER EWCC challenging instance frb100-40.
Given failure PLS large BHOSLIB instances, run PLS instance.
comparative results frb100-40 shown Table 5, indicates NuMVC
significantly outperforms COVER EWCC challenging instance.
Finally, would remark performance NuMVC BHOSLIB benchmark
better four-core version CLS (Pullan et al., 2011), even divide run time
NuMVC 4 (the number cores utilized CLS). consider machine speed ratio
divide run time NuMVC 4, NuMVC would dramatically better CLS
BHOSLIB benchmark.
Size
VC
3902
3903

suc
0
33

COVER
avg suc time
n/a
2768

suc
1
79

EWCC
avg suc time
2586
2025

suc
4
93

NuMVC
avg suc time
2955
1473

Table 5: Comparative results frb100-40 challenging instance. solver executed
100 times instance timeout 4000 seconds.

6.5 Comparison Exact Algorithms
section, compare NuMVC state-of-the-art exact Maximum Clique algorithm.
Generally, exact algorithms heuristic algorithms somewhat complementary
applications. Usually, exact algorithms find solutions structured instances faster heuristic
algorithms faster random ones.
703

fiC AI , U , L UO & ATTAR

Compared MVC MIS, many exact algorithms designed Maximum Clique
problem (Carraghan & Pardalos, 1990; Fahle, 2002; Ostergard, 2002; Regin, 2003; Tomita &
Kameda, 2009; Li & Quan, 2010b, 2010a). recent branch-and-bound MC algorithm MaxCLQ
(Li & Quan, 2010b) utilizes MaxSAT inference technologies (Li, Manya, & Planes, 2007)
improve upper bounds shows considerable progress. Experimental results MaxCLQ (Li &
Quan, 2010b) random graphs DIMACS instances indicate MaxCLQ significantly
outperforms previous exact MC algorithms. MaxCLQ algorithm improved using two
strategies called Extended Failed Literal Detection Soft Clause Relaxation, resulting better
algorithm denoted MaxCLQdyn+EFL+SCR (Li & Quan, 2010a). Due great success
MaxCLQdyn+EFL+SCR, compare algorithm MaxCLQdyn+EFL+SCR.
compare NuMVC MaxCLQdyn+EFL+SCR DIMACS benchmark instances.
results MaxCLQdyn+EFL+SCR taken previous work (Li & Quan, 2010a).
MaxCLQdyn+EFL+SCR evaluated BHOSLIB benchmark much harder
requires effective technologies exact algorithms (Li & Quan, 2010a).
run time results MaxCLQdyn+EFL+SCR obtained 3.33 GHz Intel Core 2 Duo
CPU linux 4 Gb memory, required 0.172 seconds r300.5, 1.016 seconds
r400.5 3.872 seconds r500.5 execute DIMACS machine benchmarks (Li & Quan,
2010a). corresponding run time machine 0.19, 1.12 4.24 seconds. So, multiply
reported run time MaxCLQdyn+EFL+SCR 1.098 (=(4.24/3.872+1.12/1.016)/2=1.098,
average two largest ratios). normalization based methodology established
Second DIMACS Implementation Challenge Cliques, Coloring, Satisfiability,
widely used comparing different MaxClique algorithms (Pullan & Hoos, 2006; Pullan, 2006; Li
& Quan, 2010b, 2010a).
Graph
Instance
brock400 2
brock400 3
brock400 4
brock800 2
brock800 3
brock800 4
keller5
MANN a27
MANN a45

V C

371
369
367
776
775
774
749
252
690

NuMVC
suc
time
96
100
100
0
0
0
100
100
100

572.39
8.25
4.98
n/a
n/a
n/a
0.04
<0.001
86.86

MaxCLQdyn+EFL
+SCR time
125.06
251.44
119.24
5138.10
3298.39
2391.44
6884.46
0.17
21.169

Graph
Instance

V C

NuMVC
suc
time

p hat300-3
p hat700-2
p hat700-3
p hat1000-2
p hat1000-3
p hat1500-1
p hat1500-2
sanr200 0.9
sanr400 0.7

264
656
638
954
932
1488
1435
158
379

100
100
100
100
100
100
100
100
100

0.001
0.006
0.008
0.019
0.032
3.75
0.071
<0.001
0.008

MaxCLQdyn+EFL
+SCR time
1.31
3.27
1141.92
108.94
113860.40
3.10
866.51
5.20
97.72

Table 6: Comparison NuMVC state-of-the-art exact MaxClique algorithm MaxCLQdyn+EFL+SCR DIMACS benchmark.

Table 6, present performance NuMVC MaxCLQdyn+EFL+SCR
DIMACS instances. results indicate NuMVC finds optimal solution much faster
MaxCLQdyn+EFL+SCR random instances p hat sanr instances.
believe similar results would hold hard random benchmarks BHOSLIB ones,
MaxCLQdyn+EFL+SCR evaluated instances due high hardness (Li & Quan,
2010a), NuMVC performs well them.
structured instances, note MaxCLQdyn+EFL+SCR mainly evaluated
brock instances NuMVC performs worst, open DIMACS instances
704

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

MANN a81, johnson32-2-4 keller6, remain difficult solve exact
algorithms (Li & Quan, 2010a). Although MaxCLQdyn+EFL+SCR overall performs better,
NuMVC finds optimal solution significantly faster MaxCLQdyn+EFL+SCR
structured instances, two brock instances keller5.
Finally, would note although heuristic solvers find optimal solutions fast,
unable prove optimality solutions find. hand, run time
exact algorithm spent finding optimal solution proving optimality.
sense, heuristic exact algorithms cannot compared fair way. Nevertheless,
experiments suggest heuristic approaches appealing solving large instances reasonable
short time.

7. Discussions
section, first explore run-time distribution NuMVC representative
instances, investigate effectiveness two-stage exchange strategy
forgetting mechanism NuMVC. Finally, analyze performance NuMVC different
settings two parameters forgetting mechanism, shows NuMVC
sensitive parameters.
7.1 Run-time Distributions NuMVC
subsection, conduct empirical study gain deeper insights run-time behavior
NuMVC. specifically, study run-time distribution NuMVC several representative
instances. purpose comparison, report run-time distribution EWCC,
best competing MVC local search solver.
Consider randomized algorithm solving given optimization problem instance, halting
soon optimal solution found. run time algorithm viewed
random variable, fully described distribution, commonly referred run-time
distribution (RTD) literature algorithm performance modeling (Hoos & Stutzle, 2004;
Bartz-Beielstein et al., 2010). methodology studying run-time behavior algorithms
based RTDs widely used empirical analysis heuristic algorithms (Hoos & Stutzle,
1999; Finkelstein, Markovitch, & Rivlin, 2003; Watson, Whitley, & Howe, 2005; Pullan & Hoos,
2006). follow methodology study here.
studying typical run-time behaviour, choose instances NuMVC reaches optimal
solution 100 runs, appropriate difficulty. DIMACS benchmark, select
brock400 4 MANN a45, reasonable size hardness. Also, two
instances represent two typical instance classes NuMVC, NuMVC poor performance
brock instances, dominates heuristic algorithms MANN instances.
BHOSLIB benchmark, frb56-25-5 frb59-26-5 selected. appropriate
instances studying run-time behavior NuMVC, since neither easy
solved short time difficult reach 100% success rate.
empirical RTD graphs NuMVC EWCC shown Figure 2 (the RTD
instance based 100 independent runs reach respective optimal solution). According
graphs, NuMVC shows large variability run time. investigation indicates
RTDs quite well approximated exponential distributions, labeled ed[m](x) = 1 2x/m ,
median distribution. test goodness approximations, use
705

fiC AI , U , L UO & ATTAR

Empirical RTD NuMVC EWCC MANN_a45

Empirical RTD NuMVC EWCC brock400_4
1
0.9
0.8
0.7

1
0.9

RTD NuMVC
ed[3.6]
RTD EWCC
ed[12]

0.8
0.7
0.6
P(solve)

P(solve)

0.6
0.5

0.5

0.4

0.4

0.3

0.3

0.2

0.2

0.1

0.1

0
2
10

1

0

10

1

2

10
10
runtime [CPU sec]

10

0
1
10

3

10

Empirical RTD NuMVC EWCC frb56255

0.8
0.7

0.9

RTD NuMVC
ed[19]
RTD EWCC
ed[53]

0.8
0.7

2

3

10

4

10

RTD NuMVC
ed[45]
RTD EWCC
ed[116]

0.6
P(solve)

P(solve)

1

10
10
runtime [CPU sec]

1

0.6
0.5

0.5

0.4

0.4

0.3

0.3

0.2

0.2

0.1

0.1

0
1
10

0

10

Empirical RTD NuMVC EWCC frb59265

1
0.9

RTD NuMVC
ed[59]
RTD EWCC
ed[532]

0

10

1

10
runtime [CPU sec]

2

10

0
1
10

3

10

0

10

1

10
runtime [CPU sec]

2

10

3

10

Figure 2: Run-time distributions (RTDs) NuMVC EWCC applied two DIMACS instances
(top) two BHOSLIB instances (bottom); empirical RTDs well approximated
exponential distributions, labeled ed[m](x) = 1 2x/m plots.

Kolmogorov-Smirnov test, fails reject null hypothesis sampled run time
stems exponential distributions shown figures standard confidence level
= 0.05 p-values 0.19 0.88. EWCC, Kolmogorov-Smirnov test
shows RTDs MANN a45 two BHOSLIB instances exponential distributions,
RTD brock400 4 exponential distribution.
observation exponential RTDs NuMVC consistent similar results
high performance SLS algorithms, e.g., MaxClique (Pullan & Hoos, 2006), SAT (Hoos &
Stutzle, 1999), MAXSAT (Smyth, Hoos, & Stutzle, 2003), scheduling problems (Watson
et al., 2005). arguments (Hoos & Stutzle, 1999; Hoos & Stutzle, 2004) made stochastic
local search algorithms characterized exponential RTD, conclude that, NuMVC,
probability finding optimal solution within fixed amount time (or steps) depend
run time past. Consequently, robust w.r.t. cutoff time thus, restart
706

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

time. Therefore, performing multiple independent runs NuMVC parallel result closeto-optimal parallelization speedup. Similar observations made DIMACS
instances BHOSLIB instances.
practical interest RTD analysis NuMVC difficult instances
algorithms experiments fail achieve high success rate (i.e., 40%). RTDs
cases would show algorithm stagnates suggest a-posteriori restart time
algorithm. purpose, select MANN a81 frb59-26-2 analysis. RTDs
NuMVC two instances illustrated Figure 3. Interestingly, RTDs
observe obvious stagnation, confirms NuMVC robust w.r.t. cutoff time
thus restart time. Therefore, increasing cutoff time, expect higher success
rate algorithm difficult instances.
Empirical RTD NuMVC MANN_a81 frb59262
1
0.9
RTD NuMVC MANN_a81
0.8
RTD NuMVC frb59262
0.7

P(solve)

0.6
0.5
0.4
0.3
0.2
0.1
0
1
10

2

3

10

10

4

10

runtime [CPU sec]

Figure 3: Run-time distributions (RTDs) NuMVC MANN a81 frb59-26-2 instances,
NuMVC finds optimal (or best known) solution less half runs.

7.2 Effectiveness Two-Stage Exchange
study effectiveness two-stage exchange strategy, compare NuMVC
alternative algorithm NuMVC0 selects two vertices exchanging simultaneously.
step, NuMVC0 first chooses uncovered edge e uniformly random, evaluates pair
vertices u v u current candidate solution v one endpoint e
conf Change(v) = 1. evaluating benefit (i.e., decrement cost function)
exchanging vertex pair u v, NuMVC0 first checks whether neighbors. u
v neighbors, benefit dscore(u) + dscore(v) + w(e{u, v}); otherwise, benefit
dscore(u) + dscore(v). NuMVC0 selects vertex pair greatest benefit exchange.
NuMVC (and NuMVC0 ) algorithm, two candidate vertices add
current candidate solution C (i.e., endpoints selected uncovered edge). Hence,
worst case, NuMVC performs 2 + |C| evaluations, NuMVC0 evaluate 2 |C|
pairs vertices. Moreover, NuMVC needs check dscore vertex (vertex)
707

fiC AI , U , L UO & ATTAR

evaluation, NuMVC0 performs vertex-pair evaluation involves pair vertices
relationship, thus time-consuming. Based analysis, conjecture
complexity per step NuMVC least 2 times lower NuMVC0 . Also,
mentioned Section 3, two-stage exchange strategy less greedy one selecting
two vertices exchanging simultaneously, NuMVC0 does.
investigation carried 4 DIMACS instances different families well
12 BHOSLIB instances. DIMACS benchmark, select brock400 2, C4000.5,
MANN a45, p hat 1500-1. instances different characteristics, described
(Pullan et al., 2011). Note following conclusions DIMACS instances
complementary DIMACS graphs.
DIMACS brock instances minimum vertex covers consist medium lower
degree vertices, designed defeat greedy heuristics.
DIMACS C p hat 1500-1 instances minimum vertex covers consist
higher degree vertices effectively solved greedy heuristics.
DIMACS MANN instances large proportion plateaus instance searchspace, thus greedy heuristics unsuitable solve them.
BHOSLIB instances minimum vertex covers consisting vertices whose
distribution vertex degree closely matches complete graph. difficult
instances greedy diversification heuristics.
Graph
Instance
brock400 2
C4000.5
MANN a45
p hat 1500-1
frb50-23-1
frb50-23-2
frb50-23-3
frb53-24-1
frb53-24-2
frb53-24-3
frb56-25-1
frb56-25-2
frb56-25-3
frb59-26-1
frb59-26-2
frb59-26-3

V C
371
3982
690
1488
1100
1100
1100
1219
1219
1219
1344
1344
1344
1475
1475
1475

suc
96
100
100
100
100
100
95
86
100
100
100
97
100
88
37
96

time
572
252
86
3.75
38
177
606
895
205
51
470
659
121
843
1677
636

NuMVC
steps
645631471
7802785
90642150
445830
24628019
113569606
386342329
514619149
117980833
29376406
259903023
350048132
67043078
440874471
875964146
325417225

#steps/sec (105 )
11.3
0.3
10.5
1.2
6.5
6.4
6.4
5.7
5.8
5.8
5.5
5.3
5.5
5.2
5.2
5.1

suc
19
100
100
100
100
100
63
45
100
100
72
52
100
45
21
69

time
1861
607
564
13.24
88
499
1312
1595
557
106
1088
1499
253
1572
1853
1545

NuMVC0
steps
837844749
6343304
186350533
381762
18125042
104841043
262559614
286396840
105863802
19685358
184323492
254973016
43062419
251520339
315425608
247273810

#steps/sec (105 )
4.5
0.1
3.3
0.3
2.1
2.1
2.0
1.8
1.9
1.9
1.7
1.7
1.7
1.6
1.7
1.6

Table 7: Comparative performance NuMVC NuMVC0 selects two vertices
exchanging simultaneously. results based 100 independent runs solver
instance.
comparative results NuMVC NuMVC0 presented Table 7. results show
NuMVC significantly outperforms NuMVC0 terms averaged run time, primarily due
much lower complexity per step. second, NuMVC performs 3-4 times steps
708

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

NuMVC0 , supports conjecture complexity per step NuMVC 2
times lower NuMVC0 .
turn attention comparing NuMVC NuMVC0 terms step performance,
independent complexity per step. brock MANN graphs difficult
greedy heuristics, NuMVC significantly better step performance NuMVC0 .
hand, greedy-friendly graphs C4000.5 p hat 1500-1, NuMVC needs
steps converge optimal solution NuMVC0 does. observations support
argument two-stage exchange strategy less greedy one selects two vertices
exchanging simultaneously, NuMVC0 does.
observe step performance NuMVC0 better NuMVC
BHOSLIB instances. instance, BHOSLIB instances algorithms
100% success rate, NuMVC needs 1.2 times steps NuMVC0 find optimal
solution. expect cannot yet explain. Nevertheless, NuMVC makes
rather rapid modifications solution, little degrade step performance hurt.
Graph
Instance
C4000.5
MANN a45
p hat 1500-1
frb53-24-5
frb56-25-5
frb59-26-5

PLS
#steps/sec
85,318
1,546,625
170,511
841,346
801,282
706,436

COVER
#steps/sec
8,699
279,514
19,473
128,971
116,618
108,534

EWCC
#steps/sec
11,927
578,656
34,111
219,038
199,441
189,536

NuMVC
#steps/sec
30,963
1,053,978
118,888
570,425
522,561
511,014

Table 8: Complexity per step selected instances
demonstrate low complexity per step NuMVC, compare number
search steps per second NuMVC state-of-the-art heuristic solvers
representative instances. indicated Table 8, NuMVC executes many steps second
two MVC local search solvers COVER EWCC do. instances Table
8, second NuMVC executes 4-6 times steps COVER, 3-4 times steps
EWCC. indicates two-stage exchange strategy significantly accelerate MVC
local search algorithms. Although PLS performs steps per second NuMVC, MC
local search algorithm whose search scheme essentially different MVC local search
algorithms.
7.3 Effectiveness Forgetting Mechanism
study effectiveness forgetting mechanism NuMVC, compare NuMVC
two alternative algorithms NuMVC1 NuMVC2 , obtained NuMVC modifying
edge weighting scheme below.
NuMVC1 works way NuMVC, except using forgetting mechanism,
is, deleting line 18 Algorithm 1.
NuMVC2 adopts forgetting mechanism used DLS-MC (Pullan & Hoos, 2006)
weighting scheme. specifically, NuMVC2 increases weights uncovered edges
709

fiC AI , U , L UO & ATTAR

one end step, performs forgetting operation every pd steps decreasing
weights one edges whose weights greater one. Note pd instancedependent parameter.
experiments carried representative instances benchmarks.
DIMACS benchmark, select brock400 2, C4000.5, keller6, MANN a45,
different classes appropriate difficulty. BHOSLIB benchmark,
select three instances three largest-sized instance groups respectively.
Graph
Instance Vertices
brock400 2
400
C4000.5
4000
keller6
3361
MANN a45
1035
frb53-24-1
1272
frb53-24-2
1272
frb53-24-3
1272
frb56-25-1
1400
frb56-25-2
1400
frb56-25-3
1400
frb59-26-1
1534
frb59-26-2
1534
frb59-26-3
1534

C

V
371
3982
3302
690
1219
1219
1219
1344
1344
1344
1475
1475
1475

NuMVC
suc time
96
572
100
252
100 2.51
100
86
86
895
100
205
100
51
100
470
97
659
100
121
88
843
37 1677
96
636

NuMVC1
suc time
22 1781
100
270
100 2.95
65 1187
60
925
100
243
100
49
85
914
63 1209
100
111
64 1229
21 1894
83
997

NuMVC2
pd (102 ) suc time
15 100
21
60 100
327
750 100 4.26
8 100
113
100
78
901
100 100
201
100 100
52
130
91
595
130
81
739
130 100
117
150
85
907
150
45 1439
150
97
652

Table 9: Comparative performance NuMVC two alternatives NuMVC1 NuMVC2 .
algorithm performed 100 times instance.

apparent observation Table 9 two algorithms forgetting mechanisms
(i.e., NuMVC NuMVC2 ) outperform NuMVC1 almost instances. Particularly, due
missing forgetting mechanism, NuMVC1 performs significantly worse two
algorithms brock MANN graphs. hand, Table 9 demonstrates NuMVC
NuMVC2 exhibit competitive performance BHOSLIB benchmark, dominate different
types DIMACS instances. specifically, NuMVC outperforms NuMVC2 C4000.5,
keller6 MANN a45, performs significantly worse NuMVC2 brock400 2.
order find genuine performance NuMVC2 brock instances, test NuMVC2
larger brock800 2 brock800 4 instances. results show two large brock
instances substantially difficult two brock400 instances, NuMVC2 fails
solve neither them.
Although NuMVC2 shows competitive performance NuMVC, performance given
optimizing pd parameter instance. Moreover, DLS-MC (Pullan & Hoos, 2006),
NuMVC2 considerably sensitive pd parameter. example, experiments show
frb53-24 instances, NuMVC2 performs quite well pd = 10000, fails find
optimal solution pd set value less 7000. Comparatively, NuMVC
710

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

parameter setting performs quite well types instances brock family. Actually,
show next section NuMVC sensitive parameters.
interesting compare NuMVC alternatives replace forgetting
mechanism smoothing techniques similar local search SAT. Indeed, earlier
versions NuMVC use smoothing techniques similar SAT local search,
good performance compared NuMVC. would interesting find
reasons success forgetting mechanism failure smoothing techniques
MVC edge weighting local search algorithms NuMVC.
7.4 Parameters Forgetting Mechanism

(0.3|V |, 0.1)
(0.3|V |, 0.2)
(0.3|V |, 0.3)
(0.3|V |, 0.4)
(0.3|V |, 0.5)

brock400 2
100% (382)
100% (361)
100% (362)
95% (490)
90% (507)

MANN a45
100% (153)
100% (164)
100% (131)
100% (208)
100% (90)

C4000.5
100% (262)
100% (265)
100% (272)
100% (270)
100% (268)

frb53-24-1
80% (904)
85% (918)
70% (1058)
80% (995)
65% (1316)

frb53-24-2
100% (348)
100% (279)
100% (156)
100% (191)
100% (431)

frb56-25-1
100% (338)
90% (671)
95% (826)
100% (602)
100% (490)

frb56-25-2
80% (997)
70% (1197)
85% (819)
100% (885)
95% (922)

(0.4|V |, 0.1)
(0.4|V |, 0.2)
(0.4|V |, 0.3)
(0.4|V |, 0.4)
(0.4|V |, 0.5)

100% (261)
90% (736)
100% (402)
95% (375)
90% (612)

100% (133)
100% (207)
100% (176)
100% (169)
100% (190)

100% (250)
100% (245)
100% (258)
100% (253)
100% (264)

80% (899)
80% (860)
75% (1047)
70% (1009)
65% (1059)

100% (158)
100% (443)
100% (260)
100% (394)
100% (137)

90% (464)
85% (611)
90% (976)
90% (885)
95% (428)

70% (1601)
80% (851)
90% (1055)
85% (1019)
100% (851)

(0.5|V |, 0.1)
(0.5|V |, 0.2)
(0.5|V |, 0.3)
(0.5|V |, 0.4)
(0.5|V |, 0.5)

100% (523)
85% (950)
96% (572)
90% (499)
90% (968)

100% (107)
100% (69)
100% (86)
100% (169)
100% (148)

100% (262)
100% (259)
100% (252)
100% (251)
100% (249)

70% (1007)
75% (1061)
86% (850)
70% (931)
90% (805)

100% (416)
100% (482)
100% (205)
100% (219)
100% (361)

90% (714)
95% (706)
100% (470)
90% (632)
85% (933)

75% (1064)
70% (1228)
97% (625)
80% (1027)
85% (983)

(0.6|V |, 0.1)
(0.6|V |, 0.2)
(0.6|V |, 0.3)
(0.6|V |, 0.4)
(0.6|V |, 0.5)

100% (527)
80% (713)
75% (976)
100% (710)
85% (742)

100% (203)
100% (172)
100% (92)
100% (142)
100% (125)

100% (255)
100% (279)
100% (272)
100% (276)
100% (288)

70% (1109)
75% (944)
70% (1130)
75% (907)
80% (947)

100% (267)
100% (254)
100% (298)
100% (170)
100% (192)

100% (828)
90% (704)
90% (689)
100% (592)
100% (647)

90% (878)
70% (1306)
75% (862)
85% (1028)
80% (1109)

(0.7|V |, 0.1)
(0.7|V |, 0.2)
(0.7|V |, 0.3)
(0.7|V |, 0.4)
(0.7|V |, 0.5)

100% (410)
95% (781)
90% (826)
75% (1219)
90% (707)

100% (87)
100% (128)
100% (125)
100% (101)
100% (92)

100% (273)
100% (284)
100% (266)
100% (272)
100% (280)

65% (1186)
70% (1035)
75% (916)
85% (700)
70% (1085)

100% (358)
100% (220)
100% (206)
100% (338)
100% (352)

75% (1014)
80% (713)
80% (878)
100% (536)
90% (736)

75% (934)
90% (510)
80% (971)
85% (769)
70% (1044)

Table 10: Comparative performance NuMVC various parameter combinations (, )
forgetting mechanism. instance, NuMVC performed 20 times
parameter combination, except one adopted work (0.5|V |, 0.3),
results based 100 runs. keller6, NuMVC performs almost
various parameters, success rate (100%) tiny difference averaged
run time (less 1 second), thus results reported table.

711

fiC AI , U , L UO & ATTAR

NuMVC algorithm two parameters , specify forgetting mechanism.
Specifically, averaged weight edges achieves threshold , edge weights
multiplied constant factor (0 < < 1). subsection, investigate NuMVC
performs different settings two parameters. investigation carried
DIMACS BHOSLIB benchmarks. DIMACS benchmark, select four instances
used preceding subsection reasons. BHOSLIB benchmark, select
frb53-24-1, frb53-24-2, frb56-25-1 frb56-25-2, different sizes
appropriate hardness.
Table 10 presents performance NuMVC various parameter combinations
representative instances. see Table 10, parameter combination
(0.5|V |, 0.3) yields relatively good performance instances, exhibits better robustness
instances parameter combinations do.
hand, observe NuMVC various parameter combinations performs
comparably tested instances. example, parameter settings, NuMVC achieves
success rate 100% keller6, MANN a45, C4000.5 well frb53-24-1,
averaged run time difference instances significant. instances,
difference success rate never exceeds 25% two parameter settings. observation
indicates NuMVC seems sensitive two parameters. Actually, mentioned
before, NuMVC exhibits good performance DIMACS BHOSLIB benchmarks
fixed parameter setting. advantage compared forgetting mechanisms
one used DLS-MC (Pullan & Hoos, 2006), sensitive parameter.
algorithms sensitive parameters, considerable parameter tuning required order
get good performance certain instance, usually costs much time solving
instance.

8. Conclusions Future Work
paper, presented two new local search strategies minimum vertex cover (MVC)
problem, namely two-stage exchange edge weighting forgetting. two-stage exchange
strategy yields efficient two-pass move operator MVC local search algorithms,
significantly reduces time complexity per step. forgetting mechanism enhances
edge weighting scheme decreasing weights averaged weight reaches threshold,
periodically forget earlier weighting decisions. Based two strategies, designed
slight, yet effective MVC local search algorithm called NuMVC. NuMVC algorithm
evaluated best known heuristic algorithms MVC (MC, MIS) standard benchmarks,
i.e., DIMACS BHOSLIB benchmarks. experimental results show NuMVC
largely competitive DIMACS benchmark dramatically outperforms state-of-the-art
heuristic algorithms BHOSLIB instances.
Furthermore, showed NuMVC characterized exponential RTDs, means
robust w.r.t. cutoff parameters restart time, hence close-to-optimal parallelization
speedup. performed investigations provide insights two new
strategies effectiveness. Finally, conducted experiment study performance
NuMVC different parameter settings, results indicate NuMVC sensitive
parameters.
712

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

two-stage exchange strategy lower time complexity per step,
flexibility allow us employ specific heuristics different stages. interesting research
direction thus apply idea combinatorial problems whose essential tasks
seek optimal subset fixed cardinality.

Acknowledgments
work supported 973 Program 2010CB328103, ARC Future Fellowship FT0991785,
National Natural Science Foundation China (61073033, 61003056 60903054),
Fundamental Research Funds Central Universities China (21612414). would
thank editor anonymous reviewers valuable comments earlier versions
paper. would thank Yanyan Xu proofreading paper.

References
Aggarwal, C., Orlin, J., & Tai, R. (1997). Optimized crossover independent set problem.
Operations Research, 45, 226234.
Andrade, D. V., Resende, M. G. C., & Werneck, R. F. F. (2008). Fast local search maximum
independent set problem. Workshop Experimental Algorithms, pp. 220234.
Barbosa, V. C., & Campos, L. C. D. (2004). novel evolutionary formulation maximum
independent set problem. J. Comb. Optim., 8(4), 419437.
Bartz-Beielstein, T., Chiarandini, M., Paquete, L., & Preuss, M. (Eds.). (2010). Experimental
Methods Analysis Optimization Algorithms. Springer, Berlin, Heidelberg, New
York.
Battiti, R., & Protasi, M. (2001). Reactive local search maximum clique problem.
Algorithmica, 29(4), 610637.
Busygin, S., Butenko, S., & Pardalos, P. M. (2002). heuristic maximum independent set
problem based optimization quadratic sphere. J. Comb. Optim., 6(3), 287297.
Cai, S., & Su, K. (2011). Local search configuration checking SAT. Proc. ICTAI-11,
pp. 5966.
Cai, S., & Su, K. (2012). Configuration checking aspiration local search SAT. Proc.
AAAI-12, pp. 434440.
Cai, S., Su, K., & Chen, Q. (2010). EWLS: new local search minimum vertex cover. Proc.
AAAI-10, pp. 4550.
Cai, S., Su, K., & Sattar, A. (2011). Local search edge weighting configuration checking
heuristics minimum vertex cover. Artif. Intell., 175(9-10), 16721696.
Cai, S., Su, K., & Sattar, A. (2012). Two new local search strategies minimum vertex cover.
Proc. AAAI-12, pp. 441447.
Carraghan, R., & Pardalos, P. (1990). exact algorithm maximum clique problem.
Operations Research Letters, 9(6), 375382.
713

fiC AI , U , L UO & ATTAR

Dinur, I., & Safra, S. (2005). hardness approximating minimum vertex cover. Annals
Mathematics, 162(2), 439486.
Evans, I. (1998). evolutionary heuristic minimum vertex cover problem. Proceedings
Seventh International Conference Evolutionary Programming(EP), pp. 377386.
Fahle, T. (2002). Simple fast: Improving branch-and-bound algorithm maximum clique.
Proc. European Symposium Algorithms (ESA)-02, pp. 485498.
Feige, U. (2004). Approximating maximum clique removing subgraphs. SIAM J. Discrete Math.,
18(2), 219225.
Finkelstein, L., Markovitch, S., & Rivlin, E. (2003). Optimal schedules parallelizing anytime
algorithms: case shared resources. J. Artif. Intell. Res. (JAIR), 19, 73138.
Gajurel, S., & Bielefeld, R. (2012). fast near optimal vertex cover algorithm (novca).
International Journal Experimental Algorithms (IJEA), 3, 918.
Garey, M., & Johnson, D. (1979). Computers Intractability: Guide Theory NPcompleteness. Freeman, San Francisco, CA, USA.
Glover, F. (1989). Tabu search part i. ORSA Journal Computing, 1(3), 190206.
Grosso, A., Locatelli, M., & Pullan, W. J. (2008). Simple ingredients leading efficient
heuristics maximum clique problem. J. Heuristics, 14(6), 587612.
Halperin, E. (2002). Improved approximation algorithms vertex cover problem graphs
hypergraphs. SIAM Journal Computing, 31(5), 15081623.
Hastad, J. (1999). Clique hard approximate within n1 . Acta Math, 182, 105142.
Hastad, J. (2001). optimal inapproximability results. J. ACM, 48(4), 798859.
Hoaglin, D. C., Mosteller, F., & Tukey, J. W. (Eds.). (2000). Understanding Robust Exploratory
Data Analysis. Wiley Classics Library, Wiley, New York, NY.
Hoos, H., & Stutzle, T. (2004). Stochastic Local Search: Foundations Applications. Morgan
Kaufmann, San Francisco, CA, USA.
Hoos, H. H., & Stutzle, T. (1999). Towards characterisation behaviour stochastic local
search algorithms SAT. Artif. Intell., 112(1-2), 213232.
Hutter, F., Tompkins, D. A. D., & Hoos, H. H. (2002). Scaling probabilistic smoothing: Efficient
dynamic local search SAT. Proc. CP-02, pp. 233248.
Ishtaiwi, A., Thornton, J., Sattar, A., & Pham, D. N. (2005). Neighbourhood clause weight
redistribution local search SAT. Proc. CP-05, pp. 772776.
Johnson, D. S., & Trick, M. (Eds.). (1996). Cliques, Coloring, Satisfiability: Second DIMACS
Implementation Challenge, 1993, Vol. 26 DIMACS Series Discrete Mathematics
Theoretical Computer Science. American Mathematical Society, Providence, RI, USA.
Karakostas, G. (2005). better approximation ratio vertex cover problem. Proc.
ICALP-05, pp. 10431050.
Katayama, K., Sadamatsu, M., & Narihisa, H. (2007). Iterated k-opt local search maximum
clique problem. Proc. EvoCOP-07, pp. 8495.
714

fiN U MVC: N E FFICIENT L OCAL EARCH LGORITHM INIMUM V ERTEX C

Li, C. M., Manya, F., & Planes, J. (2007). New inference rules max-sat. J. Artif. Intell. Res.
(JAIR), 30, 321359.
Li, C. M., & Quan, Z. (2010a). Combining graph structure exploitation propositional reasoning
maximum clique problem. Proc. ICTAI-10, pp. 344351.
Li, C. M., & Quan, Z. (2010b). efficient branch-and-bound algorithm based maxsat
maximum clique problem. Proc. AAAI-10, pp. 128133.
Michiels, W., Aarts, E. H. L., & Korst, J. H. M. (2007). Theoretical aspects local search. Springer.
Minton, S., Johnston, M. D., Philips, A. B., & Laird, P. (1992). Minimizing conflicts: heuristic
repair method constraint satisfaction scheduling problems. Artif. Intell., 58(1-3), 161
205.
Morris, P. (1993). breakout method escaping local minima. Proc. AAAI-93, pp.
4045.
Ostergard, P. R. J. (2002). fast algorithm maximum clique problem. Discrete Applied
Mathematics, 120(1-3), 197207.
Papadimitriou, C. H. (1991). selecting satisfying truth assignment. Proc. FOCS-91, pp.
163169.
Pullan, W. (2006). Phased local search maximum clique problem. J. Comb. Optim., 12(3),
303323.
Pullan, W. (2009). Optimisation unweighted/weighted maximum independent sets minimum
vertex covers. Discrete Optimization, 6, 214219.
Pullan, W., & Hoos, H. H. (2006). Dynamic local search maximum clique problem. J. Artif.
Intell. Res. (JAIR), 25, 159185.
Pullan, W., Mascia, F., & Brunato, M. (2011). Cooperating local search maximum clique
problem. J. Heuristics, 17(2), 181199.
Regin, J. C. (2003). Using constraint programming solve maximum clique problem. Proc.
CP-03, pp. 634648.
Richter, S., Helmert, M., & Gretton, C. (2007). stochastic local search approach vertex cover.
Proc. KI-07, pp. 412426.
Schuurmans, D., Southey, F., & Holte, R. C. (2001). exponentiated subgradient algorithm
heuristic boolean programming. Proc. IJCAI-01, pp. 334341.
Shyu, S. J., Yin, P., & Lin, B. M. T. (2004). ant colony optimization algorithm minimum
weight vertex cover problem. Annals OR, 131(1-4), 283304.
Smyth, K., Hoos, H. H., & Stutzle, T. (2003). Iterated robust tabu search max-sat. Proc.
Canadian Conference AI-03, pp. 129144.
Taillard, E. D. (1994). Parallel taboo search techniques job shop scheduling problem.
INFORMS Journal Computing, 6(2), 108117.
Thornton, J., Pham, D. N., Bain, S., & Jr., V. F. (2004). Additive versus multiplicative clause
weighting SAT. Proc. AAAI-04, pp. 191196.
715

fiC AI , U , L UO & ATTAR

Tomita, E., & Kameda, T. (2009). efficient branch-and-bound algorithm finding maximum
clique computational experiments. J. Global Optimization, 44(2), 311.
Watson, J.-P., Whitley, L. D., & Howe, A. E. (2005). Linking search space structure, run-time
dynamics, problem difficulty: step toward demystifying tabu search. J. Artif. Intell.
Res. (JAIR), 24, 221261.
Wu, Q., Hao, J.-K., & Glover, F. (2012). Multi-neighborhood tabu search maximum weight
clique problem. Annals OR, 196(1), 611634.
Wu, Z., & Wah, B. W. (2000). efficient global-search strategy discrete lagrangian methods
solving hard satisfiability problems. Proc. AAAI/IAAI-00, pp. 310315.
Xu, K., Boussemart, F., Hemery, F., & Lecoutre, C. (2005). simple model generate hard
satisfiable instances. Proc. IJCAI-05, pp. 337342.
Xu, K., Boussemart, F., Hemery, F., & Lecoutre, C. (2007). Random constraint satisfaction: Easy
generation hard (satisfiable) instances. Artif. Intell., 171(8-9), 514534.
Xu, K., & Li, W. (2000). Exact phase transitions random constraint satisfaction problems. J.
Artif. Intell. Res. (JAIR), 12, 93103.
Xu, K., & Li, W. (2006). Many hard examples exact phase transitions. Theoretical Computer
Science, 355, 291302.
Yugami, N., Ohta, Y., & Hara, H. (1994). Improving repair-based constraint satisfaction methods
value propagation. AAAI, pp. 344349.
Zuckerman, D. (2006). Linear degree extractors inapproximability max clique
chromatic number. Proc. STOC-06, pp. 681690.

716


