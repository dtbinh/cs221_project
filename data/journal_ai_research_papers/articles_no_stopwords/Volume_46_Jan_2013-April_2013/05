journal artificial intelligence

submitted published

numvc efficient local search
minimum vertex cover
shaowei cai

shaoweicai cs gmail com

key laboratory high confidence software technologies
peking university beijing china

kaile su

k su griffith edu au

institute integrated intelligent systems
griffith university brisbane australia

chuan luo

chuanluosaber gmail com

key laboratory high confidence software technologies
peking university beijing china

abdul sattar

sattar griffith edu au

institute integrated intelligent systems
griffith university brisbane australia

abstract
minimum vertex cover mvc prominent np hard combinatorial
optimization great importance theory application local search proved
successful however two main drawbacks state art mvc local
search first select pair vertices exchange simultaneously timeconsuming secondly although edge weighting techniques diversify search
lack mechanisms decreasing weights address issues propose two
strategies two stage exchange edge weighting forgetting two stage exchange
strategy selects two vertices exchange separately performs exchange two stages
strategy edge weighting forgetting increases weights uncovered edges
decreases weights edge periodically two strategies used designing
mvc local search referred numvc
conduct extensive experimental studies standard benchmarks namely dimacs
bhoslib experiment comparing numvc state art heuristic
numvc least competitive nearest competitor namely pls
dimacs benchmark clearly dominates competitors bhoslib benchmark
experimental indicate numvc finds optimal solution much faster current
best exact maximum clique random instances well structured ones
moreover study effectiveness two strategies run time behaviour
experimental analysis

introduction
minimum vertex cover mvc consists given undirected graph g v e
finding minimum sized vertex cover vertex cover subset v every
edge g least one endpoint mvc important combinatorial optimization
many real world applications network security scheduling vlsi design industrial
machine assignment equivalent two well known combinatorial optimization
maximum independent set mis maximum clique mc
c

ai access foundation rights reserved

fic ai u l uo attar

wide range applications areas information retrieval experimental design signal
transmission computer vision bioinformatics aligning dna protein
sequences johnson trick indeed three seen three different
forms viewpoint practical mvc
directly used solve mis mc due great importance theory
applications three widely investigated last several decades
carraghan pardalos evans pullan hoos richter helmert gretton
cai su chen li quan b cai su sattar
theoretical analyses indicate three mvc mis mc computationally
hard np hard associated decision np complete garey
johnson moreover hard solve approximately np hard approximate
mvc within factor smaller dinur safra although one achieve
approximation ratio halperin karakostas besides inapproximability
mvc hastad shows mis mc approximable within v
unless np zpp hastad recently conclusion enhanced mc
approximable within v unless np p zuckerman derived
derandomization hastads moreover currently best polynomial time approximation
mc guaranteed clique within factor n loglogn logn
optimum feige
solve mvc mis mc fall two types exact heuristic
exact methods mainly include branch bound carraghan
pardalos fahle ostergard regin tomita kameda li
quan b guarantee optimality solutions may fail give
solution within reasonable time large instances heuristic mainly include local
search cannot guarantee optimality solutions optimal
satisfactory near optimal solutions large hard instances within reasonable time therefore
appealing use local search solve large hard mvc mc mis instances
early heuristic methods maximum clique designed initial responses
second dimacs implementation challenge johnson trick maximum clique
one three challenge huge amount effort devoted designing
local search mvc mc mis aggarwal orlin tai battiti
protasi busygin butenko pardalos shyu yin lin barbosa campos
pullan richter et al andrade resende werneck cai et al
review heuristic three found recent
mvc local search cai et al
work devoted efficient local search mvc typically local search
mvc solve iteratively solving k vertex cover solve
k vertex cover maintain current candidate solution size k exchange
two vertices iteratively becomes vertex cover however observe two drawbacks
state art mvc local search first select pair vertices exchanging
simultaneously according heuristic richter et al cai et al
rather time consuming explained section second drawback edge
weighting techniques basic concept edge weighting increase weights uncovered
zpp class solved expected polynomial time probabilistic zero
error probability



fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

edges diversify search previous mvc local search utilize different edge weighting
schemes example cover richter et al increases weights uncovered edges
step ewls cai et al ewcc cai et al increase weights uncovered
edges reaching local optima however mechanism
decrease weights believe deficient weighting decisions made long
ago may mislead search
address two issues mvc local search proposes two
strategies namely two stage exchange edge weighting forgetting two stage exchange
strategy decomposes exchanging procedure two stages e removing stage
adding stage performs separately first selects vertex removes current
candidate solution selects vertex random uncovered edge adds twostage exchange strategy yields efficient two pass move operator mvc local search
first pass linear time search vertex remove second pass lineartime search vertex add contrast standard quadratic move
operator moreover two stage exchange strategy renders flexible
employ different heuristics different stages indeed numvc utilizes
highly greedy heuristic removing stage adding stage makes good use
diversifying heuristic within framework similar focused random walk papadimitriou
second strategy propose edge weighting forgetting increases weights
uncovered edges one step moreover averaged edge weight achieves
threshold reduces weights edges multiplying constant factor forget
earlier weighting decisions best knowledge first time forgetting
mechanism introduced local search mvc
two strategies combined design local search called numvc
carry detailed experimental study investigate performance numvc compare
pls pullan cover richter et al ewcc cai et al
leading heuristic mvc mc mis experimental numvc
competes well solvers dimacs benchmark shows dramatic improvement
existing whole bhoslib benchmark parts work published
early version cai su sattar
additionally carry experimental analyses provides
insights two strategies numvc compare numvc exact
maxclqdyn efl scr li quan best exact maximum clique
found literature experimental indicate numvc finds optimal solution
much faster exact random instances well structured ones
importantly conduct experimental investigations study run time behaviour numvc
effectiveness two strategies numvc
remainder organized follows next section introduce
definitions notations used present two strategies two stage exchange
edge weighting forgetting section describe numvc section
presents experimental study numvc comparative including
heuristic exact followed detailed investigations run time
behaviour numvc effectiveness two strategies section finally
conclude summarizing main contributions future directions


fic ai u l uo attar

preliminaries
undirected graph g v e consists vertex set v edge set e v v
edge element subset v edge e u v say vertices u v
endpoints edge e two vertices neighbors belong common
edge denote n v u v u v e set neighbors vertex v
undirected graph g v e independent set subset v pairwise nonadjacent elements clique subset v pairwise adjacent elements maximum
independent set maximum clique maximum sized independent set
clique graph respectively
note three mvc mis mc seen three different forms
viewpoint experimental vertex set independent
set g v vertex cover g vertex set k clique g v k
vertex cover complementary graph g maximum independent set graph
g one minimum vertex cover cmin g return v cmin similarly

maximum clique graph g one minimum vertex cover cmin
complementary

graph g return v cmin

given undirected graph g v e candidate solution mvc subset vertices
edge e e covered candidate solution x least one endpoint e belongs
x search procedure numvc maintains current candidate solution
convenience rest use c denote current candidate solution state
vertex v denoted sv sv means v c sv means v
c
step neighboring candidate solution consists exchanging two vertices vertex u c
removed c vertex v
c put c age vertex number steps since
state last changed
state art mvc local search numvc utilizes edge weighting
scheme edge weighting local search follow definitions notations ewcc cai
et al edge weighted undirected graph undirected graph g v e combined
weighting function w edge e e associated non negative integer number
w e weight use w denote mean value edge weights
let w weighting function g candidate solution x set cost x
x

cost g x

w e

ee e covered x

indicates total weight edges uncovered x take cost g x evaluation
f unction numvc prefers candidate solutions lower costs
vertex v v
dscore v cost g c cost g c
c c v v c c c v otherwise measuring benefit changing
state vertex v obviously vertex v c dscore v greater dscore
indicates less loss covered edges removing c vertex v
c
dscore v higher dscore indicates greater increment covered edges adding
c


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

two stage exchange
section introduce two stage exchange strategy adopted numvc
exchange pair vertices
state art mvc local search numvc iterated k vertex
cover finding k vertex cover numvc removes one vertex current
candidate solution c goes search k vertex cover sense core
numvc k vertex cover given positive integer number k searching k sized
vertex cover k vertex cover numvc begins candidate solution c size k
exchanges two vertices iteratively c becomes vertex cover
local search mvc select pair vertices exchange simultaneously
according certain heuristic example cover selects pair vertices maximize
gain u v richter et al ewls cai et al ewcc cai et al select
random pair vertices score u v strategy selecting two vertices exchange
simultaneously leads quadratic neighborhood candidate solutions moreover evaluation
pair vertices depends evaluations dscore two vertices
involves relationship two vertices belong edge therefore
rather time consuming evaluate candidate pairs vertices
contrast earlier mvc local search numvc selects two vertices
exchanging separately exchanges two selected vertices two stages iteration
numvc first selects vertex u c highest dscore removes numvc
selects uniformly random uncovered edge e chooses one endpoint v e higher
dscore restrictions adds c note two stage exchange strategy
resembles respect min conflicts hill climbing heuristic csp minton johnston
philips laird shows surprisingly good performance n queens
selecting two vertices exchanging separately may cases miss greedier
vertex pairs consist two neighboring vertices however usual local search
trade accuracy heuristics complexity per step
let r denote set candidate vertices removing adding separately time
complexity per step selecting exchanging vertex pair simultaneously r
complexity per step selecting two vertices separately numvc r
worthy note heuristics local search often intuition
experience rather theoretically empirically derived principles insights cannot say
certain less greedy good thing hoos stutzle hand
lower time complexity desirable

edge weighting forgetting
section present edge weighting technique called edge weighting forgetting
plays important role numvc
proposed strategy edge weighting forgetting works follows edge
associated positive integer number weight edge weight initialized one
iteration edge weights uncovered edges increased one moreover
average weight achieves threshold edge weights reduced forget earlier weighting
decisions formula w e w e constant factor


fic ai u l uo attar

note edge weighting techniques mvc local search including one work
fall general penalty idea optimization dates back morris
breakout method morris widely used local search constraint
optimization sat yugami ohta hara wu wah schuurmans
southey holte hutter tompkins hoos therefore provide
evidence effectiveness general applicability algorithmic technique
edge weighting techniques successfully used improve mvc local search
example cover richter et al updates edge weights step
ewls cai et al ewcc cai et al update edge weights reaching local
optima however previous edge weighting techniques mechanism decrease
weights limits effectiveness strategy edge weighting forgetting
work introduces forgetting mechanism reduce edge weights periodically contributes
considerably numvc
intuition behind forgetting mechanism weighting decisions made long ago
longer helpful may mislead search hence considered less important
recent ones example consider two edges e e w e w e
step use w e denote increase w e according evaluation
function next period time likely cover e frequently e
may assume period w e w e makes w e
w e without forgetting mechanism
would still prefer e e covered future search reasonable
period e covered much fewer steps e thus e take priority covered
sake diversification let us consider case forgetting mechanism assuming
setting experiments suppose w e w e
performs forgetting forgetting mechanism reduces edge weights
w e w e period time w e
w e w e w e case
prefers cover e rather cover e future search expect
although inspired smoothing techniques clause weighting local search
sat forgetting mechanism numvc differs smoothing techniques sat
local search according way clause weights smoothed three
main smoothing techniques clause weighting local search sat best
knowledge first pull clause weights mean value formula wi
wi w esg schuurmans et al saps hutter et al swcca
cai su second subtract one clause weights greater
one dlm wu wah paws thornton pham bain jr last
employed ddwf ishtaiwi thornton sattar pham transfers weights
neighbouring satisfied clauses unsatisfied ones obvious forgetting mechanism
numvc different smoothing techniques
recently forgetting mechanism proposed vertex weighting technique significant
mc local search dls mc pullan hoos important sub
pls pullan cls pullan mascia brunato dls mc employs
vertex weighting scheme increases weights vertices one current clique
reaching local optimum periodically decreases weights one vertices
currently penalty specifically utilizes parameter pd penalty delay specify


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

number penalty increase iterations must occur performs forgetting
operation however pullan hoos observed dls mc sensitive pd
parameter optimal value pd varies considerably among different instances indeed
performance dls mc given optimizing pd parameter contrast forgetting
mechanism numvc much less sensitive parameters shown section
thus robust
notice formula used forgetting mechanism numvc adopted
long term frequency learning mechanisms tabu search taillard however
taillars parameter term work greater one
formula used penalizing move rather forgetting penalties

numvc
section present numvc utilizes strategies two stage
exchange edge weighting forgetting
numvc
























numvc g cutoff
input graph g v e cutoff time
output vertex cover g
begin
initialize edge weights dscores vertices
initialize confchange array array
construct c greedily vertex cover
c c
elapsed time cutoff
uncovered edge
c c
remove vertex highest dscore c
continue
choose vertex u c highest dscore breaking ties favor oldest
one
c c u confchange u confchange z z n u
choose uncovered edge e randomly
choose vertex v e confchange v higher dscore breaking ties
favor older one
c c v confchange z z n v
w e w e uncovered edge e
w w e w e edge e
return c
end

better understanding first describe strategy called configuration checking
cc used numvc cc strategy cai et al proposed handling


fic ai u l uo attar

cycling local search e revisiting candidate solution visited recently
michiels aarts korst strategy successfully applied local search
mvc cai et al well sat cai su
cc strategy numvc works follows vertex v
c neighboring vertices
never change states since last time v removed c v added
back c cc strategy seen prohibition mechanism shares spirit
differs well known prohibition mechanism called tabu glover
implementation cc strategy maintain boolean array confchange vertices
search procedure vertices confchange value forbidden
add c confchange array initialized array vertex v
removed c confchange v reset vertex v changes state
z n v confchange z set
outline numvc described beginning edge
weights initialized dscores vertices computed accordingly confchange v
initialized vertex v current candidate solution c constructed iteratively
adding vertex highest dscore ties broken randomly becomes vertex
cover finally best solution c initialized c
initialization loop lines executed given cutoff time reached
search procedure uncovered edge means c vertex cover
numvc updates best solution c c line removes one vertex highest
dscore c line breaking ties randomly go search vertex cover
size c c note c vertex highest dscore minimum
absolute value dscore since dscores negative
iteration loop numvc swaps two vertices according strategy two stage
exchange lines specifically first selects vertex u c highest dscore
remove breaking ties favor oldest one removing u numvc chooses uncovered
edge e uniformly random selects one es endpoints add c follows
one endpoint whose confchange vertex selected confchange values
endpoints numvc selects vertex higher dscore breaking ties
favor older one exchange finished adding selected vertex c along
exchanging two selected vertices confchange array updated accordingly
end iteration numvc updates edge weights lines first weights
uncovered edges increased one moreover numvc utilizes forgetting mechanism
decrease weights periodically detail averaged weight edges achieves threshold
edge weights multiplied constant factor rounded
integer edge weights defined integers numvc forgetting mechanism forgets
earlier weighting decision extent past effects generally longer helpful
may mislead search
conclude section following observation guarantees executability
line
proposition uncovered edge e least one endpoint v edge e
confchange v
proof let us consider arbitrary uncovered edge e v v proof includes two cases
least one v v never changes state initialization without


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

loss generality assume v vertex initialization confchange v set
removing v c corresponds vs state sv changing
make confchange v v never changes state initialization
confchange v
b v v change states initialization e uncovered v
c
v
c without loss generality assume last removing v happens last
removing v last time v removed v c holds afterwards v removed
means v changes state confchange v set v n v

empirical
section present detailed experimental study evaluate performance numvc
standard benchmarks literature e dimacs bhoslib benchmarks first
introduce dimacs bhoslib benchmarks describe preliminaries
experiments divide experiments three parts purpose first part
demonstrate performance numvc detail second compare numvc state ofthe art heuristic finally last part compare numvc state art exact

benchmarks
good set benchmarks fundamental demonstrate effectiveness solvers
use two standard benchmarks mvc mis mc dimacs benchmark
bhoslib benchmark dimacs benchmark includes instances industry
generated bhoslib instances random ones high difficulty
dimacs b enchmark
dimacs benchmark taken second dimacs implementation challenge
maximum clique thirty seven graphs selected organizers
summary indicate effectiveness comprising second dimacs challenge
test instances generated real world coding theory
fault diagnosis kellers conjecture steiner triple etc random graphs
brock p hat families instances range size less
vertices edges greater vertices edges although
proposed two decades ago dimacs benchmark remains popular benchmark
widely used evaluating heuristic mvc richter et al pullan
cai et al gajurel bielefeld mis andrade et al pullan mc
pullan katayama sadamatsu narihisa grosso locatelli pullan
pullan et al wu hao glover particular dimacs benchmark
used evaluating cover ewcc convenient us use benchmark
conduct experiments comparing numvc cover ewcc note dimacs
graphs originally designed maximum clique mvc tested
complementary graphs
ftp dimacs rutgers edu pub challenges



fic ai u l uo attar

bhoslib b enchmark
bhoslib benchmarks hidden optimum solutions instances generated randomly
phase transition area according model rb xu boussemart hemery lecoutre
generally phase transition instances generated model rb proved
hard theoretically xu li practically xu li xu boussemart
hemery lecoutre sat version bhoslib benchmark extensively used
sat competitions nevertheless sat solvers much weaker mvc solvers
remains justifiable referring sat competition
benchmark bhoslib benchmark famous hardness influential enough
strongly recommended mvc mc mis community grosso et al cai et al
widely used recent literature reference point local search solvers
mvc mc mis besides instances large instance frb
vertices edges designed challenging mvc mc mis
bhoslib benchmark designed mc mvc mis graphs
benchmark expressed two formats e clq format mis format bhoslib
instance graph clq format one mis format complementary mc
tested graphs clq format mvc mis tested
mis format
experiment preliminaries
discuss experimental let us introduce preliminary information
experiments
numvc implemented c codes numvc ewcc publicly available
first authors homepage codes cover downloaded online pls
kindly provided authors four solvers compiled g option
experiments carried machine ghz intel core duo cpu e gb
ram linux execute dimacs machine benchmarks machine requires
cpu seconds r cpu seconds r cpu seconds r
numvc set v runs except challenging instance
frb note parameters state ofthe art mvc mc mis dls mc pullan hoos ewls cai et al
moreover parameters dls mc ewls vary considerably different instances
instance performed independent runs different random seeds
run terminated upon reaching given cutoff time cutoff time set
seconds instances except challenging instance frb cutoff
time set seconds due significant hardness
numvc report following information instance
optimal minimum known vertex cover size v c







http www nlsde buaa edu cn kexu benchmarks graph benchmarks htm
http www satcompetition org
http www nlsde buaa edu cn kexu benchmarks list graph papers htm
http www shaoweicai net html
http www informatik uni freiburg de srichter
ftp dimacs rutgers edu pub dsj clique



fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

number successful runs suc run said successful solution size v c
found
vc size shows min average max vertex cover size found numvc
runs
averaged run time runs time run time successful run
time v c solution failed run considered cutoff time
instances numvc achieve success rate report averaged
run time successful runs suc time run time measured cpu seconds
inter quartile range iqr run time runs iqr difference
th percentile th percentile sample iqr one famous robust
measures data analysis hoaglin mosteller tukey recommended
measurement closeness sampling distribution community experimental
bartz beielstein chiarandini paquete preuss
number steps averaged runs steps steps successful run
needed v c solution steps failed run executed
running cut instances numvc achieve success
rate report averaged steps successful runs suc steps
successful runs instance time steps columns marked
n success rate solver instance less th percentile
run time sample cutoff time represent real th percentile case
report iqr instead mark n corresponding column actually
success rate solver certain instance less solver considered
robust instance given cutoff time
performance numvc
section report detailed performance numvc two benchmarks
p erformance n u mvc



dimacs b enchmark

performance numvc dimacs benchmark displayed table numvc
finds optimal best known solutions dimacs instances note failed
instances brock graphs furthermore among successful instances numvc
consistently e runs instances solved within second
overall numvc exhibits excellent performance dimacs benchmark except
brock graphs remark brock graphs artificially designed defeat greedy
heuristics explicitly incorporating low degree vertices optimal vertex cover indeed
preferring higher degree vertices grasp rls k opt cover ewcc
failed graphs
p erformance n u mvc



bhoslib b enchmark

table illustrate performance numvc bhoslib benchmark numvc
successfully solves bhoslib instances terms finding optimal solution size


fic ai u l uo attar

graph
instance vertices
brock
brock
brock
brock
brock
brock
c
c
c
c
c
c
c
dsjc
dsjc
gen p
gen p
gen p
gen p
gen p
hamming
hamming
keller
keller
keller
mann
mann
mann
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat







































v c

suc

vc size




















































































































numvc
time suc time




n
n






































steps suc steps




n
n
































table numvc performance averaged independent runs dimacs
benchmark instances vc column marked asterisk means minimum
known vertex cover size proved optimal



fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

worst solution finds never exceeds v c numvc finds optimal solutions
success rate instances averaged success rate remaining
instances dramatically better existing literature
benchmark numvc finds sub optimal solution size v c bshoslib
instances quickly less seconds indicates numvc used
approximate mvc efficiently even limited time
besides bhoslib instances table challenging instance frb
hidden minimum vertex cover size designer bhoslib benchmark
conjectured instance solved pc less day within next two
decades latest record challenging instance sized vertex cover found
ewls ewcc
run numvc independent trials within seconds frb
parameter setting yields best performance among combinations
among runs runs sized
solution averaged time seconds runs sized solution including
sized averaged time seconds interesting note numvc
locate rather good approximate solution hard instance quickly size vertex
covers numvc finds within seconds
generally finding k vertex cover much easier k vertex cover hence
numvc well mvc local search solve mvc
solving k vertex cover iteratively majority running time used finding
best vertex cover c run trying without success vertex cover size
c
comparison heuristic
recent literature five leading heuristic mvc mc mis including
three mvc cover richter et al ewls cai et al ewcc cai
et al two mc dls mc pullan hoos pls pullan
note ewcc pls improved versions ewls dls mc respectively
better performance original versions dimacs bhoslib benchmarks therefore
compare numvc pls cover ewcc
comparing numvc heuristic report v c suc time well
iqr averaged run time successful runs suc time cannot indicate comparative
performance correctly unless evaluated close success rates
f suc
calculated time cutof
report statistics
suc
bold indicate best performance instance
c omparative r esults



dimacs b enchmark

comparative dimacs benchmark shown table dimacs instances
easy solved solvers success rate within seconds thus
reported table actually fact dimacs benchmark reduced
useful instances really emphasizes need make benchmark
http www nlsde buaa edu cn kexu benchmarks graph benchmarks htm



fic ai u l uo attar

graph
instance vertices
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb










































v c









































suc

vc size

numvc
time suc time

steps suc steps





































































































































































table numvc performance averaged independent runs bhoslib
benchmark instances bhoslib instances hidden optimal vertex cover
whose size shown vc column

indicated table numvc outperforms cover ewcc instances
competitive complementary pls eight hard instances least one
solver fails achieve success rate pls dominates brock graphs numvc
dominates others including two putatively hardest instances c mann
richter et al grosso et al cai et al well keller mann


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

graph
instance

v c

suc

pls
time iqr

suc

brock
brock
brock
brock
c
c
gen p
keller
mann
mann
p hat





























n



n
n














cover
time iqr
n

n
n
n




n


suc

ewcc
time iqr

suc

numvc
time iqr













n

n
n
n




n
















n
n
n




n


table comparison numvc state art heuristic dimacs
benchmark vc column marked asterisk means minimum known
vertex cover size proved optimal

c numvc finds sized solution finds sized solution
runs number pls cover ewcc respectively note
pls performs well brock family comprises three sub one
favors lower degree vertices
table indicates c mann remain difficult modern
none solve good success rate reasonable time
hand instances solved quickly less seconds least one pls
numvc low iqr value less indicates quite stable performance
c omparative r esults



bhoslib b enchmark

table present comparative bhoslib benchmark concentrating
considerable gaps comparisons report two groups small instances
frb frb solved within several seconds solvers
table illustrate numvc significantly outperforms
bhoslib instances terms success rate averaged run time
demonstrated figure take look comparison numvc ewcc
ewcc performs obviously better pls cover benchmark numvc solves
instances success rate instances ewcc instances
solved success rate overall averaged run time seconds
numvc seconds ewcc instances averaged success rate
numvc compared ewcc
excellent performance numvc underlined large gaps numvc
solvers hard instances example instances solvers fail
optimal solution success rate numvc achieves overall averaged success
rate dramatically better pls cover ewcc
respectively obviously experimental numvc delivers


fic ai u l uo attar

graph
instance

v c

suc

pls
time iqr

suc

frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb






































































n



n
n


n
n
n
n
n
n
n
n
n
n
n
n
n
n

































cover
time iqr











n
n


n
n

n

n
n



n
n
n
n


suc

ewcc
time iqr

suc












































n


n




n
n



n
n
n
n

































numvc
time iqr


























n




table comparison numvc state art local search
bhoslib benchmark bhoslib instances hidden optimal vertex cover
whose size shown vc column



fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c
















average run time

average success rate

best performance hard random benchmark vastly improving existing performance
observe numvc minimum iqr value instances
indicates apart efficiency robustness numvc better solvers











pls
cover
ewcc
numvc






frb

pls
cover
ewcc
numvc


frb


frb

frb frb frb frb
number vertices graph

frb

frb frb frb frb
number vertices graph

figure comparison numvc local search bhoslib benchmark
terms success rate left averaged run time right
compare numvc cover ewcc challenging instance frb
given failure pls large bhoslib instances run pls instance
comparative frb shown table indicates numvc
significantly outperforms cover ewcc challenging instance
finally would remark performance numvc bhoslib benchmark
better four core version cls pullan et al even divide run time
numvc number cores utilized cls consider machine speed ratio
divide run time numvc numvc would dramatically better cls
bhoslib benchmark
size
vc



suc



cover
avg suc time
n


suc



ewcc
avg suc time



suc



numvc
avg suc time



table comparative frb challenging instance solver executed
times instance timeout seconds

comparison exact
section compare numvc state art exact maximum clique
generally exact heuristic somewhat complementary
applications usually exact solutions structured instances faster heuristic
faster random ones


fic ai u l uo attar

compared mvc mis many exact designed maximum clique
carraghan pardalos fahle ostergard regin tomita
kameda li quan b recent branch bound mc maxclq
li quan b utilizes maxsat inference technologies li manya planes
improve upper bounds shows considerable progress experimental maxclq li
quan b random graphs dimacs instances indicate maxclq significantly
outperforms previous exact mc maxclq improved two
strategies called extended failed literal detection soft clause relaxation resulting better
denoted maxclqdyn efl scr li quan due great success
maxclqdyn efl scr compare maxclqdyn efl scr
compare numvc maxclqdyn efl scr dimacs benchmark instances
maxclqdyn efl scr taken previous work li quan
maxclqdyn efl scr evaluated bhoslib benchmark much harder
requires effective technologies exact li quan
run time maxclqdyn efl scr obtained ghz intel core duo
cpu linux gb memory required seconds r seconds
r seconds r execute dimacs machine benchmarks li quan
corresponding run time machine seconds multiply
reported run time maxclqdyn efl scr
average two largest ratios normalization methodology established
second dimacs implementation challenge cliques coloring satisfiability
widely used comparing different maxclique pullan hoos pullan li
quan b
graph
instance
brock
brock
brock
brock
brock
brock
keller
mann
mann

v c











numvc
suc
time













n
n
n




maxclqdyn efl
scr time










graph
instance

v c

numvc
suc
time

p hat
p hat
p hat
p hat
p hat
p hat
p hat
sanr
sanr































maxclqdyn efl
scr time










table comparison numvc state art exact maxclique maxclqdyn efl scr dimacs benchmark

table present performance numvc maxclqdyn efl scr
dimacs instances indicate numvc finds optimal solution much faster
maxclqdyn efl scr random instances p hat sanr instances
believe similar would hold hard random benchmarks bhoslib ones
maxclqdyn efl scr evaluated instances due high hardness li quan
numvc performs well
structured instances note maxclqdyn efl scr mainly evaluated
brock instances numvc performs worst open dimacs instances


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

mann johnson keller remain difficult solve exact
li quan although maxclqdyn efl scr overall performs better
numvc finds optimal solution significantly faster maxclqdyn efl scr
structured instances two brock instances keller
finally would note although heuristic solvers optimal solutions fast
unable prove optimality solutions hand run time
exact spent finding optimal solution proving optimality
sense heuristic exact cannot compared fair way nevertheless
experiments suggest heuristic approaches appealing solving large instances reasonable
short time

discussions
section first explore run time distribution numvc representative
instances investigate effectiveness two stage exchange strategy
forgetting mechanism numvc finally analyze performance numvc different
settings two parameters forgetting mechanism shows numvc
sensitive parameters
run time distributions numvc
subsection conduct empirical study gain deeper insights run time behavior
numvc specifically study run time distribution numvc several representative
instances purpose comparison report run time distribution ewcc
best competing mvc local search solver
consider randomized solving given optimization instance halting
soon optimal solution found run time viewed
random variable fully described distribution commonly referred run time
distribution rtd literature performance modeling hoos stutzle
bartz beielstein et al methodology studying run time behavior
rtds widely used empirical analysis heuristic hoos stutzle
finkelstein markovitch rivlin watson whitley howe pullan hoos
follow methodology study
studying typical run time behaviour choose instances numvc reaches optimal
solution runs appropriate difficulty dimacs benchmark select
brock mann reasonable size hardness two
instances represent two typical instance classes numvc numvc poor performance
brock instances dominates heuristic mann instances
bhoslib benchmark frb frb selected appropriate
instances studying run time behavior numvc since neither easy
solved short time difficult reach success rate
empirical rtd graphs numvc ewcc shown figure rtd
instance independent runs reach respective optimal solution according
graphs numvc shows large variability run time investigation indicates
rtds quite well approximated exponential distributions labeled ed x x
median distribution test goodness approximations use


fic ai u l uo attar

empirical rtd numvc ewcc mann

empirical rtd numvc ewcc brock








rtd numvc
ed
rtd ewcc
ed




p solve

p solve






































runtime cpu sec











empirical rtd numvc ewcc frb






rtd numvc
ed
rtd ewcc
ed














rtd numvc
ed
rtd ewcc
ed


p solve

p solve





runtime cpu sec
































empirical rtd numvc ewcc frb




rtd numvc
ed
rtd ewcc
ed








runtime cpu sec




















runtime cpu sec









figure run time distributions rtds numvc ewcc applied two dimacs instances
top two bhoslib instances bottom empirical rtds well approximated
exponential distributions labeled ed x x plots

kolmogorov smirnov test fails reject null hypothesis sampled run time
stems exponential distributions shown figures standard confidence level
p values ewcc kolmogorov smirnov test
shows rtds mann two bhoslib instances exponential distributions
rtd brock exponential distribution
observation exponential rtds numvc consistent similar
high performance sls e g maxclique pullan hoos sat hoos
stutzle maxsat smyth hoos stutzle scheduling watson
et al arguments hoos stutzle hoos stutzle made stochastic
local search characterized exponential rtd conclude numvc
probability finding optimal solution within fixed amount time steps depend
run time past consequently robust w r cutoff time thus restart


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

time therefore performing multiple independent runs numvc parallel closeto optimal parallelization speedup similar observations made dimacs
instances bhoslib instances
practical interest rtd analysis numvc difficult instances
experiments fail achieve high success rate e rtds
cases would stagnates suggest posteriori restart time
purpose select mann frb analysis rtds
numvc two instances illustrated figure interestingly rtds
observe obvious stagnation confirms numvc robust w r cutoff time
thus restart time therefore increasing cutoff time expect higher success
rate difficult instances
empirical rtd numvc mann frb


rtd numvc mann

rtd numvc frb


p solve























runtime cpu sec

figure run time distributions rtds numvc mann frb instances
numvc finds optimal best known solution less half runs

effectiveness two stage exchange
study effectiveness two stage exchange strategy compare numvc
alternative numvc selects two vertices exchanging simultaneously
step numvc first chooses uncovered edge e uniformly random evaluates pair
vertices u v u current candidate solution v one endpoint e
conf change v evaluating benefit e decrement cost function
exchanging vertex pair u v numvc first checks whether neighbors u
v neighbors benefit dscore u dscore v w e u v otherwise benefit
dscore u dscore v numvc selects vertex pair greatest benefit exchange
numvc numvc two candidate vertices add
current candidate solution c e endpoints selected uncovered edge hence
worst case numvc performs c evaluations numvc evaluate c
pairs vertices moreover numvc needs check dscore vertex vertex


fic ai u l uo attar

evaluation numvc performs vertex pair evaluation involves pair vertices
relationship thus time consuming analysis conjecture
complexity per step numvc least times lower numvc
mentioned section two stage exchange strategy less greedy one selecting
two vertices exchanging simultaneously numvc
investigation carried dimacs instances different families well
bhoslib instances dimacs benchmark select brock c
mann p hat instances different characteristics described
pullan et al note following conclusions dimacs instances
complementary dimacs graphs
dimacs brock instances minimum vertex covers consist medium lower
degree vertices designed defeat greedy heuristics
dimacs c p hat instances minimum vertex covers consist
higher degree vertices effectively solved greedy heuristics
dimacs mann instances large proportion plateaus instance searchspace thus greedy heuristics unsuitable solve
bhoslib instances minimum vertex covers consisting vertices whose
distribution vertex degree closely matches complete graph difficult
instances greedy diversification heuristics
graph
instance
brock
c
mann
p hat
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb
frb

v c

















suc

















time

















numvc
steps

















steps sec

















suc

















time

















numvc
steps

















steps sec

















table comparative performance numvc numvc selects two vertices
exchanging simultaneously independent runs solver
instance
comparative numvc numvc presented table
numvc significantly outperforms numvc terms averaged run time primarily due
much lower complexity per step second numvc performs times steps


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

numvc supports conjecture complexity per step numvc
times lower numvc
turn attention comparing numvc numvc terms step performance
independent complexity per step brock mann graphs difficult
greedy heuristics numvc significantly better step performance numvc
hand greedy friendly graphs c p hat numvc needs
steps converge optimal solution numvc observations support
argument two stage exchange strategy less greedy one selects two vertices
exchanging simultaneously numvc
observe step performance numvc better numvc
bhoslib instances instance bhoslib instances
success rate numvc needs times steps numvc optimal
solution expect cannot yet explain nevertheless numvc makes
rather rapid modifications solution little degrade step performance hurt
graph
instance
c
mann
p hat
frb
frb
frb

pls
steps sec







cover
steps sec







ewcc
steps sec







numvc
steps sec







table complexity per step selected instances
demonstrate low complexity per step numvc compare number
search steps per second numvc state art heuristic solvers
representative instances indicated table numvc executes many steps second
two mvc local search solvers cover ewcc instances table
second numvc executes times steps cover times steps
ewcc indicates two stage exchange strategy significantly accelerate mvc
local search although pls performs steps per second numvc mc
local search whose search scheme essentially different mvc local search

effectiveness forgetting mechanism
study effectiveness forgetting mechanism numvc compare numvc
two alternative numvc numvc obtained numvc modifying
edge weighting scheme
numvc works way numvc except forgetting mechanism
deleting line
numvc adopts forgetting mechanism used dls mc pullan hoos
weighting scheme specifically numvc increases weights uncovered edges


fic ai u l uo attar

one end step performs forgetting operation every pd steps decreasing
weights one edges whose weights greater one note pd instancedependent parameter
experiments carried representative instances benchmarks
dimacs benchmark select brock c keller mann
different classes appropriate difficulty bhoslib benchmark
select three instances three largest sized instance groups respectively
graph
instance vertices
brock

c

keller

mann

frb

frb

frb

frb

frb

frb

frb

frb

frb


c

v














numvc
suc time

























numvc
suc time





















numvc
pd suc time































table comparative performance numvc two alternatives numvc numvc
performed times instance

apparent observation table two forgetting mechanisms
e numvc numvc outperform numvc almost instances particularly due
missing forgetting mechanism numvc performs significantly worse two
brock mann graphs hand table demonstrates numvc
numvc exhibit competitive performance bhoslib benchmark dominate different
types dimacs instances specifically numvc outperforms numvc c
keller mann performs significantly worse numvc brock
order genuine performance numvc brock instances test numvc
larger brock brock instances two large brock
instances substantially difficult two brock instances numvc fails
solve neither
although numvc shows competitive performance numvc performance given
optimizing pd parameter instance moreover dls mc pullan hoos
numvc considerably sensitive pd parameter example experiments
frb instances numvc performs quite well pd fails
optimal solution pd set value less comparatively numvc


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

parameter setting performs quite well types instances brock family actually
next section numvc sensitive parameters
interesting compare numvc alternatives replace forgetting
mechanism smoothing techniques similar local search sat indeed earlier
versions numvc use smoothing techniques similar sat local search
good performance compared numvc would interesting
reasons success forgetting mechanism failure smoothing techniques
mvc edge weighting local search numvc
parameters forgetting mechanism

v
v
v
v
v

brock






mann






c






frb






frb






frb






frb






v
v
v
v
v











































v
v
v
v
v











































v
v
v
v
v











































v
v
v
v
v











































table comparative performance numvc parameter combinations
forgetting mechanism instance numvc performed times
parameter combination except one adopted work v
runs keller numvc performs almost
parameters success rate tiny difference averaged
run time less second thus reported table



fic ai u l uo attar

numvc two parameters specify forgetting mechanism
specifically averaged weight edges achieves threshold edge weights
multiplied constant factor subsection investigate numvc
performs different settings two parameters investigation carried
dimacs bhoslib benchmarks dimacs benchmark select four instances
used preceding subsection reasons bhoslib benchmark select
frb frb frb frb different sizes
appropriate hardness
table presents performance numvc parameter combinations
representative instances see table parameter combination
v yields relatively good performance instances exhibits better robustness
instances parameter combinations
hand observe numvc parameter combinations performs
comparably tested instances example parameter settings numvc achieves
success rate keller mann c well frb
averaged run time difference instances significant instances
difference success rate never exceeds two parameter settings observation
indicates numvc seems sensitive two parameters actually mentioned
numvc exhibits good performance dimacs bhoslib benchmarks
fixed parameter setting advantage compared forgetting mechanisms
one used dls mc pullan hoos sensitive parameter
sensitive parameters considerable parameter tuning required order
get good performance certain instance usually costs much time solving
instance

conclusions future work
presented two local search strategies minimum vertex cover mvc
namely two stage exchange edge weighting forgetting two stage exchange
strategy yields efficient two pass move operator mvc local search
significantly reduces time complexity per step forgetting mechanism enhances
edge weighting scheme decreasing weights averaged weight reaches threshold
periodically forget earlier weighting decisions two strategies designed
slight yet effective mvc local search called numvc numvc
evaluated best known heuristic mvc mc mis standard benchmarks
e dimacs bhoslib benchmarks experimental numvc
largely competitive dimacs benchmark dramatically outperforms state art
heuristic bhoslib instances
furthermore showed numvc characterized exponential rtds means
robust w r cutoff parameters restart time hence close optimal parallelization
speedup performed investigations provide insights two
strategies effectiveness finally conducted experiment study performance
numvc different parameter settings indicate numvc sensitive
parameters


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

two stage exchange strategy lower time complexity per step
flexibility allow us employ specific heuristics different stages interesting
direction thus apply idea combinatorial whose essential tasks
seek optimal subset fixed cardinality

acknowledgments
work supported program cb arc future fellowship ft
national natural science foundation china
fundamental funds central universities china would
thank editor anonymous reviewers valuable comments earlier versions
would thank yanyan xu proofreading

references
aggarwal c orlin j tai r optimized crossover independent set
operations
andrade v resende g c werneck r f f fast local search maximum
independent set workshop experimental pp
barbosa v c campos l c novel evolutionary formulation maximum
independent set j comb optim
bartz beielstein chiarandini paquete l preuss eds experimental
methods analysis optimization springer berlin heidelberg
york
battiti r protasi reactive local search maximum clique
algorithmica
busygin butenko pardalos p heuristic maximum independent set
optimization quadratic sphere j comb optim
cai su k local search configuration checking sat proc ictai
pp
cai su k configuration checking aspiration local search sat proc
aaai pp
cai su k chen q ewls local search minimum vertex cover proc
aaai pp
cai su k sattar local search edge weighting configuration checking
heuristics minimum vertex cover artif intell
cai su k sattar two local search strategies minimum vertex cover
proc aaai pp
carraghan r pardalos p exact maximum clique
operations letters


fic ai u l uo attar

dinur safra hardness approximating minimum vertex cover annals
mathematics
evans evolutionary heuristic minimum vertex cover proceedings
seventh international conference evolutionary programming ep pp
fahle simple fast improving branch bound maximum clique
proc european symposium esa pp
feige u approximating maximum clique removing subgraphs siam j discrete math

finkelstein l markovitch rivlin e optimal schedules parallelizing anytime
case shared resources j artif intell res jair
gajurel bielefeld r fast near optimal vertex cover novca
international journal experimental ijea
garey johnson computers intractability guide theory npcompleteness freeman san francisco ca usa
glover f tabu search part orsa journal computing
grosso locatelli pullan w j simple ingredients leading efficient
heuristics maximum clique j heuristics
halperin e improved approximation vertex cover graphs
hypergraphs siam journal computing
hastad j clique hard approximate within n acta math
hastad j optimal inapproximability j acm
hoaglin c mosteller f tukey j w eds understanding robust exploratory
data analysis wiley classics library wiley york ny
hoos h stutzle stochastic local search foundations applications morgan
kaufmann san francisco ca usa
hoos h h stutzle towards characterisation behaviour stochastic local
search sat artif intell
hutter f tompkins hoos h h scaling probabilistic smoothing efficient
dynamic local search sat proc cp pp
ishtaiwi thornton j sattar pham n neighbourhood clause weight
redistribution local search sat proc cp pp
johnson trick eds cliques coloring satisfiability second dimacs
implementation challenge vol dimacs series discrete mathematics
theoretical computer science american mathematical society providence ri usa
karakostas g better approximation ratio vertex cover proc
icalp pp
katayama k sadamatsu narihisa h iterated k opt local search maximum
clique proc evocop pp


fin u mvc n e fficient l ocal earch lgorithm inimum v ertex c

li c manya f planes j inference rules max sat j artif intell res
jair
li c quan z combining graph structure exploitation propositional reasoning
maximum clique proc ictai pp
li c quan z b efficient branch bound maxsat
maximum clique proc aaai pp
michiels w aarts e h l korst j h theoretical aspects local search springer
minton johnston philips b laird p minimizing conflicts heuristic
repair method constraint satisfaction scheduling artif intell

morris p breakout method escaping local minima proc aaai pp

ostergard p r j fast maximum clique discrete applied
mathematics
papadimitriou c h selecting satisfying truth assignment proc focs pp

pullan w phased local search maximum clique j comb optim

pullan w optimisation unweighted weighted maximum independent sets minimum
vertex covers discrete optimization
pullan w hoos h h dynamic local search maximum clique j artif
intell res jair
pullan w mascia f brunato cooperating local search maximum clique
j heuristics
regin j c constraint programming solve maximum clique proc
cp pp
richter helmert gretton c stochastic local search vertex cover
proc ki pp
schuurmans southey f holte r c exponentiated subgradient
heuristic boolean programming proc ijcai pp
shyu j yin p lin b ant colony optimization minimum
weight vertex cover annals
smyth k hoos h h stutzle iterated robust tabu search max sat proc
canadian conference ai pp
taillard e parallel taboo search techniques job shop scheduling
informs journal computing
thornton j pham n bain jr v f additive versus multiplicative clause
weighting sat proc aaai pp


fic ai u l uo attar

tomita e kameda efficient branch bound finding maximum
clique computational experiments j global optimization
watson j p whitley l howe e linking search space structure run time
dynamics difficulty step toward demystifying tabu search j artif intell
res jair
wu q hao j k glover f multi neighborhood tabu search maximum weight
clique annals
wu z wah b w efficient global search strategy discrete lagrangian methods
solving hard satisfiability proc aaai iaai pp
xu k boussemart f hemery f lecoutre c simple model generate hard
satisfiable instances proc ijcai pp
xu k boussemart f hemery f lecoutre c random constraint satisfaction easy
generation hard satisfiable instances artif intell
xu k li w exact phase transitions random constraint satisfaction j
artif intell res jair
xu k li w many hard examples exact phase transitions theoretical computer
science
yugami n ohta hara h improving repair constraint satisfaction methods
value propagation aaai pp
zuckerman linear degree extractors inapproximability max clique
chromatic number proc stoc pp




