Journal Artificial Intelligence Research 46 (2013) 651686

Submitted 10/12; published 04/13

Description Logic Knowledge Action Bases
Babak Bagheri Hariri
Diego Calvanese
Marco Montali

BAGHERI @ INF. UNIBZ .
CALVANESE @ INF. UNIBZ .
MONTALI @ INF. UNIBZ .

KRDB Research Centre Knowledge Data
Free University Bozen-Bolzano
Piazza Domenicani 3, 39100 Bolzano, Italy

Giuseppe De Giacomo
Riccardo De Masellis
Paolo Felli

DEGIACOMO @ DIS . UNIROMA 1.
DEMASELLIS @ DIS . UNIROMA 1.
FELLI @ DIS . UNIROMA 1.

Dipartimento di Ingegneria Informatica Automatica e Gestionale
Sapienza Universita di Roma
Via Ariosto 25, 00185 Roma, Italy

Abstract
Description logic Knowledge Action Bases (KAB) mechanism providing
semantically rich representation information domain interest terms description logic knowledge base actions change information time, possibly introducing
new objects. resort variant DL-Lite unique name assumption enforced
equality objects may asserted inferred. Actions specified sets
conditional effects, conditions based epistemic queries knowledge base
(TBox ABox), effects expressed terms new ABoxes. setting, address
verification temporal properties expressed variant first-order -calculus quantification across states. Notably, show decidability verification, suitable restriction inspired
notion weak acyclicity data exchange.

1. Introduction
Recent work business processes, services databases bringing forward need considering data processes first-class citizens process service design (Nigam & Caswell,
2003; Bhattacharya, Gerede, Hull, Liu, & Su, 2007; Deutsch, Hull, Patrizi, & Vianu, 2009; Vianu,
2009; Meyer, Smirnov, & Weske, 2011). particular, so-called artifact-centric approaches,
advocate sort middle ground conceptual formalization dynamic systems
actual implementation, promising effective practice (Cohn & Hull, 2009).
verification temporal properties presence data represents significant research challenge (for survey, see Calvanese, De Giacomo, & Montali, 2013), since taking account
data evolve time results systems infinite number states. Neither finite-state
model checking (Clarke, Grumberg, & Peled, 1999) current techniques infinitestate model checking, mostly tackle recursion (Burkart, Caucal, Moller, & Steffen, 2001),
apply case. Recently, advancements issue (Cangialosi, De Giacomo, De Masellis, & Rosati, 2010; Damaggio, Deutsch, & Vianu, 2011; Bagheri Hariri, Calvanese,
De Giacomo, De Masellis, & Felli, 2011; Belardinelli, Lomuscio, & Patrizi, 2011), context
suitably constrained relational database settings.
c
2013
AI Access Foundation. rights reserved.

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

work based maintaining information relational database,
sophisticated applications foreseen enrich data-intensive business processes semantic
level, information maintained semantically rich knowledge base allows
operating incomplete information (Calvanese, De Giacomo, Lembo, Montali, & Santoso, 2012;
Limonad, De Leenheer, Linehan, Hull, & Vaculin, 2012). leads us look combine
first-order data, ontologies, processes, maintaining basic inference tasks (specifically
verification) decidable. setting, capture domain interest terms semantically
rich formalisms provided ontological languages based Description Logics (DLs)
(Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). languages natively deal
incomplete knowledge modeled domain. additional flexibility comes added
cost, however: differently relational databases, evaluate queries need resort logical
implication. Moreover, incomplete information combined ability evolving system
actions results notoriously fragile setting w.r.t. decidability (Wolter & Zakharyaschev,
1999b, 1999a; Gabbay, Kurusz, Wolter, & Zakharyaschev, 2003). particular, due nature
DL assertions (which general definitions constraints models), get one
difficult kinds domain descriptions reasoning actions (Reiter, 2001),
amounts dealing complex forms state constraints (Lin & Reiter, 1994).
overcome difficulty, virtually solutions aim robustness based so-called
functional view knowledge bases (Levesque, 1984): KB provides ability querying
based logical implication (ask), ability progressing new KB forms
updates (tell) (Baader, Ghilardi, & Lutz, 2012; Calvanese, De Giacomo, Lenzerini, & Rosati,
2011). Notice functional view tightly related epistemic interpretation KB
(Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007a). Indeed work related
Epistemic Dynamic Logic (van Ditmarsch, van der Hoek, & Kooi, 2007), and, though
scope paper, decidability results presented could find application context
research well.
follow functional view KBs. However, key point work execution step external information incorporated system form new individuals (denoted
function terms), is, systems closed w.r.t. available information. makes
framework particularly interesting challenging. particular, presence individuals requires specific treatment equality, since system progresses new information
acquired, distinct function terms may inferred denote object.
Specifically, introduce so-called Knowledge Action Bases (KABs). KAB
equipped ontology or, precisely, TBox expressed, case, variant DLLiteA (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007b), extends core
Web Ontology Language OWL 2 QL (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2012)
particularly well suited data management. TBox captures intensional information
domain interest, similarly UML class diagrams conceptual data models, though
software component used run-time. KAB includes ABox, acts
storage state. ABox maintains data interest, accessed relying query answering based logical implication (certain answers). Notably, variant DL-LiteA without
unique name assumption (UNA), allow explicit equality assertions ABox.
way suitably treat function terms represent individuals acquired execution.
Technically, need dealing equality breaks first-order rewritability DL-LiteA query
answering, requires that, addition rewriting process, inference equality performed
652

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

(Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009). query language, use unions
conjunctive queries, possibly composing certain answers full FOL constructs.
gives rise epistemic query language asks known current KB (Calvanese et al., 2007a). Apart KB, KAB contains actions, whose execution changes
state KB, i.e., ABox. actions specified sets conditional effects,
conditions (epistemic) queries KB effects expressed terms new ABoxes.
Actions static pre-conditions, whereas process used specify actions
executed step. simplicity, model processes condition/action rules,
condition expressed query KB.
setting, address verification temporal/dynamic properties expressed firstorder variant -calculus (Park, 1976; Stirling, 2001), atomic formulae queries
KB refer constants function terms, controlled form
quantification across states allowed. Notice previous decidability results actions
DL KBs assumed information coming outside system, sense
new individual terms added executing actions (Calvanese et al., 2011; Baader et al., 2012;
Rosati & Franconi, 2012). paper, instead, allow arbitrary introduction new terms.
Unsurprisingly, show even simple KABs temporal properties, verification
undecidable. However, show rich class KABs, verification fact decidable
reducible finite-state model checking. obtain result, following Cangialosi et al. (2010),
Bagheri Hariri et al. (2011), rely recent results data exchange finiteness
chase tuple-generating dependencies (Fagin, Kolaitis, Miller, & Popa, 2005), though, case,
need extend approach deal (i) incomplete information, (ii) inference equality,
(iii) quantification across states verification language.
paper organized follows. Section 2 give preliminaries DL-LiteA without
UNA , going knowledge base formalism. Section 3 describes KAB framework detail, Section 4 discusses execution semantics. Section 5 introduce
verification formalism KABs. Section 6, show verification KABs general undecidable, even considering simple temporal properties KABs. Section 7, give
main technical result: verification weakly acyclic KABs decidable E XP IME. Section 8,
extensively survey related work. Section 9 concludes paper.

2. Knowledge Base Formalism
Description Logics (DLs) (Baader et al., 2003) knowledge representation formalisms
tailored representing domain interest terms concepts (or classes), denoting sets
objects, roles (or relations), denoting binary relations objects. DL knowledge bases
(KBs) based alphabet concept role names, alphabet individuals.
DL KB formed two distinct parts: TBox, represents intensional level KB
contains description domain interest terms universal assertions concepts
roles; ABox, represents instance level KB contains extensional
information participation individuals concepts roles.
expressing KBs use DL-LiteNU , variant DL-LiteA language (Poggi, Lembo,
Calvanese, De Giacomo, Lenzerini, & Rosati, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, &
Rosati, 2013) drop unique name assumption (UNA) line standard Web
Ontology Language (OWL 2) (Bao et al., 2012). Essentially, DL-LiteNU extends OWL 2 QL
653

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

profile OWL 2, including functionality assertions possibility state equality
individuals.
syntax concept role expressions DL-LiteNU follows:
R P | P ,
V R | R,

B N | R,
C B | B,

N denotes concept name, P role name, P inverse role.
Formally, DL-LiteNU KB (T, A), TBox finite set TBox assertions form
B v C,

R v V,

(funct R),

called respectively concept inclusions, role inclusions, functionality assertions. follow
usual assumption DL-Lite, according TBox may contain neither (funct P )
(funct P ) contains R v P R v P , role R (Poggi et al., 2008; Calvanese et al.,
2013). condition expresses roles functionality assertions cannot specialized.
DL-LiteNU TBoxes able capture essential features conceptual modeling formalisms,
UML Class Diagrams (or Entity-Relationship schemas), namely ISA classes
associations (relationships), disjointness classes associations, typing associations, association multiplicities (in particular, mandatory participation functionality).
main missing feature completeness hierarchies, would require introduction
disjunction would compromise good computational properties DL-Lite.
ABox DL-LiteNU KB (T, A) finite set ABox assertions form
N (t1 ),

P (t1 , t2 ),

t1 = t2 ,

called respectively, concept (membership) assertions, role (membership) assertions, equality
assertions, t1 , t2 terms denoting individuals (see below). presence equality assertions ABox requires specific treatment equality goes beyond usual reasoning
techniques DL-Lite based first-order rewritability, although reasoning remains polynomial
(Artale et al., 2009). hand, allow explicit disequality, though one use
membership disjoint concepts assert two individuals different.
DL-LiteNU admits complex terms denoting individuals. terms inductively defined
starting finite set constants, applying finite set (uninterpreted) functions
various arity greater 0. result, set individual terms countably infinite.
call function terms terms involving functions. Also, structure terms impact
inference equality, congruence relation structure terms, i.e., ti = t0i ,
{1, . . . , n}, f function symbol arity n, f (t1 , . . . , tn ) = f (t01 , . . . , t0n ). Apart
aspect related equality, treat individuals denoted terms simply ordinary
individual constants DLs.
adopt standard semantics DLs based FOL interpretations = (I , ),
interpretation domain interpretation function tI , N ,
P , term t,concept name N , role name P . Coherently congruence
relation terms, (f (t1 , . . . , tn ))I = (f (t01 , . . . , t0n ))I , whenever tIi = t0i ,
{1, . . . , n}.
Complex concepts roles interpreted follows:
(R)I
(B)I

= {o | o0 .(o, o0 ) RI },
= \ B ,

(P )I
(R)I
654

= {(o1 , o2 ) | (o2 , o1 ) P },
= \ R .

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

interpretation satisfies assertion form:
B v C, B C ;
R v V , RI V ;
(funct R), o, o1 , o2 that, {(o, o1 ), (o, o2 )} RI , o1 = o2 ;
N (t1 ), tI1 N ;
P (t1 , t2 ), (tI1 , tI2 ) P ;
t1 = t2 , tI1 = tI2 .
model KB (T, A) satisfies assertions A. KB (T, A) satisfiable
model. say ABox consistent w.r.t. TBox KB (T, A) satisfiable.
assertion logically implied KB (T, A), denoted (T, A) |= , every model (T, A)
satisfies well.
following characterization satisfiability logical implication DL-LiteNU easy
consequence results Artale et al. (2009).
Theorem 1 Checking satisfiability logical implication DL-LiteNU PT IME-complete.
Proof. PT IME lower bound immediate consequence lower bound established
Artale et al. (2009) DL-LiteNU allow use complex individual terms.
upper bound, Artale et al. (2009) provide PT IME algorithm based first using
functionality assertions exhaustively propagate equality, resorting PT IME algorithm
(in combined complexity) reasoning DL-Lite absence UNA. adapt
algorithm changing first step, propagate, PT IME, equality terms
active domain due functionalities, due congruence.
Next introduce queries. usual (cf. OWL 2), answers queries formed constants/terms denoting individuals explicitly mentioned ABox. (active) domain
ABox A, denoted ADOM(A), (finite) set constants/terms appearing concept, role,
equality assertions A. (predicate) alphabet KB (T, A), denoted ALPH((T, A)) set
concept role names occurring A.
union conjunctive queries (UCQ) q KB (T, A) FOL formula form
~y1 .conj 1 (~x, ~y1 ) ~yn .conj n (~x, ~yn ) free variables ~x existentially quantified variables ~y1 , . . . , ~yn . conj (~x, y~i ) q conjunction atoms form N (z), P (z, z 0 )
N P respectively denote concept role name occurring ALPH((T, A)), z, z 0
constants ADOM(A) variables ~x y~i , {1, . . . , n}. certain answers q
(T, A) set ANS (q, T, A) substitutions1 free variables q constants/terms
ADOM(A) q evaluates true every model (T, A), i.e., q logically implied
(T, A). Following notation used assertions, denote (T, A) |= q. q free
variables, called boolean certain answers either empty substitution denoting
true nothing denoting false.
Again, easy consequence results Artale et al. (2009), obtain following
characterization query answering DL-LiteNU .
Theorem 2 Computing ANS (q, T, A) UCQ q DL-LiteNU KB (T, A) PT IME-complete
size A.
1. customary, view substitution simply tuple constants, assuming ordering free
variables q.

655

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

Proof. proof Theorem 1, first propagate PT IME equality terms
active domain using functionality congruence closure, resort query answering
DL-Lite presence UNA, PT IME combined size TBox
ABox resulting equality propagation (actually, AC0 size ABox).
consider extension UCQs, called ECQs, queries query language
EQL-Lite(UCQ) (Calvanese et al., 2007a), is, FOL query language whose atoms UCQs
evaluated according certain answer semantics above. ECQ KB (T, A) possibly
open formula form
Q [q] | [x = y] | Q | Q1 Q2 | x.Q,
[q] denotes certain answers UCQ q (T, A), [x = y] denotes certain answers
x = (T, A), is, set {hx, yi ADOM(A) | (T, A) |= (x = y)}, logical operators
usual meaning, quantification ranges elements ADOM(A).
Formally define relation Q holds (T, A) substitution free variables
Q, written T, A, |= Q, inductively follows:
T, A,
T, A,
T, A,
T, A,
T, A,

|= [q]
|= [x = y]
|= Q
|= Q1 Q2
|= x.Q







(T, A) |= q,
(T, A) |= (x = y),
T, A, 6|= Q,
T, A, |= Q1 T, A, |= Q2 ,
exists ADOM(A) T, A, [x/t] |= Q,

[x/t] denotes substitution obtained assigning x constant/term (if x
already present value replaced t, not, pair x/t added substitution).
certain answer Q (T, A), denoted ANS (Q, T, A), set substitutions
free variables Q Q holds (T, A) , i.e.,
ANS (Q, T, A)

= { | T, A, |= Q}.

Following line proof Calvanese et al. (2007a), considering Theorem 2
basic step evaluating UCQ, get:
Theorem 3 Computing ANS (Q, T, A) ECQ Q DL-LiteNU KB (T, A) PT IMEcomplete size A.
recall DL-Lite enjoys rewritability property, states every UCQ q
every DL-Lite KB (T, A),
ANS (q, T, A)

= ANS (rew (q), , A),

rew (q) UCQ computed reformulation algorithm Calvanese et al. (2007b).
Notice that, way, compiled away TBox. result extended ECQs
well, i.e., every ECQ Q, ANS (Q, T, A) = ANS (rew (Q), , A) query rew (Q)
obtained Q substituting atom [q] (where q UCQ) [rew (q)] (Calvanese et al.,
2007a). setting, exploit rewritability, pre-processed
ABox (in PT IME) propagating equalities individual terms ADOM(A) according
functionality assertions congruence terms.
656

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

say two ABoxes A1 A2 equivalent w.r.t. TBox predicate alphabet ,
denoted
A1 T, A2 ,
every ABox assertion 2 A2 either concept assertion N (t) N , role
assertion P (t1 , t2 ) P , equivalence assertion t1 = t2 , (T, A1 ) |= 2 ; viceversa, every ABox assertion 1 A1 , either concept assertion N (t) N ,
role assertion P (t1 , t2 ) P , equivalence assertion t1 = t2 , (T, A2 ) |= 1 .
Notice A1 T, A2 , every ECQ Q whose concept role names belong
ANS (Q, T, A1 ) = ANS (Q, T, A2 ). Notice that, applying Theorem 3 boolean
query [] corresponding ABox assertion , A1 A2 , obtain ABox
equivalence checked PT IME.

3. Knowledge Action Bases
Knowledge Action Base (KAB) tuple K = (T, A0 , , ) A0 form
knowledge component (or knowledge base), form action component (or action
base). practice, K stores information interest KB, formed fixed TBox
initial ABox A0 , evolves executing actions according sequencing established
process . evolution new individuals acquired KB. individuals
witnesses new pieces information inserted KAB environment KAB
runs (i.e., external world). represent new objects function terms. KAB
evolves, identity individuals intuitively preserved induces necessity
remembering equalities terms denoting individuals discovered past. describe
detail components KAB.
3.1 TBox
DL-LiteNU TBox, used capture intensional knowledge domain interest.
TBox fixed all, evolve execution KAB.
3.2 ABox
A0 DL-LiteNU ABox, stores extensional information interest. Notice A0
ABox initial state KAB, KAB evolves due effect actions,
ABox, indeed state system, evolves accordingly store up-to-date information.
actions acquire new information external world using calls external
services represented functions. Given information services,
except name parameters passed them, functions remain uninterpreted.
assume result service calls depends passed parameters. Hence,
represent new individuals returned service calls function terms. presence
function terms impact treatment equality, since principle need close equality
w.r.t. congruence. closure generates infinite number logically implied equality
assertions, going keep assertions implicit, computing needed.
657

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

3.3 Actions
finite set actions. action modifies current ABox adding deleting
assertions, thus generating new ABox A0 . action form
act(~x) : {e1 , . . . , en },
act(~x) signature {e1 , . . . , en } (finite) set effects forming effect
specification . action signature constituted name act list ~x individual input
parameters, need instantiated actual individuals execution time.2 effect ei
form
[qi+ ] Q
A0i ,
(1)


qi+ UCQ, i.e., positive query, extracts bulk data process (obtained
certain answers qi+ ); free variables qi+ include action parameters;
+
Q
arbitrary ECQ, whose free variables occur among free variables qi ,
refines, using negation quantification, result qi+ . query [qi+ ] Q

whole extracts individual terms used form new state KAB (notice
UCQ-ECQ division convenience readily available positive part
condition, exploit later);

A0i set (non-ground) ABox assertions, include terms: constants A0 , free
variables qi+ , function terms f (~x) arguments ~x free variables qi+ .
terms, grounded values extracted [qi+ ] Q
, give rise (ground) ABox
assertions, contribute form next state KAB.
precisely, given current ABox K substitution input parameters
action , denote action instantiated actual parameters coming .
firing state A, get new state A0 computed simultaneously applying
instantiated effects follows:
effect ei form (1) extracts set ANS (([qi+ ] Q
), T, A) tuples
terms ADOM(A) and, tuple , asserts set A0i ABox assertions obtained
A0i applying substitution free variables qi+ . function term
f (~x) appearing A0i , new ground term introduced form f (~x).
terms represent new constants coming external environment KAB running
in.
denote ei (A) overall set ABox assertions, i.e.,
[

ei (A) =

A0i .

ANS (([qi+ ]Q
),T,A)

2. disregard specific treatment output parameters, assume instead user freely pose queries
KB, extracting whatever information she/he interested in.

658

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

Moreover, let EQ(T, A) = {t1 = t2 | ht1 , t2 ANS ([x1 = x2 ], T, A)}. Observe that, due
semantics queries, terms EQ(T, A) must appear explicitly ADOM(A),
is, possibly infinite number equalities due congruence appear EQ(T, A),
though logically implied. Hence, equalities EQ(T, A) equality assertions involving terms ADOM(A) either appear explicitly A, obtained
closing functionality congruence terms.
overall effect action parameter substitution new ABox A0 =
(T, A, )
[
ei (A).
(T, A, ) = EQ(T, A)
1in

Notice presence function terms action effects makes domain ABoxes obtained executing actions continuously changing general unbounded size. Notice
persistence assumption equalities, i.e., implicitly copy equalities holding current state new one. implies that, system evolves, acquire new
information equalities terms, never lose information equalities already acquired.
Finally, observe execution mechanism persistence/frame assumption (except equality) made. principle every move substitute whole old state, i.e., ABox,
new one. hand, clear easily write effect specifications
copy big chunks old state new one. example, [P (x, y)]
P (x, y) copies
entire set assertions involving role P . sense, execution mechanism adopted
paper basic address elaboration tolerance issues typical
reasoning actions, frame problem, ramification problem qualification problem
(Reiter, 2001)3 . consider irrelevant, contrary, relevant
research issues desirable. adopt basic mechanism simply
general enough expose difficulties need overcome order get decidability
verification setting.
3.4 Process
process component KAB possibly nondeterministic program uses KAB ABoxes
store (intermediate final) computation results, actions atomic instructions.
ABoxes arbitrarily queried KAB TBox , updated
actions . specify process component adopt rule-based specification.
Specifically, process finite set condition/action rules. condition/action rule
expression form
Q 7 ,
action Q ECQ, whose free variables exactly parameters
. rule expresses that, tuple condition Q holds, action actual
parameters executed. Processes force execution actions constrain them:
user process able choose action rules forming process allow.
Moreover, processes inherit entirely states KAB knowledge component (TBox
ABox) (see, e.g., Cohn & Hull, 2009).
3. see work Kowalski Sadri (2011).

659

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

Villain v Character
livesIn v Character
livesIn v City
Character v livesIn
(funct livesIn)
enemy v Villain
enemy v Superhero
defeated v Villain
defeated v Superhero
defeated v enemy
alterEgo v Superhero
alterEgo v Character
(funct alterEgo)

0..1

alterEgo
enemy

Superhero

Character

1..1

livesIn

City

Villain

{subset}
defeated

Figure 1: KABs TBox Example 1
observe adopt basic rule-based specification because, spite simplicity,
able expose difficulties setting. choices possible, particular,
process could maintain state besides one KAB. long additional
state finite, embeddable KAB itself, results would easily extend case.
Example 1 Let us consider KAB K = (T, A0 , , ) describing super-heroes comics world,
cities characters live. Figure 1 shows TBox rendering
UML Class Diagram. relationship UML Class Diagrams Description Logics
general DL-Lite particular, refer work Berardi, Calvanese, De Giacomo
(2005) Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodrguez-Muro, Rosati
(2009). dynamics domain, characters superheroes (super)villains,
fight other. classic plot, superheroes help endeavors law enforcement
fighting villains threatening city live in. villain reveals perpetrating
nefarious purposes citys peace, consequently becomes declared enemy
superheroes living city. character lives one city time. common trait
superheroes secret identity: superhero said alter ego character,
identity common life. Hence, ABox assertion alterEgo(s, p) means superhero
alter ego character p. Villains always try unmask superheroes, i.e., find secret identity,
order exploit knowledge defeat them. Notice subtle difference here: use
alterEgo(s, p) assertion model fact alter ego p, whereas asserting = p
capture knowledge p semantically denote individual. may include
actions following ones:
BecomeSH(p, c) : { [Character(p) livesIn(p, c) v.Villain(v) livesIn(v, c)]
{Superhero(sh(p)), alterEgo(sh(p), p)},
CopyAll }
states exists least one villain living city c, new superhero sh(p) created,
purpose protecting c. superhero p alter ego. CopyAll shortcut
explicitly copying concept role assertions new state (equality assertions always
660

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

implicitly copied). Action
Unmask(s, p) : { [alterEgo(s, p)]
CopyAll }

{s = p},

states superhero s, alter ego p, gets unmasked asserting equality
p (it known = p). Action
Fight(v, s) : { p.[Villain(v) Character(p) alterEgo(s, p)] [s = p]
CopyAll }

{defeated(v, s)},

states villain v fights superhero s, defeats unmasked, i.e., known
equal alter ego. Action
Challenge(v, s) :
{ [Villain(v) Superhero(s) p.alterEgo(s, p) livesIn(p, sc)] [defeated(v, s)]
{livesIn(v, sc), enemy(v, s)},
CopyAll }
states villain v challenges superhero defeated him, next lives
city enemy s. Action
ThreatenCity(v, c) :
{ [Villain(v) Superhero(s) p.alterEgo(s, p) livesIn(p, c)]
{enemy(v, s) livesIn(v, c)}
CopyAll }
states villain v threatens city c, becomes enemy superheroes
live c.
process might include following rules:
[Character(p)] [s.Superhero(s) livesIn(s, c)]
[Superhero(s) Character(c)]
[enemy(v, s)] [v 0 .defeated(v 0 , s)]
[Villain(v) Superhero(s)]
[Villain(v) City(c)] v 0 ([Villain(v 0 ) livesIn(v 0 , c)] [v = v 0 ])

7
7

7
7
7

BecomeSH(p, c),
Unmask(s, c),
Fight(v, s),
Challenge(v, s),
ThreatenCity(v, c).

instance, first rule states character become superhero city already
one, whereas last one states villain threaten city, city
another villain (known be) distinct him/her.
Notice that, execution, reasoning KB performed. instance, consider
initial ABox
A0 = { Superhero(batman), Villain(joker), alterEgo(batman, bruce),
livesIn(bruce, gotham), livesIn(batman, gotham), livesIn(joker, city1) }.
state, bruce batman live city, batman alter-ego bruce,
known whether denote individual. Executing Challenge(joker, batman) A0 ,
indeed allowed process , generates new ABox added assertions enemy(joker,
batman), livesIn(joker, gotham), gotham = city1 implied functionality livesIn.

661

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

4. KAB Transition System
semantics KABs given terms possibly infinite transition systems represent
possible evolutions KAB time, actions executed according process. Notice
transition systems must equipped semantically rich states, since full KB associated them. Formally define kind transition system need follows: transition
system tuple form (U, T, , s0 , abox , ), where:
U countably infinite set terms denoting individuals, called universe;
TBox;
set states;
s0 initial state;
abox function that, given state returns ABox associated
individuals terms U, conforms ;
transition relation pairs states.
convenience,
introduce active domain whole transition system, defined
ADOM () = ADOM (abox (s)). introduce (predicate) alphabet ALPH ()
set concepts roles occurring co-domain abox .
KAB generates transition system form execution. Formally, given
KAB K = (T, A0 , , ), define (generated) transition system K = (U, T, , s0 , abox , )
follows:
U formed constants function terms inductively formed starting
ADOM (A0 ) applying functions occurring actions ;
TBox KAB;
abox identity function (i.e., state simply ABox);
s0 = A0 initial state;
defined mutual induction smallest sets satisfying following property: , rule Q 7 , evaluate Q and, tuple returned,
(T, abox (s), ) consistent w.r.t. , s0 s0 = (T, abox (s), ).
Notice alphabet ALPH(K ) K simply formed set ALPH(K) concepts
roles occur K.
KAB transition system K infinite tree infinitely many different ABoxes
nodes, general. fact, get transition system infinite, enough perform
indefinitely simple action adds new terms step, e.g., action form
() : { [C(x)]

{C(f (x))}, CopyAll }.

Hence classical results model checking (Clarke et al., 1999), developed finite
transition systems, cannot applied directly verifying KABs.
662

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

5. Verification Formalism
specify dynamic properties KABs, use first-order variant -calculus (Stirling, 2001;
Park, 1976). -calculus virtually powerful temporal logic used model checking
finite-state transition systems, able express linear time logics LTL PSL,
branching time logics CTL CTL* (Clarke et al., 1999). main characteristic
-calculus ability expressing directly least greatest fixpoints (predicate-transformer)
operators formed using formulae relating current state next one. using fixpoint
constructs one easily express sophisticated properties defined induction co-induction.
reason virtually logics used verification considered fragments
-calculus. Technically, -calculus separates local properties, asserted current state
states immediate successors current one, properties talking states
arbitrarily far away current one (Stirling, 2001). latter expressed use
fixpoints.
work, use first-order variant -calculus, allow local properties
expressed ECQs, time allow arbitrary first-order quantification across
states. Given nature ECQs used formulating local properties, first-order quantification
ranges terms denoting individuals. Formally, introduce logic LA defined follows:
Q | | 1 2 | x. | hi | Z | Z.,
Q possibly open ECQ Z second order predicate variable (of arity 0). make use
following abbreviations: x. = (x.), 1 2 = (1 2 ), [] = hi,
Z. = Z.[Z/Z]. formulae Z. Z. respectively denote least
greatest fixpoint formula (seen predicate transformer Z.). usual -calculus,
formulae form Z. (and Z.) must obey syntactic monotonicity w.r.t. Z,
states every occurrence variable Z must within scope even number
negation symbols. ensures least fixpoint Z. (as well greatest fixpoint Z.)
always exists.
semantics LA formulae defined possibly infinite transition systems form
hU, T, , s0 , abox , seen above. Since LA contains formulae individual
predicate free variables, given transition system , introduce individual variable valuation
v, i.e., mapping individual variables x U, predicate variable valuation V , i.e.,
mapping predicate variables Z subsets . three notions place,
assign meaning formulae associating , v, V extension function ()
v,V , maps

formulae subsets . Formally, extension function ()v,V defined inductively follows:
(Q)
v,V
()
v,V
(1 2 )
v,V
(x.)
v,V
(hi)
v,V
(Z)
v,V
(Z.)
v,V

=
=
=
=
=
=
=

{s | ANS (Qv, T, abox (s)) = true},
\ ()
v,V ,

(1 )
v,V (2 )v,V ,
{s | t.t ADOM(abox (s)) ()
v[x/t],V },

0
0
0
{s | .s ()v,V },
V (Z),

{E | ()
v,V [Z/E] E}.

Qv stands (boolean) ECQ obtained Q substituting free variables according
v. Intuitively, ()
v,V assigns constructs following meaning:
663

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

boolean connectives expected meaning.
quantification individuals done terms current ABox. Notice
terms referred later states associated ABox include
terms anymore.
extension hi consists states that, state s0 transition
s0 , formula holds s0 valuation v .
extension [] consists states that, states s0 transition s0 ,
formula holds s0 valuation v.
extension Z. smallest subset E that, assigning Z
extension E , resulting extension (under valuation v) contained E . is,
extension Z. least fixpoint operator ()
v,V [Z/E] , V [Z/E] denotes
predicate valuation obtained V forcing valuation Z E.
Similarly, extension Z. greatest subset E that, assigning
Z extension E , resulting extension contains E . is, extension
Z.


=
{E

|E
.
Formally,
(Z.)
greatest fixpoint operator ()
v,V
v,V [Z/E]
()
v,V [Z/E] }.
closed formula, ()
v,V depend v V , denote extension

simply () . closed formula holds state () . case, write
, |= . closed formula holds , denoted |= , , s0 |= . call model
checking problem verifying whether |= holds.
next example shows simple temporal properties expressed LA .
Example 2 Considering KAB Example 1, easily express temporal properties
following ones.
current superheroes live Gotham live Gotham forever (a form
safety):
x.[Superhero(x) livesIn(x, gotham)] Z.([livesIn(x, gotham)] []Z).
Eventually current superheroes unmasked (a form liveness):
x.[Superhero(x)] Z.([alterEgo(x, x)] []Z).
exists possible future situation current superheroes unmasked (another form liveness):
x.[Superhero(x)] Z.([alterEgo(x, x)] hiZ).
Along every future, always true, every superhero, exists evolution
eventually leads unmask (a form liveness holds every moment):
Y.(x.[Superhero(x)] Z.([alterEgo(x, x)] hiZ)) []Y.
664

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

Consider two transition systems sharing universe predicate alphabet.
say behaviorally equivalent satisfy exactly LA formulas.
formally capture equivalence, make use notion bisimulation (Milner, 1971),
suitably extended deal query answering KBs.
Given two transition systems 1
=
hU, T, 1 , s01 , abox 1 , 1 2
=
hU, T, 2 , s02 , abox 2 , 2 sharing universe U, TBox ,
ALPH (1 ) = ALPH (2 ) = , bisimulation 1 2 relation B 1 2
(s1 , s2 ) B implies that:
1. abox (s1 ) T, abox (s2 );
2. s1 1 s01 , exists s02 s2 2 s02 (s01 , s02 ) B;
3. s2 2 s02 , exists s01 s1 1 s01 (s01 , s02 ) B.
say two states s1 s2 bisimilar exists bisimulation B (s1 , s2 )
B. Two transition systems 1 initial state s01 2 initial state s02 bisimilar
(s01 , s02 ) B. following theorem states formula evaluation LA indeed invariant
w.r.t. bisimulation, equivalently check bisimilar transition systems.
Theorem 4 Let 1 2 two transition systems share universe, TBox,
predicate alphabet, bisimilar. Then, two states s1 1 s2 2
(including initial ones) bisimilar, closed LA formulas ,
s1 ()1

iff

s2 ()2 .

Proof. proof analogous standard proof bisimulation invariance -calculus (Stirling, 2001), though taking account bisimulation, guarantees ECQs evaluated
identically bisimilar states. Notice assumption two transition systems share
universe predicate alphabet makes easy compare answers queries.
Making use notion bisimulation, can, example, redefine transition system
generated KAB K = (T, A0 , , ) maintaining bisimilarity, modifying definition
K = hU, T, , s0 , abox , given Section 4 follows.
(i) modify DO() function term t0 introduced generated ABox A0
current ABox4 already term (T, A) |= = t0 .
(ii) ABox A0 = DO(T, abox (s), ) obtained current state logically equivalent
ABox abox (s00 ), already generate state s00 , generate new state,
simply add s00 K .

6. Verification KABs
immediate see verification KABs undecidable general easy represent
Turing machines using KAB. Actually using fragment capabilities
KABs, shown next lemma.
Lemma 5 Checking formulas form Z.(N (a) hiZ), N atomic concept
individual occurring A0 , undecidable already KAB K = (T, A0 , , ) where:
4. Note terms present current ABox preserved new ABox, together equalities
terms.

665

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

{First(c)}
{value(c, x)}
{value(c, av0 )}
{cell(cr , aq0 )}
{cell(n(c), aq0 ), next(c, n(c)), Last(n(c))}
{Last(c)}
{cell(c, #)}
{cell(cr , #)}
{Stop(0)}

[First(c)]
[cell(c, #) value(c, x)]
[cell(c, aq ) value(c, av )]
[cell(c, aq ) value(c, av ) next(c, cr )]
[cell(c, aq ) value(c, av ) Last(c)]
[cell(c, #) Last(c)]
[cell(c, #) First(c)]
[cell(c, #) next(c, cr )]
[cell(c, aqf )]

Figure 2: Effects action used encode transition (q, v, q 0 , v 0 , R) Turing Machine
empty TBox,
actions make use negation equality,
trivial process poses restriction executability actions.
Proof. Given Turing machine = hQ, , q0 , , qf , i, show construct corresponding
KAB KM = (, A0 , , ) mimics behavior M. Specifically, encode halting
problem verification problem KM . Roughly speaking, KM maintains tape
state information (current) ABox, encodes transitions actions.
construction makes use tape initially contains unique cell, represented constant
0, extended on-the-fly needed: cells right 0 represented function terms
form n(n( (0) )), cells left 0 represented function terms form
p(p( (0) )). Then, make use one constant aq state q Q, one constant av
tape symbol value v , special constant #, following concepts roles:
cell(c, h) models cell tape, c cell identifier, h corresponds current
state M, head currently points c, # head currently point
c;
next(cl , cr ) models relative position cells, stating cr cell immediately following cl ;
value(c, v) models cell c currently contains value v, v ;
First(c) Last(c) respectively denote current first cell last cell portion
tape explored far.
Stop(c) used detect halts.
initial state KM contains unique cell defined
A0 = { cell(0, aq0 ), value(0, ), First(0), Last(0) }.
action component, contains action parameters transition ,
process poses restriction executability actions, i.e., contains rule true 7 ()
action .
provide specification actions, detailing case right shift transition
(q, v, q 0 , v 0 , R). corresponding action specification consists set effects shown
Figure 2. first effect maintains first position tape unaltered. second third
666

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

effects deal cell values. remain except current cell, updated
according transition. next three effects deal right shift Turing Machine
state. current cell next cell therefore last one, head moved
next cell state change recorded there. case last cell remains
same. instead current cell last one, moving head tape must properly
extended. function n/1 used create identifier new successor cell, starting
identifier current one. Furthermore, since transition corresponds right shift one
cell, first cell cells immediately following cell marked # marked #
next state. Finally, last effect used identify case reached final state.
marked inserting new state special assertion Stop(0).
construction left shift transition done symmetrically, using function p/1 create
new predecessor cell. construction, KM satisfies conditions theorem. Observe that,
transition system KM generated KM , every action corresponding every transition
executed ABox/state KM , since empty, actually generate
successor state s. However, state, (unique) action corresponds actually
executed transition generate successor state containing ABox assertion form
cell(c, aq ), state q M. Therefore, ABoxes/states properly corresponding
configurations could eventually lead ABox/state KM Stop(0) holds.
latter happen halts. precisely, one show induction length
respectively halting computation shortest path initial state KM
state Stop(0) holds, halts KM |= Z.([Stop(0)] hiZ),
concludes proof.
previous lemma, shows undecidability already special case, immediately
obtain following result.
Theorem 6 Verification LA formulae KABs undecidable.
observe Lemma 5 uses KB constituted ABox containing concept
role assertions, makes use conjunctive queries defining actions effects. Moreover, formula check makes use quantification all, simply seen
propositional CTL formula form EF p, expressing proposition p eventually holds along
one path.

7. Verification Weakly Acyclic KABs
spite Theorem 6, next introduce notable class KABs verification arbitrary
LA properties decidable. so, rely syntactic restriction resembles notion
weak acyclicity data exchange (Fagin et al., 2005)5 , guarantees boundedness ABoxes
generated execution KAB and, turn, decidability verification.
ready introduce notion weak acyclicity context. introduce
edge-labeled directed dependency graph KAB K = (T, A0 , , ), defined follows. Nodes,
called positions, obtained TBox T: node every concept name N ,
two nodes every role name P , corresponding domain range P . Edges
5. use original definition weak acyclicity. However, results applied variants weak
acyclicity (see discussion Section 9).

667

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

Villain

livesIn,1

livesIn,2

City

enemy,1

Character

alterEgo,2

defeats,2

*
defeats,1

*

*

alterEgo,1

*
SuperHero

enemy,2

Figure 3: Weakly acyclic dependency graph Example 1.
drawn considering every effect specification [q + ] Q
A0 action contained
, tracing values copied contribute generate new values system progresses.
particular, let p position corresponding concept/role component rewriting rew (q + )
q + variable x. every position p0 A0 variable x, include normal
edge p p0 . every position p00 A0 function term f (~t) x ~t, include

special edge p
p00 . say K weakly-acyclic dependency graph cycle going
special edge.
Example 3 KAB Example 1 weakly acyclic. dependency graph, shown Figure 3,
contain cycle going special edges. readability, self-loops shown
Figure (but present nodes), dashed edges used compactly represent
contributions given rewriting queries. E.g., dashed edge form Villain Character
denotes every outgoing edge Character, exists outgoing edge Villain
type target. Hence, w.r.t. weak acyclicity dashed edges simply replaced
normal edges.
ready state main result work, going prove remainder
section.
Theorem 7 Verification LA properties weakly acyclic KAB decidable E XP IME
size KAB.
observe restriction imposed weak acyclicity (or variants) severe,
many real cases KABs indeed weakly acyclic transformed weakly acyclic ones
cost redesign. Indeed, weakly acyclic KABs cannot indefinitely generate new values
old ones, depend chain unboundedly many previous values. words,
current values depend bounded number old values. unbounded systems exist
theory, e.g., Turing machines, higher level processes, business process management
service-oriented modeling, typically require boundedness practice. systematically
transform systems weakly acyclic ones remains open issue.
remainder section present proof Theorem 7. several steps:
1. Normalized KAB. First introduce normalized form K KAB K, isolates
contribution equalities TBox actions effects KAB. important point
normalizing KAB preserves weak acyclicity.
668

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

2. Normalized DO(). Then, introduce normalized version NORM () DO(), avoids
consider equalities generating bulk set tuples used effects generate
next ABox. transition system K,NORM generated normalized version
NORM () () normalized KAB K bisimilar transition system K generated DO() K. Hence two transition systems satisfy LA formulae.

3. Positive dominant. next step introduce call positive dominant K++
normalized KAB K. obtained K essentially dropping equalities, negations,
TBox. However K++ contains enough information positive part that,
drop features, active domain transition system K++ generated
K++ overestimates active domain transition system K,NORM generated
normalized KAB K. Moreover, normalized (and hence original) KAB weakly
acyclic, positive dominant. Finally positive dominant weakly acyclic
size active domain transition system K++ polynomially bounded size
initial ABox, hence size active domain K,NORM . implies
size K,NORM finite exponential size initial ABox.
4. Putting together. Tying results together, get claim.
following, detail steps.
7.1 Normalized KAB
Given KAB K = (T, A0 , , ), build KAB K = (T, A0 , , ), called normalized form
K, applying sequence transformations preserve semantics K producing
KAB format easier study.
1. view ABox partitioned part collecting concept role assertions,
part collecting equality assertions. denote A6E Q former EQ(T, A)
latter, closed w.r.t. (the functionality assertions in) TBox . Notice
closure computed polynomial time size .
2. K individuals appearing equality assertions ABox occur special concept assertions form Dummy(t), concept Dummy unrelated
concepts roles KAB. by:
adding concept assertions Dummy(t) equality assertion A0
appear elsewhere;
adding right-hand part action effect ei concept assertion Dummy(t)
equality assertion right-hand part ei ;
adding action effect specification form
[Dummy(x)]

{Dummy(x)}.

Notice that, result transformation, get ABoxes containing additional
concept Dummy, however never queried actions effects rules forming
process. impact transformation simply ADOM(A) ABoxes
669

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

KAB transition system readily identified set terms occurring
concept role assertion (without looking equality assertions).
Given ABox A, denote result two transformations, respectively add closure equalities extension Dummy.
3. manipulate resulting effect specification
[q + ] Q

A0

follows:
3.1. replace [q + ] Q [rew (q + )] rew (Q ) (Calvanese et al., 2007a), exploiting
results Calvanese et al. (2007b) Artale et al. (2009), guarantee that,
every ECQ Q every ABox equalities closed functionality
congruence,
ANS (Q, T, A)

= ANS (rew (Q), , A).

3.2. replace effect specification [rew (q + )] rew (Q )
A0 , resulting
+

Step 3.1, set effect specifications [qi ] rew (Q )
A0 , one CQ qi
+
UCQ rew (q ).
3.3. effect specification [qi+ ] rew (Q )
A0 , re-express qi+ make
equalities used join terms explicit remove constants qi+ . Specifically,
replace effect specification
[qi++ ] q = rew (Q )

A0 ,

where:
qi++ CQ without repeated variables obtained qi+ (i) replacing
variable x occurring qi+ , j-th occurrence x except first one, x[j] ;
(ii) replacing constant c new variable xc ;
V
V
q = = [x = x[j] ] [xc = c] (i) first conjunction contains one equality
[x = x[j] ] variable x qi+ variable x[j] introduced step
above, (ii) second conjunction contains one equality constant c
qi+ .
clarify latter consider following example:
Example 4 Given query
.
[qi+ ] = [N (x) P1 (x, y) P2 (c, x)],
Step 3.3 replaces [qi++ ] q = ,
.
qi++ = N (x) P1 (x[2] , y) P2 (xc , x[3] ),
670

.
q = = [x = x[2] ] [x = x[3] ] [xc = c].

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

correctness
Step 3.3, immediate notice [qi+ ] equivalent [qi++
V
V
[j]
(x = x ) (xc = c)]. equivalence latter [qi++ ]q = consequence
construction Artale et al. (2009), shows query entailment presence
equalities reduced query evaluation saturating equalities w.r.t. transitivity,
reflexivity, symmetry, functionality.
Given action , denote action normalized above.
Since transformations preserve logical equivalence (as long query Dummy),

Lemma 8 DO(T, A, ) T,ALPH(K) DO(T, A, ).
normalization KAB preserves weak acyclicity, crucial consideration
later results.
Lemma 9 K weakly acyclic, K weakly acyclic.
Proof. Consider effect specification [q + ] Q
A0 belonging action K.
contribution effect specification dependency graph G K limited CQ qi
UCQ rew (q + ), set concept role assertions A0 . observe
qi corresponds query qi++ K variable qi occurs exactly once. every free
variable x qi appears A0 , every occurrence x qi itself, edge included
G. dependency graph G K, one edges appears, corresponding single
occurrence variable x qi++ .
Notice Dummy omitted dependency graph G since, definition K,
Dummy occur left-hand side effects except trivial effect [Dummy(x)]
{Dummy(x)}. true K, Dummy needed. Therefore, G indeed subgraph
G, hence weak acyclicity G implies weak acyclicity G.
7.2 Normalized DO()
Next give simplified version DO(), call NORM (). start observing
reformulate definition DO() given Section 3. that, first need define
suitable notion join two queries. Let q1 q2 two ECQs, may free variables
common, let A1 A2 two ABoxes. define ANS (q1 , , A1 ) ./ ANS (q2 , , A2 )
set substitutions free variables q1 q2 qi holds , Ai , i.e.,
, Ai , |= qi , {1, 2}. Then, given action parameters substitution ABox
A,
[
(T, A, ) =
APPLY (T, A, e, ),
e

effect specification e : [q ++ ] q = Q
APPLY (T, A, e, )

[

=

A0 ,
A0

ANS (q ++ ,,A)./ANS ((q = Q ),,A)

671

EQ(T, A).

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

Instead, define NORM ()
NORM (T, A, )

=

[

APPLY NORM (T, A, e, ),

e

where, effect specification e : [q ++ ] q = Q
APPLY NORM (T, A, e, )

A0 ,
[

=

A0

EQ(T, A).

ANS (q ++ ,,A6E Q )./ANS ((q = Q ),,A)

Notice difference DO() NORM () latter use A6E Q
instead compute answers CQs q ++ .
following lemma shows applications DO() NORM () give rise logically
equivalent ABoxes.
Lemma 10 DO(T, A, ) T,ALPH(K) NORM (T, A, ).
Proof. order prove claim, enough show concept/role assertion 2 NORM (T, A, ) whose concept/role name belongs ALPH(K),
(T, DO(T, A, )) |= 2 , concept/role assertion 1 DO(T, A, ) whose concept/role name belongs ALPH(K), (T, NORM (T, A, )) |= 1 . actually prove
slightly stronger result:
(1) ABox assertion 2 APPLY NORM (T, A, e, ), (T, APPLY(T, A, e, )) |=
2 .
(2) ABox assertion 1 APPLY(T, A, e, ), (T, APPLY NORM (T, A, e, )) |=
1 .
(1), monotonicity q ++ fact A6E Q A,
[
[
A0
contained
A0 ,
(ANS (q ++ ,,A6E Q )./ANS ((q = Q ),,A))

(ANS (q ++ ,,A)./ANS ((q = Q ),,A))

hence claim follows.
(2), consider ABox assertion APPLY(T, A, e, ). definition APPLY(), know
exists effect e : [q ++ ] q = Q
A0 assignment free variables
++
=
q
(which include free variables q Q ) (ANS (q ++ , , A) ./
=
ANS ((q Q ), , A)) A0 . Let {x1 , . . . , xn } free variables q ++ ,
= {x1 t1 , . . . , xn tn , }. variable xi , let N (xi ) (unique) concept atom
q ++ xi occurs (similar considerations hold xi occurs role atom). Then,
either N (ti ) A6E Q , t0i , N (t0i ) A6E Q (ti = t0i ) EQ(T, A). former
case, let t00i denote ti , latter case let t00i denote t0i . Then, consider substitution
0 = {x1 t001 , . . . , xn t00n , }. construction, 0 ANS (q ++ , , A6E Q ), since
ANS ((q = Q ), , A), (t00i = ti ) EQ(T, A) {1, . . . , n},
0 ANS (q ++ , , A6E Q ) ./ ANS ((q = Q ), , A). Since
A0 ,
672

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

0 identical modulo EQ(T, A)
EQ(T, A) APPLY NORM (T, A, e, ),
infer (T, APPLY NORM (T, A, e, )) |= . Hence claim holds.
combining Lemma 8 Lemma 10, get DO() K NORM () K behave
equivalently, starting equivalent ABoxes.
Lemma 11 A1 T,ALPH(K) A2 DO(T, A1 , ) T,ALPH(K) NORM (T, A2 , ).
Proof. claim direct consequence Lemma 8, Lemma 10, equivalence A1
A2 , observation logical equivalence transitive.
Given KAB K normalized version K, call transition system generated
way K , using NORM () K instead DO() K, normalized transition system
generated K, denote K,NORM .
Lemma 12 Given KAB K, transition systems K K,NORM bisimilar.
Proof. Let K = (U, T, , s0 , abox , ) K,NORM = (U, T, NORM , s0 , abox NORM , NORM ).
define relation B NORM follows: (s1 , s2 ) B iff abox (s1 ) T,ALPH(K)
abox NORM (s2 ) show B bisimulation. so, prove B closed
definition bisimulation itself. Indeed, (s1 , s2 ) B, then:
abox (s1 ) T,ALPH(K) abox (s2 ) definition.
s1 s01 exists action substitution s01 =
(T, abox (s1 ), ) (notice abox (s1 ) = s1 ) s01 consistent w.r.t. . let
us consider s02 = NORM (T, abox (s2 ), ). Since abox (s1 ) T,ALPH(K) abox (s2 ),
Lemma 11, s01 T,ALPH(K) s02 . Therefore, s02 consistent w.r.t. , hence
s2 NORM s02 , (s01 , s02 ) B.
Similarly, s2 NORM s02 exists action substitution
s02 = NORM (T, abox (s2 ), ) s02 consistent w.r.t. . let us consider s01 =
(T, abox (s1 ), ). Since s2 T,ALPH(K) s1 , Lemma 11, s02 T,ALPH(K)
s01 Therefore, s01 consistent w.r.t. , hence s1 s01 , and, considering equivalence
enjoys symmetry, (s01 , s02 ) B.
proves claim.
direct consequence lemma that, considering Bismulation Invariance
Theorem 4, faithfully check LA formulas K,NORM instead K .
7.3 Positive Dominant
next step show weakly acyclic KAB K, normalized transition system K,NORM
finite. considering another transition system, behaviorally unrelated
K,NORM , hence K , whose active domain bounds active domain K,NORM .
obtain transition system essentially ignoring negative information equalities.
allows us refer back literature data exchange show boundedness. call
transition system positive dominant.
Given normalized KAB K = (T, A0 , , ), define positive dominant K KAB
6E Q

K+ = (, A0 , { + }, {true 7 + }).
673

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

action + without parameters effect specification constituted CopyAll
one effect form
6E Q
[qi++ ]
A0i
effect [qi++ ] qi= Q
A0i every action . Observe parameters

actions become simply free variables + .
Notice + applicable every step process trivially always allows it.
resulting state always consistent, since K+ empty TBox. Moreover, equality assertion
ever generated. transition system K+ constituted single run, incrementally
accumulates facts derived iterated application + increasing
ABox. behavior closely resembles chase tuple-generating dependencies (TGDs) data
exchange, application + corresponds parallel chase step (Deutsch, Nash, &
Remmel, 2008).
technical point view, notice K+ already normalized form (i.e., K+ = K+ ),
DO() NORM () identical since neither equality negation considered. Hence
K+ = K+ ,NORM .
next lemma shows K+ preserves weak acyclicity K.
Lemma 13 K weakly acyclic positive dominant K+ weakly acyclic.
Proof. claim follows fact that, construction, dependency graph G + K+
equal G. Indeed, qi++ connection Ai preserved K+ . Hence, get
claim.
Next show K+ weakly acyclic active domain ABoxes transition
system K+ polynomially bounded active domain initial ABox.
Lemma 14 K+ weakly acyclic, exists polynomial P()
6E Q

|ADOM(K+ )| < P(|ADOM(A0 )|).
Proof. observe exists strict connection execution K+ chase
set TGDs data exchange. Therefore, proof closely resembles one Fagin et al.
(2005, Thm. 3.9), shown weakly acyclic TGDs, every chase sequence bounded.
Let K+ = (U, , , A0 6E Q , abox , ), let G + = (V, E) dependency graph K+ ,
let n = |ADOM(A0 6E Q )|. every node p V , consider incoming path (finite
infinite) path ending p. Let rank (p) maximum number special edges
incoming path. Since K+ weakly acyclic hypothesis, G + contain cycles going
special edges, therefore rank (p) finite. Let r maximum among rank (pi )
nodes. observe r |V |; indeed path lead node twice using special
edges, otherwise G + would contain cycle going special edges, thus breaking weak
acyclicity hypothesis. Next observe partition nodes V according rank,
obtaining set sets {V0 , V1 , . . . , Vr }, Vi set nodes rank i.
Let us consider state obtained A0 6E Q applying action + contained
K+ arbitrary number times. prove, induction i, following claim:
every exists polynomial Pi total number distinct values c occur
positions Vi Pi (n).
674

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

(Base case) Consider p V0 . definition, p incoming path containing special edges.
Therefore, new values stored p along run A0 6E Q A. Indeed p store
values part initial ABox A0 6E Q . holds nodes V0 hence fix
P0 (n) = n.
(Inductive step) Consider p Vi , {1, . . . , r}. first kind values may stored
inside p values stored inside p A0 6E Q . number values
n. addition, value may stored p two reasons: either copied
position p0 Vj 6= j, generated possibly new function term, built applying
effects contain function head.
first determine number fresh individuals generated function terms.
possibility generating storing new value p result action reflected
presence special edges. definition, special edge entering p must start node
0
p0 V0 Vi1 .
P induction hypothesis, number distinct values exist p
bounded H(n) = j{0,...,i1} Pj (n). Let ba maximum number special edges
enter position, positions TBox; ba bounds arity taken function term
contained . every choice ba values V0 Vi1 (one special edge
enter position), number new values generated position p bounded tf H(n)ba ,
tf total number facts contained effects + . Note number
depend data A0 6E Q . considering positions Vi , total number values
generated bounded F(n) = |Vi | tf H(n)ba . Clearly, F() polynomial,
tf ba determined + .
count next number distinct values copied positions Vi positions
Vj , j 6= i. copy represented graph normal edge going node Vj
node Vi , j 6= i. observe first normal edges start nodes
V0 Vi1 , is, cannot start nodes Vj j > i. prove contradiction.
Assume exists p0 p E, p Vi p0 Vj j > i. case,
rank p would j > i, contradicts fact p Vi . consequence, number
distinct values copied positions Vi bounded total number values
V0 Vi1 , corresponds H(n) previous consideration.
Putting together, define Pi (n) = n + F(n) + H(n). Since Pi () polynomial,
claim proven.
Notice that, claim, bounded r, constant. Hence, exists
fixed polynomial P() number distinct values exist every state
bounded P(n). K+ inflationary, + applied copies concept role
assertions current next state. Since K+ contains single run, P(n) bound
ADOM(K+ ) well.
following lemma shows key feature positive dominant.
Lemma 15 ADOM(K ) ADOM(K+ ).
6E Q

Proof. Let K = (T, A0 , , ) K+ = (, A0 , { + }, {true 7 + }).
first observe that, every ABox K , ADOM(A) = ADOM(A6E Q ) definition K
(this role special concept Dummy).
675

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

show induction construction K (U, T, 1 , A0 , abox , 1 ) K+ =
6E Q

(U, , 2 , A0 , abox , 2 ), state A1 1 exists state A2 2
A1 6E Q A2 .
6E Q
base case holds initial states A0 A0 two transition systems definition.
inductive case, show that, given A1 1 A2 2 A1 6E Q A2 ,
A01 1 A1 1 A01 , unique state A02 2 A2 2 A02 A01 A02 .
show this, note A1 1 A01 exists action K substitution parameters
A01 = NORM (T, A1 , ). Similarly, taking account + parameters
always executable K+ , A02 = DO(T, A2 , + ) = NORM (T, A2 , + ).
construction K+ , effect e1 form
e1 : [q ++ ] q = Q

A0e1 ,

effect e2 + form
e2 : [q ++ ]

6E Q

A0e1 ,

A0e1 6E Q obtained A0e1 removing equality assertions. induction hypothesis,
A1 6E Q A2 . observing ANS ([q ++ ], , A1 6E Q ) ./ ANS ((q = Q ), , A1 )
6E Q
ANS ([q ++ ], , A2 ), obtain A0e1
A0e2 , A0e1 = APPLY NORM (T, A1 , e1 , )
A0e2 = APPLY(, A2 , e2 , ). Hence, get claim A01 6E Q A02 .
since ABox K active domain ADOM(A) ADOM(A6E Q ) identical construction, since ADOM(K ) ADOM(K+ ) simply union active
domains generated ABoxes, get claim.
7.4 Putting Together
KAB K weakly acyclic, then, Lemma 9, normalized form K weakly acyclic well
and, Lemma 13, positive dominant K+ . Hence, Lemma 14, size active
domain ADOM(K+ ) transition system K+ K+ polynomially related size
initial ABox.
Now, Lemma15, implies size active domain ADOM(K,NORM )
transition system K K polynomially related size initial ABox. Hence, number
possible states K finite, fact exponential size initial ABox.
follows checking LA formulae K done E XP IME w.r.t. size K.
Finally, Lemma 12, K K bisimilar, Bisimulation Invariance Theorem 4,
K K satisfy exactly LA formulae. Hence, check LA formula K
sufficient check K , done E XP IME. concludes proof
Theorem 7.

8. Related Work
provide detailed review work related framework results presented
previous sections.
676

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

8.1 Combining Description Logics Temporal Logics
work deeply related research studies combinations description logics temporal logics. Indeed, actions progress knowledge time and, although temporal logics
mention actions, easily used describing progression mechanisms, including transition systems (see, e.g., Clarke et al., 1999; Calvanese, De Giacomo, & Vardi, 2002).
research mostly explored combination standard description logics standard
temporal logics level models, certainly natural form combination
logical point view. Technically, form combination gives rise combined logic
two-dimensional semantics, one dimension time DL domain
(Schild, 1993; Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003). Unfortunately,
computational point view, form combination suffers key undecidability result,
makes fragile many practical purposes: possibility specifying roles
preserve extension time (the called rigid roles) causes undecidability6 . Referring
domain interest Example 1, would result, example, undecidability
theories specify instance Character livesIn City forever. Moreover,
undecidability result already holds concept satisfiability w.r.t. fixed TBox (i.e.,
TBox axioms must hold time points), without ABoxes, single rigid role (Wolter
& Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003). is, holds reasoning service
much simpler conjunctive query answering (Calvanese, De Giacomo, & Lenzerini, 2008),
even fixed TBox data (no ABox assertions, hence individual terms) one
simplest kinds temporal formulae, namely forever something true (safety) (Clarke et al.,
1999).
Decidability regained by: (i) dropping TBoxes altogether, decision problem
still hard non-elementary time (Gabbay et al., 2003); (ii) allowing temporal operators
concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Gutierrez-Basulto, Jung, & Lutz, 2012;
Jamroga, 2012), case complexity depends crucially description logic; (iii) allowing temporal operators TBox ABox assertions (Lutz, Wolter, & Zakharyaschev,
2008; Baader et al., 2012). fact cases (ii) (iii) mixed (Baader & Laux, 1995; Wolter
& Zakharyaschev, 1998).
Allowing temporal operators assertions (case (iii) above), tightly related
functional approach adopted paper: fact admit temporal operators front
assertions allows us consider temporal models whose time points actually sets models
description logic assertions. Hence keeps temporal component distinct description
logic one, exactly here. particular, results Baader et al. (2012) directly
compared ours. Apart obvious differences formalism used, one key point get
decidability individual terms mentioned ABox assertions fixed priori.
possible that, adapting techniques presented here, results could extended allow
functions denoting terms, hence allowing adding fresh individual terms temporal
evolution.

6. lose decidability, suffices able specify/verify persistence binary predicates/roles, allows
one build infinite grid hence encode Turing-machine computation (Robinson, 1971; van Emde Boas,
1997).

677

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

8.2 Combining Description Logics Actions
Somehow hampered undecidability results mentioned beginning section,
combinations description logics action theories studied years. particular,
Liu, Lutz, Milicic, Wolter (2006b, 2006a) study combinations description logics action
theories level models, w.r.t. two classical problems reasoning actions,
namely projection executability. problems require explicitly give sequence
actions check property resulting final state (projection), check executability
sequence actions, comes certain precondition (Reiter, 2001).
sophisticated temporal properties (in particular, forever something true mentioned above) would
lead undecidability. way, notice undecidability result deeply questions
computational point view possibility adding (sound complete) automated reasoning
capabilities proposals OWL-S (Semantic Markup Web Services) (Martin, Paolucci,
McIlraith, Burstein, McDermott, McGuinness, Parsia, Payne, Sabou, Solanki, Srinivasan, & Sycara,
2004).
Possibly first proposal based implicitly functional view KB pioneering
work De Giacomo, Iocchi, Nardi, Rosati (1999), adopts epistemic description logic
(based certain answers) combined action formalism describe routines mobile
robot. Again, one important point individual terms bounded fixed priori.
functional view approach first spelled Calvanese, De Giacomo, Lenzerini,
Rosati (2007), Calvanese et al. (2011). work, projection executability
studied, however distinction KB states actions (there specified
updates), framework gives rise single transition system whose states labeled
KBs (in fact TBox fixed ABox changes state state). However, again,
individual terms considered fixed priori hence resulting transition system finite.
So, although studied work, sophisticated forms temporal properties proposed
readily verifiable setting. Interestingly, apart KBs action, work
Golog-like programs considered. programs whose atomic actions defined
action formalism, combined using (usual less usual) programming constructs,
sequence, while-loop, if-then-else, nondeterministic pick value (Levesque, Reiter,
Lesperance, Lin, & Scherl, 1997; De Giacomo, Lesperance, & Levesque, 2000). important
characteristic programs finite number control states (notice
memory storage programs kept action theory, KB case). Although
scope paper, finiteness allows easily extending results program
well.
interesting alternative way combine description logics reasoning actions
one reported Gu Soutchanski (2010). There, description logics KB7 used special
FOL theory describing initial situation situation calculus basic action theory (Reiter, 2001).
Notice result, TBox assertions act state constraints (Lin & Reiter, 1994),
would lead undecidability discussed (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay
et al., 2003), fact essentially persist way actions.

7. actually mainly focus concepts description logic includes universal role, allows
one express TBox assertions concepts (Baader et al., 2003).

678

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

8.3 Description Logics Update
Observe effects action setting seen basic form update previous
state (Katsuno & Mendelzon, 1991). Although mechanism sidesteps semantic computational difficulties description logic KB update (Liu et al., 2006b; De Giacomo, Lenzerini, Poggi,
& Rosati, 2009; Calvanese, Kharlamov, Nutt, & Zheleznyakov, 2010; Lenzerini & Savo, 2012)
simply rejecting execution actions would lead inconsistent state. Adopting proper
forms update setting interesting issue future research.
8.4 Artifacts Data-Aware Processes
work closely related research verification artifact-centric business processes
(Nigam & Caswell, 2003; Bhattacharya et al., 2007). Artifact-centric approaches model business
processes giving equal importance control-flow perspective data interest.
artifact typically represented tuple schema, models artifact type, together
set actions/services specify information maintained artifact
manipulated time. action usually represented terms pre- post-conditions
respectively used determine action eligible execution, relate
current artifact state successor state obtained action execution. Pre- postconditions modeled first-order formulae, post-conditions employ existentially quantified
variables account external inputs environment. Differently KABs,
approaches targeting artifact-centric processes assume complete information data, using
relational database maintain artifacts information. paper, aim works
verify whether relational artifact-centric process meets temporal/dynamic property,
formalized using first-order variants branching linear temporal logics.
work Deutsch et al. (2009), infinite domain artifacts database equipped
dense linear order, mentioned pre-conditions, post-conditions, properties.
Runs receive unbounded external input infinite domain. Decidability verification
achieved avoiding branching time properties, restricting formulae used specify
pre-, post-conditions properties. particular, approach refers read-only read-write
database relations differently, querying latter checking whether contain given tuple constants. authors show restriction tight, integrity constraints cannot
added framework, since even single functional dependency leads undecidability
verification. Damaggio et al. (2011) extend approach disallowing read-write relations,
allows extension decidability result integrity constraints expressed embedded
dependencies terminating chase, decidable arithmetic. major difference
approach, concepts KAB considered read-write relations,
arbitrarily queried determine progression system. Differently works,
Belardinelli et al. (2011) consider first-order variant CTL quantification across states
verification formalism. framework supports incorporation new values external environment parameters actions; corresponding execution semantics considers
possible actual values, thus leading infinite-state transition systems. decidability verification, authors show that, assumption state system
(constituted union artifacts relational instances) bounded active domain, possible construct faithful abstract transition system which, differently original one,
finite number states. Belardinelli, Lomuscio, Patrizi (2012) improve results Belar679

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

dinelli et al. (2011) introducing semantic property uniformity which, roughly speaking,
says transition system representing execution process study able
distinguish among states constants patterns data. assumptions uniformity state boundedness, decidability verification achieved richer
logic, namely CTL quantification across states, interpreted active domain semantics.
notion state boundedness adopted independently developed framework
Bagheri Hariri, Calvanese, De Giacomo, Deutsch, Montali (2012, 2013), first-order
variants -calculus, similar one considered here, considered. There, beside differences
way data external information modeled, sufficient syntactic conditions guarantee state boundedness proposed. works developed within relational database
setting, extend trivially systems actions change DL knowledge bases.
connection data-/artifact-centric business processes data exchange exploit paper first established Cangialosi et al. (2010), De Giacomo, De Masellis,
Rosati (2012). transition relation described terms TGDs, map
current state, represented relational database instance, next one. Null values used
model incorporation new, unknown data system. process evolution essentially
form chase. suitable weak acyclicity conditions chase terminates, guaranteeing,
turn, system finite-state. Decidability shown first-order -calculus without
first-order quantification across states. approach extended Bagheri Hariri et al. (2011),
TGDs replaced actions rule-based process follow structure
KAB action component. revised framework, values imported external environment represented uninterpreted function terms, play role nulls
work Cangialosi et al. (2010), De Giacomo et al. (2012). Since Bagheri Hariri et al.
(2011), Cangialosi et al. (2010), De Giacomo et al. (2012) rely purely relational setting, choice leads ad-hoc interpretation equality, null value/function term
considered equal itself. Differently works, allow sophisticated
schema constraints, i.e., TBox itself, provide time fine-grained treatment
equality, individuals inferred equal due application schema
constraints and/or execution action. treatment equality differentiates work
one Bagheri Hariri, Calvanese, De Giacomo, De Masellis (2011), introduces preliminary version framework presented, UNA assumed equality
considered. specifically, Bagheri Hariri et al. (2011) propose semantic artifacts
means represent artifacts corresponding processes higher level abstraction relational artifacts, representing artifact data semantically rich knowledge base operating
incomplete information. KABs constitute general framework, seamlessly
customized account semantic artifacts. major difference work Bagheri Hariri
et al. (2011) constituted verification formalism. particular, works focus
form -calculus ECQs used query states system, Bagheri Hariri et al.
(2011) support quantification across states, done here.
Calvanese et al. (2012) investigate framework data-centric processes mixes approach proposed Bagheri Hariri et al. (2013) relational artifacts notion knowledge
bases used here. particular, semantically-governed data-aware processes introduced
mechanism model dynamic system working relational database, providing
time conceptual representation manipulated data terms DL-Lite knowledge base.
relying ontology-based data access (Calvanese et al., 2009), declarative mappings used
680

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

connect knowledge base underlying relational database. Differently KABs,
system evolves relational layer, knowledge base used understand ultimately
govern execution higher level abstraction.
observe results presented fully subsume Bagheri Hariri et al. (2011),
underlying description logic OWL 2 QL. one hand, remove possibility
asserting functionality roles knowledge component, equating individuals result action action component, precisely obtain setting presented Bagheri Hariri
et al. (2011). hand, frameworks established complexity upper bounds
same.

9. Conclusions
paper studied verification knowledge action bases, dynamic systems
constituted knowledge base, expressed description logics, action specification
changes knowledge base time. obtained interesting decidability result
relying notion weak acyclicity, based connection theory chase TGDs
relational databases.
work, used original notion weak acyclicity. However, easy adopt
advanced forms acyclicity, since results depend ability finding finite
bound number distinct function terms generated (when applying chase).
majority approaches adopt forms weak-acyclicity focus databases (Marnette &
Geerts, 2010; Meier, Schmidt, Wei, & Lausen, 2010), Cuenca Grau, Horrocks, Krotzsch, Kupke,
Magka, Motik, Wang (2012) investigate sophisticated forms acyclicity context
knowledge bases without UNA. results thus seamlessly applied KABs. Interestingly,
manage impact equalities setting without UNA, resort singularization technique presented Marnette (2009), closely resembles normalization KABs introduced
Section 7.
Weak acyclicity allows us gain decidability bounding number distinct function
terms occur transition system. alternative approach gain decidability bound
number distinct terms occurring ABox assertions state. Variants notion state
boundedness proposed recently contexts (Belardinelli et al., 2012; De Giacomo,
Lesperance, & Patrizi, 2012; Bagheri Hariri et al., 2013). great interest explore
approach setting presented actions acting description logic knowledge base.
observe decidability result (as well ones commented Section 8),
comes algorithm verification exponential size initial ABox. precludes direct application techniques large-scale systems, without careful analysis
modularized small units verified (almost) separately. important
direction investigation.
Acknowledgments
research partially supported EU ICT Collaborative Project ACSI
(Artifact-Centric Service Interoperation), grant agreement n. FP7-257593, large-scale
integrating project (IP) Optique (Scalable End-user Access Big Data), grant agreement n. FP7318338.
681

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

References
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). DL-Lite family
relations. J. Artificial Intelligence Research, 36, 169.
Artale, A., & Franconi, E. (1998). temporal description logic reasoning actions
plans. J. Artificial Intelligence Research, 9, 463506.
Artale, A., & Franconi, E. (2005). Temporal description logics. Gabbay, D., Fisher, M., & Vila, L.
(Eds.), Handbook Temporal Reasoning Artificial Intelligence, Foundations Artificial
Intelligence. Elsevier.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.). (2003).
Description Logic Handbook: Theory, Implementation Applications. Cambridge University Press.
Baader, F., Ghilardi, S., & Lutz, C. (2012). LTL description logic axioms. ACM Trans.
Computational Logic, 13(3), 21:121:32.
Baader, F., & Laux, A. (1995). Terminological logics modal operators. Proc. 14th
Int. Joint Conf. Artificial Intelligence (IJCAI95), pp. 808814.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., & De Masellis, R. (2011). Verification
conjunctive-query based semantic artifacts. Proc. 24th Int. Workshop Description Logic (DL 2011), Vol. 745 CEUR Electronic Workshop Proceedings, http:
//ceur-ws.org/.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., De Masellis, R., & Felli, P. (2011). Foundations
relational artifacts verification. Proc. 9th Int. Conference Business Process
Management (BPM 2011), Vol. 6896 Lecture Notes Computer Science, pp. 379395.
Springer.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., Deutsch, A., & Montali, M. (2012). Verification relational data-centric dynamic systems external services. Corr technical report arXiv:1203.0024, arXiv.org e-Print archive. Available http://arxiv.org/abs/
1203.0024.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., Deutsch, A., & Montali, M. (2013). Verification
relational data-centric dynamic systems external services. Proc. 32nd ACM
SIGACT SIGMOD SIGART Symp. Principles Database Systems (PODS 2013).
Bao, J., et al. (2012). OWL 2 Web Ontology Language document overview (second edition). W3C
Recommendation, World Wide Web Consortium. Available http://www.w3.org/
TR/owl2-overview/.
Belardinelli, F., Lomuscio, A., & Patrizi, F. (2011). Verification deployed artifact systems via data
abstraction. Proc. 9th Int. Joint Conf. Service Oriented Computing (ICSOC 2011),
Vol. 7084 Lecture Notes Computer Science, pp. 142156. Springer.
Belardinelli, F., Lomuscio, A., & Patrizi, F. (2012). abstraction technique verification
artifact-centric systems. Proc. 13th Int. Conf. Principles Knowledge
Representation Reasoning (KR 2012), pp. 319328.
Berardi, D., Calvanese, D., & De Giacomo, G. (2005). Reasoning UML class diagrams. Artificial
Intelligence, 168(12), 70118.
682

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

Bhattacharya, K., Gerede, C., Hull, R., Liu, R., & Su, J. (2007). Towards formal analysis artifactcentric business process models. Proc. 5th Int. Conference Business Process
Management (BPM 2007), Vol. 4714 Lecture Notes Computer Science, pp. 288234.
Springer.
Burkart, O., Caucal, D., Moller, F., & Steffen, B. (2001). Verification infinite structures..
Handbook Process Algebra. Elsevier Science.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodrguez-Muro, M., &
Rosati, R. (2009). Ontologies databases: DL-Lite approach. Tessaris, S., & Franconi, E. (Eds.), Reasoning Web. Semantic Technologies Informations Systems 5th Int.
Summer School Tutorial Lectures (RW 2009), Vol. 5689 Lecture Notes Computer Science, pp. 255356. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007a). EQL-Lite: Effective first-order query processing description logics. Proc. 20th Int. Joint Conf.
Artificial Intelligence (IJCAI 2007), pp. 274279.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007b). Tractable reasoning efficient query answering description logics: DL-Lite family. J. Automated
Reasoning, 39(3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2013). Data complexity
query answering description logics. Artificial Intelligence, 195, 335360.
Calvanese, D., De Giacomo, G., Lembo, D., Montali, M., & Santoso, A. (2012). Ontology-based
governance data-aware processes. Proc. 6th Int. Conf. Web Reasoning Rule
Systems (RR 2012), Vol. 7497 Lecture Notes Computer Science, pp. 2541. Springer.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2008). Conjunctive query containment answering description logics constraints. ACM Trans. Computational Logic, 9(3),
22.122.31.
Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2007). Actions programs description logic ontologies. Proc. 20th Int. Workshop Description Logic (DL 2007),
Vol. 250 CEUR Electronic Workshop Proceedings, http://ceur-ws.org/, pp. 29
40.
Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2011). Actions programs
description logic knowledge bases: functional approach. Lakemeyer, G., & McIlraith,
S. A. (Eds.), Knowing, Reasoning, Acting: Essays Honour Hector Levesque. College
Publications.
Calvanese, D., De Giacomo, G., & Montali, M. (2013). Foundations data aware process analysis:
database theory perspective. Proc. 32nd ACM SIGACT SIGMOD SIGART Symp.
Principles Database Systems (PODS 2013).
Calvanese, D., De Giacomo, G., & Vardi, M. Y. (2002). Reasoning actions planning
LTL action theories. Proc. 8th Int. Conf. Principles Knowledge Representation Reasoning (KR 2002), pp. 593602.
Calvanese, D., Kharlamov, E., Nutt, W., & Zheleznyakov, D. (2010). Updating ABoxes DL-Lite.
Proc. 4th Alberto Mendelzon Int. Workshop Foundations Data Management
683

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

(AMW 2010), Vol. 619 CEUR Electronic Workshop Proceedings, http://ceur-ws.
org/, pp. 3.13.12.
Cangialosi, P., De Giacomo, G., De Masellis, R., & Rosati, R. (2010). Conjunctive artifact-centric
services. Proc. 8th Int. Joint Conf. Service Oriented Computing (ICSOC 2010),
Vol. 6470 Lecture Notes Computer Science, pp. 318333. Springer.
Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model checking. MIT Press, Cambridge,
MA, USA.
Cohn, D., & Hull, R. (2009). Business artifacts: data-centric approach modeling business
operations processes. Bull. IEEE Computer Society Technical Committee Data
Engineering, 32(3), 39.
Cuenca Grau, B., Horrocks, I., Krotzsch, M., Kupke, C., Magka, D., Motik, B., & Wang, Z. (2012).
Acyclicity conditions application query answering description logics.
Proc. 13th Int. Conf. Principles Knowledge Representation Reasoning
(KR 2012), pp. 243253.
Damaggio, E., Deutsch, A., & Vianu, V. (2011). Artifact systems data dependencies
arithmetic. Proc. 14th Int. Conf. Database Theory (ICDT 2011), pp. 6677.
De Giacomo, G., De Masellis, R., & Rosati, R. (2012). Verification conjunctive artifact-centric
services. Int. J. Cooperative Information Systems, 21(2), 111139.
De Giacomo, G., Iocchi, L., Nardi, D., & Rosati, R. (1999). theory implementation
cognitive mobile robots. J. Logic Computation, 9(5), 759785.
De Giacomo, G., Lenzerini, M., Poggi, A., & Rosati, R. (2009). instance-level update erasure description logic ontologies. J. Logic Computation, Special Issue Ontology
Dynamics, 19(5), 745770.
De Giacomo, G., Lesperance, Y., & Levesque, H. J. (2000). ConGolog, concurrent programming
language based situation calculus. Artificial Intelligence, 121(12), 109169.
De Giacomo, G., Lesperance, Y., & Patrizi, F. (2012). Bounded situation calculus action theories
decidable verification. Proc. 13th Int. Conf. Principles Knowledge
Representation Reasoning (KR 2012), pp. 467477.
Deutsch, A., Hull, R., Patrizi, F., & Vianu, V. (2009). Automatic verification data-centric business
processes. Proc. 12th Int. Conf. Database Theory (ICDT 2009), pp. 252267.
Deutsch, A., Nash, A., & Remmel, J. B. (2008). chase revisited. Proc. 27th ACM
SIGACT SIGMOD SIGART Symp. Principles Database Systems (PODS 2008), pp. 149
158.
Fagin, R., Kolaitis, P. G., Miller, R. J., & Popa, L. (2005). Data exchange: Semantics query
answering. Theoretical Computer Science, 336(1), 89124.
Gabbay, D., Kurusz, A., Wolter, F., & Zakharyaschev, M. (2003). Many-dimensional Modal Logics:
Theory Applications. Elsevier Science Publishers.
Gu, Y., & Soutchanski, M. (2010). description logic based situation calculus. Ann. Mathematics
Artificial Intelligence, 58(1-2), 383.
684

fiD ESCRIPTION L OGIC K NOWLEDGE ACTION BASES

Gutierrez-Basulto, V., Jung, J. C., & Lutz, C. (2012). Complexity branching temporal description
logics. Proc. 20th Eur. Conf. Artificial Intelligence (ECAI 2012), pp. 390395.
Jamroga, W. (2012). Concepts, agents, coalitions alternating time. Proc. 20th Eur.
Conf. Artificial Intelligence (ECAI 2012), pp. 438443.
Katsuno, H., & Mendelzon, A. (1991). difference updating knowledge base
revising it. Proc. 2nd Int. Conf. Principles Knowledge Representation
Reasoning (KR91), pp. 387394.
Kowalski, R. A., & Sadri, F. (2011). Abductive logic programming agents destructive
databases. Ann. Mathematics Artificial Intelligence, 62(12), 129158.
Lenzerini, M., & Savo, D. F. (2012). Updating inconsistent description logic knowledge bases.
Proc. 20th Eur. Conf. Artificial Intelligence (ECAI 2012), pp. 516521.
Levesque, H. J., Reiter, R., Lesperance, Y., Lin, F., & Scherl, R. (1997). GOLOG: logic programming language dynamic domains. J. Logic Programming, 31, 5984.
Levesque, H. J. (1984). Foundations functional approach knowledge representation. Artificial
Intelligence, 23, 155212.
Limonad, L., De Leenheer, P., Linehan, M., Hull, R., & Vaculin, R. (2012). Ontology dynamic
entities. Proc. 31st Int. Conf. Conceptual Modeling (ER 2012).
Lin, F., & Reiter, R. (1994). State constraints revisited. J. Logic Programming, 4(5), 655678.
Liu, H., Lutz, C., Milicic, M., & Wolter, F. (2006a). Reasoning actions using description
logics general TBoxes. Proc. 10th Eur. Conference Logics Artificial
Intelligence (JELIA 2006), Vol. 4160 Lecture Notes Computer Science. Springer.
Liu, H., Lutz, C., Milicic, M., & Wolter, F. (2006b). Updating description logic ABoxes. Proc.
10th Int. Conf. Principles Knowledge Representation Reasoning (KR 2006),
pp. 4656.
Lutz, C., Wolter, F., & Zakharyaschev, M. (2008). Temporal description logics: survey. Proc.
15th Int. Symp. Temporal Representation Reasoning (TIME 2008), pp. 314.
Marnette, B. (2009). Generalized schema-mappings: termination tractability. Proc.
28th ACM SIGACT SIGMOD SIGART Symp. Principles Database Systems
(PODS 2009), pp. 1322.
Marnette, B., & Geerts, F. (2010). Static analysis schema-mappings ensuring oblivious termination. Proc. 13th Int. Conf. Database Theory (ICDT 2010), pp. 183195.
Martin, D., Paolucci, M., McIlraith, S., Burstein, M., McDermott, D., McGuinness, D., Parsia, B.,
Payne, T., Sabou, M., Solanki, Srinivasan, N., & Sycara, K. (2004). Bringing semantics
web services: OWL-S approach. Proc. 1st Int. Workshop Semantic Web
Services Web Process Composition (SWSWPC 2004).
Meier, M., Schmidt, M., Wei, F., & Lausen, G. (2010). Semantic query optimization presence
types. 111-122 (Ed.), Proc. 29th ACM SIGACT SIGMOD SIGART Symp.
Principles Database Systems (PODS 2010).
Meyer, A., Smirnov, S., & Weske, M. (2011). Data business processes. EMISA Forum, 31(3),
531.
685

fiBAGHERI H ARIRI , C ALVANESE , E G IACOMO , E ASELLIS , F ELLI , & ONTALI

Milner, R. (1971). algebraic definition simulation programs. Proc. 2nd Int.
Joint Conf. Artificial Intelligence (IJCAI71), pp. 481489.
Motik, B., Cuenca Grau, B., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2012). OWL 2 Web Ontology Language profiles (second edition). W3C Recommendation, World Wide Web Consortium. Available http://www.w3.org/TR/owl2-profiles/.
Nigam, A., & Caswell, N. S. (2003). Business artifacts: approach operational specification.
IBM Systems Journal, 42(3), 428445.
Park, D. M. R. (1976). Finiteness Mu-ineffable. Theoretical Computer Science, 3(2), 173181.
Poggi, A., Lembo, D., Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2008). Linking
data ontologies. J. Data Semantics, X, 133173.
Reiter, R. (2001). Knowledge Action: Logical Foundations Specifying Implementing
Dynamical Systems. MIT Press.
Robinson, R. (1971). Undecidability nonperiodicity tilings plane. Inventiones Math.,
12, 177209.
Rosati, R., & Franconi, E. (2012). Generalized ontology-based production systems. Proc.
13th Int. Conf. Principles Knowledge Representation Reasoning (KR 2012), pp.
435445. AAAI Press.
Schild, K. (1993). Combining terminological logics tense logic. Proc. 6th Portuguese
Conf. Artificial Intelligence (EPIA93), Vol. 727 Lecture Notes Computer Science,
pp. 105120. Springer.
Stirling, C. (2001). Modal Temporal Properties Processes. Springer.
van Ditmarsch, H., van der Hoek, W., & Kooi, B. (2007). Dynamic epistemic logic. Springer.
van Emde Boas, P. (1997). convenience tilings. Sorbi, A. (Ed.), Complexity, Logic,
Recursion Theory, Vol. 187 Lecture Notes Pure Applied Mathematics, pp. 331363.
Marcel Dekker Inc.
Vianu, V. (2009). Automatic verification database-driven systems: new frontier. Proc.
12th Int. Conf. Database Theory (ICDT 2009), pp. 113.
Wolter, F., & Zakharyaschev, M. (1998). Satisfiability problem description logics modal
operators. Proc. 6th Int. Conf. Principles Knowledge Representation
Reasoning (KR98), pp. 512523.
Wolter, F., & Zakharyaschev, M. (1999a). Modal description logics: Modalizing roles. Fundamenta
Informaticae, 39(4), 411438.
Wolter, F., & Zakharyaschev, M. (1999b). Temporalizing description logic. Gabbay, D., &
de Rijke, M. (Eds.), Frontiers Combining Systems, pp. 379402. Studies Press/Wiley.

686


