journal artificial intelligence

submitted published

short long supports constraint propagation
peter nightingale
ian p gent
christopher jefferson
ian miguel

pwn st andrews ac uk
ian gent st andrews ac uk
caj st andrews ac uk
ijm st andrews ac uk

school computer science university st andrews
st andrews fife ky sx uk

abstract
special purpose constraint propagation frequently make implicit use short
supports examining subset variables infer support justification
variable value pair may still form part assignment satisfies constraint
variables values save substantial work short supports
studied right two main contributions identification short supports important constraint propagation introduction
haggisgac efficient effective general purpose propagation exploiting short supports given complexity haggisgac present optimised
version simpler shortgac although experiments demonstrate efficiency shortgac compared general purpose propagation
compact set short supports available theoretically experimentally
haggisgac even better haggisgac performs better
gac schema full length supports introduce variant haggisgacstable adapted avoid work backtracking cases faster
significant reductions memory use proposed excellent
propagating disjunctions constraints experiments disjunctions found
faster constructive gac schema least order
magnitude three orders magnitude

introduction
constraint solvers typically employ systematic backtracking search interleaving choice
assignment decision variable propagation constraints determine
consequences assignment made propagation broadly divided
two types first specialised reason efficiently constraint patterns
occur frequently examples include global cardinality constraint regin
element constraint gent jefferson miguel b feasible
support every possible constraint expression specialised propagator way
case general purpose constraint propagators gac schema bessiere regin
gac bessiere regin yap zhang str lecoutre
mddc cheng yap used typically expensive specialised
propagators important tool specialised propagator available
support constraint domain value variable justification value
may still form part assignment satisfies constraint usually given terms
set literals variable value pairs corresponding possible assignments
c

ai access foundation rights reserved

finightingale gent jefferson miguel

variables constraint one efficiencies typically found specialised propagators
use short supports examining subset variables infer support
variables values save substantial work use typically implicit
e achieved specialised examine variables
cases one contributions highlight general importance short supports
example consider element constraint xy z x x x
z constraint satisfied iff element position vector x x x
equals z consider set literals x z set clearly satisfies
definition constraint xy z contain literal variable
extension valid literals variables x x support example
short support
previous work introduced shortgac nightingale gent jefferson miguel
general purpose propagation exploits short supports introduction shortgac general purpose propagators relied upon supports involving
variables develop concept introduce
haggisgac consistently efficient shortgac available
use compact sets short supports allows haggisgac outperform greatly existing general purpose propagation cases haggisgac even approaches
performance special purpose propagators haggisgac well suited
propagating disjunctions constraints outperforms traditional constructive
lagerkvist schulte wurtz muller orders magnitude
haggisgac efficient gac schema full length supports
describe variant haggisgac stable supports need deleted
backtracking applied full length supports version greatly reduced memory
usage
shortgac haggisgac haggisgac stable instantiated function named findnewsupport similar gac schema way function
specific constraint generate short supports procedurally alternatively
generic findnewsupport retrieve short supports data structure
section presents necessary background section introduces concept
short support section outlines basic idea used deal implicit supports
throughout section gives full details shortgac including complexity
key operations alternative implementations short supports provided list
form section presents haggisgac development shortgac
shortgac haggisgac evaluated experimentally section section
describes haggisgac stable corresponding experiments section finally
sections discuss related work present conclusions

haggisgac named legendary wild haggis scotland short legs long
legs walking around hills namesake haggisgac copes full length shorter
supports originates scotland details wild haggis found wikipedia http
en wikipedia org wiki wild haggis veterinary record king cromarty paterson
boyd



fishort long supports constraint propagation

supports gac triggers
constraint satisfaction csp defined set variables x function
maps variable domain x z domain finite set set
constraints c constraint c c relation subset variables x
scope constraint c named scope c set variables c constrains
solution csp function x z maps variable x x value
x every constraint c c values scope c form tuple
c e constraint satisfied
systematic search solution csp values progressively removed
domains therefore distinguish initial domains current
domains function refers current domains unless stated otherwise literal
defined variable value pair written x v literal x v valid v
current domain x e v x
definition support support constraint c domains defined
set valid literals contains exactly one valid literal variable scope c
satisfies c necessary disambiguation call support full length
support simply long support contrast short supports defined later
property commonly established constraint propagation generalised
arc consistency gac mackworth constraint c gac exists
full length support every valid literal every variable scope c gac established
identifying literals x v full length support exists removing v
domain x consider establishing gac
gac propagation usually situated systematic search hence
must operate three contexts initialisation root node support established
scratch following deletion one domain values branching
decision propagation constraints support must established
selectively upon backtracking data structures must restored correct
state point search primary focus second context operation
following value deletion although discuss efficient backtracking section
gac propagation would typically called deleted domain value
turn called domain value constraint
gac
propagation present concept active support inspired
gac schema bessiere regin active support support currently
use support set literals literal set active supports support
active support found invalid removed set
literal empty say literal lost support support sought literal
found support becomes active support found literal
support deleted
propagation present efficiency make use watched literals
provided minion gent et al b propagators need called every
deleted domain value establish gac say propagators attach remove triggers
literals domain value v variable x deleted propagator called


finightingale gent jefferson miguel

trigger attached literal x v means literal
deleted attached trigger zero work incurred emphasise
use watched literals fundamental work available
given solver need minor adaptation called literal
removal may return immediately literal active support
checked time thus fit traditional fine grained scheme
bessiere regin except cases invoked
use watched literals

short supports
concept short support generalisation full length support defined
definition short support short support constraint c domains
defined set valid literals x v x scope c x occurs
every superset contains one valid literal variable scope c
full length support strict short support short support full length
support
definition short support includes extremes empty set short support constraint entailed e every tuple scope c within satisfies
constraint similarly every full length support necessarily short support
superset case studies see examples empty short
supports short supports happen full length
short supports used maintain gac full length support
short support provides gac support literal contained within call
explicit support literals feature short support provides
support valid literals variables contained short support
definition every valid extension short support cover variables
scope c full length support say short support gives implicit gac support
valid literals variables short support
define concept complete set short supports constraint
definition short support set short support set c set short supports
constraint c domains every full length support c
necessarily strict superset least one short support c
constraint may many short support sets gives us latitude implement one efficient compute
natural ask identify correct short supports given constraint c
simple fundamental given lemma
lemma given constraint c domains empty set short support
c iff gac propagation constraint c leads empty domain
proof short support every valid assignment variables scope c
satisfies c every assignment satisfies c iff every assignment violates c every assignment violates c gac propagation constraint c leads empty


fishort long supports constraint propagation

domain complete last equivalence note assignment violate
c literals assignment supported gac propagation cannot cause
empty domain
lemma two important consequences first check short support
correctness empty support check short support x v xk
vk simply set x v xk vk assignments extend
short support iff lemma applies check correctness
propagating c seeing domain emptied
second consequence negative however determining whether gac propagation
empty domain polynomially equivalent actually performing gac propagation
bessiere hebrard hnich walsh since constraints np hard gac
propagate follows easy even check empty set short support
thus cannot expect method fast general finding short
supports constraint
given provable difficulty finding short supports set full length supports
construct sets short supports specifically three experimental case studies
section focus value strict short supports
given system situation analogous important area
constraints namely exploiting symmetries constraint gent petrie
puget large majority assumed sets symmetries
provided system even though finding sets hard inhibited
exploiting symmetry within automated detection symmetry
become important subarea mears puget however leave automated
construction compact short support sets future analogously patterns
matrix symmetries flener frisch hnich kiziltan miguel pearson walsh
least identify pattern often lets us identify strict short supports
describe
short supports disjunction
strict short supports arise naturally disjunctions constraint expressed
disjunction shorter constraints set strict short supports constructed
suppose following constraint
c x x x x c x x c x x c c x
suppose x x valid assignment satisfies c satisfy
c satisfy c regardless values x x therefore x x
strict short support c
lemma given constraint c domain set set constraints c ck
ci c ck scope ci scope c c c ck following short support
set write fls ci mean full length supports ci w r domains
c fls c fls ck


finightingale gent jefferson miguel

proof element c short support according definition
semantics disjunction b c short support set definition every fulllength support c must satisfy disjunct ci therefore full length support contains
full length support ci included c
lemma allows short support set created disjunction given initial
domains two three case studies third set prohibitively
large
similar lemma create function generates short
supports demand function takes valid literal x v current domains
returns short support supports x v explicitly implicitly null
none exists function constructed follows create domains
x v otherwise identical disjunct satisfiable
function returns null otherwise function picks disjunct ck satisfiable
returns satisfying assignment ck valid
three case studies section created function follows scheme
optimisations
propagating disjunctions recognised important topic many papers
published area wurtz muller lhomme lagerkvist schulte
jefferson moore nightingale petrie exploiting strict short supports
shortgac haggisgac haggisgac stable allows us outperform
traditional constructive wurtz muller orders magnitude
backtrack stability short supports
within search tree propagation often spend significant time backtracking
data structures reducing eliminating backtracking improve efficiency example
avoiding backtracking triggers speed simple table propagator times
gent et al b mac mac much efficient space
time backtracking avoided regin two potential advantages
reducing use backtracking state saves time restoring data structures saves
space avoiding storing supports backtrack stack
definition backtrack stable short support constraint c current domains
backtrack stable iff remains short support according definition
backtracking search tree
short support may support variable x implicitly backtrack may
add values back domain x consistent meaning
longer meets definition short support give example
example consider constraint b x boolean variable b array
variables variables x b assigned false constraint entailed
empty short support used support literals x
support backtrack stable backtracking true restored domain
b empty set longer short support


fishort long supports constraint propagation

support full length backtrack stable whenever support valid
supports literals contains backtrack stable supports exist use
full length supports cases gac schema although may much longer
necessary
section exploit backtrack stability define

shortgac overview
section summarises key ideas shortgac propagation along
illustrative example
shortgac maintains set short supports sufficient support valid literals
variables scope constraint propagating refer active
supports rests exploiting observation short supports
support established literal two ways first usual short support
contains literal supports literal second literal x v supported short
support contains literal variable x hence short supports
support x v contain literal x w value w v
following data structures central operation shortgac
numsupports total number active short supports
supportspervar array indexed x indicating number active short supports
containing variable x
supportlistperlit array indexed x v lists active short supports containing literal x v
number supports containing variable x less total number
supports exists support contain x therefore supports
literals x spends time processing variables whose literals
known supported way variables involved active supports
seek support literals active supports
illustrate consider element example introduction xy z
x x x z constraint satisfied iff element
position vector x x x equals z suppose current state shortgac storing
one support x z data structures follows
indicates literal valid
details present different presented previously nightingale et al
optimised data structures compared previous work two
significant changes longer keep count supports per literal saving overhead maintaining
data stored one dimensional vector literal instead two dimensional array
variable value saving space variables constraint different domain sizes experiments
appendix demonstrate data structures presented perform better
previous implementation
clarity presented one dimensional array supportlistperlit two dimensional format



finightingale gent jefferson miguel

supports
supportlistperlit
value




supportspervar
numsupports

x
z
variable
x x














x







z






values x x support since supportspervar counters
less numsupports therefore shortgac ignore x x
look supports x z consider finding support literals
z shortgac ignore literals least one support case z
looks literals z supportlistperlit z z
literal shortgac seeks support possible support
b x z following discovery update data structures
supports
supportlistperlit
value




supportspervar
numsupports


b
x






x
z
x
z
variable
x
x

b

b













z
b





variable x fully supported since supportspervar x numsupports
remain three literals support established z z
first two shortgac finds supports c x z
x z support exists z deleted giving
supports

supportlistperlit
value




supportspervar
numsupports


b
c

x


c



z
z
z
z
variable
x

c

b








x
x
x
x
x
b









z
b

c



valid literals supported nothing need done change
state removal value branching decision propagation


fishort long supports constraint propagation

shortgac details
key tasks implementing shortgac data structure update iteration
variables supportspervar equals numsupports iteration unsupported
values variable section describes infrastructure allows us perform
tasks efficiently
shortgac data structures
active short support arity k provides explicit support k literals
contains therefore reference must appear k lists supportlistperlit
represent two types object shortsupport shortsupportcell
shortsupport object contains k shortsupportcell objects contains literal
x v reference parent shortsupport elements array supportlistperlit doubly linked lists shortsupportcells reference parent
shortsupport iterate active short supports given literal
iterates variables x supportspervar x equals numsupports
following data structure represents partition variables number supports allows constant time size checking linear time iteration cell
partition allows variable moved adjacent cell e number
supports increases decreases constant time inspired indexed
dependency array gecode schulte tack
varsbysupport array containing permutation variables variables ordered
non decreasing number active supports supportspervar x
supportnumlowidx array integers indexed number literals
maximum number active supports possible supportnumlowidx
smallest index varsbysupport active supports
variables supportnumlowidx k k total number variables
k acts sentinel value set variables supports
varsbysupport supportnumlowidx supportnumlowidx
initially variables active supports supportnumlowidx rest
array set k
following table illustrates partition data structure works different
example variables suppose supportspervar x changed x
boxed swapped varsbysupport cell boundary moved x
lower cell consequently supportnumlowidx incremented
varsbysupport
supportspervar
x updated

w

w

w

w



x

x

x

x











x

x

z

z

z

z

z

z

literal x v represented single integer mapping x v
allows access x v vice versa



finightingale gent jefferson miguel

require sup shortsupport
sc shortsupportcell sup

x v sc literal

supportlistperlit x v

attachtrigger x v

add sc doubly linked list supportlistperlit x v

supportspervar x

sx supportspervar x

cellend supportnumlowidx sx

swap x varsbysupport cellend

supportnumlowidx sx numsupports

procedure addsupport sup
variable x supportspervar x numsupports shortgac iterates
values zero explicit supports avoid iterating values use set data
structure
zerolits array indexed x stacks containing literals variable x zero
explicit support particular order
inzerolits array indexed x v booleans indicating whether literal x
v zerolits x
supportlistperlit x v reduced empty list inzerolits x v
false x v pushed onto zerolits x inzerolits x v set true
optimisation values eagerly removed set removed lazily
set iterated set backtracked iteration non zero value
removed swapping top stack popping lazy maintenance never
costs work overall value would removed eagerly
removed next time set iterated costing save work may
never iterate list value would restored set
use free list manage set shortsupport objects avoid cost unnecessary object construction destruction shortsupport object retrieved free list
may contain shortsupportcell objects use resizable vector data structure
size ever increased
adding deleting supports
support added deleted data structures described must
updated done procedures addsupport deletesupport
procedures iterate given short support literal update
supportlistperlit supportspervar varsbysupport supportnumlowidx procedure
inserts literal zerolits necessary briefly explain maintenance varsbysupport become important section suppose adding support
literal x v procedure additional support x must moved
next cell varsbysupport line finds end cell x swap x


fishort long supports constraint propagation

require sup shortsupport
sc shortsupportcell sup

x v sc literal

remove sc doubly linked list supportlistperlit x v

supportspervar x
supportlistperlit x v

removetrigger x v

inzerolits x v

inzerolits x v true

zerolits x push x v

sx supportspervar x

cellend supportnumlowidx sx

swap x varsbysupport cellend

supportnumlowidx sx
numsupports

procedure deletesupport sup

require x v v pruned domain x
supportlistperlit x v

deletesupport supportlistperlit x v pop
repeat

continueloop false

supportnumlowidx numsupports supportnumlowidx numsupports

varsbysupport

shortgac variableupdate true

continueloop true

break loop line
continueloop false

procedure shortgac propagate propagate x v

end cell subroutine swap xi xj simple procedure given locates
swaps two variables varsbysupport leaving variables unaffected
makes use second array varsbysupinv inverse mapping varsbysupport
done cell boundary decremented position x
higher cell another point note addsupport add trigger x v
sup active explicit support contain literal deletesupport
remove trigger deleted support support
finally note special purpose methods undo changes
backtracking backtracking past point support added simply
call deletesupport similarly call addsupport backtrack past supports
deletion


finightingale gent jefferson miguel

require variable x
x v zerolits x

supportlistperlit x v

remove x v zerolits x

else

v x

sup findnewsupport x v

sup null

prune x v

else

addsupport sup

supportlistperlit x v

remove x v zerolits x

return true
return false

procedure shortgac variableupdate x pseudocode abstract
detailed maintenance zerolits inzerolits data structures might seem
test line must succeed however although sup must support x v
contain x v might implicit support findnewsupport
function discussed section
propagation
shortgac propagator procedure invoked literal contained
one active short supports pruned first deletes supports involving
pruned literal checks variables implicitly supported e
supportspervar numsupports line variable checked procedure
shortgac variableupdate described call support
found data structures changed shortgac variableupdate returns
true indicate must break loop line go round
iteration therefore continues support necessary support
found
shortgac variableupdate procedure used check status every variable
lacking implicit support iterates zerolits e literals variable might
zero explicit supports since zerolits maintained lazily iteration first
check literal indeed explicit support correct zerolits necessary
lines important case literal indeed support provided
v current domain x must seek support calling findnewsupport
constraint support value v must pruned domain x
found support update data structures calling addsupport
initialise data structures root search lines procedure invoked
notice lines refer parameter x v first calling
supports initial iteration line variables
noted earlier watched literals available solver simple check made
start procedure return immediately removed literal active support



fishort long supports constraint propagation

complexity analysis shortgac
section provide complexity analysis shortgac used incrementally search constraint solver analysis parameters arity
constraint n maximum domain size cost f calling findnewsupport
assume attaching removing trigger literal case
minion
first observe swap procedure executes time operation swap
loop secondly establish time complexity procedures
addsupport deletesupport key
lemma procedure addsupport time complexity n
proof outer loop line iterates literals short support worst
case n literals consider steps within loop list test
line call attachtrigger line adding shortsupportcell
doubly linked list line following five array dereferences
established swap procedure hence addsupport n
lemma procedure deletesupport time complexity n
proof similarly add support procedure outer loop line n
iterations removal doubly linked list line array
dereferences line subsequently list test line call removetrigger line stack push operation line recalling
swap procedure deletesupport n
theorem procedure shortgac propagate time complexity n ndf
upper bound obtained e worst case time complexity n ndf
proof analysis first statement breaks three parts
first loop line elements supportlistperlit worst case occurs
nd literals explicit support supports maximum n
involve particular literal literal may short support every
literal every variable n cost body loop
n lemma total n dominated next part
second part loop lines maximum number iterations
line n supports full length iteration line contains n
variables successive calls procedure line add supports
support addition triggers restart loop beginning line n
variables total n calls procedure call involves
iterations loop line procedure therefore innermost loop run
n times
complete proof first statement consider cost innermost loop
procedure within loop operations exceptions call
findnewsupport line cost f call addsupport line cost n
lemma f dominating cost since must least traverse support
record however n iterations nd calls findnewsupport


finightingale gent jefferson miguel

time valid literals explicit support cost n
ndf whichever greater case cost n ndf
upper bounds ndf n attained worst case literal
needs support ndf calls findnewsupport cost n
nd literals explicit support size n variable ends
example values supported values deleted worst case thus
n ndf
procedure invoked n times one branch search tree
therefore complexity one branch n n f
second complexity analysis
analysis conservative total number maximum size
short supports small therefore give another complexity analysis two additional
parameters maximum length l short supports returned findnewsupport
total number distinct short supports may returned findnewsupport
analysis pertains branch search rather single call propagate

first part complexity analysis concerns short supports length l
short support may added active set may deleted
branch short support must found calling findnewsupport cost f
lemma shows addsupport procedure takes n time lemma
stated terms l loop addsupport iterate l times giving
total time l applies deletesupport since short supports
cost finding adding deleting collectively processing short supports l f
branch
secondly may make calls findnewsupport return null
happen n times maximum number domain values
may deleted therefore cost ndf
addition shortgac operations charged
categories analyse must top analysis
procedure invoked times time short support invalidated lines
already charged processing short supports body loop lines may
executed times support found times
support found therefore times total branch search
come inner loop lines lemma unless domain
empty one active short support therefore l variables
contained active short supports l variables relevant
partition varsbysupport loop body executed l times
lemma initialisation procedure least one active short support
variable domain empty
proof suppose opposite invoked time literal active short
support pruned therefore delete active short supports must contain one
literal x v active short supports contain variable x values domain


fishort long supports constraint propagation

x implicitly supported must explicitly supported therefore v must
last remaining value x prune x v empties domain
contradiction
branch causes sl calls shortgac variableupdate line
call shortgac variableupdate takes time may invalid
literals explicitly supported literals zerolits time spent procedure
charged processing short supports pruning domains therefore top
analysis cost sld
overall time complexity l f ndf sld tighter bound cases
one given section example sat clause n f n l
giving time complexity n branch search
instantiation findnewsupport
similarly gac schema bessiere regin shortgac must instantiated
findnewsupport function function takes valid literal returns support one
exists otherwise returns null one way write specialist findnewsupport
function constraint empirical case studies
case findnewsupport function much simpler propagator
constraint use lemma build findnewsupport functions reduces
task finding satisfying tuples simple constraints x x
alternative write generic version findnewsupport case
short supports given list detail two generic instantiations findnewsupport lists case studies compare specialist functions
findnewsupport list
provide generic instantiation named findnewsupport list procedure takes
list short supports literal supportlist including explicit implicit
short supports literal analogous positive instantiation gacschema bessiere regin findnewsupport list persistent state listpos
array integers indexed variable value initially indicates current
position supportlist simply iterates list supports
seeking one literals valid listpos backtracked consequence
end list reached cannot fail immediately must search
start back listpos branch search tree particular element
list may looked however optimal
time space across search tree gent surprising achieved
amortizing cost across branches practically listpos stops
starting first element list seems good tradeoff avoiding
provably unnecessary work much data structure maintenance
constraint specific findnewsupport sometimes shorter supports findnewsupport list specific findnewsupport take advantage current
domains whereas supportlist may contain supports given initial domains
example constraint becomes entailed specific findnewsupport return


finightingale gent jefferson miguel

require x v supportlist
j listpos x v supportlist x v size

sup supportlist x v j

literals sup valid

listpos x v j

return sup
j listpos x v

sup supportlist x v j

literals sup valid

listpos x v j

return sup
return null

procedure findnewsupport list findnewsupport x v first block searches
location previous support end support list unsuccessful
search restarts start list second block circular removes
need backtrack listpos
empty support whereas list version presented cannot exploit fact
case study
findnewsupport ndlist
list instantiation two major disadvantages first inefficient
unable skip sets invalid tuples literature contains many solutions
context full length supports example binary search lecoutre
szymanek tries gent jefferson miguel nightingale second
require large amount memory short support potentially nd
pointers pointer literal implicitly supports
section give second generic list instantiation nextdifference lists
gent et al single list named supportlist containing short supports indexed integer second list named ndlist support
supportlist j literal support k ndlist j k index next
support contain literal k thus searching list
able jump sets short supports contain invalid literal
version findnewsupport nextdifference lists given procedure
solves list instantiation able jump
sets invalid short supports usually requires substantially less memory fact
optimal space unlike list instantiation given short supports length
l nextdifference list tl however uses one list supports therefore
spend time searching short supports support desired literal
literals assigned variables
suppose shortgac discovers support contains literal x v x assigned v since x take value v sound remove x v
save overhead adding apply minor optimisation cases
shortgac cases haggisgac described section

fishort long supports constraint propagation

require x v supportlist ndlist
j listpos x v
j supportlist size

sup supportlist j

nextdiff ndlist j

k sup size

b sup k

b
x v b

j nextdiff k jump next short support assigned different value

continue loop line

listpos x v j

return sup
j
j listpos x v

sup supportlist j

nextdiff ndlist j

k sup size

b sup k

b
x v b

j nextdiff k jump next short support assigned different value

continue loop line

listpos x v j

return sup
return null

procedure findnewsupport ndlist findnewsupport x v

ever optimisation cannot used haggisgac stable described section
retains active supports backtracks backtracking
literal x v may longer assigned

haggisgac dealing full length strict short supports
introduce haggisgac better theoretical properties
shortgac furthermore experiments runs substantially faster many cases
strict short supports shortgac specialised strict short supports
substantially faster full length supports gac schema
introduction motivating example
shortgac designed exploit concept implicit support inefficiencies dealing explicit supports especially full length supports consider
example constraint alldifferentexceptzero constraint non zero
values array must different zero may occur freely constraint might
used example timetabling classes taking place different rooms
must different use zero represent room unused occur
multiple times suppose alldifferentexceptzero w x z variable initial domain supports constraint full length supports every


finightingale gent jefferson miguel

non zero value different three variables equalling zero last variable may
take value suppose execute shortgac reach following situation
supports

supportlistperlit
value




supportspervar
numsupports


b
c

e
w
b e


c


w
x z
w
x z
w
x z
x z
w x z
variable
x

z
c


e
c
b

b e
c
b

e





notice lack explicit supports w w acceptable
supportspervar w numsupports suppose literal deleted
constraint causes support deleted causing following state
supports

supportlistperlit
value




supportspervar
numsupports


b
c
e

x
x
x
x
variable
x

c

e
c
b e
b





w
w
w
w

w
b e


c


z
z
z
z






z

b
c
e


point shortgac iterates zerolits lists variables
supportspervar numsupports case four variables discover must
supports w w z however inefficient two reasons
first need check zerolits z discover z support list
z became empty deletion support could discovered
second need look zerolits w deletion caused
w lose implicit support need check zerolits x z
variables implicitly supported prior ds deletion removing two
reasons inefficiency motivation behind development haggisgac
example focus directly literal z set zerolits w literals
potentially needing support
fundamental shortgac cannot efficiently detect
literal loses last support every variable implicit support checked every time
support deleted shortgac take nd time single literal needs
support discover literal improve upon wish


fishort long supports constraint propagation


varsbysupport
supportspervar
x updated
x updated
z updated
x updated
z updated
z updated
supportspervar


w

w
w
w
w
w
w



w

w
w
w
w
w
w





x
x
x
x
x
x



x

x
x
x
x
x
x



x




x
x
x

























x

x
x
x






z

z
z
z
z
z
z



z

z
z
z
z
z
z



z

z
z
z
z
z
z


figure illustration deletesupport concentrates variables lost
last implicit support see main text full description

haggisgac able detect loss literals last explicit support time
loss variables last implicit support time perhaps surprisingly
goals achievable use data structures already existing shortgac
finding literals support efficiently
two types support detecting last explicit support literal lost
simpler task delete support procedure iterates literals
short support literal removes shortsupportcell corresponding
supportlistperlit updates data structures appropriately list empty tested
line procedure literal lost last explicit support add literal
scratch list literals lost last explicit support describe
process scratch list additional cost detect empty list
inside existing test zero additional cost literal
lost last support contrasts shortgac tests procedure every
variable implicit support worst case cost n even literal
lost last explicit support
subtle task detect variable thus literals involving
lost last implicit support reason difficult seeking
variables involved support deleted procedure iterate
literals support deleted variables seek
x supportspervar x numsupports support deletion
supportspervar x numsupports support deletion variables
supportspervar x numsupports deletion implicit support
lose implicit support deletion fortunately existing
maintenance data structures happens compact exactly variables particular
region varsbysupport easily efficiently compaction
happens sequence calls procedure swap made procedure
first worked example prove general properties need
figure suppose variables constraint currently
supports deleting support involving variables x x x z z z


finightingale gent jefferson miguel

literals deleted arbitrary order top start bottom finish
start z variables already supportspervar numsupports variables x
supportspervar variables w supportspervar process literals
deletesupport pairs variables swapped marked boxes line
boundaries move cells marked vertical lines variables equal supportspervar end w x variables still supportspervar numsupports
z variables supportspervar numsupports deletion
variables lost last implicit support variables crucial point
end lie precisely final boundary supports
initial boundary supports following
simple variables losing last implicit support compacted
similar way
lemma suppose delete support numsupports p numsupports p afterwards variable x lose last implicit support p
explicit supports deletion
proof x initially fewer p explicit supports x one implicit
support deleting removes one x initially p explicit supports
involved since involved supports implicit support
lose hence x must initially p explicit supports one implicit support
must one implicit support therefore deletion x p explicit
supports implicit supports
lemma set p lemma value supportnumlowidx p
deletesupport called j value supportnumlowidx p deletesupport
exits deletesupport finishes variables lost last implicit support
call deletesupport exactly set variables indices range j
varsbysupport
proof variables implicit supports deletesupport exits lie index j
greater varsbysupport establishes lower bound index range
variable z implicit support start call must p explicit
supports must index higher z must support deleted
supports z updated deletesupport swapped
variable index supportnumlowidx p index supportnumlowidx p increases
deletesupport z stays index higher throughout thus variables
index upwards finish permutation start meaning variables
lost last implicit support must range j finally variable
range j implicit support end call index j
implicit support start therefore variables
lost last implicit support lie indices range j
lemma run deletesupport trivial enumerate variables
lost last implicit support exactly variables
varsbysupport k k j j j defined lemma enumerating
list additional work already done procedure


fishort long supports constraint propagation

corollary given constraint n variables additional work identify variables
lost last implicit support variable
none
proof already argued case variables lost implicit
support variables still work check range
empty
low level complexity contrasts favourably shortgac support deleted procedure iterates variables numsupports explicit supports
worst case n work even variable lost last implicit support compared work move details incorporating
optimisations full suite procedures maintaining gac
haggisgac details
two issues complicate implementation haggisgac compared shortgac
first lemmas depend literals support deleted single pass
therefore instead acting immediately finding literal supports keep list
literals lost supports later treatment second two cases
might detect lost support lost support explicit implicit compared
single case shortgac lost supports detected way
introduce two simple data structures storing literals variables lost
explicit implicit support
litslostexplicitsupport set containing literals lost final explicit support
supported implicitly
varslostimplicitsupport set containing variables lost final implicit
support
adapt deletesupport procedure procedure version
shown procedure literal explicit support immediately
check implicit support instead line add
set litslostexplicitsupport later processing support delete variables
implicit support detected literals deleted done
lines justified lemma
propagate procedure shown procedure earlier procedure
first delete supports involving literal deleted rest procedure
different first iterate literals lost last explicit support
variables lost last implicit support
lost explicit supports call haggisgac literalupdate procedure
procedure analogue shortgac straightforward point interest
still check whether literal supported even though added
litslostexplicitsupport reason support found unrelated
call findnewsupport might support literal done
procedure calls findnewsupport support found added
prune literal longer supported


finightingale gent jefferson miguel

require short support sup
oldindex supportnumlowidx numsupports
x v sup

remove sup supportlistperlit x v

supportlistperlit x v

detachtrigger x v

x v zerolits x

add x v zerolits x

supportspervar x numsupports

add x v litslostexplicitsupport

spv supportspervar x

swap x varsbysupport spv

supportnumlowidx spv supportnumlowidx spv

supportspervar x spv
numsupports supportnumlowidx numsupports oldindex

add varsbysupport varslostimplicitsupport

procedure haggisgac deletesupport sup one subtlety must add x
v zerolits line even add litslostexplicitsupport line
case matters seek implicit support e containing
x v later lost later point procedure requires x v zerolits
x v might still explicit support
require x v v pruned domain x
litslostexplicitsupport
varslostimplicitsupport
supportlistperlit x v

sup first element supportlistperlit x v

deletesupport sup
b litslostexplicitsupport

haggisgac literalupdate b
z varslostimplicitsupport

haggisgac variableupdate z

procedure haggisgac propagate propagate x v
variables lost implicit supports call haggisgac variableupdate procedure similar procedure differences return statements
procedure omitted check every iteration whether implicit support
found x exit loop remove x v zerolits
explicit support found allowing done lazily later call line
gain efficiency shortgac two reasons first variableupdate
called variables lost implicit support second outer loop
haggisgac propagate must restarted support found
procedure write number variables lost last
implicit support reduced worst case number calls variableupdate
haggisgac propagate n n arity constraint since
n often much smaller n even zero significant gain


fishort long supports constraint propagation

require x v last explicit support x v deleted
v x supportspervar x numsupports
supportlistperlit x v

sup findnewsupport x v

sup null

prune x v

else

addsupport sup

procedure haggisgac literalupdate x v

require variable x
x v zerolits x

supportspervar x numsupports

return

supportlistperlit x v

remove x v zerolits x

else

v x

sup findnewsupport x v

sup null

prune x v

else

addsupport sup

procedure haggisgac variableupdate x

dealing efficiently full length supports
full length support added shortgac increments numsupports supportspervar every variable since interested condition numsupports
supportspervar x full length support cannot change status variable therefore save overheads case add full length support achieved
case split haggisgacs versions addsupport deletesupport
support full length update numsupports supportspervar related data
structures note test apply final support arity n
initial one omission assigned literals optimisation correct
even assigned literals omitted omit pseudocode optimisation
changes straightforward optimisation often improves performance instances
full length supports important effect instances
runtimes within without optimisation applicable
shortgac implement case address key
inefficiency e repeated checking variables cannot
lost last implicit support affect experimental dramatically
cases found improved performance haggisgac larger
optimisation provides


finightingale gent jefferson miguel

experimental evaluation shortgac haggisgac
minion solver gent jefferson miguel used experiments
changes additional propagators experiments compared
methods maintain gac therefore solver explores search space case
since number nodes searched invariant compare rate search exploration
measured search nodes per second
used core machine ghz intel xeon e cpus gb memory
running ubuntu linux possible ran processes parallel combination instance propagator report median runs cases
possible run processes parallel exceed gb memory
ran one process time report median runs instances
marked tables one method exceeded gb sometimes
ran comparable methods series well allows consistent comparison
list ndlist different propagation means tables
necessarily indicate method uses gb memory
median robust measure performance reasons described appendix b
cases imposed time limit one hour limit search nodes
whichever first avoid short runs solver solution easily
searched solutions report complete cpu times e attempted
measure time attributable given propagator include initialisation
advantage automatically take account factors affecting runtime
including aspects e g cache usage may realise affect runtime however
mean tend understate difference methods studied
case study implemented findnewsupport method shortgac
haggisgac specific constraint used generic list instantiation section next difference list instantiation section comparison
possible compare shortgac haggisgac special purpose propagator
available
compare shortgac long shortgac full length supports
haggisgac long gac schema bessiere regin closest equivalent without strict short supports discuss gac schema section
gac schema shortgac long haggisgac long use constraint specific
findnewsupport shortgac subsequently extend short support full length
minimum value extra variable
case constraint compactly represented disjunction therefore
compare shortgac haggisgac constructive used
lagerkvist schultes without rule entailment detection

source code solver three available http www cs st andrews ac
uk pn haggisgac source tgz instances experimental http www cs
st andrews ac uk pn haggisgac data instances tgz
preliminary investigations found running processes parallel gives consistent cpu time
consistency improved taking median



fishort long supports constraint propagation



element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist























figure summary comparison shortgac haggisgac x axis median
nodes per second shortgac axis speedup slowdown haggisgac e ratio shortgac nodes per second haggisgac
hence represents equal behaviour means haggisgac
faster

implementation minion fully incremental disjunct propagated incrementally
branch search backtracked search backtracks
compare table constraints described example gent et al
constraints large example smallest element constraints
reported allowed tuples making impossible even generate store
list allowed tuples
aid comparison haggisgac shortgac addition tables
compare graphically figure figure shows relative speedup
cases slowdown haggisgac compared shortgac
case study element
use quasigroup existence qg colton miguel evaluate shortgac haggisgac element constraint class one parameter
n specifying size n n table qg variables domains n rows
columns one diagonal gac alldifferent constraints following colton miguels
model element constraints represent qg property j j
j members quasigroup quasigroup operator translates
j element qg aux j aux j n qg j qg j aux j
domain n n
personal communication pascal van hentenryck indicated unpublished optimisation
constructive whereby disjuncts need propagated cases implement
optimisation



finightingale gent jefferson miguel

n






watch
elt






specific







shortgac
list ndl











long










specific







haggisgac
list ndl











long










gac
sch






mem

con









table nodes searched per second quasigroup existence mem indicates
running memory gb columns correspond propagation
watch elt special purpose propagator shortgac haggisgac
four instantiations specific special purpose findnewsupport function
constraint list ndl next difference list long described text
gac sch gac schema con constructive

constraint element x z findnewsupport method shortgac returns
tuples form hxi j z ji index vector x j
common value z xi shortgac list supports form constructive
used x z x z
compare shortgac haggisgac special purpose watched element
propagator gent et al b gac schema constructive table presents
qg general purpose methods short supports specific list
ndlist instantiations dramatically better alternative example n
even haggisgac list method slower haggisgac specific
times faster constructive best methods
shortgac long runs faster gac schema n slower
n better n gac schema uses memory recall
use findnewsupport method fair comparison efficiently
exploit supports contrast reported previously nightingale
et al shortgac half speed gac schema two substantial differences account improvement improved data structures described
section remove assigned literals full length supports described
section haggisgac long consistently faster shortgac long
gac schema
much faster methods full length supports list variants haggisgaclist haggisgac ndlist slower haggisgac element
true shortgac expected neither specialised element
constraint deal data structures containing lists tuples
two list variants ndlist variant runs much slowly however memory usage
expected much less haggisgac list used less half much memory
n improving almost times less memory n
haggisgac element approximately twice fast shortgac element
instances believe two variables short supports index
variables meaning supported explicitly seen


fishort long supports constraint propagation

n

gaclex

































shortgac
specific long

























haggisgac
specific long

























gacschema

















con























table nodes searched per second bibds gaclex special purpose propagator
columns named table

figure list ndlist long instantiations haggisgac faster
instantiations shortgac smaller margin special purpose
watched element propagator fastest method times faster n
watched element appears scaling better n increases constructive
much slower methods exploit strict short supports however faster
haggisgac long overall clear exploiting strict short supports
beneficial compared general purpose methods
case study lex ordering
use bibd evaluate shortgac haggisgac lexicographic
ordering constraint lex constraint placed rows columns perform
double lex symmetry breaking method flener et al use bibd model
given frisch hnich kiziltan miguel walsh gaclex propagator given frisch hnich kiziltan miguel walsh use bibds
parameter values n n n n n
constraint lexleq x arrays x define mxi min dom xi
myi max dom yi findnewsupport method shortgac finds lowest
index n mxi myi n case n arises x cannot
lexicographically less support sought x n support
contains xi mxi yi myi index j mxj myj short support
contains xj mxj yj myj otherwise valid support null returned
lex constraint two arrays length n domain size dn short
supports short support set assignments two arrays equal
satisfy constraint cannot reduced shortgac list shortgac ndlist


finightingale gent jefferson miguel

practical substantial constraint omit comparison
constructive use following representation n disjuncts x x
x including final case pairs equal
table presents experiments non list methods values
n clear best method special purpose gaclex propagator
haggisgac coming second haggisgac shortgac perform similarly haggisgac shortgac far best general purpose methods
largest instances run times slower special purpose method
outperforming next best method almost times haggisgac long
shortgac long outperform gac schema instances difference
even marked
haggisgac long substantially faster shortgac long seen
figure largely explained optimisation section
summarise experiments lex constraint clearly benefit
haggisgac shortgac compared general purpose propagation methods
speed even approaches special purpose gaclex propagator
case study rectangle packing
rectangle packing simonis osullivan parameters n width
height consists packing squares size n n rectangle size
width height modelled follows variables x xn yn
xi yi represents cartesian coordinates lower left corner square
domains xi variables width yi variables height
variables branched decreasing order place largest square first
xi yi smallest value first type constraint non overlap squares
j xi xj xj j xi yi yj yj j yi minion
special purpose non overlap constraint simonis osullivan
report comparison general purpose methods experiment used optimum
rectangle sizes reported simonis osullivan
domains xn yn reduced break flip symmetries described simonis
osullivan focus performance non overlap constraint
implement commonly used implied constraints
findnewsupport function shortgac follows four disjuncts
entailed given current domains return empty support indicating entailment otherwise return support two literals satisfy one four disjuncts
list used shortgac list shortgac ndlist supports size
table compare haggisgac shortgac general purpose
methods see haggisgac fastest method shortgac second
haggisgac list haggisgac ndlist well shortgac list shortgacndlist performed well compared gac schema constructive however
n haggisgac list consumes mb memory haggisgac ndlist mb
n possible run methods processes parallel
interestingly performance two list variants haggisgac reversed
case study ndlist significantly faster list cases expected


fishort long supports constraint propagation

n w h











specific











shortgac
list
ndl



























long











specific











haggisgac
list
ndl





















long











gac
sch











con












table nodes searched per second rectangle packing instances columns named
table

ndlist used less memory though less dramatically used
memory haggisgac list
methods least times slower haggisgac
haggisgac long faster gac schema cases shortgac long
faster gac schema instances except contradicts
previously reported nightingale et al explanation given
first case study
table shows haggisgac squarepack instantiation substantially
faster shortgac instances exception n n
shortgac slightly faster compared shortgac list ndlist
long instantiations figure see haggisgac mostly
faster summary clearly benefits strict short
supports
comparing haggisgac gac schema
across experiments haggisgac long runs significantly faster gacschema minimum faster three times faster even
though code contains overhead dealing strict short supports compared
memory usage across experiments found similar performance across instances found haggisgac long uses less memory except
bibd instances bibd uses less memory gac schema
however comparison functional instantiations full length supports constraints admit strict short supports section broaden
comparison list instantiations rather functional ones
instances used previously comparing table constraints
compared gac schema similar haggisgac
shortgac conceptually three maintain list supports literal
updated backtracked search gac schema carefully implemented


finightingale gent jefferson miguel

sports
carseq
graceful
pqueens
bibd




















figure comparison gac schema haggisgac list full length table constraints x axis nodes per second gac schema axis speedup
haggisgac list

following pseudocode original bessiere regin code
shared among three optimised independently example
gac schema different implementation supportlistperlit named sc bessiere
regin specialised full length supports
contrast gac schema table constraint propagators str lecoutre
mddc cheng yap entirely different haggisgac would
difficult create truly comparable implementations
report use haggisgac list searches supports
way gac schema one difference discuss used structured
instances gent et al except semigroup class addition used car
sequencing instances nightingale specifically model b instances numbered
instances contain large number ternary table constraints
figure shows haggisgac list almost faster gac schema
bibds clear better haggisgac
least marginally faster sports scheduling prime queens graceful
graphs instances cases range faster haggisgac substantially
faster car sequencing seek supports haggisgac calls procedure
finds support stores index listpos haggisgac backtrack
listpos described section gac schema similar backtrack listpos
ensures optimality branch search iterating listpos
end list bessiere regin profiling shows gac schema hindered
backtracking listpos block copying memory car sequencing
large number table constraints instance large domains size


fishort long supports constraint propagation

alternative memory management techniques might speed gac schema
claim haggisgac fundamentally times faster gac schema
summary
summarise three case studies haggisgac indeed outperform shortgac
many instances sometimes two times commonly
shortgac rarely faster one instance much overall
experiments haggisgac clearly better shortgac furthermore
haggisgac shortgac perform well compared constructive gacschema validates idea strict short supports
finally shown experimentally haggisgac outperform gac schema
containing full length supports discuss appendix c major focus

backtrack stability short supports
within search tree haggisgac often spends significant time backtracking data structures reducing eliminating backtracking improve efficiency example mac
mac much efficient space time backtracking avoided
regin section present saves time deleting
short supports backtrack saves memory bounding total number stored
short supports including backtrack stack
requires short supports backtrack stability property
short support backtrack stable iff remains short support backtracking section
three case studies short supports construct element
lex constraints backtrack stable rectangle packing rectangle
packing generate empty support constraint entailed empty support
backtrack stable unless constraint entailed root node search
introduce haggisgac stable know short supports
backtrack stable key change delete supports backtrack
past point introduction stable still correct ancestors
node introduced save time previous since
sometimes need work backtracking obtain
tight limits space usage stored supports
present haggisgac stable introduce notion prime support
deleted literal prime support deleted literal support explicit implicit
valid support literal literal restored backtracking
invariant maintain deleting literal labelled deleted
support backtrack stack prime support literals variable currently
implicitly supported invariant guarantee backtrack
point literal restored must supported prime support
restore known implicit support
task finding prime support literal naturally splits three cases
simplest case haggisgac stable deletes literals able


finightingale gent jefferson miguel

necessary support prime support implicit explicit support
whose deletion caused fruitless search support
second case literal pruned constraint search
procedure pruned literal explicit support constraint explicit
supports must deleted longer valid label arbitrary one
literals prime support simply choose last one deleted
third case unfortunately complicated literal pruned outside
current constraint literal implicit support explicit support
difficult precisely pruned literal link implicit support
providing maintaining link throughout search would negate efficiencies
gained solution lazy variable pruned
literal implicitly supported implicit support variable
maintaining invariant described literal pruned need nothing
case need work variable loses last implicit support
ever happens invalid literal explicit support must
definition relevant zerolits list whereas previously ignored invalid literals
iterating zerolits label deleted implicit support prime
support invalid literal
lemma haggisgac stable stores time
z supports z total number literals save lot memory
haggisgac shortgac may store z supports
z deletions literals branch deletion set z supports
may stored experiments later difference memory usage
significant practice effective memory usage reduced times
details haggisgac stable
haggisgac stable control great care deletion restoration
supports instead rest simply reversing addition deletion
support node respectively deleting adding back backtrack past
node short never delete active support backtracking add back
deleted support prime support literal current active support
deleting support setup counter numprimesupported initially
incremented time support prime support propagation
finishes support numprimesupported support destroyed space reclaimed otherwise place numprimesupported pairs
backtrack stack pair consists deleted support literal prime
support backtracking pop pair first check current support
already supports literal simply decrement numprimesupported
reduces reclaim supports space literal supported
restore support via call addsupport way literals support prime
guaranteed supported
relatively minor difference iterate zerolits delete invalid literals zerolits backtracking restore


fishort long supports constraint propagation

require x v last explicit support x v deleted
v x

supportspervar x numsupports supportlistperlit x v

sup findnewsupport x v

sup null

prune x v

increment lastsupportperlit x v numprimesupported

push hx v lastsupportperlit x v onto backtrackstack

else

addsupport sup
else

increment lastsupportperlit x v numprimesupported

push hx v lastsupportperlit x v onto backtrackstack

procedure haggisgac stable literalupdate x v comparison procedure update numprimesupported backtrackstack

zerolits backtrack stack enables space complexity
lemma
haggisgac stable similar haggisgac appropriate simply describe
differences save space procedure haggisgac stable propagate almost
procedure calling backtrack stable variants deletesupport literalupdate
procedure variableupdate procedure addition end
destroy reclaim space deleted support numprimesupported
procedure haggisgac stable deletesupport called support
similar predecessor procedure additions first initialises numprimesupported second data structures lastsupportperlit deleted
literal x lastsupportpervar variable x terms procedure
assigned line line respectively note assignments
make prime support checked later
procedure analogous procedure enough differences
detail identifies prime supports necessary increments numprimesupported pushes invalid literal support pairs onto backtrack stack present
procedure detail analogue procedure identifies prime supports
increments counter adds pairs backtrackstack one difficult case arises
line x pruned externally constraint
pruned procedure would zerolits x restored backtracking still need make sure support since explicit support
zerolits last support must implicit support deleting therefore store
support backtrackstack minor change note remove literals
zerolits lines
whenever search node including root entered null pushed onto
backtrackstack used marker procedure haggisgac stablebacktrack procedure processes literal support pairs reaches null
restores prime supports literals put back domain backtracking
support currently known numprimesupported counter


finightingale gent jefferson miguel

require variable x
x v zerolits x

supportspervar x numsupports

return

supportlistperlit x v

remove x v zerolits x

else

v x

sup findnewsupport x v

sup null

prune x v

increment lastsupportpervar x numprimesupported

push hx v lastsupportpervar x onto backtrackstack

remove x v zerolits x

else

addsupport sup

else

increment lastsupportpervar x numprimesupported

push hx v lastsupportpervar x onto backtrackstack

remove x v zerolits x
procedure haggisgac stable variableupdate x similar procedure
addition maintenance numprimesupported backtrackstack
top element backtrackstack null

pop hx v supi backtrackstack

sup yet restored

supportspervar x numsupports supportlistperlit x v

haggisgac stable addsupport sup

else

another support exists x v

decrement sup numprimesupported

sup numprimesupported

destroy sup reclaim space

supportlistperlit x v

add x v zerolits x
pop null backtrackstack

procedure haggisgac stable backtrack performs backtracking backtrackstack

support becomes zero support destroyed longer necessary note
literals put back zerolits necessary line reversing deletion
procedure
cannot use optimisation described section deleting literals supports
variables assigned may break backtrack stability property


fishort long supports constraint propagation

however retain optimisation section full length supports omit
pseudocode showing interest focusing essential aspects
improved space complexity haggisgac stable
improves space complexity haggisgac stable compared haggisgac following lemma shows
lemma constraint involving z literals z supports stored
active deleted supports backtrack stack
proof define function supports literals support still active
found call findnewsupport specific literal map support
literal similarly support backtrack stack pair least
one literal prime support map support one literals every
stored support falls one two categories support deleted
put onto backtrack stack space reclaimed three supports mapped
literal
valid literals findnewsupport called existing active support
exists literal
invalid literals literal appears pair backtrack stack
twice case literal appears often twice literal
prime support already stack processed variable loses last implicit
support case literal must zerolits newly deleted implicit
support added backtrack stack literal happen
delete literal zerolits first time happens
thus number supports bounded z
bound z lemma would improve z maintained zerolits eagerly
instead lazily expense higher overheads elsewhere

experimental evaluation haggisgac stable
compare haggisgac stable haggisgac experimental setup
section well tables provide graphical comparison runtimes
haggisgac stable haggisgac figure memory usage figure
table figure shows instances section present
four instantiations haggisgac stable along fastest instantiation haggisgac watched element special purpose propagator constructive
faster gac schema table element observe slowdown
slight slowdown list variants full length supports see almost
identical performance
table shows instances section haggisgac stable lex performs slightly worse haggisgac lex though fact never worse
slightly faster largest instances might supports found


finightingale gent jefferson miguel

deep search likely contain literals supports found earlier meaning
backtrack longer supports retained instead replaced earlier
efficient short supports advantage disappears long variants indeed haggisgac stable long performs much better haggisgac long
improvement increases n times n
rectangle packing instantiation shortgac described section generates
empty support constraint becomes entailed causing variables implicitly
supported point empty support backtrack stable cannot
used haggisgac stable implemented backtrack stable variant
findnewsupport empty support returned otherwise
list long variants affected return
empty support case table use instances section
significant slowdowns backtrack stability rectangle packing times
n probably inability return empty support
hand see speedups list variants cases factor
speedup full length supports
see figure memory usage goes greatly stability used
full length supports possibly contributing speedups cases greatest
reductions case element two cases times less memory
hand significant reduction memory usage non long variant
tested haggisgac stable gac schema section gave
similar performance haggisgac therefore better gac schema
omit detailed significant memory advantage compared haggisgac stable variant saving less therefore seem gain
advantages saw earlier backtrack stability full length supports
conclude backtrack stability speed haggisgac significantly
greatly reduce memory usage full length supports however care must
used backtrack stability harmful insisting backtrack stability increases
size returned supports

related work
use counters count supports inspired ac mohr henderson
study compressing tuples constraint compact data structure
order make propagation efficient example gent et al used tries
cheng yap applied mdds extensive study searching
list tuples first valid tuple approaches include binary search lecoutre
szymanek trie search gent et al approaches similar skip lists
ndlists gent et al hologram tuples lhomme lhomme regin
techniques orthogonal main focus assist
finding supports maintaining set active supports adapted ndlists
contain short supports section may interesting adapt
approaches
str maintains sparse set valid satisfying tuples constraint lecoutre
updated variable domains computed set time


fishort long supports constraint propagation

n

watchelt













haggisgac
specific







haggisgac stable
specific
list ndlist long
























con









table nodes searched per second quasigroup existence columns
named table
n

gaclex

































haggisgac
specific long

























haggisgac stable
specific
long































gacschema

















con























table nodes searched per second bibds gaclex special purpose propagator
lex columns named table
n w h











haggisgac
specific











haggisgac stable
specific
list ndlist



































long











gacschema











table nodes searched per second rectangle packing instances columns named
table



finightingale gent jefferson miguel

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist


























e

figure summary comparison haggisgac haggisgac stable x axis
median nodes per second haggisgac axis speedup slowdown
haggisgac stable
















element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist




e

e

e

figure summary comparison memory usage kib haggisgac haggisgacstable x axis median memory usage haggisgac axis
reduction increase usage haggisgac stable e ratio haggisgac memory usage haggisgac stable hence represents
equal behaviour means haggisgac stable used less memory



fishort long supports constraint propagation

invoked concept maintaining support seeking support literal
would interesting investigate adapting str handle short supports would
entirely different ones presented possibly
complementary strengths
mdd propagator mddc cheng yap maintains mdd incrementally
search mdd compressed representation satisfying tuples
constraint time complexity mddc linear initial size mdd therefore
degree compression vital efficiency cases
constraint amenable strict short supports compress well mdd
given appropriate variable ordering example lex constraint compresses well
partly given variable order x x constraint satisfied
assigning prefix variables lex amenable short supports reason
however constraints small set short supports cannot compressed
effectively mdd suppose disjunction equality constraints pair
n variables domain size n variables mdd must cn states
another property mdd compression might indicate interesting direction future
work lex compresses well mdd multiple assignments prefix
variables lead subsequent vertex e g x x
something short support currently able exploit
katsirelos walsh proposed different generalisation support named ctuples c tuple contains set values variable scope constraint
valid tuple whose values drawn c tuple full length support katsirelos
walsh give outline modified version gac schema directly stores c tuples
present experiments different propagator gac r demonstrating
modest speed improvement c tuples compared conventional full length supports
c tuple contains values variable nevertheless recorded sc
support value individually katsirelos walsh
concept implicit support
context constructive lhomme observed support one
disjunct support values variable contained concept similar
short support albeit less general length supports fixed
length disjuncts presented non incremental constructive two
disjuncts
similar flavour gac schema bessiere regin
natural compare gac schema however gac
gac bessiere et al would interesting compare


conclusions
introduced detailed three general purpose propagation short
supports given specialised function supports
constraint used function accepts explicit list short supports
strict short supports available three perform well provide much


finightingale gent jefferson miguel

better performance general purpose methods gac schema constructive
shows value strict short supports
first studied shortgac described improvements
compared earlier report nightingale et al identified significant inefficiency shortgac dealing explicit supports
introduced haggisgac corrects flaw better theoretical
complexities performs much better shortgac experiments three
case studies haggisgac far faster general purpose methods best case
even achieved speeds special purpose propagator perhaps
remarkably able deal strict short full length supports haggisgac outperformed shortgac strict short supports gac schema full length
supports e cases respectively specialised
third haggisgac stable retain supports backtracking
less effective haggisgac invalidates use certain strict short supports
significantly faster full length supports reduce
memory usage greatly cases
proposed excellent propagating disjunctions constraints
experiments disjunctions found faster constructive
gac schema least order magnitude three orders magnitude
summarise shown value explicit use strict short supports
general purpose propagation generalised arc consistency strict short
supports available exploiting yields orders magnitude improvements generic
propagation cases even found generic come
close performance specialised propagator previously short supports
seem recognised important right overall contribution
correct focus short supports first class objects

acknowledgments
would thank anonymous reviewers bilal syed hussain comments
epsrc funding work grants ep h ep e

appendix comparison shortgac shortgac ijcai
section noted optimised data structures shortgac compared previous presentation nightingale et al demonstrate
indeed improvements compared two implementations shortgac
three case studies used use name shortgac ijcai
previous version quoting previous work nightingale et al
rerun experiments environment described section
updated codebase minion instead minion earlier
instance report nodes searched per second peak memory use
table shows instances section clear
shortgac makes much better use memory faster shortgac ijcai


fishort long supports constraint propagation



low memory sections
high memory sections
list ndlist section
gac schema constructive























e

figure scatterplot median nodes per second x axis median absolute
deviation divided median axis distinguish
main experiments sections cases medians
runs list variants used table constraints section data
gac schema constructive

instances table shows instances section element
shortgac makes better use memory faster shortgac ijcai although
improvements great table use instances section
previous two case studies shortgac consistently better speed
memory use conclude data structures used
indeed superior used previously nightingale et al

appendix b median absolute deviation experiments
experiments report median runs assess robust
median measure looked combination instances
median absolute deviation mad e median absolute difference data
points median figure shows mad instance combinations
fraction median case shows instance combinations
tested including combinations reported detail nodes per
second maximum mad found less median worst
case haggisgac long n table four
cases mad median figures memory usage even
consistent two cases showing mad median
others major conclusions draw regard change
behaviour one method another significant therefore say
median robust measure performance


finightingale gent jefferson miguel

n






shortgac
node rate







shortgac ijcai
node rate







shortgac
memory







shortgac ijcai
memory







table nodes searched per second memory use kib quasigroup existence comparison shortgac shortgac ijcai

n
















shortgac
node rate
















shortgac ijcai
node rate
















shortgac
memory
















shortgac ijcai
memory
















table nodes searched per second memory use bibd comparison
shortgac shortgac ijcai

n w h











shortgac
node rate











shortgac ijcai
node rate











shortgac
memory











shortgac ijcai
memory











table nodes searched per second memory use rectangle packing comparison
shortgac shortgac ijcai



fishort long supports constraint propagation

appendix c comparison gac schema haggisgac
showed section haggisgac outperforms gac schema dealing
full length supports despite fact haggisgac small overheads
dealing strict short supports even none exist discuss briefly
may
gac schema concept current supports literal one current support
one active supports contain literal additional data
structure active support list literals
current support hence invalidated gac schema finds current support
literal deletes literal haggisgac dispensed
entirely sign literal needs support lost current support
support list supportlistperlit empty small potential saving
maintaining
second possibly important difference gac schema eager
haggisgac literal x v loses current support gac schema check
active supports containing x v valid n operation one
invalid gac schema calls findnewsupport returns null x v
deleted haggisgac none avoiding completely cost checking validity safe every support invalid literal deletion support
cause call deletesupport last empty list causing call
findnewsupport approaches correct gac schemas wasteful
performs unnecessary validity checks however one cannot guarantee time saving gac schema perform deletions sooner possibly affecting way propagator
interacts propagators

references
bessiere c hebrard e hnich b walsh complexity reasoning
global constraints constraints
bessiere c regin j c arc consistency general constraint networks preliminary proceedings ijcai pp
bessiere c regin j c yap r h c zhang optimal coarse grained
arc consistency artificial intelligence
cheng k c k yap r h c mdd generalized arc consistency
positive negative table constraints global constraints
constraints
colton miguel constraint generation via automated theory formation
proceedings cp pp
flener p frisch hnich b kiziltan z miguel pearson j walsh
breaking row column symmetries matrix proceedings cp pp

frisch hnich b kiziltan z miguel walsh global constraints
lexicographic orderings proceedings cp pp


finightingale gent jefferson miguel

frisch hnich b kiziltan z miguel walsh propagation
lexicographic ordering constraints artificial intelligence
gent p optimality maintaining list pointers backtracking
search tech rep circa preprint university st andrews
gent p jefferson c miguel minion fast scalable constraint solver
proceedings ecai pp
gent p jefferson c miguel b watched literals constraint propagation
minion proceedings cp pp
gent p jefferson c miguel nightingale p data structures generalised
arc consistency extensional constraints proceedings aaai pp
gent p petrie k puget j f handbook constraint programming foundations artificial intelligence chap symmetry constraint programming pp
elsevier science inc york ny usa
jefferson c moore n c nightingale p petrie k e implementing logical
connectives constraint programming artificial intelligence
katsirelos g walsh compression large arity extensional
constraints proceedings cp pp
king cromarty l paterson c boyd j applications ultrasonography
reproductive management dux magnus gentis venteris saginati veterinary
record
lagerkvist z schulte c propagator groups proceedings cp pp

lecoutre c str optimized simple tabular reduction table constraints constraints
lecoutre c szymanek r generalized arc consistency positive table constraints proceedings cp pp
lhomme regin j c fast arc consistency n ary constraints
proceedings aaai pp
lhomme efficient filtering disjunction constraints
proceedings cp pp
lhomme arc consistency filtering logical combinations constraints integration ai techniques constraint programming
combinatorial optimization cp ai pp
mackworth k reading sketch maps reddy r ed ijcai pp
william kaufmann
mears c automatic symmetry detection dynamic symmetry breaking
constraint programming ph thesis clayton school information technology
monash university
mohr r henderson c arc path consistency revisited artificial intelligence


fishort long supports constraint propagation

nightingale p extended global cardinality constraint empirical survey
artificial intelligence
nightingale p gent p jefferson c miguel exploiting short supports
generalised arc consistency arbitrary constraints proceedings ijcai
pp
puget j f automatic detection variable value symmetries proceedings
cp pp
regin j c generalized arc consistency global cardinality constraint proceedings aaai pp
regin j c maintaining arc consistency search without
additional space cost proceedings cp pp
rossi f van beek p walsh eds handbook constraint programming
elsevier
schulte c tack g implementing efficient propagation control proceedings
trics techniques implementing constraint programming systems conference
workshop cp st andrews uk
simonis h osullivan b search strategies rectangle packing proceedings
cp pp
wurtz j muller constructive disjunction revisited proceedings
th annual german conference artificial intelligence advances artificial
intelligence ki pp springer verlag




