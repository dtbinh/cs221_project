Journal Artificial Intelligence Research 8 (1998) 93{128

Submitted 5/97; published 3/98

Synthesizing Customized Planners Specifications
Biplav Srivastava
Subbarao Kambhampati

Department Computer Science Engineering
Arizona State University, Tempe, AZ 85287.

biplav@asu.edu
rao@asu.edu

Abstract

Existing plan synthesis approaches artificial intelligence fall two categories {
domain independent domain dependent. domain independent approaches applicable across variety domains, may ecient one given domain.
domain dependent approaches need (re)designed domain separately,
ecient domain designed. One enticing alternative
approaches automatically synthesize domain independent planners given
knowledge domain theory planning. paper, investigate
feasibility using existing automated software synthesis tools support synthesis. Specifically, describe architecture called CLAY Kestrel Interactive
Development System (KIDS) used derive domain-customized planner
semi-automatic combination declarative theory planning, declarative control knowledge specific given domain, semi-automatically combine derive
domain-customized planners. discuss means write declarative theory
planning control knowledge KIDS, illustrate approach generating class
domain-specific planners using state space refinements. experiments show
synthesized planners outperform classical refinement planners (implemented instantiations UCP, Kambhampati & Srivastava, 1995), using control knowledge.
contrast costs benefits synthesis approach conventional methods
customizing domain independent planners.

1. Introduction

Given current state world, set desired goals, set action templates,
\planning" involves synthesizing sequence actions executed initial
state lead state world satisfies goals (Fikes & Nilsson, 1990;
McAllester & Rosenblitt, 1991; Kambhampati, 1997b). Planning known combinatorially hard problem, variety approaches plan synthesis developed
past twenty years. approaches classified two broad categories
{ domain independent domain dependent. Domain independent planners make
assumptions planning domains, thus accept solve planning problems domain. contrast, domain specific planners specifically designed
single domain thus dynamics control knowledge domain hard-coded.
advantage domain independent planning planning algorithm
designed, used domain simply changing action template
input algorithm. contrast, domain-specific planners would \modified"
\re-designed" domain. ip-side, domain-specific planners tend

c 1998 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiSrivastava & Kambhampati

Theory refinement

Domain Knowledge

planning
Control Knowledge
(eg. Planes dont touchdown
without delivering packages)

- FSS
- BSS
KIDS

- PSS
- HTN
Dynamical Model
(Action/operator description)

Problem

Customized
Planner

Plan

Figure 1: Architectural overview planner synthesis KIDS CLAY approach.
theories refinement planning domain knowledge declaratively specified KIDS turn combines produce customized planner
domain. resulting planner, conventional planners, handle
planning problem domain. detailed description, see Section 3.
ecient designated domains domain independent planners since latter may
able effectively exploit control knowledge every domain.
surprisingly, significant amount work AI planning aimed improving performance domain independent planners dynamically customizing
given domain. customization done providing domain writer ability
control search planner, case task-reduction planning (Kambhampati
& Srivastava, 1996; Kambhamapti, 1995), using learning techniques (Kambhampati,
Katukam, & Qu, 1996; Minton, 1990). Although several approaches developed
learning improve planning performance, present effective match
eciency domain dependent planners.
One intriguing alternative automatically synthesize domain dependent planners
given knowledge domain theory planning. paper, investigate feasibility using existing automated software synthesis tools support
synthesis. introduce CLAY architecture supports synthesis domain
dependent planners using KIDS, semi-automated software synthesis system. Specifically,
shown Figure 1, declarative theory plan synthesis (theory planning) combined
control knowledge specific given domain semi-automated software synthesis system called Kestrel Interactive Development System { KIDS (Smith, 1990, 1992a,
94

fiSynthesizing Customized Planners Specifications

1992b) derive customized planner domain. draw declarative theory
plan synthesis domain independent planning techniques. Domain specific control
knowledge expressed terms types plans preferred given
domain.
approach strikes promising middle-ground domain independent
domain dependent planners. theories planning encoded independent domains,
domain control knowledge encoded independent specific planning
theory used. customization step compiles domain control knowledge
planning algorithm ensures resulting planners able exploit structure
domain.

1.1 Overview Synthesis Approach

brie mentioned above, practicality approach predicated availability
software synthesis system capable deriving code formal specifications. KIDS
powerful semi-automated system development correct ecient programs
formal specifications. Given domain theory input/output specification task,
KIDS system helps synthesizing program capable solving task. Here, term
theory refers useful body knowledge. Task refers assignment given
KIDS solving solution program task. input KIDS task
theory comprised task specification declarative description useful concepts
rules reason task space. research, give planning task KIDS
expect synthesize return planner solution. planner take
planning problems input return results (plans).
order support planner synthesis, develop input theory planning
KIDS. discussed (Kambhampati, 1997b), traditional plan synthesis techniques
described terms common plan representation, different planners corresponding different ways refining partial plans progression, regression
plan-space refinements (see Section 2.2). Consequently, planning theory consist
specification planning task (in terms input output data types) one
refinement theories. Since interested domain-customized planners,
provide necessary domain knowledge KIDS.
Given inputs, KIDS semi-automatically synthesizes program (in case, domain dependent refinement planner) using generic algorithm design tactics (such branch
bound, global search). resulting planner, conventional planners, handle
planning problem domain. See Section 3 details.

1.2 Outcomes

understand ecacy plan synthesis CLAY, paper, concentrate
synthesis planners using state-space refinement theories.1 Empirical evaluation shows
synthesized planners ecient. example, blocks world
domain goal stack inversion, KIDS synthesized planner solved 14 blocks
problem minute. logistics domain, problem 12 packages, 4 planes
1. future, plan extend approach plan-space task-reduction refinements.

95

fiSrivastava & Kambhampati

8 places solved minute. Similarly, Tyre domain (Russell & Norvig,
1995), \fixit" problem solved minute. put performance results
perspective, compared KIDS' synthesized planners set classical planners implemented instantiations UCP planning system (Kambhampati & Srivastava,
1995). described later, instantiations UCP emulate spectrum classical planners, including popular SNLP planner (McAllester & Rosenblitt, 1991), selecting
appropriate refinement. experiments, best KIDS' synthesized planners
outperformed best UCP instantiations given domain-specific information. hypothesize KIDS profitably fold-in domain-specific
control knowledge (i.e., domain theory) planning code.

1.3 Organization

rest paper describes details approach, called CLAY architecture
planner synthesis. paper organized follows: brief review traditional
plan synthesis approaches software synthesis KIDS Section 2, walk
CLAY framework Section 3. Section 4 presents discussion nature planners
synthesized approach. Section 5 empirically evaluates synthesized planners
compares classical planners. Section 6 discusses related work. Section 7 describes
conclusions discusses costs benefits synthesis approach.

2. Background

section, brie discuss relevant background software synthesis KIDS,
plan generation needed follow rest paper.

2.1 Kestrel Interactive Development System

discussing KIDS, start preliminaries automated software synthesis.
holy grail software synthesis :
Produce highly reliable, adaptable software greatly reduced development time.
Automate detail intensive tasks software production largely non-creative
nature.
program, program segment, P , correct respect initial condition (assertion) final condition (assertion) F whenever true prior execution P , P terminates, F true execution P complete. Using
formal specification task, knowledge-base inference system, knowledge-based
software synthesis proceeds iterative specification refinement process specialize
general knowledge program development (in form algorithm theories) solve
specific tasks hand. refinements sound specification correct,
synthesized program (code) correct.
KIDS program-transformation framework development programs
formal specifications task. KIDS runs Sun workstations built REFINE,
commercial knowledge-based programming environment high-level language.
96

fiSynthesizing Customized Planners Specifications

Software Specification
(Input, output specification planner)

Background Knowledge
(Domain Dynamics, Control

Algorithm Design Tactics

knowledge, distributive laws etc.)

(Global search/Refinement search
planning)

Un-optimized algorithm
(A planning algorithm)

Optimization
(Simplification, finite differencing etc)

Optimized Algorithm
(optimized planner)

Compilation

Compiled Code base language

Figure 2: Overview software synthesis process KIDS
REFINE language supports first-order logic, set-theory, pattern matching transformation rules. Refine provides compiler generates Common Lisp C code programs
written logical specification language.
following, describe general steps involved synthesizing software KIDS.
Figure 2 provides overview process. process illustrated detail
Section 3 context synthesis customized planner code.
1. Develop task theory state reason task. user defines appropriate
functions types describe task gives laws allow high-level
reasoning defined functions. planning, many planning theories (e.g.,
progression regression) written relevant laws specified. provided domain theories KIDS could perform specialized reasoning planners
returned solutions.
2. Select apply design tactic select algorithmic framework
used implement task specification. KIDS currently supports variety design tactics including problem reduction, divide conquer, global search local
search. planning, use global search design tactic formalization
97

fiSrivastava & Kambhampati

classical planning driven refinement search seen special case
global search (see below).
3. Apply optimizations make generated algorithm ecient. first, generated
algorithm well-structured correct return valid solutions,
inecient. algorithm optimized specification reduction
techniques simplification, partial evaluation finite-differencing.
4. Compile algorithm produce program base language.
domain theories specifications written REFINE, KIDS synthesizes
optimizes algorithms language. transform specifications programs well optimize programs, KIDS uses form deductive reasoning called
\directed inference" reason task specification domain theory.
KIDS system used derive variety programs past. particular
interest us work deriving ecient scheduling software (Smith & Parra, 1993;
Burstein & Smith, 1996), success programs provided initial impetus
research.

2.2 Theories Plan Synthesis

mentioned earlier, using KIDS derive planning software CLAY involves figuring
(a) declarative theories different types classical planning specified
(b) algorithmic design templates best suited planner synthesis. (Kambhampati,
1997b) provides overview traditional plan synthesis approaches. discussed there,
plan synthesis approaches come many varieties little superficial commonality
them. last years, developed unifying framework subsumes
approaches (Kambhampati & Srivastava, 1995; Kambhampati, Knoblock, &
Yang, 1995; Kambhampati, 1997b). framework, plan synthesis modeled
process searching space sets action sequences. sets represented
compactly collections constraints called \partial plans." search process first
attempts extract result (an action sequence capable solving problem)
partial plan, fails, \refines" (or splits) partial plan set new partial
plans (each corresponding sets action sequences subsets action sequence
set corresponding original partial plan), considers new plans turn.
existing domain independent plan-synthesis algorithms correspond four different ways
refining partial plans. known, respectively, Forward State Space progression
refinement (FSS), Backward State Space Refinement regression refinement (BSS), Plan
Space Refinement (PSS) Task-Reduction Refinement. STRIPS (Fikes & Nilsson, 1990)
example planner using FSS refinement, TOPI (Barrett & Weld, 1994) uses
BSS refinement, SNLP (McAllester & Rosenblitt, 1991) uses plan-space refinement
NONLIN (Tate, 1977) uses task-reduction refinement. Given background,
declarative theory plan generation CLAY corresponds theories refinements.
algorithm tactic underlying plan generation corresponds \refinement search."
KIDS system supports algorithm tactic called \global search" (Smith, 1992a)
seen generalization refinement search.
98

fiSynthesizing Customized Planners Specifications

SPECIFICATION: planning problem ?
Encoding
Domain Knowledge
Theory Import
Direction

Planner

Level 1

REFINEMENT THEORY: refinements available ?
Progression(FSS)

Regression(BSS)

Plan space (PS)

Level 2

DOMAIN THEORY: particular planning domain unique ?

Blocks World
Domain
Knowlegde

Blocks World
Progression

Logistics Domain
Knowlegde

Level 3

Blocks World
Regression
Logistics Progression

Logistics
Regression

Figure 3: CLAY architecture writing planning theory. level answers question
relevant level planning detail. CLAY uses KIDS' feature theory
import modularize domain-specific planning theory

3. Developing Planner Declarative Specification: CLAY
Architecture

Figure 1 summarizes KIDS used synthesize domain-specific refinement planner. domain knowledge consists dynamical model control knowledge.
dynamical model specified form actions (also called operators) define legal transformations one state world another. Control knowledge set
domain-specific criteria helps planner decide plan P1 better P2
intended make search ecient. example control knowledge logistics domain packages moved destinations using airplanes,
planes touchdown location packages pickup deliver.
Refinement planning domain control knowledge brought together CLAY
architecture writing declarative domain-specific planning theory summarized Figure 3. specify planning task, plan representation selected constraints
satisfied solution plan enumerated planner specification.
planner specification dependent plan representation independent
refinement needed search. refinement strategy uses planner specification
defines children nodes generated given partial plan, goal test
be, explicates refinement specific search pruning tests. refinement
99

fiSrivastava & Kambhampati

specification together form planning theory. obtain domain dependent planner,
one needs import planning theory provide relevant domain-specific
planning control knowledge provides preference structure among partial plans
competing solutions. interesting special case one specifies generic domain
knowledge effect plans equally good domain. case,
based refinement used, one gets FSS, BSS, PSS hybrid (if multiple refinements
used), general-purpose planner.
level directed tree Figure 3 represents abstraction planning
task. root tree (Level 1), description planning task required
without specifying refinements strategies used. Level 2, refinements
specified assumption made domain. Next, characteristics
domain provided Level 3. progression (FSS) blocks world planner different
progression logistics domain planner terms domain knowledge.
hand, progression blocks world planner different regression (BSS) blocks-world
planner terms refinement used.
stated above, ensure exibility, control knowledge change
different refinements used thereby represent substantial exibility. practice,
since control knowledge helps prune children nodes produced refinement, pruning may
effective control knowledge encoded depending refinement.
middle ground implemented: domain control knowledge
may represented intermediate form depending partial plan representation.
refinement provide, addition termination test, conversion function
transform control knowledge refinement specific form.

3.1 Representing Domain Operators

discuss world state represented domain operators define
state transformations. classical planning, world modeled terms set \state
variables." state world corresponds particular assignments values
variables. actions described terms specific variable-value combinations
needed applicable, variable-value combinations enforce
execution. Two variants general modeling approach become popular
planning community. first, called STRIPS representation (Fikes & Nilsson, 1990)
represents world terms ground atoms first order logic. action applicability
conditions effects described terms conjunctions ground atoms.
second variant (Backstrom & Nebel, 1993) models world actions directly terms
multi-valued state variables values. Since STRIPS representation seen
state-variable model boolean state-variables, since multi-valued statevariable system converted equivalent boolean state-variable system, two
representations equivalent expressive power.
chose state-variable representation implementation since
directly mapped primitive data structures supported KIDS. Figure 4 shows
action moving block block B top block C STRIPS statevariable representation. blocks world domain environment blocks
placed table top blocks problems involve stacking
100

fiSynthesizing Customized Planners Specifications

STRIPS representation

Action: move(A; B; C )
Prec: clear(A) ^ clear(C ) ^ ^on(A; B )
Post: on(A; C ) ^ clear(B ) ^ :clear(C )
^:on(A; B )

Muti-valued state-variable representation

Action: move(A; B; C )
Pre: hB; True; 0; False; 0; Truei
Post: hC; True; 0; True; 0; Falsei

(Where state 6-tuple
h pos-A, clr-A, pos-B, clr-B, pos-C, clr-C i,
zeroes represent \don't care" values)

Figure 4: Different representations \Move B C"
desired configuration. purpose exposition, showing values state
variables corresponding block positions (e.g., pos-A) symbols 'B', 'C', etc. clear
conditions (e.g., clr-A) True False. practice, map valid values state
variables integers.

3.2 Specification Planner

KIDS uses functional specification programming language augmented set-theoretic
data types. specification task (Smith, 1992a) represented quadruple
F = hD; R; I; Oi input type satisfying input condition, : ! boolean.
output type R output condition, : R ! boolean, defines feasible solution. O(x,z) holds, z feasible solution respect input x. specification
program follows template:
function F (x :D) : set(R)
I(x)
returns f z j (x,z) g
= Body(x)
specification program F consistent possible inputs satisfying input
condition, body produces feasible solution, i.e., 8(x : D)9(z : R)(I (x) =) O(x; z )).
Within view, planner takes inputs initial state, goal state operator
list. operators assumed define state transitions valid states valid states.
specification planning task is: given initial state, goal state
operator list, return sequence operators (plan) that:



termination-test: goals must hold final state resulting execu-

tion plan. (We considering planning problems goal
make state-variables achieve specified values, i.e., goals achievement).
domain-independent-pruning-test: plan passes domain independent
pruning tests. planning refinemen specify conditions partialplan cannot lead desirable solution; partial plan satisfying pruning
101

fiSrivastava & Kambhampati

function PLANNER
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))))
returns
(PLAN: seq(integer)
| range(PLAN) subset {1 .. size(OPERS)}
& GOODNESS-TEST(VISITED-STATES
(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK(VISITED-STATES
(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& GOAL-TEST(VISITED-STATES
(PLAN, INIT, GOAL, OPERS),
INIT, GOAL))

Figure 5: declarative specification planning
test eliminated consideration. example, state-loop pruning heuristic forward state-space refinement says partial plan
plan-state executing operator O2 subset state following
earlier operator O1 , partial-plan pruned.
domain-dependent-pruning-test: plan passes additional domain-specific
pruning tests.
last one hook domain specific control knowledge introduced.
current implementation CLAY, use domain knowledge rejecting undesirable
partial plans. Section 7.1, discuss ways implementation extended
support uses domain control knowledge.
specification planning task declarative states constraints must satisfied resulting plan produced planner given planning
problem. suggest algorithm used obtain results. Algorithmic decisions made program development phase KIDS.
example top-level specification planning task (in REFINE) shown Figure 5.
specification, input condition, , true, input data type, includes INIT,
GOAL OPERS, output data type R PLAN output condition consists
goodness-test, goal-test, no-moves-back. no-moves-back domain independent
pruning tests whereas goodness-test domain dependent pruning test.
Delving deeper representation detail, represent plan sequence indices
operator list (i.e., sequence operator identifiers). state-space planning,
state sequence corresponding partial-plan produced function visited-states
goal test, domain independent pruning tests domain dependent pruning tests
done state-sequence functions goal-test, no-moves-back goodnesstest respectively. state-variables take integer values. Consequently, initial
goal states sequence integers.
words, specification Figure 5 says partial plan sequence integral
indices (of operators) indices must size operator list. Valid
102

fiSynthesizing Customized Planners Specifications

plan one whose corresponding state sequence (produced visited-states) satisfies
goal-test, no-moves-back goodness-test2.
context forward-state space refinement (FSS), visited-states returns
states obtained successive application operators partial plan
initial state resulting states thereafter. goal-test signals goal
achieved; FSS refinement involves checking last state state-sequence
goal state. no-moves-back function tests state looping; forward state-space
looping checks state executing operator Oj (STATE Sj ) subset state
following earlier operator Oi (i < j ) (STATE Si ), partial-plan pruned3.
function goodness-test checks possible redundancy state sequence
corresponding current partial plan based domain characteristics. Let us explain
context blocks world domain. specify reasonable checks
blocks world long make planner lose desired solution. Below,
present two goodness-tests:

(Heuristic H1: Limit useless moves) block moves states (i+1),

must change position states (i+1) (i+2). motivation behind
check prevent blocks moved around randomly successive moves.
(Heuristic H2: Move via table) block move initial state
table table goal position. motivated fact
polynomial time approximate algorithm solving blocks world planning problems involves putting blocks table first, constructing goal
configuration stacks bottom-up.4

3.3 Implementing Specification using Global Search

discussed Section 2, need select algorithm design tactic implement task
specification KIDS. One design tactics provided KIDS global search. basic
idea global search represent manipulate sets candidate solutions. principal
operations extract candidate solutions set split set subsets.
Derived operations include various filters used eliminate sets containing
feasible optimal solutions. Global search algorithms work follows: starting
initial set potential solutions, contains desired solutions given problem
instance, algorithm repeatedly extracts solutions, splits sets eliminates sets via
filters candidate solution drawn one sets. Sets solutions
represented implicitly data structures called descriptors, splitting done adding
2. REFINE code referenced functions shown Appendix A.
3. Actually, test slightly general condition state executing operator Oj (STATE
Sj ) weaker state following earlier operator Oi (STATE Si ), partial-plan
pruned. Sj weaker Si every state-variable assigned value state Si assigned
value state Sj . specifying weakness rather subset relationship states decide
domain independent pruning state space planning, allow synthesized planner deal
partially specified initial state. planner work correctly long state-variables
required reasoning specified initial state.
4. pruning test alone doesn't guarantee polynomial algorithm since order blocks
put table later goal positions specified pruning heuristic.

103

fiSrivastava & Kambhampati

mutually exclusive exhaustive sets constraints descriptors. process
described tree search node represents set candidates arc
represents split relationship set subset. complete details, readers
referred (Smith, 1992a).
KIDS' global search paradigm general form refinement search model
used unify classical planners UCP (Kambhampati & Srivastava, 1995). Specifically,
partial plans correspond descriptors refinements correspond splitting
strategies. use global search implement planner specification, need select
suitable representation sets potential solutions (which, refinement view
planning, essentially partial plans). global search tactic would set
search algorithm split solution-set extract solutions meet problem
specification. KIDS provides global search tactics primitive data-types sequences,
sets maps. complex data type needed represent potential solution set
task, user must implement global search tactic it.
Since interested state-space planners initially, chose represent partial
plan sequence operators (actually sequence operator indices). allowed us
use KIDS global search theory finite sequences.

3.4 Specifying Distributive Monotonic laws

One aspect KIDS specification slightly unintuitive new users need
specify distributive monotonic laws operations used input/output
specification (e.g., no-moves-back specification progression planner shown
Figure 5). Distributive laws state specific operation distributes operations
(e.g., (A + B ) C (A C ) + (B C )), monotonic laws provide set boundary
conditions (e.g., +0 = A). laws explicitly stated operations involved
specification support instantiation design tactics, well optimization
generated code. Specifically, KIDS directed-inference engine called RAINBOW
uses task specification distributed laws specified user simplify
reformulate expressions synthesized code. Deductive inference primary
means KIDS reasons task specification order apply design tactics,
optimize code, derive necessary pruning conditions. Distributive monotonic
laws indirectly provide KIDS information alternative ways defining predicates.
useful heuristic writing laws simple, normally expressed
terms main function perhaps another function handle boundary cases (called
cross-functions; see below). example, consider Figure 5 function no-movesback domain independent pruning test used specification progression planners.
Recall no-moves-back called state sequence checks later state
subset (or weaker than) earlier state. Calling no-moves-back sequence
concatenation state sequences S1 S2 equivalent calling S1
S2 testing state S1 weaker state S2. Notice first two
tests handled no-moves-back last test needs new function.
call new function cross-function no-moves-back (cross-no-moves-back).
monotonic laws no-moves-back include:



no-moves-back singleton state sequence true.

104

fiSynthesizing Customized Planners Specifications



no-moves-back empty state sequence false (useful selected action

applicable).

Similarly, distributive laws no-moves-back include:



no-moves-back sequence concatenation equal no-moves-back S1 , nomoves-back S2 cross-no-moves-back S1 S2 .

state prepended state sequence , applying no-moves-back

combined state sequence equivalent applying cross-no-moves-back
singleton sequence [A] , no-moves-back .
state appended state sequence , no-moves-back
combined state sequence no-moves-back cross-no-movesback singleton sequence [A].

rules, reasonably obvious us, nonetheless crucial
effectiveness KIDS help reformulating optimizing generated code.
example use, see Section 3.5.1, occurs Figure 7 \if
[condition] - [then] - [else]" statement gets simplified \[then]" part
conditions \[condition]" proved true context input
specification, given distributive laws.
Using task specification, selected design tactic { global search, distributive
laws, KIDS produces correct naive code, shown Figure 6. code naive
checks (for example cross-no-moves-back Figure 6) computed
repeatedly even true context. discuss methods optimize
code next section.

3.5 Program Optimization

section explains initial planner code, generated KIDS, optimized. Readers
familiar automated software synthesis literature might want skip section
first read, revisit later details.
first code produced KIDS (shown Figure 6) well-structured inecient. several opportunities optimization KIDS provides tools program
optimization. code compiled executed stage optimization. Now,
brie summarize program optimizations used achieve eciency.
3.5.1 Context Independent Simplifier

method simplifies expression independent surrounding context.
two possibilities context independent simplification:
first case, set equations treated left-to-right rewrite rules
fired exhaustively none apply. Distributive laws treated rewrite rules.
example application rewrite rule is:
(if true P else Q) =) P
105

fiSrivastava & Kambhampati

function PLANNER
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))))
returns
(PLAN: seq(integer)
| range(PLAN) subset {1 .. size(OPERS)}
& GOODNESS-TEST
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& GOAL-TEST
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL))
= NO-MOVES-BACK
(VISITED-STATES([], INIT, GOAL, OPERS),
INIT, GOAL)
& GOODNESS-TEST
(VISITED-STATES([], INIT, GOAL, OPERS),
INIT, GOAL)
PLANNER-AUX(INIT, GOAL, OPERS, [])
else undefined

function PLANNER-AUX
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))),
V: seq(integer)
| range(V) subset {1 .. size(OPERS)}
& GOODNESS-TEST
(VISITED-STATES(V, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK
(VISITED-STATES(V, INIT, GOAL, OPERS),
INIT, GOAL))
: seq(integer)
= ex (PLAN: seq(integer))
(GOAL-TEST
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& GOODNESS-TEST
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& range(PLAN) subset {1 .. size(OPERS)}
& PLAN = V)
(PLAN-1: seq(integer))
(GOAL-TEST
(VISITED-STATES(PLAN-1, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK
(VISITED-STATES(PLAN-1, INIT, GOAL, OPERS),
INIT, GOAL)
& GOODNESS-TEST
(VISITED-STATES(PLAN-1, INIT, GOAL, OPERS),
INIT, GOAL)
& range(PLAN-1) subset {1 .. size(OPERS)}
& PLAN-1 = V)
else (PLAN-2: seq(integer))
ex (NEW-V: seq(integer))
(PLAN-2 =
PLANNER-AUX(INIT, GOAL, OPERS, NEW-V)
& DEFINED?(PLAN-2)
& GOODNESS-TEST
(VISITED-STATES(NEW-V, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK
(VISITED-STATES(NEW-V, INIT, GOAL, OPERS),
INIT, GOAL)
& ex (I: integer)
(NEW-V = append(V, I)
& {1 .. size(OPERS)}))

Figure 6: First progression blocks world planner code synthesized KIDS. Notice
code inecient checks (for example, cross-no-moves-back)
computed repeatedly, even true context.

106

fiSynthesizing Customized Planners Specifications

function PLANNER
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))))
returns
(PLAN: seq(integer) |
range(PLAN) subset {1 .. size(OPERS)}
...)
= NO-MOVES-BACK
(VISITED-STATES([], INIT, GOAL, OPERS),
INIT, GOAL)
GOODNESS-TEST
(VISITED-STATES([], INIT, GOAL, OPERS),
INIT, GOAL)
PLANNER-AUX
(INIT, GOAL, OPERS, [], [INIT], INIT,
size(OPERS))
else undefined

function PLANNER
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))))
returns
(PLAN: seq(integer) |
range(PLAN) subset {1 .. size(OPERS)}
...)
= PLANNER-AUX
(INIT, GOAL, OPERS, [], [INIT], INIT,
size(OPERS))

Figure 7: Example context independent simplification KIDS. code right
size simplified version left.
function PLANNER-AUX
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))),
V: seq(integer)
| range(V) subset {1 .. size(OPERS)}
GOODNESS-TEST(VISITED-STATES
(V, INIT, GOAL, OPERS),
INIT, GOAL)
NO-MOVES-BACK(VISITED-STATES
(V, INIT, GOAL, OPERS),
INIT, GOAL))
: seq(integer)
= GOAL-TEST(
VISITED-STATES(V, INIT, GOAL, OPERS),
INIT, GOAL)
NO-MOVES-BACK(VISITED-STATES
(V, INIT, GOAL, OPERS),
INIT, GOAL)
GOODNESS-TEST(VISITED-STATES
(V, INIT, GOAL, OPERS),
INIT, GOAL)
range(V) subset {1 .. size(OPERS)}
(if ...) ...

function PLANNER-AUX
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))),
V: seq(integer)
| range(V) subset {1 .. size(OPERS)}
GOODNESS-TEST(VISITED-STATES
(V, INIT, GOAL, OPERS),
INIT, GOAL)
NO-MOVES-BACK(VISITED-STATES
(V, INIT, GOAL, OPERS),
INIT, GOAL))
: seq(integer)
= GOAL-TEST(
VISITED-STATES(V, INIT, GOAL, OPERS),
INIT, GOAL)
(if ...) ...

Figure 8: Example context dependent simplification KIDS. code right size
simplified version left.

second case, occurrences local variable defined equality

replaced equivalent value:
fC (x) j x = e ^ P (x)g =) fC (e) j P (e)g
Figure 7 shows example context-independent simplification conditions
if-condition true respective distributive laws. Hence, if-then-else
statement replaced then-part.
107

fiSrivastava & Kambhampati

function PLANNER-AUX
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))),
V: seq(integer), VS: seq(seq(integer)),
L-VS: seq(integer) |
SEQEQUAL(L-VS, last(VS))
range(V) subset {1 .. size(OPERS)}
...)
= GOAL-TEST(VS, INIT, GOAL) V
else (PLAN-2: seq(integer))
exists(I: integer)
(I {1 .. size(OPERS)}
...

function PLANNER-AUX
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))),
V: seq(integer), VS: seq(seq(integer)),
L-VS: seq(integer), NUM-OPS: integer
|
NUM-OPS = size(OPERS)
...)
= GOAL-TEST(VS, INIT, GOAL) V
else (PLAN-2: seq(integer))
exists(I: integer)
(I {1 .. NUM-OPS}
...

Figure 9: Example finite differencing (on size(OPERS)). code right size
result finite differencing left.
0. Focus Initialize PLANNER
1. Tactic Global Search PLANNER
2. Simplify, context-independent-fast: ## ##
else (PLAN-2: ##...
3. Simplify, context-dependent, forward-0, backward-4:
##(...) & ##(....
4. Simplify, context-dependent, forward-0, backward-4:
## else und...
5. FD (general-purpose) VS =
VISITED-STATES(V, INIT, GOAL, OPERS)
6. FD (general-purpose) L-VS = last(VS)
7. FD (general-purpose) NUM-OPS = size(OPERS)
8. Abstract NEXT-STATE(L-VS, I, OPERS) NS
ex (I: integer) (## ## &...
9. Simplify, context-independent-fast:
## & ## PLANNER-AUX(##, ##,...
10. Refine compile Lisp: PLANNER-AUX, PLANNER

Figure 10: Derivation steps generate progression planner blocks world domain.
3.5.2 Context Dependent Simplifier

method designed simplify given expression respect surrounding context is, thus, powerful context independent simplification. predicates
hold context expression gathered walking abstract syntax
tree. expression simplified respect set assumptions hold
context. Figure 8, function calls no-moves-back, goodness-test
range test \if" expression redundant results follow input
invariant (conditions listed \j" \:") PLANNER-AUX function.
removed simplification.

108

fiSynthesizing Customized Planners Specifications

function PLANNER
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))))
returns
(PLAN: seq(integer)
| range(PLAN) subset {1 .. size(OPERS)}
& GOODNESS-TEST
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& NO-MOVES-BACK
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL)
& GOAL-TEST
(VISITED-STATES(PLAN, INIT, GOAL, OPERS),
INIT, GOAL))
= PLANNER-AUX
(INIT, GOAL, OPERS, [], [INIT],
size(OPERS), INIT)

function PLANNER-AUX
(INIT: seq(integer), GOAL: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))),
V: seq(integer), VS: seq(seq(integer)),
NUM-OPS: integer, L-VS: seq(integer)
| SEQEQUAL(L-VS, last(VS))
& SEQEQUAL(VS,
VISITED-STATES(V, INIT, GOAL, OPERS))
& NO-MOVES-BACK
(VISITED-STATES(V, INIT, GOAL, OPERS),
INIT, GOAL)
& GOODNESS-TEST
(VISITED-STATES(V, INIT, GOAL, OPERS),
INIT, GOAL)
& range(V) subset {1 .. size(OPERS)}
& NUM-OPS = size(OPERS))
: seq(integer)
= GOAL-TEST(VS, INIT, GOAL) V
else (PLAN-2: seq(integer))
ex (NS: seq(integer), I: integer)
(NS = NEXT-STATE(L-VS, I, OPERS)
& CROSS-NO-MOVES-BACK(VS, [NS], INIT, GOAL)
& CROSS-GOODNESS-TEST(VS, [NS], INIT, GOAL)
& DEFINED?(PLAN-2)
& PLAN-2
= PLANNER-AUX
(INIT, GOAL, OPERS, append(V, I),
append(VS, NS), NUM-OPS, NS)
& {1 .. NUM-OPS})

Figure 11: Final progression blocks world planner code synthesized KIDS
3.5.3 Finite Differencing

idea behind finite differencing perform computations incrementally rather
repeat scratch every time. Let us assume inside function f (x)
expression g(x) x changes regular way. case, might useful
create new variable, equal g(x), whose value maintained across iterations
allows incremental computation g(x) next x value. Finite differencing
decomposed two basic operations: abstraction simplification (Smith, 1992a)

First, function f abstracted respect expression g(x) adding new
parameter c parameter list f (now f (x; c)) adding c = g(x) new input
invariant f . calls f , whether recursive calls within f external calls, must
changed match definition f i.e, f (x) changed f (x; g(x)).
process, occurrences g(x) replaced c.
distributive laws apply g(h(x)) yielding expression form h0(g(x))
h0 (c), new value g(h(x)) computed terms old value g(x)
real benefit optimization.

Let us illustrate process example. Suppose function f (x)
call function g(x) returns square numbers variable x varies linearly.
Now, suppose given distributive law g(x + 1) = g(x) + 2 x + 1. So,
finite-differencing, f becomes f (x; c) g(x) call replaced c + 2 x + 1.
109

fiSrivastava & Kambhampati

additional invariant c = x x maintained f . new expression
computationally much cheaper original expression.
Figure 9, finite differencing performed size(OPERS ). argument function
PLANNER expanded inclusion NUM-OPS, name entered user
value size(OPERS ). abstraction done number operators
available planner change planning. Note NUM-OPS represents
number operators planning problem meaningful concept planning.
instances size(OPERS ) replaced NUM-OPS.
3.5.4 Program Derivation

Figure 10 shows summary sequence derivation steps carried obtain
blocks world domain-specific forward-state space planner. final version planner
code shown Figure 11.
step 0, top-level planner specification selected step 1, selected design
tactic applied. Step 2 involves context independent simplification, steps 3
4 involve context dependent simplifications. Steps 5 8 cover finite differencing.
Finally, ecient planner code compiled step 10.

4. Discussion Synthesized Planners

Section 3.5 used synthesis progression planner blocks world domain case
study walk-through planner synthesis process leading final planner given
Figure 11. research, considered regression (backward state space)
planners. planners synthesized date summarized Table 1. Although
planners differ terms refinements use, domains
customized, Figure 12 attempts pseudo-code description generic template
facilitate discussion synthesized planners group.
main function planner takes initial state, goal state operator set
inputs turn calls recursive function planner aux inputs
initial plan. pruning tests comprising output conditions maintained
\invariants" (in must hold final plan, every partial
plan leading final plan). goal test, course, need hold final plan,
thus maintained invariant. Finite differencing leads invariants.
Inside planner aux, partial plan satisfies goal test, returned. Otherwise,
partial plan refined, invariants incrementally tested new partial plan
planner aux called recursively.
First thing note pseudo-code template describes planner planning
domain employing state-space refinement. Even requirement synthesized
planner state-space dictated new partial plan (partial-plan2) obtained
(in case appending operator operator sequence). generalized
support refinements, modifying operation (in current case \append")
used build new partial plan old one (with corresponding changes
distributive laws account new operation).
Second, observe invariants incrementally evaluated (see planner aux).
example, see plan ith iteration satisfies no-moves-back test,
110

fiSynthesizing Customized Planners Specifications

check latest state duplicated previous states. hypothesize
incremental evaluation primary reason synthesized planner's eciency.
refinement planning domain knowledge available, context-dependent simplification
may show many tests made separate theories fact redundant.
Moreover, incremental evaluations may cheaper complete evaluations invariants
amenable operations distribution monotonicity abstract
data-types.
Although domain independent planners given control knowledge
give KIDS planner synthesis, approach expected superior two
ways:
1. approach separates control knowledge acquisition specifics
planner extent makes acquisition process easier. contrast,
controlling search domain independent planner requires user think
terms specific \choice-points" planner's search strategy.
2. importantly, search control domain independent planners typically involves
generating unpromising partial plans first pruning them. contrast, approach improves eciency \folding in" control knowledge synthesized
planner code, incremental evaluation pruning test. Specifically, first
approximation, conventional domain independent planners add goodnesstest either control search choice points post-process generated partial plans. specify distributive laws goodness-test
incrementally evaluated (in terms cross-goodness-test goodness-test)
perform context-dependent analysis pieces available knowledge
optimize code. mean \folding in" control knowledge.
Figure 11, see instance control knowledge folded synthesized progression planner blocks world domain. Contrast first synthesized
planner shown Figure 6. notice redundant invocation various checks (such
goodness-test, visited-states, etc) earlier planner simplified away.
Moreover, individual checks (such no-moves-back goodness-test)
simplified based distributive laws (like cross-no-moves-back crossgoodness-test) consider newly added parts partial plan.
considerations lead small ecient final planner.

5. Empirical Evaluation Synthesized Planners

Table 1 lists several domain dependent state-space planners synthesized
date. planners characterized domain developed (\BW"
blocks world, \LOG" logistics, \TYR" Tyre World { benchmark
domains AI planning); type (state-space) refinement used (\P" progression
\R" regression), type domain specific control knowledge used (H1
limits useless moves, H2 moves blocks via table, etc.). report results
empirical study conducted synthesized planners. study two aims:
ascertain whether synthesized planners able eciently exploit domain
knowledge.
111

fiSrivastava & Kambhampati

%% main function PLANNER calls auxiliary function
function PLANNER (INITIAL_STATE, GOAL_STATE, OPERATOR_SET)
returns PLAN
OUTPUT CONDITIONS satisfied
=
PLANNER_AUX(INITIAL_STATE, GOAL_STATE, OPERATOR_SET,
INITIAL_PLAN, ...)
%% Note: parameters added finite differencing
%% function PLANNER_AUX called PLANNER PLANNER_AUX
%% Note: set OUTPUT CONDITIONS given part
%%
problem specification, KIDS selects one
%%
maintained INVARIANTS. Finite differencing
%%
gives INVARIANTS.
function PLANNER_AUX(INITIAL_STATE, GOAL_STATE, OPERATOR_SET,
CURRENT_PLAN, ...)
INVARIANTS satisfied state sequence
corresponding CURRENT_PLAN
return type PLAN
=
state sequence ensures satisfaction GOAL_STATE
CURRENT_PLAN executed INITIAL_STATE
return CURRENT_PLAN
else consider PARTIAL_PLAN2 = append(CURRENT_PLAN, I)
index valid operator OPERATOR_SET,
a) incremental test INVARIANTS true
state sequence corresponding PARTIAL_PLAN2
b) PARTIAL_PLAN2 =
PLANNER_AUX(INITIAL_STATE, GOAL_STATE, OPERATOR_SET,
PARTIAL_PLAN2, ...)

Figure 12: Pseudo-code state-space planners synthesized KIDS

ascertain synthesized planners better traditional domain indepen-

dent planners utilizing domain control knowledge.
discussion organized follows: Section 5.1, describe domains
problems considered empirical work. Section 5.2, evaluate absolute
performance synthesized planners various domains. Section 5.3 compare
performance synthesized planners traditional planners.

5.1 Domains Problems
5.1.1 Blocks World Domain

blocks world domain environment block placed either table
top blocks, problems involve stacking desired configuration.
Let us focus two states particular: A-ON-TOP N-ON-TOP.
.. N blocks, A-ON-TOP stands state block top block B, block B
112

fiSynthesizing Customized Planners Specifications

Name
BW-P-H1
BW-P-H2
BW-R-H1
BW-R-H2
LOG-P-L
LOG-R-L
TYR-P-M
INDEP-P
INDEP-R

Customized
domain
Blocks World
Blocks World
Blocks World
Blocks World
Logistics
Logistics
Tyre World
-none-none-

Refinement

Domain Dependent Pruning Test

Progression (FSS)
Progression (FSS)
Regression (BSS)
Regression (BSS)
Progression (FSS)
Regression (BSS)
Progression (FSS)
Progression (FSS)
Regression (BSS)

Limit useless moves (H1)
Move via table (H2)
Limit useless moves (H1)
Move via table (H2)
Limit ineciency
Limit ineciency
Multiple control rules
True (every state OK)
True (every state OK)

Table 1: Table showing variety planners synthesized KIDS. names
planners follow format <domain>-<refinement>-<heuristic>.
top block C, ..., block N-1 top block N block N table. Similarly,
N-ON-TOP stands state block table, block B top block A,
..., block N top block N-1. Problems reported experiments one three
types:
1. Stack Inversion: Invert A-ON-TOP N-ON-TOP.
2. Stack building: Initial state collection random stacks two blocks height
last N/2 blocks either put first N/2 blocks table.
Goal state A-ON-TOP N-ON-TOP.
3. Random blocks world problems: subset random blocks world problems generated using Minton's algorithm (Minton, 1988). problem N blocks, goal
state N/2 goal conditions.
domain dependent pruning tests blocks world covered Section 3. Specifically, covered pruning test H1 prevents block moved consecutive
steps, test H2 requires blocks moved via table.
5.1.2 Logistics Domain

logistics domain consists several planes packages different places. goals
involve transporting planes packages specified locations. considered
type logistics domain k planes, 2k places 3k packages.
either 2 packages 1 package 1 plane place. goal get planes
packages distinguished place.
domain dependent pruning test logistics transportation domain, (which
call \Limit Ineciency" heuristic) consists following pieces advice:
113

fiSrivastava & Kambhampati

1. Planes make consecutive ights without loading unloading package
2. Packages either goal position begin with, may loaded inside
plane goal position.
3. package reaches goal position, moved.
5.1.3 Tyre World Domain

Tyre world (Russell & Norvig, 1995) benchmark domain complex causal
structure (Blum & Furst, 1995). \fixit" problem domain, car's tyre
must replaced spare tyre (which must first ated). original
tyre placed boot tools must returned boot. domain
dependent pruning test devised enforces following constraints:
1. one state variable changes one state(S1 ) next state(S2 ),
change subsequent state(S3 ). state variable describes attribute object domain. attribute value
state S2 \overwritten" state S3 , might indicate non-minimal
plan.5
2. Work status boot last.
3. Fixing free hub invalid { wheel must first.
4. jacked-up car needs tyre, jack without putting
tyre it.
5. Work position pump wrench wheels hub
final configuration.
6. wheels goal positions, moved.

5.2 Absolute Performance Synthesized Planners

section, discuss absolute performance synthesized planners different
domains. shall see, synthesized planners able solve benchmark
problems known hard traditional planners. special note order
regarding plots follow. plots follow, curve stops mid-way
graph, means corresponding planner could solve given problem
problems problem class (as applicable) stipulated time.
5.2.1 Planners Blocks World

traditional planners, domain specific information helps planner return result faster
obtained similar results synthesized planners. seen left
5. true domains, since domains, way state variable shift value
v1 v3 transition v2 . heuristic however preserve completeness tyre
world.

114

fiSynthesizing Customized Planners Specifications

Synthesized Progression Planners Block World

Synthesized Progression Planner Logistics

Effectiveness domain-based pruning tests

Effectiveness domain-base pruning tests

100000.0

10000.0

BW-P-H1
INDEP-P

LOG-P-L
INDEP-P
1000.0

1000.0

log [time (in secs)]

log [time (in secs)]

100.0

10.0

10.0

1.0
0.1
0.1

0.0
2.0

12.0

0.0
1.0

22.0
# blocks

2.0
3.0
4.0
5.0
# planes(2X places, 3X packages)

6.0

Figure 13: Plots show domain dependent goodness tests lead ecient planners.
problem domains blocks world (left) logistics transportation domain
(right). Planners domain guidance perform better without it.
plot Figure 13, domain-specific blocks world heuristic H1 (\Limit useless moves")
helped progression planner (BW-P-H1) solve stack inversion problem (invert AON-TOP N-ON-TOP) 14 blocks minute, 22 blocks 30
minutes. Without heuristic, progression planner (INDEP-P) could solve even
5 block stack inversion problem time.
5.2.2 Planners Logistics Domain

logistics domain, progression planner Limit Ineciency heuristic (LOGP-L) could solve 4-plane problems minute 6-plane problems 30 minutes
(Figure 13, right). Without heuristic, progression planner (INDEP-P) could
solve even 2 plane problem time.
5.2.3 Planners Tyre World

25 operators, 27 state variables 6 control rules manually encoded Tyre
world (Russell & Norvig, 1995) description. fixit problem solved minute
31 step plan returned.

5.3 Comparing Traditional Synthesized Planners Blocks World

Since synthesized planners used domain specific control knowledge normally
used domain independent planners, next step involved comparing synthesized planners domain independent planners using control knowledge. aim see
synthesized planners better able exploit domain knowledge traditional planners. restricted detailed comparison blocks world domain. Since
115

fiSrivastava & Kambhampati

variety traditional classical planners varying tradeoffs
(c.f. (Barrett & Weld, 1994; Kambhampati et al., 1995)), used \league tournament"
approach comparison. Specifically, since popular classical planners correspond
different instantiations UCP (Kambhampati & Srivastava, 1995), first ran
blocks world problem distribution isolate best traditional planners. Similar
study done isolate best synthesized planners problem distribution.
point, best synthesized planner compared best traditional planner.
second round comparison, winning traditional planner given control
knowledge synthesized planner.
used two three blocks world test suites { random blocks world
problems stack building problems { comparisons. problem class
defined terms number blocks average 10 runs shown plot.
total time allowed class problems 1000 seconds planner
deemed failed problem class. planners run problems
problem suite.
5.3.1 Picking Best Synthesized Planner

section, want empirically determine effective refinement
control knowledge (heuristics) blocks world problem suites. ran six synthesized
planners (BW-P-H1, BW-P-H2, INDEP-P, BW-R-H1, BW-R-H2 INDEP-R)
test suite. Figure 14 shows relative performance. notice planners
pruning test H2 perform best compared planners using
refinement.6
5.3.2 Picking Best Traditional Planner

section, empirically search best UCP strategy blocks world. Figure 15 shows performance UCP instantiations domain dependent heuristic
information. Instantiations UCP FSS, BSS PS refinements emulate
classical forward-state space, backward-state space plan-space planners, respectively.
call instantiations UCP-FSS, UCP-BSS UCP-PS. UCP-LCFR hybrid strategy
interleaves FSS, BSS PS refinements depending lower branching factor
(Kambhampati & Srivastava, 1995). random blocks world problems (left)
stacking building problems (right), left right plots, UCP-FSS solves
6. notice progression planners perform better left plot regression planners perform
better right plot. trend explained easily terms way refinements operate
(Kambhampati, 1997b). left figure, based nature goals, branching factor
regression planners may become enormous cannot detect con icts among
steps give conditions goal (or steps eventually support goal condition). Many
operators seem potentially give condition actually case. hand,
completely specified initial state helps progression planner decide applicable operators
beginning itself. Consequently, progression planner BW-P-H2 clear win. right plot,
initial goal states completely specified, regression progression planners detect
con icts. true realistic domains, many operators applicable initial state
relevant achieving goal conditions. So, regression planner BW-R-H2 performs better
progression planner BW-P-H2.

116

fiSynthesizing Customized Planners Specifications

Performance Synthesized Planners

Performance Synthesized Planners

Random blocks world problems

Build stack achieve A-ON-TOP

100.0

100.0

BW-P-H1
BW-P-H2
INDEP-P
BW-R-H1
BW-R-H2
INDEP-R

10.0

log [time (in secs)]

log [time (in secs)]

10.0

1.0

0.1

0.0
3.0

BW-P-H1
BW-P-H2
INDEP-P
BW-R-H1
BW-R-H2
INDEP-R

1.0

0.1

5.0

7.0
# blocks

9.0

0.0
3.0

11.0

5.0

7.0
# blocks

9.0

11.0

Figure 14: Performance synthesized progression regression planners H1,
H2 domain dependent control knowledge. BW-P-H2 perform best
left plot BW-R-H2 performs best right plot. points close
together, clear BW-R-H1 INDEP-R solve problems upto 3
blocks left plot.
Performance UCP Instantiations

Performance UCP Instantiations

Mintons random blocks world problems

Go random stacks upto two blocks height A-ON-TOP

100.0

100.0

UCP-PS
UCP-FSS
UCP-BSS
UCP-LCFR

UCP-PS
UCP-FSS
UCP-BSS
UCP-LCFR
10.0

log [time (in secs)]

log [time (in secs)]

10.0

1.0

0.1

0.0
3.0

1.0

0.1

4.0

5.0
# blocks

6.0

0.0
3.0

7.0

4.0

5.0
# blocks

6.0

7.0

Figure 15: Performance UCP instantiations domain dependent heuristic.
left right plots, UCP-FSS solves problems least time. Based
results, see UCP-FSS good strategy blocks world. Note
figure UCP-BSS solves 3 blocks problems given time
plots.
117

fiSrivastava & Kambhampati

Comparison UCP-FSS Synthesized Planners

Comparison UCP-FSS Synthsized Planners

Random blocks world problems

Build stack achieve A-ON-TOP

100.0

100.0
BW-P-H2
UCP-FSS-H2

BW-R-H2
UCP-FSS-H2

10.0

log [time (in secs)]

log [time (in secs)]

10.0

1.0

0.1

0.0
3.0

1.0

0.1

5.0

7.0
# blocks

9.0

0.0
3.0

11.0

5.0

7.0
# blocks

9.0

11.0

Figure 16: best UCP strategy blocks world, namely UCP-FSS, performs
best KIDS' synthesized planners: left plot, UCP-FSS better
INDEP-P i.e., without heuristic information. H2 heuristic
given planners, BW-P-H2 winner. right plot, BW-R-H2
outperforms UCP-FSS H2.
problems least time. Based results, see UCP-FSS good strategy
blocks world problem distributions used.7
5.3.3 Comparing Best Synthesized Planner Best Traditional
Planner

Finally, pit best UCP strategy blocks world, namely UCP-FSS,
best KIDS' synthesized planners. chose BW-P-H2 random blocks world
problem suite BW-R-H2 stack building problem suite. Comparison done
planners either given heuristic information (H2) domain dependent
guidance. Figure 16 plots results. left plot, BW-P-H2 clear winner
planners given domain specific heuristic H2. right plot, BW-R-H2
outperforms UCP-FSS H2. So, see given heuristic information,
best planners synthesized KIDS outperform best instantiation UCP
blocks world.
interesting note synthesized planners improve drastically
domain specific knowledge, domain independent planners always improve
way. illustrate Figure 17, compare UCP instantiations
synthesized planers without control heuristics. synthesized planners
7. Note case synthesized planners, planner based regression outperformed one based
progression stack building problems. contrast, UCP-FSS performs UCP-BSS
problem suite. reason particular implementation UCP-BSS,
involves costly unification step.

118

fiSynthesizing Customized Planners Specifications

Comparison UCP-FSS Synthesized Planners Comparison UCP-FSS Synthesized Planners
Random blocks world problems

Build stack achieve A-ON-TOP

100.0

100.0
BW-P-H2
UCP-FSS-H2
INDEP-P
UCP-FSS-DOM-INDEP

BW-R-H2
UCP-FSS-H2
INDEP-R
UCP-FSS-DOM-INDEP
10.0

log [time (in secs)]

log [time (in secs)]

10.0

1.0

0.1

0.0
3.0

1.0

0.1

5.0

7.0
# blocks

9.0

0.0
3.0

11.0

5.0

7.0
# blocks

9.0

11.0

Figure 17: Effect control knowledge UCP planners vs. KIDS synthesized planners.
always improve addition control knowledge, true UCP
instantiations. Specifically, right plot, see UCP-FSS-H2, uses control
knowledge H2 worse UCP-FSS-DOM-INDEP, use control
knowledge! speculate UCP-FSS explicitly calls function
domain-specific reasoning recursive invocation synthesized planners
domain control knowledge folded planner code (see Section 4).

5.4 Summary Results

summary, demonstrated that:

CLAY approach writing domain-specific planning theory exible. sup-

ports mix-and-match refinements control knowledge generating variety
customized planners. examples, presented planners blocks world, logistics
domain Tyre domain, using forward backward state space refinements
different types domain-specific control knowledge.
synthesized planners exploit domain dependent control knowledge improve performance. showed that, fact, better able exploit domain
knowledge traditional planners can.

6. Related Work

research reported straddles two fields automated software synthesis
AI planning. Although research first address issue planner synthesis,
synthesis types search engines addressed Smith co-workers.
particular interest us work developing automated scheduling software
transportation logistics problems using KIDS system (Smith & Parra, 1993; Burstein &
Smith, 1996). scheduling systems generated shown significantly
119

fiSrivastava & Kambhampati

outperform general-purpose schedulers working problem. results provided
initial impetus research. Although original work used design tactic
based global search model scheduling, since developed design
tactics based local search regimes. Another interesting issue brought
work importance \constraint propagation" techniques deriving ecient code.
made us explore role (or lack thereof) constraint propagation planning.
Kambhampati Yang (1996) describe ways refinement planning framework
extended exploit constraint satisfaction techniques. future, hope able
synthesize planners using general theory refinement planning.
Although much work automated planner synthesis, notable exception work Gomes (1995). Gomes synthesized state-space problem solver
\missionaries cannibals" problem KIDS, shown synthesized
code outperforms general purpose problem solvers domain. framework
seen generalization work done Gomes. particular, separate planning
theories dynamics control knowledge, principle supports generation planning code based variety refinements. demonstrated
deriving progression regression planners three different domains (blocks world,
logistics tyre world) two different bodies control knowledge case.
Methodologically, work adds Gomes' results shown given
control knowledge, planners generated KIDS outperform traditional planners
using control knowledge choice points. makes fairer comparison
synthesized general-purpose planners.
existing planners UCPOP (Penberthy & Weld, 1994) PRODIGY
(Fink & Veloso, 1994), customization supported allowing user specify search
control rules checked every choice point search. control rules
used rank search nodes based heuristic, prune unpromising nodes.
main difference approaches synthesis approach described
supports higher degree integration domain knowledge planner
folding synthesized code planner. Planners using search control rules
cannot context dependent analysis incremental application control knowledge.
contrast, approach, control information encoded declaratively planning
algorithm optimized based knowledge available, including
control knowledge.
work utilizing explicit control knowledge addition domain dynamics
deriving planning code parallels recent work Bacchus Kabanza
(1995). concentrate providing rich language control knowledge
specified progression planner. describe language based temporal logic
specify domain control rules. Rather using knowledge prune bad plans
generated, Bacchus Kabanza explore ways incrementally tracking level
satisfaction control axioms planning progresses. approach facilitates
same, refinement independent setting, \folding in" control knowledge
developed planning code, help KIDS framework.
work constraint satisfaction community directed towards producing specialized (customized) programs relevant research described here.
COASTOOL (Yoshikawa, Kaneko, Nomura, & Watanabe, 1994) ALICE systems (Lau120

fiSynthesizing Customized Planners Specifications

riere, 1978) take declarative description CSPs compile specialized algorithms solving them, MULTI-TAC (Minton, 1996) supports automatic configuration constraint
satisfaction programs. MULTI-TAC system, particular, provides interesting contrast approach. MULTI-TAC starts algorithm schema, list high level
heuristic rules various decision points (e.g., \most-constrained-variable-first" heuristic
variable selection \least-constraining-value-first" value selection CSP search),
list ags indicating whether certain procedures (e.g., forward checking CSP)
used. MULTI-TAC uses domain specification specialize high-level
heuristics given it. example, context minimum maximal matching problem
graph theory, most-constrained-variable-first heuristic may become \choose edge
neighbors assigned values" . configuration particular
subset specialized heuristics used, particular assignment ags. MULTITAC first searches space \configurations" see configuration best fits
given problem population. best configuration found, automatically
compiled ecient code using specification refinement techniques similar
described Section 3.5.
MULTI-TAC thus presents interesting middle-ground search control rule
specification approach used UCPOP PRODIGY planners, full integration
domain-knowledge synthesized code, promised CLAY approach. contrast
UCPOP PRODIGY search control rule approach, MULTI-TAC compilation
phase support folding-in search control rules compiled code. contrast
CLAY advocates semi-automatic synthesis piece software manually
guided optimization (through help user specified distributive monotonicity laws),
MULTI-TAC supports fully automating customization configurable template.
CLAY approach effective, need provide declarative specification
task domain control knowledge, well high level algorithm tactics. KIDS
deals instantiating tactics specific problem, simplification needs
guided careful specification distributive/monotonicity laws. contrast, MULTITAC's configuration approach needs algorithm template already semi-customized
specific task, built-in hooks using heuristics. heuristics
specified form meta-heuristic knowledge.
MULTI-TAC, domain knowledge used specializing meta-heuristics.
theory, CLAY approach may support deeper integration domain knowledge
synthesized code; expense significant amount user intervention.
interesting application MULTI-TAC approach context planning might involve
starting UCP planning shell (which configured emulate many varieties
planners), list high-level heuristics guiding decision points UCP shell
(e.g., refinement selection, aw selection etc), searching among configurations
pick planner given problem distribution.

7. Conclusion

research, investigated feasibility using automated software synthesis tools
synthesize customized domain-specific planners. described CLAY architecture
exibly synthesizing ecient domain dependent classical planners declarative
121

fiSrivastava & Kambhampati

theory planning domain theory using software synthesis system (KIDS). Using
framework, classical planner synthesized enriched domain control
knowledge. proof concept, forward state-space backward state-space planners
synthesized blocks-world, logistics tyre world domains.
shown synthesized planners outperform general purpose planners
using amount domain-specific control knowledge argueed
due ability fold-in domain specific control knowledge planner code.
contrast, domain independent planners test control knowledge plan
refined, thus suffer significant application overhead.

7.1 Features Limitations

synthesis approach provides several interesting contrasts main-stream AI planning
work. begin with, AI planning work attempts improve eciency planning
concentrating way plans generated. work differs radically
concentrate \ecient planners" synthesized. use software synthesis techniques lends modularity planner synthesis activity. planning theory specified
declaratively rather form implemented program. supports changes
extensions planning theory. planning theory described independent
domains, control knowledge dynamical knowledge domain specified
domain. selecting different combinations planning theory control
knowledge, synthesize variety domain-customized refinement planners.
Despite promises, approach entail several overheads.
overheads related current state art automated software synthesis
others related current implementation CLAY architecture. follows,
try tease apart.
holy grail automated software synthesis approaches free users lowlevel coding, allow concentrate declarative specification. KIDS
system comes closest promise, still far perfect. start with, user must
reasonably familiar software synthesis process order anything substantial
KIDS. go steep learning curve could understand
structure theories make good use optimizations provided KIDS. Writing
monotonic distributive laws operations help KIDS effective
code simplification still somewhat art. Many times, go back rewrite
domain knowledge KIDS unsuccessful using knowledge provided it.
Advances software synthesis technology may provide support automatic translation
high level control knowledge forms suitable consumption KIDS;
support available right now.
current cost-benefit ratios would recommend using CLAY/KIDS
approach customizing planner one interested customizing single planner
single domain. REFINE code user writes specify synthesis task typically larger one single synthesized planner generated KIDS. Thus, manually
customizing planner domain may still appropriate. However, synthesized approaches may competitive interested able customize
variety planners variety domains.
122

fiSynthesizing Customized Planners Specifications

addition overheads entailed KIDS, specific implementation planning
theories, domain knowledge, etc. lead ineciencies. latter
eliminated better design CLAY architecture. example, make work
simple, decided go one pre-existing canned design tactics provided
KIDS, chose global search theory finite sequences candidate tactic.
choice, found state-variable representation domains suitable
implementation point view. Although getting state-variable representations
actions hard (we wrote couple utility routines converting actions
STRIPS representation state-variable representation), specifying control knowledge
terms representation turned less natural, especially larger domains
Russel's tyre world.
choice in-built design tactics limited types domain knowledge could
specify. control knowledge form node-rejection rules. General
global search allows node-preference knowledge well knowledge regarding effective
ways shrinking set potential solutions, without splitting set (by eliminating
non-solutions).
could eliminate awkwardness state-variable representations well exploit types domain knowledge designing global search tactics specially suited
planning-specific data structures. Although eventually KIDS system may support
larger variety design tactics, customizing design tactics task classes much
line current practice automated software synthesis (Gomes, Smith, & Westfold,
1996).

7.2 Future Directions

work presented seen beginning fairly open-ended research program complements, rather competes with, research ecient planning
algorithms. Ideally, would support synthesis customized planners based
full gamut planning technologies including partial order task-reduction planning. latter already subsumed refinement planning framework developed
(Kambhampati & Srivastava, 1996) supporting synthesis mainly matter
supporting exible partial plan representation KIDS (representing plans
sequences actions suced now, addressing synthesis
state-space planners). currently process (Srivastava, Kambhampati, & Mali, 1997).
generally, time get insights internal workings family planning algorithms, would translate insights declarative specifications
KIDS support synthesis ecient customized domain code. example
recent research plan synthesis approaches based constraint satisfaction. fact,
domain independent planners Graphplan (Blum & Furst, 1995) solve test
suites equal better time compared synthesized planners. taken
preliminary steps towards integrating approaches refinement planning framework using notion disjunctive refinement planning (see Kambhampati & Yang,
1996; Kambhampati, 1997b; Kambhampati, Parker, & Lambrecht, 1997; Kambhampati,
123

fiSrivastava & Kambhampati

1997a). future, work matures, intend explore synthesis planners using
theories disjunctive plan refinement.

Acknowledgements

grateful Doug Smith help KIDS numerous discussions tactics,
global search distributive laws. would thank Carla Gomes discussing
work us making useful suggestions write theories; Nort Fowler
encouragement line research. Thanks due Steve Minton
anonymous referees JAIR many helpful comments toward improving
presentation paper. research supported DARPA Planning Initiative
Phase 3 grant F30602-95-C-0247 (through subcontract Kestrel Arizona State
University).

Appendix A. Sample Code Referred Text
%% Get state sequence partial plan
function VISITED-STATES
(PLAN: seq(integer), IS: seq(integer),
GS: seq(integer),
OPERS: seq(tuple(seq(integer), seq(integer))))
: seq(seq(integer))
= empty(PLAN) [IS]
else
~empty(NEXT-STATE(IS, first(PLAN), OPERS))
prepend(VISITED-STATES(rest(PLAN),
NEXT-STATE(IS, first(PLAN), OPERS),
GS, OPERS), IS)
%% Used VISITED-STATES get next state
%% applying operator
function NEXT-STATE
(STATE: seq(integer), OPER: integer,
OPERATORS: seq(tuple(seq(integer), seq(integer))))
: seq(integer)
= fa (I: integer)(I [1 .. size(STATE)]
=> OPERATORS(OPER).1(I) = 0
OPERATORS(OPER).1(I) = STATE(I))
image(lambda(x)
OPERATORS(OPER).2(x) = 0 STATE(x)
else OPERATORS(OPER).2(x),
[1 .. size(STATE)])

%% Domain independent pruning test FSS refinement
function NO-MOVES-BACK (VIS-STATES: seq(seq(integer)),
IS: seq(integer), GS: seq(integer))
: boolean
= fa (I: integer, J: integer)
(I [1 .. size(VIS-STATES)]
& J [1 .. size(VIS-STATES)]
& < J
=> (fa (INDEX: integer)
(INDEX [1 .. size(first(VIS-STATES))]
=> VIS-STATES(J)(INDEX) =
VIS-STATES(I)(INDEX)
VIS-STATES(I)(INDEX) = 0)))

124

fiSynthesizing Customized Planners Specifications

function CROSS-NO-MOVES-BACK
(R: seq(seq(integer)), S: seq(seq(integer)), IS: seq(integer),
GS: seq(integer)): boolean
= fa (I: integer, J: integer)
(I [1 .. size(R)] & J [1 .. size(S)]
=> (fa (INDEX: integer)
(INDEX [1 .. size(first(R))]
=> S(J)(INDEX) = R(I)(INDEX)
R(I)(INDEX) = 0)))
%% Domain independent goal test FSS refinement
function GOAL-TEST
(VIS-STATES: seq(seq(integer)), INIT: seq(integer),
GOAL: seq(integer)): boolean
= fa (I: integer)
(I [1 .. size(GOAL)]
=> GOAL(I) = 0
last(VIS-STATES)(I) = GOAL(I))

%% Domain dependent pruning test
%% Heuristic H1: Limit useless move blocks world
function NO-REDUNDANCY (S: seq(seq(integer)))
: boolean
= fa (I: integer, INDEX: integer)
(I [1 .. size(S) - 2]
& INDEX [1 .. size(first(S))]
& INDEX mod 2 = 1
S(I)(INDEX) ~= S(I + 1)(INDEX)
=> S(I + 2)(INDEX) = S(I + 1)(INDEX))
%% Domain dependent pruning test
%% Heuristic H2: Move via table blocks world
function NO-REDUNDANCY (S: seq(seq(integer)),
INIT: seq(integer),
GOAL: seq(integer))
: boolean
= fa (I: integer, INDEX: integer)
(I [1 .. size(S) - 1]
& INDEX [1 .. size(first(S))]
& INDEX mod 2 = 1
& S(I)(INDEX) ~= S(I + 1)(INDEX)
=>((%% position state
%% initial state
S(I)(INDEX) = INIT(INDEX)

S(I + 1)(INDEX) =
%% position state I+1 table
(1 + real-to-nearest-integer
(size(first(S)) / 2)))

(S(I)(INDEX) =
%% position state table
(1 + real-to-nearest-integer
(size(first(S))/2))

%% position state I+1
%% goal state
S(I + 1)(INDEX) = GOAL(INDEX))))

125

fiSrivastava & Kambhampati

References

Bacchus, F., & Kabanza, F. (1995). Using temporal logic control search forward
chaining planner. New Directions AI Planning: EWSP 95, IOS Press, 141-153.
Backstrom, C., & Nebel, B. (1993). Complexity results sas+ planning. Research Report,
Dept Comp.and Info Sc., Linkoping Univ., Sweden.
Barrett, A., & Weld, D. (1994). Partial order planning: Evaluating possible eciency gains.
Artificial Intelligence, 67 (1).
Blum, A., & Furst, M. (1995). Fast planning planning graph analysis. Proc IJCAI95, 1636{1642.
Burstein, M., & Smith, D. (1996). ITAS: portable, interactive transportation scheduling
tool using search engine generated formal specifications. Proceedings 3rd
AI Planning Systems Conference, pp. 35{44.
Fikes, R., & Nilsson, N. (1990). STRIPS: new approach application theorem
proving problem solving. Readings Planning. Morgan Kaufmann Publ., San
Mateo, CA.
Fink, E., & Veloso, M. (1994). Formalizing prodigy planning algorithm. CMU CS Tech
Report CMU-CS-94-123.
Gomes, C., Smith, D., & Westfold, S. (1996). Synthesis schedulers planned shutdowns power plants. Proc. 11th Knowledge-Based Software Engg. Conf., IEEE
Computer Society Press, Los Alamitos,CA, 12{20.
Gomes, C. P. (1995). Planning kids. Technical report RL-TR-95-205, Rome Laboratory.
Kambhamapti, S. (1995). Comparative analysis partial order planning htn planning.
ACM SIGART Bulletin, 6.
Kambhampati, S. (1997a). Challenges bridging plan-sythesis paradigms. Proc. Intl.
Joint Conference Artificial Intelligence (IJCAI-97). Morgan-Kaufmann.
Kambhampati, S. (1997b). Refinement planning unifying framework plan synthesis.
AI Magazine, 18 (2), 67{98.
Kambhampati, S., Katukam, S., & Qu, Y. (1996). Failure driven dynamic search control
partial order planners: explanation-based approach. Artificial Intelligence, 88,
253{315.
Kambhampati, S., Knoblock, C., & Yang, Q. (1995). Planning refinement search:
unified framework evaluating design tradeoffs partial order planning. Artificial
Intelligence, 76, 167{238. Special Issue Planning Scheduling.
Kambhampati, S., Parker, E., & Lambrecht, E. (1997). Understanding extending
graphplan. Proc. 4th European Conference Planning. Springer Verlag.
126

fiSynthesizing Customized Planners Specifications

Kambhampati, S., & Srivastava, B. (1995). Universal classical planning: algorithm
unifying state space plan space planning approaches. New Directions AI
Planning: EWSP 95, IOS Press, 61-75.
Kambhampati, S., & Srivastava, B. (1996). Unifying classical planning approaches.
Tech. rep. ASU CSE TR 96-006, Arizona State University. Available
http://rakaposhi.eas.asu.edu/yochan.html.
Kambhampati, S., & Yang, X. (1996). role utility disjunctive representation
refinement planning. Proc. Fifth Conf. Principles Knowledge Representation
Reasoning (KR-96), pp. 135{146.
Lauriere, J. L. (1978). language program stating solving combinatorial
problems. Artificial Intelligence, 10, 29{127.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proc. 9th NCAI-91,
634-639.
Minton, S. (1988). Learning effective search control knowledge: explanation-based
approach. PhD thesis, Carnegie -Mellon University, Pittsburgh, PA.
Minton, S. (1996). Automatically configuring constraint satisfaction problems: case study.
Constraints, 1 (1).
Minton, S. (1990). Quantitative results concerning utility explanation-based learning.
Artificial Intelligence, Vol. 42, pp. 363{392.
Penberthy, J., & Weld, D. (1994). UCPOP: sound, complete, partial order planner
adl. Proc. AAAI-94, 103-114.
Russell, S., & Norvig, P. (1995). Artificial intelligence - modern approach (chap 13).
Prentice Hall, Englewood Cliffs, NJ.
Smith, D. R. (1990). KIDS: semi-automatic program development system. IEEE Trans.
Software Engineering { special issue Formal Methods, 16, No.9, Sep 1990.
Smith, D. R. (1992a). Structure design global search algorithms. Kestrel Tech. Rep.
KES.U.87.11.
Smith, D. R. (1992b). Transformational approach scheduling. Kestrel Institute Tech.
Rep. KES.U.92.2, 54pp.
Smith, D., & Parra, E. (1993). Transformational approach transportation scheduling.
Proceedings 8th Knowledge-based Software Engineering Conference, pp. 14{17.
Chicago, IL, Sept 1993.
Srivastava, B., Kambhampati, S., & Mali, A. (1997). structured approach synthesizing
planners specifications. Proc. 12th IEEE Intl. Conf. Automated Software
Engg., Lake Tahoe, NV.
Tate, A. (1977). Generating project networks. Proc. 5th IJCAI, 888{893.
127

fiSrivastava & Kambhampati

Yoshikawa, M., Kaneko, K., Nomura, Y., & Watanabe, M. (1994). constraint-based
approach high school timetabling problems: case study. Proc. NCAI-94, 1111{
1116.

128


