journal artificial intelligence

submitted published

synthesizing customized planners specifications
biplav srivastava
subbarao kambhampati

department computer science engineering
arizona state university tempe az

biplav asu edu
rao asu edu

abstract

existing plan synthesis approaches artificial intelligence fall two categories
domain independent domain dependent domain independent approaches applicable across variety domains may ecient one given domain
domain dependent approaches need designed domain separately
ecient domain designed one enticing alternative
approaches automatically synthesize domain independent planners given
knowledge domain theory investigate
feasibility existing automated software synthesis tools support synthesis specifically describe architecture called clay kestrel interactive
development system kids used derive domain customized planner
semi automatic combination declarative theory declarative control knowledge specific given domain semi automatically combine derive
domain customized planners discuss means write declarative theory
control knowledge kids illustrate generating class
domain specific planners state space refinements experiments
synthesized planners outperform classical refinement planners implemented instantiations ucp kambhampati srivastava control knowledge
contrast costs benefits synthesis conventional methods
customizing domain independent planners

introduction

given current state world set desired goals set action templates
involves synthesizing sequence actions executed initial
state lead state world satisfies goals fikes nilsson
mcallester rosenblitt kambhampati b known combinatorially hard variety approaches plan synthesis developed
past twenty years approaches classified two broad categories
domain independent domain dependent domain independent planners make
assumptions domains thus accept solve domain contrast domain specific planners specifically designed
single domain thus dynamics control knowledge domain hard coded
advantage domain independent
designed used domain simply changing action template
input contrast domain specific planners would modified
designed domain ip side domain specific planners tend

c ai access foundation morgan kaufmann publishers rights reserved

fisrivastava kambhampati

theory refinement

domain knowledge


control knowledge
eg planes dont touchdown
without delivering packages

fss
bss
kids

pss
htn
dynamical model
action operator description



customized
planner

plan

figure architectural overview planner synthesis kids clay
theories refinement domain knowledge declaratively specified kids turn combines produce customized planner
domain resulting planner conventional planners handle
domain detailed description see section
ecient designated domains domain independent planners since latter may
able effectively exploit control knowledge every domain
surprisingly significant amount work ai aimed improving performance domain independent planners dynamically customizing
given domain customization done providing domain writer ability
control search planner case task reduction kambhampati
srivastava kambhamapti learning techniques kambhampati
katukam qu minton although several approaches developed
learning improve performance present effective match
eciency domain dependent planners
one intriguing alternative automatically synthesize domain dependent planners
given knowledge domain theory investigate feasibility existing automated software synthesis tools support
synthesis introduce clay architecture supports synthesis domain
dependent planners kids semi automated software synthesis system specifically
shown figure declarative theory plan synthesis theory combined
control knowledge specific given domain semi automated software synthesis system called kestrel interactive development system kids smith


fisynthesizing customized planners specifications

b derive customized planner domain draw declarative theory
plan synthesis domain independent techniques domain specific control
knowledge expressed terms types plans preferred given
domain
strikes promising middle ground domain independent
domain dependent planners theories encoded independent domains
domain control knowledge encoded independent specific
theory used customization step compiles domain control knowledge
ensures resulting planners able exploit structure
domain

overview synthesis

brie mentioned practicality predicated availability
software synthesis system capable deriving code formal specifications kids
powerful semi automated system development correct ecient programs
formal specifications given domain theory input output specification task
kids system helps synthesizing program capable solving task term
theory refers useful body knowledge task refers assignment given
kids solving solution program task input kids task
theory comprised task specification declarative description useful concepts
rules reason task space give task kids
expect synthesize return planner solution planner take
input return plans
order support planner synthesis develop input theory
kids discussed kambhampati b traditional plan synthesis techniques
described terms common plan representation different planners corresponding different ways refining partial plans progression regression
plan space refinements see section consequently theory consist
specification task terms input output data types one
refinement theories since interested domain customized planners
provide necessary domain knowledge kids
given inputs kids semi automatically synthesizes program case domain dependent refinement planner generic design tactics branch
bound global search resulting planner conventional planners handle
domain see section details

outcomes

understand ecacy plan synthesis clay concentrate
synthesis planners state space refinement theories empirical evaluation shows
synthesized planners ecient example blocks world
domain goal stack inversion kids synthesized planner solved blocks
minute logistics domain packages planes
future plan extend plan space task reduction refinements



fisrivastava kambhampati

places solved minute similarly tyre domain russell norvig
fixit solved minute put performance
perspective compared kids synthesized planners set classical planners implemented instantiations ucp system kambhampati srivastava
described later instantiations ucp emulate spectrum classical planners including popular snlp planner mcallester rosenblitt selecting
appropriate refinement experiments best kids synthesized planners
outperformed best ucp instantiations given domain specific information hypothesize kids profitably fold domain specific
control knowledge e domain theory code

organization

rest describes details called clay architecture
planner synthesis organized follows brief review traditional
plan synthesis approaches software synthesis kids section walk
clay framework section section presents discussion nature planners
synthesized section empirically evaluates synthesized planners
compares classical planners section discusses related work section describes
conclusions discusses costs benefits synthesis

background

section brie discuss relevant background software synthesis kids
plan generation needed follow rest

kestrel interactive development system

discussing kids start preliminaries automated software synthesis
holy grail software synthesis
produce highly reliable adaptable software greatly reduced development time
automate detail intensive tasks software production largely non creative
nature
program program segment p correct respect initial condition assertion final condition assertion f whenever true prior execution p p terminates f true execution p complete
formal specification task knowledge base inference system knowledge
software synthesis proceeds iterative specification refinement process specialize
general knowledge program development form theories solve
specific tasks hand refinements sound specification correct
synthesized program code correct
kids program transformation framework development programs
formal specifications task kids runs sun workstations built refine
commercial knowledge programming environment high level language


fisynthesizing customized planners specifications

software specification
input output specification planner

background knowledge
domain dynamics control

design tactics

knowledge distributive laws etc

global search refinement search


un optimized


optimization
simplification finite differencing etc

optimized
optimized planner

compilation

compiled code base language

figure overview software synthesis process kids
refine language supports first order logic set theory pattern matching transformation rules refine provides compiler generates common lisp c code programs
written logical specification language
following describe general steps involved synthesizing software kids
figure provides overview process process illustrated detail
section context synthesis customized planner code
develop task theory state reason task user defines appropriate
functions types describe task gives laws allow high level
reasoning defined functions many theories e g
progression regression written relevant laws specified provided domain theories kids could perform specialized reasoning planners
returned solutions
select apply design tactic select algorithmic framework
used implement task specification kids currently supports variety design tactics including reduction divide conquer global search local
search use global search design tactic formalization


fisrivastava kambhampati

classical driven refinement search seen special case
global search see
apply optimizations make generated ecient first generated
well structured correct return valid solutions
inecient optimized specification reduction
techniques simplification partial evaluation finite differencing
compile produce program base language
domain theories specifications written refine kids synthesizes
optimizes language transform specifications programs well optimize programs kids uses form deductive reasoning called
directed inference reason task specification domain theory
kids system used derive variety programs past particular
interest us work deriving ecient scheduling software smith parra
burstein smith success programs provided initial impetus


theories plan synthesis

mentioned earlier kids derive software clay involves figuring
declarative theories different types classical specified
b algorithmic design templates best suited planner synthesis kambhampati
b provides overview traditional plan synthesis approaches discussed
plan synthesis approaches come many varieties little superficial commonality
last years developed unifying framework subsumes
approaches kambhampati srivastava kambhampati knoblock
yang kambhampati b framework plan synthesis modeled
process searching space sets action sequences sets represented
compactly collections constraints called partial plans search process first
attempts extract action sequence capable solving
partial plan fails refines splits partial plan set partial
plans corresponding sets action sequences subsets action sequence
set corresponding original partial plan considers plans turn
existing domain independent plan synthesis correspond four different ways
refining partial plans known respectively forward state space progression
refinement fss backward state space refinement regression refinement bss plan
space refinement pss task reduction refinement strips fikes nilsson
example planner fss refinement topi barrett weld uses
bss refinement snlp mcallester rosenblitt uses plan space refinement
nonlin tate uses task reduction refinement given background
declarative theory plan generation clay corresponds theories refinements
tactic underlying plan generation corresponds refinement search
kids system supports tactic called global search smith
seen generalization refinement search


fisynthesizing customized planners specifications

specification
encoding
domain knowledge
theory import
direction

planner

level

refinement theory refinements available
progression fss

regression bss

plan space ps

level

domain theory particular domain unique

blocks world
domain
knowlegde

blocks world
progression

logistics domain
knowlegde

level

blocks world
regression
logistics progression

logistics
regression

figure clay architecture writing theory level answers question
relevant level detail clay uses kids feature theory
import modularize domain specific theory

developing planner declarative specification clay
architecture

figure summarizes kids used synthesize domain specific refinement planner domain knowledge consists dynamical model control knowledge
dynamical model specified form actions called operators define legal transformations one state world another control knowledge set
domain specific criteria helps planner decide plan p better p
intended make search ecient example control knowledge logistics domain packages moved destinations airplanes
planes touchdown location packages pickup deliver
refinement domain control knowledge brought together clay
architecture writing declarative domain specific theory summarized figure specify task plan representation selected constraints
satisfied solution plan enumerated planner specification
planner specification dependent plan representation independent
refinement needed search refinement strategy uses planner specification
defines children nodes generated given partial plan goal test
explicates refinement specific search pruning tests refinement


fisrivastava kambhampati

specification together form theory obtain domain dependent planner
one needs import theory provide relevant domain specific
control knowledge provides preference structure among partial plans
competing solutions interesting special case one specifies generic domain
knowledge effect plans equally good domain case
refinement used one gets fss bss pss hybrid multiple refinements
used general purpose planner
level directed tree figure represents abstraction
task root tree level description task required
without specifying refinements strategies used level refinements
specified assumption made domain next characteristics
domain provided level progression fss blocks world planner different
progression logistics domain planner terms domain knowledge
hand progression blocks world planner different regression bss blocks world
planner terms refinement used
stated ensure exibility control knowledge change
different refinements used thereby represent substantial exibility practice
since control knowledge helps prune children nodes produced refinement pruning may
effective control knowledge encoded depending refinement
middle ground implemented domain control knowledge
may represented intermediate form depending partial plan representation
refinement provide addition termination test conversion function
transform control knowledge refinement specific form

representing domain operators

discuss world state represented domain operators define
state transformations classical world modeled terms set state
variables state world corresponds particular assignments values
variables actions described terms specific variable value combinations
needed applicable variable value combinations enforce
execution two variants general modeling become popular
community first called strips representation fikes nilsson
represents world terms ground atoms first order logic action applicability
conditions effects described terms conjunctions ground atoms
second variant backstrom nebel world actions directly terms
multi valued state variables values since strips representation seen
state variable model boolean state variables since multi valued statevariable system converted equivalent boolean state variable system two
representations equivalent expressive power
chose state variable representation implementation since
directly mapped primitive data structures supported kids figure shows
action moving block block b top block c strips statevariable representation blocks world domain environment blocks
placed table top blocks involve stacking


fisynthesizing customized planners specifications

strips representation

action move b c
prec clear clear c b
post c clear b clear c
b

muti valued state variable representation

action move b c
pre hb true false truei
post hc true true falsei

state tuple
h pos clr pos b clr b pos c clr c
zeroes represent care values

figure different representations move b c
desired configuration purpose exposition showing values state
variables corresponding block positions e g pos symbols b c etc clear
conditions e g clr true false practice map valid values state
variables integers

specification planner

kids uses functional specification programming language augmented set theoretic
data types specification task smith represented quadruple
f hd r oi input type satisfying input condition boolean
output type r output condition r boolean defines feasible solution x z holds z feasible solution respect input x specification
program follows template
function f x set r
x
returns f z j x z g
body x
specification program f consistent possible inputs satisfying input
condition body produces feasible solution e x z r x x z
within view planner takes inputs initial state goal state operator
list operators assumed define state transitions valid states valid states
specification task given initial state goal state
operator list return sequence operators plan



termination test goals must hold final state resulting execu

tion plan considering goal
make state variables achieve specified values e goals achievement
domain independent pruning test plan passes domain independent
pruning tests refinemen specify conditions partialplan cannot lead desirable solution partial plan satisfying pruning


fisrivastava kambhampati

function planner
init seq integer goal seq integer
opers seq tuple seq integer seq integer
returns
plan seq integer
range plan subset size opers
goodness test visited states
plan init goal opers
init goal
moves back visited states
plan init goal opers
init goal
goal test visited states
plan init goal opers
init goal

figure declarative specification
test eliminated consideration example state loop pruning heuristic forward state space refinement says partial plan
plan state executing operator subset state following
earlier operator partial plan pruned
domain dependent pruning test plan passes additional domain specific
pruning tests
last one hook domain specific control knowledge introduced
current implementation clay use domain knowledge rejecting undesirable
partial plans section discuss ways implementation extended
support uses domain control knowledge
specification task declarative states constraints must satisfied resulting plan produced planner given
suggest used obtain algorithmic decisions made program development phase kids
example top level specification task refine shown figure
specification input condition true input data type includes init
goal opers output data type r plan output condition consists
goodness test goal test moves back moves back domain independent
pruning tests whereas goodness test domain dependent pruning test
delving deeper representation detail represent plan sequence indices
operator list e sequence operator identifiers state space
state sequence corresponding partial plan produced function visited states
goal test domain independent pruning tests domain dependent pruning tests
done state sequence functions goal test moves back goodnesstest respectively state variables take integer values consequently initial
goal states sequence integers
words specification figure says partial plan sequence integral
indices operators indices must size operator list valid


fisynthesizing customized planners specifications

plan one whose corresponding state sequence produced visited states satisfies
goal test moves back goodness test
context forward state space refinement fss visited states returns
states obtained successive application operators partial plan
initial state resulting states thereafter goal test signals goal
achieved fss refinement involves checking last state state sequence
goal state moves back function tests state looping forward state space
looping checks state executing operator oj state sj subset state
following earlier operator oi j state si partial plan pruned
function goodness test checks possible redundancy state sequence
corresponding current partial plan domain characteristics let us explain
context blocks world domain specify reasonable checks
blocks world long make planner lose desired solution
present two goodness tests

heuristic h limit useless moves block moves states

must change position states motivation behind
check prevent blocks moved around randomly successive moves
heuristic h move via table block move initial state
table table goal position motivated fact
polynomial time approximate solving blocks world involves putting blocks table first constructing goal
configuration stacks bottom

implementing specification global search

discussed section need select design tactic implement task
specification kids one design tactics provided kids global search basic
idea global search represent manipulate sets candidate solutions principal
operations extract candidate solutions set split set subsets
derived operations include filters used eliminate sets containing
feasible optimal solutions global search work follows starting
initial set potential solutions contains desired solutions given
instance repeatedly extracts solutions splits sets eliminates sets via
filters candidate solution drawn one sets sets solutions
represented implicitly data structures called descriptors splitting done adding
refine code referenced functions shown appendix
actually test slightly general condition state executing operator oj state
sj weaker state following earlier operator oi state si partial plan
pruned sj weaker si every state variable assigned value state si assigned
value state sj specifying weakness rather subset relationship states decide
domain independent pruning state space allow synthesized planner deal
partially specified initial state planner work correctly long state variables
required reasoning specified initial state
pruning test alone guarantee polynomial since order blocks
put table later goal positions specified pruning heuristic



fisrivastava kambhampati

mutually exclusive exhaustive sets constraints descriptors process
described tree search node represents set candidates arc
represents split relationship set subset complete details readers
referred smith
kids global search paradigm general form refinement search model
used unify classical planners ucp kambhampati srivastava specifically
partial plans correspond descriptors refinements correspond splitting
strategies use global search implement planner specification need select
suitable representation sets potential solutions refinement view
essentially partial plans global search tactic would set
search split solution set extract solutions meet
specification kids provides global search tactics primitive data types sequences
sets maps complex data type needed represent potential solution set
task user must implement global search tactic
since interested state space planners initially chose represent partial
plan sequence operators actually sequence operator indices allowed us
use kids global search theory finite sequences

specifying distributive monotonic laws

one aspect kids specification slightly unintuitive users need
specify distributive monotonic laws operations used input output
specification e g moves back specification progression planner shown
figure distributive laws state specific operation distributes operations
e g b c c b c monotonic laws provide set boundary
conditions e g laws explicitly stated operations involved
specification support instantiation design tactics well optimization
generated code specifically kids directed inference engine called rainbow
uses task specification distributed laws specified user simplify
reformulate expressions synthesized code deductive inference primary
means kids reasons task specification order apply design tactics
optimize code derive necessary pruning conditions distributive monotonic
laws indirectly provide kids information alternative ways defining predicates
useful heuristic writing laws simple normally expressed
terms main function perhaps another function handle boundary cases called
cross functions see example consider figure function movesback domain independent pruning test used specification progression planners
recall moves back called state sequence checks later state
subset weaker earlier state calling moves back sequence
concatenation state sequences equivalent calling
testing state weaker state notice first two
tests handled moves back last test needs function
call function cross function moves back cross moves back
monotonic laws moves back include



moves back singleton state sequence true



fisynthesizing customized planners specifications



moves back empty state sequence false useful selected action

applicable

similarly distributive laws moves back include



moves back sequence concatenation equal moves back nomoves back cross moves back

state prepended state sequence applying moves back

combined state sequence equivalent applying cross moves back
singleton sequence moves back
state appended state sequence moves back
combined state sequence moves back cross movesback singleton sequence

rules reasonably obvious us nonetheless crucial
effectiveness kids help reformulating optimizing generated code
example use see section occurs figure
condition else statement gets simplified part
conditions condition proved true context input
specification given distributive laws
task specification selected design tactic global search distributive
laws kids produces correct naive code shown figure code naive
checks example cross moves back figure computed
repeatedly even true context discuss methods optimize
code next section

program optimization

section explains initial planner code generated kids optimized readers
familiar automated software synthesis literature might want skip section
first read revisit later details
first code produced kids shown figure well structured inecient several opportunities optimization kids provides tools program
optimization code compiled executed stage optimization
brie summarize program optimizations used achieve eciency
context independent simplifier

method simplifies expression independent surrounding context
two possibilities context independent simplification
first case set equations treated left right rewrite rules
fired exhaustively none apply distributive laws treated rewrite rules
example application rewrite rule
true p else q p


fisrivastava kambhampati

function planner
init seq integer goal seq integer
opers seq tuple seq integer seq integer
returns
plan seq integer
range plan subset size opers
goodness test
visited states plan init goal opers
init goal
moves back
visited states plan init goal opers
init goal
goal test
visited states plan init goal opers
init goal
moves back
visited states init goal opers
init goal
goodness test
visited states init goal opers
init goal
planner aux init goal opers
else undefined

function planner aux
init seq integer goal seq integer
opers seq tuple seq integer seq integer
v seq integer
range v subset size opers
goodness test
visited states v init goal opers
init goal
moves back
visited states v init goal opers
init goal
seq integer
ex plan seq integer
goal test
visited states plan init goal opers
init goal
moves back
visited states plan init goal opers
init goal
goodness test
visited states plan init goal opers
init goal
range plan subset size opers
plan v
plan seq integer
goal test
visited states plan init goal opers
init goal
moves back
visited states plan init goal opers
init goal
goodness test
visited states plan init goal opers
init goal
range plan subset size opers
plan v
else plan seq integer
ex v seq integer
plan
planner aux init goal opers v
defined plan
goodness test
visited states v init goal opers
init goal
moves back
visited states v init goal opers
init goal
ex integer
v append v
size opers

figure first progression blocks world planner code synthesized kids notice
code inecient checks example cross moves back
computed repeatedly even true context



fisynthesizing customized planners specifications

function planner
init seq integer goal seq integer
opers seq tuple seq integer seq integer
returns
plan seq integer
range plan subset size opers

moves back
visited states init goal opers
init goal
goodness test
visited states init goal opers
init goal
planner aux
init goal opers init init
size opers
else undefined

function planner
init seq integer goal seq integer
opers seq tuple seq integer seq integer
returns
plan seq integer
range plan subset size opers

planner aux
init goal opers init init
size opers

figure example context independent simplification kids code right
size simplified version left
function planner aux
init seq integer goal seq integer
opers seq tuple seq integer seq integer
v seq integer
range v subset size opers
goodness test visited states
v init goal opers
init goal
moves back visited states
v init goal opers
init goal
seq integer
goal test
visited states v init goal opers
init goal
moves back visited states
v init goal opers
init goal
goodness test visited states
v init goal opers
init goal
range v subset size opers


function planner aux
init seq integer goal seq integer
opers seq tuple seq integer seq integer
v seq integer
range v subset size opers
goodness test visited states
v init goal opers
init goal
moves back visited states
v init goal opers
init goal
seq integer
goal test
visited states v init goal opers
init goal


figure example context dependent simplification kids code right size
simplified version left

second case occurrences local variable defined equality

replaced equivalent value
fc x j x e p x g fc e j p e g
figure shows example context independent simplification conditions
condition true respective distributive laws hence else
statement replaced part


fisrivastava kambhampati

function planner aux
init seq integer goal seq integer
opers seq tuple seq integer seq integer
v seq integer vs seq seq integer
l vs seq integer
seqequal l vs last vs
range v subset size opers

goal test vs init goal v
else plan seq integer
exists integer
size opers


function planner aux
init seq integer goal seq integer
opers seq tuple seq integer seq integer
v seq integer vs seq seq integer
l vs seq integer num ops integer

num ops size opers

goal test vs init goal v
else plan seq integer
exists integer
num ops


figure example finite differencing size opers code right size
finite differencing left
focus initialize planner
tactic global search planner
simplify context independent fast
else plan
simplify context dependent forward backward

simplify context dependent forward backward
else und
fd general purpose vs
visited states v init goal opers
fd general purpose l vs last vs
fd general purpose num ops size opers
abstract next state l vs opers ns
ex integer
simplify context independent fast
planner aux
refine compile lisp planner aux planner

figure derivation steps generate progression planner blocks world domain
context dependent simplifier

method designed simplify given expression respect surrounding context thus powerful context independent simplification predicates
hold context expression gathered walking abstract syntax
tree expression simplified respect set assumptions hold
context figure function calls moves back goodness test
range test expression redundant follow input
invariant conditions listed j planner aux function
removed simplification



fisynthesizing customized planners specifications

function planner
init seq integer goal seq integer
opers seq tuple seq integer seq integer
returns
plan seq integer
range plan subset size opers
goodness test
visited states plan init goal opers
init goal
moves back
visited states plan init goal opers
init goal
goal test
visited states plan init goal opers
init goal
planner aux
init goal opers init
size opers init

function planner aux
init seq integer goal seq integer
opers seq tuple seq integer seq integer
v seq integer vs seq seq integer
num ops integer l vs seq integer
seqequal l vs last vs
seqequal vs
visited states v init goal opers
moves back
visited states v init goal opers
init goal
goodness test
visited states v init goal opers
init goal
range v subset size opers
num ops size opers
seq integer
goal test vs init goal v
else plan seq integer
ex ns seq integer integer
ns next state l vs opers
cross moves back vs ns init goal
cross goodness test vs ns init goal
defined plan
plan
planner aux
init goal opers append v
append vs ns num ops ns
num ops

figure final progression blocks world planner code synthesized kids
finite differencing

idea behind finite differencing perform computations incrementally rather
repeat scratch every time let us assume inside function f x
expression g x x changes regular way case might useful
create variable equal g x whose value maintained across iterations
allows incremental computation g x next x value finite differencing
decomposed two basic operations abstraction simplification smith

first function f abstracted respect expression g x adding
parameter c parameter list f f x c adding c g x input
invariant f calls f whether recursive calls within f external calls must
changed match definition f e f x changed f x g x
process occurrences g x replaced c
distributive laws apply g h x yielding expression form h g x
h c value g h x computed terms old value g x
real benefit optimization

let us illustrate process example suppose function f x
call function g x returns square numbers variable x varies linearly
suppose given distributive law g x g x x
finite differencing f becomes f x c g x call replaced c x


fisrivastava kambhampati

additional invariant c x x maintained f expression
computationally much cheaper original expression
figure finite differencing performed size opers argument function
planner expanded inclusion num ops name entered user
value size opers abstraction done number operators
available planner change note num ops represents
number operators meaningful concept
instances size opers replaced num ops
program derivation

figure shows summary sequence derivation steps carried obtain
blocks world domain specific forward state space planner final version planner
code shown figure
step top level planner specification selected step selected design
tactic applied step involves context independent simplification steps
involve context dependent simplifications steps cover finite differencing
finally ecient planner code compiled step

discussion synthesized planners

section used synthesis progression planner blocks world domain case
study walk planner synthesis process leading final planner given
figure considered regression backward state space
planners planners synthesized date summarized table although
planners differ terms refinements use domains
customized figure attempts pseudo code description generic template
facilitate discussion synthesized planners group
main function planner takes initial state goal state operator set
inputs turn calls recursive function planner aux inputs
initial plan pruning tests comprising output conditions maintained
invariants must hold final plan every partial
plan leading final plan goal test course need hold final plan
thus maintained invariant finite differencing leads invariants
inside planner aux partial plan satisfies goal test returned otherwise
partial plan refined invariants incrementally tested partial plan
planner aux called recursively
first thing note pseudo code template describes planner
domain employing state space refinement even requirement synthesized
planner state space dictated partial plan partial plan obtained
case appending operator operator sequence generalized
support refinements modifying operation current case append
used build partial plan old one corresponding changes
distributive laws account operation
second observe invariants incrementally evaluated see planner aux
example see plan ith iteration satisfies moves back test


fisynthesizing customized planners specifications

check latest state duplicated previous states hypothesize
incremental evaluation primary reason synthesized planner eciency
refinement domain knowledge available context dependent simplification
may many tests made separate theories fact redundant
moreover incremental evaluations may cheaper complete evaluations invariants
amenable operations distribution monotonicity abstract
data types
although domain independent planners given control knowledge
give kids planner synthesis expected superior two
ways
separates control knowledge acquisition specifics
planner extent makes acquisition process easier contrast
controlling search domain independent planner requires user think
terms specific choice points planner search strategy
importantly search control domain independent planners typically involves
generating unpromising partial plans first pruning contrast improves eciency folding control knowledge synthesized
planner code incremental evaluation pruning test specifically first
approximation conventional domain independent planners add goodnesstest control search choice points post process generated partial plans specify distributive laws goodness test
incrementally evaluated terms cross goodness test goodness test
perform context dependent analysis pieces available knowledge
optimize code mean folding control knowledge
figure see instance control knowledge folded synthesized progression planner blocks world domain contrast first synthesized
planner shown figure notice redundant invocation checks
goodness test visited states etc earlier planner simplified away
moreover individual checks moves back goodness test
simplified distributive laws cross moves back crossgoodness test consider newly added parts partial plan
considerations lead small ecient final planner

empirical evaluation synthesized planners

table lists several domain dependent state space planners synthesized
date planners characterized domain developed bw
blocks world log logistics tyr tyre world benchmark
domains ai type state space refinement used p progression
r regression type domain specific control knowledge used h
limits useless moves h moves blocks via table etc report
empirical study conducted synthesized planners study two aims
ascertain whether synthesized planners able eciently exploit domain
knowledge


fisrivastava kambhampati

main function planner calls auxiliary function
function planner initial state goal state operator set
returns plan
output conditions satisfied

planner aux initial state goal state operator set
initial plan
note parameters added finite differencing
function planner aux called planner planner aux
note set output conditions given part

specification kids selects one

maintained invariants finite differencing

gives invariants
function planner aux initial state goal state operator set
current plan
invariants satisfied state sequence
corresponding current plan
return type plan

state sequence ensures satisfaction goal state
current plan executed initial state
return current plan
else consider partial plan append current plan
index valid operator operator set
incremental test invariants true
state sequence corresponding partial plan
b partial plan
planner aux initial state goal state operator set
partial plan

figure pseudo code state space planners synthesized kids

ascertain synthesized planners better traditional domain indepen

dent planners utilizing domain control knowledge
discussion organized follows section describe domains
considered empirical work section evaluate absolute
performance synthesized planners domains section compare
performance synthesized planners traditional planners

domains
blocks world domain

blocks world domain environment block placed table
top blocks involve stacking desired configuration
let us focus two states particular top n top
n blocks top stands state block top block b block b


fisynthesizing customized planners specifications

name
bw p h
bw p h
bw r h
bw r h
log p l
log r l
tyr p
indep p
indep r

customized
domain
blocks world
blocks world
blocks world
blocks world
logistics
logistics
tyre world
none none

refinement

domain dependent pruning test

progression fss
progression fss
regression bss
regression bss
progression fss
regression bss
progression fss
progression fss
regression bss

limit useless moves h
move via table h
limit useless moves h
move via table h
limit ineciency
limit ineciency
multiple control rules
true every state ok
true every state ok

table table showing variety planners synthesized kids names
planners follow format domain refinement heuristic
top block c block n top block n block n table similarly
n top stands state block table block b top block
block n top block n reported experiments one three
types
stack inversion invert top n top
stack building initial state collection random stacks two blocks height
last n blocks put first n blocks table
goal state top n top
random blocks world subset random blocks world generated minton minton n blocks goal
state n goal conditions
domain dependent pruning tests blocks world covered section specifically covered pruning test h prevents block moved consecutive
steps test h requires blocks moved via table
logistics domain

logistics domain consists several planes packages different places goals
involve transporting planes packages specified locations considered
type logistics domain k planes k places k packages
packages package plane place goal get planes
packages distinguished place
domain dependent pruning test logistics transportation domain
call limit ineciency heuristic consists following pieces advice


fisrivastava kambhampati

planes make consecutive ights without loading unloading package
packages goal position begin may loaded inside
plane goal position
package reaches goal position moved
tyre world domain

tyre world russell norvig benchmark domain complex causal
structure blum furst fixit domain car tyre
must replaced spare tyre must first ated original
tyre placed boot tools must returned boot domain
dependent pruning test devised enforces following constraints
one state variable changes one state next state
change subsequent state state variable describes attribute object domain attribute value
state overwritten state might indicate non minimal
plan
work status boot last
fixing free hub invalid wheel must first
jacked car needs tyre jack without putting
tyre
work position pump wrench wheels hub
final configuration
wheels goal positions moved

absolute performance synthesized planners

section discuss absolute performance synthesized planners different
domains shall see synthesized planners able solve benchmark
known hard traditional planners special note order
regarding plots follow plots follow curve stops mid way
graph means corresponding planner could solve given
class applicable stipulated time
planners blocks world

traditional planners domain specific information helps planner return faster
obtained similar synthesized planners seen left
true domains since domains way state variable shift value
v v transition v heuristic however preserve completeness tyre
world



fisynthesizing customized planners specifications

synthesized progression planners block world

synthesized progression planner logistics

effectiveness domain pruning tests

effectiveness domain base pruning tests





bw p h
indep p

log p l
indep p




log time secs

log time secs




















blocks





planes x places x packages



figure plots domain dependent goodness tests lead ecient planners
domains blocks world left logistics transportation domain
right planners domain guidance perform better without
plot figure domain specific blocks world heuristic h limit useless moves
helped progression planner bw p h solve stack inversion invert aon top n top blocks minute blocks
minutes without heuristic progression planner indep p could solve even
block stack inversion time
planners logistics domain

logistics domain progression planner limit ineciency heuristic logp l could solve plane minute plane minutes
figure right without heuristic progression planner indep p could
solve even plane time
planners tyre world

operators state variables control rules manually encoded tyre
world russell norvig description fixit solved minute
step plan returned

comparing traditional synthesized planners blocks world

since synthesized planners used domain specific control knowledge normally
used domain independent planners next step involved comparing synthesized planners domain independent planners control knowledge aim see
synthesized planners better able exploit domain knowledge traditional planners restricted detailed comparison blocks world domain since


fisrivastava kambhampati

variety traditional classical planners varying tradeoffs
c f barrett weld kambhampati et al used league tournament
comparison specifically since popular classical planners correspond
different instantiations ucp kambhampati srivastava first ran
blocks world distribution isolate best traditional planners similar
study done isolate best synthesized planners distribution
point best synthesized planner compared best traditional planner
second round comparison winning traditional planner given control
knowledge synthesized planner
used two three blocks world test suites random blocks world
stack building comparisons class
defined terms number blocks average runs shown plot
total time allowed class seconds planner
deemed failed class planners run
suite
picking best synthesized planner

section want empirically determine effective refinement
control knowledge heuristics blocks world suites ran six synthesized
planners bw p h bw p h indep p bw r h bw r h indep r
test suite figure shows relative performance notice planners
pruning test h perform best compared planners
refinement
picking best traditional planner

section empirically search best ucp strategy blocks world figure shows performance ucp instantiations domain dependent heuristic
information instantiations ucp fss bss ps refinements emulate
classical forward state space backward state space plan space planners respectively
call instantiations ucp fss ucp bss ucp ps ucp lcfr hybrid strategy
interleaves fss bss ps refinements depending lower branching factor
kambhampati srivastava random blocks world left
stacking building right left right plots ucp fss solves
notice progression planners perform better left plot regression planners perform
better right plot trend explained easily terms way refinements operate
kambhampati b left figure nature goals branching factor
regression planners may become enormous cannot detect con icts among
steps give conditions goal steps eventually support goal condition many
operators seem potentially give condition actually case hand
completely specified initial state helps progression planner decide applicable operators
beginning consequently progression planner bw p h clear win right plot
initial goal states completely specified regression progression planners detect
con icts true realistic domains many operators applicable initial state
relevant achieving goal conditions regression planner bw r h performs better
progression planner bw p h



fisynthesizing customized planners specifications

performance synthesized planners

performance synthesized planners

random blocks world

build stack achieve top





bw p h
bw p h
indep p
bw r h
bw r h
indep r



log time secs

log time secs










bw p h
bw p h
indep p
bw r h
bw r h
indep r








blocks











blocks





figure performance synthesized progression regression planners h
h domain dependent control knowledge bw p h perform best
left plot bw r h performs best right plot points close
together clear bw r h indep r solve upto
blocks left plot
performance ucp instantiations

performance ucp instantiations

mintons random blocks world

go random stacks upto two blocks height top





ucp ps
ucp fss
ucp bss
ucp lcfr

ucp ps
ucp fss
ucp bss
ucp lcfr


log time secs

log time secs

















blocks











blocks





figure performance ucp instantiations domain dependent heuristic
left right plots ucp fss solves least time
see ucp fss good strategy blocks world note
figure ucp bss solves blocks given time
plots


fisrivastava kambhampati

comparison ucp fss synthesized planners

comparison ucp fss synthsized planners

random blocks world

build stack achieve top




bw p h
ucp fss h

bw r h
ucp fss h



log time secs

log time secs

















blocks











blocks





figure best ucp strategy blocks world namely ucp fss performs
best kids synthesized planners left plot ucp fss better
indep p e without heuristic information h heuristic
given planners bw p h winner right plot bw r h
outperforms ucp fss h
least time see ucp fss good strategy
blocks world distributions used
comparing best synthesized planner best traditional
planner

finally pit best ucp strategy blocks world namely ucp fss
best kids synthesized planners chose bw p h random blocks world
suite bw r h stack building suite comparison done
planners given heuristic information h domain dependent
guidance figure plots left plot bw p h clear winner
planners given domain specific heuristic h right plot bw r h
outperforms ucp fss h see given heuristic information
best planners synthesized kids outperform best instantiation ucp
blocks world
interesting note synthesized planners improve drastically
domain specific knowledge domain independent planners improve
way illustrate figure compare ucp instantiations
synthesized planers without control heuristics synthesized planners
note case synthesized planners planner regression outperformed one
progression stack building contrast ucp fss performs ucp bss
suite reason particular implementation ucp bss
involves costly unification step



fisynthesizing customized planners specifications

comparison ucp fss synthesized planners comparison ucp fss synthesized planners
random blocks world

build stack achieve top




bw p h
ucp fss h
indep p
ucp fss dom indep

bw r h
ucp fss h
indep r
ucp fss dom indep


log time secs

log time secs

















blocks











blocks





figure effect control knowledge ucp planners vs kids synthesized planners
improve addition control knowledge true ucp
instantiations specifically right plot see ucp fss h uses control
knowledge h worse ucp fss dom indep use control
knowledge speculate ucp fss explicitly calls function
domain specific reasoning recursive invocation synthesized planners
domain control knowledge folded planner code see section

summary

summary demonstrated

clay writing domain specific theory exible sup

ports mix match refinements control knowledge generating variety
customized planners examples presented planners blocks world logistics
domain tyre domain forward backward state space refinements
different types domain specific control knowledge
synthesized planners exploit domain dependent control knowledge improve performance showed fact better able exploit domain
knowledge traditional planners

related work

reported straddles two fields automated software synthesis
ai although first address issue planner synthesis
synthesis types search engines addressed smith co workers
particular interest us work developing automated scheduling software
transportation logistics kids system smith parra burstein
smith scheduling systems generated shown significantly


fisrivastava kambhampati

outperform general purpose schedulers working provided
initial impetus although original work used design tactic
global search model scheduling since developed design
tactics local search regimes another interesting issue brought
work importance constraint propagation techniques deriving ecient code
made us explore role lack thereof constraint propagation
kambhampati yang describe ways refinement framework
extended exploit constraint satisfaction techniques future hope able
synthesize planners general theory refinement
although much work automated planner synthesis notable exception work gomes gomes synthesized state space solver
missionaries cannibals kids shown synthesized
code outperforms general purpose solvers domain framework
seen generalization work done gomes particular separate
theories dynamics control knowledge principle supports generation code variety refinements demonstrated
deriving progression regression planners three different domains blocks world
logistics tyre world two different bodies control knowledge case
methodologically work adds gomes shown given
control knowledge planners generated kids outperform traditional planners
control knowledge choice points makes fairer comparison
synthesized general purpose planners
existing planners ucpop penberthy weld prodigy
fink veloso customization supported allowing user specify search
control rules checked every choice point search control rules
used rank search nodes heuristic prune unpromising nodes
main difference approaches synthesis described
supports higher degree integration domain knowledge planner
folding synthesized code planner planners search control rules
cannot context dependent analysis incremental application control knowledge
contrast control information encoded declaratively
optimized knowledge available including
control knowledge
work utilizing explicit control knowledge addition domain dynamics
deriving code parallels recent work bacchus kabanza
concentrate providing rich language control knowledge
specified progression planner describe language temporal logic
specify domain control rules rather knowledge prune bad plans
generated bacchus kabanza explore ways incrementally tracking level
satisfaction control axioms progresses facilitates
refinement independent setting folding control knowledge
developed code help kids framework
work constraint satisfaction community directed towards producing specialized customized programs relevant described
coastool yoshikawa kaneko nomura watanabe alice systems lau

fisynthesizing customized planners specifications

riere take declarative description csps compile specialized solving multi tac minton supports automatic configuration constraint
satisfaction programs multi tac system particular provides interesting contrast multi tac starts schema list high level
heuristic rules decision points e g constrained variable first heuristic
variable selection least constraining value first value selection csp search
list ags indicating whether certain procedures e g forward checking csp
used multi tac uses domain specification specialize high level
heuristics given example context minimum maximal matching
graph theory constrained variable first heuristic may become choose edge
neighbors assigned values configuration particular
subset specialized heuristics used particular assignment ags multitac first searches space configurations see configuration best fits
given population best configuration found automatically
compiled ecient code specification refinement techniques similar
described section
multi tac thus presents interesting middle ground search control rule
specification used ucpop prodigy planners full integration
domain knowledge synthesized code promised clay contrast
ucpop prodigy search control rule multi tac compilation
phase support folding search control rules compiled code contrast
clay advocates semi automatic synthesis piece software manually
guided optimization help user specified distributive monotonicity laws
multi tac supports fully automating customization configurable template
clay effective need provide declarative specification
task domain control knowledge well high level tactics kids
deals instantiating tactics specific simplification needs
guided careful specification distributive monotonicity laws contrast multitac configuration needs template already semi customized
specific task built hooks heuristics heuristics
specified form meta heuristic knowledge
multi tac domain knowledge used specializing meta heuristics
theory clay may support deeper integration domain knowledge
synthesized code expense significant amount user intervention
interesting application multi tac context might involve
starting ucp shell configured emulate many varieties
planners list high level heuristics guiding decision points ucp shell
e g refinement selection aw selection etc searching among configurations
pick planner given distribution

conclusion

investigated feasibility automated software synthesis tools
synthesize customized domain specific planners described clay architecture
exibly synthesizing ecient domain dependent classical planners declarative


fisrivastava kambhampati

theory domain theory software synthesis system kids
framework classical planner synthesized enriched domain control
knowledge proof concept forward state space backward state space planners
synthesized blocks world logistics tyre world domains
shown synthesized planners outperform general purpose planners
amount domain specific control knowledge argueed
due ability fold domain specific control knowledge planner code
contrast domain independent planners test control knowledge plan
refined thus suffer significant application overhead

features limitations

synthesis provides several interesting contrasts main stream ai
work begin ai work attempts improve eciency
concentrating way plans generated work differs radically
concentrate ecient planners synthesized use software synthesis techniques lends modularity planner synthesis activity theory specified
declaratively rather form implemented program supports changes
extensions theory theory described independent
domains control knowledge dynamical knowledge domain specified
domain selecting different combinations theory control
knowledge synthesize variety domain customized refinement planners
despite promises entail several overheads
overheads related current state art automated software synthesis
others related current implementation clay architecture follows
try tease apart
holy grail automated software synthesis approaches free users lowlevel coding allow concentrate declarative specification kids
system comes closest promise still far perfect start user must
reasonably familiar software synthesis process order anything substantial
kids go steep learning curve could understand
structure theories make good use optimizations provided kids writing
monotonic distributive laws operations help kids effective
code simplification still somewhat art many times go back rewrite
domain knowledge kids unsuccessful knowledge provided
advances software synthesis technology may provide support automatic translation
high level control knowledge forms suitable consumption kids
support available right
current cost benefit ratios would recommend clay kids
customizing planner one interested customizing single planner
single domain refine code user writes specify synthesis task typically larger one single synthesized planner generated kids thus manually
customizing planner domain may still appropriate however synthesized approaches may competitive interested able customize
variety planners variety domains


fisynthesizing customized planners specifications

addition overheads entailed kids specific implementation
theories domain knowledge etc lead ineciencies latter
eliminated better design clay architecture example make work
simple decided go one pre existing canned design tactics provided
kids chose global search theory finite sequences candidate tactic
choice found state variable representation domains suitable
implementation point view although getting state variable representations
actions hard wrote couple utility routines converting actions
strips representation state variable representation specifying control knowledge
terms representation turned less natural especially larger domains
russel tyre world
choice built design tactics limited types domain knowledge could
specify control knowledge form node rejection rules general
global search allows node preference knowledge well knowledge regarding effective
ways shrinking set potential solutions without splitting set eliminating
non solutions
could eliminate awkwardness state variable representations well exploit types domain knowledge designing global search tactics specially suited
specific data structures although eventually kids system may support
larger variety design tactics customizing design tactics task classes much
line current practice automated software synthesis gomes smith westfold


future directions

work presented seen beginning fairly open ended program complements rather competes ecient
ideally would support synthesis customized planners
full gamut technologies including partial order task reduction latter already subsumed refinement framework developed
kambhampati srivastava supporting synthesis mainly matter
supporting exible partial plan representation kids representing plans
sequences actions suced addressing synthesis
state space planners currently process srivastava kambhampati mali
generally time get insights internal workings family would translate insights declarative specifications
kids support synthesis ecient customized domain code example
recent plan synthesis approaches constraint satisfaction fact
domain independent planners graphplan blum furst solve test
suites equal better time compared synthesized planners taken
preliminary steps towards integrating approaches refinement framework notion disjunctive refinement see kambhampati yang
kambhampati b kambhampati parker lambrecht kambhampati


fisrivastava kambhampati

future work matures intend explore synthesis planners
theories disjunctive plan refinement

acknowledgements

grateful doug smith help kids numerous discussions tactics
global search distributive laws would thank carla gomes discussing
work us making useful suggestions write theories nort fowler
encouragement line thanks due steve minton
anonymous referees jair many helpful comments toward improving
presentation supported darpa initiative
phase grant f c subcontract kestrel arizona state
university

appendix sample code referred text
get state sequence partial plan
function visited states
plan seq integer seq integer
gs seq integer
opers seq tuple seq integer seq integer
seq seq integer
empty plan
else
empty next state first plan opers
prepend visited states rest plan
next state first plan opers
gs opers
used visited states get next state
applying operator
function next state
state seq integer oper integer
operators seq tuple seq integer seq integer
seq integer
fa integer size state
operators oper
operators oper state
image lambda x
operators oper x state x
else operators oper x
size state

domain independent pruning test fss refinement
function moves back vis states seq seq integer
seq integer gs seq integer
boolean
fa integer j integer
size vis states
j size vis states
j
fa index integer
index size first vis states
vis states j index
vis states index
vis states index



fisynthesizing customized planners specifications

function cross moves back
r seq seq integer seq seq integer seq integer
gs seq integer boolean
fa integer j integer
size r j size
fa index integer
index size first r
j index r index
r index
domain independent goal test fss refinement
function goal test
vis states seq seq integer init seq integer
goal seq integer boolean
fa integer
size goal
goal
last vis states goal

domain dependent pruning test
heuristic h limit useless move blocks world
function redundancy seq seq integer
boolean
fa integer index integer
size
index size first
index mod
index index
index index
domain dependent pruning test
heuristic h move via table blocks world
function redundancy seq seq integer
init seq integer
goal seq integer
boolean
fa integer index integer
size
index size first
index mod
index index
position state
initial state
index init index

index
position state table
real nearest integer
size first

index
position state table
real nearest integer
size first

position state
goal state
index goal index



fisrivastava kambhampati

references

bacchus f kabanza f temporal logic control search forward
chaining planner directions ai ewsp ios press
backstrom c nebel b complexity sas report
dept comp info sc linkoping univ sweden
barrett weld partial order evaluating possible eciency gains
artificial intelligence
blum furst fast graph analysis proc ijcai
burstein smith itas portable interactive transportation scheduling
tool search engine generated formal specifications proceedings rd
ai systems conference pp
fikes r nilsson n strips application theorem
proving solving readings morgan kaufmann publ san
mateo ca
fink e veloso formalizing prodigy cmu cs tech
report cmu cs
gomes c smith westfold synthesis schedulers planned shutdowns power plants proc th knowledge software engg conf ieee
computer society press los alamitos ca
gomes c p kids technical report rl tr rome laboratory
kambhamapti comparative analysis partial order htn
acm sigart bulletin
kambhampati challenges bridging plan sythesis paradigms proc intl
joint conference artificial intelligence ijcai morgan kaufmann
kambhampati b refinement unifying framework plan synthesis
ai magazine
kambhampati katukam qu failure driven dynamic search control
partial order planners explanation artificial intelligence

kambhampati knoblock c yang q refinement search
unified framework evaluating design tradeoffs partial order artificial
intelligence special issue scheduling
kambhampati parker e lambrecht e understanding extending
graphplan proc th european conference springer verlag


fisynthesizing customized planners specifications

kambhampati srivastava b universal classical
unifying state space plan space approaches directions ai
ewsp ios press
kambhampati srivastava b unifying classical approaches
tech rep asu cse tr arizona state university available
http rakaposhi eas asu edu yochan html
kambhampati yang x role utility disjunctive representation
refinement proc fifth conf principles knowledge representation
reasoning kr pp
lauriere j l language program stating solving combinatorial
artificial intelligence
mcallester rosenblitt systematic nonlinear proc th ncai

minton learning effective search control knowledge explanation
phd thesis carnegie mellon university pittsburgh pa
minton automatically configuring constraint satisfaction case study
constraints
minton quantitative concerning utility explanation learning
artificial intelligence vol pp
penberthy j weld ucpop sound complete partial order planner
adl proc aaai
russell norvig p artificial intelligence modern chap
prentice hall englewood cliffs nj
smith r kids semi automatic program development system ieee trans
software engineering special issue formal methods sep
smith r structure design global search kestrel tech rep
kes u
smith r b transformational scheduling kestrel institute tech
rep kes u pp
smith parra e transformational transportation scheduling
proceedings th knowledge software engineering conference pp
chicago il sept
srivastava b kambhampati mali structured synthesizing
planners specifications proc th ieee intl conf automated software
engg lake tahoe nv
tate generating project networks proc th ijcai


fisrivastava kambhampati

yoshikawa kaneko k nomura watanabe constraint
high school timetabling case study proc ncai





