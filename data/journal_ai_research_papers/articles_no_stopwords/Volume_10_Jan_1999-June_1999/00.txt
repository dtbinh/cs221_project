Journal Artificial Intelligence Research 10 (1999) 1-38

Submitted 4/98; published 1/99

Order Magnitude Comparisons Distance
Ernest Davis

davise@cs.nyu.edu

Courant Institute
New York, NY 10012 USA

Abstract
Order magnitude reasoning | reasoning rough comparisons sizes quantities | often called \back envelope calculation", implication
calculations quick though approximate. paper exhibits interesting class constraint sets order magnitude reasoning demonstrably fast. Specifically,
present polynomial-time algorithm solve set constraints form \Points
b much closer together points c d." prove algorithm
applied \much closer together" interpreted either referring infinite difference
scale referring finite difference scale, long difference scale greater
number variables constraint set. prove first-order theory
constraints decidable.
1. Introduction
Order magnitude reasoning | reasoning rough comparisons sizes quantities |
often called \back envelope calculation", implication calculations
quick though approximate. Previous AI work order magnitude reasoning, however,
focussed expressive power inferential structure, computational
leverage (Raiman, 1990; Mavrovouniotis Stephanopoulos, 1990; Davis, 1990; Weld,
1990).
paper exhibit interesting case solving set order magnitude
comparisons demonstrably much faster solving analogous set simple order
comparisons. Specifically, given set constraints form \Points b much
closer together points c d," consistency set determined
low-order polynomial time. contrast, easily shown solving set constraints
form \The distance b less equal distance c d"
one dimension NP-complete, higher dimensions hard solving arbitrary
set algebraic constraints reals.
particular, paper presents following results:
1. algorithm \solve constraints(S )" solves system constraints form \Points
b infinitely closer points c d" polynomial time (Section 5).
2. improved version algorithm runs time O(max(n2 ff(n)); ne; s) n
number variables, ff(n) inverse Ackermann's function, e number
edges mentioned constraint set, size constraint set. (Section
6.1).
3. extended version algorithm allows inclusion non-strict constraints
form \Points b infinitely apart points c d."
c 1999 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiDavis

running time modified algorithm slower solve constraints,
still polynomial time. (Section 6.2)
4. different extension algorithm allows combination order magnitude
constraints distances order comparisons points form \Point
precedes point b." (Section 6.3)
5. algorithm applied constraints form \The distance
b less 1=B times distance c d," B given finite value,
long B greater number variables constraint set. (Section 7)
6. first-order theory constraints decidable. (Section 8)
preliminary steps, begin small example informal discussion (Section
2). give formal account order-of-magnitude spaces (Section 3) present
data structure called cluster tree, expresses order-of-magnitude distance comparisons (Section 4). conclude paper discussion significance
results (Section 9).

2. Examples
Consider following inferences:

Example 1: wish buy house rent oce space suburb Metropolis.
obvious reasons, want house close school, house close
oce, oce close commuter train station. told Elmville
train station quite far school, Newton close together.
Infer able satisfy constraints Elmville, may able
Newton.
Example 2: Empire State Building much closer Washington Monument
Versailles. Statue Liberty much closer Empire State Building
Carnegie Hall Washington Monument.
Infer Carnegie Hall much closer Empire State Building Versailles.
Example 3: carry collection computational tasks covering wide
range diculty. instance
a.
b.
c.
d.
e.
f.

Add column 100 numbers.
Sort list 10,000 elements.
Invert 100 100 matrix.
Invert 1000 1000 matrix.
Given O.D.E. x = cos(et x), x(0) = 0, find x(20) 32-bit accuracy.
Given online collection 1,000 photographs GIF format, use state-ofthe-art image recognition software select show man
horseback.

2

fiOrder Magnitude Comparisons Distance

g. Web search collected 100 pictures men horseback,
using state-of-the-art image recognition software.
h. Using state-of-the-art theorem proving software, find proof medians triangle concurrent.
i. Using state-of-the-art theorem proving software, find proof Fermat's
little theorem.
plausible suppose that, many cases, say reliably one
task take much longer another, either human judgment using expert
system. instance, task (a) much shorter others. Task (b) much
shorter others except (a) possibly (h). Task (c) certainly much
shorter (d), (f), (g), (i). However, certain pairs (c) (h) (c)
(e) would dicult guess whether one much shorter another, whether
comparable diculty.
number independent identical computers, unknown vintage characteristics, schedule tasks kinds. Note that, circumstances, way predict absolute time required tasks within
couple orders magnitude. Nonetheless, comparative lengths presumably still stand.
Given: particular schedule tasks machines, infer relative
order completion times. example, given following schedule
Machine M1: tasks a,b,h,d.
Machine M2: tasks c,i.
possible predict (a) (b) complete (c); (c)
complete (d); (d) complete (i); possible
predict order (c) (h) complete.
three examples, given information form \The distance points
W X much less distance Z ". examples 1 2,
points geometric. example 3, points start completion times
various tasks, constraints relative lengths put form \The distance
start(a) end(a) much less distance start(c) end(c)", on.
example 3, ordering information: start task precedes end;
end (a) equal start (b); on. problem make inferences based
weak kind constraint.
noted examples meant illustrative, rather serious applications. Example 1 extend obvious way class natural,
large problems. Example 2 implausible state knowledge; reasoner
find knowing order-of-magnitude relations among distances
geometric information? Example 3 contrived. Nonetheless, illustrate kinds
situations order-of-magnitude relations distance arise; express
substantial part knowledge reasoner; inferences based purely
order-of-magnitude comparisons yield useful conclusions.
methods presented paper involve construing relation \Distance much
shorter distance E" \Distance infinitesimal compared distance
E." shall see, interpretation, systems constraints distances

3

fiDavis

solved eciently. logical foundations dealing infinitesimal quantities lie
non-standard model real line infinitesimals, developed Abraham Robinson
(1965). (A readable account given Keisler, 1976.) Reasoning quantities
infinitely different scale known \order magnitude" reasoning.
reader may ask, \Since infinitesimals physical reality, value
developing techniques reasoning them?" none examples, all,
smaller quantity truly infinitesimal larger one truly infinite. example 1
2, ratio successive sizes somewhere 10 100; example 3,
100 rather large number dicult estimate; one always give
kind upper bound. essentially certain, instance, ratio
times required tasks (a) (i) less 10100;000 . use best real-valued
estimate instead?
first answer idealization. Practically physical reasoning
calculation rest one idealization another: idealization situation calculus
time discrete; idealization solid objects rigid, employed mechanics programs; idealization physical properties density, temperature,
pressure continuous rather local averages atoms, underlies uses
partial differential equations; idealization involved use Dirac delta function;
on. idealization short distance infinitesimally smaller
long one simplifies reasoning yields useful results long care taken stay within
appropriate range application.
second answer technique mathematical approximation,
using turn intractable problem tractable one. would analogous
linearizing non-linear equation small neighborhood; approximating sum
integral.
circumstances sure approximation gives answer
guaranteed exactly correct; namely actual ratio implicit comparison
\D much smaller E " larger number points involved system
constraints. proven Section 7. broader, less well-defined, class
problems approximation, though guaranteed correct, reliable
links reasoning. instance, suppose one consider
instance example 3 involving couple hundred tasks, apply order-of-magnitude
reasoning, come answer determined wrong. possible
error would due order-of-magnitude reasoning. However, seems safe
say that, cases, error likely due mistake estimating
comparative sizes.

3. Order-of-magnitude spaces
order-of-magnitude space, om-space, space geometric points. two points
separated distance. Two distances e compared relation e,
meaning \Distance infinitesimal compared e" or, loosely, \Distance much
smaller e."
example, let < non-standard real line infinitesimals. Let <m
corresponding m-dimensional space. let point om-space point

4

fiOrder Magnitude Comparisons Distance

Rm . distance two points a; b Euclidean distance, non-negative
value < . relation e holds two distances d; e, d=e infinitesimal.
distance operator comparator related number axioms, specified
below. interesting called om-triangle inequality: ab bc
much smaller xy, ac much smaller xy. combines ordinary
triangle inequality \The distance ac less equal distance ab plus distance bc"
together rule order-of-magnitude algebra, \If p r q r p+q r."
simplify exposition if, rather talking distances, talk
orders magnitude. defined follows. say two distances e
order magnitude neither e e d. < condition d=e
finite: neither infinitesimal infinite. (Raiman, 1990 uses notation \d Co e"
relation.) rules order-of-magnitude calculus, equivalence relation.
Hence define order magnitude equivalence class distances
relation \same order magnitude". two points a; b, define function od(a; b)
order magnitude distance b. two orders magnitude p; q,
define p q if, representatives 2 p e 2 q, e. rules orderof-magnitude calculus, holds representatives, holds representatives.
advantage using orders-of-magnitude function \od", rather distances
distance function, allows us deal logical equality rather
equivalence relation \same order magnitude".
example, non-standard real line, let positive infinitesimal value.
values f1; 100; 2 50 + 1002 : : :g, order magnitude, o1.
values f; 1:001; 3 + e 1= : : :g different order magnitude o2 o1. values
f1=; 10= + 5 : : :g third order magnitude o3 o1.
Definition 1: order-of-magnitude space (om-space)
consists of:







set points P ;
set orders magnitude D;
distinguished value 0 2 D;
function \od(a; b)" mapping two points a; b 2 P order magnitude;
relation \d e" two orders magnitude d; e 2

satisfying following axioms:
A.1 orders magnitude d; e
e d, = e.

2 D, exactly one following holds: e,

A.2 d; e; f 2 D, e e f f .
(Transitivity. Together A.1, means total ordering orders
magnitude.)
A.3 2 D, 0.
(0 minimal order magnitude.)

5

fiDavis

A.4 points a; b 2 P , od(a; b) = 0 = b.
(The function od positive definite.)
A.5 points a; b 2 P , od(a; b) = od(b; a).
(The function od symmetric.)
A.6 points a; b; c 2 P , order magnitude 2 D,
od(a; b) od(b; c) od(a; c) d.
(The om-triangle inequality.)
A.7 infinitely many different orders magnitude.
A.8 point a1 2 P order magnitude
a2 ; a3 : : : od(ai ; aj ) = 6= j .

2 D, exists infinite set

example given om-space, non-standard Euclidean space, wild
woolly hard conceptualize. two simpler examples om-spaces:
I. Let infinitesimal value. define point polynomial integer
coecients, 3 + 5 85 . define order-of-magnitude power .
define n > n; example, 6 4 . define od(a; b) smallest power
b. example, od(1 + 2 33 ; 1 52 + 44 ) = 2 .
II. Let N infinite value. define point polynomial N integer
coecients. define order magnitude power N . define N p N q
p < q; example, N 4 N 6 . define od(a; b) largest power N b.
example, od(1 + N 2 3N 3 ; 1 5N 2 + 4N 4 ) = N 4 .
shown om-space either contains subset isomorphic (I) subset
isomorphic (II). (This special case general rule infinite total
ordering contains either infinite descending chain infinite ascending chain.)
use notation \de" abbreviation \d e = e".

4. Cluster Trees
Let P finite set points om-space. distances different pairs
points P different orders magnitude, om-space imposes unique treelike hierarchical structure P . points naturally fall clusters, cluster C
collection points much closer one another point
P outside C . collection clusters P forms strict tree subset
relation. Moreover, structure tree comparative sizes different clusters
tree captures order-of-magnitude relations pair points P .
tree clusters thus powerful data structure reasoning points
om-space, is, indeed, central data structure algorithms develop
paper. section, give formal definition cluster trees prove basic
results foundations algorithms.

Definition 2: Let P finite set points om-space. non-empty subset C P
called cluster P every x; 2 C , z 2 P C , od(x; y) od(x; z ). C cluster,
diameter C , denoted \odiam(C )", maximum value od(x; y) x; 2 C .

6

fiOrder Magnitude Comparisons Distance

n1
5
n2

n3

4

3

n4

n5





0

3

0

0

e

g

f

b

c

0

0

0

0

0

Figure 1: Cluster tree
Note set single element P trivially cluster P . entire set P
likewise cluster P . empty set definition cluster P .

Lemma 1: C clusters P , either C
disjoint.

D, C , C

Proof: Suppose not. let x 2 C \ D, 2 C D, z 2 C . Since C cluster,
od(x; y) od(x; z ). Since cluster, od(x; z ) od(x; y). Thus contradiction.

2

virtue lemma 1, clusters set P form tree. develop representation order magnitude relations P constructing tree whose nodes correspond
clusters P , labelled indication relative size cluster.

Definition 3: cluster tree tree

Every leaf distinct symbol.
Every internal node least two children.
internal node labelled non-negative value. Two nodes
may given value. (For purposes Sections 5-7, labels may taken
non-negative integers; Section 8, useful allow rational labels.)

Every leaf tree labelled 0.
label every internal node tree less label parent.
node N , field \N .symbols" gives set symbols leaves
subtree rooted N , field \N .label" gives integer label node N .

7

fiDavis

Thus, example, Figure 1, n3.label=3 n3.symbols = fa; dg; n1.label = 5
n1.symbols = fa; b; c; d; e; f; gg.
shall see, nodes tree represent clusters set points,
labels represent relative sizes diameters clusters.

Definition 4: valuation set symbols function mapping symbol
point om-space. cluster tree, valuation valuation .symbols.
N node valuation , write (N ) abbreviation
(N .symbols).
define cluster tree expresses order magnitude relations
set points P .
Definition 5: Let cluster tree let valuation . Let P = (T ),
set points image . say j=T (read satisfies instantiates
) following conditions hold:
i. internal node N , (N ) cluster P .
ii. cluster C P , node N C = (N ).
iii. nodes N , .label < N .label odiam( (M )) odiam( (N )).
iv. label(M ) = 0, odiam(M ) = 0. (That is, children assigned
value .)
following algorithm generates instantiation
procedure

variable

given cluster tree :

instantiate(in : cluster tree;
: om-space)
return : array points indexed symbols

G[N ] : array points indexed nodes ;

Let k number internal nodes ;
Choose 0 = 0 1 2 : : : k k + 1 different orders magnitude;
/* values chosen virtue axiom A.7 */
pick point x 2
;
G[root ] := x;
instantiate1(T;
; 1 : : : k ; G);
return restriction G symbols .
end instantiate.
instantiate1(in N : node cluster tree;
: om-space; 1 : : : k : orders magnitude;
G : array points indexed nodes )
N leaf
let C1 : : : Cp children N ;
x1 := G[N ];
q := N .label;
pick points x2 : : : xp
i; j 2 1 : : : p, 6= j od(xi ; xj ) = q ;
/* points chosen virtue axiom A.8 */
8

fiOrder Magnitude Comparisons Distance



= 1 : : : p
G[Ci ] := xi ;

instantiate1(Ci ;
; 1 : : : k ; G);

endfor
endif end

instantiate1.

Thus, begin picking orders magnitude corresponding values labels.
pick arbitrary point root tree, recurse nodes
tree. node N , place children points lie separated desired
diameter N . final placement leaves desired instantiation.
Lemma 2: cluster tree
om-space, instantiate(T;
) returns
instantiation .
proof given appendix.
Moreover, clear instantiation generated possible output
instantiate(T;
). (Given instantiation , pick G[N ] stage
symbol N .)
Note that, given valuation finite set symbols , exists cluster
tree .symbols = satisfies . essentially unique
isomorphism set labels preserves label 0 order labels.

5. Constraints
section, develop first algorithms. Algorithm solve constraints tests
collection constraints form \a much closer b c d," consistency. set consistent, algorithm returns cluster tree satisfies
constraints. algorithm builds cluster tree top bottom dealing first
large distances, proceeding smaller smaller distances.
Let system constraints form od(a; b) od(c; d); let cluster
tree. say `S (read \T satisfies ") every instantiation satisfies .
section, develop algorithm finding cluster tree satisfies given set
constraints.
algorithm works along following lines: Suppose solution satisfying .
Let diameter solution. contains constraint od(a; b) od(c; d) then,
since od(c; d) certainly D, follows od(a; b) much smaller D.
label ab \short" edge.
two points u v connected path short edges, triangle
inequality edge uv short (i.e. much shorter D). Thus, compute
connected components H edges labelled short, edges
H likewise labelled short. example, table 3, edges vz , wx, xy
labelled \short".
hand, shall prove below, edge set H ,
reason believe much shorter D. can, fact, safely posit
o.m. D. label edges \long".
assume connected component points connected short edges
cluster, child root cluster tree. root cluster tree
given largest label. children given smaller labels. \long" edge

9

fiDavis

connects symbols two different children root. Hence, instantiation tree
make long edge longer short edge.
edges labelled \long" | is, H contains complete graph
symbols | inconsistency; edges much shorter longest edge.
instance, table 4, since vw, wx, xy much smaller zy, follows
triangle inequality vy much smaller zy. since
constraints zy much smaller vz vz much smaller vy,
inconsistency.
algorithm iterates, next smaller scale. Since taken care
constraints od(a; b) od(c; d), cd labelled \long", drop
. Let greatest length edges remain . constraint
od(a; b) od(c; d) new , know od(a; b) much shorter D,
label \short". continue above. algorithm halts constraints
satisfied, therefore empty; encounter contradiction,
above.
give formal statement algorithm. algorithm uses undirected
graph variable symbols . Given graph G, constraint C
form od(a; b) od(c; d), refer edge ab \short" C , edge
cd \long" C . shorts system set shorts constraints
longs set longs constraints. edge may
short long appears one side one constraint another
constraint.
procedure

type:

solve constraints(in : system constraints form od(a; b) od(c; d))
return either cluster tree satisfying consistent;
false inconsistent.

node N cluster tree contains
pointers parent children N ;
field N.label, holding integer label;
field N.symbols, holding list symbols leaves N .

variables:

begin

integer;
C constraint ;
H; undirected graphs;
N; nodes ;

contains constraint form, \od(a; b) od(c; c)" return false;

:= number variables ;
initialize consist single node N ;
N .symbols:= variables ;
repeat

H := connected components shorts ;
H contains edges return(false) endif;
leaf N
vertices N connected H
N .label := m;
connected component N .symbols H

10



fiOrder Magnitude Comparisons Distance

construct node new child N ;
.symbols:= vertices ;

endfor endif endfor

:= subset constraints whose long H ;
:= 1;



empty;

leaf N
N .label := 0;
N .symbols one symbol
create leaf N symbol N .symbols;
label leaf 0;
endif endfor end solve constraints.

Tables 3 4 give two examples working procedure solve constraints. Table
3 shows procedure used establish following constraints
consistent:
Empire State Building (x) much closer Washington Monument (w)
Notre Dame Cathedral (v).
Bunker Hill (y) much closer Empire State Building Eiffel
Tower (z ).
distance Eiffel Tower Notre Dame much less distance
Washington Monument Bunker Hill.
Table 4 shows following inference justified:

Given: distances Statue Liberty (v) World Trade Center
(w), World Trade Center Empire State Building (x),
Empire State Building Chrysler Building (y) much less
distance Chrysler Building Washington Monument (z ).
Infer: Washington Monument much nearer Chrysler Building
Statue Liberty.
inference carried asserting negation consequent, \The Washington Monument much nearer Chrysler Building Statue Liberty,"
showing collection constraints inconsistent. Note change \much
less" \much nearer" example \less" \nearer", inference longer
valid.
Theorem 1 states correctness algorithm solve constraints. proof given
appendix.
Theorem 1: algorithm solve constraints(S ) returns cluster tree satisfying
consistent, returns false inconsistent.
may many cluster trees satisfy given set constraints. Among these,
cluster tree returned algorithm solve constraints important property:
fewest possible labels consistent constraints. words, uses
minimum number different orders magnitude solution. Therefore, algorithm
used check satisfiability set constraints om-space violates

11

fiDavis

contains constraints
1. od(w; x) od(x; v).
2. od(x; y) od(y; z ).
3. od(v; z ) od(w; y).
algorithm proceeds follows:
Initialization:
tree initializes single node n1.
n1.symbols := f v; w; x; y; z g.
First iteration:
shorts f wx; xy; vz g.
Computing connected components, H set f wx; xy; wy; vz g.
n1.label := 5;
Two children n1 created:
n11.symbols := w; x; ;
n12.symbols := v; z ;
xv H , delete constraint #1 .
yz H , delete constraint #2 .
contains constraint #3.
Second iteration:
shorts f vz g.
connected components H fvz g.
n11.label := 4;
Three children n11 created:
n111.symbols := w;
n112.symbols := x;
n113.symbols := z ;
wy H , delete constraint #3 .
empty.
Cleanup:
n12.label := 0;
Two children n12 created:
n121.symbols := v;
n122.symbols := z ;
(See Figure 2.)
Table 1: Example computing cluster tree

12

fiOrder Magnitude Comparisons Distance

n1
0th iteration
v,w,x,y,z

n1

1st iteration

5
v,w,x,y,z
n11

n12

w,x,y

v,z

n1
2nd iteration
5
v,w,x,y,z
n11
4

n12
w,x,y
v,z

w

x



n1
Cleanup
5
v,w,x,y,z
n11
4

w

x

n12
w,x,y

0



v

Figure 2: Building cluster tree

13

v,z

z

fiDavis

contains constraints
od(v; w) od(z; y).
od(w; x) od(z; y).
od(x; y) od(z; y).
od(z; y) od(v; z ).
algorithm proceeds follows:
Initialization:
tree initializes single node n1.
n1.symbols := f v; w; x; y; z g.
First iteration:
shorts f vw; wx; xy; zy; vz g.
H set connected components, complete graph v; w; x; y; z .
algorithm exits returning false
Table 2: Example determining inconsistency
axiom A.7 finitely many different orders magnitude. algorithm returns
different labels number different orders magnitude
space, constraints satisfiable. uses labels space
orders magnitude, constraints unsatisfiable.
proof easier present rewrite algorithm solve constraints following
form, returns number different non-zero labels used, actually
construct cluster tree.1

num labels(S );

function

return
else return

empty

(0)
(1 + num labels(reduce constraints(S )))
function reduce constraints(S )
H := connected components shorts ;
H contains edges return(false) top-level
else return(the set constraints whose long H )

easily verified sequence values successive recursive calls
num labels sequence values main loop solve constraints.
Therefore num labels returns number different non-zero labels tree constructed
solve constraints.
1. reader may wonder simpler algorithm presented complicated
algorithm solve constraints. reason proof found system constraints consistent num labels return
constructive solve constraints.

14

false

relies relation num labels

fiOrder Magnitude Comparisons Distance

Theorem 2: solutions set constraints , instantiations
solve constraints(S ) fewest number different values od(a; b), a; b range
symbols . number given num labels(S ).
proof given appendix.

6. Extensions Consequences
next present number modifications algorithm solve constraints. first
ecient implementation. second extends algorithm handle non-strict
comparisons. third extend algorithm handle combination order-of-magnitude
comparisons distance order comparisons, one-dimensional space.

6.1 Ecient Implementation Solve constraints
possible implement algorithm solve constraints somewhat eciently
naive encoding description. key observe graph H connected
components computed explicitly; suces compute implicitly using
merge-find sets (union-find sets). Combining suitable back pointers edges
constraints, formulate ecient version algorithm.
use following data structures subroutines:

node N cluster tree contains pointers parents children; field

N .label, holding integer label; field N .symbols, holding list symbols
leaves N ; field N .mfsets, holding list connected components
symbols N . described below, connected component implemented
merge-find set (MFSET).

edge E graph symbols contains two endpoints,

symbol; field E .shorts, list constraints E appears short;
field E .longs, list constraints E appears long.

constraint C two fields, C .short C .long, edges.

pointers lists C .short.shorts C .long.longs, enabling C removed
constant time constraint lists associated individual edges.

use disjoint-set forest implementation MFSETs (Cormen, Leiserson,

Rivest, 1990, p. 448) merging smaller sets larger path-compression.
Thus, MFSET upward-pointing tree symbols, node tree
symbol. tree whole represented symbol root. symbol
following fields:

{
{
{
{

A.parent pointer parent MFSET tree.
A.cluster leaf pointer leaf cluster tree containing A.
root MFSET A.size holds size MFSET.
root MFSET, A.symbols holds elements
MFSET.

15

fiDavis

{ root MFSET A.leaf ptr holds pointer pointer
N .mfsets N = A.cluster leaf.
describe algorithm.
procedure

variables:

0.
1.
2.
3.
4.
5.
6.
7.

begin

8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.

solve constraints1(in : system constraints form od(a; b) od(c; d)).
return either cluster tree satisfying consistent;
false inconsistent.
integer;
a; b symbols;
C constraint ;
H undirected graph;
E; F edges;
P MFSET;
N; nodes ;

contains constraint form, \od(a; b) od(c; c)" return false;

H := ;;

constraint C short E long F
add E F H ;
add C E .shorts F .longs endfor;
:= number variables ;
initialize contain root N ;
N .symbols := variables ;




leaf N , INITIALIZE MFSETS(N );
edge E = ab H
E .shorts non-empty FIND(a) 6= FIND(b)
MERGE(FIND(a), FIND(b)) endif endfor
every edge E = ab H satisfies FIND(a) = FIND(b)

repeat


return(false) endif



current leaf N
N .mfsets one element
mfset P N .mfsets
construct node new child N ;
.symbols:= P .symbols;
endfor endif endfor

edge E = ab H
FIND(a) 6= FIND(b)
constraint C E .longs
delete C ;
delete C E .longs;
delete C C .short.shorts endfor
delete E H endif endfor
:= 1;
empty;




leaf N
N .label := 0;
N .symbols one symbol
16

fiOrder Magnitude Comparisons Distance

32.
33.

create leaf N label 0 symbol N .symbols;
solve constraints1.


endif endfor end

INITIALIZE MFSETS(N : node)
: symbol;
N .mfsets := ;;
N .symbols
A.parent := null;
A.cluster leaf := N ;
A.symbols := fAg;
A.size := 1;
N .mfsets := cons(A,N .mfsets);
A.leaf ptr := N .mfsets;
endfor end INITIALIZE MFSETS.
procedure
var

MERGE(in A; B : symbol)
.size
.size swap(A; B );
A.parent := B ;
B .size := B .size + A.size;
B .symbols := B .symbols [ A.symbols;
Using A.leaf ptr, delete A.cluster leaf.mfsets;
end MERGE.
procedure

>B

FIND(in : symbol) return symbol;
: symbol;
.parent = null return
:= FIND(A.parent);
A.parent := R; /* Path compression */
return(R)
end FIND.
procedure
var R

else R

Let n number symbols ; let e number edges; let
number constraints. Note n=2 e n(n 1)=2 e=2 e(e 1)=2.
running time solve constraints1 computed follows. iteration
main loop 8-28 splits least one connected components H ,
n 1 iterations. MERGE-FIND operations loop 9-11 take together time
O(max(nff(n); e)) ff(n) inverse Ackermann's function. iteration
inner loop lines 16-18 creates one node tree. Therefore,
O(n) iterations loop entire algorithm. Lines 14, 15 outer
loop require n iterations iteration main loop. loop 22-26
executed exactly course entire execution algorithm
constraint C , hence takes time O(s) entire algorithm. Steps 20-21
require time O(e) iteration main loop. easily verified remaining
operations algorithm take time these. Hence overall running time
O(max(n2 ff(n); ne; s)).

17

fiDavis

6.2 Adding Non-strict Comparisons
algorithm solve constraints modified deal non-strict comparisons
form od(a; b) od(c; d) by, intuitively, marking edge ab \short" iteration
edge cd found short.
Specifically, algorithm solve constraints, make following two changes. First,
revised algorithm takes two parameters: , set strict constraints, W , set
non-strict constraints. Second, replace line
H := connected components shorts

following code:

1.
2.
3.
4.
5.

H := shorts ;
repeat H := connected components H ;
weak constraint od(a; b) od(c; d)
cd H add ab H endif endfor
change made H last iteration.

proof revised algorithm correct slight extension proof
theorem 1 given appendix.
Optimizing algorithm eciency little involved, new
operations must included, four parameters | n,
number symbols; e, number edges mentioned; s, number strict comparison;
w, number non-strict comparisons | optimal implementation varies
depending relative sizes. particular, either w, though both, may
much smaller n, cases requires special treatment optimal eciency.
best implementation found case w
(n)
running time O(max(n3 ; nw; s)). details implementation straightforward
sucient interest worth elaborating here.
immediate consequence result couple problems inference
easily computed:

determine whether constraint C consequence set constraints ,
form set [ :C check consistency. [ :C inconsistent Sj=C .
Note negation constraint od(a; b) od(c; d) constraint
od(c; d) od(a; b).
determine whether two sets constraints logically equivalent, check
constraint first consequence second, vice versa.

6.3 Adding Order Constraints
Example 3 Section 2 involves combination order-of-magnitude constraints distances together simple ordering points, points lie one-dimensional
line. next show extend algorithm solve constraints deal complex situation.

18

fiOrder Magnitude Comparisons Distance

terms axiomatics, adding ordering points involves positing
relation p < q total ordering ordering points related order
magnitude comparisons distances following axiom.
A.9 points a; b; c 2 P , < b < c od(a; b) od(a; c).
following rule easily deduced: C disjoint clusters, either every
point C less points D, vice versa.
extending algorithm, begin defining ordered cluster tree cluster
tree where, every internal node N , partial order children N .
B children N ordered B , instantiation tree,
every leaf must precede every leaf B . Procedure instantiate1 modified
deal ordered cluster trees follows:

instantiate1(in N : node cluster tree;
: om-space; 1 : : : k : orders magnitude;
G : array points indexed nodes )
N leaf
let C1 : : : Cp children N topologically sorted order;
x0 := G[N ];
q := N .label;
pick points x1 : : : xp increasing order
i; j 2 0 : : : p, 6= j od(xi ; xj ) = q ;
/* points chosen virtue axiom A.8 */
= 1 : : : p
G[Ci ] := xi ;
instantiate1(Ci ;
; 1 : : : k ; G)
endfor
endif end

instantiate1.

Algorithm solve constraints modified follows:
procedure

fNEWg

variables:

begin

solve constraints2(in : system constraints form od(a; b) od(c; d) ;
: system constraints form < b)
return either ordered cluster tree satisfying
consistent;
false inconsistent.
integer;
C constraint ;
H; undirected graphs;
M; N; P nodes ;
a; b; c; symbols;

contains constraint form, \od(a; b) od(c; c)"

return false

;

fNEWg internally inconsistent (contains cycle) return false;
:= number variables ;
initialize consist single node N ;
N .symbols:= variables ;
repeat

H := connected component shorts ;

19

fiDavis

fNEWg

H := incorporate order(H; O);
H contains edges


return false

leaf N
vertices N connected H
N .label := m;
connected component N .symbols H
construct node new child N ;
.symbols:= vertices ;
endfor endif

fNEWg
fNEWg
fNEWg
fNEWg
fNEWg



constraint < b 2
.symbols b P .symbols
P different children N
add ordering arc P ;
endif endfor

endfor

:= subset constraints whose long H ;
:= 1;



empty;

leaf N
N .label := 0;
N .symbols one symbol
create leaf N symbol N .symbols;
label leaf 0;
endif endfor

end

solve constraints2.

fNEWg

function

incorporate order(in H : undirected graph;
: system constraints form < b)
return undirected graph;

variables:

G : directed graph;
a; b : vertices H ;
A; B : connected components H ;
V [A] : array vertices G indexed connected components H ;
: subset vertices G;

connected component H create vertex V [A] G;
constraint < b 2
let B connected components H containing b respectively;
6= B add arc G V [A] V [B ] endif endfor;
strongly connected component G
pair distinct vertices V [A]; V [B ] 2
2 b 2 B add edge ab H endfor endfor




endfor

20

fiOrder Magnitude Comparisons Distance

end

incorporate order.

Function incorporate order serves following purpose. Suppose
midst main loop solve constraints2, partially constructed cluster tree,
currently working finding sub-clusters node N . original
form solve constraints, find connected components shorts order-ofmagnitude constraints. Let C1 : : : Cq ; know diameter Ci
much smaller diameter N . Now, suppose, example,
constraints a1 < a5 ; b5 < b2 ; c2 < c1 , a1 ; c1 2 C1 ; b2 ; c2 2 C2 ; a5 ; b5 2 C5 .
follows axiom A.9 C1 , C2 , C5 must merged single cluster,
whose diameter less diameter N . Procedure incorporate order finds
loops constructing graph G whose vertices connected components H
whose arcs ordering relations computing strongly connected
components G. (Recall two vertices u; v directed graph strongly
connected component cycle u v u.) merges together
connected components H lie single strongly connected component G.
proof correctness algorithm solve constraints2 analogous structure proof theorem 1, given appendix.
implementing manner Section 6.1, algorithm made run
time O(max(n2 ff(n); ne; no; s)), number constraints O.

7. Finite order magnitude comparison
section, demonstrated algorithm solve constraints applied systems
constraints form \dist(a; b) < dist(c; d) / B " finite B ordinary Euclidean
space long number symbols constraint network smaller B .
could sure immediately result must apply finite B .
fundamental property non-standard real line sentence first-order
theory reals holds infinite values holds suciently large finite
value, sentence holds infinite value holds arbitrarily large
finite values. Hence, since answer given algorithm solve constraints works
set constraints constraint \od(a; b) od(c; d)" interpreted \od(a; b)
< od(c; d)/B infinite B ", answer must valid suciently large finite B .
interesting find simple characterization B terms ; namely,
B larger number symbols .
begin modifying form constraints, interpretation cluster
tree. First, avoid confusion, use four-place predicate \much closer(a; b; c; d)"
rather form \od(a; b) od(c; d)" going give interpretation
\od" function. fix finite value B > 1, interpret \much closer(a; b; c; d)"
mean \dist(a; b) < dist(c; d) / B ."
next redefine means valuation instantiate cluster tree:

Definition 6: Let cluster tree let valuation symbols . say
`T following holds: symbols a; b; c; , let least common
ancestor a; b let N least common ancestor c; d. .label < N .label
much closer(a; b; c; d).

21

fiDavis

Procedure \instantiate", generates instantiation cluster tree, modified
follows:
procedure

instantiate(in : cluster tree;
: Euclidean space; B : real);
return : array points indexed symbols ;

Let n number nodes ;
:= 2 + 2n + Bn;
Choose 1 ; 2 : : : n < i+1 =ff;
pick point x 2
;
G[T ] := x;
instantiate1(T;
; 1 : : : n ; G);
return restriction G symbols .
end instantiate.
instantiate1(in N : node cluster tree;
: Euclidean space;
1 : : : n : orders magnitude;
G : array points indexed nodes )
N leaf
let C1 : : : Cp children N ;
x1 := G[N ];
q := N .label;
pick points x2 : : : xp
i; j 2 1 : : : p, 6= j q dist(xi ; xj ) < nq
/* possible since p n. */
= 1 : : : p
G[Ci ] := xi ;
instantiate1(Ci ;
; 1 : : : n ; G)
endfor
endif end

instantiate1.

analogue lemma 2 holds revised algorithm:
Lemma 22: cluster tree instantiation Euclidean space <m dimensionality m.
state theorem 3, asserts correctness algorithm \solve constraints"
new setting:

Theorem 3: Let set constraints n variables form \dist(a; b) <
dist(c; d) / B ", B > n. algorithm solve constraints(S ) returns cluster tree
satisfying consistent Euclidean space, returns false inconsistent.
proofs lemma 22 theorem 3 given appendix.
examination proof lemma 22 shows result depend
relation n B . Therefore, solve constraints(S ) returns tree ,
consistent satisfies regardless relation n B . However,
possible consistent solve constraints(S ) return false n B .
hand, one see proof theorem 3 (particularly lemma 23) B > n
solve constraints(S ) returns false inconsistent metric space. However,
metric spaces <m cluster tree returned solve constraints
may instantiation.

22

fiOrder Magnitude Comparisons Distance

8. first-order theory
final result asserts om-space rich enough full first-order language
order-of-magnitude distance comparisons decidable. Specifically, collection
orders magnitude dense unbounded above, decision algorithm
first-order sentences formula, \od(W; X ) od(Y; Z )" runs time O(4n (n!)2 s)
n number variables sentence length sentence.
basic reason following: observed corollary 4, cluster
tree determines truth value constraints form \od(a; b) od(c; d)"
a; b; c; symbols tree. is, two instantiations two omspaces agree constraint. require om-spaces dense
unbounded, much stronger statement holds: two instantiations
om-spaces agree first-order formula free symbols relation
\od(W; X ) od(Y; Z )". Hence, suces check truth sentence possible
cluster trees variables sentence. Since finitely many cluster
trees fixed set variables (taking account relative order labels
numeric values), decidable procedure.
Let L first-order language equality constant function symbols,
single predicate symbol \much closer(a; b; c; d)". easily shown L
expressive language function symbol \od" relation symbol .

Definition 7: om-space
orders magnitude
following axiom:

dense satisfies

A.9 orders magnitude 1 3 D, exists order magnitude 2
1 2 3 .

unbounded satisfies following:
A.10 every order magnitude 1 exists 2 1 2 .
collection orders magnitude hyperreal
line,
p
satisfied. axiom [A.9], 0 1 3 , choose 2 = 1 3 , geometric mean.
0 = 1 3 , choose 2 = 3 1. axiom [A.10] choose 2 = 1 =
0 < 1.

Definition 8: Let cluster tree. Let l0 = 0; l1 ; l2 : : : lk distinct labels
ascending order. extending label either (a) li i; (b) lk + 1 (note
lk label root); (c) (li 1 + li )=2 1 k.
Note k distinct non-zero labels, 2k + 2 different extending
labels .

Definition 9: Let cluster tree. Let x symbol . cluster tree
0
extends x 0 formed applying one following operations (a
single application single operation).
1. null tree 0 tree containing single node x.

23

fiDavis

2. consists single node symbol y. Make new node , make x
children , set label either 0 1.
3. internal node N (including root), make x child N .
4. Let symbol , let N father. N .label 6= 0, create new node
extending label .label < N .label. Make child N ,
make x children .
5. Let C internal node root, let N father. Create
new node extending label C .label < .label < N .label.
Make child N make x C children .
6. Let R root . Create new node .label = R.label + 1. Make
R x children . Thus root new tree 0 .
(See Figure 3.)
Note tree n symbols n 1 internal nodes

n 1 ways carry step 3.
n possible ways choose symbol step 4, 2n 2
label each.

n 2 different choices C step 5, 2n 3 choices
label each.

one way carry step 6.
Hence, less 4n2 different extensions x. (This almost certainly
overestimate least factor 2, final algorithm entirely impractical
worthwhile precise.)

Definition 10: Let cluster tree, let formula L open variables
. satisfies every instantiation satisfies .
Theorem 4: Let cluster tree. Let open formula L, whose free variables
symbols . Let
om-space dense unbounded above. Algorithm
decide(T; ) returns true satisfies false otherwise.

decide(T : cluster tree; : formula) return boolean
convert equivalent form logical symbols
: (not), ^ (and), 9 (exists), = (equals) variable names,
non-logical symbol predicate \much closer".
function

case

form X = : return (distance(X; Y; ) = 0);
form \much closer(W; X; Y; Z )": return distance(W; X; ) < distance(Y; Z; ));
form : : return not(decide(T; ))
form ^ : return(decide(T; ) decide(T; ))
form 9X ff;

24

fiOrder Magnitude Comparisons Distance

P

P

P

2

2

2
w

Q

Q

1

w

Q

w

x

1

1

u

u

v

u

v

v

x

Operation 3:

Operation 3:
Original

N = P

N = Q

P
2
w

Q
1

P

P

2

2
w

Q
1

Operation 4:

Operation 4:
y=v

y=u



Q

0/0.5/1/1.5

1
u

v




0/0.5

0/0.5

u

u

v

x

w

Operation 4:

x

y=w


P

3

2
x


w

P
2

1.5
Operation 5:
x

w

Q
1

C=Q, N=P

Q
1
u

u

v

v

v
Operation 6:
R=P

Figure 3: Extensions cluster tree

25

x

fiDavis

extension

, decide(T ; ff) = true


T0 X
return true
else return false endif endcase

end

0

decide

distance(X; : symbol; : cluster tree) return
N := common ancestor X ;
return(N .label)
function

end

integer

distance

proof theorem 4 given appendix.
Running time: remarked above, tree size k 4k2
extensions considered. total number cluster trees considered therefore
bounded nk=1 4k2 = 4n (n!)2 . easily verified logical operators
quantifiers add factor length sentence. Hence running
time bounded O(4n (n!)2 s).
key lemma, interest itself, states following:
Lemma 28: Let cluster tree. Let open formula L, whose free variables
symbols . Let
om-space dense unbounded above. one
instantiation
satisfies every instantiation
satisfies .
is, either true instantiations none. proof given
appendix.
observed conditions
lemma 28 necessary,
statement false otherwise. example, let
om-space described
example I, Section 3, polynomials infinitesimal .
unbounded
above; maximum order-of-magnitude O(1). Let starting tree Figure
3 (upper-left corner). Let formula \9X od(V; W ) od(W; X )", free V W .
valuation fU ! ; V ! 0; W ! 1g satisfies , whereas valuation
fU ! 2 ; V ! 22 ; W ! g satisfies .

9. Conclusions
applications specific algorithms undoubtedly limited; aware
practical problems solving systems order-of-magnitude relations distances
central problem. However, potential applications order-of-magnitude reasoning
generally widespread. Ordinary commonsense reasoning involves distances spanning ratio 108 , fraction inch thousands miles, durations
spanning ratio 1010 , fraction second human lifetime. Scientific
reasoning spans much greater ranges. Explaining dynamics star combines reasoning
nuclear reactions reasoning star whole; differ ratio
1057 . techniques needed compute quantities vastly differing
sizes quite different techniques needed compute quantities similar
sizes. paper small step development analysis computational
techniques.
results significant encouragement give hope
order-of-magnitude reasoning specifically, qualitative reasoning generally, may lead

26

fiOrder Magnitude Comparisons Distance

useful quick reasoning strategies broader range problems. often found
AI moving greater lesser precision mode inference type
knowledge lead quick dirty heuristic techniques, rather slow
dirty techniques. Nonmonotonic reasoning notorious example this,
arises well many types automated reasoning, including qualitative spatial
physical reasoning. algorithms developed paper welcome exception
rule. currently studying algorithmic techniques order-of-magnitude
problems, optimistic finding similar favorable results.

Acknowledgements
research supported NSF grant #IRI-9625859. Thanks Ji-Ae Shin,
Andrew Gelsey, reviewers helpful comments.

Appendix A. Proofs
appendix, give proofs various results asserted body paper.

Proof Lemma 2
Lemma 2: cluster tree
om-space, instantiate(T;
) returns
instantiation .
Proof: Let 0 = 0. node N , i=N .label, define (N ) = . proof
proceeds following steps:
i. nodes ,N , descendant N od(G[M ]; G[N ]) (N ).
Proof: child N , immediate construction x2 : : : xp
instantiate1. Else, let N = N1 ; N2 : : : Nq = path N
. definition cluster tree, follows Ni .label < N .label, > 1
therefore (Ni ) (N ). Thus od(G[M ]; G[N ]) (by o.m.-triangle inequality)
maxi=1:::q 1 (od(G[Ni+1 ]; G[Ni ])) maxi=1:::q 1 ((Ni )) (since Ni+1 child
Ni ) (N ).
ii. Let N node ; let C1 C2 two distinct children N ; let M1
M2 descendants C1 C2 respectively. od(G[M1 ]; G[M2 ]) = (N ).
Proof: construction x2 : : : xp instantiate1(N ), od(G[C1 ]; G[C2 ]) = (N ).
part (i.), od(G[M1 ]; G[C1 ]) (C1 ) (N ) likewise od(G[M2 ]; G[C2 ])
(N ). Hence, axiom A.6, od(G[M1 ]; G[M2 ]) = (N ).
iii. Let b two leaves , let N least common ancestor
b. od(G[a]; G[b]) = (N ). Proof: Immediate (ii).
iv. node N , odiam( (N )) = (N ). Proof: (iii), two leaves descending
different children N distance order (N ), two leaves N
distance order greater (N ).

27

fiDavis

v. node N , (N ) cluster (T ). Proof: Let b leaves N ,
let c leaf N . Let common ancestor b
let J common ancestor c. either N descendant N
J proper ancestor N . Therefore part (i), (I ) (J ). (iii),
od( (a); (b)) = (I ) (J ) = od( (a); (c)).
vi. internal nodes N; .label < N .label odiam( (M )) odiam( (N )).
Proof: Immediate (iv) construction .
vii. C cluster (T ) node N C = (N ). Proof: Let
set symbols corresponding C let N least common ancestor
. Let b two symbols different subtrees N .
(iii), od(G[a]; G[b]) = (N ). Let x symbol N .symbols. (iii)
od(G[a]; G[x]) (N ). Hence G[x] 2 C .

2
Proof Theorem 1
prove correctness algorithm solve constraints. assume throughout
two variables long constraint distinct.
Lemma 3: Let cluster tree let instantiation . Let b
symbols . Let N least common ancestor b . od( (a); (b)) =
odiam( (N )).
Proof: Since (a) (b) elements (N ), follows definition odiam
od( (a); (b)) odiam( (N )). Suppose inequality strict; is, od( (a); (b))
odiam( (N )). let C set symbols c od( (a); (c))
od( (a); (b)). odiam( (C )) = od( (a); (b)) odiam( (N )). easily shown
(C ) cluster (T ). Therefore, property (ii) definition 5, must
node .symbols = C . Now, certainly ancestor N , since
odiam( (M )) odiam( (N )) .symbols contains b. contradicts
assumption N least common ancestor b. 2
Corollary 4: Let cluster tree let instantiation . Let a; b; c;
symbols . Let N least common ancestor c , let
least common ancestor b . od( (a); (b)) od( (c); (d))
.label < N .label.
Proof: Immediate lemma 3 property (iii) definition 5 instantiation. 2

Lemma 5: Let set constraints form od(a; b) od(c; d). Let H
connected components shorts . consistent, every edge
H.
Proof: Let valuation satisfying . Find edge pq od( (p); (q))
maximal. Now, ab short | is, constraint od(a; b) od(c; d)
| od( (a); (b)) od( (c); (d)) od( (p); (q)).

28

fiOrder Magnitude Comparisons Distance

Now, let ab edge H , connected components shorts .
path a1 = a; a2 : : : ak = b edge ai ai+1 short = 1 : : : k 1.
Thus, om-triangle inequality, od( (a); (b)) maxi=1::k 1(od( (ai ); (ai+1 )))
od( (p); (q)). Hence pq 6= ab, pq H . 2

Lemma 6: values H iteration supersets values later
iteration.

Proof: reset subset end iteration. H defined terms
monotonic manner. 2

cannot two successive iterations main loop.
Proof: contradiction. Suppose two successive iterations. H
same, since defined terms . H constructed contain shorts
, Since resetting end first iteration change , H must
contain longs well. Thus, H contains edges . case,
algorithm terminated failure beginning first iteration. 2
Lemma 7:

Lemma 8: Algorithm solve constraints always terminates.
Proof: lemma 7, algorithm exit failure, iteration
constraints removed . Hence, number iterations main loop
original size . Everything else algorithm clearly bounded. (Note
bound number iterations improved Section 6.1 n 1, n
number symbols.) 2

Lemma 9: algorithm solve constraints returns false, inconsistent.

Proof: algorithm returns false, transitive closure shorts contains
edges . lemma 5, inconsistent.

Lemma 10: constraint C form od(a; b) od(c; d) initial value ,
edge cd H particular iteration, constraint C start
iteration.
Proof: Suppose C deleted particular iteration. edge cd,
long C , cannot H iteration. is, possible edge cd persist
H iteration C deleted . Note that, lemma 6, cd
eliminated H , remains H . 2
Lemma 11: following loop invariant holds: end loop iteration,
values L.symbols, L leaf current state tree, exactly
connected components H .

Proof: first iteration, initially root R, containing symbols,
child R created connected component H .
Let Ti Hi values H end ith iteration. Suppose
invariant holds end kth iteration. lemma 6, Hk+1 subset Hk .
Hence, connected component Hk+1 subset connected component Hk .

29

fiDavis

Moreover, connected component J Hk either connected component Hk+1
partitioned several connected components Hk+1 . former case, leaf
Tk corresponding J unchanged remains leaf Tk+1 . latter case, leaf
corresponding J gets assigned one child connected component Hk+1
subset J . Thus, connected components Hk+1 correspond leaves Tk+1 . 2

Lemma 12: procedure solve constraints return false, returns wellformed cluster tree .
Proof: Using lemma 11, cleanup section solve constraints creates final
leaves symbols, follows every symbol ends single leaf .
decremented iteration, iteration adds new node children
node, follows label internal node less label father.
Hence constraints cluster trees (definition 3) satisfied. 2
Lemma 13: Let a; b two distinct symbols let cluster tree returned
solve constraints . Let N least common ancestor a; b . either N
assigned label first iteration edge ab H , edge ab
final value H loop exited N assigned label final cleanup
section.
Proof: above, let Hi value H ith iteration.
N root, assigned label first iteration. Clearly, b,
different subtrees N , must different connected components H1 .
Suppose N assigned label kth iteration loop k > 1. lemma 11,
end previous iteration, N .symbols connected component Hk 1 ,
therefore contained edge ab. Since N least common ancestor a; b, follows
b placed two different children N ; hence, two different connected
components Hk . Thus edge ab cannot Hk .
Suppose N assigned label cleanup section algorithm. lemma
11, N .symbols connected component final value H . Hence edge ab
final value H . 2
Lemma 14: Let initially contain constraint C form od(a; b) od(c; d). Suppose
solve constraints(S ) returns cluster tree . Let least common ancestor a; b
let N least common ancestor c; d. .label < N .label.
Proof: Suppose N given label given iteration. lemma 13, cd eliminated
H iteration. lemma 10, constraint C must start
iteration. Hence ab short iteration, therefore H . Hence
given label later iteration, therefore given lower label.
easily seen cd cannot H final iteration loop, hence N
assigned label cleanup section. 2
Lemma 15: Suppose solve constraints(S ) returns cluster tree . instantiation satisfies constraints .
Proof: Immediate lemma 14 corollary 4.

30

fiOrder Magnitude Comparisons Distance

Theorem 1: algorithm solve constraints(S ) returns cluster tree satisfying
consistent, returns false inconsistent.
Proof: solve constraints(S ) returns false, inconsistent (lemma 9).
return false, returns cluster tree (lemma 12). Since instantiation
(lemma 2) since every instantiation solution (lemma 15), follows
consistent satisfies . 2
Proof Theorem 2
Lemma 16: S1 S2 consistent sets constraints, S1 S2
reduce constraints(S1 ) reduce constraints(S2 ).
Proof: Immediate construction. value H case S1 superset value
case S2 , hence reduce constraints(S1 ) superset reduce constraints(S2 ).
Lemma 17: S1 S2 consistent sets constraints, S1 S2 num labels(S1)
num labels(S2).
Proof induction num labels(S2). num labels(S2) = 0, statement trivial.
Suppose statement holds 0 , num labels(S 0) = k.
Let num labels(S2) = k + 1.
k + 1 = num labels(S2 ) = 1 + num labels(reduce constraints(S2 )),
k =num labels(reduce constraints(S2 )). Now, suppose S1 S2 . lemma 16
reduce constraints(S1 ) reduce constraints(S2 ). inductive hypothesis
num labels(reduce constraints(S1 )) num labels(reduce constraints(S2 )),
num labels(S1) num labels(S2). 2
Lemma 18: Let set constraints, let solution . graph G
symbols , let nd(G; ) number different non-zero values od(a; b)
edge ab G. Let edges(S ) set edges . nd(edges(S ), )
num labels(S ).
Proof: induction num labels(S ). num labels(S ) = 0, statement trivial.
Suppose k, statement holds 0 num labels(S 0) = k, suppose
num labels(S ) = k + 1. Let pq edge maximal length. set edges E ,
let small-edges(E; ) set edges ab E
od( (a); (b)) od( (p); (q)). Since small-edges(E ) contains edges every order
magnitude E except order magnitude pq, follows
nd(small-edges(E; ), ) = nd(E; ) 1. Let G complete graph symbols
. argument lemma 5, small-edges(G; ) H , H connected
components shorts , computed reduce constraints(S ). Let 0 set
constraints whose longs small-edges(G; ). follows 0 reduce constraints(S ).
small-edges(G; ) edges(S 0 ) edges(reduce constraints(S )).
Hence nd(edges(S ), ) = nd(G; ) = nd(small-edges(G; ), ) + 1
nd(edges(reduce constraints(S ))) + 1 (by inductive hypothesis)
num labels(reduce constraints(S )) + 1 = num labels(S ). 2

31

fiDavis

Theorem 2: solutions set constraints , instantiations
solve constraints(S ) fewest number different values od(a; b), a; b range
symbols . number given num labels(S ).
Proof: Immediate lemma 18.
Corollary 19: Let
properties om-space except k
different orders magnitude. system constraints solution

tree returned solve constraints(S ) uses k different labels.
Proof: Immediate theorems 1 2. 2
Proof Algorithm Non-strict Comparisons
prove revised algorithm presented Section 6.2 non-strict comparisons
correct. proof slight extension proof theorem 1, given above.
Recall revised algorithm Section 6.2 replaces line solve constraints
H := connected components shorts
following code:

1.
2.
3.
4.
5.

H := shorts ;
repeat H := connected components H ;
weak constraint od(a; b) od(c; d)
cd H add ab H endif endfor
change made H last iteration.

need following new lemmas proofs:

Lemma 20: Let set strict comparisons, let W set non-strict comparisons. Let H set edges output code. [ W consistent,
edge H .
Proof: proof lemma 5, let valuation satisfying [ W let pq
edge od( (p); (q)) maximal. wish show that, every edge
ab 2 H , od( (a); (b)) od( (p); (q)), hence ab 6= pq. Proof induction: suppose
holds edges H point code, ab
added H . three cases consider.

ab added step [1]. Then, lemma 5, constraint od(a; b) od(c; d)
. Hence od( (a); (b)) od( (c); (d)) od( (p); (q)).
ab added step [2]. path a1 = a; a2 : : : ak = b edge
ai ai+1 H = 1 : : : k 1. inductive hypothesis, od( (ai ); (ai+1 ))
od( (p); (q)). om-triangle inequality,
od( (a); (b)) maxi=1::k 1(od( (ai ); (ai+1 ))) od( (p); (q)).

ab added step [4]. constraint od(a; b) od(c; d) W
cd H . inductive hypothesis, od( (c); (d)) od( (p); (q)).
32

fiOrder Magnitude Comparisons Distance

2

Lemma 21: Let W contain constraint od(a; b) od(c; d). Suppose algorithm
returns cluster tree . Let least common ancestor b , let N
least common ancestor c d. .label N .label.
Proof: lemma 13, N assigned label first iteration H include
edge cd. previous iterations, since cd H , ab likewise put H .
Hence get assigned label N , .label N .label.
remainder proof correctness revised algorithm exactly
proof theorem 1.
Validation Algorithm Solve constraints2
proof correctness algorithm solve constraints2 analogous structure
proof theorem 1. sketch below: details dicult fill in.
1. (Analogue lemma 2:) ordered cluster tree, revised version
instantiate(T ) returns instantiation . proof exactly lemma
2, additional verification instantiate2 preserves orderings .
2. (Analogue lemma 5:) Let set order-of-magnitude constraints distances,
let set ordering constraints points. Let H graph given
two statements

H := connected components shorts ;
H := incorporate order(H; O);
consistent, H contain edges .
Proof: proof lemma 5, choose valuation satisfying ; let pq
edge od( (p); (q)) maximal. Following informal argument
presented Section 6.3, easily shown pq longer edges
added two statements, hence H .
3. (Analogue lemma 9:) solve constraints2 returns false, ; inconsistent.
Proof: Immediate (2).
4. (Analogue lemma 12:) solve constraints2(S ; O) return false,
returns well-formed ordered cluster tree.
Proof: merging strongly connected components G, incorporate order always
ensures ordering arcs connected components H form DAG.
arcs precisely ones later added among children node N
ordering arcs. Thus, ordering arcs children node cluster tree
form DAG. Otherwise, construction tree lemma 12.
remainder proof proof theorem 1.

33

fiDavis

Proof Theorem 3
begin proving lemma 22, revised version \instantiate", given Section
6.3, gives instantiation cluster tree Euclidean space.
Lemma 22: cluster tree instantiation Euclidean space <m dimensionality m.
proof essentially proof Lemma 2, except
keep track real quantities. node N , i=N .label, define (N ) = .
proof proceeds following steps:
i. < j , < j =ffj . Immediate construction.
ii. nodes ,C , descendant C
dist(G[M ]; G[C ]) < ffn(C )=(ff 1).
Proof: Let C = C0 ; C1 : : : Cr = path P
C .
dist(
triangle inequality) ri=01 dist(G[Ci+1]; G[Ci ])
Pr 1G(n[M(];CG)[=ffC ])i) < (by
(ff=(ff 1))(n(C )).
i=0
iii. Let N node ; let C1 C2 two children N ; let M1 M2
descendants C1 C2 respectively.
(N )(1 2n=(ff 1)) < dist(G[M1]; G[M2 ]) < n(N )(1 + 2=(ff 1))
Proof: triangle inequality,
dist(G[C1 ]; G[C2 ]) dist(G[C1 ]; G[M1 ]) + dist(G[M1 ]; G[M2 ]) + dist(G[M2 ]; G[C2 ]).
Thus, dist(G[C1]; G[C2 ]) dist(G[C1]; G[M1 ]) dist(G[M2 ]; G[C2 ]) dist(G[M1 ]; G[M2 ]).
Also, triangle inequality,
dist(G[M1 ]; G[M2 ]) dist(G[C1]; G[C2 ]) + dist(G[C1]; G[M1 ]) + dist(G[M2 ]; G[C2 ]).
construction, (N ) dist(G[C1]; G[C2 ]) < n(N ),
part (ii), = 1; 2, dist(G[Mi]; G[Ci ]) < ffn(C )=(ff 1) < n(N )=(ff 1)
(C ) < (N )=ff.
iv. symbols a; b; c; , let P least common ancestor a; b let N
least common ancestor c; d. P .label < N .label
much closer(G[a]; G[b]; G[c]; G[d]).
Proof: part (iii), dist(G[a]; G[b]) < n(P )(1 + 2=(ff 1))
dist(G[c]; G[d]) > (N )(1 2n=(ff 1)). Since (P ) < (N )=ff since
= 2 + 2n + Bn, follows straightforward algebra
dist(G[a]; G[b]) < dist(G[c]; G[d]) / B .

2

next prove analogue lemma 5.

Lemma 23: Let set constraints n variables form
\dist(a; b) < dist(c; d) / B ", B > n. consistent, edge
connected components shorts .
Proof: Let valuation satisfying . Let pq edge dist( (p); (q))
maximal. Now, ab short | is, constraint much closer(a; b; c; d)
| dist( (a); (b)) < dist( (c); (d))/B dist( (p); (q))/B .

34

fiOrder Magnitude Comparisons Distance

Now, let ab edge H , connected components shorts .
simple path a1 = a; a2 : : : ak = b edge ai ai+1 short
= 1 : : : k 1. Note k n. Then, triangle inequality,
dist( (a); (b))
dist( (a1 ); (a2 )) + dist( (a2 ); (a3 )) + . . . + dist( (ak 1 ); (ak ))
(k 1)dist( (p); (q)) / B < dist( (p); (q))

Hence pq 6= ab, pq H . 2

Theorem 3: Let set constraints n variables form \dist(a; b) < dist(c; d)
/ B ", B > n. algorithm solve constraints(S ) returns cluster tree satisfying
consistent Euclidean space, returns false inconsistent.
Proof: Note semantics constraints \much closer(a; b; c; d)" enters
proof Theorem 1 lemmas 2 5. remainder proof Theorem 1
purely relation structure structure tree. Hence,
since shown analogues lemmas 2 5 hold set constraints
kind, proof completed exactly way. 2
Proof Theorem 4
Lemma 24: Let cluster tree let valuation om-space
satisfying .
Let x symbol , let point
, let 0 valuation [ fx ! ag.
exists extension 0 x 0 satisfies 0 .
Proof: empty tree, statement trivial. contains single symbol y,
= (y) operation (2) applies .label=0; 6= (y) operation (2)
applies .label=1.
Otherwise, let symbol od( (y); a) minimal. (We deal
case ties step (D) below.) Let F father .
Let D=od( (y); a). Let V set orders magnitude od( (p); (q)),
p q range symbols . define L suitable label follows:
2 V , L label corresponding D. larger value V
L label root plus 1. 62 V , value V larger D,
let D1 largest value V less D; let D2 smallest value V greater
D; let L1 , L2 labels corresponding D1 , D2 ; let L = (L1 + L2 )=2.
One following must hold:
A. (y) = a, F .label=0. apply operation (3) N = F .
B. (y) = F .label 6= 0. apply operation (4) .label = 0.
C. (y) 6= a, od( (y); a) less od( (z ); a) symbol z =
6 .
Apply operation (4) .label set suitable value .
D. one value y1 : : : yk od( (yi ); a) = D. easily shown
case internal node Q y1 : : : yk set symbols
subtree Q. three cases consider:

35

fiDavis

D.i D=odiam( (Q.symbols)). apply operation (3) N = Q.
D.ii > odiam( (Q.symbols)), Q root. apply operation (5)
C = Q. Set .label suitable value D. (It easily shown
< odiam( (N .symbols)), N father Q.)
D.iii > odiam( (Q.symbols)), Q root. Apply operation (6).

2

Lemma 25: Let = fa1 : : : ak g finite set points whose diameter order-ofmagnitude D. exists point u that, = 1 : : : k, od(u; ai ) = D.
Proof: Let b1 = a1 . axiom A.8 exists infinite collection points b2 ; b3 : : :
od(bi ; bj ) = 6= j . Now, value ai one value bj
od(ai ; bj ) D; two values bj 1 bj 2, om-triangle
inequality, od(bj 1; bj 2 ) D. Hence, k different values bj least
ai . Let u values bj . since od(u; a1 ) = od(a1 ; ai )
i, follows od(u; ai ) ai . Thus, since od(u; ai ) od(u; ai )
D, follows od(u; ai) = D. 2
Lemma 26: Let cluster tree; let valuation om-space
satisfying ;
let 0 extension x.
dense unbounded above,
value valuation [ fx ! ag satisfies 0 .
Proof: operations (1) (2) statement trivial.
Otherwise, let L extending label . L = 0, set = 0. L ,
let order magnitude corresponding L . L1 < L < L2
L1 L2 labels consecutive values , let D1 D2 orders
magnitude corresponding L1 , L2 . Let chosen D1 D2 .
L greater label tree, choose greater diameter
tree .
0 formed operation (3), using lemma 25 let point
od(a; (y)) = odiam(N ) N .symbols.
0 formed operation (4), let point od(a; (y)) =
D.
0 formed operation (5), let point od(a; (y)) =
C .symbols. (Note that, since .label < N .label, < odiam(N .symbols).)
0 formed operation (6), let point od(a; (y)) =
R.symbols.
cases, straightforward verify [ fx ! ag satisfies 0 . 2
observed Section 8 regarding lemma 28, conditions
lemma 26
necessary, statement false otherwise. example, let
om-space
described example I, Section 3, polynomials infinitesimal .

unbounded above; maximum order-of-magnitude O(1). Let starting tree
Figure 3 (upper-left corner), let 0 result applying operation 6 (middle
bottom). Let valuation fu ! ; v ! 2; w ! 1g. satisfies , cannot
extended valuation satisfies 0 , would require x given value
od(v; w) od(x; w), value exists within
. point lemma

36

fiOrder Magnitude Comparisons Distance

that,
required dense unbounded above, cannot get \stuck"
way.

Lemma 27: Let cluster tree. Let X variable among symbols .
Let open formula L, whose free variables symbols variable
X . Let formula 9X ff. Let
om-space dense unbounded above.
exists instantiation
satisfies exists
extension 0 instantiation 0 0 extends satisfies ff.
Proof: Suppose exists instantiation satisfies 9X ff. Then,
definition, point
satisfies ff(X=a). is, instantiation
[ fX ! ag satisfies ff. Let 0 = [ fX ! ag. lemma 24, cluster tree 0
corresponding 0 extension .
Conversely, suppose exists extension 0 instantiation 0 0
satisfying ff. Let restriction 0 symbols . clearly satisfies
formula 9X ff. 2
Lemma 28: Let cluster tree. Let open formula L, whose free variables
symbols . Let
om-space dense unbounded above. one
instantiation
satisfies every instantiation
satisfies .
Proof: assume without loss generality logical symbols :
(not), ^ (and), 9 (exists), = (equals) variables names, non-logical
symbol predicate \much closer". proceed using structural induction
form . Note equivalent statement inductive hypothesis is, \For formula
, either true every instantiation , false every instantiation
."
Base case: atomic formula \X = " \much closer(W; X; Y; Z )"
follows immediately corollary 4.
Let form : . true , false . inductive hypothesis, false every instantiation . Hence true every
instantiation .
Let form ^ . true true .
inductive hypothesis, true every instantiation . Hence
true every instantiation .
Let form 9X ff. true lemma 27, exists
extension 0 instantiation 0 0 true 0 . inductive
hypothesis, true every instantiation 0 . Now, 0 instantiation 0
satisfies ff, restriction 0 variables , clearly satisfies
9X ff. lemma 26, every instantiation extended instantiation 0
0 . Therefore, every instantiation satisfies . 2
Theorem 4: Let cluster tree. Let open formula L, whose free variables
symbols . Let
om-space dense unbounded above. Algorithm
decide(T; ) returns true satisfies false otherwise.
Proof: Immediate proof lemma 28. 2

37

fiDavis

References
Cormen, T.H., Leiserson, C.E., Rivest. R.L. (1990). Introduction Algorithms. Cambridge, MA: MIT Press
Davis, E. (1990). Order Magnitude Reasoning Qualitative Differential Equations.
D. Weld J. de Kleer (Eds.) Readings Qualitative Reasoning Physical Systems.
San Mateo, CA: Morgan Kaufmann. 422-434.
Keisler, J. (1976). Foundations Infinitesimal Calculus. Boston, MA: Prindle, Webber,
Schmidt.
Mavrovouniotis, M. Stephanopoulos, G. (1990). \Formal Order-of-Magnitude Reasoning Process Engineering." D. Weld J. de Kleer (Eds.) Readings Qualitative
Reasoning Physical Systems. San Mateo, CA: Morgan Kaufmann. 323-336.
Raiman, O. (1990). \Order Magnitude Reasoning." D. Weld J. de Kleer (Eds.)
Readings Qualitative Reasoning Physical Systems. San Mateo, CA: Morgan Kaufmann. 318-322.
Robinson, A. (1965). Non-Standard Analysis. Amsterdam: North-Holland Publishing Co.
Weld, D. (1990). \Exaggeration." D. Weld J. de Kleer (Eds.) Readings Qualitative
Reasoning Physical Systems. San Mateo, CA: Morgan Kaufmann. 417-421.

38


