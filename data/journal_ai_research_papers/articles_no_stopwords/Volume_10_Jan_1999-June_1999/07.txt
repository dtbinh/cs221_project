Journal Artificial Intelligence Research 10 (1999) 353-373

Submitted 8/98; published 5/99

\Squeaky Wheel" Optimization
David E. Joslin

david joslin@i2.com

i2 Technologies
909 E. Las Colinas Blvd.
Irving, TX 75039

David P. Clements

Computational Intelligence Research Laboratory
1269 University Oregon
Eugene, 97403-1269

clements@cirl.uoregon.edu

Abstract

describe general approach optimization term \Squeaky Wheel" Optimization (SWO). SWO, greedy algorithm used construct solution
analyzed find trouble spots, i.e., elements, that, improved, likely
improve objective function score. results analysis used generate
new priorities determine order greedy algorithm constructs next
solution. Construct/Analyze/Prioritize cycle continues limit reached,
acceptable solution found.
SWO viewed operating two search spaces: solutions prioritizations.
Successive solutions indirectly related, via re-prioritization results
analyzing prior solution. Similarly, successive prioritizations generated constructing analyzing solutions. \coupled search" interesting properties,
discuss.
report encouraging experimental results two domains, scheduling problems
arise fiber-optic cable manufacturing, graph coloring problems. fact
domains different supports claim SWO general technique optimization.

1. Overview
describe general approach optimization term \Squeaky Wheel" Optimization (SWO) (Joslin & Clements, 1998). core SWO Construct/Analyze/Prioritize
cycle, illustrated Figure 1. solution constructed greedy algorithm, making decisions order determined priorities assigned elements problem.
solution analyzed find elements problem \trouble makers."
priorities trouble makers increased, causing greedy constructor deal
sooner next iteration. cycle repeats termination condition
occurs.
iteration, analyzer determines elements problem causing
trouble current solution, prioritizer ensures constructor
gives attention elements next iteration. (\The squeaky wheel gets
grease.") construction, analysis prioritization terms elements

c 1999 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiJoslin & Clements

Analyzer
Blame

Solution

Constructor

Priorities

Prioritizer

Figure 1: Construct/Analyze/Prioritize cycle
define problem domain. scheduling domain, example, elements might
tasks. graph coloring, elements might nodes colored.
three main components SWO are:

Constructor. Given sequence problem elements, constructor generates solution

using greedy algorithm, backtracking. sequence determines order
decisions made, thought \strategy" \recipe"
constructing new solution. (This \solution" may violate hard constraints.)

Analyzer. analyzer assigns numeric \blame" factor problem elements

contribute aws current solution. example, minimizing lateness
scheduling problem one objectives, blame would assigned late
tasks.
key principle behind SWO solutions reveal problem structure. analyzing solution, often identify elements solution work well,
elements work poorly. resource used full capacity, example, may
represent bottleneck. information problem structure local,
may apply part search space currently examination, may
useful determining search go next.
Prioritizer. prioritizer uses blame factors assigned analyzer modify
previous sequence problem elements. Elements received blame moved
toward front sequence. higher blame, element
moved.
priority sequence plays key role SWO. dicult problem element moves
forward sequence handled sooner constructor. tends handled
better, thus decreasing blame factor. Dicult elements rise rapidly place
sequence handled well. there, blame assigned drops,
causing slowly sink sequence parts problem
handled well given increased priority. Eventually, dicult elements sink back
point longer handled well, causing receive higher blame
move forward sequence again. Elements always easy handle sink
end sequence stay there.
354

fi\Squeaky Wheel" Optimization

Iteration: 1 Priorities: C,A,B
Late: (20), B (30)

0

10

20

C

Iteration: 2 Priorities: B,A,C
Late: (20), C (10)

0

10



20

B
Iteration: 3 Priorities: A,C,B
Late: B (30)

0

10



30



C

50

B

30

20

40

40

Task

B
C

Duration Deadline
10
10
20
20
40
20

50

C
30

40

50

B

Figure 2: Simple example
illustrate SWO cycle, consider simplified scheduling example. Suppose
single production line, three tasks schedule, A, B C . one task
performed time. Execution starts = 0. duration deadline task
shown Figure 2. objective minimize number late tasks. optimal
solution one late task.
Suppose initial priority sequence hC; A; B i, constructor schedules tasks
order, earliest possible time. resulting schedule two late tasks (B
A). Suppose analyzer assigns one point \blame" late task,
unit time late. case, A, B , C receive 20, 30 0 units blame,
respectively. Figure 2 shows prioritization, schedule constructor builds
prioritization, late tasks blame assigned each.
next cycle, prioritizer must take previous priority sequence,
blame assigned analyzer, generate new priority sequence. simple prioritizer
might sort tasks numeric blame descending order, resulting new
priority sequence hB; A; C i.
second cycle, tasks C late, scoring 20 10 points blame,
respectively. new priority sequence hA; C; B i.
third solution, constructed priority sequence, one late task, B ,
receives 30 points blame. point optimal solution. continue
running SWO, however, might expect since typically know
reached optimality, SWO attempt fix wrong current solution.
Here, since task B late, priority would increased, resulting solution would
fix problem expense others. (We would enter short cycle, alternating
last two schedules. address introducing randomization
prioritizer.)
Although example highly simplified, would clearly better
sophisticated ways implement three modules, Figure 3 shows behavior
illustrated simple example ected real domain. figure shows changing
position priority sequence three tasks scheduling domain described
detail following section. One task (\Job 24") starts high priority,
remains relatively high priority level. see task scheduled
effectively, therefore receives little blame, priority tends drop,
355

fiPriority

(high)

Joslin & Clements

(low)

Job 24
Job 26
Job 39
1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20
Iteration

Figure 3: Examples priority changes time
drop far ceases scheduled well, acquires significant level
blame, moves quickly back higher priority.
two tasks shown figure behave quite differently. One task (\Job 39")
starts relatively high priority, task \easy" schedule, little
blame, even scheduled late sequence. successive iterations,
priority task tend decrease steadily. task illustrated (\Job
26") opposite, starting low priority moving fairly steadily toward
high priority.
following section discusses characteristics SWO make effective technique optimization. discuss implementations SWO scheduling
graph coloring problems. final sections discuss related work, describe directions
future research, summarize findings.

2. Key ideas

experimental results show, SWO general approach optimization.
section, explore insights makes SWO effective.
useful think SWO searching two coupled spaces, illustrated Figure 4.
One search space familiar solution space, priority space. Moves
solution space made indirectly, via re-prioritization results analyzing
prior solution. Similarly, successive prioritizations generated constructing
analyzing solution, using blame results analysis modify
previous prioritization.
point solution space represents potential solution problem,
corresponding point priority space, derived analyzing solution, attempt
capture information structure search space vicinity solution.
SWO constructs new solution scratch, priorities thought providing
356

fi\Squeaky Wheel" Optimization

Construct

p
Analyze/
Prioritize

p



Construct


Priority space
Solution space

Figure 4: Coupled search spaces
information pitfalls common current region solution space. elements solution tended sources diculty number iterations,
increasing priority makes likely constructor handle elements
good way.
One consequence coupled search spaces small change sequence
elements generated prioritizer may correspond large change corresponding
solution generated constructor, compared solution previous iteration. Moving element forward sequence significantly change state
resulting solution. addition, elements occur sequence must
accommodate element's state. example, scheduling domain, moving task
earlier priority sequence may allow placed different manufacturing line,
thus possibly changing mix jobs run line, line
scheduled previous iteration. One small change consequences
element follows it, lower-priority tasks \fill gaps" left
higher-priority tasks scheduled.
result large move \coherent" sense similar
might expect moving higher priority task, propagating effects
change moving lower priority tasks needed. single move may correspond
large number moves search algorithm looks local changes solution,
may thus dicult algorithm find.
fact SWO makes large moves search spaces one obvious difference
SWO traditional local search techniques, WSAT (Selman, Kautz, & Cohen,
1993). Another difference SWO, moves never selected based effect
objective function. Instead, unlike hillclimbing techniques, move made
response \trouble spots" found current solution. resulting move may
uphill, move always motivated trouble spots.
357

fiJoslin & Clements

priority space \local optima" elements solution
assigned equal blame. SWO tends avoid getting trapped local optima, analysis
prioritization always (in practice) suggest changes sequence, thus changing
solution generated next iteration. guarantee SWO
become trapped small cycle, however. implementations introduced
small amounts randomness basic cycle. restart SWO periodically
new initial sequence.
Another aspect local search typically point solution space associated single value, objective function score solution. talk
hillclimbing, generally refer \terrain" described objective function score,
space solutions. process analysis SWO thought synthesizing
complex description terrain, breaking solution component
elements assigning score each. Prioritization translates analysis
\strategy" constructor use generate next solution.
Assigning scores individual elements solution allows SWO take advantage
fact real problems often combine elements dicult get right,
plus others easy. scheduling problems presented below, tasks
assigned production lines, others allow much exibility.
due dates close release time, others lot leeway. sometimes
possible identify \dicult" elements problem static analysis, interactions
complex, elements causing diculty one part search space may
trouble another. Rather trying identify elements globally
dicult analyzing entire problem, SWO analyzes individual solutions order find
elements locally dicult. Globally dicult elements tend identified time,
dicult across large parts search space.
assigning blame adjusting priorities based identified problems actual solutions, SWO avoids dependence complex, domain dependent heuristics. belief
independence particularly important complex domains even best
heuristics miss key interactions therefore inhibit search exploring
good areas heuristic incorrectly labels unpromising. SWO uses actual solutions
discover areas search space promising not.

3. SWO scheduling
section describes application SWO fiber-optic production line scheduling
problem, derived data provided Lucent Technologies. particular plant,
cable may assembled one 13 parallel production lines. cable type,
subset production lines compatible, time required produce
cable depend compatible lines selected. cable setup
time, depends cable type predecessor. Setups
certain pairs cable types infeasible. Task preemption allowed, i.e. cable
started processing line, finishes without interruption.
cable assigned release time due date. Production cannot begin
release time. objective function includes penalty missing due dates, penalty
setup times.
358

fi\Squeaky Wheel" Optimization

3.1 Implementation

describe implementation terms three main components SWO:

Constructor. constructor builds schedule adding tasks one time,

order occur priority sequence. task added selecting line
position relative tasks already line. task may inserted
two tasks already line beginning end line's schedule.
Changes relative positions tasks already line considered.
task line assigned earliest possible start time, subject
ordering, i.e., task starts either release time, immediately previous
task line, whichever greater.
possible insertion points schedule, relative tasks already
line, constructor calculates effect objective function, task
placed best-scoring location. Ties broken randomly. tasks
placed, constructor applies SWO individual line schedules, attempting
improve score line reordering cables assigned it.

Analyzer. assign blame task current schedule, analyzer first calculates

lower bound minimum possible cost task could contribute
schedule. example, task release time later due date,
late every schedule, minimum possible cost already includes
penalty. Minimum possible setup costs included. given schedule,
blame assigned task \excess cost," difference actual
cost minimum possible cost. Excess lateness costs assigned tasks
late, excess setup costs split adjacent tasks.

Prioritizer. blame assigned, prioritizer modifies previous sequence tasks moving tasks non-zero blame factors forward sequence.
Tasks moved forward distance increases magnitude blame.
move back sequence front, task must high blame
factor several iterations. call \sticky sort."

current implementation considerable room improvement. analysis
feedback currently used simple, construction schedules could take
various heuristics account, preferring place task line
\slack," things equal.

3.2 Experimental results

six sets test data, ranging size 40 297 tasks, 13 parallel
production lines. largest problem largest manufacturer required
practice. compare following solution methods:
SWO

Applies SWO architecture problem, running fixed number iterations
returning best schedule finds.
359

fiJoslin & Clements

Data
Set
40
50
60
70
148
297

Best
Obj
1890
3101
2580
2713
8869
17503

SWO

Avg
Obj
1890
3156
2584
2727
8927
17696

Avg
Time
48
57
87
124
431
1300

TABU

Obj
1911
3292
2837
2878
10421
|

Time
425
732
1325
2046
17260
|

IP

Obj
1934
3221
2729
2897
|
|

Time
20
175
6144
4950
|
|

Table 1: Experimental results: scheduling
TABU

IP

Uses TABU search (Glover & Laguna, 1997), local search algorithm moves
increase cost permitted avoid getting trapped local optima. avoid
cycling, \uphill" move made, allowed immediately undone.

Applies Integer Programming (IP) solver, using encoding described (?).

297 task problem, SWO far effective either TABU IP. TABU,
example, failed find feasible schedule running 24 hours.
smallest problems, TABU IP able find solutions, SWO outperformed
substantial margin.
Table 1 presents results problem SWO, TABU IP. SWO, ten trials
run results averaged. TABU IP implementations deterministic,
results single run shown. second column table shows best
objective function value ever observed problem. remaining columns
show objective function value running times SWO, TABU IP. IP
experiments run Sun Sparcstation 10 Model 50. IP experiments run
IBM RS6000 Model 590 (a faster machine).
best values observed result combining SWO IP, reported
(?). work, SWO generated solutions, running produced number
\good" schedules. IP solver invoked re-combine elements solutions
better solution. Although improvements achieved IP solver relatively
small, order 1.5%, achieved improvement quickly, SWO unable
achieve degree optimization even given substantially time.
noting hybrid approach effective SWO alone, much
effective IP alone, focus performance individual techniques.
note first, fairly naive implementation SWO scheduling
problems already outperformed TABU IP. Moreover, improved implementation,
reported above, still fairly simple, successful without relying domain-dependent
heuristics. take evidence effectiveness approach due
cleverness construction, analysis prioritization techniques, due
effectiveness SWO cycle identifying responding whatever elements
problem happen causing diculty local region search.
360

fi\Squeaky Wheel" Optimization

10

# lines job position run

8
6
4
2
0

0

2

4

6

0

2

4

6

8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38
Position priority sequence
Order based # lines job run

10
8
6
4
2
0

8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38
Position priority sequence
Order 14th iteration, producing solution 0.05% best known

Figure 5: Comparison heuristic priorities priorities derived SWO
instructive compare results good heuristic ordering, sequence derived SWO. good heuristic scheduling domain (and one used
initially populate priority sequence) sort tasks number production
lines task could feasibly assigned empty schedule. task
scheduled many lines likely easier schedule one compatible
small number lines, therefore expected need lower priority.
top graph Figure 5 shows sequence tasks, determined heuristic.
lower graph illustrates changes priority tasks, SWO run fourteen
iterations (enough improve solution derived sequence within 0.05 percent
best known solution).
figure illustrates, heuristic generally accurate, SWO move
tasks compatible production lines positions relatively
high priority, ecting fact contrary heuristic, tasks turned
relatively dicult schedule well. tasks compatible production lines actually easy schedule well, moved relatively low priorities.

3.3 Restarts
SWO solver used produce results reported Table 1 restarted priority
queue every n=2 iterations, n number jobs problem. noisy
heuristic used initially populate priority queue used restart
it. restart cutoff picked rather ad hoc manner. careful analysis
361

fiJoslin & Clements

Iterations
Feasible
< 18000
< 17700
per Success Mean Success Mean Success
Mean Sample
Restart
Rate Cost
Rate Cost
Rate
Cost
Size
10 0.8542
5.9 0.0504 195.3 0.0002 49994.5 10000
20 0.9722
6.0 0.2052 90.9 0.0006 33328.3
5000
30 0.9955
5.8 0.3812 67.5 0.0030 9895.5
3300
40 0.9996
5.8 0.5488 56.7 0.0060 6658.2
2500
50 0.9995
6.0 0.6330 57.0 0.0160 3112.7
2000
60 1.0000
5.7 0.7242 52.9 0.0188 3170.4
1650
70 1.0000
5.7 0.8079 50.2 0.0350 1973.5
1400
80 1.0000
6.2 0.8552 49.5 0.0296 2670.0
1250
90 1.0000
5.8 0.8827 48.9 0.0300 2965.3
1100
100 1.0000
5.9 0.8840 52.4 0.0400 2452.3
1000
200 1.0000
6.0 0.9680 53.0 0.0600 3204.3
500
300 1.0000
5.3 0.9967 50.1 0.0567 5090.8
300
400 1.0000
5.8 1.0000 52.9 0.0720 5320.2
250
500 1.0000
5.8 1.0000 52.8 0.1000 4692.6
200
600 1.0000
5.8 1.0000 57.2 0.0867 6590.8
150
700 1.0000
6.1 1.0000 42.4 0.1200 5472.4
100
800 1.0000
5.6 1.0000 53.0 0.1200 6210.3
100
900 1.0000
5.3 1.0000 45.8 0.1700 4691.6
100
1000 1.0000
6.0 1.0000 45.4 0.1800 4838.1
100

Table 2: Experimental results: restarts scheduling domain
different restart cutoff values might lead producing better solutions faster,
additional insight workings SWO.
Restarts often used non-systematic search avoid getting trapped local optima
cycles. (See Parkes Walser, 1996, empirical study WSAT
references.) Restarts used systematic search escape exponentially large
regions search space contain solution (Gomes, Selman, & Kautz, 1998).
Local optima pose little threat SWO, since directly driven uphill/downhill
considerations. SWO, use large coherent moves, tends escape unpromising parts search space quickly. However, SWO open getting trapped cycle,
restarts used means escape them.
scheduling problems, SWO unlikely get tight cycle priority
queues solutions repeat exactly. due presence random tie breaking
several places, presence noise prioritizer. However, belief
SWO get trapped cycle similar priority queues solutions repeat.
ran series experiments 297 task problem determine impact
various restart cutoffs. results summarized Table 2. Restart cutoffs ranged
every 10 iterations every 1000 iterations. success rate mean cost
shown value three different solution qualities. success rate indicates
probability solution least given quality found given pass.
mean cost average number total iterations get solution quality.
feasible 18000 solution thresholds, SWO reaches 100 percent success rate
well reaching maximum restart cutoff 1000 used experiments.
sense, easy SWO produce solutions least qualities. results
362

fi\Squeaky Wheel" Optimization

2 thresholds indicate easy SWO solve problem, cutoff
greater average number uninterrupted iterations takes produce solution
used solve problem minimum cost. \easy" problems, appears
small restart cutoff hurt, big cutoff not.
numbers 17700 solution quality threshold, tell different story. success
rate still climbing experiment ends, mean cost actually risen
minimum. solution quality, restart cutoff minimizes mean cost falls
around range 70 100. Mean costs rise steeply restart cutoffs range,
slowly cutoffs larger that. example hard problem SWO,
shows care needs taken choosing restart strategy problems.
Additional research needed determine set restart cutoff automatically
arbitrary problems.
data indicates SWO benefit restarts, point. 17700
threshold, restart cutoffs 100, increase cutoff general led
superlinear increase success rate. (This another indicator SWO learning
iteration iteration.) 100 iterations per restart, success rate initially
climbs sublinearly appears level out. open question tells us
search space.

4. SWO graph coloring
applied SWO different domain, graph coloring. objective
color nodes graph two adjoining nodes color,
minimizing number colors.

4.1 Implementation

priority sequence graph coloring consists ordered list nodes. solver
always trying produce coloring uses colors target set, one less
color used color best solution far. Again, describe implementation
terms three main components SWO:

Constructor. constructor assigns colors nodes priority sequence order.

node's color previous solution still available (i.e. adjacent node using
yet), target set, color assigned. fails, tries
assign color current target set, picking color least constraining
adjacent uncolored nodes, i.e. color reduces adjacent nodes' remaining
color choices least. none target colors available, constructor tries
\grab" color target set neighbors. color grabbed
neighbor nodes color least one choice within target
set. multiple colors grabbed, least constraining one picked.
color target set grabbed color outside target set assigned.
Nodes early priority sequence likely wide range
colors pick from. Nodes come later may grab colors earlier nodes,
earlier nodes color options within target set.
363

fiJoslin & Clements

SWO
IG
Dist. impasse
Par. impasse
TABU
Problem
colors
time colors
time colors
time colors
time colors
time
DSJC125.5
18.3
1.6 18.9
2.5 17.0
6.3 17.0 4043.6 20.0 153.3
DSJC250.5
31.9
8.3 32.8
6.9 28.0
268.5 29.2 4358.1 35.0 3442.2
DSJC500.5
56.3
40.9 58.6
18.2 49.0 8109.1 53.0 4783.9 65.0 3442.2
DSJC1000.5 101.5 208.6 104.2
67.6 89.0 41488.7 100.0 5333.8 117.0 3442.2
C2000.5
185.7 1046.2 190.0 272.4 165.0 14097.9
|
|
|
|
C4000.5
341.6 4950.8
346.9 1054.1
|
|
|
|
|
|
R125.1
5.0
0.2
5.0
2.0
5.0
0.2
5.0
64.6
5.0
0.4
R125.1c
46.0
5.1 46.0
1.1 46.0
0.2 46.0
85.0 46.0
0.9
R125.5
36.0
2.8 36.9
1.9 36.0
0.2 37.0
33.0 36.0
0.7
R250.1
8.0
0.5
8.0
7.0
8.0
0.2
8.0
22.0
8.0
0.2
R250.1c
64.0
30.6 64.0
4.6 64.0
0.5 64.0 278.2 65.0
46.4
R250.5
65.0
14.7 68.4
8.3 65.0
82.2 66.0
39.9 66.0
59.0
DSJR500.1
12.0
2.0 12.0
21.1 12.0
0.2 12.0
26.6 12.0
0.5
DSJR500.1c
85.2
96.9 85.0
14.6 85.0
59.1 85.2 5767.7 87.0 3442.2
DSJR500.5
124.1
68.7 129.6
26.1 123.0
175.3 128.0
90.5 126.0 395.1
R1000.1
20.0
8.0 20.6
87.2 20.0
8.2 20.0
49.9 20.0
1.7
R1000.1c
101.7 433.2 98.8
49.1 98.0
563.3 102.6 3940.0 105.0 3442.2
R1000.5
238.9
574.5 253.2 102.9 241.0
944.0 245.6 215.9 248.0 3442.2
at300 20 0
25.3
16.4 20.2
3.8 20.0
0.2 20.0 274.3 39.0 3442.2
at300 26 0
35.8
12.0 37.1
7.7 26.0
10.0 32.4 6637.1 41.0 3442.2
at300 28 0
35.7
11.9 37.0
9.6 31.0 1914.2 33.0 1913.5 41.0 3442.2
at1000 50 0 100.0 203.9 65.6 146.3 50.0
0.2 97.0 7792.7
|
|
at1000 60 0 100.7 198.0 102.5
87.3 60.0
0.2 97.8 6288.4
|
|
at1000 76 0 100.6 208.4 103.6
79.6 89.0 11034.0 99.0 6497.9
|
|
latin sqr 10
111.5 369.2 106.7
59.7 98.0 5098.0 109.2 6520.1 130.0 3442.2
le450 15a
15.0
5.5 17.9
17.0 15.0
0.2 15.0 162.6 16.0
17.8
le450 15b
15.0
6.1 17.9
16.2 15.0
0.2 15.0 178.4 15.0
28.4
le450 15c
21.1
8.0 25.6
14.5 15.0
57.2 16.6 2229.6 23.0 3442.2
le450 15d
21.2
7.8 25.8
13.5 15.0
36.3 16.8 2859.6 23.0 3442.2
mulsol.i.1
49.0
5.9 49.0
4.2 49.0
0.2 49.0
27.2 49.0
0.3
school1
14.0
8.4 14.0
10.5 14.0
0.2 14.0
46.3 29.0
90.7
school1 nsh
14.0
7.2 14.1
8.9 14.0
0.2 14.0
66.4 26.0
31.2

Table 3: Experimental results: graph coloring problems

Analyzer. Blame assigned node whose assigned color outside target set,
amount blame increasing additional color must added
target set. ran experiments several different variations color-based
analysis. performed reasonably.

Prioritizer. prioritizer modifies previous sequence nodes moving nodes
blame forward sequence according much blame received.
done way done scheduling problems. initial sequence list
nodes sorted decreasing degree order, noise added slightly shue
sort.
364

fi\Squeaky Wheel" Optimization

4.2 Experimental results
applied SWO standard set graph coloring problems, including random graphs
application graphs model register allocation class scheduling problems.
collected Second DIMACS Implementation Challenge (Johnson & Trick, 1996),
includes results several algorithms problems (Culberson & Luo, 1993; Glover,
Parker, & Ryan, 1993; Lewandowski & Condon, 1993; Morgenstern, 1993). Problems range
125 nodes 209 edges 4000 nodes 4,000,268 edges.
Glover et al. (1993) paper based general search technique, TABU
branch bound, rather graph coloring specific algorithm. approach
worst reported average results group. Morgenstern (1993) used distributed
IMPASSE algorithm best overall colorings, required target
number colors, well several problem specific parameters passed
solver. Lewandowski & Condon (1993) found good solutions problem set.
approach used hybrid parallel IMPASSE systematic search 32 processor
CM-5. Culberson & Luo (1993) used Iterated Greedy (IG) algorithm bears
similarity SWO. IG simplest algorithm group. solution quality falls
IMPASSE algorithms TABU solves entire set 1 2 percent time
taken methods. IG IMPASSE discussed related
work.
Table 3 compares SWO results IG (Culberson & Luo, 1993), distributed
IMPASSE (Morgenstern, 1993), parallel IMPASSE (Lewandowski & Condon, 1993), TABU
(Glover et al., 1993). each, one column shows number colors required
problem, run time (in CPU seconds). Bold face indicates number colors
within 0.5 best result table.
used Pentium Pro 333MHz workstation running Linux SWO graph coloring
experiments. times shown four algorithms based reported
(Johnson & Trick, 1996). results IG, IMPASSE TABU normalized times
using DIMACS benchmarking program dfmax, provided purpose. Therefore,
timing comparisons approximate. machine ran dfmax r500.5 benchmark
86.0 seconds; times reported machines used algorithms
86.9 seconds TABU experiments, 192.6 seconds IG, 189.3 seconds IMPASSE,
2993.6 seconds parallel IMPASSE. dfmax benchmark runs single
processor, unsuitable normalizing times parallel IMPASSE. report
unnormalized times.
variety termination conditions used. SWO terminated 1000 iterations.
IG terminated 1000 iterations without improvement. Distributed IMPASSE used
wide variety different termination conditions solve different problems.
common element across problems distributed IMPASSE stopped target
number colors, provided input parameter, reached. times reported
parallel IMPASSE times took find best solution found, time
took algorithm terminate, always 3 hours. TABU ran algorithm
determined could make progress, hour passed, whichever came
first.
365

fiJoslin & Clements

25
TABU

Avg. percent best group

20

15
Iterated Greedy

10
Squeaky Wheel

5

Par IMPASSE

Dist IMPASSE
0
0

10000

20000

30000
Time (CPU seconds)

40000

50000

60000

Figure 6: Experimental results: quality solution vs. time
TABU numbers single run problem. numbers
algorithms averages 4 runs (parallel IMPASSE), 5 runs (distributed IMPASSE, parallel
IMPASSE) 10 runs (SWO, IG, distributed IMPASSE) problem.
Figure 6 summarizes performance technique set 27 problems
algorithms solved. solver graph indicates average solution quality
average amount time needed solve set. ideal location graph
origin, producing high quality solutions little time. points shown
techniques points reported papers. curve shown SWO
shows performs given varying amounts time solve set. graph
shows, SWO clearly outperforms TABU, general purpose technique,
terms quality speed. SWO outperforms IG, graph coloring specific algorithm,
terms quality speed. IMPASSE solvers clearly produce best solutions
group. However, IMPASSE domain specific method, solvers represent
much programming effort. SWO solver uses general purpose search technique
implemented less month single programmer.

4.3 Alternate configurations SWO
note that, scheduling work, first, naive implementation SWO graph
coloring produced respectable results. Even without color reuse, color grabbing, least
constraining heuristic (the first free color found picked), SWO matched IG 6 problems
beat 10. However, half remaining problems IG better 10
colors.
explore sensitivity SWO implementation details tried following
approaches constructor prioritizer, ran SWO using combinations:
366

fi\Squeaky Wheel" Optimization

Construction: without color grabbing
Analysis: Either blame nodes receive color outside target set,

first node (in priority sequence) causes new color outside target set
introduced. color grabbing used, determination blame based
final color assigned node.

difference solution quality worst combination best combination
less 15 percent. Even alternative using standard sort instead
\sticky" sort (a fairly fundamental change) added mix, spread
worst best still 20 percent.

5. Related work

importance prioritization greedy algorithms new idea. \First Fit"
algorithm bin packing, example, relies placing items bins decreasing order
size (Garey & Johnson, 1979). Another example GRASP (Greedy Randomized Adaptive
Search Procedure) (Feo & Resende, 1995). GRASP differs approach several ways.
First, prioritization construction aspects closely coupled GRASP.
element added solution constructed, remaining elements reevaluated heuristic. Thus order elements added solution
may depend previous decisions. Second, order elements selected
trial determined heuristic (and randomization), trials independent.
learning iteration iteration GRASP.
Doubleback Optimization (DBO) (Crawford, 1996) extent inspiration
SWO another similar algorithm, Abstract Local Search (ALS) (Crawford, Dalal, &
Walser, 1998). designing SWO, began looking DBO, extremely
successful solving standard type scheduling problem. However, DBO useful
objective minimize makespan, limited types constraints
handle. limitations, began thinking principles behind
DBO, looking effective generalization approach. DBO can, fact, viewed
instance SWO. DBO begins performing \right shift" schedule, shifting
tasks far right go, boundary. resulting right-shifted
schedule, left-most tasks are, extent, tasks critical.
corresponds analysis SWO. Tasks removed right-shifted schedule,
taking left-most tasks first. ordering corresponds prioritization SWO.
task removed, placed new schedule earliest possible start time, i.e., greedy
construction.
SWO, ALS result attempt generalize DBO. ALS views priority space
(to use terminology SWO) space \abstract schedules," performs local
search space. Unlike SWO, prioritization modified, corresponding
move solution space downhill (away optimal), modified prioritization
discarded, old prioritization restored. usual local search, ALS
sometimes makes random moves, order escape local minima.
ALS, List Scheduling (Pinson, Prins, & Rullier, 1994), scheduling algorithms
deal domains include precedence constraints tasks. accommodate
367

fiJoslin & Clements

precedence constraints constructing schedules left-to-right temporally. task cannot
placed schedule predecessors placed. order
analysis, prioritization construction appropriately coupled, sucient
simply increase priority task late, constructor may able
place task lot decisions made. Consequently,
amount blame must propagated task's predecessors.
commercial scheduler OPTIFLEX (Syswerda, 1994) uses genetic algorithm approach
modify sequence tasks, constraint-based schedule constructor generates
schedules sequences. OPTIFLEX viewed instance SWO,
genetic algorithm replacing analysis. effect, \analysis" instead emerges
relative fitness members population.
Two graph coloring algorithms bear similarity SWO. Impasse Class Coloration Neighborhood Search (IMPASSE) (Morgenstern, 1993; Lewandowski & Condon,
1993), SWO, maintains target set colors produces feasible colorings. Given
coloring, IMPASSE places nodes colored outside target set impasse
set. iteration node selected impasse set, using noisy degree-based
heuristic, assigned random color target set. neighbor nodes
con ict moved impasse set.
Iterated Greedy (IG) (Culberson & Luo, 1993), SWO, uses sequence nodes
create new coloring iteration, uses coloring produce new
sequence next iteration. method used generate new sequence differs
SWO. key observation behind IG nodes color
current solution grouped together next sequence (i.e. adjacent
sequence), next solution worse current solution. IG achieves
improvement manipulating order groups occur new sequence,
using several heuristics including random based color, descending based color,
ascending based cardinality group. IG learns groupings nodes runs,
learn diculty nodes. node's place sequence
indicates nothing expected detected diculty.

6. Analysis future work

section summarizes several areas future research suggested results reported
previous sections.

6.1 Scaling

SWO uses fast, greedy algorithms constructing solutions, demonstrated
effectiveness problems realistic size, greatest threat scalability SWO
constructs new solution scratch iteration. partial solution
problem seen use \history" mechanism graph coloring problems. Using
color node previous solution means many cases
need check possible colors. significantly speeds construction.
fundamental solution problem would develop incremental version
SWO. selective reuse colors graph coloring solver small step
direction. allows constructor avoid spending time evaluating alternatives
368

fi\Squeaky Wheel" Optimization

previous choice still works. generally, may possible look
changes made prioritization, modify corresponding solution way
generates solution would constructed scratch based new
prioritization. seems feasible could done domains, least small
changes prioritization, may large portions solution
unaffected.
interesting possibility based view SWO performing local search
plus certain kind propagation. small change priorities may correspond large
change solution. example, increasing priority one task scheduling
problem may change position schedule, and, consequence, lower priority
tasks may shued around accommodate change. similar
might expect moving higher priority task, propagating effects
change moving lower priority tasks well. single move may correspond large
number moves search algorithm looks local changes schedule,
may thus dicult algorithm find.
Based view, investigating algorithm call \Priority-Limited Propagation" (PLP). PLP, local changes made solution, propagation
allowed occur, subject current prioritization. Propagation allowed occur
direction lower-priority elements. effect, small change made,
consequences change allowed \ripple" plan. propagation
occur directions decreasing priority, ripples propagation decrease
magnitude propagation possible. new prioritization generated
analyzing resulting solution. (It possible analysis incrementally,
well.) resulting approach identical SWO, many interesting
characteristics.

6.2 Coordination modules
SWO effective, obvious analysis, prioritization construction must
work together improve quality solutions. already discussed complications arise constraints placed order constructor
make decisions, case List Scheduling ALS, construction done
strictly left-to-right. Without complex analysis, search spaces effectively become uncoupled, changes priority don't cause constructor fix problems
discovered analysis.
Another way search become uncoupled related notion \excess cost,"
discussed scheduling implementation. calculation excess cost analyzer
turned key idea improving performance SWO. However, problems sometimes tasks must handled badly order achieve good overall solution. One
scheduling problems described previously two \sacrificial" tasks. Whenever
good solution found, analyzer assigns high blame sacrificial tasks,
constructor handles well next iteration. means resulting solution
poor overall quality, aws cause tasks move ahead
sacrificial tasks priority sequence SWO again, brie y, explore space
369

fiJoslin & Clements

good solutions. cases, extent analysis actually hurting ability
SWO converge good solutions.
Ideally, would generalize notion excess cost recognize sacrificial
tasks, allow tasks handled badly without receiving proportionate blame.
problems task must sacrificed solutions, may possible use
learning mechanism accomplish this.
However, notion sacrificial task subtle this. Suppose
example scheduling construction two airplanes, P1 P2,
key task, T1 T2, respectively, requiring shared resource, R.
resource con ict, must either give R T1 early schedule, starting
construction plane P1 P2, must give R T2 early schedule,
opposite result. Whichever two tasks started early finish time,
late.
Suppose construct schedule T1 goes first, T2 late, thus receiving
heavy blame factor. SWO increases priority T2, consequence, T2 goes first
subsequent schedule. T1 late, next iteration go
first. could alternate manner forever, result would SWO would
fail explore either option effectively, would jumping back forth
option building plane P1 first, option building plane P2 first,
without remaining one region search space long enough refine solution.
diculty neither T1 T2 identified sacrificial task. Assuming
two planes identical, cannot simply argue symmetry
pick one two tasks sacrificed. If, however, could identify sacrificial
task role plays solution, could achieve need. Here, task
sacrificed must one belongs whichever plane started later. analyzer
could reduce blame assigned task schedule, whichever task happens
be, would allow SWO explore region search much effectively.
problem interchangeable roles would arise even clearly introduction conditional elements solution. Suppose, example, scheduling
problem constructor may choose include include task instances
type, adding however many instances needed satisfy resource requirement.
tasks instances task type, interchangeable,
penalizing one may simply cause shuing instances really address
problem. Moreover, conditional tasks, clear analyzer
assign blame set task instances current schedule may different
set task instances successor schedules.
address concerns, notion prioritization could generalized apply
additional aspects problem. scheduling might mean prioritizing tasks,
resources various time intervals. propose prioritizations
limited \fixed" elements problem. scheduling problems, example,
may non-conditional tasks, resources, etc. (In example domains,
elements fixed sense, issue.)
One intuition behind proposal elements tend define
roles. earlier example tasks T1 T2, corresponding two planes
built, critical element either task per se, actually resource R, early
370

fi\Squeaky Wheel" Optimization

schedule. phase resource R receives high priority, later phase resource
R receives lower priority, whichever two tasks occurs later recognized
less critical. exactly capture notion \role" would like,
comes lot closer current approach. addition, assigning priorities fixed
elements problem advantage applicable problems conditional
tasks. Research currently way explore approach.

6.3

SWO

local search

Although ability make large, coherent moves strength approach,
weakness. SWO poor making small \tuning" moves solution space,
coupled-search view SWO suggests obvious remedy. SWO could combined local
search solution space, look improvements vicinity good solutions.
Similarly, making small changes prioritization would generally result smaller moves
solution space result going full analysis re-prioritization
cycle.
Yet another alternative genetic algorithm techniques \crossover" types
mutation pool nodes, done OPTIFLEX. Many hybrid approaches possible, believe coupled-search view SWO helps identify interesting
strategies combining moves various sizes kinds, search spaces, adapting
dynamically relative solution qualities.

7. Conclusions
experience fairly straightforward implement SWO new domain,
usually fairly obvious ways construct greedy solutions, analyze
solution assign \blame" elements. Naive implementations SWO tend
perform reasonably well.
found view SWO performing \coupled search" two different
search spaces informative. helpful characterize kinds moves
SWO makes search spaces, effect avoiding local optima,
etc. hope continuing gain deeper understanding makes SWO work
able say effective design SWO algorithms.
number directions future research suggests, begun scratch
surface \Squeaky Wheel" Optimization.

Acknowledgments
authors wish thank Robert Stubbs Lucent Technologies providing data
used scheduling experiments. authors wish thank George L. Nemhauser,
Markus E. Puttlitz Martin W. P. Savelsbergh collaborated using SWO
hybrid AI/OR approach. Many useful discussions came collaboration,
without would access Lucent problems. Markus wrote
framework scheduling experiments TABU IP implementations.
371

fiJoslin & Clements

authors thank members CIRL, James Crawford i2 Technologies,
helpful comments suggestions. would thank Andrew Parkes
particular suggestions insights graph coloring domain.
effort sponsored Air Force Oce Scientific Research, Air Force Materiel Command, USAF, grant number F49620-96-1-0335; Defense Advanced
Research Projects Agency (DARPA) Rome Laboratory, Air Force Materiel Command,
USAF, agreements F30602-95-1-0023 F30602-97-1-0294; National
Science Foundation grant number CDA-9625755.
U.S. Government authorized reproduce distribute reprints Governmental purposes notwithstanding copyright annotation thereon. views conclusions
contained herein authors interpreted necessarily representing ocial policies endorsements, either expressed implied, Defense
Advanced Research Projects Agency, Rome Laboratory, Air Force Oce Scientific
Research, National Science Foundation, U.S. Government.
work reported paper done authors CIRL.

References

Crawford, J., Dalal, M., & Walser, J. (1998). Abstract local search. Proceedings
AIPS-98 Workshop Planning Combinatorial Search. conjunction
Fourth International Conference Artificial Intelligence Planning Systems (AIPS98).
Crawford, J. M. (1996). approach resource constrained project scheduling. Proceedings 1996 Artificial Intelligence Manufacturing Research Planning Workshop, pp. 35{39.
Culberson, J. C., & Luo, F. (1993). Exploring k{colorable landscape iterated
greedy. (Johnson & Trick, 1996), pp. 245{284.
Feo, T. A., & Resende, M. G. (1995). Greedy randomized adaptive search procedures.
Journal Global Optimization, 6, 109{133.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide
Theory NP-Completeness. W. H. Freeman.
Glover, F., & Laguna, M. (1997). Tabu Search. Kluwer.
Glover, F., Parker, M., & Ryan, J. (1993). Coloring tabu branch bound. (Johnson
& Trick, 1996), pp. 285{307.
Gomes, C., Selman, B., & Kautz, H. (1998). Boosting combinatorial search randomization. Proceedings AAAI-98, pp. 431{437.
Johnson, D. S., & Trick, M. A. (Eds.). (1996). Cliques, Coloring, Satisfiability: Second
DIMACS Implementation Challenge, 1996, Vol. 26 DIMACS Series Discrete
Mathematics Theoretical Computer Science. American Mathematical Society.
372

fi\Squeaky Wheel" Optimization

Joslin, D., & Clements, D. (1998). \Squeaky wheel" optimization. Proceedings AAAI98, pp. 340{346.
Lewandowski, G., & Condon, A. (1993). Experiments parallel graph coloring heuristics
applications graph coloring. (Johnson & Trick, 1996), pp. 309{334.
Morgenstern, C. (1993). Distributed coloration neighborhood search. (Johnson & Trick,
1996), pp. 335{357.
Parkes, A., & Walser, J. (1996). Tuning local search satisfiability testing. Proceedings
AAAI-96, pp. 356{362.
Pinson, E., Prins, C., & Rullier, F. (1994). Using tabu search solving resourceconstrained project scheduling problem. EURO-WG PMS 4 (EURO Working
Group Project Management Scheduling), pp. 102{106 Louvain, Belgium.
Selman, B., Kautz, H. A., & Cohen, B. (1993). Local search strategies satisfiability
testing. (Johnson & Trick, 1996), pp. 521{531.
Syswerda, G. P. (1994). Generation schedules using genetic procedure.. U.S. Patent
number 5,319,781.

373


