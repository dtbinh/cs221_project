journal artificial intelligence

submitted published

order magnitude comparisons distance
ernest davis

davise cs nyu edu

courant institute
york ny usa

abstract
order magnitude reasoning reasoning rough comparisons sizes quantities often called back envelope calculation implication
calculations quick though approximate exhibits interesting class constraint sets order magnitude reasoning demonstrably fast specifically
present polynomial time solve set constraints form points
b much closer together points c prove
applied much closer together interpreted referring infinite difference
scale referring finite difference scale long difference scale greater
number variables constraint set prove first order theory
constraints decidable
introduction
order magnitude reasoning reasoning rough comparisons sizes quantities
often called back envelope calculation implication calculations
quick though approximate previous ai work order magnitude reasoning however
focussed expressive power inferential structure computational
leverage raiman mavrovouniotis stephanopoulos davis weld

exhibit interesting case solving set order magnitude
comparisons demonstrably much faster solving analogous set simple order
comparisons specifically given set constraints form points b much
closer together points c consistency set determined
low order polynomial time contrast easily shown solving set constraints
form distance b less equal distance c
one dimension np complete higher dimensions hard solving arbitrary
set algebraic constraints reals
particular presents following
solve constraints solves system constraints form points
b infinitely closer points c polynomial time section
improved version runs time max n n ne n
number variables n inverse ackermann function e number
edges mentioned constraint set size constraint set section

extended version allows inclusion non strict constraints
form points b infinitely apart points c
c ai access foundation morgan kaufmann publishers rights reserved

fidavis

running time modified slower solve constraints
still polynomial time section
different extension allows combination order magnitude
constraints distances order comparisons points form point
precedes point b section
applied constraints form distance
b less b times distance c b given finite value
long b greater number variables constraint set section
first order theory constraints decidable section
preliminary steps begin small example informal discussion section
give formal account order magnitude spaces section present
data structure called cluster tree expresses order magnitude distance comparisons section conclude discussion significance
section

examples
consider following inferences

example wish buy house rent oce space suburb metropolis
obvious reasons want house close school house close
oce oce close commuter train station told elmville
train station quite far school newton close together
infer able satisfy constraints elmville may able
newton
example empire state building much closer washington monument
versailles statue liberty much closer empire state building
carnegie hall washington monument
infer carnegie hall much closer empire state building versailles
example carry collection computational tasks covering wide
range diculty instance

b
c

e
f

add column numbers
sort list elements
invert matrix
invert matrix
given e x cos et x x x bit accuracy
given online collection photographs gif format use state ofthe art image recognition software select man
horseback



fiorder magnitude comparisons distance

g web search collected pictures men horseback
state art image recognition software
h state art theorem proving software proof medians triangle concurrent
state art theorem proving software proof fermat
little theorem
plausible suppose many cases say reliably one
task take much longer another human judgment expert
system instance task much shorter others task b much
shorter others except possibly h task c certainly much
shorter f g however certain pairs c h c
e would dicult guess whether one much shorter another whether
comparable diculty
number independent identical computers unknown vintage characteristics schedule tasks kinds note circumstances way predict absolute time required tasks within
couple orders magnitude nonetheless comparative lengths presumably still stand
given particular schedule tasks machines infer relative
order completion times example given following schedule
machine tasks b h
machine tasks c
possible predict b complete c c
complete complete possible
predict order c h complete
three examples given information form distance points
w x much less distance z examples
points geometric example points start completion times
tasks constraints relative lengths put form distance
start end much less distance start c end c
example ordering information start task precedes end
end equal start b make inferences
weak kind constraint
noted examples meant illustrative rather serious applications example extend obvious way class natural
large example implausible state knowledge reasoner
knowing order magnitude relations among distances
geometric information example contrived nonetheless illustrate kinds
situations order magnitude relations distance arise express
substantial part knowledge reasoner inferences purely
order magnitude comparisons yield useful conclusions
methods presented involve construing relation distance much
shorter distance e distance infinitesimal compared distance
e shall see interpretation systems constraints distances



fidavis

solved eciently logical foundations dealing infinitesimal quantities lie
non standard model real line infinitesimals developed abraham robinson
readable account given keisler reasoning quantities
infinitely different scale known order magnitude reasoning
reader may ask since infinitesimals physical reality value
developing techniques reasoning none examples
smaller quantity truly infinitesimal larger one truly infinite example
ratio successive sizes somewhere example
rather large number dicult estimate one give
kind upper bound essentially certain instance ratio
times required tasks less use best real valued
estimate instead
first answer idealization practically physical reasoning
calculation rest one idealization another idealization situation calculus
time discrete idealization solid objects rigid employed mechanics programs idealization physical properties density temperature
pressure continuous rather local averages atoms underlies uses
partial differential equations idealization involved use dirac delta function
idealization short distance infinitesimally smaller
long one simplifies reasoning yields useful long care taken stay within
appropriate range application
second answer technique mathematical approximation
turn intractable tractable one would analogous
linearizing non linear equation small neighborhood approximating sum
integral
circumstances sure approximation gives answer
guaranteed exactly correct namely actual ratio implicit comparison
much smaller e larger number points involved system
constraints proven section broader less well defined class
approximation though guaranteed correct reliable
links reasoning instance suppose one consider
instance example involving couple hundred tasks apply order magnitude
reasoning come answer determined wrong possible
error would due order magnitude reasoning however seems safe
say cases error likely due mistake estimating
comparative sizes

order magnitude spaces
order magnitude space om space space geometric points two points
separated distance two distances e compared relation e
meaning distance infinitesimal compared e loosely distance much
smaller e
example let non standard real line infinitesimals let
corresponding dimensional space let point om space point



fiorder magnitude comparisons distance

rm distance two points b euclidean distance non negative
value relation e holds two distances e e infinitesimal
distance operator comparator related number axioms specified
interesting called om triangle inequality ab bc
much smaller xy ac much smaller xy combines ordinary
triangle inequality distance ac less equal distance ab plus distance bc
together rule order magnitude algebra p r q r p q r
simplify exposition rather talking distances talk
orders magnitude defined follows say two distances e
order magnitude neither e e condition e
finite neither infinitesimal infinite raiman uses notation co e
relation rules order magnitude calculus equivalence relation
hence define order magnitude equivalence class distances
relation order magnitude two points b define function od b
order magnitude distance b two orders magnitude p q
define p q representatives p e q e rules orderof magnitude calculus holds representatives holds representatives
advantage orders magnitude function od rather distances
distance function allows us deal logical equality rather
equivalence relation order magnitude
example non standard real line let positive infinitesimal value
values f g order magnitude
values f e g different order magnitude values
f g third order magnitude
definition order magnitude space om space
consists







set points p
set orders magnitude
distinguished value
function od b mapping two points b p order magnitude
relation e two orders magnitude e

satisfying following axioms
orders magnitude e
e e

exactly one following holds e

e f e e f f
transitivity together means total ordering orders
magnitude

minimal order magnitude



fidavis

points b p od b b
function od positive definite
points b p od b od b
function od symmetric
points b c p order magnitude
od b od b c od c
om triangle inequality
infinitely many different orders magnitude
point p order magnitude
od ai aj j

exists infinite set

example given om space non standard euclidean space wild
woolly hard conceptualize two simpler examples om spaces
let infinitesimal value define point polynomial integer
coecients define order magnitude power
define n n example define od b smallest power
b example od
ii let n infinite value define point polynomial n integer
coecients define order magnitude power n define n p n q
p q example n n define od b largest power n b
example od n n n n n
shown om space contains subset isomorphic subset
isomorphic ii special case general rule infinite total
ordering contains infinite descending chain infinite ascending chain
use notation de abbreviation e e

cluster trees
let p finite set points om space distances different pairs
points p different orders magnitude om space imposes unique treelike hierarchical structure p points naturally fall clusters cluster c
collection points much closer one another point
p outside c collection clusters p forms strict tree subset
relation moreover structure tree comparative sizes different clusters
tree captures order magnitude relations pair points p
tree clusters thus powerful data structure reasoning points
om space indeed central data structure develop
section give formal definition cluster trees prove basic
foundations

definition let p finite set points om space non empty subset c p
called cluster p every x c z p c od x od x z c cluster
diameter c denoted odiam c maximum value od x x c



fiorder magnitude comparisons distance

n

n

n





n

n













e

g

f

b

c











figure cluster tree
note set single element p trivially cluster p entire set p
likewise cluster p empty set definition cluster p

lemma c clusters p c
disjoint

c c

proof suppose let x c c z c since c cluster
od x od x z since cluster od x z od x thus contradiction



virtue lemma clusters set p form tree develop representation order magnitude relations p constructing tree whose nodes correspond
clusters p labelled indication relative size cluster

definition cluster tree tree

every leaf distinct symbol
every internal node least two children
internal node labelled non negative value two nodes
may given value purposes sections labels may taken
non negative integers section useful allow rational labels

every leaf tree labelled
label every internal node tree less label parent
node n field n symbols gives set symbols leaves
subtree rooted n field n label gives integer label node n



fidavis

thus example figure n label n symbols fa dg n label
n symbols fa b c e f gg
shall see nodes tree represent clusters set points
labels represent relative sizes diameters clusters

definition valuation set symbols function mapping symbol
point om space cluster tree valuation valuation symbols
n node valuation write n abbreviation
n symbols
define cluster tree expresses order magnitude relations
set points p
definition let cluster tree let valuation let p
set points image say j read satisfies instantiates
following conditions hold
internal node n n cluster p
ii cluster c p node n c n
iii nodes n label n label odiam odiam n
iv label odiam children assigned
value
following generates instantiation
procedure

variable

given cluster tree

instantiate cluster tree
om space
return array points indexed symbols

g n array points indexed nodes

let k number internal nodes
choose k k different orders magnitude
values chosen virtue axiom
pick point x

g root x
instantiate
k g
return restriction g symbols
end instantiate
instantiate n node cluster tree
om space k orders magnitude
g array points indexed nodes
n leaf
let c cp children n
x g n
q n label
pick points x xp
j p j od xi xj q
points chosen virtue axiom


fiorder magnitude comparisons distance



p
g ci xi

instantiate ci
k g

endfor
endif end

instantiate

thus begin picking orders magnitude corresponding values labels
pick arbitrary point root tree recurse nodes
tree node n place children points lie separated desired
diameter n final placement leaves desired instantiation
lemma cluster tree
om space instantiate
returns
instantiation
proof given appendix
moreover clear instantiation generated possible output
instantiate
given instantiation pick g n stage
symbol n
note given valuation finite set symbols exists cluster
tree symbols satisfies essentially unique
isomorphism set labels preserves label order labels

constraints
section develop first solve constraints tests
collection constraints form much closer b c consistency set consistent returns cluster tree satisfies
constraints builds cluster tree top bottom dealing first
large distances proceeding smaller smaller distances
let system constraints form od b od c let cluster
tree say read satisfies every instantiation satisfies
section develop finding cluster tree satisfies given set
constraints
works along following lines suppose solution satisfying
let diameter solution contains constraint od b od c
since od c certainly follows od b much smaller
label ab short edge
two points u v connected path short edges triangle
inequality edge uv short e much shorter thus compute
connected components h edges labelled short edges
h likewise labelled short example table edges vz wx xy
labelled short
hand shall prove edge set h
reason believe much shorter fact safely posit
label edges long
assume connected component points connected short edges
cluster child root cluster tree root cluster tree
given largest label children given smaller labels long edge



fidavis

connects symbols two different children root hence instantiation tree
make long edge longer short edge
edges labelled long h contains complete graph
symbols inconsistency edges much shorter longest edge
instance table since vw wx xy much smaller zy follows
triangle inequality vy much smaller zy since
constraints zy much smaller vz vz much smaller vy
inconsistency
iterates next smaller scale since taken care
constraints od b od c cd labelled long drop
let greatest length edges remain constraint
od b od c know od b much shorter
label short continue halts constraints
satisfied therefore empty encounter contradiction

give formal statement uses undirected
graph variable symbols given graph g constraint c
form od b od c refer edge ab short c edge
cd long c shorts system set shorts constraints
longs set longs constraints edge may
short long appears one side one constraint another
constraint
procedure

type

solve constraints system constraints form od b od c
return cluster tree satisfying consistent
false inconsistent

node n cluster tree contains
pointers parent children n
field n label holding integer label
field n symbols holding list symbols leaves n

variables

begin

integer
c constraint
h undirected graphs
n nodes

contains constraint form od b od c c return false

number variables
initialize consist single node n
n symbols variables
repeat

h connected components shorts
h contains edges return false endif
leaf n
vertices n connected h
n label
connected component n symbols h





fiorder magnitude comparisons distance

construct node child n
symbols vertices

endfor endif endfor

subset constraints whose long h




empty

leaf n
n label
n symbols one symbol
create leaf n symbol n symbols
label leaf
endif endfor end solve constraints

tables give two examples working procedure solve constraints table
shows procedure used establish following constraints
consistent
empire state building x much closer washington monument w
notre dame cathedral v
bunker hill much closer empire state building eiffel
tower z
distance eiffel tower notre dame much less distance
washington monument bunker hill
table shows following inference justified

given distances statue liberty v world trade center
w world trade center empire state building x
empire state building chrysler building much less
distance chrysler building washington monument z
infer washington monument much nearer chrysler building
statue liberty
inference carried asserting negation consequent washington monument much nearer chrysler building statue liberty
showing collection constraints inconsistent note change much
less much nearer example less nearer inference longer
valid
theorem states correctness solve constraints proof given
appendix
theorem solve constraints returns cluster tree satisfying
consistent returns false inconsistent
may many cluster trees satisfy given set constraints among
cluster tree returned solve constraints important property
fewest possible labels consistent constraints words uses
minimum number different orders magnitude solution therefore
used check satisfiability set constraints om space violates



fidavis

contains constraints
od w x od x v
od x od z
od v z od w
proceeds follows
initialization
tree initializes single node n
n symbols f v w x z g
first iteration
shorts f wx xy vz g
computing connected components h set f wx xy wy vz g
n label
two children n created
n symbols w x
n symbols v z
xv h delete constraint
yz h delete constraint
contains constraint
second iteration
shorts f vz g
connected components h fvz g
n label
three children n created
n symbols w
n symbols x
n symbols z
wy h delete constraint
empty
cleanup
n label
two children n created
n symbols v
n symbols z
see figure
table example computing cluster tree



fiorder magnitude comparisons distance

n
th iteration
v w x z

n

st iteration


v w x z
n

n

w x

v z

n
nd iteration

v w x z
n


n
w x
v z

w

x



n
cleanup

v w x z
n


w

x

n
w x





v

figure building cluster tree



v z

z

fidavis

contains constraints
od v w od z
od w x od z
od x od z
od z od v z
proceeds follows
initialization
tree initializes single node n
n symbols f v w x z g
first iteration
shorts f vw wx xy zy vz g
h set connected components complete graph v w x z
exits returning false
table example determining inconsistency
axiom finitely many different orders magnitude returns
different labels number different orders magnitude
space constraints satisfiable uses labels space
orders magnitude constraints unsatisfiable
proof easier present rewrite solve constraints following
form returns number different non zero labels used actually
construct cluster tree

num labels

function

return
else return

empty


num labels reduce constraints
function reduce constraints
h connected components shorts
h contains edges return false top level
else return set constraints whose long h

easily verified sequence values successive recursive calls
num labels sequence values main loop solve constraints
therefore num labels returns number different non zero labels tree constructed
solve constraints
reader may wonder simpler presented complicated
solve constraints reason proof found system constraints consistent num labels return
constructive solve constraints



false

relies relation num labels

fiorder magnitude comparisons distance

theorem solutions set constraints instantiations
solve constraints fewest number different values od b b range
symbols number given num labels
proof given appendix

extensions consequences
next present number modifications solve constraints first
ecient implementation second extends handle non strict
comparisons third extend handle combination order magnitude
comparisons distance order comparisons one dimensional space

ecient implementation solve constraints
possible implement solve constraints somewhat eciently
naive encoding description key observe graph h connected
components computed explicitly suces compute implicitly
merge sets union sets combining suitable back pointers edges
constraints formulate ecient version
use following data structures subroutines

node n cluster tree contains pointers parents children field

n label holding integer label field n symbols holding list symbols
leaves n field n mfsets holding list connected components
symbols n described connected component implemented
merge set mfset

edge e graph symbols contains two endpoints

symbol field e shorts list constraints e appears short
field e longs list constraints e appears long

constraint c two fields c short c long edges

pointers lists c short shorts c long longs enabling c removed
constant time constraint lists associated individual edges

use disjoint set forest implementation mfsets cormen leiserson

rivest p merging smaller sets larger path compression
thus mfset upward pointing tree symbols node tree
symbol tree whole represented symbol root symbol
following fields






parent pointer parent mfset tree
cluster leaf pointer leaf cluster tree containing
root mfset size holds size mfset
root mfset symbols holds elements
mfset



fidavis

root mfset leaf ptr holds pointer pointer
n mfsets n cluster leaf
describe
procedure

variables










begin


























solve constraints system constraints form od b od c
return cluster tree satisfying consistent
false inconsistent
integer
b symbols
c constraint
h undirected graph
e f edges
p mfset
n nodes

contains constraint form od b od c c return false

h

constraint c short e long f
add e f h
add c e shorts f longs endfor
number variables
initialize contain root n
n symbols variables




leaf n initialize mfsets n
edge e ab h
e shorts non empty b
merge b endif endfor
every edge e ab h satisfies b

repeat


return false endif



current leaf n
n mfsets one element
mfset p n mfsets
construct node child n
symbols p symbols
endfor endif endfor

edge e ab h
b
constraint c e longs
delete c
delete c e longs
delete c c short shorts endfor
delete e h endif endfor

empty




leaf n
n label
n symbols one symbol


fiorder magnitude comparisons distance




create leaf n label symbol n symbols
solve constraints


endif endfor end

initialize mfsets n node
symbol
n mfsets
n symbols
parent null
cluster leaf n
symbols fag
size
n mfsets cons n mfsets
leaf ptr n mfsets
endfor end initialize mfsets
procedure
var

merge b symbol
size
size swap b
parent b
b size b size size
b symbols b symbols symbols
leaf ptr delete cluster leaf mfsets
end merge
procedure

b

symbol return symbol
symbol
parent null return
parent
parent r path compression
return r
end
procedure
var r

else r

let n number symbols let e number edges let
number constraints note n e n n e e e
running time solve constraints computed follows iteration
main loop splits least one connected components h
n iterations merge operations loop take together time
max nff n e n inverse ackermann function iteration
inner loop lines creates one node tree therefore
n iterations loop entire lines outer
loop require n iterations iteration main loop loop
executed exactly course entire execution
constraint c hence takes time entire steps
require time e iteration main loop easily verified remaining
operations take time hence overall running time
max n n ne



fidavis

adding non strict comparisons
solve constraints modified deal non strict comparisons
form od b od c intuitively marking edge ab short iteration
edge cd found short
specifically solve constraints make following two changes first
revised takes two parameters set strict constraints w set
non strict constraints second replace line
h connected components shorts

following code







h shorts
repeat h connected components h
weak constraint od b od c
cd h add ab h endif endfor
change made h last iteration

proof revised correct slight extension proof
theorem given appendix
optimizing eciency little involved
operations must included four parameters n
number symbols e number edges mentioned number strict comparison
w number non strict comparisons optimal implementation varies
depending relative sizes particular w though may
much smaller n cases requires special treatment optimal eciency
best implementation found case w
n
running time max n nw details implementation straightforward
sucient interest worth elaborating
immediate consequence couple inference
easily computed

determine whether constraint c consequence set constraints
form set c check consistency c inconsistent sj c
note negation constraint od b od c constraint
od c od b
determine whether two sets constraints logically equivalent check
constraint first consequence second vice versa

adding order constraints
example section involves combination order magnitude constraints distances together simple ordering points points lie one dimensional
line next extend solve constraints deal complex situation



fiorder magnitude comparisons distance

terms axiomatics adding ordering points involves positing
relation p q total ordering ordering points related order
magnitude comparisons distances following axiom
points b c p b c od b od c
following rule easily deduced c disjoint clusters every
point c less points vice versa
extending begin defining ordered cluster tree cluster
tree every internal node n partial order children n
b children n ordered b instantiation tree
every leaf must precede every leaf b procedure instantiate modified
deal ordered cluster trees follows

instantiate n node cluster tree
om space k orders magnitude
g array points indexed nodes
n leaf
let c cp children n topologically sorted order
x g n
q n label
pick points x xp increasing order
j p j od xi xj q
points chosen virtue axiom
p
g ci xi
instantiate ci
k g
endfor
endif end

instantiate

solve constraints modified follows
procedure

fnewg

variables

begin

solve constraints system constraints form od b od c
system constraints form b
return ordered cluster tree satisfying
consistent
false inconsistent
integer
c constraint
h undirected graphs
n p nodes
b c symbols

contains constraint form od b od c c

return false



fnewg internally inconsistent contains cycle return false
number variables
initialize consist single node n
n symbols variables
repeat

h connected component shorts



fidavis

fnewg

h incorporate order h
h contains edges


return false

leaf n
vertices n connected h
n label
connected component n symbols h
construct node child n
symbols vertices
endfor endif

fnewg
fnewg
fnewg
fnewg
fnewg



constraint b
symbols b p symbols
p different children n
add ordering arc p
endif endfor

endfor

subset constraints whose long h




empty

leaf n
n label
n symbols one symbol
create leaf n symbol n symbols
label leaf
endif endfor

end

solve constraints

fnewg

function

incorporate order h undirected graph
system constraints form b
return undirected graph

variables

g directed graph
b vertices h
b connected components h
v array vertices g indexed connected components h
subset vertices g

connected component h create vertex v g
constraint b
let b connected components h containing b respectively
b add arc g v v b endif endfor
strongly connected component g
pair distinct vertices v v b
b b add edge ab h endfor endfor




endfor



fiorder magnitude comparisons distance

end

incorporate order

function incorporate order serves following purpose suppose
midst main loop solve constraints partially constructed cluster tree
currently working finding sub clusters node n original
form solve constraints connected components shorts order ofmagnitude constraints let c cq know diameter ci
much smaller diameter n suppose example
constraints b b c c c c b c c b c
follows axiom c c c must merged single cluster
whose diameter less diameter n procedure incorporate order finds
loops constructing graph g whose vertices connected components h
whose arcs ordering relations computing strongly connected
components g recall two vertices u v directed graph strongly
connected component cycle u v u merges together
connected components h lie single strongly connected component g
proof correctness solve constraints analogous structure proof theorem given appendix
implementing manner section made run
time max n n ne number constraints

finite order magnitude comparison
section demonstrated solve constraints applied systems
constraints form dist b dist c b finite b ordinary euclidean
space long number symbols constraint network smaller b
could sure immediately must apply finite b
fundamental property non standard real line sentence first order
theory reals holds infinite values holds suciently large finite
value sentence holds infinite value holds arbitrarily large
finite values hence since answer given solve constraints works
set constraints constraint od b od c interpreted od b
od c b infinite b answer must valid suciently large finite b
interesting simple characterization b terms namely
b larger number symbols
begin modifying form constraints interpretation cluster
tree first avoid confusion use four place predicate much closer b c
rather form od b od c going give interpretation
od function fix finite value b interpret much closer b c
mean dist b dist c b
next redefine means valuation instantiate cluster tree

definition let cluster tree let valuation symbols say
following holds symbols b c let least common
ancestor b let n least common ancestor c label n label
much closer b c



fidavis

procedure instantiate generates instantiation cluster tree modified
follows
procedure

instantiate cluster tree
euclidean space b real
return array points indexed symbols

let n number nodes
n bn
choose n
pick point x

g x
instantiate
n g
return restriction g symbols
end instantiate
instantiate n node cluster tree
euclidean space
n orders magnitude
g array points indexed nodes
n leaf
let c cp children n
x g n
q n label
pick points x xp
j p j q dist xi xj nq
possible since p n
p
g ci xi
instantiate ci
n g
endfor
endif end

instantiate

analogue lemma holds revised
lemma cluster tree instantiation euclidean space dimensionality
state theorem asserts correctness solve constraints
setting

theorem let set constraints n variables form dist b
dist c b b n solve constraints returns cluster tree
satisfying consistent euclidean space returns false inconsistent
proofs lemma theorem given appendix
examination proof lemma shows depend
relation n b therefore solve constraints returns tree
consistent satisfies regardless relation n b however
possible consistent solve constraints return false n b
hand one see proof theorem particularly lemma b n
solve constraints returns false inconsistent metric space however
metric spaces cluster tree returned solve constraints
may instantiation



fiorder magnitude comparisons distance

first order theory
final asserts om space rich enough full first order language
order magnitude distance comparisons decidable specifically collection
orders magnitude dense unbounded decision
first order sentences formula od w x od z runs time n n
n number variables sentence length sentence
basic reason following observed corollary cluster
tree determines truth value constraints form od b od c
b c symbols tree two instantiations two omspaces agree constraint require om spaces dense
unbounded much stronger statement holds two instantiations
om spaces agree first order formula free symbols relation
od w x od z hence suces check truth sentence possible
cluster trees variables sentence since finitely many cluster
trees fixed set variables taking account relative order labels
numeric values decidable procedure
let l first order language equality constant function symbols
single predicate symbol much closer b c easily shown l
expressive language function symbol od relation symbol

definition om space
orders magnitude
following axiom

dense satisfies

orders magnitude exists order magnitude


unbounded satisfies following
every order magnitude exists
collection orders magnitude hyperreal
line
p
satisfied axiom choose geometric mean
choose axiom choose


definition let cluster tree let l l l lk distinct labels
ascending order extending label li b lk note
lk label root c li li k
note k distinct non zero labels k different extending
labels

definition let cluster tree let x symbol cluster tree

extends x formed applying one following operations
single application single operation
null tree tree containing single node x



fidavis

consists single node symbol make node make x
children set label
internal node n including root make x child n
let symbol let n father n label create node
extending label label n label make child n
make x children
let c internal node root let n father create
node extending label c label label n label
make child n make x c children
let r root create node label r label make
r x children thus root tree
see figure
note tree n symbols n internal nodes

n ways carry step
n possible ways choose symbol step n
label

n different choices c step n choices
label

one way carry step
hence less n different extensions x almost certainly
overestimate least factor final entirely impractical
worthwhile precise

definition let cluster tree let formula l open variables
satisfies every instantiation satisfies
theorem let cluster tree let open formula l whose free variables
symbols let
om space dense unbounded
decide returns true satisfies false otherwise

decide cluster tree formula return boolean
convert equivalent form logical symbols
exists equals variable names
non logical symbol predicate much closer
function

case

form x return distance x
form much closer w x z return distance w x distance z
form return decide
form return decide decide
form x



fiorder magnitude comparisons distance

p

p

p






w

q

q



w

q

w

x





u

u

v

u

v

v

x

operation

operation
original

n p

n q

p

w

q


p

p




w

q


operation

operation
v

u



q




u

v








u

u

v

x

w

operation

x

w


p




x


w

p



operation
x

w

q


c q n p

q

u

u

v

v

v
operation
r p

figure extensions cluster tree



x

fidavis

extension

decide true


x
return true
else return false endif endcase

end



decide

distance x symbol cluster tree return
n common ancestor x
return n label
function

end

integer

distance

proof theorem given appendix
running time remarked tree size k k
extensions considered total number cluster trees considered therefore
bounded nk k n n easily verified logical operators
quantifiers add factor length sentence hence running
time bounded n n
key lemma interest states following
lemma let cluster tree let open formula l whose free variables
symbols let
om space dense unbounded one
instantiation
satisfies every instantiation
satisfies
true instantiations none proof given
appendix
observed conditions
lemma necessary
statement false otherwise example let
om space described
example section polynomials infinitesimal
unbounded
maximum order magnitude let starting tree figure
upper left corner let formula x od v w od w x free v w
valuation fu v w g satisfies whereas valuation
fu v w g satisfies

conclusions
applications specific undoubtedly limited aware
practical solving systems order magnitude relations distances
central however potential applications order magnitude reasoning
generally widespread ordinary commonsense reasoning involves distances spanning ratio fraction inch thousands miles durations
spanning ratio fraction second human lifetime scientific
reasoning spans much greater ranges explaining dynamics star combines reasoning
nuclear reactions reasoning star whole differ ratio
techniques needed compute quantities vastly differing
sizes quite different techniques needed compute quantities similar
sizes small step development analysis computational
techniques
significant encouragement give hope
order magnitude reasoning specifically qualitative reasoning generally may lead



fiorder magnitude comparisons distance

useful quick reasoning strategies broader range often found
ai moving greater lesser precision mode inference type
knowledge lead quick dirty heuristic techniques rather slow
dirty techniques nonmonotonic reasoning notorious example
arises well many types automated reasoning including qualitative spatial
physical reasoning developed welcome exception
rule currently studying algorithmic techniques order magnitude
optimistic finding similar favorable

acknowledgements
supported nsf grant iri thanks ji ae shin
andrew gelsey reviewers helpful comments

appendix proofs
appendix give proofs asserted body

proof lemma
lemma cluster tree
om space instantiate
returns
instantiation
proof let node n n label define n proof
proceeds following steps
nodes n descendant n od g g n n
proof child n immediate construction x xp
instantiate else let n n n nq path n
definition cluster tree follows ni label n label
therefore ni n thus od g g n triangle inequality
maxi q od g ni g ni maxi q ni since ni child
ni n
ii let n node let c c two distinct children n let
descendants c c respectively od g g n
proof construction x xp instantiate n od g c g c n
part od g g c c n likewise od g g c
n hence axiom od g g n
iii let b two leaves let n least common ancestor
b od g g b n proof immediate ii
iv node n odiam n n proof iii two leaves descending
different children n distance order n two leaves n
distance order greater n



fidavis

v node n n cluster proof let b leaves n
let c leaf n let common ancestor b
let j common ancestor c n descendant n
j proper ancestor n therefore part j iii
od b j od c
vi internal nodes n label n label odiam odiam n
proof immediate iv construction
vii c cluster node n c n proof let
set symbols corresponding c let n least common ancestor
let b two symbols different subtrees n
iii od g g b n let x symbol n symbols iii
od g g x n hence g x c


proof theorem
prove correctness solve constraints assume throughout
two variables long constraint distinct
lemma let cluster tree let instantiation let b
symbols let n least common ancestor b od b
odiam n
proof since b elements n follows definition odiam
od b odiam n suppose inequality strict od b
odiam n let c set symbols c od c
od b odiam c od b odiam n easily shown
c cluster therefore property ii definition must
node symbols c certainly ancestor n since
odiam odiam n symbols contains b contradicts
assumption n least common ancestor b
corollary let cluster tree let instantiation let b c
symbols let n least common ancestor c let
least common ancestor b od b od c
label n label
proof immediate lemma property iii definition instantiation

lemma let set constraints form od b od c let h
connected components shorts consistent every edge
h
proof let valuation satisfying edge pq od p q
maximal ab short constraint od b od c
od b od c od p q



fiorder magnitude comparisons distance

let ab edge h connected components shorts
path ak b edge ai ai short k
thus om triangle inequality od b maxi k od ai ai
od p q hence pq ab pq h

lemma values h iteration supersets values later
iteration

proof reset subset end iteration h defined terms
monotonic manner

cannot two successive iterations main loop
proof contradiction suppose two successive iterations h
since defined terms h constructed contain shorts
since resetting end first iteration change h must
contain longs well thus h contains edges case
terminated failure beginning first iteration
lemma

lemma solve constraints terminates
proof lemma exit failure iteration
constraints removed hence number iterations main loop
original size everything else clearly bounded note
bound number iterations improved section n n
number symbols

lemma solve constraints returns false inconsistent

proof returns false transitive closure shorts contains
edges lemma inconsistent

lemma constraint c form od b od c initial value
edge cd h particular iteration constraint c start
iteration
proof suppose c deleted particular iteration edge cd
long c cannot h iteration possible edge cd persist
h iteration c deleted note lemma cd
eliminated h remains h
lemma following loop invariant holds end loop iteration
values l symbols l leaf current state tree exactly
connected components h

proof first iteration initially root r containing symbols
child r created connected component h
let ti hi values h end ith iteration suppose
invariant holds end kth iteration lemma hk subset hk
hence connected component hk subset connected component hk



fidavis

moreover connected component j hk connected component hk
partitioned several connected components hk former case leaf
tk corresponding j unchanged remains leaf tk latter case leaf
corresponding j gets assigned one child connected component hk
subset j thus connected components hk correspond leaves tk

lemma procedure solve constraints return false returns wellformed cluster tree
proof lemma cleanup section solve constraints creates final
leaves symbols follows every symbol ends single leaf
decremented iteration iteration adds node children
node follows label internal node less label father
hence constraints cluster trees definition satisfied
lemma let b two distinct symbols let cluster tree returned
solve constraints let n least common ancestor b n
assigned label first iteration edge ab h edge ab
final value h loop exited n assigned label final cleanup
section
proof let hi value h ith iteration
n root assigned label first iteration clearly b
different subtrees n must different connected components h
suppose n assigned label kth iteration loop k lemma
end previous iteration n symbols connected component hk
therefore contained edge ab since n least common ancestor b follows
b placed two different children n hence two different connected
components hk thus edge ab cannot hk
suppose n assigned label cleanup section lemma
n symbols connected component final value h hence edge ab
final value h
lemma let initially contain constraint c form od b od c suppose
solve constraints returns cluster tree let least common ancestor b
let n least common ancestor c label n label
proof suppose n given label given iteration lemma cd eliminated
h iteration lemma constraint c must start
iteration hence ab short iteration therefore h hence
given label later iteration therefore given lower label
easily seen cd cannot h final iteration loop hence n
assigned label cleanup section
lemma suppose solve constraints returns cluster tree instantiation satisfies constraints
proof immediate lemma corollary



fiorder magnitude comparisons distance

theorem solve constraints returns cluster tree satisfying
consistent returns false inconsistent
proof solve constraints returns false inconsistent lemma
return false returns cluster tree lemma since instantiation
lemma since every instantiation solution lemma follows
consistent satisfies
proof theorem
lemma consistent sets constraints
reduce constraints reduce constraints
proof immediate construction value h case superset value
case hence reduce constraints superset reduce constraints
lemma consistent sets constraints num labels
num labels
proof induction num labels num labels statement trivial
suppose statement holds num labels k
let num labels k
k num labels num labels reduce constraints
k num labels reduce constraints suppose lemma
reduce constraints reduce constraints inductive hypothesis
num labels reduce constraints num labels reduce constraints
num labels num labels
lemma let set constraints let solution graph g
symbols let nd g number different non zero values od b
edge ab g let edges set edges nd edges
num labels
proof induction num labels num labels statement trivial
suppose k statement holds num labels k suppose
num labels k let pq edge maximal length set edges e
let small edges e set edges ab e
od b od p q since small edges e contains edges every order
magnitude e except order magnitude pq follows
nd small edges e nd e let g complete graph symbols
argument lemma small edges g h h connected
components shorts computed reduce constraints let set
constraints whose longs small edges g follows reduce constraints
small edges g edges edges reduce constraints
hence nd edges nd g nd small edges g
nd edges reduce constraints inductive hypothesis
num labels reduce constraints num labels



fidavis

theorem solutions set constraints instantiations
solve constraints fewest number different values od b b range
symbols number given num labels
proof immediate lemma
corollary let
properties om space except k
different orders magnitude system constraints solution

tree returned solve constraints uses k different labels
proof immediate theorems
proof non strict comparisons
prove revised presented section non strict comparisons
correct proof slight extension proof theorem given
recall revised section replaces line solve constraints
h connected components shorts
following code







h shorts
repeat h connected components h
weak constraint od b od c
cd h add ab h endif endfor
change made h last iteration

need following lemmas proofs

lemma let set strict comparisons let w set non strict comparisons let h set edges output code w consistent
edge h
proof proof lemma let valuation satisfying w let pq
edge od p q maximal wish every edge
ab h od b od p q hence ab pq proof induction suppose
holds edges h point code ab
added h three cases consider

ab added step lemma constraint od b od c
hence od b od c od p q
ab added step path ak b edge
ai ai h k inductive hypothesis od ai ai
od p q om triangle inequality
od b maxi k od ai ai od p q

ab added step constraint od b od c w
cd h inductive hypothesis od c od p q


fiorder magnitude comparisons distance



lemma let w contain constraint od b od c suppose
returns cluster tree let least common ancestor b let n
least common ancestor c label n label
proof lemma n assigned label first iteration h include
edge cd previous iterations since cd h ab likewise put h
hence get assigned label n label n label
remainder proof correctness revised exactly
proof theorem
validation solve constraints
proof correctness solve constraints analogous structure
proof theorem sketch details dicult fill
analogue lemma ordered cluster tree revised version
instantiate returns instantiation proof exactly lemma
additional verification instantiate preserves orderings
analogue lemma let set order magnitude constraints distances
let set ordering constraints points let h graph given
two statements

h connected components shorts
h incorporate order h
consistent h contain edges
proof proof lemma choose valuation satisfying let pq
edge od p q maximal following informal argument
presented section easily shown pq longer edges
added two statements hence h
analogue lemma solve constraints returns false inconsistent
proof immediate
analogue lemma solve constraints return false
returns well formed ordered cluster tree
proof merging strongly connected components g incorporate order
ensures ordering arcs connected components h form dag
arcs precisely ones later added among children node n
ordering arcs thus ordering arcs children node cluster tree
form dag otherwise construction tree lemma
remainder proof proof theorem



fidavis

proof theorem
begin proving lemma revised version instantiate given section
gives instantiation cluster tree euclidean space
lemma cluster tree instantiation euclidean space dimensionality
proof essentially proof lemma except
keep track real quantities node n n label define n
proof proceeds following steps
j j ffj immediate construction
ii nodes c descendant c
dist g g c ffn c
proof let c c c cr path p
c
dist
triangle inequality ri dist g ci g ci
pr g n cg ffc
n c

iii let n node let c c two children n let
descendants c c respectively
n n dist g g n n
proof triangle inequality
dist g c g c dist g c g dist g g dist g g c
thus dist g c g c dist g c g dist g g c dist g g
triangle inequality
dist g g dist g c g c dist g c g dist g g c
construction n dist g c g c n n
part ii dist g mi g ci ffn c n n
c n
iv symbols b c let p least common ancestor b let n
least common ancestor c p label n label
much closer g g b g c g
proof part iii dist g g b n p
dist g c g n n since p n since
n bn follows straightforward algebra
dist g g b dist g c g b



next prove analogue lemma

lemma let set constraints n variables form
dist b dist c b b n consistent edge
connected components shorts
proof let valuation satisfying let pq edge dist p q
maximal ab short constraint much closer b c
dist b dist c b dist p q b



fiorder magnitude comparisons distance

let ab edge h connected components shorts
simple path ak b edge ai ai short
k note k n triangle inequality
dist b
dist dist dist ak ak
k dist p q b dist p q

hence pq ab pq h

theorem let set constraints n variables form dist b dist c
b b n solve constraints returns cluster tree satisfying
consistent euclidean space returns false inconsistent
proof note semantics constraints much closer b c enters
proof theorem lemmas remainder proof theorem
purely relation structure structure tree hence
since shown analogues lemmas hold set constraints
kind proof completed exactly way
proof theorem
lemma let cluster tree let valuation om space
satisfying
let x symbol let point
let valuation fx ag
exists extension x satisfies
proof empty tree statement trivial contains single symbol
operation applies label operation
applies label
otherwise let symbol od minimal deal
case ties step let f father
let od let v set orders magnitude od p q
p q range symbols define l suitable label follows
v l label corresponding larger value v
l label root plus v value v larger
let largest value v less let smallest value v greater
let l l labels corresponding let l l l
one following must hold
f label apply operation n f
b f label apply operation label
c od less od z symbol z

apply operation label set suitable value
one value yk od yi easily shown
case internal node q yk set symbols
subtree q three cases consider



fidavis

odiam q symbols apply operation n q
ii odiam q symbols q root apply operation
c q set label suitable value easily shown
odiam n symbols n father q
iii odiam q symbols q root apply operation



lemma let fa ak g finite set points whose diameter order ofmagnitude exists point u k od u ai
proof let b axiom exists infinite collection points b b
od bi bj j value ai one value bj
od ai bj two values bj bj om triangle
inequality od bj bj hence k different values bj least
ai let u values bj since od u od ai
follows od u ai ai thus since od u ai od u ai
follows od u ai
lemma let cluster tree let valuation om space
satisfying
let extension x
dense unbounded
value valuation fx ag satisfies
proof operations statement trivial
otherwise let l extending label l set l
let order magnitude corresponding l l l l
l l labels consecutive values let orders
magnitude corresponding l l let chosen
l greater label tree choose greater diameter
tree
formed operation lemma let point
od odiam n n symbols
formed operation let point od

formed operation let point od
c symbols note since label n label odiam n symbols
formed operation let point od
r symbols
cases straightforward verify fx ag satisfies
observed section regarding lemma conditions
lemma
necessary statement false otherwise example let
om space
described example section polynomials infinitesimal

unbounded maximum order magnitude let starting tree
figure upper left corner let applying operation middle
bottom let valuation fu v w g satisfies cannot
extended valuation satisfies would require x given value
od v w od x w value exists within
point lemma



fiorder magnitude comparisons distance


required dense unbounded cannot get stuck
way

lemma let cluster tree let x variable among symbols
let open formula l whose free variables symbols variable
x let formula x let
om space dense unbounded
exists instantiation
satisfies exists
extension instantiation extends satisfies
proof suppose exists instantiation satisfies x
definition point
satisfies x instantiation
fx ag satisfies let fx ag lemma cluster tree
corresponding extension
conversely suppose exists extension instantiation
satisfying let restriction symbols clearly satisfies
formula x
lemma let cluster tree let open formula l whose free variables
symbols let
om space dense unbounded one
instantiation
satisfies every instantiation
satisfies
proof assume without loss generality logical symbols
exists equals variables names non logical
symbol predicate much closer proceed structural induction
form note equivalent statement inductive hypothesis formula
true every instantiation false every instantiation

base case atomic formula x much closer w x z
follows immediately corollary
let form true false inductive hypothesis false every instantiation hence true every
instantiation
let form true true
inductive hypothesis true every instantiation hence
true every instantiation
let form x true lemma exists
extension instantiation true inductive
hypothesis true every instantiation instantiation
satisfies restriction variables clearly satisfies
x lemma every instantiation extended instantiation
therefore every instantiation satisfies
theorem let cluster tree let open formula l whose free variables
symbols let
om space dense unbounded
decide returns true satisfies false otherwise
proof immediate proof lemma



fidavis

references
cormen h leiserson c e rivest r l introduction cambridge mit press
davis e order magnitude reasoning qualitative differential equations
weld j de kleer eds readings qualitative reasoning physical systems
san mateo ca morgan kaufmann
keisler j foundations infinitesimal calculus boston prindle webber
schmidt
mavrovouniotis stephanopoulos g formal order magnitude reasoning process engineering weld j de kleer eds readings qualitative
reasoning physical systems san mateo ca morgan kaufmann
raiman order magnitude reasoning weld j de kleer eds
readings qualitative reasoning physical systems san mateo ca morgan kaufmann
robinson non standard analysis amsterdam north holland publishing co
weld exaggeration weld j de kleer eds readings qualitative
reasoning physical systems san mateo ca morgan kaufmann




