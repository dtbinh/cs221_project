Journal Artificial Intelligence Research 56 (2016) 379-402

Submitted 09/15; published 06/16

Generating Models Matched Formula
Polynomial Delay
Petr Savicky

savicky@cs.cas.cz

Institute Computer Science, Czech Academy Sciences
Pod Vodarenskou Vez 2, 182 07 Praha 8, Czech Republic

Petr Kucera

kucerap@ktiml.mff.cuni.cz
Department Theoretical Computer Science Mathematical Logic
Faculty Mathematics Physics, Charles University Prague,
Malostranske nam. 25, 118 00 Praha 1, Czech Republic

Abstract
matched formula CNF formula whose incidence graph admits matching
matches distinct variable every clause. formula always satisfiable. Matched
formulas used, example, area parametrized complexity. prove
problem counting number models (satisfying assignments) matched
formula #P-complete. hand, define class formulas generalizing
matched formulas prove formula class one choose polynomial
time variable suitable splitting tree search models formula.
consequence, models formula class, particular matched
formula, generated sequentially delay polynomial size input.
hand, prove task cannot performed efficiently linearly
satisfiable formulas, generalization matched formulas containing class
considered above.

1. Introduction
paper, consider problem counting models (satisfying assignments)
generating subsets models given formula conjunctive normal form (CNF).
well known problem counting models general CNF #P-complete (Sipser,
2006). problem generating models general CNF formula clearly hard,
checking whether least one satisfying assignment formula,
SAT problem, NP-complete (Garey & Johnson, 1979).
paper, mostly deal problem enumerating models formula.
problem important areas research applications, unbounded model
checking (Kang & Park, 2005; McMillan, 2002) data mining (Coquery, Jabbour, Sais,
Salhi, et al., 2012). success modern SAT solvers inspired design model counting
enumeration algorithms well (see e.g. Jabbour, Lonlac, Sais, & Salhi, 2014; Morgado
& Marques-Silva, 2005a, 2005b). addition basic enumeration problem
require models generated prescribed order, versions
considered, e.g. generating models non-decreasing weight (Creignou, Olive, & Schmidt,
2011).
Another line research concentrated studying special classes boolean formulas
enumeration algorithm guaranteed complexity could devised. One
c
2016
AI Access Foundation. rights reserved.

fiSavicky & Kucera

easily find example formula set models exponentially larger
size formula itself. case reasonable include size output
bound running time enumeration algorithm. specifically say
algorithm enumerates models formula runs output polynomial time
running time bounded polynomial two variables, size input
(i.e. input formula ) size output (i.e. number models ).
paper, consider restrictive setting follows. algorithm receives input
formula generates sequence models way time needed
generating first model time generating two consecutive models
sequence polynomial length formula. type complexity bound
called polynomial delay. clear enumerate models formula
polynomial delay, construct output polynomial algorithm
task well. hand, much harder get enumeration algorithm
polynomial delay output polynomial algorithm. overview various
notions enumeration complexity (see Johnson, Yannakakis, & Papadimitriou, 1988).
special classes formulas polynomial delay enumeration algorithms
described, includes 2-CNF formulas, Horn formulas, generalized satisfiability
problems others (see e.g. Aceto, Monica, Ingolfsdottir, Montanari, & Sciavicco, 2013;
Creignou & Hebrard, 1997; Dechter & Itai, 1992; Kavvadias, Sideri, & Stavropoulos, 2000).
paper, describe another class formulas polynomial delay enumeration algorithm based backtrack-free search described. contrary
algorithms known 2-CNF Horn formulas, splitting variable step cannot
chosen arbitrarily, however, existence suitable variable guaranteed
efficiently identified.
particular consider class matched formulas introduced Franco
Van Gelder (2003). Given CNF formula , consider incidence graph I() defined follows. I() bipartite graph one part consisting clauses
part containing variables . edge {x, C} variable x clause C
I() x x appears C. observed Aharoni Linial (1986) Tovey
(1984) I() admits matching (i.e. set pairwise disjoint edges) size (where
number clauses ), satisfiable. Later formulas satisfying
condition called matched formulas Franco Van Gelder. Since matching
maximum size bipartite graph found polynomial time (see e.g. Lovasz &
Plummer, 1986), one check efficiently whether given formula matched.
Given general formula , measure far matched considering maximum deficiency (), number clauses remain unmatched
maximum matching I(). formula thus matched iff () = 0. weaker notion
deficiency () = n, number clauses n number
variables , often considered.
Matched formulas play significant role theory satisfiability solving. Since
introduction matched formulas considered base class parameterized
algorithms satisfiability, see e.g. book Flum Grohe (2006) overview
parameterized algorithms theory. particular, Fleischner, Kullmann, Szeider (2002)
show satisfiability formulas maximum deficiency bounded constant k
decided time O(kknO(k) ) kk length input formula n
380

fiGenerating Models Matched Formula

denotes number variables. result later improved Szeider (2003)
algorithm satisfiability parameterized maximum deficiency formula
complexity O(2k n3 ). Parameterization based backdoor sets respect matched
formulas considered Szeider (2007).
Since matched formulas trivially satisfiable, ask stronger question:
hard count enumerate models matched formula? prove counting
models matched formula #P-complete problem, turn attention
generating models matched formula. main result paper algorithm
generates models matched formula polynomial delay. algorithm
constructs splitting tree whose nodes correspond either matched unsatisfiable
formula. However, cases strategy sufficient since nodes tree
cannot split way. prove node corresponds formula
satisfied iterated elimination pure literals. Formulas property
called pure literal satisfiable. formulas studied Kullmann (2000)
subclass linearly satisfiable formulas. node pure literal satisfiable formula
reached, algorithm switches simpler strategy. prove models pure
literal satisfiable formula generated delay linear length formula.
hand, #SAT problem pure literal satisfiable formulas #P-complete,
problem #P-complete monotone 2CNFs (Valiant, 1979a, 1979b),
pure literal satisfiable.
Several generalizations matched formulas considered literature. Kullmann (2000) generalized matched formulas class linearly satisfiable
formulas. Autarkies based matchings studied Kullmann (2003). Szeider (2005)
considered another generalization matched formulas, classes biclique satisfiable
var-satisfiable formulas. Unfortunately, biclique satisfiable var-satisfiable
formulas hard check formula falls one classes (Szeider, 2005).
show paper result transfer class linearly satisfiable
formulas demonstrating possible generate models linearly satisfiable
formula polynomial delay unless P=NP.
paper organized follows. giving basic definitions Section 2, describe
Section 3 specific simple splitting property class formulas, allows
generate models formula class efficiently. Section 4, consider pure
literal satisfiable formulas prove class required splitting property.
Section 5, consider matched formulas prove required splitting property
class formulas, generalizes matched pure literal satisfiable formulas
natural way. implies algorithm generating models matched formula
formula general class polynomial delay. Section 6, present
complexity bounds efficient versions algorithms previous sections.
Section 7, show negative result concerning linearly satisfiable formulas. Section 8
contains concluding remarks directions research.

2. Definitions
section, give necessary definitions summarize results use
paper.
381

fiSavicky & Kucera

2.1 Boolean Functions
Boolean function n variables mapping f : {0, 1}n {0, 1}. literal either
variable, called positive literal, negation, called negative literal. negation
variable x denoted x x. clause disjunction set literals,
contains one literal variable. Formula conjunctive normal form
(CNF) or, equivalently, CNF formula, conjuction clauses. often treat
clause set literals CNF formula set clauses. well known
fact every Boolean function represented CNF formula (see e.g. Genesereth
& Nilsson, 1987). size formula number clauses
denoted ||. length formula total number occurrences literals ,
i.e. sum sizes clauses , denoted kk. Given variable x
value {0, 1}, [x = a] denotes formula originating substituting x
value obvious simplifications consisting removing falsified literals satisfied
clauses. extend notation negative literals well setting [x = a] = [x = a].
formula obtained assigning values a1 , . . . , ak {0, 1} variables
x1 , . . . , xk denoted [x1 = a1 , x2 = a2 , . . . , xk = ak ]. say literal l pure
CNF formula, occurs formula negated literal l not. literal
irrelevant formula, neither literal negation occurs formula.
variable pure, appears positively, negatively , i.e. appears
literal, pure .
Let formula defining Boolean function f n variables. assignment
values v {0, 1}n model (also satisfying assignment, true point ),
satisfies f , i.e. f (v) = 1. set models denoted (). models
() defined variables occurrence . set variables
function defined formula larger, however, introduce special
notation general case. algorithmic purposes, necessary,
since adding irrelevant variable formula changes set models adding
variable possible values element original set models.
partial assignment assigns values subset variables. formula
variables x1 , . . . , xn , represented ternary vector v {0, 1, }n ,
vi = denotes fact xi assigned value v.
Note empty clause admit satisfying assignment empty CNF
satisfied assignment.
2.2 Matched Formulas
paper use standard graph terminology, (see e.g. Bollobas, 1998). Given
undirected graph G = (V, E), subset edges E matching G edges
pairwise disjoint. bipartite graph G = (A, B, E) undirected graph
disjoint sets vertices B, set edges E satisfying E B. set
W vertices G, let (W ) denote neighborhood W G, i.e. set vertices
adjacent element W . shall use following well-known result matchings
bipartite graphs:
Theorem 2.1 (Halls Theorem). Let G = (A, B, E) bipartite graph. matching
size |M | = |A| exists every subset |S| |(S)|.
382

fiGenerating Models Matched Formula

Let = C1 . . . Cm CNF formula n variables X = {x1 , . . . , xn }. associate
bipartite graph I() = (, X, E) (also called incidence graph ),
vertices correspond clauses variables X. clause Ci connected
variable xj (i.e. {Ci , xj } E) Ci contains xj xj . CNF formula matched I()
matching size m, i.e. matching pairs clause unique
variable, shall call matching clause saturated matching. Note matched
CNF trivially satisfiable, since clause satisfied literal containing
variable matched given clause. variable, matched clause
given matching , called matched , free otherwise.
2.3 Generating Models Polynomial Delay
main goal paper describe algorithm which, given matched formula ,
generates set () models polynomial delay. Let us state formally
require algorithm.
say algorithm generates models Boolean formula polynomial
delay, polynomial p, algorithm, given formula input,
satisfies following properties.
1. works steps, takes time O(p(kk)).
2. step, either finds model different models obtained
previous steps (in particular, model first step) determines
model, previous steps already found models .
algorithm properties exists, follows construct
set () models time O((|T ()| + 1) p(kk)), means algorithm
output polynomial. Note since () may exponential size respect kk,
efficiency respect size input output best hope
constructing ().

3. Efficient Splitting Tree Algorithm
idea algorithm construct decision tree function represented
given satisfiable CNF, every subtree larger single leaf contains 1-leaf.
depth tree number variables. tree searched
DFS order, time needed arbitrary moment reach 1-leaf n
times time needed split node. following, show classes
formulas including matched formulas possible find splitting procedure
yields tree described above.
decision tree Boolean function f labeled binary tree, inner node
labeled variable, leaves edges labels 0 1. decision tree computes
f (x) given assignment x process starts root visited
node follows edge labeled value variable, label node.
output label leaf reached process. computation path tests
variable, tested previous part path, test redundant.
consider trees without redundant tests.
383

fiSavicky & Kucera

decision tree representing function given CNF formula constructed top follows. root tree assigned . non-leaf node
tree assigned formula , choose arbitrary split variable x
occurrence assign restricted formulas [x = 0] [x = 1] successors.
node assigned empty formula becomes 1-leaf node assigned formula,
contains empty clause, becomes 0-leaf. resulting decision tree represents
function given , although large practical purposes. path
root inner node u tree corresponds partial assignment changes
formula representing function computed subtree whose root u.
depth tree function n variables n.
leaf node labeled 1 represents set models , precisely, leaf
depth represents 2nd models . Moreover, different leaves tree represent
disjoint sets models. Given decision tree function represented , can,
traversing it, generate models time proportional size. process leads
large delay generating successive models, tree contains large subtrees
0-leaves. following condition class formulas describes situation
avoided.
Definition 3.1. Let U class formulas, let U let x variable
occurrence . say x splitting variable relative U , every
{0, 1}, [x = a] satisfiable, [x = a] U .
class formulas U splitting property, every formula U containing
variable contains splitting variable relative U .
shall associate splitting problem class formulas U splitting property.
Definition 3.2. Let U class formulas splitting property. splitting problem
relative U following problem: Given formula U , find splitting variable
relative U results satisfiability tests formulas [x = 0] [x = 1].
Note complexity splitting problem relative U upper bound
time satisfiability test formulas U . formula satisfiable,
variable x least one formulas [x = 0]
[x = 1] satisfiable. result satisfiability checks splitting variable x
required part solution splitting problem.
Theorem 3.3. class formulas U splitting property splitting problem
relative U solved time c(), c() kk formula U ,
models formula U n variables generated delay O(n c()).
Proof. Construct tree DFS order using splitting variable every formula
assigned non-leaf node. non-leaf node labeled x splitting
variable, successors labeled [x = 0] [x = 1]. formulas
unsatisfiable, corresponding successor becomes 0 leaf. formulas
empty, corresponding successor becomes 1 leaf. root tree split even
unsatisfiable, however, nodes labeled unsatisfiable formula split.
384

fiGenerating Models Matched Formula

Hence, except possibly root, node two 0-leaves successors.
Since length every formula tree kk, node, time O(c())
sufficient choose splitting variable, determine successors leaf,
construct formulas successors node.
Let us assume u non-leaf node constructed tree different root.
One successors u labeled unsatisfiable formula. recognized
splitting algorithm successor 0-leaf. Consequently, time
O(c()), construction tree continues satisfiable successor u. Hence,
n splitting steps time O(n c()), 1-leaf reached. 2
Remark 3.4. contains unit clause U closed unit propagation,
variable x contained unit clause splitting variable identified efficiently.
reason known satisfiable, one formulas [x = a] contains
empty clause and, hence, satisfiable.
Remark 3.5. class U satisfies
1. satisfiability formulas U tested polynomial time,
2. U closed partial assignments,
splitting problem relative U polynomial complexity. Indeed, case
variable formula U splitting variable satisfiability tests
corresponding restrictions obtained polynomial time. Class U property
sometimes conservative. say property particular form
self-reducibility (in sense considered e.g. Khuller & Vazirani, 1991). classes
generalized satisfiability problem described Creignou Hebrard (1997)
property addition classes, consider, instance, Horn formulas, SLUR formulas,
2CNFs, q-Horn formulas, etc. immediate corollary Theorem 3.3, possible
generate models formulas classes polynomial delay.
main result paper splitting problem relative slight generalization matched formulas polynomial complexity although class matched
formulas closed partial assignments.

4. Pure Literal Satisfiable Formulas
considering matched formulas, let us make small detour class formulas
satisfiable iterated elimination pure literals, call pure literal
satisfiable. formulas already considered Kullmann (2000) special
case linearly satisfiable formulas.
set literals called consistent, contain contradictory literals. l
literal, let assign(l) assignment variable contained l, satisfies
l. consistent set sequence literals L, let assign(L) partial assignment
variables satisfying literals L. formula , [L] abbreviation
[assign(L)].
385

fiSavicky & Kucera

Definition 4.1. pure literal sequence formula consistent sequence literals
(l1 , . . . , lk ), every = 1, . . . , k, literal li either pure irrelevant
formula [l1 , . . . , li1 ]. particular, l1 pure irrelevant . pure literal sequence
called strict, literals li pure [l1 , . . . , li1 ].
L pure literal sequence , formula [L] called reduced formula
corresponding L. [L] contain pure literal, L called maximal
pure literal sequence .
Definition 4.2. formula pure literal satisfiable, pure literal sequence L
, reduced formula [L] empty or, equivalently, assign(L) satisfying
assignment .
autarky formula partial assignment v variables, every
clause either satisfied unchanged v. Autarkies studied e.g. Kullmann
(2000). Note every initial segment pure literal sequence defines assignment
variables, autarky. Moreover, one easily verify property
characterizes pure literal sequences.
Let us note pure literal satisfiable formulas closed partial assignments.
Consider formula , contain pure literal. Let formula obtained
adding new variable x positive literal every clause. Formula
pure literal satisfiable, [x = 0] = pure literal satisfiable. follows
pure literal satisfiable formulas satisfy second property required Remark 3.5
put effort showing pure literal satisfiable formulas
splitting property splitting problem relative pure literal satisfiable formulas
polynomial complexity.
every CNF formula, may tested polynomial time, whether pure literal
satisfiable. order find pure literal sequence witnessing fact, procedure
FindPLS Algorithm 1 uses greedy approach, step chooses satisfies
pure literal current formula. approach meaningful, since literal
pure stage procedure, either remains pure becomes irrelevant
following stages. pure literal sequence obtained procedure depends
nondeterministic choices made procedure, however, Corollary 4.4, resulting
reduced formula uniquely determined input.
Lemma 4.3. clause C CNF removed run FindPLS,
removed every run FindPLS input .
Proof. Let L K pure literal sequences produced different runs FindPLS
. formulas [L] [K] corresponding reduced formulas let C
clause contained [L]. Hence, L contains literals C. Since [K]
subset , L pure literal sequence [K]. literal L contained
[K], first literals pure [K]. Since [K] contain pure
literal, literal L contained [K]. particular, C contained [K]. 2
following immediate corollary.
386

fiGenerating Models Matched Formula

Algorithm 1 Constructing pure literal sequence
Require: CNF formula .
Ensure: maximal strict pure literal sequence L corresponding reduced
formula.
1: procedure FindPLS()
2:

3:
Initialize new empty list literals L.
4:
Initialize Pure() set pure literals .
5:
Pure() 6=
6:
Choose literal l Pure().
7:
Add l L.
8:
[l].
9:
Update Pure() consist pure literals .
10:
end
11: end procedure

Corollary 4.4. Let CNF formula let L pure literal sequence obtained
FindPLS .
1. formula [L] uniquely determined .
2. formula pure literal satisfiable, [L] empty.
Since running time procedure FindPLS polynomial length input
formula, maximal pure literal sequence formula constructed polynomial
time. complexity constructing maximal pure literal sequence formula is,
fact, O(kk) Lemma 6.1.
Lemma 4.5. Let L = (l1 , . . . , ln ) pure literal sequence formula , contains
literal variable . = 1, . . . , n, denote xi variable contained li .
xi variable largest index among variables, occurence
, xi splitting variable relative pure literal satisfiable formulas
formulas [xi = 0] [xi = 1] satisfiable, contain
empty clause.
Proof. Let one formulas [xi = 0] [xi = 1] let L = (l1 , . . . , li1 ).
Clearly, L pure literal sequence . Moreover, contain empty clause,
L assigns value literals every clause hence, satisfies it. 2
sufficient show splitting problem relative class pure literal
satisfiable formulas polynomial complexity. Later Theorem 6.2 shall show
splitting problem case solved time O(kk).
Lemma 4.6. splitting problem relative class pure literal satisfiable formulas
polynomial complexity.
387

fiSavicky & Kucera

Proof. pure literal satisfiable, pure literal sequence, satisfies it,
obtained FindPLS polynomial time. sequence contain literals
variables, extended polynomial time appending arbitrary literals missing
variables obtain pure literal sequence satisfying assumption Lemma 4.5. Then,
lemma implies method select splitting variable obtain results
satisfiability test corresponding restrictions polynomial time. 2
pure literal sequence satisfies assumption Lemma 4.5 formula ,
sequence used find splitting variable formulas splitting tree
. Using this, models pure literal satisfiable formula generated
delay smaller general bound Theorem 3.3, see Corollary 6.2.
Remark 4.7. sign literal given variable, occurs strict pure literal
sequence, uniquely determined. variables y1 y2 occur
positively negatively strict pure literal sequence formula
(x1 y1 ) (x2 y1 ) (x3 y2 ) (x4 y2 ) (y1 y2 ) .
example, (x2 , y1 , x3 , y2 ) (x4 , y2 , x1 , y1 ) strict pure literal sequences formula.

5. Matched Formulas
section concentrate matched formulas. Let us start showing
problem determining number models matched formula , i.e. size |T ()|,
hard general #SAT problem.
Theorem 5.1. problem determining |T ()| given matched formula #Pcomplete.
Proof. Let = C1 C2 . . . Cm arbitrary CNF formula n variables. Let
y1 , . . . , ym new variables appearing let = (y1 y2 . . . ym ) clause.
Let us define CNF formula n + variables equivalent
= (C1 D) (C2 D) . . . (Cm D) .
Clearly, matched formula one observe |T ()| = |T ()| 2n (2m 1).
thus reduced problem counting models general CNF formula
(i.e. general #SAT problem) problem counting models matched CNF
formula (i.e. #SAT problem restricted matched formulas). 2
goal show generate models matched formula
polynomial delay. Theorem 3.3 cannot used directly, since class
matched formulas splitting property seen following
example. Consider formula
(x1 x2 ) (x1 x3 ) (x2 x3 ) .
388

fiGenerating Models Matched Formula

formula matched, splitting variable. Indeed, setting x1 0 leads
satisfiable, yet matched formula (x2 )(x3 )(x2 x3 ) symmetry true
variables x2 x3 well. order achieve objective, consider richer
class formulas. class consider generalizes matched pure literal satisfiable
formulas follows. Note empty formula matched, since corresponds
empty graph formally assume empty graph possesses required
matching.
Definition 5.2. formula called pure literal matched, reduced formula obtained
procedure FindPLS matched.
Elimination pure literal preserves property matched, since pure literal
autarky. Hence, matched formula pure literal matched. Clearly, every pure literal
satisfiable formula pure literal matched, since reduced formula empty and, hence,
matched.
basic idea efficient splitting algorithm matched formulas presented
following theorem. Later shall show Corollary 6.4 splitting problem
relative pure literal matched formulas solved time O(n2 kk).
Theorem 5.3. class pure literal matched formulas splitting property
splitting problem relative pure literal matched formulas polynomial complexity.
order prove Theorem 5.3, show several statements concerning
structure matched formula. V set variables, say clause limited
V , contains literals variables V .
Definition 5.4. Let V subset variables matched formula let C denote
set clauses limited V . set V called critical block ,
|C| = |V |. Formally, V empty, critical block.
Note matched formula, V subset variables, C set
clauses limited V , Halls theorem (Theorem 2.1 above)
|C| (C) |V |. Critical blocks achieving equality. blocks
following property.
Lemma 5.5. Let V critical block matched formula . Then, every clause
saturated matching I(), variables V matched clauses limited V .
Proof. Let matched formula fixed clause saturated matching
variables clauses . V critical block, |V | clauses limited
V clauses matched variables V . Since variables matched
clauses different, variables V matched one clauses. 2
Another useful property set critical blocks follows.
Lemma 5.6. set critical blocks matched formula closed intersection.
Proof. Let matched formula let V1 , V2 critical blocks. intersection
V1 V2 empty, conclusion lemma satisfied. variable x V1 V2 ,
389

fiSavicky & Kucera

Lemma 5.5, every clause saturated matching I(), variable matched
clause, limited V1 V2 . Hence, number clauses,
limited V1 V2 , least |V1 V2 |. Since matched, number clauses
equal |V1 V2 | Halls theorem. Hence, V1 V2 critical block required. 2
formula x variable contained least one critical block,
Lemma 5.6 implies unique inclusion minimal critical block containing
x, equal intersection critical blocks containing x. matched
formula number clauses variables, every variable contained
critical block, since set variables formula critical block.
Definition 5.7. matched formula number clauses variables x one variables, let Bx denote inclusion minimal critical block
containing x.
notation Bx specify formula, since always clear
context. aim show formula matched, either find
splitting variable relative matched formulas, actually pure literal satisfiable.
order show property basis algorithm, shall first investigate
structure critical blocks respect matchings.
Lemma 5.8. Let matched formula number clauses variables.
Let l literal containing variable x let us assume formula [l]
matched.
1. literal l pure irrelevant clauses limited Bx ,
2. clause C contains l, every matching , C matched
variable y, Bx (where denotes strict inclusion).
Proof. symmetry, shall consider case l = x. Hence, assumptions,
[x = 0] matched formula.
1. critical block Bx subset every critical block containing x. Hence, order
prove first part lemma, sufficient show least one
critical block B containing x, x occur negatively clauses
limited B. Let C set clauses Halls condition
formula [x = 0] satisfied |(C)| < |C|. Let V = (C) set
variables, occurrence clauses C, let k = |V |.
least k + 1 clauses C. Since every clause C limited V ,
least k + 1 clauses [x = 0] limited V . clauses either
clause obtained clause removing literal x. Consider
set clauses limited V {x}. Since matched, Halls condition
satisfied set. Hence, contains k + 1 clauses limited V {x}.
Setting x = 0 leads least k + 1 clauses limited V . Hence, contains precisely
k + 1 clauses limited V {x} none contains literal x. Hence,
V {x} critical block required property proof first part
lemma finished.
390

fiGenerating Models Matched Formula

2. Let us fix clause saturated matching clauses variables I() let
clause matched x. Since [x = 0] matched, follows
contains positive literal x, otherwise matching would work
[x = 0] well. Let C clause containing x let variable C
matched . Since C different D, 6= x. assumptions,
set variables critical block and, hence, critical block
well-defined. Since C matched y, C limited Lemma 5.5.
implies x , x C. Since critical block containing x
Bx inclusion minimal critical block containing x, Bx . first part
lemma, clause limited Bx contains x implies C limited
Bx thus Bx 6= . Together get Bx .
2
structure critical blocks used show following proposition needed
prove Theorem 5.3.
Theorem 5.9. Let matched formula. every variable x, occurence
, {0, 1}, [x = a] matched, pure literal satisfiable.
Proof. Let matched formula satisfying assumptions let us fix clause
saturated matching I(). variable x matched
clause, assigning value x yields matched formula. assumption
therefore suppose variable exist variable matched
clause. case, numbers clauses variables equal
variable x , Bx well-defined.
Let n number variables clauses . = 1, . . . , n, let li
literal containing variable xi clause matched variable. every
= 1, . . . , n, formula [li ] matched formula [li ] matched. Consider
strict partial order variables defined
x < Bx

(1)

means strict inclusion. Lemma 5.8, variables maximal
partial order pure . Let us consider total ordering variables,
consistent strict partial order (1). Using appropriate renaming variables,
may assume ordering x1 , . . . , xn , every i, j, xi < xj , < j.
Let us verify using ordering, sequence ln , ln1 , . . . , l1 satisfying pure literal
sequence . Let us show induction = n, . . . , 1 xi pure irrelevant
formula [ln , . . . , li+1 ]. true = n Lemma 5.8, xn maximal
order variables induced inclusion critical blocks. Let us fix
consider partial assignment assign(ln , . . . , li+1 ). Lemma 5.8, clause containing
li matched variable xj satisfying xi < xj . Hence, clauses eliminated
considered partial assignment variable xi pure irrelevant formula
[ln , . . . , li+1 ]. 2
Proof Theorem 5.3. Assume, pure literal matched formula. Let L pure
literal sequence obtained FindPLS procedure let = [L], is,
391

fiSavicky & Kucera

assumption, matched formula. Since L maximal, contain pure literal.
empty, pure literal satisfiable formula find splitting variable
method Lemma 4.6. empty, matched pure
literal satisfiable. Hence, Theorem 5.9, variable x , [x = 0]
[x = 1] matched. Since L contain literal variable x,
application assign(L) x = commute {0, 1}. Hence, L pure literal
sequence formula [x = a] application assign(L) [x = a] leads
[x = a], matched. Hence, {0, 1}, formula [x = a] pure literal
matched variable x splitting variable formula .
time polynomial length formula sufficient select splitting variable
x proof above. nonempty, satisfiability [x = 0] [x = 1]
guaranteed choice x. empty, pure literal satisfiable method
Lemma 4.6 used. Hence, splitting variable results required satisfiability
tests obtained polynomial time. 2
Similarly class matched formulas, class pure literal matched formulas
closed unit propagation. implies unit propagation used part
construction splitting tree, particular Remark 3.4 always select
variable unit clause splitting variable.
Proposition 5.10. class pure literal matched formulas closed unit propagation.
Proof. Assume, pure literal matched formula containing unit clause C = (l)
l literal. Let us prove [l] pure literal matched formula.
Let L pure literal sequence . Observe l cannot contained L,
[l] unsatisfiable. rest proof, distinguish, whether l contained L
not.
l contained L, let L1 denote sequence literals L l let L2
sequence literals L l. simplicity, written L = (L1 , l, L2 ).
clauses missing [l] changed removing l. Since l
contained L1 , sequence L1 pure literal sequence [l]. Since assignments
disjoint sets variables commute, [L1 , l] = [l, L1 ] and, hence, sequence
L2 pure literal sequence formulas. Hence, sequence L = (L1 , L2 )
pure literal sequence [l]. Since, moreover, [L1 , l, L2 ] = [l, L1 , L2 ], application
L [l] leads matched formula. Consequently, [l] pure literal matched.
Let us consider case l contained L. case [L] matched
formula contains unit clause C = (l), since clause cannot eliminated
satisfying literals L. every maximum matching [L], clause C matched
l. Thus satisfying l gives matched formula [L, l]. Since [L, l] = [l, L] L
pure literal sequence [l], formula pure literal matched. 2

6. Algorithms Complexity
section, prove specific complexity bounds algorithms presented
previous sections. complexity bounds derived RAM model unit cost
392

fiGenerating Models Matched Formula

measure word size O(log kk), input formula. data structures
used algorithms similar described Minoux (1988) Murakami
Uno (2014). Let us first concentrate pure literal satisfiable formulas.
Lemma 6.1. maximal pure literal sequence L CNF formula constructed
time O(kk).
Proof. use approach presented linear time algorithm unit propagation
Minoux (1988) obtain efficient version procedure FindPLS Algorithm 1.
addition initializations Algorithm 1, initialize auxiliary data structures.
data structures similar described Murakami Uno (2014).
particular, occurences literals formula represented nodes arranged
sparse matrix, whose rows correspond literals columns correspond clauses.
node contains identification clause literal, whose occurence represents.
auxiliary data structures names follows:
literal l denote cl(l) row matrix, doubly-linked list
nodes representing occurences l .
clause C denote lit(C) column matrix, doublylinked list nodes corresponding occurences literals C.
literal l denote cnt(l) counter, contains size list lit(C)
number clauses l appears.
initialize set Pure() queue always contains pure literals .
literals l cnt(l) > 0 cnt(l) = 0.
data structures initialized traversing linear time. important
note node represents occurence literal l clause C.
structure representing node contains four pointers, two doubly-linked list lit(C)
two double-linked list cl(l). Thus removing node lists
performed constant time.
procedure FindPLS repeat following steps find pure literal l , add l
L apply assign(l) . Finding pure literal amounts dequeueing Pure().
applying assign(l) remove clauses containing l (these satisfied)
remove l remaining clauses. Let 1 consist clauses contain l
let 0 consist clauses contain l. claim assign(l) applied
time O(k1 k + |0 |).
1. Removing clauses 1 means going list cl(l) clause C
list literal l lit(C) (including l), remove corresponding node
cl(l ) make list lit(C) inaccessible. requires time O(1) literal l .
operation decrement counters cnt(l ) literals lit(C)
negated counterparts becomes pure, add queue Pure().
2. Removing occurrences l means going list cl(l) clause
C list, remove corresponding node cl(l) lit(C).
done time O(1) occurrence l.
393

fiSavicky & Kucera

Repeating steps literals included L requires constant number
operations occurrence literal input formula implies total
time O(kk). 2

Theorem 6.2. splitting problem relative pure literal satisfiable formulas
solved time O(kk) input pure literal satisfiable formula. Moreover,
set () models pure literal satisfiable formula generated delay
O(kk).
Proof. Using efficient version FindPLS guaranteed Lemma 6.1, operations
used proof Lemma 4.6 done time O(kk). implies first statement
theorem. procedure used preprocessing step algorithm
proving second statement. time O(kk), preprocessing produces pure literal
sequence L = (l1 , . . . , ln ), contains literal variable . auxiliary data
structures cl(l), lit(C) cnt(l) used preprocessing used later,
stored reconstructed needed.
construction L, assumption Lemma 4.5 satisfied L. method
Lemma 4.5 used find splitting variable formula,
corresponding restrictions either contains empty clause satisfies assumption
Lemma 4.5 L. Hence, sequence L used selecting splitting variable
nodes splitting tree .
DFS search controlled stack postponed nodes, initialized
root search starts. search split sequence descending branches.
descending branches starts removing node stack resuming
search node. visited node two satisfiable successors, DFS continues
one put onto stack. node single satisfiable successor,
stack modified. descending branch ends 1-leaf found.
estimate delay, estimate total time needed construct nodes one
descending branches follows.
indices L splitting variables chosen descending branch monotonically decreasing. Hence, total time needed search splitting variables
one descending branch O(n) and, hence, O(kk).
time needed manipulations formula one descending branch
follows. node removed stack, auxiliary data structures cl(l), lit(C)
cnt(l) computed original formula modified according
sequence settings variables along path root current node.
done time O(kk). Then, node descending branch, assignments
chosen variable computed satisfiable successor selected. one node,
done time O(k), k number occurrences chosen variable
. satisfiable successor selected, auxiliary structures updated according
it. total time needed operations one descending branch O(kk) using
similar argument proof Corollary 6.1.
combining estimates, total time constructing descending branch
and, hence, delay generating two consecutive models, O(kk). 2
394

fiGenerating Models Matched Formula

let us concentrate time complexity selecting splitting variable pure
literal matched formula.
Lemma 6.3. splitting problem relative pure literal matched formulas solved
time O(n kk) input formula n variables.
Proof. Following proof Theorem 5.3, first find pure literal sequence L
done time O(kk) Lemma 6.1. = [L] empty formula,
last variable L splitting variable. Otherwise matched find maximum

matching . step performed time O(kk n) (see Hopcroft & Karp,
1973). Then, search variable x , [x = 0] [x = 1]
matched. variable exists Theorem 5.9. number clauses less
n, variable used matching property. Otherwise, check
every variable, whether [x = a] matched {0, 1}. assignment x = satisfies
matched literal containing x, [x = a] matched. rest proof,
estimate complexity n checks assignments falsifying
matched literal.
Partial assignment performed time O(kk) = O(kk). partial assignment satisfied clauses removed occurences variable x removed
remaining clauses. modify matching matching N [x = a] accordingly, remove pairs containing satisfied clause pair containing x.
|N | = (where number clauses [x = a]), done. Otherwise know
|N | = 1, since one pair containing clause [x = a], specifically,
pair containing literal x, removed forming N . remains check
whether N already maximum matching whether better matching.
tested looking single augmentating path I([x = a]) matching N .
augmentating path found using breadth first search time linear size
graph I([x = a]) (see e.g. Hopcroft & Karp, 1973; Lovasz & Plummer, 1986). Hence,
test, whether [x = a] matched done time O(kk) = O(kk). 2
corollary Lemma 6.3 general bound Theorem 3.3, get
following.
Corollary 6.4. Models pure literal matched formula n variables generated
delay O(n2 kk).
Proof. Lemma 6.3 find splitting variable pure literal matched formula
time O(n kk), time determine satisfiability formulas [x = 0]
[x = 1] well. Theorem 3.3 thus get delay O(n2 kk). 2

7. Linearly Satisfiable Formulas
section consider class linearly satisfiable formulas. results Kullmann
(2000), class generalizes matched formulas pure literal satisfiable
formulas and, combining proofs, class pure literal matched formulas.
section, show possible generate models linearly satisfiable formulas
polynomial delay unless P=NP.
395

fiSavicky & Kucera

consequence, splitting problem relative linearly satisfiable formulas
polynomial complexity unless P=NP. consequence follows unconditionally
Example 7.10, presents linearly satisfiable formula 4 variables,
splitting variable respect class linearly satisfiable formulas.
Let us recall notation introduced Kullmann, used present
definition basic facts concerning linearly satisfiable formulas. l literal,
var(l) variable literal. v partial assignment, v(l) value
assignment literal l.
Definition 7.1 (Kullmann, 2000). Let CNF formula let v non-empty
partial assignment variables . say v simple linear autarky,
associated weight function w assigns variable x evaluated v positive
real number w(x) clauses C
X
X
w(var(l))
w(var(l)) .
(2)
lC,v(l)=1

lC,v(l)=0

Clearly, literal C falsified v, must literal satisfied v
well. Therefore simple linear autarky autarky. Kullmann showed check
whether simple linear autarky v CNF formula find one, exists,
solving several linear programs.
literal l pure formula, partial assignment v(l) = 1 weight
w(var(l)) = 1 simple linear autarky formula. another example, consider
satisfying assignment satisfiable 2-CNFs. assignment weight
variables forms simple linear autarky. Similarly, pure Horn CNFs without unit
clauses satisfiable simple linear autarky assigns value 0 equal weight
variables. hand, pure Horn CNF formula contains unit clause,
satisfiable simple linear autarky. example formula
(x1 ) (x1 x2 ) (x1 x3 ) (x1 x2 x3 ) ,
simple linear autarky Theorem 7.8 Lemma 7.9 below.
considering iterative application simple linear autarkies formula get
class linearly satisfiable formulas defined follows.
Definition 7.2 (Kullmann, 2000). class linearly satisfiable formulas defined
smallest class satisfying following two properties:
1. empty CNF linearly satisfiable.
2. Let CNF, simple linear autarky v [v] linearly
satisfiable. .
words, CNF formula linearly satisfiable subsequent applications
linear autarkies obtain empty formula. composition simple linear autarkies
called linear autarky Kullmann (2000) class linearly satisfiable formulas
therefore consists formulas satisfiable linear autarky. Kullmann showed
matched formulas linearly satisfiable. Since pure literal simple linear
396

fiGenerating Models Matched Formula

autarky, pure literal satisfiable formula linearly satisfiable. Similarly, pure literal
matched formula defined Section 5 linearly satisfiable simple linear autarkies
pure literals concatenated linear autarky resulting matched formula.
matched pure literal satisfiable formulas presented algorithms
generate models formulas polynomial delay, possible extend
result linearly satisfiable formulas unless P=NP. Let us first present construction,
used reduction argument.
Let arbitrary 3-CNF formula variables x1 , . . . , xn clauses c1 , . . . , cm .
Consider new variables y1 , y2 , y3 let formula consisting clauses
(y1 y2 ), (y2 y3 ), (y3 y1 ),
(cj y1 y2 y3 ),
j = 1, . . . ,
(xi y1 )
= 1, . . . , n .
Recall number models formula number satisfying assignments
variables, occurrence it. Hence, next lemma, () ()
defined different sets variables.
Lemma 7.3. Formula linearly satisfiable number models |T ()| =
|T ()| + 1.

Proof. clause ci contains three literals. Hence, clause , number
positive literals least number negative literals. follows
assignment variables 1 equal weight variables defines simple linear
autarky, satisfies . Hence, formula linearly satisfiable.
model satisfies y1 = y2 = y3 . assignment containing y1 = y2 = y3 = 1
model xi = 1 = 1, . . . , n. assignment containing y1 = y2 = y3 = 0
model assignment variables xi model . implies
second part statement lemma. 2
Since formula constructed every 3-CNF formula , lemma implies
following immediate corollary.

Corollary 7.4. NP-complete problem determine, whether general linearly
satisfiable formula least 2 models.
Note implies NP-hardness #SAT problem restricted linearly satisfiable formulas. problem is, fact, #P-complete, since #P-complete
count models monotone formulas, pure literal satisfiable and, hence, linearly
satisfiable.
Example 7.10 below, present linearly satisfiable formula, splitting
variable relative class linearly satisfiable formulas. analysis example,
use characterization simple linear autarkies obtained using clause-variable matrix.
Definition 7.5. Let CNF formula clauses c1 , . . . , cm variables x1 , . . . , xn .
clause-variable matrix formula matrix = {aj,i } dimension n
defined

1 xi cj
1 xi cj
aj,i =

0 otherwise .
397

fiSavicky & Kucera

u Rm , u 0 means uj 0 j = 1, . . . , m. Kullmann showed following
proposition.
Lemma 7.6 (Kullmann, 2000). formula clause-variable matrix simple
linear autarky, nonzero z Rn , Az 0. Moreover,
linear autarky obtained vector z using assignment

1 zi > 0
v(xi ) =
0 zi < 0

zi = 0
weight function w(xi ) = |zi |.
Let us present well-known Farkas lemma form used proof Theorem
7.8.
Theorem 7.7 (Farkas lemma). Let n real matrix b Rn . Then, exactly
one following statements true.
1. vector Rm , 0 = bt .
2. vector z Rn , Az 0 bt z < 0.
linear combination real vectors non-negative coefficients called,
simplicity, non-negative combination.
Theorem 7.8. Assume, formula n variables clauses clausevariable matrix dimension n. Then, exactly one following statements
true:
(a) linear autarky,
(b) every vector Rn non-negative combination rows A.
Proof. First, assume, (a) (b) satisfied. Lemma 7.6 implies
non-zero z Rn , Az 0. (b), non-negative vector Rm ,
= z . Multiplying z right, get
Az = z z < 0 .
contradiction, since Az non-negative.
Assume, (b) satisfied. Hence, vector b Rn , non-negative
combination rows A. Farkas lemma, vector z Rn , Az 0
bt z < 0. Since latter condition implies z non-zero, simple linear
autarky Lemma 7.6 means (a) satisfied. 2
Lemma 7.9. Assume, matrix dimension n, rank(A) = n
vector u Rm components positive, ut = 0. Then, every vector
Rn non-negative combination rows A.
398

fiGenerating Models Matched Formula

Proof. assumption, linear space generated rows Rn . Hence,
every z Rn , v Rm , v = z. sufficiently large real number s,
vector v + su components non-negative (v + su)t = z. 2
Note every linearly satisfiable CNF formula 3 variables splitting
variable relative class linearly satisfiable CNF formulas, since setting variable
constant leads formula 2 variables, quadratic and,
hence, satisfiable linearly satisfiable.
Example 7.10. Denote E = {a {0, 1}4 | 2 a1 + a2 + a3 + a4 3} every Boolean
variable x, let x1 = x x0 = x. formula
(x1 , x2 , x3 , x4 ) =

4
^ _

xai

aE i=1

linearly satisfiable, splitting variable relative class linearly satisfiable
formulas.
Proof. every clause, number positive literals least number negative
literals. Hence, formula linearly satisfiable Lemma 7.6 z = (1, 1, 1, 1).
Since invariant permutation variables, sufficient prove
x4 splitting variable. Since every clause contains negative literal,
(0, 0, 0, 0) = 1. follows formula [x4 = 0] satisfiable. One verify
[x4 = 0] =

3
^ _

xai ,

aE i=1

E = {a {0, 1}3 | 1 a1 + a2 + a3 2}. order prove [x4 = 0]
linearly satisfiable, consider clause-variable matrix columns corresponding
x1 , x2 , x3 ,


1
1 1
1 1
1


1

1
1


1 1 1 .


1
1 1
1 1

1

matrix rank 3, since vectors (2, 0, 0), (0, 2, 0), (0, 0, 2) sum two
rows first three. Moreover, sum rows matrix zero
vector. Hence, formula [x4 = 0] linear autarky Lemma 7.9
Theorem 7.8. 2

8. Conclusion Directions Research
paper, shown possible generate models matched formula
n variables delay O(n2 kk). byproduct shown models
399

fiSavicky & Kucera

pure literal satisfiable formula (i.e. formula satisfiable iterated pure literal
elimination) generated delay O(kk). shown result
cannot generalized class linearly satisfiable formulas since possible
generate models linearly satisfiable formulas polynomial delay unless P=NP.
Let us mention procedure generating models bounded delay
extended formulas small strong backdoor set respect class
matched formulas empty clause detection found. Let us assume B
backdoor set formula , i.e. B set variables satisfying partial
assignment variables B leads matched formula, formula containing
empty clause. generate decision tree (and thus generate models)
time O(2|B| kk + (f ) n2 kk). Unfortunately, searching strong backdoor sets
respect class matched formulas hard (Szeider, 2007).
algorithms described paper cases pure literal satisfiable pure
literal matched formulas used general algorithm model enumeration
based splitting tree. This, turn, DPLL based enumeration algorithm.
end, similar approach one described Stefan Szeider (2003) used.
Together formula would keep maximum matching I(). maximum
matching maintained reduction assignment steps performed
enumeration algorithm. algorithm arrives matched formula,
select splitting variables way described paper guaranteed
polynomial delay.
interesting question whether approach could used parameterized
satisfiability algorithm based maximum deficiency (see Szeider, 2003) order get
parameterized algorithm generating models general formula.

Acknowledgments
Petr Savicky supported CE-ITI GACR grant number GBP202/12/G061
institutional research plan RVO:67985807. Petr Kucera supported
Czech Science Foundation (grant GA15-15511S).

References
Aceto, L., Monica, D., Ingolfsdottir, A., Montanari, A., & Sciavicco, G. (2013). Logic
Programming, Artificial Intelligence, Reasoning: 19th International Conference,
LPAR-19, Stellenbosch, South Africa, December 14-19, 2013. Proceedings, chap.
Algorithm Enumerating Maximal Models Horn Theories Application
Modal Logics, pp. 117. Springer Berlin Heidelberg, Berlin, Heidelberg.
Aharoni, R., & Linial, N. (1986). Minimal non-two-colorable hypergraphs minimal
unsatisfiable formulas. Journal Combinatorial Theory, Series A, 43 (2), 196 204.
Bollobas, B. (1998). Modern Graph Theory, Vol. 184 Graduate Texts Mathematics.
Springer.
400

fiGenerating Models Matched Formula

Coquery, E., Jabbour, S., Sais, L., Salhi, Y., et al. (2012). SAT-based approach
discovering frequent, closed maximal patterns sequence. Proceedings
ECAI.
Creignou, N., & Hebrard, J.-J. (1997). generating solutions generalized satisfiability
problems. Informatique theorique et applications, 31 (6), 499511.
Creignou, N., Olive, F., & Schmidt, J. (2011). Theory Applications Satisfiability
Testing - SAT 2011: 14th International Conference, SAT 2011, Ann Arbor, MI, USA,
June 19-22, 2011. Proceedings, chap. Enumerating Solutions Boolean CSP
Non-decreasing Weight, pp. 120133. Springer Berlin Heidelberg, Berlin, Heidelberg.
Dechter, R., & Itai, A. (1992). Finding solutions find one. AAAI-92
Workshop Tractable Reasoning, pp. 3539.
Fleischner, H., Kullmann, O., & Szeider, S. (2002). Polynomial-time recognition minimal unsatisfiable formulas fixed clause-variable difference. Theoretical Computer
Science, 289 (1), 503 516.
Flum, J., & Grohe, M. (2006). Parameterized complexity theory (1st edition)., Vol. 3
Texts Theoretical Computer Science. EATCS Series. Springer-Verlag Berlin
Heidelberg.
Franco, J., & Van Gelder, A. (2003). perspective certain polynomial-time solvable
classes satisfiability. Discrete Appl. Math., 125 (2-3), 177214.
Garey, M., & Johnson, D. (1979). Computers Intractability: Guide Theory
NP-Completeness. W.H. Freeman Company, San Francisco.
Genesereth, M., & Nilsson, N. (1987). Logical Foundations Artificial Intelligence. Morgan
Kaufmann, Los Altos, CA.
Hopcroft, J. E., & Karp, R. M. (1973). n5/2 algorithm maximum matchings
bipartite graphs. SIAM Journal computing, 2 (4), 225231.
Jabbour, S., Lonlac, J., Sais, L., & Salhi, Y. (2014). Extending modern sat solvers
models enumeration. IEEE 15th International Conference Information Reuse
Integration (IRI), 2014, pp. 803810. IEEE.
Johnson, D. S., Yannakakis, M., & Papadimitriou, C. H. (1988). generating maximal
independent sets. Information Processing Letters, 27 (3), 119 123.
Kang, H.-J., & Park, I.-C. (2005). Sat-based unbounded symbolic model checking.
Computer-Aided Design Integrated Circuits Systems, IEEE Transactions on,
24 (2), 129140.
Kavvadias, D. J., Sideri, M., & Stavropoulos, E. C. (2000). Generating maximal models
Boolean expression. Information Processing Letters, 74 (34), 157162.
Khuller, S., & Vazirani, V. V. (1991). Planar graph coloring self-reducible, assuming
P 6= N P . Theoretical Computer Science, 88 (1), 183 189.
Kullmann, O. (2000). Investigations autark assignments. Discrete Applied Mathematics,
107 (13), 99 137.
401

fiSavicky & Kucera

Kullmann, O. (2003). Lean clause-sets: generalizations minimally unsatisfiable clausesets. Discrete Applied Mathematics, 130 (2), 209 249. Renesse Issue Satisfiability.
Lovasz, L., & Plummer, M. D. (1986). Matching Theory. North-Holland.
McMillan, K. L. (2002). Computer Aided Verification: 14th International Conference,
CAV 2002 Copenhagen, Denmark, July 2731, 2002 Proceedings, chap. Applying SAT
Methods Unbounded Symbolic Model Checking, pp. 250264. Springer Berlin Heidelberg, Berlin, Heidelberg.
Minoux, M. (1988). LTUR: simplified linear time unit resolution algorithm Horn
formulae computer implementation. Information Processing Letters, 29, 1 12.
Morgado, A., & Marques-Silva, J. (2005a). Algorithms propositional model enumeration counting. Tech. rep., Instituto de Engenharia de Sistemas e Computadores,
Investigacao e Desenvolvimento, Lisboa.
Morgado, A., & Marques-Silva, J. (2005b). Good learning implicit model enumeration. Tools Artificial Intelligence, 2005. ICTAI 05. 17th IEEE International
Conference on, pp. 6 pp.136.
Murakami, K., & Uno, T. (2014). Efficient algorithms dualizing large-scale hypergraphs.
Discrete Applied Mathematics, 170, 8394.
Sipser, M. (2006). Introduction Theory Computation, Vol. 2. Thomson Course
Technology Boston.
Szeider, S. (2003). Minimal unsatisfiable formulas bounded clause-variable difference
fixed-parameter tractable. Warnow, T., & Zhu, B. (Eds.), Computing
Combinatorics, Vol. 2697 Lecture Notes Computer Science, pp. 548558. Springer
Berlin Heidelberg.
Szeider, S. (2005). Generalizations matched CNF formulas. Annals Mathematics
Artificial Intelligence, 43 (1-4), 223238.
Szeider, S. (2007). Matched formulas backdoor sets. Marques-Silva, J., & Sakallah,
K. A. (Eds.), Theory Applications Satisfiability Testing SAT 2007, Vol. 4501
Lecture Notes Computer Science, pp. 9499. Springer Berlin Heidelberg.
Tovey, C. A. (1984). simplified NP-complete satisfiability problem. Discrete Applied
Mathematics, 8 (1), 85 89.
Valiant, L. (1979a). complexity computing permanent. Theoretical Computer
Science, 8 (2), 189 201.
Valiant, L. (1979b). complexity enumeration reliability problems. SIAM Journal
Computing, 8 (3), 410421.

402


