Journal Artificial Intelligence Research 56 (2016) 613-656

Submitted 03/16; published 08/16

Datalog Ontology Consolidation
Cristhian Ariel D. Deagustini
Mara Vanina Martnez
Marcelo A. Falappa
Guillermo R. Simari

cadd@cs.uns.edu.ar
mvm@cs.uns.edu.ar
mfalappa@cs.uns.edu.ar
grs@cs.uns.edu.ar

AI R&D Lab., Institute Computer Science Engineering (ICIC)
Consejo Nacional de Investigaciones Cientficas Tecnicas (CONICET)
Universidad Nacional del Sur (UNS), Alem 1253,
(B8000CPB) Baha Blanca, Argentina.

Abstract
Knowledge bases form ontologies receiving increasing attention
allow clearly represent available knowledge, includes knowledge constraints imposed domain users. particular, Datalog
ontologies attractive property decidability possibility
dealing massive amounts data real world environments; however,
case many ontological languages, application collaborative environments
often lead inconsistency related issues. paper introduce notion incoherence regarding Datalog ontologies, terms satisfiability sets constraints,
show specific conditions incoherence leads inconsistent Datalog ontologies.
main contribution work novel approach restore consistency
coherence Datalog ontologies. proposed approach based kernel contraction
restoration performed application incision functions select formulas
delete. Nevertheless, instead working minimal incoherent/inconsistent sets encountered ontologies, operators produce incisions non-minimal structures called
clusters. present construction consolidation operators, along properties
expected satisfied them. Finally, establish relation construction properties means representation theorem. Although proposal
presented Datalog ontologies consolidation, operators applied
types ontological languages, Description Logics, making apt used
collaborative environments Semantic Web.

1. Introduction
integration different systems, interaction resulting integration, led
host pervasive practical problems challenging research opportunities;
interesting ones occurs Webs collaborative environments, e.g., e-commerce,
arrival Semantic Web, ontology engineering. However,
collaboration among systems brings along problem conflicting pieces information
likely appear knowledge repositories evolve. Admittedly, management
conflicting information important challenging issue faced (Gomez,
Chesnevar, & Simari, 2010; Haase, van Harmelen, Huang, Stuckenschmidt, & Sure, 2005;
Huang, van Harmelen, & ten Teije, 2005; Bell, Qi, & Liu, 2007), specially integrating
c
2016
AI Access Foundation. rights reserved.

fiDeagustini, Martinez, Falappa & Simari

knowledge coming different sources (Black, Hunter, & Pan, 2009; Baral, Kraus, &
Minker, 1991; Amgoud & Kaci, 2005), knowledge expected exploited
reasoning process. context, knowledge bases form ontologies becoming useful device provide convenient way represent intensional
extensional knowledge application domain. Moreover, expressive power ontologies allows perform important tasks data integration (Lenzerini, 2002), plays
role great importance aforementioned Semantic Web (Berners-Lee, Hendler, &
Lassila, 2001). work adopt Datalog ontologies, family rule-based ontology
languages (Cal, Gottlob, & Lukasiewicz, 2012). Datalog enables modular rule-based
style knowledge representation, represent syntactical fragments first-order
logic (FOL) answering Boolean Conjunctive Query (BCQs) Q set
Datalog rules input database equivalent classical entailment check
|= Q. Tractable fragments Datalog guarantee termination query answering
procedures polynomial time data complexity first-order rewritability. Moreover, ontologies described using existential rules generalize several well-known Description
Logics (DLs); particular, linear guarded Datalog (two basic tractable fragments
family) strictly expressive whole DL-Lite family (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2005), guarded Datalog strictly expressive
EL (Brandt, 2004; Baader, Brandt, & Lutz, 2005). Therefore, results presented
paper extend directly DLs well. properties Datalog together
expressive power, fact keeps syntax closer used relational
databases greater readability, make useful modeling real applications,
ontology querying, Web data extraction, data exchange, ontology-based data access,
data integration.
focus two particular problems arise integration and/or evolution
information systems: inconsistency incoherence. Inconsistency refers lack
models theory. hand, ontological settings, incoherence refers set
ontological rules cannot applied without leading violations constraints
imposed knowledge, making unsatisfiable. Incoherence inconsistency,
arise automated procedures data integration ontology matching, may
serious issues real world applications. Since standard ontology languages adhere
classical FOL semantics, classical inference semantics fails presence kind
problems. Thus, important focus formalization methods address
inconsistency incoherence ontologies able cope users expectations
terms effectiveness procedures query answering meaning
answers potential conflict exists.
paper addresses problem handling inconsistencies incoherences
may appear Datalog ontologies. regard, propose general framework
aims consolidation Datalog ontologies (i.e., solving every conflict coherence
consistency them). is, consolidation operator takes input (possibly)
incoherent inconsistent Datalog ontology returns another Datalog ontology
conflicts amended, thus ensuring coherent consistent.
usual setting, assumption minimal change made, say,
expected consolidation process changes original ontology little possible.
approach presented based use incision functions (Hansson, 1993, 1994, 1997,
614

fiDatalog Ontology Consolidation

2001) Belief Revision literature. Instead operators account
information included conflicts knowledge base, work aim capture
consolidation operators consider information included KB solving
conflicts. main contributions work following:
introduce notion incoherence tailored Datalog . achieve adapt
setting similar notions Description Logics. Also, look relationship incoherence inconsistency impacts consolidation process.
provide set properties expected satisfied consolidation operators
Datalog ontologies means postulates. postulates provide formal
characterization consolidation operator without focusing consolidation
process actually performed, thus providing formal comparison framework
consolidation operators. postulates consider intuitions classic Belief
Revision; nevertheless, adapted Datalog ontological setting (and
could adapted suit ontological languages), meaning
two versions (one addressing incoherence another one inconsistency).
present complete construction consolidation operators take (possibly)
incoherent inconsistent Datalog ontology gives result consistent
coherent one. noteworthy characteristic operators involves two
steps approach, first considering incoherence conflicts, solving inconsistency
conflicts latter step, helping improve final result terms information
needs deleted solve conflicts.
study relationship formal properties operator
construction propose, demonstrating equivalent; thus, shows
consolidation operator satisfying properties corresponds construction
introduced work.
paper organized follows: Section 2 introduce necessary notions
Datalog Belief Revision. Next, though inconsistency incoherence related,
two distinct problems setting ontological knowledge bases
particular, clear separation intensional extensional knowledge.
Therefore, Section 3, discuss two notions Datalog ontologies, relate
other, reasons need treated combination separately.
Then, Section 4 present properties ontology consolidation operator must
satisfy, Section 5 introduce process used restore consistency coherence
Datalog ontologies, relate presented process given properties means
representation theorem. Next, present complete example depicting entire
consolidation process. Finally, Sections 7 8 discuss related work different
areas Artificial Intelligence Database Theory, provide conclusions future
lines research, respectively.

2. Preliminaries Background
facilitate reading, begin introducing notions Datalog Belief
Revision needed rest paper.
615

fiDeagustini, Martinez, Falappa & Simari

2.1 Preliminaries Datalog
First, recall basic notions Datalog ontologies used paper
(see Cal et al., 2012 details). Datalog extends Datalog allowing existential
quantification rule heads, together extensions enumerate below,
limiting interaction elements order achieve tractability.
assume domain discourse Datalog ontology consists
countable set data constants , countable set nulls N (as place holders unknown
values), countable set variables V. assume different constants represent
different values (unique names assumption). distinguish constants variables,
adopt standard notation logic programming, variable names begin
uppercase letters, constants predicate symbols begin lowercase letters.
assume relational schema R finite set predicate symbols (or simply predicates). term constant, null, variable. atom form p(t1 , . . . , tn ),
p n-ary predicate t1 , . . . , tn terms; atom ground iff terms
constants. Let L first-order language R L; LR denotes
sublanguage generated R. database (instance) R finite set atoms predicates R terms N . homomorphism constants, nulls variables
mapping h : N V N V (i) c implies h(c) = c, (ii)
c N implies h(c) N , (iii) h naturally extended atoms, sets atoms,
conjunctions atoms.
Given relational schema R, tuple-generating dependency (TGD) first-order
formula form XY(X, Y) Z(X, Z) (X, Y) (X, Z) conjunctions atoms R called body (denoted body()) head (denoted head()),
respectively. Consider database relational schema R, TGD R
form (X, Y) Z (X, Z). Then, applicable exists homomorphism
h maps atoms (X, Y) atoms D. Let applicable D, h0
homomorphism extends h follows: Xi X, h0 (Xi ) = h(Xi );
Zj Z, h0 (Zj ) = zj , zj fresh null, i.e., zj N , zj occur D, zj
lexicographically follows nulls already introduced. application adds
atom h0 ((X, Z)) already D. application say
satisfied D. Chase database set TGDs , denoted chase(D, ),
exhaustive application TGDs (Cal et al., 2012) breadth-first (level-saturating) fashion, leads (possibly infinite) chase . important
remark BCQs Q evaluated chase , i.e.,
|= Q equivalent chase(D, ) |= Q (Cal et al., 2012).
Negative constraints (NCs) first-order formulas form X(X) ,
(X) conjunction atoms (without nulls) head truth constant false,
denoted . NC satisfied database set TGDs iff
exist homomorphism h maps atoms (X) D, every
TGD satisfied, i.e., atoms body cannot true together.
Equality-generating dependencies (EGDs) first-order formulas form
X(X) Xi = Xj , (X) conjunction atoms, Xi Xj variables X. EGD satisfied database R iff, whenever exists
homomorphism h h((X)) D, holds h(Xi ) = h(Xj ). work
616

fiDatalog Ontology Consolidation

focus particular class EGDs, called separable (Cal et al., 2012); intuitively,
separability EGDs w.r.t. set TGDs states that, EGD violated, atoms
contained reason violation (and application TGDs); i.e.,
EGD E violated apply TGDs database D, EGD
violated D. Separability standard assumption Datalog ontology, one
important features family languages focus decidable (Cal,
Lembo, & Rosati, 2003) (actually tractable) fragments Datalog .
NCs EGDs play important role matter conflicts Datalog ontologies.
fact, approach present work ensure neither NCs EGDs
violated resulting ontology. Also, important remark, note restriction
using separable EGDs makes certain cases conflicts considered
proposal. treatment cases, though interesting technical point view,
outside scope work since focus tractable fragments Datalog .
usual case literature, general universal quantifiers TGDs,
negative constraints EGDs omitted, sets dependencies constraints
assumed finite. presented different ways expressing
knowledge Datalog , ready formally define Datalog ontologies.
Definition 1 (Datalog Ontology) Datalog ontology KB = (D, ), =
E NC , consists database instance finite set ground atoms (without
nulls), set TGDs , set separable EGDs E set NCs NC .
Otherwise explicitly said, paper clear context refer
component KB set constraints ontology, without distinguishing
dependencies constraints. Given database R set constraints
= E NC , set models , denoted mods(D, ), set
databases B B every formula satisfied. following
example shows simple Datalog ontology; ontology describes knowledge
therapy/psychology domain.
Example 1 (Datalog Ontology)

D: {a1 : therapy(charlie), a2 : dating(kate, charlie),




a3 : therapist(kate), a4 : belongs to(g1 , charlie),






5 : therapy(patrick ), a6 : belongs to(g2 , ed ),





7 : belongs to(g1 , kate)}







NC : {1 : treating(T , P ) dating(T , P ) }
KB =


E : {1 : treating(T , P ) treating(T 0 , P ) = 0 }








: {1 : therapy(P ) patient(P ),




2 : therapist(T ) belongs to(G, ) leads(T , G),




3 : leads(T , G) belongs to(G, P ) treating(T , P ),



4 : treating(T , P ) therapist(T )}













































set TGDs expresses dependencies as: TGD 1 states person P
therapy P patient, 2 establishes therapist belongs group
617

fiDeagustini, Martinez, Falappa & Simari

G leader group. NC 1 states patient cannot dating
therapist, EGD 1 states every patient treatment one therapist.
Following classical notion consistency, say consistent Datalog ontology
non-empty set models.
Definition 2 (Consistency) Datalog ontology KB = (D, ) consistent iff
mods(D, ) 6= . say KB inconsistent otherwise.
Example 2 Consider Datalog ontology example above; ontology clearly

inconsistent. Database instance clearly model since least TGD 2
applicable D, superset satisfies TGDs constraints time. instance TGDs 2 applicable creating atom
leads(kate, g1 ) making 3 applicable resulting new atom treating(kate, charlie),
together dating(kate, charlie) (that already D) violate NC 1 ,
therapist dating one patients.
rest paper, otherwise explicitly stated KB = (D, ) denote Datalog
ontology = E NC , database instance, set
TGDs, E set separable EGDs NC set NCs .
2.2 Background Belief Revision
Establishing origins scientific ideas difficult task sometimes controversial; nevertheless, could argued origins belief change theory go back
work Isaac Levi (1977), discussed problems concerning field research,
William Harpers proposal rational way interrelate belief change operators (Harper, 1975). However, main advances belief change theory came
1980s Carlos Alchourron David Makinson studied changes legal codes (Alchourron & Makinson, 1981), Peter Gardenforss introduced rational postulates
change operators (Gardenfors, 1982). that, three authors produced foundational paper containing became known AGM model (Alchourron, Gardenfors,
& Makinson, 1985). core contribution AGM model presentation
new general formal framework study belief change; today, work
considered cornerstone belief change theory evolved.
Since introduction AGM model, different frameworks belief dynamics
respective epistemic models proposed. epistemic model corresponds
formalism beliefs represented, providing framework different
kinds operators defined. AGM model conceived idealistic theory
rational change epistemic states represented belief sets (sets sentences
closed logical consequence, commonly denoted boldface), epistemic input
represented sentence. AGM model, three basic change operators defined:
expansion, contraction, revision. rest section, whenever use term
consistent inconsistent, refer traditional notion inconsistency knowledge
base models. Let K belief set, change operations follows:
618

fiDatalog Ontology Consolidation

Expansions: result expanding K sentence possibly larger set
infers ; intuitively, belief , hopefully consistent given epistemic state,
directly added K.
Contractions: result contracting K possibly smaller set
infer , unless tautology;
Revisions: result revising K set neither extends part
set K. general, fallacy consistently inferred
revision K .
great importance AGM comes providing axiomatic characterizations contraction revision terms rationality postulates. rationality postulates regard
operators black boxes, characterizing do, explaining
it. words, behavior constrained regard inputs basic cases,
without describing internal mechanisms used achieving behavior, crucial
say contraction revision operators obtained via constructive
approaches. AGM contractions realized partial meet contractions,
based selection among (maximal) subsets K imply . Via Levis
identity (Gardenfors, 1988), associated revision operations called partial meet revisions
obtained. Another possible approach contraction based selection among
(minimal) subsets K contribute make K imply , safe contraction (Alchourron & Makinson, 1985). general variant approach, known
kernel contraction, introduced later (Hansson, 1994). shown safe
contractions kernel contractions equivalent partial meet contractions, hence
AGM approach contraction (Hansson, 1994, 2001).
particularly interesting characteristic kernel contraction may concerned
changes symbolic level since suitable applied belief bases (set
sentences closed consequence relation) well belief sets. Thus, matters
beliefs actually represented. happen AGM approach,
studies changes knowledge level since uses belief sets. distinction
knowledge symbolic level proposed Allen Newell (1982). According Newell,
knowledge level lies symbolic level, latter used somehow represent
former. this, belief bases different symbolic content may represent
knowledge. importance that, although statically equivalent
(they represent beliefs), equivalent belief bases could dynamically different
choose use approach working directly them, kernel contraction.
Besides three basic operations mentioned, years additional operations
developed Belief Revision achieve different behaviors. instance,
belief base inconsistent, removal enough sentences lead consistent
state. additional operation called consolidation, consolidation belief base
K denoted K ! (see Hansson, 1991, 2001). focus last operation,
inherently different contraction revision, since ultimate goal obtain
consistent belief base possibly inconsistent one (without given epistemic
input), rather revising knowledge base specific formula removing
particular formula it. consolidation K obtained natural way belief
619

fiDeagustini, Martinez, Falappa & Simari

bases contracting falsum, i.e., K ! = K , represents contraction
operator; process restores consistency attending every conflict K (Hansson, 1991).

3. Incoherence Inconsistency Problems Related Datalog
Ontology Consolidation
problem obtaining consistent knowledge inconsistent knowledge base
natural many computer science fields. knowledge evolves, contradictions likely
appear, inconsistencies handled way affect
quality information obtained database.
setting Consistent Query Answering (CQA), repairing relational databases,
inconsistency-tolerant query answering ontological languages (Arenas, Bertossi, &
Chomicki, 1999; Lembo, Lenzerini, Rosati, Ruzzi, & Savo, 2010; Lukasiewicz, Martinez, &
Simari, 2012), often assumption made set expresses semantics
data component D, internal conflict set constraints
constraints subject changes time. means first, set
always satisfiable, sense application inevitably yield consistency
problem. Second, result assumption, must case conflicts come
data contained database instance, part ontology
must modified order restore consistency. Although reasonable assumption
make, specially case single ontology, work focus
general setting, consider data constraints change time
become conflicting. general scenario, knowledge evolves (and ontology
represents it) data related issues appear, constraint related ones.
argue important identify separate sources conflicts
Datalog ontologies. previous section defined inconsistency Datalog
ontology based lack models. operational point view, conflicts appear
Datalog ontology whenever NC EGD violated, is, whenever body
one constraint mapped either atoms atoms obtained
application TGDs . Beside conflicts,
focus relationship set TGDs set NCs EGDs,
could happen (a subset of) TGDs cannot applied without leading
always violation NCs EGDs. Note case clearly data
database instance problem, database TGDs applicable
inevitable produce inconsistent ontology. issue related unsatisfiability
problem concept ontology, known Description Logics community
incoherence (Flouris, Huang, Pan, Plexousakis, & Wache, 2006; Schlobach & Cornet, 2003;
Borgida, 1995; Beneventano & Bergamaschi, 1997; Kalyanpur, Parsia, Sirin, & Hendler,
2005; Schlobach, Huang, Cornet, & van Harmelen, 2007; Qi & Hunter, 2007). Incoherence
particularly important combining multiple ontologies since constraints
imposed one data could (possibly) represent conflicting models
application hand. Clearly, notions incoherence inconsistency highly
related; fact, Flouris et al.s (2006) work establish relation incoherence
inconsistency, considering incoherence particular form inconsistency.
620

fiDatalog Ontology Consolidation

Later section present complete definition incoherence Datalog , based
concept unsatisfiability sets TGDs. Nevertheless, sufficient
know proposed notion incoherence states given set unsatisfiable
constraints possible find set atoms KB = (D, ) consistent
ontology time TGDs applicable D. means
Datalog ontology consistent even set constraints incoherent, long
database instance make dependencies applicable. hand,
Datalog ontology inconsistent even set constraints satisfiable,
e.g., KB = ({tall(peter), small(peter)}, {tall(X) small(X) }), (empty)
set dependencies trivially satisfiable thus ontology coherent; ontology is,
nevertheless, inconsistent.
formalizing notion incoherence use Datalog setting
need identify set atoms relevant given set TGDs. Intuitively, say
set atoms relevant set TGDs atoms set
application generates atoms needed apply TGDs , i.e.,
triggers application every TGD .
Definition 3 (Relevant Set Atoms Set TGDs) Let R relational
schema, set TGDs, (possibly existentially closed) non-empty set
atoms, R. say relevant iff form
XY(X, Y) Z(X, Z) holds chase(A, ) |= XY(X, Y).
clear context, singleton set = {a} relevant
say atom relevant .
Example 3 (Relevant Set Atoms) Consider following constraints:

= {1 : supervises(X , ) supervisor (X ),
2 : supervisor (X ) makes decisions(X ) leads department(X , D),
3 : employee(X ) works in(X , D)}
Consider set A1 = {supervises(walter , jesse), makes decisions(walter ), employee(jesse)}.
set relevant set atoms set constraints = {1 , 2 , 3 }, since 1
3 directly applicable A1 2 becomes applicable apply 1 (i.e.,
chase entails atom supervisor (walter ), together makes decisions(walter )
triggers 2 ).
However, set A2 = {supervises(walter , jesse), makes decisions(gus)} relevant
. Note even though 1 applicable A2 , TGDs 2 3 never applied
chase(A2 , ), since atoms bodies never generated chase(A2 , ).
instance, consider TGD 2 . chase create atom
supervisor(walter), nevertheless still cannot trigger 2 since
cannot generate atom makes decisions(walter ), atom makes decisions(gus)
already A2 match constant value.
present notion coherence Datalog , adapts efforts made
DLs Schlobach Cornets (2003) Flouris et al.s (2006). conception
621

fiDeagustini, Martinez, Falappa & Simari

(in)coherence based notion satisfiability set TGDs w.r.t. set
constraints. Intuitively, set dependencies satisfiable relevant set
atoms triggers application dependencies set produce
violation constraint NC E , i.e., TGDs satisfied along NCs
EGDs KB .
Definition 4 (Satisfiability Set TGDs w.r.t. Set Constraints) Let R
relational schema, set TGDs, N NC E , R. set
satisfiable w.r.t. N iff set (possibly existentially closed) atoms R
relevant mods(A, N ) 6= . say unsatisfiable w.r.t.
N iff satisfiable w.r.t. N . Furthermore, satisfiable w.r.t. NC E iff
unsatisfiable w.r.t. N N NC E .
rest paper sometimes write set TGDs (un)satisfiable omitting
set constraints, context particular ontology
fixed set constraints NC E since set TGDs satisfiable w.r.t. NC E
satisfiable w.r.t. subset and, hand, set TGDs unsatisfiable
w.r.t. subset NC E unsatisfiable w.r.t. whole set constraints.
Example 4 (Unsatisfiable Sets Dependencies) Consider following constraints.

1NC = { : risky job(P ) unstable(P ) }
1T = {1 : dangerous work (W ) works in(W, P ) risky job(P ),
2 : therapy(P ) unstable(P )}
set 1T satisfiable set TGDs, even though simultaneous application
1 2 may violate formula 1NC 1E , hold every relevant
set atoms. Consider example relevant set D1 = {dangerous work (police),
works in(police, marty), therapy(rust)}; D1 relevant set 1T , however,
mods(D1 , 1T 1NC 1E ) 6= 1T satisfiable.
hand, example unsatisfiability consider following constraints:
2NC = {1 : sore throat(X) sing(X) }
2T = {1 : rock singer (X) sing loud (X), 2 : sing loud (X) sore throat(X),
3 : rock singer (X) sing(X)}
set 2T unsatisfiable set dependencies, application TGDs {1 , 2 , 3 }
relevant set atoms cause violation 1 . instance, consider
relevant atom rock singer (axl): application 2T {rock singer (axl)}
causes violation 1 considered together 2T , therefore
mods({rock singer (axl)}, 2T 2NC 2E ) = . Note set relevant atoms
cause violation 1 .
ready formally define coherence Datalog ontology. Intuitively,
ontology coherent subset TGDs unsatisfiable w.r.t.
constraints ontology.
622

fiDatalog Ontology Consolidation

Definition 5 (Coherence) ontology KB coherent satisfiable
w.r.t. NC E . Also, KB said incoherent iff coherent.
Example 5 (Coherence) Consider sets dependencies constraints defined Ex-

ample 4 arbitrary database instance D. see Datalog ontology
KB 1 = (D, 1T 1NC 1E ) coherent, KB 2 = (D, 2T 2NC 2E ) incoherent.
Considering incoherence set TGDs important consolidation process
Datalog ontologies, since treated appropriately within consolidation process,
incoherent set TGDs may lead trivial solution removing every single relevant
atom (in worst case, entire database instance). may adequate
particular domains, seem desirable outcome general case.
Looking Definitions 4 5 see close relationship
concepts incoherence inconsistency. fact, inferred definitions
incoherent KB induce inconsistent KB database instance contains
set atoms relevant unsatisfiable sets TGDs. result captured
following proposition (proofs results presented Appendix A).
Proposition 1 KB incoherent exists relevant
unsatisfiable set U KB = (D, ) inconsistent.
instance relationship, consider following representative example.
Example 6 (Relating Incoherence Inconsistency) Consider following ontology.

KB =


: {a1 : sing(simone), a2 : rock singer (axl ), a3 : sing loud (ronnie),




a4 : fans(ronnie), a5 : rock singer (ronnie), a6 : rock singer (roy),




a7 : manage(band1 , richard )}








NC : {1 : sore throat(X) sing(X) ,




2 : private life(X) famous(X) }



E :








:
















{1 : manage(X, ) manage(X, Z) = Z}
{1
2
3
4
5

: rock singer (X) sing loud (X),
: sing loud (X) sore throat(X),
: fans(X) famous(X),
: rock singer (X) sing(X),
: fans(X) private life(X)}

















































hinted previously Example 4, set = {rock singer (axl)}
unsatisfiable set TGDs U = {1 : rock singer (X) sing loud (X), 2 :
sing loud (X) sore throat(X), 4 : rock singer (X) sing(X)}. Since relevant
U conditions Proposition 1 fulfilled, indeed ontology KB = (D, )
inconsistent since 1 violated.
set constraints one presented Example 6 may appear consider scenarios components ontology evolve (perhaps collaboratively
623

fiDeagustini, Martinez, Falappa & Simari

maintained pool users). long new constraints added, incoherence problems
may arise. particular scenario would seem sensible identify modify,
somehow, set incoherent constraints make satisfiable, instead deleting
information ontology; proceed solve remaining inconsistencies, any. is, could beneficial define consolidation processes
changes performed achieve coherence given higher priority changes needed
consistency possible. address present twofold proposal consolidation Datalog ontologies: is, obtain new KB 0 begin addressing issues
component w.r.t. components E NC original ontology obtain
new coherent set constraints, giving TGDs necessary. Then, address
problems arising component D, obtaining new one D0 consistent
0T E NC . next section characterize, means set postulates,
consolidation operator takes account considerations.

4. Characterizing Consolidation: Postulates Datalog Ontology
Consolidation Operators
Belief Revision one main areas deals defined principled methods solve
incoherences inconsistencies; explained Section 2, common characterize
change operators means postulates, properties operators must satisfy. section introduce set postulates objective characterizing
consolidation operators Datalog ontologies. start briefly defining scenario
underlying consolidation process introducing characteristics sets formulas focus (Friedman & Halpern, 2001).

4.1 Defining Consolidation Environment
Depending type knowledge base, find two main streams work Belief
Revision. one hand, works based sets formulas closed
consequence relation, called belief sets (Alchourron et al., 1985). known
Belief Revision literature coherence model. hand, option
choose belief bases (Katsuno & Mendelzon, 1991, 1992; Fuhrmann, 1991; Hansson, 1994,
1997, 2001; Falappa, Kern-Isberner, & Simari, 2002), i.e., non-closed sets formulas;
referred foundational model.
Opposite traditional closed world assumption found established areas
relational databases, one important characteristic Datalog open world
assumption, unknown data represented means null values. consequence,
generation new information language application rules susceptible
infinite (Cal, Gottlob, & Kifer, 2008, 2013), seems make foundational
model appealing choice working setting. Therefore, consolidation
Datalog ontologies chosen follow foundational model. model,
epistemic state (possibly incoherent inconsistent) Datalog ontology.
624

fiDatalog Ontology Consolidation

4.2 Expected Properties Consolidation Operator: Postulates
present set properties consolidation operator Datalog ontologies
must satisfy. use following notation rest paper. Let KB = (D, )
original Datalog ontology consolidated, = E NC . Also,
KB ! denotes Datalog ontology KB ! = (D!, !) resulting consolidation KB ,
D! ! consolidated components KB !, respectively.
necessary differentiate KBs using subscripts. cases, given KB denote
consolidation KB ! = (Di !, !).
ready introduce Ontology Consolidation Postulates (OCP) expected
satisfied consolidation operators. Let set Datalog ontologies.
Then, Datalog ontology consolidation operator ! : function must
satisfy following properties:
OCP 1. (Inclusion) ! D! D.
consolidation process includes resulting ontology formulas belonging original ontology.
OCP 2. (Consistency) KB ! consistent.
ontology obtained consolidation process must consistent, i.e.,
negative constraints equality-generating dependencies
violated apply TGDs ! atoms D!, therefore
mods({D!, !}) 6= .
OCP 3. (Coherence) KB ! coherent.
ontology obtained consolidation process must coherent, i.e.,
! must satisfiable respect NC E !.
OCP 4. (Minimality): KB 0 KB coherent consistent, holds
KB ! 6 KB 0 .
coherent consistent ontology obtained original ontology strictly contains consolidated ontology.
postulates presented inspired properties proposed Hansson (1994) Konieczny Pino-Perez (2002). Nevertheless, adapted
suit particularities ontological setting Datalog ; particular, take
account distinction incoherence inconsistency. instance, Inclusion
direct adaptation Hanssons homonymous postulate (Hansson, 1994), states
contraction knowledge base (not necessarily proper) subset
original one. Consistency Coherence, hand, result adapting
setting Konieczny Pino-Perezs postulate IC1 (2002), intuitively ask
resulting merging must consistent; ask resulting consolidation
consistent coherent. Minimality postulate added ensure
quality consolidation (w.r.t. loss information aspect), adapted
particular work, rather general notion Belief Revision, noted
625

fiDeagustini, Martinez, Falappa & Simari

Hansson (2001) given many names conservatism (Harman, 2008), conservativity (Gardenfors, 1988), minimum mutilation (Quine, 1986) minimal change (Rott,
1992).
proposed postulates capture notion changes made respect
original ontology necessary, resulting ontology is, expected,
coherent consistent. is, given original ontology consolidation process
removes constraints (TGDs) atoms somehow involved making
original ontology incoherent/inconsistent, makes way unnecessary
removal made.

5. Datalog Ontology Consolidation Operator
previous sections presented examples incoherences inconsistencies
arise Datalog ontologies. Additionally, stated properties consolidation
operator satisfy order make adequate changes original ontology regaining
coherence consistency. Now, propose construction consolidation operator
addresses incoherence inconsistency problems Datalog ontologies.
5.1 Possible Construction Consolidation Operator
literature Belief Revision several constructions revision contraction operators studied. Hansson (1994) presents contraction operation belief
bases modeled means application incision functions. functions
contract belief base formula taking minimal sets entail (called -kernels)
producing incisions sets longer entail . resulting belief base
conformed union formulas removed function.
approach known kernel contraction; task restoring consistency known
belief revision literature contraction falsum (Hansson, 1991). work,
define consolidation process application incision functions. Nevertheless,
instead directly considering minimal inconsistent subsets formulas different
components ontology (which equivalent -kernels), work perform incisions structures called clusters (Martinez, Pugliese, Simari, Subrahmanian, & Prade,
2007; Lukasiewicz et al., 2012) groups together related kernels. specifically,
solve incoherence begin establishing dependency kernels; analogous way,
define data kernels solve inconsistencies w.r.t. , then, based them,
obtain dependency clusters data clusters exploiting overlapping relation.
5.1.1 Identifying Relation among Conflicts
first step towards conflict resolution framework calculate minimal coherence consistency conflicts, identify possible relations among conflicts, any.
Dependency kernels sets TGDs unsatisfiable w.r.t. set NCs EGDs
Datalog ontology minimal set inclusion. sets known Minimal unsatisfiability-preserving sub-TBoxes (MUPS) Minimal incoherence-preserving
sub-TBoxes (MIPS) (Schlobach & Cornet, 2003) DL community.

626

fiDatalog Ontology Consolidation

Definition
6 (Dependency Kernels) set dependency kernels KB , denoted
Q
KB , set X X unsatisfiable set dependencies
w.r.t. NC E every proper subset X 0 X (X 0 ( X) satisfiable w.r.t. NC E .
Example 7 (Dependency Kernels) Consider following sets constraints

Datalog ontology KB :

NC : {1 : counselor (X ) regent(X ) ,




2 : cannot rule(X ) heir (X ) }








E : {1 : advise(X , K ) advise(X , K 0 ) K = K 0 }







: {1 : advise(X , K ) counselor (X ),
KB =
2 : propose law (X , K ) regent(X ),




3 : prince(P ) heir (P ),




4 : son(P , K ) king(K ) prince(P ),




5 : counselor (C ) regent(C ),




6 : bastard son(X , ) son(X , ),



7 : bastard son(X , K ) king(K ) cannot rule(X )}









































KB exist two dependency kernels, i.e.,
Q
KB

= {{3 , 4 , 6 , 7 }, {5 }}.

easy show dependency kernels Datalog ontology independent
particular component ontology, thus obtained looking
component . is, even replace component ontology
empty set atoms, dependency kernels ontology empty database
original one.


Lemma 1 Let KB
Q 1 = (D
Q1 , 1 ) KB 2 = (, 2 ) two Datalog ontologies
1 = 2 . Then, KB 1 = KB 2 .

addition removal TGDs make set unsatisfiable (thus making
ontology incoherent), solve inconsistencies may need remove atoms components order address data inconsistency well. Analogously definition
dependency kernels, define data kernels minimal subset atoms
makes KB = (D, ) inconsistent.

`
Definition 7 (Data Kernels) set data kernels KB , denoted KB , set
X mods(X, ) = every X 0 ( X holds mods(X 0 , ) 6= .
627

fiDeagustini, Martinez, Falappa & Simari

Example 8 (Data Kernels) Consider following coherent inconsistent KB , pro-

posed Lukasiewicz et al. (2012).

KB =


: {directs(john, d1 ), directs(tom, d1 ), directs(tom, d2 ),




supervises(tom, john), works in(john, d1 ), works in(tom, d1 )}








NC : {supervises(X , ) manager (Y ) ,




supervises(X , ) works in(X , D) directs(Y , D) }



E :








:








{directs(X , D) directs(X , 0 ) = 0 }
{1 : works in(X , D) employee(X ),
2 : directs(X , D) employee(X ),
3 : directs(X , D) works in(X , D) manager (X )}





































KB , set data kernels
`
KB



{supervises(tom, john), directs(john, d1 ), works in(john, d1 )},
{supervises(tom, john), directs(john, d1 ), works in(tom, d1 )},
=


{directs(tom, d1 ), directs(tom, d2 )}

know minimal conflicts ontology identify relations among them,
relation exists. this, group related kernels together new structure called
cluster, makes possible achieve optimal solution related kernels. Clusters
obtained overlapping relation defined follows.
Definition 8 (Overlapping, Equivalence) Let L first order language, R L
relational schema, LR sublanguage
generated R. Given LR B LR ,
say overlap, denoted B, iff B 6= . Furthermore, given multi-set first
equivalence relation obtained
order formulas 2LR denote
reflexive transitive closure .
exploiting overlapping among dependency kernels data kernels define
dependency clusters data clusters, respectively.
Q
Definition 9 (Dependency Clusters) Let KB
set Dependency Kernels
Q

KB . Let overlapping relation, K = KB /Q
quotient set equivKB
Q

alence relation obtainedQ
Qover KB . Constraint Cluster set C = [] ,
[] K. denote KB set Constraint Clusters KB .
`
Definition 10 (Data Clusters) `
Let KB set Data Kernels KB . Let

overlapping relation, K = KB /`
quotient set equivalence relation
KB
`

obtained
KB . Data Cluster set C = [] , [] K. denote
`
`
set Data Clusters KB .
KB
Intuitively, dependency cluster groups dependency kernels TGD
common, transitive fashion; data clusters groups data kernels analogous way.
628

fiDatalog Ontology Consolidation

Example 9 (Dependency Clusters Data Clusters) Assume KB

Q

`
= {{1 , 2 }, {1 , 3 }, {4 , 5 }} KB = {{a1 , a2 }, {a1 , a3 }, {a2 , a4 , a5 }}. Then,
two dependency clusters based kernels, grouping first two kernels (due
1 ) remaining kernel another cluster; i.e.,
KB

Q
Q
KB

= {{1 , 2 , 3 }, {4 , 5 }}.

hand, case data clusters
`
`
KB

= {{a1 , a2 , a3 , a4 , a5 }}.

following proposition states that, since clusters based equivalence classes, every
kernel included one one cluster.
Q
Q
Q
PropositionQ
2 KB X some`X KB * X 0
Q
0

X 0 . Analogously,
KB X
`
`
`
`X KB X 6=
0
0
X KB * X X KB X 6= X 0 .
corollary Proposition 2 formula kernel included
one cluster.
Q
Corollary 1 (Corollary

Proposition
2)
Let








KB
`
Q
Q
0
0
forQ
X X KB
/ X 0
`
`all
Qsome KB . Then,
0
0
0








X


X

X KB X 6= X . Analogously,
KB
`
`

/ X 0 X 0 KB X 6= X 0 .
following lemma shall use paper shows example how,
ontological setting Datalog , Leibnizs indiscernibility identicals (von Leibniz,
1976) holds w.r.t. clusters Datalog ontologies, two KBs equivalent
set clusters.
ontologies KB = KB . Then,
Lemma
2 Let KB 1Q
KBQ
2 two Datalog
1
2
`
`
`
`
Q
Q
=

=
.
KB 1
KB 2
KB 1
KB 2

5.1.2 Solving Conflicts: Incision Functions
identified clusters, establish incoherences inconsistencies solved. incision function selects formulas deleted
data dependency clusters.
Definition 11 (General Incision Function) General Incision Function KB
function : (2LR , 2LR ) 2LR following conditions holds:
SQ
Q
S`
`
1. (KB ) ( KB ) ( KB ).
Q
Q
Q
2. X KB KB X holds (Y (KB )) 6= .
`
`
`
3. X KB KB X holds (Y (KB )) 6= .
629

fiDeagustini, Martinez, Falappa & Simari

Q
Q
4. X KB holds = (X (KB )) exists R X
R satisfies conditions 1 2, R ( .
`
`
5. X KB holds = (X (KB )) exists R X
R satisfies conditions 1 3, R ( .
Definition 11 states general incision function selects dependency (data,
respectively) cluster TGDs (atoms, respectively) deletion order restore coherence
(consistency). incision function complies Definition 11 used base
consolidation operator. However, note operator may differentiate
restoring coherence consistency. problem classic literature
Belief Revision since notion incoherence, distinction
rules facts languages propositional logic; thus, consistency conflicts
appear, avoiding need treat incoherences. Nevertheless, ontological setting
Datalog opportunity exploiting fact two different although
related kinds conflicts address separately goal finding solution
better suits needs applications rely kind knowledge bases.
point paper trying make that, knowledge bases form
Datalog ontologies important differentiate, adequately handle, incoherence
inconsistency quality consolidated ontology heavily depends
assuming strive minimal loss process. This, complex setting, needs
careful definition constitutes kernel. see could happen done
properly, consider following example.
Example 10 (Influence Incoherence Consolidation) Consider KB Exam-

ple 6. = 2T 2E 2NC 2T unsatisfiable. explained Example 6, singleton set {rock singer (axl)} NC 1 : sore throat(X)
sing(X) violated, making {rock singer (axl)} inconsistent . Then,
{rock singer (axl)} data kernel (and data cluster, since cannot overlap
kernel) verifiable every singleton set relevant dependency cluster. Thus,

`
`
KB


{rock singer (axl)},



{rock singer (ronnie)},
=
{rock singer (roy)},



{has fans(ronnie)}









Consider cluster {rock singer (axl)}; cluster
({rock singer (axl)}) = rock singer (axl).
`
`
`
`
S`
`
situation holds every cluster KB , thus ( KB ) = ( KB ).
problem example data kernels (and hence data clusters)
computed w.r.t. original component, which, case, contain unsatisfiable sets
constraints. seen Example 10, becomes utter importance
atoms relevant unsatisfiable sets: case, general incision function (and
inconsistency management technique based deletion treat incoherence
conflicts) necessarily delete atoms.
630

fiDatalog Ontology Consolidation

Proposition 3 Let general incision function. relevant X
(KB ).

Q
KB

Clearly, corollary Proposition 3 every atom relevant
unsatisfiable set remove every atom restore consistency.
Corollary 2 (Corollary Proposition 3) LetQ general incision function.
holds relevant X KB (KB ).
seen, incoherence great influence consolidation treated properly
(that is, previously consistency restoration). would seem better compute
data clusters based retained satisfiable part components. Lemma 1
show dependency kernels obtained independently component
original ontology, unsatisfiable sets violate negative
constraint equality-generating
dependency relevant set atoms. Therefore,
Q
Q
first obtain
,

use

incision function
KB
`
` dependency clusters select
TGDs deleted.Q
QThen, calculate KB based result application
incision function KB , way paying attention constraints
prevail consolidation process.
Next, define constraint incision functions data incision functions
used select candidates deletion (from original ontology) restore coherence
consistency, respectively. First, define incision function dependency clusters
helps solve incoherence constraints.
Definition 12 (Constraints Incision Function) Constraint Incision Function KB
function : (2LR , 2LR ) 2LR following conditions hold:
SQ
Q
1. (KB ) ( KB ).
Q
Q
Q
2. X KB KB X holds (Y (KB )) 6= .
Q
Q
3. X KB holds = (X (KB )) exists R X
R satisfies conditions 1 2, R ( .
Intuitively, constraint incision function takes dependency clusters removes TGDs
way resulting KB coherent. Analogously
constraints
incision functions, define data incision functions solve inconsistencies
`
`
.
KB
Definition 13 (Data Incision Function) Data Incision Function function
% : (2LR , 2LR ) 2LR following conditions hold:
S`
`
%(KB ) ( KB ).
`
`
`
X KB KB X holds (Y %(KB )) 6= .
`
`
X KB holds = (X %(KB )) exists R X
R satisfies conditions 13 13, R ( .
631

fiDeagustini, Martinez, Falappa & Simari

Finally, necessary make significant remark regarding usage incision
functions. that, let us first consider following excerpt quoted Hanssons (2001,
cf. p. 122) regarding possible parameters passed selection functions (which
case incision functions) choice affects possible outcomes.
[. . . ] proof uniformity makes essential use fact selection functions defined remainder sets form A, pairs
form hA, i. instead defined selection functions follows:
(A, ) non-empty subset (A, ) non-empty.
(A, ) = {A} empty.

(A, ) would operation similar partial meet contraction respects, would possible (A, ) 6= (A, )
hold = A, standard definition allow [. . . ]
Thus, extending Hanssons observation incision functions use consolidation,
take sets conflicts arguments incisions formulas
removed two different ontologies set conflicts operator
using incision function identical. reason operator could
tell difference ontologies since parameter conflicts,
exactly same. However, chosen restrict family operators
behaviors; instead, model operators whose behavior could select removal
formula equal conflicts, restricted choice. achieve
this, chosen take ontologies parameters; so, fits application domain
operators exploited, formulas conflict could affect
outcome consolidation.
approach presented here, incision function consider TGDs
effect cluster, global effect whole knowledge base. reason
requirement unlike classic models belief revision, language used
greater expressivity fact TGD generates multiple inferences. instance,
framework TGD form XY(X, Y) Z(X, Z) possible
infer multiple instances (X, Z).
see reason behind choice clearly consider following example.
Example 11 Consider following ontologies.


: {p(a), q(a)}





NC : {p(X ) r (X ) }
KB 1 =





: {1 : q(X ) r (X )}








KB 2 =








: {p(a), q(a)}








NC : {p(X ) r (X ) }












{1 : q(X ) r (X ),
2 : p(X ) s(X ),
3 : p(X ) t(X )}













:








KB , set data clusters equal,
632

fiDatalog Ontology Consolidation

`
`
KB 1

=

`
`
KB 2

=



{p(a), q(a)}



use standard approach take clusters arguments incisions, must
remove formula ontologies, explained incision
function therefore cannot choose differently argument.
Nevertheless, suppose particular scenario want remove atoms based
information help infer. case, KB 1 remove
p(a), KB 2 take q(a), since KB 2 formula p(a) triggers
TGDs, thus inferring atoms. achieve type behavior, necessary pass
ontologies parameters, since provides adequate context.
5.1.3 Cluster Contraction-Based Consolidation Operator
Lastly, define consolidation operator Datalog ontologies represents two
different parts consolidation. First, coherence restoration component
obtained based dependency clusters component original ontology.
Second, restoration consistency component obtained based data
clusters w.r.t. ! component obtained applying constraint incision function
original . way achieve behavior stated earlier paper; sense,
give incoherence resolution higher priority, since retain atoms addressing
unsatisfiable sets TGDs instead, choose follow path. cluster contractionbased consolidation operator formally defined follows:
Definition 14 (Cluster Contraction-based Consolidation Operator)
Let KB Datalog ontology, Constraint Incision Function % Data Incision
Function. Also, let KB ? = (D, \ (KB )) Datalog ontology resulting deleting
KB TGDs selected . Cluster contraction-based consolidation operator
KB !, defined follows:
KB ! = (D \ %(KB ? ), \ (KB ))
result KBQ
! Datalog ontology obtained removing,
first, TGDs
`
`
Q
(selected
) atoms (selected %
) original
KB ?
KB
ontology KB . important note that, one hand TGDs removed
, dependency clusters contain EGDs NCs. hand, Data
Incision Function uses KB ? instead KB atoms conflicts
\ (KB ) removed; data clusters calculated based constrains
obtained consolidation .
5.2 Relation Postulates Construction: Representation Theorem
Section 4 introduced properties Datalog consolidation operator
must satisfy. means following representation theorem establish
relationship set postulates Datalog ontology consolidation operator
cluster contraction-based consolidation operator proposed previous
section. follows denote ! consolidation operator defined Definition 14
% correspond arbitrary constraint data incision functions, respectively.
633

fiDeagustini, Martinez, Falappa & Simari

Theorem 1 (Representation Theorem) operator consolidation ! Cluster
Contraction-based Datalog Ontology Consolidation Operator Datalog ontology KB
iff satisfies Inclusion, Coherence, Consistency, Minimality.

6. Complete Example Datalog Ontologies Consolidation
introduced operator allows us consolidate Datalog ontologies
satisfies set expected properties expressed postulates Section 4.
section, complete process consolidation Datalog ontologies depicted
following example.
Example 12 (Consolidation Datalog Ontologies) Suppose (in-

coherent inconsistent) ontology KB shown Figure 1, expresses information
collected certain company.

D:




























NC :













E :
KB =






:




































{a1
a3
a5
a7
a8
a9

: boss(walter ), a2 : supervises(walter , jesse),
: makes decisions(walter ),a4 : makes decisions(jesse),
: supervises(skyler , walter ), a6 : employee(walter ),
: charge (jesse, distribution),
: charge (walter , cooking),
: strike(mike)}

{1 : follows orders(X ) makes decisions(X ) ,
2 : supervises(Y , X ) supervisor (X ) ,
3 : absent(X ) strike(X ) }
{1 : charge (X , ) charge (X , 0 ) = 0 }
{1 : employee(X ) supervised (X ),
2 : supervised (X ) follows orders(X ),
3 : boss(X ) makes profit(X ),
4 : supervises(Y , X ) supervisor (Y ),
5 : supervises(Y , X ) employee(X ),
6 : supervised (X ) makes decisions(X ),
7 : supervised (X ) work (X ),
8 : work (X ) get paid (X ),
9 : work (X ) charge (X , ),
10 : strike(X ) absent(X )}





















































































Figure 1: original ontology consolidated.
Now, begin first part consolidation process (i.e., solving incoherences making set satisfiable) obtain, first step towards obtaining
dependency clusters, dependency kernels KB :
Q
KB

= {{2 , 6 }, {10 }},

based kernels, calculate set dependency clusters KB
Q
Q
= {{2 , 6 }, {10 }}.
KB
634

fiDatalog Ontology Consolidation

Q
Q
Q
Note that, overlap among dependency kernels, KB = KB . Next,
use cluster incision function solve incoherency problems. sake example
assume guide contraction process means quantitative criterion, i.e.,
choosing among possible incisions ones removes fewer formulas, using
plausibility among formulas cardinality incisions same.
following show possible incisions, i.e., satisfying conditions Definition 12.
sets
cluster {2 , 6 } could either remove 2 6 . Since two incisions remove
number atoms assume example 2 plausible 6 ,
thus prefer retain former.
cluster {10 } remove 10 .
Then, particular incision example follows:
({2 , 6 }) = {6 }
({10 }) = {10 }
Now, move next part consolidation process: consistency recovery.
explained before, part operator considers TGDs effectively
included consolidation. particular example ! = \ {6 , 10 }.
let KB ? = (D, !); based KB ? calculate data kernels.
Q
= {{a2 , a4 }, {a3 , a5 }, {a3 , a6 }, {a2 , a5 }}
KB ?
Then, obtain data clusters, are:
Q
Q
= {{a2 , a3 , a4 , a5 , a6 }}
KB ?
Now, solve inconsistencies need consider sets intersection
kernels included clusters empty, using ! instead
this. again, analyze possible incisions (the sets respecting conditions
Definition 13) light number atoms deleted plausibility formulas
them. different possible incisions cluster are:
- remove {a2 , a3 }.
- remove {a2 , a3 , a6 }.
- remove {a2 , a5 , a6 }.
- remove {a4 , a5 , a6 }.
again, sets presented removal induce operator
satisfies postulates, thus captured framework. Nonetheless, explained
example choose remove atoms possible. is,
choose remove {a2 , a3 }),
%({{a2 , a3 , a4 , a5 , a6 }}) = {a2 , a3 })
Then, using Datalog ontology consolidation operator based contraction
clusters one introduced Definition 14 obtain coherent consistent
ontology shown Figure 2.
635

fiDeagustini, Martinez, Falappa & Simari

KB ! =


D! : {boss(walter ), makes decisions(jesse),




supervises(skyler , walter ), employee(walter ),




charge (jesse, distribution),




charge (walter , cooking),




strike(mike)}








NC ! : {follows orders(X ) makes decisions(X ) ,




supervises(Y , X ) supervisor (X ) ,




absent(X ) strike(X ) }



E ! :








! :

































































{in charge (X , ) charge (X , 0 ) = 0 }







{employee(X ) supervised (X ),




supervised (X ) follows orders(X ),




boss(X ) makes profit(X ),




supervises(Y , X ) supervisor (Y ),




supervises(Y , X ) employee(X ),




supervised (X ) work (X ),




work (X ) get paid (X ),



work (X ) charge (X , )}

Figure 2: ontology resulting consolidation.

7. Related Work
closely related work work Croitoru Rodriguez (2015).
work authors present consolidation operators used basis definition
semantics inconsistency tolerant ontology query answering Datalog+ (a
expressive language Datalog , Cal et al., 2012). case work,
work Croitoru Rodriguez (2015) based use Hanssons incision functions
(Hansson, 1994) solve conflicts. Nevertheless, remarkable differences
works well. Among important ones operators presented
Croitoru Rodriguez deal inconsistent ontologies, acknowledgment
incoherence problem made. shown work,
significant impact quality consolidation analysed respect minimal
loss information. Moreover, fact makes that, even though set postulates
works similar spirit, family operators characterized Croitoru
Rodriguez subset ones characterized here. due fact setting
consider (i.e., inconsistent incoherent ontologies) general,
since instance operators remove facts TGDs, Croitoru
Rodriguezs operators since focus inconsistency.
Another closely related work one Lukasiewicz et al. (2012). There, authors define general framework inconsistency-tolerant query answering Datalog
ontologies based notion incision functions. Nevertheless, work focused
enforcing consistency query time obtaining (lazy) consistent answers inconsistent ontology instead consolidating one. Clearly, process must carried
every query posed system, approach obtain new knowledge base
636

fiDatalog Ontology Consolidation

offline manner, knowledge base queried without considering inconsistency issues; approaches prove useful, depending application domain.
Additionally, one KB used rational assumption conflicts
constraints made, therefore notions unsatisfiability
incoherence. stated before, order gain generality chosen drop
assumption, treat incoherence problems well inconsistency ones. addition
works Croitoru Rodriguez Lukasiewicz et al., several works
solve inconsistency incoherence means adapting approaches based Belief
Revision techniques knowledge representation formalism.
7.1 Propositional Knowledge Bases
numerous works revision merging propositional knowledge bases (see,
instance, Konieczny & Perez, 2002; Katsuno & Mendelzon, 1992; Lin & Mendelzon, 1999;
Liberatore & Schaerf, 1998; Everaere, Konieczny, & Marquis, 2008; Konieczny & Perez,
2011; Delgrande, Dubois, & Lang, 2006; Booth, Meyer, Varzinczak, & Wassermann, 2010;
Delgrande, 2011; Delgrande & Jin, 2012; Falappa, Kern-Isberner, Reis, & Simari, 2012),
provided foundations work (fragments of) first order logics.
expected, works deep connections ours, remarkable
differences, shall see.
mentioned throughout paper, work Sven Ove Hansson (1994)
provides inspiration foundations work: follow approach akin Kernel
Contraction several intuitions it, adapted ontological language, Datalog .
consequence, besides treating incoherence provide complete inconsistency
resolution process takes advantage ontological setting, exploiting relation
components ontology define coherence consistency
restored. Also, classic incision functions introduced Hansson produce incision
minimal conflicts. approach, however, work clusters, groupings
kernels, thus always minimal. Then, propose particularization
Hanssons incision functions, focusing incision functions successfully work
clusters.
Konieczny Pino-Perez (2002) made one main contributions merging
conflicting information. work follow intuitions proposed them.
Nevertheless, main difference approach (besides obvious one
aims works, merging vs. consolidation) state final merging
consistent presence consistent (or, terminology, coherent) set
integrity constraints, analyze alternative case.
respect work Lin Mendelzon (1999), besides difference
focus (once merging vs. consolidation), main difference inconsistency
management strategy chosen work conflict solving strategy relies
votes majority establish formulas retained merging. Instead,
chosen introduce particular strategy. Nevertheless, possible adapt
framework use preference relations choose possible incisions (in
similar way shown Example 12). relations indeed designed
comply majority intuition (providing votes,
637

fiDeagustini, Martinez, Falappa & Simari

apply ontology consolidation environment since one ontology), thus
obtaining similar strategy.
work Katsuno Mendelzon (1992) problem knowledge base revision
propositional case addressed. approach, language used
express facts world constraints imposed KB .
Nevertheless, difference (in case) update KB
consolidation KB arises treatment integrity constraints: work
integrity constraints considered invariant updates restore consistency
restricted facts.
works Delgrande (2011), Delgrande Jin (2012) authors present
approach revising propositional knowledge base set sentences, every
sentence set independently accepted inconsistencies
considering whole set. main idea follows AGM theory, differs
that, necessary alter Success postulate suits intuition every
sentence set final revision (since set inconsistent).
Guided principle informational economy, characterize revision
plausible worlds among various maximally consistent subsets set sentences.
parallel Datalog ontology environment, revising component
ontology solve inconsistencies. set sentences inconsistent, union
original KB inconsistent. Nonetheless, important difference
works ours. works authors first solve inconsistencies
set sentences, decide subset characterize revision.
approach different, directly consider inconsistent KB . Then, order solve
problem setting, necessary consider union KB
entire set sentences, apply consolidation operator.
7.2 Knowledge Expressed Description Logics Ontologies, Logic Programs
Relational Databases
focus knowledge representation formalisms closely related
Datalog , mainly family Description Logics (Baader, Calvanese, McGuinness,
Nardi, & Patel-Schneider, 2003) Logic Programming (Lloyd, 1987; Nilsson & Maluszynski, 1995; Gelfond, 2008). remarkable work using belief revision solve conflicts DLs
one Qi, Liu, Bell (2006), based AGM theory (Alchourron
et al., 1985; Gardenfors, 1988). makes work stand
introduce generalizations AGM postulates case DLs, define two
operators knowledge bases, based formulas weakening, satisfy postulates.
main difference approach take account consistency problems ontologies, incoherence treatment provided. pointed earlier,
incoherence lead extreme weakening information, may
take every individual name general concept inclusion.
previously mentioned, notion incoherence inspired Schlobach
Cornets work (2003), among others. paper authors focus definition
processes capable detecting unsatisfiabilities incoherences DLs ontologies, introducing complete algorithms along empirical analysis approach. Nevertheless,
638

fiDatalog Ontology Consolidation

main focus work, authors set aside issue recover
coherence conflict detected, consider inconsistencies.
work presented consolidation process treats incoherence inconsistency,
based use Belief Revision techniques. Thus, approach presented Schlobach
Cornet could potentially useful regarding implementation operators presented work, providing effective way obtaining set kernels
set clusters based.
Black et al. (2009) propose approach capable using information coming
several DL ontologies order answer queries, taking care process incoherence inconsistency. approach based agents argumentative capabilities,
one personal knowledge base form DL ontology. agents use
dialogue games interchange arguments reach agreement answer
certain query. Thus, agents use (possible incoherent/inconsistent) union
ontologies without merging them, still obtain answer influenced every
ontology play. Moreover, approach advantage information lost,
formula deleted ontologies, result inferences obtained
approach superset obtained ontology resulting
consolidation union DL ontologies. Even though authors argue one
advantage proposed approach need waste time effort
performing consolidation KB , one disadvantage computational complexity
associated argumentative reasoning (Parsons, Wooldridge, & Amgoud, 2003; Dunne &
Wooldridge, 2009; Cecchi, Fillottrani, & Simari, 2006) process conducted
query issued online manner. Even though consolidation process
computationally expensive, necessary perform
done offline query answering system becomes available. choice one approach depends highly environment used, i.e.,
size ontologies used, often updates issued KB
critical time consumption system, among considerations; course
set inferences obtained every approach may differ
taken account. consolidation-based approach could suitable
time-dependant systems real-time systems query intensive systems data
tractability associated (a consolidated) Datalog ontology may proven handy.
Another work worth mentioning Kalyanpur, Parsia, Horridge, Sirins
(2007). work verses find justifications entailments Description
Logics ontology. justification simply precise set axioms ontology responsible
particular entailment (Kalyanpur et al., 2007). words, minimal set
axioms sufficient produce entailment, related use kernels mean
obtain clusters part consolidation strategy used. Moreover, Horridge, Parsia,
Sattler (2009) state justifications important repairing inconsistent ontologies.
Thus, could important definition consolidation processes similar
cluster-based consolidation, least one axioms justifications
entailment removed ontology, corresponding entailment longer
holds.(Kalyanpur et al., 2007, p. 269). One main contributions work
definition practical black-box (i.e.,, reasoner independent) techniques allows us
find justifications entailments ontology efficient way. such, evident
639

fiDeagustini, Martinez, Falappa & Simari

work verses different direction still benefit findings.
particular, may possible use developed algorithms part implementation
strategy consolidation operators, adapting used Datalog
dual incoherence/inconsistency setting.
Regarding Logic Programming, several works address problem
merging knowledge bases expressed logic programs, solving inconsistency issues
process. instance, Hue, Papini, Wurbel (2009) introduce merging process
based stable model semantics, using logic Here-and-There (Turner, 2003). Hue
et al. consider merging strategy based pre-orders among deletion candidates called
potential removed sets establish particular way obtain preorders. Instead, assume strategy P given pre-order defines
P . case Lin Mendelzons work (1999), although falls scope
present work certainly adapt framework use similar techniques
choosing incision prevails.
Another notorious work Logic Programming field one Delgrande, Schaub,
Tompits, Woltran (2009). work two different approaches proposed. first
one follows arbitration approach, selecting models program differs least
w.r.t. models programs. work case unsatisfiable programs
studied, similar way consider incoherence leaded unsatisfiable sets TGDs.
Nevertheless, consider unsatisfiability certain program, concept
union programs. Furthermore, strategy solve unsatisfiability simply
leaving unsatisfiable program consideration merging, instead trying
solve conflict somehow. second approach based selection models
special program P0 , thought constraints guiding merging process,
least variations w.r.t. programs merging. approach
seen particular instance approach proposed Konieczny Perez (2002).
area databases, one influential works one Arenas et al.
(1999) Consistent Query Answering, authors propose model theoretic definition consistent answers query relational database potentially inconsistent
set integrity constraints. Intuitively, consistent answers query set atoms
(classical) answers query every repair inconsistent database;
repair set atoms satisfy set constraints close possible
original database. Different notions repairs studied literature, well
different notions means set atoms close possible original
database. proposals based repairing inserting and/or deleting tuples
to/from database (actually, possible actions depend form integrity
constraints expressiveness) notion closeness defined via set inclusion
cardinality. work Arieli, Denecker, Bruynooghe (2007), however, proposes
uniform framework representing implementing different approaches database
repairing based minimizing domain dependent distances. main idea work
show thinking terms (different) distances express preferences among repairs
leads different preferences applied different scenarios. authors show
set repairs obtained using proposed distance functions deviate
obtained using set-inclusion. Furthermore, besides insertion deletion entire tuples several domain independent approaches, e.g., based cardinality
640

fiDatalog Ontology Consolidation

complex objective functions. approach proposed Wijsen (2005) updates
considered primitive theoretical framework; Bohannon et al. (2005) present
cost-based framework allows finding good repairs databases exhibit inconsistencies form violations either functional inclusion dependencies, allowing
updates attribute values. work, two heuristics defining constructing repairs based equivalence classes attribute values; algorithms presented
based greedy selection least repair cost, number performance optimizations explored. quite different semantics repairing proposed Caroprese,
Greco, Zumpano (2009), Caroprese Truszczynski (2011) Active Integrity
Constraints (AICs short); AIC production rule body conjunction
literals, false database consistent, whereas head
disjunction update atoms performed body true (that constraint violated). Repairs defined minimal sets (under set inclusion) update
actions (tuple deletions/insertions) AICs specify set update actions used
restore data consistency. Hence, among set possible repairs, subset
founded repairs consisting update actions supported AICs considered.
works area propose different semantics repairing either explicitly implicitly
considering preference relation among set repairs (cf. Andritsos, Fuxman, & Miller,
2006; Staworko, Chomicki, & Marcinkowski, 2012; Greco & Molinaro, 2012).
recently, area ontology-based data access (OBDA), Lembo et al. (2010)
study adaptation CQA DL-Lite ontologies, called AR (ABox semantics).
work, intersection (IAR) semantics presented sound approximation consistent answers; semantics consists computing intersection repairs answers
obtained there, though (possibly many) AR answers cannot obtained IAR semantics, latter computationally easy obtain DL-Lite family,
i.e., necessary compute whole set repairs order compute intersection. data combined complexity semantics studied (Rosati,
2011) wider spectrum DLs. Also, Rosati (2011) presents intractability results
query answering EL intersection semantics, non-recursive segment
language proved computable polynomial time. recently, Bienvenu
Rosati (2013) propose another family approximations CQA, DL-Lite
family. k-support semantics allows (soundly) approximate set queries entailed
CQA semantics, based k subsets database consistently entail q;
hand, k-defeater semantics approximates complete approximations seeking
sets contradict supporters q. semantics FO-rewritable ontological language standard CQ answering FO-rewritable well, used
conjunction over- under-approximate consistent answers.
Much Black et al. (2009), treatment inconsistencies proposed
semantics related particular queries instead inconsistency whole database.
Thus, attempt obtain final consistent database queried without
considering restrictions. Furthermore, address issues incoherence
inconsistency together; instead approaches either assume set integrity
constraint correctly defines semantics database instance, room
incoherence, treat constraints data alike moment removing ignoring
information, leads type problems discuss Example 10.
641

fiDeagustini, Martinez, Falappa & Simari

techniques may suitable case one single database, presence
incoherence set ICs, case consider several databases together,
approach would lead meaningless empty answers, since subset database
could satisfy constraints would case approach Lukasiewicz
et al. (2012).
related databases field work Lin Mendelzon (1998). There,
database viewed first-order theory without rules, ICs used ensure
consistency final result work Konieczny Perez (2002), presenting ways
solve known database merging problems synonyms homonyms. Nonetheless,
Konieczny Pino-Perezs work, consider problems related set ICs.
Instead, set ICs used merging process unique, choice set
expected performed merge designer. Unlike Lin Mendelzon, made
assumption consolidation environment set ICs conflict-free.
Cholvy (1998) introduces another approach used reason contradictory information. framework represented set axioms inference
rules. Additionally, paper several applications framework introduced,
e.g., solving conflicts among beliefs represented first order databases, facts
ground literals rules integrity constraints deduction rules.
scenario, contradiction obtained application constraints considering several databases together. establishes certain parallel case
inconsistency Datalog ontology. However, main difference work lies
strategy inconsistency management process defined. work,
preference order databases assumed. Instead, chosen restrict
achieve consolidation, thus presenting general approach. Nevertheless, stated
adapt incision functions suit intuition every formula equally
desirable, choosing instance preferences ontologies guideline (if using
approach tasks rather consolidation single ontology), obtaining
inconsistency management strategy akin one introduced Cholvy.
Finally, Meyer, Lee, Booth (2005) use two well-known techniques knowledge
integration propositional case, adapted refined expressiveness DLs.
proposed approach takes knowledge bases produces disjunctive knowledge
base (DKB) result integration. One disadvantage DKBs state
possible options take conflicting knowledge expected exploited
reasoning process rather choosing one them. Thus, contrary approach
final consolidated ontology given, definitive final merging; moreover,
set aside research problems related incoherence integration process.

8. Conclusions Future Work
Collaborative work information exchange becoming key aspects almost system; thus, uttermost importance automatic adequate ways solve
conflicts: knowledge evolves collaborative environment incoherence inconsistency prone arise. knowledge often represented ontologies
collaboratively built, often shared among entities use modify them. One particular way deal conflicts appear application environments
642

fiDatalog Ontology Consolidation

try modify information contained ontology order regain coherence
consistency. paper shown achieve consolidation Datalog
ontologies. introduced concept incoherence Datalog ontologies terms
unsatisfiability sets TGDs, showed relationship classical notion
inconsistency logical theory lacks models.
proposed construction consolidation operators. construction inspired kernel contraction, uses incision functions groupings minimal unsatisfiable/inconsistent sets called clusters solve conflicts. Finally, stated properties
Datalog ontology consolidation operator expected satisfy. showed
operators satisfy respective properties, obtaining result consolidation
new Datalog ontology always coherent consistent minimizing changes
made conflict resolution.
final remark, notice operators take care incoherences ontology. However, rare cases ontology designer introduce unsatisfiable
concepts ontology purpose, model particular feature application domain. case remove incoherence, rather
delete atoms triggering it, any. Clearly, since defined setting
mind behavior cannot achieved operators presented here. Nevertheless,
modify present approach suit setting almost straightforward, provide
identify whether unsatisfiable set TGDs made purpose not.
future work, intend study new constructions Datalog consolidation
operators. this, first plan change general approach, i.e., operators based
formalisms kernel contraction, mainly AGM theory (Alchourron
& Makinson, 1985; Alchourron et al., 1985); then, proposed framework
cluster contraction based consolidation operators fully constructive, depending
application domain may certainly difficult asses effect incisions, i.e.,
may hard decide among family possible incisions one select.
design point view, may easier select perform consolidation
additional information formulas knowledge base,
preference relation can, example, elicited domain experts. general,
could easier expert provide guidelines information application
domain hand could modeled preference relation formulas
ontology rather trying single desired incisions. direction want
explore constructions based exploiting preference relations among formulas
ontologies define different strategies choose formulas delete, possibly tailored
particular scenarios. Mainly, plan analyze two different aspects: relation
operators based preference relations respect ones presented
work, different strategies affect behavior.
Also, work make point differentiating concept inconsistency
incoherence; therefore, need focus languages separate extensional
intensional knowledge, otherwise two notions indistinguishable (as
case propositional logic). sense, choice Datalog due desirable
property generalizing several popular languages classical Datalog, DL-Lite, ELH,
F-Logic-Lite, etc. Even though paper perform particular analysis
effects nulls proposed solutions consolidation, Datalog family languages
643

fiDeagustini, Martinez, Falappa & Simari

chosen offers wide variety languages high computational tractability
(some FO rewritable others PTIME inference algorithms). results
work pave way continue research line next natural step, show
(or whether) different syntactic semantic properties yield tractability
query answering allow us obtain tractability results consolidation problem,
much way happened already area consistent query answering
(where repairs extensional part KB considered). is, example,
rewriting algorithms capability value invention plays important role:
value invention process controlled (in general syntactic restrictions) order
keep low complexity reasoning tasks. mind, future
look role processes value invention consolidation Datalog
ontologies, impact conflicts solved computational
efficiency.
currently working implementation operators; plan study different techniques used order produce efficient implementation, possibly
tailored specific fragments Datalog . explained before, algorithms introduced
Schlobach Cornet (2003) proven useful regarding aspect since may
provide way calculate kernels Datalog ontology, thus providing first step
towards incoherence resolution. Another important work regarding implementation
consolidation operators one Wassermann (2000), author shows
minimal incision functions knowledge base obtained kernels KB
using algorithm finding minimal hitting sets (Reiter, 1987). Several works
area ontology debugging repairs, (e.g., Halaschek-Wiener & Katz, 2006, Horridge
et al., 2009 way find justifications inconsistency) exploited Reiters
algorithms order implement frameworks. Among others, plan study
adequate techniques operators, almost direct relation
minimal incision functions Reiters minimal hitting sets; way, may possible adapt Reiter techniques attend incoherences inconsistencies, moreover,
already discussed, plan analyze relation cluster incision functions
preference relations. Regarding implementation, hold conjecture relations
exploited refine implementation operators: Reiters algorithm
based expansion directed acyclic graph, expansion made
breadth first fashion, end generates possible values minimal incision
functions. acknowledged Wassermann, kind ordering among formulas
present, ordering used choose branch expand; words,
may possible implement construction operators proposed work
means exploiting Reiters hitting sets algorithm, use preference
relation equivalent incision (if any) guide consolidation process. is,
may possible adapt algorithm chooses expand branch less
preferred set formulas, thus guiding graph expansion process.

Appendix A. Proofs
Proof Proposition 1
644

fiDatalog Ontology Consolidation

Proof Consider U U unsatisfiable set dependencies w.r.t.
NC E , set atoms relevant U .
follows definition satisfiability set dependencies w.r.t. set
constraints U unsatisfiable exist relevant set atoms A0
makes mods(A0 , U E NC ) 6= , otherwise U satisfiable.
Then, mods(A, U E NC ) = . Moreover, since U
chase(A, U ) chase(D, ), thus NC EGD violated chase(A, U )
violated chase(D, ). Thus, mods(D, E NC ) = , i.e., KB inconsistent.
Proof Lemma 1
Proof Let KB 1 = (D1 , 1 ) 1 = 1T 1E 1NC , KB 2 = Q
(, 2 )

2 = 2T 2E 2NC twoQDatalog ontologies 1 = 2 , KB 1
dependency kernels KB 1 , KB 2 dependency kernels KB 2 , respectively.
Q
Consider X KB 1 . Then, Definition 6 X 1T unsatisfiable
set dependencies w.r.t. 1E 1NC every X 0 ( X satisfiable w.r.t. 1E 1NC .
Since 1 = 2 , 1T = 2T , 1E = 2E 1NC = 2NC , thus holds
X 2T unsatisfiable set dependencies w.r.t. 2E 2NC every X 0 ( X
satisfiable w.r.t. 2E 2NC .
Q
Then,Q
Definition 6 Q

Q X KB 2 , since holds arbitrary
kernel KB 1 KB 1 = KB 2 .
Proof Proposition 2
Proof focus case dependency clusters, omitting theQproof data
clusters, analogous other. Consider arbitrary KB .
) begin showing kernel

Q
Q part
Q
Qis part cluster
0
0
cluster, i.e., X X KB * X X KB
X 6= X 0 .

obtained directly definition clusters: X Q
= []
[] equivalence class equivalence relation obtained KB . Then,
clearly X []. Therefore, since definition two
equivalence
classes either equal disjoint holds
/ [0 ] [0 ]. Let

0
0
0
0
X = 0 [0 ] . holds X 6= X * X . Since holds
Q
Q
arbitrary equivalence
class [0 ] holds X X KB * X 0
Q
Q
X 0 KB X 6= X 0 .
) show
cluster, i.e.,
Q
Q exist any0 kernel belong
Q
Q
0
* X X KB X 6= X X X KB . Again,Q
arise
Q
use equivalence classes Definitions 9 10. * X 0 X 0 KB
X 6= X 0 , holds
/ [0 ] [0 ] 6= []. So,
Ssince equivalence classes form0
partition must holds []. Therefore, X = [] * X
Q
Q
X 0 KB X 6= X 0 X.
Proof Corollary 1
645

fiDeagustini, Martinez, Falappa & Simari

Q
Proof Consider
KB . Q
Proposition
2 X
Q
Q
Q
0 X 0
X KB onlyQ


*
X


X 6= X 0 . Thus,
KB
Q
Q
Q
X X KB
/ X 0 X 0 KB X 6= X 0 .
`
0
0
Analogously,


show







X
KB
`
`
`
`
0
0
X KB
/ X X KB X 6= X 0 .
Proof Lemma 2
Q
Proof Consider X KB 1 . Then, X minimal unsatisfiable set TGDs w.r.t.
1NC 1E . Since KB 1 = KB 2 , holds X KB 2 , 1E = 2E , 1NC = 2NC
X unsatisfiable set TGDs w.r.t. 2NC 2E . Also, exist X 0 ( X
X 0 unsatisfiable set
contradict
Q TGDs w.r.t. 2NC 2E , since otherwise wouldQ
hypothesis X KB 1 , 1NC
E . Then,
Q = 2NC 1E = 2Q
QX KB 2 ;
since holds arbitrary X KB 1 , KB 1 = KB 2 .
Q
Q
Q
Consider
arbitrary X, KB 1 XY . Since
= KB 2 ,
KB
1
Q
Q
Q
Q
Q


X, KB 2 . Thus, Q
equivalent Q
, KB 1 = KB 2 .
KB 1
KB 2
`
`
`
0 0 . Since
0, 0
=


X
Likewise, consider

arbitrary
X
KB
KB
1 `
1
` KB 2 ,
`
`
`


0
0
`
`
, thus KB 1 = KB 2 .
equivalent
X , KB 2 . Therefore,
KB 2

KB 1

Proof Proposition 3
Q
Proof Consider X KB relevant X. Definition 6
X unsatisfiable w.r.t. N E NC , Definition 4
fact relevant X mods({}, X N ) = (1). Also, since {}
singleton ( {} = , clearly
mods(, X N ) 6= (2). Then,
`
(1), (2)`
`and Definition 7 follows {} KB . Also, Definition 9
{} KB , since {} cannot overlap kernel, singleton.
Consider incision {}. Definition 11 follows (KB ) {} 6= .
Then, (KB ) {} = , thus (KB ).
Proof Corollary 2
Q
Proof Consider arbitrary D. Since relevant X KB ,
Proposition 3 holds (KB ). Thus, since holds arbitrary
(KB ).
Proof Theorem 1
Proof Let KB 1 = (D1 , 1 ) KB 2 = (D2 , 2 ) two Datalog ontologies
KB 1 = KB 2 .
) Construction postulates
Consider operator ! defined Definition 14; prove ! satisfies every
postulate Theorem 1. Let KB 1 ! = (D1 !, 1 !) KB 2 ! = (D2 !, 2 !) two Datalog
ontologies resulting consolidation KB 1 KB 2 means !, respectively.
ontology
Furthermore, let KB ?1 = (D1 , 1 \ (KB 1 )) KB ?2 = (D2 , 2 \ (KB 2 )) Q
`
resulting removing TGDs selected KB 1 KB 2 . Let KB 1 KB ?
1

646

fiDatalog Ontology Consolidation

Q
`
set dependency data kernels KB 1 KB ?1 respectively, KB 2 KB ?
Q
Q
`
` 2
sets dependency data kernels KB 2 KB ?2 . Finally, let KB 1 KB ?
Q
Q
`
` 1
set dependency data clusters KB 1 KB ?1 respectively, KB 2 KB ?
2
sets dependency data clusters KB 2 KB ?2 .
Inclusion: 1 ! 1 D1 ! D1 .
definition KB 1 ! D1 ! = D1 \ %(KB ?1 ), thus D1 ! D1 .
similar way, definition KB 1 ! 1 ! = 1 \ (KB 1 ), thus
1 ! 1 .
Coherence: KB 1 ! coherent.
prove KB 1 ! coherent show 1 ! satisfiable
E NC 1 !. sufficient show minimal conflicts
attended operator, i.e., dependency kernel included 1 !,
Q
exists
Consider
Q
Q arbitrary X KB 1 . Proposition 2 Q
Q

X . definition holds
KBQ
KB 1
1
X KB 1 X holds ((KB 1 ) X) 6= . Then, exists
X ((KB 1 ) X), thus
/ 1 !. Therefore,
X * 1 !,
Q
i.e., conflict solved. Since holds arbitrary X KB 1 every
unsatisfiable set 1 included 1 !, thus 1 ! satisfiable
E NC 1 !, i.e., KB 1 ! coherent.
Consistency: Proof analogous Coherence.
Minimality: KB 0 KB 1 coherent consistent, holds KB 1 ! 6
KB 0 .
0
LetQ
KB 0 coherent consistent, let CF 1 = 1 \
S`
`

QKB KB 1
( KB ) CF D1 = D1 \ ( KB ) set formulas belong
kernel 1 D1 , respectively.
0
Suppose
reductio KB 1 ! SKB
`
` . definition KB 1 ! (KB 1 )

Q
Q
( KB ) , %(KB 1 ) ( KB ). Then, CF 1 KB 1 ! CF D1 KB 1 !.
Therefore, CF 1 KB 0 CF D1 KB 0 .
Q
Q
`
`
Then, since KB 1 ! KB 0 must exist KB KB KB 0

/ KB 1 !, KB 0 coherent consistent same. is, exists
dependency cluster data cluster removal optimal, since could
included consolidation. rest proof simplicity reasons,
consider case belongs dependency cluster. made without
loss generality, since proof case included data cluster
analogous one presented here.
Q
Q
Let us consider
KB 0 . Corollary 1
KB
Q
Q
X X KB . Let = (X (KB )) incision performed
cluster, let R = (X {KB \ KB 0 }) formulas removed XQwhen
obtaining KB 0 . Clearly, since KB 0 coherent X KB

647

fiDeagustini, Martinez, Falappa & Simari

holds R 6= , otherwise
KB 0 , make KB 0 incoherent.
Q
Q
Besides, since R R KB , thus R satisfies first two conditions
Definition 12.
Definition 12 exists set TGDs
satisfies first two conditions definition time holds
(1) R.
Since
/ KB 1 ! X (KB ), thus . However, know
X KB 0 , thus
/ R. Therefore (2) 6 R.
(1) (2) R 6 R, absurd coming
original assumption KB 1 ! KB 0 , holds KB 0 KB 1 coherent
consistent KB 1 ! 6 KB 0 .
) Postulates Construction
second part proof, consider operator ! satisfies postulates
Theorem 1. Let (!) function based ! defined follows:
Q
Q
(!) (KB 1 ) = {x | x X X KB 1 x
/ {1 KB 1 !}}
Let KB ?1 = (D1 , 1 \ (!) (KB 1 )) ontology resulting removing KB 1
TGDs selected (!) . Then, let %(!)D another function based ! defined follows:
`
`
/ {D1 KB 1 !}}
%(!)D (KB ?1 ) = {x | x X X KB ? x
1

Based %(!)D (!) define new operator follows:
KB 1 !0 = (D1 \ %(!)D (KB ?1 ), 1 \ (!) (KB 1 ))
show !0 Datalog ontology consolidation operator based Cluster
Contraction. this, first prove %(!)D well-defined data incision function
(!) well-defined constraint incision function. is, given (!)
prove that:
- (!) well-defined, i.e., KB 1 = KB 2 , (!) (KB 1 ) = (!) (KB 2 ).
Q
Q
definition (!) (!) (KB 1 ) = {x | x X X
KB 1
x
/ 1 KB 1 !}.
Consider
arbitrary
x (!) (KB 1 ). Since KB 1 = KBQ
, Lemma 2
2Q
Q
Q Q
Q
KBQ
=
.
Since
x


(KB
),

x

X

, thus holds
1
(!)
KB 2
KB 1

1
Q
x X KB 2 (1).
Q
Q
Besides, since x X KB 1 x 1 . Thus, since x
/ 1 KB 1 !, x
/ KB 1 !.
Since KB 1 = KB 2 , fact ! function KB 1 ! = KB 2 !,
holds x
/ KB 2 !. Thus, x
/ 2 KB 2 !(2).
(1) (2)Q
Qit follows x (!) (KB 1 ) holds x {y |


/ 2 KB 2 !}. definition (!) (!) (KB 2 ),
KB 2
thus KB 1 = KB 2 , (!) (KB 1 ) = (!) (KB 2 ).
648

fiDatalog Ontology Consolidation

- (!) (KB 1 )

SQ
Q
( KB 1 ).

follows directly Q
definition (!) , since every x (!) (KB 1 ) holds
Q
x X X KB 1 first condition definition.
- X

Q
Q

eY

Q

6= X, (Y (!) (KB 1 )) 6= .
Q
Q
Q
Suppose reductio
exists X KB 1 KB 1 6= ,

X (Y (!) (KB 1 )) = .
Q
Q
Then, holds
/ (!) (KB
),
i.e.,


/
X

{1 KB 1 !}.
1
KB 1
Q
hypothesis KB 1 X. Thus X, therefore
must hold {1 KB 1 !}, extension KB 1 !.
KB 1

KB 1

Since holds arbitrary 1 !. Definition 6
holds minimal unsatisfiable set TGDs w.r.t. E NC 1 . Then,
relevant set atoms holds mods(A, E NC ) = . Then, since
1 ! relevant set A0 holds mods(A0 , 1 ! E NC ) = ,
TGDs triggered A0 . Then, 1 ! unsatisfiable set TGDs w.r.t.
E NC 1 .
However, Coherence KB 1 ! coherent, thus 1 ! satisfiable
w.r.t. E NC 1 .
1 ! satisfiable w.r.t. E NC 1 1 ! unsatisfiable
w.r.t. E Q
NC 1 , absurd
coming initial supposition
Q
Q
exists
X KB 1 KB



=
6
,


X

(Y
(!) (KB 1 )) = ,
1
Q
Q
Q
andTit holds X KB 1 KB 1 X, 6=
(Y (!) (KB 1 )) 6= .
Q
Q
holds = (X (!) (KB 1 )) exists
- X
KB 1
R X R satisfies two previous conditions R ( .
prove sufficient show that, clusters disjoint sets, election
cluster optimal, otherwise exists cluster incision
function choose optimal way
Q
Q Minimality would satisfied.
So, suppose reductio exists X KB 1 = (X (!) (KB 1 ))
exist R X R satisfies two previous conditions R ( .
Q
Q
Let us consider KB 0 = (0 , D0 ) KB 1 6= X holds
0 = (Y (!) (KB 1 )) R0 = (Y {KB \ KB 0 }) (those formulas removed
obtaining KB 0 ) 0 = R0 . Since 0 = R0 R0 Q

Q
two conditions

Definition
12

satisfied.
Besides,
let
CF
=

\

1
1
KB
`
`
CF D1 = D1 \ KB set formulas belong kernel 1
D1 , respectively; let KB 0 CF 1 0 CF D1 D0 .
fact every formula conflict belongs KB 0 KB 0
built way election cluster different X
KB 0 (!) (KB 1 ) makes KB 0 \ (X {KB \ KB 0 }) = KB 1 ! \ (X (!) (KB 1 )).
is, difference KB 0 KB 1 ! difference arise
election formulas remove X.
649

fiDeagustini, Martinez, Falappa & Simari

Finally, supposition exists R X R satisfies two
previous conditions R ( . Let KB 0 R ( R = (X {KB \KB 0 })
set formulas removed X obtaining KB 0 . Then, KB 0
coherent consistent, since every conflict clusters KB 1 solved, whether
removing R (for cluster X) sets R0 (for every cluster different X). Besides,
since KB 0 \ (X {KB \ KB 0 }) = KB 1 ! \ (X S(!) (KB 1 )) R ( ,
Q
KB 1 ! = KB 1 \ (!) (KB 1 ) KB 0 = KB 1 \ { {Q
R0 R}
\X}
KB 1

(R0 = {KB \ KB 0 }) R = (X {KB \ KB 0 }) holds KB 1 ! KB 0 (1).
is, formulas involved conflicts belong KB 1 ! KB 0 ,
cluster different X formulas removed, set formulas
removed X obtain KB 0 strict subset removed (!) (KB 1 )
obtain KB 1 !, KB 1 ! strict subset KB 0 , i.e., removed formulas
deleting deleting R.
hand, since KB 0 coherent consistent, Minimality
KB 1 ! 6 KB 0 (2).
0
Therefore, (1) (2) KB 1 ! KB 0 KB
Q
Q 1 ! 6 KB , absurd
= (X
coming initial supposition exists X
KB 1
(!) (KB 1 )) exists R X
R
satisfies

two
previous
conditions
Q
Q
R ( , X

holds


=
(X


(!) (KB 1 ))
KB 1
exists R X R satisfies two previous conditions
R ( T.
omit proof %(!)D well-defined data incision function using Consistency
Minimality since analogous proof (!) well-defined constraint
incision function using Coherence Minimality.
shown %(!)D (!) well-defined data incision functions
constraint incision functions, respectively, conclude second part proof
show !0 coincides !. Inclusion follows D1 ! D1
1 ! 1 (1). Also, definition %(!)D follows %(!)D (KB ?1 ) = D1 \ D1 !,
definition (!) follows (!) (KB 1 ) = 1 \ 1 ! (2). Then,
(1) (2) D1 ! = D1 \ %(!)D (KB ?1 ) 1 ! = 1 \ (!) (KB 1 ). Thus, ! =
(D1 \ %(!)D (KB ?1 ), 1 \ (!) (KB 1 )), therefore !0 coincides !.

References
Alchourron, C., Gardenfors, P., & Makinson, D. (1985). logic theory change:
Partial meet contraction revision functions. Journal Symbolic Logic, 50 (2),
510530.
Alchourron, C., & Makinson, D. (1981). Hierarchies Regulation Logic. New
Studies Deontic Logic, 125148.
Alchourron, C., & Makinson, D. (1985). Logic Theory Change: Safe Contraction.
Studia Logica, 44, 405422.
Amgoud, L., & Kaci, S. (2005). argumentation framework merging conflicting knowledge bases: prioritized case. Proc. 8th European Conferences Symbolic
650

fiDatalog Ontology Consolidation

Quantitative Approaches Reasoning Uncertainty (ECSQUARU 05), pp.
527538.
Andritsos, P., Fuxman, A., & Miller, R. J. (2006). Clean answers dirty databases:
probabilistic approach. Proc. 22nd International Conference Data Engineering (ICDE 06), p. 30.
Arenas, M., Bertossi, L. E., & Chomicki, J. (1999). Consistent query answers inconsistent databases. Proc. 18th ACM SIGACT-SIGMOD-SIGART Symposium
Principles Database Systems (PODS 99), pp. 6879.
Arieli, O., Denecker, M., & Bruynooghe, M. (2007). Distance semantics database repair.
Annals Mathematics Artificial Intelligence, 50 (3-4), 389415.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. Proc. 19th
International Joint Conference Artificial Intelligence (IJCAI 05), pp. 364369.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). Description Logic Handbook: Theory, Implementation, Applications.
Cambridge University Press.
Baral, C., Kraus, S., & Minker, J. (1991). Combining multiple knowledge bases. Transactions Knowledge Data Engineering, 3 (2), 208220.
Bell, D. A., Qi, G., & Liu, W. (2007). Approaches inconsistency handling descriptionlogic based ontologies. Proc. Move Meaningful Internet Systems
(OTM) Workshops (2), pp. 13031311.
Beneventano, D., & Bergamaschi, S. (1997). Incoherence subsumption recursive
views queries object-oriented data models. Data Knowledge Engineering,
21 (3), 217252.
Berners-Lee, T., Hendler, J., & Lassila, O. (2001). semantic web. Scientific American,
284(5):3443.
Bienvenu, M., & Rosati, R. (2013). Tractable approximations consistent query answering
robust ontology-based data access. Proc. 23rd International Joint Conference
Artificial Intelligence (IJCAI 13), pp. 775781.
Black, E., Hunter, A., & Pan, J. Z. (2009). argument-based approach using multiple ontologies. Proc. 3rd International Conference Scalable Uncertainty
Management (SUM 09), pp. 6879.
Bohannon, P., Flaster, M., Fan, W., & Rastogi, R. (2005). cost-based model effective heuristic repairing constraints value modification. Proc. 24th ACM
SIGMOD International Conference Management Data / Principles Database
Systems (PODS 05), pp. 143154.
Booth, R., Meyer, T. A., Varzinczak, I. J., & Wassermann, R. (2010). Horn belief change:
contraction core. Proc. 19th European Conference Artificial Intelligence
(ECAI 10), pp. 10651066.
Borgida, A. (1995). Description logics data management. Transactions Knowledge
Data Engineering, 7 (5), 671682.
651

fiDeagustini, Martinez, Falappa & Simari

Brandt, S. (2004). Polynomial time reasoning description logic existential restrictions, GCI axioms, - else?. Proc. 16th European Conference
Artificial Intelligence (ECAI 04), pp. 298302.
Cal, A., Gottlob, G., & Kifer, M. (2008). Taming infinite chase: Query answering
expressive relational constraints. Brewka, G., & Lang, J. (Eds.), Proc. 11th
International Conference Principles Knowledge Representation Reasoning
(KR 08), pp. 7080. AAAI Press.
Cal, A., Gottlob, G., & Kifer, M. (2013). Taming infinite chase: Query answering
expressive relational constraints. Journal Artificial Intelligence Research, 48,
115174.
Cal, A., Gottlob, G., & Lukasiewicz, T. (2012). general Datalog-based framework
tractable query answering ontologies. Journal Web Semantic, 14, 5783.
Cal, A., Lembo, D., & Rosati, R. (2003). decidability complexity query answering inconsistent incomplete databases. Proc. 22nd ACM SIGMOD
Symposium Principles database systems (PODS 03), pp. 260271. ACM.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2005). DL-Lite:
Tractable description logics ontologies. AAAI, pp. 602607.
Caroprese, L., Greco, S., & Zumpano, E. (2009). Active integrity constraints database
consistency maintenance. Transactions Knowledge Data Engineering, 21 (7),
10421058.
Caroprese, L., & Truszczynski, M. (2011). Active integrity constraints revision programming. Theory Practice Logic Programming, 11 (6), 905952.
Cecchi, L., Fillottrani, P., & Simari, G. R. (2006). Complexity DeLP
Game Semantics. Dix, J., & Hunter, A. (Eds.), Proc. 11th International Workshop Non-Monotonic Reasoning (NMR 06), pp. 386394.
Cholvy, L. (1998). Reasoning merged information. Belief Change, Vol. 3, pp.
233263. Springer Netherlands.
Croitoru, M., & Rodriguez, R. O. (2015). Using kernel consolidation query answering
inconsistent OBDA. Proc. Joint Ontology Workshops 2015 Episode 1:
Argentine Winter Ontology.
Delgrande, J. P. (2011). Revising inconsistent set formulas. Proc. 22nd
International Joint Conference Artificial Intelligence (IJCAI 11), pp. 833838.
Delgrande, J. P., Dubois, D., & Lang, J. (2006). Iterated revision prioritized merging.
Proc. 10th International Conference Principles Knowledge Representation
Reasoning (KR 06), pp. 210220.
Delgrande, J. P., & Jin, Y. (2012). Parallel belief revision: Revising sets formulas.
Artificial Intelligence, 176 (1), 22232245.
Delgrande, J. P., Schaub, T., Tompits, H., & Woltran, S. (2009). Merging logic programs
answer set semantics. Proc. 25th International Conference Logic Programming (ICLP 09), pp. 160174.
652

fiDatalog Ontology Consolidation

Dunne, P., & Wooldridge, M. (2009). Argumentation Artificial Intelligence, chap. Complexity Abstract Argumentation, pp. 85104. Springer.
Everaere, P., Konieczny, S., & Marquis, P. (2008). Conflict-based merging operators.
Proc. 11th International Conference Principles Knowledge Representation
Reasoning (KR 08), pp. 348357.
Falappa, M. A., Kern-Isberner, G., Reis, M. D. L., & Simari, G. R. (2012). Prioritized
non-prioritized multiple change belief bases. Journal Philosophical Logic, 41 (1),
77113.
Falappa, M. A., Kern-Isberner, G., & Simari, G. R. (2002). Belief Revision, Explanations
Defeasible Reasoning. Artificial Intelligence, 141, 128.
Flouris, G., Huang, Z., Pan, J. Z., Plexousakis, D., & Wache, H. (2006). Inconsistencies,
negations changes ontologies. Proc. 21st National Conference Artificial
Intelligence (AAAI 06), pp. 12951300.
Friedman, N., & Halpern, J. Y. (2001). Belief revision: critique. Computer Research
Repository (CoRR), cs.AI/0103020.
Fuhrmann, A. (1991). Theory contraction base contraction. Journal Philosophical Logic, 20, 175203.
Gardenfors, P. (1982). Rule rational changes belief. Philosophical Essay Dediccated
Lennart Aqvist Fiftieth Birthday, 88101.
Gardenfors, P. (1988). Knowledge Flux: Modeling dynamics epistemic states. MIT
Press.
Gelfond, M. (2008). Answer sets. Handbook Knowledge Representation, chap. 7, pp.
285316. Elsevier.
Gomez, S. A., Chesnevar, C. I., & Simari, G. R. (2010). Reasoning inconsistent
ontologies argumentation. Applied Artificial Intelligence, 24 (1&2), 102148.
Greco, S., & Molinaro, C. (2012). Probabilistic query answering inconsistent databases.
Annals Mathematics Artificial Intelligence (AMAI), 64 (2-3), 185207.
Haase, P., van Harmelen, F., Huang, Z., Stuckenschmidt, H., & Sure, Y. (2005). framework handling inconsistency changing ontologies. Proc. 4th International
Semantic Web Conference (ISWC 05), pp. 353367.
Halaschek-Wiener, C., & Katz, Y. (2006). Belief base revision expressive description
logics. Proc. International Workshop OWL: Experiences Directions
(OWLED 06).
Hansson, S. O. (1991). Belief Base Dynamics. Ph.D. thesis, Uppsala University, Department
Philosophy, Uppsala, Sweden.
Hansson, S. O. (1993). Theory contraction base contraction unified. Journal Symbolic
Logic, 58 (2), 602625.
Hansson, S. O. (1994). Kernel contraction. Journal Symbolic Logic, 59 (3), 845859.
Hansson, S. O. (1997). Semi-revision. Journal Applied Non-Classical Logics, 7 (1-2),
151175.
653

fiDeagustini, Martinez, Falappa & Simari

Hansson, S. O. (2001). Textbook Belief Dynamics: Solutions Exercises. Kluwer
Academic Publishers, Norwell, MA, USA.
Harman, G. (2008). Change view: Principles reasoning. Cambridge University Press.
Harper, W. (1975). Rational Belief Change, Popper Functions Counterfactuals. Synthese, 30, 221262.
Horridge, M., Parsia, B., & Sattler, U. (2009). Explaining inconsistencies OWL ontologies.
Scalable Uncertainty Management, pp. 124137. Springer.
Huang, Z., van Harmelen, F., & ten Teije, A. (2005). Reasoning inconsistent ontologies.
Proc. 19th International Joint Conference Artificial Intelligence (IJCAI 05),
pp. 454459.
Hue, J., Papini, O., & Wurbel, E. (2009). Merging belief bases represented logic programs. Proc. 10th European Conference Symbolic Quantitative Approaches Reasoning Uncertainty (ECSQARU 09), pp. 371382.
Kalyanpur, A., Parsia, B., Horridge, M., & Sirin, E. (2007). Finding justifications
OWL DL entailments. Springer.
Kalyanpur, A., Parsia, B., Sirin, E., & Hendler, J. A. (2005). Debugging unsatisfiable classes
owl ontologies. Web Semantics: Science, Services Agents World Wide
Web, 3 (4), 268293.
Katsuno, H., & Mendelzon, A. O. (1991). difference updating knowledge base revising it. Proc. 2nd International Conference Principles
Knowledge Representation Reasoning (KR91), pp. 387394.
Katsuno, H., & Mendelzon, A. O. (1992). Propositional knowledge base revision minimal change. Artificial Intelligence, 52 (3), 263294.
Konieczny, S., & Perez, R. P. (2002). Merging information constraints: logical
framework. Journal Logic Computation, 12 (5), 773808.
Konieczny, S., & Perez, R. P. (2011). Logic based merging. Journal Philosophical Logic,
40 (2), 239270.
Lembo, D., Lenzerini, M., Rosati, R., Ruzzi, M., & Savo, D. F. (2010). Inconsistencytolerant semantics description logics. Proc. 4th International Conference
Web Reasoning Rule Systems (RR 10), pp. 103117.
Lenzerini, M. (2002). Data integration: theoretical perspective. Proc, 21st ACM
SIGMOD Symposium Principles Database Systems (PODS 02), pp. 233246.
Levi, I. (1977). Subjunctives, Dispositions Chances. Synthese, 34 (4), 423455.
Liberatore, P., & Schaerf, M. (1998). Arbitration (or merge knowledge bases).
Knowledge Data Engineering, 10 (1), 7690.
Lin, J., & Mendelzon, A. O. (1998). Merging databases constraints. International
Journal Cooperative Information Systems, 7 (1), 5576.
Lin, J., & Mendelzon, A. O. (1999). Knowledge base merging majority. Applied Logic
Series, 18, 195218.
654

fiDatalog Ontology Consolidation

Lloyd, J. W. (1987). Foundations Logic Programmming. Springer-Verlag.
Lukasiewicz, T., Martinez, M. V., & Simari, G. I. (2012). Inconsistency handling
datalog+/- ontologies. Proc. 20th European Conference Artificial Intelligence (ECAI 12), pp. 558563.
Martinez, M., Pugliese, A., Simari, G., Subrahmanian, V., & Prade, H. (2007). dirty
relational database? axiomatic approach. Mellouli, K. (Ed.), Proc.
9th European Conference Symbolic Quantitative Approaches Reasoning
Uncertainty (ECSQARU 07), Vol. 4724 Lecture Notes Computer Science, pp.
103114. Springer.
Meyer, T., Lee, K., & Booth, R. (2005). Knowledge integration description logics.
Veloso, M., & Kambhampati, S. (Eds.), Proceedings AAAI05, Twentieth National
Conference Artificial Intelligence, pp. 645650. AAAI Press.
Newell, A. (1982). Knowledge Level. Artificial Intelligence, 18, 87127.
Nilsson, U., & Maluszynski, J. (1995). Logic, Programming Prolog (2ed). John Wiley
& Sons Ltd.
Parsons, S., Wooldridge, M., & Amgoud, L. (2003). Properties complexity
formal inter-agent dialogues. Journal Logic Computation, 13 (3), 347376.
Qi, G., & Hunter, A. (2007). Measuring incoherence description logic-based ontologies.
Proc. 6th International Semantic Web Conference 2nd Asian Semantic
Web Conference (ISWC/ASWC 07), pp. 381394.
Qi, G., Liu, W., & Bell, D. A. (2006). Knowledge base revision description logics.
Proc. 10th European Conference Logics Artificial Intelligence (JELIA 06),
pp. 386398.
Quine, W. V. O. (1986). Philosophy logic. Harvard University Press.
Reiter, R. (1987). theory diagnosis first principles. Artificial Intelligence, 32(1),
5795.
Rosati, R. (2011). complexity dealing inconsistency description logic
ontologies. Proc. International Joint Conference Artificial Intelligence (IJCAI
11), pp. 10571062.
Rott, H. (1992). Modellings belief change: Prioritization entrenchment. Theoria,
58 (1), 2157.
Schlobach, S., & Cornet, R. (2003). Non-standard reasoning services debugging
description logic terminologies.. Proceedings Eighteenth International Joint
Conference Artificial Intelligence (IJCAI 03), pp. 355362.
Schlobach, S., Huang, Z., Cornet, R., & van Harmelen, F. (2007). Debugging incoherent
terminologies. Journal Automated Reasoning, 39 (3), 317349.
Staworko, S., Chomicki, J., & Marcinkowski, J. (2012). Prioritized repairing consistent query answering relational databases. Annals Mathematics Artificial
Intelligence, 64 (2-3), 209246.
655

fiDeagustini, Martinez, Falappa & Simari

Turner, H. (2003). Strong equivalence made easy: nested expressions weight constraints.
Theory Practice Logic Programming, 3 (4-5), 609622.
von Leibniz, G. W. F. (1976). Philosophical Papers Letters: selection, Vol. 1. Springer.
Wassermann, R. (2000). algorithm belief revision. Proc. International Conference Principles Knowledge Representation Reasoning (KR 00), pp. 345
352.
Wijsen, J. (2005). Database repairing using updates. ACM Transaction Database Systems, 30 (3), 722768.

656


