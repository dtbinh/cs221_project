Journal Artificial Intelligence Research 56 (2016) 547-571

Submitted 01/16; published 08/16

Research Note
Time-Bounded Best-First Search Reversible Non-reversible
Search Graphs
Carlos Hernandez

CARLOS . HERNANDEZ . U @ UNAB . CL

Departamento de Ciencias de la Ingeniera,
Universidad Andres Bello,
Santiago, Chile

Jorge A. Baier

JABAIER @ ING . PUC . CL

Departamento de Ciencia de la Computacion
Pontificia Universidad Catolica de Chile
Santiago, Chile

Roberto Asn

RASIN @ UCSC . CL

Departamento de Ingeniera Informatica
Universidad Catolica de la Santsima Concepcion
Concepcion, Chile

Abstract
Time-Bounded A* real-time, single-agent, deterministic search algorithm expands
states graph order A* does, unlike A* interleaves search action execution. Known outperform state-of-the-art real-time search algorithms based Korfs Learning
Real-Time A* (LRTA*) benchmarks, studied detail sometimes
considered true real-time search algorithm since fails non-reversible problems even
goal still reachable current state. paper propose study Time-Bounded
Best-First Search (TB(BFS)) straightforward generalization time-bounded approach
best-first search algorithm. Furthermore, propose Restarting Time-Bounded Weighted A* (TBR
(WA*)), algorithm deals adequately non-reversible search graphs, eliminating
backtracking moves incorporating search restarts heuristic learning. non-reversible
problems prove TB(BFS) terminates deduce cost bounds solutions returned
Time-Bounded Weighted A* (TB(WA*)), instance TB(BFS). Furthermore, prove TBR
(WA*), reasonable conditions, terminates. evaluate TB(WA) grid pathfinding
15-puzzle. addition, evaluate TBR (WA*) racetrack problem. compare
algorithms LSS-LRTWA*, variant LRTA* exploit lookahead search weighted
heuristic. general observation performance TB(WA*) TBR (WA*) improves weight parameter increased. addition, time-bounded algorithms almost
always outperform LSS-LRTWA* significant margin.

1. Introduction
many search applications, time scarce resource. Examples range video game path
finding, handful milliseconds given search algorithm controlling automated
characters (Bulitko, Bjornsson, Sturtevant, & Lawrence, 2011), highly dynamic robotics (Schmid,
Tomic, Ruess, Hirschmuller, & Suppa, 2013). settings, usually assumed standard
search algorithm able compute complete solution action required,
thus execution search must interleaved.
c
2016
AI Access Foundation. rights reserved.

fiH ERN ANDEZ , BAIER , &

Time-Bounded A* (Bjornsson, Bulitko, & Sturtevant, 2009) algorithm suitable searching tight time constraints. nutshell, given parameter k, runs standard A* search
towards goal rooted initial state, k expansions completed, move performed search, still needed, resumed. move computed follows. agent
path found A* root node best node b search frontier
agent moved towards b following path . Otherwise, performs backtracking move, returning agent previous state. algorithm always terminates agent goal
state, problem solution.
Time-Bounded A* algorithm relevant real-time search community.
significantly superior well-known real-time heuristic search algorithms applications.
Indeed Hernandez, Baier, Uras, Koenig (2012) showed significantly outperforms state-of-theart real-time heuristic search algorithms RTAA* (Koenig & Likhachev, 2006) daRTAA*
(Hernandez & Baier, 2012) pathfinding.
relatively new algorithm, Time-Bounded A* studied deeply literature. One reasons perhaps inability adequately deal non-reversible
problems. Indeed, non-reversible problems real-time search algorithm fail soon
algorithm led agent dead-end state; i.e., one goal unreachable. TimeBounded A*, however, additional failure condition: always fail soon backtrack
move required unreversible action. Thus class problems cannot solve limited compared real-time search algorithms, like, example, well-known LRTA* (Korf,
1990). reason, Time-Bounded A* sometimes excluded experimental comparisons
real-time search algorithms (see e.g. Burns, Ruml, & Do, 2013, p. 725).
paper extend time-bounded search approach two directions. already noted
authors (Bjornsson et al., 2009), time-bounded approach limited A*. first
contribution paper study implications using search algorithms
instead A*. Specifically, generalize Time-Bounded A* Time-Bounded Best-First Search.
general, instance Best-First Search, call TB(A) algorithm results
applying time-bounded approach A. second contribution paper extension
time-bounded search approach allows algorithm deal adequately non-reversible
problems. algorithm propose here, Restarting Time-Bounded Weighted A*which call
TBR (WA*), seen lying middle ground time-bounded algorithms
learning-based real-time search algorithms Korfs Learning Real-Time A* (LRTA*) (1990).
fact, TBR (WA*) restarts search current state backtracking move available
updates heuristic function.
carry theoretical analysis Time-Bounded Weighted A* (TB(WA*)), instance
TB(BFS), TBR (WA*). TB(WA*) establish upper lower bounds
solution cost. cost bound establishes that, domains, solution cost may reduced
significantly increasing w without increasing search time; hence, contrast wellknown Weighted A* solving offline search problems, might obtain better solutions
increasing weight. result important since suggests TB(WA*) (with w > 1)
preferred TB(A*) domains WA* runs faster A*. WA*
always run faster A* (see e.g., Wilt & Ruml, 2012), known many situations.
Experimentally, evaluate TB(WA*) pathfinding benchmarks 15-puzzle,
TBR (WA*) racetrack problem. three benchmarks observe performance improvement w increased. addition, observe TB(WA*) significantly superior TB(A*)
548

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

LSS-LRTWA* (Rivera, Baier, & Hernandez, 2015), real-time search algorithm use
weighted heuristics.
paper extends work appears conference proceedings (Hernandez, Asn, & Baier,
2014), including empirical analysis new benchmarks (Counter Strike Maps, racetrack,
15-puzzle), extending pathfinding experiments 16-neighbor connectivity, providing lower bound cost solution returned TB(WA*) (Theorem 2, below),
introducing, analyzing, evaluating TBR (WA*).
rest paper organized follows. start describing background needed
rest paper. describe TB(BFS) TBR (BFS), including formal analysis
properties. describe experimental results, finish summary
perspectives future research.

2. Background
describe background rest paper.
2.1 Search Reversible Non-reversible Environments
search graph tuple G = (S, A), finite set states, set edges
represent actions available agent state. path graph (S, A)
sequence states = s0 s1 sn , (si , si+1 ) A, {0, . . . , n 1}, s0 = s,
sn = t. say successor (s, t) edge A. Moreover, every
define Succ(s) = {t | (s, t) A}.
cost function c search graph (S, A) c : P
R+ ; i.e., associates action
positive cost. cost path = s0 s1 sn c() = n1
i=0 c(si , si+1 ), i.e. sum
costs edge considered path. cost-optimal path one
lowest cost among paths t; denote cost c (s, t). addition, denote
cT (s, t) cost cost-optimal path visits states , is,
cost-optimal path = s1 s2 . . . sn = s1 , sn = t, si , {2, . . . , n 1}.
search problem tuple (S, A, c, sstart , sgoal ) G = (S, A) search graph, sstart
sgoal states S, c cost function G. search graph G = (S, A) reversible
symmetric; is, whenever (s, t) (t, s) A. search problem reversible
search graph reversible. Consequently, problem non-reversible search graph
contains action (s, t) contain action (t, s).
solution search problem path sstart sgoal .
2.2 Best-First Search
Best-First Search (BFS) (Pearl, 1984) encompasses family search algorithms static environments associate evaluation function f (s) every state s. priority
f (s) < f (t) viewed promising node t. BFS starts initializing
priority states search space infinity, except sstart , priority set
f (sstart ). priority queue Open initialized containing sstart . iteration, algorithm
extracts Open state lowest priority, s. successor computes evaluation fs (t), considering path found s. fs (t) lower f (t),
549

fiH ERN ANDEZ , BAIER , &

added Open f (t) set fs (t). algorithm repeats process sgoal Open
lowest priority.
pseudo code presented Algorithm 1. f -value state usually implemented
attribute s, Open list implemented priority list. Furthermore, assume
cost fs (t) computed Line 13 function path via s. Thus fs (t) take finite
number values execution BFS, depends (finite) number simple
paths connect initial state s.
Algorithm 1: Best-First Search

16
17

sroot scurrent
Open
foreach
f (s)
f (sroot ) evaluation sroot
Insert sroot Open
Open 6=
Let state minimum f -value Open
= sgoal
return
Remove Open
foreach Succ(s)
fs (t) evaluation function considering discovered
fs (t) < f (t)
f (t) fs (t)
parent(t)
Insert Open

18

return solution

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

instance Best-First Search Weighted A* (WA*) (Pohl, 1970). WA* computes evaluation function terms two functions, g h. g-value corresponds cost
lowest-cost path found far towards s, implemented attribute s. WA*s evaluation function defined f (s) = g(s) + wh(s), g(s) cost lowest-cost path
found sstart s. addition, h non-negative, user-given heuristic function h(s)
estimates cost path sgoal . Finally, w real number greater equal 1.
pseudo-code WA* obtained Algorithm 1 storing g-value attribute state, h value computed external function. resulting pseudo-code
appears Algorithm 2.
heuristic function h admissible h(s) c (s, sgoal ), S. Function
h consistent h(sgoal ) = 0, h(s) c(s, t) + h(t) every edge (s, t) search graph.
Consistency implies path h(s) c() + h(t), which, turn, implies
admissibility.
BFSs closed listdenoted henceforth Closed defined set states
Open g(s) infinity.1 words, contains states
path known considered re-expansion.
1. BFS initially sets f (s) infinity every start node. WA* translates setting g(s) infinity
except sstart .

550

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

Algorithm 2: Weighted A*

19
20

sroot scurrent
Open
foreach
g(s)
f (s)
g(sroot ) 0
f (sroot ) wh(sroot )
Insert sroot Open
Open 6=
Let state minimum f -value Open
= sgoal
return
Remove Open
foreach Succ(s)
gs,t = min{g(t), g(s) + c(s, t)}
gs,t < g(t)
g(t) gs,t
f (t) g(t) + wh(t)
parent(t)
Insert Open

21

return solution

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

h admissible, WA* known find solution whose cost cannot exceed wc (sstart , sgoal ).
such, WA* may return increasingly worse solutions w increased. advantage increasing w search time usually decreased fewer states expanded. w = 1,
WA* equivalent A* (Hart, Nilsson, & Raphael, 1968). Another interesting result generalizes
well-known property consistent heuristics A* algorithm. formally stated follows:
Lemma 1 (Ebendt & Drechsler, 2009) every moment execution Weighted A*
state sroot , h consistent, upon expansion state (Line 14 Algorithm 2), holds
g(s) wc (sroot , s).
Another instance Best-First Search Greedy Best-First Search (GBFS). f equal
user-given heuristic function h. WA* used sufficiently large value w,
WA* GBFS rank nodes similar way. Indeed, let fGBFS fWA* denote, respectively, f
function GBFS WA*. w exceeds g-value every node ever generated
two nodes s1 s2 generated g-value algorithms
fGBFS (s1 ) = h(s1 ) > h(s2 ) = fGBFS (s2 ), hold fWA* (s1 ) > fWA* (s2 ). However,
even w sufficiently large, reverse always true since fWA* (s1 ) > fWA* (s2 ) hold
true h(s1 ) = h(s2 ), g-value fWA* acts practice tie breaker.
2.3 Real-Time Heuristic Search
real-time search objective solve search problem subject additional real-time
constraint. constraint, constant amount time (independent problem size) given
search algorithm, end expected perform one actions
sequence. constant small relation time would required offline
551

fiH ERN ANDEZ , BAIER , &

search algorithm solve search problem. performing actions agent reached
goal, process repeats. iteration algorithm understood two consecutive
episodes: (1) search episode, path computed, (2) execution episode,
actions path performed.
Rather receiving time limit seconds, real-time search algorithms receive parameter, say k, guarantee computational time taken search episode bounded
non-decreasing function k. example real-time search algorithm Local Search-Space,
Learning Real-Time A* (LSS-LRTA*; Algorithm 3) (Koenig & Sun, 2009). receives search
problem P parameter k. search episode, runs bounded execution A* rooted
current state expands k states. Following, updates heuristic values
states closed list A* run. update, usually referred learning step, makes h
informed, guarantees following holds every A*s closed list:
h(s) = min {cClosed (s, t) + h(t)}.
tOpen

(1)

execution episode performs actions appear path found A* current
state towards state lowest f -value open list. reversible search spaces h
Algorithm 3: LSS-LRTA*
1
2
3
4
5
6
7
8

Input: search problem P natural number k
sstart
goal state
run A* k states expanded goal node best state Open
best state A*s closed list lowest f -value
Closed
update h-value Equation 1 holds
move along path found A* best
best,

initially consistent shown LSS-LRTA* terminates search problem
solution (Koenig & Sun, 2009). search space non-reversible, however, termination cannot
guaranteed. see later, time-bounded algorithms (without restarts) prove solution
exist well. property hold algorithms whose search expands nodes
whose distance current state bounded, LSS-LRTA*.
2.4 Comparing Two Real-Time Search Algorithms
One way frequently used literature compare two real-time search algorithms B
comparing cost returned paths algorithms configured way
search episodes approximately duration. Assume real-time search algorithm
requires n search episodes solve search problem runtime . say
average time per search episode run /n.
evaluate relative performance two algorithms B use set benchmark
problems P set algorithm parameters. parameter algorithm A, obtain
record average solution cost problems P average time per episode.
likewise B plot average solution cost versus average time per episode
algorithm. curve algorithm always top curve algorithm B clearly
552

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

state B superior A, B returns better-quality solutions comparable search time
per episode.
Another approach used compare real-time search algorithms Game Time
Model (Hernandez et al., 2012). model, time partitioned uniform time intervals.
agent execute one movement time interval, search movements done
parallel. objective move agent start location goal location
time intervals possible. game time model motivated video games. Video games often
partition time game cycles, couple milliseconds long (Bulitko et al.,
2011). using Game Time Model, implementation real-time search algorithm
modified stop search soon units timewhere parameterhave passed.

3. Time-Bounded Best-First Search
Time-Bounded A* (TB(A*), Bjornsson et al., 2009) real-time search algorithm based A*.
Intuitively, TB(A*) understood algorithm runs A* search sstart sgoal
alternates search phase execution phase goal reached. search phase
bounded number states expanded using A*. execution phase two cases.
agent path sstart best state Open, forward movement
path performed. Otherwise, algorithm performs backtracking moves agent
moved state came from. search phase execute path connecting
sstart sgoal already found. algorithm terminates agent reached
goal.
generalization TB(A*) Time-Bounded Best-First Search, simply replaces A*
TB(A*) Best-First Search. pseudo code shown Algorithm 4. parameters
search problem (S, A, c, sstart , sgoal ), integer k refer lookahead
parameter.
TB(BFS) uses variable scurrent store current state agent. MoveToGoal procedure (called Main) implements loop alternates search execution. initialization
(Lines 2728) scurrent initialized sstart , and, among things, BFSs Open list set
contain sstart only. goal state reached (represented fact variable
goalF ound false), bounded version BFS called (Line 31) expands k states,
computes path sstart state Open minimizes evaluation function f .
path built quickly following parent pointers, stored variable path. execution phase (Lines 3236), current position agent, scurrent , path, agent
performs action determined state immediately following scurrent path. Otherwise,
backtracking move implemented moving agent parent search tree BFS,
parent(scurrent ). use backtracking moves mechanism guarantees agent
eventually reach state variable path because, worst case, agent eventually reach
sstart . soon state reached agent start moving towards state believed
closest goal.
Algorithm 4 equivalent TB(A*) BFS replaced A*. Finally, call TimeBounded Greedy Best-First Search (TB(GBFS)) algorithm results use Greedy
Best-First Search instead BFS.
Note length path cannot general bounded constant size
problem. bound computation search episode use technique described
553

fiH ERN ANDEZ , BAIER , &

Algorithm 4: Time-Bounded Best-First Search
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42

procedure InitializeSearch()
sroot scurrent
Open
foreach
f (s)
f (sroot ) evaluation sroot
Insert sroot Open
goalFound false
function Bounded-Best-First-Search()
expansions 0
Open 6= expansions < k f (sgoal ) > mintOpen f (t)
Let state minimum f -value Open
Remove Open
foreach Succ(s)
Compute fs (t) considering discovered s.
fs (t) < f (t)
f (t) fs (t)
parent(t)
Insert Open
expansions expansions + 1
Open = return false
Let sbest state minimum priority Open.
sbest = sgoal goalFound true
path path sroot sbest
return true
function MoveToGoal()
scurrent sstart
InitializeSearch()
scurrent 6= sgoal
goalFound = false
Bounded-Best-First-Search() = false return false
scurrent path
scurrent state scurrent path
else
scurrent parent(scurrent );
Execute movement scurrent
return true
procedure Main
MoveToGoal() = true
print(the agent goal state)
else
print(no solution)

554

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

Bjornsson et al. (2009), whereby additional counter (analogous k used measure
effort path extraction). omitted pseudocode clarity.
3.1 Properties
analyze interesting properties algorithms proposed. First,
TB(A*), TB(BFS) always terminates finds solution one exists. important
property since many real-time heuristic search algorithms (e.g., LSS-LRTA*) enter infinite loop
unsolvable problems. Second, prove upper lower bound cost solutions
returned TB(WA*). bound interesting since suggests increasing w one might
obtain better solutions rather worse.
Theorem 1 TB(BFS) move agent goal state given reversible search problem P
solution P exists. Otherwise, eventually print solution.
Proof: Follows fact Best-First Search eventually finds path towards goal.
fact search space finite state inserted Open
finite number times. addition, moves carried algorithm (including moving
parent(s)) executable reversible search space.

important note reason TB(BFS) eventually print solution
unsolvable problem dependent fact Open list used. LSS-LRTA* cannot always
detect unsolvable problems search expand locality around current state.
characteristic agent-centered search algorithms (Koenig, 2001), class algorithms
TB(BFS) member of.
following two lemmas intermediate results allow us prove upper bound
cost solutions obtained TB(WA*). results apply TB(A*) knowledge
Lemma 2 Theorem 2 proven TB(A*).
results below, assume P = (S, A, c, sstart , sgoal ) reversible search problem,
TB(WA*) run parameter w 1 h admissible heuristic. Furthermore,
assume c+ = max(u,v)A c(u, v), c = min(u,v)A c(u, v), N (w) number
expansions needed WA* solve P . Finally, assume k N (w) reasonable
assumption given real-time setting.
Lemma 2 cost moves incurred agent controlled TB(WA*) goalFound
becomes true bounded b N (w)1
cc bounded b N (w)1
cc+ .
k
k
Proof: N (w) 1 states expanded goalFound becomes true. k states expanded
per call search procedure, clearly b N (w)1
c number calls Best-Firstk
Search terminates without setting goalFound true. move costs least c c+ ,
result follows.

focus cost incurred complete path found. following Lemma
related property enjoyed TB(A*) stated Theorem 2 Hernandez et al. (2012).
Lemma 3 cost moves incurred agent controlled TB(WA*) goalFound
become true cannot exceed 2wc (sstart , sgoal ).
555

fiH ERN ANDEZ , BAIER , &

Proof: Assume goalFound become true. Let path starts sstart , ends
scurrent defined following parent pointers back sstart . Path prefix
path lowest f -value state previous run WA* therefore, Lemma 1,
c() < wc (sstart , sgoal ). worst case terms number movements necessary reach
goal path coincide sstart . case, agent backtrack
way back sstart . sstart reached, agent move goal path cost
wc (sstart , sgoal ). Thus agent may incur cost higher 2wc (sstart , sgoal ) reach
goal.

obtain lower bound upper bound solution cost TB(WA*)
follows straightforwardly two previous lemmas.
Theorem 2 Let C solution cost obtained TB(WA*). Then,
b

N (w) 1
N (w) 1 +
cc C b
cc + 2wc (sstart , sgoal ).
k
k

Proof: put together inequalities implied Lemmas 2 3.



first observation result shown empirically domains,
w increased, N (w) may decrease substantially. Gaschnig (1977), example, reports
8-puzzle N (1) exponential depth solution whereas N (w), large w
subexponential d. domains grid pathfinding, well known using high values
w results substantial reductions expanded nodes (see e.g., Likhachev, Gordon, & Thrun,
2003). Thus, increasing w, lower bound first term upper bound may
decrease substantially. second term upper bound, 2wc (sstart , sgoal ), increasing
w, may increase linearly w. suggests situations better- rather
worse-quality solutions may found w increased. see later, confirmed
experimental evaluation.
second observation bounds factor b(N (w) 1)/kc decreases k increases. suggests k large (i.e., close N (w)), increasing w may actually lead
decreased performance.
Putting observations together, Theorem 2 suggests TB(WA*) produce better solutions TBA* k relatively small problems WA* expands fewer nodes
A* offline mode. Problems WA* expand fewer nodes A* exist (Wilt &
Ruml, 2012).
Finally, hard see Theorem 2 generalized algorithms provide
optimality guarantees. Given two search algorithms B provide bounds whose
relative performance known, theorem used predictor relative performance
TB(A) versus TB(B).
3.2 Non-reversible Search Problems via Restarting
non-reversible problems, well-known real-time heuristic search algorithms LSS-LRTA*
fail when, execution episode, state path goal visited.
Time-bounded algorithms TB(BFS) fail condition
fail soon physical backtrack required non-reversible action. second condition
556

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

failure reason sometimes time-bounded algorithms discarded use nonreversible domains. objective section propose time-bounded algorithm that,
used non-reversible problems, fail due latter condition, due former.
modification TB(WA*) non-reversible problems comes incorporating
two key characteristics real-time search algorithms LSS-LRTA*: search restarts heuristic
updates. Indeed, whenever physical backtracking available, or, generally,
predefined restart condition holds, algorithm restarts search. addition, avoid getting
trapped infinite loops, algorithm updates heuristic using update rule LSSLRTA*. call resulting algorithm Restarting Time-Bounded Weighted A* (TBR (WA*)).
Algorithm 5 shows details TBR (WA*). Lines 1012 relevant difference
previous algorithm. algorithm restarts search agent path certain
restart condition, must become true action leading current state
(scurrent ) parent (parent(scurrent )).
Algorithm 5: Restarting Time-Bounded Weighted A*
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

function MoveToGoal()
scurrent sstart
InitializeSearch()
scurrent 6= sgoal
goalFound = false
Bounded-WA*() = false return false;
scurrent path
scurrent state scurrent path
Execute movement scurrent
else restart condition holds
Update heuristic function h using LSS-LRTA* update rule (Equation 1)
InitializeSearch()
else
scurrent parent(scurrent );
Execute movement scurrent
return true
procedure Main
MoveToGoal() = true
print(the agent goal state)
else
print(no solution)

Note prior restarting algorithm updates heuristic LSS-LRTA* would.
implemented version Dijkstras algorithm. Note number states may
need updated may bounded constant. needed, compute update
incremental manner, across several episodes. refer reader analysis Koenig
Sun (2009), Hernandez Baier (2012) details implementation proofs
correctness.
3.2.1 ERMINATION TBR (WA*)
TBR (WA*) used reversible non-reversible domains. heuristic function h
initially consistent search graph strongly connected, algorithm terminates.
557

fiH ERN ANDEZ , BAIER , &

Theorem 3 Let P search problem strongly connected search graph. TBR (WA*),
run consistent heuristic h, finds solution P .
proof Theorem 3 depends intermediate results, proofs
appear elsewhere. following result establishes h consistent, remains consistent
updated.
Lemma 4 (Koenig & Sun, 2009) h consistent remains consistent h updated
Equation 1.
Another intermediate results says h cannot decrease update following Equation 1.
Lemma 5 (Koenig & Sun, 2009) h initially consistent h(s), every s, cannot decrease
h updated following Equation 1.
Another intermediate result says h(s) finitely converges, intuitively means even
wanted apply infinite number updates h, point on, h change
anymore.
Definition 1 (Finite Convergence) series functions {fi }i0 finitely converges function f
exists n every n, holds fm = f . addition, say series
functions {fi }i0 finitely converges exists function f finitely converges.
Lemma 6 Let h0 consistent heuristic function P strongly connected graph. Let
= {hi }i0 hk+1 function results (1) assigning hk hk+1 (2)
updating hk+1 using Equation 1, set Closed Open generated bounded Weighted
A* run rooted arbitrary state. finitely converges.
Proof: first observation hk (s) bounded positive number every
every k. Indeed, Lemma 4, hk consistent, thus admissible, every k.
addition, problem solution, hk (s) c (s, sgoal ), every every k.
second observation set h-values state take finite, even
infinite. Formally prove H(s) = {hk (s) | k 0} finite set. Indeed, hard verify
induction (we leave exercise reader) using Equation 1, every k 0,
holds hk (s) = c(ks ) + h0 (s0 ) some, possibly empty path ks originating finishing
s0 . recall hk (s) bounded observe finitely many paths
graph whose cost bounded. conclude H(s) finite set, every s.
proof follows contradiction, assuming finitely converge.
non-decreasing (Lemma 5), possibility increases infinitely often. implies
least one state H(s) infinite: contradiction. conclude finitely
converges.

Note previous lemma saying anything function converges to;
need know function rest proof. last intermediate result
related result Ebendt Drechsler (2009) stated Section 2.2 (Lemma 1).
Lemma 7 every moment execution Weighted A* state sroot , h consistent,
every state open list, holds g(s) wcClosed (sroot , s).
558

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

Proof: Let cost-optimal path sroot visits states Closed. Let s0
state precedes . s0 part optimal path have:
cClosed (sroot , s0 ) + c(s0 , s) = cClosed (sroot , s).

(2)

successor s0 , holds that:
g(s) g(s0 ) + c(s0 , s).

(3)

g(s0 ) wc (sroot , s0 ),

(4)

g(s) wc (sroot , s0 ) + c(s0 , s).

(5)

g(s) wcClosed (sroot , s0 ) + wc(s0 , s) = w(cClosed (sroot , s0 ) + c(s0 , s)).

(6)

Lemma 1, that:

Inequalities 3 4 imply:
w > 0 cClosed c :

Substituting Equation 2 that:
g(s) wcClosed (sroot , s),

(7)


finishes proof.
provide proof main result section.

Proof (of Theorem 3) : Let us assume algorithm terminate thus enters infinite
loop. Note means algorithm restarts infinite number times (otherwise, Weighted A*
would eventually find goal state, allowing agent reach goal). Assume moment
infinite execution h converged (we know Lemma 6), let s1 s2 . . .
infinite sequence states si state search restarted. prove
every i, h(si ) > h(si+1 ).
Let denote contents open list exactly algorithm expanded si+1 , Closed
denote contents closed list immediately heuristic updated. Equation 1,
following holds:
h(si ) = cClosed (si , ) + h(sO ),



(8)

rewrite Equation 8 as:
wh(si ) = wcClosed (si , ) + wh(sO ),

(9)

Let g(sO ) denote g-value exactly si+1 preferred expansion . Now,
prove wcClosed (si , ) g(sO ). Indeed, Closed follows Lemma 1
fact cClosed c w 1. hand, Open, obtain
wcClosed (si , ) g(sO ) Lemma 7. use fact write:
wh(si ) g(sO ) + wh(sO ).
559

(10)

fiH ERN ANDEZ , BAIER , &

algorithm preferred expand si+1 instead , g(sO ) + wh(sO ) g(si+1 ) +
wh(si+1 ), hence:
wh(si ) g(si+1 ) + wh(si+1 ).
(11)
Finally, w > 0 g(si+1 ) > 0 obtain h(si ) > h(si+1 ).
implies sequence states s1 s2 . . . strictly decreasing h-values.
state space finite, must case si = sj , j 6= j, would
lead conclude h(si ) > h(si ), contradiction.


4. Experimental Results
section presents experimental results. objective experimental evaluation
understand effect weight configuration performance TB(WA*) TBR
(WA*). end, evaluate TB(WA*) reversible search problems (grid pathfinding
15-puzzle), TBR (WA*) non-reversible problem (the racetrack). reference, compare
LSS-LRTWA* (Rivera et al., 2015), version LSS-LRTA* uses Weighted A* rather
A* search phase. used algorithm since among real-time search
algorithms able exploit weights search. LSS-LRTWA* configured perform
single action execution phase.
decided include results WLSS-LRTA* (Rivera et al., 2015), another real-time
search algorithm exploits weights, two reasons. First, new results focused relatively large lookahead values (over 128). lookahead values, Rivera et al. (2015),
grid-like terrain, observe improvements significant. Second, observed that,
15-puzzle, WLSS-LRTA* yields worse performance w increased.
Section 4.1 report results 8- 16-neighbor grids similar manner reported
earlier publication (Hernandez et al., 2014). Section 4.2 reports results 8- 16-neighbor
grids using Game Time Model (cf. Section 2.4). Section 4.3 reports results non-reversible
maps deterministic version setting used evaluate algorithms Stochastic ShortestPath problem (Bonet & Geffner, 2003). Finally, Subsection 4.4 reports results 15-puzzle.
path-finding tasks Section 4.1 Section 4.2 evaluated using 8-neighbor (Bulitko
et al., 2011; Koenig & Likhachev, 2005) and16-neighbor
grids (Aine & Likhachev, 2013) (see
Figure 5). costs movements 1, 2, 5 for, respectively, orthogonal, diagonal,
chess-knight movements. implementation agent cannot jump obstacles. addition, diagonal movement (d, d) (for {1, 1}) illegal (x, y) either (x+d, y) (x, +d)
obstacle. 8-neighbor 16-neighbor grids use octile distance Euclidean
distance heuristic values, respectively. experiments run Intel(R) Core(TM) i72600 @ 3.4Ghz machine, 8Gbytes RAM running Linux. algorithms common
code base use standard binary heap Open. Ties Open broken favor larger
g-values; rule breaking ties.
4.1 Results 8-Neighbor 16-Neighbor Grid Maps
evaluated algorithms considering solution cost runtime, measures solution quality
efficiency, respectively, several lookahead weight values.
used 512 512 maps video game Baldurs Gate (BG), Room maps
(ROOMS), maps different size Starcraft (SC) available N. Sturtevants
560

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

8-neighbor BG Maps

6000
4000
2000

Algorithm

Cost (log scale)

Cost (log scale)

)
)(3
.0

)
TB

(W
A*

)(2
.6

)
(W
A*

8-neighbor Counter Strike Maps

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

20000
10000

TB

Algorithm

8-neighbor Starcraft Maps

100000

)(2
.2

)
TB

(W
A*

)(1
.8

)
(W
A*
TB

TB

(W
A*

)(1
.0

)
)(3
.0

)
TB

(W
A*

)(2
.6

)
)(2
.2

(W
A*
TB

)(1
.8

(W
A*
TB

TB

(W
A*

)(1
.4

(W
A*

)(1
.0
TB

(W
A*
TB

)

300
)

500

300
)

500

)

1000

(W
A*

1000

10000

)(1
.4

2000

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

TB

6000
4000

Cost (log scale)

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

10000
Cost (log scale)

8-neighbor Room Maps
30000

2000
1000
500

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

1e+06

100000
20000
10000

Algorithm

0)
A*
)

(3
.

6)
TB

(W

A*
)

(2
.

2)
TB

(W

A*
)

(2
.

8)
(W
TB

(W

A*
)

(1
.

4)
TB

(W

A*
)

(1
.

0)
TB

TB

(W

A*
)

(1
.

0)
A*
)

(3
.

6)
TB

(W

A*
)

(2
.

2)
TB

(W

A*
)

(2
.

8)
TB

(W

A*
)

(1
.

4)
(1
.
TB

(W

A*
)
(W

TB

TB

(W

A*
)

(1
.

0)

2000

Algorithm

Figure 1: 8-neighbor results, solution cost tends decrease w lookahead parameter
increased.

path-finding repository (Sturtevant, 2012). addition, used 7 large maps Counter Strike
(CS), whose sizes range 4259 4097 4096 5462.
evaluated six lookahead values (1, 4, 16, 64, 128, 256) 512 512 maps six
lookahead values (1, 32, 128, 256, 512, 1024) SC CS maps. used six weight values
(1.0, 1.4, 1.8, 2.2, 2.6, 3.0). map generated 50 random solvable search problems, resulting 1800 problems BG, 2000 problems ROOMS, 3250 problems SC, 350
problems CS.
Figures 1 2 show performance measures 8-neighbor grid maps. Note
average search time per episode across algorithms using lookahead
parameter. search time per episode proportional lookahead parameter
depends variable (in particular, depend weight). Thus fair conclusions
drawn comparing two configurations lookahead parameter set
value.
561

fiH ERN ANDEZ , BAIER , &

8-neighbor BG Maps

)
)(3
.0

)
TB

(W
A*

)(2
.6

)
(W
A*

8-neighbor Counter Strike Maps

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

Runtime (ms)

Runtime (ms)

)(2
.2

)
)(1
.8

Algorithm

8-neighbor Starcraft Maps

50

(W
A*

TB

TB

(W
A*

)(1
.0
(W
A*

A*
)(

Algorithm

TB

)

0)
3.

6)
TB
(

W

A*
)(

2.

2)
TB
(

W

A*
)(

2.

8)
W
TB
(

TB
(

W

A*
)(

1.

4)
1.
A*
)(
W

TB
(

TB
(

W

A*
)(

1.

0)

0

)

1

10
8
6
4
2
0
(W
A*

2

)(1
.4

3

20

TB

Runtime (ms)

4

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

25

TB

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

5
Runtime (ms)

8-neighbor Room Maps

5
3
1

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

20000
10000

1000
200

Algorithm

)

)

(3.0
A*)
TB
(W

TB
(W

A*)

(2.6

)
(2.2
A*)
TB
(W

)
(1.8
A*)
TB
(W

)
(1.4

(1.0

A*)
TB
(W

(W

TB
(W

A*)

0)
A*
)

(3
.

6)
TB

TB

(W

A*
)

(2
.

2)

(W

A*
)

(2
.

8)
TB

TB

(W

A*
)

(1
.

4)
(1
.
A*
)

(W
TB

TB

(W

A*
)

(1
.

0)

)

60

Algorithm

Figure 2: 8-neighbor results, search time typically decreases w lookahead parameter
increased.

observe following relations hold maps regarding solution cost search time.

Solution Cost lookahead values, solution cost decreases w increased. significant improvements observed lower lookahead values. surprising light
cost bound (Theorem 2) . large lookahead parameters ( 256), value w
affect solution cost significantly. lookahead parameter increases, fewer search
episodes needed less physical backtracks (back moves) needed (Hernandez et al.,
2014). Back moves strongly influence performance algorithms. TB(WA*),
w increased number back moves decreases, explains improvement solution quality. example, BG maps, using lookahead 1, average reduction
back moves 1,960.5, comparing w = 1 w = 3, whereas lookahead 512
reduction 2.4, comparing w = 1 w = 3.
562

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

16-neighbor BG Maps
Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

6000
4000
2000
1000

10000
6000
4000
2000
1000

500

Algorithm

Cost (log scale)

Cost (log scale)

)
)(3
.0

)
TB

(W
A*

)(2
.6

)
(W
A*

16-neighbor Counter Strike Maps

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

20000
10000

TB

Algorithm

16-neighbor Starcraft Maps

100000

)(2
.2

)
TB

(W
A*

)(1
.8

(W
A*

)(1
.4
TB

)
(W
A*
TB

TB

(W
A*

)(1
.0

)
)(3
.0

)
TB

(W
A*

)(2
.6

)
TB

(W
A*

)(2
.2

)
)(1
.8

(W
A*
TB

)
(W
A*
TB

)

)(1
.4

(W
A*

)(1
.0
TB

(W
A*

)

500
300

300

TB

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

30000
Cost (log scale)

10000
Cost (log scale)

16-neighbor Room Maps

2000
1000
500

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

1e+06

100000
20000
10000

Algorithm

0)
A*
)

(3
.

6)
TB

(W

A*
)

(2
.

2)
TB

(W

A*
)

(2
.

8)
(W
TB

(W

A*
)

(1
.

4)
TB

(W

A*
)

(1
.

0)
TB

TB

(W

A*
)

(1
.

0)
A*
)

(3
.

6)
TB

(W

A*
)

(2
.

2)
TB

(W

A*
)

(2
.

8)
TB

(W

A*
)

(1
.

4)
(1
.
TB

(W

A*
)
(W

TB

TB

(W

A*
)

(1
.

0)

2000

Algorithm

Figure 3: 16-neighbor results, solution cost tends decrease w lookahead parameter
increased.

Search Time w increased, search time decreases significantly lower lookahead values
decreases moderately higher lookahead values. ROOMS observe largest
improvements w increased. behavior ROOMS explained WA*
performs well type map w > 1.
Figures 3 4 show performance measures 16-neighbor grid maps. observe
relations observed 8-neighbor grid maps regarding solution cost search time.
4.1.1 8-N EIGHBOR VERSUS 16-N EIGHBOR G RID APS
Lower cost solutions obtained 8-neighbor grids 16-neighbor grids lookahead values 1, 4, 16 BG. Note exist 16-neighbor movements
expensive 8-neighbor moves, small lookaheads, 16-neighbor solutions may
similar number moves, worse quality 8-neighbor solutions. hand,
563

fiH ERN ANDEZ , BAIER , &

16-neighbor BG Maps

)
)(3
.0

)
TB

(W
A*

)(2
.6

)

16-neighbor Counter Strike Maps

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

Runtime (ms)

Runtime (ms)

(W
A*

Algorithm

16-neighbor Starcraft Maps

50

)(2
.2

)

Algorithm

(W
A*

TB

TB

(W
A*

)(1
.0
(W
A*

A*
)(

)(1
.8

)

0)
3.

6)
TB
(W

A*
)(

2.

2)
TB
(W

A*
)(

2.

8)
TB
(W

A*
)(

1.

4)
1.
TB
(W

A*
)(
TB
(W

TB
(W

A*
)(

1.

0)

0

10
8
6
4
2
0

TB

1

)

2

(W
A*

3

20

)(1
.4

4

25

TB

Runtime (ms)

5

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

30

TB

Lookahead 1
Lookahead 4
Lookahead 16
Lookahead 64
Lookahead 128
Lookahead 256

7
Runtime (ms)

16-neighbor Room Maps

5
3
1

Lookahead 1
Lookahead 32
Lookahead 128
Lookahead 256
Lookahead 512
Lookahead 1024

20000
10000

1000
200

Algorithm

)

)

(3.0
A*)
TB
(W

TB
(W

A*)

(2.6

)
(2.2
A*)
TB
(W

)
(1.8
A*)
TB
(W

)
(1.4

(1.0

A*)
TB
(W

(W

TB
(W

A*)

0)
A*
)

(3
.

6)
TB

TB

(W

A*
)

(2
.

2)

(W

A*
)

(2
.

8)
TB

TB

(W

A*
)

(1
.

4)
(1
.
A*
)

(W
TB

TB

(W

A*
)

(1
.

0)

)

60

Algorithm

Figure 4: 16-neighbor results, search time typically decreases w lookahead parameter increased.

(a)

(b)

Figure 5: 8-neighborhoods (a) 16-neighborhoods (b).

564

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

8-neighbor Counter Strike Maps
10000

TB(WA*)(1.0)
TB(WA*)(1.4)
TB(WA*)(1.8)
TB(WA*)(2.2)
TB(WA*)(2.6)
TB(WA*)(3.0)

9000
8000
7000
6000
5000
4000
3000
2000
1000

TB(WA*)(1.0)
TB(WA*)(1.4)
TB(WA*)(1.8)
TB(WA*)(2.2)
TB(WA*)(2.6)
TB(WA*)(3.0)

9000
Number Time Intervals

Number Time Intervals

10000

16-neighbor Counter Strike Maps

8000
7000
6000
5000
4000
3000
2000

0.1

0.3

0.5

0.7

0.9

1.1

1000

Duration Time Interval (ms)

0.1

0.3

0.5

0.7

0.9

1.1

Duration Time Interval (ms)

Figure 6: Results Game Time Model.
similar quality observed lookahead values. TB(WA*), almost values w
lookahead configurations, 16-neighbor grids performs fewer moves 8-neighbor grids.
example, SC w = 2.6 lookahead parameter 1024, 8-neighbor grids need
factor 1.6 moves 16-neighbor grids. Note however 16-neighbor moves
higher cost 8-neighbor moves. Regarding runtime, TB(WA*) 8-neighbor connectivity runs faster TB(WA*) 16-neighbor connectivity. happens expansion
state 16-neighbor connectivity takes time expanding state 8-neighbor
connectivity.
4.2 Results Game Time Model
report results TB(WA*) using Game Time Model Counter Strike maps 8and 16-neighbor grids. use 0.1, 0.3, 0.5, 0.7, 0.9, 1.1 milliseconds duration time
intervals. setting, quality solution measured number time intervals
required solve problem, fewer intervals used, better solution quality
is.
Figure 6 shows average performance. observe length time interval increases, TB(WA*) yields solutions better quality. hand, w increased, TB(WA*)
obtains better solutions. observed clearly duration intervals
small (e.g., 0.1ms). observe better-quality solutions 16- rather 8-neighbor
connectivity. 16-neighbor connectivity agent perform knight move
single interval.
4.3 Results Non-reversible Search Graphs: Racetrack
section compare TBR(WA*) LSS-LRTWA* deterministic version racetrack problem (Barto, Bradtke, & Singh, 1995; Bonet & Geffner, 2003). problem race565

fiH ERN ANDEZ , BAIER , &

Extended Hansen Racetrack
400

TBR(WA*)(1.0)
TBR(WA*)(3.0)
TBR(WA*)(5.0)
TBR(WA*)(7.0)
LSS-LRT(WA*)(1.0)
LSS-LRT(WA*)(3.0)
LSS-LRT(WA*)(5.0)
LSS-LRT(WA*)(7.0)

300
250

TBR(WA*)(1.0)
TBR(WA*)(3.0)
TBR(WA*)(5.0)
TBR(WA*)(7.0)
LSS-LRT(WA*)(1.0)
LSS-LRT(WA*)(3.0)
LSS-LRT(WA*)(5.0)
LSS-LRT(WA*)(7.0)

450
400
Number Actions

350
Number Actions

Game Map Racetrack
500

200
150

350
300
250
200
150

100

100

Average Time per Search (ms)

2

8

6

1.

4

1.

1.

1

2
1.

8

6

0.

4

0.

0.

2
0.

2

2
2.

8

6

1.

4

1.

1

2

1.

1.

8

6

0.

0.

4

50
0.

0.

2

50

Average Time per Search (ms)

Figure 7: Results Racetrack Grids.
track represented grid cells marked obstacles. Similar grid pathfinding,
problem move agent set initial positions cells marked final
position. Nevertheless, problem agent associated velocity, set actions
involve accelerating (vertically horizontally), performing no-op action maintains
current velocity.
state racetrack tuple (x, y, vx , vy ), (x, y) position vehicle,
(vx , vy ) velocity vector. actions represented tuples form (ax , ay ),
ax , ay {1, 0, 1}, correspond acceleration vector. Unlike original version (Barto
et al., 1995), actions deterministic one initial one destination cell.
actions deterministic, (ax , ay ) performed (x, y, vx , vy ), new state given
(x0 , 0 , vx0 , vy0 ), vx0 = vx +ax vy0 = vy +ay , (x0 , 0 ) computed considering
vehicle changes velocity (vx0 , vy0 ) moving. movement towards (x0 , 0 )
would lead crashing obstacle, Bonet Geffner (2003) do, leave vehicle next
obstacle velocity (0, 0).
experiments, used two racetracks. firstwhich refer HRTis 33
207 grid corresponds extended version racetrack used Hansen Zilberstein (2001) (which 33 69 grid). use game map AR0205SR Baldurs Gate,
whose size 214x212. refer map GRT.
generated 50 random test cases HRT GRT Manhattan distance
initial state goal state greater half width map. absolute
value components velocity vector restricted 3. heuristic
use Euclidean distance divided maximum speed.
evaluated TBR (WA*) LSS-LRTAWA* four weight values (1.0, 3.0, 5.0, 7.0). Figure 7 shows plot number actions versus average time per search episode. TBR (WA*)
number actions corresponds sum number moves plus number times
566

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

TBWA*(2)
TBWA*(3)
TBWA*(4)
TBWA*(5)
LSS-LRTWA*(2)
LSS-LRTWA*(3)
LSS-LRTWA*(4)
LSS-LRTWA*(5)

0
50
10
0
15
0
20
0
25
0
30
0
35
0
40
0
45
0
50
0
55
0

100

Lookahead

100000

TBWA*(2)
TBWA*(3)
TBWA*(4)
TBWA*(5)
LSS-LRTWA*(2)
LSS-LRTWA*(3)
LSS-LRTWA*(4)
LSS-LRTWA*(5)

10000

0
50
10
0
15
0
20
0
25
0
30
0
35
0
40
0
45
0
50
0
55
0

1000

15-puzzle
Number Expansions (log scale)

Cost (log scale)

15-puzzle

Lookahead

Figure 8: Cost time comparison TB-WA LSS-LRTWA*

vehicle move. TBR (WA*) make movements search
restarted.
important note time spent updating heuristic proportional number
states updated. update TBR (WA*) may take time update
LSS-LRTWA* Closed list may contain states former algorithm.
reason use comparison average time per search, considers search
update time.
HRT (Figure 7) observe worst behavior one obtained TBR (WA*)(1.0).
algorithms improve performance increasing w, TBR (WA*), used weight
greater 1.0, algorithm clearly yields best performance. GRT, worst algorithms TBR (WA*)(1.0) LSS-LRTA(1.0). Here, algorithms improve increasing
weight.
benchmark used fewer problems game maps, carried
95% confidence analysis cost solutions. HRT, showed costs
best configuration TBR (WA*)(5.0) could 10% away true mean,
LSS-LRTA*(3.0) costs could 11% away true mean. GRT, hand,
difference performance two best configurations TBR (7) LSS-LRTWA*(7)
statistically significant.
Finally, experiments showed computational cost learning phase TB(WA*)
higher LSS-LRTA(WA*). Indeed, number updates carried TB(WA*)
3.4 times less number updates carried LSS-LRTA(WA*) HRT 1.6 time
less GRT. explains better performance terms runtime.
567

fiH ERN ANDEZ , BAIER , &

4.4 Results 15-Puzzle
chose 15-puzzle another domain evaluating time-bounded algorithms.
build 15-puzzle implementation extending Richard Korfs implementation available Carlos Linaress homepage.2 present results TB(WA*), LSS-LRT(WA*) algorithms.
use 100 test cases presented Korf (1993), uses Manhattan distance heuristic.
domain report results slightly different way. First, omit results TB(A*)
(TB(WA*) w = 1) terminate reasonable time. due fact
A* needs many expansions solving hardest test cases. Second, use number
expansions instead runtime efficiency measure. domain, found measure
stable since, general, solving 100 problems take much time
w > 1 (0.3s w = 2; 0.08s w = 3), thus time prone affected external factors
controlled operating system.
Figure 8 shows performance TB(WA*) LSS-LRT(WA*). use lookahead values
{16, 32, 64, 128, 256, 512} weights {2, 3, 4, 5}. observe following relations.
Solution Cost solution cost TB(WA*) decreases w increased almost lookahead
values. TB(WA*) obtains better results LSS-LRTWA* lookahead values
w > 2. w < 2 performance TB(WA*) worse performence LSSLRTA*. hand, TB(WA*) w = 5 obtains solution 2.0 times better
average solution obtained LSS-LRTA* (LSS-LRTWA* w = 1).
Number Expansions number expansions TB(WA*) decreases w increased.
TB(WA*) efficient LSS-LRTWA* lookahead values w > 2.
worst performing configuration TB(WA*) w = 1.
Note curve remains flat several configurations. small
number expansions needed solve problem.
conclusion, considering solution cost number expansions, 15-puzzle TB(WA*)
better algorithm. instance, average solution cost TB(WA*) 1.6 times better
average average solution cost LSS-LRTA*.
compare greedy algorithm (Parberry, 2015), real-time domainspecific, unlike our.

5. Summary Conclusions
paper introduced Time-Bounded Best-First Search, generalization real-time search
algorithm Time-Bounded A*. addition, introduced restarting version time-bounded
approach, TBR (WA*), unlike TB(BFS), better coverage non-reversible domains.
carried theoretical analysis TB(WA*) TBR (WA*), including termination
results cost bound TB(WA*). Given weight w, bound suggests TB(WA*)
significantly superior TB(A*) precisely search problems WA* expands significantly
fewer states A*. addition, bound suggests TB(WA*) may yield benefits
domains WA*, run offline, yield improvements A*. theoretical
bounds easily adapted instances Best-First Search offer guarantees solution
2. http://scalab.uc3m.es/clinares/download/source/ida/ida.html

568

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

quality. TBR (WA*), proved termination strongly connected graphs, even contain
non-reversible actions. property enjoyed real-time search algorithms LRTA*
family enjoyed TB(BFS).
experimental evaluation, focused pathfinding, 15-puzzle, racetrack
problem, found TB(WA*) TBR (WA*) significantly superior real-time
search algorithms LRTA* family. addition, found performance tends improve
weight parameter increased, without increasing time per search episode. finding
interesting although quality improved increasing lookahead parameter,
increases time spent search episode.
well known many search benchmarks, WA* may expand significantly fewer nodes
A*. Consistent this, experiments, time-bounded versions suboptimal algorithms
Weighted A* produce significantly better solutions obtained TB(A*). Improvements less noticeable lookahead parameter large, predicted theory.
first observe performance gains using weights real-time setting.
Indeed, findings consistent Rivera et al. (2015), obtain better solutions
using weighted heuristics. work adds another piece evidence justifies studying
incorporation weights real-time algorithms (e.g., RIBS EDA;* Sturtevant, Bulitko,
& Bjornsson, 2010; Sharon, Felner, & Sturtevant, 2014). Finally, SLA* (Shue & Zamani, 1993)
LRTS (Bulitko & Lee, 2006) two algorithms perform backtracking moves.
investigation whether restarts could provide benefits algorithms left future
work.

Acknowledgements
thank Vadim Bulitko providing Counter Strike maps. research partly funded
Fondecyt grant number 1150328.

References
Aine, S., & Likhachev, M. (2013). Truncated incremental search: Faster replanning exploiting
suboptimality. Proceedings 27th AAAI Conference Artificial Intelligence (AAAI),
Bellvue, Washington, USA.
Barto, A. G., Bradtke, S. J., & Singh, S. P. (1995). Learning act using real-time dynamic programming. Artificial Intelligence, 72(1-2), 81138.
Bjornsson, Y., Bulitko, V., & Sturtevant, N. R. (2009). TBA*: Time-bounded A*. Proceedings
21st International Joint Conference Artificial Intelligence (IJCAI), pp. 431436.
Bonet, B., & Geffner, H. (2003). Labeled rtdp: Improving convergence real-time dynamic
programming.. ICAPS, Vol. 3, pp. 1221.
Bulitko, V., & Lee, G. (2006). Learning real time search: unifying framework. Journal
Artificial Intelligence Research, 25, 119157.
Bulitko, V., Bjornsson, Y., Sturtevant, N., & Lawrence, R. (2011). Real-time Heuristic Search
Game Pathfinding. Applied Research Artificial Intelligence Computer Games. Springer.
Burns, E., Ruml, W., & Do, M. B. (2013). Heuristic search time matters. Journal Artificial
Intelligence Research, 47, 697740.
569

fiH ERN ANDEZ , BAIER , &

Ebendt, R., & Drechsler, R. (2009). Weighted A* search - unifying view application. Artificial
Intelligence, 173(14), 13101342.
Gaschnig, J. (1977). Exactly good heuristics?: Toward realistic predictive theory bestfirst search. Reddy, R. (Ed.), Proceedings 5th International Joint Conference
Artificial Intelligence (IJCAI), pp. 434441. William Kaufmann.
Hansen, E. A., & Zilberstein, S. (2001). Lao: heuristic search algorithm finds solutions
loops. Artificial Intelligence, 129(1), 3562.
Hart, P. E., Nilsson, N., & Raphael, B. (1968). formal basis heuristic determination
minimal cost paths. IEEE Transactions Systems Science Cybernetics, 4(2).
Hernandez, C., Asn, R., & Baier, J. A. (2014). Time-bounded best-first search. Proceedings
7th Symposium Combinatorial Search (SoCS).
Hernandez, C., & Baier, J. A. (2012). Avoiding escaping depressions real-time heuristic
search. Journal Artificial Intelligence Research, 43, 523570.
Hernandez, C., Baier, J. A., Uras, T., & Koenig, S. (2012). TBAA*: Time-Bounded Adaptive A*.
Proceedings 10th International Joint Conference Autonomous Agents Multi
Agent Systems (AAMAS), pp. 9971006, Valencia, Spain.
Koenig, S. (2001). Agent-centered search. Artificial Intelligence Magazine, 22(4), 109131.
Koenig, S., & Likhachev, M. (2005). Fast replanning navigation unknown terrain. IEEE
Transactions Robotics, 21(3), 354363.
Koenig, S., & Likhachev, M. (2006). Real-time adaptive A*. Proceedings 5th International
Joint Conference Autonomous Agents Multi Agent Systems (AAMAS), pp. 281288.
Koenig, S., & Sun, X. (2009). Comparing real-time incremental heuristic search real-time
situated agents. Autonomous Agents Multi-Agent Systems, 18(3), 313341.
Korf, R. E. (1990). Real-time heuristic search. Artificial Intelligence, 42(2-3), 189211.
Korf, R. E. (1993). Linear-space best-first search. Artificial Intelligence, 62(1), 4178.
Likhachev, M., Gordon, G. J., & Thrun, S. (2003). ARA*: Anytime A* Provable Bounds
Sub-Optimality. Proceedings 16th Conference Advances Neural Information
Processing Systems (NIPS), Vancouver, Canada.
Parberry, I. (2015). Memory-efficient method fast computation short 15-puzzle solutions.
IEEE Trans. Comput. Intellig. AI Games, 7(2), 200203.
Pearl, J. (1984). Heuristics: Preintelligent Search Strategies Computer Problem Solving.
Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA.
Pohl, I. (1970). Heuristic search viewed path finding graph. Artificial Intelligence, 1(3),
193204.
Rivera, N., Baier, J. A., & Hernandez, C. (2015). Incorporating weights real-time heuristic
search. Artificial Intelligence, 225, 123.
Schmid, K., Tomic, T., Ruess, F., Hirschmuller, H., & Suppa, M. (2013). Stereo vision based indoor/outdoor navigation flying robots. IEEE/RSJ International Conference Intelligent Robots Systems (IROS), pp. 39553962.
570

fiT IME -B OUNDED B EST-F IRST EARCH R EVERSIBLE N - REVERSIBLE EARCH G RAPHS

Sharon, G., Felner, A., & Sturtevant, N. R. (2014). Exponential deepening a* real-time agentcentered search. Proceedings 7th Symposium Combinatorial Search (SoCS), pp.
871877.
Shue, L., & Zamani, R. (1993). admissible heuristic search algorithm. Komorowski, H. J.,
& Ras, Z. W. (Eds.), Proceedings 7th International Symposium Methodologies
Intelligent Systems (ISMIS), Vol. 689 LNCS, pp. 6975. Springer.
Sturtevant, N. (2012). Benchmarks grid-based pathfinding. Transactions Computational
Intelligence AI Games, 4(2), 144 148.
Sturtevant, N. R., Bulitko, V., & Bjornsson, Y. (2010). learning agent-centered search.
Proceedings 9th International Joint Conference Autonomous Agents Multi Agent
Systems (AAMAS), pp. 333340, Toronto, Ontario.
Wilt, C. M., & Ruml, W. (2012). weighted A* fail?. Proceedings 5th Symposium Combinatorial Search (SoCS), Niagara Falls, Ontario, Canada.

571


