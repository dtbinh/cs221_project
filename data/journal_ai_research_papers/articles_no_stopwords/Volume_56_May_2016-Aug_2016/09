journal artificial intelligence

submitted published

generating matched formula
polynomial delay
petr savicky

savicky cs cas cz

institute computer science czech academy sciences
pod vodarenskou vez praha czech republic

petr kucera

kucerap ktiml mff cuni cz
department theoretical computer science mathematical logic
faculty mathematics physics charles university prague
malostranske nam praha czech republic

abstract
matched formula cnf formula whose incidence graph admits matching
matches distinct variable every clause formula satisfiable matched
formulas used example area parametrized complexity prove
counting number satisfying assignments matched
formula p complete hand define class formulas generalizing
matched formulas prove formula class one choose polynomial
time variable suitable splitting tree search formula
consequence formula class particular matched
formula generated sequentially delay polynomial size input
hand prove task cannot performed efficiently linearly
satisfiable formulas generalization matched formulas containing class
considered

introduction
consider counting satisfying assignments
generating subsets given formula conjunctive normal form cnf
well known counting general cnf p complete sipser
generating general cnf formula clearly hard
checking whether least one satisfying assignment formula
sat np complete garey johnson
mostly deal enumerating formula
important areas applications unbounded model
checking kang park mcmillan data mining coquery jabbour sais
salhi et al success modern sat solvers inspired design model counting
enumeration well see e g jabbour lonlac sais salhi morgado
marques silva b addition basic enumeration
require generated prescribed order versions
considered e g generating non decreasing weight creignou olive schmidt

another line concentrated studying special classes boolean formulas
enumeration guaranteed complexity could devised one
c

ai access foundation rights reserved

fisavicky kucera

easily example formula set exponentially larger
size formula case reasonable include size output
bound running time enumeration specifically say
enumerates formula runs output polynomial time
running time bounded polynomial two variables size input
e input formula size output e number
consider restrictive setting follows receives input
formula generates sequence way time needed
generating first model time generating two consecutive
sequence polynomial length formula type complexity bound
called polynomial delay clear enumerate formula
polynomial delay construct output polynomial
task well hand much harder get enumeration
polynomial delay output polynomial overview
notions enumeration complexity see johnson yannakakis papadimitriou
special classes formulas polynomial delay enumeration
described includes cnf formulas horn formulas generalized satisfiability
others see e g aceto monica ingolfsdottir montanari sciavicco
creignou hebrard dechter itai kavvadias sideri stavropoulos
describe another class formulas polynomial delay enumeration backtrack free search described contrary
known cnf horn formulas splitting variable step cannot
chosen arbitrarily however existence suitable variable guaranteed
efficiently identified
particular consider class matched formulas introduced franco
van gelder given cnf formula consider incidence graph defined follows bipartite graph one part consisting clauses
part containing variables edge x c variable x clause c
x x appears c observed aharoni linial tovey
admits matching e set pairwise disjoint edges size
number clauses satisfiable later formulas satisfying
condition called matched formulas franco van gelder since matching
maximum size bipartite graph found polynomial time see e g lovasz
plummer one check efficiently whether given formula matched
given general formula measure far matched considering maximum deficiency number clauses remain unmatched
maximum matching formula thus matched iff weaker notion
deficiency n number clauses n number
variables often considered
matched formulas play significant role theory satisfiability solving since
introduction matched formulas considered base class parameterized
satisfiability see e g book flum grohe overview
parameterized theory particular fleischner kullmann szeider
satisfiability formulas maximum deficiency bounded constant k
decided time kkno k kk length input formula n


figenerating matched formula

denotes number variables later improved szeider
satisfiability parameterized maximum deficiency formula
complexity k n parameterization backdoor sets respect matched
formulas considered szeider
since matched formulas trivially satisfiable ask stronger question
hard count enumerate matched formula prove counting
matched formula p complete turn attention
generating matched formula main
generates matched formula polynomial delay
constructs splitting tree whose nodes correspond matched unsatisfiable
formula however cases strategy sufficient since nodes tree
cannot split way prove node corresponds formula
satisfied iterated elimination pure literals formulas property
called pure literal satisfiable formulas studied kullmann
subclass linearly satisfiable formulas node pure literal satisfiable formula
reached switches simpler strategy prove pure
literal satisfiable formula generated delay linear length formula
hand sat pure literal satisfiable formulas p complete
p complete monotone cnfs valiant b
pure literal satisfiable
several generalizations matched formulas considered literature kullmann generalized matched formulas class linearly satisfiable
formulas autarkies matchings studied kullmann szeider
considered another generalization matched formulas classes biclique satisfiable
var satisfiable formulas unfortunately biclique satisfiable var satisfiable
formulas hard check formula falls one classes szeider
transfer class linearly satisfiable
formulas demonstrating possible generate linearly satisfiable
formula polynomial delay unless p np
organized follows giving basic definitions section describe
section specific simple splitting property class formulas allows
generate formula class efficiently section consider pure
literal satisfiable formulas prove class required splitting property
section consider matched formulas prove required splitting property
class formulas generalizes matched pure literal satisfiable formulas
natural way implies generating matched formula
formula general class polynomial delay section present
complexity bounds efficient versions previous sections
section negative concerning linearly satisfiable formulas section
contains concluding remarks directions

definitions
section give necessary definitions summarize use



fisavicky kucera

boolean functions
boolean function n variables mapping f n literal
variable called positive literal negation called negative literal negation
variable x denoted x x clause disjunction set literals
contains one literal variable formula conjunctive normal form
cnf equivalently cnf formula conjuction clauses often treat
clause set literals cnf formula set clauses well known
fact every boolean function represented cnf formula see e g genesereth
nilsson size formula number clauses
denoted length formula total number occurrences literals
e sum sizes clauses denoted kk given variable x
value x denotes formula originating substituting x
value obvious simplifications consisting removing falsified literals satisfied
clauses extend notation negative literals well setting x x
formula obtained assigning values ak variables
x xk denoted x x xk ak say literal l pure
cnf formula occurs formula negated literal l literal
irrelevant formula neither literal negation occurs formula
variable pure appears positively negatively e appears
literal pure
let formula defining boolean function f n variables assignment
values v n model satisfying assignment true point
satisfies f e f v set denoted
defined variables occurrence set variables
function defined formula larger however introduce special
notation general case algorithmic purposes necessary
since adding irrelevant variable formula changes set adding
variable possible values element original set
partial assignment assigns values subset variables formula
variables x xn represented ternary vector v n
vi denotes fact xi assigned value v
note empty clause admit satisfying assignment empty cnf
satisfied assignment
matched formulas
use standard graph terminology see e g bollobas given
undirected graph g v e subset edges e matching g edges
pairwise disjoint bipartite graph g b e undirected graph
disjoint sets vertices b set edges e satisfying e b set
w vertices g let w denote neighborhood w g e set vertices
adjacent element w shall use following well known matchings
bipartite graphs
theorem halls theorem let g b e bipartite graph matching
size exists every subset


figenerating matched formula

let c cm cnf formula n variables x x xn associate
bipartite graph x e called incidence graph
vertices correspond clauses variables x clause ci connected
variable xj e ci xj e ci contains xj xj cnf formula matched
matching size e matching pairs clause unique
variable shall call matching clause saturated matching note matched
cnf trivially satisfiable since clause satisfied literal containing
variable matched given clause variable matched clause
given matching called matched free otherwise
generating polynomial delay
main goal describe given matched formula
generates set polynomial delay let us state formally
require
say generates boolean formula polynomial
delay polynomial p given formula input
satisfies following properties
works steps takes time p kk
step finds model different obtained
previous steps particular model first step determines
model previous steps already found
properties exists follows construct
set time p kk means
output polynomial note since may exponential size respect kk
efficiency respect size input output best hope
constructing

efficient splitting tree
idea construct decision tree function represented
given satisfiable cnf every subtree larger single leaf contains leaf
depth tree number variables tree searched
dfs order time needed arbitrary moment reach leaf n
times time needed split node following classes
formulas including matched formulas possible splitting procedure
yields tree described
decision tree boolean function f labeled binary tree inner node
labeled variable leaves edges labels decision tree computes
f x given assignment x process starts root visited
node follows edge labeled value variable label node
output label leaf reached process computation path tests
variable tested previous part path test redundant
consider trees without redundant tests


fisavicky kucera

decision tree representing function given cnf formula constructed top follows root tree assigned non leaf node
tree assigned formula choose arbitrary split variable x
occurrence assign restricted formulas x x successors
node assigned empty formula becomes leaf node assigned formula
contains empty clause becomes leaf resulting decision tree represents
function given although large practical purposes path
root inner node u tree corresponds partial assignment changes
formula representing function computed subtree whose root u
depth tree function n variables n
leaf node labeled represents set precisely leaf
depth represents nd moreover different leaves tree represent
disjoint sets given decision tree function represented
traversing generate time proportional size process leads
large delay generating successive tree contains large subtrees
leaves following condition class formulas describes situation
avoided
definition let u class formulas let u let x variable
occurrence say x splitting variable relative u every
x satisfiable x u
class formulas u splitting property every formula u containing
variable contains splitting variable relative u
shall associate splitting class formulas u splitting property
definition let u class formulas splitting property splitting
relative u following given formula u splitting variable
relative u satisfiability tests formulas x x
note complexity splitting relative u upper bound
time satisfiability test formulas u formula satisfiable
variable x least one formulas x
x satisfiable satisfiability checks splitting variable x
required part solution splitting
theorem class formulas u splitting property splitting
relative u solved time c c kk formula u
formula u n variables generated delay n c
proof construct tree dfs order splitting variable every formula
assigned non leaf node non leaf node labeled x splitting
variable successors labeled x x formulas
unsatisfiable corresponding successor becomes leaf formulas
empty corresponding successor becomes leaf root tree split even
unsatisfiable however nodes labeled unsatisfiable formula split


figenerating matched formula

hence except possibly root node two leaves successors
since length every formula tree kk node time c
sufficient choose splitting variable determine successors leaf
construct formulas successors node
let us assume u non leaf node constructed tree different root
one successors u labeled unsatisfiable formula recognized
splitting successor leaf consequently time
c construction tree continues satisfiable successor u hence
n splitting steps time n c leaf reached
remark contains unit clause u closed unit propagation
variable x contained unit clause splitting variable identified efficiently
reason known satisfiable one formulas x contains
empty clause hence satisfiable
remark class u satisfies
satisfiability formulas u tested polynomial time
u closed partial assignments
splitting relative u polynomial complexity indeed case
variable formula u splitting variable satisfiability tests
corresponding restrictions obtained polynomial time class u property
sometimes conservative say property particular form
self reducibility sense considered e g khuller vazirani classes
generalized satisfiability described creignou hebrard
property addition classes consider instance horn formulas slur formulas
cnfs q horn formulas etc immediate corollary theorem possible
generate formulas classes polynomial delay
main splitting relative slight generalization matched formulas polynomial complexity although class matched
formulas closed partial assignments

pure literal satisfiable formulas
considering matched formulas let us make small detour class formulas
satisfiable iterated elimination pure literals call pure literal
satisfiable formulas already considered kullmann special
case linearly satisfiable formulas
set literals called consistent contain contradictory literals l
literal let assign l assignment variable contained l satisfies
l consistent set sequence literals l let assign l partial assignment
variables satisfying literals l formula l abbreviation
assign l


fisavicky kucera

definition pure literal sequence formula consistent sequence literals
l lk every k literal li pure irrelevant
formula l li particular l pure irrelevant pure literal sequence
called strict literals li pure l li
l pure literal sequence formula l called reduced formula
corresponding l l contain pure literal l called maximal
pure literal sequence
definition formula pure literal satisfiable pure literal sequence l
reduced formula l empty equivalently assign l satisfying
assignment
autarky formula partial assignment v variables every
clause satisfied unchanged v autarkies studied e g kullmann
note every initial segment pure literal sequence defines assignment
variables autarky moreover one easily verify property
characterizes pure literal sequences
let us note pure literal satisfiable formulas closed partial assignments
consider formula contain pure literal let formula obtained
adding variable x positive literal every clause formula
pure literal satisfiable x pure literal satisfiable follows
pure literal satisfiable formulas satisfy second property required remark
put effort showing pure literal satisfiable formulas
splitting property splitting relative pure literal satisfiable formulas
polynomial complexity
every cnf formula may tested polynomial time whether pure literal
satisfiable order pure literal sequence witnessing fact procedure
findpls uses greedy step chooses satisfies
pure literal current formula meaningful since literal
pure stage procedure remains pure becomes irrelevant
following stages pure literal sequence obtained procedure depends
nondeterministic choices made procedure however corollary resulting
reduced formula uniquely determined input
lemma clause c cnf removed run findpls
removed every run findpls input
proof let l k pure literal sequences produced different runs findpls
formulas l k corresponding reduced formulas let c
clause contained l hence l contains literals c since k
subset l pure literal sequence k literal l contained
k first literals pure k since k contain pure
literal literal l contained k particular c contained k
following immediate corollary


figenerating matched formula

constructing pure literal sequence
require cnf formula
ensure maximal strict pure literal sequence l corresponding reduced
formula
procedure findpls



initialize empty list literals l

initialize pure set pure literals

pure

choose literal l pure

add l l

l

update pure consist pure literals

end
end procedure

corollary let cnf formula let l pure literal sequence obtained
findpls
formula l uniquely determined
formula pure literal satisfiable l empty
since running time procedure findpls polynomial length input
formula maximal pure literal sequence formula constructed polynomial
time complexity constructing maximal pure literal sequence formula
fact kk lemma
lemma let l l ln pure literal sequence formula contains
literal variable n denote xi variable contained li
xi variable largest index among variables occurence
xi splitting variable relative pure literal satisfiable formulas
formulas xi xi satisfiable contain
empty clause
proof let one formulas xi xi let l l li
clearly l pure literal sequence moreover contain empty clause
l assigns value literals every clause hence satisfies
sufficient splitting relative class pure literal
satisfiable formulas polynomial complexity later theorem shall
splitting case solved time kk
lemma splitting relative class pure literal satisfiable formulas
polynomial complexity


fisavicky kucera

proof pure literal satisfiable pure literal sequence satisfies
obtained findpls polynomial time sequence contain literals
variables extended polynomial time appending arbitrary literals missing
variables obtain pure literal sequence satisfying assumption lemma
lemma implies method select splitting variable obtain
satisfiability test corresponding restrictions polynomial time
pure literal sequence satisfies assumption lemma formula
sequence used splitting variable formulas splitting tree
pure literal satisfiable formula generated
delay smaller general bound theorem see corollary
remark sign literal given variable occurs strict pure literal
sequence uniquely determined variables occur
positively negatively strict pure literal sequence formula
x x x x
example x x x x strict pure literal sequences formula

matched formulas
section concentrate matched formulas let us start showing
determining number matched formula e size
hard general sat
theorem determining given matched formula pcomplete
proof let c c cm arbitrary cnf formula n variables let
ym variables appearing let ym clause
let us define cnf formula n variables equivalent
c c cm
clearly matched formula one observe n
thus reduced counting general cnf formula
e general sat counting matched cnf
formula e sat restricted matched formulas
goal generate matched formula
polynomial delay theorem cannot used directly since class
matched formulas splitting property seen following
example consider formula
x x x x x x


figenerating matched formula

formula matched splitting variable indeed setting x leads
satisfiable yet matched formula x x x x symmetry true
variables x x well order achieve objective consider richer
class formulas class consider generalizes matched pure literal satisfiable
formulas follows note empty formula matched since corresponds
empty graph formally assume empty graph possesses required
matching
definition formula called pure literal matched reduced formula obtained
procedure findpls matched
elimination pure literal preserves property matched since pure literal
autarky hence matched formula pure literal matched clearly every pure literal
satisfiable formula pure literal matched since reduced formula empty hence
matched
basic idea efficient splitting matched formulas presented
following theorem later shall corollary splitting
relative pure literal matched formulas solved time n kk
theorem class pure literal matched formulas splitting property
splitting relative pure literal matched formulas polynomial complexity
order prove theorem several statements concerning
structure matched formula v set variables say clause limited
v contains literals variables v
definition let v subset variables matched formula let c denote
set clauses limited v set v called critical block
c v formally v empty critical block
note matched formula v subset variables c set
clauses limited v halls theorem theorem
c c v critical blocks achieving equality blocks
following property
lemma let v critical block matched formula every clause
saturated matching variables v matched clauses limited v
proof let matched formula fixed clause saturated matching
variables clauses v critical block v clauses limited
v clauses matched variables v since variables matched
clauses different variables v matched one clauses
another useful property set critical blocks follows
lemma set critical blocks matched formula closed intersection
proof let matched formula let v v critical blocks intersection
v v empty conclusion lemma satisfied variable x v v


fisavicky kucera

lemma every clause saturated matching variable matched
clause limited v v hence number clauses
limited v v least v v since matched number clauses
equal v v halls theorem hence v v critical block required
formula x variable contained least one critical block
lemma implies unique inclusion minimal critical block containing
x equal intersection critical blocks containing x matched
formula number clauses variables every variable contained
critical block since set variables formula critical block
definition matched formula number clauses variables x one variables let bx denote inclusion minimal critical block
containing x
notation bx specify formula since clear
context aim formula matched
splitting variable relative matched formulas actually pure literal satisfiable
order property basis shall first investigate
structure critical blocks respect matchings
lemma let matched formula number clauses variables
let l literal containing variable x let us assume formula l
matched
literal l pure irrelevant clauses limited bx
clause c contains l every matching c matched
variable bx denotes strict inclusion
proof symmetry shall consider case l x hence assumptions
x matched formula
critical block bx subset every critical block containing x hence order
prove first part lemma sufficient least one
critical block b containing x x occur negatively clauses
limited b let c set clauses halls condition
formula x satisfied c c let v c set
variables occurrence clauses c let k v
least k clauses c since every clause c limited v
least k clauses x limited v clauses
clause obtained clause removing literal x consider
set clauses limited v x since matched halls condition
satisfied set hence contains k clauses limited v x
setting x leads least k clauses limited v hence contains precisely
k clauses limited v x none contains literal x hence
v x critical block required property proof first part
lemma finished


figenerating matched formula

let us fix clause saturated matching clauses variables let
clause matched x since x matched follows
contains positive literal x otherwise matching would work
x well let c clause containing x let variable c
matched since c different x assumptions
set variables critical block hence critical block
well defined since c matched c limited lemma
implies x x c since critical block containing x
bx inclusion minimal critical block containing x bx first part
lemma clause limited bx contains x implies c limited
bx thus bx together get bx

structure critical blocks used following proposition needed
prove theorem
theorem let matched formula every variable x occurence
x matched pure literal satisfiable
proof let matched formula satisfying assumptions let us fix clause
saturated matching variable x matched
clause assigning value x yields matched formula assumption
therefore suppose variable exist variable matched
clause case numbers clauses variables equal
variable x bx well defined
let n number variables clauses n let li
literal containing variable xi clause matched variable every
n formula li matched formula li matched consider
strict partial order variables defined
x bx



means strict inclusion lemma variables maximal
partial order pure let us consider total ordering variables
consistent strict partial order appropriate renaming variables
may assume ordering x xn every j xi xj j
let us verify ordering sequence ln ln l satisfying pure literal
sequence let us induction n xi pure irrelevant
formula ln li true n lemma xn maximal
order variables induced inclusion critical blocks let us fix
consider partial assignment assign ln li lemma clause containing
li matched variable xj satisfying xi xj hence clauses eliminated
considered partial assignment variable xi pure irrelevant formula
ln li
proof theorem assume pure literal matched formula let l pure
literal sequence obtained findpls procedure let l


fisavicky kucera

assumption matched formula since l maximal contain pure literal
empty pure literal satisfiable formula splitting variable
method lemma empty matched pure
literal satisfiable hence theorem variable x x
x matched since l contain literal variable x
application assign l x commute hence l pure literal
sequence formula x application assign l x leads
x matched hence formula x pure literal
matched variable x splitting variable formula
time polynomial length formula sufficient select splitting variable
x proof nonempty satisfiability x x
guaranteed choice x empty pure literal satisfiable method
lemma used hence splitting variable required satisfiability
tests obtained polynomial time
similarly class matched formulas class pure literal matched formulas
closed unit propagation implies unit propagation used part
construction splitting tree particular remark select
variable unit clause splitting variable
proposition class pure literal matched formulas closed unit propagation
proof assume pure literal matched formula containing unit clause c l
l literal let us prove l pure literal matched formula
let l pure literal sequence observe l cannot contained l
l unsatisfiable rest proof distinguish whether l contained l

l contained l let l denote sequence literals l l let l
sequence literals l l simplicity written l l l l
clauses missing l changed removing l since l
contained l sequence l pure literal sequence l since assignments
disjoint sets variables commute l l l l hence sequence
l pure literal sequence formulas hence sequence l l l
pure literal sequence l since moreover l l l l l l application
l l leads matched formula consequently l pure literal matched
let us consider case l contained l case l matched
formula contains unit clause c l since clause cannot eliminated
satisfying literals l every maximum matching l clause c matched
l thus satisfying l gives matched formula l l since l l l l l
pure literal sequence l formula pure literal matched

complexity
section prove specific complexity bounds presented
previous sections complexity bounds derived ram model unit cost


figenerating matched formula

measure word size log kk input formula data structures
used similar described minoux murakami
uno let us first concentrate pure literal satisfiable formulas
lemma maximal pure literal sequence l cnf formula constructed
time kk
proof use presented linear time unit propagation
minoux obtain efficient version procedure findpls
addition initializations initialize auxiliary data structures
data structures similar described murakami uno
particular occurences literals formula represented nodes arranged
sparse matrix whose rows correspond literals columns correspond clauses
node contains identification clause literal whose occurence represents
auxiliary data structures names follows
literal l denote cl l row matrix doubly linked list
nodes representing occurences l
clause c denote lit c column matrix doublylinked list nodes corresponding occurences literals c
literal l denote cnt l counter contains size list lit c
number clauses l appears
initialize set pure queue contains pure literals
literals l cnt l cnt l
data structures initialized traversing linear time important
note node represents occurence literal l clause c
structure representing node contains four pointers two doubly linked list lit c
two double linked list cl l thus removing node lists
performed constant time
procedure findpls repeat following steps pure literal l add l
l apply assign l finding pure literal amounts dequeueing pure
applying assign l remove clauses containing l satisfied
remove l remaining clauses let consist clauses contain l
let consist clauses contain l claim assign l applied
time k k
removing clauses means going list cl l clause c
list literal l lit c including l remove corresponding node
cl l make list lit c inaccessible requires time literal l
operation decrement counters cnt l literals lit c
negated counterparts becomes pure add queue pure
removing occurrences l means going list cl l clause
c list remove corresponding node cl l lit c
done time occurrence l


fisavicky kucera

repeating steps literals included l requires constant number
operations occurrence literal input formula implies total
time kk

theorem splitting relative pure literal satisfiable formulas
solved time kk input pure literal satisfiable formula moreover
set pure literal satisfiable formula generated delay
kk
proof efficient version findpls guaranteed lemma operations
used proof lemma done time kk implies first statement
theorem procedure used preprocessing step
proving second statement time kk preprocessing produces pure literal
sequence l l ln contains literal variable auxiliary data
structures cl l lit c cnt l used preprocessing used later
stored reconstructed needed
construction l assumption lemma satisfied l method
lemma used splitting variable formula
corresponding restrictions contains empty clause satisfies assumption
lemma l hence sequence l used selecting splitting variable
nodes splitting tree
dfs search controlled stack postponed nodes initialized
root search starts search split sequence descending branches
descending branches starts removing node stack resuming
search node visited node two satisfiable successors dfs continues
one put onto stack node single satisfiable successor
stack modified descending branch ends leaf found
estimate delay estimate total time needed construct nodes one
descending branches follows
indices l splitting variables chosen descending branch monotonically decreasing hence total time needed search splitting variables
one descending branch n hence kk
time needed manipulations formula one descending branch
follows node removed stack auxiliary data structures cl l lit c
cnt l computed original formula modified according
sequence settings variables along path root current node
done time kk node descending branch assignments
chosen variable computed satisfiable successor selected one node
done time k k number occurrences chosen variable
satisfiable successor selected auxiliary structures updated according
total time needed operations one descending branch kk
similar argument proof corollary
combining estimates total time constructing descending branch
hence delay generating two consecutive kk


figenerating matched formula

let us concentrate time complexity selecting splitting variable pure
literal matched formula
lemma splitting relative pure literal matched formulas solved
time n kk input formula n variables
proof following proof theorem first pure literal sequence l
done time kk lemma l empty formula
last variable l splitting variable otherwise matched maximum

matching step performed time kk n see hopcroft karp
search variable x x x
matched variable exists theorem number clauses less
n variable used matching property otherwise check
every variable whether x matched assignment x satisfies
matched literal containing x x matched rest proof
estimate complexity n checks assignments falsifying
matched literal
partial assignment performed time kk kk partial assignment satisfied clauses removed occurences variable x removed
remaining clauses modify matching matching n x accordingly remove pairs containing satisfied clause pair containing x
n number clauses x done otherwise know
n since one pair containing clause x specifically
pair containing literal x removed forming n remains check
whether n already maximum matching whether better matching
tested looking single augmentating path x matching n
augmentating path found breadth first search time linear size
graph x see e g hopcroft karp lovasz plummer hence
test whether x matched done time kk kk
corollary lemma general bound theorem get
following
corollary pure literal matched formula n variables generated
delay n kk
proof lemma splitting variable pure literal matched formula
time n kk time determine satisfiability formulas x
x well theorem thus get delay n kk

linearly satisfiable formulas
section consider class linearly satisfiable formulas kullmann
class generalizes matched formulas pure literal satisfiable
formulas combining proofs class pure literal matched formulas
section possible generate linearly satisfiable formulas
polynomial delay unless p np


fisavicky kucera

consequence splitting relative linearly satisfiable formulas
polynomial complexity unless p np consequence follows unconditionally
example presents linearly satisfiable formula variables
splitting variable respect class linearly satisfiable formulas
let us recall notation introduced kullmann used present
definition basic facts concerning linearly satisfiable formulas l literal
var l variable literal v partial assignment v l value
assignment literal l
definition kullmann let cnf formula let v non empty
partial assignment variables say v simple linear autarky
associated weight function w assigns variable x evaluated v positive
real number w x clauses c
x
x
w var l
w var l

lc v l

lc v l

clearly literal c falsified v must literal satisfied v
well therefore simple linear autarky autarky kullmann showed check
whether simple linear autarky v cnf formula one exists
solving several linear programs
literal l pure formula partial assignment v l weight
w var l simple linear autarky formula another example consider
satisfying assignment satisfiable cnfs assignment weight
variables forms simple linear autarky similarly pure horn cnfs without unit
clauses satisfiable simple linear autarky assigns value equal weight
variables hand pure horn cnf formula contains unit clause
satisfiable simple linear autarky example formula
x x x x x x x x
simple linear autarky theorem lemma
considering iterative application simple linear autarkies formula get
class linearly satisfiable formulas defined follows
definition kullmann class linearly satisfiable formulas defined
smallest class satisfying following two properties
empty cnf linearly satisfiable
let cnf simple linear autarky v v linearly
satisfiable
words cnf formula linearly satisfiable subsequent applications
linear autarkies obtain empty formula composition simple linear autarkies
called linear autarky kullmann class linearly satisfiable formulas
therefore consists formulas satisfiable linear autarky kullmann showed
matched formulas linearly satisfiable since pure literal simple linear


figenerating matched formula

autarky pure literal satisfiable formula linearly satisfiable similarly pure literal
matched formula defined section linearly satisfiable simple linear autarkies
pure literals concatenated linear autarky resulting matched formula
matched pure literal satisfiable formulas presented
generate formulas polynomial delay possible extend
linearly satisfiable formulas unless p np let us first present construction
used reduction argument
let arbitrary cnf formula variables x xn clauses c cm
consider variables let formula consisting clauses

cj
j
xi
n
recall number formula number satisfying assignments
variables occurrence hence next lemma
defined different sets variables
lemma formula linearly satisfiable number


proof clause ci contains three literals hence clause number
positive literals least number negative literals follows
assignment variables equal weight variables defines simple linear
autarky satisfies hence formula linearly satisfiable
model satisfies assignment containing
model xi n assignment containing
model assignment variables xi model implies
second part statement lemma
since formula constructed every cnf formula lemma implies
following immediate corollary

corollary np complete determine whether general linearly
satisfiable formula least
note implies np hardness sat restricted linearly satisfiable formulas fact p complete since p complete
count monotone formulas pure literal satisfiable hence linearly
satisfiable
example present linearly satisfiable formula splitting
variable relative class linearly satisfiable formulas analysis example
use characterization simple linear autarkies obtained clause variable matrix
definition let cnf formula clauses c cm variables x xn
clause variable matrix formula matrix aj dimension n
defined

xi cj
xi cj
aj

otherwise


fisavicky kucera

u rm u means uj j kullmann showed following
proposition
lemma kullmann formula clause variable matrix simple
linear autarky nonzero z rn az moreover
linear autarky obtained vector z assignment

zi
v xi
zi

zi
weight function w xi zi
let us present well known farkas lemma form used proof theorem

theorem farkas lemma let n real matrix b rn exactly
one following statements true
vector rm bt
vector z rn az bt z
linear combination real vectors non negative coefficients called
simplicity non negative combination
theorem assume formula n variables clauses clausevariable matrix dimension n exactly one following statements
true
linear autarky
b every vector rn non negative combination rows
proof first assume b satisfied lemma implies
non zero z rn az b non negative vector rm
z multiplying z right get
az z z
contradiction since az non negative
assume b satisfied hence vector b rn non negative
combination rows farkas lemma vector z rn az
bt z since latter condition implies z non zero simple linear
autarky lemma means satisfied
lemma assume matrix dimension n rank n
vector u rm components positive ut every vector
rn non negative combination rows


figenerating matched formula

proof assumption linear space generated rows rn hence
every z rn v rm v z sufficiently large real number
vector v su components non negative v su z
note every linearly satisfiable cnf formula variables splitting
variable relative class linearly satisfiable cnf formulas since setting variable
constant leads formula variables quadratic
hence satisfiable linearly satisfiable
example denote e every boolean
variable x let x x x x formula
x x x x




xai

ae

linearly satisfiable splitting variable relative class linearly satisfiable
formulas
proof every clause number positive literals least number negative
literals hence formula linearly satisfiable lemma z
since invariant permutation variables sufficient prove
x splitting variable since every clause contains negative literal
follows formula x satisfiable one verify
x




xai

ae

e order prove x
linearly satisfiable consider clause variable matrix columns corresponding
x x x























matrix rank since vectors sum two
rows first three moreover sum rows matrix zero
vector hence formula x linear autarky lemma
theorem

conclusion directions
shown possible generate matched formula
n variables delay n kk byproduct shown


fisavicky kucera

pure literal satisfiable formula e formula satisfiable iterated pure literal
elimination generated delay kk shown
cannot generalized class linearly satisfiable formulas since possible
generate linearly satisfiable formulas polynomial delay unless p np
let us mention procedure generating bounded delay
extended formulas small strong backdoor set respect class
matched formulas empty clause detection found let us assume b
backdoor set formula e b set variables satisfying partial
assignment variables b leads matched formula formula containing
empty clause generate decision tree thus generate
time b kk f n kk unfortunately searching strong backdoor sets
respect class matched formulas hard szeider
described cases pure literal satisfiable pure
literal matched formulas used general model enumeration
splitting tree turn dpll enumeration
end similar one described stefan szeider used
together formula would keep maximum matching maximum
matching maintained reduction assignment steps performed
enumeration arrives matched formula
select splitting variables way described guaranteed
polynomial delay
interesting question whether could used parameterized
satisfiability maximum deficiency see szeider order get
parameterized generating general formula

acknowledgments
petr savicky supported ce iti gacr grant number gbp g
institutional plan rvo petr kucera supported
czech science foundation grant ga

references
aceto l monica ingolfsdottir montanari sciavicco g logic
programming artificial intelligence reasoning th international conference
lpar stellenbosch south africa december proceedings chap
enumerating maximal horn theories application
modal logics pp springer berlin heidelberg berlin heidelberg
aharoni r linial n minimal non two colorable hypergraphs minimal
unsatisfiable formulas journal combinatorial theory series
bollobas b modern graph theory vol graduate texts mathematics
springer


figenerating matched formula

coquery e jabbour sais l salhi et al sat
discovering frequent closed maximal patterns sequence proceedings
ecai
creignou n hebrard j j generating solutions generalized satisfiability
informatique theorique et applications
creignou n olive f schmidt j theory applications satisfiability
testing sat th international conference sat ann arbor mi usa
june proceedings chap enumerating solutions boolean csp
non decreasing weight pp springer berlin heidelberg berlin heidelberg
dechter r itai finding solutions one aaai
workshop tractable reasoning pp
fleischner h kullmann szeider polynomial time recognition minimal unsatisfiable formulas fixed clause variable difference theoretical computer
science
flum j grohe parameterized complexity theory st edition vol
texts theoretical computer science eatcs series springer verlag berlin
heidelberg
franco j van gelder perspective certain polynomial time solvable
classes satisfiability discrete appl math
garey johnson computers intractability guide theory
np completeness w h freeman company san francisco
genesereth nilsson n logical foundations artificial intelligence morgan
kaufmann los altos ca
hopcroft j e karp r n maximum matchings
bipartite graphs siam journal computing
jabbour lonlac j sais l salhi extending modern sat solvers
enumeration ieee th international conference information reuse
integration iri pp ieee
johnson yannakakis papadimitriou c h generating maximal
independent sets information processing letters
kang h j park c sat unbounded symbolic model checking
computer aided design integrated circuits systems ieee transactions

kavvadias j sideri stavropoulos e c generating maximal
boolean expression information processing letters
khuller vazirani v v planar graph coloring self reducible assuming
p n p theoretical computer science
kullmann investigations autark assignments discrete applied mathematics



fisavicky kucera

kullmann lean clause sets generalizations minimally unsatisfiable clausesets discrete applied mathematics renesse issue satisfiability
lovasz l plummer matching theory north holland
mcmillan k l computer aided verification th international conference
cav copenhagen denmark july proceedings chap applying sat
methods unbounded symbolic model checking pp springer berlin heidelberg berlin heidelberg
minoux ltur simplified linear time unit resolution horn
formulae computer implementation information processing letters
morgado marques silva j propositional model enumeration counting tech rep instituto de engenharia de sistemas e computadores
investigacao e desenvolvimento lisboa
morgado marques silva j b good learning implicit model enumeration tools artificial intelligence ictai th ieee international
conference pp pp
murakami k uno efficient dualizing large scale hypergraphs
discrete applied mathematics
sipser introduction theory computation vol thomson course
technology boston
szeider minimal unsatisfiable formulas bounded clause variable difference
fixed parameter tractable warnow zhu b eds computing
combinatorics vol lecture notes computer science pp springer
berlin heidelberg
szeider generalizations matched cnf formulas annals mathematics
artificial intelligence
szeider matched formulas backdoor sets marques silva j sakallah
k eds theory applications satisfiability testing sat vol
lecture notes computer science pp springer berlin heidelberg
tovey c simplified np complete satisfiability discrete applied
mathematics
valiant l complexity computing permanent theoretical computer
science
valiant l b complexity enumeration reliability siam journal
computing




