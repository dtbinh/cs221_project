Journal Artificial Intelligence Research 56 (2016) 463-515

Submitted 12/15; published 07/16

Computing Repairs Inconsistent DL-Programs EL Ontologies
EITER @ KR . TUWIEN . AC .

Thomas Eiter
Michael Fink
Daria Stepanova

FINK @ KR . TUWIEN . AC .
DASHA @ KR . TUWIEN . AC .

Institut fr Informationssysteme, TU Wien,
Favoritenstrae 9-11, 1040 Vienna, Austria

Abstract
Description Logic (DL) ontologies non-monotonic rules two prominent Knowledge
Representation (KR) formalisms complementary features essential various applications. Nonmonotonic Description Logic (DL) programs combine formalisms thus providing support rule-based reasoning top DL ontologies using well-defined query interface
represented so-called DL-atoms. Unfortunately, interaction rules ontology may
incur inconsistencies DL-program lacks answer sets (i.e., models), thus yields
information. issue addressed recently defined repair answer sets, computing
effective practical algorithm proposed DL-Lite ontologies reduces repair computation constraint matching based so-called support sets. However, algorithm exploits
particular features DL-Lite readily applied repairing DL-programs
prominent DLs EL. Compared DL-Lite , EL support sets may neither small
support sets might exist, completeness algorithm may need given
support information bounded. thus provide approach computing repairs
DL-programs EL ontologies based partial (incomplete) support families. latter
constructed using datalog query rewriting techniques well ontology approximation based
logical difference EL-terminologies. show maximal size number support sets given DL-atom estimated analyzing properties support hypergraph,
characterizes relevant set TBox axioms needed query derivation. present declarative implementation repair approach experimentally evaluate set benchmark
problems; promising results witness practical feasibility repair approach.

1. Introduction
Description Logics (DLs) powerful formalism Knowledge Representation (KR)
used formalize domains interest describing meaning terms relationships
them. well-suited terminological modelling contexts as, Semantic Web, data
integration ontology-based data access (Calvanese, De Giacomo, Lenzerini, Lembo, Poggi, &
Rosati, 2007b; Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007a), reasoning
actions (Baader, Lutz, Milicic, Sattler, & Wolter, 2005), spatial reasoning (zccep & Mller,
2012), runtime verification program analysis (Baader, Bauer, & Lippmann, 2009; Kotek,
Simkus, Veith, & Zuleger, 2014), mention few.
DLs fragments classical first-order logic, shortcomings modelling application settings, nonmonotonicity closed-world reasoning needs expressed.
Rules nonmonotonic logic programming offer features. addition, serve well
tool declaring knowledge reasoning individuals, modelling nondeterminism model generation possible Answer Set Programming. get best two
c
2016
AI Access Foundation. rights reserved.

fiE ITER , F INK & TEPANOVA



(1) Blacklisted Staff




(2) StaffRequest hasAction.Action hasSubject.Staff hasTarget.Project
= (3) BlacklistedStaffRequest StaffRequest hasSubject.Blacklisted



(4) StaffRequest(r1 ) (5) hasSubject(r1 , john) (6) Blacklisted (john)



(7) hasTarget(r1 , p1 ) (8) hasAction(r1 , read ) (9) Action(read )


(10) projfile(p1 ); (11) hasowner (p1 , john);






(12) chief (Y ) hasowner (Z , ), projfile(Z );









(13) grant(X) DL[Project projfile; StaffRequest](X), deny(X);
P=




(14) deny(X) DL[Staff chief ; BlacklistedStaffRequest](X);





(15)


hasowner
(Y,
Z),

grant(X),






DL[; hasTarget](X, ), DL[; hasSubject](X, Z).















Figure 1: DL-program policy ontology
worlds DLs nonmonotonic rules, natural idea combining led number
approaches combination, often called hybrid knowledge bases; see work
Motik Rosati (2010) references therein. Among them, Nonmonotonic Description Logic
(DL-)programs (Eiter, Ianni, Lukasiewicz, Schindlauer, & Tompits, 2008) prominent approach
so-called DL-atoms serve query interfaces ontology loose coupling enable bidirectional information flow rules ontology. possibility add
information rules part prior query evaluation allows adaptive combinations. However, loose interaction rules ontology easily lead inconsistency,
lack models answer sets.
Example 1 Consider DL-program = hO, Pi Figure 1 formalizing access policy
ontology = hT , Ai (Bonatti, Faella, & Sauro, 2010), whose taxonomy (TBox) given
(1)-(3), (4)-(9) sample data part (ABox) A. Besides facts (10), (11) simple
rule (12), rule part P contains defaults (13), (14) expressing staff members granted
access project files unless blacklisted, constraint (15), forbids owners project information lack access it. parts, P O, interact via DL-atoms
DL[Project projfile; StaffRequest](X). latter specifies temporary update via operator , prior querying it; i.e. additional assertions Project(c) considered individual c, projfile(c) true interpretation P, instances X StaffRequest
retrieved O. Inconsistency arises john, chief project p1 owner files,
access them.
Inconsistency well-known problem logic-based data intensive systems, problem treating logically contradicting information studied various fields, e.g. belief
revision (Alchourrn, Grdenfors, & Makinson, 1985; Grdenfors & Rott, 1995), knowledge base
updates (Eiter, Erdem, Fink, & Senko, 2005), diagnosis (Reiter, 1987), ontology based data access (Lembo, Lanzerini, Rosati, Ruzzi, & Savo, 2015), nonmonotonic reasoning (Brewka, 1989;
Sakama & Inoue, 2003), many others; (cf. Bertossi, Hunter, & Schaub, 2005; Nguyen, 2008;
Martinez, Molinaro, Subrahmanian, & Amgoud, 2013; Bertossi, 2011). hybrid formalisms
far inconsistency management concentrated mostly inconsistency tolerance. instance,
464

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

MKNF knowledge bases paraconsistent semantics developed Knorr, Alferes, Hitzler
(2008), Huang, Li, Hitzler (2013) Kaminski, Knorr, Leite (2015). DL-programs inconsistency tolerance issues targeted Fink (2012), paraconsistent semantics based
Logic introduced. Furthermore, Phrer, Heymans, Eiter (2010)
considered suppressing certain problematic DL-atoms. approaches aimed reasoning
inconsistent system rather making required changes system arrive consistent
state. contrast repair techniques recently developed Eiter, Fink,
Stepanova (2013, 2014d).
theoretical framework repairing inconsistent DL-programs proposed Eiter et al.
(2013), ontology ABox (a likely source errors) changed modified DL-program
answer sets, called repair answer sets. Different repair options including deletion ABox formulas various restricted forms addition considered together naive algorithm
computing repair answer sets lacked practicality.
effective repair algorithm DL-atoms decided without dynamic ontology
access presented Eiter, Fink, Stepanova (2015). based support sets (Eiter, Fink,
Redl, & Stepanova, 2014b) DL-atoms, portions input together ABox
determine truth value DL-atom. algorithm exploits complete support families, i.e.
stocks support sets value DL-atom every interpretation determined, (repeated) ontology access avoided. approach works well
DL-Lite , prominent tractable DL, since complete support families small easy
compute.
However, unfortunately, DLs approach readily usable, general
large infinite support families. applies even EL, another wellknown important DL offers tractable reasoning widely applied many domains, including biology, (cf. e.g., Schulz, Cornet, & Spackman, 2011; Aranguren, Bechhofer, Lord, Sattler, &
Stevens, 2007), medicine (Steve, Gangemi, & Mori, 1995), chemistry, policy management, etc. Due
features EL include range restrictions concept conjunctions left-hand side
inclusion axioms, DL-atom accessing EL ontology arbitrarily large infinitely
many support sets general. latter excluded acyclic TBoxes, often occurring
practice (Gardiner, Tsarkov, & Horrocks, 2006), complete support families still large,
constructing well managing might impractical. obstructs deployment
approach proposed Eiter et al. (2014d) EL ontologies. paper tackle issue
develop repair computation techniques DL-programs ontologies EL. focus EL,
since apart simple widely used, DL well-researched, available effective
algorithms query rewriting important reasoning readily used.
specifically, introduce general algorithm repair answer set computation operates partial (incomplete) support families along techniques families
effectively computed. problem computing repair answer sets DL-programs
EL ontologies P2 -complete (in formulation decision problem; refer work
Stepanova (2015) details complexity).
contributions advances previous works Eiter et al. (2014b, 2014d, 2015)
summarized follows:
effective computation repair answer sets exploit support sets Eiter et al.
(2014d). contrast approaches Eiter et al. (2014d, 2015), however, TBox
classification invoked, use datalog rewritings queries computing support sets
465

fiE ITER , F INK & TEPANOVA

(see Hansen, Lutz, Seylan, & Wolter, 2014). introduce notion partial support
families, ontology reasoning access completely eliminated.
general constructing complete support families always feasible EL ontologies, provide novel methods computing partial support families exploiting ontology
approximation techniques based logical difference EL-terminologies considered Konev, Ludwig, Walther, Wolter (2012) Ludwig Walther (2014).
capture restricted classes TBoxes, complete support families still
effectively computed, consider support hypergraph DL-atoms, inspired
ontology hypergraphs (Nortje, Britz, & Meyer, 2013; Ecke, Ludwig, & Walther, 2013).
support hypergraph serves characterize TBox parts relevant deriving
query. analysis support hypergraphs allows us estimate maximal size
number support sets needed form complete support family.
generalize algorithm repair answer set computation proposed Eiter et al. (2014d)
EL ontologies handled. novel algorithm operates partial support
families, principle applied ontologies DLs beyond EL. uses
hitting sets disable known support sets negative DL-atoms performs evaluation
postchecks needed compensate incompleteness support families. Moreover, trades
answer completeness scalability using minimal hitting sets; however completeness may
ensured simple extension.
provide system prototype declarative realization novel algorithm repair
answer set computation. repair approach evaluated using novel benchmarks; results show promising potential proposed approach.
Organization. rest paper organized follows. Section 2, recall basic notions
preliminary results. Section 3 deals support sets computation, Section 4
discusses partial support family construction based TBox approximation techniques. Section 5
analyze properties support hypergraph estimating maximal size number support sets complete support family DL-atom. Section 6, algorithm repair answer
set computation declarative implementation presented. Experiments presented Section 7, followed discussion related work Section 8 concluding remarks Section 9.

2. Preliminaries
section, recall basic notions Description Logics, focus EL (Baader,
Brandt, & Lutz, 2005), DL-programs (Eiter et al., 2008). background Description
Logics, (see Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003).
2.1 Description Logic Knowledge Bases
consider Description Logic (DL) knowledge bases (KBs) signature = hI, C, Ri
set individuals (constants), set C concept names (unary predicates), set R role
names (binary predicates) usual. DL knowledge base (or ontology) pair = hT , Ai
TBox ABox A, finite sets formulas capturing taxonomic resp. factual
466

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Tnorm


(1) StaffRequest hasAction.Action




(2)
StaffRequest hasSubject.Staff




(3)
StaffRequest
hasTarget.Project



(4) hasAction.Action ChasA.A
=
(5) hasSubject.Staff ChasS .St




(6) hasTarget.Project ChasT .P




(7) ChasA.A ChasS .St ChasA.AhasS .St



(8) ChasA.AhasS .St ChasT .P StaffRequest

Figure 2: Normalized TBox

























knowledge, whose form depends underlying DL. abuse notation, write =
viewing set formulas.
Syntax. EL, concepts C, denoting sets objects, roles R, denoting binary relations
objects, obey following syntax, C atomic concept R R
atomic role:
C | | C C | R.C
EL, TBox axioms form C1 C2 (also called generalized concept inclusion axioms,
GCIs), C1 , C2 EL-concepts. ABox formulas form A(c) R(c, d),
C, R R, c, I. sequel, use P generic predicate C R (if
distinction immaterial).
example EL ontology given Figure 1.
Definition 2 (normalized TBox) TBox normalized, axioms one following forms:
A1 A2
A1 A2 A3
R.A1 A2
A1 R.A2 ,
A1 , A2 , A3 atomic concepts.
E.g., axiom (1) Example 1 normal form, axioms (2) (3) not.
EL TBox, equivalent TBox normal form constructible linear time (Stuckenschmidt,
Parent, & Spaccapietra, 2009) (over extended signature)1 (Baader et al., 2005).
special class TBoxes widely studied literature EL-terminologies, defined follows:
Definition 3 (EL-terminology) EL-terminology EL TBox , satisfying following conditions:
(1) consists axioms forms C C, atomic C
arbitrary EL concept;
(2) concept name occurs left hand side axioms .
example, TBox ontology Figure 1 EL-terminology.
Semantics. semantics DL ontologies based first-order interpretations (Baader et al.,
2005). interpretation pair = hI , non-empty domain interpretation
1. Linear complexity results obtained standard assumption DLs atomic concepts
constant size, i.e., length binary string representing atomic concept depend particular
knowledge base.

467

fiE ITER , F INK & TEPANOVA

function assigns individual c object cI , concept name C subset
C , role name R binary relation RI . interpretation extends
inductively non-atomic concepts C roles R according concept resp. role constructors;
EL, (R.C)I = {o1 | ho1 , o2 RI , o2 C } (C D)I = {o1 | o1 C , o1 DI }.
Satisfaction axiom resp. assertion w.r.t. interpretation I, i.e. |= , follows:
(i) |= C D, C DI ; (ii) |= C(a), aI C ; (iii) |= R(a, b), (aI , bI ) RI .
Furthermore, satisfies set formulas , denoted |= , |= .
TBox (respectively ABox A, ontology O) satisfiable (or consistent),
interpretation satisfies it. call ABox consistent TBox , consistent.
Since negation neither available expressible EL, EL ontologies consistent.
Example 4 ontology Figure 1 consistent; satisfying interpretation = hI ,
exists, = {john, read , p1 , r1 }, Action = {read }, Blacklisted = Staff = {john},
hasSubject = {r1 , john}, StaffRequest = BlacklistedStaffRequest = {r1 }, hasAction =
{r1 , read }, hasTarget = {r1 , p1 }.
Throughout paper, consider ontologies EL unique name assumption (UNA),
i.e., o1 6= o2 whenever o1 6= o2 holds interpretation. However, results carry
ontologies without UNA, hard see UNA EL effect query
answering, (cf. Lutz, Toman, & Wolter, 2009).
2.2 DL-Programs
DL-program = hO, Pi pair DL ontology set P DL-rules, extend
rules non-monotonic logic programs special DL-atoms. formed signature
= hC, P, I, C, Ri, P = hC, Pi signature rule part P set C constant
symbols (finite) set P predicate symbols (called lp predicates) non-negative arities,
= hI, C, Ri DL signature. set P disjoint C, R. simplicity, assume
C = I.
Syntax. (disjunctive) DL-program = hO, Pi consists DL ontology finite set P
DL-rules r form
a1 . . . b1 , . . . , bk , bk+1 , . . . , bm

(1)

negation failure (NAF)2 ai , 0 n, first-order atom p(~t)
predicate p P (called ordinary lp-atom) bi , 1 m, either lp-atom DLatom. rule constraint, n = 0, normal, n 1. call H(r) = {a1 , . . . , }
head r, B(r) = {b1 , . . . , bk , bk+1 , . . . , bm } body r. B + (r) = {b1 , . . . , bk }
B (r) = {bk+1 , . . . , bm } denote positive negative parts B(r) respectively.
DL-atom d(~t) form
DL[; Q](~t),
(2)

(a) = S1 op 1 p1 , . . . , Sm op pm , 0 input list i, 1 m, Si
C R, op {} update operator, pi P input predicate arity
Si ; intuitively, op = increases Si extension pi ;
2. Strong negation added resp. emulated usual (Eiter et al., 2008).

468

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

(b) Q(~t) DL-query, one forms (i) C(t), C concept
term; (ii) R(t1 , t2 ), R role t1 , t2 terms; (iii) C1 C2 ~t = .
Note inclusion DL-queries form C1 C2 easily reduced instance queries.3
Thus simplicity, consider work instance DL-queries.
Example 5 Consider DL-atom DL[Project projfile; StaffRequest](X ) rule (13)
Figure 1 X = r1 . DL-query StaffRequest(r1 ); list = Project projfile
contains input predicate projfile extends ontology predicate Project via update
operator .
Semantics. semantics DL-program
= hO, Pi given terms grounding
gr() = hO, gr(P)i C, i.e., gr(P) = rP gr(r) contains possible ground instances
rules r P C. remainder, default assume ground.
(Herbrand) interpretation set HB ground atoms, HB Herbrand base P =hC, Pi, i.e. set ground atoms P ; satisfies lp- DL-atom a,

(i) I, lp-atom,
(ii) (a) |= Q(~t) = hT , Ai, DL-atom form (2),
(d) =


[

Ai (I) Ai (I) = {Si (~t) | pi (~t) I}, 1 m.

(3)

i=1

Satisfaction DL-rule r (resp. set P rules) Herbrand interpretation = hP, Oi
usual, satisfies bj , satisfy bj ; satisfies , satisfies
r P. |=O denote satisfies (is model of) object , (DL)atom, rule set rules; superscript |= specifies ontology DL-atoms
evaluated. model minimal, model exists I.
Example 6 DL-atom = DL[Project projfile; StaffRequest](r1 ) satisfied interpretation = {projfile(p1 ), hasowner (p1 , john)}, since |= StaffRequest(r1 ). =

O\{StaffReqeust(r1 )} still holds |=O d, (d) |= StaffRequest(r1 ).
Repair Answer Sets. Various semantics DL-programs extend answer set semantics logic
programs (Gelfond & Lifschitz, 1991) DL-programs, (e.g., Eiter et al., 2008; Lukasiewicz, 2010;
Wang, You, Yuan, & Shen, 2010; Shen, 2011). concentrate weak answer sets (Eiter
et al., 2008), treat DL-atoms atoms NAF, flp-answer sets (Eiter, Ianni, Schindlauer, & Tompits, 2005), obey stronger foundedness condition. answer sets
ordinary logic program interpretations minimal models program reduct,
intuitively captures assumption-based application rules reconstruct interpretation.
I,O
P relative HB results gr(P) deleting
weak -reduct Pweak
(i) rules r either 6|=O DL-atom B + (r), |=O l l B (r);
(ii) DL-atoms B + (r) literals B (r).
3. Evaluating = DL[; C1 C2 ]() = reduces evaluating = DL[; AC2 ](a) =
{AC1 C1 , C2 AC2 } {AC1 (a)}, fresh constant AC1 , AC2 fresh concepts (similar
TBox normalization).

469

fiE ITER , F INK & TEPANOVA

I,O
flp-reduct Pflp
P results gr(P) deleting rules r, whose bodies

satisfied I, i.e. 6|= bi , bi , 1 k |=O bj , bj , k < j m.
illustrate notions example.

Example 7 Let Figure 1, let rule set P contain facts (10), (11) rules
(12), (13) X, Y, Z instantiated r1 , john, p1 respectively. Consider interpretation =
I,O
{projfile(p1 ), hasowner (p1 , john), chief (john), grant(r1 )}. flp-reduct Pflp
contains
I,O
rules P, weak -reduct Pweak
rule (13) replaced fact grant(r1 ).

Definition 8 (x-deletion repair answer set) interpretation x-deletion repair answer set

= hT A, Pi x {flp, weak }, minimal model PxI,T , A;
called x-deletion repair . = A, standard x-answer set.
Example 9 = {projfile(p1 ), chief (john), hasowner (p1 , john), grant(john)} weak
flp-repair answer set Example 1 repair = A\{Blacklisted (john)}.
Notation. denote normal logic program P (P) set answer sets P,
DL-program x () (resp. RAS x ()) set x-answer sets (resp. x-repair
answer sets) .
general flp-answer set weak -answer set, vice versa, i.e. flp-answer sets
restrictive notion; however, many cases weak flp answer sets coincide.
information reducts, see works Eiter et al. (2008) Wang et al. (2010).
Shifting Lemma. simplify matters avoid dealing logic program predicates separately, shall shift Eiter et al. (2014d) lp-input DL-atoms ontology. Given
DL-atom = DL[; Q](~t) P p , call Pp (c) input assertion d, Pp
fresh ontology predicate c C; Ad set assertions. TBox
DL-atom d, let Td = {Pp P | P p }, interpretation I, let
OdI = Td {Pp (~t) Ad | p(~t) I}. have:
Proposition 10 (Eiter et al., 2014d) every = A, DL-atom = DL[; Q](~t) interI
pretation I, holds |=O iff |=Od DL[; Q](~t) iff OdI |= Q(~t).
Unlike OI (d), OdI clear distinction native assertions input assertions
w.r.t. (via facts Pp axioms Pp P ), mirroring lp-input. Note normal
form, Td normal form.

3. Support Sets DL-Atoms
section, recall support sets DL-atoms Eiter et al. (2014b), effective
optimization means (repair) answer set computation (Eiter et al., 2014d). Intuitively, support
set DL-atom = DL[; Q](~t) portion input that, together ABox assertions,
sufficient conclude query Q(~t) evaluates true; i.e., given subset
interpretation set ABox assertions ontology O, conclude
|=O Q(~t). Basically, method suggests precomputing support sets DL-atom
nonground level. DL-program evaluation, candidate interpretation ground instances
support sets computed, help prune search space (repair) answer sets.
470

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Exploiting Proposition 10 following definition support sets using ontology
predicates.
Definition 11 (ground support sets) Given ground DL-atom = DL[; Q](~t), set AAd
support set w.r.t. ontology = hT , Ai, Td |= Q(~t). Supp (d) denote
set support sets w.r.t. O.
Support sets grouped families support sets simply support families. formally,
Definition 12 (support family) collection Supp (d) support sets DL-atom
w.r.t. ontology support family w.r.t. O.
general EL particular, even -minimal support sets arbitrarily large
infinitely many support sets may exist (not acyclic TBoxes , still exponentially many
support sets possible). However, nonetheless exploit repair answer set
computation algorithms Section 6.
Support sets linked interpretations following notion.
Definition 13 (coherence) support set DL-atom coherent interpretation I,
Pp (~c) holds p(c) I.
Example 14 DL-atom = DL[Project Projfile; StaffRequest](r1 ) Figure 1 two
support sets: S1 = {StaffRequest(r1 )} S2 = {hasSubject(r1 , john),Projectprojfile (p1 ),
Staff (john),hasAction(r1 , read ), Action(read )}. S1 coherent interpretation,
S2 coherent interpretations {projfile(p1 )}.
evaluation w.r.t. reduces search coherent support sets.
Proposition 15 Let = DL[; Q](~t) ground DL-atom, let = hT , Ai ontology,
let interpretation. Then, |=O iff Supp (d) exists s.t. coherent I.
Using sufficient portion support sets, completely eliminate ontology access
evaluation DL-atoms. naive approach, one precomputes support sets ground DLatoms respect relevant ABoxes, uses repair answer set computation.
scale practice, since support sets may computed incoherent
candidate repair answer sets.
alternative fully interleave support set computation search repair answer
sets. construct coherent ground support sets DL-atom interpretation
fly. input DL-atom may change different interpretations, support sets must
recomputed, however, since reuse may possible; effective optimizations immediate.
better solution precompute support sets nonground level, is, schematic support
sets, prior repair computation. Furthermore, may leave concrete ABox open;
support sets DL-atom instance easily obtained syntactic matching.
~ = DL[; Q](X)
~
Definition 16 (nonground support sets) Let TBox, let d(X)
~
nonground DL-atom. Suppose V X set distinct variables C set constants.
nonground support set w.r.t. set = {P1 (Y~1 ), . . . , Pk (Y~k )} atoms
471

fiE ITER , F INK & TEPANOVA

(i) Y~1 , . . . , Y~k V
~k )} support set
(ii) substitution : V C, instance = {P1 (Y~1 ), . . . , Pk (Y
~
d(X) w.r.t. OC = AC , AC set possible ABox assertions C.
ontology = AC , denote SuppO (d) set nonground support sets
w.r.t. .
AC takes care possible ABox, considering largest ABox (since
implies Supp (d) Supp (d)).
Example 17 = DL[Project projfile; StaffRequest](X ) set S1 = {StaffRequest(X )}
nonground support set, likewise set S2 = {Action(W ), Staff (Y ), hasSubject(X , ),
hasTarget(X , Z ), Projectprojfile (Z ), hasAction(X , W )}.
sufficiently large portion nonground support sets precomputed, ontology access
fully avoided. call portion complete support family.
Definition 18 (complete support family) family SuppO (d) nonground support sets
~ w.r.t. ontology complete, every support set
(non-ground) DL-atom d(X)
~
~
~ exist
Supp (d(X)), : X C, extension : V C V X


= .
Example 19 Consider DL-atom d(X) = DL[Project projfile; StaffRequest](X) Figure 1. family = {S1 , S2 , S3 , S4 , S5 , S6 } complete w.r.t. O, hT = hasTarget,
hS = hasSubject hA = hasAction:







S1
S2
S3
S4
S5
S6

= {StaffRequest(X )};
= {Project(Y ), hT (X , ), hS (X , Z ), Staff (Z ), hA(X , Z ), Action(Z )};
= {Projectprojfile (Y ), hT (X , ), hS (X , Z ), Staff (Z ), hA(X , Z ), Action(Z )};
= {Project(Y ), hT (X , ), hS (X , Z ), Blacklisted (Z ), hA(X , Z ), Action(Z )};
= {Projectprojfile (Y ), hT (X , ), hS (X , Z ), Blacklisted (Z ), hA(X , Z ), Action(Z )};
= {BlacklistedStaffRequest(X )}.


say two nonground support sets (resp. support families) ground-identical,
groundings coincide. E.g., support sets S1 = {P (X), r(X, )} S2 = {P (X), r(X, Z)}
ground-identical DL-atom d(X) = DL[; Q](X), respective support families
{S1 } {S2 }.
Definition 20 (subsumption) nonground support set subsumed , denoted S,
every ground instance ground instance exists S.
nonground support families, say S1 subsumed S2 , denoted S2 S1 ,
instance S1 instance S2 exists holds.
Example 21 = {BlacklistedStaffRequest(X ),hasSubject(X , ),Blacklisted (Y )} support
set DL-atom d(X) = DL[Staff chief ; BlacklistedStaffRequest](X) w.r.t. Figure 1, subsumed = {BlacklistedStaffRequest(X )}, i.e. S. Moreover,
S, = {S } ={S}, support families = {S, } = {S,
{BlacklistedStaffRequest(X ),hasSubject(X , Z ),Blacklisted (Z )}} mutually subsume other.
472

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Axiom
Datalog rule
A1 A2
A2 (X) A1 (X)
A1 A2 A3 A3 (X) A1 (X), A2 (X)
R.A2 A1 A1 (X) R(X, ), A2 (Y )
A1 R.A2
R(X, oA2 ) A1 (X)
A2 (oA2 ) A1 (X)

Table 1: EL TBox Rewriting
Definition 22 (maximal support set size, maxsup) maximal support set size DL-atom
w.r.t. , denoted maxsup(d ), smallest integer n 0 every complete nonground support family w.r.t. support set |S| > n, support set
exists w.r.t. Suppd (O) |S | n.
instance, DL-atom TBox Example 19, maximal support set
size 6, i.e., maxsup(d) = 6.
3.1 Computing Support Sets
section, provide methods constructing nonground support sets. natural approach
computation nonground support sets exploit (conjunctive) query answering methods
EL (e.g., Rosati, 2007; Lutz et al., 2009; Kontchakov, Lutz, Toman, Wolter, & Zakharyaschev,
2010; Stefanoni, Motik, & Horrocks, 2012).
Suppose given DL-program = hO, Pi, = hT , Ai EL ontology,
~ = DL[; Q](X).
~ method construct nonground support sets d(X)
~
DL-atom d(X)
following three steps.
Step 1. DL-query Rewriting TBox. first step exploits rewriting DL~ TBox Td = {Pp P | P p } set datalog rules.
query Q d(X)
preprocessing stage, TBox Td normalized. technique restricts syntactic form
TBoxes decomposing complex simpler axioms. purpose, set fresh concept
symbols introduced. normalized form Td norm Td computed, rewrite part
TBox relevant query Q datalog program Prog Q,Tdnorm using translation
given Table 1, variant translation Prez-Urbina, Motik, Horrocks (2010)
Zhao, Pan, Ren (2009). rewriting axioms form A1 R.A2 (fourth axiom
Table 1), introduce fresh constants (oA2 ) represent unknown objects. similar rewriting
exploited R EQUIEM system (Prez-Urbina et al., 2010), function symbols used
instead fresh constants. result obtain:
Lemma 23 every data part, i.e., ABox A, every ground assertion Q(~c), deciding whether
Prog Q,Tdnorm |= Q(~c) equivalent checking Td norm |= Q(~c).
Step 2. Query Unfolding. second step proceeds standard unfolding rules
Prog Q,Td norm w.r.t. target DL-query Q. start rule Q head expand
body using rules program Prog Q,Tdnorm . applying procedure exhaustively,
get number rules correspond rewritings query Q Td norm . Note
always possible obtain rewritings effectively, since general might
473

fiE ITER , F INK & TEPANOVA

Prog Q,Td norm


(4 ) ChasA.A (X ) hasAction(X , ), Action(Y ).




(5 ) ChasS .St (X ) hasSubject(X , ), Staff (Y ).



(6 ) ChasT .P (X ) hasTarget(X , ), Project(Y ).
=

(7
) ChasA.AhasS .St (X ) ChasA.A (X ), ChasS .St (X ).





(8
)
StaffRequest(X ) ChasA.AhasS .St (X ), ChasT .P (X ).



(9) Project(X ) Projectprojfile (X ).

















Figure 3: DL-query Rewriting DL[Project projfile; StaffRequest](X) Td norm
infinitely many cyclic, still exponentially many acyclic ; discuss
techniques computing partial support families next section.
Step 3. Support Set Extraction. last step extracts nonground support sets rewritings
Step 2. select containing predicates Td obtain rules r form
~ P1 (Y~1 ), . . . , Pk (Y~k ), Pk+1
~k+1 ), . . . , Pnp (Y~n ),
Q(X)
(Y
(4)
pk+1

n

Pi native ontology predicate 1 k, predicate mirroring lp-input
otherwise. bodies rules correspond support sets given DL-atom, i.e.
~k+1 ), . . . , Pnp (Y
~n )}
= {P1 (Y~1 ), . . . , Pk (Y~k ), Pk+1
(Y
(5)
pk+1

n

following holds.
~ = DL[; Q](X)
~ DL-atom program = hO, Pi EL
Proposition 24 Let d(X)
~
ontology = hT , Ai. Every set constructed Steps 1-3 nonground support set d(X).
Shifting Lemma, working support sets focus ontology predicates
operate them. specifically, rules form (4) k n fully reflect nonground
support sets Definition 16, ground instantiations rule constants C
implicitly correspond ground support sets.
illustrate computation nonground support sets DL-atoms EL ontologies.
Example 25 Consider DL-atom DL[Project projfile; StaffRequest](X) accessing EL ontology = hT , Ai Figure 1. datalog rewriting computed Step 1 given
Figure 3. Step 2 obtain following query unfoldings StaffRequest:
(1) StaffRequest(X) StaffRequest(X);
(2) StaffRequest(X) hasAction(X, ), Action(Y ), hasSubject(X, ),
Staff (Y ), hasTarget(X, ), Projectprojfile (Y );
(3) StaffRequest(X) hasAction(X, ), Action(Y ), hasSubject(X, ),
Staff (Y ), hasTarget(X, ), Project(Y );
(4) StaffRequest(X) hasAction(X, ), Action(Y ), hasSubject(X, ),
Blacklisted (Y ), hasTarget(X, ), Project(Y );
(5) StaffRequest(X) hasAction(X, ), Action(Y ), hasSubject(X, ),
Blacklisted (Y ), hasTarget(X, ), Projectprojfile (Y ).
Step 3 thus get rule (2) S2 = {hasAction(X, ), Action(Y ), Staff (Y ),
hasSubject(X, ), hasTarget(X, ), Projectprojfile (Y )} rule (3) S3 ={Action(Y ),
hasAction(X, ),Staff (Y ),hasSubject(X, ), Project(Y ),hasTarget(X, )}. (1), (4)
(5) remaining support sets similarly obtained.

474

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

3.2 Partial Support Families
Finding support sets DL-atom tightly related computing solutions logic-based
abduction problem. Abduction important mode reasoning widely applied different areas
AI including planning, diagnosis, natural language understanding many others (Console,
Sapino, & Dupr, 1995). Various variants problem actively studied, e.g. Eiter,
Gottlob, Leone (1997) Bienvenu (2008). Unfortunately, practically important
problems context abduction intractable even restricted propositional theories (Eiter
& Makino, 2007). abduction problem EL TBoxes considered Bienvenu (2008),
represented tuple hT , H, Oi, TBox , set atomic concepts H atomic concept
O. explanation set {A1 , . . . , } H, |= A1 . . . O.
ABox Ad contains atomic concepts, computing nonground support sets =
DL[; Q](X) accessing = hT , Ai corresponds abduction problem hTd , sig(A Ad ), Qi.
roles occur Ad , one introduce new fresh concepts construct complex
concepts hypothesis, e.g., R.A inclusion CR.A R.A added Td , CR.A
H, CR.A fresh concept.
Unlike DL-Lite , support families DL-atoms EL ontologies particular
structure; large, maximal support set size exponential size .
Example 26 Consider following acyclic TBox , contains axioms:
(1) r.B0 s.B0 B1
(2) r.B1 s.B1 B2
...
(n) r.Bn1 s.Bn1 Bn
d1 = DL[; B1 ](X1 ), maximal support set size 4, witnessed
S1 = {r(X1 , X2 ), B0 (X2 ), s(X1 , X3 ), B0 (X3 )}.

DL-atom d2 = DL[; B2 ](X1 ), maxsup(d2 ) = 10, due S2 = {r(X1 , X2 ),
r(X2 , X3 ), B0 (X3 ), s(X2 , X4 ), B0 (X4 ), s(X1 , X5 ), r(X5 , X6 ), B0 (X6 ), s(X5 , X7 ), B0 (X7 )}.
Moreover, di = DL[; Bi ](X), maxsup(di ) = maxsup(di1 ) 2 + 2, 1 n.
Note maximal support set dn involves n + 3 predicates. Therefore, TBox
form, |sig(T )|= k, lower bound worst case support set size
2k1 + 2 = (2k ), single exponential size .

general many unfoldings produced Step 2, according recent results
Hansen et al. (2014), complete support families EL computed large classes ontologies. Therefore, still exploit support families, unlike Eiter et al. (2014d) require
complete, develop techniques computing partial (i.e. incomplete) support families DL-atoms. natural approach context aim finding support sets bounded
size. general, due cyclic dependencies r.C C, possible EL
DL-Lite , support sets arbitrary large. analysis vast number ontologies
revealed many realistic cases ontologies contain (nor imply) cyclic axioms (Gardiner
et al., 2006); thus assume practical considerations TBox ontology given
DL-program acyclic, i.e., entail inclusion axioms form r.C C. However, even
restriction support sets large Example 26 shows.
475

fiE ITER , F INK & TEPANOVA

computing complete support families computationally expensive, natural approach
produce support sets certain size k using e.g. limited program unfolding.
unfolding branch reaches depth k, stop expand different branch. Similarly, compute limited number k support sets stopping rule unfolding program Prog Q,Tdnorm
k-th support set produced. alternative approach, based TBox approximation
techniques, pursued next section.

4. Partial Support Family Construction via TBox Approximation
provide practical methods construct partial support families using TBox approximation.
4.1 TBox Approximation
approximation DL ontologies source language L different target language L
well-known important technique ontology management. Existing approaches
approximation roughly divided syntactic approaches semantic approaches. former,
e.g. Tserendorj, Rudolph, Krtzsch, Hitzler (2008) Wache, Groot, Stuckenschmidt (2005), focus syntactic form axioms original ontology appropriately
rewrite axioms comply syntax target language. rather effective general produce unsound answers (Pan & Thomas, 2007). Semantic approaches
focus model-based entailment original ontology, rather syntactic structure.
aim preserving entailments much possible transforming ontology
target language; general sound, might computationally expensive
(Console, Mora, Rosati, Santarelli, & Savo, 2014).
task computing partial support families, sound ontology approximation techniques
relevant. choose DL-Lite core target approximation language, lies intersection EL DL-Lite , complete support families effectively identified (Eiter
et al., 2014d). approach approximating TBox EL DL-Lite core exploits logical
difference EL TBoxes considered Konev et al. (2012). idea behind decide
whether two ontologies give answers queries given vocabulary (called signature)
, compute succinct representation difference empty. Typical queries include
subsumption concepts, instance queries conjunctive queries. setting subsumption queries particular interest, based nonground support families constructed.
~ ontology = hT , Ai,
approach follows. Given DL-atom = DL[; Q](X)
eliminate TBox Td axioms outside DL-Lite core language, obtain simplified
TBox Td . compute succinct representation logical difference Td Td
w.r.t. = {sig(Ad A) Q}; axioms logical difference fall DL-Lite core
added Td . restricting predicates potentially appear support sets avoid
redundant computations approximate relevant part TBox. approach
particularly attractive, logical difference EL intensively studied, e.g. Lutz,
Walther, Wolter (2007) Konev et al. (2012), polynomial algorithms available
EL-terminologies; thus confine latter.
present approximation approach formally, first recall notions introduced
Konev et al. (2012).
476

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Definition 27 (-concept difference) -concept difference EL-terminologies T1
T2 set cDiff (T1 , T2 ) EL-inclusions T1 |= T2 6|= .
Example 28 terminologies T1 = {B E, E r., C B} T2 =
{C A, B, C} holds cDiff (T1 , T2 ) = = {A, B, C},

cDiff (T1 , T2 ) = {B r.} = {B, r}.
two EL-terminologies entail concept subsumptions signature , i.e. holds
cDiff (T1 , T2 ) = cDiff (T2 , T1 ) = , called -concept inseparable,
C
C
denoted T1 C
T2 . E.g. Example 28 T1 T2 T1 6 T2 .
logical difference terms instance queries defined follows.
Definition 29 (-instance difference) -instance difference terminologies T1 T2
set iDiff (T1 , T2 ) pairs form (A, ), -ABox -instance
assertion, T1 |= T2 6|= . say T1 T2 -instance inseparable,
symbols T1 T2 iDiff (T1 , T2 ) = iDiff (T2 , T1 ) = .
easily seen, T1 T2 implies T1 C
T2 . converse obvious holds.
Theorem 30 (cf. Lutz & Wolter, 2010) EL-terminologies T1 T2 signature , T1 C

T2 iff T1 T2 .
4.2 Partial Support Family Construction
show DL-atom set support sets -concept inseparable terminologies. Prior that, establish following lemma.
Lemma 31 Let = DL[; Q](~t) DL-atom, let = hT1 , Ai EL ontology, let T2
C
TBox. T1 C
T2 , =sig(A) sig(Q) {P | P p }, T1 T2 ,

= sig(Ad ).
Armed this, obtain following result equivalence nonground support families.
~ DL-atom let T1 , T2 EL-terminologies
Proposition 32 Let = DL[; Q](X)
C
T1 T2 = sig(A Ad Q) {P | P p }. S1 S2 complete nonground
support families w.r.t. O1 = hT1 , Ai O2 = hT2 , Ai, respectively, S1 S2
ground-identical.
Given two EL-terminologies T1 T2 , inclusions C cDiff (T1 , T2 ) (resp.
C cDiff (T1 , T2 )) following Konev et al. (2012) called left (resp. right) witnesses denoted
lhs
cWTnrhs
(T1 , T2 ) (resp. cWTn (T1 , T2 )). shown every inclusion C concept difference T1 T2 contains either left right witness.
Theorem 33 (cf. Konev et al., 2012) Let T1 T2 EL-terminologies signature.
cDiff (T1 , T2 ), either C member cDiff (T1 , T2 ), sig()
concept name C EL-concepts occurring .
477

fiE ITER , F INK & TEPANOVA

Algorithm 1: PartSupFam: compute partial support family
~ ontology = hT , Ai
Input: DL-atom = DL[; Q](X),
Output: Partial nonground support family SuppO (d)
(a) {sig(A Ad ) Q}
(b) Td {Pp P | P p }
(c) Td Td \{C | C 6 {A, r.} 6 {A, r.}}
rhs
lhs
(d) lrw cWTn (Td , Td ) cWTn (Td , Td )


(e) Td Td {C lrw | C, {A, r.}}
(f) {ComplSupF am(d, Td )}
return
logical difference two EL-terminologies compact representation consists
inclusions atomic concept name either left right hand side. may
inclusions atomic concepts sides role restrictions form r., fall
target language DL-Lite core DL, therefore reintroduced.
ready describe algorithm P artSupF (see Algorithm 1) compute partial
~ ontology
families support sets. input given DL-atom = DL[; Q](X)
= hT , Ai, EL-terminology. first set signature (a) predicates
relevant support set computation d. construct TBox Td (b) simplified
version Td (c) removing Td axioms form C D, C complex
concept, i.e. axioms DL-Lite core fragment. (d) compute right-hand side
left-hand side witnesses Td Td store lrw . that, (e)
construct TBox Td extending Td axioms lrw , concepts form
r sides inclusions. Based support set construction method DL-Lite Eiter
et al. (2014d), obtain complete support family Td (f), partial support
family .
Proposition 34 family computed Algorithm 1 fulfills SuppO (d), i.e., partial
support family given DL-atom w.r.t. = A.
lwr = (d) cDiff (Td , Td ) = (e), guaranteed complete Proposition 32. general Algorithm 1 used computing support families DL-atoms
accessing arbitrary TBoxes4 , practically efficient procedures (d) available acyclic
EL-terminologies (Konev et al., 2012).

5. Bounded Support Sets
section, analyze size number support sets given DL-atom have.
bounds quantities hand, one limit search space support sets.
precisely, aim support set families sufficient evaluating DL-atom. support
sets (properly) subsumed another support set (i.e., ) dropped,
consider non-ground support families subsume (in particular, complete) support
family. formally,
4. computing logical difference arbitrary TBoxes recent results Feng, Ludwig, Walther (2015) might
exploited.

478

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Definition 35 (-complete support family) say nonground support family DL-atom
-complete w.r.t. ontology O, SuppO (d).
Thus question bounds size support sets cardinality smallest S.
Throughout section, tacitly assume TBoxes acyclic, i.e. entail inclusions form R.C C.
5.1 Estimation Support Set Size Bounds
first consider estimate maximal size support sets smallest -complete support
family analyzing syntactic properties given TBox. start with, recall work
Konev et al. (2012) atomic concept primitive terminology , occurs
axiom left-hand side, pseudo-primitive, either primitive occurs
left-hand side axioms C, C arbitrary EL concept.
EL-terminology every pseudo-primitive |= A, =
A1 . . . r1 .C1 . . . rm .Cm , (atomic) conjunct Ai exists |= Ai
(Konev et al., 2012, Lemma 15). obtain:
Proposition 36 Let = DL[; Q](~t) DL-atom, let EL-terminology. Q
pseudo-primitive , maxsup(d) = 1.
Proposition 36 exploits specific case, support set size bound 1. providing
liberal syntactic conditions ensure bounded size support sets, use ontology hypergraphs (Nortje et al., 2013; Ecke et al., 2013). latter widely studied extracting
modules ontologies (Nortje et al., 2013), determining concept difference EL terminologies (Ecke et al., 2013), efficient reasoning OWL 2 QL (Lembo, Santarelli, & Savo, 2013),
important tasks.
First let us recall notion directed hypergraph, natural generalization
directed graph, proposed Ausiello, DAtri, Sacc (1983) context databases represent functional dependencies.
Definition 37 (directed hypergraph) directed hypergraph pair G = (V, E), V
set nodes graph E set directed hyperedges form e = (H, H ),
H, H V nonempty sets called hypernodes.
Given hyperedge e = (H, H ), call H tail e H head e, denoted
tail (e) head (e), respectively. hypernode singleton, |H| = 1, binary hypernode,
|H| = 2; abuse notation, singleton {v}, simply write v. notion
ontology hypergraph DL EL introduced Ecke et al. (2013) follows.
Definition 38 (ontology hypergraph) Let EL TBox normal form, let C R.
ontology hypergraph GT directed hypergraph GT = (V, E),
V = {xA | C ( sig(T ))} {xr | r R ( sig(T ))} {x },
E = {({xA }, {xB }) | B }
{({xA }, {xr , xY }) | r.Y , C {}}
{({xr , xY }, {xA }) | r.Y , C {}}
{({xB1 , xB2 }, {xA }) | B1 B2 }.
479

fiE ITER , F INK & TEPANOVA

xr1

xr3

xA3

xA1

x C2

xr2

xA2

xA4

x C1

xD

xr4

Figure 4: Hypergraph GT Example 39
Example 39 Consider following TBox normal form:

(4) C1 C2

(1) r1 .A1 C1
(2) r2 .A2 C2
(5) A3 A2
=

(3) r .A
(6)
r4 .A4
3
3
1

ontology hypergraph GT =sig(T ) depicted Figure 4.







.



define notions directed path two nodes incoming path singleton
node ontology hypergraph; natural generalizations path standard graph.
Definition 40 (directed path, incoming path) Suppose EL TBox normal form,
GT = (V, E) ontology hypergraph, x, V singleton nodes occurring GT .
directed path x GT sequence = e1 , e2 , . . . , en (hyper) edges, that:
(i) tail (e1 ) x;
(ii) head (en ) y;
(iii) every ei , < n, successor s(ei ) = ej ei exists GT j > i, head (ei )
tail (ej ), s(ei ) = s(ei ) implies head (ei ) 6= head (ei ) 6= .
incoming path singleton node x V GT = (V, E) directed path = e1 , . . . , en
node V x, head (en ) = x. set incoming paths node x
hypergraph G denoted Paths(x , G).
Intuitively, hyperedges ontology hypergraph GT model inclusion relations (complex)
concepts . Consequently, incoming path singleton node xC GT models chain
inclusions logically follow , C rightmost element chain.
Example 41 Let us look ontology hypergraph GT Figure 4. sequence edges
1 = ({xr3 , xA3 }, xA1 ), ({xr1 , xA1 }, xC1 )
480

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

x 3p

xr1

3

xr3

xA3

xA1

x C2

xr2

xA2

xD

xC

xA

x C1

xB

xD

xQ


(a) Gsupp(d),T
Example 43


(b) Gsupp(d),T
Example 45

Figure 5: Examples support hypergraphs
incoming path xC1 GT reflects inclusions r1 .A1 C1 r1 .(r3 .A3 ) C1 ;
sequence
2 = ({xr3 , xA3 }, xA1 ), ({xr1 , xA1 }, xC1 ), ({xr2 , xA2 }, xC2 ), ({xC1 , xC2 }, xD )
incoming path singleton xD , following set inclusions extracted:
(1) C1 C2 D, (2) r2 .A2 C1 D, (3) r2 .A2 r1 .A1 D, (4) r2 .A2 r1 .(r3 .A3 ) D.

introduce notion support hypergraph DL-atom.
Definition 42 (support hypergraph) support hypergraph DL-atom d=DL[; Q](~t)

constructed follows:
normal ontology = hT , Ai hypergraph Gsupp(d),T
1. build ontology hypergraph GTd = (V, E), = sig(A Ad ) {Q};
2. leave nodes edges Paths(xQ , GTd ) remove nodes edges;
3. xC GTd C 6 , Paths(xC , GTd ) (hyper) node N exists {P | xP
N } leave xC , otherwise remove corresponding edges;
4. xr GTd , r 6 , leave e = ({xr , y}, xC ) (xC , {xr , y}) exists GTd ,
{xD , }, otherwise remove e.
Let us illustrate notion support hypergraph following example:
~
Example 43 Let Example 39 accessed DL-atom = DL[A3 p3 ; D](X),

Td = {A3p3 A3 }. support hypergraph Gsupp(d),T = sig(Td ) shown Figure 5a. node xD colored blue corresponds DL-query d. edge ({xD }, {xr4 , xA4 })

, lie incoming path xD .

Gsupp(d),T
481

fiE ITER , F INK & TEPANOVA

describing approach extracting support sets DL-atom hypergraph,
introduce notion tree-acyclicity. alternative definitions refer reader works,
e.g. Ausiello, DAtri, Sacc (1986), Gallo, Longo, Pallottino (1993) Thakur
Tripathi (2009).
Definition 44 (tree-acyclicity) hypergraph G = (V, E) called tree-acyclic, (i) one
directed path exists G singleton nodes x, V, (ii) G paths =
e1 , . . . , ek tail (e1 ) head (ek ) 6= .
refer hypergraphs tree-acyclic tree-cyclic.




= {B
Example 45 Gsupp(d),T
Figure 5a tree-acyclic, G = Gsupp(d),T


= {A
A3 , B A2 } = {B} not, neither G = Gsupp(d),T
,
1
C2 }.

hypergraph Gsupp(d),T
= DL[; Q](X), = {D C; C A; C B; B Q}
= sig(T ) given Figure 5b tree-cyclic, since contains two paths xD xQ ,
namely 1 = xD , xC , xA , {xA , xB }, xQ 2 = xD , xC , xB , {xA , xB }, xQ .


support hypergraph Gsupp(d),T
= (V, E) DL-atom = DL[; Q](X) contains
incoming paths xQ start nodes corresponding predicates Ad construction,
i.e. reflects inclusions Q right-hand side predicates Ad left
hand-side entailed Td . Hence, traversing edges incoming paths xQ ,
construct sufficiently many query rewritings Q TBox Td corresponding nonground
support sets allow subsume every nonground support family w.r.t. O.
support hypergraph given DL-atom tree-acyclic, support sets conveniently constructed annotating nodes variables Xi , N way described
hX
below. use subscripts annotations, e.g. xC means node xC annotated
hX ,X

variable Xi , xr j states xr annotated ordered pair variables Xi , Xj .
approach proceeds follows. start node xQ , annotate X0 ,
hX
i.e. xQ 0 ; traverse hypergraph backwards, going head edge tail.
every edge e encounter annotate tail (e) based form annotation
head (e), variable names occur annotation head (e) and/or fresh variable names Xi ,
N, following way:
(1) |tail (e)| = 1,
hX

(1.1) head (e) = {xC1 }, tail (e) annotated hXi i;
hXi1 ,Xi2

(1.2) head (e) = {xr1
hXi

hXi

, xC1 3 }, tail (e) = xC2 annotated hXi1 i, i.e.

obtain xC2 1 ;
hXi

(2) |tail (e)| = 2 head (e) = {xC

},
hX

hX

(2.1) tail (e)={xC1 ,xC2 }, xC1 xC2 annotated Xi , i.e. {xC1 ,xC2 };
hXi ,Xi1

(2.2) tail (e)={xr1 , xC1 }, get {xr1
482

hXi

, xC1 1 },

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

every annotated hypernode N , one create set nonground atoms predicate names
extracted labels hypernodes variable names annotations. nonground
support sets = DL[; Q](X0 ) constructed incoming paths xQ .
pick incoming path 1 xQ containing n edges, start traversing
edge en head (en ) = {xQ }. first immediate support set S1 = {Q(X0 )}; next
one, S2 , extracted annotated tail en taking nonground predicates labels
variables. pick edge ek head (ek ) tail (en ), obtain support
sets substituting nonground atoms correspond head (ek ) tail (en ) S2 atoms
extracted tail (ek ); repeated. One fact construct incoming path backwards
along support set extraction, maximal path obtained.

Example 46 Consider maximal incoming path xD Gsupp(d),T
Figure 5a:

= (xA3 p3 , xA3 ), ({xr3 , xA3 }, xA1 ), ({xr1 , xA1 }, xC1 ), ({xr2 , xA2 }, xC2 ), ({xC1 , xC2 }, xD ).
{z
} |
{z
} |
{z
} |
{z
}
|
{z
} |
e1

e2

e3

e4

e5

hX3
3i
Traversing path backwards, i.e. edges order e5 , e4 , e3 , e2 , e1 , obtain: (xhX
A3 p ,xA3 )e ,

{z
}1
hX
hX
hX
hX
hX hX
hX
hX
hX
0 ,X2
0 ,X1
2 ,X3
,xA1 2 },xC1 0 ) ,({xhX
,xA2 1 },xC2 0 ) ,({xC1 0 ,xC2 0 },xD 0 ).
({xhX
,xA3 3 },{xA1 2 }) ,({xhX
r1
r2
r3
{z
} |
{z
} |
{z
} |
{z
}
|
|

e2

e3

e4

3

e5

nonground support sets extracted resulting annotated path follows:

S0 = {D(X0 )} immediately obtained head (xD );
first incoming path consider 1 = e5 , get S1 = {C1 (X0 ), C2 (X0 )};
next path 2 = e4 , e5 head (e4 ) tail (e5 ), yielding support set S2 = {C1 (X0 ),
r2 (X0 , X1 ), A2 (X0 , X1 )};
then, 3 = e3 , e5 get S3 = {C1 (X0 ), r1 (X0 , X2 ), A1 (X2 )};
4 = e3 , e4 , e5 yields S4 = {r2 (X0 , X1 ), A2 (X1 ), r1 (X0 , X2 ), A1 (X2 )};
5 = e2 , e3 , e5 , extract S5 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3 (X3 ), C2 (X0 )};
6 = e2 , e3 , e4 , e5 yields S6 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3 (X3 ), r2 (X0 , X1 ), A2 (X1 )};
7 = e1 , e2 , e3 , e5 , extract S7 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3p3 (X3 ), C2 (X0 )};
finally, 8 = e1 , e2 , e3 , e4 , e5 get S8 = {r1 (X0 , X2 ), r3 (X2 , X3 ), A3p3 (X3 ),
r2 (X0 , X1 ), A2 (X1 )}.

following lemma formally asserts correctness procedure.

Lemma 47 Let SG support family constructed tree-acyclic hypergraph G=Gsupp(d),T
~ SG -complete w.r.t. O, i.e., SG every SuppO (d).
= DL[; Q](X).

particular, Lemma 47 holds complete w.r.t. ontology = hT , Ai. Thus
determine sufficiently many nonground support sets looking support hypergraph. Note restriction tree-acyclic TBoxes crucial correctness procedure
above, ensures every node hypergraph annotated once.
Lemma 47 allows us reason structure size support sets analyzing
parameters support hypergraph. One parameter, instance, maximal number
n(, G) hyperedges singleton head node excluding ({xr , }, xA ), occurring
incoming path xQ hypergraph G.
483

fiE ITER , F INK & TEPANOVA

xQ

xL

xE
xF

xD

xM

xB

xA

xK
xC


Figure 6: Support hypergraph Gsupp(d),T
Example 49

Proposition 48 Let = hT , Ai EL ontology normal form, let =
~ DL-atom tree-acyclic support hypergraph G
DL[; Q](X)
.
supp(d),T

maxsup(d) maxG

supp(d),T


(n(, Gsupp(d),T
)) + 1.

(6)

tree-cyclic hypergraphs, bound tight, illustrate next.
Example 49 Consider DL-atom d(X) = DL[; Q](X) accessing TBox Td :


(4) E F L


(1) F
(2) C K
(5) E K
.
Td =



(3) B E
(6) L Q

support hypergraph depicted Figure 6, = sig(Td ). six hyperedges singleton head nodes, maximal support set size d(X) 4, e.g. =
{A(X), B(X), D(X), K(X)}.

next define out- in-degrees nodes hypergraph.
Definition 50 (hyper-outdegree -indegree) Given directed hypergraph G = (V, E),
hyper-outdegree denoted hd+ (x) (resp., hyper-indegree hd (x)) singleton node x V
number hyperedges e E tail (e) x (resp., head (e) x) either |tail (e)| = 2
|head (e)| = 2. Similarly, outdegree d+ (x) (resp., indegree (x)) x number
edges e E tail (e) = {x} (resp., head (e) = {x}) |head (e)| = |tail (e)| = 1.


Example 51 nodes X V\{xA3p , xD } hypergraph Gsupp(d),T
Figure 5a hyper+
+
outdegree 1, xAp3 xD hd (xAp3 ) = hd (xD ) = 0, moreover, d+ (xAp3 ) = 1.
hyper-indegrees hd (xA3 ) = hd (xA1 ) = hd (xC1 ) = hd (xC2 ) = 1. graph

({xC2 , xA2 }, xD ), holds hd+ (xC2 ) = hd+ (xA2 ) = hd (xD ) = 2,
G = Gsupp(d),T
moreover, (xA3 ) = 1.


484

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

let us define
smax (x, G) = maxPaths(x,G) (n(, G) m(, G) + 1),
(7)
P
m(, G) = xA (hdc+ (xA ) 1), hdc+ (xA ) number hyperedges form
({xA , xB }, xC ) .


Example 52 Consider Gsupp(d),T
Figure 5a, Paths(xD , Gsupp(d),T
) contains single maximal path xD , viz. = (xA3p3 , xA3 ), ({xr3 , xA3 }, xA1 ), ({xr2 , xA2 }, xC2 ), ({xr1 , xA1 }, xC1 ),
({xC1 , xC2 }, xD ). n(, G) = 4, four hyperedges singleton head node,
m(, G) = 0, nodes hyper-outdegree 1; hence smax (xQ , G) = 4 0 + 1 =
5. hypergraph Figure 6 single maximal incoming path xQ , n(, G) = 6,
m(, G) = (hdc+ (xA ) 1) + (hdc+ (xE ) 1) = 3; thus smax (xQ , G) = 6 3 + 1 = 4.


generalize bound maximal support set size Proposition 48 using
parameter smax (xQ , G) node corresponding DL-query Q DL-atom d, obtain
following result hypergraphs possibly tree-cyclic:
Proposition 53 Let = hT , Ai EL ontology normal form, let =
~ DL-atom support hypergraph G
DL[; Q](X)
supp(d),T , role predi
cates. maxsup(d ) smax (xQ , Gsupp(d),T ).

) = 4,
Example 54 tree-cyclic hypergraph Figure 6 smax (xQ , Gsupp(d),T
4 indeed maximal support set size = DL[; Q](X). hypergraph Figure 5a

3 hyperedges, every node x V, hd+ (x) 1. Thus, smax (xQ , Gsupp(d),T
) = 4,
coincides maxsup(d ), = DL[A3 p3 ; Q](X).


Note Proposition 53, take computing m(, G) outgoing hyperedges
form ({xC , xD }, xE ) account, C, D, E concepts, moreover, roles occur .
Multiple outgoing hyperedges involving roles r r influence support set size.
Example 55 Let support hypergraph = DL[; Q](X) hyperedges ({xr , xC }, xD ),
({xC , xs }, xM ), ({xD , xM }, xQ ) r , reflecting axioms r.C D, s.C
DQ. largest minimal support set S={r(X, ), C(Y ), s(X, Z), C(Z)}; size
n + 1, n number hyperedges singleton head node, hd+ (xC ) = 2.
5.2 Number Support Sets
Orthogonal question considered previous section conditions given
number n support sets sufficient obtain -complete support family. problem tightly
related counting minimal solutions abduction problem, analyzed Hermann
Pichler (2010) propositional theories various restrictions. particular, counting minimal explanations shown # coNP-complete general propositional theories
#P -complete Horn propositional theories; EL subsumes propositional Horn logic, determining size smallest -complete support family least #P -hard thus intractable.
size support sets, support hypergraph fruitfully exploited estimating
maximal number support sets given DL-atom. provide estimate, traverse
support hypergraph forward starting leaves label every node xP number
rewritings P . conveniently compute labels, introduce support weight functions.
485

fiE ITER , F INK & TEPANOVA


Definition 56 (support weight function) Let Gsupp(d),T
= (V, E) support hypergraph
DL-atom d. support weight function ws : V N assigns every node xA V number
ws(xA ) rewritings w.r.t. .

every node tree-acyclic support hypergraph, value ws conveniently computed recursive manner.

Proposition 57 Let Gsupp(d),T
tree-acyclic support hypergraph DL-atom (normalized) ontology = hT , Ai. ws given follows, VC V set nodes
concepts:



1, P
Q
ws(x) = 1 + (x) x ws(x )

P
P

+ (x),T 6VC ({x },T )E ws(x ),

hd (x) = 0 (x) = 0 x
/ VC ,
otherwise.
(8)

(x) = {T | (T, {x}) E}.

demonstrate usage Proposition 57 following examples.

Example 58 compute ws(x) nodes Gsupp(d),T
Figure 5a, traverse graph
leaves root, x {xr1 , xA2 , xC2 , xr2 , xA3p3 , xr3 } obtain ws(x) = 1; furthermore,
ws(xA3 ) = ws(xC2 ) = 2, ws(xA1 ) = 3, ws(xC1 ) = 4. Finally, ws(xD ) = 1 + ws(xC1 )
ws(xC2 ) = 1 + 4 2 = 9, number rewritings D(X) (and hence support sets
d(X) = DL[A3 p3 ; D](X)) identified Example 46.

Example 59 Consider TBox = {A B Q; C A; A; E A; F B; G B; H
B; L} DL-atom = DL[; Q](X), whose support hypergraph = sig(T )
Figure 7. ws(xQ ) = 1 + ws(xB ) ws(xA ) = 1 + 4 4 = 17, indeed 17
rewritings Q(X), namely S1 = {A(X), B(X)}, S2 = {C(X), B(X)}, S3 = {D(X), B(X)},
S4 = {E(X), B(X)}, S5 = {A(X), F (X)}, S6 = {A(X), G(X)}, S7 = {A(X), H(X)}, S8 =
{C(X), F (X)}, S9 = {C(X), G(X)}, S10 = {C(X), H(X)}, S11 = {D(X), F (X)}, S12 =
{D(X), G(X)}, S13 = {D(X), H(X)}, S14 = {E(X), F (X)}, S15 = {E(X), G(X)}, S16 =
{E(X), H(X)}, S17 = {Q(X)}.
immediate corollary Proposition 57, obtain

= (V, E) tree-acyclic support hypergraph DL-atom =
Corollary 60 Let Gsupp(d),T
~ EL ontology = hT , Ai. edge e E satisfies |tail (e)|=|head (e)|=1,
DL[; Q](X)

X
ws(tail (e)) + 1.
(9)
ws(v) =
eE | head(e)=v

Thus query node xQ , get ws(xQ ) = |E| + 1. fact, Proposition 57 leads
simple bound size -minimal complete support families general cases.
486

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

xC

xD

xE

xF

xA

xG

xH

xB

xQ

Figure 7: Hypergraph Gsupp(d),T


= (V, E) tree-acyclic support hypergraph DL-atom
Proposition 61 Let Gsupp(d),T
~ EL ontology, every edge e = ({x, y}, z) E edges
= DL[; Q](X)
e1 , e2 E head (ei ) {x, y}, {1, 2}, holds head (e1 ) = head (e2 ).
|SG
| = |E| + 1.
supp(d),T


Example 62 hypergraph Gsupp(d),T
Figure 5a single maximal path length 5,
hyperedges satisfy condition Corollary 61. 6 support sets, |S| = |E| + 1 holds.

condition Proposition 61 e e1 , e2 violated, maximal size minimal complete support family assessed easily. instance, support hyper
Figure 7 contains 7 edges, 17 support sets. shown k
graph Gsupp(d),T

nodes Gsupp(d),T violate condition, SG
contains |E|k+1 + 1 support sets;
supp(d),T

considered example, yields bound 72 + 1 = 50, far tight.
note Proposition 57 applied tree-cyclic support hypergraphs.

= DL[; Q](X), =
Example 63 Consider tree-cyclic support hypergraph Gsupp(d),T
{D C; C A; C B; B Q} = sig(T ), shown Figure 5b. Using
Proposition 57 get ws(xD ) = 1, ws(xC ) = 2, ws(xA ) = 3, ws(xB ) = 3, ws(xQ ) =
33+1 = 10. However, Q(X) 4 rewritings: (1) S1 = {Q(X)}, (2) S2 = {A(X), B(X)},
(3) S3 = {C(X)}, (4) S4 = {D(X)}.
Intuitively, tree-cyclic hypergraphs support weight function ws may account nonminimal rewritings {B(X), C(X)}, {A(X), C(X)}, {A(X), D(X)}, {B(X), D(X)},
rewritings counted multiple times. Thus general, ws(x) provides upper bound
number rewriting. Likewise, bound Proposition 61 tight even simple treecyclic support hypergraphs; e.g., one DL-atom = DL[; Q](X) w.r.t. TBox Bi ,
Bi Q, 1 n, contains 2 n edges, n + 2 support sets.


6. Repair Computation Based Partial Support Families
section, present algorithm SoundRAnsSet computing deletion repair answer
sets. shown Stepanova (2015), deciding whether given DL-program = hT A, Pi
EL ontology deletion repair answer set P2 -complete general case,
membership part established guessing candidate repair ABox along candidate
487

fiE ITER , F INK & TEPANOVA

answer set = hT , Pi, suitability guess checked using NP oracle.
Clearly efficient, |2n | candidate repair ABoxes n = |A|, even finding
answer set would cheap.
restrict search space repairs approach work Eiter et al. (2014d)
exploiting support families DL-atoms; however, contrast results Eiter et al. (2014d),
support families required complete. families complete (which may
known asserted construction), SoundRAnsSet guaranteed complete;
otherwise, may miss repair answer set, easy extension ensures completeness.
algorithm repair answer set computation, shown Algorithm 2, proceeds follows.
start (a) computing family nonground support sets DL-atom.
Next (b) so-called replacement program constructed.
replacement program obtained simple rewriting gr(), DL-atom
replaced ordinary atom ed (called replacement atom), disjunctive choice rule
ed ned added informally guesses truth value d, ed (respectively ned )
stands value true (respectively false). repair answer set augmented
proper choice ed resp. ned answer set (Eiter et al., 2013, Proposition 13); thus
search confined answer sets , found using standard ASP
solver.
(c) answer sets computed one one.
determine (d) sets Dp (resp. Dn ) DL-atoms guessed true (resp.
I,
A) instantiates DL-atoms
false) use function Gr(S, I,

Dp Dn relevant ground support sets, i.e., compatible I.
(e) loop minimal hitting sets H support sets DL-atoms Dn
consist ABox assertions, (f) construct H set Dp atoms
Dp least one support set disjoint H (thus removing H
affect values atoms Dp ).

(g) evaluate postcheck atoms Dn Dp \Dp A\H w.r.t. I.
Boolean flag rep stores evaluation result function eval n (resp. eval p ). specifically, given Dn (resp. Dp ), A\H, function eval n (resp. eval p ) returns true,
atoms Dn (resp. Dp ) evaluate false (resp. true).
\ H, P) succeeds, (h)
rep true foundedness check flpFND(I,


restriction I| original language output repair answer set.
remark many cases, foundedness check might trivial superfluous (Eiter,
Fink, Krennwallner, Redl, & Schller, 2014a), e.g., loops DL-atoms;
consider weak answer sets (Eiter et al., 2013), entirely skipped.
Example 64 Let DL-program Example 1 equivalence () axioms (2)
(3) weakened , assertions Project(p1 ) BlacklistedStaffRequest(r1 )
added ABox A. Moreover, assume d1 (r1 ) = DL[Project projfile; Staffrequest](r1 ),
d2 (r1 )=DL[Staff chief ; BlacklistedStaffRequest](r1 ), d3 (r1 ,p1 )=DL[; hasTarget](r1 ,p1 )
488

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Algorithm 2: SoundRAnsSet: compute deletion repair answer sets
Input: =hT A, Pi
Output: set repair answer sets
(a) compute set nonground support families DL-atoms
(b) construct replacement program
(c) ()

Dn {d | ned I};
SIgr
A);
(d)
Dp {d | ed I};
Gr(S, I,


(e)
minimal hitting sets H Dn SIgr (d )

(f)
Dp {d Dp | SIgr (d) s.t. H = }
A\H) evalp (Dp \Dp , I,
A\H)
(g)
rep evaln (Dn , I,
hT A\H, Pi) output I|

(h)
rep flpFND(I,
end
end

d4 (r1 ,john) = DL[; hasSubject](r1 ,john). (b) following replacement program
constructed:



(1) ed1 (r1 ) ned1 (r1 ); (2) ed2 (r1 ) ned2 (r1 ); (3) ed3 (r1 , p1 ) ned3 (r1 , p1 );








(4)
e
(r1
,
john)

ne
(r1
,
john);
(5)
projfile(p1
);
(6)
hasowner
(p1
,
john);


d4
d4






(7) chief (john) hasowner (p1 , john), projfile(p1 );
=
.


(8) grant(r1 ) ed1 (r1 ), deny(r1 );










(9) deny(r1 ) ed2 (r1 );





(10) hasowner (p1 , john), grant(r1 ), ed3 (r1 , p1 ), ed4 (r1 , john).

Suppose = {ed1 , ned2 , ed3 , ed4 , hasowner (p1 , john), projfile(p1 ), chief (john)} returned
(c) following partial support families obtained (d):


SIgr (d1 ) = {S1 , S2 }, S1 = {hasAction(r1 , read ), hasSubject(r1 , john), Action(read ),
Staff (john), hasTarget(r1 , p1 ), Projectprojfile (p1 )} S2 = {StaffRequest(r1 )};


SIgr (d2 ) = {S1 ,S2 }, S1 = {StaffRequest(r1 ),hasSubject(r1 , john),Blacklisted (john)}
S2 = {BlacklistedStaffRequest(r1 )}.


SIgr (d3 ) = {S1 }, S1 = {hasTarget(r1 , p1 )};


SIgr (d4 ) = {S1 }, S1 = {hasSubject(r1 , john)}.
(e) get hitting set H = {StaffRequest(r1 ), BlacklistedStaffRequest(r1 )}, disjoint
S1 , S1 S1 . Thus (f) obtain Dp = {d1 , d3 , d4 } (g) check whether
d2 false A\H. true, rep = false pick different hitting set H , e.g.
{Blacklisted (john), BlacklistedStaffRequest(r1 )}. Proceeding H , get (g),
H) = true flp-check succeeds (f), interpretation I|
output.
eval n (d2 , I,

following results state algorithm works properly.
489

fiE ITER , F INK & TEPANOVA

Theorem 65 Algorithm SoundRAnsSet sound, i.e., given program = hT A, Pi, every
output deletion repair answer set .
know addition support families complete, postchecks (g)
redundant. Dp = Dp , set rep = true, otherwise rep = false.
Theorem 66 Suppose input program = hT A, Pi Algorithm SoundRAnsSet,
holds DL-atom support family computed Step (a) SoundRAnsSet
-complete. Algorithm SoundRAnsSet complete, i.e., outputs every deletion repair
answer set .
easily turn SoundRAnsSet complete algorithm, modifying (e) consider
hitting sets, minimal ones. worst case, means fallback almost naive
algorithm (note hitting sets enumerated efficiently relative number).
6.1 Optimizations Extensions
Research repairing databases (see work Bertossi, 2011, overview) suggests several
techniques, potential interest DL-programs, could exploited optimizing
extending repair approach. Localization repairs proposed Eiter, Fink, Greco,
Lembo (2008) one technique, cautiously part data affected inconsistency identified search repairs narrowed part. Using localization,
setting ontology ABox split safe set facts, touched
repair, set facts (probably) affected. affected part repaired, result
combined safe ABox part get final solution. find suitable ABox split, meta
knowledge ontology (e.g. modules, additional domain information) used.
Another common approach tackling inconsistency problem, proved effective
databases, decomposition (Eiter et al., 2008). Here, available knowledge decomposed
parts, reasons inconsistency identified part separately,
respective repairs conveniently merged. databases decomposition natural,
general unclear inconsistent DL-program effectively decomposed. One way
approach problem determining DL-atoms whose replacement atoms guessed true
(resp. false) answer sets . Given set DL-atoms, one aim first searching
repair every DL-atom desired value, extend solution
get final result. Modules DL-programs (as identified DLVHEX solver)
exploited program decomposition.
repairs equally useful certain setting, various filterings repairs applied get plausible candidates. Here, qualitative domain-specific aspects repairs
crucial importance practicability. formulated terms additional local constraints express instance facts involving certain predicates constants must
preserved (resp. checked removal). Furthermore, number facts/predicates/constants allowed deletion bounded. filterings incorporated repair approach.
Yet several extensions possible conditional predicate dependence. example, user might willing express condition StaffRequest(r ) eliminated
hasAction(r , read ) holds data part, Blacklisted staff members removed,
files, modifying separate StaffRequest issued non-blacklisted staff
member.
490

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

~ P (Y
~)
(r1 ) Supd (X)

A,P

~
~)
(Y
(r2 ) Supd (X)


~ P (Y
~)
(r5 ) ned (X),


~ ) . . . Pnd (Y
~ ) ned (X),
~ A,P (Y
~)
(r6 ) P1d (Y


~ ) rb(S p (Y
~ ))
(r3 ) SdP (Y

A,P ~
A,P ~

~ ))
(r4 ) Sd (Y ) rb(Sd (Y )), nd(SdA,P (Y

~ ed (X),
~ Cd , Supd (X)
~
(r7 ) eval (X)

~
~
(r8 ) eval (X) ned (X), Cd

~ Cd , Supd (X)
~
(r9 ) ed (X),

Figure 8: Rules Rd declarative implementation
6.2 Implementation
implemented repair approach C++ system prototype (dlliteplugin DLVHEX
system, 2015).
discussed, support sets EL ontologies rich structure, thus computation, TBox classification work Eiter et al. (2014d) insufficient. Indeed, need
identify inclusions atomic concepts, inclusions form C B,
C arbitrarily complex concept B atomic. constructing support sets thus exploit R EQUIEM tool (Prez-Urbina et al., 2010), rewrites target query TBox
using datalog rewriting techniques. limiting number (resp. size) rewritings, partial
support families computed.
principle support sets may subsumed smaller support sets (e.g., {R(c, d),A(c)}
{A(c)}). support sets redundant thus eliminate implementation.
support families constructed, use declarative approach determining repair
answer sets, minimal hitting set computation accomplished rules. end,
~ three fresh predicates (i) Supd (X),
~ (ii) P (Y
~ ), (iii) A,P (Y
~ )
DL-atom d(X)


~ , intuitively say d(X)
~ = XX
~ (i) support set, (ii)
introduced,
support set involving rule predicates, (iii) support set involving ABox predicates (and
possibly rule predicates), called mixed support set. Furthermore, every DL-atom d(X), rules
Rd Figure 8 added replacement program .
~ known
rules, atom Cd informally says support family d(X)
complete. Information completeness support families certain DL-atoms added
declarative program form facts Cd . rules (r1 )-(r4 ) reflect information
~ potential repair; rb(S) stands rule body representing support
support sets d(X)
~ ), . . . , pPnd (Y
~ ),
set S, i.e. rb(S) = A1 , . . . Ak = {A1 , . . . , Ak }; nd(S) = pP1d (Y
~ ), . . . , pPnd (Y
~ )}, encodes ontology part pP (Y
~ ) states assertion
{pP1d (Y
id

~
~
Pi (Y ) marked deletion. constraint (r5 ) forbids d(X), guessed false matching
~ matching
support set consists input assertions; (r6 ) means instead d(X)
mixed support set, assertion ontology part must eliminated. rule (r7 )
~ guessed true, completeness support family unknown matching
says d(X)
~
support set available, evaluation postcheck necessary (eval (X));
rule (r8 ) similar

~
d(X) guessed false. rule (r9 ) states DL-atom guessed true must support
set, support family known complete.
set facts f acts(A) = {pP (~c) | P (~c) A}, encoding ABox assertions COMP
{Cd | Sd complete support family d} added program , answer sets
491

fiE ITER , F INK & TEPANOVA


(1) projfile(p1 ); (2) hasowner (p1 , john); (3) issued (john, r1 );





(4) chief (john) hasowner (p1 , john), projfile(p1 );





(5) deny(r1 ) ed (r1 );



(6) hasowner (p1 , john), issued (john, r1 ), deny(r1 );




(7) ed (r1 ) ned (r1 );





(8) supd (X ) pBlacklistedStaffRequest (X ), pBlacklistedStaffRequest (X);




(9) pBlacklistedStaffRequest (X ) ned (X ), pBlacklistedStaffRequest (X );
R = (10) supd (X ) pStaffRequest (X ), pStaffRequest (X ), phasSubject (X , ),



phasSubject (X, ), pBlacklisted (Y ), pBlacklisted (Y );





(11)
p
(X
) phasSubject (X , ) pBlacklisted (Y ) ned (X), pBlacklisted (Y ),
StaffRequest




pStaffRequest (X ),





phasSubject (X , );




(12)
eval
(X)

e
(X),

C
,

sup
(X);








(13) eval (X) ned (X), Cd ;



(14) ed (X), Cd , supd (X).



























































Figure 9: Program R Example 68
proceed evaluation postcheck atoms
computed. answer set I,
d(~c) fact eval (~c) answer set. evaluation postchecks succeed,
original program I.
way one identifies
extract repair answer set = I|
weak repair answer sets; flp-repair answer sets, additional minimality check needed.
many cases, however, flp weak answer sets coincide (cf. Eiter et al., 2014a); particular,
holds example benchmark programs consider.
formally show described approach indeed correctly computes weak repair answer sets.
Proposition 67 Let = hO, Pi ground DL-program, EL ontology, let
DL-atom Sd SuppO (d), let Rd set rules (r1 )-(r9 ) d. Define
1 = R f acts(A) COMP,

R = Rd , f acts(A) = {pP (~c) | P (~c) A} COMP {Cd | Sd -complete
w.r.t. O}. Suppose (1 ) evaluation postcheck succeeds every DL-atom
RAS weak (). Moreover, Cd COMP every DL-atom d,
Cd 6 COMP. I|

RAS weak () = {I| | (1 )}.
Let us demonstrate usage declarative implementation example.
Example 68 Consider Figure 9 replacement program rules R = hP, Oi,
Example 1, P follows:

(1) projfile(p1 ); (2) hasowner (p1 , john); (3) issued (john, r1 );




(4) chief (john) hasowner (p1 , john), projfile(p1 );
P=

(5) deny(r1 ) DL[Staff chief ; BlacklistedStaffRequest](r1 );



(6) hasowner (p1 , john), issued (john, r1 ), deny(r1 ).
492











.

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Assume d(X) = DL[Staff chief ; BlacklistedStaffRequest](X) given
incomplete support family Sd = {S1 , S2 }, S1 = {BlackListedStaffRequest(X )} S2 =
{StaffRequest(X ), hasSubject(X , ), Blacklisted (Y )}. interpretation {ned (r1 ),
pStaffRequest (r1 ), pBlacklisted (john), evald } among answer sets R facts(A).
post-check needed d(r1 ); test succeeds, thus I|
repair answer set.
eval I,


7. Evaluation
repair answer set computation approach implemented within DLVHEX system; details
found work Stepanova (2015), software freely online available (dlliteplugin, 2015). approach evaluated multi-core Linux server running DLVHEX 2.4.0
HTCondor load distribution system (HTCondor, 2012), specialized workload management system compute-intensive tasks, using two cores (AMD 6176 SE CPUs) 8GB
RAM.
best knowledge, similar system repairing inconsistent DL-programs exists. list systems evaluating DL-programs includes DR E W system (DReW, 2012;
Xiao, 2014) dlplugin DLVHEX system (dlplugin, 2007). DR E W system exploits
datalog rewritings evaluating DL-programs EL ontologies; however, handle inconsistencies, focus work. Thus DR E W per se could used baseline
experiments. facilitate comparison, thus extended DR E W naive repair
technique, guess repair ABox followed check suitability. However,
immediate implementation turned infeasible even small instances, general
search space repairs ways large full exploitation; guided search needed ensure
scalability. dlplugin DLVHEX system invokes R ACER P RO reasoner (RacerPro, 2007)
back-end evaluating calls ontology. However, lightweight ontologies even
standard evaluation mode without repair extensions, scales worse dlliteplugin (Eiter
et al., 2014b); thus focus latter experiments.
7.1 Evaluation Workflow
general workflow experimental evaluation follows. first step, constructed benchmarks building rules constraints top existing ontologies
data parts constructed programs become inconsistent. instances generated using
shell scripts (DL-program benchmark generation scripts, 2015) size conflicting data
part parameter. benchmarks run using HTCondor system, times
extracted log files runs. run, measured time computing first
repair answer set, including support set computation, timeout 300 seconds.
benchmark, present experimental results tables. first column p specifies
size instance (varied according certain parameters specific benchmark),
parentheses number generated instances. E.g., value 10(20) first column states
set 20 instances size 10 tested. columns represent particular repair
configurations, grouped three sets.
first set refers settings -complete support families exploited,
second third refer settings size, respectively number computed sup493

fiE ITER , F INK & TEPANOVA

port sets restricted. -complete setting, addition limit number facts (lim_f ),
predicates (lim_p) constants (lim_c) involved facts removed; e.g., lim_p = 2
states set removed facts involve two predicates. parameter del _p stores
predicates deleted; e.g., del _p = StaffRequest means repairs obtained
removing facts StaffRequest.
restricted configurations, column size = n (resp. num = n) states
computed partial support families size (resp. number) support sets n; n = ,
fact support sets computed, system aware -completeness.
exploit partial -completeness number size restriction cases, i.e. support sets
atom computed number/size limits yet reached, support family
considered atom -complete.
entry t(m)[n], total average running time (including support set generation
timeouts), number timeouts n number found repair answer sets.
7.2 Benchmarks
evaluation developed algorithms, considered following benchmarks.
(1) policy benchmark variant Example 1, rule (14) P changed
deny(X ) DL[Staff chief ; UnauthorizedStaffRequest](X), two axioms,
namely UnauthorizedStaffRequest StaffRequest hasSubject.Unauthorized
Blacklisted Unauthorized added .
(2) OpenStreetMap benchmark contains set rules ontology enhanced personalized route planning semantic information (MyITS ontology, 2012) extended
ABox containing data OpenStreetMap project (OSM, 2012).
(3) LUBM benchmark comprises rules top well-known LUBM ontology (LUBM,
2005) EL.
describe benchmark results details. experimental data online available
(Experimental data, 2015).
7.2.1 ACCESS P OLICY C ONTROL
considered ABoxes n staff members, n {10, 250, 500}. data set 5
projects 3 possible actions; furthermore 20% staff members unauthorized 40%
blacklisted. generating instances, used probability p/100 (with p column 1)
fact hasowner (pi , si ) added rules part P si , pi , Staff (si ), Project(pi )
(i.e., instances vary facts hasowner (pi , si ) P.) parameter. Here, p ranges 20,
30, etc. 90 A10 5, 10 etc. 40 A250 A500 . total average running times
settings shown Tables 24, SR stands StaffRequest. experiments
performed ABoxes chosen size (i.e., A10 , A250 , A500 ) demonstrate
approach works small, medium large data.
regards A10 , limiting -complete setting number predicates removal slightly
increases running times. Restricting repairs removing facts StaffRequest
slow repair computation compared unrestricted case, many actual
repairs indeed satisfy condition. results bounded number size support sets
494

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

p
20 (20)
30 (20)
40 (20)
50 (20)
60 (20)
70 (20)
80 (20)
90 (19)

-complete support families
restr .
lim_p = 2
del_p = SR
1.92 (0)[20] 2.70 (0)[20]
1.91 (0)[20]
1.94 (0)[20] 2.72 (0)[20]
1.94 (0)[20]
1.93 (0)[20] 2.71 (0)[20]
1.93 (0)[20]
1.92 (0)[20] 2.70 (0)[20]
1.92 (0)[20]
1.94 (0)[20] 2.72 (0)[20]
1.95 (0)[20]
1.95 (0)[20] 2.73 (0)[20]
1.95 (0)[20]
1.94 (0)[20] 2.72 (0)[20]
1.95 (0)[20]
1.96 (0)[19] 2.74 (0)[19]
1.96 (0)[19]

Incomplete support families
size = 3
size = 5
num = 3
38.51 (0)[20]
33.86 (0)[20] 1.93 (0)[20]
86.35 (1)[19]
80.52 (1)[19] 1.95 (0)[20]
98.69 (1)[19]
96.45 (1)[19] 1.94 (0)[20]
100.46 (2)[18]
98.06 (2)[18] 1.93 (0)[20]
182.16 (3)[17] 186.20 (3)[17] 1.96 (0)[20]
153.66 (2)[18] 152.66 (2)[18] 1.96 (0)[20]
227.81 (6)[14] 223.24 (6)[14] 1.96 (0)[20]
267.52 (11)[8] 267.89 (12)[8] 1.96 (0)[19]

num =
1.92 (0)[20]
1.93 (0)[20]
1.93 (0)[20]
1.91 (0)[20]
1.94 (0)[20]
1.94 (0)[20]
1.95 (0)[20]
1.95 (0)[19]

Table 2: Policy benchmark, A10
p
5(20)
10(20)
15(20)
20(20)
25(20)
30(20)
35(20)
40(20)

-complete support families
restr .
lim_p = 2
del_p = SR
6.06(0)[20]
8.28 (0)[20]
6.05 (0)[20]
6.68(0)[20]
8.90 (0)[20]
6.68 (0)[20]
8.37(0)[20] 10.56 (0)[20]
8.35 (0)[20]
9.39(0)[20] 11.61 (0)[20]
9.40 (0)[20]
11.41(0)[20] 13.62 (0)[20]
11.41 (0)[20]
14.04(0)[20] 16.24 (0)[20]
14.09 (0)[20]
15.17(0)[20] 17.32 (0)[20]
15.19 (0)[20]
17.49(0)[20] 19.64 (0)[20]
17.47 (0)[20]

Incomplete support families
size = 6
num = 3
6.06 (0)[20]
6.07 (0)[20]
6.67 (0)[20]
6.69 (0)[20]
8.33 (0)[20]
8.34 (0)[20]
9.40 (0)[20]
9.43 (0)[20]
11.46 (0)[20] 11.40 (0)[20]
14.10 (0)[20] 14.05 (0)[20]
15.12 (0)[20] 15.16 (0)[20]
17.46 (0)[20] 17.45 (0)[20]

num =
6.05 (0)[20]
6.67 (0)[20]
8.34 (0)[20]
9.41 (0)[20]
11.40 (0)[20]
14.04 (0)[20]
15.17 (0)[20]
17.43 (0)[20]

Table 3: Policy benchmark, A250
p
5 (20)
10 (20)
15 (20)
20 (20)
25 (20)
30 (20)
35 (20)
40 (20)

-complete support families
restr .
lim_p = 2
del_p = SR
14.99 (0)[20]
18.71 (0)[20]
14.98 (0)[20]
23.57 (0)[20]
27.14 (0)[20]
23.52 (0)[20]
35.07 (0)[20]
38.85 (0)[20]
35.09 (0)[20]
73.43 (2)[18]
53.27 (0)[20]
73.29 (2)[18]
152.29 (8)[12]
64.91 (0)[20] 152.33 (8)[12]
288.06 (19)[1]
97.32 (1)[19] 288.08 (19)[1]
300.00 (20)[0]
153.03 (5)[15] 300.00 (20)[0]
300.00 (20)[0] 206.96 (10)[10] 300.00 (20)[0]

Incomplete support families
size = 6
num = 3
15.00 (0)[20]
14.97 (0)[20]
23.50 (0)[20]
23.51 (0)[20]
35.02 (0)[20]
35.12 (0)[20]
73.50 (2)[18]
73.32 (2)[18]
164.34 (9)[11] 152.25 (8)[12]
276.11 (18)[2] 288.05 (19)[1]
300.00 (20)[0] 300.00 (20)[0]
300.00 (20)[0] 300.00 (20)[0]

num =
14.97 (0)[20]
23.43 (0)[20]
35.13 (0)[20]
85.33 (3)[17]
164.32 (9)[11]
300.00 (20)[0]
300.00 (20)[0]
300.00 (20)[0]

Table 4: Policy benchmark, A500
almost constant, except size limited 5 smaller (just size 3 size 5 shown).
support sets exceed bound post-evaluation checks often fail, visibly impacts
running times. support sets large, them; seen
insignificant difference times num = 3 num = .
significantly larger ABox A250 , get value p considered settings
perform almost identical except lim_p = 2 bit slower. Moreover, running times increase
gracefully value p. bounding support set size 5 produces timeouts (thus
column omitted), computing support sets size 6 always sufficient identify repairs.
largest setting A500 , -complete case finding arbitrary repair faster
restriction lim_p = 2 , p = 15. p = 20 results lim_p = 2
495

fiE ITER , F INK & TEPANOVA

p
10 (20)
20 (20)
30 (20)
40 (20)
50 (20)
60 (20)
70 (20)
80 (20)
90 (20)

-complete support families
restr .
lim_f = 5
lim_c = 10
13.01 (0)[20]
13.04 (0)[20]
13.05 (0)[20]
13.10 (0)[20]
13.04 (0)[20]
13.08 (0)[20]
13.11 (0)[20]
13.07 (0)[20]
13.12 (0)[20]

16.50 (0)[20]
16.49 (0)[20]
16.54 (0)[20]
16.58 (0)[20]
16.60 (0)[20]
16.61 (0)[20]
16.68 (0)[20]
16.70 (0)[20]
16.81 (0)[20]

16.46 (0)[20]
16.48 (0)[20]
16.49 (0)[20]
16.47 (0)[20]
16.51 (0)[20]
16.55 (0)[20]
16.58 (0)[20]
16.53 (0)[20]
16.59 (0)[20]

size = 1
16.39 (0)[11]
20.98 (0)[5]
24.56 (0)[0]
59.26 (0)[1]
123.80 (0)[0]
106.63 (1)[0]
139.08 (2)[0]
211.33 (5)[0]
260.36 (11)[0]

Incomplete support families
size = 3
num = 1
13.03 (0)[20]
13.04 (0)[20]
13.06 (0)[20]
13.07 (0)[20]
13.10 (0)[20]
13.06 (0)[20]
13.07 (0)[20]
13.06 (0)[20]
13.10 (0)[20]

13.23 (0)[20]
13.35 (0)[20]
13.51 (0)[20]
13.55 (0)[20]
13.56 (0)[20]
13.60 (0)[20]
13.61 (0)[20]
13.61 (0)[20]
13.67 (0)[20]

num = 3
13.06 (0)[20]
13.01 (0)[20]
13.02 (0)[20]
13.09 (0)[20]
13.04 (0)[20]
13.08 (0)[20]
13.07 (0)[20]
13.06 (0)[20]
13.10 (0)[20]

num =
12.99 (0)[20]
13.02 (0)[20]
13.05 (0)[20]
13.05 (0)[20]
13.06 (0)[20]
13.08 (0)[20]
13.13 (0)[20]
13.08 (0)[20]
13.08 (0)[20]

Table 5: Open Street Map benchmark results

outperform unrestricted setting, posed limitation restricts search space repairs effectively. Removing facts StaffRequest longer always sufficient, witnessed
decreased number identified repairs del _p = StaffRequest compared lim_p = 2 .
time increases rather gracefully p long repair answer sets found.
7.2.2 PEN TREET AP
second benchmark, added rules top ontology developed MyITS project.
fixed ontology contains 4601 axioms, 406 axioms TBox 4195
ABox. fragment relevant scenario rules P shown Figure 10.
Intuitively, states building features located inside private areas publicly accessible
covered bus stop bus stop roof. rules P check public stations lack
public access, using CWA private areas.
used method introduced Eiter, Schneider, imkus, Xiao (2014) extract data
OpenStreetMap repository (OSM, 2012). constructed ABox extracting
sets bus stops (285) leisure areas (682) Irish city Cork, well isLocatedInside
relations (9) (i.e., bus stops located leisure areas). data gathered
many volunteers, chances inaccuracies may high (e.g. imprecise GPS data). Since
data roofed bus stops private areas yet unavailable, randomly made 80%
bus stops roofed 60% leisure areas private. Finally, added bsi
isLocatedInside(bsi , laj ) fact busstop(bsi ) P probability p/100. instances
inconsistent since data set roofed bus stops located inside private areas.
results shown Table 5. -complete setting arbitrary repairs computed
3.5 seconds faster repairs bounded changes. restricted configuration
times vary much except size = 1, significant time increase observed,
repairs found smaller instances. previous benchmark computing small
number support sets often sufficient, configuration num = 1 expected slightly
slower num = 3 (computing support sets cheap, postchecks take time).
496

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES



=



(1) BuildingFeature isLocatedInside.Private NoPublicAccess
(2) BusStop Roofed CoveredBusStop




(9) publicstation(X) DL[BusStop busstop; CoveredBusStop](X),



DL[; Private](X);
P=
(10)


DL[BuildingFeature
publicstation; NoPublicAccess](X),



publicstation(X ).









Figure 10: DL-program OpenStreetMap ontology
p
5 (20)
15 (20)
25 (20)
35 (20)
45 (20)
55 (20)
65 (20)
75 (20)
85 (20)
95 (20)

restr .
37.14 (0)[20]
35.74 (0)[20]
35.71 (0)[20]
36.07 (0)[20]
35.98 (0)[20]
35.92 (0)[20]
36.13 (0)[20]
36.07 (0)[20]
36.11 (0)[20]
36.38 (0)[20]

-complete support families
lim_f = 5
lim_p = 2
47.77 (0)[20] 43.74 (0)[20]
34.93 (0)[11] 42.74 (0)[20]
26.94 (0)[5] 42.80 (0)[20]
20.53 (0)[0] 43.04 (0)[20]
20.50 (0)[0] 43.11 (0)[20]
20.51 (0)[0] 43.11 (0)[20]
20.43 (0)[0] 43.44 (0)[20]
20.63 (0)[0] 43.45 (0)[20]
20.30 (0)[0] 43.35 (0)[20]
20.55 (0)[0] 43.24 (0)[20]

lim_c = 20
43.88 (0)[20]
41.51 (0)[19]
41.71 (0)[19]
26.91 (0)[7]
19.54 (0)[1]
18.47 (0)[0]
18.33 (0)[0]
18.28 (0)[0]
18.04 (0)[0]
18.20 (0)[0]

Incomplete support families
size = 1
size = 3
42.57 (0)[20] 36.52 (0)[20]
42.02 (0)[20] 35.96 (0)[20]
41.91 (0)[20] 35.80 (0)[20]
42.22 (0)[20] 36.00 (0)[20]
41.94 (0)[20] 36.40 (0)[20]
42.31 (0)[20] 35.98 (0)[20]
41.81 (0)[20] 36.02 (0)[20]
42.09 (0)[20] 36.21 (0)[20]
42.22 (0)[20] 36.15 (0)[20]
42.52 (0)[20] 36.17 (0)[20]

num =
36.26 (0)[20]
35.49 (0)[20]
35.49 (0)[20]
35.65 (0)[20]
35.66 (0)[20]
35.60 (0)[20]
35.92 (0)[20]
35.85 (0)[20]
35.83 (0)[20]
35.62 (0)[20]

Table 6: LUBM benchmark results
7.2.3 LUBM
tested approach DL-programs = hP, Oi built EL version
LUBM ontology, whose TBox extended following axioms:
(1) GraduateStudent assists.Lecturer TA
(2) GraduateStudent teaches.UndergraduateStudent TA
rules follows:


(3) stud (X ) DL[; Employee](X ), DL[; TA](X );
;
P=
(4) DL[Student stud ; TAof ](X , ), takesexam(X , )
(3) states unless teaching assistant (TA) known employee, he/she student,
(4) forbids teaching assistants take exams courses teach.
ABox contains information one university 600 students, 29 teaching
assistants, constructed dedicated ABox generator (LUBM data generator, 2013). pairs
constants t, c, teachingAssistantOf (t, c) A, facts takesexam(t, c) randomly
added rules part probability p/100, thus contradicting part DL-program
growing respect p.
results benchmark provided Table 6. Bounding -complete setting
number removed facts 5 slows computation, repairs satisfying condition
exist. instances p 35 (i.e., inconsistency entrenched), 5 facts must
dropped obtain repair; moreover, often involve 20 constants according
497

fiE ITER , F INK & TEPANOVA

column 5. absence repairs lim_f = 5 lim_c = 20 found faster repair
unrestricted mode.
Limiting support set size 1 allows one find repairs instances delay less
10 seconds compared -complete setting. However, many support sets
benchmark, thus bounding number less effective.
7.3 General Results Discussion
One observe -complete settings settings post-evaluation checks fast,
running times vary slightly growing p. due declarative implementation,
computing repairs reduced finding answer sets program 1 = R facts(A)
COMP followed possible evaluation postchecks. benchmarks difference
instances size pi pi+1 data part logic program, small compared
part facts(A) 1 constant p. Thus long postchecks needed, times
required repairing differ much even though programs become inconsistent.
expected, using -complete support families works well practice. Naturally, takes
time compute restricted repairs rather arbitrary repairs; however, imposed restrictions strong repair satisfy them, solver may recognize faster.
reported Hansen et al. (2014), EL-TBoxes originate real-world applications
admit FO-rewritings (of reasonable size) almost cases. provides evidence realworld EL-TBoxes hardly contain involving constraints conceptual level, hence either
size number support sets DL-atoms often turn limited. novel algorithms
deletion repair answer set computation demonstrated applicability DL-programs
real world data (Open Street Map benchmark results Table 5).
benchmarks run synthetic, still vary w.r.t. TBox
ABox sizes. capability algorithms handling diverse DL-programs confirms
potential approach.

8. Related Work
Inconsistencies DL-programs studied several works (Phrer et al., 2010; Fink, 2012;
Eiter et al., 2013, 2014d). Phrer et al. proposed inconsistency tolerant semantics. Keeping
ontology untouched, DL-atoms introduce inconsistency well rules involving
deactivated. repair problem, outlined open issue Phrer et al., formalized Eiter
et al. (2013), notions repair repair answer sets together naive algorithm
computation proposed. latter optimized Eiter et al. (2014d, 2015)
DL-Lite effectively exploiting complete support families DL-atoms. approach
general, differs one Eiter et al. (2014d, 2015) uses partial (not
necessarily complete) support families applied ontologies DL, though
possible impact complexity.
hybrid formalisms, inconsistency management concentrated inconsistency tolerance rather repair. instance, Huang et al. (2013) presented four-valued paraconsistent
semantics based Belnaps logic (Belnap, 1977) hybrid MKNF knowledge bases (Motik &
Rosati, 2010), prominent tightly coupled combination rules ontologies.
Inspired paracoherent stable semantics Sakama Inoue (1995), work Huang
et al. (2013) extended Huang, Hao, Luo (2014) handle incoherent MKNF KBs,
498

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

i.e. programs inconsistency arises result dependency atom default
negation analogy work Fink (2012). Another direction inconsistency handling
hybrid MKNF KBs using three-valued (well-founded) semantics Knorr, Alferes, Hitzler (2011), avoids incoherence disjunction-free stratified programs. recently,
extended Kaminski et al. (2015) additional truth values evaluate contradictory
pieces knowledge. works aim inconsistency tolerance rather repair, geared
spirit query answering inherent well-founded semantics; such, limited
normal logic programs, DL-programs allow disjunctive rule heads.
context Description Logics, repairing ontologies studied intensively, foremost
handle inconsistency. DL-program repair related ABox cleaning (Masotti, Rosati, &
Ruzzi, 2011; Rosati, Ruzzi, Graziosi, & Masotti, 2012). However, latter differs various
respects: aims restoring consistency inconsistent ontology deleting -minimal sets
assertions (i.e., computing -maximal deletion repairs); deal inconsistency incurred
top consistent ontology, arbitrary (non-monotonic) rules access query
interface. Furthermore, must consider multiple ABoxes (via updates), use EL instead
DL-Lite. Refining algorithm compute -maximal deletion repairs possible.
problem computing support families tightly related finding solutions abduction
problem, considered Bienvenu (2008) theories expressed EL-terminologies.
hypothesis H = {A1 , . . . , } set atomic concepts, observation another atomic
concept. solution abduction problem set H, |= Ai Ai O.
setting general involves roles along atomic concepts. Abduction
studied various related areas e.g., DL-Lite ontologies Calvanese, Ortiz, Simkus,
Stefanoni (2013), propositional logic Eiter Makino (2007), datalog Eiter et al.
(1997) Gottlob, Pichler, Wei (2007), etc. Using incomplete support families DL-atoms
related spirit approximate inconsistency-tolerant reasoning DLs using restricted support
sets considered Bienvenu Rosati (2013); however, focus repair computation
model generation Bienvenu Rosati target inference repairs.
methods constructing partial support families exploit results logical difference
EL terminologies presented Konev et al. (2012) Ecke et al. (2013); recently
extended ELHR Ludwig Walther (2014) general TBoxes Feng et al.
(2015).
Repairing inconsistent non-monotonic logic programs investigated work
Sakama Inoue (2003), approach deleting rules based extended abduction
studied; however, restore consistency addition rules possible. latter considered
Balduccini Gelfond (2003), Occams razor consistency-restoring rules may
added. Methods explaining inconsistency arises logic program studied, e.g.,
Syrjnen (2006), exploited model-based diagnosis Reiter (1987) debug logic program. Generalized debugging logic programs investigated e.g., Gebser, Phrer, Schaub,
Tompits (2008). recently, Schulz, Satoh, Toni (2015) considered characterization
reasons inconsistency extended logic programs (i.e., disjunction-free logic programs
strong (classical) negation weak negation) terms culprit sets literals, based
well-founded maximal partial stable model semantics, derivation-based method explain culprits described; however, remains open debugging logic programs
based culprit sets could done whether could fruitfully extended debugging DLprograms. latter addressed Oetsch, Phrer, Tompits (2012) related
F

499

fiE ITER , F INK & TEPANOVA

challenging but, best knowledge, unexplored problem repairing rule part
DL-program.

9. Conclusion
considered computing repair answer sets DL-programs EL ontologies,
generalized support set approach Eiter et al. (2014d, 2014b) DL-Lite work
incomplete families supports sets; advance needed since EL complete support families large even infinite. discussed generate support sets, exploiting query
rewriting ontologies datalog (Lutz et al., 2009; Rosati, 2007; Stefanoni et al., 2012),
contrast work Eiter et al. (2014d), TBox classification invoked. Moreover,
developed alternative techniques effective computation partial support families.
approach approximate relevant part TBox DL-Lite core exploiting notion logical
difference EL-terminologies, compute complete support families approximated TBox using methods Eiter et al. (2014d). obtained support family complete,
approximated TBox logically equivalent original one.
estimate maximal size support sets, analyzed properties novel support hypergraph, corresponds subgraph ontology hypergraph (Nortje et al., 2013;
Ecke et al., 2013), nodes encode ontology predicates (or pairs them), (hyper) edges
reflect TBox inclusions. shown traversing support hypergraph one conveniently
compute upper bound number support sets given DL-atom. If, addition,
support hypergraph satisfies certain conditions (e.g. tree-acyclicity), exact estimate
obtained.
developed sound algorithm computing deletion repair answer sets DL-programs
EL ontologies, complete case support families known complete.
algorithm trades answer completeness scalability (a simple variant ensures completeness).
implemented novel algorithm using declarative means within system prototype,
invokes R EQUIEM reasoner partial support family computation. experimental assessment repair approach, set novel benchmarks constructed including real
world data. availability complete support families adds scalability repair
computation, partial support families work surprisingly well practice due structure
benchmark instances: support sets either small them, thus postevaluation checks cause much overhead. Overall, experimental evaluation revealed
promising potential novel repair methodology practical applications.
9.1 Outlook
directions future work considered area manifold. cover theoretical
practical aspects inconsistency handling approach. theoretical side, relevant open
issue sufficient conditions computing nonground support sets DL-atom
accessing EL ontology becomes tractable. work Gebser et al. (2008) bounded
tree-width might considered, parameters density support hypergraph
various acyclicity properties. Analyzing complexity counting support sets complete
support family might give hints possible restricted settings, support family computation
efficient, complexity analysis interesting problem such. practical
500

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

side, optimization current implementation extending range applications real use
cases another issue.
Repair may intermingled stepping techniques used debugging DL-programs (Oetsch
et al., 2012). considered DL-programs monolithic structures applying repair
techniques, repair computation performed DL-program taken whole.
interesting relevant quest extend approach dealing modular DL-programs.
Splitting program separate components individually evaluated well-known
programming technique, studied context DL-programs (Eiter et al., 2008).
clear, however, extent program classes repair methods
adapted modular setting.
considered EL paper, basic algorithm approach applicable
DLs. Extensions work EL+ EL++ easily possible. main difference
negation, expressible via concept; ontology get inconsistent
updates DL-atoms, leading increased number support sets need effectively
computed appropriately handled. extension expressive DLs SHIQ, SHOIN
even SROIQ challenging, efficient methods support set construction remain
developed; relatively high complexity DLs, comes computational cost.
hand, computation may done (even offline) reused; fortunately,
support families need complete, may expect return investment time support
set construction overall running time.
Orthogonal DLs, one study various additional repair possibilities, e.g. bounded
addition; overview repair possibilities see work Eiter et al. (2013).
concentrated repairing data part ontology, natural allow changes
rules interfaces. repairing rules, works ASP debugging Frhstck, Phrer,
Friedrich (2013), Gebser et al. (2008), Syrjnen (2006) used starting point,
problem challenging search space possible changes large. Priorities rules
atoms involving might applied ensure high quality rule repairs. interfaces
similarly admit numerous modifications, makes type repair difficult; user interaction
probably required.
Last least one could develop methods repairing hybrid formalisms including
tightly-coupled hybrid KBs even general representations HEX-programs (Eiter et al.,
2005), instead ontology arbitrary sources computation accessed logic
program. Heterogeneity external sources HEX-programs makes repair paraconsistent
reasoning challenging task.

Acknowledgments
thank anonymous reviewers detailed constructive suggestions helped
improve work. article significantly extends preliminary work Eiter, Fink, Stepanova
(2014c). research supported Austrian Science Fund (FWF) projects P24090
P27730.
501

fiE ITER , F INK & TEPANOVA

Appendix A. Proofs Section 3
A.1 Proof Proposition 15
() Proposition 10, |=O iff Td AI |= Q(~t), AI = {Pp (~t) Ad | p(~t) I}.
Thus, = AI support set w.r.t. O, coherent construction.
() Supp (d) coherent I, form = AI
AI AI , thus AI . Td |= Q(~t), monotonicity Td AI |= Q(~t),
hence Proposition 10 |=O d.
A.2 Proof Proposition 24
~
Consider instance = {P1 (Y1 ), . . . , Pk (Yk )} set form (5) d(X),
: V C. show support set w.r.t. OC = hT , AC (recall AC set
~
possible ABox assertions C), i.e., AC Ad (which clearly holds) Td |= Q(X).
~
latter equivalent Tdnorm |= Q(X),
turn Lemma 23 equivalent
0
~
Prog Q,Td norm |= Q(X). Let Prog = Prog Q,Td norm , let Prog i+1 , 0,
~
program results Prog unfolding rule w.r.t. target query Q(X).

i+1

~
~
Prog
|= Q(X) iff Prog |= Q(X) holds. construction S, rule
~ thus Prog |= Q(X).
~
r form (4) Prog . Clearly {r} |= Q(X)

0
~
~
~
follows Prog |= Q(X) hence Td norm |= Q(X) Td |= Q(X).

Appendix B. Proofs Section 4
B.1 Proof Lemma 31
Towards contradiction, assume T1d 6C
T2d . w.l.o.g. T1d |= P1 P2 T2d 6|= P1 P2 ,

P1 , P2 . Observe differ predicates Pp , P p occurs
, = T1d \T1 = T2d \T2 consists axioms Pp P Pp occur
T1 T2 . first show P2 must hold. Indeed, otherwise P2 \ thus P2 =
Pp sig(Ad ) P p . let = {P1 (c)} P1 , = {P1 (c), P1p (c)}
otherwise (i.e., P1 \ ), arbitrary c I. T1d model cI P1I
(resp. cI P1I cI P1 Ip ) Pp = (thus P1 6= P2 ), EL negation-free Pp occurs
axioms left. 6|= P1 Pp , follows T1d 6|= P1 P2 , contradiction.
proves P2 \ . two cases.
(i) P1 : T1 C
T2 implies T2 |= P1 P2 ; monotonicity T2d |= P1 P2 , contradiction.
(ii) P1 \ : P1 = Pp , P p occurs , P . claim T1 |= P P2 .
Indeed, otherwise T1 model P 6 P2 . easily seen interpretation


coincides Pp = P \ P2 Pp = Pp \ model
T1 ; however, 6|= Pp P2 , would contradiction. proves claim.
claim T1 C
T2 , follows T2 |= P P2 monotonicity T2d |= P P2 .
Pp P T2 , follows T2 |= P1 P2 ; contradiction.
B.2 Proof Proposition 32
Suppose S1 complete nonground support family w.r.t. O1 let instance

S1 ; = Ad AC Ad . Lemma 31, T1d C
T2d ; thus Theorem 30, T1d
502

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

T2 well. definition -instance inseparability, -ABoxes -assertions
T1d |= , holds T2d |= ; hence T2d Ad |= Q(~c). Consequently,
= Ad (ground) support set w.r.t. O2 . S2 complete nonground support family
w.r.t. O2 , follows instance S2 . converse membership symmetric.
Hence, S1 S2 ground-identical.
B.3 Proof Proposition 34
Towards contradiction, assume \ SuppO (d) exists. grounding exists
Td 6|= d(X). However, Td |= d(X), according (f), nonground
support set w.r.t. Td = Td lrw . Consequently, Td 6|= Td , contradiction,
Td Td construction (c) lrw = {C | Td |= C , Td 6|= C } Td
lhs
(d) definition cWTnrhs
cWTn .

Appendix C. Proofs Section 5
C.1 Proof Lemma 47

w.r.t. ontology =
construction support sets given hypergraph Gsupp(d),T
hT , Ai presented mimics DL-query unfolding TBox Td . formally
show (i) set extracted described way indeed nonground support sets d,
(ii) ground instance nonground support set d, (nonground) support
set constructed following procedure suitable ground
substitution . proves SG holds.
first prove (i) induction length n incoming paths, support sets
extracted.

Base: n=1. Consider path hypergraph Gsupp(d),T
. Assume single
(hyper-) edge e . construction, hyperedge must xQ head node, i.e. head (e) =
xQ . four possibilities: (1) tail (e) = {xC }, (2) tail (e) = {xr , xC }, (3) tail (e) =
{xC , xD } (4) tail (e) = {xr , }. annotate nodes path variables described
above, extract nonground atoms labels annotations nodes. result
case (1) obtain {C(X0 )}, (2): {r(X0 , X1 ), C(X1 )}, (3): {C(X0 ), D(X0 )},
(4): {r(X0 , X1 )}, X1 fresh variable. construction hypergraph edges
forms (1)-(4) correspond TBox axioms C Q, r.C Q, C Q r. Q
respectively. Therefore, sets constructed considered cases reflect
DL-query unfoldings d, hence represent nonground support sets Proposition 24.
Induction step: Suppose statement true n, i.e. path n edges sets extracted way described nonground support sets d. Consider path = e0 , . . . , en
n+1 edges, let e = e0 first edge . induction hypothesis, sets extracted
path \ e = e1 , . . . , en following approach support sets d. several
possibilities form e: (1) tail (e) = {xC } head (e) = {xD }, (2) tail (e) = {xr , xC }
head (e) = {xD }, (3) tail (e) = {xC , xD } head (e) = {xB }, (4) tail (e) = {xr , }
head (e) = {xC }, (5) tail (e) = {xC } head (e) = {xr , xD }.
(1), construction xC xD annotated Xi . Let family sets
extracted \e. pick set C(Xi ) occurs. substitute C(Xi ) D(Xi ),
obtain set . induction hypothesis must support set d. However,

503

fiE ITER , F INK & TEPANOVA

clearly support set, mimics additional unfolding step accounts rule
C(X) D(X) datalog rewriting Td .
Let us look (2). Assume set D(Xi ) nonground atoms constructed using
procedure. Xi must annotation xD . According construction {xr , xD }
annotated {hXi , Xj i, hXj i}, Xj fresh variable. sets get result
substituting D(Xi ) {r(Xi , Xj ), C(Xj )}. latter mimics unfolding step
Q accounts rule D(Xi ) r(Xi , Xj ), C(Xj ) rewriting Td . support
set induction hypothesis, must support set well. cases (3)-(5)
analyzed analogously. Thus sets size n + 1 extracted support sets d.
remains prove (ii). Towards contradiction, assume ground instance
SuppO (d) exists, ground instance every SuppO (d)
constructed procedure 6 S. support set, definition Td norm
|= Q(~c), thus Lemma 23 Prog Q,Tdnorm |= Q(~c). turn means Q(~c)
~ 0 Sm = ,
backchaining proof S0 , S1 , . . . , Sm Prog Q,Td norm form S0 = Q(X)
~ 7 ~c, Si = (Si1 Hi + Bi )i , 1, Hi Bi
0 substitution X
rule resp. fact Prog Q,Td norm general unifier Hi atom Si1 .
Without loss generality, Hi = A2 (oA2 ) Hi1 = R2 (X, oA2 ) Bi
empty end, i.e. positions k, k + 1, . . . , m. Sj resp. Sj+1 , 0 j k


amounts instance support set Sj resp. Sj+1
generated Gsupp(d),T
. particular,


Sk1 instance Sk1 consequently {Hk , Hk+1 , . . . , Hm } ( S) instance Sk1





well. means instance = Sk1 , contradiction.
C.2 Proof Proposition 48
prove statement induction number n hyperedges singleton head node

G = Gsupp(d),T
DL-atom DL[; Q](X).
Base: n = 0. show maxsup(d ) = 1 hyperedges required form exist G.
Several cases possible: (i) G contains hyperedges form (xC , {xr , xD }); (ii) G
hyperedges form ({xr , }, xC ) (xC , {xr , }); (iii) G hyperedges.
(i) Consider hyperedge . ej must exist , head (ei ) tail (ej ).
latter implies ej form ({xr , xD }, xD ) n 6= 0, i.e. contradiction.
(ii) (iii), construction contains GCIs C C, either atomic
form r.. axioms fall DL-Lite core fragment, -minimal
support sets size 2; moreover, |S| = 2 reflects DL-Lite core inconsistency arising
updated ontology (Eiter et al., 2014d). negation available expressible EL,
exists thus maximal support set size 1.
Induction Step: Suppose statement true n; prove n+1. Let = e1 , . . . , ek

maximal number n+1 hyperedges singleton
incoming path xQ Gsupp(d),T
head node. Assume ei first hyperedge required form occurring . Let us
split two parts: e1 , . . . , ei ei+1 , . . . , ek . Consider hypergraph G = (V, E ),
E = E \ {e1 , . . . , ei }, TBox reconstructed it. induction hypothesis,
maxsup(d ) w.r.t. = hT , Ai bounded n + 1. let hypergraph G = (V, E )
E = E {ei } correspond TBox . assumption head (ei ) = xA , i.e. ei either
reflects B C r.B A. Two cases possible: either = Q 6= Q.
504

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

x C n1

x Cn

x C nk

xCn

...

xCn

1

..
.

k

..
.
...
xQ

Figure 11: Fragment hypergraph used illustration proof Proposition 53
former case, ei single hyperedge , i.e. n = 1. Support sets obtained rewriting Q
B C Q r.B Q size 2. support sets constructed combining
query rewritings predicates occurring left hand side GCIs reflected ei ;
rewritings size 1 shown base case. Thus overall support set size w.r.t.
bounded 2 n + 1.
Suppose 6= Q, i.e. ei reflects either B C r.B A. definition
incoming path (hyper) edge ej must exist, head (ei ) tail (ej ). Moreover, note ej
unique (hyper) edge connected ei , otherwise given hypergraph tree-cyclic, i.e.
contradiction. distinguish two cases: (1) head (ei ) = tail (ej ) ej corresponds . . . ;
(2) head (ei ) tail (ej ) ej reflects B . . . .
1. Consider maximal support set w.r.t. , suppose A(Y ) holds. induction

hypothesis |S| n. G = Gsupp(d),T
tree-acyclic, single atom might

occur S. Adding edge ei G obtain support set atom A(Y )
substituted atoms B(Y ) C(Y ), r(Z, ) B(Z) result additional
query unfolding step. Hence support set size bounded n + 2.
2. ej reflects B . . . , support set {A(Y ), B(Y )} must exist. unfolding
respective datalog rule, get bound n + 2 support set w.r.t. .

C.3 Proof Sketch Proposition 53
Observe tree-acyclic hypergraphs nodes hyper out-degree 1, hence
m(, G) = 0. Thus, G tree-acyclic, Proposition 48 support set size given
DL-atom bounded n(, G) 0 + 1, equals smax . show claimed bound
correct tree-cyclic hypergraphs. Intuitively, m(, G) must subtracted n(, G)
avoid certain atoms support set counted multiple times. Regarding structure
support hypergraph distinguish two cases: (i) roles appear hypergraph; (ii) xr G,
holds r 6 .
505

fiE ITER , F INK & TEPANOVA

First consider (i). Since concepts appear support hypergraph assumption, support sets contain atoms single variable X0 occurs. Consider
node xCn hdc+ (xCn ) = k, k > 1, i.e., k outgoing hyperedges
xCn containing nodes corresponding concepts: ({xCn1 , xCn }, xCn ). . .({xCnk ,xCn }, xCn )
1
k
(see Figure 11). support sets {Cn 1 (X0 ), . . . , Cn k (X0 )} get support sets
{Cn1 (X0 ), . . . , Cnk (X0 ), Cn (X0 )}. Estimating maximal support set size number hyperedges hypergraph, Cn (X0 ) counted k times, appears (as variable
guaranteed X0 ). avoid multiple countings, m(, G) must subtracted n(, G).
Consider (ii). construction G, every hypernode {xr , xC } edges e1 =
(xA , {xr , xC }) e2 = ({xr , xC }, xB ) exist G. Thus xr occurs , consider
support set {B(X)}. Rewriting TBox axiom reflected e2 , get datalog rule
B(X) r(X, ), C(Y ). axiom r.C reflected e1 rewritten datalog rules
r(X, oC ) A(X); C(oC ) A(X). Unifying oC obtain unfolding A(X).
essentially shows role occurring support hypergraph , support sets
involve single variable; case, shown (i), provided bound correct.
C.4 Proof Proposition 57

proof induction number n (hyper) edges G = Gsupp(d),T
. Base: n=0. G
(hyper) edges, node one support set.
Induction step: Suppose statement holds n; show holds G n + 1 (hyper)
edges. Obviously, holds x VR . G tree-acyclic normal form, G
node x hd+ (x) = d+ (x) = 0, i.e., outgoing (hyper) edges, hd (x) 6= 0
(x) 6= 0, i.e., incoming (hyper) edge. G tree-acyclic, rewriting
set Qx = {A(X)}, x = xA consists Qx rewritings sets Qtail(e)
(hyper) nodes tail (e) head (e) = x. tail (e) {xB } (resp., {xB , xC }, {xr , xC })
rewritings {B(X)} (resp. {B(X), C(X)}, {R(X, ), C(Y )}). is, ws(xA )
sum number rewritings Qtail(e) denoted Qtail(e) , plus 1. Consider
arbitrary e head (e) = xA let G = G\e. G n edges tree-acyclic,
induction hypothesis node x V G , value ws(x), denoted wsG (x), (8).
Furthermore, ws(Qtail(e) ) ws(x ), x 6= xA G G. thus get x = xA :

wsG (x) = wsG (x) + ws(Qtail(e) )
X
wsG (x ) +
= 1+


= 1+



(x)

x

X



wsG (x ) +

X



wsG (x ) +

(x) x

X

ws(x ) + ws(Qtail(e) )

X

X

ws(x ) + ws(Qtail(e) )



(x),T 6VC ({x },T )E

(x),T 6VC ({x },T )E

(x) x

= 1+



X

X

X

ws(x )

(x),T 6VC ({x },T )E



(x) = {T | (T, {x}) E } E = E \ {e}, (x) above. obtain
ws(Qtail (e)), simply need count combinations rewritings node tail (e),
case tail (e) = {xr , xB } (where ws(xr ) = 1), need add number rewritings
tail hyperedge (T, {xr , xB }) (as normal form, must form {xC }).
506

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

C.5 Proof Corollary 60
Q
immediate Proposition 57: hypothesis, (8) form {y} VC ;
thus x ws(x ) = ws(y), i.e., ws(tail (e)) rightmost term 0.
C.6 Proof Sketch Proposition 61
condition e e1 , e2 , every set (x) Equation (8)
Q |T| = {x, y} > 1
contains (at least) one element, say x, ws(x) = 1, thus x wsG (x ) equals ws(y)

. inductive argument, obtain every node xA VC ,
G = Gsupp(d),T
ws(xA ) 1 number distinct edges G occur incoming paths xA
xB VC edge ({xB }, {xr , xA }) E, plus number edges.
turn implies query node xQ , ws(xq ) = |E| + 1 holds, construction edge e E
among respective edges xQ . result follows immediately.

Appendix D. Proofs Section 6
D.1 Proof Theorem 65
. get (h) answer set ,
Suppose SupRAnsSet outputs = I|
foundedness check w.r.t. ontology , = A\H succeeded. thus
remains show compatible set , i.e., DL-atom , Dp


iff |=O Dn iff 6|=O d. Towards contradiction, suppose case.
(d) partitioned DL-atoms two sets: Dp Dn , corresponding DL-atoms guessed

respectively, set SIgr
A). Since assume
true false I,
Gr(S, I,
compatible, one following must hold:

(1) DL-atom Dn , |=O d. two possibilities: (i) either

support set SIgr (d) (ii) support sets identified. case (i), guaranteed
support sets 6= , since otherwise hitting sets H found
(e). Hence must exist support set =
6 . According (e) H 6=
thus 6 Suppd (O ). rep = true (h), post-check must succeeded (g),

i.e. 6|=O must hold. contradiction. case (ii), likewise post-evaluation must
succeeded (h), raises contradiction.




(2) DL-atom Dp , 6|=O d. Hence SIgr (d) = , 6 Dp , post-evaluation
performed (g). latter, however, must succeeded, rep = true (h);
contradiction. Hence compatible set , thus deletion repair answer set .
D.2 Proof Theorem 66
following lemmas useful prove Theorem 66.
Lemma 69 Let ASx () x {flp, weak } = hT , A, Pi ground DL-program.
= {ed | DL , |=T d} {ned | DL , 6|=T d} answer set ,
DL set DL-atoms occurring .
lemma follows general result compatible sets basis evaluation
approach HEX-programs DLVHEX-solver (cf. (Eiter et al., 2014a)).
507

fiE ITER , F INK & TEPANOVA


Lemma 70 Let = hT , A, Pi ground DL-program let () = I|

ASx (), x {flp, weak }. Suppose DL-atom occurring P,

holds |=T iff |=T d. ASx ( ) = hT , , Pi.
, PxI,T PxI,T coincide; ASx (), minimal
Proof. note = I|

model PxI,T . Consequently, model PxI,T . Moreover, minimal,

J satisfies PxI,T , J |= PxI,T ; hence answer set PxI,T , contradiction.

Suppose RAS x (). implies ASx ( ) = hT , Pi,
A. Lemma 69 answer set thus considered (c). (d), Dp

Dn set (correct) guess |=O DL-atom d, = .
)(d) 6=
Proposition 15 -completeness S, obtain Dp Gr(S, I,


)(d) = . Gr(S, I,
)(d) Gr(S, I,
A)(d) holds
Dn Gr(S, I,



DL-atom d, follows Dn Sgr (d) (A \ ) 6= ; means


H = \ hitting set Dn SIgr (d ), hence minimal hitting set H H





considered (e). (f), Dp set Dp Dp SIgr (d) exists
H = , hence H = . Thus (g) call eval p ( ) yields true,
\ H)(d) = ; thus rep true. Eventually, (h)
likewise call eval n ( ) Gr(S, I,

test flpFND(I, hT A\H, Pi) succeed, x-answer set = hT , Pi,
output.
Lemma 70 = hT \ H, Pi, \ H. Thus step (h) = I|
D.3 Proof Proposition 67
RAS weak (). Towards contradiction,
first show every (1 ), holds I|


suppose (1 ) exists I| 6 RAS weak (). every
6 weak ( ) = hT , , Pi. particular, = A\{P (~c) | pP (~c) I}
I|
6 weak ( ) = hT , , Pi several possibilities: (i)
holds I|
c ; (ii)
guess replacement atoms ed , ned model
extension I|
,O
compatible set ; (iii) interpretation J I|
model P I|
.
extension I|
weak

c hence follows I|
c .
|=
case (i) impossible: =

. Towards contradiction, assume
Assume (ii) true. Consider interpretation I|

,
|=O ned I|
compatible . DL-atom either (1) I|





holds. case (1), I|
|=
d, ed I|
d, support set
(2) 6|=

exists. consider whether Sd 6 Sd . former case, must
coherent I|

contain ABox assertions SdA , otherwise constraint form (r5 ) violated. Due
rule (r6 ) least one assertion Pid SdA must marked deletion. Note Pid
present , relevant support set w.r.t. . Sd known complete,
immediately arrive contradiction. Otherwise, rule form (r8 ) applied,
evaluation postcheck succeeded assumption, get contradiction. 6 Sd ,
Sd known complete, rule form (r8 ) applied; due successful
6|=O d,
evaluation postcheck, contradiction obtained. suppose (2) true. I|
. Sd known complete,
support set exists w.r.t. coherent I|
508

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

constraint (r9 ) violated; contradicts |= 1 . Thus, body rule (r7 ) satisfied,
evaluation postcheck issued fails; hence get contradiction.
,O
model P I|
Finally, assume (iii) holds, i.e. interpretation J I|
weak .
\J contains atoms signature . Let us consider IM = \ .
set = I|



know (1 ); Hence rule rI must exist 1 IM |= B(rI ),
gl

gl

gl


IM 6|=
Recall 1 = ( R f acts(A) COMP). rgl
,O
,O
,O

I|
P I|
P I|

( f acts(A) COMP)Igl , rgl
iff rgl
weak
weak J 6|= Pweak construction
must RI . However,
GL weak reducts, contradiction. Therefore, rgl
gl


latter raises contradiction: rule Rgl atoms signature head IM

coincide rule head; thus follows 6|= B(RIgl ), contradiction. Therefore,
( ) holds, global contradiction, i.e. I|
RAS weak () follows.
I|
).
H(rgl

consider case support family Sd known complete, prove
AS| (1 ) = RAS weak (). shown above, remains check
AS| (1 ) RAS weak (). Towards contradiction, assume RAS weak () exists

/ (1 ) every extension I. RAS weak (), ABox exists
( ) = hT , , Pi. construct extension follows:


= {ed | |=O d} {ned | 6|=O d}

{pP (~c) | P (~c) A\A } f acts(A) COMP
{Supd (~c) | d(~c) support set Sd coherent I}
{S P (~c) | |= rb(S A,P (~c))} {S A,P (~c) | |= rb(S A,P (~c)), nd(S A,P (~c))}.








Since assumption 6 (1 ), one following must hold:

(i) |6 = ( R f acts(A) COMP)Igl

(ii) J exists, J |= ( R f acts(A) COMP)Igl .

satisfies rules forms (r )-(r ).
First assume (i) true. construction I,
1
4
Moreover, constraints form (r5 ) violated, DL-atom d(~c) 6|=O d(~c)
support set consists input assertions. rules (r7 ) (r8 ) present

reduct 1 Igl , |= Cd DL-atom d(~c).

Thus rule r 1 6|= rI could form (r ) (r ). case
gl



6

9

form (r6 ), DL-atom d(~c) would exist 6|=O d(~c). Proposition 15 support set
Hence, r must
d(~c) would exist coherent I, construction SdA,P (~c)
/ I.

form (r9 ); however, |=O d(~c) completeness Sd Proposition 15, construction
implies r violated.
Supd (~c) I,

let (ii) hold, i.e. J exists s.t. J |= 1 Igl . J contains DL-atom
d(~c) exactly one ed (~c) ned (~c) 1 contains ed (~c) ned (~c), interpretations J
coincide replacement atoms ed (~c) ned (~c). Suppose \ J contains atoms
6|= P I,O ; hence rule rI,O P I,O , exists
language . J|
weak
weak
weak
6|= H(rI,O ). Consider respective rule rI . J 6|= H(rJ ),
|= B(rI,O ), J|
J|
gl
gl
gl
weak
weak
509

fiE ITER , F INK & TEPANOVA

). construction weak GL reduct, respectively, positive
must J 6|= B(rgl






J ) B(r I,O ) same. Hence, replacement atom e (~
normal atoms B(rgl
c) (resp.
weak






ned (~c)) must occur positively B(rgl ), ed (~c) \ J (resp. ned (~c) \ J).
already argued, latter possible, leading contradiction.

Consequently, \ J must contain atoms language R. every rule rgl


form (r ) (r ) J |= B(rI ) iff |= B(rI ), thus J agree atoms P (~c)
3
A,P
Sd (~c).

4

gl

gl



Similarly, via (r1 ) (r2 ) must J agree atoms Supd (~c). Finally,
conclusion,
holds pP (~c) pP (~c) rules (r6 ) construction I.


J = holds, violates (ii).
Thus, follows (1 ). Consequently, (1 ) RAS weak (1 ) holds; proves
result.

References
Alchourrn, C. E., Grdenfors, P., & Makinson, D. (1985). logic theory change: Partial
meet contraction revision functions. J. Symbolic Logic, 50(2), 510530.
Aranguren, M. E., Bechhofer, S., Lord, P. W., Sattler, U., & Stevens, R. D. (2007). Understanding
using meaning statements bio-ontology: recasting gene ontology OWL.
BMC Bioinformatics, 8(1), 113.
Ausiello, G., DAtri, A., & Sacc, D. (1983). Graph algorithms functional dependency manipulation. J. ACM, 30(4), 752766.
Ausiello, G., DAtri, A., & Sacc, D. (1986). Minimal representation directed hypergraphs. SIAM
J. Computing, 15(2), 418431.
Baader, F., Bauer, A., & Lippmann, M. (2009). Runtime verification using temporal description
logic. Proc. 7th Intl Symp. Frontiers Combining Systems, FroCoS 2009, pp. 149164.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. Proc. 19th Intl Joint Conf.
Artificial Intelligence, IJCAI 2005, pp. 364369.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.). (2003).
Description Logic Handbook: Theory, Implementation Applications. Cambridge University Press, 2003.
Baader, F., Lutz, C., Milicic, M., Sattler, U., & Wolter, F. (2005). Integrating description logics
action formalisms: First results. Proc. 20th National Conf. Artificial Intelligence 17th
Conf. Innovative Applications Artificial Intelligence, pp. 572577.
Balduccini, M., & Gelfond, M. (2003). Logic programs consistency-restoring rules. Intl
Symp. Logical Formalization Commonsense Reasoning, AAAI 2003 Spring Symposium Series, pp. 918.
Belnap, N. (1977). useful four-valued logic. Modern Uses Multiple-Valued Logic, pp. 737.
Reidel Publishing Company, Boston.
Bertossi, L. E. (2011). Database Repairing Consistent Query Answering. Morgan & Claypool
Publishers, Ottawa, Canada.
510

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Bertossi, L. E., Hunter, A., & Schaub, T. (2005). Introduction inconsistency tolerance. Inconsistency Tolerance [result Dagstuhl seminar], pp. 114.
Bienvenu, M. (2008). Complexity abduction EL family lightweight description logics.
Proc. 11th Intl Conf. Principles Knowledge Representation Reasoning, KR 2008,
pp. 220230.
Bienvenu, M., & Rosati, R. (2013). New inconsistency-tolerant semantics robust ontology-based
data access. Proc. 26th Intl Workshop Description Logics, pp. 5364.
Bonatti, P. A., Faella, M., & Sauro, L. (2010). EL default attributes overriding. Proceedings 9th Intl Semantic Web Conf., ISWC 2010, pp. 6479.
Brewka, G. (1989). Preferred subtheories: extended logical framework default reasoning.
Proc. 11th Intl Joint Conf. Artificial Intelligence, IJCAI 1989, pp. 10431048.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., & Rosati, R. (2007a).
Ontology-based database access. Proc. 15th Italian Symposium Advanced Database
Systems, SEBD 2007, pp. 324331.
Calvanese, D., De Giacomo, G., Lenzerini, M., Lembo, D., Poggi, A., & Rosati, R. (2007b).
MASTRO-I: efficient integration relational data DL ontologies. Proc. 20th
Intl Workshop Description Logics.
Calvanese, D., Ortiz, M., Simkus, M., & Stefanoni, G. (2013). Reasoning explanations
negative query answers DL-Lite. J. Artificial Intelligence Research, 48, 635669.
Console, L., Sapino, M. L., & Dupr, D. T. (1995). role abduction database view updating.
J. Intelligent Information Systems, 4(3), 261280.
Console, M., Mora, J., Rosati, R., Santarelli, V., & Savo, D. F. (2014). Effective computation
maximal sound approximations description logic ontologies. Proc. 13th Intl Semantic
Web Conf., ISWC 2014, Part II, pp. 164179.
dlliteplugin DLVHEX system (2015). https://github.com/hexhex/dlliteplugin.
Scripts DL-program benchmark generation (2015).
dlliteplugin/benchmarks.

https://github.com/hexhex/

dlplugin DLVHEX system (2015). https://github.com/hexhex/dlplugin.
DR E W reasoner DL-Programs Datalog-rewritable Description Logics (2012). http://
www.kr.tuwien.ac.at/research/systems/drew/.
Ecke, A., Ludwig, M., & Walther, D. (2013). concept difference EL-terminologies using
hypergraphs. Proc. Intl Workshop Document Changes: Modeling, Detection, Storage
Visualization.
Eiter, T., Erdem, E., Fink, M., & Senko, J. (2005). Updating action domain descriptions. Proc.
19th Intl Joint Conf. Artificial Intelligence, IJCAI 2005, pp. 418423.
Eiter, T., Fink, M., Greco, G., & Lembo, D. (2008). Repair localization query answering
inconsistent databases. ACM Transactions Database Systems, 33(2).
Eiter, T., Fink, M., Krennwallner, T., Redl, C., & Schller, P. (2014a). Efficient HEX-program
evaluation based unfounded sets. J. Artificial Intelligence Research, 49, 269321.
511

fiE ITER , F INK & TEPANOVA

Eiter, T., Fink, M., Redl, C., & Stepanova, D. (2014b). Exploiting support sets answer set
programs external evaluations. Proc. 28th Conf. Artificial Intelligence, AAAI 2014,
pp. 10411048.
Eiter, T., Fink, M., & Stepanova, D. (2013). Data repair inconsistent DL-programs. Proc. 23rd
Intl Joint Conf. Artificial Intelligence, IJCAI 2013, pp. 869876.
Eiter, T., Fink, M., & Stepanova, D. (2014c). Computing repairs inconsistent DL-programs
EL ontologies. Proc. 14th Joint European Conf. Logics Artificial Intelligence, JELIA
2014, pp. 426441.
Eiter, T., Fink, M., & Stepanova, D. (2014d). Towards practical deletion repair inconsistent
DL-programs. Proc. 21st European Conf. Artificial Intelligence, ECAI 2014, pp. 285290.
Eiter, T., Fink, M., & Stepanova, D. (2014d). Data repair inconsistent DL-programs. Tech. rep.
INFSYS RR-1843-15-03, Institut f. Informationssysteme, TU Wien, A-1040 Vienna, Austria.
Eiter, T., Gottlob, G., & Leone, N. (1997). Abduction logic programs: Semantics complexity. Theoretical Computer Science, 189(1-2), 129177.
Eiter, T., Ianni, G., Lukasiewicz, T., Schindlauer, R., & Tompits, H. (2008). Combining answer
set programming description logics Semantic Web. J. Artificial Intelligence,
172(12-13), 14951539.
Eiter, T., Ianni, G., Schindlauer, R., & Tompits, H. (2005). uniform integration higher-order
reasoning external evaluations answer-set programming. Proc. 19th Intl Joint Conf.
Artificial Intelligence, IJCAI 2005, pp. 9096.
Eiter, T., & Makino, K. (2007). computing abductive explanations propositional Horn
theory. J. ACM, 54(5).
Eiter, T., Schneider, P., imkus, M., & Xiao, G. (2014). Using OpenStreetMap data create benchmarks description logic reasoners. Proc. 2nd Intl Workshop OWL Reasoner Evaluation, ORE 2014, Vol. 1207, pp. 5157.
Experimental data inconsistent DL-programs (2015). http://www.kr.tuwien.ac.at/
staff/dasha/jair_el/benchmark_instances.zip.
Feng, S., Ludwig, M., & Walther, D. (2015). logical difference EL: terminologies
towards tboxes. Proc. 1st Intl Workshop Sem. Technologies, IWOST 2015, pp. 3141.
Fink, M. (2012). Paraconsistent hybrid theories. Proc. 13th Intl Conf. Principles Knowledge Representation Reasoning, KR 2012, pp. 141151.
Frhstck, M., Phrer, J., & Friedrich, G. (2013). Debugging answer-set programs ouroboros extending sealion plugin. Proc. 12th Intl Conf. Logic Programming Nonmonotonic
Reasoning, LPNMR 2013, pp. 323328.
Gallo, G., Longo, G., & Pallottino, S. (1993). Directed hypergraphs applications. Discrete
Applied Mathematics, 42(2), 177201.
Grdenfors, P., & Rott, H. (1995). Belief revision. Handbook Logic Artificial Intelligence
Logic Programming, 4, 35132.
Gardiner, T., Tsarkov, D., & Horrocks, I. (2006). Framework automated comparison
description logic reasoners. Proc. 5th Intl Semantic Web Conf., ISWC 2006, pp. 654667.
512

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Gebser, M., Phrer, J., Schaub, T., & Tompits, H. (2008). meta-programming technique
debugging answer-set programs. Proc. 23rd Conf. Artificial Intelligence, AAAI 2008, pp.
448453.
Gelfond, M., & Lifschitz, V. (1991). Classical negation logic programs disjunctive databases.
New Generation Computing, 9, 365385.
Gottlob, G., Pichler, R., & Wei, F. (2007). Efficient datalog abduction bounded treewidth.
Proc. 22nd Intl Conf. Artificial Intelligence, AAAI 2007, pp. 16261631.
Grau, B. C., Horrocks, I., Kazakov, Y., & Sattler, U. (2007). right amount: extracting
modules ontologies. Proc. 16th Intl Conf. World Wide Web, WWW 2007, pp. 717
726.
Hansen, P., Lutz, C., Seylan, I., & Wolter, F. (2014). Query rewriting EL TBoxes: Efficient
algorithms. Proc. 27th Intl Workshop Description Logics, pp. 197208.
Hermann, M., & Pichler, R. (2010). Counting complexity propositional abduction. J. Computer
System Sciences, 76(7), 634649.
HTCondor load distribution system, version 7.8.7 (2012). http://research.cs.wisc.edu/
htcondor/.
Huang, S., Hao, J., & Luo, D. (2014). Incoherency problems combination description logics
rules. J. Applied Mathematics, 604753:16.
Huang, S., Li, Q., & Hitzler, P. (2013). Reasoning inconsistencies hybrid MKNF knowledge
bases. Logic J. IGPL, 21(2), 263290.
Kaminski, T., Knorr, M., & Leite, J. (2015). Efficient paraconsistent reasoning ontologies
rules. Proc. 24th Intl Joint Conf. Artificial Intelligence, IJCAI 2015, pp. 30983105.
Knorr, M., Alferes, J. J., & Hitzler, P. (2008). coherent well-founded model hybrid MKNF
knowledge bases. Proc. 18th European Conf. Artificial Intelligence, ECAI 2008, pp.
99103.
Knorr, M., Alferes, J. J., & Hitzler, P. (2011). Local closed world reasoning description logics
well-founded semantics. Artificial Intelligence, 175(9-10), 15281554.
Konev, B., Ludwig, M., Walther, D., & Wolter, F. (2012). logical difference lightweight
description logic EL. J. Artificial Intelligence Research, 44, 633708.
Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2010). combined
approach query answering DL-Lite. Proc. 12th Intl Conf. Principles Knowledge
Representation, KR 2010, pp. 247257.
Kotek, T., Simkus, M., Veith, H., & Zuleger, F. (2014). Towards description logic program
analysis: Extending ALCQIO reachability. Proc. 27th Intl Workshop Description
Logics, pp. 591594.
Lembo, D., Lenzerini, M., Rosati, R., Ruzzi, M., Savo, D. F. (2015). Inconsistency-tolerant query
answering ontology-based data access. J. Web Sem., 33, 329.
Lembo, D., Santarelli, V., & Savo, D. F. (2013). graph-based approach classifying OWL 2 QL
ontologies. Proc. 26th Intl Workshop Description Logics, pp. 747759.
LUBM benchmark (2005). http://swat.cse.lehigh.edu/projects/lubm/.
513

fiE ITER , F INK & TEPANOVA

LUBM data generator (2013). http://code.google.com/p/combo-obda/.
Ludwig, M., & Walther, D. (2014). logical difference ELHr-terminologies using hypergraphs. Proc. 21st European Conf. Artifical Intelligence, ECAI 2014, pp. 555560.
Lukasiewicz, T. (2010). novel combination answer set programming description logics
semantic web. IEEE Trans. Knowledge Data Engineering, 22(11), 15771592.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering description logic EL
using relational database system. Boutilier, C. (Ed.), Proc. 21st Joint Intl Conf. Artificial
Intelligence, IJCAI 2009, pp. 20702075.
Lutz, C., Walther, D., & Wolter, F. (2007). Conservative extensions expressive description logics.
Proc. 20th Intl Joint Conf. Artificial Intelligence, IJCAI 2007, pp. 453458.
Lutz, C., & Wolter, F. (2010). Deciding inseparability conservative extensions description
logic EL. J. Symbolic Computation, 45(2), 194228.
Martinez, M. V., Molinaro, C., Subrahmanian, V. S., & Amgoud, L. (2013). General Framework
Reasoning Inconsistency. Springer Briefs Computer Science. Springer, 2013.
Masotti, G., Rosati, R., & Ruzzi, M. (2011). Practical abox cleaning DL-Lite (progress report).
Proc. Description Logics Workshop.
Motik, B., & Rosati, R. (2010). Reconciling Description Logics Rules. J. ACM, 57(5),
162.
MyITS - Personalized Intelligent Mobility Service (2012). http://www.kr.tuwien.ac.at/
research/projects/myits/GeoConceptsMyITS-v0.9-Lite.owl/.
Nguyen, N. T. (2008). Advanced Methods Inconsistent Knowledge Management. Advanced
Information Knowledge Processing. Springer.
Nortje, R., Britz, A., & Meyer, T. (2013). Module-theoretic properties reachability modules
SRIQ. Proc. 26th Intl Workshop Description Logics, pp. 868884.
Oetsch, J., Phrer, J., & Tompits, H. (2012). Stepwise debugging description-logic programs.
J. Correct Reasoning, pp. 492508.
Open Street Map project (2012). http://www.openstreetmap.org/.
zccep, . L., & Mller, R. (2012). Combining DL Lite spatial calculi feasible geothematic query answering. Proc. 25th Intl Workshop Description Logics.
Pan, J. Z., & Thomas, E. (2007). Approximating OWL-DL ontologies. Proc. 22nd Intl Conf.
Artificial Intelligence, AAAI 2007, pp. 14341439.
Prez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering rewriting
description logic constraints. J. Applied Logic, 8(2), 186209.
Phrer, J., Heymans, S., & Eiter, T. (2010). Dealing inconsistency combining ontologies
rules using DL-programs . Proc. 7th Extended Semantic Web Conf., ESWC 2010, part
I, pp. 183197.
R ACER P RO reasoner OWL ontologies (2007). http://franz.com/agraph/racer/.
Reiter, R. (1987). theory diagnosis first principles. J. Artificial Intelligence, 32(1), 5795.
514

fiC OMPUTING R EPAIRS NCONSISTENT DL-P ROGRAMS EL NTOLOGIES

Rosati, R. (2007). conjunctive query answering EL. proceedings 20th Intl Workshop
Description Logics.
Rosati, R., Ruzzi, M., Graziosi, M., & Masotti, G. (2012). Evaluation techniques inconsistency handling OWL 2 QL ontologies. Proc. 11th Intl Semantic Web Conf., ISWC 2012,
pp. 337349.
Sakama, C., & Inoue, K. (1995). Paraconsistent stable semantics extended disjunctive programs.
J. Logic Computation, 5(3), 265285.
Sakama, C., & Inoue, K. (2003). abductive framework computing knowledge base updates.
Theory Practice Logic Programming, 3(6), 671713.
Schulz, C., Satoh, K., & Toni, F. (2015). Characterising explaining inconsistency logic
programs. Proc. 13th Intl Conf., LPNMR 2015, pp. 467479.
Schulz, S., Cornet, R., & Spackman, K. A. (2011). Consolidating SNOMED CTs ontological
commitment. Applied Ontology, 6(1), 111.
Shen, Y.-D. (2011). Well-supported semantics description logic programs. Proc. 22nd Intl
Joint Conf. Artificial Intelligence, IJCAI 2011, pp. 10811086.
Stefanoni, G., Motik, B., & Horrocks, I. (2012). Small datalog query rewritings EL. Proc.
25th Intl Workshop Description Logics.
Stepanova, D. (2015). Inconsistencies Hybrid Knowledge Bases. PhD thesis, Vienna University
Technology.
Steve, G., Gangemi, A., & Mori, A. R. (1995). Modelling sharable medical concept system:
Ontological foundation galen. AIME, pp. 411412.
Stuckenschmidt, H., Parent, C., & Spaccapietra, S. (Eds.). (2009). Modular Ontologies: Concepts,
Theories Techniques Knowledge Modularization, Vol. 5445 Lecture Notes Computer Science. Springer.
Syrjnen, T. (2006). Debugging Inconsistent Answer-Set Programs. Proc. 11th Intl Workshop
Nonmonotonic Reasoning, NMR 2006, pp. 7783.
Thakur, M., & Tripathi, R. (2009). Linear connectivity problems directed hypergraphs. Theoretical Computer Science, 410(27-29), 25922618.
Tserendorj, T., Rudolph, S., Krtzsch, M., & Hitzler, P. (2008). Approximate OWL-reasoning
Screech. Proc. 2nd Intl Conf. Web Reasoning Rule Systems, RR 2008, pp. 165180.
Wache, H., Groot, P., & Stuckenschmidt, H. (2005). Scalable instance retrieval semantic web
approximation. Proc. 1st Intl Workshops Web Information Systems Engineering,
WISE 2005, pp. 245254.
Wang, Y., You, J.-H., Yuan, L.-Y., & Shen, Y.-D. (2010). Loop formulas description logic
programs. Theory Practice Logic Programming, 10(4-6), 531545.
Xiao, G. (2014). Inline Evaluation Hybrid Knowledge Bases. Ph.D. thesis, Vienna University
Technology, Austria.
Zhao, Y., Pan, J. Z., & Ren, Y. (2009). Implementing evaluating rule-based approach
querying regular EL+ ontologies. Proc. 9th Intl Conf. Hybrid Intelligent Systems,
2009, pp. 493498.

515


