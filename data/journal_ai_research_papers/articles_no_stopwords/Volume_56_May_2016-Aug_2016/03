journal artificial intelligence

submitted published

computing repairs inconsistent dl programs el ontologies
eiter kr tuwien ac

thomas eiter
michael fink
daria stepanova

fink kr tuwien ac
dasha kr tuwien ac

institut fr informationssysteme tu wien
favoritenstrae vienna austria

abstract
description logic dl ontologies non monotonic rules two prominent knowledge
representation kr formalisms complementary features essential applications nonmonotonic description logic dl programs combine formalisms thus providing support rule reasoning top dl ontologies well defined query interface
represented called dl atoms unfortunately interaction rules ontology may
incur inconsistencies dl program lacks answer sets e thus yields
information issue addressed recently defined repair answer sets computing
effective practical proposed dl lite ontologies reduces repair computation constraint matching called support sets however exploits
particular features dl lite readily applied repairing dl programs
prominent dls el compared dl lite el support sets may neither small
support sets might exist completeness may need given
support information bounded thus provide computing repairs
dl programs el ontologies partial incomplete support families latter
constructed datalog query rewriting techniques well ontology approximation
logical difference el terminologies maximal size number support sets given dl atom estimated analyzing properties support hypergraph
characterizes relevant set tbox axioms needed query derivation present declarative implementation repair experimentally evaluate set benchmark
promising witness practical feasibility repair

introduction
description logics dls powerful formalism knowledge representation kr
used formalize domains interest describing meaning terms relationships
well suited terminological modelling contexts semantic web data
integration ontology data access calvanese de giacomo lenzerini lembo poggi
rosati b calvanese de giacomo lembo lenzerini poggi rosati reasoning
actions baader lutz milicic sattler wolter spatial reasoning zccep mller
runtime verification program analysis baader bauer lippmann kotek
simkus veith zuleger mention
dls fragments classical first order logic shortcomings modelling application settings nonmonotonicity closed world reasoning needs expressed
rules nonmonotonic logic programming offer features addition serve well
tool declaring knowledge reasoning individuals modelling nondeterminism model generation possible answer set programming get best two
c

ai access foundation rights reserved

fie iter f ink tepanova



blacklisted staff




staffrequest hasaction action hassubject staff hastarget project
blacklistedstaffrequest staffrequest hassubject blacklisted



staffrequest r hassubject r john blacklisted john



hastarget r p hasaction r read action read


projfile p hasowner p john






chief hasowner z projfile z









grant x dl project projfile staffrequest x deny x
p




deny x dl staff chief blacklistedstaffrequest x








hasowner

z

grant x






dl hastarget x dl hassubject x z















figure dl program policy ontology
worlds dls nonmonotonic rules natural idea combining led number
approaches combination often called hybrid knowledge bases see work
motik rosati references therein among nonmonotonic description logic
dl programs eiter ianni lukasiewicz schindlauer tompits prominent
called dl atoms serve query interfaces ontology loose coupling enable bidirectional information flow rules ontology possibility add
information rules part prior query evaluation allows adaptive combinations however loose interaction rules ontology easily lead inconsistency
lack answer sets
example consider dl program ho pi figure formalizing access policy
ontology ht ai bonatti faella sauro whose taxonomy tbox given
sample data part abox besides facts simple
rule rule part p contains defaults expressing staff members granted
access project files unless blacklisted constraint forbids owners project information lack access parts p interact via dl atoms
dl project projfile staffrequest x latter specifies temporary update via operator prior querying e additional assertions project c considered individual c projfile c true interpretation p instances x staffrequest
retrieved inconsistency arises john chief project p owner files
access
inconsistency well known logic data intensive systems treating logically contradicting information studied fields e g belief
revision alchourrn grdenfors makinson grdenfors rott knowledge base
updates eiter erdem fink senko diagnosis reiter ontology data access lembo lanzerini rosati ruzzi savo nonmonotonic reasoning brewka
sakama inoue many others cf bertossi hunter schaub nguyen
martinez molinaro subrahmanian amgoud bertossi hybrid formalisms
far inconsistency management concentrated mostly inconsistency tolerance instance


fic omputing r epairs nconsistent dl p rograms el ntologies

mknf knowledge bases paraconsistent semantics developed knorr alferes hitzler
huang li hitzler kaminski knorr leite dl programs inconsistency tolerance issues targeted fink paraconsistent semantics
logic introduced furthermore phrer heymans eiter
considered suppressing certain problematic dl atoms approaches aimed reasoning
inconsistent system rather making required changes system arrive consistent
state contrast repair techniques recently developed eiter fink
stepanova
theoretical framework repairing inconsistent dl programs proposed eiter et al
ontology abox likely source errors changed modified dl program
answer sets called repair answer sets different repair options including deletion abox formulas restricted forms addition considered together naive
computing repair answer sets lacked practicality
effective repair dl atoms decided without dynamic ontology
access presented eiter fink stepanova support sets eiter fink
redl stepanova b dl atoms portions input together abox
determine truth value dl atom exploits complete support families e
stocks support sets value dl atom every interpretation determined repeated ontology access avoided works well
dl lite prominent tractable dl since complete support families small easy
compute
however unfortunately dls readily usable general
large infinite support families applies even el another important dl offers tractable reasoning widely applied many domains including biology cf e g schulz cornet spackman aranguren bechhofer lord sattler
stevens medicine steve gangemi mori chemistry policy management etc due
features el include range restrictions concept conjunctions left hand side
inclusion axioms dl atom accessing el ontology arbitrarily large infinitely
many support sets general latter excluded acyclic tboxes often occurring
practice gardiner tsarkov horrocks complete support families still large
constructing well managing might impractical obstructs deployment
proposed eiter et al el ontologies tackle issue
develop repair computation techniques dl programs ontologies el focus el
since apart simple widely used dl well researched available effective
query rewriting important reasoning readily used
specifically introduce general repair answer set computation operates partial incomplete support families along techniques families
effectively computed computing repair answer sets dl programs
el ontologies p complete formulation decision refer work
stepanova details complexity
contributions advances previous works eiter et al b
summarized follows
effective computation repair answer sets exploit support sets eiter et al
contrast approaches eiter et al however tbox
classification invoked use datalog rewritings queries computing support sets


fie iter f ink tepanova

see hansen lutz seylan wolter introduce notion partial support
families ontology reasoning access completely eliminated
general constructing complete support families feasible el ontologies provide novel methods computing partial support families exploiting ontology
approximation techniques logical difference el terminologies considered konev ludwig walther wolter ludwig walther
capture restricted classes tboxes complete support families still
effectively computed consider support hypergraph dl atoms inspired
ontology hypergraphs nortje britz meyer ecke ludwig walther
support hypergraph serves characterize tbox parts relevant deriving
query analysis support hypergraphs allows us estimate maximal size
number support sets needed form complete support family
generalize repair answer set computation proposed eiter et al
el ontologies handled novel operates partial support
families principle applied ontologies dls beyond el uses
hitting sets disable known support sets negative dl atoms performs evaluation
postchecks needed compensate incompleteness support families moreover trades
answer completeness scalability minimal hitting sets however completeness may
ensured simple extension
provide system prototype declarative realization novel repair
answer set computation repair evaluated novel benchmarks promising potential proposed
organization rest organized follows section recall basic notions
preliminary section deals support sets computation section
discusses partial support family construction tbox approximation techniques section
analyze properties support hypergraph estimating maximal size number support sets complete support family dl atom section repair answer
set computation declarative implementation presented experiments presented section followed discussion related work section concluding remarks section

preliminaries
section recall basic notions description logics focus el baader
brandt lutz dl programs eiter et al background description
logics see baader calvanese mcguinness nardi patel schneider
description logic knowledge bases
consider description logic dl knowledge bases kbs signature hi c ri
set individuals constants set c concept names unary predicates set r role
names binary predicates usual dl knowledge base ontology pair ht ai
tbox abox finite sets formulas capturing taxonomic resp factual


fic omputing r epairs nconsistent dl p rograms el ntologies

tnorm


staffrequest hasaction action





staffrequest hassubject staff





staffrequest
hastarget project



hasaction action chasa

hassubject staff chass st




hastarget project chast p




chasa chass st chasa ahass st



chasa ahass st chast p staffrequest

figure normalized tbox

























knowledge whose form depends underlying dl abuse notation write
viewing set formulas
syntax el concepts c denoting sets objects roles r denoting binary relations
objects obey following syntax c atomic concept r r
atomic role
c c c r c
el tbox axioms form c c called generalized concept inclusion axioms
gcis c c el concepts abox formulas form c r c
c r r c sequel use p generic predicate c r
distinction immaterial
example el ontology given figure
definition normalized tbox tbox normalized axioms one following forms


r
r
atomic concepts
e g axiom example normal form axioms
el tbox equivalent tbox normal form constructible linear time stuckenschmidt
parent spaccapietra extended signature baader et al
special class tboxes widely studied literature el terminologies defined follows
definition el terminology el terminology el tbox satisfying following conditions
consists axioms forms c c atomic c
arbitrary el concept
concept name occurs left hand side axioms
example tbox ontology figure el terminology
semantics semantics dl ontologies first order interpretations baader et al
interpretation pair hi non empty domain interpretation
linear complexity obtained standard assumption dls atomic concepts
constant size e length binary string representing atomic concept depend particular
knowledge base



fie iter f ink tepanova

function assigns individual c object ci concept name c subset
c role name r binary relation ri interpretation extends
inductively non atomic concepts c roles r according concept resp role constructors
el r c ho ri c c c di
satisfaction axiom resp assertion w r interpretation e follows
c c di ii c ai c iii r b ai bi ri
furthermore satisfies set formulas denoted
tbox respectively abox ontology satisfiable consistent
interpretation satisfies call abox consistent tbox consistent
since negation neither available expressible el el ontologies consistent
example ontology figure consistent satisfying interpretation hi
exists john read p r action read blacklisted staff john
hassubject r john staffrequest blacklistedstaffrequest r hasaction
r read hastarget r p
throughout consider ontologies el unique name assumption una
e whenever holds interpretation however carry
ontologies without una hard see una el effect query
answering cf lutz toman wolter
dl programs
dl program ho pi pair dl ontology set p dl rules extend
rules non monotonic logic programs special dl atoms formed signature
hc p c ri p hc pi signature rule part p set c constant
symbols finite set p predicate symbols called lp predicates non negative arities
hi c ri dl signature set p disjoint c r simplicity assume
c
syntax disjunctive dl program ho pi consists dl ontology finite set p
dl rules r form
b bk bk bm



negation failure naf ai n first order atom p
predicate p p called ordinary lp atom bi lp atom dlatom rule constraint n normal n call h r
head r b r b bk bk bm body r b r b bk
b r bk bm denote positive negative parts b r respectively
dl atom form
dl q


op p sm op pm input list si
c r op update operator pi p input predicate arity
si intuitively op increases si extension pi
strong negation added resp emulated usual eiter et al



fic omputing r epairs nconsistent dl p rograms el ntologies

b q dl query one forms c c concept
term ii r r role terms iii c c
note inclusion dl queries form c c easily reduced instance queries
thus simplicity consider work instance dl queries
example consider dl atom dl project projfile staffrequest x rule
figure x r dl query staffrequest r list project projfile
contains input predicate projfile extends ontology predicate project via update
operator
semantics semantics dl program
ho pi given terms grounding
gr ho gr p c e gr p rp gr r contains possible ground instances
rules r p c remainder default assume ground
herbrand interpretation set hb ground atoms hb herbrand base p hc pi e set ground atoms p satisfies lp dl atom

lp atom
ii q ht ai dl atom form





ai ai si pi





satisfaction dl rule r resp set p rules herbrand interpretation hp oi
usual satisfies bj satisfy bj satisfies satisfies
r p denote satisfies model object dl atom rule set rules superscript specifies ontology dl atoms
evaluated model minimal model exists
example dl atom dl project projfile staffrequest r satisfied interpretation projfile p hasowner p john since staffrequest r

staffreqeust r still holds staffrequest r
repair answer sets semantics dl programs extend answer set semantics logic
programs gelfond lifschitz dl programs e g eiter et al lukasiewicz
wang yuan shen shen concentrate weak answer sets eiter
et al treat dl atoms atoms naf flp answer sets eiter ianni schindlauer tompits obey stronger foundedness condition answer sets
ordinary logic program interpretations minimal program reduct
intuitively captures assumption application rules reconstruct interpretation

p relative hb gr p deleting
weak reduct pweak
rules r dl atom b r l l b r
ii dl atoms b r literals b r
evaluating dl c c reduces evaluating dl ac
ac c c ac ac fresh constant ac ac fresh concepts similar
tbox normalization



fie iter f ink tepanova


flp reduct pflp
p gr p deleting rules r whose bodies

satisfied e bi bi k bj bj k j
illustrate notions example

example let figure let rule set p contain facts rules
x z instantiated r john p respectively consider interpretation

projfile p hasowner p john chief john grant r flp reduct pflp
contains

rules p weak reduct pweak
rule replaced fact grant r

definition x deletion repair answer set interpretation x deletion repair answer set

ht pi x flp weak minimal model pxi
called x deletion repair standard x answer set
example projfile p chief john hasowner p john grant john weak
flp repair answer set example repair blacklisted john
notation denote normal logic program p p set answer sets p
dl program x resp ras x set x answer sets resp x repair
answer sets
general flp answer set weak answer set vice versa e flp answer sets
restrictive notion however many cases weak flp answer sets coincide
information reducts see works eiter et al wang et al
shifting lemma simplify matters avoid dealing logic program predicates separately shall shift eiter et al lp input dl atoms ontology given
dl atom dl q p p call pp c input assertion pp
fresh ontology predicate c c ad set assertions tbox
dl atom let td pp p p p interpretation let
odi td pp ad p
proposition eiter et al every dl atom dl q interi
pretation holds iff od dl q iff odi q
unlike oi odi clear distinction native assertions input assertions
w r via facts pp axioms pp p mirroring lp input note normal
form td normal form

support sets dl atoms
section recall support sets dl atoms eiter et al b effective
optimization means repair answer set computation eiter et al intuitively support
set dl atom dl q portion input together abox assertions
sufficient conclude query q evaluates true e given subset
interpretation set abox assertions ontology conclude
q basically method suggests precomputing support sets dl atom
nonground level dl program evaluation candidate interpretation ground instances
support sets computed help prune search space repair answer sets


fic omputing r epairs nconsistent dl p rograms el ntologies

exploiting proposition following definition support sets ontology
predicates
definition ground support sets given ground dl atom dl q set aad
support set w r ontology ht ai td q supp denote
set support sets w r
support sets grouped families support sets simply support families formally
definition support family collection supp support sets dl atom
w r ontology support family w r
general el particular even minimal support sets arbitrarily large
infinitely many support sets may exist acyclic tboxes still exponentially many
support sets possible however nonetheless exploit repair answer set
computation section
support sets linked interpretations following notion
definition coherence support set dl atom coherent interpretation
pp c holds p c
example dl atom dl project projfile staffrequest r figure two
support sets staffrequest r hassubject r john projectprojfile p
staff john hasaction r read action read coherent interpretation
coherent interpretations projfile p
evaluation w r reduces search coherent support sets
proposition let dl q ground dl atom let ht ai ontology
let interpretation iff supp exists coherent
sufficient portion support sets completely eliminate ontology access
evaluation dl atoms naive one precomputes support sets ground dlatoms respect relevant aboxes uses repair answer set computation
scale practice since support sets may computed incoherent
candidate repair answer sets
alternative fully interleave support set computation search repair answer
sets construct coherent ground support sets dl atom interpretation
fly input dl atom may change different interpretations support sets must
recomputed however since reuse may possible effective optimizations immediate
better solution precompute support sets nonground level schematic support
sets prior repair computation furthermore may leave concrete abox open
support sets dl atom instance easily obtained syntactic matching
dl q x

definition nonground support sets let tbox let x

nonground dl atom suppose v x set distinct variables c set constants
nonground support set w r set p pk k atoms


fie iter f ink tepanova

k v
k support set
ii substitution v c instance p pk

x w r oc ac ac set possible abox assertions c
ontology ac denote suppo set nonground support sets
w r
ac takes care possible abox considering largest abox since
implies supp supp
example dl project projfile staffrequest x set staffrequest x
nonground support set likewise set action w staff hassubject x
hastarget x z projectprojfile z hasaction x w
sufficiently large portion nonground support sets precomputed ontology access
fully avoided call portion complete support family
definition complete support family family suppo nonground support sets
w r ontology complete every support set
non ground dl atom x


exist
supp x x c extension v c v x



example consider dl atom x dl project projfile staffrequest x figure family complete w r ht hastarget
hs hassubject ha hasaction














staffrequest x
project ht x hs x z staff z ha x z action z
projectprojfile ht x hs x z staff z ha x z action z
project ht x hs x z blacklisted z ha x z action z
projectprojfile ht x hs x z blacklisted z ha x z action z
blacklistedstaffrequest x


say two nonground support sets resp support families ground identical
groundings coincide e g support sets p x r x p x r x z
ground identical dl atom x dl q x respective support families

definition subsumption nonground support set subsumed denoted
every ground instance ground instance exists
nonground support families say subsumed denoted
instance instance exists holds
example blacklistedstaffrequest x hassubject x blacklisted support
set dl atom x dl staff chief blacklistedstaffrequest x w r figure subsumed blacklistedstaffrequest x e moreover
support families
blacklistedstaffrequest x hassubject x z blacklisted z mutually subsume


fic omputing r epairs nconsistent dl p rograms el ntologies

axiom
datalog rule

x x
x x x
r x r x
r
r x oa x
oa x

table el tbox rewriting
definition maximal support set size maxsup maximal support set size dl atom
w r denoted maxsup smallest integer n every complete nonground support family w r support set n support set
exists w r suppd n
instance dl atom tbox example maximal support set
size e maxsup
computing support sets
section provide methods constructing nonground support sets natural
computation nonground support sets exploit conjunctive query answering methods
el e g rosati lutz et al kontchakov lutz toman wolter zakharyaschev
stefanoni motik horrocks
suppose given dl program ho pi ht ai el ontology
dl q x
method construct nonground support sets x

dl atom x
following three steps
step dl query rewriting tbox first step exploits rewriting dl tbox td pp p p p set datalog rules
query q x
preprocessing stage tbox td normalized technique restricts syntactic form
tboxes decomposing complex simpler axioms purpose set fresh concept
symbols introduced normalized form td norm td computed rewrite part
tbox relevant query q datalog program prog q tdnorm translation
given table variant translation prez urbina motik horrocks
zhao pan ren rewriting axioms form r fourth axiom
table introduce fresh constants oa represent unknown objects similar rewriting
exploited r equiem system prez urbina et al function symbols used
instead fresh constants obtain
lemma every data part e abox every ground assertion q c deciding whether
prog q tdnorm q c equivalent checking td norm q c
step query unfolding second step proceeds standard unfolding rules
prog q td norm w r target dl query q start rule q head expand
body rules program prog q tdnorm applying procedure exhaustively
get number rules correspond rewritings query q td norm note
possible obtain rewritings effectively since general might


fie iter f ink tepanova

prog q td norm


chasa x hasaction x action




chass st x hassubject x staff



chast p x hastarget x project



chasa ahass st x chasa x chass st x







staffrequest x chasa ahass st x chast p x



project x projectprojfile x

















figure dl query rewriting dl project projfile staffrequest x td norm
infinitely many cyclic still exponentially many acyclic discuss
techniques computing partial support families next section
step support set extraction last step extracts nonground support sets rewritings
step select containing predicates td obtain rules r form
p pk k pk
k pnp n
q x


pk

n

pi native ontology predicate k predicate mirroring lp input
otherwise bodies rules correspond support sets given dl atom e
k pnp
n
p pk k pk


pk

n

following holds
dl q x
dl atom program ho pi el
proposition let x

ontology ht ai every set constructed steps nonground support set x
shifting lemma working support sets focus ontology predicates
operate specifically rules form k n fully reflect nonground
support sets definition ground instantiations rule constants c
implicitly correspond ground support sets
illustrate computation nonground support sets dl atoms el ontologies
example consider dl atom dl project projfile staffrequest x accessing el ontology ht ai figure datalog rewriting computed step given
figure step obtain following query unfoldings staffrequest
staffrequest x staffrequest x
staffrequest x hasaction x action hassubject x
staff hastarget x projectprojfile
staffrequest x hasaction x action hassubject x
staff hastarget x project
staffrequest x hasaction x action hassubject x
blacklisted hastarget x project
staffrequest x hasaction x action hassubject x
blacklisted hastarget x projectprojfile
step thus get rule hasaction x action staff
hassubject x hastarget x projectprojfile rule action
hasaction x staff hassubject x project hastarget x
remaining support sets similarly obtained



fic omputing r epairs nconsistent dl p rograms el ntologies

partial support families
finding support sets dl atom tightly related computing solutions logic
abduction abduction important mode reasoning widely applied different areas
ai including diagnosis natural language understanding many others console
sapino dupr variants actively studied e g eiter
gottlob leone bienvenu unfortunately practically important
context abduction intractable even restricted propositional theories eiter
makino abduction el tboxes considered bienvenu
represented tuple ht h oi tbox set atomic concepts h atomic concept
explanation set h
abox ad contains atomic concepts computing nonground support sets
dl q x accessing ht ai corresponds abduction htd sig ad qi
roles occur ad one introduce fresh concepts construct complex
concepts hypothesis e g r inclusion cr r added td cr
h cr fresh concept
unlike dl lite support families dl atoms el ontologies particular
structure large maximal support set size exponential size
example consider following acyclic tbox contains axioms
r b b b
r b b b

n r bn bn bn
dl b x maximal support set size witnessed
r x x b x x x b x

dl atom dl b x maxsup due r x x
r x x b x x x b x x x r x x b x x x b x
moreover di dl bi x maxsup di maxsup di n
note maximal support set dn involves n predicates therefore tbox
form sig k lower bound worst case support set size
k k single exponential size

general many unfoldings produced step according recent
hansen et al complete support families el computed large classes ontologies therefore still exploit support families unlike eiter et al require
complete develop techniques computing partial e incomplete support families dl atoms natural context aim finding support sets bounded
size general due cyclic dependencies r c c possible el
dl lite support sets arbitrary large analysis vast number ontologies
revealed many realistic cases ontologies contain imply cyclic axioms gardiner
et al thus assume practical considerations tbox ontology given
dl program acyclic e entail inclusion axioms form r c c however even
restriction support sets large example shows


fie iter f ink tepanova

computing complete support families computationally expensive natural
produce support sets certain size k e g limited program unfolding
unfolding branch reaches depth k stop expand different branch similarly compute limited number k support sets stopping rule unfolding program prog q tdnorm
k th support set produced alternative tbox approximation
techniques pursued next section

partial support family construction via tbox approximation
provide practical methods construct partial support families tbox approximation
tbox approximation
approximation dl ontologies source language l different target language l
well known important technique ontology management existing approaches
approximation roughly divided syntactic approaches semantic approaches former
e g tserendorj rudolph krtzsch hitzler wache groot stuckenschmidt focus syntactic form axioms original ontology appropriately
rewrite axioms comply syntax target language rather effective general produce unsound answers pan thomas semantic approaches
focus model entailment original ontology rather syntactic structure
aim preserving entailments much possible transforming ontology
target language general sound might computationally expensive
console mora rosati santarelli savo
task computing partial support families sound ontology approximation techniques
relevant choose dl lite core target approximation language lies intersection el dl lite complete support families effectively identified eiter
et al approximating tbox el dl lite core exploits logical
difference el tboxes considered konev et al idea behind decide
whether two ontologies give answers queries given vocabulary called signature
compute succinct representation difference empty typical queries include
subsumption concepts instance queries conjunctive queries setting subsumption queries particular interest nonground support families constructed
ontology ht ai
follows given dl atom dl q x
eliminate tbox td axioms outside dl lite core language obtain simplified
tbox td compute succinct representation logical difference td td
w r sig ad q axioms logical difference fall dl lite core
added td restricting predicates potentially appear support sets avoid
redundant computations approximate relevant part tbox
particularly attractive logical difference el intensively studied e g lutz
walther wolter konev et al polynomial available
el terminologies thus confine latter
present approximation formally first recall notions introduced
konev et al


fic omputing r epairs nconsistent dl p rograms el ntologies

definition concept difference concept difference el terminologies
set cdiff el inclusions
example terminologies b e e r c b
c b c holds cdiff b c

cdiff b r b r
two el terminologies entail concept subsumptions signature e holds
cdiff cdiff called concept inseparable
c
c
denoted c
e g example
logical difference terms instance queries defined follows
definition instance difference instance difference terminologies
set idiff pairs form abox instance
assertion say instance inseparable
symbols idiff idiff
easily seen implies c
converse obvious holds
theorem cf lutz wolter el terminologies signature c

iff
partial support family construction
dl atom set support sets concept inseparable terminologies prior establish following lemma
lemma let dl q dl atom let ht ai el ontology let
c
tbox c
sig sig q p p p

sig ad
armed obtain following equivalence nonground support families
dl atom let el terminologies
proposition let dl q x
c
sig ad q p p p complete nonground
support families w r ht ai ht ai respectively
ground identical
given two el terminologies inclusions c cdiff resp
c cdiff following konev et al called left resp right witnesses denoted
lhs
cwtnrhs
resp cwtn shown every inclusion c concept difference contains left right witness
theorem cf konev et al let el terminologies signature
cdiff c member cdiff sig
concept name c el concepts occurring


fie iter f ink tepanova

partsupfam compute partial support family
ontology ht ai
input dl atom dl q x
output partial nonground support family suppo
sig ad q
b td pp p p p
c td td c c r r
rhs
lhs
lrw cwtn td td cwtn td td


e td td c lrw c r
f complsupf td
return
logical difference two el terminologies compact representation consists
inclusions atomic concept name left right hand side may
inclusions atomic concepts sides role restrictions form r fall
target language dl lite core dl therefore reintroduced
ready describe p artsupf see compute partial
ontology
families support sets input given dl atom dl q x
ht ai el terminology first set signature predicates
relevant support set computation construct tbox td b simplified
version td c removing td axioms form c c complex
concept e axioms dl lite core fragment compute right hand side
left hand side witnesses td td store lrw e
construct tbox td extending td axioms lrw concepts form
r sides inclusions support set construction method dl lite eiter
et al obtain complete support family td f partial support
family
proposition family computed fulfills suppo e partial
support family given dl atom w r
lwr cdiff td td e guaranteed complete proposition general used computing support families dl atoms
accessing arbitrary tboxes practically efficient procedures available acyclic
el terminologies konev et al

bounded support sets
section analyze size number support sets given dl atom
bounds quantities hand one limit search space support sets
precisely aim support set families sufficient evaluating dl atom support
sets properly subsumed another support set e dropped
consider non ground support families subsume particular complete support
family formally
computing logical difference arbitrary tboxes recent feng ludwig walther might
exploited



fic omputing r epairs nconsistent dl p rograms el ntologies

definition complete support family say nonground support family dl atom
complete w r ontology suppo
thus question bounds size support sets cardinality smallest
throughout section tacitly assume tboxes acyclic e entail inclusions form r c c
estimation support set size bounds
first consider estimate maximal size support sets smallest complete support
family analyzing syntactic properties given tbox start recall work
konev et al atomic concept primitive terminology occurs
axiom left hand side pseudo primitive primitive occurs
left hand side axioms c c arbitrary el concept
el terminology every pseudo primitive
r c rm cm atomic conjunct ai exists ai
konev et al lemma obtain
proposition let dl q dl atom let el terminology q
pseudo primitive maxsup
proposition exploits specific case support set size bound providing
liberal syntactic conditions ensure bounded size support sets use ontology hypergraphs nortje et al ecke et al latter widely studied extracting
modules ontologies nortje et al determining concept difference el terminologies ecke et al efficient reasoning owl ql lembo santarelli savo
important tasks
first let us recall notion directed hypergraph natural generalization
directed graph proposed ausiello datri sacc context databases represent functional dependencies
definition directed hypergraph directed hypergraph pair g v e v
set nodes graph e set directed hyperedges form e h h
h h v nonempty sets called hypernodes
given hyperedge e h h call h tail e h head e denoted
tail e head e respectively hypernode singleton h binary hypernode
h abuse notation singleton v simply write v notion
ontology hypergraph dl el introduced ecke et al follows
definition ontology hypergraph let el tbox normal form let c r
ontology hypergraph gt directed hypergraph gt v e
v xa c sig xr r r sig x
e xa xb b
xa xr xy r c
xr xy xa r c
xb xb xa b b


fie iter f ink tepanova

xr

xr

xa

xa

x c

xr

xa

xa

x c

xd

xr

figure hypergraph gt example
example consider following tbox normal form

c c

r c
r c



r

r




ontology hypergraph gt sig depicted figure











define notions directed path two nodes incoming path singleton
node ontology hypergraph natural generalizations path standard graph
definition directed path incoming path suppose el tbox normal form
gt v e ontology hypergraph x v singleton nodes occurring gt
directed path x gt sequence e e en hyper edges
tail e x
ii head en
iii every ei n successor ei ej ei exists gt j head ei
tail ej ei ei implies head ei head ei
incoming path singleton node x v gt v e directed path e en
node v x head en x set incoming paths node x
hypergraph g denoted paths x g
intuitively hyperedges ontology hypergraph gt model inclusion relations complex
concepts consequently incoming path singleton node xc gt chain
inclusions logically follow c rightmost element chain
example let us look ontology hypergraph gt figure sequence edges
xr xa xa xr xa xc


fic omputing r epairs nconsistent dl p rograms el ntologies

x p

xr



xr

xa

xa

x c

xr

xa

xd

xc

xa

x c

xb

xd

xq


gsupp
example


b gsupp
example

figure examples support hypergraphs
incoming path xc gt reflects inclusions r c r r c
sequence
xr xa xa xr xa xc xr xa xc xc xc xd
incoming path singleton xd following set inclusions extracted
c c r c r r r r r

introduce notion support hypergraph dl atom
definition support hypergraph support hypergraph dl atom dl q

constructed follows
normal ontology ht ai hypergraph gsupp
build ontology hypergraph gtd v e sig ad q
leave nodes edges paths xq gtd remove nodes edges
xc gtd c paths xc gtd hyper node n exists p xp
n leave xc otherwise remove corresponding edges
xr gtd r leave e xr xc xc xr exists gtd
xd otherwise remove e
let us illustrate notion support hypergraph following example

example let example accessed dl atom dl p x

td p support hypergraph gsupp sig td shown figure node xd colored blue corresponds dl query edge xd xr xa

lie incoming path xd

gsupp


fie iter f ink tepanova

describing extracting support sets dl atom hypergraph
introduce notion tree acyclicity alternative definitions refer reader works
e g ausiello datri sacc gallo longo pallottino thakur
tripathi
definition tree acyclicity hypergraph g v e called tree acyclic one
directed path exists g singleton nodes x v ii g paths
e ek tail e head ek
refer hypergraphs tree acyclic tree cyclic




b
example gsupp
figure tree acyclic g gsupp



b b neither g gsupp


c

hypergraph gsupp
dl q x c c c b b q
sig given figure b tree cyclic since contains two paths xd xq
namely xd xc xa xa xb xq xd xc xb xa xb xq


support hypergraph gsupp
v e dl atom dl q x contains
incoming paths xq start nodes corresponding predicates ad construction
e reflects inclusions q right hand side predicates ad left
hand side entailed td hence traversing edges incoming paths xq
construct sufficiently many query rewritings q tbox td corresponding nonground
support sets allow subsume every nonground support family w r
support hypergraph given dl atom tree acyclic support sets conveniently constructed annotating nodes variables xi n way described
hx
use subscripts annotations e g xc means node xc annotated
hx x

variable xi xr j states xr annotated ordered pair variables xi xj
proceeds follows start node xq annotate x
hx
e xq traverse hypergraph backwards going head edge tail
every edge e encounter annotate tail e form annotation
head e variable names occur annotation head e fresh variable names xi
n following way
tail e
hx

head e xc tail e annotated hxi
hxi xi

head e xr
hxi

hxi

xc tail e xc annotated hxi e

obtain xc
hxi

tail e head e xc


hx

hx

tail e xc xc xc xc annotated xi e xc xc
hxi xi

tail e xr xc get xr


hxi

xc

fic omputing r epairs nconsistent dl p rograms el ntologies

every annotated hypernode n one create set nonground atoms predicate names
extracted labels hypernodes variable names annotations nonground
support sets dl q x constructed incoming paths xq
pick incoming path xq containing n edges start traversing
edge en head en xq first immediate support set q x next
one extracted annotated tail en taking nonground predicates labels
variables pick edge ek head ek tail en obtain support
sets substituting nonground atoms correspond head ek tail en atoms
extracted tail ek repeated one fact construct incoming path backwards
along support set extraction maximal path obtained

example consider maximal incoming path xd gsupp
figure

xa p xa xr xa xa xr xa xc xr xa xc xc xc xd
z

z

z

z


z

e

e

e

e

e

hx

traversing path backwards e edges order e e e e e obtain xhx
p xa e

z

hx
hx
hx
hx
hx hx
hx
hx
hx
x
x
x
xa xc xhx
xa xc xc xc xd
xhx
xa xa xhx
r
r
r
z

z

z

z




e

e

e



e

nonground support sets extracted resulting annotated path follows

x immediately obtained head xd
first incoming path consider e get c x c x
next path e e head e tail e yielding support set c x
r x x x x
e e get c x r x x x
e e e yields r x x x r x x x
e e e extract r x x r x x x c x
e e e e yields r x x r x x x r x x x
e e e e extract r x x r x x p x c x
finally e e e e e get r x x r x x p x
r x x x

following lemma formally asserts correctness procedure

lemma let sg support family constructed tree acyclic hypergraph g gsupp
sg complete w r e sg every suppo
dl q x

particular lemma holds complete w r ontology ht ai thus
determine sufficiently many nonground support sets looking support hypergraph note restriction tree acyclic tboxes crucial correctness procedure
ensures every node hypergraph annotated
lemma allows us reason structure size support sets analyzing
parameters support hypergraph one parameter instance maximal number
n g hyperedges singleton head node excluding xr xa occurring
incoming path xq hypergraph g


fie iter f ink tepanova

xq

xl

xe
xf

xd

xm

xb

xa

xk
xc


figure support hypergraph gsupp
example

proposition let ht ai el ontology normal form let
dl atom tree acyclic support hypergraph g
dl q x

supp

maxsup maxg

supp


n gsupp




tree cyclic hypergraphs bound tight illustrate next
example consider dl atom x dl q x accessing tbox td


e f l


f
c k
e k

td



b e
l q

support hypergraph depicted figure sig td six hyperedges singleton head nodes maximal support set size x e g
x b x x k x

next define degrees nodes hypergraph
definition hyper outdegree indegree given directed hypergraph g v e
hyper outdegree denoted hd x resp hyper indegree hd x singleton node x v
number hyperedges e e tail e x resp head e x tail e
head e similarly outdegree x resp indegree x x number
edges e e tail e x resp head e x head e tail e


example nodes x v xa p xd hypergraph gsupp
figure hyper

outdegree xap xd hd xap hd xd moreover xap
hyper indegrees hd xa hd xa hd xc hd xc graph

xc xa xd holds hd xc hd xa hd xd
g gsupp
moreover xa




fic omputing r epairs nconsistent dl p rograms el ntologies

let us define
smax x g maxpaths x g n g g

p
g xa hdc xa hdc xa number hyperedges form
xa xb xc


example consider gsupp
figure paths xd gsupp
contains single maximal path xd viz xa p xa xr xa xa xr xa xc xr xa xc
xc xc xd n g four hyperedges singleton head node
g nodes hyper outdegree hence smax xq g
hypergraph figure single maximal incoming path xq n g
g hdc xa hdc xe thus smax xq g


generalize bound maximal support set size proposition
parameter smax xq g node corresponding dl query q dl atom obtain
following hypergraphs possibly tree cyclic
proposition let ht ai el ontology normal form let
dl atom support hypergraph g
dl q x
supp role predi
cates maxsup smax xq gsupp


example tree cyclic hypergraph figure smax xq gsupp
indeed maximal support set size dl q x hypergraph figure

hyperedges every node x v hd x thus smax xq gsupp

coincides maxsup dl p q x


note proposition take computing g outgoing hyperedges
form xc xd xe account c e concepts moreover roles occur
multiple outgoing hyperedges involving roles r r influence support set size
example let support hypergraph dl q x hyperedges xr xc xd
xc xs xm xd xm xq r reflecting axioms r c c
dq largest minimal support set r x c x z c z size
n n number hyperedges singleton head node hd xc
number support sets
orthogonal question considered previous section conditions given
number n support sets sufficient obtain complete support family tightly
related counting minimal solutions abduction analyzed hermann
pichler propositional theories restrictions particular counting minimal explanations shown conp complete general propositional theories
p complete horn propositional theories el subsumes propositional horn logic determining size smallest complete support family least p hard thus intractable
size support sets support hypergraph fruitfully exploited estimating
maximal number support sets given dl atom provide estimate traverse
support hypergraph forward starting leaves label every node xp number
rewritings p conveniently compute labels introduce support weight functions


fie iter f ink tepanova


definition support weight function let gsupp
v e support hypergraph
dl atom support weight function ws v n assigns every node xa v number
ws xa rewritings w r

every node tree acyclic support hypergraph value ws conveniently computed recursive manner

proposition let gsupp
tree acyclic support hypergraph dl atom normalized ontology ht ai ws given follows vc v set nodes
concepts



p
q
ws x x x ws x

p
p

x vc x e ws x

hd x x x
vc
otherwise


x x e

demonstrate usage proposition following examples

example compute ws x nodes gsupp
figure traverse graph
leaves root x xr xa xc xr xa p xr obtain ws x furthermore
ws xa ws xc ws xa ws xc finally ws xd ws xc
ws xc number rewritings x hence support sets
x dl p x identified example

example consider tbox b q c e f b g b h
b l dl atom dl q x whose support hypergraph sig
figure ws xq ws xb ws xa indeed
rewritings q x namely x b x c x b x x b x
e x b x x f x x g x x h x
c x f x c x g x c x h x x f x
x g x x h x e x f x e x g x
e x h x q x
immediate corollary proposition obtain

v e tree acyclic support hypergraph dl atom
corollary let gsupp
el ontology ht ai edge e e satisfies tail e head e
dl q x

x
ws tail e

ws v
ee head e v

thus query node xq get ws xq e fact proposition leads
simple bound size minimal complete support families general cases


fic omputing r epairs nconsistent dl p rograms el ntologies

xc

xd

xe

xf

xa

xg

xh

xb

xq

figure hypergraph gsupp


v e tree acyclic support hypergraph dl atom
proposition let gsupp
el ontology every edge e x z e edges
dl q x
e e e head ei x holds head e head e
sg
e
supp


example hypergraph gsupp
figure single maximal path length
hyperedges satisfy condition corollary support sets e holds

condition proposition e e e violated maximal size minimal complete support family assessed easily instance support hyper
figure contains edges support sets shown k
graph gsupp

nodes gsupp violate condition sg
contains e k support sets
supp

considered example yields bound far tight
note proposition applied tree cyclic support hypergraphs

dl q x
example consider tree cyclic support hypergraph gsupp
c c c b b q sig shown figure b
proposition get ws xd ws xc ws xa ws xb ws xq
however q x rewritings q x x b x
c x x
intuitively tree cyclic hypergraphs support weight function ws may account nonminimal rewritings b x c x x c x x x b x x
rewritings counted multiple times thus general ws x provides upper bound
number rewriting likewise bound proposition tight even simple treecyclic support hypergraphs e g one dl atom dl q x w r tbox bi
bi q n contains n edges n support sets


repair computation partial support families
section present soundransset computing deletion repair answer
sets shown stepanova deciding whether given dl program ht pi
el ontology deletion repair answer set p complete general case
membership part established guessing candidate repair abox along candidate


fie iter f ink tepanova

answer set ht pi suitability guess checked np oracle
clearly efficient n candidate repair aboxes n even finding
answer set would cheap
restrict search space repairs work eiter et al
exploiting support families dl atoms however contrast eiter et al
support families required complete families complete may
known asserted construction soundransset guaranteed complete
otherwise may miss repair answer set easy extension ensures completeness
repair answer set computation shown proceeds follows
start computing family nonground support sets dl atom
next b called replacement program constructed
replacement program obtained simple rewriting gr dl atom
replaced ordinary atom ed called replacement atom disjunctive choice rule
ed ned added informally guesses truth value ed respectively ned
stands value true respectively false repair answer set augmented
proper choice ed resp ned answer set eiter et al proposition thus
search confined answer sets found standard asp
solver
c answer sets computed one one
determine sets dp resp dn dl atoms guessed true resp

instantiates dl atoms
false use function gr

dp dn relevant ground support sets e compatible
e loop minimal hitting sets h support sets dl atoms dn
consist abox assertions f construct h set dp atoms
dp least one support set disjoint h thus removing h
affect values atoms dp

g evaluate postcheck atoms dn dp dp h w r
boolean flag rep stores evaluation function eval n resp eval p specifically given dn resp dp h function eval n resp eval p returns true
atoms dn resp dp evaluate false resp true
h p succeeds h
rep true foundedness check flpfnd


restriction original language output repair answer set
remark many cases foundedness check might trivial superfluous eiter
fink krennwallner redl schller e g loops dl atoms
consider weak answer sets eiter et al entirely skipped
example let dl program example equivalence axioms
weakened assertions project p blacklistedstaffrequest r
added abox moreover assume r dl project projfile staffrequest r
r dl staff chief blacklistedstaffrequest r r p dl hastarget r p


fic omputing r epairs nconsistent dl p rograms el ntologies

soundransset compute deletion repair answer sets
input ht pi
output set repair answer sets
compute set nonground support families dl atoms
b construct replacement program
c

dn ned
sigr


dp ed
gr


e
minimal hitting sets h dn sigr

f
dp dp sigr h
h evalp dp dp
h
g
rep evaln dn
ht h pi output

h
rep flpfnd
end
end

r john dl hassubject r john b following replacement program
constructed



ed r ned r ed r ned r ed r p ned r p









e
r

john

ne
r

john

projfile p


hasowner
p

john










chief john hasowner p john projfile p




grant r ed r deny r










deny r ed r





hasowner p john grant r ed r p ed r john

suppose ed ned ed ed hasowner p john projfile p chief john returned
c following partial support families obtained


sigr hasaction r read hassubject r john action read
staff john hastarget r p projectprojfile p staffrequest r


sigr staffrequest r hassubject r john blacklisted john
blacklistedstaffrequest r


sigr hastarget r p


sigr hassubject r john
e get hitting set h staffrequest r blacklistedstaffrequest r disjoint
thus f obtain dp g check whether
false h true rep false pick different hitting set h e g
blacklisted john blacklistedstaffrequest r proceeding h get g
h true flp check succeeds f interpretation
output
eval n

following state works properly


fie iter f ink tepanova

theorem soundransset sound e given program ht pi every
output deletion repair answer set
know addition support families complete postchecks g
redundant dp dp set rep true otherwise rep false
theorem suppose input program ht pi soundransset
holds dl atom support family computed step soundransset
complete soundransset complete e outputs every deletion repair
answer set
easily turn soundransset complete modifying e consider
hitting sets minimal ones worst case means fallback almost naive
note hitting sets enumerated efficiently relative number
optimizations extensions
repairing databases see work bertossi overview suggests several
techniques potential interest dl programs could exploited optimizing
extending repair localization repairs proposed eiter fink greco
lembo one technique cautiously part data affected inconsistency identified search repairs narrowed part localization
setting ontology abox split safe set facts touched
repair set facts probably affected affected part repaired
combined safe abox part get final solution suitable abox split meta
knowledge ontology e g modules additional domain information used
another common tackling inconsistency proved effective
databases decomposition eiter et al available knowledge decomposed
parts reasons inconsistency identified part separately
respective repairs conveniently merged databases decomposition natural
general unclear inconsistent dl program effectively decomposed one way
determining dl atoms whose replacement atoms guessed true
resp false answer sets given set dl atoms one aim first searching
repair every dl atom desired value extend solution
get final modules dl programs identified dlvhex solver
exploited program decomposition
repairs equally useful certain setting filterings repairs applied get plausible candidates qualitative domain specific aspects repairs
crucial importance practicability formulated terms additional local constraints express instance facts involving certain predicates constants must
preserved resp checked removal furthermore number facts predicates constants allowed deletion bounded filterings incorporated repair
yet several extensions possible conditional predicate dependence example user might willing express condition staffrequest r eliminated
hasaction r read holds data part blacklisted staff members removed
files modifying separate staffrequest issued non blacklisted staff
member


fic omputing r epairs nconsistent dl p rograms el ntologies

p

r supd x

p




r supd x


p

r ned x


pnd
ned x
p

r p


rb p

r sdp

p
p


r sd rb sd nd sda p

ed x
cd supd x

r eval x



r eval x ned x cd

cd supd x

r ed x

figure rules rd declarative implementation
implementation
implemented repair c system prototype dlliteplugin dlvhex
system
discussed support sets el ontologies rich structure thus computation tbox classification work eiter et al insufficient indeed need
identify inclusions atomic concepts inclusions form c b
c arbitrarily complex concept b atomic constructing support sets thus exploit r equiem tool prez urbina et al rewrites target query tbox
datalog rewriting techniques limiting number resp size rewritings partial
support families computed
principle support sets may subsumed smaller support sets e g r c c
c support sets redundant thus eliminate implementation
support families constructed use declarative determining repair
answer sets minimal hitting set computation accomplished rules end
three fresh predicates supd x
ii p
iii p

dl atom x


intuitively say x
xx
support set ii
introduced
support set involving rule predicates iii support set involving abox predicates
possibly rule predicates called mixed support set furthermore every dl atom x rules
rd figure added replacement program
known
rules atom cd informally says support family x
complete information completeness support families certain dl atoms added
declarative program form facts cd rules r r reflect information
potential repair rb stands rule body representing support
support sets x
ppnd

set e rb ak ak nd pp
ppnd
encodes ontology part pp
states assertion
pp
id



pi marked deletion constraint r forbids x guessed false matching
matching
support set consists input assertions r means instead x
mixed support set assertion ontology part must eliminated rule r
guessed true completeness support family unknown matching
says x

support set available evaluation postcheck necessary eval x
rule r similar


x guessed false rule r states dl atom guessed true must support
set support family known complete
set facts f acts pp c p c encoding abox assertions comp
cd sd complete support family added program answer sets


fie iter f ink tepanova


projfile p hasowner p john issued john r





chief john hasowner p john projfile p





deny r ed r



hasowner p john issued john r deny r




ed r ned r





supd x pblacklistedstaffrequest x pblacklistedstaffrequest x




pblacklistedstaffrequest x ned x pblacklistedstaffrequest x
r supd x pstaffrequest x pstaffrequest x phassubject x



phassubject x pblacklisted pblacklisted






p
x
phassubject x pblacklisted ned x pblacklisted
staffrequest




pstaffrequest x





phassubject x





eval
x

e
x

c


sup
x








eval x ned x cd



ed x cd supd x



























































figure program r example
proceed evaluation postcheck atoms
computed answer set
c fact eval c answer set evaluation postchecks succeed
original program
way one identifies
extract repair answer set
weak repair answer sets flp repair answer sets additional minimality check needed
many cases however flp weak answer sets coincide cf eiter et al particular
holds example benchmark programs consider
formally described indeed correctly computes weak repair answer sets
proposition let ho pi ground dl program el ontology let
dl atom sd suppo let rd set rules r r define
r f acts comp

r rd f acts pp c p c comp cd sd complete
w r suppose evaluation postcheck succeeds every dl atom
ras weak moreover cd comp every dl atom
cd comp

ras weak
let us demonstrate usage declarative implementation example
example consider figure replacement program rules r hp oi
example p follows

projfile p hasowner p john issued john r




chief john hasowner p john projfile p
p

deny r dl staff chief blacklistedstaffrequest r



hasowner p john issued john r deny r














fic omputing r epairs nconsistent dl p rograms el ntologies

assume x dl staff chief blacklistedstaffrequest x given
incomplete support family sd blacklistedstaffrequest x
staffrequest x hassubject x blacklisted interpretation ned r
pstaffrequest r pblacklisted john evald among answer sets r facts
post check needed r test succeeds thus
repair answer set
eval


evaluation
repair answer set computation implemented within dlvhex system details
found work stepanova software freely online available dlliteplugin evaluated multi core linux server running dlvhex
htcondor load distribution system htcondor specialized workload management system compute intensive tasks two cores amd se cpus gb
ram
best knowledge similar system repairing inconsistent dl programs exists list systems evaluating dl programs includes dr e w system drew
xiao dlplugin dlvhex system dlplugin dr e w system exploits
datalog rewritings evaluating dl programs el ontologies however handle inconsistencies focus work thus dr e w per se could used baseline
experiments facilitate comparison thus extended dr e w naive repair
technique guess repair abox followed check suitability however
immediate implementation turned infeasible even small instances general
search space repairs ways large full exploitation guided search needed ensure
scalability dlplugin dlvhex system invokes r acer p ro reasoner racerpro
back end evaluating calls ontology however lightweight ontologies even
standard evaluation mode without repair extensions scales worse dlliteplugin eiter
et al b thus focus latter experiments
evaluation workflow
general workflow experimental evaluation follows first step constructed benchmarks building rules constraints top existing ontologies
data parts constructed programs become inconsistent instances generated
shell scripts dl program benchmark generation scripts size conflicting data
part parameter benchmarks run htcondor system times
extracted log files runs run measured time computing first
repair answer set including support set computation timeout seconds
benchmark present experimental tables first column p specifies
size instance varied according certain parameters specific benchmark
parentheses number generated instances e g value first column states
set instances size tested columns represent particular repair
configurations grouped three sets
first set refers settings complete support families exploited
second third refer settings size respectively number computed sup

fie iter f ink tepanova

port sets restricted complete setting addition limit number facts lim f
predicates lim p constants lim c involved facts removed e g lim p
states set removed facts involve two predicates parameter del p stores
predicates deleted e g del p staffrequest means repairs obtained
removing facts staffrequest
restricted configurations column size n resp num n states
computed partial support families size resp number support sets n n
fact support sets computed system aware completeness
exploit partial completeness number size restriction cases e support sets
atom computed number size limits yet reached support family
considered atom complete
entry n total average running time including support set generation
timeouts number timeouts n number found repair answer sets
benchmarks
evaluation developed considered following benchmarks
policy benchmark variant example rule p changed
deny x dl staff chief unauthorizedstaffrequest x two axioms
namely unauthorizedstaffrequest staffrequest hassubject unauthorized
blacklisted unauthorized added
openstreetmap benchmark contains set rules ontology enhanced personalized route semantic information myits ontology extended
abox containing data openstreetmap project osm
lubm benchmark comprises rules top well known lubm ontology lubm
el
describe benchmark details experimental data online available
experimental data
access p olicy c ontrol
considered aboxes n staff members n data set
projects possible actions furthermore staff members unauthorized
blacklisted generating instances used probability p p column
fact hasowner pi si added rules part p si pi staff si project pi
e instances vary facts hasowner pi si p parameter p ranges
etc etc total average running times
settings shown tables sr stands staffrequest experiments
performed aboxes chosen size e demonstrate
works small medium large data
regards limiting complete setting number predicates removal slightly
increases running times restricting repairs removing facts staffrequest
slow repair computation compared unrestricted case many actual
repairs indeed satisfy condition bounded number size support sets


fic omputing r epairs nconsistent dl p rograms el ntologies

p









complete support families
restr
lim p
del p sr

















incomplete support families
size
size
num













num









table policy benchmark
p









complete support families
restr
lim p
del p sr



















incomplete support families
size
num













num









table policy benchmark
p









complete support families
restr
lim p
del p sr




















incomplete support families
size
num













num









table policy benchmark
almost constant except size limited smaller size size shown
support sets exceed bound post evaluation checks often fail visibly impacts
running times support sets large seen
insignificant difference times num num
significantly larger abox get value p considered settings
perform almost identical except lim p bit slower moreover running times increase
gracefully value p bounding support set size produces timeouts thus
column omitted computing support sets size sufficient identify repairs
largest setting complete case finding arbitrary repair faster
restriction lim p p p lim p


fie iter f ink tepanova

p










complete support families
restr
lim f
lim c






























size










incomplete support families
size
num




















num










num










table open street map benchmark

outperform unrestricted setting posed limitation restricts search space repairs effectively removing facts staffrequest longer sufficient witnessed
decreased number identified repairs del p staffrequest compared lim p
time increases rather gracefully p long repair answer sets found
pen treet ap
second benchmark added rules top ontology developed myits project
fixed ontology contains axioms axioms tbox
abox fragment relevant scenario rules p shown figure
intuitively states building features located inside private areas publicly accessible
covered bus stop bus stop roof rules p check public stations lack
public access cwa private areas
used method introduced eiter schneider imkus xiao extract data
openstreetmap repository osm constructed abox extracting
sets bus stops leisure areas irish city cork well islocatedinside
relations e bus stops located leisure areas data gathered
many volunteers chances inaccuracies may high e g imprecise gps data since
data roofed bus stops private areas yet unavailable randomly made
bus stops roofed leisure areas private finally added bsi
islocatedinside bsi laj fact busstop bsi p probability p instances
inconsistent since data set roofed bus stops located inside private areas
shown table complete setting arbitrary repairs computed
seconds faster repairs bounded changes restricted configuration
times vary much except size significant time increase observed
repairs found smaller instances previous benchmark computing small
number support sets often sufficient configuration num expected slightly
slower num computing support sets cheap postchecks take time


fic omputing r epairs nconsistent dl p rograms el ntologies







buildingfeature islocatedinside private nopublicaccess
busstop roofed coveredbusstop




publicstation x dl busstop busstop coveredbusstop x



dl private x
p



dl buildingfeature
publicstation nopublicaccess x



publicstation x









figure dl program openstreetmap ontology
p











restr











complete support families
lim f
lim p











lim c











incomplete support families
size
size











num











table lubm benchmark
lubm
tested dl programs hp oi built el version
lubm ontology whose tbox extended following axioms
graduatestudent assists lecturer ta
graduatestudent teaches undergraduatestudent ta
rules follows


stud x dl employee x dl ta x

p
dl student stud taof x takesexam x
states unless teaching assistant ta known employee student
forbids teaching assistants take exams courses teach
abox contains information one university students teaching
assistants constructed dedicated abox generator lubm data generator pairs
constants c teachingassistantof c facts takesexam c randomly
added rules part probability p thus contradicting part dl program
growing respect p
benchmark provided table bounding complete setting
number removed facts slows computation repairs satisfying condition
exist instances p e inconsistency entrenched facts must
dropped obtain repair moreover often involve constants according


fie iter f ink tepanova

column absence repairs lim f lim c found faster repair
unrestricted mode
limiting support set size allows one repairs instances delay less
seconds compared complete setting however many support sets
benchmark thus bounding number less effective
general discussion
one observe complete settings settings post evaluation checks fast
running times vary slightly growing p due declarative implementation
computing repairs reduced finding answer sets program r facts
comp followed possible evaluation postchecks benchmarks difference
instances size pi pi data part logic program small compared
part facts constant p thus long postchecks needed times
required repairing differ much even though programs become inconsistent
expected complete support families works well practice naturally takes
time compute restricted repairs rather arbitrary repairs however imposed restrictions strong repair satisfy solver may recognize faster
reported hansen et al el tboxes originate real world applications
admit fo rewritings reasonable size almost cases provides evidence realworld el tboxes hardly contain involving constraints conceptual level hence
size number support sets dl atoms often turn limited novel
deletion repair answer set computation demonstrated applicability dl programs
real world data open street map benchmark table
benchmarks run synthetic still vary w r tbox
abox sizes capability handling diverse dl programs confirms
potential

related work
inconsistencies dl programs studied several works phrer et al fink
eiter et al phrer et al proposed inconsistency tolerant semantics keeping
ontology untouched dl atoms introduce inconsistency well rules involving
deactivated repair outlined open issue phrer et al formalized eiter
et al notions repair repair answer sets together naive
computation proposed latter optimized eiter et al
dl lite effectively exploiting complete support families dl atoms
general differs one eiter et al uses partial
necessarily complete support families applied ontologies dl though
possible impact complexity
hybrid formalisms inconsistency management concentrated inconsistency tolerance rather repair instance huang et al presented four valued paraconsistent
semantics belnaps logic belnap hybrid mknf knowledge bases motik
rosati prominent tightly coupled combination rules ontologies
inspired paracoherent stable semantics sakama inoue work huang
et al extended huang hao luo handle incoherent mknf kbs


fic omputing r epairs nconsistent dl p rograms el ntologies

e programs inconsistency arises dependency atom default
negation analogy work fink another direction inconsistency handling
hybrid mknf kbs three valued well founded semantics knorr alferes hitzler avoids incoherence disjunction free stratified programs recently
extended kaminski et al additional truth values evaluate contradictory
pieces knowledge works aim inconsistency tolerance rather repair geared
spirit query answering inherent well founded semantics limited
normal logic programs dl programs allow disjunctive rule heads
context description logics repairing ontologies studied intensively foremost
handle inconsistency dl program repair related abox cleaning masotti rosati
ruzzi rosati ruzzi graziosi masotti however latter differs
respects aims restoring consistency inconsistent ontology deleting minimal sets
assertions e computing maximal deletion repairs deal inconsistency incurred
top consistent ontology arbitrary non monotonic rules access query
interface furthermore must consider multiple aboxes via updates use el instead
dl lite refining compute maximal deletion repairs possible
computing support families tightly related finding solutions abduction
considered bienvenu theories expressed el terminologies
hypothesis h set atomic concepts observation another atomic
concept solution abduction set h ai ai
setting general involves roles along atomic concepts abduction
studied related areas e g dl lite ontologies calvanese ortiz simkus
stefanoni propositional logic eiter makino datalog eiter et al
gottlob pichler wei etc incomplete support families dl atoms
related spirit approximate inconsistency tolerant reasoning dls restricted support
sets considered bienvenu rosati however focus repair computation
model generation bienvenu rosati target inference repairs
methods constructing partial support families exploit logical difference
el terminologies presented konev et al ecke et al recently
extended elhr ludwig walther general tboxes feng et al

repairing inconsistent non monotonic logic programs investigated work
sakama inoue deleting rules extended abduction
studied however restore consistency addition rules possible latter considered
balduccini gelfond occams razor consistency restoring rules may
added methods explaining inconsistency arises logic program studied e g
syrjnen exploited model diagnosis reiter debug logic program generalized debugging logic programs investigated e g gebser phrer schaub
tompits recently schulz satoh toni considered characterization
reasons inconsistency extended logic programs e disjunction free logic programs
strong classical negation weak negation terms culprit sets literals
well founded maximal partial stable model semantics derivation method explain culprits described however remains open debugging logic programs
culprit sets could done whether could fruitfully extended debugging dlprograms latter addressed oetsch phrer tompits related
f



fie iter f ink tepanova

challenging best knowledge unexplored repairing rule part
dl program

conclusion
considered computing repair answer sets dl programs el ontologies
generalized support set eiter et al b dl lite work
incomplete families supports sets advance needed since el complete support families large even infinite discussed generate support sets exploiting query
rewriting ontologies datalog lutz et al rosati stefanoni et al
contrast work eiter et al tbox classification invoked moreover
developed alternative techniques effective computation partial support families
approximate relevant part tbox dl lite core exploiting notion logical
difference el terminologies compute complete support families approximated tbox methods eiter et al obtained support family complete
approximated tbox logically equivalent original one
estimate maximal size support sets analyzed properties novel support hypergraph corresponds subgraph ontology hypergraph nortje et al
ecke et al nodes encode ontology predicates pairs hyper edges
reflect tbox inclusions shown traversing support hypergraph one conveniently
compute upper bound number support sets given dl atom addition
support hypergraph satisfies certain conditions e g tree acyclicity exact estimate
obtained
developed sound computing deletion repair answer sets dl programs
el ontologies complete case support families known complete
trades answer completeness scalability simple variant ensures completeness
implemented novel declarative means within system prototype
invokes r equiem reasoner partial support family computation experimental assessment repair set novel benchmarks constructed including real
world data availability complete support families adds scalability repair
computation partial support families work surprisingly well practice due structure
benchmark instances support sets small thus postevaluation checks cause much overhead overall experimental evaluation revealed
promising potential novel repair methodology practical applications
outlook
directions future work considered area manifold cover theoretical
practical aspects inconsistency handling theoretical side relevant open
issue sufficient conditions computing nonground support sets dl atom
accessing el ontology becomes tractable work gebser et al bounded
tree width might considered parameters density support hypergraph
acyclicity properties analyzing complexity counting support sets complete
support family might give hints possible restricted settings support family computation
efficient complexity analysis interesting practical


fic omputing r epairs nconsistent dl p rograms el ntologies

side optimization current implementation extending range applications real use
cases another issue
repair may intermingled stepping techniques used debugging dl programs oetsch
et al considered dl programs monolithic structures applying repair
techniques repair computation performed dl program taken whole
interesting relevant quest extend dealing modular dl programs
splitting program separate components individually evaluated well known
programming technique studied context dl programs eiter et al
clear however extent program classes repair methods
adapted modular setting
considered el basic applicable
dls extensions work el el easily possible main difference
negation expressible via concept ontology get inconsistent
updates dl atoms leading increased number support sets need effectively
computed appropriately handled extension expressive dls shiq shoin
even sroiq challenging efficient methods support set construction remain
developed relatively high complexity dls comes computational cost
hand computation may done even offline reused fortunately
support families need complete may expect return investment time support
set construction overall running time
orthogonal dls one study additional repair possibilities e g bounded
addition overview repair possibilities see work eiter et al
concentrated repairing data part ontology natural allow changes
rules interfaces repairing rules works asp debugging frhstck phrer
friedrich gebser et al syrjnen used starting point
challenging search space possible changes large priorities rules
atoms involving might applied ensure high quality rule repairs interfaces
similarly admit numerous modifications makes type repair difficult user interaction
probably required
last least one could develop methods repairing hybrid formalisms including
tightly coupled hybrid kbs even general representations hex programs eiter et al
instead ontology arbitrary sources computation accessed logic
program heterogeneity external sources hex programs makes repair paraconsistent
reasoning challenging task

acknowledgments
thank anonymous reviewers detailed constructive suggestions helped
improve work article significantly extends preliminary work eiter fink stepanova
c supported austrian science fund fwf projects p
p


fie iter f ink tepanova

appendix proofs section
proof proposition
proposition iff td ai q ai pp ad p
thus ai support set w r coherent construction
supp coherent form ai
ai ai thus ai td q monotonicity td ai q
hence proposition
proof proposition

consider instance p pk yk set form x
v c support set w r oc ht ac recall ac set

possible abox assertions c e ac ad clearly holds td q x

latter equivalent tdnorm q x
turn lemma equivalent


prog q td norm q x let prog prog q td norm let prog

program prog unfolding rule w r target query q x





prog
q x iff prog q x holds construction rule
thus prog q x

r form prog clearly r q x





follows prog q x hence td norm q x td q x

appendix b proofs section
b proof lemma
towards contradiction assume c
w l g p p p p

p p observe differ predicates pp p p occurs
consists axioms pp p pp occur
first p must hold indeed otherwise p thus p
pp sig ad p p let p c p p c p p c
otherwise e p arbitrary c model ci p
resp ci p ci p ip pp thus p p el negation free pp occurs
axioms left p pp follows p p contradiction
proves p two cases
p c
implies p p monotonicity p p contradiction
ii p p pp p p occurs p claim p p
indeed otherwise model p p easily seen interpretation


coincides pp p p pp pp model
however pp p would contradiction proves claim
claim c
follows p p monotonicity p p
pp p follows p p contradiction
b proof proposition
suppose complete nonground support family w r let instance

ad ac ad lemma c
thus theorem


fic omputing r epairs nconsistent dl p rograms el ntologies

well definition instance inseparability aboxes assertions
holds hence ad q c consequently
ad ground support set w r complete nonground support family
w r follows instance converse membership symmetric
hence ground identical
b proof proposition
towards contradiction assume suppo exists grounding exists
td x however td x according f nonground
support set w r td td lrw consequently td td contradiction
td td construction c lrw c td c td c td
lhs
definition cwtnrhs
cwtn

appendix c proofs section
c proof lemma

w r ontology
construction support sets given hypergraph gsupp
ht ai presented mimics dl query unfolding tbox td formally
set extracted described way indeed nonground support sets
ii ground instance nonground support set nonground support
set constructed following procedure suitable ground
substitution proves sg holds
first prove induction length n incoming paths support sets
extracted

base n consider path hypergraph gsupp
assume single
hyper edge e construction hyperedge must xq head node e head e
xq four possibilities tail e xc tail e xr xc tail e
xc xd tail e xr annotate nodes path variables described
extract nonground atoms labels annotations nodes
case obtain c x r x x c x c x x
r x x x fresh variable construction hypergraph edges
forms correspond tbox axioms c q r c q c q r q
respectively therefore sets constructed considered cases reflect
dl query unfoldings hence represent nonground support sets proposition
induction step suppose statement true n e path n edges sets extracted way described nonground support sets consider path e en
n edges let e e first edge induction hypothesis sets extracted
path e e en following support sets several
possibilities form e tail e xc head e xd tail e xr xc
head e xd tail e xc xd head e xb tail e xr
head e xc tail e xc head e xr xd
construction xc xd annotated xi let family sets
extracted e pick set c xi occurs substitute c xi xi
obtain set induction hypothesis must support set however



fie iter f ink tepanova

clearly support set mimics additional unfolding step accounts rule
c x x datalog rewriting td
let us look assume set xi nonground atoms constructed
procedure xi must annotation xd according construction xr xd
annotated hxi xj hxj xj fresh variable sets get
substituting xi r xi xj c xj latter mimics unfolding step
q accounts rule xi r xi xj c xj rewriting td support
set induction hypothesis must support set well cases
analyzed analogously thus sets size n extracted support sets
remains prove ii towards contradiction assume ground instance
suppo exists ground instance every suppo
constructed procedure support set definition td norm
q c thus lemma prog q tdnorm q c turn means q c
sm
backchaining proof sm prog q td norm form q x
c si si hi bi hi bi
substitution x
rule resp fact prog q td norm general unifier hi atom si
without loss generality hi oa hi r x oa bi
empty end e positions k k sj resp sj j k


amounts instance support set sj resp sj
generated gsupp
particular


sk instance sk consequently hk hk hm instance sk





well means instance sk contradiction
c proof proposition
prove statement induction number n hyperedges singleton head node

g gsupp
dl atom dl q x
base n maxsup hyperedges required form exist g
several cases possible g contains hyperedges form xc xr xd ii g
hyperedges form xr xc xc xr iii g hyperedges
consider hyperedge ej must exist head ei tail ej
latter implies ej form xr xd xd n e contradiction
ii iii construction contains gcis c c atomic
form r axioms fall dl lite core fragment minimal
support sets size moreover reflects dl lite core inconsistency arising
updated ontology eiter et al negation available expressible el
exists thus maximal support set size
induction step suppose statement true n prove n let e ek

maximal number n hyperedges singleton
incoming path xq gsupp
head node assume ei first hyperedge required form occurring let us
split two parts e ei ei ek consider hypergraph g v e
e e e ei tbox reconstructed induction hypothesis
maxsup w r ht ai bounded n let hypergraph g v e
e e ei correspond tbox assumption head ei xa e ei
reflects b c r b two cases possible q q


fic omputing r epairs nconsistent dl p rograms el ntologies

x c n

x cn

x c nk

xcn



xcn






k




xq

figure fragment hypergraph used illustration proof proposition
former case ei single hyperedge e n support sets obtained rewriting q
b c q r b q size support sets constructed combining
query rewritings predicates occurring left hand side gcis reflected ei
rewritings size shown base case thus overall support set size w r
bounded n
suppose q e ei reflects b c r b definition
incoming path hyper edge ej must exist head ei tail ej moreover note ej
unique hyper edge connected ei otherwise given hypergraph tree cyclic e
contradiction distinguish two cases head ei tail ej ej corresponds
head ei tail ej ej reflects b
consider maximal support set w r suppose holds induction

hypothesis n g gsupp
tree acyclic single atom might

occur adding edge ei g obtain support set atom
substituted atoms b c r z b z additional
query unfolding step hence support set size bounded n
ej reflects b support set b must exist unfolding
respective datalog rule get bound n support set w r

c proof sketch proposition
observe tree acyclic hypergraphs nodes hyper degree hence
g thus g tree acyclic proposition support set size given
dl atom bounded n g equals smax claimed bound
correct tree cyclic hypergraphs intuitively g must subtracted n g
avoid certain atoms support set counted multiple times regarding structure
support hypergraph distinguish two cases roles appear hypergraph ii xr g
holds r


fie iter f ink tepanova

first consider since concepts appear support hypergraph assumption support sets contain atoms single variable x occurs consider
node xcn hdc xcn k k e k outgoing hyperedges
xcn containing nodes corresponding concepts xcn xcn xcn xcnk xcn xcn

k
see figure support sets cn x cn k x get support sets
cn x cnk x cn x estimating maximal support set size number hyperedges hypergraph cn x counted k times appears variable
guaranteed x avoid multiple countings g must subtracted n g
consider ii construction g every hypernode xr xc edges e
xa xr xc e xr xc xb exist g thus xr occurs consider
support set b x rewriting tbox axiom reflected e get datalog rule
b x r x c axiom r c reflected e rewritten datalog rules
r x oc x c oc x unifying oc obtain unfolding x
essentially shows role occurring support hypergraph support sets
involve single variable case shown provided bound correct
c proof proposition

proof induction number n hyper edges g gsupp
base n g
hyper edges node one support set
induction step suppose statement holds n holds g n hyper
edges obviously holds x vr g tree acyclic normal form g
node x hd x x e outgoing hyper edges hd x
x e incoming hyper edge g tree acyclic rewriting
set qx x x xa consists qx rewritings sets qtail e
hyper nodes tail e head e x tail e xb resp xb xc xr xc
rewritings b x resp b x c x r x c ws xa
sum number rewritings qtail e denoted qtail e plus consider
arbitrary e head e xa let g g e g n edges tree acyclic
induction hypothesis node x v g value ws x denoted wsg x
furthermore ws qtail e ws x x xa g g thus get x xa

wsg x wsg x ws qtail e
x
wsg x







x

x

x



wsg x

x



wsg x

x x

x

ws x ws qtail e

x

x

ws x ws qtail e



x vc x e

x vc x e

x x





x

x

x

ws x

x vc x e



x x e e e e x obtain
ws qtail e simply need count combinations rewritings node tail e
case tail e xr xb ws xr need add number rewritings
tail hyperedge xr xb normal form must form xc


fic omputing r epairs nconsistent dl p rograms el ntologies

c proof corollary
q
immediate proposition hypothesis form vc
thus x ws x ws e ws tail e rightmost term
c proof sketch proposition
condition e e e every set x equation
q x
contains least one element say x ws x thus x wsg x equals ws

inductive argument obtain every node xa vc
g gsupp
ws xa number distinct edges g occur incoming paths xa
xb vc edge xb xr xa e plus number edges
turn implies query node xq ws xq e holds construction edge e e
among respective edges xq follows immediately

appendix proofs section
proof theorem
get h answer set
suppose supransset outputs
foundedness check w r ontology h succeeded thus
remains compatible set e dl atom dp


iff dn iff towards contradiction suppose case
partitioned dl atoms two sets dp dn corresponding dl atoms guessed

respectively set sigr
since assume
true false
gr
compatible one following must hold

dl atom dn two possibilities

support set sigr ii support sets identified case guaranteed
support sets since otherwise hitting sets h found
e hence must exist support set
according e h
thus suppd rep true h post check must succeeded g

e must hold contradiction case ii likewise post evaluation must
succeeded h raises contradiction




dl atom dp hence sigr dp post evaluation
performed g latter however must succeeded rep true h
contradiction hence compatible set thus deletion repair answer set
proof theorem
following lemmas useful prove theorem
lemma let asx x flp weak ht pi ground dl program
ed dl ned dl answer set
dl set dl atoms occurring
lemma follows general compatible sets basis evaluation
hex programs dlvhex solver cf eiter et al


fie iter f ink tepanova


lemma let ht pi ground dl program let

asx x flp weak suppose dl atom occurring p

holds iff asx ht pi
pxi pxi coincide asx minimal
proof note

model pxi consequently model pxi moreover minimal

j satisfies pxi j pxi hence answer set pxi contradiction

suppose ras x implies asx ht pi
lemma answer set thus considered c dp

dn set correct guess dl atom

proposition completeness obtain dp gr


gr
gr
holds
dn gr



dl atom follows dn sgr means


h hitting set dn sigr hence minimal hitting set h h





considered e f dp set dp dp sigr exists
h hence h thus g call eval p yields true
h thus rep true eventually h
likewise call eval n gr

test flpfnd ht h pi succeed x answer set ht pi
output
lemma ht h pi h thus step h
proof proposition
ras weak towards contradiction
first every holds


suppose exists ras weak every
weak ht pi particular p c pp c

weak ht pi several possibilities
holds
c ii
guess replacement atoms ed ned model
extension

compatible set iii interpretation j
model p

extension
weak

c hence follows
c

case impossible

towards contradiction assume
assume ii true consider interpretation


ned
compatible dl atom





holds case

ed
support set


exists consider whether sd sd former case must
coherent

contain abox assertions sda otherwise constraint form r violated due
rule r least one assertion pid sda must marked deletion note pid
present relevant support set w r sd known complete
immediately arrive contradiction otherwise rule form r applied
evaluation postcheck succeeded assumption get contradiction sd
sd known complete rule form r applied due successful

evaluation postcheck contradiction obtained suppose true
sd known complete
support set exists w r coherent


fic omputing r epairs nconsistent dl p rograms el ntologies

constraint r violated contradicts thus body rule r satisfied
evaluation postcheck issued fails hence get contradiction

model p
finally assume iii holds e interpretation j
weak
j contains atoms signature let us consider im
set



know hence rule ri must exist im b ri
gl

gl

gl


im
recall r f acts comp rgl





p
p

f acts comp igl rgl
iff rgl
weak
weak j pweak construction
must ri however
gl weak reducts contradiction therefore rgl
gl


latter raises contradiction rule rgl atoms signature head im

coincide rule head thus follows b rigl contradiction therefore
holds global contradiction e
ras weak follows


h rgl

consider case support family sd known complete prove
ras weak shown remains check
ras weak towards contradiction assume ras weak exists

every extension ras weak abox exists
ht pi construct extension follows


ed ned

pp c p c f acts comp
supd c c support set sd coherent
p c rb p c p c rb p c nd p c








since assumption one following must hold

r f acts comp igl

ii j exists j r f acts comp igl

satisfies rules forms r r
first assume true construction


moreover constraints form r violated dl atom c c
support set consists input assertions rules r r present

reduct igl cd dl atom c

thus rule r ri could form r r case
gl







form r dl atom c would exist c proposition support set
hence r must
c would exist coherent construction sda p c


form r however c completeness sd proposition construction
implies r violated
supd c

let ii hold e j exists j igl j contains dl atom
c exactly one ed c ned c contains ed c ned c interpretations j
coincide replacement atoms ed c ned c suppose j contains atoms
p hence rule ri p exists
language j
weak
weak
weak
h ri consider respective rule ri j h rj
b ri j
j
gl
gl
gl
weak
weak


fie iter f ink tepanova

construction weak gl reduct respectively positive
must j b rgl






j b r hence replacement atom e
normal atoms b rgl
c resp
weak






ned c must occur positively b rgl ed c j resp ned c j
already argued latter possible leading contradiction

consequently j must contain atoms language r every rule rgl


form r r j b ri iff b ri thus j agree atoms p c

p
sd c



gl

gl



similarly via r r must j agree atoms supd c finally
conclusion
holds pp c pp c rules r construction


j holds violates ii
thus follows consequently ras weak holds proves


references
alchourrn c e grdenfors p makinson logic theory change partial
meet contraction revision functions j symbolic logic
aranguren e bechhofer lord p w sattler u stevens r understanding
meaning statements bio ontology recasting gene ontology owl
bmc bioinformatics
ausiello g datri sacc graph functional dependency manipulation j acm
ausiello g datri sacc minimal representation directed hypergraphs siam
j computing
baader f bauer lippmann runtime verification temporal description
logic proc th intl symp frontiers combining systems frocos pp
baader f brandt lutz c pushing el envelope proc th intl joint conf
artificial intelligence ijcai pp
baader f calvanese mcguinness nardi patel schneider p f eds
description logic handbook theory implementation applications cambridge university press
baader f lutz c milicic sattler u wolter f integrating description logics
action formalisms first proc th national conf artificial intelligence th
conf innovative applications artificial intelligence pp
balduccini gelfond logic programs consistency restoring rules intl
symp logical formalization commonsense reasoning aaai spring symposium series pp
belnap n useful four valued logic modern uses multiple valued logic pp
reidel publishing company boston
bertossi l e database repairing consistent query answering morgan claypool
publishers ottawa canada


fic omputing r epairs nconsistent dl p rograms el ntologies

bertossi l e hunter schaub introduction inconsistency tolerance inconsistency tolerance dagstuhl seminar pp
bienvenu complexity abduction el family lightweight description logics
proc th intl conf principles knowledge representation reasoning kr
pp
bienvenu rosati r inconsistency tolerant semantics robust ontology
data access proc th intl workshop description logics pp
bonatti p faella sauro l el default attributes overriding proceedings th intl semantic web conf iswc pp
brewka g preferred subtheories extended logical framework default reasoning
proc th intl joint conf artificial intelligence ijcai pp
calvanese de giacomo g lembo lenzerini poggi rosati r
ontology database access proc th italian symposium advanced database
systems sebd pp
calvanese de giacomo g lenzerini lembo poggi rosati r b
mastro efficient integration relational data dl ontologies proc th
intl workshop description logics
calvanese ortiz simkus stefanoni g reasoning explanations
negative query answers dl lite j artificial intelligence
console l sapino l dupr role abduction database view updating
j intelligent information systems
console mora j rosati r santarelli v savo f effective computation
maximal sound approximations description logic ontologies proc th intl semantic
web conf iswc part ii pp
dlliteplugin dlvhex system https github com hexhex dlliteplugin
scripts dl program benchmark generation
dlliteplugin benchmarks

https github com hexhex

dlplugin dlvhex system https github com hexhex dlplugin
dr e w reasoner dl programs datalog rewritable description logics http
www kr tuwien ac systems drew
ecke ludwig walther concept difference el terminologies
hypergraphs proc intl workshop document changes modeling detection storage
visualization
eiter erdem e fink senko j updating action domain descriptions proc
th intl joint conf artificial intelligence ijcai pp
eiter fink greco g lembo repair localization query answering
inconsistent databases acm transactions database systems
eiter fink krennwallner redl c schller p efficient hex program
evaluation unfounded sets j artificial intelligence


fie iter f ink tepanova

eiter fink redl c stepanova b exploiting support sets answer set
programs external evaluations proc th conf artificial intelligence aaai
pp
eiter fink stepanova data repair inconsistent dl programs proc rd
intl joint conf artificial intelligence ijcai pp
eiter fink stepanova c computing repairs inconsistent dl programs
el ontologies proc th joint european conf logics artificial intelligence jelia
pp
eiter fink stepanova towards practical deletion repair inconsistent
dl programs proc st european conf artificial intelligence ecai pp
eiter fink stepanova data repair inconsistent dl programs tech rep
infsys rr institut f informationssysteme tu wien vienna austria
eiter gottlob g leone n abduction logic programs semantics complexity theoretical computer science
eiter ianni g lukasiewicz schindlauer r tompits h combining answer
set programming description logics semantic web j artificial intelligence

eiter ianni g schindlauer r tompits h uniform integration higher order
reasoning external evaluations answer set programming proc th intl joint conf
artificial intelligence ijcai pp
eiter makino k computing abductive explanations propositional horn
theory j acm
eiter schneider p imkus xiao g openstreetmap data create benchmarks description logic reasoners proc nd intl workshop owl reasoner evaluation ore vol pp
experimental data inconsistent dl programs http www kr tuwien ac
staff dasha jair el benchmark instances zip
feng ludwig walther logical difference el terminologies
towards tboxes proc st intl workshop sem technologies iwost pp
fink paraconsistent hybrid theories proc th intl conf principles knowledge representation reasoning kr pp
frhstck phrer j friedrich g debugging answer set programs ouroboros extending sealion plugin proc th intl conf logic programming nonmonotonic
reasoning lpnmr pp
gallo g longo g pallottino directed hypergraphs applications discrete
applied mathematics
grdenfors p rott h belief revision handbook logic artificial intelligence
logic programming
gardiner tsarkov horrocks framework automated comparison
description logic reasoners proc th intl semantic web conf iswc pp


fic omputing r epairs nconsistent dl p rograms el ntologies

gebser phrer j schaub tompits h meta programming technique
debugging answer set programs proc rd conf artificial intelligence aaai pp

gelfond lifschitz v classical negation logic programs disjunctive databases
generation computing
gottlob g pichler r wei f efficient datalog abduction bounded treewidth
proc nd intl conf artificial intelligence aaai pp
grau b c horrocks kazakov sattler u right amount extracting
modules ontologies proc th intl conf world wide web www pp

hansen p lutz c seylan wolter f query rewriting el tboxes efficient
proc th intl workshop description logics pp
hermann pichler r counting complexity propositional abduction j computer
system sciences
htcondor load distribution system version http cs wisc edu
htcondor
huang hao j luo incoherency combination description logics
rules j applied mathematics
huang li q hitzler p reasoning inconsistencies hybrid mknf knowledge
bases logic j igpl
kaminski knorr leite j efficient paraconsistent reasoning ontologies
rules proc th intl joint conf artificial intelligence ijcai pp
knorr alferes j j hitzler p coherent well founded model hybrid mknf
knowledge bases proc th european conf artificial intelligence ecai pp

knorr alferes j j hitzler p local closed world reasoning description logics
well founded semantics artificial intelligence
konev b ludwig walther wolter f logical difference lightweight
description logic el j artificial intelligence
kontchakov r lutz c toman wolter f zakharyaschev combined
query answering dl lite proc th intl conf principles knowledge
representation kr pp
kotek simkus veith h zuleger f towards description logic program
analysis extending alcqio reachability proc th intl workshop description
logics pp
lembo lenzerini rosati r ruzzi savo f inconsistency tolerant query
answering ontology data access j web sem
lembo santarelli v savo f graph classifying owl ql
ontologies proc th intl workshop description logics pp
lubm benchmark http swat cse lehigh edu projects lubm


fie iter f ink tepanova

lubm data generator http code google com p combo obda
ludwig walther logical difference elhr terminologies hypergraphs proc st european conf artifical intelligence ecai pp
lukasiewicz novel combination answer set programming description logics
semantic web ieee trans knowledge data engineering
lutz c toman wolter f conjunctive query answering description logic el
relational database system boutilier c ed proc st joint intl conf artificial
intelligence ijcai pp
lutz c walther wolter f conservative extensions expressive description logics
proc th intl joint conf artificial intelligence ijcai pp
lutz c wolter f deciding inseparability conservative extensions description
logic el j symbolic computation
martinez v molinaro c subrahmanian v amgoud l general framework
reasoning inconsistency springer briefs computer science springer
masotti g rosati r ruzzi practical abox cleaning dl lite progress report
proc description logics workshop
motik b rosati r reconciling description logics rules j acm

myits personalized intelligent mobility service http www kr tuwien ac
projects myits geoconceptsmyits v lite owl
nguyen n advanced methods inconsistent knowledge management advanced
information knowledge processing springer
nortje r britz meyer module theoretic properties reachability modules
sriq proc th intl workshop description logics pp
oetsch j phrer j tompits h stepwise debugging description logic programs
j correct reasoning pp
open street map project http www openstreetmap org
zccep l mller r combining dl lite spatial calculi feasible geothematic query answering proc th intl workshop description logics
pan j z thomas e approximating owl dl ontologies proc nd intl conf
artificial intelligence aaai pp
prez urbina h motik b horrocks tractable query answering rewriting
description logic constraints j applied logic
phrer j heymans eiter dealing inconsistency combining ontologies
rules dl programs proc th extended semantic web conf eswc part
pp
r acer p ro reasoner owl ontologies http franz com agraph racer
reiter r theory diagnosis first principles j artificial intelligence


fic omputing r epairs nconsistent dl p rograms el ntologies

rosati r conjunctive query answering el proceedings th intl workshop
description logics
rosati r ruzzi graziosi masotti g evaluation techniques inconsistency handling owl ql ontologies proc th intl semantic web conf iswc
pp
sakama c inoue k paraconsistent stable semantics extended disjunctive programs
j logic computation
sakama c inoue k abductive framework computing knowledge base updates
theory practice logic programming
schulz c satoh k toni f characterising explaining inconsistency logic
programs proc th intl conf lpnmr pp
schulz cornet r spackman k consolidating snomed cts ontological
commitment applied ontology
shen well supported semantics description logic programs proc nd intl
joint conf artificial intelligence ijcai pp
stefanoni g motik b horrocks small datalog query rewritings el proc
th intl workshop description logics
stepanova inconsistencies hybrid knowledge bases phd thesis vienna university
technology
steve g gangemi mori r modelling sharable medical concept system
ontological foundation galen aime pp
stuckenschmidt h parent c spaccapietra eds modular ontologies concepts
theories techniques knowledge modularization vol lecture notes computer science springer
syrjnen debugging inconsistent answer set programs proc th intl workshop
nonmonotonic reasoning nmr pp
thakur tripathi r linear connectivity directed hypergraphs theoretical computer science
tserendorj rudolph krtzsch hitzler p approximate owl reasoning
screech proc nd intl conf web reasoning rule systems rr pp
wache h groot p stuckenschmidt h scalable instance retrieval semantic web
approximation proc st intl workshops web information systems engineering
wise pp
wang j h yuan l shen loop formulas description logic
programs theory practice logic programming
xiao g inline evaluation hybrid knowledge bases ph thesis vienna university
technology austria
zhao pan j z ren implementing evaluating rule
querying regular el ontologies proc th intl conf hybrid intelligent systems
pp




