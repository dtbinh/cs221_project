Journal Artificial Intelligence Research 56 (2016) 89

Submitted 10/15; published 05/16

Optimal Any-Angle Pathfinding Practice
Daniel Harabor

daniel.harabor@nicta.com.au

University Melbourne
National ICT Australia, Victoria Laboratory
115 Batman St, Melbourne, 3003, Australia

Alban Grastien

alban.grastien@nicta.com.au

National ICT Australia, Canberra Laboratory
7 London Circuit, Canberra, 2601, Australia

Dindar Oz

dindar.oz@yasar.edu.tr

Yasar University
Bornova, Izmir, 35100, Turkey

Vural Aksakalli

aksakalli@sehir.edu.tr

Istanbul Sehir University
Altunizade, Istanbul, 34662, Turkey

Abstract
Any-angle pathfinding fundamental problem robotics computer games.
goal find shortest path pair points grid map
path artificially constrained points grid. Prior research focused
approximate online solutions. number exact methods exist require
super-linear space pre-processing time. study, describe Anya: new
optimal any-angle pathfinding algorithm. works find approximate any-angle
paths searching individual points grid, Anya finds optimal paths
searching sets states represented intervals. interval identified on-thefly. interval Anya selects single representative point uses compute
admissible cost estimate entire set. Anya always returns optimal path
one exists. Moreover without offline pre-processing introduction
additional memory overheads. range empirical comparisons show Anya
competitive several recent (sub-optimal) online pre-processing based techniques
order magnitude faster common benchmark algorithm,
grid-based implementation A*.

1. Introduction
Any-angle pathfinding common navigation problem robotics computer games.
takes input pair points uniform two-dimensional grid asks shortest
path artificially constrained points grid. anyangle paths desirable compute typically shorter grid-constrained
counterparts following trajectory give appearance realism
intelligence; e.g. player computer game. Despite apparent simplicity anyc
2016
AI Access Foundation. rights reserved.

fiHarabor, Grastien, Oz & Aksakalli

angle pathfinding surprisingly challenging. far many successful popular methods
proposed, yet involve trade-offs kind. begin
examples highlight, broad strokes, main research trends limitations,
date.
communities Artificial Intelligence Game Development any-angle
pathfinding problem often solved efficiently using technique known string pulling.
idea compute grid-optimal path smooth result; either part
post-processing step (e.g. Pinter, 2001; Botea, Muller, & Schaeffer, 2004) interleaving
string pulling online search (e.g. Ferguson & Stentz, 2005; Nash, Daniel, Koenig, &
Felner, 2007). Regardless particular approach, string pulling techniques suffer
disadvantages: (i) require computation finding path
and; (ii) yield approximately shortest paths.
communities Robotics Computational Geometry related general problem well-studied: finding Euclidean shortest paths polygonal
obstacles plane. Visibility Graphs (Lozano-Perez & Wesley, 1979) Continuous Dijkstra paradigm (Mitchell, Mount, & Papadimitriou, 1987) among best known
influential techniques originate line research. Even though
methods optimal efficient practice nevertheless suffer
often undesirable properties: (i) search graph1 must pre-computed offline
pre-processing step; (ii) map changes point search graph invalidated
must recomputed, usually scratch.
date, clear exists any-angle pathfinding algorithm simultaneously online, optimal practically efficient (i.e. least fast practice
grid-based pathfinding using A* search). manuscript, present new work
answers open question affirmative introducing new any-angle pathfinding
algorithm called Anya. approach bears similarity existing works
literature, notably algorithms based Continuous Dijkstra paradigm.
rough overview:
methods search individual nodes grid, Anya searches
contiguous sets states form intervals.
Anya interval single representative point used derive admissible cost estimate (i.e f -value) points set.
progress search process Anya projects interval, one row grid
onto another, target reached.
Anya always finds optimal any-angle path, one exists. addition Anya
rely pre-computation introduce memory overheads (in form
auxiliary data structures) beyond required maintain open closed list.
theoretical description algorithm previously appeared literature (Harabor
& Grastien, 2013). study extend work several ways: (i) give
1. distinguish search graph input grid map. Though contexts terms
coincide exactly true general. particular search graph may subset input
grid may related entirely separate data structure.

90

fiOptimal Any-Angle Pathfinding Practice

Visible

Visible

Non-visible

2

2

2

1

1

1

0

0
0

1

2

Non-visible

2
1

0
0

1

2

0

1

2

0
0

1

2

Figure 1: Examples visible non-visible pairs points.

detailed conceptual description Anya algorithm provide extended theoretical
argument optimality completeness; (ii) discuss practical considerations
arise implementing algorithm give technical description one possible
efficient implementation; (iii) make detailed empirical comparisons showing
Anya competitive range recent sub-optimal techniques literature,
including based offline pre-processing, one order magnitude better
benchmark grid-based implementation A*; (iv) discuss range possible
extensions improving current results.

2. Optimal Any-Angle Pathfinding Problem
grid planar subdivision consisting W H square cells. cell open set
interior points traversable non-traversable. vertices associated
cell called discrete points grid. Edges grid interpreted
open intervals intermediate points; one representing transition two
discrete points. type point p = (x, y) unique coordinate x [0, W ]
= [0, H], discrete points limited subset integer x values.
discrete intermediate point traversable adjacent least one traversable
cell. Otherwise non-traversable. discrete point common exactly four
adjacent cells called intersection. intersection three adjacent cells
traversable one called corner. Two points visible one another
connected straight-line path (i.e. sequence adjacent points, either
intermediate discrete) not: (i) pass non-traversable point
(ii) pass intersection formed two diagonally-adjacent non-traversable cells.
Figure 1 shows examples help better illustrate idea.
any-angle path sequence points hp1 , . . . , pk pi visible pi1
pi+1 . length cumulative distance every successive
pair points
p
0
0
0
0
d(p1 , p2 )+. . .+d(pk1 , pk ). function d(p = (x, y), p = (x , )) = (x x )2 + (y 0 )2
uniform Euclidean distance metric. say pi turning point segments
(pi1 , pi ) (pi , pi+1 ) form angle equal 180 2 . Finally, any-angle pathfinding
problem one requires input pair discrete points, t, asks anyangle path connecting them. point designates source (equivalently, start) location
2. well-known turning points optimal any-angle paths corner points; e.g. shown
Mitchell et al. (1987).

91

fiHarabor, Grastien, Oz & Aksakalli

point designates target (equivalently, goal) location. path optimal
exists alternative any-angle path strictly shorter.
Figure 2 provides example optimal any-angle pathfinding problem.
seen source, target obstacles discrete positions however path
need follow grid. Notice trajectory path appears much
realistic alternative restricted turning modulo 45 deg 90 deg.
4
3
2
1




0
0
1
2
3
4
5
6
7
8
Figure 2: Example any-angle pathfinding problem together solution.

3. Overview Anya
Consider any-angle instance shown Figure 3. example optimal path
needs first head towards corner point n change direction
toward target t. One possible approach solving problem involves computing
visibility graph: i.e., identifying pairs corners visible one another,
visible start target locations, searching path
graph. main drawback case visibility graph quite large (up
quadratic size grid) expensive compute.
alternative approach, avoids overheads, solve problem online.
Unfortunately online search methods generally consider discrete points grid
immediate neighbours. example, expanding point common
generate neighbours: (1, 0), (2, 1), (3, 0) example
Figure3. A*

f -value
three neighbours is, respectively, 1 + 34 ' 6.83, 1 + 20 ' 5.47,
1 + 26 ' 6.1 (using Euclidean-distance
heuristic). comparison optimal


any-angle path cost 10 + 5 ' 5.4. Immediately see heuristic
hand satisfy one essential properties A* search: f -value
node always underestimate actual distance goal. Without
property A* guaranteed optimal.
issue described comes fact optimal path go
points (1, 0), (2, 1), (3, 0). Instead optimal path crosses row 1 point y1 ,
part search space. ensure optimality consider points
y1 rather discrete points grid. however many
points including e.g., points y10 (leading (3, 6)), apriori seems reasonable
candidate expansion, appear optimal path.
92

fiOptimal Any-Angle Pathfinding Practice

6
5



4
n

3
2

y2

y10

1

y1


0
0

1

2

3

4

5

6

Figure 3: pathfinding n, online algorithms A* Theta*
expand discrete points grid never intermediate points yi .
general need consider potential yi points defined fraction wh
h {0, . . . , H} w {1, . . . , W }. set quadratic n = min(W, H). understand why, consider Farey Sequence order n, sequence (ordered increasing
number) rational numbers 0 1 written fraction whose
denominator integer lower n. instance, Farey Sequence order n = 6
is: 0, 16 , 15 , 14 , 31 , 25 , 21 , 53 , 23 , 43 , 54 , 65 , 1. Notice 13 = 26 , explains length
sequence n(n + 1) 2; still asymptotic cardinality sequence known
2
3n
(Graham, Knuth, & Patashnik, 1989, ch. 9).
2
Since quadratic behaviour Farey Sequence makes impractical enumerate
potential yi points propose consider, instead individual points, set points
appear together part contiguous interval grid. example Figure 3
would consider points lying (0, 1) (3, 1), time
part single A* search node. framework need to:
define formally Anya search node,
define set successors search node,
define compute f -value search node,
prove optimality returned path,
terminate search path available,
ensure Anya algorithm efficient practice.
93

fiHarabor, Grastien, Oz & Aksakalli

4. Algorithm Description
section presents detail Anya algorithm properties. Since Anya
variant A* first present search space: search nodes, successors node
evaluation function used rank nodes search. give pseudo-code
description algorithm discuss properties. Improvements make Anya
efficient practice presented next section.
4.1 Anya Search Nodes
define notion interval, core Anya.
Definition 1 grid interval set contiguous pairwise visible points drawn
discrete row grid. interval defined terms endpoints b.
possible exception b, interval contains intermediate discrete
non-corner points.
definition, points interval share position, positive
integer. Moreover, x position points interval (including endpoints
b) rational number3 . use normal parentheses ( ) indicate
interval endpoint open square brackets [ ] indicate interval endpoint
closed. example, interval = (a, b] open (i.e. include)
closed (i.e. include) b.
Identifying intervals simple: row grid naturally divided maximally contiguous sets traversable non-traversable points. traversable set forms
tentative interval split, repeatedly necessary, corner points
end points intervals. Intervals identified operation called projection. discuss procedure next sub-section. note intervals
produced way projection non-discrete non-corner endpoints.
significant advantage Anya construct intervals on-the-fly. allows
us start answering queries immediately discrete start-target pair. Similar
algorithms, e.g. Continuous Dijkstra (Mitchell et al., 1987), require pre-processing step
queries answered single fixed start point.
Definition 2 search node (I, r) tuple r 6 point called root
interval point p visible r. represent start node itself,
set = [s] assume r located plane visible s; cost r
case zero.
A* search node, together parents, traditionally represents single path
defined travelling straight line points search nodes root
current node. Anya search node similarly defines paths obtained visiting
roots nodes ending interval current node. node therefore
represents many paths root search node always last (common) turning
3. per problem definition, every point (x, y) appearing optimal any-angle path belongs
Farey Sequence points rational.

94

fiOptimal Any-Angle Pathfinding Practice

point paths: always either root parent node one end
points parent interval.
Besides start node, treat special case, two types
search nodes: cone nodes flat nodes. example cone node shown Figure 4.
nodes characterised fact root r row
associated interval I. Notice example although interval = [a, b] maximal,
endpoints obstacles, corners indeed even discrete points
grid (here left endpoint (2.5, 4) right endpoint b (5.5, 4)). Examples
flat nodes shown Figure 5. two nodes are: ((a1 , b1 ], r) ((a2 , b2 ], r). Flat
nodes characterised fact root r row interval I.
Notice examples given a1 = r (resp. a2 = b1 ) excluded first (resp.
second) interval. semantics every search node current position located
somewhere interval reach point any-angle path whose
recent turning point r.
5

5


4

b

4

3

3

2

2

1

r = a1

b1 = a2

b2

1

r

0

0
0

1

2

3

4

5

6

Figure 4: Example cone search node.

0

1

2

3

4

5

6

Figure 5: Example two flat search nodes.

4.2 Searching Anya: Successors
successors search node n identified computing intervals sets traversable
points; row grid current node n rows immediately
adjacent. want guarantee point set reached root
n via local path taut. Taut simply means pull endpoints
path cannot make shorter. provide formal definition successor
discuss definition applied practice.
Definition 3 successor search node (I, r) search node (I 0 , r0 )
1. points p0 0 , exists point p local path hr, p, p0 taut;
2. r0 last common point shared paths hr, p, p0 i;
3. 0 maximal according points definition search node.
95

fiHarabor, Grastien, Oz & Aksakalli

first requirement (tautness) implies successor p0 0 reached
root current node r path locally optimal. use property
next subsection show Anya always finds globally optimal path one exists
all. third property, requiring successor interval maximal,
exists purpose practical efficiency: simply put, want arbitrarily
small arbitrarily many successors. Instead, make successor interval
large possible. second property two interpretations. r0 = r say
successor node observable. Similarly r0 = p say successor
non-observable. explore ideas turn.
5
v1

4

v2

u2

u3

v3
r0



3

=b
u1

2
1

r

0
0

1

2

3

4

5

6

7

Figure 6: Successors cone search node, n = ([a, b], r). five successors: ([v1 , v2 ], r) ((v2 , v3 ], r) observable ((r0 , u1 ], r0 ), ((v3 , u2 ), r0 ),
([u2 , u3 ], r0 ) not.

5
4


3
2

b

c



e

1
0
0

1

2

3

4

5

6

Figure 7: Successors flat search node, n = ((a, b], a). two successors: ((b, c], a)
observable ([d, e], b) not.
96

fiOptimal Any-Angle Pathfinding Practice

Algorithm 1 Computing successor set
1: function successors(n = (I, r))
. Takes input current node
2:
n start node
3:
return generate-start-successors(I = [s])
4:
end
5:
successors
6:
n flat node
7:
p endpoint farthest r
. Successor interval starts p
8:
successors generate-flat-successors(p, r)
. Observable successors
9:
p turning point taut local path beginning r
10:
successors successors generate-cone-successors(p, p, r) . Non-observable successors
11:
end
12:
else
. node flat, must cone
13:
left endpoint
14:
b right endpoint
15:
successors generate-cone-successors(a, b, r)
. Observable successors
16:
turning point taut local path beginning r
17:
successors successors generate-flat-successors(a, r)
. Non-observable
18:
successors successors generate-cone-successors(a, a, r)
. Non-observable
19:
end
20:
b turning point taut local path beginning r
21:
successors successors generate-flat-successors(b, r)
. Non-observable
22:
successors successors generate-cone-successors(b, b, r)
. Non-observable
23:
end
24:
end
25: end function

observable successor characterised fact points p0 0 visible
current root point r. case last common point shared local paths
form hr, p, p0 r. Observable successors computed projecting current interval
next row. projection identifies maximal interval Imax split
internal corner point point. interval produced split operation leads
new observable successor, successors share root point original
(parent) node. process illustrated Figure 6 interval = [a, b] projected
onto next row. projection identifies maximal observable interval Imax = [v1 , v3 ]
subsequently split create two observable successors: ([v1 , v2 ], r) ((v2 , v3 ], r).
comparison, non-observable successor characterised fact points
0
p 0 visible current root r. case local paths form
hr, p, p0 must pass (visibility obstructing) corner point whose identity r0 := p.
Figure 6 illustrates process computing non-observable successors. First,
non-observable points right current interval = [a, b], construct single
flat successor 0 = (b, u1 ] root r0 := b. Non-observable points exist
left current interval local path point (from r a)
taut. non-observable successors found rows grid adjacent
current interval I. projecting corner endpoint b onto next row grid
construct two non-observable successors: ((v3 , u2 ), b) ([u2 , u3 ], b).
Algorithm 1 give overview procedure generates successor set
search node. overview sub-functions appearing Algorithm 1 given
97

fiHarabor, Grastien, Oz & Aksakalli

appendix. implementation straightforward, requiring nothing complicated
grid scanning operations linear projections.
important note stage Anya perform visibility checks
generation successor nodes. Visibility checks heart many contemporary online algorithms, including Theta* (Nash & Koenig, 2013), must determine
whether successor visible node (e.g. grand-parent node).
one hand visibility checks help Theta* et al. find shorter paths expand fewer nodes
traditional A* search. hand, computational overhead introduced
checks means run-times often larger A*. comparison Anya
projects interval I, one row grid next, process involves local
reasoning. particular determine projection Imax valid, invalid
needs clipped simply testing traversability cells located above,
left right current interval proposed Imax . elimination
visibility checks important practical advantage Anya. see Section 9,
Anya finds shorter paths online methods Theta* et al.
usually much efficient terms running time.
illustrate Algorithm 1 using previous examples. Consider flat node ((a, b], a)
Figure 7. point p Line 7 set b observable flat successor ((b, c], a)
generated Line 8. Furthermore since b turning point (Line 9), interval
Imax = [d, e] considered. Since Imax contains interior corner points split
single non-observable cone successor (I = Imax , b) generated (Line 10).
Next, consider cone node ([a, b], r) Figure 6. First generate observable
successors (Line 15): interval [a, b] projected maximal interval Imax = [v1 , v3 ]
identified. Imax split internal corner point v2 leading two observable cone
successor nodes, (I1 = (v1 , v2 ], r) (I2 = (v2 , v3 ], r). Notice line-of-sight visibility
check required here. Next since b turning point look non-observable successors
well (Lines 20-22). flat successor ((b, u1 ], b) generated per previous example.
Meanwhile maximal (non-observable) cone interval Imax = (v3 , u3 ] identified.
interval split internal corner point u2 resulting two non-observable cone
successor nodes, (I3 = (v3 , u2 ], b) (I4 = (u2 , u3 ], b).
Algorithm 1 treats start node (Lines 2-4) special case root point
located grid. successors start node (i) non-observable intervals
root (ii) found left right start location, row
immediately start location row immediately below.
4.3 Evaluating Anya Search Node
search procedure Anya, similarly A*, always expands promising node found far. therefore necessary evaluate root interval pair.
evaluation corresponds estimate f minimal length path
source target current interval. optimality condition A*
estimate optimistic (i.e. never larger actual optimal path length).
classical A* search node n corresponds single point p grid value
f (n) computed sum g(p), length path source p, h(p),
(under)estimation length shortest path p target.
98

fiOptimal Any-Angle Pathfinding Practice

search node n = (I, r) represents set points f value minimum f value
points node:
f (n) = inf f (s, r, p, t)
pI

f (s, r, p, t) (under)estimate shortest path r p.
noted that, set points p continuous potentially open,
minimum replaced infimum. Since points interval visible r,
value broken follows:
f (s, r, p, t) = g(r) + d(r, p) + h(p)
d(r, p) distance points r p.
Finding point interval minimises f value may seem hard problem
since interval contains large number points want avoid generating
them. However straight-line distance heuristic h (h(p) = d(p, t)) makes easy isolate
point p minimises f value, thanks two simple geometric observations.
precise heuristics available could make harder find point p.
Lemma 1 Let r two points s.t. interval row row
rows r t. point p infimal f -value point
closest intersection straight-line path ht, ri row I.
line r intersects interval point p intersection.
Otherwise point p one endpoints interval. event precondition Lemma 1 satisfied, possible replace mirrored version t0
thus satisfy precondition. case described Lemma 2.
Lemma 2 mirrored point t0 target interval d(p, t) = d(p, t0 )
p I.
Lemma 2 trivial geometrical result. lemmas illustrated Figure 8.
4.4 Search Procedure
search procedure employed Anya presented Algorithm 2. follows pattern
A* uses priority queue, open, stores yet-to-be-expanded search nodes
ordered f value. node stores pointer parent. step search
Anya extracts best node open checks corresponding interval contains
target. event target found (Line 6) returned path sequence
root points constructed following back-pointers, current node start
location. target found current node expanded successors
added priority queue (Line 8). successors may considered redundant
safely discarded without insertion priority queue (Line 9). discuss
aspect algorithm Section 6; suffices know successors
optimal path. expansion process continues target found
open list exhausted, case algorithm returns failure (Line 14).
next sections prove fundamental properties algorithm:
correctness, optimality completeness.
99

fiHarabor, Grastien, Oz & Aksakalli

4

t1
t04

t2

3

t3

2



b

1

t4

0
0

1

2

r

3

4

5

6

Figure 8: illustration Lemmas 1 2. evaluate node n = ([a, b], r).
points t1 t04 correspond case row target intersects interval
I; t2 t3 not; t4 mirrored target t04 must used.

5. Correctness Optimality
section prove Anya correct always finds optimal path. particular
show (i) optimal path appears search space, (ii) target
expanded found optimal path, (iii) node search space
reached finite number steps. topics termination completeness
discussed Section 6.
begin analysis recalling search node n = (I, r) represents set potential
paths (from r r point p I). Following semantics say
n search node path r intersects .
Lemma 3 n = (I, r) search node optimal path then: either n contains
target n least one successor n0 search node .
Proof: Start node: n start node = [s] r located grid. Additionally, n search node (hypothesis). Algorithm 1 (Line 3) scans traversable
Algorithm 2 Anya
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:

input: Grid, source location s, target location
open {(I = [s], r0 )}
open empty
(I, r) pop(open)

return path to(I)
end
(I 0 , r0 ) successors(I, r)
prune(I 0 , r0 )
open open {(I 0 , r0 )}
end
end
end
return null

100

. Start node root r0 located grid

. Successor pruning

fiOptimal Any-Angle Pathfinding Practice

points grid visible adjacent s. points located
left right located rows immediately immediately
row s. Algorithm 1 assigns points interval 0 0
associated successor node root r0 = s. Every optimal path must pass
= [s] traversable points reached without
passing interval associated successor s. sufficient satisfy
lemma.
nodes: n arbitrary node 6 (if successors
done). definition r p (apriori unknown) intersection
interval I. two possibilities consider, depending whether
p turning point not. show cases successor n whose
interval 0 intersects , sufficient satisfy lemma.
Case 1 p turning point. Algorithm 1 (Lines 8 15) scans points
adjacent (straight-line) visible r I. point assigned
successor observable interval 0 root point r. Thus least one
successors n intersects every straight line path r p means
least one successor n intersects .
Case 2 p turning point. case p must corner endpoint I, otherwise
taut thus cannot optimal. Algorithm 1 (Lines 10, 17, 18, 21) scans
points adjacent reachable r p taut local path.
points located row p row immediately adjacent.
point assigned successor non-observable interval 0 root
r = p. process exhaustive points reachable taut local path,
r though p, must assigned interval. Thus must intersect least one
successors n.

Corollary 4 path source target, open list always
contains search node optimal path (or node currently processed).
Proof: induction.
base case: initial search node node path s.
inductive case: assume open list contains search node optimal path.
node removed expanded. node contain
target know Lemma one successor generated search node
optimal path. Therefore new search node optimal path inserted
open list.


Lemma 5 first expanded node contains target corresponds one optimal
path t.
101

fiHarabor, Grastien, Oz & Aksakalli

Proof: Sketch. First notice f -value node indeed minimal value
nodes interval, means f estimate () actual cost
target. Second notice that, given search node (I, r) successor (I 0 , r0 ),
point p0 0 , f -value p0 greater equal f -value point
p ( p = r0 r0 6= r; p intersection (r, p0 ) otherwise); f function
therefore monotonically increasing. Finally, f function search node (I, r)
length path I. Hence f function nodes representing sub-optimal
path eventually exceed optimal path distance, f function nodes
representing optimal path always remain value.


Lemma 6 target reachable Anya eventually expand node whose interval
includes target.
Proof: contradiction, assume Anya expand node whose interval includes
target. Lemma 5 know failure expand node means Anya
expand infinitely many nodes. shall prove implies f value
nodes unbounded and, therefore, target reachable.
search nodes (I 0 , r0 ), interval 0 different row parent
(I, r). Therefore, nodes, value g(p0 ) larger value g(p) 1 more.
happen node flat, bounded number
successive flat nodes.4 Hence infinite sequence successive Anya nodes infinite length. Finally Anya node bounded number successors, meaning
infinite number expansions generate infinite number successive nodes.

6. Completeness Termination
specified policy Anya detect nodes
previously expanded. context optimal A* search policy essential
prevent cyclical re-expansion ensure algorithm eventually terminates,
even path start target locations. section describe
policy Anya. Conceptually similar A* closed list approach works
tracking best g-value associated every root location (cf. every search node)
encountered search.
motivating example consider Figure 9 root r reached via two paths
different length. example green path strictly longer red path
points reached via green path g-value strictly larger
point reached via red path. Figure 10 shows similar example green
red paths reach root point r cost, resulting two identical copies
successor node (I, r). Without strategy handle root-level redundancies
search process generate many unnecessary nodes slow progress goal.
Moreover, exists path start target location, search may
4. And, furthermore, value g(p) increase significantly unobservable flat cone.

102

fiOptimal Any-Angle Pathfinding Practice

6

6


5
r

4

3

2

2

1

1

0

r

4

3

0



5



0
1

2

3

4

5

6

0

Figure 9: Root r reached via two paths
different lengths.

1

2

3

4

5

6

Figure 10: Root r reached via two
paths equal length.

terminate (e.g. input graph contains cycles possible endlessly generate
copies states ever increasing g-values).
propose following strategy avoid root-level redundancies:
1. store hash table visited roots best g-values. call table
root history apply similar way (and indeed lieu of) traditional
A* closed list.
2. generating search node n check root already root history
g-value less equal current g-value.
3. current g-value root improves value stored root history
add node open list. update g-cost root5 root
history list.
4. Alternatively, current g-value root improve value stored
root history simply discard node (i.e. added open).
root history implemented hash table. size O(n) n number
discrete points given input map. show keeping root history list
affect correctness optimality search Anya indeed complete
terminate.
Lemma 7 Anya search prunes sub-optimal paths.
5. Similar updates nodes closed list sometimes performed context incremental,
bounded cost bounded sub-optimal search. updates performed part operation called
node re-opening. updates node re-opening. particular root points never
directly expanded thus never appear open list (Anya search comprise root-interval pairs).

103

fiHarabor, Grastien, Oz & Aksakalli

Proof: Trivial. search node root sub-optimal g value, represents
sub-optimal path.


Lemma 8 Anya always terminates.
Proof: Anya terminate, must explore paths arbitrary length. paths
must eventually involve root twice root different in-between. Let
n n0 two search nodes. g value associated n0 must higher
g value associated n and, therefore, node n0 must pruned. Indeed sufficiently
long paths pruned open list eventually empty.


Lemma 9 Anya redundant node pruning keeps least one optimal path.
Proof: search node n = (I, r) removed exists another search node n0 (but
different search parents) smaller (or equal) g-value kept. Assume
n search node optimal path p1 , . . . , pk , let pi point path
intersects I. Since g-value n similar n0 , exists another path

p01 , . . . , p0i , pi+1 , . . . , pk similar length, path pruned.

7. Practical Pruning Strategies
A* orders nodes expansion evaluating ranking promising appear
(i.e. f -values). is, however, possible alter order expansion without
compromising guarantees provided A*: correctness, optimality completeness.
Indeed strategy even positive effect efficiency overall search.
section discuss two practical strategies modify expansion order speed
search. enhancements applied on-the-fly focus reducing size
priority queue. first strategy, Cul-de-sac Pruning, identifies nodes safely
discarded cannot possibly lead goal. second strategy, Intermediate
Pruning, similar works avoiding explicit generation nodes
single successor (these successors expanded immediately, without added
open list).
7.1 Cul-de-sac Pruning
One way reducing size priority queue involves early identification culde-sacs (cds). cds search node successor contain target.
definition cds need added open list since expansion cannot
lead target. simple test identify cds nodes given Algorithm 3 way
procedure Is-cul-de-sac.
Early pruning cds nodes speeds search (and reduces required memory) preventing unnecessary operations open reducing size list,
104

fiOptimal Any-Angle Pathfinding Practice

Algorithm 3 Cul-de-sac intermediate node pruning.
1: function Is-cul-de-sac(n = (I, r))
. Assumes contain target point
2:
Imax projection n
. Flat projection cone projection depending n
3:
Imax valid
. Valid means every p Imax visible r
4:
return f alse
. n cannot cul-de-sac; least one successor interval 0 Imax
5:
end
6:
return true
. n cul-de-sac; cannot projected successors
7: end function
8: function Is-Intermediate(n = (I, r))
. Assumes contain target point
9:
n flat node
10:
p endpoint furthest r
11:
p turning point taut local path prefix hr, pi
12:
return f alse
. n least one non-observable successor; cannot intermediate
13:
end
14:
else
. n flat node must cone node
15:
closed endpoint corner point
16:
return f alse
. n least one non-observable successor; cannot intermediate
17:
end
18:
0 interval projecting r
19:
0 contains corner points
20:
return f alse
. n one observable successors; cannot intermediate
21:
end
22:
end
23:
return true
24: end function

makes every operation faster. reference, open list implemented
binary heap add remove operation time complexity log n, n
size list. Examples cds pruning, cone nodes flat nodes, illustrated
Figure 11 Figure 12. cases current node root shown blue
intervals red pruned.
7.2 Intermediate Pruning
second pruning strategy described pushing expansion one direction
far possible long increase branching factor. Practically, search
node generated guaranteed one successor, immediately
generate successor instead originally intended node. said successor
one successor process recursively applied. Examples showing application
intermediate pruning given Figure 13 cone nodes Figure 14 flat nodes.
simple test identify intermediate nodes given Algorithm 3 way procedure
Is-Intermediate.
first obvious benefit intermediate pruning reduction number operations open list. However second benefit pushing expansion node
lead cul-de-sac. happens node added open list,
helps keep size list small operations list fast.
potential issue Intermediate Pruning recursive application nonpromising successor nodes could costly (in terms time) simply adding
105

fiHarabor, Grastien, Oz & Aksakalli

4

4

3

3

2

2

c


1



e f
b

r



b

c

1
r

0

0
0

1

2

3

4

5

6

0

Figure 11: Cul-de-sacs cone nodes:
nodes ([c, d), r) ((e, f ], r) generated.

2
1

2

3

4

5

6

Figure 12: Cul-de-sac flat nodes: node
((b, c], r) generated.

4
3

1

4
r

3



b

c



2

r



b

c

1

0

0

0
1
2
3
4
5
6
Figure 13: Intermediate node ([a, b], r)
one successor, ([c, d], r), immediately generated.

0
1
2
3
4
5
6
Figure 14: Intermediate node ([a, b], r)
one successor, ((b, c], r) immediately generated.

nodes open. discuss issue detail Section 7.3. note
run-time experiments application Intermediate Pruning net positive effect
performance search.
7.3 Discussion
introduced two different ways nodes frontier search
pruned: Cul-de-sac Pruning Intermediate Pruning. modify expansion order
search improve performance along single fixed path. pruning
away sterile branches skipping intermediate locations actual branching
occurs. Similar strategies previously discussed literature. example Culde-sac Pruning based set principles Dead-end Heuristic (Bjornsson &
Halldorsson, 2006); although method reasons locally applied purely online.
Intermediate Pruning shares similarities Fast Expansion (Sun, Yeoh, Chen, &
106

fiOptimal Any-Angle Pathfinding Practice

Koenig, 2009); main difference prune nodes without reference f -value.
Intermediate Pruning similar Jump Point Search (Harabor & Grastien, 2014)
applied outside context symmetry breaking extended sets points taken
intervals rather applied individual cells grid.
Anyas root history list, discussed Section 6, regarded type pruning
enhancement. case reason generally set possible paths
could used reach given point prune away successors cannot
possibly optimal path. approach taken similar principle
(but practice) pruning redundant states real-time search (Sturtevant &
Bulitko, 2011).
Pruning search nodes Anya difficult classical A* search
many modern progenitors. Anya node represents set positions
rather one. Consider example Figure 15; particularly interested
interval [a, b] generated root r1 r2 . shortest path
r1 ( 14.24 14.99 r2 ). However obstacle put
cell labeled O, optimal path switches r2 ( 15.62 15.94).
diagram suggests that, given target two search nodes sharing
interval, may possible prune either them.
situation described Figure 15 uncommon practice examples
may motivate us derive new sophisticated pruning rules enhance
performance Anya algorithm. must careful however weigh improved
pruning power new techniques overhead applying first
instance. example, alternative (arguably, better) approach avoiding redundant
node expansions keep interval history list addition (or instead of) root history.
method would certainly avoid problem outlined Figure 15 many
possible intervals roots, means size hash table potentially
much larger memory accesses potentially slower. Additionally, comparing intervals
equality membership requires extra time may worth investment6 .

6. attempted similar experiment results clearly positive.

107

fiHarabor, Grastien, Oz & Aksakalli



11
10


9
8
7
6


5

b

r1

4

r2

3
2



1
0
0

1

2

3

4

5

6

7

8

9

10

11

12

13

Figure 15: Illustrating search nodes cannot trivially pruned search nodes
n1 = ([a, b], r1 ) n2 = ([a, b], r2 ): obstacle optimal path
goes n1 (red); otherwise goes n2 (blue).

8. Experimental Setup
conduct experiments seven benchmark problem sets taken Nathan Sturtevants
well known repository (Sturtevant, 2012). Three benchmarks originate popular
computer games often appear literature. are: Baldurs Gate II , Dragon
Age Origins StarCraft. maps benchmarks vary size; several
thousand nodes several million. remaining four benchmarks comprise grids
size 512 512 randomly placed obstacles varying densities, 10% 40%.
Table 1 gives overview benchmark problems. give number maps
instances per problem set distribution number node expansions required
reference algorithm, A* using octile distance heuristic7 , solve problems
benchmark set. latter metric gives us baseline comparing difficulty
problems appearing benchmark set.
7. Octile distance analogous Manhattan distance generalised 8-connected grids.

108

fiOptimal Any-Angle Pathfinding Practice

Benchmark

#Maps

#Instances

Baldurs Gate II
Dragon Age
StarCraft
Random 10%
Random 20%
Random 30%
Random 40%

75
156
75
10
10
10
10

93160
159465
198230
16770
17740
19200
35360

Nodes Expanded A*
Min
Q1 Median Mean
Q3
Max StDev
2
166
2019 6302 9170
86720
9136
1
622
5880 14080 19150 126800 19744
3 4808
26840 50000 70110 578900 63507
2
239
548
1886 1485
59280
3921
3
749
3869 8606 14680
53760
9905
4 3520
14190 20290 33710
96090 19162
3 12520
42850 51920 83770 169900 43558

Table 1: overview seven benchmark problems used experiments. give
number maps problem instances benchmark distribution nodes expanded
reference algorithm (A*) solving problems benchmark set.

compare purely online optimal Anya algorithm number state-ofthe-art any-angle techniques. are: Theta* (Nash et al., 2007), Lazy Theta* (Nash,
Koenig, & Tovey, 2010), Field A* (Uras & Koenig, 2015a) any-angle variant
two-level Subgoal Graphs (SUB-TL) (Uras & Koenig, 2015b). approaches
near-optimal guaranteed return shortest path. methods Theta*, Lazy
Theta* Field A* purely online. SUB-TL relies offline pre-processing
step improve performance search. use C++ implementations
algorithms; source codes made publicly available Uras Koenig (2015a).
Anya implemented Java executed JVM 1.8. allow comparisons across
different implementation languages use A* algorithm (Hart, Nilsson, & Raphael,
1968), implemented C++ Java, reference point8 . compare performance Anya Java implementation A* algorithms
C++ implementation A*. experiments performed 3GHz Intel Core i7
machine 8GB RAM running OSX 10.8.4. Source code implementation
Anya available https://bitbucket.org/dharabor/pathfinding.

9. Results
evaluate performance using three different metrics: search time, nodes expanded
path length. results presented relative benchmark algorithm, A*,
combine standard octile distance heuristic. example, comparing search
time nodes expanded, give figures relative speedup algorithm vs
A*. paradigm search time speedup 2 means twice fast node
expansion speedup 2 means half many nodes expanded. comparing path
length give percent improvement path length vs A*. cases higher better.

8. C++ implementation due Uras Koenig (2015a); Java implementation own.

109

fiHarabor, Grastien, Oz & Aksakalli

Benchmark
Baldurs Gate II
Dragon Age
StarCraft 40%
Random 10%
Random 20%
Random 30%
Random 40%

Avg. Node Expansion Speedup
Anya Theta* L.Theta* F.A* SUB-TL
91.13
1.95
1.96 1.01 907.10
19.60
1.05
1.05 0.90
57.45
40.73
1.27
1.27 0.95 166.00
0.80
2.34
2.38 1.14
6.60
0.77
1.23
1.17 0.80
2.56
1.06
0.82
0.75 0.64
1.68
2.20
0.90
0.86 0.82
2.40

Avg. Path Length Improvement (%)
Anya Theta* L.Theta* F.A* SUB-TL
4.65% 4.62%
4.61% 4.38%
4.58%
4.34% 4.27%
4.22% 4.05%
4.28%
5.02% 4.95%
4.92% 4.70%
4.88%
4.77% 4.63%
4.58% 3.83%
4.59%
4.57% 4.34%
4.15% 3.26%
4.30%
4.44% 4.12%
3.77% 3.12%
4.03%
4.14% 3.95%
3.48% 3.22%
3.74%

Table 2: compare performance algorithm terms average node expansion speedup
average path length improvement. metrics taken respect reference algorithm
(A*). cases higher better.
begin Table 2 shows average performance figures nodes expanded
path length seven benchmark problem sets. make following observations:
Anya best four purely-online algorithms, expanding fewer nodes
five seven benchmarks. three benchmarks drawn real computer
games Anya expands one order fewer nodes, average, nearest purelyonline contemporary. pre-processing-based SUB-TL algorithm expands fewer
nodes, average.
Anya, methods comparison, struggles achieve speedup
four random benchmarks. two four cases performance
reference A* algorithm. Again, pre-processing-based SUB-TL algorithm
able achieve consistent, though much reduced, node expansion speedup.
Anya, optimal, shows best improvement path length; however algorithms comparison close optimal, average.
Next, evaluate performance terms search time. Rather taking simple
average per benchmark basis (or across benchmarks) instead sort instances
according difficulty, measured number node expansions required
reference A* algorithm solve problem. approach gives holistic overview
performance reduces effect bias associated selection instances
comprise benchmark set9 . Results analysis given Figure 16.
make following observations:
Anya often one order magnitude faster reference A* algorithm benchmarks drawn real computer games. Performance mixed
four random benchmarks, evaluated methods struggling achieve
speedup.
9. per Table 1, problem instances regarded easy often outnumber instances
regarded hard. difference effect skewing performance indicators
computed simple averages instances benchmark set.

110

fiOptimal Any-Angle Pathfinding Practice

Benchmarks

Baldur's Gate II
Anya
Theta*
Lazy Theta*
Field A*
SUBTL

Speedup vs A*

100

10

1000

Anya
Theta*
Lazy Theta*
Field A*
SUBTL

100

Speedup vs A*

1000

10

1

1

0.1

0.1
102

103

104
Nodes Expanded A*

105

106

102

103

Dragon Age Origins

104
Nodes Expanded A*

105

106

StarCraft
Anya
Theta*
Lazy Theta*
Field A*
SUBTL

Speedup vs A*

100

10

1000

Anya
Theta*
Lazy Theta*
Field A*
SUBTL

100

Speedup vs A*

1000

10

1

1

0.1

0.1
102

103

104
Nodes Expanded A*

105

106

102

Random; 512x512 10% obstacles

Speedup vs A*

105

106

Random; 512x512 20% obstacles
Anya
Theta*
Lazy Theta*
Field A*
SUBTL

100

104
Nodes Expanded A*

10

1000

Anya
Theta*
Lazy Theta*
Field A*
SUBTL

100

Speedup vs A*

1000

103

10

1

1

0.1

0.1
102

103

104
Nodes Expanded A*

105

106

102

Random; 512x512 30% obstacles

Speedup vs A*

105

106

Random; 512x512 40% obstacles
Anya
Theta*
Lazy Theta*
Field A*
SUBTL

100

104
Nodes Expanded A*

10

1000

Anya
Theta*
Lazy Theta*
Field A*
SUBTL

100

Speedup vs A*

1000

103

10

1

1

0.1

0.1
102

103

104
Nodes Expanded A*

105

106

102

103

104
Nodes Expanded A*

105

106

Figure 16: Search time speedup. compare performance seven benchmarks
terms search time. Figures given relative speedup vs. reference A* algorithm.
Problem instances sorted difficulty using A* node expansion rank. Note
plot log-log.

111

fiHarabor, Grastien, Oz & Aksakalli

Anya fastest four purely online methods evaluation. performance often comparable pre-processing based SUB-TL technique and,
particularly challenging instances StarCraft domain, Anya non-dominated10 .
Anyas performance terms search time less value suggested
(previously evaluated) node expansion metric. reflects fact node
expansion made Anya involves analysing grid; looking roots searching
intervals.
9.1 Discussion
seen Anya compares well current state-of-the-art any-angle pathfinding
algorithms. (almost) apples-to-apples comparison three contemporary purely
online search technique (Theta*, Lazy Theta* Field A*) seen Anya usually
expands fewer nodes per search terminates one order magnitude faster.
results underscored fact Anya online algorithm
guaranteed return Euclidean-optimal path. may surmise that, many cases
applications, Anya appears preferable alternative algorithms.
Next, make apples-to-oranges comparison purely online Anya algorithm near-optimal offline enhanced SUB-TL algorithm. seen
Anya usually fast SUB-TL performance sometimes comparable.
Moreover, Anya retains advantage solving especially challenging instances drawn
real computer games. SUB-TL appears preferable Anya cases additional space time available create store associated subgoal graph cases
overheads amortised many online instances. extra space
time available, cases map subject change (e.g. new obstacles
added existing obstacles removed), Anya appears preferable SUB-TL.
main strength Anya searches sets nodes grid rather
considering individual locations one time. Expansion thus considered
macro operator, meaning Anya bears similarity speedup techniques using
hierarchical abstraction; e.g. HPA* (Botea et al., 2004). important difference
Anya constructs abstract graph on-the-fly rather part pre-processing step.
One current drawback associated Anya nodes contain overlapping
intervals. occurs interval reachable two different root points, neither
pruned (e.g. root locations reached first time;
illustrated Figure 15). nodes are, either part whole, redundant
provided f -value smaller optimal distance goal
beget yet redundant successors. see behaviour especially results
benchmarks Random 10% Random 20% SUB-TL achieves speedup several
factors Anya struggles maintain parity reference A* algorithm. seems
reasonable improve current algorithm attempting identify overlaps order
prune consideration. efficient effective algorithm achieving
goal subject work.
10. Pareto sense; i.e. problem instances Anya better SUB-TL according
metric interest node expansions search time

112

fiOptimal Any-Angle Pathfinding Practice

10. Related Work
Among simplest popular approaches solving any-angle pathfinding
problem string-pulling. main idea find path input grid map, often
using variant A* (Hart et al., 1968), post-process path order
remove unnecessary turning points. Several methods appeared literature
Game Development; e.g. see work Pinter (2001) Botea et al. (2004).
number algorithms improve string-pulling interleaving node expansion
path post-processing online search. Particular examples include Field D* (Ferguson
& Stentz, 2005) Field A* (Uras & Koenig, 2015a), use linear interpolation
smooth grid paths one cell time, Theta* (Nash et al., 2007), introduces
shortcut time successful line-of-sight check made; parent current
node successors. Though still sub-optimal many cases approaches
nevertheless attractive able search purely online efficient
practice. addition two examples given numerous works, often
appearing literature Artificial Intelligence, apply improve basic
interleaving idea. refer interested reader Nash & Koenig, 2013 recent survey
overview.
Accelerated A* (Sislak, Volf, & Pechoucek, 2009) online any-angle algorithm
conjectured optimal strong theoretical argument made. Similar
Theta*, differs primarily line-of-sight checks performed set expanded
nodes rather single ancestor. size set loosely bounded and,
challenging problems, include large proportion nodes closed list.
One recent successful line research involves combination string-pulling
offline pre-processing step. works compelling significantly
improve performance purely online search; terms solution quality
running time. Block A* (Yap, Burch, Holte, & Schaeffer, 2011) one example.
sub-optimal algorithm pre-computes database Euclidean-optimal distances
possible tile configurations certain size (e.g. possible 3x3 blocks). database
obviates need explicit visibility checks indeed type online string-pulling.
pre-processing step needs performed exactly once; database remains valid
tiles map change indeed map changes entirely. Another recent
work improves Theta* combining algorithm pre-processing based graph
abstraction technique (Uras & Koenig, 2015b). approach, referred Section 9
SUB-TL, shown improve running time solution quality Block A*.
main disadvantage (vs. Block A*) abstract graph needs re-computed
repaired time map changes.
Euclidean Shortest Path Problem well known well researched topic
areas Computational Geometry Computer Graphics. seen generalisation Any-angle Pathfinding Problem. asks shortest path plane
impose restrictions obstacle shape obstacle placement (cf. grid aligned
polygons made unit squares).
Visibility graphs (Lozano-Perez & Wesley, 1979) family well-known popular
techniques optimally solving Euclidean Shortest Path Problem. Searching
graphs requires O(n2 log2 n) time approach much faster practice.
113

fiHarabor, Grastien, Oz & Aksakalli

two main disadvantages: (i) computing graph requires offline pre-processing
step O(n2 ) space store; (ii) graph static must recomputed repaired
environment changes. sophisticated variants Tangent Graphs (Liu &
Arimoto, 1992) Silhouette Points (Young, 2001) particularly efficient variants
visibility graphs disadvantages apply.
Another family exact approaches solving Euclidean Shortest Path Problem
based Continuous Dijkstra paradigm (Mitchell et al., 1987). efficient algorithms (Hershberger & Suri, 1999) involves pre-computation requiring O(n log2 n) space O(n log2 n) time. result Shortest Path Map; planar
subdivision environment used find Euclidean shortest path
O(log2 n) time; queries originating fixed source. visibility graphs,
approach introduces additional memory overheads (storing subdivision)
pre-processing step must re-executed time environment start location
changes.

11. Conclusion
study any-angle pathfinding: problem commonly found areas robotics
computer games. problem involves finding shortest path two points grid
asks path artificially constrained fixed points grid.
best known online algorithms any-angle problem, date, compute approximate
solutions rather optimal shortest paths. Additionally online methods
able achieve consistent speedup vs. A* algorithm common reference point
measuring performance literature. work present new online, optimal practically efficient any-angle technique: Anya. works obtain good
performance reasoning grid level method considers sets points
grid taken together contiguous intervals. approach requires revisiting
classical definition search nodes successors requires introduction new
technique computing f -value node. give thorough algorithmic description new search paradigm give theoretical arguments completeness
optimality preserving characteristics.
(almost) apples-to-apples comparison evaluate Anya three contemporary near-optimal online techniques: Theta*, Lazy Theta* Field A*. show
that, range popular benchmarks, Anya faster alternatives,
guaranteeing find optimal shortest path. apples-to-oranges comparison
evaluate Anya SUB-TL: fast pre-processing-based near-optimal any-angle
technique. show Anya non-dominated compared SUB-TL even
maintains advantage particularly challenging instances drawn real computer games. Another advantage that, unlike SUB-TL, Anya assume map
static; i.e. readily applied pathfinding problems involving dynamically changing
terrain.
Any-angle pathfinding received significant attention AI Game Development communities open question whether optimal
online algorithm exists. Anya answers question affirmative.
114

fiOptimal Any-Angle Pathfinding Practice

11.1 Future Work
several possible directions future work. Perhaps obvious development improvements extensions current Anya algorithm. example,
believe empirical performance Anya could enhanced generating successors
nodes contain redundant (or partially redundant) intervals. One possibility
keep closed list previously encountered intervals. stronger variant idea
involves bounding g-value grid intervals generating successor nodes
least one point inside candidate interval relaxed. related orthogonal improvement involves pre-processing grid identifying intervals apriori. enhancement
speed search avoiding entirely grid scanning interval projection operations
currently necessary order generate node.
seen reasoning sets points grid, rather individual
locations, computationally beneficial. believe type search paradigm
employed Anya generalised improve performance grid-optimal search
addition any-angle pathfinding.
final suggestion work, believe Anya might generalised
two-dimensional maps arbitrarily shaped polygonal obstacles, rather grids.
benefit generalisation would avoid discretisation world
path searched for. would even improve quality path returned
optimal any-angle path often non optimal non-discretised version map.

Acknowledgements
thank Tansel Uras assistance source codes used experimental section
paper. thank Adi Botea Patrik Haslum helpful suggestions
early development work.
work Daniel Harabor Alban Grastien supported NICTA. NICTA
funded Australian Government represented Department Broadband,
Communications Digital Economy Australian Research Council
ICT Centre Excellence program.
work Dindar Oz Vural Aksakalli supported Scientific Technological Research Council Turkey (TUBITAK), Grant No. 113M489.

115

fiHarabor, Grastien, Oz & Aksakalli

Appendix A.
provide additional details implementation Anyas successor set generation
algorithm. method depends basic operations technically simple: grid
scanning, traversability tests linear projection operations. attempt reproduce mechanical details operations. Instead focus presentation toward
intuitive understanding overall process.
Algorithm 4 Computing successor set, supplemental.
1: function generate-start-successors(a traversable discrete start location s)
1
2:
Construct maximal half-closed interval Imax
containing points observable left
2
3:
Construct maximal half-closed interval Imax
containing points observable right
3
4:
Construct maximal closed interval Imax
containing points observable row
4
5:
Construct maximal closed interval Imax
containing points observable row
k
6:
intervals Split Imax
corner point take union
7:
Construct intervals new (cone flat) successor node r =
8:
return start successors
9: end function
10: function generate-flat-successors(an interval endpoint p, root point r)
11:
p0 first corner point (else farthest obstacle vertex) row p hr, p, p0 taut
12:
Imax new maximal interval endpoints p (open) p0 (closed)
13:
points r p row
. Observable successors
14:
successors new flat node n = (Imax , r)
15:
else
16:
successors new flat node n = (Imax , p)
. Non-observable flat successors
17:
end
18:
return successors
19: end function
20: function generate-cone-successors(an interval endpoint a, interval endpoint b, root point r)
21:
b r row
. Non-observable successors flat node
22:
r0 b, whichever farthest r
. Previously established turning point
23:
p point adjacent row, reached via right-angle turn
. Obstacle following
24:
Imax maximum closed interval, beginning p entirely observable r0
25:
else == b
. Non-observable successors cone node
26:
r0
27:
p point adjacent row, computed via linear projection r
28:
Imax maximum closed interval, beginning p entirely observable r0
29:
else
. Observable successors cone node
30:
r0 r
31:
p point adjacent row, computed via linear projection r
32:
p0 point adjacent row, computed via linear projection r b
33:
Imax maximum closed interval, endpoints b, entirely observable r0
34:
end
35:
{ split Imax corner point }
36:
n0 new search node interval root point r0
37:
successors successors
38:
end
39:
return successors
40: end function

116

fiOptimal Any-Angle Pathfinding Practice

References
Bjornsson, Y., & Halldorsson, K. (2006). Improved Heuristics Optimal Path-finding
Game Maps. Proceedings Second Artificial Intelligence Interactive
Digital Entertainment Conference, June 20-23, 2006, Marina del Rey, California, pp.
914.
Botea, A., Muller, M., & Schaeffer, J. (2004). Near Optimal Hierarchical Path-Finding.
Journal Game Development, 1 (1), 728.
Ferguson, D., & Stentz, A. (2005). Field D*: Interpolation-based Path Planner
Replanner. Robotics Research: Results 12th International Symposium, ISRR
2005, October 12-15, 2005, San Francisco, CA, USA, pp. 239253.
Graham, R. L., Knuth, D. E., & Patashnik, O. (1989). Concrete Mathematics - Foundation Computer Science. Addison-Wesley.
Harabor, D. D., & Grastien, A. (2013). Optimal Any-Angle Pathfinding Algorithm.
Proceedings Twenty-Third International Conference Automated Planning
Scheduling, ICAPS 2013, Rome, Italy, June 10-14, 2013.
Harabor, D. D., & Grastien, A. (2014). Improving Jump Point Search. Proceedings
Twenty-Fourth International Conference Automated Planning Scheduling,
ICAPS 2014, Portsmouth, New Hampshire, USA, June 21-26, 2014.
Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). Formal Basis Heuristic Determination Minimum Cost Paths. IEEE Transactions Systems Science
Cybernetics, 4 (2), 100107.
Hershberger, J., & Suri, S. (1999). Optimal Algorithm Euclidean Shortest Paths
Plane. SIAM Journal Computing, 28 (6), 22152256.
Liu, Y.-H., & Arimoto, S. (1992). Path Planning Using Tangent Graph Mobile
Robots Among Polygonal Curved Obstacles. International Journal Robotics
Research, 11, 376382.
Lozano-Perez, T., & Wesley, M. A. (1979). Algorithm Planning Collision-Free Paths
Among Polyhedral Obstacles. Communications ACM, 22 (10), 560570.
Mitchell, J. S. B., Mount, D. M., & Papadimitriou, C. H. (1987). Discrete Geodesic
Problem. SIAM Journal Computing, 16 (4), 647668.
Nash, A., Daniel, K., Koenig, S., & Felner, A. (2007). Theta*: Any-Angle Path Planning Grids. Proceedings Twenty-Second AAAI Conference Artificial
Intelligence, July 22-26, 2007, Vancouver, British Columbia, Canada, pp. 11771183.
Nash, A., & Koenig, S. (2013). Any-Angle Path Planning. AI Magazine, 34 (4), 9.
Nash, A., Koenig, S., & Tovey, C. A. (2010). Lazy Theta*: Any-angle Path Planning
Path Length Analysis 3D. Proceedings Twenty-Fourth AAAI Conference
Artificial Intelligence, AAAI 2010, Atlanta, Georgia, USA, July 11-15, 2010.
Pinter, M. (2001). Toward Realistic Pathfinding. Game Developer Magazine, 8 (4).
117

fiHarabor, Grastien, Oz & Aksakalli

Sislak, D., Volf, P., & Pechoucek, M. (2009). Accelerated A* Trajectory Planning: Gridbased Path Planning Comparison. 4th ICAPS Workshop Planning Plan
Execution Real-World Systems.
Sturtevant, N. (2012). Benchmarks Grid-Based Pathfinding. Transactions Computational Intelligence AI Games, 4 (2), 144 148.
Sturtevant, N. R., & Bulitko, V. (2011). Learning Going Whence
Came: h- g-Cost Learning Real-Time Heuristic Search. 22nd International Joint Conference Artificial Intelligence, IJCAI 2011, pp. 365370.
Sun, X., Yeoh, W., Chen, P.-A., & Koenig, S. (2009). Simple Optimization Techniques
A*-based Search. 8th International Joint Conference Autonomous Agents
Multiagent Systems, AAMAS 2009, Budapest, Hungary, May 10-15, 2009, Volume 2,
pp. 931936.
Uras, T., & Koenig, S. (2015a). Empirical Comparison Any-Angle Path-Planning
Algorithms. Proceedings Eighth Annual Symposium Combinatorial Search,
SOCS 2015, 11-13 June 2015, Ein Gedi, Dead Sea, Israel, pp. 206211.
Uras, T., & Koenig, S. (2015b). Speeding-Up Any-Angle Path-Planning Grids.
Proceedings Twenty-Fifth International Conference Automated Planning
Scheduling, ICAPS 2015, Jerusalem, Israel, June 7-11, 2015, pp. 234238.
Yap, P., Burch, N., Holte, R. C., & Schaeffer, J. (2011). Block A*: Database-Driven Search
Applications Any-Angle Path-Planning. Proceedings Twenty-Fifth
AAAI Conference Artificial Intelligence, AAAI 2011, San Francisco, California,
USA, August 7-11, 2011.
Young, T. (2001). Optimizing Points-of-Visibility Pathfinding. Game Programming
Gems 2, pp. 324329. Charles River Media.

118


