Journal Artificial Intelligence Research 56 (2016) 1-59

Submitted 06/15; published 05/16

Query Predicate Emptiness Ontology-Based Data Access
Franz Baader

FRANZ . BAADER @ TU - DRESDEN . DE

TU Dresden, Germany

Meghyn Bienvenu

MEGHYN @ LIRMM . FR

CNRS, Universite de Montpellier
& INRIA, France

Carsten Lutz

CLU @ UNI - BREMEN . DE

University Bremen, Germany

Frank Wolter

WOLTER @ LIVERPOOL . AC . UK

Department Computer Science
University Liverpool, UK

Abstract
ontology-based data access (OBDA), database querying enriched ontology
provides domain knowledge additional vocabulary query formulation. identify query
emptiness predicate emptiness two central reasoning services context. Query emptiness asks whether given query empty answer databases formulated given
vocabulary. Predicate emptiness defined analogously, quantifies universally queries
contain given predicate. paper, determine computational complexity query
emptiness predicate emptiness EL, DL-Lite, ALC-families description logics,
investigate connection ontology modules, perform practical case study evaluate
new reasoning services.

1. Introduction
recent years, paradigm ontology-based data access (OBDA) gained increased popularity. general idea add ontology database querying provide domain knowledge
enrich vocabulary available formulation queries. particularly
useful data queried highly incomplete multiple data sources diverging vocabularies integrated (Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, & Rosati,
2008). OBDA taken particular verve area description logic (DL)
studied intensively lightweight DLs members DL-Lite EL
families, tractable regarding data complexity querying, expressive
DLs ALC SHIQ families querying intractable data complexity. use OBDA former, see example work Calvanese, De Giacomo,
Lembo, Lenzerini, Poggi, Rodriguez-Muro, Rosati (2009), Lutz, Toman, Wolter (2009),
Perez-Urbina, Motik, Horrocks (2009), Chortaras, Trivela, Stamou (2011) Eiter, Ortiz,
Simkus, Tran, Xiao (2012), surveys Krotzsch (2012) Kontchakov, RodriguezMuro, Zakharyaschev (2013); latter, see work Glimm, Lutz, Horrocks, Sattler
(2008), Ortiz, Calvanese, Eiter (2008), Bienvenu, ten Cate, Lutz, Wolter (2014) well
references given work Ortiz Simkus (2012).
c
2016
AI Access Foundation. rights reserved.

fiBAADER , B IENVENU , L UTZ , & W OLTER

OBDA approach fueled availability ontologies aim providing standard
vocabulary targeted application domain. particular, many ontologies
bio-medical domain SNOMED CT (IHTSDO, 2016), NCI (Golbeck, Fragoso, Hartel, Hendler, Oberthaler, & Parsia, 2003), GO (Gene Ontology Consortium, 2016),
formulated DL allow comparably inexpensive adoption OBDA bio-medical applications querying electronic medical records (Patel, Cimino, Dolby, Fokoue, Kalyanpur,
Kershenbaum, Ma, Schonberg, & Srinivas, 2007). Ontologies kind typically
broad coverage vocabulary often contain tens even hundreds thousands predicates
embrace various subject areas anatomy, diseases, medication, even social context
geographic location. given application, small fragment ontologys vocabulary actually occur data. Still, remaining predicates potentially useful
formulating queries linked data vocabulary ontologythis precisely
OBDA enriches vocabulary available query formulation.
Due size complexity involved ontologies vocabularies, however,
difficult understand additional predicates useful query formulation
write meaningful queries extended vocabulary. Static analysis tools analyzing
queries would thus useful. paper, consider fundamental static analysis problem
query emptiness well natural variation called predicate emptiness. former,
problem decide whether given query q provides empty answer databases
formulated given data vocabulary . Query emptiness thus helps identify queries
useless due wrong use ontology vocabulary. standard static analysis problem many
subareas database theory XML, see e.g. work Benedikt, Fan, Geerts (2008)
references therein.
example, consider following simple ontology O:
DiabetesPatient Patient u disease.Diabetes
DiabetesPatientwithoutMedication Patient u disease.Diabetes u
medication for.Diabetes
Assume used support querying medical patient database unary table
concept names Patient Diabetes binary tables role names disease
medication for, distinguishing particular diabetes type 1 type 2. example,
database could given following set assertions:
Patient(a),
disease(a, type1),

Patient(b),

medication for(a, type1),

Diabetes(type1),

disease(b, type2),

Diabetes(type2).

Thus, patient diabetes type 1 medication b patient
diabetes type 2. OBDA, queries interpreted open world assumption thus one
interested certain answers query q w.r.t. A, is, answers q
extension satisfy ontology agreement. concrete query
q1 (x) = DiabetesPatient(x),
b certain answers q1 (x) w.r.t. Adespite fact predicate DiabetesPatient used q1 (x) occur A. Since formulated using data vocabulary
= {Patient, disease, medication for, Diabetes},
2

fiQ UERY P REDICATE E MPTINESS

Q UERY EVALUATION

E MPTINESS

DL

IQ

CQ

IQ-query / CQ-predicate

CQ-query

EL

PT IME-c.

NP-c.

PT IME-c.

PT IME-c

EL

PT IME-c.

NP-c.

E XP IME-c.

E XP IME-c.

ELI

E XP IME-c.

E XP IME-c.

E XP IME-c.

E XP IME-c.

Horn-ALCIF

E XP IME-c.

E XP IME-c.

E XP IME-c.

E XP IME-c.

NL OG PACE-c.

NP-c.

NL OG PACE-c.

coNP-c.

PT IME-c.

NP-c.

coNP-c.

coNP-c.

ALC

E XP IME-c.

E XP IME-c.

NE XP IME-c.

NE XP IME-c.

ALCI

E XP IME-c.

2E XP IME-c.

NE XP IME-c.

2E XP IME-c.

ALCF

E XP IME-c.

E XP IME-c.

undecidable

undecidable

DL-Litecore|F |R
DL-Litehorn

Figure 1: Known complexity results query evaluation new complexity results emptiness

say q1 (x) non-empty given O. regard evidence q1 (x) potentially
useful query databases formulated vocabulary . another example, consider query
q2 (x) = DiabetesPatientwithoutMedication(x)
certain answer q2 (x) w.r.t. since, open world assumption, mere
absence information b medication diabetes type 1 type 2 imply
negation true. One even show that, whatever database A0 formulated vocabulary
use, never certain answer q2 (x) w.r.t. A0 . case, say
q2 (x) empty given O. contrast q1 (x), query thus useless -databases.
consider predicate emptiness, problem decide whether given predicate p
data vocabulary , case queries q involve p yield empty answer
-databases. example above, predicate DiabetesPatientwithoutMedication empty
w.r.t. important class conjunctive queries (queries constructed atomic formulas using conjunction existential quantification). Predicate emptiness used identify
predicates ontology useless query formulation, even starting construct
concrete query. graphical user interface, example, predicates would offered
users query formulation. notion predicate emptiness loosely related predicate
emptiness datalog queries studied e.g. Vardi (1989) Levy (1993).
aim paper perform detailed study query emptiness predicate emptiness
various DLs including members EL, DL-Lite, ALC families, concentrating
two common query languages DL-based OBDA: instance queries (IQs) conjunctive
queries (CQs). resulting combinations DLs query languages, determine
(un)decidability exact computational complexity query emptiness predicate emptiness.
results summarized right side Figure 1 range PT IME basic members
EL DL-Lite families via NE XP IME basic members ALC family undecidable ALC extended functional roles (ALCF). adopt standard notion combined
3

fiBAADER , B IENVENU , L UTZ , & W OLTER

complexity, measured terms size whole input (TBox, data vocabulary,
query predicate symbol).
restricted data vocabulary quantification -databases
definition, query emptiness predicate emptiness reduce standard reasoning problems
query evaluation query containment. Formally, demonstrated undecidability result ALCF, contrasted decidability query entailment
containment DL, shown Calvanese, De Giacomo, Lenzerini (1998). emptiness decidable, complexity still often differs query evaluation. simplify
comparison, display Figure 1 known complexity results query evaluation considered DLs; please consult work Baader, Brandt, Lutz (2005, 2008), Krotzsch, Rudolph,
Hitzler (2007), Eiter, Gottlob, Ortiz, Simkus (2008) results concerning EL
Horn extensions, work Calvanese, De Giacomo, Lembo, Lenzerini, Rosati (2007)
Artale, Calvanese, Kontchakov, Zakharyaschev (2009) results DL-Lite, work
Tobies (2001), Hustadt, Motik, Sattler (2004), Lutz (2008), Ortiz, Simkus, Eiter
(2008) results DLs ALC family. comparing two sides Figure 1,
observe clear relationship complexity emptiness checking
complexity query evaluation. Indeed, problems often similar complexity,
several cases emptiness checking difficult corresponding query evaluation problem. way around, complexities incomparable. Note
extension EL EL bottom concept (used express class disjointness),
observe particularly significant difference tractability evaluating instance queries
E XP IME-completeness checking IQ-query emptiness.
key ingredient developing algorithms establishing upper complexity bounds emptiness show that, searching databases witness non-emptiness (such database
non-emptiness q1 given example), one often focus single
database constructed specifically purpose class databases easier handle
class databases. single database / class databases consider depends
DL question. reason, secondary theme paper analyze shape witness
databases. turns ALC extension ALCI inverse roles, consider
single exponential-size database whose construction reminiscent type elimination filtration
constructions known modal logic literature. EL extension ELI, may
concentrate single witness candidate, much simpler one: consists facts
constructed using data vocabulary single constant. extensions EL,
use class databases witness candidates, namely tree forest structure.
DL-Lite, may restrict attention class databases whose size bounded polynomially
w.r.t. input query ontology.
demonstrate predicate emptiness useful reasoning service static analysis,
perform experiments using well-known large-scale medical ontology SNOMED CT coupled
real-world data vocabulary (corresponding terms obtained analyzing clinical notes
hospital) randomly generated vocabularies. real world vocabulary,
contains 8,858 370,000 concept names 16 62 role names SNOMED CT,
16,212 predicates turned non-empty IQs 17,339 non-empty CQs. Thus,
SNOMED CT provides substantial number additional predicates query formulation
large number predicates cannot meaningfully used queries -databases;
thus, identifying relevant predicates via predicate emptiness potentially helpful.
4

fiQ UERY P REDICATE E MPTINESS

consider use query predicate emptiness extraction modules
ontology. Thus, instead using emptiness directly support query formulation, show
used simplify ontology. -substitute ontology subset ontology
gives certain answers conjunctive queries -databases. Replacing
large ontology (potentially quite small) -substitute supports comprehension ontology
thereby formulation meaningful queries. show that, ELI, one use predicate emptiness extract particularly natural -substitute ontology, called CQ -core,
containing exactly axioms original ontology contain predicates
non-empty -databases. Thus, predicates CQ -core ontology meaningfully used queries posed -databases. example, CQ -core ontology
O0 = {DiabetesPatient Patient u disease.Diabetes}.
second axiom removed CQ contains DiabetesPatientwithoutMedication
empty given O. analyze practical interest CQ -cores, carry case study
compute CQ -cores ontology SNOMED CT coupled various signatures,
showing tend drastically smaller original ontology smaller
-modules, popular way extracting modules ontologies (Grau, Horrocks, Kazakov, &
Sattler, 2008).
article structured follows. begin Section 2 recalling syntax semantics description logics considered work. Section 3, introduce four notions
emptiness (IQ-query, IQ-predicate, CQ-predicate, CQ-query) investigate formal relationships them. first observe IQ-query IQ-predicate emptiness coincide
(so three problems consider) CQ-predicate emptiness corresponds CQquery emptiness CQs restricted simple form. exhibit two polynomial
reductions predicate query emptiness: DLs considered paper except
DL-Lite family, CQ-predicate emptiness polynomially reducible IQ-query emptiness, Horn-DLs considered paper, IQ-query emptiness polynomially reducible
CQ-predicate emptiness.
Section 4, investigate computational complexity decidability query predicate emptiness ALC family expressive DLs. ALC ALCI, provide tight
complexity bounds, showing NE XP IME-completeness three emptiness problems ALC
IQ-query emptiness CQ-predicate emptiness ALCI, 2E XP IME-completeness
CQ-query emptiness ALCI. situation dramatically (and surprisingly) different
ALCF, emptiness problems proven undecidable. previously mentioned,
complexity upper bounds ALC ALCI rely characterization non-emptiness terms
special witness database. complexity lower bounds undecidability results proven
means reductions tiling problems.
Section 5, continue investigation query predicate emptiness considering
DL EL Horn extensions. plain EL, provide simple characterization nonemptiness terms maximal singleton database, allows us show three emptiness
problems decided polynomial time. Using characterization fact
standard reasoning ELI E XP IME-complete, obtain E XP IME-completeness emptiness
checking ELI. extensions EL allow contradictions, singleton database may
consistent ontology, requiring another approach. handle extensions, show
5

fiBAADER , B IENVENU , L UTZ , & W OLTER

sufficient consider tree-shaped databases witnesses non-emptiness, devise
decision procedure emptiness checking based upon tree automata. obtain manner
E XP IME upper bound Horn-ALCIF, sharply contrasts undecidability result
(non-Horn) ALCF. Interestingly, show matching E XP IME lower bound
considerably simpler DL EL , standard reasoning tasks tractable.
Section 6, turn attention DL-Lite family lightweight DLs,
commonly considered DLs ontology-based data access. show CQ-query emptiness
coNP-complete considered DL-Lite dialects. IQ-query emptiness CQ-predicate
emptiness, show complexity depends whether considered dialect allows conjunctions left-hand side axioms. standard dialects DL-Litecore , DL-LiteR ,
DL-LiteF , allow conjunction, show IQ-query emptiness CQ-predicate
emptiness NL OG PACE-complete. dialects DL-Litehorn admits conjunctions,
IQ-query emptiness CQ-predicate emptiness coNP-complete. difference complexity due fact dialects allowing conjunction, need consider witnesses nonemptiness polynomial size, whereas absence conjunction, sufficient
consider databases consist single assertion.
Section 7, apply query predicate emptiness extract modules ontology.
introduce notion -substitute CQ -core ontology show ELI
CQ -core ontology -substitute. relate -substitutes notions module
proposed literature. particular, observe semantic syntactic -modules (Grau
et al., 2008) examples -substitutes, thus, algorithms computing modules
used compute (possibly non-minimal) -substitutes. demonstrate potential
utility -substitutes emptiness checking experiments based SNOMED CT.
Finally, Sections 8 9, conclude paper discussing related future work. Please
note improve readability text, technical proofs deferred appendix.

2. Preliminaries
DLs, concepts inductively defined help set constructors, starting countably infinite sets NC concept names NR role names. constructors important paper summarized Figure 2. inverse role form r r role name
role role name inverse role. uniformity, define double inverse identity,
is, (r ) := r role names r. Throughout paper, use A, B denote concept
names, C, denote (possibly compound) concepts, r denote roles.
shall concerned variety different DLs well-known literature.
least expressive ones EL DL-Lite, logical underpinnings OWL2
profiles OWL2 EL OWL2 QL, respectively (Motik, Grau, Horrocks, Wu, Fokoue, & Lutz,
2009). EL, concepts constructed according following grammar using constructors
top concept, conjunction, existential restriction:
C,

::=

>

|



| C uD

|

r.C

ranging concept names r role names. DL-Lite concepts TBoxes
introduced Section 6. basic expressive DL consider paper ALC
extension EL constructors bottom concept, negation, disjunction value restriction:
C,

::=

>

|



|

| C uD
6

|

C tD

|

r.C

|

r.C

fiQ UERY P REDICATE E MPTINESS

Name

Syntax

concept name
role name


r

Semantics
AI
rI

top concept
bottom concept
negation
conjunction
disjunction
existential restriction
value restriction
role inverse

>

C
C uD
C tD
r.C
r.C
r

>I =
=
\ C
C DI
C DI
{d | e C (d, e) rI }
{d | e : (d, e) rI e C }
{(d, e) | (e, d) rI }

concept inclusion
concept assertion
role assertion

CvD
A(a)
r(a, b)

C DI
aI AI
(aI , bI ) rI

Figure 2: Syntax semantics DL constructors, TBox axioms, ABox assertions.

availability additional constructors indicated concatenation letters subscripts:
letter stands addition inverse roles (inside existential value restrictions, present)
subscript stands adding . gives, example, extension ALCI ALC
inverse roles, whose constructors exactly ones shown Figure 2. defines
extension ELI EL inverse roles existential restrictions bottom concept.
concept inclusion (CI) DL L takes form C v D, C L-concepts.
use C abbreviation CIs C v v C. description logic, ontologies
formalized TBoxes. Given DLs L introduced above, L-TBox finite set
CIs L. use letter F write LF denote description logic TBoxes consist
CIs L, functionality statements funct(r), r role name
inverse role (if inverse roles admitted L). example, ALCF thus extension ALC
TBoxes contain CIs ALC functionality statements role names. use
term axioms refer concept inclusions functionality statements uniform way.
addition DLs introduced above, consider DLs impose restrictions
constructors used side concept inclusions. Horn-ALCI concept
inclusion (CI) form L v R, L R concepts defined syntax rules
R, R0 ::= > | | | | R u R0 | L R | r.R | r.R
L, L0 ::= > | | | L u L0 | L L0 | r.L
ranging concept names r (potentially inverse) roles. Horn-ALCIF-TBox
finite set Horn-ALCI CIs functionality statements funct(r). Note different
definitions Horn-DLs found work Hustadt, Motik, Sattler (2007), Eiter et al.
(2008), Kazakov (2009). original definition Hustadt, Motik, Sattler based
polarity rather technical, prefer (equivalent) definition.
size |T | TBox obtained taking sum lengths axioms,
length axiom number symbols needed write word.
7

fiBAADER , B IENVENU , L UTZ , & W OLTER

Databases represented using ABox, finite set concept assertions A(a)
role assertions r(a, b), a, b drawn countably infinite set NI individual names,
concept name, r role name. Note role assertions cannot use inverse roles.
shortcut, though, sometimes write r (a, b) r(b, a) A. use Ind(A) denote
set individual names used ABox A. knowledge base pair K = (T , A)
TBox ABox.
semantics description logics defined terms interpretation = (I , ).
domain non-empty set interpretation function maps concept name NC
subset AI , role name r NR binary relation rI , individual
name element aI . extension compound concepts inductively defined
shown third column Figure 2. interpretation satisfies (i) CI C v C DI ,
statement funct(r) rI functional, (iii) assertion A(a) aI AI , (vi) assertion
r(a, b) (aI , bI ) rI . Then, model TBox satisfies axioms , model
ABox satisfies assertions A. TBox satisfiable model ABox
satisfiable w.r.t. TBox common model. write |= C v
models satisfy CI C v D.
consider two types queries. First, instance queries (IQs) take form A(v),
concept name v individual variable taken set NV . Note instance queries
used query concept names, role names. traditional definition, due
fact role assertions implied ABox explicitly contained it,
thus querying trivial.1 general conjunctive queries (CQs) take form ~u (~v , ~u)
conjunction atoms form A(v) r(v, v 0 ) v, v 0 individual variables
~v ~u NV . Variables existentially quantified called answer variables,
arity q defined number answer variables. Queries arity 0 called Boolean.
use var(q), avar(q), qvar(q) denote set variables, answer variables, quantified
variables respectively query q. on, use IQ refer set IQs CQ
refer set CQs.
Let interpretation q (instance conjunctive) query q arity k answer
variables v1 , . . . , vk . match q mapping : var(q) (v) AI
A(v) q, ((v), (v 0 )) rI r(v, v 0 ) q, every answer variable v var(q),
individual name (v) = aI . write |= q[a1 , . . . , ak ] match
q (vi ) = aIi every 1 k. knowledge base (T , A), write
, |= q[a1 , . . . , ak ] |= q[a1 , . . . , ak ] models A. case, (a1 , . . . , ak )
certain answer q w.r.t. A. use certT ,A (q) denote set certain answers
q w.r.t. A. Note q Boolean query, () certT ,A (q)
match q every model , A, otherwise certT ,A (q) = . query evaluation problem
CQs DL L problem decide L-TBox , ABox A, CQ q arity k, tuple
~a Ind(A)k , whether ~a certT ,A (q).
use term predicate refer concept name role name signature refer
set predicates (in introduction, informally called signature vocabulary). sig(q)
denotes set predicates used query q, similarly sig(T ) sig(A) refer
signature TBox ABox A. -ABox ABox uses predicates
signature , likewise -concept.
1. longer true presence role hierarchy statements which, however, consider paper.

8

fiQ UERY P REDICATE E MPTINESS

context query answering DLs, sometimes useful adopt unique name
assumption (UNA), requires aI 6= bI interpretations a, b NI
6= b. results obtained paper depend UNA. following well-known
lemma shows UNA make difference ALCI (and fragments EL
ALC) certain answers queries change.
Lemma 1 Let ALCI-TBox, ABox, q CQ. certT ,A (q) identical
without UNA.
analogous statement fails ALCF, e.g. ABox = {f (a, b), f (a, b0 )} satisfiable w.r.t. TBox = {funct(r)} without UNA (and thus certT ,A (A(v)) = ),
unsatisfiable UNA (and thus certT ,A (A(v)) = Ind(A)).

3. Query Predicate Emptiness
introduce central notions reasoning problems studied paper, show
interrelated, make basic observations used throughout paper. following
definition introduces different notions emptiness studied paper.
Definition 2 Let TBox, signature, Q {IQ, CQ} query language. call
Q-query q empty given -ABoxes satisfiable w.r.t. ,
certT ,A (q) = .
predicate Q-empty given every Q-query q sig(q) empty
given .
follows, signatures used ABoxes called ABox signatures. quantify
ABoxes formulated ABox signature address typical database applications
data changes frequently, thus deciding emptiness based concrete ABox
much interest. example, assume ABoxes formulated signature
= {Person, hasDisease, DiseaseA, DiseaseB}
following, upper-case words concept names lower-case ones
role names. signature typically fixed application design phase, similar schema
design databases. TBox, take
= {Person v hasFather.(Person u Male), DiseaseA v InfectiousDisease}.
IQ InfectiousDisease(v) CQ v hasFather(u, v) non-empty given
despite using predicates cannot occur data, witnessed -ABoxes {DiseaseA(a)}
{Person(a)}, respectively. illustrates TBox enriches vocabulary
available query formulation. contrast, CQ
vv 0 (hasFather(u, v) hasDisease(v, v 0 ) InfectiousDisease(v 0 )),
uses predicates plus additional one ABox signature, empty
given .
9

fiBAADER , B IENVENU , L UTZ , & W OLTER

Regarding predicate emptiness, interesting observe choice query language
important. example, predicate Male IQ-empty given , CQ-empty
witnessed -ABox {Person(a)} CQ v Male(v). thus makes sense use Male
instance queries -ABoxes given , whereas meaningfully used conjunctive
queries.
every IQ CQ, predicate CQ-empty must IQ-empty. illustrated
example, converse hold. note role names IQ-empty
given since role name cannot occur instance query. contrast, hasFather clearly
CQ-empty example.
follows Lemma 1 that, ALCI fragments, query emptiness predicate emptiness oblivious whether UNA made, IQ CQ. established
following lemma, true ALCIF despite fact certain answers queries
differ without UNA.
Lemma 3 Let ALCIF-TBox. CQ q empty given UNA iff
empty given without UNA.
proof Lemma 3 given appendix. direction left right one assumes
q non-empty given without UNA takes witness -ABox A. Using model
satisfying without UNA identifying a, b Ind(A) aI = bI one
define -ABox A0 shows q non-empty given UNA.
Conversely, one assumes q non-empty given UNA takes witness
-ABox A. One use show q non-empty given without UNA.
exception DL-Lite dialect (containing role inclusions) DLs considered
paper fragments ALCIF. Thus, free adopt UNA not. remainder
paper, choose whatever convenient, careful always point explicitly
whether UNA made not. DL-Lite dialect covered formulation Lemma 3
observe discussion DL-Lite even Lemma 1 holds free adopt
UNA case well.
relevant note decision disallow individual names query atoms without
loss generality. Indeed, easily verified predicate emptiness whether
admit individuals queries not. Moreover, immediate reduction query emptiness
generalized CQs (which may contain individual names) query emptiness CQs defined
paper: suffices replace every individual query fresh answer variable xa ,
test whether resulting query (without individuals) empty given .
Definition 2 gives rise four natural decision problems.
Definition 4 Let Q {IQ, CQ}.
Q-query emptiness problem deciding, given TBox , signature , Qquery q, whether q empty given ;
Q-predicate emptiness means decide, given TBox , signature , predicate S,
whether Q-empty given .
10

fiQ UERY P REDICATE E MPTINESS

IQ-query = IQ-predicate
emptiness
emptiness
Trivial

CQ-query
emptiness

Theorem 7
(materializable DLs)

Lemma 5

Theorem 6

CQ-predicate
emptiness

Figure 3: Polytime reductions emptiness notions.
Clearly, four problems intimately related. particular, IQ-query emptiness IQpredicate emptiness effectively problem since instance query consists
single predicate. reason, disregard IQ-predicate emptiness
speak IQ-query emptiness. CQ case, things different. Indeed, following lemma
shows CQ-predicate emptiness corresponds CQ-query emptiness CQs restricted
simple form. easy consequence fact that, since composite concepts queries
disallowed, CQs purely positive, existential, conjunctive.
Lemma 5 NC (resp. r NR ) CQ-predicate empty given iff conjunctive query
v A(v) (resp. vv 0 r(v, v 0 )) empty given .
Lemma 5 allows us consider queries form v A(v) vv 0 r(v, v 0 ) dealing
CQ-predicate emptiness. on, without notice.
Trivially, IQ-query emptiness special case CQ-query emptiness. following observation less obvious applies DLs considered paper except DL-Lite
family.
Theorem 6 DL contained ALCIF admits CIs r.B v B r.> v B B
concept name, CQ-predicate emptiness polynomially reduced IQ-query emptiness.
Proof. Let TBox, signature, B concept name occur ,
role name occur . prove
1. CQ-predicate empty given iff IQ B(v) empty {s} given TBox
0 = TB {A v B}, TB = {r.B v B | r = r occurs };
2. r CQ-predicate empty given iff IQ B(v) empty {s} given TBox
0 = TB {r.> v B}, TB above.
proofs Points 1 2 similar, concentrate Point 1. First suppose CQpredicate non-empty given . -ABox , |= v A(v). Choose
a0 Ind(A) set A0 := {s(a0 , b) | b Ind(A)}. Using fact , |= v A(v)
definition A0 0 , shown 0 , A0 |= B(a0 ). converse direction,
suppose B IQ-query non-empty {s} given 0 . {s}-ABox A0
0 , A0 |= B(a) Ind(A0 ). Let obtained A0 removing assertions
s(a, b). Using fact 0 , A0 |= B(a) definition A0 0 , shown
, |= v A(v).


11

fiBAADER , B IENVENU , L UTZ , & W OLTER

Figure 3 gives overview available polytime reductions four (rather: three)
problems. terms computational complexity, CQ-query emptiness thus (potentially) hardest problem, CQ-predicate emptiness simplest. precisely, CQ-query emptiness
DL L belongs complexity class C (larger equal PT IME), IQ-query emptiness
CQ-predicate emptiness L C. Moreover, DLs L satisfying conditions
Theorem 6, C-hardness CQ-predicate emptiness L implies C-hardness CQ-query emptiness
IQ-query emptiness L.
certain conditions, prove converse Theorem 6. Following work
Lutz Wolter (2012), call model TBox ABox materialization
every CQ q arity k tuple ~a Ind(A)k , |= q[~a] iff , |= q[~a]. DL L
called materializable every ABox satisfiable w.r.t. exists materialization
A. Typical DL-Lite dialects, DL EL, Horn-extensions EL ELIF
materializable (Lutz & Wolter, 2012).
Theorem 7 Let L materializable DL admits CIs form A1 u A2 v A3 ,
A1 , A2 , A3 NC . Then, L, IQ-query emptiness polynomially reduced CQ-predicate
emptiness.
Proof. claim IQ A(v) empty given iff B CQ-empty {X} given
TBox 0 = {A u X v B}, B X concept names occur .
direction, assume A(v) IQ non-empty given , let ABox , |= A(a) Ind(A). Set A0 := {X(a)}. easy see
0 , A0 |= v B(v) thus B CQ-predicate non-empty {X} given 0 .
direction, assume B CQ non-empty {X} given 0 , let A0
{X}-ABox satisfiable 0 0 , A0 |= v B(v). may assume
X(a) A0 Ind(A0 ) adding assertions neither result unsatisfiability
w.r.t. 0 invalidate 0 , A0 |= v B(v). assumption materializability, exists
materialization 0 0 A0 0 |= v B(v). definition 0 , may assume
0
0
0
0
X = Ind(A0 ) B = AI X (if case, take modified version,
00
00
0
0
00
0
00 , 0 defined setting X := Ind(A0 ), B := AI X , :=
0
remaining concept role names ; 00 still satisfies 0 A0 since X Ind(A0 )
00
0
u X v B inclusion containing X B still materialization since
concept role names ). 0 |= v B(v) implies Ind(A0 )
0 |= B(a). Since 0 materialization 0 A0 , implies 0 , A0 |= B(a). definition
0 , implies , |= A(a), obtained A0 dropping assertions form
X(b). Since -ABox satisfiable w.r.t. (since A0 satisfiable w.r.t. 0 ), witnesses
A(v) non-empty given .

final observation section, note deciding query predicate emptiness
essentially ABox satisfiability whenever contains symbols used TBox.
described reductions, suffices consider CQ-query emptiness. CQ q = ~u (~v , ~u)
associate every individual variable v q individual name av set
Aq = {A(av ) | A(v) conjunct } {r(av , av0 ) | r(v, v 0 ) conjunct }.
Theorem 8 Let ALCIF-TBox, signature sig(T ) , q CQ. q
empty given iff sig(q) 6 Aq unsatisfiable w.r.t. .
12

fiQ UERY P REDICATE E MPTINESS

Proof. (If) Assume q non-empty given . -ABox
satisfiable w.r.t. certT ,A (q) 6= . clearly implies sig(q) since otherwise
predicate sig(q) \ find model predicate
interpreted empty set, would mean certT ,A (q) = . thus remains show Aq
satisfiable w.r.t. . end, let model A. Since certT ,A (q) 6= , exists
match q I. Modify setting aIv = (v) variables v used q. readily checked
modified model Aq , thus Aq satisfiable w.r.t. required.
(Only if) Assume sig(q) Aq satisfiable w.r.t. . sig(Aq ) . Since
clearly certT ,Aq (q) 6= , means q non-empty given .


4. Expressive Description Logics
consider query predicate emptiness ALC family expressive DLs, establishing tight
complexity results ALC ALCI, undecidability ALCF. start upper bound
proofs, showing IQ-query emptiness CQ-predicate emptiness ALCI NE XP IME, CQ-query emptiness ALC. Moreover, establish CQ-query emptiness
2E XP IME. move corresponding lower bound proofs establish
undecidability considered emptiness problems ALCF.
4.1 Upper Bounds
first main step proofs show that, deciding emptiness problems ALC
ALCI, suffices consider single special -ABox. Specifically, show construct
given satisfiable TBox ABox signature canonical -ABox ,
every CQ q, certT ,AT , (q) 6= exists -ABox satisfiable
w.r.t. certT ,A (q) 6= . prove NE XP IME upper bounds IQ-query emptiness ALCI computing , (in exponential time) guessing model , (of
exponential size |T | ) falsifies query; 2E XP IME upper bound CQ-query
emptiness ALCI obtained even simpler way computing , checking
whether certT ,AT , (q) = using known algorithms. Significantly work required obtain
NE XP IME upper bound CQ-query emptiness ALC. construct , , need
exercise lot care check whether certT ,AT , (q) = without leaving NE XP IME.
Let satisfiable ALCI-TBox ABox signature. define canonical -ABox
, introduce well-known notion types (or Hintikka sets) (Pratt, 1979; Kaminski,
Schneider, & Smolka, 2011). closure cl(T , ) smallest set contains
NC well concepts occur (potentially subconcept) closed
single negations. type set cl(T , ) model
, = tI (d), tI (d) = {C cl(T , ) | C } type
realized I. Let TT , denote set types . role name r
t, t0 TT , , say pair (t, t0 ) r-coherent write ;r t0
C t0 whenever r.C t,
C whenever r .C t0 .
seen implies corresponding conditions existential restrictions,
C t0 r.C cl(C, ) implies r.C t.
13

fiBAADER , B IENVENU , L UTZ , & W OLTER

Definition 9 (Canonical -ABox) Let satisfiable ALCI-TBox ABox signature.
Fix (distinct) individual name TT , . canonical -ABox , defined
follows:
, = {A(at ) | TT , , NC }
{r(at , at0 ) | ;r t0 t, t0 TT , , r NR }.
cardinality TT , exponential size cardinality ,
set TT , computed exponential time making use well-known E XP IME procedures
concept satisfiability w.r.t. TBoxes ALCI (Gabbay, Kurucz, Wolter, & Zakharyaschev, 2003,
p. 72) Thus, , exponential size computed exponential time. interesting
note ABox , finitary version canonical model basic modal logic
essentially identical model constructed Pratts type elimination procedure (Pratt, 1979);
fact, exactly identical sig(T ). show , satisfiable w.r.t. .
Lemma 10 Let satisfiable ALCI-TBox ABox signature. , satisfiable
w.r.t. .
Proof. Let interpretation , defined setting
,

= TT ,

AIT ,

= {t TT , | t}

rIT ,

= {(t, t0 ) TT , TT , | ;r t0 }

NC r NR . One prove induction structure C C
cl(T , ), C iff C , . definition types, C v C imply t.
Thus, , model . immediate consequence definition , ,
model , ; fact, , regarded reduct , signature .

crucial tool analyzing properties canonical ABoxes, introduce homomorphism
ABoxes. Let A0 ABoxes. ABox homomorphism A0 total
function h : Ind(A) Ind(A0 ) following conditions satisfied:
A(a) implies A(h(a)) A0 ;
r(a, b) implies r(h(a), h(b)) A0 .
next lemma identifies central property ABox homomorphisms regarding query answering.
Lemma 11 ALCI-TBox, q CQ , |= q[a1 , . . . , ], h ABox
homomorphism A0 , , A0 |= q[h(a1 ), . . . , h(an )].
Proof. prove contrapositive. Thus assume , A0 6|= q[h(a1 ), . . . , h(an )].
model 0 A0 0 6|= q[h(a1 ), . . . , h(an )]. Define model starting 0
0
reinterpreting individual names Ind(A) setting aI = h(a)I Ind(A). Since
individual names occur , model . model A: A(a) A,
A(h(a)) A0 definition ABox homomorphisms. Since 0 model A0 definition
I, follows aI AI . case r(a, b) analogous. Finally, 0 6|= q[h(a1 ), . . . , h(an )]
definition yield 6|= q[a1 , . . . , ]. thus shown , 6|= q[a1 , . . . , ].

14

fiQ UERY P REDICATE E MPTINESS

following lemma characterizes satisfiability -ABoxes w.r.t. existence ABox
homomorphism , .
Lemma 12 Let satisfiable ALCI-TBox ABox signature. -ABox satisfiable
w.r.t. iff ABox homomorphism , .
Proof. Assume satisfiable w.r.t. . Let model A. Define homomorphism h
, setting h(a) = , type realized aI I. Using
definition , , one see h indeed ABox homomorphism. Conversely, let h
ABox homomorphism , . Lemma 10, , satisfiable w.r.t. . proof
Lemma 11 shows one construct model model , using
homomorphism h. Thus satisfiable w.r.t. .

ready prove main property , regarding emptiness, discussed
beginning section.
Theorem 13 Let satisfiable ALCI-TBox ABox signature. CQ q empty
given iff certT ,AT , (q) = .
Proof. direction follows directly fact , satisfiable w.r.t. (by
Lemma 10). direction, let certT ,AT , (q) = . show q empty given ,
take -ABox satisfiable w.r.t. . Lemmas 11 12, certT ,AT , (q) = implies
certT ,A (q) = , required.

employ Theorem 13 prove NE XP IME upper bounds IQ-query emptiness.
Theorem 14 ALCI, IQ-query emptiness NE XP IME.
Proof. Let satisfiable TBox, ABox signature, A(v) IQ emptiness
given decided. employ following:
Fact. ABox A, , 6|= A(a), exists model aI 6 AI
|I | |Ind(A)| + 2|T | .
Proof Fact. , 6|= A(a), exists model J aJ 6 AJ .
may assume {aJ | Ind(A)} disjoint domain TT ,0 interpretation ,0
defined proof Lemma 10 (where assume 0 := ). define union
restriction J {aJ | Ind(A)} interpretation ,0 expanded adding rI
pairs
(aJ , t) tJ (aJ ) ;r t, Ind(A), TT ,0 ;
(t, aJ ) ;r tJ (aJ ), Ind(A), TT ,0 .
model aI 6 AI required size. finishes proof fact.
NE XP IME algorithm computes canonical ABox , (in exponential time) guesses
every Ind(AT , ) model Ia |Ia | |Ind(AT , )| + 2|T | . algorithm returns yes
Ind(AT , ):
1. Ia model , ,
15

fiBAADER , B IENVENU , L UTZ , & W OLTER

2. aIa 6 AIa .
conditions checked exponential time. Thus, Theorem 13 fact above,
algorithm returns yes iff A(v) empty given .

Note Theorem 6 CQ-predicate emptiness ALCI NE XP IME well. CQ-query
emptiness ALCI, easily derive 2E XP IME upper bound using , results
work Calvanese et al. (1998) complexity query answering DLs.
Theorem 15 ALCI, CQ-query emptiness 2E XP IME.
Proof. 2E XP IME algorithm obtained first computing canonical ABox ,
certT ,AT , (q), checking whether latter empty. done 2E XP IME since
shown work Calvanese et al. (1998) , A, q ALCI-TBox,
p(n)
set certT ,A (q) computed time 2p(m)2
p polynomial, size A,
n size q.

provide improved NE XP IME upper bound CQ-query emptiness ALC,
allow us show ALC three emptiness problems complexity.
Theorem 16 ALC, CQ-query emptiness NE XP IME.
proof somewhat technical reuses machinery fork rewritings spoilers introduced
Lutz (2008), proves combined complexity CQ-answering DL SHQ
E XP IME. concretely, show one decide emptiness CQ q ABox
signature given ALC-TBox guessing extension AeT , canonical ABox ,
assertions prevent possible match q checking AeT , satisfiable w.r.t.
. example, q A(x), obviously suffices add A(a) every individual ,
(we allow complex concepts used ABox). general case requires careful
analysis assertions considered additions, mentioned
fork rewritings spoilers enter picture. fact, used prove that, since
inverse roles TBox, suffices consider extensions , contain additional
individual names additional assertions taken candidate set whose size
polynomial size , q. remains show satisfiability (T , AeT , )
decided (non-deterministically) time single exponential size q. Full details
given appendix.
4.2 Lower Bounds Undecidability
prove matching lower bounds upper complexity bounds presented show undecidability IQ-query emptiness, CQ-predicate emptiness, CQ-query emptiness ALCF.
undecidability proof NE XP IME-lower bound proof reduction two different
tiling problems, first asks tiling finite rectangle (unbounded) size
second asks tiling 2n 2n -square. 2E XP IME lower bound CQ-query emptiness ALCI straightforward reduction query entailment ALCI. begin
NE XP IME lower bound.
Theorem 17 ALC, CQ-predicate emptiness NE XP IME-hard.
16

fiQ UERY P REDICATE E MPTINESS

Proof. proof reduction NE XP IME-hard 2n 2n -tiling problem. instance
tiling problem given natural number n > 0 (coded unary) triple (T, H, V )
non-empty, finite set tile types including initial tile Tinit placed lower left
corner, H horizontal matching relation, V vertical matching relation.
tiling (T, H, V ) map f : {0, . . . , 2n 1} {0, . . . , 2n 1} f (0, 0) = Tinit ,
(f (i, j), f (i + 1, j)) H < 2n 1, (f (i, j), f (i, j + 1)) V j < 2n 1.
NE XP IME-complete decide whether instance 2n 2n -tiling problem tiling.
reduction, let n > 0 (T, H, V ) instance 2n 2n -tiling problem
= {T1 , . . . , Tp }. construct signature TBox ALC (T, H, V )
solution selected concept name CQ-predicate empty given .
proof, convenient impose UNA.
formulating reduction TBox, use role names x represent 2n 2n grid two binary counters X counting 0 2n 1. counters use concept
names X0 , . . . , Xn1 Y0 , . . . , Yn1 bits, respectively. contains following wellknown inclusions stating value counter X0 , . . . , Xn1 incremented going
x-successors value counter Y0 , . . . , Yn1 incremented going y-successors:
k = 1, . . . , n 1,

u

0j<k





0j<k

Xj v (Xk x.Xk ) u (Xk x.Xk )

Xj v (Xk x.Xk ) u (Xk x.Xk )

similarly Y0 , . . . , Yn1 y. states value counter X change
going y-successors value counter change going xsuccessors: = 0, . . . , n 1,
Xi v y.Xi ,

Xi v y.Xi

Yi v x.Yi ,

Yi v x.Yi .


addition, states counter X 2n 1, x-successor
counter 2n 1, y-successor:
X0 u u Xn1 v x.,

Y0 u u Yn1 v y..

states Tinit holds (0, 0) tiling complete:
X0 u u Xn1 u Y0 u u Yn1 v Tinit ,
states tiling condition violated, true:
0 < j p: Ti u Tj v A,
0 i, j p (Ti , Tj ) 6 H: Ti u x.Tj v A,
0 i, j p (Ti , Tj ) 6 V : Ti u y.Tj v A.
17

>v



1ip

Ti ,

fiBAADER , B IENVENU , L UTZ , & W OLTER

Finally, since cannot use negation ABoxes, states concept names X 0 , . . . , X n1
0 , . . . , n1 equivalent X0 , . . . , Xn1 Y0 , . . . , Yn1 , respectively: =
1, . . . , n 1:
Xi v X , Xi v X , Yi v , Yi v X .
set = {x, y, X0 , . . . , Xn1 , Y0 , . . . , Yn1 , X 0 , . . . , X n1 , 0 , . . . , n1 } show
Claim. (T, H, V ) 2n 2n -tiling iff exists -ABox satisfiable w.r.t.
, |= v A(v).
Proof claim. Assume first (T, H, V ) 2n 2n -tiling. construct A, regard
pairs (i, j) < 2n j < 2n individual names let x((i, j), (i + 1, j))
< 2n 1 y((i, j), (i, j + 1)) j < 2n 1. set Xk (i, j) kth bit
1, X k (i, j) kth bit 0, Yk (i, j) kth bit j 1, k (i, j)
kth bit j 0. readily checked satisfiable w.r.t. , |= v A(v).
Conversely, assume (T, H, V ) 2n 2n -tiling given f : {0, . . . , 2n 1}
{0, . . . , 2n 1} T. Let -ABox satisfiable w.r.t. . show , 6|= v A(v).
Let model A. AI = , done. Otherwise re-define interpretation
T1 , . . . , Tp follows. Associate every uniquely determined pair (id , jd )
given values counters X I. set TkI iff f (id , jd ) = Tk let
AI = . readily checked resulting interpretation still model A.

follows preceding result IQ-query emptiness CQ-query emptiness
ALC ALCI NE XP IME-hard. CQ-query emptiness ALCI, easily derive
2E XP IME lower bound results complexity query entailment ALCI.
Theorem 18 ALCI, CQ-query emptiness 2E XP IME-hard.
Proof. shown Lutz (2008) CQ entailment ALCI 2E XP IME-hard already
ABoxes form {A(a)} Boolean CQs. clearly strengthened empty
ABoxes: replace A(a) empty ABox compensate adding TBox > v
r.A r fresh role name. thus remains observe Boolean CQ q entailed
empty ABox iff q non-empty = .

show simple addition functional roles ALC leads undecidability CQpredicate emptiness, thus IQ-query emptiness CQ-query emptiness. proof
reduction tiling problem asks tiling rectangle finite size (which neither
fixed bounded). reduction involves couple technical tricks using concept
names universally quantified second-order variables. allows us enforce
grid structure using standard frame axioms modal logic (which second-order nature).
reduction requires role names functional inverse functional. Since inverse
functionality cannot expressed ALCF, use modal logic frame axiom enforce
different, (forwards) functional role name interpreted inverse role name
interested in. course, undecidability carries variants ALCF use concept
constructor ( 1 r) instead functional roles additional sort, DLs qualified
unqualified number restrictions.
Theorem 19 ALCF, CQ-predicate emptiness undecidable.
18

fiQ UERY P REDICATE E MPTINESS

instance aforementioned tiling problem given triple (T, H, V ) non-empty,
finite set tile types including initial tile Tinit placed lower left corner final tile
Tfinal placed upper right corner, H horizontal matching relation, V
TT vertical matching relation. tiling (T, H, V ) map f : {0, . . . , n}{0, . . . , m}
n, 0, f (0, 0) = Tinit , f (n, m) = Tfinal , (f (i, j), f (i + 1, j)) H < n,
(f (i, j), f (i, j + 1)) v < m. undecidable whether instance tiling problem
tiling.
reduction, let (T, H, V ) instance tiling problem = {T1 , . . . , Tp }.
construct signature TBox (T, H, V ) solution selected
concept name CQ-predicate non-empty given .
ABox signature = {T1 , . . . , Tp , x, y, x , } T1 , . . . , Tp used concept
names, x, y, x , functional role names. use role names x represent horizontal vertical adjacency points rectangle, role names x
simulate inverses x y. , use additional auxiliary concept names. particular U
R mark upper right border rectangle, Zc,1 , Zc,2 , Zx,1 , Zx,2 , Zy,1 , Zy,2 serve
second-order variables, C serves flag indicates grid cells closed position
set, Ix Iy similar flags intended behavior role names x, x
y, . concept name propagated grid upper right corner lower
left one, ensuring flags set everywhere, every position grid labeled
least one tile type, horizontal vertical matching conditions satisfied.
lower left corner grid reached, set flag, query v A(v) asks
for.
TBox defined set following CIs, (Ti , Tj , T` ) range triples
(Ti , Tj ) H (Ti , T` ) V , e {c, x, y}, ranges
Boolean combinations concept names Ze,1 Ze,2 , i.e., concepts L1 u L2 Li
Ze,i Ze,i :
Tfinal v u U u R
x.(U u u Tj ) u Ix u Ti v U u
y.(R u u T` ) u Iy u Ti v R u
x.(Tj u u y.Y ) u y.(T` u u x.Y ) u Ix u Iy u C u Ti v
u Tinit v
Bx u x.x .Bx v Ix
u y.y .By v Iy
x.y.Bc u y.x.Bc v C
U v y. R v x. U v x.U

R v y.R



1s<tp

Ts u Tt v

CIs Ix Iy responsible enforcing x inverse x inverse
y, least ABox individuals interested in. fact, ABox contains
assertions x(a, b) x (b, c) thus violates intended interpretation x x ,
interpret Zx,1 Zx,2 left-hand sides possible instantiations CI
Ix violated, e.g. making Zx,1 Zx,2 true a, false c. ABox contains
x(a, b), x (b, a), possible. Since x functional, thus enforce x
19

fiBAADER , B IENVENU , L UTZ , & W OLTER

inverse functional. CIs C achieve similar way closing grid cells, i.e.,
x-y-successor y-x-successor every relevant ABox individual coincide. However,
seen proofs, works x inverse functional.
establish Theorem 19, suffices prove following lemma (see appendix details).
Lemma 20 (T, H, V ) admits tiling iff -ABox satisfiable
, |= v A(v).

5. EL Horn Extensions
study query predicate emptiness DL EL several Horn extensions. First,
show that, plain EL, three emptiness problems decided polynomial time. reason
case, exponential-size canonical ABox , Section 4 replaced
total -ABox contains single individual instance -predicates.
Note satisfiable w.r.t. EL-TBox EL cannot express unsatisfiability.
approach works ELI, case one obtains E XP IME upper bound
optimal since subsumption ELI already E XP IME-hard (Baader et al., 2005, 2008).
soon unsatisfiability expressed, situation changes drastically. fact, show
even EL subsumption standard reasoning tasks still tractable, (all versions
of) emptiness E XP IME-hard. Nevertheless, emptiness Horn extensions EL turns
easier emptiness expressive DLs. contrast undecidability result ALCF
NE XP IME-hardness result ALC, emptiness E XP IME even Horn-ALCIF.
reason unraveling tolerance Horn description logics observed work Lutz
Wolter (2012), implies looking ABoxes witness non-emptiness,
restrict tree-shaped ones. enables use automata-theoretic techniques
decide emptiness.
5.1 EL ELI
begin showing EL, CQ-query emptiness, CQ-predicate emptiness, IQ-query
emptiness PT IME. proofs transparent simple. signature , total
-ABox := {A(a ) | } {r(a , ) | r }.
Lemma 21 Let EL-TBox signature. CQ q empty given iff
certT ,A (q) = .
Proof. proof simplified version proof Theorem 13. (contrapositive the)
direction follows fact satisfiable w.r.t. . direction, let
certT ,A (q) = . show q empty given , take -ABox A. Define ABox
homomorphism setting h(a) := Ind(A ). Lemmas 11 12,
certT ,A (q) = implies certT ,A (q) = , required.

Lemma 21 provides polytime reduction CQ-query emptiness (and, therefore, IQ-query
emptiness CQ-predicate emptiness) query evaluation problem CQs .
appendix, show due simple shape , checking whether certT ,A (q) =
done polynomial time. fact, give polytime procedure either returns certT ,A (q) =
succeeds constructing Boolean forest-shaped query qb empty given iff q is.
20

fiQ UERY P REDICATE E MPTINESS

construction relies fact that, immediate consequence results proved Lutz
Wolter (2010), emptiness q given implies existence model
certT ,A (q) = shape tree extended reflexive loops root.
Checking , 6|= qb requires answer concept queries extension ELu EL
universal role, possible PT IME (Lutz & Wolter, 2010). obtain following
result.
Theorem 22 EL, IQ-query emptiness CQ-query emptiness decided PT IME.
matching PT IME lower bound Theorem 22 shown reduction subsumption
EL, PT IME-hard (Haase, 2007). Consider EL-TBox EL-concepts C D.
CI C v follows if, if, IQ B(v) non-empty signature {A}
given TBox {A v C, v B}, A, B concept names appear C,
. Thus, obtain
Theorem 23 EL, IQ-query emptiness CQ-query emptiness PT IME-hard.
Observe Lemma 7 materializability EL obtain CQ-predicate emptiness
PT IME-complete well EL.
Note need little proof Lemma 21 go through: suffices total
-ABox satisfiable every TBox. thus reduce emptiness query answering
total -ABox extension EL unable express contradictions. another
important example, consider ELI. Since CQ evaluation ELI E XP IME-complete,
obtain E XP IME upper bound case. matching lower bound obtained
E XP IME-hardness subsumption ELI simple reduction subsumption IQ-query
emptiness given above.
Theorem 24 ELI, IQ-query emptiness CQ-query emptiness E XP IME-complete.
follows Lemma 7 materializability ELI CQ-predicate emptiness E XP IMEcomplete ELI.
5.2 Horn Extensions Involving Negation Functionality
simplest extension EL express unsatisfiability EL . begin showing
IQ-emptiness EL E XP IME-hard, thus significantly harder subsumption instance checking (both decided polynomial time). end, first show
decide IQ-query emptiness EL sufficient consider emptiness w.r.t. directed treeshaped ABoxes, ABox called directed tree-shaped following conditions hold:
1. directed graph GdA = (Ind(A), {(a, b) | r(a, b) A}) tree;
2. a, b Ind(A), one role name r r(a, b) r(b, a)
(and one case).
Proposition 25 instance query B(v) non-empty signature given EL -TBox iff
exists directed tree-shaped -ABox satisfiable w.r.t. , |= B(a)
root A.
21

fiBAADER , B IENVENU , L UTZ , & W OLTER

Proof. provide sketch since result follows general Proposition 30 proved below. Assume B(v) non-empty given . find -ABox
satisfiable w.r.t. , |= B(a). Let potentially infinite ABox obtained
unfolding follows: individuals words a0 r0 rn1 a0 =
ri (ai , ai+1 ) 0 < n; include A(a0 r0 rn1 ) iff A(an )
include r(a0 r0 , a0 r0 rn an+1 ) rn (an , an+1 ) A. One show satisfiable w.r.t. since is, , |= B(a) iff , |= B(a). compactness first-order
consequence, obtain finite ABox A0 , A0 |= B(a). A0 required.

Theorem 26 EL , IQ-query emptiness E XP IME-hard.
Proof. Let , , B(v) given. Proposition 25, B(v) non-empty given iff
exists directed tree-shaped -ABox witness non-emptiness B(v)
given . Directed tree-shaped -ABoxes viewed EL-concepts using symbols
only, vice versa. Thus, witness -ABox exists iff exists EL-concept C using
symbols C satisfiable w.r.t. |= C v B. following
established carefully analyzing reduction underlying Theorem 36 work Lutz
Wolter (2010): given EL -TBox , signature , concept name B, E XP IME-hard
decide exists EL-concept C using symbols C satisfiable
w.r.t. |= C v B. establishes E XP IME-hardness non-emptiness. Using fact
E XP IME = coE XP IME, hardness result transfers IQ-query emptiness.

Observe Lemma 7 materializability EL obtain CQ-predicate emptiness
E XP IME-hard well EL .
Instead proving matching E XP IME upper bound emptiness EL ,
expressive Horn DL Horn-ALCIF, EL fragment. fact, rest
section devoted proof following theorem. interesting contrast result
undecidability emptiness ALCF.
Theorem 27 Horn-ALCIF, CQ-query emptiness E XP IME.
strategy proof Theorem 27 follows. first exhibit polynomial-time reduction
CQ-query emptiness Horn-ALCIF CQ-query emptiness ELIF . Then, show
non-emptiness CQ q ELIF -TBox always witnessed ABoxes certain,
forest-like shape. consider canonical models forest-shaped ABoxes (and TBox
consideration), constructed chase-like procedure special kind
materialization (cf. Section 3), is, answers returned model precisely certain
answers. central observation matches q canonical models forest-shaped ABoxes
grouped equivalence classes induced certain splittings q. finally
show construct, equivalence class, tree automaton decides existence
forest-shaped witness ABox whose canonical model admits match q falls class.
Throughout proof, generally impose UNA.
begin reduction CQ-query emptiness ELIF . fact, reduction even
shows suffices consider ELIF -TBoxes normal form, mean
CIs take one forms
A1 u u v B,

v r.B,
22

r.A v B,

fiQ UERY P REDICATE E MPTINESS

A, A1 , . . . , , B NC {>, } r role name inverse role.
Proposition 28 every Horn-ALCIF TBox , ABox signature , CQ q, one construct
polynomial time ELIF -TBox 0 normal form q empty given iff q
empty given 0 .
proof Proposition 28 standard given appendix. follows, assume
ELIF TBoxes normal form.
next define canonical models. Let (T , A) ELIF KB satisfiable
w.r.t. . construct (typically infinite) canonical model ,A (T , A), start viewed
interpretation, is: ,A = Ind(A), AIT ,A = {a | A(a) A}, rIT ,A = {(a, b) |
r(a, b) A}. exhaustively apply following completion rules:


1. A1 u u v Ai ,A 1 n,
/ AIT ,A , add
AIT ,A .
2. r.A v B , (d, e) rIT ,A , e AIT ,A ,
/ B ,A , add B ,A ;
3. v r.B , AIT ,A , either
/ (r.B)IT ,A funct(r) 6
/






,A

,A

,A

,A

,A
(r.>)
, add (d, e) r
e

B
, e fresh
element.
/ B ,A , add e
4. v r.B , funct(r) , AIT ,A , (d, e) rIT ,A , e


,A
B
.
construction rendered deterministic using ordering inclusions domain
elements decide among different possible rule applications. reason, may speak
canonical model. call model U universal homomorphism U
model A, is, function h : U AU implies h(d) AI ,
(d, e) rU implies (h(d), h(e)) rI , h(aU ) = aI Ind(A). important
property ,A universal.2 fact, following standard prove omit
details, see example work Lutz Wolter (2012).
Lemma 29 Let ELIF -TBox ABox satisfiable w.r.t. . ,A
universal model (T , A).
Let ELIF TBox -ABox satisfiable w.r.t. . easy consequence
Lemma 29 -ABox witness CQ q non-empty given
satisfiable w.r.t. match q ,A .
next step proof Theorem 27 establish proposition constrains shape
ABoxes considered deciding emptiness ELIF . follows,
ABox called tree-shaped
1. undirected graph GA = (Ind(A), {{a, b} | r(a, b) A}) tree;
2. readers wondering relationship universal models materializations defined Section 3,
remark every universal model TBox ABox materialization A. Conversely,
materialization A, exists universal model (Lutz & Wolter, 2012).

23

fiBAADER , B IENVENU , L UTZ , & W OLTER

2. a, b Ind(A), one role name r r(a, b) r(b, a) A,
one case.
working tree-shaped ABoxes, often designate one individuals root.
root tree-shaped ABox fixed, use A|a denote restriction
individuals b whose unique path root GA contains a, call b Ind(A)
r-successor (resp. r -successor) Ind(A) r(a, b) A|a (resp. r(b, a) A|a ).
consider (rooted) tree-shaped interpretations tree-shaped queries, defined analogously
tree-shaped ABoxes.
-ABox forest-shaped ABoxes A0 , A1 , . . . , Ak following
conditions satisfied:
1. union A0 , A1 , . . . , Ak ;
2. k |Ind(A0 )|;
3. 1 < j k: Ind(Ai ) Ind(Aj ) = |Ind(Ai ) Ind(A0 )| = 1;
4. 1 k: Ai tree-shaped ABox rooted individual Ind(A0 ).
call A0 root component A1 , . . . , Ak tree components. width k.
degree smallest number n every tree component Ai every Ind(Ai ),
number assertions r(a, b) r(b, a) Ai bounded n. following proposition
clarifies role forest-shaped ABoxes witnesses non-emptiness.
Proposition 30 Let ELIF -TBox, ABox signature, q CQ. q non-empty
given , witnessed -ABox forest-shaped, width |q|,
degree |T |.
Proposition 30 proved appendix taking witness -ABox A, selecting part
size |q| identified match q serves root component forest-shaped
ABox, unraveling infinite ABox starting selected part, afterwards removing
unnecessary individual names obtain desired degree, finally applying compactness
make resulting witness finite.
Clearly, assume w.l.o.g. forest-shaped witness ABoxes according Proposition 30, individual names used root component taken fixed set Ind cardinality
|q|. make assumption without notice follows.
next analyze matches forest-shaped ABoxes, using splitting query components. similar splittings queries used Appendix B, simpler. forest
splitting CQ q tuple F = (q 0 , q0 , q1 , . . . , qn , ) q 0 obtained q identifying variables, q0 , q1 , . . . , qn partition atoms q 0 , : var(q0 ) Ind
following conditions satisfied
1. q1 , . . . , qn tree-shaped;
2. var(qi ) var(q0 ) 1 1 n;
3. var(qi ) var(qj ) = 1 < j n.
24

fiQ UERY P REDICATE E MPTINESS

Let ELIF -TBox, forest-shaped ABox root component A0 , match
q ,A . Note ,A consists extended (potentially infinite) trees attached
ABox individuals generated completion rules. type F =
(q 0 , q0 , q1 , . . . , qn , ) q 0 obtained q identifying variables sends
element, q0 consists atoms q 0 matches A0 -part ,A , q0 , . . . , qn
maximal connected components q 0 \ q0 , restriction range Ind. Note
that, matter match choose, maximal connected components q 0 \ q0 must
tree-shaped match tree-shaped part ,A , consists tree component
plus attached trees generated completion rules. Thus every match type
following immediate, WT ,q,F denotes set forest-shaped -ABoxes width
|q| degree |T | admit match q type F .
Lemma 31 Let ELIF -TBox, ABox signature, q CQ. q empty
given WT ,q,F empty every forest splitting F q.
on, let ELIF -TBox normal form, ABox signature, q CQ,
assume want decide whether q empty given . Lemma 31, suffices check
whether WT ,q,F empty every forest splitting F q.
Note defining set WT ,q,F possible definition forest splitting
refer particular ABox, turn due use fixed set individual
names Ind root components forest ABoxes. fact, first quantifying forest splittings
Lemma 31 quantifying forest-shaped ABoxes (when testing emptiness
WT ,q,F ) essential obtaining single exponential time upper bound. Since number
forest splittings single exponential |q|, obtain bound test emptiness
WT ,q,F time single exponential |T | + |q|. achieve constructing,
forest splitting F q, two-way alternating parity automaton infinite trees (TWAPA) AF
accepts non-empty language WT ,q,F 6= . Note infinite trees needed
automata take trees input represent (finite) forest-shaped -ABox A,
(potentially infinite) model .
start introducing necessary background TWAPAs. Let
denote positive
integers. tree non-empty (and potentially infinite) set closed prefixes.
node root . use standard concatenation words (nodes trees) and,
convention, take x 0 = x (x i) 1 = x x . Note 1
undefined. 1, node x said child node x, x called parent
x i. slightly depart Vardis original definition TWAPAs (Vardi, 1998) working
trees full, is, define m-ary tree tree whose nodes
(rather exactly) children. W.l.o.g., assume nodes m-ary tree
{1, . . . , m} . infinite path P prefix-closed set P every n 0,
unique x P |x| = n.
set X, use B + (X) denote set positive Boolean formulas X, i.e.,
formulas built using conjunction disjunction elements X used propositional variables, special formulas true false allowed well. alphabet ,
-labeled tree pair (T, V ) tree V : node labeling function.

N

N

N
N
N

Definition 32 (TWAPA) two-way alternating parity automaton (TWAPA) m-ary trees
tuple = (S, , , s0 , F ) finite set states, finite alphabet, :
25

fiBAADER , B IENVENU , L UTZ , & W OLTER

B + (tran(A)) transition function tran(A) = {hii, [i] | {1, 0, . . . m}} set
transitions A, s0 initial state, F = (G1 , . . . , Gk ) sequence subsets
satisfying G1 G2 . . . Gh = S, called parity condition.
Intuitively, transition (hii, s) > 0 means copy automaton state sent
i-th successor current node, required exist; contrast, transition ([i], s)
sends copy i-th successor exists. transitions (hii, s) ([i], s) {1, 0}
interpreted similarly 1 indicates sending copy predecessor 0 indicates sending
copy current node. Note transition (h1i, s) cannot applied root.
Definition 33 (Run, Acceptance) run TWAPA = (S, , , s0 , F ) -labeled tree
(T, V ) S-labeled tree (T , ) () = (, s0 ) , (y) = (x, s)
(s, V (x)) = implies (possibly empty) set {(d1 , s1 ), . . . , (dn , sn )} tran(A)
satisfies 1 n:
1. di = hji, x j defined, x j , , (y i) = (x j, si ).
2. di = [j] x j defined belongs , (y i) = (x j, si ).
Given infinite path P , denote inf(P ) set states q infinitely
many P (y) form (d, q). say run (T , ) accepting
infinite paths P , exists even k inf(P ) Gk 6= inf(P ) Gk1 = .
-labeled tree (T, V ) accepted accepting run (T, V ). use
L(A) denote set -labeled trees accepted A.
note original definition TWAPAs (Vardi, 1998) uses transitions form
(hii, q) {1, . . . , m}, since (hii, q) ([i], q) coincide full m-ary trees. easy
see emptiness version TWAPAs reduced polynomial time emptiness
TWAPAs original definition since encode m-ary trees full m-ary trees. Vardi (1998)
shown emptiness problem TWAPAs E XP IME-complete. precisely,
algorithm that, given TWAPA = (S, , , s0 , F ), decides whether L(A) = runs
time exponential cardinality polynomial cardinality size .
remind reader given two TWAPAs A1 A2 Ai = (Si , , , s0,i , ),
easy construct (in polynomial time) TWAPA L(A) = L(A1 ) L(A2 )
state set S1 S2 .
make accessible TWAPAs, encode forest-shaped -ABoxes width |q|
degree |T | m-ary trees, = |q| |T |. already mentioned,
tree additionally encodes model encoded ABox. explain alphabet used
shape trees detail. root node labeled element alphabet
R consists sig(T )-ABoxes (i) Ind(A) Ind, (ii) r(a, b) implies r ,
(iii) satisfies functionality statements . Let sub(T ) denote set concepts
occur subconcepts. Non-root nodes labeled elements alphabet N
consists subsets
(NC sub(T )) ] {M } ] {r, r | r NR occurs } ] Ind ] {A | B v r.A }
26

fiQ UERY P REDICATE E MPTINESS

contains (i) exactly one role name inverse role, (ii) one element Ind,
(iii) either role name inverse role exactly one element form and,
latter case, A.
tree hT, `i ` labeling described supposed represent forest-shaped ABox AhT,`i together model IhT,`i ABox . individuals AhT,`i
ABox labels root , plus non-root nodes whose label contains
marker . nodes denote domain elements IhT,`i identified
ABox individual. assertions AhT,`i concept role memberships IhT,`i
represented labels hT, `i. Note ABox sig(T )-ABox whereas AhT,`i uses
signature . fact, -assertions part AhT,`i assertions
part IhT,`i .
need impose additional conditions make sure R N -labeled tree hT, `i
indeed represents ABox model intended. call hT, `i proper satisfies following
conditions x :
1. root labeled element R nodes element N ;
2. `(x) N contains element Ind(A) x child root , element
Ind otherwise;
3. take path remove root node (because carries special label),
nodes whose label contains form finite (possibly empty) prefix resulting path;
4. child x `(y) N , B v r.A one
following true:
(a) x root, B `(x) r `(y);
(b) x root Ind, B(a) `(x) {a, r} `(y).
roles individual names element labels describe elements connected
elements via roles AhT,`i IhT,`i . particular, successor root contains
role r individual name Ind, node represents r-successor a. label
elements form serve special marking purpose: `(x), means
element x (which part IhT,`i AhT,`i since `(x) cannot contain )
satisfy concept inclusion B v r.A. later need special markers make
sure IhT,`i model AhT,`i , materialization AhT,`i .
explanations subsequent definitions, three conditions imposed elements
four conditions used define properness make sense reader.
Let hT, `i proper R N -labeled tree. define AhT,`i IhT,`i formally. Let
ABox labels root , let restriction signature .
-ABox AhT,`i described hT, `i
AhT,`i = {A(x) | `(x) NC `(x)}
{r(b, x) | {b, r, } `(x)} {r(x, b) | {b, r , } `(x)}
{r(x, y) | child x `(x) `(y) r `(y)}
{r(y, x) | child x `(x) `(y) r `(y)}
27

fiBAADER , B IENVENU , L UTZ , & W OLTER

interpretation IhT,`i follows:
IhT,`i

= (T \ {}) Ind(A)



IhT,`i

= {a | A(a) A} {x | `(x) NC }

r

IhT,`i

= {(a, b) | r(a, b) A} {(a, x) | {a, r} `(x)} {(x, a) | {a, r } `(x)}
{(x, y) | child x r `(y)} {(x, y) | x child r `(x)}

cIhT,`i

= c

c Ind(AhT,`i )

Apart represented ABox instead interpretation, AhT,`i identical
restriction IhT,`i individuals AhT,`i symbols , particular means
IhT,`i model AhT,`i . Note ABox AhT,`i forest-shaped -ABox. Conversely,
forest-shaped -ABox width |q| degree |T |, define proper
m-ary R N -labeled trees hT, `i AhT,`i = IhT,`i = ,A .
Let F = (q 0 , q0 , q1 , . . . , qn , ) splitting q. build TWAPA AF m-ary
R N -labeled trees accepts exactly trees hT, `i AhT,`i WT ,q,F .
number states AF polynomial |T | + |q| since checked time singleexponential number states whether L(AF ) = , obtain desired E XP IME upper
bound deciding whether WT ,q,F = . construct AF intersection following
TWAPAs:
1. Aprop , makes sure input tree proper;
2. , ensures input tree hT, `i IhT,`i model ;
3. Awf ensures hT, `i satisfies certain well-foundedness condition;
4. Amatch guarantees, exploiting conditions ensured previous automata,
input tree hT, `i AhT,`i WT ,q,F .
construction first automaton Aprop straightforward, details left reader.
Note that, enforce Condition 3 proper trees, automaton needs make use parity
acceptance condition (a co-Buchi condition would actually sufficient). second TWAPA
ensures following conditions satisfied non-root nodes x, x0 input tree:
r(a, b) `() funct(r) , {a, r} 6 `(x);
funct(r) {a, r} `(x) `(x0 ), x = x0 ;
funct(r) , x one child r `(y), additionally r `(x),
child y;
A1 u u v {A1 (a), . . . , (a)} `(), A(a) `();
A1 u u v {A1 , . . . , } `(x), `(x);
v r.B A(a) `(), (i) b {r(a, b), B(b)} `(),
(ii) child x root {a, r, B} `(x);
28

fiQ UERY P REDICATE E MPTINESS

v r.B `(x), (i) {a, r } `(x) B(a) `(), (ii) r `(x)
x non-root parent B `(y), (iii) x child {r, B} `(y);
r.A v B (i) {r(a, b), A(b)} `() (ii) child root
{a, r, A} `(y), B(a) `();
r.A v B (i) {a, r } `(x) A(a) label root, (ii) r `(x)
x parent `(y), (iii) x child {r, A} `(y), B `(x).
Working exact details Aprop left reader.
Ideally, would third automaton Awf ensure IhT,`i canonical model
AhT,`i . However, seem easily possible model constructed
applying completion rules certain order difficult simulate automatonnote
applying rules different order might result construction interpretation
isomorphic one obtained following prescribed application order. thus define
Awf achieve crucial property canonical models positive information (concept
role memberships domain elements) reason, namely contained
AhT,`i logically implied AhT,`i together . formalize terms
derivations.

Let hT, `i proper R N -labeled tree, A0 (NC sub(T )) {>}, x0 A0 hT,`i .
derivation A0 x0 hT, `i finite L-labeled tree hT 0 , `0 i, L set pairs (A, x)
(NC sub(T )) {>} x AIhT,`i . require root 0 labeled
(A0 , x0 ) 0 minimal nodes z 0 `0 (z) = (A, x), one
following holds:
1. {>} x Ind(AhT,`i );
2. 6 `(x) CI A1 u u v children z1 , . . . , zn z 0
`0 (zi ) = (Ai , x) 1 n;
3. 6 `(x) CI r.A0 v child z 0 z 0 `0 (z 0 ) = (A0 , x0 )
(x, x0 ) rIhT,`i . Moreover, B `(x), child z 00 z 0
`0 (z 00 ) = (B, x).
4. 6 `(x) CI A0 v r.A funct(r) child z 0 z 0
`0 (z 0 ) = (A0 , x0 ) (x0 , x) rIhT,`i . Moreover, B `(x), child z 00
z 0 `0 (z 00 ) = (B, x).
5. = >, > 6 `(x), B `(x), child z 0 z 0 `0 (z 0 ) = (B, x).
6. `(x), CI A0 v r.A , child z 0 z 0 `0 (z 0 ) =
(A0 , x0 ) (x0 , x) rIhT,`i either (i) x child x0 , (ii) x child
root, x0 Ind, {r, x0 } `(x).
say hT, `i well-founded whenever x AIhT,`i , NC {>},
derivation x hT, `i. hard construct TWAPA Awf accepts precisely
well-founded proper R N -labeled trees; essentially, automaton verify existence
required derivations implementing Conditions 1 6 transitions, additionally
using co-Buchi condition ensure finiteness derivation.
Next let F = (q 0 , q0 , q1 , . . . , qn , ). automaton Amatch checks
29

fiBAADER , B IENVENU , L UTZ , & W OLTER

1. match q0 IhT,`i
2. match qi IhT,`i v var(q0 ) var(qi ), (v) = (v).
Amatch easy construct omit details. announced, define AF
accepts intersection languages accepted Aprop , , Awf , Amatch . remains
show WT ,q,F empty iff L(AF ) empty.
this, first clarify relation well-foundedness, canonical models, universal models. call proper R N -labeled tree hT, `i canonical (i) IhT,`i canonical
model AhT,`i , (ii) every x \{} 6 `(x), concept `(x)
element x created due application third completion rule inclusion
form B v r.A parent x .
Lemma 34
1. proper R N -labeled tree canonical, well-founded;
2. hT, `i proper R N -labeled tree well-founded IhT,`i model ,
IhT,`i universal model AhT,`i .
proof Lemma 34 found appendix. Point 1 established tracing applications
completion rules applied construct canonical model AhT,`i showing
addition make gives rise derivation. Point 2, first show one
make certain uniformity assumption derivations show define homomorphism
IhT,`i model AhT,`i starting part IhT,`i corresponds root
component AhT,`i moving downwards along tree-shaped parts IhT,`i .
Lemma 35 WT ,q,F = iff L(AF ) = .
Proof. First assume WT ,q,F 6= . forest-shaped -ABox width
|T | degree |q| satisfiable w.r.t. match q ,A type F .
Let hT, `i m-ary proper R N -labeled tree satisfies AhT,`i = canonical.
hT, `i L(Aprop ). Since satisfiable w.r.t. , IhT,`i = ,A model thus
hT, `i L(Aprop ). Point 1 Lemma 34, hT, `i L(Awf ). Finally, match witnesses
Conditions 1 2 definition Amatch satisfied thus hT, `i L(Amatch )
done.
Conversely, assume tree hT, `i L(AF ). Since hT, `i L(Aprop ), = AhT,`i
defined; definition, forest-shaped -ABox width |T | degree |q|.
remains show match q ,A type F . Since hT, `i L(AT )
L(Awf ), IhT,`i model hT, `i well-founded. Point 2 Lemma 34, IhT,`i thus
universal model A. hT, `i L(Amatch ), Conditions 1 2 definition
Amatch satisfied. verified that, consequently, match q IhT,`i
type F . Composing homomorphism IhT,`i ,A , exists since IhT,`i
universal, yields match q ,A type F .


30

fiQ UERY P REDICATE E MPTINESS

6. DL-Lite Family
study query predicate emptiness DL-Lite family description logics (Calvanese
et al., 2007; Artale et al., 2009). begin with, introduce dialects DL-Lite consider.
Basic concepts B defined
B

::=

>

|

|

r.>

ranges NC r (possibly inverse) roles. DL-Litecore TBox finite
set CIs form B1 v B2 B1 u B2 v , B1 B2 basic concepts. Thus,
DL-Litecore included ELI but, includes inverse roles, included EL. DL-LiteF
extension DL-Litecore functionality statements. DL-LiteR extension DLLitecore role inclusions r v s, r, roles. DL-LiteR logical underpinning
OWL profile OWL2 QL (Motik et al., 2009). Finally, DL-Litehorn extension DL-Litecore
conjunctions basic concepts left hand side CIs. Alternatively, defined
fragment ELI qualified existential restrictions r.C replaced unqualified existential
restrictions r.>. details, refer readers work Calvanese et al. (2007), Artale
et al. (2009), Calvanese, De Giacomo, Lembo, Lenzerini, Rosati (2013).
briefly discuss UNA DL-Lite dialects introduced above. First observe DLLitehorn DL-LiteF fragments ALCIF. Thus, Lemma 3, query emptiness predicate emptiness DL-Litehorn DL-LiteF oblivious whether UNA made not.
DL-LiteR fragment ALCIF. is, however, straightforward show DL-LiteR
certain answers CQs depend whether one adopts UNA not. Thus,
DL-LiteR query emptiness predicate emptiness oblivious whether UNA made
not. following proofs make UNA.
main results follows: CQ-query emptiness coNP-complete DL-Lite dialects.
coNP-lower bound holds already fragment DL-Litecore without role names.
contrast, complexity deciding IQ-query emptiness CQ-predicate emptiness depends
whether conjunctions admitted left-hand side concept inclusions not.
conjunctions admitted (as DL-Litecore , DL-LiteR , DL-LiteF ), IQ-query emptiness
CQ-predicate emptiness NL OG PACE-complete. conjunctions admitted (as DLLitehorn ), IQ-query emptiness CQ-predicate emptiness coNP-complete. Again,
lower bound holds already fragments DLs without role names.
note follows use Theorem 6 gives polynomial reduction
CQ-predicate emptiness IQ-query emptiness certain DLs apply DL-Lite
dialects. Instead give direct proofs. results presented Figure 1 DL-Lite dialects
straightforward consequences results established section.
begin proving coNP lower bounds. Let Lcore DL admits CIs v B
u B v , let Lhorn DL admits CIs u A0 v B u B v ,
A, A0 , B concept names.
Theorem 36 Lhorn , IQ-query emptiness, CQ-query emptiness, CQ-predicate emptiness
coNP-hard. Lcore , CQ-query emptiness coNP-hard.
Proof. proofs reduction well-known coNP-complete problem testing whether
propositional formula conjunctive normal form (CNF) unsatisfiable. Let = 1 k
31

fiBAADER , B IENVENU , L UTZ , & W OLTER

CNF formula, v1 , . . . , vn variables used , A1 , . . . , Ak concept names representing clauses, Av1 , Av1 , . . . , Avn , Avn concept names representing literals. Let
additional concept name, set = {Av1 , Av1 , . . . , Avn , Avn }. Consider Lhorn -TBox
consisting following CIs:
Avj u Avj v 1 j n;
A`j v Ai 1 k `j = ()vj disjunct ;
A1 u u Ak v .
straightforward show A(u) empty given iff u A(u) empty given
iff unsatisfiable. Thus, deciding IQ-query emptiness, CQ-predicate emptiness, CQ-query
emptiness Lhorn coNP-hard. coNP-hardness result CQ-query emptiness Lcore ,
drop last CI use CQ A1 (u) Ak (u) instead.

prove matching upper complexity bounds, considering logics DL-Litecore , DLLiteR , DL-LiteF , DL-Litehorn . end, formulate general sufficient conditions
deciding emptiness PT IME coNP. say DL L polysize emptiness witness property whenever CQ q empty given , exists -ABox
polynomial size size q satisfiable w.r.t. certT ,A (q) 6= .
Lemma 37 Let L description logic polysize emptiness witness property
query evaluation problem CQs L NP. Moreover, assume satisfiability ABoxes
w.r.t. L-TBoxes decided polynomial time. CQ-query emptiness L coNP.
Proof. NP-algorithm deciding whether CQ q empty w.r.t. guesses (i) -ABox
polynomial size q, (ii) tuple ~a individual names Ind(A) appropriate
length, (iii) polysize certificate ~a certT ,A (q); verifies polynomial time
satisfiable w.r.t. guessed certificate valid.

Theorem 38 DL-Litecore , DL-LiteR , DL-LiteF , DL-Litehorn , deciding CQ-query emptiness
coNP.
Proof. conditions stated Lemma 37 shown Calvanese et al. (2007) Artale
et al. (2009). sketch proof polysize emptiness witness property. Assume ~a certT ,A (q)
CQ q = ~u (~v , ~u) TBox DLs listed theorem statement
assume satisfiable w.r.t. . use canonical model ,A Lemma 29
(for DL-Litecore , DL-LiteF , DL-Litehorn used without modification since
fragments ELIF ; DL-LiteR , one add following completion rule
construction ,A : (x, y) rIT ,A r v , add (x, y) sIT ,A ). Let
match q ,A . recall ,A consists restriction individuals aIT ,A
Ind(A) tree-shaped interpretations Ia attached aIT ,A . Let A00 set assertions
use individual names Ind(A) exists v var(q) (v) = aIT ,A
(v) Ia . Moreover, individual Ind(A00 ) selected exists
role r b r(a, b) A, select one r(a, b ) include A01 . Let A0 = A00 A01 .
Clearly ABox A0 required: polynomial size, satisfiable w.r.t. (being subset
A), construction, satisfies ~a certT ,A0 (q).


32

fiQ UERY P REDICATE E MPTINESS

say DL L singleton emptiness witness property whenever CQ q form
A(v) v A(v) empty given , exists -ABox containing one
assertion satisfiable w.r.t. certT ,A (q) 6= .
Lemma 39 Let L description logic singleton emptiness witness property
query evaluation problem CQs form A(v) v A(v) L NL OG PACE. Moreover, assume satisfiability singleton ABoxes w.r.t. L-TBoxes decided NL OG PACE.
IQ-query emptiness CQ-predicate emptiness L NL OG PACE.
Proof. non-deterministic logarithmic space algorithm deciding whether CQ form A(v)
v A(v) empty w.r.t. iterates -ABoxes containing one assertion
checks whether least one ABoxes satisfiable w.r.t. satisfies , |= v A(v)
or, respectively, , |= A(a), individual Ind(A).

Theorem 40 DL-Litecore , DL-LiteR , DL-LiteF , deciding IQ-query emptiness CQpredicate emptiness NL OG PACE-complete.
Proof. NL OG PACE-upper bound, conditions stated Lemma 39 shown
Calvanese et al. (2007) Artale et al. (2009). sketch proof singleton emptiness
witness property. Assume ~a certT ,A (q) CQ q form A(v) v A(v) TBox
DLs listed theorem statement. assume satisfiable w.r.t. .
consider case q = v A(v); case q = A(v) similar. proof Theorem 38,
use canonical model ,A . Let mapping ,A (v) AIT ,A
consider uniquely determined Ind(A) (v) = aIT ,A (v) Ia . Using
fact conjunctions occur left-hand side CIs , one show exists
single assertion form B(a) r(a, b) ABox A0 consisting assertion,
() certT ,A0 (q). follows A0 desired witness ABox.
matching lower bound follows directly fact deciding whether |= v B
NL OG PACE-hard TBoxes DL-Litecore (Artale et al., 2009).


7. Case Study Application Modularity
demonstrate usefulness emptiness two ways. First, carry case study
predicate emptiness medical domain, find use realistic ontology adds
significant number non-empty predicates ABox signature large
number predicates empty. static analysis, thus potentially non-trivial user
manually distinguish non-empty empty predicates. Second, show (predicate)
emptiness used produce smaller version TBox tailor-made querying
given ABox signature (in sense: module TBox). Replacing potentially
much smaller module facilitates comprehension TBox, thus helping query formulation.
support claims experiments.
case study, use comprehensive medical ontology SNOMED CT, provides
systematic vocabulary used medical information interchange enable interoperable electronic health records. covers diverse medical areas clinical findings, symptoms, diagnoses, procedures, body structures, organisms, substances, pharmaceuticals, devices specimens.
33

fiBAADER , B IENVENU , L UTZ , & W OLTER

concepts roles

IQ
CQ axioms
axioms
non-empty non-empty -mod. CQ -core

500

16

3557

4631

8910

4597

500

31

3654

4734

8911

4696

1000

16

5827

7385

14110

7349

1000

31

6242

7762

14147

7731

5000

16

18330

21451

33469

21427

5000

31

18469

21557

33616

21532

10000

16

29519

33493

47044

33489

10000

31

30643

34645

47256

34637

Figure 4: Experimental Results
SNOMED CT formulated EL extended role inclusions (which removed experiments). contains 370,000 concept names 62 role names. use SNOMED CT
together ABox signature real-world application randomly generated ABox
signatures. real-world signature obtained analyzing clinical notes emergency
department intensive care unit two Australian hospitals, using natural language processing methods detect SNOMED CT concepts roles.3 contains 8,858 concepts 16 roles.
signature, 16,212 IQ-non-empty predicates 17,339 CQ-non-empty predicates
computed. Thus, SNOMED CT provides substantial number additional predicates query
formulation, roughly identical number predicates ABox signature. However,
numbers show majority predicates SNOMED CT cannot meaningfully used
queries -ABoxes, thus identifying relevant ones via predicate emptiness potentially
helpful. Somewhat surprisingly, number CQ-non-empty predicates 10%
higher number IQ-non-empty symbols.
analyzed randomly generated signatures contain 500, 1,000, 5,000, 10,000
concept names 16 31 role names (1/2 1/4 role names ontology). Every
signature contains special role name role-group, used SNOMED CT implement
certain modeling pattern present ABoxes allow pattern there.
number concept role names, generated 10 signatures. columns IQ nonempty CQ non-empty Figure 4 show results, numbers averages
10 experiments size. additional experiments confirm findings real-world
signature: case, substantial number additional predicates becomes available query
formulation, large number predicates empty.
come application modularity. Recall main motivation studying
emptiness support query formulation: TBoxes large complex, difficult
understand whether TBox contains sufficient background knowledge given query q
non-empty answer -ABox. case, clearly make sense
3. See Current Collaborative Projects Health Information Technologies Research Laboratory University
Sydney (HITRL, 2016).

34

fiQ UERY P REDICATE E MPTINESS

pose q -ABox TBox used background ontology. Similarly,
hard find whether TBox sufficiently powerful entail given predicate occur
query non-empty answer -ABox. Again, case,
predicate used formulating queries. Here, go one step further: instead
using emptiness directly support query formulation, use simplify TBox.
precisely, consider problem extracting (hopefully small!) subset given TBox
gives exactly answers CQs (or IQs) -ABox. subset called
-substitute w.r.t. CQ (or IQ, respectively) original TBox replace original
TBox answering CQs (or IQs, respectively). Working small -substitute instead
original TBox supports comprehension TBox thereby formulation meaningful
queries.
beyond scope paper investigate -substitutes depth. Instead, show that,
description logic ELI, predicate emptiness gives rise particularly natural kind substitute call CQ -core. CQ -core obtained removing concept inclusions
contain predicate CQ-predicate empty w.r.t. TBox. Thus,
CQ -core give answers CQs original TBox -ABoxes,
appealing property predicates occur used meaningfully CQ
querying -ABoxes.
show widely known semantic -modules introduced Grau et al. (2008)
-substitutes CQ -cores cannot larger semantic -modules (unless original
ontology contains tautological concept inclusions). evaluate method practice compare
size CQ -cores -modules, extend case study based SNOMED CT
extraction CQ -cores comparison -modules. start defining -substitutes
formal way.
Definition 41 Let 0 Q {IQ, CQ}. 0 -substitute w.r.t. Q
-ABoxes q Q, certT 0 ,A (q) = certT ,A (q).
aware -substitutes according Definition 41 studied before,
closely related types modules. example, -modules give answers
CQs formulated signature -ABoxes studied work Lutz Wolter (2010),
Kontchakov, Wolter, Zakharyaschev (2010), Konev, Ludwig, Walther, Wolter (2012), Botoeva, Kontchakov, Ryzhikov, Wolter, Zakharyaschev (2014, 2016), Romero, Kaminski,
Grau, Horrocks (2015). stronger version module provided -modules require original TBox model-conservative extension module regarding signature
, studied Konev, Lutz, Walther, Wolter (2013) Gatens, Konev, Wolter (2014).
However, important difference -modules -substitutes
latter restrict signature ABox, queries. contrast, mentioned
-modules guarantee answers CQs formulated signature (and -ABoxes).
particular, follows minimal modules, defined work Kontchakov et al. (2010)
Konev et al. (2013), general used -substitute.
show ELI (and, therefore, fragment EL) one use CQ-predicate
emptiness straightforward way compute -substitute w.r.t. CQ. Let TBox
ABox signature. CQ -core , denoted TCQ , set concept inclusions
X sig() CQ-predicate empty given .

35

fiBAADER , B IENVENU , L UTZ , & W OLTER

Theorem 42 Let TBox ELI. CQ -core -substitute w.r.t. CQ
(and thus w.r.t. IQ).
Proof. Let 0 CQ -core assume 0 , 6|= q[~a] -ABox A. Consider
canonical model 0 ,A , introduced Section 5.2. 0 ,A model 0 A,
0 ,A 6|= q[~a]. sufficient show 0 ,A model . Let C v \ 0
assume 0 ,A 6|= C v D. C 0 ,A 6= . Let qC (v) tree-shaped conjunctive
query corresponding C, constructed standard way (see Appendix B formal definition
similar construction). 0 ,A |= v qC (v) 0 , |= v qC (v). Hence , |=
v qC (v) X sig(C) CQ-empty given . Since C v ,
obtain , |= v qD (v), qD (v) tree-shaped conjunctive query corresponding D.
Thus, X sig(D) CQ-empty given . means C v 0 ,
contradiction.

Note Theorem 22, CQ -core computed polynomial time EL-TBox.
make simple observations regarding CQ -cores:
1. Theorem 42 fails DLs admit negation. example, = {A v B, B v E}
= {A}, -substitute w.r.t. CQ coincides , CQ -core
empty.
2. CQ -core always minimal -substitute w.r.t. CQ. Consider, example, =
{A v B1 , v B2 , B1 v B2 } let = {A}. 0 = {A v B1 , v B2 }
-substitute w.r.t. CQ CQ -core coincides .
3. let IQ -core TBox defined analogy CQ -core , based IQemptiness instead CQ-emptiness. IQ -core cannot serve -substitute
w.r.t. IQ even EL-TBox. example, let = {A v r.B, r.B v E}
= {A}. B IQ-empty given IQ -core empty. However,
empty TBox -substitute w.r.t. IQ since , |= E(a) = {A(a)}.
Interestingly, contrast -modules discussed above, -modules introduced Grau
et al. (2008) turn examples -substitutes. define -modules, let signature.
0
0
Two interpretations 0 coincide w.r.t. = X = X X .
subset 0 TBox called semantic -module w.r.t. every interpretation
0
interpretation 0 coincides w.r.t. sig(T 0 ) X = X 6
sig(T 0 ) model \ 0 . shown work Grau et al. (2008) extracting minimal
semantic -module complexity standard reasoning (that is, subsumption).
addition, shown syntactic approximation called syntactic -module computed
polynomial time (every syntactic -module semantic -module, necessarily
way around). following lemma establishes relationship -modules substitutes. concept inclusion C v tautological |= C v D.
Proposition 43 Let TBox formulated DLs introduced paper, let 0
semantic -module w.r.t. .
1. 0 -substitute w.r.t. CQ;
36

fiQ UERY P REDICATE E MPTINESS

2. sig(T 0 ) contains predicates CQ-empty given ;
3. ELI-TBox contain tautological CIs, CQ -core
contained 0 .
Proof. Point 1, suppose 0 , 6|= q[~a], 0 semantic -module w.r.t.
-ABox. Let model 0 6|= q[~a], consider interpretation 0
coincides 0 sig(T 0 ) X = remaining predicates X.
0 model since 0 semantic -module w.r.t. . 0 model since
-ABox. Since shrank extension predicates transitioning 0
6|= q[~a], 0 6|= q[~a]. Hence , 6|= q[~a], required.
Point 2, assume X CQ-empty given , X 6 sig(T 0 ). Suppose X =
concept name (the case X = r role name r similar left reader). Take
-ABox satisfiable w.r.t. , |= v A(v). Let model (T , A),
0
let 0 interpretation coincides sig(T 0 ) =
0
remaining (in particular AI = ). definition semantic -modules, 0 model
(T , A). derived contradiction 0 shows , 6|= v A(v).
Point 3, assume formulated ELI contains tautological inclusions. Let C v
\ 0 . Then, definition semantic -modules, sig(C v D) contains predicate
X 6 sig(T 0 ) (because otherwise C v tautology). Thus, Point 2, sig(C v D)
contains predicate CQ-empty given . C v CQ -core ,
required.

Point 1, use algorithms computing syntactic semantic -modules
ones provided work Grau et al. (2008) find -substitutes large variety DLs.
Point 2, modules provide over-approximation set predicates
CQ-empty. Finally, Point 3 means that, ELI, -modules cannot smaller CQ -core
unless tautological concept inclusions. general, however, -modules larger
CQ -core TBox. following example shows case already acyclic
EL-TBoxes: let
= {A v s1 .r1 .> u s2 .r2 .>, B r1 .> u r2 .>}
= {A}. predicates CQ-empty given A, s1 , s2 , r1 , r2 . Hence
CQ -core contains first CI . However, non-trivial semantic -modules
w.r.t. (and thus syntactic ones either).
demonstrate potential usefulness -substitutes CQ -core extending
case study medical domain. use ontology SNOMED CT ABox
signatures described beginning section, analyzing size CQ -core comparing size original ontology syntactic -module. real-world
signature, CQ -core contains 17,322 370,000 concept inclusions SNOMED CT. Thus,
5% size original ontology. -module w.r.t. turns significantly
larger CQ -core, containing 27,383 axioms. random signatures, sizes CQ cores -modules shown two right-most columns Figure 4. confirm
findings real-world signature: CQ -core much smaller original ontology
-module.
37

fiBAADER , B IENVENU , L UTZ , & W OLTER

Q UERY C ONTAINMENT

Q UERY E MPTINESS

DL

IQ

CQ

IQ

CQ

EL

E XP IME-c.

E XP IME-c.

PT IME-c.

PT IME-c

EL

E XP IME-c.

E XP IME-c.

E XP IME-c.

E XP IME-c

ELI, Horn-ALCIF

E XP IME-c.

2E XP IME-c.

E XP IME-c.

E XP IME-c.

PT IME

coNP-c.

NL OG PACE-c.

coNP-c.

coNP-c.

p2 -c.

coNP-c.

coNP-c.

NE XP IME-c.

NE XP IME-h.,

NE XP IME-c.

NE XP IME-c.

NE XP IME-c.

2E XP IME-c.

DL-Litecore
DL-Litehorn
ALC

2NE XP IME
ALCI

NE XP IME-c.

2NE XP IME-c.

Figure 5: Query Containment vs Query Emptiness

8. Related Work
Query emptiness fundamental problem static analysis database queries.
called query satisfiability problem. XML, example, takes following form: given
XPath query p DTD D, exist XML document conforms
answer p non-empty. complexity problem ranges tractable
undecidable depending XPath fragment, see e.g. work Benedikt et al. (2008)
references therein. DL context, query emptiness first considered work Lubyte
Tessaris (2008), use step guide enrichment ontologies.
query emptiness problem studied paper special case following query
containment problem, first considered work Bienvenu, Lutz, Wolter (2012).
regard pair (T , q) consists TBox query q compound query Q, called
ontology-mediated query (OMQ), answers Q certain answers q w.r.t.
(Bienvenu et al., 2014). take two OMQs Qi = (Ti , qi ), {1, 2}, q1 q2 IQs
CQs arity. Q1 -contained Q2 , ABox signature , ABoxes satisfiable w.r.t. T1 T2 , certT1 ,A (q1 ) certT2 ,A (q2 ). case,
write Q1 Q2 . notion containment generalizes traditional query containment
problem DLs (Calvanese et al., 2007) relativizing ABox signature admitting
distinct TBoxes T1 T2 . Query emptiness IQ q given clearly polynomially
reduced -containment setting T1 = , q1 = q, T2 = , q2 = A(x) fresh concept
name A, similarly CQs. Deciding -containment, however, often computationally harder
deciding query emptiness. Table 5 summarizes known results; results EL DLLite work Bienvenu et al. (2012), results ELI work Bienvenu,
Hansen, Lutz, Wolter (2016), results ALC ALCI work Bienvenu
et al. (2014) Bourhis Lutz (2016).
Query emptiness closely related explaining negative answers queries. problem
studied, example, Calvanese, Ortiz, Simkus, Stefanoni (2013). Adopting abductive reasoning approach, described follows. Assume , 6|= q(~a) TBox , ABox
A, query q. explain ~a answer q, one wants find minimal ABoxes E
38

fiQ UERY P REDICATE E MPTINESS

certain signature interest E satisfiable w.r.t. , E |= q(~a).
-ABoxes E regarded explanation missing answer used debugging purposes. shown work Calvanese et al. (2013) query emptiness IQs
Boolean CQs reduces (under many-one logarithmic space reductions) problem deciding
existence explanation , 6|= q(~a) = . DL-LiteA , reduction even works
unions conjunctive queries arity. Calvanese et al. (2013) use observation obtain
lower complexity bounds explaining negative query answers, exploiting results published
conference predecessor paper (Baader, Bienvenu, Lutz, & Wolter, 2010).
conjecture that, conversely, techniques proving upper complexity bounds query emptiness
(such ones paper) used obtain upper bounds explaining negative answers.

9. Conclusion
investigated computational complexity query predicate emptiness EL,
DL-Lite, ALC families DLs, concentrating instance queries conjunctive queries
showing complexities range NL OG PACE undecidable. highlighted that,
different DLs query languages, different kinds witness ABoxes sufficient establish
non-emptiness. DLs queries considered paper, would interesting
investigate future work, include following:
DLs include transitive roles, role inclusions, symmetric roles, role inclusion axioms
(Horrocks, Kutz, & Sattler, 2006; Kazakov, 2010).
cases, straightforward reductions results presented paper possible.
example, IQ-query emptiness Horn-SHIF decidable E XP IME since every
Horn-SHIF TBox , IQ A(x), ABox signature , one construct polynomial
time Horn-ALCIF TBox 0 , |= A(a) iff 0 , A, |= A(a) -ABoxes
(Hustadt et al., 2007; Kazakov, 2009). cases, CQ-query emptiness
Horn-SHIF, seems reduction.
DLs include nominals.
important classes queries unions conjunctive queries (UCQs).
materializable DLs Horn-ALCIF,
W UCQ query emptiness reduced CQ
query emptiness since every UCQ q = iI qi (~x), , |= q(~a) iff
, |= qi (~a). simple reduction work non-Horn DLs
ALC.
would interesting develop practical algorithms emptiness evaluate algorithms real-world ontologies queries. Note algorithms EL DL-Lite
easily implementable efficient presented paper. actually confirmed
case study Section 7. work required design efficient algorithms expressive DLs. Finally, would relevant investigate notion -substitute introduced
application modularity detail. example, open question compute minimal -substitutes expressive DLs ALC practice, involved
complexities.
39

fiBAADER , B IENVENU , L UTZ , & W OLTER

Acknowledgements
first author partially supported cfaed (Center Advancing Electronics Dresden)
second author partially supported ANR project PAGODA (ANR-12-JS02-007-01).
grateful Julian Mendez Dirk Walther supporting us case study. would
thank anonymous reviewers provided excellent comments helped us improve
paper.

Appendix A. Proofs Section 3
formulate result proved again.
Lemma 3 Let ALCIF-TBox. CQ q empty given UNA iff
empty given without UNA.
Proof. Consider CQ q answer variables v1 , . . . , vn .
(Only if) Assume q non-empty given without UNA. ABox satisfiable w.r.t. without UNA certT ,A (q) 6= without UNA.
Take model suppose without loss generality infinite. Define
equivalence relation Ind(A) setting b whenever aI = bI . Choose single
representative equivalence class, denote representative equivalence
class containing a. Let A0 ABox obtained replacing individual .
show A0 satisfiable w.r.t. UNA certT ,A0 (q) 6= UNA.
Regarding satisfiability, easy see model (T and) A0 satisfies
UNA individuals appearing A0 . Moreover, since infinite, reinterpret
individual names NI \ Ind(A0 ) obtain interpretation model A0 satisfies
UNA.
showing certT ,A0 (q) 6= UNA. Take (a1 , . . . , ) certT ,A (q) without
UNA. aim show (a1 , . . . , ) certT ,A0 (q). Let J 0 model A0
0
satisfies UNA. show match q J 0 (vi ) = (ai )J every
0
1 n. Consider interpretation J obtained J 0 setting aJ = (a )J every
Ind(A). easy see J model without UNA, J |= q[a1 , . . . , ]
match q J (vi ) = aJ
every 1 n.
desired match q J 0 , finishes proof.
(If) Assume q non-empty given UNA. -ABox
satisfiable w.r.t. UNA certT ,A (q) 6= UNA. Clearly,
satisfiable w.r.t. without UNA remains show certT ,A (q) 6= without
UNA. Let (a1 , . . . , ) certT ,A (q) UNA, let model without
UNA. show |= q[a1 , . . . , ]. Ind(A), let Ia following
unfolding aI :
domain Ia Ia consists words d0 r0 d1 rk1 dk d0 , . . . , dk
r0 , . . . , rk1 (potentially inverse) roles d0 = aI , (di , di+1 ) riI < k,
ri 6= ri+1 functional ri+1 < k, r0 (a, b) 6 b Ind(A) r0
functional.
AIa = {d0 r0 d1 dk | dk AI } NC ;
40

fiQ UERY P REDICATE E MPTINESS

rIa = {(d0 r0 d1 dk , d0 r0 d1 dk rk+1 dk+1 ) | r = rk+1 }
{(d0 r0 d1 dk rk+1 dk+1 , d0 r0 d1 dk ) | r = rk+1 } r NR .
Assume Ia mutually disjoint let individual name root Ia .
obtain interpretation J taking disjoint union Ia , Ind(A), adding (a, b) rJ
whenever r(a, b) A, setting aJ = Ind(A). One show J model
UNA. Thus J |= q[a1 , . . . , ] match q J (vi ) = (ai )J
every 1 n. verified 0 defined setting 0 (vi ) = aI (vi ) = Ind(A)
0 (vi ) = dk (v) = d0 , . . . , dk k 1 match q I, thus |= q[a1 , . . . , ],
required.


Appendix B. Proofs Section 4
restate first result proved.
Theorem 16 ALC, CQ-query emptiness NE XP IME.
general idea proving Theorem 16 follows. Given ALC-TBox , signature ,
CQ q, Theorem 13 suffices test whether , , 6|= q. thus start computing , . check whether , , 6|= q, guess extension set 0
concept inclusions extension , set A0 ABox assertions 0 A0
satisfied models , q match; subsequently, remains
test satisfiability , A0 w.r.t. 0 . subtlety lies selecting class extensions
guessed careful enough way final satisfiability check carried
NE XP IME.
reuse technical definitions results work Lutz (2008) proves
combined complexity CQ-answering DL SHQ E XP IME. definitions
slightly modified since Lutz considers CQs without answer variables uses DL SHQ,
ALC proper fragment. However, straightforward verify proofs given
Lutz work modified definitions.
CQ q viewed directed graph Gdq = (Vqd , Eqd ) Vqd = var(q) Eqd =
{(v, v 0 ) | r(v, v 0 ) q r NR }. call q directed tree-shaped Gdq directed tree
r(v, v 0 ), s(v, v 0 ) q implies r = s. q directed tree-shaped v0 root Gdq , call v0
root q. U var(q), write q|U denote restriction q atoms contain
variables U . set DTrees(q) directed tree-shaped subqueries q defined follows:
DTrees(q) = {q|U | U = Reachq (v), v var(q), q|U directed tree-shaped}
Reachq (v) set variables reachable v Gdq . say
q 0 obtained q performing fork elimination q 0 obtained q selecting two
atoms r(v 0 , v) s(v 00 , v) v 0 , v 00 , v qvar(q) v 0 6= v 00 , identifying v 0
v 00 ;
q 0 fork rewriting q q 0 obtained q repeatedly (but necessarily exhaustively) performing fork elimination;
41

fiBAADER , B IENVENU , L UTZ , & W OLTER

q 0 maximal fork rewriting q q 0 fork rewriting fork elimination
possible q 0 .
following shown work Lutz (2008), plays central role subsequent
definitions.
Lemma 44 variable renaming, every CQ unique maximal fork rewriting.
following definitions splittings spoilers taken work Lutz. understand splitting CQ q intuitive level, useful consider matches q model
TBox ABox special shape: consists core part whose elements exactly
(the interpretations of) ABox individuals tree-shaped parts attached
element core part disjoint other. fact, proved Lutz , 6|= q,
model described shape 6|= q. match q model
described shape partitions variables q several sets: set R contains variables matched ABox individual; sets S1 , . . . , Sn represent disjoint tree-shaped
subqueries q matched tree part whose root connected variable
R via role atom q; set represents collection tree-shaped subqueries
q disconnected variables R Si . addition partitioning, splittings
record variable R set S1 , . . . , Sn connected ABox elements
variables R mapped to. define splittings formally.
Let K = (T , A) ALC-knowledge base q CQ. splitting q w.r.t. K tuple =
hR, T, S1 , . . . , Sn , , i, R, T, S1 , . . . , Sn partitioning var(q), : {1, . . . , n} R
assigns set Si variable (i) R, : R Ind(A) assigns variable R
individual A. splitting satisfy following conditions:
1. CQ q|T variable-disjoint union directed tree-shaped queries;
2. queries q|Si , 1 n, directed tree-shaped;
3. r(v, v 0 ) q, one following holds: (i) v, v 0 belong set R, T, S1 , . . . , Sn
(ii) v R, (i) = v, v 0 Si root q|Si ;
4. 1 n, unique r NR r((i), v0 ) q, v0 root q|Si ;
5. avar(q) R.
Let q directed tree-shaped CQ. define ALC-concept Cq,v v var(q):
v leaf Gdq , Cq,v =
otherwise, Cq,v =

u

A(v)q

Au

u C;
u r.C

A(v)q

r(v,v 0 )q

q,v 0 .

v root q, use Cq abbreviate Cq,v .
following, allow compound concepts negated roles used ABox assertions. semantics assertions corresponding KBs defined expected way:
interpretation satisfies C(a) aI C satisfies r(a, b) satisfy r(a, b).
Let = hR, T, S1 , . . . , Sn , , splitting q w.r.t. K q1 , . . . , qk (directed
tree-shaped) disconnected components q|T . ALC-knowledge base (T 0 , A0 ) spoiler q,
K, one following conditions hold:
42

fiQ UERY P REDICATE E MPTINESS

1. > v Cqi 0 , 1 k;
2. atom A(v) q v R A((v)) A0 ;
3. atom r(v, v 0 ) q v, v 0 R r((v), (v 0 )) A0 ;
4. D(((i))) A0 1 n, = r.Cq|S v0 root q|Si

r((i), v0 ) q.
call K0 spoiler q K (i) every fork rewriting q 0 q, every splitting q 0
w.r.t. K, K0 spoiler q 0 , K, ; (ii) K0 minimal Property (i). following
result proved work Lutz (2008).
Theorem 45 Let K = (T , A) ALC-knowledge base q CQ. K 6|= q iff
spoiler (T 0 , A0 ) q K A0 satisfiable w.r.t. 0 .
following lemma, observed Lutz, plays central role obtaining NE XP IME
decision procedure.
Lemma 46 Let K = (T , A) ALC-knowledge base, q CQ, q maximal fork rewriting,
K0 = (T 0 , A0 ) spoiler q K. K0 contains concept inclusions ABox
assertions following form:
1. > v Cq0 q 0 DTrees(q );
2. A(a) Ind(A) occurring q;
3. r(a, b) a, b Ind(A) r occurring q;
4. D(a) Ind(A) = r.Cq0 , r occurs q q 0 DTrees(q ).
Note definition spoiler q K refers fork rewritings q,
exponentially many, Lemma 46 refers unique maximal form rewriting q .
fact, since cardinality DTrees(q ) clearly bounded size q, number concept
inclusions assertions listed Lemma 46 polynomial size q.
set proof Theorem 16. Theorems 13 45, CQ q empty
signature given TBox iff spoiler (T 0 , A0 ) q (T , , ) , A0
satisfiable w.r.t. 0 . Given CQ q, signature TBox , thus decide emptiness
q given follows:
1. compute , ;
2. guess TBox 0 ABox A0 satisfy Conditions 1 4 Lemma 46 KB
K = (T , , ) role assertion r(a, b) , r(a, b) A0 ;
3. verify (T 0 , A0 ) spoiler q (T , , );
4. verify , A0 satisfiable w.r.t. 0 .
43

fiBAADER , B IENVENU , L UTZ , & W OLTER

remains argue yields NE XP IME algorithm. already noted, Step 1 carried
(deterministic) exponential time. Due Conditions 1 4 Lemma 46 since ,
size exponential , TBox 0 ABox A0 guessed Step 2
size exponential , size polynomial q. Step 3 implemented
straightforward iteration fork rewritings q 0 q splittings q 0 w.r.t. (T , , ),
requires exponential time.
thus remains deal Step 4. Let closure single negations union
following sets concepts:
NC ;
concepts occur (possibly subconcepts);
concept names occur q;
concepts Cq r.Cq subconcepts, q DTrees(q ), q maximal fork
rewriting q, r occurs q.
Based remark Lemma 46, easy verify (and crucial argument) ||
polynomial , , q. -type set model 0
, = {C | C }. Section 4, introduce notion
coherence types: say pair -types (t, t0 ) r-coherent, denoted ;r t0 ,
r.C , C t0 implies r.C t. set -types computed E XP IME.
verify satisfiability , A0 w.r.t. 0 , guess map : Ind(AT , ) , accept
following two conditions satisfied reject otherwise:
(i) C(c) , A0 implies C (c)
(ii) r(b, c) , A0 , C (c), r.C imply r.C (b).
Clearly, checking whether two conditions satisfied done single exponential time.
thus remains argue , A0 satisfiable w.r.t. 0 case exists
map verifying conditions. First note given model KB (T 0 , , A0 ),
define desired map setting (c) = {C | cI C }. Conversely, given map
satisfying conditions (i) (ii), define interpretation follows:
=

AI = {t | t}

rI = {(t, t0 ) | ;r t0 }

cI = (c)

readily verified C , C iff C . this,
show, using similar argument given Lemma 10, model (T 0 , , A0 ).
complete proof undecidability result (Theorem 19) proving Lemma 20.
Lemma 20 (T, H, V ) admits tiling iff -ABox satisfiable w.r.t.
, |= v A(v).
Proof. (Only if) Straightforward. Consider tiling f : {0, . . . , n} {0, . . . , m}
(T, H, V ). Create individuals ai,j 0 n 0 j m, consider ABox
composed following assertions:
44

fiQ UERY P REDICATE E MPTINESS

x(ai,j , ai+1,j ) 0 < n 0 j
x (ai+1,j , ai,j ) 0 < n 0 j
y(ai,j , ai,j+1 ) 0 j < 0 n
(ai,j+1 , ai,j ) 0 j < 0 n
Th (ai,j ) f (i, j) = Th .
easily verified satisfiable w.r.t. satisfies , |= v A(v).
(If) Let -ABox satisfiable w.r.t. , |= v A(v). first show
Ix Iy enforce x inverse x inverse y, respectively, C
forces relevant grid cells closed. r {x, y} call Ind(A) r-defect exists
b Ind(A) r(a, b) r (b, a) 6 A. call inv-defect x-defect
y-defect. call Ind(A) cl-defect exist x(a, b), y(a, c), y(b, d), x(c, e)
6= e inv-defect, b y-defect c x-defect.
Claim 1. exists model Ind(A):
(d1) aI 6 IrI , r-defects Ind(A) r {x, y};
(d2) aI 6 C , cl-defects Ind(A).
Moreover, satisfies following conditions Ind(A), role names r, h {1, . . . , p}:
1. = Ind(A);
2. aI = a;
3. (a, a0 ) rI implies r(a, a0 ) A;
4. ThI implies Th (a) A.
Proof Claim 1. Let r {x, y}. Call two-element set {a, b} r-defect witness exists
c Ind(A) r(a, c), r (c, b) A. Consider undirected graph G nodes Ind(A)
set r-defect witnesses edges. Note G degree two (since r r
functional). Hence G three-colorable. Choose three coloring G colors Br,1 = Zr,1 uZr,2 ,
Br,2 = Zr,1 u Zr,2 Br,3 = Zr,1 u Zr,2
concept names
Sand choose interpretation



Zr,1 , Zr,2 correspondingly. set Ir = i=1,2,3 (Br,i u r.r .Br,i ) .
Call two-element set {d, e} cl-defect witness exist x(a, b), y(a, c), y(b, d), x(c, e)
inv-defect, b y-defect c x-defect. Consider undirected
graph G nodes Ind(A) set cl-defect witnesses edges. Note G degree
two (again since x, x , y, functional). Hence G three-colorable colors
C1 = Zc,1 u Zc,2 , C2 = Zc,1 u Zc,2 C3 = Zc,1 u Zc,2
choose interpretation
concept names Zc,1 , Zc,2 correspondingly. set C = i=1,2,3 (x.y.Ci u y.x.Ci )I .
Since neither existential restrictions concept names Th occur right-hand side
CIs , hard verify interpret remaining concept names
way additional conditions satisfied. (End proof claim)
45

fiBAADER , B IENVENU , L UTZ , & W OLTER

Let model satisfying conditions Claim 1. additionally assume w.l.o.g.
A, -minimal: model J satisfying conditions Claim 1
AJ AI J least one inclusions proper.
Let aA AI . exhibit grid structure gives rise tiling (T, H, V ).
start identifying diagonal starts aA ends instance Tfinal .
Claim 2. set G = {r1 (ai0 ,j0 , ai1 ,j1 ), . . . , rk1 (aik1 ,jk1 aik ,jk ), Tfinal (aik ,jk )}

i0 = 0, j0 = 0, a0,0 = aA ;
1 ` < k, either (i) r` = x, i`+1 = i` + 1, j`+1 = j` (ii) r` = y,
j`+1 = j` + 1, i`+1 = i` .
Proof claim. sequence, convert new model J
interpreting false points reachable (equivalently: A) aA setting
AJ = AI \ {aA }, contradicts A, -minimality I. (End proof claim)
Let n number occurrences role x ABox G Claim 1 number
occurrences y. next show
Claim 3.
.
(a) a0,0 Tinit

(b) ai,j RI implies = n;
(c) ai,j U implies j = m;
(d) ai,j ai,j Ind(G);
(e) ai,j Ind(G), (unique) Th ai,j ThI , henceforth denoted Ti,j ;
(f) (Ti,j , Ti+1,j ) H ai,j , ai+1,j Ind(G) (Ti,j , Ti,j+1 ) V ai,j , ai,j+1
Ind(G).
Proof claim. Point (a) easy consequence fact a0,0 = aA , aA AI ,
A, -minimal. (b), first note unique ` k = n {`, . . . , k}
< n {0, . . . , ` 1}. Due CI R v x., ai`1 ,j`1
/ RI . show

ais ,js
/ R < ` 1, suffices use CIs R v x. R v y.R. proof
(c) similar. prove (d)-(f) together, showing induction ` (d)-(f) satisfied
initial parts
G` := {r1 (ai0 ,j0 , ai1 ,j1 ), . . . , r`1 (ai`1 ,j`1 ai` ,j` )}
G, ` k. base case, ai0 ,j0 = aA AI clearly implies ai0 ,j0 , thus (d)
satisfied. Point (e) follows (a) disjointness tiles expressed . Point (f)
vacuously true since single individual G0 . induction step, assume G`1
satisfies (d)-(f). distinguish four cases:
ai`1 ,j`1 (U u R)I .
46

fiQ UERY P REDICATE E MPTINESS

Since G`1 satisfies (d), ai`1 ,j`1 , definition A, minimality together fact ai`1 ,j`1 (U u R)I ensure
ai`1 ,j`1 (x.(Tg u u y.Y ) u y.(Th u u x.Y ) u Ix u Iy u C u Tf )I
(Tf , Tg ) H (Tf , Th ) V . Using functionality x y, easy
show G` satisfies (d)-(f).
ai`1 ,j`1 (U u R)I .
Since ai`1 ,j`1 RI , ensures x-successor ai`1 ,j`1 I. Moreover,
ai`1 ,j`1 . Together definition , get
ai`1 ,j`1 (y.(Tg u u R) u Iy u Tf )I
(Tf , Tg ) V . must i` = i`1 , j` = j`1 + 1, r`1 = y. Using
functionality y, easy show G` satisfies (d)-(f).
ai`1 ,j`1 (U u R)I .
Analogous previous case.
ai`1 ,j`1 (U u R)I .
neither x-successor y-successor ai`1 ,j`1 (U u R)I . follows
` 1 = k, contradiction ` k.
(End proof claim)
Next, extend G full grid Conditions (a)-(e) Claim 3 still satisfied.
achieved, trivial read solution tiling problem. construction grid
consists exhaustive application following two steps:
1. x(ai,j , ai+1,j ), y(ai+1,j , ai+1,j+1 ) G ai,j+1 Ind(G) y(ai,j , ai,j+1 )
G x(ai,j+1 , ai+1,j+1 ) G, identify ai,j+1 Ind(A) y(ai,j , ai,j+1 )
x(ai,j+1 , ai+1,j+1 ) add latter two assertions G.
2. y(ai,j , ai,j+1 ), x(ai,j+1 , ai+1,j+1 ) G ai+1,j Ind(G) x(ai,j , ai+1,j )
G y(ai+1,j , ai+1,j+1 ) G, identify ai+1,j Ind(A) x(ai,j , ai+1,j )
y(ai+1,j , ai+1,j+1 ) add latter two assertions G.
hard see exhaustive application rules yields full grid, i.e., final G
(i) Ind(G) = {ai,j | n, j m}, (ii) x(ai,j , ai0 ,j 0 ) G iff i0 = + 1 j = j 0 ,
(iii) y(ai,j , ai0 ,j 0 ) G iff = i0 j 0 = j + 1.
Since two steps construction completely analogous, deal Case 1
detail. Thus let x(ai,j , ai+1,j ), y(ai+1,j , ai+1,j+1 ) G ai,j+1
/ Ind(G). Clearly, < n
j < m. (b) (c), thus ai,j
/ (R U )I . Since ai,j (d)
A, -minimal, get
ai,j (x.(Tg u u y.Y ) u y.(Th u u x.Y ) u Ix u Iy u C u Tf )I
(Tf , Tg ) H (Tf , Th ) V . together minimality means
select ai,j+1 , b Ind(A) y(ai,j , ai,j+1 ), x(ai,j+1 , b) A, ai,j+1 , b , Ti,j+1 =
47

fiBAADER , B IENVENU , L UTZ , & W OLTER

Th . choice, (a), (d), (e), second half (f) clearly satisfied. get properties
required Step 1 above, show b = ai+1,j+1 . show this,
satisfaction (b) (c) apply construction step, CIs
R v x. R v y.R

U v y. U v x.U

ensure (b) (c) still satisfied construction step. Showing b = ai+1,j+1
give us first half (f). Finally, prove b = ai+1,j+1 sufficient show ai,j
cl-defect Ind(A). follows Claim 1 since ai,j C , ai,j IxI IyI , ai+1,j IyI ,
ai,j+1 IxI .
use completed grid build solution tiling problem: tile point
(i, j) unique tile satisfied ai,j Ind(A). Property (f) Claim 2
correctness grid construction ensure adjacent tiles satisfy vertical horizontal
constraints.


Appendix C. Proofs Section 5
Theorem 22. EL, CQ-query emptiness decided PT IME.
Proof. Lemma 21, suffices show n-ary CQ q alphabet , decided
PT IME whether , |= q[a , . . . , ] total -ABox. First note
, |= q[a , . . . , ] iff , Ab |= qb,
Ab obtained adding assertion X(a ), X concept name
occur , , q;
qb Boolean CQ obtained q adding conjunct X(v) answer variable v
quantifying away answer variables.
Recall discussion Lemma 44 every CQ q viewed directed graph
Gdq . say Boolean CQ q directed forest-shaped disjoint union directed treeshaped Boolean CQs. Every Boolean CQ q directed forest-shaped corresponds concept
Cq description logic ELu extends EL universal role u , |= q iff
, |= C(a) Ind(A) (Lutz & Wolter, 2010). Checking latter condition possible
PT IME (Lutz & Wolter, 2010). Thus, sufficient convert qb polynomial time directed
forest-shaped CQ qb0 , Ab |= qb iff , Ab |= qb0 .
construct qb0 qb, exhaustively apply following rewriting rules:
1. r(v, v 00 ) r(v 0 , v 00 ) query, identify v v 0 replacing occurrences
v 0 v;
2. r(v 0 , v) s(v 00 , v) query (with r 6= s), identify v, v 0 , v 00 replacing
occurrences v 0 v 00 v;
3. cycle r0 (v0 , v1 ), . . . , rn1 (vn1 , vn ), vn = v0 query {v0 , . . . , vn1 } contains
least two variables, identify variables v0 , . . . , vn1 replacing occurrences
v1 , . . . , vn1 v0 .
48

fiQ UERY P REDICATE E MPTINESS

resulting query contains reflexive loop r(v, v) r
/ , immediately return
no. Otherwise, replace final step reflexive loop r(v, v) r X(v).
query resulting last step qb0 . easy see query obtained point
directed forest-shaped since every variable one predecessor cycles
corresponding directed graph.
prove correctness algorithm, first establish following claim:
Claim. qb0 defined, , Ab |= qb iff , Ab |= qb0 .
suffices prove rule application preserves (non)entailment query Ab .
preliminary, recall that, shown Lutz Wolter (2010), exists materialization
JT ,Ab (T , Ab ) directed tree-shaped interpretation individual root
(potentially) additional reflexive loops added root (an interpretation directed treeshaped corresponding CQ domain elements interpretation regarded
variables directed tree-shaped). Assume rewriting rule 1 applied query p resulting
query p0 . clear , Ab |= pb0 implies , Ab |= pb. converse, assume , Ab |= pb
let JT ,Ab materialization Ab introduced above. match p
JT ,Ab . Since JT ,Ab contain domain elements d, d0 , d00 6= d0
J

J

role name r, (d, d00 ) r ,Ab (d0 , d00 ) r ,Ab , match p JT ,Ab must map
identified variables v v 0 domain element thus match p0 .
two rules replacement r(v, v), r , X(v) dealt similar way.
claim, substitute qb qb0 intended. Moreover, easy see
, Ab 6|= qb algorithm returns due reflexive loop r(v, v) r
/ : simply use
interpretation JT ,Ab proof claim.

Proposition 28. every Horn-ALCIF TBox , ABox signature , CQ q, one construct
polynomial time ELIF -TBox 0 normal form q empty given iff q
empty given 0 .
Proof. proof similar reductions provided work Hustadt et al. (2007)
Kazakov (2009). Nevertheless, Kazakov considers reductions preserving subsumption only,
Hustadt, Motik, Sattler Kazakov reduce ELIF TBoxes,
give detailed proof.
following rules used rewrite ELIF -TBox normal form (all freshly
introduced concept names sig(T ) sig(q). Assume L v R given.
L form L1 u L2 R concept name, take fresh concept name
replace L v R L v v R. R concept name, either L1 L2
concept names, take fresh concept names A1 , A2 replace L v R L1 v A1 ,
L2 v A2 A1 u A2 v R;
L form L1 L2 R concept name, replace L v R L1 v R
L2 v R. Otherwise take fresh concept name replace L v R L v v R;
L form r.L0 L0 concept name, take fresh concept name A0
replace L v R L0 v A0 r.A0 v R;
R form A, replace L v R L u v ;
49

fiBAADER , B IENVENU , L UTZ , & W OLTER

R form R1 u R2 L concept name, take fresh concept name
replace L v R L v v R. Otherwise take fresh concept names A1 , A2
replace L v R L v A1 , L v A2 , A1 v R1 , A2 v R2 ;
R form L0 R0 , replace L v R L u L0 v R0 ;
R form r.R0 R0 concept name, take fresh concept name A0
replace L v R L v r.A0 A0 v R0 ;
R form r.R0 , replace L v R r .L v R.
resulting TBox 0 required. particular, every -ABox model 0 ,
model ; conversely, every model extended
model appropriately interpreting fresh concept names. Consequently,
certT (q, A) = certT 0 (q, A) thus q empty given iff q empty given 0 .

Proposition 30. Let ELIF -TBox, ABox signature, q CQ. q non-empty
given , witnessed -ABox forest-shaped, width |q|,
degree |T |.
Proof. Assume q answer variables v1 , . . . , vn non-empty given .
find -ABox satisfiable w.r.t. certT ,A (q) 6= . identify forestshaped witness non-emptiness q given , consider canonical model ,A
(T , A). construction, ,A consists ABox part I0 , restriction ,A
Ind(A), tree-shaped interpretations Ia , Ind(A), rooted containing ABox
individuals. Since ,A universal, match q ,A . Let consist individuals
Ind(A) v var(q) (v) Ia (possibly (v) = a). Let A0
ABox obtained restricting individuals ; going root component
forest-shaped witness seeking define (observe |Ind(A0 )| |q|). add
tree components, consider, , (typically infinite) tree-shaped ABox Aua
obtained unraveling starting a, work Lutz Wolter (2012):
Ind(Aua ) set sequences = c0 r0 c1 . . . rm1 cm c0 , . . . , cm Ind(A)
r0 , . . . , rm1 (possibly inverse) roles (i) c0 = a, (ii) c1 6 , (iii) rj (cj1 , cj )

0 j < m, (iv) (cj1 , rj1
) 6= (cj+1 , rj ) j > 0; say copy
cm ;
A(c) Ind(Aua ) copy c, A() Aua ;
Ind(Aua ) copy c, = rc0 Ind(Aua ), r(, ) Aua ;
Ind(Aua ) copy c, = r c0 Ind(Aua ), r(, ) Aua .
let Ab union A0 tree-shaped ABoxes {Aua | }. Observe Conditions
b Note
(ii) (iv) first item since satisfies functionality statements , A.
b
forest-shaped, need neither finite degree |T |; going fix
later.
next aim show Ab satisfiable w.r.t. certT ,Ab(q) 6= . end,
construct universal model J Ab . Start Ab viewed interpretation J0 ,
50

fiQ UERY P REDICATE E MPTINESS

construction canonical models. take, Ind(A) copies
b copy tree interpretation Ia (i) root , (ii) J0 = {},
Ind(A),
(iii) 6= implies disjointness , (iv) = identical original
tree interpretation Ia (and copy). d0 result renaming Ia , d0
called copy d. desired interpretation J obtained taking union J0 .
Note every element J copy element ,A , that, construction, J
b
model A.
straightforward show induction structure C every ELI-concept C
every element e J copy ,A , e C J iff C ,A . Since ,A
model , follows J model thus Ab satisfiable w.r.t. . sketch
proof J universal. Let model Ab . start define homomorphism h0
b remains extend h0 components
J setting h0 (a) = aI Ind(A).
J . copy tree interpretation Ia ,A copy a. shown
work Lutz Wolter (2012) that4
b copy Ind(A), AIT ,A implies , Ab |= A() concept
() Ind(A)
names A.
Recall ,A generated derivation rules building canonical models. Using
straightforward induction number rule applications exploiting () fact
normal form, one construct homomorphism ha Ia h(a) = .
renaming, obtain homomorphism h h () = . desired
homomorphism h union h0 h . thus established J universal. Going
construction J (and particular using Point (iv)), verified match
q ,A match q J . Since J universal, yields certT ,Ab(q) 6= desired.
want remove individuals Ab resulting ABox degree |T |
still witnesses non-emptiness q given . Since J universal, homomorphism h J canonical model ,Ab. Composing match h, obtain match
q ,Ab sends every variable individual A0 element tree
individual. inductively mark individuals Ab relevant match , starting
individuals A0 proceeding follows: whenever Rule 2 4 adds marked individual
x AIT ,Ab construction ,Ab presence (x, y) rIT ,A (please see
formulation mentioned rules), mark y. verified every individual outside
A0 one marked neighbor existential restriction . (potentially infinite) forest-shaped ABox Abd obtained Ab dropping assertions involve least one
unmarked individual thus degree |T |. Moreover, marking construction ensures
canonical model ,Abd contains A0 interpretation Ia , Ind(A0 ), hence match
q ,Abd .
point, ABox Abd almost required forest witness, except may infinite.
remains invoke compactness obtain finite subset Abf Abd certT ,Abf (q) 6= .
Clearly, Abf contains forest witness non-emptiness q given .

4. Lutz Wolter (2012) actually show case root component A0 Ab start
unravel consists individual names A, contains concept role assertions; proof goes
case.

51

fiBAADER , B IENVENU , L UTZ , & W OLTER

following lemmas establish two statements Lemma 34.
Lemma 47 Every canonical proper R N -labeled tree well-founded.
Proof. Let hT, `i canonical proper R N -labeled tree, let I0 , I1 , . . . interpretations encountered construction canonical model AhT,`i . Since hT, `i
canonical, IhT,`i canonical model AhT,`i .
slightly abuse terminology using term concept atom refer statements
form B(e) B concept name (or >) e domain element. role atom take
form r(e, e0 ) r role e, e0 domain elements. say concept atom B(e) (resp.
role atom r(e, e0 )) interpretation J e B J (resp. (e, e0 ) rJ ). atom
IhT,`i , rank smallest Ii . show induction rank
every concept atom IhT,`i derivation, thus hT, `i well-founded.
induction start straightforward concept atoms I0 involve concept {>}
element x either x Ind(A) = `() x \ {} `(x),
every atom derivation depth 0. induction step, let B(x) concept atom
Ii+1 \ Ii . consider rule application resulted addition B(x):
1. Assume B(x) Ii+1 application Rule 1, is, A1 u u v
B x AIj 1 j n.
every 1 j n, atom Aj (x) rank i, IH, derivation
hTj0 , `0j Aj x. obtain derivation hT 0 , `0 B x setting 0 = {} {jw | w
Tj0 }, `0 () = (B, x), `0 (jw) = `0j (w).
2. Assume B(x) Ii+1 application Rule 2, is, r.A v B
x (r.A)Ii .
x (r.A)Ii , must exist Ii (x, y) rIi AIi .
atom A(y) rank i, IH, derivation hT 00 , `00 y.
x I0 , x Ind(AhT,`i ), define derivation hT 0 , `0 B x setting
0 = {} {1w | w 00 }, `0 () = (B, x), `0 (1w) = `00 (w).
Next consider case x 6 I0 . x 6 Ind(AhT,`i ), properness ,
concept E NC {>} E `(x). Since x 6 I0 x 6 Ii ,
0 < j < x Ij \ Ij1 . Since hT, `i canonical, element x created
due application Rule 3 using concept inclusion form F v s.E, x E Ij .
Applying IH, obtain derivation hT 000 , `000 E x. thus define derivation
hT 0 , `0 B x setting 0 = {} {1w | w 00 } {2w | w 000 }, `0 () = (B, x),
`0 (1w) = `00 (w), `0 (2w) = `000 (w).
3. Assume B(x) Ii+1 application Rule 3 involving v r.B ,
is, Ii AIi (y, x) rIi+1 \ rIi .
atom A(y) rank i, IH, exists derivation hT 00 , `00 y.
Moreover, since x created applying inclusion v r.B y, second
condition canonicity ensures B `(x). thus define derivation B x
taking tree hT 0 , `0 0 = {} {1w | w 00 }, `0 () = (B, x), `0 (1w) = `00 (w).
52

fiQ UERY P REDICATE E MPTINESS

4. Assume B(x) = >(x) Ii+1 application Rule 3 involving v
r.E (E 6= >), is, Ii AIi (y, x) rIi+1 \ rIi .
atom A(y) rank i, IH, exists derivation hT 00 , `00 y.
Moreover, since x created applying inclusion v r.E y, second
condition canonicity ensures E `(x). thus define derivation > x
taking tree hT 0 , `0 0 = {, 1} {11w | w 00 }, `0 () = (>, x), `0 (1) = (E, x),
`0 (11w) = `00 (w).
5. Assume B(x) Ii+1 application Rule 4, is, v r.B ,
funct(r) , AIi , (y, x) rIi .
atom A(y) rank i, IH, exists derivation hT 00 , `00 y.
x I0 , obtain derivation B x taking tree hT 0 , `0 0 = {} {1w |
w 00 }, `0 () = (B, x), `0 (1w) = `00 (w). x 6 I0 , use
argument Point 2 find derivation hT 000 , `000 E x. obtain derivation
hT 0 , `0 B x setting 0 = {} {1w | w 00 } {2w | w 000 }, `0 () = (B, x),
`0 (1w) = `00 (w), `0 (2w) = `000 (w).

Lemma 48 Let hT, `i proper R N -labeled tree well-founded IhT,`i
model . IhT,`i universal model AhT,`i .
Proof. Assume hT, `i well-founded proper R N -labeled tree IhT,`i model
. obligation pair (A, x) x `(x). every obligation
(A, x), choose derivation hTA,x , `A,x x hT, `i minimal depth. obligations (A1 , x1 ),(A2 , x2 ), write (A1 , x1 ) (A2 , x2 ) (A1 , x1 ) occurs node label
hTA2 ,x2 , `A2 ,x2 i.
Claim. relation acyclic.
Proof claim. Assume contrary obligations (A0 , x0 ), . . . , (An , xn )
(Ai , xi ) (Ai+1 , xi+1 ) n (An+1 , xn+1 ) := (A0 , x0 ). may assume without loss generality 0 < j n, (Ai , xi ) 6= (Aj , xj ), i.e., obligations
(A0 , x0 ), . . . , (An , xn ) pairwise distinct. Let ki depth hTAi ,xi , `Ai ,xi `i
depth shallow derivation (Ai , xi ) contained hTAi+1 ,xi+1 , `Ai+1 ,xi+1 i.
hTAi ,xi , `Ai ,xi minimal depth, ki `i . Moreover, clearly `i ki+1 .
thus shown k0 = `0 = = kn = `n . Consequently, derivation (A0 , x0 )
hTA1 ,x1 , `A1 ,x1 must start root hTAi ,xi , `Ai ,xi i, implies (A0 , x0 ) = (A1 , x1 )
contradiction fact obligations distinct. finishes proof claim.
claim, assume w.l.o.g. chosen derivation hTA,x , `A,x i, node
labeled (B, y), subtree hTA,x , `A,x rooted node chosen derivation
hTB,y , `B,y (uniformity assumption).
prove IhT,`i universal model AhT,`i , take model AhT,`i .
show homomorphism h IhT,`i I, constructing h step-by-step fashion.
start, set h(a) = aI individual names occur AhT,`i . extension
h, argue
53

fiBAADER , B IENVENU , L UTZ , & W OLTER

1. x AIhT,`i concept name, h(x) defined hTA,x , `A,x uses elements
domain h, h(x) AI ;
2. (x, y) rIhT,`i r role h(x), h(y) defined, (h(x), h(y)) rI ;
3. (x, y) rIhT,`i , child x , h(y) defined, h(x) defined.
start observing initial mapping h, Point 2 trivial since model AhT,`i
role edges restriction IhT,`i domain h AhT,`i . Point 3, use
fact individual AhT,`i x parent , properness implies
x individual AhT,`i (and hence x belongs domain h).
Point 1 proved induction depth hTA,x , `A,x i. induction start, consider
depth zero. {>}, x Ind(AhT,`i ), A(x) AhT,`i . Since model AhT,`i
definition h, h(x) AI .
induction step. Assume hTA,x , `A,x uses elements domain h.
definition derivations gives rise following cases:
6 `(x), CI A1 u u v 1 n, child
z 0 z TA,x `A,x (z 0 ) = (Ai , x).
1 n, let zi child z `A,x (zi ) = (Ai , x). subderivation
hTA,x , `A,x rooted zi chosen derivation hTAi ,x , `Ai ,x Ai x. follows
hTAi ,x , `Ai ,x uses elements domain h depth strictly smaller
hTA,x , `A,x i. therefore apply induction hypothesis get h(x) AIi . Since
model A1 u u v , obtain h(x) AI .
6 `(x), CI r.A0 v child z 0 z TA,x `A,x (z 0 ) = (A0 , x0 )
(x, x0 ) rIhT,`i .
subderivation hTA,x , `A,x rooted z 0 chosen derivation hTA0 ,x0 , `A0 ,x0 A0
x0 , thus contains elements domain h strictly smaller depth
hTA,x , `A,x i. thus use IH infer h(x0 ) B , use Point 2
get (h(x), h(x0 )) rI . Since model r.A0 v , h(x) AI .
6 `(x), CI A0 v r.A funct(r) child z 0 z TA,x
`A,x (z 0 ) = (A0 , x0 ) (x0 , x) rIhT,`i .
previous item, use IH Point 2 get h(x0 ) B (h(x), h(x0 ))
rI . Since model contains A0 v r.A funct(r), follows
h(x) AI .
= >, >
/ `(x), B `(x),and child z TA,x `A,x (z) = (B, x).
case applicable since B `(x), 6 `(x), hence x domain
h.
`(x), CI A0 v r.A , child z 0 z TA,x `A,x (z 0 ) =
(A0 , x0 ) (x0 , x) rIhT,`i either (i) x child x0 , (ii) x child
root, x0 Ind, {r, x0 } `(x).
case applicable since `(x), 6 `(x), hence x domain
h.
54

fiQ UERY P REDICATE E MPTINESS

extend h, first show h yet total, exists edge (b
x, yb) rIhT,`i

concept name h(b
x) defined, h(b
) undefined, `(b
) (and consequently
`(b
)), hTA,by , `A,by elements except root node domain
h.
Assume contrary h total edge, i.e., every edge (b
x, yb)
rIhT,`i h(b
x) defined, h(b
) undefined, `(b
), derivation hTA,by , `A,by
contains non-root node domain h. Pick one edge (b
x, yb) rIhT,`i
associated derivation hTA,by , `A,by minimal depth. Since h(b
x) defined h(b
)
undefined, follows Point 3 either x
b parent yb , yb child root node
{b
x, r} `(b
). Since derivation rule 6 applicable rule node label contains

formulation rule, must thus CI A0 v r.A unique
child z TA,by satisfies `A,by (z) = (A0 , x
b). Since x
b domain h, non-root node
domain h must somewhere z. Consequently, find nodes z1 , z2 TA,by
z2 successor z1 domain element x
b0 `A,by (z1 ) domain h,
0
domain element yb `A,by (z2 ) domain h. definition derivation rules,
must (b
x0 , yb0 ) sIhT,`i role s, Point 3, either yb0 child x
b0 , yb0
0
0
child root node label contains {b
x , s}. follows x
b related yb0 one
derivation rules 4 5. Consequently, B `(b
0 ) hTA,by , `A,by contains
IhT,`i
0
0
0
obligation (B, yb ). Thus, edge (b
x , yb )
satisfies conditions associated
derivation hTB,by0 , `B,by0 strictly smaller depth hTA,by , `A,by i, contradicting minimality
hTA,by , `A,by i.
extend h using edge (b
x, yb) rIhT,`i whose existence established.
definition derivations, CI A0 v r.A child z TA,by
`A,by (z) = (A0 , x
b). Since elements hTA,by , `A,by except root node domain h,
subderivation hTA,by , `A,by rooted z uses elements domain h.
uniformity assumption, derivation hTA0 ,bx , `A0 ,bx i, thus IH yields h(b
x) A0 IhT,`i .
IhT,`i
IhT,`i
0
Since v r.A , (b
x, d) r

. Set h(b
) = d.
remains show Points 1 2 satisfied extended h (Point 3 obviously is).
start Point 2. Assume (x, y) sIhT,`i . h(x) h(y) defined already
extension h, done. Otherwise, construction h must (x, y, s) = (b
x, yb, r)
(or (x, y, s) = (b
y, x
b, r ), equivalent). choice h(b
), (h(b
x), h(b
)) rI ,
hence (x, y) sI . Point 1 proved induction depth A(x) initial version
h. induction start exactly same, induction step, cases differ
following ones:

/ `(x), B `(x), = >, child z TA,x `A,x (z) = (B, x).
Immediate since = >.
`(x), CI A0 v r.A , child z 0 z TA,x `A,x (z 0 ) =
(A0 , x0 ) (x0 , x) rIhT,`i either (i) x child x0 , (ii) x child
root, x0 Ind, {r, x0 } `(x).
Since `(x), x 6 Ind(AhT,`i ), x must introduced domain
h examination edge (x0 , x) rIhT,`i . Since child z 0 labeled (A0 , x0 ),
use CI A0 v r.A choose h(x) h(x) AIhT,`i .

55

fiBAADER , B IENVENU , L UTZ , & W OLTER

References
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). DL-Lite family
relations. Journal Artifical Intelligence Research (JAIR), 36, 169.
Baader, F., Bienvenu, M., Lutz, C., & Wolter, F. (2010). Query predicate emptiness description logics. Proceedings 12th International Conference Principles Knowledge
Representation Reasoning (KR).
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. Proceedings 19th
International Joint Conference Artificial Intelligence (IJCAI), pp. 364369.
Baader, F., Brandt, S., & Lutz, C. (2008). Pushing EL envelope further. Proceedings
Workshop OWL: Experiences Directions (OWLED).
Benedikt, M., Fan, W., & Geerts, F. (2008). XPath satisfiability presence DTDs. Journal
ACM, 55(2), 179.
Bienvenu, M., Hansen, P., Lutz, C., & Wolter, F. (2016). First-order rewritability conjunctive
queries Horn description logics. Proceedings 25th International Joint Conference
Artificial Intelligence (IJCAI).
Bienvenu, M., Lutz, C., & Wolter, F. (2012). Query containment description logics reconsidered.
Proceedings 13th International Conference Principles Knowledge Representation Reasoning (KR).
Bienvenu, M., ten Cate, B., Lutz, C., & Wolter, F. (2014). Ontology-based data access: study
disjunctive datalog, CSP, MMSNP. ACM Transactions Database System
(TODS), 39(4), 33.
Botoeva, E., Kontchakov, R., Ryzhikov, V., Wolter, F., & Zakharyaschev, M. (2014). Query inseparability description logic knowledge bases. Proceedings 14th International
Conference Principles Knowledge Representation Reasoning (KR).
Botoeva, E., Kontchakov, R., Ryzhikov, V., Wolter, F., & Zakharyaschev, M. (2016). Games
query inseparability description logic knowledge bases. Artificial Intelligence Journal
(AIJ), 234, 78119.
Bourhis, P., & Lutz, C. (2016). Containment monadic disjunctive datalog, mmsnp, expressive
description logics. Proceedings 15th International Conference Principles
Knowledge Representation Reasoning (KR).
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M., &
Rosati, R. (2009). Ontologies databases: DL-Lite approach. Tutorial Lectures
5th International Reasoning Web Summer School, Vol. 5689 Lecture Notes Computer
Science, pp. 255356. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable reasoning
efficient query answering description logics: DL-Lite family. Journal Automated
Reasoning (JAR), 39(3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2013). Data complexity
query answering description logics. Artificial Intelligence Journal (AIJ), 195, 335360.
56

fiQ UERY P REDICATE E MPTINESS

Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998). decidability query containment
constraints. Proceedings 17th ACM SIGACT-SIGMOD-SIGART Symposium
Principles Database Systems (PODS), pp. 149158.
Calvanese, D., Ortiz, M., Simkus, M., & Stefanoni, G. (2013). Reasoning explanations
negative query answers DL-Lite. Journal Artificial Intelligence Research (JAIR), 48,
635669.
Chortaras, A., Trivela, D., & Stamou, G. B. (2011). Optimized query rewriting OWL 2 QL.
Proceedings 23rd International Conference Automated Deduction (CADE), pp.
192206.
Eiter, T., Gottlob, G., Ortiz, M., & Simkus, M. (2008). Query answering description logic
Horn-SHIQ. Proceedings 11th European Conference Logics Artificial Intelligence (JELIA), pp. 166179.
Eiter, T., Ortiz, M., Simkus, M., Tran, T., & Xiao, G. (2012). Query rewriting Horn-SHIQ plus
rules. Proceedings 26th AAAI Conference Artificial Intelligence (AAAI).
Gabbay, D., Kurucz, A., Wolter, F., & Zakharyaschev, M. (2003). Many-Dimensional Modal Logics:
Theory Applications. Elsevier.
Gatens, W., Konev, B., & Wolter, F. (2014). Lower upper approximations depleting modules
description logic ontologies. Proceedings 21st European Conference Artificial
Intelligence (ECAI), pp. 345350.
Gene Ontology Consortium (2016). gene ontology. http://geneontology.org/. [Online; accessed
16-April-2016].
Glimm, B., Lutz, C., Horrocks, I., & Sattler, U. (2008). Answering conjunctive queries
SHIQ description logic. Journal Artificial Intelligence Research (JAIR), 31, 150197.
Golbeck, J., Fragoso, G., Hartel, F., Hendler, J., Oberthaler, J., & Parsia, B. (2003). national
cancer institutes thesaurus ontology. Journal Web Semantics: Science, Services
Agents World Wide Web, 1(1), 7580.
Grau, B. C., Horrocks, I., Kazakov, Y., & Sattler, U. (2008). Modular reuse ontologies: Theory
practice. Journal Artifical Intelligence Research (JAIR), 31, 273318.
Haase, C. (2007). Complexity subsumption extensions EL. Masters thesis, Dresden University Technology.
HITRL (2016). Health Information Technologies Research Laboratory. University Sydney.
http://sydney.edu.au/engineering/it/hitru. [Online; accessed 16-April-2016].
Horrocks, I., Kutz, O., & Sattler, U. (2006). even irresistible SROIQ. Proceedings
10th International Conference Principles Knowledge Representation Reasoning
(KR), pp. 5767.
Hustadt, U., Motik, B., & Sattler, U. (2004). decomposition rule decision procedures
resolution-based calculi. Proceedings 11th International Conference Logic
Programming Artificial Intelligence Reasoning (LPAR), pp. 2135.
Hustadt, U., Motik, B., & Sattler, U. (2007). Reasoning description logics reduction
disjunctive datalog. Journal Automated Reasoning (JAR), 39(3), 351384.
57

fiBAADER , B IENVENU , L UTZ , & W OLTER

IHTSDO (2016). SNOMED CT: global language healthcare. http://www.ihtsdo.org/snomedct. [Online; accessed 16-April-2016].
Kaminski, M., Schneider, T., & Smolka, G. (2011). Correctness worst-case optimality Prattstyle decision procedures modal hybrid logics. Proceedings 20th International Conference Automated Reasoning Analytic Tableaux Related Methods
(TABLEAUX), pp. 196210.
Kazakov, Y. (2009). Consequence-driven reasoning Horn-SHIQ ontologies. Proceedings
21st International Joint Conference Artificial Intelligence (IJCAI), pp. 20402045.
Kazakov, Y. (2010). extension complex role inclusion axioms description logic
SROIQ. Proceedings 5th International Joint Conference Automated Reasoning
(IJCAR), pp. 472486.
Konev, B., Ludwig, M., Walther, D., & Wolter, F. (2012). logical difference lightweight
description logic EL. Journal Artificial Intelligence Research (JAIR), 44, 633708.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2013). Model-theoretic inseparability modularity
description logic ontologies. Artificial Intelligence Journal (AIJ), 203, 66103.
Kontchakov, R., Rodriguez-Muro, M., & Zakharyaschev, M. (2013). Ontology-based data access
databases: short course. Proceedings International Reasoning Web Summer
School, pp. 194229.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2010). Logic-based ontology comparison
module extraction, application DL-Lite. Artificial Intelligence, 174(15), 1093
1141.
Krotzsch, M. (2012). OWL 2 profiles: introduction lightweight ontology languages. Tutorial Lectures 8th International Reasoning Web Summer School, Vol. 7487 Lecture
Notes Computer Science, pp. 112183. Springer.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2007). Complexity boundaries Horn description logics.
Proceedings 22nd AAAI Conference Artificial Intelligence (AAAI), pp. 452457.
Levy, A. (1993). Irrelevance Reasoning Knowledge Based Systems. Ph.D. thesis, Stanford University.
Lubyte, L., & Tessaris, S. (2008). Supporting design ontologies data access. Proceedings 21st International Description Logic Workshop (DL).
Lutz, C. (2008). complexity CQ answering expressive description logics. Proceedings
4th International Joint Conference Automated Reasoning (IJCAR), pp. 179193.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering description logic EL
using relational database system. Proceedings 21st International Joint Conference
Artificial Intelligence (IJCAI), pp. 20702075.
Lutz, C., & Wolter, F. (2010). Deciding inseparability conservative extensions description
logic EL. Journal Symbolic Computation, 45(2), 194228.
Lutz, C., & Wolter, F. (2012). Non-uniform data complexity query answering description
logics. Proceedings 13th International Conference Principles Knowledge
Representation Reasoning (KR).
58

fiQ UERY P REDICATE E MPTINESS

Motik, B., Grau, B. C., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2009). OWL 2 Web Ontology Language: Profiles. W3C Recommendation. Available http://www.w3.org/TR/owl2profiles/.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity query answering expressive
description logics via tableaux. Journal Automated Reasoning (JAR), 41(1), 6198.
Ortiz, M., & Simkus, M. (2012). Reasoning query answering description logics. Proceedings 8th International Reasoning Web Summer School, Vol. 7487 Lecture Notes
Computer Science, pp. 153. Springer.
Ortiz, M., Simkus, M., & Eiter, T. (2008). Worst-case optimal conjunctive query answering
expressive description logic without inverses. Proceedings 23rd AAAI Conference
Artificial Intelligence (AAAI), pp. 504510.
Patel, C., Cimino, J. J., Dolby, J., Fokoue, A., Kalyanpur, A., Kershenbaum, A., Ma, L., Schonberg,
E., & Srinivas, K. (2007). Matching patient records clinical trials using ontologies.
Proceedings 6th International Semantic Web Conference (ISWC), pp. 816829.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2009). comparison query rewriting techniques
dl-lite. Proceedings 22nd International Description Logic Workshop (DL).
Poggi, A., Lembo, D., Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2008). Linking
data ontologies. Journal Data Semantics, 10, 133173.
Pratt, V. R. (1979). Models program logics. Proceedings IEEE Annual Symposium
Foundations Computer Science (FOCS), pp. 115122.
Romero, A. A., Kaminski, M., Grau, B. C., & Horrocks, I. (2015). Ontology module extraction
via datalog reasoning. Proceedings 29th AAAI Conference Artificial Intelligence
(AAAI), pp. 14101416.
Tobies, S. (2001). Complexity Results Practical Algorithms Logics Knowledge Representation. Ph.D. thesis, RWTH Aachen.
Vardi, M. Y. (1989). Automata theory database theoreticans. Proceedings 7th ACM
SIGACT-SIGMOD-SIGART Symposium Principles Database Systems (PODS), pp. 83
92.
Vardi, M. Y. (1998). Reasoning past two-way automata. Proceedings 25th
International Colloquium Automata, Languages Programming (ICALP), pp. 628641.

59


