journal artificial intelligence

submitted published

query predicate emptiness ontology data access
franz baader

franz baader tu dresden de

tu dresden germany

meghyn bienvenu

meghyn lirmm fr

cnrs universite de montpellier
inria france

carsten lutz

clu uni bremen de

university bremen germany

frank wolter

wolter liverpool ac uk

department computer science
university liverpool uk

abstract
ontology data access obda database querying enriched ontology
provides domain knowledge additional vocabulary query formulation identify query
emptiness predicate emptiness two central reasoning services context query emptiness asks whether given query empty answer databases formulated given
vocabulary predicate emptiness defined analogously quantifies universally queries
contain given predicate determine computational complexity query
emptiness predicate emptiness el dl lite alc families description logics
investigate connection ontology modules perform practical case study evaluate
reasoning services

introduction
recent years paradigm ontology data access obda gained increased popularity general idea add ontology database querying provide domain knowledge
enrich vocabulary available formulation queries particularly
useful data queried highly incomplete multiple data sources diverging vocabularies integrated poggi lembo calvanese de giacomo lenzerini rosati
obda taken particular verve area description logic dl
studied intensively lightweight dls members dl lite el
families tractable regarding data complexity querying expressive
dls alc shiq families querying intractable data complexity use obda former see example work calvanese de giacomo
lembo lenzerini poggi rodriguez muro rosati lutz toman wolter
perez urbina motik horrocks chortaras trivela stamou eiter ortiz
simkus tran xiao surveys krotzsch kontchakov rodriguezmuro zakharyaschev latter see work glimm lutz horrocks sattler
ortiz calvanese eiter bienvenu ten cate lutz wolter well
references given work ortiz simkus
c

ai access foundation rights reserved

fibaader b ienvenu l utz w olter

obda fueled availability ontologies aim providing standard
vocabulary targeted application domain particular many ontologies
bio medical domain snomed ct ihtsdo nci golbeck fragoso hartel hendler oberthaler parsia go gene ontology consortium
formulated dl allow comparably inexpensive adoption obda bio medical applications querying electronic medical records patel cimino dolby fokoue kalyanpur
kershenbaum schonberg srinivas ontologies kind typically
broad coverage vocabulary often contain tens even hundreds thousands predicates
embrace subject areas anatomy diseases medication even social context
geographic location given application small fragment ontologys vocabulary actually occur data still remaining predicates potentially useful
formulating queries linked data vocabulary ontologythis precisely
obda enriches vocabulary available query formulation
due size complexity involved ontologies vocabularies however
difficult understand additional predicates useful query formulation
write meaningful queries extended vocabulary static analysis tools analyzing
queries would thus useful consider fundamental static analysis
query emptiness well natural variation called predicate emptiness former
decide whether given query q provides empty answer databases
formulated given data vocabulary query emptiness thus helps identify queries
useless due wrong use ontology vocabulary standard static analysis many
subareas database theory xml see e g work benedikt fan geerts
references therein
example consider following simple ontology
diabetespatient patient u disease diabetes
diabetespatientwithoutmedication patient u disease diabetes u
medication diabetes
assume used support querying medical patient database unary table
concept names patient diabetes binary tables role names disease
medication distinguishing particular diabetes type type example
database could given following set assertions
patient
disease type

patient b

medication type

diabetes type

disease b type

diabetes type

thus patient diabetes type medication b patient
diabetes type obda queries interpreted open world assumption thus one
interested certain answers query q w r answers q
extension satisfy ontology agreement concrete query
q x diabetespatient x
b certain answers q x w r adespite fact predicate diabetespatient used q x occur since formulated data vocabulary
patient disease medication diabetes


fiq uery p redicate e mptiness

q uery evaluation

e mptiness

dl

iq

cq

iq query cq predicate

cq query

el

pt ime c

np c

pt ime c

pt ime c

el

pt ime c

np c

e xp ime c

e xp ime c

eli

e xp ime c

e xp ime c

e xp ime c

e xp ime c

horn alcif

e xp ime c

e xp ime c

e xp ime c

e xp ime c

nl og pace c

np c

nl og pace c

conp c

pt ime c

np c

conp c

conp c

alc

e xp ime c

e xp ime c

ne xp ime c

ne xp ime c

alci

e xp ime c

e xp ime c

ne xp ime c

e xp ime c

alcf

e xp ime c

e xp ime c

undecidable

undecidable

dl litecore f r
dl litehorn

figure known complexity query evaluation complexity emptiness

say q x non empty given regard evidence q x potentially
useful query databases formulated vocabulary another example consider query
q x diabetespatientwithoutmedication x
certain answer q x w r since open world assumption mere
absence information b medication diabetes type type imply
negation true one even whatever database formulated vocabulary
use never certain answer q x w r case say
q x empty given contrast q x query thus useless databases
consider predicate emptiness decide whether given predicate p
data vocabulary case queries q involve p yield empty answer
databases example predicate diabetespatientwithoutmedication empty
w r important class conjunctive queries queries constructed atomic formulas conjunction existential quantification predicate emptiness used identify
predicates ontology useless query formulation even starting construct
concrete query graphical user interface example predicates would offered
users query formulation notion predicate emptiness loosely related predicate
emptiness datalog queries studied e g vardi levy
aim perform detailed study query emptiness predicate emptiness
dls including members el dl lite alc families concentrating
two common query languages dl obda instance queries iqs conjunctive
queries cqs resulting combinations dls query languages determine
un decidability exact computational complexity query emptiness predicate emptiness
summarized right side figure range pt ime basic members
el dl lite families via ne xp ime basic members alc family undecidable alc extended functional roles alcf adopt standard notion combined


fibaader b ienvenu l utz w olter

complexity measured terms size whole input tbox data vocabulary
query predicate symbol
restricted data vocabulary quantification databases
definition query emptiness predicate emptiness reduce standard reasoning
query evaluation query containment formally demonstrated undecidability alcf contrasted decidability query entailment
containment dl shown calvanese de giacomo lenzerini emptiness decidable complexity still often differs query evaluation simplify
comparison display figure known complexity query evaluation considered dls please consult work baader brandt lutz krotzsch rudolph
hitzler eiter gottlob ortiz simkus concerning el
horn extensions work calvanese de giacomo lembo lenzerini rosati
artale calvanese kontchakov zakharyaschev dl lite work
tobies hustadt motik sattler lutz ortiz simkus eiter
dls alc family comparing two sides figure
observe clear relationship complexity emptiness checking
complexity query evaluation indeed often similar complexity
several cases emptiness checking difficult corresponding query evaluation way around complexities incomparable note
extension el el bottom concept used express class disjointness
observe particularly significant difference tractability evaluating instance queries
e xp ime completeness checking iq query emptiness
key ingredient developing establishing upper complexity bounds emptiness searching databases witness non emptiness database
non emptiness q given example one often focus single
database constructed specifically purpose class databases easier handle
class databases single database class databases consider depends
dl question reason secondary theme analyze shape witness
databases turns alc extension alci inverse roles consider
single exponential size database whose construction reminiscent type elimination filtration
constructions known modal logic literature el extension eli may
concentrate single witness candidate much simpler one consists facts
constructed data vocabulary single constant extensions el
use class databases witness candidates namely tree forest structure
dl lite may restrict attention class databases whose size bounded polynomially
w r input query ontology
demonstrate predicate emptiness useful reasoning service static analysis
perform experiments well known large scale medical ontology snomed ct coupled
real world data vocabulary corresponding terms obtained analyzing clinical notes
hospital randomly generated vocabularies real world vocabulary
contains concept names role names snomed ct
predicates turned non empty iqs non empty cqs thus
snomed ct provides substantial number additional predicates query formulation
large number predicates cannot meaningfully used queries databases
thus identifying relevant predicates via predicate emptiness potentially helpful


fiq uery p redicate e mptiness

consider use query predicate emptiness extraction modules
ontology thus instead emptiness directly support query formulation
used simplify ontology substitute ontology subset ontology
gives certain answers conjunctive queries databases replacing
large ontology potentially quite small substitute supports comprehension ontology
thereby formulation meaningful queries eli one use predicate emptiness extract particularly natural substitute ontology called cq core
containing exactly axioms original ontology contain predicates
non empty databases thus predicates cq core ontology meaningfully used queries posed databases example cq core ontology
diabetespatient patient u disease diabetes
second axiom removed cq contains diabetespatientwithoutmedication
empty given analyze practical interest cq cores carry case study
compute cq cores ontology snomed ct coupled signatures
showing tend drastically smaller original ontology smaller
modules popular way extracting modules ontologies grau horrocks kazakov
sattler
article structured follows begin section recalling syntax semantics description logics considered work section introduce four notions
emptiness iq query iq predicate cq predicate cq query investigate formal relationships first observe iq query iq predicate emptiness coincide
three consider cq predicate emptiness corresponds cqquery emptiness cqs restricted simple form exhibit two polynomial
reductions predicate query emptiness dls considered except
dl lite family cq predicate emptiness polynomially reducible iq query emptiness horn dls considered iq query emptiness polynomially reducible
cq predicate emptiness
section investigate computational complexity decidability query predicate emptiness alc family expressive dls alc alci provide tight
complexity bounds showing ne xp ime completeness three emptiness alc
iq query emptiness cq predicate emptiness alci e xp ime completeness
cq query emptiness alci situation dramatically surprisingly different
alcf emptiness proven undecidable previously mentioned
complexity upper bounds alc alci rely characterization non emptiness terms
special witness database complexity lower bounds undecidability proven
means reductions tiling
section continue investigation query predicate emptiness considering
dl el horn extensions plain el provide simple characterization nonemptiness terms maximal singleton database allows us three emptiness
decided polynomial time characterization fact
standard reasoning eli e xp ime complete obtain e xp ime completeness emptiness
checking eli extensions el allow contradictions singleton database may
consistent ontology requiring another handle extensions


fibaader b ienvenu l utz w olter

sufficient consider tree shaped databases witnesses non emptiness devise
decision procedure emptiness checking upon tree automata obtain manner
e xp ime upper bound horn alcif sharply contrasts undecidability
non horn alcf interestingly matching e xp ime lower bound
considerably simpler dl el standard reasoning tasks tractable
section turn attention dl lite family lightweight dls
commonly considered dls ontology data access cq query emptiness
conp complete considered dl lite dialects iq query emptiness cq predicate
emptiness complexity depends whether considered dialect allows conjunctions left hand side axioms standard dialects dl litecore dl liter
dl litef allow conjunction iq query emptiness cq predicate
emptiness nl og pace complete dialects dl litehorn admits conjunctions
iq query emptiness cq predicate emptiness conp complete difference complexity due fact dialects allowing conjunction need consider witnesses nonemptiness polynomial size whereas absence conjunction sufficient
consider databases consist single assertion
section apply query predicate emptiness extract modules ontology
introduce notion substitute cq core ontology eli
cq core ontology substitute relate substitutes notions module
proposed literature particular observe semantic syntactic modules grau
et al examples substitutes thus computing modules
used compute possibly non minimal substitutes demonstrate potential
utility substitutes emptiness checking experiments snomed ct
finally sections conclude discussing related future work please
note improve readability text technical proofs deferred appendix

preliminaries
dls concepts inductively defined help set constructors starting countably infinite sets nc concept names nr role names constructors important summarized figure inverse role form r r role name
role role name inverse role uniformity define double inverse identity
r r role names r throughout use b denote concept
names c denote possibly compound concepts r denote roles
shall concerned variety different dls well known literature
least expressive ones el dl lite logical underpinnings owl
profiles owl el owl ql respectively motik grau horrocks wu fokoue lutz
el concepts constructed according following grammar constructors
top concept conjunction existential restriction
c









c ud



r c

ranging concept names r role names dl lite concepts tboxes
introduced section basic expressive dl consider alc
extension el constructors bottom concept negation disjunction value restriction
c











c ud




c td



r c



r c

fiq uery p redicate e mptiness

name

syntax

concept name
role name


r

semantics
ai
ri

top concept
bottom concept
negation
conjunction
disjunction
existential restriction
value restriction
role inverse



c
c ud
c td
r c
r c
r



c
c di
c di
e c e ri
e e ri e c
e e ri

concept inclusion
concept assertion
role assertion

cvd

r b

c di
ai ai
ai bi ri

figure syntax semantics dl constructors tbox axioms abox assertions

availability additional constructors indicated concatenation letters subscripts
letter stands addition inverse roles inside existential value restrictions present
subscript stands adding gives example extension alci alc
inverse roles whose constructors exactly ones shown figure defines
extension eli el inverse roles existential restrictions bottom concept
concept inclusion ci dl l takes form c v c l concepts
use c abbreviation cis c v v c description logic ontologies
formalized tboxes given dls l introduced l tbox finite set
cis l use letter f write lf denote description logic tboxes consist
cis l functionality statements funct r r role name
inverse role inverse roles admitted l example alcf thus extension alc
tboxes contain cis alc functionality statements role names use
term axioms refer concept inclusions functionality statements uniform way
addition dls introduced consider dls impose restrictions
constructors used side concept inclusions horn alci concept
inclusion ci form l v r l r concepts defined syntax rules
r r r u r l r r r r r
l l l u l l l r l
ranging concept names r potentially inverse roles horn alcif tbox
finite set horn alci cis functionality statements funct r note different
definitions horn dls found work hustadt motik sattler eiter et al
kazakov original definition hustadt motik sattler
polarity rather technical prefer equivalent definition
size tbox obtained taking sum lengths axioms
length axiom number symbols needed write word


fibaader b ienvenu l utz w olter

databases represented abox finite set concept assertions
role assertions r b b drawn countably infinite set ni individual names
concept name r role name note role assertions cannot use inverse roles
shortcut though sometimes write r b r b use ind denote
set individual names used abox knowledge base pair k
tbox abox
semantics description logics defined terms interpretation
domain non empty set interpretation function maps concept name nc
subset ai role name r nr binary relation ri individual
name element ai extension compound concepts inductively defined
shown third column figure interpretation satisfies ci c v c di
statement funct r ri functional iii assertion ai ai vi assertion
r b ai bi ri model tbox satisfies axioms model
abox satisfies assertions tbox satisfiable model abox
satisfiable w r tbox common model write c v
satisfy ci c v
consider two types queries first instance queries iqs take form v
concept name v individual variable taken set nv note instance queries
used query concept names role names traditional definition due
fact role assertions implied abox explicitly contained
thus querying trivial general conjunctive queries cqs take form u v u
conjunction atoms form v r v v v v individual variables
v u nv variables existentially quantified called answer variables
arity q defined number answer variables queries arity called boolean
use var q avar q qvar q denote set variables answer variables quantified
variables respectively query q use iq refer set iqs cq
refer set cqs
let interpretation q instance conjunctive query q arity k answer
variables v vk match q mapping var q v ai
v q v v ri r v v q every answer variable v var q
individual name v ai write q ak match
q vi aii every k knowledge base write
q ak q ak case ak
certain answer q w r use certt q denote set certain answers
q w r note q boolean query certt q
match q every model otherwise certt q query evaluation
cqs dl l decide l tbox abox cq q arity k tuple
ind k whether certt q
use term predicate refer concept name role name signature refer
set predicates introduction informally called signature vocabulary sig q
denotes set predicates used query q similarly sig sig refer
signature tbox abox abox abox uses predicates
signature likewise concept
longer true presence role hierarchy statements however consider



fiq uery p redicate e mptiness

context query answering dls sometimes useful adopt unique name
assumption una requires ai bi interpretations b ni
b obtained depend una following well known
lemma shows una make difference alci fragments el
alc certain answers queries change
lemma let alci tbox abox q cq certt q identical
without una
analogous statement fails alcf e g abox f b f b satisfiable w r tbox funct r without una thus certt v
unsatisfiable una thus certt v ind

query predicate emptiness
introduce central notions reasoning studied
interrelated make basic observations used throughout following
definition introduces different notions emptiness studied
definition let tbox signature q iq cq query language call
q query q empty given aboxes satisfiable w r
certt q
predicate q empty given every q query q sig q empty
given
follows signatures used aboxes called abox signatures quantify
aboxes formulated abox signature address typical database applications
data changes frequently thus deciding emptiness concrete abox
much interest example assume aboxes formulated signature
person hasdisease diseasea diseaseb
following upper case words concept names lower case ones
role names signature typically fixed application design phase similar schema
design databases tbox take
person v hasfather person u male diseasea v infectiousdisease
iq infectiousdisease v cq v hasfather u v non empty given
despite predicates cannot occur data witnessed aboxes diseasea
person respectively illustrates tbox enriches vocabulary
available query formulation contrast cq
vv hasfather u v hasdisease v v infectiousdisease v
uses predicates plus additional one abox signature empty
given


fibaader b ienvenu l utz w olter

regarding predicate emptiness interesting observe choice query language
important example predicate male iq empty given cq empty
witnessed abox person cq v male v thus makes sense use male
instance queries aboxes given whereas meaningfully used conjunctive
queries
every iq cq predicate cq empty must iq empty illustrated
example converse hold note role names iq empty
given since role name cannot occur instance query contrast hasfather clearly
cq empty example
follows lemma alci fragments query emptiness predicate emptiness oblivious whether una made iq cq established
following lemma true alcif despite fact certain answers queries
differ without una
lemma let alcif tbox cq q empty given una iff
empty given without una
proof lemma given appendix direction left right one assumes
q non empty given without una takes witness abox model
satisfying without una identifying b ind ai bi one
define abox shows q non empty given una
conversely one assumes q non empty given una takes witness
abox one use q non empty given without una
exception dl lite dialect containing role inclusions dls considered
fragments alcif thus free adopt una remainder
choose whatever convenient careful point explicitly
whether una made dl lite dialect covered formulation lemma
observe discussion dl lite even lemma holds free adopt
una case well
relevant note decision disallow individual names query atoms without
loss generality indeed easily verified predicate emptiness whether
admit individuals queries moreover immediate reduction query emptiness
generalized cqs may contain individual names query emptiness cqs defined
suffices replace every individual query fresh answer variable xa
test whether resulting query without individuals empty given
definition gives rise four natural decision
definition let q iq cq
q query emptiness deciding given tbox signature qquery q whether q empty given
q predicate emptiness means decide given tbox signature predicate
whether q empty given


fiq uery p redicate e mptiness

iq query iq predicate
emptiness
emptiness
trivial

cq query
emptiness

theorem
materializable dls

lemma

theorem

cq predicate
emptiness

figure polytime reductions emptiness notions
clearly four intimately related particular iq query emptiness iqpredicate emptiness effectively since instance query consists
single predicate reason disregard iq predicate emptiness
speak iq query emptiness cq case things different indeed following lemma
shows cq predicate emptiness corresponds cq query emptiness cqs restricted
simple form easy consequence fact since composite concepts queries
disallowed cqs purely positive existential conjunctive
lemma nc resp r nr cq predicate empty given iff conjunctive query
v v resp vv r v v empty given
lemma allows us consider queries form v v vv r v v dealing
cq predicate emptiness without notice
trivially iq query emptiness special case cq query emptiness following observation less obvious applies dls considered except dl lite
family
theorem dl contained alcif admits cis r b v b r v b b
concept name cq predicate emptiness polynomially reduced iq query emptiness
proof let tbox signature b concept name occur
role name occur prove
cq predicate empty given iff iq b v empty given tbox
tb v b tb r b v b r r occurs
r cq predicate empty given iff iq b v empty given tbox
tb r v b tb
proofs points similar concentrate point first suppose cqpredicate non empty given abox v v choose
ind set b b ind fact v v
definition shown b converse direction
suppose b iq query non empty given abox
b ind let obtained removing assertions
b fact b definition shown
v v




fibaader b ienvenu l utz w olter

figure gives overview available polytime reductions four rather three
terms computational complexity cq query emptiness thus potentially hardest cq predicate emptiness simplest precisely cq query emptiness
dl l belongs complexity class c larger equal pt ime iq query emptiness
cq predicate emptiness l c moreover dls l satisfying conditions
theorem c hardness cq predicate emptiness l implies c hardness cq query emptiness
iq query emptiness l
certain conditions prove converse theorem following work
lutz wolter call model tbox abox materialization
every cq q arity k tuple ind k q iff q dl l
called materializable every abox satisfiable w r exists materialization
typical dl lite dialects dl el horn extensions el elif
materializable lutz wolter
theorem let l materializable dl admits cis form u v
nc l iq query emptiness polynomially reduced cq predicate
emptiness
proof claim iq v empty given iff b cq empty x given
tbox u x v b b x concept names occur
direction assume v iq non empty given let abox ind set x easy see
v b v thus b cq predicate non empty x given
direction assume b cq non empty x given let
x abox satisfiable v b v may assume
x ind adding assertions neither unsatisfiability
w r invalidate v b v assumption materializability exists
materialization v b v definition may assume




x ind b ai x case take modified version






defined setting x ind b ai x

remaining concept role names still satisfies since x ind


u x v b inclusion containing x b still materialization since
concept role names v b v implies ind
b since materialization implies b definition
implies obtained dropping assertions form
x b since abox satisfiable w r since satisfiable w r witnesses
v non empty given

final observation section note deciding query predicate emptiness
essentially abox satisfiability whenever contains symbols used tbox
described reductions suffices consider cq query emptiness cq q u v u
associate every individual variable v q individual name av set
aq av v conjunct r av av r v v conjunct
theorem let alcif tbox signature sig q cq q
empty given iff sig q aq unsatisfiable w r


fiq uery p redicate e mptiness

proof assume q non empty given abox
satisfiable w r certt q clearly implies sig q since otherwise
predicate sig q model predicate
interpreted empty set would mean certt q thus remains aq
satisfiable w r end let model since certt q exists
match q modify setting aiv v variables v used q readily checked
modified model aq thus aq satisfiable w r required
assume sig q aq satisfiable w r sig aq since
clearly certt aq q means q non empty given


expressive description logics
consider query predicate emptiness alc family expressive dls establishing tight
complexity alc alci undecidability alcf start upper bound
proofs showing iq query emptiness cq predicate emptiness alci ne xp ime cq query emptiness alc moreover establish cq query emptiness
e xp ime move corresponding lower bound proofs establish
undecidability considered emptiness alcf
upper bounds
first main step proofs deciding emptiness alc
alci suffices consider single special abox specifically construct
given satisfiable tbox abox signature canonical abox
every cq q certt q exists abox satisfiable
w r certt q prove ne xp ime upper bounds iq query emptiness alci computing exponential time guessing model
exponential size falsifies query e xp ime upper bound cq query
emptiness alci obtained even simpler way computing checking
whether certt q known significantly work required obtain
ne xp ime upper bound cq query emptiness alc construct need
exercise lot care check whether certt q without leaving ne xp ime
let satisfiable alci tbox abox signature define canonical abox
introduce well known notion types hintikka sets pratt kaminski
schneider smolka closure cl smallest set contains
nc well concepts occur potentially subconcept closed
single negations type set cl model
ti ti c cl c type
realized let tt denote set types role name r
tt say pair r coherent write r
c whenever r c
c whenever r c
seen implies corresponding conditions existential restrictions
c r c cl c implies r c


fibaader b ienvenu l utz w olter

definition canonical abox let satisfiable alci tbox abox signature
fix distinct individual name tt canonical abox defined
follows
tt nc
r r tt r nr
cardinality tt exponential size cardinality
set tt computed exponential time making use well known e xp ime procedures
concept satisfiability w r tboxes alci gabbay kurucz wolter zakharyaschev
p thus exponential size computed exponential time interesting
note abox finitary version canonical model basic modal logic
essentially identical model constructed pratts type elimination procedure pratt
fact exactly identical sig satisfiable w r
lemma let satisfiable alci tbox abox signature satisfiable
w r
proof let interpretation defined setting


tt

ait

tt

rit

tt tt r

nc r nr one prove induction structure c c
cl c iff c definition types c v c imply
thus model immediate consequence definition
model fact regarded reduct signature

crucial tool analyzing properties canonical aboxes introduce homomorphism
aboxes let aboxes abox homomorphism total
function h ind ind following conditions satisfied
implies h
r b implies r h h b
next lemma identifies central property abox homomorphisms regarding query answering
lemma alci tbox q cq q h abox
homomorphism q h h
proof prove contrapositive thus assume q h h
model q h h define model starting

reinterpreting individual names ind setting ai h ind since
individual names occur model model
h definition abox homomorphisms since model definition
follows ai ai case r b analogous finally q h h
definition yield q thus shown q



fiq uery p redicate e mptiness

following lemma characterizes satisfiability aboxes w r existence abox
homomorphism
lemma let satisfiable alci tbox abox signature abox satisfiable
w r iff abox homomorphism
proof assume satisfiable w r let model define homomorphism h
setting h type realized ai
definition one see h indeed abox homomorphism conversely let h
abox homomorphism lemma satisfiable w r proof
lemma shows one construct model model
homomorphism h thus satisfiable w r

ready prove main property regarding emptiness discussed
beginning section
theorem let satisfiable alci tbox abox signature cq q empty
given iff certt q
proof direction follows directly fact satisfiable w r
lemma direction let certt q q empty given
take abox satisfiable w r lemmas certt q implies
certt q required

employ theorem prove ne xp ime upper bounds iq query emptiness
theorem alci iq query emptiness ne xp ime
proof let satisfiable tbox abox signature v iq emptiness
given decided employ following
fact abox exists model ai ai
ind
proof fact exists model j aj aj
may assume aj ind disjoint domain tt interpretation
defined proof lemma assume define union
restriction j aj ind interpretation expanded adding ri
pairs
aj tj aj r ind tt
aj r tj aj ind tt
model ai ai required size finishes proof fact
ne xp ime computes canonical abox exponential time guesses
every ind model ia ia ind returns yes
ind
ia model


fibaader b ienvenu l utz w olter

aia aia
conditions checked exponential time thus theorem fact
returns yes iff v empty given

note theorem cq predicate emptiness alci ne xp ime well cq query
emptiness alci easily derive e xp ime upper bound
work calvanese et al complexity query answering dls
theorem alci cq query emptiness e xp ime
proof e xp ime obtained first computing canonical abox
certt q checking whether latter empty done e xp ime since
shown work calvanese et al q alci tbox
p n
set certt q computed time p
p polynomial size
n size q

provide improved ne xp ime upper bound cq query emptiness alc
allow us alc three emptiness complexity
theorem alc cq query emptiness ne xp ime
proof somewhat technical reuses machinery fork rewritings spoilers introduced
lutz proves combined complexity cq answering dl shq
e xp ime concretely one decide emptiness cq q abox
signature given alc tbox guessing extension aet canonical abox
assertions prevent possible match q checking aet satisfiable w r
example q x obviously suffices add every individual
allow complex concepts used abox general case requires careful
analysis assertions considered additions mentioned
fork rewritings spoilers enter picture fact used prove since
inverse roles tbox suffices consider extensions contain additional
individual names additional assertions taken candidate set whose size
polynomial size q remains satisfiability aet
decided non deterministically time single exponential size q full details
given appendix
lower bounds undecidability
prove matching lower bounds upper complexity bounds presented undecidability iq query emptiness cq predicate emptiness cq query emptiness alcf
undecidability proof ne xp ime lower bound proof reduction two different
tiling first asks tiling finite rectangle unbounded size
second asks tiling n n square e xp ime lower bound cq query emptiness alci straightforward reduction query entailment alci begin
ne xp ime lower bound
theorem alc cq predicate emptiness ne xp ime hard


fiq uery p redicate e mptiness

proof proof reduction ne xp ime hard n n tiling instance
tiling given natural number n coded unary triple h v
non empty finite set tile types including initial tile tinit placed lower left
corner h horizontal matching relation v vertical matching relation
tiling h v map f n n f tinit
f j f j h n f j f j v j n
ne xp ime complete decide whether instance n n tiling tiling
reduction let n h v instance n n tiling
tp construct signature tbox alc h v
solution selected concept name cq predicate empty given
proof convenient impose una
formulating reduction tbox use role names x represent n n grid two binary counters x counting n counters use concept
names x xn yn bits respectively contains following inclusions stating value counter x xn incremented going
x successors value counter yn incremented going successors
k n

u

j k





j k

xj v xk x xk u xk x xk

xj v xk x xk u xk x xk

similarly yn states value counter x change
going successors value counter change going xsuccessors n
xi v xi

xi v xi

yi v x yi

yi v x yi


addition states counter x n x successor
counter n successor
x u u xn v x

u u yn v

states tinit holds tiling complete
x u u xn u u u yn v tinit
states tiling condition violated true
j p ti u tj v
j p ti tj h ti u x tj v
j p ti tj v ti u tj v


v



ip

ti

fibaader b ienvenu l utz w olter

finally since cannot use negation aboxes states concept names x x n
n equivalent x xn yn respectively
n
xi v x xi v x yi v yi v x
set x x xn yn x x n n
claim h v n n tiling iff exists abox satisfiable w r
v v
proof claim assume first h v n n tiling construct regard
pairs j n j n individual names let x j j
n j j j n set xk j kth bit
x k j kth bit yk j kth bit j k j
kth bit j readily checked satisfiable w r v v
conversely assume h v n n tiling given f n
n let abox satisfiable w r v v
let model ai done otherwise define interpretation
tp follows associate every uniquely determined pair id jd
given values counters x set tki iff f id jd tk let
ai readily checked resulting interpretation still model

follows preceding iq query emptiness cq query emptiness
alc alci ne xp ime hard cq query emptiness alci easily derive
e xp ime lower bound complexity query entailment alci
theorem alci cq query emptiness e xp ime hard
proof shown lutz cq entailment alci e xp ime hard already
aboxes form boolean cqs clearly strengthened empty
aboxes replace empty abox compensate adding tbox v
r r fresh role name thus remains observe boolean cq q entailed
empty abox iff q non empty

simple addition functional roles alc leads undecidability cqpredicate emptiness thus iq query emptiness cq query emptiness proof
reduction tiling asks tiling rectangle finite size neither
fixed bounded reduction involves couple technical tricks concept
names universally quantified second order variables allows us enforce
grid structure standard frame axioms modal logic second order nature
reduction requires role names functional inverse functional since inverse
functionality cannot expressed alcf use modal logic frame axiom enforce
different forwards functional role name interpreted inverse role name
interested course undecidability carries variants alcf use concept
constructor r instead functional roles additional sort dls qualified
unqualified number restrictions
theorem alcf cq predicate emptiness undecidable


fiq uery p redicate e mptiness

instance aforementioned tiling given triple h v non empty
finite set tile types including initial tile tinit placed lower left corner final tile
tfinal placed upper right corner h horizontal matching relation v
tt vertical matching relation tiling h v map f n
n f tinit f n tfinal f j f j h n
f j f j v undecidable whether instance tiling
tiling
reduction let h v instance tiling tp
construct signature tbox h v solution selected
concept name cq predicate non empty given
abox signature tp x x tp used concept
names x x functional role names use role names x represent horizontal vertical adjacency points rectangle role names x
simulate inverses x use additional auxiliary concept names particular u
r mark upper right border rectangle zc zc zx zx zy zy serve
second order variables c serves flag indicates grid cells closed position
set ix iy similar flags intended behavior role names x x
concept name propagated grid upper right corner lower
left one ensuring flags set everywhere every position grid labeled
least one tile type horizontal vertical matching conditions satisfied
lower left corner grid reached set flag query v v asks

tbox defined set following cis ti tj range triples
ti tj h ti v e c x ranges
boolean combinations concept names ze ze e concepts l u l li
ze ze
tfinal v u u u r
x u u u tj u ix u ti v u u
r u u u iy u ti v r u
x tj u u u u u x u ix u iy u c u ti v
u tinit v
bx u x x bx v ix
u v iy
x bc u x bc v c
u v r v x u v x u

r v r



tp

ts u tt v

cis ix iy responsible enforcing x inverse x inverse
least abox individuals interested fact abox contains
assertions x b x b c thus violates intended interpretation x x
interpret zx zx left hand sides possible instantiations ci
ix violated e g making zx zx true false c abox contains
x b x b possible since x functional thus enforce x


fibaader b ienvenu l utz w olter

inverse functional cis c achieve similar way closing grid cells e
x successor x successor every relevant abox individual coincide however
seen proofs works x inverse functional
establish theorem suffices prove following lemma see appendix details
lemma h v admits tiling iff abox satisfiable
v v

el horn extensions
study query predicate emptiness dl el several horn extensions first
plain el three emptiness decided polynomial time reason
case exponential size canonical abox section replaced
total abox contains single individual instance predicates
note satisfiable w r el tbox el cannot express unsatisfiability
works eli case one obtains e xp ime upper bound
optimal since subsumption eli already e xp ime hard baader et al
soon unsatisfiability expressed situation changes drastically fact
even el subsumption standard reasoning tasks still tractable versions
emptiness e xp ime hard nevertheless emptiness horn extensions el turns
easier emptiness expressive dls contrast undecidability alcf
ne xp ime hardness alc emptiness e xp ime even horn alcif
reason unraveling tolerance horn description logics observed work lutz
wolter implies looking aboxes witness non emptiness
restrict tree shaped ones enables use automata theoretic techniques
decide emptiness
el eli
begin showing el cq query emptiness cq predicate emptiness iq query
emptiness pt ime proofs transparent simple signature total
abox r r
lemma let el tbox signature cq q empty given iff
certt q
proof proof simplified version proof theorem contrapositive
direction follows fact satisfiable w r direction let
certt q q empty given take abox define abox
homomorphism setting h ind lemmas
certt q implies certt q required

lemma provides polytime reduction cq query emptiness therefore iq query
emptiness cq predicate emptiness query evaluation cqs
appendix due simple shape checking whether certt q
done polynomial time fact give polytime procedure returns certt q
succeeds constructing boolean forest shaped query qb empty given iff q


fiq uery p redicate e mptiness

construction relies fact immediate consequence proved lutz
wolter emptiness q given implies existence model
certt q shape tree extended reflexive loops root
checking qb requires answer concept queries extension elu el
universal role possible pt ime lutz wolter obtain following

theorem el iq query emptiness cq query emptiness decided pt ime
matching pt ime lower bound theorem shown reduction subsumption
el pt ime hard haase consider el tbox el concepts c
ci c v follows iq b v non empty signature
given tbox v c v b b concept names appear c
thus obtain
theorem el iq query emptiness cq query emptiness pt ime hard
observe lemma materializability el obtain cq predicate emptiness
pt ime complete well el
note need little proof lemma go suffices total
abox satisfiable every tbox thus reduce emptiness query answering
total abox extension el unable express contradictions another
important example consider eli since cq evaluation eli e xp ime complete
obtain e xp ime upper bound case matching lower bound obtained
e xp ime hardness subsumption eli simple reduction subsumption iq query
emptiness given
theorem eli iq query emptiness cq query emptiness e xp ime complete
follows lemma materializability eli cq predicate emptiness e xp imecomplete eli
horn extensions involving negation functionality
simplest extension el express unsatisfiability el begin showing
iq emptiness el e xp ime hard thus significantly harder subsumption instance checking decided polynomial time end first
decide iq query emptiness el sufficient consider emptiness w r directed treeshaped aboxes abox called directed tree shaped following conditions hold
directed graph gda ind b r b tree
b ind one role name r r b r b
one case
proposition instance query b v non empty signature given el tbox iff
exists directed tree shaped abox satisfiable w r b
root


fibaader b ienvenu l utz w olter

proof provide sketch since follows general proposition proved assume b v non empty given abox
satisfiable w r b let potentially infinite abox obtained
unfolding follows individuals words r rn
ri ai ai n include r rn iff
include r r r rn rn one satisfiable w r since b iff b compactness first order
consequence obtain finite abox b required

theorem el iq query emptiness e xp ime hard
proof let b v given proposition b v non empty given iff
exists directed tree shaped abox witness non emptiness b v
given directed tree shaped aboxes viewed el concepts symbols
vice versa thus witness abox exists iff exists el concept c
symbols c satisfiable w r c v b following
established carefully analyzing reduction underlying theorem work lutz
wolter given el tbox signature concept name b e xp ime hard
decide exists el concept c symbols c satisfiable
w r c v b establishes e xp ime hardness non emptiness fact
e xp ime coe xp ime hardness transfers iq query emptiness

observe lemma materializability el obtain cq predicate emptiness
e xp ime hard well el
instead proving matching e xp ime upper bound emptiness el
expressive horn dl horn alcif el fragment fact rest
section devoted proof following theorem interesting contrast
undecidability emptiness alcf
theorem horn alcif cq query emptiness e xp ime
strategy proof theorem follows first exhibit polynomial time reduction
cq query emptiness horn alcif cq query emptiness elif
non emptiness cq q elif tbox witnessed aboxes certain
forest shape consider canonical forest shaped aboxes tbox
consideration constructed chase procedure special kind
materialization cf section answers returned model precisely certain
answers central observation matches q canonical forest shaped aboxes
grouped equivalence classes induced certain splittings q finally
construct equivalence class tree automaton decides existence
forest shaped witness abox whose canonical model admits match q falls class
throughout proof generally impose una
begin reduction cq query emptiness elif fact reduction even
shows suffices consider elif tboxes normal form mean
cis take one forms
u u v b

v r b


r v b

fiq uery p redicate e mptiness

b nc r role name inverse role
proposition every horn alcif tbox abox signature cq q one construct
polynomial time elif tbox normal form q empty given iff q
empty given
proof proposition standard given appendix follows assume
elif tboxes normal form
next define canonical let elif kb satisfiable
w r construct typically infinite canonical model start viewed
interpretation ind ait rit b
r b exhaustively apply following completion rules


u u v ai n
ait add
ait
r v b e rit e ait
b add b
v r b ait
r b funct r
















r
add e r
e

b
e fresh
element
b add e
v r b funct r ait e rit e



b

construction rendered deterministic ordering inclusions domain
elements decide among different possible rule applications reason may speak
canonical model call model u universal homomorphism u
model function h u au implies h ai
e ru implies h h e ri h au ai ind important
property universal fact following standard prove omit
details see example work lutz wolter
lemma let elif tbox abox satisfiable w r
universal model
let elif tbox abox satisfiable w r easy consequence
lemma abox witness cq q non empty given
satisfiable w r match q
next step proof theorem establish proposition constrains shape
aboxes considered deciding emptiness elif follows
abox called tree shaped
undirected graph ga ind b r b tree
readers wondering relationship universal materializations defined section
remark every universal model tbox abox materialization conversely
materialization exists universal model lutz wolter



fibaader b ienvenu l utz w olter

b ind one role name r r b r b
one case
working tree shaped aboxes often designate one individuals root
root tree shaped abox fixed use denote restriction
individuals b whose unique path root ga contains call b ind
r successor resp r successor ind r b resp r b
consider rooted tree shaped interpretations tree shaped queries defined analogously
tree shaped aboxes
abox forest shaped aboxes ak following
conditions satisfied
union ak
k ind
j k ind ai ind aj ind ai ind
k ai tree shaped abox rooted individual ind
call root component ak tree components width k
degree smallest number n every tree component ai every ind ai
number assertions r b r b ai bounded n following proposition
clarifies role forest shaped aboxes witnesses non emptiness
proposition let elif tbox abox signature q cq q non empty
given witnessed abox forest shaped width q
degree
proposition proved appendix taking witness abox selecting part
size q identified match q serves root component forest shaped
abox unraveling infinite abox starting selected part afterwards removing
unnecessary individual names obtain desired degree finally applying compactness
make resulting witness finite
clearly assume w l g forest shaped witness aboxes according proposition individual names used root component taken fixed set ind cardinality
q make assumption without notice follows
next analyze matches forest shaped aboxes splitting query components similar splittings queries used appendix b simpler forest
splitting cq q tuple f q q q qn q obtained q identifying variables q q qn partition atoms q var q ind
following conditions satisfied
q qn tree shaped
var qi var q n
var qi var qj j n


fiq uery p redicate e mptiness

let elif tbox forest shaped abox root component match
q note consists extended potentially infinite trees attached
abox individuals generated completion rules type f
q q q qn q obtained q identifying variables sends
element q consists atoms q matches part q qn
maximal connected components q q restriction range ind note
matter match choose maximal connected components q q must
tree shaped match tree shaped part consists tree component
plus attached trees generated completion rules thus every match type
following immediate wt q f denotes set forest shaped aboxes width
q degree admit match q type f
lemma let elif tbox abox signature q cq q empty
given wt q f empty every forest splitting f q
let elif tbox normal form abox signature q cq
assume want decide whether q empty given lemma suffices check
whether wt q f empty every forest splitting f q
note defining set wt q f possible definition forest splitting
refer particular abox turn due use fixed set individual
names ind root components forest aboxes fact first quantifying forest splittings
lemma quantifying forest shaped aboxes testing emptiness
wt q f essential obtaining single exponential time upper bound since number
forest splittings single exponential q obtain bound test emptiness
wt q f time single exponential q achieve constructing
forest splitting f q two way alternating parity automaton infinite trees twapa af
accepts non empty language wt q f note infinite trees needed
automata take trees input represent finite forest shaped abox
potentially infinite model
start introducing necessary background twapas let
denote positive
integers tree non empty potentially infinite set closed prefixes
node root use standard concatenation words nodes trees
convention take x x x x x note
undefined node x said child node x x called parent
x slightly depart vardis original definition twapas vardi working
trees full define ary tree tree whose nodes
rather exactly children w l g assume nodes ary tree
infinite path p prefix closed set p every n
unique x p x n
set x use b x denote set positive boolean formulas x e
formulas built conjunction disjunction elements x used propositional variables special formulas true false allowed well alphabet
labeled tree pair v tree v node labeling function

n

n

n
n
n

definition twapa two way alternating parity automaton twapa ary trees
tuple f finite set states finite alphabet


fibaader b ienvenu l utz w olter

b tran transition function tran hii set
transitions initial state f g gk sequence subsets
satisfying g g gh called parity condition
intuitively transition hii means copy automaton state sent
th successor current node required exist contrast transition
sends copy th successor exists transitions hii
interpreted similarly indicates sending copy predecessor indicates sending
copy current node note transition h cannot applied root
definition run acceptance run twapa f labeled tree
v labeled tree x
v x implies possibly empty set dn sn tran
satisfies n
di hji x j defined x j x j si
di j x j defined belongs x j si
given infinite path p denote inf p set states q infinitely
many p form q say run accepting
infinite paths p exists even k inf p gk inf p gk
labeled tree v accepted accepting run v use
l denote set labeled trees accepted
note original definition twapas vardi uses transitions form
hii q since hii q q coincide full ary trees easy
see emptiness version twapas reduced polynomial time emptiness
twapas original definition since encode ary trees full ary trees vardi
shown emptiness twapas e xp ime complete precisely
given twapa f decides whether l runs
time exponential cardinality polynomial cardinality size
remind reader given two twapas ai si
easy construct polynomial time twapa l l l
state set
make accessible twapas encode forest shaped aboxes width q
degree ary trees q already mentioned
tree additionally encodes model encoded abox explain alphabet used
shape trees detail root node labeled element alphabet
r consists sig aboxes ind ind ii r b implies r
iii satisfies functionality statements let sub denote set concepts
occur subconcepts non root nodes labeled elements alphabet n
consists subsets
nc sub r r r nr occurs ind b v r


fiq uery p redicate e mptiness

contains exactly one role name inverse role ii one element ind
iii role name inverse role exactly one element form
latter case
tree ht labeling described supposed represent forest shaped abox aht together model iht abox individuals aht
abox labels root plus non root nodes whose label contains
marker nodes denote domain elements iht identified
abox individual assertions aht concept role memberships iht
represented labels ht note abox sig abox whereas aht uses
signature fact assertions part aht assertions
part iht
need impose additional conditions make sure r n labeled tree ht
indeed represents abox model intended call ht proper satisfies following
conditions x
root labeled element r nodes element n
x n contains element ind x child root element
ind otherwise
take path remove root node carries special label
nodes whose label contains form finite possibly empty prefix resulting path
child x n b v r one
following true
x root b x r
b x root ind b x r
roles individual names element labels describe elements connected
elements via roles aht iht particular successor root contains
role r individual name ind node represents r successor label
elements form serve special marking purpose x means
element x part iht aht since x cannot contain
satisfy concept inclusion b v r later need special markers make
sure iht model aht materialization aht
explanations subsequent definitions three conditions imposed elements
four conditions used define properness make sense reader
let ht proper r n labeled tree define aht iht formally let
abox labels root let restriction signature
abox aht described ht
aht x x nc x
r b x b r x r x b b r x
r x child x x r
r x child x x r


fibaader b ienvenu l utz w olter

interpretation iht follows
iht

ind



iht

x x nc

r

iht

b r b x r x x r x
x child x r x x child r x

ciht

c

c ind aht

apart represented abox instead interpretation aht identical
restriction iht individuals aht symbols particular means
iht model aht note abox aht forest shaped abox conversely
forest shaped abox width q degree define proper
ary r n labeled trees ht aht iht
let f q q q qn splitting q build twapa af ary
r n labeled trees accepts exactly trees ht aht wt q f
number states af polynomial q since checked time singleexponential number states whether l af obtain desired e xp ime upper
bound deciding whether wt q f construct af intersection following
twapas
aprop makes sure input tree proper
ensures input tree ht iht model
awf ensures ht satisfies certain well foundedness condition
amatch guarantees exploiting conditions ensured previous automata
input tree ht aht wt q f
construction first automaton aprop straightforward details left reader
note enforce condition proper trees automaton needs make use parity
acceptance condition co buchi condition would actually sufficient second twapa
ensures following conditions satisfied non root nodes x x input tree
r b funct r r x
funct r r x x x x
funct r x one child r additionally r x
child
u u v
u u v x x
v r b b r b b b
ii child x root r b x


fiq uery p redicate e mptiness

v r b x r x b ii r x
x non root parent b iii x child r b
r v b r b b ii child root
r b
r v b r x label root ii r x
x parent iii x child r b x
working exact details aprop left reader
ideally would third automaton awf ensure iht canonical model
aht however seem easily possible model constructed
applying completion rules certain order difficult simulate automatonnote
applying rules different order might construction interpretation
isomorphic one obtained following prescribed application order thus define
awf achieve crucial property canonical positive information concept
role memberships domain elements reason namely contained
aht logically implied aht together formalize terms
derivations

let ht proper r n labeled tree nc sub x ht
derivation x ht finite l labeled tree ht l set pairs x
nc sub x aiht require root labeled
x minimal nodes z z x one
following holds
x ind aht
x ci u u v children z zn z
zi ai x n
x ci r v child z z z x
x x riht moreover b x child z z
z b x
x ci v r funct r child z z
z x x x riht moreover b x child z
z z b x
x b x child z z z b x
x ci v r child z z z
x x x riht x child x ii x child
root x ind r x x
say ht well founded whenever x aiht nc
derivation x ht hard construct twapa awf accepts precisely
well founded proper r n labeled trees essentially automaton verify existence
required derivations implementing conditions transitions additionally
co buchi condition ensure finiteness derivation
next let f q q q qn automaton amatch checks


fibaader b ienvenu l utz w olter

match q iht
match qi iht v var q var qi v v
amatch easy construct omit details announced define af
accepts intersection languages accepted aprop awf amatch remains
wt q f empty iff l af empty
first clarify relation well foundedness canonical universal call proper r n labeled tree ht canonical iht canonical
model aht ii every x x concept x
element x created due application third completion rule inclusion
form b v r parent x
lemma
proper r n labeled tree canonical well founded
ht proper r n labeled tree well founded iht model
iht universal model aht
proof lemma found appendix point established tracing applications
completion rules applied construct canonical model aht showing
addition make gives rise derivation point first one
make certain uniformity assumption derivations define homomorphism
iht model aht starting part iht corresponds root
component aht moving downwards along tree shaped parts iht
lemma wt q f iff l af
proof first assume wt q f forest shaped abox width
degree q satisfiable w r match q type f
let ht ary proper r n labeled tree satisfies aht canonical
ht l aprop since satisfiable w r iht model thus
ht l aprop point lemma ht l awf finally match witnesses
conditions definition amatch satisfied thus ht l amatch
done
conversely assume tree ht l af since ht l aprop aht
defined definition forest shaped abox width degree q
remains match q type f since ht l
l awf iht model ht well founded point lemma iht thus
universal model ht l amatch conditions definition
amatch satisfied verified consequently match q iht
type f composing homomorphism iht exists since iht
universal yields match q type f




fiq uery p redicate e mptiness

dl lite family
study query predicate emptiness dl lite family description logics calvanese
et al artale et al begin introduce dialects dl lite consider
basic concepts b defined
b









r

ranges nc r possibly inverse roles dl litecore tbox finite
set cis form b v b b u b v b b basic concepts thus
dl litecore included eli includes inverse roles included el dl litef
extension dl litecore functionality statements dl liter extension dllitecore role inclusions r v r roles dl liter logical underpinning
owl profile owl ql motik et al finally dl litehorn extension dl litecore
conjunctions basic concepts left hand side cis alternatively defined
fragment eli qualified existential restrictions r c replaced unqualified existential
restrictions r details refer readers work calvanese et al artale
et al calvanese de giacomo lembo lenzerini rosati
briefly discuss una dl lite dialects introduced first observe dllitehorn dl litef fragments alcif thus lemma query emptiness predicate emptiness dl litehorn dl litef oblivious whether una made
dl liter fragment alcif however straightforward dl liter
certain answers cqs depend whether one adopts una thus
dl liter query emptiness predicate emptiness oblivious whether una made
following proofs make una
main follows cq query emptiness conp complete dl lite dialects
conp lower bound holds already fragment dl litecore without role names
contrast complexity deciding iq query emptiness cq predicate emptiness depends
whether conjunctions admitted left hand side concept inclusions
conjunctions admitted dl litecore dl liter dl litef iq query emptiness
cq predicate emptiness nl og pace complete conjunctions admitted dllitehorn iq query emptiness cq predicate emptiness conp complete
lower bound holds already fragments dls without role names
note follows use theorem gives polynomial reduction
cq predicate emptiness iq query emptiness certain dls apply dl lite
dialects instead give direct proofs presented figure dl lite dialects
straightforward consequences established section
begin proving conp lower bounds let lcore dl admits cis v b
u b v let lhorn dl admits cis u v b u b v
b concept names
theorem lhorn iq query emptiness cq query emptiness cq predicate emptiness
conp hard lcore cq query emptiness conp hard
proof proofs reduction well known conp complete testing whether
propositional formula conjunctive normal form cnf unsatisfiable let k


fibaader b ienvenu l utz w olter

cnf formula v vn variables used ak concept names representing clauses av av avn avn concept names representing literals let
additional concept name set av av avn avn consider lhorn tbox
consisting following cis
avj u avj v j n
j v ai k j vj disjunct
u u ak v
straightforward u empty given iff u u empty given
iff unsatisfiable thus deciding iq query emptiness cq predicate emptiness cq query
emptiness lhorn conp hard conp hardness cq query emptiness lcore
drop last ci use cq u ak u instead

prove matching upper complexity bounds considering logics dl litecore dlliter dl litef dl litehorn end formulate general sufficient conditions
deciding emptiness pt ime conp say dl l polysize emptiness witness property whenever cq q empty given exists abox
polynomial size size q satisfiable w r certt q
lemma let l description logic polysize emptiness witness property
query evaluation cqs l np moreover assume satisfiability aboxes
w r l tboxes decided polynomial time cq query emptiness l conp
proof np deciding whether cq q empty w r guesses abox
polynomial size q ii tuple individual names ind appropriate
length iii polysize certificate certt q verifies polynomial time
satisfiable w r guessed certificate valid

theorem dl litecore dl liter dl litef dl litehorn deciding cq query emptiness
conp
proof conditions stated lemma shown calvanese et al artale
et al sketch proof polysize emptiness witness property assume certt q
cq q u v u tbox dls listed theorem statement
assume satisfiable w r use canonical model lemma
dl litecore dl litef dl litehorn used without modification since
fragments elif dl liter one add following completion rule
construction x rit r v add x sit let
match q recall consists restriction individuals ait
ind tree shaped interpretations ia attached ait let set assertions
use individual names ind exists v var q v ait
v ia moreover individual ind selected exists
role r b r b select one r b include let
clearly abox required polynomial size satisfiable w r subset
construction satisfies certt q




fiq uery p redicate e mptiness

say dl l singleton emptiness witness property whenever cq q form
v v v empty given exists abox containing one
assertion satisfiable w r certt q
lemma let l description logic singleton emptiness witness property
query evaluation cqs form v v v l nl og pace moreover assume satisfiability singleton aboxes w r l tboxes decided nl og pace
iq query emptiness cq predicate emptiness l nl og pace
proof non deterministic logarithmic space deciding whether cq form v
v v empty w r iterates aboxes containing one assertion
checks whether least one aboxes satisfiable w r satisfies v v
respectively individual ind

theorem dl litecore dl liter dl litef deciding iq query emptiness cqpredicate emptiness nl og pace complete
proof nl og pace upper bound conditions stated lemma shown
calvanese et al artale et al sketch proof singleton emptiness
witness property assume certt q cq q form v v v tbox
dls listed theorem statement assume satisfiable w r
consider case q v v case q v similar proof theorem
use canonical model let mapping v ait
consider uniquely determined ind v ait v ia
fact conjunctions occur left hand side cis one exists
single assertion form b r b abox consisting assertion
certt q follows desired witness abox
matching lower bound follows directly fact deciding whether v b
nl og pace hard tboxes dl litecore artale et al


case study application modularity
demonstrate usefulness emptiness two ways first carry case study
predicate emptiness medical domain use realistic ontology adds
significant number non empty predicates abox signature large
number predicates empty static analysis thus potentially non trivial user
manually distinguish non empty empty predicates second predicate
emptiness used produce smaller version tbox tailor made querying
given abox signature sense module tbox replacing potentially
much smaller module facilitates comprehension tbox thus helping query formulation
support claims experiments
case study use comprehensive medical ontology snomed ct provides
systematic vocabulary used medical information interchange enable interoperable electronic health records covers diverse medical areas clinical findings symptoms diagnoses procedures body structures organisms substances pharmaceuticals devices specimens


fibaader b ienvenu l utz w olter

concepts roles

iq
cq axioms
axioms
non empty non empty mod cq core

































































































figure experimental
snomed ct formulated el extended role inclusions removed experiments contains concept names role names use snomed ct
together abox signature real world application randomly generated abox
signatures real world signature obtained analyzing clinical notes emergency
department intensive care unit two australian hospitals natural language processing methods detect snomed ct concepts roles contains concepts roles
signature iq non empty predicates cq non empty predicates
computed thus snomed ct provides substantial number additional predicates query
formulation roughly identical number predicates abox signature however
numbers majority predicates snomed ct cannot meaningfully used
queries aboxes thus identifying relevant ones via predicate emptiness potentially
helpful somewhat surprisingly number cq non empty predicates
higher number iq non empty symbols
analyzed randomly generated signatures contain
concept names role names role names ontology every
signature contains special role name role group used snomed ct implement
certain modeling pattern present aboxes allow pattern
number concept role names generated signatures columns iq nonempty cq non empty figure numbers averages
experiments size additional experiments confirm findings real world
signature case substantial number additional predicates becomes available query
formulation large number predicates empty
come application modularity recall main motivation studying
emptiness support query formulation tboxes large complex difficult
understand whether tbox contains sufficient background knowledge given query q
non empty answer abox case clearly make sense
see current collaborative projects health information technologies laboratory university
sydney hitrl



fiq uery p redicate e mptiness

pose q abox tbox used background ontology similarly
hard whether tbox sufficiently powerful entail given predicate occur
query non empty answer abox case
predicate used formulating queries go one step instead
emptiness directly support query formulation use simplify tbox
precisely consider extracting hopefully small subset given tbox
gives exactly answers cqs iqs abox subset called
substitute w r cq iq respectively original tbox replace original
tbox answering cqs iqs respectively working small substitute instead
original tbox supports comprehension tbox thereby formulation meaningful
queries
beyond scope investigate substitutes depth instead
description logic eli predicate emptiness gives rise particularly natural kind substitute call cq core cq core obtained removing concept inclusions
contain predicate cq predicate empty w r tbox thus
cq core give answers cqs original tbox aboxes
appealing property predicates occur used meaningfully cq
querying aboxes
widely known semantic modules introduced grau et al
substitutes cq cores cannot larger semantic modules unless original
ontology contains tautological concept inclusions evaluate method practice compare
size cq cores modules extend case study snomed ct
extraction cq cores comparison modules start defining substitutes
formal way
definition let q iq cq substitute w r q
aboxes q q certt q certt q
aware substitutes according definition studied
closely related types modules example modules give answers
cqs formulated signature aboxes studied work lutz wolter
kontchakov wolter zakharyaschev konev ludwig walther wolter botoeva kontchakov ryzhikov wolter zakharyaschev romero kaminski
grau horrocks stronger version module provided modules require original tbox model conservative extension module regarding signature
studied konev lutz walther wolter gatens konev wolter
however important difference modules substitutes
latter restrict signature abox queries contrast mentioned
modules guarantee answers cqs formulated signature aboxes
particular follows minimal modules defined work kontchakov et al
konev et al general used substitute
eli therefore fragment el one use cq predicate
emptiness straightforward way compute substitute w r cq let tbox
abox signature cq core denoted tcq set concept inclusions
x sig cq predicate empty given



fibaader b ienvenu l utz w olter

theorem let tbox eli cq core substitute w r cq
thus w r iq
proof let cq core assume q abox consider
canonical model introduced section model
q sufficient model let c v
assume c v c let qc v tree shaped conjunctive
query corresponding c constructed standard way see appendix b formal definition
similar construction v qc v v qc v hence
v qc v x sig c cq empty given since c v
obtain v qd v qd v tree shaped conjunctive query corresponding
thus x sig cq empty given means c v
contradiction

note theorem cq core computed polynomial time el tbox
make simple observations regarding cq cores
theorem fails dls admit negation example v b b v e
substitute w r cq coincides cq core
empty
cq core minimal substitute w r cq consider example
v b v b b v b let v b v b
substitute w r cq cq core coincides
let iq core tbox defined analogy cq core iqemptiness instead cq emptiness iq core cannot serve substitute
w r iq even el tbox example let v r b r b v e
b iq empty given iq core empty however
empty tbox substitute w r iq since e
interestingly contrast modules discussed modules introduced grau
et al turn examples substitutes define modules let signature


two interpretations coincide w r x x x
subset tbox called semantic module w r every interpretation

interpretation coincides w r sig x x
sig model shown work grau et al extracting minimal
semantic module complexity standard reasoning subsumption
addition shown syntactic approximation called syntactic module computed
polynomial time every syntactic module semantic module necessarily
way around following lemma establishes relationship modules substitutes concept inclusion c v tautological c v
proposition let tbox formulated dls introduced let
semantic module w r
substitute w r cq


fiq uery p redicate e mptiness

sig contains predicates cq empty given
eli tbox contain tautological cis cq core
contained
proof point suppose q semantic module w r
abox let model q consider interpretation
coincides sig x remaining predicates x
model since semantic module w r model since
abox since shrank extension predicates transitioning
q q hence q required
point assume x cq empty given x sig suppose x
concept name case x r role name r similar left reader take
abox satisfiable w r v v let model

let interpretation coincides sig

remaining particular ai definition semantic modules model
derived contradiction shows v v
point assume formulated eli contains tautological inclusions let c v
definition semantic modules sig c v contains predicate
x sig otherwise c v tautology thus point sig c v
contains predicate cq empty given c v cq core
required

point use computing syntactic semantic modules
ones provided work grau et al substitutes large variety dls
point modules provide approximation set predicates
cq empty finally point means eli modules cannot smaller cq core
unless tautological concept inclusions general however modules larger
cq core tbox following example shows case already acyclic
el tboxes let
v r u r b r u r
predicates cq empty given r r hence
cq core contains first ci however non trivial semantic modules
w r thus syntactic ones
demonstrate potential usefulness substitutes cq core extending
case study medical domain use ontology snomed ct abox
signatures described beginning section analyzing size cq core comparing size original ontology syntactic module real world
signature cq core contains concept inclusions snomed ct thus
size original ontology module w r turns significantly
larger cq core containing axioms random signatures sizes cq cores modules shown two right columns figure confirm
findings real world signature cq core much smaller original ontology
module


fibaader b ienvenu l utz w olter

q uery c ontainment

q uery e mptiness

dl

iq

cq

iq

cq

el

e xp ime c

e xp ime c

pt ime c

pt ime c

el

e xp ime c

e xp ime c

e xp ime c

e xp ime c

eli horn alcif

e xp ime c

e xp ime c

e xp ime c

e xp ime c

pt ime

conp c

nl og pace c

conp c

conp c

p c

conp c

conp c

ne xp ime c

ne xp ime h

ne xp ime c

ne xp ime c

ne xp ime c

e xp ime c

dl litecore
dl litehorn
alc

ne xp ime
alci

ne xp ime c

ne xp ime c

figure query containment vs query emptiness

related work
query emptiness fundamental static analysis database queries
called query satisfiability xml example takes following form given
xpath query p dtd exist xml document conforms
answer p non empty complexity ranges tractable
undecidable depending xpath fragment see e g work benedikt et al
references therein dl context query emptiness first considered work lubyte
tessaris use step guide enrichment ontologies
query emptiness studied special case following query
containment first considered work bienvenu lutz wolter
regard pair q consists tbox query q compound query q called
ontology mediated query omq answers q certain answers q w r
bienvenu et al take two omqs qi ti qi q q iqs
cqs arity q contained q abox signature aboxes satisfiable w r certt q certt q case
write q q notion containment generalizes traditional query containment
dls calvanese et al relativizing abox signature admitting
distinct tboxes query emptiness iq q given clearly polynomially
reduced containment setting q q q x fresh concept
name similarly cqs deciding containment however often computationally harder
deciding query emptiness table summarizes known el dllite work bienvenu et al eli work bienvenu
hansen lutz wolter alc alci work bienvenu
et al bourhis lutz
query emptiness closely related explaining negative answers queries
studied example calvanese ortiz simkus stefanoni adopting abductive reasoning described follows assume q tbox abox
query q explain answer q one wants minimal aboxes e


fiq uery p redicate e mptiness

certain signature interest e satisfiable w r e q
aboxes e regarded explanation missing answer used debugging purposes shown work calvanese et al query emptiness iqs
boolean cqs reduces many one logarithmic space reductions deciding
existence explanation q dl litea reduction even works
unions conjunctive queries arity calvanese et al use observation obtain
lower complexity bounds explaining negative query answers exploiting published
conference predecessor baader bienvenu lutz wolter
conjecture conversely techniques proving upper complexity bounds query emptiness
ones used obtain upper bounds explaining negative answers

conclusion
investigated computational complexity query predicate emptiness el
dl lite alc families dls concentrating instance queries conjunctive queries
showing complexities range nl og pace undecidable highlighted
different dls query languages different kinds witness aboxes sufficient establish
non emptiness dls queries considered would interesting
investigate future work include following
dls include transitive roles role inclusions symmetric roles role inclusion axioms
horrocks kutz sattler kazakov
cases straightforward reductions presented possible
example iq query emptiness horn shif decidable e xp ime since every
horn shif tbox iq x abox signature one construct polynomial
time horn alcif tbox iff aboxes
hustadt et al kazakov cases cq query emptiness
horn shif seems reduction
dls include nominals
important classes queries unions conjunctive queries ucqs
materializable dls horn alcif
w ucq query emptiness reduced cq
query emptiness since every ucq q ii qi x q iff
qi simple reduction work non horn dls
alc
would interesting develop practical emptiness evaluate real world ontologies queries note el dl lite
easily implementable efficient presented actually confirmed
case study section work required design efficient expressive dls finally would relevant investigate notion substitute introduced
application modularity detail example open question compute minimal substitutes expressive dls alc practice involved
complexities


fibaader b ienvenu l utz w olter

acknowledgements
first author partially supported cfaed center advancing electronics dresden
second author partially supported anr project pagoda anr js
grateful julian mendez dirk walther supporting us case study would
thank anonymous reviewers provided excellent comments helped us improve


appendix proofs section
formulate proved
lemma let alcif tbox cq q empty given una iff
empty given without una
proof consider cq q answer variables v vn
assume q non empty given without una abox satisfiable w r without una certt q without una
take model suppose without loss generality infinite define
equivalence relation ind setting b whenever ai bi choose single
representative equivalence class denote representative equivalence
class containing let abox obtained replacing individual
satisfiable w r una certt q una
regarding satisfiability easy see model satisfies
una individuals appearing moreover since infinite reinterpret
individual names ni ind obtain interpretation model satisfies
una
showing certt q una take certt q without
una aim certt q let j model

satisfies una match q j vi ai j every

n consider interpretation j obtained j setting aj j every
ind easy see j model without una j q
match q j vi aj
every n
desired match q j finishes proof
assume q non empty given una abox
satisfiable w r una certt q una clearly
satisfiable w r without una remains certt q without
una let certt q una let model without
una q ind let ia following
unfolding ai
domain ia ia consists words r rk dk dk
r rk potentially inverse roles ai di di rii k
ri ri functional ri k r b b ind r
functional
aia r dk dk ai nc


fiq uery p redicate e mptiness

ria r dk r dk rk dk r rk
r dk rk dk r dk r rk r nr
assume ia mutually disjoint let individual name root ia
obtain interpretation j taking disjoint union ia ind adding b rj
whenever r b setting aj ind one j model
una thus j q match q j vi ai j
every n verified defined setting vi ai vi ind
vi dk v dk k match q thus q
required


appendix b proofs section
restate first proved
theorem alc cq query emptiness ne xp ime
general idea proving theorem follows given alc tbox signature
cq q theorem suffices test whether q thus start computing check whether q guess extension set
concept inclusions extension set abox assertions
satisfied q match subsequently remains
test satisfiability w r subtlety lies selecting class extensions
guessed careful enough way final satisfiability check carried
ne xp ime
reuse technical definitions work lutz proves
combined complexity cq answering dl shq e xp ime definitions
slightly modified since lutz considers cqs without answer variables uses dl shq
alc proper fragment however straightforward verify proofs given
lutz work modified definitions
cq q viewed directed graph gdq vqd eqd vqd var q eqd
v v r v v q r nr call q directed tree shaped gdq directed tree
r v v v v q implies r q directed tree shaped v root gdq call v
root q u var q write q u denote restriction q atoms contain
variables u set dtrees q directed tree shaped subqueries q defined follows
dtrees q q u u reachq v v var q q u directed tree shaped
reachq v set variables reachable v gdq say
q obtained q performing fork elimination q obtained q selecting two
atoms r v v v v v v v qvar q v v identifying v
v
q fork rewriting q q obtained q repeatedly necessarily exhaustively performing fork elimination


fibaader b ienvenu l utz w olter

q maximal fork rewriting q q fork rewriting fork elimination
possible q
following shown work lutz plays central role subsequent
definitions
lemma variable renaming every cq unique maximal fork rewriting
following definitions splittings spoilers taken work lutz understand splitting cq q intuitive level useful consider matches q model
tbox abox special shape consists core part whose elements exactly
interpretations abox individuals tree shaped parts attached
element core part disjoint fact proved lutz q
model described shape q match q model
described shape partitions variables q several sets set r contains variables matched abox individual sets sn represent disjoint tree shaped
subqueries q matched tree part whose root connected variable
r via role atom q set represents collection tree shaped subqueries
q disconnected variables r si addition partitioning splittings
record variable r set sn connected abox elements
variables r mapped define splittings formally
let k alc knowledge base q cq splitting q w r k tuple
hr sn r sn partitioning var q n r
assigns set si variable r r ind assigns variable r
individual splitting satisfy following conditions
cq q variable disjoint union directed tree shaped queries
queries q si n directed tree shaped
r v v q one following holds v v belong set r sn
ii v r v v si root q si
n unique r nr r v q v root q si
avar q r
let q directed tree shaped cq define alc concept cq v v var q
v leaf gdq cq v
otherwise cq v

u

v q

au

u c
u r c

v q

r v v q

q v

v root q use cq abbreviate cq v
following allow compound concepts negated roles used abox assertions semantics assertions corresponding kbs defined expected way
interpretation satisfies c ai c satisfies r b satisfy r b
let hr sn splitting q w r k q qk directed
tree shaped disconnected components q alc knowledge base spoiler q
k one following conditions hold


fiq uery p redicate e mptiness

v cqi k
atom v q v r v
atom r v v q v v r r v v
n r cq v root q si

r v q
call k spoiler q k every fork rewriting q q every splitting q
w r k k spoiler q k ii k minimal property following
proved work lutz
theorem let k alc knowledge base q cq k q iff
spoiler q k satisfiable w r
following lemma observed lutz plays central role obtaining ne xp ime
decision procedure
lemma let k alc knowledge base q cq q maximal fork rewriting
k spoiler q k k contains concept inclusions abox
assertions following form
v cq q dtrees q
ind occurring q
r b b ind r occurring q
ind r cq r occurs q q dtrees q
note definition spoiler q k refers fork rewritings q
exponentially many lemma refers unique maximal form rewriting q
fact since cardinality dtrees q clearly bounded size q number concept
inclusions assertions listed lemma polynomial size q
set proof theorem theorems cq q empty
signature given tbox iff spoiler q
satisfiable w r given cq q signature tbox thus decide emptiness
q given follows
compute
guess tbox abox satisfy conditions lemma kb
k role assertion r b r b
verify spoiler q
verify satisfiable w r


fibaader b ienvenu l utz w olter

remains argue yields ne xp ime already noted step carried
deterministic exponential time due conditions lemma since
size exponential tbox abox guessed step
size exponential size polynomial q step implemented
straightforward iteration fork rewritings q q splittings q w r
requires exponential time
thus remains deal step let closure single negations union
following sets concepts
nc
concepts occur possibly subconcepts
concept names occur q
concepts cq r cq subconcepts q dtrees q q maximal fork
rewriting q r occurs q
remark lemma easy verify crucial argument
polynomial q type set model
c c section introduce notion
coherence types say pair types r coherent denoted r
r c c implies r c set types computed e xp ime
verify satisfiability w r guess map ind accept
following two conditions satisfied reject otherwise
c c implies c c
ii r b c c c r c imply r c b
clearly checking whether two conditions satisfied done single exponential time
thus remains argue satisfiable w r case exists
map verifying conditions first note given model kb
define desired map setting c c ci c conversely given map
satisfying conditions ii define interpretation follows


ai

ri r

ci c

readily verified c c iff c
similar argument given lemma model
complete proof undecidability theorem proving lemma
lemma h v admits tiling iff abox satisfiable w r
v v
proof straightforward consider tiling f n
h v create individuals ai j n j consider abox
composed following assertions


fiq uery p redicate e mptiness

x ai j ai j n j
x ai j ai j n j
ai j ai j j n
ai j ai j j n
th ai j f j th
easily verified satisfiable w r satisfies v v
let abox satisfiable w r v v first
ix iy enforce x inverse x inverse respectively c
forces relevant grid cells closed r x call ind r defect exists
b ind r b r b call inv defect x defect
defect call ind cl defect exist x b c b x c e
e inv defect b defect c x defect
claim exists model ind
ai iri r defects ind r x
ai c cl defects ind
moreover satisfies following conditions ind role names r h p
ind
ai
ri implies r
thi implies th
proof claim let r x call two element set b r defect witness exists
c ind r c r c b consider undirected graph g nodes ind
set r defect witnesses edges note g degree two since r r
functional hence g three colorable choose three coloring g colors br zr uzr
br zr u zr br zr u zr
concept names
sand choose interpretation



zr zr correspondingly set ir br u r r br
call two element set e cl defect witness exist x b c b x c e
inv defect b defect c x defect consider undirected
graph g nodes ind set cl defect witnesses edges note g degree
two since x x functional hence g three colorable colors
c zc u zc c zc u zc c zc u zc
choose interpretation
concept names zc zc correspondingly set c x ci u x ci
since neither existential restrictions concept names th occur right hand side
cis hard verify interpret remaining concept names
way additional conditions satisfied end proof claim


fibaader b ienvenu l utz w olter

let model satisfying conditions claim additionally assume w l g
minimal model j satisfying conditions claim
aj ai j least one inclusions proper
let aa ai exhibit grid structure gives rise tiling h v
start identifying diagonal starts aa ends instance tfinal
claim set g r ai j ai j rk aik jk aik jk tfinal aik jk

j aa
k r x j j ii r
j j
proof claim sequence convert model j
interpreting false points reachable equivalently aa setting
aj ai aa contradicts minimality end proof claim
let n number occurrences role x abox g claim number
occurrences next
claim

tinit

b ai j ri implies n
c ai j u implies j
ai j ai j ind g
e ai j ind g unique th ai j thi henceforth denoted ti j
f ti j ti j h ai j ai j ind g ti j ti j v ai j ai j
ind g
proof claim point easy consequence fact aa aa ai
minimal b first note unique k n k
n due ci r v x ai j
ri

ais js
r suffices use cis r v x r v r proof
c similar prove f together showing induction f satisfied
initial parts
g r ai j ai j r ai j ai j
g k base case ai j aa ai clearly implies ai j thus
satisfied point e follows disjointness tiles expressed point f
vacuously true since single individual g induction step assume g
satisfies f distinguish four cases
ai j u u r


fiq uery p redicate e mptiness

since g satisfies ai j definition minimality together fact ai j u u r ensure
ai j x tg u u u th u u x u ix u iy u c u tf
tf tg h tf th v functionality x easy
g satisfies f
ai j u u r
since ai j ri ensures x successor ai j moreover
ai j together definition get
ai j tg u u r u iy u tf
tf tg v must j j r
functionality easy g satisfies f
ai j u u r
analogous previous case
ai j u u r
neither x successor successor ai j u u r follows
k contradiction k
end proof claim
next extend g full grid conditions e claim still satisfied
achieved trivial read solution tiling construction grid
consists exhaustive application following two steps
x ai j ai j ai j ai j g ai j ind g ai j ai j
g x ai j ai j g identify ai j ind ai j ai j
x ai j ai j add latter two assertions g
ai j ai j x ai j ai j g ai j ind g x ai j ai j
g ai j ai j g identify ai j ind x ai j ai j
ai j ai j add latter two assertions g
hard see exhaustive application rules yields full grid e final g
ind g ai j n j ii x ai j ai j g iff j j
iii ai j ai j g iff j j
since two steps construction completely analogous deal case
detail thus let x ai j ai j ai j ai j g ai j
ind g clearly n
j b c thus ai j
r u since ai j
minimal get
ai j x tg u u u th u u x u ix u iy u c u tf
tf tg h tf th v together minimality means
select ai j b ind ai j ai j x ai j b ai j b ti j


fibaader b ienvenu l utz w olter

th choice e second half f clearly satisfied get properties
required step b ai j
satisfaction b c apply construction step cis
r v x r v r

u v u v x u

ensure b c still satisfied construction step showing b ai j
give us first half f finally prove b ai j sufficient ai j
cl defect ind follows claim since ai j c ai j ixi iyi ai j iyi
ai j ixi
use completed grid build solution tiling tile point
j unique tile satisfied ai j ind property f claim
correctness grid construction ensure adjacent tiles satisfy vertical horizontal
constraints


appendix c proofs section
theorem el cq query emptiness decided pt ime
proof lemma suffices n ary cq q alphabet decided
pt ime whether q total abox first note
q iff ab qb
ab obtained adding assertion x x concept name
occur q
qb boolean cq obtained q adding conjunct x v answer variable v
quantifying away answer variables
recall discussion lemma every cq q viewed directed graph
gdq say boolean cq q directed forest shaped disjoint union directed treeshaped boolean cqs every boolean cq q directed forest shaped corresponds concept
cq description logic elu extends el universal role u q iff
c ind lutz wolter checking latter condition possible
pt ime lutz wolter thus sufficient convert qb polynomial time directed
forest shaped cq qb ab qb iff ab qb
construct qb qb exhaustively apply following rewriting rules
r v v r v v query identify v v replacing occurrences
v v
r v v v v query r identify v v v replacing
occurrences v v v
cycle r v v rn vn vn vn v query v vn contains
least two variables identify variables v vn replacing occurrences
v vn v


fiq uery p redicate e mptiness

resulting query contains reflexive loop r v v r
immediately return
otherwise replace final step reflexive loop r v v r x v
query resulting last step qb easy see query obtained point
directed forest shaped since every variable one predecessor cycles
corresponding directed graph
prove correctness first establish following claim
claim qb defined ab qb iff ab qb
suffices prove rule application preserves non entailment query ab
preliminary recall shown lutz wolter exists materialization
jt ab ab directed tree shaped interpretation individual root
potentially additional reflexive loops added root interpretation directed treeshaped corresponding cq domain elements interpretation regarded
variables directed tree shaped assume rewriting rule applied query p resulting
query p clear ab pb implies ab pb converse assume ab pb
let jt ab materialization ab introduced match p
jt ab since jt ab contain domain elements
j

j

role name r r ab r ab match p jt ab must map
identified variables v v domain element thus match p
two rules replacement r v v r x v dealt similar way
claim substitute qb qb intended moreover easy see
ab qb returns due reflexive loop r v v r
simply use
interpretation jt ab proof claim

proposition every horn alcif tbox abox signature cq q one construct
polynomial time elif tbox normal form q empty given iff q
empty given
proof proof similar reductions provided work hustadt et al
kazakov nevertheless kazakov considers reductions preserving subsumption
hustadt motik sattler kazakov reduce elif tboxes
give detailed proof
following rules used rewrite elif tbox normal form freshly
introduced concept names sig sig q assume l v r given
l form l u l r concept name take fresh concept name
replace l v r l v v r r concept name l l
concept names take fresh concept names replace l v r l v
l v u v r
l form l l r concept name replace l v r l v r
l v r otherwise take fresh concept name replace l v r l v v r
l form r l l concept name take fresh concept name
replace l v r l v r v r
r form replace l v r l u v


fibaader b ienvenu l utz w olter

r form r u r l concept name take fresh concept name
replace l v r l v v r otherwise take fresh concept names
replace l v r l v l v v r v r
r form l r replace l v r l u l v r
r form r r r concept name take fresh concept name
replace l v r l v r v r
r form r r replace l v r r l v r
resulting tbox required particular every abox model
model conversely every model extended
model appropriately interpreting fresh concept names consequently
certt q certt q thus q empty given iff q empty given

proposition let elif tbox abox signature q cq q non empty
given witnessed abox forest shaped width q
degree
proof assume q answer variables v vn non empty given
abox satisfiable w r certt q identify forestshaped witness non emptiness q given consider canonical model
construction consists abox part restriction
ind tree shaped interpretations ia ind rooted containing abox
individuals since universal match q let consist individuals
ind v var q v ia possibly v let
abox obtained restricting individuals going root component
forest shaped witness seeking define observe ind q add
tree components consider typically infinite tree shaped abox aua
obtained unraveling starting work lutz wolter
ind aua set sequences c r c rm cm c cm ind
r rm possibly inverse roles c ii c iii rj cj cj

j iv cj rj
cj rj j say copy
cm
c ind aua copy c aua
ind aua copy c rc ind aua r aua
ind aua copy c r c ind aua r aua
let ab union tree shaped aboxes aua observe conditions
b note
ii iv first item since satisfies functionality statements
b
forest shaped need neither finite degree going fix
later
next aim ab satisfiable w r certt ab q end
construct universal model j ab start ab viewed interpretation j


fiq uery p redicate e mptiness

construction canonical take ind copies
b copy tree interpretation ia root ii j
ind
iii implies disjointness iv identical original
tree interpretation ia copy renaming ia
called copy desired interpretation j obtained taking union j
note every element j copy element construction j
b
model
straightforward induction structure c every eli concept c
every element e j copy e c j iff c since
model follows j model thus ab satisfiable w r sketch
proof j universal let model ab start define homomorphism h
b remains extend h components
j setting h ai ind
j copy tree interpretation ia copy shown
work lutz wolter
b copy ind ait implies ab concept
ind
names
recall generated derivation rules building canonical
straightforward induction number rule applications exploiting fact
normal form one construct homomorphism ha ia h
renaming obtain homomorphism h h desired
homomorphism h union h h thus established j universal going
construction j particular point iv verified match
q match q j since j universal yields certt ab q desired
want remove individuals ab resulting abox degree
still witnesses non emptiness q given since j universal homomorphism h j canonical model ab composing match h obtain match
q ab sends every variable individual element tree
individual inductively mark individuals ab relevant match starting
individuals proceeding follows whenever rule adds marked individual
x ait ab construction ab presence x rit please see
formulation mentioned rules mark verified every individual outside
one marked neighbor existential restriction potentially infinite forest shaped abox abd obtained ab dropping assertions involve least one
unmarked individual thus degree moreover marking construction ensures
canonical model abd contains interpretation ia ind hence match
q abd
point abox abd almost required forest witness except may infinite
remains invoke compactness obtain finite subset abf abd certt abf q
clearly abf contains forest witness non emptiness q given

lutz wolter actually case root component ab start
unravel consists individual names contains concept role assertions proof goes
case



fibaader b ienvenu l utz w olter

following lemmas establish two statements lemma
lemma every canonical proper r n labeled tree well founded
proof let ht canonical proper r n labeled tree let interpretations encountered construction canonical model aht since ht
canonical iht canonical model aht
slightly abuse terminology term concept atom refer statements
form b e b concept name e domain element role atom take
form r e e r role e e domain elements say concept atom b e resp
role atom r e e interpretation j e b j resp e e rj atom
iht rank smallest ii induction rank
every concept atom iht derivation thus ht well founded
induction start straightforward concept atoms involve concept
element x x ind x x
every atom derivation depth induction step let b x concept atom
ii ii consider rule application resulted addition b x
assume b x ii application rule u u v
b x aij j n
every j n atom aj x rank ih derivation
htj j aj x obtain derivation ht b x setting jw w
tj b x jw j w
assume b x ii application rule r v b
x r ii
x r ii must exist ii x rii aii
atom rank ih derivation ht
x x ind aht define derivation ht b x setting
w w b x w w
next consider case x x ind aht properness
concept e nc e x since x x ii
j x ij ij since ht canonical element x created
due application rule concept inclusion form f v e x e ij
applying ih obtain derivation ht e x thus define derivation
ht b x setting w w w w b x
w w w w
assume b x ii application rule involving v r b
ii aii x rii rii
atom rank ih exists derivation ht
moreover since x created applying inclusion v r b second
condition canonicity ensures b x thus define derivation b x
taking tree ht w w b x w w


fiq uery p redicate e mptiness

assume b x x ii application rule involving v
r e e ii aii x rii rii
atom rank ih exists derivation ht
moreover since x created applying inclusion v r e second
condition canonicity ensures e x thus define derivation x
taking tree ht w w x e x
w w
assume b x ii application rule v r b
funct r aii x rii
atom rank ih exists derivation ht
x obtain derivation b x taking tree ht w
w b x w w x use
argument point derivation ht e x obtain derivation
ht b x setting w w w w b x
w w w w

lemma let ht proper r n labeled tree well founded iht
model iht universal model aht
proof assume ht well founded proper r n labeled tree iht model
obligation pair x x x every obligation
x choose derivation hta x x x ht minimal depth obligations x x write x x x occurs node label
hta x x
claim relation acyclic
proof claim assume contrary obligations x xn
ai xi ai xi n xn x may assume without loss generality j n ai xi aj xj e obligations
x xn pairwise distinct let ki depth htai xi ai xi
depth shallow derivation ai xi contained htai xi ai xi
htai xi ai xi minimal depth ki moreover clearly ki
thus shown k kn n consequently derivation x
hta x x must start root htai xi ai xi implies x x
contradiction fact obligations distinct finishes proof claim
claim assume w l g chosen derivation hta x x node
labeled b subtree hta x x rooted node chosen derivation
htb b uniformity assumption
prove iht universal model aht take model aht
homomorphism h iht constructing h step step fashion
start set h ai individual names occur aht extension
h argue


fibaader b ienvenu l utz w olter

x aiht concept name h x defined hta x x uses elements
domain h h x ai
x riht r role h x h defined h x h ri
x riht child x h defined h x defined
start observing initial mapping h point trivial since model aht
role edges restriction iht domain h aht point use
fact individual aht x parent properness implies
x individual aht hence x belongs domain h
point proved induction depth hta x x induction start consider
depth zero x ind aht x aht since model aht
definition h h x ai
induction step assume hta x x uses elements domain h
definition derivations gives rise following cases
x ci u u v n child
z z ta x x z ai x
n let zi child z x zi ai x subderivation
hta x x rooted zi chosen derivation htai x ai x ai x follows
htai x ai x uses elements domain h depth strictly smaller
hta x x therefore apply induction hypothesis get h x aii since
model u u v obtain h x ai
x ci r v child z z ta x x z x
x x riht
subderivation hta x x rooted z chosen derivation hta x x
x thus contains elements domain h strictly smaller depth
hta x x thus use ih infer h x b use point
get h x h x ri since model r v h x ai
x ci v r funct r child z z ta x
x z x x x riht
previous item use ih point get h x b h x h x
ri since model contains v r funct r follows
h x ai

x b x child z ta x x z b x
case applicable since b x x hence x domain
h
x ci v r child z z ta x x z
x x x riht x child x ii x child
root x ind r x x
case applicable since x x hence x domain
h


fiq uery p redicate e mptiness

extend h first h yet total exists edge b
x yb riht

concept name h b
x defined h b
undefined b
consequently
b
hta elements except root node domain
h
assume contrary h total edge e every edge b
x yb
riht h b
x defined h b
undefined b
derivation hta
contains non root node domain h pick one edge b
x yb riht
associated derivation hta minimal depth since h b
x defined h b

undefined follows point x
b parent yb yb child root node
b
x r b
since derivation rule applicable rule node label contains

formulation rule must thus ci v r unique
child z ta satisfies z x
b since x
b domain h non root node
domain h must somewhere z consequently nodes z z ta
z successor z domain element x
b z domain h

domain element yb z domain h definition derivation rules
must b
x yb siht role point yb child x
b yb


child root node label contains b
x follows x
b related yb one
derivation rules consequently b b
hta contains
iht



obligation b yb thus edge b
x yb
satisfies conditions associated
derivation htb b strictly smaller depth hta contradicting minimality
hta
extend h edge b
x yb riht whose existence established
definition derivations ci v r child z ta
z x
b since elements hta except root node domain h
subderivation hta rooted z uses elements domain h
uniformity assumption derivation hta bx bx thus ih yields h b
x iht
iht
iht

since v r b
x r

set h b

remains points satisfied extended h point obviously
start point assume x siht h x h defined already
extension h done otherwise construction h must x b
x yb r
x b
x
b r equivalent choice h b
h b
x h b
ri
hence x si point proved induction depth x initial version
h induction start exactly induction step cases differ
following ones

x b x child z ta x x z b x
immediate since
x ci v r child z z ta x x z
x x x riht x child x ii x child
root x ind r x x
since x x ind aht x must introduced domain
h examination edge x x riht since child z labeled x
use ci v r choose h x h x aiht



fibaader b ienvenu l utz w olter

references
artale calvanese kontchakov r zakharyaschev dl lite family
relations journal artifical intelligence jair
baader f bienvenu lutz c wolter f query predicate emptiness description logics proceedings th international conference principles knowledge
representation reasoning kr
baader f brandt lutz c pushing el envelope proceedings th
international joint conference artificial intelligence ijcai pp
baader f brandt lutz c pushing el envelope proceedings
workshop owl experiences directions owled
benedikt fan w geerts f xpath satisfiability presence dtds journal
acm
bienvenu hansen p lutz c wolter f first order rewritability conjunctive
queries horn description logics proceedings th international joint conference
artificial intelligence ijcai
bienvenu lutz c wolter f query containment description logics reconsidered
proceedings th international conference principles knowledge representation reasoning kr
bienvenu ten cate b lutz c wolter f ontology data access study
disjunctive datalog csp mmsnp acm transactions database system
tods
botoeva e kontchakov r ryzhikov v wolter f zakharyaschev query inseparability description logic knowledge bases proceedings th international
conference principles knowledge representation reasoning kr
botoeva e kontchakov r ryzhikov v wolter f zakharyaschev games
query inseparability description logic knowledge bases artificial intelligence journal
aij
bourhis p lutz c containment monadic disjunctive datalog mmsnp expressive
description logics proceedings th international conference principles
knowledge representation reasoning kr
calvanese de giacomo g lembo lenzerini poggi rodriguez muro
rosati r ontologies databases dl lite tutorial lectures
th international reasoning web summer school vol lecture notes computer
science pp springer
calvanese de giacomo g lembo lenzerini rosati r tractable reasoning
efficient query answering description logics dl lite family journal automated
reasoning jar
calvanese de giacomo g lembo lenzerini rosati r data complexity
query answering description logics artificial intelligence journal aij


fiq uery p redicate e mptiness

calvanese de giacomo g lenzerini decidability query containment
constraints proceedings th acm sigact sigmod sigart symposium
principles database systems pods pp
calvanese ortiz simkus stefanoni g reasoning explanations
negative query answers dl lite journal artificial intelligence jair

chortaras trivela stamou g b optimized query rewriting owl ql
proceedings rd international conference automated deduction cade pp

eiter gottlob g ortiz simkus query answering description logic
horn shiq proceedings th european conference logics artificial intelligence jelia pp
eiter ortiz simkus tran xiao g query rewriting horn shiq plus
rules proceedings th aaai conference artificial intelligence aaai
gabbay kurucz wolter f zakharyaschev many dimensional modal logics
theory applications elsevier
gatens w konev b wolter f lower upper approximations depleting modules
description logic ontologies proceedings st european conference artificial
intelligence ecai pp
gene ontology consortium gene ontology http geneontology org online accessed
april
glimm b lutz c horrocks sattler u answering conjunctive queries
shiq description logic journal artificial intelligence jair
golbeck j fragoso g hartel f hendler j oberthaler j parsia b national
cancer institutes thesaurus ontology journal web semantics science services
agents world wide web
grau b c horrocks kazakov sattler u modular reuse ontologies theory
practice journal artifical intelligence jair
haase c complexity subsumption extensions el masters thesis dresden university technology
hitrl health information technologies laboratory university sydney
http sydney edu au engineering hitru online accessed april
horrocks kutz sattler u even irresistible sroiq proceedings
th international conference principles knowledge representation reasoning
kr pp
hustadt u motik b sattler u decomposition rule decision procedures
resolution calculi proceedings th international conference logic
programming artificial intelligence reasoning lpar pp
hustadt u motik b sattler u reasoning description logics reduction
disjunctive datalog journal automated reasoning jar


fibaader b ienvenu l utz w olter

ihtsdo snomed ct global language healthcare http www ihtsdo org snomedct online accessed april
kaminski schneider smolka g correctness worst case optimality prattstyle decision procedures modal hybrid logics proceedings th international conference automated reasoning analytic tableaux related methods
tableaux pp
kazakov consequence driven reasoning horn shiq ontologies proceedings
st international joint conference artificial intelligence ijcai pp
kazakov extension complex role inclusion axioms description logic
sroiq proceedings th international joint conference automated reasoning
ijcar pp
konev b ludwig walther wolter f logical difference lightweight
description logic el journal artificial intelligence jair
konev b lutz c walther wolter f model theoretic inseparability modularity
description logic ontologies artificial intelligence journal aij
kontchakov r rodriguez muro zakharyaschev ontology data access
databases short course proceedings international reasoning web summer
school pp
kontchakov r wolter f zakharyaschev logic ontology comparison
module extraction application dl lite artificial intelligence

krotzsch owl profiles introduction lightweight ontology languages tutorial lectures th international reasoning web summer school vol lecture
notes computer science pp springer
krotzsch rudolph hitzler p complexity boundaries horn description logics
proceedings nd aaai conference artificial intelligence aaai pp
levy irrelevance reasoning knowledge systems ph thesis stanford university
lubyte l tessaris supporting design ontologies data access proceedings st international description logic workshop dl
lutz c complexity cq answering expressive description logics proceedings
th international joint conference automated reasoning ijcar pp
lutz c toman wolter f conjunctive query answering description logic el
relational database system proceedings st international joint conference
artificial intelligence ijcai pp
lutz c wolter f deciding inseparability conservative extensions description
logic el journal symbolic computation
lutz c wolter f non uniform data complexity query answering description
logics proceedings th international conference principles knowledge
representation reasoning kr


fiq uery p redicate e mptiness

motik b grau b c horrocks wu z fokoue lutz c owl web ontology language profiles w c recommendation available http www w org tr owl profiles
ortiz calvanese eiter data complexity query answering expressive
description logics via tableaux journal automated reasoning jar
ortiz simkus reasoning query answering description logics proceedings th international reasoning web summer school vol lecture notes
computer science pp springer
ortiz simkus eiter worst case optimal conjunctive query answering
expressive description logic without inverses proceedings rd aaai conference
artificial intelligence aaai pp
patel c cimino j j dolby j fokoue kalyanpur kershenbaum l schonberg
e srinivas k matching patient records clinical trials ontologies
proceedings th international semantic web conference iswc pp
perez urbina h motik b horrocks comparison query rewriting techniques
dl lite proceedings nd international description logic workshop dl
poggi lembo calvanese de giacomo g lenzerini rosati r linking
data ontologies journal data semantics
pratt v r program logics proceedings ieee annual symposium
foundations computer science focs pp
romero kaminski grau b c horrocks ontology module extraction
via datalog reasoning proceedings th aaai conference artificial intelligence
aaai pp
tobies complexity practical logics knowledge representation ph thesis rwth aachen
vardi automata theory database theoreticans proceedings th acm
sigact sigmod sigart symposium principles database systems pods pp

vardi reasoning past two way automata proceedings th
international colloquium automata languages programming icalp pp




