journal artificial intelligence

submitted published

optimal angle pathfinding practice
daniel harabor

daniel harabor nicta com au

university melbourne
national ict australia victoria laboratory
batman st melbourne australia

alban grastien

alban grastien nicta com au

national ict australia canberra laboratory
london circuit canberra australia

dindar oz

dindar oz yasar edu tr

yasar university
bornova izmir turkey

vural aksakalli

aksakalli sehir edu tr

istanbul sehir university
altunizade istanbul turkey

abstract
angle pathfinding fundamental robotics computer games
goal shortest path pair points grid map
path artificially constrained points grid prior focused
approximate online solutions number exact methods exist require
super linear space pre processing time study describe anya
optimal angle pathfinding works approximate angle
paths searching individual points grid anya finds optimal paths
searching sets states represented intervals interval identified thefly interval anya selects single representative point uses compute
admissible cost estimate entire set anya returns optimal path
one exists moreover without offline pre processing introduction
additional memory overheads range empirical comparisons anya
competitive several recent sub optimal online pre processing techniques
order magnitude faster common benchmark
grid implementation

introduction
angle pathfinding common navigation robotics computer games
takes input pair points uniform two dimensional grid asks shortest
path artificially constrained points grid anyangle paths desirable compute typically shorter grid constrained
counterparts following trajectory give appearance realism
intelligence e g player computer game despite apparent simplicity anyc

ai access foundation rights reserved

fiharabor grastien oz aksakalli

angle pathfinding surprisingly challenging far many successful popular methods
proposed yet involve trade offs kind begin
examples highlight broad strokes main trends limitations
date
communities artificial intelligence game development angle
pathfinding often solved efficiently technique known string pulling
idea compute grid optimal path smooth part
post processing step e g pinter botea muller schaeffer interleaving
string pulling online search e g ferguson stentz nash daniel koenig
felner regardless particular string pulling techniques suffer
disadvantages require computation finding path
ii yield approximately shortest paths
communities robotics computational geometry related general well studied finding euclidean shortest paths polygonal
obstacles plane visibility graphs lozano perez wesley continuous dijkstra paradigm mitchell mount papadimitriou among best known
influential techniques originate line even though
methods optimal efficient practice nevertheless suffer
often undesirable properties search graph must pre computed offline
pre processing step ii map changes point search graph invalidated
must recomputed usually scratch
date clear exists angle pathfinding simultaneously online optimal practically efficient e least fast practice
grid pathfinding search manuscript present work
answers open question affirmative introducing angle pathfinding
called anya bears similarity existing works
literature notably continuous dijkstra paradigm
rough overview
methods search individual nodes grid anya searches
contiguous sets states form intervals
anya interval single representative point used derive admissible cost estimate e f value points set
progress search process anya projects interval one row grid
onto another target reached
anya finds optimal angle path one exists addition anya
rely pre computation introduce memory overheads form
auxiliary data structures beyond required maintain open closed list
theoretical description previously appeared literature harabor
grastien study extend work several ways give
distinguish search graph input grid map though contexts terms
coincide exactly true general particular search graph may subset input
grid may related entirely separate data structure



fioptimal angle pathfinding practice

visible

visible

non visible






















non visible
























figure examples visible non visible pairs points

detailed conceptual description anya provide extended theoretical
argument optimality completeness ii discuss practical considerations
arise implementing give technical description one possible
efficient implementation iii make detailed empirical comparisons showing
anya competitive range recent sub optimal techniques literature
including offline pre processing one order magnitude better
benchmark grid implementation iv discuss range possible
extensions improving current

optimal angle pathfinding
grid planar subdivision consisting w h square cells cell open set
interior points traversable non traversable vertices associated
cell called discrete points grid edges grid interpreted
open intervals intermediate points one representing transition two
discrete points type point p x unique coordinate x w
h discrete points limited subset integer x values
discrete intermediate point traversable adjacent least one traversable
cell otherwise non traversable discrete point common exactly four
adjacent cells called intersection intersection three adjacent cells
traversable one called corner two points visible one another
connected straight line path e sequence adjacent points
intermediate discrete pass non traversable point
ii pass intersection formed two diagonally adjacent non traversable cells
figure shows examples help better illustrate idea
angle path sequence points hp pk pi visible pi
pi length cumulative distance every successive
pair points
p




p p pk pk function p x p x x x
uniform euclidean distance metric say pi turning point segments
pi pi pi pi form angle equal finally angle pathfinding
one requires input pair discrete points asks anyangle path connecting point designates source equivalently start location
well known turning points optimal angle paths corner points e g shown
mitchell et al



fiharabor grastien oz aksakalli

point designates target equivalently goal location path optimal
exists alternative angle path strictly shorter
figure provides example optimal angle pathfinding
seen source target obstacles discrete positions however path
need follow grid notice trajectory path appears much
realistic alternative restricted turning modulo deg deg


















figure example angle pathfinding together solution

overview anya
consider angle instance shown figure example optimal path
needs first head towards corner point n change direction
toward target one possible solving involves computing
visibility graph e identifying pairs corners visible one another
visible start target locations searching path
graph main drawback case visibility graph quite large
quadratic size grid expensive compute
alternative avoids overheads solve online
unfortunately online search methods generally consider discrete points grid
immediate neighbours example expanding point common
generate neighbours example
figure

f value
three neighbours respectively
euclidean distance
heuristic comparison optimal


angle path cost immediately see heuristic
hand satisfy one essential properties search f value
node underestimate actual distance goal without
property guaranteed optimal
issue described comes fact optimal path go
points instead optimal path crosses row point
part search space ensure optimality consider points
rather discrete points grid however many
points including e g points leading apriori seems reasonable
candidate expansion appear optimal path


fioptimal angle pathfinding practice







n




























figure pathfinding n online theta
expand discrete points grid never intermediate points yi
general need consider potential yi points defined fraction wh
h h w w set quadratic n min w h understand consider farey sequence order n sequence ordered increasing
number rational numbers written fraction whose
denominator integer lower n instance farey sequence order n
notice explains length
sequence n n still asymptotic cardinality sequence known

n
graham knuth patashnik ch

since quadratic behaviour farey sequence makes impractical enumerate
potential yi points propose consider instead individual points set points
appear together part contiguous interval grid example figure
would consider points lying time
part single search node framework need
define formally anya search node
define set successors search node
define compute f value search node
prove optimality returned path
terminate search path available
ensure anya efficient practice


fiharabor grastien oz aksakalli

description
section presents detail anya properties since anya
variant first present search space search nodes successors node
evaluation function used rank nodes search give pseudo code
description discuss properties improvements make anya
efficient practice presented next section
anya search nodes
define notion interval core anya
definition grid interval set contiguous pairwise visible points drawn
discrete row grid interval defined terms endpoints b
possible exception b interval contains intermediate discrete
non corner points
definition points interval share position positive
integer moreover x position points interval including endpoints
b rational number use normal parentheses indicate
interval endpoint open square brackets indicate interval endpoint
closed example interval b open e include
closed e include b
identifying intervals simple row grid naturally divided maximally contiguous sets traversable non traversable points traversable set forms
tentative interval split repeatedly necessary corner points
end points intervals intervals identified operation called projection discuss procedure next sub section note intervals
produced way projection non discrete non corner endpoints
significant advantage anya construct intervals fly allows
us start answering queries immediately discrete start target pair similar
e g continuous dijkstra mitchell et al require pre processing step
queries answered single fixed start point
definition search node r tuple r point called root
interval point p visible r represent start node
set assume r located plane visible cost r
case zero
search node together parents traditionally represents single path
defined travelling straight line points search nodes root
current node anya search node similarly defines paths obtained visiting
roots nodes ending interval current node node therefore
represents many paths root search node last common turning
per definition every point x appearing optimal angle path belongs
farey sequence points rational



fioptimal angle pathfinding practice

point paths root parent node one end
points parent interval
besides start node treat special case two types
search nodes cone nodes flat nodes example cone node shown figure
nodes characterised fact root r row
associated interval notice example although interval b maximal
endpoints obstacles corners indeed even discrete points
grid left endpoint right endpoint b examples
flat nodes shown figure two nodes b r b r flat
nodes characterised fact root r row interval
notice examples given r resp b excluded first resp
second interval semantics every search node current position located
somewhere interval reach point angle path whose
recent turning point r







b













r

b

b



r


















figure example cone search node















figure example two flat search nodes

searching anya successors
successors search node n identified computing intervals sets traversable
points row grid current node n rows immediately
adjacent want guarantee point set reached root
n via local path taut taut simply means pull endpoints
path cannot make shorter provide formal definition successor
discuss definition applied practice
definition successor search node r search node r
points p exists point p local path hr p p taut
r last common point shared paths hr p p
maximal according points definition search node


fiharabor grastien oz aksakalli

first requirement tautness implies successor p reached
root current node r path locally optimal use property
next subsection anya finds globally optimal path one exists
third property requiring successor interval maximal
exists purpose practical efficiency simply put want arbitrarily
small arbitrarily many successors instead make successor interval
large possible second property two interpretations r r say
successor node observable similarly r p say successor
non observable explore ideas turn

v



v

u

u

v
r





b
u




r


















figure successors cone search node n b r five successors v v r v v r observable r u r v u r
u u r








b

c



e

















figure successors flat search node n b two successors b c
observable e b


fioptimal angle pathfinding practice

computing successor set
function successors n r
takes input current node

n start node

return generate start successors

end

successors

n flat node

p endpoint farthest r
successor interval starts p

successors generate flat successors p r
observable successors

p turning point taut local path beginning r

successors successors generate cone successors p p r non observable successors

end

else
node flat must cone

left endpoint

b right endpoint

successors generate cone successors b r
observable successors

turning point taut local path beginning r

successors successors generate flat successors r
non observable

successors successors generate cone successors r
non observable

end

b turning point taut local path beginning r

successors successors generate flat successors b r
non observable

successors successors generate cone successors b b r
non observable

end

end
end function

observable successor characterised fact points p visible
current root point r case last common point shared local paths
form hr p p r observable successors computed projecting current interval
next row projection identifies maximal interval imax split
internal corner point point interval produced split operation leads
observable successor successors share root point original
parent node process illustrated figure interval b projected
onto next row projection identifies maximal observable interval imax v v
subsequently split create two observable successors v v r v v r
comparison non observable successor characterised fact points

p visible current root r case local paths form
hr p p must pass visibility obstructing corner point whose identity r p
figure illustrates process computing non observable successors first
non observable points right current interval b construct single
flat successor b u root r b non observable points exist
left current interval local path point r
taut non observable successors found rows grid adjacent
current interval projecting corner endpoint b onto next row grid
construct two non observable successors v u b u u b
give overview procedure generates successor set
search node overview sub functions appearing given


fiharabor grastien oz aksakalli

appendix implementation straightforward requiring nothing complicated
grid scanning operations linear projections
important note stage anya perform visibility checks
generation successor nodes visibility checks heart many contemporary online including theta nash koenig must determine
whether successor visible node e g grand parent node
one hand visibility checks help theta et al shorter paths expand fewer nodes
traditional search hand computational overhead introduced
checks means run times often larger comparison anya
projects interval one row grid next process involves local
reasoning particular determine projection imax valid invalid
needs clipped simply testing traversability cells located
left right current interval proposed imax elimination
visibility checks important practical advantage anya see section
anya finds shorter paths online methods theta et al
usually much efficient terms running time
illustrate previous examples consider flat node b
figure point p line set b observable flat successor b c
generated line furthermore since b turning point line interval
imax e considered since imax contains interior corner points split
single non observable cone successor imax b generated line
next consider cone node b r figure first generate observable
successors line interval b projected maximal interval imax v v
identified imax split internal corner point v leading two observable cone
successor nodes v v r v v r notice line sight visibility
check required next since b turning point look non observable successors
well lines flat successor b u b generated per previous example
meanwhile maximal non observable cone interval imax v u identified
interval split internal corner point u resulting two non observable cone
successor nodes v u b u u b
treats start node lines special case root point
located grid successors start node non observable intervals
root ii found left right start location row
immediately start location row immediately
evaluating anya search node
search procedure anya similarly expands promising node found far therefore necessary evaluate root interval pair
evaluation corresponds estimate f minimal length path
source target current interval optimality condition
estimate optimistic e never larger actual optimal path length
classical search node n corresponds single point p grid value
f n computed sum g p length path source p h p
estimation length shortest path p target


fioptimal angle pathfinding practice

search node n r represents set points f value minimum f value
points node
f n inf f r p
pi

f r p estimate shortest path r p
noted set points p continuous potentially open
minimum replaced infimum since points interval visible r
value broken follows
f r p g r r p h p
r p distance points r p
finding point interval minimises f value may seem hard
since interval contains large number points want avoid generating
however straight line distance heuristic h h p p makes easy isolate
point p minimises f value thanks two simple geometric observations
precise heuristics available could make harder point p
lemma let r two points interval row row
rows r point p infimal f value point
closest intersection straight line path ht ri row
line r intersects interval point p intersection
otherwise point p one endpoints interval event precondition lemma satisfied possible replace mirrored version
thus satisfy precondition case described lemma
lemma mirrored point target interval p p
p
lemma trivial geometrical lemmas illustrated figure
search procedure
search procedure employed anya presented follows pattern
uses priority queue open stores yet expanded search nodes
ordered f value node stores pointer parent step search
anya extracts best node open checks corresponding interval contains
target event target found line returned path sequence
root points constructed following back pointers current node start
location target found current node expanded successors
added priority queue line successors may considered redundant
safely discarded without insertion priority queue line discuss
aspect section suffices know successors
optimal path expansion process continues target found
open list exhausted case returns failure line
next sections prove fundamental properties
correctness optimality completeness


fiharabor grastien oz aksakalli
















b












r









figure illustration lemmas evaluate node n b r
points correspond case row target intersects interval
mirrored target must used

correctness optimality
section prove anya correct finds optimal path particular
optimal path appears search space ii target
expanded found optimal path iii node search space
reached finite number steps topics termination completeness
discussed section
begin analysis recalling search node n r represents set potential
paths r r point p following semantics say
n search node path r intersects
lemma n r search node optimal path n contains
target n least one successor n search node
proof start node n start node r located grid additionally n search node hypothesis line scans traversable
anya















input grid source location target location
open r
open empty
r pop open

return path
end
r successors r
prune r
open open r
end
end
end
return null



start node root r located grid

successor pruning

fioptimal angle pathfinding practice

points grid visible adjacent points located
left right located rows immediately immediately
row assigns points interval
associated successor node root r every optimal path must pass
traversable points reached without
passing interval associated successor sufficient satisfy
lemma
nodes n arbitrary node successors
done definition r p apriori unknown intersection
interval two possibilities consider depending whether
p turning point cases successor n whose
interval intersects sufficient satisfy lemma
case p turning point lines scans points
adjacent straight line visible r point assigned
successor observable interval root point r thus least one
successors n intersects every straight line path r p means
least one successor n intersects
case p turning point case p must corner endpoint otherwise
taut thus cannot optimal lines scans
points adjacent reachable r p taut local path
points located row p row immediately adjacent
point assigned successor non observable interval root
r p process exhaustive points reachable taut local path
r though p must assigned interval thus must intersect least one
successors n

corollary path source target open list
contains search node optimal path node currently processed
proof induction
base case initial search node node path
inductive case assume open list contains search node optimal path
node removed expanded node contain
target know lemma one successor generated search node
optimal path therefore search node optimal path inserted
open list


lemma first expanded node contains target corresponds one optimal
path


fiharabor grastien oz aksakalli

proof sketch first notice f value node indeed minimal value
nodes interval means f estimate actual cost
target second notice given search node r successor r
point p f value p greater equal f value point
p p r r r p intersection r p otherwise f function
therefore monotonically increasing finally f function search node r
length path hence f function nodes representing sub optimal
path eventually exceed optimal path distance f function nodes
representing optimal path remain value


lemma target reachable anya eventually expand node whose interval
includes target
proof contradiction assume anya expand node whose interval includes
target lemma know failure expand node means anya
expand infinitely many nodes shall prove implies f value
nodes unbounded therefore target reachable
search nodes r interval different row parent
r therefore nodes value g p larger value g p
happen node flat bounded number
successive flat nodes hence infinite sequence successive anya nodes infinite length finally anya node bounded number successors meaning
infinite number expansions generate infinite number successive nodes

completeness termination
specified policy anya detect nodes
previously expanded context optimal search policy essential
prevent cyclical expansion ensure eventually terminates
even path start target locations section describe
policy anya conceptually similar closed list works
tracking best g value associated every root location cf every search node
encountered search
motivating example consider figure root r reached via two paths
different length example green path strictly longer red path
points reached via green path g value strictly larger
point reached via red path figure shows similar example green
red paths reach root point r cost resulting two identical copies
successor node r without strategy handle root level redundancies
search process generate many unnecessary nodes slow progress goal
moreover exists path start target location search may
furthermore value g p increase significantly unobservable flat cone



fioptimal angle pathfinding practice







r















r




























figure root r reached via two paths
different lengths













figure root r reached via two
paths equal length

terminate e g input graph contains cycles possible endlessly generate
copies states ever increasing g values
propose following strategy avoid root level redundancies
store hash table visited roots best g values call table
root history apply similar way indeed lieu traditional
closed list
generating search node n check root already root history
g value less equal current g value
current g value root improves value stored root history
add node open list update g cost root root
history list
alternatively current g value root improve value stored
root history simply discard node e added open
root history implemented hash table size n n number
discrete points given input map keeping root history list
affect correctness optimality search anya indeed complete
terminate
lemma anya search prunes sub optimal paths
similar updates nodes closed list sometimes performed context incremental
bounded cost bounded sub optimal search updates performed part operation called
node opening updates node opening particular root points never
directly expanded thus never appear open list anya search comprise root interval pairs



fiharabor grastien oz aksakalli

proof trivial search node root sub optimal g value represents
sub optimal path


lemma anya terminates
proof anya terminate must explore paths arbitrary length paths
must eventually involve root twice root different let
n n two search nodes g value associated n must higher
g value associated n therefore node n must pruned indeed sufficiently
long paths pruned open list eventually empty


lemma anya redundant node pruning keeps least one optimal path
proof search node n r removed exists another search node n
different search parents smaller equal g value kept assume
n search node optimal path p pk let pi point path
intersects since g value n similar n exists another path

p p pi pk similar length path pruned

practical pruning strategies
orders nodes expansion evaluating ranking promising appear
e f values however possible alter order expansion without
compromising guarantees provided correctness optimality completeness
indeed strategy even positive effect efficiency overall search
section discuss two practical strategies modify expansion order speed
search enhancements applied fly focus reducing size
priority queue first strategy cul de sac pruning identifies nodes safely
discarded cannot possibly lead goal second strategy intermediate
pruning similar works avoiding explicit generation nodes
single successor successors expanded immediately without added
open list
cul de sac pruning
one way reducing size priority queue involves early identification culde sacs cds cds search node successor contain target
definition cds need added open list since expansion cannot
lead target simple test identify cds nodes given way
procedure cul de sac
early pruning cds nodes speeds search reduces required memory preventing unnecessary operations open reducing size list


fioptimal angle pathfinding practice

cul de sac intermediate node pruning
function cul de sac n r
assumes contain target point

imax projection n
flat projection cone projection depending n

imax valid
valid means every p imax visible r

return f alse
n cannot cul de sac least one successor interval imax

end

return true
n cul de sac cannot projected successors
end function
function intermediate n r
assumes contain target point

n flat node

p endpoint furthest r

p turning point taut local path prefix hr pi

return f alse
n least one non observable successor cannot intermediate

end

else
n flat node must cone node

closed endpoint corner point

return f alse
n least one non observable successor cannot intermediate

end

interval projecting r

contains corner points

return f alse
n one observable successors cannot intermediate

end

end

return true
end function

makes every operation faster reference open list implemented
binary heap add remove operation time complexity log n n
size list examples cds pruning cone nodes flat nodes illustrated
figure figure cases current node root shown blue
intervals red pruned
intermediate pruning
second pruning strategy described pushing expansion one direction
far possible long increase branching factor practically search
node generated guaranteed one successor immediately
generate successor instead originally intended node said successor
one successor process recursively applied examples showing application
intermediate pruning given figure cone nodes figure flat nodes
simple test identify intermediate nodes given way procedure
intermediate
first obvious benefit intermediate pruning reduction number operations open list however second benefit pushing expansion node
lead cul de sac happens node added open list
helps keep size list small operations list fast
potential issue intermediate pruning recursive application nonpromising successor nodes could costly terms time simply adding


fiharabor grastien oz aksakalli













c






e f
b

r



b

c


r




















figure cul de sacs cone nodes
nodes c r e f r generated














figure cul de sac flat nodes node
b c r generated







r





b

c





r



b

c














figure intermediate node b r
one successor c r immediately generated








figure intermediate node b r
one successor b c r immediately generated

nodes open discuss issue detail section note
run time experiments application intermediate pruning net positive effect
performance search
discussion
introduced two different ways nodes frontier search
pruned cul de sac pruning intermediate pruning modify expansion order
search improve performance along single fixed path pruning
away sterile branches skipping intermediate locations actual branching
occurs similar strategies previously discussed literature example culde sac pruning set principles dead end heuristic bjornsson
halldorsson although method reasons locally applied purely online
intermediate pruning shares similarities fast expansion sun yeoh chen


fioptimal angle pathfinding practice

koenig main difference prune nodes without reference f value
intermediate pruning similar jump point search harabor grastien
applied outside context symmetry breaking extended sets points taken
intervals rather applied individual cells grid
anyas root history list discussed section regarded type pruning
enhancement case reason generally set possible paths
could used reach given point prune away successors cannot
possibly optimal path taken similar principle
practice pruning redundant states real time search sturtevant
bulitko
pruning search nodes anya difficult classical search
many modern progenitors anya node represents set positions
rather one consider example figure particularly interested
interval b generated root r r shortest path
r r however obstacle put
cell labeled optimal path switches r
diagram suggests given target two search nodes sharing
interval may possible prune
situation described figure uncommon practice examples
may motivate us derive sophisticated pruning rules enhance
performance anya must careful however weigh improved
pruning power techniques overhead applying first
instance example alternative arguably better avoiding redundant
node expansions keep interval history list addition instead root history
method would certainly avoid outlined figure many
possible intervals roots means size hash table potentially
much larger memory accesses potentially slower additionally comparing intervals
equality membership requires extra time may worth investment

attempted similar experiment clearly positive



fiharabor grastien oz aksakalli















b

r



r




































figure illustrating search nodes cannot trivially pruned search nodes
n b r n b r obstacle optimal path
goes n red otherwise goes n blue

experimental setup
conduct experiments seven benchmark sets taken nathan sturtevants
well known repository sturtevant three benchmarks originate popular
computer games often appear literature baldurs gate ii dragon
age origins starcraft maps benchmarks vary size several
thousand nodes several million remaining four benchmarks comprise grids
size randomly placed obstacles varying densities
table gives overview benchmark give number maps
instances per set distribution number node expansions required
reference octile distance heuristic solve
benchmark set latter metric gives us baseline comparing difficulty
appearing benchmark set
octile distance analogous manhattan distance generalised connected grids



fioptimal angle pathfinding practice

benchmark

maps

instances

baldurs gate ii
dragon age
starcraft
random
random
random
random

















nodes expanded
min
q median mean
q
max stdev



























table overview seven benchmark used experiments give
number maps instances benchmark distribution nodes expanded
reference solving benchmark set

compare purely online optimal anya number state ofthe art angle techniques theta nash et al lazy theta nash
koenig tovey field uras koenig angle variant
two level subgoal graphs sub tl uras koenig b approaches
near optimal guaranteed return shortest path methods theta lazy
theta field purely online sub tl relies offline pre processing
step improve performance search use c implementations
source codes made publicly available uras koenig
anya implemented java executed jvm allow comparisons across
different implementation languages use hart nilsson raphael
implemented c java reference point compare performance anya java implementation
c implementation experiments performed ghz intel core
machine gb ram running osx source code implementation
anya available https bitbucket org dharabor pathfinding


evaluate performance three different metrics search time nodes expanded
path length presented relative benchmark
combine standard octile distance heuristic example comparing search
time nodes expanded give figures relative speedup vs
paradigm search time speedup means twice fast node
expansion speedup means half many nodes expanded comparing path
length give percent improvement path length vs cases higher better

c implementation due uras koenig java implementation



fiharabor grastien oz aksakalli

benchmark
baldurs gate ii
dragon age
starcraft
random
random
random
random

avg node expansion speedup
anya theta l theta f sub tl



























avg path length improvement
anya theta l theta f sub tl






















table compare performance terms average node expansion speedup
average path length improvement metrics taken respect reference
cases higher better
begin table shows average performance figures nodes expanded
path length seven benchmark sets make following observations
anya best four purely online expanding fewer nodes
five seven benchmarks three benchmarks drawn real computer
games anya expands one order fewer nodes average nearest purelyonline contemporary pre processing sub tl expands fewer
nodes average
anya methods comparison struggles achieve speedup
four random benchmarks two four cases performance
reference pre processing sub tl
able achieve consistent though much reduced node expansion speedup
anya optimal shows best improvement path length however comparison close optimal average
next evaluate performance terms search time rather taking simple
average per benchmark basis across benchmarks instead sort instances
according difficulty measured number node expansions required
reference solve gives holistic overview
performance reduces effect bias associated selection instances
comprise benchmark set analysis given figure
make following observations
anya often one order magnitude faster reference benchmarks drawn real computer games performance mixed
four random benchmarks evaluated methods struggling achieve
speedup
per table instances regarded easy often outnumber instances
regarded hard difference effect skewing performance indicators
computed simple averages instances benchmark set



fioptimal angle pathfinding practice

benchmarks

baldur gate ii
anya
theta
lazy theta
field
subtl

speedup vs







anya
theta
lazy theta
field
subtl



speedup vs

















nodes expanded









dragon age origins


nodes expanded





starcraft
anya
theta
lazy theta
field
subtl

speedup vs







anya
theta
lazy theta
field
subtl



speedup vs

















nodes expanded







random x obstacles

speedup vs





random x obstacles
anya
theta
lazy theta
field
subtl




nodes expanded





anya
theta
lazy theta
field
subtl



speedup vs



















nodes expanded







random x obstacles

speedup vs





random x obstacles
anya
theta
lazy theta
field
subtl




nodes expanded





anya
theta
lazy theta
field
subtl



speedup vs



















nodes expanded










nodes expanded





figure search time speedup compare performance seven benchmarks
terms search time figures given relative speedup vs reference
instances sorted difficulty node expansion rank note
plot log log



fiharabor grastien oz aksakalli

anya fastest four purely online methods evaluation performance often comparable pre processing sub tl technique
particularly challenging instances starcraft domain anya non dominated
anyas performance terms search time less value suggested
previously evaluated node expansion metric reflects fact node
expansion made anya involves analysing grid looking roots searching
intervals
discussion
seen anya compares well current state art angle pathfinding
almost apples apples comparison three contemporary purely
online search technique theta lazy theta field seen anya usually
expands fewer nodes per search terminates one order magnitude faster
underscored fact anya online
guaranteed return euclidean optimal path may surmise many cases
applications anya appears preferable alternative
next make apples oranges comparison purely online anya near optimal offline enhanced sub tl seen
anya usually fast sub tl performance sometimes comparable
moreover anya retains advantage solving especially challenging instances drawn
real computer games sub tl appears preferable anya cases additional space time available create store associated subgoal graph cases
overheads amortised many online instances extra space
time available cases map subject change e g obstacles
added existing obstacles removed anya appears preferable sub tl
main strength anya searches sets nodes grid rather
considering individual locations one time expansion thus considered
macro operator meaning anya bears similarity speedup techniques
hierarchical abstraction e g hpa botea et al important difference
anya constructs abstract graph fly rather part pre processing step
one current drawback associated anya nodes contain overlapping
intervals occurs interval reachable two different root points neither
pruned e g root locations reached first time
illustrated figure nodes part whole redundant
provided f value smaller optimal distance goal
beget yet redundant successors see behaviour especially
benchmarks random random sub tl achieves speedup several
factors anya struggles maintain parity reference seems
reasonable improve current attempting identify overlaps order
prune consideration efficient effective achieving
goal subject work
pareto sense e instances anya better sub tl according
metric interest node expansions search time



fioptimal angle pathfinding practice

related work
among simplest popular approaches solving angle pathfinding
string pulling main idea path input grid map often
variant hart et al post process path order
remove unnecessary turning points several methods appeared literature
game development e g see work pinter botea et al
number improve string pulling interleaving node expansion
path post processing online search particular examples include field ferguson
stentz field uras koenig use linear interpolation
smooth grid paths one cell time theta nash et al introduces
shortcut time successful line sight check made parent current
node successors though still sub optimal many cases approaches
nevertheless attractive able search purely online efficient
practice addition two examples given numerous works often
appearing literature artificial intelligence apply improve basic
interleaving idea refer interested reader nash koenig recent survey
overview
accelerated sislak volf pechoucek online angle
conjectured optimal strong theoretical argument made similar
theta differs primarily line sight checks performed set expanded
nodes rather single ancestor size set loosely bounded
challenging include large proportion nodes closed list
one recent successful line involves combination string pulling
offline pre processing step works compelling significantly
improve performance purely online search terms solution quality
running time block yap burch holte schaeffer one example
sub optimal pre computes database euclidean optimal distances
possible tile configurations certain size e g possible x blocks database
obviates need explicit visibility checks indeed type online string pulling
pre processing step needs performed exactly database remains valid
tiles map change indeed map changes entirely another recent
work improves theta combining pre processing graph
abstraction technique uras koenig b referred section
sub tl shown improve running time solution quality block
main disadvantage vs block abstract graph needs computed
repaired time map changes
euclidean shortest path well known well researched topic
areas computational geometry computer graphics seen generalisation angle pathfinding asks shortest path plane
impose restrictions obstacle shape obstacle placement cf grid aligned
polygons made unit squares
visibility graphs lozano perez wesley family well known popular
techniques optimally solving euclidean shortest path searching
graphs requires n log n time much faster practice


fiharabor grastien oz aksakalli

two main disadvantages computing graph requires offline pre processing
step n space store ii graph static must recomputed repaired
environment changes sophisticated variants tangent graphs liu
arimoto silhouette points young particularly efficient variants
visibility graphs disadvantages apply
another family exact approaches solving euclidean shortest path
continuous dijkstra paradigm mitchell et al efficient hershberger suri involves pre computation requiring n log n space n log n time shortest path map planar
subdivision environment used euclidean shortest path
log n time queries originating fixed source visibility graphs
introduces additional memory overheads storing subdivision
pre processing step must executed time environment start location
changes

conclusion
study angle pathfinding commonly found areas robotics
computer games involves finding shortest path two points grid
asks path artificially constrained fixed points grid
best known online angle date compute approximate
solutions rather optimal shortest paths additionally online methods
able achieve consistent speedup vs common reference point
measuring performance literature work present online optimal practically efficient angle technique anya works obtain good
performance reasoning grid level method considers sets points
grid taken together contiguous intervals requires revisiting
classical definition search nodes successors requires introduction
technique computing f value node give thorough algorithmic description search paradigm give theoretical arguments completeness
optimality preserving characteristics
almost apples apples comparison evaluate anya three contemporary near optimal online techniques theta lazy theta field
range popular benchmarks anya faster alternatives
guaranteeing optimal shortest path apples oranges comparison
evaluate anya sub tl fast pre processing near optimal angle
technique anya non dominated compared sub tl even
maintains advantage particularly challenging instances drawn real computer games another advantage unlike sub tl anya assume map
static e readily applied pathfinding involving dynamically changing
terrain
angle pathfinding received significant attention ai game development communities open question whether optimal
online exists anya answers question affirmative


fioptimal angle pathfinding practice

future work
several possible directions future work perhaps obvious development improvements extensions current anya example
believe empirical performance anya could enhanced generating successors
nodes contain redundant partially redundant intervals one possibility
keep closed list previously encountered intervals stronger variant idea
involves bounding g value grid intervals generating successor nodes
least one point inside candidate interval relaxed related orthogonal improvement involves pre processing grid identifying intervals apriori enhancement
speed search avoiding entirely grid scanning interval projection operations
currently necessary order generate node
seen reasoning sets points grid rather individual
locations computationally beneficial believe type search paradigm
employed anya generalised improve performance grid optimal search
addition angle pathfinding
final suggestion work believe anya might generalised
two dimensional maps arbitrarily shaped polygonal obstacles rather grids
benefit generalisation would avoid discretisation world
path searched would even improve quality path returned
optimal angle path often non optimal non discretised version map

acknowledgements
thank tansel uras assistance source codes used experimental section
thank adi botea patrik haslum helpful suggestions
early development work
work daniel harabor alban grastien supported nicta nicta
funded australian government represented department broadband
communications digital economy australian council
ict centre excellence program
work dindar oz vural aksakalli supported scientific technological council turkey tubitak grant



fiharabor grastien oz aksakalli

appendix
provide additional details implementation anyas successor set generation
method depends basic operations technically simple grid
scanning traversability tests linear projection operations attempt reproduce mechanical details operations instead focus presentation toward
intuitive understanding overall process
computing successor set supplemental
function generate start successors traversable discrete start location


construct maximal half closed interval imax
containing points observable left


construct maximal half closed interval imax
containing points observable right


construct maximal closed interval imax
containing points observable row


construct maximal closed interval imax
containing points observable row
k

intervals split imax
corner point take union

construct intervals cone flat successor node r

return start successors
end function
function generate flat successors interval endpoint p root point r

p first corner point else farthest obstacle vertex row p hr p p taut

imax maximal interval endpoints p open p closed

points r p row
observable successors

successors flat node n imax r

else

successors flat node n imax p
non observable flat successors

end

return successors
end function
function generate cone successors interval endpoint interval endpoint b root point r

b r row
non observable successors flat node

r b whichever farthest r
previously established turning point

p point adjacent row reached via right angle turn
obstacle following

imax maximum closed interval beginning p entirely observable r

else b
non observable successors cone node

r

p point adjacent row computed via linear projection r

imax maximum closed interval beginning p entirely observable r

else
observable successors cone node

r r

p point adjacent row computed via linear projection r

p point adjacent row computed via linear projection r b

imax maximum closed interval endpoints b entirely observable r

end

split imax corner point

n search node interval root point r

successors successors

end

return successors
end function



fioptimal angle pathfinding practice

references
bjornsson halldorsson k improved heuristics optimal path finding
game maps proceedings second artificial intelligence interactive
digital entertainment conference june marina del rey california pp

botea muller schaeffer j near optimal hierarchical path finding
journal game development
ferguson stentz field interpolation path planner
replanner robotics th international symposium isrr
october san francisco ca usa pp
graham r l knuth e patashnik concrete mathematics foundation computer science addison wesley
harabor grastien optimal angle pathfinding
proceedings twenty third international conference automated
scheduling icaps rome italy june
harabor grastien improving jump point search proceedings
twenty fourth international conference automated scheduling
icaps portsmouth hampshire usa june
hart p e nilsson n j raphael b formal basis heuristic determination minimum cost paths ieee transactions systems science
cybernetics
hershberger j suri optimal euclidean shortest paths
plane siam journal computing
liu h arimoto path tangent graph mobile
robots among polygonal curved obstacles international journal robotics

lozano perez wesley collision free paths
among polyhedral obstacles communications acm
mitchell j b mount papadimitriou c h discrete geodesic
siam journal computing
nash daniel k koenig felner theta angle path grids proceedings twenty second aaai conference artificial
intelligence july vancouver british columbia canada pp
nash koenig angle path ai magazine
nash koenig tovey c lazy theta angle path
path length analysis proceedings twenty fourth aaai conference
artificial intelligence aaai atlanta georgia usa july
pinter toward realistic pathfinding game developer magazine


fiharabor grastien oz aksakalli

sislak volf p pechoucek accelerated trajectory gridbased path comparison th icaps workshop plan
execution real world systems
sturtevant n benchmarks grid pathfinding transactions computational intelligence ai games
sturtevant n r bulitko v learning going whence
came h g cost learning real time heuristic search nd international joint conference artificial intelligence ijcai pp
sun x yeoh w chen p koenig simple optimization techniques
search th international joint conference autonomous agents
multiagent systems aamas budapest hungary may
pp
uras koenig empirical comparison angle path
proceedings eighth annual symposium combinatorial search
socs june ein gedi dead sea israel pp
uras koenig b speeding angle path grids
proceedings twenty fifth international conference automated
scheduling icaps jerusalem israel june pp
yap p burch n holte r c schaeffer j block database driven search
applications angle path proceedings twenty fifth
aaai conference artificial intelligence aaai san francisco california
usa august
young optimizing points visibility pathfinding game programming
gems pp charles river media




