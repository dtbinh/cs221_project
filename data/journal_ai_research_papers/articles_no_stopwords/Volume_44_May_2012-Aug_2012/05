Journal Artificial Intelligence Research 44 (2012) 275-333

Submitted 12/11; published 6/12

Algorithms Generating Ordered Solutions Explicit
AND/OR Structures
Priyankar Ghosh
Amit Sharma
P. P. Chakrabarti
Pallab Dasgupta

priyankar@cse.iitkgp.ernet.in
amit.ontop@gmail.com
ppchak@cse.iitkgp.ernet.in
pallab@cse.iitkgp.ernet.in

Department Computer Science Engineering
Indian Institute Technology Kharagpur
Kharagpur-721302, India

Abstract
present algorithms generating alternative solutions explicit acyclic AND/OR
structures non-decreasing order cost. proposed algorithms use best first search
technique report solutions using implicit representation ordered cost.
paper, present two versions search algorithm (a) initial version best first
search algorithm, ASG, may present one solution generating
ordered solutions, (b) another version, LASG, avoids construction
duplicate solutions. actual solutions reconstructed quickly implicit
compact representation used. applied methods test domains,
synthetic others based well known problems including search
space 5-peg Tower Hanoi problem, matrix-chain multiplication problem
problem finding secondary structure RNA. Experimental results show efficacy
proposed algorithms existing approach. proposed algorithms
potential use various domains ranging knowledge based frameworks service
composition, AND/OR structure widely used representing problems.

1. Introduction
use AND/OR structures modeling solving complex problems efficiently
attracted significant amount research effort last decades. Initially,
AND/OR search spaces mostly used problem reduction search solving complex
problems, logical reasoning theorem proving, etc., overall problem
hierarchically decomposed conjunction disjunction subproblems (Pearl, 1984;
Nilsson, 1980). Subsequently, AND/OR structures applied variety domains, e.g., representing assembly plans (Homem de Mello & Sanderson, 1990), generating VLSI floor-plans (Dasgupta, Sur-Kolay, & Bhattacharya, 1995), puzzle solving (Fuxi,
Ming, & Yanxiang, 2003), etc. Traditionally algorithm AO* (Pearl, 1984; Nilsson, 1980;
Martelli & Montanari, 1978, 1973; Chang & Slagle, 1971) used searching implicitly defined AND/OR structures. empirical study AO* found Bonet
Geffners (2005) work.
recent past renewed research interest towards application
AND/OR structures. various planning problems, including conditional planning
handle uncertainty, AND/OR structure (Russell & Norvig, 2003) natural form

c
2012
AI Access Foundation. rights reserved.

fiGhosh, Sharma, Chakrabarti, & Dasgupta

representation. problem generating solutions representations
studied extensively (Hansen & Zilberstein, 2001; Jimenez & Torras, 2000; Chakrabarti,
1994). Dechter Mateescu (2007) presented explicit AND/OR search space
perspective graphical models. Different search strategies (best first, branch bound,
etc.) AND/OR search spaces graphical models discussed Marinescu
Dechter (2007b, 2006). AND/OR search spaces used solving mixed integer
linear programming (Marinescu & Dechter, 2005), 0/1 integer Programming (Marinescu
& Dechter, 2007a), combinatorial optimization graphical models (Marinescu & Dechter,
2009a, 2009b). AND/OR Multivalued Decision Diagrams (AOMDD), combine
idea Multi-Valued Decision Diagrams(MDD) AND/OR structures, presented
Mateescu, Dechter, Marinescu (2008) research along direction
found work Mateescu Dechter (2008). AND/OR search spaces
applied solution sampling counting (Gogate & Dechter, 2008). Smooth Deterministic Decomposable Negative Normal Forms (sd-DNNF) (Darwiche, 2001) exhibit explicit
AND/OR DAG structure used various applications including compiling
knowledge (Darwiche, 1999), estimating belief states (Elliott & Williams, 2006), etc.
Apart domains planning, constraint satisfaction, knowledge based reasoning,
etc., AND/OR structure based techniques widely used various application based
domains, e.g., web service composition (Gu, Xu, & Li, 2010; Shin, Jeon, & Lee, 2010; Gu,
Li, & Xu, 2008; Ma, Dong, & He, 2008; Yan, Xu, & Gu, 2008; Lang & Su, 2005), vision
graphics tasks (Chen, Xu, Liu, & Zhu, 2006), etc. Lang Su (2005) described
AND/OR graph search algorithm composing web services user requirements.
et al. (2008) advocated use AND/OR trees capture dependencies
inputs outputs component web services propose top-down search algorithm
generate solutions AND/OR tree. research uses AND/OR structures
context web service composition found works Gu et al. (2010,
2008), Shin et al. (2010) Yan et al. (2008). Chen et al. (2006) applied explicit
AND/OR structures cloth modeling recognition important problem
vision graphics tasks.
recent adoption AND/OR search spaces wide variety AI problems
warrants research towards developing suitable algorithms searching AND/OR
structures different perspectives. general setting, fundamental problem
remains find minimum cost solution AND/OR structures. given explicit
AND/OR graph structure, minimum cost solution computed using either topdown bottom-up approach. approaches based principle dynamic
programming complexity linear respect size search
space. Finding minimum cost solution explicit AND/OR structure fundamental
step approaches use implicit representation systematically explore
search space. particularly case AO* (Nilsson, 1980) potential
solution graph (psg) recomputed every time current explicit graph node
expanded. view recent research AND/OR structures used leveraged
wide variety problems ranging planning domain web service composition,
need generating ordered set solutions given AND/OR structure becomes
imminent. briefly mention areas ordered solutions useful.

276

fiGenerating Ordered Solutions Explicit AND/OR Structures

Ordered set solutions explicit AND/OR DAG used develop useful
variants AO* algorithm. Currently AO*, minimum cost solution computed whereas several variants A* algorithm exist, solutions often sought
within factor cost optimal solution. approaches (Ebendt & Drechsler, 2009;
Pearl, 1984) developed adapt A* algorithm using inadmissible heuristics,
leveraging multiple heuristics (Chakrabarti, Ghose, Pandey, & DeSarkar, 1989), generating
solutions quickly within bounded sub-optimality, etc. Typically techniques order
Open list using one evaluation function, next element expansion selected
ordered subset Open using criterion. Similar techniques developed
AO* search ordered set potential solutions made available. set
used node selection expansion instead expanding nodes current
best psg. opens interesting area significant research potential
existing variations A* algorithm extended AND/OR search spaces.
context model based programming, problem finding ordered set
solutions significant importance. Elliott (2007) used valued sd-DNNFs represent
problem proposed approach generate k-best solutions. Since valued sd-DNNFs
AND/OR structure, proposed approach possibly earliest algorithm
generating ordered set solutions AND/OR structure. problem finding
ordered set solutions graphical models studied Flerova Dechter (2011, 2010).
However techniques use alternative representations algorithm, AND/OR
search spaces constructed (Dechter & Mateescu, 2007) graphical models. Recent
research involving AOMDD based representation weighted structures suggested future
extensions towards generalizing Algebraic Decision Diagrams introduces notion
cost AOMDDs. envisage ordered set solutions finds useful applications
context research around AND/OR decision diagram based representation.
domain service composition, primary motivation behind providing set
alternative solutions ordered cost offer choices, trading specified
cost criterion (to limited extent) favor unspecified criteria (primarily
standpoint quality). Shiaa, Fladmark, Thiell (2008) presented approach
generating ranked set solutions service composition problem. Typically
quality criteria subjective nature difficult express terms single scalar cost
function able combine cost/price quality aspects together.
aspects quality often encountered context serving custom user requirements
user prefers minimize cost/price solution preserving his/her
preferences. example, booking holiday package specific destination, travel
service portal typically offers list packages various combinations attractions,
hotel options meal plans ordered single cost criterion, namely, cost
package. general product/solution composed number components
compositional flavor similar service composition becomes important present
user set alternative solutions ordered cost he/she select best
alternative according his/her preferences.
Dynamic programming formulations typically underlying AND/OR DAG structure, formally studied past (Martelli & Montanari, 1973). Besides
classical problems matrix chain multiplication, many real world optimization problems offer dynamic programming formulations, alternative solutions ordered cost
277

fiGhosh, Sharma, Chakrabarti, & Dasgupta

useful practice. One example problem finding secondary structure
RNA (Mathews & Zuker, 2004) important problem Bioinformatics. RNAs
may viewed sequences bases belonging set {Adenine(A), Cytocine(C), Guanine(G), Uracil(U)}. RNA molecules tend loop back form base pairs
resulting shape called secondary structure. primary factor influences
secondary structure RNA number base pairings (higher number base pairings generally implies stable secondary structure). well established rules
base pairings, problem maximizing number base pairings interesting dynamic programming formulation. However, apart number base pairings,
factors influence stability, factors typically evaluated
experimentally. Therefore, given RNA sequence, useful compute pool
candidate secondary structures (in decreasing order number base pairings)
may subjected experimental evaluation order determine stable
secondary structure.
problem generating ordered set solutions well studied domains.
discrete optimization problems, Lawler (1972) proposed general procedure
generating k-best solutions. similar problem finding k probable configurations
probabilistic expert systems addressed Nilsson (1998). Fromer Globerson (2009)
addressed problem finding k maximum probability assignments probabilistic modeling using LP relaxation. context ordinary graphs, Eppstein (1990)
studied problem finding k-smallest spanning trees. Subsequently, algorithm
finding k-best shortest paths proposed Eppsteins (1998) work. Hamacher
Queyranne (1985) suggested algorithm k-best solutions combinatorial optimization problems. Algorithms generating k-best perfect matching presented
Chegireddy Hamacher (1987). researchers applied k-shortest path problem
practical scenarios, as, routing transportation, developed specific solutions
(Takkala, Borndorfer, & Lobel, 2000; Subramanian, 1997; Topkis, 1988; Sugimoto & Katoh,
1985). However none approaches seems directly applicable AND/OR structures. Recently schemes related ordered solutions graphical models (Flerova &
Dechter, 2011, 2010) anytime AND/OR graph search (Otten & Dechter, 2011)
proposed. Anytime algorithms traditional search space (Hansen & Zhou, 2007)
well addressed research community.
paper, address problem generating ordered set solutions explicit
AND/OR DAG structure present new algorithms. existing method, proposed
Elliott (2007), works bottom-up computing k-best solutions current node
k-best solutions children nodes. present best first search algorithm,
named Alternative Solution Generation (ASG) generating ordered set solutions.
proposed algorithm maintains list candidate solutions, initially containing
optimal solution, iteratively generates next solution non-decreasing order cost
selecting minimum cost solution list. iteration, minimum cost
solution used construct another set candidate solutions, added
current list. present two versions algorithm
a. Basic ASG (will referred ASG henceforth) : version algorithm
may construct particular candidate solution once;

278

fiGenerating Ordered Solutions Explicit AND/OR Structures

b. Lazy ASG LASG : Another version ASG algorithm constructs every candidate solution once.
algorithms, use compact representation, named signature, storing
solutions. signature solution, actual explicit form solution
constructed top-down traversal given DAG. representation allows
proposed algorithms work top-down fashion starting initial optimal
solution. Another salient feature proposed algorithms algorithms work
incrementally unlike existing approach. proposed algorithms interrupted
point time execution set ordered solutions obtained far
observed subsequent solutions generated algorithms resumed
again. Moreover, upper limit estimate number solutions required known
priori, algorithms optimized using estimate.
rest paper organised follows. necessary formalisms definitions
presented Section 2. Section 3, address problem generating ordered set
solutions trees. Subsequently Section 4, address problem finding alternative
solutions explicit acyclic AND/OR DAGs non-decreasing order cost. present two
different solution semantics AND/OR DAGs discuss existing approach well
proposed approach, along comparative analysis. Detailed experimental results,
including comparison performance proposed algorithms existing
algorithm (Elliott, 2007), presented Section 5. used randomly constructed
trees DAGs well well-known problem domains including 5-peg Tower
Hanoi problem, matrix-chain multiplication problem problem finding
secondary structure RNA test domain. time required memory used
generating specific number ordered solutions different domains reported
detail. Section 6, outline briefly applying proposed algorithms implicitly
specified AND/OR structures. Finally present concluding remarks Section 7.

2. Definitions
section, describe terminology AND/OR trees DAGs followed
definitions used paper. G = hV, Ei AND/OR directed acyclic graph,
V set nodes E set edges. G refer
nodes nodes DAG respectively. direction edges G
parent node child node. nodes G successors called terminal
nodes. non-terminal nodes G two types i) nodes ii) nodes .
V V set nodes G respectively, n = |V |, n = |V |,
n = |V |. start (or root) node G denoted vR . edges edges
edges emanate nodes nodes respectively.
Definition 2.a [Solution Graph] solution graph, S(vq ), rooted node vq V ,
finite sub-graph G defined as:
a. vq S(vq );
b. vq node G vq S(vq ), exactly one immediate
successors G S(vq );
c. vq node G vq S(vq ), immediate successors
G S(vq );
279

fiGhosh, Sharma, Chakrabarti, & Dasgupta

d. Every maximal (directed) path S(vq ) ends terminal node;
e. node vq successors G S(vq ).
solution graph G mean solution graph root vR .




Definition 2.b [Cost Solution Graph] G , every edge eqr E node vq
node vr finite non-negative cost ce (hvq , vr i) ce (eqr ). Similarly every node vq
finite non-negative cost denoted cv (vq ). cost solution defined recursively
follows. every node vq S, cost C(S, vq ) is:


cv (vq ), vq terminal node;






cv (vq ) + C(S, vr ) + ce (hvq , vr i) , vq node,

C(S, vq ) =
vr successor vq S;


P


C(S, vj ) + ce (hvq , vj i) , 1 j k, vq node
cv (vq ) +




degree k, v1 , . . . , vk immediate successors vq S.
Therefore cost solution C(S, vR ) denoted C(S). denote
optimal solution every node vq opt(vq ). Therefore, optimal solution
entire AND/OR DAG G , denoted Sopt , opt(vR ). cost optimal solution
rooted every node vq G Copt (vq ), defined recursively (for minimum cost
objective functions) follows:


cv (vq ), vq terminal node;







cv (vq ) + min Copt (vj ) + ce (hvq , vj i) , 1 j k, vq node
Copt (vq ) =
degree k, v1 , . . . , vk immediate successors vq G ;




cv (vq ) + P Copt (vj ) + ce (hvq , vj i) , 1 j k, vq node




degree k, v1 , . . . , vk immediate successors vq G .
cost optimal solution Sopt G denoted Copt (vR ) or, alternatively,
Copt (Sopt ). objective function needs maximized, instead min function,
max function used definition Copt (vq ).



may noted possible one solution node
vq qualify optimal one, i.e., cost, cost
minimum. Ties optimal solution node vq resolved arbitrarily
one among qualifying solutions (determined tie-breaking) marked
opt(vq ).
AND/OR tree, = hV, Ei, AND/OR DAG additionally satisfies
restrictions tree structure i.e., one parent node node vq
. context AND/OR trees, use eq denote edge points
vertex vq . alternating AND/OR tree, = hV, Ei, AND/OR tree
restriction alternation nodes nodes. Every
child node either node terminal node, every children
node either node terminal node. use term solution tree denote
solutions AND/OR trees.
discuss different solution semantics, namely tree based semantics, AND/OR
DAGs. Every AND/OR DAG converted equivalent AND/OR tree traversing
280

fiGenerating Ordered Solutions Explicit AND/OR Structures

intermediate nodes reverse topological order replicating subtree rooted
every node whenever in-degree traversed node 1. details
shown Procedure ConvertDAG. Suppose AND/OR DAG G converted
equivalent AND/OR tree . define solutions solutions G
tree based semantics.
Procedure ConvertDAG(G )
input : AND/OR DAG G
output: equivalent AND/OR tree
1 Construct list , non-terminal nodes G , sorted reverse topological
order;
2 empty
3
vq Remove first element ;
/* Suppose Ein (vq ) list incoming edges vq
*/
4
InDegree(vq ) > 1
5
2 InDegree(vq )
6
et Ein (vq )[i];
Replicate
sub-tree rooted vq vq root;
7
Modify target node et vq vq ;
8
9
end
10
end
11 end
paper use solution semantics defined Definition 2.a default
semantics solutions AND/OR DAGs. tree based semantics used,
explicitly mentioned.
2.1 Example

2, 34

h3i
3, 29

v1

v1

v2

h1i

h1i

h2i

v3

2, 37

v2

v4

2, 8

h1i

v5

h3i

h4i

v6

3, 11

v7
h1i

h1i

h2i

h2i

v9

v10

v11

v12

v13

v14

v15

v9

v10

5

7

6

9

12

15

20

5

7

Figure 1: Alternating AND/OR Tree
281

v6

2, 35

v8

3, 9

h1i

h1i

h1i

h3i

h4i

v7
h3i

2, 41

h4i

v5

40

12
h2i

v3

3, 43

v4

v8

4, 17

h2i

h5i

h1i

35
h5i

2, 89

17

h2i

Figure 2: AND/OR DAG

52

fiGhosh, Sharma, Chakrabarti, & Dasgupta

present example alternating AND/OR tree Figure 1. figure,
terminal nodes represented circle thick outline. nodes shown
figures outgoing edges connected semi-circular curve examples.
edge costs shown side edge within angled bracket. cost
terminal nodes shown inside box. every non-terminal node vq , pair costs,
cv (vq ) Copt (vq ), shown inside rectangle.
Figure 1 optimal solution every node shown using thick dashed edges
arrow head. optimal solution AND/OR tree traced following
thick dashed edges node v1 . cost optimal solution tree 34. Also,
Figure 2 shows example DAG; cost optimal solution DAG 89.

3. Generating Ordered Solutions AND/OR Trees
section address problem generating ordered solutions trees. use
notion alternating AND/OR trees, defined Section 2, present algorithms.
alternating AND/OR tree presents succinct representation correctness
proofs much simpler alternating AND/OR trees. Appendix C show every
AND/OR tree converted equivalent alternating AND/OR tree respect
solution space.
worth noting search space problems (e.g. search space multipeg Tower Hanoi problem) exhibit alternating AND/OR tree structure. Moreover,
algorithms presented alternating AND/OR trees work without modification
general AND/OR trees. section, first present existing algorithm (Elliott,
2007) briefly, present proposed algorithms detail.
3.1 Existing Bottom-Up Evaluation Based Method Computing Alternative
Solutions
illustrate working existing method proposed Elliott (2007)
computing alternative solutions trees using example alternating AND/OR tree.
method (will referred BU henceforth) computes k-best solutions bottomup fashion. every node, vq , k-best solutions computed k-best solutions
children vq . overall idea follows.
a. node vq , solution rooted vq obtained selecting solution
child. Therefore k-best solutions vq computed selecting top k solutions
entire pool consisting solutions children.
b. case nodes, every child node vq k solutions.
solution rooted node vq obtained combining one solution every
child vq . Different combinations solutions children nodes vq generate
different solutions rooted vq . Among combinations, top k combinations
stored vq .
Figure 3 show working existing algorithm. every intermediate node
2-best solutions shown within rounded rectangle. every node vq , ith -best
cost.
solution rooted vq shown triplet form |{z}
: < child, solidx >, |{z}
{z
}
|
example, node v1 second best solution shown 2 : hv2 , 2i, 37; means
282

fiGenerating Ordered Solutions Explicit AND/OR Structures

2nd best solution rooted v1 obtained selecting 2nd best solution v2 .
Similarly, every node vq , ith solution rooted vq shown triplet
form : |sol vec|, cost triplets. sol vec comma separated list solution indices
every element sol vec corresponds child vq . j th element sol vec
shows index solution j th child. example, 2nd best solution rooted v2
shown 2 : |2, 1|, 32. means 2nd best solution rooted v2 computed using
2nd best solution 1st child (which v5 ) best solution (1st ) 2nd
child (which v6 ). index sol vec corresponds child shown placing
child node name every index position.

2, 34

h3i

3, 29

v2

h5i

2, 8

v5

1 : hv2 , 1i, 34
2 : hv2 , 2i, 37

v1

h1i

h2i

v5 v6
1 : |1, 1|, 29
2 : |2, 1|, 32

v3

2, 37

35

h1i

1 : hv9 , 1i, 8
2 : hv10 , 1i, 11

v7 v8
1 : |1, 1|, 37
1 : |1, 2|, 40

v4

h3i

h4i

v6

3, 11

v7

1 : hv11 , 1i, 11
2 : hv12 , 1i, 15

12

h3i

h2i

v8

4, 17

h1i

h1i

1 : hv13 , 1i, 17
2 : hv14 , 1i, 20
h2i

h1i

h2i

v9

v10

v11

v12

v13

v14

v15

5

7

6

9

12

15

20

Figure 3: Example working existing algorithm
existing method works input parameter k, i.e., number solutions
generated known priori. method inherently incremental
nature, thus perform efficiently solutions needed demand, e.g.,
first, top 20 solutions needed, next 10 solutions needed. case
top 20 solutions recomputed computing next 10 solutions, i.e.,
21st solution 30th solution. Next present proposed top-down approach
suffer limitation.
3.2 Top-Down Evaluation Algorithms Generating Ordered Solutions
far discussed existing approaches primarily use bottom-up approach
computing ordered solutions. propose top-down approach generating alternative solutions non-decreasing order cost. may noted top-down
283

fiGhosh, Sharma, Chakrabarti, & Dasgupta

approach incremental nature. use edge marking based algorithm, Alternative
Solution Generation (ASG), generate next best solutions previously generated solutions. initial phase ASG algorithm, compute optimal solution
given alternating AND/OR tree perform initial marking edges.
following terminology notions used describe ASG algorithm.
context AND/OR trees, use eq denote edge points vertex vq .
use following definitions describing proposed top-down approaches.
Definition 3.c [Aggregated Cost] AND/OR DAG G , aggregated cost, ca ,
edge eij node vi node vj , defined : ca (eij ) = ce (eij ) + Copt (vj ).


v1

2, 34

[e2 : 5]

2,3 : 5

h3i

3, 29

3,4 : 1

v2

h1i

h2i

[e3 : 1]

v3

2, 37

v4

35
h5i

2, 8

h1i

v5

h4i

v6

3, 11

h3i

v7

v8

4, 17

12
[e11 : 4]

[e9 : 3]
h1i

9,10 : 3

h2i

h2i

[e13 : 3]
h3i

11,12 : 4

h1i

[e14 : 6] h1i

h2i

13,14 : 3 14,15 : 6

v9

v10

v11

v12

v13

v14

v15

5

7

6

9

12

15

20

Figure 4: Example OR-edge marking swap option
Marking edge : notion marking edge follows.
node vq , L(vq ) list edges vq sorted non-decreasing order aggregated
cost edges. define (i,i+1) difference cost edges, ei
ei+1 , ei ei+1 emanate node vq , ei+1 edge next
ei L(vq ). Procedure MarkOR describes marking process edges
node. Intuitively, mark represents cost increment incurred corresponding
edge replaced solution next best sibling. edge maximum
aggregated cost marked.
Consider solution, Scur , containing edge ei = (vq , vi ), ei Eopt (Scur ).
mark ei cost increment incurred construct next best solution
Scur choosing another child vq . Figure 4 marks corresponding edges
e2 , e3 , e9 , e11 , e13 , e14 [e2 : 5], [e3 : 1], [e9 : 3], [e11 : 4], [e13 : 3], [e14 : 6].
284

fiGenerating Ordered Solutions Explicit AND/OR Structures

Procedure MarkOR(vq )
1

2
3
4
5
6
7
8

Construct L(vq ) ; /* List edges vq sorted non-decreasing order ca
values */
count number elements L(vq ) ;
1 = count 1
ec L(vq )[i] ;
en L(vq )[i + 1] ;
tmp = (ca (en ) ca (ec )) ;
Mark ec pair [en : tmp ] ;
end

Definition 3.d [Swap Option] swap option ij defined three-tuple hei , ej , ij
ei ej emanate node vq , ej edge next ei L(vq ),
ij = ca (ej ) ca (ei ). Also, say swap option ij belongs node vq .


Consider node vq sorted list L(vq ). may observed L(vq )
every consecutive pair edges forms swap option. Therefore, k edges L(vq ),
k1 swap options formed. node vq , swap options ranked according
rank original edges L(vq ). Figure 4 swap options : (2,3) = he2 , e3 , 5i,
(3,4) = he3 , e4 , 1i, (9,10) = he9 , e10 , 3i, (11,12) = he11 , e12 , 4i, (13,14) = he13 , e14 , 3i,
(14,15) = he14 , e15 , 6i. Consider node v1 L(v1 ) = he2 , e3 , e4 i. Therefore, swap
options, (2,3) (3,4) , belong v1 . node v1 , rank (2,3) (3,4) 1 2
respectively.
Definition 3.e [Swap Operation] Swap operation defined application swap
option ij = hei , ej , ij solution Sm contains edge ei following way:
. Edge e
a. Remove subtree rooted vi Sm . Let modified tree Sm

original edge ij .
, constructed previous step. Let
b. Add subtree opt(vj ) Sm
. Edge e swapped edge .
newly constructed solution Sm
j
ij

Intuitively, swap operation ij = hei , ej , ij constructs new solution Sm


Sm contains edge ei . Moreover, cost Sm increased ij compared cost
Sm C(Sm , vi ) = Copt (vi ).



proposed algorithms use swap option based compact representation, named signature, storing solutions. Intuitively, alternative solution described
set swap operations performed optimal solution Sopt . interesting observe
applying ordered sequence swap options, h1 , , k i, application
swap operation creates intermediate alternative solution. example,
first swap option sequence, 1 , applied optimal solution, Sopt , new solution, say S1 , constructed. Then, 2nd swap option, 2 , applied S1 , yet
another solution S2 constructed. Let Si denote solution obtained applying
swap options, 1 , , , Sopt sequence. Although, ordered sequence swap
options, h1 , , k i, used compact representation alternative
solution, following key points important observe.
A. Among possible sequences generate particular solution, need preclude
sequences contain redundant swap options (those swap options whose orig285

fiGhosh, Sharma, Chakrabarti, & Dasgupta

inal edge present solution applied). formally defined
later superfluous swap options. order applying swap options another important aspect. two swap options, j 1 < j k
source edge j belongs sub-tree included solution
Si applying Si1 . case, apply j place , i.e.,
apply j directly Si1 , effect source edge j present
Si1 , i.e., swapping location j sequence, j becomes
redundant swap option solution constructed would different swapped
sequence original sequence. formally define order relation pair
swap options based observation later part section formalize
compact representation solutions based order relation.
B. Suppose swap option j belongs node vpj . important observe
application j Sj1 construct Sj , invalidates application
swap options belong edge path root node vpj
solution Sj . Sj application swap option
belongs edge path root node vpj would make swap
vpj redundant. fact, swap option belonging node vpi , 1 j,
application swap options belong edge path
root node vpi invalidated solution Sj reason. condition
restricts set swap options applied particular solution.
C. Finally, two swap options j 1 < j k
j independent other, is, (a) applying Si1 subsequently
application j Sj1 , (b) applying j Si1 subsequently application
Sj1 , ultimately construct solution. happens
original edges j present Si1 , thus application one swap option
influence application other. However, desirable use one
way generate solution Sj . Section 3.3, propose variation top-down
approach (called LASG) resolves issue.
Definition 3.f [Order Relation R] define order relation, namely R, pair
swap options follows.
a. path vi vr , ei er edges, qi rj
swap options, (qi , rj ) R. example, Figure 4 ((3,4) , (13,14) ) R.
b. pq = hep , eq , pq rt = , et , rt two swap options vq = vr ,
(pq , rt ) R. Figure 4 ((2,3) , (3,4) ) R.


Implicit Representation Solutions : use implicit representation
storing every solution optimal one. solutions constructed
optimal solution applying set swap options optimal solution
following way. (i , j ) R, applied j . Therefore, every solution
represented sequence swap options, appears j (i , j ) R.
Intuitively application every swap option specifies swapped edge
part solution. Since swap options applied specific order R, may
happen edge become part solution due application
earlier swap option may get swapped due application later swap option.
286

fiGenerating Ordered Solutions Explicit AND/OR Structures

Definition 3.g [Superfluous Swap Option] Consider sequence swap options =
h1 , , corresponding solution Sm . Clearly possible swap option, ,
1 m, present sequence original edge
present solution Si1 constructed successive applications swap
options 1 , , i1 solution Sopt . application effect Si1 , i.e.,
solution Si identical solution Si1 . swap option superfluous swap
option respect sequence swap options corresponding solution Sm .


Property 3.1 sequence swap options corresponding solution minimal,
superfluous swap option.
property follows definition superfluous swap options notion
implicit representation solution.
Definition 3.h [Signature Solution] minimal sequence swap options corresponding solution, Sm , defined signature, Sig(Sm ), solution.
may noted optimal solution Sopt alternating AND/OR tree ,
Sig(Sopt ) = {}, i.e., empty sequence. possible construct one signature
solution, R partial order. important observe different signatures
particular solution equal length sets swap options corresponding
different signatures equal. Therefore set swap options corresponding
signature canonical representation signature. Henceforth use set
notation describing signature solution.
v1

2, 39

2,3 : 5

h3i

3, 29

3,4 : 1
h2i

v3

v2

h1i

2, 37

v4

35
h5i

2, 8

h1i

v5

h3i

h4i

v6

3, 11

v7

v8

4, 17

12
h2i

h2i
h1i
9,10 : 3

h3i

11,12 : 4

h1i

h1i

h2i

13,14 : 3 14,15 : 6

v9

v10

v11

v12

v13

v14

v15

5

7

6

9

12

15

20

Figure 5: solution, S2 , AND/OR tree shown Figure 4
Figure 5 show solution, say S2 , AND/OR tree shown Figure 4.
solution highlighted using thick dashed lines arrow head. pair, cv (vq ), C(S2 , vq ),
287

fiGhosh, Sharma, Chakrabarti, & Dasgupta

shown within rectangles beside node vq solution S2 , used rectangles rounded corner whenever C(S2 , vq ) 6= Copt (vq ). Since S2 generated applying
swap option (2,3) solution Sopt , signature S2 , Sig(S2 ) = h(2,3) i. Consider
another sequence, 2 = h(2,3) , (9,10) i, swap options. worth noting 2
represents solution S2 . second swap option 2 , namely 9,10 ,
applied solution constructed applying (2,3) Sopt source edge (9,10) ,
e9 , present solution. Hence (9,10) superfluous swap option 2 .
Definition 3.i [Vopt Eopt ] solution graph Sm AND/OR DAG G ,
define set nodes,
fiVopt (Sm ), set edges, Eopt (Sm ), as:
a. Vopt (Sm ) = vq vq Sm solution graph Sm (vq ) identical solution graph
opt(vq )



b. Eopt (Sm ) = epr edge epr Sm , vr Vopt (Sm )
Clearly, node vq Vopt (Sm ), vq present Sopt , (a) solution graph
Sm (vq ) identical solution graph Sopt (vq ), (b) C(Sm , vq ) = Copt (vq )


Definition 3.j [Swap List] swap list corresponding solution Sm , L(Sm ), list
swap options applicable Sm . Let Sig(Sm ) = {1 , , } i, 1 m,
swap option belongs node vpi . application swap options
belong edges path root node vpi invalidated solution
Sm . Hence, remaining swap options invalidated Sm applied
Sm constructing successor solutions Sm .
important observe swap option , source edge belongs
Eopt (Sm ), application invalidated Sm . Hence, solution Sm , construct L(Sm ) restricting swap operations edges belonging Eopt (Sm ).
Moreover, condition ensures cost newly constructed solution
computed directly form cost parent solution value applied swap
constructed form
option. elaborate, suppose solution Sm
applying jk .

) = C(S ) +
cost Sm computed directly form C(Sm ) jk : C(Sm

jk
ej Eopt (Sm ). Procedure ComputeSwapList(Sm ) describes details computing swap
options given solution Sm .


Procedure ComputeSwapList(Sm)
1
2
3

4
5
6

L(Sm ) ; Compute Eopt (Sm );
foreach edge ec Eopt (Sm )
exists swap option edge ec
/* Suppose ec emanates node vq ec = L(vq )[i]. ec
marked pair htmp , en i, en = L(vq )[i + 1]
*/
cn hec , en , tmp i; Add cn L(Sm );
end
end

swap list optimal solution, L(Sopt ), Figure 4, {(2,3) , (9,10) }.
solution S1 , shown Figure 6, Vopt = {v6 , v10 }, except node v6 v10 ,
nodes vi S1 , opt(vi ) 6= S1 (vi ). rectangles rounded corner used
C(S1 , vq ) 6= Copt (vq ). Therefore, Eopt = {e6 , e10 }. Since exists swap option
288

fiGenerating Ordered Solutions Explicit AND/OR Structures

v1

2, 37

2,3 : 5

h3i

3, 32

3,4 : 1
h2i

v2

v3

h1i

2, 37

v4

35
h5i

2, 11

h1i

v5

h4i

v6

3, 11

h3i

v7

v8

4, 17

12
h2i
h1i
9,10 : 3

h2i

h3i

11,12 : 4

h1i

h1i

h2i

13,14 : 3 14,15 : 6

v9

v10

v11

v12

v13

v14

v15

5

7

6

9

12

15

20

Figure 6: solution, S1 , AND/OR tree shown Figure 4
edges, e6 e10 , swap list solution S1 , L(S1 ) = . Hence, solution
Sm , L(Sm ) may empty, though Vopt (Sm ) never empty.
Although use notation ij denote swap option edge ei original
edge edge ej swapped edge, succinct representation, use single
subscript, 3 , k , ij etc., represent swap option. alternative representation
swap options relate edge.
Definition 3.k [Successors Predecessors Solution] set successors
predecessors solution
Sm defined as:
constructed
a. Succ(Sm ) = {Sm
applying swap option

belongs swap
list Sm }
Succ(S )}


b. P red(Sm ) = {Sm



Property 3.2 solution Sm alternating AND/OR tree following state P red(S ), C(S ) C(S )
ment holds: Sm




property follows definitions. One special case requires attention. Consider
) = C(S ) P red(S ). case arise swap
case C(Sm



option cost 0 applied Sm . occurs case tie.
3.2.1 ASG Algorithm
present ASG, best first search algorithm, generating solutions alternating
AND/OR tree non-decreasing order costs. overall idea algorithm
follows. maintain list, Open, initially contains optimal solution Sopt .
point time Open contains set candidate solutions next best
289

fiGhosh, Sharma, Chakrabarti, & Dasgupta

solution non-decreasing order cost selected. iteration minimum cost
solution (Smin ) Open removed Open added another list, named, Closed.
Closed list contains set ordered solutions generated far. successor
set Smin constructed successor solution currently present
Open well already added Closed inserted Open. However
optimization, use sublist Closed, named TList, store relevant portion Closed
checking respect solutions TList sufficient figure whether
successor solution already added Closed. interesting observe
algorithm interrupted time set ordered solutions computed far
obtained. Also, algorithm resumed solutions needed.
details ASG algorithm presented Algorithm 4.
Algorithm 4: Alternative Solution Generation (ASG) Algorithm

1

2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20

input : alternating AND/OR tree
output: Alternative solutions non-decreasing order cost
Compute optimal solution Sopt , perform edge marking populate
swap options;
Create three lists, Open, Closed, TList, initially empty;
Put Sopt Open;
lastSolCost C(Sopt );
Open empty
Smin Remove minimum cost solution Open ;
lastSolCost < C(Smin )
Remove elements TList;
lastSolCost C(Smin );
end
Add Smin Closed TList;
Compute swap list, L(Smin ), Smin ;
/* Construct Succ(Smin ) using L(Smin ) add new solutions Open
*/
foreach ij L(Smin )
Construct Sm applying ij Smin ;
Construct signature Sm , Sig(Sm ), concatenating ij Sig(Smin );
/* Check whether Sm already present Open TList
*/
(Sm Open) (Sm TList)
Add Sm Open;
end
end
Report solutions Closed;

pseudo-code Line-1 Line-4 computes optimal solution Sopt , performs
marking edges, populates swap options, initializes Open, Closed TList.
loop Line-10 responsible generating new solution every time executed
long Open empty. Line-6 ASG algorithm, solution
current minimum cost solution Open (Smin ) selected removed Open.
TList populated maintained Line-7 Line-10. loop Line-13 generates

290

fiGenerating Ordered Solutions Explicit AND/OR Structures

successor solutions Smin one one adds newly constructed solutions
Open newly constructed solution already present Open well added
TList (Line-16 checking). proof correctness Algorithm 4 presented
Appendix A. discuss following issues related Algorithm 4.
Checking Duplication : order check whether particular solution Si already
present Open TList, signature Si matched signatures solutions
already present Open TList. sufficient check equality
set swap options respective signatures set unique particular
solution. may noted TList used optimization, avoids searching
entire Closed list.
Resolving Ties : removing minimum cost solution Open list, tie
may encountered among set solutions. Suppose tie among set Stie =
{S1 , , Sk }. ties resolved favor predecessor solutions, is,


Si , Sj Stie , (If Si predecessor Sj ) (Si removed Sj )
cases ties resolved arbitrarily favor solution
added Open first.
3.2.2 Working ASG Algorithm
illustrate working ASG algorithm example AND/OR tree shown
Figure 4. contents different lists obtained first iterations outermost
loop shown Table 1. use signature solution representation
purpose. solutions already present Open constructed expanding
current Smin , highlighted under-braces.
It.
1
2
3
4

Smin
{}
{(9,10) }
{(2,3) }
{(2,3) , (3,4) }

L(Smin )
(2,3) , (9,10)

(3,4)
(11,12) , (13,14)

5

{(2,3) , (3,4) ,
(13,14) }

(11,12) , (14,15)

6

{(2,3) , (3,4) ,

(13,14)

(11,12) }

7

{(2,3) , (3,4) ,
(13,14) , (11,12) }

(14,15)

Open
{(2,3) }, {(9,10) }
{(2,3) }
{(2,3) , (3,4) }
{(2,3) , (3,4) , (11,12) },
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (11,12) },
{(2,3) , (3,4) , (13,14) , (11,12) }
{(2,3) , (3,4) , (13,14) , (14,15) }
{(2,3) , (3,4) , (13,14) , (11,12) },
|
{z
}
{(2,3) , (3,4) , (13,14) , (14,15) }

Closed
{}
{}, {(9,10) }
{}, {(9,10) }, {(2,3) }
{}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) }
{}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) }
{(2,3) , (3,4) , (13,14) }
{}, {(9,10) }, {(2,3) },

TList
{}
{(9,10) }
{(2,3) }
{(2,3) , (3,4) }
{(2,3) , (3,4) ,
(13,14) }
{(2,3) , (3,4),

{(2,3) , (3,4) }
(11,12) }
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (11,12) }
{(2,3) , (3,4) , (13,14) , (14,15) }, {}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) ,
{(2,3) , (3,4) , (13,14) ,
{(2,3) , (3,4) }
(13,14) , (11,12) }
(11,12) , (14,15) }
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (11,12) }
{(2,3) , (3,4) , (13,14) ,
(11,12) }

Table 1: Working ASG Algorithm
291

fiGhosh, Sharma, Chakrabarti, & Dasgupta

entering outermost loop (Line 5), ASG computes optimal solution
Sopt , populates swap options, inserts Sopt Open. Thus, point time, Open
contains optimal solution Sopt ; Closed TList empty. first iteration
Sopt (the signature Sopt {}) selected removed Open. swap list
Sopt , L(Sopt ), computed. L(Sopt ), consists two swap options, namely (2,3) (9,10) .
ASG adds two new solutions {(2,3) } {(9,10) } Open. solution Sopt added
Closed TList.
next iteration, solution {(9,10) } minimum cost among solutions
currently Open, selected removed Open, swap list {(9,10) } computed
subsequently {(9,10) } added Open TList. happens, L({(9,10) }) = (owing
fact Eopt = {e6 , e10 } exists swap option edges, e6 e10 ),
thus nothing else happens iteration. next iteration, solution {(2,3) } removed
Open ultimately solution {(2,3) , (3,4) } added Open adding {(2,3) }
Closed well TList. Next two iterations proceed similar fashion. Now, consider
6th iteration. iteration, solution {(2,3) , (3,4) , (11,12) } removed Open,
successor set one solution, {(2,3) , (3,4) , (11,12) , (13,14) }, already present
Open (inserted Open Iteration-5). Therefore, solution {(2,3) , (3,4) , (11,12) , (13,14) }
inserted Open again. shown Iteration-7 Table 1.
3.3 Technique Avoiding Checking Duplicates Open
section, present technique avoid checking done adding newly
constructed solution Sm Open determine whether Sm already present Open.
first explain scenario example, portion previous example
shown Figure 4. Figure 7-10, solutions shown using thick dashed line
arrow head. rectangles rounded corner used highlight fact
corresponding node marked solution belong Vopt set solution.
v4

2, 37
h4i

3, 11
h2i

4, 17
h3i

11,12 : 4

h4i

h3i

v7
h1i

v4

2, 44

v8

3, 15

h1i

13,14 : 3

h3i

v7

4, 20
h3i

h2i

v8
h1i

h1i

v11

v12

v13

v14

v11

v12

v13

v14

6

9

12

15

6

9

12

15

Figure 8: Solution S3

Figure 7: Running Example

Consider solutions S1 , S2 S3 (shown Figure 9, Figure 10 Figure 8).
(a) L(Sopt ) = {(11,12) , (13,14) }, (b) Succ(Sopt ) = {S1 , S2 },
(c) Sig(S1 ) = {(13,14) }, (d) Sig(S2 ) = {(11,12) }, (e) Sig(S3 ) = {(13,14) , (11,12) }.
Algorithm 4 constructs solution S3 (shown Figure 8) adding Open twice
(i) part adding Succ(S1 ) Open, (ii) adding Succ(S2 ) Open.
292

fiGenerating Ordered Solutions Explicit AND/OR Structures

v4

2, 40

h4i

3, 11
h2i

4, 20
h3i

11,12 : 4

h4i

h3i

v7

v4

2, 41

v8

h1i

3, 15

h1i

h3i

v7

4, 17
h3i

h2i

h1i

v8
h1i

13,14 : 3

v11

v12

v13

v14

v11

v12

v13

v14

6

9

12

15

6

9

12

15

Figure 9: Solution S1

Figure 10: Solution S2

use following definitions describe another version ASG algorithm,
constructs solutions way check find whether solution already
added Open avoided.
Definition 3.l [Solution Space DAG(SSDAG)] solution space DAG alternating
AND/OR tree directed acyclic graph (DAG), G = hV, Ei, V set
possible solutions AND/OR tree , E set edges defined as:



Sp , Sm V,



E = espm fifi espm directed edge node Sp Sm ,


Sm Succ(Sp )

Clearly Sopt root node G .




Definition 3.m [Solution Space Tree Completeness] solution space tree
alternating AND/OR tree tree = hV , E V V, V set
possible solutions AND/OR tree , E set edges defined
as:



Sp , Sm V ,









e


directed
edge

node



,

p

pm

E = epm

Sp P red(Sm ),




P red(Sm ), (Sp 6= ) edge Sm .
p
p
p
sibling set solution Sm , denoted using Sib(T , Sm ). solution space tree
AND/OR tree complete V = V.


may noted complete solution space tree alternating AND/OR tree
necessarily unique. possible alternating AND/OR tree
one complete solution space tree. However solution space DAG AND/OR tree
unique.
Definition 3.n [Native Swap Options Solution] Consider solution Sm alternating AND/OR tree . Suppose Sm constructed applying swap option ij
solution Sp . Since swap option ij = hei , ej , ij used construct Sm , node vj
present Sm . native swap options solution Sm respect swap option ij ,
N (Sm , ij ), subset L(Sm ), comprises following swap options :
293

fiGhosh, Sharma, Chakrabarti, & Dasgupta

v1

2, 49

2,3 : 5

h3i

3, 32

3,4 : 1
h2i

v2

v3

h1i

2, 43

v4

35
h5i

2, 11

h1i

v5

h3i

h4i

v6

3, 11

v7

v8

4, 23

12
h2i
h1i
9,10 : 3

h2i

h3i

11,12 : 4

h1i

h1i

h2i

13,14 : 3 14,15 : 6

v9

v10

v11

v12

v13

v14

v15

5

7

6

9

12

15

20

Figure 11: solution, S4 , AND/OR tree shown Figure 4
a. jk , jk swap option edge ej
b. , belongs node vq vq node Sm (vj )
use term N (Sm ) denote native swap options ij understood
context. Intuitively native swap options solution Sm swap options
become available immediately applying ij , available predecessor
solution Sm .



Consider solution S4 shown Figure 11 Sig(S4 ) = {(2,3) , (3,4) , (13,14) }.
solution highlighted using thick dashed lines arrow head. used rectangles rounded corner beside node vq solution S4 , C(S4 , vq ) 6= Copt (vq ).
Suppose S4 constructed form solution S3 (where Sig(S3 ) = {(2,3) , (3,4) }) using swap
option (13,14) . N (S4 , (13,14) ) = {(14,15) } whereas L(S4 ) = {(11,12) , (14,15) }.
consider solution S6 Sig(S6 ) = {(2,3) , (3,4) , (11,12) , (13,14) ). worth observing applying native swap options S4 instead swap options L(S4 )
prevents construction solution S6 solution S4 . S6 constructed
applying (13,14) solution S5 , Sig(S5 ) = {(2,3) , (3,4) , (11,12) }. However, may
noted (13,14) native swap option solution S5 .
3.3.1 Lazy ASG Algorithm
intuition behind version ASG algorithm follows. newly
constructed solution Sm , need check whether Sm already present Open
Sm constructed part computing successor set multiple solutions.
Instead using entire swap list solution construct successors
add solutions Open, using native swap options constructing subset
successor set ensures following. subset constructed using native swap options
294

fiGenerating Ordered Solutions Explicit AND/OR Structures

consists solutions currently present Open thus
added Open without comparing existing entries Open. construction

remaining successor solution Sm
insertion Open delayed
added Closed.
every predecessor solution Sm
Algorithm 5: Lazy ASG (LASG) Algorithm

1

2
3
4
5
6
7
8
9
10
11

12

13

14
15
16

17
18

19
20
21
22
23
24
25
26
27
28

input : alternating AND/OR tree
output: Alternative solutions non-decreasing order cost
Compute optimal solution Sopt , perform edge marking populate
swap options;
Create two lists, Open Closed, initially empty;
Put Sopt Closed list;
Create solution space tree Sopt root;
Compute swap list, L(Sopt ), Sopt ;
Construct Succ(Sopt ) using L(Sopt );
forall Sm Succ(Sopt )
Add Sm Open;
end
Open empty
Smin Remove minimum cost solution Open ;
/* Suppose Smin constructed Sm applying swap option ij
*/
Add node corresponding Smin connect node using edge
Sm ;
Compute swap list L(Smin ) list native swap options N (Smin , ij );
/* Expansion using native swap options
*/
foreach tmp N (Smin , ij )
Construct Stmp Smin applying tmp ;
Construct signature Stmp , Sig(Stmp ), concatenating tmp
Sig(Smin );
Add Stmp Open;
end
/* Lazy Expansion
*/

forall Sp Sib(T , Smin )
ij L(Sp )
Construct Sp Sp using ij ;
Construct signature Sp , Sig(Sp ), concatenating ij Sig(Sp );
Add Sp Open;
end
end
Add Smin Closed;
end
Report solutions Closed;

solution space tree maintained throughout course algorithm
added Closed. Based idea
determine every predecessor Sm
295

fiGhosh, Sharma, Chakrabarti, & Dasgupta

present lazy version ASG algorithm, named LASG. selecting minimum cost
solution Open, algorithm explores successor set current minimum cost
solution lazy fashion. solution Sm , first subset Succ(Sm ) constructed
using native swap options Sm . solutions belong Succ(Sm )
explored late possible described above. resolving ties, LASG algorithm
uses strategy used ASG algorithm. details LASG algorithm
presented Algorithm 5. proof correctness algorithm presented
Appendix B.
Consider example tree shown Figure 7 solutions S1 S2 (shown Figure 9
Figure 10). Initially Open contain Sopt N (Sopt ) = {(11,12) , (13,14) }.
Sopt selected Open, S1 S2 added Open. Next S1 selected
followed S2 . Since, N (S1 ) = N (S2 ) = , selecting S1 S2 successor
solutions constructed using native swap list. Among predecessors S3 , S2
added last Closed. selecting removing S2 Open, solution S3 constructed
previously selected predecessor S1 using swap option (11,12) used
construct solution S2 Sopt .
3.3.2 Working LASG Algorithm (on AND/OR tree Figure 4)
entering outermost loop (Algorithm 5, Line 10), LASG computes
optimal solution Sopt constructs Succ(Sopt ).
solutions Succ(Sopt )
added Open contents Open becomes {(2,3) }, {(9,10) } . contents
different lists solution added Closed shown Table 2. solutions
represented using signatures. solutions added Open result
lazy expansion, highlighted using under-brace.
Iteration
1
2
3

Smin
{}
{(9,10) }
{(2,3) }
{(2,3) , (3,4) }

N (Smin )
(2,3) , (9,10)

(3,4)
(11,12) , (13,14)

4

{(2,3) , (3,4) , (13,14) }

(14,15)

5

{(2,3) , (3,4) , (11,12) }



6

{(2,3) , (3,4) , (13,14) ,
(11,12) }



Open
{(2,3) }, {(9,10) }
{(2,3) }
{(2,3) , (3,4) }
{(2,3) , (3,4) , (11,12) },
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (11,12) },
{(2,3) , (3,4) , (13,14) , (14,15) }

Closed
{}
{}, {(9,10) }
{}, {(9,10) }, {(2,3) }
{}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) }
{}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) }
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (13,14) , (14,15) }, {}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) , (13,14) , (11,12) }
{(2,3) , (3,4) }
|
{z
}
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (11,12) }
{(2,3) , (3,4) , (13,14) , (14,15) }, {}, {(9,10) }, {(2,3) },
{(2,3) , (3,4) }
{(2,3) , (3,4) , (13,14) }
{(2,3) , (3,4) , (11,12) }
{(2,3) , (3,4) , (13,14) ,
(11,12) }

Table 2: Working LASG Algorithm
generating first four solutions, contents different lists LASG
identical contents corresponding lists ASG (shown Table 1).
296

fiGenerating Ordered Solutions Explicit AND/OR Structures

soltuions, native swap list equal actual swap list solution. worth noting that, unlike ASG, LASG outermost loop starts
generating optimal solution Sopt , thus generating solution
iteration number LASG less ASG 1. 4th iteration, solution S4 = {(2,3) , (3,4) , (13,14) } native swap list equal swap list
described previously. holds true solution S5 = {(2,3) , (3,4) , (11,12) }
solution S6 = {(2,3) , (3,4) , (13,14) , (11,12) }. important observe LASG adds
solution S6 = {(2,3) , (3,4) , (13,14) , (11,12) } Open generation solution
S5 = {(2,3) , (3,4) , (11,12) } part lazy expansion (highlighted using under-brace
Table 2). Whereas, ASG algorithm adds S6 Open generating solution
S4 = {(2,3) , (3,4) , (13,14) }.
3.4 Complexity Analysis Comparison among ASG, LASG BU
section present complexity analysis ASG LASG compare
BU. use following parameters analysis.
a. n n denote total number nodes number nodes
alternating AND/OR tree.
b. denotes degree node maximum number children.
c. denotes maximum number edges solution.
d. denotes maximum size Open. present complexity analysis
generating c solutions. Therefore size Closed O(c).
3.4.1 Complexity ASG
Time Complexity : time complexity major steps Algorithm 4
follows.
a. Computing first solution done bottom-up fashion, thus requiring O(n )
steps. edges emanating node sorted non-decreasing order
aggregated cost compute marks edges, marking process takes
n .d. log . Since value
large general (can upper bounded
constant), n .d. log = O(n ).
b. number swap options available solution equal number
edges solution. Thus, swap list every solution built
O(m) time. c solutions, generating swap options take O(c.m).
c. Since size successor set solution most, size Open,
c.m. size TList equal c (the size
Closed).
d. Open list implemented using Fibonacci heap. Individual insert delete
operation Open take O(1)(amortized) O(lg o) time respectively. Hence,
inserting Open deleting Open altogether takes O(o. lg o) time
O(c.m. log(c.m)).
e. checking duplicates requires scanning entire Open TList. Since
length TList c, newly constructed solution checking takes
O(c + o) time O(c + o) solutions generated. Since O(c + o) actually
O(o), generating c solutions, step takes O(o)2 time. Also, maximum value
297

fiGhosh, Sharma, Chakrabarti, & Dasgupta

O(c.m). Thus, time complexity step O(c.m)2 . Clearly
step dominates O(o. lg o) total time taken insertions Open
deletions Open.
However, time bound improved maintain hash map
solutions Open TList, case checking duplicates
done O(o) time. case O(o. lg o) (total time taken insertions
Open deletions Open) becomes dominant time required checking
duplicates.
f. upper limit estimate could made estimating size solution tree

n regular complete alternating AND/OR trees. important
observe value independent average degree node
.
Combining
together get time complexity
ASG algorithm :

factors


2
2
2
2
n + = n + (c.m) = n + c .n = O(c .n )
Howeverif additional
hash
reduced :

map used time complexity



n + o. lg = n + c. n . lg(c.n ) = n + n .(c. lg c + c. lg n )
Space Complexity: following data-structures primarily contribute space complexity ASG algorithm.
a. Three lists, namely, Open, Closed, TList maintained throughout course
running ASG. contributes O(o + c) factor, O(o).
b. Since number swap options upper bounded total number edges,
constructing swap list contributes factor, O(n .d) space complexity.
marking solution requires putting mark every node AND/OR
tree, thus adding another O(n ) space clearly dominated previous
O(n .d) factor.
c. Since signature solution essentially set swap options, size
signature upper bounded total number swap options available. Combining
Open Closed list, altogether (c + o) solutions need stored.
Since (c + o)

O(o), total space required storing solutions o.n .d .
Combining
factors
together get space complexity ASG algorithm :
+ n .d + o.n .d = O(o.n .d)
additional
hash map used improve time complexity, another addi
tional o.n .d space required maintaining hash map. Although exact space
requirement doubled, asymptotically space complexity remains same.
3.4.2 Complexity LASG
Time Complexity : Compared Algorithm 4, Algorithm 5 check
duplicates adds solution Open required. Therefore
terms complexity remain except term corresponding checking
duplicates. However, created maintained course Algorithm 5.
Creating maintaining tree require O(c) time. lazy expansion
swap list previously generated sibling solutions searched (Line 19 Line 20
Algorithm 5). size swap list solution O(m), maximum
number edges solution. O(m) sibling solutions
298

fiGenerating Ordered Solutions Explicit AND/OR Structures

solution. Therefore complexity lazy expansion O(c.m2 ). Since O(c.m2 )
dominant factor, time complexity LASG O(c.m2 ) = O(c.n ).
Space Complexity : Compared ASG algorithm, LASG algorithm maintain
TList. However LASG maintains solution space tree whose size equal
Closed list, thus adding another O(c) factor space complexity incurred ASG
algorithm. interesting observe worst case space complexity remains O(o +
n .d + o.n .d) = O(o.n .d) equal space complexity ASG algorithm.
3.4.3 Comparison BU
time complexity generating c best solutions AND/OR tree O(n .c. log c)
space complexity O(n .c). detailed analysis found work
Elliott (2007). Since, n .d = O(n ), space complexity ASG LASG
algorithm reduces O(n .c) time complexity LASG log c factor better
BU whereas time complexity ASG quadratic respect c compared
(c. log c) factor BU. additional hash-map used reduce time overhead
duplicate checking, ASG beats LASG
BU terms time complexity,

O(n ) n .(c. lg c + c. lg n ) asymptotically lower O(n .c. log c).
However worst case complexity possible AND/OR trees duplicate solution generated. Empirical results show length Open, hardly reaches
O(c.m).

4. Ordered Solution Generation AND/OR DAGs
section, present problem generating solutions non-decreasing order
cost given AND/OR DAG. present working existing algorithm
generating solution tree based semantics default semantics. Next present
modifications ASG LASG handling DAG.
4.1 Existing Bottom-Up Algorithm
Figure 12 shows example working existing bottom-up approach, BU,
AND/OR DAG Figure 2. use notations used Figure 3 describe
different solutions Figure 12 generation top 2 solutions tree-based
semantics shown.
important notice although BU correctly generates alternative solutions
AND/OR DAGs tree based semantics, BU may generate solutions
invalid default semantics. Figure 13 present solution AND/OR DAG
Figure 2. solution example solution correct tree-based
semantics invalid default semantics. solution DAG (highlighted using
thick dashed lines arrow heads) Figure 13 generated 3rd solution
AND/OR DAG Figure 2 running BU. every non-terminal node, entry
(within rectangle) corresponding 3rd solution highlighted using bold face. may
noted terminal nodes, v9 v10 , included solution DAG though
emanate parent node. Therefore, solution valid one
default semantics.
299

fiGhosh, Sharma, Chakrabarti, & Dasgupta

2, 89

v1

v2 v3
1 : |1, 1|, 89
2 : |2, 1|, 90

h1i
3, 43

v2

1 : hv5 , 1i, 43
2 : hv4 , 1i, 44

v4
40

h1i

v7

1 : hv5 , 1i, 41
2 : hv5 , 2i, 44

3, 43

h1i

v7 v8
1 : |1, 1|, 35
2 : |2, 1|, 38

v2

1 : hv9 , 1i, 9
2 : hv10 , 1i, 12

v6

v4

52

40

1 : hv5 , 1i, 43
2 : hv4 , 1i, 44

v5

2, 35

v8

3, 9
h1i

v7

2, 41

v3

h4i

1 : hv5 , 1i, 41
2 : hv5 , 2i, 44
h1i

v7 v8
1 : |1, 1|, 35
2 : |2, 1|, 38

v6
52

h3i

h4i

17

h2i

h2i

h5i

h1i

h3i

h4i
3, 9

v3

h4i
v5

2, 35

2, 41

v1

h1i

h2i

h5i

h1i

2, 89

v2 v3
1 : |1, 1|, 89
2 : |2, 1|, 90
3 : |1, 2|, 92

1 : hv2 , 1i, 34
2 : hv2 , 2i, 37

v8
17

h2i

v9

v10

v9

v10

5

7

5

7

Figure 13: solution (tree based semantics)

Figure 12: BU approach AND/OR DAG

Proposed Extension BU Generate Alternative Solutions Default
Semantics : propose simple top-down traversal pruning based extension
BU generate alternative solutions default semantics. generating ordered
solutions node vq combining solutions children, following.
newly constructed solution rooted vq , top-down traversal solution
starting vq done check whether two edges node present
particular solution (a violation default semantics). violation
default semantics detected, solution pruned list alternative solutions
rooted vq . Therefore, every node, new solution constructed,
additional top-down traversal used detect semantics violation.
4.2 Top-Down Method DAGs
proposed top-down approaches (ASG LASG) applicable AND/OR
DAGs generate alternative solution DAGs default semantics. method
computing cost increment application swap option needs modified
incorporate fact node may included solution DAG multiple
paths root node. use notion participation count computing cost
increment.
Participation Count : notion participation count applicable intermediate
nodes solution DAG follows. solution DAG, participation count
intermediate node, vq , total number distinct paths connecting root node, vR ,
vq . example, Figure 14, optimal solution DAG shown using thick dashed
lines arrow heads, participation count every intermediate nodes
shown within circle beside node.
300

fiGenerating Ordered Solutions Explicit AND/OR Structures

v1

h2i

h1i
1

h1i

v2

3, 43

1

h5i

2,5,4 : 1

v4

v1

2, 89

2

h4i

v5

2

h1i

v7

v3

2, 41

3,5,6 : 14

1

h1i

2, 35

v2

3, 44

v6

v4

52

40

1

h5i

h1i

h4i

v5

1

1

17
h2i

h1i

2, 41

3,5,6 : 14

h1i

v6

2, 35
h3i

h4i

v8

v3

52

h3i

3, 9

7,9,10 : 3

h2i

h1i

40
h4i

2, 90

v7

v8

3, 9

7,9,10 : 3

17

h2i

v9

v10

v9

v10

5

7

5

7

Figure 15: Solution DAG S1

Figure 14: AND/OR DAG

use notation ijk denote swap option context AND/OR DAGs,
swap option ijk belongs node vi , source edge swap option eij
node vi node vj , destination edge eik node vi node vk .
4.2.1 Modification Proposed Top-Down Approach
ASG algorithm modified handling AND/OR DAGs following way.
computation successor solution Line 14 Algorithm 4 modified incorporate
participation count node applied swap option belongs.
overall method shown Algorithm 6(in next page).
order apply LASG AND/OR DAGs, apart using mentioned
modification computing cost newly generated solution, another modification
needed computing native swap options given solution. modification
explained example. Consider solution, S1 , shown Figure 15. S1 highlighted
using thick dashed lines arrow heads. pair, cv (vq ), C(S1 , vq ), shown within
rectangles beside node vq ; rectangles rounded corner used C(S1 , vq ) 6=
Copt (vq ). Swap option (2,5,4) applied Sopt generate S1 . application
swap option (2,5,4) , participation count node v5 decremented 1. Therefore
S1 path root node node v5 node v5 still present S1 .
result, swap option (7,9,10) available S1 participation count equal
1 node v7 , whereas (7,9,10) available parent solution Sopt participation
count 2 node v7 . words, (7,9,10) available S1 parent solution
Sopt value participation count node v7 . Therefore (7,9,10) becomes
native swap option S1 . generalized definition native swap options solution
presented below.
Definition 4.o [Native Swap Options Solution] Consider solution Sm
AND/OR DAG G , Sm constructed applying swap option hij solution
Sp . Since swap option hij = hehi , ehj , hij used construct Sm , node vj belongs
301

fiGhosh, Sharma, Chakrabarti, & Dasgupta

Sm . Similarly, participation count node vi remains greater zero applying hij Sm , node vi belongs Sm . native swap options solution Sm
respect swap option hij , N (Sm , hij ), subset L(Sm ), comprises following
swap options :
a. hjk , hjk swap option edge ehj
b. , belongs node vq vq node Sm (vj )
c. , node vi present Sm belongs node vq vq
node Sm (vi ).
use term N (Sm ) denote native swap options hij understood
context. Intuitively native swap options solution Sm swap options
become available immediately applying hij , available predecessor
solution Sm .


Algorithm 6: ASG Algorithm AND/OR DAGs
input : AND/OR DAG G
output: Alternative solutions G non-decreasing order cost
1 Compute optimal solution Sopt , perform edge marking populate
swap options;
2 Create three lists, Open, Closed, TList, initially empty;
3 Put Sopt Open;
4 lastSolCost C(Sopt );
5 Open empty
6
Smin Remove minimum cost solution Open;
7
lastSolCost < C(Smin )
8
Remove elements TList;
9
lastSolCost C(Smin );
10
end
11
Add Smin Closed TList;
12
Compute swap list, L(Smin ), Smin ;
/* Construct Succ(Smin ) using L(Smin ) add new solutions Open
*/
13
foreach ij L(Smin )
14
Construct Sm applying ij Smin ;
15
Construct signature Sm , Sig(Sm ), concatenating ij Sig(Smin );
16
Let ij belongs node vq , p participation count vq ,
cost increment ij ;
17
C(Sm ) = C(Sm ) + p ;
/* Check whether Sm already present Open TList
*/
18
(Sm Open) (Sm TList)
19
Add Sm Open;
20
end
21 end
22 Report solutions Closed;
worth noting Definition 4.o native swap option generalization
earlier definition native swap option (Definition 3.n), defined context trees.
302

fiGenerating Ordered Solutions Explicit AND/OR Structures

case trees, participation count node maximum 1. Therefore,
application swap option solution, participation count node,
original edge swap option points to, becomes 0. Therefore third
condition never applicable trees.
LASG (Algo. 5) applied AND/OR DAGs, mentioned modification
computing cost newly generated solution general definition native
swap option generate ordered solutions default semantics.
4.2.2 Working ASG LASG Algorithm AND/OR DAG
describe working ASG algorithm example DAG shown Figure 2.
entering outermost loop, TList Closed empty, Open contains
optimal solution Sopt . contents different lists obtained first cycles
outermost loop shown Table 3. solution represented signature.
solutions already present Open constructed expanding
current Smin , highlighted under-braces. example, solution {(2,5,4) , (3,5,6) }
added Open Iteration 2 (while constructing successor solutions {(2,5,4) })
constructed Iteration 5 expanding solution {(3,5,6) }.
L(Smin )
Open
(2,5,4) , (3,5,6) , (7,9,10)
{(2,5,4) }, {(3,5,6) }, {(7,9,10) }
(3,5,6) , (7,9,10)
{(3,5,6) }, {(7,9,10) }, {(2,5,4) , (3,5,6) },
{(2,5,4) , (7,9,10) }
3 {(2,5,4) , (7,9,10) }

{(3,5,6) }, {(7,9,10) }, {(2,5,4) , (3,5,6) },

It.
1
2

Smin
{}
{(2,5,4) }

4

{(7,9,10) }



{(3,5,6) }, {(2,5,4) , (3,5,6) },

5

{(3,5,6) }

(2,5,4) , (7,9,10)

{(2,5,4) , (3,5,6) }, {(3,5,6) , (7,9,10) }
|
{z
}

Closed
{}
{}, {(2,5,4) }
{}, {(2,5,4) }
{(2,5,4) , (7,9,10) }
{}, {(2,5,4) },
{(2,5,4) , (7,9,10) },
{(7,9,10) }
{}, {(2,5,4) },
{(2,5,4) , (7,9,10) },
{(7,9,10) }, {(3,5,6) }

Table 3: Example Working ASG Algorithm DAG shown Figure 2
illustrate working LASG algorithm example DAG shown Figure 2. contents different lists solution added Closed shown
Table 4. worth noting solution S1 = {2,5,4 }, swap list L(S1 ) =
{(3,5,6) , (7,9,10) } whereas native swap list N (S1 ) = {(7,9,10) }. solutions
added Open result lazy expansion, highlighted using under-brace. example,
Iteration 7 LASG adds solution S5 = {(2,5,4) , (3,5,6) } Open generation
solution S4 = {3,5,6 } part lazy expansion, whereas ASG algorithm adds S5
Open generating solution S1 = {2,5,4 }.
4.2.3 Generating Solutions Tree Based Semantics
Unlike default semantics, ASG LASG straight forward extension
generating solutions tree based semantics. Figure 13 show example
solution valid tree based semantics, invalid default semantics,
edges emanating form node v7 , namely e(7,9) e(7,10) ,
303

fiGhosh, Sharma, Chakrabarti, & Dasgupta

N (Smin )
Open
(2,5,4) , (3,5,6) , (7,9,10) {(2,5,4) }, {(3,5,6) }, {(7,9,10) }
(7,9,10)
{(3,5,6) }, {(7,9,10) },
{(3,5,4) , (7,9,10) }
2 {(2,5,4) , (7,9,10) }

{(3,5,6) }, {(7,9,10) },

It.
1

Smin
{}
{(2,5,4) }

3

{(7,9,10) }



{(3,5,6) }

4

{(3,5,6) }

(7,9,10)

{(3,5,6) , (7,9,10) },
{(2,5,4) , (3,5,6) }
|
{z
}

Closed
{}
{}, {(2,5,4) }
{}, {(2,5,4) }
{(2,5,4) , (7,9,10) }
{}, {(2,5,4) },
{(2,5,4) , (7,9,10) },
{(7,9,10) }
{}, {(2,5,4) },
{(2,5,4) , (7,9,10) },
{(7,9,10) }, {(3,5,6) }

Table 4: Example Working LASG Algorithm DAG shown Fugure 2

present solution. two edges included solution two
different paths emanating form root node, v1 . existing bottom-up approach
stores alternative solutions node terms solutions children
node, representation allows different paths stored explicitly, thus making
BU amenable generating alternative solutions tree-based semantics.
contrary, approach works top-down using compact representation (signature) storing solutions. signature based representation, currently
possible store fact particular node included solution two
different paths may select different child node. use equivalent
tree constructed form given graph, compact representation work correctly, case, node would reachable root node one
path. AND/OR DAG converted equivalent AND/OR tree representation
using procedure ConvertDAG (described Section 2) ASG LASG applied equivalent tree representation order generate alternative solutions
correctly tree-based semantics. However, worst case, procedure ConvertDAG
incurs space explosion blow worst case complexity ASG
LASG algorithms. Using compact representations generate ordered solutions
tree-based semantics given AND/OR DAG containing space explosion
worst case complexity algorithms remain comparable BU turns
interesting open problem.

5. Experimental Results Observations
obtain idea performance proposed algorithms compare
existing approach, implemented ASG, LASG BU (existing bottom-up
approach) tested following test domains.
a. set synthetically generated AND/OR trees;
b. Tower Hanoi (TOH) problem;
c. set synthetically generated AND/OR DAGs;
d. Matrix-chain multiplication problem;
e. problem determining secondary structure RNA sequences.
304

fiGenerating Ordered Solutions Explicit AND/OR Structures

may noted implementation ASG algorithm, implemented
space efficient version ASG algorithm (without separate hash-map storing
solutions Open Closed, thereby incurring extra overhead time duplication
checking). Another important point every test case reported running time
ASG LASG generating particular number solutions includes time required
constructing optimal solution graph. details different test domains
follows.
5.1 Complete Trees
generated set complete d-ary alternating AND/OR trees varying (a)
degree non-terminal nodes (denoted d), (b) height (denoted h).
(d, h)
(2, 7)
(2, 9)
(2, 11)
(2, 13)
(2, 15)
(2, 17)
(3, 5)
(3, 7)
(3, 9)
(3, 11)
(3, 13)
(4, 5)
(4, 7)
(4, 9)
(5, 5)
(5, 7)
(6, 5)
(6, 7)
(7, 5)
(7, 7)

100 solutions
ASG
LASG
BU
0.027
0.005
0.004
0.216
0.010
0.015
1.170
0.031
0.068
6.072
0.124
0.257
30.434
0.517
1.180
130.746 2.265
4.952
0.046
0.006
0.005
0.528
0.017
0.037
5.812
0.106
0.343
66.313
1.552
3.973
636.822 12.363 31.043
0.144
0.011
0.033
2.916
0.056
0.573
58.756
1.266
7.698
0.334
0.012
0.081
12.227
0.177
2.066
0.699
0.022
0.161
32.620
0.654
7.464
1.306
0.030
0.287
81.197
1.786 15.892

300 solutions
ASG
LASG
BU
0.086
0.014
0.009
1.448
0.035
0.046
10.098
0.094
0.184
57.757
0.348
0.777
278.453 1.433
3.917

6.443
13.277
0.196
0.015
0.018
4.764
0.060
0.153
55.170
0.290
1.733
620.996 3.712
14.323

34.150 128.314
1.041
0.025
0.092
25.341
0.181
1.561
544.989 3.327
27.063
2.792
0.036
0.400
102.577 0.443
11.717
5.384
0.071
1.418
288.257 1.566
37.758
12.006
0.092
1.833
785.160 4.284 102.431

500 solutions
ASG
LASG
BU
0.186
0.023
0.020
4.137
0.060
0.097
27.354
0.216
0.407
158.520 0.524
1.641
766.201 2.806
7.257

10.306 29.703
0.459
0.026
0.042
10.345
0.088
0.457
156.158 0.494
4.913

6.607
33.923

55.510 303.785
2.610
0.042
0.123
69.596
0.264
2.107

5.172
38.606
7.374
0.062
0.930
283.689 0.827
26.994
15.133
0.134
2.235
832.235 2.594
90.465
29.870
0.179
4.322

6.890 241.064

Table 5: Comparison running time (in seconds) generating 100, 300, 500 solutions
complete alternating AND/OR trees (T denotes timeout 15 minutes)
trees viewed search space gift packing problem,
(a) terminal nodes represent cost elementary items,
(b) nodes model choice among items (elementary composite nature)
represented children,
(c) nodes model repackaging items returned children.
Every packaging incurs cost modeled cost intermediate nodes.
objective find alternative gifts order non-decreasing cost.
Table 5 shows time required generating 100, 300, 500 solutions various
complete alternating AND/OR trees. implemented ASG, LASG
existing bottom-up algorithm corresponding running time shown column
heading ASG, LASG BU, respectively. used time limit 15 minutes
305

fiGhosh, Sharma, Chakrabarti, & Dasgupta

(d, h)
(2, 7)
(2, 9)
(2, 11)
(2, 13)
(2, 15)
(2, 17)
(3, 5)
(3, 7)
(3, 9)
(3, 11)
(3, 13)
(4, 5)
(4, 7)
(4, 9)
(5, 5)
(5, 7)
(6, 5)
(6, 7)
(7, 5)
(7, 7)

ASG
12.633
52.770
116.582
287.898
664.789
1785.156
17.270
82.609
335.301
1474.477
9139.312
40.285
213.816
1563.770
64.879
529.738
97.703
1264.828
137.527
2628.461

100 solutions
LASG
BU
13.168
11.047
26.152
48.484
63.254
198.234
173.730
797.234
413.855
3193.234
1257.387 12777.234
17.258
11.688
48.086
111.438
184.375
1009.188
1071.352 9088.938
7872.055 81806.688
24.469
47.453
128.629
767.453
1158.582 12287.453
40.355
88.281
343.254
2217.188
58.191
151.047
862.332
5449.797
90.703
242.219
1995.195 11882.781

ASG
28.105
144.730
341.227
832.562
1767.867

47.531
235.855
926.004
3234.523

121.336
559.734
3209.145
182.270
1254.715
270.027
2747.238
369.086
4869.551

300 solutions
LASG
BU
32.293
14.266
75.355
69.953
165.824
292.703
399.445
1183.703
804.801
4747.703
2047.859 19003.703
49.230
14.812
134.102
152.062
376.766
1387.312
1656.844 12504.562
9565.598 112559.812
67.102
112.609
284.922
1826.359
1699.191 29246.359
110.480
225.781
596.957
5675.000
148.453
372.141
1273.641 13433.391
205.914
576.594
2627.211 28295.281

ASG
41.676
230.168
566.766
1396.758
2942.629

76.270
393.113
1507.973


199.254
917.824

305.891
2008.344
443.656
4203.957
606.133


500 solutions
LASG
BU
49.832
16.609
128.934
87.922
269.766
373.172
612.184
1514.172
1197.266
6078.172
2849.617
24334.172
80.980
17.938
219.555
192.688
577.766
1765.438
2238.152
15920.188
11251.035 143312.938
116.535
129.016
451.223
2105.266
2240.012
33725.266
179.801
363.281
858.852
9132.812
245.227
593.234
1695.684
21416.984
317.492
910.969
3273.703
44707.781

Table 6: Comparison space required (in KB) generating 100, 300, 500 solutions
complete alternating AND/OR trees

entries marked denotes time-out occurred test cases.
space required generating 100, 300, 500 solutions reported Table 6.
observed terms time space required, LASG outperforms ASG
BU. ASG BU, test cases BU performs better ASG
respect time required generating specific number solutions. space
requirement ASG BU generating specific number solutions interesting
correlation degree(d) height(h) parameter tree. low numerical values
h parameter, e.g., (d, h) combinations (2, 7), (3, 5) etc., BU performs
better ASG. contrary, combinations, least one
h parameters high value, e.g., (d, h) combinations (2, 17), (7, 5), (4, 9) etc.,
ASG outperforms BU.
5.1.1 Experimentation Queue Bounded Length
Since Open grow rapidly, ASG LASG incur significant overhead
terms time well space maintain Open list number solutions
generated known priori. fact, ASG checking duplicates Open
actually primary source time complexity storing solutions Open major
contributing factor space complexity. number solutions generated
known priori, proposed top-down approach leverage fact using bounded
length queue implementing Open. bounded length queue used, time
requirement along space requirement decreases significantly.
306

fiGenerating Ordered Solutions Explicit AND/OR Structures

(d, h)
(2, 7)
(2, 9)
(2, 11)
(2, 13)
(2, 15)
(2, 17)
(3, 5)
(3, 7)
(3, 9)
(3, 11)
(3, 13)
(4, 5)
(4, 7)
(4, 9)
(5, 5)
(5, 7)
(6, 5)
(6, 7)
(7, 5)
(7, 7)

100 solutions
ASG
LASG
BU
0.011
0.008
0.004
0.030
0.011
0.015
0.051
0.031
0.068
0.125
0.103
0.257
0.473
0.421
1.180
2.129
2.199
4.952
0.012
0.009
0.005
0.031
0.018
0.037
0.133
0.102
0.343
1.246
1.143
3.973
10.713 10.313 31.043
0.019
0.008
0.033
0.071
0.055
0.573
1.099
0.998
7.698
0.025
0.013
0.081
0.201
0.161
2.066
0.036
0.018
0.161
0.543
0.460
7.464
0.042
0.029
0.287
1.940
1.705 15.892

300 solutions
ASG LASG
BU
0.003 0.002
0.009
0.008 0.006
0.046
0.020 0.011
0.184
0.043 0.059
0.777
0.168 0.164
3.917
0.766 1.005 13.277
0.003 0.002
0.018
0.012 0.006
0.153
0.048 0.043
1.733
0.477 0.636 14.323
4.160 5.555 128.314
0.006 0.004
0.092
0.026 0.023
1.561
0.443 0.552 27.063
0.009 0.031
0.400
0.083 0.078 11.717
0.014 0.011
1.418
0.240 0.325 37.758
0.020 0.013
1.833
0.807 0.843 102.431

500 solutions
ASG LASG
BU
0.005 0.004
0.020
0.014 0.008
0.097
0.023 0.017
0.407
0.065 0.058
1.641
0.254 0.346
7.257
1.146 1.492 29.703
0.005 0.004
0.042
0.019 0.010
0.457
0.071 0.061
4.913
0.693 0.905 33.923
6.013 7.890 303.785
0.010 0.006
0.123
0.038 0.033
2.107
0.641 0.808 38.606
0.015 0.008
0.930
0.116 0.153 26.994
0.021 0.010
2.235
0.326 0.431 90.465
0.025 0.022
4.322
0.870 1.125 241.064

Table 7: Comparison running time (in seconds) generating 100, 300, 500 solutions
complete alternating AND/OR trees bounded length Open queue ASG
LASG
(d, h)
(2, 7)
(2, 9)
(2, 11)
(2, 13)
(2, 15)
(2, 17)
(3, 5)
(3, 7)
(3, 9)
(3, 11)
(3, 13)
(4, 5)
(4, 7)
(4, 9)
(5, 5)
(5, 7)
(6, 5)
(6, 7)
(7, 5)
(7, 7)

ASG
10.109
23.875
54.609
135.477
361.859
1071.258
12.008
39.469
169.469
971.930
7075.109
20.664
116.609
1082.633
33.344
324.258
51.742
825.859
78.141
1919.805

100 solutions
LASG
BU
2.383
11.047
4.883
48.484
14.883
198.234
54.883
797.234
214.883
3193.234
854.883 12777.234
2.617
11.688
11.160
111.438
88.047
1009.188
780.027
9088.938
7007.852 81806.688
5.016
47.453
57.016
767.453
889.016 12287.453
10.195
88.281
217.715
2217.188
19.773
151.047
657.648
5449.797
35.742
242.219
1677.051 11882.781

ASG
27.781
64.430
141.203
317.445
738.992
1845.562
34.609
101.320
353.477
1529.031
8763.023
56.703
247.320
1607.859
84.422
565.531
121.031
1227.742
169.297
2542.047

300 solutions
LASG
BU
5.508
14.266
8.008
69.953
18.008
292.703
58.008
1183.703
218.008
4747.703
858.008
19003.703
5.742
14.812
14.285
152.062
91.172
1387.312
783.152
12504.562
7010.977 112559.812
8.141
112.609
60.141
1826.359
892.141
29246.359
13.320
225.781
220.840
5675.000
22.898
372.141
660.773
13433.391
38.867
576.594
1680.176 28295.281

ASG
45.789
104.117
225.969
497.508
1114.422
2615.656
57.617
163.102
537.328
2085.367
10457.797
93.031
377.922
2132.516
135.812
806.797
190.758
1628.797
260.406
3163.438

500 solutions
LASG
BU
8.633
16.609
11.133
87.922
21.133
373.172
61.133
1514.172
221.133
6078.172
861.133
24334.172
8.867
17.938
17.410
192.688
94.297
1765.438
786.277
15920.188
7014.102 143312.938
11.266
129.016
63.266
2105.266
895.266
33725.266
16.445
363.281
223.965
9132.812
26.023
593.234
663.898
21416.984
41.992
910.969
1683.301 44707.781

Table 8: Comparison space required (in KB) generating 100, 300, 500 solutions
complete alternating AND/OR trees bounded length Open queue ASG
LASG

307

fiGhosh, Sharma, Chakrabarti, & Dasgupta

show effect using bounded length queue implement Open Table 7 (reporting time requirement) Table 8 (reporting memory usage) generating
100, 300, 500 solutions, number solutions generated known beforehand. Table 7 Table 8 show case ASG LASG outperforms
BU terms time well space requirements. Particularly, ASG performs well
setting, outperforming LASG cases.
5.1.2 Experimentation Compare Incremental Nature
proposed top-down algorithms incremental nature whereas existing bottomup approach incremental. generating specified number ordered solutions,
methods generate next solution incrementally without needing restart itself,
whereas existing approach needs restarted. example, generating
first 10 ordered solutions, ASG LASG generate 11th solution directly data
structures maintained far algorithms perform necessary updates
data structures. Whereas, BU needs restarted input parameter 11 generating
11th solution. Table 9 compare time needed generate subsequent 11th
solution 12th solution incrementally generating first 10 solutions. order
clarity comparison among running times respective algorithms,
used higher precision (upto 6th decimal place) reporting running time
Table 9. Clearly, ASG LASG outperform BU generating 11th 12th
solution terms time requirement.
(d, h)
(2, 7)
(2, 9)
(2, 11)
(2, 13)
(2, 15)
(2, 17)
(3, 5)
(3, 7)
(3, 9)
(3, 11)
(3, 13)
(4, 5)
(4, 7)
(4, 9)
(5, 5)
(5, 7)
(6, 5)
(6, 7)
(7, 5)
(7, 7)

first 10
0.002403
0.009111
0.028519
0.097281
0.396460
1.561020
0.001692
0.012097
0.097356
0.934389
7.898530
0.005833
0.051598
0.813028
0.051530
0.172475
0.053422
0.502939
0.033831
1.198354

ASG
11th
0.000201
0.001957
0.003311
0.014776
0.063641
0.251839
0.000158
0.001542
0.013046
0.127943
1.082319
0.000650
0.006956
0.110205
0.001327
0.024262
0.002701
0.061417
0.003706
0.156145

12th
0.000201
0.001302
0.003533
0.015929
0.059229
0.277763
0.000151
0.001572
0.014405
0.156579
1.194090
0.000671
0.007196
0.124750
0.001641
0.024438
0.003092
0.069727
0.003846
0.166501

first 10
0.001003
0.003023
0.006700
0.025877
0.102493
0.446899
0.000683
0.004084
0.031159
0.311128
2.811539
0.002143
0.017046
0.294561
0.004638
0.059751
0.005282
0.184584
0.012862
0.466560

LASG
11th
0.000240
0.000714
0.001250
0.004113
0.014490
0.061422
0.000176
0.000583
0.003948
0.033169
0.282836
0.000303
0.002209
0.027612
0.000753
0.006116
0.000636
0.017116
0.001266
0.038792

12th
0.000123
0.000629
0.001346
0.004918
0.020031
0.082366
0.000112
0.000959
0.004604
0.047594
0.387715
0.000582
0.003115
0.037281
0.000652
0.007197
0.001087
0.024042
0.001282
0.061305

first 10
0.001344
0.003596
0.014628
0.059326
0.238418
0.962635
0.001055
0.009507
0.085610
0.778298
7.037050
0.004181
0.044913
0.727766
0.005963
0.152285
0.010895
0.406947
0.018185
0.929941

BU
11th
0.001359
0.003696
0.015046
0.061393
0.246042
0.989777
0.001101
0.009931
0.089379
0.811176
7.313715
0.004434
0.047867
0.775950
0.006358
0.162527
0.011604
0.435398
0.019567
0.989326

12th
0.001397
0.003895
0.015521
0.062717
0.251746
1.015848
0.001133
0.010336
0.093419
0.846578
7.608619
0.004725
0.050940
0.823442
0.006782
0.173191
0.012556
0.465301
0.020896
1.052566

Table 9: Comparison running time (in seconds) generating first 10 solutions
11th solution 12th solution incrementally complete alternating
AND/OR trees

308

fiGenerating Ordered Solutions Explicit AND/OR Structures

5.2 Multipeg Tower Hanoi Problem
Consider problem Multipeg Tower Hanoi (Majumdar, 1996; Gupta, Chakrabarti,
& Ghose, 1992). problem, pegs fastened stand. Initially disks rest
source peg small disk large disk ordering. objective transfer
disks destination peg B minimum legal moves. legal move,
topmost disk tower transferred peg larger disk
topmost disk. problem multi-peg tower Hanoi solved recursively follows.
a. Move recursively topmost k (k varies 1 1) disks
intermediate peg, I, using pegs.
b. Transfer remaining k disks B recursively, using ( 1) pegs
available.
c. Recursively move k disks transferred previously, intermediate
peg B, using pegs.
may noted choice value k, may take value 1
1. Solutions different values k may take different number moves,
solution incurs minimum number moves optimal solution. choice
value k modeled node, every choice, problem divided
three sub-problems. decomposition sub-problems modeled
node. Therefore, search spaces multi-peg Tower Hanoi problem correspond
alternating AND/OR trees.
#disks
8
9
10
11
12
13

100 solutions
ASG
LASG
BU
0.034
0.030
0.069
0.119
0.116
0.264
0.479
0.635
1.310
2.421
2.178
3.171
7.453
7.448 11.437
25.379 25.115 38.458

300 solutions
ASG
LASG
BU
0.104
0.084
0.252
0.314
0.289
0.942
1.706
1.658
3.305
6.573
6.161
12.998
21.232 21.081 43.358
68.574 67.170 140.392

500 solutions
ASG
LASG
BU
0.200
0.138
0.577
0.590
0.458
2.183
2.303
2.829
7.592
10.651
9.678
29.242
35.825
35.663
99.593
112.411 112.470 332.113

#Opt. No.
Moves
23
27
31
39
47
55

Table 10: Comparison running time (in seconds) alternating AND/OR trees corresponding search spaces 5-peg Tower Hanoi problem different
number disks
#disks
8
9
10
11
12
13

100 solutions
ASG
LASG
BU
ASG
36.664
43.008
416.312
64.516
96.211
111.320
1471.656
131.266
295.672
341.000
5074.219
326.352
957.336
1113.508 17197.312
999.602
3155.086 3664.117 57512.812
3198.156
10339.078 12022.883 190297.969 10412.242

300 solutions
LASG
BU
ASG
80.734
660.062
105.039
154.266
2359.156
166.789
383.453
8161.719
373.453
1158.797 27728.562
1039.367
3719.352 92906.562
3247.547
12078.914 307872.969 10483.570

500 solutions
LASG
BU
117.008
903.812
197.859
3246.656
427.766
11249.219
1204.719 38259.812
3767.617 128300.312
12137.242 425447.969

Table 11: Comparison space required (in KB) alternating AND/OR trees corresponding search spaces 5-peg Tower Hanoi problem different number
disks
used search space 5 peg Tower Hanoi problem different number
disks, , generated alternative solutions non-decreasing order cost using ASG
309

fiGhosh, Sharma, Chakrabarti, & Dasgupta

LASG algorithms. cost function expresses number legal moves. value
varied 8 13, Table 10 Table 11, report time required
space required, respectively, generating 100, 300, 500 solutions every test cases.
Experimental results show performance ASG similar performance
LASG respect space time. However ASG well LASG outperforms
BU respect time space requirements.
5.3 Randomly Constructed AND/OR DAGs
constructed set randomly generated AND/OR DAGs evaluated ASG,
LASG, BU algorithm generating solutions default semantics. used
proposed extension BU algorithm generating solutions default semantics.
n



60
220
920
33
404
2124
9624
144
744
8844
40884

2
2
2
3
3
3
3
4
4
4
4

100 solutions
ASG LASG
BU
0.027 0.006 0.039
0.060 0.009 0.096
0.363 0.020 0.106
0.020 0.006 0.019
0.203 0.018 0.067
3.550 0.045 0.730
26.659 0.201 14.620
0.065 0.008 0.034
0.877 0.025 0.400
7.422 0.160 26.683

1.972


300 solutions
ASG
LASG
BU
0.089
0.021 0.158
0.281
0.030 1.100
2.485
0.059 0.266
0.123
0.021 0.098
1.483
0.048 0.257
30.302 0.126 1.681
257.605 0.612 33.382
0.348
0.027 0.217
6.910
0.069 0.994
69.097 0.449 66.558

5.819


500 solutions
ASG
LASG
BU
0.172
0.033
0.282
0.594
0.051
3.665
6.163
0.100
0.528
0.280
0.032
0.245
4.043
0.083
0.541
85.863 0.215
2.766
710.708 1.194 52.406
0.817
0.049
2.251
18.823 0.118
1.365
194.452 0.927 109.076

9.426


Table 12: Comparison running time (in seconds) generating 100, 300, 500 solutions AND/OR DAGs (T denotes timeout 15 minutes)
n



60
220
920
33
404
2124
9624
144
744
8844
40884

2
2
2
3
3
3
3
4
4
4
4

ASG
11.609
23.141
74.082
13.914
48.867
229.820
772.441
30.648
121.535
471.625
2722.938

100 solutions
LASG
BU
8.875
8.125
16.219
31.312
39.000
106.875
10.492
8.172
35.445
66.938
118.707
389.844
339.676 1996.875
17.332
29.609
65.578
287.109
266.078 2729.297
1256.535


ASG
32.852
62.516
220.648
46.117
151.363
705.809
2245.938
85.781
381.133
1183.379


300 solutions
LASG
BU
30.797
10.906
46.711
49.562
105.852
172.562
32.539
11.297
101.168
98.188
312.246
621.094
825.984 3321.875
53.961
73.359
168.305
737.891
550.477 6945.703
2353.562


ASG
54.094
100.555
371.344
77.445
262.816
1200.336
3732.523
140.312
659.434
1927.961


500 solutions
LASG
BU
50.035
13.250
74.379
65.188
168.375
230.375
54.602
14.422
163.273
129.438
507.762
852.344
1327.406 4646.875
93.539
86.641
275.594
883.984
843.484 8419.922
3447.809


Table 13: Comparison space required (in KB) generating 100, 300, 500 solutions
AND/OR DAGs

Table 12 Table 13 compare time required space required running ASG,
LASG BU generating 100, 300, 500 solutions every test cases. first
second columns every row provide size (n ) average out-degree (d)
DAG. results obtained test domain similar results randomly
310

fiGenerating Ordered Solutions Explicit AND/OR Structures

constructed AND/OR trees. may noted terms time space required,
LASG outperforms ASG BU. ASG BU, test cases
BU performs better ASG respect time required generating specific
number solutions. Whereas, space requirement ASG BU generating
specific number solutions interesting co-relation average degree(d)
size (n ) parameter DAG. low numerical values n
parameter, e.g., (n , d) combinations (60, 2), (33, 3) etc., BU performs better
ASG. contrary, combinations, least one n
parameter high value, e.g., (n , d) combinations (920, 2), (9624, 3), (40884, 4)
etc., ASG outperforms BU.
5.4 Matrix-Chain Multiplication Problem
used well-known matrix-chain multiplication (Cormen, Stein, Rivest, &
Leiserson, 2001) problem experimentation. search space popular dynamic
programming formulation problem correspond AND/OR DAG.
DAG
Cnstr.
#matrices
Time
(Sec)
20
0.033
30
0.200
40
0.898
50
3.033
60
8.335
70
19.591
80
41.960
90
82.578
100
151.814

Sopt
Cnstr.
Time
(Sec)
0.001
0.003
0.008
0.016
0.029
0.046
0.071
0.101
0.143

10 solutions

15 solutions

20 solutions

ASG

LASG

BU

ASG

LASG

BU

ASG

LASG

BU

0.003
0.009
0.019
0.047
0.088
0.140
0.209
0.296
0.409

0.002
0.008
0.018
0.048
0.090
0.142
0.212
0.300
0.412

0.206
2.785
15.580
93.267
342.212
862.387




0.004
0.012
0.024
0.062
0.118
0.187
0.280
0.396
0.546

0.003
0.010
0.024
0.065
0.120
0.190
0.282
0.398
0.548

0.288
4.087
23.414
140.513
509.906





0.005
0.015
0.030
0.079
0.148
0.235
0.351
0.496
0.688

0.004
0.012
0.030
0.081
0.151
0.238
0.354
0.499
0.683

0.373
5.406
31.112
187.227
678.718





Table 14: Comparison time required (in seconds) AND/OR DAGs corresponding
search spaces matrix-chain multiplication different number matrices, (T denotes timeout 15 minutes)
#matrices
20
30
40
50
60
70
80
90
100

ASG
19.641
66.367
156.559
308.984
537.383
859.844
1290.117
1843.828
2537.582

10 solutions
LASG
20.203
69.273
160.227
315.012
545.117
869.160
1301.406
1857.480
2556.883

BU
160.918
555.684
1317.637
2563.965
4411.855
6978.496




ASG
20.543
67.809
157.738
310.277
538.930
862.133
1293.148
1847.602
2542.746

15 solutions
LASG
21.227
70.695
161.785
316.543
546.512
870.867
1303.426
1859.812
2560.043

BU
234.305
821.902
1960.281
3825.223
6592.508





ASG
21.914
69.516
158.758
311.551
539.914
863.977
1295.852
1851.164
2549.352

20 solutions
LASG
22.773
72.523
162.852
318.145
547.551
872.219
1305.090
1861.789
2566.992

BU
303.973
1081.902
2594.207
5075.262
8759.441





Table 15: Comparison space required (in KB) AND/OR DAGs corresponding
search spaces matrix-chain multiplication different number matrices

Given sequence matrices, A1 , A2 , , , n matrices matrix Ai dimension pi1 pi , problem objective find efficient way multiply
311

fiGhosh, Sharma, Chakrabarti, & Dasgupta

matrices. classical dynamic programming approach works follows. Suppose
A[i,j] denotes matrix results evaluating product, Ai Ai+1 Aj , m[i, j]
minimum number scalar multiplications required computing matrix A[i,j] .
Therefore, cost optimal solution denoted m[i, j] recursively defined
:

m[i, j] =


0,

min

ik<j



= j;

m[i, k] + m[k + 1, j] + pi1 pk pj , < j.

choice value k modeled node every choice, problem
divided three sub-problems. decomposition sub-problems modeled
node. worth noting unlike search space 5-peg ToH problem,
search space matrix-chain multiplication problem corresponds AND/OR DAG.
used search space different matrix sequences varying length
generated alternative solutions order non-decreasing cost. Table 14, report
time required Table 15, report memory used generating 10, 15,
20 solutions every test cases.
Table 14, test case, report time required constructing
explicit AND/OR DAG recursive formulation 2nd column, optimal
solution construction time 3rd column. interesting observe relative
performance ASG LASG search space similar obtained 5peg ToH search space though search space domain AND/OR DAG. ASG
LASG perform approximately respect time space requirement.
However, advantage ASG well LASG BU respect time
space requirement significant domain.
5.5 Generating Secondary Structure RNA
Another relevant problem alternative solutions play important role
computation secondary structure RNA. RNA molecules viewed strings
bases, base belongs set {Adenine, Cytocine, Guanine, U racil} (also
denoted {A, C, G, U }). RNA molecules tend loop back form base pairs
resulting shape called secondary structure (Mathews & Zuker, 2004). stability
secondary structure largely depends number base pairings (in general, larger
number base pairings implies stable secondary structure). Although
factors influence secondary structure, often possible express
factors using cost function typically evaluated empirically. Therefore,
useful generate set possible alternative secondary structures ordered decreasing
numbering base pairings given RNA subjected experimental
evaluation.
computation optimal secondary structure considering underlying principle maximizing number base-pairings nice dynamic programming formulation (Kleinberg & Tardos, 2005). Given RNA molecule B = hb1 b2 bn
bi {A, C, G, U }, secondary structure B set base pairings, = {(i, j)},
i, j {1, 2, n}, satisfies following conditions:
312

fiGenerating Ordered Solutions Explicit AND/OR Structures

Test Case
TC1
TC2
TC3
TC4
TC5
TC6
TC7
TC8
TC9
TC10
TC11
TC12
TC13
TC14

Organism Name
Anaerorhabdus Furcosa
Archaeoglobus Fulgidus
Chlorobium Limicola
Desulfurococcus Mobilis
Haloarcula Japonica
Halobacterium Sp.
Mycoplasma Genitalium
Mycoplasma Hyopneumoniae
Mycoplasma Penetrans
Pyrobaculum Aerophilum
Pyrococcus Abyssi
Spiroplasma Melliferum
Sulfolobus Acidocaldarius
Symbiobacterium Thermophilum

# Bases
114
124
111
129
122
120
104
105
103
131
118
107
126
110

Table 16: Details RNA sequences used Experimentation
a. (i, j) D, + 4 < j : condition states ends pair
separated least four intermediate bases.
b. elements pair consists either {A, U } {C, G} (in either order).
c. base appears one pairings, i.e., matching.
d. (i, j) (k, l) two pairs D, possible < k < l < j, i.e.,
two pairings cross other.
Test
Case
TC1
TC2
TC3
TC4
TC5
TC6
TC7
TC8
TC9
TC10
TC11
TC12
TC13
TC14

DAG Cnstr.
Time (Sec)
34.464
57.999
26.423
83.943
51.290
46.508
16.766
22.775
18.831
91.419
47.660
22.649
67.913
28.911

Sopt Cnstr.
Time (Sec)
0.042
0.057
0.038
0.065
0.051
0.047
0.029
0.033
0.031
0.073
0.047
0.034
0.061
0.038

ASG
0.094
0.126
0.084
0.144
0.114
0.107
0.068
0.077
0.068
0.167
0.111
0.078
0.140
0.087

5 solutions
LASG
BU
0.095 449.916
0.128 823.493
0.089 363.421
0.152 1089.462
0.116 681.429
0.108 598.419
0.069 210.806
0.078 284.455
0.072 233.999
0.170

0.109 627.744
0.079 288.520
0.141 962.641
0.085 366.693

ASG
0.145
0.193
0.135
0.230
0.176
0.166
0.101
0.120
0.109
0.249
0.173
0.116
0.206
0.134

10 solutions
LASG
BU
0.148 893.682
0.198

0.133 718.326
0.227

0.180 1349.181
0.175

0.103 410.817
0.122 559.318
0.111 458.290
0.263

0.171 1253.034
0.123 573.602
0.218

0.137 724.113

ASG
0.197
0.271
0.183
0.314
0.239
0.226
0.136
0.153
0.144
0.347
0.220
0.165
0.290
0.182

15 solutions
LASG
BU
0.202 1359.759
0.277

0.186 1077.094
0.317

0.245

0.238

0.144 621.792
0.165 836.359
0.148 683.411
0.355

0.240

0.167 849.134
0.288

0.186 1072.552

Table 17: Comparison time required (in seconds) AND/OR DAGs corresponding
search spaces RNA secondary structure different number bases (T
denotes timeout 30 minutes)

mentioned conditions dynamic programming formulation follows.
Suppose P (i, j) denotes maximum number base pairings secondary structure
bi bj . P (i, j) recursively defined :
P [i, j] =


0,

n


max P [i, j 1], max 1 + P [i, k 1] + P [k + 1, j 1] ,
ik<j

313

+ 4 j,

+ 4 < j.

fiGhosh, Sharma, Chakrabarti, & Dasgupta

Here, choice value k modeled node every choice,
problem divided three sub-problems. decomposition sub-problems
modeled node. experimented search space problem
set RNA molecule sequences obtained test-cases developed Szymanski,
Barciszewska, Barciszewski, Erdmann (2005). details test cases shown
Table 16.
every test cases, report time required Table 17 generating 5, 10, 15
solutions. setting, space required reported Table 18. Table 17,
test case, report time required constructing explicit AND/OR DAG
recursive formulation 2nd column, time required constructing
optimal solution time 3rd column. use high value time-out (1800 seconds)
order gather running time required BU. limit maximum solutions generated
15 generating higher number solutions, BU timed
test cases. worth noting result obtained domain similar
result obtained matrix-chain multiplication problem domain. space time
wise ASG LASG perform similarly outperform BU significantly respect
time well space requirement.
Test
Case
TC1
TC2
TC3
TC4
TC5
TC6
TC7
TC8
TC9
TC10
TC11
TC12
TC13
TC14

ASG
1647.555
2254.531
1473.852
2606.242
2045.930
1912.227
1101.125
1293.812
1170.094
2984.773
1974.695
1295.141
2438.898
1475.477

5 solutions
LASG
1694.688
2310.008
1516.922
2665.820
2097.414
1963.367
1138.633
1333.336
1207.633
3047.539
2022.906
1335.883
2496.469
1517.828

BU
7409.336
9902.953
6629.891
11358.945
9021.273
8499.570
5087.680
5855.547
5352.477

8641.422
5924.664
10657.945
6627.844

ASG
1651.273
2258.773
1477.492
2610.875
2049.844
1916.422
1104.422
1297.750
1173.023
2990.211
1979.344
1297.273
2442.961
1478.555

10 solutions
LASG
1697.797
2315.258
1521.750
2671.711
2101.836
1968.305
1142.023
1338.070
1211.523
3053.977
2030.922
1339.516
2502.625
1521.352

BU
14656.469

13103.492

17875.430

10036.938
11560.203
10562.766

17119.820
11701.695

13099.055

ASG
1654.367
2262.492
1480.555
2615.719
2052.867
1921.117
1108.047
1302.242
1176.352
2994.773
1983.664
1299.805
2447.172
1482.234

15 solutions
LASG
1700.492
2318.008
1526.797
2675.633
2106.000
1972.172
1144.109
1342.484
1213.906
3059.781
2038.461
1341.914
2506.703
1525.344

BU
21846.156

19518.625



14924.820
17211.406
15718.617


17420.719

19519.742

Table 18: Comparison space required (in KB) AND/OR DAGs corresponding
search spaces RNA secondary structure different number bases

5.6 Observations
experimental data shows LASG algorithm generally outperforms ASG
algorithm existing bottom-up approach terms running time complete
alternating AND/OR trees AND/OR DAGs. Whereas, problem domains,
i.e., 5-peg Tower Hanoi problem, matrix-chain multiplication problem,
problem determining secondary structure RNA sequences, overall performance
ASG algorithm similar performance LASG algorithm. behavior
explained average maximum length statistics Open list, reported
Table 19 - Table 23, mentioned test domains.
314

fiGenerating Ordered Solutions Explicit AND/OR Structures

case complete trees random DAGs, ASG algorithm, average well
maximum size Open grows much faster LASG algorithm (Table 19
Table 20), increase size tree/DAG.
(d, h)
(2, 7)
(2, 9)
(2, 11)
(2, 13)
(2, 15)
(2, 17)
(3, 5)
(3, 7)
(3, 9)
(3, 11)
(3, 13)
(4, 5)
(4, 7)
(4, 9)
(5, 5)
(5, 7)
(6, 5)
(6, 7)
(7, 5)
(7, 7)

100 solutions
ASG
LASG
avg.
max.
avg. max.
235
383
75
159
994
1894
73
120
2427
4709
156
306
5546
10947
524
1149
11744
23291
384
523
24264
48333
655
841
304
549
120
242
1561
3015
172
346
5496
10899
191
289
17336
34542
486
691
53139 106155
1138 1216
734
1427
103
176
3748
7383
194
381
16282
32451
422
488
1216
2352
146
307
7261
14446
249
335
1781
3489
141
276
12362
24651
297
342
2433
4765
261
508
19311
38435
450
529

300 solutions
ASG
LASG
avg.
max.
avg. max.
435
629
179
289
2657
4931
220
528
6935
13537
483
1005
16266
32076
1550 2726
34836
69160
677
1121


1087 1611
740
1323
341
652
4359
8400
579
1260
16272
32244
387
661
51954 103549
956
1754


1267 1569
2062
4006
256
503
10928
21489
678
1467
48786
97196
687
1131
3407
6555
496
1053
21652
42972
470
888
5089
9911
507
1126
36868
73323
461
789
7072
13910
747
1483
57754 115116
687
961

500 solutions
ASG
LASG
avg.
max.
avg. max.
545
792
236
372
4103
7569
449
1069
11251
21843
851
1771
26748
52724
2261 3844
57673 114367
983
1824


1527 2819
1107
1972
539
1007
7026
13588
1012 2084
26904
53271
622
1368


1460 2672


1432 1776
3322
6375
452
1065
17932
35222
1265 2837


1025 1807
5508
10694
852
1742
35850
71054
832
1781
8250
16035
971
2164
61221 121958
749
1573
11595
22809
1204 2273


984
1922

Table 19: Average maximum length Open generating 100, 300, 500 solutions complete alternating AND/OR trees
n



60
220
920
33
404
2124
9624
144
744
8844
40884

2
2
2
3
3
3
3
4
4
4
4

100 solutions
ASG
LASG
avg.
max.
avg. max.
181
338
39
63
479
854
77
133
1530
2957
116
227
202
409
58
102
1001
1969
236
447
5008
9911
374
626
14422 28666
394
491
510
990
56
101
2407
4760
253
485
7522
14931
258
437


749
804

300 solutions
ASG
LASG
avg.
max.
avg. max.
428
768
131
282
1144
2058
210
417
4289
8278
332
639
604
1193
154
281
2958
5799
675 1256
14803 29314
851 1569
43087 85825
746 1339
1374
2563
187
458
7166
14204
590 1018
22254 44062
847 1831


852 1004

500 solutions
ASG
LASG
avg.
max.
avg. max.
643
1138
219
411
1721
3139
329
612
6902
13305
512
946
978
1875
234
422
4874
9781
1013 1810
24442
48357
1337 2527
71547 142327
1254 2756
2140
3996
376
868
11874
23558
885
1655
36743
72740
1565 3493


961
1215

Table 20: Average maximum length Open generating 100, 300, 500 solutions randomly constructed AND/OR DAGs

Since ASG algorithm checks presence duplicates expanding solution,
time required duplication checking grows rapidly test domains. Hence,
overall time required generating specific number solutions increases rapidly
(faster BU LASG) increase size tree/DAG. result,
BU outperforms ASG respect time requirement trees DAGs. However
315

fiGhosh, Sharma, Chakrabarti, & Dasgupta

memory used generating specific number solutions increases moderately (slower
BU) increase size tree/DAG. Therefore respect space
requirement, ASG outperforms BU larger trees DAGs.
LASG BU, time well memory requirement BU increases
faster LASG degree AND/OR tree DAG increases.
happens because, BU, time taken merging sub-solutions nodes
memory required storing alternative solutions rooted different nodes
increases rapidly increase degree node.
contrary, test domains, 5-peg Tower Hanoi problem, matrix-chain
multiplication problem, probelm finding secondary structure RNA sequences,
average maximum size Open ASG LASG comparable (Table 21, Table 22 Table 23). Therefore, LASG algorithm, time saved
avoiding duplication checking compensated extra overhead maintaining
solution space tree checks required lazy expansion. Hence running time
well space requirement almost algorithms three
mentioned problem domains.
Moreover, due low values average maximum size Open, ASG
outperforms BU respect time requirement memory used three
test domains. three domains also, LASG BU, time well
memory requirement BU increases faster LASG size search
space (AND/OR tree DAG) increases.

6. Ramifications Implicitly Specified AND/OR Structures
section, briefly discuss use proposed algorithms generation alternative
solutions non-decreasing order cost implicit AND/OR search spaces. One
possible way extend standard AO generating given number solutions,
say k, follows. Instead keeping one potential solution graph(psg), stage k
psgs computed explicitly constructed search space instead expanding
one node, k nodes, (that is, one node psg), expanded once.
expanding nodes, k psgs recomputed again. Since cost nodes
often recomputed expanding nodes, swap options associated node
updated every recomputation.
Another possible approach could run AO generates optimal solution.
point time swap options computed explicit portion
graph swap option minimum cost applied optimal solution.
resulting psg expanded resulting expansion explicit graph.
swap options re-evaluated incorporate cost update. next best psg
computed. process continues till second best solution derived. among
remaining successor psgs first solution successor psgs second solution,
promising psg selected expanded. process continues till third solution
found. successor psgs added already existing pool candidate
psgs. two broad steps, (a) selecting next best psg pool candidate
psgs, (b) keeping expanding explicit graph till next best solution
found, continued till k solutions found.
316

fiGenerating Ordered Solutions Explicit AND/OR Structures

# disks
8
9
10
11
12
13

100 solutions
ASG
LASG
avg. max. avg. max.
55
92
41
68
66
122
42
71
109
183
53
79
132
218
76
140
219
385
85
147
259
482
118
200

300 solutions
ASG
LASG
avg. max. avg. max.
111
186
91
174
163
331
119
252
216
367
142
283
296
611
177
373
473
776
234
492
675 1240
252
437

500 solutions
ASG
LASG
avg. max. avg. max.
174
375
135
235
265
484
198
382
345
693
234
447
486
882
291
558
668
1200
404
724
1016 1828
377
697

Table 21: Average maximum length Open generating 100, 300, 500 solutions 5-peg Tower Hanoi problem different number disks
# matrices
20
30
40
50
60
70
80
90
100

10 solutions
ASG
LASG
avg. max. avg. max.
46
87
25
39
84
162
71
126
73
123
58
90
86
151
75
126
91
144
76
112
136
234
85
122
181
324
94
132
226
414
103
142
307
576
167
259

15 solutions
ASG
LASG
avg. max. avg. max.
68
121
34
59
123
230
94
157
98
182
73
129
120
211
100
169
118
189
94
137
188
329
103
147
258
469
112
157
328
609
122
167
445
823
216
337

20 solutions
ASG
LASG
avg. max. avg. max.
90
176
46
95
160
293
116
192
125
226
90
152
151
266
123
205
151
267
108
160
243
437
117
170
335
607
127
180
427
777
136
190
583 1145
262
477

Table 22: Average maximum length Open generating 10, 15, 20 solutions
matrix-chain multiplication problems
Test case
TC1
TC2
TC3
TC4
TC5
TC6
TC7
TC8
TC9
TC10
TC11
TC12
TC13
TC14

5 solutions
ASG
LASG
avg. max. avg. max.
45
84
41
74
50
95
50
95
47
90
46
89
50
93
49
90
47
86
45
74
49
93
47
84
42
81
42
80
46
89
44
84
40
77
39
73
59
116
59
113
55
106
54
105
33
64
31
51
51
98
51
97
41
78
40
73

10 solutions
ASG
LASG
avg. max. avg. max.
93
176
75
125
100
192
94
170
90
168
82
142
101
194
87
155
98
186
87
149
105
200
95
168
83
157
73
119
97
188
86
159
80
147
70
119
128
251
116
212
115
225
110
211
67
116
55
98
103
193
100
185
82
154
69
112

15 solutions
ASG
LASG
avg. max. avg. max.
135
249
95
143
146
266
125
197
132
244
115
210
152
292
119
197
140
246
114
184
155
294
127
206
121
231
92
138
144
277
120
214
115
214
93
146
189
350
161
280
171
317
166
321
95
172
78
135
149
276
140
239
120
231
97
176

Table 23: Average maximum length Open generating 5, 10, 15 solutions
generating secondary structure RNA sequences

317

fiGhosh, Sharma, Chakrabarti, & Dasgupta

important observe methods heavily depend incorporating updates explicit DAG adding nodes, increase cost, etc., recomputing
associated swap options along signatures use swap options. Handling
dynamic updates DAG efficiently use implicit AND/OR search spaces
remains interesting future direction.

7. Conclusion
work presented top-down algorithm generating solutions given
weighted AND/OR structure (DAG) non-decreasing order cost. Ordered solutions
AND/OR DAGs useful number areas including model based programming,
developing new variants AO*, service composition based user preferences, real life
problems dynamic programming formulation, etc. proposed algorithm two
advantages (a) works incrementally, i.e., generating specific number solutions,
next solution generated quickly, (b) number solutions generated
known priori, algorithm leverage generate solutions faster. Experimental
results show efficacy algorithm state-of-the-art. opens
several interesting research problems development applications.

8. Acknowledgments
thank anonymous reviewers editor, Prof. Hector Geffner, valuable
comments enriched presentation paper significantly. thank
Prof. Abhijit Mitra, International Institute Information Technology, Hyderabad, India,
valuable inputs regarding test domain involving secondary structure RNA.
thank Aritra Hazra Srobona Mitra, Research Scholar, Department Comp. Sc. &
Engg., Indian Institute Technology Kharagpur, India, proof reading paper.

Appendix A. Proof Correctness Algorithm 4
Lemma A.1 Every solution optimal solution Sopt constructed
Sopt applying sequence swap options according order R.
Proof: [Lemma A.1] Every solution Sopt alternating AND/ tree
constructed choosing non optimal edges nodes. Consider
solution Sm , corresponding set non-optimal edges suppose
|S | = m. apply relation R obtain ordered sequence edges
e1 , e2 , e1 appears e2 (e1 , e2 ) R. show exists
sequence swap options constructed . every edge eij
(here eij ith edge 1 m), append subsequence edges
ei1 , . . . , eij 1 eij , ei1 , . . . , eij edges emanate
parent vq , ei1 , . . . , eij 1 first ij 1 edges L(vq ).
get sequence edges aug mentioned augmentation.
aug basically concatenation subsequences 1 , . . . , , sequence edges
ei1 , . . . , eij ei1 , . . . , eij edges emanate parent vq ,
ei1 , . . . , eij first ij edges L(vq ). construct aug follows.
318

fiGenerating Ordered Solutions Explicit AND/OR Structures

every , construct = hi1 ,i2 , . . . , ij 1,ij i, ik ,ik +1 = heik , eik +1 , ik ,ik +1
i1 ik (ij 1). constructed concatenating every individual . Hence exists
sequence swap options corresponding every solution Sm .


Definition A.p [Default Path] Lemma A.1, every non-optimal solution Sm
constructed initial optimal solution applying sequence swap options,
(Sm ), according order R. sequence solutions formed following (Sm )
corresponds path Sopt Sm SSDAG G . path defined default
path, Pd (Sm ), Sm .
Lemma A.2 SSDAG alternating AND/OR tree contains every alternative
solution .
Proof: [Lemma A.2] prove induction length default path Pd
solutions.
[Basis (n = 1) :] Consider swap list Sopt . solutions whose default path length
equal 1 form Succ(Sopt ). Therefore solutions present G.
[Inductive Step :] Suppose solutions whose default path length less equal
n present G. prove solutions default path length equal
n + 1 present G. Consider solution Sm Pd (Sm ) = n + 1. Let (Sm ) =
(S ) = h , , i. Since P (S ) =
h1 , , n , n+1 i. Consider solution Sm
1
n





V, swap option
n, Sm
n+1 L(Sm ), directed edge Sm Sm G .
Hence every solution default path length equal n + 1 present G.


Lemma A.3 alternating AND/OR tree , Algorithm 4 adds solutions Closed
(at Line 11) non-decreasing order cost.
Proof: [Lemma A.3] Consider following invariants Algorithm 4 follow
description Algorithm 4.
a. minimum cost solution Open always removed Line 6 Algorithm 4.
b. cost solutions added Open, exploring successor set
solution Sm (at Line 13 Algorithm 4), greater equal C(Sm ).
two invariants follows Algorithm 4 adds solutions Closed (at Line 11)
non-decreasing order cost.
Lemma A.4 alternating AND/OR tree , every node SSDAG ,
Agorithm 4 generates solution corresponding node.
Proof: [Lemma A.4] Lemma A.3 follows Algorithm 4 generates solutions
non-decreasing order cost. generating solution Sm , mean adding Sm
Closed (at line 11 Algorithm 4). purpose proof contradiction, let us assume
Algorithm 4 generate solution Sm . let Sm first occurrence
319

fiGhosh, Sharma, Chakrabarti, & Dasgupta

scenario generating solutions mentioned order. According Lemma A.1,
exists sequence swap options = 1 , . . . , k corresponding Sm . consider
whose sequence swap options = , . . . ,
solution Sm
1
k1 . According Property 3.2,

C(Sm ) C(Sm ). Consider following two cases:
) < C(S ): Since
a. C(Sm

first instance incorrect scenario, Algo generated
rithm 4 generates solutions non-decreasing order cost, Sm
prior Sm .
) = C(S ): Since Algorithm 4 resolves tie favor parent solution,
b. C(Sm


Sm first instance incorrect scenario case Sm
generated prior Sm .
. generated Algorithm 4,
swap option k belongs swap list Sm



is, Sm added Closed, Sm expanded solutions
applying one swap option, added Open list. Since
constructed Sm

applying one swap option ,
constructed Sm


added


Open

k
. Therefore
exploring successors Sm
eventually generated
Algorithm 4 - contradiction.



Lemma A.5 alternating AND/OR tree , Algorithm 4 add solution
Closed (at Line 11 Algorithm 4) once.
Proof: [Lemma A.5] purpose contradiction, let us assume Sm first
solution added Closed twice. Therefore Sm must added Open twice.
Consider following facts.
a. Sm added Closed first time, value lastSolCost C(Sm ),
Sm added TList.
b. description Algorithm 4 follows contents TList deleted
value lastSolCost increases.
c. Lemma A.3 follows Algorithm 4 generates solutions non-decreasing
order cost. Hence, Sm generated second time, value
lastSolCost change C(Sm ).
facts follow Sm present TList Sm added Open
second time. Since, adding solution Open, Algorithm 4 checks whether
present TList (at Line 16 Algorithm 4); Algorithm 4 must done
adding Sm Open second time. Therefore Sm could added Open
second time contradiction.


Theorem A.1 Sj V, Sj generated (at Line 11) Algorithm 4
non-decreasing order costs ties among solutions costs resolved
mentioned before.
Proof: [Theorem A.1] Follows Lemma A.2, Lemma A.3, Lemma A.4 Lemma A.5.


320

fiGenerating Ordered Solutions Explicit AND/OR Structures

Appendix B. Proof Correctness Algorithm 5
Definition B.q [Reconvergent Paths Solution Space DAG] Two paths, (i) p1 =
Si11 Si1n (ii) p2 = Si21 Si2m , SSDAG G alternating
AND/OR tree reconvergent following holds:
a. Si11 = Si21 , i.e. paths start node;
b. Si1n = Si1m , i.e. paths ends node;

c. (j [2, n 1])(k [2, 1]), Si1j 6= Si2k ; i.e. paths common
intermediate node.
Definition B.r [Order Generation Time] context Algorithm 5, define
order relation, V V, (Sp , Sq ) Sp generated Algorithm 5 Sq .
V set vertices SSDAG G alternating AND/OR tree .
Lemma B.1 Algorithm 5 adds solutions Closed list non-decreasing order
costs.
Proof: [Lemma B.1] Consider following invariants Algorithm 5 follow
description Algorithm 5.
a. minimum cost solution Open always removed line 11 Algorithm 4.
b. Algorithm 5 expands solution, say Sp , two phases. first phase Sp
expanded using native swap options Sp . solutions added Open
result application native swap options, cost greater
equal C(Sp ). second phase, i.e., lazy expansion, Sp expanded
using non native swap option. solution Sp may undergo second phase times
0 (|L(Sp )| |N (Sp , k )|) k used construct Sp . every lazy
expansion Sp , new solution added Open. Consider solution Sm
using Algorithm 5 P red(S ). Suppose swap
constructed Sm

j

option L(Sm ),
/ N (Sm , j ), i.e., native swap option Sm .
). Suppose successors respectively,
Clearly L(Sm

c

c



constructed application , i.e., Sm
Sc , Sm
Sc . let Sc
added Closed Sm .
Consider fact Algorithm 5 apply swap option Sm , is, Sc
) C(S ), C(S ) C(S ).
added Open Sc added Closed. Since C(Sm

c
c
According Algorithm 5, applied Sm (during lazy expansion), Sc
added Open right Sc added Closed. Consider time period
adding Sm adding Sc Closed. period, every solution added
Closed cost C(Sm ) C(Sc ), i.e., cost less equal C(Sc ).
general, application swap option add solution Open delayed
amount time, say , solutions, added Closed
time interval, cost less equal solution consideration.
321

fiGhosh, Sharma, Chakrabarti, & Dasgupta

facts follow Algorithm 5 adds solutions Closed list
non-decreasing order costs.


Lemma B.2 two reconvergent paths SSDAG G alternating AND/OR
tree equal length.
Proof: [Lemma B.2] Consider paths:












1
2
n
1
2
(i) p1 = S1
Sp

Sn , (ii) p2 = S1
Sp

Sn .

edges paths represent application swap option solution. p1
p2 start solution end solution. Therefore sets
swap options used paths same. Hence lengths paths
equal, is, context p1 p2 , n = m.
Lemma B.3 set reconvergent paths length n, Algorithm 5 generates
one path.
Proof: [Lemma B.3] following cases possible.
[Case 1 (n = 2) :] Consider following two paths:








1
2
1
2
(i) p1 = S1
S2
S3 , (ii) p2 = S1
S2
S3 .

obvious 1 = 2 2 = 1 . Suppose S2 S2 . Algorithm 5
apply swap option 1 S2 . Therefore p2 generated Algorithm 5.
[Case 2 (Any values n) :] case, path belonging set reconvergent paths, consists n different swap options, suppose 1 , , n . start
node end node paths consideration Sp Sm . Consider nodes
paths length 1 Sp . Clearly n nodes.
Among nodes, suppose Algorithm 5 adds Sp1 Closed first, Sp1 constructed
Sp applying swap option 1 . According Algorithm 5, 1 applied
node constructed Sp added Closed Sp1 . Therefore,
paths starting Sp , whose second node Sp1 , generated
Algorithm 5. use similar argument paths Sp1 Sm length n 1
determine paths generated Algorithm 5. stage, set
paths grown further, one path towards Sm continue grow.
applying previous argument n times, one path Sp Sm
constructed. Therefore Algorithm 5 generate one path Sp Sm .


Definition B.s [Connection Relation Rc Rc ] define connection relation, Rc ,
symmetric order relation pair nodes, vq vr , belonging alternating
AND/OR tree as:
(vq , vr ) Rc | exists node vp ,
exist two paths, (i) p1 = vp . . . vq ,

(ii) p2 = vp . . . vr
322

fiGenerating Ordered Solutions Explicit AND/OR Structures

Similarly connection relation, Rc , defined two swap options follows. Consider two swap options iq jr , iq = hei , eq , iq jr = hej , er , jr i. Suppose
edges ei eq emanate vp , edges ej er emanate vt .
(iq , jr ) Rc (vp , vt ) Rc .
Definition B.t [Mutually Connected Set] solution Sm , set Vm nodes
mutually connected,

v1 , v2 Vm , (v1 6= v2 ) {(v1 , v2 ) Rc }
Consider set nodes, Vm = {v1 , , vk }, swap option j belongs vj
1 j k. set swap options Vm = {1 , , k } mutually connected.
Lemma B.4 Suppose Sm solution alternating AND/OR tree , P red(Sm ) =
{S1 , , Sk }, swap option j used construct Sm Sj 1 j k.
swap options 1 , , k mutually connected.
Proof: [Lemma B.4] Since Sm constructed S1 , , Sk applying 1 , , k respectively, 1 , , k present signature Sm . Suppose set = {1 , , k }.
show

, b , (a , b ) Rc

purpose proof contradiction, let us assume (i1 , i2 )
/ Rc . Sm constructed applying i1 i2 Si1 Si2 respectively. Consider path p1 SSDAG
starts Sopt ends Sm , along p1 , Si1 parent Sm .
along path, i2 applied application swap option i1 . Similarly consider path p2 SSDAG starts Sopt ends Sm , along p2 ,
Si2 parent Sm . Along path, i1 applied application swap
option i2 .
Suppose i1 i2 belongs node v1 v2 respectively. Since along path p1 , i1
swap option applied last, Sm contains node v1 . Similarly along path p2 , i2
swap option applied last. Hence Sm contains node v2 . Therefore, must
node vr , exist paths node v1 v2 implies
(i1 , i2 ) Rc . arrive contradiction proves 1 , , k mutually connected.



Definition B.u [Subgraph SSDAG] Consider solution Sp alternating AND/OR
tree Tand mutually connected set Vm nodes Sp , vq Vm , C(Sp , vq ) =
(S , V ) = hV
Copt (vq ) . subgraph Gsub
p
sub , Esub SSDAG respect Sp
Vm defined follows. Vsub consists solutions constructed
Sp applying sequence swap options belonging Vm , Esub set edges
corresponding swap options belong Vm .
(S , V )
Lemma B.5 number total possible distinct solutions level Gsub
p

,

|V
|
=
n.
n+d2

n1

323

fiGhosh, Sharma, Chakrabarti, & Dasgupta

Proof: [Lemma B.5] Consider swap options belong nodes Vm .
(S , V ) represented sequence
respect swap options, every solution Sr Gsub
p
numbers length n, Seq(Sr ), every number corresponds distinct node Vm .
numerical value number represent rank swap option chosen
node vq Vm . According representation, level:
i. sum numbers Seq(Sr ) solution, Sr , equal sum numbers
Seq(Sr ) solution, Sr , level;
ii. sum numbers Seq(Sr ) solution, Sr , increased 1 sum
numbers Seq(Sr ) solution, Sp , previous level.
Hence, dth level, n slots 1 increments need made
Seq(Sr ). instance well known combinatorial problem packing n + 1
objects n slots
restriction keeping least one object per slot.
n+d2
done n1 ways.


Theorem B.1 solution space tree constructed Algorithm 5 complete.
Proof: [Theorem B.1] purpose contradiction, suppose Sm first solution
generated Algorithm 5. P red(Sm ) = {Spi } Sm constructed
Spi applying qi , 1 k. Lemma B.4 follows set
swap options {qi | 1 k} mutually connected. Therefore set nodes Vm
swap options belong mutually connected. Suppose |Vm | = n.
Consider solution Sq , Vm mutually connected, 1 k, every qi
belongs set native swap options Sq respect swap option used
construct Sq . Clearly

vt Vm , C(Sq , vt ) = Copt (vt )

argue Sq generated Algorithm 5 Sm first solution
rooted ,
generated Algorithm 5. Consider subtree Tsub
q
edges corresponding swap options belong Vm considered. prove
equal
number solutions generated Algorithm 5 every level Tsub

number solutions level Gsub (Sq , Vm ).
Consider solution Sq set Succ(Sq ). Suppose Succ(Sq , Vm ) set
successor solutions constructed Sq applying swap options belonging

minimum cost solution Succ(Sq , Vm ). According
nodes Vm , Smin

Algorithm 5 initially Succ(Smin ) partially explored using set native swap options

Smin
. non native swap option, b , belongs nodes Vm , used


explore Succ(Smin
), right sibling solution Smin
, constructed applying b Sq,
added Closed. Consider fact solution Sq , vt Vm , C(Sq , vt ) = Copt (vt )
holds. Therefore swap options belonging Vm eventually used explore

successors Smin
. Similarly second best successor Sq able use

.
one swap option, c , used construct Smin


immediate children Smin Tsub consist solutions, obtained


application one swap option Vm Smin
. native swap list Smin
contains
swap option ranking next c . swap options, used construct
324

fiGenerating Ordered Solutions Explicit AND/OR Structures


n 1 sibling solutions Smin
, used lazy expansion, accounts


another n 1 children Smin
. Hence would n children Smin
.

Similarly, second best successor Sq Tsub n 1 immediate children.
n 2 children on. children
third best successor Sq Tsub
solutions children solutions own, increasing number
solutions level tree. way, increasing level, number
solutions present level keeps increasing. prove following proposition part
proving Theorem B.1.
) given
Proposition B.1 level d, number solutions N (d, n, Tsub


n
X
n+d2


N (d, n, Tsub ) =
N (d 1, k, Tsub ) =
n1
k=1

Proof: [Proposition B.1] second level, n solutions. give rise

k=1

k+

n1
X

k+

k=1

n2
X
k=1

k

k=1

solutions third level. Similarly fourth level
n
X

n
X



) + ... + 1
) + N (3, n 1, Tsub
k.... + 1 = N (3, n, Tsub

extend level result follows.

) = 1
N (1, n, Tsub


) = n
N (2, n, Tsub


n
X
n+1

N (3, n, Tsub ) =
k=
2
k=1


N (4, n, Tsub
)

=

n
X
k=1


N (3, k, Tsub
)

=




n+2
3

induction depth d.
determine number solutions level Tsub

[Basis (d = 1) :]

) = n.
Clearly, N (1, n, Tsub



[Inductive Step :] Suppose, dth level number solutions n+d2
= n+d2
n1
d1 .
Therefore + 1th level,





n
X
n+d2
n+d3
n+d1


N (d + 1, n, Tsub ) =
+
N (d, k, Tsub ) =
+ + 1 =
d1
d1
n1
k=1

Since Algorithm 5 generate duplicate node, Proposition B.1
(S , V ) level equal number solutions
number solutions Gsub
q

(S , V ) generated

level Tsub , level set solutions Gsub
q
(S , V ),

Algorithm 5 Tsub . Therefore, level, Sm belongs Gsub
q
generated Algorithm 5. Therefore Sm generated Algorithm 5
contradiction establishes truth statement Theorem B.1.


325

fiGhosh, Sharma, Chakrabarti, & Dasgupta

Appendix C. Conversion AND/OR Tree Alternating
AND/OR Tree
AND/OR tree generalization alternating AND/OR tree restriction
strict alternation nodes relaxed. words intermediate
node child another intermediate node similar parent child
relation allowed node. present algorithm convert AND/OR
equivalent alternating AND/OR tree.
use two operations namely, folding unfolding conversions. Corresponding
every edge, stack, update-list, used conversions. AND/OR tree, consider
two nodes, vq vr , similar type (AND/OR) connected edge er .
Edges, e1 , , ek emanate er .
[Folding Node :] Suppose vq vr nodes. folding vr performed
follows.
source edges e1 , , ek changed vr vq costs updated
ce (ei ) ce (ei ) + ce (er ) + cv (vr ) 1 k, new cost sum
old cost cost edge points source ei . triplet
hvr , cv (vr ), ce (er )i pushed update-list ei , 1 k.
edge er along node vr removed vq .
[Folding Node :] Suppose vq vr nodes. folding vr performed follows.
source edges e1 , , ek changed vr vq . One edges among
e1 , , ek , suppose ei , selected arbitrarily cost updated ce (ei )
ce (ei ) + ce (er ) + cv (vr ) 1 k. triplet hvr , cv (vr ), ce (er )i pushed
update-list ei , whereas triplet hvr , 0, 0i pushed update-list ej ,
1 j k j 6= i.
edge er along node vr removed vq .
unfolding operation reverse folding operation
nodes. works node vq follows.
Procedure Unfold(node vq )
1
2
3
4
5
6
7
8
9
10
11

forall edge ei emanate vq
update list ei empty
hvt , c1 , c2 pop(update list ei );
exists edge et vq points node vt
Create node vt , connect vt using edge et vq ;
cv (vt ) c1 ;
ce (et ) c2 ;
else c2 6= 0
ce (et ) c2 ;
end
end

326

fiGenerating Ordered Solutions Explicit AND/OR Structures

Function Convert takes root node AND/OR tree transforms equivalent
alternating AND/OR tree recursively.
Function Convert(vq )
1
2
3
4
5
6

7

every child vq terminal node
vq parent vp type
Apply f old operation vq ;
end
else
foreach child vr vq , vr intermediate AND/OR node
Convert(vr );
end

Function Revert takes root node alternating AND/OR tree converts
original AND/OR tree recursively.
Function Revert(vq )
1
2
3
4
5
6

every child vq terminal node
return;
Perform unf old operation vq ;
foreach child vr vq
Revert(vr );
end

overall process generating alternative solutions AND/OR tree follows.
AND/OR tree converted alternating AND/OR tree using Convert function,
solutions generated using ASG algorithm. solutions transformed back
using Revert function. proof correctness presented below.
C.1 Proof Correctness
Suppose AND/OR tree two nodes, vq vr , similar type (AND/OR)
connected edge er . Edges e1 , , ek emanate er . fold operation
1 AND/OR tree generated application
applied vq vr . Let
f old operation.
Lemma C.1 context mentioned above, present claim following two
propositions.
Proposition C.1 set solutions node vq generated set
1 node v applying unfold operation v solutions
solutions
q
q
.
1 1 contains node v , exists soluProposition C.2 every solution Sm
q

1
tion Sm generated Sm applying unfold vq .

Proof: [Proposition C.1] present proof following cases. Consider
solution Sm contains node vq .
327

fiGhosh, Sharma, Chakrabarti, & Dasgupta

a. vq vr nodes: two cases possible.
1. vr absent Sm : Since fold operation modifies edge er only,
1 . Therefore
edges vq present

1
present solution set remain unchanged
application unfold operation.
2. vr present Sm : Since k distinct edges emanating vr ,
let one edges, say ei , present Sm . prove
1 1 , application unfold operation 1
solution Sm


generate Sm . application fold operation node vr modifies source
1 .
cost edge ei vr vq ce (ei ) ce (ei ) + ce (er ) + cv (vr )
1 solution 1 , edge e present 1 .
Suppose Sm



1
subtree rooted vq , remaining parts Sm
identical
1
1
other. Clearly Sm exists solution application
1 generates .
unfold operation vq Sm

b. vq vr nodes: Since vq node Sm contain
edges emanate vq . Therefore edge er vr present
1 1 , following holds.
Sm . Consider solution Sm

1.
1. vq present Sm

2. subtrees rooted children vq vr Sm identical
1 .
subtrees rooted children vq Sm
1 identical
3. subtree rooted vq , remaining parts Sm

other.
1 exists solution 1 application unfold operation v
Clearly Sm
q

1
Sm generates Sm .

1
solution Sm
contain node vq , valid solution
well.



Proof: [Proposition C.2] present proof following cases. Consider
1 1 contains node v .
solution Sm
q

a. vq vr nodes: Since vq node, exactly one edge ei vq
1 . two cases possible.
belong Sm
1 : Since fold operation modifies
1. ei modified folding vr
edge er edges vr only, edges vq
1 . Since e modified folding, solution
present

1
Sm valid solution .
1 : Suppose e connects v v
2. ei modified folding vr

q

1 generate solution .
1
Sm . Apply unfold operation node vq Sm

edge ei replaced edge er connects vq vr ei
connect vr vi . argue Sm valid solution since

328

fiGenerating Ordered Solutions Explicit AND/OR Structures

subtree rooted vi modified sequence (a) folding vr
1 , (b) unfolding v construct 1 .
construct
q



1 contain
b. vq vr nodes: Since vq node, Sm
edges emanate vq . two types edges emanating
1 (a) Type-1 : edges v present
vq
q

vq , (b) Type-2 : edges added vq folding edges
1 generate solution
vr . Apply unfold operation node vq Sm
Sm . Sm contain Type-1 edges, another edge er vq . Sm , vq vr
connected er Type-2 edges originated vr . argue Sm
valid solution since subtree rooted nodes pointed Type-2 edges
1 ,
modified sequence (a) folding vr construct

1.
(b) unfolding vq construct Sm Sm


1 1 contain node v valid solution
Clearly solution Sm
q


well.



Lemma C.2 function Convert applied root node AND/OR tree ,
alternating AND/OR tree generated.
Proof: [Lemma C.2] Function Convert traverses every intermediate node depth first
manner. Consider sequence nodes, vq1 , vq2 , , vqn type, vqi
parent vqi+1 1 < n. Obviously, fold operation applied vqi+1
vqi , 1 < n. words, fold operation applied sequence
nodes reverse order folding vqi+1 , edges vqi+1 modified
moved vqi , 1 < n. function call Convert(vq2 ) returns, edges
vq2 , , vqn already moved vq1 sequence nodes, vq1 , vq2 , , vqn
flattened. Therefore, every sequence nodes type flattened, function
call Convert(vR ) returns, vR root alternating AND/OR tree
generated.
Lemma C.3 function Revert applied alternating AND/OR tree , updatelist every edge becomes empty.
Proof: [Lemma C.3] Follows description Revert.
Theorem C.1 AND/OR tree , possible construct alternating AND/OR
tree using function Convert, set possible solutions generated
order increasing cost applying Algorithm 4 , converting
individual solutions using function Revert.
Proof: [Theorem C.1] According Lemma C.2, application function Convert
alternating AND/OR tree generated. Consider intermediate AND/OR
0 , 1 , , n
trees generated folding every node . Let


n . Since generated i+1
0 = ,
=

sequence AND/OR trees





329

fiGhosh, Sharma, Chakrabarti, & Dasgupta

, 0 < n, according
folding exactly one node
generated i+1 unfolding
solutions

Lemma C.3, solution , Revert unfolds every node vq
vq folded Convert transforming . Therefore
generated solutions .

Lemma C.1,
node. According
solution,
solutions

References
Bonet, B., & Geffner, H. (2005). algorithm better AO ?. Proceedings
20th national conference Artificial intelligence - Volume 3, pp. 13431347. AAAI
Press.
Chakrabarti, P. P. (1994). Algorithms searching explicit AND/OR graphs
applications problem reduction search. Artif. Intell., 65 (2), 329345.
Chakrabarti, P. P., Ghose, S., Pandey, A., & DeSarkar, S. C. (1989). Increasing search
efficiency using multiple heuristics. Inf. Process. Lett., 32 (5), 275275.
Chang, C. L., & Slagle, J. R. (1971). admissible optimal algorithm searching
AND/OR graphs. Artif. Intell., 2 (2), 117128.
Chegireddy, C. R., & Hamacher, H. W. (1987). Algorithms finding k-best perfect matchings. Discrete Applied Mathematics, 18 (2), 155165.
Chen, H., Xu, Z. J., Liu, Z. Q., & Zhu, S. C. (2006). Composite templates cloth modeling
sketching. Proceedings 2006 IEEE Computer Society Conference
Computer Vision Pattern Recognition - Volume 1, pp. 943950. IEEE Computer
Society.
Cormen, T. H., Stein, C., Rivest, R. L., & Leiserson, C. E. (2001). Introduction Algorithms
(2nd edition). McGraw-Hill Higher Education.
Darwiche, A. (1999). Compiling knowledge decomposable negation normal form.
Proceedings 16th international joint conference Artifical intelligence - Volume
1, pp. 284289. Morgan Kaufmann Publishers Inc.
Darwiche, A. (2001). Decomposable negation normal form. J. ACM, 48, 608647.
Dasgupta, P., Sur-Kolay, S., & Bhattacharya, B. (1995). VLSI floorplan generation
area optimization using and-or graph search. VLSI Design, 1995., Proceedings
8th International Conference on, pp. 370 375.
Dechter, R., & Mateescu, R. (2007). AND/OR search spaces graphical models. Artif.
Intell., 171 (2-3), 73106.
Ebendt, R., & Drechsler, R. (2009). Weighted search - unifying view application.
Artificial Intelligence, 173 (14), 1310 1342.
Elliott, P. (2007). Extracting k best solutions valued And-Or acyclic graph.
Masters thesis, Massachusetts Institute Technology.
Elliott, P., & Williams, B. (2006). DNNF-based belief state estimation. Proceedings
21st national conference Artificial intelligence - Volume 1, pp. 3641. AAAI
Press.
330

fiGenerating Ordered Solutions Explicit AND/OR Structures

Eppstein, D. (1990). Finding k smallest spanning trees. Proc. 2nd Scandinavian
Worksh. Algorithm Theory, No. 447 Lecture Notes Computer Science, pp. 38
47. Springer Verlag.
Eppstein, D. (1998). Finding k shortest paths. SIAM J. Comput., 28 (2), 652673.
Flerova, N., & Dechter, R. (2010). best solutions graphical models. 1st Workshop
Constraint Reasoning Graphical Structures.
Flerova, N., & Dechter, R. (2011). Bucket mini-bucket schemes best solutions
graphical models. GKR 2011(a workshop IJCAI 2011).
Fromer, M., & Globerson, A. (2009). LP view m-best MAP problem. Advances
Neural Information Processing Systems (NIPS) 22, pp. 567575.
Fuxi, Z., Ming, T., & Yanxiang, H. (2003). solution billiard balls puzzle using ao
algorithm application product development. Palade, V., Howlett, R., &
Jain, L. (Eds.), Knowledge-Based Intelligent Information Engineering Systems,
Vol. 2774 Lecture Notes Computer Science, pp. 10151022. Springer Berlin /
Heidelberg.
Gogate, V., & Dechter, R. (2008). Approximate solution sampling (and counting)
AND/OR spaces. CP, pp. 534538.
Gu, Z., Li, J., & Xu, B. (2008). Automatic service composition based enhanced service
dependency graph. Web Services, 2008. ICWS 08. IEEE International Conference
on, pp. 246 253.
Gu, Z., Xu, B., & Li, J. (2010). Service data correlation modeling application
data-driven service composition. Services Computing, IEEE Transactions on, 3 (4),
279291.
Gupta, P., Chakrabarti, P. P., & Ghose, S. (1992). Towers Hanoi: generalizations,
specializations algorithms. International Journal Computer Mathematics, 46,
149161.
Hamacher, H. W., & Queyranne, M. (1985). K best solutions combinatorial optimization
problems. Annals Operations Research, 4, 123143.
Hansen, E. A., & Zhou, R. (2007). Anytime heuristic search. J. Artif. Intell. Res. (JAIR),
28, 267297.
Hansen, E. A., & Zilberstein, S. (2001). LAO : heuristic search algorithm finds
solutions loops. Artificial Intelligence, 129 (1-2), 35 62.
Homem de Mello, L., & Sanderson, A. (1990). AND/OR graph representation assembly
plans. Robotics Automation, IEEE Transactions on, 6 (2), 188 199.
Jimenez, P., & Torras, C. (2000). efficient algorithm searching implicit AND/OR
graphs cycles. Artif. Intell., 124, 130.
Kleinberg, J., & Tardos, E. (2005). Algorithm Design. Addison-Wesley Longman Publishing
Co., Inc., Boston, MA, USA.
Lang, Q. A., & Su, Y. (2005). AND/OR graph search algorithm discovering composite web services. International Journal Web Services Research, 2 (4), 4664.
331

fiGhosh, Sharma, Chakrabarti, & Dasgupta

Lawler, E. L. (1972). procedure computing k best solutions discrete optimization
problems application shortest path problem. Management Science,
18 (7), pp. 401405.
Ma, X., Dong, B., & He, M. (2008). AND/OR tree search algorithm web service composition. PACIIA 08: Proceedings 2008 IEEE Pacific-Asia Workshop
Computational Intelligence Industrial Application, pp. 2327, Washington, DC,
USA. IEEE Computer Society.
Majumdar, A. A. K. (1996). Generalized multi-peg Tower Hanoi problem. Journal
Australian Mathematical Society. Series B. Applied Mathematics, 38, 201208.
Marinescu, R., & Dechter, R. (2005). AND/OR branch-and-bound solving mixed integer
linear programming problems. CP, p. 857.
Marinescu, R., & Dechter, R. (2006). Memory intensive branch-and-bound search graphical models. AAAI.
Marinescu, R., & Dechter, R. (2007a). Best-first AND/OR search 0/1 integer programming. CPAIOR, pp. 171185.
Marinescu, R., & Dechter, R. (2007b). Best-first AND/OR search graphical models.
AAAI, pp. 11711176.
Marinescu, R., & Dechter, R. (2009a). AND/OR branch-and-bound search combinatorial
optimization graphical models. Artif. Intell., 173 (16-17), 14571491.
Marinescu, R., & Dechter, R. (2009b). Memory intensive AND/OR search combinatorial
optimization graphical models. Artif. Intell., 173 (16-17), 14921524.
Martelli, A., & Montanari, U. (1973). Additive AND/OR graphs. Proceedings
3rd international joint conference Artificial intelligence, San Francisco, CA, USA.
Morgan Kaufmann Publishers Inc.
Martelli, A., & Montanari, U. (1978). Optimizing decision trees heuristically guided
search. Commun. ACM, 21, 10251039.
Mateescu, R., & Dechter, R. (2008). AND/OR multi-valued decision diagrams constraint
networks. Concurrency, Graphs Models, pp. 238257.
Mateescu, R., Dechter, R., & Marinescu, R. (2008). AND/OR multi-valued decision diagrams (AOMDDs) graphical models. J. Artif. Intell. Res. (JAIR), 33, 465519.
Mathews, D. H., & Zuker, M. (2004). RNA secondary structure prediction. Encyclopedia
Genetics, Genomics, Proteomics Bioinformatics. John Wiley & Sons, Ltd.
Nilsson, D. (1998). efficient algorithm finding probable configurations
probabilistic expert systems. Statistics Computing, 8, 159173.
Nilsson, N. J. (1980). Principles artificial intelligence. Tioga Publishing Co.
Otten, L., & Dechter, R. (2011). Anytime AND/OR depth-first search combinatorial
optimization. SoCS.
Pearl, J. (1984). Heuristics: intelligent search strategies computer problem solving.
Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA.
332

fiGenerating Ordered Solutions Explicit AND/OR Structures

Russell, S., & Norvig, P. (2003). Artificial Intelligence: Modern Approach (2nd edition
edition)., chap. Planning, pp. 375461. Prentice-Hall, Englewood Cliffs, NJ.
Shiaa, M. M., Fladmark, J. O., & Thiell, B. (2008). incremental graph-based approach
automatic service composition. IEEE International Conference Services Computing, 4 (2), 4664.
Shin, D. H., Jeon, H. B., & Lee, K. H. (2010). sophisticated approach composing
services based action dominance relation. Services Computing Conference (APSCC), 2010 IEEE Asia-Pacific, pp. 164 170.
Subramanian, S. (1997). Routing algorithms dynamic, intelligent transportation networks. Masters thesis, Virginia Technical Univ., Dept. Civil Engineering.
Sugimoto, K., & Katoh, N. (1985). algorithm finding k shortest loopless paths
directed network. Trans. Information Processing Soc. Japan, 26, 356364.
Japanese.
Szymanski, M., Barciszewska, M. Z., Barciszewski, J., & Erdmann, V. A. (2005). 5S Ribosomal RNA Database. http://biobases.ibch.poznan.pl/5SData/. Online Database.
Takkala, T., Borndorfer, R., & Lobel, A. (2000). Dealing additional constraints
k-shortest path problem. Proc. WM 2000.
Topkis, D. M. (1988). k-shortest path algorithm adaptive routing communications
networks. Trans. Communications, 36 (7), 855859.
Yan, Y., Xu, B., & Gu, Z. (2008). Automatic service composition using AND/OR graph.
E-Commerce Technology Fifth IEEE Conference Enterprise Computing,
E-Commerce E-Services, 2008 10th IEEE Conference on, pp. 335338.

333


