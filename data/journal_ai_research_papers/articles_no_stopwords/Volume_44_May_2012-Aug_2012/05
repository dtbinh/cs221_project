journal artificial intelligence

submitted published

generating ordered solutions explicit
structures
priyankar ghosh
amit sharma
p p chakrabarti
pallab dasgupta

priyankar cse iitkgp ernet
amit ontop gmail com
ppchak cse iitkgp ernet
pallab cse iitkgp ernet

department computer science engineering
indian institute technology kharagpur
kharagpur india

abstract
present generating alternative solutions explicit acyclic
structures non decreasing order cost proposed use best first search
technique report solutions implicit representation ordered cost
present two versions search initial version best first
search asg may present one solution generating
ordered solutions b another version lasg avoids construction
duplicate solutions actual solutions reconstructed quickly implicit
compact representation used applied methods test domains
synthetic others well known including search
space peg tower hanoi matrix chain multiplication
finding secondary structure rna experimental efficacy
proposed existing proposed
potential use domains ranging knowledge frameworks service
composition structure widely used representing

introduction
use structures modeling solving complex efficiently
attracted significant amount effort last decades initially
search spaces mostly used reduction search solving complex
logical reasoning theorem proving etc overall
hierarchically decomposed conjunction disjunction subproblems pearl
nilsson subsequently structures applied variety domains e g representing assembly plans homem de mello sanderson generating vlsi floor plans dasgupta sur kolay bhattacharya puzzle solving fuxi
ming yanxiang etc traditionally ao pearl nilsson
martelli montanari chang slagle used searching implicitly defined structures empirical study ao found bonet
geffners work
recent past renewed interest towards application
structures including conditional
handle uncertainty structure russell norvig natural form

c

ai access foundation rights reserved

fighosh sharma chakrabarti dasgupta

representation generating solutions representations
studied extensively hansen zilberstein jimenez torras chakrabarti
dechter mateescu presented explicit search space
perspective graphical different search strategies best first branch bound
etc search spaces graphical discussed marinescu
dechter b search spaces used solving mixed integer
linear programming marinescu dechter integer programming marinescu
dechter combinatorial optimization graphical marinescu dechter
b multivalued decision diagrams aomdd combine
idea multi valued decision diagrams mdd structures presented
mateescu dechter marinescu along direction
found work mateescu dechter search spaces
applied solution sampling counting gogate dechter smooth deterministic decomposable negative normal forms sd dnnf darwiche exhibit explicit
dag structure used applications including compiling
knowledge darwiche estimating belief states elliott williams etc
apart domains constraint satisfaction knowledge reasoning
etc structure techniques widely used application
domains e g web service composition gu xu li shin jeon lee gu
li xu dong yan xu gu lang su vision
graphics tasks chen xu liu zhu etc lang su described
graph search composing web services user requirements
et al advocated use trees capture dependencies
inputs outputs component web services propose top search
generate solutions tree uses structures
context web service composition found works gu et al
shin et al yan et al chen et al applied explicit
structures cloth modeling recognition important
vision graphics tasks
recent adoption search spaces wide variety ai
warrants towards developing suitable searching
structures different perspectives general setting fundamental
remains minimum cost solution structures given explicit
graph structure minimum cost solution computed topdown bottom approaches principle dynamic
programming complexity linear respect size search
space finding minimum cost solution explicit structure fundamental
step approaches use implicit representation systematically explore
search space particularly case ao nilsson potential
solution graph psg recomputed every time current explicit graph node
expanded view recent structures used leveraged
wide variety ranging domain web service composition
need generating ordered set solutions given structure becomes
imminent briefly mention areas ordered solutions useful



figenerating ordered solutions explicit structures

ordered set solutions explicit dag used develop useful
variants ao currently ao minimum cost solution computed whereas several variants exist solutions often sought
within factor cost optimal solution approaches ebendt drechsler
pearl developed adapt inadmissible heuristics
leveraging multiple heuristics chakrabarti ghose pandey desarkar generating
solutions quickly within bounded sub optimality etc typically techniques order
open list one evaluation function next element expansion selected
ordered subset open criterion similar techniques developed
ao search ordered set potential solutions made available set
used node selection expansion instead expanding nodes current
best psg opens interesting area significant potential
existing variations extended search spaces
context model programming finding ordered set
solutions significant importance elliott used valued sd dnnfs represent
proposed generate k best solutions since valued sd dnnfs
structure proposed possibly earliest
generating ordered set solutions structure finding
ordered set solutions graphical studied flerova dechter
however techniques use alternative representations
search spaces constructed dechter mateescu graphical recent
involving aomdd representation weighted structures suggested future
extensions towards generalizing algebraic decision diagrams introduces notion
cost aomdds envisage ordered set solutions finds useful applications
context around decision diagram representation
domain service composition primary motivation behind providing set
alternative solutions ordered cost offer choices trading specified
cost criterion limited extent favor unspecified criteria primarily
standpoint quality shiaa fladmark thiell presented
generating ranked set solutions service composition typically
quality criteria subjective nature difficult express terms single scalar cost
function able combine cost price quality aspects together
aspects quality often encountered context serving custom user requirements
user prefers minimize cost price solution preserving
preferences example booking holiday package specific destination travel
service portal typically offers list packages combinations attractions
hotel options meal plans ordered single cost criterion namely cost
package general product solution composed number components
compositional flavor similar service composition becomes important present
user set alternative solutions ordered cost select best
alternative according preferences
dynamic programming formulations typically underlying dag structure formally studied past martelli montanari besides
classical matrix chain multiplication many real world optimization offer dynamic programming formulations alternative solutions ordered cost


fighosh sharma chakrabarti dasgupta

useful practice one example finding secondary structure
rna mathews zuker important bioinformatics rnas
may viewed sequences bases belonging set adenine cytocine c guanine g uracil u rna molecules tend loop back form base pairs
resulting shape called secondary structure primary factor influences
secondary structure rna number base pairings higher number base pairings generally implies stable secondary structure well established rules
base pairings maximizing number base pairings interesting dynamic programming formulation however apart number base pairings
factors influence stability factors typically evaluated
experimentally therefore given rna sequence useful compute pool
candidate secondary structures decreasing order number base pairings
may subjected experimental evaluation order determine stable
secondary structure
generating ordered set solutions well studied domains
discrete optimization lawler proposed general procedure
generating k best solutions similar finding k probable configurations
probabilistic expert systems addressed nilsson fromer globerson
addressed finding k maximum probability assignments probabilistic modeling lp relaxation context ordinary graphs eppstein
studied finding k smallest spanning trees subsequently
finding k best shortest paths proposed eppsteins work hamacher
queyranne suggested k best solutions combinatorial optimization generating k best perfect matching presented
chegireddy hamacher researchers applied k shortest path
practical scenarios routing transportation developed specific solutions
takkala borndorfer lobel subramanian topkis sugimoto katoh
however none approaches seems directly applicable structures recently schemes related ordered solutions graphical flerova
dechter anytime graph search otten dechter
proposed anytime traditional search space hansen zhou
well addressed community
address generating ordered set solutions explicit
dag structure present existing method proposed
elliott works bottom computing k best solutions current node
k best solutions children nodes present best first search
named alternative solution generation asg generating ordered set solutions
proposed maintains list candidate solutions initially containing
optimal solution iteratively generates next solution non decreasing order cost
selecting minimum cost solution list iteration minimum cost
solution used construct another set candidate solutions added
current list present two versions
basic asg referred asg henceforth version
may construct particular candidate solution



figenerating ordered solutions explicit structures

b lazy asg lasg another version asg constructs every candidate solution
use compact representation named signature storing
solutions signature solution actual explicit form solution
constructed top traversal given dag representation allows
proposed work top fashion starting initial optimal
solution another salient feature proposed work
incrementally unlike existing proposed interrupted
point time execution set ordered solutions obtained far
observed subsequent solutions generated resumed
moreover upper limit estimate number solutions required known
priori optimized estimate
rest organised follows necessary formalisms definitions
presented section section address generating ordered set
solutions trees subsequently section address finding alternative
solutions explicit acyclic dags non decreasing order cost present two
different solution semantics dags discuss existing well
proposed along comparative analysis detailed experimental
including comparison performance proposed existing
elliott presented section used randomly constructed
trees dags well well known domains including peg tower
hanoi matrix chain multiplication finding
secondary structure rna test domain time required memory used
generating specific number ordered solutions different domains reported
detail section outline briefly applying proposed implicitly
specified structures finally present concluding remarks section

definitions
section describe terminology trees dags followed
definitions used g hv ei directed acyclic graph
v set nodes e set edges g refer
nodes nodes dag respectively direction edges g
parent node child node nodes g successors called terminal
nodes non terminal nodes g two types nodes ii nodes
v v set nodes g respectively n v n v
n v start root node g denoted vr edges edges
edges emanate nodes nodes respectively
definition solution graph solution graph vq rooted node vq v
finite sub graph g defined
vq vq
b vq node g vq vq exactly one immediate
successors g vq
c vq node g vq vq immediate successors
g vq


fighosh sharma chakrabarti dasgupta

every maximal directed path vq ends terminal node
e node vq successors g vq
solution graph g mean solution graph root vr




definition b cost solution graph g every edge eqr e node vq
node vr finite non negative cost ce hvq vr ce eqr similarly every node vq
finite non negative cost denoted cv vq cost solution defined recursively
follows every node vq cost c vq


cv vq vq terminal node






cv vq c vr ce hvq vr vq node

c vq
vr successor vq


p


c vj ce hvq vj j k vq node
cv vq




degree k v vk immediate successors vq
therefore cost solution c vr denoted c denote
optimal solution every node vq opt vq therefore optimal solution
entire dag g denoted sopt opt vr cost optimal solution
rooted every node vq g copt vq defined recursively minimum cost
objective functions follows


cv vq vq terminal node







cv vq min copt vj ce hvq vj j k vq node
copt vq
degree k v vk immediate successors vq g




cv vq p copt vj ce hvq vj j k vq node




degree k v vk immediate successors vq g
cost optimal solution sopt g denoted copt vr alternatively
copt sopt objective function needs maximized instead min function
max function used definition copt vq



may noted possible one solution node
vq qualify optimal one e cost cost
minimum ties optimal solution node vq resolved arbitrarily
one among qualifying solutions determined tie breaking marked
opt vq
tree hv ei dag additionally satisfies
restrictions tree structure e one parent node node vq
context trees use eq denote edge points
vertex vq alternating tree hv ei tree
restriction alternation nodes nodes every
child node node terminal node every children
node node terminal node use term solution tree denote
solutions trees
discuss different solution semantics namely tree semantics
dags every dag converted equivalent tree traversing


figenerating ordered solutions explicit structures

intermediate nodes reverse topological order replicating subtree rooted
every node whenever degree traversed node details
shown procedure convertdag suppose dag g converted
equivalent tree define solutions solutions g
tree semantics
procedure convertdag g
input dag g
output equivalent tree
construct list non terminal nodes g sorted reverse topological
order
empty

vq remove first element
suppose ein vq list incoming edges vq


indegree vq

indegree vq

et ein vq
replicate
sub tree rooted vq vq root

modify target node et vq vq


end

end
end
use solution semantics defined definition default
semantics solutions dags tree semantics used
explicitly mentioned
example



h


v

v

v

h

h

h

v



v

v



h

v

h

h

v



v
h

h

h

h

v

v

v

v

v

v

v

v

v



















figure alternating tree


v



v



h

h

h

h

h

v
h



h

v




h

v



v

v



h

h

h


h





h

figure dag



fighosh sharma chakrabarti dasgupta

present example alternating tree figure figure
terminal nodes represented circle thick outline nodes shown
figures outgoing edges connected semi circular curve examples
edge costs shown side edge within angled bracket cost
terminal nodes shown inside box every non terminal node vq pair costs
cv vq copt vq shown inside rectangle
figure optimal solution every node shown thick dashed edges
arrow head optimal solution tree traced following
thick dashed edges node v cost optimal solution tree
figure shows example dag cost optimal solution dag

generating ordered solutions trees
section address generating ordered solutions trees use
notion alternating trees defined section present
alternating tree presents succinct representation correctness
proofs much simpler alternating trees appendix c every
tree converted equivalent alternating tree respect
solution space
worth noting search space e g search space multipeg tower hanoi exhibit alternating tree structure moreover
presented alternating trees work without modification
general trees section first present existing elliott
briefly present proposed detail
existing bottom evaluation method computing alternative
solutions
illustrate working existing method proposed elliott
computing alternative solutions trees example alternating tree
method referred bu henceforth computes k best solutions bottomup fashion every node vq k best solutions computed k best solutions
children vq overall idea follows
node vq solution rooted vq obtained selecting solution
child therefore k best solutions vq computed selecting top k solutions
entire pool consisting solutions children
b case nodes every child node vq k solutions
solution rooted node vq obtained combining one solution every
child vq different combinations solutions children nodes vq generate
different solutions rooted vq among combinations top k combinations
stored vq
figure working existing every intermediate node
best solutions shown within rounded rectangle every node vq ith best
cost
solution rooted vq shown triplet form z
child solidx z
z


example node v second best solution shown hv means


figenerating ordered solutions explicit structures

nd best solution rooted v obtained selecting nd best solution v
similarly every node vq ith solution rooted vq shown triplet
form sol vec cost triplets sol vec comma separated list solution indices
every element sol vec corresponds child vq j th element sol vec
shows index solution j th child example nd best solution rooted v
shown means nd best solution rooted v computed
nd best solution st child v best solution st nd
child v index sol vec corresponds child shown placing
child node name every index position



h



v

h



v

hv
hv

v

h

h

v v



v





h

hv
hv

v v



v

h

h

v



v

hv
hv



h

h

v



h

h

hv
hv
h

h

h

v

v

v

v

v

v

v















figure example working existing
existing method works input parameter k e number solutions
generated known priori method inherently incremental
nature thus perform efficiently solutions needed demand e g
first top solutions needed next solutions needed case
top solutions recomputed computing next solutions e
st solution th solution next present proposed top
suffer limitation
top evaluation generating ordered solutions
far discussed existing approaches primarily use bottom
computing ordered solutions propose top generating alternative solutions non decreasing order cost may noted top


fighosh sharma chakrabarti dasgupta

incremental nature use edge marking alternative
solution generation asg generate next best solutions previously generated solutions initial phase asg compute optimal solution
given alternating tree perform initial marking edges
following terminology notions used describe asg
context trees use eq denote edge points vertex vq
use following definitions describing proposed top approaches
definition c aggregated cost dag g aggregated cost ca
edge eij node vi node vj defined ca eij ce eij copt vj


v



e



h





v

h

h

e

v



v


h



h

v

h

v



h

v

v




e

e
h



h

h

e
h



h

e h

h



v

v

v

v

v

v

v















figure example edge marking swap option
marking edge notion marking edge follows
node vq l vq list edges vq sorted non decreasing order aggregated
cost edges define difference cost edges ei
ei ei ei emanate node vq ei edge next
ei l vq procedure markor describes marking process edges
node intuitively mark represents cost increment incurred corresponding
edge replaced solution next best sibling edge maximum
aggregated cost marked
consider solution scur containing edge ei vq vi ei eopt scur
mark ei cost increment incurred construct next best solution
scur choosing another child vq figure marks corresponding edges
e e e e e e e e e e e e


figenerating ordered solutions explicit structures

procedure markor vq










construct l vq list edges vq sorted non decreasing order ca
values
count number elements l vq
count
ec l vq
en l vq
tmp ca en ca ec
mark ec pair en tmp
end

definition swap option swap option ij defined three tuple hei ej ij
ei ej emanate node vq ej edge next ei l vq
ij ca ej ca ei say swap option ij belongs node vq


consider node vq sorted list l vq may observed l vq
every consecutive pair edges forms swap option therefore k edges l vq
k swap options formed node vq swap options ranked according
rank original edges l vq figure swap options e
e e e e
e consider node v l v e e therefore swap
options belong v node v rank
respectively
definition e swap operation swap operation defined application swap
option ij hei ej ij solution sm contains edge ei following way
edge e
remove subtree rooted vi sm let modified tree sm

original edge ij
constructed previous step let
b add subtree opt vj sm
edge e swapped edge
newly constructed solution sm
j
ij

intuitively swap operation ij hei ej ij constructs solution sm


sm contains edge ei moreover cost sm increased ij compared cost
sm c sm vi copt vi



proposed use swap option compact representation named signature storing solutions intuitively alternative solution described
set swap operations performed optimal solution sopt interesting observe
applying ordered sequence swap options h k application
swap operation creates intermediate alternative solution example
first swap option sequence applied optimal solution sopt solution say constructed nd swap option applied yet
another solution constructed let si denote solution obtained applying
swap options sopt sequence although ordered sequence swap
options h k used compact representation alternative
solution following key points important observe
among possible sequences generate particular solution need preclude
sequences contain redundant swap options swap options whose orig

fighosh sharma chakrabarti dasgupta

inal edge present solution applied formally defined
later superfluous swap options order applying swap options another important aspect two swap options j j k
source edge j belongs sub tree included solution
si applying si case apply j place e
apply j directly si effect source edge j present
si e swapping location j sequence j becomes
redundant swap option solution constructed would different swapped
sequence original sequence formally define order relation pair
swap options observation later part section formalize
compact representation solutions order relation
b suppose swap option j belongs node vpj important observe
application j sj construct sj invalidates application
swap options belong edge path root node vpj
solution sj sj application swap option
belongs edge path root node vpj would make swap
vpj redundant fact swap option belonging node vpi j
application swap options belong edge path
root node vpi invalidated solution sj reason condition
restricts set swap options applied particular solution
c finally two swap options j j k
j independent applying si subsequently
application j sj b applying j si subsequently application
sj ultimately construct solution happens
original edges j present si thus application one swap option
influence application however desirable use one
way generate solution sj section propose variation top
called lasg resolves issue
definition f order relation r define order relation namely r pair
swap options follows
path vi vr ei er edges qi rj
swap options qi rj r example figure r
b pq hep eq pq rt et rt two swap options vq vr
pq rt r figure r


implicit representation solutions use implicit representation
storing every solution optimal one solutions constructed
optimal solution applying set swap options optimal solution
following way j r applied j therefore every solution
represented sequence swap options appears j j r
intuitively application every swap option specifies swapped edge
part solution since swap options applied specific order r may
happen edge become part solution due application
earlier swap option may get swapped due application later swap option


figenerating ordered solutions explicit structures

definition g superfluous swap option consider sequence swap options
h corresponding solution sm clearly possible swap option
present sequence original edge
present solution si constructed successive applications swap
options solution sopt application effect si e
solution si identical solution si swap option superfluous swap
option respect sequence swap options corresponding solution sm


property sequence swap options corresponding solution minimal
superfluous swap option
property follows definition superfluous swap options notion
implicit representation solution
definition h signature solution minimal sequence swap options corresponding solution sm defined signature sig sm solution
may noted optimal solution sopt alternating tree
sig sopt e empty sequence possible construct one signature
solution r partial order important observe different signatures
particular solution equal length sets swap options corresponding
different signatures equal therefore set swap options corresponding
signature canonical representation signature henceforth use set
notation describing signature solution
v





h




h

v

v

h



v


h



h

v

h

h

v



v

v




h

h
h


h



h

h

h



v

v

v

v

v

v

v















figure solution tree shown figure
figure solution say tree shown figure
solution highlighted thick dashed lines arrow head pair cv vq c vq


fighosh sharma chakrabarti dasgupta

shown within rectangles beside node vq solution used rectangles rounded corner whenever c vq copt vq since generated applying
swap option solution sopt signature sig h consider
another sequence h swap options worth noting
represents solution second swap option namely
applied solution constructed applying sopt source edge
e present solution hence superfluous swap option
definition vopt eopt solution graph sm dag g
define set nodes
fivopt sm set edges eopt sm
vopt sm vq vq sm solution graph sm vq identical solution graph
opt vq



b eopt sm epr edge epr sm vr vopt sm
clearly node vq vopt sm vq present sopt solution graph
sm vq identical solution graph sopt vq b c sm vq copt vq


definition j swap list swap list corresponding solution sm l sm list
swap options applicable sm let sig sm
swap option belongs node vpi application swap options
belong edges path root node vpi invalidated solution
sm hence remaining swap options invalidated sm applied
sm constructing successor solutions sm
important observe swap option source edge belongs
eopt sm application invalidated sm hence solution sm construct l sm restricting swap operations edges belonging eopt sm
moreover condition ensures cost newly constructed solution
computed directly form cost parent solution value applied swap
constructed form
option elaborate suppose solution sm
applying jk

c
cost sm computed directly form c sm jk c sm

jk
ej eopt sm procedure computeswaplist sm describes details computing swap
options given solution sm


procedure computeswaplist sm








l sm compute eopt sm
foreach edge ec eopt sm
exists swap option edge ec
suppose ec emanates node vq ec l vq ec
marked pair htmp en en l vq

cn hec en tmp add cn l sm
end
end

swap list optimal solution l sopt figure
solution shown figure vopt v v except node v v
nodes vi opt vi vi rectangles rounded corner used
c vq copt vq therefore eopt e e since exists swap option


figenerating ordered solutions explicit structures

v





h




h

v

v

h



v


h



h

v

h

v



h

v

v




h
h


h

h



h

h

h



v

v

v

v

v

v

v















figure solution tree shown figure
edges e e swap list solution l hence solution
sm l sm may empty though vopt sm never empty
although use notation ij denote swap option edge ei original
edge edge ej swapped edge succinct representation use single
subscript k ij etc represent swap option alternative representation
swap options relate edge
definition k successors predecessors solution set successors
predecessors solution
sm defined
constructed
succ sm sm
applying swap option

belongs swap
list sm
succ


b p red sm sm



property solution sm alternating tree following state p red c c
ment holds sm




property follows definitions one special case requires attention consider
c p red case arise swap
case c sm



option cost applied sm occurs case tie
asg
present asg best first search generating solutions alternating
tree non decreasing order costs overall idea
follows maintain list open initially contains optimal solution sopt
point time open contains set candidate solutions next best


fighosh sharma chakrabarti dasgupta

solution non decreasing order cost selected iteration minimum cost
solution smin open removed open added another list named closed
closed list contains set ordered solutions generated far successor
set smin constructed successor solution currently present
open well already added closed inserted open however
optimization use sublist closed named tlist store relevant portion closed
checking respect solutions tlist sufficient figure whether
successor solution already added closed interesting observe
interrupted time set ordered solutions computed far
obtained resumed solutions needed
details asg presented
alternative solution generation asg

























input alternating tree
output alternative solutions non decreasing order cost
compute optimal solution sopt perform edge marking populate
swap options
create three lists open closed tlist initially empty
put sopt open
lastsolcost c sopt
open empty
smin remove minimum cost solution open
lastsolcost c smin
remove elements tlist
lastsolcost c smin
end
add smin closed tlist
compute swap list l smin smin
construct succ smin l smin add solutions open

foreach ij l smin
construct sm applying ij smin
construct signature sm sig sm concatenating ij sig smin
check whether sm already present open tlist

sm open sm tlist
add sm open
end
end
report solutions closed

pseudo code line line computes optimal solution sopt performs
marking edges populates swap options initializes open closed tlist
loop line responsible generating solution every time executed
long open empty line asg solution
current minimum cost solution open smin selected removed open
tlist populated maintained line line loop line generates



figenerating ordered solutions explicit structures

successor solutions smin one one adds newly constructed solutions
open newly constructed solution already present open well added
tlist line checking proof correctness presented
appendix discuss following issues related
checking duplication order check whether particular solution si already
present open tlist signature si matched signatures solutions
already present open tlist sufficient check equality
set swap options respective signatures set unique particular
solution may noted tlist used optimization avoids searching
entire closed list
resolving ties removing minimum cost solution open list tie
may encountered among set solutions suppose tie among set stie
sk ties resolved favor predecessor solutions


si sj stie si predecessor sj si removed sj
cases ties resolved arbitrarily favor solution
added open first
working asg
illustrate working asg example tree shown
figure contents different lists obtained first iterations outermost
loop shown table use signature solution representation
purpose solutions already present open constructed expanding
current smin highlighted braces






smin





l smin



























open










z



closed










tlist























table working asg


fighosh sharma chakrabarti dasgupta

entering outermost loop line asg computes optimal solution
sopt populates swap options inserts sopt open thus point time open
contains optimal solution sopt closed tlist empty first iteration
sopt signature sopt selected removed open swap list
sopt l sopt computed l sopt consists two swap options namely
asg adds two solutions open solution sopt added
closed tlist
next iteration solution minimum cost among solutions
currently open selected removed open swap list computed
subsequently added open tlist happens l owing
fact eopt e e exists swap option edges e e
thus nothing else happens iteration next iteration solution removed
open ultimately solution added open adding
closed well tlist next two iterations proceed similar fashion consider
th iteration iteration solution removed open
successor set one solution already present
open inserted open iteration therefore solution
inserted open shown iteration table
technique avoiding checking duplicates open
section present technique avoid checking done adding newly
constructed solution sm open determine whether sm already present open
first explain scenario example portion previous example
shown figure figure solutions shown thick dashed line
arrow head rectangles rounded corner used highlight fact
corresponding node marked solution belong vopt set solution
v


h


h


h



h

h

v
h

v



v



h



h

v


h

h

v
h

h

v

v

v

v

v

v

v

v

















figure solution

figure running example

consider solutions shown figure figure figure
l sopt b succ sopt
c sig sig e sig
constructs solution shown figure adding open twice
part adding succ open ii adding succ open


figenerating ordered solutions explicit structures

v



h


h


h



h

h

v

v



v

h



h

h

v


h

h

h

v
h



v

v

v

v

v

v

v

v

















figure solution

figure solution

use following definitions describe another version asg
constructs solutions way check whether solution already
added open avoided
definition l solution space dag ssdag solution space dag alternating
tree directed acyclic graph dag g hv ei v set
possible solutions tree e set edges defined



sp sm v



e espm fifi espm directed edge node sp sm


sm succ sp

clearly sopt root node g




definition solution space tree completeness solution space tree
alternating tree tree hv e v v v set
possible solutions tree e set edges defined




sp sm v









e


directed
edge

node





p

pm

e epm

sp p red sm




p red sm sp edge sm
p
p
p
sibling set solution sm denoted sib sm solution space tree
tree complete v v


may noted complete solution space tree alternating tree
necessarily unique possible alternating tree
one complete solution space tree however solution space dag tree
unique
definition n native swap options solution consider solution sm alternating tree suppose sm constructed applying swap option ij
solution sp since swap option ij hei ej ij used construct sm node vj
present sm native swap options solution sm respect swap option ij
n sm ij subset l sm comprises following swap options


fighosh sharma chakrabarti dasgupta

v





h




h

v

v

h



v


h



h

v

h

h

v



v

v




h
h


h

h



h

h

h



v

v

v

v

v

v

v















figure solution tree shown figure
jk jk swap option edge ej
b belongs node vq vq node sm vj
use term n sm denote native swap options ij understood
context intuitively native swap options solution sm swap options
become available immediately applying ij available predecessor
solution sm



consider solution shown figure sig
solution highlighted thick dashed lines arrow head used rectangles rounded corner beside node vq solution c vq copt vq
suppose constructed form solution sig swap
option n whereas l
consider solution sig worth observing applying native swap options instead swap options l
prevents construction solution solution constructed
applying solution sig however may
noted native swap option solution
lazy asg
intuition behind version asg follows newly
constructed solution sm need check whether sm already present open
sm constructed part computing successor set multiple solutions
instead entire swap list solution construct successors
add solutions open native swap options constructing subset
successor set ensures following subset constructed native swap options


figenerating ordered solutions explicit structures

consists solutions currently present open thus
added open without comparing existing entries open construction

remaining successor solution sm
insertion open delayed
added closed
every predecessor solution sm
lazy asg lasg




































input alternating tree
output alternative solutions non decreasing order cost
compute optimal solution sopt perform edge marking populate
swap options
create two lists open closed initially empty
put sopt closed list
create solution space tree sopt root
compute swap list l sopt sopt
construct succ sopt l sopt
forall sm succ sopt
add sm open
end
open empty
smin remove minimum cost solution open
suppose smin constructed sm applying swap option ij

add node corresponding smin connect node edge
sm
compute swap list l smin list native swap options n smin ij
expansion native swap options

foreach tmp n smin ij
construct stmp smin applying tmp
construct signature stmp sig stmp concatenating tmp
sig smin
add stmp open
end
lazy expansion


forall sp sib smin
ij l sp
construct sp sp ij
construct signature sp sig sp concatenating ij sig sp
add sp open
end
end
add smin closed
end
report solutions closed

solution space tree maintained throughout course
added closed idea
determine every predecessor sm


fighosh sharma chakrabarti dasgupta

present lazy version asg named lasg selecting minimum cost
solution open explores successor set current minimum cost
solution lazy fashion solution sm first subset succ sm constructed
native swap options sm solutions belong succ sm
explored late possible described resolving ties lasg
uses strategy used asg details lasg
presented proof correctness presented
appendix b
consider example tree shown figure solutions shown figure
figure initially open contain sopt n sopt
sopt selected open added open next selected
followed since n n selecting successor
solutions constructed native swap list among predecessors
added last closed selecting removing open solution constructed
previously selected predecessor swap option used
construct solution sopt
working lasg tree figure
entering outermost loop line lasg computes
optimal solution sopt constructs succ sopt
solutions succ sopt
added open contents open becomes contents
different lists solution added closed shown table solutions
represented signatures solutions added open
lazy expansion highlighted brace
iteration




smin





n smin
























open








closed












z










table working lasg
generating first four solutions contents different lists lasg
identical contents corresponding lists asg shown table


figenerating ordered solutions explicit structures

soltuions native swap list equal actual swap list solution worth noting unlike asg lasg outermost loop starts
generating optimal solution sopt thus generating solution
iteration number lasg less asg th iteration solution native swap list equal swap list
described previously holds true solution
solution important observe lasg adds
solution open generation solution
part lazy expansion highlighted brace
table whereas asg adds open generating solution

complexity analysis comparison among asg lasg bu
section present complexity analysis asg lasg compare
bu use following parameters analysis
n n denote total number nodes number nodes
alternating tree
b denotes degree node maximum number children
c denotes maximum number edges solution
denotes maximum size open present complexity analysis
generating c solutions therefore size closed c
complexity asg
time complexity time complexity major steps
follows
computing first solution done bottom fashion thus requiring n
steps edges emanating node sorted non decreasing order
aggregated cost compute marks edges marking process takes
n log since value
large general upper bounded
constant n log n
b number swap options available solution equal number
edges solution thus swap list every solution built
time c solutions generating swap options take c
c since size successor set solution size open
c size tlist equal c size
closed
open list implemented fibonacci heap individual insert delete
operation open take amortized lg time respectively hence
inserting open deleting open altogether takes lg time
c log c
e checking duplicates requires scanning entire open tlist since
length tlist c newly constructed solution checking takes
c time c solutions generated since c actually
generating c solutions step takes time maximum value


fighosh sharma chakrabarti dasgupta

c thus time complexity step c clearly
step dominates lg total time taken insertions open
deletions open
however time bound improved maintain hash map
solutions open tlist case checking duplicates
done time case lg total time taken insertions
open deletions open becomes dominant time required checking
duplicates
f upper limit estimate could made estimating size solution tree

n regular complete alternating trees important
observe value independent average degree node

combining
together get time complexity
asg

factors






n n c n c n c n
howeverif additional
hash
reduced

map used time complexity



n lg n c n lg c n n n c lg c c lg n
space complexity following data structures primarily contribute space complexity asg
three lists namely open closed tlist maintained throughout course
running asg contributes c factor
b since number swap options upper bounded total number edges
constructing swap list contributes factor n space complexity
marking solution requires putting mark every node
tree thus adding another n space clearly dominated previous
n factor
c since signature solution essentially set swap options size
signature upper bounded total number swap options available combining
open closed list altogether c solutions need stored
since c

total space required storing solutions n
combining
factors
together get space complexity asg
n n n
additional
hash map used improve time complexity another addi
tional n space required maintaining hash map although exact space
requirement doubled asymptotically space complexity remains
complexity lasg
time complexity compared check
duplicates adds solution open required therefore
terms complexity remain except term corresponding checking
duplicates however created maintained course
creating maintaining tree require c time lazy expansion
swap list previously generated sibling solutions searched line line
size swap list solution maximum
number edges solution sibling solutions


figenerating ordered solutions explicit structures

solution therefore complexity lazy expansion c since c
dominant factor time complexity lasg c c n
space complexity compared asg lasg maintain
tlist however lasg maintains solution space tree whose size equal
closed list thus adding another c factor space complexity incurred asg
interesting observe worst case space complexity remains
n n n equal space complexity asg
comparison bu
time complexity generating c best solutions tree n c log c
space complexity n c detailed analysis found work
elliott since n n space complexity asg lasg
reduces n c time complexity lasg log c factor better
bu whereas time complexity asg quadratic respect c compared
c log c factor bu additional hash map used reduce time overhead
duplicate checking asg beats lasg
bu terms time complexity

n n c lg c c lg n asymptotically lower n c log c
however worst case complexity possible trees duplicate solution generated empirical length open hardly reaches
c

ordered solution generation dags
section present generating solutions non decreasing order
cost given dag present working existing
generating solution tree semantics default semantics next present
modifications asg lasg handling dag
existing bottom
figure shows example working existing bottom bu
dag figure use notations used figure describe
different solutions figure generation top solutions tree
semantics shown
important notice although bu correctly generates alternative solutions
dags tree semantics bu may generate solutions
invalid default semantics figure present solution dag
figure solution example solution correct tree
semantics invalid default semantics solution dag highlighted
thick dashed lines arrow heads figure generated rd solution
dag figure running bu every non terminal node entry
within rectangle corresponding rd solution highlighted bold face may
noted terminal nodes v v included solution dag though
emanate parent node therefore solution valid one
default semantics


fighosh sharma chakrabarti dasgupta



v

v v



h


v

hv
hv

v


h

v

hv
hv



h

v v



v

hv
hv

v

v





hv
hv

v



v


h

v



v

h

hv
hv
h

v v



v


h

h



h

h

h

h

h

h


v

h
v





v

h

h

h

h



v v




hv
hv

v


h

v

v

v

v









figure solution tree semantics

figure bu dag

proposed extension bu generate alternative solutions default
semantics propose simple top traversal pruning extension
bu generate alternative solutions default semantics generating ordered
solutions node vq combining solutions children following
newly constructed solution rooted vq top traversal solution
starting vq done check whether two edges node present
particular solution violation default semantics violation
default semantics detected solution pruned list alternative solutions
rooted vq therefore every node solution constructed
additional top traversal used detect semantics violation
top method dags
proposed top approaches asg lasg applicable
dags generate alternative solution dags default semantics method
computing cost increment application swap option needs modified
incorporate fact node may included solution dag multiple
paths root node use notion participation count computing cost
increment
participation count notion participation count applicable intermediate
nodes solution dag follows solution dag participation count
intermediate node vq total number distinct paths connecting root node vr
vq example figure optimal solution dag shown thick dashed
lines arrow heads participation count every intermediate nodes
shown within circle beside node


figenerating ordered solutions explicit structures

v

h

h


h

v





h



v

v





h

v



h

v

v







h



v



v

v







h

h

h

v






h

h





h

v


h

h

v

v



h





h

h


h



v

v







h

v

v

v

v









figure solution dag

figure dag

use notation ijk denote swap option context dags
swap option ijk belongs node vi source edge swap option eij
node vi node vj destination edge eik node vi node vk
modification proposed top
asg modified handling dags following way
computation successor solution line modified incorporate
participation count node applied swap option belongs
overall method shown next page
order apply lasg dags apart mentioned
modification computing cost newly generated solution another modification
needed computing native swap options given solution modification
explained example consider solution shown figure highlighted
thick dashed lines arrow heads pair cv vq c vq shown within
rectangles beside node vq rectangles rounded corner used c vq
copt vq swap option applied sopt generate application
swap option participation count node v decremented therefore
path root node node v node v still present
swap option available participation count equal
node v whereas available parent solution sopt participation
count node v words available parent solution
sopt value participation count node v therefore becomes
native swap option generalized definition native swap options solution
presented
definition native swap options solution consider solution sm
dag g sm constructed applying swap option hij solution
sp since swap option hij hehi ehj hij used construct sm node vj belongs


fighosh sharma chakrabarti dasgupta

sm similarly participation count node vi remains greater zero applying hij sm node vi belongs sm native swap options solution sm
respect swap option hij n sm hij subset l sm comprises following
swap options
hjk hjk swap option edge ehj
b belongs node vq vq node sm vj
c node vi present sm belongs node vq vq
node sm vi
use term n sm denote native swap options hij understood
context intuitively native swap options solution sm swap options
become available immediately applying hij available predecessor
solution sm


asg dags
input dag g
output alternative solutions g non decreasing order cost
compute optimal solution sopt perform edge marking populate
swap options
create three lists open closed tlist initially empty
put sopt open
lastsolcost c sopt
open empty

smin remove minimum cost solution open

lastsolcost c smin

remove elements tlist

lastsolcost c smin

end

add smin closed tlist

compute swap list l smin smin
construct succ smin l smin add solutions open


foreach ij l smin

construct sm applying ij smin

construct signature sm sig sm concatenating ij sig smin

let ij belongs node vq p participation count vq
cost increment ij

c sm c sm p
check whether sm already present open tlist


sm open sm tlist

add sm open

end
end
report solutions closed
worth noting definition native swap option generalization
earlier definition native swap option definition n defined context trees


figenerating ordered solutions explicit structures

case trees participation count node maximum therefore
application swap option solution participation count node
original edge swap option points becomes therefore third
condition never applicable trees
lasg algo applied dags mentioned modification
computing cost newly generated solution general definition native
swap option generate ordered solutions default semantics
working asg lasg dag
describe working asg example dag shown figure
entering outermost loop tlist closed empty open contains
optimal solution sopt contents different lists obtained first cycles
outermost loop shown table solution represented signature
solutions already present open constructed expanding
current smin highlighted braces example solution
added open iteration constructing successor solutions
constructed iteration expanding solution
l smin
open













smin



















z


closed











table example working asg dag shown figure
illustrate working lasg example dag shown figure contents different lists solution added closed shown
table worth noting solution swap list l
whereas native swap list n solutions
added open lazy expansion highlighted brace example
iteration lasg adds solution open generation
solution part lazy expansion whereas asg adds
open generating solution
generating solutions tree semantics
unlike default semantics asg lasg straight forward extension
generating solutions tree semantics figure example
solution valid tree semantics invalid default semantics
edges emanating form node v namely e e


fighosh sharma chakrabarti dasgupta

n smin
open











smin




















z


closed











table example working lasg dag shown fugure

present solution two edges included solution two
different paths emanating form root node v existing bottom
stores alternative solutions node terms solutions children
node representation allows different paths stored explicitly thus making
bu amenable generating alternative solutions tree semantics
contrary works top compact representation signature storing solutions signature representation currently
possible store fact particular node included solution two
different paths may select different child node use equivalent
tree constructed form given graph compact representation work correctly case node would reachable root node one
path dag converted equivalent tree representation
procedure convertdag described section asg lasg applied equivalent tree representation order generate alternative solutions
correctly tree semantics however worst case procedure convertdag
incurs space explosion blow worst case complexity asg
lasg compact representations generate ordered solutions
tree semantics given dag containing space explosion
worst case complexity remain comparable bu turns
interesting open

experimental observations
obtain idea performance proposed compare
existing implemented asg lasg bu existing bottom
tested following test domains
set synthetically generated trees
b tower hanoi toh
c set synthetically generated dags
matrix chain multiplication
e determining secondary structure rna sequences


figenerating ordered solutions explicit structures

may noted implementation asg implemented
space efficient version asg without separate hash map storing
solutions open closed thereby incurring extra overhead time duplication
checking another important point every test case reported running time
asg lasg generating particular number solutions includes time required
constructing optimal solution graph details different test domains
follows
complete trees
generated set complete ary alternating trees varying
degree non terminal nodes denoted b height denoted h
h





















solutions
asg
lasg
bu

























































solutions
asg
lasg
bu





















































solutions
asg
lasg
bu





















































table comparison running time seconds generating solutions
complete alternating trees denotes timeout minutes
trees viewed search space gift packing
terminal nodes represent cost elementary items
b nodes model choice among items elementary composite nature
represented children
c nodes model repackaging items returned children
every packaging incurs cost modeled cost intermediate nodes
objective alternative gifts order non decreasing cost
table shows time required generating solutions
complete alternating trees implemented asg lasg
existing bottom corresponding running time shown column
heading asg lasg bu respectively used time limit minutes


fighosh sharma chakrabarti dasgupta

h





















asg





















solutions
lasg
bu




































asg





















solutions
lasg
bu



































asg





















solutions
lasg
bu








































table comparison space required kb generating solutions
complete alternating trees

entries marked denotes time occurred test cases
space required generating solutions reported table
observed terms time space required lasg outperforms asg
bu asg bu test cases bu performs better asg
respect time required generating specific number solutions space
requirement asg bu generating specific number solutions interesting
correlation degree height h parameter tree low numerical values
h parameter e g h combinations etc bu performs
better asg contrary combinations least one
h parameters high value e g h combinations etc
asg outperforms bu
experimentation queue bounded length
since open grow rapidly asg lasg incur significant overhead
terms time well space maintain open list number solutions
generated known priori fact asg checking duplicates open
actually primary source time complexity storing solutions open major
contributing factor space complexity number solutions generated
known priori proposed top leverage fact bounded
length queue implementing open bounded length queue used time
requirement along space requirement decreases significantly


figenerating ordered solutions explicit structures

h





















solutions
asg
lasg
bu


























































solutions
asg lasg
bu


































solutions
asg lasg
bu


































table comparison running time seconds generating solutions
complete alternating trees bounded length open queue asg
lasg
h





















asg





















solutions
lasg
bu





































asg





















solutions
lasg
bu







































asg





















solutions
lasg
bu







































table comparison space required kb generating solutions
complete alternating trees bounded length open queue asg
lasg



fighosh sharma chakrabarti dasgupta

effect bounded length queue implement open table reporting time requirement table reporting memory usage generating
solutions number solutions generated known beforehand table table case asg lasg outperforms
bu terms time well space requirements particularly asg performs well
setting outperforming lasg cases
experimentation compare incremental nature
proposed top incremental nature whereas existing bottomup incremental generating specified number ordered solutions
methods generate next solution incrementally without needing restart
whereas existing needs restarted example generating
first ordered solutions asg lasg generate th solution directly data
structures maintained far perform necessary updates
data structures whereas bu needs restarted input parameter generating
th solution table compare time needed generate subsequent th
solution th solution incrementally generating first solutions order
clarity comparison among running times respective
used higher precision upto th decimal place reporting running time
table clearly asg lasg outperform bu generating th th
solution terms time requirement
h





















first





















asg
th





















th





















first





















lasg
th





















th





















first





















bu
th





















th





















table comparison running time seconds generating first solutions
th solution th solution incrementally complete alternating
trees



figenerating ordered solutions explicit structures

multipeg tower hanoi
consider multipeg tower hanoi majumdar gupta chakrabarti
ghose pegs fastened stand initially disks rest
source peg small disk large disk ordering objective transfer
disks destination peg b minimum legal moves legal move
topmost disk tower transferred peg larger disk
topmost disk multi peg tower hanoi solved recursively follows
move recursively topmost k k varies disks
intermediate peg pegs
b transfer remaining k disks b recursively pegs
available
c recursively move k disks transferred previously intermediate
peg b pegs
may noted choice value k may take value
solutions different values k may take different number moves
solution incurs minimum number moves optimal solution choice
value k modeled node every choice divided
three sub decomposition sub modeled
node therefore search spaces multi peg tower hanoi correspond
alternating trees
disks







solutions
asg
lasg
bu
















solutions
asg
lasg
bu















solutions
asg
lasg
bu

















opt
moves







table comparison running time seconds alternating trees corresponding search spaces peg tower hanoi different
number disks
disks







solutions
asg
lasg
bu
asg



















solutions
lasg
bu
asg















solutions
lasg
bu










table comparison space required kb alternating trees corresponding search spaces peg tower hanoi different number
disks
used search space peg tower hanoi different number
disks generated alternative solutions non decreasing order cost asg


fighosh sharma chakrabarti dasgupta

lasg cost function expresses number legal moves value
varied table table report time required
space required respectively generating solutions every test cases
experimental performance asg similar performance
lasg respect space time however asg well lasg outperforms
bu respect time space requirements
randomly constructed dags
constructed set randomly generated dags evaluated asg
lasg bu generating solutions default semantics used
proposed extension bu generating solutions default semantics
n



























solutions
asg lasg
bu














solutions
asg
lasg
bu





















solutions
asg
lasg
bu




























table comparison running time seconds generating solutions dags denotes timeout minutes
n



























asg












solutions
lasg
bu





















asg












solutions
lasg
bu





















asg












solutions
lasg
bu





















table comparison space required kb generating solutions
dags

table table compare time required space required running asg
lasg bu generating solutions every test cases first
second columns every row provide size n average degree
dag obtained test domain similar randomly


figenerating ordered solutions explicit structures

constructed trees may noted terms time space required
lasg outperforms asg bu asg bu test cases
bu performs better asg respect time required generating specific
number solutions whereas space requirement asg bu generating
specific number solutions interesting co relation average degree
size n parameter dag low numerical values n
parameter e g n combinations etc bu performs better
asg contrary combinations least one n
parameter high value e g n combinations
etc asg outperforms bu
matrix chain multiplication
used well known matrix chain multiplication cormen stein rivest
leiserson experimentation search space popular dynamic
programming formulation correspond dag
dag
cnstr
matrices
time
sec



















sopt
cnstr
time
sec










solutions

solutions

solutions

asg

lasg

bu

asg

lasg

bu

asg

lasg

bu



























































































table comparison time required seconds dags corresponding
search spaces matrix chain multiplication different number matrices denotes timeout minutes
matrices










asg










solutions
lasg










bu










asg










solutions
lasg










bu










asg










solutions
lasg










bu










table comparison space required kb dags corresponding
search spaces matrix chain multiplication different number matrices

given sequence matrices n matrices matrix ai dimension pi pi objective efficient way multiply


fighosh sharma chakrabarti dasgupta

matrices classical dynamic programming works follows suppose
j denotes matrix evaluating product ai ai aj j
minimum number scalar multiplications required computing matrix j
therefore cost optimal solution denoted j recursively defined


j




min

ik j



j

k k j pi pk pj j

choice value k modeled node every choice
divided three sub decomposition sub modeled
node worth noting unlike search space peg toh
search space matrix chain multiplication corresponds dag
used search space different matrix sequences varying length
generated alternative solutions order non decreasing cost table report
time required table report memory used generating
solutions every test cases
table test case report time required constructing
explicit dag recursive formulation nd column optimal
solution construction time rd column interesting observe relative
performance asg lasg search space similar obtained peg toh search space though search space domain dag asg
lasg perform approximately respect time space requirement
however advantage asg well lasg bu respect time
space requirement significant domain
generating secondary structure rna
another relevant alternative solutions play important role
computation secondary structure rna rna molecules viewed strings
bases base belongs set adenine cytocine guanine u racil
denoted c g u rna molecules tend loop back form base pairs
resulting shape called secondary structure mathews zuker stability
secondary structure largely depends number base pairings general larger
number base pairings implies stable secondary structure although
factors influence secondary structure often possible express
factors cost function typically evaluated empirically therefore
useful generate set possible alternative secondary structures ordered decreasing
numbering base pairings given rna subjected experimental
evaluation
computation optimal secondary structure considering underlying principle maximizing number base pairings nice dynamic programming formulation kleinberg tardos given rna molecule b hb b bn
bi c g u secondary structure b set base pairings j
j n satisfies following conditions


figenerating ordered solutions explicit structures

test case
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc

organism name
anaerorhabdus furcosa
archaeoglobus fulgidus
chlorobium limicola
desulfurococcus mobilis
haloarcula japonica
halobacterium sp
mycoplasma genitalium
mycoplasma hyopneumoniae
mycoplasma penetrans
pyrobaculum aerophilum
pyrococcus abyssi
spiroplasma melliferum
sulfolobus acidocaldarius
symbiobacterium thermophilum

bases















table details rna sequences used experimentation
j j condition states ends pair
separated least four intermediate bases
b elements pair consists u c g order
c base appears one pairings e matching
j k l two pairs possible k l j e
two pairings cross
test
case
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc

dag cnstr
time sec















sopt cnstr
time sec















asg















solutions
lasg
bu
















asg















solutions
lasg
bu




















asg















solutions
lasg
bu






















table comparison time required seconds dags corresponding
search spaces rna secondary structure different number bases
denotes timeout minutes

mentioned conditions dynamic programming formulation follows
suppose p j denotes maximum number base pairings secondary structure
bi bj p j recursively defined
p j




n


max p j max p k p k j
ik j



j

j

fighosh sharma chakrabarti dasgupta

choice value k modeled node every choice
divided three sub decomposition sub
modeled node experimented search space
set rna molecule sequences obtained test cases developed szymanski
barciszewska barciszewski erdmann details test cases shown
table
every test cases report time required table generating
solutions setting space required reported table table
test case report time required constructing explicit dag
recursive formulation nd column time required constructing
optimal solution time rd column use high value time seconds
order gather running time required bu limit maximum solutions generated
generating higher number solutions bu timed
test cases worth noting obtained domain similar
obtained matrix chain multiplication domain space time
wise asg lasg perform similarly outperform bu significantly respect
time well space requirement
test
case
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc

asg















solutions
lasg















bu















asg















solutions
lasg















bu















asg















solutions
lasg















bu















table comparison space required kb dags corresponding
search spaces rna secondary structure different number bases

observations
experimental data shows lasg generally outperforms asg
existing bottom terms running time complete
alternating trees dags whereas domains
e peg tower hanoi matrix chain multiplication
determining secondary structure rna sequences overall performance
asg similar performance lasg behavior
explained average maximum length statistics open list reported
table table mentioned test domains


figenerating ordered solutions explicit structures

case complete trees random dags asg average well
maximum size open grows much faster lasg table
table increase size tree dag
h





















solutions
asg
lasg
avg
max
avg max















































































solutions
asg
lasg
avg
max
avg max












































































solutions
asg
lasg
avg
max
avg max







































































table average maximum length open generating solutions complete alternating trees
n



























solutions
asg
lasg
avg
max
avg max












































solutions
asg
lasg
avg
max
avg max




































solutions
asg
lasg
avg
max
avg max








































table average maximum length open generating solutions randomly constructed dags

since asg checks presence duplicates expanding solution
time required duplication checking grows rapidly test domains hence
overall time required generating specific number solutions increases rapidly
faster bu lasg increase size tree dag
bu outperforms asg respect time requirement trees dags however


fighosh sharma chakrabarti dasgupta

memory used generating specific number solutions increases moderately slower
bu increase size tree dag therefore respect space
requirement asg outperforms bu larger trees dags
lasg bu time well memory requirement bu increases
faster lasg degree tree dag increases
happens bu time taken merging sub solutions nodes
memory required storing alternative solutions rooted different nodes
increases rapidly increase degree node
contrary test domains peg tower hanoi matrix chain
multiplication probelm finding secondary structure rna sequences
average maximum size open asg lasg comparable table table table therefore lasg time saved
avoiding duplication checking compensated extra overhead maintaining
solution space tree checks required lazy expansion hence running time
well space requirement almost three
mentioned domains
moreover due low values average maximum size open asg
outperforms bu respect time requirement memory used three
test domains three domains lasg bu time well
memory requirement bu increases faster lasg size search
space tree dag increases

ramifications implicitly specified structures
section briefly discuss use proposed generation alternative
solutions non decreasing order cost implicit search spaces one
possible way extend standard ao generating given number solutions
say k follows instead keeping one potential solution graph psg stage k
psgs computed explicitly constructed search space instead expanding
one node k nodes one node psg expanded
expanding nodes k psgs recomputed since cost nodes
often recomputed expanding nodes swap options associated node
updated every recomputation
another possible could run ao generates optimal solution
point time swap options computed explicit portion
graph swap option minimum cost applied optimal solution
resulting psg expanded resulting expansion explicit graph
swap options evaluated incorporate cost update next best psg
computed process continues till second best solution derived among
remaining successor psgs first solution successor psgs second solution
promising psg selected expanded process continues till third solution
found successor psgs added already existing pool candidate
psgs two broad steps selecting next best psg pool candidate
psgs b keeping expanding explicit graph till next best solution
found continued till k solutions found


figenerating ordered solutions explicit structures

disks







solutions
asg
lasg
avg max avg max

























solutions
asg
lasg
avg max avg max
























solutions
asg
lasg
avg max avg max
























table average maximum length open generating solutions peg tower hanoi different number disks
matrices










solutions
asg
lasg
avg max avg max





































solutions
asg
lasg
avg max avg max





































solutions
asg
lasg
avg max avg max




































table average maximum length open generating solutions
matrix chain multiplication
test case
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc
tc

solutions
asg
lasg
avg max avg max

























































solutions
asg
lasg
avg max avg max

























































solutions
asg
lasg
avg max avg max

























































table average maximum length open generating solutions
generating secondary structure rna sequences



fighosh sharma chakrabarti dasgupta

important observe methods heavily depend incorporating updates explicit dag adding nodes increase cost etc recomputing
associated swap options along signatures use swap options handling
dynamic updates dag efficiently use implicit search spaces
remains interesting future direction

conclusion
work presented top generating solutions given
weighted structure dag non decreasing order cost ordered solutions
dags useful number areas including model programming
developing variants ao service composition user preferences real life
dynamic programming formulation etc proposed two
advantages works incrementally e generating specific number solutions
next solution generated quickly b number solutions generated
known priori leverage generate solutions faster experimental
efficacy state art opens
several interesting development applications

acknowledgments
thank anonymous reviewers editor prof hector geffner valuable
comments enriched presentation significantly thank
prof abhijit mitra international institute information technology hyderabad india
valuable inputs regarding test domain involving secondary structure rna
thank aritra hazra srobona mitra scholar department comp sc
engg indian institute technology kharagpur india proof reading

appendix proof correctness
lemma every solution optimal solution sopt constructed
sopt applying sequence swap options according order r
proof lemma every solution sopt alternating tree
constructed choosing non optimal edges nodes consider
solution sm corresponding set non optimal edges suppose
apply relation r obtain ordered sequence edges
e e e appears e e e r exists
sequence swap options constructed every edge eij
eij ith edge append subsequence edges
ei eij eij ei eij edges emanate
parent vq ei eij first ij edges l vq
get sequence edges aug mentioned augmentation
aug basically concatenation subsequences sequence edges
ei eij ei eij edges emanate parent vq
ei eij first ij edges l vq construct aug follows


figenerating ordered solutions explicit structures

every construct hi ij ij ik ik heik eik ik ik
ik ij constructed concatenating every individual hence exists
sequence swap options corresponding every solution sm


definition p default path lemma every non optimal solution sm
constructed initial optimal solution applying sequence swap options
sm according order r sequence solutions formed following sm
corresponds path sopt sm ssdag g path defined default
path pd sm sm
lemma ssdag alternating tree contains every alternative
solution
proof lemma prove induction length default path pd
solutions
basis n consider swap list sopt solutions whose default path length
equal form succ sopt therefore solutions present g
inductive step suppose solutions whose default path length less equal
n present g prove solutions default path length equal
n present g consider solution sm pd sm n let sm
h since p
h n n consider solution sm

n





v swap option
n sm
n l sm directed edge sm sm g
hence every solution default path length equal n present g


lemma alternating tree adds solutions closed
line non decreasing order cost
proof lemma consider following invariants follow
description
minimum cost solution open removed line
b cost solutions added open exploring successor set
solution sm line greater equal c sm
two invariants follows adds solutions closed line
non decreasing order cost
lemma alternating tree every node ssdag
agorithm generates solution corresponding node
proof lemma lemma follows generates solutions
non decreasing order cost generating solution sm mean adding sm
closed line purpose proof contradiction let us assume
generate solution sm let sm first occurrence


fighosh sharma chakrabarti dasgupta

scenario generating solutions mentioned order according lemma
exists sequence swap options k corresponding sm consider
whose sequence swap options
solution sm

k according property

c sm c sm consider following two cases
c since
c sm

first instance incorrect scenario algo generated
rithm generates solutions non decreasing order cost sm
prior sm
c since resolves tie favor parent solution
b c sm


sm first instance incorrect scenario case sm
generated prior sm
generated
swap option k belongs swap list sm



sm added closed sm expanded solutions
applying one swap option added open list since
constructed sm

applying one swap option
constructed sm


added


open

k
therefore
exploring successors sm
eventually generated
contradiction



lemma alternating tree add solution
closed line
proof lemma purpose contradiction let us assume sm first
solution added closed twice therefore sm must added open twice
consider following facts
sm added closed first time value lastsolcost c sm
sm added tlist
b description follows contents tlist deleted
value lastsolcost increases
c lemma follows generates solutions non decreasing
order cost hence sm generated second time value
lastsolcost change c sm
facts follow sm present tlist sm added open
second time since adding solution open checks whether
present tlist line must done
adding sm open second time therefore sm could added open
second time contradiction


theorem sj v sj generated line
non decreasing order costs ties among solutions costs resolved
mentioned
proof theorem follows lemma lemma lemma lemma




figenerating ordered solutions explicit structures

appendix b proof correctness
definition b q reconvergent paths solution space dag two paths p
si si n ii p si si ssdag g alternating
tree reconvergent following holds
si si e paths start node
b si n si e paths ends node

c j n k si j si k e paths common
intermediate node
definition b r order generation time context define
order relation v v sp sq sp generated sq
v set vertices ssdag g alternating tree
lemma b adds solutions closed list non decreasing order
costs
proof lemma b consider following invariants follow
description
minimum cost solution open removed line
b expands solution say sp two phases first phase sp
expanded native swap options sp solutions added open
application native swap options cost greater
equal c sp second phase e lazy expansion sp expanded
non native swap option solution sp may undergo second phase times
l sp n sp k k used construct sp every lazy
expansion sp solution added open consider solution sm
p red suppose swap
constructed sm

j

option l sm
n sm j e native swap option sm
suppose successors respectively
clearly l sm

c

c



constructed application e sm
sc sm
sc let sc
added closed sm
consider fact apply swap option sm sc
c c c
added open sc added closed since c sm

c
c
according applied sm lazy expansion sc
added open right sc added closed consider time period
adding sm adding sc closed period every solution added
closed cost c sm c sc e cost less equal c sc
general application swap option add solution open delayed
amount time say solutions added closed
time interval cost less equal solution consideration


fighosh sharma chakrabarti dasgupta

facts follow adds solutions closed list
non decreasing order costs


lemma b two reconvergent paths ssdag g alternating
tree equal length
proof lemma b consider paths














n


p
sp

sn ii p
sp

sn

edges paths represent application swap option solution p
p start solution end solution therefore sets
swap options used paths hence lengths paths
equal context p p n
lemma b set reconvergent paths length n generates
one path
proof lemma b following cases possible
case n consider following two paths












p

ii p



obvious suppose
apply swap option therefore p generated
case values n case path belonging set reconvergent paths consists n different swap options suppose n start
node end node paths consideration sp sm consider nodes
paths length sp clearly n nodes
among nodes suppose adds sp closed first sp constructed
sp applying swap option according applied
node constructed sp added closed sp therefore
paths starting sp whose second node sp generated
use similar argument paths sp sm length n
determine paths generated stage set
paths grown one path towards sm continue grow
applying previous argument n times one path sp sm
constructed therefore generate one path sp sm


definition b connection relation rc rc define connection relation rc
symmetric order relation pair nodes vq vr belonging alternating
tree
vq vr rc exists node vp
exist two paths p vp vq

ii p vp vr


figenerating ordered solutions explicit structures

similarly connection relation rc defined two swap options follows consider two swap options iq jr iq hei eq iq jr hej er jr suppose
edges ei eq emanate vp edges ej er emanate vt
iq jr rc vp vt rc
definition b mutually connected set solution sm set vm nodes
mutually connected

v v vm v v v v rc
consider set nodes vm v vk swap option j belongs vj
j k set swap options vm k mutually connected
lemma b suppose sm solution alternating tree p red sm
sk swap option j used construct sm sj j k
swap options k mutually connected
proof lemma b since sm constructed sk applying k respectively k present signature sm suppose set k


b b rc

purpose proof contradiction let us assume
rc sm constructed applying si si respectively consider path p ssdag
starts sopt ends sm along p si parent sm
along path applied application swap option similarly consider path p ssdag starts sopt ends sm along p
si parent sm along path applied application swap
option
suppose belongs node v v respectively since along path p
swap option applied last sm contains node v similarly along path p
swap option applied last hence sm contains node v therefore must
node vr exist paths node v v implies
rc arrive contradiction proves k mutually connected



definition b u subgraph ssdag consider solution sp alternating
tree tand mutually connected set vm nodes sp vq vm c sp vq
v hv
copt vq subgraph gsub
p
sub esub ssdag respect sp
vm defined follows vsub consists solutions constructed
sp applying sequence swap options belonging vm esub set edges
corresponding swap options belong vm
v
lemma b number total possible distinct solutions level gsub
p



v


n
n

n



fighosh sharma chakrabarti dasgupta

proof lemma b consider swap options belong nodes vm
v represented sequence
respect swap options every solution sr gsub
p
numbers length n seq sr every number corresponds distinct node vm
numerical value number represent rank swap option chosen
node vq vm according representation level
sum numbers seq sr solution sr equal sum numbers
seq sr solution sr level
ii sum numbers seq sr solution sr increased sum
numbers seq sr solution sp previous level
hence dth level n slots increments need made
seq sr instance well known combinatorial packing n
objects n slots
restriction keeping least one object per slot
n
done n ways


theorem b solution space tree constructed complete
proof theorem b purpose contradiction suppose sm first solution
generated p red sm spi sm constructed
spi applying qi k lemma b follows set
swap options qi k mutually connected therefore set nodes vm
swap options belong mutually connected suppose vm n
consider solution sq vm mutually connected k every qi
belongs set native swap options sq respect swap option used
construct sq clearly

vt vm c sq vt copt vt

argue sq generated sm first solution
rooted
generated consider subtree tsub
q
edges corresponding swap options belong vm considered prove
equal
number solutions generated every level tsub

number solutions level gsub sq vm
consider solution sq set succ sq suppose succ sq vm set
successor solutions constructed sq applying swap options belonging

minimum cost solution succ sq vm according
nodes vm smin

initially succ smin partially explored set native swap options

smin
non native swap option b belongs nodes vm used


explore succ smin
right sibling solution smin
constructed applying b sq
added closed consider fact solution sq vt vm c sq vt copt vt
holds therefore swap options belonging vm eventually used explore

successors smin
similarly second best successor sq able use


one swap option c used construct smin


immediate children smin tsub consist solutions obtained


application one swap option vm smin
native swap list smin
contains
swap option ranking next c swap options used construct


figenerating ordered solutions explicit structures


n sibling solutions smin
used lazy expansion accounts


another n children smin
hence would n children smin


similarly second best successor sq tsub n immediate children
n children children
third best successor sq tsub
solutions children solutions increasing number
solutions level tree way increasing level number
solutions present level keeps increasing prove following proposition part
proving theorem b
given
proposition b level number solutions n n tsub


n
x
n


n n tsub
n k tsub
n
k

proof proposition b second level n solutions give rise

k

k

n
x

k

k

n
x
k

k

k

solutions third level similarly fourth level
n
x

n
x




n n tsub
k n n tsub

extend level follows


n n tsub


n
n n tsub


n
x
n

n n tsub
k

k


n n tsub




n
x
k


n k tsub







n


induction depth
determine number solutions level tsub

basis

n
clearly n n tsub



inductive step suppose dth level number solutions n
n
n

therefore th level





n
x
n
n
n


n n tsub

n k tsub



n
k

since generate duplicate node proposition b
v level equal number solutions
number solutions gsub
q

v generated

level tsub level set solutions gsub
q
v

tsub therefore level sm belongs gsub
q
generated therefore sm generated
contradiction establishes truth statement theorem b




fighosh sharma chakrabarti dasgupta

appendix c conversion tree alternating
tree
tree generalization alternating tree restriction
strict alternation nodes relaxed words intermediate
node child another intermediate node similar parent child
relation allowed node present convert
equivalent alternating tree
use two operations namely folding unfolding conversions corresponding
every edge stack update list used conversions tree consider
two nodes vq vr similar type connected edge er
edges e ek emanate er
folding node suppose vq vr nodes folding vr performed
follows
source edges e ek changed vr vq costs updated
ce ei ce ei ce er cv vr k cost sum
old cost cost edge points source ei triplet
hvr cv vr ce er pushed update list ei k
edge er along node vr removed vq
folding node suppose vq vr nodes folding vr performed follows
source edges e ek changed vr vq one edges among
e ek suppose ei selected arbitrarily cost updated ce ei
ce ei ce er cv vr k triplet hvr cv vr ce er pushed
update list ei whereas triplet hvr pushed update list ej
j k j
edge er along node vr removed vq
unfolding operation reverse folding operation
nodes works node vq follows
procedure unfold node vq












forall edge ei emanate vq
update list ei empty
hvt c c pop update list ei
exists edge et vq points node vt
create node vt connect vt edge et vq
cv vt c
ce et c
else c
ce et c
end
end



figenerating ordered solutions explicit structures

function convert takes root node tree transforms equivalent
alternating tree recursively
function convert vq









every child vq terminal node
vq parent vp type
apply f old operation vq
end
else
foreach child vr vq vr intermediate node
convert vr
end

function revert takes root node alternating tree converts
original tree recursively
function revert vq







every child vq terminal node
return
perform unf old operation vq
foreach child vr vq
revert vr
end

overall process generating alternative solutions tree follows
tree converted alternating tree convert function
solutions generated asg solutions transformed back
revert function proof correctness presented
c proof correctness
suppose tree two nodes vq vr similar type
connected edge er edges e ek emanate er fold operation
tree generated application
applied vq vr let
f old operation
lemma c context mentioned present claim following two
propositions
proposition c set solutions node vq generated set
node v applying unfold operation v solutions
solutions
q
q

contains node v exists soluproposition c every solution sm
q


tion sm generated sm applying unfold vq

proof proposition c present proof following cases consider
solution sm contains node vq


fighosh sharma chakrabarti dasgupta

vq vr nodes two cases possible
vr absent sm since fold operation modifies edge er
therefore
edges vq present


present solution set remain unchanged
application unfold operation
vr present sm since k distinct edges emanating vr
let one edges say ei present sm prove
application unfold operation
solution sm


generate sm application fold operation node vr modifies source

cost edge ei vr vq ce ei ce ei ce er cv vr
solution edge e present
suppose sm




subtree rooted vq remaining parts sm
identical


clearly sm exists solution application
generates
unfold operation vq sm

b vq vr nodes since vq node sm contain
edges emanate vq therefore edge er vr present
following holds
sm consider solution sm


vq present sm

subtrees rooted children vq vr sm identical

subtrees rooted children vq sm
identical
subtree rooted vq remaining parts sm


exists solution application unfold operation v
clearly sm
q


sm generates sm


solution sm
contain node vq valid solution
well



proof proposition c present proof following cases consider
contains node v
solution sm
q

vq vr nodes since vq node exactly one edge ei vq
two cases possible
belong sm
since fold operation modifies
ei modified folding vr
edge er edges vr edges vq
since e modified folding solution
present


sm valid solution
suppose e connects v v
ei modified folding vr

q

generate solution

sm apply unfold operation node vq sm

edge ei replaced edge er connects vq vr ei
connect vr vi argue sm valid solution since



figenerating ordered solutions explicit structures

subtree rooted vi modified sequence folding vr
b unfolding v construct
construct
q



contain
b vq vr nodes since vq node sm
edges emanate vq two types edges emanating
type edges v present
vq
q

vq b type edges added vq folding edges
generate solution
vr apply unfold operation node vq sm
sm sm contain type edges another edge er vq sm vq vr
connected er type edges originated vr argue sm
valid solution since subtree rooted nodes pointed type edges

modified sequence folding vr construct


b unfolding vq construct sm sm


contain node v valid solution
clearly solution sm
q


well



lemma c function convert applied root node tree
alternating tree generated
proof lemma c function convert traverses every intermediate node depth first
manner consider sequence nodes vq vq vqn type vqi
parent vqi n obviously fold operation applied vqi
vqi n words fold operation applied sequence
nodes reverse order folding vqi edges vqi modified
moved vqi n function call convert vq returns edges
vq vqn already moved vq sequence nodes vq vq vqn
flattened therefore every sequence nodes type flattened function
call convert vr returns vr root alternating tree
generated
lemma c function revert applied alternating tree updatelist every edge becomes empty
proof lemma c follows description revert
theorem c tree possible construct alternating
tree function convert set possible solutions generated
order increasing cost applying converting
individual solutions function revert
proof theorem c according lemma c application function convert
alternating tree generated consider intermediate
n
trees generated folding every node let


n since generated



sequence trees







fighosh sharma chakrabarti dasgupta

n according
folding exactly one node
generated unfolding
solutions

lemma c solution revert unfolds every node vq
vq folded convert transforming therefore
generated solutions

lemma c
node according
solution
solutions

references
bonet b geffner h better ao proceedings
th national conference artificial intelligence pp aaai
press
chakrabarti p p searching explicit graphs
applications reduction search artif intell
chakrabarti p p ghose pandey desarkar c increasing search
efficiency multiple heuristics inf process lett
chang c l slagle j r admissible optimal searching
graphs artif intell
chegireddy c r hamacher h w finding k best perfect matchings discrete applied mathematics
chen h xu z j liu z q zhu c composite templates cloth modeling
sketching proceedings ieee computer society conference
computer vision pattern recognition pp ieee computer
society
cormen h stein c rivest r l leiserson c e introduction
nd edition mcgraw hill higher education
darwiche compiling knowledge decomposable negation normal form
proceedings th international joint conference artifical intelligence
pp morgan kaufmann publishers inc
darwiche decomposable negation normal form j acm
dasgupta p sur kolay bhattacharya b vlsi floorplan generation
area optimization graph search vlsi design proceedings
th international conference pp
dechter r mateescu r search spaces graphical artif
intell
ebendt r drechsler r weighted search unifying view application
artificial intelligence
elliott p extracting k best solutions valued acyclic graph
masters thesis massachusetts institute technology
elliott p williams b dnnf belief state estimation proceedings
st national conference artificial intelligence pp aaai
press


figenerating ordered solutions explicit structures

eppstein finding k smallest spanning trees proc nd scandinavian
worksh theory lecture notes computer science pp
springer verlag
eppstein finding k shortest paths siam j comput
flerova n dechter r best solutions graphical st workshop
constraint reasoning graphical structures
flerova n dechter r bucket mini bucket schemes best solutions
graphical gkr workshop ijcai
fromer globerson lp view best map advances
neural information processing systems nips pp
fuxi z ming yanxiang h solution billiard balls puzzle ao
application product development palade v howlett r
jain l eds knowledge intelligent information engineering systems
vol lecture notes computer science pp springer berlin
heidelberg
gogate v dechter r approximate solution sampling counting
spaces cp pp
gu z li j xu b automatic service composition enhanced service
dependency graph web services icws ieee international conference
pp
gu z xu b li j service data correlation modeling application
data driven service composition services computing ieee transactions

gupta p chakrabarti p p ghose towers hanoi generalizations
specializations international journal computer mathematics

hamacher h w queyranne k best solutions combinatorial optimization
annals operations
hansen e zhou r anytime heuristic search j artif intell res jair

hansen e zilberstein lao heuristic search finds
solutions loops artificial intelligence
homem de mello l sanderson graph representation assembly
plans robotics automation ieee transactions
jimenez p torras c efficient searching implicit
graphs cycles artif intell
kleinberg j tardos e design addison wesley longman publishing
co inc boston usa
lang q su graph search discovering composite web services international journal web services


fighosh sharma chakrabarti dasgupta

lawler e l procedure computing k best solutions discrete optimization
application shortest path management science
pp
x dong b tree search web service composition paciia proceedings ieee pacific asia workshop
computational intelligence industrial application pp washington dc
usa ieee computer society
majumdar k generalized multi peg tower hanoi journal
australian mathematical society series b applied mathematics
marinescu r dechter r branch bound solving mixed integer
linear programming cp p
marinescu r dechter r memory intensive branch bound search graphical aaai
marinescu r dechter r best first search integer programming cpaior pp
marinescu r dechter r b best first search graphical
aaai pp
marinescu r dechter r branch bound search combinatorial
optimization graphical artif intell
marinescu r dechter r b memory intensive search combinatorial
optimization graphical artif intell
martelli montanari u additive graphs proceedings
rd international joint conference artificial intelligence san francisco ca usa
morgan kaufmann publishers inc
martelli montanari u optimizing decision trees heuristically guided
search commun acm
mateescu r dechter r multi valued decision diagrams constraint
networks concurrency graphs pp
mateescu r dechter r marinescu r multi valued decision diagrams aomdds graphical j artif intell res jair
mathews h zuker rna secondary structure prediction encyclopedia
genetics genomics proteomics bioinformatics john wiley sons ltd
nilsson efficient finding probable configurations
probabilistic expert systems statistics computing
nilsson n j principles artificial intelligence tioga publishing co
otten l dechter r anytime depth first search combinatorial
optimization socs
pearl j heuristics intelligent search strategies computer solving
addison wesley longman publishing co inc boston usa


figenerating ordered solutions explicit structures

russell norvig p artificial intelligence modern nd edition
edition chap pp prentice hall englewood cliffs nj
shiaa fladmark j thiell b incremental graph
automatic service composition ieee international conference services computing
shin h jeon h b lee k h sophisticated composing
services action dominance relation services computing conference apscc ieee asia pacific pp
subramanian routing dynamic intelligent transportation networks masters thesis virginia technical univ dept civil engineering
sugimoto k katoh n finding k shortest loopless paths
directed network trans information processing soc japan
japanese
szymanski barciszewska z barciszewski j erdmann v ribosomal rna database http biobases ibch poznan pl sdata online database
takkala borndorfer r lobel dealing additional constraints
k shortest path proc wm
topkis k shortest path adaptive routing communications
networks trans communications
yan xu b gu z automatic service composition graph
e commerce technology fifth ieee conference enterprise computing
e commerce e services th ieee conference pp




