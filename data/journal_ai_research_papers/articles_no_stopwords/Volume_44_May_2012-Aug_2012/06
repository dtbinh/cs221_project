Journal Artificial Intelligence Research 44 (2012) 633-708

Submitted 11/11; published 08/12

Logical Difference
Lightweight Description Logic EL
Boris Konev
Michel Ludwig

konev@liverpool.ac.uk
michel.ludwig@liverpool.ac.uk

Department Computer Science
University Liverpool, UK

Dirk Walther

dirk.walther@upm.es

Departamento Inteligencia Artificial, Facultad de Informatica
Universidad Politecnica de Madrid, Spain

Frank Wolter

wolter@liverpool.ac.uk

Department Computer Science
University Liverpool, UK

Abstract
study logic-based approach versioning ontologies. view, ontologies
provide answers queries vocabulary interest. difference
two versions ontology given set queries receive different answers.
investigate approach terminologies given description logic EL extended
role inclusions domain range restrictions three distinct types queries:
subsumption, instance, conjunctive queries. three cases, present polynomialtime algorithms decide whether two terminologies give answers queries
given vocabulary compute succinct representation difference nonempty. present implementation, CEX2, developed algorithms subsumption
instance queries apply distinct versions Snomed CT NCI ontology.

1. Introduction
Terminologies lightweight ontologies used provide common vocabulary
domain interest together descriptions meaning terms built
vocabulary relationships them. used areas medical
informatics, bio-informatics, semantic web capture domain semantics promote interoperability. Terminologies often large complex. example, widely
used medical terminology Snomed CT (Systematized Nomenclature Medicine Clinical
Terms) contains 300 000 term definitions (IHTSDO, 2008). Another example
National Cancer Institute ontology (NCI) consisting 60 000 axioms (Golbeck, Fragaso, Hartel, Hendler, Oberhaler, & Parsia, 2003). Engineering, maintaining,
using terminologies complex laborious task, practically unfeasible
without appropriate tool support. article, focus principled logic-based
approach support terminology versioning.
Dealing multiple versions information unit nothing new computing, version control well established computer technology. Although modern version
control systems provide range operations including support collaborative development, branching, merging, etc., operations extend rely basic operations
c
2012
AI Access Foundation. rights reserved.

fiKonev, Ludwig, Walther, & Wolter

detecting representing differences versions. paper, focus
basic problem versioning.
need versioning support recognised ontology research community
ontology users, large number approaches tools developed.
review currently existing support ontology versioning, distinguish three approaches
describe according difference ontologies compute:
1. versioning based syntactic difference (syntactic diff);
2. versioning based structural difference (structural diff);
3. versioning based logical difference (logical diff).
syntactic diff underlies existing version control systems used software development (Conradi & Westfechtel, 1998) (such as, example, RCS, CVS, SCCS). works
text files represents difference versions blocks text present one
version another, ignoring meta-information document. observed
already work Noy Musen (2002), ontology versioning cannot rely purely
syntactic diff operation since many syntactic differences (e.g., order ontology axioms)
affect semantics ontologies. Therefore, ontology versioning based syntactic
difference essentially limited comparing rather informal change logs (Oliver, Shahar,
Shortliffe, & Musen, 1999).
structural diff extends syntactic diff taking account information
structure ontologies. suggested dealing structured hierarchical documents UML diagrams, database schemas, XML documents (see, e.g.,
Ohst, Welle, & Kelter, 2003, references within). ontologies, main characteristic
structural diff regards structured objects, is-a taxonomy (Noy & Musen, 2002), set RDF triplets (Klein, Fensel, Kiryakov, & Ognyanov,
2002) set class defining axioms (Redmond, Smith, Drummond, & Tudorache, 2008;
Jimenez-Ruiz, Cuenca Grau, Horrocks, & Llavori, 2011). Changes ontologies mostly
described terms structural operations, example, adding deleting class, extending class, renaming slots, moving class one place hierarchy another,
adding deleting axiom, class renaming, etc.; sometimes basic logical properties
ontologies, e.g., equivalence different structural forms concepts, taken
account (Palma, Haase, Corcho, & Gomez-Perez, 2009; Jimenez-Ruiz et al., 2011). Ontology versioning based structural diff form available current ontology
editors ontology management systems either natively plugins (Noy & Musen,
2002; Klein et al., 2002; Jimenez-Ruiz et al., 2011).
Though helpful, structural diff still deficiency unambiguous semantic foundation syntax dependent. Moreover, tailored towards
applications ontologies based induced concept hierarchy (or mild
extension it), capture modern applications ontology based data access (OBDA) (Poggi, Lembo, Calvanese, Giacomo, Lenzerini, & Rosati, 2008; Lutz, Toman,
& Wolter, 2009) ontologies used provide user-oriented view data
634

fiThe Logical Difference Lightweight Description Logic EL

make accessible via queries formulated solely language ontology without
knowledge actual structure data.1
logical diff recently introduced (Konev, Walther, & Wolter, 2008;
Kontchakov, Wolter, & Zakharyaschev, 2010) completely abstracts representation ontology. Here, ontology regarded set axioms formulated logical
language formal unambiguous semantics. view, ontologies provide
answers queries vocabulary interest. Typical queries include subsumption
queries concepts and, ontology used access instance data, instance
conjunctive queries. logical diff motivated view. two versions ontology
give answers class queries relevant application domain, may
deemed difference regardless syntactic structural form; queries
producing different answers versions may considered characterisation
difference itself. way one can, example, define exactly differences visible
querying instance data exactly differences expressed subsumptions
concepts.
make approach work practice, least two problems addressed:
ontology languages classes queries computational complexity
even detecting two ontology versions differ certain vocabulary least
one exponential harder ontology classification sometimes undecidable;
even computational complexity increase, searching differences
ontologies within certain vocabulary requires techniques different used standard reasoning (Lutz, Walther, & Wolter, 2007; Lutz
& Wolter, 2010; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008).
set queries producing different answers two versions empty,
typically infinite and, therefore, cannot presented user such. Thus,
techniques succinctly characterise elements present user
required.
aim paper provide first steps toward solutions problems
terminologies (aka classical TBoxes) given description logic ELHr extends
description logic EL underlying OWL 2 EL profile role inclusions domain
range restrictions (Baader, Brandt, & Lutz, 2008). main contributions follows:
1. argued syntax-dependence regarded advantage rather deficiency
context versioning (Goncalves, Parsia, & Sattler, 2011; Jimenez-Ruiz et al., 2011). example, Jimenez-Ruiz et al. argue logical equivalence ontologies permissive: even
O0 strongest assumption semantic point view conflicts may still exist. might
result presence incompatible annotations (statements act comments carry
logical meaning), mismatch modelling styles; example, may written simple language
OWL 2 EL profile contain = (A v B u C), O0 may contain = (B C v A).
Even though , explicit use negation disjunction means O0 outside EL profile.
agree Jimenez-Ruiz et al. Goncalves et al. various applications
structural rather logical difference appropriate. Even syntactic diff applications ontology
versioning. practice, see logic-based approaches complementary structural approaches.
interesting analysis NCI versions taking account structural logical differences given
work Goncalves et al.

635

fiKonev, Ludwig, Walther, & Wolter

subsumption, instance, conjunctive queries, present polynomial-time algorithms
decide whether two ELHr -terminologies give different answers query
respective class queries given signature concept role names (note
use terms signature vocabulary synonymously).
Besides polynomial-time decision procedure detecting differences, develop
succinct presentation (typically infinite) difference. presentation computed polynomial time well.
present two different types polynomial-time algorithms deciding existence
logical differences terminologies computing succinct representation
it: first type algorithms conceptually transparent keeps two
input terminologies separate reduces (a substantial part of) difference problem
instance checking problem ABox. algorithms are, however, sufficiently
efficient large inputs. example, substantial performance problems occur
computing differences versions Snomed CT joint signature since
constructed ABox typically quadratic size input terminologies. second
variant algorithms, based dynamic programming, efficient practice.
developed detail acyclic ELHr -terminologies.
present implementation, CEX2, based second type algorithms
computes succinct representation difference acyclic ELHr -terminologies
concept instance query case. addition, prototype implementation
ABox-based algorithm used estimate efficiency.
important tool investigation, present description logics, ELran
ELran,u,u , capture subsumption differences instance query difference ELHr -terminologies. result presented general ELHr -TBoxes can,
therefore, exploited future work versioning general ELHr -TBoxes.
present experiments using CEX2 illustrate efficiency algorithms
potential applications terminologies Snomed CT NCI. plugin Protege
discussed. CEX2 extends functionality first version CEX (Konev, Walther, &
Wolter, 2008) OwlDiff plugin (Kremen, Smd, & Kouba, 2011), implements
algorithms developed Konev, Walther, Wolter. Based Snomed CT,
investigate performance ABox-based algorithms practice.
paper based on, extends work Konev, Walther, Wolter (2008).
improve readability, number proofs deferred appendix.

2. Preliminaries
Let NC , NR , NI countably infinite mutually disjoint sets concept names, role
names, individual names. EL-concepts C built according rule
C :=



|

>

| C uD

|

r.C,

NC , r NR , C, range EL-concepts. set ELHr -inclusions
consists
concept inclusions C v D, ran(r) v ran(r) u C v D,
636

fiThe Logical Difference Lightweight Description Logic EL

concept equations C D,
role inclusions r v s,
C EL-concepts r, NR . ELHr -TBox finite set ELHr inclusions. Inclusions form ran(r) v ran(r)uC v referred range
restrictions, inclusions form r.> v referred domain restrictions.
ELHr -TBox called ELHr -terminology concept inclusions equations
form
v C C,
ran(r) v C,
r.> v C,
NC r NR , C EL-concept C 6= >, C 6= > u >, etc.,
concept name occurs left-hand side. Note that, concept inclusions
form r.> v C, concept r.> often denoted dom(r). terminology acyclic
(or unfoldable) process exhaustively substituting definitions place defined
concept names terminates. example, terminology contains concept inclusion
Mother v hasMother.Mother
acyclic. Formally, consider relation concept names setting
B exists ELHr -inclusion form C v C B
occurs C. terminology acyclic transitive closure +
irreflexive.
description logic, instance data represented ABox assertions form >(a),
A(a) r(a, b), a, b NI , NC , r NR . ABox non-empty finite
set ABox-assertions. said singleton ABox contains exactly one ABox
assertion. obj(A) denote set individual names A. knowledge base K (KB)
pair (T , A) consisting TBox ABox A. Assertions form C(a)
r(a, b), a, b NI , C EL-concept, r NR , called instance assertions. Note
instance assertions form C(a) C concept name C = >
occur ABoxes.
semantics ELHr given interpretations = (I , ), domain
non-empty set, function mapping concept name subset AI
, role name r binary relation rI , individual name
element aI . extension C concept C defined induction follows:
>I
(C u D)I
(r.C)I
ran(r)I

:=
:=
:=
:=


C DI
{d | e C : (d, e) rI }
{d | e : (e, d) rI }

satisfies
concept inclusion C v D, symbols |= C v D, C DI ;
637

fiKonev, Ludwig, Walther, & Wolter

concept equation C D, symbols |= C D, C = DI ;
role inclusion r v s, symbols |= r v s, rI sI ;
assertion C(a), symbols |= C(a), aI C ,
assertion r(a, b), symbols |= r(a, b), (aI , bI ) rI .
say interpretation model TBox (ABox A) |=
( A). ELHr -inclusion follows TBox every model model
, symbols |= . |= used denote follows empty TBox
sometimes write r vT |= r v s. instance assertion follows KB (T , A)
every individual name occurs occurs obj(A) every model (T , A)
model , symbols (T , A) |= . important ways querying ELHr -TBoxes
KBs
subsumption: check whether |= , ELHr -inclusion TBox ,
instance checking: check whether (T , A) |= , instance assertion KB
(T , A),
conjunctive query answering.
define latter, call first-order formula q(~x) conjunctive query form
~y (~x, ~y ), conjunction expressions A(t), NC , r(t1 , t2 ), r NR ,
t, t1 , t2 drawn NI sequences variables ~x ~y . Let ~x = x1 , . . . , xk . Let
interpretation mapping ~x ~y . Set (a) = aI obj(A).
say vector ~a = a1 , . . . , ak -match q(~x) satisfies following
conditions:
(t) AI every conjunct A(t) ;
((t1 ), (t2 )) rI every conjunct r(t1 , t2 ) ;
(xi ) = aIi 1 k.
set |= q[~a] if, if, exists ~a -match q(~x) I. Let
(T , A) KB. sequence ~a members obj(A) certain answer q(~x)
KB (T , A), symbols (T , A) |= q(~a), |= q[~a], every model (T , A).
three types querying ELHr -TBoxes studied extensively. complexity
subsumption instance checking PTime (Baader et al., 2008). combined
complexity answering Boolean conjunctive queries (i.e., deciding whether (T , A) |= q
conjunctive query q without free variables) coNP-complete (Rosati, 2007) data
complexity PTime (Rosati, 2007). Information reasoners subsumption checking
ELHr found work Delaitre Kazakov (2009), Kazakov, Krotzsch,
Simancik (2011), Mendez Suntisrivaraporn (2009). Lutz et al. (2009) present
approach efficient conjunctive query answering ELHr .
638

fiThe Logical Difference Lightweight Description Logic EL

2.1 Normal Form
often convenient consider normalised ELHr -terminologies. Let ELHr terminology concept name. Call
primitive NC \ ({A NC | C } {A NC | v C });
pseudo-primitive NC \ {A NC | C }.
Note concept names occur primitive pseudo-primitive .
Call concept name non-conjunctive pseudo-primitive exists
concept form r.C r.C . Otherwise, called conjunctive
. Thus, conjunctive if, if, exists concept name B
B exist C1 , . . . , Cn , n 2, C1 u u Cn . Let X
finite set
concepts. say concept F conjunction concepts X F
form DX D. X called conjunct F and, concept name,
called atomic conjunct F . sometimes write F instead X.
ELHr -terminology normalised consists ELHr -inclusions following
form:
r.B, F , A, B concept names F non-empty conjunction
concept names every conjunct B 0 F non-conjunctive ;
E v r.B, E v r.>, E v F , B concept name, E either concept
name, form s.>, ran(s), F non-empty conjunction concept
names every conjunct B 0 F non-conjunctive .
following lemma shows, ELHr -terminology normalised yielding
model conservative extension original terminology.
Lemma 1. every ELHr -terminology , one construct polynomial time normalised terminology 0 polynomial size |T | sig(T ) sig(T 0 ), 0 |= ,
every model exists model J 0 = J X = X J
every X sig(T ). Moreover, 0 acyclic acyclic.
Normalised terminologies sense defined minor modification normalised terminologies defined Baader (2003). straightforward extension
proof given Baader provided appendix.
2.2 Canonical Model
define canonical model, IK , ELHr -knowledge bases K. IK constructed
polynomial time gives answers instance queries K; i.e., IK |= if,
if, K |= , instance assertion . construction similar canonical
model introduced Lutz et al. (2009).
Let sub(T ) denote set subconcepts concepts used , rol(T ) set
role names occurring . Take fresh individual names xran(r),D every r rol(T )
sub(T ) set
NIaux := {xran(r),D | r rol(T ) sub(T )}.
639

fiKonev, Ludwig, Walther, & Wolter

define generating interpretation WK KB K = (T , A) follows:
W K
AW K
r WK

aWK

:= obj(A) NIaux ;
:= {a obj(A) | K |= A(a)} {xran(r),D NIaux | |= ran(r) u v A};
:= {(a, b) obj(A) obj(A) | s(a, b) |= v r}
{(a, xran(s),D ) obj(A) NIaux | K |= s.D(a) |= v r}
{(xran(s),D , xran(s0 ),D0 ) NIaux NIaux | |= ran(s) u v s0 .D0 , |= s0 v r};
:= a, obj(A).

path WK finite sequence d0 r1 d1 rn dn , n 0, d0 obj(A) and, < n,
WK
(di , di+1 ) ri+1
. use paths(WK ) denote set paths WK . p paths(WK ),
tail(p) denotes last element dn p.
canonical model IK knowledge base K restriction WK domain
elements path WK tail d. following result summarises
main properties IK .
Theorem 2. Let K = (T , A) ELHr -KB.
1. IK model K;
2. IK computed polynomial time size K;
3. xran(s),D IK obj(A), C EL-concept C = ran(r),
K |= C(a) if, if, aIK C IK .
|= ran(s) u v C if, if, xran(s),D C IK .
proof Theorem 2 given appendix. follows Point 3 IK gives
answers instance queries K itself.

3. Logical Difference
section, introduce three notions logical difference TBoxes
derived notion -inseparability. Intuitively, logical difference two TBoxes T1
T2 set relevant formulas T1 |= T2 6|= vice
versa. course, formulas relevant depends application domain. many
applications subsumptions concepts relevant, TBoxes employed
access instance data, answers instance even conjunctive queries relevant
well. addition, applications large-scale terminologies Snomed CT
NCI typically small subset vocabulary terminology relevant.
Thus, meaningful notion logical difference take account formulas
given certain signature interest, signature subset NC NR .
Given concept, role, concept inclusion, TBox, ABox, query E, denote sig(E)
signature E, is, set concept role names occurring it. call E
-concept, -concept inclusion, -TBox, -ABox, -query, respectively, sig(E) .
Similarly, EL -concept C EL-concept sig(C) ELHr -inclusion
ELHr -inclusion sig() .
first notion logical difference introduce corresponds applications
subsumptions relevant.
640

fiThe Logical Difference Lightweight Description Logic EL

Definition 3 (-concept difference). -concept difference ELHr -TBoxes T1
T2 set cDiff (T1 , T2 ) ELHr -inclusions T1 |= T2 6|= .
say T1 T2 -concept inseparable, symbols T1 C
T2 , cDiff (T1 , T2 ) =
cDiff (T2 , T1 ) = .
-concept inseparability T1 T2 means T1 replaced T2
application concerned ELHr -inclusions.2 following example
shows, however, -concept inseparable terminologies give different answers
instance query data.
Example 4. Let T1 = {ran(r) v A1 , ran(s) v A2 , B A1 u A2 }, T2 = , = {r, s, B}.
One show T1 T2 -concept inseparable. However, -ABox =
{r(a, c), s(b, c)} (T1 , A) |= B(c) (T2 , A) 6|= B(c).
take account differences TBoxes relevant TBoxes
used access instance data, consider -instance difference.
Definition 5 (-instance difference). -instance difference TBoxes T1 T2
set iDiff (T1 , T2 ) pairs form (A, ), -ABox -instance
assertion (T1 , A) |= (T2 , A) 6|= . say T1 T2 -instance
inseparable, symbols T1 T2 , iDiff (T1 , T2 ) = iDiff (T2 , T1 ) = .
contrast ELHr , shown Lutz Wolter (2010) EL-TBoxes
difference -concept inseparability -instance inseparability.
paper extend result ELHr -TBoxes without range restrictions (the proof
given Corollary 37):
Theorem 6. Let T1 T2 ELHr -TBoxes without range restrictions signature.

T1 C
T2 if, if, T1 T2 .
Sometimes, instance queries sufficiently expressive, conjunctive queries
employed. case, following notion difference appropriate.
Definition 7 (-query-difference). -query difference TBoxes T1 T2
set qDiff (T1 , T2 ) pairs form (A, q(~a)), -ABox, q(~x) conjunctive query, ~a tuple individual names (T1 , A) |= q(~a)
(T2 , A) 6|= q(~a). say T1 T2 -query inseparable, symbols T1 q ,
qDiff (T1 , T2 ) = qDiff (T2 , T1 ) = .
observed Lutz Wolter (2010) already, even EL -instance inseparability
imply -query inseparability. following simple example.
Example 8. Let T1 = {A v r.B}, T2 = , = {A, B}. T1 T2 -instance
inseparable, -query inseparable. Consider -ABox = {A(a)}
-query q = x.B(x). (T1 , A) |= q (T2 , A) 6|= q.
2. refer reader conclusion paper brief discussion claim.

641

fiKonev, Ludwig, Walther, & Wolter

shown Lutz Wolter (2010) Example 8 essentially situation
difference -instance inseparability -query inseparability
EL: two notions become equivalent EL universal role admitted instance
queries (e.g., Example 8, conjunctive query x.B(x) corresponds instance query
u.B(a) universal role u). contrast, ELHr subtle differences
instance query case.
Example 9. Let T1 = {A v s.>, v r1 , v r2 }, T2 = {A v r1 .> u r2 .>}, =
{A, r1 , r2 }. T1 T2 -concept -instance inseparable,
-query inseparable. show latter, let = {A(a)} let q = x(r1 (a, x) r2 (a, x)).
(T1 , A) |= q (T2 , A) 6|= q.
seen -concept inseparability imply -instance inseparability
-instance inseparability imply -query inseparability. converse
implications, however, hold:
Lemma 10. ELHr -TBoxes T1 T2 signatures :
T1 q T2



T1 T2



T1 C
T2 .

Proof. first implication follows observation every instance query
regarded conjunctive query. second implication, note first v r
cDiff (T1 , T2 ), ({s(a, b)}, r(a, b)) iDiff (T1 , T2 ). let C v cDiff (T1 , T2 ).
One construct -ABox AC individual EL-concepts D0 :
(T , AC ) |= D0 (a) if, if, |= C v D0 (cf. Lemma 36). Thus (AC , D(a))
iDiff (T1 , T2 ).
introduced three notions difference ELHr -TBoxes, investigate two problems: (i) detect whether difference two ELHr terminologies and, so, (ii) represent differences.
follows assume fresh symbols used normalised form terminologies occur signature compute difference
terminologies. obtain following lemma direct corollary Lemma 1.
Lemma 11. ELHr -terminologies T1 , T2 normalised forms T10 , T20
defined Lemma 1, following hold:
cDiff (T1 , T2 ) = cDiff (T10 , T20 );
iDiff (T1 , T2 ) = iDiff (T10 , T20 );
qDiff (T1 , T2 ) = qDiff (T10 , T20 ).
on, unless stated otherwise, consider normalised terminologies only.
642

fiThe Logical Difference Lightweight Description Logic EL

4. Case EL-Terminologies
investigating logical difference ELHr -terminologies, illustrate main
ideas behind proofs considering -concept difference EL-terminologies.
EL-terminology ELHr -terminology consisting EL-inclusions only, is, concept
inclusions form v C concept equations form C. start
observation even acyclic EL-terminologies T1 T2 cDiff (T1 , T2 )
contains inclusions least exponential size only. Thus, searching witness
inclusions cDiff (T1 , T2 ), one deal case witness inclusions
least exponential size.
Example 12. Consider
T1 = {A0 v B0 , A1 Bn } {Bi+1 r.Bi u s.Bi | 0 < n}
T2 = {A1 v F0 } {Fi v r.Fi+1 u s.Fi+1 | 0 < n}
= {A0 , A1 , r, s}. concept inclusion cDiff (T1 , T2 ) minimal size given
Cn v A1 ,
C0 = A0 Ci+1 = r.Ci u s.Ci , 0.
Clearly, Cn exponential size. Note, however, use structure sharing define
size Cn number subconcepts, Cn polynomial size.
derive basic properties EL-terminologies using sequent calculus.
4.1 Proof System EL
derive basic properties EL Gentzen-style sequent calculus presented Hofmann (2005); see Figure 1. calculus operates sequents form C v D,
C, EL-concepts; symbol v treated syntactic separator. derivation
(or, equivalently, proof ) sequent C v finite rooted tree whose nodes labelled
sequents, whose root labelled C v D, whose leaves labelled axioms
(instances Ax AxTop) whose internal nodes labelled result
application one inference rules labels children. length
derivation number rule applications derivation.
Example 13. Let = {A B1 uB2 , F v B1 }. derivation sequent r.(F uB2 ) v
r.A shown below. root derivation labelled r.(F u B2 ) v r.A
two leaves B1 v B1 B2 v B2 , respectively.
(Ax)

B1 v B1
(PDefL)
(Ax)
F v B1
B2 v B2
(AndL1)
(AndL2)
F u B2 v B1
F u B2 v B2
(AndR)
F u B2 v B1 u B2
(DefR)
F u B2 v
(Ex)
r.(F u B2 ) v r.A
643

fiKonev, Ludwig, Walther, & Wolter

CvC

(Ax)

Cv>

(AxTop)

CvE
(AndL1)
C uD

CvE CvD
(AndR)
C vDuE
CA v
(DefL)
AvD

CvD
(Ex)
r.C v r.D

v CA
(DefR)
DvA

CA v
(PDefL)
AvD

DvE
(AndL2)
C uD

CA

v CA

Figure 1: Gentzen-style proof system EL-terminologies.
Notice basic calculus Hofmann (2005) considers EL without constant >
terminologies without concept inclusions. take care >, added
rule (AxTop), (PDefL) rule representing inclusions form v C. Cutelimination, completeness, correctness shown straightforward extension
proof given Hofmann.
terminology concepts C, D, write ` C v if, if, exists
proof C v calculus Figure 1.
Theorem 14 (Hofmann). EL-terminologies concepts C, D, holds
|= C v if, if, ` C v D.
apply calculus derive description syntactic form concepts C
|= C v D, non-conjunctive .
Lemma 15. Let normalised EL-terminology, r role name, concept name
EL-concept.
1. Assume
|=

l

Ai u

1in

l

rj .Cj v A,

1jm

pseudo-primitive , Ai concept names 1 n, Cj ELconcepts 1 j m, m, n 0. exists Ai , 1 n,
|= Ai v A.
2. Assume
|=

l
1in

l

Ai u

rj .Cj v r.D,

1jm

Ai concept names 1 n, Cj EL-concepts 1 j m,
m, n 0.
exists Ai , 1 n, |= Ai v r.D
exists rj , 1 j m, rj = r |= Cj v D.
644

fiThe Logical Difference Lightweight Description Logic EL



Proof. use Theorem 14. First, prove Point 1. Let C = 1in Ai u 1jm rj .Cj
assume |= C v A, pseudo-primitive . Let proof C v A.
Note that, since pseudo-primitive (and concept name), inspecting form
conclusions inference rules, one see root derivation
derived either Ax, AndL1, AndL2, DefL, PDefL. show
exists Ai , 1 n, |= Ai v induction n + m, i.e.
number conjuncts C. easy see n + 1 6|= > v definition
terminologies .
base case n + = 1 trivial: root derived one
Ax, DefL, PDefL; so, conclude C = A1 ; i.e. n = 1, = 0, set
Ai = A1 .
Assume n + > 1. root derived either AndL1
AndL2. cases, premise used application either inference rule
sequent C 0 v either C = C 0 u C = u C 0 EL-concept D.
Thus, C 0 contains less conjuncts C (but still least one). conclude
|= C 0 v holds Theorem 14. applying induction hypothesis, hence
exists concept name Ai conjunct C 0 |= Ai v A. Finally, still
note Ai conjunct C.


prove Point 2. Let C = 1in Ai u 1jm rj .Cj assume |= C v r.D.
Let proof C v r.D. Note due form right-hand side sequent
C v r.D, rule used derive root one Ax, AndL1,
AndL2, DefL, PDefL, Ex. prove either exists Ai , 1 n,
|= Ai v r.D, exists rj , 1 j m, rj = r |= Cj v
induction n + again. Similarly above, n + 1.
n + = 1, rule used derive root one Ax, DefL,
PDefL, Ex. two subcases:
root derived DefL PDefL: n = 1, = 0 C = A1 ; i.e.
|= Ai v r.D Ai = A1 .
root derived Ax Ex: n = 0, = 1, C = r1 .C1 ,
r1 = r. C1 = D, obviously |= C1 v holds. Otherwise, rule Ex
used derive root ` C1 v holds, implies |= C1 v D.
Thus, case, rj = r |= Cj v holds j = 1.
case n+m > 1 proved induction analogously proof Point 1 above.
apply Lemma 15 elements cDiff (T1 , T2 ).
Theorem 16 (Primitive witness EL). Let T1 T2 EL-terminologies
signature. cDiff (T1 , T2 ), either C v v member cDiff (T1 , T2 ),
sig() concept name C, EL-concepts occurring .
Proof. Let = C v cDiff (T1 , T2 ). proof induction construction
D. 6= > T2 |= C v >. = D1 u D2 , one C v Di , = 1, 2,
cDiff (T1 , T2 ) apply induction hypothesis. = r.D1 then, Lemma 15,
645

fiKonev, Ludwig, Walther, & Wolter

either (i) exists conjunct C, concept name, T1 |= v D, (ii)
exists conjunct r.C1 C T1 |= C1 v D1 .
case (i) follows T2 6|= v otherwise T2 |= C v C v 6
cDiff (T1 , T2 ) due |= C v A. Hence, v cDiff (T1 , T2 ).
Finally, case (ii) obtain T2 6|= C1 v D1 otherwise |= C v r.C1 , T2 |= r.C1 v
C v 6 cDiff (T1 , T2 ) again. Thus, C1 v D1 cDiff (T1 , T2 ) apply
induction hypothesis.
Theorem 16, every inclusion C v -concept difference T1 T2 contains basic witness inclusion concept name either right-hand side
left-hand side. define
set left-hand -concept difference witnesses, cWtnlhs
(T1 , T2 ), set
NC exists concept v cDiff (T1 , T2 )
set right-hand -concept difference witnesses, cWtnrhs
(T1 , T2 ), set
NC exists concept C C v cDiff (T1 , T2 ).
rhs
regard concept names cWtnlhs
(T1 , T2 ) cWtn (T1 , T2 ) succinct and,
certain sense, complete representation -concept difference T1 T2
define set -concept difference witnesses
rhs
cWtn (T1 , T2 ) = (cWtnlhs
(T1 , T2 ), cWtn (T1 , T2 )).

follows, first present polytime algorithm computing cWtnrhs
(T1 , T2 ). polytime algorithm computing cWtnlhs
(T
,

)

already

given

Lutz
Wolter (2010)
1 2

(for EL-TBoxes). briefly present since extension developed consider ELHr -terminologies. algorithms together decide -concept inseparability since,
Theorem 16, T1 T2 -concept inseparable if, if, cWtn (T1 , T2 ) =
cWtn (T2 , T1 ) = (, ).
4.2 Computing cWtnrhs
(T1 , T2 )
Let assume want decide whether cWtnrhs
(T1 , T2 ). Thus, want
decide whether exists -concept C T1 |= C v T2 6|= C v A.
general strategy follows. Let
noimplyT2 , (A) = {C | T2 6|= C v A, C EL -concept}.
aim algorithm checks whether noimplyT2 , (A) contains C T1 |=
C v A. two sets C concepts call C cover C
exists C C |= C v D. Thus, C noimplyT2 , (A) cover
noimplyT2 , (A) noimplyT2 , (A) exists C C |= C v D.
Note C cover noimplyT2 , (A), exists -concept C
C v cDiff (T1 , T2 ) if, if, exists C C T1 |= C v A.
Thus reduced original problem construction appropriate cover C
deciding subsumption problem T1 |= C v A, C C. Unfortunately, general,
finite cover exists. following example illustrates situation.
646

fiThe Logical Difference Lightweight Description Logic EL

Example 17. (1) Let = {A, B, r} T2 = . noimplyT2 , (A) contains concepts atomic conjunct. Clearly, noimplyT2 , (A) contains
finite cover.
(2) Let 0 = {A, B, r} T20 = {A r.A}. noimplyT20 ,0 (A) contains
0 \ {A}-concepts contains finite cover.
(3) Let 00 = {A, B1 , B2 } T200 = {A B1 u B2 }. {B1 , B2 } cover
noimplyT200 ,00 (A).
consequence, instead directly constructing cover noimplyT2 , (A), first
construct transparent small covers
noimplyT2 , (A) {C | depth(C) n},
n 0, depth(C) role-depth C; i.e., number nestings existential
restrictions C.3 covers denoted noimplynT2 , (A), n 0, singleton
sets non-conjunctive T2 finite sets containing k concepts
B1 u uBk T2 . Based sequence, present two distinct algorithms computing
cWtnrhs
(T1 , T2 ):
1. encode infinite sequence noimplynT2 , (A), n 0, polynomial-size ABox
AT2 , . way obtain reduction original problem instance
checking problem knowledge base (T1 , AT2 , ). certain sense, ABox
AT2 , encodes (in general infinite) cover noimplyT2 , (A).
2. employ terminology T1 dynamic programming approach decide
concepts noimplynT2 , (A) relevant deciding whether cWtnrhs
(T1 , T2 ).
Although less transparent, large terminologies latter approach considerably
efficient. develop acyclic terminologies.
EL-terminology , concept name signature , set
pre
(A) = {B | |= B v A}.
finite covers noimplynT2 , (A), n 0, defined Figure 2. n = 0,
set noimplynT2 , (A) consists concepts without role names. distinguish conjunctive non-conjunctive A. Note non-conjunctive, noimplynT2 , (A)
singleton set. Example 17 (3) shows always case conjunctive A. n + 1, distinguish pseudo-primitive concept names, conjunctive
concept names, definition form r.C. Again, nonn
conjunctive A, noimplyn+1
T2 , (A) singleton set. Note concepts covers
{C | depth(C) n, C EL -concept}, n 0. illustrate definitions using
EL-terminologies Example 17.
Example 18. (1) Let = {A, B, r} T2 = . B non-conjunctive T2
noimply0T2 , (A) = {B} noimply0T2 , (B) = {A}. B pseudo-primitive
T2 , noimply1T2 , (A) = {B u r.(A u B)} noimply1T2 , (B) = {A u r.(A u B)}.
3. precisely depth(A) = 0, depth(C1 u C2 ) = max{depth(C1 ), depth(C2 )}, depth(r.D) =
depth(D) + 1.

647

fiKonev, Ludwig, Walther, & Wolter

Set, inductively,
all0 =

l

A0

l

alln+1
=


A0

A0 u

A0

l

s.alln .



Define noimply0T2 , (A) follows:
non-conjunctive T2 ,
l

noimply0T2 , (A) = {

A0 };

A0 \pre
(A)
2

conjunctive F T2 ,
[

noimply0T2 , (A) =

noimply0T2 , (B);

BF

define, inductively, noimplyn+1
T2 , (A)
pseudo-primitive T2 ,
l

noimplyn+1
T2 , (A) = {

A0 u

A0 (\pre
(A))

l

s.alln }.



2

conjunctive F T2 ,
noimplyn+1
T2 , (A) =

[

noimplyn+1
T2 , (B).

BF

r.B T2 ,
n+1
noimplyn+1
T2 , (A) = {C,T2 },
n+1
=(
C,T
2

l

A0 u

A0 (\pre
T2 (A))

l

l

s.alln u

r.E).

r
Enoimplyn


r6=s

2 ,

(B)

Figure 2: Definition noimplynT2 , (A)

(2) Let 0 = {A, B, r} T20 = {A r.A}. B non-conjunctive T20
noimply0T 0 ,0 (A) = {B} noimply0T 0 ,0 (B) = {A}. B pseudo-primitive T20
2

2

noimply1T2 , (B) = {A u r.(A u B)}. r.A T20 noimplyT20 ,0 (A) = {B u r.B}.
T200

(3) Let 00 = {A, B1 , B2 } T200 = {A B1 u B2 }. B1 B2 non-conjunctive
noimply0T 00 ,00 (B1 ) = {B2 } noimply0T 00 ,00 (B2 ) = {B1 }. conjunctive T200
2

2

648

fiThe Logical Difference Lightweight Description Logic EL

and, definition, noimply0T 00 ,00 (A) = {B1 , B2 }. Since contain role names,
2

noimply0T 00 ,00 (X) = noimplynT 00 ,00 (X), X {A, B1 , B2 } n > 0.
2

2

following lemma shows correctness definition noimplynT2 , (A).
Lemma 19. Let T2 normalised EL-terminology, signature, NC .
noimplynT2 , (A) cover noimplyT2 , (A) {C | depth(C) n}. Namely, n 0,
C1. T2 6|= C v A, C noimplynT2 , (A).
C2. EL -concepts n = depth(D), T2 6|= v A, |= C v
C noimplynT2 , (A).

particular, n0 noimplynT2 , (A) cover noimplyT2 , (A).
Proof.d C1. Assume first pseudo-primitive T2 . noimplynT2 , (A) consists
C = A0 (\pre (A)) A0 u F , F (possibly empty) conjunction concepts
T2

form s.Fi . Lemma 15, T2 6|= C v atomic conjuncts C
\ pre
T2 (A).
prove C1 concept names pseudo-primitive
T2 . proof

induction n. n = 0 r.B T2 , assume T2 |= A0 (\pre (A)) A0 v A.
T2

r.B T2 , Lemma 15 must exist A0 \ pre
T2 (A)
0

T2 |= v A. contradicts definition
set preT2 (A)). n = 0
conjunctive F T2 , let C noimplynT2 , (A) = BF noimplynT2 , (B). hence
exists atomic conjunct B F C noimplynT2 , (B). T2 normalised, B
non-conjunctive, i.e. property C1 already proved B. Thus, T2 6|= C v B,
implies T2 6|= C v otherwise T2 |= C v B would hold.
induction step, assume C1 proved n 0.
element noimplyn+1
Let r.B T2 let CTn+1
T2 , (A). Assume
2 ,
n+1
T2 |= CT2 , v A. Lemma 15 two possibilities:

T2 |= A0 (\pre (A)) A0 v r.B. Similarly above, claim follows Lemma 15
T2

fact r.B T2 .
r exists E noimplynT2 , (B) T2 |= E v B. excluded
induction hypothesis.
derived contradiction. case F T2 , conjunctive T2 , considered
analogously case n = 0.
C2. Let n = 0 assume first non-conjunctive. Let -concept
depth(D)d = 0 T2 6|= v A. conjuncts \ pre
T2 (A)
obtain |= A0 \pre (A) A0 v D. assume conjunctive T2 F T2 .
T2

Let -concept depth(D) = 0 T2 6|= v A. T2 6|= v B,
conjunct B F . induction, |= C v (unique B must non-conjunctive)
C noimply0T2 , (B), therefore |= C v C noimply0T2 , (A).
induction step, assume C2 shown n. Let -concept
T2 6|= v depth(D) = n + 1.
649

fiKonev, Ludwig, Walther, & Wolter

(a) Let pseudo-primitive T2 . atomicdconjuncts aredincluded
n
0
\ pre
A0 \pre (A) u s.all .
T2 (A). |= C v follows immediately C =
T2

(b) Let r.B T2 . Let CTn+1
element noimplyn+1
T2 , (A) assume
2 ,
D=

l

l

Eu

EQ0
n+1
Q0 \ pre
T2 (A). Hence, |= CT2 , v
distinguish two cases:

s.D0 .

(s,D0 )Q1



EQ0

E. consider conjunct s.D0 D.

6= r, |= CTn+1
v s.D0 , required.
2 ,
= r, sufficient show exists E noimplynT2 , (B)
|= E v D0 . Suppose exist E. Then, (the
contraposition of) induction hypothesis, T2 |= D0 v B. contradicts
T2 6|= v (as r.B T2 ).
(c) conjunctive T2 F T2 . case analogous case
conjunctive T2 n = 0.
Corollary 20. normalised EL-terminologies T1 T2 NC following
conditions equivalent:
exists EL -concept C T1 |= C v T2 6|= C v A;
exists n 0 C noimplynT2 , (A) T1 |= C v A.
Observe direct application Corollary 20 yield procedure comn
puting cWtnrhs
(T1 , T2 ) gives bound n set noimplyT2 , (A). point
present two ways avoiding problem (as well problem concepts
noimplynT2 , (A) exponential size). Firstly, instead working covers construct ABox encoding covers. contrast concepts, ABoxes admit encoding
structure sharing
cycles so, intuitively, admit polynomial reconstruction
infinite concept n0,Cnoimplyn (A) C.
T2 ,
ABox AT2 , constructed Figure 3, normalised EL-terminology
concept name sig(T ), set

{A}, non-conjunctive
non-conjT (A) =
{B1 , . . . , Bn }, B1 u u Bn
Note construction AT2 , similar construction noimplynT2 , (A).
assertions individual play role concepts alln , n 0,
assertions individuals play role sets noimplynT2 , (A), n 0. fact, one
readily show AT2 , |= C(A ) C noimplynT2 , (A) non-conjunctive
T2 and, conversely, (a involved proof) shows whenever AT2 , |= D(A )
EL-concept D, exist n 0 C noimplynT2 , (A) |= C v D.
illustrate construction AT2 , using EL-terminologies Example 17.
650

fiThe Logical Difference Lightweight Description Logic EL

Let
{A | sig(T2 ) non-conjunctive T2 } { } NI .
set individual names. non-conjunctive T2 , define sets AT2 , (A) assertions
follows
pseudo-primitive T2 ,
AT2 , (A) = {A0 (A ) | A0 \ pre
T2 (A)} {r(A , ) | r },
r.B T2 ,
AT2 , (A) ={A0 (A ) | A0 \ pre
T2 (A)}
{s(A , ) | r 6= }
{r(A , B 0 ) | B 0 non-conjT2 (B), r }
Let
[

AT2 , = { A0 ( ) | A0 } { r( , ) | r }

AT2 , (A)

Asig(T2 )
non-conjunctive T2

Figure 3: Construction AT2 , .
Example 21. (1) Let = {A, B, r} T2 = .
AT2 , = {A(B ), B(A ), r(A , ), r(B , )} ,
= {A( ), B( ), r( , )}.
(2) Let 0 = {A, B, r} T20 = {A r.A}.
AT20 ,0 = {A(B ), B(A ), r(A , ), r(B , 0 )} A0 ,
A0 = {A(0 ), B(0 ), r(0 , 0 )}.
(3) Let 00 = {A, B1 , B2 } T200 = {A B1 u B2 }.
AT200 ,00 = {B1 (B2 ), B2 (B1 )} A00 ,
A00 = {A(00 ), B1 (00 ), B2 (00 )}.
obtain following characterisation cWtnrhs
(T1 , T2 ).
Theorem 22. Let T1 T2 normalised EL-terminologies signature.
following conditions equivalent :
cWtnrhs
(T1 , T2 );
exist n 0 C noimplynT2 , (A) T1 |= C v A;
651

fiKonev, Ludwig, Walther, & Wolter

(T1 , AT2 , ) |= A(B ) B non-conjT2 (A).
equivalence Points 1 2 follows Corollary 20. give detailed
proof equivalence Points 2 3 follows general results
ELHr -terminologies present below.
Example 23. normalised form terminologies Example 12,
0
00
T1 = {A0 v B0 , A1 Bn } {Bi+1 Bi+1
u Bi+1
| 0 < n}
0
00
{Bi+1 r.Bi | 0 < n} {Bi+1 s.Bi | 0 < n}

T2 = {A1 v F0 } {Fi Fi0 u Fi00 | 0 < n}
{Fi0 v r.Fi+1 | 0 < n} {Fi00 v s.Fi+1 | 0 < n},
= {A0 , A1 , r, s}, ABox AT2 , graphically represented
r,
r,

r,
r,

F 00
A0 ,A1

r,
r,


A0 ,A1


F 00

F 0

A0 ,A1

A0 ,A1

1

r,

n

F 00

r,
A0
A1

n

1

r,

A1
A0

F 0

A0 ,A1

0

A0
F 0

0

A0

clear (T1 , AT2 , ) |= A1 (A1 ). fact, (T1 , A) |= A1 (A1 ) holds already
restriction AT2 , individuals {A1 , }.
Theorem 24. EL-terminologies T1 T2 signature , set cWtnrhs
(T1 , T2 )
computed polynomial time.
Proof. suffices give polynomial time algorithm decides every whether
cWtnrhs
(T1 , T2 ). First, ABox AT2 , computed polynomial time
quadratic size T2 . Theorem 22, cWtnrhs
(T1 , T2 ) iff (T1 , AT2 , ) |= A(B )
B non-conjT2 (A), latter condition checked polynomial time since
instance checking polynomial time EL-TBoxes.
Regarding efficiency approach, observe typical terminologies large
, ABox AT2 , indeed quadratic size T2 since \ pre
T2 (A) typically contain
concept names . Thus, large terminologies straightforward
implementation rather elegant algorithm work efficiently one would
store ABox quadratic size instance checking it. refer reader
Table 3 discussion prototype implementation approach applied
modules Snomed CT.
describe second approach computing cWtnrhs
(T1 , T2 ), works
acyclic EL-terminologies. Recall cWtnrhs
(T
,

1 2 ) if, if, ex
ists EL -concept C T2 6|= C v T1 |= C v A. Thus,
6 cWtnrhs
(T1 , T2 ) if, if, every EL -concept C C noimplyT2 , (A)
652

fiThe Logical Difference Lightweight Description Logic EL

procedure NotWitness(E)
E pseudo-primitive
T1


NotWitness(E) := | pre
T1 (E) preT2 (A)
end
(E E1 u u Ek
T1 )
NotWitness(E) := ki=1 NotWitness(Ei )
end
E r.E 0 T1
0 )
r
/ NotWitness(E



NotWitness(E) := | pre
T1 (E) preT2 (A)
else



r.A0 T2



NotWitness(E) := fifi non-conjT2 (A0 ) NotWitness(E 0 )


pre (E) pre (A)
T1
T2
end
end
end procedure
Figure 4: Computation NotWitness(E).
holds C noimplyT1 , (A). approach based computing witness
relation NW ((sig(T1 ) ) NC ) ((sig(T2 ) ) NC ), defined follows:
(E, A) NW

if, if,

() noimplyT2 , (A) noimplyT1 , (E)

Observe cWtnrhs
(T1 , T2 ) if, if, (A, A) 6 NW; hence, compute
set cWtnrhs
(T
,

)


sufficient
compute relation NW. practice, crucial
1 2

compute relation NW rather complement: typical terminologies concept
names unrelated sense subsume other. Thus, relation
NW much smaller complement (which contains, among others, pairs (E, A)
subsume T1 T2 ).
determine pairs (E, A) NW, aim computing every concept name
E sig(T1 ) set concept names sig(T2 ) property () holds.
set called NotWitness(E) computed Figure 4, following
modifications: (1) consider sig(T2 ) non-conjunctive T2
take conjunctive concept names account later. (2) consider fresh concept
name occurring sig(T1 ) sig(T2 ) informally standing possible concepts.
Thus, procedure, NotWitness(E) given Figure 4 recursively associates every
E sig(T1 ) subset set
= {All} { | (sig(T2 ) ), non-conjunctive T2 }
NW relation
((sig(T1 ) ) NC ) (((sig(T2 ) ) NC ) {All}).
653

fiKonev, Ludwig, Walther, & Wolter

Note unlike approach computing cWtnrhs
(T1 , T2 ) presented previously, approach described handle two terminologies separately.
previous approach ABox AT2 , could precomputed T2 re-used
compare T2 terminology T1 , whereas terminologies analysed
simultaneously. prove correctness procedure NotWitness(E).
Lemma 25. normalised acyclic EL-terminologies T1 T2 , signature ,
E sig(T1 ) following holds: NotWitness(E) if, if,
(E, A) NW.
Proof. prove E sig(T1 ) following two conditions
equivalent:
NotWitness(E);
n 0 C noimplynT2 , (A): T1 6|= C v E.

sufficient since n0 noimplynT2 , (A) cover noimplyT2 , (A) (Lemma 19).
E 6 sig(T1 ) claim trivial. E sig(T1 ) proof induction relative
relation T1 sig(T1 ) sig(T1 ) (whose definition found page 637). Note
since considered terminologies acyclic sig(T1 ) finite, relation T1
well-founded.
distinguish possible definitions E T1 . Suppose E pseudoprimitive T1 . , follows definition noimplynT2 , (A)
Lemma 15 exist n 0 C noimplynT2 , (A) T1 |= C v E if,

if, T1 |= B v E B ( \ pre
T2 (A)). Note B ( \ preT2 (A)),
T1 6|= B v E holds if, if, every B , T1 |= B v E implies B pre
T2 (A).
n

Thus, every n C noimplyT2 , (A), T1 6|= C v E if, if, preT1 (E) pre
T2 (A)
if, if, NotWitness(E).
Assume E E1 u u Ek T1 . Then, concept C, T1 6|= C v E if,
if, T1 6|= C v Ei 1 k. Hence, applying induction hypothesis
obtain every n C noimplynT2 , (A), T1 6|= C v E if, if, NotWitness(Ei )
1 k, if, if, NotWitness(E).
Finally, assume E r.E 0 T1 . Notice that, since
/ ( sig(T1 ) sig(T2 )) (in

particular, pseudo-primitive T2 ), preT2 (All) = . Thus, definition
every n 0, noimplynT2 , (All) = {alln }. applying induction hypothesis assume
lemma holds E 0 , implies
/ NotWitness(E 0 ) if, if,
n 0, T1 |= alln v E 0 . distinguish following cases, analogously
case distinction procedure NotWitness(E) (see Figure 4).
r
/ , -concept form s.G, NR , r 6=
T1 6|= s.G v r.E 0 . Similarly, NotWitness(E 0 ), holds every n 0
T1 6|= alln v E 0 . Hence, -concept form s.G, obtain T1 6|= s.G v r.E 0
otherwise T1 |= alln v E 0 would hold n = depth(s.G) (where depth(s.G)
role-depth s.G). So, Lemma 15, two cases analogous case E
pseudo-primitive considered above.
Assume r
/ NotWitness(E 0 ), is, n0 0
n0
0
T1 |= v E .
654

fiThe Logical Difference Lightweight Description Logic EL

First, observe definition form r.A0 T2 ,
+1
unique C noimplynT20,
(A) T1 |= C v E r.alln0 conjunct C (and
non-conjunctive T2 definition set ). definition form r.A0
T2 , n 0 C noimplynT2 , (A), Lemma 15 T1 6|= C v E
n1

0
0
if, if, pre
T1 (E) preT2 (A), and, n > 0, every C noimplyT2 , (A )
0
0
T1 6|= C v .
conclude case r
/ NotWitness(E 0 ), ,
n
n 0, C noimplyT2 , (A), T1 6|= C v E, if, if, r.A0

0

0
T2 , pre
T1 (E) preT2 (A) 0 C noimplyT2 , (A )

0
0

(A0 ) =
S1 6|= C v E . Noticem that, definition 0,0 noimplyT2 ,

0
Bnon-conjT (A0 ) noimplyT2 , (B). Thus, 0 C noimplyT2 , (A ),
2

T1 6|= C 0 v E 0 holds if, if, 0, B non-conjT2 (A0 )
0
0
0
C 0 noimplym
T2 , (B), T1 6|= C v E , if, if, B non-conjT2 (A ), B
0
NotWitness(E ) holds applying induction hypothesis.
Thus, T1 6|= C v E, n 0 C noimplynT2 , (A), if, if,
NotWitness(E).
Corollary 26. Let T1 T2 normalised acyclic EL-terminologies signature.
cWtnrhs
(T1 , T2 ) = { sig(T1 ) | B non-conjT2 (A) B 6 NotWitness(A) }.
Proof. First, observe cWtnrhs
(T1 , T2 ), sig(T1 ) must hold otherwise
-concept C T1 |= C v if, if, |= C v A, thus 6
cWtnrhs
(T1 , T2 ). Now, NC have:
cWtnrhs
(T1 , T2 )

iff

iff

iff
iff

sig(T1 ) (by observation) and, definition,
exists -concept C T2 6|= C v T1 |=
CvA
sig(T1 ) exists B non-conjT2 (A)
-concept C T2 6|= C v B T1 |= C v (as
otherwise T2 |= C v would hold)
sig(T1 ) exists B non-conjT2 (A)
(A, B) 6 NW (by definition relation NW)
sig(T1 ) exists B non-conjT2 (A)
B 6 NotWitness(A), Lemma 25.

acyclic terminologies, obtain alternative proof Theorem 24.
Theorem 27. acyclic EL-terminologies T1 T2 signature , cWtnrhs
(T1 , T2 )
computed polynomial time using procedure NotWitness(E).
Proof. compute set cWtnrhs
(T1 , T2 ), sufficient Corollary 26 compute
sets NotWitness(E) every E sig(T1 ). Assuming T1 T2 classified
result classification cached, NotWitness(E) computed E sig(T1 ),
worst case, time O((|T1 | + |T2 |)3 ).
Example 28. acyclic terminologies T1 , T2 signature Example 23,
NotWitness(A0 ) = {A0 },
655

NotWitness(B0 ) = {A0 }

fiKonev, Ludwig, Walther, & Wolter

concept names X sig(T1 ), NotWitness(X) = . particular A1
/
NotWitness(A1 ), conclude A1 concept difference witness.
4.3 Computing cWtnlhs
(T1 , T2 )
Recall set left-hand -concept difference witnesses, cWtnlhs
(T1 , T2 ), set
NC exists concept C v C cDiff (T1 , T2 ).
tractability computing cWtnlhs
(T1 , T2 ) EL proved Lutz Wolter (2010)
arbitrary EL-TBoxes reduction simulation checking. formulate main
steps employ technique dealing logical difference
ELHr -terminologies.
two interpretations I1 I2 say relation I1 I2
-simulation if, if, following conditions hold:
(d, e) AI1 , e AI2 ;
(d, e) (d, d0 ) rI1 r , exists e0 (d0 , e0 )
(e, e0 ) rI2 .
I1 e I2 write (I1 , d) (I2 , e) exists -simulation relation I1 I2 (d, e) S. checked polynomial time
whether (I1 , d) (I2 , e) various polynomial-time algorithms checking existence
simulations developed (Clarke & Schlingloff, 2001; Crafa, Ranzato, & Tapparo,
2011; van Glabbeek & Ploeger, 2008). Simulations characterise expressive power
EL-concepts following sense.
Lemma 29 (Lutz & Wolter, 2010). Let I1 I2 interpretations, signature, I1 ,
e I2 .
(I1 , d) (I2 , e)



EL -concepts C: C I1 e C I2 .

follows ,
cWtnlhs
(T1 , T2 )



(IK1 , a) 6 (IK2 , a)

Ki = (Ti , A) = {A(a)} IKi canonical model Ki , = 1, 2.
see this, recall Theorem 2 every EL-concept C, C IKi if, if,
(Ti , A) |= C(a). latter condition equivalent Ti |= v C. have, therefore,
proved:
Theorem 30 (Lutz & Wolter, 2010). EL-TBoxes T1 T2 signatures , set
cWtnlhs
(T1 , T2 ) computed polynomial time.
following example illustrates use simulations canonical models
determine cWtnlhs
(T1 , T2 ).
Example 31. Let = {A, r, B1 , B2 }
T1 = {A v r.F0 , F0 v F1 u F2 , F1 v r.B1 , F2 v r.B2 },
T2 = {A v G1 u G2 , G1 v r.G01 , G2 v r.G02 , G01 v r.B1 , G02 v r.B2 }
656

fiThe Logical Difference Lightweight Description Logic EL

check whether cWtnlhs
(T1 , T2 ) consider KBs K1 = (T1 , {A(a)}) K2 =
(T2 , {A(a)}). cWtnlhs
(T1 , T2 ) iff (IK1 , a) 6 (IK2 , a), canonical models
IK1 IK2 K1 K2 , respectively. Illustrations canonical models IK1 IK2
shown below.
xran(r),B1
B1

xran(r),B2
B2

r

xran(r),B1
B1

r

r

r



r

xran(r),G01

xran(r),F0

IK 1

xran(r),B2
B2
xran(r),G02

r

r







IK2

(IK1 , a) 6 (IK2 , a) point xran(r),F0 neither -simulated xran(r),G01
-simulated xran(r),G02 . concept inclusion cDiff (T1 , T2 ) left-hand side
given v r.((r.B1 ) u (r.B2 )).

5. ELHr -Instance Difference
polynomial-time algorithms inseparability logical difference ELHr based
extensions ideas used Section 4 EL. is, however, one important
difference: introduce new logics, ELran ELran,u,u , concept difference
captures exactly instance and, respectively, query difference ELHr . prove analogue Theorem 16 languages and, thereby, instance query difference
ELHr , introduce sequent calculus characterises ELran -consequences
ELHr -terminologies. start investigation instance difference case since
transparent concept difference case (recall EL difference
instance concept difference).
5.1 ELran -Concept Difference
Recall Example 4 showing ELHr -concept inseparability imply -instance
inseparability:
T1 = {ran(r) v A1 , ran(s) v A2 , B A1 u A2 },

T2 = ,

= {r, s, B}.

Notice ABox = {r(a, c), s(b, c)}, exhibiting instance difference
T1 T2 , c range r s. example suggests ran(r) ran(s)
could used complex concepts, kind difference made visible concept
language.
Definition 32 (ELran ). C ran -concepts constructed using following syntax rule
C :=



|

ran(r)

|

C uD

|

r.C,

NC , C, range C ran -concepts r NR . set ELran -inclusions
consists concept inclusions C v role inclusions r v s, C C ran concept, EL-concept, r, NR .
657

fiKonev, Ludwig, Walther, & Wolter

Clearly, every ELHr -inclusion ELran -inclusion. Additionally, ELran -inclusions
concept ran(r) occur everywhere concepts left-hand side inclusions.
gives us additional concept inclusions -concept difference.
Example 33. T1 T2 Example 4, T1 |= ran(r) u ran(s) v B,
T2 6|= ran(r) u ran(s) v B. Thus, using C ran -concept ran(r) u ran(s) simulate
ABox {r(a, c), s(b, c)} Example 4 make -difference could
observed ELHr visible ELran .
show Example 33 generalised arbitrary TBoxes. end,
consider following straightforward generalisation -concept difference differences ELran .
ran
r
Definition 34 (ELran
-difference). EL -difference ELH -TBoxes T1 T2
ran
set cDiff ran
(T1 , T2 ) EL -inclusions T1 |= T2 6|= .

prove equivalence -instance difference ELHr -concept differran
ence ELran , first associate every ABox individual set CA,a
ran
C -concepts. Assume given. Let, inductively, obj(A):
l
l
0,ran
=(
CA,a
A) u (
ran(r));
A(a)A


n+1,ran
=(
CA,a

l

A(a)A

A) u (

r(b,a)A

l

ran(r)) u (

r(b,a)A

l

n,ran
),
r.CA,b

r(a,b)A

set
n,ran
ran
| n 0}
CA,a
= {CA,a
n,ran
(a) fordall n > 0. Moreover, lemma shows
that, intuObserve |= CA,a
ran specific concept |=
ran (a).
itively, infinite conjunction CA,a
CA,a
Conversely, associate ABox C ran -concept. construction straightforward; however, care taken since introduce structure sharing
associate distinct individual names distinct occurrences subconcepts. Given
C ran -concept C, first define path C finite sequence C0 r1 C1 rn Cn ,
C0 = C, n 0, ri+1 .Ci+1 conjunct Ci , 0 < n. use paths(C)
denote set paths C. p paths(C), tail(p) denotes last element
Cn p.
Now, let aran ap p paths(C) individual names set inductively:

AC = { s(ap , aq ) | p, q paths(C); q = p C 0 , C 0 }
{ A(ap ) | conjunct tail(p), p paths(C) }
{ >(ap ) | > conjunct tail(p), p paths(C) }
{ r(aran , ap ) | ran(r) conjunct tail(p), p paths(C) }
Example 35. Let C = (r.(A u ran(v))) u (s.((t.(A u ran(v))) u (t.(B u ran(s)))))
C ran -concept. AC represented graphically follows.
658

fiThe Logical Difference Lightweight Description Logic EL




v

B






r

v

aran



aC

indicate aC aran ; individuals identified paths C. Note
different occurrences u ran(v) C correspond different individuals AC .
Lemma 36. Let ELHr -TBox, ABox, C0 D0 C ran -concepts, let
a0 obj(A).
n,ran
(T , A) |= D0 (a0 ) if, if, exists n 0 |= CA,a
v D0 ;
0

|= C0 v D0 if, if, (T , AC0 ) |= D0 (aC0 ).
Below, employ lemma transfer analogue Theorem 16 ELran
ELHr -instance differences. now, note following consequence:
Corollary 37. two ELHr -TBoxes T1 T2 , cDiff ran
(T1 , T2 ) = if, if,
iDiff (T1 , T2 ) = .
n,ran
Proof. (A, D0 (a0 )) iDiff (T1 , T2 ), exists n 0 CA,a
v
0
ran
D0 cDiff ran
(T
,

).
Conversely,

C
v


cDiff
(T
,

),

(A
,

(a
))

1
2
0
0
1
2
0
C
C


0
0
iDiff (T1 , T2 ).

Note Theorem 6 follows Corollary 37 since ELHr -TBox without
range restrictions |= C v if, if, |= C 0 v D, C 0 obtained C
replacing concept form ran(r) C >.
5.2 Proof System ELHr
Gentzen-style proof system ELHr consists rules given Figures 1 5.
Cut elimination, correctness, completeness proof system shown similarly
corresponding proofs given Hofmann (2005).
Theorem 38. ELHr -terminologies C ran -concepts C D, holds
|= C v if, if, ` C v D.
generalise Lemma 15 ELHr -terminologies.
Lemma 39. Let ELHr -terminology, concept name r.D EL-concept.
Assume
l
l
l
|=
ran(si ) u
Aj u
rk .Ck v r.D,
1il

1jn

1km

Ck , 1 k m, C ran -concepts l, m, n 0. least one following
conditions holds:
659

fiKonev, Ludwig, Walther, & Wolter

r.(C u ran(r)) v
(ExRan)
r.C v
BvD
(Dom)
r.C v
r.> v B
AvD
(Ran)
ran(r) v
s.C v
(Sub)
r.C v

ran(r) v

ran(s) v
(RanSub)
ran(r) v

r v

Figure 5: Additional rules ELHr -terminologies.
(e1) exists rk , 1 k m, |= rk v r |= Ck u ran(rk ) v D;
(e2) exists Aj , 1 j n, |= Aj v r.D;
(e3) exists rk , 1 k m, |= rk .> v r.D;
(e4) exists si , 1 l, |= ran(si ) v r.D.
assume pseudo-primitive
l
l
|=
ran(si ) u
Aj u
1il

1jn

l

rk .Ck v A,

1km

Ck , 1 k m, C ran -concepts l, m, n 0. least one following
conditions holds:
(a1) exists Aj , 1 j n |= Aj v A;
(a2) exists rk , 1 k |= rk .> v A;
(a3) exists si , 1 l |= ran(si ) v A.
Proof. prove first part lemma, second part proved analogously.



Let C = 1il ran(si ) u 1jn Aj u 1km rk .Ck assume |= C v r.D
holds. Then, ` C v r.D Theorem 38, implies exists
derivation sequent C v r.D. proof proceeds induction depth
D, i.e. maximal length path root one leaves D.
Notice l + n + 2, root derived AndL1
AndL2. lemma follows induction hypothesis.
Otherwise, l + n + = 1. Note l + + n = 0 possible since
6|= > v r.D definition terminology . C = A1 C = ran(s1 ), (e2)
(e4), respectively, hold already. remains consider case C = r1 .C1 . Then,
rule used derive root one Ax, Ex, ExRan, Dom
Sub. consider cases one one:
660

fiThe Logical Difference Lightweight Description Logic EL

root derived Ax: considering form inference rule,
r1 = r C1 = D. Hence |= r1 v r |= C1 u ran(r1 ) v D, implies
(e1) holds.
root derived Ex: r1 = r ` C1 v D. Hence, |= r1 v r
|= C1 v holds Theorem 38. Thus, |= C1 u ran(r1 ) v
infer (e1) holds again.
root derived Dom: ` B v r.D r1 .> v B .
Theorem 38, |= B v r.D hence, |= r1 .> v r.D, is, (e3)
holds.
root derived ExRan: obtain ` r1 .(C1 u ran(r1 )) v r.D.
Since sequent r1 .(C1 u ran(r1 )) v r.D derivation shorter length
D, apply induction hypothesis. Hence, either |= r1 .> v r.D,
is, (e3) holds, |= r1 v r |= (C1 u ran(r1 )) u ran(r1 ) v D. Hence (e1)
holds |= C1 u ran(r1 ) v (C1 u ran(r1 )) u ran(r1 ).
root derived Sub: obtain ` s.C1 v r.D r1 v .
induction hypothesis, either |= s.> v r.D, |= v r |=
C1 u ran(s) v D. seen |= r1 .> v r.D, |= r1 v r
|= C1 u ran(r1 ) v D, respectively. Hence (e3) (e1) holds.

prove extension Theorem 16 ELran -consequences ELHr -terminologies.
give rather detailed description simple witness inclusions contained members
cDiff ran
(T1 , T2 ) since going use result analysing concept
difference ELHr .
Theorem 40 (Primitive witness ELran -differences). Let T1 T2 ELHr -terminologies
signature. cDiff ran
(T1 , T2 ), either exist {r, s} sig()
ran
r v cDiff (T1 , T2 ) form C v D, one
1. C 0 v ran(r) u C 0 v A,
2. v D0 , r.> v D0 ran(r) v D0
0
member cDiff ran
(T1 , T2 ), r sig(), sig() concept name, C
subconcept C D0 subconcept D.
ran -concept EL-concept.
Proof. Let C v cDiff ran
(T1 , T2 ), C C
prove theorem induction structure D.
Notice 6= > T2 |= C v >. concept name, inclusion
Point 1 exists. = D1 u D2 , one C v Di , = 1, 2, cDiff ran
(T1 , T2 ).
apply induction hypothesis anddwe infer

inclusion

Point 1


Point 2 exists. = r.D1 , let C = 1il ran(si ) u 1jn Aj u 1km rk .Ck .
Then, Lemma 39, one (e1)(e4) holds. Cases (e2)(e4) directly entail
inclusion Point 1 Point 2 exists. case (e1), either rk v r cDiff ran
(T1 , T2 )

661

fiKonev, Ludwig, Walther, & Wolter

T1 |= Ck u ran(rk ) v D1 T2 6|= Ck u ran(rk ) v D1 (as otherwise T2 |= C v would
hold). apply induction hypothesis D1 conclude inclusion
Point 1 Point 2 exists.
5.3 Instance Difference Witnesses
Similarly Theorem 16 concept difference EL-terminologies derived extension, Theorem 40, ELran , show every member (A, )
iDiff (T1 , T2 ) gives rise basic witness either ABox instance query
atomic. keep formulation succinct give abstract description relationship (A, ) iDiff (T1 , T2 ) witness using signature (A, ).
interested reader problem derive stronger relationship (A, )
witness proof.
Theorem 41 (Primitive witness ELHr -instance differences). Let T1 T2 ELHr terminologies signature. iDiff (T1 , T2 ), least one following
conditions holds:
1. ({r(a, b)}, s(a, b)) iDiff (T1 , T2 ), r, sig();
2. (A, A(b)) iDiff (T1 , T2 ), concept name sig(), individual b,
ABox sig(A) sig().
3. (A, D(b)) iDiff (T1 , T2 ), singleton ABox A, individual b A, ELconcept sig(A), sig(D) sig();
Proof. Let (A, ) iDiff (T1 , T2 ). distinguish following cases.
(a) = s(a, b), (T1 , A) |= s(a, b) if, if, r(a, b) T1 |=
r v s. (T2 , A) 6|= s(a, b) obtain T2 6|= r v s. Thus, ({r(a, b)}, s(a, b)) iDiff (T1 , T2 )
Point 1 holds.
(b) Assume = D(b) EL-concept D. Lemma 36, n 0
n,ran
n,ran
v D. Theorem 40, one (i) r v s, (ii) v D0 , (iii)
v T2 6|= CA,b
T1 |= CA,b
r.> v D0 , (iv) ran(r) v D0 , (v) C v A, (vi) ran(r)uC v member cDiff ran
(T1 , T2 ),
n,ran
D0
r sig(), sig() concept name, C subconcept CA,b
subconcept D. (i) r v cDiff ran
(T1 , T2 ), ({r(a, b)}, s(a, b)) iDiff (T1 , T2 )
Point 1 holds.
let F v G denote member cDiff ran
(T1 , T2 ) cases (ii)-(vi) above. Conran
sider ABox AF associated C -concept F Point 2 Lemma 36.
sig(AF ) sig() (AF , G(aF )) iDiff (T1 , T2 ).
case (ii), obtain F = concept name. Hence AF = {A(aF )} Point 3
holds. case (iii), obtain AF = {r(aF , a> ), >(a> )} Point 3 lemma applies
(after removing >(a> ) AF ). Similarly, (iv), AF = {r(aran , aF )},
Point 3 lemma holds. Finally, cases (v) (vi), G sig() concept
name. Hence Point 2 lemma applies.
Theorem 41 justifies following finite representation -instance difference ELHr -terminologies. corresponds exactly three distinct points theorem. Assume T1 T2 given. Let
662

fiThe Logical Difference Lightweight Description Logic EL

set role -instance difference witnesses, iWtnR
(T1 , T2 ), consist r v
T1 |= r v T2 6|= r v s;
set right-hand -instance difference witnesses, iWtnrhs
(T1 , T2 ), consist
exists (A, A(a)) iDiff (T1 , T2 );
set left-hand -instance difference witnesses, iWtnlhs
(T1 , T2 ), consist
exists C(a) ({A(a)}, C(a)) iDiff (T1 , T2 ) r
exists C(c) c = c = b ({r(a, b)}, C(c)) iDiff (T1 , T2 ).
set -instance difference witnesses defined
rhs
lhs
iWtn (T1 , T2 ) = (iWtnR
(T1 , T2 ), iWtn (T1 , T2 ), iWtn (T1 , T2 )).

Theorem 41, observe iWtn (T1 , T2 ) = (, , ) if, if, iDiff (T1 , T2 ) = .
set iWtnR
(T1 , T2 ) easily computed polynomial time analysed
paper. Thus, aim present polynomial-time algorithms computing
lhs
iWtnrhs
(T1 , T2 ) iWtn (T1 , T2 ).
5.4 Computing iWtnrhs
(T1 , T2 )
compute iWtnrhs
(T1 , T2 ) two different ways: first, present transparent
ABox approach works arbitrary ELHr -terminologies, second present
efficient dynamic programming approach works acyclic ELHr -terminologies
only. approaches introduced Section 4.2 EL-terminologies. start
ABox approach exhibit -ABox AT2 , depending T2
non-conjunctive exists ABox (A, A(d)) iDiff (T1 , T2 ) if,
if, (T1 , AT2 , ) |= A(A ) certain individual name . case conjunctive
reduced condition defining concept names.
deal ELHr -terminologies rather EL-terminologies extend
structure AT2 , significantly. describe model-theoretic properties AT2 , ,
require notion -range simulation. capture model-theoretically expressive
power C ran -concepts (the concepts used describe -instance difference terms subsumption, cf. Lemma 36). two ABoxes A1 , A2 designated
individual names a1 a2 , say relation obj(A1 ) obj(A2 )
-simulation if, if,
(S1) (a1 , a2 ) S;
(S2) : (a, b) A(a) A1 , A(b) A2 ;
(S3) r : (a, b) r(a, a0 ) A1 , exists b0 (a0 , b0 )
r(b, b0 ) A2 .
say -range simulation if, addition,
(RS) r : (a, b) exists c r(c, a) A1 , exists
c0 r(c0 , b) A2 .
follows write
663

fiKonev, Ludwig, Walther, & Wolter

(A1 , a1 ) (A2 , a2 ) exists -simulation (A1 , a1 ) (A2 , a2 );
(A1 , a1 ) ran
(A2 , a2 ) exists -range simulation (A1 , a1 )

(A2 , a2 ).
following lemma shows range simulations characterise C ran -concepts.
Lemma 42. Let A1 A2 -ABoxes designated individual names a1 a2 .
ran -concepts
(A1 , a1 ) ran
(A2 , a2 ), (T , A1 ) |= C(a1 ) implies (T , A2 ) |= C(a2 ) C
C.
Proof. apply Lemma 36. Let -range simulation A1 A2
(a1 , a2 ) S. One prove induction n n 0, obj(A1 )
b obj(A2 ),
n,ran
(b).
() (a, b) S, A2 |= CA
1 ,a
ran assume (A1 , a1 ) ran
(A2 , a2 ) (T , A1 ) |= C(a1 ) holds C
n,ran
concept C. Then, Lemma 36, exists n 0 |= CA1 ,a1 v C. Moreover,
n,ran
(A1 , a1 ) ran
(A2 , a2 ), () A2 |= CA1 ,a1 (a2 ), implies
(T , A2 ) |= C(a2 ), required.

construction , given Figure 6, normalised ELHr terminology signature. advise reader recall definition , given
Figure 3 EL-terminologies consider additional ingredients required
ELHr -terminologies. remind reader definition non-conjT (A)
Section 4.2:

{A}, non-conjunctive
non-conjT (A) =
{B1 , . . . , Bn }, B1 u u Bn
Figure 6, use following sets, NC r NR :
preC
(A) = { B NC | |= B v },
preDom
(A) = { r NR | |= r.> v },
preRan
(A) = { r NR | |= ran(r) v },
preRole
(r) = { NR | |= v r }.
following example illustrates definition , .
Example 43. T1 = {ran(r) v A1 , ran(s) v A2 , B A1 u A2 }, T2 = , = {r, s, B}
defined Example 4,
AT2 , = {B( ), r( , ), s( , ), r(B , ), s(B , ), r( , B ), s( , B )}.
holds (T1 , AT2 , ) |= B(B ) (T2 , AT2 , ) 6|= B(B ).

664

fiThe Logical Difference Lightweight Description Logic EL

Let
{A | sig(T ) non-conjunctive } { } NI .
set individual names. non-conjunctive , define sets , (A) assertions
follows
pseudo-primitive ,
, (A) = { A0 (A ) | A0 \ preC
(A) }
{ r(A , ) | r \ preDom
(A) }
{ r( , ) | r \ preRan
(A) },
r.B , NR let


0
= { (s, B 0 ) | B 0 non-conjT (B), preRole
(r) \ (preDomT (A) preRanT (B )) }

set
, (A) = { A0 (A ) | A0 \ preC
(A) }
{ s( , ) | \ preRan
(A) }

{ s(A , ) | \ (preRole
(r) preDomT (A)) }

{ s(A , ) | (s, ) }.
Let
, = { A0 ( ) | A0 } { r( , ) | r }

[

, (A)

Asig(T )
non-conjunctive

Figure 6: Construction , ELHr -terminologies.
Lemma 44. every normalised ELHr -terminology signature following
conditions equivalent -ABoxes A, sig(T ) non-conjunctive ,
obj(A):
1. (T , A) 6|= A(a);
2. obj(AT , ) (A, a) ran
(AT , , ).
Lemma 44 proved appendix.
Lemma 45. Let T1 T2 normalised ELHr -terminologies, signature .
Let AT2 , ABox constructed Figure 6. following conditions equivalent:
exists -ABox (T1 , A) |= A(a) (T2 , A) 6|= A(a);
(T1 , AT2 , ) |= A(B ) B non-conjT2 (A).
665

fiKonev, Ludwig, Walther, & Wolter

Proof. Assume exists -ABox obj(A) (T1 , A) |= A(a) (T2 , A) 6|=
A(a). Then, (T2 , A) 6|= A(a), B non-conjT2 (A), (T2 , A) 6|= B(a). Hence,
Lemma 44, (A, a) ran
(AT2 , , B ). then, Lemma 42, (T1 , AT2 , ) |= A(B ),
required.
Conversely, suppose (T1 , AT2 , ) |= A(B ) B non-conjT2 (A) B
obj(AT2 , ). Notice that, Lemma 44, (T2 , AT2 , ) 6|= B(B ). Hence (T2 , AT2 , ) 6|= A(B )
AT2 , B witness Point 1.
Theorem 46. Let T1 T2 normalised ELHr -terminologies signature.
iWtnrhs
(T1 , T2 ) computed polynomial time.
Proof. Lemma 45, iWtnrhs
(T1 , T2 ) if, if, B non-conjT2 (A)
(T1 , AT2 , ) |= A(B ). remains observe AT2 , constructed polynomial
time checking whether (T1 , AT2 , ) |= A(B ) polynomial time.
briefly describe dynamic programming approach computing set
r
iWtnrhs
(T1 , T2 ) acyclic terminologies extended EL ELH . extension
NotWitness(E) algorithm Figure 4 ELHr given Figure 7. Figure 4,
procedure NotWitness(E) recursively associates every E sig(T1 ) subset
= {All} { | (sig(T2 ) ), non-conjunctive T2 }.
conditions NotWitness(E) become complex since one take

account sets preRan
(E) preDomT (E). prove correctness NotWitness
algorithm, observe following consequence Lemma 36.
Corollary 47. Let T1 T2 normalised acyclic ELHr -terminologies signature.
ran -concept C C v cDiff ran (T , ) }.
iWtnrhs
1 2
(T1 , T2 ) = { | C

Proof. First, let iWtnrhs
(T1 , T2 ). exists -ABox (T1 , A) |=
A(a) (T2 , A) 6|= A(a). Hence, Point 1 Lemma 36 exists n 0
n,ran
n,ran
ran -concept. Conversely, assume
CA,a
v cDiff ran
(T1 , T2 ). Note CA,a C
exists C ran -concept C C v cDiff ran
(T1 , T2 ). Point 2
Lemma 36, (AC , A(aC )) iDiff (T1 , T2 ), i.e. iWtnrhs
(T
,
T2 ).
1

formulate correctness NotWitness algorithm way
Corollary 26.
Theorem 48. Let T1 T2 normalised acyclic ELHr -terminologies signature.
iWtnrhs
(T1 , T2 ) = { sig(T1 ) | B non-conjT2 (A) B 6 NotWitness(A) }.
proof extension proofs Lemma 25 Corollary 26. Namely, one
show sig(T1 ) B sig(T2 ) B non-conjunctive
T2 following conditions equivalent:
B NotWitness(A);
ran -concepts C: 6|= C v B implies 6|= C v A.
C
2
1

Using Corollary 47, thus obtain every : iWtnrhs
(T1 , T2 ) if, if,
ran
exists C -concept C T2 6|= C v T1 |= C v if, if, exists
B non-conjT2 (A) B 6 NotWitness(A).
666

fiThe Logical Difference Lightweight Description Logic EL

procedure AuxPP (E)


preC
T1 (E) = preRanT1 (E) = preDomT1 (E) =
return {All}
else

Auxconcept := { | preC
T1 (E) preCT2 (A) }

Auxran := { | preRanT1 (E) preRan
T2 (A) }

Auxdom := { | preDomT1 (E) preDom
T2 (A) }
return Auxconcept Auxran Auxdom
end
end procedure
procedure NotWitness(E)
E pseudo-primitive T1
NotWitness(E) := AuxPP (E)
else E E1 u uSEk T1
k
NotWitness(E) := i=1 NotWitness(Ei )
else E r.E 0 T1
0
preRole
T1 (r) = NotWitness(E )
NotWitness(E) := AuxPP (E)
else



pseudo-primitive ,

Auxrole,prim :=

preRole
T1 (r) preDomT2 (A)


t.B T2 ,










preRoleT1 (r) preRoleT2 (t) preDomT2 (A),







preRoleT (r) preRoleT (t)
1
2
Auxrole,exist := fifi

0



/
preDom
(A)

B

non-conj


T2 (B)
T2




0
00





6
preRan
(B
),

exists
E

non-conjT1 (E 0 )
T2




00
0
00

B NotWitness(E ) 6 preRan
T1 (E )
NotWitness(E) := (Auxrole,prim Auxrole,exist ) AuxPP (E)
end
end
end procedure





















Figure 7: Computation NotWitness(E) ELHr .
5.5 Tractability iWtnlhs
(T1 , T2 )
prove tractability iWtnlhs
(T1 , T2 ) reduction simulation checking
case EL-terminologies (Theorem 30).
Theorem 49. Let T1 T2 ELHr -TBoxes let signature. set
iWtnlhs
(T1 , T2 ) computed polynomial time.
Proof. concept name
iWtnlhs
(T1 , T2 )


667

(IK1 , a) 6 (IK2 , a)

fiKonev, Ludwig, Walther, & Wolter

Ki = (Ti , A) = {A(a)} IKi canonical model Ki , = 1, 2. Indeed,
({A(a)}, C(a)) iDiff (T1 , T2 ), EL -concept C, if, if, Theorem 2,
C IK1
/ C IK2 . condition is, Lemma 29, equivalent (IK1 , a) 6 (IK2 , a).
latter condition checked polynomial time.
Similarly, role name r
r iWtnlhs
(T1 , T2 )



(IK1 , a) 6 (IK2 , a) (IK1 , b) 6 (IK2 , b)

Ki = (Ti , A), = {r(a, b)}, IKi canonical model Ki , = 1, 2. Again,
latter condition checked polynomial time.

6. ELHr -Concept Difference
section present polynomial-time algorithms deciding -concept inseparability
computing succinct representation concept difference ELHr -terminologies.
algorithms essentially reduction instance difference case.
start introducing succinct representation -concept difference. Let
T1 T2 ELHr -terminologies. Since cDiff (T1 , T2 ) cDiff ran
(T1 , T2 ), follows
Theorem 40 C v cDiff (T1 , T2 ) exists inclusion least one
following forms
(i) C 0 v A,
(ii) ran(r) u C 0 v A,
(iii) v D0 ,
(iv) r.> v D0 ,
(v) ran(r) v D0
cDiff (T1 , T2 ), r sig(), sig() concept name, C 0 subconcept C
D0 subconcept D. Notice particular case (ii) C 0 EL-concept.
Hence, case -instance difference, obtain following representation
-concept difference. Assume T1 T2 given. Let
set role inclusion -concept difference witnesses, cWtnR
(T1 , T2 ), consist
r v T1 |= r v T2 6|= r v s;
set right-hand -concept difference witnesses, cWtnrhs
(T1 , T2 ), consist
exists EL-concept C either C v cDiff (T1 , T2 )
additionally exists role name r ran(r) u C v cDiff (T1 , T2 ).
set left-hand -concept difference witnesses, cWtnlhs
(T1 , T2 ), consist
exists EL-concept C v C cDiff (T1 , T2 ),
role names r exists EL-concept C either r.> v C
cDiff (T1 , T2 ) ran(r) v C cDiff (T1 , T2 ).
set -concept difference witnesses defined
rhs
lhs
cWtn (T1 , T2 ) = (cWtnR
(T1 , T2 ), cWtn (T1 , T2 ), cWtn (T1 , T2 )).

668

fiThe Logical Difference Lightweight Description Logic EL

Observe cWtn (T1 , T2 ) = (, , ) if, if, cDiff (T1 , T2 ) = . obtain
lhs
sets cWtnR
(T1 , T2 ) cWtn (T1 , T2 ) coincide corresponding witness sets
instance difference, allows us re-use results developed
detecting instance differences.
Lemma 50. Let T1 T2 normalised ELHr -terminologies signature.
following holds:
R
1. cWtnR
(T1 , T2 ) = iWtn (T1 , T2 ),
lhs
2. cWtnlhs
(T1 , T2 ) = iWtn (T1 , T2 )
rhs
3. cWtnrhs
(T1 , T2 ) iWtn (T1 , T2 )
lhs
Proof. Point 1 follows directly definition. Proving cWtnlhs
(T1 , T2 ) iWtn (T1 , T2 )
rhs
cWtnrhs
(T1 , T2 ) iWtn (T1 , T2 ) similar Lemma 10. Finally, prove
lhs
lhs
iWtn (T1 , T2 ) cWtn (T1 , T2 ), assume iWtnlhs
(T1 , T2 ). exists ELconcept D(a) ({A(a)}, D(a)) iDiff (T1 , T2 ). T1 |= v T2 6|= v
lhs
and, therefore, cWtnlhs
(T1 , T2 ). argument r iWtn (T1 , T2 ) similar.

presented polynomial-time algorithms compute iWtnlhs
(T1 , T2 )
rhs
iWtnR
(T
,

).
Thus,

remains

analyse
cWtn
(T
,

).
1
2
1
2


6.1 Tractability cWtnrhs
(T1 , T2 )
prove tractability cWtnrhs
(T1 , T2 ) modifying ABox AT2 , introrhs
duced prove tractability iWtnrhs
(T1 , T2 ). Recall iWtn (T1 , T2 ) iff (T1 , AT2 , ) |=
A(B ) B non-conjT2 (A) (cf. Lemma 45). satisfying condition
cWtnrhs
(T1 , T2 ) since ABox AT2 , cannot always captured set EL-concepts
(cf. Example 4). modification AT2 , motivated observation ABox
contain individual range two distinct role names, EL-concepts
rather C ran -concepts sufficient capture consequences ABox. Thus,
going modify AT2 , minimal way resulting ABox contain
individual name range two distinct role names.
Definition 51. ABox role-splitting pair assertions r(a, c), s(b, c)
A, individual names a, b, c distinct role names r, s.
following lemma states main property role-splitting ABoxes.
Lemma 52. Let T1 T2 normalised ELHr -terminologies, signature
let role-splitting -ABox (T1 , A) |= A(a) (T2 , A) 6|= A(a).
cWtnrhs
(T1 , T2 ).
n,ran
n,ran
Proof. Lemma 36, exists n 0 T1 |= CA,a
v T2 6|= CA,a
v A.
Assume first exist b obj(A) r r(b, a) A. Then,
n,ran
definition since role-splitting, ran(r) occurs CA,a
direct scope
n,ran
existential restriction r. Hence CA,a equivalent EL -concept,
done. assume exists r(b, a) A. Then, since role-splitting,
n,ran
CA,a
equivalent concept ran(r) u C, C EL -concept. case
T1 |= ran(r) u C v T2 6|= ran(r) u C v A, required.

669

fiKonev, Ludwig, Walther, & Wolter

-ABox sig(A) NR 6= , define role-splitting unfolding
individuals { ar | obj(A), r sig(A) NR } setting
= { A(ar ) | A(a) A, r sig(A) NR } { r(as , br ) | r(a, b) A, sig(A) NR }.
Example 53. Consider T1 = {ran(r) v A1 , ran(s) v A2 , B A1 u A2 }, T2 = , =
{r, s, B} = {r(a, c), s(b, c)} Example 4. (T1 , A) |= B(c) (T2 , A) 6|=
B(c). Notice role-splitting unfolding = {r(ar , cr ), r(as , cr ), s(br , cs ), s(bs , cs )}
contain individual range one role
c



cr



cs
r

r



r



b

ar




br



bs

(T1 , ) 6|= B(cr ), (T1 , ) 6|= B(cs ).
apply role-splitting unfolding ABox , Figure 6. following
result concept version Lemma 44 proved appendix reduction
Lemma 44. ABox AC corresponding EL-concept C introduced
Lemma 36. simplicity, consider signatures containing least one role name.
Lemma 54. every normalised ELHr -terminology , signature NR 6= ,
concept name non-conjunctive , role name r , EL -concepts C
following conditions equivalent = C = ran(r) u C:
6|= v A;

r NR , (A )r obj(AT , ) (AD , aD ) ran
(AT , , (A )r ).

following lemma proved similarly Lemma 45, using Lemma 54 instead
Lemma 44.
Lemma 55. Let T1 T2 normalised ELHr -terminologies, signature
NR 6= . following conditions equivalent:
cWtnrhs
(T1 , T2 );
exists r (T1 , AT2 , ) |= A((B )r ) B non-conjT2 (A).
Proof. Assume cWtnrhs
(T1 , T2 ). Then, either exists EL -concept C
T1 |= C v T2 6|= C v A, additionally exists r T1 |=
ran(r) u C v T2 6|= ran(r) u C v A. Hence, = C = ran(r) u C,
respectively, T2 6|= v B, B non-conjT2 (A), Lemma 54, exists

r (A )r obj(AT , ) (AD , aD ) ran
(AT2 , , (B )r ). then, Lemma 42
(T1 , AT2 , ) |= A((B )r ) (T1 , AD ) |= A(aD ) holds Lemma 36.
converse direction, easy see (B )r obj(AT2 , ), B obj(AT2 , ),

(AT2 , , (B )r ) ran
(AT2 , , B ), implies (T2 , AT2 , ) 6|= A((B )r ) Lemma 44.
Consequently, obtain cWtnrhs
(T1 , T2 ) applying Lemma 52 using fact
ABox AT2 , role-splitting.
670

fiThe Logical Difference Lightweight Description Logic EL

Finally, obtain tractability result.
Theorem 56. Let T1 T2 ELHr -terminologies signature. set
cWtnrhs
(T1 , T2 ) computed polynomial time.
rhs
Proof. NR = , cWtnrhs
(T1 , T2 ) = iWtn (T1 , T2 ), computed
polynomial time Theorem 46.
Otherwise NR 6= result follows Lemma 55 fact AT2 ,
constructed polynomial time size T2 .

7. ELHr -Query Difference
investigate query difference ELHr -terminologies, introduce language
ELran,u,u extends ELran universal role intersections roles. show
concept differences ELran,u,u correspond query differences ELHr . ELran,u,u
prove analogue Theorem 40, states inclusion concept
difference contains inclusion either left-hand side right-hand side
atomic. Using correspondence concept difference ELran,u,u query
difference ELHr obtain meaningful definition succinct representation
query difference qDiff (T1 , T2 ). Finally, provide polynomial-time algorithms deciding
-query inseparability computing succinct representation query difference.
7.1 ELran,u,u -Concept Difference
start section defining language ELran,u,u .
Definition 57 (ELran,u,u ). Let u (the universal role) fresh logical symbol. C u,u concepts constructed using following syntax rule
C :=



|

C uD

|

R.C

|

u.C,

NC , C, range C u,u -concepts R = r1 u u rn r1 , . . . , rn NR
n 1. set ELran,u,u -inclusions consists concept inclusions C v role
inclusions r v s, C C ran -concept, C u,u -concept, r, NR .
semantics additional constructors straightforward setting, interpretation I,
(r1 u u rn )I = rI1 rnI ;
uI = .
Note regard universal role u logical symbol; i.e., u 6 NR sig(u.C) =
sig(C) concept C. Assuming u logical symbol reflects fact firstorder translation uses non-logical symbols. example, signature first-order
translation x.A(x) u.A contain non-logical symbols exception
itself.
convenient decompose C u,u -concepts. set C u -concepts defined
set C u,u -concepts without universal role. Every C u,u -concept C equivalent
671

fiKonev, Ludwig, Walther, & Wolter

concept form D0 u u.D1 u u u.Dk , D0 , . . . , Dk C u -concepts.
see this, observe concept C subconcept u.D equivalent u.D u C 0 ,
C 0 obtained C replacing occurrences u.D >. example,
u r.(B u u.E) equivalent concept u.E u u r.(B u >).
u,u
u ) set C u,u (C u ) concepts whose signature
following denote C
(C
contained .
Clearly, every ELran -inclusion ELran,u,u -inclusion. addition, role conjunctions
universal role ELran,u,u -inclusions used capture differences
ELHr -TBoxes cannot captured ELHr -inclusions.
Example 58. first reconsider Example 8. Recall
T1 = ,

T2 = {A v r.B},

= {A, B}.

T2 |= v u.B T1 6|= v u.B and, universal role regarded
logical symbol, sig(A v u.B) . Thus, employing universal role ELran,u,u
simulate query difference ({A(a)}, x.B(x)) using subsumption v u.B.
Second, reconsider Example 9. Recall
T1 = {A v s.>, v r1 , v r2 },

T2 = {A v r1 .> u r2 .>},

= {A, r1 , r2 }.

T1 |= v (r1 u r2 ).> T2 6|= v (r1 u r2 ).>. Thus, simulate query
difference ({A(a)}, x.(r1 (a, x) r2 (a, x))) using subsumption v (r1 u r2 ).>.
introduce appropriate notion -concept difference ELran,u,u .
ran,u,u
Definition 59 (EL
-difference). ELran,u,u
-difference ELHr -TBoxes T1

ran,u,u
ran,u,u
-inclusions T1 |=
(T1 , T2 ) EL
T2 set cDiff
T2 6|= .

extend Lemma 39 concepts use universal role conjunctions
roles.
Lemma 60. Let ELHr -terminology R.D C u -concept R = t1 u u tq
conjunction role names. Assume
l
l
l
|=
ran(si ) u
Aj u
rk .Ck v R.D,
1il

1jn

1km

Ck , 1 k m, C ran -concepts l, m, n 0. least one following
conditions holds:
(e1u ) exists rk , 1 k m, rk vT t1 ,. . . , rk vT tq , |= Ck uran(rk ) v
D;
(e2u ) exists Aj , 1 j n, |= Aj v R.D;
(e3u ) exists rk , 1 k m, |= rk .> v R.D;
(e4u ) exists si , 1 l, |= ran(si ) v R.D.
672

fiThe Logical Difference Lightweight Description Logic EL

u universal role |= C v u.D, C C ran -concept
C u -concept, least one following holds:
(e1u ) exists subconcept r.C 0 C |= C 0 u ran(r)v D;
(e2u ) exists concept name C |= v u.D;
(e3u ) exists role name r C |= r.> v u.D;
(e4u ) exists role name r C |= ran(r) v u.D;
(e5u ) |= C v D;
(e6u ) exists subconcept (ran(r) u C 0 ) C |= r.C 0 v D.
Theorem 61 (Primitive witnesses ELran,u,u ). Let T1 T2 ELHr -terminologies
ran,u,u
signature. cDiff
(T1 , T2 ), either exist {r, s} sig()
ran,u,u
r v cDiff
(T1 , T2 ) form C v D, one
1. C 0 v
2. v D0 , r.> v D0 ran(r) v D0
member cDiff ran,u,u
(T1 , T2 ), sig() concept name, r sig() role

0
ran
name, C C -concept, D0 C u,u -concept, sig(C 0 ), sig(D0 ) sig().
Proof. Let C v cDiff ran,u,u
(T1 , T2 ), C C ran -concept C u,u -concept.

prove result induction structure D. proof verydsimilar
proof Theorem

40 consider case = u.D1 only. Let C = 1il ran(si ) u
1jn Aj u 1km rk .Ck . Then, Lemma 60, one (e1u )(e6u ) holds.
Cases (e2u )(e4u ) directly entail existence inclusion Point 2
theorem. case (e1u ) exists subconcept r.C 0 C T1 |= C 0 uran(r) v D1 .
T2 6|= C 0 u ran(r) v D1 otherwise T2 |= r.C 0 v r.D1 , i.e.
(T1 , T2 ). apply
T2 |= C v would hold. Thus, C 0 u ran(r) v D1 cDiff ran,u,u

induction hypothesis D1 infer inclusion Point 1 Point 2 exists.
(T1 , T2 ) otherwise T2 |= C v
Similarly, case (e5u ), C v D1 cDiff ran,u,u

D1 , i.e. T2 |= C v due = u.D1 . applying induction hypothesis D1 ,
obtain inclusion Point 1 Point 2 exists.
Finally, case (e6u ) exists subconcept ran(r) u C 0 C T1 |= r.C 0 v
D1 . Observe first every model T2 every C , exists d0
(ran(r) u C 0 )I , implies exists d00 (r.C 0 )I . assume
T2 |= r.C 0 v D1 , would follow every model T2 every C ,
exists d00 D1I , i.e. T2 |= C v u.D1 would hold. infer r.C 0 v D1
ran,u,u
cDiff
(T1 , T2 ) applying induction hypothesis D1 , conclude
inclusion Point 1 Point 2 exists.
7.2 Query Difference Witnesses
start connecting concept differences ELran,u,u query differences
ELHr -terminologies. direction query differences ELHr concept differences
ELran,u,u straightforward: observe every assertion C(a) C C u,u -concept
673

fiKonev, Ludwig, Walther, & Wolter

regarded Boolean conjunctive query qC,a . example, assertion (u.Aur.B)(a)
equivalent conjunctive query xy.(A(x)r(a, y)B(y)) (details translation
provided appendix). obtain (where AC ABox defined Lemma 36):
Lemma 62. two ELHr -TBoxes T1 T2 signature , C v
cDiff ran,u,u
(T1 , T2 ) if, if, (AC , qD,aC ) qDiff (T1 , T2 ).

follows distinguish assertion C(a) C C u,u -concept
conjunctive query qC,a . follows Lemma 62 qDiff (T1 , T2 ) = ,
cDiff ran,u,u
(T1 , T2 ) = .

come (considerably involved) direction query differences concept
differences ELran,u,u . following lemma provides rather abstract description
inclusions qDiff (T1 , T2 ) reflected members cDiff ran,u,u
(T1 , T2 ) stating

given signature.
Lemma 63. two ELHr -TBoxes T1 T2 signature , qDiff (T1 , T2 ),
(T1 , T2 ) sig(0 ) sig().
exists 0 cDiff ran,u,u

interested reader extract detailed description proof given
appendix. proof Lemma 63 given appendix model-theoretic employs
close relationship conjunctive query entailment homomorphisms (Chandra
& Merlin, 1977). intuition behind result, however, rather straightforward:
(T , A) |= q[~a] conjunctive query q(~x) = ~y (~x, ~y ) ELHr -TBox , every
model (T , A) mapping variables ~x ~y ~a
-match q(~x) I. (T , A) models essentially forest-shaped: consist
tree-shaped models attached ABox individuals (cf. Lutz et al., 2009).
forest-shaped models, individuals ~y mapped individuals
mapped trees attached ABox individuals. mapping, however,
exists already conjunctive query q 0 q homomorphic image q 0 q 0
essentially forest-shaped: individuals mapped ABox individuals form trees
attached core q 0 mapped ABox individuals. words,
obtain q 0 partitioning q core subsets correspond C u,u -concepts!
Now, exists -ABox conjunctive -query q(~a) (T2 , A) |= q[~a]
(T1 , A) 6|= q[~a], find conjunctive -query q 0 behaviour
q essentially forest-shaped. (A, q 0 ) one obtain required ELran,u,u inclusion C v D, captures subtree query q 0 (a C u,u -concept) C
(a C ran -concept) ABox A. intuition last step exactly
Lemma 36.
note result holds general TBoxes terminologies.
Lemma 63 Theorem 61, directly obtain following description primitive witnesses query differences.
Theorem 64 (Primitive witness ELHr -query differences). Let T1 T2 ELHr terminologies signature. qDiff (T1 , T2 ), least one following
conditions holds (for individual names a, b):
1. ({r(a, b)}, s(a, b)) qDiff (T1 , T2 ), r, sig();
674

fiThe Logical Difference Lightweight Description Logic EL

2. (A, A(b)) qDiff (T1 , T2 ), concept name sig() ABox
sig(A) sig();
3. (A, D(b)) qDiff (T1 , T2 ), singleton ABox C u,u -concept
sig(A), sig(D) sig().
Observe Theorem 64 coincides Theorem 41 exception Point 3
concept C u,u -concept. can, therefore, define following finite
representation -query difference. Assume T1 T2 given. Define set
qWtnR
(T1 , T2 ) role -query difference witnesses set role -instance differR
ence witnesses; i.e., qWtnR
(T1 , T2 ) = iWtn (T1 , T2 );
qWtnrhs
(T1 , T2 ) right-hand -query difference witnesses set right-hand
rhs
-instance difference witnesses; i.e., qWtnrhs
(T1 , T2 ) = iWtn (T1 , T2 );
qWtnlhs
(T1 , T2 ) left-hand -instance difference witnesses set
exists C u,u -concept C ({A(a)}, C(a)) qDiff lhs
(T1 , T2 ) r
u,u
exists C -concept C ({r(a, b)}, C(c)) qDiff (T1 , T2 )
c = c = b.
set -query difference witnesses defined
rhs
lhs
qWtn (T1 , T2 ) = (qWtnR
(T1 , T2 ), qWtn (T1 , T2 ), qWtn (T1 , T2 )).

Theorem 64, qWtn (T1 , T2 ) = (, , ) if, if, qDiff (T1 , T2 ) = . Algorithms
rhs
computing qWtnR
(T1 , T2 ) qWtn (T1 , T2 ) presented section instance
difference. thus remains consider qWtnlhs
(T1 , T2 ).
7.3 Tractability qWtnlhs
(T1 , T2 )
u,u -concepts
prove tractability qWtnlhs
(T1 , T2 ) first capture expressive power C
using stronger form simulation interpretations. Let I1 I2 interpretations. -simulation I1 I2 called global intersection preserving
-simulation if, addition,

every I1 exists d0 I2 (d, d0 ) S;
(d, e) S, d0 I1 , R = {r | (d, d0 ) rI1 } =
6 , exists e0
(e, e0 ) (d0 , e0 ) rI2 r R.
write (I1 , d)
(I2 , e) exists global intersection preserving -simulation
I1 I2 (d, e) S.
Lemma 65. Let I1 I2 finite interpretations, signature, I1 , e I2 .

u,u
(I1 , d)

C C
: C I1 e C I2 .
(I2 , e)
checked polynomial time whether (I1 , d)
(I2 , e).
675

fiKonev, Ludwig, Walther, & Wolter

proof straightforward extension proof Lemma 29 polynomialtime algorithm deciding existence -simulations.
observe Theorem 2 properties canonical model IK KB K
extended C u,u -concepts (in appendix, proof given C u,u -concepts
well). Namely, C u,u -concepts C0 :
K |= C0 (a) if, if, aIK C0IK .
|= C u v C0 if, if, xC,D C0IK .
follows concept name ,
qWtnlhs
(T1 , T2 )



(IK1 , a) 6
(IK2 , a),

Ki = (Ti , A) = {A(a)}, = 1, 2. every role name r


r qWtnlhs
(IK1 , a) 6
(T1 , T2 )
(IK2 , a) (IK1 , b) 6 (IK2 , b)
Ki = (Ti , A) = {r(a, b)}, = 1, 2. Thus, obtain following tractability
result:
Theorem 66. Let T1 T2 ELHr -terminologies signature. set
qWtnlhs
(T1 , T2 ) computed polynomial time.

8. Implementation Experiments
section, describe experimental evaluation theoretical work developed above. experiments employ CEX2 tool.4 CEX2, implemented
polynomial-time algorithms which, given acyclic ELHr -terminologies T1 T2 signature input, compute witnesses concept difference cDiff (T1 , T2 )
instance difference iDiff (T1 , T2 ).5
CEX2 written OCaml reasoner CB (Kazakov, 2009) internally used
classification engine. implementation CEX2, employed algorithms
developed paper. detail, instance difference case acyclic ELHr terminologies T1 T2 ,
compute iWtnR
(T1 , T2 ), CEX2 performs straightforward comparison role
inclusion chains entailed terminologies T1 T2 ;
compute iWtnrhs
(T1 , T2 ), CEX2 uses NotWitness algorithm Figure 7
employs Theorem 48;
compute iWtnlhs
(T1 , T2 ), CEX2 checks existence -simulation
canonical models (Theorem 49).
4. Available open-source license http://www.csc.liv.ac.uk/~michel/software/cex2/
5. extended version CEX2 computing witnesses query difference qDiff (T1 , T2 ) well
presented (Konev, Ludwig, & Wolter, 2012). addition, Konev et al. describe experiments comparing
query difference witnesses concept instance difference witnesses presented
paper.

676

fiThe Logical Difference Lightweight Description Logic EL

output iWtnlhs
(T1 , T2 ) partitioned three sets:
set left-hand atomic -instance difference witnesses, iWtnlhs,A
(T1 , T2 ),

defined set concept names exists EL-concept C
({A(a)}, C(a)}) iDiff (T1 , T2 ) (equivalently v C cDiff (T1 , T2 ));
set left-hand domain -instance difference witnesses, iWtnlhs,dom
(T1 , T2 ),

defined set role names r exists EL-concept C
({r(a, b)}, C(a)) iDiff (T1 , T2 ) (equivalently, r.> v C cDiff (T1 , T2 ));
set left-hand range -instance difference witnesses, iWtnlhs,ran
(T1 , T2 ),

defined set role names r exists EL-concept C
({r(a, b)}, C(b)) iDiff (T1 , T2 ) (equivalently, ran(r) v C cDiff (T1 , T2 )).
Obviously, holds that:
lhs,A
iWtnlhs
(T1 , T2 ) iWtnlhs,dom
(T1 , T2 ) iWtnlhs,ran
(T1 , T2 ).
(T1 , T2 ) = iWtn



concept difference case, recall
R
cWtnR
(T1 , T2 ) = iWtn (T1 , T2 ),

lhs
cWtnlhs
(T1 , T2 ) = iWtn (T1 , T2 ),

use algorithms instance case. set
(T1 , T2 ) = iWtnlhs,X (T1 , T2 )
cWtnlhs,X

rhs
X {A, dom, ran}. compute iWtnrhs
(T1 , T2 ), CEX2 exploits cWtn (T1 , T2 )
rhs
rhs
iWtn (T1 , T2 ) (Lemma 50) first computes iWtn (T1 , T2 ) checks using
straightforward variant NotWitness algorithm concept differences whether
cWtnrhs
(T1 , T2 ).
following three subsections describe experiments conducted.
experimental settings follows. programs run PCs equipped
Intel Core 2 Duo E6400 CPU 3 GiB main memory. Version 2.0.1 CEX2
used.

8.1 Comparing Different Versions Snomed CT
applied CEX2 compare January 2009 (SM09a) July 2009 (SM09b) version Snomed CT. SM09a SM09b contain 310013 307693 concept names, respectively. versions use 62 role names, contain role inclusions
domain range restrictions present. Consequently, one infer Corollary 47 iWtn (SM09b, SM09a) = cWtn (SM09b, SM09a). follows consider
cWtn (SM09b, SM09a) only.
experiments used signatures ranging called Snomed CT subsets,
employed UK deployment Snomed CT specific areas. compared SM09a SM09b 159 signatures computing cWtn (SM09b, SM09a)
sets . considered signatures always contain 62 Snomed
CT role names. comparisons resulted non-empty difference reproduced
677

fiKonev, Ludwig, Walther, & Wolter

Table 2. none cases, differences regarding role inclusions detected.
Table 2, second column gives number concept names respective subset ,
third fifth column number concept witness differences. Observe
number differences correlate size considered signatures , i.e.
exist signatures somewhat comparable size, induce greatly varying
number difference witnesses (see e.g. subsets Diagnosis Manumat).
order determine many difference witnesses computed CEX2 obtained
straightforward comparison class hierarchies already, computed
sets
clsWtnlhs
(SM09b, SM09a) = { | B : v B cDiff (SM09b, SM09a) }

clsWtnrhs
(SM09b, SM09a) = { B | : v B cDiff (SM09b, SM09a) }
considered comparison signatures . results obtained
depicted Table 2. One see often great number differences cannot
detected considering classification difference only.
last three columns Table 2, give CPU times required computing
concept witnesses:
first, times given CEX2 directly applied full terminologies
SM09a SM09b;
second, times given one first extracts -modules using module extraction tool MEX (Konev, Lutz, Walther, & Wolter, 2008) SM09a and, respectively,
SM09b applies CEX2 extracted -modules. Observe -module
extracted MEX -query (and, therefore, -concept -instance) inseparable
whole terminology. Thus, computed concept witnesses same.
finally, times given if, addition computing concept witnesses full
terminologies SM09a SM09b, CEX2 computes examples concept inclusions
logical difference explain witnesses. discuss feature CEX2
below.
One observe extracting MEX modules leads significant improvement
performance CEX2. course, signature large (e.g., Diagnosis
Finding), resulting modules almost large Snomed CT effect
less significant. Secondly, one observe additional computation example concept inclusions logical difference roughly doubles times needed
comparison.
Finally, evaluate practical feasibility using ABox approach compute
sets iWtnrhs
(SM09b, SM09a), implemented computation ABoxes ,
together ABox reasoning algorithm checking second condition Lemma 45.
tested implementation subsets Snomed CT used evaluating performance CEX2. limit size ABoxes , speed
computations, first computed modules using MEX. results obtained
678

fiThe Logical Difference Lightweight Description Logic EL

shown Table 3. size -modules computed MEX, i.e. T1 SM09b T2
SM09a, shown columns two three, respectively. expected definition , , one observe number concept role membership assertions
present ABoxes AT2 , grow large, even modules signatures
thousand concept names.
8 41 considered subsets implementation ran available physical
memory (indicated time value -) possible concept membership consequences
ABox computed. Overall, observed longest execution time
5 hours set Specmatyp. conclusion, one see straightforward
implementation ABox approach practically useful terminologies
signatures thousand concept names.
8.2 Comparing Different Versions NCI Thesaurus
used CEX2 tool compare distinct versions NCI Thesaurus.
distributed releases NCI Thesaurus contain language constructs part
ELHr (such disjunction value restriction). obtain ELHr -terminologies,
removed inclusions contain non-ELHr constructor original terminologies.
Typically, affected 5%-8% inclusions present distributed NCI
versions. ELHr -versions generated way contain role inclusions well
domain range restrictions.
Similarly work Goncalves et al. (2011), compared 71 consecutive
ELHr -versions NCI Thesaurus ranging versions 03.10J 10.02d,
exception 05.03F 05.04d, could parsed correctly. Version 10.03h
later versions NCI Thesaurus acyclic, hence, could
handled CEX2 tool.
two consecutive versions NCIn NCIn+1 within considered range,
computed sets cWtn (NCIn+1 , NCIn ) iWtn (NCIn+1 , NCIn ) signatures =
sig(NCIn ) sig(NCIn+1 ). overview set sizes cWtnrhs
(NCIn+1 , NCIn )
lhs,A
cWtn (NCIn+1 , NCIn ) obtained found Figure 8. comparisons
sorted chronologically along x-axis according release dates NCI ontology
versions, whereas corresponding number left-hand atomic difference witnesses
right-hand difference witnesses found y-axis. One see number righthand difference witnesses remained fairly low throughout different versions. However,
occasional spikes occurred number left-hand atomic difference witnesses
maximum value 33487 comparing versions 05.01d 05.03d. Moreover, none
comparisons except shown Figure 9 left-hand role domain left-hand role
range difference witnesses identified. Overall, witnesses regarding role inclusions
detected found every two considered consecutive versions NCIn
NCIn+1 = sig(NCIn ) sig(NCIn+1 ),
cWtn (NCIn+1 , NCIn ) = iWtn (NCIn+1 , NCIn ).
running time 140 seconds 228 MiB memory required average
computing witnesses example inclusions iDiff (NCIn+1 , NCIn ). Computing witnesses example inclusions cDiff (NCIn+1 , NCIn ) average took 157 seconds
used 228 MiB memory.
679

fiKonev, Ludwig, Walther, & Wolter

Subset Name
Admin
Adminproc
Cdacarest
Crcareneur
Crcareresp
Devicetyp
Diagimg
Diagnosis
Drgadrcon
Endosfind
Endosproc
Epcream.6a
Epenema.7a
Epenema.7b
Epeye.4
Epiuds16
Famhist
Finding
Foodadrcon
Ffoodaller
Invest
Labinvest
Labinvmeth
Labisolate
Labmorph
Labspec
Labtopog
Lifestyle
Manumat
Nofoodall
Nonhuman
Pbcl
Pbhllng
Pf
Provadv
Sf
Socpercir
Specmatyp
Treatment
Vmp
Vtm

| NC |
7684
3198
355
1640
1082
6539
4162
75879
8009
178
73
403
25
6
223
1
416
168383
2378
468
14839
3904
3794
16313
4854
1221
27277
13090
90503
686
1839
5866
1113
79
1052
613
6786
8830
43660
13667
2117

|cWtnrhs
|
7
0
1
28
72
26
27
7410
131
0
1
0
0
0
0
0
8
11824
11
1
1396
61
103
150
32
3
866
77
2
1
24
633
1
0
2
0
8
10
2419
2
0

|clsWtnrhs
|
5
0
1
8
18
26
13
881
131
0
1
0
0
0
0
0
5
2497
11
1
534
45
81
150
32
3
220
41
0
1
11
116
0
0
1
0
8
8
1255
0
0

|cWtnlhs,A
|

29
6
1
197
262
22
13
12409
47
13
5
3
3
2
6
1
31
31228
15
9
5549
2520
3380
661
45
18
169
826
22
13
469
1342
27
4
158
3
2
46
9251
22
13

|clsWtnlhs
|
7
0
1
13
64
22
8
5406
47
0
3
0
0
0
0
0
4
20063
14
9
5441
133
3374
661
45
3
169
148
0
13
131
402
0
0
108
0
2
10
8740
0
0

Time (s)
cWtn -
full ontologies
358.51
344.60
337.91
399.57
377.36
369.20
444.66
844.26
1419.52
363.23
352.84
337.41
337.42
337.50
337.53
337.26
339.36
1559.23
481.20
379.42
511.12
382.32
367.20
671.36
858.11
360.80
1947.19
445.75
349.73
421.23
678.53
395.27
454.39
337.68
343.78
338.13
366.14
380.19
793.12
342.70
339.14

Time (s)
cWtn -
module extraction
9.89
8.24
6.76
15.58
12.24
8.01
38.56
486.53
10.17
7.86
7.30
7.39
6.86
6.76
7.20
6.69
8.84
1366.08
7.74
7.03
76.90
12.47
10.70
14.14
8.28
13.38
38.05
32.49
15.36
7.11
12.50
12.18
7.99
7.12
8.19
7.44
8.99
16.10
330.45
12.95
9.45

Time (s)
cWtn
examples
654.12
642.23
556.41
704.21
680.51
589.81
775.37
2699.89
1708.49
662.67
573.66
631.51
556.31
629.57
1236.84
1233.89
633.94
5017.02
1516.47
677.97
769.93
680.94
1290.83
1005.95
1113.70
1272.51
4463.05
765.10
1224.92
721.74
1907.70
1358.88
761.00
634.26
569.56
629.50
1300.47
685.35
1315.23
1247.18
633.50

Table 2: Subset Comparisons T1 = SM09b T2 = SM09a Resulting Non-Empty
Difference

680

fiThe Logical Difference Lightweight Description Logic EL

Subset Name
Admin
Adminproc
Cdacarest
Crcareneur
Crcareresp
Devicetyp
Diagimg
Diagnosis
Drgadrcon
Endosfind
Endosproc
Epcream.6a
Epenema.7a
Epenema.7b
Epeye.4
Epiuds16
Famhist
Finding
Foodadrcon
Foodaller
Invest
Labinvest
Labinvmeth
Labisolate
Labmorph
Labspec
Labtopog
Lifestyle
Manumat
Nofoodall
Nonhuman
Pbcl
Pbhllng
Pf
Provadv
Sf
Socpercir
Specmatyp
Treatment
Vmp
Vtm

| NC |

|sig(T1 ) NC |

|sig(T2 ) NC |

|{ A(a) | A(a) AT2 , }|
(in thousands)

|{ r(a, b) | r(a, b) AT2 , }|
(in thousands)

Time (s)

7684
3198
355
1640
1082
6539
4162
75879
8009
178
73
403
25
6
223
1
416
168383
2378
468
14839
3904
3794
16313
4854
1221
27277
13090
90503
686
1839
5866
1113
79
1052
613
6786
8830
43660
13667
2117

6746
3071
322
6484
5273
3617
11007
156588
8323
1487
809
1425
85
13
851
5
3126
323809
2716
636
42071
9308
10132
16281
4575
7106
27118
26233
11605
990
8728
8497
2488
386
3104
1856
6757
12928
111178
11972
7655

6750
3120
323
6375
5206
3619
11074
156441
8361
1534
826
1446
86
15
859
7
3136
324400
2723
644
42559
9302
10147
16313
4558
7064
27142
26473
11649
991
8848
8793
2487
389
3014
1860
6754
12871
111612
12018
7711

66942
12352
148
8568
4361
43743
40817
8636801
70643
210
48
641
4
0
214
0
1003
41381927
6745
326
504618
36048
36738
267268
24538
5566
723594
250140
8851332
727
13698
64174
3083
37
3202
1332
48627
112252
3716810
289683
16540

1081
480
52
651
503
830
1220
14134
1095
148
82
198
19
10
120
8
301
30521
353
87
4224
1147
1203
2033
628
570
3294
2374
12127
132
926
1357
344
59
378
270
889
1580
10578
2629
970

9291.75
1642.41
3.86
3110.07
3689.22
2381.00
12503.63
2097.23
143.87
17.88
315.58
0.32
0.06
60.80
0.05
137.34
277.80
11.57
8632.09
4131.02
7785.59
1275.48
646.59
26.99
10110.25
16410.12
933.00
3.86
518.47
249.26
5819.23
18306.56
2861.37

Table 3: Performance ABox Approach Computing iWtnrhs
(SM09b, SM09a)

681

fiKonev, Ludwig, Walther, & Wolter

35000
Nr Right-Hand Witnesses
Nr Left-Hand Atomic Witnesses
30000

25000

20000

15000

10000

5000

0

lhs,A
Figure 8: Sizes cWtnrhs
(NCIn+1 , NCIn ) Consec (NCIn+1 , NCIn ) cWtn
utive ELHr -versions NCIn NCIn+1 NCI Thesaurus

T1
04.04j
04.11a
05.03d
06.02d
08.10e
08.12d
09.06e

T2
04.03n
04.09a
05.01d
06.01c
08.09d
08.11d
09.05d

| NC |
34245
35976
38020
45582
66052
68229
70493

| NR |
76
91
92
113
123
123
123

|cWtnrhs
|
252
106
138
419
1774
968
1305

|cWtnlhs,A
|

4926
4023
33487
1438
19055
4726
575

|cWtnlhs,dom
|

1
2
92
1
113
114
1

|cWtnlhs,ran
|

1
2
92
1
113
113
1

lhs
Figure 9: Detailed Results cWtnrhs
(T1 , T2 ) cWtn (T1 , T2 ) Selected Versions
NCI Thesaurus using Shared Signatures = sig(T1 ) sig(T2 )

682

fiThe Logical Difference Lightweight Description Logic EL

peaks atomic left-hand difference witnesses mostly resulted changes
general concepts. mentioned already, Goncalves et al. (2011) provide indepth analysis NCI versions. systematic comparison methods used Goncalves
et al. logical diff introduced paper would interesting, beyond
scope paper. One interesting observation made is, however,
peak atomic left-hand witnesses observed versions 05.01d 05.03d
correlates fact according Goncalves et al. large number non-redundant
axioms added version 05.03d. However, comparable number non-redundant
axioms added version 04.12g, peak atomic left-hand right-hand
witnesses observed analysis.
8.3 Scalability Analysis
demonstrated previous sections CEX2 capable finding logical difference two unmodified versions Snomed CT distinct versions
NCI thesaurus restricted ELHr . order see CEX2s performance scales,
tested randomly generated acyclic terminologies various sizes. randomly
generated terminology contains certain number defined- primitive concept names
role names. ratio concept equations concept inclusions fixed,
ratio existential restrictions conjunctions. random terminologies
generated varying number defined concept names using parameters SM09a:
62 role names; equality-inclusion ratio 0.525; exists-conjunction ratio 0.304.
every chosen size, generated 10 samples consisting two random terminologies
described above. applied CEX2 find logical difference two terminologies joint signature. Figure 10 shows average memory consumption CEX2
10 randomly generated terminologies various sizes. 10(a) maximum length
conjunctions fixed two (M=2), 10(b) number conjuncts conjunction randomly selected two M. seen performance
CEX2 crucially depends length conjunctions. 10(b), curves break
point CEX2 runs physical memory6 . instance, case M=22,
happens terminologies 7 500 defined concept names. Finally, note
time required CEX2 compare two random terminologies highly varied
across different samples. maximum time required CEX2 11 333 seconds.
8.4 Additional User Support Analysing Differences
far discussed experiments CEX2 one computes set concept
instance difference witnesses two terminologies. Clearly, witnesses
provide sufficient information detailed analysis logical difference two
terminologies. thorough analysis, required consider examples
cDiff (T1 , T2 ) iDiff (T1 , T2 ) show certain concept names concept/instance
difference witnesses. Thus, whenever searches concept names
exists C C v cDiff (T1 , T2 ), CEX2 output example concept inclusions
C v cDiff (T1 , T2 ). Similarly, requested, CEX2 compute example inclusions
6. cases classification terminologies CB already requires 3 GiB
memory.

683

fiKonev, Ludwig, Walther, & Wolter

1200

3500

3000

Memory Consumption MiB

Memory Consumption MiB

1000

800

600

400

2500

2000

1500

1000

200
500

M=10

M=2

M=22

0

Number Concept Names

95
00

85
00

75
00

65
00

55
00

45
00

35
00

25
00

15
00

50
0

10
00
0
30
00
0
50
00
0
70
00
0
90
00
0
11
00
00
13
00
00
15
00
00
17
00
0
19 0
00
00
21
00
00
23
00
00
25
00
00
27
00
00
29
00
0
31 0
00
00
33
00
00
35
00
00

0

Number Concept Names

(a) Short Conjunctions

(b) Long Conjunctions

Figure 10: Memory Consumption CEX2 Randomly Generated Terminologies
illustrating left-hand concept differences v C, r.> v C, ran(r) v C, examples
instance difference case. know Example 12 even minimal examples
exponential size input terminologies. practice, however, Snomed CT
NCI additional computation example inclusion every concept/instance
difference witness doubles times required computation. described
already, observed Table 2, computation times examples
shown last column computation times without examples shown
7th column. examples computed CEX2 often reasonable size. instance,
consider subset Specimen Material Type (Specmatyp) Table 2, holds
(i) exist 10 right-hand -concept witnesses, i.e. |cWtnrhs
(SM09b, SM09a)| = 10;
(SM09b, SM09a),
(ii) set left-hand atomic -concept difference witnesses, cWtnlhs,A

contains 46 concept names.
Point (i) (ii), longest concepts C, C v cDiff (SM09b, SM09a)
v cDiff (SM09b, SM09a) computed CEX2 twelve concept role
name occurrences (thus far smaller exponential worst case suggests).
computed difference witnesses example concept inclusions
witnesses, interest explain example concept inclusion entailed one
terminology other. Computing minimal subsets terminology entail
example concept inclusion promising approach explaining logical differences
known axiom pinpointing justification. supported CEX2,
investigated extensively various description logics including EL (Schlobach & Cornet,
2003; Baader, Penaloza, & Suntisrivaraporn, 2007; Kalyanpur, Parsia, Horridge, & Sirin,
2007; Horridge, Parsia, & Sattler, 2010; Penaloza & Sertkaya, 2010). illustrate
approach, consider subset Specimen Material Type (Specmatyp) Table 2.
CEX2 outputs
VenipunctureForBloodTest cWtnlhs,A
(SM09b, SM09a).

684

fiThe Logical Difference Lightweight Description Logic EL

(1)

LaboratoryTest v LaboratoryProcedure u EvaluationProcedure
BloodTest LaboratoryTest u roleGroup. hasSpecimen. BloodSpecimen

(2)

(3) VenipunctureForBloodTest (roleGroup.hasFocus .BloodTest)
u Venipuncture
u (roleGroup.((procedureSiteDirect.VenousStructure)
u (method.PunctureAction)))

Figure 11: Minimal Axiom Set
computes following concept inclusion (slightly simplified hand) member cDiff (SM09b, SM09a):
()

VenipunctureForBloodTest
v roleGroup.hasFocus.EvaluationProcedure

Using axiom pinpointing one compute minimal set inclusions SM09b
entails concept inclusion above; set shown Figure 11. Axioms 2 3
terminologies, SM09a contains
LaboratoryTest v LaboratoryProcedure
instead Axiom 1, explains difference two terminologies. Note
concept role names shaded grey. seen interaction
-concepts heavily depends inclusions built mainly non-concepts; actually none inclusions required derive () -inclusion.
finally note CEX2 text-based tool. order make accessible
ontology users, Protege plugin, LogDiffViz7 , created, calls CEX2 visualises
ontology versions differences hierarchical structure. LogDiffViz
provides basic axiom pinpointing. plugin distributed self-contained Java archive
file (JAR) CEX2 bundled.

9. Related Work
describe relationship work presented paper existing work
logical difference inseparability ontologies. Related work versioning distinction syntactical, structural, logic-based approaches versioning
discussed introduction already presented here. problem
deciding whether two ontologies -inseparable signature investigated many ontology languages different notions inseparability concept
inseparability, instance inseparability, conjunctive query inseparability, model-theoretic
inseparability (i.e., -reducts models first ontology coincide -reducts
models second ontology). Inseparability closely related notion conservative extensions since one ontology conservative extension another ontology
contains ontology subset inseparable w.r.t. signature
7. Available http://protegewiki.stanford.edu/wiki/Logical_Difference_Vizualiser_(LogDiffViz)

685

fiKonev, Ludwig, Walther, & Wolter

smaller ontology. Thus, algorithmic results deciding conservativity directly relevant inseparability well. tractability results presented paper sharp
contrast known results. start general EL-TBoxes: general ELTBoxes deciding inseparability conservative extensions ExpTime complete problems
concept, instance conjunctive queries. problems undecidable modeltheoretic inseparability model-theoretic conservative extensions (Lutz & Wolter, 2010).
(We note, however, model-theoretic case unexpected positive algorithmic results
obtained Konev, Lutz, et al., 2008, acyclic EL ALC extensions
inverse roles.) ALC standard extensions without nominals deciding concept
inseparability conservative extensions 2ExpTime-complete (Ghilardi, Lutz, & Wolter,
2006; Lutz et al., 2007; Lutz & Wolter, 2011) ALCQIO deciding concept inseparability conservative extensions becomes undecidable (Lutz et al., 2007; Cuenca Grau
et al., 2008). Nothing known ALC complexity inseparability instance
conjunctive queries. DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, &
Rosati, 2006), complexity concept, instance, query inseparability ranges
PSpace-hard (and ExpTime) description logic underlying OWL 2 QL standard, NP-complete DL-Litehorn , p2 -complete DL-Litebool (Konev, Kontchakov,
Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010). DLLitebool model-theoretic inseparability decidable (Kontchakov et al., 2010) DLLitecore concept, instance, query inseparability PTime (Konev et al., 2011).
contrast work presented paper, however, attempt made present
logical difference user two ontology inseparable. mentioned above,
work Konev et al. (2012), CEX2 extended conjunctive query difference case
acyclic ELHr -terminologies various experiments based NCI thesaurus
discussed.
work discussed far concerned logical difference inseparability description logic TBoxes. difference description logic concepts
investigated, example, work Teege (1994), Brandt, Kusters, Turhan
(2002) besides interest kind difference problems considered well
techniques employed rather different. Inseparability conservativity
ontologies given ontology languages expressive description logics (including first-order logic) considered work Kutz Mossakowski (2008,
2011). Similar relationships theories investigated answer set
programming (Pearce & Valverde, 2004; Eiter, Fink, & Woltran, 2007; Pearce & Valverde,
2012).
Finally, note Lemma 15 ABox constructed Figure 3 appear capture describe fundamental properties EL ELHr -terminologies.
applied investigate seemingly unrelated problems query containment ontology
based data access using EL-terminologies (Bienvenu, Lutz, & Wolter, 2012b) first-order
rewritability instance queries (Bienvenu, Lutz, & Wolter, 2012a).

10. Conclusion
paper, presented polytime algorithms decide concept, instance,
query-inseparability w.r.t. signature ELHr -terminologies compute represen686

fiThe Logical Difference Lightweight Description Logic EL

tation difference non-empty. Experiments using CEX2 based SNOMED
CT NCI show outputs given algorithm mostly reasonable size
analysed users. Many extensions, applications, open problems remain
explored. mention them:
(1) motivated study -inseparability terminologies problem comparing different versions terminology regarding say
certain signature. potential promising applications found area
decomposing composing ontologies. example, importing ontology
ontology 0 (i.e., forming 0 ) often important ensure 0
interfere signature . words, 0 conservative extension
sense consequences 0 signature coincide
consequences (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo,
Parsia, Sattler, & Schneider, 2011). observed already, -inseparability generalises conservative extensions and, therefore, algorithms used check whether
one terminology conservative extension another terminology. Algorithms checking
conservative extensions used extract modules ontologies (Cuenca Grau
et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009;
Konev et al., 2011). would interest explore applications inseparability
testing algorithms extract modules terminologies check conservativity.
(2) Inseparability defined paper mean one terminology
replaced another terminology every context. various applications inseparability
modularity important ensure T1 T2 -inseparable, T1
T2 -inseparable well, ontology . called replacement
property Konev, Lutz, Walther, Wolter (2009) exploited discussed,
example, work Cuenca Grau et al. (2008) Kontchakov et al. (2010).
notions inseparability introduced paper replacement property.
see this, let = {A, A0 , B, B 0 }

T1 =

v r.B
A0 r.B 0




T2 =

v r.B
A0 v r.B 0


.

T1 T2 -query inseparable (and, therefore, -concept -instance inseparable),
T1 even -concept inseparable T2 , = {B v B 0 }. Indeed,
observe (T1 ) |= v A0 , (T2 ) 6|= v A0 .
important open research problem determine complexity of, develop
algorithms strong versions inseparability replacement property EL
ELHr -terminologies.
(3) ELHr rather weak description logic. would great interest explore
far techniques developed ELHr applied ontologies contain additional constructors, still consist mainly ELHr -inclusions. unlikely tractable
sound complete algorithms interesting extensions exist, seems worth exploring algorithms sound incomplete extensions algorithms presented
paper. results direction presented Goncalves, Parsia, Sattler
(2012).
687

fiKonev, Ludwig, Walther, & Wolter

Acknowledgments
research supported EPSRC grant EP/H043594/1. would thank
William Gatens development LogDiffViz Protege plugin three anonymous
reviewers helpful comments.

Appendix A. Proofs Section 2
Lemma 1 every terminology , one construct polynomial time normalised
terminology 0 polynomial size |T | sig(T ) sig(T 0 ), 0 |= , every
model exists model J 0 = J X = X J every
X sig(T ). Moreover, 0 acyclic acyclic.
Proof. Given terminology , construct normalised terminology 0 five steps follows:
First, remove occurrences > conjunctions, replace C occurrence r.C,
C concept name >, fresh concept name add concept
definition C terminology. Repeat last step exhaustively.
Second, replace every ri .Bi inclusion right-hand side form F u
r1 .B1 u u rm .Bm (m 1), Bi either concept name Bi = >, F
conjunction concept names F 6= > 2, fresh concept name
Bi0 add concept definition Bi0 ri .Bi terminology.
Third, replace every inclusion form r.> two inclusions v r.>
r.> v terminology.
Fourth, consider concept name sequences B0 , . . . , Bn1
F0 , . . . , Fn , conjunctions concept names, terminology
contains concept definitions F0 Bi Fi+1 , < n, Bi conjunct
conjunct Fn . Let Fn0 conjunction concept names Fn except A. Let,
0
recursively, Fi1
result replacing conjunct Bi1 Fi1 conjunction
0
, 1 n. Replace concept definition F0 terminology
primitive concept definition v F00 .
Fifth, inclusion F , v F , r.> v F , ran(r) v F , F
conjunction concept names, replace every conjunct B F B F 0
terminology, F 0 conjunction non-conjunctive concept names, F 0 .
see construction indeed yields normalised terminology 0 , observe
steps 1, 2, 3 ensure inclusion one following forms: r.B,
F , E v r.B, E v r.>, E v F , B concept name, E either concept
name, form s.>, ran(s), F conjunction (possibly conjunctive)
concept names. Step 4 breaks cycles concept definitions Step 5 takes care
conjuncts conjunction concept names F right-hand side inclusion
form F , v F , r.> v F , ran(r) v F non-conjunctive concept names.
readily verified 0 acyclic acyclic none steps introduces cycles
concept definitions.
show 0 obtained polynomial time 0 polynomial
size |T |. Let n number inclusions c maximal length inclusions
right-hand side . Clearly, steps 1, 2 3 increase number
inclusions c n, raising total number inclusions 4nc. Steps 4
688

fiThe Logical Difference Lightweight Description Logic EL

5 increase number inclusions, length right-hand sides.
length right-hand side inclusion increase sum lengths
right-hand sides inclusions, i.e., 4nc2 upper bound right-hand
side. upper bound running time steps construction
therefore 16n2 c3 . Hence, size 0 running time construction
O(n2 c3 ).
Notice every new concept name occurs left-hand side unique concept
definition C 0 . Thus, every model expanded model J 0
interpreting fresh concept names sig(T 0 ) \ sig(T ) setting AJ = C .
Moreover, readily checked 0 |= .
prove extended version Theorem 2 according EL-concepts
concepts form ran(r) evaluated correctly canonical model IK ,
C u,u -concepts (which introduced Definition 57).
Theorem 2[Extended Version] Let K = (T , A) ELHr -KB.
1. IK model K;
2. IK computed polynomial time size K;
3. xC,D IK obj(A), C0 C u,u -concept form ran(r),

K |= C0 (a) if, if, aIK C0IK .
|= C u v C0 if, if, xC,D C0IK .
Proof. Point 2 follows fact instance checking ELHr done polynomial time.
first prove Point 3 EL-concepts C0 sub(T ). proof simultaneous
induction construction C0 . interesting step C0 = r.D0 .
start proof direction left right. Assume first K |= C0 (a).
(a, xran(r),D0 ) rIK . |= (ran(r) u D0 ) v D0 . Thus, induction
hypothesis, xran(r),D0 D0IK . C0IK , required. assume |= C uD v C0 .
(xC,D , xran(r),D0 ) rIK . |= (ran(r) u D0 ) v D0 . induction
hypothesis, xran(r),D0 D0IK . xC,D C0IK , required.
Conversely, assume aIK C0IK . exists IK (aIK , d) rIK
D0IK . Assume first = b obj(A). induction hypothesis, K |= D0 (b).
exists s(a, b) vT r. Thus, K |= C0 (a), required. Assume
= xran(s),F . K |= s.F (a), vT r xran(s),F D0IK . induction
hypothesis, |= ran(s) u F v D0 . Thus, K |= C0 (a), required.
assume xC,D C0IK . exists xran(s),F |= C u v s.F , vT r
xran(s),F D0IK . induction hypothesis, |= ran(s) u F v D0 . Thus |= C u v
r.D0 , required.
prove Point 3 concepts form C0 = ran(r). Assume K |= (ran(r))(a).
exist b s(b, a) vT r. ran(r)IK . Conversely,
689

fiKonev, Ludwig, Walther, & Wolter

assume ran(r)IK . Then, definition IK , exist b s(b, a)
vT r. Hence K |= (ran(r))(a), required.
Assume |= C u v ran(r). have, C = ran(s), vT r. xC,D
ran(r)IK since path WK tail xC,D . converse direction similar.
follows proved far IK model (T , A). Thus
proved Point 1, remains prove Point 3.
prove Point 3 arbitrary C u,u -concepts C0 . interesting step C0 = S.D0 ,
= r1 u u rn .
Assume first K |= C0 (a). C0IK since IK model K. Similarly,
|= C u v C0 , xC,D C0IK since xC,D (C u D)IK IK model .
Conversely, assume C0IK . exists IK (aIK , d) IK
D0IK . Assume first = b obj(A). induction hypothesis, K |= D0 (b).
every ri , 1 n, exists si si (a, b) si vT ri . Thus, K |= C0 (a),
required.
Assume = xran(s),F . K |= s.F (a), vT ri 1 n
xran(s),F D0IK . induction hypothesis, |= ran(s) u F v D0 . Thus, K |= C0 (a),
required.
assume xC,D C0IK . exists xran(s),F |= C u v s.F , vT ri ,
1 n, xran(s),F D0IK . induction hypothesis, |= ran(s) u F v D0 . Thus
|= C u v S.D0 , required.

Appendix B. Proofs Section 5
proofs, require models infinite sets concepts. introduce notation
well known result existence minimal models. Let (possibly
infinite) set C ran -concepts (which introduced Definition 32), ELHr -TBox,
either C u,u -concept (which introduced Definition 57) C ran -concept. write
|= say included w.r.t. if, every model ,
DI follows C C . following observation follows fact
C u,u C ran -concepts equivalent Horn formulas (in sense Chang
Keisler, 1990):
Lemma 67. ELHr -TBoxes sets C ran -concepts exists model
following equivalent, C u,u C ran -concepts D:
|= D;
DI .
come proof Lemma 36. convenience reader formulate
result again.
Lemma 36. every ELHr -TBox , ABox A, C ran -concepts C0 D0 ,
a0 obj(A):
n,ran
(T , A) |= D0 (a0 ) if, if, exists n 0 |= CA,a
v D0 ;
0

690

fiThe Logical Difference Lightweight Description Logic EL

|= C0 v D0 if, if, (T , AC0 ) |= D0 (aC0 ).
n,ran
(a0 )
Proof. prove Point 1. direction right left observe |= CA,a
0
n,ran
n 0. Thus, |= CA,a0 v D0 implies (T , A) |= D0 (a0 ).
ran |= . Then, using compactness,
assume (T , A) |= D0 (a0 ). show CA,a
0
0
n,ran
find n 0 |= CA,a0 v D0 , required.
ran 6|= . Take, every obj(A), model point
Assume CA,a
0

0

ran |= C.
da C ran -concepts C: da C Ia if, if, CA,a
models exist Lemma 67. may assume mutually disjoint. Take
following union models Ia :

= aobj(A) Ia ;

AI = aobj(A) AIa , NC ;

rI = aobj(A) rIa {(da , db ) | r0 (a, b) A, r0 vT r}, r NR ;

aI = da , obj(A).
Claim 1. C ran -concepts C obj(A) following holds Ia :
C Ia iff C .
proof induction construction C. interesting cases C = ran(r)
C = r.D direction right left.
Let
C assume first C = ran(r). Let C Ia (d0 , d) rI .
(d0 , d) aobj(A) rIa , claim follows definition. Otherwise, = da , d0 = db
n,ran
every n 0. Hence,
b r0 (b, a) r0 vT r. Thus, ran(r0 ) CA,a
ran


CA,a |= ran(r) obtain C .
Assume
r.D C Ia . Take d0 (d, d0 ) rI d0 DI .
C =
0

0
(d, ) a0 obj(A) r , C Ia follows immediately induction hypothesis.
Otherwise, = da d0 = db b r0 (a, b) r0 vT r. induction
ran |= D. compactness, exists concept E C ran
hypothesis, d0 DIb . Hence, CA,b
A,b
n,ran
every n > 0.
|= E v D. r0 (a, b) A, obtain r0 .E CA,a
ran |= r 0 .D obtain C Ia using r 0 v r. finishes proof
then, CA,a


claim.
Now, C v , let C , i.e. Ia obj(A).
Claim 1 C Ia , implies DIa C Ia DIa . conclude
DI applying Claim 1 again. Similarly, one show C = DI every
C rI sI every r v . follows model .
construction I, (aI , bI ) rI every r(a, b) A. Moreover, A(a)
ran |= A, implies AIa aI AI
obj(A), holds CA,a

ran 6|= ,
claim. thus infer model (T , A) 6|= D0 (a0 ) CA,a
0
0
Ia

implies da0 6 D0 0 aI0 6 D0I , Claim 1. Hence, (T , A) 6|= D0 (a0 )
derived contradiction.
proof Point 2 simple application definition.
691

fiKonev, Ludwig, Walther, & Wolter

prove cut elimination, correctness, completeness calculus ELHr
given Figures 1 5. start basic observations, easily proved
induction length derivations.
Lemma 68. ELHr -terminology , C ran -concepts C, role names r,

1. ` > v D, ` C v D;
2. ` C v v CA CA , ` C v CA ;
3. ` C v r.D ` C v r.(D u ran(r));
4. ` C v r.D, r.> v B , ` C v B;
5. ` C v ran(r) ran(r) v , ` C v A;
6. ` C v r.D, r v , ` C v s.D;
7. ` C v ran(r) r v , ` C v ran(s).
Lemma 69 (Cut elimination). ELHr -terminology , C ran -concepts C, D, E,
` C v ` v E ` C v E.
Proof. Let D1 derivation C v D2 derivation v E. Let Li
length Di , = 1, 2. proof lemma induction lexicographical
ordering pairs (L2 , L1 ).
case L2 = 0 L1 = 0, well cases L2 ends one
AndL1, AndL2, AndR, Ex, DefL, DefR PDefL virtually
proof Hofmann (2005). Assume D2 ends Dom, last sequent form
r.D0 v E, sequent B v E. Lemma 68, Item 4, ` C v r.D0
implies ` C v B, induction hypothesis, ` C v E.
cases D2 ends ExRan, Ran, Sub, RanSub dealt
similar way using Lemma 68, Items 3, 57.
Theorem 38. Let ELHr -terminology; C0 D0 C ran -concepts. |=
C0 v D0 if, if, ` C0 v D0 .
Proof. easily checked proof system rules sound ` C0 v D0 ,
|= C0 v D0 .
Conversely, assume |= C0 v D0 . prove ` C0 v D0 construct
interpretation based derivability sequents . show model
. consequence obtain C0I D0I conclude ` C0 v D0 based
properties I.
domain set well-formed pairs x = hC, RC i, C C ran -concept
RC finite set role names
l
NR : ` (C u
ran(r)) v ran(s), RC .
rRC

692

fiThe Logical Difference Lightweight Description Logic EL

introduce following abbreviation. Let
l
Ran(RC ) =
ran(r).
rRC

C ran -concepts C interpreted
I(C) = {hD, RD | ` (D u Ran(RD )) v C},
r NR interpreted
I(r) = {(hC, RC , hD, RD i) | r RD
` (C u Ran(RC )) v r.(D u Ran(RD ))}.
Note I(C) nonempty every C: consider R0C = {s NR | ` C v ran(s)}.
0
finite, R0C finite.
Notice that, Ax AndR, ` C v C u Ran(RC ) so,
Lemma 69, ` (C u rR0 ran(r)) v ran(s), s, ` C v ran(s), R0C .
C






is, C, R0C well-formed pair and, obviously, C, R0C I(C).
show I(C) = C C ran -concepts C. proof induction
construction C.
1. I(>) = .
well-formed pair hC, RC i, ` C u Ran(RC ) v > axiom.
2. I(C u D) = I(C) I(D).
Let hC, RC I(D1 u D2 ), ` (C u Ran(RC )) v (D1 u D2 ). Since ` (D1 u D2 ) v
D1 , Lemma 69, ` (C u Ran(RC )) v D1 , is, hC, RC I(D1 ). Similarly,
hC, RC I(D2 ).
Conversely, suppose hC, RC I(D1 ) hC, RC I(D2 ) holds, is, ` (C u
Ran(RC )) v D1 ` (C uRan(RC )) v D2 . AndR, ` (C uRan(RC )) v (D1 uD2 ),
is, hC, RC I(D1 u D2 ).
3. I(r.C) = {x | I(C) : (x, y) I(r)}.
Suppose well-formed pair hD, RD hD, RD I(r.C), `
(D u Ran(RD )) v r.C. Then, Lemma 68, Item 3, ` (D u Ran(RD )) v r.(C u ran(r)).
Consider RrC = {s NR | ` (C u ran(r)) v ran(s)}. Clearly, r RrC and, similarly
argument R0C above, hC, RrC well-formed pair. Ax AndR, `
Curan(r) v CuRan(RrC ), Ex, ` r.(Curan(r)) v r.(CuRan(RrC )) Lemma 69,
` (D u Ran(RD )) v r.(C u Ran(RrC )). Then, definition, (hD, RD , hC, RrC i) I(r)
and, since ` (C u Ran(RrC )) v C, hC, RrC I(C).
Conversely, let (hD1 , RD1 , hD2 , RD2 i) I(r) hD2 , RD2 I(C), is, ` (D1 u
Ran(RD1 )) v r.(D2 uRan(RD2 )), r RD2 , ` (D2 uRan(RD2 )) v C. Ex
` r.(D2 u Ran(RD2 )) v r.C, and, Lemma 69, ` (D1 u Ran(RD1 )) v r.C,
is, hD1 , RD1 I(r.C).
4. I(ran(r)) = {y | x : (x, y) I(r)}.
First show I(ran(r)) = {hC, RC | r RC }. r RC , `
C u Ran(RC ) v ran(r), is, I(ran(r)) {hC, RC | r RC }. Suppose hC, RC
I(ran(r)), is, ` (C u Ran(RC )) v ran(r). Then, since hC, RC well-formed pair,
r RC , is, I(ran(r)) {hC, RC | r RC }.
693

fiKonev, Ludwig, Walther, & Wolter

Suppose hC, RC I(ran(r)), is, hC, RC r RC . Let
denote (C u Ran(RC )). induction length derivations one see sequent
form r.D v ran(s) derivable NR . Therefore, hr.D, wellformed pair (hr.D, , hC, RC i) I(r). Conversely, let (hD1 , RD1 , hD2 , RD2 i) I(r)
then, particular, r RD2 . is, hD2 , RD2 I(ran(r)).
show model . need show axioms true
I.
1. I(X) I(CX ), whenever X CX X v CX .
Let hC, RC I(X), is, ` (C u Ran(RC )) v X. Lemma 68, Item 2, `
(C u Ran(RC )) v CX , is, hC, RC I(CX ).
2. I(CX ) I(X), whenever X CX .
Let hC, RC I(CX ), is, ` (C u Ran(RC )) v CX . Since Ax DefR
` CX v X, Lemma 69, ` (C u Ran(RC )) v X, hC, RC I(X).
3. (x, y) I(r) I(A), whenever ran(r) v .
Let (hC, RC , hD, RD i) I(r), is, ` (C u Ran(RC )) v r.(D u Ran(RD ))
r RD . Since r RD and, as, Ax Ran, ` ran(r) v A, AndL1, AndL2
` (D u Ran(RD )) v A, is, hD, RD I(A).
4. (x, y) I(r) x I(B), whenever r.> v B .
Let (hC, RC , hD, RD i) I(r), is, ` (C u Ran(RC )) v r.(D u Ran(RD ))
r RD . Notice that, Lemma 68, Item 4, ` (C u Ran(RC )) v B, is,
hC, RC I(B).
5. I(s) I(r), whenever v r .
Let (hC, RC , hD, RD I(r)), ` (C uRan(RC )) v r.(DuRan(RD )) r RD .
Lemma 68, Item 6, ` (C u Ran(RC )) v s.(D u Ran(RD )). Since r v ,
Ax RanSub, ` ran(r) v ran(s) ` (D u Ran(RD )) v ran(s) AndL1
AndL2. Since hD, RD well-formed, RD . Thus, (hC, RC , hD, RD i) I(s)



|= C0 v D0 , I(C0 ) I(D0 ). Since C0 , R0C0 I(C0 ),



C0 , R0C0 I(D0 ), ` (C0 u Ran(R0C0 )) v D0 . ` C0 v C0 u Ran(R0C0 ),
` C0 v D0 Lemma 69.
Proof Lemma 44. Let normalised ELHr -terminology signature. Additionally, let -ABox, sig(T ) non-conjunctive obj(A).
direction (1.) (2.), direct consequence construction ,
b obj(A) B sig(T ) non-conjunctive (T , A) 6|= B(b)
B obj(AT , ).
Assume (T , A) 6|= A(a). obj(AT , ). define -range simulation setting,
b obj(A) B sig(T ) non-conjunctive B obj(AT , ) :
(b, B ) if, if, (T , A) 6|= B(b),
(b, ) b obj(A).
show indeed -range simulation (a, ) verifying
conditions (S1)(S3) (RS) introduced page 663 hold.
694

fiThe Logical Difference Lightweight Description Logic EL

(S1)

(T , A) 6|= A(a) obj(AT , ), immediately follows (a, ) S.

(S2) Let (b, ) B(b) B . prove B() , .
= B B sig(T ) non-conjunctive , obtain definition
(T , A) 6|= B(b). Moreover, holds B 6 preC
(B) otherwise (T , A) |= B(b).
Thus, definition , (B) B(B ) , . = , immediately
follows B( ) , definition , .
(S3) Now, let (b, ) r(b, b0 ) r . prove exists
0 obj(AT , ) (b0 , 0 ) r(, 0 ) , . = , immediately follows
definition , r( , ) , (b0 , ) holds definition S.
= B B sig(T ) non-conjunctive follows definition
(T , A) 6|= B(b). Additionally, infer r 6 preDom
(B) otherwise
(T , A) |= (r.>)(b) would imply (T , A) |= B(b).
Consider cases B defined . B pseudo-primitive , obtain
definition , (B) r(B , ) , holds (b0 , ) definition
S.
B r0 .B 0 , distinguish following two cases. r 6
0

0
preRole
(r ), obtain r \ (preRoleT (r ) preDomT (B)) thus r(B , ) ,
definition , holds (b0 , ) definition S. case
0

0
r preRole
(r ), r preRoleT (r ) \ preDomT (B). Furthermore, (T , A) 6|=
0
0
B(b) (T , A) 6|= (r .B )(b), easy see must exist Bi00 non-conjT (B 0 )
00
00 0
r 6 preRan
(Bi ) (T , A) 6|= Bi (b ). r(B , Bi00 ) ,
0
definition , (B) (b , Bi00 ) definition S.
(RS) Let (b, ) r(c, b) r . show exists
0 r( 0 , ) , . = B B sig(T ) non-conjunctive , obtain
definition (T , A) 6|= B(b). Furthermore, r 6 preRan
(B)
otherwise (T , A) |= B(b). Thus, definition , (B) r( , B ) , .
= , follows definition , r( , ) , .
converse direction (2.) (1.), assume obj(AT , ) (A, a) ran

(AT , , ). sufficient show n
n,ran
6|= CA
vA
, ,A

implies (T , , ) 6|= A(A ) Lemma 36. obtain Lemma 42
(T , A) 6|= A(a) holds.
Thus, prove induction n every concept name B sig(T )
n,ran
non-conjunctive B obj(AT , ), 6|= CA
v B.
, ,B
Let n = 0 B sig(T ) non-conjunctive B obj(AT , ). follows

l
l
l
0,ran
0
CA
=
B
u
ran(s)
u
ran(s)
, ,B
B 0 \preC
(B)

s\preRan
(B)

695

Ar.BT
Bnon-conjT (B)


spreRole
(r)\(preDomT (A)preRanT (B))

fiKonev, Ludwig, Walther, & Wolter

0,ran
Hence, one see every subconcept form ran(s) occurs CA
,
, ,B

obtain 6 preRan
(B). B non-conjunctive , holds either B
pseudo-primitive B r0 .B 0 . Hence, Lemma 39 conclude
0,ran
6|= CA
v B.
, ,B
n > 0, let B sig(T ) non-conjunctive B obj(AT , ).
distinguish following two cases. B pseudo-primitive , obtain
n,ran
CA
=
, ,B

l

l

B0 u

s\preRan
(B)

B 0 \preC
(B)

l

ran(s) u

ran(s)

Ar.BT
Bnon-conjT (B)


spreRole
(r)\(preDomT (A)preRanT (B))

u

l

s.Cs

s\preDom
(B)
n,ran
v B.
C ran -concepts Cs . follows Lemma 39 6|= CA
, ,B
0
0
B r .B , obtain
n,ran
=
CA
, ,B

l
B 0 \preC
(B)

u

l

B0 u

s\preRan
(B)

l

ran(s)

Ar.BT
Bnon-conjT (B)


spreRole
(r)\(preDomT (A)preRanT (B))

l

s.Cs u


0
s\(preRole
(r )preDomT (B))

l

ran(s) u

n1,ran
s.CA
, , 00

B 00 non-conjT (B 0 )
0 )\(preDom (B)preRan (B 00 ))
spreRole
(r




B

C ran -concepts Cs . easy see conditions (e2), (e3) (e4) Lemma 39
n,ran
v B hold, condition (e1) would fulfilled.
hold. Thus, |= CA
, ,B
n,ran
n1,ran
B 00 non-conjT (B 0 )
CA
observe every subconcept s.CA
, ,B
, , 00
B

n1,ran


00
00
0
preRole
(r ) \ (preDomT (B) preRanT (B )), obtain 6|= CAT , , 00 v B
B

n1,ran
u ran(s) v B 0 Lemma 39
induction hypothesis. Thus, 6|= CA
, ,B 00
every B 00 s. infer condition (e1) hold and, therefore,
n,ran
v B.
6|= CA
, ,B

Appendix C. Proofs Section 6
Proof Lemma 54. Let normalised ELHr -terminology signature
NR 6= . Additionally, let NC concept name non-conjunctive
, let r role name, let C EL -concept. Finally, let = C
= ran(r) u C.
First observe obtain Lemma 36 6|= v holds if, if,
(T , AD ) 6|= A(aD ). Additionally, Lemma 44, (T , AD ) 6|= A(aD ) if, if,
obj(AT , ) (AD , aD ) ran
(AT , , ). Thus, sufficient show following
equivalence:

ran

(AD , aD ) ran
(AT , , ) r : (A )r obj(AT , ) (AD , aD ) (AT , , (A )r )

696

fiThe Logical Difference Lightweight Description Logic EL

Next note ABox AD role-splitting C EL-concept = ran(r) u C,
{ s(b, aD ) AD | b obj(AD ), sig(AD ) } = {r(aran , aD )}.
Assume first obj(AT , ), (AD , aD ) ran
(AT , , ) let obj(AD )obj(AT , )
corresponding -range simulation. define relation obj(AD ) obj(AT , )
setting every obj(AD ), every obj(AT , ) every role name r
r obj(AT , ):
(a, r )

(a, ) s(c, a) AD sig(AD ) c obj(AD ),
= r

Note well-defined AD role-splitting.
show -range simulation exists r sig(A,T ) (A )r
obj(AT , ) (aD , (A )r ) , prove conditions (S1)(S3) condition (RS)
page 663 hold.
(S1) exists s(c, aD ) AD sig(AD ) c obj(AD ),
exists 0 obj(AT , ) s( 0 , ) , (aD , ) -range simulation,
i.e. s(( 0 )s , (A )s ) , (A )s obj(AT , ). Hence, (aD , (A )s ) .
Otherwise, easy see exists r (A )r obj(AT , )
obj(AT , ) sig(AT , ) . Thus, (aD , ) S, (aD , (A )r ) .
(S2) Let (a, r ) A(a) AD obj(AD ), obj(AT , ),
r sig(AT , ). follows definition (a, ) S. Hence, -range
simulation, A() , , implies A(r ) , definition
, .
(S3) Let (a, r ) s(a, a0 ) AD a, a0 obj(AD ), obj(AT , ), r sig(AT , )
. definition obtain (a, ) S. Additionally, -range
simulation, exists 0 obj(AT , ) (a0 , 0 ) s(, 0 ) , . Thus,
s(r , s0 ) , definition , (a0 , s0 ) definition
AD role-splitting.
(RS) Let (a, r ) s(c, a) AD a, c obj(AD ), obj(AT , ), r sig(AT , )
. definition , (a, ) holds r = s. -range simulation,
exists 0 obj(AT , ) s( 0 , ) = r( 0 , ) , . Hence, r(r0 , r ) , holds
definition , .
converse direction, assume exists r (A )r obj(AT , )



(AD , aD ) ran
(AT , , (A )r ) holds. Let obj(AD ) obj(AT , ) corresponding
-range simulation. define relation obj(AD ) obj(AT , ) setting every
obj(AD ) every obj(AT , ):
(a, )



r sig(AT , ) : (a, r ) .

straightforward verify obj(AT , ) -range simulation
(aD , ) S.
697

fiKonev, Ludwig, Walther, & Wolter

Appendix D. Proofs Section 7
Proof Lemma 60. require preliminary observations. Let AC ABox
associated C ran -concept C (Lemma 36). Then, ELHr -terminology , C ran concept C C u,u concept D, |= C v if, K |= D(aC ),
K = (T , AC ). Theorem 2 (extended version),
|= C v if, if, IK |= D(aC ), IK canonical model K.
Note |= C v u.D if, if, DIK 6= d, d0 IK
R = t1 u u tn , (d, d0 ) RIK if, if, exists role name
(d, d0 ) sIK vT ti , = 1, . . . , n. summarise consequences require
proof below:
(i) C u -concept occurrences Si = ri,1 u . . . u ri,mi intersections roles,
1 k, |= C v if, if, exist role names si , 1 k,
si vT ri,j 1 k, 1 j mi |= C v D0 , D0 obtained
replacing Si si .
(ii) C u -concept, |= C v u.D if, if, exists sequence
r10 , . . . , rn0 IK |= (r10 . rn0 .D)(aran ) IK |= (r10 . rn0 .D)(aC ).
first case, exists subconcept (ran(r) u C 0 ) C (up commutativity
associativity u) |= r.C 0 v r10 . rn0 .D. second case
|= C v r10 . rn0 .D.



assume C = 1il ran(si )u 1jn Aj u 1km rk .Ck |= C v R1 .D.
Let R1 , . . . , Rk occurrences role intersections R1 .D, Ri = ri,1 u . . . u
ri,mi , 1 k. (i), find role names si , 1 k, si vT ri,j
1 k, 1 j mi |= C v D0 , D0 obtained replacing Ri
si . applying Lemma 39 |= C v s1 .D0 using t1 vT r1,j , 1 j m1
|= D0 v D, obtain one conditions (e1u ), (e2u ), (e3u ), (e4u ) must
hold.
second part lemma, first prove induction n 1 every C ran concept C every C u -concept |= C v r1 . rn .D least one
following conditions holds
(e1n ) exists subconcept r.C 0 C |= C 0 u ran(r)v D;
(e2n ) exists concept name C |= v u.D;
(e3n ) exists role name r C |= r.> v u.D;
(e4n ) exists role name r C |= ran(r) v u.D.
n = 1, let C C ran concept C u -concept |= C v r1 .D.
obtain least one conditions (e1u ), (e2u ), (e3u ), (e4u ) must hold
first part lemma, hence, one (e1n ), (e2n ), (e3n ), (e4n ) satisfied.
n > 1, let C C ran concept C u -concept |= C v r1 . rn .D.
apply first part lemma again, conditions (e2u ), (e3u ), (e4u )
fulfilled, conclude conditions (e2n ), (e3n ), (e4n ) satisfied.
698

fiThe Logical Difference Lightweight Description Logic EL

case (e1u ) holds, exists subconcept r.C 0 C |= C 0 u ran(r) v
r2 . rn .D. induction hypothesis obtain least one conditions
(e1n ), (e2n ), (e3n ), (e4n ) fulfilled |= C 0 u ran(r) v r2 . rn .D, thus
|= C v r1 . rn .D r sig(C) every subconcept C 0 subconcept
C.
Now, |= C v u.D C ran -concept C C u -concept D, (ii)
distinguish following two cases:
exists subconcept ran(r) u C 0 C sequence r10 , . . . , rn0 0 |=
r.C 0 v r10 . rn0 0 .D. n0 = 0, |= r.C 0 v condition (e6u )
holds. n0 1 obtain least one conditions (e1n ), (e2n ), (e3n ),
(e4n ) satisfied. (e1n ) holds, exists subconcept r0 .C 00 r.C 0
|= C 00 u ran(r0 ) v D. r.C 0 = r0 .C 00 , |= C 0 u ran(r) v D.
(C 0 u ran(r)) occurs top-level concept C, |= C v holds,
thus, condition (e5u ). Otherwise, exists subconcept s.((C 0 u ran(r)) u E)
C (e1u ) satisfied |= C 0 u ran(r) u E u ran(s) v D. r.C 0 6= r0 .C 00 , r0 .C 00
subconcept C 0 (thus, C) condition (e1u ) holds. Finally, one
conditions (e2n ), (e3n ), (e4n ) satisfied, one (e2u ), (e3u ), (e4u ) holds
(ii).
exists sequence r10 , . . . , rn0 0 |= C v r10 . rn0 0 .D. n0 = 0 condition
(e5u ) holds. n0 1, least one conditions (e1n ), (e2n ), (e3n ), (e4n )
holds. Then, (ii), conclude one conditions (e1u ), (e2u ), (e3u ),
(e4u ) satisfied well.

give translation C u,u -assertions conjunctive queries. similar
construction ABox C ran -concept given Section 5.1. First, given C u -concept
C, define path C finite sequence C0 R1 C1 . . . Rn Cn , C0 = C, n 0,
Ri+1 .Ci+1 conjunct Ci , 1 < n (Ri conjunctions role names). Let
xp p paths(C) pairwise distinct variable names set
XC = { s(xp , xq ) | p, q paths(C); q = p R C 0 , conjunct R }
{ A(xp ) | conjunct tail(p), p paths(C) }
Let ~x sequence
V variables XC except xC . conjunctive query qC,a
obtained ~x. XC replacing xC
Va. Finally,
V = D0 uu.D1 u uu.Dk
obtain conjunctive query qD,a ~x.( 0ik XD ), (we assume distinct

variables used every XDi , 0 k, ~x sequence variables except
xD0 ) replacing xD0 a.
prove Lemma 63 require preparation. Query answering closely related
existence certain homomorphisms interpretations. Let signature,
set individual names, I1 , I2 interpretations. function f : I1 I2 called
(O, )-homomorphism
f (aI1 ) = f (aI2 ) O;
699

fiKonev, Ludwig, Walther, & Wolter

AI1 implies f (d) AI2 ;
(d1 , d2 ) rI1 implies (f (d1 ), f (d2 )) rI2 r .
known (Chandra & Merlin, 1977) exists (O, )-homomorphism I1
I2 I1 |= q[~a] conjunctive -query q using individual names
~a = a1 , . . . , ak O, I2 |= q[~a].
proof slightly refine notion (O, )-homomorphism considering partial (O, )-homomorphisms domains satisfy certain conditions. Namely,
every n 0, call partial (O, )-homomorphism level n homomorphism
domain contains elements reachable -role chain length n either
named individual element without -predecessor. prove
every ELran,u,u -inclusion C v depth(C), depth(D) n, T1 |= C v implies
T2 |= C v D, exists partial level n homomorphism certain model
(T1 , A) certain model (T2 , A).
consider partial homomorphisms certain interpretations only,
introduce first. Let finite set individual names interpretation.
called O-named exists = aI . model called O-forest
(F1) everySd O-named, exists one d0
(d0 , d) rNR rI ;

(F2) infinite sequences d0 , d1 , . . . (di+1 , di ) rNR rI 0
di O-named.

(F3) (d, d0 ) rNR rI d0 O-named, O-named.
Let finite set individual names, n 0, signature. partial function f
O-forest model 0 called (O, n, )-homomorphism
0

(H1) O: aI domain f f (aI ) = aI ;
0

(H2) d, d0 domain f r : (d, d0 ) rI implies (f (d), f (d0 )) rI ;
0

(H3) domain f : AI implies f (d) AI ;
(H4) exist chain d1 , . . . , dm = (di , di+1 )
length > n O-named di , domain f .



r r





one prove following
Lemma 70. Suppose O-forest, 0 interpretation every > 0
exists (O, m, )-homomorphism 0 . Assume well |= q[~a] q
conjunctive -query using individual names ~a = a1 , . . . , ak O.
0 |= q[~a].
Proof. Assume ~a -match q(~x) = ~y .q 0 (~x, ~y ) ~a consists
elements O. (F2) (F3) definition O-forests (H1) (H4)
definition partial homomorphisms, exists > 0 (v), v ~x ~y ,
domain (O, m, )-homomorphism f . Take (O, m, )-homomorphism f .
~a 0 -match q(~x) 0 , 0 (v) = f ((v)), v ~x ~y .
700

fiThe Logical Difference Lightweight Description Logic EL

Finally, need technique constructing (O, m, )-homomorphisms. Let
interpretation. > 0, let
u
tIm,,u (d) = {C C
| depth(C) m, C },

where, above, depth(C) role-depth C; i.e., number nestings existential
restrictions C.
Lemma 71. Let finite signature let > 0 Suppose O-forest 0
interpretation
0

0

0

(in0) (aI , bI ) rI implies (aI , bI ) rI , a, b r ;
0

(in1) tIm,,u (aI ) tIm,,u
(aI ), O;
0
0

(d0 );
(d) tm,,u
(in2) exists d0 tm,,u

I0
exists (O, m, )-homomorphism g 0 .
Proof. construct g constructing sequence functions f0 , . . . , fm , : 0 ,
follows: domain dom(f0 ) f0 consists
aI

0
0
0
exist (d , d) r rI . aI set f0 (aI ) = aI .
every remaining dom(f0 ) choose d0 according (in2) set f0 (d) = d0 . Observe
tm,,u
(d) tIm,,u
(f0 (d)) dom(f0 ).
0

suppose fn constructed
(fn (d)) dom(fn );
(d) tmn,,u
(in3) tmn,,u

I0
(in4) n > 0: dom(fn ) if, if, O-named exists sequence
d0 r1I d1 r2I rnI dn = d0 O-named ri d0
dom(f0 ).

construct fn+1 consider dom(fn ) O-named d0 (d, d0 ) r rI .
0
0

u
0

domain fn+1 consists . Let Rd,d = {r | (d, ) r } Rd,d0 =
( rR 0 r).
d,d
l
u
Rd,d
tmn,,u
(d)
0.

mn1,,u 0
(d )
DtI

(in3),
u
Rd,d
0.

l

tImn,,u
(fn (d))
0

mn1,,u 0
DtI
(d )
0

Thus, choose e (fn (d), e) rI r Rd,d0 tImn1,,u (d0 )
tmn1,,u
(e) set fn+1 (d0 ) = e. defines fn+1 . Observe fn+1 wellI0
defined (F1). Observe fn+1 properties (in3) (in4), (F3).

set g = 0nm fm . readily checked g required.
701

fiKonev, Ludwig, Walther, & Wolter

position prove Lemma 63.
Lemma 63 qDiff (T1 , T2 ), exists 0 cDiff ran,u,u
(T1 , T2 ) sig(0 )

sig().
Proof. Assume T1 T2 given let (A, q(~a)) qDiff (T1 , T2 ). Let 0 = sig(A)
sig(q). Assume that, contrast shown,
T1 |=

()



T2 |=

ELran,u,u -inclusions sig() 0 .
Consider model 0 (T2 , A) 0 6|= q[~a]. Lemma 70, obtain contradiction
exists obj(A)-forest model (T1 , A) every n > 0
exists (obj(A), n, 0 )-homomorphism fn 0 .
0
Take, every obj(A) model Ia0 T1 da Ia C ran C u,u concepts C:
0
da C Ia T1 tI 0 (a) |= C


0

0


ran
C }.
tI 0 (a) = {C C
0 |

interpretations Ia0 exist Lemma 67. define unfolding
Ia Ia0 . path

Ia0 finite sequence d0 R1 d1 . . . Rn dn , n 0, Ri+1 = Ri+1 set Ri+1
0
role names r Ri+1 iff (di , di+1 ) rIa , < n. path p, tail(p) denotes
last element p. let Ia consist paths Ia0 set
0

AIa = {p Ia | tail(p) AIa };
rIa = {(d, dRd0 ) Ia Ia | r R}.
Ia O-forest = . Moreover, C u,u -concepts C p Ia :
()

p C Ia



0

tail(p) C Ia .

particular, Ia still model T1 .
Take following (disjoint) union interpretations Ia :

= aobj(A) Ia ;

AI = aobj(A) AIa , NC ;

rI = aobj(A) rIa {(da , db ) | r0 (a, b) A, r0 vT1 r}, r NR ;
aI = da , obj(A).
show obj(A)-forest, model (T1 , A) exist (obj(A), n, )homomorphisms 0 n > 0. First observe following:
Claim 1. EL concepts C Ia :
C C Ia
702

fiThe Logical Difference Lightweight Description Logic EL

proof induction construction C. interesting case C = r.D
direction left right.
Assume C Ia . Take d0 (d, d0 ) rI

d0 DI . (d, d0 ) a0 obj(A) rIa0 , C Ia follows immediately induction
hypothesis. Otherwise, = da , d0 = db b r0 (a, b) r0 vT1 r.
induction hypothesis, d0 DIb . Hence, (), T1 tI 0 (b) |= D. compactness,
exists concept E tI 0 (b) T1 |= E v D. obtain r0 .E tI 0 (a).
T1 |= r0 .E v r0 .D obtain da C Ia using r0 vT1 r ().
Claim 2. obj(A)-forest model (T1 , A).
obj(A)-forest model follows construction. remains
show model T1 . role inclusions r v T1 follows construction
rI sI . Suppose C1 v C2 T1 . C1 EL-concept, |= C1 v C2 follows
Claim 1 condition Ia models T1 . assume C1 = ran(r)
let ran(r)I . 6= da a, C2I since Ia models T1 . = da ,
exists r0 (b, a) r0 vT1 r. ran(r0 ) tI 0 (a), T1 tI 0 (a) |= C2 .
Hence, (), da C2Ia , i.e. da C2I Claim 1.
Claim 3. every n > 0 exists (obj(A), n, 0 )-homomorphism 0 .
Lemma 71, sufficient show conditions (in0), (in1), (in2). Condition (in0)
follows directly (). Condition (in1) proved induction construction C.
interesting step C = S.D = r1 u u rm . Let obj(A) C
0
tIn, ,u (aI ). Take d0 (aI , d0 ) d0 DI . d0 Ia , then, (), T1 tI 0 (a) |=
0 ,u
0
(aI ). assume
S.D. () compactness, T2 tI 0 (a) |= S.D. Hence C tIn,
0
d0 6 Ia . r10 , . . . , rk0 b d0 = bI ri0 (a, b) 1 k
0
every 1 exists 1 j rj0 vT1 ri . tIn, ,u (bI ).
0

0

,u
(b ). (), every 1 j exists
induction hypothesis tn,
I0
0 ,u
0
0
1 j k rj vT2 ri . C tIn,
(aI ), required.
0

(in2), let C = Dtn,0 ,u (d) D. 6= aI obj(A),


() exists b obj(A) T1 tI 0 (b) |= u.C. compactness (),
0 ,u
0 ,u
0
(d) tn,
(d0 ), required.
T2 tI 0 (b) |= u.C. Hence, exists d0 tn,

I0
0
= aI obj(A), then, (in1) shown above, d0 = aI required.
finishes proof Lemma 63.

References
Baader, F., Brandt, S., & Lutz, C. (2008). Pushing EL envelope further. Proceedings
6th International Workshop OWL: Experiences Directions (OWLED
2009), Vol. 529 CEUR Workshop Proceedings. CEUR-WS.org.
Baader, F., Penaloza, R., & Suntisrivaraporn, B. (2007). Pinpointing description
logic EL+ . Proceedings 30th Annual German Conference Artificial Intelligence (KI 2007), Vol. 4667 Lecture Notes Computer Science, pp. 5267,
Heidelberg/Berlin, Germany. Springer Verlag.
703

fiKonev, Ludwig, Walther, & Wolter

Baader, F. (2003). Terminological cycles description logic existential restrictions.
Proceedings 18th International Joint Conference Artificial Intelligence
(IJCAI 2003), pp. 325330, San Francisco, CA, USA. Morgan Kaufmann.
Bienvenu, M., Lutz, C., & Wolter, F. (2012a). Deciding FO-rewritability EL. Proceedings 25th International Workshop Description Logics (DL 2012).
Bienvenu, M., Lutz, C., & Wolter, F. (2012b). Query containment description logics revisited. Proceedings 13th International Conference Principles Knowledge
Representation Reasoning (KR 2012).
Brandt, S., Kusters, R., & Turhan, A.-Y. (2002). Approximation difference description logics. Proceedings 8th International Conference Principles
Knowledge Representation Reasoning (KR-02), pp. 203214, San Francisco, CA,
USA. Morgan Kaufmann.
Calvanese, D., Giacomo, G. D., Lembo, D., Lenzerini, M., & Rosati, R. (2006). Data
complexity query answering description logics. Proceedings Tenth
International Conference Principles Knowledge Representation Reasoning
(KR 2006), pp. 260270.
Chandra, A. K., & Merlin, P. M. (1977). Optimal implementation conjunctive queries
relational data bases. Proceedings 9th Annual ACM Symposium Theory
Computing (STOC 77), pp. 7790, New York, NY, USA. ACM.
Chang, C. C., & Keisler, H. J. (1990). Model Theory, Vol. 73 Studies Logic
Foundations Mathematics. Elsevier, Amsterdam, Netherlands.
Clarke, E., & Schlingloff, H. (2001). Model checking. Handbook Automated Reasoning,
Vol. II, chap. 24, pp. 16351790. Elsevier, Amsterdam, Netherlands.
Conradi, R., & Westfechtel, B. (1998). Version models software configuration management. ACM Computing Surveys (CSUR), 30 (2), 232282.
Crafa, S., Ranzato, F., & Tapparo, F. (2011). Saving space time efficient simulation
algorithm. Fundamenta Informaticae, 108 (1-2), 2342.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2008). Modular reuse ontologies: theory practice. Journal Artificial Intelligence Research (JAIR), 31,
273318.
Delaitre, V., & Kazakov, Y. (2009). Classifying ELH ontologies SQL databases.
Proceedings 6th International Workshop OWL: Experiences Directions
(OWLED 2009), Vol. 529 CEUR Workshop Proceedings. CEUR-WS.org.
Eiter, T., Fink, M., & Woltran, S. (2007). Semantical characterizations complexity
equivalences answer set programming. ACM Transactions Computational Logic,
8 (3).
Ghilardi, S., Lutz, C., & Wolter, F. (2006). damage ontology? case conservative extensions description logic. Proceedings Tenth International
Conference Principles Knowledge Representation Reasoning (KR 2006),
pp. 187197, Menlo Park, CA, USA. AAAI Press.
704

fiThe Logical Difference Lightweight Description Logic EL

Golbeck, J., Fragaso, G., Hartel, F., Hendler, J., Oberhaler, J., & Parsia, B. (2003).
National Cancer Institutes thesaurus ontology. Journal Web Semantics, 1 (1),
7580.
Goncalves, R. S., Parsia, B., & Sattler, U. (2011). Analysing multiple versions ontology:
study NCI thesaurus. Proceedings 24th International Workshop
Description Logics (DL 2011), Vol. 745 CEUR Workshop Proceedings. CEURWS.org.
Goncalves, R. S., Parsia, B., & Sattler, U. (2012). Concept-based semantic difference
expressive description logics. Proceedings 25th International Workshop
Description Logics (DL 2012).
Hofmann, M. (2005). Proof-theoretic approach description-logic. Proceedings
20th Annual IEEE Symposium Logic Computer Science (LICS 2005), pp. 229
237, Washington, DC, USA. IEEE Computer Society.
Horridge, M., Parsia, B., & Sattler, U. (2010). Justification oriented proofs OWL.
Proceedings 9th International Semantic Web Conference (ISWC 2010), Vol.
6496 Lecture Notes Computer Science, pp. 354369, Berlin/Heidelberg, Germany.
Springer-Verlag.
IHTSDO (2008). SNOMED Clinical Terms User Guide. International Health Terminology Standards Development Organisation (IHTSDO). Available
http://www.ihtsdo.org/publications/introducing-snomed-ct/.
Jimenez-Ruiz, E., Cuenca Grau, B., Horrocks, I., & Llavori, R. B. (2011). Supporting
concurrent ontology development: Framework, algorithms tool. Data & Knowledge
Engineering, 70 (1), 146164.
Kalyanpur, A., Parsia, B., Horridge, M., & Sirin, E. (2007). Finding justifications
OWL DL entailments. Proceedings 6th International 2nd Asian Semantic
Web Conference (ISWC07+ASWC07), pp. 267280, Berlin/Heidelberg, Germany.
Springer Verlag.
Kazakov, Y. (2009). Consequence-driven reasoning Horn SHIQ ontologies. Proceedings
21st International Conference Artificial Intelligence (IJCAI 2009), pp. 2040
2045.
Kazakov, Y., Krotzsch, M., & Simancik, F. (2011). Unchain EL reasoner. Proceedings 24th International Workshop Description Logics (DL 2011), CEUR
Workshop Proceedings. CEUR-WS.org.
Klein, M. C. A., Fensel, D., Kiryakov, A., & Ognyanov, D. (2002). Ontology versioning
change detection web. Knowledge Engineering Knowledge Management:
Ontologies Semantic Web, Vol. 2473 Lecture Notes Computer Science,
pp. 247259. Springer Verlag, Berlin/Heidelberg, Germany.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2008). Semantic modularity module
extraction description logic. Proceedings 18th European Conference
Artificial Intelligence (ECAI 2008), Vol. 178 Frontiers Artificial Intelligence
Applications, pp. 5559, Amsterdam, Netherlands. IOS Press.
705

fiKonev, Ludwig, Walther, & Wolter

Konev, B., Walther, D., & Wolter, F. (2008). logical difference problem description
logic terminologies. Proceedings 4th International Joint Conference Automated Reasoning (IJCAR 2008), Vol. 5195 Lecture Notes Computer Science,
pp. 259274, Berlin/Heidelberg, Germany. Springer Verlag.
Konev, B., Kontchakov, R., Ludwig, M., Schneider, T., Wolter, F., & Zakharyaschev, M.
(2011). Conjunctive query inseparability OWL 2 QL TBoxes. Proceedings
25th Conference Artificial Intelligence (AAAI 2011), Menlo Park, CA, USA.
AAAI Press.
Konev, B., Ludwig, M., & Wolter, F. (2012). Logical difference computation CEX2.5.
Proceedings 6th International Joint Conference Automated Reasoning
(IJCAR 2012), Lecture Notes Computer Science, Berlin/Heidelberg, Germany.
Springer.
Konev, B., Lutz, C., Walther, D., & Wolter, F. (2009). Formal properties modularisation.
Modular Ontologies, pp. 2566. Springer Verlag, Berlin/Heidelberg, Germany.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2010). Logic-based ontology comparison
module extraction, application DL-Lite. Artificial Intelligence, 174 (15),
10931141.
Kontchakov, R., Pulina, L., Sattler, U., Schneider, T., Selmer, P., Wolter, F., & Zakharyaschev, M. (2009). Minimal module extraction DL-Lite ontologies using
QBF solvers. Proceedings 21st International Joint Conference Artificial
Intelligence (IJCAI 2009), pp. 836841, San Francisco, CA, USA. Morgan Kaufmann.
Kutz, O., & Mossakowski, T. (2008). Conservativity structured ontologies. Proceedings
18th European Conference Artificial Intelligence (ECAI 2008), Vol. 178
Frontiers Artificial Intelligence Applications, pp. 8993, Amsterdam,
Netherlands. IOS Press.
Kutz, O., & Mossakowski, T. (2011). modular consistency proof DOLCE. Proceedings 25th Conference Artificial Intelligence (AAAI 2011), Menlo Park, CA,
USA. AAAI Press.
Kremen, P., Smd, M., & Kouba, Z. (2011). OWLDiff: practical tool comparison
merge OWL ontologies. Proceedings 10th International Workshop Web
Semantics, pp. 229233, Los Alamitos, CA, USA. IEEE Computer Society Press.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering description
logic EL using relational database system. Proceedings 21st International
Joint Conference Artificial Intelligence (IJCAI 2009), pp. 20702075, Menlo Park,
CA, USA. AAAI Press.
Lutz, C., Walther, D., & Wolter, F. (2007). Conservative extensions expressive description logics. Proceedings 20th International Joint Conference Artificial
Intelligence (IJCAI 2007), pp. 453458, Menlo Park, CA, USA. AAAI Press.
Lutz, C., & Wolter, F. (2010). Deciding inseparability conservative extensions
description logic EL. Journal Symbolic Computing, 45 (2), 194228.
Lutz, C., & Wolter, F. (2011). Foundations uniform interpolation forgetting expressive description logics. Proceedings 22nd International Joint Conference
706

fiThe Logical Difference Lightweight Description Logic EL

Artificial Intelligence (IJCAI 2011), pp. 989995, Menlo Park, CA, USA. AAAI
Press.
Mendez, J., & Suntisrivaraporn, B. (2009). Reintroducing CEL OWL 2 EL reasoner.
Proceedings 22nd International Workshop Description Logics (DL 2009),
Vol. 477 CEUR Workshop Proceedings. CEUR-WS.org.
Noy, N. F., & Musen, M. A. (2002). PromptDiff: fixed-point algorithm comparing
ontology versions. Proceedings 18th national conference Artificial intelligence, pp. 744750, Menlo Park, CA, USA. AAAI Press.
Ohst, D., Welle, M., & Kelter, U. (2003). Differences versions UML diagrams.
Proceedings 9th European software engineering conference held jointly
11th ACM SIGSOFT international symposium Foundations software engineering
(ESEC03/SIGSOFT FSE03), pp. 227236, New York, NY, USA. ACM.
Oliver, D. E., Shahar, Y., Shortliffe, E. H., & Musen, M. A. (1999). Representation
change controlled medical terminologies. Artificial Intelligence Medicine, 15 (1),
5376.
Palma, R., Haase, P., Corcho, O., & Gomez-Perez, A. (2009). Change representation
OWL 2 ontologies. Proceedings 6th International Workshop OWL: Experiences Directions (OWLED 2009), Vol. 529 CEUR Workshop Proceedings.
CEUR-WS.org.
Pearce, D., & Valverde, A. (2004). Uniform equivalence equilibrium logic logic programs. Proceedings 7th International Conference Logic Programming
Nonmonotonic Reasoning (LPNMR 2004), Vol. 2923 Lecture Notes Computer
Science, pp. 194206, Berlin/Heidelberg, Germany. Springer.
Pearce, D., & Valverde, A. (2012). Synonymous theories knowledge representations
answer set programming. Journal Computer System Sciences, 78 (1), 86104.
Penaloza, R., & Sertkaya, B. (2010). complexity axiom pinpointing EL
family description logics. Proceedings 12th International Conference
Principles Knowledge Representation Reasoning (KR 2010), Menlo Park, CA,
USA. AAAI Press.
Poggi, A., Lembo, D., Calvanese, D., Giacomo, G. D., Lenzerini, M., & Rosati, R. (2008).
Linking data ontologies. Journal Data Semantics, 10, 133173.
Redmond, T., Smith, M., Drummond, N., & Tudorache, T. (2008). Managing change:
ontology version control system. Proceedings 5th International Workshop
OWL: Experiences Directions (OWLED 2008), Vol. 432 CEUR Workshop
Proceedings. CEUR-WS.org.
Rosati, R. (2007). conjunctive query answering EL. Proceedings 2007
International Workshop Description Logic (DL 2007), Vol. 250 CEUR Workshop
Proceedings. CEUR-WS.org.
Schlobach, S., & Cornet, R. (2003). Non-standard reasoning services debugging
description logic terminologies. Proceedings 18th International Joint Conference Artificial Intelligence (IJCAI 2003), pp. 355362, San Francisco, CA, USA.
Morgan Kaufmann.
707

fiKonev, Ludwig, Walther, & Wolter

Teege, G. (1994). Making difference: subtraction operation description logics.
Proceedings 4th International Conference Principles Knowledge Representation Reasoning (KR94), pp. 540550, San Francisco, CA, USA. Morgan
Kaufmann.
van Glabbeek, R. J., & Ploeger, B. (2008). Correcting space-efficient simulation algorithm.
Proceedings 20th International Conference Computer Aided Verification
(CAV 2008), Vol. 5123 Lecture Notes Computer Science, pp. 517529, Heidelberg/Berlin, Germany. Springer Verlag.
Vescovo, C. D., Parsia, B., Sattler, U., & Schneider, T. (2011). modular structure
ontology: Atomic decomposition. Proceedings 22nd International Joint
Conference Artificial Intelligence (IJCAI 2011), pp. 22322237, Menlo Park, CA,
USA. AAAI Press.

708


