journal artificial intelligence

submitted published

limits compact plan representations
christer backstrom
peter jonsson

christer backstrom liu se
peter jonsson liu se

department computer science
linkoping university
se linkoping sweden

abstract
compact representations objects common concept computer science automated viewed case concept instance compact
implicit representation graph path plan graph
graphs represented compactly instances paths
usually represented explicitly sequences actions cases known
plans compact representations example macros
extend general case proving number bounds compact
representations plans criteria efficient sequential random access
actions addition consequences
gained reformulating contrast
prove number positive demonstrating restricted cases plans
useful compact representations well proving macro plans favourable access
properties finally discussed relation relevant contexts

introduction
usage study representations objects much smaller objects
commonplace computer science us encounter representations
daily basis form zipped files mp files etc practical cases usually
talk compressed objects terms compact succinct common
theoretical studies meaning terms vary common interesting case
size representation polylogarithmic size object
sometimes sufficient compute compact representation object instance
archiving file cases representation must support operations
efficiently without first unpacking object explicit representation performing
operations compact representation often harder performing operation
explicit object cases compact representation make easier
emphasising inherent structure object
one archetypical case compact representations automated although
seldom viewed way instance implicit representation graph
typically exponentially larger representation instance
solutions plans paths graph consider example strips instance
n variables variables implicitly define state space n states action
preconditions define nm arcs graph similarly define instances
paths exponential length although instances already
c

ai access foundation rights reserved

fibackstrom jonsson

compact representations little attention paid compact representations
solutions usually represented explicitly introduces analyses
number compact representations
first turn computer science general compact representations
arbitrary strings intensively studied field example charikar et al
rytter address approximating smallest string representation
compressed grammar bille et al representations permit efficient
access matching operations jansson sadakane sung demonstrate
representations efficient edit operations structured objects arbitrary strings
potentially compact representations following examples
displaying positive well negative areas galperin wigderson
wagner study complexity common graph operations
graphs implicitly represented circuits tell whether two vertices connected
balcazar uses variant study complexity search ai
circuit generates adjacency list vertex bulatov dalmau
present efficient certain csp relies compact
representation set solutions liberatore schaerf study preprocessing
model checking focus size preprocessed parts cadoli et al study
formalisms knowledge representation study modelled one
formalism transformed another formalism polynomially larger
representation
one compact representations areas use macros
concept widely used long time although seldom
purpose providing compact representations exception following case
class jonsson backstrom b instances property optimal
plans exponential length possible decide polynomial time
plan gimenez jonsson showed plans class
polynomial size representation macros macro plans even
generated polynomial time although plan may exponential length
thus necessarily take exponential time generate possible generate compact
representation polynomial time jonsson later demonstrated similar
number classes although particular classes instances may
still restricted much practical use principle compressing solution
macros interesting tool plan explanation
approaches compact plan representation appear sparingly literature
notable exception liberatore studies two concepts plan representation
efficient random access efficient sequential access respectively macro
plans examples representing one long plan compactly might consider
representing large set plans compactly instance plan recognition may
simultaneously consider exponential number candidate plans geib although
seldom viewed way reactive plan representation large set plans
one state goal reached however known reactive
plans cannot compact efficient correct general case jonsson haslum
backstrom although properties important instance spaceship
applications williams pandurang nayak pomdps may similarly thought


fialgorithms limits compact plan representations

probabilistic variant reactive plans compactness representations important
case boutilier poole yet another case size plan
big plan necessarily long occur types branching
plans contingent bonet geffner three different concepts
isolated instance bonet casts contingent
conformant branching plan represented one
long non branching plan branches appearing subplans cases
interesting know objects question compact representations although
compact representation save space may secondary many cases
important aspect object compact representation object
inherent structure may exploit purposes instance represent
set many plans representation recursive macros similar emphasize
differences similarities plans make comparisons
operations plans efficient similarly case branching plans might
want exploit structure clearly displays two branches common
differ
positive macro representations gimenez jonsson jonsson
prompt obvious question whether long plans compressed macros
method unlikely matter type
compact representation try use macro plans finite automata whatever
remainder organized follows section introduces basic notation
concepts well framework used contains
useful definitions complexity first ask section whether
optimal plans instance compact representations answer
possible neither macros method however
exclude plans instance compact solutions section
thus restrict question whether uniform compact representation one plan
solvable instance precisely ask corresponds
one compact representation solvable instance
unlikely exist must able access actions plan useful way
section turn non uniform case asking solvable instance least
one plan compact representation primarily consider representations
efficiently access actions plan sequentially randomly
seems unlikely general case interesting special cases
representations exist section investigate macro representations
extend gimenez jonsson two ways prove plans
polynomial size macro representation random accessed polynomial
time without access full plan however prove cannot
represent plans compactly macros section analyse whether get around
long plans reformulating
answered negatively actually ask plan original
inherently intractable reformulation however even considering
decision still seems possible make simpler reformulation
finally section contains discussion related
relevant topics adding information guide planners causal graphs


fibackstrom jonsson

plan explanation ends summary together list
open questions
appeared previous conference publication
backstrom jonsson b

preliminaries
section consists three parts first part introduces general notation
terminology used second part defines two frameworks used
finite functional propositional strips presents
constructions frequently used third part briefly recapitulates concept
advice taking turing machines defines sat used
several occasions
general notation terminology
sequence objects x x xn written hx x xn hi denoting empty
sequence given set x objects set sequences x including hi denoted
x set sequence aggregation x objects write x denote
cardinality number objects x write x denote size number
bits representation x composition two functions f g denoted
f g defined f g x f g x
negation propositional atom x denoted x literal atom
negation set l x literals set x atoms defined l x
x x x x negation extended literals literal negation
extended sets x set literals x x let
subset l x set x atoms p os x x x set
atoms appear positive n eg x x x set atoms
appear negated atoms p os n eg set consistent p os
n eg empty set z atoms satisfies p os z n eg z
update operator n binary function given set x atoms set
literals x n set atoms defined x n x n eg p os

positive compact representations want apply general
powerful languages possible hold languages
restricted hence use finite functional formalism backstrom
jonsson makes minimum assumption language except
ground language state variables finite domains
definition finite functional ffp frame tuple hv ai v
implicitly ordered set variables v n domain function maps every variable
finite subset natural numbers set actions frame implicitly
defines state space f v vn v vn variables
v order members f referred states action two
associated total functions precondition pre f postcondition


fialgorithms limits compact plan representations

post f f pairs states f actions

pre
post
sequence ha plan state f state f

hi
states f ai si si
ffp instance tuple p hv gi f hv ai ffp frame
f state g f total function state f goal
state p g goal g reachable state f plan
goal state p solution p plan goal state f
solution p called plan p
complexity computing pre postconditions actions goal
function referred step complexity consider subclass
ffp p consists ffp frames instances polynomial step complexity
occasionally consider restrictions ffp p use notation ffp p
class ffp frames f instances p action pre postconditions
g computed p f time p p time p polynomial
furthermore say ffp p instance p hv gi deterministic
p p plan one
pre instance deterministic planner never faced
choice two actions
proving compact representation exist gets stronger
use weaker formalism want use restricted formalism possible
since automatically apply formalisms expressive
hence use propositional strips number common
variants propositional strips known equivalent
sas formalism strong form polynomial reduction backstrom
refer strips variant called propositional strips
negative goals psn backstrom defined special case ffp p
uses binary variables define traditional way treating variables
propositional atoms
definition strips frame tuple f hv ai v set propositional atoms
set actions state space defined f v states subsets
v action precondition pre postcondition post
consistent sets literals v pairs states f actions

satisfies pre
n post
sequence ha plan state f state f

hi
states f ai si si


fibackstrom jonsson

strips instance tuple p hv gi f hv ai strips frame
state f g consistent set literals v state f goal state
p satisfies g goal g reachable state f plan
goal state p solution p plan goal state f
solution p called plan p
notation x frequently used define action precondition x
postcondition
negative proven hold strips however cases
hold even many restricted subclasses strips would lead far survey
cases use restriction unary actions archetypical case
throughout
definition strips action unary post set strips actions unary
actions unary strips frame instance unary action set unary
unary actions may seem limiting restriction demonstrated
sufficient many cases use board controllers spacecrafts muscettola et al
brafman domshlak surprising though since strips
pspace complete remains even restricted unary actions bylander
given strips instance possible construct corresponding strips instance
unary following reduction unary instances simplified strips version
reduction used sas backstrom proof theorem
construction let p hv gi strips instance construct corresponding

instance p hv g follows define vlock vlock
let v



v vlock g g vlock define contains
following actions

abegin pre vlock vlock


aend post vlock vlock
post
ai vlock


leave without proof construction polynomial reduction class
strips instances class unary strips instances furthermore worth noting
construction easily modified use padding redundant variables
make original actions correspond number actions unary instance
hence possible make reduction plans unary instance
constant factor longer corresponding plans original instance
make frequent use strips instances include encodings binary
counters following construction uses one action bit
increment non negative integer encoded binary
construction n bit binary counter encoded strips follows let v
x xn let contain n actions
ai xi xi x xi xi x n


fialgorithms limits compact plan representations

following plan counting bit counter according construction
ha
could modify binary counter use unary actions described construction direct way get unary actions count gray code
construction backstrom klein n bit gray code counter encoded
strips follows let v x xn let contain n actions
si xi xi xi x xi n
ri xi xi xi x xi n
following plan counting bit gray code counter according
construction
hs r r r r r r r
complexity theory
use abbreviation dtm deterministic turing machine ntm nondeterministic turing machine addition standard types use advice
taking turing machines deterministic nondeterministic type
advice taking turing machine associated sequence advice
strings special advice tape advice function natural numbers
advice sequence n input x advice tape immediately loaded
x continues normal way except access
advice written advice tape exists polynomial p n p n
n said use polynomial advice complexity class p poly
set decision solved advice taking dtm runs
polynomial time polynomial advice extended instance
np poly defined ntms run polynomial time polynomial advice
note advice depends size input content furthermore
advice sequence must exist need computable following two
literature used later
theorem np p poly polynomial hierarchy collapses karp lipton
theorem b let k integer pk pk poly polynomial
hierarchy collapses level k yap lemma combined theorem
sat consists instances form c c cm ci
called clause set exactly three literals universe
binary variables instance c satisfiable exists assignment truth
values variables used c least one literal true ci c
otherwise unsatisfiable deciding satisfiability sat np complete deciding
unsatisfiability conp complete precisely use following definition
sat


fibackstrom jonsson

definition integers n let xn x xn set variables let
n
n number possible literal clauses xn let c n c n cn

n


fixed systematic enumeration clauses let cn cn cn cn clause
n
cin defines three literals cin let cn cn cn



fixed systematic enumeration subsets cn let n hxn cn
n
n implicitly define set en e n e n en atoms subsets
eni ejn cjn cni n
n

systematic enumeration possible sat instances
sequence n n n
n variables hence equivalent usual definition sat technically speaking
redundant encoding sat since allows instances specify variables
used clauses harmless however non redundant instances remain
still hard instances neither redundantly encoded instances
harder non redundant counterpart since n n enumerations
cn en chosen polynomial time computable assume
enumerations fixed note set eni uniquely
identifies clause set cni

representing arbitrary plans compactly
known cases instances exponential size plans
plans polynomial size representation gimenez jonsson
obvious question thus whether plans including exponential length
polynomial representations one interpretation question answer trivially yes
observation set plans arbitrary ffp p instance p p
size representation since instance together deterministic
successively enumerates outputs plans representation
although trivial useful observation highlights fundamental issues representations liberatore discusses similar representation instead
specifying defines lexiographic ordering actions furthermore
adds plan index able represent single plan rather whole set
plans however index unproblematic see soon
interesting interpretation question whether every single plan
particular instance polynomial representation even precisely
polynomial p every plan every instance representation
size p n n size instance investigate question
consider simple compact notation possible index number plan
particular instance since instances may infinitely many plans due cycles
state transition graph consider optimal plans however guarantee
even index small enougha polynomial number bits may sufficient
represent
sometimes omit index n assumed obvious context thus write ki rather
kn



fialgorithms limits compact plan representations

construction given arbitrary integer n construct strips instance p n
hvn gn vn x xn gn x xn contains
actions
ai xi xi x xi xi x n
bi xi xi x xi xi x n
lemma every integer n instance pn according construction
optimal plans

n

proof let n arbitrary integer p n corresponding strips instance according
construction instance binary counter variables x xn
construction except extra variable independently set
true false depending whether action type ai bi chosen since variables
x xn interpreted binary number let notation hm yi represent
state x xn encodes number false let hm yi represent
corresponding state true whenever state hm yi hm yi n
possible go hm yi hm yi one action
states state transition graph instance appears figure initial state
h yi goal states h n yi h n yi hence plan p n must
length n every state goal state two different actions
choose lead different states however goal reachable
n
states choice action matter hence different
plans p n







n





goal

init

figure state transition graph proof lemma
although atom redundant particular example whole construction could
part larger instance purpose noted
instances used proof optimal plans plans length
set prove previous claim
theorem every integer n takes n bits index optimal plans
instance pn according construction
proof since bit number distinguish different objects
follows lemma least n bits necessary index plans p n


fibackstrom jonsson

immediately implies optimal plans strips instance
polynomial size representations holds even restrictions unary actions
basing construction gray counter instead binary counter every action
two postconditions rewriting construction yields equivalent instance
unary actions block four actions action original instance
although plans get times longer number plans remain hence
theorem still holds
theorem leaves possibility open plans instance
polynomial representations although interesting question thus
many plans instance polynomial representations answer
question stray field information theory kolmogorov complexity
scope treat field detail loosely speaking kolmogorov
complexity string size smallest dtm generate string
input let k x denote kolmogorov complexity binary string x following
lemma due buhrman et al lm
lemma incompressibility lemma let c positive integer every set cardinality
least c elements x k x blog mc c
lemma used fraction plans compactly represented
approaches zero size instances approaches infinity
theorem let p arbitrary polynomial consider instances pn according construction arbitrary integers n let n total number plans
pn let n number plans represented p n bits
limn n
n
n

proof let p arbitrary polynomial know lemma n
every n let c n n p n incompressibility lemma says
least n c n plans k blog n c c n
c n n plans k blog n c c n
values n c n simplifies say p n
plans k p n hence n p n theorem follows since
p n
limn n

n limn n
means even case plans every solvable instance
compact representations probability particular plan compact representation
vanishingly low large instances although strictly necessary use
kolmogorov complexity prove theorem makes information theoretic
aspect compact representations clearer

uniform compact representations plans
know cannot general compress arbitrary exponential plans subexponential size choose plan use previous
still leaves open possibility small fraction solutions instance could compact representations however planner oracle whatever


fialgorithms limits compact plan representations

would choose us plan present us compact representation
suppose planner could actually would make use still need
actual plan cannot avoid exponential size hence interesting case
seems could least access useful information plan efficiently
term representation used loose sense need really precisely
defined moment suffices note representation needs kind
data structure kind access extreme cases
vector data trivial access embeds data
could mean access compact representation efficiently investigate
two criteria first one efficiently retrieve actions actual
plan sequentially interpretation efficient actions retrieved
polynomial delay johnson papadimitriou yannakakis second criterion
action actual represented plan random accessed polynomial time
size instance
looking explicit representations plan take look uniform
case single representation covers instances precisely
consider case single works compact representation
plan every solvable instance
theorem solvable strips instance p
generate plan p sequentially polynomial delay random access action
plan p polynomial time p np
note theorem follow fact strips pspacecomplete since solvable instances considered proving theorem need
introduce extra technical machinery start encoding sat instances according
definition strips follows
construction let n n arbitrary integers construct
strips instance p hvn eni goal vn xn en cts ctu goal inc
v vm n actions specified table
previously noted subset eni en uniquely identifies sat instance telling
clauses cn enabled initial state selects particular nvariable instance interested actions partitioned three groups group
contains two actions acs acu set atoms cts ctu respectively
actions block cts ctu initially false one atoms
set true plan cts ctu mutually exclusive group ii consists
actions require cts true group iii consists actions require ctu true
two groups actions thus mutually exclusive hence every plan must start
exactly one action group rest plan consists actions
group ii group iii depending first action intention
following plan starts action acs commits verifying
satisfiable plan starts action acu commits verifying
satisfiable case plan ends action satisfies goal plan
verified commitment made first action interpreted viewing


fibackstrom jonsson



acs ctu cts
acu cts ctu

commit prove satisfiability
commit prove unsatisfiability

ii

aseti cts v xi
avt cts v

set xi
start verification

avt j cts ejn vj vj
avtkj cts ejn vj kj vj
ags cts vm n goal

skip disabled clause cj
verify cj true since kj true
conclude instance satisfiable

avf j ctu inc ejn j j j inc
aixi ctu inc xi xi x
inc xi xi x
agu ctu inc x xn goal

verify clause cj false
increment counter

iii

conclude instance unsatisfiable

index ranges n j n k

table actions construction
planner theorem prover first outputs theorem first action plan
proof theorem rest plan
lemma every integer n integer n strips
instance pin according construction following properties
computed polynomial time n
corresponds sat instance sin every plan pin starts action
acs sin satisfiable otherwise action acu
least one plan
proof property trivial prove prove property first note initial
state contains atoms en previously noted subset eni en uniquely
identifies sat instance telling clauses cn enabled
two cases plan starts action acs commits verifying

n satisfiable plan starts action acu commits verifying
satisfiable case plan ends action satisfies goal
plan verified commitment made first action details two cases
follows
plan verifies satisfiability must form
k

n
hacs aseti asetih avt avtk avtm n
agsi
z



z


assign

verify

assign block h actions set satisfying assignment x xn verify
k
block consists one action avtj j clause cjn cjn enabled ejn true
kj verifies kj cjn true assignment otherwise cjn


fialgorithms limits compact plan representations

disabled kj avt j skips cjn without verifying anything
planner thus
committed verify satisfiable
chosen satisfying assignment x xn
chosen one literal enabled clause witness clause true
assignment
last action ags makes goal true three steps successful note
works case clause enabled corresponds trivially
satisfiable instance empty set clauses obviously plan form
satisfiable
plan instead verifies unsatisfiability must form
hacu b b b ah bh agui
h n except first last actions plan viewed two
interleaved sequences
ha ah haix aix aix aix aix

hb b bh
aixi actions increment actions use x xn form binary counter since
variables correspond number initial state n increment
actions subplan enumerates possible truth assignments x xn sequence
consists actions type avf j avf j action verifies corresponding
clause cjn enabled false current assignment x xn aixi actions
require inc true set false avf j actions instead require inc false
set true hence plan synchronised alternates actions
two sequences since first aixi action preceeded avf j action
avf j action last aixi action follows must unsatisfied
enabled clause every possible truth assignment since synchronization otherwise
get stuck counter cannot increment plan type
unsatisfiable last action agu makes goal true succeeded note
case need actions skip disabled clauses since sufficient
demonstrate one enabled clause false assignment
follows plan first form satisfiable second form

n unsatisfiable furthermore since first action commitment rest
plan whether verify satisfiability unsatisfiability sufficient check action
decide satisfiable
property follows immediately property since plan must
two forms
necessary tools prove theorem


fibackstrom jonsson

proof theorem suppose sequential random access stated precondition theorem solve sat instance
polynomial time asking first action plan
corresponding instance p tell action whether satisfiable however
implies p np
proof would still hold rewriting construction described construction
theorem holds even restricted set unary strips instances

non uniform compact representations plans
theorem uses strong criterion requires one single handle
instances relaxed variant non uniform case allow different
representations different instances consider compact representations
single plans different access criteria order must first define
precisely mean representations
compact representations access mechanisms
define concepts csar crar representations action sequences
characterised access properties
definition let f arbitrary function let f hv ai ffp p frame
let representation dtm furthermore
f compact f f runs f f space including input
output tapes
f compact sequential access representation f csar f compact
takes input generates actions sequentially f f time
successive action
f compact random access representation f crar f compact
arbitrary index input outputs action
f f time
note definition require representations computable
could used two separate functions one bound access time one bound
size would allow better precision however choose use single function
since makes theory simpler clearer sufficient precision
purposes consider output tape cleared actions
output single action sequence note space complexity
includes input output tapes implies longest sequence f crar
note definition differs slightly previous one backstrom jonsson b first
generalised definition allow compact representations arbitrary function f
arbitrary polynomial second order improve precision longer use notation
exact functions finally representations restriction space time none
changes matter previous publication details proofs



fialgorithms limits compact plan representations

represent less actions since input limited bits csar
corresponding limit since input furthermore time restriction f csar
viewed generalisation polynomial delay concept restricted
polynomials often apply definition instances rather frames although
makes slight difference technically important principle ignoring
allows simpler theorems proofs write crar csar referring
whole family representations particular type
sequential access representations
sequential access non uniform case would ask solvable strips
instances least one plan polynomial csar unfortunately still remains
open question hence consider restricted case question
require csar must verifiable within resource constraint define
follows
definition every ffp p plan representation type r define following decision
plan representation verification
instance ffp p instance p hv gi string
question r representation plan p
complexity verification measured p state following
theorem polynomial csars
theorem let c arbitrary complexity class p arbitrary polynomial
p csar verification np c every solvable strips instance least one plan
corresponding p csar pspace np c
proof let p arbitrary polynomial suppose p csar verification npc every
solvable strips instance least one plan corresponding p csar let p
arbitrary strips instance decide p plan guessing string
length p p bits check string p csar plan p
done polynomial time p ntm oracle c since p csar
verification npc however deciding strips instance plan pspacecomplete bylander thm follows pspace npc since p
chosen arbitrarily
csar instance limited use must first verify
correct since verification may difficult solving instance
note c class polynomial hierarchy pspace npc implies
collapse hierarchy preceding theorem holds restriction unary strips
instances since still pspace complete restriction bylander
thm fact holds restrictions still pspace complete
includes several cases bylanders analysis well many subclasses
sas see backstrom nebel jonsson backstrom overviews



fibackstrom jonsson

although may seem disapointing holds condition
must check whether csar correct means instance theorem
irrelevant correctness csar guaranteed design one case following
theorem every strips instance according construction plan
polynomial csar
proof consider arbitrary instance p add n extra bits b bn b
tells satisfiable satisfiable remaining bits specify satisfying
assignment bi gives value vi otherwise undefined claim
simple deterministic uses p b bn generates
plan p polynomial delay follows
suppose b says satisfiable h bits b bn one
plan p form
k

n
agsi
hacs aseti asetih avt avtk avtm n
z


z



assign

verify

actions assign block easily generated b bn avtkj actions
output avt j cjn enabled otherwise output avtkj smallest k kj
true specified assignment clearly works polynomial delay
instead suppose satisfiable plan second type must cycle
possible assignments generating corresponding counting
actions trivial assignment must output avf j action determine
smallest j cjn enabled satisfied current assignment
output avf j done polynomial time since polynomial number
clauses
clearly construction polynomial csar plan p
following theorem demonstrates general harder classes
instances even optimal plans polynomial csars design
theorem subclass x strips polynomial p deciding
instances x plan pspace complete solvable instances x
optimal plan p csar
proof pspace characterised class polynomial space bounded dtms
bylander thm used fact demonstrate polynomial reduction
pspace strips refer bylander details brief given
machine input x constructs deterministic strips instance plan
x accepts hence polynomial time check
valid state action applied state follows
polynomial p every solvable strips instance plan
p csar furthermore since instance deterministic one plan
must optimal


fialgorithms limits compact plan representations

even general observation every deterministic ffp p instance
solvable exactly one plan thus optimal plan polynomial
csar contrast next consider class instances solvable instances
plans polynomial csars optimality guarantee
example thus illustrates csar representation gives guarantees
actual data represents precisely example uses class reversible
ffp p instances state transition graph symmetric
definition ffp p frame f hv ai reversible pairs states
f whenever action action

note reversible instances easy special case deciding
plan still pspace complete jonsson et al thm plans
still exponential length
theorem polynomial q polynomials p every solvable
reversible ffp p instance q p csar plan
proof let p hv gi solvable ffp p instance f hv ai
reversible consider figure optplan assumed
optplan g returns length shortest plan g
ignoring process b clear outputs optimal plan p since
plan assumption process b finds two actions executing
ha state ends state choice actions must exist since
plan goal state f reversible synchronisation processes
b make actions appear adjacent order output
thus interfere plan produced process
make plan longer choosing actions process b done double loop
pairs actions checking
obvious polynomial r process b runs r p time
choose r allow extra time run process parallel let p together
p c constant c choose r satisfies
n c r n n obviously r csar plan p choose
polynomial q r n q p n n
optplan must obviously run polynomial space complexity otherwise
important parallel used proof theorem extent
nonsense process job consulting ordinary
optplan gives time guarantees process b hand contributes nothing
relevant plan satisfies access time requirement process b buys time
process plan generating irrelevant actions frequently enough satisfy
time requirements wait statements strictly necessary illustrate
tune step complexity slowing process b desired
although example might perhaps considered somewhat pathological clearly
demonstrates csar crar representation
data structures certain access properties guarantee particular


fibackstrom jonsson























g
parallel
process
optplan g
pre
post
optplan g
optplan g
process b
process running
choose pre
u post
choose pre u post u
output
wait
output
wait
output
post

figure csar reversible instances
properties actual data stored uncommon plan representations
instance reactive plan could constructed behaviour still
considered correct run polynomial time space alternatively use
random walk output actions polynomial delay
eventually reach goal plan output lot redundant
actions figure may sense viewed derandomized variant
random walk
random access representations
case non uniform random access clearer case sequential access
answer question existence crars without qualifications
verifiability
theorem polynomial p every solvable strips instance
least one plan corresponding p crar polynomial hierarchy collapses
since theorem conditioned verifiability representations stronger
theorem proving theorem need introduce additional theory



fialgorithms limits compact plan representations

construction let n arbitrary integer construct strips instance p n
hvn goal
vn xn en v vm n svi sva sia sii sti f goal
actions specified table

abi svi sva sia sii sti svi

begin instance block

aba svi sia sva f v v vm n

begin assignment block

avtkj sva vj vj ejn kj vj
avf j sva vj vj ejn j j j vj f

verify j true clause cj
verify clause cj false

avsj sva vj vj ejn vj

skip disabled clause cj

aaf sva vm n f sva sia
aat sva vm n f sva sia

verify assignment satisfying
verify assignment satisfying

aixi sia xi xi x sia xi xi x
arx sia xn x sia svi sti xn x

increment assignment counter
reset assignment counter

ais sti sti sii
aiu sti sti sii

verify instance satisfiable
verify instance unsatisfiable


aiij sii ejn enj e sii ejn ej
n en

increment instance counter

ari

n
sii en e n

goal

instances checked

index ranges n j n k

table actions construction
previous construction allows plans two types choosing assignment
verifying clauses chaining enumerating assignments demonstrate
one false clause construction mixes methods check instance
satisfiable plan must enumerate variable assignments assignment
must walk clauses chaining enabled clause demonstrates
true literal none literals true disabled clauses skipped
atoms f keep track whether clauses true assignment
n
case instance satisfiable extra counter uses variables e n en
enumerates possible subsets eni en thus implicitly enumerating sat instances
n
n n
counter constitutes outer loop eni possible
assignments x xn tested described plan thought
implementing figure
lemma integers n instance pn according construction
following properties
computed polynomial time n


fibackstrom jonsson


sat instances size n

clear

assignments x xn

clear f

clauses cj

cj disabled

nothing

elsif kj cj satisfied

nothing

else neither j j j satisfied

set f

f

set



report satisfiable

else

report unsatisfiable
figure algorithmic description construction
least one plan
exist constants bn every n action
position bn plan pn ais sat instance sin satisfiable
aiu sin unsatisfiable
proof addition previous explanation construction note instance
designed deterministic setting n n bn satisfies
claim since action position bn ais satisfiable aiu
unsatisfiable
set prove theorem
proof theorem suppose p polynomial solvable strips instances
least one plan corresponding p crar n let p n
corresponding instance according construction let n p crar plan
n p n assumption n n must exist every n
construct advice taking dtm takes input form hp n ii
n integers n n let represented binary
exactly n bits strictly increasing n depends n
let sn well defined since depend define advice
function sn n advice thus p crar plan strips
instance p n according construction recall need know
advice exists let bn refer corresponding constants
must exist according lemma since run whatever used access
n follows assumptions action bn n polynomial
time sn let return yes action ais otherwise return


fialgorithms limits compact plan representations

given arbitrary sat instance compute corresponding input
run instance construction answers yes satisfiable input computed polynomial time runs polynomial time polynomial advice since solves satisfiability sat follows
np p poly impossible unless polynomial hierarchy collapses level
according theorem
worth noting plans instances according construction
contains subplan every sat instance particular size hence alternatively
view plan representation set exponentially many plans shows
representing one long plan representing large set plans fundamentally
different issues
crars restricted cases prove exist
one example construction
theorem every strips instance according construction plan
polynomial crar
proof add n extra bits b bn explained proof theorem construct
polynomial time random access follows
suppose b says satisfiable h bits b bn one
plan p form
k

n
hacs aseti asetih avt avtk avtm n
agsi

z


z


assign

verify

since h n construct whole assign sequence determine specific action
polynomial time avtkj actions correspond specific clause cjn since
clauses ordered compute j index action ask cjn
enabled output avf j otherwise output avf kj smallest k kj
true specified assignment b bn
instead suppose satisfiable first last actions interleaved aixi avf j actions aixi actions function counter
variables x xn let arbitrary index plan first
last action odd ai aixk action k easily computed
output aixk even ai avf j action value x xn immediately
ai easily computed use value check enabled clauses
order finding clause cjn satisfied output avf j
clearly construction polynomial crar plan p
another much larger class instances plans crars considered
next section
relationships compact representations
section investigate crar csar concepts relate since
macro plan viewed compact representation investigate macro


fibackstrom jonsson

plans relate concepts start showing polynomial crar
plan polynomial csar plan
theorem polynomial q polynomials p ffp p frames
f hv ai p crar q p csar
proof let f arbitrary ffp p instance let p crar plan f
use action counter initiated index first action plan generate
actions plan sequentially repeatedly asking action indexed counter
incrementing counter let denote together bit
counter sufficient since must shorter actions suppose takes r time
increment bit counter constant c c runs
p f c space runs p f r p f c time define polynomial q
q n r n c obviously c q q p f p f c q p f
p f r p f c q p f q p csar
opposite hold however particular instances according
construction plan crar plan csar
construction acts separation two concepts
theorem unless polynomial hierarchy collapses polynomial q
every polynomial p every strips instance p every plan p p csar
q p crar
proof let x denote class strips instances used proof theorem since
instances deterministic polynomial p every solvable instance
p csar plan however follows proof
polynomial r instances x plan r crar hence
polynomial q instances plan q p crar
although previously defined makes sense look
macro plans context macro sequence two actions macros
commonly used treated single action planner macros
useful certain subsequences actions occur frequently
plans korf however macros may used purpose representing
plan compact structured way especially true macros allowed
contain macros since allows hierarchies macros instance well
known shortest solution towers hanoi arbitrary number
disks described recursive schema gill ex although plan
exponential number disks class instances jonsson
backstrom b property polynomial time
instance plan plan may exponential length thus cannot
generated subexponential time gimenez jonsson showed plans
instances polynomial size representation macros fact macro
plan even generated polynomial time although actual non macro plan would
take exponential time generate later generalised classes


fialgorithms limits compact plan representations

instances jonsson polynomial size macro plans
immediate connection compact plan representations however contrast
gimenez jonsson discuss generate macro plans analyse
properties
macro plans powerful tools representing plans compactly hence
interesting identify criteria compact macro plan representations exist
scope give partial answer
question following way straightforward see macro plan viewed
context free grammar cfg let actions terminals let macros
variables let macro expansions production rules let root macro
start symbol note use macros represent single plan rather represent possibilities macro expansions must acyclic order
produce unique well defined plan hence macro plan defined acyclic cfg
cfgs used represent single string compactly often referred
compressed grammars furthermore compressed grammar permits efficient
random access string represents access necessary preprocessing
polynomial time size grammar bille et al precisely consider
grammar size n represents string length n derivation tree maximum
height h polynomial time preprocessing size grammar possible
random access symbol string index log n time alternatively
h time typically work first computing length substrings
generated rule preprocessing step use information
symbol certain index top search since grammar acyclic get h n
hence following proposition immediate properties compressed grammars
proposition polynomial r every ffp p frame hv ai
every macro plan sequence used random access action
r time
thus get following relationship macro plans crars
theorem polynomial p polynomials q ffp p frames
f hv ai action sequences macro plan
q f p q crar
proof let r polynomial macro plans random accessed r
time let together random access c
constant c define p p n r n c get c q f c
r q f c p q f furthermore runs r r q f c p q f
space time follows p q crar
follows theorem every plan polynomial macro plan
polynomial crar class polynomial macro plans subclass class
polynomial crars know proper subclass way
imply cannot polynomial macro plan instance
corollary polynomial p every solvable strips instance
least one plan corresponding macro plan size p p polynomial hierarchy collapses


fibackstrom jonsson

proof immediate theorems

reformulation
concluded seems little hope plans compactly
represented general case turn idea reformulation see
help may seem place context contrary
quite logical step take far analysed plans
hold obvious hold
instances solved reformulating instances
thus hypothetically possible could get around
however say something useful relevant sufficient look
naive approaches polynomial reductions investigate stronger criterion
basic idea reformulation transform instance another equivalent instance another instance instance
reformulation useful solution instance must use solve
original instance something must gained often reformulation used intention overall process faster solving original instance directly common
variants reformulate sat csp model checking another
reformulation sat first suggested kautz selman
still popular long fox hamdi discuss
reformulation general edelkamp leue visser discuss
connections model checking
reformulation process viewed shown figure instance p
solution directly ordinary solving p via reformulation
instead follows indirect path figure first p reformulated instance
r p instance solved produces solution r p
finally transformed back solution p

p
direct

r p
indirect




figure reformulation generation
obviously reformulation cannot help us plans exponential even first
two steps indirect path took polynomial time polynomial size would
still necessarily take exponential time transform exponential


fialgorithms limits compact plan representations

inherently intractable whichever method use solve reformulation
could potentially speed things could somehow used directly solution
original would happen rarely
situation different though consider decision rather
generation ask plan whether plan
case use solution r p directly since decision two
possible answers yes may thus escape inherent intractability variant
reformulation shown figure since exponential solution generated case
reformulation could potentially efficient know decision
strips pspace complete general case reformulated easier
solve could beneficial first reformulate p r p ask instance
solution would possible check solution
embarking generating possibly exponentially long plan consider instance
class jonsson backstrom b plans may exponential size
possible decide polynomial time plan thus seems case
reformulating decision interesting one look
give improvement hardly improvement plan generation
via reformulation

p
direct

r p
indirect

yes

yes

figure reformulation decision
let pe strips denote decision plan existence strips
following two trivial illustrative
theorem exists decision x function r holds
p pe strips r p x p r p answer b
complexity class c decision x c polynomial time computable
function r holds p pe strips r p x p r p
answer pspace c
proof let x pe strips r identity function b immediate since r
polynomial reduction pe strips x
cases reformulate pspace complete pspace complete interesting prove anything better must obviously
look x r useful restrictions


fibackstrom jonsson

important note reformulating np complete instance sat magically make np complete reason
strips pspace complete allows exponential solutions soon
restrict solutions bounded fixed polynomial belongs
np furthermore encodings instances sat typically use atoms encode
actions appear position plan exponential number extra
atoms required general case hence original already
np blow instance exponentially reformulating sat
latter case complexity longer comparable note deliberately restrict ask plan certain length shorter
actually solving restricted version optimization case
would harder fact seems unlikely general
could reformulated np order avoid straightforward naive
approaches reformulation consider analyse reformulations defined follows
definition let p hv gi strips instance let f hv ai let hi gi
let x decision reformulation pe strips x pair hr ri
functions maps every instance p hf pe strips corresponding instance
x r r f x p x answer hr ri polynomial
reformulation fixed polynomials p q
r f p f
r computable q r f time
thus consider reformulation involves two functions r r function r
main reformulation function intended reformulate difficult part instance
even require function computable require exists function
r used transform initial goal descriptions something similar
instance use combine delivered r proper instance
x noted reformulation concept similar although identical
compilation concept used nebel
theorem polynomial reformulation pe strips x np
unless polynomial hierarchy collapses
proof suppose hr ri reformulation arbitrary integer n let f un hvn
defined construction without action acs let heni goal
n follows trivially proof lemma instance
p hf un solution unsatisfiable note sat part
instance disarmed
construct advice taking ntm input hf un ii n
n representing binary n bits clearly strictly increasing
depends n let sn arbitrary define advice function
sn r f un note need know advice exists
let first compute compute x r sn r r f un
polynomial time since sn given free advice assumption x x
answer yes p solution assumption x np


fialgorithms limits compact plan representations

solve x guessing solution verifying polynomial time hence deciding
p solution np poly
arbitrary sat instance compute polynomial time answers yes

n unsatisfiable however unsatisfiability sat conp complete
follows conp np poly impossible unless polynomial hierarchy
collapses level according theorem b
pushed arbitrarily high polynomial hierarchy thus making
unlikely could reformulated anything simpler
corollary polynomial reformulation hr ri pe strips decision
x pk k unless polynomial hierarchy collapses level k
proof sketch construction demonstrates encode existential quantification
choosing truth assignment sat part universal quantification enumerating
truth assignments unsat part hence straightforward modify
analogous construction qbf formulae k alternations given rest
proof analogous proof theorem must use oracle pk
argument leads pk pk poly impossible unless polynomial hierarchy
collapses level k according theorem b
since proofs build construction rely exact position
actions follows theorem corollary hold restricted unary
strips instances

discussion
section consists five parts first transfer reformulation theorem
general adding information guide planners discuss explain
literature discuss potential relationship causal
graphs compact representations followed discussion
could relevant plan explanation fourth part discusses related
work compact representations compilation section ends summary
list open questions
reformulation additional information
theorem broader consequences reformulation fact implies
way help planner adding information frame matter
information get unless accept amount information
polynomially bounded frame size following theorem function g
assumed represent additional information need even computable
require polynomially bounded
theorem let p arbitrary polynomial consider function g

g maps strips frames g f p f frames f


fibackstrom jonsson

strips instances p hf answers yes input hp g f
p plan
runs polynomial time polynomial hierarchy collapses
proof assume function g properties described
theorem define function r r f hf g f every strips frame f
define function r r hf xi hhf xi every strips instance p hf
every string x r r f hhf g f hp g f hr ri polynomial
reformulation strips equivalent solve
polynomial time however reformulation exist according theorem
unless polynomial hierarchy collapses
extended upwards polynomial hierarchy way corollary longer requiring polynomial means cannot
make simpler adding polynomial amount additional information frame
use clever use information remain
hard without extra information may sometimes help add information particular instance somehow guide planner systematic way
add information frame level required polynomial size
literature rich methods intended make
efficient adding information one way another although methods perhaps
thought non exhaustive list methods similar
abstraction hierarchies macros case annotated landmarks
state space abstraction goes back least abstrips planner sacerdoti main idea form abstraction hierarchies variables thus
implicitly actions planner plan important goals
first get abstract plan refined detailed plan knoblock
proposed automatically computing abstraction hierarchies
successful many examples demonstrated sometimes
fail produce exponential plans instances linear optimal plan backstrom
jonsson surprising since use abstraction hierarchy
viewed adding information frame automatic generation abstraction
hierarchies systematic way add information thus treated special case
theorem
adding set macros frame similar abstraction hierarchies knoblock pp noted planner uses abstraction searches
plan abstract space tries refine action subplan lower
lever planner uses macros search abstract space instead already
set macros available correspond subplan finding macro works
expanded thus similar refining abstract action use
macros demonstrated speed considerably certain cases korf
macros typically added frame level learning suggested
one method create macros automatically korf however macros typically treated action planner expanded finding
plan hence addition macros may backfire make less efficient


fialgorithms limits compact plan representations

adding redundant actions may haslum jonsson
surprising since addition macros addition information thus covered
theorem
case see spalazzi survey uses stored plans plan skeletons
planner tries reuse modifying extending one sense
similar macro advanced macros macro expansion methods
one view similar abstraction plan must refined order
work difference abstraction planner finds plan skeleton
abstract space case planner set plans stored database
plans may handcoded usually learning previous
situations well known case may fail improve efficiency
cases used must similar actual instance hand nebel koehler
liberatore b explained special case theorem
term annotated sometimes used refer number similar techniques adding control information planner examples prodigy planner
veloso et al allows control information rules goal ordering
tlplan bacchus kabanza allows adding temporal logic axioms control
planner techniques good hand tailored control rules axioms
particular application domain immediate theorem cannot help
us general case
landmarks hoffmann porteous sebastia idea adding
explicit subgoals called landmarks instance intention tell
planner landmarks must achieved plan order achieve overall
goal landmarks may ordered guide planner however
authors point deciding variable value logic formula necessary
subgoal pspace complete hence one usually considers incomplete
sets landmarks interestingly landmarks differ previous methods
important aspect landmarks added instance level frame level
although might quite rigid difference practice seems fundamental
essence hence adding landmarks non uniform case adding information
thus immediately covered theorem meaningfully analyse non uniform
case remains open question
causal graphs
knoblock defined ordering variables instance
used guidance finding abstraction hierarchies ordering variables
fundamental class jonsson backstrom b ordering implicitly
defined abstraction hierarchy concept ordering variables
intention defining abstraction hierarchy define tractable subclasses etc nowadays
usually referred causal graph see chen gimenez survey
properties causal graph define tractable subclasses many papers still
use knoblocks definition follows
every strips action let vpre atoms pre vpost atoms post let


fibackstrom jonsson

f hv ai strips frame causal graph f directed graph gcg hv
u v v u v u v
u vpre vpost v vpost
idea behind causal graphs strongly connected component graph
correspond abstraction level applying definition examples
instance according construction causal graph containing
large strongly connected component would possible form good
abstraction hierarchies causal graphs however theorem says
plans instances seem likely useful compact representations anyway
plans binary counter construction polynomial crars since
polynomial macro plans yet whole causal graph instance strongly
connected hand plans gray counter construction exponential
polynomial crars causal graph acyclic case thus seems
causal graph type used knoblock many others sufficient
even necessarily useful tool judging plans compact representations
variants causal graphs though one example interaction networks chen
gimenez another jonssons refined version knoblocks causal graph
defined follows
let f hv ai strips frame refined causal graph f directed graph
grcg hv u v v u v u v
u vpre vpost v vpost
u v vpost
u vpost v vpost
b u vpost v vpost

major difference variant knoblocks two variables
appear postcondition action necessarily form cycle
graph hence unary actions longer prerequisite acyclic graphs
refined causal graph gray counter binary counter acyclic
graphs construction still large strongly connected component
three examples acyclicity refined causal graph correlates whether plans
compact representations correlation seems hold general
difference two types causal graphs suggests study variations
concept could lead insight topic compact representations
turn fruitful would likely carry areas causal
graphs used model checking wehrle helmert
plan explanation
important plan explanation bidot et al
suggest important systems ai systems able


fialgorithms limits compact plan representations

explain plans decisions user else user may trust system
similarly southwick writes
seems general agreement amongst involved kbs
order useful system must able explain reasoning user
although consider advanced explanation methods
implications possible explain meaningfully plan explanation
necessarily bad consider example plan instance
construction case sat instance unsatisfiable almost whole plan
consists alternating sequence form ha b b b denotes
actions aix aix n b denotes actions avf avf first
group actions together implement increment function thus serve
purpose similarly second group consists actions serve purpose
verifying clause false abstraction action sequence could
form hinc vfy inc vfy inc vfy inc denotes counting actions vfy
verification actions purpose explanation seems useful replace
actual actions abstract explanations functions abstract sequence
easier understand allows macros compress might
enhance explaining power however particular case would probably even
useful abstract whole sequence loop similar essentially
boils partitioning set actions equivalence classes
class consist actions meaningfully seen implementing concept
seems interesting important investigate one partition
set actions equivalence classes useful abstractions
plan explanation could mean trace explanation model checking would
analogously make long trace shorter abstract order make easier understand well known close ties model checking
model checking traces viewed plans vice versa edelkamp et al
number steps clock cycles exponential number state variables
even system divided subsystems individual subsystems may exponential behaviour blows combined subsystems exponential size
plan trace much use engineerit almost impossible task analyse
understand plan verifying system could autonomously
repetitive patterns even recursive repetitive patterns plan abstract
would considerably easier understand happens fact may
interesting execute plan even simulator compact understandable
explanation plan may actual goal
furthermore geib discusses combinatorial explosion plan recognition exponential number plans may share plan prefix recognized far
could clearly useful structured compact representations plan candidates
save space allow intelligent operations plans although
slightly different representing single long plan seen
two related
cases primary purpose compact representation would thus
exploit inherent structure plan set plans rather save space


fibackstrom jonsson

additional related work
liberatore studied representing plans compactly
similarities well differences contrast us
considers plans represented sequences states sequences actions
cases considers random access representation well sequential representation random access representation action sequences ta essentially
crar concept except specifies must implemented circuit
sequential representation action sequences sa hand different
csar concept function takes state input returns next state
hence restricted type reactive plan csar
thus immediately comparable instance contrary theorem
proves ta representation cannot polynomially converted sa representation
clearly shows sa csar quite different concepts proof
instances plans sa representation thus obviously carry
csars furthermore uses language actions modelled
polynomial size circuits coincides class ffp p hence hardness
proofs weaker since use restricted strips language cases
finally noted liberatores theorem case ta representations
similar theorem use different methods different conditions
nebel defines concept compilation languages although
ways similar reformulation concept differences compilation
function frame another frame different language
compilation need resource bounded resulting frame must polynomially
bounded original frame initial state goal must possible translate
polynomial time first step corresponds function r second
step essentially corresponds function r however nebel considers compilation
languages requires concept modularity present
furthermore focus complexity decision
question whether size solutions preserved compilations
conclusions open questions
current status knowledge non uniform compact representations
visualized figure outer box represents set solvable strips instances
inner boxes represent subsets least one plan instance
csar crar polynomial macro plan know classes least one plan
instance guaranteed polynomial macro plan towers hanoi
know classes least one plan instance crar know
plans polynomial macro plan construction example
open question plan crar polynomial macro plan
know classes instance plan csar know
crar example class reversible systems however construction
class instances plan csar plan crar
case provides strict separation csar crar concepts whether
classes strips instances plan csar remains open question though


fialgorithms limits compact plan representations

plans
plans w csar
plans w crar


towers
hanoi

plans w poly
macro plans




anything


reversible
systems



construction

construction

figure current status csars crars

thus following chain inclusions
polynomial macro plans crar csar strips
know first last inclusions strict
theorem may seem weak since conditioned p np similar
techniques proofs lemma corollary could encode qbf
arbitrary number alternating quantifiers hence push polynomial
hierarchy however remains open question condition could strengthened
way p pspace
argued number hold restricted unary
instances cases restrictions otherwise largely unexplored
area little currently known structural restrictions affect
applies whether plans csars crars
whether polynomial size macro plans
consider non uniform case compact representations single plans
single instances might interesting consider non uniform case reformulation adding information however seems straightforward since could
reformulate instance single bit telling whether instance solvable
reformulation clearly interesting additional criteria necessary
previously backstrom jonsson defined complexity measure
padding intended insensitive plan length concept seems related
nebels compilations although two concepts identical directly comparable
thus reasonable believe compact representations padded complexity
somehow related especially since padded complexity motivated instances
long plans however yet know relationship furthermore would


fibackstrom jonsson

interesting consider compilations look size compact representations
plan rather size explicit plans
acknowledgments
malte helmert anders jonsson anonymous reviewers earlier
conference version provided valuable comments suggestions

references
bacchus f kabanza f temporal logics express search control knowledge artificial intelligence
backstrom c jonsson p pspace complete equal
equal others proceedings th international symposium combinatorial search socs castell de cardona barcelona spain pp

backstrom c jonsson p b limits compact representations plans proceedings st international conference automated scheduling
icaps freiburg germany pp
backstrom c computational complexity reasoning plans phd dissertation linkoping university linkoping sweden
backstrom c expressive equivalence formalisms artificial intelligence

backstrom c jonsson p abstraction hierarchies exponentially less efficient proceedings th international joint conference
artificial intelligence ijcai montreal qc canada pp
backstrom c klein polynomial time sas pubs class
computational intelligence
backstrom c nebel b complexity sas computational
intelligence
balcazar j complexity searching implicit graphs artificial intelligence

bidot j biundo heinroth minker w nothdurft f schattenberg b
verbal plan explanations hybrid proceedings th mkwi
related puk workshop planung scheduling und konfigurieren entwurfen puk
pp
bille p landau g raman r sadakane k satti weimann random
access grammar compressed strings proceedings nd acm siam symposium discrete soda san fransisco ca usa pp
bonet b conformant plans beyond principles complexity artificial
intelligence


fialgorithms limits compact plan representations

bonet b geffner h incomplete information heuristic search
belief space proceedings th international conference artificial intelligence systems aips breckenridge co usa pp
boutilier c poole computing optimal policies partially observable
decision processes compact representations proceedings th national
conference artificial intelligence aaai portland usa vol pp

brafman r domshlak c structure complexity unary
operators journal artificial intelligence
buhrman h jiang li vitanyi p b applications
incompressibility method part ii theoretical computer science
bulatov dalmau v simple maltsev constraints siam
journal computing
bylander computational complexity propositional strips
artificial intelligence
cadoli donini f liberatore p schaerf space efficiency propositional
knowledge representation formalisms journal artificial intelligence

charikar lehman e liu panigrahy r prabhakaran sahai shelat
smallest grammar ieee transactions information theory

chen h gimenez causal graphs structurally restricted journal computer system sciences
edelkamp leue visser w summary dagstuhl seminar
directed model checking directed model checking dagstuhl seminar
proceedings dagstuhl germany
galperin h wigderson succinct representations graphs information
control
geib c assessing complexity plan recognition proceedings th
national conference artificial intelligence aaai san jose ca usa pp

gill applied algebra computer sciences prentice hall englewood
cliffs nj
gimenez jonsson complexity simple
causal graphs journal artificial intelligence
haslum p jonsson p reduced operator sets proceedings
th international conference artificial intelligence systems aips
breckenridge co usa pp
hoffmann j porteous j sebastia l ordered landmarks journal
artificial intelligence


fibackstrom jonsson

jansson j sadakane k sung w k compressed random access memory
arxiv abs v
johnson papadimitriou c h yannakakis generating maximal
independent sets information processing letters
jonsson role macros tractable journal artificial intelligence
jonsson p backstrom c state variable structural restrictions
complexity artificial intelligence
jonsson p backstrom c b tractable plan existence imply tractable
plan generation annals mathematics artificial intelligence
jonsson p haslum p backstrom c towards efficient universal
randomized artificial intelligence
karp r lipton r j connections nonuniform uniform complexity classes proceedings th acm symposium theory
computing stoc los angeles ca usa pp
kautz h selman b satisfiability proceedings th
european conference artificial intelligence ecai vienna austria pp

knoblock c generating abstraction hierarchies automated
reducing search kluwer academic publishers norwell
knoblock c automatically generating abstractions artificial
intelligence
korf r e macro operators weak method learning artificial intelligence

korf r e search quantitative artificial intelligence

liberatore p schaerf size data structures used symbolic model
checking arxiv abs
liberatore p complexity issues finding succinct solutions pspace complete
arxiv abs cs
liberatore p b complexity case journal experimental
theoretical artificial intelligence
long fox hamdi reformulation proceedings
th international symposium abstraction reformulation approximation
sara kananaskis ab canada vol lecture notes computer science pp springer
muscettola n pandurang nayak p pell b williams b c remote agent
boldly go ai system gone artificial intelligence



fialgorithms limits compact plan representations

nebel b compilability expressive power propositional
formalisms journal artificial intelligence
nebel b koehler j plan reuse versus plan generation theoretical
empirical analysis artificial intelligence
rytter w application lempel ziv factorization approximation
grammar compression theoretical computer science
sacerdoti e hierarchy abstraction spaces artificial intelligence

southwick r w explaining reasoning overview explanation knowledgebased systems knowledge engineering review
spalazzi l survey case artificial intelligence review

veloso carbonell j g perez borrajo fink e blythe j integrating learning prodigy architecture journal experimental
theoretical artificial intelligence
wagner k complexity combinatorial succinct input representation acta informatica
wehrle helmert causal graph revisited directed model checking
proceedings th international symposium static analysis sas los
angeles ca usa vol lecture notes computer science pp
springer
williams b pandurang nayak p reactive planner model executive proceedings th international joint conference artificial intelligence ijcai nagoya japan pp
yap c k consequences non uniform conditions uniform classes theoretical computer science




