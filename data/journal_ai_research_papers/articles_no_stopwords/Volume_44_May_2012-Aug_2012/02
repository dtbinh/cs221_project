Journal Artificial Intelligence Research 44 (2012) 141-177

Submitted 11/11; published 05/12

Algorithms Limits Compact Plan Representations
Christer Backstrom
Peter Jonsson

christer.backstrom@liu.se
peter.jonsson@liu.se

Department Computer Science
Linkoping University
SE-581 83 Linkoping, Sweden

Abstract
Compact representations objects common concept computer science. Automated planning viewed case concept: planning instance compact
implicit representation graph problem find path (a plan) graph.
graphs represented compactly planning instances, paths
usually represented explicitly sequences actions. cases known
plans always compact representations, example, using macros. show
results extend general case, proving number bounds compact
representations plans various criteria, efficient sequential random access
actions. addition this, show results consequences
gained reformulating planning problem. contrast
prove number positive results, demonstrating restricted cases plans
useful compact representations, well proving macro plans favourable access
properties. results finally discussed relation relevant contexts.

1. Introduction
usage study representations objects much smaller objects
commonplace computer science. us encounter representations
daily basis form zipped files, mp3 files etc. practical cases, usually
talk compressed objects, terms compact succinct common
theoretical studies. meaning terms vary common interesting case
size representation polylogarithmic size object.
Sometimes sufficient compute compact representation object, instance,
archiving file. cases representation must support various operations
efficiently without first unpacking object explicit representation. Performing
operations compact representation often harder performing operation
explicit object, cases compact representation make easier
emphasising inherent structure object.
One archetypical case using compact representations automated planning, although
seldom viewed way. planning instance implicit representation graph
typically exponentially larger representation, instance,
solutions, plans, paths graph. Consider, example, Strips instance
n variables. variables implicitly define state space 2n states action
preconditions define 2nm arcs graph. Similarly, define instances
paths exponential length too. Although planning instances already
c
2012
AI Access Foundation. rights reserved.

fiBackstrom & Jonsson

compact representations, little attention paid compact representations
solutions, usually represented explicitly. paper introduces analyses
number compact representations.
first turn computer science general find compact representations
arbitrary strings intensively studied field. example, Charikar et al. (2005)
Rytter (2003) address problem approximating smallest string representation using
compressed grammar. Bille et al. (2011) show representations permit efficient
access matching operations, Jansson, Sadakane, Sung (2012) demonstrate
representations efficient edit operations. structured objects arbitrary strings
potentially compact representations. following examples,
displaying positive well negative results various areas. Galperin Wigderson
(1983) Wagner (1986) study complexity common graph operations
graphs implicitly represented circuits tell whether two vertices connected.
Balcazar (1996) uses variant approach study complexity search AI,
using circuit generates adjacency list vertex. Bulatov Dalmau (2006)
present efficient algorithm certain CSP problems relies using compact
representation set solutions. Liberatore Schaerf (2010) study preprocessing
model checking focus size preprocessed parts. Cadoli et al. (2000) study
various formalisms knowledge representation study problems modelled one
formalism transformed another formalism polynomially larger
representation.
One approach compact representations various areas use macros.
concept widely used long time planning, although seldom
purpose providing compact representations. exception following case. 3S
class (Jonsson & Backstrom, 1998b) planning instances property optimal
plans exponential length always possible decide polynomial time
plan not. Gimenez Jonsson (2008) showed plans 3S class
always polynomial-size representation using macros, macro plans even
generated polynomial time. is, although plan may exponential length,
thus necessarily take exponential time generate, possible generate compact
representation polynomial time. Jonsson (2009) later demonstrated similar results
number classes. Although particular classes planning instances may
still restricted much practical use, principle compressing solution
using macros interesting tool planning plan explanation.
approaches compact plan representation appear sparingly literature.
notable exception Liberatore (2005a) studies two concepts plan representation
efficient random access efficient sequential access respectively. macro
plans examples representing one long plan compactly. might consider
representing large set plans compactly. instance, plan recognition may
simultaneously consider exponential number candidate plans (Geib, 2004). Although
seldom viewed way, reactive plan representation large set plans,
one state goal reached. is, however, known reactive
plans cannot compact, efficient correct general case (Jonsson, Haslum,
& Backstrom, 2000), although properties important, instance, spaceship
applications (Williams & Pandurang Nayak, 1997). Pomdps may similarly thought
142

fiAlgorithms Limits Compact Plan Representations

probabilistic variant reactive plans compactness representations important
case (Boutilier & Poole, 1996). Yet another case size plan
big plan necessarily long, occur various types branching
plans, contingent planning (Bonet & Geffner, 2000). three different concepts
isolated other. instance, Bonet (2010) casts contingent planning
problem conformant planning, is, branching plan represented one
long non-branching plan, branches appearing subplans. cases,
interesting know objects question compact representations. Although
compact representation save space, may secondary many cases.
important aspect object compact representation object
inherent structure may exploit purposes. instance, represent
set many plans representation using recursive macros, similar, emphasize
differences similarities plans. make comparisons
operations plans efficient. Similarly, case branching plans might
want exploit structure clearly displays two branches common
differ.
positive results macro representations (Gimenez & Jonsson, 2008; Jonsson, 2009)
prompt obvious question whether long plans always compressed using macros
(or method). show paper unlikely, matter type
compact representation try use (macro plans, finite automata whatever).
remainder paper organized follows. Section 2 introduces basic notation
concepts well planning framework used paper, contains
useful definitions complexity results. first ask, Section 3, whether
(optimal) plans instance compact representations. find answer
no; possible, neither macros method. However, results
exclude plans instance compact solutions. Section 4
thus restrict question whether uniform compact representation one plan
solvable instance. precisely, ask algorithm corresponds
one compact representation solvable instance. show algorithm
unlikely exist must able access actions plan useful way.
Section 5 turn non-uniform case, asking solvable instance least
one plan compact representation. primarily consider representations
efficiently access actions plan sequentially randomly. show
seems unlikely general case, interesting special cases
representations exist. section investigate macro representations
extend results Gimenez Jonsson two ways. prove plans
polynomial-size macro representation random accessed polynomial
time without access full plan. However, prove cannot always
represent plans compactly using macros. Section 6 analyse whether get around
problem long plans reformulating planning problem.
answered negatively. actually ask plan original problem, problem
inherently intractable using reformulation. However, even considering
decision problem still seems possible make planning simpler reformulation.
Finally, Section 7 contains discussion results paper related
relevant various topics adding information guide planners, causal graphs
143

fiBackstrom & Jonsson

plan explanation. paper ends summary results together list
open questions.
results paper appeared previous conference publication
(Backstrom & Jonsson, 2011b).

2. Preliminaries
section consists three parts. first part introduces general notation
terminology used paper. second part defines two planning frameworks used
paper, Finite Functional Planning propositional Strips, presents
constructions frequently used. third part briefly recapitulates concept
advice-taking Turing machines defines 3SAT problem used
several occasions paper.
2.1 General Notation Terminology
sequence objects x1 , x2 , . . . , xn written hx1 , x2 , . . . , xn i, hi denoting empty
sequence. Given set X objects, set sequences X, including hi, denoted
X . set, sequence aggregation X objects, write |X| denote
cardinality (the number objects) x write ||X|| denote size (the number
bits representation) x. composition two functions f g denoted
f g defined (f g)(x) = f (g(x)).
negation propositional atom x denoted x. literal either atom
negation set L(X) literals set X atoms defined L(X) =
{x, x | x X}. Negation extended literals ` literal `. Negation
extended sets X set literals X = {` | ` X}. Let
subset L(X) set X atoms. P os(Y ) = {x X | x } set
atoms appear positive , N eg(Y ) = {x X | x } set atoms
appear negated Atoms(Y ) = P os(Y )N eg(Y ). set consistent P os(Y )
N eg(Y ) empty set Z atoms satisfies P os(Y ) Z N eg(Y )Z = .
update operator n binary function given set X atoms set
literals, X n set atoms defined X n = (X N eg(Y )) P os(Y ).
2.2 Planning
positive results compact representations, want results apply general
powerful planning languages possible, results hold languages
restricted. Hence, use Finite Functional Planning formalism (Backstrom &
Jonsson, 2011a), makes minimum assumption language, except
ground language state variables finite domains.
Definition 1. Finite Functional Planning (FFP) frame tuple hV, D, Ai V
implicitly ordered set variables, : V N domain function maps every variable
finite subset natural numbers set actions. frame implicitly
defines state space S(f ) = D(v1 ) . . . D(vn ), v1 , . . . , vn variables
V order. members S(f ) referred states. action two
associated total functions, precondition pre(a) : S(f ) {0, 1} postcondition
144

fiAlgorithms Limits Compact Plan Representations

post(a) : S(f ) S(f ). pairs states s, S(f ) actions A,

1) pre(a)(s) = 1
2) = post(a)(s).
sequence = ha1 , . . . , a` plan state s0 S(f ) state s` S(f )
either
1) = hi s0 = s`
2) states s1 , . . . , s`1 S(f ) ai si1 si (for 1 `).
FFP instance tuple p = hV, D, A, I, Gi f = hV, D, Ai FFP frame,
S(f ) state G : S(f ) {0, 1} total function. state S(f ) goal
state p G(s) = 1. goal G reachable state S(f ) plan
goal state p. solution p plan goal state S(f ).
solution p called plan p.
complexity computing pre- postconditions actions goal
function referred step complexity. paper, consider subclass
FFP([P]) consists FFP frames instances polynomial step complexity.
occasionally consider restrictions FFP([P]) use notation FFP(p)
class FFP frames f (and instances p) action pre- postconditions
(and G) computed p(||f ||) time (and p(||p||) time), p polynomial.
furthermore say FFP([P]) instance p = hV, D, A, I, Gi deterministic
S(p) p plan s, one
pre(a)(s) = 1. is, instance deterministic planner never faced
choice two actions.
proving compact representation exist, result gets stronger
use weaker formalism. is, want use restricted formalism possible,
since results automatically apply formalisms expressive.
Hence, use propositional Strips results. number common
variants propositional Strips known equivalent
SAS+ formalism strong form polynomial reduction (Backstrom, 1995).
refer Strips paper variant called propositional Strips
negative goals (PSN) Backstrom. defined special case FFP([P])
uses binary variables, define traditional way, treating variables
propositional atoms.
Definition 2. Strips frame tuple f = hV, Ai V set propositional atoms
set actions. state space defined S(f ) = 2V states subsets
V . action precondition pre(a) postcondition post(a),
consistent sets literals V . pairs states s, S(f ) actions A,

1) satisfies pre(a)
2) = n post(a).
sequence = ha1 , . . . , a` plan state s0 S(f ) state s` S(f )
either
1) = hi s0 = s`
2) states s1 , . . . , s`1 S(f ) ai si1 si (for 1 `).
145

fiBackstrom & Jonsson

Strips instance tuple p = hV, A, I, Gi f = hV, Ai Strips frame,
state S(f ) G consistent set literals V . state S(f ) goal state
p satisfies G. goal G reachable state S(f ) plan
goal state p. solution p plan goal state S(f ).
solution p called plan p.
notation : X frequently used define action precondition X
postcondition .
negative results proven hold Strips. However, cases results
hold even many restricted subclasses Strips. would lead far survey
cases paper use restriction unary actions archetypical case
throughout paper.
Definition 3. Strips action unary |post(a)| = 1, set Strips actions unary
actions unary Strips frame instance unary action set unary.
Unary actions may seem limiting restriction demonstrated
sufficient many cases use on-board controllers spacecrafts (Muscettola et al.,
1998; Brafman & Domshlak, 2003). surprising, though, since Strips planning
PSPACE-complete remains even restricted unary actions (Bylander, 1994).
Given Strips instance always possible construct corresponding Strips instance
unary. following reduction unary instances simplified Strips version
reduction used SAS + (Backstrom, 1992, proof Theorem 6.7).
Construction 4. Let p = hV, A, I, Gi Strips instance. Construct corresponding

instance p 0 = hV 0 , A0 , 0 , G0 follows. Define Vlock = {vlock
| A}. let V 0 =
0
0
0
V Vlock , = G = G Vlock . Define A, contains
following actions:
},
abegin : pre(a) Vlock {vlock

},
aend : post(a) {vlock } {vlock
} {` }, ` post(a).
ai : {vlock


leave without proof construction polynomial reduction class
Strips instances class unary Strips instances. furthermore worth noting
construction easily modified use padding redundant variables
make original actions correspond number actions unary instance.
Hence, possible make reduction plans unary instance
constant factor longer corresponding plans original instance.
make frequent use Strips instances include encodings binary
counters based following construction, uses one action bit
increment non-negative integer encoded binary.
Construction 5. n-bit binary counter encoded Strips follows: let V =
{x1 , . . . , xn } let contain n actions
ai : {xi , xi1 , . . . , x1 } {xi , xi1 , . . . , x1 } (1 n).
146

fiAlgorithms Limits Compact Plan Representations

following plan counting 0 16 using 5-bit counter according Construction 5:
ha1 , a2 , a1 , a3 , a1 , a2 , a1 , a4 , a1 , a2 , a1 , a3 , a1 , a2 , a1 , a5 i.
could modify binary counter use unary actions described Construction 4, direct way get unary actions count Gray code.
Construction 6. (Backstrom & Klein, 1991) n-bit Gray-code counter encoded
Strips follows: let V = {x1 , . . . , xn } let contain 2n actions
si : {xi , xi1 , xi2 , . . . , x1 } {xi } (1 n),
ri : {xi , xi1 , xi2 , . . . , x1 } {xi } (1 n).
following plan counting 0 16 5-bit Gray-code counter according
Construction 6:
hs1 , s2 , r1 , s3 , s1 , r2 , r1 , s4 , s1 , s2 , r1 , r3 , s1 , r2 , r1 , s5 i.
2.3 Complexity Theory
use abbreviation DTM deterministic Turing machine NTM nondeterministic Turing machine. addition standard types, use advice
taking Turing machines deterministic nondeterministic type.
advice-taking Turing machine associated sequence a1 , a2 , a3 , . . . advice
strings, special advice tape advice function a, natural numbers
advice sequence, a(n) = . input x advice tape immediately loaded
a(||x||). continues normal way, except access
advice written advice tape. exists polynomial p ||a(n)|| p(n),
n > 0, said use polynomial advice. complexity class P/poly
set decision problems solved advice-taking DTM runs
polynomial time using polynomial advice. extended that, instance,
NP/poly defined NTMs run polynomial time using polynomial advice.
Note advice depends size input, content. Furthermore,
advice sequence must exist; need computable. following two
results literature used later paper.
Theorem 7. a) NP P/poly, polynomial hierarchy collapses (Karp & Lipton,
1980, Theorem 6.1). b) Let k > 0 integer. pk pk /poly, polynomial
hierarchy collapses level k + 2 (Yap, 1983, Lemma 7 combined Theorem 2).
3SAT problem consists instances form C = {c1 , . . . , cm } ci ,
1 m, called clause set exactly three literals universe
binary variables. instance C satisfiable exists assignment truth
values variables used C least one literal true ci C.
otherwise unsatisfiable. Deciding satisfiability 3SAT NP-complete, deciding
unsatisfiability coNP-complete. precisely, use following definition
3SAT paper.
147

fiBackstrom & Jonsson

Definition 8. integers n > 0, let Xn = {x1 , . . . , xn } set variables let
m(n)
m(n) number possible 3-literal clauses Xn . Let c1n , c2n , . . . , cn

m(n)
1
2
fixed systematic enumeration clauses let Cn = {cn , cn , . . . , cn }. clause
m(n) 1
cin defines three literals that1 cin = {`1i , `2i , `3i }. Further, let Cn0 , Cn1 , . . . , Cn2



fixed systematic enumeration subsets Cn , let n = hXn , Cn i, 0 <
m(n)
2m(n) . implicitly define set En = {e1n , e2n , . . . , en } atoms subsets
Eni = {ejn | cjn Cni }, 0 < 2m(n) .
m(n)

1 systematic enumeration possible 3SAT instances
sequence 0n , 1n , . . . , 2n
n variables, hence equivalent usual definition 3SAT. Technically speaking,
redundant encoding 3SAT since allows instances specify variables
used clauses. harmless, however; non-redundant instances remain,
still hard instances neither redundantly encoded instances
harder non-redundant counterpart. Since m(n) 8n3 , enumerations
Cn En chosen polynomial-time computable, assume
enumerations fixed on. note set Eni uniquely
identifies clause set Cni .

3. Representing Arbitrary Plans Compactly
known cases planning instances exponential-size plans
plans always polynomial-size representation (Gimenez & Jonsson, 2008).
obvious question thus whether plans, including exponential length,
polynomial representations. one interpretation question answer trivially yes.
Observation 9. set plans arbitrary FFP([P]) instance p O(||p||)
size representation, since instance together deterministic planning algorithm
successively enumerates outputs plans representation.
Although trivial useful observation highlights fundamental issues representations. Liberatore (2005a) discusses similar representation, instead
specifying algorithm defines lexiographic ordering actions. Furthermore,
adds plan index able represent single plan rather whole set
plans. However, index unproblematic, see soon.
interesting interpretation question whether every single plan
particular instance polynomial representation. Even precisely,
polynomial p every plan every planning instance representation
size O(p(n)), n size planning instance? investigate question
consider simple compact notation possible, index number plan
particular instance. Since instances may infinitely many plans, due cycles
state-transition graph, consider optimal plans only. is, however, guarantee
even index small enougha polynomial number bits may sufficient
represent it.
1. sometimes omit index n, assumed obvious context, thus write `ki rather
`kn,i .

148

fiAlgorithms Limits Compact Plan Representations

Construction 10. Given arbitrary integer n > 0, construct Strips instance p n =
hVn , , , Gn Vn = {x1 , . . . , xn , y}, = , Gn = {x1 , . . . , xn } contains
actions
ai : {xi , xi1 , . . . , x1 } {xi , xi1 , . . . , x1 , y} (1 n)
bi : {xi , xi1 , . . . , x1 } {xi , xi1 , . . . , x1 , y} (1 n).
Lemma 11. every integer n > 0, instance pn according Construction 10 22
optimal plans.

n 1

Proof. Let n > 0 arbitrary integer p n corresponding Strips instance according
Construction 10. instance binary counter variables x1 , . . . , xn
Construction 5, except extra variable independently set
true false, depending whether action type ai bi chosen. Since variables
x1 , . . . , xn interpreted binary number, let notation hm, yi represent
state x1 , . . . , xn encodes number false, let hm, yi represent
corresponding state true. Whenever state hm, yi hm, yi (where < 2n 1)
possible go either hm + 1, yi hm + 1, yi using one action,
states. state transition graph instance appears Figure 1. initial state
h0, yi goal states h2n 1, yi h2n 1, yi. Hence, plan p n must
length 2n 1. every state goal state two different actions
choose lead different states. However, goal reachable
n
states choice action matter. Hence, 22 1 different
plans p n .

m=

0

1

2n 1
y=1

2

y=0
goal

init

Figure 1: State-transition graph proof Lemma 11.
Although atom redundant particular example whole construction could
part larger instance, purpose. noted
instances used proof optimal plans; plans length.
set prove previous claim.
Theorem 12. every integer n > 0, takes 2n 1 bits index optimal plans
instance pn according Construction 10.
Proof. Since m-bit number distinguish 2m different objects,
follows Lemma 11 least 2n 1 bits necessary index plans p n
149

fiBackstrom & Jonsson

result immediately implies (optimal) plans Strips instance
polynomial-size representations. holds even restrictions, unary actions.
basing Construction 10 Gray counter instead binary counter every action
two postconditions. Rewriting using Construction 4 yields equivalent instance
unary actions using block four actions action original instance.
Although plans get 4 times longer number plans remain same. Hence,
Theorem 12 still holds.
theorem leaves possibility open plans instance
polynomial representations, although can. interesting question thus
many plans instance polynomial representations? answer
question stray field information theory Kolmogorov complexity.
scope paper treat field detail, loosely speaking, Kolmogorov
complexity string size smallest DTM generate string
input. Let K(x) denote Kolmogorov complexity binary string x. following
lemma due Buhrman et al. (2000, Lm. 1).
Lemma 13. (Incompressibility lemma) Let c positive integer. Every set cardinality
least m(1 2c ) + 1 elements x K(x) blog mc c.
lemma used show fraction plans compactly represented
approaches zero size instances approaches infinity.
Theorem 14. Let p arbitrary polynomial. Consider instances pn according Construction 10 arbitrary integers n > 0. Let t(n) total number plans
pn let s(n) number plans represented p(n) bits.
limn s(n)
t(n) = 0.
n

Proof. Let p arbitrary polynomial. know Lemma 11 t(n) = 22 1 .
every n > 0, let c(n) = 2n p(n) 2. incompressibility lemma says
least t(n)(1 2c(n) ) + 1 plans K() blog t(n)c c(n).
is, 2c(n) t(n) 1 plans K() < blog t(n)c c(n). Using
values t(n) c(n) above, simplifies say 2p(n)+1 1
plans K() p(n). Hence, s(n) 2p(n)+1 1. theorem follows since
2p(n)+1 1
0 limn s(n)
= 0.
t(n) limn 22n 1
means even case plans every solvable instance
compact representations, probability particular plan compact representation
vanishingly low large instances. Although strictly necessary use
Kolmogorov complexity prove Theorem 14 makes information-theoretic
aspect compact representations clearer.

4. Uniform Compact Representations Plans
know cannot, general, compress arbitrary exponential plans subexponential size. choose plan use? previous
result still leaves open possibility small fraction solutions planning instance could compact representations. However, planner (or oracle whatever)
150

fiAlgorithms Limits Compact Plan Representations

would choose us plan present us compact representation
of. Suppose planner could actually this, would make use it? still need
actual plan cannot avoid exponential size. Hence, interesting case
seems could least access useful information plan efficiently.
term representation used loose sense here, need really precisely
defined moment. suffices note representation needs kind
data structure kind access algorithm, extreme cases either
vector data trivial access algorithm algorithm embeds data.
could mean access compact representation efficiently? investigate
two criteria. first one efficiently retrieve actions actual
plan sequentially. interpretation efficient actions retrieved
polynomial delay (Johnson, Papadimitriou, & Yannakakis, 1988). second criterion
action actual represented plan random accessed polynomial time,
size instance.
looking explicit representations plan take look uniform
case, single representation covers instances. precisely,
consider case single algorithm works compact representation
plan every solvable instance.
Theorem 15. algorithm solvable Strips instance p either
generate plan p sequentially polynomial delay random access action
plan p polynomial time, P = NP.
Note theorem follow fact Strips planning PSPACEcomplete since solvable instances considered. proving theorem need
introduce extra technical machinery. start encoding 3SAT instances according
Definition 8 Strips follows.
Construction 16. Let n > 0 i, 0 < 2m(n) , arbitrary integers. Construct
Strips instance p = hVn , , Eni , {goal}i Vn = Xn En {cts, ctu, goal, inc}
{v0 , . . . , vm(n) } actions specified Table 1.
previously noted, subset Eni En uniquely identifies 3SAT instance telling
clauses Cn enabled . is, initial state selects particular nvariable instance interested in. actions partitioned three groups. Group
contains two actions acs acu, set atoms cts ctu respectively.
actions block cts ctu initially false, one atoms
set true plan. is, cts ctu mutually exclusive. Group II consists
actions require cts true group III consists actions require ctu true.
two groups actions thus mutually exclusive. Hence, every plan must start
exactly one action group rest plan consists actions
either group II group III, depending first action is. intention
following: plan starts action acs commits verifying
satisfiable plan starts action acu commits verifying
satisfiable. either case plan ends action satisfies goal plan
verified commitment made first action. interpreted viewing
151

fiBackstrom & Jonsson



acs : {ctu} {cts}
acu : {cts} {ctu}

Commit prove satisfiability
Commit prove unsatisfiability

II

aseti : {cts, v0 } {xi }
avt0 : {cts} {v0 }

Set xi
Start verification

avt0j : {cts, ejn , vj1 ,} {vj }
avtkj : {cts, ejn , vj1 , `kj } {vj }
ags : {cts, vm(n) } {goal}

Skip disabled clause cj
Verify cj true since `kj true
Conclude instance satisfiable

avf j : {ctu, inc, ejn , `1j , `2j , `3j } {inc}
aixi : {ctu, inc, xi , xi1 , . . . , x1 }
{inc, xi , xi1 , . . . , x1 }
agu : {ctu, inc, x1 , . . . , xn } {goal}

Verify clause cj false
Increment counter

III

Conclude instance unsatisfiable

Index ranges: 1 n, 1 j m(n) 1 k 3.

Table 1: Actions Construction 16.
planner theorem prover first outputs theorem (the first action plan)
proof theorem (the rest plan).
Lemma 17. every integer n > 0 integer 0 < 2m(n) , Strips
instance pin according Construction 16 following properties:
1. computed polynomial time n.
2. corresponds 3SAT instance sin every plan pin starts action
acs sin satisfiable otherwise action acu.
3. always least one plan.
Proof. Property 1 trivial prove. prove property 2, first note initial
state contains atoms En . previously noted, subset Eni En uniquely
identifies 3SAT instance telling clauses Cn enabled .
two cases: plan starts action acs commits verifying

n satisfiable plan starts action acu commits verifying
satisfiable. either case plan ends action satisfies goal
plan verified commitment made first action. details two cases
follows.
plan verifies satisfiability, must form
k

m(n)
hacs, aseti1 , . . . , asetih , avt0 , avtk11 , . . . , avtm(n)
, agsi.
{z
}
|
|
{z
}

assign

verify

assign block h actions set satisfying assignment x1 , . . . , xn . verify
k
block consists one action = avtj j clause cjn . cjn enabled (ejn true),
1 kj 3 verifies `kj cjn true assignment. Otherwise, cjn
152

fiAlgorithms Limits Compact Plan Representations

disabled kj = 0, = avt0j skips cjn without verifying anything.
planner thus
1. committed verify satisfiable,
2. chosen satisfying assignment x1 , . . . , xn
3. chosen one literal enabled clause witness clause true
assignment.
last action ags makes goal true three steps successful. Note
works case clause enabled, corresponds trivially
satisfiable instance empty set clauses. Obviously, plan form
satisfiable.
plan instead verifies unsatisfiability, must form
hacu, b0 , a1 , b1 , a2 , b2 , . . . , ah , bh , agui,
h = 2n 1. Except first last actions, plan viewed two
interleaved sequences
= ha1 , . . . , ah = haix1 , aix2 , aix1 , aix3 , . . . , aix1

= hb0 , b1 , . . . , bh i.
aixi actions increment actions use x1 , . . . , xn form binary counter. Since
variables correspond number 0 initial state 2n 1 increment
actions, subplan enumerates possible truth assignments x1 , . . . , xn . Sequence
consists actions type avf j . avf j action verifies corresponding
clause cjn enabled false current assignment x1 , . . . , xn . aixi actions
require inc true set false, avf j actions instead require inc false
set true. Hence plan synchronised alternates actions
two sequences. Since first aixi action preceeded avf j action
avf j action last aixi action, follows must unsatisfied
enabled clause every possible truth assignment, since synchronization otherwise
get stuck counter cannot increment. is, plan type
unsatisfiable. last action agu makes goal true succeeded. Note
case need actions skip disabled clauses since sufficient
demonstrate one enabled clause false assignment.
follows plan first form satisfiable second form

n unsatisfiable. Furthermore, since first action commitment rest
plan whether verify satisfiability unsatisfiability, sufficient check action
decide satisfiable not.
Property 3 follows immediately property 2 since plan must either
two forms.
necessary tools prove theorem.
153

fiBackstrom & Jonsson

Proof Theorem 15. Suppose algorithm either sequential random access stated precondition theorem. solve 3SAT instance
polynomial time asking algorithm first action plan
corresponding instance p tell action whether satisfiable. However,
implies P = NP.
proof would still hold rewriting Construction 16 described Construction 4,
is, Theorem 15 holds even restricted set unary Strips instances only.

5. Non-Uniform Compact Representations Plans
Theorem 15 uses strong criterion: requires one single algorithm handle
instances. relaxed variant non-uniform case, allow different
representations different instances. is, consider compact representations
single plans different access criteria. order must first define
precisely mean representations.
5.1 Compact Representations Access Mechanisms
define concepts Csar Crar representations action sequences
characterised access properties2 .
Definition 18. Let f arbitrary function. Let f = hV, D, Ai FFP([P]) frame
let . representation DTM. Furthermore:
1. f -compact |||| f (||f ||) runs f (||f ||) space including input
output tapes.
2. f -compact sequential-access representation (f -Csar) f -compact,
takes input generates actions sequentially f (||f ||) time
successive action.
3. f -compact random-access representation (f -Crar) f -compact
arbitrary index (where 1 ||) input, outputs action
f (||f ||) time.
Note definition require representations computable.
could used two separate functions, one bound access time one bound
size, would allow better precision. However, choose use single function
since makes theory simpler clearer sufficient precision
purposes paper. consider output tape cleared actions
output single action, sequence . note space complexity
includes input output tapes, implies longest sequence f -Crar
2. Note definition differs slightly previous one (Backstrom & Jonsson, 2011b). First,
generalised definition allow compact representations arbitrary function f ,
arbitrary polynomial. Second, order improve precision longer use O() notation
exact functions. Finally, representations restriction space time. None
changes matter results previous publication, details proofs.

154

fiAlgorithms Limits Compact Plan Representations

represent less 2|||| actions since input limited |||| bits. Csar
corresponding limit since input. Furthermore, time restriction f -Csar
viewed generalisation polynomial delay concept restricted
polynomials. often apply definition instances rather frames. Although
makes slight difference technically, important principle ignoring
allows simpler theorems proofs. write Crar Csar referring
whole family representations particular type.
5.2 Sequential-Access Representations
sequential access non-uniform case would ask solvable Strips
instances least one plan polynomial Csar. Unfortunately, still remains
open question. Hence, consider restricted case question
require Csar must verifiable within resource constraint, define
follows.
Definition 19. every FFP([P]) plan representation type R, define following decision problem:
Plan Representation Verification
Instance: FFP([P]) instance p = hV, D, A, I, Gi string .
Question: R-representation plan p?
complexity verification measured ||p|| + ||||. state following
theorem polynomial Csars.
Theorem 20. Let C arbitrary complexity class p arbitrary polynomial.
p-Csar verification NP C every solvable Strips instance least one plan
corresponding p-Csar, PSPACE NP C .
Proof. Let p arbitrary polynomial. Suppose p-Csar verification NPC every
solvable Strips instance least one plan corresponding p-Csar. Let p
arbitrary Strips instance. decide p plan guessing string
length p(||p||) bits check string p-Csar plan p.
done polynomial time (in ||p||) using NTM oracle C since p-Csar
verification NPC . However, deciding Strips instance plan PSPACEcomplete (Bylander, 1994, Thm. 3.1) follows PSPACE NPC , since p
chosen arbitrarily.
is, Csar planning instance limited use must first verify
correct using it, since verification may difficult solving instance itself.
note C class polynomial hierarchy, PSPACE NPC implies
collapse hierarchy. preceding theorem holds restriction unary Strips
instances, since planning still PSPACE-complete restriction (Bylander, 1994,
Thm. 3.3). fact, holds restrictions planning still PSPACE-complete,
includes several cases Bylanders analysis well many subclasses
SAS+ planning (see Backstrom & Nebel, 1995; Jonsson & Backstrom, 1998a, overviews
results).
155

fiBackstrom & Jonsson

Although result may seem disapointing, holds condition
must check whether Csar correct. means, instance, theorem
irrelevant correctness Csar guaranteed design. One case following.
Theorem 21. Every Strips instance according Construction 16 plan
polynomial Csar.
Proof. Consider arbitrary instance p . Add n + 1 extra bits b0 , . . . , bn b0
tells satisfiable not. satisfiable remaining bits specify satisfying
assignment bi gives value vi , otherwise undefined. claim
simple deterministic algorithm uses p b0 , . . . , bn generates
plan p polynomial delay follows.
Suppose b0 says satisfiable h bits b1 , . . . , bn one.
plan p form
k

m(n)
, agsi.
hacs, aseti1 , . . . , asetih , avt0 , avtk11 , . . . , avtm(n)
{z
}
|
{z
}
|

assign

verify

actions assign block easily generated b1 , . . . , bn . avtkj actions,
output avt0j cjn enabled otherwise output avtkj smallest k `kj
true specified assignment. Clearly algorithm works polynomial delay.
Instead suppose satisfiable. plan second type must cycle
possible assignments. generating corresponding counting
actions trivial. assignment must output avf j action. Determine
smallest j cjn enabled satisfied current assignment,
output avf j . done polynomial time since polynomial number
clauses.
Clearly construction polynomial Csar plan p .
following theorem demonstrates general harder classes
instances even optimal plans polynomial Csars design.
Theorem 22. subclass X Strips polynomial p deciding
instances X plan PSPACE-complete solvable instances X
optimal plan p-Csar.
Proof. PSPACE characterised class polynomial-space bounded DTMs.
Bylander (1994, Thm. 3.1) used fact demonstrate polynomial reduction
PSPACE Strips planning. refer Bylander details brief: given
machine input x constructs deterministic Strips instance plan
(x) accepts. Hence, polynomial time problem check
valid state find action, any, applied state. follows
polynomial p every solvable Strips instance plan
p-Csar. Furthermore, since instance deterministic one plan,
must optimal.
156

fiAlgorithms Limits Compact Plan Representations

even general observation every deterministic FFP([P]) instance
solvable exactly one plan, thus optimal, plan polynomial
Csar. contrast next consider class instances solvable instances
always plans polynomial Csars optimality guarantee.
example thus illustrates Csar representation gives guarantees
actual data represents. precisely, example uses class reversible
FFP([P]) instances, state-transition graph symmetric.
Definition 23. FFP([P]) frame f = hV, D, Ai reversible pairs states
S(f ), whenever action action a0
s.
Note reversible instances easy special case planning; deciding
plan still PSPACE-complete (Jonsson et al., 2000, Thm. 18). is, plans
still exponential length.
Theorem 24. polynomial q polynomials p, every solvable
reversible FFP(p) instance (q p)-Csar plan.
Proof. Let p = hV, D, A, I, Gi solvable FFP(p) instance f = hV, D, Ai
reversible. Consider algorithm Figure 2. Optplan assumed algorithm
optplan(s,G) returns length shortest plan G.
ignoring process B, clear algorithm outputs optimal plan p since
plan assumption. Process B finds two actions a1 a2 executing
ha1 , a2 state ends state s. choice actions must exist since
plan goal state f reversible. synchronisation processes
B make actions a1 , a2 appear adjacent order output
algorithm, thus interfere plan produced process A.
make plan longer. Choosing actions process B done double loop
pairs actions checking them.
obvious polynomial r process B runs r(||p||) time.
choose r allow extra time run process parallel. Let p together
algorithm. |||| ||p|| + c constant c. Choose r satisfies
n + c r(n) n > 0. Obviously, r-Csar plan p. Choose
polynomial q r(n) q(p(n)) n > 0.
Algorithm Optplan must obviously run polynomial space, complexity otherwise
important. parallel algorithm used proof theorem extent
nonsense algorithm. Process job consulting ordinary planning algorithm
(optplan) gives time guarantees. Process B, hand, contributes nothing
relevant plan satisfies access time requirement. is, process B buys time
process find plan generating irrelevant actions frequently enough satisfy
time requirements. wait statements strictly necessary illustrate
tune step complexity algorithm slowing process B desired.
Although example might, perhaps, considered somewhat pathological, clearly
demonstrates Csar (just Crar) representation.
data structures certain access properties guarantee particular
157

fiBackstrom & Jonsson

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

:=
G(s) = 0
parallel
process A:
` = optplan(s, G)
a0 s.t. pre(a0 )(s) = 1
:= post(a0 )(s)
optplan(t, G) < `
:= a0 , ` := optplan(t, G)
process B:
process running
choose a1 s.t. pre(a1 )(s) = 1
u := post(a1 )(s)
choose a2 s.t. pre(a2 )(u) = 1 post(a2 )(u) =
output a1
wait
output a2
wait
output
:= post(a)(s)

Figure 2: Csar algorithm reversible instances.
properties actual data stored. uncommon plan representations either.
instance, reactive plan could constructed behaviour still
considered correct run polynomial time space. alternatively use
random walk algorithm, output actions polynomial delay.
eventually reach goal plan, output lot redundant
actions. algorithm Figure 2 may, sense, viewed derandomized variant
random walk.
5.3 Random-Access Representations
case non-uniform random access clearer case sequential access.
answer question existence Crars without qualifications
verifiability.
Theorem 25. polynomial p every solvable Strips instance
least one plan corresponding p-Crar, polynomial hierarchy collapses.
Since theorem conditioned verifiability representations stronger
result Theorem 20. proving theorem need introduce additional theory.

158

fiAlgorithms Limits Compact Plan Representations

Construction 26. Let n > 0 arbitrary integer. Construct Strips instance p n =
hVn , , , {goal}i
Vn = Xn En {v0 , . . . , vm(n) } {svi, sva, sia, sii, sti, t, f, goal}
actions specified Table 2.

abi : {svi, sva, sia, sii, sti} {svi, t}

Begin instance block

aba : {svi, sia} {sva, f , v0 , v1 , . . . , vm(n) }

Begin assignment block

avtkj : {sva, vj , vj1 , ejn , `kj } {vj }
avf j : {sva, vj , vj1 , ejn , `1j , `2j , `3j } {vj , f }

Verify `j true clause cj
Verify clause cj false

avsj : {sva, vj , vj1 , ejn } {vj }

Skip disabled clause cj

aaf : {sva, vm(n) , f } {sva, sia}
aat : {sva, vm(n) , f } {sva, sia, t}

Verify assignment satisfying
Verify assignment satisfying

aixi : {sia, xi , xi1 , . . . , x1 } {sia, xi , xi1 , . . . , x1 }
arx : {sia, xn , . . . , x1 } {sia, svi, sti, xn , . . . , x1 }

Increment assignment counter
Reset assignment counter

ais : {sti, t} {sti, sii}
aiu : {sti, t} {sti, sii}

Verify instance satisfiable
Verify instance unsatisfiable

1
aiij : {sii, ejn , enj1 , . . . , e1 } {sii, ejn , ej1
n , . . . , en }

Increment instance counter

ari :

m(n)
{sii, en , . . . , e1n }

{goal}

instances checked

Index ranges: 1 n, 1 j m(n) 1 k 3.

Table 2: Actions Construction 26.
previous Construction 16 allows plans two types, either choosing assignment
verifying clauses chaining, enumerating assignments demonstrate
one false clause each. Construction 26 mixes methods. check instance
satisfiable plan must enumerate variable assignments assignment
must walk clauses chaining. enabled clause demonstrates
either true literal none literals true, disabled clauses skipped
over. Atoms f keep track whether clauses true assignment,
m(n)
case instance satisfiable. extra counter uses variables e1n , . . . , en
enumerates possible subsets Eni En , thus implicitly enumerating 3SAT instances
m(n) 1
0n , . . . , 2n
. counter constitutes outer loop, Eni , possible
assignments x1 , . . . , xn tested described above. plan thought
implementing algorithm Figure 3.
Lemma 27. integers n > 0, instance pn according Construction 26
following properties:
1. computed polynomial time n.
159

fiBackstrom & Jonsson

1
3SAT instances size n
2
clear
3
assignments x1 , . . . , xn
4
clear f
5
clauses cj
6
cj disabled
7
nothing
8
elsif `kj cj satisfied
9
nothing
10
else (neither `1j , `2j `3j satisfied)
11
set f
12
f
13
set
14

15
report satisfiable
16
else
17
report unsatisfiable
Figure 3: Algorithmic description Construction 26.
2. always least one plan.
3. exist constants bn every i, 0 < 2m(n) , action
position bn + plan pn ais 3SAT instance sin satisfiable
aiu sin unsatisfiable.
Proof. addition previous explanation construction note instance
designed deterministic. Setting = 2n (m(n) + 3) + 2 bn = + 1 satisfies
claim, since action position bn + ais satisfiable aiu
unsatisfiable.
set prove theorem.
Proof Theorem 25. Suppose p polynomial solvable Strips instances
least one plan corresponding p-Crar. n > 0, let p n
corresponding instance according Construction 26 let n p-Crar plan
n p n . assumption, n n must exist every n.
Construct advice-taking DTM takes input form = hp n , ii,
n integers n > 0 0 < 2m(n) . Let represented binary
using exactly m(n) bits. Then, ||I || strictly increasing n depends n.
Let sn = ||I || (which well defined since ||I || depend i). Define advice
function a(sn ) = n . advice thus p-Crar plan Strips
instance p n according Construction 26. (Recall need know
advice exists, find it.) Let bn refer corresponding constants
must exist according Lemma 27. Since run whatever algorithm used access
n , follows assumptions find action bn + n polynomial
time sn . Let return yes action ais otherwise return no.
160

fiAlgorithms Limits Compact Plan Representations

Given arbitrary 3SAT instance , compute corresponding input
run instance. construction, answers yes satisfiable. input computed polynomial time ||s || runs polynomial time using polynomial advice. Since solves satisfiability 3SAT follows
NP P/poly, impossible unless polynomial hierarchy collapses level 2
according Theorem 7a.
worth noting plans instances according Construction 26
contains subplan every 3SAT instance particular size. Hence, alternatively
view plan representation set exponentially many plans, shows
representing one long plan representing large set plans fundamentally
different issues.
Crars restricted cases prove always exist.
One example is, again, Construction 16.
Theorem 28. Every Strips instance according Construction 16 plan
polynomial Crar.
Proof. Add n+1 extra bits b0 , . . . , bn explained proof Theorem 21 construct
polynomial-time random-access algorithm follows.
Suppose b0 says satisfiable h bits b1 , . . . , bn one.
plan p form
k

m(n)
hacs, aseti1 , . . . , asetih , avt0 , avtk11 , . . . , avtm(n)
, agsi.
|
{z
}
|
{z
}

assign

verify

Since h n construct whole assign sequence determine specific action
polynomial time. avtkj actions correspond specific clause cjn . Since
clauses ordered compute j index action ask for. cjn
enabled output avf 0j otherwise output avf kj smallest k `kj
true specified assignment b1 , . . . , bn .
Instead suppose satisfiable. first last actions interleaved aixi avf j actions. aixi actions function counter
variables x1 , . . . , xn . Let arbitrary index plan first
last action. odd, ai aixk action k easily computed i,
output aixk . even ai avf j action. value x1 , . . . , xn immediately
ai easily computed i. Use value check enabled clauses
order finding clause cjn satisfied output avf j .
Clearly construction polynomial Crar plan p .
Another much larger class instances plans Crars considered
next section.
5.4 Relationships Compact Representations
section investigate Crar Csar concepts relate other. Since
macro plan viewed compact representation investigate macro
161

fiBackstrom & Jonsson

plans relate concepts. start showing polynomial Crar
plan polynomial Csar plan.
Theorem 29. polynomial q polynomials p, FFP([P]) frames
f = hV, D, Ai , p-Crar, (q p)-Csar.
Proof. Let f arbitrary FFP([P]) instance let p-Crar plan f .
Use action counter initiated index first action plan. Generate
actions plan sequentially repeatedly asking action indexed counter
incrementing counter. Let 0 denote algorithm together . ||||-bit
counter sufficient since must shorter 2|||| actions. Suppose takes r(m) time
increment m-bit counter. constant c ||0 || |||| + c, 0 runs
2p(||f ||) + c space 0 runs p(||f ||) + r(p(||f ||)) + c time. Define polynomial q
q(n) = 2r(n)+c. Obviously, ||0 || ||||+c q(||||) q(p(||f ||)), 2p(||f ||)+c q(p(||f ||))
p(||f ||) + r(p(||f ||)) + c q(p(||f ||)) 0 (q p)-Csar .
opposite hold, however. particular, instances according
Construction 26 plan Crar plan Csar,
construction acts separation two concepts.
Theorem 30. Unless polynomial hierarchy collapses, polynomial q
every polynomial p, every Strips instance p every plan p, p-Csar
(q p)-Crar.
Proof. Let X denote class Strips instances used proof Theorem 25. Since
instances deterministic polynomial p every solvable instance
p-Csar plan. However, follows proof
polynomial r instances X plan r-Crar. Hence,
polynomial q instances plan (q p)-Crar.
Although previously defined paper, makes sense look
macro plans context. macro sequence two actions. Macros
commonly used planning treated single action planner. Macros
useful planning certain subsequences actions occur frequently
plans (Korf, 1987). However, macros may used purpose representing
plan compact structured way. especially true macros allowed
contain macros, since allows hierarchies macros. instance, well
known shortest solution Towers-of-Hanoi problem arbitrary number
disks described recursive schema (Gill, 1976, Ex. 319) although plan
exponential number disks. 3S class planning instances (Jonsson &
Backstrom, 1998b) property always find polynomial time
instance plan, plan may exponential length thus cannot
generated subexponential time. Gimenez Jonsson (2008) showed plans 3S
instances always polynomial-size representation using macros. fact, macro
plan even generated polynomial time although actual non-macro plan would
take exponential time generate. result later generalised classes
162

fiAlgorithms Limits Compact Plan Representations

planning instances Jonsson (2009). show polynomial-size macro plans
immediate connection compact plan representations. However, contrast
Gimenez Jonsson discuss generate macro plans analyse
properties.
Macro plans powerful tools representing plans compactly. Hence,
interesting identify criteria compact macro-plan representations exist not.
problem scope paper, give partial answer
question following way. straightforward see macro plan viewed
context free grammar (CFG): let actions terminals, let macros
variables, let macro expansions production rules let root macro
start symbol. note use macros represent single plan, rather represent various possibilities planning, macro expansions must acyclic order
produce unique well-defined plan. Hence, macro plan defined acyclic CFG.
CFGs used represent single string compactly often referred
compressed grammars. Furthermore, compressed grammar permits efficient
random access string represents; access necessary preprocessing
polynomial time size grammar (Bille et al., 2011). precisely, consider
grammar size n represents string length N derivation tree maximum
height h. polynomial time preprocessing, size grammar, possible
random access symbol string index O(log N ) time or, alternatively,
O(h) time. algorithms typically work first computing length substrings
generated rule, preprocessing step, use information find
symbol certain index top-down search. Since grammar acyclic get h n.
Hence, following proposition immediate properties compressed grammars.
Proposition 31. polynomial r every FFP([P]) frame hV, D, Ai
every macro plan sequence , used random access action
r(||||) time.
thus get following relationship macro plans Crars.
Theorem 32. polynomial p polynomials q, FFP([P]) frames
f = hV, D, Ai action sequences , macro plan ||||
q(||f ||) (p q)-Crar.
Proof. Let r polynomial macro plans 0 random accessed r(||0 ||)
time. Let together random access algorithm. |||| |||| + c
constant c. Define p p(n) = r(n) + c. get |||| |||| + c q(||f ||) + c
r(q(||f ||)) + c = p(q(||f ||)). Furthermore, runs r(||||) r(q(||f ||)) + c = p(q(||f ||))
space time. follows (p q)-Crar .
follows Theorem 29 every plan polynomial macro plan
polynomial Crar. is, class polynomial macro plans subclass class
polynomial Crars, know proper subclass. way, results
imply cannot always find polynomial macro plan instance.
Corollary 33. polynomial p every solvable Strips instance
least one plan corresponding macro plan size p(||p||) polynomial hierarchy collapses.
163

fiBackstrom & Jonsson

Proof. Immediate Theorems 25 32.

6. Problem Reformulation
concluded seems little hope plans compactly
represented general case, turn idea problem reformulation see
help. may seem place context is, contrary,
quite logical step take. far, analysed planning problems plans,
results hold for. obvious that, when, results hold
planning instances solved reformulating instances problem.
thus hypothetically possible could get around problems approach.
However, say something useful relevant this, sufficient look
naive approaches, polynomial reductions, investigate stronger criterion.
basic idea reformulation transform planning instance another equivalent instance, either another planning instance instance problem.
reformulation useful, solution new instance must use solve
original instance, something must gained. Often, reformulation used intention overall process faster solving original instance directly. Common
variants reformulate planning SAT, CSP, model checking another planning
problem. Reformulation planning SAT first suggested Kautz Selman
(1992) still popular approach planning. Long, Fox, Hamdi (2002) discuss
reformulation planning general Edelkamp, Leue, Visser (2007) discuss
connections model checking planning.
reformulation process viewed shown Figure 4. planning instance p
solution find directly using ordinary planning. Solving p via reformulation
instead follows indirect path figure. First p reformulated new instance
R(p) (of problem). instance solved produces solution R(p).
Finally, transformed back solution p.

p
Direct

R(p)
Indirect




Figure 4: Reformulation generation problem.
Obviously, reformulation cannot help us plans exponential. Even first
two steps indirect path took polynomial time polynomial size, would
still necessarily take exponential time transform exponential.
164

fiAlgorithms Limits Compact Plan Representations

is, problem inherently intractable whichever method use solve it. Reformulation
could potentially speed things up, could somehow used directly solution
original problem, would happen rarely, all.
situation different, though, consider decision problem rather
generation problem, is, ask plan whether plan not.
case use solution R(p) directly, since decision problems two
possible answers, yes no. may thus escape inherent intractability. variant
reformulation shown Figure 5. Since exponential solution generated case,
reformulation could potentially efficient. know decision problem
Strips PSPACE-complete general case. reformulated problem easier
solve, could beneficial first reformulate p R(p) ask instance
solution not. would possible check solution
embarking generating possibly exponentially long plan. Consider, instance,
3S class (Jonsson & Backstrom, 1998b) plans may exponential size
always possible decide polynomial time plan. thus seems case
reformulating decision problems interesting one look at,
give improvement, hardly improvement plan generation
via reformulation either.

p
Direct

R(p)
Indirect

Yes/No

Yes/No

Figure 5: Reformulation decision problem.
Let PE(Strips) denote decision problem (that is, plan existence) Strips.
following two results trivial, illustrative.
Theorem 34. a) exists decision problem X function R holds
p PE( Strips) R(p) X p R(p) answer. b)
complexity class C, decision problem X C polynomial-time computable
function R holds p PE( Strips) R(p) X p R(p)
answer, PSPACE C.
Proof. a) Let X = PE(Strips) R identity function. b) Immediate, since R
polynomial reduction PE(Strips) X.
cases reformulate PSPACE-complete problem PSPACE-complete problem, interesting. prove anything better, must obviously
look X R useful restrictions.
165

fiBackstrom & Jonsson

important note reformulating planning NP-complete problem, instance SAT, magically make planning NP-complete. reason
Strips planning PSPACE-complete allows exponential solutions. soon
restrict solutions bounded fixed polynomial, planning belongs
NP. Furthermore, encodings planning instances SAT typically use atoms encode
actions appear position plan, is, exponential number extra
atoms required general case. Hence, either original problem already
NP blow instance exponentially reformulating SAT.
latter case, complexity results longer comparable. note, deliberately restrict ask plan certain length shorter,
actually solving restricted version optimization problem, case
planning would harder. fact, seems unlikely planning general
could reformulated problem NP. order avoid straightforward naive
approaches reformulation consider analyse reformulations defined follows.
Definition 35. Let p = hV, A, I, Gi Strips instance, let f = hV, Ai let = hI, Gi.
Let X decision problem. reformulation PE(Strips) X pair hR, ri
functions maps every instance p = hf , PE(Strips) corresponding instance
x = R(r(f ), ) X p x answer. hR, ri polynomial
reformulation fixed polynomials p, q
1) ||r(f )|| O(p(||f ||))
2) R computable O(q(||r(f )|| + ||d ||)) time.
thus consider reformulation involves two functions, R r. Function r
main reformulation function, intended reformulate difficult part instance.
even require function computable, require exists. Function
R used transform initial goal descriptions something similar
new instance use, combine result delivered r proper instance
X. noted reformulation concept similar, although identical,
compilation concept used Nebel (2000).
Theorem 36. polynomial reformulation PE( Strips) X NP,
unless polynomial hierarchy collapses.
Proof. Suppose hR, ri reformulation. arbitrary integer n > 0, let f un = hVn ,
defined Construction 16, without action acs, let = hEni , {goal}i,
0 < 2m(n) . follows trivially proof Lemma 17 instance
p = hf un , solution unsatisfiable (note SAT part
instance disarmed).
Construct advice-taking NTM input = hf un , ii, n > 0 0
< 2m(n) , representing binary using m(n) bits. Clearly, ||I || strictly increasing
depends n, let sn = ||I || (for arbitrary i). Define advice function
a(sn ) = r(f un ). (Note need know advice exists, find it).
Let first compute , compute x = R(a(sn ), ) = R(r(f un ), ),
polynomial time since a(sn ) given free advice. assumption, x X
answer yes p solution. assumption, X NP
166

fiAlgorithms Limits Compact Plan Representations

solve x guessing solution verifying polynomial time. Hence, deciding
p solution NP/poly.
arbitrary 3SAT instance , compute polynomial time. answers yes

n unsatisfiable. However, unsatisfiability 3SAT coNP-complete
follows coNP NP/poly, impossible unless polynomial hierarchy
collapses level 3, according Theorem 7b.
result pushed arbitrarily high polynomial hierarchy, thus making
unlikely planning could reformulated anything simpler all.
Corollary 37. polynomial reformulation hR, ri PE( Strips) decision
problem X pk , k > 1, unless polynomial hierarchy collapses level k + 2.
Proof sketch. Construction 16 demonstrates encode existential quantification
(choosing truth assignment sat part) universal quantification (enumerating
truth assignments unsat part). Hence, straightforward modify
analogous construction QBF formulae k alternations. Given that, rest
proof analogous proof Theorem 36, must use oracle pk1 .
argument leads pk pk /poly, impossible unless polynomial hierarchy
collapses level k + 2, according Theorem 7b.
Since proofs build Construction 16 rely exact position
actions follows Theorem Corollary hold restricted unary
Strips instances only.

7. Discussion
section consists five parts. first transfer reformulation theorem
general result adding information guide planners, discuss explain
various results literature. discuss potential relationship causal
graphs compact representations. followed discussion results
paper could relevant plan explanation. fourth part discusses related
work compact representations compilation. section ends summary
results list open questions.
7.1 Reformulation Additional Information
Theorem 36 broader consequences reformulation. fact, implies
way help planner adding information planning frame, matter
information get it, unless accept amount information
always polynomially bounded frame size. following theorem function g
assumed represent additional information, need even computable.
require result polynomially bounded.
Theorem 38. Let p arbitrary polynomial. Consider function g algorithm

1. g maps Strips frames {0, 1} ||g(f )|| O(p(||f ||)) frames f
167

fiBackstrom & Jonsson

2. Strips instances p = hf, i, algorithm answers yes input hp, g(f )i
p plan.
runs polynomial time, polynomial hierarchy collapses.
Proof. Assume function g algorithm properties described
theorem. Define function r r(f ) = hf , g(f )i every Strips frame f .
define function R R(hf , xi, ) = hhf , i, xi every Strips instance p = hf ,
every string x. R(r(f ), ) = hhf , i, g(f )i = hp, g(f )i, hR, ri polynomial
reformulation Strips planning equivalent problem algorithm solve
polynomial time. However, reformulation exist according Theorem 36,
unless polynomial hierarchy collapses.
result extended upwards polynomial hierarchy way Corollary 37 (no longer requiring polynomial algorithm). means cannot
make planning simpler adding polynomial amount additional information frame
use clever algorithm use information planning. Planning remain
hard without extra information. may sometimes help add information particular instance somehow guide planner, systematic way
add information frame level required polynomial size.
planning literature rich methods intended make planning
efficient adding information one way another, although methods perhaps
always thought so. non-exhaustive list methods, similar,
abstraction hierarchies, macros, case-based planning, annotated planning landmarks.
State space abstraction planning goes back least Abstrips planner (Sacerdoti, 1974). main idea form abstraction hierarchies variables, thus
implicitly actions, planner plan important goals
first get abstract plan refined detailed plan. Knoblock
(1994) proposed algorithm automatically computing abstraction hierarchies.
algorithm successful many examples demonstrated sometimes
fail produce exponential plans instances linear optimal plan (Backstrom
& Jonsson, 1995). surprising since use abstraction hierarchy
viewed adding information planning frame. Automatic generation abstraction
hierarchies systematic way add information thus treated special case
Theorem 38.
Adding set macros planning frame similar using abstraction hierarchies, Knoblock (1993, pp. 110111) noted. planner uses abstraction searches
plan abstract space tries refine action subplan lower
lever. planner uses macros search abstract space instead already
set macros available correspond subplan. Finding macro works
expanded thus similar refining abstract action. use
macros demonstrated speed planning considerably certain cases (Korf,
1987). Macros typically added frame level, learning suggested
one method create macros automatically (Korf, 1985). However, macros typically treated action planner expanded finding
plan. Hence, addition macros may backfire make planning less efficient,
168

fiAlgorithms Limits Compact Plan Representations

adding redundant actions may (Haslum & Jonsson, 2000). again,
surprising since addition macros addition information thus covered
Theorem 38.
Case based planning (see Spalazzi, 2001, survey) uses stored plans plan skeletons
planner tries reuse modifying and/or extending them. one sense,
similar macro planning, advanced macros macro expansion methods.
One view similar abstraction, plan must refined order
work. difference abstraction planner finds plan skeleton planning
abstract space case-based planner set plans stored database.
plans may handcoded, usually result learning previous planning
situations. well known case-based planning may fail improve efficiency
cases used must similar actual instance hand (Nebel & Koehler, 1995;
Liberatore, 2005b). explained special case Theorem 38.
term annotated planning sometimes used refer number similar techniques adding control information planner. Examples Prodigy planner
(Veloso et al., 1995) allows control information rules goal ordering
Tlplan (Bacchus & Kabanza, 2000) allows adding temporal-logic axioms control
planner. techniques good using hand-tailored control rules/axioms
particular application domain, immediate Theorem 38 cannot help
us general case.
Planning landmarks (Hoffmann, Porteous, & Sebastia, 2004) idea adding
explicit subgoals (called landmarks) planning instance. intention tell
planner landmarks must achieved plan order achieve overall
goal. Landmarks may ordered, guide planner. However,
authors point out, deciding variable value (or logic formula) necessary
subgoal PSPACE-complete problem. Hence, one usually considers incomplete
sets landmarks. interestingly, landmarks differ previous methods
important aspect; landmarks added instance level, frame level.
Although might quite rigid difference practice, seems fundamental
essence. Hence, adding landmarks non-uniform case adding information
thus immediately covered Theorem 38. meaningfully analyse non-uniform
case remains open question.
7.2 Causal Graphs
Knoblock (1994) defined ordering variables planning instance
used guidance finding abstraction hierarchies. ordering variables
fundamental 3S class (Jonsson & Backstrom, 1998b) ordering implicitly
defined abstraction hierarchy. concept ordering variables
intention defining abstraction hierarchy, define tractable subclasses etc. nowadays
usually referred causal graph (see Chen & Gimenez, 2010, survey using
properties causal graph define tractable subclasses planning). Many papers still
use Knoblocks definition, follows:
every Strips action let Vpre(a) = Atoms(pre(a)) Vpost(a) = Atoms(post(a)). Let
169

fiBackstrom & Jonsson

f = hV, Ai Strips frame. causal graph f directed graph GCG = hV,
u, v V , u v u 6= v
u Vpre(a) Vpost(a) v Vpost(a) .
idea behind causal graphs strongly connected component graph
correspond abstraction level. applying definition examples
paper, find instance according Construction 16 causal graph containing
large strongly connected component. is, would possible form good
abstraction hierarchies based causal graphs. However, Theorem 25 says
plans instances seem likely useful compact representations anyway.
Plans binary counter Construction 5 polynomial Crars since
polynomial macro plans. Yet, whole causal graph instance strongly
connected. hand, plans Gray counter Construction 6 exponential
polynomial Crars too, causal graph acyclic case. thus seems
causal graph type used Knoblock many others sufficient,
even necessarily useful, tool judging plans compact representations.
variants causal graphs, though. One example interaction networks (Chen &
Gimenez, 2010). Another Jonssons (2009) refined version Knoblocks causal graph,
defined follows:
Let f = hV, Ai Strips frame. refined causal graph f directed graph
GRCG = hV, u, v V , u v u 6= v either
1) u Vpre(a) Vpost(a) v Vpost(a)
2) u, v Vpost(a) either
a) a0 u Vpost(a0 ) v 6 Vpost(a0 )
b) a0 u 6 Vpost(a0 ) v Vpost(a0 ) .

major difference variant Knoblocks two variables
appear postcondition action, necessarily form cycle
graph. Hence, unary actions longer prerequisite acyclic graphs. using
refined causal graph, Gray counter binary counter acyclic
graphs, Construction 16 still large strongly connected component. is,
three examples acyclicity refined causal graph correlates whether plans
compact representations not. correlation seems hold general,
difference two types causal graphs suggests study variations
concept could lead insight topic compact representations.
turn fruitful, would likely carry areas causal
graphs used, model checking (Wehrle & Helmert, 2009).
7.3 Plan Explanation
results paper important plan explanation. Bidot et al. (2010)
suggest important planning systems (and AI systems) able
170

fiAlgorithms Limits Compact Plan Representations

explain plans decisions user, else user may trust system.
Similarly, Southwick (1991) writes:
seems general agreement amongst involved KBS research
order useful, system must able explain reasoning user.
Although consider advanced explanation methods, do, results
implications possible explain meaningfully. plan explanation, results
necessarily bad planning. Consider example plan instance
Construction 16. case 3SAT instance unsatisfiable, almost whole plan
consists alternating sequence form ha, b, a, b, a, b, . . .i, denotes either
actions aix 1 , . . . , aix n b denotes either actions avf 1 , . . . , avf . first
group actions together implement increment function, thus serve
purpose. Similarly, second group consists actions serve purpose
verifying clause false. abstraction action sequence could
form hinc, vfy, inc, vfy, inc, vfy, . . .i, inc denotes counting actions vfy
verification actions. purpose explanation, seems useful replace
actual actions abstract explanations functions. abstract sequence
easier understand, allows using macros compress it, might
enhance explaining power. However, particular case, would probably even
useful abstract whole sequence loop, similar. essentially
boils partitioning set actions equivalence classes
class consist actions meaningfully seen implementing concept.
seems interesting important investigate one partition
set actions equivalence classes useful abstractions.
Plan explanation could mean trace explanation model checking, would
analogously make long trace shorter abstract order make easier understand. well known close ties planning model checking,
model-checking traces viewed plans vice versa (Edelkamp et al., 2007).
number steps (or clock cycles) exponential number state variables;
even system divided subsystems, individual subsystems may exponential behaviour blows combined subsystems. exponential-size
plan/trace much use engineerit almost impossible task analyse
understand plan. planning/verifying system could autonomously find
repetitive patterns, even recursive repetitive patterns, plan abstract these,
would considerably easier understand happens why. fact, may
interesting execute plan, even simulator, compact understandable
explanation plan may actual goal.
Furthermore, Geib (2004) discusses problem combinatorial explosion plan recognition, exponential number plans may share plan prefix recognized far.
could clearly useful structured compact representations plan candidates
save space allow intelligent operations plans. Although
problem slightly different representing single long plan, seen
two problems related.
cases, primary purpose compact representation would thus find
exploit inherent structure plan, set plans, rather save space.
171

fiBackstrom & Jonsson

7.4 Additional Related Work
Liberatore (2005a) studied problem representing plans compactly
similarities well differences results ours. contrast us,
considers plans represented sequences states, sequences actions.
cases, considers random access representation well sequential representation. random-access representation action sequences (TA) essentially
Crar concept, except specifies must implemented circuit.
sequential representation action sequences (SA), hand, different
Csar concept. function takes state input returns next state.
Hence, restricted type reactive plan Csar, results
thus immediately comparable ours. instance, contrary Theorem 29
proves TA representation cannot polynomially converted SA representation,
clearly shows SA Csar quite different concepts. proof
planning instances plans SA representation thus obviously carry
Csars. Furthermore, uses planning language actions modelled
polynomial-size circuits. coincides class FFP([P]). Hence, hardness
proofs weaker since use restricted Strips language cases.
finally noted Liberatores Theorem 17 case TA representations
result similar Theorem 25, use different methods different conditions.
Nebel (2000) defines concept compilation planning languages. Although
ways similar reformulation concept, differences. compilation
function planning frame another frame different planning language.
compilation need resource bounded resulting frame must polynomially
bounded original frame. initial state goal must possible translate
polynomial time. is, first step corresponds function r second
step essentially corresponds function R. However, Nebel considers compilation
planning languages requires concept modularity present
approach. Furthermore, focus complexity decision problem
question whether size solutions preserved compilations.
7.5 Conclusions Open Questions
current status knowledge non-uniform compact representations
visualized Figure 6. outer box represents set solvable Strips instances
inner boxes represent subsets least one plan instance
Csar, Crar polynomial macro plan. know classes least one plan
instance guaranteed polynomial macro plan, Towers Hanoi 3S.
know classes least one plan instance Crar know
plans polynomial macro plan. Construction 16 example.
open question plan Crar polynomial macro plan.
know classes instance plan Csar know
Crar, example, class reversible systems. However, Construction 26
class instances plan Csar plan Crar,
case provides strict separation Csar Crar concepts. Whether
classes Strips instances plan Csar remains open question, though.
172

fiAlgorithms Limits Compact Plan Representations

plans
Plans w. Csar
Plans w. Crar

3S
Towers
Hanoi

Plans w. poly.
macro plans
?

?

anything
here?

reversible
systems

?

Construction 16

Construction 26

Figure 6: Current status Csars Crars.

thus following chain inclusions
polynomial macro plans Crar Csar Strips,
know first last inclusions strict.
Theorem 15 may seem weak since conditioned P 6= NP. Using similar
techniques proofs Lemma 27 Corollary 37 could encode QBF
arbitrary number alternating quantifiers and, hence, push result polynomial
hierarchy. However, remains open question condition could strengthened
way P 6= PSPACE.
argued number results hold restricted unary
instances, cases restrictions, otherwise largely unexplored
area. Little currently known various structural restrictions affect
results paper. applies whether plans Csars Crars
whether polynomial-size macro plans.
consider non-uniform case compact representations single plans
single instances, might interesting consider non-uniform case reformulation adding information. However, seems straightforward since could
always reformulate instance single bit telling whether instance solvable not.
reformulation clearly interesting additional criteria necessary.
previously (Backstrom & Jonsson, 2011a) defined complexity measure based
padding intended insensitive plan length. concept seems related
Nebels compilations, although two concepts identical directly comparable.
thus reasonable believe compact representations padded complexity
somehow related, especially since padded complexity motivated instances
long plans. However, yet know relationship is. Furthermore, would
173

fiBackstrom & Jonsson

interesting consider compilations look size compact representations
plan rather size explicit plans.
Acknowledgments
Malte Helmert, Anders Jonsson anonymous reviewers paper earlier
conference version provided valuable comments suggestions.

References
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116 (1-2), 123191.
Backstrom, C., & Jonsson, P. (2011a). PSPACE-complete planning problems equal
equal others. Proceedings 4th International Symposium Combinatorial Search (SoCS11) Castell de Cardona, Barcelona, Spain, pp.
1017.
Backstrom, C., & Jonsson, P. (2011b). Limits compact representations plans. Proceedings 21st International Conference Automated Planning Scheduling,
(ICAPS11), Freiburg, Germany, pp. 1825.
Backstrom, C. (1992). Computational Complexity Reasoning Plans. PhD dissertation, Linkoping University, Linkoping, Sweden.
Backstrom, C. (1995). Expressive equivalence planning formalisms. Artificial Intelligence,
76 (1-2), 1734.
Backstrom, C., & Jonsson, P. (1995). Planning abstraction hierarchies exponentially less efficient. Proceedings 14th International Joint Conference
Artificial Intelligence (IJCAI95), Montreal, QC, Canada, pp. 15991605.
Backstrom, C., & Klein, I. (1991). Planning polynomial time: SAS-PUBS class.
Computational Intelligence, 7, 181197.
Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11, 625656.
Balcazar, J. (1996). complexity searching implicit graphs. Artificial Intelligence,
86 (1), 171188.
Bidot, J., Biundo, S., Heinroth, T., Minker, W., Nothdurft, F., & Schattenberg, B. (2010).
Verbal plan explanations hybrid planning. Proceedings 24th MKWI
related PuK-workshop: Planung/Scheduling und Konfigurieren/Entwurfen (PuK10),
pp. 23092320.
Bille, P., Landau, G., Raman, R., Sadakane, K., Satti, S., & Weimann, O. (2011). Random
access grammar-compressed strings. Proceedings 22nd ACM-SIAM Symposium Discrete Algorithms (SODA11), San Fransisco, CA, USA, pp. 373389.
Bonet, B. (2010). Conformant plans beyond: Principles complexity. Artificial
Intelligence, 174 (3-4), 245269.
174

fiAlgorithms Limits Compact Plan Representations

Bonet, B., & Geffner, H. (2000). Planning incomplete information heuristic search
belief space. Proceedings 5th International Conference Artificial Intelligence Planning Systems (AIPS00), Breckenridge, CO, USA, pp. 5261.
Boutilier, C., & Poole, D. (1996). Computing optimal policies partially observable
decision processes using compact representations. Proceedings 13th National
Conference Artificial Intelligence (AAAI96), Portland, OR, USA, Vol. 2, pp. 1168
1175.
Brafman, R. I., & Domshlak, C. (2003). Structure complexity planning unary
operators. Journal Artificial Intelligence Research, 18, 315349.
Buhrman, H., Jiang, T., Li, M., & Vitanyi, P. M. B. (2000). New applications
incompressibility method: Part II. Theoretical Computer Science, 235 (1), 5970.
Bulatov, A., & Dalmau, V. (2006). simple algorithm Maltsev constraints. SIAM
Journal Computing, 36 (1), 1627.
Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69 (1-2), 165204.
Cadoli, M., Donini, F., Liberatore, P., & Schaerf, M. (2000). Space efficiency propositional
knowledge representation formalisms. Journal Artificial Intelligence Research, 13,
131.
Charikar, M., Lehman, E., Liu, D., Panigrahy, R., Prabhakaran, M., Sahai, A., & Shelat, A.
(2005). smallest grammar problem. IEEE Transactions Information Theory,
51 (7), 25542576.
Chen, H., & Gimenez, O. (2010). Causal graphs structurally restricted planning. Journal Computer System Sciences, 76 (7), 579592.
Edelkamp, S., Leue, S., & Visser, W. (2007). Summary Dagstuhl seminar 06172
directed model checking. Directed Model Checking, No. 06172 Dagstuhl Seminar
Proceedings. Dagstuhl, Germany.
Galperin, H., & Wigderson, A. (1983). Succinct representations graphs. Information
Control, 56 (3), 183198.
Geib, C. (2004). Assessing complexity plan recognition. Proceedings 19th
National Conference Artificial Intelligence (AAAI04), San Jose, CA, USA, pp.
507512.
Gill, A. (1976). Applied Algebra Computer Sciences. Prentice Hall. Englewood
Cliffs, NJ.
Gimenez, O., & Jonsson, A. (2008). complexity planning problems simple
causal graphs. Journal Artificial Intelligence Research, 31, 319351.
Haslum, P., & Jonsson, P. (2000). Planning reduced operator sets. Proceedings
5th International Conference Artificial Intelligence Planning Systems (AIPS00),
Breckenridge, CO, USA, pp. 150158.
Hoffmann, J., Porteous, J., & Sebastia, L. (2004). Ordered landmarks planning. Journal
Artificial Intelligence Research, 22, 215278.
175

fiBackstrom & Jonsson

Jansson, J., Sadakane, K., & Sung, W.-K. (2012). Compressed random access memory.
ArXiv, abs/1011.1708v2.
Johnson, D. S., Papadimitriou, C. H., & Yannakakis, M. (1988). generating maximal
independent sets. Information Processing Letters, 27 (3), 119123.
Jonsson, A. (2009). role macros tractable planning. Journal Artificial Intelligence Research, 36, 471511.
Jonsson, P., & Backstrom, C. (1998a). State-variable planning structural restrictions:
Algorithms complexity. Artificial Intelligence, 100 (1-2), 125176.
Jonsson, P., & Backstrom, C. (1998b). Tractable plan existence imply tractable
plan generation. Annals Mathematics Artificial Intelligence, 22 (3-4), 281296.
Jonsson, P., Haslum, P., & Backstrom, C. (2000). Towards efficient universal planning:
randomized approach. Artificial Intelligence, 117 (1), 129.
Karp, R. M., & Lipton, R. J. (1980). connections nonuniform uniform complexity classes. Proceedings 12th ACM Symposium Theory
Computing (STOC80), Los Angeles, CA, USA, pp. 302309.
Kautz, H. A., & Selman, B. (1992). Planning satisfiability. Proceedings 10th
European Conference Artificial Intelligence (ECAI92), Vienna, Austria, pp. 359
363.
Knoblock, C. A. (1993). Generating Abstraction Hierarchies: Automated Approach
Reducing Search Planning. Kluwer Academic Publishers. Norwell, MA.
Knoblock, C. A. (1994). Automatically generating abstractions planning. Artificial
Intelligence, 68 (2), 243302.
Korf, R. E. (1985). Macro-operators: weak method learning. Artificial Intelligence,
26 (1), 3577.
Korf, R. E. (1987). Planning search: quantitative approach. Artificial Intelligence,
33 (1), 6588.
Liberatore, P., & Schaerf, M. (2010). size data structures used symbolic model
checking. ArXiv, abs/1012.3018.
Liberatore, P. (2005a). Complexity issues finding succinct solutions PSPACE-complete
problems. ArXiv, abs/cs/0503043.
Liberatore, P. (2005b). complexity case-based planning. Journal Experimental
Theoretical Artificial Intelligence, 17 (3), 283295.
Long, D., Fox, M., & Hamdi, M. (2002). Reformulation planning. Proceedings
5th International Symposium Abstraction, Reformulation Approximation
(SARA02), Kananaskis, AB, Canada, Vol. 2371 Lecture Notes Computer Science, pp. 1832. Springer.
Muscettola, N., Pandurang Nayak, P., Pell, B., & Williams, B. C. (1998). Remote agent:
boldly go AI system gone before. Artificial Intelligence, 103 (1-2),
547.
176

fiAlgorithms Limits Compact Plan Representations

Nebel, B. (2000). compilability expressive power propositional planning
formalisms. Journal Artificial Intelligence Research, 12, 271315.
Nebel, B., & Koehler, J. (1995). Plan reuse versus plan generation: theoretical
empirical analysis. Artificial Intelligence, 76 (1-2), 427454.
Rytter, W. (2003). Application Lempel-Ziv factorization approximation
grammar-based compression. Theoretical Computer Science, 302 (1-3), 211222.
Sacerdoti, E. D. (1974). Planning hierarchy abstraction spaces. Artificial Intelligence,
5 (2), 115135.
Southwick, R. W. (1991). Explaining reasoning: overview explanation knowledgebased systems. Knowledge Engineering Review, 6, 119.
Spalazzi, L. (2001). survey case-based planning. Artificial Intelligence Review, 16,
336.
Veloso, M. M., Carbonell, J. G., Perez, A., Borrajo, D., Fink, E., & Blythe, J. (1995). Integrating planning learning: PRODIGY architecture. Journal Experimental
Theoretical Artificial Intelligence Research, 7 (1), 81120.
Wagner, K. (1986). complexity combinatorial problems succinct input representation. Acta Informatica, 23 (3), 325356.
Wehrle, M., & Helmert, M. (2009). causal graph revisited directed model checking.
Proceedings 16th International Symposium Static Analysis (SAS09), Los
Angeles, CA, USA, Vol. 5673 Lecture Notes Computer Science, pp. 86101.
Springer.
Williams, B., & Pandurang Nayak, P. (1997). reactive planner model-based executive. Proceedings 15th International Joint Conference Artificial Intelligence (IJCAI97), Nagoya, Japan, pp. 11781185.
Yap, C.-K. (1983). consequences non-uniform conditions uniform classes. Theoretical Computer Science, 26, 287300.

177


