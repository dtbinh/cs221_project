Journal Artificial Intelligence Research 51 (2014) 555-577

Submitted 05/14; published 11/14

Iterative Plan Construction Workflow Satisfiability Problem
David Cohen
Jason Crampton
Andrei Gagarin
Gregory Gutin
Mark Jones

D.C OHEN @ RHUL . AC . UK
JASON .C RAMPTON @ RHUL . AC . UK
NDREI .G AGARIN @ RHUL . AC . UK
G.G UTIN @ RHUL . AC . UK
ARK .J ONES @ RHUL . AC . UK

Royal Holloway, University London, UK

Abstract
Workflow Satisfiability Problem (WSP) problem practical interest arises whenever tasks need performed authorized users, subject constraints defined business
rules. required decide whether exists plan assignment tasks authorized
users constraints satisfied. natural see WSP subclass
Constraint Satisfaction Problem (CSP) variables tasks domain set
users. makes WSP distinctive number tasks usually small compared number users, appropriate ask constraint languages WSP
fixed-parameter tractable (FPT), parameterized number tasks.
novel approach WSP, using techniques CSP, enabled us design generic
algorithm FPT several families workflow constraints considered literature.
Furthermore, prove union FPT languages remains FPT satisfy simple compatibility condition. Lastly, identify new FPT constraint language, user-independent constraints, includes many constraints interest business processing systems.
demonstrate generic algorithm provably optimal running time (2k log k ),
language, k number tasks.

1. Introduction
workflow formalises business process. collection interrelated tasks performed
users order achieve objective. many situations, wish restrict users
perform certain tasks. particular, may wish specify lists users authorized
perform workflow tasks. Additionally, may wish either particular
requirements business logic security requirements prevent certain combinations
users performing particular combinations tasks (Crampton, 2005). constraints include
separation-of-duty (also known two-man rule), may used prevent sensitive
combinations tasks performed single user, binding-of-duty, requires
particular combination tasks executed user. use constraints workflow
management systems enforce security policies studied extensively last fifteen
years; example see work Bertino, Ferrari, Atluri (1999), Crampton (2005) Wang
Li (2010).
1.1 Workflow Satisfiability Problem
possible combination constraints authorization lists unsatisfiable,
sense exist assignment users tasks contraints satisfied
c
2014
AI Access Foundation. rights reserved.

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

every task performed authorized user; perhaps minimal example requirement
two tasks performed user intersection authorization lists
tasks empty. plan satisfies constraints allocates authorized user task said
valid. Workflow Satisfiability Problem (WSP) takes workflow specification input
returns valid plan one exists null value otherwise. important determine whether
business process satisfiable not, since unsatisfiable one never completed without
violating security policy encoded constraints authorization lists. Wang Li (2010)
shown, reduction G RAPH C OLORING, WSP NP-hard subclass
CSP, even consider binary separation-of-duty constraints. Nevertheless, practical
applications WSP, require solving algorithm efficient possible (Crampton &
Gutin, 2013, 2.2).
Many hard problems become less complex natural parameter instance bounded.
Hence, say problem input size n parameter k fixed-parameter tractable (FPT)
admits algorithm running time O(f (k)nd ), constant independent n k,
f computable function depending k.1
Wang Li (2010) first observe fixed-parameter algorithmics appropriate
way study WSP, number tasks usually small often much smaller
number users. (The literature directly support assumption, although widely-cited
study, Schaad, Moffett, & Jacob, 2001, found number users exceeds job functions,
roles, multiplicative factor around 25; finding confirmed recent followup study, Jayaraman, Ganesh, Tripunitara, Rinard, & Chapin, 2011. workflow specification
usually concerned particular business objective involve small number roles.
Taking roles proxy tasks, seems reasonable assume number users
order magnitude greater number tasks.) believe, therefore, appropriate
extend work initiated Wang Li use fixed parameter algorithms solving
WSP parameterized number tasks, and, particular, ask constraint languages
fixed parameter tractable.
Wang Li (2010) proved that, general, WSP W[1]-hard thus highly unlikely
admit fixed-parameter algorithm. showed WSP FPT consider
separation-of-duty binding-of-duty constraints. Crampton, Gutin, Yeo (2013) obtained significantly faster fixed-parameter algorithms applicable regular constraints, thereby
including cases shown FPT Wang Li. work, recent research,
demonstrated existence fixed-parameter algorithms WSP presence constraint types (Crampton, Crowston, Gutin, Jones, & Ramanujan, 2013; Crampton & Gutin, 2013).
define WSP formally introduce number different constraint types, including regular
constraints, Section 2.
use notation, suppresses polynomial factors.
is,
g(n, k, m) = (h(n, k, m)) exists polynomial q(n, k, m) g(n, k, m) =
O(q(n, k, m)h(n, k, m)). particular, FPT algorithm one runs time (f (k))
computable function f depending k.

1. introduction fixed-parameter algorithms complexity found in, example, books Downey
Fellows (2013), Niedermeier (Niedermeier, 2006).

556

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

1.2 Relation WSP CSP
Constraint Satisfaction Problem (CSP) general paradigm expressing, declarative
format, problems variables assigned values domain. assignments
constrained restricting allowed simultaneous assignments sets variables.
model useful many application areas including planning, scheduling, frequency assignment
circuit verification (Rossi, van Beek, & Walsh, 2006). CSP community well-established
research community dedicated finding effective solution techniques CSP (Dechter, 2003).
CSP NP-hard, even binary not-equals constraints allowed domain
three elements, reduce G RAPH 3-C OLORING CSP. 2 Hence, considerable
effort made understand effect restricting type allowed constraints. Recently significant progress towards completion research program
strong evidence support algebraic dichotomy conjecture Bulatov, Jeavons
Krokhin (2005), characterising precisely kinds constraint language lead polynomial
solvability.
worth noting WSP subclass CSP variable (called task
WSP terminology) arbitrary unary constraint (called authorization) assigns
possible values (called users) s; called conservative CSP. Note, however,
usually CSP number variables much larger number values, WSP
number tasks usually much smaller number users. important remember
WSP use term constraint authorizations define special
types constraints, extend types authorizations, remain arbitrary.
1.3 Outline Paper
novel approach WSP using techniques CSP, characterising types constraints
constraint languages particular characteristics, enables us generalise unify existing
algorithms. So, paper, first time, rather considering algorithms specific
constraints, design generic algorithm fixed-parameter algorithm several families
workflow constraints considered literature. particular introduce notions userindependent constraints, subsume number well-studied constraint types WSP
literature, including regular constraints studied Crampton et al. (2013).
generic algorithm builds plans incrementally, discarding partial plans never satisfy
constraints. based naive algorithm, presented Section 2.2. naive algorithm
stores far information required solve WSP, running time better
exhaustively searching valid plan.
generic algorithm uses general classic paradigm: retain little information possible every step algorithm. paradigm used classical polynomial-time algorithms Gaussian elimination solving systems linear equations constraint propagation
algorithms (used, example, solve 2SAT polynomial time). generic algorithm uses
paradigm problem-specific way, based concepts extension-equivalence, planindistinguishability patterns, enabling us retain single pattern equivalence class
indistinguishable plans. Extension-equivalence plan encodings described Section 3.
way solution constructed algorithm quite unusual accumulation
2. Wang Lis NP-hardness result WSP thus restatement well-known result CSP.

557

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

(representatives of) set solutions goes along users (i.e., values CSP), along tasks
(i.e., variables CSP).
analyze running time algorithm introduce notion diversity (see Definition 6). notion reminiscent pathwidth (measures taken prefixes largest
outcome diversity) difference diversity based number equivalence classes, hiding actual structure behind scenes. approach might useful
structural analysis hypergraphs.
Section 4, describe pattern-based algorithm demonstrate fixedparameter algorithm WSP user-independent constraints. show running time
algorithm (2k log k ) WSP user-independent constraints
algorithm running time (2o(k log k) ) WSP user-independent constraints unless
Exponential Time Hypothesis3 (ETH) fails. Thus, unlike WSP regular constraints
(and problems studied Bodlaender, Cygan, Kratsch, & Nederlof, 2013; Fomin, Lokshtanov, &
Saurabh, 2014), WSP user-independent constraints highly unlikely admit algorithm
running time (2O(k) ). show generic algorithm interest constraints
user-independent, prove generic algorithm single-exponential algorithm
constraint language obtained equivalence relation set users.
Section 5 show generic algorithm deal unions constraint languages.
leads generalisation result user-independent constraints. Section 6 discuss
results computational experiments using implementation algorithm (discussed
full detail work Cohen, Crampton, Gagarin, Gutin, & Jones, 2014). brief conclusion
given Section 7.

2. Background
define workflow schema tuple (S, U, A, C), set tasks workflow,
U set users, = {A(s) : S}, A(s) U authorization list task s,
C set workflow constraints. workflow constraint pair c = (L, ), L
set functions L U : L scope constraint; specifies assignments
elements U elements L satisfy constraint c.
Given X U , plan function : X. Given workflow constraint (L, ),
X U , plan : X satisfies (L, ) either L \ 6= |L =
. plan : X eligible satisfies every constraint C. plan : X
authorized (s) A(s) . plan valid authorized eligible. plan
: U called complete plan. algorithm solve WSP takes workflow schema
(S, U, A, C) input outputs valid, complete plan, one exists (and null, otherwise).
running example, consider following instance WSP.
Instance 1. task set = {s1 , . . . , s4 } user set U = {u1 , . . . , u6 }. authorization
lists follows (where tick indicates given user authorized given task):
3. Exponential Time Hypothesis claims algorithm running time (2o(n) ) 3SAT n variables (Impagliazzo, Paturi, & Zane, 2001).

558

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

s1
s2
s3
s4

u1
4

u2
4
4
4
4

u3

u4

u5

u6

4
4

4
4

4
4

4

constraints follows: s1 s2 must assigned user; s2 s3 must
assigned different users; s3 s4 must assigned different users; s1 s4 must
assigned different users.
Example 1 illustrates meanings eligible, complete authorised plans context
Instance 1.
Example 1. following table gives assignments four plans, 1 , 2 , 3 , 4 :

1
2
3
4

s1
u1
u1
u1
u2

s2
u2
u1
u2

s3
u4
u4
u4
u4

s4
u5
u5
u5
u5

Authorized
4
4
4

Eligible
4
4
4

Complete
4
4
4

1 complete plan authorized eligible, s1 s2 assigned
different users.
2 complete plan eligible authorized, u1 authorized s2 .
3 plan authorized eligible, therefore valid. However, 3
complete plan assignment s2 .
4 complete plan eligible authorized. Thus 4 valid complete plan,
therefore solution.
algorithm runs instance (S, U, A, C) WSP, measure running
time terms n = |U |, k = |S|, = |C|. (The set authorization lists consists k
lists size n, need consider size separately measuring
running time.) say algorithm runs polynomial time running time
p(n, k, m), p(n, k, m) polynomial n, k m.
2.1 WSP Constraints
paper interested complexity WSP workflow constraint language
(the set permissible workflow constraints) restricted. section introduce constraint
types interest. practical applications real world workflows.
assume constraints authorizations checked polynomial time.
means takes polynomial time check whether plan authorized, eligible valid.
correctness algorithm unaffected assumption, choosing constraints
checkable polynomial time would naturally affect running time.
559

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

2.1.1 C ONSTRAINTS EFINED B INARY R ELATION
Constraints two tasks, s0 , represented form (s, s0 , ), binary
relation U (Crampton, 2005). plan satisfies constraint (s) (s0 ). Writing
= denote relation {(u, u) : u U } 6= denote relation {(u, v) : u, v U, u 6= v},
separation-of-duty binding-of-duty constraints may represented form (s, s0 , 6=)
(s, s0 , =), respectively. Crampton et al. (2013) considered constraints ,
equivalence relation defined U . practical example workflow constraints
equivalence relation partitions users different departments: constraints could
enforce two tasks performed members department. Constraints
restricted singleton tasks considered (Crampton et al., 2013; Wang & Li, 2010):
plan satisfies constraint form (S 0 , 00 , ) tasks s0 0 s00 00
(s0 ) (s00 ).
2.1.2 C ARDINALITY C ONSTRAINTS
tasks-per-user counting constraint form (t` , tr , ), 1 6 t` 6 tr 6 k S.
plan satisfies (t` , tr , ) user performs either tasks t` tr tasks. Tasksper-user counting constraints generalize cardinality constraints widely adopted
WSP community (American National Standards Institute, 2004; Bertino, Bonatti, & Ferrari,
2001; Joshi, Bertino, Latif, & Ghafoor, 2005; Sandhu, Coyne, Feinstein, & Youman, 1996).
2.1.3 R EGULAR C ONSTRAINTS
say C regular satisfies following condition: partition S1 , . . . , Sp
1
every
Sp [p] exists eligible complete plan user u (u) = Si ,
plan i=1 (Si ui ), ui distinct, eligible. Regular constraints extend set
constraints considered Wang Li (2010). Crampton et al. (2013) show following
constraints regular: (S 0 , 00 , 6=); (S 0 , 00 , =), least one sets 0 , 00 singleton;
tasks-per-user counting constraints form (t` , tr , ), t` = 1.
2.1.4 U SER -I NDEPENDENT C ONSTRAINTS
Many business rules concerned identities users complete set tasks;
concerned relationships users. Accordingly, say constraint (L, ) user-independent whenever : U U permutation,
. obvious example user-independent constraint requirement two
tasks performed different users (separation-of-duty). complex example suppose
most/at least/exactly p users required complete sensitive set tasks (cardinality
constraints), p usually small, i.e., 1, 2, 3 so. substantial literature constraints method specifying enforcing business rules (for example, Gligor, Gavrila, &
Ferraiolo, 1998; Simon & Zurko, 1997), including work researchers SAP IBM (for example, Basin, Burri, & Karjoth, 2014; Wolter & Schaad, 2007). widely studied constraints
cardinality constraints separation-of-duty, form part ANSI standard rolebased access control (American National Standards Institute, 2004), developed US National
Institute Standards Technology (NIST). short, literature relevant standards suggest user-independent constraints interest business processes workflow
560

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

management systems. definition user-independent includes constraints defined
ANSI RBAC standard many more.
Every regular constraint user-independent, many user-independent constraints
regular. Indeed, constraints type (S 0 , 00 , =) user-independent, necessarily
regular (Crampton et al., 2013). Many counting constraints Global Constraint Catalogue (Beldiceanu, Carlsson, & Rampon, 2012) user-independent, regular. particular, constraint NVALUE, bounds number users performing set
tasks, user-independent regular. Note, however, constraints form (s0 , s00 , )
(s0 , s00 , 6) user-independent general.
important note authorization lists, fundamental access control
system, viewed unary constraints, certainly user-independent. presence
user-independent constraints authorization lists workflow specification makes
WSP challenging.
2.2 Naive Algorithm
main aim section present simple algorithm (Algorithm 1) solve
instance WSP. running time algorithm slightly worse brute-force algorithm, algorithms basic structure provides starting point develop
efficient algorithm.
need introduce additional notation terminology.
Let : X plan S, X U . let TASK() = U SER() = X.
important generic algorithm TASK() U SER() given explicit parts .
particular, set U SER() may different set users assigned task . is,
user u U SER() without task (s) = u. worth observing
TASK() may empty (because may allocate tasks users X).
u U , (T u) denotes plan : {u} (s) = u .
Two functions f1 : D1 E1 f2 : D2 E2 disjoint D1 D2 = E1 E2 = .
union two disjoint functions f1 : D1 E1 , f2 : D2 E2 function f = f1 f2
f : D1 D2 E1 E2 f (d) = (d) Di , {1, 2}. Let g : E
h : E F functions. h g denotes composite function F
h g(d) = h(g(d)) D. integer p > 0, set [p] = {1, 2, . . . , p}.
Proposition 1. Let (S, U, A, C) instance WSP, n = |U |, k = |S| = |C|.
(S, U, A, C) solved time ((n + 1)k ) Algorithm 1.
Proof. Let u1 , . . . , un ordering U , let Ui = {u1 , . . . , ui } [n].
[n] turn, construct set plans U SER() = Ui valid.
set n contains plan TASK() = S, (S, U, A, C) solution; otherwise,
plan solution (S, U, A, C).
Algorithm 1 shows construct sets . hard verify contains exactly
every valid plan U SER() = Ui , i. implies correctness algorithm.
remains analyse running time.
[n] S, i|T | valid plans U SER() =
Ui , TASK() = . construct 1 , need consider plans U SER() = U1 ,
exactly 2k plans. plan decide polynomial time whether add 1 .
561

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Algorithm 1: Naive solution procedure WSP
input : instance (S, U, A, C) WSP
1 Construct ordering u1 , . . . , un U ;
2 Set 1 = ;
3 foreach
4
Set = (T u1 );
5
eligible u1 A(s)
6
Set 1 = 1 {};
7
end
8 end
9 Set = 1;
10 < n
11
Set i+1 = ;
12
foreach 0
13
foreach \ TASK( 0 )
14
ui+1 A(s)
15
Set = 0 (T ui+1 );
16
eligible
17
Set i+1 = i+1 {};
18
end
19
end
20
end
21
end
22
Set = + 1;
23 end
24 foreach n
25
TASK() =
26
return ;
27
end
28 end
29 return NULL ;

construct i+1 [n 1], need consider every pair ( 0 , ) 0
\ TASK( 0 ). Consider pair ( 0 , ), 0 (S 0 , Ui )-plan 0 S,
0
0
\ 0 . Thus i|S | possibilities
0 ,
2|S||S | choices . Thus,
P
P
0
0
k
k
total number pairs given 0 i|S | 2|S||S | = j=0 j ij 2kj = (i + 2)k .
pair ( 0 , ) decide whether
add 0 (T ui+1 ) i+1 polynomial time. Thus,
P
k

k

k
construct takes time ( n1
i=0 (i + 2) ) = (n(n + 1) ) = ((n + 1) ).

Algorithm 1 inefficient even small k, due fact contains valid plans
U SER( 0 ) = {u1 , . . . , ui }. show next section necessary store
much information solve WSP.

0

562

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

3. Plan-Indistinguishability Relations
first introduce notion extension-equivalence, defined equivalence relation set
plans. Informally, relation enables us keep single member equivalence class
building plans incrementally.
Definition 1. Given instance (S, U, A, C) WSP, two eligible plans 1 2 , define
1 2 following conditions hold:
1. U SER(1 ) = U SER(2 ) TASK(1 ) = TASK(2 );
2. 1 0 eligible 2 0 eligible, plan 0 disjoint 1 2 .
equivalence relation set eligible plans, say 1 2 extensionequivalent 1 2 .
Example 2. Consider Instance 1.
Let 1 : {s3 , s4 } {u2 , u4 } function 1 (s3 ) = u2 1 (s4 ) = u4 . Let
2 : {s3 , s4 } {u2 , u4 } function 2 (s3 ) = u4 2 (s4 ) = u2 .
plans 1 2 eligible, U SER(1 ) = U SER(2 ) TASK(1 ) =
TASK(2 ). plan 0 disjoint 1 2 , plan 1 0 satisfy constraints
(s2 , s3 , 6=), (s1 , s4 , 6=). Thus 1 0 eligible 0 eligible. Similarly, 2 0
eligible 0 eligible. Thus 1 0 eligible 2 0 eligible,
1 2 extension-equivalent.
Suppose polynomial time algorithm check whether two eligible plans
extension-equivalent. Algorithm 1, could keep track one plan equivalence class: constructing , add 2 1 extension-equivalent
2 already ; construct i+1 , may use 1 proxy 2 . number
extension-equivalent classes small compared number plans, worst-case running
time algorithm may substantially lower Algorithm 1.
Unfortunately, necessarily easy decide two eligible plans extension-equivalent,
approach practical. However, always refine4 extension-equivalence equivalence relation equivalence easy determine. example, identity equivalence
relation plan equivalent refinement.
refined equivalence relation may equivalence classes extensionequivalence, substantially fewer identity relation, may obtain better running
time naive algorithm.
Definition 2. Given instance (S, U, A, C) WSP, let set eligible plans
let equivalence relation refining extension-equivalence . say planindistinguishability relation (with respect C) if, eligible 1 , 2 1 2 ,
plan 0 disjoint 1 2 1 0 eligible, 1 0 2 0 .
Example 3. Let identity relation plans. is, 1 2 U SER(1 ) =
U SER(2 ), TASK(1 ) = TASK(2 ), 1 (s) = 2 (s) U SER(1 ).
4. equivalence relation 2 refinement equivalence relation 1 every equivalence class 2 subset
equivalence class 1 .

563

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

plan-indistinguishability relation. shows every plan-indistinguishability relation
extension-equivalence relation. Indeed, plans given Example 2 extension-equivalent
identical.
Recall refined extension-equivalence since may hard determine whether two
eligible plans extension-equivalent. therefore natural assume following:
Assumption 1. Given plan-indistinguishability relation , takes polynomial time check
whether two eligible plans equivalent .
correctness algorithms depend assumption. However, poor choice
plan-indistinguishability relation could affect running times.
describe appropriate plan-indistinguishability relations constraints
using. case determining two eligible plans equivalent take polynomial
time.
3.1 Plan-Indistinguishability Relation User-Independent Constraints
Lemma 1. Suppose constraints user-independent, let ui relation 1 ui
2
1. U SER(1 ) = U SER(2 ) TASK(1 ) = TASK(2 );
2. s, TASK(1 ), 1 (s) = 1 (t) 2 (s) = 2 (t).
ui plan-indistinguishability relation set eligible plans.
Proof. definition user-independent constraints, eligible plan : U U
permutation, eligible. Suppose 1 ui 2 , let = TASK(1 )
X = U SER(1 ). Let 0 : 1 (T ) 2 (T ) function 0 (1 (t)) = 2 (t)
task t. Let 00 : X \ 1 (T ) X \ 2 (T ) arbitrary bijection (note |1 (T )| = |2 (T )|
Condition 2 ui ). Let = 0 00 . permutation 2 = 1 . Thus 1
eligible 2 eligible.
consider two eligible plans 1 , 2 1 ui 2 , plan 0 disjoint 1
2 . First show 1 0 ui 2 0 . clear U SER(1 0 ) = U SER(2 0 )
TASK(1 0 ) = TASK(2 0 ). s, U SER(1 0 ), (1 0 )(s) = (1 0 )(t),
either s, TASK( 0 ), case (2 0 )(s) = (2 0 )(t) trivially, s,
TASK(1 ), case 2 (s) = 2 (t) since 1 ui 2 , hence (2 0 )(s) =
(2 0 )(t). Thus (1 0 )(s) = (1 0 )(t) (2 0 )(s) = (2 0 )(t) and, similar
argument, converse holds. Thus 1 0 ui 2 0 . Furthermore, follows argument
first paragraph 1 0 eligible 2 0 eligible. Thus, condition
Definition 2 second condition Definition 1 hold.
first condition ui trivially satisfies first condition Definition 1. Thus, ui satisfies
conditions plan-indistinguishability relation.
Example 4. Consider instance WSP users u1 , . . . u6 tasks s1 , . . . , s6
constraints user-independent. Let ui plan-indistinguishability relation given
Lemma 1. Let c1 constraint scope {s2 , s3 , s4 , s5 } c1 satisfied
even number users assigned tasks {s2 , s3 , s4 , s5 }. Let c2 constraint scope
564

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

{s1 , s3 , s4 , s6 } c2 satisfied either s1 s3 assigned different users,
s4 s6 assigned different users. Suppose c1 c2 constraints whose
scope contains tasks {s1 , s2 , s3 } {s4 , s5 , s6 }.
consider plans 1 , 2 : {s1 , s2 , s3 } {u1 , u2 , u3 , u4 } 1 (s1 ) =
u1 , 1 (s2 ) = u2 , 1 (s3 ) = u1 , 2 (s1 ) = u3 , 2 (s2 ) = u4 , 2 (s3 ) = u3 , suppose
1 , 2 eligible. 1 2 equivalent ui .
Observe plan 0 disjoint 1 2 , 1 0 eligible 2 0
eligible. 1 2 assign two users {s2 , s3 }, 0 must assign two users {s4 , s5 }
order satisfy c1 . 1 2 assign s1 s3 user, 0 must assign s4 s5
different users order satisfy c2 . long conditions satisfied, 0 satisfies
constraints scope {s4 , s5 , s6 }, 1 0 2 0 eligible.
3.2 Plan-Indistinguishability Relation Equivalence Relation Constraints
Recall given binary relation U , constraint form (si , sj , ) satisfied plan
(si ) (sj ). Recall constraints user-independent general.
Lemma 2. Suppose equivalence relation U . Let V1 , . . . , Vl equivalence classes
U . Suppose constraints form (si , sj , ) (si , sj , 6). Let e relation
1 e 2
1. U SER(1 ) = U SER(2 ) TASK(1 ) = TASK(2 );
2. equivalence classes Vj Vj U SER(1 ) 6= Vj \ U SER(1 ) 6= ,
TASK(1 ), 1 (s) Vj 2 (s) Vj .
e plan-indistinguishability relation.
Proof. clear e satisfies first condition Definition 1. suppose 1 , 2 eligible
plans 1 e 2 , let 0 plan disjoint 1 2 . first show 1 0
eligible 2 0 eligible.
Suppose 1 0 eligible. Consider two tasks t, t0 TASK(2 0 ). {t, t0 } TASK( 0 ),
2 0 falsify constraint t0 since equal 1 0 restricted
{t, t0 } 1 0 eligible. {t, t0 } TASK(2 ), 2 0 break constraints
since 2 eligible.
may assume TASK(2 ), t0 TASK( 0 ). definition, (2 0 )(t) (2 0 )(t0 )
exists j [l] 2 (t), 0 (t0 ) Vj . Vj U SER(2 ) 6=
Vj \ U SER(2 ) 6= . Therefore, definition e , 1 (s) Vj 2 (s) Vj ,
TASK(1 ). particular, 1 (t) Vj , (1 0 )(t) (1 0 )(t0 ). similar argument,
(1 0 )(t) (1 0 )(t0 ) (2 0 )(t) (2 0 )(t0 ). Therefore, every constraint
satisfied (1 0 ) satisfied (2 0 ). Therefore 1 0 eligible
2 0 , similar argument converse holds.
remains show 1 0 e 2 0 . clear user task sets same.
user set, sets {Vj : Vj U SER(1 0 ) 6= , Vj \ U SER(1 0 ) 6= }
{Vj : Vj U SER(2 0 ) 6= , Vj \ U SER(2 0 ) 6= } same. Furthermore,
Vj set TASK(1 0 ), (1 0 )(s) Vj (2 0 )(s) Vj , either
TASK(1 ), case Vj U SER(1 ) 6= , Vj \ U SER(1 ) 6= 2 (s) Vj ,
565

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

TASK( 0 ), case (2 0 )(s) = 0 (s) = (1 0 )(s). similar argument,
(2 0 )(s) Vj , (1 0 )(s) Vj . Thus 1 0 e 2 0 .
Example 5. Let equivalence relation users equivalence classes
{u1 }, {u2 }, {u3 , u4 , u5 }, {u6 , u7 , u8 }. Consider instance WSP users u1 , . . . , u8
tasks s1 , . . . , s6 constraints form (si , sj , ) (si , sj , 6). Let e
plan-indistinguishability relation given Lemma 2. Suppose constraints whose scope
contains tasks {s1 , s2 , s3 } {s4 , s5 , s6 } constraints (s1 , s5 , 6), (s2 , s5 , )
(s2 , s6 , 6).
consider plans 1 , 2 : {s1 , s2 , s3 } {u1 , u2 , u3 , u4 } 1 (s1 ) =
u1 , 1 (s2 ) = u3 , 1 (s3 ) = u3 , 2 (s1 ) = u2 , 2 (s2 ) = u3 , 2 (s3 ) = u4 , suppose
1 , 2 eligible. 1 2 equivalent e .
Observe plan 0 disjoint 1 2 , 1 0 eligible 2 0
eligible. -equivalence class members {u1 , u2 , u3 , u4 } members
{u1 , u2 , u3 , u4 } class {u3 , u4 , u5 }. 1 2 assign members {u3 , u4 } exactly
set {s2 , s3 }. Thus plan 0 disjoint 1 2 , 1 0 2 0 satisfy
constraint (s1 , s5 , 6) whatever 0 assigns s5 . satisfy (s2 , s5 , ) 0 assigns
s5 u5 , satisfy (s2 , s6 , 6) 0 assign s6 u5 . long
conditions satisfied, 0 satisfies constraints scope {s4 , s5 , s6 }, 1 0
2 0 eligible.

4. Generic Algorithm WSP
follows, X U, S, let [X, ] denote set eligible plans
U SER() = X TASK() = . section introduce algorithm works
similar way Algorithm 1, except instead storing valid plans particular set users
tasks, construct [X, ]-representative sets task set certain user sets X.
definition, equivalence classes plan-indistinguishability relation necessarily partition
[X, ]. Hence equivalence class representation form (X, T, ),
dependent constraint language. remainder section describe algorithm
give examples representations.
4.1 Encodings Patterns
generic algorithm, construct plans iteratively, using one plan
equivalence class plan-indistinguishability relation. running time algorithm
depend number equivalence classes relation, certain sets plans.
ensure sets equivalence classes ordered therefore searched sorted efficiently,
introduce notion encodings patterns. Loosely speaking, encoding function
maps plans -equivalence class element (the pattern plans).
encodings ensure logarithmic-time access insertion operations representative set plans,
rather linear time naive method would allow.
Note use encodings patterns necessary fixed-parameter
tractability results; problems could solved without use patterns encodings
fixed-parameter time, function k would grow quickly.

566

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

Definition 3. Given instance (S, U, A, C) WSP plan-indistinguishability relation
, let set plans. Let PAT set consider function ENC : PAT.
X U, S, let PAT[X, ] = ENC([X, ]). say ENC -encoding (or
encoding ) if, X U, 1 , 2 [X, ],
1. ENC(1 ) = ENC(2 ) 1 2 ;
2. ENC(1 ) calculated time polynomial n, k, m;
3. exists linear ordering PAT[X, ] that, p, p0 PAT[X, ], decide
whether p p0 time polynomial n, k, m.
elements PAT called -patterns. ENC() = p say p -pattern .
second third conditions Definition 3 ensure may use encodings organise
plans reasonable time. clear context, refer -encoding
encoding -patterns patterns.
note complexity consequences Definition 3 following:
Proposition 2. encoding plan-indistinguishability relation set patterns PAT ,
assigning patterns PAT nodes balanced binary tree, perform following
two operations time (log(|PAT |)): (i) check whether p PAT , (ii) insert pattern
p
/ PAT PAT .
Proof. Recall comparisons polynomial n, k, m. result follows wellknown properties balanced binary trees (e.g., see (Cormen, Stein, Rivest, & Leiserson, 2001)).
show plan-indistinguishability relations given previous section
encodings. first need define lexicographic order.
Definition 4. Given totally ordered set (A, ), (total) lexicographic order d-tuples
Ad defined follows. say (x1 , . . . , xd ) (y1 , . . . , yd ) either xj = yj j [d]
xi < yi xj = yj j < i.
Taking = N = k obtain natural lexicographic order Nk0 .
lexicographically order sets disjoint subsets ordered set =
{t1 , . . . , tk }, t1 < < tk .
Definition 5. associate k-tuple (x1 , . . . , xk ) Nk0 set disjoint subsets
{S1 , . . . , Sr } {t1 , . . . , tk } follows. xi = 0 ti
/ rm=1 Sm . ti rm=1 Sm ,
j < {ti , tj } Sm xi = xj ,
otherwise xi = max{x1 , . . . , xi1 } + 1, max = 0.
write VEC(S) = (x1 , . . . , xk ). Note VEC(S) computed time O(k 2 ).
Thus, tasks subset assigned value; assignment integers
tasks performed iteratively. example, = {1, . . . , 8} sets =
{{2, 4}, {3}, {5, 7}} B = {{2, 3, 4}, {5, 7}}, VEC(A) = (0, 1, 2, 1, 3, 0, 3, 0)
VEC (B) = (0, 1, 1, 1, 2, 0, 2, 0). lexicographically bigger B.
567

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Corollary 1. Let ui plan-indistinguishability relation given set user-independent
constraints Lemma 1. exists encoding ui .
Proof. Let s1 , . . . , sk ordering plan. Let = { 1 (u) : u U SER()}
let VEC() = VEC(S ). plan , let ENC() tuple (U SER(), TASK(), VEC()).
clear ENC(1 ) = ENC(2 ) 1 ui 2 , r (si ) = r (sj )
yi = yj VEC(r ) = (y1 , . . . , yk ), r {1, 2}. Furthermore clear ENC()
determined polynomial time .
remains define linear ordering PAT[X, ] given X U, S. two
patterns p = (X, T, (x1 , . . . , xk )), p0 = (X, T, (y1 , . . . , yk )) PAT[X, ], define p p0
(x1 , . . . , xk ) (y1 , . . . , yk ).
Example 6. Let ENC encoding given proof Corollary 1. Let 1 , 2 plans
given Example 4. ENC(1 ) = ENC(2 ) = {{u1 , u2 , u3 , u4 }, {s1 , s2 , s3 }, (1, 2, 1, 0, 0, 0)}.
Corollary 2. Let e plan-indistinguishability relation given set constraints equivalence relations Lemma 2. exists encoding e .
Proof. Suppose equivalence relation users, let V1 , . . . , Vp equivalence classes
U . Suppose constraints form (si , sj , ) (si , sj , 6).
plan , define ENC() (U SER(), TASK(), ),


= 1 (Vj U SER()) : Vj U SER() 6= , Vj \ U SER() 6= , 1 j p .
clear ENC(1 ) = ENC(2 ) 1 e 2 , (s) Vj
i1 (Vj ), {1, 2}. Furthermore clear ENC() determined polynomial
time .
remains define linear ordering PAT[X, ] given X U, S. Let : X
plan. set disjoint subsets TASK(), natural order, order
patterns PAT[X, ] according lexicographic order .

Example 7. Let ENC encoding given proof Corollary 2. Let 1 , 2 plans
given Example 5. ENC(1 ) = ENC(2 ) = {{u1 , u2 , u3 , u4 }, {s1 , s2 , s3 }, {{s2 , s3 }}}.
4.2 Generic Algorithm
use notion diversity introduced next definition analyse running time
generic algorithm.
Definition 6. Let (S, U, A, C) instance WSP, n = |U |, k = |S| = |C|,
suppose plan-indistinguishability relation respect C. Given ordering u1 , . . . , un
U , let Ui = {u1 , . . . , ui } [n]. Let wi number equivalence classes
set [Ui , ] eligible plans. define diversity respect u1 , . . . , un
w = maxi[n] wi .
Since generic algorithm stores one plan equivalence class , need
notion representative set.
568

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

Definition 7. Given instance (S, U, A, C) WSP, let 0 set eligible plans let
plan-indistinguishability relation. set 00 said 0 -representative set respect
following properties hold:
1. 00 0 ; every plan 00 valid;
2. every valid 0 0 , exists 00 00 0 00 .
clear context, say 00 0 -representative set representative set
0 . generic algorithm based finding plan-indistinguishability relations
exist small representative sets.
Theorem 1. Let (S, U, A, C) instance WSP, n = |U |, k = |S| = |C|. Let
u1 , . . . , un ordering U , let Ui = {u1 , . . . , ui } [n], U0 = . Suppose
diversity w respect u1 , . . . , un . Furthermore suppose exists -encoding
ENC . (S, U, A, C) solved time (3k w log w).
Proof. proof proceeds demonstrating correctness bounding running time
Algorithm 2, solves WSP. begin proof, give overview Algorithm 2.
[n] turn S, construct representative set [Ui , ],
denoted [Ui , ] .
well constructing set [Ui , ] , maintain companion set PAT[Ui , ] =
ENC ([Ui , ] ). provides efficient way representing equivalence classes
[Ui , ] . particular, allows us check whether given valid plan added
[Ui , ] , faster searching [Ui , ] linearly.
[Un , S] constructed, remains check whether [Un , S] non-empty,
exists valid complete plan , exists valid complete plan 0 [Un , S]
0 .
Algorithm 2 gives details construct [Ui , ] .
proof correctness Algorithm 2 proceeds induction. Observe first case
[U0 , ] , 6= possible plan [U0 , ], set [U0 , ] = .
= possible plan empty plan ). plan added [U0 , ] ,
trivially valid. Thus [U0 , ] [U0 , ]-representative set .
assume set [Ui , ] constructed [Ui , ]representative set. consider construction [Ui+1 , ] S. clear
added [Ui+1 , ] , [Ui+1 , ], eligible. Furthermore authorized,
union authorized plans 0 [Ui , 0 ] (T 00 ui+1 ). Thus every plan
[Ui+1 , ] valid plan [Ui+1 , ]. hand, suppose valid plan
[Ui+1 , ]. let 00 = 1 ({ui+1 }) 0 = \ 00 , let 0 = |Ui , =
0 (T 00 ui+1 ). assumption, exists 0 [Ui , ] 0 0 . Consider
plan = 0 (T 00 ui+1 ). clear considered algorithm.
Furthermore, 0 0 = 0 (T 00 ui+1 ), . Therefore
eligible (as eligible) authorized (as union two authorized plans). Therefore
569

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Algorithm 2: Generic algorithm WSP
input : instance (S, U, A, C) WSP, ordering u1 , . . . , un U ,
plan-indistinguishability relation
1 Set [U0 , ] = {( )};
2 foreach =
6
3
Set [U0 , ] = ;
4 end
5 Set = 0;
6 < n
7
foreach
8
Set [Ui+1 , ] = ;
9
Set PAT[Ui+1 , ] = ;
10
foreach 0
11
Set 00 = \ 0 ;
12
ui+1 A(s) 00
13
foreach 0 [Ui , 0 ]
14
Set = 0 (T 00 ui+1 );
15
eligible
16
Set p = ENC();
17
p
/ PAT[Ui+1 , ]
18
Insert p PAT[Ui+1 , ] ;
19
Set [Ui+1 , ] = [Ui+1 , ] {};
20
end
21
end
22
end
23
end
24
end
25
end
26
Set = + 1;
27 end
28 [Un , S] 6=
29
return [Un , S] ;
30 else
31
return NULL;
32 end

valid added [Ui+1 , ] unless [Ui+1 , ] already contains another plan equivalent . Thus, [Ui+1 , ] contains plan -equivalent , follows
[Ui+1 , ] [Ui+1 , ]-representative set, required.
remains analyse running time algorithm. Proposition 2, testing whether
pattern p PAT[Ui , ] inserting p PAT[Ui , ] takes (log(|PAT[Ui , ] |)) time.
Since Assumption 1 assumption time check constraints authorizations
takes polynomial time check eligibility, authorization -equivalence plans, running
570

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

P
P
P
P

time algorithm ( n1
i=0

0
[Ui ,T 0 ] log(|[Ui+1 , ] |)). clear
construction [Ui , 0 ] contains one plan -equivalence class [Ui , 0 ],
soP
definition
|[Ui , 0 ] | w i, 0 . follows running time algorithm
P
n1 P

( i=0 0 w log w) = (3k w log w).
Remark 1. Rather checking whether [Un , S] non-empty end algorithm,
could instead check whether [Ui , S] non-empty construction [Ui , S] i.
is, stop search soon valid plan task set S. likely lead
saving running time implementation algorithm. paper concerned
worst-case running time, would unaffected change, perform check
end algorithm interest clarity.
4.3 Application User-Independent Constraints Optimality
subsection, show WSP user-independent constraints FPT. Let Bk denote
kth Bell number, number partitions set k elements.
Lemma 3. Let u1 , . . . , un ordering U , let ui plan-indistinguishability relation
given Lemma 1. ui diversity Bk respect u1 , . . . , un .
Proof. plan , set { 1 (u) : u U SER()} partition tasks TASK().
Furthermore, two plans generate partition equivalent ui . Therefore
number equivalence classes ui [Ui , ] exactly number possible partitions
, B|T | . Thus, Bk required diversity.
Theorem 2. constraints user-independent, WSP solved time
(2k log k ).
Proof. Let u1 , . . . , un ordering U , let ui plan-indistinguishability relation
given Lemma 1.
Lemma 3, ui diversity Bk respect u1 , . . . , un . Furthermore, Corollary 1,
exists encoding ui . Therefore, may apply Theorem 1 w = Bk , get
algorithm running time (3k Bk log Bk ) = (2k log k ) Bk < (0.792k/ ln(k + 1))k
every k (Berend & Tassa, 2010).
running time (2k log k ) obtained optimal sense algorithm running time
exists, unless ETH fails. proof following theorem, use result
Lokshtanov, Marx, & Saurabh, 2011 (Theorem 2.2).

(2o(k log k) )

Theorem 3. algorithm WSP user-independent constraints running time
(2o(k log k) ), unless ETH fails.
Proof. give reduction problem kk NDEPENDENT ET: Given integer parameter
k graph G vertex set V = {(i, j) : i, j [k]}, decide whether G independent set
|I| = k r [k], exists (r, i) I.
Informally, k k NDEPENDENT ET gives us graph k k grid vertices, asks
whether independent set one vertex row. Lokshtanov et al. (2011) proved
algorithm solve k k NDEPENDENT ET time 2o(k log k) , unless ETH fails.
571

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Consider instance k k NDEPENDENT ET graph G. first produce
equivalent instance WSP constraints user-independent.
refine instance one user-independent constraints.
Let U = {u1 , . . . , uk } set k users = {s1 , . . . , sk } set k tasks. Let
authorization lists A(si ) = U [k]. i, j, h, l [k], let c((i, j), (h, l)) denote
constraint scope {si , sh }, satisfied plan unless (si ) = uj
(sh ) = ul . every pair vertices (i, j), (h, l) adjacent G, add constraint
c((i, j), (h, l)) C.
show (S, U, A, C) ES-instance WSP G independent set one vertex row. Suppose (S, U, A, C) ES-instance WSP
let valid complete plan. [k], let f (i) unique j (si ) = uj .
= {(i, f (i)) : [k]} set one vertex row G; furthermore, satisfies every constraint, edge G contains one element I, independent
set.
Conversely, suppose G ES-instance k k NDEPENDENT
ET. [k], let

f (i) integer (i, f (i)) I. observe ki=1 ({si } uf (i) ) valid complete
plan.
show reduce (S, U, A, C) instance WSP constraints
user-independent. main idea introduce new tasks representing users,
constraints, replace mention particular user mention user performs
particular task.
Create k new tasks t1 , . . . , tk let 0 = {t1 , , . . . , tk }. Let authorization lists
0
(s) = U A0 (ti ) = {ui } [k]. constraint c((i, j), (h, l))
C, let d((i, j), (h, l)) constraint scope {si , sh , tj , tl }, satisfied plan
unless (si ) = (tj ) (sh ) = (tl ). Let initially C 0 = C. replace, C 0 , every constraint
c((i, j), (h, l)) d((i, j, ), (h, l)).
Since defined equalities, users mentioned, constraints C 0 userindependent. show (S 0 , U, A0 , C 0 ) equivalent (S, U, A, C). First, suppose
valid complete plan (S, U, A, C). let 0 : 0 U plan 0 (si ) = (si )
[k], 0 (tj ) = uj j [k]. easy check satisfies every constraint
C 0 satisfies every constraint C 0 . Since 0 authorized eligible plan, 0 valid
complete plan (S 0 , U, A0 , C 0 ).
Conversely, suppose 0 valid complete plan (S 0 , U, A0 , C 0 ). Since A0 (ti ) = {ui }
[k], 0 (ti ) = ui every [k]. [k], let f (i) unique integer
0 (si ) = uf (i) . define : U (si ) = uf (i) , observe constraints C
satisfied . So, valid complete plan (S, U, A, C).
4.4 Application Equivalence Relation Constraints
known restricting WSP equivalence relation constraints enough ensure
problem FPT (Crampton et al., 2013). However, derive result applying
algorithm directly shown appropriate properties language equivalence relation
constraints. serves demonstrate wide applicability approach.

572

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

Lemma 4. Let e plan-indistinguishability relation given set equivalence relation
constraints Lemma 2. exists ordering u1 , . . . , un U e diversity
2k respect U .
Proof. Suppose equivalence relation users, let V1 , . . . , Vp equivalence classes
U . Suppose constraints form (si , sj , ) (si , sj , 6).
Let u1 , . . . , un ordering U elements Vj appear elements
Vj 0 , j < j 0 . Thus, plan U SER() = Ui = {u1 , . . . , ui },
one integer ji Vji U SER() 6= , Vji \ U SER() 6= .
follows two plans 1 , 2 [Ui , ] e -equivalent, [n], S,
provided 1 (t) Vji 2 (t) Vji . Therefore e 2k
equivalence classes [Ui , ], required.
Theorem 4. Suppose equivalence relation U . Suppose constraints form
(si , sj , ) (si , sj , 6). WSP solved time (6k ).
Proof. Let u1 , . . . , un ordering U given Lemma 4, let e planindistinguishability relation given Lemma 2.
Lemma 4, e diversity 2k respect u1 , . . . , un . Furthermore Corollary 2,
exists encoding e . Therefore, may apply Theorem 1 w = 2k , get algorithm
running time (3k 2k log(2k )) = (6k ).

5. Unions Constraint Languages
section show approach allows us easily combine constraint languages shown
FPT WSP. need build bespoke algorithms new constraint language
obtained, show two languages sense compatible.
highlights advantages approach previous methods, required development new algorithms different constraint languages combined instance
WSP (e.g., see Crampton et al., 2013).
Theorem 5. Let (S, U, A, C1 C2 ) instance WSP, suppose 1 planindistinguishability relation respect C1 2 plan-indistinguishability relation
respect C2 . Given ordering u1 , . . . , un U , let W1 diversity 1 respect
u1 , . . . , un W2 diversity 2 respect u1 , . . . , un .
Let equivalence relation 0 1 0 2 0 .
plan-indistinguishability relation respect C1 C2 , diversity W1 W2
respect u1 , . . . , un .
Proof. first show plan-indistinguishability relation respect C1 C2 . Let
0 eligible plans (with respect C1 C2 ). 0 implies 1 0 1 satisfies
conditions plan-indistinguishability relation, clear 0 U SER() =
U SER( 0 ) TASK() = TASK( 0 ). consider plan 00 disjoint 0 . 1
plan-indistinguishability relation respect C1 1 0 , 00 C1 -eligible
0 00 is. Similarly 00 C2 -eligible 0 00 is. Observing
plan C1 C2 -eligible C1 -eligible C2 -eligible, implies 00
C1 C2 -eligible 0 00 is. Thus 0 extension equivalent.
573

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

1 2 plan-indistinguishability relations, 00 1 0 00
00 2 0 00 , therefore 00 0 00 . Thus, satisfies conditions
plan-indistinguishability relation.
bound diversity respect u1 , . . . , un , consider Ui =
{u1 , . . . , ui }. enough note -equivalent plans [Ui , ] must
1 2 -equivalence classes. W1 choices 1 -equivalence class
W2 choices 2 equivalence class, W1 W2 equivalence classes
[Ui , ].
Remark 2. Given encoding ENC1 1 encoding ENC2 2 , may construct
encoding . Given plan , let ENC() ordered pair (ENC1 (), ENC2 ()). clear
ENC() = ENC( 0 ) 0 .
Given sets Ui = {u1 , . . . , ui }, fix linear orderings ENC1 ([Ui , ])
ENC 2 ([Ui , ]). let lexicographic ordering ENC ([Ui , ]) = ENC 1 ([Ui , ])
ENC 2 ([Ui , ]).
nothing stop us applying Theorem 5 multiple times, order get planindistinguishability relation bounded diversity union several constraint languages.
Note diversity expected grow exponentially number languages
union. Thus, makes sense apply Theorem 5 union small number languages.
However, long fixed number languages, plan-indistinguishability
relation fixed-parameter diversity, resulting union languages planindistinguishability relation fixed-parameter diversity.
use result directly show constraints either user independent
equivalence relation constraints, WSP still FPT.
Theorem 6. Suppose equivalence relation U . Let (S, U, A, C) instance
WSP, suppose constraints either form, (s1 , s2 , ), (s1 , s2 , 6) userindependent constraints. WSP solved time (2k log k+k ).
Proof. Let Ce C set constraints form (s1 , s2 , ), (s1 , s2 , 6), let Cui
remaining (user-independent) constraints.
Let u1 , . . . , un ordering U given Lemma 4. Lemmas 2 4, exists planindistinguishability relation e Ce diversity 2k respect u1 , . . . , un . Furthermore
Corollary 2, e encoding. Lemmas 1 3, exists plan-indistinguishability
relation ui Cui diversity Bk respect u1 , . . . , un . Furthermore Corollary 1,
ui encoding.
Therefore Theorem 5, may find plan-indistinguishability relation C,
diversity Bk 2k respect u1 , . . . , un encoding. Thus
may apply Theorem 1 w = Bk 2k , get running time (3k Bk 2k log(Bk 2k )) =
(3k 2k log k(1o(1))+k log(2k log k(1o(1))+k )) = (2k log k+k ).

6. Computational Experiments WSP Algorithms
Apart conducting theoretical research WSP, Wang Li (2010) carried experimental study problem. Due difficulty acquiring real-world workflow instances,
574

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

Wang Li used synthetic data experimental study. encoded instances WSP
pseudo-Boolean SAT order use pseudo-Boolean SAT solver SAT4J.
implemented algorithm compared performance SAT4J another set
synthetic instances WSP (Cohen et al., 2014). instances use k = 16, 20
24, n = 10k user-independent (cardinality) constraints three different types: vary
number constraints proportions different constraint types; user authorized
1 8 tasks k = 16, 1 10 tasks k = 20, 1 12
tasks k = 24. algorithm implemented C++ enhanced inclusion
techniques employed CSP solving, propagation. converted WSP instances
pseudo-Boolean problems processing SAT4J. experiments performed MacBook
Pro computer 2.6 GHz Intel Core i5 processor 8 GB 1600 MHz DDR3 RAM (running
Mac OS X 10.9.2).
lightly-constrained instances, SAT4J often faster algorithm, largely
number patterns considered algorithm large instances. However, highlyconstrained instances, SAT4J unable compute decision number instances (because
ran memory), sharp contrast algorithm solved instances. Overall,
average, algorithm faster SAT4J and, particular, two orders magnitude faster
k = 16. Moreover, time taken algorithm varies much less SAT4J, even
unsatisfiable instances, time taken proportional product number
patterns number users. (In particular, tested instances, much less dependent
number constraints, parameter cause significant fluctuations time taken SAT4J
leads sharp increase number variables pseudo-Boolean encoding.) Full
details results published (Cohen et al., 2014).

7. Conclusion
paper introduced algorithm based notion plan-indistinguishability, applicable
wide range WSP instances. showed algorithm powerful enough optimal,
sense, wide class user-independent constraints. generic algorithm
fixed-parameter algorithm equivalence relation constraints, user-independent.
showed deal unions different types constraints using generic algorithm.
particular, proved generic algorithm fixed-parameter algorithm union
user-independent equivalence relation constraints.

Acknowledgments
research supported EPSRC grant EP/K005162/1. grateful referees
useful comments suggestions.

References
American National Standards Institute (2004).
CITS RBAC 359-2012).
575

Role Based Access Control (ANSI IN-

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Basin, D. A., Burri, S. J., & Karjoth, G. (2014). Obstruction-free authorization enforcement: Aligning security business objectives. Journal Computer Security, 22(5), 661698.
Beldiceanu, N., Carlsson, M., & Rampon, J.-X. (2012). Global constraint catalog, 2nd edition
(revision a). working copy 5195, Swedish Institute Computer Science, Kista, Sweden.
Berend, D., & Tassa, T. (2010). Improved bounds bell numbers moments sums
random variables. Probability Mathematical Statistics, 30(2), 185205.
Bertino, E., Bonatti, P. A., & Ferrari, E. (2001). TRBAC: temporal role-based access control
model. ACM Trans. Inf. Syst. Secur., 4(3), 191233.
Bertino, E., Ferrari, E., & Atluri, V. (1999). specification enforcement authorization
constraints workflow management systems. ACM Trans. Inf. Syst. Secur., 2(1), 65104.
Bodlaender, H. L., Cygan, M., Kratsch, S., & Nederlof, J. (2013). Deterministic single exponential
time algorithms connectivity problems parameterized treewidth. Proceedings
40th International Conference Automata, Languages, Programming - Volume Part I,
ICALP13, pp. 196207, Berlin, Heidelberg. Springer-Verlag.
Bulatov, A., Jeavons, P., & Krokhin, A. (2005). Classifying complexity constraints using
finite algebras. SIAM Journal Computing, 34, 720742.
Cohen, D., Crampton, J., Gagarin, A., Gutin, G., & Jones, M. (2014). Engineering algorithms
workflow satisfiability problem user-independent constraints. Chen, J., Hopcroft,
J. E., & Wang, J. (Eds.), Frontiers Algorithmics - 8th International Workshop, FAW 2014,
Zhangjiajie, China, June 28-30, 2014. Proceedings, Vol. 8497 Lecture Notes Computer
Science, pp. 4859. Springer.
Cormen, T. H., Stein, C., Rivest, R. L., & Leiserson, C. E. (2001). Introduction Algorithms (2nd
edition). McGraw-Hill Higher Education.
Crampton, J., Crowston, R., Gutin, G., Jones, M., & Ramanujan, M. (2013). Fixed-parameter
tractability workflow satisfiability presence seniority constraints. Fellows, M.,
Tan, X., & Zhu, B. (Eds.), Frontiers Algorithmics Algorithmic Aspects Information
Management, Vol. 7924 Lecture Notes Computer Science, pp. 198209. Springer
Berlin Heidelberg.
Crampton, J. (2005). reference monitor workflow systems constrained task execution.
Proceedings Tenth ACM Symposium Access Control Models Technologies,
SACMAT 05, pp. 3847, New York, NY, USA. ACM.
Crampton, J., & Gutin, G. (2013). Constraint expressions workflow satisfiability. Proceedings 18th ACM Symposium Access Control Models Technologies, SACMAT 13,
pp. 7384, New York, NY, USA. ACM.
Crampton, J., Gutin, G., & Yeo, A. (2013). parameterized complexity kernelization
workflow satisfiability problem. ACM Trans. Inf. Syst. Secur., 16(1), 4:14:31.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann Publishers, 340 Pine Street, Sixth
Floor, San Francisco, CA 94104-3205.
Downey, R. G., & Fellows, M. R. (2013). Fundamentals Parameterized Complexity. Texts
Computer Science. Springer.
576

fiI TERATIVE P LAN C ONSTRUCTION W ORKFLOW ATISFIABILITY P ROBLEM

Fomin, F. V., Lokshtanov, D., & Saurabh, S. (2014). Efficient computation representative sets
applications parameterized exact algorithms. Proceedings Twenty-Fifth
Annual ACM-SIAM Symposium Discrete Algorithms, SODA 14, pp. 142151. SIAM.
Gligor, V., Gavrila, S., & Ferraiolo, D. (1998). formal definition separation-of-duty policies composition. 1998 IEEE Symposium Security Privacy, 1998. Proceedings., pp. 172183.
Impagliazzo, R., Paturi, R., & Zane, F. (2001). problems strongly exponential complexity?. J. Comput. Syst. Sci., 63(4), 512530.
Jayaraman, K., Ganesh, V., Tripunitara, M. V., Rinard, M. C., & Chapin, S. J. (2011). ARBAC
policy large multi-national bank. CoRR, abs/1110.2849.
Joshi, J. B. D., Bertino, E., Latif, U., & Ghafoor, A. (2005). generalized temporal role-based
access control model. IEEE Transactions Knowledge Data Engineering,, 17(1), 423.
Lokshtanov, D., Marx, D., & Saurabh, S. (2011). Slightly superexponential parameterized problems.
Proceedings Twenty-second Annual ACM-SIAM Symposium Discrete Algorithms,
SODA 11, pp. 760776. SIAM.
Niedermeier, R. (2006). Invitation Fixed-Parameter Algorithms. Oxford University Press.
Rossi, F., van Beek, P., & Walsh, T. (Eds.). (2006). Handbook Constraint Programming.
Elsevier.
Sandhu, R. S., Coyne, E. J., Feinstein, H. L., & Youman, C. E. (1996). Role-based access control
models. Computer, 29(2), 3847.
Schaad, A., Moffett, J., & Jacob, J. (2001). role-based access control system european
bank: case study discussion. Proceedings Sixth ACM Symposium Access
Control Models Technologies, SACMAT 01, pp. 39, New York, NY, USA. ACM.
Simon, R., & Zurko, M. (1997). Separation duty role-based environments. Computer
Security Foundations Workshop, 1997. Proceedings., 10th, pp. 183194.
Wang, Q., & Li, N. (2010). Satisfiability resiliency workflow authorization systems. ACM
Trans. Inf. Syst. Secur., 13(4), 40:140:35.
Wolter, C., & Schaad, A. (2007). Modeling task-based authorization constraints bpmn.
Proceedings 5th International Conference Business Process Management, BPM07,
pp. 6479, Berlin, Heidelberg. Springer-Verlag.

577


