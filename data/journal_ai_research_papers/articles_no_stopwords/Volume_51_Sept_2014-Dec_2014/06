journal artificial intelligence

submitted published

iterative plan construction workflow satisfiability
david cohen
jason crampton
andrei gagarin
gregory gutin
mark jones

c ohen rhul ac uk
jason c rampton rhul ac uk
ndrei g agarin rhul ac uk
g g utin rhul ac uk
ark j ones rhul ac uk

royal holloway university london uk

abstract
workflow satisfiability wsp practical interest arises whenever tasks need performed authorized users subject constraints defined business
rules required decide whether exists plan assignment tasks authorized
users constraints satisfied natural see wsp subclass
constraint satisfaction csp variables tasks domain set
users makes wsp distinctive number tasks usually small compared number users appropriate ask constraint languages wsp
fixed parameter tractable fpt parameterized number tasks
novel wsp techniques csp enabled us design generic
fpt several families workflow constraints considered literature
furthermore prove union fpt languages remains fpt satisfy simple compatibility condition lastly identify fpt constraint language user independent constraints includes many constraints interest business processing systems
demonstrate generic provably optimal running time k log k
language k number tasks

introduction
workflow formalises business process collection interrelated tasks performed
users order achieve objective many situations wish restrict users
perform certain tasks particular may wish specify lists users authorized
perform workflow tasks additionally may wish particular
requirements business logic security requirements prevent certain combinations
users performing particular combinations tasks crampton constraints include
separation duty known two man rule may used prevent sensitive
combinations tasks performed single user binding duty requires
particular combination tasks executed user use constraints workflow
management systems enforce security policies studied extensively last fifteen
years example see work bertino ferrari atluri crampton wang
li
workflow satisfiability
possible combination constraints authorization lists unsatisfiable
sense exist assignment users tasks contraints satisfied
c

ai access foundation rights reserved

fic ohen c rampton g agarin g utin j ones

every task performed authorized user perhaps minimal example requirement
two tasks performed user intersection authorization lists
tasks empty plan satisfies constraints allocates authorized user task said
valid workflow satisfiability wsp takes workflow specification input
returns valid plan one exists null value otherwise important determine whether
business process satisfiable since unsatisfiable one never completed without
violating security policy encoded constraints authorization lists wang li
shown reduction g raph c oloring wsp np hard subclass
csp even consider binary separation duty constraints nevertheless practical
applications wsp require solving efficient possible crampton
gutin
many hard become less complex natural parameter instance bounded
hence say input size n parameter k fixed parameter tractable fpt
admits running time f k nd constant independent n k
f computable function depending k
wang li first observe fixed parameter algorithmics appropriate
way study wsp number tasks usually small often much smaller
number users literature directly support assumption although widely cited
study schaad moffett jacob found number users exceeds job functions
roles multiplicative factor around finding confirmed recent followup study jayaraman ganesh tripunitara rinard chapin workflow specification
usually concerned particular business objective involve small number roles
taking roles proxy tasks seems reasonable assume number users
order magnitude greater number tasks believe therefore appropriate
extend work initiated wang li use fixed parameter solving
wsp parameterized number tasks particular ask constraint languages
fixed parameter tractable
wang li proved general wsp w hard thus highly unlikely
admit fixed parameter showed wsp fpt consider
separation duty binding duty constraints crampton gutin yeo obtained significantly faster fixed parameter applicable regular constraints thereby
including cases shown fpt wang li work recent
demonstrated existence fixed parameter wsp presence constraint types crampton crowston gutin jones ramanujan crampton gutin
define wsp formally introduce number different constraint types including regular
constraints section
use notation suppresses polynomial factors

g n k h n k exists polynomial q n k g n k
q n k h n k particular fpt one runs time f k
computable function f depending k

introduction fixed parameter complexity found example books downey
fellows niedermeier niedermeier



fii terative p lan c onstruction w orkflow atisfiability p roblem

relation wsp csp
constraint satisfaction csp general paradigm expressing declarative
format variables assigned values domain assignments
constrained restricting allowed simultaneous assignments sets variables
model useful many application areas including scheduling frequency assignment
circuit verification rossi van beek walsh csp community well established
community dedicated finding effective solution techniques csp dechter
csp np hard even binary equals constraints allowed domain
three elements reduce g raph c oloring csp hence considerable
effort made understand effect restricting type allowed constraints recently significant progress towards completion program
strong evidence support algebraic dichotomy conjecture bulatov jeavons
krokhin characterising precisely kinds constraint language lead polynomial
solvability
worth noting wsp subclass csp variable called task
wsp terminology arbitrary unary constraint called authorization assigns
possible values called users called conservative csp note however
usually csp number variables much larger number values wsp
number tasks usually much smaller number users important remember
wsp use term constraint authorizations define special
types constraints extend types authorizations remain arbitrary
outline
novel wsp techniques csp characterising types constraints
constraint languages particular characteristics enables us generalise unify existing
first time rather considering specific
constraints design generic fixed parameter several families
workflow constraints considered literature particular introduce notions userindependent constraints subsume number well studied constraint types wsp
literature including regular constraints studied crampton et al
generic builds plans incrementally discarding partial plans never satisfy
constraints naive presented section naive
stores far information required solve wsp running time better
exhaustively searching valid plan
generic uses general classic paradigm retain little information possible every step paradigm used classical polynomial time gaussian elimination solving systems linear equations constraint propagation
used example solve sat polynomial time generic uses
paradigm specific way concepts extension equivalence planindistinguishability patterns enabling us retain single pattern equivalence class
indistinguishable plans extension equivalence plan encodings described section
way solution constructed quite unusual accumulation
wang lis np hardness wsp thus restatement well known csp



fic ohen c rampton g agarin g utin j ones

representatives set solutions goes along users e values csp along tasks
e variables csp
analyze running time introduce notion diversity see definition notion reminiscent pathwidth measures taken prefixes largest
outcome diversity difference diversity number equivalence classes hiding actual structure behind scenes might useful
structural analysis hypergraphs
section describe pattern demonstrate fixedparameter wsp user independent constraints running time
k log k wsp user independent constraints
running time k log k wsp user independent constraints unless
exponential time hypothesis eth fails thus unlike wsp regular constraints
studied bodlaender cygan kratsch nederlof fomin lokshtanov
saurabh wsp user independent constraints highly unlikely admit
running time k generic interest constraints
user independent prove generic single exponential
constraint language obtained equivalence relation set users
section generic deal unions constraint languages
leads generalisation user independent constraints section discuss
computational experiments implementation discussed
full detail work cohen crampton gagarin gutin jones brief conclusion
given section

background
define workflow schema tuple u c set tasks workflow
u set users u authorization list task
c set workflow constraints workflow constraint pair c l l
set functions l u l scope constraint specifies assignments
elements u elements l satisfy constraint c
given x u plan function x given workflow constraint l
x u plan x satisfies l l l
plan x eligible satisfies every constraint c plan x
authorized plan valid authorized eligible plan
u called complete plan solve wsp takes workflow schema
u c input outputs valid complete plan one exists null otherwise
running example consider following instance wsp
instance task set user set u u u authorization
lists follows tick indicates given user authorized given task
exponential time hypothesis claims running time n sat n variables impagliazzo paturi zane



fii terative p lan c onstruction w orkflow atisfiability p roblem






u


u





u

u

u

u












constraints follows must assigned user must
assigned different users must assigned different users must
assigned different users
example illustrates meanings eligible complete authorised plans context
instance
example following table gives assignments four plans







u
u
u
u


u
u
u


u
u
u
u


u
u
u
u

authorized




eligible




complete




complete plan authorized eligible assigned
different users
complete plan eligible authorized u authorized
plan authorized eligible therefore valid however
complete plan assignment
complete plan eligible authorized thus valid complete plan
therefore solution
runs instance u c wsp measure running
time terms n u k c set authorization lists consists k
lists size n need consider size separately measuring
running time say runs polynomial time running time
p n k p n k polynomial n k
wsp constraints
interested complexity wsp workflow constraint language
set permissible workflow constraints restricted section introduce constraint
types interest practical applications real world workflows
assume constraints authorizations checked polynomial time
means takes polynomial time check whether plan authorized eligible valid
correctness unaffected assumption choosing constraints
checkable polynomial time would naturally affect running time


fic ohen c rampton g agarin g utin j ones

c onstraints efined b inary r elation
constraints two tasks represented form binary
relation u crampton plan satisfies constraint writing
denote relation u u u u denote relation u v u v u u v
separation duty binding duty constraints may represented form
respectively crampton et al considered constraints
equivalence relation defined u practical example workflow constraints
equivalence relation partitions users different departments constraints could
enforce two tasks performed members department constraints
restricted singleton tasks considered crampton et al wang li
plan satisfies constraint form tasks

c ardinality c onstraints
tasks per user counting constraint form tr tr k
plan satisfies tr user performs tasks tr tasks tasksper user counting constraints generalize cardinality constraints widely adopted
wsp community american national standards institute bertino bonatti ferrari
joshi bertino latif ghafoor sandhu coyne feinstein youman
r egular c onstraints
say c regular satisfies following condition partition sp

every
sp p exists eligible complete plan user u u si
plan si ui ui distinct eligible regular constraints extend set
constraints considered wang li crampton et al following
constraints regular least one sets singleton
tasks per user counting constraints form tr
u ser ndependent c onstraints
many business rules concerned identities users complete set tasks
concerned relationships users accordingly say constraint l user independent whenever u u permutation
obvious example user independent constraint requirement two
tasks performed different users separation duty complex example suppose
least exactly p users required complete sensitive set tasks cardinality
constraints p usually small e substantial literature constraints method specifying enforcing business rules example gligor gavrila
ferraiolo simon zurko including work researchers sap ibm example basin burri karjoth wolter schaad widely studied constraints
cardinality constraints separation duty form part ansi standard rolebased access control american national standards institute developed us national
institute standards technology nist short literature relevant standards suggest user independent constraints interest business processes workflow


fii terative p lan c onstruction w orkflow atisfiability p roblem

management systems definition user independent includes constraints defined
ansi rbac standard many
every regular constraint user independent many user independent constraints
regular indeed constraints type user independent necessarily
regular crampton et al many counting constraints global constraint catalogue beldiceanu carlsson rampon user independent regular particular constraint nvalue bounds number users performing set
tasks user independent regular note however constraints form
user independent general
important note authorization lists fundamental access control
system viewed unary constraints certainly user independent presence
user independent constraints authorization lists workflow specification makes
wsp challenging
naive
main aim section present simple solve
instance wsp running time slightly worse brute force basic structure provides starting point develop
efficient
need introduce additional notation terminology
let x plan x u let task u ser x
important generic task u ser given explicit parts
particular set u ser may different set users assigned task
user u u ser without task u worth observing
task may empty may allocate tasks users x
u u u denotes plan u u
two functions f e f e disjoint e e
union two disjoint functions f e f e function f f f
f e e f di let g e
h e f functions h g denotes composite function f
h g h g integer p set p p
proposition let u c instance wsp n u k c
u c solved time n k
proof let u un ordering u let ui u ui n
n turn construct set plans u ser ui valid
set n contains plan task u c solution otherwise
plan solution u c
shows construct sets hard verify contains exactly
every valid plan u ser ui implies correctness
remains analyse running time
n valid plans u ser
ui task construct need consider plans u ser u
exactly k plans plan decide polynomial time whether add


fic ohen c rampton g agarin g utin j ones

naive solution procedure wsp
input instance u c wsp
construct ordering u un u
set
foreach

set u

eligible u

set

end
end
set
n

set

foreach

foreach task

ui

set ui

eligible

set

end

end

end

end

set
end
foreach n

task

return

end
end
return null

construct n need consider every pair
task consider pair ui plan


thus possibilities

choices thus
p
p


k
k
total number pairs given j j ij kj k
pair decide whether
add ui polynomial time thus
p
k

k

k
construct takes time n
n n n

inefficient even small k due fact contains valid plans
u ser u ui next section necessary store
much information solve wsp





fii terative p lan c onstruction w orkflow atisfiability p roblem

plan indistinguishability relations
first introduce notion extension equivalence defined equivalence relation set
plans informally relation enables us keep single member equivalence class
building plans incrementally
definition given instance u c wsp two eligible plans define
following conditions hold
u ser u ser task task
eligible eligible plan disjoint
equivalence relation set eligible plans say extensionequivalent
example consider instance
let u u function u u let
u u function u u
plans eligible u ser u ser task
task plan disjoint plan satisfy constraints
thus eligible eligible similarly
eligible eligible thus eligible eligible
extension equivalent
suppose polynomial time check whether two eligible plans
extension equivalent could keep track one plan equivalence class constructing add extension equivalent
already construct may use proxy number
extension equivalent classes small compared number plans worst case running
time may substantially lower
unfortunately necessarily easy decide two eligible plans extension equivalent
practical however refine extension equivalence equivalence relation equivalence easy determine example identity equivalence
relation plan equivalent refinement
refined equivalence relation may equivalence classes extensionequivalence substantially fewer identity relation may obtain better running
time naive
definition given instance u c wsp let set eligible plans
let equivalence relation refining extension equivalence say planindistinguishability relation respect c eligible
plan disjoint eligible
example let identity relation plans u ser
u ser task task u ser
equivalence relation refinement equivalence relation every equivalence class subset
equivalence class



fic ohen c rampton g agarin g utin j ones

plan indistinguishability relation shows every plan indistinguishability relation
extension equivalence relation indeed plans given example extension equivalent
identical
recall refined extension equivalence since may hard determine whether two
eligible plans extension equivalent therefore natural assume following
assumption given plan indistinguishability relation takes polynomial time check
whether two eligible plans equivalent
correctness depend assumption however poor choice
plan indistinguishability relation could affect running times
describe appropriate plan indistinguishability relations constraints
case determining two eligible plans equivalent take polynomial
time
plan indistinguishability relation user independent constraints
lemma suppose constraints user independent let ui relation ui

u ser u ser task task
task
ui plan indistinguishability relation set eligible plans
proof definition user independent constraints eligible plan u u
permutation eligible suppose ui let task
x u ser let function
task let x x arbitrary bijection note
condition ui let permutation thus
eligible eligible
consider two eligible plans ui plan disjoint
first ui clear u ser u ser
task task u ser
task case trivially
task case since ui hence
thus similar
argument converse holds thus ui furthermore follows argument
first paragraph eligible eligible thus condition
definition second condition definition hold
first condition ui trivially satisfies first condition definition thus ui satisfies
conditions plan indistinguishability relation
example consider instance wsp users u u tasks
constraints user independent let ui plan indistinguishability relation given
lemma let c constraint scope c satisfied
even number users assigned tasks let c constraint scope


fii terative p lan c onstruction w orkflow atisfiability p roblem

c satisfied assigned different users
assigned different users suppose c c constraints whose
scope contains tasks
consider plans u u u u
u u u u u u suppose
eligible equivalent ui
observe plan disjoint eligible
eligible assign two users must assign two users
order satisfy c assign user must assign
different users order satisfy c long conditions satisfied satisfies
constraints scope eligible
plan indistinguishability relation equivalence relation constraints
recall given binary relation u constraint form si sj satisfied plan
si sj recall constraints user independent general
lemma suppose equivalence relation u let v vl equivalence classes
u suppose constraints form si sj si sj let e relation
e
u ser u ser task task
equivalence classes vj vj u ser vj u ser
task vj vj
e plan indistinguishability relation
proof clear e satisfies first condition definition suppose eligible
plans e let plan disjoint first
eligible eligible
suppose eligible consider two tasks task task
falsify constraint since equal restricted
eligible task break constraints
since eligible
may assume task task definition
exists j l vj vj u ser
vj u ser therefore definition e vj vj
task particular vj similar argument
therefore every constraint
satisfied satisfied therefore eligible
similar argument converse holds
remains e clear user task sets
user set sets vj vj u ser vj u ser
vj vj u ser vj u ser furthermore
vj set task vj vj
task case vj u ser vj u ser vj


fic ohen c rampton g agarin g utin j ones

task case similar argument
vj vj thus e
example let equivalence relation users equivalence classes
u u u u u u u u consider instance wsp users u u
tasks constraints form si sj si sj let e
plan indistinguishability relation given lemma suppose constraints whose scope
contains tasks constraints

consider plans u u u u
u u u u u u suppose
eligible equivalent e
observe plan disjoint eligible
eligible equivalence class members u u u u members
u u u u class u u u assign members u u exactly
set thus plan disjoint satisfy
constraint whatever assigns satisfy assigns
u satisfy assign u long
conditions satisfied satisfies constraints scope
eligible

generic wsp
follows x u let x denote set eligible plans
u ser x task section introduce works
similar way except instead storing valid plans particular set users
tasks construct x representative sets task set certain user sets x
definition equivalence classes plan indistinguishability relation necessarily partition
x hence equivalence class representation form x
dependent constraint language remainder section describe
give examples representations
encodings patterns
generic construct plans iteratively one plan
equivalence class plan indistinguishability relation running time
depend number equivalence classes relation certain sets plans
ensure sets equivalence classes ordered therefore searched sorted efficiently
introduce notion encodings patterns loosely speaking encoding function
maps plans equivalence class element pattern plans
encodings ensure logarithmic time access insertion operations representative set plans
rather linear time naive method would allow
note use encodings patterns necessary fixed parameter
tractability could solved without use patterns encodings
fixed parameter time function k would grow quickly



fii terative p lan c onstruction w orkflow atisfiability p roblem

definition given instance u c wsp plan indistinguishability relation
let set plans let pat set consider function enc pat
x u let pat x enc x say enc encoding
encoding x u x
enc enc
enc calculated time polynomial n k
exists linear ordering pat x p p pat x decide
whether p p time polynomial n k
elements pat called patterns enc p say p pattern
second third conditions definition ensure may use encodings organise
plans reasonable time clear context refer encoding
encoding patterns patterns
note complexity consequences definition following
proposition encoding plan indistinguishability relation set patterns pat
assigning patterns pat nodes balanced binary tree perform following
two operations time log pat check whether p pat ii insert pattern
p
pat pat
proof recall comparisons polynomial n k follows properties balanced binary trees e g see cormen stein rivest leiserson
plan indistinguishability relations given previous section
encodings first need define lexicographic order
definition given totally ordered set total lexicographic order tuples
ad defined follows say x xd yd xj yj j
xi yi xj yj j
taking n k obtain natural lexicographic order nk
lexicographically order sets disjoint subsets ordered set
tk tk
definition associate k tuple x xk nk set disjoint subsets
sr tk follows xi ti
rm sm ti rm sm
j ti tj sm xi xj
otherwise xi max x xi max
write vec x xk note vec computed time k
thus tasks subset assigned value assignment integers
tasks performed iteratively example sets
b vec
vec b lexicographically bigger b


fic ohen c rampton g agarin g utin j ones

corollary let ui plan indistinguishability relation given set user independent
constraints lemma exists encoding ui
proof let sk ordering plan let u u u ser
let vec vec plan let enc tuple u ser task vec
clear enc enc ui r si r sj
yi yj vec r yk r furthermore clear enc
determined polynomial time
remains define linear ordering pat x given x u two
patterns p x x xk p x yk pat x define p p
x xk yk
example let enc encoding given proof corollary let plans
given example enc enc u u u u
corollary let e plan indistinguishability relation given set constraints equivalence relations lemma exists encoding e
proof suppose equivalence relation users let v vp equivalence classes
u suppose constraints form si sj si sj
plan define enc u ser task


vj u ser vj u ser vj u ser j p
clear enc enc e vj
vj furthermore clear enc determined polynomial
time
remains define linear ordering pat x given x u let x
plan set disjoint subsets task natural order order
patterns pat x according lexicographic order

example let enc encoding given proof corollary let plans
given example enc enc u u u u
generic
use notion diversity introduced next definition analyse running time
generic
definition let u c instance wsp n u k c
suppose plan indistinguishability relation respect c given ordering u un
u let ui u ui n let wi number equivalence classes
set ui eligible plans define diversity respect u un
w maxi n wi
since generic stores one plan equivalence class need
notion representative set


fii terative p lan c onstruction w orkflow atisfiability p roblem

definition given instance u c wsp let set eligible plans let
plan indistinguishability relation set said representative set respect
following properties hold
every plan valid
every valid exists
clear context say representative set representative set
generic finding plan indistinguishability relations
exist small representative sets
theorem let u c instance wsp n u k c let
u un ordering u let ui u ui n u suppose
diversity w respect u un furthermore suppose exists encoding
enc u c solved time k w log w
proof proof proceeds demonstrating correctness bounding running time
solves wsp begin proof give overview
n turn construct representative set ui
denoted ui
well constructing set ui maintain companion set pat ui
enc ui provides efficient way representing equivalence classes
ui particular allows us check whether given valid plan added
ui faster searching ui linearly
un constructed remains check whether un non empty
exists valid complete plan exists valid complete plan un

gives details construct ui
proof correctness proceeds induction observe first case
u possible plan u set u
possible plan empty plan plan added u
trivially valid thus u u representative set
assume set ui constructed ui representative set consider construction ui clear
added ui ui eligible furthermore authorized
union authorized plans ui ui thus every plan
ui valid plan ui hand suppose valid plan
ui let ui let ui
ui assumption exists ui consider
plan ui clear considered
furthermore ui therefore
eligible eligible authorized union two authorized plans therefore


fic ohen c rampton g agarin g utin j ones

generic wsp
input instance u c wsp ordering u un u
plan indistinguishability relation
set u
foreach


set u
end
set
n

foreach

set ui

set pat ui

foreach

set

ui

foreach ui

set ui

eligible

set p enc

p
pat ui

insert p pat ui

set ui ui

end

end

end

end

end

end

set
end
un

return un
else

return null
end

valid added ui unless ui already contains another plan equivalent thus ui contains plan equivalent follows
ui ui representative set required
remains analyse running time proposition testing whether
pattern p pat ui inserting p pat ui takes log pat ui time
since assumption assumption time check constraints authorizations
takes polynomial time check eligibility authorization equivalence plans running


fii terative p lan c onstruction w orkflow atisfiability p roblem

p
p
p
p

time n



ui log ui clear
construction ui contains one plan equivalence class ui
sop
definition
ui w follows running time
p
n p

w log w k w log w
remark rather checking whether un non empty end
could instead check whether ui non empty construction ui
stop search soon valid plan task set likely lead
saving running time implementation concerned
worst case running time would unaffected change perform check
end interest clarity
application user independent constraints optimality
subsection wsp user independent constraints fpt let bk denote
kth bell number number partitions set k elements
lemma let u un ordering u let ui plan indistinguishability relation
given lemma ui diversity bk respect u un
proof plan set u u u ser partition tasks task
furthermore two plans generate partition equivalent ui therefore
number equivalence classes ui ui exactly number possible partitions
b thus bk required diversity
theorem constraints user independent wsp solved time
k log k
proof let u un ordering u let ui plan indistinguishability relation
given lemma
lemma ui diversity bk respect u un furthermore corollary
exists encoding ui therefore may apply theorem w bk get
running time k bk log bk k log k bk k ln k k
every k berend tassa
running time k log k obtained optimal sense running time
exists unless eth fails proof following theorem use
lokshtanov marx saurabh theorem

k log k

theorem wsp user independent constraints running time
k log k unless eth fails
proof give reduction kk ndependent et given integer parameter
k graph g vertex set v j j k decide whether g independent set
k r k exists r
informally k k ndependent et gives us graph k k grid vertices asks
whether independent set one vertex row lokshtanov et al proved
solve k k ndependent et time k log k unless eth fails


fic ohen c rampton g agarin g utin j ones

consider instance k k ndependent et graph g first produce
equivalent instance wsp constraints user independent
refine instance one user independent constraints
let u u uk set k users sk set k tasks let
authorization lists si u k j h l k let c j h l denote
constraint scope si sh satisfied plan unless si uj
sh ul every pair vertices j h l adjacent g add constraint
c j h l c
u c es instance wsp g independent set one vertex row suppose u c es instance wsp
let valid complete plan k let f unique j si uj
f k set one vertex row g furthermore satisfies every constraint edge g contains one element independent
set
conversely suppose g es instance k k ndependent
et k let

f integer f observe ki si uf valid complete
plan
reduce u c instance wsp constraints
user independent main idea introduce tasks representing users
constraints replace mention particular user mention user performs
particular task
create k tasks tk let tk let authorization lists

u ti ui k constraint c j h l
c let j h l constraint scope si sh tj tl satisfied plan
unless si tj sh tl let initially c c replace c every constraint
c j h l j h l
since defined equalities users mentioned constraints c userindependent u c equivalent u c first suppose
valid complete plan u c let u plan si si
k tj uj j k easy check satisfies every constraint
c satisfies every constraint c since authorized eligible plan valid
complete plan u c
conversely suppose valid complete plan u c since ti ui
k ti ui every k k let f unique integer
si uf define u si uf observe constraints c
satisfied valid complete plan u c
application equivalence relation constraints
known restricting wsp equivalence relation constraints enough ensure
fpt crampton et al however derive applying
directly shown appropriate properties language equivalence relation
constraints serves demonstrate wide applicability



fii terative p lan c onstruction w orkflow atisfiability p roblem

lemma let e plan indistinguishability relation given set equivalence relation
constraints lemma exists ordering u un u e diversity
k respect u
proof suppose equivalence relation users let v vp equivalence classes
u suppose constraints form si sj si sj
let u un ordering u elements vj appear elements
vj j j thus plan u ser ui u ui
one integer ji vji u ser vji u ser
follows two plans ui e equivalent n
provided vji vji therefore e k
equivalence classes ui required
theorem suppose equivalence relation u suppose constraints form
si sj si sj wsp solved time k
proof let u un ordering u given lemma let e planindistinguishability relation given lemma
lemma e diversity k respect u un furthermore corollary
exists encoding e therefore may apply theorem w k get
running time k k log k k

unions constraint languages
section allows us easily combine constraint languages shown
fpt wsp need build bespoke constraint language
obtained two languages sense compatible
highlights advantages previous methods required development different constraint languages combined instance
wsp e g see crampton et al
theorem let u c c instance wsp suppose planindistinguishability relation respect c plan indistinguishability relation
respect c given ordering u un u let w diversity respect
u un w diversity respect u un
let equivalence relation
plan indistinguishability relation respect c c diversity w w
respect u un
proof first plan indistinguishability relation respect c c let
eligible plans respect c c implies satisfies
conditions plan indistinguishability relation clear u ser
u ser task task consider plan disjoint
plan indistinguishability relation respect c c eligible
similarly c eligible observing
plan c c eligible c eligible c eligible implies
c c eligible thus extension equivalent


fic ohen c rampton g agarin g utin j ones

plan indistinguishability relations
therefore thus satisfies conditions
plan indistinguishability relation
bound diversity respect u un consider ui
u ui enough note equivalent plans ui must
equivalence classes w choices equivalence class
w choices equivalence class w w equivalence classes
ui
remark given encoding enc encoding enc may construct
encoding given plan let enc ordered pair enc enc clear
enc enc
given sets ui u ui fix linear orderings enc ui
enc ui let lexicographic ordering enc ui enc ui
enc ui
nothing stop us applying theorem multiple times order get planindistinguishability relation bounded diversity union several constraint languages
note diversity expected grow exponentially number languages
union thus makes sense apply theorem union small number languages
however long fixed number languages plan indistinguishability
relation fixed parameter diversity resulting union languages planindistinguishability relation fixed parameter diversity
use directly constraints user independent
equivalence relation constraints wsp still fpt
theorem suppose equivalence relation u let u c instance
wsp suppose constraints form userindependent constraints wsp solved time k log k k
proof let ce c set constraints form let cui
remaining user independent constraints
let u un ordering u given lemma lemmas exists planindistinguishability relation e ce diversity k respect u un furthermore
corollary e encoding lemmas exists plan indistinguishability
relation ui cui diversity bk respect u un furthermore corollary
ui encoding
therefore theorem may plan indistinguishability relation c
diversity bk k respect u un encoding thus
may apply theorem w bk k get running time k bk k log bk k
k k log k k log k log k k k log k k

computational experiments wsp
apart conducting theoretical wsp wang li carried experimental study due difficulty acquiring real world workflow instances


fii terative p lan c onstruction w orkflow atisfiability p roblem

wang li used synthetic data experimental study encoded instances wsp
pseudo boolean sat order use pseudo boolean sat solver sat j
implemented compared performance sat j another set
synthetic instances wsp cohen et al instances use k
n k user independent cardinality constraints three different types vary
number constraints proportions different constraint types user authorized
tasks k tasks k
tasks k implemented c enhanced inclusion
techniques employed csp solving propagation converted wsp instances
pseudo boolean processing sat j experiments performed macbook
pro computer ghz intel core processor gb mhz ddr ram running
mac os x
lightly constrained instances sat j often faster largely
number patterns considered large instances however highlyconstrained instances sat j unable compute decision number instances
ran memory sharp contrast solved instances overall
average faster sat j particular two orders magnitude faster
k moreover time taken varies much less sat j even
unsatisfiable instances time taken proportional product number
patterns number users particular tested instances much less dependent
number constraints parameter cause significant fluctuations time taken sat j
leads sharp increase number variables pseudo boolean encoding full
details published cohen et al

conclusion
introduced notion plan indistinguishability applicable
wide range wsp instances showed powerful enough optimal
sense wide class user independent constraints generic
fixed parameter equivalence relation constraints user independent
showed deal unions different types constraints generic
particular proved generic fixed parameter union
user independent equivalence relation constraints

acknowledgments
supported epsrc grant ep k grateful referees
useful comments suggestions

references
american national standards institute
cits rbac


role access control ansi

fic ohen c rampton g agarin g utin j ones

basin burri j karjoth g obstruction free authorization enforcement aligning security business objectives journal computer security
beldiceanu n carlsson rampon j x global constraint catalog nd edition
revision working copy swedish institute computer science kista sweden
berend tassa improved bounds bell numbers moments sums
random variables probability mathematical statistics
bertino e bonatti p ferrari e trbac temporal role access control
model acm trans inf syst secur
bertino e ferrari e atluri v specification enforcement authorization
constraints workflow management systems acm trans inf syst secur
bodlaender h l cygan kratsch nederlof j deterministic single exponential
time connectivity parameterized treewidth proceedings
th international conference automata languages programming part
icalp pp berlin heidelberg springer verlag
bulatov jeavons p krokhin classifying complexity constraints
finite algebras siam journal computing
cohen crampton j gagarin gutin g jones engineering
workflow satisfiability user independent constraints chen j hopcroft
j e wang j eds frontiers algorithmics th international workshop faw
zhangjiajie china june proceedings vol lecture notes computer
science pp springer
cormen h stein c rivest r l leiserson c e introduction nd
edition mcgraw hill higher education
crampton j crowston r gutin g jones ramanujan fixed parameter
tractability workflow satisfiability presence seniority constraints fellows
tan x zhu b eds frontiers algorithmics algorithmic aspects information
management vol lecture notes computer science pp springer
berlin heidelberg
crampton j reference monitor workflow systems constrained task execution
proceedings tenth acm symposium access control technologies
sacmat pp york ny usa acm
crampton j gutin g constraint expressions workflow satisfiability proceedings th acm symposium access control technologies sacmat
pp york ny usa acm
crampton j gutin g yeo parameterized complexity kernelization
workflow satisfiability acm trans inf syst secur
dechter r constraint processing morgan kaufmann publishers pine street sixth
floor san francisco ca
downey r g fellows r fundamentals parameterized complexity texts
computer science springer


fii terative p lan c onstruction w orkflow atisfiability p roblem

fomin f v lokshtanov saurabh efficient computation representative sets
applications parameterized exact proceedings twenty fifth
annual acm siam symposium discrete soda pp siam
gligor v gavrila ferraiolo formal definition separation duty policies composition ieee symposium security privacy proceedings pp
impagliazzo r paturi r zane f strongly exponential complexity j comput syst sci
jayaraman k ganesh v tripunitara v rinard c chapin j arbac
policy large multi national bank corr abs
joshi j b bertino e latif u ghafoor generalized temporal role
access control model ieee transactions knowledge data engineering
lokshtanov marx saurabh slightly superexponential parameterized
proceedings twenty second annual acm siam symposium discrete
soda pp siam
niedermeier r invitation fixed parameter oxford university press
rossi f van beek p walsh eds handbook constraint programming
elsevier
sandhu r coyne e j feinstein h l youman c e role access control
computer
schaad moffett j jacob j role access control system european
bank case study discussion proceedings sixth acm symposium access
control technologies sacmat pp york ny usa acm
simon r zurko separation duty role environments computer
security foundations workshop proceedings th pp
wang q li n satisfiability resiliency workflow authorization systems acm
trans inf syst secur
wolter c schaad modeling task authorization constraints bpmn
proceedings th international conference business process management bpm
pp berlin heidelberg springer verlag




