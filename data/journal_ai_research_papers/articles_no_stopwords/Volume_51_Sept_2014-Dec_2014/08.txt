Journal Artificial Intelligence Research 51 (2014) 645-705

Submitted 05/14; published 12/14

Complexity Answering Conjunctive Navigational
Queries OWL 2 EL Knowledge Bases
Giorgio Stefanoni
Boris Motik

giorgio.stefanoni@cs.ox.ac.uk
boris.motik@cs.ox.ac.uk

Department Computer Science, University Oxford
Parks Road, Oxford OX1 3QD, United Kingdom

Markus Krotzsch
Sebastian Rudolph

markus.kroetzsch@tu-dresden.de
sebastian.rudolph@tu-dresden.de

Faculty Computer Science, TU Dresden
Nothnitzer Strae 46, 01062 Dresden, Germany

Abstract
OWL 2 EL popular ontology language supports role inclusionsaxioms
form S1 Sn v capture compositional properties roles. Role inclusions closely
correspond context-free grammars, used show answering conjunctive
queries (CQs) OWL 2 EL knowledge bases unrestricted role inclusions undecidable. However, OWL 2 EL inherits OWL 2 DL syntactic regularity restriction
role inclusions, ensures role chains implying particular role described
using finite automaton (FA). sufficient ensure decidability CQ answering;
however, FAs worst-case exponential size known approaches
provide tight upper complexity bound.
paper, solve open problem show answering CQs OWL
2 EL knowledge bases PSpace-complete combined complexity (i.e., complexity
measured total size input). end, use novel encoding regular role
inclusions using bounded-stack pushdown automatathat is, FAs extended stack
bounded size. Apart theoretical interest, encoding used practical tableau
algorithms avoid exponential blowup due role inclusions. addition, sharpen
lower complexity bound show problem PSpace-hard even consider
role inclusions part input (i.e., query parts knowledge
base fixed). Finally, turn attention navigational queries OWL 2 EL
knowledge bases, show answering positive, converse-free conjunctive graph
XPath queries PSpace-complete well; interesting since allowing converse
operator queries known make problem ExpTime-hard. Thus, paper
present several important contributions landscape complexity answering
expressive queries description logic knowledge bases.

1. Introduction
Description logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2010)
family knowledge representation formalisms logically underpin Web Ontology Language OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler,
2008). DL knowledge bases describe domain terms concepts (i.e., unary predicates),
roles (i.e., binary predicates), individuals (i.e., constants), describe relationships concepts, roles, individuals using logical axioms. DLs OWL

c
2014
AI Access Foundation. rights reserved.

fiStefanoni, Motik, Krotzsch, & Rudolph

2 steadily gaining popularity provide developers modern
information systems flexible graph-like data model natural countless application areas, Semantic Web (Gutierrez, Hurtado, Mendelzon, & Perez, 2011),
social network analysis (Fan, 2012), network traffic analysis (Barrett, Jacob, & Marathe,
2000). Answering queries DL/OWL knowledge bases core service applications
diverse monitoring financial products within Italian Ministry Economy
Finance (De Giacomo et al., 2012), accessing real-time diagnostic data turbines (Giese
et al., 2013), integrating configuration data air traffic control systems (Calvanese
et al., 2011). Due practical importance query answering, theoretical investigation
expressivity computational complexity query languages high
research agenda knowledge representation community past decade.
Conjunctive queries (CQs) (Chandra & Merlin, 1977) basic class queries
relational databases. Querying DL knowledge bases using CQs studied diverse range settings (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; PerezUrbina, Motik, & Horrocks, 2010; Rudolph & Glimm, 2010; Kontchakov, Lutz, Toman,
Wolter, & Zakharyaschev, 2011; Ortiz, Rudolph, & Simkus, 2011; Gottlob & Schwentick,
2012; Venetis, Stoilos, & Stamou, 2012). However, conjunctive queries first-order definable thus cannot express certain important properties graph reachability.
Regular path queries (RPQs) (Cruz, Mendelzon, & Wood, 1987; Barcelo, 2013) alternative query language capable describing connections graph vertices using
regular expressions, allowing users navigate inside graph. example, RPQ
(isPartOf hasLocation) retrieves pairs vertices connected via zero isPartOf
edges followed one hasLocation edge. Furthermore, 2RPQs extend RPQs converse operator (i.e., backward navigation) (Calvanese, Vardi, De Giacomo, & Lenzerini,
2000); nested regular expressions allow existential quantification paths (Perez,
Arenas, & Gutierrez, 2010); C(2)RPQs extend (2)RPQs CQs conjunctions (2)RPQs (Calvanese, De Giacomo, Lenzerini, & Vardi, 2000; Bienvenu, Ortiz, &
Simkus, 2013). Finally, inspired XPath query language XML, graph XPath queries
(GXQs) recently proposed language querying graph databases (Libkin,
Martens, & Vrgoc, 2013) DL knowledge bases (Kostylev, Reutter, & Vrgoc, 2014; Bienvenu, Calvanese, Ortiz, & Simkus, 2014). GXQs extend 2RPQs negation regular
expressions, checking properties vertices using Boolean combinations node tests
is, concepts existential quantifications paths. example, graph XPath
query (isPartOf test(Cell hhasSpecialityi) hasLocation) refines aforementioned RPQ
requiring node isPartOf edges hasLocation edge instance Cell concept outgoing hasSpeciality edge. Graph XPath
queries straightforwardly extended conjunctive graph XPath queries (CGXQs).
query languages Boolean answer variables; hence, answer
query Boolean value.
1.1 Problem Setting
Although computing answers query DL knowledge base function problem,
common literature consider complexity associated decision problem
is, checking whether Boolean query entailed knowledge base. article

646

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

follow well-established practice analyse computational properties several
query languages DL knowledge bases. follow Vardi (1982) measure input
size two ways: combined complexity measures complexity terms combined
size query knowledge base, data complexity measures complexity
terms size data (i.e., query parts knowledge bases
considered fixed).
computational properties query answering DL knowledge bases depend
expressivity constructs used knowledge base query language
used. particular, conjunctive query answering expressive description logics
least exponential combined complexity (Glimm, Lutz, Horrocks, & Sattler, 2008; Lutz,
2008) intractable data complexity (Calvanese, De Giacomo, Lembo, Lenzerini, &
Rosati, 2013; Ortiz, Calvanese, & Eiter, 2008). problem becomes tractable data
complexity RL (Grosof, Horrocks, Volz, & Decker, 2003; ter Horst, 2005)
QL (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009) profiles
OWL 2, several worst-case optimal algorithms proposed perform well
practice (Urbani, van Harmelen, Schlobach, & Bal, 2011; Rodriguez-Muro & Calvanese,
2012). paper, however, focus OWL 2 EL profile OWL 2, based
EL family DLs (Baader, Brandt, & Lutz, 2005). Basic reasoning problems
OWL 2 EL, checking concept subsumption instance checking, decided
polynomial time (Baader et al., 2005; Krotzsch, 2011), makes language
interesting practical applications. Motivated observation, paper present
several novel complexity results answering queries OWL 2 EL knowledge bases.
One important modelling constructs OWL 2 EL role inclusionsaxioms
form S1 Sn v express compositional properties roles. example,
following inclusions state role isPartOf transitive that, x located
part z, x located z.
isPartOf isPartOf v isPartOf

hasLocation isPartOf v hasLocation

Prior introduction EL family, role inclusions already identified
source undecidability expressive DLs loosely correspond context-free
grammars: inclusion S1 Sn v knowledge base seen production rule
S1 Sn , knowledge base induces context-free language L(S) role
S. Using correspondence, Wessel (2001) showed checking satisfiability ALCR
knowledge bases unrestricted role inclusions undecidable. regain decidability,
Horrocks Sattler (2004) proposed syntactic regularity restriction role inclusions
ensuring language L(S) regular thus recognised using finite
automaton (FA); Kazakov (2008) later showed that, cases, size automaton
necessarily exponential knowledge base size. OWL 2 DL profile OWL 2
extends ALCR thus incorporates regularity restriction definition.
Even unrestricted role inclusions, standard reasoning problems EL
solved polynomial time (Baader et al., 2005). Moreover, Stefanoni, Motik, Horrocks
(2013) showed answering CQs OWL 2 EL knowledge bases without role inclusions
NP-complete. However, using correspondence role inclusions contextfree grammars, Rosati (2007) Krotzsch, Rudolph, Hitzler (2007) independently
proved answering CQs EL knowledge bases unrestricted role inclusions
647

fiStefanoni, Motik, Krotzsch, & Rudolph

undecidable; furthermore, Krotzsch et al. (2007) showed checking concept subsumptions EL knowledge bases inverse roles unrestricted role inclusions
undecidable.
OWL 2 EL inherits regularity restriction OWL 2 DL, undecidability proofs Rosati (2007) Krotzsch et al. (2007) apply OWL 2 EL.
fact, Krotzsch et al. (2007) showed answering CQs EL knowledge bases extended
regular role inclusions PSpace-hard combined complexity, proposed
CQ answering algorithm fragment OWL 2 EL regular role inclusions.
algorithm, however, runs PSpace if, role S, language L(S) represented using automaton polynomial size; due mentioned result Kazakov
(2008), approach provide us matching PSpace upper bound
problem. Ortiz et al. (2011) proposed different algorithm answering CQs OWL 2
EL knowledge bases (with regular role inclusions without restriction usage
features). Similarly algorithm Krotzsch et al. (2007), algorithm
Ortiz et al. (2011) encodes regular role inclusions using finite automata. Hence,
algorithms run time polynomial size data thus settle
question data complexity, settle question combined complexity.
comparatively works studying complexity (conjunctive) graph
XPath queries DL knowledge bases. particular, Kostylev et al. (2014) observed
GXQs closely related propositional dynamic logic full negation (Harel, Tiuryn,
& Kozen, 2000), immediately shows answering GXQs DL knowledge bases
undecidable even respect empty knowledge base. Several GXQ fragments
proposed possible solution problem: path-positive GXQs disallow negation
role expressions, positive GXQs prohibit negation concepts well.
Kostylev et al. (2014) showed answering path-positive GXQs intractable data
complexity already queries without transitive closure operator knowledge
bases containing instance assertions. Recently, Bienvenu et al. (2014) showed
answering positive GXQs fragment OWL 2 EL tractable data complexity,
ExpTime-complete combined complexity.
1.2 Contributions
paper, present several novel complexity results answering queries OWL 2
EL knowledge bases.
First, present first CQ answering algorithm handle OWL 2 EL
(with regular role inclusions without restriction size FAs)
runs PSpace, thus settle open question combined complexity
CQ answering OWL 2 EL. result based novel encoding languages
induced regular role inclusions using pushdown automata (PDAs)that is, FAs extended
stack. show that, role S, construct polynomial time
PDA accepts language L(S) whose computations use stack size linear
number role inclusions. Bounded-stack PDAs (Anselmo, Giammarresi, & Varricchio,
2003) recognise precisely class regular languages exponentially
succinct finite automata (Geffert, Mereghetti, & Palano, 2010). obtain CQ
answering algorithm running PSpace, extend algorithm Krotzsch et al. (2007)

648

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

data
combined

ELHOdr

PTime

OWL 2 EL
PTime

Horn-SHOIQ
PTime

Horn-SROIQ
PTime

(Ortiz et al., 2011)

(Theorem 31)

(Ortiz et al., 2011)

(Ortiz et al., 2011)

NP

PSpace

ExpTime

2ExpTime

(Stefanoni et al., 2013)

(Theorem 31)

(Ortiz et al., 2011)

(Ortiz et al., 2011)

Table 1: complexity landscape CQ answering (all completeness results)
handle universal role, keys, self-restrictions, reflexive roles, thus covering
features EL profile apart datatypes, adapt handle
regular role inclusions encoded using PDAs. Apart allowing us obtain complexity
results presented paper, tableau algorithm Horrocks, Kutz, Sattler (2006)
used popular reasoners Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz,
2007) FaCT++ (Tsarkov & Horrocks, 2006) straightforwardly modified use
bounded-stack PDAs instead FAs, could eliminate potential source inefficiency
practice. Finally, brevity simplicity deal datatypes paper;
however, set OWL 2 EL datatypes designed enable datatype
reasoning using external datatype checking procedure (Baader, Brandt, & Lutz, 2008;
Cuenca Grau et al., 2008) easily incorporated algorithm.
Second, improve PSpace lower bound Krotzsch et al. (2007) showing
answering CQs OWL 2 EL PSpace-hard already role inclusions
considered part input (i.e., conjunctive query, TBox, ABox
fixed). Furthermore, show CQs answered polynomial time query
role inclusions fixed, emphasises observation role inclusions
main source problems PSpace-hardness.
Third, show positive, converse-free CGXQsthat is, CGXQs allow
negation paths, negation concepts, converse operatorcan answered
OWL 2 EL knowledge bases using polynomial space. particular, OWL 2 EL allows
role inclusions, self-restrictions, reflexive roles, allow us polynomially reduce answering CGXQ answering CQ extended knowledge base.
show answering positive, converse-free GXQs (i.e., CGXQs single atom)
done time polynomial input size. result interesting Bienvenu
et al. (2014) proved answering positive GXQs EL knowledge bases ExpTimecomplete; hence, adding converse operator increases complexity GXQs.
results thus show answering GXQs CGXQs difficult instance checking
answering conjunctive queries, respectively, least theoretical perspective
makes GXQs CGXQs appealing query languages OWL 2 EL knowledge bases.
1.3 Summary Complexity Landscape
Table 1 summarises complexity landscape answering CQs various DLs related
OWL 2 EL. Here, ELHOdr
fragment OWL 2 EL obtained allowing simple
role inclusions form v S, disallowing universal role, reflexive roles,
self-restrictions, datatypes, combined complexity result logic due
Stefanoni et al. (2013). Furthermore, Horn-SHOIQ extends ELHOdr
inverse roles
Horn qualified number restrictions, Horn-SROIQ extends Horn-SHOIQ role
649

fiStefanoni, Motik, Krotzsch, & Rudolph

data

positive
positive
converse-free converse-free
GXQs
CGXQs
PTime-c
PTime-c
(Theorem 34)

combined

PTime-c
(Theorem 34)

positive
GXQs

path-positive
GXQs

GXQs

PTime-h

coNP-h

coNP-h

(Theorem 34) (Bienvenu et al., 2014) (Kostylev et al., 2014) (Kostylev et al., 2014)

PSpace-c

ExpTime-h

ExpTime-h

undecidable

(Theorem 34) (Bienvenu et al., 2014) (Bienvenu et al., 2014) (Kostylev et al., 2014)

Table 2: complexity answering navigational queries OWL 2 EL knowledge bases
(c means complete, h means hard)

inclusions; results logics due Ortiz et al. (2011). CQ answering PTimecomplete data complexity cases, essentially due fact
logics Horn disjunctive reasoning needed. combined complexity,
table illustrates presence different constructs affects complexity answering
CQs. particular, extending ELHOdr
role inclusions increases complexity
NP PSpace; PSpace lower bound, increase solely due role inclusions.
Furthermore, extending ELHOdr
inverse roles increases complexity NP
ExpTime. Finally, extending OWL 2 EL inverse roles increases complexity
PSpace 2ExpTime.
Table 2 summarises complexity landscape answering navigational queries
OWL 2 EL knowledge bases. one see, adding converse operator increases
combined complexity GXQs ExpTime (Bienvenu et al., 2014). Moreover, adding
negation node tests increases data complexity GXQs coNP, whereas adding
negation path expressions leads undecidability combined complexity (Kostylev
et al., 2014). contrast, existential quantification paths increase complexity: answering positive, converse-free (C)GXQs OWL 2 EL knowledge bases
difficult answering (C)RPQs EL knowledge bases (Bienvenu et al., 2013).
1.4 Organisation Article
rest article organised follows. Section 2, present basic definitions
finite automata, pushdown automata, DL underpinning OWL 2 EL, conjunctive
queries. Section 3, introduce novel encoding regular role inclusions using PDAs
bounded stack size. Section 4, present CQ answering algorithm OWL 2
EL discuss complexity. Section 5, present improved PSpace lower-bound
answering CQs OWL 2 EL. Finally, Section 6, introduce (conjunctive) graph
XPath queries, show reduce problem answering positive, converse-free
conjunctive graph XPath queries answering ordinary conjunctive queries, present
aforementioned complexity results.

650

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

2. Preliminaries
section recapitulate basic definitions finite automata, pushdown automata,
DL ELRO+ underpinning OWL 2 EL, conjunctive queries. rest paper,
[i..j] set containing natural number k N k j.
2.1 Automata Language Theory
article, use standard notions alphabets (which must finite), strings, string
concatenation, Kleene operators, languages formal language theory (Hopcroft,
Motwani, & Ullman, 2003). assume alphabets contain special symbol
, use label transitions automata consume input symbols.
Furthermore, empty word. Finally, w w0 words, |w| number symbols
occurring w; w w0 unique word w00 w := w00 w0 w00 exists,
otherwise w w0 undefined.
2.1.1 Finite Automata
finite automaton (FA) tuple F = hQ, , , i, f Q finite set states,
input alphabet, : Q {} 7 2Q transition function, Q start state,
f Q final state. F deterministic |(s, )| = 0 |(s, c)| 1
Q c ; otherwise, F nondeterministic. size |F| F number
symbols used encode F tape Turing machine.
instantaneous description F pair hs, wi Q w .
derivation relation ` F smallest set that, states s0 Q,
symbol c , word w ,
s0 (s, c), hs, c wi ` hs0 , wi;
s0 (s, ), hs, wi ` hs0 , wi.
Let ` reflexive transitive closure `. Then, language accepted F
defined L(F) = {w | hi, wi ` hf, i}. language L regular FA
F exists L = L(F).
2.1.2 Pushdown Automata
pushdown automaton (PDA) tuple P = hQ, , , , i, I, f, F Q finite set
states; input alphabet; stack alphabet; transition function mapping
state Q, symbol c {}, stack symbol X finite subset
(s, c, X) Q ; Q start state; start stack ; f Q final
state; F final stack. size |P| P number symbols used
encode P tape Turing machine.
instantaneous description P triple hs, w, Q, w ,
. read stack content left rightthat is, leftmost symbol
top stack. derivation relation ` P smallest set that,
states s0 Q, symbol c , word w , stack symbol X ,
words 0 ,

651

fiStefanoni, Motik, Krotzsch, & Rudolph

hs0 , 0 (s, c, X) implies hs, c w, X ` hs0 , w, 0 i;
hs0 , 0 (s, , X) implies hs, w, X ` hs0 , w, 0 i.
Let ` reflexive transitive closure relation `. Then, language accepted
P defined L(P) = {w | hi, w, Ii ` hf, , F i}.
definitions PDA P language L(P) somewhat nonstandard:
literature typically considers Hopcroft PDA (Hopcroft et al., 2003) Ph differs
definition contain final stack F initial stack symbol
(rather word ); moreover, language accepted Ph defined
Lh (Ph ) = {w | : hi, w, Ii ` hf, , i}. show next definitions
equivalent standard definitions Hopcroft et al. (2003).
Proposition 1. following two properties hold.
(1) PDA P, Hopcroft PDA Ph exists L(P) = Lh (Ph ).
(2) Hopcroft PDA Ph , PDA P exists Lh (Ph ) = L(P).
Proof (Sketch). first prove property (1), prove property (2).
(1) show transform arbitrary PDA P Hopcroft PDA Ph
L(P) = Lh (Ph ). Ph uses fresh initial state i0 fresh stack symbols Z0
occurring . Symbol Z0 start stack symbol Ph ; furthermore, Ph new
-transition moves PDA state i0 initial state P replacing Z0
, start stack P. point, Ph simulates P, always leaving
bottom stack reaches final state f P. Next, Ph uses fresh
states s1 , . . . , s|F | fresh -transitions move Ph state f s|F | reading F
stack. Finally, s|F | , PDA Ph -moves fresh final state f 0 top-most
symbol stack , thus accepting input whenever P reaches f F
stack. Automata P Ph clearly accept languages.
(2) show transform arbitrary Hopcroft PDA Ph PDA P
Lh (Ph ) = L(P). PDA P uses fresh stack symbol , initial stack
initial stack symbol Ph , final stack empty word. P simulates Ph ,
always leaving bottom stack reaches final state f Ph . Next, P
-moves fresh final state f 0 pops topmost symbol stack. point,
PDA takes -transitions empty stack, eventually reaching final state
empty stack. Automata P Ph clearly accept languages.
k natural number, k-bounded language accepted P set Lk (P) containing word w derivation hs0 , w0 , 0 ` ` hsn , wn , n exists
s0 sn start final state P, respectively;
w0 = w wn = ;
0 n start final stack P, respectively;
|i | k [0..n].

652

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Then, P k-bounded stack L(P) = Lk (P). stack P bounded
constant, PDA P simulated finite automaton encodes stack contents
using states, L(P) regular, translating P finite automaton may
require space exponential k (Geffert et al., 2010). contrast, following proposition
shows exists PDA Pk L(Pk ) = Lk (P) size Pk polynomial
size P k.
Proposition 2. PDA P natural number k, one compute polynomial
time PDA Pk L(Pk ) = Lk (P).
Proof. Let P = hQ, , , , i, I, f, F PDA let k N natural number. Let
Pk = hQk , , , k , ik , I, fk , F PDA defined
Qk = Q [0..k];
transition function k smallest function that, ` [0..k], symbol
c {}, states s, s0 Q, word hs0 , (s, c, X)
` + || 1 k, hhs0 , ` + || 1i, k (hs, `i, c, X);
ik = hi, |I|i fk = hf, |F |i.
Clearly, Pk computed time polynomial size P k. Let ` `k
derivation relations P Pk , respectively. definitions k ik ,
hhs, `i, w, `k hhs0 , ji, w0 , 0 hs, w, ` hs0 , w0 , 0 i, || = ` | 0 | = j,
max(`, j) k. Thus, Lk (P) = L(Pk ), required.
2.2 Description Logic ELRO+ Conjunctive Queries
description logic ELRO+ , underpinning OWL 2 EL, defined w.r.t. signature consisting mutually disjoint countably infinite alphabets C, R, atomic concepts,
roles, individuals, respectively. assume {>c , c } C, >c top
concept c bottom concept; similarly, assume {>r , r } R, >r
top role (universal role) r bottom role. individual I, expression
{a} nominal is, concept consisting precisely individual a. Then, N set
containing nominal {a} individual I. call B C N basic concept.
role chain word R; || = 0, call empty role chain write
. Concepts, TBox axioms, RBox axioms, ABox axioms defined specified
Table 3. ELRO+ TBox finite set concept inclusions, range restrictions,
keys; ELRO+ RBox R finite set role inclusions.
R ELRO+ RBox, let R := {>r } {S R | occurs R}; furthermore,
rewrite relation =
w.r.t. R smallest relation role chains following
holds role chains 1 2 .
1 2 =
1 2 axiom v R.
1 >r 2 =
1 2 role chain R .
=
reflexivetransitive closure
= . role, L(S) := { R | =
}
language induced RBox R. role simple R if, role chain
653

fiStefanoni, Motik, Krotzsch, & Rudolph

Concepts:
top concept
bottom concept
nominal
conjunction
self-restriction
existential restriction
Role chains:
top role
bottom role
empty role chain
nonempty role chain
TBox axioms:
concept inclusion
range restriction
key

RBox axioms:
role inclusion
ABox axioms:
concept assertion
role assertion

Syntax

Semantics

>c
c
{a}
C uD
S.Self
S.C



{aI }
C DI
{x | hx, xi }
{x | C : hx, yi }

>r
r

S1 Sn



{hx, xi | x }
S1I SnI

CvD
range(S, C)
key(C, S1 . . . Sn )

C DI
C
x, y, z1 , . . . , zn
individuals a, b, c1 , . . . , cn exist
x = aI , = bI , zi = cIi 1 n,
x = holds whenever {x, y} C
{hx, zi i, hy, zi i} SiI 1 n.

vS


bI
SI

A(b)
S(a, b)

haI , bI

Table 3: Interpreting ELRO+ concepts, roles, axioms interpretation = hI ,

S=
, || 1. ELRO+ ABox finite set concept role assertions.
Finally, ELRO+ knowledge base (KB) tuple K = hT , R, Ai ELRO+
TBox, R ELRO+ RBox, ELRO+ ABox
concept S.Self occurring , role simple R;
S1 Sn v R range(S 0 , C) 0 =
S, role Sn0 R
0

0
exists Sn =
Sn range(Sn , C) .
Let |T |, |R|, |A| numbers symbols needed encode , R, A, respectively,
tape Turing machine, let |K| = |T |+|R|+|A|. Furthermore, knowledge
base, TBox, ABox, define
:= {a | occurs }, N := {{a} | }, C := {A C | occurs }.
654

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

semantics ELRO+ defined follows. interpretation tuple = hI ,
nonempty set domain elements, called domain I, interpretation function maps individual domain element aI ,
atomic concept C \ {>c , c } set AI , atomic role R \ {>r , r }
relation . Function extended concepts role chains shown
upper part Table 3, denotes composition binary relations. interpretation model K satisfies axioms occurring K shown bottom
Table 3. Moreover, K consistent model K exists; K inconsistent model
K exists; K entails first-order sentence (resp. concept inclusion C v role
inclusion v S), written K |= (resp. K |= C v K |= v S), |= (resp. C DI
) model K. definition L(S), L(S) implies
K |= v S. Knowledge base consistency, entailment concept inclusions, entailment
role inclusions decided polynomial time (Krotzsch, 2011; Baader et al., 2005).
2.2.1 Conjunctive Queries
term individual variable. atom expression form A(t) R(t0 , t)
atomic concept, R role, t0 terms. conjunctive query (CQ)
formula q = ~y .(~x, ~y ) conjunction atoms variables ~x ~y . Variables ~x
answer variables q. ~x empty, call q = ~y .(~y ) Boolean CQ (BCQ).
substitution partial mapping variables terms; dom() rng()
domain range , respectively. conjunction atoms, ()
result applying substitution atoms . Then, (q) = ~z.(), ~z contains
(i) (y) variable ~y (y) variable, (ii) variable ~y
(y) undefined. definition (q) somewhat nonstandard quantified
variables replaced: example, given q = y1 , y2 , y3 .R(y1 , y2 ) (y1 , y3 )
= {y2 7 a, y3 7 z}, (q) = y1 , z.R(y1 , a) (y1 , z).
Let K = hT , R, Ai ELRO+ knowledge base let q = ~y .(~x, ~y ) CQ.
q K q uses predicates individuals occurring K. substitution
candidate answer q K, dom() = ~x rng() IK , certain
answer q K K |= (q). Answering q K amounts computing
set certain answers q K. stated, CQ answering function problem;
thus article study complexity associated decision problem named BCQ
answering, problem deciding, given Boolean CQ q K, whether K |= q.
Please note BCQ answering equivalent recognition problem decides,
given CQ q K candidate answer , whether certain answer q K.
Following Vardi (1982), combined complexity assumes q K part
input, data complexity assumes ABox part input.
2.3 Ensuring Decidability BCQ Answering via Regularity
Rosati (2007) Krotzsch et al. (2007) independently showed answering Boolean
CQs ELRO+ knowledge bases undecidable. Intuitively, role inclusions simulate derivations context-free languages; thus, Boolean CQ check whether two
context-free languages non-empty intersection, known undecidable problem (Hopcroft et al., 2003).

655

fiStefanoni, Motik, Krotzsch, & Rudolph

regain decidability, next recapitulate definition so-called regular RBoxes
Horrocks Sattler (2004). Let R ELRO+ RBox let smallest
transitive relation R that, 0 v R 6= , S.
Then, RBox R regular irreflexive role inclusion v R form
(t1) v S,
(t2) v S,
(t3) S1 Sn v Si 6= [1..n],
(t4) S1 Sn v Si 6= [1..n],
(t5) S1 Sn v Si 6= [1..n].
induction define level lv(S) role R follows: lv(S) = 0
R exists S; otherwise, lv(S) = 1 + max{lv(T ) | S}. Clearly,
lv(S) computed time polynomial |R|. Section 4 show BCQ answering
ELRO+ KBs regular RBoxes PSpace.
2.4 Normalising ELRO+ Knowledge Bases
simplicity, rest paper assume ELRO+ knowledge base
K = hT , R, Ai normalised, case following properties hold.
(n1) IK 6= , K 6|= {a} v {b} {a, b} IK 6= b.
(n2) axiom one following forms, A(i) basic concepts role.
A1 u A2 v A3

A1 v S.A2

S.A1 v A2

v S.Self

S.Self v

(n3) axiom v R || 2 6= >r , role
occurs R.
next show knowledge base K normalised polynomial time without
affecting regularity RBox component answers Boolean CQs.
Proposition 3. ELRO+ knowledge base K regular RBox Boolean
CQ q K, one compute polynomial time normalised ELRO+ knowledge base
K0 Boolean CQ q 0
RBox K0 regular,
q 0 K0 , K |= q K0 |= q 0 .
Proof. Let K ELRO+ KB regular RBox let q Boolean CQ K.
first satisfy property (n1). Let K1 obtained K extending ABox
K assertion >c (c) c fresh individual; clearly, K1 |= q K |= q.
Next, let K2 q 0 obtained K1 q, respectively, uniformly substituting
individual arbitrary, fixed, individual b K1 |= {a} v {b}. Entailment
656

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

concept inclusions decided polynomial time, K2 q 0 computed
polynomial time. Moreover, K2 q 0 obtained replacing individual
arbitrary, fixed individual b aI = bI model K1 , q 0 K2 ,
K2 |= q 0 K1 |= q.
next satisfy property (n2). Let K3 result eliminating keys K2 .
one see Table 3, keys derive axioms form {a} v {b}; moreover,
effects conclusions already captured K2 , K3 |= q 0
K2 |= q 0 . Next, eliminate polynomial time range restrictions occurring
K applying syntactic transformation Baader et al. (2008); let K4 resulting
knowledge base. Since definition ELRO+ knowledge base carefully restricts
interactions role inclusions range restrictions, K4 |= q 0
K3 |= q 0 (Baader et al., 2008). Next, following Krotzsch (2011), compute polynomial
time knowledge base K5 satisfies (n2) K5 |= q 0 K4 |= q 0 .
next satisfy property (n3). Let K6 result exhaustively decomposing
role inclusion v form (t3)(t5) || > 2 occurring K5 according
following rewrite rules, occurrence role 0 fresh.
(t3) S1 Sn v 7 {S 0 v S,
1 Sn v 0 }
0
(t4)
S1 Sn v 7 {S Sn v S, S1 Sn1 v 0 }
(t5) S1 Sn v
7
{S 0 v S,
1 Sn v 0 }
linearly many rewrite steps required satisfy (n3), resulting RBox
regular. Furthermore, model K6 model K5 model K5
expanded model J K6 interpreting role 0 occurring K6 \ K5
(S 0 )J = (0 )J , 0 unique role chain 0 v 0 occurs K6 . Thus,
K6 |= q 0 K5 |= q 0 . Next, let K7 result removing axiom
v >r K6 ; removed axioms tautologies, K7 |= q 0 K6 |= q 0 .
Finally, let K0 result adding axiom r v S, role occurs K7
occur RBox component. axioms K0 \ K7 preserve regularity
tautologies, K0 |= q 0 K7 |= q 0 , required.

3. Encoding Regular RBoxes Succinctly Using Bounded-Stack PDAs
reasoning algorithm DL role inclusions known us uses step checks
whether L(S) holds arbitrary role chain role S. example, check
whether K |= S(a, b) holds, algorithm must ensure that, model K, role chain
L(S) exists connecting elements interpreting b. Although characterise
languages L(S), role inclusions lend well language recognition,
algorithms known us transform role inclusions another, manageable form.
analogous fact that, regular expressions characterise regular languages,
former routinely transformed FAs order facilitate language recognition.
Horrocks Sattler (2004) showed that, regular RBox R role
occurring R, one construct FA FS L(FS ) = L(S). FAs used
tableau decision procedure SROIQthe DL underpinning OWL 2 DL (Horrocks
et al., 2006). Given SROIQ knowledge base, tableau procedure tries construct
657

fiStefanoni, Motik, Krotzsch, & Rudolph

S2

iS2

start




iS1

S1

fS2

iS1

fS1



S0

fS0

fS1





iS0

S1


iS0

S0

iS0

fS0

S0

fS0

iS0

S0

fS0

Figure 1: FA FS2 constructed following Horrocks Sattler (2004)
finite graph representing model KB, edges labelled roles,
vertices labelled concepts. aforementioned FAs used ensure universal
restriction S.C obey constraints imposed role inclusions; roughly speaking,
obtained running FS graph updating current state FS along
path, labelling reachable vertex state FS final concept
C. Simanck (2012) optimised tableau procedure simulating FAs on-the-fly, rather
precomputing advance.
Horrocks Sattler (2004) observed FAs contain exponentially many
states. Kazakov (2008) proved unavoidable cases: regular RBox
Rn containing axioms (1), size FA F L(F) = L(Sn ) exponential n.
Si1 Si1 v Si

[1..n]

(1)

blowup number states caused simple model computation underlying FAs, behaviour automaton determined solely current state.
example above, L(Sn ) whenever consists Si repeated j times
[0..n] j = 2ni . Thus, parsing , FA recognising L(Sn ) must
remember number occurrences Si already seen, achieved
using different state number 0 2n . Figure 1 shows FA FS2
constructed Horrocks Sattler (2004): remember current state, FS2 contains
two copies automaton FS1 , copy FS1 contains two copies automaton FS0 .
Hence, obtain PSpace procedure, must devise succinct representation
languages induced role inclusions. Towards goal, note role inclusions
closely related context-free grammars, context-free languages efficiently
recognised using pushdown automata (Hopcroft et al., 2003)that is, FAs extended
infinite stack storing contextual information. Hence, given regular RBox R
role occurring R, construct PDA PS accepts L(S). Unlike FA shown
Figure 1 remembers contextual information using states, PDA PS uses stack
remember current status computation determine proceed. show
number states PS polynomial size R, PS recognise
L(S) using stack size linear size R; thus, PS provides us required
succinct encoding FS . Section 4, use PDAs algorithm answers
Boolean CQs ELRO+ knowledge bases using polynomial space.
658

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

start

iS2

S2 , X/X

fS2
, X/X

, X/iS1 fS2 X

iS1

S1 , X/X

i>r

fS1

R, X/X

f>r

, X/X
, X/iS0 fS1 X

iS0

S0 , X/X

fS0

Figure 2: PDA PS2 corresponding FA FS2 , X R R R
rest section, fix arbitrary regular RBox R. Proposition 3,
assume role inclusion v R || 2 6= >r .
role occurring R , next define PDA PS .
Definition 4. Let R role. Then, PS = hQR , R , R , R , , , fS , PDA
QR = {iT , fT | R } set states, R = QR {} stack alphabet,
R smallest transition function satisfying following conditions X R .
(r) R \ {>r }, hfT , Xi R (iT , T, X).
(t1) v R, hfT , Xi R (iT , , X).
(t2) v R, hiT , Xi R (fT , , X).
(t3) T1 v R, hiT1 , Xi R (iT , , X).
(t4) T1 T2 v R, hiT1 , iT2 fT Xi R (iT , , X).
(t5) T2 v R, hiT2 , fT Xi R (fT , , X).
(ur) R , hf>r , Xi R (i>r , T, X).
(u1) hf>r , Xi R (i>r , , X).
(u2) hi>r , Xi R (f>r , , X).
(p) R QR , hs, R (fT , , s).
following examples, present PDA succinctly encodes FA FS2 ,
explain different types transitions Definition 4, content
stack influences computation PDAs.
Example 5. Figure 2 shows PDA PS2 corresponding FA FS2 Figure 1.
c, X/

transition hs0 , R (s, c, X) shown s0 , X/ indicates transition replaces top-most stack symbol X word ; moreover, transitions form
(p) Definition 4 shown figure sake clarity. one see
figure, unlike FA FS2 , copying states PDA PS2 .
659

fiStefanoni, Motik, Krotzsch, & Rudolph

, X/X

start



S, X/X

, X/i>r fS X

i>r

fS

R, X/X

f>r

, X/X

, X/fS X
, X/iT X

iP



T, X/X

fT

, X/X
, X/X

P, X/X

fP
Figure 3: PDA PS RBox Example 6, X R R R
Example 6. explain different types transitions Definition 4 stack
used computation PDA, use regular RBox R containing role inclusions
(2)(6). Figure 3 shows PDA PS using notation Example 5.
vP

(2)

vT

(3)

P >r v

(4)

ST vS

(5)

P vT

(6)

role R associated states fT , moving former
latter ensures PDA reads role chain L(T ). transition type (r) allows
PDA read state . -transition type (t1) fT added
reflexive, allows PDA read empty role chain; example, axiom
(2) introduces -transition iP fP . Moreover, -transition type (t2)
fT added transitive, allows PDA read number role
chains 1 , . . . , n L(T ); example, axiom (3) introduces -transition fT
. Transitions types (ur), (u1), (u2) analogously reflect properties >r :
(ur) allows PDA read arbitrary role, (u1) (u2) reflect reflexivity
transitivity >r , respectively. None transitions affect PDAs stack.
illustrate transitions type (t4), next show how, 1 = P S, PDA PS
determines 1 L(S); latter ensured axiom (4). assume PDA PS
state stack. Due axiom (4), PS make -transition type (t4)
state iP , pushing i>r fS stack. Since new state iP , PDA next need
read P ; furthermore, stack content signals PDA that, finishes reading
P , move state i>r read >r state fS finish reading S. Indeed,
PS make transition type (r) state fP read P , followed -transition
type (p) state i>r popping i>r stack; next, PDA make transition
660

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

type (ur) state f>r reading S, followed -transition type (p) state fS popping
fS stack. point, PDA accepts input.
illustrate transitions types (t3) (t5), next show how, 2 = P , PDA
PS determines 2 L(S); latter ensured axioms (5) (6). Again, assume
PDA PS state stack. PDA PS make transition type
(r) state fS , reading leaving stack unchanged; next, due axiom (5), PS
make -transition type (t5) state , pushing fS stack. Due axiom (6),
PDA PS next make -transition type (t3) state iP , pushing stack;
point, stack contains fS . Next, PDA make transition type
(r) state fP reading P , -transition type (p) state popping
stack; furthermore, analogous way, PDA move state fT reading
leaving fS stack. Finally, PDA make -transition type (p) state
fS popping fS stack. point, PDA accepts input.
understand benefit using PDAs rather FAs, note PS reaches state iP
recognising 1 2 . Role P occurs axioms (4) (6), PS moves
state iP order read occurrence P , must remember two
axioms caused move knows continue reading P : 1 , PS must
continue reading >r , whereas 2 , must continue reading . Unlike FAs Horrocks
Sattler (2004) remember information copying states, PS remembers
information stack: 1 , reaches iP i>r fS stack, whereas 2 ,
PS reaches iP fS stack. Thus, stack PS analogous stacks
programming languages: stack symbols correspond return addresses, transitions
type (p) correspond return statements.
following proposition immediate definition PDA PS .
Proposition 7. PDA PS computed time polynomial |R|.
following theorem states PDA PS accepts L(S) PS stack bounded
size R. proof result given Section 3.1.
Theorem 8. role R role chain ,
1. L(PS ) L(S),
2. PS stack bounded 2 lv(S) + 1.
Theorem 8 gives rise following notion depth RBox R, provide us
global bound stack size PDAs encoding R.
Definition 9. depth RBox R defined dR := maxSR (2 lv(S) + 1).
Finally, outline bounded-stack encoding regular RBoxes reduce
space used tableau algorithm SROIQ. Since ELRO+ support inverse
roles, Definition 4 directly provide us encoding languages induced
SROIQ RBoxes. Nevertheless, extend construction completing
RBox R inv(Sn ) inv(S1 ) v inv(S) R role inclusion S1 Sn v
RBox, inv() maps role inverse. One check that, (inverse) role
661

fiStefanoni, Motik, Krotzsch, & Rudolph

S, PDA PS constructed using completed RBox R encodes FS . Then, modify
portion tableau algorithm responsible checking satisfaction universal
restrictions running bounded-stack PDA graph constructed tableau
procedure. Roughly speaking, universal restriction S.C labelling vertex, run
PS graph updating current state stack PS , label
reachable vertex current state stack PS final concept C. Since
PS stack size polynomial |R|, requires polynomial space, unlike
FAs Horrocks Sattler (2004) optimised encoding Simanck (2012),
may require exponential space.
3.1 Proof Correctness
section, prove Theorem 8. Towards goal, let ` derivation relation
w.r.t. transition function R ; furthermore, derivation step hs, , ` hs0 , 0 , 0 i,
write hs, , `x hs0 , 0 , 0 hs0 , 0 , 0 obtained hs, , applying
transition form (x) Definition 4 x {r, t1, . . . , t5, ur, u1, u2, p}.
3.1.1 Soundness Stack Boundedness
section, prove that, role R role chain ,
1. L(PS ) implies L(S),
2. PS stack bounded 2 lv(S) + 1.
end, first show PDA PS satisfies following liveness property:
computation PS pushes state QR stack, PS eventually pop
stack. Then, show derivation PS moving state state fS takes
one five forms; call derivations regular. Finally, show regular derivations
satisfy properties (1) (2).
start showing PDA PS satisfies following liveness property.
Lemma 10. Let hs0 , 0 , 0 ` ` hsn , n , n arbitrary derivation
s0 = , sn = fS , 0 = role R word R . Then,
role lv(T ) < lv(S) [0..n] si {iT , fT } = s0i i0
s0i QR , index j [i..n] exists
(a) sj = fT j = ;
(b) k [i..j], word k form k := k00 k00 R ; and,
(c) sj+1 = s0i , j+1 = i0 , j+1 = j .
Proof. Let hs0 , 0 , 0 ` ` hsn , n , n above, [0..n 1], let
xi {r , t1 , . . . , t5 , ur , u1 , u2 , p} form derivation step ithat is, fix xi (arbitrarily one possibility) hsi , , `xi hsi+1 , i+1 , i+1
holds. Furthermore, role lv(T ) < lv(S), let set containing
index [0..n] si {iT , fT } form := s0i i0 s0i QR .
Note that, index , due lv(T ) < lv(S), si {iT , fT }, sn = fS ,
662

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

< nthat is, hsi , , ` hsi+1 , i+1 , i+1 occurs derivation. Next,
induction N, show that, role = lv(T ) < lv(S) ,
j [i..n] exists satisfying properties (a)(c).
Base case (). Consider arbitrary role R 0 = lv(T ) < lv(S).
consider interesting case 6= ; otherwise, properties (a)(c) hold vacuously.
Since lv(T ) = 0 si {iT , fT }, xi {r , t1 , t2 , ur , u1 , u2 , p}. reverseinduction (i.e., induction starting maximal element), next show
index satisfies required properties.
Base case. Let = max . xi {r , t1 , t2 , ur , u1 , u2 }, si+1 {iT , fT }
i+1 = ; thus, + 1 , contradicts maximality i.
remaining possibility xi = p, implies si = fT , si+1 = s0i , i+1 = i0 ,
i+1 = ; then, j = satisfies properties (a)(c).
Inductive step. Consider arbitrary index properties (a)(c) hold
` ` > i. xi {r , t1 , t2 , ur , u1 , u2 }, si+1 {iT , fT } i+1 = ;
hence, ii+1 so, inductive hypothesis, index j exists satisfying properties
(a)(c). Otherwise, xi = p, si = fT , si+1 = s0i , i+1 = i0 , i+1 = , j =
satisfies properties (a)(c).
Inductive Step (). Consider arbitrary N properties (a)(c) hold
role P R lv(P ) lv(P ) < lv(S) index IP . Furthermore,
consider arbitrary role + 1 = lv(T ) < lv(S). consider interesting
case 6= ; otherwise, properties (a)(c) hold vacuously. Recall
v 0 R 0 6= >r , lv(>r ) = 0 6= >r . Thus,
xi 6 {ur , u1 , u2 }. reverse-induction , next show index satisfies
required properties.
Base case (). Let = max . xi {r , t1 , t2 }, si+1 {iT , fT } i+1 = ;
thus, + 1 , contradicts maximality i. xi {t3 , t4 , t5 },
si+1 {iP , fP } role P lv(P ) < lv(T ) lv(P ) < lv(S); furthermore,
00 {i , f } 00
i+1 form i+1 := i+1




i+1 sequence
00
zero one states. state occurring i+1
{iR , fR } role
R level less . then, inductive hypothesis (), index ` > exists
s` = sT ` = , contradicts maximality i. Finally, xi = p,
si = fT , si+1 = s0i , i+1 = i0 , i+1 = , j = satisfies properties (a)(c).
Inductive step (). Consider arbitrary index properties (a)(c) hold
index ` ` > i, consider possible forms xi .
xi {r , t1 , t2 }. Then, si+1 {iT , fT } i+1 = , + 1 . inductive
hypothesis (), index j exists satisfying properties (a)(c).
xi = t3 . Then, si+1 = iT1 i+1 = role T1 lv(T1 ) < lv(T ).
Thus, + 1 IT1 . inductive hypothesis (), index ` [i + 1..n] exists
s` = fT1 ` = i+1 ; furthermore, k [i + 1..`], k
form k := k00 i+1 word k00 R ; finally, s`+1 = `+1 = .
definition , ` + 1 . inductive hypothesis (),
index j exists satisfying properties (a)(c).
663

fiStefanoni, Motik, Krotzsch, & Rudolph

xi = t4 . Then, si+1 = iT1 i+1 = iT2 fT roles T1 T2
lv(T1 ) < lv(T ) lv(T2 ) < lv(T ). Thus, + 1 IT1 . inductive hypothesis
(), index `1 [i + 1..n] exists s`1 = fT1 `1 = i+1 ; furthermore,
k [i..`1 ], k form k := k00 i+1 word k00 R ;
finally, s`1 +1 = iT2 `1 +1 = fT . Then, `1 + 1 IT2 . Again, inductive
hypothesis (), index `2 [`1 + 1..n] exists s`2 = fT2 `2 = `1 +1 ;
furthermore, k [`1 + 1..`2 ], k form k := k00 `1 +1
word k00 R ; finally, s`2 +1 = fT `2 +1 = . definition ,
`2 + 1 . So, inductive hypothesis (), index j exists satisfying
properties (a)(c).
xi = t5 . Then, si+1 = iT2 i+1 = fT role T2 lv(T2 ) < lv(T ).
Then, + 1 IT2 . inductive hypothesis (), index ` [i + 1..n] exists
s` = fT2 ` = i+1 ; k [i..`], k form
k := k00 i+1 word k00 R ; finally, s`+1 = fT `+1 = .
definition , ` + 1 . So, inductive hypothesis (),
index j exists satisfying properties (a)(c).
xi = p. Then, si = fT , si+1 = s0i , i+1 = i0 , i+1 = . Therefore, j = satisfies
properties (a)(c).
Next, role R , define notion regular derivations PS .
Definition 11. set regular derivations P>r inductively defined follows,
role R , role chain R , R .
sequr hi>r , 0 , `ur hf>r , 0 , regular derivation P>r .
sequ1 hi>r , 0 , `u1 hf>r , 0 , regular derivation P>r .
sequ2 hi>r , 0 , ` ` hf>r , k , hi>r , k , ` ` hf>r , n , regular derivations P>r , following regular derivation P>r .
hi>r , 0 , ` ` hf>r , k , `u2 hi>r , k , ` ` hf>r , n ,
Next, consider arbitrary natural number N assume regular derivations
PT already defined = >r role R \ {>r } lv(T ) m.
Then, role R \ {>r } lv(S) = + 1, regular derivations PS defined
follows, S(i) R , R , R .
seqr , 0 , `r hfS , 0 , regular derivation PS .
seqt1 v R, , 0 , `t1 hfS , 0 , regular derivation PS .
seqt2 v R , 0 , ` ` hfS , k , , k , ` ` hfS , n ,
regular derivations PS , following regular derivation PS .
, 0 , ` ` hfS , k , `t2 , k , ` ` hfS , n ,

664

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

seqt3 S1 v R, hiS1 , 0 , ` ` hfS1 , k , regular derivation
PS1 , , k , ` ` hfS , n , regular derivation PS , following
regular derivation PS .
, 0 , `t3 hiS1 , 0 , ` ` hfS1 , k , `p , k , ` ` hfS , n ,
seqt4 S1 S2 v R, hiS1 , 0 , iS2 fS ` ` hfS1 , k , iS2 fS regular derivation PS1 , hiS2 , k , fS ` ` hfS2 , n , fS regular derivation PS2 ,
following regular derivation PS .
, 0 ,
hiS1 , 0 , iS2 fS
fS
hiS2 , k ,
hfS , n ,

`t4
` ` hfS1 , k , iS2 fS `p
fS `p
` ` hfS2 , n ,


seqt5 S2 v R, , 0 , ` ` hfS , k , regular derivation PS ,
hiS2 , k , fS ` ` hfS2 , n , fS regular derivation PS2 , following regular derivation PS .
, 0 , ` ` hfS , k , `t5 hiS2 , k , fS ` ` hfS2 , n , fS `p hfS , n ,
left show derivation PS moves PDA start state
final state fS regular regular derivations satisfy required properties.
following lemma, show derivations leave particular word
bottom stack regular satisfy properties (1) (2). Subsequently,
show accepting derivation PS form.
Lemma 12. role R , word R , derivation form
hs0 , 0 , 0 ` ` hsn , n , n s0 = , sn = fS , 0 = ,
(i) derivation regular PS ;
(ii) [0..n], |i | 2 lv(S);
(iii)
= 0 n .
Proof. prove claim induction n N+ .
Base case. n = 1, consider arbitrary role R , word R , sequence
, 0 , 0 ` hfS , 1 , 1 i. Definition 4, transitions cases (r), (t1), (ur),
(u1) move PS state state fS . transitions leave stack untouched,
1 = = 0 property (ii) holds. properties (i) (iii), next consider
four different forms sequence may take.
, 1 , 0 `r hfS , 1 , 1 i. 6= >r , regular derivation
PS case seqr (i) holds. Finally, 0 1 = S, implies =
0 1 ,
(iii) holds.
665

fiStefanoni, Motik, Krotzsch, & Rudolph

, 0 , 0 `t1 hfS , 0 , 1 i. 6= >r , regular derivation PS
case seqt1 (i) holds. Finally, 0 1 = ; moreover, case t1 Definition 4,
v R, =
; hence, =
0 1 (iii) holds.
, 1 , 0 `ur hfS , 1 , 1 i. = >r R , regular
derivation P>r case sequr (i) holds. Finally, 0 1 = R ,
implies =
0 1 , (iii) holds.
, 0 , 0 `u1 hfS , 0 , 1 i. = >r , regular derivation P>r
case sequ1 (i) holds. Finally, 0 1 = ; hence, =
, (iii) holds.
Inductive step. Consider arbitrary n N+ assume (i)(iii) hold
role 0 R , word 0 R , derivation hs00 , 00 , 00 0 ` ` hs0c , 0c , c0 0
length n form required lemma. Furthermore, consider
arbitrary role R , arbitrary word R , arbitrary derivation
hs0 , 0 , 0 ` ` hsn+1 , n+1 , n+1

(7)

length n + 1 s0 = , 0 = , sn+1 = fS . [0..n 1], let
xi {r , t1 , . . . , t5 , ur , u1 , u2 , p} form derivation step ithat is, fix xi (arbitrarily one possibility) hsi , , `xi hsi+1 , i+1 , i+1
holds. next consider possible forms sequence might have, show
properties (i)(iii) hold case.
(Case 1) = >r . consider form hs0 , 0 , 0 `x0 hs1 , 1 , 1 i. Since
s0 = i>r , x0 {t1 , t3 , t4 , ur , u1 }. R normalised, v 0 R
0 6= >r , x0 {ur, u1} s1 = f>r 1 = = 0 . Since n > 1,
hs1 , 1 , 1 `x1 hs2 , 1 , 2 occurs sequence x1 {t2 , t5 , u2 , p}. Since
s1 = f>r R normalised, x1 {u2 , p}; furthermore, since 1 =
assumption form (7), x1 6= p. Hence, remaining possibility
x1 = u2 . case (u2) Definition 4, s2 = i>r , 2 = 1 , 2 = 1 .
next prove properties (i)(iii) hold.
(i) sequr sequ1 , hs0 , 0 , 0 `x0 hs1 , 1 , 1 regular derivation P>r .
inductive hypothesis, hs2 , 2 , 2 ` ` hsn+1 , n+1 , n+1 regular
derivation PS . definition regular derivations, n = 2 = .
then, (7) regular derivation PS case sequ2 .
(ii) Words 0 , 1 , 2 empty. inductive hypothesis, |` | 2 lv(>r )
` [2..n + 1]. Therefore, |i | 2 lv(>r ) holds [0..n + 1].
(iii) inductive hypothesis, >r =
2 n+1 . cases (ur) (u1), either
0 2 = 0 2 = R . then, >r
= 0 n+1 holds.
(Case 2) 6= >r k [0..n] exists hsk , k , k `t2 hsk+1 , k+1 , k+1
sk = fS . Then, case (t2) Definition 4, v R, sk+1 = , k+1 = k ,
k+1 = k . next prove properties (i)(iii) hold.

666

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

(i) inductive hypothesis, hs0 , 0 , 0 ` ` hsk , k , k regular derivation
PS . definition regular derivations, k = 0 = . Since sk+1 =
k+1 = k = , hsk+1 , k+1 , k+1 ` ` hsn+1 , n+1 , n+1
form shown (7) shorter n + 1 so, inductive hypothesis,
regular derivation PS . Then, (7) regular derivation PS case seqt2 .
(ii) inductive hypothesis, |`1 | 2 lv(S) `1 [0..k], well
|`2 | 2 lv(S) `2 [k + 1..n + 1]. Therefore, |i | 2 lv(S) holds
[0..n + 1].
(iii) inductive hypothesis, =
0 k =
k+1 n+1 . then,

v R k+1 = k implies =
0 n+1 holds.
(Case 3) 6= >r ` [0..n] exists hs` , ` , ` `t2 hs`+1 , `+1 , `+1
s` = fS , k [0..n] exists hsk , k , k `t5 hsk+1 , k+1 , k+1
sk = fS . Then, let k largest indexthat is, assume > k exists
hsm , , `t5 hsm+1 , m+1 , m+1 sm = fS . Then, case (t5)
Definition 4, role S2 level less S, S2 v R, sk+1 = iS2 ,
k+1 = k , k+1 = fS k . next prove properties (i)(iii) hold.
(i) Since sk = fS , inductive hypothesis hs0 , 0 , 0 ` ` hsk , k , k
regular derivation PS . Definition 12, k = 0 . Since sk+1 = iS2
k+1 = fS 0 , Lemma 10, index j [k + 1..n] exists sj = fS2
j = k+1 ; furthermore, sj+1 = fS j+1 = 0 j+1 = j . prove
j + 1 = n + 1. sake contradiction, assume j + 1 < n + 1 consider
form transition hsj+1 , j+1 , j+1 `xj +1 hsj+2 , j+2 , j+2 i. Given
sj+1 = fS 6= >r , must xj+1 {t2 , t5 , p}. initial assumption,
xj+1 6= t2 ; furthermore, maximality k, xj+1 6= t5 ; finally,
since j+1 = 0 = , xj+1 6= p. Thus, j + 1 = n + 1, required. follows
sequence following form, k+1 = k n+1 = n .
, 0 ,
0 ` ` hfS , k , 0 `t5
hiS2 , k+1 , k+1 ` ` hfS2 , n , n `p
hfS , n+1 , 0
Lemma 10, ` [k + 1..n], ` form ` = `00 fS 0 .
00
particular, words k+1
n00 empty. Then, inductive hypothesis,
hiS2 , k+1 , k+1 ` ` hfS2 , n , n regular derivation PS2 .
case seqt5 , (7) regular derivation PS .
(ii) inductive hypothesis, `1 [0..k], |`1 | 2 lv(S). Furthermore, `2 [k + 1..n], |`002 | 2 lv(S2 ). Since lv(S2 ) < lv(S)
`2 = `002 fS , |`2 | 2 lv(S). Given n+1 = ,
[0..n + 1], |i | 2 lv(S).
(iii) inductive hypothesis, =
0 k S2 =
k+1 n . Given

=
S2 , k+1 = k , n+1 = n , obtain =
0 n+1 .

667

fiStefanoni, Motik, Krotzsch, & Rudolph

(Case 4) 6= >r ` [0..n] exists hs` , ` , ` `x` hs`+1 , `+1 , `+1 i,
s` = fS x` {t2 , t5 }; hs0 , 0 , 0 `t3 hs1 , 1 , 1 i. Then, case (t3) Definition 4, role S1 level less S, S1 v R, s1 = iS1 ,
1 = 0 , 1 = 0 . next prove properties (i)(iii) hold.
(i) Since s1 = iS1 1 = 0 , Lemma 10, j [1..n] exists sj = fS1
j = 1 ; furthermore, sj+1 = j+1 = 0 j+1 = j . Then, sequence
following form, 1 = 0 .
, 0 ,
0 `t3
j `p
1 ` ` hfS1 , j ,
hiS1 , 1 ,
, j+1 , j+1 ` ` hfS , n+1 , n+1
Lemma 10, ` [1..j], ` form ` = `00 0 .
particular, words 100 j00 empty. inductive hypothesis,
hiS1 , 0 , 1 ` ` hfS1 , j , j regular derivation PS1 . Since j+1 = 0 ,
inductive hypothesis, , j+1 , j+1 ` ` hfS , n+1 , n+1
regular derivation PS . case seqt3 , (7) regular derivation PS .
(ii) inductive hypothesis, `2 [j + 1..n + 1], |`2 | 2 lv(S);
furthermore, `1 [1..j], |`001 | 2 lv(S1 ). Since lv(S1 ) < lv(S)
`1 = `001 , |`1 | 2 lv(S). Finally, since 0 = ,
[0..n + 1], |i | 2 lv(S).
(iii) inductive hypothesis, S1 =
1 j =
j+1 n+1 .
Given =
S1 S, 1 = 0 , j+1 = j , =
0 n+1 .
(Case 5) 6= >r ` [0..n] exists hs` , ` , ` `x` hs`+1 , `+1 , `+1 i,
s` = fS , x` {t2 , t5 }; addition, hs0 , 0 , 0 `x0 hs1 , 1 , 1 x0 6= t3.
next consider remaining possibilities x0 . s0 = , x0 6 {t2 , t5 , u2 , p}
cases (t2), (t5), (u2), (p) Definition 4; furthermore, due 6= >r ,
x0 6 {ur , u1 } cases (ur) (u1) Definition 4. Moreover, assume x0 {r , t1 };
then, s1 = fS 1 = 0 cases (r) (t1) Definition 4; since n > 1
6= >r , possibility hs1 , 1 , 1 `p hs2 , 2 , 2 i, impossible
due 1 = assumption form (7). Hence, remaining possibility
x0 = t4 . case (t4) Definition 4, roles S1 S2 level less
S, S1 S2 v R, s1 = iS1 , 1 = 0 , 1 = iS2 fS 0 . next prove
properties (i)(iii) hold.
(i) Since s1 = iS1 1 = iS2 fS 0 , Lemma 10, j1 [1..n] exists sj1 = fS1
j1 = 1 ; furthermore, sj1 +1 = iS2 j1 +1 = fS 0 j1 +1 = j1 . Again,
Lemma 10, j2 [j1 + 1..n] exists sj2 = fS2 j2 = j1 +1 ; furthermore,
sj2 +1 = fS j2 +1 = 0 j2 +1 = j2 . Next, prove j2 + 1 = n + 1.
sake contradiction, suppose j2 + 1 < n + 1 consider form
hsj2 +1 , j2 +1 , j2 +1 `xj2 +1 hsj2 +2 , j2 +2 , j2 +2 i. Given sj2 +1 = fS ,
must xj2 +1 {t2 , t5 , u2 , p}. However, assumed xj2 +1 6 {t2 , t5 }
6= >r , xj2 +1 6= u2 ; finally, since j2 +1 = 0 = , xj2 +1 6= p.
668

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Therefore, j2 + 1 = n + 1, required, sequence following
form, 1 = 0 , j1 +1 = j , n+1 = n .
, 0 ,
0 `t4
hiS1 , 1 ,
1 ` ` hfS1 , j1 , j1 `p
hiS2 , j1 +1 , j1 +1 ` ` hfS2 , n , n `p
hfS , n+1 , n+1
Lemma 10, `1 [1..j1 ], word `1 form `1 = `001 iS2 fS 0 .
particular, words 100 j001 empty. Then, inductive hypothesis,
hiS1 , 1 , 1 ` ` hfS1 , j1 , j1 regular derivation PS1 .
Similarly, Lemma 10, `2 [j1 + 1..n], `2 form
`2 = `002 fS 0 . particular, words j001 +1 n00 empty. Then,
inductive hypothesis, hiS2 , j1 +1 , j1 +1 ` ` hfS2 , n , n
regular derivation PS2 . case seqt4 , (7) regular derivation PS .
(ii) inductive hypothesis, `1 [1..j1 ], |`001 | 2 lv(S1 ). Since
lv(S1 ) < lv(S) `1 = `001 iS2 fS , |`1 | 2 lv(S). Similarly,
inductive hypothesis, `2 [j1 + 1..n], |`002 | 2 lv(S2 ). Since
lv(S2 ) < lv(S) `2 = `002 fS , |`2 | 2 lv(S). Since 0 = ,
[0..n + 1], |i | 2 lv(S).
(iii) inductive hypothesis, S1 =
1 j1 S2 =
j1 +1 n . Given

=
S1 S2 , 1 = 0 , n+1 = n , conclude =
0 n+1 .
possibilities form (7), claim lemma holds
derivation form.
finally ready show PDA PS satisfies properties (1) (2).
Lemma 13. role R role chain ,
1. L(PS ) implies L(S),
2. PS stack bounded 2 lv(S) + 1.
Proof. definition PS , transitions resulting case p Definition 4
ones popping elements stack, never pop symbol ; hence, point
accepting derivation PS , stack content form := i0 . Then,
two claims follow immediately Lemma 12.
3.1.2 Completeness
next prove encoding complete, thus proving Theorem 8.
Lemma 14. role R role chain , L(S) implies
L(PS ).

669

fiStefanoni, Motik, Krotzsch, & Rudolph

Axiom Type
(t1)
vT
(t2)

(t3)

(t4)

(t5)

Derivation
`t1 hfT ,

00

hiT ,

,

vT

hiT ,
hiT ,

00 ,
00 ,

T1 v

hiT , T1 00 ,
hiT1 , T1 00 ,
hiT ,
00 ,

T1 T2 v

hiT , T1 T2 00 ,
hiT1 , T1 T2 00 , iT2 fT
hiT2 ,
T2 00 ,
fT
00
hfT ,
,

T2 v

hiT , T2 00 ,
hiT2 ,
T2 00 ,
hfT ,
00 ,




`r
`r

`t3
` r
`r
`t4
` r
` r


`r
fT ` r


00 ,



hfT , 00 ,
hfT ,
00 ,




`t2

hfT1 , 00 ,
hfT ,
00 ,




`p

hfT1 , T2 00 , iT2 fT `p
hfT2 ,
00 ,
fT ` p
hfT , T2 00 ,
hfT2 ,
00 ,

`t5
fT ` p

Table 4: Definition derivation (9) depending form axiom v .
Proof. Consider arbitrary role R . following, role chain , write
0

=
= S; furthermore, N+ , write =
role chains 1 , . . . ,
exist =
1 =
=
= . definition L(S),

L(S) natural number N exists =
. induction

N, next show =
implies L(PS ).
0

Base case. Let = 0. Then, =
S. consider two cases depending
form role R .
= >r . case (ur) Definition 4, hi>r , >r , `ur hf>r , , i.
R \ {>r }. case (r) Definition 4, , S, `r hfS , , i.
either case L(PS ), required.
Inductive step. Consider arbitrary N assume that, role chain 0

=
0 , 0 L(PS ); show holds + 1. Then,
consider arbitrary role chains 1 , . . . , m+1 =
1 =
=
=
m+1 .
definition relation =
, role R role chains 0 , , 00 exist role chain
form := 0 00 , role chain m+1 form m+1 := 0 00 ,

=
. Since =
0 00 , inductive hypothesis, 0 00 L(PS ),
sequence hs0 , 0 , 0 ` ` hsn , n , n PS exists s0 = sn = fS ; furthermore,
0 = n = ; finally, 0 = 0 00 n = . exists index
[0..n 1] = 00 i+1 = 00 . Furthermore, j [0..i], role chain


00
j form j :=
j role chain j R . Next, consider form
xi hsi , , `xi hsi+1 , i+1 , i+1 i. Definition 4, transitions cases (r) (ur)
read symbols input, xi {r, ur}. show lemma holds case.
670

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

(Case 1) Consider case xi = r . Then, si = si+1 = fT ,
= i+1 , R \ {>r }. Due =
6= >r , v R. Then,
following derivation PS

00
00

hs0 ,
0 , 0 ` ` hsi , , `

(8)



(9)

[The derivation Table 4 v ] `
00

hsi+1 , , i+1 ` ` hsn , , n

(10)

derivation (9) defined Table 4 depending form axiom v R.
(Case 2) Consider case xi = ur . Then, si = i>r si+1 = f>r ,
= i+1 R . Then, following derivation PS

00
00

hs0 ,
0 , 0 ` ` hsi , , `
00

[The derivation seq(, , ) (14)] `



00

hsi+1 , , i+1 ` ` hsn , , n
derivation seq(, 0 , ) (12) inductively defined follows.
(
hi>r , 00 , `u1 hf>r , 00 ,
= ,
00
seq(, , ) :=
00
00
00
hi>r , , `ur hf>r , , `u2 seq(, , ) = P .

(11)
(12)
(13)

(14)

Therefore, either case, 0 00 L(PS ), required.

4. Polynomial Space BCQ Answering Algorithm ELRO+
ELRO+ knowledge base K translated set first-order Horn clauses,
Boolean CQ q K answered evaluating q so-called canonical model
model homomorphically embedded model K. Canonical
models usually obtained using chase. Many different chase variants studied
literature, producing different, homomorphically equivalent, canonical
model (Johnson & Klug, 1984; Marnette, 2009; Cal, Gottlob, & Kifer, 2013; Baget, Leclere,
Mugnier, & Salvat, 2011). paper, introduce variant call consequencebased chase, (possibly infinite) set assertions IK produces K call
universal interpretation K. compute IK , consequence-based chase initialises IK
contain ABox K, well assertions {a}(a), >c (a), >r (a, b) individuals
b occurring K; then, iteratively extends IK using chase rules. slightly unusual
aspect chase variant considers axioms entailed (and contained
in) K. example, IK point contains assertion A(w) K |= v S.B holds,
IK extended assertions S(w, w0 ) B(w0 ) w0 fresh term; term w0
said auxiliary type S, B concept type B. BCQ answering algorithm
present section based checking consequences K, chase variant
makes proofs simpler. Example 15 illustrates aspects.
Example 15. Let K = hT , R, ELRO+ KB, contains axioms (15)(21),
R contains role inclusion (22).
{a} v S.A
671

(15)

fiStefanoni, Motik, Krotzsch, & Rudolph



b





1 S,

2 S,






3 T, B

R



b

6 S, B







4 S, C

oS,A







oT,B

oS,B

R




oS,C



S,

S,

5
T, B

Universal Interpretation

Compact Interpretation

Figure 4: universal interpretation compact interpretation K
v S.A

(16)

{b} v S.A

(17)

{b} v T.B

(18)

{b} v S.C

(19)

C v T.B

(20)

C v R.{b}

(21)

ST vS

(22)

Figure 4 shows universal interpretation IK K. Assertions involving >c >r
shown clarity. edges obtained via role inclusions dashed; remaining edges
solid, apart dotted edges, denote repetition solid edges. Black edges
obtained using conventional chase variants, whereas light grey subbranches IK
caused axioms entailed by, occurring in, K. Auxiliary terms labelled
using integers, terms type shown next term. Universal interpretation IK
viewed family directed trees whose roots individuals K
solid edges point parents children individuals K. Axiom (16) makes IK
infinite, decision procedure BCQ answering cannot simply materialise IK
evaluate query it; instead, finitary representation IK needed.
axioms (19), (20), (22), K |= {b} v S.B; then, since {b}(b) IK ,
consequence-based chase ensures {S(b, 6), B(6)} IK holds well. contrast,
commonly considered chase variants ensure {S(b, 6), B(6)} IK K
contain axiom {b} v S.B.
rest section, present first worst-case optimal algorithm decides
K |= q given arbitrary regular ELRO+ KB K Boolean CQ q K. Towards
goal, Section 4.1 review existing approaches answering CQs DLs discuss
672

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

techniques provide optimal procedure ELRO+ ; Section 4.2
discuss intuitions behind algorithm; Section 4.3 introduce algorithm
formally show runs polynomial space combined size K q
polynomial time size K; Section 4.4 prove algorithms correctness.
4.1 Existing Approaches Answering CQs
Techniques answering conjunctive queries DL knowledge bases developed thus far
broadly classified following three groups.
first group consists automata-based approaches DLs Horn-SHIQ
Horn-SROIQ (Ortiz et al., 2011), SH (Eiter, Ortiz, & Simkus, 2012a), fragment ELRO+ obtained disallowing universal role, reflexive roles, self restrictions (Krotzsch et al., 2007). techniques, however, require constructing automata
whose size exponential size knowledge base.
second group consists rewriting-based approaches. Roughly speaking, approaches rewrite query and/or TBox another formalism, usually union
CQs datalog program; relevant answers obtained evaluating
rewriting ABox. Rewriting-based approaches proposed members
DL-Lite family (Artale et al., 2009; Calvanese et al., 2007), DLs EL (Rosati,
2007), ELHIO (Perez-Urbina et al., 2010; Mora, Rosati, & Corcho, 2014) HornSHIQ (Eiter, Ortiz, Simkus, Tran, & Xiao, 2012b), members datalog family (Virgilio, Orsi, Tanca, & Torlone, 2012), name few. rewriting approach,
however, supports nominals role inclusions. Moreover, common shortcoming
rewritings exponential query and/or TBox size, approaches
may use exponential space.
third group consists approaches based particular interpretation K
call compact interpretation. Figure 4 shows interpretation KB K
Example 15: finitely approximates universal interpretation using individuals
form oS,B represent auxiliary terms type S, B. compact interpretation thus
materialised space polynomial |K|, used answer instance queries
test atomic subsumptions K (Baader et al., 2005; Krotzsch, 2011). Materialising
compact interpretation lies core many reasoning algorithms EL variants,
natural try use interpretation answering CQs well. Since compact
interpretation model K, CQ maps universal interpretation maps
compact interpretation well; however, Example 16 shows, converse
necessarily hold.
Example 16. Let K Example 15, let q1 , q2 , q3 following BCQs.
q1 = x. R(x, b)

q2 = x. S(a, x) S(b, x)

q3 = x. (b, x) S(b, x)

compact interpretation K shown Figure 4; one see, obtained
universal interpretation merging terms type S, B onto individual oS,B .
query q1 mapped onto compact universal interpretation, queries
q2 q3 mapped onto compact interpretation. Thus, evaluating q2 q3
compact interpretation produces unsound answers.
673

fiStefanoni, Motik, Krotzsch, & Rudolph



b

{a}

b {b}

Ax

B

R
R,D 1



T,B
3




S,B 5


R





R,A
2






4 T,B






T,B
6

P





T,B



7


8 S,B





P,B 9






T,B 10

Universal Interpretation


11 S,B



z B

Skeleton q

Figure 5: universal interpretation K skeleton q
remedy, combined approaches developed first evaluate query
compact interpretation filter results eliminate unsound answers.
approaches developed members DL-Lite family (Kontchakov et al.,
2011; Lutz, Seylan, Toman, & Wolter, 2013) EL family (Lutz, Toman, & Wolter,
2009; Stefanoni et al., 2013) DLs, datalog family (Gottlob, Manna, & Pieris,
2014) rule-based languages. particular, Stefanoni et al. (2013) developed filtering
step applicable DL ELHOdr
, step breaks K contains role inclusions.
Query q3 Example 16 mapped onto compact interpretation mapping
atom S(b, x) dashed edge (i.e., edge obtained via role inclusions); moreover, q3
tree-shaped, filtering step Stefanoni et al. (2013) identify
match unsound. problem intuitively understood follows. unfolding
query (22), query q3 essentially asks whether role chains 1 L(S) 2 L(T )
exist label path solid edges IK starting b. compact interpretation,
satisfied 1 = 2 = x mapped individual oT,B . Individual
oT,B , however, represents distinct terms 3 5 IK ; hence, although 3 connected
b via 1 5 connected b via 2 , role chains 1 2 satisfy query q3 .
words, compact interpretation small represent relevant conditions.
4.2 Intuitions
worst-case optimal procedure BCQ answering ELRO+ shown Algorithm 1
page 681. essentially extends refines algorithm Krotzsch et al. (2007).
explain underlying intuitions using knowledge base shown Example 17.
Example 17. Let K ELRO+ knowledge base whose TBox contains axioms (23)(29)
whose RBox contains role inclusions (30)(31).
{a} v R.A
v T.{b}
674

(23)
(24)

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs



S, X/X

fS

, X/fS X



T, X/X

fT

, X/X

Figure 6: transitions R corresponding axioms (30)(31)
AvD

(25)

{b} v T.B

(26)

{b} v P.B

(27)

B v S.Self

(28)

B v T.B

(29)

vT

(30)

ST vS

(31)

Moreover, let q following Boolean CQ K.
q = x, y, z. D(x) (x, z) S(y, z)

(32)

Figure 5 shows universal interpretation IK K; notation Example 15.
solid looping edges auxiliary terms concept type B obtained axiom (28). One
see K |= q holds; example, following substitution embeds q IK .
= {x 7 2, 7 6, z 7 7}

(33)

algorithm uses PDA encoding RBox described Section 3. transition
function R axioms (30)(31) shown Figure 6; notation Example 6;
note Figure 6 contained Figure 3.
must prove existence substitution mapping q IK . substitution
map binary atoms q dashed edges Figure 5. Dashed edges introduce
shortcuts terms IK , dashed edge unfolded path consisting
solid edges using role inclusions K. solid paths IK two
types: auxiliary paths involve auxiliary terms, whereas nominal paths require moving
least one individual. instance, edge (2, 7) unfolded path
= connecting 2 b, b 6, 6 7. contrast, edge S(6, 7)
unfolded path = connecting 6 itself, 6 7. algorithm
uses PDAs transition function Figure 6 represent binary atom
q sequence binary atoms mapped corresponding solid path IK .
Interpretation IK , however, infinite, space possible substitutions infinite.
Hence, prove existence substitution mapping q IK , cannot simply
enumerate them, use Algorithm 1 instead.
675

fiStefanoni, Motik, Krotzsch, & Rudolph

line 1 check whether K unsatisfiable; so, K |= q holds trivially. Next,
line 2 guess substitution continue checking K |= (q); thus, step takes
account variables could mapped individuals, two variables could
mapped term. example, guess identity mapping
~y . step 3, guess finite structure, called skeleton (q), represents
(possibly infinite) set substitutions mapping variables (q) distinct auxiliary
terms IK . Figure 5 shows skeleton query Example 17: skeleton vertices
individuals K variables (q), arranged forest whose
roots individuals; moreover, vertex v assigned atomic concept (v).
step, skeleton represents substitution (if any) satisfying following
two properties:
1. maps variable x term concept type (x),
2. edge hv, v 0 S, (v 0 ) descendant (v) IK .
next extend conditions prune set substitutions, goal
leaving substitutions compatible (q)that is, embed (q) IK .
establish compatibility unary atoms (q) line 4. particular, consider
atom D(x) (q). property (1), substitution represented skeleton
Figure 5 maps variable x term concept type (x) = A, implying A( (x)) IK
holds. then, since K |= (x) v holds, know D( (x)) IK holds well; thus,
atom D(x) satisfied substitution represented S.
contrast, cannot establish compatibility binary query atoms using entailment
checking only, vertex labels relative position vertices sufficiently
describe substitutions. example, substitution
1 = {x 7 2, 7 9, z 7 10}

(34)

satisfies properties (1) (2), (1 (x), 1 (z)) 6 IK .
prune substitutions, lines 516 Algorithm 1 guess binary atom
(q) unfold sequence solid steps IK . solid paths IK go
nominals auxiliary terms only, two possibilities accounted
guessing line 8. Moreover, skeleton already constrains relative positions
query terms, represent unfolding binary atom labelling edge hv, v 0
set L(v, v 0 ) bounded-stack PDAs transition function Figure 6
substitution represented satisfies following property:
3. PDA P L(v, v 0 ), nonempty role chain L(P) exists labelling path
IK solid edges (v) (v 0 ).
next illustrate label edges substitutions satisfying properties
(1)(3) compatible binary atom (q).
(x, z), must ensure that, substitution represented S, role chain
L(T ) exists connecting (x) (z) using solid edges. Since relative positions
(x) (z) IK determined shown Figure 5, path must connect
(x) b, connect b (y), finally connect (y) (z). addition,
assume individuals occur paths b (y), (y) (z):
676

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

>r


R

{a}

R

B




S,

T, P


{b}

start

B



start

Figure 7: left-hand side, walking finite automaton wfa(A, {b}) (transitions involving >c >r shown clarity); right-hand side, stationary finite automaton sfa(B)

path (x) (z) involves individuals b visits b once,
absorb path segments subpath (x) b. Thus, check
existence setting v0 = au = b lines 78 (no guessing possible line 8
case) splitting lines 711 path three subpaths. particular,
line 10 guess states s0 , s1 , s2 = fT line 11 guess stack words 0 , 1 ,
2 = following properties:
(i) subpaths (x) b described PDA PT0 whose start state stack
, respectively, final state stack s0 0 , respectively;
(ii) subpaths b (y) described PDA PT1 whose start state stack
s0 0 , respectively, final state stack s1 1 , respectively;
(iii) subpaths (y) (z) described PDA PT2 whose start state stack
s1 1 , respectively, final state stack s2 2 , respectively.
know terms IK variables z mapped to, cannot
check existence paths (ii) (iii) independently. Therefore, add line 12
PDAs PT1 PT2 constraints edges hb, yi hy, zi S, respectively. edges
thus accumulate constraints moves auxiliary terms must satisfy; later
shall explain lines 1718 check constraints and, check passes,
know map z auxiliary terms whose concept types (y)
(z), respectively. contrast, path (i) finishes individual,
check existence path independently constraint. end,
construct walking finite automaton wfa(A, {b}) shown left-hand side Figure
7. wfa(A, {b}) describes moves IK terms concept type (x) =
individual bthat is, L(wfa(A, {b})) term w concept type
role chain connecting w b IK via solid edges; then, line 14 check
whether intersection languages wfa(A, {b}) PT0 empty. wfa(A, {b})
FA PT0 PDA, test emptiness intersection languages
polynomial time (Hopcroft et al., 2003). example, guess s0 = s1 = s2 = fT .
677

fiStefanoni, Motik, Krotzsch, & Rudolph

Thus, PT1 accepts language , b connected 1 (y) solid edge
labelled P , adding PT1 constraint edge hb, yi ensures substitution 1 (34)
satisfy property (3).
S(y, z), must ensure that, substitution represented S, role chain
L(S) exists connecting (y) (z) using solid edges. even though z
descendant S, line 8 could guess v0 = au = b, connects (y) b
then, without going individuals, connects b (z) via (y). rest
paragraph, however, consider case connects (y) (z) directly,
since possibility example, one see Figure 5. Therefore,
line 8, guess v0 = = y. then, path (y) (z) could first loop (y)
due self-restrictions; must actually move (y) (z); finally could
loop (z). reasons discuss following paragraph, absorb latter loop
constraint added edge hy, zi; however, check existence former loop
independently. Therefore, lines 711 split two subpaths. particular,
line 10 guess states s0 s1 = fS , line 11 guess stack words 0 1 =
following properties:
(i) looping (y) described PDA PS0 whose start state stack
, respectively, final state stack s0 0 , respectively;
(ii) subpaths (y) (z) start move (y), possibly involve
looping (z), described PDA PS1 whose start state stack s0 0 ,
respectively, final state stack s1 1 , respectively.
previous case, check (ii) adding PS1 constraint edge hy, zi S.
Furthermore, check existence path (i) constructing stationary finite
automaton sfa(B) shown right-hand side Figure 7. sfa(B) describes
possible loops terms concept type (y) = B; is, L(sfa(B))
term w concept type B role chain corresponding (possibly
empty) loop w; then, line 16 check whether intersection languages
sfa(B) PS0 empty. example, guess s0 = s1 = fS ; thus PS0 accepts
language , whereas PS1 accepts language .
line 17, skeleton represents substitutions compatible
atoms (q), must still show least one substitution realised
universal interpretation IK . end, apply Algorithm 2 page 681
edge hv, v 0 skeleton, thus check whether terms (v) (v 0 ) IK exist
satisfy properties (1)(3) PDAs L(v, v 0 ). Roughly speaking, solve
problem running PDAs parallel lines 715 Algorithm 2. However, cannot
materialise IK , exploit property consequence-based chase procedure: term
w concept type connected term w0 concept type B IK using solid
edge labelled K |= v S.B. Furthermore, concept type w fully
describes solid paths descendants w, need keep track actual
position IK ; instead, use variable concept keep track current terms concept
type. Thus, line 9 check existence edges IK via entailment checking; that,
PDA, line 11 guess state stack PDA, line 12 check
whether PDA perform move, line 14 actually move PDA. Due
678

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

self-restrictions reflexive roles, however, PDAs need move synchrony:
move solid edge, PDAs independently loop current term.
end, line 11 guess state s0 stack 0 PDA moves
looping, line 13 check whether PDA move state stack
state s0 stack 0 using role chain compatible concept type term
PDA moving into, given stationary finite automaton sfa(D).
PDAs required loop, FA sfa(D) accepts empty word. Algorithm 2 thus checks
loops move, line 16 Algorithm 1 necessary. Lines 25
take account PDAs nondeterministic initially make
several -transitions; note explicit check -transitions required initially
since line 13 allows possible -transitions move along solid edge. Finally,
ensure termination Algorithm 2 observing that, since stack PDA L(v, v 0 )
bounded, number current configurations PDA exponential,
number distinct tuples current PDA configurations exponential well;
hence, algorithm repeats computations exponentially many steps.
thus obtain nondeterministic decision procedure running polynomial space using
binary counter stop computation distinct configurations explored.
constraints added previous paragraphs, one check Algorithm 2
returns true edges S; hence, K |= (q) holds, thus K |= q holds well.
4.3 Formalisation
formalise intuitions previous section. Towards goal, fix
normalised ELRO+ KB K = hT , R, Ai regular RBox R, let QR , R , R
specified Definition 4, let dR depth R specified Section 3.
start formalising notion skeleton Boolean CQ.
Definition 18. skeleton Boolean CQ q = ~y . (~y ) triple = hV, E,
following components.
1. V = IK ~y set vertices.
2. E V ~y set edges directed graph hV, Ei forest whose
roots precisely elements IK .
3. : ~y 7 {>c } CK function maps existential variables q atomic
concepts. convenience, extended V (v) := {v} v IK .
path nonempty sequence (distinct) vertices v0 , . . . , vn n 0 and,
[0..n 1], hvi , vi+1 E.
Please observe that, K normal form, exists least one individual occurring
K thus V 6= . next generalise notion PDA encoding RBox R
Definition 4 allowing arbitrary start final states well arbitrary start
final stacks size dR . generalised PDA used algorithm
implement splitting operation mentioned Section 4.2.
Definition 19. states s, s0 QR words , 0 R || dR | 0 | dR ,
generalised PDA R given pda(s, , s0 , 0 ) := hQR , R , R , R , s, , s0 , 0 i.
679

fiStefanoni, Motik, Krotzsch, & Rudolph

following definition introduces automata one use succinctly represent
axioms logically follow K.
Definition 20. Let B basic concepts. walking finite automaton
B given wfa(A, B) := hQ, R , w , A, Bi Q w follows.
Q = {>c } CK NK .
w transition function containing w (C, S) role R
states C Q K |= C v S.D.
stationary finite automaton given sfa(A) := h{A}, R , , A, Ai
contains (A, S) role R K |= v S.Self K |= v S.
Boolean CQs answered nondeterministic procedure entails shown Algorithm 1, uses auxiliary procedure exist shown Algorithm 2. following
theorem states entails(K, q) decides K |= q, proof given Section 4.4.
Theorem 21. Let q Boolean CQ K. Then, K |= q nondeterministic
computation exists entails(K, q) returns true.
Finally, determine complexity algorithm entails, towards goal
first determine complexity auxiliary function exist.
Lemma 22. Function exist(A, B, {Pj = pda(sj , j , s0j , j0 ) | 0 j m}) implemented uses space polynomial |K| and, RBox R fixed, runs
time polynomial |T | + |A|.
Proof. Consider arbitrary A, B, Pj = pda(sj , j , s0j , j0 ) stated above; let
Algorithm 2; let ` derivation relation corresponding R . definition
generalised PDAs, |j | dR |j0 | dR j [1..m].
Proposition 2, using polynomial time one compute PDAs accepting languages
LdR (pda(sj , j , s, )) LdR (pda(s, , s0 , 0 )) lines 4 13; therefore, checks lines
4 13 implemented use time (and therefore space) polynomial
|K| (Hopcroft et al., 2003, ch. 7).
space usage Algorithm 2, please observe function stores following
information computation step:
(a) array state length state[j] QR j [1..m], array stack
length stack[j] R |stack[j]| dR j [1..m],
(b) generalised PDA line 4,
(c) generalised PDA stationary automaton line 14,
(d) concept concept {A, >c } CK line 1,
(e) binary counter k 1 k ,
(f) depth dR R, atomic concept {>c } CK , role R .
680

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Algorithm 1: entails(K, q)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

K inconsistent return true
guess substitution dom() = ~y rng() ~y IK
guess skeleton = hV, E, (q)
atom A(t) (q) exists K 6|= (t) v return false
foreach hv, v 0 E let L(v, v 0 ) :=
foreach binary atom S(t, u) (q)
let au unique individual u reachable au
guess v0 {t, au } u reachable v0
let v0 , . . . , vn unique path vn = u
guess states s0 , . . . , sn QR sn = fS
guess words 0 , . . . .n R n = |i | dR [0..n]
foreach [1..n] let L(vi1 , vi ) := L(vi1 , vi ) {pda(si1 , i1 , si , )}
v0
L(wfa((t), (v0 ))) L(pda(iS , , s0 , 0 )) = return false
else
L(sfa((v0 ))) L(pda(iS , , s0 , 0 )) = return false
foreach hv, v 0 E
exist((v), (v 0 ), L(v, v 0 )) return false
return true

Algorithm 2: exist(A, B, {Pj = pda(sj , j , s0j , j0 ) | 0 j m})
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

let concept := let := (1 + |CK |) |QR |m (|R |1+dR )m
j = 1
guess state QR word R || dR
6 LdR (pda(sj , j , s, )) return false
set state[j] := stack[j] :=
guess k N 1 k
r = 1 k
guess R {>c } CK
K 6|= concept v S.D, K |= v {a} IK return false
j = 1
guess {s, s0 } QR {, 0 } R || dR | 0 | dR
hstate[j], S, stack[j]i 6` hs, , return false
L(sfa(D)) LdR (pda(s, , s0 , 0 )) = return false
set state[j] := s0 stack[j] := 0
set concept :=
concept 6= B return false
exists index j [1..m] state[j] 6= s0j stack[j] 6= j0
return false
return true

681

fiStefanoni, Motik, Krotzsch, & Rudolph

definition dR , dR linearly bounded number axioms occurring R; hence, need O(m |R|) space store two arrays. Furthermore,
need O(m |K|) space store counter k using binary encoding. Definition
20, size sfa(D) polynomial |K|; Definition 4, size pda(s, , s0 , 0 ) polynomial |R|. Overall, space needed store required information polynomial
|K|. Finally, following Krotzsch (2011), realise check step 9 polynomial
time. Thus, exist implemented uses space polynomial |K|.
Next, assume RBox R fixed. dR , QR , R , R fixed
well; moreover, bounded size R fixed, linear
size A. Thus, number alternatives nondeterministic step line 3
Algorithm 2 fixed, lines 15 require time polynomial |T | + |A|. Furthermore,
instead guessing k using nondeterministic step 6, repeat lines 715
k [1..M ], requires linear number iterations. show lines 715
implemented run polynomial time, first define three sets used
perform checks lines 9, 12, 13.
{hS, C, Di R (CK NK {>c })2 | K |= C v S.D IK : K 6|= v {a}} (35)
{hS, pda(s, , s0 , 0 )i | R hs, S, ` hs0 , , 0 i} (36)
{hC, pda(s, , s0 , 0 )i | C CK {>c } L(sfa(C)) LdR (pda(s, , s0 , 0 )) 6= } (37)
Given R fixed, sets computed time polynomial size
A. next show implement for-loop steps 715 use space logarithmic
size , A, sets equations (35)(37). space usage lines 715,
computation step for-loop store information points (a)(f) above.
Since R fixed, however, points (a)(c) require constant space. Furthermore,
checks lines 9, 12, 13 performed lookup sets (35)(37); storing
sets using suitable binary encoding using binary index sets,
check implemented using logarithmic space. Finally, CK linear
size A, store counter k, concepts concept, role using binary
encoding, overall space function needs store logarithmic |T | + |A|,
size sets (35)(37). Thus, steps 715 require nondeterministic logarithmic space,
well known implies steps 715 implemented run polynomial
time. Finally, steps 1619 clearly require polynomial time. Consequently, function exist
implemented runs time polynomial |T | + |A| fixed R.
ready establish complexity function entails(K, q); Section 5
shall show function worst-case optimal combined data complexities.
Theorem 23. q BCQ K, function entails(K, q) implemented
1. uses space polynomial input size,
2. RBox R fixed, runs nondeterministic polynomial time size
TBox , ABox A, query q,
3. RBox R query q fixed, runs (deterministic) polynomial time
size TBox ABox A.
682

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Proof. Let q = ~y .(~y ) Boolean CQ K.
shown Proposition 2, one compute lines 14 16 PDA accepting language
LdR (pda(iS , , s0 , 0 )) polynomial time, checks lines 14 16 require time
(and therefore space) polynomial |K| (Hopcroft et al., 2003, ch. 7). Moreover, checks
lines 1 4 require time polynomial |K| (Krotzsch, 2011).
(1), please observe function entails specified Algorithm 1 stores
following information computation step:
substitution dom() = ~y rng() ~y IK ;
skeleton = hV, E, (q);
path v0 , . . . , vn S, sequence states s0 , . . . , sn QR , sequence words
0 , . . . , n R |i | dR [0..n];
function L mapping edge hv, v 0 E set generalised PDA; and,
walking automaton wfa((t), (v0 )) stationary automaton sfa((v0 )).
definition skeleton (q), need space polynomial size q K
store S. Moreover, length longest path given number variables
occurring (q), store sequences vertices, states, words space
polynomial |q| |K| well. Also, set L(v, v 0 ) contains PDAs,
number binary atoms occurring (q). Then, Lemma 22, entails
implemented uses space polynomial input size.
(2), assume RBox R fixed. Lemma 22, fixed RBox R, step 18
implemented runs time polynomial |T | + |A|. Clearly, steps
Algorithm 1 implemented run nondeterministic polynomial time size
TBox , ABox A, query q. Consequently, fixed RBox R, function entails
implemented runs nondeterministic polynomial time size TBox
, ABox A, query q.
(3), assume RBox R query q fixed. dR , QR , R , R
fixed well. Given number variables occurring q fixed, number
guessing steps required steps 2 3 fixed; also, number alternatives
steps linear |T | + |A|. Thus, steps 2 3 require polynomial time. Furthermore,
maximum number iterations for-loop steps 616 fixed length
longest path fixed. Thus, number guessing steps lines 11 12
fixed. addition, number alternatives guessing steps lines 8, 11, 12
fixed well. Therefore, steps 616 require time polynomial |T | + |A|. Finally, since
query fixed, maximum number iterations for-loop steps 17 18
fixed so, Lemma 22, steps 17 18 require time polynomial A.
Therefore, entails implemented runs time polynomial |T | + |A|
fixed R q.

683

fiStefanoni, Motik, Krotzsch, & Rudolph

4.4 Proof Theorem 21
prove function entails(K, q) indeed decides K |= q. Towards goal,
start proving correctness function exist, introduce universal
interpretation K, and, finally, show entails sound complete.
4.4.1 Correctness exist
following proposition proves correctness function exist Algorithm 2.
Lemma 24. Function exist(A, B, {Pj = pda(sj , j , s0j , j0 ) | 0 j m}) returns true
exist natural number k 1, roles S1 , . . . , Sk , basic concepts A0 , . . . , Ak
A0 = Ak = B, role chains {j,i | j [1..m] [1..k]}
following conditions hold [1..k] j [1..m].
1. IK , K |= Ai1 v Si .Ai K 6|= Ai v {a}.
2. role occurring j,i , K |= Ai v T.Self K |= v .
3. S1 j,1 Sk j,k LdR (Pj ).
Proof. Consider arbitrary A, B, Pj = pda(sj , j , s0j , j0 ) stated lemma. Moreover, let ` derivation relation corresponding R .
() Assume nondeterministic computation exist function
returns true. Let k N guessed step 6; show for-loop steps 715
satisfies following invariant: iteration r, exist roles S1 , . . . , Sr , basic
concepts A0 , . . . , Ar , and, j [1..m], role chains j,1 , . . . , j,r A0 = A,
Ar = concept, following holds [1..r] j [1..m].
(i) K |= Ai1 v Si .Ai and, IK , K 6|= Ai v {a}.
(ii) role occurring j,i , K |= Ai v T.Self K |= v .
(iii) S1 j,1 Sr j,r LdR (pda(sj , j , state[j], stack[j])).
Base case. first iteration loop (i.e., steps 15 r = 0),
concept = A, LdR (pda(sj , j , state[j], stack[j]) j [1..m],
properties (i)(iii) clearly hold.
Inductive step. Consider arbitrary iteration r [1..k 1] assume properties
(i)(iii) hold end iteration r; show true iteration r + 1.
inductive hypothesis, exist roles S1 , . . . , Sr , basic concepts A0 , . . . , Ar , and,
j [1..m], role chains j,1 , . . . , j,r A0 = A, Ar = concept properties
(i)(iii) hold. Let role Sr+1 = atomic concept Ar+1 = guessed step 8.
Clearly, K |= concept v Sr+1 .Ar+1 K 6|= Ar+1 v {a} IK ,
required property (i). Furthermore, consider arbitrary j [1..m], let s, s0 , ,
0 guessed step 11, let state[j] stack[j] end iteration r;
then, hstate[j], Sr+1 , stack[j]i ` hs, , due step 12; furthermore, due step 13, role
chain j,r+1 exists j,r+1 L(sfa(D)) LdR (pda(s, , s0 , 0 )). Definition 20
stationary automata, role occurring j,r+1 K |= v T.Self
684

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

K |= v , required property (ii). Finally, let state[j] stack[j] specified
step 14; S1 j,1 Sr j,r Sr+1 j,r+1 LdR (pda(sj , j , state[j], stack[j])),
property (iii) holds.
Step 16 ensures concept = B; furthermore, steps 1718 ensure state[j] = s0j
stack[j] = j0 j [1..m], PDA Pj accepts S1 j,1 Sk j,k . Thus, properties
(1)(3) lemma hold, required.
() Let S1 , . . . , Sn roles, let A0 , . . . , basic concepts A0 = = B,
let j,i role chains satisfying properties (1)(3) lemma. derivation
S1 j,1 Sn j,n PDA Pj following form, sj,n+1 = s0j j,n+1 = j0 :
hsj , S1 j,1 Sn j,n , j `
hs0j,1 ,

hsj,1 , S1 j,1 Sn j,n , j,1 `

j,1 S2 Sn j,n ,

hsj,2 , S2 j,2 Sn j,n , j,2 `

0
j,1


(39)



(40)



(41)

. . . `

(42)

`

... `
hs0j,i ,

hsj,i , Si j,i Sn j,n , j,i `

j,i Si+1 Sn j,n ,

hsj,i+1 , Si+1 j,i Sn j,n , j,i+1 `
hs0j,n ,

hsj,n , Sn j,n , j,n `
hsj,n+1 , , j,n+1

j,n ,

(38)



0
j,i

0
j,n


`



`

(43)
(44)

Transition (38) (39) special sense allows Pj make arbitrary
number -transitions; rest derivation regular consists reading Si
j,i . Thus, sj,i s0j,i states Pj after, respectively, reading Si ,
0 respective stacks. property (3) lemma, | |
j,i j,i
j,i
R
0
|j,i | dR .
Let Xi = hAi , s1,i , 1,i , . . . , sm,i , m,i i. PDA, |QR | many different
P R
|R |` many difstates, 1+|CK | different elements {>c }CK ; furthermore, d`=0
PdR
ferent stacks length dR . |R | > 0 dR > 0, `=0 |R |` |R |1+dR ;
consequently, distinct tuples. Thus, k ,
Xk = Xn+1 . then, Ak = B; furthermore, j [1..m], sj,k = sj,n+1 = s0j
j,k = j,n+1 = j0 , S1 j,1 Sk j,k LdR (Pj ).
easily construct nondeterministic computation exist follows.
step 3, j let = sj,1 = j,1 ; clearly, condition step 4 satisfied.
r for-loop lines 715, proceed follows.
step 8 let = Si = Ai , respectively; clearly, condition step 9
satisfied due property (1).
0 , 0 =
j [1..m], let = s0j,r , s0 = sj,r+1 , = j,r
j,r+1 ; clearly,
condition step 12 satisfied due form derivation; furthermore,
condition step 13 satisfied due property (2) Definition 20.

Finally, conditions steps 16 17 satisfied due way chose k.
Therefore, function exist returns true step 19.

685

fiStefanoni, Motik, Krotzsch, & Rudolph

Rule
(cr1)
(cr2)

(cr3)

(cr4)
(cr5)

(cr6)

(cr7)

Precondition
K |= A1 u A2 v B
{A1 (w), A2 (w)}
K |= v S.B
K |= B v {a} IK
A(w)
K |= v S.B
K 6|= B v {a} IK
A(w)
K |= S.A v B
{S(w, w0 ), A(w0 )}
K |= S.Self v B
S(w, w)
role simple
K |= v S.Self
A(w)
role simple
L(S)
(w, w0 )

Conclusion
B(w)
S(w, a), B(a)

S(w, fS,B (w)), B(fS,B (w))
>c (fS,B (w)), >r (fS,B (w), fS,B (w))
>r (fS,B (w), w0 ) term w0 occurring
>r (w0 , fS,B (w)) term w0 occurring
B(w)
B(w)

S(w, w)

S(w, w0 )

Table 5: Rules consequence-based chase
4.4.2 Consequence-Based Chase Universal Interpretations
prove entails(K, q) sound complete, interpret K using forest-shaped
universal interpretation described Section 4.2. Towards goal, next define
auxiliary notions, define universal interpretation, and, finally, prove two properties interpretation.
universe K set terms built individuals occurring K
unary function symbols form fS,A R CK . Since K normalised,
universe K nonempty. fact ground atom constructed using predicates
occurring K terms universe K. role chain = S1 Sn , terms
w w0 , set facts I, write (w, w0 ) (not necessarily distinct) terms
w = w0 , . . . , wn = w0 exists Si (wi1 , wi ) [1..n]. set facts
entails Boolean CQ q = ~y . (~y ), written |= q, substitution exists
dom( ) = ~y (q) I. universal interpretation IK K defined follows.
Definition 25. chase rule Table 5 applicable set facts preconditions
rule satisfied, contain conclusions rule. consequencebased chase (often chase) K sequence sets facts I0 , I1 , . . .
I0 = {{a}(a), >c (a), >r (a, b) | {a, b} IK }

(45)

and, 1, set Ii+1 obtained extending Ii conclusion one (arbitrarily
chosen) chase rule applicable Ii , Ii+1 = Ii chase rule applicable Ii .
686

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

sequence must fairthat is, derivation rule applicable Ii specific
precondition, j exists suchSthat Ij+1 obtained Ij applying rule
mentioned precondition. Set IK = Ii universal interpretation K.
Since K normal form, K 6|= {a} v {b} distinct individuals
b IK ; hence, one individual IK exists rule (cr2) K |= B v {a}.
that, straightforward see IK independent order
chase rules applied, call IK universal interpretation K. Moreover,
due fairness, derivation rule applicable IK is, chase rule
Table 5 either preconditions rule satisfied IK , IK contains
conclusions rule. Finally, well-known that, K consistent, IK
homomorphically embedded model K (Krotzsch et al., 2007). Consequently,
universal interpretation IK used answer arbitrary Boolean CQs K.
Fact 26. Boolean CQ q, K |= q K |= >c v c IK |= q.
Next, show IK relates axioms entailed K. end, let
following function mapping term w universe K basic concept:
(
{w} w
(w) :=

w form w = fS,A (w0 )
Proposition 27. universal model IK satisfies following properties.
1. A(w) IK , K |= (w) v A.
2. S(w, w0 ) IK , nonempty role chain = 0 S1 1 m1 Sm
L(S) terms w0 , . . . , wm universe K w0 = w wm = w0
exist
(a) [1..m], either wi IK , atomic concept Ai {>c } CK exists
wi = fSi ,Ai (wi1 ) K 6|= Ai v {a} individual IK ,
(b) [1..m], K |= (wi1 ) v Si .(wi ),
(c) [0..m] role occurring , K |= (wi ) v T.Self
K |= v .
Proof. Let I0 , I1 , . . . chase sequence K. show induction rule applications properties (1) (2) satisfied A(w) S(w, w0 ) ,
respectively, additionally satisfies following property:
3. term w occurring , K |= x.(w)(x).
definition I0 (cr3), terms w w0 occurring ,
clearly {>c (w), >r (w, w0 ), >r (w0 , w)} .
Base case. Consider I0 , note term w occurring I0 individual
(w) = {w}. Consider A(a) I0 ; either A(a) A, = {a}, = >c ,
K |= {a} v A, property (1) holds. Furthermore, consider S(a, b) I0 ;
687

fiStefanoni, Motik, Krotzsch, & Rudolph

S(a, b) = >r , K |= {a} v S.{b}, property (2) holds w0 = a,
w1 = b, = S. Finally, property (3) holds K |= x.{a}(x) IK .
Inductive step. Assume satisfies properties (1)(3). considering
derivation rule, assume rule applicable shown Table 5,
show properties (1)(3) hold conclusions rule. Note rule (cr3)
affect property (3), explicitly consider properties hold vacuously.
(cr1) inductive hypothesis, K |= (w) v A1 K |= (w) v A2 ,
implies K |= (w) v B, required property (1).
(cr2) inductive hypothesis, K |= (w) v K |= x.(w)(x),
clearly imply K |= (w) v S.B K |= x.B(x). Moreover, (a) = {a}, K |= (a) v B,
property (1) holds. Finally, since K |= (w) v S.(a), property (2) holds w0 = w,
w1 = a, = S.
(cr3) Let w00 = fS,B (w). inductive hypothesis, K |= (w) v
K |= x.(w)(x), K |= (w) v S.B K |= x.B(x). Moreover, (w00 ) = B,
K |= (w00 ) v B, K |= (w00 ) v >c , K |= x.(w00 )(x), required properties (1)
(3), respectively. property (2), consider role assertions derived rule.
S(w, w00 ). Note K |= (w) v S.(w00 ) K 6|= B v {a} IK ,
property (2) holds w0 = w, w1 = w00 , = S.
>r (w00 , w00 ). Clearly, property (2) holds w0 = w00 = 0 = >r .
>r (w00 , w0 ) term w0 occurring . Let individual w0 rooted
in; then, >r (a, w0 ) so, inductive hypothesis, role chain L(>r )
terms = w0 , . . . , wm = w0 exist satisfying properties (a)(c). Since K |= x.(w00 )(x),
K |= (w00 ) v >r .{a}; thus, >r w00 , w0 , . . . , wm satisfy property (2).
>r (w0 , w00 ) term w0 occurring . Then, >r (w0 , w) so, inductive
hypothesis, role chain L(>r ) terms w0 = w0 , . . . , wm = w exist satisfying
properties (a)(c). then, >r w0 , . . . , wm , w00 satisfy property (2).
(cr4) inductive hypothesis, K |= (w0 ) v A; moreover, terms w0 , . . . , wm
w0 = w wm = w0 nonempty role chain = 0 S1 1 m1 Sm
L(S) exist satisfying properties (a)(c). definition L(S), K |= v S;
together entailments properties (b) (c), K |= (w) v S.(w0 ).
then, K |= (w) v S.A, implies K |= (w) v B, required property (1).
(cr5) inductive hypothesis, nonempty role chain L(S) exist satisfying
properties (a)(c); moreover, K |= v definition L(S). Role simple,
|| = 1, therefore one following two forms.
= 0 0 = . property (c), K |= (w) v T.Self K |= v .
Furthermore, due K |= v S, K |= v S. then, K |= (w) v S.Self,
K |= (w) v B holds, required property (1).
= S1 . Terms w0 w1 satisfying property (2) equal w; moreover,
w1 form fS1 ,A1 (w), w IK . Furthermore, property (b)
688

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

K |= (w) v S1 .(w); together w IK , K |= (w) v S1 .Self. Finally,
due K |= v S, K |= S1 v S. then, K |= (w) v S.Self,
K |= (w) v B holds, required property (1).
(cr6) inductive hypothesis, K |= (w) v A, conclude
K |= (w) v S.Self, property (2) holds w0 = w = 0 = S.
(cr7) = , w = w0 K |= v S, property (2) holds w0 = w
= 0 = S. Otherwise, assume nonempty form = S1 Sk .
Thus, terms w0 , . . . , wk w0 = w wk = w0 exist Si (wi1 , wi )

[1..k]. inductive hypothesis, [1..k], terms w0i , . . . , wm






w0 = wi1 wmi = wi role chain L(Si ) exist satisfying properties
k
i1 = w
(a)(c); note w0i = w0 = w, wm
= wk = w0 , wm
0
i1
k
1
k
[1..k]. definition L(S), L(S), property (2) holds
1 , . . . , wk , . . . , wk .
role chain 1 k terms w0 , w11 , . . . , wm
mk
1
1
4.4.3 Soundness
ready show algorithm entails sound.
Lemma 28. nondeterministic computation exists entails(K, q) returns true,
K |= q.
Proof. Assume nondeterministic computation exists entails(K, q) returns
true. algorithm returns true step 1, K |= q, K inconsistent; hence,
rest proof, assume K consistent show IK |= q. end, let
substitution , skeleton = hV, E, i, function L determined entails. Graph
hV, Ei forest rooted individuals occurring K so, structural induction
forest, define mapping V universe K satisfy following:
(i) v V , (v)( (v)) IK ;
(ii) hv, v 0 E Pj L(v, v 0 ), role chain j L(Pj ) exists
j ( (v), (v 0 )) IK .
Base case. IK , let (a) = a. Since (a) = {a} {a}(a) IK , first
property clearly holds, second property vacuous.
Inductive step. Consider hv, v 0 E (v) defined, (v 0 ) not;
let L(v, v 0 ) = {P1 , . . . , Pm }. Since exist((v), (v 0 ), L(v, v 0 )) returns true, Lemma 24
roles S1 , . . . , Sn , atomic concepts A1 , . . . , , and, j [1..m], role
chain j = S1 j,1 Sn j,n exist n 1, A0 = (v) = (v 0 ),
following holds [1..n] j [1..m].
1. IK , K |= Ai1 v Si .Ai K 6|= Ai v {a}.
2. role occurring j,i , K |= Ai v T.Self K |= v .
3. j LdR (Pj ).

689

fiStefanoni, Motik, Krotzsch, & Rudolph

Let w0 = (v); let wi = fSi ,Ai (wi1 ) [1..n]; let (v 0 ) = wn . Since A0 = (v),
inductive hypothesis A0 ( (v)) IK . Furthermore, (cr3) applicable
IK so, [1..n], Si (wi1 , wi ) IK Ai (wi ) IK ; thus, ( (v 0 )) IK ,
required. Finally, role occurring j,i , K |= Ai v T.Self
K |= v ; (cr6) (cr7) applicable IK , respectively, (wi , wi ) IK ;
thus, j ( (v), (v 0 )) IK , required.
next show ((q)) IK considering independently atom (q).
prove lemma, combine obvious way.
Consider arbitrary unary atom A(t) (q). step 4 Algorithm 1,
K |= (t) v A, implies K |= (t) u (t) v A. property (i),
(t)( (t)) IK . Since rule (cr1) applicable IK , A( (t)) IK , required.
Consider arbitrary binary atom S(t, u) (q). Let v0 , . . . , vn , s0 , . . . , sn ,
0 , . . . , n determined steps 811 Algorithm 1 considers atom S(t, u).
[1..n], pda(si1 , i1 , si , ) L(vi1 , vi ) step 12; then, property (ii)
role chain exists L(pda(si1 , i1 , si , )) ( (vi1 ), (vi )) IK .
Next, define 0 considering following two cases.
v0 I. step 14 Algorithm 1, role chain 0 = S1 Sk exists
0 L(wfa((t), (v0 ))). property (i), (t)( (t)) IK ; moreover, Definition 20, basic concepts (t) = A0 , A1 , . . . , Ak = {v0 } exist K |= Aj1 v Sj .Aj
j [1..k]. Rules (cr2) (cr3) applicable IK ,
0 ( (t), (v0 )) IK .
v0 6 I, implies v0 = t. step 16 Algorithm 1, role chain 0 = T1 Tk
exists 0 L(sfa((v0 ))). property (i), (v0 )( (v0 )) IK ;
moreover, Definition 20, K |= (v0 ) v Tj .Self K |= v Tj j [1..k].
Rules (cr6) (cr7), respectively, applicable IK , thus 0 ( (t), (v0 )) IK .
either case, steps 14 16 0 L(pda(iS , , s0 , 0 )). let 0 = 0 n ;
note n = 0, case 0 = 0 . Clearly, 0 ( (t), (vn )) IK ,
vn = u. Moreover, 0 L(pda(iS , , sn , n )) sn = fS n = . Finally,
rule (cr7) applicable IK , S( (t), (u)) IK , required.
4.4.4 Completeness
next prove encoding complete, thus proving Theorem 21.
Lemma 29. K |= q, nondeterministic computation exists entails(K, q)
returns true.
Proof. Assume K |= q. K inconsistent, entails(K, q) returns true, required;
hence, rest proof, assume K consistent. then, IK |= q,
substitution exists (q) IK . Let defined Section 4.4.2.
substitution step 2, let (y) := (y) (y) I; otherwise, let (y)
arbitrary, fixed, variable 0 q (y) = (y 0 ). straightforward see
((q)) IK .

690

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

skeleton = hV, E, step 3, set V contains IK variables occurring
(q), (y) = ((v)) variable V . Furthermore, let smallest
irreflexive transitive relation universe K w fS,A (w) term
w universe K; then, let hv, v 0 E (v) (v 0 ) v 00 V exists
(v) (v 00 ) (v 0 ). definition , graph hV, Ei forest rooted
IK , required Definition 18.
step 4, arbitrary atom A(t) (q), A((t)) IK ; property (1)
Proposition 27, K |= ((t)) v A; hence, condition satisfied.
consider arbitrary edge hv, v 0 E; let w0 , . . . , wk terms, let A1 , . . . , Ak
atomic concepts, let S1 , . . . , Sk roles w0 = (v), wk = (v 0 ),
wi = fSi ,Ai (wi1 ) [1..k]; finally, let A0 = (v). Note
uniquely defined edge, that, construction IK , [1..k],
K |= Ai1 v Si .Ai K 6|= Ai v {a} IK . Then, role chain compatible
edge hv, v 0 role chains 1 , . . . , k exists = S1 1 Sk k and,
[1..k] role occurring , K |= Ai v T.Self K |= v .
rest proof show following property.
() PDA P L(v, v 0 ), role chain L(P) exists compatible
edge hv, v 0 i.
Lemma 24 definition compatibility, property () implies
condition step 18 satisfied edge hv, v 0 i.
loop steps 616, let S(t, u) arbitrary binary atom (q); next
determine required nondeterministic choices preserve () step 12,
satisfy conditions steps 14 16, completes proof lemma. Let au IK
unique individual connected u hV, Ei. Since S((t), (u)) IK , nonempty
role chain = 0 S1 1 m1 Sm L(S) terms w0 , . . . , wm
universe K w0 = (t) wm = (u) exist satisfying property (2) Proposition 27.
define vertex v0 step 8, consider two possibilities, define
index `0 [0..m] w`0 = (v0 ).
j [0..m] exists wj IK , let v0 = au let `0 largest index
w`0 = au .
Otherwise, let v0 = let `0 = 0.
Let v0 , . . . , vn unique path connecting v0 u S. definition `0
form terms w`0 +1 , . . . , wm , wj 6 j [`0 + 1..m]; (v0 ) = w`0 ;
(vn ) = wm . Thus, [1..n], unique index `i exists (vi ) = w`i .
let 0 = 0 S`0 `0 , let = S`i1 +1 `i1 +1 S`i `i [1..n];
clearly, = 0 n . properties (a)(c) Proposition 27, [1..n], role chain
compatible edge hvi1 , vi i. Furthermore, L(S) Theorem 8 imply
LdR (pda(iS , , fS , )), states s0 , . . . , sn sn = fS words 0 , . . . , n
n = exist 0 LdR (pda(iS , , s0 , 0 )) LdR (pda(si1 , i1 , si , )
[1..n]. Since compatible hvi1 , vi i, step 12 preserves property (),
required. Finally, consider step 13.

691

fiStefanoni, Motik, Krotzsch, & Rudolph

v0 I. property (b) Proposition 27, K |= (wj1 ) v Sj .(wj ) j [1..`0 ].
Furthermore, property c Proposition 27, K |= (wj ) v T.Self K |= v
j [0..`0 ] role occurring j ; thus, K |= (wj ) v T.(wj ).
then, 0 L(wfa((t), (v0 ))), condition step 14 satisfied.
v0 6 I, v0 = 0 = 0 . property (c) Proposition 27, K |= (wj ) v T.Self
K |= v role occurring 0 . then, 0 L(sfa((v0 ))),
condition step 16 satisfied.

5. Lower Complexity Bound
previous section, presented BCQ answering algorithm ELRO+ uses
space polynomial total size input. algorithm worst-case optimal
combined complexity since Krotzsch et al. (2007) reduced PSpace-hard problem
checking nonemptiness intersection languages generated deterministic
finite automata F1 . . . Fm common alphabet (Kozen, 1977) BCQ answering
ELRO+ . knowledge base K encoding problem, regular RBox contains roles
S1 . . . Sm L(Si ) = L(Fi ) [1..m]; furthermore, TBox ensures
universal interpretation IK rooted tree so, , term w exists
reachable root chain
roles corresponding ; finally, Boolean CQ
contains atoms check whether L(Fi ) nonempty. next improve lower
bound showing problem hard already restricted setting query,
TBox, ABox fixed, RBox varies.
Theorem 30. K regular ELRO+ knowledge base q Boolean conjunctive query,
checking K |= q PSpace-hard even
query fixed consist two binary atoms single quantified variable,
TBox fixed contains axioms form v S.A,
ABox fixed contains single unary assertion.
Proof. reduce PSpace-hard problem deciding whether intersection
languages generated deterministic finite automata nonempty (Kozen, 1977). Let
0 deterministic finite automata alphabet 0 , let fresh symbols
F10 , . . . , Fm
1
2
occurring 0 , let = 0 {1 , 2 }. j [1..m], let Fj = hQj , , j , ij , fj
deterministic finite automaton alphabet obtained extending Fj0
transition labelled 1 final state fj0 Fj0
itself, transition labelled
0
0

2 fj fresh final state fj Fj . Then,
j ) 6= word
j L(F
0
w j L(Fj ) exist |w| odd: given w j L(Fj ), |w| odd, |w 1 2 |
odd w 1 2 L(Fj ) j [1..m], |w| even, |w 2 | odd
w 2 L(Fj ) j [1..m]. Finally, assume w.l.o.g. Qi Qj 6= Qi R
hold 1 < j m, R well.
Let w = ST1 Sn word n odd, let = Q1 . . . Qm .
Clearly, w j L(Fj ) holds word w form
n
n
w = e01 e0m S1 o1m o11 S2 e21 e2m e1n1 en1
Sn om o1

692

(46)

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

exists following conditions hold j [1..m]:

(i) [1..n] odd, oij Qj j (ei1
j , Si ) = oj ;

(ii) [1..n] even, eij Qj j (oi1
j , Si ) = ej ;

(iii) e0j = ij onj = fj .
let LO , LE , L1 , L2 following languages.
LO :={e1 em om o1 | j (ej , S) = oj , j [1..m]}

(47)

LE :={om o1 e1 em | j (oj , S) = ej , j [1..m]}

(48)



L1 :=(LO ) LO

(49)


L2 :={i1 im } ( LE ) {fm f1 }

(50)

Consider arbitrary word w corresponding word w . definition
L1 , w L1 w form (46) satisfies property (i). Similarly,
definition L2 , w L2 w theT form (46) satisfies
properties (ii) (iii). Thus, w L1 L2 w j L(Fj ). simplicity,
rest proof, use following equivalent formulations L1 L2 .
L1 =LO (LO )+ LO

(51)
+

L2 ={i1 im } {fm f1 } {i1 im } ( LE ) {fm f1 }

(52)

TWe next define knowledge base K fixed query q K |= q
j L(Fj ) 6= . present construction stages, describe
affects canonical model = hI , Kthat is, model constructed using
standard notion chase (i.e., Definition 25, semantic conditions
K replaced syntactic checks axioms K). simplicity, first present K
TBox depends , later modify encoding use fixed TBox.
TBox contains axioms (53), ABox contains axiom (54).
assume aI = ; then, word , domain element exists
connected via chain roles corresponding .
v.A

symbol

(53)

A(a )

(54)

next present RBox R consisting four parts, encoding languages LO , LE ,
S,m+1
S,m
L1 , L2 . encoding uses fresh roles LS,1
LS,0
uniquely
, . . . , LO
E , . . . , LE
0
associated role , well fresh roles LO , LE , L , L1 , L1 , L2 , L02 .
first part R contains axioms (55)(57). clear that, words
1 , 2 1 prefix 2 , ha1 , a2 LIO 2 1 LO .
v LS,m+1

ej

LS,j+1


oj v

LS,j




(55)

j [1..m] ej , oj Qj j (ej , S) = oj

(56)

LS,1
v LO

(57)
693

fiStefanoni, Motik, Krotzsch, & Rudolph

second part R contains axioms (58)(60). clear that, words
1 , 2 1 prefix 2 , ha1 , a2 LIE 2 1 LE .

oj

S,j1
LE

v LS,0
E



(58)

LS,j
E

j [1..m] ej , oj Qj j (oj , S) = ej

(59)

ej v

LS,m
v LE
E

(60)

third part R contains axioms (61)(65). clear that, words
1 , 2 1 prefix 2 , ha1 , a2 LI1 2 1 L1 .
v L



(61)

LO v L1

(62)

L01
L01

(63)

v L1

(65)

LO L v
L01 L01
L01 LO

v

(64)

fourth part R contains axioms (66)(69). clear that, words
1 , 2 1 prefix 2 , ha1 , a2 LI2 2 1 L2 .
i1 im L fm f1 v L2

(66)

L02
L02

(67)
(68)

L fm f1 v L2

(69)

L LE v
L02
i1 im

L02



L02

v

Query q given (70). Then, K |= q word exists
ha , LI1 ha , LI2 , latter clearly case L1 L2 .
RBox R regular size polynomial size automata F1 , . . . , Fm .
q = y. L1 (a , y) L2 (a , y)

(70)

next tighten reduction use fixed TBox 0 consisting axioms (71)(72),
P0 P1 fresh roles.
v P0 .A

(71)

v P1 .A

(72)

let k = dlog2 ||e, assume symbol corresponds k-digit binary
number b1 bk bi {0, 1}. Then, let R0 R extended axioms (73).
Pb 1 Pb k v

corresponding b1 bk

(73)

Finally, let K0 = hT 0 , R0 , Ai, let 0 canonical model K0 . Axioms (54), (71),
(72) ensure existence binary tree whose edges labelled roles P0 P1 .
Furthermore, axioms (73) ensure that, sequence k edges
tree corresponding binary number assigned , shortcut tree
694

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

labelled . Thus, homomorphically embedded 0 . Finally, roles P0
P1 occur R query q checks existence domain element connected ;
therefore, extra edges 0 irrelevant. Consequently, encoding languages L1
L2 works way varying TBox .
Finally, characterise complexity BCQ answering ELRO+ knowledge bases.
Theorem 31. K regular ELRO+ KB q Boolean CQ, checking K |= q
1. PTime-complete data complexity,
2. NP-complete, RBox R fixed,
3. PSpace-complete combined complexity.
Proof. Calvanese et al. (2006) proved BCQ answering PTime-hard data complexity already EL knowledge bases. Furthermore, query fixed, BCQ
answering NP-hard already relational databases (Chandra & Merlin, 1977).
theorem follows Theorems 23 30, Savitchs theorem.

6. Navigational Queries
data DL knowledge bases graph-like structure, unary assertions encode
properties graph nodes binary assertions encode graph edges. Conjunctive queries
cannot express recursive properties reachability, expressivity often insufficient applications require graph navigation. popularity graph
databases rise, number navigational languages querying graph-like data
proposed; example, regular path queries (Barcelo, 2013) use regular expressions express complex navigational patterns graph vertices, graph XPath
queries (Libkin et al., 2013) extend regular path queries converse operator, negation regular expressions, checking properties vertices using Boolean combinations
concepts existential quantifications paths. DL context, computational complexity navigational queries studied several expressive DLs
members DL-Lite family EL(H) fragment ELRO+ (Calvanese, Eiter, &
Ortiz, 2009; Bienvenu et al., 2013; Kostylev et al., 2014; Bienvenu et al., 2014). order
complete complexity landscape problem, section study problem
answering graph XPath queries ELRO+ knowledge bases.
6.1 Graph XPath Queries
Graph XPath queries consist node expressions path expressions, whose syntaxes
defined respectively following two context-free grammars B basic concept
role.
B | | 1 2 | 1 2 | hi
| | 1 2 | 1 + 2 | | | test()
Following Libkin et al. (2013), consider following expression fragments.
695

fiStefanoni, Motik, Krotzsch, & Rudolph

P,E
4

P

g

P

P,F
3

S,D
5

R,S



R

b

U
P

S,D
6



S,A
7



U

P,A
2



f

P

R,S

c
B

R



R,S

e



P,E
1

Figure 8: Interpretation
1. path-positive fragment disallows path expressions form .
2. positive fragment disallows path expressions form node expressions
form .
3. converse-free fragment disallows path expressions form .
graph XPath atom form (s) (s, t), node expression, path
expression, terms. conjunctive graph XPath query (CGXQ) g expression
g = ~y . (~x, ~y ) conjunction graph atoms variables ~x ~y ; variables ~x
called answer variables g. ~x = , g = ~y . (~y ) Boolean CGXQ.
Path-positive, positive, converse-free CGXQs obtained restricting query atoms
accordingly. Finally, graph XPath query (GXQ) CGXQ containing single atom.
define semantics CGXQs, let = hI , first-order interpretation.
interpretation node path expressions inductively defined follows.
()I
(1 2 )I
(1 2 )I
(hi)I

=
=
=
=

\ ()I
(1 )I (2 )I
(1 )I (2 )I
{x | : hx, yi }

(S )I
(1 2 )I
(1 + 2 )I
( )I
()I
(test())I

=
=
=
=
=
=

{hy, xi | hx, yi }
(1 )I (2 )I
(1 )I (2 )I
(I )
\ ()I
{hx, xi | x }

Please observe difference path expressions 1 2 corresponds (1 + 2 ),
whereas intersection 1 2 corresponds (1 + 2 ); moreover, Libkin et al.
(2013) define path expression , setting corresponds test(>c ). Satisfaction
Boolean CGXQ g CGXQ entailment defined obvious way; moreover,
Boolean CGXQ answering problem checking K |= g.
Example 32. illustrate definitions using interpretation shown Figure 8;
notation Example 15. Moreover, let 1 , 2 , 3 following path expressions.
1 =(R test(hS test(A B)i))

(74)

2 =(U test(hP test(A B)i))

(75)

696

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Node expressions
TB = {B v CB }
T1 2 = {C1 u C1 v C1 2 } T1 T2
T1 2 = {C1 v C1 2 , C2 v C1 2 } T1 T2
Thi = {T .>c v Chi }
Path expressions
TS =
T1 2 = T1 T2
T1 +2 = T1 T2
=
Ttest() = {C v Ttest() .Self}

RB =
R1 2 = R1 R2
R1 2 = R1 R2
Rhi = R

RS = {S v TS }
R1 2 = {T1 T2 v T1 2 } R1 R2
R1 +2 = {T1 v T1 +2 , T2 v T1 +2 } R1 R2
R = { v , v , v } R
Rtest() = R

Table 6: Encoding positive, converse-free node path expressions using axioms
3 =((R S) )

(76)

Expression 1 positive, retrieves pairs individuals connected
path R-edges that, element occurring path first,
exists outgoing path S-edges reaching member concept B. example,
{haI , dI i, haI , eI i} (1 )I .
contrast, expression 2 path-positive, retrieves pairs individuals
connected U -edge P -successor exists member concept AtB.
example, haI , g (2 )I , haI , f 6 (2 )I .
Finally, expression 3 neither positive path-positive, retrieves pairs
individuals connected path consisting sequence edges described
regular expression (R S) . example, haI , dI (3 )I , haI , eI 6 (3 )I .
Let g = x, y, z.1 (x, y) 2 (x, z) 3 (x, y) conjunctive graph XPath query, let
= {x 7 a, 7 d, z 7 g} substitution. Using Figure 8, one check |= (g).
observed Kostylev et al. (2014), node expressions graph XPath queries correspond precisely formulas propositional dynamic logic negation (PDL ) (Harel
et al., 2000); satisfiability problem PDL undecidable (Harel, 1984), answering
GXQs DL constraints undecidable. Decidability results recently obtained path-positive positive queries DL-Lite knowledge bases (Kostylev et al.,
2014). addition, Kostylev et al. (2014) proved that, DLs, answering path-positive,
converse-free GXQs coNP-hard data-complexity. Finally, Bienvenu et al. (2014) proved
answering positive GXQs EL knowledge bases ExpTime-complete. Thus,
rest section focus positive, converse-free graph XPath queries.
6.2 Complexity Answering Positive, Converse-Free Graph XPath Queries
rest section, fix ELRO+ KB K = hT , R, Ai R regular.
next show that, given positive, converse-free Boolean CGXQ g, one construct
polynomial time regular ELRO+ KB K0 Boolean CQ q 0 K |= g
K0 |= q 0 . construction K0 combines various expressive features ELRO+ :
697

fiStefanoni, Motik, Krotzsch, & Rudolph

role inclusions reflexive roles encode path expressions g RBox, selfrestrictions encode node expressions g TBox.
Proposition 33. Given positive, converse-free Boolean CGXQ g K, one compute
time polynomial |K| + |g| ELRO+ KB K0 Boolean CQ q 0 RBox
K0 regular, g q 0 equally many atoms, K |= g K0 |= q 0 .
Proof. Let g = ~y . (~y ) positive, converse-free Boolean CGXQ K.
positive node expression , let C fresh atomic concept uniquely associated
and, positive, converse-free path expression , let fresh role uniquely
associated . structural induction, associate (resp. ) TBox
RBox R (resp. TBox RBox R ) shown Table 6. Then, let
K0 = hT 0 , R R0 , Ai TBox 0 RBox R0 follows.
[
[
[
[
T0=


R0 =
R
R
(s)

(s,t)

(s)

(s,t)

let q 0 = ~y . 0 (~y ) Boolean CQ 0 contains C (s) atom (s)
(s, t) atom (s, t) . Clearly, g q 0 number atoms;
moreover, since query g K, query q 0 K0 . Finally, q 0 K0
computed polynomial time input size, RBox K0 clearly regular.
next show K0 6|= q 0 K 6|= g.
() Assume K0 6|= q 0 , interpretation exists |= K0 6|= q 0 .
Since axiom K axiom K0 , |= K. Furthermore,
positive node expression positive path expression , (C )I
(T )I . prove claim simultaneous induction structure node
path expressions.
Base case. base case, let arbitrary node expression form = B
let arbitrary path expression form = S. Since B v CB 0 , v TS R0 ,
model K0 , claim easily follows.
Inductive step. inductive step, distinguish two cases.
First, consider arbitrary node expression property holds node
path expressions occurring . let x arbitrary element assume
x ; show x CI considering various forms take.
= 1 2 . Since x , x I1 x I2 . inductive hypothesis,
x CI1 x CI2 . definition 0 , C1 u C2 v C 0 .
Since model 0 , x CI , required.
= 1 2 . proof case similar one above.
= hi. Since x , exists hx, yi . inductive
hypothesis, hx, yi TI . definition 0 , .>c v C 0 .
Since model 0 , x CI , required.
Second, consider arbitrary path expression property holds
node path expressions occurring . let x arbitrary elements
assume hx, yi ; show hx, yi TI considering various forms
take.
698

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

= 1 2 . Since hx, yi , exists z hx, zi 1I
hz, yi 2I . inductive hypothesis, hx, zi TI1 hz, yi TI2 .
Moreover, definition R0 , T1 T2 v R0 . Since model
R0 , hx, yi TI , required.
= 1 + 2 . Since hx, yi , hx, yi 1I hx, yi 2I .
inductive hypothesis, hx, yi TI1 hx, yi TI2 . definition R0 ,
{T1 v , T2 v } R0 . Since model R0 , hx, yi TI .
= 1 . First, consider case x = y. definition R0 ,
v R0 . Since model R0 , hx, yi TI , required. Otherwise,
consider case x 6= y. Since hx, yi , elements x0 , . . . , xn x0 = x
xn = exist n > 0 hxi1 , xi 1I [1..n].
inductive hypothesis, [1..n], hxi1 , xi TI1 . definition
R0 , T1 T1 v R0 . Since model R0 , hx, yi .
= test(). follows x = x . inductive hypothesis,
x CI . definition 0 , C v .Self 0 . Since model
0 , hx, yi TI , required.
then, since node path expressions g positive, 6|= q 0 implies 6|= g.
I0

() Assume K 6|= g, interpretation exists |= K 6|= g. Let
interpretation obtained extending fresh concepts roles follows.
0

(C )I =

0

0

(T )I =

0

definition K0 , straightforward see 0 |= K0 ; furthermore,
definition q 0 , straightforward see 0 6|= q 0 , required.
Next, establish complexity answering positive, converse-free (C)GXQs
ELRO+ knowledge bases.
Theorem 34. K regular ELRO+ KB g positive, converse-free Boolean CGXQ,
checking K |= g PTime-complete data complexity, PSpace-complete combined
complexity. g positive, converse-free Boolean GXQ, checking K |= g PTimecomplete combined data complexities.
Proof. hardness data complexity Boolean positive, converse-free (C)GXQs follows
PTime-hardness instance checking EL (Calvanese et al., 2006).
positive, converse-free GXQs, hardness combined complexity inherited
PTime-hardness TBox reasoning EL (Baader et al., 2005). matching upper
bounds, Proposition 33 allows us reduce Boolean GXQ answering checking entailments
form K0 |= q 0 q 0 BCQ containing one atom. next show that,
possible form q 0 , reduce latter problem checking entailment ELRO+
concept inclusions, decided PTime. following, c arbitrarily
chosen individual IK0 .
K0 |= A(a) K0 |= {a} v A.
699

fiStefanoni, Motik, Krotzsch, & Rudolph

K0 |= y.A(y) K0 |= {c} v >r .A.
K0 |= S(a, b) K0 |= {a} v S.{b}.
K0 |= y.S(y, b) K0 |= {c} v >r .S.{b}.
K0 |= y.S(a, y) K0 |= {a} v S.>c .
K0 |= y1 , y2 .S(y1 , y2 ) K0 |= {c} v >r .S.>c .
positive, converse-free CGXQs, hardness combined complexity given Theorem 31, matching upper bounds follow Theorem 23 Proposition 33.

7. Conclusions
paper, presented first CQ answering algorithm OWL 2 EL runs
PSpace, thus closing longstanding open question. algorithm based
innovative, succinct encoding regular role inclusions using bounded-stack PDAthat is,
finite automata extended stack fixed size. believe encoding interesting
right, used optimise popular OWL 2 DL reasoners. Moreover,
refined previously known PSpace lower bound CQ answering showing
problem remains PSpace-hard even query, TBox, ABox fixed (and
RBox varies); thus, identify role inclusions culprit problems
PSpace-hardness. Finally, showed positive, converse-free GXQs CGXQs
answered OWL 2 EL knowledge bases PTime PSpace, respectively;
interesting Bienvenu et al. (2014) showed adding converse operator
makes problem ExpTime-hard. Thus, least theoretical perspective, positive,
converse-free (C)GXQs seem provide adequate language querying OWL 2 EL
knowledge bases.
see two main open problems future work. First, drawing inspiration
succinct encoding role inclusions, shall extend combined approach
Stefanoni et al. (2013) OWL 2 EL thus obtain practical algorithm. Second, static
query analysis fundamental task query optimisation, shall study containment
problem graph queries ELRO+ constraints.

Acknowledgements
results article extension results published preliminary form Krotzsch et al. (2007) Proceedings 6th International Semantic
Web Conference (ISWC 2007). work supported Alcatel-Lucent; EU FP7
project OPTIQUE; EPSRC projects MASI3 , Score!, DBOnto; DFG project
DIAMOND (Emmy Noether grant KR 4381/1-1).

References
Anselmo, M., Giammarresi, D., & Varricchio, S. (2003). Finite automata non-selfembedding grammars. Proceedings 7th International Conference Im-

700

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

plementation Application Automata, CIAA02, pp. 4756, Berlin, Heidelberg.
Springer-Verlag.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). DL-Lite family
relations. J. Artif. Intell. Res. (JAIR), 36, 169.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. Kaelbling, L. P.,
& Saffiotti, A. (Eds.), Proceedings 19th International Joint Conference Artificial Intelligence (IJCAI 2005), pp. 364369, Edinburgh, UK. Morgan Kaufmann
Publishers.
Baader, F., Brandt, S., & Lutz, C. (2008). Pushing EL envelope further. Clark, K.,
& Patel-Schneider, P. F. (Eds.), Proceedings OWLED 2008 DC Workshop
OWL: Experiences Directions.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2010). Description Logic Handbook: Theory, Implementation, Applications.
Cambridge University Press. Paperback edition.
Baget, J.-F., Leclere, M., Mugnier, M.-L., & Salvat, E. (2011). rules existential
variables: Walking decidability line. Artif. Intell., 175 (9-10), 16201654.
Barcelo, P. (2013). Querying graph databases. Hull, R., & Fan, W. (Eds.), PODS, pp.
175188. ACM.
Barrett, C., Jacob, R., & Marathe, M. (2000). Formal-language-constrained path problems.
SIAM J. Comput., 30 (3), 809837.
Bienvenu, M., Calvanese, D., Ortiz, M., & Simkus, M. (2014). Nested regular path queries
Description Logics. Proc. 14th Int. Conf. Principles Knowledge
Representation Reasoning (KR 2014). AAAI Press.
Bienvenu, M., Ortiz, M., & Simkus, M. (2013). Conjunctive regular path queries
lightweight Description Logics. Rossi, F. (Ed.), IJCAI. IJCAI/AAAI.
Cal, A., Gottlob, G., & Kifer, M. (2013). Taming infinite chase: Query answering
expressive relational constraints. J. Artif. Intell. Res. (JAIR), 48, 115174.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M.,
Rosati, R., Ruzzi, M., & Savo, D. F. (2011). MASTRO system Ontology-Based
Data Access. Semantic Web, 2 (1), 4353.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2006). Data
complexity query answering Description Logics. Proc. 10th Int. Conf.
Principles Knowledge Representation Reasoning (KR 2006), pp. 260
270.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning efficient query answering Description Logics: DL-Lite family. J.
Autom. Reasoning, 39 (3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2013). Data
complexity query answering Description Logics. Artificial Intelligence, 195, 335
360.

701

fiStefanoni, Motik, Krotzsch, & Rudolph

Calvanese, D., De Giacomo, G., Lenzerini, M., & Vardi, M. Y. (2000). Containment
conjunctive regular path queries inverse. Proc. 7th Int. Conf.
Principles Knowledge Representation Reasoning (KR 2000), pp. 176185.
Calvanese, D., Eiter, T., & Ortiz, M. (2009). Regular path queries expressive Description
Logics nominals. Boutilier, C. (Ed.), IJCAI 2009, Proceedings 21st
International Joint Conference Artificial Intelligence, Pasadena, California, USA,
July 11-17, 2009, pp. 714720.
Calvanese, D., Vardi, M. Y., De Giacomo, G., & Lenzerini, M. (2000). View-based query
processing regular path queries inverse. Proceedings Nineteenth ACM
SIGMOD-SIGACT-SIGART Symposium Principles Database Systems, PODS
00, pp. 5866, New York, NY, USA. ACM.
Chandra, A. K., & Merlin, P. M. (1977). Optimal implementation conjunctive queries
relational data bases. Hopcroft, J. E., Friedman, E. P., & Harrison, M. A. (Eds.),
Proc. 9th annual ACM Symposium Theory Computing (STOC 77), pp.
7790, Boulder, CO, USA. ACM Press.
Cruz, I. F., Mendelzon, A. O., & Wood, P. T. (1987). graphical query language supporting
recursion. SIGMOD Rec., 16 (3), 323330.
Cuenca Grau, B., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P. F., & Sattler, U.
(2008). OWL 2: next step OWL. J. Web Sem., 6 (4), 309322.
De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rosati, R., Ruzzi, M., & Savo, D. F.
(2012). MASTRO: reasoner effective Ontology-Based Data Access. Horrocks,
I., Yatskevich, M., & Jimenez-Ruiz, E. (Eds.), ORE, Vol. 858 CEUR Workshop
Proceedings. CEUR-WS.org.
Eiter, T., Ortiz, M., & Simkus, M. (2012a). Conjunctive query answering Description
Logic SH using knots. J. Comput. Syst. Sci., 78 (1), 4785.
Eiter, T., Ortiz, M., Simkus, M., Tran, T.-K., & Xiao, G. (2012b). Query rewriting
Horn-SHIQ plus rules. Hoffmann, J., & Selman, B. (Eds.), AAAI. AAAI Press.
Fan, W. (2012). Graph pattern matching revised social network analysis. Deutsch,
A. (Ed.), ICDT, pp. 821. ACM.
Geffert, V., Mereghetti, C., & Palano, B. (2010). concise representation regular
languages automata regular expressions. Information computation, 208 (4),
385394.
Giese, M., Calvanese, D., Haase, P., Horrocks, I., Ioannidis, Y., Kllapi, H., Koubarakis, M.,
Lenzerini, M., Moller, R., Rodriguez-Muro, M., Ozcep, O., Rosati, R., Schlatte, R.,
Schmidt, M., Soylu, A., & Waaler, A. (2013). Scalable end-user access big data.
Akerkar, R. (Ed.), Big Data Computing. CRC Press.
Glimm, B., Lutz, C., Horrocks, I., & Sattler, U. (2008). Conjunctive query answering
Description Logic SHIQ. J. Artif. Intell. Res. (JAIR), 31, 157204.
Gottlob, G., Manna, M., & Pieris, A. (2014). Polynomial combined rewritings existential
rules. Proc. 14th Int. Conf. Principles Knowledge Representation
Reasoning (KR 2014). AAAI Press.
702

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Gottlob, G., & Schwentick, T. (2012). Rewriting ontological queries small nonrecursive
datalog programs. Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.), Principles
Knowledge Representation Reasoning: Proceedings Thirteenth International
Conference, KR 2012, Rome, Italy, June 10-14, 2012. AAAI Press.
Grosof, B. N., Horrocks, I., Volz, R., & Decker, S. (2003). Description Logic Programs: Combining logic programs Description Logic. Proceedings 12th international
conference World Wide Web, pp. 4857.
Gutierrez, C., Hurtado, C. A., Mendelzon, A. O., & Perez, J. (2011). Foundations
semantic web databases. J. Comput. Syst. Sci., 77 (3), 520541.
Harel, D. (1984). Dynamic logic. Gabbay, D., & Guenthner, F. (Eds.), Handbook
Philosophical Logic Vol. II, pp. 497604. Reidel Publishing Company.
Harel, D., Tiuryn, J., & Kozen, D. (2000). Dynamic Logic. MIT Press, Cambridge, MA,
USA.
Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2003). Introduction Automata Theory,
Languages, Computation - international edition (2. ed). Addison-Wesley.
Horrocks, I., Kutz, O., & Sattler, U. (2006). even irresistible SROIQ. Doherty,
P., Mylopoulos, J., & Welty, C. A. (Eds.), KR, pp. 5767. AAAI Press.
Horrocks, I., & Sattler, U. (2004). Decidability SHIQ complex role inclusion axioms.
Artificial Intelligence, 160 (12), 79104.
Johnson, D. S., & Klug, A. C. (1984). Testing containment conjunctive queries
functional inclusion dependencies. J. Comput. Syst. Sci., 28 (1), 167189.
Kazakov, Y. (2008). RIQ SROIQ harder SHOIQ. Brewka, G., & Lang,
J. (Eds.), KR, pp. 274284. AAAI Press.
Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2011). combined approach Ontology-Based Data Access. Walsh, T. (Ed.), IJCAI 2011,
Proceedings 22nd International Joint Conference Artificial Intelligence,
Barcelona, Catalonia, Spain, July 16-22, 2011, pp. 26562661. IJCAI/AAAI.
Kostylev, E. V., Reutter, J. L., & Vrgoc, D. (2014). XPath DL-Lite ontologies.
Bienvenu, M., Ortiz, M., Rosati, R., & Simkus, M. (Eds.), Informal Proceedings
27th International Workshop Description Logics, Vienna, Austria, July 17-20,
2014., Vol. 1193 CEUR Workshop Proceedings, pp. 258269. CEUR-WS.org.
Kozen, D. (1977). Lower bounds natural proof systems. FOCS, pp. 254266. IEEE
Computer Society.
Krotzsch, M. (2011). Efficient rule-based inferencing OWL EL. Walsh, T. (Ed.),
Proceedings 22nd International Joint Conference Artificial Intelligence (IJCAI11). AAAI Press/IJCAI. 26682673.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2007). Conjunctive queries tractable fragment
OWL 1.1. Aberer, K., Choi, K.-S., Noy, N., Allemang, D., Lee, K.-I., Nixon, L.,
Golbeck, J., Mika, P., Maynard, D., Mizoguchi, R., Schreiber, G., & Cudre-Mauroux,
P. (Eds.), Proceedings 6th International Semantic Web Conference (ISWC07),
Vol. 4825 LNCS, pp. 310323. Springer.
703

fiStefanoni, Motik, Krotzsch, & Rudolph

Libkin, L., Martens, W., & Vrgoc, D. (2013). Querying graph databases XPath.
Tan, W.-C., Guerrini, G., Catania, B., & Gounaris, A. (Eds.), ICDT, pp. 129140.
ACM.
Lutz, C. (2008). complexity conjunctive query answering expressive Description
Logics. Automated Reasoning.
Lutz, C., Seylan, I., Toman, D., & Wolter, F. (2013). combined approach OBDA:
Taming role hierarchies using filters. Alani, H., Kagal, L., Fokoue, A., Groth, P. T.,
Biemann, C., Parreira, J. X., Aroyo, L., Noy, N. F., Welty, C., & Janowicz, K. (Eds.),
International Semantic Web Conference (1), Vol. 8218 Lecture Notes Computer
Science, pp. 314330. Springer.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering Description Logic EL using relational database system. Boutilier, C. (Ed.), IJCAI
2009, Proceedings 21st International Joint Conference Artificial Intelligence,
Pasadena, California, USA, July 11-17, 2009, pp. 20702075.
Marnette, B. (2009). Generalized schema-mappings: termination tractability.
Paredaens, J., & Su, J. (Eds.), PODS, pp. 1322. ACM.
Mora, J., Rosati, R., & Corcho, O. (2014). kyrie2: Query rewriting extensional
constraints ELHIO. Mika, P., Tudorache, T., Bernstein, A., Welty, C., Knoblock,
C. A., Vrandecic, D., Groth, P. T., Noy, N. F., Janowicz, K., & Goble, C. A. (Eds.),
Semantic Web - ISWC 2014 - 13th International Semantic Web Conference, Riva
del Garda, Italy, October 19-23, 2014. Proceedings, Part I, Vol. 8796 Lecture Notes
Computer Science, pp. 568583. Springer.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity query answering expressive Description Logics via tableaux. J. Autom. Reasoning, 41 (1), 6198.
Ortiz, M., Rudolph, S., & Simkus, M. (2011). Query answering Horn fragments
Description Logics SHOIQ SROIQ. Walsh, T. (Ed.), IJCAI 2011, Proceedings 22nd International Joint Conference Artificial Intelligence, Barcelona,
Catalonia, Spain, July 16-22, 2011, pp. 10391044. IJCAI/AAAI.
Perez, J., Arenas, M., & Gutierrez, C. (2010). nSPARQL: navigational language RDF.
Web Semant., 8 (4), 255270.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering rewriting
Description Logic constraints. J. Applied Logic, 8 (2), 186209.
Rodriguez-Muro, M., & Calvanese, D. (2012). High performance query answering
DL-Lite ontologies. Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.), Principles
Knowledge Representation Reasoning: Proceedings Thirteenth International
Conference, KR 2012, Rome, Italy, June 10-14, 2012. AAAI Press.
Rosati, R. (2007). conjunctive query answering EL. Calvanese, D., Franconi, E.,
Haarslev, V., Lembo, D., Motik, B., Turhan, A.-Y., & Tessaris, S. (Eds.), Description
Logics, Vol. 250 CEUR Workshop Proceedings. CEUR-WS.org.
Rudolph, S., & Glimm, B. (2010). Nominals, inverses, counting, conjunctive queries or:
infinity friend!. J. Artif. Intell. Res. (JAIR), 39, 429481.
704

fiThe Complexity Answering CQs GXQs OWL 2 EL KBs

Simanck, F. (2012). Elimination complex rias without automata. Kazakov, Y.,
Lembo, D., & Wolter, F. (Eds.), Proceedings 2012 International Workshop
Description Logics, DL-2012, Rome, Italy, June 7-10, 2012, Vol. 846 CEUR
Workshop Proceedings. CEUR-WS.org.
Sirin, E., Parsia, B., Cuenca Grau, B., Kalyanpur, A., & Katz, Y. (2007). Pellet: practical
OWL-DL reasoner. J. Web Sem., 5 (2), 5153.
Stefanoni, G., Motik, B., & Horrocks, I. (2013). Introducing nominals combined
query answering approaches EL. desJardins, M., & Littman, M. L. (Eds.),
AAAI. AAAI Press.
ter Horst, H. J. (2005). Completeness, decidability complexity entailment RDF
Schema semantic extension involving OWL vocabulary. Web Semantics:
Science, Services Agents World Wide Web, 3 (2-3), 79115.
Tsarkov, D., & Horrocks, I. (2006). FaCT++ Description Logic reasoner: System description. Furbach, U., & Shankar, N. (Eds.), IJCAR, Vol. 4130 Lecture Notes
Computer Science, pp. 292297. Springer.
Urbani, J., van Harmelen, F., Schlobach, S., & Bal, H. E. (2011). QueryPIE: Backward
reasoning OWL Horst large knowledge bases. Aroyo, L., Welty, C.,
Alani, H., Taylor, J., Bernstein, A., Kagal, L., Noy, N. F., & Blomqvist, E. (Eds.),
International Semantic Web Conference (1), Vol. 7031 Lecture Notes Computer
Science, pp. 730745. Springer.
Vardi, M. Y. (1982). complexity relational query languages (extended abstract).
Proceedings fourteenth annual ACM symposium Theory computing, STOC
82, pp. 137146, New York, NY, USA. ACM.
Venetis, T., Stoilos, G., & Stamou, G. B. (2012). Incremental query rewriting OWL 2 QL.
Kazakov, Y., Lembo, D., & Wolter, F. (Eds.), Proceedings 2012 International
Workshop Description Logics, DL-2012, Rome, Italy, June 7-10, 2012, Vol. 846
CEUR Workshop Proceedings. CEUR-WS.org.
Virgilio, R. D., Orsi, G., Tanca, L., & Torlone, R. (2012). NYAYA: system supporting
uniform management large sets semantic data. Kementsietsidis, A., & Salles,
M. A. V. (Eds.), IEEE 28th International Conference Data Engineering (ICDE
2012), Washington, DC, USA (Arlington, Virginia), 1-5 April, 2012, pp. 13091312.
IEEE Computer Society.
Wessel, M. (2001). Obstacles Way Qualitative Spatial Reasoning Description
Logics: Undecidability Results. Working Notes 2001 International
Description Logics Workshop (DL-2001), Vol. 49. CEUR-WS.org.

705


