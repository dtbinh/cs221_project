Journal Artificial Intelligence Research 51 (2014) 1-70

Submitted 2/14; published 9/14

Cooperative Monitoring Diagnose Multiagent Plans
Roberto Micalizio
Pietro Torasso

micalizio@di.unito.it
torasso@di.unito.it

Dipartimento di Informatica,
Universita di Torino
corso Svizzera 185, 10149 - Torino, Italy

Abstract
Diagnosing execution Multiagent Plan (MAP) means identifying explaining
action failures (i.e., actions reach expected effects). Current approaches
MAP diagnosis substantially centralized, assume action failures independent other.
paper, diagnosis MAPs, executed dynamic partially observable
environment, addressed fully distributed asynchronous way; addition, action
failures longer assumed independent other.
paper presents novel methodology, named Cooperative Weak-Committed Monitoring (CWCM), enabling agents cooperate monitoring actions. Cooperation helps agents cope scarcely observable environments: agent
cannot observe directly acquired agents. CWCM exploits nondeterministic action models carry two main tasks: detecting action failures building
trajectory-sets (i.e., structures representing knowledge agent environment recent past). Relying trajectory-sets, agent able explain
action failures terms exogenous events occurred execution
actions themselves. cope dependent failures, CWCM coupled diagnostic
engine distinguishes primary secondary action failures.
experimental analysis demonstrates CWCM methodology, together
proposed diagnostic inferences, effective identifying explaining action failures
even scenarios system observability significantly reduced.

1. Introduction
Multiagent Plans (MAPs) adopted many applicative domains, Web services
service robots, whenever interactions among cooperative agents organized
advance (i.e., planned), order reach acceptable efficiency level execution;
consider instance, orchestrated Web services (Yan, Dague, Pencole, & Cordier, 2009),
assembling tasks (Heger, Hiatt, Sellner, Simmons, & Singh, 2005; Sellner, Heger, Hiatt,
Simmons, & Singh, 2006), service robotics (Micalizio, Torasso, & Torta, 2006). MAPs
therefore characterized cooperative team agents perform actions concurrently
order achieve common global goal.
use MAPs real-world scenarios, however, cope critical issue:
plan actions deviate expected nominal behaviors due occurrence
(unpredictable) exogenous events. deviations typically considered plan failures
since prevent agents reach goals. Indeed, although MAPs versatile
c
2014
AI Access Foundation. rights reserved.

fiMicalizio & Torasso

systems, particularly fragile: failure action easily propagate
system causing failures actions, even assigned different agents.
order make execution MAP robust (i.e., tolerant least exogenous
events), therefore important detect isolate action failures, provide human
user (or plan repair module) set possible explanations detected failures.
recent works (see e.g., Mi & Scacchi, 1993; Gupta, Roos, Witteveen, Price, & de Kleer,
2012; Micalizio, 2013) argued plan repair procedure effective
causes plan failure known (e.g., identified via diagnosis).
last decade, problem diagnosing execution MAP faced
different perspectives. Since seminal work, Kalech Kaminka (2003) focus
coordination failures introduce notion social diagnosis. Social diagnosis relies
abstract representation MAP hand, given terms behaviors, aims
explaining two agents selected conflicting behaviors. Kalech Kaminka
(2011) Kalech (2012) present alternative algorithms inferring social diagnosis.
approaches (see e.g., de Jonge, Roos, & Witteveen, 2009; Roos & Witteveen,
2009; Micalizio & Torasso, 2008, 2009) adopt explicit representation MAP terms
agents actions shared resources. particular, diagnostic framework, Roos
Witteveen (2009) de Jonge et al. (2009) consider action failures (i.e., actions
reach expected effects), introduce notion plan diagnosis. plan
diagnosis subset (already performed) actions that, assumed abnormal, make
plan execution consistent observations received far. Since set
observations possibly explained many plan diagnoses, Roos Witteveen (2009)
present criterion identifying preferred diagnoses based predictive power
diagnoses.
proposals, however, rely assumptions might limit applicability real-world scenarios. First all, assume form synchronization
among agents (e.g., synchronized selection behaviors, execution actions).
importantly, action failures assumed mutually independent. Furthermore,
particular case social diagnosis, agents cooperate exchanging
belief states, might critical issue keep information private. hand, framework proposed Roos Witteveen (2009),
diagnostic inferences substantially centralized.
paper aim relaxing assumptions extending relational-based
framework introduced Micalizio Torasso (2008, 2009). Similarly Roos Witteveen, adopt explicit representation MAP hand term agents actions
shared resources. differently them, action models include nominal well
faulty evolutions. argue rest paper, kind extended action
models subsumes action models proposed Roos Witteveen.
addition, aim fully distributed solution rely synchronized
execution actions (i.e., global clock available). distributed solution social
diagnosis proposed Kalech, Kaminka, Meisels, Elmaliach (2006).
work, however, form synchronization among agents required agents select
next behavior simultaneously. Moreover, agents cooperate sharing
belief states. proposal, coordination among agents achieved means
exchange direct observations agents. idea observation
2

fiCooperative Monitoring Diagnose Multiagent Plans

acquired agent used agents reasoning. understand
difference exchanging belief states direct observations, note
belief state interpretation observations made specific agent according
local knowledge. Since agent might partial knowledge environment,
belief states could ambiguous even erroneous. Therefore, agents exchange
beliefs, may propagate errors. Conversely,
coordination consists exchange direct observations, agents infer
beliefs without risk conditioned errors made others.
propose framework that, relying notion Partial-Order, Causal-Link
(POCL) Plans (see Cox, Durfee, & Bartold, 2005; Weld, 1994; Boutilier & Brafman, 2001),
limits number messages exchanged agents number causal links
existing actions assigned different agents.
proposal, communication plays central role assuring consistent
execution MAP, easing diagnostic task. consider environment agents operate scarcely observable, agents directly acquire
information small portion surroundings. Dealing scarce observations challenging solving diagnostic task situation might
prevent detection action failures. cope issue propose paper
strategy named Cooperative Weak-Committed Monitoring (CWCM), extends
weak-committed monitoring introduced Micalizio Torasso (2009). CWCM allows
agents cooperate agent infer outcome
actions (i.e., failure detection) pieces information provided agents.
soon failures detected, must diagnosed order identify
root causes. paper, propose local diagnostic process agent
diagnose failure actions without need interacting agents.
particular, diagnostic inferences take account failures different actions
may dependent. words, action failure indirect consequence (i.e.,
secondary failure) failure preceding action (i.e., primary failure). Identifying
primary secondary failures essential point view plan repair primary
failures root causes anomalous observed execution. principle, plan repair
recovers primary failures recover secondary failures. interesting property methodology process inferring primary secondary
failures performed autonomously agent, relying trajectory-sets built
cooperative monitoring.
1.1 Contributions
paper contributes diagnosis MAP execution many ways. First all,
paper shows extended action models proposed monitoring purpose
obtained compositionally nominal models actions, models
exogenous events affect actions. Thus, knowledge engineer take
advantage focusing models elementary components systems
(e.g., actions exogenous events), creating complex, extended, action models
composing elementary components.
3

fiMicalizio & Torasso

addition, proposed CWCM framework fully distributed: agent monitors
actions, central agent traces actions progress. Thus,
CWCM applied domains agents operate physically distributed
environments, hence centralized solution could impractical. Another important
feature CWCM asynchronous: neither assumption synchronized execution
actions, assumptions long actions last made. words, agents
share global clock. course, form synchronization still necessary
mutual exclusion required accessing critical resources. cases, however,
prefer use term coordination.
CWCM represents valid solution whenever diagnosis MAP performed
environments characterized scarce observability levels. fact, significant contribution
CWCM cooperative monitoring protocol enables agents acquire information system resources other. paper argue number
messages exchanged via cooperative protocol linear number inter-agent
causal links (i.e., causal dependencies existing pair agents).
last important contribution paper ability distinguishing primary secondary failures. Previous approaches (see e.g., Micalizio & Torasso, 2008; Roos
& Witteveen, 2009), fact, assume action failures independent other.
1.2 Outline
paper organized follows. Section 2 introduce basic multiagent planning
framework use starting point work. Section 3 basic framework
extended relaxing important assumptions. Section 4 formally presents Cooperative Weak-Committed Monitoring (CWCM) strategy, local diagnostic inferences
discussed Section 5. paper closes detailed experimental analysis Section
6, critical discussion related works Section 7.
paper includes Appendix briefly discuss CWCM
implemented means Ordered Binary Decision Diagrams (OBDDs) (Bryant, 1992,
1986), formally analyze computational complexity implementation.

2. Multiagent Planning: Basic Framework
section organized three parts. First, introduce basic notions Multiagent Planning terminology use throughout paper. Then, discuss
propositional planning language translated state-variable representation.
Finally, present basic strategy plan execution multiagent settings
highlight importance cooperation among agents even strong assumption exogenous event occurs. assumption relaxed Section 3.
2.1 Preliminary Concepts Multiagent Planning
Since interested diagnosing systems modeled multiagent plans,
begin discussion presenting framework developed within planning community
represent synthesize kind plans. worth noting planning problem
typically approached propositional terms: preconditions effects actions literals
4

fiCooperative Monitoring Diagnose Multiagent Plans

must true, respectively, application actions themselves.
Thus intuitively introduce section planning notions propositional terms,
however, Section 2.2, argue addressing problem plan execution,
convenient handle representation system terms state variables,
hence translate propositional framework state variables one.
important assumption holding throughout paper that, although observations gathered agents execution time partial, always correct;
elaborate point Section 3.1.
2.1.1 Multiagent Plans
Multiagent Plan (MAP) systems take account paper modeled
tuple S=hT , RES , P i, where:
team cooperating agents; agents denoted letters j;
RES set shared resources objects available environment;
assume resources reusable (i.e., consumable),
accessed mutual exclusion; note agents exchange pieces
information resources, space resource names common
language agents communicate;
P completely instantiated Partial-Order Causal-Link Plan (POCL) (Weld, 1994),
resulting planning phase ones Boutilier Brafman (2001)
Cox et al. (2005). sake simplicity, MAP P simplified structure
since involve concurrency non-concurrency constraints. precisely,
MAP P tuple hI, G, A, R, Ci where:
- set propositional atoms representing initial state system
planning time.
- G another set propositional atoms representing global goal achieved.
Note G conjunction sub-goals Gi agent charge of.
- set action instances agents execute; action
assigned specific agent . planning time, assume action
modeled terms preconditions pre(a) effects eff (a),
conjunctions grounded atoms (see PDDL level 1, Fox & Long, 2003).
rest paper, denote ail l-th action performed agent i.
- R set precedence links action instances; precedence link ha, a0
R means action a0 start completion action a.
- C set causal links form lk : ha, q, a0 i; link lk states action
provides action a0 service q, q atom occurring
effects preconditions a0 .
assume MAP P :
flaw-free: nominal execution P achieves G;
5

fiMicalizio & Torasso

safe respect use resources. Intuitively, say resource
res RES used safely iff execution step, res either assigned,
assigned exactly one agent. similar concurrency requirement (Roos
& Witteveen, 2009): two actions executed concurrently require
subset resources;
redundant actions: even though P necessarily optimal, contains
actions directly indirectly provide services help achievement goal.
means always exists chain causal links action
plan least one atom goal G.
guarantee resource safeness, introduce notion working sessions associated resources agents:
Definition 1 Let res resource RES , agent , working session
wshres,ii using res pair haio , aic actions Ai that:
aio precedes aic (i.e., aio aic , transitive closure precedence
relations R).
aio action Ai agent acquires res, modeled specifying
atom available(res) preconditions aio . Moreover, exists C
incoming causal link form hajk , available(res), aio i, ajk action assigned
agent j (possibly ajk a0 i.e., pseudo action whose effects determine
initial state system). Action aio opens working session. action
aih Ai aio aic (i.e., aio aih aic ), incoming causal link labeled
service available(res) coming action another agent j 6= i.
aic action Ai agent relinquishes resource res favor another
agent j 6= i. modeled means causal link haic , available(res), ajk C,
meaning action aic releases res one effects, available(res)
one preconditions ajk . Action aic closes working session. course,
agent release resource res one agent; i.e., outgoing link
haic , available(res), ajk unique. addition, action aih Ai aio aic ,
outgoing link labeled service available(res) directed towards action
another agent j.
action aih aio aic use res; i.e., res mentioned preconditions effects aih . precisely, causal link mentioning res two
actions aih aik Ai allowed aih aik belong working
session, namely, aio aih aik aic .
Given working session wshres,ii , denote opening closing actions
opening(wshres,ii ) closing(wshres,ii ), respectively. Two working sessions wshres,ii
ws0hres,ji consecutive, wshres,ii / ws0hres,ji , closing(wshres,ii ) provides opening(ws0hres,ji )
service available(res).
Proposition 1 MAP P satisfies resource safeness requirement resource
res RES, working sessions res totally ordered sequence
ws1hres,i1 / ws2hres,i2 . . . / wsnhres,in , agent ij (with j : 1..n).
6

fiCooperative Monitoring Diagnose Multiagent Plans

means that, independently agents accessing resource, two working sessions
resource res never overlap other. Possibly, agent
one session sequence, meaning agent acquires relinquishes resource
res many times along plan.
resource safeness requirement extension concurrency requirement introduced Roos Witteveen (2009). fact, concurrency requirement implicitly
imposes ordering two actions cannot performed simultaneously,
resource safeness imposes ordering blocks actions identified working session. necessary order model situations agent uses set resources
number consecutive actions cannot interleaved actions
agents. working session sort critical section cannot interrupted. worth
noting that, since working session associated single resource, since
constraint working sessions two resources, possible action
aic Ai closes two different working sessions. example, let wshres,ii ws0hres0 ,ii
two working sessions agent using resources res res0 , respectively; possible
action aic closing(wshres,ii ) closing(ws0hres0 ,ii ). addition, resource
res could released favor agent j, resource res0 could released favor
another agent k. modeled two causal links haic , available(res), ajx
haic , available(res0 ), aky i.
2.1.2 Local Plans
Since interested fully distributed framework plan execution plan
diagnosis, impose every agent knows portion P perform;
thus introduce notion local plan. Intuitively, local plan P projection P
actions assigned agent i; P therefore partitioned many local plans
agents . formally, given agent , local plan P assigned

, C i, represents portion
tuple P =hI , Gi , Ai , Ri , Clocal
, Cin

initial state known agent plan execution starts; Gi sub-goal assigned

agent i; Ai , Ri Clocal
meaning A, R C, respectively, restricted
, highlight causal

Cin
actions assigned agent i. remaining sets, Cout
dependencies existing actions agent actions assigned agents
maintains outgoing causal links modeling services agent provides
: Cout
maintains incoming causal links modeling services
agents with; whereas, Cin
agent receives agents. simplify plan structure, precedence links
actions different agents allowed R. This, however, real limitation
precedence links actions different agents could expressed causal links
exchanged service refers dummy resource.
rest paper consider local plan P partially ordered set
actions. However, assume agent perform one action per time,
rest paper index actions according execution step. words,
P executed sequence hai0 , ai1 , . . . , , ai i, ai0 ai two pseudoactions similar ones introduced Weld (1994). Action ai0 preconditions
effects coincide initial state known agent i; particular, pseudo-action
used determine initial set resources assigned agent i: link leaving
7

fiMicalizio & Torasso

ai0 labeled service available(resk ) denotes resk assigned agent i.
Action ai , hand, effects preconditions correspond sub-goal
Gi assigned i.
2.2 Translating Propositional Framework State-Variable
Representation
Although planning approaches literature relies propositional language
represent planning problems, adopt paper representation based multivalued state variables similar SAS+ approach introduced Jonsson
Backstrom (1998). reason choice stems fact multi-valued
variable implicitly encode mutual exclusion constraints among values domain:
variable assume one value given time. Thus, easier represent
evolution system state time sequence assignments values state
variables. solution effectively adopted diagnosis plans (Roos &
Witteveen, 2009), Helmert (2009) proven, restrictive since always
possible translate propositional representation set multi-valued state variables.
rest section briefly describe propositional planning language (see
e.g., Nebel, 2000) mapped state variables representation. Three main aspects
addressed: (1) represent agents states terms state variables rather
sets propositional fluents; (2) represent exchange services among agents;
(3) model actions terms state variables.
2.2.1 Mapping Atoms Variables
point view, action models system states represented terms
finite set multi-valued state variables, finite discrete domain.
Given MAP system S=hT , RES, P i, associate agents resources
RES set state variables; variables maps subset atoms
corresponding propositional representation.
follows current system state given values currently assigned
state variables agents resources. global view, however, inadequate
achieve fully distributed framework. thus introduce notion agent state,
captures portion system state relevant specific agent team.
agent associated set VARi variables. variable v VARi
finite discrete domain dom(v). state Sli agent given execution step l
therefore assignment values variables VARi . precisely, Sli (v) dom(v)
value assumed variable v VARi agent state Sli . partial agent state li
assignment values subset variables VARi .
Variables VARi partitioned two subsets: END ENV . Set END includes
endogenous state variables (e.g., agent position); whereas ENV includes variables
shared resources. partitioning global system state agent states,
state variables resources duplicated many copies agents
. Therefore, resource resk RES , exists private copy resik belonging
ENV . maintain consistency among private copies, rely two assumptions:
(1) MAP P flaw-free, (2) P satisfies resource safeness requirement. two
8

fiCooperative Monitoring Diagnose Multiagent Plans

assumptions induce variables ENV implicit constraint: execution step
one agent knows actual state given resource resk . consequence,
private copy resik keeps correct value. agents, resource resk
sight; modeled assigning value unknown local variables resk ;
namely, j 6= i, resjk =unknown. Thus consistency among different private
copies implicitly maintained.
course, agent j acquires resource resk agent i, comes know
actual state resource. values variables ENV fact exchanged
among agents. Section 2.3 present basic cooperative protocol enables
agents share knowledge resources preserving resource safeness
requirement; basic protocol later extended Section 4.5. Variables END ,
hand, refer agent i, framework cannot shared
agents.
2.2.2 Mapping Services Variables Assignments
Since adopt representation based state variables, service exchanged
two agents conveniently modeled value assignment resource variable. instance, causal link lk : hai , available(resk ), aj used propositional representation
model action ai Ai provides action aj Aj resource resk . link
rewritten state variables representation hai , resk = available, aj i, resk
name agents j refer specific resource RES . words,
resk sort meta-variable known agent agent j. course,
agent maps meta-variable resk private copy. precisely, means
link hai , resk = available, aj i, agent able communicate j change state
resource resk : agent j knows that, execution ai , private variable resjk
value available, meaning j use resk . worth noting available
special value, used agents exchanging resources. general, agents communicate
domain-dependent values state resource (e.g., position
block blocks world domain).
Relying state variables representation, identify set resources
available given agent l-th plan execution step availResi (l) = {resk
RES |Sli (resik ) = available}. next subsection focus coordination protocol
allows agents j exchange information shared resources.
2.2.3 Mapping Propositional Action Models Function-Like Models
Let Q subset state variables VARi , rest paper denote (Q)
space possible assignments variables Q, Q denote specific
assignment (Q); is, specific partial state agent i. rest paper
use premises(ali ) effects(ail ) denote subset status variables VARi
preconditions effects, respectively, action ail defined. Thus premises(ail )
represents specific assignment values space (premises(ail )). Note set
premises includes services must provided agents,
therefore correspond incoming causal links action ail . Similarly, set effects
9

fiMicalizio & Torasso

includes services agent provides agents with, encoded causal links
outgoing ail .
Given action instance ail Ai , deterministic (nominal) model ail mapping:
: premises(ail ) effects(ail )
fanom

l

premises(ail ) assignment variables premises(ail ) VAR representing
preconditions ail , effects(ail ) assignment variables effects(ail ) VARi
modeling effects action. assume effects(ail ) premises(ail );
substantial limitation, however. variable v, principle would
mentioned effects action model, mentioned premises
action allowing v assume possible value domain. reason
assumption clear Section 3.2 formalize notion exogenous events.
Since interested execution plans, reformulate applicability
action state (see Nebel, 2000) terms executability. Given agent state Sli ,
action instance ail Ai executable Sli (VARi ) iff Sli |= premises(ail ); indeed,
strong condition relaxed next section. Using terminology
Roos Witteveen (2009), say action ail executable Sli ail fully


enabled Sli . result execution ail enabled Sli new agent state Sl+1

(VAR ), called successor state:


(Sli \ effects(ail )) effects(ail ) Sli |= premises(ail )




Sli 6|= effects(ail ) 6|= ,

Sl+1
=




,
otherwise.

precisely, Sli \ effects(ail ) partial agent state obtained removing Sli
variables mentioned effects(ail ). partial state subsequently completed
. state
new assignments effects(ail ), yielding new (complete) agent state Sl+1
transformation, however, legal when: (1) action ail fully enabled Sli (i.e., Sli 6|=
Sli |= premises(ail )), (2) action effects consistent (i.e., effects(ail ) 6|= ).
Otherwise, new agent state undefined.

2.3 Plan Execution Nominal Conditions
actual execution MAP requires form coordination among agents.
decomposition global plan local plans, fact, allows agents execute actions fully distributed way without intervention global manager:
agents execute actions concurrently asynchronously (i.e., global clock required).
addition, differently previous approaches (see e.g., de Jonge et al., 2009; Micalizio
& Torasso, 2008), actions take single time slot completed execution globally synchronized, make assumption duration
action. Agent coordination therefore essential order violate precedence
causal constraints introduced planning phase. sake clarity, first
present basic coordination strategy assuming that:
10

fiCooperative Monitoring Diagnose Multiagent Plans




BaDE(P =hI , Gi , Ai , E , Clocal
, Cin
, Cout
i)
1. l 1
2. Sli
3. ail 6= ai
4.
Sli consume-inter-agent-messages(inbox)
5.
ail executable Sli
6.
execute ail

7.
Sl+1
fanom
(Sli )

l

8.
obsil+1 gather observations

9.
Sl+1
obsil+1 |=
10.
stop execution propagate failure
11.
end

12.
causal link lk Cout
lk : hail , v = d, ajm
13.
notify agent j achievement service v =
14.
v RES = available

15.
Sl+1
(v) unknown
16.
end
17.
end
18.
l l+1
19.
end
20. end

Figure 1: Basic Distributed Plan Execution (BaDE) strategy.
- action-based observability: even though agents complete view
environment, agent always able observe preconditions effects
actions performs. addition, observations assumed reliable correct.
denote obsil+1 set observations received agent l-th plus 1
execution step execution l-th action. observations obsil+1
thought sets value assignments variables effects(ail ). is,
variable v effects(ail ), assignment v = belongs obsil+1 ; dom(v);
- deterministic actions: actions never fail models precisely define
agent state changes;
- static environment: environment change consequence execution
agents actions.
three strong assumptions relaxed Section 3, present
complex coordination strategy guarantees consistent access resources even
actions fail.
2.3.1 Basic Coordination Protocol
coordination protocol adopt simple effective, exploits causal links
models, fact, exchange service/resource
P . outgoing link Cout
agent - service provider - another agent j - service client. order support
communication among agents, assume agent inbox, i.e., folder
messages coming agents stored. Whenever executes action
, sends message outgoing link ai notifying
ail outgoing links Cout
l

receiver needed service/resource available. Likewise, link Cin
11

fiMicalizio & Torasso

models exchange service/resource receiver another agent j
, waits
provider. Whenever execute action incoming links Cin
message links since action becomes executable required
services/resources provided. assumptions made MAP P ,
protocol guarantees resources always accessed consistently. fact, assumption
P satisfies resource safeness requirement, assures working sessions
resource totally serialized; particular, two working sessions wshres,ii /ws0hres,ji
serialized means causal link hclosing(wshres,ii ), res = available, opening(ws0hres,ji )i.
Therefore, wshres,ii closes, agent notifies agent j resource res available.
2.4 Basic Distributed Plan Execution (BaDE) Strategy
high-level plan execution strategy performed agent team outlined
Figure 1. strategy consists loop iterates long actions
P executed. first step loop acquire new information
agents shared resources. accomplish task, agent plays role client
coordination protocol gathers notification messages, any, sent
agents; notification messages (i.e., value assignments convey) asserted
within current agent state Sli updates local view system status
acquires (if available) new resources. step, next action ail selected:
ail executable yet, agent keeps waiting notification messages (i.e.,
services/resources still missing). Otherwise, agent executes ail real world,

. (Note
exploiting nominal model fanom
estimates successor state Sl+1

l

actual execution ail real world may take time necessarily
known advance.)
action ail completed, agent gathers observations efi .
fects action matches observations estimated successor state Sl+1
Since assuming actions cannot fail, discrepancy observations
estimations discovered. include control line 9 compatibility
extension described sections 3 4, actions may fail.
execution ail , agent plays role provider coordination protocol
propagates (positive) effects action ail towards agents sending notificai (see lines 13 16 algorithm
tion message outgoing link ail Cout
Figure 1). particular, case agent released resource (v RES), agent
sets private copy resource unknown, way resource becomes
unreachable mutual exclusive access guaranteed.
last remark basic strategy regards increment counter l. Note
l incremented action executed; thus l correspond metric
time, pointer next action performed. Adhering BaDE strategy,
agent conclude local plan within finite amount time.
Proposition 2 Let = hT , RES, P MAP system P flaw-free satisfies
resource safeness requirement. agents follow BaDE strategy Figure 1,
P successfully completed finite amount time.
12

fiCooperative Monitoring Diagnose Multiagent Plans

Proof: sufficient show least one action P always execution,
step, achievement goal. contradiction, let us assume goal
reached, action progress. Since assume failure
occur, situation happen agents deadlock, waiting services
one provide with. deadlock may arise either erroneous planning
phase, P flaw-free initially assumed, BaDE coordination
strategy erroneous. Let us show agents adopt BaDE strategy,
failure occurs, agents never wait indefinitely accessing resource. Since P satisfies
assumption resource safeness requirement, must hold wshres,ji / wshres,ii ; i.e.,
closing(wshres,ji ) provides opening(wshres,ii ) (i.e., ail ) service res = available. Agent
waits service res = available two situations: (1) agent j performed
action closing(wshres,ji ) yet (correct behavior), (2) agent j already performed action
closing(wshres,ji ), sent appropriate message i. second case contradicts hypotheses agents adopt BaDE coordination protocol. fact,
required protocol, whenever working session wshres,ji closes, agent j send
message next agent accessing resource.
Therefore, agents never deadlock, least one action always execution,
since P finite number actions, goal G must achieved within finite amount
time.

Example 1. conclude section briefly exemplifying concepts introduced
far. particular, present office-like domain used test scenario
experiments (Section 6), domain similar ones adopted Micalizio (2013)
Steinbauer Wotawa (2008). domain, robotic agents deliver parcels
desks number clerks. robot carry one two parcels depending whether
heavy light, respectively. Figure 2 shows office-like environment used
tests; includes: 9 desks, distributed 5 office-rooms, connected
means 8 doors. Moreover, two repositories contain 12 parcels delivered
(8 light 4 heavy). Parcels, repositories, doors, desks critical resources
used accessed one agent per time. domain includes three
parking areas, locations agents positioned simultaneously
critical resources. (The term location used identify either parking areas
resources agent physically positioned; e.g., parcels locations.)
Agents perform following actions: move location another, load/unload
parcels within resources locations (i.e., parking areas), addition,
impose one parcel positioned desk, repositories
unlimited capacity. Finally, agents carry one heavy parcel two light parcels
location another.
Figure 3 shows simple example MAP office domain. team involves three
agents A1, A2, A3, whose plans given three columns, respectively.
bottom picture effects pseudoaction a0 represent initial states three
agents. top picture, premises pseudoaction represent desired
final state. objective MAP figure deliver parcel1 desk3 (i.e.,
agent unload parcel1 positioned desk3), bring parcel back
initial position repository repos1. Similarly, parcel2 first delivered desk6,
13

fiMicalizio & Torasso

Figure 2: office-like environment used experiments: five rooms R1-R5, two
repositories: repos1 repos2, eight doors, nine desks, three parking areas.

brought back repository repos2; parcel3, already delivered
desk3, delivered desk4. ease readability picture, show
inter-agent causal links. use two different graphical notations distinguish
causal links giving access resources (diamond-headed), causal links model
kinds services (black-circle-headed). instance, link actions a13
a24 diamond-headed, means action a13 provides a24 service desk3 = available
(i.e., a13 , agent A1 longer access desk3). three dashed rectangles
picture represent working sessions associated resource desk3, used
three agents different execution steps. (The working sessions resources
highlighted avoid picture becoming confused.)
Black-circle-headed links used represent services. instance,
1 encodes service desk3.content=empty,
link actions a12 a25 (labeled )
required action a25 since one parcel located desktop. link labeled
2 (from a25 a37 ) encodes two services: desk3.content=parcel1 parcel1.pos=desk3.

3 refer desk6 parcel2.
Similar services encoded link ,


3. Extending Framework
previous section described simple coordination strategy guarantees
consistent execution MAP P three strong assumptions hold: (1) agent
action-based observability: precisely observe preconditions effects
actions performs; (2) environment static (no exogenous events permitted);
(3) actions deterministic (no deviation nominal behavior possible).
Henceforth extend basic framework relaxing three assumptions and,
consequence, increasing complexity strategy controlling distributed
plan execution.
14

fiCooperative Monitoring Diagnose Multiagent Plans

parcel1.pos=repos1
parcel1.delivered=desk6
A3.pos=P1


parcel3.pos=desk4
parecel3.delivered=desk4
A1.pos=P2

parcel2.pos=repos2
parcel2.delivered=desk3
A2.pos=P3

a212

move(repos2, P3)

a211

a311

unload(repos2, parcel2)

a210

a17

move(repos1, P1)

repos2

a310

carry(desk6, repos2)

move(door2, P2)

a29

a16

unload(repos1, parcel1)
repos1

3


a39

load(desk6, parcel2)

move(desk4, door2)

carry(door1, repos1)

desk6

a28

a15

a38

move(door4, desk6)

unload(desk4, parcel3)

a27

a14

door4

move(P2, door4)

carry(door2, desk4)

1


a12

move(P2, desk3)

desk3

move(door4, desk3)

a35

unload(desk3, parcel1)

move(desk6. door4)

a24

a34

carry(door1, desk3)

unload(desk6, parcel2)

a23

a33

carry(repos1, door1)

A1.pos=P2
desk3=avail
desk4=avail
parcel3.pos=desk3
parcel3.delivered=desk3
door2=avail

load(desk3, parcel1)

a25

load(desk3, parcel3)
desk3

a37
a36

move(desk3, P2)

a11

parcel1

a26

a13
carry(desk3, door2)

carry(desk3, door1)

2


carry(repos2, desk6)

a22

a32

load(repos1, parcel1)

load(repos2, parcel2)

a21

a31

move(P1, repos1)

move(P3, repos2)

A2.pos=P1
repos1=avail
parcel1.pos=repos1
parcel1.delivered=no
door1=avail

A3.pos=P3
repos2=avail
parcel2.pos=repos2
parcel2.delivered=no
desk6=avail
door4=avail

a0

Figure 3: simple example MAP office-like domain used testing.

15

fiMicalizio & Torasso

3.1 Partial Observability
first assumption relax action-based observability. basic framework,
observations obsil+1 agent receives (l + 1)-th step execution cover
variables effects(ail ). extended framework, obsil+1 becomes partial since
subset variables effects(ail ) covered general, possibly obsil even empty.
case assume observations correct, meaning actual
state agent cannot inconsistent observations received agent itself.
However, observations ambiguous sense given variable, agent
receives disjunction possible values. addition, guarantee termination
plan execution phase, assume agent observes least achievement
atoms local goal Gi G.
3.2 Plan Threats
second extension dynamics system: move static system
dynamic one. means that, besides changes due agents actions,
system change consequence exogenous, unpredictable events, typically represent plan threats (Birnbaum, Collins, Freed, & Krulwich, 1990) nominal
execution plan. Intuitively, plan threat seen abrupt change happened
environment (i.e., resources), state agent.
paper associate occurrence exogenous event execution
action. words, exogenous event occur execution
action affect active variables action; namely, variables
mentioned within premises effects action. Thus, exogenous event
cannot affect simultaneously two actions, indirect effects many
actions, even different agents, means shared resources.
principle, given exogenous event , one could define model predict
affect execution action. real-world domains, however, always possible
precisely know advance actual impact exogenous event: one hand,
may non-deterministic effects; hand, effects may
known. take account possibly non-deterministic effects exogenous events,
model exogenous event relation happens defined follows:
happens (affectedby ) {} (affectedby )

(1)

affectedby VARi , (affectedby ) space partial agent states defined
affectedby . worth noting (affectedby ) empty affectedby
empty, too. enables us state that, exogenous event occurs, variable
affectedby must necessarily evolve unexpectedly. Thus, tuple relation happens
represents non-deterministic effect ; namely, tuple represents possible abrupt
change agents status variables.
deal known effects exogenous event , extend domain dom(v)
variable v VARi special value unknown leaves open possible
evolution v.
denote X set exogenous events might occur plan
execution. Note X includes pseudo event modeling absence abrupt
16

fiCooperative Monitoring Diagnose Multiagent Plans

changes. special event must hold affectedby = . Since exogenous
event defined state transition agents state variables, affect
action ail iff
affectedby effects(ail ).
(2)
Namely, affects subset variables action ail defined.
Given action ail , X (ail ) denotes subset exogenous events X satisfy
relation (2). Note that, pseudo event always included X (ail ), action
ail Ai , since affectedby (i.e., empty set) trivially satisfies relation (2).
3.3 Extended Action Models
last extension propose action models. Since plan threats occur
execution actions, effects combine actions effects. estimate
system evolves time, essential extend nominal action model order
encode, single piece knowledge, nominal well anomalous evolutions
action. Intuitively, extended model describe agent state Sli evolves

agent carried action instance ail , when,
new agent state Sl+1
execution action, exogenous event X occurred, possibly .
Moreover, basic framework give granted action performed
fully enabled. extended framework condition necessarily satisfied. Due
partial observability, fact, agent may unable precisely determine whether
next action fully enabled not. cope situation, introduce Section 3.4
concept possibly enabled action. time being, anticipate agent
may decide perform action even action fully enabled, hence
extended action model must rich estimate state agent evolves even
situation.
, given
extended model M(ail ) action ail derived nominal model fanom

l

terms premises effects, set exogenous events X (ail ); formally
defined as:
, X (ail ), (ail ), (ail )i,
M(ail ) : hfanom

l

X (ail ) already introduced; whereas (ail ) (ail ) two
fanom

l

transition relations partial states (premises(a)) (effects(a)),
possible predict execution action ail changes state
environment (i.e., resources held i) agent itself.
Relation (ail ) estimates next agents states action ail fully enabled
state Sli . relation results combination nominal action model
models exogenous events X (ail ):
(ail ) =

[

happens }
{fanom

l

X (ail )

(3)

Intuitively, fanom
happens set tuples form hpre, , eff i, pre equals

l

premises(ail ), eff (effects(ail )) models abrupt changes caused event
17

fiMicalizio & Torasso

nominal effects action ail . Formally, happening h, , 0 happens holds:


premises(ail ) {} {(effects(ail ) \ affectedby ) 0 }




[
Sli |= premises(ail ) premises(ail ) |= ;
fanom
fihappens =

l


h,,0 ihappens

otherwise.

(4)
important note that, since always part X (ail ), nominal model hpremises(ail ),
, effects(ail )i always included (ail ). particular, state transition, variable assume value unknown. follows directly by: (1) nominal model fanom

l

cannot mention unknown value definition, (2) exogenous event cannot
happens
affect variable since affectedby empty. Thus, operation fanom

l
reproduces nominal behavior.
addition, note X (ail ) include special exogenous event ? . symbol
denotes indefinite exogenous event model given, hence variables
effects(ail ) mapped unknown: occurrence ? prediction possible.
Relation (ail ) structure (ail ) terms preconditions, effects
exogenous events, represents dual version (ail ) since defined ail
executable Sli . fact, (ail ) defined states action ail enabled.
Let (premises(ail )) space assignments values variables premises(ail ),
(ail ) defined space states (premises(ail ))=(premises(ail )) \ premises(ail )
as:
(ail ) (premises(ail )) {? } hunknown, . . . , unknowni,
(5)
? denotes indefinite exogenous event . Note (ail ) weaker model
(ail ) since invariably assigns unknown value variable effects(ail ).
say, whenever action performed wrong configuration, impact
effects(ail ) variables becomes unpredictable. Although use symbol ? denote
indefinite events occurring (ail ) , slightly different meanings
diagnostic point view discussed detail Section 5.
Remark 1. relational action models propose sufficiently flexible deal
incomplete imprecise knowledge. many cases, fact, may costly (or even
impossible) determine exogenous events impact variables effects(ali ).
extended framework copes problem allowing three forms incompleteness:
- unknown value included domain variable allows represent that,
effect exogenous event, value variable becomes predictable.
extreme case, variables effects action set unknown
(see weak model exogenous event ? ).
- Non-deterministic action evolutions defined: exogenous event may
non-deterministic effects states agents.
- weak relation allows us model status agent execution
action wrong conditions.
18

fiCooperative Monitoring Diagnose Multiagent Plans

Remark 2. Since actions performed even though fully enabled,
guarantee execution plan violate resource safeness
requirement? answer question coordination protocol part
Cooperative Weak-Committed Monitoring (CWCM) strategy discussed Section 4.
useful anticipate, however, coordination protocol guarantees agent
uses resource actions violate resource safeness requirement.
Example 2. Let us consider simple example office domain, assume
agent A1 charge performing action carry(A1, Parc2, desk1, desk2);
action requires A1 move current position desk1 position desk2
loaded parcel Parc2. nominal model action expressed
state transition:
hpos = desk1, cObj=Parc2, Parc2pos1=A1, , pos = desk2, cObj=Parc2, Parc2pos1=A1i;
pos cObj two endogenous variables A1 representing current position
agent carried object, respectively. state shared resource Parc2
encoded variable Parc2pos1, private variable agent A1 keeps maintain
position parcel Parc2. agents, local copy variable Parc2pos
unknown.
actual execution carry action affected number exogenous
events; instance, wheelsblocked prevents agent moving all, wrongstep
allows agent move, wrong direction. Another event affect
carry action lostparcel : agent moving, carried object(s) lost; finally,
? denotes unpredictable event occurring carry action attempted state
preconditions satisfied. alternative situations summarized
within extended model showed Table 1. first entry table nominal
state transition, one labeled . Entries 2 5 describe action
behaves known exogenous event occurs. Note that, although exogenous
event one foreseen possibilities, effects may precisely known;
instance, effect wrongstep lostparcel variables assume value
unknown. first five entries table represent relation extended model.
last entry table, instead, relation allows us make weak
predictions. tuple hpos=*, cObj=*, Parc2-place=*i shortcut represent
possible assignment preconditions satisfied. Note that, practical
point view, necessary compute (potentially huge) set explicitly,
discuss Appendix implementation.

3.4 Extending Basic Concepts
Since relaxed three assumptions basic framework, review
three important concepts: state agent, executability action,
outcome action.
19

fiMicalizio & Torasso

END

t1
t2
t3
t4
t5
t6

ENV

END

ENV

pos

cObj

Parc2pos1

event

pos

cObj

Parc2pos1

desk1
desk1
desk1
desk1
desk1
*

Parc2
Parc2
Parc2
Parc2
Parc2
*

A1
A1
A1
A1
A1
*



desk2
desk1
unknown
desk2
desk2
unknown

Parc2
Parc2
Parc2
empty
empty
unknown

A1
A1
A1
desk1
unknown
unknown

wheelblocked
wrongstep
lostparcel
lostparcel
?

Table 1: extended model action instance carry(A1, B2, desk1, desk2)
office domain.

3.4.1 Agents Belief States
First all, agent team must able deal form uncertainty.
Since actions may evolve non-deterministically since agent cannot observe
effects actions, agent must able deal belief states rather agent
states. agent state Sli , agent belief state Bli encodes knowledge agent
l-th execution step. Sli precise state assumed step
l, Bli set possible agent states consistent observations received i.
rest paper use lowercase indicate agent state among others within given
belief state, use uppercase indicate actual agent state given execution
step. important note that, exactly agent state Sli , belief state Bli defined
state variables agent i; two states s1 s2 Bli differ least one
variable. words, must exists least one variable v VARil s1 (v),
value assumed v s1 , different s2 (v). course, ambiguity represents
issue understanding whether next action ail executable.
3.4.2 Possibly Enabled Actions
Since agent belief state Bli , notion action executability needs
revised. conservative policy would require action ail fully enabled every
state Bli ; due partial observability condition might satisfied,
execution MAP could stopped action enabled even though plan
threat occurred.
avoid situation, propose optimistic policy introduce notion
possibly enabled action.
Definition 2 Optimistic Policy Action ail possibly enabled Bli iff Bli
ail fully enabled s; namely, |= premises(ail ).
worth noting value unknown cannot used qualify action fully
enabled. value, fact, used explicitly state agent know
value variable. Therefore, variable v value unknown state s, v
mentioned premises(ail ), ail fully enabled s.
possibly enabled action therefore sort conjecture: since action premises
satisfied least one state belief state, action assumed executable.
20

fiCooperative Monitoring Diagnose Multiagent Plans

course, may case s, although possible, real state agent,
hence action performed preconditions satisfied real world.
3.4.3 Action Outcome
basic framework given granted outcome action always
nominal. extended framework, however, actions fail. individuate three possible action outcomes: nominal ok, anomalous failed, pending intermediate
situations.
, |= effects(ai ).
Definition 3 Action ail outcome ok iff Bl+1
l

(estimated execution ail ).
is, actions effects hold every state Bl+1

Definition 3 hold exists least one state Bl+1
nominal
effects satisfied. previous approaches (Micalizio & Torasso, 2008, 2007a),
introduced adopted strong committed policy: effects action ail
, action outcome failed (see
satisfied state belief state Bl+1
Definition 3). strong committed policy based assumption that, whenever action
ail successfully completed, agent receives amount observations sufficient
detect success. Thereby, success cannot detected, failure must
occurred.
policy, however, may unacceptable real-world domains
guarantees system observability. consequence, agent could infer failure
even action ail completed success, observations sufficient
confirm it.
paper define failure action dual case success:
, 6|= effects(ai ).
Definition 4 Action ail outcome failed iff Bl+1
l

state expected effects ail
Namely, possible find Bl+1
achieved.
situations neither success (Definition 3) failure (Definition
4) inferred, action outcome pending.
, |= effects(ai ) s0 B ,
Definition 5 Action ail outcome pending iff Bl+1
l+1
l
0

6|= effects(al ).

words, whenever agent unable determine success failure
action ail , postpones evaluation action outcome step future;
action enqueued list pActsi pending actions maintained agent i. refer
policy weak committed since agent take decisions whenever
insufficient observations sufficient support them. next section discuss
impact weak committed policy monitoring task.

4. Cooperative Weak-Committed Monitoring
section discuss fully distributed approach problem monitoring
execution MAP. consider extended framework previously discussed introduces two sources ambiguity: agent belief states, ambiguous action outcomes.
21

fiMicalizio & Torasso

cope forms uncertainty, propose monitoring methodology called
Cooperative Weak-Committed Monitoring (CWCM), relies weak-committed
policy. CWCM approach allows agent detect outcome action
time execution. idea possibly uncertain knowledge agent
environment refined time exploiting observations
agent receive future. get result, CWCM allows team members
cooperate monitoring tasks.
rest section organized follows. first formalize notion trajectoryset maintained agent, explain extended action models used
extend trajectory-set one step further. discuss trajectory-set
refined observations helps determining outcomes
pending actions (if any). Finally, redefine cooperative protocol sketched basic
framework obtain cooperative monitoring protocol. CWCM entirely formalized
terms Relational Algebra operators. (For short introduction used operators, see
Micalizio, 2013.)
4.1 Trajectory-Set
weak-committed approach requires agent able reason past.
means agent cannot maintain last belief state, keep
trajectory-set; i.e., sequence belief states traces recent history agents
state.
define trajectory-set generalization agent trajectory. agent trajectory
agent i, denoted tr (1, l), defined segment [ai1 , . . . , ail1 ] local plan P ,
consists ordered sequence agent states interleaved exogenous events X
(including ). agent trajectory represents possible evolution status agent i,
consistent observations agent received far; formally:
Definition 6 agent trajectory tr (1, l) plan segment [ai1 , . . . , ail1 ]
tr (1, l)=hs1 , e1 , s2 , . . . , el1 , sl
where:
- sk (k : 1..l) state agent k-th step obsik sk 6|= .
- eh (h : 1..l 1) event X (ah ) labeling state transition sh sh+1 .
agent trajectory therefore sequence agent states, interleaved events, traces
agent behavior along given plan segment. sake discussion, consider
plan segment starting first performed action ai1 ; practice, however, plan
segment consideration intermediate portion agents local plan.
return point Section 4.6.
Since state sk (k [1..l]) complete assignment values agent state
variables VARi , variables duplicated many times actions
plan segment consideration; following, denote VARik copies
state variables referring k-th execution step.
noticed above, however, partial system observability general sufficient
estimation unique trajectory; reason agent keeps trajectory-set r [1..l],
22

fiCooperative Monitoring Diagnose Multiagent Plans

contains possible agent trajectories tr (1, l) consistent observations received execution plan segment [ai1 , . . . , ail1 ].
Note that, given trajectory-set r [1, l], agent belief state execution step k
[1..l] easily inferred projecting r [1..l] state variables VARik :
Bki = projectVARi (T r [1..l])
k

(6)

Thus definitions 2 (possibly enabled actions), 3 (successfully completed actions), 4 (failed
actions), 5 (pending action), based belief states, still meaningful
require redefined.
rest paper, term trajectory frontier (or simply frontier) refers
last belief state maintained within trajectory-set. instance, frontier r [1, l]
belief state Bli . general rule, use l denote index last execution step
(and hence frontier); k used refer generic execution step [1, l].
4.2 Extending Trajectory-Set
extension trajectory-set corresponds predictive step basic framework
next agent state estimated. However, basic framework
step easy mapping state another, need complex procedure
extended framework. Given current trajectory-set r [1, l] extended
model M(ail ), estimation step defined Relational terms follows:
r [1, l + 1] = r [1, l] M(ail ) = r [1, l] join ((ail ) (ail )).

(7)

new trajectory-set r [1, l + 1] built contribution
relations. relations fact used estimate execution action ail changes
state system. Relation applied portion Bli action ail fully
enabled. Whereas, relation applied states Bli action ail
enabled; i.e., occurrence exogenous event already assumed.
4.3 Refining Trajectory-Set Observations
basic framework assumed that, whenever action ail completed, agent
. extended framework,
receives observation obsil+1 new agent state Sl+1
agent receive observation obsik referring past execution step k (i.e., 1 k l).
next section present cooperative monitoring protocol basis
message passing among agents. section discuss observation
past handled given agent i. Intuitively, consuming observation obsik means
selecting Bki states consistent it; Relational terms:
refined Bki = selectobsi Bki
k

(8)

result refined belief state less ambiguous original one number
states inconsistent observations pruned off.
important note unknown value consistent concrete observed
value. Therefore, state Bki , variable v unknown s, v mentioned
obsik , v assumes observed value obsik (v) refined Bki . Note allow
observed variable obsik assume value unknown.
23

fiMicalizio & Torasso

BlA1
s1l



s1l+1
wheelblocked
wrongstep

s2l

A1
Bl+1

s2l+1
s3l+1

lostparcel
lostparcel
?

s4l+1
s5l+1
s6l+1

Figure 4: one-step trajectory-set corresponding transition step l step l + 1.

Example 3. Let us consider office domain, assume l steps,
trajectory frontier agent A1 consists following belief state BlA1 :
s1l : h pos = desk1, cObj = Parc2, Parc2pos1= A1
s2l : h pos = unknown , cObj = Parc2, Parc2pos1= A1
Namely, BlA1 consists two alternative agent states s1l s2l . Let us assume
next l-th action performed A1 carry action, whose model previously
presented Table 1. According equation (7), easy see s1l matches
state transitions t1 t5 carry action model ( portion model), whereas
state s2l matches transition t6 ( portion model). Figure 4 gives idea
two relations used infer new frontier:
s1l+1 : h pos = desk2, cObj = Parc2, Parc2pos1 = A1
s2l+1 : h pos = desk1, cObj = Parc2, Parc2pos1 = A1
s3l+1 : h pos = unknown, cObj = Parc2, Parc2pos1= A1
s4l+1 : h pos = desk2, cObj = empty, Parc2pos1= desk1
s5l+1 : h pos = desk2, cObj = empty, Parc2pos1= unknown
s6l+1 : h pos = unknown , cObj =unknown, Parc2pos1=unknown
Now, let us assume agent A1 receives observation obsA1
l+1 = {hpos = desk2i},
used refine new frontier. easy see obsA1
l+1 consistent
states except s2l+1 , pos assigned different value. States s3l+1 s6l+1
consistent obsA1
l+1 unknown value consistent precise value.
new refined frontier therefore
s1l+1 : h pos = desk2, cObj = Parc2, Parc2pos1 = A1
s3l+1 : h pos = desk2 , cObj = Parc2, Parc2pos1 = A1
24

fiCooperative Monitoring Diagnose Multiagent Plans

s4l+1 : h pos = desk2, cObj = empty, Parc2pos1= desk1
s5l+1 : h pos = desk2, cObj = empty, Parc2pos1= unknown
s6l+1 : h pos = desk2 , cObj =unknown, Parc2pos1=unknown
seems s1l+1 s3l+1 identical, indeed consider single
belief states, trajectories; two states differ way achieved: s1l+1
inferred assuming everything goes smoothly; s3l+1 inferred assuming something
wrong occurred (i.e., wrongstep ). course, second hypothesis plausible
discuss next section pruned trajectory-set.

example shows consuming set observations obsik reduces ambiguity
within agent belief state Bki . addition, consumption messages
beneficial effect reducing ambiguity trajectory-set r [1, l]. fact, refined
belief state turn used filter trajectory-set follows:
refined r [1, l] = selectrefinedBi r [1, l].
k

(9)

refined r [1, l] maintains trajectories k-th step
state refined Bki . important result since agent take advantage
observations whenever available, even though refer past execution step.
may happen, fact, even though obsik enough determine outcome
action aik1 , another belief state Bhi refined r [1, l] becomes sufficiently precise
determine outcome pending action aih1 . next section, exploit
characteristic determine outcomes pending actions.
4.4 Inferring Propagating Action Outcomes
Whenever current trajectory-set refined observations, useful scan
pending action list pActsi , assess, action aik pActsi , whether either Definition
3 4 applies.
outcome action important piece information exploit,
well observations, refine current trajectory-set. outcome action aik , either
positive negative, fact used infer outcome actions pActsi .
reach result exploit notions causal predecessors aik (predecessors(aik )),
causal successors aik (successors(aih )). First all, say action aih indirectly
provides action aik service, aik indirectly receives service aih , iff
exists sequence actions aiv1 , . . . , aivn that:
1. aiv1 coincides aih
2. aivn coincides aik

.
3. action aivx , x : 1..n 1, exists causal link haivx , q, aivx+1 Clocal

words, must exist chain causal links starts aih , passes
actions sequence aiv1 , . . . , aivn , ends aik . Indirect causal dependencies pass plans agents considered definition.
example, two causal links haih , q, ajv hajv , q 0 , aik i, cannot say aih
25

fiMicalizio & Torasso

indirectly provides aik service since action ajv belongs agent j. limitation, advantage otherwise agents interact heavily order compute
indirect causal relations. notion indirect dependency actions basis
locality principle allows agent consider portion local plan
monitoring diagnosis.
set predecessors (aik ) therefore subset Ai including actions
directly indirectly provide aik service. side, successors(aik )
subset Ai including actions which, directly indirectly, receive
service aik .

Given action aik , denote chains to(aik ) subset causal links Clocal
defined


actions predecessors(ak ). Similarly, denote chains f rom(ak ) subset

defined actions successors(aki ).
causal links Clocal
Proposition 3 Let aik action whose outcome ok, causal links
chains to(aik ) represent services satisfied.
fact, aik outcome ok, services required aik satisfied,
recursively, services required actions predecessors(aik ) satisfied too.
Proposition 4 (Backward Propagation Success) Let aik action whose outcome ok, let us mark satisfied causal links chains to(aik ), action
pActsi predecessors (aik ) outgoing links marked satisfied, outcome ok,
too.
Proposition 5 Let aik action whose outcome failed, services
chains f rom(aik ) might missing.
fact, since aik outcome f ailed, least one expected effects missing;
hand, action aik could reached subset effects, services could
sufficient enable subsequent actions. forward propagation failure must
therefore take account results successfully achieved. Let us denote miss(aik )
set causal links leaving aik representing missing services.
Proposition 6 (Forward Propagation Failure) Let aik action whose outcome
failed, let us mark missing causal link cl chains f rom(aik ) reachable
one links miss(aik ) via chain missing causal links, unless cl already
marked satisfied. Then, action pActsi successors(aik ), least one
outgoing link marked missing, outcome failed, too.
Intuitively, properties 4 6 assume action performed fully
enabled produce correct results. hand, action achieves
effects must performed fully enabled, hence services
mentioned premises must provided.
26

fiCooperative Monitoring Diagnose Multiagent Plans

a2

2

a3

1
...

7

a1

a6

8

4

a4

3

a5

a7

...

6

5

.
Figure 5: portion local plan restricted causal links Clocal

Example 4. example show outcome action actually exploited
determine outcomes actions. course, agent able determine
outcome relying observations messages agents. cooperative
protocol discussed details following subsection; time being, important
observe that:
positive messages (formalized confirm messages following) received
given step processed negative message (i.e., disconfirm message)
received step;
agent receiving least one negative message stop execution plan,
start diagnostic phase.

shown,
Let us consider plan segment Figure 5, links Clocal
let us assume agent performs actions order a1 , a2 , a3 , a4 , a5 , a6 ,
actions pending. execution a5 , agent discovers a5
outcome ok. outcome propagated backwards: predecessors(a5 ) = {a1 , a4 }, thereby
links chains to(a5 ) = {4, 5} marked satisfied; course, link 6 marked
satisfied nominal outcome a5 . enables conclude action a4
outcome ok; whereas nothing concluded action a1 since links 1 7 neither
marked satisfied, missing. Let us assume receives observations
service link 1, consequence concludes a1 outcome failed.
case outcome propagated forwardly: successors(a1 ) = {a2 , a3 , a4 , a5 , a6 , a7 },
thereby chains f rom(a1 ) = {1, 2, 3, 4, 5, 6, 7, 8}; however, links 4, 5, 6 already
marked satisfied; addition, links 7 8 reachable via chain missing
causal links link 1; thus, links 2, 3 marked missing. Agent hence
concludes actions a2 a3 outcome f ailed. outcome inferred
action a6 , remains pending, outcome inferred action a7
performed yet. outcome pending action a6 inferred means diagnosis
inferences discussed Section 5.


Relying properties 4 6, determine outcome pending actions
exploiting causal dependencies existing among actions, even though
current trajectory-set still ambiguous apply either Definition 3 (outcome ok)
Definition 4 (outcome failed).
27

fiMicalizio & Torasso

Note discover action aih outcome ok, exogenous event occurred
action necessarily ; thus, filter r [1, l] follows:
refined r [1, l] = selecteh = r [1, l]

(10)

eh refers h-th exogenous event labeling transition state sh state
sh+1 r [1, l]. refinement (10) keep r [1, l] trajectories
h-th exogenous event . Thus keep transitions obtained
relation , prune spurious trajectories contributed relation .
hand, outcome action aih f ailed, cannot refine
trajectory-set via eh since know eh cannot , already implicitly
obtained thanks refinement equation (9).
Summing up, weak-committed methodology able deal scarce observations using two essential mechanisms. First, build trajectory-set maintaining
history agent state, keep list pending action outcomes. Second,
take advantage observations whenever available revising knowledge
agent itself; favorable case, revision process empty set
pending actions.
4.5 Cooperative Monitoring Protocol
last element CWCM methodology cooperative monitoring protocol
allows agent exploit information provided others. idea agent
take advantage direct observations, observations
agents environment, particular shared resources.
cooperative protocol plays central role preserving resource safeness requirement even actions fully enabled performed.
4.5.1 Interaction Scenarios
BaDE strategy, CWCM two agents, j, need interact
share causal link lk : hail , v = d, ajm v RES, dom(v), v =
value assignment representing change state resource requested agent
); whereas,
j. Contextually lk, agent plays service provider role (with lk Cout
j
agent j plays role service client (with lk Cin ). following first present
three interaction scenarios CWCM. shortly report messages
exchanged two agents. Then, present client provider roles detail
means high-level algorithms.
Notify-ready interaction interaction provider sure provided
client requested service. Thus, provider sends message habout lk notify
v = readyi client j; answer client provider required.
Notify-not-accomplished interaction scenario, agent sure requested
service missing; therefore sends agent j message habout lk notify v = notaccomplishedi client j; answer j foreseen.
Ask-if interaction case, provider unable determine whether
service v = achieved; thus asks j info sending j message
28

fiCooperative Monitoring Diagnose Multiagent Plans

cooperative-protocol::client(inbox, r [1, l], ail )
1. message m: h lk notify v = ready inbox s.t. lk incoming link ail
2.
remove inbox
3.
assert v = frontier r [1, l]
4. end
5. message m: h lk ask-if v = accomplished? inbox s.t. lk incoming link ail

6.
remove inbox
7.
unable observe v
8.
reply h lk no-info
9.
else
10.
obs observe v
11.
obs equals
12.
reply h lk confirm v =
13.
else obs equal
14.
reply h lk disconfirm v =
15.
end
16.
end
17. end
18. message m:habout lk notify v = not-accomplishedi inbox s.t. lk incoming message
ail
19.
remove inbox
20.
stop plan execution
21. end

Figure 6: pseudo-code cooperative protocol, client behavior.
habout lk ask-if v = accomplished?i. client reply message three
different ways:
1. habout lk confirm v = di, message confirms provider expected
service v = actually achieved;
2. habout lk disconfirm v = di expected service missing;
3. habout lk no-infoi client unable determine whether assignment
v = holds environment not.
case receives no-info message j, eventually reply either ready
message not-accomplished one.
4.5.2 Client Role
algorithm Figure 6 outlines behavior agent behaving client.
algorithm takes inputs inbox (i.e., collector messages coming agents),
current trajectory-set r [1, l], next action performed ail .
Agent consumes message inbox service required
premise execution ail . incoming message type ready (lines 1
4), agent uses information provided another agent observation, use
term assert (line 3) shortcut relational operations presented equations (8)
(9).
incoming message ask-if interaction (lines 5 17), agent determines whether capable observing v (e.g., equipped right sensor v?).
29

fiMicalizio & Torasso

case cannot observe v, replies provider no-info message. Otherwise,
agent acquires observation v, replies provider accordingly.
Finally, whenever agent receives not-accomplished message (lines 18 21),
stops execution plan service required performing ail missing.1
important note agent playing client consumes message
relevant next action performed. Thereby, ask-if message could
answered certain amount delay.
4.5.3 Provider Role
provider behavior outlined Figure 7. algorithm takes inputs inbox,
current trajectory-set r [1, l], list pending actions pActsi , last performed
action ail . precisely, last argument either null, action
performed recently, actual action instance whose outcome still assessed.
refine concept recently performed action next section present
main CWCM plan execution loop.
algorithm starts checking inbox order consume answers (if any)
previous ask-if interactions. algorithm specifies behavior agent according
type received message. case confirm messages (lines 1 5), agent uses
v = observation refine trajectory-set. term assert used
shortcut relational operations equations (8) (9); belief state
actually refined k-th +1; is, one contains effects action aik .
case disconfirm message (lines 6 10), agent prunes k-th +1 belief
state r [1, l] state v = holds. case incoming message
type no-info (line 11 18), agent checks whether outgoing links action

marked ans-no-info, meaning none services provided
aik Cout

ak agents achieved sure. case, agent marks aik
not-enough-info.
preliminary steps, agent possibly acquired information
others. Thus, assess outcome pending actions pActsi , including ail
null (line 19). algorithm Figure 8 outlines steps assessing outcomes
actions pActsi , discussed later on. sufficient say assess-pendingactions returns two lists actions, ok-list f ailed-list, empty, contain
actions whose outcome ok f ailed, respectively. course, whenever action pActsi
found either ok f ailed, removed pActsi , added corresponding
list. process involves actions previously marked not-enough-info.
action ail null (an action performed recently), first time
outcome ail assessed. Thus, case ail outcome pending (line 20), agent
starts ask-if interaction (lines 21-24) asking information agents
requires one services produced ail . Otherwise, ail null ail outcome
pending, ask-if interaction skipped.
line 25 line 34, agent sends ready not-accomplished messages
according actions ok-list f ailed-list, respectively. addition, agent sends
1. impact action failure estimated means failure propagation mechanism (Micalizio
& Torasso, 2007b). sake discussion, leave topic paper.

30

fiCooperative Monitoring Diagnose Multiagent Plans

cooperative-protocol::provider(inbox, r [1, l], pActsi , ail )
1. message m:habout lk confirm v = di inbox
2.
remove inbox
3.
let lk haik , v = d, ajm
4.
assert v = k-th +1 belief state within r [1, l]
5. end
6. message m:habout lk disconfirm v = di inbox
7.
remove inbox
8.
let lk haik , v = d, ajm
9.
prune k-th +1 belief state within r [1, l] state v =
10. end
11. message m:habout lk no-infoi inbox
12.
remove inbox
13.
let lk haik , v = d, ajm
14.
mark lk ans-no-info
15.
links outgoing aik marked ans-no-info
16.
mark aik not-enough-info
17.
end
18. end
19. hok-list, f ailed-listi assess-pending-actions(pActsi , r [1, l])
20. ail null outcome pending

21.
link lk:hail , v = d, ajm i, lk Cout
(i 6= j)
22.
send j message m:h ask-if v = accomplished?i
23.
end
24. end
25. action aik ok-list
26.
link lk : haik , v = d, ajm
27.
send j message m:habout lk notify v = readyi
28.
end
29. end
30. action aik s.t. (aik f ailed-list) (aik pActsi marked not-enough-info)
31.
link lk : haik , v = d, ajm
32.
send j message m:habout lk notify v = not-accomplishedi
33.
end
34. end
35. return hok-list, f ailed-listi

Figure 7: pseudo-code cooperative protocol, provider behavior.

not-accomplished message pending action aik marked not-enough-info. pending
action marked not-enough-info highlights scarcely observable environment is.
fact, neither agent i, agents waiting services provided aik , capable
determine whether least one expected services provided not.
deal ambiguity, agent prudentially considers action probably failed.
Although choice could seem strong, necessary preserve resource safeness
requirement scarcely observable environments. Agent evidence supporting
successful achievement effects expected ail , hence cannot notify
success. time, agents might waiting services provided ail ,
thus agents would stalling without even knowing it. Considering ail failed allows
get impasse notifying failure agents, may attempt
form plan repair.
31

fiMicalizio & Torasso

assess-pending-actions(pActsi , r [1, l])
1. ok-list {}
2. f ailed-list {}
3. action aik pActsi

4.
Bk+1
, |= effects(aik )
5.
ok-list ok-list {aik }
6.
r [1, l] selectek = r [1, l]
7.
oks propagateSuccess(pActsi , aik )
8.
ok-list ok-list oks
9.
pActsi pActsi \ oks

10.
else Bk+1
, 6|= effects(aik )
11.
f ailed-list f ailed-list {aik }
12.
faultypropagateFailure(pActsi , aik )
13.
f ailed-list f ailed-list faulty
14.
pActsi pActsi \ faulty
15.
end
16. end
17. remove, present, mark not-enough-info action ok-list f ailed-list
18. return hok-list, f ailed-listi

Figure 8: pseudo-code assessment pending actions.
algorithm terminates returning two lists ok-list f ailed-list calling
algorithm, shown Figure 10 discussed next section.
4.5.4 Assessing Action Outcomes
presenting main CWCM algorithm, shortly present algorithm assessing
pending actions pActsi given execution step. discussed earlier, assessment
relies properties 4 6, equation (10). algorithm shown Figure 8;
takes inputs list pending actions pActsi , current trajectory-set r [1, l].
algorithm returns two lists, ok-list f ailed-list, actions whose outcomes either
ok f ailed, respectively.
algorithm considers actions pActsi (if any), tests whether
action outcome ok f ailed. first case, success backward propagated
(line 7): oks list successfully completed actions discovered means propagation; actions removed pActsi added ok-list. second case,
failure forward propagated (line 12): faulty list faulty actions discovered means
failure propagation; actions removed pActsi added f ailed-list.
algorithm terminates returning two, possibly empty, lists ok-list f ailed-list.
mentioned above, action aik pActsi , previously marked not-enough-info,
found definitive outcome (ok f ailed). may happen because, although
agents provided information effects aik , agent could
exploit outcome propagation actions preceding following aik . course, mark
not-enough-info removed actions ok-list f ailed-list.
Proposition 7 (Protocol Correctness - Resource Usage) cooperative monitoring protocol guarantees resource safeness requirement never violated
32

fiCooperative Monitoring Diagnose Multiagent Plans

execution MAP P . words, shared resources used correctly throughout
plan execution even action failures occur.
Proof: Let us consider interaction scenarios, show
resources accessed consistently; namely, never happens two (or more) agents
access resource simultaneously.
Given causal link lk : haik , res = available, ajm i, interaction activated agent
depends outcome action aik .
notify-ready interaction equivalent interaction BaDE framework,
occurs aik outcome ok. case expected services achieved
sure. Thus, notifies j res available, already released res:
resource passed j consistently.
ask-if scenario occurs aik outcome pending, splits three cases.
1. Agent j (i.e., client) directly observes resource available. therefore
access resource safely mutual exclusion.
2. Agent j directly observes resource still occupied i. case j
attempt access res. resource used single agent resource
safeness requirement violated.
3. Agent j unable say whether resource res available. point view
j, state res unknown, hence, since preconditions ajm
satisfied, j keeps waiting information i. case res used
one agent.
last interaction scenario occurs aik outcome f ailed. case, notifies
j resource available: j try use res preconditions ajm
satisfied.

Proposition 8 (Protocol Correctness - Provided Services) Let j two agents
playing roles provider client, respectively, given causal link lk : haik , v =
d, ajm i. cooperative monitoring protocol enables two agents determine actual
value variable v least determine whether v different expected value d.
Proof: proposition proved considering different interaction scenarios
protocol. notify-ready interaction occurs agent conclude action
aik outcome ok. (This may happen means direct observations effects
aik , means backward propagation nominal outcomes.) Since action aik
outcome ok, effects, including v = d, achieved. ask-if interaction
occurs agent cannot determine outcome aik , hence truth value
statement v = known. case agent j charge determining whether
statement v = true false. Agent j reach result means direct
observations v. possible answers j three:
j directly observes v = d, thus service provided;
j directly observes v d, thus service provided;
33

fiMicalizio & Torasso

e3 =


B1A1
r A1 [1, 5]



B2A1
s2

2
3

B4A1

obsA1
4
B5A1


B3A1



s4

6

s8

s5

7

s9

11

s6

8

s10

12

s14

s7

9

s11

13

s15

s12
10
s13

4

s1
1

s3
5

Figure 9: trajectory-set kept agent A1 execution first four actions.
j unable observe v, case agent relies answers provided agents,
any, asked link. Agent conclude v = true
least one received answers allows conclude nominal outcome aik ;
otherwise, action assumed failed, hence service v = considered
missing.
last interaction scenario, agent directly observed, indirectly inferred means
forward failure propagation, v = false.

proposition considered sort generalization Proposition 7
applies possible services, services mentioning available value.
proposition important allows agents diagnose without
necessity interacting other, discuss Section 5.
Proposition 9 (Protocol Complexity) number messages exchanged among
agents linear number n inter-agent causal links.
Proof: provider-client interaction occurs agent, playing role
provider, performed action ail least one outgoing, inter-agent causal link.
number messages exchanged handling inter-agent causal link depends
outcome ail . ail either outcome ok f ailed, provider sends one message
client (i.e., ready not-accomplished, respectively). hand, ail
outcome pending, two agents exchange three messages: provider sends
ask-if, client answers no-info, provider either replies ready not-accomplished.
Thus worst scenario, number messages exchanged among agents 3n,
hence O(n).

Example 5. Let us assume execution first four actions, trajectoryset kept agent A1 one depicted Figure 9. trajectory-set contains 5 belief
states none sufficiently refined determine outcome action; thus,
actions currently pending. edges state another labeled
represent nominal progress plan execution; others instead, labeled
1 . . . 13 , model occurrence exogenous event (possibly ? ).
34

fiCooperative Monitoring Diagnose Multiagent Plans

show agent take advantage pieces information provided
others, let us assume agent A1 receives another agent observation obsA1
4
effects action a3 . instance, let us assume action a3 corresponds move
action, observation obsA1
4 refers position agent A1 execution
A1
a3 . Observation obs4 therefore used refine belief state B4A1 . example, s8
s9 states B4A1 consistent observation. Thanks
first refinement (see equations (8) (9)) able prune trajectories
pass either s8 s9; trajectories depicted dotted
edges. Dashed edges, hand, still possible trajectories still kept
within trajectory set.
However, refinement trajectory-set possible discover
refined B4A1 sufficiently precise determine action a3 outcome ok.
fact, A1s position conveyed observation obsA1
4 matches expected one;
means event e3 , affecting a3 , . pruning trajectory-set e3 =
(equation (10)), fortunate case B3A1 contains state s4 ,
nominal effects action a2 satisfied, too. backwards propagating success a3 ,
first a2 , a1 conclude three actions outcome ok.
fact, process, resulting trajectory-set maintains bold, solid edges;
whereas dashed edges pruned off. resulting trajectory-set, however,
allow us conclude anything a4 , still remains pending.

4.6 Cooperative Weak-Committed Monitoring: Main Algorithm
main CWCM algorithm outlined Figure 10. agent follows algorithm execute monitor local plan P .
initial steps set agent trajectory-set set pending
actions, algorithm iterates actions P far next action performed
coincides pseudo-action ai , meaning P completed. (Remind
assume actions P providing atoms premises(ai ) observable effects.)
beginning iteration, agent interacts agents (line 5) playing
client role cooperative protocol. step, agent consumes ready
not-accomplished messages (if any), acquires information resources required
perform next action ail . case agent receives not-accomplished message, stops
plan execution preconditions ail never satisfied. case
ask-if message received, agent establishes whether able observe required
service answers accordingly (see algorithms figures 6 7).
new information acquired asserted within agent trajectory-set,
agent assesses whether next action ail possibly enabled (Definition 2). positive
case, action performed real world (line 8). Subsequently, agent estimates
possible evolutions ail exploiting (ail ) (ail ) extend current
trajectory-set (line 9). completion action ail , agents direct observations
gathered obsil+1 (line 10) asserted extended trajectory-set (line 11);
case assert shortcut relational operations described equations (8)
(9). Action ail temporarily put list pending actions (line 12).
outcome assessment fact postponed step regards current pending actions,
35

fiMicalizio & Torasso

Cooperative-Weak-Committed-Monitoring(P )
1. l 1
2. r [1, l] //The initial belief state initial state agent
3. pActsi
4. ail 6=
5.
cooperative-protocol::client(inbox, r [1, l], ail )
6.
last null
7.
ail possibly enabled frontier r [1, l]
8.
execute ail
9.
r [1, l + 1] r [1, l] M(ail )// trajectory-set extension using (ail ) (ail )
10.
obsil+1 gather direct observations
11.
assert obsil+1 frontier r [1, l + 1]
12.
pActsi pActsi {ail }
13.
last ail
14.
l l+1
15.
end
16.
hok-list, f ailed-listi cooperative-protocol::provider(inbox, r [1, l], pActsi , last)
17.
f ailed-list 6= aik pActsi marked not-enough-info
18.
stop execution
19.
diagnose(P , pActsi , ok-list, f ailed-list, r [1, l])
20.
switch safe mode
21.
end
22. end

Figure 10: Cooperative Weak-Committed Monitoring: high-level algorithm.
activated even action executed. important note
iteration loop necessarily corresponds execution action.
seen, provider behavior cooperative protocol needs know whether
action recently performed (i.e., whether action performed
current iteration). purpose use variable last, set null
beginning iteration, set action ail action actually performed
(line 13). Whenever action performed, counter l incremented (line 14);
is, l-th plan execution step completed.
loop proceeds agent behaving provider (line 16). step
includes evaluation outcomes actions pActsi list (see algorithm
Figure 7). provider behavior returns two lists, ok-list f ailed-list, maintaining
actions outcome ok f ailed, respectively; course, lists could empty.
side effect, pActsi modified removing action whose outcome longer pending.
list f ailed-list empty, least one action pActsi marked notenough-info, agent stops plan execution, starts diagnostic process (discussed
Section 5), switches safe mode. agent safe mode perform actions,
interacts agents trying reduce impact failure. First all, agent
safe mode answers ask-if message no-info, prevents sender waiting
indefinitely answer. Moreover, agent safe mode releases many resources
possible sending appropriate ready messages; allows agents access
resources proceed plans. detailed discussion safe mode
scope paper, found works Micalizio Torasso (2007b)
Micalizio (2013).
36

fiCooperative Monitoring Diagnose Multiagent Plans

case failure discovered, actions performed far outcome
ok (i.e., pActsi gets empty), trajectory-set r simplified. fact, since
past actions nominal outcome, longer required keep whole past history
since beginning plan execution. Thus, safe convenient forget past
keep within trajectory-set frontier. implementation used
experiments adopts strategy keeping size trajectory-set manageable.
sake discussion, provide details point.
4.7 Cooperative Weak-Committed Monitoring: Correctness
conclude section discussing correctness algorithm Figure 10.
Theorem 1 [CWCM Correctness] CWCM assigns action aik outcome:
- ok iff action affected exogenous events;
- f ailed iff exogenous event, possibly ? , affected aik ;
- alternatively, CWCM marks pending action aik not-enough-info iff outcome
inferred relying observations agents, outcome propagation technique.
Proof: Part 1: action aik outcome ok iff aik affected exogenous events.
words, show aik reaches effects(aik ) iff ek = trajectory within
r [1, l], k : 1..l 1.
() contradiction, let us assume effects(aik ) reached, nominal
trajectory pruned r [1, l]. happen monitoring process
two ways: (a) observations, (b) outcome propagation. Let us
consider case (a), let us suppose monitoring phase agent receives observations obsik+1 consistent effects(aik ). effect pruning r [1, l] obsik+1 ,
nominal transition ek = pruned r 1 [1, l]; this, however, contradiction
definition extended model M(aik ), nominal transitions labeled
lead nominal effects(aik ). Thus, either obsik+1 inconsistent effects(aik ),
hence aik cannot ok, obsik+1 consistent effects(aik ) ek trajectories
within r [1, l].
Let us consider case (b), outcome propagation. two cases: backward
propagation ok, forward propagation f ailed. backward propagation ok
possibly assigns nominal outcome actions aik pActsi ; propagation, ek
equals trajectory within r , definition. forward propagation f ailed
possibly assigns nominal outcome actions aik pActsi ; propagation ek trajectory r [1, l]. two propagations cannot change
outcome action pActsi : action already assigned outcome, outcome cannot changed anymore. particular, aik outcome ok,
aih predecessors(aik ) discovered faulty, forward propagation f ailed cannot
prune ek = r [1, l]. fact, discussed Proposition 6, forward propagation
impacts causal links neither marked satisfied, missing,
along chain links starting one links miss(aih ). aik
assigned outcome ok, agent must received sufficient observations determine
premises aik satisfied. follows services required aik
37

fiMicalizio & Torasso

already marked satisfied. Thus, nominal transition ek = cannot lost
effect outcome propagation.
() aik affected exogenous event, hence eh = trajectory within
r 1 [1, l], aik outcome ok (i.e., reaches effects(aik )). construction, extended
model M(aik ) guarantees transitions labeled leads states
expected effects hold. follows that, ek = trajectories r [1, l], aik must
outcome ok necessarily.
Part 2: action aik outcome f ailed iff exogenous event, possibly ? , affected
execution. demonstrated following reasoning similar one Part 1;
omit brevity.
Part 3: action aik marked not-enough-info iff outcome inferred relying
observations agents, outcome propagation technique. easy see
CWCM marks aik not-enough-info one occasion: provider behavior,
answers gathered aik ask-if interaction no-info. exactly
means agent team provide information services provided
aik . hand, marking removed aik inserted either
ok-list f ailed-list; thus cannot happen action definite outcome
marked not-enough-info.

Theorem 2 Given MAP system = hT , RES, P i, P plan hI, G, A, R, Ci,
global goal G achieved iff actions outcome ok.
Proof: previous theorem demonstrated action outcome ok
effects achieved, outcome cannot changed
effect refinements trajectory-set. Thereby, global goal G
reached, actions must reached effects, hence must outcome ok.
fact, since assume P redundant action (i.e., action P contributes
G), sufficient least one action fails reaching one effect have: 1) least
one action outcome f ailed, 2) least one piece G achieved.
hand, actions outcome ok, G must achieved
necessarily. absurd, actions ok, G reached.
happen P flaw, produce G even nominal conditions,
initial assumptions (see Section 2) P flaw-free actually produces G.

Example 5 used clarify proof. example shown that,
restrict B4A1 belief state state satisfies expected effects action
a3 , action a3 outcome ok. time, outcome backward propagated
edges labeled lead B4A1 . action a4 last action A1s
plan, effects action must observable, hypothesis. Now, depending
available observations, agent A1 either conclude s12 actual state a4
(thereby: (1) goal reached, (2) trajectory-set contains one trajectory
edge labeled , (3) actions outcome ok), s13
actual agents state, hence least one action (i.e., a4 itself) must outcome f ailed.
Corollary 1 global goal G achieved, agent keeps trajectory-set
r [1, l] nominal trajectory hs1 , , s2 , . . . , , sl+1 i, s1 |= sl+1 |= Gi .
38

fiCooperative Monitoring Diagnose Multiagent Plans

Proof: follows two previous theorems. G reached, actions
outcome ok (Theorem 2). hand, since aik ok iff ek =
every trajectory within r [1, l] (Theorem 1), follows agent keeps
trajectory-set nominal trajectory.

correctness monitoring process therefore summarized following
statement: execution P affected anomalous event, cooperative
monitoring able keep trace progress achievement goal G since
nominal transition never lost. hand, execution P affected
least one anomalous event, even known advance, cooperative monitoring
able detect stop execution phase. addition, Proposition 7 assures
nominal, well anomalous, situations resources always accessed consistently.

5. Plan Diagnosis: Local Strategy
Plan diagnostic inferences start soon CWCM algorithm discovered failure
least one action (i.e., f ailed-list empty), pending action marked notenough-info. section discuss mean plan diagnosis,
inferred. propose distributed approach agent infers diagnosis
local plan autonomously. fact, thanks Proposition 8, plan execution safe
respect use resources, agent never blame agents explain
action failures.
5.1 Inputs CWCM
previous section focused monitoring purpose CWCM methodology. important note, however, CWCM produces useful pieces information
diagnostic point view. First all, actions f ailed-list could considered
plan diagnosis according definition Roos Witteveen (2009); namely, subset
actions assumed faulty explain observations. However, f ailed-list
take account action failures might indirect consequences
others. Thus, f ailed-list sufficient would isolate primary action
failures caused secondary action failures.
addition, CWCM produces trajectory-set r [1, l], seen set
consistency-based diagnoses (Reiter, 1987). trajectory r [1, l] possible
explanation agents behavior consistent observations received agent
itself.
5.2 Event-Based Explanations
Dealing directly r [1, l], however, might awkward since encodes possible explanations, including ones mentioning indefinite exogenous event ? ,
considered unlikely. Moreover, trajectories share sequence
events, differ state variables, considered completely different explanations. Thus, r [1, l] needs processed order useful. first reduction
r [1, l] given projecting event variables e1 , . . . , el1 ; call resulting
39

fiMicalizio & Torasso

structure Event-based Explanations (EVE):
EVE = projecte1 ,...,el1 r [1, l].

(11)

EVE set sequences exogenous events (including ? ). sequence
set possible consistency-based diagnosis anomalous behavior agent.
Since EVE could still contain huge number diagnoses, EVE informative
human user decide recover plan failure. One way
reducing number diagnoses would prefer diagnoses involve
minimum number exogenous events. Unfortunately, preference criterion would lead
misleading results events dependent one another. find meaningful
explanations, one identify exogenous events caused primary action failures
exogenous events correspond secondary action failures.
5.3 Minimum Primary Action Failures
facilitate identification primary action failures, distinguish indefinite
events ? contributed portion action model, indefinite events ? contributed portion. distinction necessary CWCM, turns
useful diagnostic purpose. Intuitively, ? denotes occurrence exogenous
event affecting execution (possibly) enabled action; ? therefore unknown
abrupt change affecting nominal behavior action. hand, ?
indefinite event use label state transitions action performed
state satisfying preconditions. Relying distinction, possible
identify primary failure means following definition.
Definition 7 action ak pActsi f ailed-list primary action failure iff exists
explanation x EVE x[ek ] 6= x[ek ] 6= ? , x[ek ] k-th event
explanation x.
words, action ak considered primary failure given event-based
explanation x EVE iff occurrence exogenous event mentioned (ak )
assumed x. Note Definition 7 examine set pending actions pActsi ,
including actions marked not-enough-info. addition, note set primary action
failures never empty. fact, agent starts diagnosis phase one
performed actions labeled failed. hand, agent stops
execution plan another agent fails providing service, first agent
exonerated diagnosing since none actions labeled failed,
root causes missing service located outside plan.
Secondary failures caused primary failure, defined follows:
Definition 8 Let x EVE possible explanation, let ak f ailed-list pActsi
primary failure x, actions ah successors(ak ) x[eh ] = ?
secondary failures caused ak according explanation x.
Note that, given primary failure ak explanation x EVE , actions
successors(ak ) necessarily secondary failures (see Proposition 4). fact, even though
ak achieved effects (i.e., outcome failed), action may reached
40

fiCooperative Monitoring Diagnose Multiagent Plans

them. consequence, actions successors(ak ) may enabled
despite failure ak . reason, Definition 8 require action ah
successors(ak ) labeled secondary failure exogenous event ? assumed
explanation x. definitions primary secondary failures proposition
follows directly.
Proposition 10 Given explanation x EVE , set primary action failures P rmx ,
set secondary action failures Sndx extracted x disjointed.
Relying proposition, define Primary Action Failure Diagnoses (PADs):
Definition 9 Let x EVE possible event-based explanation, primary action-failure
explanation (PAD) extracted x pair hP rmx , Sndx P rmx Sndx
sets primary secondary failures, respectively, extracted x.
course, since EVE general contains several explanations, since primary failures
assumed independent other, possible extract minimum cardinality
primary action-failure diagnoses (mPADs) simply selecting explanations
minimum set primary failures:
mP ADs = {P rmx x EVE |P rmx | minimum }

(12)

Minimum primary action failure diagnoses (mPADs) indeed mean plan
diagnosis: localize actions qualified failed order explain
anomalous observations.2
5.4 Refining Plan Diagnosis
inferred plan diagnosis, one refine diagnoses identifying root
causes. refined explanations expressed terms exogenous events,
extracted EVE set.
Definition 10 Let ah primary action failure, let EVE (ah ) set explanations x EVE ah P rmx , refined explanation action ah
refinedExp(ah ) =

[

x[eh ].

(13)

xEVE (ah )

words, refinedExp(ah ) consists exogenous events might
occurred execution action ah , hence might caused failure ah .
course, since ah primary failure, secondary failures caused ah
explained occurrence one events refinedExp(ah ).
2. Note different preference criteria could adopted select explanations EVE . instance, one
could prefer minimality rather minimum cardinality.

41

fiMicalizio & Torasso

a1

a2

a4

a3

a5

a7

a6

a8

Figure 11: portion local plan assigned agent
Example 6. Let us consider simple local plan Figure 11 assigned agent i.

. Let us assume that,
simplify picture show local causal links Clocal
execution local plan, agent detects failure action a8 . diagnostic
process activated order explain failure identifying (minimum) set
primary action failures. diagnostic process receives input list failed actions
f ailed-list={a8 }, list successfully completed actions ok-list={a4 }, list
pending actions pActsi = {a1 , a2 , a3 , a5 , a6 , a7 }. addition, diagnostic process
receives trajectory-set r [1, 9], simplicity show Table 2 set
event-based explanations (EVE ) extracted trajectory-set.
Table 2 easy see explanations, except last one, explain
failure action a8 indirect effect previous failure (i.e., a8 secondary
failure). last explanation considers a8 primary failure, unknown,
unlikely, exogenous event ? must assumed.
first step diagnostic process consists inferring set mP ADs diagnoses.
Thus, identify primary secondary failures explanation EVE :
P AD : { x1, x2 :
x3 :

h{a1 },

{a3 , a5 , a8 }i

h{a6 , a7 },

{a8 }i

x4 : h{a3 , a6 , a7 }, {a8 }i
x5 :

h{a2 },

{a7 , a8 }i

x6 :

h{a8 },

}

observe interesting consequences. First all, explanations EVE
collapsed within single explanation P ADs; see instance explanations x1 x2.
advantage reduce number alternative explanations. addition,
sets primary action failures used identify (subset-)minimal diagnoses.
instance, explanation {a6 , a7 } derived x3 minimal diagnosis, whereas explanation
{a3 , a6 , a7 } extracted x4 not. Finally, since assume primary failures
independent other, prefer subset-minimal diagnoses whose cardinality

x1
x2
x3
x4
x5
x6

a1
1
5





a2




4


a3
?
?

6



a4







a5
?
?





a6


2
2



a7


3
3
?


a8
?
?
?
?
?
?

Table 2: set EVE maintained within current trajectory-set
42

fiCooperative Monitoring Diagnose Multiagent Plans

minimal. example mP ADs = {{a1 }, {a2 }, {a8 }}. fact, thus sufficient
assume failure one actions explain observations.
step, action mP ADs, one infer refined diagnosis.
instance, easy see primary action failure a1 two alternative refined
diagnoses: either 1 5 (see Table 2); whereas primary action failure a2 4
single possible refined diagnosis. Finally, one assume occurrence ? explain
primary action failure a8 . Relying refined diagnoses, preference criteria could
employed conclude primary failure a8 less likely a1 a2 ,
hence could disregarded.

Note that, since agent able diagnose plan autonomously, plan
diagnosis global level could inferred combining local solutions inferred
agent team, integration guaranteed globally consistent. fact,
thanks Proposition 8 agent never blame another agent failure one
actions.

6. Experimental Analysis
far addressed CWCM methodology diagnostic inferences
declarative manner means relations Relational operators relations.
Relations simple, yet powerful formalism represent nondeterministic action models
ambiguous belief states. addition, used model complex
structures trajectory-set event-based explanations (EVE ).
comes actually implementing CWCM methodology, however, must
noticed computational complexity algorithm Figure 10 dominated
complexity (macro-)operator involved extension current trajectoryset. hand, diagnostic inferences based projection current
trajectory-set event variables (see equation 11). steps might computationally expensive, efficient implementation relations relational
operators therefore becomes essential. possible way cope issue translate
relations symbolic, hence compact, formalism, encode Relational operators operations selected symbolic formalism. Alternatively, may
possible exploit recent advancements Continuous Query Languages (CQLs) deal
data streams (see e.g., STREAM system Arasu, Babu, & Widom, 2006), implement CWCM relying primitives made available Data Stream Management
System hand.
paper, chosen method knowledge compilation, particular,
selected Ordered Binary Decision Diagram (OBDD) (Bryant, 1986, 1992) formalism encode relation Relational operators. choice justified two main
reasons: first, OBDDs nowadays well-known language made available many
mature libraries; second, theoretical results Darwiche Marquis (2002) suggest
OBDDs answer queries polynomial time provided sizes remain
tractable. in-depth description cooperative monitoring diagnosis
implemented via OBDDs reported Appendix.
rest section organized follows. First, Section 6.1, sketch
software architecture implementation; Section 6.2, present experimen43

fiMicalizio & Torasso

domain

initial
state

P

XML

XML

XML

DISPATCHER

A1

P A1

RA1

outcome assessment

CW CM

RAN

outcome assessment

...

CW CM

DIAGNOSIS

extend trj



P

r A1

DIAGNOSIS

extend trj

detected failure

r

detected failure

cooperative protocol messages

observations
observations A1

ANs next action

SIMULATOR

A1s next action

domain; initial state

XML

exogenous events

Figure 12: software architecture CWCM implementation used tests.

tal setting used carry tests, consisting simulated execution several
MAPs. Finally, discuss interesting results monitoring (Section 6.4),
diagnosis (Section 6.5).

6.1 Software Architecture Implementation
CWCM proposal implemented Java SDK 7 program. software
architecture shown Figure 12, highlighting main actors: Dispatcher, N
agents team (from agent A1 agent AN), Simulator. picture shows
internal architecture agents. Solid edges modules represent data flows,
dashed edges represents instead control flows, whereas dotted edge CW CM
abstracts messages exchanged agents cooperative monitoring.
simulation MAP P starts submitting Dispatcher module three XML files
containing, respectively, system domain (i.e., agents objects defined
scenario hand), system initial state (e.g., initial positions agents, initial
states resources, etc.), MAP P performed. Dispatcher decomposes
P local plans agent receive portion P interest.
particular, P decomposed, Dispatcher activates agents,
implemented threads, passing initial states local plans.
44

fiCooperative Monitoring Diagnose Multiagent Plans

OBDDs made available JavaBDD library 3 , provides java, easyto-use interface Java BuDDy 4 , popular mature library manipulating
OBDDs written C.
Besides agents, Dispatcher activates Simulator, implemented thread.
Differently agents, however, Simulator receives input plan,
initial state system. addition, Simulator reads fourth XML file
exogenous events injected plan execution. precisely,
file list agents actions, associated anomalous event
must occur execution action. course, subset actions
affected exogenous events mentioned file.
environment set-up, Dispatcher starts agents,
execute CWCM algorithm discussed Section 4. actual execution action
simulated Simulator: Whenever agent intends perform action,
sends message Simulator conveying action performed. Simulator
simulate action execution taking account possible exogenous events
injected. action associated observations, Simulator sends
corresponding agent appropriate message. worth noting Simulator,
agent, uses OBDDs estimate next state whole system according
actions currently progress. Differently agents, however,
Simulator always knows precise state agent resource system.
details use OBDDs handling relations given Appendix A.
discussed Section 4, whenever failure action detected agent i,
Diagnosis module agent activated. results diagnosis inferences,
discussed Section 5 saved report file Ri associated agent i.
experiments described following performed PC, Intel Core 2 Duo,
2.80 Ghz, 8 GB RAM equipped Windows 7 OS. test repeated ten times,
average values considered experimental analysis order absorb load
fluctuations CPU.
6.2 Experimental setting
domain used tests already introduced Example 1. actions
agent perform summarized Table 3 5 , reporting details
encoding action models OBDDs. precisely, # variables number state
variables OBDD defined; number includes one variable encoding
possibly anomalous event occurring action execution; remaining variables
used encode agent state transition step t, action starts, step t+1,
action ends. Columns #-nodes #-trans. report, respectively, number
nodes OBDD encoding portion action model, number state
transitions encoded . Columns #M-nodes #M-trans. refer whole extended
model M, including portion. domain, agent handles 36 variables
encode belief state environment.
3. http://javabdd.sourceforge.net/index.html
4. http://sourceforge.net/projects/buddy/
5. Examples test cases action models found
http://www.di.unito.it/micalizi/CWCM/index.html.

45

fiMicalizio & Torasso

move
carry
load
unload

# variables
15
19
17
17

#-nodes
193
346
386
386

#-trans.
34
38
40
40

#M-nodes
291
374
892
892

#M-trans.
420
1857
169
169

Table 3: details relational action models.
6.3 Objectives Experimental Analysis
least three main questions want get answered means
experiments. questions are:
CWCM scale well number agents team grows?
CWCM affected level system observability? extent?
cooperation among agents really useful monitoring purpose?
answer questions, carried tests varying three main characteristics:
team size, observability level, monitoring strategy.
6.3.1 Team Size
assess scalability CWCM, generated MAPs teams 3 8 agents.
Thus, 6 scenarios, them, synthesized 30 MAPs. main
characteristics MAPs reported Table 4. Note MAPs trivial
consist significant number actions subgoals achieved. term MAPspan refers number execution steps required complete plan
nominal conditions full observability. concurrency rate, computed number
actions divided MAP-span, indicates agents perform actions concurrently.
Finally, number inter-agent causal links shows often agents interact
achieve subgoals.
6.3.2 Observability Level
assess competence CWCM, MAPs performed different conditions
observability. particular, considered three degrees domain observability.
following, term FULL denotes complete observability effects actions
performed agents. level observability unrealistic practice,
represents benchmark compare performance CWCM observability
conditions. term HIGH denotes degree observability guarantees observe
effects 70% MAPs actions, randomly selected. Finally, term LOW denotes
degree observability 30% MAPs actions, randomly selected.
6.3.3 Monitoring Strategies
Finally, assess actual benefits achieved cooperation among agents
monitoring phase, considered three alternative monitoring strategies:
BaDE, already presented Section 2, simplest strategy, based strong
committed policy.
46

fiCooperative Monitoring Diagnose Multiagent Plans

scenario

#agents

#actions

#subgoals

MAP-span

concurrency
rate

SCN3

3

SCN4

4

SCN5

5

SCN6

6

SCN7

7

SCN8

8

67.67

47.00

30.78

14.04

10.20

9.94

69.00

52.00

27.90

5.42

3.15

2.93

91.60

77.80

34.40

7.37

3.97

3.10

128.90

73.60

27.00

40.27

4.63

8.10

180.40

73.90

30.90

36.84

18.35

5.27

156.40

48.80

20.50

6.13

7.63

2.70

2.2
2.5
2.7
4.8
5.9
7.2

#causal

#inter-agent

links

links

226.44

10.5

32.82

1.87

239.30

20.1

13.39

1.45

329.80

26.8

11.34

1.1

377.70

28

70.14

4.75

467.20

36.6

60.55

4.92

360.60

45.00

6.90

2.82

Table 4: Characteristics MAPs six scenarios nominal conditions (average
values confidence intervals).

WCM (Weak-Committed Monitoring) introduced Micalizio Torasso (2008,
2009) based weak-committed policy allows agents keep trajectorysets cope scarce observability. WCM, agent able keep pending
actions far actions provide services agents. Differently
CWCM, WCM agents cannot cooperate other; therefore,
outcome action cannot precisely determined, provides another agent
j (i.e., 6= j) service, assumed failed i, stops execution
plan.
CWCM, discussed Section 4, extends weak-committed policy active
cooperation among agents.
6.3.4 Exogenous Events
Although exogenous events generated randomly, generation reflects
(expected) probability given exogenous event occur. instance, completely unexpected event, encoded ? , unlikely occur, hence frequency
experiments pretty low. Table 5 shows probability distribution used generate
exogenous events randomly.
6.4 Experimental Analysis: Monitoring
experimental analysis monitoring task subdivided two main parts.
first one, assess three strategies BaDE, WCM, CWCM, nominal
conditions; is, exogenous event occurs simulated execution
MAPs. goal study impact observability degree competence
47

fiMicalizio & Torasso

Exogenous event
blocked-wheel
wrong-move
lose-parcel
slip-parcel
blocked-arm
?

Probability
25 %
10 %
25 %
10 %
25 %
5%

Table 5: exogenous events frequencies experiments.
HIGH observability

WCM

CWCM

% achieved subgoals

% performed actions

HIGH observability
BaDE
100
80
60
40
20
0
3

4

5

6

7

8

BaDE

WCM

80
60
40
20
0
3

4

# agent

100
80
60
40
20
0
3

4

5

6

6

7

8

7

8

LOW observability
BaDE

CWCM

% achieved subgoals

% performed actions

WCM

5

# agents

LOW observability
BaDE

CWCM

100

7

8

WCM

CWCM

100
80
60
40
20
0
3

4

5

6

# agents

# agents

Figure 13: [Nominal Conditions] Competence:
achieved goals.

percentage performed actions

three strategies. second part, assess competence three
strategies exogenous events occur.
6.4.1 Nominal Conditions
Competence. competence estimated percentage actions performed
subgoals actually achieved agents. Since condition FULL observability
agents perform 100% actions achieve 100% subgoals
three strategies, Figure 13 report results HIGH LOW conditions.
expected, BaDE sensitive observability degree. hand, since
WCM CWCM keep trajectory-sets, tolerant partial observability,
generally behave much better BaDE. CWCM better WCM
cooperation agents allows compensate lack direct observations
messages coming others. discussed Section 4.5, however, may possible
even agents unable provide useful pieces information. Thus,
CWCM strategy, agent decides stop execution plan when,
even asking agents observations, possible determine outcome
action. explained Section 4.5, case agent stops execution
plan marking actions not-enough-info. reason percentage
performed actions achieved goals 100% observability levels HIGH
48

fiCooperative Monitoring Diagnose Multiagent Plans

FULL observability
WCM

LOW observability

HIGH observability
BaDE

CWCM

WCM

CWCM

BaDE

300

300

250

250

250

200

200

200

150

msec

300

msec

msec

BaDE

150

100

100

50

50

50

0

0

4

5

6

# agents

7

8

CWCM

150

100

3

WCM

0
3

4

5

6

# agents

7

8

3

4

5

6

7

8

# agents

Figure 14: [Nominal Conditions] Monitoring time (average 95% confidence interval)
single execution step.

LOW. results obtained CWCM case remarkable: worst case, SCN5,
least 80% actions performed 70% subgoals achieved despite
30% actions observable.
Computational Time. Figure 14 shows average time (and 95% confidence interval) monitoring single step execution. Note BaDE strategy monitoring consists estimating next belief state; whereas, WCM CWCM
extend trajectory-sets. addition, CWCM cooperate agents.
cooperation introduce costs consumption message another
agent corresponds operation OBDD encoding current trajectory-set. first
positive result emerging Figure 14 that, even worst scenario, CWCM takes
300 milliseconds monitoring execution action. allows us
conclude CWCM could employed effectively real-world domains agents
actions performed order seconds.
addition, easy see computational time strongly depends observability level. example, FULL observability, CWCM WCM behave similarly;
case, fact, CWCM agents need cooperate other, hence
two strategies almost same. However, observability decreases, CWCM
slightly expensive WCM BaDE. higher cost counterbalanced
competence CWCM, that, already noticed, outperforms competence
BaDE WCM.
charts Figure 14 apparent strict dependency
number agents team computational time three strategies.
This, fact, consequence distributed approach agent maintains
point view environment, cooperation agents
based exchange messages belief states.
OBDD dimensions. relation time observability becomes clear
consider sizes OBDDs encoding trajectory-sets; see Figure 15, left.
brevity report average sizes OBDDs maintained three strategies
HIGH LOW observability conditions6 . easy see exists relation
computational time shown Figure 14 sizes OBDDs Figure
6. FULL observability case, OBDD sizes CWCM well 3000 nodes, average.
addition, CWCM WCM generate OBDDs similar sizes, expected.

49

fiMicalizio & Torasso

HIGH observability

HIGH observability
BaDE

WCM

CWCM

WCM

HIGH observability
WCM

CWCM

CWCM

12.00

12000
8000
4000
0
3

4

5

6

7

80
70
60
50
40
30
20
10
0

Length trajectory

# trajectories

# OBDD nodes

16000

3

8

4

5

LOW observability
WCM

7

8.00
6.00
4.00
2.00
0.00

8

3

4

5

# agents

# agents

BaDE

6

10.00

LOW observability

CWCM

WCM

6

7

8

7

8

#agents
LOW observability
WCM

CWCM

CWCM

12.00

12000
8000
4000
0
3

4

5

6

# agents

7

8

80
70
60
50
40
30
20
10
0

Length trajectory

# trajectories

# OBDD nodes

16000

3

4

5

6

# agents

7

8

10.00
8.00
6.00
4.00
2.00
0.00
3

4

5

6

#agents

Figure 15: [Nominal Conditions] Left: Sizes OBDDs number nodes (average
95% confidence interval); center: Average number trajectories within
trajectory-set; right: Average length one trajectory.

15, left: bigger OBDDs higher computational time. already
noted, although OBDDs may get large, computational time still acceptable.
(The biggest OBDD observed 17,707 nodes, built CWCM
SCN5 LOW observability.)
Obviously, level observability strong impact dimensions OBDDs. fact, reduced level observability makes trajectory-sets ambiguous,
hence trajectories encoded within single OBDD. made explicit Figure 15, center, show number trajectories encoded, average,
within trajectory-set time instant, length (Figure 15, right). course,
two last charts, consider WCM CWCM since BaDE strategy
build trajectory-sets. Moreover, note actual implementation CWCM,
extension trajectory-set cover whole plan performed far,
current subset pending actions.
CWCM Communication Analysis. conclude study nominal conditions
analysis communication required CWCM methodology. Figure 16
shows average number messages exchanged among agents. first interesting
result that, FULL conditions, number exchanged messages coincides
number inter-agent causal links. fact, since results taken nominal
conditions, action reaches nominal effects; therefore, cooperative protocol handles inter-agent causal link means simple ready message sent provider
client, answer required. observability level HIGH, however,
number messages tends increase, even though increase significantly except
scenario SCN8. expected, largest number messages exchanged
observation LOW, expected.
50

fiCooperative Monitoring Diagnose Multiagent Plans

CWCM messages nominal conditions
FULL

HIGH

LOW

70

# messages

60
50
40
30
20
10
0
3

4

5

6

7

8

# agents

Figure 16: number messages exchanged CWCM agents nominal conditions.
HIGH observability

CWCM

BaDE

100
80
60
40
20
0
4

5

6

7

8

60
40
20
0
3

4

40
20
0
6

7

8

# agents

% achieved subgoals

% achieved subgoals

60

5

6

7

8

WCM

60
40
20
0
3

4

BaDE

60
40
20
0
5

6

# agents

6

7

8

7

8

LOW observability

CWCM

80

4

5

# agents

100

3

CWCM

80

HIGH observability
BaDE

CWCM

80

4

5

WCM

100

# agents

100

3

BaDE

80

FULL observability
WCM

LOW observability

CWCM

100

# agents

BaDE

WCM

7

8

% achieved subgoals

3

% performed actions

% performed actions

WCM

% performed actions

FULL observability
BaDE

WCM

CWCM

100
80
60
40
20
0
3

4

5

6

# agents

Figure 17: [Faulty Conditions] Competence: percentages performed actions achieved
goals.
6.4.2 Faulty Conditions
Competence. Let us consider test set before, randomly inject
single exogenous event MAP. goal assess well three strategies
behave partial observability exogenous events combine together. Figure 17 shows
competence three strategies faulty setting three observability
levels. environment fully observable, three strategies behave exactly
same, expected. course, percentages performed actions achieved goals
depend early, late, exogenous event occurs MAP. general,
say least 70% actions performed despite injected exogenous event.
similar consideration made percentage achieved goals.
observability conditions degrade HIGH LOW, however, easy
see CWCM outperforms two strategies. means CWCM actually
tolerant strategies partial observability even faulty scenario.
51

fiMicalizio & Torasso

FULL observability
WCM

BaDE

CWCM

WCM

LOW observability

CWCM

BaDE

300

300

250

250

250

200

200

200

150
100

150
100

50

50

0

0

3

4

5

6

7

msec

300

msec

msec

BaDE

HIGH observability

8

WCM

CWCM

150
100
50
0

3

4

# agents

5

6

7

8

3

4

# agents

5

6

7

8

# agents

Figure 18: [Faulty Conditions] Monitoring time (average 95% confidence interval)
single execution step.
HIGH observability

HIGH obervability

CWCM

WCM

12000
10000
8000
6000
4000
2000

50
40
30
20
10
0

0
3

4

5

6

7

3

8

4

5

WCM

7

8

WCM

CWCM

14000

# trajectories

12000
10000
8000
6000
4000
2000
5

6

# agents

6
4
2
0
3

4

5

7

8

WCM

50
40
30
20
10
3

4

5

6

# agents

6

7

8

7

8

LOW observability

CWCM

0

0
4

8

# agents

60

3

10

LOW observability

LOW observability
BaDE

6

CWCM

12

# agents

# agents

# OBDD nodes

WCM

60

# trajectories

# OBDD nodes

14000

HIGH observability

CWCM

Length trajectory

WCM

7

8

length trajectory

BaDE

CWCM

12
10
8
6
4
2
0
3

4

5

6

# agents

Figure 19: [Faulty Conditions] Average sizes OBDDs encoding trajectory-set (left),
average number trajectories within trajectory-set (center), average length
trajectory-set (right).
particular, since difference CWCM WCM cooperative monitoring, conclude cooperation among agents actually beneficial.
Computational time. Figure 18 reports computational cost, milliseconds,
three strategies faulty conditions three levels system observability.
important note case computational time strongly depends
observability level; whereas depend number agents team,
presence exogenous event. fact, time monitoring MAP affected
exogenous event order magnitude monitoring MAP
nominal conditions. differences observed comparing charts Figure
14 charts Figure 18 due fact execution MAP affected
fault terminates earlier MAP executed nominal conditions, independently
level observability.
course, BaDE strategy cheapest three, unable monitor
effectively execution MAP. fact, strong committed policy basis
52

fiCooperative Monitoring Diagnose Multiagent Plans

CWCM messages faulty conditions
FULL

HIGH

LOW

60

# messages

50
40
30
20
10
0
3

4

5

6

7

8

#agents

Figure 20: number messages exchanged CWCM agents faulty conditions.
strategy sensitive level observability, HIGH LOW conditions
performs poorly.
OBDD dimensions. Let us consider dimensions OBDDs maintained
three strategies. left-hand side Figure 19, report sizes, number
nodes, OBDDs representing current belief state (BaDE strategy), current
trajectory-set (WCM CWCM strategies) three conditions observability.
expected, BaDE keeps smallest OBDDs since maintains last belief state,
makes BaDE strategy unable deal low observability levels. WCM
CWCM behave similarly FULL observability conditions, CWCM tends
maintain bigger OBDDs observability level decreases. result explained
fact CWCM build longer trajectory-sets WCM (Figure 19, right),
longer trajectory-sets tend ambiguous demonstrated average
number trajectories within trajectory-set (Figure 19, right).
CWCM Communication Analysis. Figure 20 shows number messages exchanged
CWCM agents faulty conditions. trend similar nominal conditions, however, number messages slightly lower. happens occurrence failure prevents agents performing actions, consequence
messages exchanged. reason slightly less messages SCN6 SCN5. fact, number inter-agent causal links two
scenarios almost same, faults SCN6 stronger impact SCN5,
evident looking number performed actions SCN5 SCN6 (see Figure 17).
6.5 Experimental Analysis: Diagnosis
Competence. competence diagnostic inferences evaluated percentage
cases action affected injected exogenous event included
within set preferred explanations mP ADs. Figure 21 (left-hand side) shows
diagnostic inferences behave three levels observability. Obviously, FULL
observability, diagnostic inferences always identify correct primary action failure.
HIGH LOW observability, however, impaired agent stop plan execution due lack observations (i.e., not-enough-info). cases diagnosis cannot
identify primary failure. Figure 21 (right-hand side) shows average distance
(i.e., number actions), action affected exogenous event, action
53

fiMicalizio & Torasso

FULL

HIGH

LOW

FULL

HIGH

LOW

8

80

#actions

% diagnosed cases

100

60
40

6
4
2

20
0

0
3

4

5

6

7

8

3

4

5

#agents

6

7

8

#agents

Figure 21: [Diagnosis] Competence (left), responsiveness (right).


xplanations

EVE: inferred explanations
FULL

HIGH

LOW

FULL

# explanantions

# explanations

50
40
30
20
10
0
3

4

5

6

7

8

LOW

4
3
2
1
0
3

# agents

HIGH

5

4

5

6

7

8

# agents

Figure 22: [Diagnosis] EVE explanations (left), mPADs explanations (right).
failure actually detected. FULL observability, diagnosis highly
responsive detects action failure soon exogenous event occurs (i.e.,
distance zero). hand, observability partial, CWCM agent
take longer detect failure.
Explanations Preferred Explanations. Section 5, pointed that,
given trajectory-set, one identify two types explanations: EVE mP ADs.
set EVE represents explanations consistent observations received
agent; whereas mP ADs set primary action failures inferred EVE . Figure 22 shows cardinalities (on average) two sets inferred six scenarios
different levels observability. two charts Figure 22 draw two conclusions. First, cardinality EVE strongly depends observability level; namely,
reduction observability level causes increment number possible explanations. However, cardinality mP ADs almost independent observability
level. fact, number preferred explanations inferred LOW observability similar number preferred explanations inferred FULL observability six
scenarios. course, mP ADs sets computed LOW observability tend slightly
bigger mP ADs sets computed FULL observability, consequence
fact initial EVE set ambiguous LOW observability.
means that, regardless initial ambiguity EVE sets, preferred explanations
reduced almost subsets six scenarios.
second important conclusion mP ADs explanations substantially
useful identifying fault EVE explanations. fact, average cardinality
mP ADs sets three worst cases LOW observability; whereas, average
54

fiCooperative Monitoring Diagnose Multiagent Plans

Diagnosis: Computational Time
FULL

HIGH

LOW

1000

msec

800
600
400
200
0
3

4

5

6

7

8

# agents

Figure 23: Diagnosis: Computational Time.

number EVE explanations best case FULL observability eight,
rises 38 worst case LOW observability (see SCN3). means
mP ADs explanations may actually help human user refine her/his hypotheses
current situation system. essential consider diagnosis
first step recovery (Micalizio, 2013). Thus, human user, possibly automatic
supervisor, consider small number alternative explanations, hence better
focus plan recovery process fault(s) believed plausible.
Computational Effort. Finally, consider computational time required infer
diagnoses. inferring EVE explanations, computational cost mainly due
cost removing non-relevant variables trajectory-set provided CWCM (see
Appendix discussion theoretical point view cost variable
removal). Figure 23 reports average computational time, milliseconds, extracting
EVE explanations six scenarios three different levels observability.
noticed previous section, LOW observability, trajectory-set tends
bigger two observability levels. consequence time
inferring diagnoses LOW conditions tends higher; however, time
1 second even worst case. side, HIGH observability conditions,
worst time 150 milliseconds (see scenario SCN3). worst time falls
50 milliseconds consider FULL observability level. computational times
allow us conclude diagnostic task, monitoring one, performed
on-line number applicative domains actions performed order
seconds, even minutes.
6.6 Discussion
beginning experimental analysis posed three questions,
position answering them. First all, experimental results show CWCM
sensitive number agents team. consequence partitioning
global plan local plans. way, fact, agent keeps point
view states shared resources; namely, agent local belief state
depend number agents team. seen, consistency
among local beliefs guaranteed exchange messages whose number
linear number inter-agent causal links MAP consideration.
55

fiMicalizio & Torasso

hand, level observability system strong impact
computational effort CWCM ambiguity trajectory-sets computed.
lower observability, higher computational cost bigger
trajectory-sets. important result emerges analysis worst-case
scenarios depicted Appendix rare, never occurred experiments. Indeed, compact encoding trajectory-sets action models obtained via
OBDDs facilitates efficient implementation CWCM takes, average,
hundreds milliseconds monitor single action. allows us conclude CWCM
successfully employed on-line monitoring many real-world domains.
level observability impact diagnostic inferences. fact,
number EVE explanations significantly grows observability level decreases.
However, number preferred mP ADs explanations strongly influenced
observability level.
Finally, direct comparison CWCM WCM demonstrates cooperation among agents essential tolerant scarce observations.
cooperation, fact, means agent CWCM keep longer
trajectory-sets WCM. longer trajectory-sets give agent chances
collect pieces information successful completion pending actions.

7. Related Works
consider four main families model-based approaches diagnosis dynamic
systems close MAPs:
Discrete-Event Systems (DESs);
Relation-oriented;
Team-oriented;
Resource-oriented.
rest section briefly review main approaches within families,
highlighting differences similarities CWCM methodology proposed here.
7.1 Discrete-Event Systems
Since seminal work Sampath, Sengupta, Lafortune, Sinnamohideen, Teneketzis
(1995) Diagnoser, huge number works addressed diagnosis dynamic
systems modeling systems DESs. Diagnoser approach compiles
diagnostic model (i.e., Diagnoser itself) whole system off-line, approaches
(see e.g., Lamperti & Zanella, 2002; Cordier & Grastien, 2007) compute possible system
behaviors, check behaviors correct. Grastien, Haslum, Thiebaux
(2012) extends DESs conflict-based approach initially proposed Reiter (1987)
static systems.
best knowledge, DES framework gets closer one
presented Grastien, Anbulagan, Rintanen, Kelareva (2007). framework,
diagnosis label either normal faulty, associated system trajectory;
trajectory sequence system states interleaved events, thus similar
56

fiCooperative Monitoring Diagnose Multiagent Plans

trajectories kept within trajectory-sets. trajectory normal contain
fault events; trajectory faulty, otherwise.
Grastien et al. propose reduce diagnosis problem SAT one. idea formulate SAT problem, order answer question observed behavior compatible
faults occurring?. course, answer yes = 0, system
assumed nominal exists least one normal path consistent observations.
principle, proposed system description could encode MAP: execution actions
could modeled subset observable events; whereas exogenous events could
mapped unobservable events directly. However, DES framework cannot directly
applied domains CWCM deal with. First all, DES approach
next state whole system inferred taking account synchronous occurrence
set events. Thus, agents event generators, follows perform
actions synchronously, CWCM restriction imposed. Moreover, SATbased methodology centralized trajectories whole system states, whereas
CWCM enables agent build local trajectory-sets distributed way.
7.2 Relation-Oriented Approaches
Relation-oriented approaches proposed Micalizio Torasso (2008, 2009).
define works relation-oriented since action models expressed terms relations
agents state variables. advantage kind model possibility
representing single piece knowledge nominal abnormal evolutions
action. CWCM methodology falls within category, extends previous
works two ways. First all, CWCM able deal completely unexpected events,
denoted ? , model exists. Indeed, occurrence ? execution
action maps variables effects(a) unknown value; meaning
variables longer predictable.
second important extension protocol allows agents cooperate
monitoring task. experimental results demonstrated,
cooperation among agents essential cope scarce observations. means
cooperation, fact, agent acquire new pieces information would
acquire directly. pieces therefore used refine trajectory-set,
possibly outcome pending actions could determined.
7.3 Teamwork-Oriented Approaches
Rather diagnosing action failures, CWCM, teamwork-oriented approaches
focused diagnosing teamwork failures; i.e., coordination failures. type failures
necessarily due erroneous actions, wrong decisions taken agents.
detection teamwork failures addressed seminal works Tambe
(1998) Kaminka Tambe (2000). Kalech Kaminka (2003) later focused
diagnosis coordination failures, introduced notion social
diagnosis. specifically, team cooperating agents represented abstract
terms means hierarchy behaviors. behavior abstraction concrete
actions agent actually takes real world. Indeed, behaviors abstract
single actions, possibly sequences actions. Thus, differently relational-
57

fiMicalizio & Torasso

resource-oriented approaches (see later), explicit model agents plans missing
teamwork-oriented solutions.
social diagnosis framework assumes agents synchronize jointly
select team behavior. disagreement arises least two agents select two behaviors
incompatible other. disagreements represent instances social
diagnosis problems. course, agents select behaviors according beliefs,
thus social diagnosis disagreement set conflicting belief states held subset
agents. Kalech Kaminka (2005, 2007, 2011) propose different methods inferring
social diagnosis. solutions, however, rely assumptions may limit
applicability real-world scenarios. First all, assumed agents team
share hierarchy behaviors belief states agents homogeneous
(i.e., defined set propositional atoms). Moreover, agents must willing
exchange beliefs. CWCM methodology propose, however,
suffer limitations. CWCM, fact, makes assumption
agents internal beliefs. addition, communication among agents exchange
agents internal beliefs, observations shared resources agents directly gather,
guarantees agents high degree privacy.
7.4 Resource-Oriented Approaches
approaches within resource-oriented family mainly proposed Roos
Witteveen. call approaches resource-oriented because, point view,
system diagnosed plan, state system given states
system resources. execution action change state(s) one
resource(s). approaches deserve particular attention similarities
CWCM methodology, number relevant differences.
Witteveen, Roos, van der Krogt, de Weerdt (2005) present basic framework
use extend subsequent works. framework, actions modeled
atomic plan steps; precisely, action models functions deterministically map
resource states input resource states output. models therefore represent
changes normally caused actions successfully performed.
faulty behavior actions, conversely, modeled via weak abnormal function,
maps state resource input unknown value. means that,
action fails, states resources handled action become unpredictable.
diagnostic problem arises observations received execution step
inconsistent nominal predictions made action models. means
least one actions performed far behaved abnormally. Witteveen et al.
(2005) introduce notion plan diagnosis subset plan actions that, qualified
abnormal, make observations consistent predictions made assuming
actions nominal.
course, since may exist many possible plan diagnoses, important look
diagnoses preferable others. Roos Witteveen (2009) propose different preference criterion based predictive power plan diagnosis has.
therefore introduce notion maximally-informative plan diagnosis (maxi-diagnosis)
set plan diagnoses predict correctly biggest subset observations. no58

fiCooperative Monitoring Diagnose Multiagent Plans

tion diagnosis subsequently refined notion minimal maximally-informative
plan diagnosis (mini-maxi-diagnosis), subset maxi-diagnosis
number failed actions assumed minimal.
work de Jonge et al. (2009), basic framework extended: agents
seen resources, action models includes variables agents equipment
environment events (i.e., exogenous events). extension allows distinction
primary secondary diagnoses. primary diagnosis plan diagnosis (i.e.,
expressed terms failed actions), secondary diagnosis thought second
level diagnosis tries explain given action failure occurred.
CWCM tries resolve problem one addressed Roos Witteveen
(2009): Diagnosing execution MAP. However, action models significantly different two approaches. Roos Witteveens point view, action models
deterministic functions nominal behavior only. Whereas CWCM, model actions
relations easily accommodate nominal faulty evolutions. particular,
faulty evolutions nondeterministic, partially specified support
unknown value indicate expectations possible given variable.
Another important difference two approaches execution
actions. Roos Witteveen assume actions take one time instant performed
action execution proceeds synchronously agents. CWCM
realistic since action execution asynchronous: even though actions modeled
terms preconditions effects, actual duration necessarily one time instant.
seen, fact, agents cooperate exploiting causal
precedence links explicitly defined within plan model. plan model adopted
Roos Witteveen, instead, mentions explicitly precedence links only,
include causal links.
process diagnosis inferred presents substantial differences.
Witteveen et al. (2005) de Jonge et al. (2009) present centralized method carry
diagnostic inferences. distributed procedure qualifying actions abnormal proposed
Roos Witteveen (2009), case detection diagnostic problem
made centralized way. Moreover, methodology proposed Roos Witteveen
sort strong committed approach, sense whenever observations,
system infer diagnosis. hand, CWCM methodology fully
distributed detection diagnostic problem (i.e., monitoring),
solution. addition, CWCM inherently weak committed: observations necessarily
trigger diagnostic process, diagnosis inferences start interpretation
observations either lead (1) determining action failure, (2) determining
service produced favor another agents action actually missing. CWCM achieves
second point exploiting direct observations gathered agent, messages
coming agents. means observations sufficient either
reach condition (1) (2), diagnosis inferred.
said above, de Jonge et al. (2009) introduce distinction primary
secondary diagnosis. distinction found methodology. primary
diagnosis de Jonge et al. corresponds minimum primary action failures (mPADs),
identify actions assumed faulty order make plan execution
consistent observations. secondary diagnosis, hand, corresponds
59

fiMicalizio & Torasso

refined explanations (refinedExp), associate action mPADs
set exogenous events that, consistently observations, might occurred
hence caused action failure.
paper assess impact primary action failure mP ADs
inferring set secondary action failures; namely, subset actions fail
indirect consequence failure a. Although identification secondary failures
would possible, de Jonge et al. take account problem.
conclusion, CWCM framework considered extension frameworks de Jonge et al. (2009) Roos Witteveen (2009). fact, action models
proposed Roos Witteveen reproduced within framework including
relation-based model two entries: one deterministic nominal evolution
action, one abnormal behavior agent variables become unknown consequence unpredictable event. action models could used
CWCM usual infer plan diagnosis fully distributed way.

8. Conclusion
Plan diagnosis essential step implement robust multiagent planning systems.
shown works (Mi & Scacchi, 1993; Gupta et al., 2012; Micalizio, 2013), fact,
explanations provided plan diagnosis steer repair procedure make repair
process effective.
paper addressed problem plan diagnosis splitting two
subproblems: detection action failures, actual explanation detected
action failures terms exogenous events might occurred. detection action failures achieved means Cooperative Weak-Committed Monitoring (CWCM)
strategy, allows agents cooperate monitoring task. Cooperation among agents plays central role detection action failures,
explanations. CWCM methodology, fact, allows agent build
structure (i.e., trajectory-set), internal representation world
point view agent itself. Relying structure, agent infer explanations
action failures without need interacting agents.
proposed framework diagnosis MAPs extends previous approaches
literature. First all, CWCM fully distributed asynchronous. Previous approaches
(see e.g., Kalech & Kaminka, 2011; Roos & Witteveen, 2009; Micalizio & Torasso, 2008),
instead, based synchronous step (e.g., agents execute actions synchronously).
framework agent perform next action soon actions preconditions
satisfied. verify condition, impose agents adhere coordination
protocol guarantees consistent access shared resources.
addition, propose extension relational language modeling nondeterministic actions (Micalizio & Torasso, 2008). previous approach, fact,
assume know advance exogenous events affect given action;
paper able deal partial knowledge exogenous events. particular, allow specify subset effects exogenous event action
(i.e., agents variables might become unknown event), allow
specify action might affected indefinite event whose effects completely
60

fiCooperative Monitoring Diagnose Multiagent Plans

unpredictable (i.e., agents variables become unknown due event). kind
extended action model subsumes action models proposed Roos Witteveen,
consists two parts: nominal action model, abnormal model maps
agents variable unknown value.
Cooperation among agents nondeterministic action models make CWCM particularly apt deal dynamic partially observable environments. one side,
nondeterministic action models discussed capture unexpected changes
environment. side, cooperative monitoring allows agent acquire
information environment agents. important note that,
differently works agents exchange internal belief states
(see e.g., Kalech & Kaminka, 2011), CWCM agent needs communicate
observes. enables agents keep private internal beliefs; addition, agents
could adopt specific policies deciding observations forwarded
agents. Forwarding observations agents, single agent
current proposal, might help agents discover earlier outcomes
pending actions; leave opportunity future research.
must noted CWCM assumes observations correct:
actual state agent must pruned agent belief state due erroneous
observation. assumption often made many model-based approaches diagnosis (see e.g., Birnbaum et al., 1990; Brusoni, Console, Terenziani, & Theseider Dupre,
1998; Pencole & Cordier, 2005; Roos & Witteveen, 2009; Eiter, Erdem, Faber, & Senko,
2007, mention few). Correctness observations, however, implies
observations must precise. CWCM fact consume ambiguous messages given
disjunction values variable (i.e., var = v1 var = v2 . . . var = vn ),
negation specific value (i.e., var 6= v). point view CWCM,
consuming observations simply corresponds selection states within belief
state observations refer to. Although aspect emphasized paper,
ability dealing ambiguous observations enriches communicative capacities
agents. instance, ask-if interaction, client, rather answering
generic no-info, could give provider disjunction possible resource states among
which, however, client incapable discriminate actual one. set alternative
states is, point view provider, much informative no-info,
possibly could lead provider determine actual state resource hand.
point view diagnostic inference, shown possible
explain action failures extracting explanations trajectory-sets built CWCM.
particular, pointed assuming action failures independent
might lead spurious diagnoses. reason proposed methodology
identifying primary action failures secondary action failures, indirect
consequence primary ones. simple preference criterion, based minimality
primary action failures, proposed prefer alternative explanations.
deep experimental analysis shown cooperative monitoring diagnosis practically feasible. efficient implementation based OBDDs discussed
Appendix together computational analysis theoretical point view.
experiments highlighted CWCM scales well number agents,
affected level observability environment: trajectory-sets tend big61

fiMicalizio & Torasso

ger environment less observable. However, experiments demonstrate
cooperation effective even dealing scarcely observable environments. Competence rates noncooperative solutions, fact, comparable CWCM
environment fully observable; situations, instead, CWCM always
exhibits highest competence.
proposed framework extended different ways. mentioned above,
far adopted careful approach communication restricting agents talk
exchanged services. However, agents might willing
communicate pieces knowledge acquired. interesting possible
extension improve cooperative protocol along direction. intuition, fact,
agent acquires information, could infer outcome
pending actions earlier now. course, communication must
become bottleneck, agents able identify piece information worth
forwarded agents, avoid broadcasting every observation agents.
important extension aim at, however, relax assumption
communication among agents always reliable. Removing assumption
many consequences. First all, cooperative monitoring protocol extended
order deal messages lost. Moreover, Proposition 7, safe use
resources, might longer guaranteed CWCM; thus resources could accessed
inconsistently. diagnose situations could take point view similar Kalech
Kaminkas social diagnosis. fact, erroneous access resources, could considered
coordination failures. would impact diagnostic inferences longer
local, distributed. is, monitoring task, diagnosis
performed means cooperation number agents.

Acknowledgments
authors wish thank anonymous reviewers insightful comments,
substantially contributed final shape work.

Appendix A. Implementation Computational Analysis
Appendix first recall basic OBDD operators complexities,
study computational cost expensive relational operations involved
CWCM diagnostic methodologies discussed above.
A.1 OBDD Operators Complexities
computational analysis discuss next subsection relies results presented
Bryant (1986, 1992). works, author discusses efficient implementation
OBDDs operators corresponding computational complexities. results
summarized Table 6, f , f1 , f2 denote Boolean functions, encoded
reduced function graphs G, G1 , G2 , respectively. size graph G corresponds
number vertices, represented |G|. primitive OBDD operators
reported upper side Table 6:
62

fiCooperative Monitoring Diagnose Multiagent Plans

- reduce builds canonical form Boolean function f ; i.e., given specific variables
ordering, reduce operator gets graph G whose size minimal.
- apply implements binary logical operations two Boolean functions f1 f2 ;
operator works graphs G1 G2 encoding two functions, respectively;
op binary logical operator (, , , ). computational complexity
worst case product sizes (i.e., number vertices) two
graphs.
- restrict substitutes constant b variable xi time almost linear number
vertices within graph G.
- rename renames set variables ~x new one ~x0 ; complexity exponential
number renamed variables.
- equiv checks equivalence two Boolean functions f1 f2 ; since operator
scans two corresponding graphs simultaneously, computational complexity
linear sizes.
lower side Table 6 report computational cost time space relational operators join, intersect, union project obtained combining
primitive OBDD operators. Observe that, among relational operators, projection
expensive; fact, exponential number (binary) variables
removed (see e.g., Torta & Torasso, 2007; Torasso & Torta, 2006 details).
A.2 CWCM: Computational Analysis
analyze computational complexity CWCM, consider high-level algorithm
presented Figure 10, focus computational cost performing single iteration
loop action ail actually performed real-world.
situation three main steps hide potentially expensive operations relations:
extension current trajectory-set (line 9);
refinement trajectory-set available observations (line 11);
detection outcomes pending actions (line 19, Figure 7).
rest section analyze computational effort steps.
operator
reduce(f )
apply(op, f1 , f2 )
restrict(xi , b, f )
rename (f , ~x, ~x0 )
equiv(f1 , f2 )

time
O(|G| log |G|)
O(|G1 | |G2 |)
O(|G|)
O(|G| 2|~x| )
O(max(|G1 |, |G2 |))

size
|G|
|G1 | |G2 |
|G|
|G| 2|~x|
N/A

join (f1 , f2 ); union(f1 , f2 );
intersect(f1 , f2 ) (i.e., select)
project(f , {x1 , . . . , xn }, {y1 , . . . , ym })

O(|G1 | |G2 |)
O(|G1 | |G2 |)
O((2(nm) |G|)2 )

|G1 | |G2 |
|G1 | |G2 |
2(nm) |G|

Table 6: OBDD operators complexity.
63

fiMicalizio & Torasso

A.2.1 Extending Trajectory-Set
According equation (7), operator , r [1, l] yields new trajectory-set
r [i, l + 1], involves two join operations: one r [1, l] (ail ), one
r [1, l] (ail ). results two operations subsequently merged new
trajectory-set r [1, l + 1] via union operation. understand computational cost
relational operations, necessary map OBDD operators. already
shown previous works (see e.g., Torta & Torasso, 2007; Micalizio, 2013), natural
join mapped two Boolean functions (and hence two
OBDDs), whereas union two relations becomes Boolean or. Let Gl , Gl+1 , G ,
G OBDDs corresponding relations r [1, l], r [1, l + 1], (ail ),
(ail ), respectively; operator mapped following expression terms
OBDDs operations:
Gl+1 = apply(, apply(, Gl , G ), apply(, Gl , G ))

(14)

Given operator complexities Table 6, computational effort infer new
trajectory-set worst case:
O(|Gl+1 |) = O(|Gl | |G |) O(|Gl | |G |)
= O(|Gl |2 |G | |G |).

(15)

A.2.2 Refinement Observations
new trajectory-set inferred, refined observations obsik
received agent. sake exposition, equations (8) (9) defined
refinement trajectory-set intersection trajectory-set
belief state Bki refined obsik . Note extraction belief state
expensive operation, thus try avoid operation whenever possible. particular
case, since agent variables V ARki included within current trajectory-set,
refinement operation carried intersection r [1, l + 1] obsik ;
terms OBDD operators:
Gref .l+1 = apply(, Gl+1 , Gobsi )
k

(16)

Gobsi OBDD encoding obsik , Gref .l+1 OBDD corresponding
k
refined trajectory-set refinedT r [1, l + 1]. follows computational cost
operation
(17)
O(|Gref .l+1 |) = O(|Gl+1 | |Gobsi |)
k

A.2.3 Detecting Pending Actions Outcomes
last step CWCM algorithm consider assessment outcome every
action currently within list pending actions pActsi . Section 4, noted
verify success given action aik pActsi , sufficient check whether nominal

effects aik satisfied every state Bk+1
(Definition 3). case condition
hold, one verify whether expected nominal effects aik missing
64

fiCooperative Monitoring Diagnose Multiagent Plans


state Bk+1
(Definition 4). checks result negative answer (i.e., belief state

Bk+1 still ambiguous), action aik remains pending.

explicitly checking conditions might parExtracting belief state Bk+1
ticularly expensive, especially trajectory-set grows time. extraction
belief state project operation, fact, would require elimination
r [1, l + 1] variables interested in; thus, would remove variables
steps 1, 2, . . . , k, k + 2, . . . , l + 1, l |VARi | variables. Table 6 shows,
complexity project exponential number variables removed, could
easily become bottleneck.
cope problem, implemented checking ok f ailed outcomes
different way. particular, Definition 3 directly follows:


.
join effects(aik ) equals Bk+1
Proposition 11 aik outcome ok iff Bk+1

Proof: proof straightforward: definition aik outcome ok iff nominal effects



satisfied every state Bk+1
; join Bk+1
effects(aik ) yields Bk+1


nominal effects already included every state Bk+1 , hence action
outcome ok.

Since Bk+1 included refinedT r [1, +l + 1], proposition extended
whole trajectory-set:
Proposition 12 aik outcome ok iff
refined r [1, l + 1] join effects(aik )equalsrefined r [1, l + 1].
say, refinement trajectory-set observations, action aik
outcome ok iff nominal effects filter trajectory refinedT r [1, l + 1].
Relying proposition, verify whether aik outcome ok two steps: first,
build temporary OBDD maintaining result join r [1, l + 1]
effects(aik ), check whether temporary OBDD equivalent original
trajectory-set; terms OBDD operators:
outcomeOK? = equiv(Gref.l+1 , apply(, Gref.l+1 , Geffects(ai ) ))
k

(18)

Since size Geffects(ai ) negligible compared size Gref.l+1 , computak
tional complexity check O(|Gref.l+1 |2 ).
f ailed outcome checked similar way; case want discover
whether nominal effects aik missing r [1, l + 1]; happens
negation effects effects(aik ) represent possible filter r [1, l + 1]
r [1, l + 1] join effects(aik ) equals r [1, l + 1]. terms OBDD operators
outcomeFailed? = equiv(Gref.l+1 , apply(, Gref.l+1 , Geffects(ai ) ))

(19)

k

important note OBDD Geffects(ai ) computed constant time directly
k
Geffects(ai ) ; fact, given Boolean function f corresponding graph Gf ,
k
sufficient exchange 0 1 nodes Gf obtain graph
representation Boolean function not(f ). Thus, check O(|Gref.l+1 |2 ).
65

fiMicalizio & Torasso

follows cost determining outcomes actions pActsi is:
O(|pActsi | |G(ref.)l+1 |2 ).

(20)

equation (20), easy see computational cost CWCM methodology strongly depends amount available observations. worst case fact
give step l, due scarce observations, number pending actions
close l itself; is, |pActsi | l, meaning almost actions performed far
outcome pending.
A.3 Diagnosis: Computational Analysis
computational cost diagnostic process strongly dominated cost
inferring event-based explanations (EVE ). shown, fact, possible
extract set minimum cardinality primary action failures explanations (mP ADs)
structure. According Equation 11, EVE set extracted projection
current trajectory-set r [1, l] event variables e1 , . . . , el1 ; unfortunately,
case way avoid expensive operation.
estimate computational cost, first consider many binary variables
within OBDD Gl encoding r [1, l], many (binary) variables going
remove OBDD. state event variable r [i, l] fact multi-valued
variable actually implemented terms number binary variables within
OBDD Gl . number required binary variables depends size domain
original high-level variable. Let us assume size largest domain
variables VARi , estimate need b = log binary variables
variable mentioned r [1, l] (both state event variables). easy see
number binary variables required represent single belief state w = b |VARi |:
multi-valued variable VARi b binary variables OBDD level.
number binary variables encoding trajectory-set r [i, l] therefore p =
l w + (l 1) b; fact, within r [1, l], l beliefs l-1 event variables. cost
projecting r [1, l] event variables therefore:
O((2plw |Gl |)2 ).

(21)

EVE diagnoses extracted, possible infer minimum cardinality
primary failures exploiting techniques Torasso Torta (2003), proven
polynomial size OBDD.
A.4 Discussion
first important result emerges computational analysis
monitoring single execution step CWCM exponential. fact,
shown step declarative definition mapped number OBDD
operators whose complexity polynomial, provided sizes involved OBDDs
remain manageable. particular, shown exponential operation used
declarative definition, projection, avoided actual implementation.
main concern CWCM trajectory-set may grow time agent
66

fiCooperative Monitoring Diagnose Multiagent Plans

performs actions without receiving observations. Consequently, computational cost
CWCM tends grow time since size OBDD encoding trajectoryset may increase. important note, however, growth exponential
quadratic (see equation (15)). addition, estimate computational costs
monitoring diagnosis, exploited estimations reported Table 6; these,
however, estimates worst possible cases, practice cases
common. Bryant conjectures that, although theoretical cost apply operator
two OBDDs G1 G2 O(|G1 | |G2 |) worst case, practice actual
cost cases closer O(|G1 | + |G2 | + |G3 |) G3 resulting OBDD
(Bryant, 1986). Thus size resulting, intermediate OBDDs plays central
role determining actual computational cost.
specific case CWCM, observe common
agent perform long portion plan without receiving observations. CWCM
allows fact agents communicate other; therefore, unless agent
completely isolated others, agent likely receive observations coming
agents services provided with. means that, practice,
size OBDD encoding trajectory-set become intractable
cooperation among agents, experiments conducted far support
hypothesis.
hand, diagnostic inferences slightly expensive monitoring strategy. project operation cannot avoided order infer
diagnosis. case, however, observe plan execution already
stopped consequence detected failure. Thus, diagnosis take
time infer result since constrained on-line.

References
Arasu, A., Babu, S., & Widom, J. (2006). CQL continuous query language: semantic
foundations query execution. International Journal Large Data
Bases, 15 (2), 121142.
Birnbaum, L., Collins, G., Freed, M., & Krulwich, B. (1990). Model-based diagnosis
planning failures. Proc. Association Advancement Artificial Intelligence
(AAAI90), pp. 318323.
Boutilier, C., & Brafman, R. I. (2001). Partial-order planning concurrent interacting
actions. Journal Artificial Intelligence Research, 14, 105136.
Brusoni, V., Console, L., Terenziani, P., & Theseider Dupre, D. (1998). spectrum
definitions temporal model based diagnosis. Artificial Intelligence, 102, 3979.
Bryant, R. (1986). Graph-based algorithms boolean function manipulation. IEEE Transactions Computers, 35 (8), 677691.
Bryant, R. (1992). Symbolic boolean manipulation ordered binary-decision diagrams.
ACM Computer Surveys, 24, 293318.
67

fiMicalizio & Torasso

Cordier, M.-O., & Grastien, A. (2007). Exploiting independence decentralised
incremental approach diagnosis. Proc. International Joint Conference
Artifical Intelligence (IJCAI07), pp. 292297.
Cox, J. S., Durfee, E. H., & Bartold, T. (2005). distributed framework solving
multiagent plan coordination problem. Proc. International Conference Autonomous Agents Multiagent Systems (AAMAS05), pp. 821827.
Darwiche, A., & Marquis, P. (2002). knowledge compilation map. Journal Artificial
Intelligence Research, 17, 229264.
de Jonge, F., Roos, N., & Witteveen, C. (2009). Primary secondary diagnosis multiagent plan execution. Journal Autonomous Agent Multiagent Systems, 18 (2),
267294.
Eiter, T., Erdem, E., Faber, W., & Senko, J. (2007). logic-based approach finding
explanations discrepancies optimistic plan execution. Fundamenta Informaticae,
79 (1-2), 2569.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. Journal Artificial Intelligence Research, 20, 61124.
Grastien, A., Anbulagan, Rintanen, J., & Kelareva, E. (2007). Diagnosis discrete-event
systems using satisfiability algorithms. Proc. Association Advancement
Artificial Intelligence (AAAI07), pp. 305310.
Grastien, A., Haslum, P., & Thiebaux, S. (2012). Conflict-based diagnosis discrete event
systems: Theory practice. Proceedings Thirteenth International Conference Principles Knowledge Representation Reasoning (KR12), pp. 489499.
Gupta, S., Roos, N., Witteveen, C., Price, B., & de Kleer, J. (2012). Exploiting shared
resource dependencies spectrum based plan diagnosis. Proc. Association
Advancement Artificial Intelligence (AAAI12), pp. 2425 2426.
Heger, F. W., Hiatt, L. M., Sellner, B., Simmons, R., & Singh, S. (2005). Results Sliding
Autonomy Multi-Robot Spatial Assembly. Proc. International Symposium
Artificial Intelligence, Robotics Automation Space (iSAIRAS).
Helmert, M. (2009). Concise finite-domain representations PDDL planning tasks. Artificial Intelligence, 173 (5-6), 503535.
Jonsson, P., & Backstrom, C. (1998). State-variable planning structural restrictions:
Algorithms complexity. Artificial Intelligence, 100 (1-2), 125176.
Kalech, M. (2012). Diagnosis coordination failures: matrix-based approach. Journal
Autonomous Agents Multiagent Systems, 24 (1), 69103.
Kalech, M., & Kaminka, G. A. (2003). design social diagnosis algorithms
multi-agent teams. Proc. International Joint Conference Artificial Intelligence
(IJCAI03), pp. 370375.
Kalech, M., & Kaminka, G. A. (2005). Diagnosing team agents: Scaling up. Proc.
International Conference Autonomous Agents Multi-Agent Systems (AAMAS05), pp. 249255.
68

fiCooperative Monitoring Diagnose Multiagent Plans

Kalech, M., & Kaminka, G. A. (2007). design coordination diagnosis algorithms
teams situated agents. Artificial Intelligence, 171 (8-9), 491513.
Kalech, M., & Kaminka, G. A. (2011). Coordination diagnostic algorithms teams
situated agents: Scaling up. Computational Intelligence, 27 (3), 393421.
Kalech, M., Kaminka, G. A., Meisels, A., & Elmaliach, Y. (2006). Diagnosis multi-robot
coordination failures using distributed CSP algorithms. Proc. Association
Advancement Artificial Intelligence (AAAI06), pp. 970975.
Kaminka, G. A., & Tambe, M. (2000). Robust multi-agent teams via socially-attentive
monitoring. Journal Artificial Intelligence Research, 12, 105147.
Lamperti, G., & Zanella, M. (2002). Diagnosis discrete-event systems uncertain
temporal observations. Artificial Intelligence, 137 (1-2), 91163.
Mi, P., & Scacchi, W. (1993). Articulation: integrated approach diagnosis, replanning, rescheduling software process failures. Proc. Knowledge-Based
Software Engineering Conference, pp. 7784.
Micalizio, R. (2013). Action failure recovery via model-based diagnosis conformant
planning. Computational Intelligence, 29 (2), 233280.
Micalizio, R., & Torasso, P. (2007a). On-line monitoring plan execution: distributed
approach. Knowledge-Based Systems, 20 (2), 134142.
Micalizio, R., & Torasso, P. (2007b). Plan diagnosis agent diagnosis multi-agent
systems. Proc. Congress Italian Association Artificial Intelligence
(AI*IA07), Vol. 4733 LNCS, pp. 434446.
Micalizio, R., & Torasso, P. (2008). Monitoring execution multi-agent plan: Dealing
partial observability. Proc. European Conference Artificial Intelligence
(ECAI08), pp. 408412.
Micalizio, R., & Torasso, P. (2009). Agent cooperation monitoring diagnosing
MAP. Proc. Multiagent System Technologies (MATES09), Vol. 5774 LNCS,
pp. 6678.
Micalizio, R., Torasso, P., & Torta, G. (2006). On-line monitoring diagnosis team
service robots: model-based approach. AI Communications, 19 (4), 313349.
Nebel, B. (2000). compilability expressive power propositional planning
formalisms. Journal Artificial Intelligence Research, 12, 271315.
Pencole, Y., & Cordier, M. (2005). formal framework decentralized diagnosis
large scale discrete event systems application telecommunication networks.
Artificial Intelligence, 164, 121170.
Reiter, R. (1987). theory diagnosis first principles. Artificial Intelligence, 32 (1),
5796.
Roos, N., & Witteveen, C. (2009). Models methods plan diagnosis. Journal
Autonomous Agent Multiagent Systems, 19 (1), 3052.
Sampath, M., Sengupta, R., Lafortune, S., Sinnamohideen, K., & Teneketzis, D. (1995).
Diagnosability discrete event systems.. IEEE Transactions Automatic Control,
40 (9), 15551575.
69

fiMicalizio & Torasso

Sellner, B., Heger, F., Hiatt, L., Simmons, R., & Singh, S. (2006). Coordinated multiagent teams sliding autonomy large-scale assembly. IEEE - Special Issue
Multi-Robot Systems, 94 (7), 1425 1444.
Steinbauer, G., & Wotawa, F. (2008). Enhancing plan execution dynamic domains using
model-based reasoning. Intelligent Robotics Applications, First International
Conference, (ICIRA08), Vol. 5314 LNAI, pp. 510519.
Tambe, M. (1998). Implementing agent teams dynamic multi-agent environments. Applied
Artificial Intelligence, 12 (2-3), 189210.
Torasso, P., & Torta, G. (2003). Computing minimum-cardinality diagnoses using OBDDs.
German Conference AI (KI03), Vol. 2821 LNCS, pp. 224238.
Torasso, P., & Torta, G. (2006). Model-based diagnosis OBDD compilation: complexity analysis. Reasoning, Action Interaction AI Theories Systems,
Vol. 4155 LNCS, pp. 280298.
Torta, G., & Torasso, P. (2007). role modeling causal independence system
model compilation OBDDs. AI Communications, 20 (1), 1726.
Weld, D. S. (1994). introduction least commitment planning. AI Magazine, 15 (4),
2761.
Witteveen, C., Roos, N., van der Krogt, R., & de Weerdt, M. (2005). Diagnosis single
multi-agent plans. Proc. International Conference Autonomous Agents
Multiagent Systems (AAMAS05), pp. 805812.
Yan, Y., Dague, P., Pencole, Y., & Cordier, M.-O. (2009). model-based approach
diagnosing fault web service processes. Journal Web Service Research., 6 (1),
87110.

70


