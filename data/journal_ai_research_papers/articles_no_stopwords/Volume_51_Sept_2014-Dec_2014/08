journal artificial intelligence

submitted published

complexity answering conjunctive navigational
queries owl el knowledge bases
giorgio stefanoni
boris motik

giorgio stefanoni cs ox ac uk
boris motik cs ox ac uk

department computer science university oxford
parks road oxford ox qd united kingdom

markus krotzsch
sebastian rudolph

markus kroetzsch tu dresden de
sebastian rudolph tu dresden de

faculty computer science tu dresden
nothnitzer strae dresden germany

abstract
owl el popular ontology language supports role inclusionsaxioms
form sn v capture compositional properties roles role inclusions closely
correspond context free grammars used answering conjunctive
queries cqs owl el knowledge bases unrestricted role inclusions undecidable however owl el inherits owl dl syntactic regularity restriction
role inclusions ensures role chains implying particular role described
finite automaton fa sufficient ensure decidability cq answering
however fas worst case exponential size known approaches
provide tight upper complexity bound
solve open answering cqs owl
el knowledge bases pspace complete combined complexity e complexity
measured total size input end use novel encoding regular role
inclusions bounded stack pushdown automatathat fas extended stack
bounded size apart theoretical interest encoding used practical tableau
avoid exponential blowup due role inclusions addition sharpen
lower complexity bound pspace hard even consider
role inclusions part input e query parts knowledge
base fixed finally turn attention navigational queries owl el
knowledge bases answering positive converse free conjunctive graph
xpath queries pspace complete well interesting since allowing converse
operator queries known make exptime hard thus
present several important contributions landscape complexity answering
expressive queries description logic knowledge bases

introduction
description logics dls baader calvanese mcguinness nardi patel schneider
family knowledge representation formalisms logically underpin web ontology language owl cuenca grau horrocks motik parsia patel schneider sattler
dl knowledge bases describe domain terms concepts e unary predicates
roles e binary predicates individuals e constants describe relationships concepts roles individuals logical axioms dls owl

c

ai access foundation rights reserved

fistefanoni motik krotzsch rudolph

steadily gaining popularity provide developers modern
information systems flexible graph data model natural countless application areas semantic web gutierrez hurtado mendelzon perez
social network analysis fan network traffic analysis barrett jacob marathe
answering queries dl owl knowledge bases core service applications
diverse monitoring financial products within italian ministry economy
finance de giacomo et al accessing real time diagnostic data turbines giese
et al integrating configuration data air traffic control systems calvanese
et al due practical importance query answering theoretical investigation
expressivity computational complexity query languages high
agenda knowledge representation community past decade
conjunctive queries cqs chandra merlin basic class queries
relational databases querying dl knowledge bases cqs studied diverse range settings calvanese de giacomo lembo lenzerini rosati perezurbina motik horrocks rudolph glimm kontchakov lutz toman
wolter zakharyaschev ortiz rudolph simkus gottlob schwentick
venetis stoilos stamou however conjunctive queries first order definable thus cannot express certain important properties graph reachability
regular path queries rpqs cruz mendelzon wood barcelo alternative query language capable describing connections graph vertices
regular expressions allowing users navigate inside graph example rpq
ispartof haslocation retrieves pairs vertices connected via zero ispartof
edges followed one haslocation edge furthermore rpqs extend rpqs converse operator e backward navigation calvanese vardi de giacomo lenzerini
nested regular expressions allow existential quantification paths perez
arenas gutierrez c rpqs extend rpqs cqs conjunctions rpqs calvanese de giacomo lenzerini vardi bienvenu ortiz
simkus finally inspired xpath query language xml graph xpath queries
gxqs recently proposed language querying graph databases libkin
martens vrgoc dl knowledge bases kostylev reutter vrgoc bienvenu calvanese ortiz simkus gxqs extend rpqs negation regular
expressions checking properties vertices boolean combinations node tests
concepts existential quantifications paths example graph xpath
query ispartof test cell hhasspecialityi haslocation refines aforementioned rpq
requiring node ispartof edges haslocation edge instance cell concept outgoing hasspeciality edge graph xpath
queries straightforwardly extended conjunctive graph xpath queries cgxqs
query languages boolean answer variables hence answer
query boolean value
setting
although computing answers query dl knowledge base function
common literature consider complexity associated decision
checking whether boolean query entailed knowledge base article



fithe complexity answering cqs gxqs owl el kbs

follow well established practice analyse computational properties several
query languages dl knowledge bases follow vardi measure input
size two ways combined complexity measures complexity terms combined
size query knowledge base data complexity measures complexity
terms size data e query parts knowledge bases
considered fixed
computational properties query answering dl knowledge bases depend
expressivity constructs used knowledge base query language
used particular conjunctive query answering expressive description logics
least exponential combined complexity glimm lutz horrocks sattler lutz
intractable data complexity calvanese de giacomo lembo lenzerini
rosati ortiz calvanese eiter becomes tractable data
complexity rl grosof horrocks volz decker ter horst
ql calvanese et al artale calvanese kontchakov zakharyaschev profiles
owl several worst case optimal proposed perform well
practice urbani van harmelen schlobach bal rodriguez muro calvanese
however focus owl el profile owl
el family dls baader brandt lutz basic reasoning
owl el checking concept subsumption instance checking decided
polynomial time baader et al krotzsch makes language
interesting practical applications motivated observation present
several novel complexity answering queries owl el knowledge bases
one important modelling constructs owl el role inclusionsaxioms
form sn v express compositional properties roles example
following inclusions state role ispartof transitive x located
part z x located z
ispartof ispartof v ispartof

haslocation ispartof v haslocation

prior introduction el family role inclusions already identified
source undecidability expressive dls loosely correspond context free
grammars inclusion sn v knowledge base seen production rule
sn knowledge base induces context free language l role
correspondence wessel showed checking satisfiability alcr
knowledge bases unrestricted role inclusions undecidable regain decidability
horrocks sattler proposed syntactic regularity restriction role inclusions
ensuring language l regular thus recognised finite
automaton fa kazakov later showed cases size automaton
necessarily exponential knowledge base size owl dl profile owl
extends alcr thus incorporates regularity restriction definition
even unrestricted role inclusions standard reasoning el
solved polynomial time baader et al moreover stefanoni motik horrocks
showed answering cqs owl el knowledge bases without role inclusions
np complete however correspondence role inclusions contextfree grammars rosati krotzsch rudolph hitzler independently
proved answering cqs el knowledge bases unrestricted role inclusions


fistefanoni motik krotzsch rudolph

undecidable furthermore krotzsch et al showed checking concept subsumptions el knowledge bases inverse roles unrestricted role inclusions
undecidable
owl el inherits regularity restriction owl dl undecidability proofs rosati krotzsch et al apply owl el
fact krotzsch et al showed answering cqs el knowledge bases extended
regular role inclusions pspace hard combined complexity proposed
cq answering fragment owl el regular role inclusions
however runs pspace role language l represented automaton polynomial size due mentioned kazakov
provide us matching pspace upper bound
ortiz et al proposed different answering cqs owl
el knowledge bases regular role inclusions without restriction usage
features similarly krotzsch et al
ortiz et al encodes regular role inclusions finite automata hence
run time polynomial size data thus settle
question data complexity settle question combined complexity
comparatively works studying complexity conjunctive graph
xpath queries dl knowledge bases particular kostylev et al observed
gxqs closely related propositional dynamic logic full negation harel tiuryn
kozen immediately shows answering gxqs dl knowledge bases
undecidable even respect empty knowledge base several gxq fragments
proposed possible solution path positive gxqs disallow negation
role expressions positive gxqs prohibit negation concepts well
kostylev et al showed answering path positive gxqs intractable data
complexity already queries without transitive closure operator knowledge
bases containing instance assertions recently bienvenu et al showed
answering positive gxqs fragment owl el tractable data complexity
exptime complete combined complexity
contributions
present several novel complexity answering queries owl
el knowledge bases
first present first cq answering handle owl el
regular role inclusions without restriction size fas
runs pspace thus settle open question combined complexity
cq answering owl el novel encoding languages
induced regular role inclusions pushdown automata pdas fas extended
stack role construct polynomial time
pda accepts language l whose computations use stack size linear
number role inclusions bounded stack pdas anselmo giammarresi varricchio
recognise precisely class regular languages exponentially
succinct finite automata geffert mereghetti palano obtain cq
answering running pspace extend krotzsch et al



fithe complexity answering cqs gxqs owl el kbs

data
combined

elhodr

ptime

owl el
ptime

horn shoiq
ptime

horn sroiq
ptime

ortiz et al

theorem

ortiz et al

ortiz et al

np

pspace

exptime

exptime

stefanoni et al

theorem

ortiz et al

ortiz et al

table complexity landscape cq answering completeness
handle universal role keys self restrictions reflexive roles thus covering
features el profile apart datatypes adapt handle
regular role inclusions encoded pdas apart allowing us obtain complexity
presented tableau horrocks kutz sattler
used popular reasoners pellet sirin parsia cuenca grau kalyanpur katz
fact tsarkov horrocks straightforwardly modified use
bounded stack pdas instead fas could eliminate potential source inefficiency
practice finally brevity simplicity deal datatypes
however set owl el datatypes designed enable datatype
reasoning external datatype checking procedure baader brandt lutz
cuenca grau et al easily incorporated
second improve pspace lower bound krotzsch et al showing
answering cqs owl el pspace hard already role inclusions
considered part input e conjunctive query tbox abox
fixed furthermore cqs answered polynomial time query
role inclusions fixed emphasises observation role inclusions
main source pspace hardness
third positive converse free cgxqsthat cgxqs allow
negation paths negation concepts converse operatorcan answered
owl el knowledge bases polynomial space particular owl el allows
role inclusions self restrictions reflexive roles allow us polynomially reduce answering cgxq answering cq extended knowledge base
answering positive converse free gxqs e cgxqs single atom
done time polynomial input size interesting bienvenu
et al proved answering positive gxqs el knowledge bases exptimecomplete hence adding converse operator increases complexity gxqs
thus answering gxqs cgxqs difficult instance checking
answering conjunctive queries respectively least theoretical perspective
makes gxqs cgxqs appealing query languages owl el knowledge bases
summary complexity landscape
table summarises complexity landscape answering cqs dls related
owl el elhodr
fragment owl el obtained allowing simple
role inclusions form v disallowing universal role reflexive roles
self restrictions datatypes combined complexity logic due
stefanoni et al furthermore horn shoiq extends elhodr
inverse roles
horn qualified number restrictions horn sroiq extends horn shoiq role


fistefanoni motik krotzsch rudolph

data

positive
positive
converse free converse free
gxqs
cgxqs
ptime c
ptime c
theorem

combined

ptime c
theorem

positive
gxqs

path positive
gxqs

gxqs

ptime h

conp h

conp h

theorem bienvenu et al kostylev et al kostylev et al

pspace c

exptime h

exptime h

undecidable

theorem bienvenu et al bienvenu et al kostylev et al

table complexity answering navigational queries owl el knowledge bases
c means complete h means hard

inclusions logics due ortiz et al cq answering ptimecomplete data complexity cases essentially due fact
logics horn disjunctive reasoning needed combined complexity
table illustrates presence different constructs affects complexity answering
cqs particular extending elhodr
role inclusions increases complexity
np pspace pspace lower bound increase solely due role inclusions
furthermore extending elhodr
inverse roles increases complexity np
exptime finally extending owl el inverse roles increases complexity
pspace exptime
table summarises complexity landscape answering navigational queries
owl el knowledge bases one see adding converse operator increases
combined complexity gxqs exptime bienvenu et al moreover adding
negation node tests increases data complexity gxqs conp whereas adding
negation path expressions leads undecidability combined complexity kostylev
et al contrast existential quantification paths increase complexity answering positive converse free c gxqs owl el knowledge bases
difficult answering c rpqs el knowledge bases bienvenu et al
organisation article
rest article organised follows section present basic definitions
finite automata pushdown automata dl underpinning owl el conjunctive
queries section introduce novel encoding regular role inclusions pdas
bounded stack size section present cq answering owl
el discuss complexity section present improved pspace lower bound
answering cqs owl el finally section introduce conjunctive graph
xpath queries reduce answering positive converse free
conjunctive graph xpath queries answering ordinary conjunctive queries present
aforementioned complexity



fithe complexity answering cqs gxqs owl el kbs

preliminaries
section recapitulate basic definitions finite automata pushdown automata
dl elro underpinning owl el conjunctive queries rest
j set containing natural number k n k j
automata language theory
article use standard notions alphabets must finite strings string
concatenation kleene operators languages formal language theory hopcroft
motwani ullman assume alphabets contain special symbol
use label transitions automata consume input symbols
furthermore empty word finally w w words w number symbols
occurring w w w unique word w w w w w exists
otherwise w w undefined
finite automata
finite automaton fa tuple f hq f q finite set states
input alphabet q q transition function q start state
f q final state f deterministic c
q c otherwise f nondeterministic size f f number
symbols used encode f tape turing machine
instantaneous description f pair hs wi q w
derivation relation f smallest set states q
symbol c word w
c hs c wi hs wi
hs wi hs wi
let reflexive transitive closure language accepted f
defined l f w hi wi hf language l regular fa
f exists l l f
pushdown automata
pushdown automaton pda tuple p hq f f q finite set
states input alphabet stack alphabet transition function mapping
state q symbol c stack symbol x finite subset
c x q q start state start stack f q final
state f final stack size p p number symbols used
encode p tape turing machine
instantaneous description p triple hs w q w
read stack content left rightthat leftmost symbol
top stack derivation relation p smallest set
states q symbol c word w stack symbol x
words



fistefanoni motik krotzsch rudolph

hs c x implies hs c w x hs w
hs x implies hs w x hs w
let reflexive transitive closure relation language accepted
p defined l p w hi w ii hf f
definitions pda p language l p somewhat nonstandard
literature typically considers hopcroft pda hopcroft et al ph differs
definition contain final stack f initial stack symbol
rather word moreover language accepted ph defined
lh ph w hi w ii hf next definitions
equivalent standard definitions hopcroft et al
proposition following two properties hold
pda p hopcroft pda ph exists l p lh ph
hopcroft pda ph pda p exists lh ph l p
proof sketch first prove property prove property
transform arbitrary pda p hopcroft pda ph
l p lh ph ph uses fresh initial state fresh stack symbols z
occurring symbol z start stack symbol ph furthermore ph
transition moves pda state initial state p replacing z
start stack p point ph simulates p leaving
bottom stack reaches final state f p next ph uses fresh
states f fresh transitions move ph state f f reading f
stack finally f pda ph moves fresh final state f top
symbol stack thus accepting input whenever p reaches f f
stack automata p ph clearly accept languages
transform arbitrary hopcroft pda ph pda p
lh ph l p pda p uses fresh stack symbol initial stack
initial stack symbol ph final stack empty word p simulates ph
leaving bottom stack reaches final state f ph next p
moves fresh final state f pops topmost symbol stack point
pda takes transitions empty stack eventually reaching final state
empty stack automata p ph clearly accept languages
k natural number k bounded language accepted p set lk p containing word w derivation hs w hsn wn n exists
sn start final state p respectively
w w wn
n start final stack p respectively
k n



fithe complexity answering cqs gxqs owl el kbs

p k bounded stack l p lk p stack p bounded
constant pda p simulated finite automaton encodes stack contents
states l p regular translating p finite automaton may
require space exponential k geffert et al contrast following proposition
shows exists pda pk l pk lk p size pk polynomial
size p k
proposition pda p natural number k one compute polynomial
time pda pk l pk lk p
proof let p hq f f pda let k n natural number let
pk hqk k ik fk f pda defined
qk q k
transition function k smallest function k symbol
c states q word hs c x
k hhs k hs c x
ik hi fk hf f
clearly pk computed time polynomial size p k let k
derivation relations p pk respectively definitions k ik
hhs w k hhs ji w hs w hs w j
max j k thus lk p l pk required
description logic elro conjunctive queries
description logic elro underpinning owl el defined w r signature consisting mutually disjoint countably infinite alphabets c r atomic concepts
roles individuals respectively assume c c c c top
concept c bottom concept similarly assume r r r r
top role universal role r bottom role individual expression
nominal concept consisting precisely individual n set
containing nominal individual call b c n basic concept
role chain word r call empty role chain write
concepts tbox axioms rbox axioms abox axioms defined specified
table elro tbox finite set concept inclusions range restrictions
keys elro rbox r finite set role inclusions
r elro rbox let r r r occurs r furthermore
rewrite relation
w r r smallest relation role chains following
holds role chains

axiom v r
r
role chain r

reflexivetransitive closure
role l r

language induced rbox r role simple r role chain


fistefanoni motik krotzsch rudolph

concepts
top concept
bottom concept
nominal
conjunction
self restriction
existential restriction
role chains
top role
bottom role
empty role chain
nonempty role chain
tbox axioms
concept inclusion
range restriction
key

rbox axioms
role inclusion
abox axioms
concept assertion
role assertion

syntax

semantics

c
c

c ud
self
c



ai
c di
x hx xi
x c hx yi

r
r

sn



hx xi x
sni

cvd
range c
key c sn

c di
c
x z zn
individuals b c cn exist
x ai bi zi cii n
x holds whenever x c
hx zi hy zi sii n

vs


bi
si

b
b

hai bi

table interpreting elro concepts roles axioms interpretation hi


elro abox finite set concept role assertions
finally elro knowledge base kb tuple k ht r ai elro
tbox r elro rbox elro abox
concept self occurring role simple r
sn v r range c
role sn r



exists sn
sn range sn c
let r numbers symbols needed encode r respectively
tape turing machine let k r furthermore knowledge
base tbox abox define
occurs n c c occurs


fithe complexity answering cqs gxqs owl el kbs

semantics elro defined follows interpretation tuple hi
nonempty set domain elements called domain interpretation function maps individual domain element ai
atomic concept c c c set ai atomic role r r r
relation function extended concepts role chains shown
upper part table denotes composition binary relations interpretation model k satisfies axioms occurring k shown bottom
table moreover k consistent model k exists k inconsistent model
k exists k entails first order sentence resp concept inclusion c v role
inclusion v written k resp k c v k v resp c di
model k definition l l implies
k v knowledge base consistency entailment concept inclusions entailment
role inclusions decided polynomial time krotzsch baader et al
conjunctive queries
term individual variable atom expression form r
atomic concept r role terms conjunctive query cq
formula q x conjunction atoms variables x variables x
answer variables q x empty call q boolean cq bcq
substitution partial mapping variables terms dom rng
domain range respectively conjunction atoms
applying substitution atoms q z z contains
variable variable ii variable
undefined definition q somewhat nonstandard quantified
variables replaced example given q r
z q z r z
let k ht r ai elro knowledge base let q x cq
q k q uses predicates individuals occurring k substitution
candidate answer q k dom x rng ik certain
answer q k k q answering q k amounts computing
set certain answers q k stated cq answering function
thus article study complexity associated decision named bcq
answering deciding given boolean cq q k whether k q
please note bcq answering equivalent recognition decides
given cq q k candidate answer whether certain answer q k
following vardi combined complexity assumes q k part
input data complexity assumes abox part input
ensuring decidability bcq answering via regularity
rosati krotzsch et al independently showed answering boolean
cqs elro knowledge bases undecidable intuitively role inclusions simulate derivations context free languages thus boolean cq check whether two
context free languages non empty intersection known undecidable hopcroft et al



fistefanoni motik krotzsch rudolph

regain decidability next recapitulate definition called regular rboxes
horrocks sattler let r elro rbox let smallest
transitive relation r v r
rbox r regular irreflexive role inclusion v r form
v
v
sn v si n
sn v si n
sn v si n
induction define level lv role r follows lv
r exists otherwise lv max lv clearly
lv computed time polynomial r section bcq answering
elro kbs regular rboxes pspace
normalising elro knowledge bases
simplicity rest assume elro knowledge base
k ht r ai normalised case following properties hold
n ik k v b b ik b
n axiom one following forms basic concepts role
u v

v

v

v self

self v

n axiom v r r role
occurs r
next knowledge base k normalised polynomial time without
affecting regularity rbox component answers boolean cqs
proposition elro knowledge base k regular rbox boolean
cq q k one compute polynomial time normalised elro knowledge base
k boolean cq q
rbox k regular
q k k q k q
proof let k elro kb regular rbox let q boolean cq k
first satisfy property n let k obtained k extending abox
k assertion c c c fresh individual clearly k q k q
next let k q obtained k q respectively uniformly substituting
individual arbitrary fixed individual b k v b entailment


fithe complexity answering cqs gxqs owl el kbs

concept inclusions decided polynomial time k q computed
polynomial time moreover k q obtained replacing individual
arbitrary fixed individual b ai bi model k q k
k q k q
next satisfy property n let k eliminating keys k
one see table keys derive axioms form v b moreover
effects conclusions already captured k k q
k q next eliminate polynomial time range restrictions occurring
k applying syntactic transformation baader et al let k resulting
knowledge base since definition elro knowledge base carefully restricts
interactions role inclusions range restrictions k q
k q baader et al next following krotzsch compute polynomial
time knowledge base k satisfies n k q k q
next satisfy property n let k exhaustively decomposing
role inclusion v form occurring k according
following rewrite rules occurrence role fresh
sn v v
sn v


sn v sn v sn v
sn v

v
sn v
linearly many rewrite steps required satisfy n resulting rbox
regular furthermore model k model k model k
expanded model j k interpreting role occurring k k
j j unique role chain v occurs k thus
k q k q next let k removing axiom
v r k removed axioms tautologies k q k q
finally let k adding axiom r v role occurs k
occur rbox component axioms k k preserve regularity
tautologies k q k q required

encoding regular rboxes succinctly bounded stack pdas
reasoning dl role inclusions known us uses step checks
whether l holds arbitrary role chain role example check
whether k b holds must ensure model k role chain
l exists connecting elements interpreting b although characterise
languages l role inclusions lend well language recognition
known us transform role inclusions another manageable form
analogous fact regular expressions characterise regular languages
former routinely transformed fas order facilitate language recognition
horrocks sattler showed regular rbox r role
occurring r one construct fa fs l fs l fas used
tableau decision procedure sroiqthe dl underpinning owl dl horrocks
et al given sroiq knowledge base tableau procedure tries construct


fistefanoni motik krotzsch rudolph





start








fs



fs





fs

fs
















fs



fs





fs

figure fa fs constructed following horrocks sattler
finite graph representing model kb edges labelled roles
vertices labelled concepts aforementioned fas used ensure universal
restriction c obey constraints imposed role inclusions roughly speaking
obtained running fs graph updating current state fs along
path labelling reachable vertex state fs final concept
c simanck optimised tableau procedure simulating fas fly rather
precomputing advance
horrocks sattler observed fas contain exponentially many
states kazakov proved unavoidable cases regular rbox
rn containing axioms size fa f l f l sn exponential n
si si v si

n



blowup number states caused simple model computation underlying fas behaviour automaton determined solely current state
example l sn whenever consists si repeated j times
n j ni thus parsing fa recognising l sn must
remember number occurrences si already seen achieved
different state number n figure shows fa fs
constructed horrocks sattler remember current state fs contains
two copies automaton fs copy fs contains two copies automaton fs
hence obtain pspace procedure must devise succinct representation
languages induced role inclusions towards goal note role inclusions
closely related context free grammars context free languages efficiently
recognised pushdown automata hopcroft et al fas extended
infinite stack storing contextual information hence given regular rbox r
role occurring r construct pda ps accepts l unlike fa shown
figure remembers contextual information states pda ps uses stack
remember current status computation determine proceed
number states ps polynomial size r ps recognise
l stack size linear size r thus ps provides us required
succinct encoding fs section use pdas answers
boolean cqs elro knowledge bases polynomial space


fithe complexity answering cqs gxqs owl el kbs

start



x x

fs
x x

x fs x



x x

r

fs

r x x

f r

x x
x fs x



x x

fs

figure pda ps corresponding fa fs x r r r
rest section fix arbitrary regular rbox r proposition
assume role inclusion v r r
role occurring r next define pda ps
definition let r role ps hqr r r r fs pda
qr ft r set states r qr stack alphabet
r smallest transition function satisfying following conditions x r
r r r hft xi r x
v r hft xi r x
v r hit xi r ft x
v r hit xi r x
v r hit ft xi r x
v r hit ft xi r ft x
ur r hf r xi r r x
u hf r xi r r x
u hi r xi r f r x
p r qr hs r ft
following examples present pda succinctly encodes fa fs
explain different types transitions definition content
stack influences computation pdas
example figure shows pda ps corresponding fa fs figure
c x

transition hs r c x shown x indicates transition replaces top stack symbol x word moreover transitions form
p definition shown figure sake clarity one see
figure unlike fa fs copying states pda ps


fistefanoni motik krotzsch rudolph

x x

start



x x

x r fs x

r

fs

r x x

f r

x x

x fs x
x x

ip



x x

ft

x x
x x

p x x

fp
figure pda ps rbox example x r r r
example explain different types transitions definition stack
used computation pda use regular rbox r containing role inclusions
figure shows pda ps notation example
vp



vt



p r v



st vs



p vt



role r associated states ft moving former
latter ensures pda reads role chain l transition type r allows
pda read state transition type ft added
reflexive allows pda read empty role chain example axiom
introduces transition ip fp moreover transition type
ft added transitive allows pda read number role
chains n l example axiom introduces transition ft
transitions types ur u u analogously reflect properties r
ur allows pda read arbitrary role u u reflect reflexivity
transitivity r respectively none transitions affect pdas stack
illustrate transitions type next p pda ps
determines l latter ensured axiom assume pda ps
state stack due axiom ps make transition type
state ip pushing r fs stack since state ip pda next need
read p furthermore stack content signals pda finishes reading
p move state r read r state fs finish reading indeed
ps make transition type r state fp read p followed transition
type p state r popping r stack next pda make transition


fithe complexity answering cqs gxqs owl el kbs

type ur state f r reading followed transition type p state fs popping
fs stack point pda accepts input
illustrate transitions types next p pda
ps determines l latter ensured axioms assume
pda ps state stack pda ps make transition type
r state fs reading leaving stack unchanged next due axiom ps
make transition type state pushing fs stack due axiom
pda ps next make transition type state ip pushing stack
point stack contains fs next pda make transition type
r state fp reading p transition type p state popping
stack furthermore analogous way pda move state ft reading
leaving fs stack finally pda make transition type p state
fs popping fs stack point pda accepts input
understand benefit pdas rather fas note ps reaches state ip
recognising role p occurs axioms ps moves
state ip order read occurrence p must remember two
axioms caused move knows continue reading p ps must
continue reading r whereas must continue reading unlike fas horrocks
sattler remember information copying states ps remembers
information stack reaches ip r fs stack whereas
ps reaches ip fs stack thus stack ps analogous stacks
programming languages stack symbols correspond return addresses transitions
type p correspond return statements
following proposition immediate definition pda ps
proposition pda ps computed time polynomial r
following theorem states pda ps accepts l ps stack bounded
size r proof given section
theorem role r role chain
l ps l
ps stack bounded lv
theorem gives rise following notion depth rbox r provide us
global bound stack size pdas encoding r
definition depth rbox r defined dr maxsr lv
finally outline bounded stack encoding regular rboxes reduce
space used tableau sroiq since elro support inverse
roles definition directly provide us encoding languages induced
sroiq rboxes nevertheless extend construction completing
rbox r inv sn inv v inv r role inclusion sn v
rbox inv maps role inverse one check inverse role


fistefanoni motik krotzsch rudolph

pda ps constructed completed rbox r encodes fs modify
portion tableau responsible checking satisfaction universal
restrictions running bounded stack pda graph constructed tableau
procedure roughly speaking universal restriction c labelling vertex run
ps graph updating current state stack ps label
reachable vertex current state stack ps final concept c since
ps stack size polynomial r requires polynomial space unlike
fas horrocks sattler optimised encoding simanck
may require exponential space
proof correctness
section prove theorem towards goal let derivation relation
w r transition function r furthermore derivation step hs hs
write hs x hs hs obtained hs applying
transition form x definition x r ur u u p
soundness stack boundedness
section prove role r role chain
l ps implies l
ps stack bounded lv
end first pda ps satisfies following liveness property
computation ps pushes state qr stack ps eventually pop
stack derivation ps moving state state fs takes
one five forms call derivations regular finally regular derivations
satisfy properties
start showing pda ps satisfies following liveness property
lemma let hs hsn n n arbitrary derivation
sn fs role r word r
role lv lv n si ft
qr index j n exists
sj ft j
b k j word k form k k k r
c sj j j j
proof let hs hsn n n n let
xi r ur u u p form derivation step ithat fix xi arbitrarily one possibility hsi xi hsi
holds furthermore role lv lv let set containing
index n si ft form qr
note index due lv lv si ft sn fs


fithe complexity answering cqs gxqs owl el kbs

nthat hsi hsi occurs derivation next
induction n role lv lv
j n exists satisfying properties c
base case consider arbitrary role r lv lv
consider interesting case otherwise properties c hold vacuously
since lv si ft xi r ur u u p reverseinduction e induction starting maximal element next
index satisfies required properties
base case let max xi r ur u u si ft
thus contradicts maximality
remaining possibility xi p implies si ft si
j satisfies properties c
inductive step consider arbitrary index properties c hold
xi r ur u u si ft
hence ii inductive hypothesis index j exists satisfying properties
c otherwise xi p si ft si j
satisfies properties c
inductive step consider arbitrary n properties c hold
role p r lv p lv p lv index ip furthermore
consider arbitrary role lv lv consider interesting
case otherwise properties c hold vacuously recall
v r r lv r r thus
xi ur u u reverse induction next index satisfies
required properties
base case let max xi r si ft
thus contradicts maximality xi
si ip fp role p lv p lv lv p lv furthermore
f
form




sequence

zero one states state occurring
ir fr role
r level less inductive hypothesis index exists
st contradicts maximality finally xi p
si ft si j satisfies properties c
inductive step consider arbitrary index properties c hold
index consider possible forms xi
xi r si ft inductive
hypothesis index j exists satisfying properties c
xi si role lv lv
thus inductive hypothesis index n exists
ft furthermore k k
form k k word k r finally
definition inductive hypothesis
index j exists satisfying properties c


fistefanoni motik krotzsch rudolph

xi si ft roles
lv lv lv lv thus inductive hypothesis
index n exists ft furthermore
k k form k k word k r
finally ft inductive
hypothesis index n exists ft
furthermore k k form k k
word k r finally ft definition
inductive hypothesis index j exists satisfying
properties c
xi si ft role lv lv
inductive hypothesis index n exists
ft k k form
k k word k r finally ft
definition inductive hypothesis
index j exists satisfying properties c
xi p si ft si therefore j satisfies
properties c
next role r define notion regular derivations ps
definition set regular derivations p r inductively defined follows
role r role chain r r
sequr hi r ur hf r regular derivation p r
sequ hi r u hf r regular derivation p r
sequ hi r hf r k hi r k hf r n regular derivations p r following regular derivation p r
hi r hf r k u hi r k hf r n
next consider arbitrary natural number n assume regular derivations
pt already defined r role r r lv
role r r lv regular derivations ps defined
follows r r r
seqr r hfs regular derivation ps
seqt v r hfs regular derivation ps
seqt v r hfs k k hfs n
regular derivations ps following regular derivation ps
hfs k k hfs n



fithe complexity answering cqs gxqs owl el kbs

seqt v r hfs k regular derivation
ps k hfs n regular derivation ps following
regular derivation ps
hfs k p k hfs n
seqt v r fs hfs k fs regular derivation ps k fs hfs n fs regular derivation ps
following regular derivation ps

fs
fs
k
hfs n


hfs k fs p
fs p
hfs n


seqt v r hfs k regular derivation ps
k fs hfs n fs regular derivation ps following regular derivation ps
hfs k k fs hfs n fs p hfs n
left derivation ps moves pda start state
final state fs regular regular derivations satisfy required properties
following lemma derivations leave particular word
bottom stack regular satisfy properties subsequently
accepting derivation ps form
lemma role r word r derivation form
hs hsn n n sn fs
derivation regular ps
ii n lv
iii
n
proof prove claim induction n n
base case n consider arbitrary role r word r sequence
hfs definition transitions cases r ur
u move ps state state fs transitions leave stack untouched
property ii holds properties iii next consider
four different forms sequence may take
r hfs r regular derivation
ps case seqr holds finally implies

iii holds


fistefanoni motik krotzsch rudolph

hfs r regular derivation ps
case seqt holds finally moreover case definition
v r
hence
iii holds
ur hfs r r regular
derivation p r case sequr holds finally r
implies
iii holds
u hfs r regular derivation p r
case sequ holds finally hence
iii holds
inductive step consider arbitrary n n assume iii hold
role r word r derivation hs hs c c c
length n form required lemma furthermore consider
arbitrary role r arbitrary word r arbitrary derivation
hs hsn n n



length n sn fs n let
xi r ur u u p form derivation step ithat fix xi arbitrarily one possibility hsi xi hsi
holds next consider possible forms sequence might
properties iii hold case
case r consider form hs x hs since
r x ur u r normalised v r
r x ur u f r since n
hs x hs occurs sequence x u p since
f r r normalised x u p furthermore since
assumption form x p hence remaining possibility
x u case u definition r
next prove properties iii hold
sequr sequ hs x hs regular derivation p r
inductive hypothesis hs hsn n n regular
derivation ps definition regular derivations n
regular derivation ps case sequ
ii words empty inductive hypothesis lv r
n therefore lv r holds n
iii inductive hypothesis r
n cases ur u
r r
n holds
case r k n exists hsk k k hsk k k
sk fs case definition v r sk k k
k k next prove properties iii hold



fithe complexity answering cqs gxqs owl el kbs

inductive hypothesis hs hsk k k regular derivation
ps definition regular derivations k since sk
k k hsk k k hsn n n
form shown shorter n inductive hypothesis
regular derivation ps regular derivation ps case seqt
ii inductive hypothesis lv k well
lv k n therefore lv holds
n
iii inductive hypothesis
k
k n

v r k k implies
n holds
case r n exists hs hs
fs k n exists hsk k k hsk k k
sk fs let k largest indexthat assume k exists
hsm hsm sm fs case
definition role level less v r sk
k k k fs k next prove properties iii hold
since sk fs inductive hypothesis hs hsk k k
regular derivation ps definition k since sk
k fs lemma index j k n exists sj fs
j k furthermore sj fs j j j prove
j n sake contradiction assume j n consider
form transition hsj j j xj hsj j j given
sj fs r must xj p initial assumption
xj furthermore maximality k xj finally
since j xj p thus j n required follows
sequence following form k k n n

hfs k
k k hfs n n p
hfs n
lemma k n form fs

particular words k
n empty inductive hypothesis
k k hfs n n regular derivation ps
case seqt regular derivation ps
ii inductive hypothesis k lv furthermore k n lv since lv lv
fs lv given n
n lv
iii inductive hypothesis
k
k n given


k k n n obtain
n



fistefanoni motik krotzsch rudolph

case r n exists hs x hs
fs x hs hs case definition role level less v r
next prove properties iii hold
since lemma j n exists sj fs
j furthermore sj j j j sequence
following form


j p
hfs j

j j hfs n n
lemma j form
particular words j empty inductive hypothesis
hfs j j regular derivation ps since j
inductive hypothesis j j hfs n n
regular derivation ps case seqt regular derivation ps
ii inductive hypothesis j n lv
furthermore j lv since lv lv
lv finally since
n lv
iii inductive hypothesis
j
j n
given
j j
n
case r n exists hs x hs
fs x addition hs x hs x
next consider remaining possibilities x x u p
cases u p definition furthermore due r
x ur u cases ur u definition moreover assume x r
fs cases r definition since n
r possibility hs p hs impossible
due assumption form hence remaining possibility
x case definition roles level less
v r fs next prove
properties iii hold
since fs lemma j n exists sj fs
j furthermore sj j fs j j
lemma j j n exists sj fs j j furthermore
sj fs j j j next prove j n
sake contradiction suppose j n consider form
hsj j j xj hsj j j given sj fs
must xj u p however assumed xj
r xj u finally since j xj p


fithe complexity answering cqs gxqs owl el kbs

therefore j n required sequence following
form j j n n



hfs j j p
j j hfs n n p
hfs n n
lemma j word form fs
particular words j empty inductive hypothesis
hfs j j regular derivation ps
similarly lemma j n form
fs particular words j n empty
inductive hypothesis j j hfs n n
regular derivation ps case seqt regular derivation ps
ii inductive hypothesis j lv since
lv lv fs lv similarly
inductive hypothesis j n lv since
lv lv fs lv since
n lv
iii inductive hypothesis
j
j n given


n n conclude
n
possibilities form claim lemma holds
derivation form
finally ready pda ps satisfies properties
lemma role r role chain
l ps implies l
ps stack bounded lv
proof definition ps transitions resulting case p definition
ones popping elements stack never pop symbol hence point
accepting derivation ps stack content form
two claims follow immediately lemma
completeness
next prove encoding complete thus proving theorem
lemma role r role chain l implies
l ps



fistefanoni motik krotzsch rudolph

axiom type

vt








derivation
hft



hit



vt

hit
hit




v

hit
hit
hit


v

hit
hit ft
hit

ft

hft


v

hit
hit

hft





r
r


r
r

r
r


r
ft r






hft
hft







hft
hft





p

hft ft p
hft

ft p
hft
hft



ft p

table definition derivation depending form axiom v
proof consider arbitrary role r following role chain write



furthermore n write
role chains
exist


definition l

l natural number n exists
induction

n next
implies l ps


base case let
consider two cases depending
form role r
r case ur definition hi r r ur hf r
r r case r definition r hfs
case l ps required
inductive step consider arbitrary n assume role chain


l ps holds
consider arbitrary role chains




definition relation
role r role chains exist role chain
form role chain form


since
inductive hypothesis l ps
sequence hs hsn n n ps exists sn fs furthermore
n finally n exists index
n furthermore j role chain



j form j
j role chain j r next consider form
xi hsi xi hsi definition transitions cases r ur
read symbols input xi r ur lemma holds case


fithe complexity answering cqs gxqs owl el kbs

case consider case xi r si si ft
r r due
r v r
following derivation ps




hs
hsi







derivation table v


hsi hsn n



derivation defined table depending form axiom v r
case consider case xi ur si r si f r
r following derivation ps




hs
hsi


derivation seq





hsi hsn n
derivation seq inductively defined follows

hi r u hf r


seq



hi r ur hf r u seq p







therefore case l ps required

polynomial space bcq answering elro
elro knowledge base k translated set first order horn clauses
boolean cq q k answered evaluating q called canonical model
model homomorphically embedded model k canonical
usually obtained chase many different chase variants studied
literature producing different homomorphically equivalent canonical
model johnson klug marnette cal gottlob kifer baget leclere
mugnier salvat introduce variant call consequencebased chase possibly infinite set assertions ik produces k call
universal interpretation k compute ik consequence chase initialises ik
contain abox k well assertions c r b individuals
b occurring k iteratively extends ik chase rules slightly unusual
aspect chase variant considers axioms entailed contained
k example ik point contains assertion w k v b holds
ik extended assertions w w b w w fresh term term w
said auxiliary type b concept type b bcq answering
present section checking consequences k chase variant
makes proofs simpler example illustrates aspects
example let k ht r elro kb contains axioms
r contains role inclusion
v




fistefanoni motik krotzsch rudolph



b














b

r



b

b







c

os







ot b

os b

r




os c








b

universal interpretation

compact interpretation

figure universal interpretation compact interpretation k
v



b v



b v b



b v c



c v b



c v r b



st vs



figure shows universal interpretation ik k assertions involving c r
shown clarity edges obtained via role inclusions dashed remaining edges
solid apart dotted edges denote repetition solid edges black edges
obtained conventional chase variants whereas light grey subbranches ik
caused axioms entailed occurring k auxiliary terms labelled
integers terms type shown next term universal interpretation ik
viewed family directed trees whose roots individuals k
solid edges point parents children individuals k axiom makes ik
infinite decision procedure bcq answering cannot simply materialise ik
evaluate query instead finitary representation ik needed
axioms k b v b since b b ik
consequence chase ensures b b ik holds well contrast
commonly considered chase variants ensure b b ik k
contain axiom b v b
rest section present first worst case optimal decides
k q given arbitrary regular elro kb k boolean cq q k towards
goal section review existing approaches answering cqs dls discuss


fithe complexity answering cqs gxqs owl el kbs

techniques provide optimal procedure elro section
discuss intuitions behind section introduce
formally runs polynomial space combined size k q
polynomial time size k section prove correctness
existing approaches answering cqs
techniques answering conjunctive queries dl knowledge bases developed thus far
broadly classified following three groups
first group consists automata approaches dls horn shiq
horn sroiq ortiz et al sh eiter ortiz simkus fragment elro obtained disallowing universal role reflexive roles self restrictions krotzsch et al techniques however require constructing automata
whose size exponential size knowledge base
second group consists rewriting approaches roughly speaking approaches rewrite query tbox another formalism usually union
cqs datalog program relevant answers obtained evaluating
rewriting abox rewriting approaches proposed members
dl lite family artale et al calvanese et al dls el rosati
elhio perez urbina et al mora rosati corcho hornshiq eiter ortiz simkus tran xiao b members datalog family virgilio orsi tanca torlone name rewriting
however supports nominals role inclusions moreover common shortcoming
rewritings exponential query tbox size approaches
may use exponential space
third group consists approaches particular interpretation k
call compact interpretation figure shows interpretation kb k
example finitely approximates universal interpretation individuals
form os b represent auxiliary terms type b compact interpretation thus
materialised space polynomial k used answer instance queries
test atomic subsumptions k baader et al krotzsch materialising
compact interpretation lies core many reasoning el variants
natural try use interpretation answering cqs well since compact
interpretation model k cq maps universal interpretation maps
compact interpretation well however example shows converse
necessarily hold
example let k example let q q q following bcqs
q x r x b

q x x b x

q x b x b x

compact interpretation k shown figure one see obtained
universal interpretation merging terms type b onto individual os b
query q mapped onto compact universal interpretation queries
q q mapped onto compact interpretation thus evaluating q q
compact interpretation produces unsound answers


fistefanoni motik krotzsch rudolph



b



b b

ax

b

r
r



b





b


r





r







b






b


p





b






b





p b






b

universal interpretation


b



z b

skeleton q

figure universal interpretation k skeleton q
remedy combined approaches developed first evaluate query
compact interpretation filter eliminate unsound answers
approaches developed members dl lite family kontchakov et al
lutz seylan toman wolter el family lutz toman wolter
stefanoni et al dls datalog family gottlob manna pieris
rule languages particular stefanoni et al developed filtering
step applicable dl elhodr
step breaks k contains role inclusions
query q example mapped onto compact interpretation mapping
atom b x dashed edge e edge obtained via role inclusions moreover q
tree shaped filtering step stefanoni et al identify
match unsound intuitively understood follows unfolding
query query q essentially asks whether role chains l l
exist label path solid edges ik starting b compact interpretation
satisfied x mapped individual ot b individual
ot b however represents distinct terms ik hence although connected
b via connected b via role chains satisfy query q
words compact interpretation small represent relevant conditions
intuitions
worst case optimal procedure bcq answering elro shown
page essentially extends refines krotzsch et al
explain underlying intuitions knowledge base shown example
example let k elro knowledge base whose tbox contains axioms
whose rbox contains role inclusions
v r
v b





fithe complexity answering cqs gxqs owl el kbs



x x

fs

x fs x



x x

ft

x x

figure transitions r corresponding axioms
avd



b v b



b v p b



b v self



b v b



vt



st vs



moreover let q following boolean cq k
q x z x x z z



figure shows universal interpretation ik k notation example
solid looping edges auxiliary terms concept type b obtained axiom one
see k q holds example following substitution embeds q ik
x z



uses pda encoding rbox described section transition
function r axioms shown figure notation example
note figure contained figure
must prove existence substitution mapping q ik substitution
map binary atoms q dashed edges figure dashed edges introduce
shortcuts terms ik dashed edge unfolded path consisting
solid edges role inclusions k solid paths ik two
types auxiliary paths involve auxiliary terms whereas nominal paths require moving
least one individual instance edge unfolded path
connecting b b contrast edge
unfolded path connecting
uses pdas transition function figure represent binary atom
q sequence binary atoms mapped corresponding solid path ik
interpretation ik however infinite space possible substitutions infinite
hence prove existence substitution mapping q ik cannot simply
enumerate use instead


fistefanoni motik krotzsch rudolph

line check whether k unsatisfiable k q holds trivially next
line guess substitution continue checking k q thus step takes
account variables could mapped individuals two variables could
mapped term example guess identity mapping
step guess finite structure called skeleton q represents
possibly infinite set substitutions mapping variables q distinct auxiliary
terms ik figure shows skeleton query example skeleton vertices
individuals k variables q arranged forest whose
roots individuals moreover vertex v assigned atomic concept v
step skeleton represents substitution satisfying following
two properties
maps variable x term concept type x
edge hv v v descendant v ik
next extend conditions prune set substitutions goal
leaving substitutions compatible q embed q ik
establish compatibility unary atoms q line particular consider
atom x q property substitution represented skeleton
figure maps variable x term concept type x implying x ik
holds since k x v holds know x ik holds well thus
atom x satisfied substitution represented
contrast cannot establish compatibility binary query atoms entailment
checking vertex labels relative position vertices sufficiently
describe substitutions example substitution
x z



satisfies properties x z ik
prune substitutions lines guess binary atom
q unfold sequence solid steps ik solid paths ik go
nominals auxiliary terms two possibilities accounted
guessing line moreover skeleton already constrains relative positions
query terms represent unfolding binary atom labelling edge hv v
set l v v bounded stack pdas transition function figure
substitution represented satisfies following property
pda p l v v nonempty role chain l p exists labelling path
ik solid edges v v
next illustrate label edges substitutions satisfying properties
compatible binary atom q
x z must ensure substitution represented role chain
l exists connecting x z solid edges since relative positions
x z ik determined shown figure path must connect
x b connect b finally connect z addition
assume individuals occur paths b z


fithe complexity answering cqs gxqs owl el kbs

r


r



r

b






p


b

start

b



start

figure left hand side walking finite automaton wfa b transitions involving c r shown clarity right hand side stationary finite automaton sfa b

path x z involves individuals b visits b
absorb path segments subpath x b thus check
existence setting v au b lines guessing possible line
case splitting lines path three subpaths particular
line guess states ft line guess stack words
following properties
subpaths x b described pda pt whose start state stack
respectively final state stack respectively
ii subpaths b described pda pt whose start state stack
respectively final state stack respectively
iii subpaths z described pda pt whose start state stack
respectively final state stack respectively
know terms ik variables z mapped cannot
check existence paths ii iii independently therefore add line
pdas pt pt constraints edges hb yi hy zi respectively edges
thus accumulate constraints moves auxiliary terms must satisfy later
shall explain lines check constraints check passes
know map z auxiliary terms whose concept types
z respectively contrast path finishes individual
check existence path independently constraint end
construct walking finite automaton wfa b shown left hand side figure
wfa b describes moves ik terms concept type x
individual bthat l wfa b term w concept type
role chain connecting w b ik via solid edges line check
whether intersection languages wfa b pt empty wfa b
fa pt pda test emptiness intersection languages
polynomial time hopcroft et al example guess ft


fistefanoni motik krotzsch rudolph

thus pt accepts language b connected solid edge
labelled p adding pt constraint edge hb yi ensures substitution
satisfy property
z must ensure substitution represented role chain
l exists connecting z solid edges even though z
descendant line could guess v au b connects b
without going individuals connects b z via rest
paragraph however consider case connects z directly
since possibility example one see figure therefore
line guess v path z could first loop
due self restrictions must actually move z finally could
loop z reasons discuss following paragraph absorb latter loop
constraint added edge hy zi however check existence former loop
independently therefore lines split two subpaths particular
line guess states fs line guess stack words
following properties
looping described pda ps whose start state stack
respectively final state stack respectively
ii subpaths z start move possibly involve
looping z described pda ps whose start state stack
respectively final state stack respectively
previous case check ii adding ps constraint edge hy zi
furthermore check existence path constructing stationary finite
automaton sfa b shown right hand side figure sfa b describes
possible loops terms concept type b l sfa b
term w concept type b role chain corresponding possibly
empty loop w line check whether intersection languages
sfa b ps empty example guess fs thus ps accepts
language whereas ps accepts language
line skeleton represents substitutions compatible
atoms q must still least one substitution realised
universal interpretation ik end apply page
edge hv v skeleton thus check whether terms v v ik exist
satisfy properties pdas l v v roughly speaking solve
running pdas parallel lines however cannot
materialise ik exploit property consequence chase procedure term
w concept type connected term w concept type b ik solid
edge labelled k v b furthermore concept type w fully
describes solid paths descendants w need keep track actual
position ik instead use variable concept keep track current terms concept
type thus line check existence edges ik via entailment checking
pda line guess state stack pda line check
whether pda perform move line actually move pda due


fithe complexity answering cqs gxqs owl el kbs

self restrictions reflexive roles however pdas need move synchrony
move solid edge pdas independently loop current term
end line guess state stack pda moves
looping line check whether pda move state stack
state stack role chain compatible concept type term
pda moving given stationary finite automaton sfa
pdas required loop fa sfa accepts empty word thus checks
loops move line necessary lines
take account pdas nondeterministic initially make
several transitions note explicit check transitions required initially
since line allows possible transitions move along solid edge finally
ensure termination observing since stack pda l v v
bounded number current configurations pda exponential
number distinct tuples current pda configurations exponential well
hence repeats computations exponentially many steps
thus obtain nondeterministic decision procedure running polynomial space
binary counter stop computation distinct configurations explored
constraints added previous paragraphs one check
returns true edges hence k q holds thus k q holds well
formalisation
formalise intuitions previous section towards goal fix
normalised elro kb k ht r ai regular rbox r let qr r r
specified definition let dr depth r specified section
start formalising notion skeleton boolean cq
definition skeleton boolean cq q triple hv e
following components
v ik set vertices
e v set edges directed graph hv ei forest whose
roots precisely elements ik
c ck function maps existential variables q atomic
concepts convenience extended v v v v ik
path nonempty sequence distinct vertices v vn n
n hvi vi e
please observe k normal form exists least one individual occurring
k thus v next generalise notion pda encoding rbox r
definition allowing arbitrary start final states well arbitrary start
final stacks size dr generalised pda used
implement splitting operation mentioned section
definition states qr words r dr dr
generalised pda r given pda hqr r r r


fistefanoni motik krotzsch rudolph

following definition introduces automata one use succinctly represent
axioms logically follow k
definition let b basic concepts walking finite automaton
b given wfa b hq r w bi q w follows
q c ck nk
w transition function containing w c role r
states c q k c v
stationary finite automaton given sfa h r ai
contains role r k v self k v
boolean cqs answered nondeterministic procedure entails shown uses auxiliary procedure exist shown following
theorem states entails k q decides k q proof given section
theorem let q boolean cq k k q nondeterministic
computation exists entails k q returns true
finally determine complexity entails towards goal
first determine complexity auxiliary function exist
lemma function exist b pj pda sj j j j j implemented uses space polynomial k rbox r fixed runs
time polynomial
proof consider arbitrary b pj pda sj j j j stated let
let derivation relation corresponding r definition
generalised pdas j dr j dr j
proposition polynomial time one compute pdas accepting languages
ldr pda sj j ldr pda lines therefore checks lines
implemented use time therefore space polynomial
k hopcroft et al ch
space usage please observe function stores following
information computation step
array state length state j qr j array stack
length stack j r stack j dr j
b generalised pda line
c generalised pda stationary automaton line
concept concept c ck line
e binary counter k k
f depth dr r atomic concept c ck role r


fithe complexity answering cqs gxqs owl el kbs

entails k q




















k inconsistent return true
guess substitution dom rng ik
guess skeleton hv e q
atom q exists k v return false
foreach hv v e let l v v
foreach binary atom u q
let au unique individual u reachable au
guess v au u reachable v
let v vn unique path vn u
guess states sn qr sn fs
guess words n r n dr n
foreach n let l vi vi l vi vi pda si si
v
l wfa v l pda return false
else
l sfa v l pda return false
foreach hv v e
exist v v l v v return false
return true

exist b pj pda sj j j j j




















let concept let ck qr r dr
j
guess state qr word r dr
ldr pda sj j return false
set state j stack j
guess k n k
r k
guess r c ck
k concept v k v ik return false
j
guess qr r dr dr
hstate j stack j hs return false
l sfa ldr pda return false
set state j stack j
set concept
concept b return false
exists index j state j j stack j j
return false
return true



fistefanoni motik krotzsch rudolph

definition dr dr linearly bounded number axioms occurring r hence need r space store two arrays furthermore
need k space store counter k binary encoding definition
size sfa polynomial k definition size pda polynomial r overall space needed store required information polynomial
k finally following krotzsch realise check step polynomial
time thus exist implemented uses space polynomial k
next assume rbox r fixed dr qr r r fixed
well moreover bounded size r fixed linear
size thus number alternatives nondeterministic step line
fixed lines require time polynomial furthermore
instead guessing k nondeterministic step repeat lines
k requires linear number iterations lines
implemented run polynomial time first define three sets used
perform checks lines
hs c di r ck nk c k c v ik k v
hs pda r hs hs
hc pda c ck c l sfa c ldr pda
given r fixed sets computed time polynomial size
next implement loop steps use space logarithmic
size sets equations space usage lines
computation step loop store information points f
since r fixed however points c require constant space furthermore
checks lines performed lookup sets storing
sets suitable binary encoding binary index sets
check implemented logarithmic space finally ck linear
size store counter k concepts concept role binary
encoding overall space function needs store logarithmic
size sets thus steps require nondeterministic logarithmic space
well known implies steps implemented run polynomial
time finally steps clearly require polynomial time consequently function exist
implemented runs time polynomial fixed r
ready establish complexity function entails k q section
shall function worst case optimal combined data complexities
theorem q bcq k function entails k q implemented
uses space polynomial input size
rbox r fixed runs nondeterministic polynomial time size
tbox abox query q
rbox r query q fixed runs deterministic polynomial time
size tbox abox


fithe complexity answering cqs gxqs owl el kbs

proof let q boolean cq k
shown proposition one compute lines pda accepting language
ldr pda polynomial time checks lines require time
therefore space polynomial k hopcroft et al ch moreover checks
lines require time polynomial k krotzsch
please observe function entails specified stores
following information computation step
substitution dom rng ik
skeleton hv e q
path v vn sequence states sn qr sequence words
n r dr n
function l mapping edge hv v e set generalised pda
walking automaton wfa v stationary automaton sfa v
definition skeleton q need space polynomial size q k
store moreover length longest path given number variables
occurring q store sequences vertices states words space
polynomial q k well set l v v contains pdas
number binary atoms occurring q lemma entails
implemented uses space polynomial input size
assume rbox r fixed lemma fixed rbox r step
implemented runs time polynomial clearly steps
implemented run nondeterministic polynomial time size
tbox abox query q consequently fixed rbox r function entails
implemented runs nondeterministic polynomial time size tbox
abox query q
assume rbox r query q fixed dr qr r r
fixed well given number variables occurring q fixed number
guessing steps required steps fixed number alternatives
steps linear thus steps require polynomial time furthermore
maximum number iterations loop steps fixed length
longest path fixed thus number guessing steps lines
fixed addition number alternatives guessing steps lines
fixed well therefore steps require time polynomial finally since
query fixed maximum number iterations loop steps
fixed lemma steps require time polynomial
therefore entails implemented runs time polynomial
fixed r q



fistefanoni motik krotzsch rudolph

proof theorem
prove function entails k q indeed decides k q towards goal
start proving correctness function exist introduce universal
interpretation k finally entails sound complete
correctness exist
following proposition proves correctness function exist
lemma function exist b pj pda sj j j j j returns true
exist natural number k roles sk basic concepts ak
ak b role chains j j k
following conditions hold k j
ik k ai v si ai k ai v
role occurring j k ai v self k v
j sk j k ldr pj
proof consider arbitrary b pj pda sj j j j stated lemma moreover let derivation relation corresponding r
assume nondeterministic computation exist function
returns true let k n guessed step loop steps
satisfies following invariant iteration r exist roles sr basic
concepts ar j role chains j j r
ar concept following holds r j
k ai v si ai ik k ai v
ii role occurring j k ai v self k v
iii j sr j r ldr pda sj j state j stack j
base case first iteration loop e steps r
concept ldr pda sj j state j stack j j
properties iii clearly hold
inductive step consider arbitrary iteration r k assume properties
iii hold end iteration r true iteration r
inductive hypothesis exist roles sr basic concepts ar
j role chains j j r ar concept properties
iii hold let role sr atomic concept ar guessed step
clearly k concept v sr ar k ar v ik
required property furthermore consider arbitrary j let
guessed step let state j stack j end iteration r
hstate j sr stack j hs due step furthermore due step role
chain j r exists j r l sfa ldr pda definition
stationary automata role occurring j r k v self


fithe complexity answering cqs gxqs owl el kbs

k v required property ii finally let state j stack j specified
step j sr j r sr j r ldr pda sj j state j stack j
property iii holds
step ensures concept b furthermore steps ensure state j j
stack j j j pda pj accepts j sk j k thus properties
lemma hold required
let sn roles let basic concepts b
let j role chains satisfying properties lemma derivation
j sn j n pda pj following form sj n j j n j
hsj j sn j n j
hs j

hsj j sn j n j

j sn j n

hsj j sn j n j


j



















hs j

hsj si j sn j n j

j si sn j n

hsj si j sn j n j
hs j n

hsj n sn j n j n
hsj n j n

j n






j


j n











transition special sense allows pj make arbitrary
number transitions rest derivation regular consists reading si
j thus sj j states pj respectively reading si
respective stacks property lemma
j j
j
r

j dr
let xi hai sm pda qr many different
p r
r many difstates ck different elements c ck furthermore
pdr
ferent stacks length dr r dr r r dr
consequently distinct tuples thus k
xk xn ak b furthermore j sj k sj n j
j k j n j j sk j k ldr pj
easily construct nondeterministic computation exist follows
step j let sj j clearly condition step satisfied
r loop lines proceed follows
step let si ai respectively clearly condition step
satisfied due property

j let j r sj r j r
j r clearly
condition step satisfied due form derivation furthermore
condition step satisfied due property definition

finally conditions steps satisfied due way chose k
therefore function exist returns true step



fistefanoni motik krotzsch rudolph

rule
cr
cr

cr

cr
cr

cr

cr

precondition
k u v b
w w
k v b
k b v ik
w
k v b
k b v ik
w
k v b
w w w
k self v b
w w
role simple
k v self
w
role simple
l
w w

conclusion
b w
w b

w fs b w b fs b w
c fs b w r fs b w fs b w
r fs b w w term w occurring
r w fs b w term w occurring
b w
b w

w w

w w

table rules consequence chase
consequence chase universal interpretations
prove entails k q sound complete interpret k forest shaped
universal interpretation described section towards goal next define
auxiliary notions define universal interpretation finally prove two properties interpretation
universe k set terms built individuals occurring k
unary function symbols form fs r ck since k normalised
universe k nonempty fact ground atom constructed predicates
occurring k terms universe k role chain sn terms
w w set facts write w w necessarily distinct terms
w w wn w exists si wi wi n set facts
entails boolean cq q written q substitution exists
dom q universal interpretation ik k defined follows
definition chase rule table applicable set facts preconditions
rule satisfied contain conclusions rule consequencebased chase often chase k sequence sets facts
c r b b ik



set ii obtained extending ii conclusion one arbitrarily
chosen chase rule applicable ii ii ii chase rule applicable ii


fithe complexity answering cqs gxqs owl el kbs

sequence must fairthat derivation rule applicable ii specific
precondition j exists suchsthat ij obtained ij applying rule
mentioned precondition set ik ii universal interpretation k
since k normal form k v b distinct individuals
b ik hence one individual ik exists rule cr k b v
straightforward see ik independent order
chase rules applied call ik universal interpretation k moreover
due fairness derivation rule applicable ik chase rule
table preconditions rule satisfied ik ik contains
conclusions rule finally well known k consistent ik
homomorphically embedded model k krotzsch et al consequently
universal interpretation ik used answer arbitrary boolean cqs k
fact boolean cq q k q k c v c ik q
next ik relates axioms entailed k end let
following function mapping term w universe k basic concept

w w
w

w form w fs w
proposition universal model ik satisfies following properties
w ik k w v
w w ik nonempty role chain sm
l terms w wm universe k w w wm w
exist
wi ik atomic concept ai c ck exists
wi fsi ai wi k ai v individual ik
b k wi v si wi
c role occurring k wi v self
k v
proof let chase sequence k induction rule applications properties satisfied w w w
respectively additionally satisfies following property
term w occurring k x w x
definition cr terms w w occurring
clearly c w r w w r w w
base case consider note term w occurring individual
w w consider c
k v property holds furthermore consider b


fistefanoni motik krotzsch rudolph

b r k v b property holds w
w b finally property holds k x x ik
inductive step assume satisfies properties considering
derivation rule assume rule applicable shown table
properties hold conclusions rule note rule cr
affect property explicitly consider properties hold vacuously
cr inductive hypothesis k w v k w v
implies k w v b required property
cr inductive hypothesis k w v k x w x
clearly imply k w v b k x b x moreover k v b
property holds finally since k w v property holds w w
w
cr let w fs b w inductive hypothesis k w v
k x w x k w v b k x b x moreover w b
k w v b k w v c k x w x required properties
respectively property consider role assertions derived rule
w w note k w v w k b v ik
property holds w w w w
r w w clearly property holds w w r
r w w term w occurring let individual w rooted
r w inductive hypothesis role chain l r
terms w wm w exist satisfying properties c since k x w x
k w v r thus r w w wm satisfy property
r w w term w occurring r w w inductive
hypothesis role chain l r terms w w wm w exist satisfying
properties c r w wm w satisfy property
cr inductive hypothesis k w v moreover terms w wm
w w wm w nonempty role chain sm
l exist satisfying properties c definition l k v
together entailments properties b c k w v w
k w v implies k w v b required property
cr inductive hypothesis nonempty role chain l exist satisfying
properties c moreover k v definition l role simple
therefore one following two forms
property c k w v self k v
furthermore due k v k v k w v self
k w v b holds required property
terms w w satisfying property equal w moreover
w form fs w w ik furthermore property b


fithe complexity answering cqs gxqs owl el kbs

k w v w together w ik k w v self finally
due k v k v k w v self
k w v b holds required property
cr inductive hypothesis k w v conclude
k w v self property holds w w
cr w w k v property holds w w
otherwise assume nonempty form sk
thus terms w wk w w wk w exist si wi wi

k inductive hypothesis k terms w wm






w wi wmi wi role chain l si exist satisfying properties
k
w
c note w w w wm
wk w wm


k

k
k definition l l property holds
wk wk
role chain k terms w w wm
mk


soundness
ready entails sound
lemma nondeterministic computation exists entails k q returns true
k q
proof assume nondeterministic computation exists entails k q returns
true returns true step k q k inconsistent hence
rest proof assume k consistent ik q end let
substitution skeleton hv e function l determined entails graph
hv ei forest rooted individuals occurring k structural induction
forest define mapping v universe k satisfy following
v v v v ik
ii hv v e pj l v v role chain j l pj exists
j v v ik
base case ik let since ik first
property clearly holds second property vacuous
inductive step consider hv v e v defined v
let l v v p pm since exist v v l v v returns true lemma
roles sn atomic concepts j role
chain j j sn j n exist n v v
following holds n j
ik k ai v si ai k ai v
role occurring j k ai v self k v
j ldr pj



fistefanoni motik krotzsch rudolph

let w v let wi fsi ai wi n let v wn since v
inductive hypothesis v ik furthermore cr applicable
ik n si wi wi ik ai wi ik thus v ik
required finally role occurring j k ai v self
k v cr cr applicable ik respectively wi wi ik
thus j v v ik required
next q ik considering independently atom q
prove lemma combine obvious way
consider arbitrary unary atom q step
k v implies k u v property
ik since rule cr applicable ik ik required
consider arbitrary binary atom u q let v vn sn
n determined steps considers atom u
n pda si si l vi vi step property ii
role chain exists l pda si si vi vi ik
next define considering following two cases
v step role chain sk exists
l wfa v property ik moreover definition basic concepts ak v exist k aj v sj aj
j k rules cr cr applicable ik
v ik
v implies v step role chain tk
exists l sfa v property v v ik
moreover definition k v v tj self k v tj j k
rules cr cr respectively applicable ik thus v ik
case steps l pda let n
note n case clearly vn ik
vn u moreover l pda sn n sn fs n finally
rule cr applicable ik u ik required
completeness
next prove encoding complete thus proving theorem
lemma k q nondeterministic computation exists entails k q
returns true
proof assume k q k inconsistent entails k q returns true required
hence rest proof assume k consistent ik q
substitution exists q ik let defined section
substitution step let otherwise let
arbitrary fixed variable q straightforward see
q ik



fithe complexity answering cqs gxqs owl el kbs

skeleton hv e step set v contains ik variables occurring
q v variable v furthermore let smallest
irreflexive transitive relation universe k w fs w term
w universe k let hv v e v v v v exists
v v v definition graph hv ei forest rooted
ik required definition
step arbitrary atom q ik property
proposition k v hence condition satisfied
consider arbitrary edge hv v e let w wk terms let ak
atomic concepts let sk roles w v wk v
wi fsi ai wi k finally let v note
uniquely defined edge construction ik k
k ai v si ai k ai v ik role chain compatible
edge hv v role chains k exists sk k
k role occurring k ai v self k v
rest proof following property
pda p l v v role chain l p exists compatible
edge hv v
lemma definition compatibility property implies
condition step satisfied edge hv v
loop steps let u arbitrary binary atom q next
determine required nondeterministic choices preserve step
satisfy conditions steps completes proof lemma let au ik
unique individual connected u hv ei since u ik nonempty
role chain sm l terms w wm
universe k w wm u exist satisfying property proposition
define vertex v step consider two possibilities define
index w v
j exists wj ik let v au let largest index
w au
otherwise let v let
let v vn unique path connecting v u definition
form terms w wm wj j v w
vn wm thus n unique index exists vi w
let let n
clearly n properties c proposition n role chain
compatible edge hvi vi furthermore l theorem imply
ldr pda fs states sn sn fs words n
n exist ldr pda ldr pda si si
n since compatible hvi vi step preserves property
required finally consider step



fistefanoni motik krotzsch rudolph

v property b proposition k wj v sj wj j
furthermore property c proposition k wj v self k v
j role occurring j thus k wj v wj
l wfa v condition step satisfied
v v property c proposition k wj v self
k v role occurring l sfa v
condition step satisfied

lower complexity bound
previous section presented bcq answering elro uses
space polynomial total size input worst case optimal
combined complexity since krotzsch et al reduced pspace hard
checking nonemptiness intersection languages generated deterministic
finite automata f fm common alphabet kozen bcq answering
elro knowledge base k encoding regular rbox contains roles
sm l si l furthermore tbox ensures
universal interpretation ik rooted tree term w exists
reachable root chain
roles corresponding finally boolean cq
contains atoms check whether l nonempty next improve lower
bound showing hard already restricted setting query
tbox abox fixed rbox varies
theorem k regular elro knowledge base q boolean conjunctive query
checking k q pspace hard even
query fixed consist two binary atoms single quantified variable
tbox fixed contains axioms form v
abox fixed contains single unary assertion
proof reduce pspace hard deciding whether intersection
languages generated deterministic finite automata nonempty kozen let
deterministic finite automata alphabet let fresh symbols
f fm


occurring let j let fj hqj j ij fj
deterministic finite automaton alphabet obtained extending fj
transition labelled final state fj fj
transition labelled



fj fresh final state fj fj
j word
j l f

w j l fj exist w odd given w j l fj w odd w
odd w l fj j w even w odd
w l fj j finally assume w l g qi qj qi r
hold j r well
let w st sn word n odd let q qm
clearly w j l fj holds word w form
n
n
w e e e e e n en
sn om





fithe complexity answering cqs gxqs owl el kbs

exists following conditions hold j

n odd oij qj j ei
j si oj

ii n even eij qj j oi
j si ej

iii e j ij onj fj
let lo le l l following languages
lo e em om j ej oj j



le om e em j oj ej j





l lo lo




l im le fm f



consider arbitrary word w corresponding word w definition
l w l w form satisfies property similarly
definition l w l w thet form satisfies
properties ii iii thus w l l w j l fj simplicity
rest proof use following equivalent formulations l l
l lo lo lo




l im fm f im le fm f



twe next define knowledge base k fixed query q k q
j l fj present construction stages describe
affects canonical model hi kthat model constructed
standard notion chase e definition semantic conditions
k replaced syntactic checks axioms k simplicity first present k
tbox depends later modify encoding use fixed tbox
tbox contains axioms abox contains axiom
assume ai word domain element exists
connected via chain roles corresponding
v

symbol







next present rbox r consisting four parts encoding languages lo le


l l encoding uses fresh roles ls
ls
uniquely
lo
e le

associated role well fresh roles lo le l l l l l
first part r contains axioms clear words
prefix ha lio lo
v ls

ej

ls j


oj v

ls j






j ej oj qj j ej oj



ls
v lo




fistefanoni motik krotzsch rudolph

second part r contains axioms clear words
prefix ha lie le

oj

j
le

v ls
e





ls j
e

j ej oj qj j oj ej



ej v

ls
v le
e



third part r contains axioms clear words
prefix ha li l
v l





lo v l



l
l



v l



lo l v
l l
l lo

v



fourth part r contains axioms clear words
prefix ha li l
im l fm f v l



l
l




l fm f v l



l le v
l
im

l



l

v

query q given k q word exists
ha li ha li latter clearly case l l
rbox r regular size polynomial size automata f fm
q l l



next tighten reduction use fixed tbox consisting axioms
p p fresh roles
v p



v p



let k dlog e assume symbol corresponds k digit binary
number b bk bi let r r extended axioms
pb pb k v

corresponding b bk



finally let k ht r ai let canonical model k axioms
ensure existence binary tree whose edges labelled roles p p
furthermore axioms ensure sequence k edges
tree corresponding binary number assigned shortcut tree


fithe complexity answering cqs gxqs owl el kbs

labelled thus homomorphically embedded finally roles p
p occur r query q checks existence domain element connected
therefore extra edges irrelevant consequently encoding languages l
l works way varying tbox
finally characterise complexity bcq answering elro knowledge bases
theorem k regular elro kb q boolean cq checking k q
ptime complete data complexity
np complete rbox r fixed
pspace complete combined complexity
proof calvanese et al proved bcq answering ptime hard data complexity already el knowledge bases furthermore query fixed bcq
answering np hard already relational databases chandra merlin
theorem follows theorems savitchs theorem

navigational queries
data dl knowledge bases graph structure unary assertions encode
properties graph nodes binary assertions encode graph edges conjunctive queries
cannot express recursive properties reachability expressivity often insufficient applications require graph navigation popularity graph
databases rise number navigational languages querying graph data
proposed example regular path queries barcelo use regular expressions express complex navigational patterns graph vertices graph xpath
queries libkin et al extend regular path queries converse operator negation regular expressions checking properties vertices boolean combinations
concepts existential quantifications paths dl context computational complexity navigational queries studied several expressive dls
members dl lite family el h fragment elro calvanese eiter
ortiz bienvenu et al kostylev et al bienvenu et al order
complete complexity landscape section study
answering graph xpath queries elro knowledge bases
graph xpath queries
graph xpath queries consist node expressions path expressions whose syntaxes
defined respectively following two context free grammars b basic concept
role
b hi
test
following libkin et al consider following expression fragments


fistefanoni motik krotzsch rudolph

p e


p

g

p

p f





r



r

b

u
p











u

p




f

p

r

c
b

r



r

e



p e


figure interpretation
path positive fragment disallows path expressions form
positive fragment disallows path expressions form node expressions
form
converse free fragment disallows path expressions form
graph xpath atom form node expression path
expression terms conjunctive graph xpath query cgxq g expression
g x conjunction graph atoms variables x variables x
called answer variables g x g boolean cgxq
path positive positive converse free cgxqs obtained restricting query atoms
accordingly finally graph xpath query gxq cgxq containing single atom
define semantics cgxqs let hi first order interpretation
interpretation node path expressions inductively defined follows



hi









x hx yi






test








hy xi hx yi




hx xi x

please observe difference path expressions corresponds
whereas intersection corresponds moreover libkin et al
define path expression setting corresponds test c satisfaction
boolean cgxq g cgxq entailment defined obvious way moreover
boolean cgxq answering checking k g
example illustrate definitions interpretation shown figure
notation example moreover let following path expressions
r test hs test b



u test hp test b





fithe complexity answering cqs gxqs owl el kbs

node expressions
tb b v cb
c u c v c
c v c c v c
thi c v chi
path expressions
ts



ttest c v ttest self

rb
r r r
r r r
rhi r

rs v ts
r v r r
r v v r r
r v v v r
rtest r

table encoding positive converse free node path expressions axioms
r



expression positive retrieves pairs individuals connected
path r edges element occurring path first
exists outgoing path edges reaching member concept b example
hai di hai ei
contrast expression path positive retrieves pairs individuals
connected u edge p successor exists member concept atb
example hai g hai f
finally expression neither positive path positive retrieves pairs
individuals connected path consisting sequence edges described
regular expression r example hai di hai ei
let g x z x x z x conjunctive graph xpath query let
x z g substitution figure one check g
observed kostylev et al node expressions graph xpath queries correspond precisely formulas propositional dynamic logic negation pdl harel
et al satisfiability pdl undecidable harel answering
gxqs dl constraints undecidable decidability recently obtained path positive positive queries dl lite knowledge bases kostylev et al
addition kostylev et al proved dls answering path positive
converse free gxqs conp hard data complexity finally bienvenu et al proved
answering positive gxqs el knowledge bases exptime complete thus
rest section focus positive converse free graph xpath queries
complexity answering positive converse free graph xpath queries
rest section fix elro kb k ht r ai r regular
next given positive converse free boolean cgxq g one construct
polynomial time regular elro kb k boolean cq q k g
k q construction k combines expressive features elro


fistefanoni motik krotzsch rudolph

role inclusions reflexive roles encode path expressions g rbox selfrestrictions encode node expressions g tbox
proposition given positive converse free boolean cgxq g k one compute
time polynomial k g elro kb k boolean cq q rbox
k regular g q equally many atoms k g k q
proof let g positive converse free boolean cgxq k
positive node expression let c fresh atomic concept uniquely associated
positive converse free path expression let fresh role uniquely
associated structural induction associate resp tbox
rbox r resp tbox rbox r shown table let
k ht r r ai tbox rbox r follows







r
r
r








let q boolean cq contains c atom
atom clearly g q number atoms
moreover since query g k query q k finally q k
computed polynomial time input size rbox k clearly regular
next k q k g
assume k q interpretation exists k q
since axiom k axiom k k furthermore
positive node expression positive path expression c
prove claim simultaneous induction structure node
path expressions
base case base case let arbitrary node expression form b
let arbitrary path expression form since b v cb v ts r
model k claim easily follows
inductive step inductive step distinguish two cases
first consider arbitrary node expression property holds node
path expressions occurring let x arbitrary element assume
x x ci considering forms take
since x x x inductive hypothesis
x ci x ci definition c u c v c
since model x ci required
proof case similar one
hi since x exists hx yi inductive
hypothesis hx yi ti definition c v c
since model x ci required
second consider arbitrary path expression property holds
node path expressions occurring let x arbitrary elements
assume hx yi hx yi ti considering forms
take


fithe complexity answering cqs gxqs owl el kbs

since hx yi exists z hx zi
hz yi inductive hypothesis hx zi ti hz yi ti
moreover definition r v r since model
r hx yi ti required
since hx yi hx yi hx yi
inductive hypothesis hx yi ti hx yi ti definition r
v v r since model r hx yi ti
first consider case x definition r
v r since model r hx yi ti required otherwise
consider case x since hx yi elements x xn x x
xn exist n hxi xi n
inductive hypothesis n hxi xi ti definition
r v r since model r hx yi
test follows x x inductive hypothesis
x ci definition c v self since model
hx yi ti required
since node path expressions g positive q implies g


assume k g interpretation exists k g let
interpretation obtained extending fresh concepts roles follows


c









definition k straightforward see k furthermore
definition q straightforward see q required
next establish complexity answering positive converse free c gxqs
elro knowledge bases
theorem k regular elro kb g positive converse free boolean cgxq
checking k g ptime complete data complexity pspace complete combined
complexity g positive converse free boolean gxq checking k g ptimecomplete combined data complexities
proof hardness data complexity boolean positive converse free c gxqs follows
ptime hardness instance checking el calvanese et al
positive converse free gxqs hardness combined complexity inherited
ptime hardness tbox reasoning el baader et al matching upper
bounds proposition allows us reduce boolean gxq answering checking entailments
form k q q bcq containing one atom next
possible form q reduce latter checking entailment elro
concept inclusions decided ptime following c arbitrarily
chosen individual ik
k k v


fistefanoni motik krotzsch rudolph

k k c v r
k b k v b
k b k c v r b
k k v c
k k c v r c
positive converse free cgxqs hardness combined complexity given theorem matching upper bounds follow theorem proposition

conclusions
presented first cq answering owl el runs
pspace thus closing longstanding open question
innovative succinct encoding regular role inclusions bounded stack pdathat
finite automata extended stack fixed size believe encoding interesting
right used optimise popular owl dl reasoners moreover
refined previously known pspace lower bound cq answering showing
remains pspace hard even query tbox abox fixed
rbox varies thus identify role inclusions culprit
pspace hardness finally showed positive converse free gxqs cgxqs
answered owl el knowledge bases ptime pspace respectively
interesting bienvenu et al showed adding converse operator
makes exptime hard thus least theoretical perspective positive
converse free c gxqs seem provide adequate language querying owl el
knowledge bases
see two main open future work first drawing inspiration
succinct encoding role inclusions shall extend combined
stefanoni et al owl el thus obtain practical second static
query analysis fundamental task query optimisation shall study containment
graph queries elro constraints

acknowledgements
article extension published preliminary form krotzsch et al proceedings th international semantic
web conference iswc work supported alcatel lucent eu fp
project optique epsrc projects masi score dbonto dfg project
diamond emmy noether grant kr

references
anselmo giammarresi varricchio finite automata non selfembedding grammars proceedings th international conference im



fithe complexity answering cqs gxqs owl el kbs

plementation application automata ciaa pp berlin heidelberg
springer verlag
artale calvanese kontchakov r zakharyaschev dl lite family
relations j artif intell res jair
baader f brandt lutz c pushing el envelope kaelbling l p
saffiotti eds proceedings th international joint conference artificial intelligence ijcai pp edinburgh uk morgan kaufmann
publishers
baader f brandt lutz c pushing el envelope clark k
patel schneider p f eds proceedings owled dc workshop
owl experiences directions
baader f calvanese mcguinness nardi patel schneider p f eds
description logic handbook theory implementation applications
cambridge university press paperback edition
baget j f leclere mugnier l salvat e rules existential
variables walking decidability line artif intell
barcelo p querying graph databases hull r fan w eds pods pp
acm
barrett c jacob r marathe formal language constrained path
siam j comput
bienvenu calvanese ortiz simkus nested regular path queries
description logics proc th int conf principles knowledge
representation reasoning kr aaai press
bienvenu ortiz simkus conjunctive regular path queries
lightweight description logics rossi f ed ijcai ijcai aaai
cal gottlob g kifer taming infinite chase query answering
expressive relational constraints j artif intell res jair
calvanese de giacomo g lembo lenzerini poggi rodriguez muro
rosati r ruzzi savo f mastro system ontology
data access semantic web
calvanese de giacomo g lembo lenzerini rosati r data
complexity query answering description logics proc th int conf
principles knowledge representation reasoning kr pp

calvanese de giacomo g lembo lenzerini rosati r tractable
reasoning efficient query answering description logics dl lite family j
autom reasoning
calvanese de giacomo g lembo lenzerini rosati r data
complexity query answering description logics artificial intelligence




fistefanoni motik krotzsch rudolph

calvanese de giacomo g lenzerini vardi containment
conjunctive regular path queries inverse proc th int conf
principles knowledge representation reasoning kr pp
calvanese eiter ortiz regular path queries expressive description
logics nominals boutilier c ed ijcai proceedings st
international joint conference artificial intelligence pasadena california usa
july pp
calvanese vardi de giacomo g lenzerini view query
processing regular path queries inverse proceedings nineteenth acm
sigmod sigact sigart symposium principles database systems pods
pp york ny usa acm
chandra k merlin p optimal implementation conjunctive queries
relational data bases hopcroft j e friedman e p harrison eds
proc th annual acm symposium theory computing stoc pp
boulder co usa acm press
cruz f mendelzon wood p graphical query language supporting
recursion sigmod rec
cuenca grau b horrocks motik b parsia b patel schneider p f sattler u
owl next step owl j web sem
de giacomo g lembo lenzerini poggi rosati r ruzzi savo f
mastro reasoner effective ontology data access horrocks
yatskevich jimenez ruiz e eds ore vol ceur workshop
proceedings ceur ws org
eiter ortiz simkus conjunctive query answering description
logic sh knots j comput syst sci
eiter ortiz simkus tran k xiao g b query rewriting
horn shiq plus rules hoffmann j selman b eds aaai aaai press
fan w graph pattern matching revised social network analysis deutsch
ed icdt pp acm
geffert v mereghetti c palano b concise representation regular
languages automata regular expressions information computation

giese calvanese haase p horrocks ioannidis kllapi h koubarakis
lenzerini moller r rodriguez muro ozcep rosati r schlatte r
schmidt soylu waaler scalable end user access big data
akerkar r ed big data computing crc press
glimm b lutz c horrocks sattler u conjunctive query answering
description logic shiq j artif intell res jair
gottlob g manna pieris polynomial combined rewritings existential
rules proc th int conf principles knowledge representation
reasoning kr aaai press


fithe complexity answering cqs gxqs owl el kbs

gottlob g schwentick rewriting ontological queries small nonrecursive
datalog programs brewka g eiter mcilraith eds principles
knowledge representation reasoning proceedings thirteenth international
conference kr rome italy june aaai press
grosof b n horrocks volz r decker description logic programs combining logic programs description logic proceedings th international
conference world wide web pp
gutierrez c hurtado c mendelzon perez j foundations
semantic web databases j comput syst sci
harel dynamic logic gabbay guenthner f eds handbook
philosophical logic vol ii pp reidel publishing company
harel tiuryn j kozen dynamic logic mit press cambridge
usa
hopcroft j e motwani r ullman j introduction automata theory
languages computation international edition ed addison wesley
horrocks kutz sattler u even irresistible sroiq doherty
p mylopoulos j welty c eds kr pp aaai press
horrocks sattler u decidability shiq complex role inclusion axioms
artificial intelligence
johnson klug c testing containment conjunctive queries
functional inclusion dependencies j comput syst sci
kazakov riq sroiq harder shoiq brewka g lang
j eds kr pp aaai press
kontchakov r lutz c toman wolter f zakharyaschev combined ontology data access walsh ed ijcai
proceedings nd international joint conference artificial intelligence
barcelona catalonia spain july pp ijcai aaai
kostylev e v reutter j l vrgoc xpath dl lite ontologies
bienvenu ortiz rosati r simkus eds informal proceedings
th international workshop description logics vienna austria july
vol ceur workshop proceedings pp ceur ws org
kozen lower bounds natural proof systems focs pp ieee
computer society
krotzsch efficient rule inferencing owl el walsh ed
proceedings nd international joint conference artificial intelligence ijcai aaai press ijcai
krotzsch rudolph hitzler p conjunctive queries tractable fragment
owl aberer k choi k noy n allemang lee k nixon l
golbeck j mika p maynard mizoguchi r schreiber g cudre mauroux
p eds proceedings th international semantic web conference iswc
vol lncs pp springer


fistefanoni motik krotzsch rudolph

libkin l martens w vrgoc querying graph databases xpath
tan w c guerrini g catania b gounaris eds icdt pp
acm
lutz c complexity conjunctive query answering expressive description
logics automated reasoning
lutz c seylan toman wolter f combined obda
taming role hierarchies filters alani h kagal l fokoue groth p
biemann c parreira j x aroyo l noy n f welty c janowicz k eds
international semantic web conference vol lecture notes computer
science pp springer
lutz c toman wolter f conjunctive query answering description logic el relational database system boutilier c ed ijcai
proceedings st international joint conference artificial intelligence
pasadena california usa july pp
marnette b generalized schema mappings termination tractability
paredaens j su j eds pods pp acm
mora j rosati r corcho kyrie query rewriting extensional
constraints elhio mika p tudorache bernstein welty c knoblock
c vrandecic groth p noy n f janowicz k goble c eds
semantic web iswc th international semantic web conference riva
del garda italy october proceedings part vol lecture notes
computer science pp springer
ortiz calvanese eiter data complexity query answering expressive description logics via tableaux j autom reasoning
ortiz rudolph simkus query answering horn fragments
description logics shoiq sroiq walsh ed ijcai proceedings nd international joint conference artificial intelligence barcelona
catalonia spain july pp ijcai aaai
perez j arenas gutierrez c nsparql navigational language rdf
web semant
perez urbina h motik b horrocks tractable query answering rewriting
description logic constraints j applied logic
rodriguez muro calvanese high performance query answering
dl lite ontologies brewka g eiter mcilraith eds principles
knowledge representation reasoning proceedings thirteenth international
conference kr rome italy june aaai press
rosati r conjunctive query answering el calvanese franconi e
haarslev v lembo motik b turhan tessaris eds description
logics vol ceur workshop proceedings ceur ws org
rudolph glimm b nominals inverses counting conjunctive queries
infinity friend j artif intell res jair


fithe complexity answering cqs gxqs owl el kbs

simanck f elimination complex rias without automata kazakov
lembo wolter f eds proceedings international workshop
description logics dl rome italy june vol ceur
workshop proceedings ceur ws org
sirin e parsia b cuenca grau b kalyanpur katz pellet practical
owl dl reasoner j web sem
stefanoni g motik b horrocks introducing nominals combined
query answering approaches el desjardins littman l eds
aaai aaai press
ter horst h j completeness decidability complexity entailment rdf
schema semantic extension involving owl vocabulary web semantics
science services agents world wide web
tsarkov horrocks fact description logic reasoner system description furbach u shankar n eds ijcar vol lecture notes
computer science pp springer
urbani j van harmelen f schlobach bal h e querypie backward
reasoning owl horst large knowledge bases aroyo l welty c
alani h taylor j bernstein kagal l noy n f blomqvist e eds
international semantic web conference vol lecture notes computer
science pp springer
vardi complexity relational query languages extended abstract
proceedings fourteenth annual acm symposium theory computing stoc
pp york ny usa acm
venetis stoilos g stamou g b incremental query rewriting owl ql
kazakov lembo wolter f eds proceedings international
workshop description logics dl rome italy june vol
ceur workshop proceedings ceur ws org
virgilio r orsi g tanca l torlone r nyaya system supporting
uniform management large sets semantic data kementsietsidis salles
v eds ieee th international conference data engineering icde
washington dc usa arlington virginia april pp
ieee computer society
wessel obstacles way qualitative spatial reasoning description
logics undecidability working notes international
description logics workshop dl vol ceur ws org




