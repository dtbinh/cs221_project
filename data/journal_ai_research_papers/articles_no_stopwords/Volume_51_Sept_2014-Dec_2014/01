journal artificial intelligence

submitted published

testability bdi agent systems
michael winikoff
stephen cranefield

michael winikoff otago ac nz
stephen cranefield otago ac nz

department information science
university otago
zealand

abstract
deploying software system need assure stakeholders
system behave correctly assurance usually done testing system
however intuitively obvious adaptive systems including agent systems
exhibit complex behaviour thus harder test examine
obvious intuition case belief desire intention bdi agents analyse
size behaviour space bdi agents although intuition correct
factors influence size expected specifically
found introduction failure handling much larger effect size
behaviour space expected discuss implications findings
testability bdi agents

introduction
increasingly called upon develop software systems operate dynamic environments robust face failure required exhibit flexible behaviour operate open environments one developing systems
demonstrated effectiveness range domains use metaphor
software agents wooldridge agent systems increasingly finding
deployment wide range applications e g munroe miller belecheanu pechoucek
mcburney luck benfield hendrickson galanti
agent systems increasingly deployed issue assurance rears head
deploying system need convince rely system
responsible fails system fact work traditionally
assurance done testing however generally accepted adaptive systems
exhibit wide complex range behaviours making testing hard example
validation extensive tests mandatory however task proved
challenging agent systems explore realms behaviour outside peoples expectations often yield surprises munroe et al section
intuition agent systems exhibit complex behaviour makes
hard test explore intuition focusing well known beliefdesire intention bdi realising adaptive flexible agents rao georgeff
although considerable formal methods context agent systems dastani
hindriks meyer yet ready real world application see section
concerns scope work applicability winikoff
c

ai access foundation rights reserved

fiwinikoff cranefield

bratman demonstrated practically applicable resulting
reduced development cost increased flexibility benfield et al
explore intuition agent systems hard test analysing
space possible behaviours bdi agents number paths bdi
program probability failure focus bdi agents provide welldefined execution mechanism analysed seek understand
complexities testability implications adaptive intelligent behaviour
absence parallelism since implications parallelism already well known
derive number paths bdi program function parameters e g number applicable plans per goal failure fate naturally
leads us consider number paths affected parameters
might expected intuition agent systems hard test
correct e agent systems large number paths bdi
agents harder test procedural programs showing number paths
bdi program much larger number paths similarly sized
procedural program
contribution threefold firstly confirms intuition bdi
programs hard test secondly quantifying number paths
function parameters bdi program thirdly surprising
parameters influence number paths
although recently increasing interest testing agent systems zhang
thangarajah padgham ekinci tiryaki cetin dikenelli gomez sanz
bota serrano pavon nguyen perini tonella b surprisingly little work determining feasibility testing agent systems first place
padgham winikoff pp analyse number successful executions
bdi agents goal plan tree defined section consider failure failure
handling analysis consider testability implications shaw farwer
bordini analysed goal plan trees shown checking whether goal plan
tree execution schedule respect resource requirements np complete
different one tackle concerned allocation
resources amongst goals rather behaviour space
briefly address number possible criticisms work considering
existing work
number paths useful metric assessing testability
consider related area software testing section argue
metric well established one appropriate use assess testability
isnt obvious corollary complexity htn
consider detail htn section argue although
bdi execution cycle certain similarities htn differences
significant particular mean htn
simply different testing bdi programs
use combinatorial analysis rather complexity analysis
combinatorial analysis precise yields formulae exact number


fion testability bdi agent systems

paths exact probabilities failure latter see section
informative order magnitude complexity additionally allows
us consider issues complexity analysis would address effect
number failures number paths
software testing
trying assess hard agent systems test concretely given bdi
agent program want know hard program test reduced
directly question test set adequacy agent program p easy test precisely
extent exists test set adequate testing p
infeasibly large conversely agent program p hard test extent
adequate test set would infeasibly large words hardness
testing program directly assessed size required test set adequate
respect suitable adequacy criteria
many criteria used assess whether given set tests adequate recent overview see mathur given interested assessing
difficulty testing given program clearly looking white box testing furthermore working abstract goal plan trees rather detailed programs
see section means need consider control flow metrics rather
data flow since abstract goal plan tree contain data flow information
focussing white box testing criteria control flow basic
long standing criterion assessing test set adequacy paths program
covered miller maloney example consider program following form

input x

condition

endif

c

else b

two paths program
adequate test set must least two tests adequate one exercise first path
another exercise second case test set single test
inadequate part program executed testing
obvious complication covering paths program loop
infinite number paths since loop potentially executed number
times standard technique dealing bound length paths
number executions loop zhu hall may p bounding execution
loops done calculating upper bound number iterations
data mathur p considering paths loops executed
zero times one time mathur p
one question might asked consider paths rather weaker
criterion agent applications typically involve environments non episodic
environments history matters means behaviour given plan goal
general sensitive agents history hence need consider different
possible histories achieving goal may different done first thing


fiwinikoff cranefield

agent failed plan already performed number actions
means makes sense consider path criterion testing
furthermore although paths adequacy criterion often considered impractical reason appears primarily existence infinite number paths
presence loops instance zhu et al p say plan coverage criterion
strong practically useful programs infinite
number different paths program loops setting
loops existence infinite number paths issue considering number
paths possible
therefore use number paths proxy measure testing difficulty
paths program adequate test set according
paths criterion need large hand number paths
large adequate test set need large
one issue need consider since paths strong criterion
possible even absence bounding loops criterion
infeasibly large numbers paths order address issue analysis
number paths procedural programs equivalent size compare
number paths bdi programs see section
finally bears noting paths criterion considers parts
program traversed testing ignores values variables example
trivial program consisting single statement x x x single one step path
trivially covered many traces x
htn
similarities hierarchical task network htn erol hendler
nau bdi execution de silva padgham use hierarchical
representation goals non primitive tasks htn terminology plans decomposition methods goal plan trees task networks complexity htn
explored given similarities simply exploit known complexity

turns cannot simple reason complexity htn
concerns plan finding different bdi plan execution
sardina padgham explain
bdi agent systems htn planners come different communities
differ many important ways former focus execution plans
whereas latter concerned actual generation plans
former generally designed respond goals information latter
designed bring goals addition bdi systems meant
embedded real world therefore take decisions particular
current state planners hand perform hypothetical reasoning
actions interactions multiple potential states thus failure
different meaning two types systems context
failure means plan potential plan suitable within
bdi agent systems failure typically means active sub plan ought


fion testability bdi agent systems

aborted whereas backtracking upon failure option systems
generally bdi systems actions taken real world sardina
padgham p bold emphasis added
words htn systems plan ahead execution whereas bdi systems interleave
execution
htn plan existence answers question plan exist
complexity studied settings correspond bdi execution many goals
total ordering within plans variables known expspace hard
dexptime erol hendler nau however work address
question bdi execution considering complexity plan existence htn
asking computational complexity search process
plan hand asking number paths
goal plan tree asking possibilities arise executing plan
illustrate point consider following example suppose single goal
g decomposed two alternative plans p p plan p consists
sequential execution actions b c plan p consists sequential execution
actions e plan existence boils considering options p
p since case search space simple offering two options
hand question many paths exist bdi execution considers different
ways goal plan tree executed whereas htn considers p
single atomic decomposition bdi execution needs consider sequence actions b c
distinct steps possible three actions succeed giving trace b c
possible action b fail followed p successfully used giving trace
b e action c fail followed p successfully used giving trace
b c e
overall means complexity analysis erol et al
different htn complexity relevant finally note
fact setting plan existence actually trivially true since
bdi programs constraints expansion program
sequence actions
remainder structured follows begin briefly presenting
bdi execution model section discussing bdi execution viewed
process transforming goal plan trees section section core
analyse number paths bdi style goal plan tree consider
analysis assumptions hold real system real platform section
analysis bdi programs compares analysis number paths
conventional procedural programs section finally conclude discussion
implications testing future work section
approaches blur difference adding look ahead bdi online execution
htns example planner retsina multi agent system paolucci shehory sycara kalp
pannu ability interleave execution however theoretical analysis
extension reported analysis erol hendler nau applies
classical htn



fiwinikoff cranefield

bdi execution model
describe belief desire intention bdi model explain chose
model agent execution addition well known widely used bdi model
well defined generic well defined allows us analyse behaviour spaces
generic implies analysis applies wide range
platforms
bdi model viewed philosophical bratman logical rao
georgeff perspectives interested implementation perspective exhibited range architectures platforms jack busetta
ronnquist hodgson lucas jam huber dmars dinverno kinny luck
wooldridge prs georgeff lansky ingrand georgeff rao
um prs lee huber kenny durfee jason bordini hubner wooldridge
spark morley myers jadex pokahr braubach lamersdorf
irma bratman israel pollack purposes analysis
formal detailed presentation unnecessary interested formal semantics
bdi languages referred work rao winikoff padgham harland
thangarajah bordini et al example
implementation bdi agent key concepts beliefs generally
data events plans reader may surprising goals key concepts
bdi systems reason goals modelled events acquisition goal
viewed goal event agent responds selecting executing plan
handle event remainder section keeping established
practice describe bdi plans handling events goals
bdi plan consists three parts event pattern specifying event relevant
context condition boolean condition indicates situations plan
used plan body executed plans event pattern context condition
may terms containing variables matching unification process depending
particular bdi system used bdi interpreters plan instances respond
given event general plan body contain arbitrary code programming
language however purposes assume plan body sequence steps
step action succeed fail event posted
example consider simple plans shown figure first plan plan
relevant handling event achieve goal go home applicable situations
agent believes train imminent plan body consists sequence
four steps case assume actions could modelled
events handled plans
key feature bdi plan encapsulates conditions
applicable defining event pattern context condition allows
additional plans given event added modular fashion since invoking
types event typically include addition removal beliefs agents belief set
example jack plan body written language superset java
follows abstract notations agentspeak l rao winikoff et al
aim capture essence range complex bdi languages
includes traditional actions affect agents environment internal actions
invoke code check whether certain condition follows agents beliefs



fion testability bdi agent systems

plan handles event
achieve goal go home
context condition
train imminent
plan body
walk train station
check train running time
catch train
walk home
plan b handles event
achieve goal go home
context condition
raining bicycle
plan body
cycle home
plan c handles event
achieve goal go home
context condition
true e applicable
plan body
walk bus stop
check buses running
catch bus
walk home
figure three simple plans
context e triggering event posted contain code selects amongst
available plans key reason flexibility bdi programming
typical bdi execution cycle elaboration following event driven process
summarised figure
event occurs received outside source triggered within
agent
agent determines set instances plans plan library event patterns
match triggering event set relevant plan instances
agent evaluates context conditions relevant plan instances generate
set applicable plan instances relevant plan instance applicable context
condition true applicable plan instances event deemed
failed posted plan plan fails note
single relevant plan may lead applicable plan instances context condition
false one applicable plan instance context condition
may contain free variables multiple solutions
one applicable plan instances selected executed selection mechanism varies platforms generality analysis make bdi engines fact complicated interleave execution multiple
active plan instances intentions triggered different events



fiwinikoff cranefield

boolean function execute event
let relevant plans set plan instances resulting
matching plans event patterns event
let tried plans
true
let applicable plans set plan instances resulting
solving context conditions relevant plans
applicable plans applicable plans tried plans
applicable plans empty return false
select plan p applicable plans
tried plans tried plans p
execute p body true return true
endwhile
boolean function execute plan body
plan body empty return true
elseif execute first plan body false return false
else return execute rest plan body
endif
boolean function execute action
attempt perform action
action executed successfully return true else return false endif

figure bdi execution cycle
sumptions plan selection plans body may create additional events
handled process
plan body fails failure handling triggered
brevity remainder use term plan loosely mean
plan plan instance intention clear context
regarding final step approaches dealing failure perhaps
common used many existing bdi platforms
select alternative applicable plan consider event failed
remaining applicable plans determining alternative applicable plans one may
consider existing set applicable plans calculate set applicable
plans ignoring already tried done figure makes
sense situation may changed since applicable plans determined
many bdi platforms use failure handling mechanism retrying
plans upon failure analysis applies platforms
one alternative failure handling used jason bordini et al
post failure event handled user provided plan although
flexible since user specify upon failure place burden


fion testability bdi agent systems

specifying failure handling user note jason provides pattern allows
traditional bdi failure handling mechanism specified succinctly bordini et al
pp another alternative failure handling used apl dastani
predecessor apl permit programmer write plan repair rules
conditionally rewrite failed plan another plan jasons
quite flexible possible analyse general way plan rules
quite arbitrary another well known bdi architecture irma described
high level prescribe specific failure handling mechanism
full development architecture would give account
ways resource bounded agent would monitor prior plans
light changes belief however developed course
times agent give prior plan light belief
plan longer executable happens process
deliberation may triggered bratman et al
given bdi execution cycle discussed three example plans given earlier
figure give rise range behaviours including following
suppose event achieve goal go home posted agent believes
train imminent walks train station finds train running
time catches train walks home
suppose upon arrival train station agent finds trains
delayed step plan fails agent considers alternative plans
raining present time plan b applicable plan c adopted
catch bus
suppose agent decided catch bus train believed
imminent raining attempting execute plan c fails e g
bus strike agent reconsider plans rain stopped
bicycle may use plan b
note correct respectively incorrect behaviour distinct successful
respectively failed execution plan software testing essence process running system checking whether observed behaviour trace correct e conforms
specification model hand bdi agents behaviour traces
classified successful failed however correctness given execution
trace independent whether trace successful failed execution successful
execution may fact exhibit behaviour correct instance traffic controller
agent may successfully execute actions set traffic signals intersection green
achieve goal successful execution incorrect behaviour
possible failed execution correct instance traffic controller agent
attempting route cars point point b traffic accident blocked key
bridge two points rational correct behaviour agent
fail achieve goal


fiwinikoff cranefield

bdi execution goal plan tree expansion
bdi execution summarised figure dynamic process progressively executes
actions goals posted order easily analyse process present
alternative view declarative instead viewing bdi execution process
view data transformation finite goal plan tree sequence action
executions
events plans visualised tree goal children
plan instances applicable plan instance children sub goals
posts goal plan tree tree goal realised one plan
instances plan instance needs sub goals achieved
viewing bdi execution terms goal plan tree action sequences makes
analysis behaviour space size easier consider bdi execution process taking
goal plan tree transforming sequence recording failed successful
executions actions progressively making decisions plans use
goal executing plans
process non deterministic need choose plan goal tree
furthermore consider failure need consider action whether fails
fail failure recovery done
define transformation process detail prolog code implementing
process found figure defines non deterministic predicate exec first
argument input goal plan tree second argument output sequence
actions goal plan tree represented prolog term conforming following
simple grammar gpt abbreviates goal plan tree aogl abbreviates action
goal list symbol
hgpt goal goal hplanlisti
hplanlisti hplani hplani hplanlisti
hplani plan plan haogli
haogli act hgpt act haogli hgpt haogli
example simple goal plan tree shown figure modelled prolog term
goal plan act plan act b
analysis make simplifying assumption instead modelling instantiation
plans plan instances assume goal plan tree contains applicable plan
instances thus order transform goal node sequence actions nondeterministically select one applicable plan instances selected plan
transformed turn resulting action sequence line figure selecting
plan consider possibility applicable plans could chosen
first plan done different points time different plan instances may
applicable saw example earlier plan chosen failed
order consistent existing practice shall use term goal rather event
remainder
remainder use term behaviour space size rather
cumbersome term number paths bdi program



fion testability bdi agent systems

















exec goal
exec goal plans trace remove plans plan rest exec plan trace
failed trace recover rest trace trace trace trace
exec plan
exec plan step steps trace exec step trace
failed trace trace trace continue steps trace trace
exec act action action
exec act action action fail
failed trace append x fail trace
recover plans trace traces exec goal plans trace append trace trace traces
continue steps trace trace exec plan steps trace
append trace trace trace
remove x xs x xs
remove x xs x z remove xs z

figure prolog code expand goal plan trees
goal
plan

plan



b

figure simple goal plan tree

plan c selected failed finally plan b applicable
plan failed selected
selected plan executes successfully e action trace doesnt end fail
marker line resulting trace trace goals execution line otherwise perform failure recovery line done taking remaining plans
transforming goal plans options resulting action sequence
appended action sequence failed plan obtain complete action sequence
goal
process easily seen match described figure exception
discussed begin applicable plans relevant plans specifically
applicable plan selected executed successful execution stops
successful alternative plan selected execution continues e action
sequences appended
order transform plan node first transform first step plan
sub goal action line successful continue transform
rest plan append two resulting traces together lines
first step plan successful trace simply trace first step
line words stop transforming plan step fails process
easily seen correspond plan body execution figure


fiwinikoff cranefield

finally order transform action action sequence simply take
action singleton sequence line however need take account
possibility action may fail thus second possibility action followed
failure indicator line process easily seen correspond action
execution figure note model dont concern
action fails could lack resources environmental issues
example applying process two example goal plan trees found
appendix

behaviour space size bdi agents
consider many paths goal plan tree used
bdi agent realise goal tree use analysis previous section
basis view bdi execution transforming goal plan tree action
traces thus question large behaviour space bdi agents answered
deriving formulae allow one compute number behaviours successful
unsuccessful e failed given goal plan tree
make following uniformity assumptions allow us perform analysis
simplifying assumptions concern form goal plan tree
assume subtrees goal plan node structure
leaves goal plan tree distance number edges away
root tree therefore define depth goal plan tree
number layers goal nodes contains goal plan tree depth plan
sub goals goal plan tree depth plan node
children goal nodes depth goal node children plan
nodes depth note definition depth reverse usual
definition depth trees root defined use definition
simplifies presentation derivations later section
assume plan instances depth k sub goals
assume goals j applicable plan instances case
goal j relevant plans exactly one applicable plan
instance case ways instance goal may j
relevant plans half applicable current situation goal may
single relevant plan j applicable instances note assumption rules
possibility infinite number applicable plan instances
would case plans context condition infinite number solutions
cannot occur context condition defined terms conjunctions
propositions refer finite belief base however occur agents
context conditions make use prolog knowledge base case
agent oriented programming languages jason goal nevertheless
since deal applicable plans dont model context conditions
focus single goal analysis multiple goals treated concurrent interleaving
individual goals multiple agents treated concurrent interleaving care
needs taken details agent waiting another agent respond



fion testability bdi agent systems

figure shows uniform goal plan tree depth
g




r pj
p




r

g gk




r

p pj





figure uniform goal plan tree
assumptions made clearly unrealistic means consider
possibility real agent programs behave quite differently since meet
assumptions address issue number ways firstly section
consider relaxation assumptions defining semi uniform trees
number available plan instances j vary across different levels tree secondly
section consider example non uniform goal plan tree industrial
application derive number paths real goal plan tree compare
analysis similarly sized uniform goal plan trees see whether real non uniform
tree significantly lower number paths uniform tree finally section
consider issue infinite trees allowing trees recursive defining
number paths bound path length recursive tree
analysis uses following terminology
uniformity assumptions mean structure subtree rooted goal
plan node determined solely depth therefore denote goal
plan node depth gd pd respectively
use n xd denote number successful execution paths goal plan tree
depth rooted x x goal g plan p specifying
important sometimes elide writing n x
similarly use n xd denote number unsuccessful execution paths
goal plan tree depth root x g p
extend notation plan body segments e sequences x xn xi
goal action denotes sequential composition abbreviate sequence
n occurrences x xn example g g g g
base case successful executions
begin calculating number successful paths goal plan tree
absence failure failure handling analysis follows padgham
winikoff pp
roughly speaking number ways goal achieved sum number
ways children achieved since children represent alternatives


fiwinikoff cranefield

e goal represented node hand number ways plan
achieved product number ways children achieved
since children must achieved e plan represented node
precisely n x x n x n x sequence successful x
x successful
given tree root g goal assume j children achieved
n different ways select one children number ways
g achieved jn similarly tree root p plan assume
k children achieved n different ways execute children
number ways p executed n n nk plan children
e depth executed successfully exactly one way yields following
definition
n gd j n pd
n p
n pd n gd k n gd k
expanding definition obtain
n g j n p j j
k

n g j n p j n g j j k j k
n g j n p j j k k j k
n g j n p j j k

k

k

k j k

k k

generalised
n gd j

pd


ki

k simplified equivalence k k k k k
give following closed form definition k n gd n pd j
n gd j k


n pd j

k

k kd k




note equation n pd assumes sub goals achieved sequentially
executed parallel number options higher since need consider
possible interleavings sub goals execution example suppose plan pd
two sub goals g g sub goals n gd successful executions
execution l steps assume ease analysis execution paths
length number ways interleaving two parallel executions
length l calculated follows naish section


l
l

l
l l
tree assumed uniform children achieved number
ways thus interchangeable analysis allowing us write j n rather n nj



fion testability bdi agent systems

hence number ways executing pd parallel execution subgoals








n pd n gd

l
l



n gd

l
l l

remainder assume sub goals plan achieved
sequentially since common case since yields lower figure
shall see still large enough allow conclusions drawn
adding failure
extend analysis include failure determine number unsuccessful
executions e executions failure top level goal moment
assume failure handing add failure handling section
order determine number failed executions know failure
occur bdi systems two places failure occurs goal
applicable plan instances action within applicable plan instance fails
however uniformity assumption means address former caseit
assumed goal j instances applicable plans note
conservative assumption relaxing number unsuccessful executions
even larger
order model latter case need extend model plans encompass
actions example suppose plan body form ga gb ai
actions ga gb sub goals denotes sequential execution plan
following five cases unsuccessful e failed executions
fails
succeeds ga fails
ga succeed fails
ga succeed gb fails
ga gb succeed fails
suppose ga executed successfully n ga different ways third
case corresponds n ga different failed executions successful execution ga
extend adding failed execution actions executed one way
e n n similarly gb n gb successful executions fifth
case corresponds n ga n gb different failed executions ga unsuccessfully
executed n ga different ways second case corresponds n ga different executions similarly fourth case corresponds n ga n gb different executions putting
together total number unsuccessful executions plan p
body ga gb sum five cases
n ga n ga n ga n gb n ga n gb


fiwinikoff cranefield

formally n x x n x n x n x sequence fail
x fails x succeeds x fails follows n xk n x k n xk
n x n x k easily proven induction
generally assume actions sub goals
plan e example plan corresponds following plan body
corresponds g g plan sub goals e depth
considered consist actions quite conservative particular
use assume plans depth consist single action
number unsuccessful execution traces goal plan tree defined
analysis follows first calculate numbers successes
failures following repeated section plan body gd
n gd n gd n
n gd n
n gd
n gd
n gd n gd n gd n
n gd n gd n n
n gd n gd

n pd n gd k
n n n gd k
n n n n gd k
n gd n gd k
n gd n gd n gd k
n gd k
n gd n gd
assuming n gd
n gd
yields following definitions number unsuccessful executions goalplan tree without failure handling equation n gd derived
reasoning previous section single plan selected executed j
plans
n gd j n pd
n p
n gd k
n gd

n gd

n pd n gd n gd

finally note analysis number successful executions goal plan
tree absence failure handling presented section unaffected addition
actions plan bodies one way sequence actions
succeed equations remain correct


fion testability bdi agent systems

adding failure handling
consider introduction failure handling mechanism affects analysis
common means dealing failure bdi systems respond failure
plan trying alternative applicable plan event triggered plan
example suppose goal g e g achieve goal go home three applicable plans pa
pb pc pa selected fails failure handling mechanism
respond selecting pb pc executing assume pc selected pc fails
last remaining plan pb used fails goal deemed
failed
might hope harder fail way goal
execution fail applicable plans tried fails
number executions computed follows goal gd j applicable plan instances n pd unsuccessful executions n pd j
unsuccessful executions plans sequence since plans selected
order multiply j yielding n gd j n pd j
number ways plan fail still defined equation
failure handling happens level goalsbut n g refers
definition
j

n gd j n pd





n p




k

n gd
n gd

n gd

n pd n gd n gd



turning number successful executions e n x observe
effect adding failure handling convert failures successes e execution
would otherwise unsuccessful extended longer execution may succeed
consider simple case depth tree consisting goal g e g achieve goal go home
three children pa pbandpc previously successful executions corresponded
pi e select pi execute however failure handling
following additional successful executions well additional cases corresponding
different orderings plans e g pb failing pa successfully executed
pa fails pb executed successfully
pa fails pb executed fails pc executed succeeds
leads definition form
n g n pa n pa n pb n pa n pb n pc
fact actually underestimate possible goal fail none untried
relevant plans applicable resulting situation noted earlier assume analysis
goals cannot fail applicable plan instances conservative assumption
relaxing number behaviours even larger



fiwinikoff cranefield

however need account different orderings plans instance case
first selected plan succeeds corresponding first term n pa fact applies
j plans first term including different orderings j n p
similarly second term n pa n pb corresponding case initially
selected plan fails next plan selected succeeds fact applies j initial plans
j next plans yielding j j n p n p
continuing process j yields following formulae


n g n p n p n p n p n p
generalises
j

n g j n p j j n p n p j n p

n p

resulting following equations since failure handling done goal level
equation plans section


n gd

j
x



n pd

n pd



n p


j
j






n pd n gd

k





used standard bdi failure handling mechanism trying alternative
applicable plans let us briefly consider alternative failure handling mechanism
simply posts event without tracking plans already attempted
fairly easy see fact creates infinite number behaviours suppose
goal g achieved pa pb pa could selected executed resulting
failure pa could selected fail etc suggests
standard bdi failure handling mechanism fact appropriate avoids
infinite behaviour space possibility infinite loop discussed earlier
section failure recovery mechanism used apl apl dastani cannot
analysed general way since depends details specific agent program
irma bratman et al provide sufficient details allow analysis
tables make equations developed far concrete showing illustrative values n n range reasonable fairly low values j k
number columns number goals plans actions tree number actions brackets many actions executed
single successful execution failure handling number goals calculated
follows depth single goal see figure depth n
j k g n goals g n denotes number goals depth n tree
gives g n j k j k j k n example j k
g since goal exactly j plans number plans tree
depth n j g n consider number actions non leaf plan
k actions since k goals k places actions
leaf plan actions tree depth n j j k n leaf plans let p n
number plans depth n tree comprised pn n non leaf plans


fion testability bdi agent systems

parameters
j k










goals





number
plans






actions





n g



n g











table illustrative values n g n g without failure handling first number actions e g number actions tree second
e g number actions single execution failures occur

parameters
j k










goals





number
plans






actions





n g





n g





table illustrative values n g n g failure handling
pl n leaf plans e p n pn n pl n number actions depth n tree
k pn n pl n example j k
p g comprised leaf plans non leaf plans
therefore actions
recurrence relations
equations previous sections define functions n n mutual recurrence
depth goal plan tree uniform branching structure effect
increasing parameters k evident level recursion
clear effect increasing number applicable plan instances j
given goal aim section explore effects changing j
relaxing uniformity assumption specifically allow number plans available
vary goal nodes different depths tree still assuming nodes
given depth structure refer semi uniform goal plan trees
derive set recurrence relations n n presence failure handling
explicitly effect adding plan goal root particular
sub tree
begin defining generalised notation n gj n gj j list
jd jd j element ji represents number plans available goals
depth goal plan tree denote empty list hi write j j represent
list head j tail j
order corresponds definition depth decreases tree



fiwinikoff cranefield

generalise equations apply semi uniform goal plan trees
derivation equations depended sub nodes goal plan node
structure assumption preserved generalised setting
therefore rewrite equations notation express right
hand sides functions f f n pj f n pj aim recursive
definition f f recurrence j
n gjj f j n pj
n gjj f j n pj n pj

f j j aj
f j b

j
x

b ai



j
j

change bounds n hence replace


j
x

b



j
j

simplify j j j


j
x


b ai

j j
j

multiple reorder


j
x


j
ai j b
j


j
use definition binomial
j j

j
x
j
ai j b







expression right last line corresponds following combinatorial analysis f goal gjj successful execution involve sequence
plan executions thatfail j followed one plan execution
succeeds ji ways choosing failed plans ordered ways
plan n pj ways fail j ways choosing final
successful plan b n pj ways succeed
goal explicit characterisation incremental effect adding
extra plan n gjj n gjj finding definitions f f recurrence relations
terms parameter j deriving recurrence relation f straightforward
f j j aj j j
j j
z
j times


fion testability bdi agent systems

n gjj f j n pj n pj
n gjj f j n pj
f b
f j b j b f j b





f


f j j f j
n phi
n phi
n pj n gj k j hi
n gj k
j hi
n pj n gj n gj
n gj
figure recurrence relations numbers failures successes goal plan tree
presence failure handling

shows f f j j f j
however derivation recurrence relation f simple use
technique first finding exponential generating function e g f wilf
sequence f j b
j derive recurrence relation details
given appendix b yield equation figure
equation copied equation appendix b gives us recurrence relation

sequence f j b
j seeking figure brings together
equations far failure handling case including previous
section defining n pd n pd generalised semi uniform trees
formulation gives us different way looking recurrence allows us
easily see behaviour space grows number applicable plans j
goal grows considering meaning parameters b numbers failures
successes respectively plan level current goal node equation
f j b seen following combinatorial interpretation one plan
must selected try initially j choices succeed one
b different ways meaning plans need tried fail one different
ways fails goal must succeed remaining j plans
occur f j b ways
see growth number successful executions goal grows
rate greater j aj presence b term relaxed uniformity
simple case b listed sequence line encyclopedia
integer sequences sloane number permutations nonempty subsets n



fiwinikoff cranefield

constraint used recurrence relations gives us way investigate numbers
traces goal plan trees different semi uniform shapes however remainder
focus uniform trees original parameter j exception
section
probability failing
section said introducing failure handling makes harder fail however
tables appear first glance contradict many ways
failing failure handling without failure handling
key understanding apparent discrepancy consider probability
failing tables merely count number possible execution paths without
considering likelihood particular path taken working probability
failing shows although many ways failing
succeeding probability failing indeed much lower
let us denote probability execution goal plan tree root x depth
failing p xd probability succeeding p xd p xd
assume probability action failing probability
given plans actions succeeding simply x x number actions
hence probability plan failing failure one actions simply
x e plan depth probability failure

plan depth greater probability failure due actions
k
recall plan actions k sub goals
considering actions sub goals g gk plan p
plan succeed sub goals must succeed additionally plans
actions must succeed giving p pd p gd k easily derive
equation p pd given note reasoning applies plan regardless
whether failure handling failure handling done goal level
absence failure handling goal g possible plans p pj succeed
must select one plan execute probability success probability
plan succeeding e p gd p pd ignore moment possibility
goal failing applicable plans assumption relaxed later
formally case without failure handling
p gd p pd
p p
k

p pd p gd
simplicity assume failure action plan independent failure
actions plan



fion testability bdi agent systems














failure handling







failure handling







table goal failure probabilities without failure handling
consider happens failure handling added case order
goal fail plans must fail e p gd p pd j since failure handling
goal level equation plans unchanged giving
p gd p pd j
p p
k

p pd p gd
easy see equations patterns probabilities actually
illustration purposes table shows probability failure
without failure handling two scenarios values computed j k
e relatively small branching factor consider two cases
hence rather high hence

seen without failure handling failure magnified larger goalplan tree actions involved hence greater chance action
somewhere failing leading failure top level goal since failure
handling hand failure handling probability failure low
doesnt appear grow significantly goal plan tree grows
relax assumption goal cannot fail applicable
plans e goal fail plans tried unfortunately relaxing
assumption complicates analysis need consider possibility none
remaining plans applicable point failure handling attemped
let us begin reconsidering case failure handling use g
denote probability goal failing none remaining plans applicable
case failure handling non zero g indicates situations
goal applicable plans may indicate error part
programmer certain situations goal may possible achieve
assume analysis purposes probability constant particular
depend plans already tried number relevant
plans remaining
probability goal failing p gd g g p pd e goal fails
plans applicable applicable plans selected
plan fails equation plans unchanged since failure handling done


fiwinikoff cranefield

goal level following equations case without failure handling
p gd g g p pd
p p
k

p pd p gd
observe setting g yields equations derived earlier assumed
goal cannot fail due inapplicable plans
consider probability failure failure handling goal two
plans following cases
goal fail plans applicable g
applicable plans g goal fail first selected
plan fails p pd failure handling successful occur
applicable plans g applicable plans g
selected plan fails p pd
putting together goal two plans
p gd g g p pd g g p pd
general case j available plans goal fail
applicable plans outset probability g
b applicable plans g selected plan fails p pd
applicable plans g
c applicable plans g selected plan fails p pd
applicable plans g
reasoning b repeated j times
gives definition following form
g g p pd g g p pd g g
z
z

z
z
b
c


defined terms auxiliary function p gd defines probability
failure goal g depth remaining relevant plan instances may
may yield applicable plan instances
p gd p gd j
p gd g g p pd
p gd g g p pd p gd
p p
k

p pd p gd


fion testability bdi agent systems
















failure handling
g
g g









g g g










failure handling
g
g g









g g g










table goal failure probabilities without failure handling goals
applicable plans

observe setting g reduces definition derived earlier since g g x
simplifies x hence p gd p pd
immediately clear formulae actual patterns
probability considering illustrative examples table shows overall behaviour b g assumed relatively low compared
probability action failure doesnt significantly affect probabilities
analysis rate failures
section briefly examine number traces goal plan tree affected
placing bound rate action failures occur within trace simplicity
work uniform goal plan trees construction extends trivially semiuniform goal plan trees
figure presented equations calculating total number behaviours
goal plan tree failure handling many behaviours involve possibly
unrealistic number action failures make assumption upper
limit rate action failures e number failures divided length
trace affect number possible behaviours large numbers
seen reduce significantly
instance considering j k possible executions
failure many involve high rate action failure many
involve small percentage failures figure contains cumulative counts
generated looking possible executions small case plotted
number action failures x axis shows given value n many
traces n fewer action failures instance n
traces fewer action failures traces successful
unsuccessful figure shows equivalent graph rate action failure trace
failure rate computed number failures divided length trace
bounding rate action failures allows us model assumption environment limited
unpredictability perhaps programmer limited incompetence



fiwinikoff cranefield

ok

failed





number traces cumula





























ok















failed































number failures

figure number traces cumulative vs number failures j k




number traces cumulative
































failure rate

figure number traces cumulative vs failure rate j k



fion testability bdi agent systems

number traces counted range failure rate instance first
data point graph shows traces failure rate
question generalise analysis larger execution spaces clearly
counting possible executions feasible instead turn generating functions
given plan body segment particularly gd interested
computing numbers successful failed traces failure rate bounded
given ratio r number failed actions total number actions
e proportion actions execution trace fail denote n r
n r compute values first determine integers n
numbers successful failed traces length contain exactly n action
failures denoted n r n n r n respectively define length trace
number actions successful unsuccessful contains note
finite goal plan tree uniform semi uniform one maximum
possible trace length n r n n r n non zero finite
number integer pairs n positive quadrant plane positive
axis case n values calculate n r
n
r similarly n rs n r n
sum n r n
begin considering ordinary bivariate generating functions wilf
values n r n n r n


fr x
fr x

x

x

n r n xm n

n
x

x

n r n xm n

n

action one successful execution length contains action
failures fr x x power series coefficient x
coefficients similarly fr x x xy one failed execution
length one action failure
consider fr
fr x


x

x

n r n xm n

n
x

x
n

x

x


nr p nr q u xm n




p q u n

double sum parentheses considers trace possible ways allocating
number actions number action failures n necessarily successful
executions sums non negative integer values p q u
recall defined towards start section page plan body segment sequence
x xn xi goal action
ordinary generating functions differ exponential generating functions including denominators
factorials powers variable



fiwinikoff cranefield


fr x



x
x
x x

n r p xp n r q u xq u

p q n u n
x
x
x

x

n r p xp n r q u xq u

p q u

x
x

x

x


p

q u

nr p x
nr q u x
p

q u





fr x fr x
p
p p
p
second line derived identity
q
p

p q f p q
f p q expressions sum non negative integers p q first expression
first summing non negative values horizontal axis
summing pairs p q non negative integers lying line slope
intersects horizontal axis
considering fr x
fr x


x

x

n r n xm n

n
x

x

n r n

n





x

x



nr p nr q u xm n




p q u n


xx

n r n xm n

n
x

x



n

x

x


nr p nr q u xm n




p q u n



fr x
x
x

x

x


n r p xp
n r q u xq u
p

q u

fr x fr x fr x
second line observation failed execution
length n action failures failed execution length n
action failures occurring execution successful execution length p
failures followed failed execution length q u failures
p q u n
assuming know fr gd x fr gd x depth
construct functions fr pd x fr pd x applying expand
right hand sides following equations simply replace pd plan body


fion testability bdi agent systems

fr pd x fr gd k x
fr pd x fr gd k x

remains define fr gd x fr gd x terms fr pd x fr pd
x count successful executions gd length n action failures
must first choose one j applicable plans one ultimately succeeds
must choose j remaining applicable plans tried
failed consider possible orderings plans actions trace
n action failures must distributed across failed successful plans leads
us following derivation procedure construct fr gd x
fr gd x
x

x

n r gd n xm n
n



x

x


j

n

j

p


j
x
j
p

p

j


j
x
j

p

p

x

p

x

n r pd f

p



x

x


n

n r pd xm n



p f fp n

x

x



n r pd f

p



n r pd xm n



p f fp n

j
x
p

x
x
p
x

x

j

f

f
p
nr pd f x
nr pd f x
p
f

f


j
x
j
j
p fr pd x fr pd x p
p
p

constructing fr gd x simpler failed execution goal involves failed attempts
execute j applicable plans j orderings plans must considered
gives us following construction fr gd x
fr gd x


x

x

n r gd n xm n

n
x

x

x

j

n

j

x
x


x

j f fj n


f

nr pd f x

f

j fr pd x j


j



nr pd f nr pd j fj xm n




fiwinikoff cranefield

equations define recursive procedure computing fr gd x fr gd
x given values j k discussed earlier section given way
n
calculating n r n calculate n r sum n r n
r

similarly nrs used python rmpoly gmpy libraries generate
polynomial representations functions fr gd x fr gd x specified
values j k l calculate n r n r ratios r figure
shows j k
examining figure conclude two things one hand number traces
really explodes larger rates action failures example figure traces
failure rate greater hand although making assumptions
failure rate reduce number possible traces number traces still quite
large note scale axis instance failure rate around
failed executions successful executions failure rate
respective numbers failure rate

shape figure explained follows firstly occurrence action
failure triggers activity alternative plans failures longer traces
secondly longer traces shorter traces simply
longer trace possibilities variations e g different orders trying
plans explains increase figure starts slowly accelerates
get failures longer traces longer traces
word plot non cumulative number paths
ratio action failures would see initial increase ratio grows
paths doesnt explain beyond certain point get fewer traces
cumulative graph levels explanation quite simple beyond certain
ratio appears around successful traces number
failed traces declines
recursive trees
section developed recurrence relations allowed us relax assumption
goal plan trees uniform considered semi uniform trees section
relax assumption goal plan trees finite allow trees
shape considering arbitrary trees allowed contain labels
refer parts tree e allow trees recursive derive generating
functions seen extension derived previous section
number paths successful unsuccessful executing recursive goalplan trees obviously infinite tree infinite number paths define
generating functions take parameter bound lengths paths counted

finite number actions attempted execution goal plan tree
bounds length possible traces number action failures occur within
thus fr gd x fr gd x polynomials finite orderonly finite number coefficients
non zero infinite sums define



fion testability bdi agent systems

failed executions cumulative

successful executions cumulative

cumulative

e

e

number traces cumulative

e

e

e

e

e

e






















































failure rate

figure number traces cumulative vs failure rate j k
given upper bound path length equations specify number paths
many actions
begin defining notation representing recursive trees goals plan body
multisets plans variables bindings goal represented term form
goal plan body multiset plan body multiset multiset representing different
applicable plan instances used satisfy goal multiset
combinatorial analysis structure plans significant therefore
use single abstract action represent actions goal may achievable
multiple plan instances structure must treat
distinct need represent bodies plan instances element
multiset e plan sequence terms separated right associative sequential
composition operator term sequence abstract action term
goal term defined representing sub goal label see formally
plan body multiset p multiset plans written p c pj cj
ci number times associated plan pi appears multiset
define following multiset operations set p set pi multiset p
p pi characteristic function denoting number times plan pi appears
multiset e ci p p multiset subtraction defined p p x
max p x p x finally p size multiset e sum ci

use equations derived section non recursive trees case allow
define f power x f
however avoid confusion use numeric subscripts distinguish different occurrences actions



fiwinikoff cranefield

order allow recursive trees represented possible step plan
label denoted referring term provided binding simply
mapping labels terms goal plan terms b binding write
b denote item mapped b entry b
example consider simple tree consisting goal two plans together
binding maps variable root tree first plan left
two steps action recursive reference root tree
second plan right single action
goal
plan

plan






recursive tree represented follows define binding b
goal maps whole tree tree
proceed defining generating functions introduce auxiliary notation p power series use standard notation xp xpnn p denote
coefficient term xp xpnn series define p cond denote power
xn

series containing terms p satisfy condition cond define f g
f g power x n e f g terms power x greater n removed
n
define f mx f power x n e f terms power x greater
n removed
position derive generating functions specify number
paths arbitrary possible recursive goal plan tree given bound
path length define bdi program represented term e goal plan
plan multiset action label b binding mapping labels terms defined
define n n b number successful paths respect
binding b actions n failed actions similarly define
n n b number failed paths respect b actions
n failed actions want derive recurrence relations generating
functions

f
x b


f
x b

x

x
n
x

x

n n b xm n
n n b xm n

n

upper bound number actions path
previous operation directly supported rmpoly python library multivariate
polynomials series used compute generating functions
subscript used distinguish generating functions allow recursive tree
generating functions defined elsewhere



fion testability bdi agent systems

order simplify presentation details complex derivations
given appendix c resulting equations shown figure first two
equations equations figure applicable term capture
assumption remaining equations apply next
two equations simply specify labels looked provided binding equation
indicates single successful path action single
action unsuccessful actions e generating function x equation
similarly indicates single unsuccessful path single action
unsurprisingly single unsuccessful action generating function x
equations deal sequences sequence succeed
must succeed count paths concatenating sub paths corresponds
multiplying power series sequence fail fails succeeds
fails alternatives correspond addition power series equations
special case action divide overall path length limit
precisely must trace length since action must therefore
maximum length
dealt labels single actions sequences next turn goals equations cases derivation complex covered appendix c

f
equation appendix c intuition successful path
goals execution involves single successful plan p number failed executions
plan selected remaining multiset plans p p case plan
appears multiset select occurrences hence
multiplication p p number failed paths goal equation
appendix c introduce auxiliary generating function g p x z b
p multiset plans z variable whose power z indicates exact number plans p used words given power series denoted
g p x z b term cmno xm n z indicates cmno paths involve actions n failed exactly plans p generating

function g technical device allows us derive definition f
need

given power series definition f simply selects terms p
power z since plans must fail goal fail removes
z p terms dividing g exponential generating function z
means includes division factorial need multiply factorial p
remove

equation defines f
p x b used equation terms

auxiliary function g derivation given appendix c intuition
possible number plans could used limit power series g
value remove z dividing due g exponential
generating function z see appendix c

finally equations give definition g p x z b see appendix c
derivation intuitively equation creates power series plan type
x

combines equation little complex single way
failing plans used corresponding term x z otherwise
select c plans plans must fail corresponding term


fiwinikoff cranefield


f
x b





f x b















f x b f b x b
f x b f b x b








f x b x
f x b xy


f x b



f
x b f
x b action

x


f x b f
x b otherwise

f
x b




x b f
x b f
x b action
f

x



f
x b f
x b f
x b otherwise

f
goal p x b
x
x



p p f
p x b f
p p x b







pset p

f
goal p x b p

p

f
p x b

x




g p x z b power z p
z p
g p x z b power z
zo




g p c pj cj x z b
x

x

g p c x z b g pj cj x z b



c
x
c
g p c x z b
f p x b ox z









figure equations recursive goal plan trees

f
p x b giving number failed traces across plans
x

x




f
p x b ox f
p x b f
p x b

z


times

used python rmpoly gmpy libraries generate polynomial repre

sentations functions f
x b f
x b defined figure
specified values b defined simple tree one given earlier
section example computed number paths different values


fion testability bdi agent systems

values chosen correspond values table
values n g n g come table values correspond
longest path argue comparing recursive tree uniform tree
consider path length limit shown table




n g



n g



n



n



table comparing n n respectively n n
looking numbers table worth noting recursive tree
used extremely simple two plans single action low number
actions sparseness tree account relatively low number unsuccessful
paths instance modify tree adding extra actions giving tree
binding around successful paths
unsuccessful paths unfortunately python unable calculate n n tree
manage successful paths
unsuccessful paths shows expected number unsuccessful
paths higher complex tree fewer successful paths
complex tree explained observing tree traces longer
actions need done traces excluded bound trace
length
goal
plan

plan










overall analysis section application confirms
number paths recursive tree depends trees structure
unsurprising indicates even simple recursive tree number
paths given upper bound path length quickly becomes extremely large

reality check
previous section analysed abstract model bdi execution order determine
size behaviour space analysis yielded information size
behaviour space affected factors probability goal
failing
section consider two issues whether analysis faithful whether
applicable real systems analysis made number simplifying assumptions
correspond first two rows table respectively involve actions



fiwinikoff cranefield

mean may faithful semantics real bdi platform
may apply real systems thus conduct two reality checks assess
whether analysis faithful section whether applicable section
firstly assess whether analysis faithful real bdi platforms e
omit significant features contain errors comparing abstract
bdi execution model real bdi platform namely jack busetta et al
comparison allows us assess extent analysis abstract bdi
execution model matches execution takes place real industrial strength bdi
platform comparison essence basic reality check simply checking
analysis previous section indeed match execution semantics typical
bdi platform modelling artificial goal plan tree bdi platform
next order assess extent analysis apply real systems
analyse goal plan tree real industrial application analysis allows us
determine extent conclusions analysis uniform semi uniform
goal plan trees applies real applications goal plan trees likely
uniform words extent large numbers tables apply
real applications
real platform
order compare real bdi platforms execution abstract bdi
execution model implemented two goal plan trees appendix jack agent
programming language structure plans events precisely mirrors
structure tree goal plan tree event two relevant plans
applicable selectable order actions implemented
code printed action name depending condition described
continued execution triggered failure printed failure indicator
system print action
n
system print x
false trigger failure

conditions determined whether action failed succeeded plan
selected first controlled input n java class variable test harness
systematically generated inputs thus forcing decision options explored
matched computed prolog code figure giving precisely
six traces smaller tree traces larger tree
indicates abstract bdi execution model indeed accurate description
takes place real bdi platform specifically jack
note selected jack two reasons one modern well known
industry strength bdi platform important reason jack descendent line bdi platforms going back prs thus good representative
code available upon request authors
jack goal bdigoalevent



fion testability bdi agent systems

parameters
number
j k

goals
actions







workflow goals
says goals
figure goals

failure handling
secs
n g
n g








failure handling
section
n g
n g













table illustrative values n g n g bottom part first row
second last row

larger family bdi platforms words showing bdi execution model
analysed matches jacks model able argue matches execution
jacks predecessors including prs dmars close relatives e g um prs
jam
real application
consider extent real systems deep branching goal plan trees
extent large numbers shown tables apply real applications
rather uniform goal plan trees example real application consider
industrial application daimler used bdi agents realise agile business processes
burmeister arnold copaciu rimassa note finding suitable application
somewhat challenging need application real toy system however
order able analyse application bdi furthermore
details applications goal plan tree need available unfortunately many
reported bdi industrial applications provide sufficient details
internals allow analysis carried
figure shows goal plan tree work burmeister et al
achieve goals levels maintain goals plans context
variables burmeister et al p unlike typical goal plan trees used bdi
platforms tree figure consists layers refined goals
refinements leaves plans terms analysis presented
treat link goal g set goals say g g g
equivalent goal g single plan p performs g g g actions
e non leaf plans
last row table gives n values goal plan tree top
row middle row bottom row note figures actually
lower bounds assumed plans depth simple linear combinations
actions whereas clear burmeister et al plans fact
details meant legible structure matters



fiwinikoff cranefield

model
ls ab
differe
model
keep th

figuretree
goal
acm
prototype
figure goal plan
thehierarchy
work burmeister
et al
figure reproduced
permission ifaamas

advantage modeling implicitly offers
support parallel execution process parts
depend reduce overall time needed
complicated contain nested decision making e g see burmeister et al
process
execution moreover maintain goals good means
figure
provide
process


agent
monitors
roughthe
indication
size
aadditional
goal plan tree isagility
number
goals

goals
tree figure
sizeto


firstthroughout
two rows table
comparing e g

conditions

fulfilled
process
number possible behaviours uniform goal plan trees real nontime
constraints

pro actively
activities
avoid
uniform
goal plan tree
see
behaviour initiates
space somewhat
smaller

real
tree thatbefore
stillthey
quite appear
large especially case failure handling however

note following points

development prototype support rapid
tree figure plans leaves reduces complexity
prototyping
execution process provided
words goal plan tree typical plans alternating
goals would

larger number
possible
behaviours
ls abpm

proven
ofvery
helpful
developed
represent
living process directly executed
figures tree conservative estimate since assume leaf plans
visualized

part ofin
interface
thatcalculated
coupled
simple
behaviour
otherweb
words user
number
paths

theis
actual
number directly
paths thefrom
real application
estimate
workflow
generated
process model

interface computed directly parameters
comparison procedural programs
corresponding task context variables types possible
order argue bdi programs harder test non agent programs need
values


ofprocess
programs
quickly
comparison
specifically
need changes
analyze number
paths non agent
compareand
tested
agent
programs
us address
concern
modeled
thus
errorsthis

theallow

bethediscovered
paths criterion test suite adequacy requires infeasibly large number

corrected
briefly
short
tests
section
doestime
analyzing number paths procedural
program

stated starting point building acm prototype
model acm reference
process model developed
software demonstrator underlying agent engine
demonstrator jadex partially different modeling
execution semantics compared ls abpm tool


model
prototy

compl
depend
challen

execut
depend
proces


con

contex
manip
model
plans

compl
possib
variab
variab
one
proces
variab
startin
goals
create
h
model

fion testability bdi agent systems

number actions statements





n





n g





n g





table comparison values n n g n g
define program composed primitive statements sequences statements p p conditionals select two sub programs since capture
conditions statements elide condition write conditional p p indicating one pi selected note bdi analysis exclude loops
define number paths program p n p straightforward see
definition n p
n
n p p n p n p
n p p n p n p
order compare bdi programs consider size program
compare programs size key question procedural program
nodes significantly fewer paths bdi program size define
size program p number primitive statements contains denote
p note means count internal nodes syntax tree
e therefore comparing bdi programs consider size
bdi program number actions
work number paths varies size program p
size program therefore natural number define n max n p
p n largest number paths possible program size
appendix contains derivation n resulting following definition
multiple
n
n
n
n














n
n
n
n











table shows comparison values n n g n g sized
programs table worth emphasising n highest possible value
defined maximum possible programs however maximal program
highly atypical example considering programs seven statements
path p p simply concatenates path p path p hence product path
p p path p path p hence addition
total number nodes tree yields almost identical



fiwinikoff cranefield

total possible programs programs paths
maximum figure shows number paths many programs
many paths maximum clearly typical indeed mean number paths
seven statement program median consider programs
statements programs maximal
number paths average number paths across programs

overall looking table conclude number paths bdi programs
much larger even atypical maximal number paths procedural program
size supports conclusion bdi programs harder test
procedural programs


number programs






















number paths procedural program







figure profile number paths statement programs

conclusion
summarise analysis found space possible behaviours bdi agents
indeed large absolute sense relative sense compared procedural
programs size
expected number possible behaviours grows trees depth breadth
j k grow however somewhat surprisingly introduction failure handling makes
significant difference number behaviours instance uniform goalplan tree depth j k adding failure handling took number successful
behaviours
consider negative consequences analysis worth highlighting
one positive consequence analysis provides quantitative support long held belief


fion testability bdi agent systems

bdi agents allow definition highly flexible robust agents flexibility
defined number possible behaviours agent shown large
robustness defined ability agent recover failure analysis
section showed bdi failure recovery mechanism effective achieving low
rate actual failure even action reasonable chance failing
analysis tell us testability bdi agent systems
answer question need consider tested testing
typically carried levels individual components unit testing collections
components integration testing system whole
consider testing whole system behaviour space sizes depicted tables
suggest quite strongly attempting obtain assurance systems correctness
testing system whole feasible reason discussed
section adequate test suite paths criterion adequacy requires
least many tests paths program tested program say
paths even test suite tens thousands tests inadequate
hugely inadequate since covers tiny fraction percent number
paths
fact situation even worse consider number possible
executions probability failing space unsuccessful executions particularly hard test since many unsuccessful executions successful ones
probability unsuccessful execution low making part behaviour
space hard reach furthermore shown section although making assumptions
possible numbers action failures occur given execution reduces
number possible behaviours still many many behaviours even relatively
small trees e g j k
system testing bdi agents seems impractical unit testing
integration testing unfortunately clear apply usefully
agent systems interesting behaviour complex possibly emergent
example given ant colony optimisation system dorigo stutzle testing single
ant doesnt provide much useful information correct functioning whole
system similarly bdi agents testing sub goal difficult ensure
testing covers situations goal may attempted consequently
difficult draw conclusions correctness goal testing
sub goals
need acknowledge analysis somewhat pessimistic real bdi systems
necessarily deep heavily branching goal plan trees indeed tree
real application described section smaller behaviour space abstract
goal plan trees analysed section however even though smaller still quite large
cause validation

one big challenges test phase keep model consistent
define right context conditions correct execution
scenarios therefore support dependency analysis automated


fiwinikoff cranefield

simulation testing process needed burmeister et al
p
leave us respect testing agent systems conclusion
seems testing whole bdi system feasible number possible
approaches dealing issue testability could recommended
keep bdi goal plan trees shallow sparse keeps number behaviours small issue lose benefits bdi
reasonably large number behaviours desirable provides
flexibility robustness
avoid failure handling since failure handling large contributor behaviour space could modify agent languages disable failure handling
useful disabling failure handling removes benefits
specifically ability recover failures
make testing sophisticated could testing coverage perhaps improved
incorporating additional information domain knowledge detailed
model environment indicates possible failure modes probabilities answer known potentially interesting area
work however large number paths encourage much optimism

another related direction see whether patterns exist behaviour space
since failure recovery mechanism certain structure may
behaviour space large sense structured
structure exists may useful making agents testable however
point time direction may may turn fruitful
viable testing strategy
finally related direction try intelligent selection
test cases order gain coverage given number test cases one
recently described evolutionary testing
nguyen miles perini tonella harman luck genetic evolution
used good e challenging test cases
supplement testing alternative means assurance since testing
able cover large behaviour space consider forms assurance
promising candidate form formal method unfortunately formal
methods techniques yet applicable industry sized agent systems return
section
burmeister et al made following observation changes process
quickly modeled tested thus errors discovered corrected short time
discussing advantages executable arguing able execute
model allowed testing useful detecting errors model able execute
model undoubtedly useful evidence given specific claim made testing
sufficient assuring correctness agent system
see edited dastani et al recent overview current state art
including chapter role formal methods assurance agents winikoff



fion testability bdi agent systems

proceed caution accept bdi agent systems general robust due
failure handling mechanisms present practical way
assuring behave appropriately possible situations worth
noting humans similar respect whilst train examine
certify human certain role e g pilot surgeon way assuring
behave appropriately situations consequently situations
incorrect behaviour may dire consequences surrounding system needs
safety precautions built e g process double checks information
backup system co pilot
future work
room extending analysis section firstly analysis single
goal within single agent multiple agents collaborating achieve single highlevel goal viewed shared goal plan tree certain goals plans
allocated certain agents course distributed goal plan tree
concurrency concurrency introduced would useful consider whether
certain interleavings concurrent goals fact equivalent furthermore
considered achievement goals would interesting consider types goals van
riemsdijk dastani winikoff secondly analysis focused bdi agents
one particular type agent would interesting consider sorts
agent systems broadly sorts adaptive systems
another extension analysis consider criteria test suite adequacy
used paths criterion arguing appropriate
recognize paths actually quite strong criterionit subsumes many
criteria zhu et al figure alternative criterion could consider
edges known branch coverage decision coverage requires
choice program statement tests test suite
exercise options e edges program graph covered edges
criterion weaker paths regarded generally accepted minimum
jorgensen
another area refinement analysis make less abstract two specific areas
could made detailed resources environment analysis
consider resources environment directly instead considers actions may
fail range reasons might include resource issues environmental issues
analysis could extended explicitly consider resources interaction goals
thangarajah winikoff padgham fischer could extended
explicit model environment
whilst analysis consider real application would desirable consider
range applications could provide additional evidence analysis unduly
pessimistic would lead understanding variance goal plan trees
characteristics across applications key challenge finding suitable applications
bdi sufficiently complex ideally real applications detailed design
information available preferably source code another challenge methodology
analysed shape goal plan tree daimler workflow application


fiwinikoff cranefield

access run system alternative methodology requires access
implemented system probably source code run force generate
traces sub goals would require modification source code
underlying agent platform collected data shape real world
industrial applications able analyse whether uniform semi uniform goalplan trees good types system whether seek ways
relax uniformity assumption
importantly highlighted difficulties assuring bdi agent systems
testing need ways assuring systems
promise automatic generation test cases agent
systems nguyen perini tonella zhang thangarajah padgham however size behaviour space suggests number test cases needed may
large testing failed plan execution difficult one interesting
potentially promising avenue use formal techniques help guide test generation
process e g symbolic execution specification guided testing dwyer hatcliff pasareanu robby visser
another attracted interest model checking agent systems
wooldridge fisher huget parsons bordini fisher pardavila wooldridge
raimondi lomuscio work promising model checking techniques use range abstractions cover large search space without deal
individual cases one time burch clarke mcmillan dill hwang fix
grumberg heyman heyman schuster furthermore verifying subgoal considers possibilities possible combine verification different sub goals
however work needed raimondi lomuscio verify systems agents
defined abstractly e terms plans goals mable agent programming
language wooldridge et al actually imperative language augmented certain agent features bdi language work bordini et al
include failure handling general state art model checking agent system
implementations still limited quite small systems dennis fisher webster bordini

acknowledgements
would thank members department information science university
otago discussions relating would thank lin padgham
comments draft finally would thank anonymous
reviewers insightful comments helped improve
work done winikoff sabbatical rmit visiting
university otago

generating traces top level goal likely feasible
work deductive verification verification
concurrent systems appears less likely verification tools relatively
easy use applicable real systems



fion testability bdi agent systems

appendix example goal plan trees expansions
suppose following two trees sample left sample right trees
correspond j k sample sample
goal
plan


goal

plan

goal

b c

goal



plan

plan

plan

plan

plan

plan



b

e

f

g

h

trees expanded respectively following sequences actions
letter indicates execution action indicates failure predicted
formulae four successful executions two unsuccessful executions
first tree

b

b
b

b
b

second tree expansions following possibilities consisting
successful unsuccessful traces





















e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e

b
b cgd
b cgd
b cg hd
b cg hd
b cg h
b chd
b chd
b ch gd
b ch gd
b ch g
b c
fb
fb cgd
fb cgd
fb cg hd
fb cg hd
fb cg h
fb chd
fb chd






















f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f

b chd
b chd
b ch gd
b ch gd
b ch g
b c
eb
eb cgd
eb cgd
eb cg hd
eb cg hd
eb cg h
eb chd
eb chd
eb ch gd
eb ch gd
eb ch g
eb c
e cgd
e cgd

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g












h
h
h
h
h
h
h
h
h

aeb
aeb
ae fb
ae fb
ae f
afb
afb
af eb
af eb
af e


aeb
aeb
ae fb
ae fb
ae f
afb
afb
af eb

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h

afb
af eb
af eb
af e

gd
gd aeb
gd aeb
gd ae fb
gd ae fb
gd ae f
gd afb
gd afb
gd af eb
gd af eb
gd af e
gd
g aeb
g aeb
g ae fb

note failure marker isnt counted considering length trace section



fiwinikoff cranefield























e fb ch gd
e fb ch gd
e fb ch g
e fb c
e f cgd
e f cgd
e f cg hd
e f cg hd
e f cg h
e f chd
e f chd
e f ch gd
e f ch gd
e f ch g
e f c
fb
fb cgd
fb cgd
fb cg hd
fb cg hd
fb cg h

af e cg hd
af e cg hd
af e cg h
af e chd
af e chd
af e ch gd
af e ch gd
af e ch g
af e c
cgd
cgd
cg hd
cg hd
cg h
chd
chd
ch gd
ch gd
ch g
c
cgd

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

g hd af eb
g hd af e
g hd
g h aeb
g h aeb
g h ae fb
g h ae fb
g h ae f
g h afb
g h afb
g h af eb
g h af eb
g h af e
g h
hd
hd aeb
hd aeb
hd ae fb
hd ae fb
hd ae f
hd afb

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

h g ae fb
h g ae f
h g afb
h g afb
h g af eb
h g af eb
h g af e
h g
aeb
aeb
ae fb
ae fb
ae f
afb
afb
af eb
af eb
af e


appendix b analysis recurrence relations
appendix contains details derivation section
exponential generating function f x sequence f j b
j function
defined following power series
f x


x

f j b

j

xj
j



definition f


j



j
x
x
x
x
x
xj
j
j

ai j b

ai j b

j

j
j



j



right hand side
changed upper limit inner sum
j
generalised definition j j j j valid

complex numbers j non zero integers wilf gives ji j
right hand side form product exponential generating functions wilf
rule section








j
j
x
x
x
x
x
x
j
xj

j
j
j
j
j

j
j

j

j



case j j aj j j b therefore write





j
j
x
x
ax
x
f x
j
jb
j
j
j

j



fion testability bdi agent systems

p

left hand sum g ax g n n
wilf equation

p
n
x
x


right hand sum equal bx dx
n wilf rule section bx dx e
x
wilf equation bxe thus
f x


bxex
bxex
ax
ax

p
xj

therefore f b constant term power series
j f j b j
f recurrence relation defining f j b equate original
definition f x equation closed form function differentiate
side give us power series f j b values shifted one position left
multiply denominator closed form giving us following derivation





x

bxex
xj
ax
ax
f j b
dx
j
dx ax
j



x
xj
b x ex
abxex

ax
f j b j
ax

j
ax
ax
j




x
j



bxex
xj x
xj

b x ex
f j b j
af j b j
j
j
ax


j



recall f b


x
x
xj
xj


f j b j

ajf j b
j
j
j

j

bxex bex


x

f j b

j

recall

bxex



j

equating coefficients

xj
j

xj
j jb j

j
x

ex

j

j

p


x
xj
b
j b
j

xj
j
xj
j j

p



x
xj
x

f j b
j
j

get

f j b ajf j b bj b af j b
f j b b j af j b ajf j b
j b af j b



note many operations performed generating functions used
valid without concern convergence series combinatorics generating functions often
treated analytic functions evaluated specific variable values rather formal possibly
infinite algebraic objects well defined operations addition multiplication
set formal power series finite set variables structure ring abstract algebra
ring notion function convergence evaluation wilf ch



fiwinikoff cranefield

appendix c analysis recursive goal plan trees
appendix contains detailed derivations relating section

c derivation f
goal p x b

define f
goal p x b terms n usual way noting upper
bound realise length bound


f
goal p x b

x

x

n goal p n b xm n

n


n goal p n b defined section make use nonbounded version four arguments

f
goal p x b

x

x

n goal p n b xm n

n


define n counting successful traces
n goal p n b
x

p p

x

n p n b n p p n b


n n n

pset p

n p n b number unsuccessful paths zero plans
plan multiset p respect binding b actions n
failed actions
inner sum considers ways partition numbers actions action
failures n caused single plan shape p p
p
caused


plans


section

page


use

identity

p q f p q
p p
p
q f p q rewrite

f
goal p x b
x

x
x
x

p p
n p n b n p p n b xm n


n n n

n pset p

x



p p

pset p

x

x

x

n p n b n p p n b xm n

n
n n n

give us

f
goal p x b
x

p p

pset p


x
x

x

x

n p n b xm n n p p n b xm n

n n



fion testability bdi agent systems



x

p p

pset p
x

x



n p n b x





n p p n b xm n

n

n

x

x

x

n





p p f p x b f p p x b

pset p

f
p x b generating function n p n b section c

provide definition f
p x b terms auxiliary function g see section c
introduce bound length paths giving

f
goal p x b
x
x



p p f
p x b f
p p x b

pset p



x

x



p p f
p x b f
p p x b

pset p

c derivation f
goal p x b

similarly previous derivation define

f
goal p x b

x

x

n goal p n b xm n

n

goal p terms plans p
derive recursive definition f

first define function n p n b denotes number unsuccessful
paths use plans multiset p

n goal p n b n p n p b
states goal fail p plans multiset must tried
define generating function g p x z b n p n b ordinary x exponential z e coefficients xm n z values
n p n b


f
goal p x b

x

x

n p n p b xm n

n

wish rewrite terms g generalising right hand side
sum possible values number plans used followed restriction
select values p



fiwinikoff cranefield


f
goal p x b

p

x

x
n p n p b z p


p z p

xm n

n

x
p


x
n p n b z power z p
p
xm n
p
z
n



p
p

p p

n

n
n p n b x z



power z p

z p

since nested sum definition g see section c simplify


f goal p x b p

g p x z b power z p
z p


section c derive definition g p terms f
p p
set p


c definition f
p x b

recall n p n b number unsuccessful paths zero
plans plan multiset p respect binding b actions n

failed actions f
p x b ordinary generating function
first consider case p empty case precisely one way

fail generates trace length zero therefore f
x b x
case p non empty sum number plans used
execution yields following definition
p


n p n b

x

n p n b



n p n b number unsuccessful paths plan

multiset
plans therefore definition f
p x b
p pp



n
n
p


n

b x





n

f
p x b




x
p
x
x

n p n b xm n

n

replace n looking coefficient corresponding term g
accounts division g reorder summations
p



x

x x

xm n z g p x z b xm n

n



fion testability bdi agent systems

shift outwards multiply z z
p
p p
n

n
x
n x z g p x z b x z



zo


p



x




g p x z b power z
zo

c definition g p x z b
define g p x z b generating function n p n b ordinary x exponential z hence division
maximum allowed trace length
g p x z b

x
x

x

n p n b

n

xm n z


recall n p n b denotes number unsuccessful paths use
plans multiset p empty multiset plans successful execution
single unsuccessful execution actions uses plans hence

n

n n b
otherwise
therefore g x z b non empty multisets must partition actions
trace action failures numbers plans used across different plan bodies
multiset consider ways plans plan shapes
interleaved give overall order attempting plans
n p c pj cj n b
x

n p c n b n pj cj mj nj oj b
mj
n nj n
oj

multinomial coefficient
thus


oj






oj

g p c pj cj x z b
definition g restriction rather bounded sum
expanding n



x
x


n p c n b






j

n



j

n nj n
oj

xm n z
n pj cj mj nj oj b






power x

fiwinikoff cranefield




x

x


n p c n b








j


n mj
n nj n
oj

xm n z
n pj cj mj nj oj b



power x

cancelling distributing oi xmi ni z oi



x

x

n p c n b

n mj
n nj n
oj

xm n z


xmj nj z oj
n pj cj mj nj oj b
oj





replacing


x

x









x



x
x

redistributing sums



n p c n b

xm n z

n




x



power x






n pj cj mj nj oj b

xmj nj z oj

mj nj oj

oj


power x

x

replacing restriction




n

x



x z x

n p c n b


n




n

x
j
j
j
x
x z

n pj cj mj nj oj b
oj
mj nj oj



definition g
x

x

g p c x z b g pj cj x z b

need define g pi ci x z b
consider n p c n b simple cases use
plans single unsuccessful
path actions n

c
hand oc co
ways selecting c available
copies plan p selected plans executed different orders
execution sum possible distributions actions successful unsuccessful


fion testability bdi agent systems

amongst plans gives

x
c



n p n b n p mo b




mo
n n
n p c n b



n




otherwise



therefore following definition g p c x z b initial abbreviates x z e base case n rest
definition g expanding n definition
g p c x z b




x
c





x

x

n p n b n p mo b

mo
n n

n

xm n z


cancel rearrange sums replace upper bound
restriction





x
x
x
x

c



n



n p n b n p mo b x

power x z



n
mo
n n


x

replacing

x









x
x

redistributing sums




x
c



x

x


n p n b xm n



n

x

x


n p mo b xmo

mo


power x z

x
x

x
c

n p n b xm n
power x z

n

xx

replace
n p n b xm n f
p x b per definition


n

c
x
c

f p x b power x z


c
x
c
f p x b ox z






fiwinikoff cranefield

appendix analysis procedural code structures
seek derive expression largest possible number paths program
given size e definition n max n p p recall
program atomic statement single path e n sequence
two programs p p n p p n p n p conditional p p
n p p n p n p
relatively easy see examining possible programs
n instance largest number paths obtained program
easy largest number paths possible
larger values observe program
largest number paths follows particular form program
largest path written p n p
generally define following
shows programs maximal number paths size
considered particular form
theorem program size largest possible number
paths written pi pi pi pik pij j k

proof establish induction assume holds n
n must hold let us assume
program pm maximal number paths form
j


k
pm
pm
pm
pm
two cases depending
structure pm consider case turn fact
pm rewritten desired form preserving number paths
program size b pm cannot maximal since construct program size
larger number paths pm
j


k
case pm form pm
pm
pm
least one pm
neither

let pm one sub programs neither convenience

define p shorthand pm
since p size less induction
hypothesis applies written form pi pi pil pij
easy see one rewrite pm desired form
exploiting associativity rewriting follows




pm
pi pi pij pm
pm
pi pi pij pm


applying rewriting pm
yields program size
number paths original program desired form
sequence sub programs shows holds
e maximal path program written desired form


k
case pm form pm
pm
pm
k means

k
pm must consist single conditional e pm pm pm
k

fact one maximal path program structure modulo
swapping order arguments
size written maximal number paths program
size meets desired form



fion testability bdi agent systems



without loss generality view pm form pm
pm
viewing

k

k
pm pm pm pm k consider following


sub cases depending values n pm
n pm



case n pm
n pm
greater pm



maximal consider program pm
pm
pm
e replaced




know n pm pm n pm n pm
without loss gen

erality lets assume n pm n pm original pm


fewer paths pm
number paths pm n pm n pm






n pm since n pm n pm n pm n pm n pm





n pm
n pm
n pm
since n pm
n pm
greater




n pm n pm n pm n pm
e

pm paths pm hence pm maximal


case b least one n pm
n pm
greater without loss



generality assume n pm n pm
two cases n pm




sub case b let us consider first case n pm
program one path statement sequence statements
clearly latter maximal since replacing would
program size paths therefore pm



maximal pm
must pm pm
therefore pm

size two sub cases still greater
second sub case simple inspecting possible

programs size n therefore n pm

however know size paths
hence sub case pm cannot maximal number paths
first sub case still greater induction hypothesis applies


written desired form abbreviate pm

therefore pm
j



p pm p p p p

consider variant program pm
p p p j

clearly size pm pm
paths
j




pm n pm n p n p p n p p j n p
n p p j n pm n p n p p j order

n pm n pm
need n p p j
follows fact must least one p since p
size least



sub case b ii know n pm
n pm
since n pm




n pm n pm hence n pm n pm



n pm
n pm
n pm
strictly greater

n pm strictly less n pm shown pm actually

maximal number paths hand n pm


n pm n pm however values
theorem applies know n therefore
shown sub case pm maximal



fiwinikoff cranefield

shown assume pm maximal structure
specified fact one derive another program size
satisfy desired structure larger number paths pm contradicts assumption pm maximal establishes desired property pm
induction applies desired
previous shows considering programs given size
largest possible number paths denoted pm limit considering
programs form p p pkm pim
derive definition n firstly observe inspecting cases
n
n
n
two first cases discussed last case two programs
appropriate structure size paths
paths
consider adding statement program e going
effect modifies pm adding one pim increments n pim one
since multiplication commutative associative without loss generality assume
n p
increment n pkm therefore n pm n p pk
k



n pm n p pk n pk two cases
therefore
case pim n pm n p pk
n p note case p
n pm n p pk





written p pk

case pim observe replacing gives
greater increase number paths replacing hence

possibly reordering pim pkm n pm n p pk



n pm n p pk n pm
therefore recursive definition n depending form pm next
observe fact form pm follows simple cycle know case
holds p therefore p written hence
p written hence p written
generally prove induction pm written p pkm
following holds multiple pim b
one multiple exactly two pim rest
c two multiple exactly one pim rest
gives us following recursive definition multiple
n n




n n





fion testability bdi agent systems

n n




simplified



n n
n


n
n n

n n

easily derive non recursive definition focusing last case observing
n n n multiple
n substitute definition obtain
following complete definition n multiple
n
n
n
n
n
n

n


n



fiwinikoff cranefield

references
benfield hendrickson j galanti making strong business case
multiagent technology stone p weiss g eds proceedings fifth international joint conference autonomous agents multiagent systems aamas
pp acm press
bordini r h fisher pardavila c wooldridge model checking agentspeak proceedings second international joint conference autonomous
agents multiagent systems aamas pp acm press
bordini r h hubner j f wooldridge programming multi agent systems
agentspeak jason wiley
bratman e israel j pollack e plans resource bounded practical
reasoning computational intelligence
bratman e intentions plans practical reason harvard university press
cambridge
burch j clarke e mcmillan k dill hwang j symbolic model checking
states beyond information computation
burmeister b arnold copaciu f rimassa g bdi agents agile goaloriented business processes proceedings seventh international conference
autonomous agents multiagent systems aamas industry track pp
ifaamas
busetta p ronnquist r hodgson lucas jack intelligent agents components intelligent agents java agentlink news
dastani apl practical agent programming language autonomous agents
multi agent systems
dastani hindriks k v meyer j j c eds specification verification
multi agent systems springer berlin heidelberg
de silva l padgham l comparison bdi real time reasoning
htn webb g yu x eds ai advances artificial
intelligence vol lecture notes computer science pp springer
berlin heidelberg
dennis l fisher webster p bordini r h model checking agent
programming languages automated software engineering
dinverno kinny luck wooldridge formal specification
dmars singh rao wooldridge eds intelligent agents iv
proceedings fourth international workshop agent theories architectures
languages vol lecture notes artificial intelligence pp
berlin heidelberg springer
dorigo stutzle ant colony optimization mit press
dwyer b hatcliff j pasareanu c robby visser w formal software analysis emerging trends software model checking future software engineering
pp los alamitos ca ieee computer society


fion testability bdi agent systems

ekinci e e tiryaki cetin dikenelli goal oriented agent testing
revisited luck gomez sanz j j eds agent oriented software engineering ix vol lecture notes computer science pp berlin heidelberg springer
erol k hendler j nau complexity htn annals
mathematics artificial intelligence
erol k hendler j nau htn complexity expressivity
proceedings th national conference artificial intelligence aaai pp
aaai press
fix l grumberg heyman heyman schuster verifying
large industrial circuits processes beyond peled tsay k eds automated technology verification analysis vol lecture
notes computer science pp berlin heidelberg springer
georgeff p lansky l procedural knowledge proceedings ieee
special issue knowledge representation
gomez sanz j j bota j serrano e pavon j testing debugging
mas interactions ingenias luck gomez sanz j j eds agentoriented software engineering ix vol lecture notes computer science
pp berlin heidelberg springer
huber j jam bdi theoretic mobile agent architecture proceedings
third international conference autonomous agents agents pp
acm press
ingrand f f georgeff p rao architecture real time reasoning
system control ieee expert
jorgensen p software testing craftsmans second edition crc
press
lee j huber j kenny p g durfee e h um prs implementation procedural reasoning system multirobot applications proceedings conference intelligent robotics field factory service space
cirffss pp american institute aeronautics astronautics
mathur p foundations software testing pearson
miller j c maloney c j systematic mistake analysis digital computer
programs communications acm
morley myers k spark agent framework proceedings
third international joint conference autonomous agents multiagent systems
aamas pp york acm
munroe miller belecheanu r pechoucek mcburney p luck
crossing agent technology chasm experiences challenges commercial applications agents knowledge engineering review


fiwinikoff cranefield

naish l resource oriented deadlock analysis dahl v niemela eds
proceedings rd international conference logic programming vol
lecture notes computer science pp springer berlin heidelberg
nguyen c miles perini tonella p harman luck evolutionary testing autonomous software agents proceedings th international
conference autonomous agents multiagent systems aamas pp
ifaamas
nguyen c perini tonella p b experimental evaluation ontology
test generation multi agent systems luck gomez sanz j j eds
agent oriented software engineering ix vol lecture notes computer
science pp berlin heidelberg springer
nguyen c perini tonella p automated continuous testing multiagent systems proceedings fifth european workshop multi agent systems
eumas
padgham l winikoff developing intelligent agent systems practical
guide john wiley sons
paolucci shehory sycara k p kalp pannu component retsina agents jennings n r lesperance eds proceedings
th international workshop agent theories architectures languages
atal vol lecture notes computer science pp berlin heidelberg springer
pokahr braubach l lamersdorf w jadex bdi reasoning engine
bordini r h dastani dix j el fallah seghrouchni eds multi agent
programming languages platforms applications chap pp springer
raimondi f lomuscio automatic verification multi agent systems
model checking via ordered binary decision diagrams j applied logic

rao agentspeak l bdi agents speak logical computable language
de velde w v perrame j eds agents breaking away proceedings
seventh european workshop modelling autonomous agents multi agent
world maamaw vol lecture notes artificial intelligence pp
berlin heidelberg springer
rao georgeff p modeling rational agents within bdi architecture
allen j fikes r sandewall e eds proceedings second international
conference principles knowledge representation reasoning pp
morgan kaufmann
sardina padgham l bdi agent programming language failure handling declarative goals autonomous agents multi agent systems

shaw p farwer b bordini r theoretical experimental
goal plan tree proceedings seventh international conference
autonomous agents multiagent systems aamas pp ifaamas


fion testability bdi agent systems

sloane n j line encyclopedia integer sequences http www
att com njas sequences
thangarajah j winikoff padgham l fischer k avoiding resource
conflicts intelligent agents van harmelen f ed proceedings th
european conference artificial intelligence ecai pp ios press
van riemsdijk b dastani winikoff goals agent systems
unifying framework proceedings seventh conference autonomous agents
multiagent systems aamas pp ifaamas
wilf h generatingfunctionology second edition academic press inc boston
http www math upenn edu wilf gfology pdf
winikoff assurance agent systems role formal verification
play dastani hindriks k v meyer j j c eds specification
verification multi agent systems chap pp springer berlin heidelberg
winikoff padgham l harland j thangarajah j declarative procedural goals intelligent agent systems proceedings eighth international
conference principles knowledge representation reasoning kr pp
toulouse france morgan kaufmann
wooldridge introduction multiagent systems john wiley sons
chichester england
wooldridge fisher huget p parsons model checking multi agent
systems mable proceedings first international joint conference
autonomous agents multi agent systems aamas pp acm press
zhang z thangarajah j padgham l model testing agent systems
filipe j shishkov b helfert maciaszek l eds software data
technologies vol communications computer information science pp
berlin heidelberg springer
zhu h hall p v may j h r software unit test coverage adequacy
acm computing surveys




