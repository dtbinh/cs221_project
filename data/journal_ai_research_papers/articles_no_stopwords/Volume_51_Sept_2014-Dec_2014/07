Journal Artificial Intelligence Research 51 (2014) 829-866

Submitted 06/14; published 12/14

Exact Double-Oracle Algorithm Zero-Sum
Extensive-Form Games Imperfect Information
Branislav Bosansky

branislav.bosansky@agents.fel.cvut.cz

Agent Technology Center
Department Computer Science
Faculty Electrical Engineering
Czech Technical University Prague

Christopher Kiekintveld

cdkiekintveld@utep.edu

Computer Science Department
University Texas El Paso, USA

Viliam Lisy
Michal Pechoucek

viliam.lisy@agents.fel.cvut.cz
michal.pechoucek@agents.fel.cvut.cz

Agent Technology Center
Department Computer Science
Faculty Electrical Engineering
Czech Technical University Prague

Abstract
Developing scalable solution algorithms one central problems computational
game theory. present iterative algorithm computing exact Nash equilibrium
two-player zero-sum extensive-form games imperfect information. approach
combines two key elements: (1) compact sequence-form representation extensiveform games (2) algorithmic framework double-oracle methods. main idea
algorithm restrict game allowing players play selected sequences
available actions. solving restricted game, new sequences added finding
best responses current solution using fast algorithms.
experimentally evaluate algorithm set games inspired patrolling
scenarios, board, card games. results show significant runtime improvements
games admitting equilibrium small support, substantial improvement memory use even games large support. improvement memory use particularly
important allows algorithm solve much larger game instances existing
linear programming methods.
main contributions include (1) generic sequence-form double-oracle algorithm
solving zero-sum extensive-form games; (2) fast methods maintaining valid restricted
game model adding new sequences; (3) search algorithm pruning methods
computing best-response sequences; (4) theoretical guarantees convergence
algorithm Nash equilibrium; (5) experimental analysis algorithm several
games, including approximate version algorithm.

1. Introduction
Game theory widely used methodology analyzing multi-agent systems applying
formal mathematical models solution concepts. One focus computational game theory development scalable algorithms reasoning large games.
c
2014
AI Access Foundation. rights reserved.

fiBosansky, Kiekintveld, Lisy, & Pechoucek

need continued algorithmic advances driven growing number applications
game theory require solving large game instances. example, several decision
support systems recently deployed homeland security domains recommend
policies based game-theoretic models placing checkpoints airports (Pita, Jain,
Western, Portway, Tambe, Ordonez, Kraus, & Parachuri, 2008), scheduling Federal Air
Marshals (Tsai, Rathi, Kiekintveld, Ordonez, & Tambe, 2009), patrolling ports (Shieh,
An, Yang, Tambe, Baldwin, Direnzo, Meyer, Baldwin, Maule, & Meyer, 2012). capabilities systems based large amount research fast algorithms
security games (Tambe, 2011). Another notable example algorithmic progress
led game-theoretic Poker agents competitive highly skilled human
opponents (e.g., see Zinkevich, Bowling, & Burch, 2007; Sandholm, 2010).
focus developing new algorithms important general class games
includes security games Poker, well many familiar games. precisely,
study two-player zero-sum extensive-form games (EFGs) imperfect information.
class games captures sequential interactions two strictly competitive players
situations make decisions uncertainty. Uncertainty caused either
stochastic environment opponent actions directly
observable. consider general models sequential interactions uncertainty,
many fast algorithms developed Poker security domains
rely specific game structure.
propose new class algorithms finding exact (or approximate) Nash equilibrium solutions class EFGs imperfect information. leading exact
algorithm literature uses compact sequence-form representation linear programming optimization techniques solve games type (Koller, Megiddo, & von
Stengel, 1996; von Stengel, 1996). approach exploits compact representation, improve solution methods adopting algorithmic framework based
decompositions known computational game theory literature oracle algorithms
(McMahan, Gordon, & Blum, 2003). Oracle algorithms related methods constraint/column generation used solving large-scale optimization problems (Dantzig &
Wolfe, 1960; Barnhart, Johnson, Nemhauser, Savelsbergh, & Vance, 1998) exploit two
characteristics commonly found games. First, many cases finding solution
game requires using small fraction possible strategies, necessary
enumerate strategies find solution (Wilson, 1972; Koller & Megiddo, 1996).
Second, finding best response specific opponent strategy game computationally
much less expensive solving equilibrium. addition, best response algorithms
often make use domain-specific knowledge heuristics speed calculations
even further.
sequence-form double-oracle algorithm integrates decomposition ideas oracle
algorithms compact sequence-form representation EFGs imperfect information. results iterative algorithm always need generate
complete linear program game find Nash equilibrium solution. main idea
algorithm create restricted game players choose limited
space possible strategies (represented sequences actions). algorithm solves
restricted game uses fast best-response algorithm find strategies
original unrestricted game perform well current solution restricted
830

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

game. strategies added restricted game process iterates
best response found improve solution. case, current solution
equilibrium original game. Typically, solution found adding small
fraction strategies restricted game.
begin presenting related work, technical background, notation.
describe main algorithm three parts: (1) methods creating, solving, expanding valid restricted game, (2) algorithm finding best-response strategies
added restricted game, (3) variants main loop controlling iterative
process solving restricted games adding new strategies. present formal analysis
prove algorithm converges Nash equilibrium original game. Finally, provide experimental evaluation runtime performance convergence
behavior algorithm several realistic games different characteristics including
border patrolling scenario, Phantom Tic-Tac-Toe, simplified variant Poker.
compare results state-of-the-art algorithms finding exact approximate solutions: linear programming using sequence form, Counterfactual Regret
Minimization (CFR, Zinkevich, Johanson, Bowling, & Piccione, 2008; Lanctot, 2013).
experimental results confirm algorithm requires fraction possible sequences solve game practice significantly reduces memory requirements
solving large games. advances state art allows us exactly solve
much larger games compared existing algorithms. Moreover, games admitting
equilibrium small support (i.e., sequences non-zero probability
equilibrium), algorithm achieves significant improvements computation time
finds equilibrium iterations. result hold without using
domain-specific knowledge, show incorporating domain-specific heuristics
bounds algorithm straightforward way lead even significant
performance improvements. Analysis convergence rate shows approximative
bounds value game either similar bit worse early stages
compared CFR. However, convergence behavior CFR algorithm long
tail algorithm always finds exact solution much faster CFR.

2. Related Work
Solving imperfect-information EFGs computationally challenging task, primarily due
uncertainty actions opponent and/or stochastic environment.
leading exact algorithm (Koller et al., 1996; von Stengel, 1996) based formulating
problem finding optimal strategy play linear program. algorithm exploits
compact representation strategies sequences individual actions (called sequence
form) results linear program linear size size game tree. However,
approach limited applicability since game tree grows exponentially
number sequential actions game. common practice overcoming limited
scalability sequence-form linear programming use approximation method.
best known approximative algorithms include counterfactual regret minimization (CFR,
Zinkevich et al., 2008), improved versions CFR sampling methods (Lanctot, Waugh,
Zinkevich, & Bowling, 2009; Gibson, Lanctot, Burch, Szafron, & Bowling, 2012); Nesterovs
Excessive Gap Technique (EGT, Hoda, Gilpin, Pena, & Sandholm, 2010); variants
831

fiBosansky, Kiekintveld, Lisy, & Pechoucek

Monte Carlo Tree Search (MCTS) algorithms applied imperfect-information games (e.g.,
see Ponsen, de Jong, & Lanctot, 2011).
family counterfactual regret minimization algorithms based learning methods informally described follows. algorithm repeatedly traverses
game tree learns strategy play applying no-regret learning rule minimizes specific variant regret (counterfactual regret) information set.
no-regret learning converges optimal strategy information set. overall
regret bounded sum regret information set; hence, strategy
whole converges Nash equilibrium. main benefits approach include
simplicity robustness, adapted generic games (e.g., see Lanctot,
Gibson, Burch, Zinkevich, & Bowling, 2012, CFR applied games imperfect
recall). However, algorithm operates complete game tree therefore requires
convergence information sets, slow large games one desires
solution small error.
Another popular method Excessive Gap Technique exploits convex properties
sequence-form representation uses recent mathematical results finding extreme
points smooth functions (see Hoda et al., 2010, details). main idea approximate problem finding pair equilibrium strategies two smoothed functions
guiding find approximate solution. Although approach achieves faster
convergence comparison CFR, algorithm less robust (it known whether
similar approach used general classes games) less used practice.
CFR, EGT operates complete strategy space sequences.
Monte Carlo Tree Search (MCTS) another family methods shown promise
solving large games, particular perfect information board games Go (e.g.,
Lee et al., 2009). CFR EGT algorithms guaranteed find -Nash
equilibrium, convergence equilibrium solution formally shown
variants MCTS imperfect-information games. contrary, common
version MCTS based Upper Confidence Bounds (UCB) selection function
converge incorrect solutions even simultaneous-move games (Shafiei, Sturtevant, &
Schaeffer, 2009) simplest class imperfect-information EFGs. MCTS algorithms therefore (in general) guarantee finding (approximate) optimal solution
imperfect-information games. One exception recent proof convergence MCTS
certain selection methods simultaneous-move games (Lisy, Kovarik, Lanctot, &
Bosansky, 2013). Still, using MCTS sometimes reasonable choice since produce
good strategies practice (Ponsen et al., 2011).
Contrary existing approximative approaches, algorithm aims find exact solution without explicitly considering strategy complete game tree.
work combines compact sequence-form representation double-oracle algorithmic framework. Previous work double-oracle framework focused primarily
applications normal-form games, restricted game expanded adding pure
best-response strategies iteration. One first examples solving games using
double-oracle principle McMahan et al. (2003). introduced doubleoracle algorithm, proved convergence Nash equilibrium, experimentally verified
algorithm achieves computation time improvements search game
evader trying cross environment without detected sensors placed
832

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

opponent. double-oracle algorithm reduced computation time several hours
tens seconds allowed solve much larger instances game. Similar success
domain-specific double-oracle methods demonstrated variety different domains inspired pursuit-evasion games (Halvorson, Conitzer, & Parr, 2009)
security games played graph (Jain, Korzhyk, Vanek, Conitzer, Tambe, & Pechoucek,
2011; Letchford & Vorobeychik, 2013; Jain, Conitzer, & Tambe, 2013).
works tried apply iterative framework oracle algorithms
EFGs, primarily using pure mixed strategies EFGs. first work exploited
iterative principle predecessor sequence-form linear-program formulation (Koller
& Megiddo, 1992). algorithm, authors use representation similar sequence form single player, strategies opponent iteratively
added constraints linear program (there exponential number constraints
formulation). approach seen specific variant oracle algorithms, strategy space expanded gradually single player. algorithm
generalization work, since algorithm uses sequence-form representation
players incrementally expands strategy space players.
recent work done McMahan thesis (McMahan, 2006) followup work (McMahan & Gordon, 2007). works authors investigated extension
double-oracle algorithm normal-form games extensive-form case.
double-oracle algorithm EFGs operates similarly normal-form variant
uses pure mixed strategies defined EFGs. main disadvantage approach
basic version still requires large amount memory since pure strategy
EFG large (one action needs specified information set),
exponential number possible pure strategies. overcome disadvantage,
authors propose modification double-oracle algorithm keeps number
strategies restricted game bounded. algorithm removes restricted game
strategies least used current solution restricted game.
order guarantee convergence, algorithm adds iteration restricted
game mixed strategy representing mean removed strategies; convergence
guaranteed similarly fictitious play (see McMahan & Gordon, 2007, details).
Bounding size restricted game results low memory requirements. However,
algorithm converges extremely slowly take long time (several hours
small game) algorithm achieve small error (see experimental evaluation
McMahan, 2006; McMahan & Gordon, 2007).
similar concept using pure strategies EFGs used iterative algorithm
designed Poker work Zinkevich et al. (2007). algorithm work
expands restricted game strategies found generalized best response instead
using pure best response strategies. Generalized best response Nash equilibrium
partially restricted game player computing best response use pure
strategies original unrestricted game, opponent restricted use
strategies restricted game. However, main disadvantages using pure
mixed strategies EFGs still present result large memory requirements
exponential number iterations.
contrast, algorithm directly uses compact sequence-form representation
EFGs uses sequences building blocks (i.e., restricted game expanded
833

fiBosansky, Kiekintveld, Lisy, & Pechoucek

allowing new sequences played next iteration). Using sequences
sequence form solving restricted game reduces size restricted game
number iterations, however, introduces new challenges constructing
maintaining restricted game, ensuring convergence Nash equilibrium,
must solve algorithm converge correct solution.

3. Technical Background
begin presenting standard game-theoretic model extensive-form games, followed discussion common solution concepts algorithms computing solutions. present sequence-form representation state-of-theart linear program computing solutions using representation. Finally, describe
oracle algorithms used solving normal-form games. summary
common notation provided Table 1 quick reference.
3.1 Extensive-Form Games
Extensive-form games (EFGs) model sequential interactions players game.
Games extensive form visually represented game trees (e.g., see Figure 2).
Nodes game tree represent states game; state game corresponds
sequence moves executed players game. node assigned player
acts game state associated node. edge game tree
node corresponds action performed player acts node.
Extensive-form games model limited observations players grouping nodes
information sets, given player cannot distinguish nodes belong
information set player choosing action. model represents
uncertainty environment stochastic events using special Nature player.
Formally, two-player EFG defined tuple G = (N, H, Z, A, p, u, C, I): N set
two players N = {1, 2}. use refer one two players (either 1 2),
refer opponent i. H denotes finite set nodes game tree. node
corresponds unique history actions taken players Nature root
game; hence, use terms history node interchangeably. denote Z H
set terminal nodes game. denotes set actions overload
notation use A(h) represent set actions available player acting
node h H. specify ha = h0 H node h0 reached node h executing
action A(h). say h prefix h0 denote h v h0 . terminal
node z Z define utility function player (ui : Z R). study zero-sum
games, ui (z) = ui (z) holds z Z.
function p : H N {c} assigns node player takes action
node, c means Nature player selects action node based fixed
probability distribution known players. use function C : H [0, 1] denote
probability reaching node h due Nature (i.e., assuming players play
required actions reach node h). value C(h) product probabilities
assigned actions taken Nature player history h. Imperfect observation
player modeled via information sets Ii form partition nodes assigned
player {h H : p(h) = i}. Every information set contains least one node
834

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

node belongs exactly one information set. Nodes information set player
indistinguishable player. nodes h single information set Ii Ii
set possible actions A(h). Action A(h) uniquely identifies information set
Ii cannot exist node h0 H belong information set
Ii allowed played (i.e., A(h0 )). Therefore overload notation
use A(Ii ) denote set actions defined node h information set.
assume perfect recall, means players perfectly remember actions
information gained course game. result, nodes
information set Ii history actions player i.
3.2 Nash Equilibrium Extensive-Form Games
Solving game requires finding strategy profile (i.e., one strategy player)
satisfies conditions defined specific solution concept. Nash equilibrium (NE)
best known solution concept game theory describes behavior players
certain assumptions rationality. Nash equilibrium, every player plays
best response strategies players. Let set pure strategies
player i. EFGs, pure strategy assignment exactly one action played
information set. mixed strategy probability distribution set pure
strategies player. denote set mixed strategies player i.
pair strategies = (1 , 2 ) use ui () = ui (i , ) expected outcome
game player players follow strategies . best response player
opponents strategy strategy iBR , ui (iBR , ) ui (i0 , )
strategies i0 . strategy profile = (1 , 2 ) NE player
holds best response . game multiple NEs; zero-sum
setting, equilibria value (i.e., expected utility every player
same). called value game, denoted V . problem finding
NE zero-sum game polynomial computational complexity size game.
NE solution concept somewhat weak extensive-form games. Nash equilibrium
requires players act rationally. However, irrational strategies selected
parts game tree reachable players follow NE
strategies (these parts said equilibrium path). reason NE
expect part game played therefore sufficiently restrict
strategies information sets. overcome drawbacks, number refinements
NE introduced imposing restrictions intention describing
sensible strategies. Examples include subgame-perfect equilibrium (Selten, 1965) used
perfect-information EFGs. subgame-perfect equilibrium forces strategy profile
Nash equilibrium sub-game (i.e., sub-tree rooted node h)
original game. Unfortunately, sub-games particularly useful imperfectinformation EFGs; hence, refinements include strategic-from perfect equilibrium
(Selten, 1975), sequential equilibrium (Kreps & Wilson, 1982), quasi-perfect equilibrium
(van Damme, 1984; Miltersen & Srensen, 2010). first refinement avoids using weakly
dominated strategies equilibrium strategies two-player games (van Damme, 1991,
p. 29) known undominated equilibrium. Sequential equilibrium tries
exploit mistakes opponent using notion beliefs consistent
835

fiBosansky, Kiekintveld, Lisy, & Pechoucek

strategy opponent even information sets equilibrium path. main
intuitions behind first two refinements combined quasi-perfect equilibrium.
Even though solution described NE always prescribe rational strategies
equilibrium path, still valuable compute exact NE large extensive-form
games several reasons. focus zero-sum games, NE strategy guarantees
value game even equilibrium path. words, strategy
equilibrium path optimally exploit mistakes opponent, still
guarantees outcome least value gained following equilibrium path. Moreover,
refined equilibrium still NE calculating value game often starting
point many algorithms compute refinements example used
computing undominated equilibrium (e.g., see Ganzfried & Sandholm, 2013; Cermak,
Bosansky, & Lisy, 2014) normal-form proper equilibrium (Miltersen & Srensen, 2008).
3.3 Sequence-Form Linear Program
Extensive-form games perfect recall compactly represented using sequence
form (Koller et al., 1996; von Stengel, 1996). sequence ordered list actions taken
single player history h. number actions (i.e., length sequence )
denoted |i | empty sequence (i.e., sequence actions) denoted .
set possible sequences player denoted set sequences
players = 1 2 . sequence extended single action taken
player i, denoted = i0 (we use v i0 denote prefix i0 ). games
perfect recall, nodes information set Ii share sequence actions
player use seqi (Ii ) denote sequence. overload notation use
seqi (h) denote
leading node h, seqi (H 0 ) ,
sequence of0 actions player
0
0
seqi (H ) = h0 H 0 seqi (h ) H H. Since action uniquely identifies
information set Ii nodes information set share history actions
player i, sequence uniquely identifies information set. use function infi (i0 )
denote information set last action sequence i0 taken.
empty sequence, function infi () information set root node.
Finally, define auxiliary payoff function gi : R extends utility
function nodes game tree. payoff function gi represents expected
utility nodes reachable sequentially executing actions specified pair
sequences :
X
gi (i , ) =
ui (h) C(h)
(1)
hZ : jN j =seqj (h)

value payoff function defined 0 leaf reachable sequentially executing actions sequences either actions pair sequences
executed inner node (h H \ Z) reached, sequential execution actions node h reached, current action executed
sequence (h) defined (i.e.,
/ A(h)). Formally define pair sequences
compatible exists node h H sequence every player equals
seqi (h).
compute Nash equilibrium two-player zero-sum extensive-form game
using linear program (LP) polynomial size size game tree using
836

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

sequence form (Koller et al., 1996; von Stengel, 1996). LP uses equivalent compact
representation mixed strategies players form realization plans. realization
plan sequence probability player play sequence actions
assumption opponent choose compatible sequences actions
reach information sets actions specified sequence defined.
denote realization plan player ri : R. equilibrium realization plans
computed using following LP (e.g., see Shoham & Leyton-Brown, 2009, p. 135):

vinfi (i )

X

max vinfi ()
r,v
X
0
vIi

gi (i , ) ri (i )

0 :seq (I 0 )=
Ii








ri () = 1
X

(2)
(3)

ri (i a) = ri (i )

Ii Ii , = seqi (Ii )

(4)



(5)

aA(Ii )

ri (i ) 0

Solving LP yields realization plan player using variables ri , expected values
information sets player (variables vIi ). LP works follows: player
maximizes expected utility value selecting values variables realization plan constrained Equations (35). probability playing empty
sequence defined 1 (Equation 3), probability playing sequence
equal sum probabilities playing sequences extended exactly one action
(Equation 4). Finding realization plan constrained best responding
opponent, player i. ensured Equation (2), player selects
information set Ii action minimizes expected utility value vIi information set. one constraint defined sequence , last action
sequence determines best action played information set infi (i ) = Ii .
expected utility composed expected utilities information sets reachable
playing sequence (sum v variables left side) expected utilities
leafs sequence leads (sum g values right side constraint).
3.4 Double-Oracle Algorithm Normal-Form Games
describe concept column/constraint generation techniques applied previously
normal-form games known double-oracle algorithm (McMahan et al., 2003).
Normal-form games represented using game matrices; rows matrix correspond
pure strategies one player, columns correspond pure strategies opponent,
values matrix cells represent expected outcome game players
play corresponding pure strategies. Zero-sum normal-form games solved linear
programming polynomial time size matrix (e.g., see Shoham & LeytonBrown, 2009, p. 89).
Figure 1 shows visualization main structure double-oracle algorithm
normal-form games. algorithm consists following three steps repeat
convergence:
837

fiBosansky, Kiekintveld, Lisy, & Pechoucek

Figure 1: Schematic double-oracle algorithm normal-form game.
1. create restricted game limiting set pure strategies player
allowed play
2. compute pair Nash equilibrium strategies restricted game using LP
solving normal-form games
3. player, compute pure best response strategy equilibrium strategy
opponent found previous step; best response may pure strategy
original unrestricted game
best response strategies computed step 3 added restricted game, game
matrix expanded adding new rows columns, algorithm continues
next iteration. algorithm terminates neither players improve outcome
game adding new strategy restricted game. case players
play best response strategy opponent original unrestricted game.
algorithm maintains values expected utilities best-response strategies
throughout iterations algorithm. values provide bounds value
original unrestricted game V perspective player i, minimal value
past best-response calculations represents upper bound value
original game, ViU B , maximal value past best-response calculations
opponent represents lower bound value original game, ViLB . Note
bounds holds lower bound player equal negative value
upper bound opponent:
UB
ViLB = Vi

general, computing best responses computationally less demanding solving
game, since problem reduced single-player optimization. Due fact bestresponse algorithms operate quickly (e.g., exploiting additional domainspecific knowledge), called oracles context. algorithm incrementally
adds strategies one player, algorithm called single-oracle algorithm,
algorithm incrementally adds strategies players, algorithm called
double-oracle algorithm. Double-oracle algorithms typically initialized arbitrary
pair strategies (one pure strategy player). However, use larger set
initial strategies selected based domain-specific knowledge.
double-oracle algorithm zero-sum normal-form games runs polynomial time
size game matrix. Since iteration adds least one pure strategy
838

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

Figure 2: Example two-player extensive-form game visualized game tree. Circle
player aims maximize utility value, box aims minimize utility value. bold
edges represent sequences actions added restricted game.
restricted game finite pure strategies, algorithm stops
|i | + |i | iterations. iteration polynomial, since consists solving
linear program computing best responses. relative performance doubleoracle algorithm compared solving linear program original unrestricted game
closely depends number iterations required convergence. worst case,
algorithm adds pure strategies solves original game, although rarely
case practice. Estimating expected number iterations needed double-oracle
algorithm converge, however, remains open problem.
3.4.1 Towards Extensive-Form Games
straightforward method applying double-oracle algorithm EFGs use pure
strategies defined EFGs (i.e., assignments action information set, realization
plans) apply exactly algorithm described section i.e., iteratively add
pure strategies unrestricted extensive-form game restricted game matrix.
However, result exponential number iterations exponentially large
restricted game worst case. algorithm differs significantly idea since
directly operates (more compact) sequences instead full strategies.

4. Sequence-Form Double-Oracle Algorithm Extensive-Form Games
describe sequence-form double-oracle algorithm solving extensive-form
games imperfect information. First, give informal overview algorithm.
use example game depicted Figure 2 illustrate key concepts. Afterwards, formally define restricted game describe key components
algorithm, following full example run algorithm.
overall scheme algorithm based double-oracle framework described
previous section. main difference algorithm uses sequences define
restrictions game tree. restricted game model defined allowing
players use (i.e., play non-zero probability) subset sequences
original unrestricted game. restricted subset sequences defines subsets
reachable actions, nodes, information sets original game tree. Consider example Figure 2. restricted game defined sequences , A, AC, AD circle
player, , x box player. sequences represent actions allowed game,
839

fiBosansky, Kiekintveld, Lisy, & Pechoucek

define reachable nodes (using history reference , A, Ax, AxC, AxD),
reachable information sets (I1 , I2 circle player information set
box player).
algorithm iteratively adds new sequences allowed actions restricted
game, similarly double-oracle algorithm normal-form games. restricted game
solved standard zero-sum extensive-form game using sequence-form linear program. best response algorithm searches original unrestricted game find new
sequences add restricted game. sequences added, restricted
game tree expanded adding new actions, nodes, information sets
reachable based new sets allowed sequences. process solving restricted
game adding new sequences iterates new sequences improve solution
added.
two primary complications arise use sequences instead full
strategies double-oracle algorithm, due fact sequences necessarily define actions information sets: (1) strategy computed restricted game
may complete strategy original game, define behavior
information sets restricted game, (2) may possible
play every action sequence allowed restricted game, playing
sequence depend compatible sequence actions opponent.
example game tree Figure 2, strategy circle player restricted game
specifies play information sets I3 I4 . consequence second issue
inner nodes original unrestricted game (temporarily) become leafs
restricted game. example, box player add sequence restricted
game making node Ay leaf restricted game, since actions
circle player restricted game applicable node.
algorithm solves complications using two novel ideas. first idea
concept default pure strategy (denoted iDef ). Informally speaking, algorithm
assumes player fixed implicit behavior defines player
default information set part restricted game. described
default strategy iDef , specifies action every information set. Note
default strategy need represented explicitly (which could use large amount
memory). Instead, defined implicitly using rules, selecting first action
deterministic method generating ordered set actions A(h) node h.
use default pure strategies map every strategy restricted game valid
strategy full game. Specifically, strategy original unrestricted game selects
actions according probabilities specified strategy restricted game
every information set part restricted game, information sets
plays according default pure strategy. Recall example Figure 2,
pure default strategy circle player hA, C, E, Gi (i.e., selecting leftmost
action information set). Hence, strategy original unrestricted game use
strategy restricted game information sets I1 I2 , select pure actions
E, G information sets I3 I4 respectively.
second key idea use temporary utility values cases
allowed actions played node restricted game inner
node original game (so called temporary leaf ). ensure correct convergence
840

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

H
ZH
iDef
ri : 7 R
C : H 7 R
gi : H 7 R
seqi
infi : 7 Ii

game-tree nodes / histories
leafs / terminal states
implicit default pure strategy player
realization plan player sequence
probability reaching node due Nature play
extension utility function nodes;
gi (h) = ui (h) C(h) h Z gi (h) = 0 h terminal node (h
/ Z)
sequence(s) actions player leading node / set nodes /
/ information set
information set last action sequence executed

Table 1: outline main symbols used paper.

algorithm temporary utilities must assigned provide bound
expected value gained continuing play given node. algorithm uses
value corresponds expected outcome continuing game play, assuming
player making choice temporary leaf uses default strategy,
opponent plays best response. Assume add sequence box player
restricted game example tree Figure 2. temporary utility value node Ay
would correspond value 2, since default strategy information set I3 play E
circle player. next section formally describe method prove
correctness algorithm given temporary values.
describe detail key parts method. first formally define
restricted game methods expanding restricted game, including details
key ideas introduced above. describe algorithm selecting
new sequences allowed next iteration. decision sequences add
based calculating best response original unrestricted game using game-tree
search improved additional pruning techniques. Finally, discuss different variations
main logic double-oracle algorithm determines player(s)
algorithm adds new best-response sequences current iteration.
4.1 Restricted Game
section formally defines restricted game subset original unrestricted
game. restricted game fully specified set allowed sequences. define
sets nodes, actions, information sets subsets original unrestricted sets
based allowed sequences. denote original unrestricted game tuple
G = (N, H, Z, A, p, u, C, I) restricted game G0 = (N, H 0 , Z 0 , A0 , p, u0 , C, 0 ).
sets functions associated restricted game use prime notation; set
players, functions p C remain same.
restricted game defined set allowed sequences (denoted 0 )
returned best response algorithms. indicated above, even allowed sequence
0 might playable full length due missing compatible sequences
opponent. Therefore, restricted game defined using maximal compatible set
sequences 0 0 given set allowed sequences 0 . define 0 maximal
841

fiBosansky, Kiekintveld, Lisy, & Pechoucek

subset sequences 0 that:
0i {i 0i : 0i h H j N seqj (h) = j }

N

(6)

Equation (6) means player every sequence 0i , exists
compatible sequence opponent allows sequence executed full
(i.e., sequentially executing actions sequences node h
reached seqj (h) = j players j N ).
set sequences 0 fully defines restricted game, sets
tuple G0 derived 0 . node h restricted game
sequences must played reach h set 0 players:
H 0 {h H : N seqi (h) 0 }

(7)

pair sequences 0 , nodes reachable executing pair sequences
included H 0 . Actions defined node h restricted game
playing action node leads node restricted game:
A0 (h) {a A(h) : ha H 0 }

h H 0

(8)

Nodes restricted game corresponding inner nodes original unrestricted
game may inner nodes restricted game. Therefore, set leaves
restricted game union leaf nodes original game inner nodes
original game currently valid continuation restricted game, based
allowed sequences:

Z 0 Z H 0 {h H 0 \ Z : A0 (h) = }
(9)
explicitly differentiate leaves restricted game correspond leaves
original unrestricted game (i.e., Z 0 Z) leaves restricted game correspond
inner nodes original unrestricted game (i.e., Z 0 \ Z), since algorithm assigns
temporary utility values nodes latter case.
information sets restricted game correspond information sets original
unrestricted game. node h belongs information set Ip(h) original game,
holds restricted game. define information set part
restricted game least one inner node belongs information
set included restricted game:
Ii0 {Ii Ii : h Ii h H 0 \ Z 0 }

(10)

information set restricted game Ii Ii0 consists nodes
restricted game i.e., h Ii : h H 0 .
Finally, define modified utility function u0 restricted game. primary
reason modified utility function define temporary utility values leaves
set Z 0 \Z. Consider h Z 0 \Z temporary leaf player player acting
node (i = p(h)). Moreover, let ui (h) expected outcome game starting
node assuming players playing NE strategies original unrestricted
game. modified utility function u0i leaf must return value lower bound
842

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

value ui (h). Due zero-sum assumption, value represents upper bound
value opponent i. Setting value way ensures two things: (1) player
likely use sequences leading node h optimal strategies restricted game (since
modified utility value upper bound actual value), (2) player adds new
sequences using best-response algorithms prolong sequence seqi (h) leading node h
sequences would yield better expected value u0i . Later show
counterexample setting value otherwise cause algorithm converge
incorrect solution. calculate lower bound setting utility value
corresponds outcome original game player continues playing
BR default strategy.
default strategy iDef opponent plays best response
valid lower bound since consider single strategy player acting
node h, correspond default strategy; considering strategies could allow
player improve value continuing node h. leaf nodes
h Z 0 Z set u0i (h) ui (h).
4.1.1 Solving Restricted Game
restricted game defined section valid zero-sum extensive-form game
solved using sequence-form linear programming described Section 3.
algorithm computes NE restricted game solving pair linear programs using
restricted sets 0 , H 0 , Z 0 , 0 , modified utility function u0 .
strategy restricted game translated original game using
pure default strategy extend restricted strategy defined. Formally,
ri0 mixed strategy represented realization plan player restricted
game, define extended strategy r0i strategy identical strategy
restricted game sequences included restricted game, correspond
default strategy iDef sequence included restricted game:
(
ri0 (i )
0i
r0i (i )
(11)
ri0 (i0 ) iDef (i \ i0 )
/ 0i ; i0 = arg maxi00 0i ; i00 vi |i00 |
realization plan sequence allowed restricted game (i.e.,
/ 0i )
equal realization probability longest prefix sequence allowed
restricted game (denoted i0 ), setting remaining part sequence (i.e., \ i0 )
correspond default strategy player i. computation expressed
multiplication two probabilities, overload notation use iDef (i \ i0 )
1 remaining part sequence corresponds default strategy player i,
0 otherwise.
iteration double-oracle algorithm one sequence-form LP solved
player compute pair NE strategies restricted game. denote strategies
) (r , r ) extended original unrestricted game using
(ri , ri

default strategies.
4.1.2 Expanding Restricted Game
restricted game expanded adding new sequences set 0 updating
remaining sets according definition. adding new sequences, algorithm
843

fiBosansky, Kiekintveld, Lisy, & Pechoucek

calculates stores temporary utility values leaves Z 0 \ Z used
sequence-form LP.
updating restricted game, linear programs modified correspond new restricted game. newly added information sets sequences,
new variables created linear programs constraints corresponding
information sets/sequences created (Equations 2 4). Moreover, constraints already existing linear program need updated. sequence
added set 0i immediate prefix sequence (i.e., sequence i0 v
|i0 | + 1 = |i |) already part restricted game, need update
constraint information sets Ii i0 = seqi (Ii ) ensure consistency
strategies (Equation 4), constraint corresponding sequence i0 (Equation 2).
addition, algorithm updates Equations (2) assigned sequences opponent
g(i , ) 6= 0. Finally, algorithm updates constraints previously used
utilities temporary leaf nodes longer leaf nodes restricted game
adding new sequences.
New sequences player found using best response sequence (BRS) algorithms described Section 4.2. perspective sequence-form double-oracle
algorithm, BRS algorithm calculates pure best response player fixed
strategy opponent original unrestricted game. pure best response specifies
action play information set currently reachable given opponents
extended strategy ri . best response formally defined pure realization
plan riBR assigns integer values 0 1 sequences. realization plan
necessarily pure strategy original unrestricted game may
action specified every information set. Specifically, action specified
information sets reachable (1) due choices player i, (2) due
zero probability realization plan opponent ri . Omitting actions
affect value best response information sets never reached;
hence, riBR holds r0i ui (riBR , ri ) ui (r0i , ri ) exists pure best
response strategy iBR ui (riBR , ri ) = ui (iBR , ri ). sequences
used best-response pure realization plan probability 1 returned BRS
algorithm call best-response sequences:
{i : riBR (i ) = 1}

(12)

4.1.3 Example Run Algorithm
demonstrate sequence-form double-oracle algorithm example game depicted Figure 3a. example, two players: circle box. Circle aims
maximize utility value leafs, box aims minimize utility value. assume
choosing leftmost action information set default strategy
players game.
algorithm starts empty set allowed sequences restricted game
0 ; hence, algorithm sets current pair (ri , ri ) strategies equivalent
Def ). Next, algorithm adds new sequences correspond best response
(iDef ,
default strategy opponent; example best response sequences
circle player {, A, AD}, {, y} box player. sequences added
844

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

(a) Step 0

(b) Step 1

(d) Step 3

(c) Step 2

(e) Step 4

Figure 3: Example steps sequence-form double-oracle algorithm two-player
zero-sum game, circle player aims maximize utility value, box aims minimize
utility value. Bold edges correspond sequences actions added restricted
game. dashed boxes indicate information sets.
set allowed sequences 0 . Next, set sequences restricted game 0
updated. maximal compatible set sequences set 0 cannot contain sequence
AD compatible sequence box player (i.e., x case) allowed
restricted game yet sequence AD cannot fully executed. Moreover, adding
sequences y, restricted game contain node Ay actions E F
defined original unrestricted game. However, continuation
current restricted game yet; hence, node temporary leaf, belongs Z 0 \ Z,
algorithm needs define new value modified utility function u0 node.
value u0 (Ay) equal 2 corresponds outcome game circle
player continues playing default strategy box player plays best response.
complete first step algorithm summarize nodes information sets
included restricted game; H 0 contains 3 nodes (the root, node playing
action node Ay), two information sets (the information set node Ay
added restricted game, node leaf restricted game).
Playing sequences probability 1 Nash equilibrium restricted
game. situation depicted Figure 3b, sequences 0 shown bold edges.
algorithm proceeds complete list steps algorithm summarized Table 2. second iteration, new sequences B BH added
restricted game. box player add new sequences iteration
best response extended equilibrium strategy circle player i.e., playing
sequences A, AC, AE probability 1. NE updated restricted game changes
playing sequences B, BH sequence y, probability 1. third iteration
situation changes box player adds sequence x, new sequences
845

fiBosansky, Kiekintveld, Lisy, & Pechoucek

added circle player. adding sequence x, sequence AD becomes part
set 0 fully executed due adding compatible sequence x. NE
restricted game fully mixed, sequences starting B played
ratio 3 : 4, x ratio 4 : 3. fourth iteration, algorithm adds
sequence AF restricted game (the best response circle player), removes
assigned value u0 (Ay) since node longer belongs set Z 0 . algorithm stops
four iterations. sequences added restricted game, solution
) translated solution original unrestricted
restricted game (ri , ri


game, (ri , ri ) Nash equilibrium original game.
Iteration
1.
2.
3.
4.

BR
r
, A, AD
, B, BH
, B, BH
, A, AF

BR
r
,
,
, x
,

0
,
, A, B, BH
, A, AD, B, BH
, A, AD, AF, B, BH

0
,
,
, y, x
, y, x

Table 2: Steps sequence-form double-oracle algorithm applied example.
Consider small modification example game utility value
3 leaf following action F (i.e., node AyF ). case, algorithm
need add sequence AF (nor AE) restricted game improve
value restricted game. Note modified example game shows
algorithm needs set utility values nodes Z 0 \ Z. algorithm simply uses
unmodified utility function, node Ay treated zero utility
value. value overestimates outcome actual continuation following node
original game circle player since sequences AE AF never
part best response circle player, algorithm converge incorrect
solution.
4.2 Best-Response Sequence Algorithm
purpose best-response sequence (BRS) algorithm generate new sequences
added restricted game next iteration, prove
best response better expected value uses sequences currently allowed
restricted game. Throughout section use term searching player represent
player algorithm computes best response sequences. refer
player i.
BRS algorithm calculates expected value pure best response opponents strategy ri . algorithm returns set best-response sequences well
expected value strategy extended strategy opponent.
algorithm based depth-first search traverses original unrestricted
game tree. behavior opponent fixed strategy given extended
realization plan ri . save computation time, best-response algorithms use branch
bound search best-response sequences. algorithm uses bound
expected value inner node, denoted . bound represents minimal
utility value node currently evaluated needs gain order part
846

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

Require: - searching player, h - current node, Iik - current information set, r0i - opponents
strategy, Min/MaxUtility - bounds utility values, - lower bound node h
1: w r (seqi (h)) C(h)
2: h Z
3:
return ui (h) w
4: else h Z 0 \ Z
5:
return u0i (h) w
6: end

7: sort A(h) based probability wa r 0i seqi (ha) C(ha)
8: v h 0
9: A(h),
wa > 0

10:
0 v h + (w wa ) MaxUtility
11:
0 wa MaxUtility
12:
v 0 BRSi (ha, 0 )
13:
v 0 =
14:
return
15:
end
16:
vh vh + v0
17:
w w wa
18:
else
19:
return
20:
end
21: end
22: return v h

Figure 4: BRSi nodes players.

best-response sequence. Using bound search, algorithm able
prune branches certainly part best-response sequence. bound
set MinUtility root node.
distinguish 2 cases search algorithm: either algorithm evaluating
information set (or specifically node h) assigned searching player i,
node assigned one players (either opponent, player i,
chance node). pseudocode two cases depicted Figures 4 5.
4.2.1 Nodes Opponent
first describe case used algorithm evaluates node h assigned either
opponent searching player Nature (see Figure 4). main idea
calculate expected utility node according (fixed) strategy player.
strategy known either given extended realization plan ri ,
stochastic environment (C). Throughout algorithm, variable w represents
probability node based realization probability opponent stochastic
environment (line 1). value iteratively decreased values wa represent realization probabilities currently evaluated action A(h). Finally, vh expected
utility value node.
algorithm evaluates actions descending order according probability
played (based r0i C; lines 921). First, calculate new lower bound
847

fiBosansky, Kiekintveld, Lisy, & Pechoucek

0 successor ha (line 10). new lower bound minimal value must
returned recursive call BRSi (ha) optimistic assumption
remaining actions yield maximum possible utility. lower bound
exceed maximum possible utility game, algorithm executed recursively
successors (line 12). Note algorithm evaluate branches zero
realization probability (line 9).
3 possibilities pruning part search algorithm. first
pruning possible currently evaluated node leaf restricted game,
node inner node original node (i.e., h Z 0 \ Z; line 5). algorithm
directly use value modified utility function u0 case, since calculated
best response searching player default strategy opponent
applied successors node h since h Z 0 . Secondly, cut-off occurs
new lower bound successor larger maximum possible utility
game, since value never obtained successor (line 19). Finally, cut-off
occurs cut-off one successors (line 14).
4.2.2 Nodes Searching Player
nodes assigned searching player, algorithm evaluates every action
state belongs current information set. algorithm traverses states
descending order according probability occurrence given strategies
opponent Nature (line 8). Similar previous case, iteration algorithm
calculates new lower bound successor node (line 17). new lower bound 0
minimal value must returned recursive call BRSi (h0 a) order
action selected best action information set optimistic
assumption action yields maximum possible utility value applying
remaining states information set. algorithm performs recursive call
(line 20) action still could best information set (i.e., lower
bound exceed maximal possible utility game). Note cut-off
occurs one successors, currently evaluated action longer best
action information set. Hence, va set action evaluated
remaining nodes. algorithm determines action selected
best one information set, evaluates action remaining nodes
information set. Finally, algorithm stores values best action
nodes information set (line 30). reused information set
visited (i.e., algorithm reaches different node h0 information set
Ii ; line 5).
cut-off occurs part search algorithm maximal possible value vah
smaller lower bound evaluating node h. means regardless
action selected best action information set, lower bound
node h reached; hence, cut-off occurs (line 27). cut-off occurs
information set, information set cannot reached sequences
searching player leading information set cannot part best response.
due propagating cut-off least one previous information set searching
player, otherwise tight lower bound set (the bound first set
848

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

Require: - searching player, h - current node, Iik - current information set, ri - opponents
strategy, Min/MaxUtility - bounds utility values, lower bound node h
1: h Z
2:
return ui (h) r0i (seqi (h)) C(h)
3: end
4: v h already calculated
5:
return v h
6: end
7: H 0 {h0 ; h0 Ii }
0
8: sort H
value ri (seqi (h0 )) C(h0 )
P descending according
0
9: w h0 H 0 r (seqi (h )) C(h0 )
10: va 0 A(h); maxAction
11: h0 H 0
12:
wh0 r0i (seqi (h0 )) C(h0 )
13:
A(h0 )
14:
maxAction empty
15:
0 wh0 MinUtility
16:
else
17:
0 (vmaxAction + w MinUtility) (va + (w wh0 ) MaxUtility)
18:
end
19:
0 wh0 MaxUtility
0
20:
vah BRSi (h0 a, 0 )
0
21:
va va + vah
22:
end
23:
end
24:
maxAction arg maxaA(h0 ) va
25:
w w wh0

26:
h evaluated maxaA(h) vah <
27:
return
28:
end
29: end
0
h0
v h h0 H 0
30: store vmaxAction
h
31: return vmaxAction

Figure 5: BRSi nodes searching player.

information sets searching player). Therefore, exists least one action
searching player never evaluated (after cut-off, value va
action set ) cannot selected best action information set. Since
assume perfect recall, nodes information set Ii share sequence actions
seqi (Ii ); hence, node h0 Ii reached again.
4.3 Main Loop Alternatives
introduce several alternative formulations main loop sequence-form
double-oracle algorithm. general approach double-oracle algorithm solve
restricted game find equilibrium strategy player, compute best responses
original game players, continue next iteration. However,
sequence-form LP formulated double-oracle scheme way
849

fiBosansky, Kiekintveld, Lisy, & Pechoucek

iteration algorithm solve restricted game perspective single
player i. words, formulate single LP described Section 3.3 computes
optimal strategy opponent restricted game (player i), compute
best response player strategy. means iteration
select specific player i, compute best response iteration. call
selection process player-selection policy.
several alternatives player-selection policy act domainindependent heuristics double-oracle algorithm. consider three possible policies:
(1) standard double-oracle player-selection policy selecting players iteration, (2) alternating policy, algorithm selects one player switches
players regularly (player selected one iteration, player selected
following iteration), finally (3) worse-player-selection policy selects player
currently worse bound solution quality. end iteration
algorithm selects player upper bound utility value away
current value restricted game. formally,


arg max fiViU B ViLP
(13)


ViLP last calculated value restricted game player i. intuition
behind choice either bound precise missing sequences
player restricted game need added, upper bound overestimated. either case, best-response sequence algorithm run player
next iteration, either add new sequences tighten bound. case tie,
alternating policy applied order guarantee regular switching players.
experimentally compare policies show impact overall performance
sequence-form double-oracle algorithm (see Section 6).

5. Theoretical Results
section prove sequence-form double-oracle algorithm always converge Nash equilibrium original unrestricted game. First, formally define
strategy computed best-response sequence (BRS) algorithm, prove lemmas
characteristics BRS strategies, finally prove main convergence
result. Note variations main loop described Section 4.3 affect
correctness algorithm long player-selection policy ensures improvement made BRS algorithm one player BRS algorithm run
opponent next iteration.
0 realization plan player restricted game G0 . BRS(r 0 )
Lemma 5.1 Let ri

returns sequences corresponding realization plan riBR unrestricted game,
riBR part pure best response strategy r0i . value returned algorithm
value executing pair strategies ui (r0i , riBR ).
0 ) searches game tree selects action maximizes value
Proof BRS(ri
game player information sets Ii assigned player reachable given
strategy opponent r0i . opponents nodes, calculates expected value

850

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

0 defined value according pure action default
according ri
Def
0 defined. chance nodes, returns expected value
strategy ri
node sum values successor nodes weighted probabilities.
node h, successors maximal possible value node h
maximal possible value (when playing r0i ). selections nodes
belong achieves maximal value; hence, form best response strategy
r0i .
0 )) denote value returned BRS algorithm,
brevity use v(BRS(ri
equal ui (r0i , riBR ).
0 realization plan player restricted game G0 let
Lemma 5.2 Let ri

Vi value original unrestricted game G player i,
0
v(BRS(ri
)) Vi .

(14)

0 )) value best response r 0
Proof Lemma 5.1 showed v(BRS(ri

0 )) < V
valid strategy original unrestricted game G. v(BRS(ri

Vi cannot value game since player strategy r0i achieves better
utility, contradiction.
0 realization plan player returned LP
Lemma 5.3 Let ri
0
restricted game G let ViLP value restricted game returned LP,
0
v(BRS(ri
)) ViLP .

(15)

0
Proof realization plan ri
part Nash equilibrium strategy zero-sum
LP
game guarantees value Vi
G0 . best response computation original
unrestricted game G selects actions restricted game G0 , creates best
response game G0 well obtaining value ViLP . best response selects action
allowed restricted game G0 , two cases.
Case 1 : best response strategy uses action temporary leaf h Z 0 \ Z.
Player makes decision leaf, otherwise value temporary leaf
would directly returned BRS. value temporary leaf underestimated player restricted game modified utility function u0
Def .
over-estimated BRS computation best response default strategy
value best response increase including action.
Case 2 : best response strategy uses action allowed G0 internal node
restricted game H 0 \ Z 0 . occur nodes assigned player i,
actions player going G0 probability zero r0i . BRS takes action
maximum value nodes assigned player i, reason selecting action
leading outside G0 greater equal value best action G0 .
0 )) > V LP
Lemma 5.4 assumptions previous lemma, v(BRS(ri

returns sequences added restricted game G0 next iteration.

851

fiBosansky, Kiekintveld, Lisy, & Pechoucek

Proof Based proof previous Lemma, BRS player improve
value LP (ViLP ) selecting action present G0
performed node h included G0 (in makes decision). Let (i , )
pair sequences leading h. construction restricted game
next iteration, sequence sequence ensures executed full
part new restricted game.
Note, Lemmas 5.2 5.4 would hold utility values u0 temporary
leaves (h Z 0 \ Z) set arbitrarily. algorithm sets values temporary leaf h
player p(h) continues playing default strategy opponent (p(h))
playing best response. utility values temporary leaves set arbitrarily
used BRS algorithms speed-up calculation proposed (see algorithm
Figure 4, line 5), Lemma 5.2 need hold cases value
node h strictly overestimates optimal expected value player p(h). case,
best-response value opponent may lower optimal outcome,


v BRS(rp(h) ) < Vp(h)
(16)
hand, BRS algorithm use temporary values u0
node, Lemma 5.4 violated best-response value strictly higher
player p(h) even though new sequences added restricted game.
Theorem 5.5 sequence-form double-oracle algorithm extensive-form games described previous section terminates
0
v(BRS(ri
)) = v(BRS(ri0 )) = ViLP = Vi ,

(17)

always happens finite number iterations (because game finite),
strategies (r0i , r0i ) Nash equilibrium original unrestricted game.
Proof First show algorithm continues equalities (17) hold.
0 )) 6= v(BRS(r 0 )) Lemma 5.2 Lemma 5.4 know
v(BRS(ri

0 ) > V LP , restricted game following itersome player holds BRS(ri

ation larger least one action algorithm continues. worst case,
restricted game equals complete game G0 = G, cannot extended further.
case BRS cannot find better response Vi algorithm stops due
Lemma 5.4.
condition theorem holds algorithm found NE complete
BR = BRS(r 0 ) best response r 0
game, Lemma 5.1 know ri


complete game. However, value best response strategy zero-sum
game value game, strategy r0i optimal part Nash
equilibrium game.

6. Experiments
present experimental evaluation performance sequence-form
double-oracle algorithm EFGs. compare algorithm two state-of-the-art
852

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

baselines, full sequence-form LP (referred FullLP on), Counterfactual Regret Minimization (CFR). first baseline standard exact method
solving sequence-form EFG, CFR one leading approximate algorithms applied EFG. experimental results demonstrate advantages double-oracle
algorithm three different classes realistic EFGs. test impact different
variants main loop algorithm described Section 4.3.
compare three variants sequence-form double-oracle algorithm: (1) DO-b
variant best-responses calculated players iteration;
(2) DO-sa calculates best-response single player iteration according
simple alternating policy; (3) DO-swp variant best-response
calculated single player according worse-player selection policy.
variants double-oracle algorithm use default strategy first
action applicable state played default.
Since standardized collection zero-sum extensive-form games benchmark purposes, use several specific games evaluate double-oracle algorithm
identify strengths weaknesses algorithm. games selected
evaluate performance different conditions, games differ maximal
utility players gain, causes imperfect information, structure
information sets. One key characteristics affects performance
double-oracle algorithm relative size support Nash equilibria (i.e., number sequences used NE non-zero probability). exist NE
small support, algorithm must necessarily add large fraction sequences
restricted game find solution, mitigating advantages double-oracle approach.
present results two types games double-oracle significantly outperforms FullLP instances: search game motivated border patrol Phantom
Tic-Tac-Toe. present results simplified version poker doubleoracle algorithm always improve computation time. However, FullLP
limited scalability due larger memory requirements cannot find solutions
larger variants poker, double-oracle algorithm able solve instances.
principal interest developing new generic methods solving extensive-form
games. Therefore, implemented algorithm generic framework modeling arbitrary extensive-form games.1 algorithms use domain-specific knowledge
implementation, rely specific ordering actions. drawbacks
generic implementation higher memory requirements additional overhead
algorithms. domain-specific implementation could improve performance
eliminating auxiliary data structures. run experiments using
single thread Intel i7 CPU running 2.8 GHz. algorithms given
maximum 10 GB memory Java heap space. used IBM CPLEX 12.5 solving
linear programs, parameter settings use single thread barrier solution
algorithm.
addition runtimes, analyze speed convergence double-oracle algorithms compare one state-of-the-art approximative algorithms, Counterfactual Regret Minimization (CFR). implemented CFR domain independent way
1. Source code available home pages authors.

853

fiBosansky, Kiekintveld, Lisy, & Pechoucek

based pseudocode work Lanctot (2013, p. 22). principle, sufficient
CFR maintain set information sets apply no-regret learning rule
information set. However, maintaining traversing set effectively
domain independent manner could affected implementation generic extensiveform games data structures (i.e., generating applicable actions states game,
applying actions, etc.). Therefore use implementation CFR traverses
complete game tree held memory maintain fairness comparison,
guarantee maximal possible speed convergence CFR algorithm. time
necessary build game tree included computation time CFR.
6.1 Test Domains
Search Games first test belongs class search (or pursuit-evasion) games,
often used experimental evaluation double-oracle algorithms (McMahan et al., 2003;
Halvorson et al., 2009). search game two players: patroller (or defender)
evader (or attacker). game played directed graph (see Figure 6),
evader aims cross safely starting node (E) destination node (D).
defender controls two units move intermediate nodes (the shaded areas)
trying capture evader occupying node evader. turn
players move units simultaneously current node adjacent node,
units stay location. exception evader cannot stay
two leftmost nodes. pre-determined number turns made without either player
winning, game draw. example win-tie-loss game utility
values set {1, 0, 1}.
Players unaware location actions player one exception
evader leaves tracks visited nodes discovered defender visits
nodes later. game includes option evader avoid leaving tracks
using special move (a slow move) requires two turns simulate evader covering
tracks.
Figure 6 shows examples graphs used experiments. patrolling units
move shaded areas (P1,P2), start node shaded
areas. Even though graph small, concurrent movement units implies large
branching factor (up 50 one turn) thus large game trees (up 1011 nodes).
experiments used three different graphs, varied maximum number turns
game (from 3 7), altered ability attacker perform slow
moves (labeled SA slow moves allowed, SD otherwise).
Phantom Tic-Tac-Toe second game blind variant well-known game
Tic-Tac-Toe (e.g., used Lanctot et al., 2012). game played 3 3 board,
two players (cross circle) attempt place 3 identical marks horizontal, vertical,
diagonal row win game. blind variant, players unable observe
opponents moves player knows opponent made move
turn. Moreover, player tries place mark square already occupied
opponents mark, player learns information place mark
square. Again, utility values game set {1, 0, 1}.
854

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

Figure 6: Three variants graph used experiments search game; refer
G1 (left), G2 (middle), G3 (right).
uncertainty phantom Tic-Tac-Toe makes game large ( 109 nodes).
addition, since one player try several squares move successful, players
necessarily alternate making moves. rule makes structure
information sets rather complicated since opponent never learns many attempts
first player actually performed, single information set contain nodes different
depths game tree.
Poker Games Poker frequently studied literature example large
extensive-form game imperfect information. include experiments simplified
two-player poker game inspired Leduc Holdem.
version poker, player starts amount chips
players required put number chips pot (called ante). next
step, Nature player deals single card player (the opponent unaware
card) betting round begins. player either fold (the opponent wins pot),
check (let opponent make next move), bet (being first add amount
chips pot), call (add amount chips equal last bet opponent
pot), raise (match increase bet opponent). raise made
players, betting round ends, Nature player deals one card
table, second betting round rules begins. second betting
round ends, outcome game determined player wins if: (1) private card
matches table card opponents card match, (2) none players
cards matches table card private card higher private card
opponent, (3) opponent folds. utility value amount chips player
lost. player wins, game draw pot split.
experiments alter number types cards (from 3 4;
3 types cards Leduc), number cards type (from 2 3; set 2 Leduc),
maximum length sequence raises betting round (ranging 1 4; set 1
Leduc), number different sizes bets (i.e., amount chips added pot)
bet/raise actions (ranging 1 4; set 1 Leduc).
6.2 Results
Search Games results search game scenarios show sequence-form
double-oracle algorithm particularly successful applied games NEs
small support exist. Figure 7 shows comparison running times FullLP
variants double-oracle algorithm (note logarithmic y-scale). variants
855

fiBosansky, Kiekintveld, Lisy, & Pechoucek

102

101

100

103

FullLP
DO-B
DO-SA
DO-SWP
Time [s] (log scale)

Time [s] (log scale)

103

G1-SD

G2-SD

G3-SD

G1-SA

G2-SA

102

101

100

G3-SA

Search Game Scenarios - Depth 6

FullLP
DO-B
DO-SA
DO-SWP

G1-SD

G2-SD

G3-SD

G1-SA

G2-SA

G3-SA

Search Game Scenarios - Depth 7

Figure 7: Comparison running times 3 different graphs either slow moves
allowed (SA) disallowed (SD), depth set 6 (left subfigure) 7 (right subfigure).
Missing values FullLP algorithm indicate algorithm runs memory.

double-oracle algorithm several orders magnitude faster FullLP.
apparent fully-connected graph (G2) generates largest game tree.
slow moves allowed depth set 6, takes almost 100 seconds FullLP
solve instance game variants double-oracle algorithms solve
game less 3 seconds. Moreover, depth increased 7, FullLP
unable solve game due memory constraints, fastest variant DO-swp
solved game less 5 seconds. Similar results obtained graphs.
graph G1 induced game difficult double-oracle algorithm:
depth set 7, takes almost 6 minutes FullLP solve instance,
fastest variant DO-swp solved game 21 seconds. reason even though
game tree largest, complex structure information sets.
due limited compatibility among sequences players; patrolling
unit P1 observes tracks top-row node, second patrolling unit P2 capture
evader top-row node, middle-row node.
Comparing different variants sequence-form double-oracle algorithm
show consistent results. variant consistently better game since
double-oracle variants typically able compute Nash equilibrium quickly.
However, DO-swp often fastest settings difference quite significant.
speed-up variant offers apparent G1 graph. average
instances search game, DO-sa uses 92.59% computation time DO-b,
DO-swp uses 88.25%.
Table 3 shows breakdown cumulative computation time spent different components double-oracle algorithm: solving restricted game (LP), calculating best
responses (BR), creating valid restricted game selecting new sequences add
(Validity). results show due size game, computation
best-response sequences takes majority time (typically around 75% larger
instances), creating restricted game solving takes small fraction
total time. noticeable size final restricted game small
856

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

DO-B

DO-SA

DO-SWP

CFR

Bounds Interval Size [-] (log scale)

10
1
0.1
0.01
0.001
0.0001
1e-05
0

50

100
Time [s]

150

200

Figure 8: Convergence variants double-oracle algorithm CFR search
game domain: y-axis displays current approximation error.
Algorithm
FullLP
DO-b
DO-sa
DO-swp

Overall [s]
351.98
81.51
54.32
21.15

LP [s]

6.97
5.5
1.93

BR [s]

63.39
39.11
16.28

Validity [s]

10.58
9.09
2.47

Iterations

187
344
209

|0 |

|01 |( |11 | )

252 (17.22%)
264 (18.05%)
193 (13.19%)

|0 |

|02 |( |22 | )

711 (0.26%)
649 (0.24%)
692 (0.25%)

Table 3: Cumulative running times different components double-oracle algorithm,
iterations, size restricted game terms number sequences compared
size complete game. results shown scenario G1, depth 7, allowed
slow moves.
compared original game, since number sequences second player (the
defender) less 1% (there 273,099 sequences defender).
Finally, analyze convergence rate variants double-oracle algorithm.
results depicted Figure 8, size interval given bounds
ViU B ViLB defines current error double-oracle algorithm |ViU B ViLB |.
convergence rate CFR algorithm depicted. error CFR calculated
way, sum best-response values current mean strategies
CFR algorithm. see variants double-oracle algorithm perform
similarly error drops quickly 1 iterations later version
algorithm quickly converges exact solution. results show game
double-oracle algorithm quickly find correct sequences actions compute
exact solution, spite size game. comparison, CFR algorithm
quickly learn correct strategies information sets, convergence
long tail. 200 seconds, error CFR equal 0.0657 dropping
slowly (0.0158 1 hour). error CFR quite significant considering value
game case (0.3333).
Phantom Tic-Tac-Toe results Phantom Tic-Tac-Toe confirm game
suitable sequence-form double-oracle algorithm. Due size game,
baseline algorithms (the FullLP CFR) ran memory able
857

fiBosansky, Kiekintveld, Lisy, & Pechoucek

DO-SA

DO-SWP
DO-B
DO-SA
DO-SWP

1
Time [s] (log scale)

Bounds Interval Size [-] (log scale)

DO-B

0.1
0.01
0.001

104

0.0001
1e-05
0

5000

10000
15000
Time [s]

20000

25000

103

Random

Domain-dependent

Different Action Ordering Phantom Tic-Tac-Toe

Figure 9: (left) Comparison convergence rate double-oracle variants Phantom Tic-Tac-Toe; (right) Comparison performance double-oracle variants
Phantom Tic-Tac-Toe domain-specific move ordering default strategy used.
Algorithm
FullLP
DO-b
DO-sa
DO-swp

Overall [s]
N/A
21,197
17,667
17,589

LP [s]

2,635
2,206
2,143

BR [s]

17,562
14,560
14,582

Validity [s]

999
900
864

Iterations

335
671
591

|0 |

|01 |( |11 | )

7,676 (0.60%)
7,518 (0.59%)
8,242 (0.65%)

|0 |

|02 |( |22 | )

10,095 (0.23%)
9,648 (0.22%)
8,832 (0.20%)

Table 4: Cumulative running times different components double-oracle algorithm
game Phantom Tic-Tac-Toe.
solve game. Therefore, compare times different variants
double-oracle algorithm. Figure 9 (left subfigure) shows overall performance three
variants double-oracle algorithm form convergence graph. see
performance two variants similar, performance DO-sa DO-swp
almost identical. hand, results show DO-b converges significantly
slower.
time breakdown variants double-oracle algorithm shown Table 4.
Similarly previous case, majority time ( 83%) spent calculating
best responses. variants double-oracle algorithm, DO-swp variant
fastest one. converged significantly fewer iterations compared DO-sa
variant (iterations twice expensive DO-b variant).
present results demonstrate potential combining sequenceform double-oracle algorithm domain-specific knowledge. Every variant doubleoracle algorithm use move ordering based domain-specific heuristics. move
ordering determines default strategy (recall algorithm uses first action
default strategy player), direction search best response
algorithms. replacing randomly generated move ordering heuristic one
chooses better actions first, results show significant improvement performance
variants (see Figure 9, right subfigure), even though changes
rest algorithm. variant able solve game less 3 hours,
took 2 hours fastest DO-swp variant.
858

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

200

FullLP
DO-B
DO-SA
DO-SWP
103
Time [s] (log scale)

150
Time [s]

104

FullLP
DO-B
DO-SA
DO-SWP

100

102

101

50

100

0
R1

R2

R3

R4

Increasing number allowed "Raise Actions"

B1

B2

B3

B4

Increasing size possible bets

Figure 10: Comparison running times different variants simplified poker
game. left subfigure shows computation times increasing number raise
actions allowed, right subfigure shows computation times increasing number
different bet sizes raise/bet actions.
Poker Games Poker represents game double-oracle algorithms perform well sequence-form LP often faster smaller instances. One significant
difference compared previous games size NE support larger
(around 5% sequences larger instances). Secondly, game trees poker games
relatively shallow imperfect information game due Nature.
result, double-oracle algorithms require larger number iterations add
sequences restricted game (up 10% sequences player added even
largest poker scenarios) order find exact solution. However, increasing
depth and/or branching factor, size game grows exponentially FullLP
able solve largest instances due memory constraints.
Figure 10 shows selected results simplified poker variants. results
left subfigure show computation times increasing depth game allowing
players re-raise (players allowed re-raise opponent certain number
times). remaining parameters fixed 3 types cards, 2 cards type, 2
different betting sizes. size game grows exponentially, number possible
sequences increasing 210,937 player R4 scenario. computation time
FullLP directly related size tree increases exponentially
increasing depth (note standard scale). hand, increase
less dramatic variants double-oracle algorithm. DO-swp variant
fastest largest scenario FullLP solved instance 126 seconds,
took 103 seconds DO-swp. Finally, FullLP able solve games
increase length R5 due memory constraints, computation time
double-oracle algorithms increases marginally.
right subfigure Figure 10 shows increase computation time increasing number different bet sizes raise/bet actions. remaining parameters
fixed 4 types cards, 3 cards type, 2 raise actions allowed. Again,
game grows exponentially increasing branching factor. number sequences
increases 685,125 player B4 scenario, computation time
859

fiBosansky, Kiekintveld, Lisy, & Pechoucek

DO-B

DO-SA

DO-SWP

CFR

DO-B

DO-SWP

CFR

10
Bounds Interval Size [-] (log scale)

Bounds Interval Size [-] (log scale)

10

DO-SA

1
0.1
0.01
0.001
0.0001
1e-05

1
0.1
0.01
0.001
0.0001
1e-05

0

50

100

150

200
250
Time [s]

300

350

400

0

200

400

600
800
Time [s]

1000

1200

1400

Figure 11: Comparison convergence variants double-oracle algorithm
CFR two variants simplified poker 4 types cards, 3 cards
type. 4 raise actions allowed, 2 different bet sizes left subfigure;
2 raise actions allowed, 3 different bet sizes right subfigure.
Algorithm
FullLP
DO-b
DO-sa
DO-swp

Overall [s]
278.18
234.60
199.24
182.68

LP [s]

149.32
117.71
108.95

BR [s]

56.04
51.25
48.25

Validity [s]

28.61
29.59
24.8

Iterations

152
289
267

|0 |

|01 |( |11 | )

6,799 (1.81%)
6,762 (1.80%)
6,572 (1.75%)

|0 |

|02 |( |22 | )

6,854 (1.83%)
6,673 (1.78%)
6,599 (1.76%)

Table 5: Cumulative running times different components double-oracle algorithm,
iterations, sizes restricted game terms number sequences compared
size complete game. results shown poker scenario 4 raise
actions allowed, 2 different betting values, 4 types cards, 3 cards type.
algorithms increases exponentially well (note logarithmic scale). results show
even increasing branching factor, double-oracle variants tend slower
solving FullLP. However, FullLP ran memory largest
B4 setting, double-oracle variants able find exact solution using less
memory.
Comparing different variants double-oracle algorithm using convergence
graph (see Figure 11) decomposition computation times (see Table 5) shows
DO-swp fastest variant selected scenario (and nearly poker
scenarios). Decomposition overall time shows majority computation
time spent solving restricted game LP (up 65%). decomposition shows
DO-swp typically faster due lower number iterations. addition,
final size restricted game typically smallest variant. average
instances poker games, DO-sa uses 86.57% computation time DO-b,
DO-swp uses 82.3% computation time.
Convergence poker games slower compared search games similar size (note
logarithmic scale Figure 11). Comparing double-oracle algorithm variants CFR
shows interesting result left subfigure. Due size game, speed
CFR convergence nearly double-oracle algorithms first
860

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

iterations. However, double-oracle algorithms continue converge roughly
rate able find exact solution, error CFR algorithm decreases
slowly. scenario depicted left subfigure, CFR algorithm converged
error 0.1212 (the value game case 0.09963) 400 seconds.
1 hour, error dropped 0.0268. scenarios shallow game trees
larger branching factor, convergence CFR faster beginning compared
double-oracle algorithms (right subfigure Figure 11). However, main disadvantage
CFR long tail convergence still case error 1600 seconds
still 0.0266 (the value game 0.09828).
6.3 Discussion Results
experimental results support several conclusions. results demonstrate
sequence-form double-oracle algorithm able compute exact solution much larger
games compared state-of-the-art exact algorithm based sequence-form linear
program. Moreover, experimentally shown realistic games
small fraction sequences necessary find solution game. cases,
double-oracle algorithms significantly speed computation time. results
indicate DO-swp variant typically fastest, cases. selecting
player currently worse bound performance, DO-swp version
add important sequences, prove better sequences adjust
upper bound value faster.
Comparing speed convergence double-oracle algorithms state-ofthe-art approximative algorithm CFR showed CFR quickly approximates solution
first iterations. However, convergence CFR long tail CFR
able find exact solution larger games reasonable time. Another interesting
observation games convergence rate double-oracle algorithms
CFR similar first iterations, double-oracle algorithms continue
rate find exact solution, long tail convergence remains CFR.
despite fact implementation CFR advantage complete
game tree including states histories memory.
Unfortunately, difficult characterize exact properties games
double-oracle algorithms perform better terms computation time compared
algorithms. Certainly, double-oracle algorithm suitable games
equilibria large support due necessity large number iterations.
However, small support equilibrium sufficient condition. apparent
due two graphs shown poker experiments, either depth game tree
branching factor increased. Even though game grows exponentially
size support decreases 2.5% cases, behavior double-oracle
algorithms quite different. conjecture games longer sequences suit
double-oracle algorithms better, since several actions form best-response sequences
added single iteration. contrasts shallow game trees large
branching factors, iterations necessary add multiple actions. However,
deeper analysis identify exact properties games suitable open
question must analyzed normal-form games first.
861

fiBosansky, Kiekintveld, Lisy, & Pechoucek

7. Conclusion
present novel exact algorithm solving two player zero-sum extensive-form games
imperfect information. approach combines compact sequence-form representation extensive-form games iterative algorithmic framework double-oracle
methods. integrates two successful approaches solving large scale games
yet brought together general class games algorithm addresses.
main idea algorithm restrict game allowing players play
restricted set sequences available sequences actions, iteratively expand
restricted game time using fast best-response algorithms. Although worst
case double-oracle algorithm may need add possible sequences, experimental
results different domains prove double-oracle algorithm find exact Nash
equilibrium prior constructing full linear program complete game. Therefore,
sequence-form double-oracle algorithm reduces main limitation sequence-form
linear programmemory requirementsand able solve much larger games compared
state-of-the-art methods. Moreover, since algorithm able identify sequences
promising actions without domain-specific knowledge, provide significant
runtime improvements.
proposed algorithm another crucial advantage compared current state
art. double-oracle framework offers decomposition problem computing
Nash equilibrium separate sub-problems, including best-response algorithms,
choice default strategy, algorithms constructing solving restricted
game. developed solutions sub-problems domain-independent manner. However, view algorithm general framework
specialized domain-specific components take advantage structure specific
problems improve performance sub-problems. lead substantial
improvements speed algorithm, number iterations, well reducing
final size restricted game. demonstrated potential domain-specific
approach game Phantom Tic-Tac-Toe. Another example fast best-response
algorithms operate public tree (i.e., compact representation games
publicly observable actions; see Johanson, Bowling, Waugh, & Zinkevich, 2011) exploited games poker. Finally, formal analysis identifies key properties
domain-specific implementations need satisfy guarantee convergence
correct solution game.
algorithm opens large number directions future work. represents new
class methods solving extensive-form games imperfect information operates
differently common approaches (e.g., counterfactual regret minimization),
many possible alternatives improve performance algorithm remain
investigated. Examples include sophisticated calculation utility values
temporary leaves, alternative strategies expanding restricted game, removing
unused sequences restricted game. broader analysis using sequenceform double-oracle algorithm approximation technique performed, possibly
exploring alternative approximative best-response algorithms based sampling (e.g.,
Monte Carlo) techniques.
862

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

several theoretical questions could investigated. First, performance double-oracle algorithm depends strongly number iterations
sequences need added. However, theoretical question regarding expected
number iterations thus speed convergence double-oracle algorithm
explored even simpler game models (e.g., games normal form).
analysis simpler models needed identify general properties games
double-oracle methods tend faster identify optimal way expanding
restricted game.

Acknowledgements
Earlier versions paper published European Conference Artificial
Intelligence (ECAI) (Bosansky, Kiekintveld, Lisy, & Pechoucek, 2012) conference
Autonomous Agents Multi Agent Systems (AAMAS) (Bosansky, Kiekintveld, Lisy,
Cermak, & Pechoucek, 2013). major additions full version include (1) novel,
detailed description parts algorithm, (2) introduction analysis
different policies player selection main loop double-oracle algorithm,
(3) new experiments phantom tic-tac-toe domain together thorough
analysis experimental results domains, including analysis convergence
algorithm, (4) experimental comparison CFR, finally (5) extended analysis
related work.
research supported Czech Science Foundation (grant no. P202/12/2054)
U.S. Army Research Office (award no. W911NF-13-1-0467).

References
Barnhart, C., Johnson, E. L., Nemhauser, G. L., Savelsbergh, M. W. P., & Vance, P. H.
(1998). Branch-And-Price: Column Generation Solving Huge Integer Programs.
Operations Research, 46, 316329.
Bosansky, B., Kiekintveld, C., Lisy, V., Cermak, J., & Pechoucek, M. (2013). Doubleoracle Algorithm Computing Exact Nash Equilibrium Zero-sum Extensiveform Games. Proceedings International Conference Autonomous Agents
Multiagent Systems (AAMAS), pp. 335342.
Bosansky, B., Kiekintveld, C., Lisy, V., & Pechoucek, M. (2012). Iterative Algorithm
Solving Two-player Zero-sum Extensive-form Games Imperfect Information.
Proceedings 20th European Conference Artificial Intelligence (ECAI), pp.
193198.
Cermak, J., Bosansky, B., & Lisy, V. (2014). Practical Performance Refinements
Nash Equilibria Extensive-Form Zero-Sum Games. Proceedings European
Conference Artificial Intelligence (ECAI), pp. 201206.
Dantzig, G., & Wolfe, P. (1960). Decomposition Principle Linear Programs. Operations
Research, 8, 101111.
Ganzfried, S., & Sandholm, T. (2013). Improving Performance Imperfect-Information
Games Large State Action Spaces Solving Endgames. Computer
863

fiBosansky, Kiekintveld, Lisy, & Pechoucek

Poker Imperfect Information Workshop National Conference Artificial
Intelligence (AAAI).
Gibson, R., Lanctot, M., Burch, N., Szafron, D., & Bowling, M. (2012). Generalized Sampling Variance Counterfactual Regret Minimization. Proceedings 26th
AAAI Conference Artificial Intelligence, pp. 13551361.
Halvorson, E., Conitzer, V., & Parr, R. (2009). Multi-step Multi-sensor Hider-seeker Games.
Proceedings Joint International Conference Artificial Intelligence (IJCAI),
pp. 159166.
Hoda, S., Gilpin, A., Pena, J., & Sandholm, T. (2010). Smoothing Techniques Computing
Nash Equilibria Sequential Games. Mathematics Operations Research, 35 (2),
494512.
Jain, M., Conitzer, V., & Tambe, M. (2013). Security Scheduling Real-world Networks.
Proceedings International Conference Autonomous Agents Multiagent
Systems (AAMAS), pp. 215222.
Jain, M., Korzhyk, D., Vanek, O., Conitzer, V., Tambe, M., & Pechoucek, M. (2011). Double
Oracle Algorithm Zero-Sum Security Games Graph. Proceedings 10th
International Conference Autonomous Agents Multiagent Systems (AAMAS),
pp. 327334.
Johanson, M., Bowling, M., Waugh, K., & Zinkevich, M. (2011). Accelerating Best Response
Calculation Large Extensive Games. Proceedings 22nd International Joint
Conference Artificial Intelligence (IJCAI), pp. 258265.
Koller, D., & Megiddo, N. (1992). Complexity Two-Person Zero-Sum Games
Extensive Form. Games Economic Behavior, 4, 528552.
Koller, D., Megiddo, N., & von Stengel, B. (1996). Efficient Computation Equilibria
Extensive Two-Person Games. Games Economic Behavior, 14 (2), 247259.
Koller, D., & Megiddo, N. (1996). Finding Mixed Strategies Small Supports Extensive Form Games. International Journal Game Theory, 25, 7392.
Kreps, D. M., & Wilson, R. (1982). Sequential Equilibria. Econometrica, 50 (4), 86394.
Lanctot, M. (2013). Monte Carlo Sampling Regret Minimization Equilibrium Computation Decision Making Large Extensive-Form Games. Ph.D. thesis, University Alberta.
Lanctot, M., Gibson, R., Burch, N., Zinkevich, M., & Bowling, M. (2012). No-Regret
Learning Extensive-Form Games Imperfect Recall. Proceedings 29th
International Conference Machine Learning (ICML 2012), pp. 121.
Lanctot, M., Waugh, K., Zinkevich, M., & Bowling, M. (2009). Monte Carlo Sampling
Regret Minimization Extensive Games. Advances Neural Information
Processing Systems (NIPS), pp. 10781086.
Lee, C.-S., Wang, M.-H., Chaslot, G., Hoock, J.-B., Rimmel, A., Teytaud, O., Tsai, S.-R.,
Hsu, S.-C., & Hong, T.-P. (2009). Computational Intelligence Mogo Revealed
Taiwans Computer Go Tournaments. IEEE Transactions Computational Intelligence AI Games, 1, 7389.
864

fiAn Exact Double-Oracle Algorithm Zero-Sum EFGs Imperfect Information

Letchford, J., & Vorobeychik, Y. (2013). Optimal Interdiction Attack Plans. Proceedings 12th International Conference Automonous Agents Multiagent
Systems (AAMAS), pp. 199206.
Lisy, V., Kovarik, V., Lanctot, M., & Bosansky, B. (2013). Convergence Monte Carlo Tree
Search Simultaneous Move Games. Advances Neural Information Processing
Systems (NIPS), Vol. 26, pp. 21122120.
McMahan, H. B. (2006). Robust Planning Domains Stochastic Outcomes, Adversaries, Partial Observability. Ph.D. thesis, Carnegie Mellon University.
McMahan, H. B., & Gordon, G. J. (2007). Fast Bundle-based Anytime Algorithm
Poker Convex Games. Journal Machine Learning Research - Proceedings
Track, 2, 323330.
McMahan, H. B., Gordon, G. J., & Blum, A. (2003). Planning Presence Cost
Functions Controlled Adversary. Proceedings International Conference
Machine Learning, pp. 536543.
Miltersen, P. B., & Srensen, T. B. (2008). Fast Algorithms Finding Proper Strategies
Game Trees. Proceedings Symposium Discrete Algorithms (SODA), pp.
874883.
Miltersen, P. B., & Srensen, T. B. (2010). Computing Quasi-Perfect Equilibrium
Two-Player Game. Economic Theory, 42 (1), 175192.
Pita, J., Jain, M., Western, C., Portway, C., Tambe, M., Ordonez, F., Kraus, S., & Parachuri,
P. (2008). Deployed ARMOR protection: Application Game-Theoretic Model
Security Los Angeles International Airport. Proceedings 8th International Conference Autonomous Agents Multiagent Systems (AAMAS), pp.
125132.
Ponsen, M. J. V., de Jong, S., & Lanctot, M. (2011). Computing Approximate Nash Equilibria Robust Best-Responses Using Sampling. Journal Artificial Intelligence
Research (JAIR), 42, 575605.
Sandholm, T. (2010). State Solving Large Incomplete-Information Games,
Application Poker. AI Magazine, special issue Algorithmic Game Theory, 13
32.
Selten, R. (1975). Reexamination Perfectness Concept Equilibrium Points
Extensive Games. International Journal Game Theory, 4, 2555.
Selten, R. (1965). Spieltheoretische Behandlung eines Oligopolmodells mit Nachfragetrgheit
[An oligopoly model demand inertia]. Zeitschrift fur die Gesamte Staatswissenschaft, 121, 301324.
Shafiei, M., Sturtevant, N., & Schaeffer, J. (2009). Comparing UCT versus CFR Simultaneous Games. IJCAI Workshop General Game Playing.
Shieh, E., An, B., Yang, R., Tambe, M., Baldwin, C., Direnzo, J., Meyer, G., Baldwin, C. W.,
Maule, B. J., & Meyer, G. R. (2012). PROTECT : Deployed Game Theoretic System
Protect Ports United States. International Conference Autonomous
Agents Multiagent Systems (AAMAS), pp. 1320.
865

fiBosansky, Kiekintveld, Lisy, & Pechoucek

Shoham, Y., & Leyton-Brown, K. (2009). Multiagent Systems: Algorithmic, GameTheoretic, Logical Foundations. Cambridge University Press.
Tambe, M. (2011). Security Game Theory: Algorithms, Deployed Systems, Lessons
Learned. Cambridge University Press.
Tsai, J., Rathi, S., Kiekintveld, C., Ordonez, F., & Tambe, M. (2009). IRIS - Tool
Strategic Security Allocation Transportation Networks Categories Subject
Descriptors. Proceedings 8th International Conference Autonomous Agents
Multiagent Systems (AAMAS), pp. 3744.
van Damme, E. (1984). Relation Perfect Equilibria Extensive Form Games
Proper Equilibria Normal Form Games. Game Theory, 13, 113.
van Damme, E. (1991). Stability Perfection Nash Equilibria. Springer-Verlag.
von Stengel, B. (1996). Efficient Computation Behavior Strategies. Games Economic
Behavior, 14, 220246.
Wilson, R. (1972). Computing Equilibria Two-Person Games Extensive Form.
Management Science, 18 (7), 448460.
Zinkevich, M., Johanson, M., Bowling, M., & Piccione, C. (2008). Regret Minimization
Games Incomplete Information. Advances Neural Information Processing
Systems (NIPS), 20, 17291736.
Zinkevich, M., Bowling, M., & Burch, N. (2007). New Algorithm Generating Equilibria
Massive Zero-Sum Games. Proceedings National Conference Artificial
Intelligence (AAAI), pp. 788793.

866


