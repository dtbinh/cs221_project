journal artificial intelligence

submitted published

exact double oracle zero sum
extensive form games imperfect information
branislav bosansky

branislav bosansky agents fel cvut cz

agent technology center
department computer science
faculty electrical engineering
czech technical university prague

christopher kiekintveld

cdkiekintveld utep edu

computer science department
university texas el paso usa

viliam lisy
michal pechoucek

viliam lisy agents fel cvut cz
michal pechoucek agents fel cvut cz

agent technology center
department computer science
faculty electrical engineering
czech technical university prague

abstract
developing scalable solution one central computational
game theory present iterative computing exact nash equilibrium
two player zero sum extensive form games imperfect information
combines two key elements compact sequence form representation extensiveform games algorithmic framework double oracle methods main idea
restrict game allowing players play selected sequences
available actions solving restricted game sequences added finding
best responses current solution fast
experimentally evaluate set games inspired patrolling
scenarios board card games significant runtime improvements
games admitting equilibrium small support substantial improvement memory use even games large support improvement memory use particularly
important allows solve much larger game instances existing
linear programming methods
main contributions include generic sequence form double oracle
solving zero sum extensive form games fast methods maintaining valid restricted
game model adding sequences search pruning methods
computing best response sequences theoretical guarantees convergence
nash equilibrium experimental analysis several
games including approximate version

introduction
game theory widely used methodology analyzing multi agent systems applying
formal mathematical solution concepts one focus computational game theory development scalable reasoning large games
c

ai access foundation rights reserved

fibosansky kiekintveld lisy pechoucek

need continued algorithmic advances driven growing number applications
game theory require solving large game instances example several decision
support systems recently deployed homeland security domains recommend
policies game theoretic placing checkpoints airports pita jain
western portway tambe ordonez kraus parachuri scheduling federal air
marshals tsai rathi kiekintveld ordonez tambe patrolling ports shieh
yang tambe baldwin direnzo meyer baldwin maule meyer capabilities systems large amount fast
security games tambe another notable example algorithmic progress
led game theoretic poker agents competitive highly skilled human
opponents e g see zinkevich bowling burch sandholm
focus developing important general class games
includes security games poker well many familiar games precisely
study two player zero sum extensive form games efgs imperfect information
class games captures sequential interactions two strictly competitive players
situations make decisions uncertainty uncertainty caused
stochastic environment opponent actions directly
observable consider general sequential interactions uncertainty
many fast developed poker security domains
rely specific game structure
propose class finding exact approximate nash equilibrium solutions class efgs imperfect information leading exact
literature uses compact sequence form representation linear programming optimization techniques solve games type koller megiddo von
stengel von stengel exploits compact representation improve solution methods adopting algorithmic framework
decompositions known computational game theory literature oracle
mcmahan gordon blum oracle related methods constraint column generation used solving large scale optimization dantzig
wolfe barnhart johnson nemhauser savelsbergh vance exploit two
characteristics commonly found games first many cases finding solution
game requires small fraction possible strategies necessary
enumerate strategies solution wilson koller megiddo
second finding best response specific opponent strategy game computationally
much less expensive solving equilibrium addition best response
often make use domain specific knowledge heuristics speed calculations
even
sequence form double oracle integrates decomposition ideas oracle
compact sequence form representation efgs imperfect information iterative need generate
complete linear program game nash equilibrium solution main idea
create restricted game players choose limited
space possible strategies represented sequences actions solves
restricted game uses fast best response strategies
original unrestricted game perform well current solution restricted


fian exact double oracle zero sum efgs imperfect information

game strategies added restricted game process iterates
best response found improve solution case current solution
equilibrium original game typically solution found adding small
fraction strategies restricted game
begin presenting related work technical background notation
describe main three parts methods creating solving expanding valid restricted game finding best response strategies
added restricted game variants main loop controlling iterative
process solving restricted games adding strategies present formal analysis
prove converges nash equilibrium original game finally provide experimental evaluation runtime performance convergence
behavior several realistic games different characteristics including
border patrolling scenario phantom tic tac toe simplified variant poker
compare state art finding exact approximate solutions linear programming sequence form counterfactual regret
minimization cfr zinkevich johanson bowling piccione lanctot
experimental confirm requires fraction possible sequences solve game practice significantly reduces memory requirements
solving large games advances state art allows us exactly solve
much larger games compared existing moreover games admitting
equilibrium small support e sequences non zero probability
equilibrium achieves significant improvements computation time
finds equilibrium iterations hold without
domain specific knowledge incorporating domain specific heuristics
bounds straightforward way lead even significant
performance improvements analysis convergence rate shows approximative
bounds value game similar bit worse early stages
compared cfr however convergence behavior cfr long
tail finds exact solution much faster cfr

related work
solving imperfect information efgs computationally challenging task primarily due
uncertainty actions opponent stochastic environment
leading exact koller et al von stengel formulating
finding optimal strategy play linear program exploits
compact representation strategies sequences individual actions called sequence
form linear program linear size size game tree however
limited applicability since game tree grows exponentially
number sequential actions game common practice overcoming limited
scalability sequence form linear programming use approximation method
best known approximative include counterfactual regret minimization cfr
zinkevich et al improved versions cfr sampling methods lanctot waugh
zinkevich bowling gibson lanctot burch szafron bowling nesterovs
excessive gap technique egt hoda gilpin pena sandholm variants


fibosansky kiekintveld lisy pechoucek

monte carlo tree search mcts applied imperfect information games e g
see ponsen de jong lanctot
family counterfactual regret minimization learning methods informally described follows repeatedly traverses
game tree learns strategy play applying regret learning rule minimizes specific variant regret counterfactual regret information set
regret learning converges optimal strategy information set overall
regret bounded sum regret information set hence strategy
whole converges nash equilibrium main benefits include
simplicity robustness adapted generic games e g see lanctot
gibson burch zinkevich bowling cfr applied games imperfect
recall however operates complete game tree therefore requires
convergence information sets slow large games one desires
solution small error
another popular method excessive gap technique exploits convex properties
sequence form representation uses recent mathematical finding extreme
points smooth functions see hoda et al details main idea approximate finding pair equilibrium strategies two smoothed functions
guiding approximate solution although achieves faster
convergence comparison cfr less robust known whether
similar used general classes games less used practice
cfr egt operates complete strategy space sequences
monte carlo tree search mcts another family methods shown promise
solving large games particular perfect information board games go e g
lee et al cfr egt guaranteed nash
equilibrium convergence equilibrium solution formally shown
variants mcts imperfect information games contrary common
version mcts upper confidence bounds ucb selection function
converge incorrect solutions even simultaneous move games shafiei sturtevant
schaeffer simplest class imperfect information efgs mcts therefore general guarantee finding approximate optimal solution
imperfect information games one exception recent proof convergence mcts
certain selection methods simultaneous move games lisy kovarik lanctot
bosansky still mcts sometimes reasonable choice since produce
good strategies practice ponsen et al
contrary existing approximative approaches aims exact solution without explicitly considering strategy complete game tree
work combines compact sequence form representation double oracle algorithmic framework previous work double oracle framework focused primarily
applications normal form games restricted game expanded adding pure
best response strategies iteration one first examples solving games
double oracle principle mcmahan et al introduced doubleoracle proved convergence nash equilibrium experimentally verified
achieves computation time improvements search game
evader trying cross environment without detected sensors placed


fian exact double oracle zero sum efgs imperfect information

opponent double oracle reduced computation time several hours
tens seconds allowed solve much larger instances game similar success
domain specific double oracle methods demonstrated variety different domains inspired pursuit evasion games halvorson conitzer parr
security games played graph jain korzhyk vanek conitzer tambe pechoucek
letchford vorobeychik jain conitzer tambe
works tried apply iterative framework oracle
efgs primarily pure mixed strategies efgs first work exploited
iterative principle predecessor sequence form linear program formulation koller
megiddo authors use representation similar sequence form single player strategies opponent iteratively
added constraints linear program exponential number constraints
formulation seen specific variant oracle strategy space expanded gradually single player
generalization work since uses sequence form representation
players incrementally expands strategy space players
recent work done mcmahan thesis mcmahan followup work mcmahan gordon works authors investigated extension
double oracle normal form games extensive form case
double oracle efgs operates similarly normal form variant
uses pure mixed strategies defined efgs main disadvantage
basic version still requires large amount memory since pure strategy
efg large one action needs specified information set
exponential number possible pure strategies overcome disadvantage
authors propose modification double oracle keeps number
strategies restricted game bounded removes restricted game
strategies least used current solution restricted game
order guarantee convergence adds iteration restricted
game mixed strategy representing mean removed strategies convergence
guaranteed similarly fictitious play see mcmahan gordon details
bounding size restricted game low memory requirements however
converges extremely slowly take long time several hours
small game achieve small error see experimental evaluation
mcmahan mcmahan gordon
similar concept pure strategies efgs used iterative
designed poker work zinkevich et al work
expands restricted game strategies found generalized best response instead
pure best response strategies generalized best response nash equilibrium
partially restricted game player computing best response use pure
strategies original unrestricted game opponent restricted use
strategies restricted game however main disadvantages pure
mixed strategies efgs still present large memory requirements
exponential number iterations
contrast directly uses compact sequence form representation
efgs uses sequences building blocks e restricted game expanded


fibosansky kiekintveld lisy pechoucek

allowing sequences played next iteration sequences
sequence form solving restricted game reduces size restricted game
number iterations however introduces challenges constructing
maintaining restricted game ensuring convergence nash equilibrium
must solve converge correct solution

technical background
begin presenting standard game theoretic model extensive form games followed discussion common solution concepts computing solutions present sequence form representation state theart linear program computing solutions representation finally describe
oracle used solving normal form games summary
common notation provided table quick reference
extensive form games
extensive form games efgs model sequential interactions players game
games extensive form visually represented game trees e g see figure
nodes game tree represent states game state game corresponds
sequence moves executed players game node assigned player
acts game state associated node edge game tree
node corresponds action performed player acts node
extensive form games model limited observations players grouping nodes
information sets given player cannot distinguish nodes belong
information set player choosing action model represents
uncertainty environment stochastic events special nature player
formally two player efg defined tuple g n h z p u c n set
two players n use refer one two players
refer opponent h denotes finite set nodes game tree node
corresponds unique history actions taken players nature root
game hence use terms history node interchangeably denote z h
set terminal nodes game denotes set actions overload
notation use h represent set actions available player acting
node h h specify ha h h node h reached node h executing
action h say h prefix h denote h v h terminal
node z z define utility function player ui z r study zero sum
games ui z ui z holds z z
function p h n c assigns node player takes action
node c means nature player selects action node fixed
probability distribution known players use function c h denote
probability reaching node h due nature e assuming players play
required actions reach node h value c h product probabilities
assigned actions taken nature player history h imperfect observation
player modeled via information sets ii form partition nodes assigned
player h h p h every information set contains least one node


fian exact double oracle zero sum efgs imperfect information

node belongs exactly one information set nodes information set player
indistinguishable player nodes h single information set ii ii
set possible actions h action h uniquely identifies information set
ii cannot exist node h h belong information set
ii allowed played e h therefore overload notation
use ii denote set actions defined node h information set
assume perfect recall means players perfectly remember actions
information gained course game nodes
information set ii history actions player
nash equilibrium extensive form games
solving game requires finding strategy profile e one strategy player
satisfies conditions defined specific solution concept nash equilibrium ne
best known solution concept game theory describes behavior players
certain assumptions rationality nash equilibrium every player plays
best response strategies players let set pure strategies
player efgs pure strategy assignment exactly one action played
information set mixed strategy probability distribution set pure
strategies player denote set mixed strategies player
pair strategies use ui ui expected outcome
game player players follow strategies best response player
opponents strategy strategy ibr ui ibr ui
strategies strategy profile ne player
holds best response game multiple nes zero sum
setting equilibria value e expected utility every player
called value game denoted v finding
ne zero sum game polynomial computational complexity size game
ne solution concept somewhat weak extensive form games nash equilibrium
requires players act rationally however irrational strategies selected
parts game tree reachable players follow ne
strategies parts said equilibrium path reason ne
expect part game played therefore sufficiently restrict
strategies information sets overcome drawbacks number refinements
ne introduced imposing restrictions intention describing
sensible strategies examples include subgame perfect equilibrium selten used
perfect information efgs subgame perfect equilibrium forces strategy profile
nash equilibrium sub game e sub tree rooted node h
original game unfortunately sub games particularly useful imperfectinformation efgs hence refinements include strategic perfect equilibrium
selten sequential equilibrium kreps wilson quasi perfect equilibrium
van damme miltersen srensen first refinement avoids weakly
dominated strategies equilibrium strategies two player games van damme
p known undominated equilibrium sequential equilibrium tries
exploit mistakes opponent notion beliefs consistent


fibosansky kiekintveld lisy pechoucek

strategy opponent even information sets equilibrium path main
intuitions behind first two refinements combined quasi perfect equilibrium
even though solution described ne prescribe rational strategies
equilibrium path still valuable compute exact ne large extensive form
games several reasons focus zero sum games ne strategy guarantees
value game even equilibrium path words strategy
equilibrium path optimally exploit mistakes opponent still
guarantees outcome least value gained following equilibrium path moreover
refined equilibrium still ne calculating value game often starting
point many compute refinements example used
computing undominated equilibrium e g see ganzfried sandholm cermak
bosansky lisy normal form proper equilibrium miltersen srensen
sequence form linear program
extensive form games perfect recall compactly represented sequence
form koller et al von stengel sequence ordered list actions taken
single player history h number actions e length sequence
denoted empty sequence e sequence actions denoted
set possible sequences player denoted set sequences
players sequence extended single action taken
player denoted use v denote prefix games
perfect recall nodes information set ii share sequence actions
player use seqi ii denote sequence overload notation use
seqi h denote
leading node h seqi h
sequence actions player


seqi h h h seqi h h h since action uniquely identifies
information set ii nodes information set share history actions
player sequence uniquely identifies information set use function infi
denote information set last action sequence taken
empty sequence function infi information set root node
finally define auxiliary payoff function gi r extends utility
function nodes game tree payoff function gi represents expected
utility nodes reachable sequentially executing actions specified pair
sequences
x
gi
ui h c h

hz jn j seqj h

value payoff function defined leaf reachable sequentially executing actions sequences actions pair sequences
executed inner node h h z reached sequential execution actions node h reached current action executed
sequence h defined e
h formally define pair sequences
compatible exists node h h sequence every player equals
seqi h
compute nash equilibrium two player zero sum extensive form game
linear program lp polynomial size size game tree


fian exact double oracle zero sum efgs imperfect information

sequence form koller et al von stengel lp uses equivalent compact
representation mixed strategies players form realization plans realization
plan sequence probability player play sequence actions
assumption opponent choose compatible sequences actions
reach information sets actions specified sequence defined
denote realization plan player ri r equilibrium realization plans
computed following lp e g see shoham leyton brown p

vinfi

x

max vinfi
r v
x

vii

gi ri

seq
ii








ri
x




ri ri

ii ii seqi ii







aa ii

ri

solving lp yields realization plan player variables ri expected values
information sets player variables vii lp works follows player
maximizes expected utility value selecting values variables realization plan constrained equations probability playing empty
sequence defined equation probability playing sequence
equal sum probabilities playing sequences extended exactly one action
equation finding realization plan constrained best responding
opponent player ensured equation player selects
information set ii action minimizes expected utility value vii information set one constraint defined sequence last action
sequence determines best action played information set infi ii
expected utility composed expected utilities information sets reachable
playing sequence sum v variables left side expected utilities
leafs sequence leads sum g values right side constraint
double oracle normal form games
describe concept column constraint generation techniques applied previously
normal form games known double oracle mcmahan et al
normal form games represented game matrices rows matrix correspond
pure strategies one player columns correspond pure strategies opponent
values matrix cells represent expected outcome game players
play corresponding pure strategies zero sum normal form games solved linear
programming polynomial time size matrix e g see shoham leytonbrown p
figure shows visualization main structure double oracle
normal form games consists following three steps repeat
convergence


fibosansky kiekintveld lisy pechoucek

figure schematic double oracle normal form game
create restricted game limiting set pure strategies player
allowed play
compute pair nash equilibrium strategies restricted game lp
solving normal form games
player compute pure best response strategy equilibrium strategy
opponent found previous step best response may pure strategy
original unrestricted game
best response strategies computed step added restricted game game
matrix expanded adding rows columns continues
next iteration terminates neither players improve outcome
game adding strategy restricted game case players
play best response strategy opponent original unrestricted game
maintains values expected utilities best response strategies
throughout iterations values provide bounds value
original unrestricted game v perspective player minimal value
past best response calculations represents upper bound value
original game viu b maximal value past best response calculations
opponent represents lower bound value original game vilb note
bounds holds lower bound player equal negative value
upper bound opponent
ub
vilb vi

general computing best responses computationally less demanding solving
game since reduced single player optimization due fact bestresponse operate quickly e g exploiting additional domainspecific knowledge called oracles context incrementally
adds strategies one player called single oracle
incrementally adds strategies players called
double oracle double oracle typically initialized arbitrary
pair strategies one pure strategy player however use larger set
initial strategies selected domain specific knowledge
double oracle zero sum normal form games runs polynomial time
size game matrix since iteration adds least one pure strategy


fian exact double oracle zero sum efgs imperfect information

figure example two player extensive form game visualized game tree circle
player aims maximize utility value box aims minimize utility value bold
edges represent sequences actions added restricted game
restricted game finite pure strategies stops
iterations iteration polynomial since consists solving
linear program computing best responses relative performance doubleoracle compared solving linear program original unrestricted game
closely depends number iterations required convergence worst case
adds pure strategies solves original game although rarely
case practice estimating expected number iterations needed double oracle
converge however remains open
towards extensive form games
straightforward method applying double oracle efgs use pure
strategies defined efgs e assignments action information set realization
plans apply exactly described section e iteratively add
pure strategies unrestricted extensive form game restricted game matrix
however exponential number iterations exponentially large
restricted game worst case differs significantly idea since
directly operates compact sequences instead full strategies

sequence form double oracle extensive form games
describe sequence form double oracle solving extensive form
games imperfect information first give informal overview
use example game depicted figure illustrate key concepts afterwards formally define restricted game describe key components
following full example run
overall scheme double oracle framework described
previous section main difference uses sequences define
restrictions game tree restricted game model defined allowing
players use e play non zero probability subset sequences
original unrestricted game restricted subset sequences defines subsets
reachable actions nodes information sets original game tree consider example figure restricted game defined sequences ac ad circle
player x box player sequences represent actions allowed game


fibosansky kiekintveld lisy pechoucek

define reachable nodes history reference ax axc axd
reachable information sets circle player information set
box player
iteratively adds sequences allowed actions restricted
game similarly double oracle normal form games restricted game
solved standard zero sum extensive form game sequence form linear program best response searches original unrestricted game
sequences add restricted game sequences added restricted
game tree expanded adding actions nodes information sets
reachable sets allowed sequences process solving restricted
game adding sequences iterates sequences improve solution
added
two primary complications arise use sequences instead full
strategies double oracle due fact sequences necessarily define actions information sets strategy computed restricted game
may complete strategy original game define behavior
information sets restricted game may possible
play every action sequence allowed restricted game playing
sequence depend compatible sequence actions opponent
example game tree figure strategy circle player restricted game
specifies play information sets consequence second issue
inner nodes original unrestricted game temporarily become leafs
restricted game example box player add sequence restricted
game making node ay leaf restricted game since actions
circle player restricted game applicable node
solves complications two novel ideas first idea
concept default pure strategy denoted idef informally speaking
assumes player fixed implicit behavior defines player
default information set part restricted game described
default strategy idef specifies action every information set note
default strategy need represented explicitly could use large amount
memory instead defined implicitly rules selecting first action
deterministic method generating ordered set actions h node h
use default pure strategies map every strategy restricted game valid
strategy full game specifically strategy original unrestricted game selects
actions according probabilities specified strategy restricted game
every information set part restricted game information sets
plays according default pure strategy recall example figure
pure default strategy circle player ha c e gi e selecting leftmost
action information set hence strategy original unrestricted game use
strategy restricted game information sets select pure actions
e g information sets respectively
second key idea use temporary utility values cases
allowed actions played node restricted game inner
node original game called temporary leaf ensure correct convergence


fian exact double oracle zero sum efgs imperfect information

h
zh
idef
ri r
c h r
gi h r
seqi
infi ii

game tree nodes histories
leafs terminal states
implicit default pure strategy player
realization plan player sequence
probability reaching node due nature play
extension utility function nodes
gi h ui h c h h z gi h h terminal node h
z
sequence actions player leading node set nodes
information set
information set last action sequence executed

table outline main symbols used

temporary utilities must assigned provide bound
expected value gained continuing play given node uses
value corresponds expected outcome continuing game play assuming
player making choice temporary leaf uses default strategy
opponent plays best response assume add sequence box player
restricted game example tree figure temporary utility value node ay
would correspond value since default strategy information set play e
circle player next section formally describe method prove
correctness given temporary values
describe detail key parts method first formally define
restricted game methods expanding restricted game including details
key ideas introduced describe selecting
sequences allowed next iteration decision sequences add
calculating best response original unrestricted game game tree
search improved additional pruning techniques finally discuss different variations
main logic double oracle determines player
adds best response sequences current iteration
restricted game
section formally defines restricted game subset original unrestricted
game restricted game fully specified set allowed sequences define
sets nodes actions information sets subsets original unrestricted sets
allowed sequences denote original unrestricted game tuple
g n h z p u c restricted game g n h z p u c
sets functions associated restricted game use prime notation set
players functions p c remain
restricted game defined set allowed sequences denoted
returned best response indicated even allowed sequence
might playable full length due missing compatible sequences
opponent therefore restricted game defined maximal compatible set
sequences given set allowed sequences define maximal


fibosansky kiekintveld lisy pechoucek

subset sequences
h h j n seqj h j

n



equation means player every sequence exists
compatible sequence opponent allows sequence executed full
e sequentially executing actions sequences node h
reached seqj h j players j n
set sequences fully defines restricted game sets
tuple g derived node h restricted game
sequences must played reach h set players
h h h n seqi h



pair sequences nodes reachable executing pair sequences
included h actions defined node h restricted game
playing action node leads node restricted game
h h ha h

h h



nodes restricted game corresponding inner nodes original unrestricted
game may inner nodes restricted game therefore set leaves
restricted game union leaf nodes original game inner nodes
original game currently valid continuation restricted game
allowed sequences

z z h h h z h

explicitly differentiate leaves restricted game correspond leaves
original unrestricted game e z z leaves restricted game correspond
inner nodes original unrestricted game e z z since assigns
temporary utility values nodes latter case
information sets restricted game correspond information sets original
unrestricted game node h belongs information set ip h original game
holds restricted game define information set part
restricted game least one inner node belongs information
set included restricted game
ii ii ii h ii h h z



information set restricted game ii ii consists nodes
restricted game e h ii h h
finally define modified utility function u restricted game primary
reason modified utility function define temporary utility values leaves
set z z consider h z z temporary leaf player player acting
node p h moreover let ui h expected outcome game starting
node assuming players playing ne strategies original unrestricted
game modified utility function u leaf must return value lower bound


fian exact double oracle zero sum efgs imperfect information

value ui h due zero sum assumption value represents upper bound
value opponent setting value way ensures two things player
likely use sequences leading node h optimal strategies restricted game since
modified utility value upper bound actual value player adds
sequences best response prolong sequence seqi h leading node h
sequences would yield better expected value u later
counterexample setting value otherwise cause converge
incorrect solution calculate lower bound setting utility value
corresponds outcome original game player continues playing
br default strategy
default strategy idef opponent plays best response
valid lower bound since consider single strategy player acting
node h correspond default strategy considering strategies could allow
player improve value continuing node h leaf nodes
h z z set u h ui h
solving restricted game
restricted game defined section valid zero sum extensive form game
solved sequence form linear programming described section
computes ne restricted game solving pair linear programs
restricted sets h z modified utility function u
strategy restricted game translated original game
pure default strategy extend restricted strategy defined formally
ri mixed strategy represented realization plan player restricted
game define extended strategy r strategy identical strategy
restricted game sequences included restricted game correspond
default strategy idef sequence included restricted game

ri

r

ri idef
arg maxi vi
realization plan sequence allowed restricted game e

equal realization probability longest prefix sequence allowed
restricted game denoted setting remaining part sequence e
correspond default strategy player computation expressed
multiplication two probabilities overload notation use idef
remaining part sequence corresponds default strategy player
otherwise
iteration double oracle one sequence form lp solved
player compute pair ne strategies restricted game denote strategies
r r extended original unrestricted game
ri ri

default strategies
expanding restricted game
restricted game expanded adding sequences set updating
remaining sets according definition adding sequences


fibosansky kiekintveld lisy pechoucek

calculates stores temporary utility values leaves z z used
sequence form lp
updating restricted game linear programs modified correspond restricted game newly added information sets sequences
variables created linear programs constraints corresponding
information sets sequences created equations moreover constraints already existing linear program need updated sequence
added set immediate prefix sequence e sequence v
already part restricted game need update
constraint information sets ii seqi ii ensure consistency
strategies equation constraint corresponding sequence equation
addition updates equations assigned sequences opponent
g finally updates constraints previously used
utilities temporary leaf nodes longer leaf nodes restricted game
adding sequences
sequences player found best response sequence brs described section perspective sequence form double oracle
brs calculates pure best response player fixed
strategy opponent original unrestricted game pure best response specifies
action play information set currently reachable given opponents
extended strategy ri best response formally defined pure realization
plan ribr assigns integer values sequences realization plan
necessarily pure strategy original unrestricted game may
action specified every information set specifically action specified
information sets reachable due choices player due
zero probability realization plan opponent ri omitting actions
affect value best response information sets never reached
hence ribr holds r ui ribr ri ui r ri exists pure best
response strategy ibr ui ribr ri ui ibr ri sequences
used best response pure realization plan probability returned brs
call best response sequences
ribr



example run
demonstrate sequence form double oracle example game depicted figure example two players circle box circle aims
maximize utility value leafs box aims minimize utility value assume
choosing leftmost action information set default strategy
players game
starts empty set allowed sequences restricted game
hence sets current pair ri ri strategies equivalent
def next adds sequences correspond best response
idef
default strategy opponent example best response sequences
circle player ad box player sequences added


fian exact double oracle zero sum efgs imperfect information

step

b step

step

c step

e step

figure example steps sequence form double oracle two player
zero sum game circle player aims maximize utility value box aims minimize
utility value bold edges correspond sequences actions added restricted
game dashed boxes indicate information sets
set allowed sequences next set sequences restricted game
updated maximal compatible set sequences set cannot contain sequence
ad compatible sequence box player e x case allowed
restricted game yet sequence ad cannot fully executed moreover adding
sequences restricted game contain node ay actions e f
defined original unrestricted game however continuation
current restricted game yet hence node temporary leaf belongs z z
needs define value modified utility function u node
value u ay equal corresponds outcome game circle
player continues playing default strategy box player plays best response
complete first step summarize nodes information sets
included restricted game h contains nodes root node playing
action node ay two information sets information set node ay
added restricted game node leaf restricted game
playing sequences probability nash equilibrium restricted
game situation depicted figure b sequences shown bold edges
proceeds complete list steps summarized table second iteration sequences b bh added
restricted game box player add sequences iteration
best response extended equilibrium strategy circle player e playing
sequences ac ae probability ne updated restricted game changes
playing sequences b bh sequence probability third iteration
situation changes box player adds sequence x sequences


fibosansky kiekintveld lisy pechoucek

added circle player adding sequence x sequence ad becomes part
set fully executed due adding compatible sequence x ne
restricted game fully mixed sequences starting b played
ratio x ratio fourth iteration adds
sequence af restricted game best response circle player removes
assigned value u ay since node longer belongs set z stops
four iterations sequences added restricted game solution
translated solution original unrestricted
restricted game ri ri


game ri ri nash equilibrium original game
iteration





br
r
ad
b bh
b bh
af

br
r


x




b bh
ad b bh
ad af b bh




x
x

table steps sequence form double oracle applied example
consider small modification example game utility value
leaf following action f e node ayf case
need add sequence af ae restricted game improve
value restricted game note modified example game shows
needs set utility values nodes z z simply uses
unmodified utility function node ay treated zero utility
value value overestimates outcome actual continuation following node
original game circle player since sequences ae af never
part best response circle player converge incorrect
solution
best response sequence
purpose best response sequence brs generate sequences
added restricted game next iteration prove
best response better expected value uses sequences currently allowed
restricted game throughout section use term searching player represent
player computes best response sequences refer
player
brs calculates expected value pure best response opponents strategy ri returns set best response sequences well
expected value strategy extended strategy opponent
depth first search traverses original unrestricted
game tree behavior opponent fixed strategy given extended
realization plan ri save computation time best response use branch
bound search best response sequences uses bound
expected value inner node denoted bound represents minimal
utility value node currently evaluated needs gain order part


fian exact double oracle zero sum efgs imperfect information

require searching player h current node iik current information set r opponents
strategy min maxutility bounds utility values lower bound node h
w r seqi h c h
h z

return ui h w
else h z z

return u h w
end

sort h probability wa r seqi ha c ha
v h
h
wa


v h w wa maxutility

wa maxutility

v brsi ha

v

return

end

vh vh v

w w wa

else

return

end
end
return v h

figure brsi nodes players

best response sequence bound search able
prune branches certainly part best response sequence bound
set minutility root node
distinguish cases search evaluating
information set specifically node h assigned searching player
node assigned one players opponent player
chance node pseudocode two cases depicted figures
nodes opponent
first describe case used evaluates node h assigned
opponent searching player nature see figure main idea
calculate expected utility node according fixed strategy player
strategy known given extended realization plan ri
stochastic environment c throughout variable w represents
probability node realization probability opponent stochastic
environment line value iteratively decreased values wa represent realization probabilities currently evaluated action h finally vh expected
utility value node
evaluates actions descending order according probability
played r c lines first calculate lower bound


fibosansky kiekintveld lisy pechoucek

successor ha line lower bound minimal value must
returned recursive call brsi ha optimistic assumption
remaining actions yield maximum possible utility lower bound
exceed maximum possible utility game executed recursively
successors line note evaluate branches zero
realization probability line
possibilities pruning part search first
pruning possible currently evaluated node leaf restricted game
node inner node original node e h z z line
directly use value modified utility function u case since calculated
best response searching player default strategy opponent
applied successors node h since h z secondly cut occurs
lower bound successor larger maximum possible utility
game since value never obtained successor line finally cut
occurs cut one successors line
nodes searching player
nodes assigned searching player evaluates every action
state belongs current information set traverses states
descending order according probability occurrence given strategies
opponent nature line similar previous case iteration
calculates lower bound successor node line lower bound
minimal value must returned recursive call brsi h order
action selected best action information set optimistic
assumption action yields maximum possible utility value applying
remaining states information set performs recursive call
line action still could best information set e lower
bound exceed maximal possible utility game note cut
occurs one successors currently evaluated action longer best
action information set hence va set action evaluated
remaining nodes determines action selected
best one information set evaluates action remaining nodes
information set finally stores values best action
nodes information set line reused information set
visited e reaches different node h information set
ii line
cut occurs part search maximal possible value vah
smaller lower bound evaluating node h means regardless
action selected best action information set lower bound
node h reached hence cut occurs line cut occurs
information set information set cannot reached sequences
searching player leading information set cannot part best response
due propagating cut least one previous information set searching
player otherwise tight lower bound set bound first set


fian exact double oracle zero sum efgs imperfect information

require searching player h current node iik current information set ri opponents
strategy min maxutility bounds utility values lower bound node h
h z

return ui h r seqi h c h
end
v h already calculated

return v h
end
h h h ii

sort h
value ri seqi h c h
p descending according

w h h r seqi h c h
va h maxaction
h h

wh r seqi h c h

h

maxaction empty

wh minutility

else

vmaxaction w minutility va w wh maxutility

end

wh maxutility


vah brsi h


va va vah

end

end

maxaction arg maxaa h va

w w wh


h evaluated maxaa h vah

return

end
end

h
v h h h
store vmaxaction
h
return vmaxaction

figure brsi nodes searching player

information sets searching player therefore exists least one action
searching player never evaluated cut value va
action set cannot selected best action information set since
assume perfect recall nodes information set ii share sequence actions
seqi ii hence node h ii reached
main loop alternatives
introduce several alternative formulations main loop sequence form
double oracle general double oracle solve
restricted game equilibrium strategy player compute best responses
original game players continue next iteration however
sequence form lp formulated double oracle scheme way


fibosansky kiekintveld lisy pechoucek

iteration solve restricted game perspective single
player words formulate single lp described section computes
optimal strategy opponent restricted game player compute
best response player strategy means iteration
select specific player compute best response iteration call
selection process player selection policy
several alternatives player selection policy act domainindependent heuristics double oracle consider three possible policies
standard double oracle player selection policy selecting players iteration alternating policy selects one player switches
players regularly player selected one iteration player selected
following iteration finally worse player selection policy selects player
currently worse bound solution quality end iteration
selects player upper bound utility value away
current value restricted game formally


arg max fiviu b vilp



vilp last calculated value restricted game player intuition
behind choice bound precise missing sequences
player restricted game need added upper bound overestimated case best response sequence run player
next iteration add sequences tighten bound case tie
alternating policy applied order guarantee regular switching players
experimentally compare policies impact overall performance
sequence form double oracle see section

theoretical
section prove sequence form double oracle converge nash equilibrium original unrestricted game first formally define
strategy computed best response sequence brs prove lemmas
characteristics brs strategies finally prove main convergence
note variations main loop described section affect
correctness long player selection policy ensures improvement made brs one player brs run
opponent next iteration
realization plan player restricted game g brs r
lemma let ri

returns sequences corresponding realization plan ribr unrestricted game
ribr part pure best response strategy r value returned
value executing pair strategies ui r ribr
searches game tree selects action maximizes value
proof brs ri
game player information sets ii assigned player reachable given
strategy opponent r opponents nodes calculates expected value



fian exact double oracle zero sum efgs imperfect information

defined value according pure action default
according ri
def
defined chance nodes returns expected value
strategy ri
node sum values successor nodes weighted probabilities
node h successors maximal possible value node h
maximal possible value playing r selections nodes
belong achieves maximal value hence form best response strategy
r
denote value returned brs
brevity use v brs ri
equal ui r ribr
realization plan player restricted game g let
lemma let ri

vi value original unrestricted game g player

v brs ri
vi



value best response r
proof lemma showed v brs ri

v
valid strategy original unrestricted game g v brs ri

vi cannot value game since player strategy r achieves better
utility contradiction
realization plan player returned lp
lemma let ri

restricted game g let vilp value restricted game returned lp

v brs ri
vilp




proof realization plan ri
part nash equilibrium strategy zero sum
lp
game guarantees value vi
g best response computation original
unrestricted game g selects actions restricted game g creates best
response game g well obtaining value vilp best response selects action
allowed restricted game g two cases
case best response strategy uses action temporary leaf h z z
player makes decision leaf otherwise value temporary leaf
would directly returned brs value temporary leaf underestimated player restricted game modified utility function u
def
estimated brs computation best response default strategy
value best response increase including action
case best response strategy uses action allowed g internal node
restricted game h z occur nodes assigned player
actions player going g probability zero r brs takes action
maximum value nodes assigned player reason selecting action
leading outside g greater equal value best action g
v lp
lemma assumptions previous lemma v brs ri

returns sequences added restricted game g next iteration



fibosansky kiekintveld lisy pechoucek

proof proof previous lemma brs player improve
value lp vilp selecting action present g
performed node h included g makes decision let
pair sequences leading h construction restricted game
next iteration sequence sequence ensures executed full
part restricted game
note lemmas would hold utility values u temporary
leaves h z z set arbitrarily sets values temporary leaf h
player p h continues playing default strategy opponent p h
playing best response utility values temporary leaves set arbitrarily
used brs speed calculation proposed see
figure line lemma need hold cases value
node h strictly overestimates optimal expected value player p h case
best response value opponent may lower optimal outcome


v brs rp h vp h

hand brs use temporary values u
node lemma violated best response value strictly higher
player p h even though sequences added restricted game
theorem sequence form double oracle extensive form games described previous section terminates

v brs ri
v brs ri vilp vi



happens finite number iterations game finite
strategies r r nash equilibrium original unrestricted game
proof first continues equalities hold
v brs r lemma lemma know
v brs ri

v lp restricted game following itersome player holds brs ri

ation larger least one action continues worst case
restricted game equals complete game g g cannot extended
case brs cannot better response vi stops due
lemma
condition theorem holds found ne complete
br brs r best response r
game lemma know ri


complete game however value best response strategy zero sum
game value game strategy r optimal part nash
equilibrium game

experiments
present experimental evaluation performance sequence form
double oracle efgs compare two state art


fian exact double oracle zero sum efgs imperfect information

baselines full sequence form lp referred fulllp counterfactual regret minimization cfr first baseline standard exact method
solving sequence form efg cfr one leading approximate applied efg experimental demonstrate advantages double oracle
three different classes realistic efgs test impact different
variants main loop described section
compare three variants sequence form double oracle b
variant best responses calculated players iteration
sa calculates best response single player iteration according
simple alternating policy swp variant best response
calculated single player according worse player selection policy
variants double oracle use default strategy first
action applicable state played default
since standardized collection zero sum extensive form games benchmark purposes use several specific games evaluate double oracle
identify strengths weaknesses games selected
evaluate performance different conditions games differ maximal
utility players gain causes imperfect information structure
information sets one key characteristics affects performance
double oracle relative size support nash equilibria e number sequences used ne non zero probability exist ne
small support must necessarily add large fraction sequences
restricted game solution mitigating advantages double oracle
present two types games double oracle significantly outperforms fulllp instances search game motivated border patrol phantom
tic tac toe present simplified version poker doubleoracle improve computation time however fulllp
limited scalability due larger memory requirements cannot solutions
larger variants poker double oracle able solve instances
principal interest developing generic methods solving extensive form
games therefore implemented generic framework modeling arbitrary extensive form games use domain specific knowledge
implementation rely specific ordering actions drawbacks
generic implementation higher memory requirements additional overhead
domain specific implementation could improve performance
eliminating auxiliary data structures run experiments
single thread intel cpu running ghz given
maximum gb memory java heap space used ibm cplex solving
linear programs parameter settings use single thread barrier solution

addition runtimes analyze speed convergence double oracle compare one state art approximative counterfactual regret minimization cfr implemented cfr domain independent way
source code available home authors



fibosansky kiekintveld lisy pechoucek

pseudocode work lanctot p principle sufficient
cfr maintain set information sets apply regret learning rule
information set however maintaining traversing set effectively
domain independent manner could affected implementation generic extensiveform games data structures e generating applicable actions states game
applying actions etc therefore use implementation cfr traverses
complete game tree held memory maintain fairness comparison
guarantee maximal possible speed convergence cfr time
necessary build game tree included computation time cfr
test domains
search games first test belongs class search pursuit evasion games
often used experimental evaluation double oracle mcmahan et al
halvorson et al search game two players patroller defender
evader attacker game played directed graph see figure
evader aims cross safely starting node e destination node
defender controls two units move intermediate nodes shaded areas
trying capture evader occupying node evader turn
players move units simultaneously current node adjacent node
units stay location exception evader cannot stay
two leftmost nodes pre determined number turns made without player
winning game draw example win tie loss game utility
values set
players unaware location actions player one exception
evader leaves tracks visited nodes discovered defender visits
nodes later game includes option evader avoid leaving tracks
special move slow move requires two turns simulate evader covering
tracks
figure shows examples graphs used experiments patrolling units
move shaded areas p p start node shaded
areas even though graph small concurrent movement units implies large
branching factor one turn thus large game trees nodes
experiments used three different graphs varied maximum number turns
game altered ability attacker perform slow
moves labeled sa slow moves allowed sd otherwise
phantom tic tac toe second game blind variant well known game
tic tac toe e g used lanctot et al game played board
two players cross circle attempt place identical marks horizontal vertical
diagonal row win game blind variant players unable observe
opponents moves player knows opponent made move
turn moreover player tries place mark square already occupied
opponents mark player learns information place mark
square utility values game set


fian exact double oracle zero sum efgs imperfect information

figure three variants graph used experiments search game refer
g left g middle g right
uncertainty phantom tic tac toe makes game large nodes
addition since one player try several squares move successful players
necessarily alternate making moves rule makes structure
information sets rather complicated since opponent never learns many attempts
first player actually performed single information set contain nodes different
depths game tree
poker games poker frequently studied literature example large
extensive form game imperfect information include experiments simplified
two player poker game inspired leduc holdem
version poker player starts amount chips
players required put number chips pot called ante next
step nature player deals single card player opponent unaware
card betting round begins player fold opponent wins pot
check let opponent make next move bet first add amount
chips pot call add amount chips equal last bet opponent
pot raise match increase bet opponent raise made
players betting round ends nature player deals one card
table second betting round rules begins second betting
round ends outcome game determined player wins private card
matches table card opponents card match none players
cards matches table card private card higher private card
opponent opponent folds utility value amount chips player
lost player wins game draw pot split
experiments alter number types cards
types cards leduc number cards type set leduc
maximum length sequence raises betting round ranging set
leduc number different sizes bets e amount chips added pot
bet raise actions ranging set leduc

search games search game scenarios sequence form
double oracle particularly successful applied games nes
small support exist figure shows comparison running times fulllp
variants double oracle note logarithmic scale variants


fibosansky kiekintveld lisy pechoucek









fulllp
b
sa
swp
time log scale

time log scale



g sd

g sd

g sd

g sa

g sa







g sa

search game scenarios depth

fulllp
b
sa
swp

g sd

g sd

g sd

g sa

g sa

g sa

search game scenarios depth

figure comparison running times different graphs slow moves
allowed sa disallowed sd depth set left subfigure right subfigure
missing values fulllp indicate runs memory

double oracle several orders magnitude faster fulllp
apparent fully connected graph g generates largest game tree
slow moves allowed depth set takes almost seconds fulllp
solve instance game variants double oracle solve
game less seconds moreover depth increased fulllp
unable solve game due memory constraints fastest variant swp
solved game less seconds similar obtained graphs
graph g induced game difficult double oracle
depth set takes almost minutes fulllp solve instance
fastest variant swp solved game seconds reason even though
game tree largest complex structure information sets
due limited compatibility among sequences players patrolling
unit p observes tracks top row node second patrolling unit p capture
evader top row node middle row node
comparing different variants sequence form double oracle
consistent variant consistently better game since
double oracle variants typically able compute nash equilibrium quickly
however swp often fastest settings difference quite significant
speed variant offers apparent g graph average
instances search game sa uses computation time b
swp uses
table shows breakdown cumulative computation time spent different components double oracle solving restricted game lp calculating best
responses br creating valid restricted game selecting sequences add
validity due size game computation
best response sequences takes majority time typically around larger
instances creating restricted game solving takes small fraction
total time noticeable size final restricted game small


fian exact double oracle zero sum efgs imperfect information

b

sa

swp

cfr

bounds interval size log scale







e





time





figure convergence variants double oracle cfr search
game domain axis displays current approximation error

fulllp
b
sa
swp

overall





lp





br





validity





iterations





















table cumulative running times different components double oracle
iterations size restricted game terms number sequences compared
size complete game shown scenario g depth allowed
slow moves
compared original game since number sequences second player
defender less sequences defender
finally analyze convergence rate variants double oracle
depicted figure size interval given bounds
viu b vilb defines current error double oracle viu b vilb
convergence rate cfr depicted error cfr calculated
way sum best response values current mean strategies
cfr see variants double oracle perform
similarly error drops quickly iterations later version
quickly converges exact solution game
double oracle quickly correct sequences actions compute
exact solution spite size game comparison cfr
quickly learn correct strategies information sets convergence
long tail seconds error cfr equal dropping
slowly hour error cfr quite significant considering value
game case
phantom tic tac toe phantom tic tac toe confirm game
suitable sequence form double oracle due size game
baseline fulllp cfr ran memory able


fibosansky kiekintveld lisy pechoucek

sa

swp
b
sa
swp


time log scale

bounds interval size log scale

b








e






time







random

domain dependent

different action ordering phantom tic tac toe

figure left comparison convergence rate double oracle variants phantom tic tac toe right comparison performance double oracle variants
phantom tic tac toe domain specific move ordering default strategy used

fulllp
b
sa
swp

overall
n




lp





br





validity





iterations





















table cumulative running times different components double oracle
game phantom tic tac toe
solve game therefore compare times different variants
double oracle figure left subfigure shows overall performance three
variants double oracle form convergence graph see
performance two variants similar performance sa swp
almost identical hand b converges significantly
slower
time breakdown variants double oracle shown table
similarly previous case majority time spent calculating
best responses variants double oracle swp variant
fastest one converged significantly fewer iterations compared sa
variant iterations twice expensive b variant
present demonstrate potential combining sequenceform double oracle domain specific knowledge every variant doubleoracle use move ordering domain specific heuristics move
ordering determines default strategy recall uses first action
default strategy player direction search best response
replacing randomly generated move ordering heuristic one
chooses better actions first significant improvement performance
variants see figure right subfigure even though changes
rest variant able solve game less hours
took hours fastest swp variant


fian exact double oracle zero sum efgs imperfect information



fulllp
b
sa
swp

time log scale


time



fulllp
b
sa
swp












r

r

r

r

increasing number allowed raise actions

b

b

b

b

increasing size possible bets

figure comparison running times different variants simplified poker
game left subfigure shows computation times increasing number raise
actions allowed right subfigure shows computation times increasing number
different bet sizes raise bet actions
poker games poker represents game double oracle perform well sequence form lp often faster smaller instances one significant
difference compared previous games size ne support larger
around sequences larger instances secondly game trees poker games
relatively shallow imperfect information game due nature
double oracle require larger number iterations add
sequences restricted game sequences player added even
largest poker scenarios order exact solution however increasing
depth branching factor size game grows exponentially fulllp
able solve largest instances due memory constraints
figure shows selected simplified poker variants
left subfigure computation times increasing depth game allowing
players raise players allowed raise opponent certain number
times remaining parameters fixed types cards cards type
different betting sizes size game grows exponentially number possible
sequences increasing player r scenario computation time
fulllp directly related size tree increases exponentially
increasing depth note standard scale hand increase
less dramatic variants double oracle swp variant
fastest largest scenario fulllp solved instance seconds
took seconds swp finally fulllp able solve games
increase length r due memory constraints computation time
double oracle increases marginally
right subfigure figure shows increase computation time increasing number different bet sizes raise bet actions remaining parameters
fixed types cards cards type raise actions allowed
game grows exponentially increasing branching factor number sequences
increases player b scenario computation time


fibosansky kiekintveld lisy pechoucek

b

sa

swp

cfr

b

swp

cfr


bounds interval size log scale

bounds interval size log scale



sa






e






e











time















time







figure comparison convergence variants double oracle
cfr two variants simplified poker types cards cards
type raise actions allowed different bet sizes left subfigure
raise actions allowed different bet sizes right subfigure

fulllp
b
sa
swp

overall





lp





br





validity





iterations





















table cumulative running times different components double oracle
iterations sizes restricted game terms number sequences compared
size complete game shown poker scenario raise
actions allowed different betting values types cards cards type
increases exponentially well note logarithmic scale
even increasing branching factor double oracle variants tend slower
solving fulllp however fulllp ran memory largest
b setting double oracle variants able exact solution less
memory
comparing different variants double oracle convergence
graph see figure decomposition computation times see table shows
swp fastest variant selected scenario nearly poker
scenarios decomposition overall time shows majority computation
time spent solving restricted game lp decomposition shows
swp typically faster due lower number iterations addition
final size restricted game typically smallest variant average
instances poker games sa uses computation time b
swp uses computation time
convergence poker games slower compared search games similar size note
logarithmic scale figure comparing double oracle variants cfr
shows interesting left subfigure due size game speed
cfr convergence nearly double oracle first


fian exact double oracle zero sum efgs imperfect information

iterations however double oracle continue converge roughly
rate able exact solution error cfr decreases
slowly scenario depicted left subfigure cfr converged
error value game case seconds
hour error dropped scenarios shallow game trees
larger branching factor convergence cfr faster beginning compared
double oracle right subfigure figure however main disadvantage
cfr long tail convergence still case error seconds
still value game
discussion
experimental support several conclusions demonstrate
sequence form double oracle able compute exact solution much larger
games compared state art exact sequence form linear
program moreover experimentally shown realistic games
small fraction sequences necessary solution game cases
double oracle significantly speed computation time
indicate swp variant typically fastest cases selecting
player currently worse bound performance swp version
add important sequences prove better sequences adjust
upper bound value faster
comparing speed convergence double oracle state ofthe art approximative cfr showed cfr quickly approximates solution
first iterations however convergence cfr long tail cfr
able exact solution larger games reasonable time another interesting
observation games convergence rate double oracle
cfr similar first iterations double oracle continue
rate exact solution long tail convergence remains cfr
despite fact implementation cfr advantage complete
game tree including states histories memory
unfortunately difficult characterize exact properties games
double oracle perform better terms computation time compared
certainly double oracle suitable games
equilibria large support due necessity large number iterations
however small support equilibrium sufficient condition apparent
due two graphs shown poker experiments depth game tree
branching factor increased even though game grows exponentially
size support decreases cases behavior double oracle
quite different conjecture games longer sequences suit
double oracle better since several actions form best response sequences
added single iteration contrasts shallow game trees large
branching factors iterations necessary add multiple actions however
deeper analysis identify exact properties games suitable open
question must analyzed normal form games first


fibosansky kiekintveld lisy pechoucek

conclusion
present novel exact solving two player zero sum extensive form games
imperfect information combines compact sequence form representation extensive form games iterative algorithmic framework double oracle
methods integrates two successful approaches solving large scale games
yet brought together general class games addresses
main idea restrict game allowing players play
restricted set sequences available sequences actions iteratively expand
restricted game time fast best response although worst
case double oracle may need add possible sequences experimental
different domains prove double oracle exact nash
equilibrium prior constructing full linear program complete game therefore
sequence form double oracle reduces main limitation sequence form
linear programmemory requirementsand able solve much larger games compared
state art methods moreover since able identify sequences
promising actions without domain specific knowledge provide significant
runtime improvements
proposed another crucial advantage compared current state
art double oracle framework offers decomposition computing
nash equilibrium separate sub including best response
choice default strategy constructing solving restricted
game developed solutions sub domain independent manner however view general framework
specialized domain specific components take advantage structure specific
improve performance sub lead substantial
improvements speed number iterations well reducing
final size restricted game demonstrated potential domain specific
game phantom tic tac toe another example fast best response
operate public tree e compact representation games
publicly observable actions see johanson bowling waugh zinkevich exploited games poker finally formal analysis identifies key properties
domain specific implementations need satisfy guarantee convergence
correct solution game
opens large number directions future work represents
class methods solving extensive form games imperfect information operates
differently common approaches e g counterfactual regret minimization
many possible alternatives improve performance remain
investigated examples include sophisticated calculation utility values
temporary leaves alternative strategies expanding restricted game removing
unused sequences restricted game broader analysis sequenceform double oracle approximation technique performed possibly
exploring alternative approximative best response sampling e g
monte carlo techniques


fian exact double oracle zero sum efgs imperfect information

several theoretical questions could investigated first performance double oracle depends strongly number iterations
sequences need added however theoretical question regarding expected
number iterations thus speed convergence double oracle
explored even simpler game e g games normal form
analysis simpler needed identify general properties games
double oracle methods tend faster identify optimal way expanding
restricted game

acknowledgements
earlier versions published european conference artificial
intelligence ecai bosansky kiekintveld lisy pechoucek conference
autonomous agents multi agent systems aamas bosansky kiekintveld lisy
cermak pechoucek major additions full version include novel
detailed description parts introduction analysis
different policies player selection main loop double oracle
experiments phantom tic tac toe domain together thorough
analysis experimental domains including analysis convergence
experimental comparison cfr finally extended analysis
related work
supported czech science foundation grant p
u army office award w nf

references
barnhart c johnson e l nemhauser g l savelsbergh w p vance p h
branch price column generation solving huge integer programs
operations
bosansky b kiekintveld c lisy v cermak j pechoucek doubleoracle computing exact nash equilibrium zero sum extensiveform games proceedings international conference autonomous agents
multiagent systems aamas pp
bosansky b kiekintveld c lisy v pechoucek iterative
solving two player zero sum extensive form games imperfect information
proceedings th european conference artificial intelligence ecai pp

cermak j bosansky b lisy v practical performance refinements
nash equilibria extensive form zero sum games proceedings european
conference artificial intelligence ecai pp
dantzig g wolfe p decomposition principle linear programs operations

ganzfried sandholm improving performance imperfect information
games large state action spaces solving endgames computer


fibosansky kiekintveld lisy pechoucek

poker imperfect information workshop national conference artificial
intelligence aaai
gibson r lanctot burch n szafron bowling generalized sampling variance counterfactual regret minimization proceedings th
aaai conference artificial intelligence pp
halvorson e conitzer v parr r multi step multi sensor hider seeker games
proceedings joint international conference artificial intelligence ijcai
pp
hoda gilpin pena j sandholm smoothing techniques computing
nash equilibria sequential games mathematics operations

jain conitzer v tambe security scheduling real world networks
proceedings international conference autonomous agents multiagent
systems aamas pp
jain korzhyk vanek conitzer v tambe pechoucek double
oracle zero sum security games graph proceedings th
international conference autonomous agents multiagent systems aamas
pp
johanson bowling waugh k zinkevich accelerating best response
calculation large extensive games proceedings nd international joint
conference artificial intelligence ijcai pp
koller megiddo n complexity two person zero sum games
extensive form games economic behavior
koller megiddo n von stengel b efficient computation equilibria
extensive two person games games economic behavior
koller megiddo n finding mixed strategies small supports extensive form games international journal game theory
kreps wilson r sequential equilibria econometrica
lanctot monte carlo sampling regret minimization equilibrium computation decision making large extensive form games ph thesis university alberta
lanctot gibson r burch n zinkevich bowling regret
learning extensive form games imperfect recall proceedings th
international conference machine learning icml pp
lanctot waugh k zinkevich bowling monte carlo sampling
regret minimization extensive games advances neural information
processing systems nips pp
lee c wang h chaslot g hoock j b rimmel teytaud tsai r
hsu c hong p computational intelligence mogo revealed
taiwans computer go tournaments ieee transactions computational intelligence ai games


fian exact double oracle zero sum efgs imperfect information

letchford j vorobeychik optimal interdiction attack plans proceedings th international conference automonous agents multiagent
systems aamas pp
lisy v kovarik v lanctot bosansky b convergence monte carlo tree
search simultaneous move games advances neural information processing
systems nips vol pp
mcmahan h b robust domains stochastic outcomes adversaries partial observability ph thesis carnegie mellon university
mcmahan h b gordon g j fast bundle anytime
poker convex games journal machine learning proceedings
track
mcmahan h b gordon g j blum presence cost
functions controlled adversary proceedings international conference
machine learning pp
miltersen p b srensen b fast finding proper strategies
game trees proceedings symposium discrete soda pp

miltersen p b srensen b computing quasi perfect equilibrium
two player game economic theory
pita j jain western c portway c tambe ordonez f kraus parachuri
p deployed armor protection application game theoretic model
security los angeles international airport proceedings th international conference autonomous agents multiagent systems aamas pp

ponsen j v de jong lanctot computing approximate nash equilibria robust best responses sampling journal artificial intelligence
jair
sandholm state solving large incomplete information games
application poker ai magazine special issue algorithmic game theory

selten r reexamination perfectness concept equilibrium points
extensive games international journal game theory
selten r spieltheoretische behandlung eines oligopolmodells mit nachfragetrgheit
oligopoly model demand inertia zeitschrift fur die gesamte staatswissenschaft
shafiei sturtevant n schaeffer j comparing uct versus cfr simultaneous games ijcai workshop general game playing
shieh e b yang r tambe baldwin c direnzo j meyer g baldwin c w
maule b j meyer g r protect deployed game theoretic system
protect ports united states international conference autonomous
agents multiagent systems aamas pp


fibosansky kiekintveld lisy pechoucek

shoham leyton brown k multiagent systems algorithmic gametheoretic logical foundations cambridge university press
tambe security game theory deployed systems lessons
learned cambridge university press
tsai j rathi kiekintveld c ordonez f tambe iris tool
strategic security allocation transportation networks categories subject
descriptors proceedings th international conference autonomous agents
multiagent systems aamas pp
van damme e relation perfect equilibria extensive form games
proper equilibria normal form games game theory
van damme e stability perfection nash equilibria springer verlag
von stengel b efficient computation behavior strategies games economic
behavior
wilson r computing equilibria two person games extensive form
management science
zinkevich johanson bowling piccione c regret minimization
games incomplete information advances neural information processing
systems nips
zinkevich bowling burch n generating equilibria
massive zero sum games proceedings national conference artificial
intelligence aaai pp




