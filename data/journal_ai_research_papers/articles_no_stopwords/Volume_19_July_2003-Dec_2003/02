journal artificial intelligence

submitted published

answer set action costs
thomas eiter
wolfgang faber

eiter kr tuwien ac
faber kr tuwien ac

institut fur informationssysteme tu wien
favoritenstr wien austria

nicola leone

leone unical

department mathematics university calabria
rende cs italy

gerald pfeifer
axel polleres

pfeifer dbai tuwien ac
polleres kr tuwien ac

institut fur informationssysteme tu wien
favoritenstr wien austria

abstract
recently answer set programming proposed towards realizing declarative systems present language k c
extends declarative language k action costs k c provides notion admissible optimal plans plans whose overall action costs within given limit resp
minimum plans e cheapest plans demonstrate novel language allows
expressing nontrivial tasks declarative way furthermore utilized
representing optimality criteria computing shortest plans
least number steps refinement combinations cheapest fastest plans
study complexity aspects language k c provide transformation logic programs
solved via answer set programming furthermore report experimental selected experience encouraging answer set may
valuable expressive systems intricate
naturally specified solved

introduction
recently several declarative languages formalisms introduced allow
intuitive encoding complex involving ramifications incomplete information non deterministic action effects parallel actions see e g giunchiglia lifschitz
lifschitz b lifschitz turner mccain turner giunchiglia cimatti
roveri eiter et al b b
systems designed generate plans accomplish goals
practice one often interested particular plans optimal respect objective
function quality cost plan measured common simple objective
function length plan e number time steps achieve goal many systems
tailored compute shortest plans example cmbp cimatti roveri gpt
bonet geffner compute shortest plans step consists single action
graphplan blum furst descendants smith weld weld
c

ai access foundation morgan kaufmann publishers rights reserved

fie iter faber l eone p feifer p olleres

anderson smith compute shortest plans step actions might executed
parallel
however equally important objective functions consider particular
executing actions causes cost may desire plan minimizes overall cost
actions
answer set subrahmanian zaniolo dimopoulos nebel koehler
niemela lifschitz b recent declarative plans encoded answer sets logic program issue optimal plans objective value
function addressed detail far see section details
address issue present extension language k eiter et al b b
user may associate costs actions taken account
process main contributions work follows
define syntax semantics language kc modularly extends
language k costs associated action extending action declarations
optional cost construct describes cost executing respective action
action costs static dynamic may depend current stage plan
action considered execution dynamic action costs important
natural applications simple variant well known traveling salesperson
cumbersome model solve similar languages
analyze computational complexity language k c provide completeness major tasks propositional setting locate
suitable slots polynomial hierarchy classes derived provide insight intrinsic computational difficulties respective
give handle efficient transformations optimal knowledge representation formalisms particular logic programs
awareness complexity analysis action
costs implemented transformation answer set programming done system prototype developed prototype ready experiments available
http www dlvsystem com k
finally present applications extended language capable
easily modeling optimal criteria computing cheapest plans
minimize overall action costs shortest plans least number steps
refinement combinations viz shortest plans among cheapest
cheapest plans among shortest notice knowledge task
addressed works far
extension k action costs provides flexible expressive tool representing
moreover since ks semantics builds states knowledge rather
states world deal incomplete knowledge plan quality
best knowledge completely novel
experience encouraging answer set powerful logic programming
engines allows development declarative systems intricate


fia nswer et p lanning u nder action c osts

tasks specified solved work complements extends preliminary
presented previous work eiter et al
remainder organized follows next section briefly review
language k informally presenting main constituents features simple
example define section extension k action costs consider
first examples usage kc section devoted analysis complexity issues
section consider applications k c types particular optimization
expressed k c consider practical examples section
present transformation k c answer set programming section report
prototype implementation experiments discussion related work section
conclude outlook ongoing future work

short review language k
section give brief informal overview language k refer eiter et al b
appendix formal details assume reader familiar basic ideas
action languages particular notions actions fluents goals plans
illustration shall use following running example
bridge crossing four persons want cross river night plank
bridge hold two persons time lamp must used
crossing pitch dark planks missing someone must bring lamp back
others tricks throwing lamp halfway crosses etc allowed
fluents states state k characterized truth values fluents describing relevant
properties domain discourse fluent may true false unknown state
states k states knowledge opposed states world fluent true
false easily enforced k desired formally state consistent set
possibly negated legal fluent instances
action applicable precondition list literals fluents holds
current state execution may cause modification truth values fluents
background knowledge static knowledge invariant time k domain
specified normal disjunction free datalog program single answer set
viewed set facts example background knowledge specifies four persons
person joe person jack person william person averell

type declarations fluent action must declaration ranges arguments specified instance
crosstogether x requires person x person x

specifies arguments action crosstogether two persons cross bridge together

across x requires person x
used instead inequality avoid symmetric rules



fie iter faber l eone p feifer p olleres

specifies fluent describing specific person side river literals
requires must classical literals static background knowledge person x
person literals built predicates x implementation k dlv k system eiter faber leone pfeifer polleres currently supports built predicates
b b b obvious meaning less less equal inequality
strings numbers arithmetic built ins b c b c stand integer
addition multiplication predicate int x enumerates integers
user defined limit
causation rules causation rules rules brevity syntactically similar rules
action language c giunchiglia lifschitz lifschitz lifschitz turner
basic form
caused f b

conjunction fluent action literals possibly including default negation b
conjunction fluent literals possibly including default negation f fluent literal
informally rule reads b known true current state known true
previous state f known true current state well part
part allowed empty means true causation rule called
dynamic part empty called static otherwise
causation rules used express effects actions ramifications example
caused across x cross x across x
caused across x cross x across x

describe effects single person crossing bridge direction
initial state constraints static rules apply states initial states
may unique expressed keywords initially preceding
sequences rules latter describes initial state constraints must satisfied
initial state example
initially caused across x

enforces fluent across false initial state x satisfying declaration
fluent across e persons rule irrelevant subsequent states
executability actions

expressed k explicitly instance

executable crosstogether x haslamp x
executable crosstogether x haslamp

declares two persons jointly cross bridge one lamp action
may multiple executability statements statement
executable cross x

empty body says cross executable provided type restrictions x
respected dually
nonexecutable b

prohibits execution action condition b satisfied example
nonexecutable crosstogether x differentsides x



fia nswer et p lanning u nder action c osts

says persons x cross bridge together different sides bridge
case conflicts nonexecutable overrides executable
default strong negation k supports strong negation written note however fluent f state neither f f needs hold case knowledge
f incomplete addition weak negation interpreted default negation answer set
semantics gelfond lifschitz permitted rule bodies allows natural modeling inertia default properties well dealing incomplete knowledge general
example
caused haslamp joe haslamp jack haslamp william haslamp averell

expresses conclusion default joe lamp whenever evident
persons
macros

k provides number macros syntactic sugar example

inertial across x

informally states across x holds current state across x held previous state
unless across x explicitly known hold macro expands rule
caused across x across x across x

moreover totalize knowledge fluent declaring total f shortcut
caused f f

caused f f

intuitive meaning rules unless truth value f derived cases
f resp f true considered
domains k domain pd h hd rii background
knowledge action fluent declarations rules executability conditions r
p hpd qi domain pd query
q g gm gm gn l
g gn ground fluents l plan length instance goal query
across joe across jack across william across averell

asks plans bring four persons across steps
plans defined transition semantics execution set actions
transforms current state state optimistic plan p sequence p ha al
sets action instances al trajectory hhs hs
hsl al sl ii legal initial state state sl literals goal true
starting legal transition hs modeling execution actions
must executable transforms state followed legal transitions
ti hsi ai si l cf appendix details plan sequential
l e step consists one action plans enforced
including keyword noconcurrency
besides optimistic plans k support stronger secure conformant plans secure
plan must guaranteed work circumstances eiter et al b regardless
incomplete information initial state possible nondeterminism action effects


fie iter faber l eone p feifer p olleres

better readability following describe k p
strictly terms sets declarations rules executability conditions optionally use
compact representation k programs following general form
fluents
actions
initially

goal

fd
ad
ir
cr
q

optional sections fluents consist lists fluent declarations f
action declarations ad initial state constraints ir executability conditions causation rules
cr respectively together background knowledge goal query q specify
k p hh hd rii qi given f plus ad r ir plus
cr
solving bridge crossing
constructs k encoding bridge crossing assuming joe
initially carries lamp shown figure simple five step plans l
joe carries lamp brings others across one
p h crosstogether joe jack cross joe crosstogether joe william
cross joe crosstogether joe averell

actions costs
language k system prototype dlv k already express solve
involved tasks cf eiter et al b however k dlv k alone offer means
finding optimal plans objective cost function general different criteria plan
optimality relevant optimality wrt action costs shown next example
slight elaboration bridge crossing well known brain teasing riddle
quick bridge crossing persons bridge crossing scenario need
different times cross bridge namely minutes respectively walking two
implies moving slower rate possible four persons get across within
minutes
first thought infeasible since seemingly optimal plan joe fastest
keeps lamp leads others across takes minutes altogether surprisingly
see optimal solution indeed takes minutes
order allow elegant convenient encoding optimization
extend k language k c one assign costs actions
syntax kc
let act f l var denote finite sets action names fluent names variable symbols
furthermore let lact lf l ltyp denote sets action fluent type literals respectively
format input files system prototype presented section



fia nswer et p lanning u nder action c osts

actions

cross x requires person x
crosstogether x requires person x person x
takelamp x requires person x

fluents

across x requires person x
differentsides x requires person x person
haslamp x requires person x

initially across x haslamp joe


executable crosstogether x haslamp x
executable crosstogether x haslamp
nonexecutable crosstogether x differentsides x
executable cross x haslamp x
executable takelamp x
nonexecutable takelamp x haslamp differentsides x
caused
caused
caused
caused

across x crosstogether x
across crosstogether x
across x crosstogether x
across crosstogether x

across x
across
across x
across

caused across x cross x across x
caused across x cross x across x
caused haslamp x takelamp x
caused haslamp x takelamp x haslamp x
caused differentsides x across x across
caused differentsides x across x across
inertial across x
inertial across x
inertial haslamp x
noconcurrency
goal

across joe across jack across william across averell l

figure k encoding bridge crossing
formed action names fluent names predicates background knowledge including
built predicates respectively terms nonempty finite set constants con
kc extends action declarations k costs follows
definition action declaration k c form
p x xn requires tm costs c c ck



p act arity n x xn var tm c ck
ltyp every xi occurs tm c integer constant variable
set variables occurring tm c ck denoted var distinguished
variable time var var time time occur tm


fie iter faber l eone p feifer p olleres

keyword requires omitted k keyword omitted
costs c optional state parameters action must variables
fixed values informally means parameters action must typed
requires part condition asserts cost locally defined given stage
plan referenced global variable time conditions ensure
variables known type information action parameters static e depend
time
domains k c defined k
example elaborated bridge crossing declaration cross x
extended follows suppose predicate walk person minutes background knowledge
indicates person takes minutes cross may simply declare
cross x requires person x costs wx walk x wx

semantics kc
semantically kc extends k cost values actions points time plan p
ha al step l actions ai executed reach time point
ground action p x xn legal action instance action declaration wrt k c
domain pd h hd rii exists ground substitution var
time xi xi n tm unique answer
set background knowledge called witness substitution p x xn
informally action instance legal satisfies respective typing requirements action costs
formalized follows
definition let p x xn legal action instance declaration form
let witness substitution

costs part empty

cost p x xn
val c c ck

undefined otherwise

unique answer set val con defined integer value
integer constants non integer constants
reference variable time possible define time dependent action costs shall consider example section cost introduce well defined legal action instances
define action cost values follows
definition legal action instance p x xn well defined iff holds
time point witness substitution time cost
integer ii cost cost holds two witness substitutions coincide
time defined costs well defined unique cost time point given
costi cost
definition condition ensures cost value exists must integer
condition ii ensures value unique e two different witness substitutions
evaluate cost part integer cost value


fia nswer et p lanning u nder action c osts

action declaration well defined legal instances well defined
fulfilled database terms variables x xn together time functionally determine value c framework semantics k c domain pd h hd rii
well defined well defined action declarations pd rest assume
well definedness kc unless stated otherwise
costi define costs plans
definition let p hpd q l plan p ha al
p cost defined
costp p

pl

j

p


cost


j
aaj

plan p optimal p costp p costp p plan p p e p least cost
among plans p cost p denoted cost p given costp
costp p p optimal plan p
particular costp p p hi e plan void note cost p defined
plan p exists
usually one estimate upper bound plan length know exact
length optimal plan although defined optimality fixed plan length l
see section appropriate encodings extended optimality plans
length l
besides optimal plans plans bounded costs interest motivates following definition
definition plan p p admissible wrt cost c cost p p c
admissible plans impose weaker condition plan quality optimal plans
particularly relevant optimal costs crucial issue long cost stays within given
limit optimal plans difficult compute might face questions make
airport within one hour enough change buy coffee etc amount
admissible shall see computing admissible plans complexity wise
easier computing optimal plans
optimal solution quick bridge crossing
model quick bridge crossing k c first extend background knowledge
follows predicate walk describes time person needs cross max determines
two persons slower
walk joe walk jack walk william walk averell
max b walk walk b b
max b b walk walk b b

next modify declarations cross crosstogether figure adding costs
following subscripts dropped clear context



fie iter faber l eone p feifer p olleres

cross x requires person x costs wx walk x wx
crosstogether x requires person x person x
costs wmax walk x wx walk wy max wx wy wmax

declaration takelamp remains unchanged time hand lamp negligible
modified domain step plan reported section cost actually optimal plan length l however relinquish first intuition
fastest person joe lamp consider varying plan length
following step plan
p h crosstogether joe jack cross joe takelamp william
crosstogether william averell takelamp jack cross jack
crosstogether joe jack

costp p thus p admissible respect cost means quick
bridge crossing positive answer fact p least cost plans length
l thus optimal step plan moreover p least cost plans emerge
consider plan lengths thus p optimal solution quick bridge crossing
arbitrary plan length
bridge crossing incomplete knowledge
language k well suited model involve uncertainty incomplete
initial states non deterministic action effects qualitative level enriched language k c
gracefully extends secure conformant plans well must reach goal circumstances eiter et al b b precisely optimistic plan ha secure
applicable evolution system starting legal initial state first
action set plan length l executed e legal transition hs
exists every possible state next action set executed etc
performed actions goal accomplished cf appendix formal definition
secure plans inherit costs optimistic plans different possibilities define
optimality secure plans may consider secure plan optimal least cost
among optimistic plans
among secure plans
first alternative might secure plans optimal
secure plans reason second alternative appears appropriate
definition secure plan p optimal p least cost among
secure plans p e costp p costp p secure plan p p secure cost
p denoted costsec p costsec p costp p p optimal secure plan p
notion admissible secure plans defined analogously
example assume known least one person bridge scenario lamp
neither exact number lamps allocation lamps persons known
four desperate persons ask plan brings safely across bridge need
fast secure plan works possible initial situations k c modeled
replacing initially part following declarations


fia nswer et p lanning u nder action c osts

initially total haslamp x
caused false haslamp joe haslamp jack
haslamp william haslamp averell

first statement says person lamp second least
one must lamp detailed discussion use total statement
modeling incomplete knowledge non determinism refer eiter et al b
easily see optimal secure solution take least minutes since original
case joe lamp one possible initial situations cost
optimistic plan optimal plan lengths however secure plan
optimal plan lengths requires least steps higher cost different
optimistic plans need one extra step beginning makes sure one
walk first joe jack lamp effected proper takelamp action
example plan following cost
p h takelamp joe crosstogether joe jack cross joe
takelamp william crosstogether william averell takelamp jack
cross jack crosstogether joe jack

easily check p works every possible initial situation thus optimal secure
plan plan length moreover arbitrary plan length

computational complexity
section address computational complexity k c complementing similar
language k eiter et al b
complexity classes
assume reader familiar basic notions complexity theory p np
reductions completeness see e g papadimitriou references therein
recall polynomial hierarchy ph contains classes p p p p pi
p
p
npi pi co pi pi pi particular p np p pnp
note classes contain decision e answer yes
checking well definedness deciding plan existence computing
plan search instance possibly empty finite set
solutions exists solve possibly nondeterministic must compute
alternative solutions set computation branches empty precisely
search solved transducers e turing machines equipped output tape
machine halts accepting state contents output tape
computation observe nondeterministic machine computes partial multi valued function
analog np class npmv contains search computed nondeterministic turing machine polynomial time precise definition see selp
man analogy pi pi mv npmvi denote generalization
npmv machine access pi oracle
analogs classes p pi given classes fp f pi
contain partial single valued functions instance


fie iter faber l eone p feifer p olleres

computable polynomial time resp pi oracle say abusing terminology
search fp resp fpi partial single valued function f fp
resp f fpi f f undefined iff example
computing satisfying assignment propositional cnf fsat computing optimal tour
traveling salesperson tsp f p view cf papadimitriou
partial function f polynomial time reducible another partial function g
polynomial time computable functions h h f h g h
g h defined whenever f defined hardness completeness defined usual
setting
focus following questions
checking well definedness decide whether given action description well defined wrt
given domain pd resp whether given domain pd well defined
admissible decide whether p admissible optimistic secure
plan exists wrt given cost value c plan
optimal optimal optimistic secure plan given
notice eiter et al b focused deciding existence optimistic secure plans
rather actually finding plans presented detailed study complexity task
restrictions ground propositional confine
discussion case p hpd q l look polynomial length
plans e plan length l bounded polynomial size input
shall consider mainly ground propositional assume
domains well typed unique model background knowledge computed
polynomial time general case well known complexity logic programming
cf dantsin eiter gottlob voronkov already evaluating background knowledge
exptime hard thus provably intractable recall following
appear directly follow previous work eiter et al b
proposition deciding given propositional p sequence p ha
al action sets whether given sequence ht tl legal trajectory witnessing
p optimistic plan p feasible polynomial time ii whether p secure plan
p p complete

start considering checking well definedness interesting investigate
non ground case assuming background knowledge already evaluated way
assess intrinsic difficulty task obtaining following
theorem complexity checking well definedness given k c domain pd
h hd rii unique model checking well definedness given action declaration form wrt pd ii well definedness pd p complete


fia nswer et p lanning u nder action c osts

proof membership violated nonempty costs part legal action
instance p x xn exist witness substitutions
time time cost val c cost val c val c val c
witness substitution cost val c integer
guessed checked via witness substitution polynomial time along
note definition variables must substituted constants
background knowledge including numbers must values time occurs
c ck given decide help np oracle summary disproving welldefinedness nondeterministically possible polynomial time np oracle hence
checking well definedness co p p membership part ii follows
since well definedness pd reduces well definedness action declarations p
closed conjunctions
hardness hardness reduction deciding whether quantified boolean
formula qbf
q xy c ck
ci li li k disjunction literals l j atoms
x x xn xn xm true without loss generality may assume
ci contains three necessarily distinct literals positive negative
construct domain pd follows background knowledge
bool bool
pos pos pos pos pos pos pos
neg neg neg neg neg neg neg

bool declares truth values facts pos x x x neg x x x state
truth assignments x x x positive clause x x x resp
negative clause x x x satisfied
rest domain pd consists single action declaration form
p v vn requires bool v bool vn costs c ck


ci





pos vi vi vi ci xi xi xi
neg vi vi vi ci xi xi xi

k

example clause c x x x mapped c pos v v v easy see
legal action instance p b bn corresponds truth assignment x
given xi bi n furthermore cost value defined iff
formula c ck true thus well defined wrt pd iff q true since pd

efficiently constructible proves p hardness
observe ground case checking well definedness much easier since substitutions need guessed test proof theorem polynomial thus assumption
efficient evaluation background program obtain
corollary ground propositional case checking well definedness action description wrt kc domain pd h hd rii resp pd whole possible
polynomial time


fie iter faber l eone p feifer p olleres

remark checking well definedness expressed task k
logic program refer eiter faber leone pfeifer polleres b details
turn computing admissible plans
theorem complexity admissible polynomial plan lengths deciding whether
given well defined propositional hpd qi optimistic admissible
plan wrt given integer b np complete finding plan complete npmv ii
deciding whether hpd qi secure admissible plan wrt given integer b p complete
computing plan p mv complete hardness holds cases fixed plan length
proof refer appendix finally address complexity computing
optimal plans
theorem complexity optimal polynomial plan lengths computing
optimal optimistic plan hpd q l k c fp complete ii computing optimal
secure plan hpd q l k c fp complete hardness holds cases even plan
length l fixed
proof found appendix
remark case unbounded plan length complexity computing plans increases requires least exponential time general since plans might exponential length
size thus practical terms constructing plans infeasible
since occupy exponential space furthermore follows previous eiter et al
b deciding existence admissible optimistic resp secure plan wrt given cost pspace complete resp nexptime complete leave detailed
analysis complexity aspects k c work

applications
cost efficient versus time efficient plans
section language k c used minimize plan length combination
minimizing costs plan especially interesting settings parallel
actions allowed cf kautz walser lee lifschitz
domains parallel actions kautz walser propose criteria optimized instance number actions needed number necessary time steps
parallel actions allowed well combinations two criteria exploiting
action costs proper modeling solve optimization sort example
single plans minimal number actions simply assigning cost possible
actions
consider following optimization
plan minimal cost cheapest plan given number steps
plan minimal time steps shortest plan
shortest among cheapest plans


fia nswer et p lanning u nder action c osts

cheapest among shortest plans
already defined optimal plans far
express terms optimal cost plans well extend elaboration respect
combinations
c heapest p lans



g iven p lan l ength

guiding example refer blocks world parallel moves allowed apart
finding shortest plans minimizing total number moves issue kc encoding
domain plans serializable shown figure serializability means parallel
actions non interfering executed sequentially order e parallel plan
arbitrarily unfolded sequential plan
fluents

b l requires block b location l
blocked b requires block b
moved b requires block b

actions

move b l requires block b location l costs



executable move b l b l
nonexecutable move b l blocked b
nonexecutable move b l blocked l
nonexecutable move b l move b l b b block l
nonexecutable move b l move b l l l
nonexecutable move b b move b l
caused
caused
caused
caused

b l move b l
blocked b b b
moved b move b l
b l moved b b l

figure kc encoding blocks world domain
emerging initial state goal state depicted figure
modeled background knowledge bw
block block block block block block
location table
location b block b

extending program figure follows
initially table table table
goal

table table table l



















figure simple blocks world instance


fie iter faber l eone p feifer p olleres

move penalized cost minimization total number moves
let pl denote plan length l
l optimal plan involves six moves e cost p
p h move table move table move table move move move

unfolding steps plan gives rise similar plans length l cost
l among others following optimal plan cost
p h move table move move table move move

plan parallelized two steps plan length l
obtain optimal plans similar p extended void steps thus plan cheapest
plan lengths cost needs three steps note shortest parallel plans length
expensive explained
hortest p lans
intuitively possible include minimization time steps cost function
describe preprocessing method given k domain pd list q ground literals
upper bound plan length generates p pd q
optimal plans p correspond shortest plans reach q pd steps e
plans hpd q l l minimal assume action costs specified
original domain pd minimizing time steps target
first rewrite domain pd pd follows introduce distinct fluent
gr distinct action finish defined follows
fluents
actions

gr
finish costs time

intuitively action finish represents final action use finish plan later
action occurs expensive plan assign time cost fluent gr goal
reached shall true remain true soon goal reached triggered
finish action
modeled k c adding following statements section
program
executable finish q gr
caused gr finish
caused gr gr

furthermore want finish occur exclusively want block occurrence
action goal reached therefore every action pd add
nonexecutable finish

add gr part executability condition finally avoid inconsistencies static dynamic effects soon goal reached add gr
part causation rule pd except nonexecutable rules remain unchanged
define p pd q hpd gr take plan length since
need one additional step execute finish action
need rewrite nonexecutable rules respective actions already switched
rewriting executability conditions



fia nswer et p lanning u nder action c osts

construction easy see optimal plan p ha aj aj ai
p must aj finish aj ai
j thus following desired property
proposition optimal plans p correspondence shortest plans reaching q pd precisely p ha aj optimal optimistic plan
p pd q aj finish p ha aj optimistic plan
hpd q j j hpd q j optimistic plan j j
blocks world example method get step plans choose
compute shortest plans plan lengths set upper bound large enough
plans length l guaranteed exist trivial bound total number legal
states general exponential number fluents
however many typical applications inherent much smaller bound plan length
instance blocks world n blocks goal configuration reached within
n sinit sgoal steps sinit sgoal numbers stacks initial goal
state respectively therefore upper bound plan length simple instance
remark minimizing plan length efficient upper bound
close optimum known searching minimum length plan iteratively increasing
plan length may much efficient bound known since weak upper bound
lead explosion search space cf benchmarks section
hortest

among

c heapest p lans

previous subsection shown calculate shortest plans k programs without
action costs combining arbitrary k c programs rewriting method described easy
want shortest among cheapest plans use rewriting
little change setting costs actions except finish least high
highest possible cost finish action obviously plan length
simply modify action declarations
requires b costs c

p multiplying costs factor
requires b costs c c c

lets action costs take priority cost finish compute plans
satisfying criterion let p denote resultant
proposition optimal plans p correspondence shortest among
cheapest plans reaching q pd within steps precisely p ha aj
optimal optimistic plan p pd q aj finish p
ha aj plan pj hpd q j j ii p ha aj
plan pj hpd q j j costpj p costpj p
costpj p costpj p j j
figure shows p blocks world instance one optimal plan p
one solve blocks world sequentially first unstacking blocks table
n sinit steps building goal configuration n sgoal steps



fie iter faber l eone p feifer p olleres

fluents

b l requires block b location l
blocked b requires block b
moved b requires block b
gr

actions

move b l requires block b location l costs c c
finish costs time



executable move b l b l gr
nonexecutable move b l blocked b
nonexecutable move b l blocked l
nonexecutable move b l move b l b b block l
nonexecutable move b l move b l l l
nonexecutable move b b move b l
caused
caused
caused
caused

b l gr move b l
blocked b b b gr
moved b gr move b l
b l moved b gr b l

executable finish table table
table gr
caused gr finish
caused gr gr
nonexecutable move b l finish
initially table table table
goal

gr

figure computing shortest plan blocks world instance minimum number
actions

p h move table move move table
move move finish

costp p compute optimal cost wrt optimization subtracting cost finish dividing thus
need minimum moves reach goal minimal number steps obviously steps
except final finish action e thus need least steps plan five moves
c heapest

among

hortest p lans

use rewriting optimization cost functions adapted similarly
previous subsection cost action finish takes priority
actions costs end sufficient set cost finish high enough achieved
multiplying factor f higher sum action costs legal action instances
steps j let p denote resulting
proposition optimal plans p correspondence cheapest among
shortest plans reaching q pd within steps precisely p ha aj


fia nswer et p lanning u nder action c osts

optimal optimistic plan p pd q aj finish p
ha aj plan pj hpd q j j ii p ha aj
plan pj hpd q j j j j j j costpj p
costpj p
example possible moves thus could take f
would set costs finish time however need take account
actions actually occur simultaneously example six blocks
moved parallel therefore sufficient set f assign finish cost
time f time accordingly action declarations modified follows
actions

move b l requires block b location l costs
finish costs c c time

optimal plan modified p
p h move table move table move table
move move move finish

costp p compute optimal cost wrt optimization simply
subtracting cost finish e since finish occurs time point
consequently need minimum moves shortest plan length
indeed seen optimization
represented kc remark transformations p p p work restrictions
secure sequential plans well
traveling salesperson
another illustrating example optimal cost introduce elaboration
traveling salesperson
traveling salesperson tsp start classical traveling salesperson tsp given set cities connections e g roads airways certain costs
want know economical round trip visits cities exactly returns
starting point tour exists figure shows instance representing capitals
austrian provinces dashed line flight connection connections roads
connection marked costs traveling hours
brg bregenz
eis eisenstadt
gra graz
ibk innsbruck
kla klagenfurt
lin linz
sbg salzburg
stp st plten
vie vienna

lin
sbg





ibk





vie









kla

figure tsp austria

eis








stp




brg



gra



fie iter faber l eone p feifer p olleres

represent kc follows background knowledge sp defines two predicates
city c conn f c representing cities connections associated costs connections traveled ways
conn brg ibk conn ibk sbg conn ibk vie conn ibk kla
conn sbg kla conn sbg gra conn sbg lin conn sbg vie
conn kla gra conn lin stp conn lin vie conn lin gra
conn gra vie conn gra eis conn stp vie conn eis vie
conn stp eis conn vie brg
conn b c conn b c
city conn

possible encoding tsp starting vienna vie k c program figure includes two
actions traveling one city another directly returning starting point
end round trip soon cities visited
actions

travel x requires conn x c costs c
return x requires conn x vie c costs c

fluents

unvisited end
c requires city c
visited c requires city c



executable travel x x
nonexecutable travel x visited
executable return x x
nonexecutable return x unvisited
caused unvisited city c visited c
caused end return x
caused travel x
caused visited c c
inertial visited c

noconcurrency
initially vie
goal
end

figure traveling salesperson
ten optimal step solutions cost first five
others symmetrical
p h travel vie stp
travel lin sbg
return brg
p h travel vie eis
travel sbg gra
return brg
p h travel vie eis
travel gra kla
return brg
p h travel vie lin
travel gra kla

travel stp eis
travel sbg kla

travel eis stp
travel gra kla

travel eis stp
travel kla sbg

travel lin stp
travel kla sbg

travel eis gra travel gra lin
travel kla ibk travel ibk brg
travel stp lin travel lin sbg
travel kla ibk travel ibk brg
travel stp lin travel lin gra
travel sbg ibk travel ibk brg
travel stp eis travel eis gra
travel sbg ibk travel ibk brg



fia nswer et p lanning u nder action c osts

return brg
p h travel vie gra
travel lin sbg
return brg


travel gra eis travel eis stp travel stp lin
travel sbg kla travel kla ibk travel ibk brg


tsp variable costs let us consider elaboration tsp assume
costs traveling different connections may change trip note three
five solutions example include traveling st polten eisenstadt vice versa
second day let us assume salesperson starts monday face
exceptions might increase cost trip instance heavy traffic jams expected
tuesdays route st polten eisenstadt ii salesperson shall use flight
connection vienna bregenz mondays expensive business class tickets
available connection beginning week deal different costs
respective connections depending particular day
end first add background knowledge sp predicate cost b w c
representing cost c traveling connection b weekday w take exceptional
costs account
cost b w c conn b c int w w w ecost b w
ecost b w conn b c cost b w c c c

original costs predicate conn b c represent defaults overridden
explicitly adding different costs instance represent exceptions ii add
cost stp eis cost vie brg

setting exceptional costs two critical connections weekdays coded integers
monday sunday represent mapping time steps weekdays
following rules add sp
weekday
weekday w w w weekday w w
weekday weekday

note although modified background knowledge sp stratified since cost defined
cyclic negation total well founded model thus unique answer set
finally change costs traveling returning k c program figure
actions

travel x requires conn x c costs c
weekday time w cost x w c
return x requires conn x vie c costs c
weekday time w cost x vie w c

since costs p includes traveling st polten eisenstadt second
day increased due exception four plans remain optimal note
unlike default costs exceptional costs apply bidirectionally exception
affect p p furthermore due exception ii symmetrical round trips starting
flight trips bregenz longer optimal
presented encoding proves flexible allows adding arbitrary exceptions
connection weekday simply adding respective facts moreover even
involved scenarios exceptions defined rules modeled


fie iter faber l eone p feifer p olleres

small example resource restrictions
although resources main target following encoding
shows action costs used order model optimization resource consumption
cases important resource real world money instance let us consider
buying selling lee lifschitz
pocket newspaper costs magazine costs
enough money buy one newspaper two magazines
kc encoded compact way following background facts
item newspaper item magazine

combined following short k c program
actions

buy item number requires item item price int number
costs c c number price

fluents

item number requires item item price int number



executable buy item number
nonexecutable buy item n buy item n n n
caused item number buy item number

goal

newspaper magazines

action buy executable one must buy two different amounts certain
item obviously admissible plan wrt cost exists optimal plan
h buy newspaper buy magazine cost p therefore answer

considers positive action costs directly allow modeling full
consumer producer provider relations resources general favor clear non ambiguous
definition optimality instance allowing negative costs one could add producer
action make existing plan cheaper whereas costs guaranteed increase
monotonically allowing clear definition plan costs optimality
hand encode kinds resource restrictions fluents represent resources model production consumption action effects fluents
add restrictions constraints allows us model even complex resource scheduling
optimization however remains restricted action costs

transformation logic programming
section describe action costs implemented means
transformation answer set programming extends previous transformation eiter et al
maps ordinary k disjunctive logic programs answer
set semantics gelfond lifschitz takes advantage weak constraints cf buccafurri
leone rullo implemented dlv system faber pfeifer eiter
faber leone pfeifer addition translation adapted
language smodels simons niemela soininen
disjunctive logic programs weak constraints
first give brief review disjunctive logic programs weak constraints


fia nswer et p lanning u nder action c osts

syntax

disjunctive rule short rule r construct
v v b bk bk bm



ai bj classical literals function free first order alphabet n
k part left resp right head resp body r omitted
let h r set head literals b r b r b r
set body literals b r b bk b r bk bm strong
constraint rule empty head n
weak constraint construct
b bk bk bm w



w integer constant variable occurring b bk bi classical literals
b r defined
disjunctive logic program dlpw simply program finite set rules constraints
weak constraints superscript w indicates potential presence weak constraints
semantics answer sets program without weak constraints defined usual gelfond lifschitz lifschitz one difference though consider
inconsistent answer sets answer sets program weak constraints defined
selection answer sets weak constraint free part optimal answer sets
weak constraint c form violated instance conjunction
satisfied respect candidate answer set e exists substitution mapping
variables c herbrand base b bk bk bm
call w violation value c wrt violation cost c wrt denoted
costc sum violation values violating substitutions c wrt cost
denoted cost
x
cost
costc
c weak constraints

e sum violation costs weak constraints wrt answer set
selected called optimal answer set cost minimal answer sets
buccafurri et al know given head cycle free disjunctive program deciding whether query q true optimal answer set p complete respective class
computing answer set fp complete together section indicates translations optimal head cycle free disjunctive logic programs
weak constraints language smodels feasible polynomial time
translating kc dlpw
extend original transformation lp p naturally maps k p
weak constraint free program eiter et al translation lp w p optimal
answer sets lpw p correspond optimal cost plans k c p
colon w stems dlv language allows specify priority layer colon
need priority layers translation stick dlv syntax
weak constraint c admissible possible violation values candidate answer sets integers
thus w variable must guarantee w bound integer



fie iter faber l eone p feifer p olleres

basically lp p fluent action literals extended additional time parameter
executability conditions well causations rules modularly translated rule rule corresponding program rules constraints disjunction used guessing actions
executed plan point time
r eview



ranslation lp p

basic steps translation k programs logic programs follows cf eiter et al
details
step macro expansion

first replace macros k program definitions

step background knowledge background knowledge p already given logic
program included lp p without modification
step auxiliary predicates

represent steps add following facts lp p

time time l next next l l

l plan length query q g l p hand
step causation rules causation rules mapped rules lp p adding type information extending fluents actions time stamp time next example
caused across x cross x across x

leads rule across x cross x across x person x next
lp p variables type information person x across x
across x taken type declaration added helps avoid unsafe logic programming rules
step executability conditions similarly executability condition translated disjunctive rule guessing whether action occurs certain time step running example
executable cross x haslamp x

becomes cross x cross x haslamp x person x next
encodes guess whether time point action cross x happen type information person x added well next ensure last time point
step initial state constraints initial state constraints transformed static causation
rules step constant instead variable thus need auxiliary predicate time stamp instance
initially caused across x

becomes adding type information across x person x
step goal query
goal

finally query q

g gm tm gm tm gn tn l

translated follows goal reached ary predicate symbol
goal reached g l gm tm l gm tm l gn tn l
goal reached


fia nswer et p lanning u nder action c osts

e xtending



ranslation



action c osts

extended translation lpw p kc p first includes rules lp pnc pnc
p stripping cost parts furthermore following step added
step action costs

action declaration form nonempty costs part add

rule rd form

costp x xn c p x xn tm
c ck u



costp symbol u variables time u optimization
u present u occurs elsewhere r
costp x xn c c

ii weak constraint wcd form



example cross action quick bridge crossing translated
costcross x wx cross x person x walk x wx
costcross x wx wx

showed previous work eiter et al answer sets lp p correspond
trajectories optimistic plans p following theorem states similar correspondence
lpw p optimal plans p define consistent set ground literals sets
asj j act ssj f f j f lf l j
theorem answer set correspondence let p hpd qi well defined k c
let lpw p program
optimistic plan p ha al p supporting trajectory hhs
hs hsl al sl ii p exists answer set lp w p
aj asj j l sj ssj j l costp p costlpw p
ii answer set lpw p sequence p ha al solution p e
optimistic plan witnessed trajectory hhs hs hsl al sl ii
costp p costlpw p aj asj sk ssk j l
k l
proof resp correspondence k eiter et al details
refer appendix
definitions optimal cost plans optimal answer sets conclude
following
corollary optimal answer set correspondence well defined k c
p hpd q l trajectories hhs hsl al sl ii optimal plans p p
correspond optimal answer sets lp w p aj asj j l
sj ssj j l
proof aj weak constraint causes violation value cost j furthermore
p onlypcost violations thus candidate answer set optimal
costlpw p lj aaj costj costp p minimal e corresponds optimal
plan

similar correspondence holds admissible plans


fie iter faber l eone p feifer p olleres

corollary answer set correspondence admissible plans well defined k c p hpd q l trajectories hhs hsl al sl ii admissible plans p p wrt cost c correspond answer sets lp w p costlpw p c
aj asj j l sj ssj j l
secure introduced technique check security optimistic plan
certain instances means logic program eiter et al
method carries action costs straightforward way optimal resp admissible secure plans similarly computed answer set programming
alternative translation smodels
apart presented translation weak constraints one could choose alternative
translation answer set programming smodels simons et al supports
another extension pure answer set programming allowing minimize sets predicates
could used alternative formulation step
step

action declarations nonempty costs parts add rule form
cost p x xn c tm c ck u



similar step two differences action name p parameter add
l n parameters constant x n l maximum arity actions
pd necessary order get unique arity l predicate cost furthermore add
occurs p x xn p x xn tm



second rule adds parameters achieve unique arity l
predicate occurs smodels syntax compute optimal plans adding
minimize occurs x xl cost x xl c c

note smodels support disjunction rule heads need modify step
expressing action guess via unstratified negation smodels choice rules

implementation
implemented experimental prototype system dlv k solving k eiter et al improved version prototype capable optimal
admissible respect extended syntax k c available experiments
http www dlvsystem com k
dlvk realized frontend dlv system faber pfeifer eiter et al
first hand transformed described previous section
dlv kernel invoked produce answer sets optimistic optimal
action costs defined answer sets simply translated back suitable output user
printed
case user specified secure conformant performed system
check security plans computed normal non optimal simply done
checking answer set returned right transforming back user output case


fia nswer et p lanning u nder action c osts

optimal secure hand candidate answer set generation dlv kernel
intercepted kernel proceeds computing candidate answer sets returning answer
set minimal violation cost value running candidates order generate
optimal secure plans frontend interrupts computation allowing answer sets
represent secure plans considered candidates
checking plan security done rewriting translated program wrt candidate answer
set plan order verify whether plan secure rewritten check program tested
separate invocation dlv kernel details system architecture refer
eiter et al
usage
suppose background knowledge program depicted figure cost extensions
section stored files crossing bk crossing plan invoking
program command line
dlv fpcrossing plancrossing bk planlength

compute optimal plans solving seven steps output
supporting trajectory following optimal plan
plan crosstogether joe jack cross joe takelamp william
crosstogether william averell takelamp jack
cross jack crosstogether joe jack cost

action cost shown colon non zero switch planlength
used set plan length overrides plan length given query part planing
planlength get plans cost cheaper plans
length
user asked whether perform optional security check whether look
optimal plans respectively switch fpsec used instead fp obtain
secure plans
command line option costbound n effects computation admissible plans
respect cost n example resource described section solved
following call prototype
dlv fpbuying bkbuying plan n planlength costbound

correctly admissible plan found calling system without cost bound
prototype calculates following optimal cost plan
plan buy newspaper buy magazine

cost

current prototype supports simple bounded integer arithmetics option n used
sets upper bound n integers may used program builtin predicate int true integers n setting n high enough taking account
outcome built arithmetic predicates b c b c important get
correct details prototype given dlv k web site http www
dlvsystem com k


fie iter faber l eone p feifer p olleres

experiments
performance experimental dlv k without action costs optimal
reported previous work eiter et al section present encouraging experimental action costs particular parallel blocks world tsp
experiments performed pentium iii mhz machine mb main memory running suse linux set time limit seconds tested instance exceeding
limit indicated tables
possible report ccalc cmbp two logic
systems whose input languages c resp ar capabilities similar k resp k c
ccalc causal calculator ccalc model checker languages causal theories
mccain turner translates programs action language c language
causal theories turn transformed sat solved sat
solver mccain turner current version ccalc uses mchaff moskewicz et al
default sat solver minimal length plans generated iteratively increasing plan
length upper bound ccalc written prolog tests used version b
ccalc obtained url http www cs utexas edu users tag cc
trial version sicstus prolog used encodings taken lee lifschitz
parallel blocks world adapted ccalc encodings included
current download version system sequential blocks world adapted encodings
adding c command noconcurrency resembles respective k command
ccalc include sec startup time
cmbp conformant model planner cmbp cimatti roveri
model checking paradigm exploits symbolic boolean function representation techniques
binary decision diagrams bryant cmbp allows computing sequential minimal
length plans user declare upper bound plan length input language
extension ar giunchiglia kartha lifschitz unlike k action languages
c lee lifschitz language supports propositional actions cmbp
tailored conformant reported complement previous comparison
shows encoding sequential blocks world cmbp eiter et al tests
used cmbp available url http sra itc people roveri cmbp
b locks w orld
tables different blocks world encodings section several
configurations p denotes simple instance figure p p instances used
previous work eiter et al erdem
table shows finding shortest sequential plan second third column
number blocks length shortest plan e least number moves solving
respective blocks world instance execution time solving shortestplan encoding p section shown column five upper bound shown fourth
column plan length column six shows execution time finding shortest plan
incremental plan length search starting similar method used ccalc
remaining two columns ccalc cmbp


fia nswer et p lanning u nder action c osts


p
p
p
p
p
p

blocks







min moves steps







upper bound steps







dlvk

dlvk
inc














ccalc







cmbp





table sequential blocks world shortest plans


p
p
p
p
p
p
p

blocks








steps fixed








min moves








dlvk








table parallel blocks world cheapest plans minimal number moves fixed plan length

table shows execution times parallel blocks world fixed plan length
number moves minimized e section used encoding figure
generates parallel serializable plans ccalc cmbp allow optimizing
criteria plan length dlv k
next table shows finding shortest parallel plan e section first minimal possible number steps given processed instance
encoding p section ii without costs iteratively increasing plan length
iii ccalc iteratively increasing plan length plan found every
number moves first plan computed reported separately cmbp supports
sequential included comparison
finally table shows combined optimizations parallel blocks
world outlined section second column contains upper bound plan

upper bound
p
p
p
p
p
p








min steps







dlvk
moves





time





dlvk
inc
moves







time







table parallel blocks world shortest plan



ccalc
moves
time













fie iter faber l eone p feifer p olleres


p
p
p
p
p
p

upper bound







steps moves









dlvk

dlvk
inc












ccalc







steps moves







dlvk

dlvk
inc














table parallel blocks world

length respective instance following three columns present finding
shortest among cheapest plans e section
dlvk refers combined minimal encoding p described section
dlvk
inc refers incrementally searching shortest among cheapest plans

done means costbound command line option taking minimal
sequential costs e shortest sequential plan length computed table upper
cost limit encodings compute serializable plans minimal sequential length
used cost limit special case
ccalc similar technique used ccalc encoding bound costs additive fluents lee lifschitz
note incremental strategy used dlv k
inc ccalc takes advantage specific formulation parallel blocks world general allowing parallel actions
necessarily serializable arbitrary costs optimal parallel cost might differ
optimal sequential solution particular plans longer cheapest sequential plans example coincide shortest sequential plans may need
considered makes incremental search solution infeasible general
last test finding cheapest among shortest plans section
tested integrated encoding upper bound p resp incrementally finding
shortest plan unlike cannot derive fixed cost limit sequential
solution really need optimize costs makes encoding ccalc infeasible
blocks world blocks world experiments dlv k solve optimization tasks effective flexible way systems compared hand
already stated minimal plan length encodings section solve
tight upper bound plan length known iteratively increasing plan
length effective especially upper bound much higher actual optimal solution becomes drastically apparent execution times seem explode one instance
next highly non linear manner table solution p found
reasonable time whereas p p could solved within time limit seconds
observation confirmed tables instance p table etc partly explained
behavior underlying dlv system geared towards plan search
general purpose solver uses heuristics might work well cases
particular answer set generation process dlv distinction made actions


fia nswer et p lanning u nder action c osts

fluents might useful tasks control generation answer sets resp
plans may part investigations
interestingly ccalc finds better quality parallel solutions cf table e
solutions fewer moves although significantly slower system instances
incremental encoding ccalc seems even effective system
however ccalc offers means optimization allows admissible optimal
makes flexible general stated could fortunately
exploit fixed cost bound particular example ccalc possible general
instances
intuitively harder simply finding shortest plan cheapest among
shortest plans general solved incrementally
must consider plans lengths longer plan may cheaper cannot freeze plan
length shortest plan incrementally found
tsp
experimental tsp variable costs reported tables unlike
blocks world comparable systems available none systems supports cost
optimal needed solving plan length given
number cities
table shows tsp instance austrian province capitals figure
nine cities connections without exceptional costs section without subscript exc table instances reported table different cost exceptions
lwe rnd described
bigger tsp instances given capitals members european
union eu varying connection graphs exceptional costs shown table
used flight distances km cities connection costs instances tsp eu tspeu
generated randomly choosing given number connections possible connections cities note tsp eu solution time reported
dlvk terminated instances first optimal plan found
tested instances practical relevance simply randomly choosing
connections tspeu instance taken flight connections three carriers
namely star alliance alitalia luxair tsp eu included direct connections km capital hopping interest small airplane limited
range instance
instance tables measured execution time
without exceptional costs
costs connections saturdays sundays weekends
costs connections fridays saturdays sundays long weekends lwe
random cost exceptions rnd added number randomly generated exceptions costs tsp austria instances
eu eu


fie iter faber l eone p feifer p olleres

instance
tspaustria
tspaustria exc
tspaustria
tspaustria lwe
tspaustria rnd
tspaustria rnd
tspaustria rnd
tspaustria rnd

cost exceptions









cost time









table tsp tspaustria varying exceptions

instance
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd

conn





































except





































cost time





































instance
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu
tspeu
tspeu lwe
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd
tspeu rnd

conn






























except






























cost time






























table tsp instances capitals eu members


fia nswer et p lanning u nder action c osts

tsp instance tspeu shows limits system given data allows many
possible tours finding optimal one gets tricky hand realistic instance
tspeu real airline connections solved rather quickly surprising
airlines central airport instance vienna austrian airlines direct connections
destinations served allows much fewer candidate answer sets
reality number airlines consider limited e g tsp eu solution
two star alliance alitalia luxair allowed course cannot compete
dedicated tsp solvers able solve much bigger tsp instances
considered however knowledge none solvers deal features
incomplete knowledge defaults time dependent exceptional costs etc directly even
execution times stable yet case many exceptions contrast instance tsp eu
shows exceptions cause significant speedup due heuristics used
underlying dlv system single better solutions faster costs spread evenly
tspeu without exceptional costs
note experimented alternative smodels translation sketched section refrain detailed discussion since translation optimized dlv
smodels performance worse around factor tested tsp instances dlv ii
integrated frontend available smodels providing high level language nevertheless shown minor modifications adopted
system smodels

related work
last years widely recognized plan length alone one criterion
optimized several attempts made extend planners consider action
costs
pyrrhus system williams hanks extension ucpop
allows optimal resources durations domain dependent knowledge
added direct heuristic search utility model defined
used express optimization function system supports language extension
adl pednault predecessor pddl ghallab et al
synthesis branch bound optimization least commitment plan space planner
approaches heuristic search include use strategy together
action costs heuristics ephrati pollack mihlstein work refanidis
vlahavas use multi criteria heuristics obtain near optimal plans considering multiple criteria
apart plan length alone refanidis vlahavas however described heuristics
fully admissible guarantees optimal plans certain restrictions haslum geffner
fact heuristic state space planners able guarantee optimality
powerful suggested nareyek describes resources
structural constraint satisfaction scsp solves local search
combined global control however work promotes inclusion domain dependent
knowledge general unlimited search space declarative high level language provided nareyek
among related approaches kautz walser generalize satisfiability
use integer optimization techniques encoding optimal resource pro

fie iter faber l eone p feifer p olleres

duction consumption kautz walser first recall integer logic programming
generalizes sat sat formula translated system inequalities second extend effects preconditions actions similar strips extension proposed koehler
modeling resource consumption production koehler kautz walser allow arbitrary
optimization functions use non declarative low level representation algebraic modeling language ampl fourer gay kernighan mention koehlers
strips formalization mapped however express nondeterminism incomplete knowledge implementation called ilpplan uses ampl package http www ampl com unfortunately ampl
freely available could compare system experimentally
lee lifschitz describe extension c action language c allows intuitive encoding resources costs means called additive fluents lee lifschitz
way admissible realized optimization considered
framework far implementation planner language ccalc mccain
already described previous section another implementation system action language c cplan giunchiglia ferraris giunchiglia
cplan system mainly focuses conformant support advanced
features c furthermore code longer maintained
son pontelli propose translate action language b prioritized default theory answer
set programming allow express preferences actions rules object level
interpreter part input language son pontelli however
preferences orthogonal model qualitative preferences opposed
overall value function plans trajectories

conclusion outlook
work continues stream pursues usage answer set programming
building systems offer declarative languages action languages
tasks specified high level abstraction lifschitz b
representation practical languages must high expressiveness
provide convenient constructs language elements
towards goal presented language k c extends declarative
language k eiter et al b action costs taken account
generating optimal plans e plans least total execution cost admissible plans
wrt given cost bound e plans whose total execution cost stays within given limit basis
implementation issues investigated computational complexity major tasks language derived complexity sharply characterizing
computational cost furthermore presented transformation optimal admissible
k c logic programming optimal answer set semantics buccafurri
et al described dlv k prototype implemented top kr tool
dlv computes semantics
shown kc allows representation intricate particular
demonstrated variant traveling salesperson tsp could
conveniently specified kc strength kc via underlying language k states
knowledge e incomplete states suitably respected secure plans e conformant plans


fia nswer et p lanning u nder action c osts

work circumstances including nondeterministic action effects k c flexible
language exploiting time dependent action costs allows representation
optimality criteria cheapest plans shortest plans combinations thereof
experiments shown instances considered including
realistic instances tsp variant could decently solved hand current
version dlvk scale large instances general unsurprisingly
compete high end tools specialized particular
tsp see shortcoming though since main goal point demonstrate usefulness expressive capabilities formalism easily represent non trivial
optimization tasks especially involved viewpoint knowledge
representation way non trivial instances medium size one may
often encounter solved little effort
several issues remain work implementation performance improvements
may gained via improvements underlying dlv engine subject current work
furthermore alternative efficient transformations kc logic programming might researched e g ones involve preprocessing performing means end analysis simplify logic program constructed
another issue language extensions example crucial difference
resource approaches former hinges action costs latter
build fluent values somewhat different view quality plan possible way
encompass language allow dynamic fluent values contribute action costs
needs carefully elaborated though deterministic complete knowledge extension straightforward non deterministic domains incomplete knowledge
would possibly ambiguities different trajectories plan possibly yield different
costs fluent values contribute action costs favor intuitive definition plan costs
optimality refrained extension current state
possible extension negative action costs useful modeling producer consumer relations among actions resources allowing different priorities among
actions e different cost levels would increase flexibility allow optimizing different
criteria finally duration actions important issue current language
effects actions assumed materialize next state coding techniques
may express delayed effects several states time interleaving actions constructs
language would desirable investigating issues part ongoing future work

acknowledgments
grateful joohyung lee help ccalc paul walser useful
informations ilpplan furthermore thank michael gelfond interesting discussions
suggestions anonymous reviewers detailed helpful comments
work supported fwf austrian science funds projects p
z n european commission project fet wasp ist infomix
preliminary shorter version presented th european conference
logics artificial intelligence jelia cosenza italy september


fie iter faber l eone p feifer p olleres

appendix language k
appendix contains shortened form definition language k translation k
answer set programs see eiter et al b details examples
basic syntax
assume act f l typ disjoint sets action fluent type names respectively e
predicate symbols arity disjoint sets con var constant variable symbols
f l act describe dynamic knowledge typ describes static background knowledge
action resp fluent type atom form p tn p act resp f l typ arity n
tn con var action resp fluent type literal l action resp fluent type
atom negation alternatively true negation symbol define
l l l l atom set l literals consistent
l l furthermore l resp l set positive resp negative literals l
set action resp fluent type literals denoted l act resp lf l ltyp furthermore lf l typ

lf l ltyp ldyn lf l l
act l lf l typ lact
actions fluents must declared statements follows
definition action fluent declaration action resp fluent declaration form
p x xn requires tm




var n arity p
p l


act resp p lf l x xn
ltyp every xi occurs tm

keyword requires may omitted causation rules specify dependencies
fluents fluents actions
definition causation rule causation rule rule short expression form
caused f b bk bk bl



f lf l false b bl lf l typ l l k n
rules n static rules others dynamic rules l resp n resp
omitted l n caused optional
access parts causation rule r h r f post r b bk post r
bk bl pre r pre r lit r f b bl
intuitively pre r pre r pre r resp post r post r post r
accesses state resp action happen
special static rules may specified initial states
definition initial state constraint initial state constraint static rule form
preceded initially
language k allows conditional execution actions several alternative executability
conditions may specified


fia nswer et p lanning u nder action c osts

definition executability condition executability condition e expression form
executable b bk bk bl



l
act b bl l l k
l e executability unconditional skipped parts e accessed h e
pre e b bk pre e bk bl lit e b bl intuitively
pre e pre e pre e refers state actions suitability evaluated
state action execution involved convenience define post e post e
causal rules executability conditions must satisfy following condition
similar safety logic programs variable default negated type literal must occur
literal default negated type literal safety requested variables appearing
literals reason variables appearing fluent action literals implicitly safe
respective type declarations
notation causal rule initial state constraint executability condition r post pre b
define r r r bs r posts r pres r
p lanning omains



p lanning p roblems

definition action description domain action description hd ri consists
finite set action fluent declarations finite set r safe causation rules safe initial
state constraints safe executability conditions contain positive cyclic dependencies among actions k domain pair pd h adi disjunction free
normal datalog program background knowledge safe total well founded
model cf van gelder ross schlipf ad action description call pd
positive default negation occurs ad
definition p hpd qi pair domain pd query q e
g gm gm gn



g gn lf l variable free n denotes plan length
semantics
start preliminary definition typed instantiation domain
similar grounding logic program difference correctly typed
fluent action literals generated
let pd h hd rii domain let unique answer set gelfond lifschitz p x xn legal action resp fluent instance action resp fluent declaration form substitution defined x xn
tm lpd denote set legal action fluent instances instantiation domain respecting type information follows
total well founded model existing corresponds unique answer set datalog program allowing
multiple answer sets would eventually lead ambiguities language



fie iter faber l eone p feifer p olleres

definition typed instantiation domain pd h hd rii typed instantiation given pd h hd rii grounding con
r r r r r r set substitutions variables r
con lit r ldyn lpd lpd l
f l
words pd replace r ground versions keep latter
rules atoms fluent action literals agree declarations say
pd h hd rii ground r ground moreover well typed pd
pd coincide
tates



ransitions

definition state state transition state w r domain pd consistent set
lf l lit pd lit pd legal fluent instances negations state transition
tuple hs states lact lit pd set legal action
instances pd
observe state necessarily contain f f legal instance f
fluent may even empty state transitions constrained done
definition legal state transitions proceed analogy definition answer sets
gelfond lifschitz considering first positive e involving positive domain
general
follows assume pd h hd rii well typed ground domain
unique answer set pd respective concepts defined
typed grounding pd
definition legal initial state state legal initial state positive pd
least set w r post c implies h c initial state constraints
static rules c r
positive pd state set l
act called executable action set w r
exists executability condition e r h e pre e lf l typ sm


pre e l
act pre e lact sm note definition allows modeling
dependent actions e actions depend execution actions
definition legal state transition given positive pd state transition hs
called legal executable action set w r minimal consistent set satisfies
causation rules w r every causation rule r r post r
ii pre r lf l typ iii pre r lact hold h r false
h r
extended general well typed ground pd containing default negation
gelfond lifschitz type reduction positive domain gelfond lifschitz
definition reduction let pd ground well typed domain let
hs state transition reduction pd h hd rt ii pd
domain rt obtained r deleting


fia nswer et p lanning u nder action c osts

r r post r pre r sam
default literals l l l remaining r r
note pd positive ground extend definitions follows
definition legal initial state executable action set legal state transition
domain pd state legal initial state legal initial state pd h set
executable action set w r state executable w r pd hs state transition
hs legal legal pd
p lans
definition trajectory sequence state transitions hhs hs
hsn sn ii n trajectory pd legal initial state pd hs ai si
n legal state transitions pd
n hi empty associated explicitly
definition optimistic plan sequence action sets ha ai optimistic
plan p hpd qi trajectory hhs hs
hsi ai si ii exists pd accomplishes goal e g gm si gm gn
si
optimistic plans amount plans valid plans etc defined literature term
optimistic stress credulous view definition respect incomplete fluent
information nondeterministic action effects cases execution optimistic plan
p might fail reach goal thus resort secure plans
definition secure plans alias conformant plans optimistic plan ha secure plan every legal initial state trajectory hhs hsj aj sj ii
j n holds j n accomplishes goal ii j n j
executable sj w r pd e legal transition hs j aj sj exists
note plans admit general concurrent execution actions call plan ha
sequential non concurrent j j n
macros
k includes several macros shorthands frequently used concepts let l
act denote
action atom f lf l fluent literal b possibly empty sequence b bk bk
bl bi lf l typ l possibly empty sequence
aj l j n
inertia allow easy representation fluent inertia k provides
inertial f b

defaults



caused f f b f

default value fluent expressed shortcut
default f



caused f f

effect unless causation rule provides evidence opposite value


fie iter faber l eone p feifer p olleres

totality

reasoning incomplete total knowledge k provides f positive
total f b



caused f f b
caused f f b

instance useful model non deterministic action effects discussion
full impact statement modeling incomplete knowledge non determinism
refer previous language k eiter et al b
state integrity

integrity constraints refer preceding state k provides
forbidden b

non executability



caused false b

specifying action executable k provides

nonexecutable b



caused false b

definition nonexecutable overrides executable case conflicts
sequential plans exclude simultaneous execution actions k provides
noconcurrency



caused false

range possible actions lpd lact
macros b resp omitted b resp empty

appendix b proofs
proof theorem membership np resp npmv since l polynomial size p optimistic plan p ha al p supporting trajectory
ht ti p guessed proposition verified polynomial time furthermore costp p b efficiently checked since costp p easily computed costs
constants
hardness k fragment k c k viewed
deciding existence resp finding admissible plan wrt cost previously shown
eiter et al b deciding existence optimistic plan given k
np hard fixed plan length l hence np hard kc
finding optimistic plan hard npmv reduction well known
sat cf papadimitriou whose instances cnfs c ck clauses ci
li li mi li j classical literal propositional atoms x x xn
consider following domain pd
fluents
actions

x xn state state
c costs ck costs
ax axn
initially total x total xn
caused state

caused state state
executable c l l
forbidden l l c

executable ck lk lk mk
forbidden lk lk mk ck
executable ax x forbidden x ax

executable axn xn forbidden xn axn



fia nswer et p lanning u nder action c osts

fluents xi state total statements initially section encode candidate truth assignments subsequent statements force c j executed iff corresponding
clause violated truth assignment encoded initial state final pairs executable
forbidden statements force actions ax executed iff corresponding fluents x hold
necessary directly extract computed truth assignments plan
since dealing function class fluent state identifies state time
consider p hpd state clearly optimistic plan
p p corresponds truth assignment p x vice versa costp p number
clauses violated p thus admissible optimistic plans p wrt cost correspond
satisfying assignments clearly constructing p efficiently possible
constructing satisfying truth assignment corresponding plan p actions
axi concludes hardness proof
membership ii since security optimistic plan admissible wrt cost k checked
proposition call p oracle membership p resp p mv follows
analogous considerations oracle needed
hardness ii decision variant p hardness immediately inherited p completeness deciding existence secure plan language k
hardness even fixed plan length eiter et al b plan computation variant give
reduction following p mv complete instance open qbf
q z xy x z
x x xl ym z z zn respectively x z
w l g cnf formula x z solutions truth assignments z
q z satisfied
suppose x z c ck ci ci ci ci consider following
domain pdq z q z variant domain given proof
theorem eiter et al b
fluents
x xl ym z zn state state
actions
az costs azn costs
initially total x total xl
caused state

caused state state
executable az executable az executable azn
caused x x caused x x

caused xl xl caused xl xl
total state total ym state
caused z az caused z az

caused zn azn caused zn azn
forbidden c c c state

forbidden ck ck ck state
x

x many legal initial states pdq z correspond
possible truth assignments x initial states contain state starting initial
state si executing set actions represents truth assignment variables z since


fie iter faber l eone p feifer p olleres

actions executable z executable action sets z represent
truth assignments z

pair si aj exist many successor state candidates si si
contain fluents according truth assignment x represented fluents according
truth assignment z represented j fluents according truth assignment
fluent state candidate states satisfying clauses x z legal
virtue forbidden statements
hard see optimistic plan form p ha azi zi z
goal state exists wrt pdq z iff assignment variables x z
formula x z satisfied furthermore p secure iff represents assignment
variables z regardless assignment variables x chosen
corresponding legal initial state assignment variables
clauses x z satisfied e least one state si k reachable si executing
si k contains state words p secure iff x z true thus
admissible secure plans pdq z wrt cost correspond assignments z
q z true
since pdq z constructible x z polynomial time follows computing
secure plan p hpdq z qi q state p mv hard

proof theorem membership concerning membership performing binary search
range max max upper bound plan costs plan polynomial
length l given l times sum action costs least integer v
optimistic plan p p admissible wrt cost v exists optimistic plan exists
clearly costp p v costp v thus plan p optimal since max
single exponential representation size p binary search thus computing cost p
theorem feasible polynomial time np oracle subsequently construct
optimistic plan p costp p costp extending partial plan pi ha ai
l step step follows let set legal action
instances initialize bi ask oracle whether pi completed optimistic
plan p ha al admissible wrt costp ai bi answer
yes update bi bi else leave bi unchanged repeat test
aj j resulting bi action set pi ha ai ai
ai bi completed optimistic plan admissible wrt cost p thus ai
polynomial time constructible np oracle
summary construct optimal optimistic plan polynomial time np oracle
thus fp
hardness hardness plan length l reduction max weight
sat papadimitriou instance sat instance c ck proof
theorem plus positive integer weightsp
w k contains
truth assignments x wsat ci true wi maximal
end take domain pd proof theorem modify
cost ci wi k thus constructing domain pd consider
pi hpdi state since actions cj actions nonzero
cost plan corresponding top
truth assignment
p associated sum weights
violated clauses wvio ki wi wsat since ki wi constant minimizing


fia nswer et p lanning u nder action c osts

wvio equivalent maximizing wsat hence one one correspondence
optimal optimistic plans pi wvio minimal maximal truth assignments
furthermore computing pi extracting max weight sat solution optimal
plan p efficiently possible proves fp hardness
membership ii proof similar membership proof uses oracle asks
completion partial secure plan p ha ai secure plan p ha al
ai bi aj p admissible wrt costp rather partial optimistic plan
oracle easily seen p thus computing optimal secure plan f p
hardness ii hardness reduction following f p complete cf krentel given open qbf q z xy x z proof
theorem ii compute lexicographically first truth assignment z q z
satisfied
accomplished changing cost action az pdq z ni
n let pd q z resulting domain since cost az e assigning
zi value true greater sum costs az j j n optimal
secure plan hpd q z state amounts lexicographically
first truth assignment z q z satisfied thus fp hardness follows

proof theorem prove applying well known splitting set theorem
logic programs lifschitz turner theorem applies logic programs
split two parts one bottom part refer predicates defined
top part answer sets bottom part extended answer sets
whole program looking remaining top rules informally splitting set
set u ground literals defining bottom part bu program answer set sb
bu used reduce remaining rules b u program eu bu sb
involving classical literals occur b u evaluating literals b u
wrt sb answer set se eu bu sb set sb se answer set
original program
disregarding weak constraints split program lp w p bottom part consisting
lp pnc pnc p cost information stripped top part containing
remaining rules derive correspondence optimistic plans p answer sets
lpw p similar correspondence lp p nc eiter et al
detail theorem eiter et al states k p correspondence answer sets lp p supporting trajectories optimistic plans
p ha al items ii costs discarded thus answer set lp pnc
corresponds trajectory optimistic plan p pnc vice versa
follows talking lp p nc lpw p mean respective grounded
logic programs lpw p augments lp pnc rules weak constraints let u
lit lp pnc set literals occurring lp p nc clearly u splits lpw p defined
lifschitz turner disregard weak constraints lp w p since rules form
introduce head literals consequently get b u lpw p lp pnc
answer set lp pnc rule eu lpw p bu lpw p form
costa x xn c body


fie iter faber l eone p feifer p olleres

fact rules positive conclude respect split u
answer set lp pnc induces unique answer set lpw p therefore modulo
costs correspondence supporting trajectories candidate answer sets claimed
follows directly theorem eiter et al
remains prove costp p costlpw p holds candidate answer sets corresponding optimistic plan p ha al p correspondence shown
action p x xn aj corresponds exactly one atom p x xn j asj
j l therefore p x xn declared non empty cost part
well definedness modulo x xn exactly one fact costp x xn j c
model eu lpw p bu lpw p
furthermore definition c costj p x xn e cost action
instance p x xn time j consequently
pl
p violation value weak constraint wc
w
form p lp p costwc
j
p x xn aj costj p x xn since
violation values stem weak constraints total cost lpw p costp p
proves


references
blum l furst l fast graph analysis artificial
intelligence
bonet b geffner h incomplete information heuristic search
belief space chien kambhampati knoblock c eds proceedings
fifth international conference artificial intelligence scheduling aips
pp breckenridge colorado usa
bryant r e graph boolean function manipulation ieee transactions computers c
buccafurri f leone n rullo p strong weak constraints disjunctive datalog
dix j furbach u nerode eds proceedings th international conference
logic programming non monotonic reasoning lpnmr lecture
notes ai lnai pp dagstuhl germany springer verlag
buccafurri f leone n rullo p enhancing disjunctive datalog constraints ieee
transactions knowledge data engineering
cimatti roveri conformant via symbolic model checking journal
artificial intelligence
dantsin e eiter gottlob g voronkov complexity expressive power
logic programming acm computing surveys
dimopoulos nebel b koehler j encoding nonmonotonic
logic programs proceedings european conference ecp
pp springer verlag
eiter faber w leone n pfeifer g declarative solving
dlv system minker j ed logic artificial intelligence pp kluwer
academic publishers


fia nswer et p lanning u nder action c osts

eiter faber w leone n pfeifer g polleres b incomplete
knowledge lloyd j dahl v furbach u kerber lau k k palamidessi c
pereira l sagiv stuckey p j eds computational logic cl first international conference proceedings lecture notes ai lnai pp
london uk springer verlag
eiter faber w leone n pfeifer g polleres answer set
action costs flesca greco ianni g leone n eds proceedings
th european conference artificial intelligence jelia lecture notes
computer science pp
eiter faber w leone n pfeifer g polleres b answer set action costs tech rep infsys rr institut fur informationssysteme technische
universitat wien
eiter faber w leone n pfeifer g polleres logic programming
knowledge state ii dlv k system artificial intelligence

eiter faber w leone n pfeifer g polleres b logic programming
knowledge state semantics complexity appear acm transactions
computational logic
ephrati e pollack e mihlstein cost directed planner preliminary report
proceedings thirteenth national conference artificial intelligence aaai
pp aaai press
erdem e applications logic programming computational experiments
unpublished draft http www cs utexas edu users esra papers html
faber w pfeifer g since dlv homepage http www dlvsystem com
ferraris p giunchiglia e satisfiability nondeterministic domains
proceedings seventeenth national conference artificial intelligence aaai july
august austin texas usa pp aaai press mit press
fourer r gay kernighan b w ampl modeling language mathematical
programming duxbury press
gelfond lifschitz v classical negation logic programs disjunctive
databases generation computing
ghallab howe knoblock c mcdermott ram veloso weld
wilkins
pddl domain definition language tech rep yale center computational vision control available
http www cs yale edu pub mcdermott software pddl tar gz
giunchiglia e satisfiability expressive action languages concurrency
constraints nondeterminism cohn g giunchiglia f selman b eds proceedings seventh international conference principles knowledge representation
reasoning kr april breckenridge colorado usa pp morgan
kaufmann


fie iter faber l eone p feifer p olleres

giunchiglia e kartha g n lifschitz v representing action indeterminacy
ramifications artificial intelligence
giunchiglia e lifschitz v action language causal explanation preliminary report proceedings fifteenth national conference artificial intelligence
aaai pp
haslum p geffner h admissible heuristics optimal chien kambhampati knoblock c eds proceedings fifth international conference
artificial intelligence scheduling aips pp breckenridge colorado usa aaai press
kautz h walser j p state space integer optimization proceedings
th national conference artificial intelligence aaai pp
koehler j resource constraints proceedings th european
conference artificial intelligence ecai pp
krentel generalizations opt p polynomial hierarchy theoretical computer
science
lee j lifschitz v additive fluents provetti cao eds proceedings
aaai spring symposium answer set programming towards efficient scalable
knowledge representation reasoning pp stanford ca aaai press
lifschitz v turner h splitting logic program van hentenryck p ed proceedings th international conference logic programming iclp pp
santa margherita ligure italy mit press
lifschitz v turner h representing transition systems logic programs gelfond
leone n pfeifer g eds proceedings th international conference logic
programming nonmonotonic reasoning lpnmr lecture notes ai
lnai pp el paso texas usa springer verlag
lifschitz v foundations logic programming brewka g ed principles knowledge representation pp csli publications stanford
lifschitz v action languages answer sets apt k marek v w
truszczynski warren eds logic programming paradigm year
perspective pp springer verlag
lifschitz v b answer set schreye ed proceedings th
international conference logic programming iclp pp las cruces
mexico usa mit press
mccain n causal calculator homepage http www cs utexas edu
users tag cc
mccain n turner h causal theories actions change proceedings
th national conference artificial intelligence aaai pp
mccain n turner h satisfiability causal theories cohn g
schubert l shapiro c eds proceedings sixth international conference principles knowledge representation reasoning kr pp morgan kaufmann
publishers


fia nswer et p lanning u nder action c osts

moskewicz w madigan c f zhao zhang l malik chaff engineering
efficient sat solver proceedings th design automation conference dac
las vegas nv usa june pp acm
nareyek beyond plan length criterion local search scheduling ecai workshop vol lecture notes computer science pp
springer
niemela logic programs stable model semantics constraint programming
paradigm niemela schaub eds proceedings workshop computational aspects nonmonotonic reasoning pp trento italy
papadimitriou c h computational complexity addison wesley
pednault e p exploring middle ground strips situation calculus proceedings st international conference principles knowledge representation reasoning kr pp toronto canada morgan kaufmann publishers
inc
refanidis vlahavas framework multi criteria plan evaluation heuristic
state space ijcai workshop resources
selman l taxonomy complexity classes functions journal computer
system sciences
simons p niemela soininen extending implementing stable model
semantics artificial intelligence
smith e weld conformant graphplan proceedings fifteenth
national conference artificial intelligence aaai pp aaai press
mit press
son c pontelli e reasoning actions prioritized default theory flesca
greco ianni g leone n eds proceedings th european conference
artificial intelligence jelia lecture notes computer science pp
subrahmanian v zaniolo c relating stable ai domains
sterling l ed proceedings th international conference logic programming
pp tokyo japan mit press
van gelder ross k schlipf j well founded semantics general logic
programs journal acm
weld anderson c r smith e extending graphplan handle uncertainty
sensing actions proceedings fifteenth national conference artificial intelligence aaai pp aaai press mit press
williams hanks optimal goal directed utility model
hammond k j ed proceedings second international conference artificial intelligence systems aips pp aaai press




