journal artificial intelligence

submitted published

altaltp online parallelization plans
heuristic state search
romeo sanchez nigenda
subbarao kambhampati

rsanchez asu edu
rao asu edu

department computer science engineering
arizona state university tempe az

abstract
despite near dominance heuristic state search planners still lag behind disjunctive
planners generation parallel plans classical reason directly
searching parallel solutions state space planners would require planners branch
possible subsets parallel actions thus increasing branching factor exponentially
present variant heuristic state search planner altalt called altaltp
generates parallel plans greedy online parallelization partial plans greedy
significantly informed use novel distance heuristics altaltp
derives graphplan style graph
guaranteed provide optimal parallel plans empirical altaltp
capable generating good quality parallel plans fraction cost incurred
disjunctive planners

introduction
heuristic state space search proved one efficient
frameworks solving large deterministic bonet loerincs geffner
bonet geffner bacchus despite near dominance one achilles
heel remains generation parallel plans haslum geffner parallel plans allow
concurrent execution multiple actions time step concurrency likely
important progress temporal domains disjunctive planners
graphplan blum furst satplan kautz selman gpcsp kambhampati seem trouble generating parallel plans
planners search space states overwhelmed task main reason
straightforward methods generation parallel plans would involve progression
regression sets actions increases branching factor search space
exponentially given n actions branching factor simple progression regression
search bounded n progression regression search parallel plans
bounded n
inability state search planners producing parallel plans noted
literature previously past attempts overcome limitation successful indeed haslum geffner consider generating parallel
plans regression search space states note resulting planner hsp p scales significantly worse graphplan present tp haslum
geffner addition aimed actions durations improves
c

ai access foundation rights reserved

fisanchez kambhampati

branching scheme hsp p making incremental along lines graphplan
empirical studies reported haslum geffner however indicate even
unfortunately scales quite poorly compared graphplan variants informally achilles heel heuristic state search planners interpreted sort
last stand disjunctive planners capable generating parallel plans
efficiently
given way efficiently generating optimal parallel plans involves
disjunctive planners might want consider ways generating near optimal parallel
plans state search planners one obvious post process sequential
plans generated state search planners make parallel easily
done approaches explored backstrom one drawback
approaches limited transforming sequential plan given input
parallelization sequential plans often plans close optimal parallel
plans
alternative explore involves incremental online parallelization
specifically planner altaltp variant altalt planner sanchez nguyen
kambhampati nguyen kambhampati sanchez starts search
space regression single actions promising single action regress
selected altaltp attempts parallelize fatten selected search branch
independent actions parallelization done greedy incremental fashion actions considered addition current search branch heuristic cost
subgoals promise achieve parallelization continues next step
state resulting addition action better heuristic cost
sub optimality introduced greedy nature parallelization offset
extent plan compression procedure called pushup tries rearrange evolving
parallel plans pushing actions higher levels search branch e later stages
execution plan
despite seeming simplicity proven quite robust
practice fact experimental comparison five competing planners stan long
fox lpg gerevini serina blackbox kautz selman sapa
kambhampati tp haslum geffner shows altaltp viable
scalable alternative generating parallel plans several domains many
altaltp able generate parallel plans close optimal makespan
seems retain efficiency advantages heuristic state search disjunctive planners
producing plans fraction time taken disjunctive planners many cases
altaltp found superior post processing approaches specifically
compared altaltp involves post processing sequential plans
generated altalt techniques backstrom found altaltp
able generate shorter parallel plans many cases finally altaltp incurs
little additional overhead compared altalt
rest discuss implementation evaluation
generate parallel plans altaltp section starts providing review
altalt system altaltp section describes generation
empirically demonstrate later curious readers may refer plots figure



fionline parallelization plans heuristic state search

action templates

serial
graph

graphplan
plan extension phase
stan

spec
init goal state

extraction
heuristics

actions
last level

altalt

heuristics

regression planner
hsp r

solution plan

figure architecture altalt
parallel plans altaltp section presents extensive empirical evaluation altaltp
evaluation includes comparison ablation studies finally section discusses
related work classical well metric temporal section summarizes
contributions

altalt background architecture heuristics
altalt system combination graphplan blum furst
long fox kautz selman heuristic state space search bonet et al
bonet geffner mcdermott technology altalt extracts powerful
heuristics graph data structure guide regression search space
states high level architecture altalt shown figure specification
action template description first fed graphplan style planner case
stan long fox constructs graph
polynomial time assume reader familiar graphplan blum
furst graph structure fed heuristic extractor module
capable extracting variety effective heuristics nguyen kambhampati
nguyen et al heuristics along specification
set ground actions final action level graph structure fed
regression state search planner
explain operation altalt detailed level need provide
background components shall start regression search
module regression search process searching space potential plan suffixes suffixes generated starting goal state regressing
set relevant action instances domain resulting states nondeterministically regressed relevant action instances process repeated
reach state set subgoals satisfied initial state state
framework set conjunction literals seen subgoals need
made true way achieving top level goals action instance considered
relevant state effects give least one element delete


fisanchez kambhampati

element regressing ef f prec
essentially set goals still need achieved application
everything would achieved applied relevant action
separate search branch generated regressing action
fringe branch search terminates success node every literal
state corresponding node present initial state
crux controlling regression search involves providing heuristic function
estimate relative goodness states fringe current search tree
guide search promising directions heuristic function needs evaluate
cost achieving set subgoals comprising regressed state initial
state words heuristic computes length plan needed achieve
subgoals initial state discuss heuristic computed
graph provides optimistic reachability estimates
normally graph data structure supports parallel plans e plans
step one action may executed simultaneously since want graph provide heuristics regression search module altalt generates
sequential solutions first make modification generates
serial graph serial graph graph addition
normal mutex relations every pair non noop actions level marked
mutex additional action mutexes propagate give additional propositional mutexes finally graph said level change action
proposition mutex lists two consecutive levels
assume given graphplan module altalt used
generate expand serial graph levels discussed sanchez
et al relax requirement growing graph level
tolerate graded loss informedness heuristics derived graph
start notion level set propositions
definition level given set propositions lev index first level
leveled serial graph propositions appear non mutex
one another singleton lev index first level
singleton element occurs level exists lev graph
grown level
intuition behind definition level literal p serial
graph provides lower bound length plan serial graph
equal number actions plan achieve p initial state
insight simple way estimating cost set subgoals sum levels
heuristic sum heuristic hsum

p

ps

lev p

sum heuristic similar greedy regression heuristic used unpop mcdermott heuristic used hsp planner bonet et al main
limitation heuristic makes implicit assumption subgoals elements
independent hsum heuristic neither admissible particularly informed
ignores interactions subgoals develop effective heuristics


fionline parallelization plans heuristic state search

need consider positive negative interactions among subgoals limited
fashion
nguyen et al discuss variety ways graph
incorporate negative positive interactions heuristic estimate discuss
relative tradeoffs one best heuristics according analysis heuristic called
hadjsum adopted heuristic default heuristic altalt basic idea
hadjsum adjust sum heuristic take positive negative interactions
account heuristic approximates cost achieving subgoals set
sum cost achieving considering positive interactions ignoring negative
interactions plus penalty ignoring negative interactions first component
rp computed length relaxed plan supporting
extracted ignoring mutex relations approximate penalty induced
negative interactions alone proceed following argument consider pair
subgoals p q negative interactions p q lev p q
level p q present together exactly maximum lev p lev q
degree negative interaction p q thus quantified
p q lev p q max lev p lev q
want use values characterize amount negative interactions
present among subgoals given set subgoals pair wise independent
clearly values zero otherwise pair subgoals different
value largest value among pair subgoals used measure
negative interactions present heuristic hadjsum summary
heuristic adjusted hadjsum length rp maxp qs p q
analysis nguyen et al shows one robust heuristics
terms solution time quality thus default heuristic used altalt
well altaltp see

generation parallel plans altaltp
obvious way make altalt produce parallel plans would involve regressing subsets
non interfering actions unfortunately increases branching factor exponentially
infeasible practice instead altaltp uses greedy depth first makes
use heuristics regress single actions incrementally parallelizes partial plan
step rearranging partial plan later necessary
high level architecture altaltp shown figure notice heuristic
extraction phase altaltp similar altalt one important modification contrast altalt uses serial graph basis
heuristic see section altaltp uses standard parallel graph makes
sense given altaltp interested parallel plans altalt aimed generating
sequential plans regression state search engine altaltp different
search module altalt altaltp augments search engine altalt fattening
step plan compression procedure pushup details procedures
discussed


fisanchez kambhampati

action templates

parallel

graph

graphplan
plan extension phase
stan

extraction
heuristics

actions
last level

altaltp

heuristics

spec
init goal state

node
expansion
fattening

node ordering
selection

plan
compression

pushup

solution plan

figure architecture altaltp



p









ap



sp

figure altaltp notation





sm

fionline parallelization plans heuristic state search

parexpand
get set applicable actions current state
forall ai
si regress ai
children children si
sp state among children minimum
hadjsum value
ap action regresses sp
fattening process
ap
forall g ranked decreasing order level g
action ag supporting g ag
ai pairwise independent action
multiple actions pick one
minimum hadjsum regress ag among ag
hadjsum ai hadjsum
ag
spar regress
children children spar
return children
end
figure node expansion procedure
general idea altaltp select fringe action ap among actions
used regress particular state stage search see figure
pivot branch given action ap fattened adding actions
generating state consequence regression multiple parallel actions
candidate actions used fattening pivot branch must come sibling
branches pivot branch b pairwise independent actions
currently pivot branch use standard definition action independence two
actions considered independent state resulting regressing
actions simultaneously obtained applying sequentially
possible linearizations sufficient condition preconditions
effects actions interfere
prec ef f prec ef f
l refers non negated versions literals set l discuss
details pivot branch selected first place branch
incrementally fattened
selecting pivot branch figure shows procedure used select parallelize
pivot branch procedure first identifies set regressable actions
current node regresses computing children states next
action leading child state lowest heuristic cost among children
selected pivot action ap corresponding branch becomes pivot branch


fisanchez kambhampati


pack asu
pack asu
pack asu
pack home

h
unload pack airp home

ap unload pack airp asu

unload pack airp asu

sp
h
pivot
unload pack airp asu
unload pack airp asu
unload pack airp asu
unload pack airp asu
unload pack airp home


h



sm
h

possible pairwise
independent actions

figure regression state identify p ivot related set
pairwise independent actions

heuristic cost states computed hadjsum heuristic altalt
parallel graph specifically context discussion
hadjsum heuristic end section compute p q values turn
depend level p level q level p q terms levels parallel
graph rather serial graph easy level set
conditions parallel graph less equal level serial
graph length relaxed plan still computed terms number
actions later see figure change improve quality
parallel plans produced altaltp
search used altaltp similar used hspr bonet geffner
hybrid greedy depth first weighted search goes depthfirst long heuristic cost children states lower
current state otherwise resorts weighted search select next
node expand latter case evaluation function used rank nodes
f g w h g length current partial plan terms
number steps h estimated cost given heuristic function e g hadjsum
w weight given heuristic function w set empirical
experience
breaking ties case tie selecting pivot branch e one branch
leads state lowest heuristic cost break tie choosing action
role w best first search see korf



fionline parallelization plans heuristic state search

supports subgoals harder achieve hardness literal l measured
terms level graph l first appears standard rationale
decision c f kambhampati sanchez want fail faster
considering difficult subgoals first additional justification case
know subgoal higher level value requires steps actions
achievement appeared later graph supporting
first may able achieve easier subgoals along way thereby reduce
number parallel steps partial plan
fattening pivot branch next procedure needs decide subset
sibling actions pivot action ap used fatten pivot branch
obvious first idea would fatten pivot branch maximally adding pairwise
independent actions found search stage idea
may add redundant heuristically inferior actions branch satisfying
preconditions may lead increase number parallel steps
order avoid fattening pivot branch irrelevant actions
adding action require heuristic cost state
regressing strictly lower addition
requirement pairwise independent current set actions
simple check ensures add one action supporting
set subgoals
overall procedure fattening pivot branch thus involves picking next
hardest subgoal g hardness measured terms level subgoal
graph finding action ag achieving g pair wise independent
actions added used regress leads state
lowest heuristic cost consequence lower cost
found ag added procedure repeated one
action ag break ties considering degree overlap
preconditions action ag set actions currently degree precondition
overlap defined prec oo prec action higher
degree overlap preferred reduce amount additional work need
establish preconditions notice fattening process search
node may multiple actions leading parent multiple actions leading
children
example figure illustrates use node expansion procedure
logistics domain bacchus example four packages pack
pack pack pack goal place first three asu
remaining one home two planes airp airp carry plans
figure shows first level search regressed shows pivot
action ap given unload pack airp asu candidate set pairwise independent
actions respect ap finally see figure generation parallel
branch notice node seen partial regressed plan described
paragraphs actions regressing lower heuristic estimates considered apar
fatten pivot branch notice action unload pack airp home
discarded leads state higher cost even though inconsistent


fisanchez kambhampati


pack asu
pack asu
pack asu
pack home
apar unload pack airp asu
unload pack airp asu
unload pack airp asu

h
unload pack airp home

unload pack airp asu
ap unload pack airp asu

spar
h

sp


h

h
pivot



sm
h


unload pack airp asu
unload pack airp asu
unload pack airp asu
unload pack airp asu
unload pack airp asu
unload pack airp home

figure spar incrementally fattening p ivot branch pairwise
independent actions

rest actions chosen fatten pivot branch furthermore
see preferred actions plane airp since overlap
pivot action ap
offsetting greediness fattening fattening procedure greedy since
insists state resulting fattening strictly better heuristic value
useful avoiding addition irrelevant actions plan procedure
sometimes preclude actions ultimately relevant discarded
heuristic perfect actions may become part plan later stages
search e earlier parts execution eventual solution plan since
searching space plan suffixes happens length parallel plan
likely greater since steps may needed support preconditions
actions would forced come even later stages search earlier parts
plan action allowed partial plan earlier search e closer
end eventual solution plan preconditions could probably achieved
parallel subgoals plan thus improving number steps
order offset negative effect greediness altaltp arranges partial plan
promote actions higher search branch e later parts execution
eventual solution plan specifically expanding given node altaltp checks
see actions leading parent node e figure shows
apar leads spar pushed higher levels search branch online


fionline parallelization plans heuristic state search

pushup
get actions leading
forall
x
sx get parent node
getting highest ancestor action
loop
ax get actions leading sx
parallel ax
x x
sx get parent node sx
else
aj get action conflicting ax
secondary optimizations
remove aj branch
include anew necessary
else
ax ax

break
end loop
adjusting partial plan
sx get highest ancestor x history
createn ewbranchf rom sx
x
snew regress sx ax
sx snew
x x
end

figure pushup procedure

arrangement plan done pushup procedure shown figure
pushup procedure called time node gets expanded try
compress partial plan actions highest ancestor node
sx search branch action applied e gives literal
sx without deleting literals sx pairwise independent actions
ax currently leading sx words condition parallel ax satisfied
sx found removed set actions leading introduced
set actions leading sx child current search branch next
states search branch sx adjusted reflect change adjustment
involves recomputing regressions search nodes sx first glance
might seem transformation questionable utility since preconditions
regressions become part descendants sx necessarily
reduce length plan however expect length reduction actions
supporting preconditions get pushed eventually later expansions


fisanchez kambhampati


pack asu
pack asu
pack asu
pack home
unload pack airp asu
unload pack airp asu
unload pack airp asu

h
unload pack airp home

unload pack airp asu
unload pack airp asu

spar

sp

h





h

h

sm
h

unload pack airp home
fly airp locx asu
spar

sp



sm

h
pivot

unload pack airp home
fly airp locx asu

h

h

finding highest ancestor node action
pushed


unload pack airp asu
unload pack airp asu
unload pack airp asu
unload pack airp home

pack asu
pack asu
pack asu
pack home

h
unload pack airp home

unload pack airp asu
unload pack airp asu
unload pack airp asu

unload pack airp asu

unload pack airp asu
spar

snew

sp

h



h

sm

h

fly airp locx asu

fly airp locx asu



snew

spar

sp

h

fly airp locx asu
unload pack airp home

h
pivot

h

unload pack airp home



sm
h

h

b pushup procedure generates search branch

figure rearranging partial plan


fionline parallelization plans heuristic state search

rather doctor existing branch current implementation add
branch sx reflects changes made pushup procedure
branch becomes active search branch leaf node expanded next
aggressive variation pushup pushup procedure described
expensive affects current search branch operations involved
recomputing regressions branch course possible aggressive
manipulating search branch example applying action ancestor
sx set literals child state say snew changes thus additional actions may
become relevant expanding snew principle could expand snew light
information decided go expansion option typically
seem worth cost section compare default version pushup
procedure variant expands nodes search branch
studies support decision avoid expansion finally although introduced
pushup procedure add fattening step used independent
latter case net effect would incremental parallelization sequential
plan
example figure two actions leading node spar depth two
two actions unload pack airp home fly airp locx asu
expanding spar check two actions leading pushed
second action pushable since interacts actions ancestor node first
one highest ancestor partial plan interacts pushable
action example root node ancestor insert pushable
action unload pack airp home directly root node adjust
state spar snew depth shown figure b adding branch reflecting
changes states notice action unload pack airp home
initially discarded greediness fattening procedure see figure
offset negative effect plan compression see
expanded state snew depth made adjustments
partial plan actions already presented search trace

evaluating performance altaltp
implemented altaltp top altalt tested implementation suite
used aips competition bacchus long
fox well benchmark mcdermott experiments
broadly divided three sets aimed comparing performance altaltp
different scenarios
comparing performance altaltp systems capable producing
parallel plans
way data structures set adding branch turns robust
option manipulating existing search branch
instead aggressive pushup modification would expand snew depth generating similar states
generated expansion spar depth



fisanchez kambhampati









gripper aips

altalt p
stan
tp
blackbox
lpg nd

elevator aips
altalt p
stan



blackbox
lpg nd





steps



steps

















































b



figure performance gripper aips elevator aips domains




altalt p
stan
blackbox







steps



time



































b



figure performance schedule domain aips
comparing incremental parallelization technique altalt post processing
ablation studies analyze effect different parts altaltp
overall performance
experiments done sun blade workstation running sunos
gb ram unless noted otherwise altaltp run hadjsum heuristic


fionline parallelization plans heuristic state search





altalt p
stan
tp
blackbox
lpg nd










time

steps

















































b

figure performance logistics domain aips





altalt p
stan
tp
blackbox
lpg nd
sapa











time

steps




















































































b

figure performance driverlog domain aips
described section parallel graph grown first
level top level goals present without mutex times seconds
comparing altaltp competing approaches
first set experiments compared performance planner
obtained running stan long fox blackbox kautz selman


fisanchez kambhampati

tp haslum geffner lpg gerevini serina sapa
kambhampati unless noted otherwise every planner run default
settings planners could run domains due parsing
memory allocation errors cases omit planner consideration
particular domains
planners used comparison studies
stan disjunctive planner optimized version graphplan
reasons invariants symmetries reduce size search space blackbox
graphplan works converting
specified strips fikes nilsson notation boolean satisfiability
solving sat solver version used defaults satz lpg gerevini
serina judged best performing planner rd international
competition long fox planner graphs local
search inspired walksat lpg run default heuristics
settings since lpg employs iterative improvement quality plans
produced improved running multiple iterations thus increasing
running time make comparisons meaningful decided run lpg two
iterations n since beyond running time lpg generally worse
altaltp finally chosen two metric temporal planners able
represent parallel plans representation time durative actions
tp haslum geffner temporal planner hsp p haslum geffner
optimal parallel state space planner ida search
last planner list sapa kambhampati sapa powerful
domain independent heuristic forward chaining planner metric temporal domains
employs distance heuristics kambhampati sanchez control search
comparison different domains
run planners gripper domain international
scheduling competition mcdermott well three different domains
logistics scheduling elevator miconic strips bacchus three
competition long fox driverlog zenotravel satellite
cases multiple versions domain used strips untyped
versions discuss domains
gripper figure compare performance altaltp gripper domain mcdermott rest planners excluding sapa plot shows
terms number parallel steps see even simplistic domain altaltp lpg planners capable scaling generating parallel
chosen ipp koehler optimized graphplan system
reported haslum geffner already less efficient stan
since sapa read strips file format run sapa planner equivalent
unit duration actions long fox



fionline parallelization plans heuristic state search





altalt p
stan
lpg nd
sapa













steps

time


















































































b



figure performance zenotravel domain aips
plans none approaches able solve four altaltp
able scale without difficulty involving balls furthermore altaltp
returns better plans lpg
elevator figure b compare altaltp stan blackbox lpg elevator
domain miconic strips bacchus altaltp approached quality solutions
produced optimal approaches e g blackbox stan notice blackbox
solve around half solved altaltp domain
scheduling scheduling domain shown figure blackbox
stan considered comparison altaltp seems reasonably approximate
optimal parallel plans many around produce significantly
suboptimal plans however able solve
two approaches fraction time
logistics plots corresponding logistics domain bacchus shown
figure difficult altaltp outputs lower quality
solutions optimal approaches however altaltp lpg able scale
complex easily see altaltp provides better quality
solutions lpg altaltp seems efficient approaches
although stan supposed able generate optimal step length plans handful cases
seems produced nonoptimal solutions gripper domain explanation
behavior informed authors code
include traces tp pre processor planner able read
domain
tp pre processor cannot read domain lpg runs memory sapa parsing

sapa excluded due parsing



fisanchez kambhampati





altalt p
stan
tp
blackbox






lpg nd
sapa






steps

time
















































































b



figure performance satellite domain aips
lpg solutions obtained one iteration since lpg
able complete second iteration reasonable amount time explains
low time taken lpg lower quality solutions
driverlog see figure altaltp reasonably well terms quality
respect approaches driverlog domain every planner considered
time altaltp one two planners able scale figure b shows
altaltp efficient planners
zeno travel altaltp sapa lpg able solve
domain altaltp solves efficiently figure b providing good solution
quality figure compared temporal metric planners
satellite satellite domain shown figure although every
planner considered altaltp sapa lpg solve sapa
solves produces lower quality solutions many altaltp produces
better solution quality sapa efficient however altaltp produces
lower quality solutions lpg four lpg cannot solve one
produces lower quality solutions
summary summary note altaltp significantly superior elevator
gripper domains performs well driverlog zenotravel satellite
domains competition long fox performance planners
similar schedule domain logistics domain quality altaltp plans
second blackbox optimal planner solve
however scales along lpg bigger size returning good step blackbox tp able parse domain



fionline parallelization plans heuristic state search





altalt postproc
altalt p
altalt










time

steps



































b

figure altalt post processing vs altaltp logistics domain





altalt
altalt postproc
altalt p







time



steps

















































































b

figure altalt post processing vs altaltp zenotravel domain

length quality plans tp heuristic state search regression planner capable
producing parallel plans able scale domains sapa heuristic
search progression planner competitive still outperformed altaltp
time solution quality


fisanchez kambhampati

solution solution found length
time load truck obj tru pos level
time load truck obj tru pos level
time load truck obj tru pos level
time drive truck tru pos apt cit level
time unload truck obj tru apt level
time fly airplane apn apt apt level
time unload truck obj tru apt level
time load airplane obj apn apt level
time load airplane obj apn apt level
time load truck obj tru pos level
time fly airplane apn apt apt level
time drive truck tru pos apt cit level
time unload airplane obj apn apt level
time load truck obj tru apt level
time unload truck obj tru apt level
time drive truck tru apt pos cit level
time unload airplane obj apn apt level
time unload truck obj tru apt level
time unload truck obj tru pos level
total number actions plan

post processed plan
time load truck obj tru pos
time load truck obj tru pos
time load truck obj tru pos
time fly airplane apn apt apt
time load truck obj tru pos
time drive truck tru pos apt cit
time drive truck tru pos apt cit
time unload truck obj tru apt
time unload truck obj tru apt
time unload truck obj tru apt
time unload truck obj tru apt
time load airplane obj apn apt
time load airplane obj apn apt
time fly airplane apn apt apt
time unload airplane obj apn apt
time unload airplane obj apn apt
time load truck obj tru apt
time drive truck tru apt pos cit
time unload truck obj tru pos
end post processing actions length

altaltp solution

b altaltp plus post processing

figure plots showing altaltp solutions cannot improved anymore postprocessing

comparison post processing approaches
mentioned earlier see section one way producing parallel plans
studied previously literature post process sequential plans backstrom
compare online parallelization post processing implemented backstrom
minimal de ordering used post process sequential plans produced
altalt running default heuristic hadjsum serial graph
section compare online parallelization procedure offline method
first set experiments logistics domain bacchus
shown figure expected original altalt longest plans since allows
one action per time step plot shows post processing techniques help
reducing makespan plans generated altalt however notice
altaltp outputs plans better makespan altalt altalt followed postprocessing shows online parallelization better post processing
sequential plans moreover plot figure b shows time taken altaltp
largely comparable taken two approaches fact much
additional cost overhead procedure
figure repeats experiments zenotravel domain long fox
see altaltp produces better makespan post processing sequential
plans altalt notice time altalt plus post processing clearly less efficient


fionline parallelization plans heuristic state search



logistics aips



altalt p
altalt p nopush
altalt p agr



logistics aips





time

steps





































b

satellite aips



satellite aips



altalt p
altalt nopush
altalt p agr









time

steps
















































































c



figure analyzing effect pushup procedure

two approaches summary section demonstrate
altaltp superior altalt plus post processing
one might wonder plans generated altaltp benefit postprocessing phase investigated issue found specific post processing
routines used produce improvements main reason
behavior pushup procedure already tries exploit opportunity
shortening plan length promoting actions partial plan illustrative
example figure parallel plan output altaltp
logistics domain logistics bacchus post processing


fisanchez kambhampati





logistics aips

blocksworld aips

serial pg
parallel pg







altalt p
altalt





time

steps


































































b solving serial domain

utility parallel graphs

figure plots showing utility parallel graphs computing
heuristics characterizing overhead incurred altaltp serial domains

solution although two solutions differ terms step contents notice
step length difference step contents explained fact
de ordering relaxes ordering relations plan allowing
actions come earlier pushup moves actions towards end plan
run comprehensive studies three different domains logistics satellite
zenotravel found case step length plan produced altaltp
improved post processing routine omit comparison plots since essentially
curves corresponding altaltp altaltp post processing coincident
ablation studies
section attempts analyze impact different parts altaltp performance
utility pushup procedure figure shows effects running altaltp
without pushup procedure fattening procedure well running
aggressive version pushup described section expands
nodes search branch action pushed see running
altaltp pushup fattening procedures better latter comparison
figure figure shows even fattening procedure
performs better original altalt figure b see although
pushup procedure add much overhead aggressive version pushup get
quite expensive notice around solved within time limits
verified least one domains



fionline parallelization plans heuristic state search

aggressive pushup plots figure c figure
experiments satellite domain see situation quite similar
domain conclude pushup procedure used offset greediness
achieves purpose
utility basing heuristics parallel graphs see figure parallel graph basis deriving heuristic estimates
altaltp winning idea serial graph overestimates heuristic values
terms steps producing somewhat longer parallel solutions fact version
serial graph runs time many demonstrates
running times improved use parallel graphs
comparison altalt one final concern would much extra computational
hit taken altaltp serial domains e g blocks world bacchus
expect negligible confirm intuitions ran altaltp set
sequential blocks world domain see plot b
time performance altalt altaltp equivalent almost

related work
idea partial exploration parallelizable sets actions kabanza
godefroid kabanza kambhampati studied area
concurrent reactive one main goals approximate optimal
parallelism however focused forward chaining
planners kabanza state world completely known
implied backward search methods suitable kind analysis godefroid
kabanza search nodes correspond partial states shown
backward search methods used approximate parallel plans context
classical
optimization plans according different criteria e g execution time quality etc
done post processing step post processing computation given
plan maximize parallelism discussed backstrom reordering
de ordering techniques used maximize parallelism plan de ordering
techniques ordering relations removed added reordering arbitrary
modifications plan allowed general case np hard
difficult approximate backstrom furthermore discussed section
post processing techniques concerned modifying order
existing actions given plan considers modifying orderings
inserting actions online minimize possible number parallel
steps overall
already discussed graphplan planners long fox kautz
selman return optimal plans number time steps graphplan
uses ida include greatest number parallel actions time step
search however iterative procedure time consuming provide
guarantee number actions final plans attempts
minimize number actions planners huang selman kautz


fisanchez kambhampati

domain control knowledge generation rules specific
domain graphplan tries maximize parallelism satisfying
subgoals time step search fails backtracks reduces
set parallel actions considered one level altaltp opposite
tries guess initial parallel nodes given heuristics iteratively adds actions
nodes possible pushup procedure later search
recently work generalizing forward state search handle action concurrency metric temporal domains particular relevance work
temporal tlplan bacchus ady sapa kambhampati
planners designed specifically handling metric temporal domains use
similar search strategies main difference temporal tlplan
depends hand coded search control knowledge guide search sapa
altaltp uses heuristics derived temporal graphs
planners co opted produce parallel plans classical domains planners forward chaining search altaltp achieve concurrency
incrementally without projecting sets actions following way normal forward
search planners start initial state corresponding time consider actions
apply choose one say apply getting simultaneously
progress system clock order allow concurrency planners
bacchus ady kambhampati essentially decouple
action application clock progression every point search nondeterministic choice progressing clock applying additional actions
current time point point view planners altaltp seen providing heuristic guidance non deterministic choice modulo difference altaltp
regression search empirical comparisons altaltp sapa
altaltp outperforms sapa suggest heuristic strategies employed
altaltp including incremental fattening pushup procedure gainfully
adapted planners increase concurrency solution plans finally hsp
tp extension temporal domains heuristic state search planners
regression capable producing parallel plans haslum geffner tp
seen regression version used sapa temporal tlplan
experiments however demonstrate neither planners scales well comparison
altaltp
pushup procedure seen plan compression procedure similar
plan compression procedures double back optimization crawford
one difference double back used context local search pushup
used context systematic search double back could applied
finished plan schedule post processing outcome would
depend highly plan given input

concluding remarks
motivated acknowledged inability heuristic search planners generate parallel
plans developed presented generate parallel plans
context altalt heuristic state space planner challenging


fionline parallelization plans heuristic state search

exponential branching factor incurred naive methods tries avoid
branching factor blow greedy online parallelization evolving partial
plans plan compression procedure called pushup used offset ill effects
greedy search empirical comparison planners capable
producing parallel plans altaltp able provide reasonable quality parallel plans
fraction time competing approaches seems provide better
quality plans achieved post processing sequential plans
altaltp provides attractive tradeoff quality efficiency generation
parallel plans future plan adapt altaltp metric temporal
domains need concurrency pressing one idea adapt
sources strength altaltp sapa metric temporal planner developed
group kambhampati

acknowledgments
thank minh b xuanlong nguyen helpful discussions feedback
thank david smith jair reviewers many constructive comments
supported part nasa grants nag ncc nsf grant
iri

references
bacchus f aips competition ai magazine
bacchus f ady resources concurrency forward
chaining proceedings ijcai pp
backstrom c computational aspects reordering plans journal artificial
intelligence
blum furst fast graph analysis artificial
intelligence
bonet b geffner h heuristic search proceedings
ecp
bonet b loerincs g geffner h robust fast action selection mechanism
proceedings aaai pp aaai press
crawford j resource constrained project scheduling proceedings
artificial intelligence manufacturing workshop
aaai press
b kambhampati solving graph compiling csp
proceedings aips pp
b kambhampati sapa domain independent heuristic metric
temporal planner proceedings ecp


fisanchez kambhampati

fikes r nilsson n strips application theorem
proving solving artificial intelligence
gerevini serina lpg planner local search graphs
proceedings aips aaai press
godefroid p kabanza f efficient reactive planner synthesizing reactive
plans proceedings aaai vol pp aaai press mit press
haslum p geffner h admissible heuristics optimal proceedings
aips pp
haslum p geffner h heuristic time resources proceedings
ecp springer
huang selman b kautz h control knowledge benefits
tradeoffs proceedings aaai iaai pp
kabanza f verifying reactive plans position proceedings
aaai workshop immobots theories action control
kambhampati sanchez r distance goal ordering heuristics graphplan proceedings aips pp
kautz h selman b pushing envelope propositional logic
stochastic search proceedings aaai pp aaai press
kautz h selman b blackbox unifying sat graph
proceedings ijcai
koehler j rifo within ipp tech rep university freiburg
korf r linear space best first search artificial intelligence
long fox efficient implementation plan graph stan journal
artificial intelligence
long fox rd international competition
analysis appear jair
mcdermott regression match graphs control search artificial intelligence
mcdermott ai systems competition ai magazine

nguyen x kambhampati extracting effective admissible heuristics
graph proceedings aaai iaai pp
nguyen x kambhampati sanchez r graph basis deriving heuristics plan synthesis state space csp search artificial intelligence



fionline parallelization plans heuristic state search

sanchez r nguyen x kambhampati altalt combining advantages
graphplan heuristics state search proceedings kbcs bombay india




