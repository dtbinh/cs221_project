Journal Artificial Intelligence Research 19 (2003) 355-398

Submitted 10/02; published 10/03

Architectural Approach
Ensuring Consistency Hierarchical Execution
Robert E. Wray

wrayre@acm.org

Soar Technology, Inc., 3600 Green Court, Suite 600
Ann Arbor, MI 48105 USA

John E. Laird

laird@umich.edu

University Michigan, 1101 Beal Avenue
Ann Arbor, MI 48109 USA

Abstract
Hierarchical task decomposition method used many agent systems organize
agent knowledge. work shows combination hierarchy persistent
assertions knowledge lead difficulty maintaining logical consistency asserted
knowledge. explore problematic consequences persistent assumptions
reasoning process introduce novel potential solutions. implemented one
possible solutions, Dynamic Hierarchical Justification, effectiveness demonstrated
empirical analysis.

1. Introduction
process executing task dividing series hierarchically organized subtasks called hierarchical task decomposition. Hierarchical task decomposition
used large number agent systems, including Adaptive Intelligent Systems architecture (Hayes-Roth, 1990), ATLANTIS (Gat, 1991a), Cypress (Wilkins et al., 1995),
Entropy Reduction Engine (Bresina, Drummond, & Kedar, 1993), Procedural Reasoning System (Georgeff & Lansky, 1987), RAPS (Firby, 1987), Soar (Laird, Newell, &
Rosenbloom, 1987; Laird & Rosenbloom, 1990), Theo (Mitchell, 1990; Mitchell et al.,
1991), cornerstone belief-desire-intention-based agent implementations (Rao &
Georgeff, 1991; Wooldridge, 2000). Hierarchical task decomposition helps agents
knowledge developer agent manage environmental complexity. example,
agent may consider high-level tasks find power source fly Miami
independent low-level subtasks go east 10 meters turn heading 135.
low-level tasks chosen dynamically based currently active high level
tasks current situation; thus high-level task progressively decomposed
smaller subtasks. division labor simplifies design agents, thus reducing
cost. Additional advantages hierarchical task decomposition include knowledge sharing
(a low-level subtask invoked many different high-level procedures), modularity
(the decomposition helps insulate subtasks interaction knowledge)
naturalness representation (Simon, 1969).
Without careful design, difficult ensure consistent reasoning agents employing hierarchical task decompositions. consistency, mean reasoning
lead set assertions contains contradiction. Ensuring consistency becomes
c 2003 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiWray & Laird

much difficult solve thus costly complexity agents
knowledge grows. Although problem solved careful design agent
knowledge, approach requires understanding possible interactions
hierarchy. Thus, correctness solution depends skill vigilance
knowledge engineer. bias seek solutions operation agents primitive memories processes structured ensure inconsistencies arise. Thus,
prefer architectural solutions knowledge-based ones. Architectural solutions
guarantee consistency tasks domains, reducing brittleness due omissions
task knowledge. Further, developing architectural solution may costly,
less costly repeatedly developing knowledge-based solutions different domains.
following sections describe inconsistency problem introduce space
solutions problem, including two novel solutions. theoretical
empirical analysis, one new solutions, Dynamic Hierarchical Justification, shown
provide efficient architectural solution problem ensuring reasoning consistency
hierarchical execution.

2. Maintaining Reasoning Consistency Hierarchical Agents
section describes inconsistency problem greater detail. review methods
ensuring consistency non-hierarchical systems discuss limitations
approaches hierarchical systems.
2.1 Consistency Non-hierarchical Systems
Truth maintenance systems (TMSs) often used maintain consistency non-hierarchical systems (Doyle, 1979; McDermott, 1991; Forbus & deKleer, 1993). inference engine
uses domain knowledge create two different kinds assertions knowledge agents
knowledge base: assumptions entailments. inference engine enables assumptions
decided treat true, without requiring assertion justified. Agents often treat environmental percepts assumptions unquestioned beliefs
(Shoham, 1993). Entailments justified assertions. data structure, justification,
captures reasons asserting entailment. reasons longer hold (the
entailment longer justified), TMS retracts set asserted beliefs. Thus,
TMS automatically manages assertion retraction entailments agents
situation changes, ensuring entailments consistent external environment
enabled assumptions.
Careful construction domain knowledge required ensure enabled
assumptions contradictory. example, assumption inconsistent
current input, agent must domain knowledge recognizes situation
removes assumption. Thus, agent utilizes TMS, problem maintaining
consistency reasoning largely one managing assumptions agents domain
knowledge.
Assumptions often reflect hypothetical reasoning world (hence assumptions). However, assumptions used represent persistent feature. Although
researchers explored structuring external environment provide persistent memory (Agre & Horswill, 1997), internal, persistent memory usually necessary agent
356

fiEnsuring Consistency Hierarchical Execution

Assumptions
Entailments
Assumptions
Entailments
Assumptions

Inference
Engine

Entailments
Assumptions

TMS

Entailments
Assumptions
Entailments
Assumptions
Entailments
Assumptions
Entailments

Memory
Hierarchy Maintenance

Figure 1: hierarchical agent.
domains. example, persistence required hypothetical reasoning, nonmonotonic
revisions assertions (such counting), remembering.
2.2 Truth Maintenance Hierarchical Agents
TMS agent framework introduced extended hierarchical agent architectures. agent, inference engine TMS less identical
non-hierarchical agent. agent initiates new subtask via dynamic hierarchical
task decomposition, creates new database contain assumptions entailments specific subtask. decomposition result stack subtasks,
containing entailments assumptions specific subtask, shown Figure 1.
consider creation deletion distinct databases assertions sine qua non
hierarchical architecture. architecture decomposes task identifying
relevant subtasks, dynamically organizing memory according current
decomposition.
new system component, hierarchy maintenance, responsible creating
destroying subtask databases subtasks begin terminate. subtask
achieved (or determined longer worth pursuing), hierarchy maintenance responds
immediately removing assertions associated subtask. function
central importance hierarchical architectures allows agent automatically
retract assertions associated terminated subtask, requiring agent knowledge
clean remove individual assertions associated terminated subtask.
hierarchy maintenance component efficiently remove assertions
(conceptually) located distinct unit, subtask database.
357

fiWray & Laird

Subtask1

a11
e11

a12

a14
a13

a15

Subtask2
e14
e12
e17
e15
e19
e13
e18
a21
e16a11 a12
a22
a13

e21

e22

(a14, a15, e14, e19)
PSfrag replacements

Subtask3

a31

e23

a34
a32

e31

e32

(a12, a22, e22)

Hierarchy Maintenance

Figure 2: example hierarchy maintenance. Assumptions (a) entailments (e)
asserted within subtasks.

agents hierarchy maintenance function employed help maintain consistency, illustrated notionally Figure 2. agent architecture identifies assertions
higher levels hierarchy led new subtask. assertions together
form subtask support set. Figure 2, assertions 14 , a15 , e14 , e19 form support
set Subtask2 a12 , a22 , e22 support Subtask3 . support sets, effect, form
justifications subtasks hierarchy. assertion support set removed
(e.g., a22 ), agent responds removing subtask (Subtask 3 ). hierarchical architectures use architectural processes create destroy subtask databases,
example illustrates architectural hierarchical maintenance function realized
via process similar justification truth maintenance.
Within specific subtask, reason maintenance go before. However, hierarchical structure adds complication maintenance logical consistency. Assumptions
level hierarchy dependent entailments assumptions higher
levels hierarchy.1 dependence relationship suggested Figure 1 curved
lines extending one subtask one it. Higher levels hierarchy form
context reasoning local subtask.
execution agents embedded dynamic domains, hierarchical context may
change almost time. changing context problematic entailments;
1. Assumptions lower level subtask always least indirectly dependent higher level assertions. observation exploited Section 3.3.

358

fiEnsuring Consistency Hierarchical Execution

TMS readily determine dependent context changes retract affected entailments.
However, changes higher levels hierarchy (such deriving inputs)
may invalidate assumptions lower levels. Without additional architectural
mechanisms, domain knowledge required ensure consistency among assumptions
hierarchical context non-hierarchical systems. domain knowledge ensuring consistency assumptions complicated necessity spanning multiple
(possibly many) subtasks. refer knowledge across-level consistency knowledge. described detail below, identifying creating across-level consistency
knowledge tedious, costly, often incomplete process. Across-level knowledge must
explicitly consider interactions different subtasks (in different levels hierarchy), rather focus solely local subtask, compromising benefit
hierarchical decomposition.
continuing, note hierarchical architectures contrasted
hierarchical task network (HTN) planners (Sacerdoti, 1975; Erol, Hendler, & Nau, 1994)
execution-oriented systems use HTN representations, DECAF (Graham
& Decker, 2000) RETSINA (Sycara, Decker, Pannu, Williamson, & Zeng, 1996).
planning problem HTN planner represented initial task network
consist primitive non-primitive tasks. planner uses operators find plan
solve tasks. Methods allow planner match non-primitive tasks
task networks describe accomplish task; thus, methods enable hierarchical
decomposition planning problem family connected task networks.
main difference HTN systems hierarchical architectures
planner represents plan single global state. is, methods represent decomposition steps, hierarchical structure evolving plan represented blackboardlike database reflect structure decomposition. following
sections discuss problems especially solutions depend hierarchical organization asserted knowledge execution, addition hierarchical task decomposition encoded agents task knowledge. Thus, following generally
applicable HTN-based execution systems. However, HTN systems need address
inconsistency problem; Section 5.1.1 examines consequences global state respect
inconsistency arising persistence hierarchy.
2.3 Failing Respond Relevant Changes Hierarchical Context
mentioned introduction, agent fails respond relevant change
hierarchical context leaves now-inconsistent assumption enabled, resulting
behavior become irrational; is, consistent knowledge. section
explores irrational behavior arise several illustrative examples.
2.3.1 Blocks World
use variant blocks world illustrate inconsistency problem domain
familiar readers. domain execution domain rather planning
domain, call Dynamic Blocks World reflect difference static
blocks world used planning. assume agent knowledge build ordered
359

fiWray & Laird

Goal: (1 2) (2 3) (3 table)
Agent Memory
put-on-table(3)
put-on-table(2)
put-down(2)

Agent Memory
put-on-table(3)
put-on-table(2)
put-down(2)

Agent Memory
put-on-table(3)
put-on-table(2)
put-down(2)

empty
space

empty
space

empty
space

2
3
1

2
3
1

Actual World State

2

3
1

time

2

2
3
1

ent
l ev 3

n
r
Exte ks
c
kno

Actual World State

time

2
3 1

3 1

Actual World State

Figure 3: Failing respond relevant changes hierarchical context Dynamic
Blocks World.

tower (1-on-2-on-3) without resorting planning uses hierarchical task decomposition
determine actions take builds tower.
Figure 3, agent placing block-2 table, order reach block-3
begin goal tower. put-down subtask finds empty location table.
agent places empty assertion memory associated put-down subtask.
figure, space immediately left gripper chosen. Whether
space empty may directly observable may need inferred number
facts domain stored assumption memory. Assume empty
assertion assumption. Now, assume block-3 suddenly placed underneath block-2.
result inconsistency assumption (the location good place put
block-2) hierarchical context (the location longer good place put
block table).
agent fails recognize block-3 moved, attempt put block-2
location occupied block-3. behavior irrational, consistent
agents goals knowledge (assuming agent knowledge indicates
blocks placed positions already occupied blocks). inconsistency arises agent failed recognize previously-derived assumption
(empty) longer true current situation.
Although example may appear contrived, specific situation arose experimental system developed explore architecture learning issues. course, possible
simple domain reformulate task problem occur.
reformulation task via changes additions knowledge exactly solution
wish avoid. is, desire architecture guarantee consistency
hierarchical context local assumptions architecture provides priori
constraints (guidance) knowledge development process increased robustness
execution (via consistency). conclusion returns example describe
360

fiEnsuring Consistency Hierarchical Execution

patrol
intercept
attack(defensive)
achieveproximity
turntoheading

Figure 4: Decomposition behavior subtasks.
architectural solution inconsistency problem solves particular problem without
requiring reformulation agents task knowledge.
2.3.2 TacAir-Soar
TacAir-Soar agents pilot virtual military aircraft complex, real-time computer simulation tactical combat (Tambe et al., 1995; Jones et al., 1999). TacAir-Soar domain
indirectly accessible (each agent uses simulated aircraft sensor models perceive
pilot real aircraft would sense), nondeterministic (from point view
agent, behavior agents cannot strictly predicted anticipated), nonepisodic (the decisions agent makes early simulation impact later options
capabilities), dynamic (the world changes real time agent reasoning),
continuous (individual inputs continuous values). Domains characteristics
difficult ones create apply agents (Russell & Norvig, 1995).
domain knowledge TacAir-Soar agents organized 450 subtasks;
execution, resulting hierarchical task decomposition sometimes reaches depths greater
10 subtasks. agent one several different mission roles, among
flying patrol mission, acting partner wing agents lead.
Consider pair planes patrol, given specific instructions
engaging enemy aircraft. enemy aircraft enter patrol area, lead agent decides
intercept aircraft. lead decomposes intercept series situationdependent subtasks, may decomposed. example, Figure 4
shows complex task intercepting enemy aircraft decomposed
decision turn agents aircraft specific heading. agent turns heading
order get close enough enemy agent (via achieve-proximity) launch
attack.
Assume three different kinds attack chosen intercept. first tactic
(scare) engage attempt scare away enemy planes without using deadly force.
tactic selected rules engagement specify deadly force
used, regardless number aircraft area. One remaining two tactics
chosen deadly force allowed. Offensive attack appropriate friendly
patrol
intercept
count (enemy)

patrol
intercept
count(friendly)

patrol
intercept
attack(defensive)
achieveproximity
turntoheading

Figure 5: Trace behavior leading intercept tactic TacAir-Soar.
361

fiWray & Laird

Figure 6: Inconsistency due persistence.

planes outnumber equal enemy planes. Defensive attack used enemy planes
outnumber friendly planes.
Choosing offensive defensive attack requires counting current aircraft
area. Figure 5 shows evolution executing example decomposition.
agent must count relevant enemy friendly planes. Determining planes side
relevance count often requires remembering sufficiently complex entailment count possible. instance, non-combatant aircraft
counted, requiring reasoning type aircraft. agent determines
enemy planes outnumber friendly ones, agent selects defensive-attack, leading
decomposition.
happens enemy plane flees, thus reducing actual count relevant enemy planes one? count maintained agent invalid. Standard TMS
mechanisms insufficient count asserted assumption. actual
number enemy friendly planes equal, agent switch tactic offensive attack. Continuing defensive attack consistent agents
knowledge. Additionally, friendly agents participating attack may base
behavior expectation agent pursuing offensive attack. Thus agent
needs recognize inconsistency remove current count.
Figure 6 presents conceptual illustration problem. Assumptions represented
squares, entailments circles. horizontal line represents hierarchical relationship
assertions (i.e., assumptions entailments) hierarchical context (above
line) assertions local subtask (below line). arrowed lines represent
dependence creation assertion. previous examples, reasoning
subtask may require persistence, leading creation assumption
assumption 1. However, persistent assertion may still depend assertions.
work focuses dependent assertions higher level context, A, B, C, D,
E1 figure.
Suppose world changes E1 retracted memory E2 asserted.
Assumption 1 remains memory. E 2 would lead 1 (e.g., could lead
new assumption 2, shown), 1 longer justified may consistent
higher level context. Whether potential inconsistency among assertions
leads inconsistent behavior depends use assumption 1 later reasoning.
362

fiEnsuring Consistency Hierarchical Execution

3. Solutions
goal develop architectural solutions allow agent support persistent
assumptions simultaneously avoid inconsistencies across hierarchical context
lead irrational behavior. introducing two new architectural solutions, however,
examine knowledge-based approaches consequences order provide
rationale architectural approach.
3.1 Knowledge-based Solutions
Inconsistency avoided hierarchical agents creating domain knowledge
recognizes potential inconsistencies responds removing assumptions. Many planning agent systems use explicit domain knowledge represent knowledge
interactions among assertions world. example, Entropy Reduction Engine
(ERE) (Bresina et al., 1993) one agent system relies knowledge-based assumption consistency (KBAC). ERE requires domain constraints, knowledge describes
physics task domain. Domain constraints identify impossible conditions.
instance, domain constraint would indicate robot cannot occupy two different
physical locations simultaneously.
ERE, domain constraints specifically used maintain consistency current
world model state execution (Bresina et al., 1993, pp. 166). However, many
architectures use KBAC well (perhaps conjunction methods). KBAC
knowledge viewed simply domain knowledge must added system
achieve consistent behavior.
KBAC always necessary maintain consistency among assumptions within
level hierarchy. However, order guarantee consistency assumptions distributed throughout hierarchy, possible interactions leading inconsistency must
identified throughout hierarchy. knowledge engineering problem add significant cost agent development. knowledge designer must specify conditions
assumption asserted conditions must
removed. TacAir-Soar interception example, enemy plane flees, agent
requires knowledge disables assumptions depend upon number enemy
airplanes. Similarly, Dynamic Blocks World, agent must knowledge
recognizes situation, subtask, cause disabling empty.
cases, KBAC knowledge crosses levels hierarchy. complete KBAC solution
requires agents knowledge capture potential dependencies assumptions
local subtask higher levels hierarchy.
Although possible encode complete across-level consistency knowledge
simple domains, experience TacAir-Soar complex agent systems convinced
us KBAC requires significant investments time energy. Further,
often possible enumerate conditions assumption must removed,
agents brittle, failing difficult-to-understand, difficult-to-duplicate ways.
insufficiency knowledge-based solutions led us consider architectural solutions
problem. Architectural solutions eliminate need domain knowledge encoded
address inconsistency hierarchical context assumptions within
subtask. Thus, cost developing individual agents reduced. addition
363

fiWray & Laird

generality, definition, architectural solutions complete, thus able
guarantee consistency hierarchical context assumptions within subtask,
times, agent task. completeness improve robustness agent
systems, especially situations explicitly anticipated designers.
3.2 Assumption Justification
One potential architectural solution inconsistency problem justify assumption hierarchy respect assertions higher levels hierarchy. Assumption
Justification extension truth maintenance approaches consistency outlined
previously. assumption hierarchy treated entailment
respect dependent assertions higher hierarchy. new data structure, assumption justification, created captures reasons hierarchical context
particular assumption. Locally, assumption treated exactly assumption
non-hierarchical system. However, assumption justification longer supported
(indicating change dependent hierarchical context), architecture retracts
assumption.
Refer Figure 2. agent asserts 34 , architecture builds assumption justification assumption includes 22 a21 . agent retracts
a21 , assumption justification 34 longer supported architecture
retracts a34 . architecture ensures reasoning consistency across hierarchy levels
assumption persists longer context assertions led creation.
Assumption Justification solves inconsistency problem dependencies
hierarchical context captured justification. Within subtask, domain knowledge still required ensure consistency among enabled assumptions subtask.
However, across-level consistency knowledge needed. Assumption Justification still
supports local nonmonotonic hypothetical reasoning. Thus, Assumption Justification
appears meet functional evaluation criteria. However, order assess impact
performance, implementation details must considered.
3.2.1 Implementing Assumption Justification
Creating assumption justifications requires computing context dependencies assumption, similar computation justifications entailments. 2 Figure 7 outlines
procedure computing assumption justification data structure. procedure
invoked assertion created. procedure creates assumption justifications
every assertion local subtask; is, entailments well assumptions. approach allows architecture cache context dependencies local assertion.
advantage caching architecture simply concatenate assumption
justifications local assertions contributing directly creation assumption
2. Assumption Justification procedure, presented, requires inference engine record justification every assertion course processing. Soar, architecture Assumption
Justification implemented, calculations available production rule matcher
assumptions entailments. However, justification calculations assumptions may supported
architectures, requiring modifications underlying inference engine. Laird Rosenbloom
(1995) Soar Users Manual (Laird, Congdon, & Coulter, 1999) describe specific mechanisms
justification creation Soar.

364

fiEnsuring Consistency Hierarchical Execution

PROC create new assertion(. . .)
assumption justification computed new assertion
created. Thus, assumption justifications computed
assumptions entailments.
...
Ajust create justif ication(. . .)
Justifications created via well-known, textbook algorithms
(e.g., Forbus & deKleer, 1993; Russell & Norvig, 1995)
Aaj make assumption justif ication f assertion(A)
...
END
PROC make assumption justif ication f assertion(assertion A)
AJ NIL
assertion j Ajust , justification

1
(Level(j) closer root Level(A))
AJ append(j, AJ) (add j assumption justification)

2
ELSE
(j level)
AJ concatenate(jaj , AJ) (add assumption justification j
assumption justification A)
return AJ, list assertions comprising assumption justification
END
PROC Level(assertion A)
Return subtask level associated assertion
Figure 7: procedure building assumption justifications.
(in
2). chose caching option computing assumption justifications ondemand implementation would, assumption created, recursively follow
local dependencies context dependencies determined. advantage
caching implementation context dependencies assertion must computed once, even local assertion contributes creation multiple local
assumptions.
procedure creates assumption justification loops assertions
justification new assertion A. assertions justification either context
local assertions. Context assertions,
1, added assumption justification directly.
However, local assertions added assumption justification
assumption justification include context dependencies. example, architecture retract local assertion reasons change hierarchical
context (e.g., non-monotonic reasoning step change enabled assumptions
subtask) cases, agent necessarily retract dependent assumptions.
assumption justifications local assertions justification already
computed (i.e., cached, described above), assumption justification
365

fiWray & Laird

B C E

B C E

PSfrag replacements

(a)

12

(b)

1

Figure 8: Technical problems Assumption Justification. (a), assumption replaces
another assumption nonmonotonically. (b), multiple assumption justifications
assumption must supported.

local assertion j simply added assumption justification A,
2.
on-demand implementation, procedure would recur local assertions,
context dependencies local assertions contributing identified.
worst-case computational complexity algorithm polynomial number
assertions subtask. addition higher-level assertion done constanttime (a single pointer reference). However,
2 must uniquely add context assertions
assumption justification local assertion. (n 1) local assumption
justifications whenever nth assertion created. Thus, concatenation needs
performed (n1) times call assumption justification procedure.
limit provides upper bound O(n) complexity assumption justification
procedure: worst-case cost building individual assumption justification linear
number assertions, n, level. However, architecture executes assumption
justification procedure every assertion level. Thus, worst case cost building
justifications particular level O(1 + 2 . . . + n) O(n 2 ).
Non-monotonic changes complicate implementation. architecture must disable
replaced assumption, rather delete it, initial assumption may need
restored. example, Figure 8 (a), assume assertion E leads
assertion 2 local subtask retraction 1 (i.e., 2 revision 1).
agent retracts E, Assumption Justification retract 2, desired, must
re-enable 1. Thus, assumption 1 must remain available memory, although disabled.
Figure 8 (b) illustrates second problem. assumption multiple assumption justifications. justifications change reasoning progresses. Assumption 1
initially depends assertions A, B, C higher levels. assume later
processing, agent removes A, normally would result retraction 1.
However, meantime, context changed 1 justified {C,
D, E}. agent removes A, architecture immediately retract 1
must determine 1 justified sources.
implementation Assumption Justification Soar completed members
Soar research group University Michigan. Experiments using Air-Soar, flight
simulator domain (Pearson et al., 1993), showed overhead maintaining prior
assumptions level produced significant negative impact agent performance.
domain, Assumption Justification incurred significant computational cost, requiring
366

fiEnsuring Consistency Hierarchical Execution

least 100% time original Air-Soar agent. Further, number assumption
justifications maintained within level continued grow execution, reasons
explained above. subtasks required minutes execute aircraft performed
maneuver, leading large (and problematic) increases amount memory required.
Thus, Assumption Justification failed meet efficiency requirements theoretical
empirical grounds. Although limitations Assumption Justification might improved developing solutions technical problems, abandoned exploration
approach strongly discouraging results.
3.3 Dynamic Hierarchical Justification
Figure 2 introduced notion support set subtasks. Procedural Reasoning
System (PRS) (Georgeff & Lansky, 1987) Soar (Laird et al., 1987) use architectural
mechanisms retract complete levels subtask hierarchy support set longer
holds. section, consider solution leverages hierarchy maintenance
function ensure consistency assumptions higher level context.
significant disadvantage support set existing systems fixed.
Soar, support set computed initiation subtask updated
reflect reasoning occurs within subtask. example, Figure 2, suppose
assumption a34 depends assumptions a22 a21 (represented dashed, arrowed
lines). support set include 21 ; assertion may even present
Subtask3 created. local assumption depends assertion
support set, change assertion directly lead retraction
assumption (or subtask). Thus, approaches using Fixed Hierarchical Justification
(FHJ) still require knowledge-based solutions consistency. FHJ discussed
Section 5.1.2.
propose novel solution, Dynamic Hierarchical Justification (DHJ), similar
Fixed Hierarchical Justification, dynamically updates support set reasoning
progresses. Assumption justifications individual assumptions unnecessary. However,
one consequence simplification subtask (and assertions within it)
retracted dependent context changes. Refer Figure 2. DHJ agent
asserts a34 Figure 2, architecture updates support set Subtask 3 include a21 .
Assumption a22 already member support set need added again.
member support set Subtask 3 changes, architecture retracts entire
subtask. Thus Dynamic Hierarchical Justification enforces reasoning consistency across
hierarchy subtask persists long dependent context assertions.
3.3.1 Implementing Dynamic Hierarchical Justification
Figure 9 outlines procedure computing support set DHJ. Assumption
Justification, architecture directly add context assertions support set
1.
architecture computes dependencies local assertion
3, assertion
marked inspected
4. Inspected assertions simply ignored
future
2, architecture already added assertions dependencies
support set. architecture ignore dependent, local assumptions
2
dependencies assumptions already added support set.
367

fiWray & Laird

PROC create new assertion(. . .)
Whenever new assumption asserted, support set updated
include additional context dependencies.
...
Ajust create justif ication(. . .)
assumption
subtask asserted
Ssupport set append(Ssupport set , add dependencies support set(A))
...
END
PROC add dependencies support set(assertion A)
assertion j Ajust , justification

1
{Level(j) closer root Level(A)}
append(j, S) (append context dependency support set)

2


3

4

ELSEIF {Level(j) Level(A)
j assumption
j previously inspected }
append(S, add dependencies support set(j))
(compute support set dependencies j add S)
jinspected true
(js context dependencies added support set)

return S, list new dependencies support set
END
PROC Level(assertion A)
Return subtask level associated assertion
Figure 9: procedure Dynamic Hierarchical Justification.
DHJ needs inspect local assertion once, context dependencies
computed on-demand, rather cached Assumption Justification. Condition
2
true whenever local entailment whose context dependencies yet
computed. dependencies determined calling add dependencies support set
recursively. Recursive instantiations add dependencies support set receive local
assertion justification uninspected entailment, j, return list comprising
context dependencies j. return value appended support set
prior instantiation add dependencies support set.
recursive call add dependencies support set
3 non-constant time
operation procedure. must made assertion j thus
worst case complexity compute dependencies linear number assertions
level, Assumption Justification. However, DHJ requires single inspection
individual assertion, rather repeated inspections new assumption As368

fiEnsuring Consistency Hierarchical Execution

sumption Justification. Thus architecture needs call add dependencies support set n times subtask consisting n assertions, worst case cost
updating support set level remains O(n). reduction complexity potentially makes Dynamic Hierarchical Justification efficient solution Assumption
Justification, especially number local assertions increases.
Additionally, two technical problems outlined Assumption Justification
impact DHJ. DHJ never needs restore previous assumption. dependency
changes, architecture retracts entire level. Thus, DHJ immediately delete
replaced assumptions memory. DHJ collects dependencies assumptions,
need switch one justification another. Figure 8 (b), dependencies
A, B, C, D, E added support set. simplifications make
support set overly specific reduce memory computation overhead required
Dynamic Hierarchical Justification.
DHJ retractions sometimes followed regeneration subtask
re-assertion reasoning retracted. example, enemy plane fled
described TacAir-Soar scenario, DHJ would retract entire level associated
counting subtask. count would need re-started beginning.
Section 3.4.3 examines potential problems introduced interruption regeneration.
cost incurred regeneration previously-derived assertions primary
drawback Dynamic Hierarchical Justification.
3.4 Implications Dynamic Hierarchical Justification
Dynamic Hierarchical Justification solves specific problem maintaining reasoning
consistency hierarchy, guaranteeing consistency utilizing efficient algorithm.
heuristic DHJ employs assumes assumptions closely associated
subtasks retracting subtasks nearly equivalent retracting individual assumptions.
section explores implications heuristic, focusing task decompositions,
impact agents ability use persistent assumptions, feasibility interrupting
agent (with subtask retraction) midst reasoning.
3.4.1 Influence Task Decomposition
agents reasoning viewed knowledge search (Newell, 1990). perspective, inconsistency problem failure backtrack knowledge search. world
changes, leading changes agent hierarchy. agent must retract
knowledge previously asserted, backtrack knowledge state consistent
world state.3 solution described terms way achieves (or
avoids) backtracking knowledge search. instance, KBAC leads knowledge-based
backtracking, KBAC knowledge tells agent correct assumptions
given current situation.
3. Obviously, world state usually different agents initial state often impossible
return prior state execution system. use backtrack section refer
retraction asserted execution knowledge remaining asserted knowledge consistent
currently perceived world state.

369

fiWray & Laird

B C E F G H

(a)

1

B C E
(b)

2

1

2

Figure 10: Examples (a) disjoint dependencies (b) intersecting assumption dependencies.

Assumption Justification form dependency-directed backtracking (Stallman &
Sussman, 1977). dependency-directed backtracking, regardless chronological order
architecture makes assertions, architecture identify retract
assertions contributed failure search retain assertions. Assumption Justification, architecture retracts assumptions directly affected
change context. Assumptions created later processing, dependent
change, unaffected. Consider examples Figure 10. (a), assumptions
1 2 depend upon disjoint sets assertions. Assumption Justification, removal assertion 1s assumption justification result retraction 1; 2
unchanged, even architecture asserted 2 1.
Dynamic Hierarchical Justification similar backjumping (Gaschnig, 1979). Backjumping heuristically determines state current search backtrack
backjump. heuristics used backjumping based syntactic features
problem. instance, constraint satisfaction problems, backjumping algorithm
identifies variable assignments related variable assignments via constraints specified problem definition. violation discovered, algorithm
backtracks recent, related variable (Dechter, 1990). Intervening variable assignments discarded. DHJ, assertion hierarchy changes, system
backjumps knowledge search highest subtask hierarchy dependent
change. Figure 10 (a) dependent assertions collected support set
subtask. higher level assertions change, entire subtask removed.
using DHJ, backjumping, previous knowledge search may need
repeated backtracking. Assume removal subtask Figure 10 (a)
due change A. similar subtask reinitiated, assumption 2 may need
regenerated. regeneration unnecessary 2 need retracted
avoid inconsistency. Dynamic Hierarchical Justification, agent retracts
reasoning dependent subtask (and lower levels hierarchy); assertions
dependent change context removed. Thus, backjumping, DHJ
uses syntactic feature reasoning (decomposition subtasks) choose backtracking
point backtracking always conservative possible.
Although subtask decomposition syntactic feature knowledge search,
strongly principled one, reflecting semantic analysis task knowledge designer. Hierarchical task decomposition based premise tasks broken
discrete units little interaction units; nearly decom370

fiEnsuring Consistency Hierarchical Execution

posable (Simon, 1969). Thus, goal hierarchical decomposition separate mostly
independent subtasks one another. consequence separation dependencies higher levels limited much possible (interaction subtasks
minimized) dependencies among assertions particular subtask
shared (otherwise, subtask could subdivided two independent subtasks).
course, often possible decompose given task many different ways.
cases domain imposes minimal constraint knowledge engineer significant
latitude crafting task decomposition.
situation illustrated Figure 10, (b) would complete decomposition
task knowledge engineer (a), assuming two alternatives represent
decomposition task. (b), number dependent assertions necessarily grow function number assumptions local level, (a)
does. Further, (a), two independent assumptions pursued. assumptions
could potentially inferred separate subtasks alternate decomposition. (b),
hand, assumptions subtask closely tied together terms
dependencies thus better asserted within subtask. dependencies assumptions 1 2 considerable overlap (b), Assumption Justification
pays high overhead cost track individual assumptions (most) everything
local subtask would removed simultaneously assertions B, C, changed. DHJ incurs overhead, DHJ better choice intersection
assumption dependencies high. Task knowledge structured situation
(b), rather (a) would lead unnecessary retractions. (b) appears
better reflect well-decomposed tasks, Dynamic Hierarchical Justification constrain
knowledge development process improve resulting decompositions. Consequently,
nearly-decomposed tasks allow DHJ avoid unnecessary regenerations
avoiding processing overhead Assumption Justification.
3.4.2 Limiting Persistence DHJ
DHJ limits persistence subtasks, resulting assumptions persistent
assumptions typical truth maintenance systems. section explores consequences
limitations determine DHJ architectures 4 still provide persistence
necessary agent execution (Section 2.1).
DHJ retract subtask potential inconsistency could impact hypothetical
recursive reasoning counting. Consider aircraft classification counting example.
Perhaps aircrafts altitude contributes hypothetical classification aircraft
(e.g., particular altitude speed combinations might suggest reconnaissance aircraft).
agent would create assumptions locally depend aircrafts altitude.
altitude (or altitude boundary) changes, assumption retracted.
retraction required avoid inconsistency. contacts altitude longer suggests
reconnaissance aircraft, assumption depended assertion
removed. DHJ captures dependencies performs retraction. agent
4. clarity, Assumption Justification already eliminated candidate solution,
following discussion focuses exclusively DHJ. However, Assumption Justification limits persistence
similarly.

371

fiWray & Laird

opportunity reconsider classification aircraft, pursue tasks
classification longer important.
DHJ retract subtask assumption created local subtask
purpose remembering input (or elaboration input). example, agent
needed remember particular aircrafts altitude particular point time,
assumption cannot stored local subtask. DHJ limits persistence way
remembering within local subtask generally impossible.
order remember previous situations, assumptions asserted root task.
assumption asserted level never retracted higher level
dependencies (assuming percepts associated top level higher input
level, Theo, Mitchell et al., 1991). primary drawback requirement
remembering remembered items longer local subtask created them,
requiring additional domain knowledge manage remembered assumptions. However,
remembering already requires domain knowledge; possible remember assertion
regardless dependencies able retract architecturally.
examples show Dynamic Hierarchical Justification still allows forms
persistence, trades capturing dependencies nonmonotonic assumptions local subtasks remembering assumptions root task, dependencies captured.
DHJ forces remembered items root task, suggests fundamental aspect root task managing remembered assumptions. view
requirement positive consequence DHJ, forces knowledge engineers
better recognize reasons creating assumption (e.g., remembering vs. hypothetical) circumscribes remembering develop adopt functional
temporal theories manage assumptions created remembering (e.g., Allen, 1991;
Altmann & Gray, 2002).
3.4.3 Recovery Interruption DHJ
Dynamic Hierarchical Justification makes agent reactive environment, ensuring relevant changes environment lead retraction dependent
subtasks. DHJ imposes automatic interruption agent subtask retraction,
without evaluating state system first. Although automatic interruption increases
reactivity system, lead difficulties way override it.
section examine two cases uncontrolled interruption cause problems.
problems arise DHJ biases system reactive; is, respond automatically changes environment without deliberation. However, cases,
additional agent knowledge overcome bias make system deliberate
avoid uncontrolled interruption.
first problem arises sequence actions must completed
without interruption order subgoal achieved. processing interrupted,
possible, dynamics world, task cannot resumed.
example, imagine aircraft nearing point launch missile target.
task interrupted resumed, aircrafts position may changed
enough, relative target, additional steering commands necessary
372

fiEnsuring Consistency Hierarchical Execution

missile launched. case, may preferable interrupt original
launch sequence begun.
Consider two possible approaches achieving capability Dynamic Hierarchical
Justification architectures. first move processing root task.
root task interrupted, processing interrupted. However,
approach greatly restricts task hierarchically decomposed thus
considered last resort. second approach add new reasoning task
freezes external situation respect additional reasoning subtask.
new processing initiates execution subtask creates persistent structures
root task. persistent structures represent deliberate commitment
interrupted. remaining processing subtask accesses structures
execution task. Thus, persistent, even changes
surrounding situation would interrupted subtask, processing
insensitive changes interruption prevented. approach requires
additional reasoning recognize completion uninterruptible behavior remove
persistent structures built initial subtask. reasoning reflects deliberate act,
signaling commitment longer holds. abstract, together additions
provide mechanism overcoming automatic interruption. disadvantage
approach that, part system design, subgoals cannot interrupted
must identified beforehand. subtasks, additional agent knowledge must
implemented create remove encapsulations dynamic data.
critical problem DHJ Wesson Oil problem: someone cooking
dinner higher-priority activity suddenly occurs (a hurt child), cook turn
stove (a cleanup procedure) leaving hospital (Gat, 1991b). problem
occurs change hierarchical context level far terminal
level hierarchy. situation, similar tasks may resumed initiated
following interruption. agent must therefore recognize whether cleanup
external and/or internal states necessary, and, so, perform cleanup. Even
DHJ, agent still behave appropriately right knowledge. particular,
agent must able recognize partially completed tasks (like cooking dinner)
able select cleanup actions specific task state (like turning stove burner).
DHJ requires remembered assumptions asserted root level
hierarchy, recognition task internal state available; need try reconstruct
state external environment alone. However, require analysis
task domain(s) knowledge engineer interruptible activity requiring
cleanup include triggering assertions cleanup root task.
work prompted desire architectural solutions inconsistency, yet
maintaining consistency efficiently lead interruptions, which, DHJ, requires
knowledge-based solutions problems arising automatic interruption. 5 However,
requirements imposed DHJ positive consequences. Subtask retractions
observed recovery development process help define must remembered
root task cleanup, significantly different laborious process debugging
5. Dynamic Hierarchical Justification could used trigger meta-level deliberation rather
immediate subtask retraction. would possibly provide architectural solution question
deliberate potential inconsistency intention reconsideration (see Section 5.2).

373

fiWray & Laird

agent programs failing due inconsistency. theory, Dynamic Hierarchical
Justification imposes requirements handling interruptions pose serious questions
overall utility. practice, found addressing questions
problem variety recent agent implementations using Soar-DHJ architecture (e.g.,
Laird, 2001; Wray et al., 2002).

4. Empirical Evaluation Dynamic Hierarchical Justification
Architectural mechanisms DHJ must efficient. demonstrated
algorithm efficient, question impact overall behavior generation
capability agent remains open question due interruption regeneration. Given
complexity agent-based systems domains applied,
analytical evaluations must extremely narrow scope, even require specialized
techniques (Wooldridge, 2000). section instead pursues empirical evaluation
Dynamic Hierarchical Justification, focusing efficiency responsiveness two domains
extremes continua agent domain characteristics. architectural
solution inconsistency motivated cost (and incompleteness) knowledgebased solutions, knowledge development costs estimated.
4.1 Methodological Issues
Dynamic Hierarchical Justification general solution, applicable wide range agent
tasks. order evaluate solution, number methodological issues must
addressed. following describes three important issues choices made
evaluation.
4.1.1 Relative vs. Absolute Evaluation
constitutes good poor cost performance evaluations? general,
absolute evaluation performance cost difficult task itself, addition
agents knowledge architecture, determines overall cost performance results.
circumvent problem making relative comparisons agents using
original, Fixed Hierarchical Justification Soar architecture (FHJ agents) new agents
(DHJ agents). FHJ agents provide cost performance benchmarks, obviating
need absolute evaluations.
4.1.2 Addressing Multiple Degrees Freedom Agent Design
Even architecture task fixed, many different functional agents developed. one know comparative results valid general experimenter
control benchmarks new agents?
DHJ agents compared agents previously implemented others. systems
provide good performance targets, optimized performance,
minimize bias, developed independently.
FHJ systems used fixed benchmarks, modified. DHJ agents use
identical task decompositions employed FHJ agents initial knowledge
base. observed opportunities improve performance DHJ agents modifying
374

fiEnsuring Consistency Hierarchical Execution

either task decomposition re-designing significant portions agent knowledge
base. However, agent knowledge modified necessary correct behavior,
order ensure DHJ agents remained tightly constrained FHJ counterparts,
thus limiting bias evaluation.
4.1.3 Choice Representative Tasks
evaluation limited execution agents Dynamic Blocks World
reduced-knowledge version TacAir-Soar (micro-TacAir-Soar). choice
tasks domains considerable drawback benchmarks (Hanks, Pollack, & Cohen, 1993). Although choices motivated primarily availability domains
pre-existing FHJ agents, two domains represent opposite extremes many
domain characteristics. Micro-TacAir-Soar, TacAir-Soar, inaccessible, nondeterministic, dynamic, continuous, Dynamic Blocks World simulator used
experiments accessible, deterministic, static discrete. primary motivation
using Dynamic Blocks World, less representative typical agent tasks
Micro-TacAir-Soar, assess cost employing DHJ domain priori
appears would useful (although Section 6 suggests DHJ prove useful even
relatively static domains). Thus, Dynamic Blocks World provide baseline
actual cost deploying algorithm, even though little benefit expected
deployment domain.
4.2 Evaluation Hypotheses
Although specific expectations differ different domains, differences dimensions
knowledge cost performance anticipated comparing DHJ agents
baseline agents. following discusses expectations metric(s) used
dimension.
4.2.1 Knowledge Engineering Cost
Knowledge engineering effort DHJ agents decrease comparison previously
developed agents. Knowledge Soar represented production rules. production
represents single, independent knowledge unit. assume addition productions represents increase cost measure knowledge cost counting number
productions type agent. number productions, course, provides
coarse metric cost complexity individual productions varies significantly.
However, productions removed DHJ agents often difficult
ones create. Therefore, difference number productions probably conservative
metric knowledge cost DHJ.
4.2.2 Performance: Efficiency Responsiveness
general, overall performance change little DHJ agents, compared FHJ
counterparts. Although Dynamic Hierarchical Justification add new architectural
mechanism, algorithm efficient contribute significant differences performance. Further, less domain knowledge need asserted
375

fiWray & Laird

across-level consistency knowledge incorporated architecture. Thus, applying across-level KBAC knowledge represented significant expense overall cost
executing task, DHJ agents might perform better FHJ agents.
two specific exceptions expectation. First, domains consistency knowledge (mostly) unnecessary task performance, FHJ agents may perform
better DHJ agents. example, Dynamic Blocks World requires little consistency knowledge DHJ architecture still update support set, even though
inconsistency-causing context changes arise.
Second, regeneration problematic, overall performance suffer. DHJ, whenever
dependent context changes, subtask retracted. change lead
different choice subtask, subtask necessarily regenerated. Thus,
DHJ, subtask regeneration occur, and, regeneration significant, performance
degradation result.
CPU execution time provides simple, single dimension gross performance. CPU
time reported individual experiments reflects time agent spends reasoning
initiating actions rather time takes execute actions environment.
Decisions: Soar, subtasks correspond selection operators subgoals
implementing operators. selection operator called decision. Soar
selects operator, tries apply operator. Soar reaches impasse cannot
apply newly selected operator. non-primitive operators lead generation
subgoal subsequent decision. example, Soar selects put-down operator
one decision creates subgoal implement put-down subsequent decision.
Together, two steps constitute notion subtask Soar.
number decisions thus used indication number subtasks
undertaken task. FHJ, subtask generally never interrupted terminated
(either successfully unsuccessfully). DHJ, subtasks interrupted whenever
dependent change occurs. Thus, decisions increase DHJ agents subtasks
interrupted re-started. Further, decisions increase substantially (suggesting
significant regeneration), overall performance degrade.
Production Firings: production rule fires conditions match result
applied current situation. Production firings decrease DHJ two reasons.
First, across-level consistency knowledge previously used FHJ agents
longer necessary (or represented); therefore, knowledge accessed. Second,
reasoning occurred inconsistency arose FHJ agents interrupted
eliminated. However, production firings increase significant regeneration necessary.
4.3 Empirical Evaluation Blocks World
Agents Dynamic Blocks World domain execution knowledge transform
initial configuration three blocks ordered tower using simulated gripper arm.
table simulation width nine blocks. agents task goal always
build 1-on-2-on-3 tower. agent built tower resulting 981 unique,
non-goal, initial configurations blocks. Table 1 summarizes results tasks.
expected, total knowledge decreased. Overall performance improved. Decisions increased,
expected, number rule firings increased well, anticipated.
376

fiEnsuring Consistency Hierarchical Execution

Rules
Decision Avg.
Avg. Rule Firings
Avg. CPU Time (ms)

FHJ
x
s.d.
188

87.1
20.9
720.3 153.5
413.1 121.6

DHJ
x
s.d.
175

141.1
38.7
855.6 199.6
391.6 114.0

Table 1: Summary knowledge performance data Blocks World. agents
performed tower-building task 981 configurations. Task order
randomly determined.

4.3.1 Knowledge Differences
Total knowledge decreased 7% DHJ agent. small reduction consistent
expectation. aggregate comparison misleading knowledge
added (16 productions) deleted (29).
Removing Consistency Knowledge: Soar, subtask operator subgoal
terminated separately. Soar monitors impasse-causing assertions determine subgoal
(such subtask goal) removed via FHJ. However, removal subtask
operator requires knowledge. original, FHJ architecture treats initiation
operator persistent assumption requires knowledge recognize selected
operator interrupted terminated. knowledge categorized consistency knowledge determines time subtask terminated,
even initiating conditions subtask longer hold.
DHJ, effects operators persistent; assertions entailments
situation. Thus, initiation subtask treated entailment
subtask remains selected long initiation conditions subtask hold.
change removes need knowledge terminate subtask: subtask
initiation conditions longer true, subtask automatically retracted. Thus,
termination knowledge removed subtask operators.
Filling Gaps Domain Knowledge: persistence subtasks original architecture allows FHJ agents ignore large parts state space domain knowledge.
example, knowledge initiates stack put-on-table subtasks assumes
gripper currently holding block. tasks executed, gripper,
course, grasp individual blocks. conditions initiating stack put-on-table
holding block ignored original domain knowledge.
DHJ agent requires knowledge determine subtasks choose
holding blocks, subtasks interrupted agent still holds block.
16 productions necessary, primarily stack put-on-table operators.
important note knowledge necessary domain knowledge. FHJ agents could
solve problem began task holding block lacked
domain knowledge states. additions thus positive consequence
DHJ. architectures enforcement consistency revealed gaps domain knowledge.
377

fiWray & Laird

4.3.2 Performance Differences
Somewhat surprisingly, overall performance DHJ agents (measured CPU time) improves slightly comparison FHJ agents, even though decisions production
firings increase. Soar-specific performance metrics considered individually
below, overall performance improvement considered.
Decisions: FHJ agents, average, made considerably fewer decisions DHJ agents.
difference consistent across every task. additional decisions result
removal subsequent regeneration subtasks. example, agent picks
block pursuit stack task, selection stack task must regenerated.
knowledge DHJ agents could modified avoid testing specific configurations
blocks thus avoid many regenerations.
Production Firings: number production firings increased Blocks World.
increase production firings attributed knowledge added system
regeneration subtasks made additions necessary. relative increase
number production firings (19%) much smaller increase decisions (62%).
smaller difference attributed productions removed (and thus
fire).
CPU Time: Generally, production firings increase Soar, increase CPU
time expected. However, CPU time DHJ decreased slightly comparison FHJ
even though production firings increased. explain result, additional aspects
Soars processing must considered.
match cost production constant grows linearly number
tokens, partial instantiations production (Tambe, 1991). token indicates
conditions production matched variable bindings conditions.
Thus, token represents node search agents memory matching
instantiation(s) production. specific productions conditions are,
constrained search memory, thus costs less generate instantiation.
new productions added DHJ Blocks World agent specific
agents memory (i.e., external internal state) productions removed.
Further, simply fewer total productions reduce amount total search
memory.6 informal inspection match time tokens several FHJ
DHJ runs showed number tokens decreased DHJ 10-15%. reduction
token activity primary source improvement Dynamic Blocks World DHJ
agent CPU time. improvement, course, general result provides
guarantee task domain cost matching increase rather
decrease.

6. RETE algorithm (Forgy, 1979) shares condition elements across different productions. Thus,
removal productions decreases total search removed productions contain condition elements
appearing remaining productions. perform exhaustive analysis condition
elements determine removed productions reduce number unique condition elements
RETE network.

378

fiEnsuring Consistency Hierarchical Execution

4.4 Empirical Evaluation TacAir-Soar
Converting TacAir-Soar DHJ architecture would expensive, requiring many
months effort. DHJ agents instead developed research instruction version
TacAir-Soar, Micro-TacAir-Soar (TAS). TAS agents use TacAir-Soar simulation
environment (ModSAF) interface knowledge fly missions, resulting order magnitude decrease number productions agents. However,
TAS uses tactics doctrine missions TacAir-Soar.
TAS, team two agents (lead wing) fly patrol mission described
previously. engage hostile aircraft headed toward within
specific range. lead agents primary role fly patrol route intercept
enemy planes. wings responsibility fly formation lead.
total knowledge significantly reduced, converting TAS DHJ agents relatively
inexpensive. However, results representative TacAir-Soar TAS
retains complexity dynamics TacAir-Soar.
patrol mission clearly-defined task termination condition Dynamic
Blocks World. address problem, agent simulation executes ten
minutes simulator time. time, agent opportunity take off,
fly formation partner patrol, intercept one enemy agent, return patrol
intercept. actual TacAir-Soar scenario, activities would normally
separated much larger time scales. However, agent spends much time
patrol mission simply monitoring situation (waiting), rather taking new actions.
Ten minutes simulated time proved brief enough overall behavior
dominated wait-states, providing time natural flow events.
running fixed period time, increase number decisions
attributed regeneration simply improvement decision cycle time. avoid
potential confusion running simulator constant cycle time. mode,
simulator update represents 67 milliseconds simulated time. agent
runs fixed period time fixed updates, FHJ DHJ agent execute
number decisions. problems due regeneration apparent
number rule firings degradation responsiveness. Additionally, general results
change significantly scenarios executed real-time mode normally
used TacAir-Soar agents. fixed cycle simply eliminates variability.
Although patrol scenario designed minimize variation run run,
TAS simulator inherently stochastic specific actions taken agent
time course actions varies task repeated. control variation, scenario run lead wing agents approximately 50 times. Logging
data collection significantly impacted CPU time performance statistics.
order control effect, actually ran scenario 99 times, randomly choosing
one agent (lead wing) perform logging functions (and discarding performance measures). agent performed logging functions. Data logging agents used
create Figure 9. performance measures logging agents recorded
conclusion scenario summarized Table 2.
379

fiWray & Laird

Lead Agent
Rules
Number runs (n)
Decisions
Outputs
Rule Firings
CPU Time (msec)

FHJ
591
43
x s.d.
8974
0.0
109.1 6.71
2438 122
1683 301

x
8974
142.8
2064
1030

DHJ
539
53
s.d.
0.0
7.03
81.1
242

Wing Agent
FHJ
DHJ
591
539
56
46
x s.d.
x s.d.
8958
0.0
8958
0.0
1704 42.7
869 12.8
16540 398
6321 104
12576 861
2175 389

Table 2: Summary TAS run data.
4.4.1 Improving Task Decompositions
TacAir-Soar DHJ agents required extensive knowledge revision. revision
unexpected. instance, unlike Dynamic Blocks World, TAS agents remember many
percepts, last known location enemy aircraft. previously described,
assertions remembering must located root level hierarchy, thus
requiring knowledge revision. However, problems discovered.
cases, FHJ agents took advantage inconsistency asserted knowledge. words,
FHJ agent allowed inconsistency assertions actually depended
inconsistencies apply new knowledge. two major categories knowledge.
Within-level consistency knowledge recognized specific inconsistencies (e.g., retraction
proposal subtask) trigger actions clean subtask
state. Complex subtasks allowed non-interruptible execution complex procedure
regardless continuing acceptability subtask. cases, agent knowledge
modified remove dependence inconsistency. Appendix provides
explanation original knowledge subsequent changes. Section 4.4.3 summarizes
changes quantitatively.
4.4.2 Results
Table 2 lists average data FHJ DHJ lead wing agents patrol/intercept
scenario modifications DHJ agents knowledge base completed.
results domain consistent expectations: total knowledge decreases, rule
firings decrease performance improves, substantially DHJ wing agent.
following sections explore results greater detail.
4.4.3 Knowledge Differences
Table 3 quantifies changes Soar production rules described above. 7 Modifications include deletions, additions changes. rule considered changed
conditions changed slightly, made type computation
subtask. example, changed within-level consistency knowledge refers
7. DHJ agent data generated knowledge base included changes accommodate
learning (Wray, 1998) changes included table completeness. presence
rules knowledge base negligible impact performance data reported here.

380

fiAcross-level
Consistency

Remembering

Within-level
Consistency

Complex
Subtasks

Learning

Miscellaneous

Ensuring Consistency Hierarchical Execution

44
0

36
32

9
5

10
21

4
0

8
1

0

33

8

0

24

0

FHJ Agent:
Deletions:
Additions:
DHJ Agent:
Additional Changes:

TOTALS
591
(111)
59
539
65

Table 3: Quantitative summary changes production rules FHJ agent knowledge
base DHJ agents.

entailed structure rather one created assumption, structure
located subtask. somewhat restrictive definition change inflates
addition deletion accounting. many cases production deleted immediately added different subtask. example, productions manipulate
motor commands moved local subtasks highest subtask. Almost
additions deletions Remembering category attributed move,
required synthesis new production knowledge.
Total knowledge required DHJ agents decreased. approximately 9% reduction achieved making type modification 40% FHJ agent
rules, may seem modest gain, given conversion cost. However, cost
artifact chosen methodology. DHJ agents constructed domain
without previously existing FHJ agents, least 9% decrease total knowledge would
expected. result thus suggests reduction cost agent design.
high conversion cost suggest converting much larger system, TacAir-Soar,
would probably costly. hand, modifications made evident
identifiable regenerations architecture. Thus, 235 total changes made FHJ
knowledge base much easier make constructing similar number rules.
4.4.4 Performance Differences
performance results Table 2 show, DHJ agents improved performance relative
FHJ peers. However, improvements lead wing agents substantially
different. Differences tasks lead wing pilots led differences relative
improvements.
Lead Wing Agents: lead wing agent share knowledge base
perform different tasks TAS scenario. 8 differences lead differences
8. agents share knowledge base dynamically swap roles execution.
instance, lead exhausts long-range missiles, order wing take lead role,
take role wing itself.

381

fiWray & Laird

2000

DHJ Lead
DHJ Wing
FHJ Lead
FHJ Wing

Cumulative Outputs

1500

1000

500
intercept

launch missile

patrol turns

resume patrol
0
0

100

200

300

400

500

600

Time (sec)

Figure 11: Cumulative outputs course one ten minute scenario DHJ (black)
FHJ (gray) agents. Cumulative outputs lead agents represented
solid lines, wing agents dashed lines.

absolute performance. Recall leads primary responsibility fly patrol route
intercept enemy aircraft. hand, wings primary mission role follow
lead. different tasks require different responses agents.
agents overall reasoning activity often correlated output activity;
is, commands sends external environment take action it. Figure 11
summarizes output activity two pairs lead wing agents (FHJ & DHJ)
course ten-minute scenario. output activity leads mostly concentrated
places course scenario (take-off, intercept, launch-missile,
resuming patrol following intercept). wings concentrated output
activity occurs leads turn new leg patrol wings must follow
lead 180 degree turn. remainder section, focus DHJ
agents contrast lead wing agent behavior. discussion performance metrics
examine differences FHJ DHJ leads wings.
lead actually spends scenario waiting, short bursts reasoning
output activity occurring tactically important junctures scenario. patrol,
lead flies straight makes decision turn reaches end patrol
leg. lead monitors environment searches enemy planes. search
382

fiEnsuring Consistency Hierarchical Execution

(mostly) passive; agents radar notifies agent new entities detected.
detecting classifying enemy plane potential threat, lead commits
intercept. lead immediately makes number course, speed, altitude adjustments,
based tactical situation. actions evident figure pulse labeled
intercept. lead spends time intercept closing distance
aircraft get within weapon range, maneuver little thus
requiring actions environment (thus relatively flat slope following intercept).
agent reaches missile range enemy plane, lead executes number
actions quickly. lead steers plane launch window missile, pushes
fire button, waits missile clear, determines course maintain
radar contact missile flies target (at launch-missile). intercept
completed, lead resumes patrol task. Again, issues large number output
commands short period time. examples show leads reasoning focuses
primarily reacting discrete changes tactical situation (patrol leg ended, enemy
range, etc.) behavior generally requires little continuous adjustment.
execution wings follow-leader task, hand, requires reaction
continuous change leads position order maintain formation. Position corrections
require observing leads position, recognizing undesired separation formation,
responding adjusting speed, course, altitude, etc. wing following
lead throughout scenario, executing position maintenance knowledge almost
constantly. lead flying straight level, patrol leg, wings task
require generation many outputs. Figure 11, periods little activity
evident periodic flat segments wings cumulative outputs. lead
begins maneuver (e.g., turn), wing must maintain formation throughout
maneuver. turn wing generates many motor commands follows lead.
turn takes seconds complete, outputs increase gradually
course turn, seen figure. Thus, wing periodically encounters
dynamic situation requires significant reasoning motor responses. Further,
response change discrete, lead, occurs continuously
course leads maneuver.
differences tasks two agents account relatively large absolute
differences performance metrics lead wing agents. wings
adjusting positions relative leads, issue many output commands
leads, requires many inferences determine commands
be.
Decisions: differences decisions lead wing due artifact
data collection. lead agents ran extra second wings halted order
initiate data collection.
Production Firings: lead wing agents, production firings decrease. However, wings production firings decrease 62%, lead, decrease
15%. One reason large improvement DHJ wing due elimination
redundant output commands FHJ agents. FHJ wing sometimes issues
motor command once. reason duplication specific motor command computed locally, thus available subtasks. cases,
two subtasks may issue motor command. command stored locally,
383

fiWray & Laird

command may issued agent cannot recognize command
already issued another subtask. motor commands remembered
top subtask DHJ agents, inspected subtasks. DHJ wing thus
never issues redundant motor command. large relative decrease outputs
wing agent FHJ DHJ (Figure 11) attributed improvement. Production firings decrease decrease output activity reasoning activity
wing concerns reacting leads maneuvers.
contrast wing, leads average number outputs actually increases. Regeneration source additional outputs. situations, DHJ agents
subtask adjusting heading, speed altitude get updated repeatedly highly
dynamic situation (e.g., hard turn). FHJ agent uses subtask knowledge decide
current output command needs updated. However, DHJ, subtask may
retracted due dependence changing value (e.g., current heading). subtask regenerated following retraction, lead may generate slightly different motor
command. example, lead might decide turn heading 90.1 instead 90.2 .
decision causes generation new output command would
re-issued FHJ agents accounts small increase outputs. suggests
without self-imposed constraint methodology, knowledge base could
modified avoid regeneration decrease production firings.
Although large magnitude improvement wing primarily due remembering motor commands, agents needed less consistency knowledge thus
accessed less knowledge performing task. agents perform tasks
using less knowledge.
CPU Time: CPU time decreases DHJ lead wing agents. improvement
lead (39%) half improvement wing (81%). differences due
primarily decrease production firings. fewer production firings thus
fewer instantiations generate, leading improvements CPU time. Match time
improved, contributing overall performance improvement. 9 larger improvements
CPU time compared production firings improvements (39% vs. 15% lead,
81% vs. 62% wing) might attributable decreases number rule
firings match time. Again, results offer guarantee match time always
decrease DHJ. important note, however, two different domains DHJ
reduces total knowledge constrains remaining knowledge. architecture
leveraged small differences improved overall performance.
4.4.5 Differences Responsiveness
CPU time decreases DHJ agents, responsiveness generally improve.
However, agent knowledge split several different subtasks,
actions may initiated quickly would initiated FHJ agent.
section, explore differences responsiveness one situations.
9. Dynamic Blocks World, trends based observations data, rather
significant analysis. particular, TAS, data number tokens generated collected.
results reported consistent expectation token activity falls DHJ agents,
compared FHJ agents.

384

fiEnsuring Consistency Hierarchical Execution

FHJ
DHJ

Avg. In-Range Time
(sec)
161.816
162.048

Avg. Launch Time
(sec)
162.084
162.993

Reaction Time
(sec)
.268
.945

n
95
99

Table 4: comparison average reaction times launching missile TAS.
enemy plane comes range, agent executes series actions, leading
firing missile. Reaction time difference time enemy
agent comes range time agent actually pushes fire button launch
missile. reaction time one measure agents responsiveness. Table 4 shows,
FHJ agent able launch missile quarter second. However,
DHJ agent three-and-a-half times slower FHJ agent launching
missile, taking almost full second, average.
Split subtasks, regeneration, subtask selection contribute increase
reaction time. Splitting subtask n steps, may executed
single decision previously, may take n decisions DHJ agent. actions
necessary launching missile one would expect increase of, most,
hundred milliseconds change. However, dividing subtasks separate steps,
sequential series actions interrupted. particular, number regenerations
occur launch-missile subtask agent prepares fire missile highly
dynamic situation. agent sometimes chooses undertake similar action
situation changed enough slightly different action might necessary, described
above. result DHJ agents taking accurate aim FHJ agents,
responding quickly dynamics environment. aiming,
however takes time, although increase time tactically significant (i.e.,
enemy planes escaping previously hit FHJ agents).
additional re-engineering knowledge would improve reaction time (e.g.,
described Section 3.4.3). However, decreases responsiveness difficult avoid,
general. Dynamic Hierarchical Justification requires subtasks different dependencies initiated terminated separately, risk unnecessary regeneration. However,
splitting complex tasks separate subtasks, individual actions delayed subtasks separate procedures, selection particular
subtask series postponed additional subtask choices available.
4.5 Summary Empirical Evaluations
Figure 12 summarizes results Dynamic Blocks World TAS. domains,
DHJ agents require fewer total productions, suggesting decrease knowledge cost. Performance roughly Dynamic Blocks World lead agents TAS.
DHJ wing agents show much greater improvement overall performance, due
DHJ changes knowledge. results suggest Dynamic Hierarchical
Justification expected reduce engineering effort degrade performance
variety domains, simple complex. However, response time situations may
decrease.
385

fiWray & Laird

600
500

Productions

400
300
200
FHJ Lead
FHJ Wing
FHJ DBW

100

DHJ Lead
DHJ Wing
DHJ DBW

0
0

1

2

3

4

10

11

12

13

14

CPU Time (sec)

Figure 12: Mean CPU Time vs. knowledge productions FHJ (black) DHJ (gray)
agents Dynamic Blocks World TAS. graph includes actual
distribution CPU time agent well mean agent.
Means Dynamic Blocks World agents illustrated squares, TAS
lead agents triangles, TAS wing agents diamonds.

5. Discussion
Solutions KBAC new solutions introduced developed
inconsistency problem (Wray, 1998). briefly introduce additional solutions,
consider relationship Dynamic Hierarchical Justification intention reconsideration belief-desire-intention agents belief revision.
5.1 solutions inconsistency across hierarchy
section, review existing architectural solutions problem inconsistency arising persistence hierarchy assertions.
5.1.1 Limiting Persistence
One obvious approach eliminating inconsistency arising persistence disallow
persistent assumptions altogether. approach adopted Theo (Mitchell et al.,
1991). reasoning Theo entailed sensors; perceptual inputs unjustified.
Theo cannot reason non-monotonically particular world state; world
change non-monotonically. Thus, Theo cannot generally remember previous inputs.
386

fiEnsuring Consistency Hierarchical Execution

Another possible limitation would restrict assumptions single memory
(global state), or, equivalently, allow assumptions root level hierarchy
hierarchical architecture. solution ensures hierarchical context always
consistent (all assertions within associated subtask entailments) allows
persistence. HTN execution systems RETSINA DECAF, mentioned
previously, global state, obviously suffer inconsistency
hierarchy. However, interactions persistent assertions new information
derived sensors problem systems global state.
RETSINA recently adopted rationale-based monitoring (Veloso, Pollack, & Cox,
1998) identify environmental changes could impact currently executing task network (Paolucci et al., 1999). Rationale-based monitoring uses structure plan knowledge (in case, plan operators, including task networks) alleviate inconsistency. Monitors relevant world features created dynamically planning progresses identifying
pre-conditions operators instantiating via straightforward taxonomy monitor types (e.g., monitor quantified conditions). collection monitors form plan
rationale, reasons support planners decisions (Veloso et al., 1998). Plan rationales
thus similar justifications used truth maintenance. Monitors activated
pre-condition element world changes. inform planner
change, planner deliberate whether change impact
plan construction and, so, consider appropriate repairs.
Rationale-based monitoring similar Dynamic Hierarchical Justification, especially
leverage structures (different) underlying task representations provide consistency. However, two important differences. First,
DHJ identifies specific subtask impacted change, require deliberation
determine impact change; immediate return consistent knowledge state
possible. monitor activated rationale-based monitoring, planner must
first determine plan affected, require deliberation. Second,
monitors trigger deliberation, rather automatically retracting reasoning,
agent using rationale-based monitoring determine plan repaired
how. DHJ (as implemented) offer flexibility; retraction automatic. Automatic retraction assumes cost retrieving (or regenerating) pre-existing plan knowledge
less costly deliberation determine if/how plan revised. plan
modification expensive plan generation (Nebel & Koehler, 1995), assumption reasonable. However, invoking deliberate revision process could circumvent
potential problems arising recovery interruption (Section 3.4.3).
5.1.2 Fixed Hierarchical Justification
mentioned previously, pre-DHJ version Soar Procedural Reasoning
System (PRS) (Georgeff & Lansky, 1987) use Fixed Hierarchical Justification retract
complete levels hierarchy support set longer holds. PRS, support
set consists set context elements must hold execution subtask.
elements defined knowledge engineer. Fixed Hierarchical Justification offers
complete solution inconsistency problem context references within reasoning
subtask limited support set. approach guarantees consistency. However,
387

fiWray & Laird

requires knowledge designer identify potentially relevant features used
reasoning within subtask. Additionally, resulting system may overly sensitive
features support set features rarely impact reasoning, leading
unnecessary regeneration.
Fixed Hierarchical Justification requires less explicit consistency knowledge knowledgebased solutions. However, KBAC knowledge still required access whole task hierarchy possible. Thus, agents ability make subtask-specific reactions unexpected
changes environment limited knowledge designers ability anticipate
explicitly encode consequences changes.
5.2 Intention Reconsideration
belief-desire-intention (BDI) model agency, intention represents commitment
achieving goal (Rao & Georgeff, 1991; Wooldridge, 2000). intention thus similar
instantiation subtask hierarchical architecture.
Dynamic Hierarchical Justification viewed partial implementation intention reconsideration (Schut & Wooldridge, 2000, 2001). Intention reconsideration
process determining agent abandon intentions (due goal achievement, recognition failure, recognition intention longer desired).
Dynamic Hierarchical Justification partial implementation intention reconsideration able capture syntactic features problem solving (i.e.,
identification dependencies via support set) determine reconsider
intention. Situations require deliberation determine intention
abandoned captured DHJ.10 Schut & Wooldridge (2001) describe initial attempt allow run-time determination reconsideration policies. optimal policy
would maximize likelihood deliberate intention reconsideration actually leads
abandoning intention (i.e., agent reconsiders reconsideration necessary).
contrast, Dynamic Hierarchical Justification offers low-cost, always available, domain general process abandoning intentions, cannot automatically identify reconsiderations
requiring semantic analysis problem state.
BDI models, agents choose execute current action plans without
reconsidering current intentions first. Kinny Georgeff (1991) showed that,
static domains, bold agents never reconsider intentions perform effectively
cautious agents always reconsider executing plan step. opposite
true highly dynamic domains: cautious agents perform bold ones. Soar
PRS described cautious via Fixed Hierarchical Justification. is,
plan step, architectures determine elements support set remain asserted
executing step. FHJ approaches are, effect, bold appear,
reconsider intentions assertions changed dependent
context, support set. Dynamic Hierarchical Justification provides
cautious agents, ensures agents reconsideration function takes
account context dependencies subtask reasoning. perspective intention
10. DHJ preclude deliberate reconsideration. However, Soar (as testbed exploration
DHJ) provide architectural solution deliberate reconsideration. Thus, situations
addressed knowledge deliberative processes architecture.

388

fiEnsuring Consistency Hierarchical Execution

reconsideration, problems introduced dynamic domains prompted us explore
cautious solutions.
results empirical analysis somewhat consistent Kinny &
Georgeff. cautious DHJ agents performed better less cautious FHJ agents
highly dynamic TacAir-Soar domain. Dynamic Blocks World, performance
differences equivocal. comparison FHJ number new intentions
increased Dynamic Hierarchical Justification (measured Soar decisions).
slight overall performance improvement DHJ, due improvements
match time productions, Soar-specific measure likely generalize
systems. results suggest DHJ possibly overly cautious static
domains. However, Dynamic Hierarchical Justification present significant
performance cost unexpectedly played constructive role agent execution even
static domain, DHJ seems warranted static dynamic domains.
5.3 Belief Revision
Belief Revision refers process changing beliefs accommodate newly acquired
information. inconsistency problem example need revision asserted
beliefs: change hierarchical context (deriving ultimately perceived changes
world) leads situation currently asserted assumption would (necessarily) regenerated re-derived. Theories belief revision identify functions
used update belief set remains consistent.
best known theory belief revision AGM theory (Alchourron, Gardenfors,
& Makinson, 1985; Gardenfors, 1988, 1992). AGM coherence theory, meaning
changes beliefs determined based mutual coherence one another. approach contrasts foundations approach, justifications (reasons) determine
when/how revise belief set. Obviously, Dynamic Hierarchical Justification extension foundations approach belief revision. However, foundations
coherence approaches reconciled (Doyle, 1994), section explore repercussions Dynamic Hierarchical Justification context AGM theory belief
revision.
AGM theory, new sentence presented database sentences representing
current knowledge state, agent faced task revising knowledge base
via one three processes: expansion (adding sentences knowledge base), contraction
(removing sentences knowledge base) revision (a combination expansions
contractions). AGM theory emphasizes making minimal changes knowledge base
epistemic entrenchment, notion usefulness sentence within database.
AGM theory prefers sentences high epistemic entrenchment (relative
sentences) retained revision.
Comparing Dynamic Hierarchical Justification Assumption Justification suggests
sometimes cheaper remove subtask (and asserted beliefs associated
subtask) compute minimal revision Assumption Justification.
context belief revision, result surprising, since shown
computing minimal revision knowledge base computationally harder
deduction (Eiter & Gottlob, 1992). theoretical result led applications
389

fiWray & Laird

compute belief updates via incremental derivations belief state, rather via belief
revision (Kurien & Nayak, 2000).
power heuristic approach used DHJ analytic solution follows
characteristics outlined Section 3.4.1: hierarchical structure organization
agent assertions efficiency underlying reasoning system regenerate
unnecessarily removed assertions. Assumptions (persistent beliefs) associated particular subtasks hierarchical architectures. change perception (an epistemic input)
leads revision. Rather determining minimal revision, DHJ uses heuristic
that, context, says persistent beliefs subtask similar epistemic entrenchment subtask/intention itself. cases, heuristic incorrect,
leading regeneration, but, correct, provides much simpler mechanism revision. Gardenfors (1988) anticipates conclusions, suggesting systems possessing
additional internal structure (as compared relatively unstructured belief sets
AGM theory) may provide additional constraints orderings epistemic entrenchment.

6. Conclusion
empirical results Dynamic Blocks World TAS domains consistent expectations: knowledge engineering cost decreased overall performance
DHJ roughly (or slightly improved) comparison independently-developed
FHJ benchmarks. Development cost decreases designer freed task
creating across-level consistency knowledge. One drawback DHJ responsiveness
degrade regeneration occurs.
DHJ incorporated currently released version Soar (Soar 8)
3 years experience users confirms development cost decreases.
partly true developers need deeper understanding architecture realize
benefit. However, DHJ removes need encoding across-level consistency
knowledge, proven difficult understand encode many systems. DHJ
makes understanding role assumptions Soar systems straightforward, imposing design development constraints. instance, knowledge designer must
think why, when, persistence used agent. knowledge designer determines functional role persistent assumption, DHJ guides
development knowledge necessary assumption. nonmonotonic hypothetical assumption, knowledge must created looks outside subtask
order ensure consistency (i.e., across-level knowledge necessary). Assumptions
remembering must asserted root level hierarchy, knowledge must
created manage remembered assumption. Functions root task include
monitoring, updating, removing remembered assumptions (we developing domaingeneral methods managing remembered assumptions reduce cost). Thus,
DHJ increase complexity architecture, makes design decisions
explicit manageable previous KBAC approaches.
Regeneration, seemingly one drawbacks DHJ, contributes decreased
knowledge development costs. Regeneration serves debugging tool, allowing immediate
localization problem areas domain knowledge (and specific decomposition).
debugging aid contrasts previous knowledge development inconsistency
390

fiEnsuring Consistency Hierarchical Execution

often became evident irrational behavior, making often difficult determine
actual source problem. Thus, addition reducing total knowledge necessary
task, Dynamic Hierarchical Justification might reduce cost per knowledge
unit creating agent knowledge localizing problems via regeneration. However,
case domain cannot decomposed nearly decomposable subunits,
regeneration could debilitating.
Another positive consequence DHJ agent may behave robustly novel
situations anticipated knowledge engineer. example, simple experiment,
FHJ DHJ Dynamic Blocks World agents placed situation described
Figure 3. FHJ agent fails block moves lacks knowledge recognize
moving blocks; knowledge designer assumed static domain. knowledge,
however, DHJ agent responds situation gracefully. specific situation
Figure 3, DHJ agent immediately retracts put-on-table(3) subtask,
block-3 table, thus selection subtask longer consistent
current situation. agent chooses stack(2,3) decomposes subtask
actions put block-2 block-3. new block (e.g., block-4) placed
empty space block-2, architecture responds retracting subtask goal
put-down(2) (i.e., subtask contains empty assumption). begins search
empty spaces order continue attempt put block-2 table.
architecture, rather agent knowledge, ensures consistency across hierarchy, DHJ
agents less brittle situations explicitly anticipated agent design.
DHJ provides solution problem learning rules non-contemporaneous
constraints (Wray, Laird, & Jones, 1996). Non-contemporaneous constraints arise
temporally distinct assertions (e.g., red light, green light) collected single learned
rule via knowledge compilation. rule non-contemporaneous constraints lead
inappropriate behavior rather never apply. problem makes difficult
use straightforward explanation-based learning approaches operationalize agent execution
knowledge. Non-contemporaneous constraints arise architecture creates persistent
assumptions become inconsistent hierarchical context (Wray et al., 1996).
DHJ never allows inconsistency, solves non-contemporaneous problem.
instance, agents Dynamic Blocks World TAS able learn
unproblematically new architecture, no/little knowledge re-design. Wray (1998)
provides additional details empirical assessment learning.
Dynamic Hierarchical Justification operates higher level granularity Assumption Justification knowledge-based solution methods, trading fine-grained consistency lower computational cost. higher level abstraction introduce additional cost execution. particular, necessary regeneration led redundancy
knowledge search Dynamic Blocks World TAS agents. Although overall efficiency improved, improvement due improvements average
match cost productions, cannot guaranteed domains architectures. Further, Dynamic Hierarchical Justification requires complex subtasks
split distinct subtasks. requirement improves knowledge decomposition
reduces regeneration performance reduce responsiveness. However,
straightforward compilation reasoning subtasks DHJ enables, reduction
responsiveness overcome learning (Wray, 1998).
391

fiWray & Laird

Although implementation evaluation DHJ limited Soar, attempted
reduce specificity results Soar two ways. First, identified problems across-level consistency knowledge introduces knowledge-based approaches:
expensive develop, degrades modularity simplicity hierarchical representation, robust knowledge designers imagination. agents
developed sufficiently complex domains, expense creating knowledge grow
prohibitive. cost may lead additional researchers consider architectural assurances
consistency. Second, Dynamic Hierarchical Justification gains power via structure
hierarchically decomposed tasks. Although specific implementations may differ
agent architectures, heuristic simplifications employed DHJ transfer
architecture utilizing hierarchical organization memory task decomposition. Dynamic Hierarchical Justification efficient, architectural solution ensures reasoning
consistency across hierarchy agents employing hierarchical task decompositions.
solution allows agents act reliably complex, dynamic environments
fully realizing low cost agent development via hierarchical task decomposition.

Acknowledgments
work would possible without contributed directly
development evaluation Dynamic Hierarchical Justification. Scott Huffman, John
Laird Mark Portelli implemented Assumption Justification Soar. Ron Chong implemented precursor DHJ. Randy Jones, John Laird, Frank Koss developed TacAirSoar. Sayan Bhattacharyya, Randy Jones, Doug Pearson, Peter Wiemer-Hastings,
members Soar group University Michigan contributed development Dynamic Blocks World simulator. anonymous reviewers provided valuable,
constructive comments earlier versions manuscript. work supported
part University Michigan Rackham Graduate School Pre-doctoral fellowship, contract N00014-92-K-2015 Advanced Systems Technology Office DARPA
NRL, contract N6600I-95-C-6013 Advanced Systems Technology Office
DARPA Naval Command Ocean Surveillance Center, RDT&E division. Portions work presented 15 th National Conference Artificial Intelligence
Madison, Wisconsin.

Appendix A: Improving Task Decompositions
appendix describes detail changes made TAS agent knowledge
DHJ.
Remembering: Figure 4 showed agent computing new heading subtask
achieve-proximity subtask. calculation usually depends upon current heading.
agent generates command turn, heading changes soon thereafter.
situation, DHJ agent must remember already made decision turn
new heading placing assumption reflects new heading top level.
places assumption local level, new current heading trigger
removal turn-to-heading regeneration subtask (if agent determines
still needs turn new heading).
392

fiEnsuring Consistency Hierarchical Execution

FHJ agents, output commands (such turn specific heading)
asserted assumptions local subtask. DHJ agents knowledge changed
issue output commands directly output interface (which, Soar, always part
highest subtask hierarchy). unnecessary regeneration occurs
agent remembers motor commands generates new one different
output necessary. change, course, requires consistency knowledge
motor commands unjustified thus must explicitly removed, true
remembered knowledge DHJ.
Within-level Consistency Knowledge: Dynamic Hierarchical Justification, solutions across-level consistency problem, still requires consistency knowledge within
individual subtask. knowledge FHJ agents used remove intermediate results execution subtask. clean knowledge allows agent
remove local assertions contributed terminating subtask thus avoid
(mis)use assertions later reasoning.
example, consider achieve-proximity subtask. subtask used
number different situations agent needs get closer another agent.
wing strays far lead, may invoke achieve-proximity get back
formation lead. lead uses achieve-proximity get close enough enemy
aircraft launch missile. subtask requires many local computations agent
reasons heading take get closer another aircraft. specific
computation depends information available aircraft.
wing pursuing lead, may know leads heading thus calculate collision
course maximize rate convergence. Sometimes agents heading
available. case, agent simply moves toward current location agent.
local computations stored local subtask. achieve-proximity
terminated FHJ agent, agent removes local structure. Removing structure
important interrupts entailment local structure (e.g., calculation
current collision course) guarantees agent decides achieve-proximity
different aircraft, supporting data structures properly initialized. knowledge
thus maintains consistency local subtask removing local structure
achieve-proximity subtask longer selected.
FHJ agent could recognize going remove subtask. termination
conditions FHJ agents acted signal within-level consistency knowledge.
knowledge removes local structure achieve-proximity summarized as:
achieve-proximity operator selected, initiation conditions longer hold,
remove local achieve-proximity data structure. Thus, FHJ agent uses
recognition inconsistency assertions trigger activation within-level
consistency knowledge.
subtasks initiating conditions longer supported DHJ agents,
selected subtask removed immediately. Thus, DHJ agent never opportunity
apply FHJ agents within-level consistency knowledge. failure utilize
knowledge led number problems, including regenerations expected.
solve problem, local subtask data structure created entailment
initiation conditions subtask itself. subtask initiation conditions
longer held, subtask selection local structure immediately removed
393

fiWray & Laird

architecture, requiring additional knowledge. Thus, change obviated need
within-level consistency knowledge. However, local data structure may need
regenerated subtask temporarily displaced. instance, FHJ within-level
consistency knowledge could determine conditions local structure
removed. DHJ solution lost flexibility.
Subtasks Complex Actions: FHJ agents execute number actions rapid
succession, regardless inconsistency local assertions. single subtask operator
initiated situation representing conditions apply first
action sequence, terminated last step sequence applied.
intermediate step invalidates initiation conditions, subtask still executes
actions.
Consider process launching missile. actual missile launch requires
push button, assuming previous steps selecting target
appropriate missile accomplished beforehand. pushing fire button,
pilot must fly straight level seconds missile rockets ignite launch
missile flight. missile cleared aircraft, agent supports
missile keeping radar contact target. FHJ agents, push-fire-button
subtask includes act pushing fire button counting missile clears
aircraft. tasks different mutually exclusive dependencies. initiation
condition push-fire-button requires missile already launched. However,
subsequent counting requires monitoring newly launched missile.
DHJ agents using FHJ knowledge base always remove push-fire-button subtask soon missile perceived air, interrupting complete procedure.
Regeneration push-fire-button subtask occurs agent never waits
missile clear thus never realizes missile launched needs supported.
DHJ agent unsuccessfully fires available missiles enemy plane.
Pushing fire button waiting missile clear independent tasks
happen arise serial order domain. enforced independence
creating new subtask, wait-for-missile-to-clear, depends
newly launched missile air. DHJ agent pushes fire button, selects
wait-for-missile-to-clear count seconds taking action,
supports missile clears successfully.
solution reduces regeneration improves behavior quality
non-trivial cost. Whenever subtask split, effects subtask actions longer occur
rapid succession within decision. Instead, effect first subtask occurs one
decision, effect second subtask second decision, etc. Thus, solution
compromise responsiveness.

References
Agre, P. E., & Horswill, I. (1997). Lifeworld analysis. Journal Artificial Intelligence
Research, 6, 111145.
Alchourron, C. E., Gardenfors, P., & Makinson, D. (1985). logic theory change:
Partial meet contraction revision functions. Journal Symbolic Logic, 50 (2),
510530.
394

fiEnsuring Consistency Hierarchical Execution

Allen, J. F. (1991). Time time again. International Journal Intelligent Systems,
6 (4), 341355.
Altmann, E. M., & Gray, W. D. (2002). Forgetting remember: functional relationship
decay interference. Psychological Science, 13, 2733.
Bresina, J., Drummond, M., & Kedar, S. (1993). Reactive, integrated systems pose new
problems machine learning. Minton, S. (Ed.), Machine Learning Methods
Planning, pp. 159195. Morgan Kaufmann, San Francisco, CA.
Dechter, R. (1990). Enhancement schemes constraint processing: Backjumping, learning
cutset decomposition. Artificial Intelligence, 41, 273312.
Doyle, J. (1979). truth maintenance system. Artificial Intelligence, 12, 231272.
Doyle, J. (1994). Reason maintenance belief revision. Gardenfors, P. (Ed.), Belief
Revision, pp. 2951. Cambridge University Press, Cambridge, UK.
Eiter, T., & Gottlob, G. (1992). complexity propositional knowledge base revision,
updates, counterfactuals. Artificial Intelligence, 57, 227270.
Erol, K., Hendler, J., & Nau, D. S. (1994). HTN planning: Complexity expressivity.
Proceedings 12th National Conference Artificial Intelligence, pp. 11231128.
Firby, R. J. (1987). investigation reactive planning complex domains. Proceedings 6th National Conference Artificial Intelligence, pp. 202206.
Forbus, K. D., & deKleer, J. (1993). Building Problem Solvers. MIT Press, Cambridge,
MA.
Forgy, C. L. (1979). Efficient Implementation Production Systems. Ph.D. thesis,
Computer Science Department, Carnegie-Mellon University.
Gardenfors, P. (1988). Knowledge Flux: Modeling Dynamics Epistemic States.
MIT Press, Cambridge, MA.
Gardenfors, P. (1992). Belief revision. Pettorossi, A. (Ed.), Meta-Programming Logic.
Springer-Verlag, Berlin, Germany.
Gaschnig, J. (1979). Performance measurement analysis certain search algorithms.
Tech. rep. CMU-CS-79-124, Computer Science Department, Carnegie-Mellon University, Pittsburgh, Pennsylvania.
Gat, E. (1991a). Integrating planning reacting heterogeneous asynchronous architecture mobile robots. SIGART BULLETIN, 2, 7174.
Gat, E. (1991b). Reliable, Goal-directed Control Autonomous Mobile Robots. Ph.D.
thesis, Virginia Polytechnic Institute State University, Blacksburg, VA.
Georgeff, M., & Lansky, A. L. (1987). Reactive reasoning planning. Proceedings
6th National Conference Artificial Intelligence, pp. 677682.
Graham, J., & Decker, K. (2000). Towards distributed, environment-centered agent framework. Wooldridge, M., & Lesperance, Y. (Eds.), Lecture Notes Artificial Intelligence: Agent Theories, Architectures, Languages VI (ATAL-99). Springer-Verlag,
Berlin.
395

fiWray & Laird

Hanks, S., Pollack, M., & Cohen, P. R. (1993). Benchmarks, test beds, controlled experimentation design agent architectures. AI Magazine, 14, 1742.
Hayes-Roth, B. (1990). architecture adaptive intelligent systems. Workshop
Innovative Approaches Planning, Scheduling Control, pp. 422432.
Jones, R. M., Laird, J. E., Neilsen, P. E., Coulter, K. J., Kenny, P., & Koss, F. V. (1999).
Automated intelligent pilots combat flight simulation. AI Magazine, 20 (1), 2741.
Kinny, D., & Georgeff, M. (1991). Commitment effectiveness situated agents.
Proceedings 12th International Joint Conference Artificial Intelligence, pp.
8288.
Kurien, J., & Nayak, P. P. (2000). Back future consistency-based trajectory
tracking. Proceedings 17th National Conference Artificial Intelligence,
pp. 370377.
Laird, J. E. (2001). knows going do: Adding anticipation Quakebot.
Proceedings 5th International Conference Autonomous Agents, pp. 385
392.
Laird, J. E., Congdon, C. B., & Coulter, K. J. (1999). Soar users manual version 8.2.
Manual, Department Electrical Engineering Computer Science, University
Michigan, http://ai.eecs.umiuch.edu/soar/docs.html.
Laird, J. E., Newell, A., & Rosenbloom, P. S. (1987). Soar: architecture general
intelligence. Artificial Intelligence, 33, 164.
Laird, J. E., & Rosenbloom, P. S. (1990). Integrating execution, planning, learning
Soar external environments. Proceedings 8 th National Conference
Artificial Intelligence, pp. 10221029.
Laird, J. E., & Rosenbloom, P. S. (1995). evolution Soar cognitive architecture.
Steier, D., & Mitchell, T. (Eds.), Mind Matters: Contributions Cognitive
Computer Science Honor Allen Newell. Lawrence Erlbaum Associates, Hillsdale,
NJ.
McDermott, D. (1991). general framework reason maintenance. Artificial Intelligence,
50, 289329.
Mitchell, T. M., Allen, J., Chalasani, P., Cheng, J., Etzioni, O., Ringuette, M., & Schlimmer,
J. C. (1991). Theo: framework self-improving systems. VanLehn, K. (Ed.),
Architectures Intelligence, chap. 12, pp. 323355. Lawrence Erlbaum Associates,
Hillsdale, NJ.
Mitchell, T. M. (1990). Becoming increasingly reactive. Proceedings 8 th National
Conference Artificial Intelligence, pp. 10511058.
Nebel, B., & Koehler, J. (1995). Plan reuse versus plan generation: theoretical
empirical analysis. Artificial Intelligence, 76, 427454.
Newell, A. (1990). Unified Theories Cognition. Harvard University Press, Cambridge,
MA.
396

fiEnsuring Consistency Hierarchical Execution

Paolucci, M., Shehory, O., Sycara, K. P., Kalp, D., & Pannu, A. (1999). planning component RETSINA agents. Wooldridge, M., & Lesperance, Y. (Eds.), Lecture Notes
Artificial Intelligence: Agent Theories, Architectures, Languages VI (ATAL99), pp. 147161, Berlin. Springer-Verlag.
Pearson, D. J., Huffman, S. B., Willis, M. B., Laird, J. E., & Jones, R. M. (1993).
symbolic solution intelligent real-time control. Robotics Autonomous Systems,
11, 279291.
Rao, A. S., & Georgeff, M. P. (1991). Modeling rational agents within BDI-architecture.
Proceedings 2nd International Conference Principles Knowledge Representation Reasoning, pp. 471484.
Russell, S., & Norvig, P. (1995). Artificial Intelligence: Modern Approach. Prentice Hall,
Upper Saddle River, NJ.
Sacerdoti, E. D. (1975). nonlinear nature plans. Proceedings 4 th International Joint Conference Artificial Intelligence, pp. 206214.
Schut, M., & Wooldridge, M. (2000). Intention reconsideration complex environments.
Proceedings 4th International Conference Autonomous Agents, pp. 209216.
Schut, M., & Wooldridge, M. (2001). Principles intention reconsideration. Proceedings
5th International Conference Autonomous Agents, pp. 340347.
Shoham, Y. (1993). Agent-oriented programming. Artificial Intelligence, 60 (1), 5192.
Simon, H. A. (1969). Sciences Artificial. MIT Press, Cambridge, MA.
Stallman, R. M., & Sussman, G. J. (1977). Forward reasoning dependency-directed
backtracking system computer aided circuit analysis. Artificial Intelligence,
9 (2), 135196.
Sycara, K., Decker, K., Pannu, A., Williamson, M., & Zeng, D. (1996). Distributed intelligent agents. IEEE Expert, 11 (6), 3646.
Tambe, M. (1991). Eliminating Combinatorics Production Match. Ph.D. thesis,
Carnegie-Mellon University. (Also published Technical Report CMU-CS-91-150,
Computer Science Department, Carnegie Mellon University.).
Tambe, M., Johnson, W. L., Jones, R. M., Koss, F., Laird, J. E., Rosenbloom, P. S., &
Schwamb, K. (1995). Intelligent agents interactive simulation environments. AI
Magazine, 16 (1), 1539.
Veloso, M. M., Pollack, M. E., & Cox, M. T. (1998). Rationale-based monitoring planning dynamic environments. Proceedings 4 th International Conference
Artificial Intelligence Planning Systems, pp. 171180.
Wilkins, D. E., Myers, K. L., Lowrance, J. D., & Wesley, L. P. (1995). Planning reacting
uncertain dynamic environments. Journal Experimental Theoretical
Artificial Intelligence, 7 (1), 197227.
Wooldridge, M. (2000). Reasoning Rational Agents. MIT Press, Cambridge, MA.
Wray, R. E. (1998). Ensuring Reasoning Consistency Hierarchical Architectures. Ph.D.
thesis, University Michigan. published University Michigan Technical
Report CSE-TR-379-98.
397

fiWray & Laird

Wray, R. E., & Laird, J. (1998). Maintaining consistency hierarchical reasoning.
Proceedings 15th National Conference Artificial Intelligence, pp. 928935.
Wray, R. E., Laird, J., & Jones, R. M. (1996). Compilation non-contemporaneous constraints. Proceedings 13th National Conference Artificial Intelligence, pp.
771778.
Wray, R. E., Laird, J. E., Nuxoll, A., & Jones, R. M. (2002). Intelligent opponents virtual
reality trainers. Proceedings Interservice/Industry Training, Simulation
Education Conference (I/ITSEC) 2002.

398


