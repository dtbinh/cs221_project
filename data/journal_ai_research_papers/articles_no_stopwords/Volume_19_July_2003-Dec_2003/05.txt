Journal Artificial Intelligence Research 19 (2003) 631-657

Submitted 10/02; published 12/03

AltAltp : Online Parallelization Plans
Heuristic State Search
Romeo Sanchez Nigenda
Subbarao Kambhampati

rsanchez@asu.edu
rao@asu.edu

Department Computer Science Engineering,
Arizona State University, Tempe AZ 85287-5406

Abstract
Despite near dominance, heuristic state search planners still lag behind disjunctive
planners generation parallel plans classical planning. reason directly
searching parallel solutions state space planners would require planners branch
possible subsets parallel actions, thus increasing branching factor exponentially.
present variant heuristic state search planner AltAlt called AltAltp
generates parallel plans using greedy online parallelization partial plans. greedy
approach significantly informed use novel distance heuristics AltAltp
derives graphplan-style planning graph problem. approach
guaranteed provide optimal parallel plans, empirical results show AltAltp
capable generating good quality parallel plans fraction cost incurred
disjunctive planners.

1. Introduction
Heuristic state space search planning proved one efficient planning
frameworks solving large deterministic planning problems (Bonet, Loerincs, & Geffner,
1997; Bonet & Geffner, 1999; Bacchus, 2001). Despite near dominance, one achilles
heel remains generation parallel plans (Haslum & Geffner, 2000). Parallel plans allow
concurrent execution multiple actions time step. concurrency likely
important progress temporal domains. disjunctive planners
Graphplan (Blum & Furst, 1997) SATPLAN (Kautz & Selman, 1996) GPCSP (Do & Kambhampati, 2000) seem trouble generating parallel plans,
planners search space states overwhelmed task. main reason
straightforward methods generation parallel plans would involve progression
regression sets actions. increases branching factor search space
exponentially. Given n actions, branching factor simple progression regression
search bounded n, progression regression search parallel plans
bounded 2n .
inability state search planners producing parallel plans noted
literature previously. Past attempts overcome limitation successful. Indeed, Haslum Geffner (2000) consider problem generating parallel
plans using regression search space states. note resulting planner, HSP*p, scales significantly worse Graphplan. present TP4 (Haslum &
Geffner, 2001), addition aimed actions durations, improves
c
2003
AI Access Foundation. rights reserved.

fiSanchez & Kambhampati

branching scheme HSP*p, making incremental along lines Graphplan.
Empirical studies reported Haslum Geffner (2001), however indicate even
new approach, unfortunately, scales quite poorly compared Graphplan variants. Informally, achilles heel heuristic state search planners interpreted sort
last stand disjunctive planners capable generating parallel plans
efficiently.
Given way efficiently generating optimal parallel plans involves using
disjunctive planners, might want consider ways generating near-optimal parallel
plans using state search planners. One obvious approach post-process sequential
plans generated state search planners make parallel. easily
done - using approaches explored Backstrom (1998), one drawback
approaches limited transforming sequential plan given input.
Parallelization sequential plans often results plans close optimal parallel
plans.1
alternative, explore paper, involves incremental online parallelization.
Specifically, planner AltAltp , variant AltAlt planner (Sanchez, Nguyen,
& Kambhampati, 2000; Nguyen, Kambhampati, & Sanchez, 2002), starts search
space regression single actions. promising single action regress
selected, AltAltp attempts parallelize (fatten) selected search branch
independent actions. parallelization done greedy incremental fashion actions considered addition current search branch based heuristic cost
subgoals promise achieve. parallelization continues next step
state resulting addition new action better heuristic cost.
sub-optimality introduced greedy nature parallelization offset
extent plan-compression procedure called Pushup tries rearrange evolving
parallel plans pushing actions higher levels search branch (i.e. later stages
execution) plan.
Despite seeming simplicity approach, proven quite robust
practice. fact, experimental comparison five competing planners - STAN (Long
& Fox, 1999), LPG (Gerevini & Serina, 2002), Blackbox (Kautz & Selman, 1996), SAPA (Do
& Kambhampati, 2001) TP4 (Haslum & Geffner, 2001) - shows AltAltp viable
scalable alternative generating parallel plans several domains. many problems,
AltAltp able generate parallel plans close optimal makespan.
seems retain efficiency advantages heuristic state search disjunctive planners,
producing plans fraction time taken disjunctive planners many cases.
AltAltp found superior post-processing approaches. Specifically,
compared AltAltp approach involves post-processing sequential plans
generated AltAlt using techniques Backstrom (1998). found AltAltp
able generate shorter parallel plans many cases. Finally, show AltAltp incurs
little additional overhead compared AltAlt.
rest paper, discuss implementation evaluation approach
generate parallel plans AltAltp . Section 2 starts providing review
AltAlt planning system, AltAltp based. Section 3 describes generation
1. empirically demonstrate later; curious readers may refer plots Figure 15.

632

fiOnline Parallelization Plans Heuristic State Search

Action Templates

Serial Planning
Graph

Graphplan
Plan Extension Phase
(based STAN)

Problem Spec
(Init, Goal state)

Extraction
Heuristics

Actions
Last Level

AltAlt

Heuristics

Regression Planner
(based HSP-R)

Solution Plan

Figure 1: Architecture AltAlt
parallel plans AltAltp . Section 4 presents extensive empirical evaluation AltAltp .
evaluation includes comparison ablation studies. Finally, Section 5 discusses
related work classical well metric temporal planning. Section 6 summarizes
contributions.

2. AltAlt Background Architecture Heuristics
AltAlt planning system based combination Graphplan (Blum & Furst, 1997;
Long & Fox, 1999; Kautz & Selman, 1999) heuristic state space search (Bonet et al.,
1997; Bonet & Geffner, 1999; McDermott, 1999) technology. AltAlt extracts powerful
heuristics planning graph data structure guide regression search space
states. high level architecture AltAlt shown Figure 1. problem specification
action template description first fed Graphplan-style planner (in case,
STAN Long & Fox, 1999), constructs planning graph problem
polynomial time (we assume reader familiar Graphplan algorithm Blum
& Furst, 1997). planning graph structure fed heuristic extractor module
capable extracting variety effective heuristics (Nguyen & Kambhampati,
2000; Nguyen et al., 2002). heuristics, along problem specification,
set ground actions final action level planning graph structure fed
regression state-search planner.
explain operation AltAlt detailed level, need provide
background various components. shall start regression search
module. Regression search process searching space potential plan suffixes. suffixes generated starting goal state regressing
set relevant action instances domain. resulting states (nondeterministically) regressed relevant action instances, process repeated
reach state (set subgoals) satisfied initial state. state
framework set (conjunction of) literals seen subgoals need
made true way achieving top level goals. action instance considered
relevant state effects give least one element delete
633

fiSanchez & Kambhampati

element S. result regressing (S\ef f (a)) prec(a) -
essentially set goals still need achieved application a,
everything would achieved applied. relevant action
a, separate search branch generated, result regressing action
new fringe branch. Search terminates success node every literal
state corresponding node present initial state problem.
crux controlling regression search involves providing heuristic function
estimate relative goodness states fringe current search tree
guide search promising directions. heuristic function needs evaluate
cost achieving set subgoals (comprising regressed state) initial
state. words, heuristic computes length plan needed achieve
subgoals initial state. discuss heuristic computed
planning graph, which, provides optimistic reachability estimates.
Normally, planning graph data structure supports parallel plans - i.e., plans
step one action may executed simultaneously. Since want planning graph provide heuristics regression search module AltAlt, generates
sequential solutions, first make modification algorithm generates
serial planning graph. serial planning graph planning graph which, addition
normal mutex relations, every pair non-noop actions level marked
mutex. additional action mutexes propagate give additional propositional mutexes. Finally, planning graph said level change action,
proposition mutex lists two consecutive levels.
assume given problem, Graphplan module AltAlt used
generate expand serial planning graph levels off. discussed Sanchez
et al. (2000), relax requirement growing planning graph level-off,
tolerate graded loss informedness heuristics derived planning graph.
start notion level set propositions:
Definition 1 (Level) Given set propositions, lev(S) index first level
leveled serial planning graph propositions appear non-mutex
one another. singleton, lev(S) index first level
singleton element occurs. level exists, lev(S) = planning graph
grown level-off.
intuition behind definition level literal p serial planning
graph provides lower bound length plan (which, serial planning graph,
equal number actions plan) achieve p initial state. Using
insight, simple way estimating cost set subgoals sum levels.
Heuristic 1 (Sum heuristic) hsum (S) :=

P

pS

lev({p})

sum heuristic similar greedy regression heuristic used UNPOP (McDermott, 1999) heuristic used HSP planner (Bonet et al., 1997). main
limitation heuristic makes implicit assumption subgoals (elements
S) independent. hsum heuristic neither admissible particularly informed
ignores interactions subgoals. develop effective heuristics,
634

fiOnline Parallelization Plans Heuristic State Search

need consider positive negative interactions among subgoals limited
fashion.
(Nguyen et al., 2002), discuss variety ways using planning graph
incorporate negative positive interactions heuristic estimate, discuss
relative tradeoffs. One best heuristics according analysis heuristic called
hAdjSum2M . adopted heuristic default heuristic AltAlt. basic idea
hAdjSum2M adjust sum heuristic take positive negative interactions
account. heuristic approximates cost achieving subgoals set
sum cost achieving S, considering positive interactions ignoring negative
interactions, plus penalty ignoring negative interactions. first component
RP (S) computed length relaxed plan supporting S,
extracted ignoring mutex relations. approximate penalty induced
negative interactions alone, proceed following argument. Consider pair
subgoals p, q S. negative interactions p q, lev({p, q}),
level p q present together, exactly maximum lev(p) lev(q).
degree negative interaction p q thus quantified by:
(p, q) = lev({p, q}) max (lev(p), lev(q))
want use - values characterize amount negative interactions
present among subgoals given set S. subgoals pair-wise independent,
clearly, values zero, otherwise pair subgoals different
value. largest value among pair subgoals used measure
negative interactions present heuristic hAdjSum2M . summary,
Heuristic 2 (Adjusted 2M) hAdjSum2M (S) := length(RP (S)) + maxp,qS (p, q)
analysis Nguyen et al. (2002) shows one robust heuristics
terms solution time quality. thus default heuristic used AltAlt
(as well AltAltp ; see below).

3. Generation Parallel Plans Using AltAltp
obvious way make AltAlt produce parallel plans would involve regressing subsets
(non interfering) actions. Unfortunately, increases branching factor exponentially
infeasible practice. Instead, AltAltp uses greedy depth-first approach makes
use heuristics regress single actions, incrementally parallelizes partial plan
step, rearranging partial plan later necessary.
high level architecture AltAltp shown Figure 2. Notice heuristic
extraction phase AltAltp similar AltAlt, one important modification. contrast AltAlt uses serial planning graph basis
heuristic (see Section 2), AltAltp uses standard parallel planning graph. makes
sense given AltAltp interested parallel plans AltAlt aimed generating
sequential plans. regression state-search engine AltAltp different
search module AltAlt. AltAltp augments search engine AltAlt 1) fattening
step 2) plan compression procedure (Pushup). details procedures
discussed below.
635

fiSanchez & Kambhampati

Action Templates

Parallel
Planning
Graph

Graphplan
Plan Extension Phase
(based STAN)

Extraction
Heuristics

Actions
Last Level

AltAltp

Heuristics

Problem Spec
(Init, Goal state)

Node
Expansion
(Fattening)

Node Ordering
Selection

Plan
Compression
Algorithm
(PushUp)

Solution Plan

Figure 2: Architecture AltAltp



A={a 1 ,a 2 ,...,a p ,...a }

a1

a2

S1

S2

ap
. ..


Sp

Figure 3: AltAltp Notation

636

. ..

Sm

fiOnline Parallelization Plans Heuristic State Search

parexpand(S)
get set applicable actions current state
forall ai
Si Regress(S,ai )
CHILDREN(S) CHILDREN(S) + Si
Sp state among Children(S) minimum
hadjsum2M value
ap action regresses Sp
/**Fattening process
{ ap }
forall g ranked decreasing order level(g)
Find action ag supporting g ag 6
ai pairwise independent action O.
multiple actions, pick one
minimum hadjsum (Regress(S, + ag )) among ag
hadjsum2M (S, + ai ) < hadjsum2M (S, O)
+ ag
Spar Regress(S, O)
CHILDREN(S) CHILDREN(S) + Spar
return CHILDREN
END;
Figure 4: Node Expansion Procedure
general idea AltAltp select fringe action ap among actions
used regress particular state stage search (see Figure 3). Then,
pivot branch given action ap fattened adding actions A,
generating new state consequence regression multiple parallel actions.
candidate actions used fattening pivot branch must (a) come sibling
branches pivot branch (b) pairwise independent actions
currently pivot branch. use standard definition action independence: two
actions a1 a2 considered independent state resulting regressing
actions simultaneously obtained applying a1 a2 sequentially
possible linearizations. sufficient condition preconditions
effects actions interfere:
((|prec(a1 )| |ef f (a1 )|) (|prec(a2 )| |ef f (a2 )|)) =
|L| refers non-negated versions literals set L. discuss
details pivot branch selected first place, branch
incrementally fattened.
Selecting Pivot Branch: Figure 4 shows procedure used select parallelize
pivot branch. procedure first identifies set regressable actions
current node S, regresses them, computing new children states. Next,
action leading child state lowest heuristic cost among new children
selected pivot action ap , corresponding branch becomes pivot branch.
637

fiSanchez & Kambhampati


At(pack1,ASU)
At(pack2,ASU)
At(pack3,ASU)
At(pack4, Home)

H=23
am: Unload(pack4,airp2,Home)

ap: Unload(pack1,airp1,ASU)

a1: Unload(pack1,airp2,ASU)

Sp
H=21
Pivot
Unload(pack2,airp1,ASU)
Unload(pack2,airp2,ASU)
Unload(pack3,airp1,ASU)
Unload(pack3,airp2,ASU)
Unload(pack4,airp2,HOME)

S1
H=21

...

Sm
H=22

Possible Pairwise
Independent Actions

Figure 5: regression state, identify P ivot related set
pairwise independent actions.

heuristic cost states computed hadjsum2M heuristic AltAlt,
based parallel planning graph. Specifically, context discussion
hadjsum2M heuristic end Section 2, compute (p, q) values, turn
depend level(p), level(q) level(p, q) terms levels parallel planning
graph rather serial planning graph. easy show level set
conditions parallel planning graph less equal level serial
planning graph. length relaxed plan still computed terms number
actions. show later (see Figure 19(a)) change improve quality
parallel plans produced AltAltp .
search algorithm used AltAltp similar used HSPr (Bonet & Geffner,
1999) - hybrid greedy depth first weighted A* search. goes depthfirst long heuristic cost children states lower
current state. Otherwise, algorithm resorts weighted A* search select next
node expand. latter case, evaluation function used rank nodes
f (S) = g(S) + w h(S) g(S) length current partial plan terms
number steps, h(S) estimated cost given heuristic function (e.g. hAdjSum2M ),
w weight given heuristic function. w set 5 based empirical
experience.2
Breaking Ties: case tie selecting pivot branch, i.e., one branch
leads state lowest heuristic cost, break tie choosing action
2. role w Best-First search see (Korf, 1993).

638

fiOnline Parallelization Plans Heuristic State Search

supports subgoals harder achieve. Here, hardness literal l measured
terms level planning graph l first appears. standard rationale
decision (c.f. Kambhampati & Sanchez, 2000) want fail faster
considering difficult subgoals first. additional justification case,
know subgoal higher level value requires steps actions
achievement appeared later planning graph. So, supporting
first, may able achieve easier subgoals along way thereby reduce
number parallel steps partial plan.
Fattening Pivot Branch: Next procedure needs decide subset
sibling actions pivot action ap used fatten pivot branch.
obvious first idea would fatten pivot branch maximally adding pairwise
independent actions found search stage. problem idea
may add redundant heuristically inferior actions branch, satisfying
preconditions may lead increase number parallel steps.
So, order avoid fattening pivot branch irrelevant actions,
adding action O, require heuristic cost state results
regressing + strictly lower S. addition
requirement pairwise independent current set actions O.
simple check ensures add one action supporting
set subgoals S.
overall procedure fattening pivot branch thus involves picking next
hardest subgoal g (with hardness measured terms level subgoal
planning graph), finding action ag achieving g, pair-wise independent
actions which, added used regress S, leads state
lowest heuristic cost, consequence lower cost S.
found, ag added O, procedure repeated. one
action ag , break ties considering degree overlap
preconditions action ag set actions currently O. degree precondition
overlap defined |prec(a) {oO prec(o)}|. action higher
degree overlap preferred reduce amount additional work need
establish preconditions. Notice fattening process, search
node may multiple actions leading parent, multiple actions leading
children.
Example: Figure 5 illustrates use node expansion procedure problem
logistics domain (Bacchus, 2001). example four packages pack1,
pack2, pack3 pack4. goal place first three ASU
remaining one home. two planes airp1 airp2 carry plans.
figure shows first level search regressed. shows pivot
action ap given unload(pack1,airp1,ASU), candidate set pairwise independent
actions respect ap . Finally, see Figure 6 generation parallel
branch. Notice node seen partial regressed plan. described
paragraphs above, actions regressing lower heuristic estimates considered apar
fatten pivot branch. Notice action unload(pack4,airp2,Home)
discarded leads state higher cost, even though inconsistent
639

fiSanchez & Kambhampati


At(pack1,ASU)
At(pack2,ASU)
At(pack3,ASU)
At(pack4, Home)
apar: Unload(pack1,airp1,ASU)
Unload(pack2,airp1,ASU)
Unload(pack3,airp1,ASU)

H=23
am: Unload(pack4,airp2,Home)

a1: Unload(pack1,airp2,ASU)
ap: Unload(pack1,airp1,ASU)

Spar
H=19

Sp

S1
H=21

H=21
Pivot

...

Sm
H=22


Unload(pack1,airp1,ASU)
Unload(pack2,airp1,ASU)
Unload(pack2,airp2,ASU)
Unload(pack3,airp1,ASU)
Unload(pack3,airp2,ASU)
Unload(pack4,airp2,HOME)

Figure 6: Spar result incrementally fattening P ivot branch pairwise
independent actions

rest actions chosen fatten pivot branch. Furthermore,
see preferred actions using plane airp1, since overlap
pivot action ap .
Offsetting Greediness Fattening: fattening procedure greedy, since
insists state resulting fattening strictly better heuristic value.
useful avoiding addition irrelevant actions plan, procedure
sometimes preclude actions ultimately relevant discarded
heuristic perfect. actions may become part plan later stages
search (i.e., earlier parts execution eventual solution plan; since
searching space plan suffixes). happens, length parallel plan
likely greater, since steps may needed support preconditions
actions would forced come even later stages search (earlier parts
plan). action allowed partial plan earlier search (i.e., closer
end eventual solution plan), preconditions could probably achieved
parallel subgoals plan, thus improving number steps.
order offset negative effect greediness, AltAltp re-arranges partial plan
promote actions higher search branch (i.e., later parts execution
eventual solution plan). Specifically, expanding given node S, AltAltp checks
see actions leading parent node (i.e., Figure 6 shows
Apar leads Spar ) pushed higher levels search branch. online
640

fiOnline Parallelization Plans Heuristic State Search

pushUP(S)
get actions leading
forall
x0
Sx get parent node
/** Getting highest ancestor action
Loop
Ax get actions leading Sx
(parallel(a, Ax ))
x x+1
Sx get parent node Sx1
Else
aj get action conflicting Ax
(Secondary Optimizations)
Remove aj branch
Include anew necessary
Else
Ax1 Ax1 +

break
End Loop
/**Adjusting partial plan
Sx get highest ancestor x history
createN ewBranchF rom(Sx )
x > 0
Snew regress Sx Ax1
Sx Snew
x x1
END;

Figure 7: Pushup Procedure

re-arrangement plan done Pushup procedure, shown Figure 7.
Pushup procedure called time node gets expanded, try
compress partial plan. actions find highest ancestor node
Sx search branch action applied (i.e., gives literal
Sx without deleting literals Sx , pairwise independent actions
Ax currently leading Sx , words condition parallel(a, Ax ) satisfied).
Sx found, removed set actions leading introduced
set actions leading Sx (to child current search branch). Next,
states search branch Sx adjusted reflect change. adjustment
involves recomputing regressions search nodes Sx . first glance,
might seem transformation questionable utility since preconditions (and
regressions) become part descendants Sx , necessarily
reduce length plan. however expect length reduction actions
supporting preconditions get pushed eventually later expansions.
641

fiSanchez & Kambhampati


At(pack1,ASU)
At(pack2,ASU)
At(pack3,ASU)
At(pack4, Home)
Unload(pack1,airp1,ASU)
Unload(pack2,airp1,ASU)
Unload(pack3,airp1,ASU)

H=23
Unload(pack4,airp2,Home)

Unload(pack1,airp2,ASU)
Unload(pack1,airp1,ASU)

Spar

Sp

H=19

...

S1

H=21

H=21

Sm
H=22

Unload(pack4,airp2,Home)
fly(airp1,LocX,ASU)
Spar

Sp

...

Sm

H=18
Pivot

Unload(pack4,airp2,Home)
fly(airp1,LocX,ASU)

H=18

H=16

(a) Finding highest ancestor node action
pushed up.


Unload(pack1,airp1,ASU)
Unload(pack2,airp1,ASU)
Unload(pack3,airp1,ASU)
Unload(pack4,airp2,HOME)

At(pack1,ASU)
At(pack2,ASU)
At(pack3,ASU)
At(pack4, Home)

H=23
Unload(pack4,airp2,Home)

Unload(pack1,airp1,ASU)
Unload(pack2,airp1,ASU)
Unload(pack3,airp1,ASU)

Unload(pack1,airp2,ASU)

Unload(pack1,airp1,ASU)
Spar

Snew

Sp

H=19

S1

H=21

Sm

H=21

fly(airp1,LocX,ASU)

fly(airp1,LocX,ASU)

...

Snew

Spar

Sp

H=16

fly(airp1,LocX,ASU)
Unload(pack4,airp2,Home)

H=18
Pivot

H=22

Unload(pack4,airp2,Home)

...

Sm
H=18

H=16

(b) Pushup procedure generates new search branch.

Figure 8: Rearranging Partial Plan
642

fiOnline Parallelization Plans Heuristic State Search

Rather doctor existing branch, current implementation, add
new branch Sx reflects changes made Pushup procedure.3 new
branch becomes active search branch, leaf node expanded next.
Aggressive Variation Pushup: Pushup procedure, described above,
expensive affects current search branch, operations involved
recomputing regressions branch. course, possible aggressive
manipulating search branch. example, applying action ancestor
Sx set literals child state, say Snew changes, thus additional actions may
become relevant expanding Snew . principle, could re-expand Snew light
new information. decided go re-expansion option, typically
seem worth cost. Section 4.3, compare default version Pushup
procedure variant re-expands nodes search branch, results
studies support decision avoid re-expansion. Finally, although introduced
Pushup procedure add-on fattening step, used independent
latter, case net effect would incremental parallelization sequential
plan.
Example: Figure 8(a), two actions leading node Spar (at depth two),
two actions Unload(pack4,airp2,Home) fly(airp1,LocX,ASU). So,
expanding Spar check two actions leading pushed up.
second action pushable since interacts actions ancestor node, first
one is. find highest ancestor partial plan interacts pushable
action. example root node ancestor. So, insert pushable
action Unload(pack4,airp2,Home) directly root node. re-adjust
state Spar Snew depth 1, shown Figure 8(b), adding new branch, reflecting
changes states below. Notice action Unload(pack4,airp2,Home)
initially discarded greediness fattening procedure (see Figure 6),
offset negative effect plan compression algorithm. see
re-expanded state Snew depth 1, made adjustments
partial plan using actions already presented search trace.4

4. Evaluating Performance AltAltp
implemented AltAltp top AltAlt. tested implementation suite
problems used 2000 2002 AIPS competition (Bacchus, 2001; Long
& Fox, 2002), well benchmark problems (McDermott, 2000). experiments
broadly divided three sets, aimed comparing performance AltAltp
different scenarios:
1. Comparing performance AltAltp planning systems capable producing
parallel plans.
3. way data structures set up, adding new branch turns robust
option manipulating existing search branch.
4. Instead, aggressive Pushup modification would expand Snew depth 1, generating similar states
generated expansion Spar depth.

643

fiSanchez & Kambhampati

80

70

60

35

Gripper AIPS-98

AltAlt-p
STAN
TP4
Blackbox
LPG 2nd

Elevator AIPS-00
AltAlt-p
STAN

30

Blackbox
LPG 2nd

25

50

Steps

20

Steps

40

15

30
10

20

5

10

0

0
1

2

3

4

5

Problems

6

7

1

8

3

5

7

9

11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49

Problems

(b)

(a)

Figure 9: Performance Gripper (AIPS-98) Elevator (AIPS-00) Domains.
12

1400

AltAlt-p
STAN
Blackbox

10

1200

1000

Steps

8

Time

800

6

600

4
400

2
200

0

0

1

4

7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70

1

Problems

4

7

10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70

Problems

(b)

(a)

Figure 10: Performance Schedule domain (AIPS-00)
2. Comparing incremental parallelization technique AltAlt + Post-Processing.
3. Ablation studies analyze effect different parts AltAltp approach
overall performance.
experiments done Sun Blade-100 workstation, running SunOS 5.8
1GB RAM. Unless noted otherwise, AltAltp run hadjsum2M heuristic
644

fiOnline Parallelization Plans Heuristic State Search

90

450

Altalt-p
STAN
TP4
Blackbox
LPG 2nd

80

70

350
300

50

Time

Steps

60

400

250

40

200

30

150

20

100
50

10

0

0
1

3

5

7

1

9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61

4

7

10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61

Problems

Problems

(a)

(b)

Figure 11: Performance Logistics domain(AIPS-00)

35

800

AltAlt-p
STAN
TP4
Blackbox
LPG 2nd
Sapa

30

25

700

600

400

Time

Steps

500

20

15

300

10
200

5
100

0
1

2

3

4

5

6

7

8

9

10

11

12

13

14

0

15

1

Problems

2

3

4

(a)

5

6

7

8

9

Problems

10

11

12

13

14

15

(b)

Figure 12: Performance DriverLog domain(AIPS-02)
described section 2 paper, parallel planning graph grown first
level top-level goals present without mutex. times seconds.
4.1 Comparing AltAltp Competing Approaches
first set experiments compared performance planner
results obtained running STAN (Long & Fox, 1999), Blackbox (Kautz & Selman,
645

fiSanchez & Kambhampati

1999), TP4 (Haslum & Geffner, 2001), LPG (Gerevini & Serina, 2002) SAPA (Do &
Kambhampati, 2001). Unless noted otherwise, every planner run default
settings. planners could run domains due parsing problems
memory allocation errors. cases, omit planner consideration
particular domains.
4.1.1 Planners Used Comparison Studies
STAN disjunctive planner, optimized version Graphplan algorithm
reasons invariants symmetries reduce size search space. Blackbox
based Graphplan algorithm works converting planning problems
specified STRIPS (Fikes & Nilsson, 1971) notation boolean satisfiability problems
solving using SAT solver (the version used defaults SATZ).5 LPG (Gerevini
& Serina, 2002) judged best performing planner 3rd International Planning
Competition (Long & Fox, 2002), planner based planning graphs local
search inspired Walksat approach. LPG run default heuristics
settings. Since LPG employs iterative improvement algorithm, quality plans
produced improved running multiple iterations (thus increasing
running time). make comparisons meaningful, decided run LPG two
iterations (n=2), since beyond that, running time LPG generally worse
AltAltp . Finally, chosen two metric temporal planners, able
represent parallel plans representation time durative actions.
TP4 (Haslum & Geffner, 2001) temporal planner based HSP*p (Haslum & Geffner,
2000), optimal parallel state space planner IDA* search algorithm.
last planner list SAPA (Do & Kambhampati, 2001). SAPA powerful
domain-independent heuristic forward chaining planner metric temporal domains
employs distance-based heuristics (Kambhampati & Sanchez, 2000) control search.
4.1.2 Comparison Results Different Domains
run planners Gripper domain International Planning
Scheduling competition 1998 (McDermott, 2000), well three different domains
(Logistics, Scheduling, Elevator-miconic-strips) 2000 (Bacchus, 2001), three
2002 competition (Long & Fox, 2002) - DriverLog, ZenoTravel, Satellite.
cases multiple versions domain, used STRIPS Untyped
versions.6 . discuss results domains below.
Gripper: Figure 9(a), compare performance AltAltp Gripper domain (McDermott, 2000) rest planners excluding SAPA. plot shows
results terms number (parallel) steps. see even simplistic domain, AltAltp LPG planners capable scaling generating parallel
5. chosen IPP (Koehler, 1999), optimized Graphplan planning system
results reported Haslum Geffner (2001) show already less efficient STAN.
6. Since SAPA read STRIPS file format, run SAPA planner equivalent problems
unit-duration actions Long Fox (2002).

646

fiOnline Parallelization Plans Heuristic State Search

5000

40

AltAlt-p
STAN
LPG 2nd
Sapa

35

4500
4000

30
3500

25

3000

Steps

Time

20

15

2500
2000
1500

10
1000

5

500
0

0
1

2

3

4

5

6

7

8

9

10

11

12

13

14

1

15

Problems

2

3

4

5

6

7

8

9

10

11

12

13

14

15

Problems

(b)

(a)

Figure 13: Performance ZenoTravel domain (AIPS-02)
plans. None approaches able solve four problems.7 AltAltp
able scale without difficulty problems involving 30 balls. Furthermore, AltAltp
returns better plans LPG.
Elevator: Figure 9(b), compare AltAltp STAN, Blackbox LPG Elevator
domain (Miconic Strips) (Bacchus, 2001).8 AltAltp approached quality solutions
produced optimal approaches (e.g. Blackbox STAN). Notice Blackbox
solve around half problems solved AltAltp domain.
Scheduling: Results Scheduling domain shown Figure 10. Blackbox
STAN considered comparison.9 AltAltp seems reasonably approximate
optimal parallel plans many problems (around 50 them), produce significantly
suboptimal plans some. However, able solve problems
two approaches fraction time.
Logistics: plots corresponding Logistics domain Bacchus (2001) shown
Figure 11.10 difficult problems AltAltp outputs lower quality
solutions optimal approaches. However, AltAltp LPG able scale
complex problems, easily see AltAltp provides better quality
solutions LPG. AltAltp seems efficient approaches.
7. Although STAN supposed able generate optimal step-length plans, handful cases
seems produced nonoptimal solutions Gripper Domain. explanation
behavior, informed authors code.
8. include traces TP4 pre-processor planner able read
domain.
9. TP4 pre-processor cannot read domain, LPG runs memory, SAPA parsing
problems.
10. SAPA excluded due parsing problems.

647

fiSanchez & Kambhampati

5000

60

AltAlt-p
STAN
TP4
Blackbox

50

4500
4000

LPG 2nd
Sapa

40

3500
3000

Steps

Time

30

2500
2000

20
1500
1000

10

500

0

0

1

2

3

4

5

6

7

8

9

10 11 12 13 14 15 16 17 18 19

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

Problems

Problems

(b)

(a)

Figure 14: Performance Satellite domain(AIPS-02)
LPG solutions problems 49 61 obtained one iteration, since LPG
able complete second iteration reasonable amount time. explains
low time taken LPG, lower quality solutions.
DriverLog: see Figure 12(a) AltAltp reasonably well terms quality
respect approaches DriverLog domain. Every planner considered
time. AltAltp one two planners able scale up. Figure 12(b) shows
AltAltp efficient planners.
Zeno-Travel: AltAltp , SAPA, LPG able solve problems
domain.11 AltAltp solves efficiently (Figure 13(b)) providing good solution
quality (Figure 13(a)) compared temporal metric planners.
Satellite: results Satellite domain shown Figure 14. Although every
planner considered, AltAltp , SAPA, LPG solve problems. SAPA
solves problems produces lower quality solutions many them. AltAltp produces
better solution quality SAPA, efficient. However, AltAltp produces
lower quality solutions LPG four problems. LPG cannot solve one problems
produces lower quality solutions 5 them.
Summary: summary, note AltAltp significantly superior elevator
gripper domains. performs well DriverLog, ZenoTravel, Satellite
domains 2002 competition (Long & Fox, 2002). performance planners
similar Schedule domain. Logistics domain, quality AltAltp plans
second Blackbox problems optimal planner solve.
However, scales along LPG bigger size problems, returning good step11. Blackbox TP4 able parse domain.

648

fiOnline Parallelization Plans Heuristic State Search

250

900

AltAlt-PostProc
AltAlt-p
AltAlt

800

200

700
600

150

Time

Steps

500
400

100
300
200

50

100
0

0

1

4

7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61

1

4

7

10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61

Problems

Problems

(a)

(b)

Figure 15: AltAlt Post-Processing vs. AltAltp (Logistics domain)

450

60

AltAlt
AltAlt-PostProc
AltAlt-p

50

400
350
300

Time

40

Steps

30

250
200
150

20

100
10
50
0

0
1

2

3

4

5

6

7

8

Problems

9

10

11

12

13

14

1

15

2

3

4

5

6

7

8

9

10

11

12

13

14

15

Problems

(a)

(b)

Figure 16: AltAlt Post-Processing vs. AltAltp (Zenotravel domain)

length quality plans. TP4, heuristic state search regression planner capable
producing parallel plans able scale domains. SAPA, heuristic
search progression planner, competitive, still outperformed AltAltp planning
time solution quality.
649

fiSanchez & Kambhampati

SOLUTION: solution found (length = 9)
Time 1: load-truck(obj13,tru1,pos1) Level: 1
Time 1: load-truck(obj12,tru1,pos1) Level: 1
Time 1: load-truck(obj11,tru1,pos1) Level: 1
Time 2: drive-truck(tru1,pos1,apt1,cit1) Level: 1
Time 3: unload-truck(obj12,tru1,apt1) Level: 3
Time 3: fly-airplane(apn1,apt2,apt1) Level: 1
Time 3: unload-truck(obj11,tru1,apt1) Level: 3
Time 4: load-airplane(obj12,apn1,apt1) Level: 4
Time 4: load-airplane(obj11,apn1,apt1) Level: 4
Time 5: load-truck(obj21,tru2,pos2) Level: 1
Time 5: fly-airplane(apn1,apt1,apt2) Level: 2
Time 6: drive-truck(tru2,pos2,apt2,cit2) Level: 1
Time 6: unload-airplane(obj11,apn1,apt2) Level: 6
Time 7: load-truck(obj11,tru2,apt2) Level: 7
Time 7: unload-truck(obj21,tru2,apt2) Level: 3
Time 8: drive-truck(tru2,apt2,pos2,cit2) Level: 2
Time 9: unload-airplane(obj12,apn1,apt2) Level: 6
Time 9: unload-truck(obj13,tru1,apt1) Level: 3
Time 9: unload-truck(obj11,tru2,pos2) Level: 9
Total Number actions Plan: 19

POST PROCESSED PLAN ...
Time: 1 : load-truck(obj13,tru1,pos1)
Time: 1 : load-truck(obj12,tru1,pos1)
Time: 1 : load-truck(obj11,tru1,pos1)
Time: 1 : fly-airplane(apn1,apt2,apt1)
Time: 1 : load-truck(obj21,tru2,pos2)
Time: 2 : drive-truck(tru1,pos1,apt1,cit1)
Time: 2 : drive-truck(tru2,pos2,apt2,cit2)
Time: 3 : unload-truck(obj12,tru1,apt1)
Time: 3 : unload-truck(obj11,tru1,apt1)
Time: 3 : unload-truck(obj21,tru2,apt2)
Time: 3 : unload-truck(obj13,tru1,apt1)
Time: 4 : load-airplane(obj12,apn1,apt1)
Time: 4 : load-airplane(obj11,apn1,apt1)
Time: 5 : fly-airplane(apn1,apt1,apt2)
Time: 6 : unload-airplane(obj11,apn1,apt2)
Time: 6 : unload-airplane(obj12,apn1,apt2)
Time: 7 : load-truck(obj11,tru2,apt2)
Time: 8 : drive-truck(tru2,apt2,pos2,cit2)
Time: 9 : unload-truck(obj11,tru2,pos2)
END POST PROCESSING: Actions= 19 Length: 9

(a) AltAltp Solution

(b) AltAltp plus Post-processing

Figure 17: Plots showing AltAltp solutions cannot improved anymore Postprocessing.

4.2 Comparison Post-Processing Approaches
mentioned earlier (see Section 1), one way producing parallel plans
studied previously literature post-process sequential plans (Backstrom, 1998).
compare online parallelization post-processing, implemented Backstrom (1998)s
Minimal De-ordering Algorithm, used post-process sequential plans produced
AltAlt (running default heuristic hAdjSum2M using serial planning graph).
section compare online parallelization procedure offline method.
first set experiments Logistics domain (Bacchus, 2001). results
shown Figure 15. expected, original AltAlt longest plans since allows
one action per time step. plot shows post-processing techniques help
reducing makespan plans generated AltAlt. However, notice
AltAltp outputs plans better makespan either AltAlt AltAlt followed postprocessing. shows online parallelization better approach post-processing
sequential plans. Moreover, plot Figure 15(b) shows time taken AltAltp
largely comparable taken two approaches. fact, much
additional cost overhead procedure.
Figure 16 repeats experiments ZenoTravel domain (Long & Fox, 2002).
again, see AltAltp produces better makespan post-processing sequential
plans AltAlt. Notice time, AltAlt plus post-processing clearly less efficient
650

fiOnline Parallelization Plans Heuristic State Search

140

Logistics AIPS-00

600

AltAlt-p
AltAlt-p NoPush
AltAlt-p AGR

120

Logistics AIPS-00

500

100

Time

Steps

400

80

300

60
200

40
100

20

0

0

1

4

7

1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61

10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61

Problems

Problems

(a)

100

(b)

Satellite AIPS-02

250

Satellite AIPS-02

90

AltAlt-p
AltAlt-NoPush
AltAlt-p AGR

80

200

60

150

Time

Steps

70

50
40

100

30
20

50

10
0

0

1

2

3

4

5

6

7

8

9 10 11 12 13 14 15 16 17 18 19 20

Problems

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

Problems

(c)

(d)

Figure 18: Analyzing effect Pushup procedure

either two approaches. summary, results section demonstrate
AltAltp superior AltAlt plus post-processing.
One might wonder plans generated AltAltp benefit postprocessing phase. investigated issue found specific post-processing
routines used produce improvements. main reason
behavior Pushup procedure already tries exploit opportunity
shortening plan length promoting actions partial plan. illustrative
example, show, Figure 17, parallel plan output AltAltp problem
logistics domain (logistics-4-1 Bacchus, 2001), result post-processing
651

fiSanchez & Kambhampati

80

140

Logistics AIPS-00

BlocksWorld AIPS-00

Serial PG
Parallel PG

70

120

60

AltAlt-p
AltAlt

100

50

Time

Steps

80

40

60

30
40

20
20

10

0

0
1

4

7

10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61

1

3

5

7

9

11

13

Problems

15

17

19

21

Problems

23

25

27

29

31

33

35

(b) Solving Serial domain

(a) Utility using Parallel Planning Graphs

Figure 19: Plots showing utility using parallel planning graphs computing
heuristics, characterizing overhead incurred AltAltp serial domains.

solution. Although two solutions differ terms step contents, notice
step length. difference step contents explained fact
de-ordering algorithm relaxes ordering relations plan, allowing
actions come earlier, Pushup always moves actions towards end plan.
run comprehensive studies three different domains (Logistics, Satellite
Zenotravel), found case step length plan produced AltAltp
improved post-processing routine (we omit comparison plots since essentially
show curves corresponding AltAltp AltAltp post-processing coincident).12
4.3 Ablation Studies
section attempts analyze impact different parts AltAltp performance.
Utility Pushup Procedure: Figure 18 shows effects running AltAltp
without Pushup procedure (but fattening procedure), well running
aggressive version Pushup, described Section 3, re-expands
nodes search branch, action pushed up. see running
AltAltp Pushup fattening procedures better latter. Comparison
results Figure 15(a) Figure 18(a) shows even fattening procedure
performs better original AltAlt. Figure 18(b) see although
Pushup procedure add much overhead, aggressive version Pushup get
quite expensive. notice around 20 problems solved within time limits
12. verified least one problem domains.

652

fiOnline Parallelization Plans Heuristic State Search

aggressive Pushup. plots Figure 18(c) Figure 18(d) show results
experiments Satellite domain. see situation quite similar
domain. conclude Pushup procedure, used offset greediness
algorithm, achieves purpose.
Utility basing heuristics Parallel Planning Graphs: see Figure 19(a) using parallel planning graph basis deriving heuristic estimates
AltAltp winning idea. serial planning graph overestimates heuristic values
terms steps, producing somewhat longer parallel solutions. fact version
using serial planning graph runs time many problems demonstrates
running times improved use parallel planning graphs.
Comparison AltAlt: One final concern would much extra computational
hit taken AltAltp algorithm serial domains (e.g. Blocks-World Bacchus,
2001). expect negligible confirm intuitions, ran AltAltp set
problems sequential Blocks-World domain. see plot 19(b)
time performance AltAlt AltAltp equivalent almost problems.

5. Related work
idea partial exploration parallelizable sets actions new (Kabanza, 1997;
Godefroid & Kabanza, 1991; & Kambhampati, 2001). studied area
concurrent reactive planning, one main goals approximate optimal
parallelism. However, research focused forward chaining
planners (Kabanza, 1997), state world completely known.
implied backward-search methods suitable kind analysis (Godefroid
& Kabanza, 1991) search nodes correspond partial states. shown
backward-search methods used approximate parallel plans context
classical planning.
Optimization plans according different criteria (e.g. execution time, quality, etc)
done post-processing step. post-processing computation given
plan maximize parallelism discussed Backstrom (1998). Reordering
de-ordering techniques used maximize parallelism plan. de-ordering
techniques ordering relations removed, added. reordering, arbitrary
modifications plan allowed. general case problem NP-Hard
difficult approximate (Backstrom, 1998). Furthermore, discussed Section 1
4, post-processing techniques concerned modifying order
existing actions given plan. approach considers modifying orderings
inserting new actions online minimize possible number parallel
steps overall problem.
already discussed Graphplan based planners (Long & Fox, 1999; Kautz &
Selman, 1999), return optimal plans based number time steps. Graphplan
uses IDA* include greatest number parallel actions time step
search. However, iterative procedure time consuming provide
guarantee number actions final plans. attempts
minimize number actions planners (Huang, Selman, & Kautz, 1999)
653

fiSanchez & Kambhampati

using domain control knowledge based generation rules specific
planning domain. Graphplan algorithm tries maximize parallelism satisfying
subgoals time step, search fails backtracks reduces
set parallel actions considered one level before. AltAltp opposite,
tries guess initial parallel nodes given heuristics, iteratively adds actions
nodes possible Pushup procedure later search.
recently, work generalizing forward state search handle action concurrency metric temporal domains. particular relevance work
Temporal TLPlan (Bacchus & Ady, 2001) SAPA (Do & Kambhampati, 2001).
planners designed specifically handling metric temporal domains, use
similar search strategies. main difference Temporal TLPlan
depends hand-coded search control knowledge guide search, SAPA (like
AltAltp ) uses heuristics derived (temporal) planning graphs. such,
planners co-opted produce parallel plans classical domains. planners forward chaining search, AltAltp , achieve concurrency
incrementally, without projecting sets actions, following way. Normal forward
search planners start initial state S0 , corresponding time t0 , consider actions
apply S0 , choose one, say a1 apply S0 , getting S1 . simultaneously
progress system clock t0 t1 . order allow concurrency, planners
Bacchus Ady (2001), Kambhampati (2001) essentially decouple
action application clock progression. every point search, nondeterministic choice - progressing clock, applying (additional) actions
current time point. point view planners, AltAltp seen providing heuristic guidance non-deterministic choice (modulo difference AltAltp
regression search). results empirical comparisons AltAltp SAPA,
show AltAltp outperforms SAPA, suggest heuristic strategies employed
AltAltp including incremental fattening, pushup procedure, gainfully
adapted planners increase concurrency solution plans. Finally, HSP*,
TP4, extension temporal domains, heuristic state search planners using
regression capable producing parallel plans (Haslum & Geffner, 2000). TP4
seen regression version approach used SAPA temporal TLPlan.
experiments however demonstrate neither planners scales well comparison
AltAltp .
Pushup procedure seen plan compression procedure. such, similar
plan compression procedures double-back optimization (Crawford, 1996).
One difference double-back used context local search, Pushup
used context systematic search. Double-back could applied
finished plan schedule, post-processing approach outcome would
depend highly plan given input.

6. Concluding Remarks
Motivated acknowledged inability heuristic search planners generate parallel
plans, developed presented approach generate parallel plans
context AltAlt, heuristic state space planner. challenging problem
654

fiOnline Parallelization Plans Heuristic State Search

exponential branching factor incurred naive methods. approach tries avoid
branching factor blow greedy online parallelization evolving partial
plans. plan compression procedure called Pushup used offset ill effects
greedy search. empirical results show comparison planners capable
producing parallel plans, AltAltp able provide reasonable quality parallel plans
fraction time competing approaches. approach seems provide better
quality plans achieved post-processing sequential plans. results show
AltAltp provides attractive tradeoff quality efficiency generation
parallel plans. future, plan adapt AltAltp approach metric temporal
domains, need concurrency pressing. One idea adapt
sources strength AltAltp SAPA, metric temporal planner developed
group (Do & Kambhampati, 2001).

Acknowledgments
thank Minh B. XuanLong Nguyen helpful discussions feedback.
thank David Smith JAIR reviewers many constructive comments. research
supported part NASA grants NAG2-1461 NCC-1225, NSF grant
IRI-9801676.

References
Bacchus, F. (2001). AIPS00 planning competition. AI Magazine, 22 (3), 4756.
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward
chaining approach. Proceedings IJCAI-01, pp. 417424.
Backstrom, C. (1998). Computational aspects reordering plans. Journal Artificial
Intelligence Research, 9, 99137.
Blum, A., & Furst, M. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90, 281300.
Bonet, B., & Geffner, H. (1999). Planning heuristic search: new results. Proceedings
ECP-99.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism
planning. Proceedings AAAI-97, pp. 714719. AAAI Press.
Crawford, J. (1996). approach resource-constrained project scheduling. Proceedings
1996 Artificial Intelligence Manufacturing Research Planning Workshop.
AAAI Press.
Do, M. B., & Kambhampati, S. (2000). Solving planning graph compiling CSP.
Proceedings AIPS-00, pp. 8291.
Do, M. B., & Kambhampati, S. (2001). SAPA: domain-independent heuristic metric
temporal planner. Proceedings ECP-01.
655

fiSanchez & Kambhampati

Fikes, R., & Nilsson, N. (1971). Strips: new approach application theorem
proving problem solving. Artificial Intelligence, 2 (3-4), 189208.
Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphs.
Proceedings AIPS-02. AAAI Press.
Godefroid, P., & Kabanza, F. (1991). efficient reactive planner synthesizing reactive
plans. Proceedings AAAI-91, Vol. 2, pp. 640645. AAAI Press/MIT Press.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning. Proceedings
AIPS-00, pp. 140149.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP-01. Springer.
Huang, Y., Selman, B., & Kautz, H. (1999). Control knowledge planning: benefits
tradeoffs. Proceedings AAAI/IAAI-99, pp. 511517.
Kabanza, F. (1997). Planning verifying reactive plans (position paper). Proceedings
AAAI-97 Workshop Immobots: Theories Action, Planning Control.
Kambhampati, S., & Sanchez, R. (2000). Distance based goal ordering heuristics graphplan. Proceedings AIPS-00, pp. 315322.
Kautz, H., & Selman, B. (1996). Pushing envelope: planning, propositional logic,
stochastic search. Proceedings AAAI-96, pp. 11941201. AAAI Press.
Kautz, H., & Selman, B. (1999). Blackbox: unifying sat-based graph-based planning.
Proceedings IJCAI-99.
Koehler, J. (1999). RIFO within IPP. Tech. rep. 126, University Freiburg.
Korf, R. (1993). Linear-space best-first search. Artificial Intelligence, 62, 4178.
Long, D., & Fox, M. (1999). Efficient implementation plan graph STAN. Journal
Artificial Intelligence Research, 10, 87115.
Long, D., & Fox, M. (2002). 3rd international planning competition: results
analysis. appear JAIR.
McDermott, D. (1999). Using regression-match graphs control search planning. Artificial Intelligence, 109 (1-2), 111159.
McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2),
3555.
Nguyen, X., & Kambhampati, S. (2000). Extracting effective admissible heuristics
planning graph. Proceedings AAAI/IAAI-00, pp. 798805.
Nguyen, X., Kambhampati, S., & Sanchez, R. (2002). Planning graph basis deriving heuristics plan synthesis state space CSP search. Artificial Intelligence,
135 (1-2), 73123.
656

fiOnline Parallelization Plans Heuristic State Search

Sanchez, R., Nguyen, X., & Kambhampati, S. (2000). AltAlt: combining advantages
graphplan heuristics state search. Proceedings KBCS-00. Bombay, India.

657


