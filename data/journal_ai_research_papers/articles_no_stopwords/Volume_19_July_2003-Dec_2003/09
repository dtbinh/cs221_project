journal artificial intelligence

submitted published

compiling causal theories successor state axioms
strips systems
fangzhen lin

flin cs ust hk

department computer science
hong kong university science technology
clear water bay kowloon hong kong

abstract
describe system specifying effects actions unlike commonly
used ai system uses action description language allows one
specify effects actions domain rules state constraints
entail action effects old ones declaratively action domain language
corresponds nonmonotonic causal theory situation calculus procedurally
action domain compiled set logical theories one action domain
fully instantiated successor state axioms strips systems
generated expect system useful tool knowledge engineers writing action
specifications classical ai systems golog systems systems
formal specifications actions needed

introduction
describe system generating action effect specifications set domain rules
direct action effect axioms among things expect system useful
tool knowledge engineers writing action specifications classical ai systems
golog systems levesque et al systems formal specifications
actions needed
motivate consider language used strips fikes nilsson describing effects actions briefly speaking action described language
first order formula called precondition describes condition
action executable add list enumerates propositions action make
true successfully executed situation delete list enumerates propositions action make false successfully executed situation
original strips allowed precondition elements two lists complex
formulas strips actions refer whose precondition given conjunction atomic formulas whose add delete lists lists atomic formulas
widely acknowledged language inadequate describing actions
real world one limitations one address
language one enumerate possible effects action difficult impossible
task complex domains example given large c program hard figure
effects changing value pointer values pointers program
however underlying principle simple value pointer changes
values pointers point memory location change well put
another way direct effect action changing value pointer x
c

ai access foundation morgan kaufmann publishers rights reserved

filin

value pointer x indirect side effects action derived
constraint says two pointers point common location
values must
idea specifying effects actions domain constraints engineering
first principle many advantages first constraints action independent work actions secondly effects actions derived domain
constraints agree ones expectation good indication one
axiomatized domain correctly finally domain constraints used purposes well instance used check consistency initial situation
database general set sentences violates domain constraint know
legal situation satisfy set sentences idea used
prune impossible states recently even efforts reverse engineering
domain constraints strips systems speed planners e g zhang foo
gerevini schubert fox long others
appealing use domain constraints derive indirect effects actions
making idea work formally turned challenge commonly
known ramification proposals made solve
recently however proposals best theoretical interest
high computational complexity situation since changed substantially due
use causality representing domain constraints lin mccain turner
thielscher baral lifschitz others
describe implemented system builds recent work causalitybased approaches ramification specifically system takes input
action domain description actions described precondition axioms
direct effect axioms domain constraints represented call domain rules
system returns output complete action specification strips format
set fully instantiated successor state axioms reiter
organized follows begin introducing action description language propose procedure compile action domain specified language
complete set successor state axioms strips description
extracted soundness procedure respect translation
action domain descriptions situation calculus causal theories lin next
describe implementation procedure present experimental
one see one limitations system essentially propositional
effect axioms domain rules variables need fully instantiated
compilation process partially overcome limitation
allow one generalize propositional output first order case certain classes
action domain descriptions discuss related work conclude
pointers future work

action description language
assume first order language equality shall call predicates whose extensions may changed actions fluents whose extensions changed
actions static relations call unary static relations types fluent atoms


fifrom causal theories strips systems

mean atomic formulas formed fluents equality atom one form u v
u v variables constants inequality constraint one form
u v actions represented functions assumed functions
positive arities language
action description language includes following components
type definitions
type definition specified expressions following form
domain p
p type constants intuitive meaning expression
domain extension type p set instance blocks
world may type called block say five blocks named numerically
domain block logistics domain may type called loc
locations say locations l l l domain loc l l l
primitive fluent definitions
primitive fluents defined expressions following form
fluent f x xn p x pn xn e em
f n ary fluent pi n type ei
inequality constraint form xj xk j k n intuitive meaning
expression f x xn legal fluent atom second argument true
instance blocks world given type definition domain block
following fluent specification
fluent x block x block x
would generate following six legal fluent atoms

clearly exactly one fluent definition fluent
complex fluent definitions
given set primitive fluents one may want define ones instance
blocks world given primitive fluent define clear terms
x clear x x
specify complex fluents clear first define fluent formulas follows
fluent formula terms e constant
domain type variable
f tn fluent formula tn terms f n ary
primitive fluent complex fluent static relation


filin

fluent formula
fluent formulas
fluent formula x variable p type x p x type p
holds x p x type p holds fluent formulas notice
require types finite domains quantifications really shorthands
domain p x p stands
x x
x p stands
x x
complex fluent specified language pair expressions following
form
complex f x xn p x pn xn e em
defined f x xn
pi ei primitive fluent definitions fluent formula
mention complex fluents whose free variables among x xn
first expression specifies syntax second semantics complex fluent
instance complex fluent clear blocks world specified
complex clear x block x
defined clear x block x
mentioned quantifiers shorthands type must
finite domain instance given following specification
domain block
fluent x block x block
fluent definition clear expanded
defined clear
defined clear
defined clear
static relation definitions
mentioned static relation one changed action domain
instance robot navigation domain may proposition connected r r
meaning door connects rooms r r truth value proposition cannot
changed navigating robot rolls room room
language static relation defined expression following form
static g x xn p x pn xn e em
g n ary predicate pi ei primitive fluent definitions
meaning expression similar fluent definition exactly
one definition static relation


fifrom causal theories strips systems

domain axioms
domain axioms constraints static relations instance static proposition
connected r r may want impose following constraint connected r r
connected r r language domain axioms specified expressions
form
axiom
fluent formula mention fluents e mentions static
relations equality instance constraint connected written
axiom door r room r room connected r r
connected r r
door room types
action definitions
actions defined expressions following form
action x xn p x pn xn e em
n ary action pi ei primitive fluent definitions
instance blocks world given type definition domain block
following action specification
action stack x block x block x
would generate following six action instances
stack stack stack stack stack stack
exactly one action definition action
action precondition definitions
action precondition definitions specified expressions following form
p recond x xn
n ary action fluent formula whose free variables among x xn
exactly one precondition definition action instance
blocks world may
p recond stack x clear x clear ontable x
says action stack x executable situation clear x clear
ontable x must true


filin

action effect specifications
action effects specified expressions following form
effect x xn f yk
form
effect x xn f yk
fluent formula f primitive fluent intuitive meaning
expressions true initial situation action x xn cause
f yk true false instance blocks world action stack x causes
x
effect stack x true x
example context dependent effect consider action drop x breaks object
fragile
effect drop x f ragile x broken x
notice fluent formula action effect specifications variables x xn yk informally variables supposed
universally quantified precisely expressions instantiated one
substitute objects variables provided resulting formulas well formed
instance given action effect specification effect move x g x q x x f
one instantiate effect move g b q b c f long move legal
action according action definition move g b q b c f legal
fluent atoms according fluent definitions g q f
domain rules
domain rules specified expressions following form
causes f x xn
following form
causes f x xn
fluent formula f primitive fluent action effect specifications
variables x xn intuitive meaning domain rule
situation holds fluent atom f x xn caused
true domain rule stronger material implication formal semantics given
mapping causal rule lin see section thus name causes
instance blocks world block one block
causes x z x z
logistics domain one may want say package inside truck
location l package location l well
causes x l x l


fifrom causal theories strips systems

action domain descriptions
following definition sums action description language
definition action domain description set type definitions primitive fluent
definitions complex fluent definitions static proposition definitions domain axioms action
definitions action precondition definitions action effect specifications domain rules
example following action domain description defines blocks world three
blocks
domain block
fluent x block x block
fluent ontable x block x
complex clear x block x
defined clear x block x
causes x x z z
causes x z x z
causes x ontable x
causes ontable x x
action stack x block x block x
p recond stack x ontable x clear x clear
effect stack x true x
action unstack x block x block x
p recond unstack x clear x x
effect unstack x true ontable x
action move x z block x block block z x x z z
p recond move x z x clear x clear z
effect move x z true x z

procedural semantics
given action domain description use following procedure called ccp causal
completion procedure generate complete action effect specification
use primitive complex fluent definitions generate legal fluent atoms
following let f set fluent atoms generated
use action definitions generate legal action instances action
instance following


filin

primitive fluent atom f f collect ground instances positive
effects
effect f effect n f
ground instances negative effects
effect f effect f
ground instances positive domain rules
causes f causes k f
ground instances negative domain rules
causes f causes l f
generate following pseudo successor state axiom
succ f init init n succ succ l
init f init init
succ succ k



fluent formula init formula obtained replacing every fluent atom f init f similarly succ formula
obtained replacing every fluent atom f succ f intuitively
init f means f true initial situation succ f f true
successor situation performing action initial situation
let succ set pseudo successor state axioms one primitive
fluent f generated last step succ following set axioms
succ succ f succ defined f complex fluent definition
init following set axioms
init axiom domain axiom
init init f causes f domain rule
init init f causes f domain rule
init f init defined f complex fluent definition
init p recond precondition definition
fluent atom f formula f
init succ succ succ f f
f mention propositions form succ f output
axiom
succ f f
generating ground instances shorthands x p expanded see definition fluent
formulas last section



fifrom causal theories strips systems

otherwise action effect f indeterminate case output two
axioms
succ f f
f succ f
f strongest formula satisfying first implication f weakest
formula satisfying second implication following explicit
action computing effects write axioms
succa inita succ
conceptually step procedure significant next section
shall prove step provably correct translation situation calculus
causal theories lin computationally step expensive shall
describe strategies system uses implement section
procedure work properly action domain description satisfy
following conditions
require fluent atoms init succ succ among generated
step would rule cases
fluent x block x block x
together defined clear x block x latter would generate
fluent atoms form x x ruled fluent definition
one could drop inequality constraint definition change
complex fluent definition defined clear x block x x
could built test procedure reject action domain
description incoherent fluent definitions one easy way making sure
happen use inequality constraints definition fluents
mentioned action exactly one action precondition captures exactly conditions action executable
action precondition given explicitly one needs careful
writing action effect axioms domain rules contradictory effects
would generated instance given p recond true action effect axioms
effect true f effect true f clearly realizable simultaneously
similarly causes true f given domain rule one write
effect axiom effect true f insisted executable
could simply conclude executable effect axioms contradiction effect axioms contradict domain rules remains future
work extend procedure allow automatic generation implicitly
given action preconditions shall assume given action domain
specification consistent sense action instance generated
step following theory
init succ succ init succ f
effect f ground instance effect axiom


filin

consistent
related point procedure assumes information initial situation
given init particular action effect axioms entail information initial situation instance given causes q p effect true p
p recond true must initial situation q cannot true
otherwise persist next situation causing p false contradicts action effect formally means given set atoms
form init f f primitive fluent atom init consistent
succsucc consistent complement following
set
init f init f
f primitive fluent atom generated step
notice similar reason reiter needed called consistency assumption order completion procedure sound complete generating
successor state axioms reiter
action domain descriptions clearly targeted specifying deterministic actions
indeterminate effects sometimes arise cyclic domain rules instance
consider following action domain description
causes p p
p recond true
action init tautology succ empty succ consists following pseudosuccessor state axiom p
succ p succ p init p
equivalent init p succ p initially p true performed
know p continue true p initially false performed
know p true
example consider blocks world description example set fluent atoms
generated step
f
clear clear clear
ontable ontable ontable
step generates following action instances
stack stack stack stack stack stack
unstack unstack unstack unstack unstack
unstack move move move move
move move


fifrom causal theories strips systems

action instances need go steps instance
stack one effect axiom
effect stack true
following causal rules
causes
causes
causes
causes
causes ontable
therefore step generates following pseudo successor state axiom
succ true
init succ succ
succ succ succ ontable
similarly generate following pseudo successor state axioms primitive
fluent atoms
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ init succ succ
succ succ succ ontable
succ ontable
init ontable succ succ succ
succ ontable
init ontable succ succ succ


filin

succ ontable
init ontable succ succ succ
complex fluent clear definition yields following axioms
succ clear succ succ succ
succ clear succ succ succ
succ clear succ succ succ
solve pseudo successor state axioms generate following successor state axioms
succ f alse
succ f alse
succ f alse
succ f alse
succ init
succ ontable init ontable
succ clear init clear
succ clear init clear

succ true
succ f alse
succ init
succ f alse
succ ontable f alse
succ ontable init ontable
succ clear f alse

set fully instantiated successor state axioms generate
strips descriptions following
stack
preconditions
add list
delete list
cond effects
indet effects

ontable clear clear

ontable clear
none
none

stack
preconditions
add list
delete list
cond effects
indet effects

ontable clear clear

ontable clear
none
none



fifrom causal theories strips systems

following remarks
although generate axiom succ f alse stack put
delete list deduce init f alse
init well fluent atom put add delete list action
fluent atoms truth value definitely changed action see section
details strips description generated successor state
axioms
one see ccp procedure crucially depends fact type
finite domain reasoning done propositional logic
limitation current system limitation bad one might think
first typical assume finite domains changing
domain type action description easy one needs change
corresponding type definition significantly generic action domain description
often obtained one assumes finite domain blocks world
example numbers generic names replaced
parameters instance replace x stripslike description stack get strips description stack x
works x found strategy often works
domains

formal semantics
formal semantics action domain description defined translating
situation calculus causal theory lin shall procedure ccp given
sound semantics
section mainly interested nonmonotonic action theories
interested action description language describing action
domains section safely skipped
first briefly review language situation calculus
situation calculus
language situation calculus many sorted first order language assume
following sorts situation situations action actions fluent propositional fluents
truth value truth values true f alse object everything else
use following domain independent predicates functions
binary function action situation situation
resulting performing
binary predicate h p situation h p true p holds
binary predicate p oss action situation p oss true
possible executable
ternary predicate caused fluent atom p truth value v situation
caused p v true fluent atom p caused something unspecified
truth value v situation


filin

last section introduced fluent formulas extend h formulas
fluent formula situation h defined follows
h
p static proposition h p p
inductively h h h h h similarly
connectives
inductively h x p x p x h h x p x p x
h
according definition h expanded situation calculus formula
h applied fluents
translation situation calculus
given first order language l writing action domain descriptions assume
corresponding language l situation calculus constants l
constants sort object l types l types unary predicates l
static relations predicates arities l fluents l functions
sort f luent l actions l functions sort action l
conventions following translation map action domain description situation
calculus theory
let action domain description translation situation calculus
theory defined follows
type definition domain p ak translated
x p x x x ak
ak
primitive fluent definition
fluent f x xn p x pn xn e em
translated
x xn fluent f x xn p x pn xn e em
complex fluent definition
complex f x xn p x pn x e em
defined f x xn
translated
x xn fluent f x xn p x pn x e em
x xn fluent f x xn h f x xn h


fifrom causal theories strips systems

domain axiom static propositions
axiom
translated quantifiers treated shorthands
x p x p x
x p x p x
action definition
action x xn p x pn xn e em
translated
x xn action x xn p x pn xn e em
assume domain description one action definition
action
action precondition axiom
p recond x xn
translated
action x xn p oss x xn h

list free variables x xn mentioned earlier
one limitations current system action preconditions
given explicitly reflected translation
action effect axiom
effect x xn f yk
translated
action x xn fluent f yk p oss x xn

h caused f yk true x xn
list free variables x xn f yk
similarly effect axiom
effect x xn f yk
translated
action x xn fluent f yk p oss x xn

h caused f yk f alse x xn


filin

domain rule form
causes f x xn
translated

fluent f
x xn h caused f x xn true
list free variables f x xn similarly domain rule
form
causes f x xn
translated

fluent f
x xn h caused f x xn f alse
given action domain description let translation situation
calculus semantics determined completion comp defined
set following sentences
circumscription caused predicates fixed
following basic axioms caused says fluent atom caused
true false true false
caused p true holds p



caused p f alse holds p



truth values following unique names domain closure axiom
true f alse v v true v f alse



unique names assumptions fluents actions specifically f fn
fluents
x fj j different
x x
similarly actions
primitive fluent atom f following generic successor state axiom
p oss h f



caused f true h f caused f f alse
foundational axioms lin reiter b discrete situation calculus
axioms characterize structure space situations purpose
enough mention include following unique names
axioms situations




fifrom causal theories strips systems

following theorem shows procedural semantics given previous section
sound respect semantics given
theorem let action domain description translation situation
calculus let ground action instance situation variable situation
calculus formula satisfies following two conditions contains two
situation terms mention predicate h
equality static relations let obtained replacing h f
init f h f succ f
comp p oss



init succ succ




init succ succ sets axioms generated according procedure section
proof suppose situation model comp p oss construct
ms follows
domain ms object domain
interpretations non situational function predicate symbols ms

fluent atom f ms init f iff h f ms succ f iff
h f
clearly iff ms ms model left hand
side see
notice first ground fluent atom f generated procedure ccp iff fluent f
true notice fluent atoms init succ succ must generated
procedure
first ms model init
axiom domain axiom thus satisfies since
fluent symbols ms satisfies
causes f x xn domain rule

fluent f
x xn h caused f x xn true
thus satisfies

fluent f
x xn h h f x xn
thus init init f corresponding formula init f
ground instantiation f x xn respectively fluent f must
true otherwise formula would init satisfies
h h f construction ms satisfies init init f
case causes f similar


filin

suppose defined f instantiation complex fluent definition
f init init fluent f must true thus must satisfy
h f h construction ms satisfies init f init
suppose p recond precondition axiom since satisfies p oss
action one action instances generated procedure
thus satisfies h ms satisfies init
ms model succ primitive fluent atom f
generated procedure step pseudo successor state axiom holds referring
notation axiom need satisfies following formula
h f h h n
h h l
h f h h
h h k
first instantiating generic successor state axiom get
p oss h f
caused f true h f caused f f alse
since model p oss
h f



caused f true h f caused f f alse
consider circumscription caused predicates fixed notice
axioms caused form w caused x z w formula
mention caused therefore circumscription caused equivalent
predicate completion caused suppose f f axioms
caused f x v follows
w caused f x v wi caused f x v
unique names axioms fluents predicate completion
caused entail
caused f x v w wi
w wi action effect axioms domain rules f way
generated noting action fluent f p oss true one
see equivalence instantiated replacing x true v
get
caused f true h h n
h h l


fifrom causal theories strips systems

similarly following axiom caused f f alse
caused f f alse h h
h h k
two axioms get
h f h h n
h h l
h f h h
h h k
since model comp satisfies formula construction
ms satisfies pseudo successor state axiom
finally fact ms model succ apparent

general imply several reasons
mentioned procedure ccp assume information
initial situation given init
procedure works actions one time situation calculus theory
captures effects actions single theory possible bad specification action causes entire theory become inconsistent instance
causes true p p recond true effect f alse p corresponding situation calculus theory inconsistent action
procedure generate inconsistent theory

implementation
except step procedure ccp section straightforward implement
section describes strategy system uses implementing step main
idea comes work lin strongest necessary weakest sufficient
conditions
given propositional theory proposition q set b propositions formula
said sufficient condition q b consists propositions b
q said weakest sufficient condition sufficient
condition similarly formula said necessary
condition q b consists propositions b q said
strongest necessary condition necessary condition

easy see weakest sufficient condition strongest necessary condition unique logical equivalence background theory shown lin
two notions closely related computed technique
forgetting lin reiter particular action theories effective strategy first compute strongest necessary condition add background theory


filin

compute weakest sufficient condition theory strategy
justified following proposition lin
proposition let theory q proposition b set propositions
necessary condition q b weakest sufficient condition q b
weakest sufficient condition q b
describe strategy implementing step procedure ccp
following given action instance step let succ set pseudosuccessor state axioms primitive fluent atoms succ set pseudo successor state
axioms complex fluent atoms init set initial situation axioms derived
action precondition axiom domain axioms domain rules complex fluent
definitions following succ proposition one form succ f
init proposition one form init f
transform init clausal form derive set unit clauses u nit
use u nit simplify axioms succ resulting axiom
succ f f



f mention succ propositions delete succ output
replace succ f rest axioms f
fluent atom f whose pseudo successor state axiom succ f
form init f candidate frame axiom check see succ f
derived succ u nit init f unit resolution delete succ
output succ f init f replace succ f succ init f
fluent atom f whose pseudo successor state axiom succ compute
strongest necessary condition f succ f init propositions
theory init succ weakest sufficient condition f succ f initpropositions theory f init succ f tautology delete
succ output succ f f replace succ f succ f
tautology output succ f f f f succ f delete
succ correctness step follows proposition
previous steps solve equations succ generate appropriate output
primitive fluent atoms complex fluent atom f
defined f
every primitive fluent atom successor state axiom following
primitive fluent atoms changed action complex
fluent atom changed action output succ f init f
b otherwise output succ f obtained succ replacing
every succ proposition right side successor state axiom


fifrom causal theories strips systems

otherwise primitive fluent atoms successor state
axiom means action may indeterminate effect
action may indeterminate effect f well compute strongest necessary weakest sufficient conditions succ f init succ succ
last step output
step try generate strips description action instance
steps fluent atom f according one
following cases
successor state axiom succ f true put f add list unless
init f entailed init
b successor state axiom succ f f alse put f delete list
unless init f entailed init
c successor state axiom succ f true f alse
init f put f conditional effect list output successor state
axiom
f successor state axiom put list indeterminate
effects
clearly f put lists truth value affected
steps procedure bottleneck worst case computing
strongest necessary condition proposition conp hard however
experience action context free effect fluent atom f successor
state axiom computed without going step
implemented procedure ccp strategy swi prolog
url system follows
http www cs ust hk flin ccp html
system encoded action description language many
domains come original release pddl mcdermott compiled
strips specifications encodings domains returned
system included online appendix following illustrate
interesting features system following two domains blocks world
monkey bananas domain
blocks world
used blocks world running example shall give alternative specification domain following better known set actions stack
unstack pickup putdown shall use domain changing slightly
precondition one actions different action specification
swi prolog developed jan wielemaker university amsterdam



filin

begin description corresponds standard strips encoding
domain
fluent x block x block
fluent ontable x block x
fluent holding x block x
complex clear x block x
defined clear x block x holding x
complex handempty true
defined handempty x block holding x
causes x x z z
causes x z x z
causes x ontable x
causes ontable x x
causes x holding x
causes x holding
causes holding x ontable x
causes holding x x
causes holding x x
causes holding x x holding
action stack x block x block x
p recond stack x holding x clear
effect stack x true x
action unstack x block x block x
p recond unstack x clear x x handempty
effect unstack x true holding x
action putdown x block x
p recond putdown x holding x
effect putdown x true ontable x
action pickup x block x
p recond pickup x handempty ontable x clear x
effect pickup x true holding x
notice compared description example two fluents holding
handempty thus domain rules definition
clear changed take account block held considered
clear


fifrom causal theories strips systems

assuming domain three blocks domain block system
generate fluent atoms action instances action instance returns
complete set successor state axioms strips representation total
computation time actions k inferences seconds pure strips
domain e actions context free type domains mentioned earlier
step implementation procedure needed step easy
expected instance action pickup strips representation returned system looks following track track stripslike representation looks
pickup
preconditions clear handempty ontable
add list holding
delete list ontable clear handempty
conditional effects
indeterminate effects
complete output given online appendix let us consider happen
drop ontable x precondition pickup x
p recond pickup x handempty clear x
means long block clear picked precondition
system returns following strips representation action pickup
pickup
preconditions clear handempty
add list holding
delete list clear handempty ontable
conditional effects
succ clear init init
succ clear init init
indeterminate effects
negation disjunction adl description action
would something following
pickup x
preconditions clear x handempty
add list holding x
clear x
delete list clear x handempty
x x
ontable x ontable x
times refer cpu times pentium iii ghz machine mb ram running
swi prolog linux number inferences one reported swi prolog
roughly corresponds number resolution steps carried prolog interpreter
machine independent



filin

monkey bananas domain
domain adapted mcdermotts pddl library domains
attributes university washingtons ucpop collection action domains
turn attributes prodigy action effects generated system
context dependent context free systems shall elaborate
difference later
domain two types loc locations assume three locations
object things monkey banana box etc
domain loc
domain object monkey box banana knif e glass f ountain
following fluent definitions
fluent onf loor
fluent x object loc x
fluent hasknif e
fluent onbox x loc x
fluent hasbanana
fluent haswater
fluent hasglass
following domain rules fluents
causes onbox x monkey x



causes onbox x box x



causes onbox x onf loor



causes onf loor onbox x



causes x x



causes hasglass monkey x glass x



causes hasknif e monkey x knif e x



causes hasbanana monkey x banana x



following action definitions along respective preconditions effect
axioms
goto x monkey goes x
action goto x loc x loc x
p recond goto x monkey onf loor
effect goto x true monkey x


fifrom causal theories strips systems

climb x monkey climbs onto box location x
action climb x loc x
p recond climb x box x onf loor monkey x
effect climb x true onbox x
pushbox x monkey pushes box x
action pushbox x loc x loc x
p recond pushbox x monkey box onf loor
effect pushbox x true monkey x
effect pushbox x true box x
getknif e x get knife location x
action getknif e x loc x
p recond getknif e x knif e x monkey x hasknif e
effect getknif e x true hasknif e
getbanana x grab banana loc x provided monkey box
action getbanana x loc x
p recond getbanana x onbox x banana x hasbanana
effect getbanana x true hasbanana
pickglass x pick glass loc x
action pickglass x loc x
p recond pickglass x glass x monkey x hasglass
effect pickglass x true hasglass
getwater x get water fountain loc x provided monkey box
glass hand
action getwater x loc x
p recond getwater x f ountain x onbox x hasglass haswater
effect getwater x true haswater
domain actions fluent atoms action system
generates complete set fully instantiated successor state axioms stripslike representation instance action goto following strips
representation generated system


filin

action goto
preconditions monkey onfloor
add list monkey
delete list monkey
conditional effects
succ banana init hasbanana init banana
succ knife init hasknife init knife
succ glass init hasglass init glass
succ banana init hasbanana init banana
succ knife init hasknife init knife
succ glass init hasglass init glass
total running time actions seconds performing million inferences
percent time spent step e computing strongest necessary
weakest sufficient conditions fluent atoms given action contextdependent effects instance action goto majority time spent
generating conditional effects
action actually actions domain could use adl
description pednault conditional effects
add list banana hasbanana
knife hasknife
glass hasglass
delete list banana hasbanana
knife hasknife
glass hasglass
however clear whether done general case
mentioned earlier specifications domain given mcdermotts collection well others context free instance following specification
action goto pddl mcdermotts collection
action go
parameters x
precondition location x location
x floor monkey
effect monkey x monkey
corresponds context free action change fluent except
clear design action take account domain rules
specification initially banana location goal banana
location would achievable


fifrom causal theories strips systems

summary
domains experimented including scheduling domain includes
pednaults dictionary paycheck domain special case rocket domain sri
robot domain machine shop assembling domain ferry domain grid domain
sokoban domain gear domain included online appendix
summarize common features domains
domains tried quite straightforward decide effects
action encoded direct effects given predicate effect
effects indirect effects derived domain rules
common domain rules functional dependency constraints instance
blocks world fluent atom x functional arguments
monkey banana domain fluent atom object loc functional
second argument object one location makes sense
would special shorthand domain rules perhaps special
procedure handling well significantly given prevalence
functional dependency constraints action domains worthwhile
investigate possibility general purpose planner making good use
constraints
mentioned earlier system propositional generated successor state
axioms strips systems fully instantiated however often easy
user generalize propositional specifications first order ones
shall investigate generality observation next

generalizing propositional strips systems ones
parameters
mentioned many action domain descriptions successor state axioms
strips systems generated specific domain generalized arbitrary ones
precisely let domain description
domain p dp domain pk dpk
type specification suppose action inita succa
suppose another domain description except different
type specification
domain p dp domain pk dp k
question interested given one one mapping type
specification inita succa true resp
replacing objects resp according mapping
instance true blocks world generalize
domain description example follows shown action stack
succ succ true change type specification
domain block b c e map c e domain


filin

specification action stack c succ c succ e
true furthermore changing mapping see x different
c mapping needs one one succ x true
obviously expected blocks world proceed
general classes domain descriptions well first make precise
mapping one type specification another
definition given two type specifications
domain p dp domain pk dpk

domain p dp domain pk dp k
embedding one one mapping dp dpk dp dp k
k dpi f dp
clearly embedding type p size domain
p must least size domain p given embedding
expression actions propositions formulas action domain description
type specification mapped language one simply
replaces object differs uses
type specification notice objects domain type
replaced constants may occur effect axioms domain rules
definition action domain description belongs simple class mention
function positive arity mention complex fluents except complex fluent
definitions satisfies following conditions
p recond action precondition definition form
x p q w w fluent formula quantifiers
effect f effect f action effect axiom
quantifiers variables f among one
cannot something
effect explodeat x nearby x dead
causes f causes f domain rule quantifiers variables must f
theorem let simple action domain description action instance
let except type specification formula
mention complex fluent quantifiers embedding
type specification inita succa
init succ


fifrom causal theories strips systems

proof suppose init succ true truth assignment
language satisfies init succ construct truth
assignment language follows proposition p language
mention complex fluent p iff p p really
static proposition succ f init f f primitive fluent atom truth
values complex fluent atoms defined according definitions clearly
need satisfies inita succa inita
three cases
init f init defined f complex fluent definition
follows construction
init p recond precondition definition
assumption form x p q w w formula without
quantifiers without loss generality let us assume x p w formula
equivalent

w x
adp

dp domain type p x p w iff




w x

adp

iff




w x

adp

true since x p w
formulas inita mention complex fluents quantifiers
true corresponding ones true
succa suppose f primitive fluent atom pseudo successor state axiom f
constructed according procedure ccp given section follows
succ f init init n succ succ l
init f init init succ succ k
following properties
effect axiom effect f effect f property
quantifier variables f
domain rule form causes f causes f property
quantifier variables f
pseudo successor state axiom succ f f thus f
since f proves model succa thus theorem




filin

however examples belong simple
class two reasons action preconditions blocks world mention
complex fluents negative domain rules causes f may
variables f first principle complex fluents
replaced definitions second serious leads
type simple action theories
definition action domain description belongs simple ii class mention
function positive arity mention complex fluents except complex fluent
definitions satisfies following conditions
p recond action precondition definition form
x p q w w fluent formula quantifiers
effect f effect f action effect axiom
quantifiers variables f among
positive domain rules form causes f
causes f domain rule must form
formula mention fluents fluent atom notice
restriction variables
simple ii class action domain descriptions seem limited
positive domain rules negative domain rules allowed binary nevertheless
still capture many context free action domains instance blocks world
meet pass domains belong class blocks world notice
uses complex fluent clear action precondition definitions
p recond stack x ontable x clear x clear definitions reformulated
follows clears definition
p recond stack x
ontable x x block block x x
satisfy condition p recond definition simple ii
action domain descriptions verified formally seems
context free action domains mcdermotts pddl library action domains including
logistics domain belong simple ii class
theorem let simple ii action domain description action instance
let except type specification formula
mention complex fluent quantifiers embedding
type specification inita succa
init succ
proof suppose init succ true truth assignment
language satisfies init succ construct truth


fifrom causal theories strips systems

assignment language follows proposition p language
mention complex fluent p iff p p really
static proposition succ f init f f primitive fluent atom truth
values complex fluent atoms defined according definitions clearly
need satisfies inita succa inita
three cases
init f init defined f complex fluent definition
follows construction
init p recond precondition definition
assumption form x p q w w formula without
quantifiers without loss generality let us assume x p w
formula equivalent
w x w x n
x p w iff
w x w x n
iff
w x w x n
true since x p w
formulas inita mention complex fluents quantifiers
true corresponding ones true
succa suppose f primitive fluent atom since positive domain rule
form causes f pseudo successor state axiom f constructed according
procedure ccp given section must following form
succ f init init n
init f init init succ succ k
k causes f instance domain rule
effect axiom effect f effect f property
quantifier variables f pseudo successor
state axiom succ f must form
succ f init init n
init f init init
succ



succ k



succ

disjunction disjunct must causes f
instance fluent atom contains object f
two cases


filin

suppose succ f succ f since model succ
satisfies axiom succ f therefore satisfies following
formula
init init n
init f init init
succ succ k
since formula mention complex fluents quantifiers
satisfies corresponding formula
init init n



init f init init

succ



succ k

right side equivalence pseudo successor state axiom
succ f succa
suppose satisfies well satisfies right side
thus succ f succ f two cases
satisfies following formula
init init n



case since formula mention complex fluents
quantifier satisfies following corresponding formula
init init n



thus satisfies right side
satisfy satisfies following formula
init f init init succ succ k
thus satisfies following formula
init f init init
succ succ k
right side equivalence satisfied
need succ recall disjunction
disjunct must correspond domain rule form causes f
form g mention fluents g
fluent atom mentions object occur note
init init f axiom succ satisfied thus
init means init g false
false succ false since succ suppose
init g false notice since positive domain rules


fifrom causal theories strips systems

g object f pseudo successor state axiom
g succ must form succ g init g therefore
init g get succ since disjunct
proved succ therefore succ f thus succ f


related work
closely related work causal reasoning module wilkinss sipe
system wilkins wilkins writes page wilkins use strips
assumptions made operators unacceptably difficult describe previous classical
planners one primary reasons effects action must explicitly stated deductive causal theories one important mechanisms used
sipe alleviate operator representation caused strips assumption certainly one motivations system well sipe domain rules
triggers preconditions conditions effects informally triggers become
true situation sipe would check sequence see preconditions
true old situation conditions true situation
conditions true deduce effects instance sipe causal rule
x blocks world would look
causal rule
arguments x z
trigger x
precondition x z
effects x z
comparison domain rules much simpler instance corresponding rule
sipe rule simply causes x z x z need
procedural directives triggers large degree see system rational
reconstruction causal reasoning module sipe shown theorem
procedure used system sound translation causal theories
situation calculus wilkins gave translation causal rules formulas
situation calculus specify underlying logic reason formulas
fact shown lin translations would work
familiar pddl original version mcdermott aips
competition committee allows domain axioms stratified theories according
manual pddl mcdermott axioms logical formulas assert
relationships among propositions hold within situation format writing
axioms pddl follows
axiom
vars x
context w
implies p


filin

w formula p literal axioms treated directionally w p
following rule intention axioms according manual
rule action definitions allowed effects mention
predicates occur implies field axiom intention
action definitions mention primitive predicates changes
truth value derived predicates occur axioms without
axioms action definitions describe changes predicates
might affected action leads complex software engineering
domain engineering
clear quotation axioms pddl intended defining derived
predicates similar complex fluent definitions versions pddl
extended original version allowing actions durations continuous changes
considered axioms derive changes primitive predicates
done domain rules
action domain description language different syntax
strongly influenced prolog syntax shares much ideas behind action languages
gelfond lifschitz however unlike action languages provide facilities expressing truth value fluent atom particular situation initial
situation rather aimed specifying generic effects actions hand
facilities specifying types static relations importantly date action
languages implemented directly mapped nonmonotonic logic programming
system rather compilation monotonic system action effects given
explicitly done instance sat method would
implemented e g mccain turner action languages comparison
action domain description compiled strips description existing
systems blackbox selman kautz system r lin b directly
called

concluding remarks
described system generating effects actions direct action effect
axioms domain rules among things shown soundness procedure used system tested successfully many benchmark action domains used
current ai planners future work considering generalize simple
action theories section include context dependent action domain descriptions
monkey bananas domain

acknowledgments
extended abstract part appeared proceedings aaai would
thank anonymous reviewers jair aaai well associate
editor charge jair insightful comments earlier versions
work supported part grants council hong kong
competitive earmarked grant hkust e


fifrom causal theories strips systems

references
baral c reasoning actions nondeterministic effects constraints qualification proceedings fourteenth international joint conference artificial
intelligence ijcai ijcai inc distributed morgan kaufmann san mateo
ca pp
fikes r e nilsson n j strips theorem proving
solving artificial intelligence
fox long automatic inference state invariants tim journal
artificial intelligence
gelfond lifschitz v action languages electronic transactions artificial
intelligence http www ep liu se ea cis vol nr
gerevini schubert l inferring state constraints domain independent
proceedings th national conference artificial intelligence
aaai aaai press menlo park ca
levesque h reiter r lesperance lin f scherl r golog logic
programming language dynamic domains journal logic programming special
issue reasoning action change
lifschitz v logic causal explanation artificial intelligence
lin f embracing causality specifying indirect effects actions proceedings fourteenth international joint conference artificial intelligence
ijcai ijcai inc distributed morgan kaufmann san mateo ca pp

lin f embracing causality specifying indeterminate effects actions
proceedings th national conference artificial intelligence aaai
aaai press menlo park ca pp
lin f strongest necessary weakest sufficient conditions artificial intelligence
lin f b planner called r ai magazine
lin f reiter r forget greiner r subramanian eds
working notes aaai fall symposium relevance pp american association artificial intelligence menlo park ca available
http www cs toronto edu cogrobo forgetting ps z
lin f reiter r b state constraints revisited journal logic computation
special issue actions processes
mccain n turner h causal theory ramifications qualifications
proceedings fourteenth international joint conference artificial intelligence
ijcai ijcai inc distributed morgan kaufmann san mateo ca pp

mccain n turner h causal theories action change proceedings
th national conference artificial intelligence aaai aaai press
menlo park ca pp


filin

mccain n turner h satisfiability causal theories proceedings
sixth international conference principles knowledge representation
reasoning kr pp
mcdermott pddl domain definition language tech rep tr dcs tr yale center computational vision control
pednault e p adl exploring middle ground strips situation calculus proceedings first international conference principles
knowledge representation reasoning kr pp morgan kaufmann
publishers inc
reiter r frame situation calculus simple solution sometimes completeness goal regression lifschitz v ed artificial
intelligence mathematical theory computation papers honor john mccarthy pp academic press san diego ca
selman b kautz h unifying sat graph proceedings sixteenth international joint conference artificial intelligence ijcai
ijcai inc distributed morgan kaufmann san mateo ca pp
thielscher computing ramification post processing proceedings
fourteenth international joint conference artificial intelligence ijcai ijcai inc distributed morgan kaufmann san mateo ca pp
thielscher ramification causality artificial intelligence
wilkins practical extending classical ai paradigm morgan kaufmann san mateo ca
zhang foo n deriving invariants constraints action theories
fundamenta informaticae




