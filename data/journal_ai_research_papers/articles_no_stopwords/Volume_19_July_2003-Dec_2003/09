Journal Artificial Intelligence Research 19 (2003) 279-314

Submitted 09/02; published 10/03

Compiling Causal Theories Successor State Axioms
STRIPS-Like Systems
Fangzhen Lin

flin@cs.ust.hk

Department Computer Science
Hong Kong University Science Technology
Clear Water Bay, Kowloon, Hong Kong

Abstract
describe system specifying effects actions. Unlike commonly
used AI planning, system uses action description language allows one
specify effects actions using domain rules, state constraints
entail new action effects old ones. Declaratively, action domain language
corresponds nonmonotonic causal theory situation calculus. Procedurally,
action domain compiled set logical theories, one action domain,
fully instantiated successor state-like axioms STRIPS-like systems
generated. expect system useful tool knowledge engineers writing action
specifications classical AI planning systems, GOLOG systems, systems
formal specifications actions needed.

1. Introduction
describe system generating action effect specifications set domain rules
direct action effect axioms, among things. expect system useful
tool knowledge engineers writing action specifications classical AI planning systems,
GOLOG systems (Levesque et al., 1997), systems formal specifications
actions needed.
motivate, consider language used STRIPS (Fikes & Nilsson, 1971) describing effects actions. Briefly speaking, action described language
first-order formula, called precondition describes condition
action executable, add list enumerates propositions action make
true successfully executed situation, delete list enumerates propositions action make false successfully executed situation.
original STRIPS allowed precondition elements two lists complex
formulas, STRIPS actions refer whose precondition given conjunction atomic formulas whose add delete lists lists atomic formulas.
widely acknowledged language inadequate describing actions
real world. One limitations, one address paper,
language, one enumerate possible effects action, difficult impossible
task complex domains. example, given large C program, hard figure
effects changing value pointer values pointers program.
However, underlying principle simple: value pointer changes,
values pointers point memory location change well. Put
another way, direct effect action changing value pointer x
c
2003
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiLin

value pointer x. indirect side effects action derived
constraint says two pointers point common location,
values must same.
idea specifying effects actions using domain constraints engineering
first principle, many advantages. First all, constraints action independent, work actions. Secondly, effects actions derived domain
constraints agree ones expectation, good indication one
axiomatized domain correctly. Finally, domain constraints used purposes well. instance, used check consistency initial situation
database. general, set sentences violates domain constraint, know
legal situation satisfy set sentences. idea used planning
prune impossible states. Recently, even efforts reverse engineering
domain constraints STRIPS-like systems speed planners (e.g. Zhang & Foo,
1997; Gerevini & Schubert, 1998; Fox & Long, 1998, others).
appealing use domain constraints derive indirect effects actions,
making idea work formally turned challenge. problem commonly
known ramification problem, various proposals made solve it.
recently, however, proposals best theoretical interest
high computational complexity. situation since changed substantially due
use causality representing domain constraints (Lin, 1995, 1996; McCain & Turner,
1995, 1997; Thielscher, 1995, 1997; Baral, 1995; Lifschitz, 1997, others).
describe paper implemented system builds recent work causalitybased approaches ramification problem. Specifically, system takes input
action domain description actions described precondition axioms
direct effect axioms, domain constraints represented call domain rules.
system returns output complete action specification STRIPS-like format
set fully instantiated successor state axioms (Reiter, 1991).
paper organized follows. begin introducing action description language. propose procedure compile action domain specified language
complete set successor state axioms STRIPS-like description
extracted. show soundness procedure respect translation
action domain descriptions situation calculus causal theories Lin (1995). next
describe implementation procedure, present experimental results.
one see, one limitations system essentially propositional.
effect axioms domain rules variables, need fully instantiated
compilation process. partially overcome limitation, show results
allow one generalize propositional output first-order case certain classes
action domain descriptions. discuss related work, conclude paper
pointers future work.

2. Action Description Language
assume first-order language equality. shall call predicates whose extensions may changed actions fluents, whose extensions changed
actions static relations. call unary static relations types. fluent atoms
280

fiFrom Causal Theories STRIPS-Like Systems

mean atomic formulas formed fluents. equality atom one form u = v,
u v variables constants, inequality constraint one form
u 6= v. Actions represented functions, assumed functions
positive arities language.
action description language includes following components.
2.1 Type Definitions
type definition specified expressions following form:
Domain(p, {a1 , ..., }),
p type, a1 , ..., constants. intuitive meaning expression
domain (extension) type p set {a1 , ..., }. instance, blocks
world, may type called block, have, say, five blocks named numerically:
Domain(block, {1, 2, 3, 4, 5}). logistics domain, may type called loc
locations, have, say, 3 locations l1 , l2 , l3 : Domain(loc, {l1 , l2 , l3 }).
2.2 Primitive Fluent Definitions
Primitive fluents defined expressions following form:
Fluent(f (x1 , ..., xn ), p1 (x1 ) pn (xn ) e1 em ),
f n-ary fluent, pi , 1 n, type, ei , 1 m,
inequality constraint form xj 6= xk , 1 j < k n. intuitive meaning
expression f (x1 , ..., xn ) legal fluent atom second argument true.
instance, blocks world, given type definition Domain(block, {1, 2, 3}),
following fluent specification:
Fluent(on(x, y), block(x) block(y) x 6= y)
would generate following six legal fluent atoms:
on(1, 2), on(1, 3), on(2, 1), on(2, 3), on(3, 1), on(3, 2).
Clearly, exactly one fluent definition fluent.
2.3 Complex Fluent Definitions
Given set primitive fluents, one may want define new ones. instance,
blocks world, given primitive fluent on, define clear terms as:
(x)clear(x) (y)on(y, x).
specify complex fluents clear, first define fluent formulas follows:
t1 = t2 fluent formula, t1 t2 terms, i.e. either constant
domain type variable.
f (t1 , ..., tn ) fluent formula, t1 , ..., tn terms, f either n-ary
primitive fluent, complex fluent, static relation.
281

fiLin

0 fluent formula, , 0 , 0 , 0 , 0
fluent formulas.
fluent formula, x variable, p type, (x, p) (for x type p,
holds) (x, p) (for x type p, holds) fluent formulas. Notice
require types finite domains, quantifications really shorthands:
domain p {a1 , ..., }, (x, p) stands
(x/a1 ) (x/an ),
(x, p) stands
(x/a1 ) (x/an ).
complex fluent specified language pair expressions following
form:
Complex(f (x1 , ..., xn ), p1 (x1 ) pn (xn ) e1 em ),
Defined(f (x1 , ..., xn ), ),
pi ei primitive fluent definitions, fluent formula
mention complex fluents whose free variables among x1 , ..., xn .
first expression specifies syntax second semantics complex fluent.
instance, complex fluent clear blocks world specified as:
Complex(clear(x), block(x)),
Defined(clear(x), (y, block)on(y, x)).
mentioned above, quantifiers shorthands type must
finite domain. instance, given following specification:
Domain(block, {1, 2, 3}),
Fluent(on(x, y), block(x) block(y))
fluent definition clear expanded to:
Defined(clear(1), (on(1, 1) on(2, 1) on(3, 1))),
Defined(clear(2), (on(1, 2) on(2, 2) on(3, 2))),
Defined(clear(3), (on(1, 3) on(2, 3) on(3, 3))).
2.4 Static Relation Definitions
mentioned, static relation one changed action domain.
instance, robot navigation domain, may proposition connected(d, r1, r2)
meaning door connects rooms r1 r2. truth value proposition cannot
changed navigating robot rolls room room.
language, static relation defined expression following form:
Static(g(x1 , ..., xn ), p1 (x1 ) pn (xn ) e1 em ),
g n-ary predicate, pi ei primitive fluent definitions.
meaning expression similar fluent definition, exactly
one definition static relation.
282

fiFrom Causal Theories STRIPS-Like Systems

2.5 Domain Axioms
Domain axioms constraints static relations. instance, static proposition
connected(d, r1, r2), may want impose following constraint: connected(d, r1, r2)
connected(d, r2, r1). language, domain axioms specified expressions
form:
Axiom(),
fluent formula mention fluents, i.e. mentions static
relations equality. instance, constraint connected written as:
Axiom((d, door)(r1 , room)(r2 , room)connected(d, r1 , r2 )
connected(d, r2 , r1 )),
door room types.
2.6 Action Definitions
Actions defined expressions following form:
Action(a(x1 , ..., xn ), p1 (x1 ) pn (xn ) e1 em ),
n-ary action, pi ei primitive fluent definitions.
instance, blocks world, given type definition Domain(block, {1, 2, 3}),
following action specification:
Action(stack(x, y), block(x) block(y) x 6= y)
would generate following six action instances:
stack(1, 2), stack(1, 3), stack(2, 1), stack(2, 3), stack(3, 1), stack(3, 2).
exactly one action definition action.
2.7 Action Precondition Definitions
Action precondition definitions specified expressions following form:
P recond(a(x1 , ..., xn ), ),
n-ary action, fluent formula whose free variables among x1 , ..., xn .
exactly one precondition definition action. instance,
blocks world, may have:
P recond(stack(x, y), clear(x) clear(y) ontable(x)),
says action stack(x, y) executable situation, clear(x), clear(y),
ontable(x) must true it.
283

fiLin

2.8 Action Effect Specifications
Action effects specified expressions following form:
Effect(a(x1 , ..., xn ), , f (y1 , ..., yk )),
form:
Effect(a(x1 , ..., xn ), , f (y1 , ..., yk )),
fluent formula, f primitive fluent. intuitive meaning
expressions true initial situation, action a(x1 , ..., xn ) cause
f (y1 , ..., yk ) true (false). instance, blocks world, action stack(x, y) causes
x y:
Effect(stack(x, y), true, on(x, y)).
example context dependent effect, consider action drop(x) breaks object
fragile:
Effect(drop(x), f ragile(x), broken(x)).
Notice fluent formula action effect specifications variables x1 , ..., xn , y1 , ..., yk . Informally, variables supposed
universally quantified. precisely, expressions instantiated, one
substitute objects variables, provided resulting formulas well-formed.
instance, given action effect specification Effect(move(x), g(x1 ) q(x1 , x2 ), f (y)),
one instantiate to: Effect(move(a), g(b) q(b, c), f (d)), long move(a) legal
action (according action definition move) g(b), q(b, c), f (d) legal
fluent atoms (according fluent definitions g, q, f ).
2.9 Domain Rules
Domain rules specified expressions following form:
Causes(, f (x1 , ..., xn )),
following form:
Causes(, f (x1 , ..., xn )),
fluent formula, f primitive fluent. action effect specifications,
variables x1 , ..., xn . intuitive meaning domain rule
situation, holds, fluent atom f (x1 , ..., xn ) caused
true. domain rule stronger material implication. formal semantics given
mapping causal rule Lin (1995) (see Section 4), thus name causes.
instance, blocks world, block one block:
Causes(on(x, y) 6= z, on(x, z)).
logistics domain, one may want say package inside truck
location l, package location l well:
Causes(in(x, y) at(y, l), at(x, l)).
284

fiFrom Causal Theories STRIPS-Like Systems

2.10 Action Domain Descriptions
following definition sums action description language:
Definition 1 action domain description set type definitions, primitive fluent
definitions, complex fluent definitions, static proposition definitions, domain axioms, action
definitions, action precondition definitions, action effect specifications, domain rules.
Example 1 following action domain description defines blocks world three
blocks:
Domain(block, {1, 2, 3}),
Fluent(on(x, y), block(x) block(y)),
Fluent(ontable(x), block(x)),
Complex(clear(x), block(x)),
Defined(clear(x), (y, block)on(y, x)),
Causes(on(x, y) x 6= z, on(z, y)),
Causes(on(x, y) 6= z, on(x, z)),
Causes(on(x, y), ontable(x)),
Causes(ontable(x), on(x, y)),
Action(stack(x, y), block(x) block(y) x 6= y),
P recond(stack(x, y), ontable(x) clear(x) clear(y)),
Effect(stack(x, y), true, on(x, y)),
Action(unstack(x, y), block(x) block(y) x 6= y),
P recond(unstack(x, y), clear(x) on(x, y)),
Effect(unstack(x, y), true, ontable(x)),
Action(move(x, y, z), block(x) block(y) block(z) x 6= x 6= z 6= z),
P recond(move(x, y, z), on(x, y) clear(x) clear(z)),
Effect(move(x, y, z), true, on(x, z)).

3. Procedural Semantics
Given action domain description D, use following procedure called CCP (Causal
Completion Procedure) generate complete action effect specification:
1. Use primitive complex fluent definitions generate legal fluent atoms.
following let F set fluent atoms generated.
2. Use action definitions generate legal action instances, action
instance following.
285

fiLin

2.1. primitive fluent atom F F, collect ground instances1 positive
effects:
Effect(A, 1 , F ), , Effect(A, n , F ),
ground instances negative effects:
Effect(A, 1 , F ), , Effect(A, , F ),
ground instances positive domain rules:
Causes(01 , F ), , Causes(0k , F ),
ground instances negative domain rules:
Causes(01 , F ), , Causes(0l , F ),
generate following pseudo successor state axiom;
succ(F ) init(1 ) init(n ) succ(01 ) succ(0l )
init(F ) [init(1 ) init(m )
succ(01 ) succ(0k )],

(1)

fluent formula , init() formula obtained replacing every fluent atom f init(f ), similarly succ() formula
obtained replacing every fluent atom f succ(f ). Intuitively,
init(f ) means f true initial situation, succ(f ) f true
successor situation performing action initial situation.
2.2. Let Succ set pseudo successor state axioms, one primitive
fluent F , generated last step, Succ1 following set axioms:
Succ1 = {succ(F ) succ() | Defined(F, ) complex fluent definition},
Init following set axioms:
Init = { | Axiom() domain axiom}
{init() init(F ) | Causes(, F ) domain rule}
{init() init(F ) | Causes(, F ) domain rule}
{init(F ) init() | Defined(F, ) complex fluent definition}
{init(A ) | P recond(A, ) precondition definition A}.
fluent atom F , formula F
Init Succ Succ1 |= succ(F ) F ,
F mention propositions form succ(f ), output
axiom
succ(F ) F .
1. generating ground instances, shorthands (x, p) expanded. See definition fluent
formulas last section.

286

fiFrom Causal Theories STRIPS-Like Systems

Otherwise, action effect F indeterminate. case, output two
axioms:
succ(F ) F ,
F succ(F ),
F strongest formula satisfying first implication, F weakest
formula satisfying second implication. following, explicit
action computing effects, write axioms
SuccA , InitA , Succ1A .
Conceptually, Step 2.1 procedure significant. next section,
shall prove step provably correct translation situation calculus
causal theories Lin (1995). Computationally, Step 2.2 expensive. shall
describe strategies system uses implement Section 5.
procedure work properly, action domain description satisfy
following conditions.
1. require fluent atoms Init, Succ, Succ1 among generated
Step 1. would rule cases
Fluent(on(x, y), block(x) block(y) x 6= y)
together Defined(clear(x), (y, block)on(y, x)), latter would generate
fluent atoms form on(x, x) ruled fluent definition on.
one could either drop inequality constraint definition change
complex fluent definition Defined(clear(x), (y, block)(on(y, x) x 6= y)).
could built test procedure reject action domain
description incoherent fluent definitions this. One easy way making sure
happen use inequality constraints definition fluents.
2. mentioned above, action exactly one action precondition captures exactly conditions action executable.
action precondition given explicitly this, one needs careful
writing action effect axioms domain rules contradictory effects
would generated. instance, given P recond(A, true), action effect axioms
Effect(A, true, F ) Effect(A, true, F ) clearly realizable simultaneously.
Similarly, Causes(true, F ) given domain rule, one write
effect axiom Effect(A, true, F ). insisted always executable,
could simply conclude executable effect axioms contradiction effect axioms contradict domain rules. remains future
work extend procedure allow automatic generation implicitly
given action preconditions. now, shall assume given action domain
specification consistent sense action instance generated
Step 1, following theory
Init Succ Succ1 {init() succ(F ) |
Effect(A, , F ) ground instance effect axiom}
287

fiLin

consistent.
3. related point, procedure assumes information initial situation
given Init. particular, action effect axioms entail information initial situation. instance, given Causes(q, p), Effect(A, true, p),
P recond(A, true), must initial situation, q cannot true,
otherwise, persist next situation, causing p false, contradicts action effect. Formally, means given set atoms
form init(f ), f primitive fluent atom, Init consistent,
SuccSucc1 consistent, , complement I, following
set:
{init(f ) | init(f ) 6
f primitive fluent atom generated Step 1}
Notice similar reason, Reiter needed called consistency assumption order completion procedure sound complete generating
successor state axioms (Reiter, 1991).
action domain descriptions clearly targeted specifying deterministic actions,
indeterminate effects sometimes arise cyclic domain rules. instance,
consider following action domain description:
Causes(p, p),
P recond(A, true)
action A, Init tautology, Succ1 empty, Succ consists following pseudosuccessor state axiom p:
succ(p) succ(p) init(p),
equivalent init(p) succ(p). initially p true, performed,
know p continue true. p initially false, performed,
know p true not.
Example 2 Consider blocks world description Example 1. set fluent atoms
generated Step 1 is:
F = {on(1, 1), on(1, 2), on(1, 3), on(2, 1), on(2, 2), on(2, 3),
on(3, 1), on(3, 2), on(3, 3), clear(1), clear(2), clear(3),
ontable(1), ontable(2), ontable(3)}.
Step 2 generates following action instances:
stack(1, 2), stack(1, 3), stack(2, 1), stack(2, 3), stack(3, 1), stack(3, 2),
unstack(1, 2), unstack(1, 3), unstack(2, 1), unstack(2, 3), unstack(3, 1),
unstack(3, 2), move(1, 2, 3), move(1, 3, 2), move(2, 1, 3), move(2, 3, 1),
move(3, 1, 2), move(3, 2, 1)
288

fiFrom Causal Theories STRIPS-Like Systems

action instances, need go Steps 2.1 2.2. instance,
stack(1, 2), one effect axiom on(1, 2):
Effect(stack(1, 2), true, on(1, 2)),
following causal rules on(1, 2):
Causes(on(1, 1), on(1, 2)),
Causes(on(1, 3), on(1, 2)),
Causes(on(2, 2), on(1, 2)),
Causes(on(3, 2), on(1, 2)),
Causes(ontable(1), on(1, 2)).
Therefore Step 2.1 generates following pseudo-successor state axiom on(1, 2):
succ(on(1, 2)) true
init(on(1, 2)) [succ(on(1, 1)) succ(on(1, 3))
succ(on(2, 2)) succ(on(3, 2) succ(ontable(1))].
similarly generate following pseudo-successor state axioms primitive
fluent atoms:
succ(on(1, 1)) init(on(1, 1)) [succ(on(1, 2)) succ(on(1, 3))
succ(on(2, 1)) succ(on(3, 1) succ(ontable(1))],
succ(on(1, 3)) init(on(1, 3)) [succ(on(1, 1)) succ(on(1, 2))
succ(on(2, 3)) succ(on(3, 3)) succ(ontable(1))],
succ(on(2, 1)) init(on(2, 1)) [succ(on(1, 1)) succ(on(3, 1))
succ(on(2, 2)) succ(on(2, 3)) succ(ontable(2))],
succ(on(2, 2)) init(on(2, 2)) [succ(on(1, 2)) succ(on(1, 3))
succ(on(2, 1) succ(on(2, 3)) succ(ontable(2))],
succ(on(2, 3)) init(on(2, 3)) [succ(on(1, 3)) succ(on(3, 3))
succ(on(2, 1) succ(on(2, 2)) succ(ontable(2))],
succ(on(3, 1)) init(on(3, 1)) [succ(on(3, 2)) succ(on(3, 3))
succ(on(1, 1) succ(on(1, 3)) succ(ontable(1))],
succ(on(3, 2)) init(on(3, 2)) [succ(on(3, 1)) succ(on(3, 3))
succ(on(1, 2) succ(on(2, 2)) succ(ontable(2))],
succ(on(3, 3)) init(on(3, 3)) [succ(on(3, 1)) succ(on(3, 2))
succ(on(1, 3) succ(on(2, 3)) succ(ontable(3))],
succ(ontable(1))
init(ontable(1)) [succ(on(1, 2)) succ(on(1, 1)) succ(on(1, 3))],
succ(ontable(2))
init(ontable(2)) [succ(on(2, 1)) succ(on(2, 2)) succ(on(2, 3))],
289

fiLin

succ(ontable(3))
init(ontable(3)) [succ(on(3, 1)) succ(on(3, 2)) succ(on(3, 3))].
complex fluent clear, definition yields following axioms:
succ(clear(1)) succ(on(1, 1)) succ(on(2, 1)) succ(on(3, 1)),
succ(clear(2)) succ(on(1, 2)) succ(on(2, 2)) succ(on(3, 2)),
succ(clear(3)) succ(on(1, 3)) succ(on(2, 3)) succ(on(3, 3)).
solve pseudo-successor state axioms generate following successor state axioms:
succ(on(1, 1)) f alse
succ(on(1, 3)) f alse
succ(on(2, 2)) f alse
succ(on(3, 1)) f alse
succ(on(3, 3)) init(on(3, 3))
succ(ontable(2)) init(ontable(2))
succ(clear(1)) init(clear(1))
succ(clear(3)) init(clear(3))

succ(on(1, 2)) true
succ(on(2, 1)) f alse
succ(on(2, 3)) init(on(2, 3))
succ(on(3, 2)) f alse
succ(ontable(1)) f alse
succ(ontable(3)) init(ontable(3))
succ(clear(2)) f alse

set fully instantiated successor state axioms, generate
STRIPS-like descriptions following:
stack(1, 2)
Preconditions:
Add list:
Delete list:
Cond. effects:
Indet. effects:

ontable(1), clear(1), clear(2).
on(1, 2).
ontable(1), clear(2).
none.
none.

stack(1, 3)
Preconditions:
Add list:
Delete list:
Cond. effects:
Indet. effects:

ontable(1), clear(1), clear(3).
on(1,3).
ontable(1), clear(3).
none.
none.

290

fiFrom Causal Theories STRIPS-Like Systems

following remarks:
Although generate axiom succ(on(1, 3)) f alse stack(1, 2), put
on(1, 3) delete list. deduce init(on(1, 3)) f alse
Init well. fluent atom put add delete list action
fluent atoms truth value definitely changed action. See Section 5
details STRIPS-like description generated successor state
axioms.
one see, CCP procedure crucially depends fact type
finite domain reasoning done propositional logic.
limitation current system, limitation bad one might think.
First all, typical planning problems assume finite domains, changing
domain type action description easy - one needs change
corresponding type definition. significantly, generic action domain description
often obtained one assumes finite domain. blocks world
example, numbers 1, 2, 3 generic names, replaced
parameters. instance, replace 1 x 2 STRIPSlike description stack(1, 2), get STRIPS-like description stack(x, y)
works x y. found strategy often works
planning domains.

4. Formal Semantics
formal semantics action domain description defined translating
situation calculus causal theory Lin (1995). shall show procedure CCP given
sound semantics.
section mainly interested nonmonotonic action theories.
interested using action description language describing action
domains, section safely skipped.
first briefly review language situation calculus.
4.1 Situation Calculus
language situation calculus many sorted first-order language. assume
following sorts: situation situations, action actions, fluent propositional fluents,
truth-value truth values true f alse, object everything else.
use following domain independent predicates functions:
Binary function - action situation s, do(a, s) situation
resulting performing s.
Binary predicate H - p situation s, H(p, s) true p holds s.
Binary predicate P oss - action situation s, P oss(a, s) true
possible (executable) s.
Ternary predicate Caused - fluent atom p, truth value v, situation
s, Caused(p, v, s) true fluent atom p caused (by something unspecified)
truth value v situation s.
291

fiLin

last section, introduced fluent formulas. extend H formulas:
fluent formula situation s, H(, s) defined follows:
H(t1 = t2 , s) t1 = t2 .
P static proposition, H(P, s) P .
inductively, H(, s) H(, s), H( 0 , s) H(, s) H(0 , s), similarly
connectives.
inductively, H((x, p), s) x.[p(x) H(, s)] H((x, p), s) x.[p(x)
H(, s)].
According definition, H(, s) expanded situation calculus formula
H applied fluents.
4.2 Translation Situation Calculus
Given first-order language L writing action domain descriptions, assume
corresponding language L0 situation calculus constants L
constants sort object L0 , types L types (unary predicates) L0 ,
static relations predicates arities L0 , fluents L functions
sort f luent L0 , actions L functions sort action L0 .
conventions, following translation map action domain description situation
calculus theory.
Let action domain description. translation situation calculus
theory defined follows:
type definition Domain(p, {a1 , ..., ak }) translated to:
(x).p(x) (x = a1 x = ak ),
a1 6= a2 6= 6= ak .
primitive fluent definition
Fluent(f (x1 , ..., xn ), p1 (x1 ) pn (xn ) e1 em )
translated
(x1 , ..., xn ).Fluent(f (x1 , ..., xn )) p1 (x1 ) pn (xn ) e1 em .
complex fluent definition
Complex(f (x1 , ..., xn ), p1 (x1 ) pn (x) e1 em ),
Defined(f (x1 , ..., xn ), ),
translated
(x1 , ..., xn ).Fluent(f (x1 , ..., xn )) p1 (x1 ) pn (x) e1 em ,
(x1 , ..., xn , s).Fluent(f (x1 , ..., xn )) [H(f (x1 , ..., xn ), s) H(, s)].
292

fiFrom Causal Theories STRIPS-Like Systems

domain axiom static propositions:
Axiom()
translated quantifiers treated shorthands:
(x, p) = x.p(x) ,
(x, p) = x.p(x) .
action definition
Action(a(x1 , ..., xn ), p1 (x1 ) pn (xn ) e1 em )
translated
(x1 , ..., xn ).Action(a(x1 , ..., xn )) p1 (x1 ) pn (xn ) e1 em .
assume domain description one action definition
action.
action precondition axiom
P recond(a(x1 , ..., xn ), )
translated
~ s).Action(a(x1 , ..., xn )) [P oss(a(x1 , ..., xn ), s) H(, s)],
(,
~ list free variables a(x1 , ..., xn ) . mentioned earlier
one limitations current system action preconditions
given explicitly. reflected translation.
action effect axiom:
Effect(a(x1 , ..., xn ), , f (y1 , ..., yk )),
translated
~ s).Action(a(x1 , ..., xn )) Fluent(f (y1 , ..., yk )) P oss(a(x1 , ..., xn ), s)
(,
{H(, s) Caused(f (y1 , ..., yk ), true, do(a(x1 , ..., xn ), s))},
~ list free variables a(x1 , ..., xn ), f (y1 , ..., yk ), .
Similarly, effect axiom
Effect(a(x1 , ..., xn ), , f (y1 , ..., yk )),
translated
~ s).Action(a(x1 , ..., xn )) Fluent(f (y1 , ..., yk )) P oss(a(x1 , ..., xn ), s)
(,
{H(, s) Caused(f (y1 , ..., yk ), f alse, do(a(x1 , ..., xn ), s))}.
293

fiLin

domain rule form
Causes(, f (x1 , ..., xn ))
translated
~
().Fluent(f
(x1 , ..., xn )) (s){H(, s) Caused(f (x1 , ..., xn ), true, s)},
~ list free variables f (x1 , ..., xn ) . Similarly, domain rule
form
Causes(, f (x1 , ..., xn ))
translated
~
().Fluent(f
(x1 , ..., xn )) (s){H(, s) Caused(f (x1 , ..., xn ), f alse, s)}.
given action domain description D, let translation situation
calculus. semantics determined completion comp(T ) defined
set following sentences:
1. circumscription Caused predicates fixed.
2. following basic axioms Caused says fluent atom caused
true (false), true (false):
Caused(p, true, s) Holds(p, s),

(2)

Caused(p, f alse, s) Holds(p, s).

(3)

3. truth values, following unique names domain closure axiom:
true 6= f alse (v)(v = true v = f alse).

(4)

4. unique names assumptions fluents actions. Specifically, F1 ,..., Fn
fluents, have:
(~x) 6= Fj (~y ), j different,
(~x) = (~y ) ~x = ~y .
Similarly actions.
5. primitive fluent atom F , following generic successor state axiom:
a, s.P oss(a, s) H(F, do(a, s))

(5)

[Caused(F, true, do(a, s)) H(F, s) Caused(F, f alse, do(a, s))].
6. foundational axioms (Lin & Reiter, 1994b) discrete situation calculus.
axioms characterize structure space situations. purpose
paper, enough mention include following unique names
axioms situations:
6= do(a, s),
do(a, s) = do(a0 , s0 ) (a = a0 = s0 ).
294

fiFrom Causal Theories STRIPS-Like Systems

following theorem shows procedural semantics given previous section
sound respect semantics given here.
Theorem 1 Let action domain description, translation situation
calculus. Let ground action instance, situation variable, (s) situation
calculus formula satisfies following two conditions (1) contains two
situation terms do(A, s); (2) mention predicate H,
equality, static relations. Let obtained replacing H(f, s)
init(f ), H(f, do(A, s)) succ(f ).
comp(T ) |= s.P oss(A, s) (s)

(6)

Init Succ Succ1 |= ,

(7)


Init, Succ, Succ1 sets axioms generated according procedure Section 3
Proof: Suppose situation model comp(T ) {P oss(A, S)}. Construct
MS,A follows:
domain MS,A object domain .
interpretations non-situational function predicate symbols MS,A
.
fluent atom f , MS,A |= init(f ) iff |= H(f, S) MS,A |= succ(f ) iff
|= H(f, do(A, S)).
Clearly, |= (S) iff MS,A |= . show MS,A model left hand
side (7). this, see (7), (6).
Notice first ground fluent atom F generated procedure CCP iff Fluent(F )
true . Notice fluent atoms Init Succ Succ1 must generated
procedure.
show first MS,A model Init:
1. Axiom() domain axiom, . Thus satisfies . Since
fluent symbols it, MS,A satisfies too.
2. Causes(, f (x1 , ..., xn )) domain rule,
~
().Fluent(f
(x1 , ..., xn )) (s){H(, s) Caused(f (x1 , ..., xn ), true, s)}
. Thus satisfies
~
().Fluent(f
(x1 , ..., xn )) (s){H(, s) H(f (x1 , ..., xn ), s)}.
Thus init( 0 ) init(F ) corresponding formula Init, 0 F
ground instantiation f (x1 , ..., xn ), respectively, Fluent(F ) must
true (otherwise formula would Init), satisfies
H( 0 , S) H(F, S). construction MS,A , satisfies init( 0 ) init(F ).
case Causes(, f ) similar.
295

fiLin

3. Suppose Defined(F, ) instantiation complex fluent definition
F Init. Init, Fluent(F ) must true. Thus must satisfy
H(F, S) H(, S). construction MS,A , satisfies init(F ) init(, S).
4. Suppose P recond(A, ) precondition axiom A. Since satisfies P oss(A, S)
Action(A) (because one action instances generated procedure),
thus satisfies H(A , S). MS,A satisfies init(A ).
show MS,A model Succ, is, primitive fluent atom F
generated procedure Step 1, pseudo-successor state axiom (1) holds. Referring
notation axiom, need show satisfies following formula:
H(F, do(A, S)) H(1 , S) H(n , S)
H(01 , do(A, S)) H(0l , do(A, S))
H(F, S) [H(1 , S) H(m , S)
H(01 , do(A, S)) H(0k , do(A, S))].
First all, instantiating generic successor state axiom (5) S, get:
P oss(A, S) H(F, do(A, S))
[Caused(F, true, do(A, S)) H(F, S) Caused(F, f alse, do(A, S))].
Since model P oss(A, S),
H(F, do(A, S))

(8)

[Caused(F, true, do(A, S)) H(F, S) Caused(F, f alse, do(A, S))].
consider circumscription Caused predicates fixed. Notice
axioms Caused form W Caused(x, y, z), W formula
mention Caused. Therefore circumscription Caused equivalent
predicate completion Caused. Suppose F f (t), axioms
Caused(f (x), v, s) follows:
W1 Caused(f (x), v, s), , Wi Caused(f (x), v, s).
unique names axioms fluents, result predicate completion
Caused entail:
Caused(f (x), v, s) W1 Wi .
W1 ,...,Wi action effect axioms domain rules f . way
(1) generated, noting Action(A), Fluent(F ), P oss(A, S) true, one
see equivalence instantiated replacing x, true v,
s, get
Caused(F, true, do(A, S)) H(1 , S) H(n , S)
H(01 , do(A, S)) H(0l , do(A, S)).
296

fiFrom Causal Theories STRIPS-Like Systems

Similarly, following axiom Caused(F, f alse, do(A, S)):
Caused(F, f alse, do(A, S)) H(1 , S) H(m , S)
H(01 , do(A, S)) H(0k , do(A, S)).
two axioms (8), get:
H(F, do(A, S)) H(1 , S) H(n , S)
H(01 , do(A, S)) H(0l , do(A, S))
H(F, S) [H(1 , S) H(m , S)
H(01 , do(A, S)) H(0k , do(A, S))].
Since model Comp(T ), satisfies formula. construction
MS,A , satisfies pseudo-successor state axiom (1).
Finally, fact MS,A model Succ1 apparent.
2
general, (6) imply (7). several reasons:
mentioned procedure CCP, assume information
initial situation given Init.
procedure works actions one time. situation calculus theory
captures effects actions single theory. possible bad specification action causes entire theory become inconsistent. instance,
Causes(true, p), P recond(A, true), Effect(A, f alse, p), corresponding situation calculus theory inconsistent action A.
procedure, generate inconsistent theory A.

5. Implementation
Except Step 2.2, procedure CCP Section 3 straightforward implement.
section describes strategy system uses implementing Step 2.2. main
idea comes work Lin (2001a) strongest necessary weakest sufficient
conditions.
Given propositional theory , proposition q, set B propositions, formula
said sufficient condition q B consists propositions B
|= q. said weakest sufficient condition sufficient
condition 0 , |= 0 . Similarly, formula said necessary
condition q B consists propositions B |= q . said
strongest necessary condition necessary condition 0 ,
|= 0 .
easy see weakest sufficient condition strongest necessary condition unique logical equivalence background theory. shown (Lin,
2001a) two notions closely related, computed using technique
forgetting (Lin & Reiter, 1994a). particular, action theories, effective strategy first compute strongest necessary condition, add background theory,
297

fiLin

compute weakest sufficient condition new theory. strategy
justified following proposition Lin (2001a):
Proposition 1 Let theory, q proposition, B set propositions.
necessary condition q B , weakest sufficient condition q B
{}, weakest sufficient condition q B .
describe strategy implementing Step 2.2 procedure CCP.
following, given action instance A, Step 2.2, let Succ set pseudosuccessor state axioms primitive fluent atoms, Succ1 set pseudo-successor state
axioms complex fluent atoms, Init set initial situation axioms derived
action precondition axiom A, domain axioms, domain rules, complex fluent
definitions. following, succ-proposition one form succ(f ),
init-proposition one form init(f ).
1. Transform Init clausal form derive set unit clauses U nit.
2. Use U nit simplify axioms Succ resulting axiom it:
succ(f ) f ,

(9)

f mention succ-propositions, delete Succ, output
replace succ(f ) rest axioms f .
3. fluent atom f whose pseudo-successor state axiom (9) Succ, f
form init(f ) ... (a candidate frame axiom), check see succ(f )
derived Succ, U nit, init(f ) unit resolution. so, delete Succ,
output succ(f ) init(f ), replace succ(f ) Succ init(f ).
4. fluent atom f whose pseudo-successor state axiom (9) Succ, compute
strongest necessary condition f succ(f ) init-propositions
theory Init Succ, weakest sufficient condition f succ(f ) initpropositions theory {f } Init Succ. f tautology, delete
(9) Succ, output succ(f ) f , replace succ(f ) Succ f .
tautology, output succ(f ) f f f succ(f ), delete (9)
Succ. correctness step follows Proposition 1.
5. previous steps solve equations Succ, generate appropriate output
primitive fluent atoms. complex fluent atom F :
Defined(F, ),
every primitive fluent atom successor state axiom, following:
(a) primitive fluent atoms changed action, complex
fluent atom changed action either, output succ(F ) init(F );
(b) otherwise, output succ(F ) , obtained succ() replacing
every succ-proposition right side successor state axiom.
298

fiFrom Causal Theories STRIPS-Like Systems

Otherwise, primitive fluent atoms successor state
axiom, means action may indeterminate effect them,
action may indeterminate effect F well. Compute strongest necessary weakest sufficient conditions succ(F ) Init Succ Succ1
last step, output them.
6. step try generate STRIPS-like description action instance
based results Steps 4 5. fluent atom F , according one
following cases:
(a) successor state axiom succ(F ) true, put F add list unless
init(F ) entailed Init;
(b) successor state axiom succ(F ) f alse, put F delete list
unless init(F ) entailed Init;
(c) successor state axiom succ(F ) , true, f alse,
init(F ), put F conditional effect list output successor state
axiom.
(d) F successor state axiom, put list indeterminate
effects.
Clearly, F put lists, truth value affected A.
Steps 4 5 procedure bottleneck worst case, computing
strongest necessary condition proposition coNP-hard. However,
experience action context-free effect fluent atom F , successor
state axiom computed without going Step 4.
implemented procedure CCP using strategy SWI-Prolog 3.2.92 .
url system follows:
http://www.cs.ust.hk/~flin/ccp.html
Using system, encoded action description language many planning
domains come original release PDDL (McDermott, 1998), compiled
STRIPS-like specifications. encodings domains results returned
system included online appendix. following, illustrate
interesting features system using following two domains: blocks world
monkey bananas domain.
5.1 Blocks World
used blocks world running example. shall give alternative specification domain using following better known set actions: stack,
unstack, pickup, putdown. shall use domain show changing slightly
precondition one actions result different action specification.
2. SWI-Prolog developed Jan Wielemaker University Amsterdam

299

fiLin

begin description corresponds standard STRIPS encoding
domain.
Fluent(on(x, y), block(x) block(y)),
Fluent(ontable(x), block(x)),
Fluent(holding(x), block(x)),
Complex(clear(x), block(x),
Defined(clear(x), ((y, block)on(y, x)) holding(x)),
Complex(handempty, true),
Defined(handempty, (x, block)holding(x)),
Causes(on(x, y) x 6= z, on(z, y)),
Causes(on(x, y) 6= z, on(x, z)),
Causes(on(x, y), ontable(x)),
Causes(ontable(x), on(x, y)),
Causes(on(x, y), holding(x)),
Causes(on(x, y), holding(y)),
Causes(holding(x), ontable(x)),
Causes(holding(x), on(x, y)),
Causes(holding(x), on(y, x)),
Causes(holding(x) 6= x, holding(y)),
Action(stack(x, y), block(x) block(y) x 6= y),
P recond(stack(x, y), holding(x) clear(y)),
Effect(stack(x, y), true, on(x, y)),
Action(unstack(x, y), block(x) block(y) x 6= y),
P recond(unstack(x, y), clear(x) on(x, y) handempty),
Effect(unstack(x, y), true, holding(x)),
Action(putdown(x), block(x)),
P recond(putdown(x), holding(x)),
Effect(putdown(x), true, ontable(x)),
Action(pickup(x), block(x)),
P recond(pickup(x), handempty ontable(x) clear(x)),
Effect(pickup(x), true, holding(x)).
Notice compared description Example 1, two fluents, holding
handempty here. Thus domain rules them, definition
clear changed take account block held, considered
clear.
300

fiFrom Causal Theories STRIPS-Like Systems

assuming domain three blocks Domain(block, {1, 2, 3}), system
generate 19 fluent atoms, 18 action instances. action instance, returns
complete set successor state axioms STRIPS-like representation. total
computation time actions 835K inferences 0.5 seconds.3 pure STRIPS
domain, i.e. actions context free. type domains, mentioned earlier,
Step 4 implementation procedure needed, Step 5 easy.
results expected. instance, action pickup(1), STRIPS-like representation returned system looks following: track 1 track 2), STRIPSlike representation looks like:
pickup(1):
Preconditions: clear(1), handempty, ontable(1)
Add list: holding(1)
Delete list: ontable(1), clear(1), handempty
Conditional effects:
Indeterminate effects:
complete output given online appendix. let us consider happen
drop ontable(x) precondition pickup(x):
P recond(pickup(x), handempty clear(x)).
means long block clear, picked up. new precondition,
system returns following STRIPS-like representation action pickup(1);
pickup(1):
Preconditions: clear(1), handempty
Add list: holding(1)
Delete list: clear(1), handempty, on(1, 2), on(1, 3), ontable(1)
Conditional effects:
succ(clear(2))<-> - (init(on(2, 2))\/init(on(3, 2)))
succ(clear(3))<-> - (init(on(2, 3))\/init(on(3, 3)))
Indeterminate effects:
- negation, \/ disjunction. ADL-like description action
would something following:
pickup(x):
Preconditions: clear(x), handempty
Add list: holding(x),
clear(y) on(x,y)
Delete list: clear(x), handempty,
on(x,y) on(x,y)
ontable(x) ontable(x)
3. times paper refer CPU times Pentium III 1GHz machine 512MB RAM running
SWI-Prolog 3.2.9 Linux. number inferences one reported SWI-Prolog,
roughly corresponds number resolution steps carried Prolog interpreter,
machine independent.

301

fiLin

5.2 Monkey Bananas Domain
domain adapted McDermotts PDDL library planning domains,
attributes University Washingtons UCPOP collection action domains,
turn attributes Prodigy. action effects generated system
context-dependent, context-free systems. shall elaborate
difference later.
domain, two types, loc locations (we assume three locations
here), object things monkey, banana, box, etc.:
Domain(loc, {1, 2, 3}),
Domain(object, {monkey, box, banana, knif e, glass, f ountain}).
following fluent definitions:
Fluent(onF loor),
Fluent(at(M, X), object(M ) loc(X)),
Fluent(hasknif e),
Fluent(onbox(X), loc(X)),
Fluent(hasbanana),
Fluent(haswater),
Fluent(hasglass).
following domain rules fluents:
Causes(onbox(X), at(monkey, X)),

(10)

Causes(onbox(X), at(box, X)),

(11)

Causes(onbox(X), onF loor),

(12)

Causes(onF loor, onbox(X)),

(13)

Causes(at(M, X) X 6= Y, at(M, )),

(14)

Causes(hasglass at(monkey, X), at(glass, X)),

(15)

Causes(hasknif e at(monkey, X), at(knif e, X)),

(16)

Causes(hasbanana at(monkey, X), at(banana, X)).

(17)

following action definitions along respective preconditions effect
axioms:
goto(x, y) - monkey goes x y:
Action(goto(X, ), loc(X) loc(Y ) X 6= ),
P recond(goto(X, ), at(monkey, ) onF loor),
Effect(goto(X, ), true, at(monkey, X)).
302

fiFrom Causal Theories STRIPS-Like Systems

climb(X) - monkey climbs onto box location X:
Action(climb(X), loc(X)),
P recond(climb(X), at(box, X) onF loor at(monkey, X)),
Effect(climb(X), true, onbox(X)).
pushbox(X, ) - monkey pushes box X.
Action(pushbox(X, ), loc(X) loc(Y ) X 6= ),
P recond(pushbox(X, ), at(monkey, ) at(box, )) onF loor),
Effect(pushbox(X, ), true, at(monkey, X)),
Effect(pushbox(X, ), true, at(box, X)).
getknif e(X) - get knife location X.
Action(getknif e(X), loc(X)),
P recond(getknif e(X), at(knif e, X) at(monkey, X) hasknif e),
Effect(getknif e(X), true, hasknif e).
getbanana(X) - grab banana loc X, provided monkey box.
Action(getbanana(X), loc(X)),
P recond(getbanana(X), onbox(X) at(banana, X) hasbanana),
Effect(getbanana(X), true, hasbanana).
pickglass(X) - pick glass loc X.
Action(pickglass(X), loc(X)),
P recond(pickglass(X), at(glass, X) at(monkey, X) hasglass),
Effect(pickglass(X), true, hasglass).
getwater(X) - get water fountain loc X, provided monkey box,
glass hand.
Action(getwater(X), loc(X)),
P recond(getwater(X), at(f ountain, X) onbox(X) hasglass haswater),
Effect(getwater(X), true, haswater).
domain 27 actions 26 fluent atoms. Again, action, system
generates complete set fully instantiated successor state axioms STRIPSlike representation. instance, action goto(1, 2), following STRIPS-like
representation generated system:
303

fiLin

Action goto(1, 2)
Preconditions: at(monkey, 2), onFloor
Add list: at(monkey, 1)
Delete list: at(monkey, 2)
Conditional effects:
succ(at(banana, 1)) <-> init(hasbanana) \/ init(at(banana, 1))
succ(at(knife, 1)) <-> init(hasknife) \/ init(at(knife, 1))
succ(at(glass, 1)) <-> init(hasglass) \/ init(at(glass, 1))
succ(at(banana, 2)) <-> - init(hasbanana) & init(at(banana, 2))
succ(at(knife, 2)) <-> - init(hasknife) & init(at(knife, 2))
succ(at(glass, 2)) <-> - init(hasglass) & init(at(glass, 2))
total running time actions 8 seconds performing 20 million inferences.
90 percent time spent Step 4, i.e. computing strongest necessary
weakest sufficient conditions fluent atoms given action contextdependent effects. instance, action goto(1, 2) above, majority time spent
generating 6 conditional effects.
action, actually actions domain, could use ADL-like
description (Pednault, 1989) conditional effects:
Add list: at(banana,1) hasbanana
at(knife,1) hasknife
at(glass,1) hasglass
Delete list: at(banana,2) hasbanana
at(knife,2) hasknife
at(glass,2) hasglass
However, clear whether always done general case.
mentioned earlier specifications domain given McDermotts collection well others context-free. instance, following specification
action goto PDDL McDermotts collection:
(:action GO-TO
:parameters (?x ?y)
:precondition (and (location ?x) (location ?y)
(not (= ?y ?x)) (on-floor) (at monkey ?y))
:effect (and (at monkey ?x) (not (at monkey ?y))))
corresponds context-free action change fluent except at.
clear design action take account domain rules (15) - (17).
specification, initially banana location 1, goal banana
location 2 would achievable.
304

fiFrom Causal Theories STRIPS-Like Systems

5.3 Summary
domains experimented including scheduling domain includes
Pednaults dictionary paycheck domain special case, rocket domain, SRI
robot domain, machine shop assembling domain, ferry domain, grid domain,
sokoban domain, gear domain. included online appendix.
summarize common features domains:
domains tried, quite straightforward decide effects
action encoded direct effects (those given predicate Effect)
effects indirect effects (those derived domain rules).
common domain rules functional dependency constraints. instance,
blocks world, fluent atom on(x, y) functional arguments;
monkey banana domain, fluent atom at(object, loc) functional
second argument (each object one location). makes sense
would special shorthand domain rules, perhaps special
procedure handling well. significantly, given prevalence
functional dependency constraints action domains, worthwhile
investigate possibility general purpose planner making good use
constraints.
mentioned earlier, system propositional. generated successor state
axioms STRIPS-like systems fully instantiated. However, often easy
user generalize propositional specifications first-order ones.
shall investigate generality observation next.

6. Generalizing Propositional STRIPS-Like Systems Ones
Parameters
mentioned, many action domain descriptions, successor state axioms
STRIPS-like systems generated specific domain generalized arbitrary ones.
precisely, let domain description,
Domain(p1 , Dp1 ), , Domain(pk , Dpk )
type specification. Suppose action InitA SuccA |= .
suppose D0 another domain description except different
type specification:
Domain(p1 , Dp0 1 ), , Domain(pk , Dp0 k ).
question interested this: given one-to-one mapping type
specification D0 , InitA0 SuccA0 |= 0 true D0 ? A0 (resp. 0 )
result replacing objects (resp. ) according mapping.
instance, true blocks world, generalize results
domain description Example 1 follows. shown, action stack(1, 2),
succ(on(1, 2)) succ(on(1, 3)) true. change type specification
Domain(block, {a, b, c, d, e}), map 1 a, 2 c, 3 e, new domain
305

fiLin

specification, action stack(a, c), succ(on(a, c)) succ(on(a, e))
true. Furthermore, changing mapping 3, see x different
c (the mapping needs one-to-one), succ(on(a, x)) true.
Obviously, expected blocks world. proceed show
general classes domain descriptions, well. first make precise
mapping one type specification another.
Definition 2 Given two type specifications O:
Domain(p1 , Dp1 ), , Domain(pk , Dpk ),
O0 :
Domain(p1 , Dp0 1 ), , Domain(pk , Dp0 k ),
embedding O0 one-to-one mapping Dp1 Dpk Dp0 1 Dp0 k
1 k, Dpi , f (a) Dp0 .
Clearly, embedding O0 , type p, size domain
p O0 must least size domain p O. Given embedding
, expression (actions, propositions, formulas) action domain description
type specification mapped () language D0 : one simply
replaces object (a), D0 differs uses O0
type specification. Notice objects (those domain type)
replaced, constants may occur effect axioms domain rules.
Definition 3 action domain description belongs simple-I class mention
function positive arity, mention complex fluents except complex fluent
definitions, satisfies following conditions:
1. P recond(A, ) action precondition definition, form
(x, p)...(y, q)W , W fluent formula quantifiers.
2. Effect(A, , F ) Effect(A, , F ) action effect axiom,
quantifiers, variables F among A. is, one
cannot something
Effect(explodeAt(x), nearby(y, x), dead(y)).
3. Causes(, F ) Causes(, F ) domain rule, quantifiers, variables must F .
Theorem 2 Let simple-I action domain description, action instance
D. Let D0 except type specification. formula
mention complex fluent quantifiers, embedding
type specification D0 , InitA SuccA |= D.
Init (A) Succ (A) |= () D0 .
306

fiFrom Causal Theories STRIPS-Like Systems

Proof: Suppose Init (A) Succ (A) |= () true, M1 truth assignment
language D0 satisfies Init (A) Succ (A) (). construct truth
assignment M2 language follows: proposition P language
mention complex fluent, M2 |= P iff M1 |= (P ) (P really either
static proposition, succ(F ),or init(F ), F primitive fluent atom). truth
values complex fluent atoms M2 defined according definitions. Clearly,
M2 |= . need show M2 satisfies InitA SuccA . InitA ,
three cases:
1. M2 |= init(F ) init() Defined(F, ) complex fluent definition.
follows construction M2 .
2. M2 |= init(A ) P recond(A, ) precondition definition A.
assumption, form (x, p)...(y, q).W , W formula without
quantifiers. Without loss generality, let us assume (x, p)W . formula
equivalent
_
W (x/a)
aDp

D, Dp domain type p D. M2 |= (x, p)W iff
M2 |=

_

W (x/a)

aDp

iff
M1 |=

_

W (x/ (a)),

aDp

true since M1 |= (x, p)W .
3. formulas InitA mention complex fluents quantifiers.
true M2 corresponding ones true M1 .
SuccA , suppose F primitive fluent atom, pseudo-successor state axiom F
constructed according procedure CCP given Section 3 follows:
succ(F ) init(1 ) init(n ) succ(01 ) succ(0l )
init(F ) [init(1 ) init(m ) succ(01 ) succ(0k )].
following properties D:
effect axiom Effect(A, , F ) Effect(A, , F ) property
quantifier, variables F ;
domain rule form Causes(, F ) Causes(, F ) property
quantifier, variables F ;
pseudo-successor state axiom (succ(F )) D0 (F ). Thus M2 |= F
since M1 |= (F ). proves M2 model SuccA , thus theorem.
2

307

fiLin

However, examples paper belong simple-I
class, two reasons: action preconditions, blocks world, mention
complex fluents; negative domain rules Causes(, F ) may
variables F . first problem problem principle complex fluents
replaced definitions. second problem serious, leads
new type simple action theories.
Definition 4 action domain description belongs simple-II class mention
function positive arity, mention complex fluents except complex fluent
definitions, satisfies following conditions:
1. P recond(A, ) action precondition definition, form
(x, p)...(y, q)W , W fluent formula quantifiers.
2. Effect(A, , F ) Effect(A, , F ) action effect axiom,
quantifiers, variables F among A.
3. positive domain rules form Causes(, F ).
4. Causes(, F ) domain rule, must form 1 2 , 1
formula mention fluents 2 fluent atom. Notice
restriction variables 2 .
Simple-II class action domain descriptions seem limited
positive domain rules, negative domain rules allowed binary. Nevertheless,
still capture many context-free action domains. instance, blocks world
meet-and-pass domains paper belong class: blocks world, notice
uses complex fluent clear action precondition definitions,
P recond(stack(x, y), ontable(x) clear(x) clear(y)), definitions reformulated
follows using clears definition:
P recond(stack(x, y),
ontable(x) (x1 , block)(y1 , block)(on(x1 , x) on(y1 , y))).
satisfy condition P recond definition simple-II
action domain descriptions. verified formally, seems
context-free action domains McDermotts PDDL library action domains, including
logistics domain, belong simple-II class.
Theorem 3 Let simple-II action domain description, action instance
D. Let D0 except type specification. formula
mention complex fluent quantifiers, embedding
type specification D0 , InitA SuccA |=
Init (A) Succ (A) |= () D0 .
Proof: Suppose Init (A) Succ (A) |= () true, M1 truth assignment
language D0 satisfies Init (A) Succ (A) (). construct truth
308

fiFrom Causal Theories STRIPS-Like Systems

assignment M2 language follows: proposition P language
mention complex fluent, M2 |= P iff M1 |= (P ) (P really either
static proposition, succ(F ),or init(F ), F primitive fluent atom). truth
values complex fluent atoms M2 defined according definitions. Clearly,
M2 |= . need show M2 satisfies InitA SuccA . InitA ,
three cases:
1. M2 |= init(F ) init() Defined(F, ) complex fluent definition.
follows construction M2 .
2. M2 |= init(A ) P recond(A, ) precondition definition A.
assumption, form (x, p)...(y, q).W , W formula without
quantifiers. Without loss generality, let us assume (x, p1 )W .
formula equivalent
W (x/a11 ) W (x/a1n1 )
D. M2 |= (x, p1 )W iff
M2 |= W (x/a11 ) W (x/a1n1 )
iff
M1 |= W (x/ (a11 )) W (x/ (a1n1 )),
true since M1 |= (x, p1 )W .
3. formulas InitA mention complex fluents quantifiers.
true M2 corresponding ones true M1 .
SuccA , suppose F primitive fluent atom. Since positive domain rule
form Causes(, F ), pseudo-successor state axiom F constructed according
procedure CCP given Section 3 must following form:
succ(F ) init(1 ) init(n )
init(F ) [init(1 ) init(m ) succ(01 ) succ(0k )],
1 k, Causes(0i , F ) instance domain rule D.
D0 , effect axiom Effect(, F ) Effect(, F ) property
quantifier, variables F , pseudo-successor
state axiom (succ(F )) D0 must form:
succ( (F )) init( (1 )) init( (n ))
init( (F )) [init( (1 )) init( (m ))
succ( (01 ))



succ( (0k ))

(18)

succ()],

disjunction disjunct must Causes(, (F ))
instance D0 fluent atom contains object (A) (F ).
two cases:
309

fiLin

Suppose M2 |= succ(F ). M1 |= succ( (F )). Since M1 model Succ (A) ,
M1 satisfies axiom succ( (F )). Therefore M1 satisfies following
formula:
init( (1 )) init( (n ))
init( (F )) [init( (1 )) init( (m ))
succ( (01 )) succ( (0k ))].
Since formula mention complex fluents quantifiers,
M2 satisfies corresponding formula:
init(1 ) init(n )

(19)

init(F ) [init(1 ) init(m )

succ(01 )



succ(0k )],

right side equivalence pseudo-successor state axiom
succ(F ) SuccA .
suppose M2 satisfies (19). Well show M1 satisfies right side (18),
thus M1 |= succ( (F )) M2 |= succ(F ). two cases:
M2 satisfies following formula:
init(1 ) init(n ).

(20)

case, since formula mention complex fluents
quantifier, M1 satisfies following corresponding formula:
init( (1 )) init( (n )).

(21)

Thus M1 satisfies right side (18).
M2 satisfy (20) satisfies following formula:
init(F ) [init(1 ) init(m ) succ(01 ) succ(0k )].
Thus M1 satisfies following formula:
init( (F )) [init( (1 )) init( (m ))
succ( (01 )) succ( (0k ))].
show right side equivalence (18) satisfied M1 ,
need show M1 |= succ(). Recall disjunction
disjunct must correspond domain rule form Causes(, (F )),
form 1 G 1 mention fluents, G
fluent atom mentions object occur (A). Note
init() init( (F )) axiom Succ (A) , satisfied M1 . Thus
M1 |= init(). means either 1 init(G) false M1 . 1
false, succ() false since succ(1 ) 1 . Suppose
init(G) false M1 . Notice since positive domain rules,
310

fiFrom Causal Theories STRIPS-Like Systems

G object (A) (F ), pseudo-successor state axiom
G Succ (A) must form succ(G) init(G) . Therefore
M1 |= init(G) get M1 |= succ(). Since disjunct ,
proved M1 |= succ(). Therefore M1 |= succ( (F )). Thus M2 |= succ(F ).
2

7. Related Work
planning, closely related work causal reasoning module Wilkinss SIPE
system (Wilkins, 1988). Wilkins writes (page 85, Wilkins, 1988): Use STRIPS
assumptions made operators unacceptably difficult describe previous classical
planners... One primary reasons effects action must explicitly stated... Deductive causal theories one important mechanisms used
SIPE alleviate problems operator representation caused STRIPS assumption. certainly one motivations system well. SIPE, domain rules
triggers, preconditions, conditions, effects. Informally, triggers become
true new situation, SIPE would check sequence see preconditions
true old situation, conditions true new situation.
conditions true, deduce effects. instance, SIPE causal rule
on(x, y) blocks world would look like:
Causal-rule: Not-on
Arguments: x, y, z;
Trigger: on(x,y);
Precondition: on(x,z);
Effects: on(x,z);
comparison, domain rules much simpler. instance, corresponding rule
SIPE rule simply: Causes(on(x, y) 6= z, on(x, z)). need
procedural directives triggers. large degree, see system rational
reconstruction causal reasoning module SIPE. shown Theorem 1,
procedure used system sound translation causal theories
situation calculus. Wilkins gave translation causal rules formulas
situation calculus, specify underlying logic reason formulas.
fact, shown Lin (1995), translations would work.
familiar PDDL, original version McDermott AIPS-98
Planning Competition Committee allows domain axioms stratified theories. According
manual PDDL 1.2 (McDermott, 1998), axioms logical formulas assert
relationships among propositions hold within situation. format writing
axioms PDDL follows:
(:axiom
:vars (?x ?y ...)
:context W
:implies P)
311

fiLin

W formula P literal. Axioms treated directionally, W P .
following rule intention using axioms according manual:
rule action definitions allowed effects mention
predicates occur :implies field axiom. intention
action definitions mention primitive predicates on, changes
truth value derived predicates occur axioms. Without
axioms, action definitions describe changes predicates
might affected action, leads complex software engineering
(or domain engineering) problem.
clear quotation axioms PDDL intended defining derived
predicates. similar complex fluent definitions. New versions PDDL
extended original version allowing actions durations continuous changes.
considered using axioms derive changes primitive predicates
done domain rules.
action domain description language, different syntax
strongly influenced Prolog syntax, shares much ideas behind action languages
(Gelfond & Lifschitz, 1999). However, unlike action languages, provide facilities expressing truth value fluent atom particular situation initial
situation. Rather, aimed specifying generic effects actions. hand,
facilities specifying types static relations. importantly, date, action
languages either implemented directly mapped nonmonotonic logic programming
system rather compilation monotonic system action effects given
explicitly, done here. instance, new SAT-based planning method would
implemented (e.g. McCain & Turner, 1998) action languages. comparison,
action domain description compiled STRIPS-like description, existing planning
systems Blackbox (Selman & Kautz, 1999) System R (Lin, 2001b) directly
called.

8. Concluding Remarks
described system generating effects actions direct action effect
axioms domain rules, among things. shown soundness procedure used system tested successfully many benchmark action domains used
current AI planners. future work, considering generalize simple
action theories Section 6 include context-dependent action domain descriptions
monkey bananas domain.

Acknowledgments
extended abstract part paper appeared Proceedings AAAI-2000. would
thank anonymous reviewers JAIR AAAI2000 well associate
editor charge paper JAIR insightful comments earlier versions
paper. work supported part Research Grants Council Hong Kong
Competitive Earmarked Research Grant HKUST6061/00E.
312

fiFrom Causal Theories STRIPS-Like Systems

References
Baral, C. (1995). Reasoning actions: nondeterministic effects, constraints, qualification. Proceedings Fourteenth International Joint Conference Artificial
Intelligence (IJCAI95), IJCAI Inc. Distributed Morgan Kaufmann, San Mateo,
CA., pp. 20172023.
Fikes, R. E., & Nilsson, N. J. (1971). STRIPS: new approach theorem proving
problem solving. Artificial Intelligence, 2, 189208.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificial Intelligence Research, 9, 367421.
Gelfond, M., & Lifschitz, V. (1999). Action languages. Electronic Transactions Artificial
Intelligence, http://www.ep.liu.se/ea/cis, Vol 3, nr 016.
Gerevini, A., & Schubert, L. (1998). Inferring state constraints domain-independent
planning. Proceedings 15th National Conference Artificial Intelligence
(AAAI98), AAAI Press, Menlo Park, CA.
Levesque, H., Reiter, R., Lesperance, Y., Lin, F., & Scherl, R. (1997). GOLOG: logic
programming language dynamic domains. Journal Logic Programming, Special
issue Reasoning Action Change, 31, 5984.
Lifschitz, V. (1997). logic causal explanation. Artificial Intelligence, 96, 451465.
Lin, F. (1995). Embracing causality specifying indirect effects actions. Proceedings Fourteenth International Joint Conference Artificial Intelligence
(IJCAI95), IJCAI Inc. Distributed Morgan Kaufmann, San Mateo, CA., pp. 1985
1993.
Lin, F. (1996). Embracing causality specifying indeterminate effects actions.
Proceedings 13th National Conference Artificial Intelligence (AAAI96),
AAAI Press, Menlo Park, CA., pp. 670676.
Lin, F. (2001a). strongest necessary weakest sufficient conditions. Artificial Intelligence, 128(1-2), 143159.
Lin, F. (2001b). planner called R. AI Magazine, 22(3), 7376.
Lin, F., & Reiter, R. (1994a). Forget it!. Greiner, R., & Subramanian, D. (Eds.),
Working Notes AAAI Fall Symposium Relevance, pp. 154159. American Association Artificial Intelligence, Menlo Park, CA. available
http://www.cs.toronto.edu/cogrobo/forgetting.ps.Z.
Lin, F., & Reiter, R. (1994b). State constraints revisited. Journal Logic Computation,
Special Issue Actions Processes, 4(5), 655678.
McCain, N., & Turner, H. (1995). causal theory ramifications qualifications.
Proceedings Fourteenth International Joint Conference Artificial Intelligence
(IJCAI95), IJCAI Inc. Distributed Morgan Kaufmann, San Mateo, CA., pp. 1978
1984.
McCain, N., & Turner, H. (1997). Causal theories action change. Proceedings
14th National Conference Artificial Intelligence (AAAI97), AAAI Press,
Menlo Park, CA., pp. 460465.
313

fiLin

McCain, N., & Turner, H. (1998). Satisfiability planning causal theories. Proceedings
Sixth International Conference Principles Knowledge Representation
Reasoning (KR98), pp. 212221.
McDermott, D. (1998). PDDL planning domain definition language. Tech. rep. TR98-003/DCS TR-1165, Yale Center Computational Vision Control.
Pednault, E. P. (1989). ADL: Exploring middle ground STRIPS situation calculus. Proceedings First International Conference Principles
Knowledge Representation Reasoning (KR89), pp. 324332. Morgan Kaufmann
Publishers, Inc.
Reiter, R. (1991). frame problem situation calculus: simple solution (sometimes) completeness result goal regression. Lifschitz, V. (Ed.), Artificial
Intelligence Mathematical Theory Computation: Papers Honor John McCarthy, pp. 418420. Academic Press, San Diego, CA.
Selman, B., & Kautz, H. (1999). Unifying SAT-based graph-based planning. Proceedings Sixteenth International Joint Conference Artificial Intelligence (IJCAI
99), IJCAI Inc. Distributed Morgan Kaufmann, San Mateo, CA., pp. 318325.
Thielscher, M. (1995). Computing ramification post-processing. Proceedings
Fourteenth International Joint Conference Artificial Intelligence (IJCAI95), IJCAI Inc. Distributed Morgan Kaufmann, San Mateo, CA., pp. 19942000.
Thielscher, M. (1997). Ramification causality. Artificial Intelligence, 89, 317364.
Wilkins, D. (1988). Practical planning: extending classical AI planning paradigm. Morgan Kaufmann, San Mateo, CA.
Zhang, Y., & Foo, N. (1997). Deriving invariants constraints action theories.
Fundamenta Informaticae, 30(1), 109123.

314


