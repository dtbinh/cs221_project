Journal Artificial Intelligence Research 19 (2003) 25-71

Submitted 10/02; published 08/03

Answer Set Planning Action Costs
Thomas Eiter
Wolfgang Faber

EITER @ KR . TUWIEN . AC .
FABER @ KR . TUWIEN . AC .

Institut fur Informationssysteme, TU Wien
Favoritenstr. 9-11, A-1040 Wien, Austria

Nicola Leone

LEONE @ UNICAL .

Department Mathematics, University Calabria
I-87030 Rende (CS), Italy

Gerald Pfeifer
Axel Polleres

PFEIFER @ DBAI . TUWIEN . AC .
POLLERES @ KR . TUWIEN . AC .

Institut fur Informationssysteme, TU Wien
Favoritenstr. 9-11, A-1040 Wien, Austria

Abstract
Recently, planning based answer set programming proposed approach towards realizing declarative planning systems. paper, present language K c ,
extends declarative planning language K action costs. K c provides notion admissible optimal plans, plans whose overall action costs within given limit resp.
minimum plans (i.e., cheapest plans). demonstrate, novel language allows
expressing nontrivial planning tasks declarative way. Furthermore, utilized
representing planning problems optimality criteria, computing shortest plans
(with least number steps), refinement combinations cheapest fastest plans.
study complexity aspects language K c provide transformation logic programs,
planning problems solved via answer set programming. Furthermore, report experimental results selected problems. experience encouraging answer set planning may
valuable approach expressive planning systems intricate planning problems
naturally specified solved.

1. Introduction
Recently, several declarative planning languages formalisms introduced, allow
intuitive encoding complex planning problems involving ramifications, incomplete information, non-deterministic action effects, parallel actions (see e.g., Giunchiglia & Lifschitz, 1998;
Lifschitz, 1999b; Lifschitz & Turner, 1999; McCain & Turner, 1998; Giunchiglia, 2000; Cimatti &
Roveri, 2000; Eiter et al., 2000b, 2003b).
systems designed generate plans accomplish planning goals,
practice one often interested particular plans optimal respect objective
function quality (or cost) plan measured. common simple objective
function length plan, i.e., number time steps achieve goal. Many systems
tailored compute shortest plans. example, CMBP (Cimatti & Roveri, 2000) GPT
(Bonet & Geffner, 2000) compute shortest plans step consists single action,
Graphplan algorithm (Blum & Furst, 1997) descendants (Smith & Weld, 1998; Weld,
c
2003
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Anderson, & Smith, 1998) compute shortest plans step actions might executed
parallel.
However, other, equally important objective functions consider. particular,
executing actions causes cost, may desire plan minimizes overall cost
actions.
answer set planning (Subrahmanian & Zaniolo, 1995; Dimopoulos, Nebel, & Koehler, 1997;
Niemela, 1998; Lifschitz, 1999b), recent declarative approach planning plans encoded answer sets logic program, issue optimal plans objective value
function addressed detail far (see Section 8 details). paper,
address issue present extension planning language K (Eiter et al., 2000b, 2003b),
user may associate costs actions, taken account planning
process. main contributions work follows.
define syntax semantics planning language Kc , modularly extends
language K: Costs associated action extending action declarations
optional cost construct describes cost executing respective action.
action costs static dynamic, may depend current stage plan
action considered execution. Dynamic action costs important
natural applications, show simple variant well-known Traveling Salesperson
Problem, cumbersome model solve other, similar languages.
analyze computational complexity planning language K c , provide completeness results major planning tasks propositional setting, locate
suitable slots Polynomial Hierarchy classes derived it. results provide insight intrinsic computational difficulties respective planning problems,
give handle efficient transformations optimal planning knowledge representation formalisms, particular logic programs.
show, awareness results complexity analysis, planning action
costs implemented transformation answer set programming, done system prototype developed. prototype, ready experiments, available
http://www.dlvsystem.com/K/.
Finally, present applications show extended language capable
easily modeling optimal planning various criteria: computing (1) cheapest plans
(which minimize overall action costs); (2) shortest plans (with least number steps);
and, refinement combinations these, viz. (3) shortest plans among cheapest, (4)
cheapest plans among shortest. Notice that, knowledge, task (3)
addressed works far.
extension K action costs provides flexible expressive tool representing
various problems. Moreover, since Ks semantics builds states knowledge rather
states world, deal incomplete knowledge plan quality, is,
best knowledge, completely novel.
experience encouraging answer set planning, based powerful logic programming
engines, allows development declarative planning systems intricate planning
26

fiA NSWER ET P LANNING U NDER ACTION C OSTS

tasks specified solved. work complements extends preliminary results
presented previous work (Eiter et al., 2002a).
remainder paper organized follows. next section, briefly review
language K informally presenting main constituents features simple planning
example. that, define Section 3 extension K action costs, consider
first examples usage Kc . Section 4 devoted analysis complexity issues.
Section 5, consider applications K c . show various types particular optimization
problems expressed K c , consider practical examples. Section 6,
present transformation K c answer set programming, Section 7, report
prototype implementation experiments. discussion related work Section 8,
conclude paper outlook ongoing future work.

2. Short Review Language K
section, give brief informal overview language K, refer (Eiter et al., 2003b)
Appendix formal details. assume reader familiar basic ideas
planning action languages, particular notions actions, fluents, goals plans.
illustration, shall use following planning problem running example.
Problem 1 [Bridge Crossing Problem] Four persons want cross river night plank
bridge, hold two persons time. lamp, must used
crossing. pitch-dark planks missing, someone must bring lamp back
others; tricks (like throwing lamp halfway crosses, etc.) allowed.
Fluents states. state K characterized truth values fluents, describing relevant
properties domain discourse. fluent may true, false, unknown state is,
states K states knowledge, opposed states world fluent either true
false (which easily enforced K, desired). Formally, state consistent set
(possibly negated) legal fluent instances.
action applicable precondition (a list literals fluents) holds
current state. execution may cause modification truth values fluents.
Background knowledge. Static knowledge invariant time K planning domain
specified normal (disjunction-free) Datalog program single answer set
viewed set facts. example, background knowledge specifies four persons:
person(joe). person(jack). person(william). person(averell).

Type declarations. fluent action must declaration ranges arguments specified. instance,
crossTogether(X, Y) requires person(X), person(Y), X < Y. 1

specifies arguments action crossTogether, two persons cross bridge together,

across(X) requires person(X).
1. < used instead inequality avoid symmetric rules.

27

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

specifies fluent describing specific person side river. literals
requires must classical literals static background knowledge (like person(X)
person(Y)), literals built-in predicates (such X < Y). implementation K, DLV K system (Eiter, Faber, Leone, Pfeifer, & Polleres, 2003a), currently supports built-in predicates
< B, <= B, != B obvious meaning less-than, less-or-equal inequality
strings numbers, arithmetic built-ins = B + C = B C stand integer
addition multiplication, predicate #int(X) enumerates integers (up
user-defined limit).
Causation rules. Causation rules (rules brevity) syntactically similar rules
action language C (Giunchiglia & Lifschitz, 1998; Lifschitz, 1999a; Lifschitz & Turner, 1999)
basic form:
caused f B A.

conjunction fluent action literals, possibly including default negation, B
conjunction fluent literals, possibly including default negation, f fluent literal.
Informally, rule reads: B known true current state known true
previous state, f known true current state well. if-part
after-part allowed empty (which means true). causation rule called
dynamic, after-part empty, called static otherwise.
Causation rules used express effects actions ramifications. example,
caused across(X) cross(X), -across(X).
caused -across(X) cross(X), across(X).

describe effects single person crossing bridge either direction.
Initial state constraints. Static rules apply states initial states (which
may unique). expressed keywords always : initially : preceding
sequences rules latter describes initial state constraints must satisfied
initial state. example,
initially : caused -across(X).

enforces fluent across false initial state X satisfying declaration
fluent across, i.e., persons. rule irrelevant subsequent states.
Executability actions.

expressed K explicitly. instance,

executable crossTogether(X, Y) hasLamp(X).
executable crossTogether(X, Y) hasLamp(Y).

declares two persons jointly cross bridge one lamp. action
may multiple executability statements. statement
executable cross(X).

empty body says cross always executable, provided type restrictions X
respected. Dually,
nonexecutable B.

prohibits execution action condition B satisfied. example,
nonexecutable crossTogether(X, Y) differentSides(X, Y).

28

fiA NSWER ET P LANNING U NDER ACTION C OSTS

says persons X cross bridge together different sides bridge.
case conflicts, nonexecutable overrides executable A.
Default strong negation. K supports strong negation (, written -). Note, however, fluent f, state neither f -f needs hold. case knowledge
f incomplete. addition, weak negation (not), interpreted default negation answer set
semantics (Gelfond & Lifschitz, 1991), permitted rule bodies. allows natural modeling inertia default properties, well dealing incomplete knowledge general.
example,
caused hasLamp(joe) hasLamp(jack), hasLamp(william), hasLamp(averell).

expresses conclusion default, joe lamp, whenever evident
persons it.
Macros.

K provides number macros syntactic sugar. example,

inertial across(X).

informally states across(X) holds current state, across(X) held previous state,
unless -across(X) explicitly known hold. macro expands rule
caused across(X) -across(X) across(X).

Moreover, totalize knowledge fluent declaring total f. shortcut
caused f -f.

caused -f f.

intuitive meaning rules unless truth value f derived, cases
f resp. -f true considered.
Planning domains problems. K, planning domain PD = h, hD, Rii background
knowledge , action fluent declarations D, rules executability conditions R; planning
problem P = hPD, qi planning domain PD query
q = g1 , . . . , gm , gm+1 , . . . , gn ? (l)
g1 , . . . , gn ground fluents l 0 plan length. instance, goal query
across(joe), across(jack), across(william), across(averell)? (5)

asks plans bring four persons across 5 steps.
Plans defined using transition-based semantics, execution set actions
transforms current state new state. (optimistic) plan P sequence P = hA 1 , . . . , Al
sets action instances A1 , A2 , . . . , Al trajectory = hhs0 , A1 , s1 i, hs1 , A2 , s2 i, . . . ,
hsl1 , Al , sl ii legal initial state s0 state sl literals goal true.
is, starting s0 , legal transition t1 = hs0 , A1 , s1 i, modeling execution actions 1
(which must executable), transforms 0 state s1 . followed legal transitions
ti = hsi1 , Ai , si i, = 2, 3, . . . , l (cf. Appendix details). plan sequential, |A | 1
= 1, . . . , l, i.e., step consists one action; plans enforced
including keyword noConcurrency.
Besides optimistic plans, K support stronger secure (or conformant) plans. secure
plan must guaranteed work circumstances (Eiter et al., 2000b), regardless
incomplete information initial state possible nondeterminism action effects.
29

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

better readability, following always describe K planning problems P
strictly terms sets declarations, rules executability conditions, optionally use
compact representation K programs following general form:
fluents :
actions :
initially :
always :
goal :

FD
AD
IR
CR
q

(optional) sections fluents always consist lists fluent declarations F ,
action declarations AD , initial state constraints IR executability conditions causation rules
CR , respectively. Together background knowledge goal query q, specify
K planning problem P = hh, hD, Rii, qi, given F plus AD R IR plus
CR . 2
2.1 Solving Bridge Crossing Problem
Using constructs, K encoding Bridge Crossing Problem, assuming joe
initially carries lamp, shown Figure 1. simple five-step plans (l = 5),
joe always carries lamp brings others across. One is:
P = h {crossTogether(joe, jack)}, {cross(joe)}, {crossTogether(joe, william)},
{cross(joe)}, {crossTogether(joe, averell)}

3. Actions Costs
Using language K system prototype, DLV K , already express solve
involved planning tasks, cf. (Eiter et al., 2003b). However, K DLV K alone offer means
finding optimal plans objective cost function. general, different criteria plan
optimality relevant, optimality wrt. action costs shown next example,
slight elaboration Bridge Crossing Problem, well-known brain teasing riddle:
Problem 2 [Quick Bridge Crossing Problem] persons bridge crossing scenario need
different times cross bridge, namely 1, 2, 5, 10 minutes, respectively. Walking two
implies moving slower rate both. possible four persons get across within 17
minutes?
first thought infeasible, since seemingly optimal plan joe, fastest,
keeps lamp leads others across takes 19 minutes altogether. Surprisingly,
see, optimal solution indeed takes 17 minutes.
order allow elegant convenient encoding optimization problems,
extend K language K c one assign costs actions.
3.1 Syntax Kc
Let act , f l , var denote (finite) sets action names, fluent names variable symbols.
Furthermore, let Lact , Lf l , Ltyp denote sets action, fluent, type literals, respectively,
2. format input files system prototype, presented Section 7.

30

fiA NSWER ET P LANNING U NDER ACTION C OSTS

actions :

cross(X) requires person(X).
crossTogether(X, Y) requires person(X), person(Y), X < Y.
takeLamp(X) requires person(X).

fluents :

across(X) requires person(X).
differentSides(X, Y) requires person(X), person(Y).
hasLamp(X) requires person(X).

initially : -across(X). hasLamp(joe).
always :

executable crossTogether(X, Y) hasLamp(X).
executable crossTogether(X, Y) hasLamp(Y).
nonexecutable crossTogether(X, Y) differentSides(X, Y).
executable cross(X) hasLamp(X).
executable takeLamp(X).
nonexecutable takeLamp(X) hasLamp(Y), differentSides(X, Y).
caused
caused
caused
caused

across(X) crossTogether(X, Y),
across(Y) crossTogether(X, Y),
-across(X) crossTogether(X, Y),
-across(Y) crossTogether(X, Y),

-across(X).
-across(Y).
across(X).
across(Y).

caused across(X) cross(X), -across(X).
caused -across(X) cross(X), across(X).
caused hasLamp(X) takeLamp(X).
caused -hasLamp(X) takeLamp(Y), X != Y, hasLamp(X).
caused differentSides(X, Y) across(X), -across(Y).
caused differentSides(X, Y) -across(X), across(Y).
inertial across(X).
inertial -across(X).
inertial hasLamp(X).
noConcurrency.
goal :

across(joe), across(jack), across(william), across(averell)? (l)

Figure 1: K encoding Bridge Crossing Problem
formed action names, fluent names, predicates background knowledge (including
built-in predicates), respectively, using terms nonempty (finite) set constants con .
Kc extends action declarations K costs follows.
Definition 3.1 action declaration K c form:
p(X1 , . . . , Xn ) requires t1 , . . . , tm costs C c1 , . . . , ck .

(1)

(1) p act arity n 0, (2) X1 , . . . , Xn var , (3) t1 , . . . , tm , c1 , . . . , ck
Ltyp every Xi occurs t1 , . . . , tm , (4) C either integer constant, variable
set variables occurring t1 , . . . , tm , c1 , . . . , ck (denoted var (d)), distinguished
variable time, (5) var (d) var {time}, (6) time occur 1 , . . . tm .
31

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

= 0, keyword requires omitted; k = 0, keyword omitted
costs C optional. Here, (1) (2) state parameters action must variables,
fixed values. Informally, (3) means parameters action must typed
requires part. Condition (4) asserts cost locally defined given stage
plan, referenced global variable time. Conditions (5) (6) ensure
variables known type information action parameters static, i.e., depend
time.
Planning domains planning problems K c defined K.
example, elaborated Bridge Crossing Problem, declaration cross(X)
extended follows: suppose predicate walk(Person, Minutes) background knowledge
indicates Person takes Minutes cross. Then, may simply declare
cross(X) requires person(X) costs WX walk(X, WX).

3.2 Semantics Kc
Semantically, Kc extends K cost values actions points time. plan P =
hA1 , . . . , Al i, step 1 l, actions Ai executed reach time point i.
ground action p(x1 , . . . , xn ) legal action instance action declaration wrt. K c
planning domain PD = h, hD, Rii, exists ground substitution var (d)
{time} Xi = xi , 1 n {t1 , . . . , tm } , unique answer
set background knowledge . called witness substitution p(x 1 , . . . , xn ).
Informally, action instance legal, satisfies respective typing requirements. Action costs
formalized follows.
Definition 3.2 Let = p(x1 , . . . , xn ) legal action instance declaration form (1)
let witness substitution a.

costs part empty;
0,
cost (p(x1 , . . . , xn )) =
val(C), {c1 , . . . , ck } ;

undefined otherwise.

unique answer set val : con defined integer value
integer constants 0 non-integer constants.
reference variable time, possible define time-dependent action costs; shall consider example Section 5.2. Using cost , introduce well-defined legal action instances
define action cost values follows.
Definition 3.3 legal action instance = p(x 1 , . . . , xn ) well-defined iff holds (i)
time point 1, witness substitution time = cost (a)
integer, (ii) cost (a) = cost0 (a) holds two witness substitutions , 0 coincide
time defined costs. well-defined a, unique cost time point 1 given
costi (a) = cost (a) (i).
definition, condition (i) ensures cost value exists, must integer,
condition (ii) ensures value unique, i.e., two different witness substitutions
0 evaluate cost part integer cost value.
32

fiA NSWER ET P LANNING U NDER ACTION C OSTS

action declaration well-defined, legal instances well-defined.
fulfilled if, database terms, variables X1 , . . . , Xn together time (1) functionally determine value C. framework, semantics K c planning domain PD = h, hD, Rii
well-defined well-defined action declarations PD. rest paper, assume
well-definedness Kc unless stated otherwise.
Using costi , define costs plans.
Definition 3.4 Let P = hPD, Q ? (l)i planning problem. Then, plan P = hA 1 , . . . , Al
P, cost defined
costP (P ) =

Pl

j=1

P


cost
(a)
.
j
aAj

plan P optimal P, costP (P ) costP (P 0 ) plan P 0 P, i.e., P least cost
among plans P. cost planning problem P, denoted cost P , given costP =
costP (P ), P optimal plan P.
particular, costP (P ) = 0 P = hi, i.e., plan void. Note cost P defined
plan P exists.3
Usually one estimate upper bound plan length, know exact
length optimal plan. Although defined optimality fixed plan length l,
see Section 5.1 appropriate encodings extended optimality plans
length l.
Besides optimal plans, plans bounded costs interest, motivates following definition.
Definition 3.5 plan P planning problem P admissible wrt. cost c, cost P (P ) c.
Admissible plans impose weaker condition plan quality optimal plans.
particularly relevant optimal costs crucial issue, long cost stays within given
limit, optimal plans difficult compute. might face questions make
airport within one hour?, enough change buy coffee? etc. amount
admissible planning problems. shall see, computing admissible plans complexity-wise
easier computing optimal plans.
3.3 Optimal Solution Quick Bridge Crossing Problem
model Quick Bridge Crossing Problem K c , first extend background knowledge
follows, predicate walk describes time person needs cross max determines
two persons slower:
walk(joe, 1). walk(jack, 2). walk(william, 5). walk(averell, 10).
max(A, B, A) :- walk( , A), walk( , B), >= B.
max(A, B, B) :- walk( , A), walk( , B), B > A.

Next, modify declarations cross crossTogether Figure 1 adding costs:
3. following, subscripts dropped clear context.

33

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

cross(X) requires person(X) costs WX walk(X, WX).
crossTogether(X, Y) requires person(X), person(Y), X <
costs Wmax walk(X, WX), walk(Y, WY), max(WX, WY, Wmax).

declaration takeLamp remains unchanged, time hand lamp negligible.
Using modified planning domain, 5-step plan reported Section 2.1 cost 19. Actually, optimal plan length l = 5. However, relinquish first intuition
fastest person, joe, always lamp consider problem varying plan length,
find following 7-step plan:
P = h {crossTogether(joe, jack)}, {cross(joe)}, {takeLamp(william)},
{crossTogether(william, averell)}, {takeLamp(jack)}, {cross(jack)},
{crossTogether(joe, jack)}

Here, costP (P ) = 17, thus P admissible respect cost 17. means Quick
Bridge Crossing Problem positive answer. fact, P least cost plans length
l = 7, thus optimal 7-step plan. Moreover, P least cost plans emerge
consider plan lengths. Thus, P optimal solution Quick Bridge Crossing
Problem arbitrary plan length.
3.4 Bridge Crossing Incomplete Knowledge
language K well-suited model problems involve uncertainty incomplete
initial states non-deterministic action effects qualitative level. enriched language K c
gracefully extends secure (conformant) plans well, must reach goal circumstances (Eiter et al., 2000b, 2003b). precisely, optimistic plan hA 1 , . . . , secure,
applicable evolution system: starting legal initial state 0 , first
action set A1 (for plan length l 1) always executed (i.e., legal transition hs 0 , A1 , s1
exists), every possible state 1 , next action set A2 executed etc.,
performed actions, goal always accomplished (cf. Appendix formal definition).
secure plans inherit costs optimistic plans, different possibilities define
optimality secure plans. may consider secure plan optimal, least cost either
among optimistic plans,
among secure plans only.
first alternative, might planning problems secure plans, optimal
secure plans. reason, second alternative appears appropriate.
Definition 3.6 secure plan P optimal planning problem P, least cost among
secure plans P, i.e., costP (P ) costP (P 0 ) secure plan P 0 P. secure cost
P, denoted costsec (P), costsec (P) = costP (P ), P optimal secure plan P.
notion admissible secure plans defined analogously.
example, assume known least one person bridge scenario lamp,
neither exact number lamps allocation lamps persons known.
four desperate persons ask plan brings safely across bridge, need
(fast) secure plan works possible initial situations. K c , modeled
replacing initially-part following declarations:
34

fiA NSWER ET P LANNING U NDER ACTION C OSTS

initially : total hasLamp(X).
caused false -hasLamp(joe), -hasLamp(jack),
-hasLamp(william), -hasLamp(averell).

first statement says person either lamp not, second least
one must lamp. detailed discussion use total statement
modeling incomplete knowledge non-determinism refer (Eiter et al., 2003b).
easily see, optimal secure solution take least 17 minutes, since original
case (where joe lamp) one possible initial situations, cost
optimistic plan optimal plan lengths 17. However, secure plan
optimal plan lengths requires least 8 steps (but higher cost): Different
optimistic plans, need one extra step beginning makes sure one
walk first (above, joe jack) lamp, effected proper takeLamp action.
example plan following cost 17:
P = h {takeLamp(joe)}, {crossTogether(joe, jack)}, {cross(joe)},
{takeLamp(william)}, {crossTogether(william, averell)}, {takeLamp(jack)},
{cross(jack)}, {crossTogether(joe, jack)}

easily check P works every possible initial situation. Thus, optimal (secure)
plan plan length 8, moreover arbitrary plan length.

4. Computational Complexity
section, address computational complexity K c , complementing similar results
language K (Eiter et al., 2003b).
4.1 Complexity Classes
assume reader familiar basic notions complexity theory, P, NP,
problem reductions completeness; see e.g. (Papadimitriou, 1994) references therein.
recall Polynomial Hierarchy (PH) contains classes P0 = P0 = P0 = P Pi+1 =
P
P
NPi , Pi+1 = co-Pi+1 , Pi+1 = Pi , 0. particular, P1 = NP P2 = PNP .
Note classes contain decision problems (i.e., problems answer yes
no). checking well-definedness deciding plan existence problems, computing
plan search problem, problem instance (possibly empty) finite set S(I)
solutions exists. solve problem, (possibly nondeterministic) algorithm must compute
alternative solutions set computation branches, S(I) empty. precisely,
search problems solved transducers, i.e., Turing machines equipped output tape.
machine halts accepting state, contents output tape result
computation. Observe nondeterministic machine computes (partial) multi-valued function.
analog NP, class NPMV contains search problems S(I) computed nondeterministic Turing machine polynomial time; precise definition, see (SelP
man, 1994). analogy Pi+1 , Pi+1 MV = NPMVi , 0, denote generalization
NPMV machine access Pi oracle.
Analogs classes P Pi+1 , 0, given classes FP F Pi+1 , 0,
contain partial single-valued functions (that is, |S(I)| 1 problem instance
35

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

I) computable polynomial time using resp. Pi oracle. say, abusing terminology,
search problem FP (resp. FPi+1 ), partial (single-valued) function f FP
(resp. f FPi+1 ) f (I) S(I) f (I) undefined iff S(I) = . example,
computing satisfying assignment propositional CNF (FSAT) computing optimal tour
Traveling Salesperson Problem (TSP) F P2 view, cf. (Papadimitriou, 1994).
partial function f polynomial-time reducible another partial function g,
polynomial-time computable functions h 1 h2 f (I) = h2 (I, g(h1 (I)))
g(h1 (I)) defined whenever f (I) defined. Hardness completeness defined usual.
4.2 Problem Setting
focus following questions:
Checking Well-Definedness: Decide whether given action description well-defined wrt.
given planning domain PD, resp. whether given planning domain PD well-defined.
Admissible Planning: Decide whether planning problem P admissible (optimistic/secure)
plan exists wrt. given cost value c, find plan.
Optimal Planning: Find optimal (optimistic/secure) plan given planning problem.
Notice (Eiter et al., 2003b) focused deciding existence optimistic/secure plans,
rather actually finding plans, presented detailed study complexity task
various restrictions ground (propositional) planning problems. paper, confine
discussion case planning problems P = hPD, Q ? (l)i look polynomial length
plans, i.e., problems plan length l bounded polynomial size input.
shall consider mainly ground (propositional) planning, assume planning
domains well-typed unique model background knowledge computed
polynomial time. general case, well-known complexity results logic programming,
cf. (Dantsin, Eiter, Gottlob, & Voronkov, 2001), already evaluating background knowledge
EXPTIME-hard, problems thus provably intractable. recall following results,
appear (or directly follow from) previous work (Eiter et al., 2003b).
Proposition 4.1 Deciding, given propositional planning problem P sequence P = hA 1 , . . . ,
Al action sets, (i) whether given sequence = ht 1 , . . . , tl legal trajectory witnessing
P optimistic plan P feasible polynomial time, (ii) whether P secure plan
P P2 -complete.
4.3 Results
start considering checking well-definedness. problem, interesting investigate
non-ground case, assuming background knowledge already evaluated. way
assess intrinsic difficulty task obtaining following result.
Theorem 4.2 (Complexity checking well-definedness) Given K c planning domain PD =
h, hD, Rii unique model , checking (i) well-definedness given action declaration form (1) wrt. PD (ii) well-definedness PD P2 -complete.
36

fiA NSWER ET P LANNING U NDER ACTION C OSTS

Proof. Membership: (i), violated nonempty costs part legal action
instance = p(x1 , . . . , xn ) either (1) exist witness substitutions 0
time = time 0 , cost (a) = val(C) cost0 (a) = val(C 0 ), val(C) 6= val(C 0 ),
(2) witness substitution cost (a) = val(C) integer.
guessed checked, via witness substitution, polynomial time, along
0 (1); note that, definition, variables must substituted constants
background knowledge (including numbers), must values time occurs
c1 , . . . , ck . Given a, decide (2) help NP oracle. summary, disproving welldefinedness nondeterministically possible polynomial time NP oracle. Hence,
checking well-definedness co-P2 = P2 . membership part (ii) follows (i),
since well-definedness PD reduces well-definedness action declarations it, P2
closed conjunctions.
Hardness: show hardness (i) reduction deciding whether quantified Boolean
formula (QBF)
Q = XY.c1 ck
ci = Li,1 Li,`i , = 1, . . . , k, disjunction literals L i,j atoms
X = x1 , . . . , xn = xn+1 . . . , xm , true. Without loss generality, may assume
ci contains three (not necessarily distinct) literals, either positive negative.
construct planning domain PD follows. background knowledge, ,
bool(0). bool(1).
pos(1, 0, 0). pos(0, 1, 0). pos(0, 0, 1). pos(1, 1, 0). pos(1, 0, 1). pos(0, 1, 1). pos(1, 1, 1).
neg(0, 0, 0). neg(1, 0, 0). neg(0, 1, 0). neg(0, 0, 1). neg(1, 1, 0). neg(1, 0, 1). neg(0, 1, 1).

Here, bool declares truth values 0 1. facts pos(X 1 , X2 , X3 ) neg(X1 , X2 , X3 ) state
truth assignments X1 , X2 , X3 positive clause X1 X2 X3 resp.
negative clause X1 X2 X3 satisfied.
rest planning domain PD consists single action declaration form
p(V1 , ..., Vn ) requires bool(V1), ..., bool(Vn) costs 0 c1 , ..., ck .


ci

=



pos(Vi,1 , Vi,2 , Vi,3 ), ci = xi,1 xi,2 xi,3 ,
neg(Vi,1 , Vi,2 , Vi,3 ), ci = xi,1 xi,2 xi,3 ,

= 1, . . . , k.

example, clause c = x1 x3 x6 mapped c = pos(V1 , V3 , V6 ). easy see
legal action instance = p(b1 , . . . , bn ) corresponds 1-1 truth assignment X
given (xi ) = bi , = 1, . . . , n. Furthermore, cost value defined (which 0) iff
formula (c1 ck ) true. Thus, well-defined wrt. PD iff Q true. Since PD
2
efficiently constructible, proves P2 -hardness.
Observe ground case, checking well-definedness much easier. Since substitutions need guessed, test proof Theorem 4.2 polynomial. Thus, assumption
efficient evaluation background program, obtain:
Corollary 4.3 ground (propositional) case, checking well-definedness action description wrt. Kc planning domain PD = h, hD, Rii, resp. PD whole, possible
polynomial time.
37

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

remark checking well-definedness expressed planning task K,
logic program; refer (Eiter, Faber, Leone, Pfeifer, & Polleres, 2002b) details.
turn computing admissible plans.
Theorem 4.4 (Complexity admissible planning) polynomial plan lengths, deciding whether
given (well-defined) propositional planning problem hPD, qi (i) optimistic admissible
plan wrt. given integer b NP-complete, finding plan complete NPMV, (ii)
deciding whether hPD, qi secure admissible plan wrt. given integer b P3 -complete,
computing plan P3 MV-complete. Hardness holds cases fixed plan length.
proof refer Appendix. finally address complexity computing
optimal plans.
Theorem 4.5 (Complexity optimal planning) polynomial plan lengths, (i) computing
optimal optimistic plan hPD, Q ? (l)i K c FP2 -complete, (ii) computing optimal
secure plan hPD, Q ? (l)i K c FP4 -complete. Hardness holds cases even plan
length l fixed.
proof found Appendix.
remark case unbounded plan length, complexity computing plans increases requires (at least) exponential time general, since plans might exponential length
size planning problem. Thus, practical terms, constructing plans infeasible,
since occupy exponential space. Furthermore, follows previous results (Eiter et al.,
2003b), deciding existence admissible optimistic resp. secure plan planning problem wrt. given cost PSPACE-complete resp. NEXPTIME-complete. leave detailed
analysis complexity aspects K c work.

5. Applications
5.1 Cost Efficient versus Time Efficient Plans
section, show language K c used minimize plan length combination
minimizing costs plan. especially interesting problem settings parallel
actions allowed (cf. (Kautz & Walser, 1999; Lee & Lifschitz, 2001)).
domains parallel actions, Kautz Walser propose various criteria optimized, instance number actions needed, number necessary time steps
parallel actions allowed, well combinations two criteria (1999). exploiting
action costs proper modeling, solve optimization problems sort. example,
single plans minimal number actions simply assigning cost 1 possible
actions.
consider following optimization problems:
() Find plan minimal cost (cheapest plan) given number steps.
() Find plan minimal time steps (shortest plan).
() Find shortest among cheapest plans.
38

fiA NSWER ET P LANNING U NDER ACTION C OSTS

() Find cheapest among shortest plans.
Problem () already defined optimal plans far. show
express () terms optimal cost plans well, extend elaboration respect
combinations () ().
5.1.1 C HEAPEST P LANS



G IVEN P LAN L ENGTH ()

guiding example, refer Blocks World parallel moves allowed, apart
finding shortest plans minimizing total number moves issue. Kc encoding
domain, plans serializable, shown Figure 2. Serializability means parallel
actions non-interfering executed sequentially order, i.e. parallel plan
arbitrarily unfolded sequential plan.
fluents :

on(B, L) requires block(B), location(L).
blocked(B) requires block(B).
moved(B) requires block(B).

actions :

move(B, L) requires block(B), location(L) costs 1.

always :

executable move(B, L) B != L.
nonexecutable move(B, L) blocked(B).
nonexecutable move(B, L) blocked(L).
nonexecutable move(B, L) move(B1, L), B < B1, block(L).
nonexecutable move(B, L) move(B, L1), L < L1.
nonexecutable move(B, B1) move(B1, L).
caused
caused
caused
caused

on(B, L) move(B, L).
blocked(B) on(B1, B).
moved(B) move(B, L).
on(B, L) moved(B) on(B, L).

Figure 2: Kc encoding Blocks World domain
planning problem emerging initial state goal state depicted Figure 3
modeled using background knowledge bw :
block(1). block(2). block(3). block(4). block(5). block(6).
location(table).
location(B) :- block(B).

extending program Figure 2 follows:
initially : on(1, 2). on(2, table). on(3, 4). on(4, table). on(5, 6). on(6, table).
goal :

on(1, 3), on(3, table), on(2, 4), on(4, table), on(6, 5), on(5, table) ?(l)

1
2

3
4

1
3

5
6

2
4

6
5

Figure 3: simple Blocks World instance
39

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

move penalized cost 1, results minimization total number moves.
Let Pl denote planning problem plan length l.
l = 2, optimal plan involves six moves, i.e. cost P2 = 6:
P2 = h {move(1, table), move(3, table), move(5, table)}, {move(1, 3), move(2, 4), move(6, 5)}

unfolding steps, plan gives rise similar plans length l = 3, . . . , 6 cost 6.
l = 3, find among others following optimal plan, cost 5:
P3 = h {move(3, table)}, {move(1, 3), move(5, table)}, {move(2, 4), move(6, 5)}

plan parallelized two steps. plan length l > 3,
obtain optimal plans similar P 3 , extended void steps. Thus plan cheapest
plan lengths cost 5 needs three steps. Note shortest parallel plans (of length 2)
expensive, explained above.
5.1.2 HORTEST P LANS ()
Intuitively, possible include minimization time steps cost function.
describe preprocessing method which, given K planning domain PD, list Q ground literals,
upper bound 0 plan length, generates planning problem P (PD, Q, i)
optimal plans P correspond shortest plans reach Q PD steps, i.e.,
plans hPD, Q ? (l)i l minimal. assume action costs specified
original planning domain PD, minimizing time steps target.
First rewrite planning domain PD PD follows: introduce new distinct fluent
gr new distinct action finish, defined follows:
fluents :
actions :

gr.
finish costs time.

Intuitively, action finish represents final action, use finish plan. later
action occurs, expensive plan assign time cost. fluent gr (goal
reached) shall true remain true soon goal reached, triggered
finish action.
modeled K c adding following statements always section
program:
executable finish Q, gr.
caused gr finish.
caused gr gr.

Furthermore, want finish occur exclusively want block occurrence
action goal reached. Therefore, every action PD, add
nonexecutable finish.

add gr if-part executability condition A. Finally, avoid inconsistencies static dynamic effects soon goal reached, add gr
part causation rule PD except nonexecutable rules remain unchanged. 4
define P (PD, Q, i) = hPD , gr ?(i + 1)i. take + 1 plan length since
need one additional step execute finish action.
4. need rewrite nonexecutable rules respective actions already switched
rewriting executability conditions.

40

fiA NSWER ET P LANNING U NDER ACTION C OSTS

construction, easy see optimal plan P = hA 1 , . . . , Aj , Aj+1 , . . . , Ai+1
planning problem P must Aj+1 = {finish} Aj+2 = . . . = Ai+1 =
j {0, . . . , i}. thus following desired property.
Proposition 5.1 optimal plans P 1-1 correspondence shortest plans reaching Q PD. precisely, P = hA1 , . . . , Aj+1 , , . . . , optimal optimistic plan
P (PD, Q, i) Aj+1 = {finish} P 0 = hA1 , . . . , Aj optimistic plan
hPD, Q ? (j)i j {0, . . . , i}, hPD, Q ? (j 0 )i optimistic plan j 0 < j.
Blocks World example, using method get 2-step plans, choose 2.
compute shortest plans plan lengths, set upper bound large enough
plans length l guaranteed exist. trivial bound total number legal
states general exponential number fluents.
However, many typical applications inherent, much smaller bound plan length.
instance, Blocks World n blocks, goal configuration reached within
2n sinit sgoal steps, sinit sgoal numbers stacks initial goal
state, respectively.5 Therefore, 6 upper bound plan length simple instance.
remark approach minimizing plan length efficient upper bound
close optimum known. Searching minimum length plan iteratively increasing
plan length may much efficient bound known, since weak upper bound
lead explosion search space (cf. benchmarks Section 7.2).
5.1.3 HORTEST

AMONG

C HEAPEST P LANS ()

previous subsection, shown calculate shortest plans K programs without
action costs. Combining arbitrary K c programs rewriting method described easy.
want find shortest among cheapest plans, use rewriting,
little change. setting costs actions except finish least high
highest possible cost finish action. obviously plan length + 1. So,
simply modify action declarations
requires B costs C D.

P multiplying costs factor + 1:
requires B costs C1 C1 = (i + 1) C, D.

lets action costs take priority cost finish compute plans
satisfying criterion (). Let P denote resultant planning problem. have:
Proposition 5.2 optimal plans P 1-1 correspondence shortest among
cheapest plans reaching Q PD within steps. precisely, P = hA 1 , . . . , Aj+1 , , . . . ,
optimal optimistic plan P (PD, Q, i) Aj+1 = {finish} (i) P 0 =
hA1 , . . . , Aj plan Pj = hPD, Q ? (j)i, j {0, . . . , i}, (ii) P 00 = hA1 , . . . , Aj 0
plan Pj 0 = hPD, Q ? (j 0 )i j 0 i, either costPj 0 (P 00 ) > costPj (P 0 )
costPj 0 (P 00 ) = costPj (P 0 ) j 0 j.
Figure 4 shows P Blocks World instance = 6. One optimal plan P
5. One solve Blocks World problem sequentially first unstacking blocks table
(n sinit steps) building goal configuration (n sgoal steps).

41

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

fluents :

on(B, L) requires block(B), location(L).
blocked(B) requires block(B).
moved(B) requires block(B).
gr.

actions :

move(B, L) requires block(B), location(L) costs C C = 7 1.
finish costs time.

always :

executable move(B, L) B != L, gr.
nonexecutable move(B, L) blocked(B).
nonexecutable move(B, L) blocked(L).
nonexecutable move(B, L) move(B1, L), B < B1, block(L).
nonexecutable move(B, L) move(B, L1), L < L1.
nonexecutable move(B, B1) move(B1, L).
caused
caused
caused
caused

on(B, L) gr move(B, L).
blocked(B) on(B1, B), gr.
moved(B) gr move(B, L).
on(B, L) moved(B), gr on(B, L).

executable finish on(1, 3), on(3, table), on(2, 4), on(4, table),
on(6, 5), on(5, table), gr.
caused gr finish.
caused gr gr.
nonexecutable move(B, L) finish.
initially : on(1, 2). on(2, table). on(3, 4). on(4, table). on(5, 6). on(6, table).
goal :

gr? (7)

Figure 4: Computing shortest plan Blocks World instance minimum number
actions

P = h {move(3, table)}, {move(1, 3), move(5, table)},
{move(2, 4), move(6, 5)}, {finish}, , , i,

costP (P ) = 39. compute optimal cost wrt. optimization () subtracting cost finish dividing + 1: (39 4) (i + 1) = 35 7 = 5. Thus,
need minimum 5 moves reach goal. minimal number steps obviously steps,
except final finish action, i.e. 3. Thus, need least 3 steps plan five moves.
5.1.4 C HEAPEST

AMONG

HORTEST P LANS ()

Again, use rewriting optimization (). cost functions adapted similarly
previous subsection, cost action finish takes priority
actions costs. end, sufficient set cost finish high enough, achieved
multiplying factor F higher sum action costs legal action instances
steps j = 1, . . . , + 1. Let P denote resulting planning problem. have:
Proposition 5.3 optimal plans P 1-1 correspondence cheapest among
shortest plans reaching Q PD within steps. precisely, P = hA 1 , . . . , Aj+1 , , . . . ,
42

fiA NSWER ET P LANNING U NDER ACTION C OSTS

optimal optimistic plan P (PD, Q, i) Aj+1 = {finish} (i) P 0 =
hA1 , . . . , Aj plan Pj = hPD, Q ? (j)i, j {0, . . . , i}, (ii) P 00 = hA1 , . . . , Aj 0
plan Pj 0 = hPD, Q ? (j 0 )i j 0 i, either j 0 > j, j 0 = j costPj 0 (P 00 )
costPj (P 0 ).
example, 36 possible moves. Thus, could take F = 36 (i + 1)
would set costs finish time 36 (i + 1). However, need take account
actions actually occur simultaneously. example, six blocks
moved parallel. Therefore, sufficient set F = 6 (i + 1) assign finish cost
time F = time 42. Accordingly, action declarations modified follows:
actions :

move(B, L) requires block(B), location(L) costs 1.
finish costs C C = time 42.

optimal plan modified planning problem P is:
P = h {move(1, table), move(3, table), move(5, table)},
{move(1, 3), move(2, 4), move(6, 5)}, {finish}, , , ,

costP (P ) = 132. Here, compute optimal cost wrt. optimization () simply
subtracting cost finish, i.e. 132 3 42 = 6, since finish occurs time point 3.
Consequently, need minimum 6 moves shortest plan, length 3 1 = 2.
indeed, seen (and how) optimization problems () ()
represented Kc . remark transformations P , P , P work restrictions
secure and/or sequential plans well.
5.2 Traveling Salesperson
another illustrating example optimal cost planning, introduce elaboration
Traveling Salesperson Problem.
Traveling Salesperson Problem (TSP). start classical Traveling Salesperson Problem (TSP), given set cities connections (e.g., roads, airways) certain costs.
want know economical round trip visits cities exactly returns
starting point (if tour exists). Figure 5 shows instance representing capitals
Austrian provinces. dashed line flight connection, connections roads;
connection marked costs traveling hours.
brg ... Bregenz
eis ... Eisenstadt
gra ... Graz
ibk ... Innsbruck
kla ... Klagenfurt
lin ... Linz
sbg ... Salzburg
stp ... St. Plten
vie ... Vienna

lin
sbg

2

2

ibk

2

5

vie
1

2
3
2

2

2
kla

Figure 5: TSP Austria

eis

2

3

43

2
stp 1

1

1
brg

1

gra

1

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

represent Kc follows. background knowledge SP defines two predicates
city(C) conn(F, T, C) representing cities connections associated costs. Connections traveled ways:
conn(brg, ibk, 2). conn(ibk, sbg, 2). conn(ibk, vie, 5). conn(ibk, kla, 3).
conn(sbg, kla, 2). conn(sbg, gra, 2). conn(sbg, lin, 1). conn(sbg, vie, 3).
conn(kla, gra, 2). conn(lin, stp, 1). conn(lin, vie, 2). conn(lin, gra, 2).
conn(gra, vie, 2). conn(gra, eis, 1). conn(stp, vie, 1). conn(eis, vie, 1).
conn(stp, eis, 2). conn(vie, brg, 1).
conn(B, A, C) :- conn(A, B, C).
city(T) :- conn(T, , ).

possible encoding TSP starting Vienna (vie) K c program Figure 6. includes two
actions traveling one city another directly returning starting point
end round trip soon cities visited.
actions :

travel(X, Y) requires conn(X, Y, C) costs C.
return from(X) requires conn(X, vie, C) costs C.

fluents :

unvisited. end.
in(C) requires city(C).
visited(C) requires city(C).

always :

executable travel(X, Y) in(X).
nonexecutable travel(X, Y) visited(Y).
executable return from(X) in(X).
nonexecutable return from(X) unvisited.
caused unvisited city(C), visited(C).
caused end return from(X).
caused in(Y) travel(X, Y).
caused visited(C) in(C).
inertial visited(C).

noConcurrency.
initially : in(vie).
goal :
end? (9)

Figure 6: Traveling Salesperson
problem ten optimal 9-step solutions cost 15. show first five here,
others symmetrical:
P1 = h {travel(vie, stp)},
{travel(lin, sbg)},
{return from(brg)}
P2 = h {travel(vie, eis)},
{travel(sbg, gra)},
{return from(brg)}
P3 = h {travel(vie, eis)},
{travel(gra, kla)},
{return from(brg)}
P4 = h {travel(vie, lin)},
{travel(gra, kla)},

{travel(stp, eis)},
{travel(sbg, kla)},

{travel(eis, stp)},
{travel(gra, kla)},

{travel(eis, stp)},
{travel(kla, sbg)},

{travel(lin, stp)},
{travel(kla, sbg)},

{travel(eis, gra)}, {travel(gra, lin)},
{travel(kla, ibk)}, {travel(ibk, brg)},
{travel(stp, lin)}, {travel(lin, sbg)},
{travel(kla, ibk)}, {travel(ibk, brg)},
{travel(stp, lin)}, {travel(lin, gra)},
{travel(sbg, ibk)}, {travel(ibk, brg)},
{travel(stp, eis)}, {travel(eis, gra)},
{travel(sbg, ibk)}, {travel(ibk, brg)},

44

fiA NSWER ET P LANNING U NDER ACTION C OSTS

{return from(brg)}
P5 = h {travel(vie, gra)},
{travel(lin, sbg)},
{return from(brg)}


{travel(gra, eis)}, {travel(eis, stp)}, {travel(stp, lin)},
{travel(sbg, kla)}, {travel(kla, ibk)}, {travel(ibk, brg)},


TSP variable costs. Let us consider elaboration TSP, assume
costs traveling different connections may change trip. Note three
five solutions example include traveling St.Polten Eisenstadt vice versa
second day. Let us assume salesperson, starts Monday, face
exceptions might increase cost trip. instance, (i) heavy traffic jams expected
Tuesdays route St.Polten Eisenstadt (ii) salesperson shall use flight
connection Vienna Bregenz Mondays expensive business class tickets
available connection beginning week. deal different costs
respective connections depending particular day.
end, first add background knowledge SP new predicate cost(A, B, W, C)
representing cost C traveling connection B weekday W take exceptional
costs account:
cost(A, B, W, C) :- conn(A, B, C), #int(W), 0 < W, W <= 7, ecost(A, B, W).
ecost(A, B, W) :- conn(A, B, C), cost(A, B, W, C1), C != C1.

original costs predicate conn(A, B, C) represent defaults, overridden
explicitly adding different costs. instance, represent exceptions (i) (ii), add:
cost(stp, eis, 2, 10). cost(vie, brg, 1, 10).

setting exceptional costs two critical connections 10. Weekdays coded integers
1 (Monday) 7 (Sunday). represent mapping time steps weekdays
following rules add SP :
weekday(1, 1).
weekday(D, W) :- = D1 + 1, W = W1 + 1, weekday(D1, W1), W1 < 7.
weekday(D, 1) :- = D1 + 1, weekday(D1, 7).

Note although modified background knowledge SP stratified (since cost defined
cyclic negation), total well-founded model, thus unique answer set.
Finally, change costs traveling returning K c program Figure 6:
actions :

travel(X, Y) requires conn(X, Y, C1) costs C
weekday(time, W), cost(X, Y, W, C).
return from(X) requires conn(X, vie, C1) costs C
weekday(time, W), cost(X, vie, W, C).

Since costs P1 (which includes traveling St.Polten Eisenstadt) second
day increased due exception (i), four plans remain optimal. Note
unlike default costs, exceptional costs apply bidirectionally, exception
affect P2 P3 . Furthermore, due exception (ii) symmetrical round trips starting
flight trips Bregenz longer optimal.
presented encoding proves flexible, allows adding arbitrary exceptions
connection weekday simply adding respective facts; moreover, even
involved scenarios, exceptions defined rules, modeled.
45

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

5.3 Small Example Planning Resource Restrictions
Although planning resources main target approach, following encoding
shows action costs used order model optimization resource consumption
cases. important resource real world planning money. instance, let us consider
problem buying selling (Lee & Lifschitz, 2001):
$6 pocket. newspaper costs $1 magazine costs $3.
enough money buy one newspaper two magazines?
Kc , encoded compact way following background facts:
item(newspaper, 1). item(magazine, 2).

combined following short K c program:
actions :

buy(Item, Number) requires item(Item, Price), #int(Number)
costs C C = Number Price.

fluents :

have(Item, Number) requires item(Item, Price), #int(Number).

always :

executable buy(Item, Number).
nonexecutable buy(Item, N1) buy(Item, N2), N1 < N2.
caused have(Item, Number) buy(Item, Number).

goal :

have(newspaper, 1), have(magazines, 2) ? (1)

action buy always executable, one must buy two different amounts certain
item once. Obviously, admissible plan wrt. cost 6 exists, optimal plan problem,
h{buy(newspaper, 1), buy(magazine, 2)} cost P = 7. Therefore, answer problem
no.
approach considers positive action costs directly allow modeling full
consumer/producer/provider relations resources general, favor clear non-ambiguous
definition optimality. instance, allowing negative costs one could always add producer
action make existing plan cheaper, whereas approach costs guaranteed increase
monotonically, allowing clear definition plan costs optimality.
hand, encode various kinds resource restrictions using fluents represent resources. model production/consumption action effects fluents
add restrictions constraints. allows us model even complex resource scheduling
problems; optimization, however, remains restricted action costs.

6. Transformation Logic Programming
section, describe planning action costs implemented means
transformation answer set programming. extends previous transformation (Eiter et al.,
2003a), maps ordinary K planning problems disjunctive logic programs answer
set semantics (Gelfond & Lifschitz, 1991), takes advantage weak constraints, cf. (Buccafurri,
Leone, & Rullo, 1997, 2000), implemented DLV system (Faber & Pfeifer, 1996; Eiter,
Faber, Leone, & Pfeifer, 2000a). addition, show translation adapted
language Smodels (Simons, Niemela, & Soininen, 2002).
6.1 Disjunctive Logic Programs Weak Constraints
First, give brief review disjunctive logic programs weak constraints.
46

fiA NSWER ET P LANNING U NDER ACTION C OSTS

Syntax

disjunctive rule (for short, rule) R construct
a1 v v :- b1 , , bk , bk+1 , , bm .

(2)

ai bj classical literals function-free first-order alphabet, n 0,
k 0. part left (resp. right) :- head (resp. body) R, :- omitted
= 0. let H(R) = {a1 , . . ., } set head literals B(R) = B + (R) B (R)
set body literals, B + (R) = {b1 ,. . . , bk } B (R) = {bk+1 , . . . , bm }. (strong)
constraint rule empty head (n = 0).
weak constraint construct
: b1 , , bk , bk+1 , , bm . [w :]

(3)

w integer constant variable occurring b 1 , . . . , bk bi classical literals.6
B(R) defined (2).
disjunctive logic program (DLPw ) (simply, program) finite set rules, constraints
weak constraints; here, superscript w indicates potential presence weak constraints.
Semantics answer sets program without weak constraints defined usual (Gelfond & Lifschitz, 1991; Lifschitz, 1996). one difference, though: consider
inconsistent answer sets. answer sets program weak constraints defined
selection answer sets weak-constraint free part 0 optimal answer sets.
weak constraint c form (3) violated, instance conjunction
satisfied respect candidate answer set S, i.e., exists substitution mapping
variables c Herbrand base {b 1 , , bk } {bk+1 , , bm }
= ; call w violation value c wrt. . 7 violation cost c wrt. S, denoted
costc (S), sum violation values violating substitutions c wrt. S; cost
S, denoted cost (S),
X
cost (S) =
costc (S),
c weak constraints

i.e., sum violation costs weak constraints wrt. S. answer set
selected (called optimal answer set), cost (M ) minimal answer sets .
(Buccafurri et al., 2000) know given head-cycle-free disjunctive program, deciding whether query q true optimal answer set P2 -complete. respective class
computing answer set FP2 -complete. Together results Section 4 indicates translations optimal planning problems head-cycle-free disjunctive logic programs
weak constraints language Smodels feasible polynomial time.
6.2 Translating Kc DLPw
extend original transformation lp(P), naturally maps K planning problem P
weak-constraint free program (Eiter et al., 2003a), new translation lp w (P), optimal
answer sets lpw (P) correspond optimal cost plans K c planning problem P.
6. colon [w :] stems DLV language, allows specify priority layer colon.
need priority layers translation, stick DLV syntax.
7. weak constraint c admissible, possible violation values candidate answer sets integers.
Thus, w variable, must guarantee w bound integer.

47

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Basically, lp(P) fluent action literals extended additional time parameter,
executability conditions well causations rules modularly translated (rule rule) corresponding program rules constraints; disjunction used guessing actions
executed plan point time.
6.2.1 R EVIEW



RANSLATION lp(P)

basic steps translation K programs logic programs follows (cf. (Eiter et al.,
2003a) details):
Step 0 (Macro Expansion):

First, replace macros K program definitions.

Step 1 (Background Knowledge): background knowledge P already given logic
program included lp(P), without modification.
Step 2 (Auxiliary Predicates):

represent steps, add following facts lp(P)

time(0)., . . . , time(l). next(0, 1)., . . . , next(l 1, l).

l plan length query q = G?(l) P hand.
Step 3 (Causation Rules): Causation rules mapped rules lp(P) adding type information extending fluents actions time stamp using time next. example,
caused across(X) cross(X), -across(X).

leads rule across(X, T1) :- cross(X, T0), -across(X, T0), person(X), next(T0, T1 ).
lp(P) T1 , T0 new variables. Here, type information person(X) across(X),
-across(X), taken type declaration, added, helps avoid unsafe logic programming rules.
Step 4 (Executability Conditions): Similarly, executability condition translated disjunctive rule guessing whether action occurs certain time step. running example,
executable cross(X) hasLamp(X).

becomes cross(X, T0) -cross(X, T0) :- hasLamp(X, T0), person(X), next(T0, T1 ).
encodes guess whether time point 0 action cross(X) happen; again, type information person(X) added well next(T 0 , T1 ) ensure T0 last time point.
Step 5 (Initial State Constraints): Initial state constraints transformed static causation
rules Step 3, using constant 0 instead variable 1 thus need auxiliary predicate time stamp. instance,
initially : caused -across(X).

becomes, adding type information -across(X, 0) :- person(X).
Step 6 (Goal Query):
goal :

Finally, query q:

g1 (t1 ), . . . , gm (tm ), gm+1 (tm+1 ), . . . , gn (tn ) ? (l).

translated follows, goal reached new 0-ary predicate symbol:
goal reached :- g1 (t1 , l), . . . , gm (tm , l), gm+1 (tm+1 , l), . . . , gn (tn , l).
:- goal reached.
48

fiA NSWER ET P LANNING U NDER ACTION C OSTS

6.2.2 E XTENDING



RANSLATION



ACTION C OSTS

extended translation lpw (P) Kc problem P first includes rules lp(Pnc ), Pnc
results P stripping cost parts. Furthermore, following step added:
Step 7 (Action Costs):

action declaration form (1) nonempty costs-part, add:

(i) new rule rd form

costp (X1 , . . . , Xn , T, C) :- p(X1 , . . . , Xn , T), t1 , . . . , tm ,
c1 , . . . , ck , U = + 1.

(4)

costp new symbol, U new variables = {time U}. optimization,
U = + 1 present U occurs elsewhere r .
: costp (X1 , . . . , Xn , T, C). [C :]

(ii) weak constraint wcd form

(5)

example, cross action Quick Bridge Crossing Problem translated
costcross(X, T, WX):- cross(X, T), person(X), walk(X, WX).
: costcross(X, T, WX). [WX :]

showed previous work (Eiter et al., 2003a), answer sets lp(P) correspond
trajectories optimistic plans P. following theorem states similar correspondence result
lpw (P) optimal plans P. define, consistent set ground literals S, sets
ASj = {a(t) | a(t, j 1) S, act } sSj = {f (t) | f (t, j) S, f (t) Lf l }, j 0.
Theorem 6.1 (Answer Set Correspondence) Let P = hPD, qi (well-defined) K c planning
problem, let lpw (P) program. Then,
(i) optimistic plan P = hA1 , . . . , Al P supporting trajectory = hhs 0 , A1 , s1 i,
hs1 , A2 , s2 i, . . . , hsl1 , Al , sl ii P , exists answer set lp w (P)
Aj = ASj j = 1, . . . , l, sj = sSj , j = 0, . . . , l costP (P ) = costlpw (P) (S);
(ii) answer set lpw (P), sequence P = hA1 , . . . , Al solution P, i.e.,
optimistic plan, witnessed trajectory = hhs 0 , A1 , s1 i, hs1 , A2 , s2 i, . . . , hsl1 , Al , sl ii
costP (P ) = costlpw (P) (S), Aj = ASj sk = sSk j = 1, . . . , l
k = 0, . . . , l.
proof based resp. correspondence result K (Eiter et al., 2003a). details,
refer Appendix.
result definitions optimal cost plans optimal answer sets, conclude
following result:
Corollary 6.2 (Optimal answer set correspondence) well-defined K c planning problem
P = hPD, Q ? (l)i, trajectories = hhs 0 , A1 , s1 i, . . . , hsl1 , Al , sl ii optimal plans P P
correspond optimal answer sets lp w (P), Aj = ASj j = 1, . . . , l
sj = sSj , j = 0, . . . , l.
Proof. Aj , weak constraint (5) causes violation value cost j (a). Furthermore,
P onlyPcost violations. Thus, candidate answer set optimal
costlpw (P) (S) = lj=1 aAj costj (a) = costP (P ) minimal, i.e., corresponds optimal
plan.
2
similar correspondence result holds admissible plans:
49

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Corollary 6.3 (Answer set correspondence admissible plans) well-defined K c planning problem P = hPD, Q ? (l)i, trajectories = hhs 0 , A1 , s1 i, . . . , hsl1 , Al , sl ii admissible plans P P wrt. cost c correspond answer sets lp w (P) costlpw (P) (S) c,
Aj = ASj j = 1, . . . , l sj = sSj , j = 0, . . . , l.
secure planning, introduced technique check security optimistic plan
certain planning problem instances means logic program (Eiter et al., 2003a).
method carries planning action costs straightforward way, optimal resp. admissible secure plans similarly computed answer set programming.
6.3 Alternative Translation Smodels
Apart presented translation using weak constraints, one could choose alternative
approach translation answer set programming. Smodels (Simons et al., 2002) supports
another extension pure answer set programming allowing minimize sets predicates.
approach could used alternative formulation Step 7:
Step 7a:

action declarations nonempty costs-parts, add new rule form
cost(p, X1 , . . . , Xn , 0, . . . , 0, T, C) :- t1 , . . . , tm , c1 , . . . , ck , U = + 1.

(6)

similar Step 7 above, two differences: (1) action name p parameter, (2) add
l n parameters constant 0 X n l maximum arity actions
PD. necessary order get unique arity l + 2 predicate cost. Furthermore, add
occurs(p, X1 , . . . , Xn , 0, . . . , 0, T) :- p(X1 , . . . , Xn , T), t1 , . . . , tm ,.

(7)

second rule adds 0 parameters achieve unique arity l + 1 new
predicate occurs. Using Smodels syntax, compute optimal plans adding
minimize[occurs(A, X1, ..., Xl , T) : cost(A, X1, ..., Xl , T, C) = C].

Note Smodels support disjunction rule heads, need modify Step 4,
expressing action guess via unstratified negation Smodels choice rules.

7. Implementation
implemented experimental prototype system, DLV K , solving K planning problems (Eiter et al., 2003a). improved version prototype capable optimal
admissible planning respect extended syntax K c , available experiments
http://www.dlvsystem.com/K/ .
DLVK realized frontend DLV system (Faber & Pfeifer, 1996; Eiter et al.,
2000a). First, planning problem hand transformed described previous section.
Then, DLV kernel invoked produce answer sets. optimistic planning (optimal,
action costs defined) answer sets simply translated back suitable output user
printed.
case user specified secure/conformant planning performed, system
check security plans computed. normal (non-optimal) planning, simply done
checking answer set returned right transforming back user output. case
50

fiA NSWER ET P LANNING U NDER ACTION C OSTS

optimal secure planning, hand, candidate answer set generation DLV kernel
intercepted: kernel proceeds computing candidate answer sets, returning answer
set minimal violation cost value, running candidates. Here, order generate
optimal secure plans, planning frontend interrupts computation, allowing answer sets
represent secure plans considered candidates.
Checking plan security done rewriting translated program wrt. candidate answer
set/plan order verify whether plan secure. rewritten check program tested
separate invocation DLV kernel. details system architecture refer
(Eiter et al., 2003a)
7.1 Usage
Suppose background knowledge program depicted Figure 1 cost extensions
Section 3.3 stored files crossing.bk crossing.plan; then, invoking
program command line
dlv FPcrossing.plancrossing.bk planlength = 7

compute optimal plans solving problem seven steps. output find,
supporting trajectory, following optimal plan:
PLAN : crossTogether(joe, jack) : 2; cross(joe) : 1; takeLamp(william);
crossTogether(william, averell) : 10; takeLamp(jack);
cross(jack) : 2; crossTogether(joe, jack) : 2 COST : 17

action, cost shown colon, non-zero. switch -planlength=i
used set plan length; overrides plan length given query-part planing
problem. Using -planlength=5, get plans cost 19, cheaper plans
length.
user asked whether perform optional security check whether look
(optimal) plans, respectively. switch -FPsec used instead -FP obtain
secure plans only.
command line option -costbound=N effects computation admissible plans
respect cost N . example, resource problem described Section 5.3 solved
following call prototype:
dlv FPbuying.bkbuying.plan N = 10 planlength = 1 costbound = 6

Correctly, admissible plan found. calling system without cost bound,
prototype calculates following optimal cost plan:
PLAN : buy(newspaper, 1) : 1, buy(magazine, 2) : 6

COST : 7

current prototype supports simple bounded integer arithmetics. option -N=10 used
sets upper bound N = 10 integers may used program; builtin predicate #int true integers 0 . . . N . Setting N high enough, taking account
outcome built-in arithmetic predicates = B + C = B C, important get
correct results. details prototype given DLV K web site http://www.
dlvsystem.com/K/.
51

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

7.2 Experiments
Performance experimental results DLV K (without action costs optimal planning)
reported previous work (Eiter et al., 2003a). section, present encouraging experimental results planning action costs, particular parallel Blocks World TSP.
experiments performed Pentium III 733MHz machine 256MB main memory running SuSE Linux 7.2. set time limit 4000 seconds tested instance exceeding
limit indicated - result tables.
possible, report results CCALC CMBP, two logic-based planning
systems whose input languages (C+ resp. AR) capabilities similar K resp. K c .
CCALC. Causal Calculator (CCALC) model checker languages causal theories
(McCain & Turner, 1997). translates programs action language C+ language
causal theories turn transformed SAT problems; solved using SAT
solver (McCain & Turner, 1998). current version CCALC uses mChaff (Moskewicz et al.,
2001) default SAT solver. Minimal length plans generated iteratively increasing plan
length upper bound. CCALC written Prolog. tests, used version 2.04b
CCALC obtained <URL:http://www.cs.utexas.edu/users/tag/cc/
> trial version SICStus Prolog 3.9.1. used encodings taken (Lee & Lifschitz,
2001) parallel Blocks World adapted CCALC 2.0. encodings included
current download version system. sequential Blocks World adapted encodings
adding C+ command noConcurrency. resembles respective K command.
results CCALC include 2.30sec startup time.
CMBP. Conformant Model Based Planner (CMBP) (Cimatti & Roveri, 2000) based
model checking paradigm exploits symbolic Boolean function representation techniques
Binary Decision Diagrams (Bryant, 1986). CMBP allows computing sequential minimal
length plans, user declare upper bound plan length. input language
extension AR (Giunchiglia, Kartha, & Lifschitz, 1997). Unlike K action languages
C+ (Lee & Lifschitz, 2001), language supports propositional actions. CMBP
tailored conformant planning. results reported complement previous comparison
shows encoding sequential Blocks World CMBP (Eiter et al., 2003a). tests,
used CMBP 1.0, available <URL:http://sra.itc.it/people/roveri/cmbp/>.
7.2.1 B LOCKS W ORLD
Tables 14 show results different Blocks World encodings Section 5.1 several
configurations: P0 denotes simple instance Figure 3, P1P5 instances used
previous work (Eiter et al., 2003a; Erdem, 1999).
Table 1 shows results finding shortest sequential plan. second third column
show number blocks length shortest plan (i.e., least number moves) solving
respective blocks world instance. execution time solving problem using shortestplan encoding P Section 5.1 shown column five, using upper bound shown fourth
column plan length. Column six shows execution time finding shortest plan
incremental plan length search starting 0, similar method used CCALC.
remaining two columns show results CCALC CMBP.
52

fiA NSWER ET P LANNING U NDER ACTION C OSTS

Problem
P0
P1
P2
P3
P4
P5

#blocks
6
4
5
8
11
11

min. #moves (=#steps)
5
4
6
8
9
11

upper bound #steps
6
4
7
10
16
16

DLVK

DLVK
inc

0.48s
0.05s
0.24s
25.32s
-

0.29s
0.08s
0.27s
2.33s
8.28s
12.63s

CCALC
4.65s
3.02s
4.02s
10.07s
27.19s
32.27s

CMBP
21.45s
0.13s
8.44s
-

Table 1: Sequential Blocks World - shortest plans

Problem
P0
P0
P1
P2
P3
P4
P5

#blocks
6
6
4
5
8
11
11

#steps(fixed)
2
3
3
5
4
5
7

min. #moves
6
5
4
6
9
13
15

DLVK
0.05s
0.09s
0.04s
0.10s
0.21s
0.81s
327s

Table 2: Parallel Blocks World - cheapest plans: Minimal number moves fixed plan length ()

Table 2 shows execution times parallel blocks world fixed plan length
number moves minimized, i.e. problem () Section 5.1. used encoding Figure 2,
generates parallel serializable plans. CCALC CMBP allow optimizing
criteria plan length, results DLV K here.
Next, Table 3 shows results finding shortest parallel plan, i.e. problem () Section 5.1. First, minimal possible number steps given. processed instance (i) using
encoding P Section 5.1, (ii) without costs iteratively increasing plan length
(iii) using CCALC, iteratively increasing plan length plan found. every result,
number moves first plan computed reported separately. CMBP supports
sequential planning, included comparison.
Finally, Table 4 shows results combined optimizations () () parallel Blocks
World outlined Section 5.1. second column contains upper bound plan

upper bound
P0
P1
P2
P3
P4
P5

6
4
7
10
16
16

min. #steps
2
3
5
4
5
7

DLVK
#moves
6
5
9
-

time
0.52s
0.07s
0.39s
-

DLVK
inc
#moves
6
5
9
12
18
26

time
0.09s
0.08s
0.21s
0.43s
1.54s
3.45s

Table 3: Parallel Blocks World - shortest plan ()

53

CCALC
#moves
time
6
4.05s
4
2.95s
6
3.70s
9
7.69s
13
20.45s
15
23.22s

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

()
P0
P1
P2
P3
P4
P5

upper bound
6
4
7
10
16
16

steps/moves
3/5
3/4
5/6
5/8
9/9
11/11

()

DLVK

DLVK
inc

38.5s
0.07s
2.08s
-

0.18s
0.11s
0.21s
1.57s
-

CCALC
5.89s
3.47s
5.65s
15.73s
73.64s
167s

steps/moves
2/6
3/4
5/6
4/9
5/13
7/15

DLVK

DLVK
inc

0.26s
0.08s
0.78s
177s
-

0.09s
0.08s
0.28s
0.45s
1.86s
323s

Table 4: Parallel Blocks World - (),()

length respective instance. following three columns present results finding
shortest among cheapest plans, i.e. problem () Section 5.1:
DLVK refers results combined minimal encoding P described Section 5.1;
DLVK
inc refers results incrementally searching shortest among cheapest plans:

done means -costbound=i command line option taking minimal
sequential costs (i.e., shortest sequential plan length computed Table 1) upper
cost limit. encodings compute serializable plans, minimal sequential length
used cost limit special case.
CCALC similar technique used CCALC encoding bound costs additive fluents (Lee & Lifschitz, 2001).
Note incremental strategy (used DLV K
inc CCALC) takes advantage specific formulation parallel Blocks World problem: general, allowing parallel actions
necessarily serializable arbitrary costs, optimal parallel cost might differ
optimal sequential solution. particular, plans longer cheapest sequential plans (which, example, coincide shortest sequential plans) may need
considered. makes incremental search solution problem () infeasible general.
last test finding cheapest among shortest plans, is, problem () Section 5.1.
tested integrated encoding upper bound (P ) resp. incrementally finding
shortest plan. Unlike problem (), cannot derive fixed cost limit sequential
solution here; really need optimize costs, makes encoding CCALC infeasible.
Blocks World Results Blocks World experiments show DLV K solve various optimization tasks effective flexible way systems compared. hand,
already stated above, minimal plan length encodings Section 5.1, solve
problems tight upper bound plan length known. Iteratively increasing plan
length effective, especially upper bound much higher actual optimal solution. becomes drastically apparent execution times seem explode one instance
next, highly non-linear manner Table 1 solution P3 found
reasonable time whereas P4 P5 could solved within time limit 4000 seconds.
observation confirmed tables (instance P5 Table 2, etc.) partly explained
behavior underlying DLV system, geared towards plan search,
general purpose problem solver uses heuristics might work well cases.
particular, answer set generation process DLV, distinction made actions
54

fiA NSWER ET P LANNING U NDER ACTION C OSTS

fluents, might useful planning tasks control generation answer sets resp.
plans; may part investigations.
Interestingly, CCALC finds better quality parallel solutions problem () (cf. Table 3), i.e.
solutions fewer moves, although significantly slower system instances.
incremental encoding problem (), CCALC seems even effective system.
However, CCALC offers means optimization; allows admissible optimal
planning. makes approach flexible general. stated above, could fortunately
exploit fixed cost bound particular example CCALC, possible general
instances problem ().
Problem () intuitively harder simply finding shortest plan cheapest among
shortest plans general: problems always solved incrementally, ()
must consider plans lengths. longer plan may cheaper, cannot freeze plan
length (shortest) plan incrementally found.
7.2.2 TSP
experimental results TSP variable costs reported Tables 5 6. Unlike
blocks world, comparable systems available; none systems supports cost
optimal planning needed solving problem. Here, plan length always given
number cities.
Table 5 shows results TSP instance Austrian province capitals Figure 5
(nine cities, 18 connections), without exceptional costs Section 5.2 (with without subscript exc table). instances reported table different cost exceptions
(we, lwe, rnd) described below.
Results bigger TSP instances, given capitals 15 members European
Union (EU) varying connection graphs exceptional costs shown Table 6.
used flight distances (km) cities connection costs. Instances TSP EU 1TSPEU 6
generated randomly choosing given number connections possible connections 15 cities. Note TSP EU 1 solution; time reported
DLVK terminated, instances first optimal plan found.
tested instances practical relevance simply randomly choosing
connections: TSPEU 7 instance taken flight connections three carriers
(namely, Star Alliance, Alitalia, Luxair), TSP EU 8 included direct connections 1500km. capital hopping interest small airplane limited
range, instance.
instance Tables 56 measured execution time:
without exceptional costs,
50% costs connections Saturdays Sundays (weekends, we)
50% costs connections Fridays, Saturdays Sundays (long weekends, lwe),
random cost exceptions (rnd): added number randomly generated exceptions costs 0 10 TSP Austria 0 3000 instances
EU1 EU8.
55

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Instance
TSPAustria
TSPAustria,exc
TSPAustria,we
TSPAustria,lwe
TSPAustria,rnd
TSPAustria,rnd
TSPAustria,rnd
TSPAustria,rnd

#cost exceptions
0
2
36
54
10
50
100
200

cost/time
15/0.31s
15/0.32s
12/0.34s
11/0.35s
14/0.30s
15/0.31s
23/0.35s
36/0.37s

Table 5: TSP Results TSPAustria varying exceptions

Instance
TSPEU 1
TSPEU 1,we
TSPEU 1,lwe
TSPEU 1,rnd
TSPEU 1,rnd
TSPEU 1,rnd
TSPEU 1,rnd
TSPEU 2
TSPEU 2,we
TSPEU 2,lwe
TSPEU 2,rnd
TSPEU 2,rnd
TSPEU 2,rnd
TSPEU 2,rnd
TSPEU 3
TSPEU 3,we
TSPEU 3,lwe
TSPEU 3,rnd
TSPEU 3,rnd
TSPEU 3,rnd
TSPEU 3,rnd
TSPEU 4
TSPEU 4,we
TSPEU 4,lwe
TSPEU 4,rnd
TSPEU 4,rnd
TSPEU 4,rnd
TSPEU 4,rnd
TSPEU 5
TSPEU 5,we
TSPEU 5,lwe
TSPEU 5,rnd
TSPEU 5,rnd
TSPEU 5,rnd
TSPEU 5,rnd
TSPEU 5,rnd

#conn.
30
30
30
30
30
30
30
30
30
30
30
30
30
30
35
35
35
35
35
35
35
35
35
35
35
35
35
35
40
40
40
40
40
40
40
40

#except.
0
60
90
100
200
300
400
0
60
90
100
200
300
400
0
70
105
100
200
300
400
0
70
105
100
200
300
400
0
80
120
100
200
300
400
500

cost/time
-/9.11s
-/11.93s
-/13.82s
-/11.52s
-/12.79s
-/14.64s
-/16.26s
16213/13.27s
13195/16.41s
11738/18.53s
15190/15.54s
13433/16.31s
13829/18.34s
13895/20.59s
18576/24.11s
15689/28.02s
14589/30.39s
19410/26.75s
22055/29.64s
18354/31.54s
17285/32.66s
16533/36.63s
12747/41.72s
11812/43.12s
15553/39.17s
13216/41.19s
16413/43.51s
13782/45.69s
15716/91.83s
12875/97.73s
12009/100.14s
13146/85.69s
12162/83.44s
12074/76.81s
12226/82.97s
13212/82.53s

Instance
TSPEU 6
TSPEU 6,we
TSPEU 6,lwe
TSPEU 6,rnd
TSPEU 6,rnd
TSPEU 6,rnd
TSPEU 6,rnd
TSPEU 6,rnd
TSPEU 7
TSPEU 7,we
TSPEU 7,lwe
TSPEU 7,rnd
TSPEU 7,rnd
TSPEU 7,rnd
TSPEU 7,rnd
TSPEU 7,rnd
TSPEU 7,rnd
TSPEU 7,rnd
TSPEU 8
TSPEU 8,we
TSPEU 8,lwe
TSPEU 8,rnd
TSPEU 8,rnd
TSPEU 8,rnd
TSPEU 8,rnd
TSPEU 8,rnd
TSPEU 8,rnd
TSPEU 8,rnd
TSPEU 8,rnd

#conn.
40
40
40
40
40
40
40
40
55
55
55
55
55
55
55
55
55
55
64
64
64
64
64
64
64
64
64
64
64

#except.
0
80
120
100
200
300
400
500
0
110
165
100
200
300
400
500
600
700
0
128
192
100
200
300
400
500
600
700
800

cost/time
17483/142.7s
14336/150.3s
13244/154.7s
15630/142.5s
14258/137.2s
11754/120.5s
11695/111.4s
12976/120.8s
15022/102.6s
12917/112.2s
11498/116.2s
13990/104.2s
12461/100.8s
13838/106.9s
12251/96.58s
16103/109.2s
14890/110.3s
17070/110.7s
10858/3872s
9035/3685s
8340/3324s
10283/2603s
9926/1372s
10028/1621s
8133/597.7s
8770/573.3s
8220/360.7s
6787/324.6s
11597/509.5s

Table 6: TSP Various instances capitals 15 EU members
56

fiA NSWER ET P LANNING U NDER ACTION C OSTS

TSP Results Instance TSPEU 8 shows limits system: given data allows many
possible tours, finding optimal one gets tricky. hand, realistic instance
TSPEU 7 real airline connections solved rather quickly, surprising:
airlines central airport (for instance Vienna Austrian Airlines) direct connections
destinations served. allows much fewer candidate answer sets, (as
reality) number airlines consider limited. E.g., TSP EU 7 solution
two Star Alliance, Alitalia, Luxair allowed. course, cannot compete
dedicated TSP solvers/algorithms, able solve much bigger TSP instances
considered here. However, knowledge, none solvers deal features
incomplete knowledge, defaults, time dependent exceptional costs, etc. directly. results even
show execution times stable yet case many exceptions. contrast, instance TSP EU 8
shows exceptions cause significant speedup. due heuristics used
underlying DLV system, single better solutions faster costs spread evenly
TSPEU 8 without exceptional costs.
Note that, experimented alternative Smodels translation sketched Section 6.3. refrain detailed discussion here, since (i) translation optimized DLV
Smodels performance worse (around factor 10 tested TSP instances) DLV (ii)
integrated planning frontend available Smodels providing high-level planning language. Nevertheless, shown approach can, minor modifications, adopted
planning system based Smodels.

8. Related Work
last years, widely recognized plan length alone one criterion
optimized planning. Several attempts made extend planners consider action
costs.
PYRRHUS system (Williams & Hanks, 1994) extension UCPOP planning
allows optimal planning resources durations. Domain-dependent knowledge
added direct heuristic search. utility model defined planning problem
used express optimization function. system supports language extension
ADL (Pednault, 1989), predecessor PDDL (Ghallab et al., 1998). algorithm
synthesis branch-and-bound optimization least-commitment, plan-space planner.
approaches based heuristic search include use A* strategy together
action costs heuristics (Ephrati, Pollack, & Mihlstein, 1996) work Refanidis
Vlahavas use multi-criteria heuristics obtain near-optimal plans, considering multiple criteria
apart plan length alone (Refanidis & Vlahavas, 2001). However, described heuristics
fully admissible, guarantees optimal plans certain restrictions (Haslum & Geffner,
2000). fact, heuristic state-space planners able guarantee optimality.
powerful approach suggested Nareyek, describes planning resources
structural constraint satisfaction problem (SCSP), solves problem local search
combined global control. However, work promotes inclusion domain-dependent
knowledge; general problem unlimited search space, declarative high-level language provided (Nareyek, 2001).
Among related approaches, Kautz Walser generalize Planning Satisfiability
approach use integer optimization techniques encoding optimal planning resource pro57

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

duction/consumption (Kautz & Walser, 1999). First, recall integer logic programming
generalizes SAT, SAT formula translated system inequalities. Second, extend effects preconditions actions similar STRIPS extension proposed Koehler
modeling resource consumption/production (Koehler, 1998). Kautz Walser allow arbitrary
optimization functions use non-declarative, low-level representation based algebraic modeling language AMPL (Fourer, Gay, & Kernighan, 1993). mention Koehlers
STRIPS-like formalization mapped approach. However, express nondeterminism incomplete knowledge. implementation approach called ILPPLAN, uses AMPL package (http://www.ampl.com/). Unfortunately, AMPL
freely available, could compare system approach experimentally.
Lee Lifschitz describe extension C+ action language C allows intuitive encoding resources costs means called additive fluents (Lee & Lifschitz,
2001). way admissible planning realized, optimization considered
framework far. implementation planner based language CCALC (McCain,
1999) already described previous section. Another implementation planning system based action language C Cplan (Giunchiglia, 2000; Ferraris & Giunchiglia,
2000). Cplan system mainly focuses conformant planning support advanced
features C+. Furthermore, code longer maintained.
Son Pontelli propose translate action language B prioritized default theory answer
set programming. allow express preferences actions rules object level
interpreter part input language (Son & Pontelli, 2002). However,
preferences orthogonal approach model qualitative preferences opposed
overall value function plans/trajectories.

9. Conclusion Outlook
work continues research stream pursues usage answer set programming
building planning systems offer declarative planning languages based action languages,
planning tasks specified high level abstraction (Lifschitz, 1999a, 1999b).
representation practical planning problems, languages must high expressiveness
provide convenient constructs language elements.
Towards goal, presented planning language K c , extends declarative
planning language K (Eiter et al., 2000b, 2003a) action costs taken account
generating optimal plans, i.e., plans least total execution cost, admissible plans
wrt. given cost bound, i.e., plans whose total execution cost stays within given limit. basis
implementation issues, investigated computational complexity major planning tasks language, derived complexity results sharply characterizing
computational cost. Furthermore, presented transformation optimal admissible
planning problems K c logic programming optimal answer set semantics (Buccafurri
et al., 1997, 2000), described DLV K prototype implemented top KR tool
DLV, computes semantics.
shown, Kc allows representation intricate planning problems. particular,
demonstrated variant Traveling Salesperson Problem (TSP), could
conveniently specified Kc . strength Kc that, via underlying language K, states
knowledge, i.e., incomplete states, suitably respected secure plans, i.e., conformant plans
58

fiA NSWER ET P LANNING U NDER ACTION C OSTS

work circumstances, including nondeterministic action effects. K c flexible
language which, exploiting time-dependent action costs, allows representation planning
various optimality criteria cheapest plans, shortest plans, combinations thereof.
experiments shown various instances problems considered, including
realistic instances TSP variant, could decently solved. hand, current
version DLVK scale large problem instances general, and, unsurprisingly,
compete high-end planning tools specialized algorithms particular problem
TSP. see shortcoming, though, since main goal point demonstrate usefulness expressive capabilities formalism easily represent non-trivial
planning optimization tasks, especially involved viewpoint knowledge
representation. way, non-trivial instances problems medium size (which one may
often encounter) solved little effort.
Several issues remain work. implementation, performance improvements
may gained via improvements underlying DLV engine, subject current work.
Furthermore, alternative, efficient transformations Kc logic programming might researched, e.g. ones involve preprocessing planning problem performing means-end analysis simplify logic program constructed.
Another issue language extensions. example, crucial difference
approach resource-based approaches former hinges action costs, latter
build fluent values, somewhat different view quality plan. possible way
encompass language allow dynamic fluent values contribute action costs;
needs carefully elaborated, though: deterministic planning complete knowledge extension straightforward, non-deterministic domains incomplete knowledge
would possibly result ambiguities. Different trajectories plan possibly yield different
costs fluent values contribute action costs. favor intuitive definition plan costs
optimality refrained extension current state.
possible extension negative action costs, useful modeling producer/consumer relations among actions resources. Allowing different priorities among
actions, i.e., different cost levels, would increase flexibility allow optimizing different
criteria once. Finally, duration actions important issue. current language,
effects actions assumed materialize next state. coding techniques,
may express delayed effects several states time and/or interleaving actions, constructs
language would desirable. Investigating issues part ongoing future work.

Acknowledgments
grateful Joohyung Lee help using CCALC Paul Walser useful
informations ILPPLAN. Furthermore, thank Michael Gelfond interesting discussions
suggestions, anonymous reviewers detailed helpful comments.
work supported FWF (Austrian Science Funds) projects P14781
Z29-N04 European Commission project FET-2001-37004 WASP IST-200133570 INFOMIX.
preliminary, shorter version paper presented 8th European Conference
Logics Artificial Intelligence (JELIA02), Cosenza, Italy, September 2002.
59

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Appendix A. Language K
appendix contains, shortened form, definition language K translation K
answer set programs; see (Eiter et al., 2003b, 2003a) details examples.
A.1 Basic Syntax
assume act , f l , typ disjoint sets action, fluent type names, respectively, i.e.,
predicate symbols arity 0, disjoint sets con var constant variable symbols.
Here, f l , act describe dynamic knowledge typ describes static background knowledge.
action (resp. fluent, type) atom form p(t 1 , . . . , tn ), p act (resp. f l , typ ) arity n
t1 , . . . , tn con var . action (resp. fluent, type) literal l action (resp. fluent, type)
atom negation a, (alternatively, ) true negation symbol. define
.l = l = .l = l = a, atom. set L literals consistent,
L .L = . Furthermore, L+ (resp. L ) set positive (resp. negative) literals L.
set action (resp. fluent, type) literals denoted L act (resp. Lf l , Ltyp ). Furthermore, Lf l,typ
+
= Lf l Ltyp , Ldyn = Lf l L+
act , L = Lf l,typ Lact .
actions fluents must declared using statements follows.
Definition A.1 (action, fluent declaration) action (resp. fluent) declaration, form:
p(X1 , . . . , Xn ) requires t1 , . . . , tm

(8)

+
var n 0 arity p, , . . . ,
p L+
1

act (resp. p Lf l ), X1 , . . . , Xn
Ltyp , 0, every Xi occurs t1 , . . . , tm .

= 0, keyword requires may omitted. Causation rules specify dependencies
fluents fluents actions.
Definition A.2 (causation rule) causation rule (rule, short) expression form
caused f b1 , . . . , bk , bk+1 , . . . , bl a1 , . . . , , am+1 , . . . ,

(9)

f Lf l {false}, b1 , . . . , bl Lf l,typ , a1 , . . . , L, l k 0, n 0.
Rules n = 0 static rules, others dynamic rules. l = 0 (resp. n = 0), (resp.
after) omitted; l = n = 0, caused optional.
access parts causation rule r h(r) = {f }, post + (r) = {b1 , . . . , bk }, post (r) =
{bk+1 , . . . , bl }, pre+ (r) = {a1 , . . . , }, pre (r) = {am+1 , . . . , }, lit(r) = {f, b1 , . . . , bl ,
a1 , . . . , }. Intuitively, pre(r) = pre + (r) pre (r) (resp. post(r) = post+ (r) post (r))
accesses state (resp. after) action(s) happen.
Special static rules may specified initial states.
Definition A.3 (initial state constraint) initial state constraint static rule form (9)
preceded initially.
language K allows conditional execution actions, several alternative executability
conditions may specified.
60

fiA NSWER ET P LANNING U NDER ACTION C OSTS

Definition A.4 (executability condition) executability condition e expression form
executable b1 , . . . , bk , bk+1 , . . . , bl

(10)

L+
act b1 , . . . , bl L, l k 0.
l = 0 (i.e., executability unconditional), skipped. parts e accessed h(e) =
{a}, pre+ (e) = {b1 , . . . , bk }, pre (e) = {bk+1 , . . . , bl }, lit(e) = {a, b1 , . . . , bl }. Intuitively,
pre(e) = pre+ (e) pre (e) refers state actions suitability evaluated.
state action execution involved; convenience, define post+ (e) = post (e) = .
causal rules executability conditions must satisfy following condition,
similar safety logic programs: variable default-negated type literal must occur
literal default-negated type literal. safety requested variables appearing
literals. reason variables appearing fluent action literals implicitly safe
respective type declarations.
Notation. causal rule, initial state constraint, executability condition r {post, pre, b},
define (r) = + (r) (r), bs (r) = posts (r) pres (r).
A.1.1 P LANNING OMAINS



P LANNING P ROBLEMS

Definition A.5 (action description, planning domain) action description hD, Ri consists
finite set action fluent declarations finite set R safe causation rules, safe initial
state constraints, safe executability conditions contain positive cyclic dependencies among actions. K planning domain pair PD = h, ADi, disjunction-free
normal Datalog program (the background knowledge) safe total well-founded
model (cf. (van Gelder, Ross, & Schlipf, 1991)) 8 AD action description. call PD
positive, default negation occurs AD.
Definition A.6 (planning problem) planning problem P = hPD, qi pair planning domain PD query q, i.e.,
g1 , . . . , gm , gm+1 , . . . , gn ? (i)

(11)

g1 , . . . , gn Lf l variable-free, n 0, 0 denotes plan length.
A.2 Semantics
start preliminary definition typed instantiation planning domain.
similar grounding logic program, difference correctly typed
fluent action literals generated.
Let PD = h, hD, Rii planning domain, let (unique) answer set (Gelfond & Lifschitz, 1991). Then, (p(X 1 , . . . , Xn )) legal action (resp. fluent) instance action (resp. fluent) declaration form (8), substitution defined X1 , . . . , Xn
{(t1 ), . . . , (tm )} . LPD denote set legal action fluent instances. instantiation planning domain respecting type information follows.
8. total well-founded model, existing, corresponds unique answer set datalog program. Allowing
multiple answer sets would eventually lead ambiguities language.

61

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Definition A.7 (typed instantiation) planning domain PD = h, hD, Rii, typed instantiation given PD = h, hD, Rii, grounding (over con )
R = {(r) | r R, r }, r set substitutions variables r using
con , lit((r)) Ldyn LPD (.LPD L
f l ).
words, PD replace R ground versions, keep latter
rules atoms fluent action literals agree declarations. say
PD = h, hD, Rii ground, R ground, moreover well-typed, PD
PD coincide.
A.2.1 TATES



RANSITIONS

Definition A.8 (state, state transition) state w.r.t planning domain PD consistent set
Lf l (lit(PD) lit(PD) ) legal fluent instances negations. state transition
tuple = hs, A, s0 s, s0 states Lact lit(PD) set legal action
instances PD.
Observe state necessarily contain either f f legal instance f
fluent, may even empty (s = ). State transitions constrained; done
definition legal state transitions below. proceed analogy definition answer sets
(Gelfond & Lifschitz, 1991), considering first positive (i.e., involving positive planning domain)
general planning problems.
follows, assume PD = h, hD, Rii well-typed ground planning domain
unique answer set . PD, respective concepts defined
typed grounding PD.
Definition A.9 (legal initial state) state 0 legal initial state positive PD, 0
least set (w.r.t. ) post(c) 0 implies h(c) s0 , initial state constraints
static rules c R.
positive PD state s, set L +
act called executable action set w.r.t. s,
exists executability condition e R h(e) = {a}, pre + (e)Lf l,typ sM ,
+

pre+ (e)L+
act A, pre (e)(Lact sM ) = . Note definition allows modeling
dependent actions, i.e. actions depend execution actions.
Definition A.10 (legal state transition) Given positive PD, state transition = hs, A, 0
called legal, executable action set w.r.t. 0 minimal consistent set satisfies
causation rules w.r.t. . is, every causation rule r R, (i) post(r) 0 ,
(ii) pre(r) Lf l,typ , (iii) pre(r) Lact hold, h(r) 6= {false}
h(r) s0 .
extended general well-typed ground PD containing default negation using
Gelfond-Lifschitz type reduction positive planning domain (Gelfond & Lifschitz, 1991).
Definition A.11 (reduction) Let PD ground well-typed planning domain, let =
hs, A, s0 state transition. Then, reduction PD = h, hD, Rt ii PD planning
domain Rt obtained R deleting
62

fiA NSWER ET P LANNING U NDER ACTION C OSTS

1. r R, either post (r)(s0 ) 6= pre (r)(sAM ) 6= ,
2. default literals L (L L) remaining r R.
Note PD positive ground. extend definitions follows.
Definition A.12 (legal initial state, executable action set, legal state transition) planning
domain PD, state s0 legal initial state, s0 legal initial state PD h,,s0 ; set
executable action set w.r.t. state s, executable w.r.t. PD hs,A,i ; and, state transition
= hs, A, s0 legal, legal PD .
A.2.2 P LANS
Definition A.13 (trajectory) sequence state transitions = hhs 0 , A1 , s1 i, hs1 , A2 , s2 i, . . .,
hsn1 , , sn ii, n 0, trajectory PD, s0 legal initial state PD hs i1 , Ai , si i,
1 n, legal state transitions PD.
n = 0, = hi empty s0 associated explicitly.
Definition A.14 (optimistic plan) sequence action sets hA 1 , . . . , Ai i, 0, optimistic
plan planning problem P = hPD, qi, trajectory = hhs 0 , A1 , s1 i, hs1 , A2 , s2 i, . . . ,
hsi1 , Ai , si ii exists PD accomplishes goal, i.e., {g 1 , . . . gm } si {gm+1 , . . . , gn }
si = .
Optimistic plans amount plans, valid plans etc defined literature. term
optimistic stress credulous view definition, respect incomplete fluent
information nondeterministic action effects. cases, execution optimistic plan
P might fail reach goal. thus resort secure plans.
Definition A.15 (secure plans (alias conformant plans)) optimistic plan hA 1 , . . . , secure plan, every legal initial state 0 trajectory = hhs0 , A1 , s1 i, . . . , hsj1 , Aj , sj ii
0 j n, holds (i) j = n accomplishes goal, (ii) j < n, j+1
executable sj w.r.t. PD, i.e., legal transition hs j , Aj+1 , sj+1 exists.
Note plans admit general concurrent execution actions. call plan hA 1 , . . . ,
sequential (or non-concurrent), |A j | 1, 1 j n.
A.3 Macros
K includes several macros shorthands frequently used concepts. Let L +
act denote
action atom, f Lf l fluent literal, B (possibly empty) sequence b 1 , . . . , bk , bk+1 , . . . ,
bl bi Lf l,typ , = 1, . . . , l, (possibly empty) sequence 1 , . . . , ,
am+1 , . . . , aj L, j = 1, . . . , n.
Inertia allow easy representation fluent inertia, K provides
inertial f B A.

Defaults



caused f .f, B f, A.

default value fluent expressed shortcut
default f.



caused f .f.

effect unless causation rule provides evidence opposite value.
63

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Totality

reasoning incomplete, total knowledge K provides (f positive):
total f B A.



caused f f, B A.
caused f f, B A.

instance useful model non-deterministic action effects. discussion
full impact statement modeling planning incomplete knowledge non-determinism,
refer previous paper language K (Eiter et al., 2003b).
State Integrity

integrity constraints refer preceding state, K provides
forbidden B A.

Non-executability



caused false B A.

specifying action executable, K provides

nonexecutable B.



caused false a, B.

definition, nonexecutable overrides executable case conflicts.
Sequential Plans exclude simultaneous execution actions, K provides
noConcurrency.



caused false a1 , a2 .

a1 a2 range possible actions 1 , a2 LPD Lact a1 6= a2 .
macros, B (resp. A) omitted, B (resp. A) empty.

Appendix B. Proofs
Proof Theorem 4.4: Membership (i): problems NP resp. NPMV, since l polynomial size P, optimistic plan P = hA 1 , . . . , Al P supporting trajectory
= ht1 , . . . , ti P guessed and, Proposition 4.1, verified polynomial time. Furthermore, costP (P ) b efficiently checked, since costP (P ) easily computed (all costs
constants).
Hardness (i): K fragment K c , K planning problem viewed problem
deciding existence resp. finding admissible plan wrt. cost 0. previously shown
(Eiter et al., 2003b), deciding existence optimistic plan given K planning problem
NP-hard fixed plan length l; hence, NP-hard Kc .
show finding optimistic plan hard NPMV reduction well-known
SAT problem, cf. (Papadimitriou, 1994), whose instances CNFs = c 1 ck clauses ci =
Li,1 Li,mi , Li,j classical literal propositional atoms X = {x 1 , . . . , xn }.
Consider following planning domain PD :
fluents :
actions :

x1 . . . . xn . state0. state1.
c1 costs 1. . . . ck costs 1.
ax1 . . . . axn .
initially : total x1 . . . . total xn .
caused state0.
always :
caused state1 state0.
executable c1 .L1,1 , . . . , .L1,m1 .
forbidden .L1,1 , . . . , .L1,m1 , c1 .

executable ck .Lk,1 , . . . , .Lk,mk .
forbidden .Lk,1 , . . . , .Lk,mk , ck .
executable ax1 x1 . forbidden x1 , ax1 .

executable axn xn . forbidden xn , axn .

64

fiA NSWER ET P LANNING U NDER ACTION C OSTS

fluents xi state0 total statements initially-section encode candidate truth assignments. subsequent statements force c j executed iff corresponding
clause violated truth assignment encoded initial state. final pairs executable
forbidden statements force actions ax executed iff corresponding fluents x hold.
necessary directly extract computed truth assignments plan,
since dealing function class. fluent state1 identifies state time 1.
Consider planning problem P = hPD , state1?(1)i. Clearly, optimistic plan
P P corresponds truth assignment P X vice versa, costP (P ) number
clauses violated P . Thus, admissible optimistic plans P wrt. cost 0 correspond 1-1
satisfying assignments . Clearly, constructing P efficiently possible,
constructing satisfying truth assignment corresponding plan P (because actions
axi ). concludes hardness proof.
Membership (ii): Since security optimistic plan admissible wrt. cost k checked,
Proposition 4.1, call P2 -oracle, membership P3 resp. P3 MV follows
analogous considerations (i) (where oracle needed).
Hardness (ii): decision variant, P3 -hardness immediately inherited P3 completeness deciding existence secure plan problem language K,
hardness even fixed plan length (Eiter et al., 2003b). plan computation variant, give
reduction following P3 MV-complete problem: instance open QBF
Q[Z] = XY [X, Y, Z]
X = x1 , . . . , xl , = y1 , . . . , ym , Z = z1 , . . . , zn , respectively, [X, Y, Z]
(w.l.o.g.) 3CNF formula X, , Z. solutions S(I) truth assignments Z
Q[Z] satisfied.
Suppose [X, Y, Z] = c1 . . . ck ci = ci,1 ci,2 ci,3 . consider following
planning domain PDQ[Z] Q[Z], variant planning domain given proof
Theorem 5.5 (Eiter et al., 2003b):
fluents :
x1 . . . . xl . y1 . . . . ym . z1 . . . . zn . state0. state1.
actions :
az1 costs 0. . . . azn costs 0.
initially : total x1 . . . . total xl .
caused state0.
always :
caused state1 state0.
executable az1 . executable az2 . . . . executable azn .
caused x1 x1 . caused x1 x1 .

caused xl xl . caused xl xl .
total y1 state0. . . . total ym state0.
caused z1 az1 . caused z1 az1 .

caused zn azn . caused zn azn .
forbidden .C1,1 , .C1,2 , .C1,3 state0.

forbidden .Ck,1 , .Ck,2 , .Ck,3 state0.
|X|

2|X| many legal initial states s1 , . . . , s2 PDQ[Z] , correspond 1-1
possible truth assignments X initial states contain state0. Starting initial
state si , executing set actions represents truth assignment variables Z. Since
65

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

actions always executable, 2 |Z| executable action sets A1 , . . . , A2|Z| , represent
truth assignments Z.
|Y |
pair si Aj exist 2|Y | many successor state candidates si,1 , . . . , si,2 ,
contain fluents according truth assignment X represented , fluents according
truth assignment Z represented j , fluents according truth assignment ,
fluent state1. candidate states, satisfying clauses [X, Y, Z] legal,
virtue forbidden statements.
hard see optimistic plan form P = hA 1 (where A1 {azi | zi Z})
goal state1 exists wrt. PDQ[Z] iff assignment variables X Z
formula [X, Y, Z] satisfied. Furthermore, P secure iff A1 represents assignment
variables Z that, regardless assignment variables X chosen
(corresponding legal initial state ), assignment variables
clauses [X, Y, Z] satisfied (i.e., least one state si,k reachable si executing
A1 ); si,k contains state1. words, P secure iff [X, Y, Z] true. Thus,
admissible secure plans PDQ[Z] wrt. cost 0, correspond 1-1 assignments Z
Q[Z] true.
Since PDQ[Z] constructible [X, Y, Z] polynomial time, follows computing
secure plan P = hPDQ[Z] , qi, q = state1 ? (1), P3 MV-hard.
2
Proof Theorem 4.5: Membership (i): Concerning membership, performing binary search
range [0, max] (where max upper bound plan costs plan polynomial
length l given l times sum action costs) find least integer v
optimistic plan P P admissible wrt. cost v exists (if optimistic plan exists);
clearly, costP (P ) = v costP = v, thus plan P optimal. Since max
single exponential representation size P, binary search, thus computing cost P ,
is, Theorem 4.4, feasible polynomial time NP oracle. Subsequently, construct
optimistic plan P costP (P ) = costP extending partial plan Pi = hA1 , . . . , Ai i,
= 0, . . . , l 1 step step follows. Let = {a 1 , . . . , } set legal action
instances. initialize Bi+1 := ask oracle whether Pi completed optimistic
plan P = hA1 , . . . , Al admissible wrt. costP Ai+1 (Bi+1 \ {a1 }). answer
yes, update Bi+1 := Bi+1 \ {a1 }, else leave Bi+1 unchanged. repeat test
aj , j = 2, 3, . . . , m; resulting Bi+1 action set Pi+1 = hA1 , . . . , Ai , Ai+1
Ai+1 = Bi+1 completed optimistic plan admissible wrt. cost P . Thus, Ai+1
polynomial-time constructible NP oracle.
summary, construct optimal optimistic plan polynomial time NP oracle.
Thus, problem FP2 .
Hardness (i): show hardness plan length l = 1 reduction problem MAX WEIGHT
SAT (Papadimitriou, 1994), instance SAT instance = c 1 ck proof
Theorem 4.4.(i), plus positive integer weightsP
w , = 1, . . . , k. Then, S(I) contains
truth assignments X wsat () = : ci =true wi maximal.
end, take planning domain PD proof Theorem 4.4 modify
cost ci wi , = 1, . . . , k, thus constructing new planning domain PD . Consider
planning problem PI = hPDI , state1?(1)i. Since actions cj actions nonzero
cost, plan (corresponding toP
truth assignment )
P associated sum weights
violated clauses, wvio () = ( ki=1 wi ) wsat (). Since ki=1 wi constant I, minimizing
66

fiA NSWER ET P LANNING U NDER ACTION C OSTS

wvio () equivalent maximizing wsat (). Hence, one-to-one correspondence
optimal optimistic plans PI (for wvio () minimal) maximal truth assignments I.
Furthermore, computing PI extracting MAX-WEIGHT SAT solution optimal
plan P efficiently possible. proves FP2 -hardness.
Membership (ii): proof similar membership proof (i), uses oracle asks
completion partial secure plan P = hA1 , . . . , Ai secure plan P = hA1 , . . . , Al
Ai+1 (Bi+1 \ {aj }) P admissible wrt. costP , rather partial optimistic plan.
oracle is, easily seen, P3 . Thus, computing optimal secure plan F P4 .
Hardness (ii): show hardness reduction following problem, F P4 complete (cf. (Krentel, 1992)): Given open QBF Q[Z] = XY [X, Y, Z] proof
Theorem 4.4.(ii), compute lexicographically first truth assignment Z Q[Z]
satisfied.
accomplished changing cost action az PDQ[Z] 0 2ni ,
= 1, . . . , n. Let PD 0 [Q[Z]] resulting planning domain. Since cost az (i.e., assigning
zi value true) greater sum costs az j + 1 j n, optimal
secure plan planning problem hPD 0 [Q[Z]], state1 ? (1)i amounts lexicographically
first truth assignment Z Q[Z] satisfied. Thus, FP4 -hardness problem follows.
2
Proof Theorem 6.1: prove result applying well-known Splitting Set Theorem
logic programs (Lifschitz & Turner, 1994). theorem applies logic programs
split two parts one them, bottom part, refer predicates defined
top part all. answer sets bottom part extended answer sets
whole program looking remaining (top) rules. Informally, splitting set
set U ground literals defining bottom part bU () program. answer set Sb
bU () used reduce remaining rules \ b U () program eU ( \ bU (), Sb )
involving classical literals occur b U (), evaluating literals b U ()
wrt. Sb . answer set Se eU ( \ bU (), Sb ), set = Sb Se answer set
original program.
Disregarding weak constraints, split program lp w (P) bottom part consisting
lp(Pnc ), Pnc P cost information stripped off, top part containing
remaining rules; derive correspondence optimistic plans P answer sets
lpw (P) similar correspondence result lp(P nc ) (Eiter et al., 2003a).
detail, Theorem 3.1 (Eiter et al., 2003a) states K-planning problem P correspondence answer sets lp(P) supporting trajectories optimistic plans
P = hA1 , . . . , Al items (i) (ii), costs discarded. Thus, answer set 0 lp(Pnc )
corresponds trajectory 0 optimistic plan P 0 Pnc vice versa.
follows, talking lp(P nc ) lpw (P), mean respective grounded
logic programs. lpw (P) augments lp(Pnc ) rules (4) weak constraints (5). Let U =
lit(lp(Pnc )) set literals occurring lp(P nc ). Clearly, U splits lpw (P) defined
(Lifschitz & Turner, 1994), disregard weak constraints lp w (P), since rules form
(4) introduce new head literals. Consequently, get b U (lpw (P)) = lp(Pnc ). Then,
answer set 0 lp(Pnc ), rule eU (lpw (P) \ bU (lpw (P)), 0 ) form
costa (x1 , . . . , xn , t, c) :- Body.
67

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

fact rules positive, conclude respect split U ,
answer set 0 lp(Pnc ) induces unique answer set 0 lpw (P). Therefore, modulo
costs, correspondence supporting trajectories candidate answer sets claimed
follows directly Theorem 3.1 (Eiter et al., 2003a).
remains prove costP (P ) = costlpw (P) (S) holds candidate answer sets corresponding optimistic plan P = hA 1 , . . . , Al P. correspondence shown above,
action p(x1 , . . . , xn ) Aj corresponds exactly one atom p(x 1 , . . . , xn , j 1) ASj ,
j {1, . . . , l}. Therefore, p(x1 , . . . , xn ) declared non-empty cost part, (4)
well-definedness, modulo x1 , . . . , xn , exactly one fact costp (x1 , . . . , xn , j 1, c)
model eU (lpw (P) \ bU (lpw (P)), S).
Furthermore, definition (4), c = costj (p(x1 , . . . , xn )), i.e., cost action
instance p(x1 , . . . , xn ) time j. Consequently,
Pl
P violation value weak constraint wc
w
form (5) p lp (P) costwc (S) =
j=1
p(x1 ,...,xn )Aj costj (p(x1 , . . . , xn )). Since
violation values stem weak constraints (5), total cost lpw (P) (S) = costP (P ).
proves result.
2

References
Blum, A. L., & Furst, M. L. (1997). Fast Planning Planning Graph Analysis. Artificial
Intelligence, 90, 281300.
Bonet, B., & Geffner, H. (2000). Planning Incomplete Information Heuristic Search
Belief Space. Chien, S., Kambhampati, S., & Knoblock, C. A. (Eds.), Proceedings
Fifth International Conference Artificial Intelligence Planning Scheduling (AIPS00),
pp. 5261, Breckenridge, Colorado, USA.
Bryant, R. E. (1986). Graph-based algorithms boolean function manipulation. IEEE Transactions Computers, C-35(8), 677691.
Buccafurri, F., Leone, N., & Rullo, P. (1997). Strong Weak Constraints Disjunctive Datalog.
Dix, J., Furbach, U., & Nerode, A. (Eds.), Proceedings 4th International Conference
Logic Programming Non-Monotonic Reasoning (LPNMR97), No. 1265 Lecture
Notes AI (LNAI), pp. 217, Dagstuhl, Germany. Springer Verlag.
Buccafurri, F., Leone, N., & Rullo, P. (2000). Enhancing Disjunctive Datalog Constraints. IEEE
Transactions Knowledge Data Engineering, 12(5), 845860.
Cimatti, A., & Roveri, M. (2000). Conformant Planning via Symbolic Model Checking. Journal
Artificial Intelligence Research, 13, 305338.
Dantsin, E., Eiter, T., Gottlob, G., & Voronkov, A. (2001). Complexity Expressive Power
Logic Programming. ACM Computing Surveys, 33(3), 374425.
Dimopoulos, Y., Nebel, B., & Koehler, J. (1997). Encoding Planning Problems Nonmonotonic
Logic Programs. Proceedings European Conference Planning 1997 (ECP-97),
pp. 169181. Springer Verlag.
Eiter, T., Faber, W., Leone, N., & Pfeifer, G. (2000a). Declarative Problem-Solving Using
DLV System. Minker, J. (Ed.), Logic-Based Artificial Intelligence, pp. 79103. Kluwer
Academic Publishers.
68

fiA NSWER ET P LANNING U NDER ACTION C OSTS

Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2000b). Planning Incomplete
Knowledge. Lloyd, J., Dahl, V., Furbach, U., Kerber, M., Lau, K.-K., Palamidessi, C.,
Pereira, L. M., Sagiv, Y., & Stuckey, P. J. (Eds.), Computational Logic - CL 2000, First International Conference, Proceedings, No. 1861 Lecture Notes AI (LNAI), pp. 807821,
London, UK. Springer Verlag.
Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2002a). Answer Set Planning
Action Costs. Flesca, S., Greco, S., Ianni, G., & Leone, N. (Eds.), Proceedings
8th European Conference Artificial Intelligence (JELIA), No. 2424 Lecture Notes
Computer Science, pp. 186197.
Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2002b). Answer Set Planning Action Costs. Tech. rep. INFSYS RR-1843-02-13, Institut fur Informationssysteme, Technische
Universitat Wien.
Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2003a). Logic Programming Approach
Knowledge-State Planning, II: DLV K System. Artificial Intelligence, 144(12), 157
211.
Eiter, T., Faber, W., Leone, N., Pfeifer, G., & Polleres, A. (2003b). Logic Programming Approach
Knowledge-State Planning: Semantics Complexity. appear ACM Transactions
Computational Logic.
Ephrati, E., Pollack, M. E., & Mihlstein, M. (1996). Cost-directed Planner: Preliminary Report.
Proceedings Thirteenth National Conference Artificial Intelligence (AAAI-96),
pp. 1223 1228. AAAI Press.
Erdem, E. (1999). Applications Logic Programming Planning: Computational Experiments.
Unpublished draft. http://www.cs.utexas.edu/users/esra/papers.html.
Faber, W., & Pfeifer, G. (since 1996). DLV homepage.. http://www.dlvsystem.com/.
Ferraris, P., & Giunchiglia, E. (2000). Planning Satisfiability Nondeterministic Domains.
Proceedings Seventeenth National Conference Artificial Intelligence (AAAI00), July
30 August 3, 2000, Austin, Texas USA, pp. 748753. AAAI Press / MIT Press.
Fourer, R., Gay, D. M., & Kernighan, B. W. (1993). AMPL: Modeling Language Mathematical
Programming. Duxbury Press.
Gelfond, M., & Lifschitz, V. (1991). Classical Negation Logic Programs Disjunctive
Databases. New Generation Computing, 9, 365385.
Ghallab, M., Howe, A., Knoblock, C., McDermott, D., Ram, A., Veloso, M., Weld,
D., & Wilkins, D. (1998).
PDDL Planning Domain Definition language. Tech. rep., Yale Center Computational Vision Control. Available
http://www.cs.yale.edu/pub/mcdermott/software/pddl.tar.gz.
Giunchiglia, E. (2000). Planning Satisfiability Expressive Action Languages: Concurrency,
Constraints Nondeterminism. Cohn, A. G., Giunchiglia, F., & Selman, B. (Eds.), Proceedings Seventh International Conference Principles Knowledge Representation
Reasoning (KR 2000), April 12-15, Breckenridge, Colorado, USA, pp. 657666. Morgan
Kaufmann.
69

fiE ITER , FABER , L EONE , P FEIFER & P OLLERES

Giunchiglia, E., Kartha, G. N., & Lifschitz, V. (1997). Representing Action: Indeterminacy
Ramifications. Artificial Intelligence, 95, 409443.
Giunchiglia, E., & Lifschitz, V. (1998). Action Language Based Causal Explanation: Preliminary Report. Proceedings Fifteenth National Conference Artificial Intelligence
(AAAI 98), pp. 623630.
Haslum, P., & Geffner, H. (2000). Admissible Heuristics Optimal Planning. Chien, S., Kambhampati, S., & Knoblock, C. A. (Eds.), Proceedings Fifth International Conference
Artificial Intelligence Planning Scheduling (AIPS00), pp. 140149, Breckenridge, Colorado, USA. AAAI Press.
Kautz, H., & Walser, J. P. (1999). State-space planning integer optimization. Proceedings
16th National Conference Artificial Intelligence (AAAI-99), pp. 526533.
Koehler, J. (1998). Planning Resource Constraints. Proceedings 13th European
Conference Artificial Intelligence (ECAI98), pp. 489493.
Krentel, M. (1992). Generalizations Opt P Polynomial Hierarchy. Theoretical Computer
Science, 97(2), 183198.
Lee, J., & Lifschitz, V. (2001). Additive Fluents. Provetti, A., & Cao, S. T. (Eds.), Proceedings
AAAI 2001 Spring Symposium Answer Set Programming: Towards Efficient Scalable
Knowledge Representation Reasoning, pp. 116123, Stanford, CA. AAAI Press.
Lifschitz, V., & Turner, H. (1994). Splitting Logic Program. Van Hentenryck, P. (Ed.), Proceedings 11th International Conference Logic Programming (ICLP94), pp. 2337,
Santa Margherita Ligure, Italy. MIT Press.
Lifschitz, V., & Turner, H. (1999). Representing Transition Systems Logic Programs. Gelfond,
M., Leone, N., & Pfeifer, G. (Eds.), Proceedings 5th International Conference Logic
Programming Nonmonotonic Reasoning (LPNMR99), No. 1730 Lecture Notes AI
(LNAI), pp. 92106, El Paso, Texas, USA. Springer Verlag.
Lifschitz, V. (1996). Foundations Logic Programming. Brewka, G. (Ed.), Principles Knowledge Representation, pp. 69127. CSLI Publications, Stanford.
Lifschitz, V. (1999a). Action Languages, Answer Sets Planning. Apt, K., Marek, V. W.,
Truszczynski, M., & Warren, D. S. (Eds.), Logic Programming Paradigm 25-Year
Perspective, pp. 357373. Springer Verlag.
Lifschitz, V. (1999b). Answer Set Planning. Schreye, D. D. (Ed.), Proceedings 16th
International Conference Logic Programming (ICLP99), pp. 2337, Las Cruces, New
Mexico, USA. MIT Press.
McCain, N. (1999). Causal Calculator Homepage.. http://www.cs.utexas.edu/
users/tag/cc/.
McCain, N., & Turner, H. (1997). Causal Theories Actions Change. Proceedings
15th National Conference Artificial Intelligence (AAAI-97), pp. 460465.
McCain, N., & Turner, H. (1998). Satisfiability Planning Causal Theories. Cohn, A. G.,
Schubert, L., & Shapiro, S. C. (Eds.), Proceedings Sixth International Conference Principles Knowledge Representation Reasoning (KR98), pp. 212223. Morgan Kaufmann
Publishers.
70

fiA NSWER ET P LANNING U NDER ACTION C OSTS

Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering
Efficient SAT Solver. Proceedings 38th Design Automation Conference, DAC 2001,
Las Vegas, NV, USA, June 18-22, 2001, pp. 530535. ACM.
Nareyek, A. (2001). Beyond Plan-Length Criterion. Local Search Planning Scheduling, ECAI 2000 Workshop, Vol. 2148 Lecture Notes Computer Science, pp. 5578.
Springer.
Niemela, I. (1998). Logic Programs Stable Model Semantics Constraint Programming
Paradigm. Niemela, I., & Schaub, T. (Eds.), Proceedings Workshop Computational Aspects Nonmonotonic Reasoning, pp. 7279, Trento, Italy.
Papadimitriou, C. H. (1994). Computational Complexity. Addison-Wesley.
Pednault, E. P. D. (1989). Exploring Middle Ground STRIPS Situation Calculus. Proceedings 1st International Conference Principles Knowledge Representation Reasoning (KR89), pp. 324332, Toronto, Canada. Morgan Kaufmann Publishers,
Inc.
Refanidis, I., & Vlahavas, I. (2001). Framework Multi-Criteria Plan Evaluation Heuristic
State-Space Planning. IJCAI-01 Workshop Planning Resources.
Selman, A. L. (1994). Taxonomy Complexity Classes Functions. Journal Computer
System Sciences, 48(2), 357381.
Simons, P., Niemela, I., & Soininen, T. (2002). Extending Implementing Stable Model
Semantics. Artificial Intelligence, 138, 181234.
Smith, D. E., & Weld, D. S. (1998). Conformant Graphplan. Proceedings Fifteenth
National Conference Artificial Intelligence, (AAAI98), pp. 889896. AAAI Press /
MIT Press.
Son, T. C., & Pontelli, E. (2002). Reasoning Actions Prioritized Default Theory. Flesca,
S., Greco, S., Ianni, G., & Leone, N. (Eds.), Proceedings 8th European Conference
Artificial Intelligence (JELIA), No. 2424 Lecture Notes Computer Science, pp. 369381.
Subrahmanian, V., & Zaniolo, C. (1995). Relating Stable Models AI Planning Domains.
Sterling, L. (Ed.), Proceedings 12 th International Conference Logic Programming,
pp. 233247, Tokyo, Japan. MIT Press.
van Gelder, A., Ross, K., & Schlipf, J. (1991). Well-Founded Semantics General Logic
Programs. Journal ACM, 38(3), 620650.
Weld, D. S., Anderson, C. R., & Smith, D. E. (1998). Extending Graphplan Handle Uncertainty
& Sensing Actions. Proceedings Fifteenth National Conference Artificial Intelligence, (AAAI98), pp. 897904. AAAI Press / MIT Press.
Williams, M., & Hanks, S. (1994). Optimal Planning Goal-Directed Utility Model.
Hammond, K. J. (Ed.), Proceedings Second International Conference Artificial Intelligence Planning Systems (AIPS-94), pp. 176181. AAAI Press.

71


