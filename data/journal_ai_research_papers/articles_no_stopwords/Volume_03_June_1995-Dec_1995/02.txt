Journal Artificial Intelligence Research 3 (1995) 53-118

Submitted 3/95; published 7/95

Building Refining Abstract Planning Cases
Change Representation Language
Ralph Bergmann
Wolfgang Wilke

bergmann@informatik.uni-kl.de
wilke@informatik.uni-kl.de

Centre Learning Systems Applications (LSA)
University Kaiserslautern, P.O.-Box 3049, D-67653 Kaiserslautern, Germany

Abstract

Abstraction one promising approaches improve performance problem
solvers. several domains abstraction dropping sentences domain description {
used hierarchical planners { proven useful. paper present examples
illustrate significant drawbacks abstraction dropping sentences. overcome
drawbacks, propose general view abstraction involving change
representation language. developed new abstraction methodology related
sound complete learning algorithm allows complete change representation
language planning cases concrete abstract. However, achieve powerful
change representation language, abstract language well rules
describe admissible ways abstracting states must provided domain model.
new abstraction approach core Paris (Plan Abstraction Refinement
Integrated System), system abstract planning cases automatically
learned given concrete cases. empirical study domain process planning
mechanical engineering shows significant advantages proposed reasoning
abstract cases classical hierarchical planning.

1. Introduction
Abstraction one challenging promising approaches improve complex
problem solving inspired way humans seem solve problems. first, less
relevant details given problem ignored abstracted problem
solved easily. Then, step step, details added solution taking
increasingly detailed look problem. Thereby, abstract solution constructed
first refined towards concrete solution. One typical characteristic work
hierarchical problem solving abstraction mostly performed dropping sentences
domain description (Sacerdoti, 1974, 1977; Tenenberg, 1988; Unruh & Rosenbloom,
1989; Yang & Tenenberg, 1990; Knoblock, 1989, 1994; Bacchus & Yang, 1994). second
common characteristic hierarchical problem solver usually derives abstract
solution scratch, without using experience previous problem solving episodes.
Giunchiglia Walsh (1992) presented comprehensive formal framework
abstraction comparison different abstraction approaches theorem proving
(Plaisted, 1981, 1986; Tenenberg, 1987), planning (Newell & Simon, 1972; Sacerdoti, 1974,
1977; Tenenberg, 1988; Unruh & Rosenbloom, 1989; Yang & Tenenberg, 1990; Knoblock,
1989, 1994), model based diagnosis (Mozetic, 1990). hierarchical planning, Korf's
model abstraction problem solving (Korf, 1987) allows analysis reductions
c 1995 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBergmann & Wilke

search caused single multiple levels abstraction. shown optimal
case, abstraction reduce expected search time exponential linear. Knoblock
developed approach construct hierarchy abstraction spaces automatically
given concrete-level problem solving domain (Knoblock, 1990, 1993, 1994).
called ordered monotonic abstraction hierarchies (Knoblock, Tenenberg, & Yang, 1991b)
proven useful many domains. Recently, Bacchus Yang (1994) presented
improved method automatically generating abstraction hierarchies based
detailed model search costs.
abstraction methods, however, rely abstraction dropping sentences
domain description kind homomorphic abstraction (Holte et al., 1994,
1995). shown kinds abstractions highly representation dependent (Holte et al., 1994, 1995). two classical planning domains, different \natural\
representations analyzed turns several representations
classical abstraction techniques lead significantly improved problem
solvers (Knoblock, 1994; Holte et al., 1995). However, well known normally many
different representations domain exist already pointed Korf (1980),
theory representation developed. particular,
theory representation hierarchical problem solving dropping sentences.
knowledge-engineering perspective, many different aspects simplicity,
understandability, maintainability must considered developing domain representation. Therefore, assume representations domains given knowledge
engineers rely representations consider \natural" certain kinds
problems. demonstrate two simple example problems related representations,
usual use abstraction problem solving lead improvement.
first example, improvement achieved abstraction restricted
dropping sentences domain. second example, abstract solution computed
scratch decompose original problem consequently cut
search space next detailed level. want argue examples
never represented way standard hierarchical problem solving works well.
However, think would require large effort knowledge engineer develop
appropriate representation believe often impossible develop representation appropriate knowledge-engineering perspective allows
ecient hierarchical problem solving based dropping sentences.
take observations motivation develop general model abstraction problem solving. already pointed Michalski (1994), abstraction,
general, seen switching completely new representation language
level detail reduced. problem solving, new abstract representation language
must consist completely new sentences operators subset
sentences operators concrete language. knowledge, Sipe (Wilkins, 1988)
planning system currently allows change representation language
across different levels abstraction. However, general abstraction methodology
allows ecient algorithms abstraction refinement yet developed.
want propose method abstraction allows complete change representation language problem solution concrete abstract vice versa,
concrete abstract language given. Additionally, propose use experience
54

fiBuilding Refining Abstract Planning Cases

previously solved problems, usually available set cases, come abstract
solutions. use experience already proven useful various approaches speedup learning explanation-based learning (Mitchell, Keller, & Kedar-Cabelli, 1986;
DeJong & Mooney, 1986; Rosenbloom & Laird, 1986; Minton, 1988; Minton, Carbonell,
Knoblock, Kuokka, Etzioni, & Gil, 1989; Shavlik & O'Rorke, 1993; Etzioni, 1993; Minton
& Zweben, 1993; Langley & Allen, 1993; Kambhampati & Kedar, 1994), analogical
case-based reasoning (Carbonell, 1986; Kambhampati & Hendler, 1992; Veloso & Carbonell,
1993; Veloso, 1994).
main contribution paper, present abstraction methodology
related learning method beneficial abstract planning cases automatically derived
given concrete cases. Based given concrete abstract language, learning
approach allows complete change representation case concrete
abstract level. However, achieve unconstrained kind abstraction,
set admissible abstractions must implicitly predefined generic abstraction theory.
Compared approaches abstraction hierarchies generated automatically,
effort required specify abstract language, feel price
pay make planning tractable certain situations.
approach fully implemented Paris (Plan Abstraction Refinement
Integrated System), system abstract cases learned organized case
base. novel problem solving, case-base searched suitable abstract case
refined concrete solution current problem.
presentation approach organized follows. next section presents
analysis hierarchical problem solving shortcomings current approaches
illustrated simple examples. Section three argues powerful case abstraction
refinement method overcome identified problems. Furthermore, present
Paris approach informally, using simple example. next three sections paper
formalize general abstraction approach. introducing basic terminology, Section 5 defines new formal model case abstraction. Section 6 contains detailed
description correct complete learning algorithm case abstraction. Section 7
explains refinement cases solving new problems. Section 8 gives detailed description domain process planning mechanical engineering production
rotary-symmetric workpieces lathe demonstrates proposed approach examples domain. Section 9 reports detailed experimental evaluation Paris
described domain. Finally, discuss presented approach relation similar
work field. appendix article contains formal proofs properties
abstraction approach related learning algorithm. Additionally, detailed
representation mechanical engineering domain used experimental evaluation
given Online Appendix 1.

2. Analysis Hierarchical Problem Solving
basic intuition behind abstraction follows. first ignoring less relevant features
problem description, abstraction allows problems solved coarse fashion
less effort. Then, derived abstract (skeletal) solution serves problem decomposition
original, detailed problem. Korf (1987) shown hierarchical problem
55

fiBergmann & Wilke

solving reduce required search space significantly. Assume problem requires
solution length n furthermore assume average branching factor b,
i.e., average number states reached given state applying
single operator. worst-case time complexity finding required solution search
O(bn ). Now, suppose problem decomposed abstract solution
k subproblems, require solution length n1; : : : ; nk , respectively,
n1 + n2 + + nk = n. situation, worst-case time complexity finding
complete solution O(bn1 + bn2 + + bnk ) O(bmax(n1;n2 ;:::;nk ) ). Please note
significant reduction search time complexity. particular, easily see
reduction maximal subproblems similar size, i.e., n1 n2 nk .
However, achieve significant search reduction, computed abstract solution must
solution abstracted problem, must additionally fulfill certain
requirement presupposed analysis. subproblems introduced abstract
solution must independent, i.e., must solvable without interaction
subproblems. avoids backtracking solution subproblem
consequently cuts necessary overall search space. Even restriction
completely fulfilled, i.e., backtracking still required cases, several empirical studies
(especially Knoblock, 1991, 1993, 1994) shown abstraction nevertheless lead
performance improvements.
Unfortunately, domains representations domains (Holte et al., 1994,
1995) way abstraction used hierarchical problem solving cannot improve
problem solving derived abstract solutions don't fulfill mentioned
requirement all. following, show two examples domains
demonstrate two general drawbacks hierarchical problem solving. Please note
examples, particular representation assumed. feel representations
somehow \natural" likely used knowledge engineer developing domain. However, might representations domains traditional
hierarchical planning works. assume representations dicult find,
especially domain representation fulfill additional knowledge-engineering
requirements.

2.1 Abstraction Dropping Sentences

hierarchical problem solving, abstraction mostly1 achieved dropping sentences
problem description preconditions and/or effects operators (Sacerdoti, 1974,
1977; Tenenberg, 1988; Unruh & Rosenbloom, 1989; Yang & Tenenberg, 1990; Knoblock,
1989, 1994). assumption justifies kind abstraction less relevant
details problem description expressed isolated sentences representation
addressed relevant sentences established. Ignoring
sentences assumed lead abstract solution useful reduce search
concrete planning levels.
However, assumption hold domains. example, many real world
domains, certain events need counted, e.g., transporting certain number
1. Tenenberg's (1988) abstraction analogical mappings planning system Sipe (Wilkins,
1988) contains first approaches allow change representation language.

56

fiBuilding Refining Abstract Planning Cases

containers one location another. Imagine domain which, addition several
operators, increment operator described follows:
Operator: inc
Precondition: value(X )
Delete: value(X )
Add: value(X + 1)

representation, integer value increased represented single sentence. state consists single sentence, operator contains
one single sentence.2 think representation \natural" likely
chosen knowledge engineer. domain, incrementing value(0) value(8)
requires sequential plan composed 8 inc-operators, leading state sequence:
value(0),value(1),: : : ,value(8). example, however, abstraction dropping sentences work because, single sentence would dropped, nothing would remain operator description whole counting problem would dropped
completely. empty problem abstract level, empty plan
going solve it. Unfortunately, empty plan cannot cause complexity reduction
solving problem concrete level. Consequently, abstraction dropping sentences
completely fails improve problem solving situation.
However, adequately cope counting problem abstracting
quantitative value expressed sentence towards qualitative representation (e.g.,
low=f0; 1; 2; 3g, medium = f4; 5; 6; 7g, high = f8; 9; 10; 11g). qualitative representation would result abstract plan composed two operators (subproblems)
increase value low medium high. abstract plan defines two
independently refinable subproblems. solve first subproblem concrete level,
problem solver search sequence inc-operators increment value
0 medium value (any value set f4; 5; 6; 7g). subproblem
solved sequence 4 inc-operators leading concrete state value 4. Similarly, second subproblem concrete level find sequence operators
change value 4 final value 8. second subproblem solved
sequence 4 inc-operators. see complete problem requires
sequence 8 concrete operators divided 2 subproblems subproblem
solved 4-step plan. exponential nature search space, two
4-step problems together solved much less search 8-step problem
whole. Following Korf's analysis sketched before, time complexity reduced O(b8)
O(b4)3 . Please note particular abstraction leads two subproblems
central achieving complexity reduction. important point problem
decomposed one subproblem. kind abstraction achieved
introducing new abstract representation language consists qualitative values
corresponding abstract increment operator.
2. However, might assume term X + 1 modeled separate predicate precondition.
Unfortunately, change described situation all.
3. assume many operators besides inc-operator, b 1 holds.

57

fiBergmann & Wilke

even generalize specific example presented above. problem
dropping condition approach possible abstract information (e.g.,
value example) coded single sentence representation.
particularly problem required solution contains long sequence states
differ single sentence. Dropping particular sentence leads dropping
whole problem, dropping sentence lead abstraction.
really required abstract information encoded single sentence obviously
requires dropping complete information.
summarize, seen abstraction dropping sentences work
particular kind problems shown. general, abstraction requires changing complete representation language concrete abstract usually involves
introduction completely new abstract terms (sentences operators). Within
general view, dropping sentences special case abstraction. reason dropping sentences widely used hierarchical planning due simplicity,
refinement easy abstract states directly used goals
detailed levels. Another important property abstraction dropping sentences
useful hierarchies abstraction spaces constructed automatically domain
descriptions (Knoblock, 1990, 1993, 1994; Bacchus & Yang, 1994).

2.2 Generating Abstract Solutions Scratch

Another limiting factor classical hierarchical problem solving way abstract solutions computed. pointed Korf, good abstract solution must lead mostly
independent subproblems equal size. classical problem solving, abstract solution
found breadth-first depth-first search using linear (e.g., Alpine, Knoblock, 1993)
non-linear (e.g., Abtweak, Yang & Tenenberg, 1990) problem solvers. problem solvers, upward-solution property (Tenenberg, 1988) usually holds, means
abstract solution exists concrete-level solution exists. Usually, problem
solvers find arbitrary abstract solution (e.g., shortest possible solution). Unfortunately, way guarantee computed solutions refinable lead
mostly independent subproblems suciently equal size, even solution exists.
general, even heuristics try guide problem solving towards
aspired kind useful abstractions. problem illustrated following example,
additionally shows limitation abstraction dropping sentences.
Imagine large (or even infinite) state space includes least 8 distinct states
shown left Figure 1. 8 states described presence absence
three sentences E 1, E 2, E 3 state description. 3-bit-vector shown Figure
1, "0" indicates absence sentence "1" represents presence sentence.
8 different states described three sentences arranged 3-dimensional
cube, using one dimension sentence. arrows diagram show possible state
transitions available operators domain.4 operator manipulates (adds
deletes) exactly one sentence state description, certain conditions
sentences fulfilled. representation two operators shown right
4. dashed lines represent operators introduced make shape cube
easy see.

58

fiBuilding Refining Abstract Planning Cases

Z

011

111

Two example operators:
010

110

X Z
001

E2

X

000

101

E3
E1

100

O100->101 :
Precondition:
E1
(not E2)
(not E3)

O101->100 :
Precondition:
E1
(not E2)
E3

Add: E3

Delete: E3



Figure 1: State space example domain representation two operators
side figure. subscript operator name relates respective transition
state diagram. general, see

E 1 manipulated, E 2 E 3 holds,
E 2 manipulated, E 1 E 3 holds,
E 3 manipulated, E 1 _ E 2 holds.
Furthermore, assume many operators connect states
domain, shown diagram, 8 depicted states. Consequently,
must assume branching factor b 1 state, makes search space
problem solving quite large. Besides description domain, Figure 1 shows
three example problems: X ! X 0, ! 0 Z ! Z 0 . example, solution
problem X ! X 0 5-step path 000 ! 010 ! 110 ! 111 ! 101 ! 001.
Now, let's consider abstract solutions correspond concrete solutions
three problems. problem, want examine three possible ways
abstraction dropping one sentences. purpose, geometric arrangement
states turns useful abstraction simply viewed
projecting 3-dimensional state space onto plane defined sentences
dropped abstraction. left part Figure 2 shows three possible abstract
state spaces result dropping one sentences. important
see abstract state space, every sentence modified unconditionally
independent sentences. However, one sentence modified
operator. Thereby, constraints exist concrete level relaxed.
abstraction concrete solution three problems (X ! X 0, ! 0
Z ! Z 0) respect three possible ways dropping conditions shown
59

fiBergmann & Wilke

State spaces
dropping conditions

X->X

Y->Y

E2

4

E2
1

2

1

2
3
E1

2

2

E1
E3

Z->Z

3

1

1

E3
4

3

1

E1
4

E2 2

1
3

2

E2

3

1
3

2
1 E3

2
3

E1

3

1
E3

2

3

Figure 2: Abstract state spaces dropping conditions
right side Figure 2. nine possible abstract solutions consists three
four abstract operators. sequence applied indicated
numbers mark operators. see whatever sentence
drop problems, appropriate abstract solution exists decomposes
original problem independent refinable subproblems suciently equal size.
main point example none abstract solutions found
hierarchical problem solver! reason abstracted problems
exists 0-step 1-step solution addition nine 3-step 4-step solutions
indicated depicted paths. However, short solution completely useless
reducing search next concrete level original problem
decomposed all. central problem problem solvers find
shorter useless solutions first, try refine them. Consequently, search
space concrete level reduced performance improvement achieved
all. However, might representations example domain
hierarchical problem solver comes useful abstract solution. think, however,
representation shown quite natural represents 8 different states
minimal number binary sentences.
summarize, presented example useful abstract solution found
hierarchical planning although exists. reason planners usually try
find shortest solutions, good strategy ground level, may
appropriate abstract level. Neither desirable search longest
solutions might cause unnecessarily long concrete plans.

3. Case Abstraction Refinement

way problem, propose use experience given form concrete
planning cases abstract experience reuse new situations. Therefore,
need powerful abstraction methodology allows introduction completely
new abstract terminology abstract level. makes possible useful abstract
solutions expressed domains abstraction dropping conditions
sucient. particular, methodology must serve means analyze
different abstraction approaches, must allow ecient algorithms abstracting
refining problems solutions.
60

fiBuilding Refining Abstract Planning Cases

3.1 Basic Idea
introduce approach achieves case abstraction refinement changing
representation language. prerequisite, approach requires abstract
language (state description operators) given domain expert addition
concrete level description. require set admissible ways abstracting
states implicitly predefined generic abstraction theory. course additional
knowledge engineering requirement, feel price pay
enhance power hierarchical problem solving. Recent research knowledge acquisition
already describes approaches tools acquisition concrete level abstract level
operators real-world domains (Schmidt & Zickwolff, 1992; Schmidt, 1994). abstract
language given user additional advantage abstracted cases
expressed language user familiar. Consequently, understandability
explainability, always important issues applying system, achieved
easily.
source learning, assume set concrete planning cases,
consists problem statement together related solution. case Prodigy
(Minton et al., 1989), consider sequential plans, i.e., plans totally ordered
operators. planning cases assume include problem solving trace example problem solving cases Prodigy/Analogy (Veloso, 1992; Veloso & Carbonell,
1993; Veloso, 1994). real-world applications, domain expert's solutions previous
problems usually recorded company's filing cabinet database. cases
seen collection company's experience, want draw power.
learning phase, set abstract planning cases generated available
concrete case. abstract planning case consists abstracted problem description
together abstracted solution. case abstraction procedure guarantees
abstract solution contained abstract case always refined become solution
concrete problem contained concrete case became abstracted. Different
abstract cases may situated different levels abstraction may abstractions
according different abstraction aspects. Different abstract cases different utility
reduce search space concrete level different ways. happen
several concrete cases share abstraction. set abstract planning cases
learned organized case-base ecient retrieval problem solving.
problem solving phase, case base searched abstract case
found applied current problem hand. abstract case applicable
current problem abstracted problem contained abstract planning case
abstraction current problem. However, cannot guarantee abstract
solution contained selected abstract case really refined become solution
current problem. least known abstract solution case base
already useful solving one previous problems, i.e., problems contained
concrete cases abstract case learned. Since new problem
similar previous problems abstracted way,
least high chance abstract solution useful solving new problem.
new problem solved refinement new concrete case arises
used learning.
61

fiBergmann & Wilke

Learning

PARIS-System

Evaluation/
Indexing

Case Base

Generalization

Abstraction

Problem Solving
Retrieval

Domain Description
Concrete Domain,
Abstract Domain,
Generic Abstraction Theory

New Problem

Specialization

Refinement

Solved Problem

Training Cases

Figure 3: components Paris System

3.2 PARIS Architecture
Paris (Plan Abstraction Refinement Integrated System) follows basic ap-

proach described. Figure 3 shows overview whole system components.
Besides case abstraction refinement, Paris includes explanation-based approach
generalizing cases learning specializing problem solving. Furthermore, system includes additional mechanisms evaluating different abstract
cases generalizations derived explanation-based component. evaluation
component measures reduction search time caused abstract plan solving concrete problems case base abstract plan applicable.
Based evaluation, several different indexing retrieval mechanisms developed. retrieval procedures abstract cases preferred caused
reduction search previous problem solving episodes. particular, abstract cases turn useless many concrete problems may even become
completely removed case-base. spectrum developed retrieval approaches
ranges simple sequential search, via hierarchical clustering sophisticated approach balancing hierarchy abstract cases according statistical distribution
cases within problem space evaluated utility. details generalization procedure found (Bergmann, 1992a), evaluation retrieval
mechanisms reported (Bergmann & Wilke, 1994; Wilke, 1994). whole multistrategy system including various interactions described components
topic forthcoming article, first ideas already found (Bergmann, 1992b,
1993). However, target paper concentrate core Paris, namely
approach abstraction refinement.
62

fiBuilding Refining Abstract Planning Cases

State Abstractions
Abstract Plan

A3

011

111

A2
010

110

001

A1

100

A1

A2

A3

A4

000
011
010

110

111

001
101
100

Changing
Representration

101

A4

000

Figure 4: example case abstraction

3.3 Informal Description Abstraction Approach

first give informal description abstraction approach Paris, based
small example shown Figure 1 enhance understanding subsequent formal
sections. Suppose solution problem X ! X 0 available concrete problem solving experience. task learn abstract case beneficially
used solve future problems ! 0 Z ! Z 0 . learning task must
achieved within abstraction approach stronger dropping sentences.
look Figure 4, becomes obvious changing representation single abstract
case learned useful three concrete problems. abstract plan shown
indicates concrete states abstracted towards single abstract state,
single abstract plan exists useful three problems.
3.3.1 Abstract Language Generic Abstraction Theory

achieve kind abstraction, approach requires abstract language (states
operators), well generic abstraction theory provided user. example Figure 4, abstract language must contain new abstract sentences A1 ; : : : ; A4
three abstract operators allow respective state transitions. abstract
operators, called Oai (i 2 f1; : : : ; 3g), defined follows:
Operator: Oai
Precondition: Ai
Delete: Ai
Add: Ai+1

new abstract sentence, user must provide set generic abstraction rules
describe sentence defined terms available sentences con63

fiBergmann & Wilke

crete language. generic abstraction theory defined rules specifies set
admissible state abstractions. example, generic abstraction theory must contain following two rules define new abstract sentence A1 : :E 1 ^ E 2 ! A1
:E 1 ^ :E 2 ^ :E 3 ! A1. general, definition generic abstraction theory
require state abstractions noted explicitly. Abstract states derived
implicitly application combination several rules generic abstraction
theory.
Besides kind abstraction described above, user may want specify
different type abstraction she/he considers useful. example,
assume abstraction dropping sentence E 1 realized. case,
abstract language must contain copy two sentences dropped, i.e.,
sentences E 2 E 3. Therefore, user5 may define two abstract sentences A5
A6 following rules generic abstraction theory: E 2 ! A5 E 3 ! A6.
course, respective abstract operators must specified.
Since domain expert knowledge engineer must provide abstract language
generic abstraction theory, she/he must already one particular kinds
abstraction mind. She/he must know kind details omitted solving
problem abstract fashion. approach, knowledge-engineer given
power express kind abstraction she/he considers useful.
3.3.2 Model Case Abstraction

Based given abstract language generic abstraction theory, abstraction
planning case formally described two abstraction mappings: state abstraction
mapping sequence abstraction mapping. two mappings describe two dimensions
reducing level detail case. state abstraction mapping reduces level
detail state description changing representation language. case
abstraction indicated Figure 4, state abstraction mapping must map concrete
states 000, 011 010 onto abstract state described new sentence A1,
simultaneously must map concrete states occurring plan onto respective
abstract states described new sentences A2 , A3 , A4 . sequence abstraction
mapping reduces level detail number states considered
abstract level relating concrete states concrete case abstract
states abstract case. concrete states skipped, abstract
state must result particular concrete state. example, Figure 4, abstraction
plan 000 ! 010 ! 110 ! 111 ! 101 ! 001 requires sequence abstraction mapping
relates first abstract state described A1 first concrete state 000,
second abstract state described A2 third concrete state 110, forth.
example, second fifth concrete states skipped.
3.3.3 Learning Abstract Planning Cases

procedure learning abstract planning cases given concrete planning case
decomposed four separate phases. simple example, phases shown
5. Please note abstraction dropping sentences, consider ALPINE-like algorithm
generates required abstract language generic abstraction theory automatically.

64

fiBuilding Refining Abstract Planning Cases

A5A6

A5

Ca 2
Phase-IV
Ca 1 A1

Oa 1

Phase-III

A2

Oa 2

Oa 3

A3

A4

Oa 3

Oa 2

Oa 1

A6

Oa 1

Oa 3

Phase-II

A1

1 A5

2 A5

3 A5 A6

4 A6

4 A6

Phase-I

000

010

110

111

101

001

Figure 5: four phases case abstraction solution problem X ! X 0
Figure 5. phase-I, states result execution plan contained
concrete case determined. Therefore, operator contained plan (starting
first operator) applied successor state computed. process starts
initial state contained case leads final state, goal state
contained case. phase-II, derive admissible abstractions concrete
state computed first phase. purpose, generic abstraction theory used
determine abstract sentences derived respective concrete state
applying rules generic abstraction theory. Figure 5 shows abstract sentences
derived generic abstraction theory sketched above. example,
see second concrete state abstract description derived contains
two abstract sentences: abstract sentence A1 required achieve type abstraction
shown Figure 4 additionally abstract sentences A5 required abstraction
dropping sentences. Please note process, representation language states
changed concrete abstract. next two phases deal abstract operators.
already stated, abstract operators given abstract language provided
user. However, assume operator abstraction rules associate abstract
operator single concrete operator sequence concrete operators. reason
operator abstraction rules extremely hard acquire even harder
keep complete. next two phases case abstraction, search transitions
abstract states based available abstract operators. phase-III, acyclic directed
graph constructed. edge leads abstract state successor abstract state
j (not necessarily next abstract state), abstract operator applicable state
application leads state j . definition abstract operators
used process. available abstract operators determine transitions
included graph. Figure 5 shows resulting graph, provided abstract
operators sketched Section 3.3.1 contained abstract language. graph
65

fiBergmann & Wilke

transitions shown plain line style result operators Oai , transitions
shown dashed line style result operators required abstraction dropping
conditions.
phase-IV graph searched consistent paths initial abstract state
final abstract state. paths must consistent sense resulting
path (i.e., abstract plan) every abstract operator correctly applicable state
results previous operator. Moreover, state abstraction required
abstract plan must change within plan. Figure 5 two paths kind
shown. lower path represents abstract planning case Ca1 (abstract initial final
state together operator sequence) results kind abstraction shown
Figure 4. upper path represents abstract planning case Ca2 results
abstraction dropping sentence E 1. abstract plan shown Figure
2 problem X ! X 0. Together two plans, abstract state descriptions
result operator application shown. Please note state descriptions
always subset description derived generic abstraction theory.
example, description fourth abstract state derived phase-II, contains
sentences A3 ; A5; A6. abstract state occurs abstract cases computed
phase-IV. case Ca2 , respective state described sentences A5
A6 sentences result application operators
starting abstract initial state. case Ca1, abstract state described
sentence A3 sentence results application operator Oa2.
example see abstract operators two functions. first
function select concrete states become abstracted. example,
abstract case Ca1, second concrete state skipped, even first second
concrete states abstracted different abstract descriptions phase-II. reason
abstract operator a) leads first abstracted state
second abstracted state b) consistent operators
rest path. second function abstract operators select
abstract sentences considered abstract planning case. example,
abstract case Ca1 , sentences A1 ; : : : ; A4 considered sentences A5 A6
left out. reason abstract operators Oa1 ; Oa2; Oa3 occur
plan don't use A5 A6 precondition don't manipulate sentences.
phase-IV finished, set abstract planning cases available. planning
cases stored case-base used problem solving.
3.3.4 Selecting Refining Abstract Cases

problem solving, abstract case must selected case-base, abstract
plan contained case must refined become solution current problem.
case retrieval must search abstract case applicable, i.e., contains
problem description abstraction current problem. example, assume
problem ! 0 solved case X ! X 0 presented learning.
situation case-base contains two abstract cases Ca1 Ca2 shown phaseIV Figure 5. abstract case Ca1 used solving new problem,
initial state 000 new problem abstracted A1 applying generic
66

fiBuilding Refining Abstract Planning Cases

Selected abstract case:

A1

Defined search spaces:

000

Refined solution:

000

Oa 1

010

A2

Oa 2

A3

?

?

110

111

Oa 3

A4

100

101

100

Figure 6: Refinement abstract case solution problem ! 0
abstraction theory. Similarly, final state 100 abstracted A4 . However,
abstract case Ca2 applicable final abstract state cannot abstracted
A6. Consequently, lower abstract case must used. plan refinement
refine abstract operators sequentially left right shown Figure 6. Thereby
abstract operator defines abstract goal state, i.e., state results
execution operator. example, abstract operator Oa1 defines abstract goal
A2. refine abstract operator, search concrete operator sequence, starting
current concrete state (i.e., initial state first operator), concrete
state reached abstracted desired goal state. state found
used starting state refinement next abstract operator.
solution problem ! 0 , refinement abstract operator Oa1
achieved sequence two concrete operators leading concrete state 110.
concrete state used starting state refine next abstract operator Oa2.
refinement procedure finishes last abstract operator refined way
final concrete state achieved. Please note type refinement operators
used directly, instead sequence states results
execution used. Alternatively, could stored abstract case sequence
abstracted states. experience, storing sequence operators requires less
space storing sequence states. become obvious looking
domain introduced Section 8. Besides abstract operators play
important role learning phase.

3.4 Relations Skeletal Plans
similar experience-based case-based variant finding abstract solution
found early paper Friedland Iwasaki (1985) concept skeletal
plans introduced. skeletal plan "[...] sequence generalized steps, which,
instantiated specific operations specific problem context solve given problem
[p.161]. [...] Skeletal plans exist many levels generality. general level,
basic plans, used `fall-backs', specific, easier
refine plans cannot found. [p. 164]." Skeletal plans solutions planning problems
different levels detail consequently abstract plans. problem solving
67

fiBergmann & Wilke

recalled library refined towards concrete solution. approach
seen early idea integrating abstraction case-based reasoning. However,
several differences skeletal plan approach Paris approach.
skeletal plan approach model operators (neither concrete abstract) used
describe preconditions effects operators done Paris. explicit
notion states abstraction refinement states. Instead, plan refinement
achieved stepping hierarchy operators, guided heuristic rules operator
selection. particular, approach supports automatic acquisition skeletal
plans provided. Unfortunately, skeletal plan approach yet investigated
much detail current work field speedup-learning. neither formal
model skeletal planning empirical evaluations.
rest paper introduce investigate Paris approach
formally.

4. Basic Terminology
section want introduce basic formal terminology used throughout rest
paper. Therefore define formal representation problem solving domains.
want assume problem solving general viewed transforming initial
state final state using sequence operators (Newell & Simon, 1972). Following
Strips-oriented representation (Fikes & Nilsson, 1971), domain problem solving
= hL; E ; O; Ri described first-order language6 L, set essential atomic sentences
E L (Lifschitz, 1987), set operators related descriptions, additionally,
set rules (Horn clauses) R L. essential sentences (which must atomic)
sentences used describe state. state 2 describes dynamic
part situation domain consists finite subset ground instances essential
sentences E . symbol , denote set possible states descriptions
domain, defined = 2E , E = fe je 2 E substitution
e groundg. addition, Horn clauses R allow representation static properties
true situations. Horn clauses must contain essential sentence
head clause.
operator o(x1; : : : ; xn) 2 described triple hPreo ; Addo; Deloi,
precondition Preo conjunction atoms L, add-list Addo deletelist Delo finite sets (possibly instantiated) essential sentences E . Furthermore,
variables occuring operator descriptions must follow following restrictions:
fx1; : : : ; xng V ar(Preo) V ar(Delo) fx1; : : : ; xng V ar(Addo).7
instantiated operator expression form o(t1; : : : ; tn ), ti ground
terms L. term ti describes instantiation variable xi operator description. notational convenience define instantiated precondition well instantiated add-list delete-list instantiated operator follows: Preo(t1 ;:::;tn ) := Preo ,
Addo(t1;:::;tn) := fa ja 2 Addog, Delo(t1;:::;tn) := fd jd 2 Delo g, hPreo ; Addo; Deloi
6. basic language first order, deductive rules given Horn logic subset
full first-order language used.
7. restrictions however relaxed fx1 ; : : : ; xn g V ar(Preo ) required.
introduced restriction simplifies subsequent presentation.

68

fiBuilding Refining Abstract Planning Cases

description (uninstantiated) operator o(x1; : : : ; xn), = fx1 =t1 ; : : : ; xn =tn g
corresponding instantiation.
instantiated operator applicable state s, [ R ` Pre
holds.8

instantiated operator transforms state s1 state s2 (we write: s1 ,! s2 )
applicable s1 s2 = (s1 n Delo ) [ Addo . problem description p = hsI ; sG
consists initial state sI together final state sG . problem solving task
find sequence instantiated operators (a plan) = (o1; : : : ; ol ) transforms
ol
o1
initial state final state (sI ,!
,!
sG ). case C = hp; oi problem
description p together plan solves p.
introduced Strips-oriented formalism defining problem solving domain
similar form expressiveness representations typically used general problem
solving planning. state described finite set ground atoms
functions used. Full Horn logic available describe static rules. restriction Horn clauses advantage powerful allowing ecient proof
construction using well known SLD-refutation procedures (Lloyd, 1984). Compared
Prodigy Description Language (PDL) (Minton, 1988; Blythe et al., 1992) language provide explicit quantification specific syntactic construct, similar
expressiveness reached implicit quantification Horn clauses. Moreover,
language provide kind type specification constants variables
PDL think major disadvantage. Besides points language
quite similar PDL.

5. Formal Model Case Abstraction
section present new formal model case abstraction provides theory
changing representation language case concrete abstract. already
stated assume addition concrete language abstract language supplied
domain expert. Following introduced formalism, assume concrete level
problem solving defined concrete problem solving domain Dc = hLc ; Ec; Oc ; Rci
abstract level (case-based) problem solving represented abstract problem solving domain Da = hLa ; Ea; Oa; Rai. reasons simplicity, assume
domains share symbols9 . condition always achieved renaming symbols. remainder paper states operators concrete
domain denoted sc oc respectively, states operators abstract
domain denoted sa oa respectively. problem case abstraction
described transforming case concrete domain Dc case abstract
domain Da (see Figure 7). transformation formally decomposed two
independent mappings: state abstraction mapping ff, sequence abstraction mapping
(Bergmann, 1992c). state abstraction mapping transforms selection concrete
state descriptions occur solution problem abstract state descriptions,
8. following, simply omit parameters operators instantiated operators case
unambiguous relevant.
9. Otherwise, symbol (or sentence) could become ambiguous would problem applying
generic abstraction theory. would unclear whether generic abstraction rule refers concrete
abstract sentence

69

fiBergmann & Wilke

abstract
domain:

Da


O1



s0

1a


concrete
domain:

Dc

c0


O2


Oj

ja


Oc1

(0) = 0

c1

Oc2

c

s2

Oc3

c

s3
(1) = 3


j+1


Om

Oci+1

Ocn


Oc4

Oci

ci
(j) =



cn
(m) = n

Figure 7: General idea abstraction
sequence abstraction mapping specifies concrete states mapped
skipped.

5.1 State Abstraction

state abstraction mapping translates states concrete world abstract world.
Definition 1 (State Abstraction Mapping) state abstraction mapping : Sc ! Sa
mapping Sc , set states concrete domain, Sa, set states
abstract domain. particular, must effective total function.
general definition state abstraction mapping impose restrictions
kind abstraction besides fact mapping must total many-toone function. However, restrict set possible state abstractions set
abstractions user considers useful, assume additional domain knowledge
abstract state relates concrete state provided. knowledge
must expressed terms domain specific generic abstraction theory (Giordana,
Roverso, & Saitta, 1991).

Definition 2 (Generic Abstraction Theory) generic abstraction theory set Horn
clauses form ea a1 ; : : : ; ak . rules ea abstract essential sentence,
i.e., ea = Ea Ea 2 Ea substitution . body generic abstraction rule
consists set sentences concrete abstract language, i.e., ai atoms
Lc [ La .
Based generic abstraction theory, restrict set possible state abstraction
mappings deductively justified generic abstraction theory.

Definition 3 (Deductively Justified State Abstraction Mapping) state abstraction mapping deductively justified generic abstraction theory A, following conditions
hold sc 2 Sc :
2 ff(sc ) sc [ Rc [ `
2 ff(sc ) s~c s~c [ Rc [ ` holds, 2 ff(~sc ) fulfilled.
70

fiBuilding Refining Abstract Planning Cases

definition first condition assures every abstract sentence reached
mapping justified abstraction theory. Additionally, second requirement
guarantees abstract sentence used describe abstraction one state,
must used describe abstraction states, abstract sentence
derived generic abstraction theory. Please note deductively justified state
abstraction mapping completely induced set Ea respect generic
abstraction theory follows: ff(sc ) := f 2 jsc [ Rc [ ` g. Unless otherwise stated
always assume deductively justified state abstraction mappings. summarize,
state abstraction mapping transforms concrete state description abstract state
description thereby changes representation state concrete abstract.
Please note deductively justified state abstraction mappings need defined
user. determined automatically learning algorithm
presented Section 6.

5.2 Sequence Abstraction

solution problem consists sequence operators corresponding sequence
states. relate abstract solution concrete solution, relationship
abstract states (or operators) concrete states (or operators) must captured.
abstract state must corresponding concrete state every concrete state
must associated abstract state. due fact abstraction always
reduction level detail (Michalski & Kodratoff, 1990), situation, reduction
number states. selection concrete states corresponding
abstraction, sequence abstraction mapping defined follows:

Definition 4 (Sequence Abstraction Mapping) sequence abstraction mapping : N ! N

relates abstract state sequence (sa0 ; : : : ; sam ) concrete state sequence (sc0; : : : ; scn )
mapping indices j 2 f1; : : : ; mg abstract states saj indices 2 f1; : : : ; ng
concrete states sci , following properties hold:

fi(0) = 0 fi(m) = n: initial state goal state abstract sequence

must correspond initial goal state respective concrete state sequence.

fi(u) < fi(v) u < v: order states defined concrete
state sequence must maintained abstract state sequence.

Note defined sequence abstraction mapping formally maps indices abstract
domain concrete domain. abstraction mapping better map indices
concrete domain indices abstract domain, inverse mapping
,1 does. However, mapping inconvenient handle formally since
range definition ,1 must always considered. Therefore stick presented
definition.

5.3 Case Abstraction

Based two abstraction functions introduced, intuition case abstraction
captured following definition.
71

fiBergmann & Wilke

Hierarchies abstraction spaces
Dl
Different kinds abstractions
D2

Da
Da1
Dc

Da

D1

Da2
D0

D0

Dc

Figure 8: Different kinds abstractions (a) abstraction hierarchies (b)

Definition 5 (Case Abstraction) case Ca = hhsa0 ; sami; (oa1; : : : ; oam)i abstraction
case Cc = hhsc0; scn i; (oc1; : : : ; ocn)i respect domain descriptions (Dc ; Da)
oaj
oci c
sci,1 ,!
si 2 f1; : : : ; ng saj,1 ,!
sj j 2 f1; : : : ; mg
exists state abstraction mapping sequence abstraction mapping , that:
saj = ff(scfi(j)) holds j 2 f0; : : : ; mg.

definition case abstraction demonstrated Figure 7. concrete space shows
sequence n operations together resulting state sequence. Selected states
mapped states abstract space. mapping maps indices
abstract states back corresponding concrete states.

5.4 Generality Case Abstraction Methodology

following, brie discuss generality presented case abstraction methodology. see hierarchies abstraction spaces well different kinds abstractions represented simultaneously using presented methodology.
5.4.1 Different kinds Abstractions

general, one possible abstraction object world.
Abstraction performed many different ways. example two different abstractions case already shown example Figure 5. example,
two different abstractions (see abstract cases Ca1 Ca2) derived
concrete case. abstraction methodology able cope different abstractions
case specified user. Assume given one concrete domain Dc
two different abstract domains Da1 Da2 , represents two different kinds
abstraction. Furthermore, assume abstract domains share
symbols10 . always define single abstract domain Da joining individual
abstract domains includes kinds abstractions (see Figure 8 (a)).
property formally captured following simple lemma.
10. abstract domains disjoint, symbols simply renamed achieve property.

72

fiBuilding Refining Abstract Planning Cases

Lemma 6 (Joining different abstractions) concrete domain Dc two disjoint abstract domains Da1 Da2 given, joint abstract domain Da = Da1 [ Da2
defined follows: Let Da1 = (La1; Ea1; Oa1; Ra1) let Da2 = (La2; Ea2; Oa2; Ra2).
Da = Da1 [ Da2 = (La1 [ La2 ; Ea1 [ Ea2 ; Oa1 [ Oa2 ; Ra1 [ Ra2). joint abstract domain
Da fulfills following property: Ca abstraction Cc respect (Dc, Da1)
respect (Dc , Da2), Ca abstraction Cc respect (Dc ; Da).
5.4.2 Hierarchy Abstraction Spaces

work hierarchical problem solving assume multi-level hierarchy abstraction
spaces problem solving (e.g., Sacerdoti, 1974; Knoblock, 1989). Even presented
approach contains two domain descriptions, hierarchy abstract domains simply
mapped onto presented two-level model shown Figure 8 (b). Assume
hierarchy disjoint domain descriptions (D0; : : : ; Dl) given. particular, domain
D+1 assumed abstract domain . multi-level hierarchy
abstraction spaces, case C abstraction level abstraction case C0,
exists sequence cases (C1 ; : : : ; C ,1 ) Ci domain Di Ci+1
abstraction Ci respect (Di ; Di+1) 2 f0; : : : ; , 1g. multilevel hierarchy domain descriptions always reduced two-level description.
abstract domain two-level description contains union levels
multi-level hierarchy. property formally captured following lemma.

Lemma 7 (Multi-Level Hierarchy) Let (D0; : : : ; Dl) arbitrary multi-level
hierarchy

l
domain descriptions. two-level description (Dc , Da ) Da = =1
Dc = D0 holds that: Ca abstraction Cc respect (D0; : : : ; Dl) Ca
abstraction Cc respect (Dc , Da ).
Since shown different kinds abstractions well hierarchies abstraction spaces directly represented within two-level case abstraction methodology,
restrict exactly two levels.

6. Computing Case Abstractions

present Pabs algorithm (Bergmann, 1992c; Wilke, 1993) automatically
learning set abstract cases given concrete case. Thereby, assume
concrete domain Dc abstract domain Da given together generic abstraction
theory A. use functional notation Ca 2 PABS(hDc ; Da; Ai; Cc) denote Ca
element set abstract cases returned Pabs algorithm.
algorithm consists four separate phases introduced Section 3.
following present phases detail.
first three phases, require procedure determining whether conjunctive
formula consequence set Horn clauses. purpose, use SLD-refutation
procedure (Lloyd, 1984) given set Horn clauses (a logic program) C together
conjunctive formula G (a goal clause). refutation procedure determines set
answer substitutions
C ` G holds 2
. write
= SLD(C; G).
SLD-refutation procedure performs kind backward-chaining works
73

fiBergmann & Wilke

follows. selects literal goal clause G (i.e., left literal) searches
Horn clause logic program C contains literal head unifies
selected goal literal. selected literal removed G body (if empty)
applied clause added beginning goal clause. general
unifier goal literal head clause applied whole new goal clause.
resulting goal clause called resolvent. process continues goal clause
becomes empty resolvents built. former case, goal
proven answer substitution computed composing substitutions used
resolution. Backtracking used look possible selections applicable
Horn rules determine alternative answer substitutions. set answer substitutions
returned set
. whole space possible applications available Horn rules
searched unsuccessfully, goal clause consequence logic program
C SLD-refutation procedure terminates without answer substitution (
= ;).
must confused situation empty substitution returned
(
= f;g), variables occur G. phase-III Pabs algorithm, require
derivation trees addition answer substitutions. write = SLD(C; G)
assume set pairs (; ), answer substitution
derivation C ` G .
order assure termination SLD-refutation procedure require
abstract domain generic abstraction theory designed according
following principles11 :
concrete state sc 2 Sc concrete operator oc 2 Oc oc
described hPreoc ; Addoc ; Deloc i, SLD(sc [ Rc ; Preoc ) must lead finite set
ground substitutions variables occur Preoc .
state abstract sa 2 Sa abstract operator oa 2 Oa oa
described hPreoa ; Addoa ; Deloa i, SLD(sa [ Ra; Preoa ) must lead finite set
ground substitutions variables occur Preoa .
state sc 2 Sc abstract essential sentence E 2 Ea, SLD(sc [Rc [A; E )
must lead finite set ground substitutions variables occur E .
following four phases Pabs algorithm explained detail.

6.1 Phase-I: Computing Concrete State Sequence

input case abstraction algorithm, assume concrete case Cc =
hhscI ; scGi; (oc1; : : : ; ocn)i. Note (oc1; : : : ; ocn) totally ordered sequence instantiated operators similar plans Prodigy (Minton, 1988; Minton et al., 1989; Veloso
& Carbonell, 1993). first phase, state sequence results simulation
problem solution computed follows:

11. first glance, restrictions seem bit hard achieve take closer look see
standard requirement (terminating) logic program (i.e., Prolog program).

74

fiBuilding Refining Abstract Planning Cases

Algorithm 1 (Phase-I: Computing concrete state sequence)
sc0 := scI
:= 1 n
SLD(sci,1 [ Rc; Preoci ) = ; STOP \Failure: Operator applicable"
sci := (sci,1 n Deloci ) [ Addoci

end
scG 6 scn STOP \Failure: Goal state reached"

oc


algorithm, states sci computed, sci,1 ,!
sci holds
2 f1; : : : ; ng. failure occurs given plan valid, i.e., solve given
problem.

6.2 Phase-II: Deriving Abstract Essential Sentences

Using derived concrete state sequence input, following algorithm computes
sequence abstract state descriptions (sai ) applying generic abstraction theory
separately concrete state.

Algorithm 2 (Phase-II: State abstraction)
:= 0 n
sai := ;
E 2 Ea

:= SLD(sci [ Rc [ A; E )
2

sai := sai [ fE g
end
end
end
Please note claimed domain theories designed way

finite contains ground substitution variables E . Therefore, every
description sai consists ground atoms consequently valid abstract state
description. Within introduced model case abstraction computed
superset outcome possible state abstraction mappings. deductively justified
state abstraction mapping restricted ff(sci ) sai = fe 2 Sa jsci [ Rc [ ` eg
2 f1; : : : ; ng. Consequently, determined abstract sentences abstract
case might require.

6.3 Phase-III: Computing Possible Abstract State Transitions

next phase algorithm, search instantiated abstract operators
transform abstract state s~ai sai subsequent abstract state s~aj saj (i < j ).
Therefore, preconditions instantiated operator must least fulfilled
state s~ai consequently sai . Furthermore, added effects operator must
true s~aj consequently saj .
75

fiBergmann & Wilke

Algorithm 3 (Phase-III: Abstract state transitions)
G := ;
:= 0 n , 1
j := + 1 n
o(x1; : : : ; xu) 2 Oa
let hPreo ; Delo; Addoi description o(x1; : : : ; xu)
:= SLD(sai [ Ra ; Preo)
h; 2
letAdd0o = faja 2 Addog
(* Compute possible instantiations *)
(* added sentences hold saj *)
:= f;g
(* set possible substitutions *)
(* initially empty substitution. *)

2 Add0o
0 := ;
2
e 2 saj
substitution = e 0 := 0 [ fg
end
end
:= 0

end

(* Now, contains set possible substitutions *)
(* added sentences contained saj *)

2
G := G [ fhi; j; o(x1; : : : ; xu ); ig
end
end
end
end
end

set possible operator transitions collected directed edges graph
vertices represent abstract states. algorithm, set G edges acyclic
directed graph constructed. pair states (sai,saj ) < j checked
whether exists operator o(x1; : : : ; xu ) applicable sai . purpose,
SLD-refutation procedure computes set possible answer substitutions
precondition operator fulfilled sai . derivation belongs
answer substitution stored together operator graph since
required next phase case abstraction. derivation \and-tree"
inner-node ects resolution goal literal head clause
leaf-node represents resolution fact. Note proving precondition
abstract operator inner nodes tree always refer clauses Horn rule set
Ra, leave-nodes represent facts stated Ra essential sentences contained
76

fiBuilding Refining Abstract Planning Cases

sai . answer substitution applied add-list operator leading
partially instantiated add-list Add0o. Note still variables Add0o

operator may contain variables contained precondition may
occur add-list. Therefore, set possible substitutions incrementally
constructed 2 saj holds 2 Add0o. completely instantiated operator
derived thereby finally included directed edge (from j ) graph G.
algorithm guaranteed (instantiated) operator leads sai
saj applicable sai essential sentences added operator contained
saj . Furthermore, applied SLD-refutation procedure complete (it always finds
answer substitutions), every instantiated operator applicable sai
essential sentences added operator contained saj contained
oai
graph. follows immediately ff(scfi (i,1)) ,!
ff(scfi(i) ) holds arbitrary
deductively justified state abstraction mapping sequence abstraction mapping ,
hfi (i , 1); (i); oai; 2 G holds.

6.4 Phase-IV: Determining Sound Paths

Based state abstractions sai derived phase-II graph G computed
previous phase, phase-IV selects set sound paths initial abstract state
final abstract state. set significant abstract sentences sequence abstraction
mapping determined construction path.
Algorithm 4 (Phase-IV: Searching sound paths)12
Paths := fh(); ;; (fi(0) = 0)ig
exists h(oa1; : : : ; oak); ff; fii 2 Paths fi(k) < n
Paths := Paths n h(oa1 ; : : : ; oak ); ff; fii
hi; j; oa; 2 G = fi(k)
let E set essential sentences contained derivation
let ff0 = E [ Addoa [
2 f1; :a: : ; kg holds:

(safi ( ,1) \ ff0 ) ,!
(sfi ( ) \ ff0 )

(sa \ ff0 )
(safi (k) \ ff0 ) ,!
j
Paths := Paths [ fh(oa1 ; : : : ; oak; oa); ff0; [ ffi(k + 1) = j gi g

end
end

CasesAbs := ;
h(oa1 ; : : : ; oak); ff; fii 2 Paths fi(k) = n
CasesAbs := CasesAbs [ fhhsa0 \ ; san \ i; (oa1 ; : : : ; oak)ig

end
return CasesAbs

construction sequence abstraction mapping obvious, set represents image state abstraction mapping thereby determines set sentences

12. Please note h(oa1 ; : : : ; oak ); ff; matches fh(); ;; (fi (0) = 0)ig k = 0. operator n denotes
set difference.

77

fiBergmann & Wilke

reached order assure applicability constructed operator sequence. Note state abstraction mapping directly determined
follows: ff(sci ) = fe 2 jsci [ Rc [ ` eg. idea algorithm start
empty path. path extended operator G iteration algorithm
path leads final state index n. New essential sentences ff0 may
occur proof precondition added effects new operator. path
constructed far must still consistent according extension state description
and, addition, new operator must transform sentences correctly.
result, phase-IV returns cases abstractions given concrete input
case respect concrete abstract domain definitions generic abstraction
theory. Depending domain theory, single abstract case learned
single concrete case already shown Figure 5.

6.5 Correctness Completeness PABS Algorithm

Finally, want state strong connection formal model case
abstraction presented algorithm. algorithm terminates domain descriptions generic abstraction theory formulated required beginning
section, SLD-resolution procedure always terminates. algorithm correct,
every abstract case computed Pabs algorithm case abstraction according
introduced model. SLD-refutation procedure applied Pabs complete every
case abstraction according Definition 5 returned Pabs. property
captured following theorem.

Theorem 8 (Correctness completeness PABS algorithm) complete SLDrefutation procedure used Pabs algorithm, Case Ca abstraction case Cc
respect (Dc ; Da) generic theory A, Ca 2 PABS(hDc ; Da; Ai; Cc).

6.6 Complexity Algorithm

complexity algorithm mainly determined phases III IV. worst
case complexity phase-III O(n2 C1 C2) n length concrete plan
C1 C2 dependent domain theories follows: C1 = jOa j j
j C2 =
jAddOa j (jEajj
j)jAddOaj. Thereby, jOaj represents number abstract operators, j
j
maximum number substitutions found SLD-refutation procedure, jAddOa j
maximum number added sentences abstract operator, jEaj number
abstract essential sentences. complexity phase-IV determined O(n 2(n,1)
C1). assume constant domain theories overall complexity Pabs algorithm
summarized O(n 2(n,1) ). exponential factor comes possibly exponential
number paths directed acyclic graph n nodes every state connected
every successor state. Whether graph kind appears much dependent
abstract domain theory, determines transitions abstract states
possible. exponential nature lead time complexity problem domains
used. Additionally, want make clear computational effort must
spent learning problem solving. time required learning
long, learning phase executed off-line.
78

fiBuilding Refining Abstract Planning Cases

space complexity algorithm mainly determined phase-III
derivations proofs abstract operators' preconditions must stored.
sum n2 C1 C2 derivations worst case. turn problem
domains used derivation short (in cases
3 inferences static Horn rules). reason derivations relate
abstract operators likely contain less preconditions concrete operators.

7. Refinement Abstract Cases

previous section described abstract cases automatically learned
concrete cases. assume case-base contains set abstract cases.
want show abstract cases used solve problems concrete level.
Furthermore, discuss impact specific form abstract problem solving
domain improvement problem solving achieved.

7.1 Applicability Refinability Abstract Cases

given abstract case concrete problem description, question arises
situations abstract case refined solve concrete problem. kind
refinability a-posterior definition easily given follows.

Definition 9 (Refinability abstract case) abstract case Ca refined solve
concrete problem p exists solution oc p, Ca abstraction
hp; oci.

Obviously, refinability property undecidable general since otherwise planning
would decidable. However, define applicability abstract case
decidable necessary property refinability follows.

Definition 10 (Applicability abstract case) abstract case Ca = hhsa0 ; sami,
(oa1 ; : : : ; oam)i applied solve concrete problem p = hscI ; scG exists state
abstraction mapping sai 2 Im(ff) 2 f0; : : : ; mg ff(scI ) = sa0
ff(scG ) = sam . Thereby, Im(ff) denotes image state abstraction mapping ff, i.e.,

abstract states reached.

applicable abstract case, least guaranteed concrete initial goal
states map abstract ones concrete intermediate states exists
abstracted required abstract case.
Even applicability necessary precondition refinability formally
guarantee refinability, since downward solution property (Tenenberg, 1988), states
every abstract solution refined, strong requirement hold general
abstraction methodology. However, indeed guaranteed abstract case
contained case-base already abstraction one previous concrete cases
due correctness Pabs algorithm used learning. one problems
contained concrete cases solved guaranteed learned
abstract case refined solve problem. Consequently, abstract case
case-base least refined solve one problem occurred past.
79

fiBergmann & Wilke

Abstract solutions useless never refined solve concrete
problem never case-base consequently never tried solving problem.
Therefore, expect abstract case case-base high chance
refinable new similar problems applied.

7.2 Selecting Applicable Abstract Case

decide whether abstract case applied solve concrete problem P ,
determine suitable state abstraction mapping. assume deductively
justified state abstraction mappings,
required state abstraction mapping always




induced set = i=0 si shown Section 5.1. Consequently, Ca applicable
problem p = hscI ; scG sa0 = f 2 j scI [ Rc [ ` g sam = f 2
j scG [Rc [A ` g. Since every abstract case use solving new problem
learned another concrete case, known abstract state sai must
least one concrete state (from previous concrete state) abstracted via
sai . Consequently, sai 2 Im(ff) holds. Together introduced restrictions
definition Rc respect complete SLD-refutation procedure (see Section
6), applicability abstract case decidable. Algorithm 5 describes selection
applicable abstract case problem p = hscI ; scG detail.
Algorithm 5 (Selection applicable abstract case)
saI := saG := ;

E 2 Ea

:= SLD(S
scI [ Rc [ A; E )


sI := sI [ 2
E
E 2 Ea

:= SLD(sScG [ Rc [ A; E )
saG := saG [ 2
E
repeat
repeat
Select new case Ca = hhsa0 ; sam i; (oa1; : : : ; oam)i case base
sa0 saI sam saG
cases available
refineDFID (scI ; (); ;; scG)
return result refineDFID
:=Sm1 , 1 sai := (sai,1 n Deloai ) [ Addoai
:= i=0 sai
(saI \ ff) = sa0 (saG \ ff) = sam
refineDFID (scI ; (sa1; : : : ; sam,1 ); ff; scG)
refineDFID returns success(p)
return success(p)

first, initial final concrete states problem abstracted using
generic abstraction theory. Thereby, abstract problem description hsaI ; saG determined.
Then, pre-selection step, abstract case chosen form case base.
abstract sentences contained initial final abstract state case must
80

fiBuilding Refining Abstract Planning Cases

contained abstracted problem description hsaI ; saG i. condition, however,
guarantee selected case applicable respect Definition 10. set
abstract sentences inducing respective state abstraction mapping computed
applicability condition checked test whether selected case applicable.
selected case applicable, new case must retrieved. applicable abstract
case determined refinement algorithm refineDFID (see following section)
executed. algorithm uses sequence intermediate abstract states (sa1 ; : : : ; sam,1 ),
previously determined abstract plan case, guide search concrete
level. operators contained abstract plan used anymore. refinement
procedure returns success(p), refinement succeeds solution plan p.
refinement fails (the procedure returns failure), another case selected. cases
available problem solved pure search without guidance abstract
plan.

7.3 Refining Abstract Plan
refinement selected abstract case starts concrete initial state
problem statement. search proceeds sequence concrete operations found
leads concrete state sc , sa1 = f 2 j sc [ Rc [ ` g holds.
applicability condition abstract case guarantees state exists (sai 2 Im(ff))
guaranteed required concrete operator sequence exists too. Therefore,
search task may fail causes whole refinement process fail also. first
abstract operator refined successfully new concrete state found. state
taken starting state refine next abstract operator manner.
refinement fails backtrack refinement previous operator try
find alternative refinement. whole refinement process reaches final abstract
operator must directly search operator sequence leads concrete goal
state scG . concrete goal state reached concatenation concrete partial
solutions leads complete solution original problem.
refinement demands search procedure allows abstract goal specification. kinds forward-directed search depth-first iterative-deepening (Korf,
1985b) best-first search (Korf, 1993) procedures used purpose
states explicitly constructed search. states tested see
abstracted towards desired goal. Paris use depth-first iterative-deepening
search described Algorithm 6. algorithm consists two recursive procedures.
top-level procedure refineDFID receives concrete initial state scI , concrete final state
scG , sequence intermediate abstract states = (sa1 ; : : : ; sak) derived abstract
case, well set induces state abstraction mapping. procedure
increments maximum depth depth-first search procedure searchbounded
maximum DeepMax. procedure searchbounded performs actual search. goal
search either abstract state, i.e., first abstract state , concrete
goal state scG abstract state already visited. procedure performs
depth-first search applying available concrete operators recursively calling
search procedure concrete state scnew results operator application.
81

fiBergmann & Wilke

abstract goal state reached removed list refinement
continues next abstract state first one list.
Algorithm 6 (Refinement depth-first iterative-deepening (DFID) search)
procedure refineDFID (scI ; a; ff; scG)
Deep := 0

repeat

searchbounded (scI ; a; ff; scG; Deep)
searchbounded returns success(p) return success(p)
Deep := Deep + 1 (* Search unsuccessful: Increment search deepness *)
Deep = DeepMax

return failure

procedure searchbounded (scI ; a; ff; scG; Deep)
= () (* abstract goals: Test concrete final goal *)
scI = scG return success(())
= (sa1; : : : ; sak) (* least one abstract goal *)
e 2 sa1 holds: SLD(scI [ Rc [ A; e) =6 ;
e 2 n sa1 holds: SLD(scI [ Rc [ A; e) = ;
(* Abstract state reached: Refine next abstract operator *)
refineDFID (scI ; (sa2 ; : : : ; sak ); ff; scG)
refineDFID returns success(p) return success(p)
Deep = 0 return failure (* Maximum depth reached *)
(* Apply operators: Create successor states *)

oc 2 Oc

= SLD(scI [ Rc; Preoc ) (*
set possible operator instantiations *)
2

scnew := (scI n (Deloc )) [ (Addoc ) (* Create successor state *)
searchbounded (scnew ; a; ff; scG ; Deep , 1) (* Continue search new state *)
searchbounded returns success(p) return success((oc) p))
return failure
Please note kind refinement different standard notion refinement hierarchical problem solving (Knoblock et al., 1991b).
strong correspondence abstract operator possible concrete operator.
Moreover, justification structure refined abstract plan completely different
justification structure abstract plan completely independent
definition abstract concrete operators. Even disadvantage compared
usual refinement procedure used hierarchical problem solving, main computational
advantage abstraction caused decomposition original problem smaller
subproblems maintained.

7.4 Alternative Search Procedures Refinement

Besides forward-directed search procedure currently used Paris backward-directed
search used means-end analysis (Fikes & Nilsson, 1971) nonlinear partial-ordered
82

fiBuilding Refining Abstract Planning Cases

planning (McAllester & Rosenblitt, 1991) applied refinement certain
circumstances. Therefore, would either require state concretion function
turn rules generic abstraction theory virtual concrete operators.
state concretion function must able determine single state finite set
concrete states given abstract state together concrete problem description.
Thereby, concrete problem description may help reduce number possible concrete states. derived state concretions used concrete goal states
backward directed search may start.
Alternatively, turn process state concretion directly search procedure representing rule generic abstraction theory virtual abstract
operator. precondition rule generic abstraction theory becomes precondition virtual operator conclusion rule becomes positive effect
operator. using virtual concrete operators together operators
concrete domain, backward-directed planner use abstract state directly
goal search. part plan resulting solution consists concrete operators (and virtual operators) taken refinement abstract
operator.

7.5 Criteria Developing Abstract Problem Solving Domain
abstract problem solving domain generic abstraction theory used important impact improvement problem solving achieved. Therefore,
desirable set criteria state \good\ abstract domain definition look. Strong criteria allowing quantitative predictions resulting speedups
hardly developed. hierarchical planners criteria don't exist either.
However, give set factors determine success approach.
overall problem solving time uenced mainly following four factors: independent refinability abstract operators, goal distance abstract operators, concrete scope
applicability abstract operators, complexity generic abstraction theory.
7.5.1 Independent Refinability Abstract Operators

Following Korf's analysis hierarchical problem solving (Korf, 1987) introduced
2, plan refinement approach reduces overall search space bn
PSection
b(fi (i),fi (i,1)). Thereby, b average branching factor, n length coni=1
crete solution, sequence abstraction mapping used abstraction
concrete case abstract case. already mentioned, cannot guarantee
abstract plan applicable problem really refined. Furthermore, Korf's
analysis assumes backtracking refinement individual abstract
operators required cannot guaranteed. computational advantage
abstraction lost either two cases.
However, abstract operators occurring abstract problem solving domain
fulfill strong requirement independent refinability, guaranteed every
applicable abstract case refined without backtracking. abstract operator oa
independently refinable sc , s~c 2 Sc every state abstraction mapping
83

fiBergmann & Wilke


ff(sc ) ,!
ff(~sc ) holds,
exists sequence concrete operators (oc1; : : : ; ock )
c
c
ok c
o1
sc ,!
: : : ,!
s~ holds.


problem requirement seems much hard develop abstract
problem solving domain operators fulfill requirement. Although cannot
expect operators abstract problem solving domain independently refinable,
knowledge engineer developing abstract domain still try define abstract
operators independently refined situations, i.e., sc , s~c 2 Sc
state abstraction mapping applicable abstract operator refined
concrete operator sequence. Although notion mostly independent refinability
formal feel practically useful developing abstract domain definition.
abstract operators refined independently many situations,
higher chance abstract plan composed operators refinable.
7.5.2 Goal Distance Abstract Operators

goal distance (cf. subgoal distance, Korf, 1987) maximum length sequence
concrete operators required refine particular abstract operator. longer goal
distance larger search space required refine abstract operator. particular,
complexity search required refine complete abstract plan determined
largest goal distance abstract operators occur abstract plan.
Hence good reason keep goal distance short. However, goal distance
negatively interacts next factor, namely concrete scope applicability
abstract operators.
7.5.3 Concrete Scope Applicability Abstract Operators

concrete scope applicability abstract operator specifies many concrete
states abstracted abstract state abstract operator applicable,
many concrete states abstracted abstract state reached
abstract operator. scope determined definition abstract operator
generic abstraction theory responsible specifying admissible state
abstractions. concrete scope applicability abstract operators determines
applicability abstract plans learned. abstract plan applicable concrete problems limited use domains problems
solved vary much. Hence, concrete scope applicability abstract operators large possible. Unfortunately, according experience, abstract
operators large scope usually larger goal distance operators
short goal distance don't large scope applicability. Therefore, compromise
two contradicting issues must found.
7.5.4 Complexity Generic Abstraction Theory

fourth factor uences problem solving time complexity generic
abstraction theory. theory must applied time new concrete state created
concrete level search. complex generic abstraction theory,
time required compute state abstractions. Hence, generic abstraction theory
84

fiBuilding Refining Abstract Planning Cases

require complicated inferences avoid backtracking within SLD-refutation
procedure.
Although four factors don't allow precise prediction expected problem
solving behavior resulting system, provide focus consider
designing abstract problem solving domain related generic abstraction theory.

8. Example Domain: Process Planning Mechanical Engineering
Paris approach successfully tested toy-domains familiar
towers Hanoi (Simon, 1975). domains, hierarchical problem solvers use
dropping sentence approach proven useful (Knoblock, 1994).
section presents new example domain selected field process planning mechanical engineering really requires stronger abstraction
approach.13 selected goal generating process plan production
rotary-symmetric workpiece lathe. problem description, may derived
CAD-drawing, contains complete specification (especially geometry)
desired workpiece (goal state) together specification piece raw material
(called mold) produced (initial state).
left side Figure 9 shows example rotary-symmetric workpiece
manufactured cylindrical mold.14 Rotary parts manufactured putting
mold fixture (chuck) lathe. chucking fixture, together attached
mold, rotated longitudinal axis mold rotation center.
mold rotated cutting tool moves along contour thereby removes certain parts
mold desired goal workpiece produced. Within process
hard determine sequence specific parts workpiece
removed cutting tools used. workpiece chucked certain area
workpiece covered chucking tool cannot processed cutting tool.
Moreover, workpiece chucked area used chucking plain.
Otherwise fixation would suciently stable. Hence, many workpieces usually
processed first chucking workpiece one side processing accessible area.
workpiece chucked opposite side area previously covered
processed. Processing example workpiece shown Figure 9 requires
workpiece first chucked left side right side processed. processed
right side used chuck workpiece area plain allows stable
fixing. Hence, left side workpiece including small groove processed.
explain representation domain detail. complete definition
domain found Online Appendix 1. Several simplifications real
domain required order obtain domain definition could eciently handled
large set experiments. One restriction represent workpieces
right-angled contour elements. example, conical contour cannot represented.
Many different cutting chucking tools available real-life process planning.
13. domain adapted CaPlan-System (Paulokat & Wess, 1994), developed University Kaiserslautern.
14. Note figure shows 2-dimensional drawing 3-dimensional workpiece. measure 1 in.
equals 25.4 mm.

85

fiBergmann & Wilke

Example Workpiece

Grid Representation example workpiece

2 mm
18 mm


40 mm

165 mm

Raw
Material
Workpiece

10 mm

5
4
3
2

8 mm

1

2mm

(4,2)
(1,1)
1 2

3

4

x

6 mm
8 mm

Figure 9: example workpieces grid representation
restricted single chucking tool three different cutting tools.
specification tools simplified. example, rotation
speed workpiece feed cutting tool parameters play
role processing workpiece. impact parameters neglected.
Despite simplifications remaining part real-world domain trivial
represents substantial subset critical problems domain.

8.1 Concrete Domain
explain concrete problem solving domain giving detailed description
states operators.
8.1.1 State Description

representation domain concrete level, exact geometry
workpiece must represented state, including specific measures detail
contour. However, complete workpiece always divided atomic areas
always processed whole. Therefore state representation organized
using grid divides entire workpiece several disjoint rectangular areas
different sizes (see right side Figure 9). Together grid coordinate specific
position size corresponding rectangular area represented. grid used
static part state description change planning. However
different problems require different grids. specific shape workpiece planning
represented specifying status grid rectangle. Table 1 predicates
used represent workpiece described detail.
Besides description workpiece, state representation contains information workpiece chucked kind cutting tool currently used.
Table 2 describes predicates used purpose.
86

fiBuilding Refining Abstract Planning Cases

Predicate Description
xpos max predicates xpos max(xgrid ) ypos max(ygrid ) specify size
ypos max grid direction x-coordinate y-coordinate respectively.
state consists exactly one instance predicates, e.g.,
xpos max(4) ypos max(5) example shown Figure 9.
grid xpos
grid ypos

predicates grid xpos(xgrid ; xstart; xsize ) grid ypos(ygrid ; ystart; ysize )
specify geometrical position size grid areas direction
x-coordinate y-coordinate respectively. first argument
predicates specifies coordinate grid areas, second argument
declares geometrical starting position, third argument specifies
size grid areas. state consists exactly one instance
predicates different x-coordinate y-coordinate.
example above, grid xpos(1,0,18), grid xpos(2,18,2), grid xpos(3,20,165),
grid xpos(4,185,40) specify grid x-direction grid ypos(1,0,8), : : : ,
grid ypos(5,26,8) specify grid y-direction.

mat

predicate mat(xgrid ; ygrid; status) describes status particular
grid area specified coordinates (xgrid ; ygrid). argument status
instantiated one three constants raw, workpiece, none.
constant raw indicates specified area still consists raw material must removed cutting operators. constant
workpiece specifies area consists material belongs
goal workpiece. constant none specifies area contain
material, i.e., material present mold material
already removed previous cutting operations. One instance
mat predicate required grid area specify current state.
previously mentioned predicates change execution plan, mat predicate changed cutting operator.
particular, initial state goal state problem differs status assigned grid areas must become removed. example,
initial state example shown above, sentence mat(4,2,raw)
present final state contains sentence mat(4,2,none).
Table 1: Essential sentences representation workpiece

8.1.2 Operators

process plan manufacture certain workpiece consists sequence operators.
total order operators problem domain manufacturing
steps executed sequentially lathe.15 chosen four different operators
15. However, new brands lathe machine allow parallel processing.

87

fiBergmann & Wilke

Predicate
chuck pos

Description
predicate chuck pos(side) describes whether workpiece currently
chucked either side. parameter side instantiated one
three constants none, right, left. constant none specifies
workpiece chucked constants right left specify
workpiece chucked respective side. state contains
exactly one instance predicate.

covered

predicate covered(xmin ; xmax) specifies areas workpiece
currently covered chucking tool. predicate declares
areas x-coordinate lying within interval [xmin ; xmax]
covered. Covered areas cannot processed cutting tool. state
consist exactly one instance predicate workpiece chucked.

cut tool
predicates cut tool(id) cut direction(dir) specify unique identicut direction fication (id) cutting tool currently used area
processed direction (dir) cutting tool moves. parameter id symbol specifies legal cutting tool described
predicates included static rules Rc concrete domain description. parameter dir instantiated one three constants
left, right center. value left specifies cutting tool moves
left right, right specifies cutting tool moves right
left, center specifies cutting tool move outside towards
center workpiece.

Table 2: Essential sentences representation chucking cutting tools
represent chucking workpiece, selection cutting tool, cutting
process itself. operators described Table 3.
Manufacturing workpiece shown Figure 9 requires 15-step plan shown
Figure 10. first, workpiece chucked left side. cutting tool selected
allows cutting right left. tool indicated grid areas removed.
Please note left side workpiece cannot processed since covered
chucking tool. (see right side Figure 10), workpiece unchucked
chucked right side. tool allows processing left right, upper
part mold removed. Finally, specific tool used manufacture small groove.

8.2 Abstract Domain

example see small groove considered detail
processed basic contour workpiece established. important
characteristic example right part workpiece processed
left side workpiece. sequence crucial success plan. groove
88

fiBuilding Refining Abstract Planning Cases

Operator
chuck

Description
operator chuck(side) specifies workpiece chucked
specified side. side parameter instantiated constants
left right. Chucking allowed workpiece chucked already surface used chucking plain. effect chucking
operation, respective instances predicate chuck pos covered
included state description.

unchuck

operator unchuck specifies chucking workpiece removed. operation executed workpiece chucked already. effect operation, parameter predicate chuck pos
changed none predicate covered deleted.

use tool

operator use tool(dir; id) specifies tool selected subsequent cutting operators direction cutting tool moves.
workpiece must chucked tool chosen. effect
operator respective instantiations predicates cut tool
cut direction added state. parameters use tool
operator definition respective predicates.

cut

operator cut(xgrid ; ygrid) specifies raw material grid
area indicated coordinates (xgrid; ygrid ) removed. effect
operator predicate mat specifies status
particular area changed status raw status none. However,
apply operator several preconditions must fulfilled. workpiece
must chucked chucking tool must cover specified area
area must accessible cutting tool. Moreover, cutting
tool allows processing selected area must already
selected. cutting tool imposes certain constraints geometrical
size area processed it. details, see full
description domain Online Appendix 1.
Table 3: Concrete operators

would processed first workpiece could never chucked left side
processing right side would consequently impossible. Domain experts told us
situation specific example shown. general importance
many cases. fact allows us select parts problem description solution
considered details abstract. Parts \essential"
must maintained abstract case. found abstract
detailed shape workpiece long distinguish processing left
right side workpiece. Furthermore, important distinguish
rough contour workpiece small details grooves. developed
89

fiBergmann & Wilke

1. chuck(left)

7.-8. unchuck, chuck(right)

2.-6. use_tool(right, t2), cut(4,5),...,cut(4,2)

9.-12. use_tool(left,t1),cut(1,5),..,cut(3,5)
13.-15. use_tool(center,t3), cut(2,4), unchuck

Figure 10: plan manufacturing workpiece
abstract domain definition containing new language describing states operators
based abstraction idea.
8.2.1 State Description

introduce new abstract grid divides workpiece left, middle,
right area abstract specific location concrete grid area. areas
called complex processing areas. area assigned particular status. Furthermore,
abstract state contains information whether complex processing area contains
small contour elements (such grooves), grooves exactly look like.
abstract detailed conditions chucking workpiece, abstract state
contains approximation conditions, stating workpiece cannot chucked
particular side, side contains small contour elements already
processed. predicates used represent abstract state described detail
Table 4.
8.2.2 Operators

consider abstract operator completely processes one complex area
workpiece, operator processes complex area roughly, operator
processes small grooves complex area. consider abstract chucking
operator chucking strong impact overall plan. Table 5 shows
available abstract operators.

8.3 Generic Abstraction Theory
generic abstraction theory defines sentences used describe abstract state (see
Table 4) terms sentences concrete state (see Tables 1 2) set
Horn rules. definition abstract sentence explained detail Table 6.
90

fiBuilding Refining Abstract Planning Cases

Predicate
abs area state

Description
predicate abs area state(area; status) describes status
three complex processing areas. argument area
specifies one complex processing areas left, middle, right.
argument status describes status respective area.
status either todo, rough, ready. status todo
specifies area needs processing large contour elements, rough area small contour elements
grooves need processed. status ready specifies
area completed. abstract initial state usually contains
one complex processing areas status todo,
abstract goal state complex processing areas status
ready.

abs small parts

predicate abs small parts(area) specifies complex processing area (area) contains small contour elements need
manufactured.

abs chuck pos

predicate abs chuck pos(side) describes whether workpiece
currently chucked either side. parameter side
instantiated one three constants none, right, left.
predicate exactly meaning chuck pos predicate
concrete level. predicate abstracted
renamed.

abs chuckable wp

predicate abs chuckable wp(side) describes whether workpiece chucked left right side side
completely processed.

Table 4: Essential sentences describing abstract state
strongly considered factors uence quality domain (see Section 7.5) development abstract problem solving domain generic
abstraction theory. Although none defined abstract operators independently refinable, mostly independently refinable. preconditions abstract
operator still contains approximations conditions must fulfilled order assure concrete operator sequence exist refines abstract operator. example,
predicate abs chuckable wp(side) approximation detailed condition (a plain
surface) required chucking. goal distance operator quite different
strongly depends problem solved. goal distance set fixation
operators two (possibly one unchuck operator followed chuck operator)
goal distances abstract operators different. example, goal distance process ready operator depends number concrete grid areas belonging
91

fiBergmann & Wilke

Operator
set fixation

Description
operator set fixation(side) specifies workpiece chucked
specified side. side parameter instantiated
constants left, right none. constant none specifies
chucking removed. Compared concrete operator chuck
preconditions chucking side simplified. effect
operator predicate abs chuck pos modified.

process rough

operator process rough(area) specifies complex processing
area (area) processed completely small contour elements. parameter area either left, middle, right.
precondition operator requires workpiece chucked
different side area. effect operator predicate abs area state modified.

process fine

operator process fine(area) specifies small contour elements
complex processing area (area) processed. parameter area either left, middle, right. precondition
operator requires large contour elements side
workpiece already processed workpiece chucked
different side. effect operator predicate
abs area state modified.

process ready

operator process ready(area) specifies indicated complex
area workpiece completely processed, including large
small contour elements. effect operator predicate
abs area state modified.
Table 5: Abstract operators

respective abstract area containing material needs removed.
goal distance number gird areas, say c, plus number required use tool
operations (less equal c). Hence, goal distance c 2c.
goal distance become long complex problems, two operators
process rough process fine introduced. cover processing small
large grid areas respectively consequently smaller goal distance
process ready operator. goal distance two operators smaller
smaller concrete scope applicability process ready operator. example
process ready operator applied state arbitrary areas need
processed, process fine applied states large grid areas
already processed.
Although developed simplified version whole domain production planning mechanical engineering rotary symmetrical workpieces feel
92

fiBuilding Refining Abstract Planning Cases

Abstract Predicate Description terms predicates concrete domain
abs area state
predicate abs area state(area; status) describes status
three complex processing areas. left processing area
consists areas concrete grid covered,
workpiece chucked left side. Similarly, right processing
area consists concrete grid areas covered
workpiece chucked right side. middle processing area
consists areas never covered chucking
tool. status complex processing area todo, exists
concrete large grid area belongs complex processing
area needs processed. grid area considered
large size direction x-coordinate larger 3
mm. status complex processing area rough, large
grid areas complex processing area already processed
exists concrete small grid area belongs
complex processing area needs processed. gird
area considered small size direction x-coordinate
smaller equal 3 mm. status complex processing
area ready concrete grid areas belong complex
processing area processed.
abs small parts

sentence abs small parts(area) holds exists small concrete grid area (size smaller equal 3 mm) belongs
complex processing area needs processed.

abs chuck pos

sentence abs chuck pos(side) holds concrete
sentence chuck pos(side) holds.

abs chuckable wp

predicate abs chuckable wp(side) describes whether workpiece still chucked left right side side
completely processed. sentence holds part desired
workpiece belongs respective side completely plain.
is, concrete grid areas status workpiece range
y-coordinate.
Table 6: Generic abstraction theory

domain expert together knowledge engineer able define abstract
domain representation generic abstraction theory complete domain. particular, model-based interactive knowledge acquisition tools MIKADO (Schmidt, 1994;
Schmidt & Zickwolff, 1992) make complete modeling task much feasible.
93

fiBergmann & Wilke

Case C1
Initial state

Goal State

Solution
1. chuck(left)
8.
chuck(right)
13. use_tool(center, t3)
2. use_tool(right,t2) 9.
use_tool(left,t1) 14. cut(2,4)
3.-6. cut(4,5),..., cut(4,2) 10.-12. cut(1,5),..., cut(3,5) 15. unchuck
7. unchuck

Problem
Abstraction

1.

2.- 6.

7.- 8.

9.- 12.

I.

II.

III.

IV.

13.- 14.

15.
Problem
Abstraction

Abstraction
V.

VI.

Abstract Case Ca
Abstract initial state
abs_area_state(left, todo)
abs_area_state(right,todo)
abs_small_parts(left)
abs_chuckable_wp(right)

Problem
Abstraction

Abstract Solution
I. set_fixation(left)
II. process_ready(right)
III. set_fixation(right)

Abstract goal state

IV. process_rough(left)
V. process_fine(left)
VI. set_fixation(none)

I.

II.

III.

1.

2.- 3.

4.- 5.

IV.

V.

VI.

11.- 14.

15.

abs_area_state(left, ready)
abs_area_state(right,ready)
abs_chuckable_wp(right)

Refinement
6.- 11.

New Case C2

Initial state

Solution Solution
1. chuck(left)
2. use_tool(right,t2)
3. cut(7,3)
4. unchuck

Problem
Abstraction

Goal State

5.
chuck(right),
12. use_tool(center, t3)
6.
use_tool(left,t1), 13. cut(2,2)
7.-11. cut(1,3),...,cut(5,3), 14. cut(4,2)
15. unchuck

Figure 11: Abstracting Refining Example Case

8.4 Abstracting Refining Process Planning Case

explain example case shown Figure 9 abstracted
abstract case reused solve different planning problem. process
demonstrated Figure 11. top figure shows concrete planning case C1
already presented Figure 9. case abstracted Pabs algorithm presented
Section 6. algorithm returns 6 different abstract cases16. One abstract cases
shown center figure. abstract solution plan consists sequence 6
abstract operators. sequence operators plan indicated Roman
numerals. particular abstraction indicated concrete abstract case
denotes sequence concrete operators turned abstract operator.
16. 5 abstract cases differ shown abstract case two aspects: shown abstract
solution additional abstract step set fixation(none) inserted steps II III.
abstract step V replaced abstract step process ready, abstract steps IV V
together replaced abstract step process ready.

94

fiBuilding Refining Abstract Planning Cases

learned abstract case used solve new problem C2 whose initial
final concrete states shown bottom figure. Even concrete workpiece
looks quite different workpiece case C1 abstract case used solve
problem. reason new workpiece requires left
right side must processed. particular right side must processed
left side processed left side contains two small grooves prevent
workpiece chucked side processed. However, see
abstract operators (in particular operators II, VI, V) refined completely
different sequences concrete operators abstracted.
already mentioned, abstract operators used independently refinable
mostly independently refinable. Consequently, happen applicable abstract case cannot refined. Figure 12 shows example concrete planning problem
abstract case shown Figure 11 applicable refinable. reason
location small abstract part left side workpiece. small
part consists concrete grid area (1,3) raw material must removed. However, specific situation, small part must removed large parts,
left side workpiece contains (the grid areas (2,3), (3,3), (2,2)), removed.
reason without removing small part, larger parts located right
small part cannot accessed cutting tool able cut areas (2,3)
(3,3). Consequently problem solved plan shown right
side Figure 12. Unfortunately, plan refinement abstract plan shown
Figure 11, abstract plans requires large parts must removed
small parts removed. Hence, refinement operator process rough(left) fails.
situation problem solver must select different abstract plan.

9. Empirical Evaluation Results
section presents results empirical study Paris mechanical engineering domain already introduced. evaluation performed fully implemented
Paris system using abstraction abilities system. generalization component switched-off purpose. designed experiments allow us
judge performance improvements caused various abstract cases derived Pabs.
Furthermore, analyzed average speed-up behavior system respect
large set randomly selected training test cases.

9.1 Planning Cases
empirical evaluation 100 concrete cases randomly generated. case
requires 100-300 sentences describe initial final state,
instances mat predicate. length solution plans ranges 6 18
operators. Even generated cases represent simple problems compared
problems real domain expert needs solve, search space required solve sample
problems already quite large. due fact branching factor b
1:7 6:6, depending complexity problem. Hence, 18-step solution
complete search space consists 3:7 1015 states.
95

fiBergmann & Wilke

Solution

New Problem


2 mm
3
2

2mm

1

Workpiece

8 mm

1. chuck(left)
2. use_tool(right,t2)
3. cut(4,3)
4. cut(4,2)
5. unchuck
6. chuck(right)
7. use_tool(left,t1)
8. cut(1,3)
9. cut(2,3)
10. cut(3,3)
11. use_tool(center, t3)
12. cut(2,2)
13. unchuck

18 mm
abs_small_parts(left)
1 2

3

4

x

Figure 12: Example Case refinement abstract plan shown Figure
11 fails.

case generation procedure leads solutions optimal nearly optimal.
solutions require less 10 steps optimal solutions sense
known shortest solution problem solve. solutions longer
10 steps manually checked see whether contain steps
obviously redundant. redundant steps removed. Although solutions
necessarily shortest solutions, nevertheless acceptably short.

9.2 Evaluating Abstraction Dropping Sentences
first used recent version Alpine (Knoblock, 1993) together Prodigy4 (Blythe et al., 1992) check whether abstraction dropping sentences improve
problem solving domain represented described Section 8. Therefore, used
concrete problem solving domain domain theory Prodigy. Unfortunately,
representation, Alpine able generate ordered monotonic abstraction
hierarchy. reason Alpine distinguish different groups
literals different literal names (and argument types) used
problem space. example, Alpine cannot distinguish different sentences
described mat grid xpos predicate. important
abstraction. would drop parts grid represent small rectangles
grooves. However, would require examination measures associated
grid area (as argument) relation surrounding grid areas. Therefore, sentence drop (or criticalities assign) cannot decided statically
name predicate type arguments. hierarchical planners including
96

fiBuilding Refining Abstract Planning Cases

Prodigy Alpine highly dependent representation used, particular

strategy restricted dropping sentences (Holte et al., 1994, 1995). However, might
another representation domain hierarchical planners improve
performance think representation quite "natural" domain.
first trial conclude application domain representation
chosen following experiments Paris really require dropping
sentences achieve improvement abstraction.

9.3 Evaluating PARIS Approach

first experiment Paris designed evaluate hypotheses domain
need (I) changing representation language abstraction, (II)
reusing abstract cases instead generating abstract solutions scratch. test
hypotheses rely time solving randomly generated problems using different
modes Paris system.
9.3.1 Experimental Setting
experiment used Paris system solve 100 problems randomly

generated cases. Thereby goal abstraction improve concrete-level problem
solver, performs brute-force search depth-first iterative-deepening search
strategy (Korf, 1985a) introduced Section 7.3. improvement determined
terms problem solving time required solve single problem. Paris used solve
100 problems three different modes:

Pure search: problem solver used solve problem pure search without
use abstraction.

Hierarchical planning: mode Paris uses introduced abstract domain. How-

ever, abstract cases recalled case library computed automatically search standard hierarchical planning, using new abstraction language. So, problem solver first tries search solution original
problem abstract domain tries refine solution.
hierarchical problem solving, backtracking two levels abstraction
subproblem occur. Thereby, used hierarchical planning
new abstraction methodology instead dropping sentences.

Reasoning abstract cases: mode first used Paris learn abstract
cases come 100 concrete cases. problem, abstract cases
exists according abstraction methodology available one
problems solved. problem solving measured time required
solving problem using every applicable abstract cases. Then, problem,
three abstract cases determined: a) best abstract case, i.e., case leads
shortest solution time, b) worst abstract case (longest solution time)
abstraction aspired solution case, c) worst applicable abstract
case determined. difference b) c) relates difference
applicable refinable abstract cases introduced Section 7.1. abstract case
97

fiBergmann & Wilke

selected c) applicable current problem, might abstraction
case problem taken. b) abstract cases selected
indeed abstractions current problem, i.e., abstract cases
previously learned case problem taken. three
different cases selected figure impact case selection (which
addressed paper) proposed method.
Although every problem theoretically solved brute-force search procedure,
exponential nature search space avoids solution complex problems within
reasonable time. Therefore, time-bound 200 CPU seconds Sun Sparc-ELC
computer introduced three modes described above. limit-bound
exceeded problem remains unsolved. Increasing time-bound would increase
number solvable problems three modes.
9.3.2 Results

determined solution time 100 problems described
modes. average solution time well number problems could solved
within time limit shown Table 7. determined values reasoning
abstract cases separately three types abstract cases. significance
speedup results investigated using maximally conservative sign test
(Etzioni & Etzioni, 1994). Unfortunately turned speedup hierarchical
planning pure search significant. couldn't find significant speedup
reasoning abstract cases using always worst applicable abstract case (c)
pure search. due large number doubly censored data (both problem
solvers cannot solve problem within time limit), counted
speedup hypothesis. However, improvements pure search reasoning refinable
abstract cases significant (p < 0:000001) using best refinable case (a)
using worst refinable case (b). Furthermore, turned speedup
reasoning refinable cases hierarchical planning significant upper
bound p-value 0:001. mentioned p-value standard value used statistical
hypothesis tests. probability, assuming hypothesis hold,
encountering data favors hypothesis much observed data
experiment (Etzioni & Etzioni, 1994). Therefore result significant
p-value smaller. analysis, clearly see, two basic hypotheses
supported experimental data. Even significant see moderate
improvement problem solving time number solved problems using
hierarchical planning changing representation language. Please remember
hierarchical planning dropping conditions lead improvement (see
Section 9.2). Obviously, changing representation language abstraction required
improve problem solving domain stated first hypothesis (I).
strong support second hypothesis (II) found presented
data. see significant speedups reasoning abstract cases pure search
even hierarchical planning. worst abstract case used problem
solved, speedup significant problem solving behavior slightly
worse hierarchical planning. Please note situations extremely unlikely
98

fiBuilding Refining Abstract Planning Cases

Problem solving mode
Average solution time (sec.) Solved problems
Pure search
156
29
Hierarchical planning
107
50
Reasoning abstract cases
(a) Best refinable case
35
94
(b) Worst refinable case
63
79
(c) Worst applicable case
117
45
Table 7: Comparison average solution time per problem number solved
problems within time-bound 200 seconds. table compares pure search
(depth-first iterative deepening), hierarchical planning using abstract problem solving domain, reasoning abstract cases differently selected
abstract cases.
happen all. sophisticated indexing retrieval abstract cases situation
avoided part.

9.4 Evaluating Impact Different Training Sets
one respect previous experiment based optimistic assumption. always
assume abstract cases required solving problem learned advance.
situation realistic scenario application. Usually, one set cases
available training system different set problems needs solved.
cannot assume good applicable abstract cases always available solve new
problem. Furthermore, presented example shows problem solving time
vary lot different abstract cases selected problem solving. Therefore,
designed new experiment evaluate improvements caused Paris approach
realistic scenario.
9.4.1 Experimental Setting

randomly chosen 10 training sets 5 cases 10 training sets 10 cases
100 available cases. training sets selected independently other.
Then, 20 training sets used separate experiment. 20
experiments, 100 cases used particular training set
used evaluate performance resulting system. Training set test set
completely independent procedure. problem solving task,
determine problem solving behavior applicable abstract cases, used
simple automatic mechanism retrieve one (hopefully good) applicable abstract case
problem. Therefore, cases organized linearly cases base, sorted
length abstract plan contained case. case base sequentially searched
longer shorter plans applicable case found. heuristic based
assumption longer abstract plan specific shorter abstract plan
99

fiBergmann & Wilke

Size training sets
(cases)
5
10

Number abstract cases
minimum
maximum
average
7
15
9.1
8
25
14.2

Table 8: Comparison number learned abstract cases a) 10 training sets
consists 5 concrete cases b) 10 training sets
consists 10 concrete cases. table shows minimum, maximum,
average number abstract cases learned 10 training sets
respective size.
Size training sets
(cases)
5
10

Average problem solving time (sec.)
best set
worst set
average
43
89
59
35
76
56

Table 9: Comparison problem solving time required reasoning abstract cases
separate training a) 10 training sets consists 5
concrete cases b) 10 training sets consists 10 concrete
cases. table shows average problem solving time per problem best,
worst average training set 10 training sets size.
divides actual problem more, smaller subproblems. Consequently longest
applicable plan lead best improvement.
9.4.2 Results

statistically evaluated second experiment. Table 8 shows number abstract
cases could learned different training sets. minimum, maximum
average number abstract cases could learned 10 training sets
size indicated. Note altogether 42 abstract cases learned 100
cases would used training previous experiment. 10 training
sets contained 5 cases each, 7 15 abstract cases could learned.
expected, size training set increased abstract cases learned.
Table 9 shows average problem solving time learning different sets.
table shows minimum, maximum average problem solving time
10 different training sets two sizes. see best training sets leads
problem solving time similar slightly worse optimum shown
Table 7. Even average case, considerable improvements pure search
hierarchical problem solving (compare Table 7 Table 9) discovered.
100

fiBuilding Refining Abstract Planning Cases

Size training sets
(cases)
5
10

Percentage Solved Problems
best set
worst set
average
91
68
83
94
74
86

Table 10: Comparison percentage solved problems separate training
a) 10 training sets consists 5 concrete cases b) 10
training sets consists 10 concrete cases. table shows
percentage solved problems best, worst average training
set 10 training sets size.
Size training sets
(cases)
5
10

Number training sets significant speedups
pure search
hierarchical planning
p < 0:0005
p < 0:0005
p < 0:05
9
4
8
10
5
7

Table 11: Comparison significance (p-value) speedup results pure search
hierarchical planning separate training a) 10 training sets
consists 5 concrete cases b) 10 training sets
consists 10 concrete cases. table shows number training sets
cause significant speedups different p-values.
positive results identified looking percentage solved problems,
shown Table 10. see best training sets number solved
problems close maximum achieved approach. Even worst
training set considerably problems could solved pure search hierarchical
planning.
Additionally mentioned speedup results analyzed maximally conservative sign test described (Etzioni & Etzioni, 1994). Table 11 summarizes
significance results speeding pure search hierarchical problem solver.
turned 19 20 training sets lead highly significant speedups (p < 0:0005)
pure search. hard upper bound p-values half training
sets lead significant differences reasoning abstract cases hierarchical
planning. slightly higher upper bound p < 0:05, 3=4 training sets
caused significantly better performance hierarchical planning.
Altogether, reported experiment showed even small number training cases
(i.e., 5% 10%) already lead strong improvements problem solving.
see abstract cases must present, first experiment, successful.
Furthermore, experiment shown even simple retrieval mechanism (sequential
101

fiBergmann & Wilke

Size training sets
(cases)
5
10

Average percentage solutions
shorter/equal/longer solution length
shorter
equal
longer
20
54
26
22
50
28

Table 12: Comparison length solutions created reasoning learned
abstract cases solutions available concrete cases. table shows
average percentage solutions shorter/equal/longer solution length
separate training a) 10 training sets consists 5
concrete cases b) 10 training sets consists 10 concrete
cases.
search) select beneficial abstract cases library. Neither training situations
second experiment lead results worse worst case shown Table
7.

9.5 Quality Produced Solutions

Although main purpose approach improve performance problem
solver, quality produced solutions important practical system.
solution length used simple criterion determine quality
solution. However, general quality solution ect execution costs
plan, plans robustness, certain user preferences (Perez & Carbonell, 1993).
quality measures dicult assess, particular manufacturing
domain, rely simple criterion used evaluating quality solutions
Prodigy/Analogy (Veloso, 1992).
9.5.1 Experimental Setting

analyzed solutions computed previous set experiments assess
quality solutions produced Paris. Therefore, length solutions derived
problem solving, learning 20 training sets, compared
length nearly optimal solutions contained concrete cases.
9.5.2 Results

training set length solution derived corresponding testing phase
compared length solution noted concrete case. percentage
solutions shorter, equal, longer solution length determined training set
separately, average 10 training sets equal size determined. Table
12 shows result evaluation.
turned big difference quality results 20
training sets. particular, size training sets strong uence
102

fiBuilding Refining Abstract Planning Cases

results. Table 12 see 72% (22% + 50%) 74% (20% + 54%)
solutions produced equal better quality solutions contained
concrete cases. Please note concrete cases used testing always different
cases used training. Additionally, solutions compare
results produced Paris already nearly optimal solutions due case generation
procedure.17 Taking account, results already fairly good.

9.6 Impact Abstract Problem Solving Domain
experiments reported conducted concrete abstract domain
representation presented Section 8 Online Appendix 1. final experiment
impact specific choice abstract problem solving domain investigated.
9.6.1 Experimental Setting

created new abstract problem solving domain less constrained one
used before. purpose one operator completely removed certain conditions
remaining operators removed also. particular, set fixation operator
removed conditions abs chuck pos, abs chuckable wp, chuck comp removed
preconditions three remaining operators. Hence, fact chucking
workpiece impact production plan neglected abstract level.
However, concrete problem solving domain generic abstraction theory
modified all. Consequently, chucking still plays important role concrete level.
set experiments described Section 9.4 repeated less constrained
abstract problem solving domain using training testing sets before.
9.6.2 Results

Table 13 14 summarize results experiments. Table 13 shows average
problem solving time occurs learning different training sets. turns
training sets, learning improves concrete level problem solver,
speedup much smaller using original abstract problem solving domain
(cf. Table 7 9). particular, none resulting speedups concrete level problem
solving significant. similar result observed comparing percentage
solved problems (see Figure 14). still slight improvement number
problems could solved learning improvement much smaller
using original abstract problem solving domain (cf. Table 7 10).

17. cases one, shorter solutions produced Paris one step shorter solution
contained concrete case.

103

fiBergmann & Wilke

Size training sets
(cases)
5
10

Average problem solving time (sec.)
best set
worst set
average
114
118
117
107
112
110

Table 13: Using less constrained abstract problem solving domain: Comparison
problem solving time required reasoning abstract cases separate
training a) 10 training sets consists 5 concrete cases
b) 10 training sets consists 10 concrete cases. table
shows average problem solving time per problem best, worst
average training set 10 training sets size.

Size training sets
(cases)
5
10

Percentage Solved Problems
best set
worst set
average
55
52
53
58
54
56

Table 14: Using less constrained abstract problem solving domain: Comparison
percentage solved problems separate training a) 10 training sets
consists 5 concrete cases b) 10 training sets
consists 10 concrete cases. table shows percentage solved problems
best, worst average training set 10 training sets
size.
experiment supported general intuition abstract problem solving domain significant impact improvement problem solving achieved
reasoning abstract cases. reason less constrained domain leads
worse results original abstract domain explained respect
criteria explained Section 7.5. Since important preconditions abstract operators
removed many situations new operators cannot refined.
holds particularly situations workpiece cannot chucked perform
required cutting operations. new abstract operators mostly independently
refinable. Moreover, since abstract operator set fixation removed concrete chuck
unchuck operator must introduced refinement remaining abstract
operators. Consequently, goal distance abstract operators increased.
two factors reason worse results using less constrained abstract domain
theory.
104

fiBuilding Refining Abstract Planning Cases

10. Discussion
paper shown detail hierarchical problem solving (Sacerdoti, 1974;
Tenenberg, 1988; Unruh & Rosenbloom, 1989; Yang & Tenenberg, 1990; Knoblock, 1990)
limited view abstraction dropping sentences well strategy
abstract solutions computed lead poor behavior various relevant situations.
observation supported comprehensive artificial examples (see Section 2.1 2.2)
real-world example domain mechanical engineering (see Section 8),
supported experiment (see Section 9.2). recent results reported (Holte et al.,
1995) support observations well.
general, abstraction task transforming problem solution concrete representation different abstract representation, reducing level
detail (Michalski & Kodratoff, 1990; Giunchiglia & Walsh, 1992; Michalski, 1994). However, hierarchical problem solvers, much limited view abstraction
dropping sentences shown reason ecient ways abstracting problem
solution impossible (e.g., see Section 2.1 Figure 4). second weakness
hierarchical problem solvers usually compute arbitrary abstract solutions solutions high chance refinable next concrete
level. Although upward solution property (Tenenberg, 1988) guarantees refinable abstract solution exists, guaranteed problem solver finds abstract
solution (e.g., see Section 2.2). Problem solvers even heuristically guided towards
refinable abstract solutions.
Paris approach present new formal abstraction methodology problem
solving (see Section 5) allows abstraction changing whole representation language concrete abstract. Together formal model, correct complete
learning algorithm abstracting concrete problem solving cases (see Section 6) given.
abstract solutions determined procedure useful solving new concrete
problems, high chance refinable.
detailed experimental evaluation fully implemented Paris system
domain mechanical engineering strongly demonstrates Paris significantly improve problem solving situations hierarchical problem solver using dropping
sentences fails show advantage (see Table 7 11).

10.1 Related Work
discuss Paris approach relation relevant work field.
10.1.1 Theory Abstraction

Within Giunchiglia Walsh's (1992) theory abstraction, Paris approach
classified follows: formal system ground space 1 given concrete
problem solving domain Dc using situation calculus (Green, 1969) representation.
language abstract formal system 2 given language abstract
problem solving domain Da . However, operators Da turned axioms
2 . Instead, abstract cases build axioms 2 . Moreover, generic abstraction
theory defines abstraction mapping f : 1 ) 2 . Within framework, view
105

fiBergmann & Wilke

Paris system learns useful axioms abstract system, composing several

smaller elementary axioms (the operators). However, prove formula (the existence
solution) abstract system, exactly one axiom (case) selected. deductive
machinery abstract system restricted respect ground space. Depending
learned abstract cases abstractions Paris either theory decreasing (TD)
theory increasing (TI). case-base abstract cases completely empty
domain axiom available resulting abstractions consequently TD. casebase contains maximally abstract case hhtrue; truei(nop)i18 (and generic abstraction
theory contains clause ! true), case applied every concrete problem
resulting abstraction consequently TI. Even maximally abstract case
improve ground level problem solving, always included case-base
ensure TI property, loosing completeness. case retrieval mechanism
must however guarantee, maximally abstract case chosen refinement
applicable case available. Note, fulfilled retrieval mechanism
(sequential search longer shorter plans) used experiments.
10.1.2 Skeletal Plans

already mentioned Section 3.4 Paris approach inspired idea skeletal
plans (Friedland & Iwasaki, 1985). abstract cases seen skeletal plan,
learning algorithm means learn skeletal plans automatically concrete
plans. Even idea skeletal plans intuitively appealing, knowledge,
paper contains first comprehensive experimental support usefulness planning
skeletal plans. Since shown skeletal plans acquired automatically,
planning method applied easily.
purpose, Anderson Farley (1988) Kramer Unger (1992) proposed approaches plan abstraction go direction Paris algorithm.
However, approach automatically forms abstract operators generalization, mostly
based dropping sentences. Moreover, abstracted plan, every concrete operator
abstracted, number operators reduced abstraction. Thereby
abstraction approach less powerful Paris style abstractions.
10.1.3 Alpine's Ordered Monotonic Abstraction Hierarchies
Alpine (Knoblock, 1989, 1990, 1993, 1994) automatically learns hierarchies abstraction

spaces given domain description domain description together planning problem. mentioned several times before, Alpine relies abstraction dropping
sentences. However, enables Alpine generate abstraction hierarchies automatically.
stronger abstraction framework one follow Paris, automatic
generation abstraction hierarchies (or abstract domain descriptions) seem
realistic due large (infinite) space possible abstract spaces. use powerful abstraction methodology, feel pay price losing ability
automatically construct abstraction hierarchy.
Another point specific property ordered monotonic abstraction hierarchies
generated Alpine, allows ecient plan refinement. refinement, ab18. nop 'no operation' operator always applicable change abstract state.

106

fiBuilding Refining Abstract Planning Cases

stract plan expanded successively lower levels inserting operators. Furthermore,
already established conditions plan guaranteed violated anymore refinement. Unfortunately, kind refinement cannot performed Paris-style
abstractions. Especially, direct correspondence abstract operators
concrete operators. Consequently, abstract plan cannot extended become
concrete plan. However, main function abstract plan maintained, namely
original problem decomposed several smaller subproblems causes main
reduction search.
10.1.4 Explanation-based Learning, Case-based Reasoning Analogy

presented Paris approach uses experience improve problem solving, similar several
approaches machine learning, mostly explanation-based learning (Mitchell et al.,
1986; DeJong & Mooney, 1986), case-based reasoning (Kolodner, 1980; Schank, 1982; Althoff & Wess, 1992; Kolodner, 1993) analogical problem solving (Carbonell, 1986; Veloso
& Carbonell, 1988). basic ideas behind explanation-based learning case-based
analogical reasoning much related. common goal approaches
avoid problem solving scratch situations already occurred past.
Explanations (i.e., proofs justifications) constructed successful solutions already
known system. explanation-based approaches, explanations mostly cover
whole problem solving process (Fikes, Hart, & Nilsson, 1972; Mooney, 1988; Kambhampati
& Kedar, 1994), relate problem solving chunks (Rosenbloom & Laird,
1986; Laird, Rosenbloom, & Newell, 1986) smaller size even single decisions
within problem solving process (Minton, 1988; Minton et al., 1989). Explanation-based
approaches generalize constructed explanations learning extensive use
available domain knowledge store result control rule (Minton, 1988) schema
(Mooney & DeJong, 1985). case-based reasoning systems Priar (Kambhampati
& Hendler, 1992) Prodigy/Analogy (Veloso & Carbonell, 1993; Veloso, 1994) cases
usually explicitly generalized advance. kept fully instantiated
case library, annotated created explanations. Unlike cases Paris
problem-solution-pairs, cases complete problem solving episodes containing detailed information decision taken problem solving. problem
solving, cases retrieved contain explanations applicable current problem (Kambhampati & Hendler, 1992; Veloso & Carbonell, 1993; Veloso, 1994). detailed
decisions recorded cases replayed modified become solution
current problem. approaches use kind generalization experience,
none approaches use idea abstraction speedup problem solving based
experience. already noted (Michalski & Kodratoff, 1990; Michalski, 1994), abstraction generalization must confused. generalization transforms description
along set-superset dimension, abstraction transforms description along level-of-detail
dimension.
exception given (Knoblock, Minton, & Etzioni, 1991a) Alpine's
abstractions combined EBL component Prodigy. Thereby, control rules
learned refer ground space problem solving abstract
spaces. control rules speedup problem solving abstract level. However,
107

fiBergmann & Wilke

control rules guide problem solver abstract level finds solutions faster
manner finds refinable abstract solutions. Although
experience kind integration abstraction explanation-based learning,
assume control rules generated EBL component guide problem
solver towards short abstract solutions cause much reduction search
several circumstances.

10.2 Requirements Limitations PARIS

following, summarize requirements limitations Paris
approach. main requirements availability good abstract domain description
availability concrete cases.
10.2.1 Abstract Domain

important prerequisite method availability required background knowledge, namely concrete world description, abstract world description,
generic abstraction theory. construction planning system, concrete
world descriptions must acquired anyway, since specify \language\ problem description (essential sentences) problem solution (operators). abstract
world generic abstraction theory must acquired. feel indeed
price pay make planning tractable certain practical situations.
Nevertheless, formulation adequate abstract domain theory crucial
success approach. abstract operators missing required express
useful abstract plan, speedup achieved. need mostly independently
refinable abstract operators. operators exist, simply represented
abstract domain using whole representational power. hierarchical planning
dropping conditions, abstract domain must implicitly contained concrete
domain way abstract domain remains, certain literals concrete domain
removed (see Section 2.1). feel kind modeling much harder
achieve modeling abstract view domain explicitly distinct planning space
Paris. Additionally, requirement abstract domain given user
advantage learned abstract cases expressed terms user
familiar with. Thereby, user understand abstract case easily. open
additional opportunity involve user planning process, example
selection abstract cases she/he favors.
Research knowledge acquisition shown human experts employ lot
abstract knowledge cope complexity real-world planning problems. Specific knowledge acquisition tools developed comfortably acquire abstract
knowledge different sources. Especially, acquisition planning operators addressed much detail (Schmidt & Zickwolff, 1992; Schmidt, 1994).
10.2.2 Availability Cases
second prerequisite, Paris approach needs concrete planning cases (problem-

solution pairs). real-world scenario cases usually available company's
filing cabinet database. According requirement share general view
108

fiBuilding Refining Abstract Planning Cases

machine learning use kind experience promising way cope
highly intractable problems. Paris approach available cases must
somehow representative future problem solving tasks. known cases must similar
enough new problems abstract cases really reused. experiments
give strong indications even small set concrete cases training leads high
improvements problem solving (see Table 9 11).

10.3 Generality Achieved Results

reported experiments performed specific base-level problem solver
performs depth-first iterative-deepening search strategy (Korf, 1985a). However,
strongly believe Paris abstractions beneficial problem solvers
using backward-chaining, means-end analysis nonlinear partial-order planning. shown
(Veloso & Blythe, 1994), one optimal planning strategy. Different planning
strategies usually rely different commitments search. strategy useful
one domain may worse others. However, search strategies, length
shortest possible solution usually determines amount search required.
Paris, whole search problem decomposed several subproblems allow
short solutions. Consequently, kind problem decomposition use
search strategies.
Moreover, think idea reasoning abstract cases, formulated
completely new terminology ground space useful kinds
problem solving design model-based diagnosis. model-based diagnosis,
developed approach (Pews & Wess, 1993; Bergmann, Pews, & Wilke, 1994) similar
Paris. domain descriptions consist model technical system
diagnosis found. describes behavior elementary composed
component system different levels abstraction. model-based diagnosis,
behavior technical system simulated possible faulty component searched
cause observed symptoms. Using abstract cases, search reduced
focused onto components already defective (in similar machines)
consequently likely defective new situations.

10.4 Future Work

Future research investigate goal-directed procedures refinement backwarddirected search non-linear partial order planners (see Section 7.4). Additionally,
experience must gained additional domains different representations them.
Furthermore, address development highly ecient retrieval algorithms
abstract cases. Table 7 shows, retrieval mechanism strong uence
achieved speedup. Even linear retrieval presented turned pretty
good, expect utility problem (Minton, 1990) occur size casebase grows. Furthermore, good selection procedure abstract cases use
feedback problem solver evaluate learned abstract cases based
speedup cause. would eliminate unbeneficial cases abstract operators
case-base abstract problem solving domain. Experiments different indexing
retrieval mechanisms recently indicated possible.
109

fiBergmann & Wilke

Furthermore, speedup caused combination different approaches
abstraction explanation-based learning addressed. Within Paris system
explanation-based component case generalization still present (see Figure 3),
used experiments plain abstraction evaluated.
experiments, abstraction, explanation-based learning integration
addressed comprehensively. hopefully lead better understanding
different strengths methods have.
long-term research goal, Paris-like approaches developed
evaluated kinds problem solving tasks configuration design or,
already started, model-based diagnosis.

Appendix A. Proofs

section contains proofs various lemma theorems.

Lemma 6 (Joining different abstractions) concrete domain Dc two disjoint abstract domains Da1 Da2 given, joint abstract domain Da = Da1 [ Da2
defined follows: Let Da1 = (La1; Ea1; Oa1; Ra1) let Da2 = (La2; Ea2; Oa2; Ra2).
Da = Da1 [ Da2 = (La1 [ La2 ; Ea1 [ Ea2 ; Oa1 [ Oa2 ; Ra1 [ Ra2). joint abstract domain
Da fulfills following property: Ca abstraction Cc respect (Dc, Da1)
respect (Dc , Da2), Ca abstraction Cc respect (Dc ; Da).
Proof: proof lemma quite simple. Ca abstraction Cc respect
(Dc , Dai), exists sequence abstraction mapping sequence abstraction
mapping required Definition 5. easy see, abstraction mappings
lead respective case abstraction (Dc ; Da). 2

Lemma 7 (Multi-Level Hierarchy) Let (D0; : : : ; Dl) arbitrary multi-level
hierarchy
domain descriptions. two-level description (Dc , Da ) Da = l =1
Dc = D0 holds that: Ca abstraction Cc respect (D0; : : : ; Dl) Ca
abstraction Cc respect (Dc , Da ).
Proof: Let C = hhs0 ; smi; case domain (intermediate state denoted
sj ), let C0 = hhs00 ; s0n i; o0i case domain D0 (intermediate state denoted s0i ),
let C abstraction case C0 respect (D0; : : : ; ). sequence
cases (C1 ; : : : ; C ,1 ) exists Ci domain Di Ci+1 abstraction
case Ci respect (Di ; Di+1) 2 f0; : : : ; , 1g. proof induction
C abstraction C0 respect (Dc , Da ) (see figure 13). basis
( = 1) obvious: C1 abstraction C0 respect (D0 ; D1) consequently
abstraction respect (Dc , Da ). Now, assume lemma holds cases
domain ,1 . follows immediately C ,1 abstraction C0 respect
(Dc , Da ). Let C ,1 = hhs00; s0k i; o0i let intermediate states denoted s0r .

Definition 5 follows, state abstraction mapping sequence abstraction mapping
exists, ff(scfi(r)) = s0r r 2 f0; : : : ; kg. C abstraction C ,1
110

fiBuilding Refining Abstract Planning Cases












1










D0

Figure 13: Abstraction mappings hierarchies abstraction spaces
respect (D ,1 ; ), exists state abstraction mapping ff0 sequence
abstraction mapping 0 ff0 (s0fi 0 (j ) ) = sj j 2 f0; : : : ; mg. Now,
define state abstraction mapping ff00(s) = ff0 (ff(s)) sequence abstraction mapping
00(j ) = fi(fi0(j )). easy see, ff00 well defined state abstraction mapping
(s s0 ) ff(s) ff(s0) ) ff0 (ff(s)) ff0 (ff(s0 ))) 00 well defined sequence
abstraction mapping (fi (fi 0 (0)) = 0 ; (fi 0(m)) = (k) = n ; u < v , 0(u) < 0 (v ) ,
(fi 0 (u)) < fi(fi0(v))). Furthermore follows ff00(scfi 00 (j ) ) = ff0 (ff(scfi (fi 0(j )))) = ff0 (s0fi0(j ) ) = saj ,
leading conclusion C abstraction C0 respect (Dc , Da ). 2

Theorem 8 (Correctness completeness Pabs algorithm) complete SLDrefutation procedure used Pabs algorithm, Case Ca abstraction case Cc
respect (Dc ; Da) generic theory A, Ca 2 PABS(hDc ; Da; Ai; Cc).
Proof:

Correctness (\"): Ca returned Pabs, h(oa1 ; : : : ; oak); ff; 2 Paths holds 19
phase-IV. define state abstraction mapping ff(s) := fe 2 jRc [ [ ` eg,
which, together sequence abstraction mapping lead desired conclusion.
every operator oai, know construction phase-IV, hfi (i , 1); (i); oai; 2 G
holds. construction phase-III, conclude safi (i,1) [ Ra ` Preoai holds
consequently E [Ra ` Preoai holds respective execution body
while-loop phase-IV. Since E ff0 holds ` monotonic derivation operator,
obvious ff(scfi (i)) [ Ra ` Preoai . Furthermore, `if all'-test, executed
oai
extension path, ensures (safi (i,1) \ ) ,!
(safi (i) \ ) holds. Together
oai
fulfillment precondition operator ff(scfi (i,1)) ,!
ff(scfi(i)).
Thus, shown, Ca correct abstraction respect Definition 5.
Completeness (\"): Assume, case Ca = hhsa0 ; sam i; (oa1; : : : ; oam)i abstraction Cc
based deductively justified state abstraction mapping. exists state ab19. Note refers set finally constructed termination while-loop. use
denote respective set construction loop.

111

fiBergmann & Wilke

oa


ff(scfi(i))
straction mapping sequence abstraction mapping ff(scfi (i,1)) ,!
holds 2 f1; : : : ; mg. Since deductively justified A, follows construction
phase-II, ff(sci,1 ) sai,1 . Since ` monotonic derivation operator, preconditon oai fulfilled safi (i,1) . Furthermore, addlist operator fulfilled
ff(scfi (i)) consequently fulfilled sai . construction phase-III,
guaranteed, hfi (i , 1); (i); oai; 2 G. Now, would show, phase-IV:

exists sequence assignments variable Paths, h(); fi0; ff0i 2
Paths, h(oa1 ); fi1; ff1 2 Paths, : : : , h(oa1 ; : : : ; oam); fim; ffm 2 Paths ,
fik ( ) = fi( ) 2 f0; : : : ; kg
(ffk \ sal) ff(scl) l 2 f1; : : : ; ng
ffk Skl=1 Addoal .

proof induction i. induction basis obvious due initialization
Paths variable. Now, assume h(oa1 ; : : : ; oak); fik ; ffk 2 Paths (with k < m)
state execution phase-IV. Since, hfi (k); (k + 1); oak+1; 2 G holds
argued before, (k) = fik (k) induction hypothesis, selected operator sequence
tried extended oa = oak+1 body while-loop. Additionally,
know, E contains exactly sentences required proof precondition
oak+1 . Note, since SLD-resolution procedure assumed complete
oak+1 applicable ff(sck ), E required proof preconditition oa
E ff(scfi(k) ). Since deductively justified, 8e 2 E ; 8l 2 f1; : : : ; mg holds: e 2 ff(scfi (l))
scfi (l) [ Rc [ ` e. construction sal , 8e 2 E ; 8l 2 f1; : : : ; mg holds: e 2 ff(scfi (l))
e 2 sal . Consequently, E \ sal ff(scl ) l 2 f1; : : : ; mg. hand,
know oak+1 leads ff(scfi (k+1) ). Consequently, Addoak+1 ff(scfi (k+1)). Following
argumentation above, conclude (Addoak+1 \ sal ) ff(scl )
l 2 f1; : : : ; mg. Consequently, ff0 = ffk [ E [ Addoak+1 holds ff0 \ sal ff(scl ). Now,
oa
conclude Paths extended oak+1 follows. Since ff(scfi ( ,1) ) ,!
ff(scfi ( ))
holds Addoa 2 ff0 (ff0 \ safi ( ) ) ff(scfi ( ) ), immediately follow
oa
(ff0 \ safi ( ,1) ) ,!
(ff0 \ safi ( ) ). Consequently, h(oa1 ; : : : ; oak; oak+1 ); ffk+1; fik+1 2 Paths
ffk+1 = ff0 fik+1 ( ) = fik ( ) = ( ) 2 f1; : : : ; kg fik+1(k + 1) = fi(k). So,
induction hypothesis fulfilled k + 1. Thereby, shown Ca returned
Pabs. 2

Acknowledgements
authors want thank Agnar Aamodt, Jaime Carbonell, Padraig Cunningham, Subbarao Kambhampati, Michael M. Richter, Manuela Veloso, well members
research group many helpful discussions remarks earlier versions paper. Particularly, want thank Padraig Cunningham carefully proof-reading
112

fiBuilding Refining Abstract Planning Cases

recent version paper. greatly indebted anonymous JAIR reviewers helped significantly improve paper. research partially supported
German \Sonderforschungsbereich" SFB-314 Commission European
Communities (ESPRIT contract P6322, Inreca project). partners Inreca
AcknoSoft (prime contractor, France), tecInno (Germany), Irish Medical Systems (Ireland)
University Kaiserslautern (Germany).

References
Althoff, K. D., & Wess, S. (1992). Case-based reasoning expert system development.
Schmalhofer, F., Strube, G., & Wetter, T. (Eds.), Contemporary Knowledge Engineering amd Cognition. Springer, Heidelberg.
Anderson, J. S., & Farly, A. M. (1988). Plan abstraction based operator generalization.
Proceedings 7th International Conference Artifical Intelligence, pp. 100{104
San Mateo. Morgan Kaufmann.
Bacchus, F., & Yang, Q. (1994). Downward refinement eciency hierarchical problem
solving. Artificial Intelligence, 71, 43{100.
Bergmann, R. (1992a). Knowledge acquisition generating skeletal plans. Schmalhofer, F., Strube, G., & Wetter, T. (Eds.), Contemporary Knowledge Engineering
Cognition, pp. 125{133 Heidelberg. Springer.
Bergmann, R. (1992b). Learning abstract plans speed hierarchical planning.
Tadepalli, P. (Ed.), Proceedings ML92 Workshop Knowledge Compilation
Speedup Learning. University Aberdeen, Scotland.
Bergmann, R. (1992c). Learning plan abstractions. Ohlbach, H. (Ed.), GWAI-92 16th
German Workshop Artificial Intelligence, Vol. 671 Springer Lecture Notes
AI, pp. 187{198.
Bergmann, R. (1993). Integrating abstraction, explanation-based learning multiple
examples hierarchical clustering performance component planning.
Plaza, E. (Ed.), Proceedings ECML-93 Workshop Integrated Learning
Architectures (ILA-93) Vienna, Austria.
Bergmann, R., Pews, G., & Wilke, W. (1994). Explanation-based similarity: unifying
approach integrating domain knowledge case-based reasoning. Richter, M.,
Wess, S., Althoff, K., & Maurer, F. (Eds.), Topics Case-Based Reasoning, Vol. 837
Lecture Notes Artificial Intelligence, pp. 182{196. Springer.
Bergmann, R., & Wilke, W. (1994). Inkrementelles Lernen von Abstraktionshierarchien
aus maschinell abstrahierten Planen. Fensel, D., & Nakhaeizadeh, G. (Eds.),
Proceedings Workshop Maschinelles Lernen: Theoretische Ansatze und Anwendungsaspekte, No. 291. Institut fur angewandte Informatik und formale Beschreibungsverfahren, University Karlsruhe, Germany.
113

fiBergmann & Wilke

Blythe, J., Etzioni, O., & et al. (1992). Prodigy4.0: manual tutorial. Tech. rep.
CMU-CS-92-150, Carnegie Mellon University, Pittsburgh, PA.
Carbonell, J. G. (1986). Derivational analogy: theory reconstructive problem solving
expertise aquisition. Michalski, R. S., Carbonell, J. G., & Mitchell, T. M.
(Eds.), Machine learning: artificial intelligence approach, Vol. 2, chap. 14, pp.
371{392. Morgan Kaufmann, Los Altos, CA.
DeJong, G., & Mooney, R. (1986). Explanation-based learning: alternative view. Machine Learning, 1 (2), 145{176.
Etzioni, O. (1993). structural theory explanation-based learning. Artificial Intelligence,
60, 93{139.
Etzioni, O., & Etzioni, R. (1994). Statistical methods analyzing speedup learning.
Machine Learning, 14, 333{347.
Fikes, R. E., Hart, P. E., & Nilsson, N. J. (1972). Learning executing generalized robot
plans. Artificial Intelligence, 3, 251{288.
Fikes, R. E., & Nilsson, N. J. (1971). Strips: new approach application theorem
proving problem solving. Artificial Intelligence, 2, 189{208.
Friedland, P. E., & Iwasaki, Y. (1985). concept implementation skeletal plans.
Journal Automated Reasoning, 1 (2), 161{208.
Giordana, A., Roverso, D., & Saitta, L. (1991). Abstracting background knowledge
concept learning. Kodratoff, Y. (Ed.), Proceedings European Working Session
Learning (EWSL-91), Lecture Notes Artificial Intelligence, pp. 1{13 Berlin.
Springer.
Giunchiglia, F., & Walsh, T. (1992). theory abstraction. Artificial Intelligence, 57,
323{389.
Green, C. (1969). Application theorem proving problem solving. Proceedings
IJCAI-69, pp. 219{239 Washington, DC.
Holte, R., Drummond, C., Perez, M., Zimmer, R., & MacDonald, A. (1994). Searching
abstractions: unifying framework new high-performance algorithm.
Proceedings 10th Canadian Conference Artificial Intelligence, pp. 263{270.
Morgan Kaufmann Publishers.
Holte, R., Mkadmi, T., Zimmer, R., & MacDonald, A. (1995). Speeding problem solving
abstraction: graph-oriented approach. Tech. rep. TR-95-07, Computer Science
Dept., University Ottawa, Ontario, Canada.
Kambhampati, S., & Hendler, J. A. (1992). validation-structure-based theory plan
modification reuse. Artificial Intelligence, 55, 193{258.
114

fiBuilding Refining Abstract Planning Cases

Kambhampati, S., & Kedar, S. (1994). unified framework explanation-based generalization partially ordered partially instantiated plans. Artificial Intelligence, 67,
29{70.
Knoblock, C. A. (1989). theory abstraction hierachical planning. Proceedings
Workshop Change Representation Inductive Bias, pp. 81{104 Boston,
MA. Kluwer.
Knoblock, C. A. (1990). Learning abstraction hierarchies problem solving. Proceedings
Eighth National Conference Artificial Intelligence, Vol. 2, pp. 923{928 London.
MIT Press.
Knoblock, C. A. (1991). Search reduction hierarchical problem solving. Proceedings
9th National Conference Artificial Intelligence, Vol. 2, pp. 686{691 Anaheim,
CA.
Knoblock, C. A. (1993). Generating abstraction hierarchies: automated approach
reducing search planning. Kluwer Academic Publishers.
Knoblock, C. A. (1994). Automatically generating abstractions planning. Artificial
Intelligence, 68, 243{302.
Knoblock, C. A., Minton, S., & Etzioni, O. (1991a). Integrating abstraction
explanation-based learning PRODIGY. Proceedings 9th National Conference Artificial Intelligence, Vol. 2, pp. 541{546 Anaheim, CA.
Knoblock, C. A., Tenenberg, J. D., & Yang, Q. (1991b). Characterizing abstraction hierarchies planning. Proceedings 9th National Conference Artificial
Intelligence, Vol. 2, pp. 692{697 Anaheim, CA.
Kolodner, J. L. (1980). Retrieval Organizational Strategies Conceptual Memory.
Ph.D. thesis, Yale University.
Kolodner, J. L. (1993). Case-based reasoning. Morgan Kaufmann.
Korf, R. E. (1980). Toward model representation changes. Artifical Intelligence, 14,
41{78.
Korf, R. E. (1985a). Depth-first iterative-deepening: optimal admissible tree search.
Artifical Intelligence, 27, 97{109.
Korf, R. E. (1985b). Macro-operators: weak method learning. Artifical Intelligence,
26, 35{77.
Korf, R. E. (1987). Planning search: quantitative approach. Artifical Intelligence, 33,
65{88.
Korf, R. E. (1993). Linear-space best-first search. Artifical Intelligence, 62, 41{78.
115

fiBergmann & Wilke

Kramer, M., & Unger, C. (1992). Abstracting operators hierarchical planning.
Hendler, J. (Ed.), Proceedings International Conference AI Planning, pp.
287{288. Morgan Kaufmann.
Laird, J., Rosenbloom, P., & Newell, A. (1986). Universal Subgoaling Chunking:
Automatic Generation Learning Goal Hierarchies. Kluwer Academic Publishers, Norwell, MA.
Langley, P., & Allen, J. (1993). unified framework planning learning. Minton,
S. (Ed.), Machine Learning Methods Planning, chap. 10, pp. 317{350. Morgan
Kaufmann.
Lifschitz, V. (1987). semantics STRIPS. Reasoning Actions Plans:
Proceedings 1986 Workshop, pp. 1{9 Timberline, Oregon.
Lloyd, J. (1984). Foundations Logic Programming. Springer.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
9th National Conference Artificial Intelligence, pp. 634{639.
Michalski, R. S. (1994). Inferential theory learning conceptual basis multistrategy
learning. Michalski, R., & Tecuci, G. (Eds.), Machine Learning: Multistrategy
Approach, No. 11, chap. 1, pp. 3{62. Morgan Kaufmann.
Michalski, R. S., & Kodratoff, Y. (1990). Research machine learning: Recent progress,
classification methods, future directions. Kodratoff, Y., & Michalski, R. S.
(Eds.), Machine learning: Artificial Intelligence Approach, Vol. 3, chap. 1, pp.
3{30. Morgan Kaufmann, San Mateo, CA.
Minton, S. (1988). Learning Search Control Knowledge: Explanation-Based Approach.
Kluwer, Boston, MA.
Minton, S. (1990). Quantitativ results concerning utility explanation-based learning.
Artifical Intelligence, 42, 363{391.
Minton, S., Carbonell, J. G., Knoblock, C., Kuokka, D. R., Etzioni, O., & Gil, Y. (1989).
Explanation-based learning: problem solving perspective. Artificial Intelligence,
40, 63{118.
Minton, S., & Zweben, M. (1993). Learning, planning scheduling: overview.
Minton, S. (Ed.), Machine Learning Methods Planning, chap. 1, pp. 1{30. Morgan
Kaufmann.
Mitchell, T. M., Keller, R. M., & Kedar-Cabelli, S. T. (1986). Explanation-based generalization: unifying view. Machine Learning, 1 (1), 47{80.
Mooney, R. J. (1988). Generalizing order operators macro-operators. Laird,
J. (Ed.), Proceedings 5th International Conference Machine Learning, pp.
270{283 San Mateo, CA. Morgan Kaufmann.
116

fiBuilding Refining Abstract Planning Cases

Mooney, R. J., & DeJong, G. F. (1985). Learning schemata natural language processing.
Proceedings IJCAI, pp. 681{687 Los Angeles, CA.
Mozetic, I. (1990). Abstraction model-based diagnosis. AAAI Workshop Automatic
Generation Approximations Abstractions, pp. 64{75 Boston, MA.
Newell, A., & Simon, H. (1972). Human Problem Solving. Prentice-Hall Englewood Cliffs,
NJ.
Paulokat, J., & Wess, S. (1994). Planning machining workpieces partial-order,
nonlinear planner. AAAI-Fall Symposium Planning Learning: Real
Applications.
Perez, M., & Carbonell, J. (1993). Automated acquisition control knowledge improve
quality plans. Tech. rep. CMU-CS-93-142, Carnegie Mellon University.
Pews, G., & Wess, S. (1993). Combining model-based approaches case-based reasoning
similarity assessment case adaptation diagnositc applications. Richter,
M. M., Wess, S., Althoff, K., & Maurer, F. (Eds.), Preprints First European
Workshop Case-Based Reasoning (EWCBR-93), Vol. II, pp. 325{328. University
Kaiserslautern, Germany.
Plaisted, D. (1981). Theorem proving abstraction. Artifical Intelligence, 16, 47{108.
Plaisted, D. (1986). Abstraction using generalization functions. Proceedings 8th
Conference Automated Deduction, Vol. 16, pp. 365{376.
Rosenbloom, P., & Laird, J. (1986). Mapping explanation-based learning onto SOAR.
Proceedings National Conference Artificial Intelligence, Vol. 2 Philadelphia, PA.
Sacerdoti, E. (1974). Planning hierarchy abstraction spaces. Artificial Intelligence,
5, 115{135.
Sacerdoti, E. (1977). Structure Plans Behavior, Vol. 5. American-Elsevier, New
York.
Schank, R. C. (1982). Dynamic Memory: Theory Learning Computers People.
Cambridge University Press, New York.
Schmidt, G. (1994). Modellbasierte, interaktive Wissensakquisition und Dokumentation von
Domaenenwissen. Ph.D. thesis, University Kaiserslautern, Germany.
Schmidt, G., & Zickwolff, M. (1992). Cases, models integrated knowledge acquisition
formalize operators manufacturing. Proceedings 7th Knowledge Acquisition
Knowledge-based Systems Workshop (Banff).
Shavlik, J., & O'Rorke, P. (1993). Empirically evluation EBL. Investigating ExplanationBased Learning, Vol. 5, chap. 7, pp. 222{294. Kluwer Academic Publishers.
Simon, H. (1975). functional equivalence problem solving skills. Cognitive Psychology,
7, 268{288.
117

fiBergmann & Wilke

Tenenberg, J. (1987). Preserving consistency across abstraction mappings. McDermott,
J. (Ed.), Proceedings 10th International Conference Artifical Intelligence,
pp. 1011{1014 Los Altos, CA. Morgan Kaufmann.
Tenenberg, J. (1988). Abstraction Planning. Ph.D. thesis, Computer Science Department,
University Rochester, New York.
Unruh, A., & Rosenbloom, P. (1989). Abstraction problem solving learning.
Proceedings International Joint Conference Artifical Intelligence-89, pp.
590{595 Detroit, MI. Morgan Kaufmann.
Veloso, M. M. (1992). Learning analogical reasoning general problem solving. Ph.D.
thesis, Carnegie Mellon University, Pittsburgh, PA.
Veloso, M. M. (1994). PRODIGY/ANALOGY: Analogical reasoning general problem
solving. Richer, M., Wess, S., Althoff, K., & Maurer, F. (Eds.), Topics CaseBased Reasoning, pp. 33{52. Lecture Notes AI, Vol. 837, Springer.
Veloso, M. M., & Blythe, J. (1994). Linkability: Examining causal link commitments
partial-order planning. Proceedings 2nd International Conference
Planning AI Systems AIPS-94.
Veloso, M. M., & Carbonell, J. G. (1988). Integrating derivational analogy general
problem solving architecture. Minton, S. (Ed.), Proceedings First Workshop
Case-Based Reasoning. Morgan Kaufmann.
Veloso, M. M., & Carbonell, J. G. (1993). Towards scaling machine learning: case
study derivational analogy PRODIGY. Minton, S. (Ed.), Machine Learning
Methods Planning, chap. 8, pp. 233{272. Morgan Kaufmann.
Wilke, W. (1993). Entwurf und Implementierung eines Algorithmus zum wissensintensiven
Lernen von Planabstraktionen nach der PABS-Methode. Projektarbeit, Universitat
Kaiserslautern.
Wilke, W. (1994). Entwurf, Implementierung und experimentelle Bewertung von
Auswahlverfahren fur abstrakte Plane im fallbasierten Planungssystem PARIS. Master's thesis, University Kaiserslautern, Germany.
Wilkins, D. (1988). Practical Planning: Extending classical AI planning paradigm.
Morgan Kaufmann.
Yang, Q., & Tenenberg, J. (1990). Abtweak: Abstracting nonlinear, least commitment
planner. Proceedings 8th National Conference Aritificial Intelligence, pp.
204{209 Boston, MA.

118


