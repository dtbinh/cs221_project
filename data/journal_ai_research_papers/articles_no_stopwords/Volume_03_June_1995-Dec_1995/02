journal artificial intelligence

submitted published

building refining abstract cases
change representation language
ralph bergmann
wolfgang wilke

bergmann informatik uni kl de
wilke informatik uni kl de

centre learning systems applications lsa
university kaiserslautern p box kaiserslautern germany

abstract

abstraction one promising approaches improve performance
solvers several domains abstraction dropping sentences domain description
used hierarchical planners proven useful present examples
illustrate significant drawbacks abstraction dropping sentences overcome
drawbacks propose general view abstraction involving change
representation language developed abstraction methodology related
sound complete learning allows complete change representation
language cases concrete abstract however achieve powerful
change representation language abstract language well rules
describe admissible ways abstracting states must provided domain model
abstraction core paris plan abstraction refinement
integrated system system abstract cases automatically
learned given concrete cases empirical study domain process
mechanical engineering shows significant advantages proposed reasoning
abstract cases classical hierarchical

introduction
abstraction one challenging promising approaches improve complex
solving inspired way humans seem solve first less
relevant details given ignored abstracted
solved easily step step details added solution taking
increasingly detailed look thereby abstract solution constructed
first refined towards concrete solution one typical characteristic work
hierarchical solving abstraction mostly performed dropping sentences
domain description sacerdoti tenenberg unruh rosenbloom
yang tenenberg knoblock bacchus yang second
common characteristic hierarchical solver usually derives abstract
solution scratch without experience previous solving episodes
giunchiglia walsh presented comprehensive formal framework
abstraction comparison different abstraction approaches theorem proving
plaisted tenenberg newell simon sacerdoti
tenenberg unruh rosenbloom yang tenenberg knoblock
model diagnosis mozetic hierarchical korf
model abstraction solving korf allows analysis reductions
c ai access foundation morgan kaufmann publishers rights reserved

fibergmann wilke

search caused single multiple levels abstraction shown optimal
case abstraction reduce expected search time exponential linear knoblock
developed construct hierarchy abstraction spaces automatically
given concrete level solving domain knoblock
called ordered monotonic abstraction hierarchies knoblock tenenberg yang b
proven useful many domains recently bacchus yang presented
improved method automatically generating abstraction hierarchies
detailed model search costs
abstraction methods however rely abstraction dropping sentences
domain description kind homomorphic abstraction holte et al
shown kinds abstractions highly representation dependent holte et al two classical domains different natural
representations analyzed turns several representations
classical abstraction techniques lead significantly improved
solvers knoblock holte et al however well known normally many
different representations domain exist already pointed korf
theory representation developed particular
theory representation hierarchical solving dropping sentences
knowledge engineering perspective many different aspects simplicity
understandability maintainability must considered developing domain representation therefore assume representations domains given knowledge
engineers rely representations consider natural certain kinds
demonstrate two simple example related representations
usual use abstraction solving lead improvement
first example improvement achieved abstraction restricted
dropping sentences domain second example abstract solution computed
scratch decompose original consequently cut
search space next detailed level want argue examples
never represented way standard hierarchical solving works well
however think would require large effort knowledge engineer develop
appropriate representation believe often impossible develop representation appropriate knowledge engineering perspective allows
ecient hierarchical solving dropping sentences
take observations motivation develop general model abstraction solving already pointed michalski abstraction
general seen switching completely representation language
level detail reduced solving abstract representation language
must consist completely sentences operators subset
sentences operators concrete language knowledge sipe wilkins
system currently allows change representation language
across different levels abstraction however general abstraction methodology
allows ecient abstraction refinement yet developed
want propose method abstraction allows complete change representation language solution concrete abstract vice versa
concrete abstract language given additionally propose use experience


fibuilding refining abstract cases

previously solved usually available set cases come abstract
solutions use experience already proven useful approaches speedup learning explanation learning mitchell keller kedar cabelli
dejong mooney rosenbloom laird minton minton carbonell
knoblock kuokka etzioni gil shavlik rorke etzioni minton
zweben langley allen kambhampati kedar analogical
case reasoning carbonell kambhampati hendler veloso carbonell
veloso
main contribution present abstraction methodology
related learning method beneficial abstract cases automatically derived
given concrete cases given concrete abstract language learning
allows complete change representation case concrete
abstract level however achieve unconstrained kind abstraction
set admissible abstractions must implicitly predefined generic abstraction theory
compared approaches abstraction hierarchies generated automatically
effort required specify abstract language feel price
pay make tractable certain situations
fully implemented paris plan abstraction refinement
integrated system system abstract cases learned organized case
base novel solving case base searched suitable abstract case
refined concrete solution current
presentation organized follows next section presents
analysis hierarchical solving shortcomings current approaches
illustrated simple examples section three argues powerful case abstraction
refinement method overcome identified furthermore present
paris informally simple example next three sections
formalize general abstraction introducing basic terminology section defines formal model case abstraction section contains detailed
description correct complete learning case abstraction section
explains refinement cases solving section gives detailed description domain process mechanical engineering production
rotary symmetric workpieces lathe demonstrates proposed examples domain section reports detailed experimental evaluation paris
described domain finally discuss presented relation similar
work field appendix article contains formal proofs properties
abstraction related learning additionally detailed
representation mechanical engineering domain used experimental evaluation
given online appendix

analysis hierarchical solving
basic intuition behind abstraction follows first ignoring less relevant features
description abstraction allows solved coarse fashion
less effort derived abstract skeletal solution serves decomposition
original detailed korf shown hierarchical


fibergmann wilke

solving reduce required search space significantly assume requires
solution length n furthermore assume average branching factor b
e average number states reached given state applying
single operator worst case time complexity finding required solution search
bn suppose decomposed abstract solution
k subproblems require solution length n nk respectively
n n nk n situation worst case time complexity finding
complete solution bn bn bnk bmax n n nk please note
significant reduction search time complexity particular easily see
reduction maximal subproblems similar size e n n nk
however achieve significant search reduction computed abstract solution must
solution abstracted must additionally fulfill certain
requirement presupposed analysis subproblems introduced abstract
solution must independent e must solvable without interaction
subproblems avoids backtracking solution subproblem
consequently cuts necessary overall search space even restriction
completely fulfilled e backtracking still required cases several empirical studies
especially knoblock shown abstraction nevertheless lead
performance improvements
unfortunately domains representations domains holte et al
way abstraction used hierarchical solving cannot improve
solving derived abstract solutions fulfill mentioned
requirement following two examples domains
demonstrate two general drawbacks hierarchical solving please note
examples particular representation assumed feel representations
somehow natural likely used knowledge engineer developing domain however might representations domains traditional
hierarchical works assume representations dicult
especially domain representation fulfill additional knowledge engineering
requirements

abstraction dropping sentences

hierarchical solving abstraction mostly achieved dropping sentences
description preconditions effects operators sacerdoti
tenenberg unruh rosenbloom yang tenenberg knoblock
assumption justifies kind abstraction less relevant
details description expressed isolated sentences representation
addressed relevant sentences established ignoring
sentences assumed lead abstract solution useful reduce search
concrete levels
however assumption hold domains example many real world
domains certain events need counted e g transporting certain number
tenenberg abstraction analogical mappings system sipe wilkins
contains first approaches allow change representation language



fibuilding refining abstract cases

containers one location another imagine domain addition several
operators increment operator described follows
operator inc
precondition value x
delete value x
add value x

representation integer value increased represented single sentence state consists single sentence operator contains
one single sentence think representation natural likely
chosen knowledge engineer domain incrementing value value
requires sequential plan composed inc operators leading state sequence
value value value example however abstraction dropping sentences work single sentence would dropped nothing would remain operator description whole counting would dropped
completely empty abstract level empty plan
going solve unfortunately empty plan cannot cause complexity reduction
solving concrete level consequently abstraction dropping sentences
completely fails improve solving situation
however adequately cope counting abstracting
quantitative value expressed sentence towards qualitative representation e g
low f g medium f g high f g qualitative representation would abstract plan composed two operators subproblems
increase value low medium high abstract plan defines two
independently refinable subproblems solve first subproblem concrete level
solver search sequence inc operators increment value
medium value value set f g subproblem
solved sequence inc operators leading concrete state value similarly second subproblem concrete level sequence operators
change value final value second subproblem solved
sequence inc operators see complete requires
sequence concrete operators divided subproblems subproblem
solved step plan exponential nature search space two
step together solved much less search step
whole following korf analysis sketched time complexity reduced b
b please note particular abstraction leads two subproblems
central achieving complexity reduction important point
decomposed one subproblem kind abstraction achieved
introducing abstract representation language consists qualitative values
corresponding abstract increment operator
however might assume term x modeled separate predicate precondition
unfortunately change described situation
assume many operators besides inc operator b holds



fibergmann wilke

even generalize specific example presented
dropping condition possible abstract information e g
value example coded single sentence representation
particularly required solution contains long sequence states
differ single sentence dropping particular sentence leads dropping
whole dropping sentence lead abstraction
really required abstract information encoded single sentence obviously
requires dropping complete information
summarize seen abstraction dropping sentences work
particular kind shown general abstraction requires changing complete representation language concrete abstract usually involves
introduction completely abstract terms sentences operators within
general view dropping sentences special case abstraction reason dropping sentences widely used hierarchical due simplicity
refinement easy abstract states directly used goals
detailed levels another important property abstraction dropping sentences
useful hierarchies abstraction spaces constructed automatically domain
descriptions knoblock bacchus yang

generating abstract solutions scratch

another limiting factor classical hierarchical solving way abstract solutions computed pointed korf good abstract solution must lead mostly
independent subproblems equal size classical solving abstract solution
found breadth first depth first search linear e g alpine knoblock
non linear e g abtweak yang tenenberg solvers solvers upward solution property tenenberg usually holds means
abstract solution exists concrete level solution exists usually
solvers arbitrary abstract solution e g shortest possible solution unfortunately way guarantee computed solutions refinable lead
mostly independent subproblems suciently equal size even solution exists
general even heuristics try guide solving towards
aspired kind useful abstractions illustrated following example
additionally shows limitation abstraction dropping sentences
imagine large even infinite state space includes least distinct states
shown left figure states described presence absence
three sentences e e e state description bit vector shown figure
indicates absence sentence represents presence sentence
different states described three sentences arranged dimensional
cube one dimension sentence arrows diagram possible state
transitions available operators domain operator manipulates adds
deletes exactly one sentence state description certain conditions
sentences fulfilled representation two operators shown right
dashed lines represent operators introduced make shape cube
easy see



fibuilding refining abstract cases

z





two example operators




x z


e

x





e
e




precondition
e
e
e


precondition
e
e
e

add e

delete e



figure state space example domain representation two operators
side figure subscript operator name relates respective transition
state diagram general see

e manipulated e e holds
e manipulated e e holds
e manipulated e e holds
furthermore assume many operators connect states
domain shown diagram depicted states consequently
must assume branching factor b state makes search space
solving quite large besides description domain figure shows
three example x x z z example solution
x x step path
let consider abstract solutions correspond concrete solutions
three want examine three possible ways
abstraction dropping one sentences purpose geometric arrangement
states turns useful abstraction simply viewed
projecting dimensional state space onto plane defined sentences
dropped abstraction left part figure shows three possible abstract
state spaces dropping one sentences important
see abstract state space every sentence modified unconditionally
independent sentences however one sentence modified
operator thereby constraints exist concrete level relaxed
abstraction concrete solution three x x
z z respect three possible ways dropping conditions shown


fibergmann wilke

state spaces
dropping conditions

x x



e



e








e





e
e

z z







e






e


e






e







e




e




e





figure abstract state spaces dropping conditions
right side figure nine possible abstract solutions consists three
four abstract operators sequence applied indicated
numbers mark operators see whatever sentence
drop appropriate abstract solution exists decomposes
original independent refinable subproblems suciently equal size
main point example none abstract solutions found
hierarchical solver reason abstracted
exists step step solution addition nine step step solutions
indicated depicted paths however short solution completely useless
reducing search next concrete level original
decomposed central solvers
shorter useless solutions first try refine consequently search
space concrete level reduced performance improvement achieved
however might representations example domain
hierarchical solver comes useful abstract solution think however
representation shown quite natural represents different states
minimal number binary sentences
summarize presented example useful abstract solution found
hierarchical although exists reason planners usually try
shortest solutions good strategy ground level may
appropriate abstract level neither desirable search longest
solutions might cause unnecessarily long concrete plans

case abstraction refinement

way propose use experience given form concrete
cases abstract experience reuse situations therefore
need powerful abstraction methodology allows introduction completely
abstract terminology abstract level makes possible useful abstract
solutions expressed domains abstraction dropping conditions
sucient particular methodology must serve means analyze
different abstraction approaches must allow ecient abstracting
refining solutions


fibuilding refining abstract cases

basic idea
introduce achieves case abstraction refinement changing
representation language prerequisite requires abstract
language state description operators given domain expert addition
concrete level description require set admissible ways abstracting
states implicitly predefined generic abstraction theory course additional
knowledge engineering requirement feel price pay
enhance power hierarchical solving recent knowledge acquisition
already describes approaches tools acquisition concrete level abstract level
operators real world domains schmidt zickwolff schmidt abstract
language given user additional advantage abstracted cases
expressed language user familiar consequently understandability
explainability important issues applying system achieved
easily
source learning assume set concrete cases
consists statement together related solution case prodigy
minton et al consider sequential plans e plans totally ordered
operators cases assume include solving trace example solving cases prodigy analogy veloso veloso carbonell
veloso real world applications domain expert solutions previous
usually recorded company filing cabinet database cases
seen collection company experience want draw power
learning phase set abstract cases generated available
concrete case abstract case consists abstracted description
together abstracted solution case abstraction procedure guarantees
abstract solution contained abstract case refined become solution
concrete contained concrete case became abstracted different
abstract cases may situated different levels abstraction may abstractions
according different abstraction aspects different abstract cases different utility
reduce search space concrete level different ways happen
several concrete cases share abstraction set abstract cases
learned organized case base ecient retrieval solving
solving phase case base searched abstract case
found applied current hand abstract case applicable
current abstracted contained abstract case
abstraction current however cannot guarantee abstract
solution contained selected abstract case really refined become solution
current least known abstract solution case base
already useful solving one previous e contained
concrete cases abstract case learned since
similar previous abstracted way
least high chance abstract solution useful solving
solved refinement concrete case arises
used learning


fibergmann wilke

learning

paris system

evaluation
indexing

case base

generalization

abstraction

solving
retrieval

domain description
concrete domain
abstract domain
generic abstraction theory



specialization

refinement

solved

training cases

figure components paris system

paris architecture
paris plan abstraction refinement integrated system follows basic ap

proach described figure shows overview whole system components
besides case abstraction refinement paris includes explanation
generalizing cases learning specializing solving furthermore system includes additional mechanisms evaluating different abstract
cases generalizations derived explanation component evaluation
component measures reduction search time caused abstract plan solving concrete case base abstract plan applicable
evaluation several different indexing retrieval mechanisms developed retrieval procedures abstract cases preferred caused
reduction search previous solving episodes particular abstract cases turn useless many concrete may even become
completely removed case base spectrum developed retrieval approaches
ranges simple sequential search via hierarchical clustering sophisticated balancing hierarchy abstract cases according statistical distribution
cases within space evaluated utility details generalization procedure found bergmann evaluation retrieval
mechanisms reported bergmann wilke wilke whole multistrategy system including interactions described components
topic forthcoming article first ideas already found bergmann b
however target concentrate core paris namely
abstraction refinement


fibuilding refining abstract cases

state abstractions
abstract plan






































changing
representration







figure example case abstraction

informal description abstraction

first give informal description abstraction paris
small example shown figure enhance understanding subsequent formal
sections suppose solution x x available concrete solving experience task learn abstract case beneficially
used solve future z z learning task must
achieved within abstraction stronger dropping sentences
look figure becomes obvious changing representation single abstract
case learned useful three concrete abstract plan shown
indicates concrete states abstracted towards single abstract state
single abstract plan exists useful three
abstract language generic abstraction theory

achieve kind abstraction requires abstract language states
operators well generic abstraction theory provided user example figure abstract language must contain abstract sentences
three abstract operators allow respective state transitions abstract
operators called oai f g defined follows
operator oai
precondition ai
delete ai
add ai

abstract sentence user must provide set generic abstraction rules
describe sentence defined terms available sentences con

fibergmann wilke

crete language generic abstraction theory defined rules specifies set
admissible state abstractions example generic abstraction theory must contain following two rules define abstract sentence e e
e e e general definition generic abstraction theory
require state abstractions noted explicitly abstract states derived
implicitly application combination several rules generic abstraction
theory
besides kind abstraction described user may want specify
different type abstraction considers useful example
assume abstraction dropping sentence e realized case
abstract language must contain copy two sentences dropped e
sentences e e therefore user may define two abstract sentences
following rules generic abstraction theory e e
course respective abstract operators must specified
since domain expert knowledge engineer must provide abstract language
generic abstraction theory must already one particular kinds
abstraction mind must know kind details omitted solving
abstract fashion knowledge engineer given
power express kind abstraction considers useful
model case abstraction

given abstract language generic abstraction theory abstraction
case formally described two abstraction mappings state abstraction
mapping sequence abstraction mapping two mappings describe two dimensions
reducing level detail case state abstraction mapping reduces level
detail state description changing representation language case
abstraction indicated figure state abstraction mapping must map concrete
states onto abstract state described sentence
simultaneously must map concrete states occurring plan onto respective
abstract states described sentences sequence abstraction
mapping reduces level detail number states considered
abstract level relating concrete states concrete case abstract
states abstract case concrete states skipped abstract
state must particular concrete state example figure abstraction
plan requires sequence abstraction mapping
relates first abstract state described first concrete state
second abstract state described third concrete state forth
example second fifth concrete states skipped
learning abstract cases

procedure learning abstract cases given concrete case
decomposed four separate phases simple example phases shown
please note abstraction dropping sentences consider alpine
generates required abstract language generic abstraction theory automatically



fibuilding refining abstract cases





ca
phase iv
ca

oa

phase iii



oa

oa





oa

oa

oa



oa

oa

phase ii













phase













figure four phases case abstraction solution x x
figure phase states execution plan contained
concrete case determined therefore operator contained plan starting
first operator applied successor state computed process starts
initial state contained case leads final state goal state
contained case phase ii derive admissible abstractions concrete
state computed first phase purpose generic abstraction theory used
determine abstract sentences derived respective concrete state
applying rules generic abstraction theory figure shows abstract sentences
derived generic abstraction theory sketched example
see second concrete state abstract description derived contains
two abstract sentences abstract sentence required achieve type abstraction
shown figure additionally abstract sentences required abstraction
dropping sentences please note process representation language states
changed concrete abstract next two phases deal abstract operators
already stated abstract operators given abstract language provided
user however assume operator abstraction rules associate abstract
operator single concrete operator sequence concrete operators reason
operator abstraction rules extremely hard acquire even harder
keep complete next two phases case abstraction search transitions
abstract states available abstract operators phase iii acyclic directed
graph constructed edge leads abstract state successor abstract state
j necessarily next abstract state abstract operator applicable state
application leads state j definition abstract operators
used process available abstract operators determine transitions
included graph figure shows resulting graph provided abstract
operators sketched section contained abstract language graph


fibergmann wilke

transitions shown plain line style operators oai transitions
shown dashed line style operators required abstraction dropping
conditions
phase iv graph searched consistent paths initial abstract state
final abstract state paths must consistent sense resulting
path e abstract plan every abstract operator correctly applicable state
previous operator moreover state abstraction required
abstract plan must change within plan figure two paths kind
shown lower path represents abstract case ca abstract initial final
state together operator sequence kind abstraction shown
figure upper path represents abstract case ca
abstraction dropping sentence e abstract plan shown figure
x x together two plans abstract state descriptions
operator application shown please note state descriptions
subset description derived generic abstraction theory
example description fourth abstract state derived phase ii contains
sentences abstract state occurs abstract cases computed
phase iv case ca respective state described sentences
sentences application operators
starting abstract initial state case ca abstract state described
sentence sentence application operator oa
example see abstract operators two functions first
function select concrete states become abstracted example
abstract case ca second concrete state skipped even first second
concrete states abstracted different abstract descriptions phase ii reason
abstract operator leads first abstracted state
second abstracted state b consistent operators
rest path second function abstract operators select
abstract sentences considered abstract case example
abstract case ca sentences considered sentences
left reason abstract operators oa oa oa occur
plan use precondition manipulate sentences
phase iv finished set abstract cases available
cases stored case base used solving
selecting refining abstract cases

solving abstract case must selected case base abstract
plan contained case must refined become solution current
case retrieval must search abstract case applicable e contains
description abstraction current example assume
solved case x x presented learning
situation case base contains two abstract cases ca ca shown phaseiv figure abstract case ca used solving
initial state abstracted applying generic


fibuilding refining abstract cases

selected abstract case



defined search spaces



refined solution



oa





oa











oa









figure refinement abstract case solution
abstraction theory similarly final state abstracted however
abstract case ca applicable final abstract state cannot abstracted
consequently lower abstract case must used plan refinement
refine abstract operators sequentially left right shown figure thereby
abstract operator defines abstract goal state e state
execution operator example abstract operator oa defines abstract goal
refine abstract operator search concrete operator sequence starting
current concrete state e initial state first operator concrete
state reached abstracted desired goal state state found
used starting state refinement next abstract operator
solution refinement abstract operator oa
achieved sequence two concrete operators leading concrete state
concrete state used starting state refine next abstract operator oa
refinement procedure finishes last abstract operator refined way
final concrete state achieved please note type refinement operators
used directly instead sequence states
execution used alternatively could stored abstract case sequence
abstracted states experience storing sequence operators requires less
space storing sequence states become obvious looking
domain introduced section besides abstract operators play
important role learning phase

relations skeletal plans
similar experience case variant finding abstract solution
found early friedland iwasaki concept skeletal
plans introduced skeletal plan sequence generalized steps
instantiated specific operations specific context solve given
p skeletal plans exist many levels generality general level
basic plans used fall backs specific easier
refine plans cannot found p skeletal plans solutions
different levels detail consequently abstract plans solving


fibergmann wilke

recalled library refined towards concrete solution
seen early idea integrating abstraction case reasoning however
several differences skeletal plan paris
skeletal plan model operators neither concrete abstract used
describe preconditions effects operators done paris explicit
notion states abstraction refinement states instead plan refinement
achieved stepping hierarchy operators guided heuristic rules operator
selection particular supports automatic acquisition skeletal
plans provided unfortunately skeletal plan yet investigated
much detail current work field speedup learning neither formal
model skeletal empirical evaluations
rest introduce investigate paris
formally

basic terminology
section want introduce basic formal terminology used throughout rest
therefore define formal representation solving domains
want assume solving general viewed transforming initial
state final state sequence operators newell simon following
strips oriented representation fikes nilsson domain solving
hl e ri described first order language l set essential atomic sentences
e l lifschitz set operators related descriptions additionally
set rules horn clauses r l essential sentences must atomic
sentences used describe state state describes dynamic
part situation domain consists finite subset ground instances essential
sentences e symbol denote set possible states descriptions
domain defined e e fe je e substitution
e groundg addition horn clauses r allow representation static properties
true situations horn clauses must contain essential sentence
head clause
operator x xn described triple hpreo addo deloi
precondition preo conjunction atoms l add list addo deletelist delo finite sets possibly instantiated essential sentences e furthermore
variables occuring operator descriptions must follow following restrictions
fx xng v ar preo v ar delo fx xng v ar addo
instantiated operator expression form tn ti ground
terms l term ti describes instantiation variable xi operator description notational convenience define instantiated precondition well instantiated add list delete list instantiated operator follows preo tn preo
addo tn fa ja addog delo tn fd jd delo g hpreo addo deloi
basic language first order deductive rules given horn logic subset
full first order language used
restrictions however relaxed fx xn g v ar preo required
introduced restriction simplifies subsequent presentation



fibuilding refining abstract cases

description uninstantiated operator x xn fx xn tn g
corresponding instantiation
instantiated operator applicable state r pre
holds

instantiated operator transforms state state write
applicable n delo addo description p hsi sg
consists initial state si together final state sg solving task
sequence instantiated operators plan ol transforms
ol

initial state final state si

sg case c hp oi
description p together plan solves p
introduced strips oriented formalism defining solving domain
similar form expressiveness representations typically used general
solving state described finite set ground atoms
functions used full horn logic available describe static rules restriction horn clauses advantage powerful allowing ecient proof
construction well known sld refutation procedures lloyd compared
prodigy description language pdl minton blythe et al language provide explicit quantification specific syntactic construct similar
expressiveness reached implicit quantification horn clauses moreover
language provide kind type specification constants variables
pdl think major disadvantage besides points language
quite similar pdl

formal model case abstraction
section present formal model case abstraction provides theory
changing representation language case concrete abstract already
stated assume addition concrete language abstract language supplied
domain expert following introduced formalism assume concrete level
solving defined concrete solving domain dc hlc ec oc rci
abstract level case solving represented abstract solving domain da hla ea oa rai reasons simplicity assume
domains share symbols condition achieved renaming symbols remainder states operators concrete
domain denoted sc oc respectively states operators abstract
domain denoted sa oa respectively case abstraction
described transforming case concrete domain dc case abstract
domain da see figure transformation formally decomposed two
independent mappings state abstraction mapping sequence abstraction mapping
bergmann c state abstraction mapping transforms selection concrete
state descriptions occur solution abstract state descriptions
following simply omit parameters operators instantiated operators case
unambiguous relevant
otherwise symbol sentence could become ambiguous would applying
generic abstraction theory would unclear whether generic abstraction rule refers concrete
abstract sentence



fibergmann wilke

abstract
domain

da











concrete
domain

dc

c





oj

ja


oc



c

oc

c



oc

c





j


om

oci

ocn


oc

oci

ci
j



cn
n

figure general idea abstraction
sequence abstraction mapping specifies concrete states mapped
skipped

state abstraction

state abstraction mapping translates states concrete world abstract world
definition state abstraction mapping state abstraction mapping sc sa
mapping sc set states concrete domain sa set states
abstract domain particular must effective total function
general definition state abstraction mapping impose restrictions
kind abstraction besides fact mapping must total many toone function however restrict set possible state abstractions set
abstractions user considers useful assume additional domain knowledge
abstract state relates concrete state provided knowledge
must expressed terms domain specific generic abstraction theory giordana
roverso saitta

definition generic abstraction theory generic abstraction theory set horn
clauses form ea ak rules ea abstract essential sentence
e ea ea ea ea substitution body generic abstraction rule
consists set sentences concrete abstract language e ai atoms
lc la
generic abstraction theory restrict set possible state abstraction
mappings deductively justified generic abstraction theory

definition deductively justified state abstraction mapping state abstraction mapping deductively justified generic abstraction theory following conditions
hold sc sc
sc sc rc
sc c c rc holds sc fulfilled


fibuilding refining abstract cases

definition first condition assures every abstract sentence reached
mapping justified abstraction theory additionally second requirement
guarantees abstract sentence used describe abstraction one state
must used describe abstraction states abstract sentence
derived generic abstraction theory please note deductively justified state
abstraction mapping completely induced set ea respect generic
abstraction theory follows sc f jsc rc g unless otherwise stated
assume deductively justified state abstraction mappings summarize
state abstraction mapping transforms concrete state description abstract state
description thereby changes representation state concrete abstract
please note deductively justified state abstraction mappings need defined
user determined automatically learning
presented section

sequence abstraction

solution consists sequence operators corresponding sequence
states relate abstract solution concrete solution relationship
abstract states operators concrete states operators must captured
abstract state must corresponding concrete state every concrete state
must associated abstract state due fact abstraction
reduction level detail michalski kodratoff situation reduction
number states selection concrete states corresponding
abstraction sequence abstraction mapping defined follows

definition sequence abstraction mapping sequence abstraction mapping n n

relates abstract state sequence sa sam concrete state sequence sc scn
mapping indices j f mg abstract states saj indices f ng
concrete states sci following properties hold

n initial state goal state abstract sequence

must correspond initial goal state respective concrete state sequence

u v u v order states defined concrete
state sequence must maintained abstract state sequence

note defined sequence abstraction mapping formally maps indices abstract
domain concrete domain abstraction mapping better map indices
concrete domain indices abstract domain inverse mapping
however mapping inconvenient handle formally since
range definition must considered therefore stick presented
definition

case abstraction

two abstraction functions introduced intuition case abstraction
captured following definition


fibergmann wilke

hierarchies abstraction spaces
dl
different kinds abstractions


da
da
dc

da



da




dc

figure different kinds abstractions abstraction hierarchies b

definition case abstraction case ca hhsa sami oa oam abstraction
case cc hhsc scn oc ocn respect domain descriptions dc da
oaj
oci c
sci
si f ng saj
sj j f mg
exists state abstraction mapping sequence abstraction mapping
saj scfi j holds j f mg

definition case abstraction demonstrated figure concrete space shows
sequence n operations together resulting state sequence selected states
mapped states abstract space mapping maps indices
abstract states back corresponding concrete states

generality case abstraction methodology

following brie discuss generality presented case abstraction methodology see hierarchies abstraction spaces well different kinds abstractions represented simultaneously presented methodology
different kinds abstractions

general one possible abstraction object world
abstraction performed many different ways example two different abstractions case already shown example figure example
two different abstractions see abstract cases ca ca derived
concrete case abstraction methodology able cope different abstractions
case specified user assume given one concrete domain dc
two different abstract domains da da represents two different kinds
abstraction furthermore assume abstract domains share
symbols define single abstract domain da joining individual
abstract domains includes kinds abstractions see figure
property formally captured following simple lemma
abstract domains disjoint symbols simply renamed achieve property



fibuilding refining abstract cases

lemma joining different abstractions concrete domain dc two disjoint abstract domains da da given joint abstract domain da da da
defined follows let da la ea oa ra let da la ea oa ra
da da da la la ea ea oa oa ra ra joint abstract domain
da fulfills following property ca abstraction cc respect dc da
respect dc da ca abstraction cc respect dc da
hierarchy abstraction spaces

work hierarchical solving assume multi level hierarchy abstraction
spaces solving e g sacerdoti knoblock even presented
contains two domain descriptions hierarchy abstract domains simply
mapped onto presented two level model shown figure b assume
hierarchy disjoint domain descriptions dl given particular domain
assumed abstract domain multi level hierarchy
abstraction spaces case c abstraction level abstraction case c
exists sequence cases c c ci domain di ci
abstraction ci respect di di f g multilevel hierarchy domain descriptions reduced two level description
abstract domain two level description contains union levels
multi level hierarchy property formally captured following lemma

lemma multi level hierarchy let dl arbitrary multi level
hierarchy

l
domain descriptions two level description dc da da
dc holds ca abstraction cc respect dl ca
abstraction cc respect dc da
since shown different kinds abstractions well hierarchies abstraction spaces directly represented within two level case abstraction methodology
restrict exactly two levels

computing case abstractions

present pabs bergmann c wilke automatically
learning set abstract cases given concrete case thereby assume
concrete domain dc abstract domain da given together generic abstraction
theory use functional notation ca pabs hdc da ai cc denote ca
element set abstract cases returned pabs
consists four separate phases introduced section
following present phases detail
first three phases require procedure determining whether conjunctive
formula consequence set horn clauses purpose use sld refutation
procedure lloyd given set horn clauses logic program c together
conjunctive formula g goal clause refutation procedure determines set
answer substitutions
c g holds
write
sld c g
sld refutation procedure performs kind backward chaining works


fibergmann wilke

follows selects literal goal clause g e left literal searches
horn clause logic program c contains literal head unifies
selected goal literal selected literal removed g body empty
applied clause added beginning goal clause general
unifier goal literal head clause applied whole goal clause
resulting goal clause called resolvent process continues goal clause
becomes empty resolvents built former case goal
proven answer substitution computed composing substitutions used
resolution backtracking used look possible selections applicable
horn rules determine alternative answer substitutions set answer substitutions
returned set
whole space possible applications available horn rules
searched unsuccessfully goal clause consequence logic program
c sld refutation procedure terminates without answer substitution

must confused situation empty substitution returned

f g variables occur g phase iii pabs require
derivation trees addition answer substitutions write sld c g
assume set pairs answer substitution
derivation c g
order assure termination sld refutation procedure require
abstract domain generic abstraction theory designed according
following principles
concrete state sc sc concrete operator oc oc oc
described hpreoc addoc deloc sld sc rc preoc must lead finite set
ground substitutions variables occur preoc
state abstract sa sa abstract operator oa oa oa
described hpreoa addoa deloa sld sa ra preoa must lead finite set
ground substitutions variables occur preoa
state sc sc abstract essential sentence e ea sld sc rc e
must lead finite set ground substitutions variables occur e
following four phases pabs explained detail

phase computing concrete state sequence

input case abstraction assume concrete case cc
hhsci scgi oc ocn note oc ocn totally ordered sequence instantiated operators similar plans prodigy minton minton et al veloso
carbonell first phase state sequence simulation
solution computed follows

first glance restrictions seem bit hard achieve take closer look see
standard requirement terminating logic program e prolog program



fibuilding refining abstract cases

phase computing concrete state sequence
sc sci
n
sld sci rc preoci stop failure operator applicable
sci sci n deloci addoci

end
scg scn stop failure goal state reached

oc


states sci computed sci
sci holds
f ng failure occurs given plan valid e solve given


phase ii deriving abstract essential sentences

derived concrete state sequence input following computes
sequence abstract state descriptions sai applying generic abstraction theory
separately concrete state

phase ii state abstraction
n
sai
e ea

sld sci rc e


sai sai fe g
end
end
end
please note claimed domain theories designed way

finite contains ground substitution variables e therefore every
description sai consists ground atoms consequently valid abstract state
description within introduced model case abstraction computed
superset outcome possible state abstraction mappings deductively justified
state abstraction mapping restricted sci sai fe sa jsci rc eg
f ng consequently determined abstract sentences abstract
case might require

phase iii computing possible abstract state transitions

next phase search instantiated abstract operators
transform abstract state ai sai subsequent abstract state aj saj j
therefore preconditions instantiated operator must least fulfilled
state ai consequently sai furthermore added effects operator must
true aj consequently saj


fibergmann wilke

phase iii abstract state transitions
g
n
j n
x xu oa
let hpreo delo addoi description x xu
sld sai ra preo
h
letadd faja addog
compute possible instantiations
added sentences hold saj
f g
set possible substitutions
initially empty substitution

add


e saj
substitution e fg
end
end


end

contains set possible substitutions
added sentences contained saj


g g fhi j x xu ig
end
end
end
end
end

set possible operator transitions collected directed edges graph
vertices represent abstract states set g edges acyclic
directed graph constructed pair states sai saj j checked
whether exists operator x xu applicable sai purpose
sld refutation procedure computes set possible answer substitutions
precondition operator fulfilled sai derivation belongs
answer substitution stored together operator graph since
required next phase case abstraction derivation tree
inner node ects resolution goal literal head clause
leaf node represents resolution fact note proving precondition
abstract operator inner nodes tree refer clauses horn rule set
ra leave nodes represent facts stated ra essential sentences contained


fibuilding refining abstract cases

sai answer substitution applied add list operator leading
partially instantiated add list add note still variables add

operator may contain variables contained precondition may
occur add list therefore set possible substitutions incrementally
constructed saj holds add completely instantiated operator
derived thereby finally included directed edge j graph g
guaranteed instantiated operator leads sai
saj applicable sai essential sentences added operator contained
saj furthermore applied sld refutation procedure complete finds
answer substitutions every instantiated operator applicable sai
essential sentences added operator contained saj contained
oai
graph follows immediately scfi
scfi holds arbitrary
deductively justified state abstraction mapping sequence abstraction mapping
hfi oai g holds

phase iv determining sound paths

state abstractions sai derived phase ii graph g computed
previous phase phase iv selects set sound paths initial abstract state
final abstract state set significant abstract sentences sequence abstraction
mapping determined construction path
phase iv searching sound paths
paths fh ig
exists h oa oak fii paths k n
paths paths n h oa oak fii
hi j oa g k
let e set essential sentences contained derivation
let e addoa
f kg holds

safi
sfi

sa
safi k
j
paths paths fh oa oak oa ffi k j gi g

end
end

casesabs
h oa oak fii paths k n
casesabs casesabs fhhsa san oa oak ig

end
return casesabs

construction sequence abstraction mapping obvious set represents image state abstraction mapping thereby determines set sentences

please note h oa oak matches fh ig k operator n denotes
set difference



fibergmann wilke

reached order assure applicability constructed operator sequence note state abstraction mapping directly determined
follows sci fe jsci rc eg idea start
empty path path extended operator g iteration
path leads final state index n essential sentences may
occur proof precondition added effects operator path
constructed far must still consistent according extension state description
addition operator must transform sentences correctly
phase iv returns cases abstractions given concrete input
case respect concrete abstract domain definitions generic abstraction
theory depending domain theory single abstract case learned
single concrete case already shown figure

correctness completeness pabs

finally want state strong connection formal model case
abstraction presented terminates domain descriptions generic abstraction theory formulated required beginning
section sld resolution procedure terminates correct
every abstract case computed pabs case abstraction according
introduced model sld refutation procedure applied pabs complete every
case abstraction according definition returned pabs property
captured following theorem

theorem correctness completeness pabs complete sldrefutation procedure used pabs case ca abstraction case cc
respect dc da generic theory ca pabs hdc da ai cc

complexity

complexity mainly determined phases iii iv worst
case complexity phase iii n c c n length concrete plan
c c dependent domain theories follows c joa j j
j c
jaddoa j jeajj
j jaddoaj thereby joaj represents number abstract operators j
j
maximum number substitutions found sld refutation procedure jaddoa j
maximum number added sentences abstract operator jeaj number
abstract essential sentences complexity phase iv determined n n
c assume constant domain theories overall complexity pabs
summarized n n exponential factor comes possibly exponential
number paths directed acyclic graph n nodes every state connected
every successor state whether graph kind appears much dependent
abstract domain theory determines transitions abstract states
possible exponential nature lead time complexity domains
used additionally want make clear computational effort must
spent learning solving time required learning
long learning phase executed line


fibuilding refining abstract cases

space complexity mainly determined phase iii
derivations proofs abstract operators preconditions must stored
sum n c c derivations worst case turn
domains used derivation short cases
inferences static horn rules reason derivations relate
abstract operators likely contain less preconditions concrete operators

refinement abstract cases

previous section described abstract cases automatically learned
concrete cases assume case base contains set abstract cases
want abstract cases used solve concrete level
furthermore discuss impact specific form abstract solving
domain improvement solving achieved

applicability refinability abstract cases

given abstract case concrete description question arises
situations abstract case refined solve concrete kind
refinability posterior definition easily given follows

definition refinability abstract case abstract case ca refined solve
concrete p exists solution oc p ca abstraction
hp oci

obviously refinability property undecidable general since otherwise
would decidable however define applicability abstract case
decidable necessary property refinability follows

definition applicability abstract case abstract case ca hhsa sami
oa oam applied solve concrete p hsci scg exists state
abstraction mapping sai im f mg sci sa
scg sam thereby im denotes image state abstraction mapping e

abstract states reached

applicable abstract case least guaranteed concrete initial goal
states map abstract ones concrete intermediate states exists
abstracted required abstract case
even applicability necessary precondition refinability formally
guarantee refinability since downward solution property tenenberg states
every abstract solution refined strong requirement hold general
abstraction methodology however indeed guaranteed abstract case
contained case base already abstraction one previous concrete cases
due correctness pabs used learning one
contained concrete cases solved guaranteed learned
abstract case refined solve consequently abstract case
case base least refined solve one occurred past


fibergmann wilke

abstract solutions useless never refined solve concrete
never case base consequently never tried solving
therefore expect abstract case case base high chance
refinable similar applied

selecting applicable abstract case

decide whether abstract case applied solve concrete p
determine suitable state abstraction mapping assume deductively
justified state abstraction mappings
required state abstraction mapping




induced set si shown section consequently ca applicable
p hsci scg sa f j sci rc g sam f
j scg rc g since every abstract case use solving
learned another concrete case known abstract state sai must
least one concrete state previous concrete state abstracted via
sai consequently sai im holds together introduced restrictions
definition rc respect complete sld refutation procedure see section
applicability abstract case decidable describes selection
applicable abstract case p hsci scg detail
selection applicable abstract case
sai sag

e ea

sld
sci rc e


si si
e
e ea

sld sscg rc e
sag sag
e
repeat
repeat
select case ca hhsa sam oa oam case base
sa sai sam sag
cases available
refinedfid sci scg
return refinedfid
sm sai sai n deloai addoai
sai
sai sa sag sam
refinedfid sci sa sam scg
refinedfid returns success p
return success p

first initial final concrete states abstracted
generic abstraction theory thereby abstract description hsai sag determined
pre selection step abstract case chosen form case base
abstract sentences contained initial final abstract state case must


fibuilding refining abstract cases

contained abstracted description hsai sag condition however
guarantee selected case applicable respect definition set
abstract sentences inducing respective state abstraction mapping computed
applicability condition checked test whether selected case applicable
selected case applicable case must retrieved applicable abstract
case determined refinement refinedfid see following section
executed uses sequence intermediate abstract states sa sam
previously determined abstract plan case guide search concrete
level operators contained abstract plan used anymore refinement
procedure returns success p refinement succeeds solution plan p
refinement fails procedure returns failure another case selected cases
available solved pure search without guidance abstract
plan

refining abstract plan
refinement selected abstract case starts concrete initial state
statement search proceeds sequence concrete operations found
leads concrete state sc sa f j sc rc g holds
applicability condition abstract case guarantees state exists sai im
guaranteed required concrete operator sequence exists therefore
search task may fail causes whole refinement process fail first
abstract operator refined successfully concrete state found state
taken starting state refine next abstract operator manner
refinement fails backtrack refinement previous operator try
alternative refinement whole refinement process reaches final abstract
operator must directly search operator sequence leads concrete goal
state scg concrete goal state reached concatenation concrete partial
solutions leads complete solution original
refinement demands search procedure allows abstract goal specification kinds forward directed search depth first iterative deepening korf
b best first search korf procedures used purpose
states explicitly constructed search states tested see
abstracted towards desired goal paris use depth first iterative deepening
search described consists two recursive procedures
top level procedure refinedfid receives concrete initial state sci concrete final state
scg sequence intermediate abstract states sa sak derived abstract
case well set induces state abstraction mapping procedure
increments maximum depth depth first search procedure searchbounded
maximum deepmax procedure searchbounded performs actual search goal
search abstract state e first abstract state concrete
goal state scg abstract state already visited procedure performs
depth first search applying available concrete operators recursively calling
search procedure concrete state scnew operator application


fibergmann wilke

abstract goal state reached removed list refinement
continues next abstract state first one list
refinement depth first iterative deepening dfid search
procedure refinedfid sci scg
deep

repeat

searchbounded sci scg deep
searchbounded returns success p return success p
deep deep search unsuccessful increment search deepness
deep deepmax

return failure

procedure searchbounded sci scg deep
abstract goals test concrete final goal
sci scg return success
sa sak least one abstract goal
e sa holds sld sci rc e
e n sa holds sld sci rc e
abstract state reached refine next abstract operator
refinedfid sci sa sak scg
refinedfid returns success p return success p
deep return failure maximum depth reached
apply operators create successor states

oc oc

sld sci rc preoc
set possible operator instantiations


scnew sci n deloc addoc create successor state
searchbounded scnew scg deep continue search state
searchbounded returns success p return success oc p
return failure
please note kind refinement different standard notion refinement hierarchical solving knoblock et al b
strong correspondence abstract operator possible concrete operator
moreover justification structure refined abstract plan completely different
justification structure abstract plan completely independent
definition abstract concrete operators even disadvantage compared
usual refinement procedure used hierarchical solving main computational
advantage abstraction caused decomposition original smaller
subproblems maintained

alternative search procedures refinement

besides forward directed search procedure currently used paris backward directed
search used means end analysis fikes nilsson nonlinear partial ordered


fibuilding refining abstract cases

mcallester rosenblitt applied refinement certain
circumstances therefore would require state concretion function
turn rules generic abstraction theory virtual concrete operators
state concretion function must able determine single state finite set
concrete states given abstract state together concrete description
thereby concrete description may help reduce number possible concrete states derived state concretions used concrete goal states
backward directed search may start
alternatively turn process state concretion directly search procedure representing rule generic abstraction theory virtual abstract
operator precondition rule generic abstraction theory becomes precondition virtual operator conclusion rule becomes positive effect
operator virtual concrete operators together operators
concrete domain backward directed planner use abstract state directly
goal search part plan resulting solution consists concrete operators virtual operators taken refinement abstract
operator

criteria developing abstract solving domain
abstract solving domain generic abstraction theory used important impact improvement solving achieved therefore
desirable set criteria state good abstract domain definition look strong criteria allowing quantitative predictions resulting speedups
hardly developed hierarchical planners criteria exist
however give set factors determine success
overall solving time uenced mainly following four factors independent refinability abstract operators goal distance abstract operators concrete scope
applicability abstract operators complexity generic abstraction theory
independent refinability abstract operators

following korf analysis hierarchical solving korf introduced
plan refinement reduces overall search space bn
psection
b thereby b average branching factor n length coni
crete solution sequence abstraction mapping used abstraction
concrete case abstract case already mentioned cannot guarantee
abstract plan applicable really refined furthermore korf
analysis assumes backtracking refinement individual abstract
operators required cannot guaranteed computational advantage
abstraction lost two cases
however abstract operators occurring abstract solving domain
fulfill strong requirement independent refinability guaranteed every
applicable abstract case refined without backtracking abstract operator oa
independently refinable sc c sc every state abstraction mapping


fibergmann wilke


sc
sc holds
exists sequence concrete operators oc ock
c
c
ok c

sc

holds


requirement seems much hard develop abstract
solving domain operators fulfill requirement although cannot
expect operators abstract solving domain independently refinable
knowledge engineer developing abstract domain still try define abstract
operators independently refined situations e sc c sc
state abstraction mapping applicable abstract operator refined
concrete operator sequence although notion mostly independent refinability
formal feel practically useful developing abstract domain definition
abstract operators refined independently many situations
higher chance abstract plan composed operators refinable
goal distance abstract operators

goal distance cf subgoal distance korf maximum length sequence
concrete operators required refine particular abstract operator longer goal
distance larger search space required refine abstract operator particular
complexity search required refine complete abstract plan determined
largest goal distance abstract operators occur abstract plan
hence good reason keep goal distance short however goal distance
negatively interacts next factor namely concrete scope applicability
abstract operators
concrete scope applicability abstract operators

concrete scope applicability abstract operator specifies many concrete
states abstracted abstract state abstract operator applicable
many concrete states abstracted abstract state reached
abstract operator scope determined definition abstract operator
generic abstraction theory responsible specifying admissible state
abstractions concrete scope applicability abstract operators determines
applicability abstract plans learned abstract plan applicable concrete limited use domains
solved vary much hence concrete scope applicability abstract operators large possible unfortunately according experience abstract
operators large scope usually larger goal distance operators
short goal distance large scope applicability therefore compromise
two contradicting issues must found
complexity generic abstraction theory

fourth factor uences solving time complexity generic
abstraction theory theory must applied time concrete state created
concrete level search complex generic abstraction theory
time required compute state abstractions hence generic abstraction theory


fibuilding refining abstract cases

require complicated inferences avoid backtracking within sld refutation
procedure
although four factors allow precise prediction expected
solving behavior resulting system provide focus consider
designing abstract solving domain related generic abstraction theory

example domain process mechanical engineering
paris successfully tested toy domains familiar
towers hanoi simon domains hierarchical solvers use
dropping sentence proven useful knoblock
section presents example domain selected field process mechanical engineering really requires stronger abstraction
selected goal generating process plan production
rotary symmetric workpiece lathe description may derived
cad drawing contains complete specification especially geometry
desired workpiece goal state together specification piece raw material
called mold produced initial state
left side figure shows example rotary symmetric workpiece
manufactured cylindrical mold rotary parts manufactured putting
mold fixture chuck lathe chucking fixture together attached
mold rotated longitudinal axis mold rotation center
mold rotated cutting tool moves along contour thereby removes certain parts
mold desired goal workpiece produced within process
hard determine sequence specific parts workpiece
removed cutting tools used workpiece chucked certain area
workpiece covered chucking tool cannot processed cutting tool
moreover workpiece chucked area used chucking plain
otherwise fixation would suciently stable hence many workpieces usually
processed first chucking workpiece one side processing accessible area
workpiece chucked opposite side area previously covered
processed processing example workpiece shown figure requires
workpiece first chucked left side right side processed processed
right side used chuck workpiece area plain allows stable
fixing hence left side workpiece including small groove processed
explain representation domain detail complete definition
domain found online appendix several simplifications real
domain required order obtain domain definition could eciently handled
large set experiments one restriction represent workpieces
right angled contour elements example conical contour cannot represented
many different cutting chucking tools available real life process
domain adapted caplan system paulokat wess developed university kaiserslautern
note figure shows dimensional drawing dimensional workpiece measure
equals mm



fibergmann wilke

example workpiece

grid representation example workpiece

mm
mm


mm

mm

raw
material
workpiece

mm






mm



mm









x

mm
mm

figure example workpieces grid representation
restricted single chucking tool three different cutting tools
specification tools simplified example rotation
speed workpiece feed cutting tool parameters play
role processing workpiece impact parameters neglected
despite simplifications remaining part real world domain trivial
represents substantial subset critical domain

concrete domain
explain concrete solving domain giving detailed description
states operators
state description

representation domain concrete level exact geometry
workpiece must represented state including specific measures detail
contour however complete workpiece divided atomic areas
processed whole therefore state representation organized
grid divides entire workpiece several disjoint rectangular areas
different sizes see right side figure together grid coordinate specific
position size corresponding rectangular area represented grid used
static part state description change however
different require different grids specific shape workpiece
represented specifying status grid rectangle table predicates
used represent workpiece described detail
besides description workpiece state representation contains information workpiece chucked kind cutting tool currently used
table describes predicates used purpose


fibuilding refining abstract cases

predicate description
xpos max predicates xpos max xgrid ypos max ygrid specify size
ypos max grid direction x coordinate coordinate respectively
state consists exactly one instance predicates e g
xpos max ypos max example shown figure
grid xpos
grid ypos

predicates grid xpos xgrid xstart xsize grid ypos ygrid ystart ysize
specify geometrical position size grid areas direction
x coordinate coordinate respectively first argument
predicates specifies coordinate grid areas second argument
declares geometrical starting position third argument specifies
size grid areas state consists exactly one instance
predicates different x coordinate coordinate
example grid xpos grid xpos grid xpos
grid xpos specify grid x direction grid ypos
grid ypos specify grid direction

mat

predicate mat xgrid ygrid status describes status particular
grid area specified coordinates xgrid ygrid argument status
instantiated one three constants raw workpiece none
constant raw indicates specified area still consists raw material must removed cutting operators constant
workpiece specifies area consists material belongs
goal workpiece constant none specifies area contain
material e material present mold material
already removed previous cutting operations one instance
mat predicate required grid area specify current state
previously mentioned predicates change execution plan mat predicate changed cutting operator
particular initial state goal state differs status assigned grid areas must become removed example
initial state example shown sentence mat raw
present final state contains sentence mat none
table essential sentences representation workpiece

operators

process plan manufacture certain workpiece consists sequence operators
total order operators domain manufacturing
steps executed sequentially lathe chosen four different operators
however brands lathe machine allow parallel processing



fibergmann wilke

predicate
chuck pos

description
predicate chuck pos side describes whether workpiece currently
chucked side parameter side instantiated one
three constants none right left constant none specifies
workpiece chucked constants right left specify
workpiece chucked respective side state contains
exactly one instance predicate

covered

predicate covered xmin xmax specifies areas workpiece
currently covered chucking tool predicate declares
areas x coordinate lying within interval xmin xmax
covered covered areas cannot processed cutting tool state
consist exactly one instance predicate workpiece chucked

cut tool
predicates cut tool id cut direction dir specify unique identicut direction fication id cutting tool currently used area
processed direction dir cutting tool moves parameter id symbol specifies legal cutting tool described
predicates included static rules rc concrete domain description parameter dir instantiated one three constants
left right center value left specifies cutting tool moves
left right right specifies cutting tool moves right
left center specifies cutting tool move outside towards
center workpiece

table essential sentences representation chucking cutting tools
represent chucking workpiece selection cutting tool cutting
process operators described table
manufacturing workpiece shown figure requires step plan shown
figure first workpiece chucked left side cutting tool selected
allows cutting right left tool indicated grid areas removed
please note left side workpiece cannot processed since covered
chucking tool see right side figure workpiece unchucked
chucked right side tool allows processing left right upper
part mold removed finally specific tool used manufacture small groove

abstract domain

example see small groove considered detail
processed basic contour workpiece established important
characteristic example right part workpiece processed
left side workpiece sequence crucial success plan groove


fibuilding refining abstract cases

operator
chuck

description
operator chuck side specifies workpiece chucked
specified side side parameter instantiated constants
left right chucking allowed workpiece chucked already surface used chucking plain effect chucking
operation respective instances predicate chuck pos covered
included state description

unchuck

operator unchuck specifies chucking workpiece removed operation executed workpiece chucked already effect operation parameter predicate chuck pos
changed none predicate covered deleted

use tool

operator use tool dir id specifies tool selected subsequent cutting operators direction cutting tool moves
workpiece must chucked tool chosen effect
operator respective instantiations predicates cut tool
cut direction added state parameters use tool
operator definition respective predicates

cut

operator cut xgrid ygrid specifies raw material grid
area indicated coordinates xgrid ygrid removed effect
operator predicate mat specifies status
particular area changed status raw status none however
apply operator several preconditions must fulfilled workpiece
must chucked chucking tool must cover specified area
area must accessible cutting tool moreover cutting
tool allows processing selected area must already
selected cutting tool imposes certain constraints geometrical
size area processed details see full
description domain online appendix
table concrete operators

would processed first workpiece could never chucked left side
processing right side would consequently impossible domain experts told us
situation specific example shown general importance
many cases fact allows us select parts description solution
considered details abstract parts essential
must maintained abstract case found abstract
detailed shape workpiece long distinguish processing left
right side workpiece furthermore important distinguish
rough contour workpiece small details grooves developed


fibergmann wilke

chuck left

unchuck chuck right

use tool right cut cut

use tool left cut cut
use tool center cut unchuck

figure plan manufacturing workpiece
abstract domain definition containing language describing states operators
abstraction idea
state description

introduce abstract grid divides workpiece left middle
right area abstract specific location concrete grid area areas
called complex processing areas area assigned particular status furthermore
abstract state contains information whether complex processing area contains
small contour elements grooves grooves exactly look
abstract detailed conditions chucking workpiece abstract state
contains approximation conditions stating workpiece cannot chucked
particular side side contains small contour elements already
processed predicates used represent abstract state described detail
table
operators

consider abstract operator completely processes one complex area
workpiece operator processes complex area roughly operator
processes small grooves complex area consider abstract chucking
operator chucking strong impact overall plan table shows
available abstract operators

generic abstraction theory
generic abstraction theory defines sentences used describe abstract state see
table terms sentences concrete state see tables set
horn rules definition abstract sentence explained detail table


fibuilding refining abstract cases

predicate
abs area state

description
predicate abs area state area status describes status
three complex processing areas argument area
specifies one complex processing areas left middle right
argument status describes status respective area
status todo rough ready status todo
specifies area needs processing large contour elements rough area small contour elements
grooves need processed status ready specifies
area completed abstract initial state usually contains
one complex processing areas status todo
abstract goal state complex processing areas status
ready

abs small parts

predicate abs small parts area specifies complex processing area area contains small contour elements need
manufactured

abs chuck pos

predicate abs chuck pos side describes whether workpiece
currently chucked side parameter side
instantiated one three constants none right left
predicate exactly meaning chuck pos predicate
concrete level predicate abstracted
renamed

abs chuckable wp

predicate abs chuckable wp side describes whether workpiece chucked left right side side
completely processed

table essential sentences describing abstract state
strongly considered factors uence quality domain see section development abstract solving domain generic
abstraction theory although none defined abstract operators independently refinable mostly independently refinable preconditions abstract
operator still contains approximations conditions must fulfilled order assure concrete operator sequence exist refines abstract operator example
predicate abs chuckable wp side approximation detailed condition plain
surface required chucking goal distance operator quite different
strongly depends solved goal distance set fixation
operators two possibly one unchuck operator followed chuck operator
goal distances abstract operators different example goal distance process ready operator depends number concrete grid areas belonging


fibergmann wilke

operator
set fixation

description
operator set fixation side specifies workpiece chucked
specified side side parameter instantiated
constants left right none constant none specifies
chucking removed compared concrete operator chuck
preconditions chucking side simplified effect
operator predicate abs chuck pos modified

process rough

operator process rough area specifies complex processing
area area processed completely small contour elements parameter area left middle right
precondition operator requires workpiece chucked
different side area effect operator predicate abs area state modified

process fine

operator process fine area specifies small contour elements
complex processing area area processed parameter area left middle right precondition
operator requires large contour elements side
workpiece already processed workpiece chucked
different side effect operator predicate
abs area state modified

process ready

operator process ready area specifies indicated complex
area workpiece completely processed including large
small contour elements effect operator predicate
abs area state modified
table abstract operators

respective abstract area containing material needs removed
goal distance number gird areas say c plus number required use tool
operations less equal c hence goal distance c c
goal distance become long complex two operators
process rough process fine introduced cover processing small
large grid areas respectively consequently smaller goal distance
process ready operator goal distance two operators smaller
smaller concrete scope applicability process ready operator example
process ready operator applied state arbitrary areas need
processed process fine applied states large grid areas
already processed
although developed simplified version whole domain production mechanical engineering rotary symmetrical workpieces feel


fibuilding refining abstract cases

abstract predicate description terms predicates concrete domain
abs area state
predicate abs area state area status describes status
three complex processing areas left processing area
consists areas concrete grid covered
workpiece chucked left side similarly right processing
area consists concrete grid areas covered
workpiece chucked right side middle processing area
consists areas never covered chucking
tool status complex processing area todo exists
concrete large grid area belongs complex processing
area needs processed grid area considered
large size direction x coordinate larger
mm status complex processing area rough large
grid areas complex processing area already processed
exists concrete small grid area belongs
complex processing area needs processed gird
area considered small size direction x coordinate
smaller equal mm status complex processing
area ready concrete grid areas belong complex
processing area processed
abs small parts

sentence abs small parts area holds exists small concrete grid area size smaller equal mm belongs
complex processing area needs processed

abs chuck pos

sentence abs chuck pos side holds concrete
sentence chuck pos side holds

abs chuckable wp

predicate abs chuckable wp side describes whether workpiece still chucked left right side side
completely processed sentence holds part desired
workpiece belongs respective side completely plain
concrete grid areas status workpiece range
coordinate
table generic abstraction theory

domain expert together knowledge engineer able define abstract
domain representation generic abstraction theory complete domain particular model interactive knowledge acquisition tools mikado schmidt
schmidt zickwolff make complete modeling task much feasible


fibergmann wilke

case c
initial state

goal state

solution
chuck left

chuck right
use tool center
use tool right
use tool left cut
cut cut cut cut unchuck
unchuck


abstraction











ii

iii

iv





abstraction

abstraction
v

vi

abstract case ca
abstract initial state
abs area state left todo
abs area state right todo
abs small parts left
abs chuckable wp right


abstraction

abstract solution
set fixation left
ii process ready right
iii set fixation right

abstract goal state

iv process rough left
v process fine left
vi set fixation none



ii

iii







iv

v

vi





abs area state left ready
abs area state right ready
abs chuckable wp right

refinement


case c

initial state

solution solution
chuck left
use tool right
cut
unchuck


abstraction

goal state


chuck right
use tool center

use tool left cut
cut cut cut
unchuck

figure abstracting refining example case

abstracting refining process case

explain example case shown figure abstracted
abstract case reused solve different process
demonstrated figure top figure shows concrete case c
already presented figure case abstracted pabs presented
section returns different abstract cases one abstract cases
shown center figure abstract solution plan consists sequence
abstract operators sequence operators plan indicated roman
numerals particular abstraction indicated concrete abstract case
denotes sequence concrete operators turned abstract operator
abstract cases differ shown abstract case two aspects shown abstract
solution additional abstract step set fixation none inserted steps ii iii
abstract step v replaced abstract step process ready abstract steps iv v
together replaced abstract step process ready



fibuilding refining abstract cases

learned abstract case used solve c whose initial
final concrete states shown bottom figure even concrete workpiece
looks quite different workpiece case c abstract case used solve
reason workpiece requires left
right side must processed particular right side must processed
left side processed left side contains two small grooves prevent
workpiece chucked side processed however see
abstract operators particular operators ii vi v refined completely
different sequences concrete operators abstracted
already mentioned abstract operators used independently refinable
mostly independently refinable consequently happen applicable abstract case cannot refined figure shows example concrete
abstract case shown figure applicable refinable reason
location small abstract part left side workpiece small
part consists concrete grid area raw material must removed however specific situation small part must removed large parts
left side workpiece contains grid areas removed
reason without removing small part larger parts located right
small part cannot accessed cutting tool able cut areas
consequently solved plan shown right
side figure unfortunately plan refinement abstract plan shown
figure abstract plans requires large parts must removed
small parts removed hence refinement operator process rough left fails
situation solver must select different abstract plan

empirical evaluation
section presents empirical study paris mechanical engineering domain already introduced evaluation performed fully implemented
paris system abstraction abilities system generalization component switched purpose designed experiments allow us
judge performance improvements caused abstract cases derived pabs
furthermore analyzed average speed behavior system respect
large set randomly selected training test cases

cases
empirical evaluation concrete cases randomly generated case
requires sentences describe initial final state
instances mat predicate length solution plans ranges
operators even generated cases represent simple compared
real domain expert needs solve search space required solve sample
already quite large due fact branching factor b
depending complexity hence step solution
complete search space consists states


fibergmann wilke

solution




mm



mm



workpiece

mm

chuck left
use tool right
cut
cut
unchuck
chuck right
use tool left
cut
cut
cut
use tool center
cut
unchuck

mm
abs small parts left






x

figure example case refinement abstract plan shown figure
fails

case generation procedure leads solutions optimal nearly optimal
solutions require less steps optimal solutions sense
known shortest solution solve solutions longer
steps manually checked see whether contain steps
obviously redundant redundant steps removed although solutions
necessarily shortest solutions nevertheless acceptably short

evaluating abstraction dropping sentences
first used recent version alpine knoblock together prodigy blythe et al check whether abstraction dropping sentences improve
solving domain represented described section therefore used
concrete solving domain domain theory prodigy unfortunately
representation alpine able generate ordered monotonic abstraction
hierarchy reason alpine distinguish different groups
literals different literal names argument types used
space example alpine cannot distinguish different sentences
described mat grid xpos predicate important
abstraction would drop parts grid represent small rectangles
grooves however would require examination measures associated
grid area argument relation surrounding grid areas therefore sentence drop criticalities assign cannot decided statically
name predicate type arguments hierarchical planners including


fibuilding refining abstract cases

prodigy alpine highly dependent representation used particular

strategy restricted dropping sentences holte et al however might
another representation domain hierarchical planners improve
performance think representation quite natural domain
first trial conclude application domain representation
chosen following experiments paris really require dropping
sentences achieve improvement abstraction

evaluating paris

first experiment paris designed evaluate hypotheses domain
need changing representation language abstraction ii
reusing abstract cases instead generating abstract solutions scratch test
hypotheses rely time solving randomly generated different
modes paris system
experimental setting
experiment used paris system solve randomly

generated cases thereby goal abstraction improve concrete level
solver performs brute force search depth first iterative deepening search
strategy korf introduced section improvement determined
terms solving time required solve single paris used solve
three different modes

pure search solver used solve pure search without
use abstraction

hierarchical mode paris uses introduced abstract domain

ever abstract cases recalled case library computed automatically search standard hierarchical abstraction language solver first tries search solution original
abstract domain tries refine solution
hierarchical solving backtracking two levels abstraction
subproblem occur thereby used hierarchical
abstraction methodology instead dropping sentences

reasoning abstract cases mode first used paris learn abstract
cases come concrete cases abstract cases
exists according abstraction methodology available one
solved solving measured time required
solving every applicable abstract cases
three abstract cases determined best abstract case e case leads
shortest solution time b worst abstract case longest solution time
abstraction aspired solution case c worst applicable abstract
case determined difference b c relates difference
applicable refinable abstract cases introduced section abstract case


fibergmann wilke

selected c applicable current might abstraction
case taken b abstract cases selected
indeed abstractions current e abstract cases
previously learned case taken three
different cases selected figure impact case selection
addressed proposed method
although every theoretically solved brute force search procedure
exponential nature search space avoids solution complex within
reasonable time therefore time bound cpu seconds sun sparc elc
computer introduced three modes described limit bound
exceeded remains unsolved increasing time bound would increase
number solvable three modes


determined solution time described
modes average solution time well number could solved
within time limit shown table determined values reasoning
abstract cases separately three types abstract cases significance
speedup investigated maximally conservative sign test
etzioni etzioni unfortunately turned speedup hierarchical
pure search significant significant speedup
reasoning abstract cases worst applicable abstract case c
pure search due large number doubly censored data
solvers cannot solve within time limit counted
speedup hypothesis however improvements pure search reasoning refinable
abstract cases significant p best refinable case
worst refinable case b furthermore turned speedup
reasoning refinable cases hierarchical significant upper
bound p value mentioned p value standard value used statistical
hypothesis tests probability assuming hypothesis hold
encountering data favors hypothesis much observed data
experiment etzioni etzioni therefore significant
p value smaller analysis clearly see two basic hypotheses
supported experimental data even significant see moderate
improvement solving time number solved
hierarchical changing representation language please remember
hierarchical dropping conditions lead improvement see
section obviously changing representation language abstraction required
improve solving domain stated first hypothesis
strong support second hypothesis ii found presented
data see significant speedups reasoning abstract cases pure search
even hierarchical worst abstract case used
solved speedup significant solving behavior slightly
worse hierarchical please note situations extremely unlikely


fibuilding refining abstract cases

solving mode
average solution time sec solved
pure search


hierarchical


reasoning abstract cases
best refinable case


b worst refinable case


c worst applicable case


table comparison average solution time per number solved
within time bound seconds table compares pure search
depth first iterative deepening hierarchical abstract solving domain reasoning abstract cases differently selected
abstract cases
happen sophisticated indexing retrieval abstract cases situation
avoided part

evaluating impact different training sets
one respect previous experiment optimistic assumption
assume abstract cases required solving learned advance
situation realistic scenario application usually one set cases
available training system different set needs solved
cannot assume good applicable abstract cases available solve
furthermore presented example shows solving time
vary lot different abstract cases selected solving therefore
designed experiment evaluate improvements caused paris
realistic scenario
experimental setting

randomly chosen training sets cases training sets cases
available cases training sets selected independently
training sets used separate experiment
experiments cases used particular training set
used evaluate performance resulting system training set test set
completely independent procedure solving task
determine solving behavior applicable abstract cases used
simple automatic mechanism retrieve one hopefully good applicable abstract case
therefore cases organized linearly cases base sorted
length abstract plan contained case case base sequentially searched
longer shorter plans applicable case found heuristic
assumption longer abstract plan specific shorter abstract plan


fibergmann wilke

size training sets
cases



number abstract cases
minimum
maximum
average







table comparison number learned abstract cases training sets
consists concrete cases b training sets
consists concrete cases table shows minimum maximum
average number abstract cases learned training sets
respective size
size training sets
cases



average solving time sec
best set
worst set
average







table comparison solving time required reasoning abstract cases
separate training training sets consists
concrete cases b training sets consists concrete
cases table shows average solving time per best
worst average training set training sets size
divides actual smaller subproblems consequently longest
applicable plan lead best improvement


statistically evaluated second experiment table shows number abstract
cases could learned different training sets minimum maximum
average number abstract cases could learned training sets
size indicated note altogether abstract cases learned
cases would used training previous experiment training
sets contained cases abstract cases could learned
expected size training set increased abstract cases learned
table shows average solving time learning different sets
table shows minimum maximum average solving time
different training sets two sizes see best training sets leads
solving time similar slightly worse optimum shown
table even average case considerable improvements pure search
hierarchical solving compare table table discovered


fibuilding refining abstract cases

size training sets
cases



percentage solved
best set
worst set
average







table comparison percentage solved separate training
training sets consists concrete cases b
training sets consists concrete cases table shows
percentage solved best worst average training
set training sets size
size training sets
cases



number training sets significant speedups
pure search
hierarchical
p
p
p







table comparison significance p value speedup pure search
hierarchical separate training training sets
consists concrete cases b training sets
consists concrete cases table shows number training sets
cause significant speedups different p values
positive identified looking percentage solved
shown table see best training sets number solved
close maximum achieved even worst
training set considerably could solved pure search hierarchical

additionally mentioned speedup analyzed maximally conservative sign test described etzioni etzioni table summarizes
significance speeding pure search hierarchical solver
turned training sets lead highly significant speedups p
pure search hard upper bound p values half training
sets lead significant differences reasoning abstract cases hierarchical
slightly higher upper bound p training sets
caused significantly better performance hierarchical
altogether reported experiment showed even small number training cases
e already lead strong improvements solving
see abstract cases must present first experiment successful
furthermore experiment shown even simple retrieval mechanism sequential


fibergmann wilke

size training sets
cases



average percentage solutions
shorter equal longer solution length
shorter
equal
longer







table comparison length solutions created reasoning learned
abstract cases solutions available concrete cases table shows
average percentage solutions shorter equal longer solution length
separate training training sets consists
concrete cases b training sets consists concrete
cases
search select beneficial abstract cases library neither training situations
second experiment lead worse worst case shown table


quality produced solutions

although main purpose improve performance
solver quality produced solutions important practical system
solution length used simple criterion determine quality
solution however general quality solution ect execution costs
plan plans robustness certain user preferences perez carbonell
quality measures dicult assess particular manufacturing
domain rely simple criterion used evaluating quality solutions
prodigy analogy veloso
experimental setting

analyzed solutions computed previous set experiments assess
quality solutions produced paris therefore length solutions derived
solving learning training sets compared
length nearly optimal solutions contained concrete cases


training set length solution derived corresponding testing phase
compared length solution noted concrete case percentage
solutions shorter equal longer solution length determined training set
separately average training sets equal size determined table
shows evaluation
turned big difference quality
training sets particular size training sets strong uence


fibuilding refining abstract cases

table see
solutions produced equal better quality solutions contained
concrete cases please note concrete cases used testing different
cases used training additionally solutions compare
produced paris already nearly optimal solutions due case generation
procedure taking account already fairly good

impact abstract solving domain
experiments reported conducted concrete abstract domain
representation presented section online appendix final experiment
impact specific choice abstract solving domain investigated
experimental setting

created abstract solving domain less constrained one
used purpose one operator completely removed certain conditions
remaining operators removed particular set fixation operator
removed conditions abs chuck pos abs chuckable wp chuck comp removed
preconditions three remaining operators hence fact chucking
workpiece impact production plan neglected abstract level
however concrete solving domain generic abstraction theory
modified consequently chucking still plays important role concrete level
set experiments described section repeated less constrained
abstract solving domain training testing sets


table summarize experiments table shows average
solving time occurs learning different training sets turns
training sets learning improves concrete level solver
speedup much smaller original abstract solving domain
cf table particular none resulting speedups concrete level
solving significant similar observed comparing percentage
solved see figure still slight improvement number
could solved learning improvement much smaller
original abstract solving domain cf table

cases one shorter solutions produced paris one step shorter solution
contained concrete case



fibergmann wilke

size training sets
cases



average solving time sec
best set
worst set
average







table less constrained abstract solving domain comparison
solving time required reasoning abstract cases separate
training training sets consists concrete cases
b training sets consists concrete cases table
shows average solving time per best worst
average training set training sets size

size training sets
cases



percentage solved
best set
worst set
average







table less constrained abstract solving domain comparison
percentage solved separate training training sets
consists concrete cases b training sets
consists concrete cases table shows percentage solved
best worst average training set training sets
size
experiment supported general intuition abstract solving domain significant impact improvement solving achieved
reasoning abstract cases reason less constrained domain leads
worse original abstract domain explained respect
criteria explained section since important preconditions abstract operators
removed many situations operators cannot refined
holds particularly situations workpiece cannot chucked perform
required cutting operations abstract operators mostly independently
refinable moreover since abstract operator set fixation removed concrete chuck
unchuck operator must introduced refinement remaining abstract
operators consequently goal distance abstract operators increased
two factors reason worse less constrained abstract domain
theory


fibuilding refining abstract cases

discussion
shown detail hierarchical solving sacerdoti
tenenberg unruh rosenbloom yang tenenberg knoblock
limited view abstraction dropping sentences well strategy
abstract solutions computed lead poor behavior relevant situations
observation supported comprehensive artificial examples see section
real world example domain mechanical engineering see section
supported experiment see section recent reported holte et al
support observations well
general abstraction task transforming solution concrete representation different abstract representation reducing level
detail michalski kodratoff giunchiglia walsh michalski however hierarchical solvers much limited view abstraction
dropping sentences shown reason ecient ways abstracting
solution impossible e g see section figure second weakness
hierarchical solvers usually compute arbitrary abstract solutions solutions high chance refinable next concrete
level although upward solution property tenenberg guarantees refinable abstract solution exists guaranteed solver finds abstract
solution e g see section solvers even heuristically guided towards
refinable abstract solutions
paris present formal abstraction methodology
solving see section allows abstraction changing whole representation language concrete abstract together formal model correct complete
learning abstracting concrete solving cases see section given
abstract solutions determined procedure useful solving concrete
high chance refinable
detailed experimental evaluation fully implemented paris system
domain mechanical engineering strongly demonstrates paris significantly improve solving situations hierarchical solver dropping
sentences fails advantage see table

related work
discuss paris relation relevant work field
theory abstraction

within giunchiglia walsh theory abstraction paris
classified follows formal system ground space given concrete
solving domain dc situation calculus green representation
language abstract formal system given language abstract
solving domain da however operators da turned axioms
instead abstract cases build axioms moreover generic abstraction
theory defines abstraction mapping f within framework view


fibergmann wilke

paris system learns useful axioms abstract system composing several

smaller elementary axioms operators however prove formula existence
solution abstract system exactly one axiom case selected deductive
machinery abstract system restricted respect ground space depending
learned abstract cases abstractions paris theory decreasing td
theory increasing ti case base abstract cases completely empty
domain axiom available resulting abstractions consequently td casebase contains maximally abstract case hhtrue truei nop generic abstraction
theory contains clause true case applied every concrete
resulting abstraction consequently ti even maximally abstract case
improve ground level solving included case base
ensure ti property loosing completeness case retrieval mechanism
must however guarantee maximally abstract case chosen refinement
applicable case available note fulfilled retrieval mechanism
sequential search longer shorter plans used experiments
skeletal plans

already mentioned section paris inspired idea skeletal
plans friedland iwasaki abstract cases seen skeletal plan
learning means learn skeletal plans automatically concrete
plans even idea skeletal plans intuitively appealing knowledge
contains first comprehensive experimental support usefulness
skeletal plans since shown skeletal plans acquired automatically
method applied easily
purpose anderson farley kramer unger proposed approaches plan abstraction go direction paris
however automatically forms abstract operators generalization mostly
dropping sentences moreover abstracted plan every concrete operator
abstracted number operators reduced abstraction thereby
abstraction less powerful paris style abstractions
alpine ordered monotonic abstraction hierarchies
alpine knoblock automatically learns hierarchies abstraction

spaces given domain description domain description together mentioned several times alpine relies abstraction dropping
sentences however enables alpine generate abstraction hierarchies automatically
stronger abstraction framework one follow paris automatic
generation abstraction hierarchies abstract domain descriptions seem
realistic due large infinite space possible abstract spaces use powerful abstraction methodology feel pay price losing ability
automatically construct abstraction hierarchy
another point specific property ordered monotonic abstraction hierarchies
generated alpine allows ecient plan refinement refinement ab nop operation operator applicable change abstract state



fibuilding refining abstract cases

stract plan expanded successively lower levels inserting operators furthermore
already established conditions plan guaranteed violated anymore refinement unfortunately kind refinement cannot performed paris style
abstractions especially direct correspondence abstract operators
concrete operators consequently abstract plan cannot extended become
concrete plan however main function abstract plan maintained namely
original decomposed several smaller subproblems causes main
reduction search
explanation learning case reasoning analogy

presented paris uses experience improve solving similar several
approaches machine learning mostly explanation learning mitchell et al
dejong mooney case reasoning kolodner schank althoff wess kolodner analogical solving carbonell veloso
carbonell basic ideas behind explanation learning case
analogical reasoning much related common goal approaches
avoid solving scratch situations already occurred past
explanations e proofs justifications constructed successful solutions already
known system explanation approaches explanations mostly cover
whole solving process fikes hart nilsson mooney kambhampati
kedar relate solving chunks rosenbloom laird
laird rosenbloom newell smaller size even single decisions
within solving process minton minton et al explanation
approaches generalize constructed explanations learning extensive use
available domain knowledge store control rule minton schema
mooney dejong case reasoning systems priar kambhampati
hendler prodigy analogy veloso carbonell veloso cases
usually explicitly generalized advance kept fully instantiated
case library annotated created explanations unlike cases paris
solution pairs cases complete solving episodes containing detailed information decision taken solving
solving cases retrieved contain explanations applicable current kambhampati hendler veloso carbonell veloso detailed
decisions recorded cases replayed modified become solution
current approaches use kind generalization experience
none approaches use idea abstraction speedup solving
experience already noted michalski kodratoff michalski abstraction generalization must confused generalization transforms description
along set superset dimension abstraction transforms description along level detail
dimension
exception given knoblock minton etzioni alpine
abstractions combined ebl component prodigy thereby control rules
learned refer ground space solving abstract
spaces control rules speedup solving abstract level however


fibergmann wilke

control rules guide solver abstract level finds solutions faster
manner finds refinable abstract solutions although
experience kind integration abstraction explanation learning
assume control rules generated ebl component guide
solver towards short abstract solutions cause much reduction search
several circumstances

requirements limitations paris

following summarize requirements limitations paris
main requirements availability good abstract domain description
availability concrete cases
abstract domain

important prerequisite method availability required background knowledge namely concrete world description abstract world description
generic abstraction theory construction system concrete
world descriptions must acquired anyway since specify language description essential sentences solution operators abstract
world generic abstraction theory must acquired feel indeed
price pay make tractable certain practical situations
nevertheless formulation adequate abstract domain theory crucial
success abstract operators missing required express
useful abstract plan speedup achieved need mostly independently
refinable abstract operators operators exist simply represented
abstract domain whole representational power hierarchical
dropping conditions abstract domain must implicitly contained concrete
domain way abstract domain remains certain literals concrete domain
removed see section feel kind modeling much harder
achieve modeling abstract view domain explicitly distinct space
paris additionally requirement abstract domain given user
advantage learned abstract cases expressed terms user
familiar thereby user understand abstract case easily open
additional opportunity involve user process example
selection abstract cases favors
knowledge acquisition shown human experts employ lot
abstract knowledge cope complexity real world specific knowledge acquisition tools developed comfortably acquire abstract
knowledge different sources especially acquisition operators addressed much detail schmidt zickwolff schmidt
availability cases
second prerequisite paris needs concrete cases

solution pairs real world scenario cases usually available company
filing cabinet database according requirement share general view


fibuilding refining abstract cases

machine learning use kind experience promising way cope
highly intractable paris available cases must
somehow representative future solving tasks known cases must similar
enough abstract cases really reused experiments
give strong indications even small set concrete cases training leads high
improvements solving see table

generality achieved

reported experiments performed specific base level solver
performs depth first iterative deepening search strategy korf however
strongly believe paris abstractions beneficial solvers
backward chaining means end analysis nonlinear partial order shown
veloso blythe one optimal strategy different
strategies usually rely different commitments search strategy useful
one domain may worse others however search strategies length
shortest possible solution usually determines amount search required
paris whole search decomposed several subproblems allow
short solutions consequently kind decomposition use
search strategies
moreover think idea reasoning abstract cases formulated
completely terminology ground space useful kinds
solving design model diagnosis model diagnosis
developed pews wess bergmann pews wilke similar
paris domain descriptions consist model technical system
diagnosis found describes behavior elementary composed
component system different levels abstraction model diagnosis
behavior technical system simulated possible faulty component searched
cause observed symptoms abstract cases search reduced
focused onto components already defective similar machines
consequently likely defective situations

future work

future investigate goal directed procedures refinement backwarddirected search non linear partial order planners see section additionally
experience must gained additional domains different representations
furthermore address development highly ecient retrieval
abstract cases table shows retrieval mechanism strong uence
achieved speedup even linear retrieval presented turned pretty
good expect utility minton occur size casebase grows furthermore good selection procedure abstract cases use
feedback solver evaluate learned abstract cases
speedup cause would eliminate unbeneficial cases abstract operators
case base abstract solving domain experiments different indexing
retrieval mechanisms recently indicated possible


fibergmann wilke

furthermore speedup caused combination different approaches
abstraction explanation learning addressed within paris system
explanation component case generalization still present see figure
used experiments plain abstraction evaluated
experiments abstraction explanation learning integration
addressed comprehensively hopefully lead better understanding
different strengths methods
long term goal paris approaches developed
evaluated kinds solving tasks configuration design
already started model diagnosis

appendix proofs

section contains proofs lemma theorems

lemma joining different abstractions concrete domain dc two disjoint abstract domains da da given joint abstract domain da da da
defined follows let da la ea oa ra let da la ea oa ra
da da da la la ea ea oa oa ra ra joint abstract domain
da fulfills following property ca abstraction cc respect dc da
respect dc da ca abstraction cc respect dc da
proof proof lemma quite simple ca abstraction cc respect
dc dai exists sequence abstraction mapping sequence abstraction
mapping required definition easy see abstraction mappings
lead respective case abstraction dc da

lemma multi level hierarchy let dl arbitrary multi level
hierarchy
domain descriptions two level description dc da da l
dc holds ca abstraction cc respect dl ca
abstraction cc respect dc da
proof let c hhs smi case domain intermediate state denoted
sj let c hhs n case domain intermediate state denoted
let c abstraction case c respect sequence
cases c c exists ci domain di ci abstraction
case ci respect di di f g proof induction
c abstraction c respect dc da see figure basis
obvious c abstraction c respect consequently
abstraction respect dc da assume lemma holds cases
domain follows immediately c abstraction c respect
dc da let c hhs k let intermediate states denoted r

definition follows state abstraction mapping sequence abstraction mapping
exists scfi r r r f kg c abstraction c


fibuilding refining abstract cases

























figure abstraction mappings hierarchies abstraction spaces
respect exists state abstraction mapping sequence
abstraction mapping j sj j f mg
define state abstraction mapping sequence abstraction mapping
j j easy see well defined state abstraction mapping
well defined sequence
abstraction mapping k n u v u v
u v furthermore follows scfi j scfi j j saj
leading conclusion c abstraction c respect dc da

theorem correctness completeness pabs complete sldrefutation procedure used pabs case ca abstraction case cc
respect dc da generic theory ca pabs hdc da ai cc
proof

correctness ca returned pabs h oa oak paths holds
phase iv define state abstraction mapping fe jrc eg
together sequence abstraction mapping lead desired conclusion
every operator oai know construction phase iv hfi oai g
holds construction phase iii conclude safi ra preoai holds
consequently e ra preoai holds respective execution body
loop phase iv since e holds monotonic derivation operator
obvious scfi ra preoai furthermore test executed
oai
extension path ensures safi
safi holds together
oai
fulfillment precondition operator scfi
scfi
thus shown ca correct abstraction respect definition
completeness assume case ca hhsa sam oa oam abstraction cc
deductively justified state abstraction mapping exists state ab note refers set finally constructed termination loop use
denote respective set construction loop



fibergmann wilke

oa


scfi
straction mapping sequence abstraction mapping scfi
holds f mg since deductively justified follows construction
phase ii sci sai since monotonic derivation operator preconditon oai fulfilled safi furthermore addlist operator fulfilled
scfi consequently fulfilled sai construction phase iii
guaranteed hfi oai g would phase iv

exists sequence assignments variable paths h
paths h oa paths h oa oam fim ffm paths
fik f kg
ffk sal scl l f ng
ffk skl addoal

proof induction induction basis obvious due initialization
paths variable assume h oa oak fik ffk paths k
state execution phase iv since hfi k k oak g holds
argued k fik k induction hypothesis selected operator sequence
tried extended oa oak body loop additionally
know e contains exactly sentences required proof precondition
oak note since sld resolution procedure assumed complete
oak applicable sck e required proof preconditition oa
e scfi k since deductively justified e e l f mg holds e scfi l
scfi l rc e construction sal e e l f mg holds e scfi l
e sal consequently e sal scl l f mg hand
know oak leads scfi k consequently addoak scfi k following
argumentation conclude addoak sal scl
l f mg consequently ffk e addoak holds sal scl
oa
conclude paths extended oak follows since scfi
scfi
holds addoa safi scfi immediately follow
oa
safi
safi consequently h oa oak oak ffk fik paths
ffk fik fik f kg fik k k
induction hypothesis fulfilled k thereby shown ca returned
pabs

acknowledgements
authors want thank agnar aamodt jaime carbonell padraig cunningham subbarao kambhampati michael richter manuela veloso well members
group many helpful discussions remarks earlier versions particularly want thank padraig cunningham carefully proof reading


fibuilding refining abstract cases

recent version greatly indebted anonymous jair reviewers helped significantly improve partially supported
german sonderforschungsbereich sfb commission european
communities esprit contract p inreca project partners inreca
acknosoft prime contractor france tecinno germany irish medical systems ireland
university kaiserslautern germany

references
althoff k wess case reasoning expert system development
schmalhofer f strube g wetter eds contemporary knowledge engineering amd cognition springer heidelberg
anderson j farly plan abstraction operator generalization
proceedings th international conference artifical intelligence pp
san mateo morgan kaufmann
bacchus f yang q downward refinement eciency hierarchical
solving artificial intelligence
bergmann r knowledge acquisition generating skeletal plans schmalhofer f strube g wetter eds contemporary knowledge engineering
cognition pp heidelberg springer
bergmann r b learning abstract plans speed hierarchical
tadepalli p ed proceedings ml workshop knowledge compilation
speedup learning university aberdeen scotland
bergmann r c learning plan abstractions ohlbach h ed gwai th
german workshop artificial intelligence vol springer lecture notes
ai pp
bergmann r integrating abstraction explanation learning multiple
examples hierarchical clustering performance component
plaza e ed proceedings ecml workshop integrated learning
architectures ila vienna austria
bergmann r pews g wilke w explanation similarity unifying
integrating domain knowledge case reasoning richter
wess althoff k maurer f eds topics case reasoning vol
lecture notes artificial intelligence pp springer
bergmann r wilke w inkrementelles lernen von abstraktionshierarchien
aus maschinell abstrahierten planen fensel nakhaeizadeh g eds
proceedings workshop maschinelles lernen theoretische ansatze und anwendungsaspekte institut fur angewandte informatik und formale beschreibungsverfahren university karlsruhe germany


fibergmann wilke

blythe j etzioni et al prodigy manual tutorial tech rep
cmu cs carnegie mellon university pittsburgh pa
carbonell j g derivational analogy theory reconstructive solving
expertise aquisition michalski r carbonell j g mitchell
eds machine learning artificial intelligence vol chap pp
morgan kaufmann los altos ca
dejong g mooney r explanation learning alternative view machine learning
etzioni structural theory explanation learning artificial intelligence

etzioni etzioni r statistical methods analyzing speedup learning
machine learning
fikes r e hart p e nilsson n j learning executing generalized robot
plans artificial intelligence
fikes r e nilsson n j strips application theorem
proving solving artificial intelligence
friedland p e iwasaki concept implementation skeletal plans
journal automated reasoning
giordana roverso saitta l abstracting background knowledge
concept learning kodratoff ed proceedings european working session
learning ewsl lecture notes artificial intelligence pp berlin
springer
giunchiglia f walsh theory abstraction artificial intelligence

green c application theorem proving solving proceedings
ijcai pp washington dc
holte r drummond c perez zimmer r macdonald searching
abstractions unifying framework high performance
proceedings th canadian conference artificial intelligence pp
morgan kaufmann publishers
holte r mkadmi zimmer r macdonald speeding solving
abstraction graph oriented tech rep tr computer science
dept university ottawa ontario canada
kambhampati hendler j validation structure theory plan
modification reuse artificial intelligence


fibuilding refining abstract cases

kambhampati kedar unified framework explanation generalization partially ordered partially instantiated plans artificial intelligence

knoblock c theory abstraction hierachical proceedings
workshop change representation inductive bias pp boston
kluwer
knoblock c learning abstraction hierarchies solving proceedings
eighth national conference artificial intelligence vol pp london
mit press
knoblock c search reduction hierarchical solving proceedings
th national conference artificial intelligence vol pp anaheim
ca
knoblock c generating abstraction hierarchies automated
reducing search kluwer academic publishers
knoblock c automatically generating abstractions artificial
intelligence
knoblock c minton etzioni integrating abstraction
explanation learning prodigy proceedings th national conference artificial intelligence vol pp anaheim ca
knoblock c tenenberg j yang q b characterizing abstraction hierarchies proceedings th national conference artificial
intelligence vol pp anaheim ca
kolodner j l retrieval organizational strategies conceptual memory
ph thesis yale university
kolodner j l case reasoning morgan kaufmann
korf r e toward model representation changes artifical intelligence

korf r e depth first iterative deepening optimal admissible tree search
artifical intelligence
korf r e b macro operators weak method learning artifical intelligence

korf r e search quantitative artifical intelligence

korf r e linear space best first search artifical intelligence


fibergmann wilke

kramer unger c abstracting operators hierarchical
hendler j ed proceedings international conference ai pp
morgan kaufmann
laird j rosenbloom p newell universal subgoaling chunking
automatic generation learning goal hierarchies kluwer academic publishers norwell
langley p allen j unified framework learning minton
ed machine learning methods chap pp morgan
kaufmann
lifschitz v semantics strips reasoning actions plans
proceedings workshop pp timberline oregon
lloyd j foundations logic programming springer
mcallester rosenblitt systematic nonlinear proceedings
th national conference artificial intelligence pp
michalski r inferential theory learning conceptual basis multistrategy
learning michalski r tecuci g eds machine learning multistrategy
chap pp morgan kaufmann
michalski r kodratoff machine learning recent progress
classification methods future directions kodratoff michalski r
eds machine learning artificial intelligence vol chap pp
morgan kaufmann san mateo ca
minton learning search control knowledge explanation
kluwer boston
minton quantitativ concerning utility explanation learning
artifical intelligence
minton carbonell j g knoblock c kuokka r etzioni gil
explanation learning solving perspective artificial intelligence

minton zweben learning scheduling overview
minton ed machine learning methods chap pp morgan
kaufmann
mitchell keller r kedar cabelli explanation generalization unifying view machine learning
mooney r j generalizing order operators macro operators laird
j ed proceedings th international conference machine learning pp
san mateo ca morgan kaufmann


fibuilding refining abstract cases

mooney r j dejong g f learning schemata natural language processing
proceedings ijcai pp los angeles ca
mozetic abstraction model diagnosis aaai workshop automatic
generation approximations abstractions pp boston
newell simon h human solving prentice hall englewood cliffs
nj
paulokat j wess machining workpieces partial order
nonlinear planner aaai fall symposium learning real
applications
perez carbonell j automated acquisition control knowledge improve
quality plans tech rep cmu cs carnegie mellon university
pews g wess combining model approaches case reasoning
similarity assessment case adaptation diagnositc applications richter
wess althoff k maurer f eds preprints first european
workshop case reasoning ewcbr vol ii pp university
kaiserslautern germany
plaisted theorem proving abstraction artifical intelligence
plaisted abstraction generalization functions proceedings th
conference automated deduction vol pp
rosenbloom p laird j mapping explanation learning onto soar
proceedings national conference artificial intelligence vol philadelphia pa
sacerdoti e hierarchy abstraction spaces artificial intelligence

sacerdoti e structure plans behavior vol american elsevier
york
schank r c dynamic memory theory learning computers people
cambridge university press york
schmidt g modellbasierte interaktive wissensakquisition und dokumentation von
domaenenwissen ph thesis university kaiserslautern germany
schmidt g zickwolff cases integrated knowledge acquisition
formalize operators manufacturing proceedings th knowledge acquisition
knowledge systems workshop banff
shavlik j rorke p empirically evluation ebl investigating explanationbased learning vol chap pp kluwer academic publishers
simon h functional equivalence solving skills cognitive psychology



fibergmann wilke

tenenberg j preserving consistency across abstraction mappings mcdermott
j ed proceedings th international conference artifical intelligence
pp los altos ca morgan kaufmann
tenenberg j abstraction ph thesis computer science department
university rochester york
unruh rosenbloom p abstraction solving learning
proceedings international joint conference artifical intelligence pp
detroit mi morgan kaufmann
veloso learning analogical reasoning general solving ph
thesis carnegie mellon university pittsburgh pa
veloso prodigy analogy analogical reasoning general
solving richer wess althoff k maurer f eds topics casebased reasoning pp lecture notes ai vol springer
veloso blythe j linkability examining causal link commitments
partial order proceedings nd international conference
ai systems aips
veloso carbonell j g integrating derivational analogy general
solving architecture minton ed proceedings first workshop
case reasoning morgan kaufmann
veloso carbonell j g towards scaling machine learning case
study derivational analogy prodigy minton ed machine learning
methods chap pp morgan kaufmann
wilke w entwurf und implementierung eines algorithmus zum wissensintensiven
lernen von planabstraktionen nach der pabs methode projektarbeit universitat
kaiserslautern
wilke w entwurf implementierung und experimentelle bewertung von
auswahlverfahren fur abstrakte plane im fallbasierten planungssystem paris master thesis university kaiserslautern germany
wilkins practical extending classical ai paradigm
morgan kaufmann
yang q tenenberg j abtweak abstracting nonlinear least commitment
planner proceedings th national conference aritificial intelligence pp
boston




