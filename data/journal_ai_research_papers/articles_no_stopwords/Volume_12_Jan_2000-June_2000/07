journal artificial intelligence

submitted published

reasonable forced goal orderings use
agenda driven

jana koehler ch schindler com

jana koehler
schindler lifts ltd
r technology management
ebikon switzerland
jorg hoffmann
institute computer science
albert ludwigs university
georges kohler allee geb
freiburg germany

hoffmann informatik uni freiburg de

abstract

addresses computing goal orderings one
longstanding issues ai makes two contributions first formally
defines discusses two different goal orderings called reasonable
forced ordering orderings defined simple strips operators well
complex adl operators supporting negation conditional effects complexity
orderings investigated practical relevance discussed secondly two
different methods compute reasonable goal orderings developed one
graphs investigates set actions directly finally
shown ordering relations derived given set goals
g used compute called goal agenda divides g ordered set
subgoals planner principle use goal agenda plan increasing
sets subgoals lead exponential complexity reduction solution
complex found solving easier subproblems since polynomial
overhead caused goal agenda computation potential exists dramatically speed
demonstrate empirical evaluation use
method ipp planner
introduction

effectively plan interdependent subgoals focus ai
long time starting early work abstrips sacerdoti
conjunctive goal chapman quite number approaches
presented complexity studied today
planners made progress solving bigger instances scalability
classical systems still
focus following given set conjunctive goals
define detect ordering relation subsets original goal set arrive
ordering relation subsets first focus atomic facts contained
goal set formally define two closely related ordering relations atomic goals
c ai access foundation morgan kaufmann publishers rights reserved

fikoehler hoffmann
call reasonable forced ordering study complexity turns
hard decide
consequently introduce two ecient methods used approximate
reasonable goal orderings definitions first given simple strips domains
desired theoretical properties easily proven afterwards extend definitions
adl operators pednault handling conditional effects negative preconditions
discuss invest effort trying forced orderings
set ordering relations atomic goals used divide
goal set disjunct subsets subsets ordered respect
resulting sequence subsets comprises called goal agenda
used control agenda driven
method called goal agenda manager implemented context ipp
system potential exponentially reducing computation times
certain domains
organized follows section introduces motivates reasonable
forced goal orderings starting simple strips operators formally defined
complexity investigated section present two methods compute approximation reasonable ordering discuss orderings
practical point view section concludes extension definitions adl
operators conditional effects section shows system benefit
ordering information computing goal agenda guides planner define
subsets goals ordered respect discuss goal
agenda affect theoretical properties particular completeness
section contains empirical evaluation work showing
obtained goal agenda ipp section summarize light
related work concludes outlook possible future directions
section
ordering relations atomic goals

start investigate simple strips domains allowing sets atoms
describe states preconditions add delete lists operators
definition state set ground atoms denoted p state
p

subset ground atoms

note states assumed complete e know atom p whether
p p holds assume operator schemata ground e
talk actions
definition strips action strips action usual form
pre add add del del
pre preconditions add add list del delete
list action set ground atoms assume del add
applying strips action state defined usual


fion reasonable forced goal orderings





add n del pre
otherwise



pre holds action said applicable applying
sequence one action state recursively defined
ho

ho
definition g triple
set actions initial state g goals sets ground atoms
plan p ordered sequence actions actions plan taken certain
action set denote writing p
n

n

n

note define plan sequence actions sequence parallel steps
done graphplan blum furst example makes subsequent
theoretical investigation readable directly carry parallel plans
given two atomic goals b ways define ordering relation
imagined first one distinguish domain specific domainindependent goal ordering relations although domain specific orderings
effective need redeveloped single domain therefore one particular
interested domain independent ordering relations broader range applicability
secondly following hullem et al one distinguish goal selection goal
achievement order first ordering determines order planner works
atomic goals second one determines order solution
plan achieves goals compute ordering latter type
agenda driven propose later orderings
coincide anyway goals achieved first plan planner
works first
following scenario motivates achievement order goals possibly
defined given two atomic goals b solution plan exists let us assume
planner achieved goal e arrived state
holds b hold yet exists plan executable
achieves b without ever deleting solution found plan
found two possible reasons exist
unsolvable achieving first leads planner deadlock situation thus planner forced achieve b simultaneously
existing solution plans destroy temporarily order achieve b
achieved first instead seems reasonable achieve
b simultaneously sake shorter solution plans
first situation ordering b simultaneously forced inherent properties domain second situation ordering b
simultaneously appears reasonable order avoid non optimal plans consequently define two goal orderings called forced reasonable ordering
sake clarity first give basic definitions


b





b

fikoehler hoffmann
definition reachable state let g let p

set ground atoms occur say state p reachable iff
exists sequence ho actions ho
holds
n

n

definition generic state let g


b



b



denote reachable state achieved b false
e b sequence actions ho
ho add


n

b

n



b

n

one imagine state incomplete information
states represents satisfy j b atoms p p p b
adopt arbitrary truth values
definition reduced action set let g let


b



g atomic goal denote set actions delete
e fo j del g




prepared define exactly mean forced reasonable goal orderings
definition forced ordering let g let b
g two atomic goals say forced ordering b written
f

b
f

p b p
definition satisfied plan achieving b must achieve b
simultaneously otherwise encounter deadlock rendering
unsolvable
definition reasonable ordering let g let
b g two atomic goals say reasonable ordering b







b





b

r

written b
r

p oa b p oa
definition gives b meaning goal achieved


b



b

r

plan anymore achieves b without least temporarily destroying b
goal prior
remark obviously b implies b vice versa make
slightly less obvious observation point formulae definitions use
universal quantification states
state formulae satisfied goals b get ordered e b
b follow respectively case however much information gained
goal ordering b sequence actions achieve b prior
simultaneously cannot achieved b still false thus
case ordering relations b b trivial sense reasonable
planner would invest much effort considering goals b ordered way
round anyway
r

f



b

f

r

f

r



fion reasonable forced goal orderings
definition trivial ordering relation let g let
b g two atomic goals ordering relation b
state




f

b called
r

trivial iff

b

usually consider forced reasonable goal orderings non trivial
orderings make distinction explicit
definitions seem deliver promising candidates achievement order
unfortunately hard test turns corresponding decision
pspace hard
theorem let f order denote following

given two atomic facts b well action set initial state
b hold
f

deciding f order pspace hard

proof proof proceeds polynomially reducing

plansat bylander
decision whether exists solution plan given arbitrary strips
instance deciding f order

let g denote initial state goal state action set arbitrary
strips instance let b c atomic facts contained instance
far build action set initial state f order instance setting











g


add fag del fc g
add del fag
add fb g del

fc g
fag
g



fc g
definitions reaching b equivalent solving original
way round unreachability b forced ordering b equivalent
unsolvability original order prove consider following
way achieving applying consequently state
fag cf definition thus starting assumption b valid apply
following equivalences
f





b

f

b
f






p b p
cf definition


p b fag p
fag reachable state
p g p
definition
solution plan exists g given


b



b





b

fikoehler hoffmann
thus complement plansat polynomially reduced f order pspace
co pspace done
theorem let r order denote following

given two atomic facts b well action set initial state
b hold
deciding r order pspace hard
r

proof proof proceeds polynomially reducing plansat r order

let g initial state goal state action set arbitrary
strips instance let b c atomic facts contained
instance far define action set setting


fc g
add fa dg del fc g

fa dg add del fdg

g
add fb g del



g

initial state

fc g

proof theorem intention behind definitions make solvability
original equivalent reachability b reasonable orderings
reachability concerned actions delete need safety
condition
precisely way achieve applying e per definition
state fa dg action operator set deletes
following sequence equivalences




b

b
p oa b p oa
p oa b fa dg p oa
r



p b fa dg p
p g p
solution plan exists g


b



b

cf definition

fa dg reachable state
action deletes
definition


b

thus complement plansat polynomially reduced r order
pspace co pspace done
consequently finding reasonable forced ordering relations atomic goals
already hard original appears unlikely planner
gain advantage possible way dilemma define
ordering relations decided polynomial time ideally sucient
existence reasonable forced goal orderings following introduce two
orderings




fion reasonable forced goal orderings
computation goal orderings

section
define goal ordering computed graphplan exclusivity
information facts prove ordering sucient
decided polynomial time subscript e stands ecient
define goal ordering computed heuristic method
much faster computation graphplan delivers powerful
goal ordering information subscript h stands heuristic
discuss currently available benchmark domains contain forced orderings e fail providing decomposition
orderings extended handle expressive adl operators
e

r

h

f

reasonable goal orderings graphplan

goal ordering computed specific involving initial
state goal set g fa b g set ground actions order develop
ecient computational method proceed two steps
compute knowledge generic state
define relation investigate theoretical properties particular
prove implies


b

e

e

r

state represents states reachable
achieved b hold given information one derive
additional knowledge particular possible determine subset atoms f
one definitely knows f must hold one method determine f
obtained via computation invariants e logical formulae hold reachable
states cf fox long determined invariants one assumes
holds b computes logical implications another possibility
simply use graphplan blum furst starting graph
built graph leveled time step proposition level time
step represents set states superset states reachable
applying actions atoms marked mutually exclusive blum
furst level never hold state satisfying thus cannot
hold denote set f false set respect returned

graphplan
f
fp j p exclusive graph leveled offg

note graph grown given used
determine f sets atomic goals g


b







b

b


gp

b


gp



gp

assume reader familiar graphplan system well known
community otherwise blum furst provide necessary background



fikoehler hoffmann

holds states
actions
lemma



fgp





satisfying reachable


proof follows immediately definitions level two propositions
mutual exclusive given blum furst
provide simple test sucient existence reasonable ordering
b two atomic goals b
definition ecient ordering let g fa b g
r

e

let f



gp

false set ordering b holds
e

b add pre f

gp



means b ordered reduced action set contains actions
b add lists require precondition
contained false set preconditions never hold state satisfying
thus actions never applicable
theorem
b b
e

r

proof assume b e b p oa reachable state
r



b



b



b plan p oa ho n
del definition
ho n
lemma
f
ho n

furthermore b b ho must
step makes b true e
k n b ho b ho
step obviously b add consequently definition
b pre f must applicable state
executed otherwise would add anything state preconditions
must hold e pre ho immediately leads f
ho contradiction equation
quite obviously ordering decided polynomial time


b



n

b











b





gp





b

b





n

b

k

b



b

k

k

e


gp

k

k

k

k



b




gp

k

b

k

e

theorem let e order denote following

given two atomic facts b well initial state action set

b hold
e

e order decided polynomial time


e order

p

fion reasonable forced goal orderings
proof begin need computing f

takes polynomial time
blum furst follows directly building graph
polynomial jij joj l l maximal length precondition add
delete list action number time steps built taking l parameter
input size remains graph levels polynomial
number time steps graph leveled time steps
neither set facts number exclusion relations change
two subsequent time steps set facts increase facts already occuring
graph remain number exclusions decrease non exclusive facts
non exclusive subsequent layers thus maximal number time steps
built graph leveled dominated maximal number changes
occur two subsequent layers dominated maximal number
facts plus maximal number exclusion relations maximal number facts
jij joj l maximal number exclusions jij joj l square
maximal number facts
computed f polynomial time testing b involves looking actions
rejecting
delete decidable time l
precondition element f decidable time l jij joj l
thus additional runtime test joj l jij joj l

gp


gp

e


gp

let us consider following example illustrates computation
common representational variant blocks world actions stack unstack
pickup putdown blocks
e

pickup ob

clear ob table ob arm empty

add holding ob

del clear ob table ob arm empty

putdown ob
holding ob

add clear ob arm empty table ob
del holding ob

stack ob underob

clear underob holding ob

unstack ob underob

add arm empty clear ob ob underob
del clear underob holding ob

ob underob clear ob arm empty

add holding ob clear underob

del ob underob clear ob arm empty

given simple task stacking three blocks
initial state table table b table c
goal state b b c


fikoehler hoffmann
reasonable ordering two atomic goals intuitively blocks world
domain possesses natural goal ordering namely planner start building
tower bottom top way round
let us first investigate whether relation b b c holds vividly speaking
asks whether still possible stack block b b c achieved
first step run graphplan atoms exclusive b c
graph corresponds leveled
e





b c

fgp

fclear c table b holding c holding b c c b b g

one observes immediately atoms never true state satisfies

b c

secondly remove ground actions delete b c case action

ready test b b c holds action add
b stack b preconditions holding clear b neither
member f test fails get b b c
next step test whether b c b holds graphplan returns
following false set

unstack b c satisfies condition obtain reduced action set

b c

e

b c

e

gp

e





b

fgp

fclear b table holding b holding c c b b g

action unstack b contained deletes b
action adds b c stack b c needs preconditions clear c
holding b second precondition holding b contained set false facts
e holding b f thus conclude b c b altogether
b b c b c b correctly ects intuition b
needs stacked onto c stacked onto b
although appears impose strict conditions domain order derive
reasonable goal ordering succeeds finding reasonable goal orderings available test
domains orderings exists example tyreworld bulldozer
shopping russel norvig fridgeworld glass domain
tower hanoi domain link world woodshop disadvantage
computational resources requires since building graphs theoretically
polynomial quite time memory consuming thing
therefore next section presents fast heuristic computation goal orderings
analyzes domain actions directly need build graphs anymore
b

b

e

gp

e

e

e

note goals specify block c go leave planner
recent implementations graphs example developed stan fox
long ipp koehler build graphs explicitly anymore orders
magnitude faster original graphplan implementation still computation
graph takes almost time needed determine e relations



fion reasonable forced goal orderings
reasonable goal orderings derived fast heuristic method

one analyze available actions directly method call direct analysis
da determines initial value f computing intersection delete lists
actions contain add list defined following equation


fda











del



add

atoms set false state achieved
deleted state description independently action used add
short example let us consider two actions

add fag del fc dg
add fa c g del fdg
atom deleted actions thus element initially
contained f
however equation says added atoms f
deleted say anything whether might possible reestablish atoms
f one easily imagine actions exist leave true
time add atoms case reachable states atoms
f hold
goal derive ordering relation easily computed
ideally relation sucient relation therefore want make
sure atoms f really false state achieved
arrive approximation atoms remain false performing fixpoint reduction
f set removing atoms achievable following sense

da


da


da


da

e

r



da



da

definition achievable atoms atom p achievable state given
action set written p
p

p add p pre p

definition says atom p achievable state holds
exists action domain adds p whose preconditions achievable
necessary condition existence plan p state
p holds
lemma p p p p
proof atom p must already contained state added

step p second case preconditions need established
p way thus p preconditions step adds achievable
sense definition


fikoehler hoffmann
two obvious diculties definition first p must tested
complete knowledge state cause case
however generic state cannot decide whether arbitrary
atom contained secondly observe infinite regression preconditions
must tested achievability
first turns good heuristic simply assume p
e test performed second order avoid infinite
looping achievable test one needs terminate regression preconditions
particular level point question far regress quick approximation
simply decides achievable first recursive call


b

definition possibly achievable atoms atom p possibly achievable given
action set written pa p
p add p pre

p add

holds e action adds p preconditions add effects
actions

assumption justified none atoms p contained state
possibly achievable necessary condition achievable
lemma let state p p add pre

holds

p pa p
proof p p know step p add

p pre p know pre p pre
must achiever p add

condition facts p must contained state seems
rather rigid nevertheless condition possibly achievable delivers good
benchmark domains easy decide use test

perform fixpoint reduction set f
decide whether atomic goal b ordered

da

fixpoint reduction depicted figure uses approximative test pa f
remove facts f achieved finds facts certain
restrictions see side effect fixpoint obtain set
actions method assumes applicable state order b
iff cannot possibly achieved actions

da





b

fion reasonable forced goal orderings
f
n fo j f pre g
fixpoint reached false
fixpoint reached
fixpoint reached true
f f
pa f


f f n g
n fo j f pre g
fixpoint reached false
f



da




endif
endfor
endwhile
return f

figure quick heuristic fixpoint reduction set f

da

computation checks whether atoms f initially set f possibly
achievable actions delete require atoms
f precondition achievable atoms removed f gets updated
accordingly one iteration f change fixpoint reached e f
decrease increase final sets f false facts
applicable actions returned
let us illustrate fixpoint computation short example consisting empty
initial state goals fa b g following set actions


da

op
op
op f c g
op f g






add f g
add fa c g
add f g
add f b g

del f c g
del f g

assuming achieved obtain f f fdg initial
value false set since atom op op delete adding
figure illustrates hypothetical process starting empty initial state
trying achieve first get two different states holds
atom hold thus states action applicable
requires precondition excludes op yielding initial action set
fop op op g op action add b therefore used
action set see b still achieved would case
consequently without performing fixpoint computation would order b
seen figure would reasonable ordering plan
hop op achieves b state op without destroying
fixpoint computation works us around follows action op add precondition op without deleting checking
pa first iteration fixpoint procedure finds action checks


da









b

b

fikoehler hoffmann
whether preconditions op achievable sense added another action case since precondition c added op thus
removed f becomes empty action op put back set
becomes identical action set set turn identical
original action set action deletes fixpoint process terminates b
ordered achieved action op correctly ects
fact exists plan state hop fc ag
state satisfies b without destroying




b



deadlock

op

op



c
op
c

holds state satisfying

op
c b

plan b

figure example illustrating need fixpoint computation
already pointed intention behind fixpoint procedure following
starting state want know facts become true without
destroying consequently actions become applicable first step
actions use facts f applicable facts
deleted state description added however actions may make facts
f true want remove facts f manage facts
made true without destroying final set f contain
facts hold state reachable without destroying case
final action set contain actions applied
safely use action set determine whether another goal b still achieved

however use approximative test pa f f f
fact current f set achievable may facts achievable without
destroying remain set f could exclude actions set
safely applied certain restrictions however
prove happen order need impose restriction
particular state achieved goal none preconditions
actions add facts contained f occur state fixpoint
procedure remove facts f achievable without destroying
use property fixpoint procedure later heuristic ordering relation
approximates reasonable orderings


b



da


da


da



b







b

b


da





da



b

b

fion reasonable forced goal orderings
lemma let g let g atomic goal let
reachable state achieved let p oa ho
sequence actions destroying let f set facts returned
fixpoint computation depicted figure


n

b

f f


da

f add pre






b

fact f holds state reached applying p oa e
p oa f


b

proof

let f denote state fact action sets respectively j iterations
depicted figure f decreases computation


f f j let denote sequence states encountered
executing p oa ho e ho
n assume action applicable state e pre
otherwise cause state transition skip p oa obviously
p oa need f proof proceeds
induction length n p oa
n p oa hi facts f deleted state
description added f f f f f
proposition follows immediately
n n p oa ho induction hypothesis know
f n need sf
let j step fixpoint iteration f becomes empty e j
denotes iteration intersection states n f empty
first time iteration exists intersections f n
empty
action n applicable state e pre
thus pre f actions p oa therefore actions contained
set contains actions whose intersection f empty
let us focus facts state facts achieved executing p oa
words plan facts
seen plan consists actions applying lemma facts p
p oa p oj know facts p achievable actions

j

j

n

j

n



b





b















n



n

b

n




da

b

n

n





da

da

n



n

j



n





j















j



j

j

n



b



b

n

j



b

j

p
facts f interested namely f facts
added still contained f possibly achievable actions
let f fact f f f apply lemma f

p



n



b

j

n

n

j

j

n

j





b

fikoehler hoffmann

apply lemma obviously f f add
pre prerequisite p arrive
f f pa f


j



b



n

b

j

b

j

j

j

remains proven facts f removed f
fixpoint computation argumentation sucient
facts f f get tested pa f iteration j fixpoint computation
tests succeed lead f yielding desired f
remember f f two cases need consider
j intersections f initially empty e f n
case facts f f tested pa f iteration j
fixpoint computation
j case least one intersections f became empty iteration
j definition j e least one fact removed f iteration
therefore fixpoint reached yet computation performs
least one iteration namely iteration j facts f tested
iteration particular facts f f
observations induction complete proposition proven
already said simply order b possibly achievable
action set resulted fixpoint computation ordering relation
h stands heuristic obtained way approximates reasonable goal
ordering
definition heuristic ordering let g fa b g
n

j

j

n

n

j

j



n





da


da



j

j

n

j

h

r

let set actions obtained performing fixpoint computation
shown figure
ordering b holds
pa b
h

h

reached particular state assumptions made
fixpoint computation test pa b justified possibly achievable sucient condition non existence plan b
temporarily destroy
theorem let g let b g two atomic goals let


b

reachable state achieved b still false e b
let f sets facts actions respectively derived
fixpoint computation shown figure


b



b

f f fb g f add pre


da





pa b p oa





b

b p oa





b







fion reasonable forced goal orderings
proof assume plan p oa ho destroy
n

achieves b e b ho restriction
facts f lemma applied action sequence ho yielding
ho f consequently
applicable ho
preconditions contained ho yielding pre

f
first case simply skip effects second case
follows thus plan constructed actions achieves b
applying lemma leads us b b
know respect b b add
pre holds therefore apply lemma arrive pa b
contradiction
return blocks world example computation proceeds
let us first investigate whether b b c holds initial value f
obtained delete list stack b c action one adds
goal


n

b





da



b









b





b









b



b



b





b

h

b c

h

da

fclear c holding b g
intuitively immediately clear neither facts ever hold state
b c true b c c clear gripper cannot hold b
turns fixpoint computation respects intuition leaves set f
unchanged yielding f fclear c holding b g repeat fixpoint process
detail reconstructed figure details necessary
understanding correct ordering relations derived short facts
achievers reduced action set need preconditions
achiever available example holding b achieved unstack
pickup action need b stand another block stand table
actions achieve facts need holding b true thus excluded
reduced action set
finishing fixpoint computation planner tests pa b
contains actions except delete b c use clear c holding b
precondition finds action stack b adds b preconditions
action holding clear b conditions added actions
pickup unstack b respectively contained neither
needs c clear b gripper thus test finds fact b
possibly achievable actions ordering derived e b
b c follows
way round b c b tested initial value f
obtained single action stack b

fclear b holding g
f




b c

fda

b c
da

h

b

h

da

b
da



fikoehler hoffmann
fixpoint computation cause changes resulting f fclear b
holding g process tests whether pa b c holds contains
actions except delete b use clear b holding
precondition action add b c stack b c action needs
preconditions facts holding b clear c process finds crucial
condition achieving first fact violated action achieve holding b
clear b precondition b must clear first gripper hold
since clear b element f none actions achieving holding b contained
consequently test pa b c fails obtain ordering b c
b makes sense gripper cannot grasp b stack onto c anymore
b achieved
h

forced goal orderings invertible

far introduced two easily computable ordering relations
approximate reasonable goal ordering one might wonder invest
effort trying forced goal orderings two reasons
h

e

r

already seen section forced goal ordering reasonable
goal ordering e method approximates latter used crude
approximation former
many benchmark invertible certain sense
contain forced orderings anyway
section elaborate detail second argument bit
general necessary point want make use later
agenda driven propose complete respect certain class
proceed formally defining class
contain forced orderings identify sucient criterion
membership class finally demonstrate many benchmark
fact satisfy criterion start introduce notion
deadlock
definition deadlock let g reachable state
called deadlock iff sequence actions leads goal e iff


p p g p

class interested class

deadlock free naturally called deadlock free none reachable states

deadlock sense definition
non trivial forced goal orderings imply existence deadlocks remember
ordering b b called trivial iff state
f

r



b

lemma let g let b g two atomic goals
non trivial forced ordering b b exists deadlock
state
f



fion reasonable forced goal orderings
proof recalling definition assuming non triviality know
least one state made true b still false definition
know plan state achieves b particular
possible achieve goals starting thus state must
deadlock
f



b



b



b

investigate deadlocks detail discuss commonly
used benchmark contain e deadlock free lemma
know domains contain non trivial forced goal orderings
much point trying care trivial goal
orderings orderings force reasonable consider goals
correct order
existence deadlocks depends structural properties
must action sequences executed lead states goals
cannot reached anymore sequences must undesired effects cannot
inverted sequence actions changing perspective one obtains hint
sucient condition non existence deadlocks might defined assume
effects action sequence domain
inverted executing certain sequence actions invertible
particular possible get back initial state reachable state
therefore solvable contain deadlocks state
one reach goals going back initial state first execute arbitrary
solution thereafter formally define notion invertible
turn argumentation proof
definition invertible let g
let denote states reachable actions called

invertible

po po

p p



theorem let g invertible solution exists
g contain deadlocks

proof let p arbitrary reachable state invert

ible know sequence actions p p holds
solvable solution plan p starting achieving
g p together obtain g p p therefore
concatenation p p solution plan executable consequently
deadlock










know invertible solvable contain deadlocks
consequently contain non trivial forced goal orderings see next
matter fact benchmark invertible arrive
sucient condition invertibility notion inverse actions


fikoehler hoffmann
definition inverse action given action set containing action
form pre add del action called inverse
form pre add del satisfies following conditions
pre pre add n del
add del
del add

certain conditions applying inverse action leads back state one started

lemma let state action applicable del pre

add hold action inverse sense definition
applicable hoi hoi hoi follows

proof applicable pre atoms add added

atoms del removed altogether

hoi pre add n del pre

thus applicable hoi
furthermore hoi add n del
hoi hoi
add n del hoi
add n del add n del
add n del del n add
cf definition
add n add
del pre

add
lemma states two prerequisites inclusion operator delete list preconditions empty intersection operator add list state
applicable called invertible meets prerequisites
inverse action
theorem given g set ground actions satisfying

del pre pre add actions reachable states
inverse action action invertible

proof let reachable state let p ho sequence actions

need existence sequence p



n

p p




fion reasonable forced goal orderings
holds define p ho prove induction n

n p p hi hi hi obvious
n n p ho induction hypothesis know
ho ho make following bit readable
let denote ho
n

n

n

n

n

n

ho ho
ho ho
ho ho ho
ho

n

n






n

n

n

n

n

n

cf lemma
per induction
n

altogether know invertible solvable contain forced
orderings know inverse action action
invertible following theorem theorem requires del pre hold
action pre add hold actions reachable states
see conditions inclusion delete list precondition list b
empty intersection action add list reachable states applicable
c existence inverse actions hold currently used benchmark domains
concerning condition actions delete facts require preconditions one finds phenomenon domains commonly used
community least known authors something seems
hold reasonable logical formulation authors even postulate
assumption work cf fox long
similarly case conditions b c one usually finds inverse actions
benchmark domains action preconditions usually imply state invariants
add effects false example blocks world stack unstack
actions invert action add effects exclusive preconditions
former contained union false constructed preconditions see
section similarly domains deal logistics example logistics
trains ferry gripper etc one often inverse pairs actions preconditions
excluding add effects sometimes two different ground instances
operator schema yield inverse pair example gripper two ground instances
move rooma roomb
robby rooma

add robby roomb del robby rooma


order avoid reasoning reachable states condition b one could postulate
action add effects negative preconditions cf jonsson haslum backstrom
however commonly used typical benchmark



fikoehler hoffmann
move roomb rooma
robby roomb

add robby rooma del robby roomb

move operator schema invert similarly towers hanoi
single move operator schema inverse instance found
ground instance schema add effects false
preconditions true
rarely non invertible actions found benchmark domains
occur role domain often quite limited example operators cuss
ate russel tyreworld
cuss

del annoyed

ate x wheel

pump ated x intact x

add ated x del ated x

obviously much point defining something decuss de ate
operator formally speaking none ground actions operators destroys
goal precondition action domain therefore matter
effects cannot inverted particular forced goal ordering derived
wrt actions
importance inverse actions real world domains discussed
nayak williams describe planner burton controlling cassini
spacecraft contrast domains example used
barrett et al almost never contain inverse actions consequently domains
plenty forced goal orderings could discovered used planner avoid deadlock
situations widespread although perhaps unconscious use invertible
benchmarking current phenomenon related strips descending systems
one anonymous reviewers pointed us quite number non invertible
proposed literature e g register assignment
nilsson robot crossing road sanborn hendler
instances manufacturing regli gupta nau yale shooting
mcdermott hanks e
invertible one could spirit argument beginning section
simply use approximate forced orderings one interested finding least
precisely methods might detect forced orderings
reasonable might necessarily forced orderings
one interested finding forced orderings possible way go
example simple blocks world modification blocks cannot unstacked anymore
stacked forces planner build stacks bottom
still capable finding correct goal orderings
e

h

e

h

e

h

cuss operator way one known authors deletes fact
precondition one know could removed domain description
without changing anything



fion reasonable forced goal orderings
extension goal orderings adl actions

orderings introduced far easily extended deal
ground adl actions conditional effects negation instead delete lists
actions following syntactic structure
pre eff
eff
pre eff
eff


pre eff eff
unconditional elements action summarized precondition
action denoted pre unconditional positive negative effects
eff eff respectively conditional effect consists effect
condition antecedent pre positive negative effects eff eff
additionally denote set unconditional conditional effects
e f g
computation immediately carries adl actions extension
graphs used handle conditional effects e g ipp koehler nebel
hoffmann dimopoulos sgp anderson weld one simply takes
set exclusive facts returned systems determine set f test
definition decides whether ordering b two atomic goals
b extended adl follows
n

n

n

n









n

e



gp

e

definition ordering adl let g fa b g
e

false set ordering b holds

let f



e

gp

b eff pre pre f







gp



denotes negative effects implied conditions







eff
eff





pre

j prei effj



thus b ordered unconditional conditional effects add b
imply effect deletes need conditions cannot made true together
note effect requires conditions pre pre satisfied
impossible state holds non empty intersection
f

computation requires little adaptation effort order obtain
set f need investigate conditional effects well action
conditional unconditional effect determine atoms negated
matter effect used achieve obtain atoms intersecting
appropriate sets








gp

h


da




effi





fikoehler hoffmann
exactly facts deleted achieving matter
effect use
intersection sets actions yields desired set f let us
consider following small example clarify computation
fu g
fw g f x g
fv w g fag f x g
fw g
fu g f g

da

obtain f x g f g f x g precondition
implied first conditional effect effect achieve
get f x g
obtain smaller set add unconditional positive effect
action
fu g
fw ag f x g
fv w g fag f x g
fw g
fu g f g
case need intersect sets f x g f x g
yielding f x g ects fact achieving via unconditional
effect x gets removed state
fixpoint computation requires adapt computation first repeat
steps case simple strips actions consider unconditional negative
effects intersection preconditions false set

n fo j eff f pre g

da

additionally remove action conditional effects imply
deletion impossible effect condition

red fred jo og
red function red
n f j pre f
k

k


da

k

g

finally need redefine definition expresses conditions
fact believed possibly achievable given certain set operators
definition possibly achievable atoms adl atom p possibly achievable given action set written pa p

p eff
p pre pre p eff










holds e positive effect p conditions preconditions
made true effects reduced action set


fion reasonable forced goal orderings
process decides whether atomic goal b heuristically ordered another
goal e whether b holds proceeds exactly way described
section false set f reduced fixpoint computation remains
unchanged employs updated routines computing deciding pa f
b ordered b possibly achievable
pa b action set fixpoint
h


da

h

use goal orderings

determined ordering relations hold pairs atomic goals
given goal set question make use several
proposals made literature see section detailed discussion
propose novel extracts explicit ordering subsets
goal set called goal agenda planner case ipp run successively
subproblems represented agenda
goal agenda

first step one take computing goal agenda perform called goal
g atomic goals must examined
order whether ordering relation b b none holds
ordering relation arbitrary definition used
experiments relation
determined ordering relations hold atomic goals want
split goal set smaller sets relations want order
smaller sets relations precisely goal sequence
goal sets g g

g g
analysis goal analysis pair b

e

h

n

n









g



g
j

j j n want sequence goal sets respect ordering
relations derived atomic goals make explicit first
introduce simple representation detected atomic orderings goal graph g
g v e

v g

e f b g g j b g
desired properties sequence goal sets possess easily
stated


fikoehler hoffmann

goals b lie cycle g belong set e b g
g contains path goal goal b vice versa ordered
b e g b g j




j

properties appear reasonable goal set sequence respecting
atomic orderings introduce simple algorithmic method produce
sequence goal sets meets requirements
first transitive closure g computed done cubic
time size goal set warshall node transitive
closure ingoing edges outgoing edges counted disconnected nodes
moved separate set goals g sep containing
atomic goals participate relation nodes degree

determined difference number ingoing edges
number outgoing edges nodes identical degree merged one set
sets ordered increasing degree yield desired sequence goal sets
remaining set g sep non empty clear place
put
let us consider small example process figure depicts left goal
graph goal set g fa b c e g ordering relations
b b c b transitive closure right












b

b
c

c






e

e

figure left goal graph depicting relations atomic subgoals
right transitive closure graph
figure number outgoing edges goal corresponding degrees
resulting goal set sequence shown



e










b









c


b


c

g sep
e



figure left number outgoing edges node right
degree nodes merged sets goals degree
node e becomes member g sep set remains unordered
dicult verify resulting goal sequence respects atomic goal orderings


fion reasonable forced goal orderings

nodes occurring cycle graph isomorphic outgoing edges

transitive closure graph particular degree get
merged set g
say graph path b vice versa
transitive closure graph edge node
b path additionally edge b e b
follows similarly ingoing edge b node path
additionally edge b gives us b altogether

b
b
b b thus degree
smaller degree b required gets ordered b
note nothing said argumentation set unordered goals gsep set could principle inserted anywhere sequence resulting
sequence still respecting atomic orderings possible heuristic may use goal set
first sequence apparently reach goals
goals set achieved another heuristic could put set end
neither reach goal set goals decided
deal sophisticated way trying derive ordering relation
g sep goal sets g already derived order
need extend definitions goal orderings sets goals
























extension goal orderings goal sets

given set atomic goals exponentially many
subsets compared order derive reasonable goal ordering
goal sets consideration possible subsets question
exponential overhead partial goal agenda obtained far
offers one possible answer suggests taking set g sep trying order
respect goal sets emerging goal graph
given g two subsets atomic goals fa g g
fb b g g definition sets atomic goals straightforward
sake simplicity consider strips actions definitions
directly extended adl
define ordering extends sets begin defining set f f n g
atoms exclusive least one atomic goal graph
generated g
f f n g fp j p exclusive least one graph leveled g
set n g obtained accordingly removing actions delete
least one e n g fo j f ng del g
definition ordering goal sets let g
n

e

k

h



e

e

gp







gp









fa g g fb b g g let ng false set fa g
ordering fb b g fa g holds
j f kg ng b add pre ng
e



n

k

k

e

n

gp

n





j



gp

fikoehler hoffmann
similar way extended sets f determined
equation set n g simply union individual sets
f n g f
f



h

h



da



da





da

da



fixpoint computation entered

n fo j f ng del ng pre g
recomputation iteration fixpoint figure done




da

accordingly apart remains unchanged

definition ordering let g fa g

fb b g g let set actions obtained performing
fixpoint computation shown figure modified handle sets facts defined
equations ordering fb b g fa g holds
j f kg pa b

g

h

n

k

h

k

n

j

given goal sets undergo goal analysis e pair sets checked
ordering relation derived relation defines edge graph
subgoal sets nodes transitive closure determined degree
node computed graph contains disconnected nodes total ordering
subsets goals ordering nodes degree ordering
defines goal agenda case disconnected nodes default heuristic
adding corresponding goals last goal set agenda
e

h

agenda driven

given g let us assume goal agenda g g g
k entries returned analysis entry contains subset g g
basic idea agenda driven first feed planner
original initial state goals g g execute solution plan p
yielding initial state p
initialized g solving want goals g true
want goals g remain true set g g g continuous
merging successive entries agenda yields sequence incrementally growing
goal sets planner namely

g g
k







j

j



little detail agenda driven implemented ipp works
follows first ipp called g returns plan p
achieves subgoal set g p sequence parallel sets actions returned
ipp similarly graphplan given plan resulting state r p


fion reasonable forced goal orderings
computed operational semantics actions case set
strips actions one simply adds add effects deletes del effects
state description order obtain resulting state following function
definition strips function coincides directly r function
case set parallel adl actions one needs consider possible linearizations
parallel action set deal conditional effects separately
linearization different resulting state obtained satisfy
goals obtain initial state one takes intersection resulting states
possible linearization actions parallel set means compute n
linearizations parallel action set n actions time step since n usually
small adl actions per time step rare practical costs
computation neglectible
way given solution subproblem g one calculates initial
state runs planner subsequent g
g solved
plan solving original g obtained taking
sequence subplans p p p one could argue increasing goal
sets lead highly non optimal plans ipp still uses ops first strategy
achieve goals originally introduced graphplan system blum furst
employing strategy graphplan short first tries achieve
goals simply keeping true possible since goals g g g already
satisfied initial state starting planner tries achieve g
strategy ensures goals destroyed established solution
found otherwise ops first strategy merely graphplan feature
reasonable strategy preserve goals already true initial state
whenever possible
soundness agenda driven obvious g g
sequence sound subplans yielding state transition initial state
state satisfying g
completeness less obvious holds planner cannot
make wrong decisions finally reaching goals precisely
complete contain deadlocks introduced definition








k



k

k







k

theorem given solvable g goal agenda g g g

k

g g g g running complete planner agenda driven manner
described yield solution deadlock free




k

proof let us assume planner solution step agenda driven

e solution found subproblem g planner assumed
complete subproblem implies unsolvability g
solvable neither g solvable since g g holds therefore
goals cannot reached furthermore reachable state reached
executing partial solution plans p p initial state consequently
must deadlock state sense definition contradiction


















see koehler et al exact definition r want repeat





fikoehler hoffmann
states feasibility shown benchmark
currently investigated contain inverse actions therefore invertible
theorem deadlock free theorem thus theorem
preserves completeness domains
however general case completeness cannot guaranteed following example
illustrates situation assumption j p assuming preconditions
achieving actions contained state reached cf derivation
ordering section wrong yields goal ordering plan
found anymore although solvable
given initial state fc dg goals fa b g planner following set
ground strips actions


b

h

op
op
op
op

fc g
fdg
fe g
g






add fb g del fdg
add fe g
add g
add fag

analysis return ordering b b added op
precondition c effect actions thus concludes c
reachable state holds example c holds reachable
states assumption j c made test pa b wrong thus b
reached hand b holds even forced ordering
b testing b ordering remains undetected
method discover precondition f op achievable state
b holds obtain f fdg excludes op op op
remain set usable actions thus op considered legal achiever op
considered legal achiever precondition f could detect right ordering
regressed action chain op op op found
f set b actions must excluded
consequently goal agenda fb g fag fed planner solves first
subproblem op fails achieving state fb c g since
inverse action op cannot established way
h



b

r

f

h

b
da

empirical

implemented methods approximate called goal agenda manager
gam ipp system koehler et al gam activated
set ground actions determined uses approximate
reasonable goal ordering calls ipp entry
goal agenda outputs solution plan concatenation solution plans
found entry agenda
r

e

h

source code gam ipp collection domains
draw subsequent examples downloaded http www informatik uni freiburg de
koehler ipp gam html experiments performed sparc



fion reasonable forced goal orderings
empirical evaluation performed uses ipp domain collection contains domains domains
able derive goal ordering information domains domains indeed pose constraints ordering planner achieve set goals
domains goal orderings could derived found single goal
achieved example manhattan movie molgen montlake domains
goals achieved order example logistics gripper ferry
domains found benchmark domain natural goal ordering existed
method failed detect matter fact looking goal ordering seems
natural one usually finds ordering reasonable sense definition see
example blocks world woodshop tyreworld domains method finds almost
reasonable orderings indicates approximation techniques
appropriate detecting ordering information
e

h

following first compare techniques terms runtime
number goal agenda entries generated take closer look agendas
generated selected domains investigate uence performance
ipp system exact definition domains downloaded
ipp webpage give name domain name particular
well number ground actions domain contains
parameter nicely characterizes size domain usually diculty
handle
e

h

examples times shown compute goal agenda contain effort
parse instantiate operators e compute set actions times parsing
instantiation listed explicitly test examples used
usually close zero uence performance planner significant
way
comparison
h

e

begin comparison summary obtained different representational variants blocks world bw large bw large examples originate
satplan test suite kautz selman added larger examples
bw large e bw large g parcplan example comes el kholy richards
uses multiple grippers limited space table stack n examples use
graphplan blocks world representation simply require stack n blocks
table initial state
two methods return exactly ordering relations across blocks world
figure confirms computation graphs
much time consuming hits computational border domain contains
actions computation much faster scales larger action
sets
e

h



fikoehler hoffmann

bw large
bw large b
bw large c
bw large
bw large e
bw large f
bw large g
parcplan
stack
stack
stack
stack

actions agenda entries cpu cpu















































e

h

figure comparison blocks world actions shows number
actions set planner tries construct plan agenda
entries says many goal subsets detected ordered gam
column display cpu time required methods
compute agenda provided set dash mean
ipp ran memory gbyte machine
e

h

figure figure domains method
able detect reasonable orderings figure lists domains methods
return goal agendas tyreworld hanoi fridgeworld domains originate
ucpop penberthy weld link repeat domain found veloso
blythe performance coincide shown figure figure
shows picture terms runtime performance domains different
agendas returned
woodshop scheduling domains contain actions conditional effects
domains use strips operators computation fails derive goal
orderings scheduling world display largest
sched wood explanation behavior found
different treatment conditional effects methods ipp limited
form mutex relations conditional effects building graph
goal achieved conditional effect often exclusive large
number facts graph thus f sets small sometimes even empty
consequently actions excluded performing reachability
analysis thus reasonable orderings may remain undetected direct analysis investigates
conditional effects detail therefore able derive much larger f sets
behavior method strips domains bulldozer glassworld
shopping world caused phenomenon domains one derive much
larger f sets graphs turn sets exclude actions since direct
analysis finds smaller empty f sets finds less relations woodshop domain
e

h

e

h

h



fion reasonable forced goal orderings
actions agenda entries cpu cpu

























































domain
tyreworld


fixit
fixit
fixit
fixit
fixit
fixit
hanoi
hanoi
hanoi
hanoi
hanoi
hanoi
fridgeworld fridge
link repeat link
link

e

h

figure comparison benchmark domains return
identical agendas
e

h

domain
bulldozer
glassworld


bull
glass
glass
glass
shoppingworld shop
scheduling
sched
woodshop
wood
wood
wood

actions agenda entries cpu cpu




































e

h

figure domains return different goal agendas give
form n n number slash says many entries contained
agenda computed number following slash says many
entries contained agenda computed agenda entries means
agenda contains single entry namely original goal set
ordering derived
e

h

e

h

shows differ within domain depending specific
wood varies wood sense one
goal slightly different object needs put different shape two
goals present goal orderings derived pairs old


fikoehler hoffmann
goals wood lots relations derived mixed pairs old goals
wood yielding detailed goal agenda wood contains additional objects
many goals successfully ordered
subsequent experiments decided solely use heuristic ordering
computation less costly computation cases yielding
comparable agendas cases three domains investigate closely
namely blocks world tyreworld hanoi domains agendas derived methods
fact exactly
e

h

e

h

uence goal orderings performance ipp interaction
rifo

section analyze uence goal agenda performance ipp
combine another domain analysis method called rifo nebel dimopoulos
koehler rifo family heuristics enables ipp exclude irrelevant actions
initial facts effectively combined gam
ipp plans subset goals original goal set likely
subset relevant actions needed plan precisely
obtain one subproblem entry agenda subproblem
use rifo preprocessing ipp configuration gam reduces
search space ipp decreasing number subgoals planner achieve
moment rifo reduces search space dramatically selecting
actions relevant goal subset
blocks world

figure illustrates parcplan el kholy richards detail seven
robot arms used order blocks stacks possible positions table























































figure parcplan limited space table seven robot arms
several stacks
goal agenda derived ipp orders blocks horizontal layers





table table
table




fion reasonable forced goal orderings
optimal plan actions solving found ipp gam
spends one second computing goal agenda almost seconds build
graphs second search plan actions tried
solution without goal analysis ipp needs approx searches
actions seconds
rifo nebel et al fails detecting subset relevant actions original
goal set considered succeeds selecting relevant actions subproblems
stated agenda reduces runtime less spent
goal agenda almost spent removal irrelevant actions initial facts less
spent building graphs previously almost time spent

figure shows ipp satplan blocks world examples kautz selman
bw large e example taken dimopoulos nebel koehler two
large examples bw large f containing blocks requiring build stacks
goal state bw large g blocks stacks
satplan
bw large
bw large b
bw large c
bw large
bw large e
bw large f
bw large g

actions plan length ipp g g r g r l
































figure performance extended satplan blocks world test suite second
column shows number ground actions domain third column
shows plan length e number actions contained plan generated
gam parentheses plan length generated ipp without gam given
ipp without gam able solve corresponding g means
ipp gam g r means ipp uses gam rifo g r l
means subgoals set agenda arbitrarily linearized
runtimes cover whole process starting parsing operator
domain file performing gam rifo analysis active
searching graph plan found
ipp without gam solve bw large bw large b
goal agenda plans become slightly longer performance increasing dramatically
plan length growing blocks accidentally put positions cut
goals still ahead agenda thus additional actions need added
plan remove blocks wrong positions speed possible
rifo additionally used reduces size graphs dramatically
finally goals belong subset agenda linearized



fikoehler hoffmann
heuristic assumption analysis found reasonable goal orderings goals
achievable order option solved almost instantly
reader may wonder point use linearization agenda entries
extra option investigate two reasons first
linearization negative side effects domains investigated
example yields much longer plans logistics domain variants
linearizing single entry agenda logistics contains packages get
transported goal position one one course takes much
steps simultaneously transporting packages coinciding destinations
secondly effects linearization somewhat unpredictible even domains
usually tends yield good gam recognise interactions goals consider blocks world four blocks b c
say b positioned c initially blocks table goal
b c agenda comprise single entry
containing goals fact reasonable goal ordering nevertheless
stacking onto b immedeatly bad idea planner needs move c achieve
c aware gam might linearize single agenda entry
b front makes harder actually thus runtime
advantages linearization sometimes yields blocks world less seen
cases good luck
figure shows ipp stack n ipp without domain analysis
handle blocks less minutes blocks minutes
needed gam blocks stacked less minutes gam
rifo minutes limit extended blocks stack solved min
min spent analysis methods min needed building
graphs extracting plan
time




ipp

ipp g
ipp g r








figure

ipp















blocks

simple huge stacking

figure shows sharing overall solving time gam rifo
ipp search blocks world similar obtained
tyreworld gam takes rifo takes
search effort reduced approx overall solving time clearly
determined rifo search effort becomes marginal factor determination
performance indicates speed possible improving


fion reasonable forced goal orderings
performance gam rifo indicates even hardest
become easy structured decomposed right way

stack
stack
stack
stack
parcplan

actions






gam
rifo






search






figure distribution solving time blocks world examples gam
rifo search comprises time build search
graph remaining fraction total solving time
shown table spent parsing instantiating operators

tyreworld

tyreworld originally formulated stuart russell asks planner
replace tire easily solved ipp within milliseconds
becomes much harder number tires increasing cf figure
tires










figure

actions
ipp
g r
g r l
search space





























tyreworld numbers parentheses time steps followed
number actions generated plan last column compares
search spaces number slash shows number actions tried
parameter plain ipp number following
slash shows number actions tried ipp gam rifo
linearization entries agenda dash means number
actions tried unknown ipp failed solving corresponding


ipp



fikoehler hoffmann
ipp able solve tires gam rifo
tires handled solution length gam slightly increasing caused
super uous jack jack actions short explained follows
wheel needs mounted hub expressed r h goal mount
wheel hub must jacked mounting nuts done hub
needs jacked order tighten nuts achieving tight n h goal
gam puts goals one entry preceeding tight goals thus solving
entry containing goals hub jacked wheel put hub
immediatly jacked order replace next wheel afterwards solving
tight goals hub must jacked one time
nuts solving manner planner inserts one super uous jack
one super uous jack action wheel precisely super uous actions
inserted one wheel namely wheel last mounted solving
goals mounting wheel goals achieved planner proceeds
next agenda entry wheel still jacked trying achieve
tight goals ipp recognizes shortest plan terms number parallel steps
nuts first done hub already jacked thus hub
jacked one time achieving corresponding goal jacked one
time achieving tight goal
case tires following goal subsets identified ordered









ated r ated r ated r
r hub r hub r hub
tight n hub tight n hub tight n hub
w boot pump boot w boot w boot
jack boot
wrench boot
closed boot

hardest subproblem agenda achieve r hub goals entry
e mount ated spare wheels hubs trying generate maximum parallelized plan impossible ipp tires since goals completely
independent linearization perfectly work resulting
plans become slightly longer due way tight goals achieved
l option noticed earlier one wheel one last mounted
solving goals super uous jack jack actions need inserted
plan linearizing agenda entries super uous jack jack actions must
likely inserted wheels yielding plans two steps longer reason
tight goal might first linearization likely
tight goal corresponding hub still jacked planner needs
insert one super uous jack action later must jack hub yielding
another super uous action g r l case tires actions need
tried plan actions found takes gam requires
rifo requires consumed generate graphs
spent compute initial states subproblems remaining consumed
parsing instantiating






fion reasonable forced goal orderings
tower hanoi

surprising obtained tower hanoi domain domain stack discs
moved one peg third peg auxiliary second peg
never larger disc put onto smaller disc case three discs
increasing size goals stated peg gam returns
following agenda correctly ects ordering largest disc needs
put goal position first
peg



goal agenda leads partition subproblems corresponds recursive
formulation solving e solve n discs
planner first solve n discs etc first entry plan
actions time steps generated achieves goal peg
plan actions time steps achieves goals peg
peg holding already initial state finally one step plan time step
generated moves third disc two discs already goal
position
time
time
time
time

step
step
step
step






move peg
move peg
move peg
move peg peg

time step move peg
time step move peg
time step move peg

surprisingly ipp able benefit information runtime ipp
gam exploding dramatically increasing numbers discs see figure
discs actions ipp ipp g
ucpop
ucpop subproblems


















figure runtimes ipp without goal agenda hanoi compared ucpop without agenda ucpop agenda subproblems
zlifo ibf control strategy
move action takes first argument disc moved second disc moved
third argument disc peg moved



fikoehler hoffmann
able provide explanation phenomenon division
subproblems causes much larger search space planner although solution
plans rifo cannot improve situation selects actions relevant
tower hanoi domain one found ipp performance deteriorated gam currently see way one tell advance whether ipp
gain advantage gam overhead caused goal analysis
small inadequate split goals subgoal sets lead
search see section
however case phenomenon seems specific ipp simulated
information provided gam ucpop obtained quite different picture
fifth column figure shows runtime ucpop zlifo pollack joslin
paolucci ibf control strategy number explored partial plans
parentheses ucpop solve discs last column
figure runtime number explored partial plans
ucpop run subproblems agenda exactly
subproblems ipp solve performance ucpop improves
significantly instead taking exploring partial plans ucpop takes
explores plans unfortunately
subproblems discs remain beyond performance ucpop
performance improvement independent search strategies used ucpop
example ibf control used without zlifo number explored partial plans
reduced case discs runtime improves
seconds seconds similarly bf control without zlifo
number explored partial plans reduces
knoblock reports improvement performance prodigy planner
fink veloso abstraction hierarchy generated domain
alpine module provides essence information goal agenda
summary comparison related work

many related approaches developed provide planner ability
decompose giving kind goal ordering information subsequently discuss important review work light
approaches
method introduces preprocessing derives total ordering
subsets goals performing static heuristic analysis hand
works domains described strips adl operators
polynomial time purpose method provide planner
search control e opt deriving goal achievement order successively call
planner totally ordered subsets goals
method preserves soundness system completeness
case domain contain deadlocks argue
however goal ordering information alpine requires represent tower hanoi domain
involving several operators cf knoblock



fion reasonable forced goal orderings
benchmark domains quite often possess property supported
authors williams nayak
computation requires polynomial time methods
incomplete sense detect reasonable goal orderings general
case complexity deciding existence forced reasonable goal orderings
proven pspace hard section therefore trading completeness
eciency seems acceptable solution complexity relate found
bylander proves pspace completeness serial decomposability korf
given set subgoals serial decomposability means previously satisfied subgoals need violated later solution path e subgoal
achieved remains valid goal reached purpose method derive
constraints make orderings explicit serial decomposability set
goals found e consider complementary ected
complexity proofs
many cases found goal agenda manager significantly improve
performance ipp system found least one domain namely
tower hanoi dramatic decrease performance observed although ipp
still generates optimal plan processing ordered goals agenda
far complexity backstrom jonsson predicted
abstraction hierarchies exponentially less ecient exponentially longer
plans generated
idea analyze effects preconditions operators derive ordering
constraints interaction operators found variety approaches
analyze harmful interactions operators method studying delete
effects approaches described dawsson siklossy korf knoblock
concentrate positive interactions operators successful matching
effects preconditions forms basis learn macro operators see dawsson siklossy
korf
alpine system knoblock learns abstraction hierarchies prodigy
planner fink veloso ordering preconditions
effects operator e effects operator must abstraction
hierarchy preconditions must placed lower level effects
introduces ordering possible subgoals domain orthogonal
ordering compute alpine subgoal ordered subgoal b
enables b e must possibly achieved first order achieve b method
orders b cannot achieved without necessarily destroying b
alpine gam set binary constraints case alpine constraints
computed atoms domain gam restricts analysis
goals approaches represent binary constraints graph structure alpine
merges atomic goals together belong strongly connected component graph
gam merges sets goals together identical degree compute
topological sorting sets consistent constraints resulting goal
orderings quite similar examples knoblock demonstrate gam
approximates reasonable goal orderings domains alpine fails finding abstraction
hierarchies two examples knoblock tower hanoi domain
h

e



fikoehler hoffmann
one move operator blocks world domains alpine cannot detect
orderings investigates operator schemata set ground actions
therefore cannot distinguish orderings different instantiations
literal although alpine could modified handle ground actions significantly
increase amount computation requires gam hand handles large sets
ground actions ecient way particular direct analysis used
analysis quite similar alpine performed framework
htn described tsuneto et al analyzes external
conditions methods cannot achieved decomposing method
means conditions established decomposition methods
precede method external condition two strategies determine
decomposition order methods defined empirically compared lies main
difference approaches described far instead trying automatically
construct decomposition orderings predefined fixed domains

harmful interactions among operators studied smith peot etzioni
threat operator precondition p occurs instantiation
effects inconsistent p smith peot knowledge
threats used control plan space planner contrast state space planner
ipp computing explicit ordering goals prevent presence threats
partial plan order goals processed determine order
actions occur plan notion forced reasonable goal orderings
comparable threat threat still potential resolved
adding binding ordering constraints plans contrast forced
reasonable goal ordering persists bindings enforces specific ordering
subgoals
given static etzioni computes backchaining tree
goals form graph subsequently analyzes occurrence
goal interactions necessarily occur analysis much complicated
static deal uninstantiated operators axioms
describe properties legal states analysis goal ordering rules
order goals certain conditions satisfied state main difference gam
generates explicit goal orderings independently specific state need
extract conditions specific state satisfy considers generic state
analysis represents states satisfying b gam static
incomplete sense cannot detect existing goal interactions
gam deciding reasonable orderings pspace hard proven
static compute necessary effects operator
given state etzioni conjectures nebel backstrom prove


b

abstraction hierarchies general goal orderings compute cannot serve
purpose providing planner goal ordering information allow generate plans
different levels refinement see bacchus yang two approaches generating
abstraction hierarchies numerical criticality values found sacerdoti bundy
giunchiglia sebastiani walsh



fion reasonable forced goal orderings
computationally intractable therefore polynomial time analysis method
must incomplete
last least quite number approaches late eighties
focused directly subgoal orderings fall two categories approaches
described drummond currie hertzberg horz focus detection
con icts caused goal interdependencies guide partial order planner search
investigate approaches detail extract explicit
goal orderings preprocess works described irani cheng
cheng irani joslin roach implement preprocessing approaches
perform structural analysis task determine appropriate goal
ordering starts irani cheng compute relation
pairs goals roughly speaking orders goal goal b b must
achieved achieved formalism rather complicated theoretical
properties relation investigated cheng irani
extended sets goals ordered respect exact
properties formalism remain unclear joslin roach graph theoretical
described generates graph atoms given domain description
nodes draws arc node node b operator exists takes
precondition b effect assuming operators inverse
counterparts identifying connected components graph proposed means
order goals unlikely scale size spaces today planners
consider completely outdated terms terminology
finally one wonder reasonable forced goal orderings relate others
defined literature one attempt know ordering
relation explicitly defined properties studied see hullem et al
notion necessary goal orderings introduced must true
minimal solution plans kambhampati extends operator graphs
smith peot orders goal three criteria called goal subsumption goal
clobbering precondition violation goal subsumption b holds every solution plan
achieving goal b state achieves goal state preceding plan
achieving one goals g n fag deletes goal clobbering holds solution plan
deletes b thus b precondition violation holds solution b
deadlock cannot reached anymore e b composite
criterion defined tests three criteria simultaneously goal necessarily
ordered b satisfies composite criterion
remark precondition violation seems equivalent forced orderings
introduced goal clobbering appears similar reasonable orderings
possible us verify conjecture authors hullem et al give
exact formal definitions nothing similar goal subsumption argue
criterion rarely satisfied natural goal achieved every
plan minimal contains subplan solution plan remark minimality
mean shortest plans least number actions considered fact minimal
plans highly non optimal long action truly super uous
authors precise mean argue means
two goals ordered satisfy least one criteria



fikoehler hoffmann
solution goal b anyway goal removed goal set without
changing task
authors report able detect necessary orderings artificial
domains cf barrett weld fail typical benchmark domains
blocks world tyreworld reason seems operator graphs
represent possible instantiations operator schemes authors claim
makes operator graph analysis ecient however heuristic ordering
introduced takes almost computation time succeeds finding
goal orderings domains




h

outlook

three promising avenues future following
first one imagine goal ordering information used search
process e ordering original goal set goals emerge
search major challenge seems balance effort computing goal
ordering information savings search process one
easily imagine ordering goal sets ever generated become quite costly
investment without yielding major benefit planner
secondly refinement goal agenda additional subgoals another interesting future line work first investigation called intermediate goals
facts planner must make true achieve original goal
explored inside gam reported koehler hoffmann earlier
work addressing task learning intermediate goals found ruby kibler
focus ai since
third line work addresses interaction gam forward searching system seen gam preserves correctness planner
preserves completeness least deadlock free domains
seen however solution plans gam get longer e gam preserve optimality planner recently systems deliver plans
guaranteed optimality demonstrated impressive performance terms runtime
plan length e g hsp first mentioned bonet loerincs geffner
grt refanidis vlahavas particular hoffmann systems
heuristic search planners searching forward state space non admissible
informative heuristics
system developed one authors awarded group
distinguished performance system schindler award
best performing system miconic elevator domain adl track
aips competition integration goal agenda techniques
planner one factors enabled excellent behavior competition
crucial scaling blocks world blocks helped factor
schedule miconic never slowed
forward state space search quite natural framework driven goal agenda
simply let planner solve subproblem start next search state
last search ended even appealing heuristic forward search planners deeper


fion reasonable forced goal orderings
kind interaction gam example graphplan style planners addition
smaller facing goal agenda heuristics
uenced employ techniques estimating goal distance state
goal agenda different goal sets stage process
therefore goal distance estimate different currently heuristic device
inside search developed knows driven
goal agenda access complete set goals information
used prune unpromising branches search space discovers
currently achieved goals probably destroyed reachieved later
references

allen j ed aips proceedings th international conference artificial intelligence systems aaai press menlo park
anderson c weld conditional effects graphplan allen allen
pp
bacchus f yang q downward refinement eciency hierarchical
solving artificial intelligence
backstrom c jonsson p abstraction hierarchies exponentially less ecient mellish mellish pp
barrett weld partial order evaluating possible eciency gains
artificial intelligence
blum furst fast graph analysis artificial
intelligence
bonet b loerincs g geffner h robust fast action selection mechanism proceedings th national conference american
association artificial intelligence pp
bundy giunchiglia f sebastiani r walsh computing abstraction
hierarchies numerical simulation weld clancey weld clancey pp

bylander complexity serial decomposability proceedings
th national conference american association artificial intelligence pp
san jose ca mit press
bylander computational complexity propositional strips
artificial intelligence
chapman conjunctive goals artificial intelligence
cheng j irani k ordering subgoals sridharan sridharan
pp


fikoehler hoffmann
dawsson c siklossy l role preprocessing solving systems
proceedings th international joint conference artificial intelligence pp
cambridge
dimopoulos nebel b koehler j encoding nonmonotonic logic programs steel steel pp
drummond currie k goal ordering partially ordered plans sridharan
sridharan pp
el kholy richards b temporal resource reasoning
parcplan approch wahlster w ed proceedings th european conference artificial intelligence pp john wiley sons chichester
york
etzioni acquiring search control knowledge via static analysis artificial intelligence
fink e veloso prodigy technical report cmu
carnegie mellon university
fox long automatic inference state invariants tim journal
artificial intelligence
fox long ecient implementation plan graph stan journal
artificial intelligence
hertzberg j horz towards theory con ict detection resolution
nonlinear plans sridharan sridharan pp
hoffmann j heuristic domain independent use enforced
hill climbing th international symposium methods intelligent
systems
hullem j munoz avila h weberskirch f extracting goal orderings
improve partial order graphplan technical report university
kaiserslautern
irani k cheng j subgoal ordering goal augmentation heuristic solving mcdermott ed proceedings th international joint
conference artificial intelligence pp milan italy morgan kaufmann
jonsson p haslum p backstrom c towards ecient universal
randomized artificial intelligence
joslin roach j theoretical analysis conjunctive goal artificial
intelligence
kambhampati admissible pruning strategies plan minimality planspace mellish mellish pp


fion reasonable forced goal orderings
kautz h selman b pushing envelope propositional logic
stochastic search weld clancey weld clancey pp
knoblock c automatically generating abstractions solving ph
thesis carnegie mellon university
knoblock c automatically generating abstractions artificial intelligence
koehler j handling conditional effects negative goals ipp technical report university freiburg institute computer science available
http www informatik uni freiburg de koehler ipp html
koehler j hoffmann j goal agendas technical report
university freiburg available http www informatik uni freiburg de
koehler ipp html
koehler j nebel b hoffmann j dimopoulos extending graphs
adl subset steel steel pp
korf r macro operators weak method learning artificial intelligence

korf r search quantitative artificial intelligence

mcdermott hanks nonmonotonic logic temporal projection artificial
intelligence
mellish c ed ijcai proceedings th international joint conference
artificial intelligence morgan kaufmann san francisco ca
nebel b backstrom c computational complexity temporal projection plan validation journal artificial intelligence
nebel b dimopoulos koehler j ignoring irrelevant facts operators
plan generation steel steel pp
nilsson n principles artificial intelligence tioga publishing company palo
alto
pednault e adl exploring middle ground strips situation
calculus brachman r levesque h reiter r eds proceedings st
international conference principles knowledge representation reasoning
pp toronto canada morgan kaufmann
penberthy j weld ucpop sound complete partial order planner
adl nebel b swartout w rich c eds proceedings rd
international conference principles knowledge representation reasoning
pp morgan kaufmann san mateo


fikoehler hoffmann
pollack joslin paolucci selection strategies partial order
journal artificial intelligence
refanidis vlahavas grt domain independent heuristic strips
worlds greedy regression tables proceedings th european conference pp
regli w gupta nau ai versus manufactoring operation
case study mellish mellish pp
ruby kibler learning subgoal sequences sridharan
sridharan pp
russel norvig p artificial intelligence modern prentice hall
sacerdoti e hierarchy abstraction spaces artificial intelligence

sanborn j hendler j near term event projection dynamic simulation
robot cross road proceedings nd conference ai
simulation
smith peot postponing threats partial order proceedings
th national conference american association artificial intelligence
pp aaai press mit press
sridharan n ed ijcai proceedings th international joint conference artificial intelligence detroit mi morgan kaufmann
steel ed ecp proceedings th european conference
vol lnai springer
tsuneto r hendler j nau analyzing external conditions improve
eciency htn allen allen pp
veloso blythe j linkability examining causal link commitments partialorder hammond k ed proceedings nd international conference artificial intelligence systems pp aaai press menlo
park
warshall j theorem boolean matrices journal acm
weld clancey b eds aaai proceedings th national conference american association artificial intelligence aaai press
williams b nayak r reactive planner model executive
proceedings th international joint conference artificial intelligence pp
morgan kaufmann san francisco ca




