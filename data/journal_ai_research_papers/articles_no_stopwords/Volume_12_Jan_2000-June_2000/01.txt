Journal Artificial Intelligence Research 12 (2000) 35-86

Submitted 5/99; published 2/00

Reasoning Interval Point-based
Disjunctive Metric Constraints Temporal Contexts
Federico Barber

FBARBER@DSIC.UPV.ES

Dpto. de Sistemas Informticos Computacin
Universidad Politcnica de Valencia
Camino de Vera s/n, 46022 Valencia, Spain

Abstract
introduce temporal model reasoning disjunctive metric constraints intervals
time points temporal contexts. temporal model composed labeled temporal algebra
reasoning algorithms. labeled temporal algebra defines labeled disjunctive metric pointbased constraints, disjunct input disjunctive constraint univocally associated
label. Reasoning algorithms manage labeled constraints, associated label lists, sets
mutually inconsistent disjuncts. algorithms guarantee consistency obtain minimal
network. Additionally, constraints organized hierarchy alternative temporal contexts.
Therefore, reason context-dependent disjunctive metric constraints intervals
points. Moreover, model able represent non-binary constraints, logical
dependencies disjuncts constraints handled. computational cost reasoning
algorithms exponential accordance underlying problem complexity, although
improvements proposed.

1. Introduction
Two main lines research commonly recognized temporal reasoning area. first
approach deals reasoning temporal constraints time-dependent entities. goal
determine consequences (T) follow set temporal constraints, "{TemporalConstraints}|=T?", determine whether set temporal constraints consistent,
assumptions properties temporal facts. second approach deals reasoning
change, events, actions causality. Here, goal obtain consequent state set
actions events performed initial state: "[Si, {A1, A2, ..., }]|= Sj?".
approaches constitute active fields research applications several artificial intelligence areas
reasoning change, scheduling, temporal planning, knowledge-based systems, natural
language understanding, etc. areas, time plays crucial role, problems dynamic
behavior, necessary represent reason temporal dimension information.
paper, deal first approaches. goal reasoning qualitative
quantitative constraints intervals time-points temporal contexts. Moreover, special
cases non-binary constraints managed. tasks pending issues temporal
reasoning area, well important features facilitate modeling relevant problems area
(including planning, scheduling, causal hypothetical reasoning, etc.).
Several temporal reasoning models defined literature, clear trade-off
representation expressiveness complexity reasoning algorithms. Qualitative Point
Algebra (PA) (Vilain, Kautz & Van Beek, 1986) limited subset interval-based models. Interval

2000 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Algebra (IA) introduced Allen (1983) represents symbolic (qualitative) constraints
intervals metric information, 'interval1 starts 2 seconds interval2 ', cannot
included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include 'time
line' (metric) constraints, represent limited subset disjunctive
constraints intervals. Thus, constraints 'interval1 {bef, aft} interval2 ' cannot
represented (Gerevini & Schubert, 1995).
efforts made integrate qualitative quantitative temporal information
points intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri
(1996) introduces Qualitative Algebra (QA), interval represented three nodes (one
representing interval two representing extreme points) QA
represent qualitative metric constraints points intervals. Badaloni Berati (1996) define
Interval Distance Sub Algebra (IDSA), nodes intervals. intervals related
disjunctive 4-tuple-metric constraints ending time points {(I-i, I-j ), (I+i , I-j ), (I-i , I+j ), (I+i ,
I+j )}. Staab Hahn (1998) propose model reasoning qualitative metric boundaries
intervals. However, models cannot handle constraints interval durations,
identified earlier Allen (1983). Constraints 'interval1 lasts 2 seconds interval2'
require high-order expression (Dechter et al., 1991), duration primitive
integrated interval point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993)
proposes two orthogonal networks relate constraints durations time points. Navarrete
(1997) Wetprasit Sattar (1998) relate disjunctive constraints durations time points,
limited subset interval constraints managed. recently, Pujari Sattar (1999)
propose framework reasoning points, intervals durations (PIDN). Here, variables
represent points intervals, constraints ordered set three intervals representing (Start,
End, Duration) subdomains. However, specialized algorithms management PIDN
constraints proposed.
relation complexity reasoning algorithms, consistency problem polynomial
PA (Vilain, Kautz & Van Beek, 1986) non-disjunctive metric networks (Dechter et al., 1991).
However, Vilain, Kautz Van Beek (1986) showed determining consistency
general-case temporal network (i.e.: disjunctive qualitative metric constraints points,
intervals durations) NP-hard. Thus, previous qualitative quantitative models,
consistency problem tractable properties constraints, relationships
variable domains constraints, using restricted subsets constraints (Dechter et al., 1991;
Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.).
instance, tractable subclasses IA identified Vilain, Kautz Van Beek (1986),
Nebel Burckert (1995), Drakengren Jonsson (1997), etc. Moreover, interesting results
obtained identification tractable subclasses QA. Specifically, Jonsson et al. (1999)
identified five maximal tractable subclasses qualitative point-interval algebra. However,
knowledge maximal tractable subclass PIDN model (maximal tractable subclass
qualitative quantitative point, interval duration constraints) still identified. case,
restricted tractable subclasses able obtain expressiveness full models,
problem reasoning disjunctive constraints points intervals remains NP-complete.
hand, qualitative metric temporal models manage certain types
non-binary constraints, important modeling problems (scheduling, causal
reasoning, etc.). instance, disjunctive assertions (interval1 {bef, meets} interval2 ) (time36

fiBARBER

point3 [10 20] time-point4 ), temporal-causal relations (interval1 {bef, meets}
interval2 ) (time-point3 [10 20] time-point4 ) incorporated models
(Meiri, 1996). Moreover, global consistency property introduced Dechter (1992)
important property temporal networks, since allows us obtain solutions backtrack-free
search (Dechter, 1992; Freuder, 1982). particular, global consistent network would allow us
handle conjunctive queries (interval1 {bef, meets} interval2 ) (time-point3 [10 20]
time-point4 ) hold? without propagation query, required (van Beek, 1991).
Stergiou Koubarakis (1996), Jonsson Bckstrm (1996) dealt representation
temporal constraints means disjunctions linear constraints (linear inequalities
inequations) named Disjunctive Linear Relations (DLRs). expressions unifying
approach manage disjunctive constraints points, intervals durations,
expressions subsume formalism temporal constraint reasoning (Jonsson & Bckstrm,
1998). Moreover, DLRs able represent disjunctions non-disjunctive metric constraints (x1 y1 c1 x2 -y2 c2 .... xn -yn cn ), xi yi time points, ci real numbers n1 (Stergiou
& Koubarakis, 1998). Obviously, satisfiability problem arbitrary set disjunctions
linear constraints NP-complete. Interesting tractable subclasses DLRs conditions
tractability identified (Cohen et al., 1996; Jonsson & Bckstrm, 1996; Stergiou &
Koubarakis, 1996). two main tractable subclasses Horn linear Ord-Horn linear
constraints (Stergiou & Koubarakis, 1996; Jonsson & Bckstrm, 1998). However, subclasses
subsume temporal algebras whose management polynomial.
management set disjunctions linear constraints mainly based general methods
linear programming, although specific methods defined tractable subclasses
(Stergiou & Koubarakis, 1998; Cohen et al., 1996; etc.). Pujari Sattar outline (1999),
linear programming approach, though expressive, take advantage underlying
structures (e.g., domain constraints) temporal constraints. addition, usual concepts temporal
reasoning, composition intersection operations constraints, minimal constraints, kconsistency (Freuder, 1982), decomposability (Montanari , 1974), globally consistency (Dechter,
1992), etc., consequences adapted reasoning disjunctive linear constraints,
trivial issue.
spite expressive power previous models, problems (including planning,
scheduling, hypothetical reasoning, etc.) need reason alternative contexts (situations,
intentions causal projections) know holds one (Dousson et al., 1993;
Gerevini & Schubert, 1995; Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999). gives
rise need reason context-dependent constraints. feature supported usual
temporal models general way, described usual expressive power constraints
(Jeavons et al., 1999). Therefore, ad-hoc methods used reasoning temporal
contexts required.
issues addressed paper. describe temporal model, integrates
qualitative metric disjunctive constraints time-points intervals. temporal model
based time-points primitive, intervals represented means end timepoints. However, representation interval constraints seems imply kind relation
among endpoint constraints (Gerevini & Schubert, 1995). proposed temporal model introduces
labeled constraints, elemental constraint (disjunct) disjunctive point-based metric
constraint associated one unique label. way, point-based constraints related among
37

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

without using hyper-arcs. Therefore, metric symbolic constraints among intervals timepoints fully integrated, represented managed means labeled metric point-based
Temporal Constraint Network (TCN). Particularly, model proposed handles constraints
proposed QA (Meiri, 1996), IDSA (Badaloni & Berati, 1996), Distance Constraint Arrays
model (Staab & Hahn, 1998). Moreover, several added functionalities provided:
Management alternative temporal contexts. input constraint associated
given context. hierarchy alternative temporal contexts defined,
constraints points intervals dependent context. knowledge,
features improve existing temporal models, contexts managed.
Reasoning algorithms labeled constraints based closure process. processes
guarantee consistency obtain minimal disjunctive context-dependent TCN. Additionally,
special type globally labeled-consistent TCN obtained. property allows us obtain
solutions backtrack-free search (Freuder, 1982).
Management special type non-binary constraints. Reasoning algorithms able
manage disjunctions disjunctive constraints. supposes extension disjunctions
non-disjunctive metric constraints proposed Stergiou Koubarakis (1998). Moreover,
given set disjunctive constraints, model handle logical relations among
disjunctions different constraints. Thus, express set atomic disjuncts
disjunctive constraints mutually disjunctive among them. Therefore, special type
and/or TCN managed conjunctive (and) TCN. Likewise, model handle
special non-binary constraints representing implications among temporal constraints
identified Meiri (1996).
features, proposed temporal model suitable modeling problems
requirements appear. computational cost reasoning methods non-polynomial, given
complexity underlying problem. However, several improvements proposed.
brief revision main temporal reasoning concepts presented Section 2. Section 3,
temporal algebra labeled point-based disjunctive metric constraints described. temporal
algebra introduces concept labeled constraints temporal operations. Reasoning
algorithms guaranteeing minimal (and consistent) TCN specified Section 4. using
model, integration interval point-based constraints management non-binary
constraints respectively described Sections 5 6. Association constraints temporal
contexts management context-dependent constraints detailed Section 7. Finally, Section
8 concludes.

2. Basic Temporal Concepts
Temporal reasoning deals reasoning temporal constraints. syntax semantics
constraints defined underlying temporal algebra, basis performing
reasoning processes. temporal algebra defined according following elements:
Temporal primitive (or variable) 'x ', usually time-points (ti ) intervals (Ii ).
Interpretation domain primitives xi . interpretation domain represents time line.
38

fiBARBER

Time points instantiated (ti D), temporal intervals modelled pairs
ending time points instantiated D: Ii = (Ii -, Ii +), Ii DxD, Ii -Ii +.
Temporal constraints primitives, constraint relates n primitives: c1,2..n (x1 ,
x2 , ..., xn ). particular cases, 'empty constraint' {} named Inconsistent-Constraint
'U' Universal-Constraint. Unary-constraints restrict interpretation domain
variables. usually used symbolic algebras, infinite domain
assumed. Binary-constraints temporal constraints two variables (xi cij xj ), nary-constraints represent temporal constraints among n variables. default, binary constraints
assumed paper. qualitative (relative relation) quantitative
(metric relation) constraints, well disjunctive (cij set disjunctive basic constraints,
|cij |1) non-disjunctive constraints.
Operations constraints. Mainly, Temporal Composition (), Temporal Intersection
(), Temporal Union (), Temporal Inclusion ().
temporal problem specified set n variables X= {xi }, interpretation domain
finite set temporal constraints variables {(xi cij xj )}. temporal problem gives rise
Temporal Constraint Network (TCN) represented directed graph nodes
represent temporal primitives (xi ) labeled-directed edges represent binary constraints
(cij). Universal Constraint U usually represented graph, direct edge
(representing cij ) xi xj implies inverse one (representing cji ) xj xi .
According underlying Temporal Algebra, mainly IA-TCNs based Interval
Algebra (Allen, 1983), PA-TCNs based Point Algebra (Vilain et al., 1986), Metric-TCNs
based Metric Point Algebra (Dechter et al., 1991; Dean & McDermott, 1987). later
case, disjunctive metric point-based constraints give rise Temporal Constraint Satisfaction
Problem (TCSP) (Dechter et al., 1991).
Reasoning temporal constraints seen Constraint Satisfaction Problem (CSP).
instantiation variables X n-tuple (v1 , v2 , v3 , ...,vn ) / vi represents assignments
values {vi } variables {x }: (x1 =v1 , x2 =v2 , ...,xn =vn). (global) solution TCN consistent
instantiation variables X domains TCN constraints satisfied. value
v consistent (or feasible) value xi exists TCN solution xi =v. set
feasible values variable xi minimal domain variable. constraint (xi cij xj )
consistent exists solution (xi cij xj ) holds. constraint cij minimal iff consists
consistent elements (or feasible values) is, satisfied
interpretation TCN constraints. TCN minimal iff constraints minimal.
TCN consistent (or satisfiable ) iff least one solution. Freuder (1982) generalizes
notion consistency as: 'a network k-consistent iff (given instantiation k-1 variables
satisfying direct constraints among variables) exists least one instantiation
kth variable k values taken together satisfy constraints among k variables'.
consequences: (i) (k-1)-length paths network consistent, (ii) pair nodes,
exists interpretation satisfies (k-1)-length path them, (iii) sub-TCN
k-nodes consistent. particular cases, 1-consistency, 2-consistency 3-consistency called
node-consistency, arc-consistency path-consistency, respectively (Mackworth, 1977; Montanari,
1974).
39

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Path-consistency common concept constraint networks. Montanari (1974)
Mackworth (1977), path k-length nodes (x1 , x2 , ..., xk , xj ) path-consistent iff
value v1 d1 vj dj (x1=v1 c1j xj=vj ) holds, exists sequence values v2 d2 , v3d3 ,
..., vk dk (v1 cl2 v2 ), (v2 c23 v3 ),...., (vk ck,j vj ) hold. TCN path-consistent iff
paths consistent. Moreover, Montanari (1974) proves ensure path-consistency suffices
check every 2-length path. Thus, path-consistency 3-consistency equivalent concepts.
Alternatively, Meiri (1996) outlines path k-length (xi , x1 , x2 , ...,xk , xj ) path-consistent iff cij
(ci1 c12 ... ckj ). However, definition disregards domain constraints, equivalent
former definition variable domains infinite TCN node arc-consistent,
usual case symbolic algebras. metric algebras, path-consistency usually assumes node
arc-consistency. Therefore, taking account necessary test 2-length paths
assure path-consistency, TCN path-consistent iff cij ,cik ,ckjTCN, cij (cik ckj ).
condition gives rise usual path-consistent algorithm: Transitive Closure Algorithm
(TCA) imposes local 3-consistency sub-TCN 3 nodes, 2-length paths
become consistent paths (Mackworth, 1977; Montanari , 1974). TCA algorithm obtain
equivalent path-consistent TCN exists. Otherwise, fails.
cij ,cik ,ckj TCN: cij cij (cik ckj )
network strong k-consistent iff network j-consistent jk (Freuder, 1982). nconsistent TCN consistent TCN, strong n-consistent TCN minimal TCN. Alternatively,
Dechter (1992) introduces concepts local global consistency: partial instantiation
variables (x1 =v1 , x2 =v2 , ...,xk =vk ) / 1k<n locally consistent satisfies constraints among
variables. subTCN globally consistent locally consistent instantiation
variables subTCN extended consistent instantiation TCN. globally
consistent TCN one subTCNs globally consistent. Thus, TCN strong nconsistent iff globally consistent (Dechter, 1992).
first reasoning task TCN determine whether TCN consistent. TCN
consistent, obtain minimal-TCN, TCN solutions (by assuming discrete finite
model time), one solution, partial solution (consistent instantiation subset TCN
variables, part global solution), etc.
Deductive closure, propagation, one basic reasoning algorithms. closure process
deductive process TCN, new derived constraints deduced explicitly
asserted ones means composition () intersection () operations. Thus, process
determining consistency minimality TCN related sound complete closure
process (Vilain et al., 1986). Alternatively, CSP-based methods (with several heuristic search criteria)
used guaranteeing consistency obtaining TCN solutions. paper, mainly
interested TCN closure processes.
Determining consistency general-case TCN NP-hard, Minimal TCNs
obtained polynomial number consistency processes (Vilain et al., 1986). Particularly, Dechter,
Meiri Pearl (1991) showed determining consistency obtaining minimal disjunctive
metric TCN achieved O(n3 le), n number TCN nodes, e number
explicitly asserted (input) constraints, l maximum number intervals input
constraint. However, specific levels k-consistency guarantee consistency obtain minimal
TCN, depending TCN topology underlying temporal algebra. example, path40

fiBARBER

consistency guarantees consistency obtains minimal non-disjunctive metric TCN (Dechter et
al., 1991). path-consistency TCA Algorithm O(n3) cost (Allen, 1983; Vilain, Kautz & Van
Beek, 1986). However, assuring path-consistency become complex task disjunctive metricTCNs variable domain large continuous. stated Dechter, Meiri Pearl
(1991), number intervals |cij cjk | upper bounded |cij |x|cjk |. Thus, total number
disjuncts (subintervals) path-consistent TCN might exponential number disjuncts per
constraints initial (input) TCN. Schwalb Dechter (1997) call fragmentation
problem, appear non-disjunctive metric TCNs. Thus, TCA algorithm O(n3
R3 ) disjunctive metric-TCNs time dense (Dechter et al., 1991), range R
maximum difference lowest highest number specified input constraints.

3. Labeled Temporal Algebra
main elements point-based disjunctive metric temporal algebra (Dechter et al., 1991):
Time-point (ti ) primitive variable. continuous variable domain (like Q ) usually
assumed.
temporal constraint cij U finite set l mutually exclusive subdomains (or
subintervals) D.
cij {[d-1 d+1 ], [d-2 d+2 ], ...., [d-k d+k ], ....., [d-l d+l ]} ,

d-k d+k d-k ,d+k D,

disjunctively restricts temporal distance two time-points, ti tj :
tj - ti {[d-1 d+1 ], [d-2 d+2 ], ....., [d-l d+l ]},
meaning (d-1 tj -ti d+1 ) .... (d-l tj -ti d+l ). Similar conditions applied open
(d-k d+k ) semi-open intervals (d-k d+k ], [d-k d+k ). Universal-Constraint U {(- +)}.
Unary constraints restrict associated subdomain time-point ti {[d-1 d+1 ], [d-2 d+2], .....,
[d-l d+l ]}. special time-point T0 usually included, represents 'the beginning
world' (usually, T0 =0). Thus, unary constraint ti represented binary one
ti T0 :
ti - T0 {[d-1 d+1 ], [d-2 d+2 ], ..... ,[d-l d+l ]} ti[d-1 , d+1 ] ti [d-2 , d+2 ] , ..., ti[d-l , d+l ]
and, default: ti , (T0 {[0 )} ti ).
algebra operations, mainly , , . (Meiri, 1996), given two temporal
constraints S={[dS-i , dS+i ]} T={[dT-j , dT +j ]},
= {dk / diS djT / dk = di +dj }.
is, [dS-i , dS+i ]S, [dT-j , dT +j ]T, T{[dS-i +d T-j , dS+i +d T+j ]}. Here, resulting subdomains
may pairwise disjoint. Therefore, additional processing may required
compute disjoint subdomain set.
= {dk / dkS dkT}. is, set-intersection subdomains.
= {dk / dkS dk T}, set-union subdomains.
ST = iff dk S, dk T.
41

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

basis point-based disjunctive metric temporal algebra operations,
introduce labeled point-based disjunctive metric temporal algebra, gives rise labeledTCN.
3.1 Labeled Constraints Inconsistent Label Sets
elemental constraint (ec) one disjunct disjunctive constraint. Similar terms atomic,
basic canonical constraints. However, lets use term due special structure labeled
elemental constraints introduced on. Thus, disjunctive constraint cij
considered disjunctive set l mutually exclusive elemental constraints {ecij.k }.
ecij.k = [d-ij.k d+ij.k ] / i,j,k d-ij.k d+ij.k
cij {ec ij.1 , ec ij.2 , ..., ec ij.l } U / k,p(1,..,l), kp, (ecij.k ec ij.p )=
Definition 1 (Labeled constraints). labeled elemental constraint lecij.k elemental constraint
ecij.k associated set labels {labelij.k}, labelij.k symbol. labeled constrain lc ij
disjunctive set labeled elemental constraints {lecij.k }. is,
lc ij {lecij.1 , lecij.2 , ..., lecij.l },
lecij.k (ec ij.k {labelij.k }), {labelij.k }{label1 , label2 , ..., labels } set symbols.

label labeled-TCN considered unique symbol. following cases
occur:
i)

input (or explicitly asserted) constraint lc ij one elemental constraint, is,
one disjunct, elemental constraint label 'R0 '. labeled UniversalConstraint {U{R0}}. given TCN, set elemental constraints labeled 'R0 '
common context. Thus, label R0 represents set elemental constraints
alternatives (disjuncts). elemental constraints labeled R0
hold since alternative disjuncts.

ii)

input constraint lc ij one elemental constraint, elemental constraint
lecij.k lc ij single exclusive label associated (|{labelij.k }|=1). Thus, label
TCN represents bi-univocally elemental constraint explicitly asserted
constraint.

iii) derived elemental constraint (obtained combining (lc) intersecting ( lc) two
labeled elemental constraints) set labels associated it. set labels obtained
label sets associated combined (or intersected) labeled elemental constraints.
detailed later specification operations (lc, lc) Section 3.2.
consequence, label set associated derived elemental constraint represents
conjunctive support-set explicitly asserted elemental constraints imply derived
elemental constraint.
Let's see simple example labeled constraints, introduced Dechter, Meiri
Pearl (1991).

42

fiBARBER

{([60 70]{R0})}

t4
{([40 50]{R3}) ([20 30]{R4})}

{([10 20]{R0})}

t3

T0
t2

{([60 ){R1}) ([30 40]{R2})}

T0

{([10 20]{R0} )}

t1

Figure 1: labeled point-based disjunctive metric TCN Example 1

Example 1: "John goes work either car [30'-40'], bus (at least 60'). Fred goes work
either car [20'-30'], carpool [40'-50']. Today John left home (t1)
7:10 7:20, Fred arrived (t4) work 8:00 8:10. know
John arrived (t2) work 10'-20' Fred left home (t3)."
example, disjunctive labeled constraints Figure 1, T0 represents
initial time (7:00) granularity minutes. label 'R0 ' associated elemental
constraints belonging constraints one disjunct. constraints one,
mutually exclusive disjuncts, disjunct labeled exclusive label Rn (n>0). Thus,
label R0 associated "John left home 7:10 7:20", "Fred arrived work
8:00 8:10", "John arrived work 10'-20' Fred left home".
common context.
label R1 associated "John goes bus", R2 "John goes car".
label R3 associated "Fred goes carpool", R4 "Fred goes car".
Definition 2 (Inconsistent-Label-Sets). Inconsistent-Label-Set (I-L-Set) set labels {labeli }
represents set overall inconsistent elemental constraints. is, cannot
simultaneously hold.
Theorem 1. label set superset I-L-Set I-L-Set. proof obvious.
set elemental constraints inconsistent, superset inconsistent.
Definition 3. Elemental constraints {lecij.k} input disjunctive constraint lc ij pairwise disjoint.
Thus, 2-length set labels pair {lecij.k } added set I-L-Sets. is,
input constraint lc ij {lecij.1 , lecij.2 , ..., lecij.l }, lecij.k (ecij.k {labelij.k }) |{labelij.k }|=1:
k,p(1,..,l) / kp, I-L-Sets I-L-Sets ({labelij.k }{labelij.p })
example Figure 1, {R1 R2 } {R3 R4 } I-L-Sets. I-L-Sets existing labeled
TCN detected reasoning processes later detailed Section 4.

43

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

3.2 Operations Labeled Constraints
following points define main operations labeled constraints.
3.2.1 TEMPORAL INCLUSION LC
temporal inclusion operation lc take account inclusion temporal intervals
inclusion associated label sets:
lecij.k lc lecij.p = (ecij.k {labelij.k }) lc (ecij.p {labelij.p }) =def ecij.k ecij.p {labelij.k } {labelij.p }.
3.2.2 TEMPORAL UNION LC
Operation lc performs disjunctive temporal union labeled constraints set-union
elemental constraints. However, labeled elemental constraints whose associated labels I-L-Sets
rejected.
lc ij lc lcij =def lecij.k lc ij , lc [{lecij.k } lcij] ,
lc [{lecij.k } lcij ] = (ec ij.k {labelij.k }) lc lcij =def
Inconsistent({labelij.k }) : lcij
lecij.p lcij / lecij.p lc lecij.k : lcij
: ({lcij } {lecij.k }) - ({lecij.p }, lecij.plcij lecij.k lclecij.p )

(s1 )
(s2 ).

function Inconsistent({labelij.k}) returns true set {labelij.k } I-L-Set superset
existing I-L-Set (Theorem 1). Otherwise, returns false:
Inconsistent({labelij.k }) =def
{labels }Inconsistent-Label-Sets / {labels }{labelij.k } True Else False.
operation lc simplifies resulting constraint. Equal less-restricted elemental constraints
equal bigger associated label sets removed. instance:
{([10 30] {R1 R3 R5 R9}), ([40 40] {R6 R7})} lc {([10 20] {R1 R3}), ([40 40] {R6 R7 R8})} =
{([10 20] {R1 R3}), ([40 40] {R6 R7})}.
resulting constraint, ([10 30] {R1 R3 R5 R9}) ([40 40] {R6 R7 R8}) eliminated, examples
cases s1 s2 , respectively. is, ([10 20] {R1 R3}) lc ([10 30]{R1 R3 R5 R9}) ([40 40] {R6 R7})
lc ([40 40] {R6 R7 R8}). simplifications seem counter-intuitive. However, note label
set associated derived-labeled elemental constraint represents support set (composed
input elemental constraints) derived-labeled elemental constraint obtained. Thus,
minimal associated label set represented, reason efficiency. Moreover,
labels associated label set {labelij.k }, elemental constraint (ecij.k ) equal
restricted.
3.2.3 TEMPORAL COMPOSITION LC
Operation lc performs temporal composition labeled constraints. based operation
underlying disjunctive metric point-based algebra.
44

fiBARBER

lc ij lc lc jk =def lecij.plc ij , lecjk.q lc jk lc [ (ecij.p ecjk.q {labelij.p }{labeljk.q })].
instance: {([0 10] {R1}), ([20 30] {R2})} lc {([100 200] {R3}), ([300 400] {R4})} =
{([320 430] {R4 R2}), ([300 410] {R4 R1}), ([100 210] {R3 R1}), ([120 230] {R3 R2})}.
Note elemental constraints labeled derived constraint may pairwise disjoint.
However, labeled derived elemental constraints cannot simplified. related
fragmentation problem disjunctive metric algebra (Schwalb & Dechter, 1997).
derived-labeled elemental constraint associated label set. example,
(([320 430] {R4 R2}), ([300 410] {R4 R1})) cannot simplified ([300 430] {R4 R2 R1}) since
subinterval depends different set labels (that is, different support-set elemental
constraints). label set {R4 R2 } becomes I-L-Set, ([320 430] {R4 R2}) removed.
hand, [300 410] becomes inconsistent interval implied time points,
{R4 R1 } asserted I-L-Set.
3.2.4 TEMPORAL INTERSECTION LC
Operation lc performs temporal intersection labeled constraints based operation
.
lc ij lc lcij =def lecij.k lc ij , lecij.p lcij , lc [lecij.k lc lecij.p ]
where, lecij.k lc lecij.p =def
ec ij.k ecij.p = {}
;The Inconsistent-Constraint returned.
Else [(ecij.k ecij.p ) ({labelij.k }{labelij.p })]
example:
{([0 10] {R1}), ([20 25] {R2})} lc {([0 30] {R3}), ([40 50] {R4})} = {([20 25] {R3 R2}), ([0 10] {R3 R1})}
operations lc lc, label set {labelij.r} associated derived labeled-elemental
constraint (ecij.r) obtained set-union labels associated combined (lc) intersected
( lc) labeled-elemental constraints. Therefore, {labelij.r} represents support set (composed input
elemental constraints) implies derived elemental constraint (ecij.r).
Definition 4. set I-L-Sets complete represents inconsistent sets TCN elemental
constraints. set I-L-Sets sound I-L-Set represents inconsistent set elemental
constraints.
Theorem 2. Assuming complete sound set I-L-Sets, labeled elemental constraint
consistent iff associated label set I-L-Set. proof trivial, since label
set associated labeled elemental constraint represents support-set.
Theorem 3. Assuming complete sound set I-L-Sets, inconsistent labeled elemental
constraint obtained operations lc lc.
Proof: operations lc lc use operation lc obtain results. operation lc
rejects labeled elemental constraints whose associated labels I-L-Sets. Thus, elemental
constraints derived operations lc lc consistent (Theorem 2).
45

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

3.3 Distributive Property lc lc Disjunctive Labeled Constraints
Operations distributive (i.e.: distributes ) non-disjunctive metric TCN,
property hold disjunctive metric constraints. Dechter, Meiri Pearl (1991) show
following example. Given disjunctive metric constraints:
a= {[0 1], [10 20]},
have:

b= {[25 50]},

c= {[0 30], [40 50]},

(a (b c) = {[25 31], [35 70]}

(a b) (a c) = {[25 70]}.

Thus, clearly (a (b c) (a b) (a c). However, distributive property holds
operations lc lc labeled TCN.
Theorem 4. using labeled constraints I-L-Sets, lc distributes lc.
Proof: Lets consider labeled constraints lc , lc j lc k . Thus,
(lc lc lc j ) lc (lc lc lc k )
expressed, according definition operation lc, as:
(lecp lc , lecq lc j , lc[(lecp lc lecq )]) lc (lecrlc , lecs lc k , lc[(lecr lc lecs)]) =
lecp lc , lecq lc j , lecrlc , lecs lc k (lc[(lecp lc lecq)] lc lc[(lecr lc lecs )])
which, according definition lc, expressed as:
lecp lc , lecq lc j , lecrlc , lecs lc k (lc[(lecp lc lecq ) lc (lecr lc lecs )])

(e1)

expression, lecp lecr elemental constraints same-labeled constraint lc .
However, set-union label sets associated pair elemental constraints (input
derived) labeled constraint I-L-Set (Definition 3). is, lecp lecr, {labelp }{labelr}
I-L-Set. Thus, lecp lecr, label set associated (lecp lc lecq ) lc (lecr lc lecs ) I-LSet. consequence, (lecp lc lecq ) lc (lecr lc lecs ) rejected operation lc. is,
lecp lc , lecq lc j , lecrlc , lecs lc k / lecplecr (lc[(lecp lc lecq ) lc (lecr lc lecs )]) = .
Thus, expression (e1) results:
lecp lc , lecq lc j , lecslc k (lc [(lecp lc lecq ) lc (lecp lc lecs )]).
expression, lc clearly distributes lc elemental constraints (i.e.: non-disjunctive
constraints). Therefore:
lecp lc , lecq lc j , lecslc k (lc [(lecp lc (lecq lc lecs ))]) =
lecp lc , lc [lecp lc (lecqlc j , lecs lc k , lc [lecq lc lecs ])] = lc lc (lc j lc lc k ).
is, lc distributes lc labeled constraints.

instance, following previous example:
a= {[0 1] {R1}, [10 20] {R2}},

b= {[25 50] {R0}},

c= {[0 30] {R3}, [40 50] {R4}}

{R1 R2 }, {R3 R4 } I-L-Sets. Thus, have:
(a lc (b lc c) = {[0 1] {R1}, [10 20] {R2}} lc ({[25 50] {R0}} lc {[0 30] {R3}, [40 50] {R4}}) =
{[0 1] {R1}, [10 20] {R2}}lc {[25 30] {R3 R0}, [40 50] {R4 R0}} =
46

fiBARBER

{[25 31] {R1 R3 R0}, [40 51] {R1 R4 R0}, [35 50] {R3 R2 R0}, [50 70] {R4 R2 R0}}.
Also,
(a lc b) lc (a lc c) =
({[0 1] {R1}, [10 20] {R2}} lc {[25 50] {R0}}) lc
({[0 1] {R1}, [10 20] {R2}} lc {[0 30] {R3}, [40 50] {R4}}) =
{[25 51] {R1 R0}, [35 70] {R2 R0}} lc {[0 31] {R1 R3}, [40 51] {R1 R4} [10 50] {R2 R3}, [50 70] {R2 R4}} =
lc ([25 31] {R1 R3 R0}, [40 51] {R1 R4 R0}, [25 50] {R1 R2 R3 R0},
[50 51] {R1 R2 R4 R0}, [40 51] {R1 R2 R4 R0}, [35 50] {R3 R2 R0}, [50 70] {R4 R2 R0}).
However, {R1 R2 }, {R3 R4 } I-L-Sets. Thus, ([25 50] {R1 R2 R3 R0}, [50 51] {R1 R2 R4 R0}, [40 51] {R1
R2 R4 R0}) removed operation lc. Therefore,
(a lc b) lc (a lc c) = {[25 31] {R1 R3 R0}, [40 51] {R1 R4 R0}, [35 50] {R3 R2 R0}, [50 70] {R4 R2 R0}}.
is, (a lc (b lc c) = (a lc b) lc (a lc c).

4. Reasoning Algorithms Labeled Constraints
Several algorithms reasoning disjunctive constraints applied management
labeled temporal constraints, using lc, lc, lc lc operations. instance, wellknown Transitive Closure Algorithm, general closure algorithms (Dechter, 1992; Dechter et al.,
1991; van Beek & Dechter, 1997), CSP-based approaches, etc. However, Montanari (1974) shows
composition operation distributes intersection, path-consistent TCN
minimal TCN. Theorem 4, lc distributes lc. Thus, application pathconsistent algorithm proposed-labeled TCN obtain minimal TCN. Thus, TCA
algorithm could used closure process labeled constraints, similar way Allen
(1983) uses it. However, incremental reasoning process proposed basis incremental
path-consistent algorithm non-disjunctive metric constraints described Barber (1993).
incremental reasoning process useful temporal constraints initially known
successively deduced independent process; instance, integrated planning
scheduling system (Garrido et al., 1999). proposed reasoning algorithm similar TCA
algorithm. However, updating closure processes performed new input constraint.
Thus, new input constraint updated closured previously minimal TCN (Figure 9).
Therefore, propagation modified constraints closure process needed. Moreover,
proposed reasoning algorithms obtain complete sound set I-L-Sets.
specification reasoning processes described Section 4.1. properties
processes described later Section 4.2.
4.1 Updating Process
Given previous labeled-TCN, composed set nodes {ni }, set labeled constraints {lc ij }
among them, set I-L-Sets, updating process new c ij nodes ni nj
constraint detailed Figure 2.
47

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Updating (ni cij nj)
;cij {ecij., ecij.2 , ..., ecij.l }, disjunctive metric constraint.
lc'ij Put-Labels (cij ), ;An exclusive label associated elemental constraint
ecij.k cij
Consistency-Test (lc ij , lc'ij ) ;Consistency test lc'ij. previously existing
constraint n nj lcij . Moreover, new I-L-Sets
detected.
(*Inconsistent Constraint*)
Return (false)
Else (*Consistent Constraint*)
lc ij lc ij lc lc'ij ,
lc ji Inverselc (lc ij ),
Closure (ni lc ij nj ), ;Closure algorithm updated constraint.
Return (true)
End-If
End-Updating
Figure 2: Updating process labeled constraints
function Put-Labels(cij ) returns labeled-constraint lcij {lecij.1 , lecij.2 , ..., lecij.l },
associating exclusive label elemental constraint cij. one disjunct cij ,
label unique elemental constraint {R0 }. Otherwise, pair labels lcij added
set I-L-Sets, since elemental constraints cij pairwise disjoint (Definition 3). using
Inverse function non-labeled constraints, Inverse lc function is:
Inverselc ({(ec ij.k {labelij.k })}) =def {(Inverse (ec ij.k ) {labelij.k })}
described updating process performed time one new input constraint cij
asserted previous TCN. Thus, initial TCN nodes, constraints, I-L-Sets
assumed (Figure 9). new input constraint (cij ), TCN incrementally updated
closured. is, cij consistent (Consistency-Test function), constraint cij added
TCN, closure process (Closure function) propagates effects TCN, new TCN
obtained. new updating process performed new TCN, successively.
4.1.1. CONSISTENCY-TEST FUNCTION
Consistency-Test function (Figure 3) based operation lc. new input constraint lc'ij
nodes ni nj consistent temporally intersects previously existing constraint
lc ij nodes. Moreover, Consistency-Test function detect new I-L-Sets:
i)

new constraint lc'ij consistent existing constraint lc ij , two elemental
constraints ecij.p lc'ij , ecij.klc ij intersect (ecij.k ecij.p =), label set
{labelij.k }{labelij.p } I-L-Set added current set I-L-Sets.

ii)

existing elemental constraint nodes ni nj (lecij.klc ij) intersect
new constraint lc'ij , {labelij.k } I-L-Set added current set
I-L-Sets.

48

fiBARBER

Consistency-Test (lc ij , lcij ) =
(lc ij lc lcij ) = {}
Return (False)
Else
lecij.k lc ij , lecij.p lc'ij / lecij.k lc lecij.p ={}
I-L-Sets I-L-Sets ({labelij.k }{labelij.p }),
lecij.k lc ij / lecij.k lc lcij = {}
I-L-Sets I-L-Sets {labelij.k },
End-If
Return (True)
End- Consistency-Test
Figure 3: Consistency-Test function
example,
Consistency-Test ({([0 10] {R1}), ([20 25] {R2}), ([100 110] {Ra})},
{([0 30] {R3}), ([40 50] {R4}), ([-50 -40] {Rb})}) = True
since
{{([0 10] {R1}), ([20 25] {R2}), ([100 110] {Ra})} lc {([0 30] {R3}), ([40 50] {R4}), ([-50 -40] {Rb})} =
{([20 25] {R3 R2}), ([0 10] {R3 R1})} {}.
function, label sets {R4 R2 }, {R4 R1 } {Ra} detected I-L-Sets
added current set I-L-Sets, since:
{[20 25] {R2}} lc {[40 50] {R4}}={},
{[0 10] {R1})} lc {[40 50] {R4})}={},
{([100 110] {Ra})} lc {([0 30] {R3}), ([40 50] {R4}), ([-50 -40] {Rb})}={}.
Note {Rb } need detected I-L-Set, since label Rb included
final constraint {([20 25] {R3 R2}), ([0 10] {R3 R1 })} added TCN.
superset I-L-Set I-L-Set (Theorem 1). Moreover, note {R4 R2}, {R4 R1 }
need added set I-L-Sets, since label R4 included final constraint.
Therefore, following simplifications performed time new I-L-Set added
current set I-L-Sets. simplifications modify results reasoning processes,
minimize size set I-L-Sets improve management efficiency.
i)

new I-L-Set superset existing I-L-Set added set I-L-Sets.

ii)

existing I-L-Set superset new I-L-Set, existing I-L-Set removed.

iii) new I-L-Set contains label lc'ij , appear labeled constraint
(lc ij lc lc'ij ) added TCN, added set I-L-Sets.
Lets see example updating consistency-test processes. Lets take labeled-TCN
results Example 1 following constraints updated closured:

49

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Set Inconsistent-Label-Sets: {{R1 R 2}, {R3 R 4}}
{([60 70] {R0})}

t4
{([40 50] {R3})]
([20 30] {R4})}
{([-10 20] {R3 R0})
([10 40] {R4 R0})}

t3
t1

{([-10 20] {R3 R0})
([10 40] {R4 R0})}

T0
{([40 60] {R2 R0})
([70 ) {R1 R0})}

{([40 ) {R1 R3 R0})
([20 ) {R1 R4 R0})
([-10 30] {R2 R4 R0})
([10 50] {R2 R3 R0})}

{([10 30] {R3 R0})
([30 50] {R4 R0})]}

t2

{((- 0] {R1 R0})
([0 30] {R2 R0})}

{([60 ) {R1})
([30 40] {R2})}

T0
{([10 20] {R0})]}

t4
t1

Figure 4: resulting labeled-TCN Figure 1 updating (t3 {[10 20]} t2 )
(t1 {[60 )R1, [30 40] R2 } t2 ), (t3 {[40 50] R3 , [20 30] R4 } t4), (T0 {[10 20]R0 } t1 ), (T0 {[60 70]R0 } t4 ).
resulting labeled-TCN shown Figure 4 set I-L-Set {{R1 R2 }, {R3 R4 }}.
Now, update (t3 {[10 20]R0 } t2 ). previously existing constraint t3 t2 (Figure 4):
{([40 ){R1 R3 R0 }) ([20 ){R1 R4 R0}), ([-10 30] {R2 R4 R0}) ([10 50] {R2 R3 R0})}
Consistency-Test function performs:
{[10 20] {R0}} lc {([40 ){R1 R3 R0 }) ([20 ){R1 R4 R0}), ([-10 30] {R2 R4 R0}) ([10 50] {R2 R3 R0})} =
{[20 20] {R1 R4 R0}, [10 20] {R2 R0} []{R1 R3 R0}} {}

(e1)

Thus, (t2-t3{[10 20] {R0}}) consistent. Moreover, {R1 R3 R0 } detected I-L-Set.
elemental constraints associated {R1 R3 R0 } inconsistent set disjuncts cannot hold
simultaneously. is:
"If today John left home 7:10 7:20 (R0 ), Fred arrived work 8:00
8:10 (R0 ) John arrived work 10'-20' Fred left home (R0 ),
impossible John gone bus (R 1 ) Fred gone carpool (R 3 )."
set I-L-Sets obtained reasoning process considered special derived
constraints, express inconsistency set input elemental constraints. instance,
I-L-Set {R0 R1 R3 } represents (Figure 1):
( (T0 [10 20] T1 ) (T3 [10 20] T2 ) (T0 [60 70] T4 ) (T3 [40 50] T4 ) (T1 [60 ) T2 )).
expression non-binary constraint. type constraints could represented
disjunctive linear constraint, Jonsson Bckstrm (1996), Stergiou Koubarakis (1996)
show. However, input elemental constraints represented derived constraints able
derive inconsistent sets input elemental constraints. model, done means
label sets associated labeled elemental constraints.

50

fiBARBER

4.2 Closure Process
closure process (Figure 5) applied time new input constraint (lc'i j ) updated,
effects lc'ij propagated TCN.
Closure (ni lc ij nj)
(* First loop: Closure n n j n k *)
nk TCN / lc jk {U{R0}}:
lc ik lc ik lc (lc ij lc lc jk ), lc ki Inverse(lc ik)
(* Second loop: Closure n j ni nl *)
nl TCN / lc il {U{R0}}:
lc jl lc jl lc (Inverse(lc ij ) lc lc il ), lc lj Inverse(lc jl )
(* Third loop: Closure nl ni nj nk *)1
nl , nk TCN / lc li {U{R0}}, lc jk {U{R0}}:
lc lk lc lk lc (lc li lc lc ij lc lc jk ), lc kl Inverse(lc lk )
End-Closure
Figure 5: closure process labeled constraints

(3)
nl.1

nl.i

lc il.i

(2)

ni

nk.1
(1)

lcij

nj

nk.i
lcjk.i

nk.t

nl.s

Figure 6: Loops Closure Process
closure process three loops (Figure 6). loops process obtains:

1

i)

Derived constraints lc ik ni node nk , nk previously connected nj
(edge 1 Figure 6).

ii)

Derived constraints lc lj nj node nl , nl previously connected ni
(edge 2 Figure 6).

loop could simplified as:
(*n l n n k*): n l, n k TCN / lc li {U{R0}}, lc j k {U{R0}}:

lc lk lc lk lc (lc li lc lc ik),

(*n l nj n k*): n l, n k TCN / lc li {U{R0}}, lc j k {U{R0}}: lc lk lc lk lc (lc lj lc lcj k)
since lc ik (or lc lj ) already closured first (or second loop). Moreover, efficiency third loop
improved modified constraints first (or second loop) considered.

51

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Set Inconsistent-Label-Sets: {{R1 R2 }, {R3 R4}, {R1 R3 R0}}
{([60 70]{R2 R0}) ([70 70]{R4 R1 R0})}

t4
{([60 60]{R4 R1 R0})
([40 60]{R4 R2 R0})
([50 60]{R3 R2 R0})}

t1 {([10 30]{R4 R2 R0})
([10 20]{R3 R2 R0})
([40 40]{R4 R1 R0})}

{([40 50]{R3 R2 R0})
([20 30]{R4 R2 R0})
([20 20]{R4 R1 R0})}

t3

T0

{([40 50]{R2 R3 R0})
([40 60]{R2 R4 R0})
([70 70]{R1 R4 R0})}

{([10 20]{R2 R0}) ([20 20] {R4 R1 R0})}

{([50 50]{R4 R1 R0})
([20 30]{R3 R2 R0})
([30 50]{R4 R2 R0})}

t2

{([0 0] {R1 R4 R0})
([20 30]{R2 R3 R0})
([0 20]{R2 R4 R0})}

{([30 40]{R2 R0})
([60 60]{R1 R4 R0})}

T0
{([10 20]{ R2 R0}) ([10 10] {R4 R1 R0})}

t4
t1

Figure 7: Labeled-Minimal TCN Example 1
iii) Derived constraints lc lk pair nodes nl nk , nl nk previously
connected ni nj respectively (edge 3 Figure 6).
Lets see previous Example 1 represented Figure 1 Figure 4, consistent
constraint (expression e1):
(t3 {[20 20] {R1 R4 R0}, [10 20] {R2 R0}} t2 )
closured. first loop closure process, have:
lc 30 lc 30 lc ({[20 20] {R1 R4 R0}, [10 20] {R2 R0}} lc lc 20 =
{[-30 -10] {R3 R0 } [-50 -30] {R4 R 0 }} lc
({[20 20] {R1 R4 R0}, [10 20] {R2 R0}} lc {[-60 40] {R2 R0} (- -70] {R1 R0}}) =
{[-30 -10] {R3 R0}} [-50 -30] {R4 R0}} lc
{[-40 -20] {R1 R2 R4 R0}, (- -50] {R1 R4 R0} [-50 20] {R2 R0} (- -50] {R1 R2 R0}}.
However, {{R1 R2 }, {R3 R4 } {R0 R1 R3 }} I-L-Sets. labeled elemental constraints whose
associated label set superset I-L-Sets derived (Theorem 3). Thus:
lc 30 {[-30 -10] {R3 R0}} [-50 -30] {R4 R0}} lc {(- -50] {R1 R4 R0} [-50 20] {R2 R0} }=
{(-30 -20] {R2 R3 R0} [-50 50] {R4 R1 R0} [-50 -30] {R4 R2 R0}}.
Similarly,
lc 31 lc 31 lc ({[20 20] {R1 R4 R0} [10 20] {R2 R0}} lc lc 21 =
{[-20 -10] {R3 R2 R0 } [-40 -40] {R4 R1 R0} [-30 -10] {R4 R2 R0}}
lc 34 lc 34 lc ({[20 20] {R1 R4 R0}, [10 20] {R2 R0}} lc lc 24 =
{[40 50] {R3 R2 R0 } [20 30] {R4 R2 R0} [20 20] {R4 R1 R0}}.
second third loops, final labeled-TCN obtained (Figure 7). final set I-LSets {{R1 R2 }, {R3 R4 } {R0 R1 R3 }}. sets represent sets mutually inconsistent inputelemental constraints exist TCN Figure 1.
52

fiBARBER

4.3 Properties Reasoning Algorithms
section, main properties proposed reasoning algorithms described.
Theorem 5. proposed updating closure processes (Sections 4.1 4.2) guarantee
consistent TCN applied previous minimal (and consistent) TCN.
Proof: updating constraint lcij asserted TCN consistent previous minimal
constraint lc ij (Consistency-Test function).

Theorem 6. proposed closure algorithm obtains path-consistent TCN, applied
previous minimal TCN.
Proof: detailed Barber (1993) non-disjunctive TCNs applied labeled
TCNs. have:
i)

derived constraint exist pair nodes path combines
asserted constraint lc ij .

ii)

closure process computes derived constraint pair nodes (nl , nk )
become connected path across closured constraint lc ij . Lets assume existing path
nodes nx1 , ny1 includes lc ij :
nx1 , nx2 , nx3 , ........, nx, (nj lc ij nj ), ny ......, ny2 , ny1
derived constraint nx1 ny1 computed. However, minimal
constraint (nx1 , ni ) (nj , ny1 ) already exist previous minimal
TCN. consequence, derived constraint (nx1 , ny1 ) computed third loop
process.

iii) previous TCN minimal, possible derived constraints exist
pair nodes (nl, nk ) already computed constraint lclk derived nodes
proposed closure process. third loop, process obtains:
lclk = lc lk lc (lc li lc lc ij lc lc jk ).
Lets suppose exists another path (nl , nk ) across updated lc ij constraint: (nl ,
np , ni , nj , nq , nk ). path computes another derived constraint (nl , nk ):
lc''lk = lc lk lc (lc lp lc lc pi lc lc ij lc lc jq lc lc qk ).
However, since previous TCN minimal, previously existing minimal constraints
lc li lc jk imply (lc lp lc lc pi ) (lc jq lc lc qk), respectively. is, lc li lc(lc lp lc lc pi )
lc jk lc(lc jq lc lc qk ) Thus, lc''lk implicitly implied lclk (lclk lclc''lk ). Here,
assumed associative property lc, obvious definition.
iv) Derived constraints obtained closure process need closured
previous TCN minimal. is, constraint TCN would become restricted
derived constraints closured. Let suppose lc lk modified third loop
closure process:
lclk = lc lk lc (lc li lc lc ij lc lc jk )
propagated (nl , nk , np ) subTCN (Figure 8). Thus, following
derived constraints obtained:
53

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

lclp = lc lp lc (lclk lc lc kp )

lcpq = lc pq lc (lc pl lc lclk ).

constraint lclp , have,
lclp = lc lp lc (lclk lc lc kp ) = lc lp lc ((lc lk lc (lc li lc lc ij lc lc jk )) lc lc kp ).
However, since lc distributes lc,
lclp = lc lp lc ((lc lk lc lc kp ) lc (lc li lc lc ij lc lc jk lc lc kp )).
Since previous TCN minimal, minimal constraints lc pi lc pj previously
exist, lclp lc(lc lk lc lc kp ) lc jp lc(lc jk lc lc kp ). Thus,
lclp lc lc lp lc (lc li lc lc ij lc lc jp ).
However, third loop closure process, following derived constraint
computed:
lc''lp = lc lp lc (lc li lc lc ij lc lc jp ).
Thus, lclp already represented obtained constraint lc''lp (that is, lc''lp lc lc'lp ).
similar way,
lc''pq = lc pq lc (lc pi lc lc ij lc lc jq )
obtained proposed closure process, lc''pq lc lc'pq .
Therefore, derived constraint (any combinable path across lc ij ) pair nodes
TCN computed, closure process obtains path-consistent TCN.

np

lclp

lcpk

lclk

nl
lclj

lc ij

ni

nk
nj

lcjk

Figure 8: lc lk propagated lc lp lc pq
Theorem 7. proposed reasoning processes obtain minimal TCN, previous TCN
minimal TCN.
Proof: Montanari (1974) shows composition distributes intersection (i.e.:
distributes ), path-consistent TCN minimal TCN). case nondisjunctive metric TCNs (Dechter et al., 1991). case, lc distributes lc (Theorem 4)
closure process obtains path consistent TCN (Theorem 6). Therefore, proposed reasoning
processes obtain minimal TCN.

54

fiBARBER

New input
constraint

INITIAL
TCN
nodes,
constraints, I-L-Sets

Input Constraint
( ni lcij nj )
(ni lcij nj ) consistent
Reasoning Process: Updating + Closure processes
Consistency-Test: Consistent TCN
Closure Process: Path-Consistent TCN.
Distributive Property ( lc lc): Minimal
New consistent minimal TCN
New complete sound set I-L-Sets

Figure 9: incremental reasoning process
Theorem 8. updating process, reasoning algorithms obtain complete sound new set
I-L-Sets (Definition 4), applied previous minimal TCN previous sound
complete set I-L-Sets.
Proof:
i) new set I-L-Sets complete. consistency test updated constraint lc'ij obtains
possible new I-L-Sets appear lc'ij added TCN, except I-L-Sets
related mutual exclusion disjuncts lc'ij (which determined
Put-Label function):
a) new I-L-Sets appear label lc'ij participate. Otherwise,
would detected previous updating process, since previous set
I-L-Sets assumed complete. Thus, label lcij always participate
new I-L-Set appears lcij updated.
b) new I-L-Sets (in label lcij participates) detected consistency
test lcij. Let's assume new undetected I-L-Set exists {Rk , R1 , R2 , ....., Rp }
new elemental constraint eck{Rk}lc'ij takes part. Thus, elemental
constraints associated {R1 , R2 , ....., Rp } compute derived elemental constraint ecx
nodes ni nj :
(ecx {R1, R2, ....., Rp})

/

(ecx {R1, R2, ....., Rp}) lc (eck{Rk}) =

elemental constraint ecx already represented previously existing constraint lc ij

55

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

ni nj since previous TCN minimal2 . Thus, eck ecx=, I-LSet {Rk , R1 , R2 , ....., Rp } detected consistency test lcij . conclusion, new
inconsistent sets elemental constraints lc'ij participates detected
new I-L-Sets exist. Therefore, new set I-L-Sets complete previous set
I-L-Sets complete.
ii) new set I-L-Sets sound. new I-L-Sets obtained represent inconsistent sets
elemental constraints. trivial, given consistency test function.
conclusion, proposed reasoning algorithms obtain minimal (and consistent) TCN
applied previous minimal-TCN (Figure 9). Therefore, reasoning algorithms guarantee
TCN consistency obtain minimal TCN complete sound set I-L-Sets new
input assertion.
4.4 Global Labeled-Consistency
minimal (binary) disjunctive network, every subnetwork size two globally consistent
(Dechter, 1992). Therefore, local consistent instantiation subset two variables
extended full consistent instantiation. However, assure local consistent instantiation
subset two variables overall consistent, partial instantiation propagated
whole TCN (van Beek, 1991). Thus, assembling TCN solution become costly
propagation process disjunctive TCNs, even though minimal TCN used. proposed
reasoning processes maintain complete sound set I-L-Sets (Theorem 8). Thus, deduce
locally consistent set elemental constraints overall consistent means label sets
associated labeled elemental constraints set I-L-Sets. Specifically, deduce
whether locally consistent instantiation k variables (1<k<n) overall consistent. Lets see
following example, based previous one proposed Dechter, Meiri Pearl (1991):
Example 2: "Dave goes walking work [25 50]. John goes work either car
[10 30'], bus [45 60]. Fred goes work either car [15' 20'],
carpool [35' 40'], walking [55 60]. Today, left
home 6:50 7:50 (at t1, t2 t3 time-points), arrived
work time (t4 ) 8:00."
Here, following labeled disjunctive constraints where, T0 represents initial time
(6:50) granularity minutes:
t1 - T0 {[0 60]R0 },
t4 - 1 {[25 50]R0 },

2 - T0 {[0 60]R0 },

3 - T0 {[0 60]R0 },

4 2 {[10 30]R1 , [45 60]R2 },

4 - T0 {[0 70]R0 },

4 3 {[15 20]R3 , [35 40]R4 , [55 60]R5 }.

minimal TCN Example 2 represented Figure 10. Here, binary constraints
time-point T0 represent unary constraints restrict interpretation domains variables
(t1 , t2 , t3 , t4 ). Obviously, minimal TCN globally consistent TCN. instance,

2

elemental constraint ec x already represented explicit way, means another elemental constraint ecy
(ecy Tec x, {labely }{R1, R2, ....., Rp}) due simplification process performed operation lc . cases,
ec kec x=, ec kecy =.

56

fiBARBER

instantiations {(t1 =0), (t2=0), (t3=0)} consistent existing constraints involved among (T0 ,
t1 , t2 , t3 ), partial solution cannot extended overall TCN.

{[0 45]}

t1
{[25 50]}

{[-35 35]}
{[0 55]}

T0
{[-35 40}]

t3

{[15 20] [35 40] [55 60]}

t4

{[-50 45]}
{[10 30] [45 60]}

{[0 60]}

t2

{[25 70]}

Figure 10: Minimal TCN Example 2
Lets consider TCN labeled constraints. reasons simplicity, denote
labeled constraints among (T0 , t1 , t2 , t3 ):
(T0 {[5 45]{R0 R5}, [0 45]{R0 R4}, [0 45]{R0 R3}} 1 ),
(T0 {[0 25]{R2 R0}, [5 60]{R1 R0 R4}, [25 60]{R1 R0 R5}, [0 60]{R1 R0 R3}} 2 ),
(T0 {[25 55]{R0 R2 R3}, [0 15] {R0 R5}, [0 35]{R0 R1 R4}, [5 55]{R0 R1 R3}, [5 35]{R0 R2 R4}} 3 ),
(t 1 {([-5 35]{R0 R2}, [-40 5] {R0 R1}} 2 ),
(t 1 {[-15 15]{R0 R4}, [-35 -5]{R0 R3}, [5 35]{R0 R5}} 3 ),
(t 2 {[5 30] {R1 R0 R4}, [-45 -25]{R2 R0 R3}, [25 50]{R1 R0 R5}, [-15 10]{R1 R0 R3}, [-25 -5]{R2 R0 R4}, [-5 15]{R2 R0 R5}} t3 ).

set I-L-Sets {{R1 R2 } {R3 R4 } {R3 R5 } {R4 R5}}. labeled TCN set
I-L-Sets, deduce instantiations {(t1 =0), (t2 =0), (t3 =0)} overall consistent.
instantiations locally consistent labeled constraints subTCN (T0 , t1 , t2 , t3 ):
label sets associated possible simultaneous fulfillment
(T0 {[0 0]} 1 ), (T0 {[0 0]} 2 ) (T0 {[0 0]} 3 )

I-L-Sets. is, label sets Cartesian product
{{R0 R4 } {R0 R3 }} {{R2 R0 } {R1 R0 R3 }} {{R0 R5 } {R0 R1 R4 }}

I-L-Sets. Thus, set I-L-Sets used deduce consistency set labeled elemental
constraints obtain globally consistent labeled-TCN.
Theorem 9. Lets assume labeled-TCN n nodes (and corresponding complete sound set
I-L-Sets) local set k (1k( n2 )) labeled elemental constraints TCN, one
pair nodes:
{lec1 , lec2 ,....., leck } {(ec 1 {label1 }), (ec2 {label2 }), ..., (ec k {labelk })}.

57

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

local set labeled elemental constraints {lec1 , lec2 , ... , leck }is overall consistent iff setunion associated label sets (i=1,k {labeli }) I-L-Set.
Proof: label set (i=1,k {labeli }) support-set simultaneous fulfillment {lec1 , lec2 ,
--- , leck }. Moreover, set I-L-Sets complete sound respect overall TCN (Theorem
8), label set set I-L-Set overall consistent. Therefore (Theorem 2),
(i=1,k {labeli }) {lec1 , lec2 , ... , leck } overall consistent iff i=1,k {labeli } I-L-Set.
Definition 5 (Labeled-consistency3 ): Lets assume labeled-TCN n nodes (and corresponding
complete set I-L-Sets) set k (1k(n2 )) constraints, one pair
nodes TCN:
{c ij } / 1in, 1jn, ij.
set constraints {c ij } labeled-consistent respect nodes involved
constraints, iff:
i)

constraint cij , exists elemental labeled constraint elc ij.x (ni , nj )
TCN elc ij.x satisfies cij . is: cij , elc ij.xlc ij / c ij ecij.x .

ii)

resulting set union label sets associated elemental labeled constraints
(which satisfy {c ij }) I-L-Set: U cij{label ij.x} I-L-Set. Note
condition Theorem 9.

Theorem 10. Lets assume labeled-TCN n nodes (and corresponding complete set I-LSets) set k (1k( n2 )) constraints, one pair nodes
TCN:
{c ij } / 1in, 1jn, ij.
set constraints {c ij } overall consistent iff {c ij } labeled-consistent respect
nodes involved constraints {c ij }.
Proof: proof trivial according Definition 5 Theorem 9. set
constraints {c ij } consistent iff exists local set elemental constraints TCN {elc ij.x}
makes {c ij} labeled-consistent (Definition 5). Thus, local set {elc ij.x} consistent (Theorem
9), {c ij } consistent.
instance, determine whether pair constraints c' ij c'kl hold simultaneously
(that is, overall consistent) if:
elc ij.xlc ij / c' ij ecij.x elc kl.yckl / c'kl eckl.y {labelij.x}{labelkl.y }
I-L-Set.
Moreover, local instantiation k-1 (1<kn) variables {t1 =v1 , t2 =v2 , ..., t(k-1)=v(k-1)}
extended global solution if:
elc 10.xlc 10 / v1ec10.x,...... , elc (k-1)0.ylc (k-1)0 / v(k-1)ec10.x,
lc i0 constraint ni T0 , {label10.x}{label20.y } .... {label(k-1)0.y }is
I-L-Set.
3

need introduce concept labeled-consistency since different concept consistency concept.

58

fiBARBER

instance, Example 2 Figure 10, partial instantiation {(t1 =0), (t2 =5), (t3 =5)}
consistent. have:
([0 45]{R0 R3})lc10 / 0[0 45],

([0 60]{R1 R0 R3})lc20 / 5[0 60],

([5 55]{R0 R1 R3})lc30 / 5[5 55],

{R0 R3 }{R0 R1 R3}{R0 R1 R3 }={R0 R1 R3 } IL-Set. Thus, partial solution
extended global solution. instance, {(t1 =0), (t2 =5), (t3 =5), (t4 =25)}.
Therefore, labeled-TCN considered globally labeled-consistent TCN. is,
basis concepts introduced Dechter (1992):
Definition 6. (Local Labeled-consistency): partial instantiation variables (1k<n) {t1 =v1 , t2 =v2 ,
..., tk =vk } local labeled-consistent labeled-consistent respect (T0 , t1 , t2 , ..., tk ) nodes.
holds k=n.
Definition 7. (Global Labeled-consistency): labeled sub-TCN (with global set I-L-Sets)
global labeled-consistent partial instantiation variables sub-TCN, local
labeled-consistent, extended overall TCN. globally labeled-consistent TCN one
sub-TCNs globally labeled-consistent.
Theorem 11. new assertion, proposed reasoning processes obtain globally labeledconsistent TCN, applied previous minimal TCN previous sound complete
set I-L-Sets.
Proof: proof trivial according previous definitions (Definition 6 Definition 7)
properties reasoning processes (Theorem 7 Theorem 8). partial instantiation
subTCN, labeled-consistent respect nodes involved partial
instantiation, overall consistent (Theorem 10).
Similar expressions made k-labeled-consistency strong k-labeled-consistency
basis concepts provided Freuder (1982). Therefore, set I-L-Sets labeled-TCN
provides useful way assure whether local instantiation variables part global
solution. Moreover, Freuder (1982) shows strong k-consistent TCN, consistent instantiations
variables subnetwork size k found backtrack-free manner variable
ordering. consequence decomposability (Montanari, 1974; Dechter et al., 1991)
globally consistency (Dechter, 1992) properties. Obviously, feature holds labeled
TCNs.
4.5 Analysis Temporal Complexity
Lets analyze computational cost proposed reasoning processes. processes are,
basically, incremental path-consistent algorithm (Barber, 1993). updating process
new input constraint TCN n nodes, computational cost updating closure
processes bounded 'n2 (O(lc) + O(lc))'. proposed reasoning process, path-consistent
algorithm obtains minimal disjunctive metric TCN. possible due management
labeled constraints, associated label sets, I-L-Sets. Thus, complexity reasoning processes
mainly due (instead complex closure process) management complex data structures
(labeled constraints, associated label sets, I-L-Sets). is, complexity proposed

59

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

reasoning processes mainly due complexity operations lc lc.
computational cost lc lc depends number elemental constraints labeled
constraints, size associated label sets, size I-L-Sets previous minimal labeled
TCN. Let 'n' number nodes, 'l' maximum number disjuncts (or labels) input
constraints, 'e' number updated input constraints previous TCN. maximum
number labels TCN l*e, since disjunct updated input labeled constraint
own, unequivocal label. Moreover, I-L-Set maximum one label input
labeled constraint lc ij , since: (i) elemental constraints lc ij pairwise disjoint, pair
labels lc ij added set I-L-Sets, (ii) superset existing I-L-Set
I-L-Set. Thus, maximum number labels I-L-Set e. Furthermore, label I-LSet different input labeled constraint. e input labeled constraints,
input labeled constraint maximum l labels. Thus, maximum number I-L-Sets q-length
(1qe) (( qe ) lq ).
Therefore, number i-length (1ie) I-L-Sets i=1,e (( ei ) li ) = O(2e le). However,
superset I-L-Set already known inconsistent, supersets stored set
I-L-Sets. Thus, number I-L-Set bounded O(le). Additionally, e*( l2 ) I-LSets 2-length, since l disjuncts updated constraint mutually exclusive among them.
Similarly, maximum number associated label sets bounded O(le), one
maximum e labels. Thus, number elemental constraints (or labeled subintervals)
labeled constraint bound O(le), since elemental constraint labeled constraint
associated label set.
According parameters, computational cost updating process bounded
O(n2 l3e). recovery process constraints constant cost, since minimal-TCN always
maintained. computational cost proposed algorithms agreed computational cost
inherent problem management disjunctive metric constraints (Dechter, 1991). fact,
closure process could considered integrated management le alternative nondisjunctive TCNs disjunctive TCN split, shown Dechter, Meiri Pearl
(1991). noted l bounded typical problems scheduling,
usually l 2 (Garrido et al., 1999), restricting domain size (range granularity) metric
algebras. hand, several improvements made described processes.
example, efficient management label sets direct influence efficiency
reasoning processes. Thus, label set (for instance, {R3 R5 R8 }) considered
unidimensional array bits, binary representation integer number (for instance
(23 +25 +28 )). Therefore, associated label set represented number set I-L-Sets
becomes set numbers. Matching set-union processes label sets operations lc lc
efficiently performed means operations integer numbers constant cost.
Therefore, computational cost bounded O(n2 l2e).
alternative implementations study. Two different approaches exist temporal
constraint management (Brusoni et al., 1997; Yampratoom, Allen, 1993; Barber, 1993). first
approach maintain closured TCN recomputing TCN new input constraint
making derived constraints explicit. Here, queries answered constant time, although
implies high spatial cost. second approach explicitly represent input constraints,
spatial requirements minimum. However, computation needed query time
consistency new input constraint tested. proposed reasoning methods hold
60

fiBARBER

first approach, seems appropriate problems queries TCN
usual tasks updating processes.
addition, proposed reasoning algorithms obtain sound complete set I-L-Sets
globally labeled-consistent TCN. Regrettably, assembling solution labeled TCN, although
backtrack free, costly due exponential number I-L-Sets. However, features offer
capability representing managing special types non-binary disjunctive constraints (later
detailed Section 6).
reasoning algorithms query processes non-closured TCN, well CSP
approaches defined basis labeled temporal algebra described. Less expensive
algorithms applied labeled constraints using specified operations lc, lc, lc
lc. instance, TCA algorithm applied Allen (1983), k-consistency algorithms
described (Cooper, 1990; Freuder, 1978). Moreover, minimal TCN labeled
constraints obtained without enforcing global consistency; example, applying naive
backtracking algorithm described Dechter, Meiri Pearl (1991), O(n3 le).

5. Interval-Based Constraints Labeled Point-Based Constraints
integration quantitative qualitative information goal several temporal
models, described Section 1. intervals represented means ending
points Ii + Ii -, integration constraints intervals points seems require kind nonbinary constraints time-points (Gerevini & Schubert, 1995; Schwalb & Dechter, 1997;
Drakengren & Jonsson, 1997). section, proposed temporal model applied order
integrate interval point-based constraints. Constraints intervals managed means
constraints ending points intervals I-L-Sets. Likewise, metric information added
interval constraints expressive way integrating qualitative quantitative
constraints obtained.
5.1 Symbolic Interval-Based Constraints
Symbolic constraints intervals express qualitative temporal relation two intervals.
symbolic constraint disjunctive subset 13 elemental constraints, mutually
exclusive among (Allen, 1983). example, following constraint
I1 {ec 1 , ec2 } I2 ,

ec1 , ec2 {b, m, o, d, s, f, e, bi, mi, oi, di, si, fi},

really means 'I1 [ (ec1 ec2 ) (ec1 ec2 ) ] I2', since ec 1 ec 2 mutually exclusive, one
one elemental constraint hold. reasons simplicity, consider two disjuncts
symbolic constraint. However, expressions easily extended managing
2 13 disjuncts. expression expressed as:
I1 [ (ec1 ec2 ) (ec1 ec2 ) ] I2
I1 [ (ec1 ec1 ) (ec 2 ec2 ) (ec1 ec2 ) (ec1 ec2 ) ] I2
way, have:

61

(e2).

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

i)

constraints [I1 (ec1 ec1 ) I2 ] [I1 (ec2 ec2 ) 2 ] expressed disjunctive
metric constraints pairs time-points,

ii)

constraints [I1 (ec 1 ec2 ) I2 ] [I1 (ec1 ec2 ) I2 ] expressed mutual
exclusion among associated labels point-based constraints. is, set
I-L-Sets.

present simple example illustrate conclusions. instance, (I1 {before after} I2 )
expressed means constraints among time points I1 -, I1 +, I2 - I2 +, as:
[I1 {b a} I2 ] (I1 + {(0 ){Rb1}} I2 -) (I1 - {(- 0){Ra1}} I2 +).
Thus, intervals represented means ending points Ii + Ii -, interval-based
constraint gives rise disjunctive constraints different pairs time points (i.e.: non-binary
constraints). non-binary constraints represented I-L-Sets. Thus, according
expression (e2),
[I1 {b a} I2] [I1 (b b) I2 ] [I1 (a a) I2 ] [I1 (b a) I2 ] [I1 (b a) I2 ],
have:
I1 I2 I1 + {(0 ){Rb1}} I2 -,
I1 I2
I1 + {(- 0]{Rb2}} I2 -,

I1 I2 I1 - {(- 0){Ra1}} I2 +,
I1 I2 I1 - {[0 ){Ra2}} I2 +.

Therefore, [I1 {b a} 2 ] expressed as:
[I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -] [I1 - {(- 0){Ra1} [0 ){Ra2}} I2 +]
[ (I1 + {(0 ){Rb1}} I2 -) (I1 - {(- 0){Ra1}} I2 +) ]
[ (I1 + {(- 0]{Rb2}} I2 -) (I1 - {[0 ){Ra2}} I2 +) ],
equivalent (by using labels associated elemental constraint):
[I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -] [I1 - {(- 0){Ra1} [0 ){Ra2}} I2 +]
{Rb1 Ra1},{Rb2 Ra2} I-L-Sets, one one disjunctive symbolic constraint
holds.
Thus, symbolic constraints intervals represented means of: (i) set
disjunctive metric constraints time-points, (ii) set I-L-Sets. Table 1,
equivalent metric constraints interval ending time points elemental interval-based
constraint detailed. According table, following steps allow us represent disjunctive
symbolic constraints intervals means disjunctive metric constraints interval
ending points I-L-Sets:
i)

interval represented means ending points Ii +, Ii-. default, (I - {(0, ){R0}}
Ii +) holds.

ii)

symbolic constraint two intervals (Ii cij Ij) composed disjunctive set
(from 1 13) elemental symbolic constraints cij ={ecij.k }{b, m, o, d, s, f, e, bi, mi, oi, di,
si, fi}.

iii) elemental symbolic constraint ec{b, m, o, d, s, f, e, bi, mi, oi, di, si, fi} represented
62

fiBARBER

conjunctive set disjunctive point-based metric constraints (fourth column Table
1). conjunctive set point-based constraints expresses fulfillment nonfulfillment (ec ec) elemental symbolic constraint ec.
iv) disjunctive set cij ={ecij.k } elemental symbolic constraints Ii Ij represented
by:


conjunctive set disjunctive point-based metric constraints time-points
Ii +, Ii -, Ij+ I-j . conjunctive set composed constraints fourth column
Table 1 elemental constraint {ecij.k }.



set I-L-Sets expresses logical relation among elemental symbolic
constraints {ec ij.k }. is, 'one one elemental symbolic constraint {ecij.k}
hold':
iv.a) one elemental constraint {ecij.k } hold. condition
need represented since different sets point-based constraints
correspond fulfillment different elemental symbolic constraints (second
column Table 1) already mutually exclusive.
iv.b)

One elemental symbolic constraints {ecij.k } hold. Let
label sets, label set corresponds point-based constraints
related non-fulfillment elemental symbolic constraint {ec ij.k }
(third column Table 1). Thus, Cartesian product among label sets
set I-L-Sets.

instance, I1 {b di} I2 represented as:
(I1 - { (0 ){R0}} I1 +), (I2 - { (0 ) {R0}} I2 +),

I1 {b b} I2 (I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -),
I1 {m m} I2 (I1 + {[0 0] {Rm1} (0 ){Rm2} (- 0){Rm3}} I2 -),
I1 {s s} I2 (I1 - {[0 0] {Rs1} (0 ){Rs3} (- 0){Rs4}} I2 -) (I1 + {(0 ){Rs2} (- 0]{Rs5}} I2 +),
I1 {di di} I2 I2 {d d} I1 (I2 - {(- 0){Rd1} [0 ){Rd3}} I1 -) (I2 + {(0 ){Rd2} (- 0]{Rd4}} I1 +).

Moreover, one symbolic constraints {b, m, s, di} hold. Thus (according Point
iv.b method), Cartesian product associated labels related non-fulfillment
elemental symbolic constraints {b, m, s, di}. is:
{{Rb2 }{Rm2 , Rm3 }{Rs3 , Rs4 , Rs5 }{Rd3 , Rd4 }

explicitly included set I-L-Sets.
applying method, qualitative interval-based constraints fully integrated
proposed labeled point-based constraints. case, interpretation domain time-points {Ii Ii +} restricted three values ({D}={(-, 0), [0 0], (0 )}), that, l=3. Therefore,
computational cost reasoning algorithms bounded O(n2 3 2e).
illustrate proposed method, lets show typical example symbolic interval-based
constraints (Figure 11.a), given Allen (1983). example shows interval-based
constraints represented managed means disjunctive metric point-based constraints
minimal IA-TCN obtained.
63

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Ii ecij.k Ij

Ii ecij.k Ij

Ii ecij.k Ij

Ii (ecij.k ec
ij.k) Ij

Ii Ij

Ii + {(0 ){Rb1}} Ij -

Ii + {(- 0]{Rb2}} Ij -

Ii + {(0 ){Rb1} (- 0]{Rb2}} Ij -

Ii meets Ij

Ii + {[0 0]{Rm1}} Ij -

Ii + {(0 ){Rm2} (- 0){Rm3}} Ij -

Ii + {[0 0]{Rm1} (0 ){Rm2} (- 0){Rm3}} Ij -

Ii Ij

Ii - {(- 0){Rd1}} Ij -

(Ii - {[0 ){Rd3}} Ij -)

Ii - {(- 0){Rd1} [0 ){Rd3}} Ij -

Ii + {(0 ){Rd2}} Ij +
Ii starts Ij

Ii + {[0 0]{Rf1}} Ij +
-

Ii {(- 0){Rf2}} Ij

-




Ii + {(0 ){Rd2} (- 0]{Rd4}} Ij +
Ii - {[0 0]{Rs1} (0 ){Rs3} (- 0){Rs4}} Ij Ii + {(0 ){Rs2} (- 0]{Rs5}} Ij +

(Ii + {(- 0]{Rs5}} Ij +)

(Ii + {(0 ){Rf3} (- 0){Rf4}} Ij +)

Ii + {[0 0]{Rf1} (0 ){Rf3} (- 0){Rf4}} Ij +

(Ii {[0 ){Rf5}} Ij )
-

Ii - {(- 0){Rf2} [0 ) {Rf5}} Ij -

-

(Ii + {[0 ){Ro4}} Ij -)

+
Ii overlaps Ij Ii {(- 0){Ro1}} Ij

Ii equal Ij

(Ii + {(- 0]{Rd4}} Ij +)

(Ii - {(0 ){Rs3} (- 0){Rs4}} Ij -)

Ii - {[0 0]{Rs1}} Ij Ii + {(0 ){Rs2}} Ij +

Ii finishes Ij



Ii + {(- 0){Ro1} [0 ){Ro4}} Ij -

Ii + {(0 ){Ro2}} Ij +



(Ii + {(- 0]{Ro5}} Ij +)

Ii + {(0 ){Ro2} (- 0]{Ro5}} Ij +

Ii - {(0 ){Ro3}} Ij -



(Ii - {(- 0]{Ro6}} Ij -)

Ii - {(0 ){Ro3} (- 0]{Ro6}} Ij -

Ii + {[0 0]{Re1}} Ij +

(Ii + {(0 ){Re3} (- 0){Re4}} Ij +)

Ii + {(0 ){Re3} [0 0]{Re1} (- 0){Re4}} Ij +

Ii - {[0 0]{Re2}} Ij -

(Ii - {(0 ){Re5} (- 0){Re6}} Ij -)

Ii - {(0 ){Re5} [0 0]{Re2} (- 0){Re6}} Ij -

Table 1: Interval-based constraints equivalent disjunctive metric constraints
interval ending points (Cells second fourth columns conjunctive set constraints)

Symbolic
Constraint
(IA {d di} IB)



(IB {d di} IC)



(ID {m s} IA)



(ID {o} IB)



(ID {m s} IC)



Disjunctive Metric Constraint I+ I-

Inconsistent-Label-Sets

IA - {(- 0){R1} [0 ){R3}} IBIA + {(0 ){R2} (- 0]{R4}} IB+
IB- {(- 0){R5} [0 ){R7}} IA IB+ {(0 ) {R6} (- 0]{R8}} IA +

{R4 R8 } {R3 R8 }
{R4 R7 } {R3 R7 }

IB- {(- 0){R9} [0 ){R11}} ICIB+ {(0 ) {R10} (- 0]{R12}} IC+
IC- {(- 0){R13} [0 ){R15}} IBIC+ {(0 ) {R14} (- 0]{R16}} IB+
+
ID {[0 0]{R17} (0 ){R18} (- 0){R19}} IA ID- {[0 0]{R20} (0 ){R22} (- 0){R23}} IA ID+ {(0 ){R21} (- 0]{R24}} IA +
ID+ {(- 0){R0}} IBID+ {(0 ){R0}} IB+
ID- {(0 ){R0}} IBID+ {[0 0]{R25} (0 ){R26 (- 0){R27}} ICID- {[0 0]{R28} (0 ){R30} (- 0){R31}} ICID+ {(0 ){R29} (- 0]{R32}} IC+

{R12 R16 } {R11 R16 }
{R12 R15 } {R11 R15 }
{R19 R24 } {R18 R24 } {R19 R23 }
{R18 R23 } {R19 R22 } {R18 R22 }

{R27 R32 } {R26 R32 } {R27 R31 }
{R26 R31 } {R27 R30 } {R26 R30 }

Table 2: Symbolic constraints Figure 11.a means disjunctive metric
constraints I+, I-

64

fiBARBER

Figure 11.a represents path-consistent IA-TCN, inconsistent values constraints
(Allen, 1983). Table 2, interval-based symbolic constraints example,
corresponding disjunctive metric constraints ending time -points (Ii +, Ii -)
corresponding set I-L-Sets (according Table 1). Moreover, have:
(IA -{(0 ){R0}}IA +), (IB-{(0 ){R0}}IB+), (IC-{(0 ){R0}}IC+ ) (ID- {(0 ){R0}}ID+).

metric constraints among ending time-points intervals updated according
proposed methods Section 4, labeled minimal TCN Table 3 obtained. associated
labels elemental constraint (disjunct) constraints included reasons brevity.




{s,m}


{s,m}

{o}

{d, di}



B

{d,di}

{d, oi, f, e, fi,
si, s, , di}

{o}

{d, di}

B

{d,di}

{s,m}

{s,m}
{d, di, s, si, e}

C

a) Path-Consistent IA-TCN

C

b) Minimal IA-TCN

Figure 11: Path-Consistent equivalent Minimal IA-TCN

IA+
IA+

IA-

IB+

{(- 0)}

{(0 ),
(- 0)}
{(0 )}

IA-

{(0 )}

IB+

{(- 0), {(- 0)}
(0 )}

IB-

{(0 )}

{(0 ),
(- 0)}

IB-

{(0 )}

{[0 0],
(0 )}

{(- 0),
(0 )}
{(- 0)}

{(0 )}

{(0 )}

IC-

ID+

ID-

{(- 0)} {(- )} {(- 0)} {(- 0)} {(- 0)}
{(0 )}

{(- 0), {[0 0], {(- 0),
[0 0],
(0 )}
[0 0]}
(0 )}
{(- 0), {(- 0)} {(- 0)} {(- 0)}
(0 )}
{(0 )}

IC+ {(- )} {(- 0)} {(- 0), {(- 0)}
(0 )}
IC
{(0 )} {(- 0), {(0 )} {(- 0),
[0 0],
(0 )}
(0 )}
ID+ {(0 )} {(- 0), {(0 )} {(- 0)}
[0 0]}
ID-

IC+

{(0 )}

{(- 0),
(0 )}

{(0 )}

{(- 0)}

{(- 0)} {(- 0)} {(- 0)}
{(0 )}

{(0 ),
[0 0]}

{(0 )}

{(- 0),
[0 0]}

{(0 )}

{[0 0],
(0 )}

{(- 0),
[0 0]}
{(- 0)}

{(0 )}

Table 3: minimal metric point-based TCN IA-TCN Figure 11.a
65

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Allen (1983) remarks symbolic constraint (IA {f fi} IC) cannot hold given existing
constraints IA, IB, IC ID. labeled point-based TCN, (IA {f fi} IC) represented
set constraints among ending points IA IC. Moreover, labels associated
labeled elemental constraint allow us determine whether set elemental constraints
different pairs time-points part global solution (Theorem 10). Thus, deduce
whether (IA {f fi} IC) hold point-based TCN.
existing constraints ending time-points IC IA, associated labelsets are:
IC+ {(- ){R25 R30 R29 R17 R22 R21 R0){R27 R28 R29 R19 R20 R21 R0},
(- 0){R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R0 R8},
(0 ){R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R0 R6}} IA+
IC-

{(0 ){R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0},
[0 0] {R25 R30 R29 R17 R22 R21 R0}{R27 R28 R29 R19 R20 R21 R0},
(- 0){R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0}} IA-

Let's ask disjunct (IA {f fi} IC):
i) constraint (IA {f} IC) implies (IC+ {[0 0]} IA+) (IC- {(- 0)} IA-). According
Theorem 10, constraints hold iff set-union label sets associated (IC+ [0 0]
IA+) (IC- (- 0) IA-) I-L-Set. two possibilities:
i.1) {R25 R30 R29 R17 R22 R21 R0 } {R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0 } =
{R6 R5 R4 R3 R20 R19 R25 R30 R29 R17 R22 R21 R11 R12 R13 R14 R0 },
i.2)

{R27 R28 R29 R19 R20 R21 R0 } {R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0 } =
{R14 R13 R12 R11 R30 R25 R27 R28 R29 R19 R20 R21 R3 R4 R5 R0 R6 }.

However, label sets (i.1, i.2) I-L-Sets: instance, {R19 R22 } {R27 R30 } I-LSets (Table 2) subsets i.1 i.2, respectively. Thus, (IA {f} IC) hold.
ii) constraint (IA {fi} IC) implies (IC+ {[0 0]} IA+) (IC- { (0 )} IA-). Similarly:
ii.1) {R25 R30 R29 R17 R22 R21 R0 } {R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0 } =
{R16 R15 R10 R9 R28 R27 R25 R30 R29 R17 R22 R21 R1 R2 R7 R0 R8 }.

label set I-L-Set. instance, {R30 R27 } I-L-Set. Also,
ii.2) {R27 R28 R29 R19 R20 R21 R0 } {R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0 } =
{R8 R7 R2 R1 R22 R17 R27 R28 R29 R19 R20 R21 R9 R10 R15 R16 R0 }.

label sets (ii.1, ii.2) I-L-Sets. instance, {R 30 R27} {R19 R22 } I-LSets. Thus, (IA {fi} IC) hold either.
conclusion, symbolic constraint (IA {f fi} IC) cannot hold globally labeled-consistent
point-based TCN. conclusion could obtained minimal IA-TCN (Figure 11.b).
Additionally, (IA {f fi} IC) implies (IA+ [0 0] IC+). is, constraint (IA+ [0 0]
IC+) holds, associated constraints label sets {R25 R30 R29 R17 R22 R21 R0 }
{R27 R28 R29 R19 R20 R21 R0 } hold. one label sets implies (IC - {[0 0]} IA-).
is: (IA+ [0 0] IC+) (IC- {[0 0]} IA-). Thus, way (IA+ [0 0] IC+) hold (IA
{e} IC) holds. relations detailed Section 6.
66

fiBARBER

5.2 Metric Constraints Intervals
Metric constraints intervals managed described temporal model.
general point view, metric information added elemental interval-based constraint
standard way (Table 4). metric constraints interval boundaries (Table 4) similar
ones proposed Staab Hahn (1998).
IA Symbolic
Elemental
Constraints

IA Metric Elemental Constraints
cij {[dm1 dM1 ], [dm2 dM2 ], ..... [dmn dMn ]}
c'ij {[dm 1 dM1 ], [dm 2 dM2 ], ..... [dm n dMn ]}
Ii

Ii Ij

Ii (before cij ) Ij

Ii meets Ij

Ii (meets c ij ) Ij

Ii Ij

Ii (cij c'ij ) Ij

Ii starts Ij

Ii (starts c ij ) Ij

Ii finishes Ij

Ii (finishes cij ) j

C

ij

Ij

Ii
Cij

Ij

Ii

C' ij

C
ij

Ij
Ii
C
ij

Ij
Ii

C
ij

Ij
Ii

Ii overlaps Ij

Ii (overlaps cij ) Ij

Cij

Ij

Ii

Ii equal Ij

Ii (cij equal c'ij ) Ij

C
ij

C'

ij

Ij

Table 4: Metric interval constraints interval boundaries
Obviously, metric constraints Table 4 managed proposed model, means
metric constraints interval ending points. Thus, symbolic constraints Interval Algebra
extended way metric domain. However, since interval represented means
ending time-points, flexible metric constraints intervals represented means
metric constraints ending time-points. way, described model subsumes
Interval Distance Sub Algebra model proposed Badaloni Berati (1996). Moreover, ending
points intervals related initial time-point T0 , unary metric constraints
interval durations expressed means metric constraints two ending points
interval:
dur (Ii ) = {[dm1 dM1 ], [dm2 dM2 ], ..... [dmn dMn ]}
(Ii - {[dm1 dM1 ], [dm2 dM2 ], ..... [dmn dMn ]} Ii +).

67

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

-

[ I1 ]

-

[ I1 ]

30
60

T0

I1

I1+

[

]

20
I2
[

50

]

{[140 150], [200 210]}

Figure 12: Metric constraints intervals
Thus, following constraints (Figure 12):
(I1 {b, o} I2) (I1- [[20 30], [50 60]} I2-) (I2- {[140 150], [200 210]} T0 )
represented (Table 1):
default: (I1 - { (0 ){R0}} I1+), (I2- { (0 ){R0}} I2+),
(I1 {b, o} I2)



(I1+ {(0 ){Rb1} (- 0]{Rb2}} I2-),

(I1+ {(- 0){Ro1} [0 ){Ro4}} I2-),

(I1+ {(0 ){Ro2} (- 0]{Ro5}} I2+),

(I1- {(0 ){Ro3} (- 0]{Ro6}} I2-),



(I1- [[20 30], [50 60]} left I2-)
(I2- {[140 150], [200 210]} T0 )



(I1- {[50 60]{R1} [20 30]{R2}} I2-),
(T0 {[140 150]{R3} [200 210]{R4}} I2- ),

{Rb2 Ro4 }, {Rb2 Ro5 }, {Rb2 Ro6 }, {R1 R2 } {R3 R4 } I-L-Sets.

6. Reasoning Logical Expressions Constraints
described model, disjunct input constraint univocally associated label.
Moreover, label set associated derived elemental constraint represents support-set
input elemental constraints elemental constraint derived. I-L-Sets represent
inconsistent sets input elemental constraints. reasoning labeled disjunctive constraints,
associated label lists I-L-Sets, temporal model offers capability reasoning logical
expressions elemental constraints belonging disjunctive constraints different pairs
time points. Let's assume following labeled input constraints:
(ni lc ij nj ) (ni {(lecij.1 ){Rij.1} (lecij.2 ) {Rij.2} .....(lecij.p ) {Rij.p}} nj ),
(nk lc kl nl ) (nk {(leckl.1 ) {Rkl.1} (leckl.2 ) {Rkl.2} .....(leckll.q ) {Rkl.q}} nl )
i) represent two elemental constraints 4 (elc ij.x lc ij , elckl.ylc kl ) cannot hold simultaneously
(that (elc ij.x elc kl.y )) label set {Rij.x Rkl.y } added set I-L-Sets.
ii) represent logical dependency two elemental constraints, 'If lec ij.x
leckl.y' (where lecij.xcij , leckl.yckl ), Cartesian product {Rij.x} {{Rkl.1 , Rkl.2 , ....., Rkl.q }{Rkl.y }} added set I-L-Sets.
iii) represent two elemental constraints (elc ij.xlcij , elckl.y lc kl ) hold simultaneously
(bi-directional logical dependency), Cartesian products {Rij.x} {{Rkl.1 , Rkl.2 , ....., Rkl.q }4

reasons simplicity, two elemental constraints shown. However, two disjunctions managed
similar way. Likewise, features applied labeled derived constraints.

68

fiBARBER

{Rkl.y }} {Rkl.y } {{Rij.1 , Rij.2 , ....., Rij.p }-{Rij.x}} added set I-L-Sets.
instance, lets see Example 2 Section 4.4 (Figure 10):
represent John goes work car Fred goes work walking possible,
{R1 R5 } asserted I-L-Set.
represent John goes work car Fred goes work walking, {R1 R3 }
{R1 R4 } asserted I-L-Sets.
represent John goes work car Fred goes work walking, vice versa,
{R1 R3 }, {R1 R4 } {R5 R2 } asserted I-L-Sets.
similar way, logical relations among point-based interval-based elemental constraints
represented. instance, logical dependence "the duration I1 [5 8] I2 I3
duration 1 [12 15] I2 I3" represented as:
(I2 {b, bi} I3 )

(I2 + {(0 ){Rb9} (- 0]{Rb10}} I3 -),
{Rb10 Rb12 } I-L-Set,

(I3 + {(0 ){Rb11} (- 0]{Rb12}} I2 -),

(I1 - {[5 8] {R1} [12 15] {R2}} I1 +),
{R1 Rb11 }, {R2 Rb9 } I-L-Sets, since Rb11 associated I2 I3 Rb9 associated
I2 I3 . Likewise, "I1 starts time 2 t1 occurs t2" represented
(see Table 1):
I1 {s, s} I2 (I1 - {[0 0] {Rs1} (0 ){Rs3} (- 0){Rs4}} I2 -) , (I1 + {(0 ){Rs2} (- 0]{Rs5}} I2 +) ,
(t1 {(- -1] {R1}, [0 0] {R2}, [1 ){R3}} t2 ),
{R3 Rs3 }, {R3 Rs4 }, {R3 Rs5 } I-L-Sets, since R3 associated 't1 occurs t2 ' Rs3 ,
Rs4 Rs5 associated 'I1 start time I2 '.
6.1 Disjunctions Point Interval-Based Constraints
Disjunctions constraints different pairs points intervals represented
proposed model means labeled constraints points set I-L-Sets. subsumes
related expressiveness subset disjunctive linear constraints proposed Stergiou
Koubarakis (1998), disjunctions constraints different pairs points
managed.
represent disjunctive set disjunctive constraints points, have5 :
(ni lc ij nj ) (nk lc kl nl ) represented as: (ni {lc ij lc ij } nj ) (nk {lc kl lc kl } nl ),
logical relation among lc ij , lc ij , lc kl lc kl. Thus, disjunctive set constraints:
{(ni lc ij nj ) (nk lc kl nl )}
{(ni {(lecij.1 ){Rij.1}, (lecij.2){Rij.2}, ...., (lecij.p ){Rij.p}} nj )
(nk {(leckl.1 ){Rkl.1}, (leckl.2 ){Rkl.2}, ...., (leckj.q ){Rkl.q}} nl )}
5

reasons simplicity, two constraints shown. However, two disjunctive constraints managed
similar way.

69

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

represented as:
i) conjunctive set constraints (ni , nj ) (nk , nl ), where, (lecx)
represented means complementary domain (lecx):
(ni {(lecij.1 ){Rij.1}, (lecij.2 ){Rij.2}, ...., (lecij.p ){Rij.p}, {(lecij.1 ){Rij.1}, (lecij.2 ){Rij.2}, ...., (lecij.p ){Rij.p}}} nj )
(nk {(leckl.1 ){Rkl.1}, (leckl.2 ){Rkl.2}, ..., (leckj.q ){Rkl.q}, {(leckl.1 ){Rkl.1}, (leckl.2 ){Rkl.2}, ..., (leckj.q ){Rkl.q}}} nl )
{(ni {(lecij.1 ){Rij.1}, (lecij.2 ){Rij.2}, ..., (lecij.p ){Rij.p}, (lecij.1 ){R'ij.1}, (lecij.2 ){R'ij.2}, ..., (lecij.p){R'ij.p}} nj )
(nk {(leckl.1){Rkl.1}, (leckl.2 ){Rkl.2}, .., (leckj.q ){Rkl.q}, (leckl.1 ){R'kl.1}, (leckl.2){R'kl.2}, ..., ( leckl.q ){R'kl.q} } nl )}
ii) set I-L-Sets represent mutually exclusive disjunction lc ij lc kl (they cannot
simultaneously hold):
ii.a) One constraints lc ij lc kl hold: Cartesian product label sets
complementary domains lc ij lc kl , {R'ij.1 , R'ij.2 , ...., R'ij.p }{R'kl.1 , R'kl.2 , ...., R'kl.q },
I-L-Sets.
ii.b) one constraints lc ij lc kl hold: Cartesian product label sets
lc ij lc kl , {Rij.1 , Rij.2 , ...., Rij.p }{Rkl.1 , Rkl.2 , ...., Rkl.q } I-L-Sets.
Thus, disjunctive conjunctive sets disjunctive constraints points represented
managed means conjunctive set disjunctive constraints set I-L-Sets.
example:
(ti {[5 5] {R1} [10 10] {R2}} tj ) (tk {[0 0] {R3} [20 20] {R4}} tl )
(ti {[5 5] {R1} [10 10] {R2} (- 5){R5} (5 10) {R6} (10 ){R7}} tj )
(tk {[0 0] {R3} [20 20] {R4} (- 0){R8} (0 20) {R9} (20 ){R10}} tl ),

(ii.a) since (ti {[5 5] {R1}, [10 10] {R2}} tj ] [tk {[0 0] {R3}, [20 20] {R4}} tl ] hold:
{R5 R6 R7 }{R8 R9 R10 } I-L-Sets,
(ii.b) since one constraint (t {[5 5]{R1} [10 10] {R2}} tj ) (tk {[0 0] {R3} [20 20]{R4}} tl )
hold:
{R1 R2 }{R3 R4 } = {R1 R3 }, {R1 R4 }, {R2 R3 }, {R2 R4 } I-L-Sets.
Ii ecij Ij

Ii ecij Ij

Ii ecij Ij

I1 I2

I1 {(0 ){Rb1}} I2

I3 I4

I3 + {(0 ){Rb3}} I4 -

+

-

Ii (ecij ecij) Ij
-

I1 {(0 ){Rb1} (- 0]{Rb2}} I2 -

I3 + {(- 0]{Rb4}} I4 -

I3 + {(0 ){Rb3} (- 0]{Rb4}} I4 -

+

I1 {(- 0]{Rb2}} I2

+

Table 5: Point-based constraints (I1 I2 ) (I3 4 )
Similarly, disjunctions interval-based constraints different pairs intervals
represented. instance, Table 1 Table 5, {(I1 I2 ) (I3 I4)}
represented as:
(I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -), (I3 + {(0 ){Rb3} (- 0]{Rb4}} I4 -),

70

fiBARBER


a)

one constraints (I1 I2) (I3 I4 ) hold. Thus, Cartesian product
label sets associated disjunctive constraints (Ii ecij Ij ) set I-L-Sets: {Rb2 ,
Rb4 } I-L-Set,

b)

one constraints (I1 I2 ) (I3 I4 ) hold. Thus, label set
associated mutual fulfillment constraints (Ii ecij Ij ) I-L-Set: {Rb1 , Rb3 }
I-L-Set.

Thus:
{(I1 I2 ) (I3 I4 )}
(I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -), (I3 + {(0 ){Rb3} (- 0]{Rb4}} I4 -),
{Rb2 , Rb4 }, {Rb1 , Rb3 } I-L-Sets.
Ii ecij Ij

Ii ecij Ij

Ii ecij Ij

Ii (ecij ecij) Ij

(I1 I2 )

I1 - {(- 0){Rd1}} I2 -

(I1 - {[0 ){Rd3}} I2 -)

I1 - {(- 0){Rd1} [0 ){Rd3}} I2 -

I1 + {(0 ){Rd2}} I2 +
(I3 starts I4 )

I3 - {[0 0]{Rs1}} I4 I3 + {(0 ){Rs2}} I4 +



(I1 + {(- 0]{Rd4}} I2 +)

I1 + {(0 ){Rd2} (- 0]{Rd4}} I2 +

(I3 - {(0 ){Rs3} (- 0){Rs4}} I4 -) I3 - {[0 0]{Rs1} (0 ){Rs3} (- 0){Rs4}} I4

(I3 + {(- 0]{Rs5}} I4 +)

I3 + {(0 ){Rs2} (- 0]{Rs5}} I4 +

Table 6: Point-based constraints (I1 I2 ) (I3 starts I4 )
similar way (Table 6), (I1 I2 ) (I3 starts 4 )
(I1 - {(- 0){Rd1} [0 ){Rd3}} I2 -),

(I1 + {(0 ){Rd2} (- 0]{Rd4}} I2 +),

(I3 - {[0 0] {Rs1} (0 ){Rs3} (- 0){Rs4}} I4 -), (I3 + {(0 ){Rs2} (- 0]{Rs5}} I4 +),
{Rd1 Rd2 Rs1 Rs2 } Cartesian product {Rd3 Rd4 } X {Rs3 Rs4 Rs5 } I-L-Sets.
Therefore, logical relations elemental constraints represented set I-L-Sets. Thus,
labeled TCN (and set I-L-Sets) represent special type and/or TCN. types
non-binary constraints enrich expressiveness language allow modeling
complex problems (Meiri, 1996). Stergiou Koubarakis (1996) Jonsson Bckstrm (1998)
show Disjunctions Linear Constraints (DLR) able represent non-binary
constraints. However, Pujari Sattar (1999) remark general methods linear programming
applied DLR management, specific temporal concepts (like ones
detailed Section 2) considered general methods. proposed model,
management non-binary constraints performed proposed reasoning methods
without increasing computational complexity. added functionality interest several
temporal reasoning problems, including planning, scheduling temporal constraint databases
(Barber et al., 1994; Gerevini & Schubert, 1995; Brusoni et al., 1997; Stergiou & Koubarakis, 1998;
etc.) general solutions provided specific temporal reasoning area.
addition, proposed reasoning algorithms obtain globally labeled-consistent TCN
(Theorem 11). feature allows us manage hypothetical queries, important
requirement query processes temporal constraint databases (Brusoni et al., 1997). Thus, queries
71

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

c'ij hold, c'kl? answered without TCN propagation. label set associated
derived elemental constraint represents set input elemental constraints hold
fulfillment elemental constraint. Therefore,
(xk c'kl xl)(xi c'ij xj )
holds, elc kl.y lc kl / eckl.yc'kl elc ij.xlc ij / ec ij.xc'ij labels(elc ij.x)labels(elc kl.y ) hold.
example, labeled minimal TCN Figure 7, have:
(T1 {[40 40]} T3 ) (T2 { [0 0] } T4 ),

(T3 { [20 20] } T2 ) (T3 { [20 20] } T4 ).

However, (T3 {[10 20]} T2 ) imply (T1 {[70 70]} T4 ). Similarly, questions
c'ij hold, c'kl? easily answered applying Theorem 9 Theorem 10.

7. Alternative Temporal Contexts
reason temporal facts, simultaneously work different alternative temporal
contexts, situations, trends, plans, intentions possible worlds (Dousson et al., 1993; Garcia &
Laborie, 1996). usual branching (backward forward) model time. Here,
alternative past contexts (i.e.: different lines facts may occurred) alternative future
contexts (i.e.: different lines facts may occur). Thus, temporal context management
required hypothetical causal reasoning. Also, different contexts permits partition
whole TCN set independent chains order decrease complexity problem size
(Gerevini & Schubert, 1995). section, deal hypothetical reasoning issues.
goal temporal management context-dependent constraints. Thus, general, hierarchy
alternative temporal contexts established, constraints associated different
temporal contexts. instance, Figure 13 represents hierarchy alternative contexts, W0
represents root context different disjunctive constraints (n1 , n2 )
context. Temporal reasoning algorithms detailed paper able manage contextdependent constraints:
Input disjunctive constraints asserted different temporal contexts. this, labels
associated input elemental constraints used represent context
disjunctive asserted. instance (Figure 13), constraint:
(n1 {[0 50] {R1}, [200 210] {R2}} n2 )
asserted context W1 , following input context-dependent labeled constraint:
(n1 {[0 25] {R1, W1}, [260 280] {R2, W1}} n2 ).
Here, context-dependent label set associated elemental constraint represents
alternative temporal disjunct (i.e.: R1 R2 ) context elemental
constraint asserted (W1 ).
Label sets associated context-dependent derived elemental constraints represent
temporal contexts derived elemental constraints hold.
Definition 8. context-dependent disjunctive constraint disjunctive constraint
elemental constraint (i.e.: disjunct) associated alternative temporal context. universal
labeled constraint {(- ){W0 R0}}, W0 root context.
72

fiBARBER

proposed reasoning processes manage context-dependent disjunctive constraints way
similar previously defined labeled disjunctive constraints (Section 3). instance, according
constraints contexts Figure 13, following input labeled constraints nodes n1
n2 updated:
(n1 {[0 100] {R1 W0}, [200 300] {R2 W0}} n2 ),

(n1 {[0 50] {R3 W1}, [200 210] {R4 W1}} n2 ),

(n1 {[60 100] {R5 W 2} , [290 300] {R6 W2}} n2 ),

(n1 {[0 25] {R7 W3}, [260 280] {R8 W3}} n2 ),

(n1 { [0 25] {R0 W11}} n2 ),

(n1 { [30 50] {R9 W12}, [200 205] {R10 W12}} n2 ),

(n1 {[0 20] {R0 W31}, [210 215] {R0 W32}} n2 ),

(n1 {[260 280] {R0 W33}} n2 ).

restricted constraints
Context W11

n1 {[0 25]} n 2

Context W1

n 1 {[0 50], [200 210]} n 2
Context W12

n 1 {[0 100], [200 300]} n 2

Context W2

n 1{[30 50], [200 205]} n 2

n1 {[60 100], [290 300]} n 2

Root-Context W0

Context W31

n 1{[0 20]} n 2
Context W3

n 1{[0 25], [260 280]} n 2

Context W32

n1{[210 215]} n

2

Context W33

n1{[260 280]} n

2

Assertion Context k

Downward Propagation:
Propagation contextk
successor contexts

Upward Consistency:
Consistency contextk
predecessor contexts

Figure 13: hierarchy alternative contexts
updating process new constraint cij given context Wp assure
consistency c ij context Wp , well predecessor contexts (Figure 13). consistency
cij successor contexts Wp detailed Section 7.2, since several options
identified. However, necessary assure consistency among constraints belonging contexts
different hierarchies. Successor contexts given context represent different alternatives,
mutually exclusive. Thus, constraints belonging contexts different hierarchies
mutually inconsistent. However, imply constraints contexts
necessarily mutually disjoint. instance (Figure 13), constraints (n1 {[0 50] {R3 W1}, [200
210]{R4 W1}} n2 ) context W1 (n1 {[0 25] {R7 W3}, [260 280] {R8 W3}} n2 ) context W3
mutually disjoint. However, W1 , W2 W3 assumed three mutually exclusive alternatives
W0 .
73

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

closure process new constraint cij context Wp downward propagate new
constraint cij successor contexts (Figure 13). Moreover, propagation performed
predecessor contexts contextk , among contexts different hierarchies. Elemental
constraints belonging contexts different hierarchies cannot simultaneously considered,
is, combined intersected.
7.1 Context-Dependent Updating Closure Processes
update closure processes defined Section 4 adapted order manage contextdependent disjunctive constraints. Context-Update process (Figure 14) asserts constraint
cij {ec1 , ec2, ..., ecn } context contextk. way similar updated process described
Section 4, Context-Update performed time new context-dependent constraint
asserted.
Context-Update (ni cij nj contextk)
lc'ij Put-label-context (cij , contextk )
;Labelling mutual inconsistency.
Consistency-Test (get-upward (ni , nj , contextk ), lc'ij )
;Upwards Consistency test
(*Inconsistent Constraint*)
Return (false)
Else (*Consistent Constraint*)
;lc'ij asserted contextk
lc ij (lc ij - get (ni , nj , contextk )) lc (lc ij lc lc'ij ),
;successor contexts.
lc ji Inverselc (lc ij ),
Context-Closure (ni lc ij nj contextk )
;Downwards Closure algorithm contextk.
.
Return (true)
End-If
End-Context-Update
Figure 14: Context-Update process context-dependent labeled constraints
Where:
Put-label-context (cij , contextk ) associates exclusive label set elemental constraint
ecij.p cij . label set two labels {Rij.p contextk }. label set, first label
label associated temporal disjunct. way similar Put-labels function, labels
mutually exclusive (Definition 3). second label represents context cij
updated. Moreover, pair labels associated successor contexts parent context
contextk added I-L-Sets, since successor contexts given context
mutually exclusive:
contextp / contextp Succesor-Contexts(Parent-Context(Contextk )),
I-L-Sets I-L-Sets ({contextk }{contextp }).
Parent-Context(contextk ) Successor-Contexts(contextk ) return parent-context
set successor-contexts contextk , respectively. Thus, Figure 13, {{W1 , W2 },
{W1 , W3 }, {W2 , W3 }, {W11 , W12 }, {W31 , W32 }, {W31 , W33 }, {W32 , W33 }} I-L-Sets.
74

fiBARBER

get (ni , nj , contextk ) returns set labeled elemental constraints ni nj
contextk (and successor contexts). is:
get (ni , nj , contextk )::= {(ecij.p {labelij.p })lc ij / contextk {labelij.p }}.
Note get(ni , nj, contextk ) subset lc ij . Thus, (lc ij - get (ni , nj , context k )) means setdifference lc ij get (ni , nj , contextk ). is, set elemental constraints
context-dependent constraint lc ij , contextk , successor contexts.


get-upward (ni, nj , contextk ), similarly previous get function, returns existing
constraints ni nj contextk (and successor contexts). However,
constraint ni nj contextk , function returns
constraints ni nj exist predecesor context contextk:
get-upward (ni, nj , contextk ) ::=
get (ni , nj , contextk ) return (get (ni , nj , contextk ))
Else
Contextk Parent-Context (Contextk )
get (ni , nj , contextk ) Contextk =W0
get (ni , nj , contextk ) return (get (ni , nj , contextk ))
Else return({(- +)}{W0 R0}})
End-get-upward

context-dependent closure (Figure 15) process similar closure process described
Section 4 performed updating process. closure process updated
constraint contextk downwards performed contextk successor contexts.

Context-Closure (ni lc ij nj contextk)
(* First loop: Closure n n j n k *)
nk TCN / lc jk {U{R0 W0}}:
lc'ik lc ik lc (lc ij lc lc jk ),
lc ik (lc ik - get (ni , nk , contextk )) lc lcij ,
lc ki Inverse(lc ik)
(* Second loop: Closure n j ni nl *)
nl TCN / lc il {U{R0 W0}}:
lc'jl lc jl lc (Inverse(lc ij ) lc lc il ),
lc jl (lc jl - get (nj , nl , contextk )) lc lc'jl ,
lc lj Inverse(lc jl )
(* Third loop: Closure nl ni nj nk *)
nl , nk TCN / lc lj {U{R0 W0}}, lc jk {U{R0 W0}}:
lc'lk lc lk lc (lc li lc lc ij lc lc jk )
lc lk (lc lk - get (nl , nk , contextk )) lc lc'lk ,
lc kl Inverse(lc lk)
End-Context-Closure
Figure 15: Context-Closure process context-dependent labeled constraints
75

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

resulting label set associated context-dependent derived elemental constraint represents
contexts elemental constraint holds, well hierarchy predecessor contexts
elemental constraint. instance, Figure 16 shows contextual labeling example
Figure 13. Moreover, successively performing updating closure processes
constraints example, following constraint nodes n1 n2 :
(n1 lc 12 n2 ): (n1 {[0 100] {R1 W0}, [200 300] {R2 W0}, [0 50] {R3 R1 W1 W0}, [200 210] {R4 R2 W1 W0},
(e3)
[60 100] {R5 R1 W2 W0}, [290 300] {R6 R2 W2 W0}, [0 25] {R7 R1 W3 W0}, [260 280] {R8 R2 W3 W0},
[0 25] {R0 R3 R1 W11 W1 W0}, [30 50] {R9 R3 R1 W12 W1 W0}, [200 205] {R10 R2 R4 W12 W1 W0},
[0 20] {R0 R7 R1 W31 W3 W0}, [210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0}} n2 )

{W0}

{W0 W1}

{W0 W1 W11}

{W0 W3}

{W0 W2}

{W0 W1 W12}

{W0 W 3 W 31}

{W0 W3 W32}

{W0 W 3 W33}

Figure 16: Labels contexts
closure process performed among constraints belonging contexts different hierarchies.
According Put-label-context function, pair labels related successor contexts
context I-L-Set. Thus, I-L-Sets prevent deriving elemental constraints contexts
different hierarchies. is, derived elemental constraint obtained (combining intersecting)
two elemental constraints contexts different hierarchy inconsistent associated
label set. Therefore, derived elemental constraints rejected operation lc.
instance, example Figure 13, {{W1 , W2 }, {W1 , W3 }, {W2 , W3 }, {W11 , W12 }, {W31 , W32 },
{W31 , W33 }, {W32 , W33 }} I-L-Sets. Thus, constraint asserted context W1 :
i) propagation performed using constraints contexts W11 W12 simultaneously,
since {W11 , W12 } I-L-Set.
ii) propagation performed context W2 , W3 , successors, since {W1 ,
W2 } {W1 W3 } I-L-Sets.
Let's see example Context-Update Context-Closure processes. Lets assume
context-dependent constraints Figure 13 already updated closured, previous
constraint lc 12 (expression e3) exists n1 n2 . Now, update (n1 {[20 40]} n2 ) context
W1 . call Consistency-Test function Context-Update function is:
Consistency-Test (get-upward (n1 , n2 , W1 ), {[20 40] {R0 W1}}).
Given previous constraint lc 12 n1 n2 (expression e3), function performs:
{[0 50] {R3 R1 W1 W0}, [200 210] {R4 R2 W1 W0}, [0 25] {R0 R3 R1 W11 W1 W0},
76

fiBARBER

[30 50] {R9 R3 R1 W12 W1 W0}, [200 205] {R10 R2 R4 W12 W1 W0}} lc {[20 40]{R0 W1}}=
{[20 40] {R3 R1 R0 W1 W0}, [20 25] {R0 R3 R1 W11 W1 W0}, [30 40] {R9 R3 R1 R0 W12 W1 W0}}
Thus, new constraint (n1 {[20 40]} n2 ) consistent context W1 . Therefore, constraint
n1 n2 results:
lc12 (lc 12 - get (n 1 , n 2 , W 1 )) lc (lc 12 lc {[20 40]{R0 W1}}) =
{[0 100]{R1 W0}, [200 300] {R2 W0}, [60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0},
[0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0}, [0 20]{R0 R7 R1 W31 W3 W0},
[210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0}} lc
{[20 40]{R1 R0 W1 W0}, [20 40]{R3 R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}}=
{[0 100]{R1 W0}, [200 300] {R2 W0}, [60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0}, [0 25]{R7 R1 W3 W0},

(e4)

[260 280]{R8 R2 W3 W0}, [0 20]{R0 R7 R1 W31 W3 W0}, [210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0},
[20 40]{R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}}.

Note new updated constraint asserted context W1 propagated successor
contexts (W11 W12 ). However, new constraint context W1 affect existing
constraints predecessor contexts W1 (W0) constraints belonging contexts different
hierarchies (W2 , W3 successors).
update process, closure process performed, since node related n1 n2 .
Now, lets update (n3 {[10 20]} n1 ) context W1 . have:
Consistency-Test (get-upward (n3 , n1 , W1 ), {[10 20] {R0 W1}}),
performs:
{(- +)}{W0 R0} lc {[20 40] {R0 W1}} = {[20 40] {R0 W0 W1}} ,
since previous constraint exists (n3 n1 ) context W1 . constraint (n3 {[10 20]} n1 )
consistent, asserted TCN:
lc 31 {(- +)}{W0 R0}, [20 40] {R0 W0 W1}}.
(e5)
Afterwards, constraint closured. call Context-Closure process is:
Context-Closure (n3 , {(- +)}{W0 R0}, [20 40] {R0 W0 W1}}, n1 , W1 ).
closure process, first loop performed since node related n3 . Moreover,
previous constraint lc 12 (expression e4) exists current TCN n1 n2 . Thus,
first loop performs:
lc'32 lc 32 lc ({(- +)}{W0 R0}, [20 40] {R0 W0 W1}} lc lc 12 ) =
{(- ){W0 R0}} lc ({(- +)}{W0 R0}, [20 40] {R0 W0 W1}} lc lc 12 ) =
{(- +)}{W0 R0}, [220 340] {R2 R0 W0 W1}, [40 80] {R1 R0 W1 W0},
[40 65] {R0 R3 R1 W11 W1 W0}, [50 80] {R9 R3 R1 R0 W12 W1 W0}},
that,
lc 32 (lc 32 - get (n3 , n2 , W1 )) lc lc'32 = ({(- ){W0 R0}} - {}) lc lc'32 =
{(- ){W0 R0}, [220 340] {R2 R0 W0 W1}, [40 80] {R1 R0 W1 W0},
[40 65] {R0 R3 R1 W11 W1 W0}, [50 80] {R9 R3 R1 R0 W12 W1 W0}}.
77

(e6)

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Thus, asserted constraint (n3 , n2 ) context W1 closured context W1
successor contexts (W11 W12 ). Likewise, closure process perform
propagation simultaneously using constraints contexts W11 W 22 , context W2 ,
W3 , successors.
7.2 Complete Versus Incomplete Partition Contexts
updating process, consistency new constraint lcij given context assured
context parent contexts. Lets deal consistency issues context
successor contexts. Here, constraints given context Wi either completely
covered partially covered existing constraints successor contexts Wi . is,
successor contexts Wi either complete partition partial partition Wi .
instance, let's assert constraint (n1 {[210 210] {R0 W1}} n2 ) context W1 example
Figure 13. Consistency-test function, (where constraint lc 12 previous
expression e2):
get-upward (n 1 , n 2 , W 1 ) lc {[210 210]{R0 W1}} =
{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}, [0 25]{R0 R3 R1 W11 W1 W0}, [30 50]{R9 R3 R1 W12 W1 W0},
[200 205]{R10 R2 R4 W12 W1 W0}} lc {[210 210]{R0 W1}} = {[210 210]{R0 W1 R4 R2 W0}}.

is, asserted constraint consistent existing constraints context W1 . However,
resulting elemental constraint associated context W11 W12 . means asserted
constraint (n1 {[210 210] {R0 W1}} n2 ) consistent W1 , inconsistent W11 W12 . Here,
two alternatives appear:
i) assume existing successor contexts complete partition parent context.
Therefore, new constraint cij context Wi rejected, cij inconsistent
successor contexts Wi. instance, assume W11 W12 Figure 13
complete partition W1 . Thus, (n1 {[210 210] {R0 W1}} n2 ) rejected.
ii) assume successor contexts complete partition parent context. Therefore,
successor contexts become inconsistent removed. example,
assume contexts W11 W12 complete partition context W1 ,
another possible new successor context W 1 would able match future asserted
constraint (n1 {[210 210] {R0 W1}} n2 ). case, constraint (n1 {[210 210] {R0 W1}} n2 )
assumed correct, asserted TCN. Therefore, contexts W11
W12 become inconsistent. {W11 } {W12 } added set I-L-Sets,
contexts (and successor contexts constraints) become inconsistent
removed TCN. is, elemental constraints associated label set containing
{W11 } {W12 } removed.
cases, context always consistent successor contexts. option
adopted depend problem type solve (Garrido et al., 1999). options
easily introduced described reasoning processes, since function Consistency Test
determine successor contexts (Ws ) become inconsistent new constraint (lcij )
context (Wk ):
78

fiBARBER

Ws Successor-Contexts(Wk ) / elc ij.p get-upward (ni , nj , Wk ), Ws{labelij.p }
elc ij.r(get-upward (ni , nj , Wk ) lc lcij ), Ws{labelij.r}.
hand, when: (i) successor contexts (Wk1 , Wk2 , ..., Wkp ) context Wk
complete partition it, (ii) constraints (Wk1 , Wk2 , ..., Wkp ) asserted,
constraints Wk restricted according final existing constraints (W k1 , Wk2 , ..., Wkp ).
this, context Wk constrained temporal union constraints
successor contexts.
7.3 Minimal Consistent Context-Dependent TCN
Definition 9. context-dependent TCN minimal (and consistent) constraints context
consistent (with respect constraints context, predecessor contexts,
successor contexts) minimal (with respect constraints context predecessor
contexts).
Theorem 12. updating process, context-dependent reasoning processes obtain minimal
(and consistent) context-dependent TCN previous context-dependent TCN minimal.
Proof: previous context-dependent TCN minimal, Consistency-Test function guarantees
consistency new context-dependent input constraint:
i)

context parent contexts (get-upward function Theorem 5),

ii)

successor contexts (depending two identified cases Section 7.2).

closure process new constraint given context (Wk ) propagates effects
context successor contexts. Therefore (Theorem 7), process obtains new minimal
constraints context (Wk ) successor contexts.
Moreover, obtained context-dependent TCN globally labeled-consistent. Thus,
deduce whether set elemental constraints (between different pairs time points) consistent
(Theorem 10). is, set elemental constraints holds context. instance, given
previous constraints lc 12 , lc 31 lc 32 (previous expressions e4, e5 e6), deduce that:
(n1 {[40 40]} n2 ) (n3 {[40 40]} n1 ) (n3 {[40 40]} n2 )
full consistent since:
elc 12.xlc 12 , elc 31.y lc 31 , elc 32.zlc 32 / ({label12.x} {label12.x} {label12.x}) I-L-Set.
Specifically, instantiations hold {R1 R0 W1 W0 } {R1 R0 W0 }. Thus, set
elemental constraints holds context W1 (and, obviously, predecessor contexts).
Likewise, minimal context-dependent TCN, user retrieve constraints hold
context constraints simultaneously hold set given contexts. this,
Context-Constraints function retrieves constraints hold pair nodes (ni , nj )
given context (contextk ). is, result Get-upwards(ni , nj , contextk ) except elemental
constraints belonging successor contexts contextk :

79

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Context-Constraints (ni, nj, contextk )::= Get-upwards (ni , nj , contextk )
{lecij.p lc ij / contextqSuccesor-Contexts(contextk ), {contextq }{labelij.p }}.
instance, given context-dependent constraint lc 12 Figure 13 (expression e3),
following constraint would hold (n1 , n2 ) contexts W1 W3 :
Context-Constraints(n 1 , n 2 , W1 ) lc Context-Constraint(n 1 , n 2 , W 3 ) =
{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}} lc {[0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0}}=
{[0 25]{R7 R3 R1 W3 W1 W0}}6 .

addition, obtain constraints, simultaneously hold context
successor ones. instance, context W1 successor contexts (W11 , W12),
following constraint holds:
Context-Constrains(n1 , n2 , W1) lc [Context-Constraints(n1, n 2 , W11 ) lc Context-Constraints(n 1 , n2 , W12 )]=
{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}} lc
{[0 25]{R0 R3 R1 W11 W1 W0}}lc {[30 50] {R9 R3 R1 W12 W1 W0}, [200 205]{R10 R2 R4 W12 W1 W0}}=
{[200 205]{W12 R10 R4 R2 W1 W0}, [0 25]{W11 R0 R3 R1 W1 W0}, [30 50]{W12 R9 R3 R1 W1 W0}}.

hand, alternative context (Wi ) associated alternative hypothesis
(Hi ). hypothesis Hi gives rise set constraints, asserted associated
context Wi . Thus, proposed reasoning processes assure minimal constraints hierarchy
hypotheses. Moreover, hypothesis (Hi ) becomes unavailable, label set {Wi }
added set I-L-Sets. Thus, constraints context Wi (and successor contexts)
removed. is, constraints depend unavailable hypothesis Hi removed.
7.4 Computational Complexity Temporal Context Management
management temporal context increase complexity reasoning processes
detailed Section 4. fact, consider label associated disjunct (Ri ) labeled
disjunctive constraints associated context (Wi ). Thus, computational cost
updating process bounded O(n2 l2e), 'l' maximum number input disjuncts
pair nodes contexts.
temporal labeled algebra proposed paper (Section 3) applied pointbased disjunctive metric constraints (Dechter, Meiri & Pearl, 1991). However, labeled algebra
applied temporal constraints. case, operations lc, lc, lc lc
specified (Section 3) basis operations , , underlying
algebra. way, management temporal contexts applied types
constraints.
Theorem 13. computational complexity proposed reasoning process applied contextdependent non-disjunctive metric constraints polynomial (O(n2 W2)) number W managed
contexts.
6

However, note impossible situation, since W 1 W 3 mutually exclusive contexts. is, {W 3, W 1}
I-L-Set.

80

fiBARBER

Proof: Disjunctions constraints related contexts input constraints
asserted, non-disjunctive constraints managed. is, constraints pair nodes
form:
(ni {(ec ij.0 {W0 R0 }), (ec ij.1 {W1 R0 }), ...... , (ecij.k {Wk R0 })} nj ) ,

0kW / W=|{Wi }|

Thus, maximum number disjuncts constraints bounded maximum number
managed contexts W. Moreover, maximum length associated label sets maximum depth
hierarchy contexts, set I-L-Sets 2-length sets (i.e.: pairs labels
associated pair successor contexts context). Therefore, computational cost
operations lc lc bounded O(W2 ).
methods proposed Section 7.1 management temporal contexts applied
temporal reasoning algorithms, instead reasoning methods detailed Section 4.
requires reasoning algorithms based operations composition
intersection temporal constraints. Thus,
i) elemental constraint associated context (W ) asserted7 .
Thus, label sets associated elemental constraints one contextual label {Wi }.
ii) methods management temporal contexts described Section 7.1
integrated new reasoning algorithms. algorithms use operations
lc, lc, get get-upwards. computational cost operations lc lc related
management temporal contexts polynomial (O(W2 )) number (W) managed
contexts. Therefore, computational cost reasoning algorithms increased factor
W2 temporal contexts managed.
instance, interval-based constraints managed, TCA algorithm used
obtain path-consistent context-dependent IA-TCN, O(n3 W2 ) cost. Similarly, contextdependent reasoning applied PIDN networks (Pujari & Sattar, 1999), computational cost
specific reasoning algorithms PIDN constraints increased factor W2 . proposed
temporal algebra Section 3 applied tractable classes constraints, specific reasoning
algorithms management classes constraints applied. computational
cost reasoning algorithms (which based combination intersection
operations constraints) increased polynomial factor W2 . instance, nondisjunctive metric constraints managed, TCA algorithm used closure algorithm
Section 7.1. algorithm obtain minimal context-dependent TCN computational
cost O(n 3 W2 ).

8. Conclusions
Several problems remain pending representation reasoning problems temporal constraints.
relation this, dealt reasoning complex qualitative quantitative constraints
time-points intervals, organized hierarchy alternative temporal
7

is, labels (Ri) associated disjunctions disjunctive constraints. Thus, Definition 3 applied
Put-Label-Context function. Therefore, distributive property lc lc hold disjunctive
constraints. However, relevant since reasoning processes applied.

81

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

contexts. described new-labeled temporal algebra, whose main elements labeled
disjunctive metric constraints, label sets associated elemental constraints, sets inconsistent
elemental constraints (I-L-Sets). temporal model presented able integrate qualitative
metric constraints time-points intervals. fact, symbolic metric constraint
intervals represented means disjunctive metric constraints time points set
I-L-Sets. model able manage (non-binary) logical relations among elemental
constraints. reasoning algorithms described model based distributive property
composition intersection labeled constraints, guarantee consistency obtain
minimal TCN disjunctive metric point-based constraints. addition, special type global
labeled-consistent TCN obtained.
Labeled constraints organized hierarchy alternative temporal contexts,
temporal reasoning processes performed contexts. Reasoning algorithms guarantee
consistency hierarchy contexts, maintain minimal context-dependent TCN, allow us
determine constraints hold context set alternative contexts. Thus,
reason hierarchy context-dependent constraints intervals, points unary durations
(Figure 17).
described features useful functionalities modeling important problems
temporal reasoning area. However, identified previous models. Therefore,
temporal model presented represents flexible framework reasoning complex, contextdependent, metric qualitative constraints time-points, intervals unary durations.
Dur(I 1) { [ 2 0 20], [50 60]}

I1 {b} 2
1 {[10 20], [100 130]} -2

Context W 1 1
-

1 {b m} 2
Dur(I 1 ) {[20 30], [50 100]}

1 {[100 100], [200 300]} I+ 2
Dur(I 1) {[20 30], [60 100]}

Context W 1

Context W 1 2
1 {[10 20], [100 200]} - 2
I- 1 {[0 100], [200 300]} + 2
Root-Context W 0

1 {[10 15], [120 200]}
1{ } 2
Context W 2

2

1{d} 2
1 {[10 10]} -2
Context W 2 1
Dur(I 1 ) = 50
1 { } I2
Context W 2 2

Figure 17: Context-dependent constraints intervals, time points unary durations
path-consistent algorithm used closure process labeled TCNs, typical
TCA algorithm applied Allen (1983). path-consistent algorithm would obtain minimal
context-dependent TCN disjunctive metric constraints. proposed incremental
reasoning process. Thus, minimal (and consistent) context-dependent TCN assured new
assertion. incremental reasoning allows us detect whether new input constraint
inconsistent previously existing ones. useful problem constraints

82

fiBARBER

initially known successively deduced incremental independent process (Garrido et
al., 1999).
prototype proposed reasoning algorithms implemented Common-Lisp
available author. reasoning algorithms applied integrated architecture
planning scheduling processes (Garrido et al., 1999). Here, scheduling process
guarantee consistency alternative partial plan (i.e.: temporal constraints availability
resources operations) simultaneously planner generating partial plan (Srivastava
& Kambhampati, 1999). Thus, following main features needed:
Management disjunctive metric constraints. Particularly, planning scheduling
problems number disjuncts input constraints generally bounded l2 (i.e.: nonsimultaneous use resources). However, temporal dependencies constraints (i.e.:
non-binary constraints) appear. instance, operation durations dependent
order scheduled.
Incremental reasoning. process interactively guarantee consistency new
input temporal constraint (about resources, plans, ordering, objects) new step
deduced partial plan.
Management temporal contexts, context associated alternative plan
(action state). Reasoning algorithms simultaneously work different alternative
partial plans.
globally labeled-consistent (and minimal) TCN allows us determine consistent alternative
choices obtain optimal solutions plan. Additionally, proposed model
useful framework apply problems features appear (Dousson et al., 1993;
Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999; etc.).
computational cost reasoning algorithms exponential, due inherent complexity
management disjunctive constraints. However, management temporal contexts
increase complexity reasoning processes disjunctive constraints.
improvements decrease empirical cost reasoning algorithms proposed
paper. application algorithms handle explicit TCN (without making
derived constraints explicit) empirical evaluations several test cases study.
Moreover, reasoning algorithms applied temporal algebra presented, proposed
Section 4. hand, interesting identify subclasses labeled temporal algebra
size label sets bounded, identify tractable subclasses IA proposed
model. could interesting identify expressive power I-L-Sets (and labeled
constraints) basis method described Jeavons, Cohen Cooper (1999). Here, I-LSet represents special derived constraint, expresses inconsistency set input
elemental constraints; is, special type disjunctive linear constraint (Jonsson & Bckstrm,
1996; Stergiou & Koubarakis, 1996).
proposed-labeled algebra (labeled constraints operations them) applied
temporal models (i.e.: classes temporal constraints, operations, reasoning
algorithms). this, operations labeled algebra (lc, lc, lc lc) defined
basis respective operations (, , ) models, reasoning
algorithms use operations defined labeled constraints ( lc, lc, lc lc).
83

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

requires reasoning algorithms based composition intersection operations.
Specifically, application proposed model tractable temporal constraints -as
identified Section 1 (Jonsson et al., 1999; Drakengren & Jonsson, 1997; Vilain, Kautz Van
Beek, 1986; etc.)- allows tractable reasoning process hierarchy temporal constraint
contexts.

Acknowledgements
work partially supported Generalitat Valenciana (Research Project #GV-1112/93)
Spanish Government (Research Project #CYCIT-TAP-98-0345). author would
sincerely thank JAIR reviewers helpful comments suggestions previous
versions paper.

References
Allen, J. (1983). Maintaining knowledge temporal intervals. Comm ACM, 26, 11, 832843.
Badaloni, S., & Berati, M. (1996). Hybrid Temporal Reasoning Planning Scheduling.
Proceedings 3 Int. Workshop Temporal Representation Reasoning (TIME96).
Barber, F. (1993). metric time-point duration-based temporal model. ACM Sigart Bulletin,
4 (3), 30-40.
Barber, F., Botti, V., Onaindia, E., & Crespo, A. (1994). Temporal reasoning Reakt:
environment real-time knowledge-based systems. AICommunications, 7 (3), 175-202.
Brusoni, V., Console, L., & Terenziani, P. (1997). Later: Managing temporal information efficiently,
IEEE Expert, 12 (4), 56-64.
Cohen, D., Jeavons, P., & Koubarakis, M. (1996). Tractable disjunctive constraints. Proceedings.
3rd Int. Conf. Principles Practice Constraint Programming (CP96). Freuder,
E.C. (Ed.). Lecture Notes Computer Science, 1118, 297-307.
Cooper, M.C. (1990). optimal k-consistency algorithm. Artificial Intelligence, 41, 89-95.
Dean, T.L., & McDermott, D.V. (1987). Temporal data base management. Artificial Intelligence, 38,
1-55.
Dechter. R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49,
61-95.
Dechter, R. (1992). local global consistency. Artificial Intelligence, 55, 87-107.
Dousson, C., Gaborit, P., & Ghallab M. (1993). Situation Recognition: Representation
Algorithms. Proceedings 13th International Joint Conference Artificial Intelligence
(IJCAI93).
Drakengren, T., & Jonsson, P. (1997). Eight maximal tractable subclasses Allen's algebra
metric time. Journal A.I. Research, 7, 25-45.
84

fiBARBER

Freuder, E. C. (1978). Synthesizing constraint expressions. Comm. ACM, 21 (11), 958-965.
Freuder, E. C. (1982). sufficient condition backtrack-free search. Journal ACM, 29 (1),
24-32.
Garcia, F., & Laborie, P. (1996). Hierarchisation Seach Space Temporal Planning. New
Directions AI Planning, 217-232, IOS Press.
Garrido, A., Marzal, E., Sebasti, L., & Barber F. (1999). model planning scheduling
integration. Proceedings 8 th. Conference Spanish Association A.I.
(CAEPIA99).
Gerevini, A., & Schubert, L. (1995). Efficient algorithms qualitative reasoning time.
Artificial Intelligence, 74, 207-248.
Jeavons, P., Cohen, D., & Cooper M. (1998). Constraints, consistency closure. Artificial
Intelligence, 101, 251-268.
Jeavons, P., Cohen, D., Gyssens, M. (1999). determine expressive power constraints.
Constraints: Int. Journal, 4, 113-131.
Jonsson, P., & Bckstrm, C. (1996). linear-programming approach temporal reasoning.
Proceedings 13 th. National Conference Artificial Intelligence (AAAI96).AAAI
Press.
Jonsson, P., & Bckstrm, C. (1998). unifying approach temporal constraint reasoning. Artificial
Intelligence, 102, 143-155.
Jonsson, P., Drakengren, T., & Bckstrm, C. (1999). Computational complexity relating time
points intervals. Artificial Intelligence, 109, 273-295.
Kautz, H., & Ladkin, P. (1991). Integrating metric qualitative temporal reasoning. Proceedings
9th. National Conference Artificial Intelligence (AAAI91).AAAI Press.
Mackworth, A. K. (1977). Consistency networks relations, Artificial Intelligence, 8, 121-118,.
Meiri, I. (1996). Combining qualitative quantitative constraints temporal reasoning. Artificial
Intelligence, 87, 343-385.
Montanari, U. (1974). Networks constraints: fundamental properties applications picture
processing. Information Science, 7, 95-132.
Navarrete, I., & Marin, R. (1997). Qualitative temporal reasoning points durations.
Proceedings 15 th. International Joint Conference Artificial Intelligence (IJCAI-97).
Nebel, B., & Burckert, H.J. (1995). Reasoning temporal relations: maximal tractable subclass
Allen's interval algebra. Journal ACM, 42 (1), 43-66.
Pujari, A., & Sattar, A. (1999). new framework reasoning Points,. Intervals
Durations. Proceedings Int. Joint Conference Artificial Intelligence (IJCAI'99).
Schwalb, E., & Dechter, R. (1997). Processing disjunctions temporal constraints networks.
Artificial Intelligence, 93, 29-61.
85

fiREASONING INTERVAL POINT -BASED DISJUNCTIVE ETRIC CONSTRAINTS TEMPORAL CONTEXTS

Staab, S., & Hahn, U. (1998). Distance constraint arrays: model reasoning intervals
qualitative quantitative distances. Proceedings 12th Biennial Conference
Canadian Society Computational Studies Intelligence Advances Artificial
Intelligence (AI-98), Lecture Notes Artificial Intelligence, 1418, 334-348.
Srivastava, B., & Kambhampati, S. (1999). Efficient planning separate resource scheduling.
Proceedings AAAI Spring Symp. search strategy uncertainty incomplete
information. AAAI Press.
Stergiou, K., & Koubarakis, M. (1996). Tractable disjunctions Linear Constraints. Proceedings
2nd Int. Conf. Principles Practice Constraints Programming (CP96).
Freuder, E.C. (Ed.). Lecture Notes Computer Science, 1118, 297-307.
Stergiou, K., & Koubarakis, M. (1998). Bactracking algorithms disjunctions temporal
constraints. Proceedings 15 th. National Conference Artificial Intelligence (AAAI98). AAAI Press.
Van Beek, P. (1991).Temporal query processing indefinite information. Artificial Intelligence
Medicine, 3 (6), 325-339.
Van Beek, P., & Detcher R. (1995). minimality global consistency row convex
networks. Journal ACM, 42 (3), 543-561.
Van Beek, P., & Dechter, R. (1997). Constraint tightness looseness versus local global
consistency. Journal ACM, 44 (4), 549-566.
Vilain, M., Kautz, H., & Van Beek P. (1986). Constraint propagation algorithm temporal
reasoning. Proceedings 5Th. National Conference Artificial Intelligence (AAAI86).AAAI Press.
Wetprasit, R., Sattar A. (1998). Temporal representation qualitative quantitative information
points durations. Proceedings 15 th. National Conference Artificial
Intelligence (AAAI98). AAAI Press.
Yampratoom, E., & Allen, J. (1993). Performance temporal reasoning systems, ACM Sigart
Bulletin, 4, (3), 26-29.

86


