journal artificial intelligence

submitted published

compilability expressive power
propositional formalisms
bernhard nebel

nebel informatik uni freiburg de

institut fur informatik albert ludwigs universitat georges kohler allee freiburg germany

abstract
recent approaches extending graphplan handle expressive
formalisms raise question formal meaning expressive power
formalize intuition expressive power measure concisely domains
plans expressed particular formalism introducing notion compilation
schemes formalisms notion analyze expressiveness
large family propositional formalisms ranging basic strips formalism
conditional effects partial state specifications propositional formulae preconditions
one conditional effects cannot compiled away plan size grow
linearly compiled away allow polynomial growth resulting plans
confirms recently proposed extensions graphplan concerning
conditional effects optimal respect compilability framework another
general propositional formulae cannot compiled conditional effects plan size
preserved linearly implies allowing general propositional formulae preconditions
effect conditions adds another level difficulty generating plan

introduction
g raphplan blum furst satplan kautz selman among
efficient systems nowadays however generally felt formalism
supported systems namely propositional basic strips fikes nilsson
expressive enough reason much effort anderson smith weld gazen
knoblock kambhampati parker lambrecht koehler nebel hoffmann dimopoulos devoted extending graphplan order handle powerful
formalisms adl pednault
appears consensus much expressive power added particular language feature example everybody seems agree adding negative preconditions
add much expressive power basic strips whereas conditional effects considered
significant increase expressive power anderson et al gazen knoblock
kambhampati et al koehler et al however unclear measure expressive power formal way related question whether compilation
approaches extend expressiveness formalism optimal example gazen
knoblock propose particular method compiling operators conditional effects
basic strips operators method however exponentially larger operator sets
people anderson et al kambhampati et al koehler et al agree
cannot better nobody proven yet space efficient method
impossible
c ai access foundation morgan kaufmann publishers rights reserved

fin ebel

order address measuring relative expressive power formalisms start intuition formalism least expressive another formalism domains corresponding plans formalism concisely expressed
formalism least seems underlying intuition expressive power
discussed literature
backstrom proposed measure expressiveness formalisms
esp reductions reductions roughly speaking polynomial many one reductions
instances change plan length notion showed
propositional variants basic strips containing conditional effects arbitrary logical
formulae considered expressively equivalent however taking point view espreductions restrictive two reasons firstly plans must identical size might
want allow moderate growth secondly requiring transformation computed
polynomial time overly restrictive ask concisely something expressed
necessarily imply exists polynomial time transformation fact one
formalism might expressive another one mapping formalisms might
computable least seems usual assumption made term
expressive power discussed baader cadoli donini liberatore schaerf erol
hendler nau gogic kautz papadimitriou selman
inspired recent approaches measure expressiveness knowledge representation formalisms cadoli et al gogic et al propose address questions
expressive formalism notion compiling one formalism
another one compilation scheme one formalism another differs polynomial many one reduction required compilation carried polynomial
time however expressible polynomial space furthermore required
operators instance translated without considering initial state
goal restriction might sound unnecessarily restrictive turns existing
practical approaches compilation gazen knoblock well theoretical approaches
backstrom consider structured transformations operators transformed
independently initial state goal description technical point view
restriction guarantees compilations non trivial entire instance could transformed
compilation scheme could decide existence plan source instance generate
small solution preserving instance target formalism would lead unintuitive
conclusion formalisms expressive power
mentioned beginning space taken domain structure important
space used plans reason distinguish compilation schemes
whether preserve plan size exactly linearly polynomially
notion compilability analyze wide range propositional formalisms ranging basic strips formalism containing conditional effects arbitrary boolean formulae partial state specifications one identify two
equivalence classes formalisms respect polynomial time compilability preserving plan size exactly means adding language feature formalism without leaving
class increase expressive power affect principal efficiency
assume reader basic knowledge complexity theory garey johnson papadimitriou
familiar notion polynomial many one reductions complexity classes p np conp
pspace notions introduced needed



fic ompilability



e xpressive p ower p lanning f ormalisms

method however provide separate formalisms
computational complexity theory circuit complexity non uniform complexity
classes separation indicate adding particular language feature adds expressive power difficulty integrating feature existing
example prove conditional effects cannot compiled away boolean formulae
cannot compiled conditional effectsprovided plans target formalism allowed
grow linearly
answers question posed beginning compilation proposed gazen
knoblock cannot space efficient even allow linear growth plans
target formalism allowing polynomial growth plans however compilation
scheme space efficient interestingly seems case compilation scheme
allows polynomially larger plans similar implementation conditional effects
ipp system koehler et al kambhampati colleagues system
anderson colleagues system
rest structured follows section introduce range propositional formalisms analyzed together general terminology definitions
introduce notion compilability formalisms section
section present polynomial time compilation schemes different formalisms
preserve plan size exactly demonstrating formalisms identical expressiveness
remaining cases prove section cannot compilation scheme
preserving plan size linearly even bounds computational resources
compilation process section reconsider question identical expressiveness compilation schemes allow polynomial growth plans finally section
summarize discuss

propositional formalisms
first define general propositional formalism appears almost
expressive propositional variant adl pednault formalism allows arbitrary
boolean formulae preconditions conditional effects partial state specifications subsequently
specialize formalism imposing different syntactic restrictions
general propositional formalism
let countably infinite set propositional atoms propositional variables finite
subsets denoted defined set consisting constants
denoting truth denoting falsity well atoms negated atoms e literals
language propositional logic logical connectives
fiff
propositional atoms denoted clause disjunction literals say
formula conjunctive normal form cnf conjunction clauses
disjunctive normal form dnf disjunction conjunctions literals
given set literals refer positive literals refer
negative literals atoms used e
note gazen knoblock translation scheme generates operators depend
initial state goal description however operators simply code initial state goal description
nothing else reason ignore



fin ebel



define element wise negation e

ba
state c truth assignment atoms following identify state
set atoms true state state specification subset e logical
theory consisting literals called consistent iff contain complementary literals
general state specification describes many states namely satisfy
denoted ef gh case complete e
ijd precisely one model namely k abusing notation refer
inconsistent state specification illegal state specification
operators pairs lm pre post p use notation pre lb post lq refer first
second part operator l respectively precondition pre element rkskt e
set propositional formulae set post set postconditions consists
conditional effects form

uwv xff
uzy



called effectv conditions elements
called
elements
u
effects singleton sets e g h
often omit curly brackets write
v
example order illustrate notions use running example
connected production camera ready manuscripts latex source files
somewhat simplified course set atoms choose following set

bacffed fgcffihqj klffgm ffgp qgffgrsklrsffgr rsmlffgrsm fftklu hvfftk hqcfftkwm
hqj k klu h nxqffihbjsk k za nx ba
propositional atoms following intended meaning atoms first line represent
presence corresponding files atoms second line signify index
citations correct dvi file define following operators rbkwr bac zac
xea kwu h ac first operators simple precondition execution
rbklr fgc file exist successful execution r rsm r file
produced

rbklr zacm fgcffgrbkwr v v brsrsmlffgrsm ov va



xea kwu hsac

operator similar

xea kwu h acm k hc v v qkwu h fftklm ov va
finally zac operator bit complicated precondition needs presence
bac file produces effect fgc k hc hbjsk files unconditionally addition
know citations correct rsr file present index correct


fic ompilability

klu h

file present



e xpressive p ower p lanning f ormalisms

bac zac
v
v
rsr
fir rsv
klu h

f cfftk hqcffihbjsklffgm bff
v hbjs k hqy j k bk k n zaxff nxqff
hbjsk klu h nxqff
v
kwu h hqj k kwu h nx

semantics operators given state transition functions e mappings states
states given state c set postconditions post cbff post denotes active effects c

mcsff post uwv

post ffec

u ba

state transition function induced operator l defined follows


c

r r
c csff post lb mcsff post lb c pre lb

cbff post lq

undefined

otherwise

words precondition operator satisfied state c active effects consistent
state c mapped state c differs c truth values active effects
forced become true positive effects forced become false negative effects
precondition satisfied set active effects inconsistent function
undefined
formalism work states state specifications general
lead semantic restricting state specifications sets
literals however syntactic manipulations state specifications defined way
sound lifschitz sense
similarly active effects respect states define corresponding function
respect state specifications

dff post uwv fifi

post ffd

u ba

define potentially active effects follows

dff post cbff posta
e


dff post
state specification operator l n pre post p dff post
means state specification resulting application state transition functions
might representable theory consisting literals reason consider
operator application illegal resulting illegal state specification could
liberal point consider operator application state specification illegal
set states resulting applying state transition functions could definitely represented
note happen state specification incomplete



fin ebel

theory consisting literals alternatively could consider atoms mentioned
dff post post unsafe application operator delete literals
post dff post state specification consider resulting state specification
still legal dff post consistent since seem exist standard model
execution conditional effects presence partial state specifications adopt first
alternative one arbitrary choice noted however decision influences
present
dff post leads illegal state specification
similarly rule dff post
require precondition satisfied states ef gh state specification
already inconsistent applying l leads definition
function defines outcome applying operator l set operators
state specification

r r
dff post lq post lb

pre lb
j

post lb

dand
ffilq









b
l





post lb
post





otherwise

example propositional atoms operators example assume following
two state specifications
zackfftklu hk backfftklu h ffgrsr mffgrsm ov try apply
operator bac notice



post zm bacb fgcfftk hcffihqj klffgm ffihqj k klu h nx bff
post zm bacb post zm bacb h hbjsk k za nxqff hqj k k ba nx bff



post zm bacb hand apply rbkwr bac
e post zm bacb

successfully ffgrbkwr bacb



easily verified syntactic operation state specification function
corresponds state transitions states described specification
proposition let state specification l operator induced state transition
function ffilq

ef gh dffilb c gc c ffec dfi ba
dffilb


ef gh



two states c


mc post lb
ffec e g mc post lb
exists state cwe gh c undefined


fic ompilability

e xpressive p ower p lanning f ormalisms



words whenever dffilb legal specification specification describes
states application state transition function states satisfy
original state specification ffilq illegal good reasons

instance tuple

n ffifft pff






n fftp domain structure consisting finite set propositional atoms
finite set operators


initial state specification
goal specification



talk size instance symbolically following mean size
reasonable encoding instance
following use notation refer set finite sequences operators
elements called plans denotes size plan e number
operators say step plan applying state
specification recursively defined follows

b

r r
dff n p
dff nl iff l ffgagaga ffil kp dffil nl ffgagaga ffil kp


sequence operators said plan solution iff
x ffe
x ffe
example let propositional
atoms operators introduced example
consider following instance
n n fftpfft backffgrbklr ffklu hk bfft hbjskffihqjsk k za nx pa
words given latex source file bac bibliography database rbklr want generate dvi
file hbjsk citations file correct hbjsk k ba nx furthermore know
know index file yet
anything existence bbl file aux file etc
kwu h plan nzrsklr bacffgm zacsp solution plan illegal
state specification resulting state specification entails hqj k hbjsk k ba nx
plans satisfying sound order state precisely extend
notion state transition functions operators state transition functions plans let
state transition function corresponding composition primitive state transition functions
induced operators nl ffgagaga ffil p e



b e b eagagaqfi bvff
could liberal requiring done order allow fair
comparison restricted formalisms



fin ebel


e c defined iff e b c defined every
notion one easily proveusing induction plan lengththat plan instance
sound lifschitz sense e corresponds application state transition functions
initial states


proposition let n ffifft p instance
x ffe consistent

nl gff agaga ffil p

element

e gh x ffe c tc c ffec ba
ffe inconsistent


ef gh



exists possibly empty prefix
x nl ffgagaga ffil p



two states c


nl gff agaga ffil p


eff c wef gh

mc

b exists state cwe gh bw

c





c post l
post l
undefined

family propositional formalisms
propositional variant standard strips fikes nilsson call
follows formalism requires complete state specifications unconditional
effects propositional atoms formulae precondition lists less restrictive
formalisms following additional features
incomplete state specifications state specifications may complete
conditional effects effects conditional
literals formulae formulae preconditions effect conditions literals
boolean formulae formulae preconditions effect conditions arbitrary
boolean formulae
extensions combined use combinations letters refer multiple
extensions instance refers formalism extended literals precondition lists

refers formalism allowing incomplete state specifications conditional effects
qb finally refers general formalism introduced section



example consider instance example becomes quickly obvious
instance expressed initial state specification incomplete

operator zac contains conditional effects negative literals effect conditions however
need general boolean formulae express instance


fic ompilability



e xpressive p ower p lanning f ormalisms











q












figure formalisms partially ordered syntactic restrictions

figure displays partial order propositional formalisms defined way
sequel say specialization written iff identical
diagram depicting partial order
comparing set formalisms one backstrom analyzed one notices despite small differences presentation formalisms



common propositional strips cps

propositional strips negative goals psn
ground tweak gt
computational complexity family

one would expect much easier turns
case provided one takes computational complexity perspective
analyzing computational complexity different formalisms consider
usual deciding whether exists plan given instancethe plan existence
planex use prefix referring formalism consider
existence particular formalism
theorem



planex pspace complete



qb

consider formalisms identical sas formalism backstrom nebel since
allow multi valued state variables



fin ebel

proof pspace hardness planex follows bylander corollary
membership qs planex pspace follows could step step guess
sequence operators verifying step operator application leads legal follow
state specification last operator application leads state specification entails
goal specification step verification carried polynomial space reason
conditions definition verified polynomially many calls
np oracle therefore qs decided non deterministic machine polynomial space
hence member pspace
follows plan existence formalisms expressiveness
including formalismsis pspace complete

expressiveness compilability formalisms
although difference computational complexity formalisms
qb family might nevertheless difference concisely domains plans
expressed order investigate question introduce notion compiling formalisms
compiling formalisms
mentioned introduction consider formalism expressive another
formalism domains plans formulated formalism concisely expressible
formalize intuition making use call compilation schemes
solution preserving mappings polynomially sized domain structures
domain structures restrict size compilation scheme
require bounds computational resources compilation fact measuring
expressibility irrelevant whether mapping polynomial time computable exponential time
computable even non recursive least seems idea notion expressive
power discussed similar contexts baader erol et al gogic et al cadoli
et al want use compilation schemes practice reasonably
efficient course however want prove one formalism strictly expressive
another one prove compilation scheme regardless many
computational resources compilation scheme might use
far compilation schemes restrict size domain structures however measuring expressive power size generated plans play role backstrom
esp reductions plan size must identical similarly translation


proposed gazen knoblock seems implicit prerequisite plan
length target formalism almost comparing expressiveness
different formalisms might however prepared accept growth plans
target formalism instance may accept additional constant number operators
may even satisfied plan target formalism linearly polynomially larger
leads schematic picture compilation schemes displayed figure
although figure gives good picture compilation framework completely
accurate first compilation scheme may introduce auxiliary propositional atoms
used control execution newly introduced operators atoms likely
initial value may appear goal specification instances target


fic ompilability



e xpressive p ower p lanning f ormalisms






compilation





g



b





figure compilation framework

formalism assume compilation scheme takes care adds literals
initial state goal specifications
additionally translations initial state goal specifications may necessary
want compile formalism permits literals preconditions goals one requires atoms trivial translations necessary similarly want compile formalism
permits us use partial state specification formalism requires complete state specifications translation initial state specification necessary however state translation
functions limited depend set symbols source
formalism context independent e translation literal state specification
depend whole specification efficiently computable
compilation framework theoretical tool measure expressiveness
course practical relevance let us assume reasonably fast system
formalism want add feature resulting formalism
come efficient compilation scheme means easily integrate
featureeither compilation scheme modifying
minimally compilation scheme exists probably would integrating feature finally computationally expensive compilation schemes exist interesting
situation case line compilation costs may high however since compiled
domain structure used different initial goal state specifications high line costs
may compensated efficiency gain resulting
turns however situation arise analyzing compilability qs formalisms identify polynomial time compilation scheme able prove
compilation scheme exists

means compilation schemes formalisms similar knowledge compilations cadoli
donini fixed part computational domain structure variable part consists
initial state goal specifications main difference knowledge compilation framework
take size account words compile function instead decision




fin ebel



compilation schemes
assume tuple functions n ffe ffe qff
n ffifft p instances follows

ffz p

induce function





instances





n ffe h ffi ffe zs fft pga


following three conditions satisfied call compilation scheme



iff exists plan

exists plan





state translation functions z modular e
functions eff satisfy














ffd
ffdfiff h ffdff

polynomial time computable
size ffe polynomial size arguments
condition states function induced compilation scheme solutionpreserving condition states requirements line state translation functions
functions computable element wise provided state specification consistent considering fact functions depend original set symbols
state specification requirement seem restrictive since state translation
functions line functions require efficiently computable
finally condition formalizes idea compilation compilation much
important concisely represented e polynomial space compilation process fast nevertheless interested efficient compilation schemes say
polynomial time compilation scheme ffe polynomial time computable
functions
addition resource requirements compilation process distinguish different compilation schemes according effects size plans solving
property every plan
instance target formalism compilation scheme
solving instance exists plan solving

positive integer constant compilation scheme preserving plan size exactly additive
positive integer constants
compilation
constants k
scheme preserving plan size linearly lff polynomial
compilation scheme preserving plan size polynomially generally say formalism compilable formalism polynomial time preserving plan size exactly
linearly polynomially exists compilation scheme appropriate properties

write
case compilable compilation done polynomial time super script depending whether scheme preserves plan size
exactly linearly plan polynomially respectively
easy see notions compilability introduced reflexive transitive
although hard imagine modular state translation function polynomial time computable
pathological function could e g output translations exponential size encoding symbols



fic ompilability

proposition relations







e xpressive p ower p lanning f ormalisms







transitive reflexive

furthermore obvious moving upwards diagram displayed figure
polynomial time compilation scheme preserving plan size exactly v denotes
projection th argument function returns empty set generic
compilation scheme moving upwards partial order ffeffeff p
proposition j











compilability preserving plan size exactly
proposition leads question whether exist compilation schemes
implied specialization relation proposition proposition
compilation schemes every pair formalisms suffices prove compilable
order arrive conclusion formalisms compilable
formalisms
preview section given figure establish two equivalence
classes members class compilable preserving plan size exactly
two equivalence classes called class symbols




naming respective largest elements











q












figure equivalence classes formalisms created polynomial time compilation
schemes preserving plan size exactly



fin ebel

formalisms without conditional effects boolean formulae
first formalisms analyzed backstrom namely


polynomial time compilable preserving plan size exactly fact fourth class
added set namely lies

words notion compilability get equivalence class
backstrom esp reductions closer look proofs backstrom reveals surprising esp reductions used could reformulated
compilation schemes since used quite different notation nevertheless prove claim
first principles
key idea compiling formalisms literals formalisms allow atoms

consider different atoms formalism purpose introduce


set negative
copy
j e disjoint

literal replaced e











j


otherwise



set atoms one translate state specifications preconditions easily postconditions make sure intended semantics taken care e

whenever added must deleted vice versa
finally deal partial state specifications however
effects unconditional preconditions contain atoms
case safely assume atoms unknown truth value false without changing
outcome application operator let denote completion respect
e


xa



function transform partial state specification complete specification
without changing outcome e get plans
theorem
exactly



polynomial time compilable preserving plan size

proof since h z

follows propositions


order prove claim

let n ffifft p instance n fftp translate operator l

operator

l n pre lbff post lq post lq pa
set operators denoted
n ffe ffe qff ffz p follows




ffi
zs fft





define compilation scheme




n
pff






w

fic ompilability



e xpressive p ower p lanning f ormalisms

satisfies conditions functions computed polythe scheme obviously
nomial time instance
obvious
let


dffilb ffd lba


n l ffgagaga l p denote sequence operators corresponding sequence operators

nl ffgagaga iff l vp induction plan length easy

plan iff plan
e condition compilation schemes satisfied means fact compilation
let

scheme since plan size change compilation scheme preserves plan size
exactly finally functions computed time polynomial arguments
polynomial time compilation scheme
one view matter whether expressivity point view
allow atoms literals matter whether complete partial state
specificationprovided propositional formulae conditional effects allowed
formalisms conditional effects without boolean formulae
interestingly view spelled generalizes case conditional effects allowed case matter whether atoms literals allowed
whether partial complete state specifications proving however two
additional complications firstly one must compile conditional effects partial state specifications conditional effects complete state specifications
post lb definition function must tested seccondition dff post lq
ondly compiling formalism literals formalism allows atoms
condition dff post lb definition must taken care reason
prove two steps
first step compiled specifying


compilation scheme execution operator l partial state specification leads

dff post lb
illegal state dff post lb
considering running example ex things quite obvious state specification contain literal negation literal mentioned effect
condition illegal state specification example state specification neither contain r rsm rsrsm executing bac general case however
things less straightforward effect literals produced one conditional
rule effect condition consist one literal
assuming without loss generality polynomial transformation effects
singleton sets check following condition one conditional effects
effect literal activatedi e effect condition entailed partial state
conditional effects effect literal blocked e effect condition
contains literal inconsistent state specification true original operator
dff post lq otherwise resulting state specification inconsistent
satisfies dff post lb
example consider following operator

l


n fft q v h bfft v v h q pa


fin ebel

application operator satisfies dff post lb







true state specification

dff post lb

iff

true state specification

one false one false



cases get post lb
dff post lb illegal state order
test condition formalism complete states introduce four sets atoms




bff
bff
bff

x th conditional effect l ba
atom true part original partial state specification atom
set true operator one conditional effects adds appear
effect operator atom
set true operator one conditional effects deletes
appear effect operator finally atoms form added
action th conditional effect th operator blocked effect condition
atoms could translate operator

n h ffi v v bff
v h bff

v bff
ffi v bff
h v bff

v v bff

v bff

x z

q pa
let eff function returns
respectively effect th
conditional effect th operator assuming atoms set according

intended semantics previous operator deleted atoms w

l

following test operator checks whether original operator would led inconsistent
test



ffa iff e v


bdc



whenever means th conditional effect th operator must
previously executed operator blocked addition effect conditional
dff post lb
effect activated e iff true would dff post lb
original formalism reason force illegal state conversely true
false one eff true would dff post lq post lb
original formalism need force illegal state

could force extra literals operator l test operator
applied would compilation scheme preserves plan size linearly however
possible better key idea merge test operator th step
operator step e


fic ompilability



e xpressive p ower p lanning f ormalisms

polynomial time compilable preserving plan size exactly

n ffifft p instance n fftp without loss generality
proof let
assume postconditions operators l following form
v f ffgagaga ffi h
g
v f z bff
post l





f


lemma



first introduce number sets symbols pairwise disjoint disjoint



ji













ki












bff
z bff
z bff
z bff
z bff
ki


th conditional effect l

bff
th conditional effect l ba

denotes set primed literals e z
given set literals
e c mv
w function cll denotes successor function modulo

mn doqpsrut functions wv shall functions v jv jv


v bfi post l
v v



v eff
v v v b post l
let postv

l

postv
let block v

l

defined follows

l vv v
v v post l e
v
wff
post l e bff

defined
block v

l q ffi v v v q vxvxf f post l q
q ffi wv
post l ffi bff

let testv defined

z
z
z
z
v ba
q v v iff e v v

v
let fresh symbols appearing jv jv
define pair compiled operators l v corresponding original operator l w
l v pre l h v bff postv v l blockv zl testv
v v ffi v b q
v v v j v iff e q x

k

v
q
z v v z v

v

z v ba
c

v



fin ebel

pair compiled operators achieves intended effects keeps track fully known
atoms postv checks conditional effects blocked block v tests whether
dff post lb
execution previous operator satisfied condition dff post lb
testv setup bookkeeping atoms next step atoms v enforced
executing testing merged parallelizing test step execution step
order check execution last step need extra checking step

l v v b test v v v q pa
specify compilation scheme



follows


n









ffi ffi g bff



l ffil tl l ffil pff


ffi ibff ji
ji
v bff

fft h jff




b
ffi
fft

scheme obviously satisfies conditions e state translation functions modular
polynomially sized functions
e compilation functions
computed polynomial time instance

obvious
assume




x z ffd h bff nl p

dff nl p
provided dff nl p case dff nl p f ffd nl p
dff post l dff post l latter case application operator
ffd nl p leads inconsistent state conditional effects test
part postconditions operators applicable state additionally true
relation zb ffx dff nl ffil zi ffd h nl ffil p
let nl ffgagaga ffil p denote sequence operators corresponding sequence operators
nl ffgagaga ffil v p induction plan length easily shown







iff

plan

since plan solving instance



exists plan



lav


plan





must lav last operator follows

iff exists plan





follows immediately polynomial time compilation scheme
preserving plan size exactly proves claim







proved compiled preserving plan size exactly seems worth


noting depends semantics chosen executing conditional operators partial state specifications example use alternative semantics deletes literals


dff post lb zm dff post lb provided dff post lb consistent exists probably compilation scheme preserves plan size linearly use semantics


fic ompilability



e xpressive p ower p lanning f ormalisms

resulting state specification legal application state transformation functions leads
theory represented set literals seems unlikely exists scheme
preserves plan size polynomially reason pessimistic conjecture
semantics appears conp hard determine whether state specification resulting
applying b operator legal

second step showing partial state specifications literals compiled away
compile key idea proof proof


theorem replace negative literal atom order detect inconsistencies
introduced conditional effects add postcondition conditional effects form

v check last operator plan introduce inconsistencies
force application checking operator contains conditional effects
lemma




polynomial time compilable



preserving plan size exactly

proof let
n ffifft p instance n fftp since
postconditions operators l following form

b

post lb



vxb gff agaga ffi






vxb









instance

bff

bff


proof theorem shall disjoint copy set atoms

c lq following set
negative literal replaced atom let post
post
c lb

v

b






b

vxb


post lbe ba

let cons set conditional effects
cons

q h v bff


let atom appearing let l

l n

let




l tl

pre lbff
post
c lbh cons

v v pff

let operator l

l n cons v pa

specify compilation scheme

q


ffi
zs fft

follows


n v bff
l q pff
bff
v bff




satisfies conditions functions computed polythe scheme obviously
nomial time instance


fin ebel

assume



obvious


dffilb ffd lbff

provided dffilb









case dffilb ffd lb
ffd lb

latter case application operator ffdff lb leads inconsistent state
conditional
effects cons part postconditions

let n l ffgagaga l p denote sequence operators corresponding sequence operators

nl ffgagaga ffil vp induction plan length easily shown







iff

plan

since plan solving instance



exists plan









l

plan





must l last operator follows

iff exists plan

follows polynomial time compilation scheme
proves claim











preserving plan size exactly

course dependent semantics formalisms deal
dff post lb
complete state specifications hence dff post lb
theorem
size exactly







polynomial time compilable preserving plan

proof b follows lemma lemma proposition propositions

fact b claim follows







limits compilation preserving plan size linearly
interesting question course whether compilation schemes preserving plan
size exactly identified far turns case prove
pairs formalisms identified compilation scheme preserving
plan size exactly compilation scheme impossible even allow linear increase
plan size pairs formalisms even able prove polynomial increase
plan size would help establishing compilation scheme however
fhe assumption preview
conditional assumption slightly stronger ef g
section given table symbol means exists compilation
scheme first formalism specialization second one cases
specify separation give theorem number
conditional effects cannot compiled away
first prove conditional effects cannot compiled away deeper reason
conditional effects one independently number things parallel
impossible formalisms without conditional effects consider example
operator zac example clear propagates truth value rsr klu h
hqj k k ba nx hbjsk klu h nx respectivelyprovided state specification satisfies precondition


fic ompilability






qs











q
j





cor

cor

cor

cor

ji

ji



theo

cor

cor

ji

ji



cor

cor

cor







ji













cor









theo























cor



theo








cor

q






cor









k



e xpressive p ower p lanning f ormalisms
















cor







cor





table separation

obviously possible come set exponentially many operators
thing one step however unclear less exponentially many operators
fact impossible
order illustrate point let us generalize example start set
propositional atoms ffgagaga disjoint copy set ml l fiv







dnl shall denote corresponding set literals


consider following









l

e

l dfi l g ba
l



domain structure

l
b
n fft v l v l wfiv p
n pa
construction follows pairs fft consistent complete set
l instance n ffifft p one step plan conversely pairs


fft gff l l exist solution
trying define domain structure polynomially sized property

seems impossible even allow step plans however trying prove turns
additional condition state translation function needed
say state translation functions local iff state specifications








dpff qff ffdff






fin ebel

locality additional condition state translation functions could easily prove
conditional effects cannot compiled away instead however
possible derive weaker condition definition compilation schemes
enough prove impossibility weaker condition quasi locality state translation
functions relative given set symbols turn notion universal
f
literals literal called universal literal given state translation functions iff one
following conditions satisfied


f



f



f



f



f



f

p bfft h
p bfft h
p bffeb
pzs h bfft h
pzs h bfft h
pzs h bffeb

let r denote set universal literals define quasi locality state translation functions relative set propositional atoms induced set universal literals r follows
pairs








w
r

dff sffzs ffdfiff







words non local literals quasi local state translation functions universal literals
lemma given compilation scheme f n ffe
ut
exists set atoms



ffe qff ffz p natural number
quasi local



r v function union possible
proof let
translations literal returned state translation functions e
gl h bfft h h bfft h h bffeb
h bfft
zb h bfft h
zs h bffeba
set


w

r choose infinite subset
w





w



xw finitely many atoms xw glor infinite subset w exist


w



universal literal

f


r

set r
r

f



aff g q sur





f

r must
note infinite subset w must exist reason literal
occur infinitely many atoms w could infinite subset
satisfying condition single atom six possible ways generate
f
must exist infinite subset literal occurs v h bfft h
f
v h bfft h zv h bffeb iff subset universal literal


fic ompilability



e xpressive p ower p lanning f ormalisms

pick subset satisfying first condition choose finite subset
desired cardinality state translation functions quasi local respect
r
otherwise repeat selection process w r condition satisfied
selection process repeated finitely often otherwise atoms tl infinite impossible state translation functions
polynomial time computable therefore finite
demonstrates exists set propositional atoms statetranslation functions quasi local however might able effectively determine
set
finally able prove non existence compilation schemes
compiling conditional effects away preserving plan size linearly
theorem



cannot compiled preserving plan size linearly

proof assume contradiction exists compilation scheme q pres
serving plan size linearly compiles domain structure defined

domain structure

tff pa
lemma assume set atoms chosen translation

functions quasi local set
let us consider initial state specifications consistent complete
contain positive negative literals

obviously
following form









k
r
fik ba

state specifications assumption

q

instance

n ffi h b ffi l h p
step plan since different step plans number polyno
mial size plan used different initial statesprovided sufficiently

large
suppose plan used pairs fft fft



ffi h k
ffi l
ffi h k
zs ffi l k

since
must differ least one atom say without loss generality
assume since successful plan modular




follows

x ffeh

zs l b fft l





fin ebel

literals zs kl bfft klx may added operators none literals
l bfft l deleted operator without reestablishing literal another
operator deletion contains operators unconditional effects adds
deletes literals regardless initial state
f
let us assume exists literal zs kl bfft klx added
f
implies distinguish three cases


k conclude f
f
p k
lx bffeb implies f
f

state z bffi k l q bfftf bffe assumed
f
translation functions quasi local must universal literal universal

f
contain positive negative
possible initial states
f
literals well literal elements universal present
f
reason added valid


plan must part



f
words literals
k lx bfft k lx added already
conclude
ffe l bfft l


f

let




l bffi l j l h

l bfft l
zs ffi l l l h b va
z modular clear therefore ffefi




achieves well klx bfft klx follows modular achieves



since n ffi ffi l z k
l e l p plan plan

n ffi fft p fact plan instance implies cannot compilation
scheme desired contradiction
propositions well theorem generalized follows see
table
corollary qs
preserving plan size linearly




cannot compiled q formalism specializing

answers question whether space efficient compilation schemes

one proposed gazen knoblock possible even assuming unbounded
computational resources compilation process space efficient compilation scheme
impossibleprovided compilation preserve plan size linearly allow polynomially larger plans efficient compilation schemes possible see section
demonstrates choice semantics important interpret conditional effects
sequentially brewka hertzberg exists straightforward compilation scheme preserving
plan size exactly



fic ompilability



e xpressive p ower p lanning f ormalisms

non uniform complexity classes
next section make use called non uniform complexity classes defined
advice taking machines order prove impossibility compilation scheme
advice taking turing machine turing machine advice oracle necessarily recursive function positive integers bit strings input machine loads
bit string continues usual note oracle derives bit string
length input contents input advice said polynomial
oracle string polynomially bounded instance size complexity class defined terms resource bounded machines e g p np j pbnm called non uniform
x class decided machines resource bounds
polynomial advice
advice oracle class p poly appears much powerful p howy es pbnm
ever seems unlikely p poly contains np fact one prove fje
implies certain relationships uniform complexity classes believed unlikely stating first introduce polynomial hierarchy
let x class decision e denotes class decision
decided polynomial time deterministic turing machine allowed use
procedurea called oraclefor deciding whereby executing procedure
cost constant time similarly fje denotes class decision

polynomial time
nondeterministic turing machine solves
instances



defined follows
oracle p notions sets














v

v


v









v

v

v




eff
e


fje
ygn fje

thus gfhe

ygnfje set classes defined way called polynomial
hierarchy denoted ph note

f
v

e







v



v


v


v






v





e sekd




v classes unknown whether
v
v
v
v
v
inclusions classes proper however strongly believed case
e hierarchy truly infinite
firm belief polynomial hierarchy proper mentioned question
ee pbnm answered shown fje es pbnm would imply

whether fje

polynomial hierarchy collapses second level karp lipton e
yg nfhes pb nthis

however considered quite unlikely shown fje

ygnfje fj es pbnm implies polynomial hierarchy collapses third level yap
e
considered unlikely use proving

pairs formalisms unlikely one formalism compiled
one
super script used distinguish sets analogous sets kleene hierarchy



fin ebel

expressive power partial state specifications boolean formulae
cases considered far operators partial state specifications could compiled
operators complete state specifications e partial state specifications add expressiveness longer true however allow arbitrary boolean formulae
preconditions effect conditions case decide conp complete
whether formula tautology deciding whether one step plan exists asking example
q instance n fft nff kpe bffefft v p plan equivalent asking whether tautology
let one step plan existence planex planex restricted
plans size one evident qb planex q planex
conp hard let fixed polynomial polynomial step plan existence
planex planex restricted plans length bounded
size instance easy see np formalisms except
qb q reason guessing sequence operators state specifications
polynomial size one verify step polynomial time precondition satisfied
current state specification produces next state specification since
polynomially many steps overall verification takes polynomial time
proposition planex solved polynomial time nondeterministic turing machine formalisms different q
fact planex conp hard e g p planex np follows
almost immediately polynomial time compilation scheme q
ygnfje however even allow unbounded
preserves plan length polynomially fhe
computational resources compilation process proof technique first used kautz sel

man used compilation scheme cannot exist provided



theorem

q

cannot compiled preserving plan size polynomially unless









proof let propositional formula size conjunctive normal form three literals per
clause first step construct domain structure size polynomial
following properties unsatisfiability arbitrary cnf formula size equivalent
step plan existence planex instance n ffi fft p computed
polynomial time
given set atoms denoted define set clauses set containing
clauses three literals built atoms size e
polynomial let set atoms e corresponding one one clauses
let
b

f f f f f f
construct domain structure n fivfftkp formulae size follows











v bff
n v bfft v pe ba




fic ompilability



e xpressive p ower p lanning f ormalisms

let function determines cnf formulae atoms correspond
clauses formula e

f f f ba
initial state particular formula size computed follows
h h h v ba

construction follows exists one step plan n fft ffi fft v p


iff





unsatisfiable
let us assume exists compilation scheme q preserving plan
size polynomially let us assume domain structure compiled
domain structure n fft p compiled domain structure construct
following advice taking turing machine
input formula size load advice n ffe fftffe fft p
advice polynomial polynomial size compilation scheme generates
polynomially larger domain structures polynomial time function
computed polynomial time compute


ffi b fft
polynomial time goal specification

fft v fft
computed polynomial time finally decide planex resulting
instance n ffi fft p proposition know done polynomial time

nondeterministic turing machine
deciding planex n ffi fft p equivalent deciding planex
n ffi fft v p turn equivalent deciding unsatisfiability follows
decide conp complete nondeterministic polynomial advice taking turing machine
fhe pbnm yap
polynomial time follows ygnfje
claim follows
proposition proposition generalizes follows see table

corollary qs cannot

compiled formalisms preserving


plan size polynomially unless





restrict form formulae however may able devise compilation schemes
q e g reconsidering proof last theorem turns essential
use negation cnf formula precondition restrict cnf formulae
preconditions seems possible move partial complete state descriptions ideas
similar ones used proof lemma
however compilation scheme work reason condition
dff post lb dff post lb definition function condition satisfied operator inconsistent condition could easily employed reduce
unsatisfiability cnf formulae step plan existence enables us use technique proof theorem


fin ebel

circuit complexity
next impossibility need notions boolean circuits families circuits
boolean circuit directed acyclic graph nodes called gates
gate
type k k fiff fiff
ffi f ffgagaga gates k k

sffiff ffgagaga degree zero gates k k degree one
gates k k
fiff degree two gates except one least one outgoing
edge gate outgoing edge called output gate gates incoming edges
called input gates depth circuit length longest path input gate
output gate size circuit number gates circuit
given value assignment variables
output gate obvious way example
gate circuit shown figure

ffgagaga circuit computes value
get value output











figure example boolean circuit

instead circuits computing boolean functions use accepting

words length word h agaga interpreted value

assignment input variables ffgagaga circuit word accepted iff output gate

value word order deal words different length need one circuit
possible length family circuits infinite sequence ffgagagaw

input variables language accepted family circuits thei set words
accepts
usually one considers called uniform families circuits e circuits generated
turing machine pk space bound sometimes however non uniform families
interesting example class languages accepted non uniform families polynomiallysized circuits class p poly introduced section
restrictions size depth circuits define complexity
classes uniform variants subsets p one class important
following class languages accepted uniform families circuits polynomial size
logarithmic depth named nc another class proves important us defined
terms non standard circuits namely circuits gates unbounded fan instead
restricting degree gate two maximum allow unbounded degree
class languages accepted families polynomially sized circuits unbounded fan
constant depth called aci


fic ompilability



e xpressive p ower p lanning f ormalisms



definition follows almost immediately ac
nc moreover
shown languages nc non uniform variant aci
implies ac nc furst saxe sipser
boolean formulae cannot compiled conditional effects
seen section boolean formulae quite expressive used combination partial state specifications however state specifications complete
case seems possible simulate evaluation cnf formulae conditional
effects fact possible compile polynomial time example preserving plan

size linearly provided formulae conjunctive normal form operator would
split two operators one evaluates clauses formulae original operator
one combines evaluations takes appropriate actions e g asserting
precondition satisfied sequencing pairs operators achieved introducing
extra literals
say general case however trying simulate evaluation
arbitrary logical formula conditional effects seems case need many
operators nesting depth formula means would need plans cannot
bounded linearly longer original plans
use sketched section separate order let us

view domain structures fixed size plans machines accept languages words
consisting bits let

bfftvpa
assume atoms numbered word

consisting bits could

encoded set literals




th bit

th bit k ba

conversely consistent state specification let word th bit iff

say bit word accepted one step step plan iff
exists one step step plan respectively instance

n n v bfftkpffi v bfft pa
similarly families circuits define families domain structures ffe ffgagaga


language accepted family one step step plan set words accepted
domain structure words length borrowing notion uniformity well
say family domain structures uniform generated pk space turing
machine
papadimitriou pointed languages accepted uniform polynomially sized
boolean expressions identical nc papadimitriou p easy see family domain structures nothing family boolean expressions provided use
one step plans acceptance
proposition class languages accepted uniform families domain structures
one step plan acceptance identical nc


fin ebel

closer look power step plan acceptance families

domain structures turns less powerful nc order first
prove following lemma relates step plans circuits gates unbounded fan





lemma let f n fftp domain structure let
let step plan

exists polynomially sized boolean circuit unbounded fan depth fit
plan n ffifft p iff circuit value input
proof general structure circuit step









plan displayed figure























































figure circuit structure goal testing step



plan



plan step level atom connection connections level
input gates e goal test performed
gate checks goals
true level case gate checked

inconsistency generated executing plan
plan step must computed whether precondition satisfied
conditional effects figure displays precondition test precondition
conjunction precondition literals true v becomes true
connected gate figure
without loss generality polynomial transformation assume conditional
vgf whether effect f activated level computed circuit
effects form
v
displayed figure b shows circuit

finally activated effects combined circuit shown figure c atoms
check whether activated would set true one
inputs gate figure neither activated value
level n determined value level otherwise value level

determined value w e activation value positive effect level
depths circuits figure b c dominate depth circuit necessary
represent one plan step leading conclusion plan step represented circuit
depth adding depth goal testing circuit claim follows
lemma implies step plan acceptance indeed less powerful step plan

acceptance means compilation scheme preserving plan size linearly

impossible


fic ompilability



e xpressive p ower p lanning f ormalisms









z











































z

b



z





c

figure circuit structure precondition testing conditional effects b computation
effects c operators



theorem



members







class

proof theorem proposition claim follows

assume contradiction let ffe ffgagaga uniform family



domain structures ffe ffgagagaw domain structures generated compilation



scheme preserves plan size linearly lemma know domain

structure n fft p given goal generate polynomially sized unbounded fanin circuit depth tests whether particular step plan achieves goal order
decide step plan existence must test ie different plans polynomial size
compilation scheme plan generate one test circuit
adding another gate decide step plan existence circuit depth w size
polynomial size since state translation functions modular
fixed computed additional level gates since proposition
languages nc accepted uniform families domain structures one step plan
acceptance assumption implies accept language nc possibly

non uniform aci circuits impossible furst colleagues
propositions generalize theorem follows
corollary







cannot compiled



b







preserving plan size linearly

compilability preserving plan size polynomially
shown previous section compilation schemes induced propositions
ones identified section allow compilation schemes preserving plan size exactly pairs formalisms able rule compilation schemeseven


fin ebel

allow linear growth resulting plans nevertheless might still chance
compilation schemes preserving plan size polynomially shown qs q cannot
compiled formalisms even plan grow polynomially may still able
compilation schemes preserving plan size polynomially qs pair
remaining formalisms
preview section given figure seen able











b












figure equivalence classes formalisms created polynomial time compilation
schemes preserving plan size polynomially compilation schemes constructed
section indicated dashed lines

establish compilation schemes preserving plan size polynomially pairs formalisms
proved impossibility compilation schemes
compiling conditional effects away partial state specifications
first compilation scheme develop one qs q assume
conditional effects singleton effect sets since use arbitrary boolean
formulae effect conditions qs assume one rule effect literal
simple polynomial transformation arbitrary sets operators brought form
dff post lb considerably
simplifies checking condition dff post lb
one rule activate particular literal


fic ompilability



e xpressive p ower p lanning f ormalisms

order simulate parallel behavior conditional effects break
individual operators executed sequentially means conditional effect
operator introduce two operators one simulates successful application rule
one simulates blocking situation rule least one operators must
executed conditional effect original operator something force
additional literals added control execution operators leads
sequence operators length bounded number conditional effects original
operator
want simulate parallel behavior sequence unconditional operators effects
unconditional operators directly influence state description effect
deferred operators corresponding set conditional effects
executed reason use sequence copying operators copy activated
effects state description conditional operators executed copying
operators used check set activated effects consistent
theorem

qs

compiled

q

polynomial time preserving plan size polynomially

proof assume n fftp qb source domain structure assume without
loss generality polynomial transformation operators form

l n pre l fft vxf ffgagaga ffe vgf fiz pff
f
f
f
x

v
let disjoint copies used record active effects conditional
another disjoint copy used record active effect
effects let
l
copied yet let
j zlw set atoms corresponding one one

operators let set symbols corresponding one one conditional effects
e

v f post l ffil ba
x
finally let fresh atom appearing
signals copying
l
active effects state specification progress set symbols compiled
domain structure

f



l





ba

operator l compilation scheme introduces number operators
first operator introduce one checks whether conditional effects previous
operators executed copying progress precondition satisfied
case execution conditional effects operator started

l pre
n pre l h




bff b


l

pa

operator enables conditional effect operators activated effects introduce
following operators

lk
n b
q bff ffl



z f l

f pa

fin ebel

words effect condition entailed activated positive negative effect well
fact rule tried recorded
since one effect literal conditional effect conditional effect
blocked negation effect condition entailed state specification
blocked conditional effects introduce following operators

l
n b
bff pa

order check conditional effects tried activating corresponding effect
activating conditional effect blocked following operator used

l
n bb



vgf

post l

e bff bb pa

operator enables copying activated effects state specification achieved
following set operators atom


l

l
l











n l b fft l pff
n l b fft l pff
n l bff
pa

finally need operator checks possible effects copied operator
starts execution cycle enabling execution another precondition operator

li
n
l

pa

definitions specify set compiled operators

pre

l ffil l vhf
l l vxf post l e
l l
post l e
l ffil ffil w
lait ba
specify compilation scheme ffe zffe zff p follows
n fft p

b
l bff

bff
ffi
zs fft
scheme obviously satisfies conditions
compilation schemes
functions computed polynomial time q instance instance
let legal state specification let dffil operator
clear exists sequence
l x discussion
l followed
pre
operators consisting l followed operators form l


operator l followed turn operators l followed finally operator l
ffe fff


fic ompilability



e xpressive p ower p lanning f ormalisms

conversely exist plan transforms

bffil pre

legal state specification contains b

induction plan length follows arguments exists plan
iff exists plan every plan v

maximum number conditional effects operators hence
polynomial time compilation scheme preserving plan size polynomially
immediate consequence theorem q form equivalence class
respect compilability preserving plan size polynomially
corollary
polynomially

qs





polynomial time compilable preserving plan size

know corollary class cannot become larger
case compiling however depends semantics chosen


executing conditional effects partial state specifications use alternative semantics resulting state specification legal application state transformation
functions leads theory represented set literals seems likely exists
another scheme preserves plan size polynomially however use alternative semantics


deletes literals dff post lb dff post lb dff post lb consistent
appears unlikely able identify compilation scheme preserves plan
size polynomially
compiling conditional effects away complete state specifications
next compilation scheme compiles since deal complete state


post lb
specification take care condition post lb
true complete states makes compilation scheme somewhat simpler since
allow general boolean formulae scheme becomes little bit difficult
general however compilation scheme specify similar one given
proof theorem
theorem compiled
serving plan size polynomially







compiled



polynomial time pre

proof proof theorem assume n fftp
domain structure assume operators form

v f b pff
l n pre l fft u vxf ffgagaga u x
f
u structure u





source

structure means
assume effects unique conditional effect
addition assume set symbols compiled domain structure proof
theorem

f







l





ba

fin ebel



pre
operator l introduce operators l l l
theorem
addition following operators needed


lk
l e

l




l




n bb u q l f n bb e e u bff pa

l

l



proof

f pff


compiled set operators contains operators compilation scheme

identical scheme presented proof theorem means significant
difference compilation scheme presented proof theorem operator scheme
l e tests rule whether contains effect condition blocks rule since
complete state specifications every conditional effect activated blocked
used record execution conditional effect tried
similar arguments proof theorem follows compilation
scheme indeed scheme leads claim made theorem


follows equivalent respect formalisms


equivalent respect two sets could merged one equivalence class

provided able prove e g compiled



compiling boolean formulae away
section showed impossible compile boolean formulae conditional effects
plans allowed grow linearly however sketched already idea compilation
scheme preserves plan size polynomially compile boolean
formulae expressively equivalent basic strips e compile boolean

formulae away completely
theorem



polynomial time compilable



preserving plan size polynomially

proof assume f fftp domain structure assume without loss generality
e
operators l form l ffi p
one formula precondition instead set formulae
let two sets atoms corresponding one one sub formulae occurring preconditions operators atoms denoted
sub formula atoms form used record truth value sub formula
computed atoms form used store computed truth value
operator l n ffi p target operator set following operator

l q ffi b bffi pa
set operators generated way denoted
atom introduce following two operators

l
l









n bff ffi pff
n h bff pa

set operators generated way denoted






fic ompilability



e xpressive p ower p lanning f ormalisms

sub formula occurring preconditions
operators introduced

l

l
l
sub formulae j



l
l
l

form


p

following

n ffi ffi ffi b fft ffi pff
n bfft h pff
n bfft h pa






following operators introduced
n ffi bfft ffi pff
n ffi bfft ffi pff
n ffi bfft h pa

finally j following operators

l
l









n bfft iff pff
n iff bfft pa

set operators generated sub formulae denoted
specify compilation scheme



b
ffi
fft





n u pff





construction obvious functions polynomial time computable

induced function reduction

state translation functions modular
every plan source instance exists plan
maximum number sub formulae preconditions
claim follows
might question whether compiling boolean formulae away could done
efficiently boolean expressions evaluated circuits logarithmic
depth indeed possible however satisfied
compilation scheme preserving plan size polynomially together theorem settles question compilation schemes preserving plan size polynomially pairs
formalisms
corollary formalisms

preserving plan size polynomially









polynomial time compilable

fin ebel

parallel execution feasibility compilation schemes preserving plan
size polynomially
compilation schemes preserve plan size exactly linearly seem immediate use
polynomial growth plan appears little practical interest considering practical
experience roughly characterized property many
steps plan without getting caught combinatorial explosion fact
number significantly smaller polynomial growth seem make much sense
take graphplan blum furst consideration againthe system
motivated investigation first placeit turns system allows parallel
execution actions although parallel execution might seem add power
system considerably affect sequential plan solve
instance steps parallel plan need least actions nevertheless although size
plan measured number operations might number time steps may
considerably smallerwhich might allow efficient generation plan
look compilation scheme compiles conditional effects away seems case
large number generated actions could executed parallelin particular actions
simulate conditional effects
however semantics parallel execution graphplan quite restrictive one action
adds deletes atom second action adds deletes one action deletes atom
second action precondition two actions cannot executed parallel
graphplan restriction seems impossible compile conditional effects away
preserving number time steps plan however compilation scheme preserves
number time steps linearly seems possible instead compilation scheme
approaches far used exponential translation gazen knoblock modified
graphplan order handle conditional effects anderson et al koehler et al
kambhampati et al modifications involve changes semantics parallel
execution well changes search procedure implementations compared
straightforward translation gazen knoblock used would interesting
compare compilation scheme ideas spelled theorem
base line

summary discussion
motivated recent approaches extend graphplan blum furst
deal expressive formalisms anderson et al gazen knoblock
kambhampati et al koehler et al asked term expressive power could
mean context one reasonable intuition seems term expressive power refers
concisely domain structures corresponding plans expressed
intuition inspired recent approaches area knowledge compilation gogic et al
cadoli et al cadoli donini introduced notion compilability order
measure relative expressiveness formalisms basic idea compilation
scheme transform domain structure e symbol set operators
initial state goal specification transformedmodulo small changes necessary
technical reasons distinguish compilation schemes according whether plan
target formalism size additive constant size bounded linearly


fic ompilability



e xpressive p ower p lanning f ormalisms

size plan source formalism size bounded polynomially original
instance original plan
although compilability framework appears straightforward intuitive tool
measuring expressiveness formalisms possible come alternative
measures backstrom instance proposed use esp reductions polynomial
many one reductions preserve plan size exactly however requiring
transformation polynomial time computable seems overly restrictive
particular want prove one formalism expressive another one better
proven exists compilation scheme regardless much computational resources
compilation process may need furthermore appear severe technical
backstrom framework proving negative hand
positive reported backstrom achievable compilation framework
transformations used fact compilation schemes taking together appears
case compilation framework superior intuitive technical point view
another judging expressiveness formalisms proposed
erol colleagues measure expressiveness formalisms according set plans instance contrasts hierarchical task
network nicely strips help us making distinctions
formalisms family
compilability framework mainly theoretical tool measure concisely domain
structures plans expressed however appears good measure
difficult becomes language feature added polynomial time compilation
schemes preserve plan size linearly indicate easy integrate feature
compiled away one use compilation scheme mimic compilation scheme
extending polynomial time compilation scheme leading
polynomial growth plan possible indication adding feature
requires probably significant extension even compilation
scheme preserving plan size polynomially ruled probably serious
integrating feature
framework analyzed large family formalisms ranging basic
strips formalisms conditional effects boolean formulae incomplete state specifications surprising analysis able come complete
classification pair formalisms able construct polynomial time
compilation scheme required size bound resulting plans could prove compilation schemes impossibleeven computational resources compilation process
unbounded
particular showed formalisms considered






incomplete state specifications literals preconditions compiled basic strips
preserving plan size exactly
incomplete state specifications literals preconditions effect conditions compiled away preserving plan size exactly already conditional effects
compilation schemes preserving plan size linearly except implied
specialization relationship described


fin ebel

allow polynomial growth plans target formalism formalisms
containing incomplete state specifications boolean formulae compilable incomplete state specifications together boolean formulae however seem add significantly
expressiveness formalism since cannot compiled away even
allowing polynomial growth plan unbounded resources compilation process
noted however hold use semantics
conditional effects partial state specifications spelled section semantics
may get slightly different concerning compilability conditional effects partial
states
one question one may ask happens consider formalisms boolean formulae
syntactically restricted indicated places restricted formulae
cnf dnf formulae sometimes easily compiled away however
cases impossible example shown cnf formulae cannot compiled
basic strips preserving plan size linearly nebel confirms backstrom
conjecture cnf formulae preconditions add expressive power basic strips
another question reasonable restrictions compilation scheme particular
one may want know whether non modular state translation functions could lead powerful
compilation schemes first requiring state translation functions modular seems
quite weak considering fact compilation scheme concerned
domain structure initial state goal specification transformed
secondly considering fact state translation functions depend operator
set complicated functions seem useless technical point view need
modularity order prove conditional effects boolean formulae cannot compiled away
preserving plan size linearly conditional effects modularity similar condition seems
crucial case boolean formulae could weaken condition point
require state translation functions computable circuits constant depthor
something similar case additional freedom one gets non modular state translation
functions seem help functions take operators
account nevertheless seems interesting theoretical prove powerful
state translation functions add power compilation schemes
although mainly theoretical inspired recent approaches extend
graphplan handle powerful formalisms containing conditional
effects answers give open field
design first gazen knoblock compiling conditional effects away
optimal want allow plan growth constant factor secondly
approaches anderson et al kambhampati et al koehler et al
modify graphplan strategy similar polynomial time compilation
scheme preserving plan size polynomially reason approaches compared
pure compilation ideas compilation scheme developed
proof theorem base line thirdly allowing unrestricted boolean formulae adds
level expressivity cannot compiled away linear growth plan
size fact approaches one anderson colleagues simply expand
formulae dnf accepting exponential blow cannot better plan
size preserved linearly fourthly want add partial state specifications top
general boolean formulae would amount increase expressivity much larger


fic ompilability



e xpressive p ower p lanning f ormalisms

adding conditional effects general formulae basic strips case way
compile away even allow polynomial plan growth
finally one may wonder apply approaches translating bounded propositional logic satplan kautz selman
blackbox kautz selman since entire analysis relative expressiveness
formalisms uses assumption compile one formalism another
formalism tell us anything size representations switch
another formalism particular seems possible encoding bounded
conditional operators propositional logic concise encoding
unconditional operators advice give concise encoding
found first translating conditional actions unconditional actions standard encoding unconditional actions kautz mcallester selman generate boolean
formulae however addressing determining conciseness representation
context appears interesting relevant topic future

acknowledgments
reported started partly carried author enjoyed
visitor ai department university south wales many thanks go norman
foo maurice pagnucco abhaya nayak rest ai department discussions
cappuccinos would thank birgitt jenner jacobo toran clarifications
concerning circuit complexity

appendix symbol index
symbol

explanation
cardinality set
size instance
symbol used conditional effects

syntactic specialization relation

compilability relation restriction

boolean constant denoting falsity denoting

illegal state specification

boolean constant denoting truth

advice function
lff

active effects operator state state specification
ac
complexity class

boolean circuit
family boolean circuits

conp
complexity class
conp poly non uniform conp
closing set literals w r


plan e sequence operators
complexity class polynomial hierarchy


instance

l
v l

page









fin ebel





ffe ffe
u


f ffeff


b

e ghll
nc

np
np poly

l




ffi
l

p
p poly
ph



























planex

post

pre


pspace






lff
lff
c


























initial state description
compilation scheme n ffe ffe qff ffz p
transformation induced compilation scheme
components compilation scheme
goal task
set boolean formulae
boolean formulae
literal
sets literals
boolean formulae use atoms
set theory
complexity class
negative literals set literals
complexity class
non uniform np
operator n pre post p
set operators
set finite sequences operators
propositional atoms
potentially active effects operator
given state specification
complexity class
non uniform p
polynomial hierarchy
positive literals set literals
plan existence
postconditions operator
preconditions operator
complexity class
instance ffifft p
complexity class polynomial hierarchy
maps state specification operator state
extension lff plans
state truth assignment
state specification
strips formalism
strips literals preconditions
strips boolean formulae preconditions
strips incomplete state descriptions
strips conditional effects
strips combinations extensions
equivalence classes induced
equivalence classes induced
propositional atoms used set literals
countably infinite set propositional atoms


fic ompilability







r


ffz



x



















e xpressive p ower p lanning f ormalisms

finite subset
set literals overs
complexity class polynomial hierarchy
state translation functions compilation scheme
universal literals
word
complexity class
formalisms
domain structure fftp
family domain structures

references
anderson c r smith e weld conditional effects graphplan proceedings th international conference artificial intelligence systems aips pp aaai press menlo park
baader f formal definition expressive power knowledge representation languages
proceedings th european conference artificial intelligence ecai stockholm sweden pitman
backstrom c expressive equivalence formalisms artificial intelligence

backstrom c nebel b complexity sas computational intelligence
blum l furst l fast graph analysis artificial
intelligence
brewka g hertzberg j things worlds formalizing actions
plans journal logic computation
bylander computational complexity propositional strips artificial
intelligence
cadoli donini f survey knowledge compilation ai communications

cadoli donini f liberatore p schaerf comparing space efficiency
propositional knowledge representation formalism aiello l c doyle j shapiro
eds principles knowledge representation reasoning proceedings th
international conference kr pp cambridge morgan kaufmann
erol k hendler j nau htn complexity expressivity
proceedings th national conference american association artificial intelligence aaai pp seattle wa mit press


fin ebel

erol k hendler j nau complexity hierarchical task network
annals mathematics artificial intelligence
fikes r e nilsson n strips application theorem proving
solving artificial intelligence
furst saxe j b sipser parity circuits polynomial time hierarchy
mathematical systems theory
garey r johnson computers intractabilitya guide theory
np completeness freeman san francisco ca
gazen b c knoblock c combining expressiveness ucpop efficiency
graphplan steel alami r eds recent advances ai th european
conference ecp vol lecture notes artificial intelligence pp
toulouse france springer verlag
gogic g kautz h papadimitriou c h selman b comparative linguistics
knowledge representation proceedings th international joint conference
artificial intelligence ijcai pp montreal canada morgan kaufmann
kambhampati parker e lambrecht e understanding extending graphplan
steel alami r eds recent advances ai th european conference
ecp vol lecture notes artificial intelligence pp
toulouse france springer verlag
karp r lipton r j
mathematique

turing machines take advice

l ensignement

kautz h mcallester selman b encoding plans propositional logic
aiello l c doyle j shapiro eds principles knowledge representation
reasoning proceedings th international conference kr pp cambridge morgan kaufmann
kautz h selman b forming concepts fast inference proceedings
th national conference american association artificial intelligence aaai
pp san jose ca mit press
kautz h selman b pushing envelope propositional logic
stochastic search proceedings th national conference american association artificial intelligence aaai pp mit press
kautz h selman b blackbox application theorem
proving solving working notes aips workshop
combinatorial search pittsburgh pa
koehler j nebel b hoffmann j dimopoulos extending graphs
adl subset steel alami r eds recent advances ai th european
conference ecp vol lecture notes artificial intelligence pp
toulouse france springer verlag


fic ompilability



e xpressive p ower p lanning f ormalisms

lifschitz v semantics strips georgeff p lansky eds reasoning actions plans proceedings workshop pp timberline
morgan kaufmann
nebel b expressive power disjunctive preconditions biundo fox
eds recent advances ai th european conference ecp
durham uk springer verlag appear
papadimitriou c h computational complexity addison wesley reading
pednault e p adl exploring middle ground strips situation
calculus brachman r levesque h j reiter r eds principles knowledge
representation reasoning proceedings st international conference kr
pp toronto morgan kaufmann
yap c k consequences non uniform conditions uniform classes theoretical
computer science




