Journal Artificial Intelligence Research 12 (2000) 271-315

Submitted 2/00; published 5/00

Compilability Expressive Power
Propositional Planning Formalisms
Bernhard Nebel

NEBEL @ INFORMATIK . UNI - FREIBURG . DE

Institut fur Informatik, Albert-Ludwigs-Universitat, Georges-Kohler-Allee, D-79110 Freiburg, Germany

Abstract
recent approaches extending GRAPHPLAN algorithm handle expressive
planning formalisms raise question formal meaning expressive power is.
formalize intuition expressive power measure concisely planning domains
plans expressed particular formalism introducing notion compilation
schemes planning formalisms. Using notion, analyze expressiveness
large family propositional planning formalisms, ranging basic STRIPS formalism
conditional effects, partial state specifications, propositional formulae preconditions.
One results conditional effects cannot compiled away plan size grow
linearly compiled away allow polynomial growth resulting plans.
result confirms recently proposed extensions GRAPHPLAN algorithm concerning
conditional effects optimal respect compilability framework. Another result
general propositional formulae cannot compiled conditional effects plan size
preserved linearly. implies allowing general propositional formulae preconditions
effect conditions adds another level difficulty generating plan.

1. Introduction
G RAPHPLAN (Blum & Furst, 1997) SATPLAN (Kautz & Selman, 1996) among
efficient planning systems nowadays. However, generally felt planning formalism
supported systems, namely, propositional basic STRIPS (Fikes & Nilsson, 1971),
expressive enough. reason, much research effort (Anderson, Smith, & Weld, 1998; Gazen
& Knoblock, 1997; Kambhampati, Parker, & Lambrecht, 1997; Koehler, Nebel, Hoffmann, & Dimopoulos, 1997) devoted extending GRAPHPLAN order handle powerful
planning formalisms ADL (Pednault, 1989).
appears consensus much expressive power added particular language feature. example, everybody seems agree adding negative preconditions
add much expressive power basic STRIPS, whereas conditional effects considered
significant increase expressive power (Anderson et al., 1998; Gazen & Knoblock, 1997;
Kambhampati et al., 1997; Koehler et al., 1997). However, unclear measure expressive power formal way. Related problem question whether compilation
approaches extend expressiveness planning formalism optimal. example, Gazen
Knoblock (1997) propose particular method compiling operators conditional effects
basic STRIPS operators. method, however, results exponentially larger operator sets.
people (Anderson et al., 1998; Kambhampati et al., 1997; Koehler et al., 1997) agree
cannot better that, nobody proven yet space-efficient method
impossible.
c 2000 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiN EBEL

order address problem measuring relative expressive power planning formalisms, start intuition formalism least expressive another formalism planning domains corresponding plans formalism concisely expressed
formalism . This, least, seems underlying intuition expressive power
discussed planning literature.
Backstrom (1995) proposed measure expressiveness planning formalisms using
ESP-reductions. reductions are, roughly speaking, polynomial many-one reductions
planning instances change plan length. Using notion, showed
propositional variants basic STRIPS containing conditional effects arbitrary logical
formulae considered expressively equivalent. However, taking point view, ESPreductions restrictive two reasons. Firstly, plans must identical size, might
want allow moderate growth. Secondly, requiring transformation computed
polynomial time overly restrictive. ask concisely something expressed,
necessarily imply exists polynomial-time transformation. fact, one
formalism might expressive another one, mapping formalisms might
computable all. This, least, seems usual assumption made term
expressive power discussed (Baader, 1990; Cadoli, Donini, Liberatore, & Schaerf, 1996; Erol,
Hendler, & Nau, 1996; Gogic, Kautz, Papadimitriou, & Selman, 1995).
Inspired recent approaches measure expressiveness knowledge representation formalisms (Cadoli et al., 1996; Gogic et al., 1995), propose address questions
expressive planning formalism using notion compiling one planning formalism
another one. compilation scheme one planning formalism another differs polynomial many-one reduction required compilation carried polynomial
time. However, result expressible polynomial space. Furthermore, required
operators planning instance translated without considering initial state
goal. restriction might sound unnecessarily restrictive, turns existing
practical approaches compilation (Gazen & Knoblock, 1997) well theoretical approaches
(Backstrom, 1995) consider structured transformations operators transformed
independently initial state goal description. technical point view
restriction guarantees compilations non-trivial. entire instance could transformed,
compilation scheme could decide existence plan source instance generate
small solution-preserving instance target formalism, would lead unintuitive
conclusion planning formalisms expressive power.
mentioned beginning, space taken domain structure important,
space used plans. reason, distinguish compilation schemes
whether preserve plan size exactly, linearly, polynomially.
Using notion compilability, analyze wide range propositional planning formalisms, ranging basic STRIPS planning formalism containing conditional effects, arbitrary boolean formulae, partial state specifications. one results, identify two
equivalence classes planning formalisms respect polynomial-time compilability preserving plan size exactly. means adding language feature formalism without leaving
class increase expressive power affect principal efficiency
1. assume reader basic knowledge complexity theory (Garey & Johnson, 1979; Papadimitriou,
1994), familiar notion polynomial many-one reductions complexity classes P, NP, coNP,
PSPACE. notions introduced paper needed.

272

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

planning method. However, provide results separate planning formalisms using
results computational complexity theory circuit complexity non-uniform complexity
classes. separation results indicate adding particular language feature adds expressive power difficulty integrating feature existing planning algorithm.
example, prove conditional effects cannot compiled away boolean formulae
cannot compiled conditional effectsprovided plans target formalism allowed
grow linearly.
answers question posed beginning. compilation approach proposed Gazen
Knoblock (1997) cannot space efficient, even allow linear growth plans
target formalism. Allowing polynomial growth plans, however, compilation
scheme space efficient. Interestingly, seems case compilation scheme
allows polynomially larger plans similar implementation conditional effects
IPP system (Koehler et al., 1997), Kambhampati colleagues' (1997) planning system,
Anderson colleagues' (1998) planning system.
rest paper structured follows. Section 2, introduce range propositional planning formalisms analyzed paper together general terminology definitions.
Based that, introduce notion compilability planning formalisms Section 3.
Section 4 present polynomial-time compilation schemes different formalisms
preserve plan size exactly, demonstrating formalisms identical expressiveness.
remaining cases, prove Section 5 cannot compilation scheme
preserving plan size linearly, even bounds computational resources
compilation process. Section 6 reconsider question identical expressiveness using compilation schemes allow polynomial growth plans. Finally, Section 7
summarize discuss results.

2. Propositional Planning Formalisms
First, define general propositional planning formalism, appears almost
expressive propositional variant ADL (Pednault, 1989). formalism allows arbitrary
boolean formulae preconditions, conditional effects partial state specifications. Subsequently,
specialize formalism imposing different syntactic restrictions.
2.1 General Propositional Planning Formalism
Let countably infinite set propositional atoms propositional variables. Finite
subsets denoted . Further, defined set consisting constants
(denoting truth) (denoting falsity) well atoms negated atoms, i.e., literals,
. language propositional logic logical connectives
fiff ,
propositional atoms denoted . clause disjunction literals. Further, say
formula conjunctive normal form (CNF) conjunction clauses.
disjunctive normal form (DNF) disjunction conjunctions literals.
Given set literals , refer positive literals , "!$#%& refer
negative literals , '(& atoms used , i.e., '($fi*),+.-//102-33 4-5
2. Note Gazen Knoblock's (1997) translation scheme generates planning operators depend
initial state goal description. However, operators simply code initial state goal description
nothing else. reason, ignore here.

273

fiN EBEL

76

. Further, define 8 element-wise negation , i.e.,

8),+.-90:4-35;6&<=+>4-?0@-=376BA
state C truth-assignment atoms . following, identify state
set atoms true state. state specification subset , i.e., logical
theory consisting literals only. called consistent iff contain complementary literals
. general, state specification describes many states, namely satisfy ,
denoted EF:GH$D( . case complete, i.e., -3/ either -=/D
4-IJD , precisely one model, namely K>$D( . abusing notation, refer
inconsistent state specification , illegal state specification.
Operators pairs LM)ON pre post P . use notation pre LB post LQ refer first
second part operator L , respectively. precondition pre element RKSKT , i.e.,
set propositional formulae. set post, set postconditions, consists
conditional effects, form

UWV Xff
UZY



called effectV conditions elements
called
elements
U
effects. singleton sets, e.g., +.-H6
+\[]6 , often omit curly brackets write
- V [.
Example 1 order illustrate various notions, use running example planning
problems connected production camera-ready manuscripts LATEX source files
somewhat simplified, course. set atoms , choose following set:

^),+`_bacffed]fgcffihQj]klffgm no4ffgp\qgffgrsklrsffgr]rsmlffgrsm o4fftklu>hvfftk hQcfftkwm
hQj]k klu>h nxQffihBjsk y>k _za nx6BA
propositional atoms following intended meaning. atoms first line represent
presence corresponding files, atoms second line signify index
citations correct dvi-file. Based that, define following operators: rBkwr\_bac , d{_zac ,
| d]xea>kwu{h]ac . first operators simple. precondition execution
rBklr - d]fgc -file exist. successful execution, r]rsm - r]m -file
produced:

rBklr{_zacM)~}`d]fgcffgrBkwr4ff{v V +Brsrsmlffgrsm ov6"vA



| d]xea>kwu{hsac

operator similar:

| d]xea>kwu{h]acM)}4`k hc`4ff{v V +Qkwu{h`fftklm ov6"vA
Finally, d{_zac operator bit complicated. precondition needs presence
_bac -file produces effect d]fgc -, k hc -, hBjsk , -files unconditionally. addition,
know citations correct rsr]m -file present index correct
274

fiC OMPILABILITY

klu>h

-file present:



E XPRESSIVE P OWER P LANNING F ORMALISMS

d{_bac)~}_zac`4ff
V
V
rsr]m
fir]rsV
klu>h

+{d]f:cfftk hQcffihBjsklffgm no`6Bff
V hBjs8k hQy>j]k _bk y>k n_zaxff nxQff
hBjsk klu>h nxQff
V
kwu{h 8hQj]k kwu{h nx 4

semantics operators given state-transition functions, i.e., mappings states
states. Given state C set postconditions post, CBff post denotes active effects C :

MCsff post()+\0 UWV &

post ffeC0 )

U 6BA

state-transition function { induced operator L defined follows:

>\
{C>)

R 3 R
C7fi"!$#%$Csff post LB..<$MCsff post LB.. C0 ) pre LB

CBff post LQ.0)

undefined

otherwise

words, precondition operator satisfied state C active effects consistent,
state C mapped state C: differs C truth values active effects
forced become true positive effects forced become false negative effects.
precondition satisfied set active effects inconsistent, result function
undefined.
planning formalism itself, work states state specifications. general,
lead semantic problems. restricting state specifications sets
literals, however, syntactic manipulations state specifications defined way
sound Lifschitz' (1986) sense.
Similarly active effects respect states, define corresponding function
respect state specifications:

$Dff post *)+\I0 UWV fifi

post ffD^0 )

U 6BA

Further, define potentially active effects follows:

$Dff post () CBff postA
e %


$Dff post ,
state specification operator L5)N pre post P , $Dff post )
means state specification resulting application state-transition functions
might representable theory consisting literals only. reason, consider
operator application illegal, resulting illegal state specification . could
liberal point consider operator application state specification illegal
set states resulting applying state-transition functions could definitely represented
3. Note happen state specification incomplete.

275

fiN EBEL

theory consisting literals only. Alternatively, could consider atoms mentioned
$Dff post ,M$D8ff post unsafe application operator delete literals
7 $D8ff post $Dff post . state specification, consider resulting state specification
still legal $Dff post consistent. Since seem exist standard model
execution conditional effects presence partial state specifications, adopt first
alternative one arbitrary choice. noted, however, decision influences
results present below.
$Dff post leads illegal state specification,
Similarly rule $Dff post )
require precondition satisfied states EF:GH$D( state specification
already inconsistent, result applying L results . leads definition
function , defines outcome applying operator L set operators
state specification:

R 1 R
D/($Dff post LQ.<5M$D8ff post LB. D0)

0 ) pre LB
J

$D8ff post LB.0)

$Dand
$D8ffiLQ)


$

8




B
L
.



)
post LB.
post





otherwise

Example 2 Using propositional atoms operators Example 1, assume following
two state specifications
)+:_zacKfftklu>hK6 , )+:_bacKfftklu{h`ffgrsr]mffgrsm ov6 . try apply
operator d{_bac , notice results



post zm d\_bacB.) +{d]fgcfftk hcffihQj]klffgm no4ffihQj]k klu{h nx6Bff
post zm d\_bacB.) post zm d{_bacB.H<=+\hBjsk y>k _za nxQff8hQj]k y>k _ba nx6Bff



post zm d\_bacB.A hand, apply rBkwr\_bac
i.e., post zm d{_bacB.)

successfully : ffgrBkwr\_bacB()



easily verified syntactic operation state specification using function
corresponds state transitions states described specification.
Proposition 1 Let state specification, L operator, { induced state-transition
function. $D8ffiLQ0) ,

EF:GH$$DffiLB.),+{C 0gC ){C>ffeC0 )Dfi6BA
$DffiLB;0 ) , either
1.

EF:GH$D()

,

2. two states C
3.

MC post LB. ,
ffeC /E:G$D( MC post LB.)
exists state CWE:GH$D {>C> undefined.
276

fiC OMPILABILITY

E XPRESSIVE P OWER P LANNING F ORMALISMS



words, whenever $DffiLB results legal specification, specification describes
states result application state-transition function > states satisfy
original state specification . Further, $D8ffiLQ illegal, good reasons it.

planning instance tuple

)~N&ffifft5Pff






)~N$fftP domain structure consisting finite set propositional atoms
finite set operators ,


initial state specification,
goal specification.



talk size instance, symbolically 00 00 , following, mean size
(reasonable) encoding instance.
following, use notation refer set finite sequences operators.
Elements called plans. 00 300 denotes size plan, i.e., number
operators . say -step plan 00 3008 . result applying state
specification recursively defined follows:

!B
;
R R
;!t$Dff\N$P.)
;!t]$Dff\NL iff L ffgAgAgA:ffiL>KP.) ;!]$$DffiL ff\NL ffgAgAgA{ffiL{KP.


sequence operators said plan solution iff
1. X!]ffe0)
2. X!]ffe;0 ) .
Example 3 Let propositional
atoms operators introduced Example 1
consider following planning instance:
)N.N$fftPfft+:_bacKffgrBklr]ffklu>hK6Bfft+\hBjskffihQjsk y>k _za nx6>PA
words, given latex source file (_bac ) bibliography database ( rBklr ), want generate dvi
file (hBjsk ) citations file correct (hBjsk y>k _ba nx ). Furthermore, know
know index file yet
anything existence bbl-file aux-file etc.,
( kwu{h ). plan )~Nzrsklr\_bacffgm d{_zacsP solution plan result illegal
state specification resulting state specification entails hQj]k hBjsk y>k _ba nx .
Plans satisfying (1) (2) sound. order state precisely, extend
notion state transition functions operators state transition functions plans. Let {
state transition function corresponding composition primitive state-transition functions
induced operators )~NL ffgAgAgA\ffiL>P , i.e.,



B e. b> ) >eAgAgAQfi{bvff
4. could liberal requiring . done order allow fair
comparison restricted planning formalisms.

277

fiN EBEL


e. C> defined iff e. b C defined every , 9 . Using
notion, one easily proveusing induction plan lengththat plan instance
sound Lifschitz' (1986) sense, i.e., corresponds application state transition functions
initial states.


Proposition 2 Let )N&ffifft5P planning instance
. X!]ffe consistent,

)NL gff AgAgA\ffiL>P

element

E:GH$X!ffe.),+{C 0tC ){C>ffeC0 )>6BA
;!]ffe inconsistent, either
1.

EF:GH\()

,

2. exists (possibly empty) prefix
X!]ff\NL ffgAgAgA:ffiL P. either



(a) two states C


NL gff AgAgA\ffiL>$P (
3~ )

eff C WEF:GH$D(

MC

(b) exists state CWE:GH$D {bw

C>



D)

C post L> . ,
post L>2 .)
undefined.

2.2 Family Propositional Planning Formalisms
propositional variant standard STRIPS (Fikes & Nilsson, 1971), call
follows, planning formalism requires complete state specifications, unconditional
effects, propositional atoms formulae precondition lists. Less restrictive planning
formalisms following additional features:
Incomplete state specifications ( ): state specifications may complete.
Conditional Effects ( ): Effects conditional.
Literals formulae ( ): formulae preconditions effect conditions literals.
Boolean formulae ( ): formulae preconditions effect conditions arbitrary
boolean formulae.
extensions combined. use combinations letters refer multiple
extensions. instance, refers formalism extended literals precondition lists,

`s refers formalism allowing incomplete state specifications conditional effects,
%QB , finally, refers general planning formalism introduced Section 2.1.



Example 4 consider planning instance Example 3, becomes quickly obvious
instance expressed using . initial state specification incomplete,

operator d{_zac contains conditional effects negative literals effect conditions. However,
need general Boolean formulae express instance.
278

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

`{

>

>>



{

`Q

`

`








Figure 1: Planning formalisms partially ordered syntactic restrictions

Figure 1 displays partial order propositional planning formalisms defined way.
sequel say specialization , written , iff identical
diagram depicting partial order.
Comparing set planning formalisms one Backstrom (1995) analyzed, one notices despite small differences presentation planning formalisms:



common propositional strips (CPS),

propositional strips negative goals (PSN),
ground Tweak (GT).
2.3 Computational Complexity Planning -Family

one would expect planning much easier planning %s , turns
case, provided one takes computational complexity perspective.
analyzing computational complexity planning different formalisms, consider,
usual, problem deciding whether exists plan given instancethe plan existence
problem (PLANEX). use prefix referring planning formalism consider
existence problem particular planning formalism.
Theorem 3



-PLANEX PSPACE-complete



%QB .

5. consider planning formalisms identical SAS formalism (Backstrom & Nebel, 1995), since
allow multi-valued state variables.

279

fiN EBEL

Proof. PSPACE-hardness -PLANEX follows result Bylander (1994, Corollary 3.2).
Membership %Qs -PLANEX PSPACE follows could, step step, guess
sequence operators, verifying step operator application leads legal follow
state specification last operator application leads state specification entails
goal specification. step, verification carried polynomial space. reason
conditions definition verified polynomially many calls
NP-oracle. Therefore, %Qs decided non-deterministic machine polynomial space,
hence member PSPACE.
follows plan existence problem formalisms expressiveness
%s including formalismsis PSPACE-complete.

3. Expressiveness Compilability Planning Formalisms
Although difference computational complexity formalisms
QB -family, might nevertheless difference concisely planning domains plans
expressed. order investigate question, introduce notion compiling planning formalisms.
3.1 Compiling Planning Formalisms
mentioned Introduction, consider planning formalism expressive another
formalism planning domains plans formulated formalism concisely expressible
. formalize intuition making use call compilation schemes,
solution preserving mappings polynomially sized results domain structures
domain structures. restrict size result compilation scheme,
require bounds computational resources compilation. fact, measuring
expressibility, irrelevant whether mapping polynomial-time computable, exponential-time
computable, even non-recursive. least, seems idea notion expressive
power discussed similar contexts (Baader, 1990; Erol et al., 1996; Gogic et al., 1995; Cadoli
et al., 1996). want use compilation schemes practice, reasonably
efficient, course. However, want prove one formalism strictly expressive
another one, prove compilation scheme regardless many
computational resources compilation scheme might use.
far, compilation schemes restrict size domain structures. However, measuring expressive power, size generated plans play role. Backstrom's
ESP-reductions (1995), plan size must identical. Similarly, translation


proposed Gazen Knoblock (1997) seems implicit prerequisite plan
length target formalism almost same. comparing expressiveness
different planning formalisms, might, however, prepared accept growth plans
target formalism. instance, may accept additional constant number operators,
may even satisfied plan target formalism linearly polynomially larger.
leads schematic picture compilation schemes displayed Figure 2.
Although Figure 2 gives good picture compilation framework, completely
accurate. First all, compilation scheme may introduce auxiliary propositional atoms
used control execution newly introduced operators. atoms likely
initial value may appear goal specification planning instances target
280

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS




Planning

compilation





G



B

Planning



Figure 2: compilation framework

formalism. assume compilation scheme takes care adds literals
initial state goal specifications.
Additionally, translations initial state goal specifications may necessary.
want compile formalism permits literals preconditions goals one requires atoms, trivial translations necessary. Similarly, want compile formalism
permits us use partial state specification formalism requires complete state specifications, translation initial state specification necessary. However, state translation
functions limited. depend set symbols source
formalism, context-independent, i.e., translation literal state specification
depend whole specification, efficiently computable.
compilation framework theoretical tool measure expressiveness, has,
course, practical relevance. Let us assume reasonably fast planning system
planning formalism want add new feature resulting formalism .
come efficient compilation scheme , means easily integrate
new featureeither using compilation scheme modifying planning algorithm
minimally. compilation scheme exists, probably would problems integrating feature. Finally, computationally expensive compilation schemes exist, interesting
situation. case, off-line compilation costs may high. However, since compiled
domain structure used different initial goal state specifications, high off-line costs
may compensated efficiency gain resulting using planning algorithm.
turns, however, situation arise analyzing compilability %Qs formalisms. Either identify polynomial-time compilation scheme able prove
compilation scheme exists.

6. means compilation schemes planning formalisms similar knowledge compilations (Cadoli &
Donini, 1997), fixed part computational problem domain structure variable part consists
initial state goal specifications. main difference knowledge compilation framework
take (size the) result account. words compile function problems instead decision
problems.

281

fiN EBEL



3.2 Compilation Schemes
Assume tuple functions M)N>>ffe ffe>Qff
N&ffifft5P -instances follows:

ffz>P

induce function





-instances

)



()N@>>ffe H< $ffi\ffe>s%<zs$fft9.PgA


following three conditions satisfied, call compilation scheme



iff exists plan

1. exists plan



;

2. state-translation functions z modular, i.e.,
D0) , functions (for ?)eff ) satisfy






:

~) </ ,

,



$ffD(()
$ ffDfiff H< $ ffDff

polynomial-time computable;
3. size results >\ffe , > polynomial size arguments.
Condition (1) states function induced compilation scheme solutionpreserving. Condition (2) states requirements on-line state-translation functions. result
functions computable element-wise, provided state specification consistent. Considering fact functions depend original set symbols
state specification, requirement seem restrictive. Since state-translation
functions on-line functions, require result efficiently computable.
Finally, condition (3) formalizes idea compilation. compilation much
important result concisely represented, i.e., polynomial space, compilation process fast. Nevertheless, interested efficient compilation schemes. say
polynomial-time compilation scheme >\ffe , > polynomial-time computable
functions.
addition resource requirements compilation process, distinguish different compilation schemes according effects size plans solving
property every plan
instance target formalism. compilation scheme
solving instance exists plan solving 00 @0000 300

positive integer constant , compilation scheme preserving plan size exactly (up additive
00 300 positive integer constants
, compilation
constants). 00 @00K
scheme preserving plan size linearly, 00 00-i00 300lff{00 00 polynomial - ,
compilation scheme preserving plan size polynomially. generally, say planning formalism compilable formalism (in polynomial time, preserving plan size exactly,
linearly, polynomially), exists compilation scheme appropriate properties.

write
case compilable compilation done polynomial time. super-script , , - depending whether scheme preserves plan size
exactly, linearly plan, polynomially, respectively.
easy see, notions compilability introduced reflexive transitive.
7. Although hard imagine modular state-translation function polynomial time computable,
pathological function could, e.g., output translations exponential size encoding symbols.

282

fiC OMPILABILITY

Proposition 4 relations







E XPRESSIVE P OWER P LANNING F ORMALISMS







transitive reflexive.

Furthermore, obvious moving upwards diagram displayed Figure 1,
always polynomial-time compilation scheme preserving plan size exactly. v denotes
projection -th argument function returns always empty set, generic
compilation scheme moving upwards partial order )ON ffeffeff P .
Proposition 5 J ,









.

4. Compilability Preserving Plan Size Exactly
Proposition 5 leads question whether exist compilation schemes
implied specialization relation. Proposition 5 Proposition 4,
find compilation schemes every pair formalisms. suffices prove compilable
, order arrive conclusion formalisms compilable
formalisms .
preview results section given Figure 3. establish two equivalence
classes members class compilable preserving plan size exactly.
two equivalence classes called - -class, symbols ,




naming respective largest elements.

{

>

>



{

Q

>







`


Figure 3: Equivalence classes planning formalisms created polynomial-time compilation
schemes preserving plan size exactly

283

fiN EBEL

4.1 Planning Formalisms without Conditional Effects Boolean Formulae
First, show formalisms analyzed Backstrom (1995), namely, , ,


polynomial-time compilable preserving plan size exactly. fact, fourth class
added set, namely, ` , lies .

words, using notion compilability, get equivalence class
Backstrom's ESP-reductions. closer look proofs Backstrom's (1995) paper reveals surprising ESP-reductions used could reformulated
compilation schemes. Since used quite different notation, nevertheless prove claim
first principles.
key idea compiling planning formalisms literals formalisms allow atoms

consider - 4- different atoms new formalism. purpose, introduce
!
!
, "? set negative
copy . Further,
J),+ -0 -=/6 , i.e., disjoint
!
literal 4- replaced - , i.e.,
#

?)
"



!

!
+.-//I0 -3=76fi<=+ -3
J0:4-53;6

0)
otherwise.

!

Using < new set atoms, one translate state specifications preconditions easily. postconditions make sure intended semantics taken care of, i.e.,
!
whenever - added, - must deleted vice versa.
Finally, deal problem partial state specifications. However,
problem effects unconditional preconditions contain atoms.
case, safely assume atoms unknown truth-value false without changing
outcome application operator. Let $&%*fi denote completion respect
, i.e.,

fi*),+>4-90 -3/ff-3
76fi<?XA

$&%

Using function, transform partial state specification complete specification
without changing outcome, i.e., get plans.
Theorem 6
exactly.

, ` ,

, polynomial-time compilable preserving plan size

Proof. Since ^`H Z

, follows Propositions 4 5
show

order prove claim.

Let )N&ffifft5P -instance )N$fftP . translate operator L

operator
!
L)~N'" pre LBff(" post LQ<5)"5 post LQ.PA
set operators denoted
N>>ffe ffe>Qff ffz{P follows:

>)
)
>s)
$ffi\)
zs$fft9)



!

. define compilation scheme
!

!

$N <
Pff


$&% +* ! ' "?\ff
"==A
284

W)

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

satisfies conditions (2) (3), functions computed polyThe scheme obviously
nomial time, -instance.
. obvious
Let
!

$ff$DffiLB.(), $ffD(ff LBA
!

) .N -L ffgAgAgA:ff/L- P denote sequence operators corresponding sequence operators

)~NL ffgAgAgA:iff L>vP . Using induction plan length, easy show
!
plan iff plan ,
i.e., condition (1) compilation schemes satisfied. means, fact compilation
Let

scheme. Further, since plan size change, compilation scheme preserves plan size
exactly. Finally, functions computed time polynomial arguments,
polynomial-time compilation scheme.
One view result matter whether, expressivity point view,
allow atoms literals matter whether complete partial state
specificationprovided propositional formulae conditional effects allowed.
4.2 Planning Formalisms Conditional Effects without Boolean Formulae
Interestingly, view spelled generalizes case conditional effects allowed. case matter whether atoms literals allowed
whether partial complete state specifications. proving that, however, two
additional complications. Firstly, one must compile conditional effects partial state specifications conditional effects complete state specifications. problem
$D8ff post LB. definition function must tested. Seccondition $Dff post LQ.)
ondly, compiling formalism literals formalism allows atoms only,
condition M$Dff post LB.0) definition must taken care of. reason,
prove result two steps.
first step, show compiled . problem specifying


compilation scheme execution operator L partial state specification leads

$Dff post LB. .
illegal state $Dff post LB.)
considering running example (Ex. 1), things quite obvious. state specification contain literal negation literal mentioned effect
condition, illegal state specification results. example, state specification neither contain r]rsm &rsrsm , result executing d{_bac . general case, however,
things less straightforward effect literals produced one conditional
rule effect condition consist one literal.
Assuming without loss generality (using polynomial transformation) effects
singleton sets, check following condition. Either one conditional effects
effect literal activatedi.e., effect condition entailed partial state
conditional effects effect literal blocked, i.e., effect condition
contains literal inconsistent state specification. true, original operator
$Dff post LQ. , otherwise resulting state specification inconsistent.
satisfies $Dff post LB.)
example, consider following operator:

L )


N$fft+Q+.-ff8[]6 V +>4-H6Bfft+10ff2v6 V +>4-H6Q6>PA
285

fiN EBEL

application operator satisfies $Dff post LB.)
1.
2.

-

0

8[ true state specification,

$Dff post LB.

iff either

2 true state specification,

3. one - *[ false one 0 2 false.



cases, get M$D8ff post LB.)
$Dff post LB. result illegal state. order
test condition formalism complete states introduce four new sets atoms:

)
)

+.- 0 -3=6Bff
.+ - 0@-3/6Bff
43 ) .+ -53=0@-3/6Bff
6
) +1 7X0 8 th conditional effect L 6BA
atom - true either - 4- part original partial state specification. atom
- set true operator one conditional effects adds - - appear
effect operator. atom 5
- 3 set true operator one conditional effects deletes
- 4- appear effect operator. Finally, atoms form 7 added
action 8 th conditional effect th operator blocked effect condition. Using
new atoms, could translate operator

N$ff8+H+.-`ffi[>ff-ff8[]6 V V +.-4 ff-53*ff4-6Bff
+ 0 2 0ff V 2`6 +.- ff- 3 ff4-H6Bff
1
+.-`ff4-6 V +1 6Bff
+\[ ffi[]6 V 1+ 6Bff
+ 04ff9 0H6 V 1+ 6Bff
1
+ 2]V ff9 2v6 1+ ` 6Bff
1
V <5 3 6 I+.- 3 6Bff

+ ;:X 7 (0 < )Z
1
.6Q6>PA
Let = eff>8] function returns - 5
- 3 , - 4- , respectively, effect 8 th
conditional effect th operator. Assuming atoms set according
6
intended semantics previous operator deleted atoms 7=<W4
35< ,
>L ! )

following test operator checks whether original operator would led inconsistent result:
test

)

ffA@+>9 7ff9=8 iff>8]e6 V 0( 7
?

6BDC



Whenever 9 7 , means 8 th conditional effect th operator (which must
previously executed operator) blocked. addition effect conditional
$Dff post LB.
effect activated, i.e., 9=8 iff>8] true, would $Dff post LB.)
original formalism. reason, force illegal state. Conversely, either 7 true
8 false one 8 , = eff>8] true, would $Dff post LQ.) $D8ff post LB.
original formalism need force illegal state.
!
could force, using extra literals, operator L{ test operator
applied. would result compilation scheme preserves plan size linearly. However,
possible better that. key idea merge test operator th step
operator step E .
286

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

polynomial-time compilable preserving plan size exactly.

)N&ffifft9P -instance ~)N$fftP . Without loss generality,
Proof. Let
assume postconditions operators L 1 following form:
V F ffgAgAgA:ffi : H
G
V F :z6Bff
post L ),+\





F
7
7I .
Lemma 7



First, introduce number new sets symbols pairwise disjoint disjoint
:

)
JI )
)


)

I3

3
6

6

+.-
.+ -KI
+.-
+.- I3
+.- 3



)
)

)


0@-=/6Bff
0z-3/6Bff
0z-3/6Bff
0z-3/6Bff
0z-3/6Bff
+1KI 7 0 8
+1 7 0 8

th conditional effect L

6Bff
th conditional effect L 6BA

, denotes set primed literals, i.e., )+.- 0i-^Z76<
given set literals
2, i.e., C]Mv=)
+>4-`*0"$4- W76 function CLl denotes successor function modulo
6
MN\DOQPSRUT . Further, functions =WV )ff: shall functions V JV <9JV3

#
V [Bfi post L
V / V
[
7

= V eff>8])
[ V3 / V3 ( 7 V 8[B post L>A
let postV

L

postV
let block V

L

)ff: defined follows

L *)+\/<?'(2 VV .+ -ff-`ff- V
6 0@-3/ff\ V V %- post L e6&<
+\/<?'(2 >+ 4-ff-`ff- V3
6 0 -3Wff\
" - post L>$e6Bff

)ff: defined
block V

L ()+Q+\[ffi[{ 6 V V V 7 0Q 7 VXVXF F 7{ post L ff\$*[Q75 7>6&<
+Q+>8[ffi[ 6 WV 7 0 7
7\& post L ffi[3 7>6Bff

let testV defined

Z
Z
Z
6 Z
V\[ 6BA
),+Q+>D 7 V\[ ff9= V\[ iff>8]e6 V 0] 7 V\[
6
V .
Further, let , , fresh symbols appearing <3 <=JV <3JV 3 <
define pair compiled operators L V ( )ff: ) corresponding original operator L W :
L V )ON pre L H<=+\ V 6Bff postV V L %< blockV ZL %< testV <
+> V +>*/ V]ff^ `ffi V\[b6Q67<
+> V V <9 V3 6 J+1= V iff>8]e6Q6X<
+>
+ K:;
1
V 7
.6Q6&<
Z V\[ V]0 < Z V\[ )
6
V
+>
<5( 3 <5 Z V\[ 6BA
{C

1 V

287

fiN EBEL

pair compiled operators achieves intended effects keeps track fully known
atoms using postV , checks conditional effects blocked using block V , tests whether
$Dff post LB. using
execution previous operator satisfied condition $Dff post LB.)
testV , setup bookkeeping atoms next step. Using atoms /V , enforced
executing testing merged parallelizing test step execution step 9 .
order check execution last step, need extra checking step:

L V )ON +\ V B6 test V <=+> V +\`ff8 V Q6 6>PA
specify compilation scheme

> )

follows:
6
6
N\
9
<




9
<

<=+\`ffi ffi{g6Bff
<5 <5 3 <93 <
<
_
+\L ffiL 0tL 1?6fi<=+\L ffiL 6>Pff
6
6
+>^4ffi/IBff8 6&<9(JI 5
< ( <5JI3 <3( 3 <5 I(<9
+\v6Bff
$&% \%
< $&% +.- 0 -3=fft+.-ff"-H6Jff?)
]6>ff
/A

)
>B )
$ffi\ )
$fft5)

scheme obviously satisfies conditions (2), i.e., state-translation functions modular,
polynomially sized results. Further, functions
(3), i.e., compilation functions
computed polynomial time, -instance.

. obvious
Assume




< *)X!],z.$ffD(H<9>bff\NL P.5ff1
<
.$ff;!t]$Dff\NL> P..5ff1
provided ;!t]$Dff\NL P.0) . case ;!t]$Dff\NL P.F0 ) , either ;!t], $ffD(&< ff\NL P.0 )
M$Dff post L .) $Dff post L . . latter case, application operator
;!t], $ffD(ff\NL P. leads inconsistent state conditional effects test ,
part postconditions operators applicable state. Additionally, true
relation zb$ffX!]$Dff\NL>.ffiL 7 . ;!],zi$ffD(H<?>.ff\NL ffiL]7 P. .
Let )~NL ffgAgAgA\ffiL P denote sequence operators corresponding sequence operators
)~NL ffgAgAgA:ffiL>v P . Using induction plan length, easily shown







iff

plan

Further, since plan solving instance



exists plan



a` LAV


plan



.

must LAV last operator, follows

iff exists plan



.

follows immediately polynomial-time compilation scheme
preserving plan size exactly, proves claim.







proved compiled preserving plan size exactly, seems worth


noting result depends semantics chosen executing conditional operators partial state specifications. example, use alternative semantics deletes literals


7 $Dff post LB.ZM$Dff post LB. provided $Dff post LB. consistent, exists probably compilation scheme preserves plan size linearly. use semantics
288

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

resulting state specification legal application state-transformation functions leads
theory represented set literals, seems unlikely exists scheme
preserves plan size polynomially. reason pessimistic conjecture
semantics appears coNP-hard determine whether state specification resulting
applying B -operator legal.

second step showing partial state specifications literals compiled away,
show compile . key idea proof proof

!
Theorem 6. replace negative literal 4- new atom - . order detect inconsistencies
introduced conditional effects, add postcondition conditional effects form
!
+.-ff -%6 V . Further, check last operator plan introduce inconsistencies,
force application checking operator contains conditional effects.
Lemma 8




polynomial-time compilable



preserving plan size exactly.

Proof. Let
) N&ffifft9P -instance ) N$fftP . Since
postconditions operators L1 following form:

b

post LB()+\



VXb gff AgAgA\ffi




:

VXb

:







-instance,

6Bff

^7Bff 7
.
!
proof Theorem 6, shall disjoint copy , "9 set atoms
!
c LQ following set
negative literal 4- replaced atom - . let post
post
c LB()+

?^7 V '"

b

"

fi<5)"5
7

b

\(097 VXb {7
7

post LBe6BA

Further, let cons set conditional effects
cons

),+Q+.-ff -H! 6 V 0@-3/6Bff
!

let atom appearing , let L

L! )~N'"

let

!

O)+
L! 0tL1?6

pre LBff
post
c LBH< cons <=+>

V 9v6>Pff

, let operator L>

L>)~N$ff cons <=+> V ` 6>PA

specify compilation scheme

>Q )
)
>s )
$ffi\ )
zs$fft5)

follows:
!
!
N$< <3+\v6Bff =
< +\L>Q6>Pff
+>^ `6Bff
+\v6Bff
"?(<5d
"58ff
"=/A

satisfies conditions (2) (3), functions computed polyThe scheme obviously
nomial time, -instance.
289

fiN EBEL

Assume



. obvious
!

$ff$DffiLB.), $ffD(ff LBff

provided $DffiLB0)

!

!



!

case $DffiLB;0 ) , either , $ffD(ff LB;0 ) +.-ff -%6
, $ffD(ff LB -=/ .
!
latter case, application operator , $ffDff LB leads inconsistent state
conditional
effects cons, part postconditions.
!
Let )N.-L ffgAgAgA:ff/L- P denote sequence operators corresponding sequence operators

)~NL ffgAgAgA:ffiL>vP . Using induction plan length, easily shown







iff

plan

Further, since plan solving instance



exists plan



!

`



L>

plan



.

must L> last operator, follows

iff exists plan

follows polynomial-time compilation scheme
proves claim.









.

preserving plan size exactly,

result is, course, dependent semantics formalisms deal
$Dff post LB. .
complete state specifications, hence always M$Dff post LB.()
Theorem 9
size exactly.

, , `

,



polynomial-time compilable preserving plan

Proof. B follows Lemma 8, Lemma 7 Proposition 4. Using Propositions 4

5 fact `B` , claim follows.







5. Limits Compilation Preserving Plan Size Linearly
interesting question is, course, whether compilation schemes preserving plan
size exactly identified far. turns out, case. prove
pairs formalisms identified compilation scheme preserving
plan size exactly, compilation scheme impossible even allow linear increase
plan size. pairs formalisms even able prove polynomial increase
plan size would help establishing compilation scheme. results are, however,
fhe assumption. preview
conditional based assumption slightly stronger eF)g
results section given Table 1. symbol means exists compilation
scheme first formalism specialization second one. cases,
specify separation give theorem number result.
5.1 Conditional Effects Cannot Compiled Away
First all, prove conditional effects cannot compiled away. deeper reason
conditional effects, one independently number things parallel,
impossible formalisms without conditional effects. consider, example,
operator d{_zac Example 1, clear `propagates' truth value rsr]m klu{h
hQj]k y>k _ba nx hBjsk klu>h nx , respectivelyprovided state specification satisfies precondition.
290

fiC OMPILABILITY



%s


Qs


%s





%]


%Q
j


%


Cor. 15

Cor. 12

Cor. 15

Cor. 15

ji

ji

4i

Theo. 11

Cor. 12

Cor. 12

ji

ji

4i

Cor. 12

Cor. 12

Cor. 19

)





ji



%









Cor. 15









Theo. 14





)

















Cor. 15



Theo. 18






)

Cor. 19

%Q






Cor. 15







)

k



E XPRESSIVE P OWER P LANNING F ORMALISMS
















Cor. 15





)

Cor. 19



)

Table 1: Separation Results

obviously possible come set exponentially many operators
thing one step. However, unclear less exponentially many operators.
fact, show impossible.
order illustrate point, let us generalize example. start set
propositional atoms &) +.- ffgAgAgA:ff-``6 disjoint copy set: ml ) +.- l 0- ,fiv6 .
Further,






, Dnl shall denote corresponding set literals


Consider following





)



l

, i.e.,

)+.- l 0@- =Dfi6&<=+>4- l 0g4- /D6BA
l



domain structure:

fi<5 l
B
) @*N$fft+.- V - l ff"- V 4- l 0@- Wfiv6>P
) N$ ff8 PA
construction follows pairs fft5 consistent complete set
1l , instance )N `ffifft5P one-step plan. Conversely, pairs


fft9 gff l 1 l , exist solution.
Trying define domain structure polynomially sized 00 00 property

seems impossible, even allow -step plans. However, trying prove this, turns
additional condition state-translation function needed.
say state-translation functions local iff state specifications
ff5 )







$ Dpff qff s$ ffDff ()A
291





fiN EBEL

locality additional condition state-translation functions could easily prove
conditional effects cannot compiled away. Instead show, however,
possible derive weaker condition definition compilation schemes
enough prove impossibility result. weaker condition quasi-locality state-translation
functions relative given set symbols , turn based notion universal
F
literals. literal called universal literal given state-translation functions iff one
following conditions satisfied:
1. -3= :

F

2. -3= :

F

3. -3= :

F

4. -3= :

F

5. -3= :

F

6. -3= :

F

p +.-6Bfft+.-H6> ,
p +.-6Bfft+>4-H6> ,
p +.-6BffeB ,
pzs +.-H6Bfft+.-H6> ,
pzs +.-H6Bfft+>4-H6> ,
pzs +.-H6BffeB .

Let r denote set universal literals. define quasi-locality state-translation functions relative set propositional atoms induced set universal literals r follows.
D0) pairs ff3 ) ,








W
r

$ Dff sffzs$ ffDfiff







words, non-local literals quasi-local state-translation functions universal literals.
Lemma 10 given compilation scheme F)N>{ffe
00ut^
exists set atoms



ffe>Qff ffz>P natural number
quasi-local .

,

R;v function result union results possible
Proof. Let
translations literal returned state-translation functions, i.e.,
gl- *) +.-H6Bfft+.-H6>< +.-H6Bfft+>"-H6>< +.-H6BffeB.<
+.-H6Bfft+.-6>
< zB +.-H6Bfft+>4-H6>
< zs +.-H6BffeBA
Set

5)
w

r) . choose infinite subset
w





w

either

1. -3xw , finitely many atoms [xw" ,glor infinite subset w exist,
2.

w



universal literal

F


r

set r?`)
r<=+

F

6

Aff4g[Q.sUr )


,

.
F

r must
Note infinite subset w must exist. reason literal
occur infinitely many atoms w could find infinite subset
satisfying condition (1). single atom six possible ways generate
F
, must exist infinite subset literal occurs either v +.-H6Bfft+.-H6> ,
F
v +.-H6Bfft+>4-H6> , zv +.-H6BffeB (for ?)iff ) subset universal literal.
292

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

pick subset satisfying first condition, choose finite subset
desired cardinality state-translation functions quasi-local respect
r .
Otherwise repeat selection process w r condition (1) satisfied.
selection process repeated finitely often otherwise atoms tl- infinite result, impossible state-translation functions
polynomial-time computable therefore finite results.
demonstrates always exists set propositional atoms statetranslation functions quasi-local. However, might able effectively determine
set.
Using result, finally able prove non-existence compilation schemes
compiling conditional effects away preserving plan size linearly.
Theorem 11



cannot compiled % preserving plan size linearly.

Proof. Assume contradiction exists compilation scheme %Q preS
serving plan size linearly, compiles domain structure defined %

domain structure

> ) )ON$ tff PA
Lemma 10 assume set atoms chosen translation

functions quasi-local set.
Let us consider initial state specifications consistent complete
contain positive negative literals:

Obviously,
following form



{T





K
/R
+>fi4ff(fiK6BA

state specifications. assumption,

%Q

instance

N ff5 .$ ffi\H<?>b ff5 $ ffi l H<9 .P
-step plan. Since |i0 0 different -step plans, number polyno
mial size , plan used different initial statesprovided sufficiently

large.
Suppose plan used pairs fft ff\t fft , result :



) $fi4ffi H<9 K
) $ ffi l %<9
) $fi4ffi H<9 K
) zs$fi`ffi l %<9>s K

Since )
, must differ least one atom, say - . Without loss generality
assume -33 4-35 . Since successful plan modular,




follows

X!] ffeh}

zs +.- l B6 fft+.- l >6

}~

293

fiN EBEL

literals zs +.-Kl;6Bfft+.-KlX6> may added operators none literals
+.- l 6Bfft+.- l 6> deleted operator without reestablishing literal another
operator deletion. contains operators unconditional effects, adds
deletes literals regardless initial state.
F
Let us assume exists literal zs +.-Kl;6Bfft+.-KlX6> added .
F
implies 3t distinguish three cases:


= K , conclude F 3t .
F
2. p +.K
- lX6BffeB , implies F 3t .
F
3.
state z. +\[s6Bffi& [^) K- l ,+Q+\[s6BfftF +>*[s6Bffe]6 . assumed
F
translation functions quasi-local , must universal literal. universal

F
contain positive negative
, possible initial states
F
literals well literal elements . universal , present
F
reason. Further, added valid


plan , must part .



F
words, literals
+.K- lX6Bfft+.K- lX6> added already .
conclude
;!] ffe }y +.- l 6Bfft+.- l 6>A
1.

F

let

)
)

$ +.- l 6Bffi l J+>4- l 6>H<9

< +.- l 6Bfft+.- l 6>
) zs$ 4ffi l +>"- l 67<=+.- l 6>H<9>B vA
z modular, clear } therefore ;!t]t ffefi} .




achieves well +.-KlX6Bfft+.-KlX6> , follows (again modular), achieves

.

Since N ffi ffi l Z+>4K
- l;67</+.E- l76>P plan, plan

N ffi fft P . fact plan instance implies cannot compilation
scheme, desired contradiction.
Using Propositions 4 5 well Theorem 9, result generalized follows (see
Table 1).
Corollary 12 %Qs , %] ,
preserving plan size linearly.




cannot compiled %Q formalism specializing %

answers question whether space efficient compilation schemes

one proposed Gazen Knoblock (1997) possible. Even assuming unbounded
computational resources compilation process, space efficient compilation scheme
impossibleprovided compilation preserve plan size linearly. allow polynomially larger plans, efficient compilation schemes possible (see Section 6).
8. result demonstrates choice semantics important. interpret conditional effects
sequentially Brewka Hertzberg (1993) do, exists straightforward compilation scheme preserving
plan size exactly.

294

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

5.2 Non-Uniform Complexity Classes
next section make use so-called non-uniform complexity classes, defined
using advice-taking machines, order prove impossibility compilation scheme.
advice-taking Turing machine Turing machine advice oracle, (not necessarily recursive) function positive integers bit strings. input , machine loads
bit string i00 "00 continues usual. Note oracle derives bit string
length input contents input. advice said polynomial
oracle string polynomially bounded instance size. Further, complexity class defined terms resource-bounded machines, e.g., P NP, J]pBnm (also called non-uniform
X) class problems decided machines resource bounds
polynomial advice.
advice oracle, class P/poly appears much powerful P. HowY es]pBnm
ever, seems unlikely P/poly contains NP. fact, one prove fJe
implies certain relationships uniform complexity classes believed unlikely. stating result, first introduce polynomial hierarchy.
Let X class decision problems. e+ denotes class decision problems
decided polynomial time deterministic Turing machine allowed use
procedurea so-called oraclefor deciding problem , whereby executing procedure
cost constant time. Similarly, fJe denotes class decision problems

polynomial time using
nondeterministic Turing-machine solves
instances



defined follows:
oracle ~p . Based notions, sets , ,












)

V )

V )

)
V









V

V

V



)
)eff
e


fJe
ygn fJe

Thus, )gfhe

)ygnfJe . set classes defined way called polynomial
hierarchy, denoted PH. Note

F)
V

e^







V


)
V


V

)
V






V



"A

e sekD

have,


V . classes, unknown whether
V
V
V
V
V
inclusions classes proper. However, strongly believed case,
i.e., hierarchy truly infinite.
Based firm belief polynomial hierarchy proper, mentioned question
eE]pBnm answered. shown fJe es]pBnm would imply

whether fJe

polynomial hierarchy collapses second level (Karp & Lipton, 1982), i.e., )
yg nfhes] pB.nThis,

however, considered quite unlikely. Further, shown fJe

ygnfJe fJ es ]pBnm implies polynomial hierarchy collapses third level (Yap, 1983),
i.e.,
) , considered unlikely. use result proving

pairs formalisms unlikely one formalism compiled
one.
9. super-script used distinguish sets analogous sets Kleene hierarchy.

295

fiN EBEL

5.3 Expressive Power Partial State Specifications Boolean Formulae
cases considered far, operators partial state specifications could compiled
operators complete state specifications, i.e., partial state specifications add expressiveness. longer true, however, allow arbitrary boolean formulae
preconditions effect conditions. case, decide coNP-complete problem
whether formula tautology deciding whether one-step plan exists. Asking, example,
Q -instance N$fft+]Nff KPe6Bffefft+\v6>P plan equivalent asking whether tautology.
Let one-step plan existence problem (1-PLANEX) PLANEX problem restricted
plans size one. evident %QB -1-PLANEX %Q -1-PLANEX
coNP-hard. Let - fixed polynomial, polynomial step plan-existence problem
(- -PLANEX) PLANEX problem restricted plans length bounded - ,
size planning instance. easy see, problem NP formalisms except
%QB %Q . reason guessing sequence operators state specifications
polynomial size, one verify step polynomial time precondition satisfied
current state specification produces next state specification. Since
polynomially many steps, overall verification takes polynomial time.
Proposition 13 -- -PLANEX solved polynomial time nondeterministic Turing machine formalisms different %s %Q .
fact % -1-PLANEX coNP-hard and, e.g., %s -p-PLANEX NP, follows
almost immediately polynomial-time compilation scheme Q ]
ygnfJe ). However, even allow unbounded
preserves plan length polynomially (if fhe)
computational resources compilation process, proof technique first used Kautz Sel
).
man (1992) used show compilation scheme cannot exist (provided )



Theorem 14

%Q

cannot compiled %] preserving plan size polynomially, unless



)



.

Proof. Let propositional formula size conjunctive normal form three literals per
clause. first step, construct % domain structure * size polynomial
following properties. Unsatisfiability arbitrary 3CNF formula size equivalent
-step plan existence % - -PLANEX instance N8`ffi1 fft+\`6>P , 1 computed
polynomial time .
Given set atoms, denoted , define set clauses set containing
clauses three literals built using atoms. size | , i.e.,
polynomial . Let ? set new atoms -E . corresponding one-to-one clauses
. Further, let
B

)@9 F F F M- . (0\+ F F F 6M
construct % domain structure 8)~N$fivfftKP formulae size follows:


&




)

)

<?<=+\v6Bff
+]N +> v6Bfft+\v6>Pe6BA


296

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

Let function determines 3CNF formulae , atoms ? correspond
clauses formula , i.e.,

*()+.- . 0\+ F F F 63(6BA
Now, initial state particular formula size computed follows:
)h *H<1 ?M~*.H<=+>^v6BA
1
construction, follows exists one-step plan N$&`fft`ffi1"fft+\v6>P


iff





unsatisfiable.
Let us assume exists compilation scheme %Q %] preserving plan
size polynomially. Further, let us assume % domain structure 8 compiled %]
domain structure * )N$fi fft P . Using compiled domain structure, construct
following advice-taking Turing machine.
input formula size , load advice N8 ffe $&`fftffe>]$&`fft.P .
advice polynomial 8 polynomial size compilation scheme generates
polynomially larger domain structures. polynomial-time function 1
computed polynomial time, compute

)
.$ ffi % <9>b$ fft
polynomial time. goal specification

) $ fft+\v6><9 $ fft
computed polynomial time. Finally, decide - -PLANEX problem resulting
%] -instance N ffi fft P . Proposition 13 know done polynomial time

nondeterministic Turing machine.
deciding - -PLANEX N ffi fft P equivalent deciding -PLANEX
N84ffi1"fft+\v6>P , turn equivalent deciding unsatisfiability , follows
decide coNP-complete problem nondeterministic, polynomial advice-taking Turing machine
fhe5]pBnm . Using Yap's (1983) result,
polynomial time. follows ygnfJe
claim follows.
Using Proposition 4 Proposition 5, result generalizes follows (see Table 1).

Corollary 15 %Qs % cannot

compiled planning formalisms preserving

.
plan size polynomially, unless )





restrict form formulae, however, may able devise compilation schemes
%Q to, e.g., % . Reconsidering proof last theorem, turns essential
use negation CNF formula precondition. restrict CNF formulae
preconditions, seems possible move partial complete state descriptions using ideas
similar ones used proof Lemma 7.
However, compilation scheme work %s . reason condition
$Dff post LB.) $Dff post LB. definition function . condition satisfied, result operator inconsistent. condition could easily employed reduce
unsatisfiability CNF formulae 1-step plan existence, enables us use technique proof theorem.
297

fiN EBEL

5.4 Circuit Complexity
next impossibility result need notions boolean circuits families circuits.
boolean circuit directed, acyclic graph )'*ff , nodes called gates.
gate 2
type K!,2K+>fiff fiff
&ff:ffi6<F+1 ffgAgAgA26 . gates K!,2K

+sffiff ffgAgAgA26 in-degree zero, gates K!,2K+>6 in-degree one,
gates K!,2K+>
fiff 6 in-degree two. gates except one least one outgoing
edge. gate outgoing edge called output gate. gates incoming edges
called input gates. depth circuit length longest path input gate
output gate. size circuit number gates circuit.
Given value assignment variables +1
output gate obvious way. example,
gate circuit shown Figure 4.

ffgAgAgA6 , circuit computes value
)~ ) get value 1 output











Figure 4: Example boolean circuit

Instead using circuits computing boolean functions, use accepting

words length +\ff:>6 . word )H AgAgA4+\ff:>6 interpreted value

assignment input variables ffgAgAgA:ff4 circuit. word accepted iff output gate

value 1 word. order deal words different length, need one circuit
possible length. family circuits infinite sequence )O' ff( ffgAgAgAw ,

input variables. language accepted family circuits theI set words
8 accepts .
Usually, one considers so-called uniform families circuits, i.e., circuits generated
Turing machine Pk( -space bound. Sometimes, however, non-uniform families
interesting. example, class languages accepted non-uniform families polynomiallysized circuits class P/poly introduced Section 5.2.
Using restrictions size depth circuits, define new complexity
classes, uniform variants subsets P. One class important
following class languages accepted uniform families circuits polynomial size
logarithmic depth, named NC . Another class proves important us defined
terms non-standard circuits, namely circuits gates unbounded fan-in. Instead
restricting in-degree gate two maximum, allow unbounded in-degree.
class languages accepted families polynomially sized circuits unbounded fan-in
constant depth called ACI .
298

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS



definition, follows almost immediately AC
NC . Moreover,
shown languages NC non-uniform variant ACI ,
implies AC ) NC (Furst, Saxe, & Sipser, 1984).
5.5 Boolean Formulae Cannot Compiled Conditional Effects
seen Section 5.3, Boolean formulae quite expressive used combination partial state specifications. However, state specifications complete?
case, seems possible simulate evaluation CNF formulae using conditional
effects. fact, possible compile polynomial-time, example, % preserving plan

size linearly, provided formulae conjunctive normal form. operator would
split two operators, one evaluates clauses formulae original operator
one combines evaluations takes appropriate actions, e.g., asserting
precondition satisfied. Sequencing pairs operators achieved introducing
extra literals.
say general case, however? trying simulate evaluation
arbitrary logical formula using conditional effects, seems case need many
operators nesting depth formula, means would need plans cannot
bounded linearly longer original plans.
use results sketched Section 5.4 separate % . order so, let us

view domain structures fixed size plans machines accept languages. words
consisting bits, let

8)ON$fi<=+\`6BfftvPA
Assume atoms numbered 1 . word

consisting bits could

encoded set literals

,
) +.- 0

th bit

6fi<=+>4- 0 th bit K6BA

Conversely, consistent state specification , let word th bit 1 iff
- /D .
say -bit word accepted one-step -step plan 8 iff
exists one-step -step plan, respectively, instance

)~N.N$fi<=\+ v6BfftKPffi <=+>^ v6Bfft\+ `6>PA
Similarly families circuits, define families domain structures, ) ffe ffgAgAgA .


language accepted family one-step (or -step) plan set words accepted
using domain structure 8 words length . Borrowing notion uniformity well,
say family domain structures uniform generated Pk -space Turing
machine.
Papadimitriou pointed languages accepted uniform polynomially-sized
boolean expressions identical NC (Papadimitriou, 1994, p. 386). easy see, family % domain structures nothing family boolean expressions, provided use
one-step plans acceptance.
Proposition 16 class languages accepted uniform families % domain structures using
one-step plan acceptance identical NC .
299

fiN EBEL

closer look power -step plan acceptance families

domain structures is, turns less powerful NC . order show that, first
prove following lemma relates -step plans circuits gates unbounded fan-in.





Lemma 17 Let F)~N$fftP domain structure, let
, let -step plan

. exists polynomially sized boolean circuit unbounded fan-in depth >;fiT
plan N&ffifft5P iff circuit value 1 input .
Proof. general structure circuit -step



.
.
.



plan displayed Figure 5.







1

1

.....



.
.
.

.
.
.



.
.
.

1









1

.
.
.

.....



. . .





Figure 5: Circuit structure goal testing -step



plan

7

plan step (or level) 8 atom - , connection - . connections level
input gates, i.e., - ) . goal test performed
-gate checks goals
true level , case )+.- ff4- ff- 6 . Further, using -gate, checked

inconsistency generated executing plan.
plan step 8 , must computed whether precondition satisfied
result conditional effects are. Figure 6 (a) displays precondition test precondition
+.- ff- ff4- 6 . conjunction precondition literals true, V becomes true,
connected -gate Figure 5.
Without loss generality (using polynomial transformation), assume conditional
VGF . Whether effect F activated level 8 computed circuit
effects form
V 4- .
displayed Figure 6 (b), shows circuit +.- ff4- 6

Finally, activated effects combined circuit shown Figure 6 (c). atoms - ,
check whether - 4- activated, would set true. one
inputs -gate Figure 5. neither - 4- activated, value -
level 8N determined value - level 8 . Otherwise value - level 8
7
determined value -W , i.e., activation value positive effect - level 8 .
depths circuits Figure 6 (b) (c) dominate depth circuit necessary
represent one plan step leading conclusion plan step represented using circuit
depth 7. Adding depth goal testing circuit, claim follows.
lemma implies -step plan acceptance indeed less powerful % 1-step plan

acceptance, means compilation scheme % preserving plan size linearly

impossible.
300

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS









1z










...
















(

(



(a)









z

(b)



z

(



(c)

Figure 6: Circuit structure precondition testing (a), conditional effects (b), computation
effects (c) operators



Theorem 18



, members







-class.

Proof. show %1 , Theorem 9 Proposition 4 claim follows.

Assume contradiction . Let ) ffe ffgAgAgA uniform family



domain structures `)8 ffe8 ffgAgAgAw domain structures generated compilation



scheme preserves plan size linearly. Lemma 17 know domain

structure )~N$ fft P given goal generate polynomially sized, unbounded fanin circuit depth >T tests whether particular -step plan achieves goal. order
decide -step plan existence, must test |i0 0 ie different plans, polynomial size
8 compilation scheme. plan, generate one test circuit,
adding another -gate decide -step plan existence using circuit depth >W size
polynomial size 8 . Further, since state-translation functions modular, results
fixed computed using additional level gates. Since Proposition 16
languages NC accepted uniform families % domain structures using one-step plan
acceptance, assumption % implies accept language NC (possibly

non-uniform) ACI circuits, impossible result Furst colleagues (1984).
Using Propositions 4 5 again, generalize theorem follows.
Corollary 19

]





cannot compiled



B







preserving plan size linearly.

6. Compilability Preserving Plan Size Polynomially
shown previous section, compilation schemes induced Propositions 4
5 ones identified Section 4 allow compilation schemes preserving plan size exactly. pairs formalisms able rule compilation schemeseven
301

fiN EBEL

allow linear growth resulting plans. Nevertheless, might still chance
compilation schemes preserving plan size polynomially. shown %Qs %Q cannot
compiled formalisms even plan grow polynomially, may still able
find compilation schemes preserving plan size polynomially %Qs /% pair
remaining formalisms.
preview results section given Figure 7. seen, able

`{>

>

>



{

B

>










Figure 7: Equivalence classes planning formalisms created polynomial-time compilation
schemes preserving plan size polynomially. Compilation schemes constructed
section indicated dashed lines

establish compilation schemes preserving plan size polynomially pairs formalisms
proved impossibility compilation schemes.
6.1 Compiling Conditional Effects Away Partial State Specifications
first compilation scheme develop one Qs Q . before, assume
conditional effects singleton effect sets. Further, since use arbitrary boolean
formulae effect conditions Qs , assume one rule effect literal.
Using simple polynomial transformation, arbitrary sets operators brought form.
$Dff post LB. considerably,
simplifies checking condition $Dff post LB.)
one rule activate particular literal.
302

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

order simulate parallel behavior conditional effects, break
individual operators executed sequentially. means conditional effect
operator introduce two new operators. One simulates successful application rule,
one simulates blocking situation rule. least one operators must
executed conditional effect original operator. something force
additional literals added control execution operators. leads
sequence operators length bounded number conditional effects original
operator.
want simulate parallel behavior sequence unconditional operators, effects
unconditional operators directly influence state description, effect
deferred operators corresponding set conditional effects
executed. reason, use sequence copying operators copy activated
effects state description conditional operators executed. copying
operators used check set activated effects consistent.
Theorem 20

Qs

compiled

Q

polynomial time preserving plan size polynomially.

Proof. Assume ) N$fftP %QB source domain structure assume further, without
loss generality (using polynomial transformation), operators form

L )~N pre L fft+{ VXF ffgAgAgA\ffe : VGF :fiz6>Pff
F
F
F
73 , 7 , 7) X
) .
V
Let 3 disjoint copies , used record active effects conditional
another disjoint copy, used record active effect
effects, let
l
copied yet. Further, let
J),+.-4*0zLW?6 new set atoms corresponding one-to-one
6
operators let set symbols corresponding one-to-one conditional effects
, i.e.,
6
V F 7 & post L>@ffiL{81?6BA
),+14 7 0 7 X
Finally, let fresh atom appearing <= </ 3 </
<= signals copying
l
active effects state specification progress. set symbols compiled
domain structure

)F<9 <5
3

<5
l

<9m<

6

</+\\6BA

operator L , compilation scheme introduces number new operators.
first operator introduce one checks whether conditional effects previous
operators executed, copying progress precondition satisfied.
case, execution conditional effects operator started:

L pre
)~N pre L{$H<5


6

<=+>8{6Bff(+.- b 6&<3(7?<5(43<5

<3(
l

PA

operator enables conditional effect operators. activated effects, introduce
following operators:

Lk 7 ~
) N +.-4b4
5 7Q6Bff*+1 7>6&</+.- ffl

303

0z-?) F 7>67<=+.- 3 l

0:4-) F 76>PA

fiN EBEL

words, effect condition entailed, activated positive negative effect well
fact rule tried recorded.
Since one effect literal conditional effect, conditional effect
blocked negation effect condition entailed state specification.
blocked conditional effects introduce following operators:

L 7 ~
) N +.- b
5( 7 6Bff(+1` 7 6>PA

order check conditional effects tried (activating corresponding effect
activating conditional effect blocked), following operator used:

L
) N +.-4bb6fi<=+1 7

6

0 7 VGF 7\

post L

e6Bff(+\{6&<=+>"-4bb6>PA

operator enables copying activated effects state specification, achieved
following set operators atom -3/ :


L

L
L



)
3


)

)

N +\>ff- ff4- 3 ff- l B6 fft+.-ff"- l >6 Pff
N +\>ff4-"ff-53(ff- l B6 fft+>4-ff4- l >6 Pff
N +\>ff- ff- 3 ff- l 6Bff
PA

Finally, need operator checks possible effects copied. operator
starts execution cycle enabling execution another precondition operator:

Li ~
) N +\{67<3(
l

ff8+>*\6>PA

Using definitions, specify set compiled operators:

pre

)+\L ffiL 0L 1?6&< VHF
+\L 7 0L ?ff\ 7 VXF 7\fi post L e67<
+\L 7 0L 19ff\ 7
7\& post L e6&<
+\L ffiL 3 ffiL 0 -3W6fi<
+\LAit6BA
Based that, specify compilation scheme )ON>{ffe>zffe zff P follows:
>> ) N$ fft P
6
>b ) (7?<5(
3<9 l <3( <5 </+>8{6Bff
>s ) (m
<3+>*\6Bff
$ffi\ )
zs$fft9) =A
scheme obviously satisfies conditions (2) (3)
compilation schemes
functions computed polynomial time. Further, Q -instance -instance.
Let legal %s state specification let ) $DffiL operator
clear D0) , exists sequence
L>X . discussion,
7 L 7 followed
pre
operators consisting L , followed operators form L


operator L , followed turn operators L , followed finally operator L ,
);!t]$D5<9 ffe ffF
304

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

Conversely, D8%0 ) , exist plan transforms

$D5<9>bffiL pre

legal state specification contains 8 4-4b .
Using
induction plan length, follows arguments exists plan
iff exists plan every plan 00 @00v00 300
<= , <
maximum number conditional effects operators . Hence
polynomial-time compilation scheme preserving plan size polynomially.
immediate consequence theorem %s %Q form equivalence class
respect compilability preserving plan size polynomially.
Corollary 21
polynomially.

%Qs



%

polynomial-time compilable preserving plan size

Further, know Corollary 15 class cannot become larger.
case compiling , however, result depends semantics chosen


executing conditional effects partial state specifications. use alternative semantics resulting state specification legal application state-transformation
functions leads theory represented set literals, seems likely exists
another scheme preserves plan size polynomially. However, use alternative semantics


deletes literals ; $Dff post LB.(I$Dff post LB. $Dff post LB consistent,
appears unlikely able identify compilation scheme preserves plan
size polynomially.
6.2 Compiling Conditional Effects Away Complete State Specifications
next compilation scheme compiles %] % . Since deal complete state


$D8ff post LB. ,
specification, take care condition M$D8ff post LB.M)
always true complete states. makes compilation scheme somewhat simpler. Since
allow general boolean formulae, scheme becomes little bit difficult.
general, however, compilation scheme specify similar one given
proof Theorem 20.
Theorem 22 %] compiled
serving plan size polynomially.

%





compiled



polynomial time pre-

Proof. proof Theorem 20, assume ) N$fftP (%]
domain structure. Further, assume operators form

V F :b6>Pff
L )~N pre L fft+ U VXF ffgAgAgA\ff U : X
F
U %] structure U 7
7M 7




) source

structure. means
assume effects unique conditional effect.
addition, assume set symbols compiled domain structure proof
Theorem 20:

)F<9 <5

3

<5

305

l

<9m<

6

</+\\6BA

fiN EBEL



pre
operator L , introduce operators L , L , L
Theorem 20.
addition, following operators needed:


Lk 7 )
L 7e : )

,L


3

,L




N +.-4bb6&< U 7>ff*+1 7Q6fi<=+.- - l 0@-?) F 76&<=+.- 3 N +.-4bb6&</+>* 7e :0t 7e : U 76Bff*+1 7>6>PA

, L

l



proof

0:4-) F 76>Pff


compiled set operators contains operators compilation scheme

identical scheme presented proof Theorem 20. means significant
difference compilation scheme presented proof Theorem 20 operator scheme
L 7e : tests rule whether contains effect condition blocks rule. Since
complete state specifications, every conditional effect either activated blocked,
7 's used record execution conditional effect tried.
Using similar arguments proof Theorem 20, follows compilation
scheme indeed scheme leads claim made theorem.


follows equivalent respect formalisms


equivalent respect . two sets could merged one equivalence class,

provided able prove that, e.g., % compiled .



6.3 Compiling Boolean Formulae Away
Section 5.5 showed impossible compile boolean formulae conditional effects
plans allowed grow linearly. However, sketched already idea compilation
scheme preserves plan size polynomially. show compile boolean
formulae , expressively equivalent basic STRIPS, i.e., compile boolean

formulae away completely.
Theorem 23

%

polynomial-time compilable



preserving plan size polynomially.

Proof. Assume F)ON$fftP domain structure. assume without loss generality
= (i.e.,
operators L 1 form L )ON ffi P ,
one formula precondition instead set formulae).
Let two new sets atoms corresponding one-to-one sub-formulae occurring preconditions operators . new atoms denoted [\ [>
sub-formula . Atoms form [{ used record truth-value sub-formula
computed atoms form [\ used store computed truth-value.
operator L )~N ffi P , target operator set following operator:

L )ON +\[Q.ffi[ B 6Bffi <5( PA
set operators generated way denoted .
Further, atom -3/ , introduce following two operators:

L
L



3

)

)

N +.-6Bff*+\[ ffi[ 6>Pff
N +>"-H6Bff*+\[ ff8[ 6>PA

set operators generated way denoted
306



.

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

sub-formula occurring preconditions
operators introduced:

L

L )
L 3 )
sub-formulae J)



L
L
L 3

form )


p

following

N +\[ ffi[ ffi[\ ffi[\ B6 fft+\[ ffi[\6>Pff
N +\[ ff*[\ 6Bfft+\[ ff8\[ H6>Pff
N +\[ *[\ 6Bfft+\[ ff8\[ H6>PA
)

3



, following operators introduced:
) N +\[ ffi\[ 6Bfft+\[ ffi\[ 6>Pff
) N +\[ ffi\[ 6Bfft+\[ ffi\[ 6>Pff
) N +\[ ffi[ ff8\[ ff81[ 6Bfft+\[ ff*\[ H6>PA

Finally, J)^ , following operators:

L
L



3

)

)

N +\[ 8[ 6Bfft+\[ iff [\6>Pff
N +\[ iff [ 6Bfft+\[ ff8\[ 6>PA

set operators generated sub-formulae denoted
specify compilation scheme :

>)
)
>B)
$ffi\)
s$fft9)



.

$N <9m9<5 ff8 </ </U*Pff



/A

construction obvious functions polynomial-time computable,

induced function reduction,

state-translation functions modular,
every plan source planning instance exists plan 00 @00
00 300 ,<^\ , < maximum number sub-formulae preconditions .
that, claim follows.
might question whether compiling boolean formulae away could done
efficiently. Using result boolean expressions evaluated circuits logarithmic
depth, indeed possible. However, satisfied result
compilation scheme preserving plan size polynomially all. result together Theorem 22 settles question compilation schemes preserving plan size polynomially pairs
formalisms.
Corollary 24 formalisms

preserving plan size polynomially.





307

%]

polynomial-time compilable

fiN EBEL

6.4 Parallel Execution Models Feasibility Compilation Schemes Preserving Plan
Size Polynomially
compilation schemes preserve plan size exactly linearly seem immediate use,
polynomial growth plan appears little practical interest. Considering practical
experience planning algorithms roughly characterized property many
steps plan without getting caught combinatorial explosion fact
number significantly smaller 100, polynomial growth seem make much sense.
take GRAPHPLAN (Blum & Furst, 1997) consideration againthe planning system
motivated investigation first placeit turns system allows parallel
execution actions. Although parallel execution might seem add power planning
system considerably, affect results all. sequential plan solve planning
instance steps, parallel plan need least actions. Nevertheless, although size
plan (measured number operations) might same, number time steps may
considerably smallerwhich might allow efficient generation plan.
look compilation scheme compiles conditional effects away, seems case
large number generated actions could executed parallelin particular actions
simulate conditional effects.
However, semantics parallel execution GRAPHPLAN quite restrictive. one action
adds deletes atom second action adds deletes one action deletes atom
second action precondition, two actions cannot executed parallel
GRAPHPLAN . restriction, seems impossible compile conditional effects away
preserving number time steps plan. However, compilation scheme preserves
number time steps linearly seems possible. Instead compilation scheme,
approaches far either used exponential translation (Gazen & Knoblock, 1997) modified
GRAPHPLAN -algorithm order handle conditional effects (Anderson et al., 1998; Koehler et al.,
1997; Kambhampati et al., 1997). modifications involve changes semantics parallel
execution well changes search procedure. implementations compared
straightforward translation Gazen Knoblock (1997) used, would interesting
compare compilation scheme based ideas spelled Theorem 22
base line.

7. Summary Discussion
Motivated recent approaches extend GRAPHPLAN algorithm (Blum & Furst, 1997)
deal expressive planning formalisms (Anderson et al., 1998; Gazen & Knoblock, 1997;
Kambhampati et al., 1997; Koehler et al., 1997), asked term expressive power could
mean context. One reasonable intuition seems term expressive power refers
concisely domain structures corresponding plans expressed. Based
intuition inspired recent approaches area knowledge compilation (Gogic et al., 1995;
Cadoli et al., 1996; Cadoli & Donini, 1997), introduced notion compilability order
measure relative expressiveness planning formalisms. basic idea compilation
scheme transform domain structure, i.e., symbol set operators,
initial state goal specification transformedmodulo small changes necessary
technical reasons. Further, distinguish compilation schemes according whether plan
target formalism size (up additive constant), size bounded linearly
308

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

size plan source formalism, size bounded polynomially original planning
instance original plan.
Although compilability framework appears straightforward intuitive tool
measuring expressiveness planning formalisms, possible come alternative
measures. Backstrom (1995), instance, proposed use ESP-reductions, polynomial
many-one reductions planning problems preserve plan size exactly. However, requiring
transformation polynomial-time computable seems overly restrictive.
particular, want prove one formalism expressive another one, better
proven exists compilation scheme regardless much computational resources
compilation process may need. Furthermore, appear severe technical problems
using Backstrom's (1995) framework proving negative results. hand,
positive results reported Backstrom achievable compilation framework
transformations used fact compilation schemes. Taking together, appears
case compilation framework superior intuitive technical point view.
Another approach judging expressiveness planning formalisms proposed
Erol colleagues (1994, 1996). measure expressiveness planning formalisms according set plans planning instance have. approach contrasts hierarchical task
network planning nicely STRIPS-planning, help us making distinctions
formalisms -family.
compilability framework mainly theoretical tool measure concisely domain
structures plans expressed. However, appears good measure
difficult planning becomes new language feature added. Polynomial-time compilation
schemes preserve plan size linearly indicate easy integrate feature
compiled away. One either use compilation scheme mimic compilation scheme
extending planning algorithm. polynomial-time compilation scheme leading
polynomial growth plan possible, indication adding new feature
requires probably significant extension planning algorithm. even compilation
scheme preserving plan size polynomially ruled out, probably serious
problem integrating new feature.
Using framework, analyzed large family planning formalisms ranging basic
STRIPS formalisms conditional effects, boolean formulae, incomplete state specifications. surprising result analysis able come complete
classification. pair formalisms, either able construct polynomial-time
compilation scheme required size bound resulting plans could prove compilation schemes impossibleeven computational resources compilation process
unbounded.
particular, showed formalisms considered paper:






incomplete state specifications literals preconditions compiled basic STRIPS
preserving plan size exactly,
incomplete state specifications literals preconditions effect conditions compiled away preserving plan size exactly, already conditional effects,
compilation schemes preserving plan size linearly except implied
specialization relationship described above.
309

fiN EBEL

allow polynomial growth plans target formalism, formalisms
containing incomplete state specifications boolean formulae compilable other. Incomplete state specifications together boolean formulae, however, seem add significantly
expressiveness planning formalism, since cannot compiled away even
allowing polynomial growth plan unbounded resources compilation process.
noted, however, results hold use semantics
conditional effects partial state specifications spelled Section 2.1. semantics,
may get slightly different results concerning compilability conditional effects partial
states.
One question one may ask happens consider formalisms boolean formulae
syntactically restricted. indicated various places paper, restricted formulae,
CNF DNF formulae, sometimes easily compiled away. However,
cases impossible. example, shown CNF formulae cannot compiled
basic STRIPS preserving plan size linearly (Nebel, 1999), confirms Backstrom's (1995)
conjecture CNF-formulae preconditions add expressive power basic STRIPS.
Another question reasonable restrictions compilation scheme are. particular,
one may want know whether non-modular state-translation functions could lead powerful
compilation schemes. First all, requiring state-translation functions modular seems
quite weak considering fact compilation scheme concerned
domain structure initial state goal specification transformed
all. Secondly, considering fact state-translation functions depend operator
set, complicated functions seem useless. technical point view, need
modularity order prove conditional effects boolean formulae cannot compiled away
preserving plan size linearly. conditional effects, modularity similar condition seems
crucial. case boolean formulae, could weaken condition point
require state-translation functions computable circuits constant depthor
something similar. case, additional freedom one gets non-modular state-translation
functions seem help functions take operators
account. Nevertheless, seems interesting theoretical problem prove powerful
state-translation functions add power compilation schemes.
Although paper mainly theoretical, inspired recent approaches extend
GRAPHPLAN algorithm handle powerful planning formalisms containing conditional
effects. So, answers give open problems field planning algorithm
design? First all, Gazen Knoblock's (1997) approach compiling conditional effects away
optimal want allow plan growth constant factor. Secondly,
approaches (Anderson et al., 1998; Kambhampati et al., 1997; Koehler et al., 1997)
modify GRAPHPLAN algorithm using strategy similar polynomial-time compilation
scheme preserving plan size polynomially. reason, approaches compared
pure compilation approach using ideas compilation scheme developed
proof Theorem 22 base line. Thirdly, allowing unrestricted boolean formulae adds
level expressivity cannot compiled away linear growth plan
size. fact, approaches one Anderson colleagues (1998) simply expand
formulae DNF accepting exponential blow-up. Again, cannot better plan
size preserved linearly. Fourthly, want add partial state specifications top
general boolean formulae, would amount increase expressivity much larger
310

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

adding conditional effects general formulae basic STRIPS, case way
compile away even allow polynomial plan growth.
Finally, one may wonder results apply planning approaches based translating (bounded) planning problems propositional logic SATPLAN (Kautz & Selman, 1996)
BLACKBOX (Kautz & Selman, 1998). Since entire analysis relative expressiveness
planning formalisms uses assumption compile one planning formalism another
planning formalism, results tell us anything size representations switch
another formalism. particular, seems possible find encoding (bounded) planning
problems conditional operators propositional logic concise encoding
unconditional operators. advice results give concise encoding
found first translating conditional actions unconditional actions using standard encoding unconditional actions (Kautz, McAllester, & Selman, 1996) generate boolean
formulae. However, addressing problem determining conciseness representation
context appears interesting relevant topic future research.

Acknowledgments
research reported paper started partly carried author enjoyed
visitor AI department University New South Wales. Many thanks go Norman
Foo, Maurice Pagnucco, Abhaya Nayak rest AI department discussions
cappuccinos. would thank Birgitt Jenner Jacobo Toran clarifications
concerning circuit complexity.

Appendix A: Symbol Index
Symbol

Explanation
cardinality set
size instance
symbol used conditional effects

syntactic specialization relation

compilability relation restriction

boolean constant denoting falsity, denoting

illegal state specification

273 boolean constant denoting truth

295 advice function
Lff\Ll
275, 275
active effects operator state state specification
AC
298 complexity class

298 boolean circuit
298 family boolean circuits

coNP
272 complexity class
coNP/poly 295 non-uniform coNP
closing set literals w.r.t.
$&%;(Ll 284

277 plan, i.e., sequence operators
295 complexity class polynomial hierarchy


295 instance problem

0L0
V 00 L]00

Page
292
277
274
279
282
273

311

fiN EBEL





>\ffe ffe>
U


F ffeff


;ff b

E\GHLl
NC
"!@#%
NP
NP/poly

L




- ffi[ff0ff24ff
L\

P
P/poly
PH

277
282
282
282
277
274
273
287
273
273
274
298
273
272
295
274
276
277
274
275

272
295
295
273
>Ll
PLANEX
279
post
274
pre
274

PSPACE
272

277
295

276
Lff\Ll
;!t]Lff\Ll 277
C
274

274

278
278

%
278
278
`

278
;
278
283



283

'(
273

273

initial state description
compilation scheme ( )~N>{ffe ffe>Qff ffz>P )
transformation induced compilation scheme
components compilation scheme
goal planning task
set boolean formulae
boolean formulae
literal
sets literals
boolean formulae use atoms
set models theory
complexity class
negative literals set literals
complexity class
non-uniform NP
operator ( )~N pre post P )
set operators
set finite sequences operators
propositional atoms
potentially active effects operator
given state specification
complexity class
non-uniform P
polynomial hierarchy
positive literals set literals
plan existence problem
postconditions operator
preconditions operator
complexity class
planning instance ( )ON&ffifft9P )
complexity class polynomial hierarchy
maps state specification operator new state
extension Lff\Ll plans
state (or truth assignment)
state specification
STRIPS planning formalism
STRIPS literals preconditions
STRIPS boolean formulae preconditions
STRIPS incomplete state descriptions
STRIPS conditional effects
STRIPS combinations extensions
equivalence classes induced
equivalence classes induced
propositional atoms used set literals
countably infinite set propositional atoms
312

fiC OMPILABILITY







r


ffz



X

,




273
273
295
282
292
298
295
272
277
299



E XPRESSIVE P OWER P LANNING F ORMALISMS

finite subset
set literals overs
complexity class polynomial hierarchy
state-translation functions compilation scheme
universal literals
word +\ff:>6t
complexity class
planning formalisms
domain structure ( )ON$fftP )
family domain structures

References
Anderson, C. R., Smith, D. E., & Weld, D. S. (1998). Conditional effects Graphplan. Proceedings 4th International Conference Artificial Intelligence Planning Systems (AIPS98), pp. 4453. AAAI Press, Menlo Park.
Baader, F. (1990). formal definition expressive power knowledge representation languages.
Proceedings 9th European Conference Artificial Intelligence (ECAI-90) Stockholm, Sweden. Pitman.
Backstrom, C. (1995). Expressive equivalence planning formalisms. Artificial Intelligence, 76(1
2), 1734.
Backstrom, C., & Nebel, B. (1995). Complexity results SAS planning. Computational Intelligence, 11(4), 625655.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90(1-2), 279298.
Brewka, G., & Hertzberg, J. (1993). things worlds: formalizing actions
plans.. Journal Logic Computation, 3(5), 517532.
Bylander, T. (1994). computational complexity propositional STRIPS planning. Artificial
Intelligence, 69(12), 165204.
Cadoli, M., & Donini, F. M. (1997). survey knowledge compilation. AI Communications,
10(3,4), 137150.
Cadoli, M., Donini, F. M., Liberatore, P., & Schaerf, M. (1996). Comparing space efficiency
propositional knowledge representation formalism. Aiello, L. C., Doyle, J., & Shapiro,
S. (Eds.), Principles Knowledge Representation Reasoning: Proceedings 5th
International Conference (KR-96), pp. 364373 Cambridge, MA. Morgan Kaufmann.
Erol, K., Hendler, J. A., & Nau, D. S. (1994). HTN planning: Complexity expressivity.
Proceedings 12th National Conference American Association Artificial Intelligence (AAAI-94), pp. 11231129 Seattle, WA. MIT Press.
313

fiN EBEL

Erol, K., Hendler, J. A., & Nau, D. S. (1996). Complexity results hierarchical task-network
planning. Annals Mathematics Artificial Intelligence, 18, 6993.
Fikes, R. E., & Nilsson, N. (1971). STRIPS: new approach application theorem proving
problem solving. Artificial Intelligence, 2, 189208.
Furst, M., Saxe, J. B., & Sipser, M. (1984). Parity, circuits, polynomial-time hierarchy.
Mathematical Systems Theory, 17(1), 1327.
Garey, M. R., & Johnson, D. S. (1979). Computers IntractabilityA Guide Theory
NP-Completeness. Freeman, San Francisco, CA.
Gazen, B. C., & Knoblock, C. (1997). Combining expressiveness UCPOP efficiency
Graphplan. Steel, S., & Alami, R. (Eds.), Recent Advances AI Planning. 4th European
Conference Planning (ECP'97), Vol. 1348 Lecture Notes Artificial Intelligence, pp.
221233 Toulouse, France. Springer-Verlag.
Gogic, G., Kautz, H. A., Papadimitriou, C. H., & Selman, B. (1995). comparative linguistics
knowledge representation. Proceedings 14th International Joint Conference
Artificial Intelligence (IJCAI-95), pp. 862869 Montreal, Canada. Morgan Kaufmann.
Kambhampati, S., Parker, E., & Lambrecht, E. (1997). Understanding extending Graphplan.
Steel, S., & Alami, R. (Eds.), Recent Advances AI Planning. 4th European Conference
Planning (ECP'97), Vol. 1348 Lecture Notes Artificial Intelligence, pp. 260272
Toulouse, France. Springer-Verlag.
Karp, R. M., & Lipton, R. J. (1982).
Mathematique, 28, 191210.

Turing machines take advice.

L' Ensignement

Kautz, H. A., McAllester, D. A., & Selman, B. (1996). Encoding plans propositional logic.
Aiello, L. C., Doyle, J., & Shapiro, S. (Eds.), Principles Knowledge Representation
Reasoning: Proceedings 5th International Conference (KR-96), pp. 374385 Cambridge, MA. Morgan Kaufmann.
Kautz, H. A., & Selman, B. (1992). Forming concepts fast inference.. Proceedings
10th National Conference American Association Artificial Intelligence (AAAI-92),
pp. 786793 San Jose, CA. MIT Press.
Kautz, H. A., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings 13th National Conference American Association Artificial Intelligence (AAAI-96), pp. 11941201. MIT Press.
Kautz, H. A., & Selman, B. (1998). BLACKBOX: new approach application theorem
proving problem solving. Working notes AIPS'98 Workshop Planning
Combinatorial Search Pittsburgh, PA.
Koehler, J., Nebel, B., Hoffmann, J., & Dimopoulos, Y. (1997). Extending planning graphs
ADL subset. Steel, S., & Alami, R. (Eds.), Recent Advances AI Planning. 4th European
Conference Planning (ECP'97), Vol. 1348 Lecture Notes Artificial Intelligence, pp.
273285 Toulouse, France. Springer-Verlag.
314

fiC OMPILABILITY



E XPRESSIVE P OWER P LANNING F ORMALISMS

Lifschitz, V. (1986). semantics STRIPS. Georgeff, M. P., & Lansky, A. (Eds.), Reasoning Actions Plans: Proceedings 1986 Workshop, pp. 19 Timberline, OR.
Morgan Kaufmann.
Nebel, B. (1999). expressive power disjunctive preconditions?. Biundo, S., & Fox,
M. (Eds.), Recent Advances AI Planning. 5th European Conference Planning (ECP'99)
Durham, UK. Springer-Verlag. appear.
Papadimitriou, C. H. (1994). Computational Complexity. Addison-Wesley, Reading, MA.
Pednault, E. P. (1989). ADL: Exploring middle ground STRIPS situation
calculus. Brachman, R., Levesque, H. J., & Reiter, R. (Eds.), Principles Knowledge
Representation Reasoning: Proceedings 1st International Conference (KR-89),
pp. 324331 Toronto, ON. Morgan Kaufmann.
Yap, C. K. (1983). consequences non-uniform conditions uniform classes. Theoretical
Computer Science, 26, 287300.

315


