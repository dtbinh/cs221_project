journal artificial intelligence

submitted published

graph dynamic csp
exploiting ebl ddb csp search techniques graphplan
subbarao kambhampati

rao asu edu

department computer science engineering
arizona state university tempe az

abstract
reviews connections graphplans graph dynamic
constraint satisfaction motivates need adapting csp search techniques
graphplan describes explanation learning dependency directed backtracking dynamic variable ordering forward checking sticky values random restart search
strategies adapted graphplan empirical provided demonstrate
augmentations improve graphplans performance significantly x speedups several
benchmark special attention paid explanation learning dependency
directed backtracking techniques empirically found useful improving
performance graphplan

introduction
graphplan blum furst currently one efficient solving classical four five competing systems recent aips competition graphplan mcdermott extending efficiency
graphplan thus seems worth activity kambhampati parker
lambrecht provided reconstruction graphplan explicate links
previous work classical constraint satisfaction one specific link discussed
connection process searching graphplans graph solving dynamic constraint satisfaction dcsp mittal falkenhainer seen dcsp
perspective standard backward search proposed blum furst lacks variety ingredients thought make efficient csp search mechanisms frost dechter
bayardo schrag include forward checking dynamic variable ordering dependency directed backtracking explanation learning tsang kambhampati
kambhampati et al suggested would beneficial study impact
extensions effectiveness graphplans backward search
describe experiences adding variety csp search techniques improve graphplan backward searchincluding explanation learning ebl dependencydirected backtracking capabilities ddb dynamic variable ordering forward checking sticky
values random restart search strategies addition ebl ddb capabilities
turned empirically useful ebl ddb explaining failures
leaf nodes search tree propagating explanations upwards search
tree kambhampati ddb involves propagation failure explanations support
intelligent backtracking ebl involves storing interior node failure explanations pruning
future search nodes graphplan use weak form failure driven learning calls mem

c ai access foundation morgan kaufmann publishers rights reserved

fik ambhampati

oization shall see graphplans brand learning quite limited
explicit analysis reasons failure instead explanation failure search node
taken constraints search node explained kambhampati
eliminates opportunities dependency directed backtracking adversely effects
utility stored memos
adding full fledged ebl ddb capabilities effect gives graphplan ability
intelligent backtracking ability learn generalized memos likely
applicable situations technically involves generalizing conflict directed backjumping
prosser specialized version ebl ddb strategy applicable binary csp
work context dynamic constraint satisfaction discussed kambhampati empirically ebl ddb capabilities improve graphplans search efficiency quite
dramaticallygiving rise x speedups allowing graphplan easily solve several
hither hard unsolvable particular report experiments
bench mark described kautz selman well domains
used recent aips competition mcdermott
discuss utility issues involved storing memos point graphplan
memoization strategy seen conservative form csp good learning
conservative strategy keeps storage retrieval costs goods usual bane good
learning strategiesunder control loses learning opportunities present use
sticky values way recouping losses empirical studies sticky
values lead x improvement ebl
addition ebl ddb investigated utility forward checking dynamic
variable ordering isolation concert ebl ddb empirical studies
capabilities typically lead additional x speedup ebl ddb
competitive ebl ddb
finally consider utility ebl ddb strategies context random restart search
strategies gomes selman kautz recently shown good solving hard combinatorial including ebl ddb
strategies retain advantages even context random restart strategies specifically
ebl ddb strategies enable graphplan use backtrack limits effectivelyallowing
achieve higher solvability rates optimal plans significantly smaller backtrack
restart limits
organized follows next section provide background viewing
graphplans backward search dynamic constraint satisfaction review
opportunities view presents section discuss inefficiencies backtracking
learning methods used normal graphplan motivate need ebl ddb capabilities
section describes ebl ddb added graphplan section presents empirical studies
demonstrating usefulness augmentations section investigates utility forward
checking dynamic variable ordering strategies graphplan section investigates utility
ebl ddb strategies context random restart search section discusses related work
section presents conclusions directions work
binary csp initial constraints pairs variables



fip lanning g raph

action list
level k

proposition list
level k

action list
level k

proposition list
level k

g g p p
domains g fa g g fa gg fa gg fa g
p fa gp fa gp fa gp fa g
p fa gp fa g
constraints normal p p
p p
p p
constraints activity g activefp p p g
g activefp g
g activefp g
g activefp p g
init state activefg g g g g

p




x



p





g
g

p
p



g

p



x

csp

variables



x





g

p


graph

b dcsp

figure graph dcsp corresponding

review graphplan connections dcsp
review graphplan
graphplan blum furst seen disjunctive version forward
state space planners kambhampati et al kambhampati consists two interleaved
phases forward phase data structure called graph incrementally extended
backward phase graph searched extract valid plan planninggraph consists two alternating structures called proposition lists action lists figure shows
partial graph structure start initial state zeroth level proposition list
given k level graph extension structure level k involves introducing
actions whose preconditions present k th level proposition list addition actions
given domain model consider set dummy persist actions one condition
k th level proposition list persist c action c precondition c effect
actions introduced proposition list level k constructed union
effects introduced actions graph maintains dependency links
actions level k preconditions level k proposition list effects level k
proposition list graph construction involves computation propagation
mutex constraints propagation starts level actions statically interfering
e preconditions effects inconsistent labeled mutex mutexes
propagated level forward two simple rules two propositions level k
marked mutex actions level k support one proposition mutex actions
support second proposition two actions level k mutex statically interfering
one propositions preconditions supporting first action mutually exclusive
one propositions supporting second action
search phase k level graph involves checking see sub graph
graph corresponds valid solution involves starting
propositions corresponding goals level k goals present
present pair marked mutually exclusive search abandoned right away
grap grown another level goal propositions select action


fik ambhampati

g g p p
g fa g g fa gg fa gg fa g
p fa gp fa gp fa gp fa g
p fa gp fa g
constraints normal p p
p p
p p
constraints activity g activefp p p g
g activefp g
g activefp g
g activefp p g
init state activefg g g g g

g g p p
g fa g g fa gg fa gg fa g
p fa gp fa gp fa gp fa g
p fa gp fa g
constraints normal p p
p p
p p
constraints activity g p p p
g p
g p
g p p
init state g g g g

variables

variables

domains

domains

dcsp

b csp

figure compiling dcsp standard csp
level k action list supports two actions selected supporting two
different goals mutually exclusive backtrack try change selection
actions point recursively call search process k level graph
preconditions actions selected level k goals k level search
search succeeds reach level corresponding initial state
consider partial graph shown figure graphplan may generated
search solution g g top level goals want satisfy
actions support goals graph specific actionprecondition dependencies shown straight line connections actions
left level support conditions p p graph notice conditions p
p level k supported two actions x marked connections
actions denote action pairs mutually exclusive notice
given mutually exclusive relations alone graphplan cannot derive mutual exclusion
relations proposition level p p
connections graphplan csp
graphplan described bears little resemblance previous classical
kambhampati et al explicate number important links
graphplan previous work constraint satisfaction communities
specifically graph length k thought first approximation
disjunctive unioned version k level search tree generated forward state space refinement
action lists corresponding union actions appearing k th level proposition
lists corresponding union states appearing k th level mutex constraints
seen providing partial information subsets proposition list actually
correspond legal states corresponding forward state space search process searching
graph extract valid plan seen dynamic constraint satisfaction
since last link relevant work described review

dynamic constraint satisfaction dcsp mittal falkenhainer generalization constraint satisfaction tsang specified set variables


fip lanning g raph



csp

activity flags variables domains variables constraints legal variablevalue combinations dcsp initially subset variables active objective
assignments active variables consistent constraints among variables addition dcsp specification contains set activity constraints activity
constraint form variable x takes value vx variables z w become
active
correspondence graph dcsp clear specifically propositions levels correspond dcsp variables actions supporting correspond variable domains three types constraints action mutex
constraints fact proposition mutex constraints subgoal activation constraints
since actions modeled values rather variables action mutex constraints
modeled indirectly constraints propositions two actions marked mutex
graph every pair propositions p p
one possible supporting actions p one possible supporting actions
p constraint

p p
fact mutex constraints modeled constraints prohibit simultaneous activation
two facts specifically two propositions p p marked mutex graph
constraint

active p active p

subgoal activation constraints implicitly specified action preconditions supporting
active proposition p action makes propositions previous level corresponding
preconditions active
finally propositions corresponding goals active beginning figure shows dynamic constraint satisfaction corresponding example
graph discussed
olving



dcsp

two ways solving dcsp first direct mittal falkenhainer
involves starting initially active variables finding satisfying assignment
assignment may activate variables newly activated variables
assigned second epoch process continues reach epoch
variables activated implies success unable give satisfying assignment
activated variables given epoch latter case backtrack previous epoch
try alternative satisfying assignment variables backtracking
assignment possible backward search process used graphplan blum
furst seen solving dcsp corresponding graph direct
fashion
second solving dcsp first compile standard csp use
standard csp compilation process quite straightforward illustrated
note literal appearing different levels corresponds different dcsp variables thus strictly speaking literal p proposition list level converted dcsp variable pi keep matters simple
example figure contains syntactically different literals different levels graph



fik ambhampati

figure main idea introduce null value denoted domains
dcsp variables model inactive dcsp variable csp variable
takes value constraint particular variable p active modeled p thus
activity constraint form

g activefp p p g
compiled standard csp constraint

g p p p
worth noting activation constraints concerned ensuring
propositions preconditions selected action take non values thus allow
possibility propositions become active take non values even though
strictly supporting preconditions selected action although lead inoptimal
plans mutex constraints ensure unsound plans produced kautz selman
avoid unnecessary activation variables need add constraints effect
unless one actions needing variable precondition selected value
variable earlier higher level variable must value constraints
typically going high arity wind mentioning large number variables
previous level may thus harder handle search
finally mutex constraint two propositions

active p active p
compiled

p p

since action mutex constraints already standard csp form compilation
activity constraints converted standard constraints thus entire csp
standard csp solved standard csp search techniques tsang
direct method advantage closely mirrors graphplans graph
structure backward search possible implement
plan graph structure without explicitly representing constraints furthermore discuss section distinct advantages adopting dcsp view implementing
ebl ddb graphplan compilation csp requires plan graph first converted
extensional csp however allow use standard well supports nondirectional search one follow epoch epoch assigning
variables since main aim illustrate utility csp search techniques context
graphplan adopt direct solution method dcsp study
tradeoffs offered technique compiling graph csp reader referred
kambhampati
possible compile csp propositional satisfiability e csp
boolean variables accomplished compiling every csp variable p domain fv v vn g
n boolean variables form p v p vn every constraint form p
vj compiled
p vj essentially done blackbox system kautz selman
compilation csp strict requirement non directional search zimmerman kambhampati
describe technique allows backward search graphplan non directional see discussion
section





fip lanning g raph



csp

interpreting mutex propagation csp view
viewing graph constraint satisfaction helps put mutex propagation
clearer perspective see kambhampati et al specifically way graphplan constructs graph winds enforcing partial directed consistency partial directed
consistency tsang partial consistency ensured graph building procedure
introduces action level l actions preconditions present proposition
list level l mutually exclusive partial consistency ensured mutual
exclusion propagation procedure
particular graphplan graph construction implicitly derives good constraints form

active pmi pmi

simply removed put level mutex
case pm
constraints form




active pmi active pni

pmi pni



p marked mutually exclusive
case pm
n
procedures directed use reachability analysis enforcing consistency partial enforce full consistency full consistency
lack full consistency verified fact appearance goal level k
necessarily mean goal actually achievable level k e solution csp
assigns non value goal level similarly lack full consistency verified fact appearance pair goals level k imply plan
achieving goals level
another somewhat less obvious way consistency enforcement used
graphplan partial conservative concentrates whether single goal variable
pair goal variables simultaneously non values active solution may
goal non value non values feasible similarly may
pair goals achievable necessarily achievable every possible pair actions
respective domains
interpretation mutex propagation procedure graphplan brings fore several possible
extensions worth considering graphplan
explore utility directional consistency enforcement procedures solely
reachability analysis kambhampati et al argue extending analysis
relevance information et al provide empirical analysis effectiveness
consistency enforcement relevance information
explore utility enforcing higher level consistency pointed kambhampati
et al kambhampati memoization strategies seen failure driven
procedures incrementally enforce partial higher level consistency
normally csp literature good seen compound assignment part feasible
pni correspond conjunction nogoods
solution view mutex constraints form pm


pni
form pm au pn av au av values domains pm











fik ambhampati

consider relaxing focus non values alone allow derivation goods
form

pmi au pni av

guaranteed winning idea number derived goods increase
quite dramatically particular assuming l levels graph
average goals per level average actions supporting goal maximum
number graphplan style pair wise mutexes l size goods
type discussed l consider similar issue context
graphplan memoization strategy section

inefficiencies graphplans backward search
motivate need ebl ddb shall first review details graphplans backward
search pinpoint inefficiencies shall base discussion example
graph figure reproduced convenience figure assuming g g
top level goals interested solving start level k select
actions support goals g g keep matters simple shall assume search
assigns conditions variables level top bottom e g first g
choice actions values support condition
consider top actions first since one choice conditions level
none actions mutually exclusive select actions
supporting conditions level k make sure preconditions
satisfied level k thus subgoal conditions p p level
k recursively start action selection select action p p
two supporting actions convention select first p
choice get selecting support p choice suppose
select first choice infeasible mutually exclusive
already chosen backtrack choose mutually exclusive
previously selected action stymied choices p
backtrack undo choices previous conditions graphplan uses chronological
backtracking whereby first tries see p assigned p
notice first indication inefficiency failure assign p nothing
assignment p yet chronological backtracking try assign p vain hope
averting failure lead large amount wasted effort case p
indeed choices
turns p choices backtrack p another
choice try continue search forward value p hit impasse p
since value p mutex point backtrack p continue
backtracking p p remaining choices backtrack
p need go back level k try assign goals level done
graphplan search makes memo signifying fact failed satisfy goals
p p level hope search ever subgoals set goals
future scuttle right away help remembered memo second
indication inefficiency remembering subgoals p p even though see
lies trying assign p p p p simultaneously nothing


fip lanning g raph

action list
level k

proposition list
level k



csp

action list
level k

proposition list
level k


p


x



x



p


p

g


p


g

p



x

g

g

p




figure running example used illustrate ebl ddb graphplan
subgoals remember fp p p p g memo fp p g
remembered memo would general would much better chance useful
future
memo stored backtracking continues level k chronological
fashion trying reassign g g g g order see third indication inefficiency caused chronological backtracking g really role failure encountered
assigning p p since spawns condition p level k yet backtracking
scheme graphplan considers reassigning g somewhat subtle point reassigning
g going avert failure although g requires p one conditions taking
part failure p required g unless g gets reassigned considering
assignments g going avert failure
example continue backtracking g g since alternative supports finally memoize fg g g g g level point backward search
fails graphplan extends graph another level initiating backward
search extended graph

improving backward search ebl ddb
describe graphplans backward search augmented full fledged ebl
ddb capabilities eliminate inefficiencies pointed previous section informally
ebl ddb strategies involve explanation failures leaf nodes regression propagation
leaf node failure explanations compute interior node failure explanations along lines described kambhampati specific extensions propose backward search



fik ambhampati

essentially seen adapting conflict directed backjumping strategy prosser generalizing work dynamic constraint satisfaction
shown pseudo code form figure contains two mutually recursive
procedures plan assign goals former called level
graph calls assign goals assign values required conditions
level assign goals picks condition selects value recursively calls
remaining conditions invoked empty set conditions assigned calls
plan initiate search next previous level
order illustrate ebl ddb capabilities added lets retrace previous example
pick point assign p level k assigned p p
p try assign value p violate mutex constraint
explanation failure search node set constraints false derived
complete explanation failure thus stated

p p p p
part p p stripped explanation since mutual
exclusion relation hold long solving particular particular
actions take cue conflict directed backjumping prosser
represent remaining explanation compactly terms conflict sets specifically
whenever search reaches condition c assignment conflict
set initialized fcg whenever one possible assignments c inconsistent mutually
exclusive current assignment previous variable c add c conflict set c
current example start fp g conflict set p expand adding p
cannot assigned p choice support p informally
conflict set representation seen incrementally maintained partial explanation
failure indicating conflict current value p one possible
values p kambhampati
consider second possible value p viz mutually exclusive
currently supporting p following practice add p conflict set
p point choices p backtrack p passing
conflict set p viz fp p p g reason failure essence conflict set
shorthand notation following complete failure explanation kambhampati


p p p p p p p p

worth noting point p revisited future different assignments
preceding variables conflict set initialized fp g considering assignments
first advantage conflict set allows transparent way supporting dependency directed backtracking kambhampati current example failed assign
p start backtracking need chronological fashion however
strip first disjunctive clause since present graph structure next two implicative clauses
since part mutual exclusion relations change conflict set representation keeps condition variable names last two clauses denoting essence current
assignments variables p p causing failure assign p



fip lanning g raph



csp

plan g goals pg plan graph k level
k return empty subplan p success
memo g
fail return conflict set
call assign goals g pg k
assign goals fails returns conflict set
store memo
regress actions selected level k get r
fail return r conflict set
assign goals succeeds returns k level subplan p
return p success
assign goals g goals pg plan graph k level actions
g
let u union preconditions actions
call plan u pg k
plan fails returns conflict set r
fail return r
plan succeeds returns subplan p length k
succeed return k length subplan p
else g
select goal g g
let cs
fgg ag set actions level k pg support g
l
ag fail return cs conflict set
ag
else pick action ag set ag
mutually exclusive action b
let l goal b selected support
cs flg
set cs
goto l
else mutually exclusive action
call assign goals g fg g pg k fag
call fails returns conflict set c
g c
set cs cs c conflict set absorption
goto l
else g c
fail return c conflict set
dependency directed backjumping

figure pseudo code description graphplan backward search enhanced ebl ddb capabilities backward search level k graph pg initiated call
plan g pg k g set top level goals


fik ambhampati

instead jump back recent variable condition taking part conflict set p
case p avoiding considering alternatives p thus avoiding
one inefficiencies standard backward search easy see backjumping
sound since p causing failure p thus assigning wont avert failure
continuing along whenever search backtracks condition c backtrack conflict
absorbed current conflict set c example absorb fp p p g conflict
set p currently fp g making fp p p g conflict set p assign
remaining value p next try assign p value
mutex thus set conflict set p fp p g backtrack conflict
set backtracking reaches p conflict set absorbed current conflict set
p described earlier giving rise fp p p p g current combined failure reason
p step illustrates conflict set condition incrementally expanded collect
reasons failure possible values condition
point p choices backtrack p current conflict set
fp p p p g p first absorb conflict set fp p p p g p current conflict
set initiate backtracking since p choices
reached end current level k backtracking p must
involve undoing assignments conditions k th level however
two steps memoization regression
memoization
backtrack first assigned variable given level store conflict set
variable memo level store conflict set fp p p p g p memo
level notice memo store shorter thus general one stored
normal graphplan include p p anything
failure
regression
backtrack level k level k need convert conflict set first
assigned variable level k refers conditions level k conversion
process involves regressing conflict set actions selected k th level kambhampati
essence regression step computes smallest set conditions variables
kth level whose supporting actions spawned activated dcsp terms conditions variables
conflict set level k current case conflict set fp p p p g
see p p required condition g level k condition p required
condition g
case condition p g g responsible supporting
actions needed p cases two heuristics computing regression prefer
choices help conflict set regress smaller set conditions still choice
multiple conditions level k pick one assigned earlier motivation first rule keep failure explanations compact thus general possible
current example memo includes conditions p farthest gone
level even necessary verify p would memo set
one supporters p



fip lanning g raph



csp

motivation second rule support deeper dependency directed backtracking
important note heuristics aimed improving performance ebl ddb
affect soundness completeness
current example first rules applies since p already required g
requiring p p even case e g required p still would
selected g g regression p since g assigned earlier search
regressing fp p p p g actions k th level thus fg g g start
backtracking level k conflict set jump back g right away since
recent variable named conflict set avoids inefficiency considering
choices g g done normal backward search g backtrack conflict set
absorbed backtracking continues since choices procedure
repeated g point end leveland memoize fg g g
memo level k since levels backtrack graphplan called
extend graph one level
notice memos ebl analysis capture failures may require significant
amount search rediscover example able discover fg g g failing
goal set despite fact mutex relations choices goals g
g
memos
end section couple observations regarding use stored memos
standard graphplan memos level stored level specific hash table whenever
backward search reaches level k set conditions satisfied consults hash table
see exact set conditions stored memo search terminated exact hit
occurs since ebl analysis allows us store compact memos likely complete goal
set level k going exactly match stored memo likely stored
memo subset goal set level k sufficient declare goal set failure
words memo checking routine graphplan needs modified checks
see subset current goal set stored memo naive way
involves enumerating subsets current goal set checking
hash table turns costly one needs efficient data structures setenumeration trees rymon indeed koehler co workers koehler nebel hoffman
dimopoulos developed data structure called ub trees storing memos
ub tree structures seen specialized version set enumeration trees
efficiently check subset current goal set stored memo
second observation regarding memos often serve failure explanation
suppose level k goal set level subsumes
stored memo use failure explanation level regress
back previous level process provide us valuable opportunities
back jumping levels k allows us learn compact memos levels note
none would possible normal memos stored graphplan
way memo declare goal set level k failing memo exactly equal goal
set case regression get us goals level k buy us
backjumping learning power kambhampati



fik ambhampati

empirical evaluation effectiveness ebl ddb
seen way ebl ddb capabilities added backward search maintaining updating conflict sets noted ebl ddb capabilities avoid variety
inefficiencies standard graphplan backward search augmentations soundness completeness preserving follows corresponding properties conflict directed
backjumping kambhampati remaining million dollar question whether capabilities make difference practice present set empirical answer
question
implemented ebl ddb described previous section top graphplan
implementation lisp changes needed code add ebl ddb capability relatively minor two functions needed non trivial changes added ub tree subset
memo checking code described koehler et al ran several comparative experiments
benchmark kautz selman well four domains
specific domains included blocks world rocket world logistics domain gripper domain ferry
domain traveling salesperson domain towers hanoi domains including
blocks world logistics domain gripper domain used recent ai
systems competition specifications well domains publicly available
table shows statistics times taken number backtracks made normal graphplan graphplan ebl ddb capabilities
run time improvement
first thing note ebl ddb techniques offer quite dramatic speedups x
blocks world way x logistics domain att log unsolvable
normal graphplan hours cpu time note number backtracks
reduces significantly consistently ebl ddb given lengh runs time
lisp spends garbage collection becomes important issue thus report cumulative time
including cpu time garbage collection time graphplan ebl ddb separate
cpu time cumulative time plain graphplan cases total time spent
large enough garbage collection time significant fraction specifically two
entrys column corresponding total time normal graphplan first entry
cpu time spent second entry parenthesis cumulative time cpu time garbage
collection time spent speedup computed respect cumulative time graphplan
ebl ddb cpu time plain graphplan reported speedups thus seen
conservative estimates
original lisp implementation graphplan done mark peot implementation subsequently
improved david smith
assign goals plan
earlier versions including presented ijcai kambhampati reported
experiments sun sparc ultra running allegro common lisp linux machine run time statistics
seem approximately x faster sparc machine
interesting note percentage time spent garbage collection highly dependent
example case att log minutes hours cumulative time spent
garbage collection case tower hours hours cumulative
time spent garbage collection



fiproblem

speedup
x
x
x
x
x
x
x
x
x
x
x
x
x
x
x

table empirical performance ebl ddb unless otherwise noted times cpu minutes pentium iii mhz machine
meg ra running linux allegro common lisp compiled speed tt total time mt time used checking
memos btks number backtracks done search times graphplan ebl ddb include cpu
garbage collection time cpu time separated total time case normal graphplan numbers
parentheses next names list number time steps number actions respectively solution avln
avfm denote average memo length average number failures detected per stored memo respectively

csp

avfm













normal graphplan
tt mt
btks avln

k


k

k


k

hr hr



k



hr hr
k

hr hr


k


k

hr hr
k

hr hr


p lanning g raph



huge fact
bw large b
rocket ext
rocket ext b
att log
gripper
gripper
gripper
tower
tower
ferry
ferry
ferry
tsp
tsp

graphplan ebl ddb
tt
mt
btks avln avfm

k



k



k




k




k


k




k


k


k



k



k




k



k



k


k



fik ambhampati

reduction memo length
highlight fact speedups offered ebl ddb domain
dependent quite meager blocks world quite dramatic many
domains including rocket world logistics ferry gripper tsp hanoi domains statistics
memos shown table shed light reasons variation particular interest
average length stored memos given columns labeled avln general
expect ebl analysis reduces length stored memos conditions part
failure explanation stored memo however advantage depends
likelihood small subset goals given level actually taking part failure
likelihood turn depends amount inter dependencies goals given
level table note average length reduces quite dramatically rocket world
logistics reduction much less pronounced blocks world variation
traced back larger degree inter dependency goals given level blocks
world
reduction average memo length correlated perfectly speedups offered ebl
corresponding let put perspective fact average length
memos rocket ext ebl without
ebl shows essence

normal graphplan discovering sized failure embedded
possible ways worst
case sized goal set storing memo time incurring increased backtracking
matching costs thus wonder normal graphplan performs badly compared
graphplan ebl ddb
utility stored memos
statistics table increased utility memos stored graphplan
ebl ddb since ebl ddb store general smaller memos normal graphplan
theory generate fewer memos use often columns labeled avfm
give ratio number failures discovered use memos number memos
generated first place seen measure average utility stored
memos note utility consistently higher ebl ddb example rocketext b see average ebl ddb generated memo used discover failures
times number memos generated normal graphplan
relative utility ebl vs ddb
statistics table see even though ebl make significant improvements
run time significant fraction run time ebl well normal graphplan spent
memo checking raises possibility overall savings mostly ddb part
ebl part e part involving storing checking memos fact net drain
kambhampati katukam qu see true ran ebl e
memo checking disabled ddb capability well standard graphplan memoization
case att log took memo statistics interrupting search hours
statistics att log aseem suggest memo usage bad normal graphplan however
noted att log solved normal graphplan begin improved usage factor may due
mostly fact search went considerably longer time giving graphplan opportunity use
memos



fip lanning g raph


att log
tower
rocket ext
gripper
tsp
huge fct

ebl ddb
btks
time
k
k
k

k
k

k



csp

ddb
btks
time
k
k

k

k

k

k


speedup
x
x
x
x
x
x

table utility storing ebl memos ddb
strategies left shown table demonstrate ability store
smaller memos afforded ebl quite helpfulgiving rise x speedup ddb alone
att log x speedup tower course
ddb important capability indeed att log aand tower could even solved
standard graphplan ddb become solvable summary
ebl ddb net positive utility
utility memoization
another minor well recognized point brought statistics table
memo checking sometimes significant fraction run time standard graphplan
example case rocket ext standard graphplan takes minutes minutes
half time spent memo checking hash tables raises possibility
disable memoization perhaps well version ebl ddb
see case ran memoization disabled
general disabling memo checking leads worsened performance came across
cases disablement reduces overall run time run time still much higher
get ebl ddb example case rocket ext disable memo
checking completely graphplan takes minutes lower minutes taken
standard graphplan still much higher minutes taken version graphplan
ebl ddb capabilities added add ddb capability still disabling memochecking run time becomes minutes still times higher afforded
ebl capability
c vs lisp question
given existing implementations graphplan done c many optimizations
one nagging doubt whether dramatic speedups due ebl ddb somehow dependent
moderately optimized lisp implementation used experiments thankfully
ebl ddb techniques described implemented maria fox
derek long stan system stan highly optimized implementation graphplan
fared well recent aips competition found ebl ddb resulted
similar dramatic speedups system fox fox long example
considered removing memoization completely even poorer



fik ambhampati

unable solve att log plain graphplan could solve easily ebl ddb
added
finally worth pointing even ebl ddb capabilities unable solve
larger benchmarks bw large c att log b however
indictment ebl ddb since knowledge planners solved
used local search strategies gsat randomized start strategies
used additional domain specific knowledge pre processing least
aware existing implementations graphplan solve

utility graphplan memos
one important issue ebl managing costs storage matching indeed discussed kambhampati naive implementations ebl ddb known lose gains
made pruning power matching storage costs consequently several techniques
invented reduce costs selective learning well selective forgetting
interesting see costs prominent issue ebl ddb graphplan
think mostly two characteristics graphplan memoization strategy
graphplans memoization strategy provides compact representation goods
well selective strategy remembering goods seen dcsp remembers
subsets activated variables satisfying assignment seen csp c f
figure graphplan remembers goods form

p p pmi
superscripts correspond level graph proposition
belongs normal ebl implementations learn goods form

p p j pmk
suppose graph contains n propositions divided l levels proposition
p level j actions supporting csp compilation graph
n variables values extra one normal ebl implementation
csp learn worst case n goods contrast graphplan
n
remembers l l memos dramatic reduction reduction two
factors
individual memo stored graphplan corresponds exponentially large set
normal goods memo

p p pmi
shorthand notation conjunction dm goods corresponding possible

non assignments p pm

variable v may present good present one
possibilities n variables
level nl propositions occurs memo occur





possible assignmentsgiving

fip lanning g raph



csp

b memos subsume goods made proposition variables graph level
matching cost reduced fact considerably fewer goods ever
learned fact graphplan stores goods memos separately level
consults memos stored level j backwards search level j
discussion throws light called ebl utility
critical graphplan ebl done normal csps
scenarios memoization conservative avoid rediscovery
failures
discussion raises possibility graphplan even ebl ddb memoization
conservative may losing useful learning opportunities
required syntactic form specifically graphplan learn memo form

p p pmi
must case dm possible assignments propositional variables must
good even one good graphplan avoids learning memo thus
potentially repeating failing searches later time although loss made extent
learning several memos lower level
p
consider example following scenario set variables p pm
n
level assigned backward search suppose search found legal partial asi domain p contains k values fv vk g
signment variables p pm



trying assign variables pm pni suppose repeatedly fail backtrack variable
pmi assigning eventually settling value v point backtracking
higher level variables p p assigning
occurs time backtrack pm


point would useful remember goods effect none
going work backtracking repeated
first values pm
goods take form

pmi vj pmi pmi pni
tried found lead failure
j ranges values pm

assigning later variables unfortunately goods syntactic form memos
memoization procedure cannot remember search thus forced rediscover
failures
sticky values partial antidote
one way staying standard memoization avoiding rediscovery failing search
paths case example use sticky values heuristic frost
dechter kambhampati involves remembering current value variable
skipping ddb trying value first search comes back
variable heuristic motivated fact skip variable ddb
means variable current assignment contributed failure caused


fik ambhampati

backtrackingso makes sense restore value upon visit example
backtracked tries
heuristic remember v current value pm
first value visited variation technique arrange fold
domain variable values precede current value sent back
domain values tried previously untried values found
fail makes assumption values led failure likely
becomes fv v vk v v v g
example heuristic folds domain pm
notice heuristics make sense employ ddb otherwise never
skip variable backtracking
implemented sticky value heuristics top ebl ddb graphplan statistics
table experiments extension seen sticky values
able give x additional speedup ebl ddb depending
folding heuristic dominates simple version terms number backtracks
difference quite small terms run time

forward checking dynamic variable ordering
ddb ebl considered look back techniques analyze failures looking
back past variables may played part failures different class
techniques known look forward techniques improving search prominent among
latter forward checking dynamic variable ordering supporting forward checking involves
filtering conflicting actions domains remaining goals soon particular
goal assigned example figure forward checking filter domain p
soon p assigned dynamic variable ordering dvo involves selecting assignment
goal least number remaining establishers dvo combined forward checking variables ordered according live domain sizes live domain
comprised values domain yet pruned forward checking experiments techniques bring reasonable albeit non dramatic improvements
graphplans performance table shows statistics benchmark dynamic variable ordering alone forward checking dynamic variable ordering note
backtracks reduce x case dynamic variable ordering x
case dynamic variable ordering forward checking speedups time somewhat smaller
ranging x x times perhaps improved efficient implementation forward checking seem suggest amount optimization
going make dynamic variable ordering forward checking competitive ebl ddb
one thing several including att log tsp ferry etc
could solved even forward checking dynamic variable ordering second
even could solved reduction backtracks provided ebl ddb far
greater provided fc dvo strategies example tsp fc dvo strategies
experimented variation heuristic known brelaz heuristic gomes et al
ties among variables sized live domains broken picking variables take part
number constraints variation however lead appreciable improvement performance
study forward checking dynamic variable ordering initiated dan weld
current implementation physically removes pruned values variable forward checking phase
restores values backtracks better implementations including use flags values well
use indexed arrays c f bacchus van run





ebl ddb sticky
btks
speedup
k
x x
k
x x
k x x
k x x
k x x
k
x x

ebl ddb sticky fold
time
btks
speedup

k
x x

k
x x
k x x
k x x
k x x

k
x x

table utility sticky values along ebl ddb

csp

time









rocket ext
rocket ext b
gripper
ferry
tsp
att log

plain ebl ddb
time
btks

k

k
k
k
k

k

p lanning g raph



fik ambhampati


huge fact
bw large b
rocket ext
rocket ext b
att log
gripper
tsp
tower

gp
k
k
k
k
hr
k
k
hr

gp dvo
k
k
k
k
hr
k
k
hr

speedup
x x
x x
x x
x x
x x
x x


gp dvo fc
k
k
k
k
hr
k
k
hr

speedup
x x
x
x x
x x
x x
x x

table impact forward checking dynamic variable ordering routines graphplan times
cpu minutes measured mhz pentium iii running linux franz
allegro common lisp numbers parentheses next times number
backtracks speedup columns report two factorsthe first speedup time
second speedup terms number backtracks fc dvo tend
reduce number backtracks reduction seem
time savings

reduce number backtracks k k x improvement however pales
comparison k backtracks x improvement given ebl ddb see entry
table notice say variable ordering strategies make dramatic
difference graphplans backward search dcsp compilation graph
make claims utility fc dvo csp compilation graph
complementing ebl ddb forward checking dynamic variable ordering
although forward checking dynamic variable ordering approaches found particularly effective isolation graphplans backward search thought would interesting
revisit context graphplan enhanced ebl ddb strategies part original reasoning underlying expectation goal variable ordering significant
effect graphplan performance fact failing goal sets stored toto
memos blum furst pp reason longer holds use ebl ddb
exists difference opinion whether forward checking
ddb fruitfully co exist prosser suggest domain filteringsuch
one afforded forward checking degrades intelligent backtracking recent work
frost dechter bayardo schrag however seems suggest however best csp
capabilities
adding plain dvo capability top ebl ddb presents difficulties adding forward
checking require changes figure difficulty arises
failure may occurred combined effect forward checking backtracking
example suppose four variables v v considered assignment
order suppose v domain f g v cannot v cannot v
b suppose v domain contains constraint saying v cant


fip lanning g raph


huge fct
bw large b
rocket ext
rocket ext b
att log
tower
tsp

ebl
time btks
k
k
k
k
k
k
k



csp

ebl dvo
time btks
speedup
k
x x
k
x x
k
x x
k
x x
k x x
k
x x
k x x

ebl fc dvo
time btks
speedup
k
x x
k x x
k
x x
k
x x
k x x
k
x x
k
x x

table effect complementing ebl ddb dynamic variable ordering forward checking
strategies speedup columns report two factorsthe first speedup time
second speedup terms number backtracks fc dvo tend
reduce number backtracks reduction seem
time savings

v v suppose forward checking assigned v v
values b forward checking prunes v domain leaving value
point try assign v fail use figure conflict set v
would fv v v g constraint violated v v v however
sufficient since failure v may occurred forward checking stripped
value domain v handled pushing v v variables
whose assignment stripped values v v conflict set specifically conflict
set every variable v initialized fv g begin whenever v loses value
forward checking respect assignment v v added conflict set v whenever
future variable v conflicts v add conflict set v rather v
conflict set v specifically line
set cs cs f l g
procedure figure replaced line
set cs cs conflict set l
incorporated changes implementation support support forward checking dynamic variable ordering well ebl graphplan table shows performance version experimental test suite seen numbers number
backtracks reduced x case ebl dvo x case
ebl fc dvo cpu time improvements somewhat lower got x speedup
notice possible values stripped v domain may impact
failure assign v example perhaps another constraint says v cant v b
case strictly speaking assignment v cannot really blamed failure v leads
non minimal explanations reason expect strict minimization explanations pre requisite
effectiveness ebl ddb see kambhampati



fik ambhampati

ebl dvo x speedup ebl fc dvo several cases cpu times increase fc dvo attribute overheads forward checking
lesser extent dynamic variable ordering importantly comparing
tables see ebl ddb capabilities able bring significant speedups
even graphplan implementation fc dvo

ebl ddb randomized search
recent years seen increased use randomized search strategies include
purely local search strategies gerevini selman levesque mitchell well
hybrid strategies introduce random restart scheme top systematic search strategy
gomes et al blackbox system kautz selman supports variety
random restart strategies top sat compilation graph empirical
studies strategies probabilistically speaking scale much better purely
systematic search strategies
wanted investigate much ebl ddb techniques help graphplan
even presence newer search strategies ebl ddb techniques little
applicability purely local search strategies could theory help random restart systematic
search strategies random restart strategies motivated attempt exploit heavytail distribution gomes et al solution nodes search trees many
intuitively non trivial percentage easy solutions
well hard solutions makes sense restart search
spending much effort solution restarting way hope probabilistically hit
easier solutions
implemented random restart strategy top graphplan making following simple
modifications backward search
keep track number times backward search backtracks one level
plan graph previous level level closer goal state whenever number
exceeds given limit called backtrack limit search restarted going back last
level plan graph assuming number restarts exceeded given
limit search process two restarts referred epoch
supporting actions values proposition variable considered randomized
order randomization ensures search restarted look
values variable different order
notice random restart strategy still allows application ebl ddb strategies since
given epoch behavior search identical standard backward
search indeed backtrack limit number restarts made larger
larger whole search becomes identical standard backward search
reordering values variable doesnt make whole lot sense blackbox sat encodings
thus boolean variables thus randomization blackbox done order goals
considered assignment typically tends clash built goal ordering strategies dvo
sat z li anbulagan get around conflict breaking ties among variables randomly
avoid clashes decided randomize graphplan reordering values variable picked inter level
backtracks natural parameter characterizing difficulty graphplans backward search



fiproblem

sol














normal graphplan
length
time av mfsl


k k

k k


k k


k k


k k
k k
k k


k k


k k


k k


k k


k k


k k

table effect ebl ddb random restart graphplan time measured cpu minutes allegro common lisp running
linux mhz pentium machine numbers next names number steps actions shortest
plans reported literature r b l parameters second column refer limits number
restarts number backtracks number levels plan graph expanded statistics averaged
multiple runs typically mfsl column gives average number memo failures per searched level
plan graph numbers parentheses total number memo failures averaged runs plan lengths
averaged successful runs

csp

graphplan ebl ddb
length
time av mfsl


k k


k k


k k

k k

k k


k k

k k

k k

k k


k k


k k

k k

k k



sol














p lanning g raph



att log
att log
att log
att log
att log
att log b
att log b
att log b
att log c
att log c
rocket ext
rocket ext
rocket ext

parameters
r b l














fik ambhampati

check intuitions effectiveness ebl ddb randomized search indeed correct conducted empirical investigation comparing performance random search
standard graphplan well graphplan ebl ddb capabilities since search randomized solved multiple number times times cases runtime plan length statistics averaged runs experiments conducted
given backtrack limit given restart limit well limit number levels
graph extended last one needed randomized search solution may
missed first level appears leading prolonged extension graph
inoptimal solution found later level limit number levels expanded
probability finding solution increases time cpu time spent searching
graph increases
implemented random restart search first thing noticed improvement
solvability horizon expected given gomes et al table shows
one important point note table talk average plan
lengths cpu times needed due randomization potentially run produce
different outcome plan secondly graphplan systematic search guarantees shortest
plans measured number steps randomized search guarantee
particular randomized version might consider particular graph barren
solutions simply fact solution could found within confines given
backtrack limit number restarts
graphplan without ebl ddb likely solve larger randomized
search strategies example logistics domain att log solvable
within hours real time ebl systematic search randomization added
implementation able solve att log b att log c quite frequently limits
number restarts backtracks levels increased likelihood finding solution well
average length solution found improves example graphplan ebl ddb able
solve att log b every trial restarts backtracks levels limits although
plans quite inoptimal
next perhaps interesting question wanted investigate whether ebl
ddb continue useful graphplan uses randomized search first blush
seems importantafter even graphplan standard search may
luck able solutions quickly presence randomization thought
however suggests ebl ddb may still able help graphplan specifically
help graphplan given backtrack limit judicious fashion elaborate suppose
random restart search conducted backtracks restarts ebl
ddb graphplan able pinpoint cause failure accurately without ebl
ddb means search backtracks chance backtrack
similar reasons reduced turn gives search chance
catching success one number epochs allowed addition
direct benefit able use stored memos across epochs cut search
seen data table given set limits number restarts number
backtracks number levels expanded graphplan ebl ddb able get higher
percentage solvability well significantly shorter length solutions terms levels
terms actions get comparable standard graphplan significantly
increase input parameters restarts backtracks levels expanded turn led dra

fip lanning g raph



csp

matic increases average run time example att log restarts
backtracks levels limit graphplan able solve time
average plan length steps actions contrast without ebl ddb graphplan
able solve cases average plan length steps
actions double restarts backtracks ebl ddb version goes solvability
average plan length steps actions standard graphplan goes
solvability plan length steps actions increase number levels
standard graphplan solves average plan length steps
actions takes restarts backtracks well level limit standard
graphplan able cross solvability time average run time minutes
average plan length steps actions contrast solvability minutes step action plans provided graphplan ebl restarts
backtracks significant similar observed logistics
att log b att log c domains rocket ext rocket ext b
graphplan ebl ddb able generate reuse memos effectively across different restart epochs specifically numbers columns titled av mfsl
give average number memo failures per search level note cases
average number memo failures significantly higher graphplan ebl
normal graphplan shows ebl ddb analysis helping graphplan reduce wasted effort
significantly thus reap better benefits given backtrack restart limits

related work
original implementation graphplan blum furst experimented variation
memoization strategy called subset memoization strategy keep memo generation
techniques change way memos used declaring failure stored memo
found subset current goal set since complete subset checking costly
experimented partial subset memoization subsets length n n
considered n sized goal set
mentioned earlier koehler co workers koehler et al visited
subset memoization strategy developed effective solution complete subset checking
involves storing memos data structure called ub tree instead hash tables
experiments subset memoization mixed indicating subset memoization seem improve cpu time performance significantly reason quite
easy understand improved memo checking time ub tree data structure
still generating storing old long memos contrast ebl ddb extension
described supports dependency directed backtracking reducing average length
stored memos increases utility significantly thus offering dramatic speedups
verify main source power ebl ddb graphplan ebl ddb part
ub tree memo checking ran experiments ebl ddb turned
notice number search levels may different smaller number graph levels
graphplan initiates search none goals pair wise mutex att log
att log b att log c happens starting level rocket ext happens starting level numbers
parentheses total number memo failures divide number average number levels
search conducted get av mfsl statistic



fik ambhampati


huge fact
bw large b
rocket ext
rocket ext b
att log

tt




hrs

mt






btks
k
k
k
k


ebl x
x
x
x
x
x

gen






fail






avfm






avln






table performance subset memoization ub tree data structure without ebl ddb
tt total cpu time mt time taken checking memos btks
number backtracks eblx amount speedup offered ebl ddb subset
memoization gen lists number memos generated stored fail lists
number memo failures avfm average number failures identified per
generated memo avln average length stored memos

subset memo checking ub tree data structure still enabled shown
table columns labeled avfm expected subset memoization improve
utility stored memos normal graphplan since uses memo scenarios
normal graphplan however note subset memoization
dramatic impact performance graphplan ebl ddb capability significantly
enhance savings offered subset memoization
kambhampati describe general principles underlying ebl ddb techniques
sketch extended dynamic constraint satisfaction development
seen application ideas readers needing background
ebl ddb thus encouraged review related work includes previous attempts applying ebl ddb work ucpop ebl system
kambhampati et al one interesting contrast ease ebl ddb added
graphplan compared ucpop system part difference comes fact
search graphplan ultimately propositional dynamic csp ucpops search
variablized solving search
mentioned section graphplan graph compiled normal csp
representation rather dynamic csp representation used dynamic csp representation corresponds quite directly backward search used graphplan saw
model provides clearer picture mutex propagation memoization strategies helps us
unearth sources strength graphplan memoization strategyincluding fact
memos conservative form good learning obviate need good
management strategies large extent
dynamic csp model may account peculiarities
empirical studies example widely believed csp literature forward checking
dynamic variable ordering critical perhaps even critical ebl ddb
strategies bacchus van run frost dechter however
graphplan uses dynamic csp model search dvo fc largely ineffective
compared ebl ddb standard graphplan extent may due fact



fip lanning g raph



csp

graphplan already primitive form ebl built memoization strategy fact blum
furst argue memoization minimal action set selection action set
considered minimal possible remove action set still support
goals actions selected ordering goals little effect especially
earlier levels contain solution
another reason ineffectiveness dynamic variable ordering heuristic may
differences csp dcsp dcsp main aim
quickly assignment current level variables rather assignment
current level likely activate fewer easier assign variables whose assignment
turn leads fewer easier assign variables general heuristic picking
variable smallest live domain necessarily make sense dcsp since variable
two actions supporting may actually much harder handle another many
actions supporting actions supporting first one eventually lead activation
many harder assign variables may thus worth considering ordering strategies
customized dynamic csp modelse g orderings number
difficulty variables get activated given variable value choice
recently experimented value ordering heuristic picks value assigned variable distance estimates variables activated choice
kambhampati nigenda graph provides variety ways obtaining
distance estimates simplest idea would say distance proposition p level
p enters graph first time distance estimate used
rank variables values variables ranked simply terms distancesthe
variables highest distance chosen first akin fail first principle value ordering
bit trickierfor given variable need pick action whose precondition set lowest
distance distance precondition set computed distance individual
preconditions several ways





maximum distances individual propositions making preconditions
sum distances individual propositions making preconditions
first level set propositions making preconditions present
non mutex

kambhampati nigenda evaluate goal value ordering strategies
ideas lead quite impressive upto orders magnitude
tests speedups solution bearing graphs relate distances computed
graph distance transforms computed planners hsp bonet loerincs
geffner unpop mcdermott idea graph basis
computing heuristic distance metrics investigated context state space search
nguyen kambhampati interesting finding even one
state space instead csp style solution extraction ebl still useful lazy demanddriven discovering n ary mutexes improve informedness heuristic
specifically long kambhampati describe method limited run graphplans backward search armed ebl ddb used pre processing stage explicate memos n ary
mutexes used significantly improve effectiveness heuristic
state search


fik ambhampati

general importance ebl ddb csp sat well recognized indeed
one best systematic solvers propositional satisfiability relsat bayardo
schrag uses ebl ddb forward checking randomized version relsat
one solvers supported blackbox system kautz selman compiles
graph sat encoding ships solvers blackbox thus offers
way indirectly comparing dynamic csp static csp solving
graph discussed section main differences blackbox needs compile
graph extensional sat representation makes harder blackbox
exploit searches previous levels graphplan stored memos
leads memory blowups latter particularly problematic techniques
condensing graphs bi level representation discussed fox long
smith weld effective compile graph sat
flip side blackbox allows non directional search opportunity exploit existing sat
solvers rather develop customized solvers graph present clear
whether approaches dominates informal experiments found
certain att log x easier solve non directional search offered
blackbox others gripper x easier solve graphplan backward
search recent aips competition inconclusive respect
mcdermott
main rationale focusing dynamic csp model graph due
closeness graphplans backward search gelle argues keeping activity constraints
distinct value constraints several advantages terms modularity representation
graphplan advantage becomes apparent activation constraints known
priori posted dynamically search case several extensions
graphplan handle conditional effects kambhampati et al anderson smith
weld koehler et al incomplete initial states weld anderson smith
although ebl ddb strategies try exploit symmetry search space improve
search performance go far enough many cases example gripper domain
real difficulty search gets lost combinatorics deciding hand used
pick ball transfer next rooma decision completely irrelevant
quality solution search failures matter ebl ddb allow graphplan
cut search bit allowing transfer balls one room another
come beyond balls two possible ways scaling first
variablize memos realize certain types failures would occurred irrespective
actual identity hand used variablization called generalization part
ebl methods kambhampati kambhampati et al another way scaling
situations would recognize symmetry inherent abstract
resources search srivastava kambhampati describe type resource
abstraction graphplan

conclusion future work
traced connections graphplan graph csp motivated need exploiting csp techniques improve performance graphplan backward search adapted evaluated several csp search techniques contest graph



fip lanning g raph



csp

plan included ebl ddb forward checking dynamic variable ordering sticky values
random restart search empirical studies ebl ddb particularly useful dramatically speeding graphplans backward search tp x instances speedups
improved x addition forward checking dynamic variable ordering sticky values top ebl ddb showed ebl ddb techniques equally
effective helping graphplan even random restart search strategies used
secondary contribution clear description connections
graphplan graph dynamic constraint satisfaction connections
help us understand unique properties graphplan memoization strategy viewed
csp standpoint see section
several possible ways extending work first would support
use learned memos across specification changes
case replanning blum furst suggest promising future direction
ebl framework described makes extension feasible discussed kambhampati
schiex verfaillie supporting inter usage involves contextualizing
learned goods particular since soundness memos depends initial state
given operators change inter usage
memos supported tagging learned memo specific initial state literals
supported memo memos used corresponding level
long initial state justification holds initial state justification
memos computed incrementally procedure first justifies propagated mutex
relations terms initial state justifies individual memos terms justifications
mutexes memos derived
success ebl ddb approaches graphplan part due high degree redundancy graph structure example propositions actions level l
graph superset propositions actions level l mutexes memos
level l subset mutexes memos level l ebl ddb techniques help
graphplan exploit redundancy avoiding previous failures exploitation redundancy pushed indeed search graphplan graph size l
almost play search graph size l additional
choices zimmerman kambhampati present complementary technique called
explanation guided backward search attempts exploit deja vu property graphplans backward search technique involves keeping track elaborate trace search
level l along failure information termed pilot explanation level l
pilot explanation guide search level l way ebl ddb help process
significantly reduce size pilot explanations need maintained preliminary
technique shows complements ebl ddb provides significant
savings search
acknowledgements
supported part nsf young investigator award nyi iri arpa rome
laboratory initiative grant f c army aasert grant daah afosr grant f nsf grant iri thank maria fox derek
long taking time implement experiment ebl ddb stan system



fik ambhampati

would thank well terry zimmerman biplav srivastava dan weld avrim
blum steve minton comments previous drafts special thanks due
dan weld hosted university washington summer spent time discussing
connections csp graphplan finally thank mark peot david smith
clean lisp implementation graphplan served basis extensions

references
anderson c smith weld conditional effects graphplan proc ai
systems conference
bacchus f van run p dynamic variable ordering csps proc principles
practice constraint programming cp published lecture notes artificial intelligence springer verlag
bayardo r schrag r csp look back techniques solve real world sat instances proc aaai
blum furst fast graph analysis artificial intelligence

bonet b loerincs g geffner h robust fast action selection mechanism
proc aaai
b kambhampati solving graph compiling csp proc th
international conference ai scheduling
b srivastava b kambhampati investigating effect relevance reachability constraints sat encodings proc th international conference
ai scheduling
fox private correspondence
fox long efficient implementation plan graph journal artificial intelligence
frost dechter r search best constraint satisfactions earch proc aaai
gelle e generation locally consistent solution spaces mixed dynamic constraint ph thesis ingenieure informaticienne epfl de nationalite suisse lausanne switzerland
gerevini fast greedy graphs proc aaai
gomes c selman b kautz h boosting combinatorial search randomization
proc aaai pp
kambhampati challenges bridging plan synthesis paradigms proc ijcai



fip lanning g raph



csp

kambhampati relations intelligent backtracking explanation
learning constraint satisfaction artifical intelligence
kambhampati improving graphplans search ebl ddb techniques proc ijcai
kambhampati katukam qu failure driven dynamic search control partial
order planners explanation artificial intelligence
kambhampati nigenda r distance goal ordering heuristics graphplan
proc th international conference ai scheduling
kambhampati parker e lambrecht e understanding extending graphplan
proceedings th european conference url rakaposhi eas asu edu ewspgraphplan ps
kautz h selman b pushing envelope plannng propositional logic stochastic
search proc aaai
kautz h selman b blackbox unifying sat graph proc
ijcai
koehler j nebel b hoffman j dimopoulos extending graphs adl
subset tech rep albert ludwigs university
li c anbulagan heuristics unit propagation satisfiability
proc ijcai
mcdermott


aips

ftp cs yale edu pub mcdermott aipscomp html

competition



mcdermott regression graphs control search aritificial intelligence
mittal falkenhainer b dynamic constraint satisfaction proc aaai
nguyen x kambhampati extracting effective admissible state space heuristics
graph tech rep asu cse tr arizona state university
prosser p domain filtering degrade intelligent backtracking search proc ijcai
rymon r set enumeration trees proc krr
schiex verfaillie g nogood recording static dynamic constraint satisfaction
proc th intl conference tools artificial intelligence
selman b levesque h mitchell gsat method solving hard satisfiability
proc aaai
smith weld temporal mutual exclusion reasoning proc
ijcai


fik ambhampati

srivastava b kambhampati scaling teasing resource scheduling
proc european conference
tsang e foundations constraint satisfaction academic press san diego california
weld anderson c smith extending graphplan handle uncertainty sensing
actions proc aaai
zimmerman kambhampati exploiting symmetry plan graph via
explanation guided search proc aaai




