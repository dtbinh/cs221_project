Journal Artificial Intelligence Research 1 (1994) 277{308

Submitted 3/94; published 6/94

Semantics Complete Algorithm
Subsumption CLASSIC Description Logic
Alex Borgida

borgida@cs.rutgers.edu

Department Computer Science
Rutgers University
New Brunswick, NJ 08904 U. S. A.

Peter F. Patel-Schneider

pfps@research.att.com

AT&T Bell Laboratories
600 Mountain Avenue
Murray Hill, NJ 07974 U. S. A.

Abstract

paper analyzes correctness subsumption algorithm used classic,
description logic-based knowledge representation system used practical
applications. order deal eciently individuals classic descriptions, developers use algorithm incomplete respect standard,
model-theoretic semantics description logics. provide variant semantics descriptions respect current implementation complete,
independently motivated. soundness completeness polynomial-time subsumption algorithm established using description graphs, abstracted version
implementation structures used classic, independent interest.

1. Introduction Description Logics

Data knowledge bases models part natural world. models
often built individual objects inter-related relationships grouped
classes capture commonalities among instances. Description logics (DLs),
known terminological logics, form class languages used build access
models; distinguishing feature classes (usually called concepts) defined
intensionally|in terms descriptions specify properties objects must satisfy
belong concept. descriptions expressed using language allows
construction composite descriptions, including restrictions binary relationships
(usually called roles) connecting objects.
example, consider description
GAME u 4 participants u 8participants:(PERSON u gender : Female):1
description characterizes objects intersection (u) three sub-descriptions:
GAME|objects belong atomic concept; 4 participants|objects least
four fillers participants role; 8participants:(PERSON u gender : Female)|objects
whose participants fillers restricted belong PERSONs,
gender role filled value Female.
1. notation used descriptions standard notation description logic community
(Baader et al., 1991). classic notation used verbose.

c 1994 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBorgida & Patel-Schneider

key difference DLs standard representation formalisms based
First-Order Logic, e.g., relational deductive databases, DLs provide arena
exploring new sets \logical connectives"|the constructors used form composite
descriptions|that different standard connectives conjunction, universal
quantifiers, etc.. Therefore, DLs provide new space search expressive
yet effectively computable representation languages. Moreover, although possible
translate many aspects DLs currently encountered First Order Logic, reasoning
translation would poor substitute DL-based systems reason
way resemble standard theorem proving (e.g., making use imperative
programming features).
Descriptions one used several ways knowledge base
management system (KBMS) based description logic:
1. state queries: KBMS locate objects satisfy description's
properties.
2. define classify concepts: Identifiers attached descriptions, manner views relational DBMSs. system addition automatically determine
\subclass" relationship pairs concepts based definitions.
example, concept defined description would subsumed
concept defined \games least two participants" (GAME u 2 participants).
3. provide partial information objects: important understand distinct DL descriptions ascribed arbitrary individuals (e.g., \today's game
cards|individual Bgm#467|will exactly two participants following
set three : : : , tea rum"). Note unlike database systems, DL-based KBMSs require descriptions predefined. provides
considerable power recording partial knowledge objects.
4. detect errors: possible determine whether two descriptions disjoint,
whether description incoherent not, whether ascribing description
individual leads inconsistency.
Quite number KBMSs based description logics built, including classic
(Resnick et al., 1992), loom (MacGregor & Bates, 1987), back (Peltason et al., 1987).
systems used several practical situations, including software information
bases (Devanbu et al., 1991), financial management (Mays et al., 1987), configuration management (Owsnicki-Klewe, 1988; Wright et al., 1993), data exploration. Additional
signs DLs significant subjects study several recent workshops DLs
(Nebel et al., 1991; Peltason et al., 1991; AAAI, 1992).

1.1 Tractability Completeness DL Implementations

fundamental operation descriptions determining whether one description
general, subsumes, another, sense object satisfying latter would
satisfy conditions former. parallel surge work finding tractable
yet expressive subsets first order logic, DL research community investigating
complexity reasoning various constructors. first result area (Levesque
278

fiSubsumption CLASSIC

& Brachman, 1987) showed even seemingly simple addition small language
lead subsumption determination becoming NP-hard. recent, striking pair
results (Patel-Schneider, 1989b; Schmidt-Schauss, 1989) shows adding ability
represent equalities role compositions makes complexity subsumption problem
leap quadratic undecidable.
three possible responses intractability results:
Provide incomplete implementation DL reasoner, sense
inferences sanctioned standard semantics constructors
performed algorithm. approach, explicitly adopted loom system
implementers (MacGregor & Bates, 1987), advocated users (Doyle &
Patil, 1991), one major diculty: one describe users inferences
actually drawn implementation systems known properties
implemented top KBMS? Two solutions problem suggested: alternative semantic accounts (based weaker, 4-valued logics, example)
(Patel-Schneider, 1989a), proof-theoretic semantics (Borgida, 1992).
Provide complete implementation specific DL reasoner, acknowledging
certain circumstances may take inordinate amount time. approach,
followed systems kris (Baader & Hollunder, 1991), problem
unpredictability: system \go wild blue yonder"?
course, circumstances impossible even attempt since reasoning
problem undecidable.
Carefully devise language limited expressive power reasoning tractable,
provide complete implementation it. approach chosen
designers languages kandor (Patel-Schneider, 1984) krypton
(Brachman et al., 1983), close approach classic (Borgida et al.,
1989).
hidden diculty second third approach produce implementation
correct (\complete") respect semantics. diculty illustrated
discovery, several years later, implementation kandor, well candide
(Beck et al., 1989), fact incomplete, subsumption problem NP-hard (Nebel,
1988), rather polynomial, claimed; happened despite fact Kandor
\small" language comparison DLs, implementation appeared
evidently correct. avoid problems, necessary produce convincing
demonstrations algorithm correct; several proofs fact already appeared DL literature (e.g., (Patel-Schneider, 1987; Hollunder & Nutt, 1990; Donini
et al., 1991)), albeit languages seen use practical applications.

1.2 Outline

classic 12 system reasoner based moderately complicated DL.
used commercial (Wright et al., 1993) prototype applications AT&T, made
available academic researchers AT&T Bell Laboratories.
2. classic 1 first released version classic. new version, classic 2, expressive DL,
recently released.

279

fiBorgida & Patel-Schneider

One purpose paper provide rigorous formal analysis correctness
eciency classic DL subsumption algorithm.3 start presenting
result subset language, call Basic classic. subsumption
algorithm relies transformation descriptions data structure, call
description graphs, generalization A-Kaci's psi-terms (1984).
process normalizing graph canonical form, remove obvious redundancies
explicate certain implicit facts, encoding particular infinite set inferences
drawn so-called \coreference constraints". correctness subsumption
algorithm demonstrated rigorously showing construct (inductively) countermodel case algorithm returns answer \no".
Next, explore effect adding individuals descriptions. show that, using
individuals, one encode disjunctive information leading need examine combinatorially many possibilities. classic implementation fact incomplete respect
standard semantics. second contribution paper well-motivated,
understandable, small change standard semantics alleviates problem.
extend subsumption algorithm proof correctness deal individuals
modified semantics, thereby characterizing sense \incompleteness"
reasoner.
paper therefore illustrates three paradigms described above, albeit nonstandard manner second paradigm, first time realistic
language significant practical use.

2. Basic CLASSIC
Descriptions Basic classic built collection atomic concept names, role
names, attribute names. Roles attributes always atomic descriptions
built using operators/constructors value restrictions number restrictions,
indicate below.
Basic classic incorporates objects host programming language,4 called host
individuals, form distinct group classic individuals; latter
roles attributes own, former restricted role attribute fillers.
denotational semantics classic descriptions starts, usual, domain
values, , subsets extensions descriptions, subsets
extensions roles attributes. domain fact disjointly divided two realms,
host realm, H , containing objects corresponding host language individuals,
classic realm C , containing objects. Every description, except THING,
denotes entire domain extension subset either classic realm
host realm. (NOTHING denotes empty set, therefore classic host
concept.) extension role possible world relation classic realm
entire domain, extension attribute function classic realm
entire domain.
3. empirical tests (Heinsohn et al., 1992), classic emerged fastest current DL
implementations.
4. general scheme incorporating host objects described (Baader & Hanschke, 1991).

280

fiSubsumption CLASSIC

Host descriptions relatively simple: (i) HOST-THING, denoting entire host realm,
H ; (ii) special, pre-defined names corresponding types host programming language; (iii) conjunctions descriptions. descriptions corresponding
host programming language types pre-defined extensions subsumption relationships, mirroring subtype relationship host programming language.
subtype relationship satisfied possible worlds/interpretations. require (i)
host concepts extension either infinite size empty; (ii)
extensions two host concepts overlap, one must subsumed other, i.e.,
types disjoint, unless subtypes other; (iii) host concept
infinite number extra instances child concepts. (These conditions
needed avoid able infer conclusions size host descriptions.)
allows host concepts INTEGER, REAL, COMPLEX, STRING, BOOLEAN
NON-ZERO-INTEGER .
Non-host (classic) descriptions Basic classic formed according following
syntax:
Syntax
Constructor Name
CLASSIC-THING
E
Atomic Concept Name
CuD
Intersection
8R:C
Role Value Restriction
8A:C
Attribute Value Restriction
n R
Minimum Number Restriction
R
Maximum Number Restriction
A1 : : : Ak = B1 : : : Bh Equality Restriction
E atomic concept name; C classic descriptions; R role; A, Ai ,
Bj attributes; n,k,h positive integers; non-negative integer. set
constructors Basic classic judiciously chosen result language
subsumption easy compute.
denotational semantics descriptions Basic classic recursively built
extensions assigned atomic names possible world:
Definition 1 possible world/interpretation, , consists domain, , interpretation function :I . domain disjointly divided classic realm, C , host
realm, H . interpretation function assigns extensions atomic identifiers follows:
extension atomic concept name E subset EI classic realm.
extension atomic role name R subset RI C .
extension atomic attribute name total function AI C
.
extension CI non-atomic classic description computed follows:
CLASSIC-THINGI = C .
(C u D)I = CI \ DI .
281

fiBorgida & Patel-Schneider

(8p:C)I = fd 2 C j 8x (d; x) 2 pI ) x 2 CI g, i.e., objects C
whose p-role p-attribute fillers extension C;

(n p)I (resp. (n p)I ) objects C least (resp. most) n fillers
role p.

(A1 : : : Ak = B1 : : : Bh )I = fd 2 C j Ak (: : : A1I (d)) = BhI (: : : B1I (d))g, i.e.,

objects C property applying composition extension
Ai composition extension Bj object result
value.5

description, D1, said subsume another, D2 , possible worlds , D2I
D1 .

key interest computation subsumption relationship descriptions
Basic classic. Subsumption computation multi-part process. First, descriptions
turned description graphs. Next, description graphs put canonical form,
certain inferences explicated redundancies reduced combining
nodes edges graph. Finally, subsumption determined description
canonical description graph.
describe detail process, start formal definition notion
description graph (Definition 2), present techniques

translating description description graph (Section 2.2), requires merging
pairs nodes, pairs graphs (Definitions 4 5);

putting description graph canonical form (Section 2.3);
determining whether description subsumes description graph (Algorithm 1).
prove correctness approach, need show first two steps
lead us right direction, i.e., following three questions equivalent: \Does
description subsume description C?", \Does description subsume graph GC ?",
\Does description subsume graph canonical(GC )?". this, need define
formal semantics descriptions graphs (Definitions 1 3), prove
results (Theorems 1 2). prove \completeness" subsumption algorithm,
show algorithm indicate subsumes canonical(GC ),
construct interpretation (\graphical world") object denotation
canonical(GC ) D.

2.1 Description Graphs

One way developing subsumption algorithm first transform descriptions
canonical form, determine subsumption relationships them. Canonical
descriptions normally thought trees since descriptions terms first order
term language. presence equality restrictions classic significantly changes
5. Note attribute chains must definite value, last cannot evaluate
host individuals, since cannot attributes.

282

fiSubsumption CLASSIC

fCLASSIC-THING
g


fTHING
g
:




,


,


captain,
coach



,


participants - fPERSONg


,

fGAMEg

father

[0; 1]

Figure 1: description graph.
handling subsumption introduce relationships different pieces
normal form. significantly, presence equalities, small description,
8friend:TALL u friend = friendfriend, subsumed descriptions arbitrary size,

8friend:(8friend:(: : : (8friend:TALL) : : :)):
order record sets inferences canonical form, resort graphbased representation, suggested semantic-network origins description logics,
work A-Kaci (1984).
Intuitively, description graph labelled, directed multigraph, distinguished
node. Nodes graph correspond descriptions, edges graph correspond
restrictions roles attributes. edges graph labelled role name
minimum maximum number fillers associated edge,
attribute name. nodes graph labelled concept names associated
node concept. example, Figure 1 description graph, which, shall see later,
corresponds description GAME u 8participants: PERSON u coach = (captainfather).
equality restrictions (and hence non-tree portions graph) involve
attributes, edges labelled roles cut-edges, i.e., removal increases one
number connected components graph. restriction important
graph tree form, really difference graphical linear notation,
semantics simple develop. graph general directed acyclic graph,
problem relating semantics generated two different paths
graph share beginning ending nodes. graph contains cycles,
problem developing correct semantics even dicult, simplistic semantics
non-well-founded, sort fixed-point model-preference semantics
required. Fortunately, non-tree parts graphical notation involve attributes
only, attributes functional, job much easier.
result restrictions, possible view description graph
following recursive structure: (i) distinguished node r, \island"
nodes connected edges labelled attributes. (ii) Nodes island may
0 edges labelled roles leaving them, pointing distinguished nodes
description graphs. (iii) graphs share nodes edges common
other, islands them.
283

fiBorgida & Patel-Schneider

recursive structure, easier represent description graphs using
recursive definition, instead usual graph definition. recursive definition similar
recursive definition tree, states tree consists information
(the information root tree) plus set trees (the children root
tree). description graphs complex simple trees, use
two-part definition.

Definition 2 description graph triple, hN; E; ri, consisting set N nodes;

bag E edges (a-edges) labelled attribute names; distinguished node r N .
Elements E written hn1 ; n2; Ai n1 n2 nodes attribute
name.
node description graph pair, hC; H consisting set C concept names
(the atoms node), bag H tuples (the r-edges node). r-edge
tuple, hR; m; M; Gi, role name, R; min, m, non-negative integer; max,
, non-negative integer 1; (recursively nested) description graph G,
representing restriction fillers role. (G often called restriction
graph node.)
Concept names description graph atomic concept names, host concept names,
THING, CLASSIC-THING, HOST-THING.

Descriptions graphs provided extensions starting possible worlds
used descriptions. However, addition need way identifying individuals
related attributes, given function .

Definition 3 Let G = hN; E; ri description graph let possible world.

interpretation GI G, interpretation nI nodes N , recursively (and mutually) defined follows:
element, d, GI , iff function, , N
1. = (r);
2. n 2 N (n) 2 nI ;
3. hn1 ; n2; Ai 2 E h(n1 ); (n2)i 2 AI , (which equivalent (n2 ) =
AI ((n1)), since AI function).
element, d, nI , n = hC; H i, iff
1. C 2 C , 2 CI ;
2. hR; m; M; Gi 2 H ,
(a) elements, d0, domain hd; d0i 2 RI

(b) d0 2 GI d0 hd; d0i 2 RI .
284

fiSubsumption CLASSIC

2.2 Translating Descriptions Description Graphs

Basic classic description turned description graph recursive process,
working \inside out". process, description graphs nodes often
merged.

Definition 4 merge two nodes, n1 n2, new node whose atoms union

atoms two nodes whose r-edges union r-edges two
nodes6.

Definition 5 merge two description graphs, G1 G2, description graph whose

nodes disjoint union7 non-distinguished nodes G1 G2 plus new
distinguished node. edges merged graph union edges G1 G2,
except edges touching distinguished nodes G1 G2 modified touch
new distinguished node. new distinguished node merge two distinguished
nodes G1 G2.

rules translating description C Basic classic description graph GC
follows:
1. description consists concept name turned description graph
one node a-edges. atoms node contains concept name.
node r-edges.
2. description form n R turned description graph one node
a-edges. node atoms CLASSIC-THING single r-edge
role R, min n, max 1, restriction GTHING .
3. description form n R turned description graph one node
a-edges. node atoms CLASSIC-THING single r-edge role
R, min 0, max n, restriction GTHING .
4. description form 8R:C, R role, turned description graph
one node a-edges. node atoms CLASSIC-THING single
r-edge role R, min 0, max 1, restriction GC.
5. turn description form C u description graph, construct GC
GD merge them.
6. turn description form 8A:C, attribute, description graph,
first construct description graph hNC ; EC ; rC C. description graph
8A:C hNC [ ftg; EC [ fht; rC ; Aig; ti, node hfCLASSIC-THINGg; fgi.
7. turn description form A1 : : : = B1 : : : Bm description graph
first create distinguished node, node r, CLASSIC-THING atoms,
node e, THING atoms. 1 n , 1 create node ai , atoms
6. Note duplicate edges, ones joining ni ni , removed, since edges form bag.
7. taking disjoint union two sets, elements one may systematically renamed first make
sure sets non-overlapping.

285

fiBorgida & Patel-Schneider

CLASSIC-THING. 1 j , 1 create node bj , atoms
CLASSIC-THING. None ai bj r-edges.
n = 1, create edge hr; e; A1i; n > 1 create edges hr; a1; A1i, han,1 ; e; i,
hai,1 ; ai; Ai 2 n , 1.
Similarly, = 1, create edge hr; e; B1i; > 1 create edges hr; b1; B1 i,
hbm,1; e; Bmi, hbi,1; bi; Bii 2 , 1.
creates two disjoint paths, one Ai one Bj , distinguished node end node.
Figure 1 presents view description graph constructed fashion
description GAME u 8participants:PERSON u coach = captainfather:
want show process preserves extensions. use merge
operations first show work correctly.

Lemma 1 n1 n2 nodes (n1 n2)I = nI1 \ nI2 . D1 D2 description
graphs (D1 D2)I = D1I \ D2I .
Proof: Since components (atoms r-edges) merged node obtained

unioning components respective nodes, since interpretation node
intersection interpretation components, result obviously true
nodes.
merging graphs, difference root nodes replaced
merger edges, well root. element (D1 D2)I clearly
element D1I D2I . Conversely, since take disjoint union nodes
two graphs, mapping functions 1 2 Definition 3 simply unioned,
element D1I D2I element merged root node, hence
(D1 D2 )I .

Theorem 1 possible worlds, extension description ex-

tension description graph.
Proof: proof structural induction descriptions.
extension concept names, cardinality restrictions, 8-restrictions roles
easily seen agree extension description graphs formed them.
Lemma 1 shows conjunction properly handled. 8-restrictions attributes,
construction correct attributes functional.
equalities A1 : : : = B1 : : : Bm construction forms description graph
two disjoint paths distinguished node end node, one labelled Ai ,
nodes ai , labelled Bj , nodes bj .

2 (A1 : : : = B1 : : : Bm)I = fd 2 C j Ak (: : : A1 (d)) = Bh (: : : B1 (d))g;
defining (ai ) = Ai (: : : A1 (d)) (bj ) = Bj (: : : B1 (d))g, yields mapping

required Definition 3. converse satisfied requirement Definition 3
a-edge hn1 ; n2; Ai 2 E , (n2 ) = AI ((n1 )).
286

fiSubsumption CLASSIC

2.3 Canonical Description Graphs

following sections occasionally refer \marking node incoherent";
consists replacing special node outgoing r-edges, including
atoms NOTHING, always empty interpretation. Marking description
graph incoherent consists replacing description graph consisting
incoherent node. (Incoherent graphs thought representing concepts
empty extension.)
Description graphs transformed canonical form repeating following normalization steps whenever possible description graph descendants.
1. node atoms pre-defined host concept, add HOST-THING
atoms. node atomic concept name atoms, add CLASSIC-THING
atoms. pre-defined host concept atoms node, add
more-general pre-defined host concepts atoms.
2. node HOST-THING CLASSIC-THING atoms, mark
node incoherent. node atoms pair host concepts
related pre-defined subsumption relationship, mark node incoherent, since
intersection empty.
3. node description graph marked incoherent, mark description graph
incoherent. (Reason: Even node root, attributes must always value,
value cannot belong empty set.)
4. r-edge node min greater max, mark node incoherent.
5. r-edge node description graph marked incoherent, change max
0. (Reason: cannot fillers belong empty set.)
6. r-edge node max 0, mark description graph incoherent.
(Reason: normalization step records equivalence 0 R 8R:NOTHING,
used infer concept 8R:C arbitrary C subsumes 0 R.)
7. node two r-edges labelled role, merge two edges,
described below.
8. description graph two a-edges node labelled
attribute, merge two edges.
merge two r-edges node, identical roles, replace one redge. new r-edge role role, maximum two mins min,
minimum two maxs max, merge two description graphs
restriction.
merge two a-edges hn; n1 ; Ai hn; n2; Ai, replace single new edge
hn; n0; Ai, n0 results merging n1 n2, i.e., n0 = n1 n2. (If n1 = n2
n0 = n1.) addition, replace n1 n2 n0 a-edges description graph.
287

fiBorgida & Patel-Schneider

need show transformations canonical form change extension
graph. main diculty showing two edge-merging processes
change extension.

Lemma 2 Let G = hN; E; ri description graph two mergeable a-edges let
G0 = hN 0; E 0; r0i result merging two a-edges. GI = G0I .
Proof: Let two edges hn; n1; Ai hn; n2; Ai new node n0 n1 n2.
Choose 2 GI , let function N domain satisfying conditions

extensions (Definition 3) (r) = d. (n1 ) = (n2 )
equal AI ((n)). Let 0 except 0 (n0 ) = (n1 ) = (n2 ).
0 satisfies Definition 3, part 3, G0, replace n1 n2 n0 everywhere.
Moreover, 0 (n0) = (n1 ) 2 nI1 \ nI2 , which, Lemma 1, equals (n1 n2 )I ; part 2
satisfied too, since n0 = n1 n2 . Finally, root modified merger, i.e., n1
n2 r, say n1, = (n1) = 0 (n0), part 1 definition satisfied.
Conversely, given arbitrary 2 G0I , let 0 function stipulated Definition 3
0 (r0) = d. Let 0 except (n1 ) = (n0 ) (n2 ) = 0 (n0 ).
argument traversed reverse verify satisfies Definition 3,
2 GI .

Lemma 3 Let n node two mergeable r-edges let n0 node

edges merged. nI = n0I .
Proof: Let two r-edges hR; m1; M1; G1i hR; m2; M2; G2i.
Let 2 nI . m1 (m2) M1 (M2) elements domain, d0,
hd; d0i 2 RI . Therefore maximum m1 m2
minimum M1 M2 elements domain, d0, hd; d0i 2 RI . Also, d0
hd; d0i 2 RI GI1 (GI2 ). Therefore, d0 hd; d0i 2 RI GI1 \ GI2 ,
equals (G1 G2)I Lemma 1. Thus 2 n0I .
Let 2 n0I . maximum m1 m2 minimum
M1 M2 elements domain, d0 , hd; d0i 2 RI . Therefore
m1 (m2) M1 (M2) elements domain, d0, hd; d0i 2 RI . Also, d0
hd; d0i 2 RI (G1 G2 )I = GI1 \ GI2 . Therefore, d0 hd; d0i 2 RI
GI1 (GI2 ). Therefore 2 nI .

dealt issue merging, return desired result: showing
\normalization" affect meaning description graphs.

Theorem 2 possible worlds , extension canonical form description

graph, G, resulting Basic classic description extension
description.
Proof: Steps 1 2 justified since GI subset either H C ,
disjoint.
Step 3 justified fact that, definition description graphs, must
element domain extension node description graph.
Steps 4, 5, 6 easily derived Definition 3.
Steps 7 8 dealt preceding two lemmas.
288

fiSubsumption CLASSIC

2.4 Subsumption Algorithm
final part subsumption process checking see canonical description graph
subsumed description. turns possible carry subsumption
test without expense normalizing candidate subsumer concept.

Algorithm 1 (Subsumption Algorithm) Given description description graph
G = hN; E; ri, subsumes?(D; G) defined true following

conditions hold:

1. description graph G marked incoherent.
2. equivalent THING. (This determined checking first D=THING,
recursively testing whether subsumes canonical description graph GTHING .)
3. concept name element atoms r.
4. n R r-edge r R role min greater equal n.
5. n R r-edge r R role max less equal n.
6. 8R:C r-edge r R role G0 restriction graph
subsumes?(C; G0).
7. 8R:C subsumes?(C; GTHING) r CLASSIC-THING atoms. (Reason: 8R:THING requires possibility R applicable object, absent
host values.)
8. 8A:C a-edge G form hr; r0; Ai, subsumes?(C; hN; E; r0i).
9. 8A:C subsumes?(C; GTHING) r CLASSIC-THING atoms.
10. A1 : : : = B1 : : : Bm paths A1 ; : : :; B1 ; : : :; Bm exist G
starting r end node.
11. A1 : : : = B1 : : : Bm Bm paths A1 ; : : :; An,1
B1 ; : : :; Bm,1 exist G starting r end node,
CLASSIC-THING atoms. (Reason: AiI ( A1 ( )) = Bj ( B1 ( ))
:::



:::



(AiI (: : : A1I (d))) = (Bj (: : : B1 (d)))

attribute F, long attribute applicable (i.e., value host
domain).)

12. C u E subsumes?(C; G) subsumes?(E; G) true.
289

fiBorgida & Patel-Schneider

2.5 Correctness Subsumption Algorithm

soundness algorithm fairly obvious, shall dwell it. completeness algorithm is, usual, dicult establish. First show
canonical description graph node marked incoherent, possible
world non-empty extension description graph node constructed.
constructive, inductive manner, constructing collection possible worlds, called graphical worlds description graph. graphical world
distinguished domain element extension description graph node.
common operation merge two possible worlds.
Definition 6 Let I1 I2 two possible worlds. merge I1 I2, I1 I2,
possible world classic realm disjoint union classic realm I1
classic realm I2 . extension atomic names I1 I2 disjoint union
extensions I1 I2 .
easy show extension description, description graph, node
I1 I2 union (disjoint union classic realm, regular union host realm)
extensions I1 I2 .
Another operation add new domain elements possible world. new domain
elements must classic realm. extension atomic identifiers remain
except new domain elements belong arbitrary set atomic concept
names arbitrary set fillers (filler) role (attribute). Again,
easy show domain element original world extension original
world iff extension augmented world.
Given node, n, marked incoherent, construct graphical worlds
n follows:
1. atoms n precisely THING, n r-edges,
constructs cause r-edges created add CLASSIC-THING atoms.
possible world, domain element distinguished domain element,
graphical world n.
2. atoms n include HOST-THING, n r-edges. possible
world, distinguished element domain element extension
atoms n host concepts, graphical world n. (Because
requirements host domain, infinite number domain
elements.)
3. atoms n include CLASSIC-THING, r-edge, hR; m; M; Gi, n,
construct graphical worlds G. done number
> 0 G marked incoherent, G
marked incoherent = 0.
two graphical worlds host domain element
distinguished element. (Again, possible extension host concept
either empty infinite.) merge graphical worlds r-edge
one possible world. Add new domain elements one exactly
290

fiSubsumption CLASSIC

extensions atoms n fillers R exactly distinguished
elements appropriate graphical worlds. domain element
correct number fillers r-edge, disjoint union classic
realms merge process different host domain elements picked
above; therefore extension n. Thus resulting world graphical
world n.
Given description graph, G = hN; E; ri, marked incoherent, construct
graphical worlds G follows: node n 2 N construct graphical world
n. done none marked incoherent. Merge graphical
worlds. Modify resulting world hn1 ; n2; Ai 2 E A-filler
distinguished node graphical world n1 distinguished node graphical
world n2 . easy show distinguished node graphical world r
extension G, making graphical world G.
show final part result.

Theorem 3 subsumption algorithm indicates canonical description
graph G subsumed Basic classic description D, possible world
domain element extension graph extension D.
Therefore G subsumed D.
Proof: proof actually shows subsumption algorithm indicates
canonical description graph, G, subsumed description, D,
graphical worlds G distinguished domain elements
extension D. Remember subsumption algorithm indicates G subsumed
D, G must marked incoherent thus graphical worlds G.
proof proceeds structural induction D. Let G = hN; E; ri.
atomic concept name pre-defined host concept, occur
atoms r. construction, graphical world G distinguished
domain element extension D. Similarly, CLASSIC-THING
HOST-THING, distinguished domain elements wrong realm.
THING, possible subsumption algorithm indicate
non-subsumption. case graphical world G property
distinguished domain element extension D.

form D1 u D2 subsumption algorithm must indicate G

subsumed least one D1 D2 . inductive hypothesis, get
graphical worlds G distinguished domain elements
extension D1 extension D2, thus extension D.

form n R either r-edge r labelled R min less
n r-edge.
former case graphical worlds G distinguished node
n , 1 fillers R, n greater min r-edge R, thus
distinguished node extension D.
291

fiBorgida & Patel-Schneider

latter case, graphical worlds G distinguished node
number fillers R. n , 1 fillers property
distinguished node extension D.

form n R either r-edge r labelled R max greater
n (including 1) r-edge.
former case graphical worlds G distinguished node
n + 1 fillers R, n less max r-edge R, thus
distinguished node extension D.
latter case, graphical worlds G distinguished node
number fillers R. n + 1 fillers property
distinguished node extension D.

form 8R:C, R role, two cases arise.
1. subsumes?(C; GTHING) CLASSIC-THING atoms r.
graphical worlds G whose distinguished element host

realm, thus extension D.
2. Otherwise, either r-edge r role R description graph H
subsumes?(C; H ) false r-edge r role R. Note
extension C entire domain, thus must subset
either host realm classic realm.
former case H marked incoherent (or else subsumption could
false) max r-edge cannot 0. Thus graphical
worlds H whose distinguished element extension C
graphical worlds G use graphical worlds H distinguished
domain element R-fillers. graphical worlds G distinguished element extension D.
latter case, pick graphical worlds G distinguished node
R-filler wrong realm. graphical worlds G distinguished
element extension D.

form 8A:C attribute two cases arise.
1. subsumes?(C; GTHING) CLASSIC-THING atoms r.
graphical worlds G whose distinguished element host
realm, thus extension D.
2. Otherwise, either a-edge r attribute node
r0 subsumes?(C; H ) false, H = hN; E; r0i; a-edge
r attribute A. Note extension C entire domain,
thus must subset either host realm classic realm.
former case H marked incoherent, G marked incoherent. Thus graphical worlds H whose distinguished element
extension C. Given graphical world H , graphical world
G formed simply changing distinguished domain element.
292

fiSubsumption CLASSIC

original graphical world's distinguished element extension C,
new graphical world's distinguished element extension
D, required.
latter case, pick graphical worlds G distinguished node
A-filler wrong realm. graphical worlds G distinguished
element extension D.
form A1 : : : = B1 : : : Bm several cases arise.
1. one paths A1 ; : : :; An,1 B1 ; : : :; Bm,1 exist G starting
r, find end partial path use graphical worlds
domain element node element host domain filler
next attribute path. one full paths filler.
2. paths A1 ; : : :; B1 ; : : :; Bm exist G starting r end
different nodes, use graphical worlds domain elements
two nodes different.
3. one paths A1 ; : : :; B1 ; : : :; Bm exist G starting
r paths A1 ; : : :; An,1 B1; : : :; Bm,1 exist G starting r
end node either CLASSIC-THING atoms
node 6= Bm. former case use graphical worlds domain
element node host realm. latter case use graphical worlds
different fillers Bm domain element node.
4. one paths A1 ; : : :; B1 ; : : :; Bm exist G starting
r paths A1 ; : : :; An,1 B1; : : :; Bm,1 exist G starting r
end different nodes use graphical worlds different fillers
domain elements nodes domain elements
host realm.
cases either one (: : : A1 )(d) BmI (: : : B1 )(d)
exist (: : : A1 )(d) 6= BmI (: : : B1 )(d), distinguished domain element
extension D.

2.6 Implementing subsumption algorithm

section provide comments actual subsumption algorithm
used classic system, including rough analysis complexity.
described it, deciding whether description C subsumes accomplished
three phases:
1. Convert description graph GD .
2. Normalize GD .
3. Verify whether C subsumes GD .
Step 1: Conversion accomplished simple recursive descent parser, takes
advantage fact syntax description logics (i.e., leading term constructor) makes amenable predictive parsing. Clearly, constructing graphs fixed sized
293

fiBorgida & Patel-Schneider

terms (like at-least) constant time (if measure size integer size 1 matter large), time non-recursive terms (like same-as) proportional
length. Finally, recursive terms (like all, and) require fixed amount additional
work, top recursive processing. Therefore, first stage accomplished
time proportional size input description. order speed later processing,
useful maintain various lists, lists atomic concept identifiers,
roles/attributes, sorted order. sorting needs done initially (later, ordering
maintained performing list merges) incurs, worst case quadratic
overhead processing8 . case, total size graph constructed (including
sizes nodes, etc.) proportional size original concept description.
Step 3: Checking whether description C subsumes description graph GD ,
seen run time proportional size subsuming concept, modulo cost
lookups various lists. Since sorted, lookup costs bounded
logarithm size candidate subsumee graph, total cost bounded
O(j C j log j GD j).
Step 2: Normalization accomplished post-order traversal description
graph: processing description graph hN; E; ri, node N normalized first independently (see details below), afterwards attribute edges E normalized.
later task involves identifying multiple identically-labelled attribute edges leaving node
(this done one pass since attribute edges grouped source node, sorted
attribute name), \merging" them. Merging two edges quite easy itself, merging nodes tips, must careful node mergers
may cascade; example, concept form a1 = b1 u a2 = b2 u : : : u = bn u
a1 = a2 u a2 = a3 u : : : u an,1 = original graph 2n + 1 nodes, 2n
collapsed normalization step 8. discover eciently, use version
A-Kaci's algorithm unifying -terms (At-Kaci, 1984; At-Kaci & Nasr, 1986);
algorithm relies UNION-FIND technique identify nodes merged, runs
time slightly linear number nodes N . Therefore cost
non-recursive portion graph normalization roughly linear number nodes
it.
merging two description graph nodes quite similar normalization
single node: atomic concept identifier lists need sorted/merged, duplicates
eliminated y. done time proportional size nodes
themselves, make size node include size various lists it,
atoms. processing role edges leaving node is, again, one identifying merging
identically-labelled edges. (But case mergers labelled edges interact,
single pass role-edge list sucient.) cost non-recursive aspects
merger proportional size local information.
therefore left problem bounding total number procedure calls
NormalizeGraph, NormalizeNode, MergeEdge, MergeNode, bounding
sizes nodes merged.
NormalizeGraph NormalizeNode called exactly every (sub)graph
node original graph, part depth-first traversal, argued above,
8. tend use fancy sorting techniques since lists likely long.

294

fiSubsumption CLASSIC

contribute time proportional total size original graph,
proportional size original description.
number calls MergeEdge MergeNode simply bounded however {
node may merged several times others. However, calls paired,
invocation MergeNode reduces number nodes graph one. Therefore, since number nodes incremented elsewhere, total number calls
MergeEdge MergeNode bounded number nodes original graph.
problem non-recursive cost call MergeNode depends size
argument nodes, call may increase size remaining node
sum sizes two original nodes.
Therefore, original concept size S, graph n nodes, size
vi, worst case cost would result iterative summation sizes:
(vi1 + vi2 ) + (vi1 + vi2 + vi3 ) + (vi1 + vi2 + vi3 + vi4 ) + : : :
= n vi1 + (n , 1) vi2 + : : : + 1 vi
n

Given n vj bounded
, clearly worst case O(S 3).
P
fact, given constraint j =1 nvj = , possible argue worst case
cost occur vj = 1 every j, (i.e., n = ), case cost really
O(S 2).
theoretical improvements could attempted algorithm
(e.g., merging nodes correct order increasing size) well analysis (e.g.,
nodes graphs depth tree merged).
remark description logics, classic permits identifiers associated complex descriptions identifiers used descriptions
(though recursion allowed). expansion identifiers standard operation
lead exponential growth size certain pathological cases (Nebel, 1990), making
subsumption problem inherently intractable. type system programming language Standard ML, pathological cases encountered practice,
correct algorithm simple, straightforward ecient normal cases (unlike
correct algorithm reasoning set constructor, say).
users rarely ask whether concept subsumes another, rather
interested relationship pairs concepts, classic fact constructs
normalized description graph description given it. suggests might
better check whether one description graph subsumes another one, rather checking
whether description subsumes graph. general, works quite well, except
would verify attribute edges subsumer graph form subgraph
subsumee's attribute edges. Since edges uniquely labelled normalization,
inherently hard, still requires complete traversal (and hence marking/unmarking)
upper graph. therefore found useful encode part description
graph's root same-as restrictions lead construction corresponding aedges; then, subsumption testing, aspect subsumer related same-as
checked list same-as pairs.
Also, description algorithm tried optimize cost normalization, dominates checking single subsumption. overall use
295

fiBorgida & Patel-Schneider

system (e.g., processing individuals), inquiries restrictions roles/attributes
frequent, space usage problem, may practically advantageous
maintain r-edges a-edges node hash table, rather sorted list,
order speed access. (Note merging r-edges, one must however still
way iterating values stored hash table.)

3. Individuals Descriptions

practical applications DLs used, integrity constraint checking,
often useful able specify ranges atomic values roles. common
examples involve integers, e.g., \the year student 1,2,3 4",
called enumerated types Pascal, e.g., \the gender person either F". One way
allow constraints introduce new description constructor, set description,
creates description list individual names, whose obvious extension
set consisting extensions individuals appear list. construct
could used terms 8year:f1 2 3 4g. Another useful constructor involving individuals
fills restriction, p : I, denotes objects extension individual
one fillers relationship denoted role attribute p. (Note
attribute, q, 8q:fIg q : I.)
Within paradigm DLs, constructors quite useful fact used
express new forms incomplete information. example, know Ringo
early fifties, simply assert Ringo described 8age:f50 51 52 53 54g.
constructors used ask useful queries. example, find
male persons suces determine instances gender : M.
new constructors interact previous ones, cardinality constraints:
clearly size set upper cardinality bound role restricts. interaction
problematic long individuals set host values, since individuals
properties fixed known ahead time. However, allow classic
individuals members sets, properties individuals might
affect subsumption. simple example, know Ringo instance
concept ROCK-SINGER (which shall write Ringo 2 ROCK-SINGER ) extension
8friends:ROCK-SINGER always superset extension 8friends:fRingog.
disturbing classification hierarchy definitions would change
new facts individuals added knowledge base. Definitions meant
contingent facts current world. Therefore, subsumption usually defined
independent \contingent" assertions. shall see below, use individual
properties description subsumption leads intractability.

3.1 Complex Subsumption Reasoning: Example

Traditional proofs intractability (e.g. (Levesque & Brachman, 1987)) occasionally
left users DLs puzzled intuitive aspects language make reasoning
dicult. reason present example illustrates complexity reasoning
set description.
Suppose concept JADED-PERSON one wants
visit Arctic and/or Antarctic, wherever penguins:
296

fiSubsumption CLASSIC

JADED-PERSON =: 8wantsToVisit:(fArctic Antarcticg u 8hasPenguins!: fYesg)

Suppose remember Arctic Antarctic; know
South Pole located one two places, penguins there,
North Pole located one two places, penguins there.
Assuming isLocatedIn! hasPenguins! attributes|roles exactly one filler,
record
Southpole 2 8isLocatedIn!:(fArctic Antarcticg u 8hasPenguins!: fYesg)
Northpole 2 8isLocatedIn!:(fArctic Antarcticg u 8hasPenguins!: fNog)

thus unable distinguish exact location Southpole Northpole; however,
since hasPenguins! single filler, exactly one Arctic Antarctic (and fact
must) Yes filler hasPenguins!, therefore exactly one location
Southpole .
result facts, know extension JADED-PERSON must
subset extension 1 wantsToVisit database containing facts
Southpole Northpole.
Observe occasional worse-case behavior, generalized
diculty reasoning set descriptions. subsumption ignores assertions
individuals, (yet) show subsumption per se must perform inferences.
simple transformation, given appendix, establishes fact, converting
recognition individuals question subsumption two descriptions
making individuals involved attribute-fillers new dummy attributes,
descriptions restrictions attributes. result, description non-empty
attribute values must satisfy corresponding restrictions.

3.2 Modified Semantics Individuals

seen two problems individuals appearing descriptions: (1) effect
\mutable facts" extensional relationships \immutable" descriptions, (2)
computational intractability subsumption caused appearance individuals
descriptions.
deal first problem, reasonable restrict computation subsumption cannot access \database facts" individuals, role fillers,
individuals treated host identifiers. procedural description
aspect reasoning, sense negation-by-failure Prolog. Prolog,
would desirable find semantic account phenomenon.
semantics ignores mutable facts determining subsumption hard
devise|all required two different sets possible worlds corresponding
KB containing concepts individuals. One set consists possible worlds
model information KB; second consists possible worlds
model information concepts (and roles attributes). asking questions individuals, first set possible worlds must considered; asking
subsumption questions, second, larger, set must considered, thus ignoring effects
mutable facts.
297

fiBorgida & Patel-Schneider

However, semantics solve computational problem individuals
descriptions. deal problem, semantics individuals modified
follows: instead mapping individuals separate elements domain, done
standard semantics, individuals mapped disjoint subsets domain, intuitively
representing different possible realizations (Platonic) individual.
Therefore, semantics set constructor stated follows: Domain value
belongs extension fB1 : : : Bn g iff belongs extension one Bi .
associated change notion cardinality required|two elements domain
considered congruent belong extension individual
identical. cardinality set elements domain size set
modulo congruence relationship. means occurrences different identifiers
description(s) guaranteed unequal, distinct occurrences individual
identifier guaranteed denote individual.
two consequences stance:
1. Looking descriptions Southpole Northpole Section 3.1, distinct
occurrences Arctic might satisfied distinct domain elements, different role
fillers. (In greater detail: extension Arctic might include domain elements d1
d2, d1 satisfying condition hasPenguins! : Yes, d2 satisfies hasPenguins! : No.
Southpole located d1, Northpole located d2 , still
satisfying isLocatedIn! : Arctic. Similarly domain elements d3 d4
extension Antarctic. Therefore one could two places visit
penguins, d1 d3.)
2. Even though individual may description includes
isLocatedIn! : Arctic u originatesIn! : Arctic;
need satisfy condition isLocatedIn! = originatesIn!, since equality restriction requires identity domain values.

4. Adding Individuals CLASSIC

Individuals occur classic host descriptions. following constructs create
classic descriptions:
R:I
A:I
fI1 : : : Ing
attribute, R role, name classic individual host value,
collectively called individuals, Ij names classic individuals. New host descriptions
constructed using fI1 : : : g, Ij host values.
interpretation function :I extended individual identifiers, requiring II
non-empty subset C , syntactically recognized host individual,
making II = fIg host values I. stated earlier, interpretations distinct identifiers
must non-overlapping.
interpretation CI non-atomic descriptions modified follows:
298

fiSubsumption CLASSIC

p : II = fd 2 C j 9x (d; x) 2 pI ^ x 2 II g
fI1 : : : IngI = Sk IIk Ik classic individuals; fI1 : : : IngI = fI1 : : : g Ik
host individuals; empty otherwise.

(n p)I (resp. (n p)I ) objects C least (resp. most) n noncongruent fillers role p

development subsumption algorithm Section 2 modified take
account added constructs modified semantics introduced earlier.
First description graphs extended. node description graph given third
field, either finite set individuals special marker denoting \universal"
set. field often called dom node. a-edges r-edges given
extra field, called fillers edge. field finite set individuals.
unspecified, constructions previous sections, dom node universal set
fillers a-edge r-edge empty set.
semantics description graphs Definition 3 extended following:

Definition 7 Let G = hN; E; ri description graph let possible world.

element, d, GI , iff function, , N

1. = (r);
2. n 2 N (n) 2 nI ;
3. hn1 ; n2; A; F 2 E h(n1 ); (n2)i 2 AI , f 2 F , (n2 ) 2 f .
element, d, nI , n = hC; H; i, iff
1. C 2 C , 2 CI ;
2. hR; m; M; G; F 2 H ,
(a)
(b)
(c)

elements, d0, domain hd; d0i 2 RI ;
d0 2 GI d0 hd; d0i 2 RI ;
f 2 F domain element, d0 , hd; d0i 2 RI d0 2 f

3. universal set 9f 2 2 f .

merging nodes, dom sets intersected. Merging description graphs unchanged. merging a-edges r-edges, sets fillers unioned.
translation descriptions description graphs extended following rules:
8. description form R : turned description graph one node
a-edges. node atoms CLASSIC-THING single r-edge role
R, min 0, max 1, fillers fIg. description graph restricting r-edge
GCLASSIC-THING classic individual, GHOST-THING otherwise.
299

fiBorgida & Patel-Schneider

9. description form : turned description graph two nodes
single a-edge them. distinguished node graph source
a-edge. r-edges atoms CLASSIC-THING. node
r-edges. atoms CLASSIC-THING classic individual,
HOST-THING otherwise. a-edge single filler I.
10. description form fI1 : : : g turned description graph one node.
node dom set containing I1 , r-edges. atoms
node HOST-THING individuals host values, CLASSIC-THING
individuals classic individual names. (Note parser ensures
individuals either must host values must classic individual names.)
short examination shows Theorem 1 true graphs, i.e., extension
description graphs formed using rules extension description
formed.
following transformations added canonicalization algorithm:
9. dom node empty, mark node incoherent.
10. host value dom node atoms node, remove
dom.
11. a-edge one filler, mark description graph incoherent.
12. a-edge filler node end universal dom, make dom
filler.
13. filler a-edge included dom node end, mark
description graph incoherent.
14. node one element dom, make element filler
a-edges pointing it.
15. fillers r-edge subset dom distinguished node
restriction graph edge, mark node r-edge incoherent.
16. min r-edge less cardinality fillers it, let min
cardinality.
17. max r-edge greater cardinality dom distinguished node description graph r-edge, make max edge
cardinality dom.
18. min r-edge greater equal cardinality dom
distinguished node restriction graph r-edge, let fillers edge
union fillers dom above. (If min greater cardinality,
steps 4 17 detect inconsistency.)
300

fiSubsumption CLASSIC

19. max edge equal cardinality fillers edge, let dom
distinguished node description graph r-edge intersection
dom fillers. (If max less cardinality, steps 18 4 detect
inconsistency.)
Note new canonical form a-edges pointing single node
value fillers, empty set, node set
value dom.
proofs Lemmas 3 2 work extension description graphs.
proof Theorem 2 extended graphs.
subsumption algorithm page 289 extended follows:
13. R : r-edge r role R fillers including I.
14. : a-edge r attribute fillers including I.
15. fI1 : : : g dom r subset fI1 : : : g.
Again, soundness extended algorithm fairly obvious. completeness
proof following additions construction graphical worlds:

extension classic individual names starts empty.
constructing graphical worlds node includes HOST-THING
atoms non-universal dom, pick domain elements corresponding
elements dom.

constructing graphical worlds node includes CLASSIC-THING
atoms non-universal dom, add distinguished domain element
extension one dom elements.

constructing graphical worlds r-edges node, ensure element

fillers r-edge distinguished element least one graphical
worlds extension either adding extension using appropriate
host domain elements. (This done fillers must subset
dom distinguished node graphical world host values must belong
atoms.)

fillers a-edges need considered \pushed" onto nodes
canonicalization process.
proof Theorem 3 extended following cases:

form fI1 : : : Ing dom r subset fI1; : : :; Ing. Thus
graphical worlds G distinguished domain element
extension Ij.

form : either a-edge r labelled
filler a-edge.

301

fiBorgida & Patel-Schneider

former case node pointed a-edge cannot domain
singleton consisting I. Therefore graphical worlds G
distinguished node A-filler extension I, required.
latter case, pick graphical worlds G distinguished node Afiller wrong realm. graphical worlds G distinguished element
extension D.

form R : either r-edge r labelled R
filler r-edge.
former case either cardinality dom distinguished node
description graph r-edge greater min, m, r-edge, dom
include I. dom include I, graphical worlds
node distinguished element extension I, required.
dom include I, least elements dom besides I,
fillers r-edge subset set elements. thus graphical
worlds G use elements, required.
latter case, pick graphical worlds G distinguished node Rfiller wrong realm. graphical worlds G distinguished element
extension D.

shows subsumption algorithm given sound complete
modified semantics presented here.

5. Complete CLASSIC

make final pass deal less problematic aspects classic descriptions
appropriately covered far.
classic allows primitive descriptions form (PRIMITIVE T),
description, symbol. extension arbitrary subset
extension D, extension (PRIMITIVE E T), provided
E subsume other. way one express EMPLOYEE, kind person
must employee number,
(PRIMITIVE (PERSON u 1 employeeNr) employee)
construct removed creating every primitive atomic concept (e.g.,
EMPLOYEEHOOD) replacing definition concept conjunction
necessary conditions atom, case EMPLOYEEHOOD u (PERSON u
1 employeeNr). Care taken use atomic concept equivalent primitives.
classic permits declaration disjoint primitives, essentially allowing one state
extensions various atomic concepts must disjoint possible worlds.
deal declarations, need modify algorithm creating canonical graphs
adding step marks node incoherent whenever atoms contains two identifiers
declared disjoint.
302

fiSubsumption CLASSIC

allow approximate representation ideas cannot encoded using
constructors expressly provided, classic allows use test-defined concepts, using
following syntax:
(TEST [host-language Boolean function])
e.g., (TEST Prime-Number-Testing-Function).9 purposes subsumption,
treated \black-boxes", semantics assigned atomic concepts. (Test concepts
real effect reasoning level individuals, perform constraint
checking.)
simple additions, algorithm sound complete subsumption
algorithm descriptions classic 1, modified semantics introduced
paper.

6. Summary, Related Work, Conclusions
believe paper makes two kinds contributions: First, paper presents abstracted form subsumption algorithm classic description logic, shows
ecient correct modified semantics. significant
previous claims correct ecient subsumption algorithms implemented DLs
kandor (Patel-Schneider, 1984) candide (Beck et al., 1989) turned
unfounded (Nebel, 1988).
tractability proof language Basic classic claimed exist (but
proven) (Donini et al., 1991), alternate proof technique may found considering restriction (corrected) subsumption algorithm (Hollunder & Nutt, 1990).
Description graphs turned interest support
theoretical results DLs, concerning learnability (Cohen & Hirsh, 1994; Pitt &
Frazier, 1994)|results would seem harder obtain using standard notation
DLs.
Second, paper investigates effect allowing individuals appear descriptions DLs. independently demonstrated (Lenzerini & Schaerf, 1991), adding
set description introduces yet another source intractability, provided
intuitive example illustrating source diculties. implementers classic
system, others use refutation/tableaux theorem-proving techniques, chose
perform inferences validated standard semantics,
formal intractability result obvious algorithm apparent, short enumerating possible ways filling roles. subset inferences actually performed
initially described procedurally: \facts" individuals taken account
subsumption algorithm. paper provides denotational semantic account
incomplete set inferences. formal proof correct account corollary
completeness proof subsumption algorithm Section 4, observation
graph construction subsumption algorithms section indeed ignore
9. order deal two realms, classic fact provides two constructors: H-TEST CTEST, host classic descriptions, cause added complications besides
keeping track correct realm.

303

fiBorgida & Patel-Schneider

properties individuals involved. one difference original implementation classic current semantics attribute paths ending
filler used imply equality condition. noted Section 3.2, modified
semantics support inference, taken implementation
classic. significant change standard semantics small, easy explain
users (either procedurally semantically), affects desired aspects
language (i.e., reasoning Basic classic remains exactly before).

Acknowledgments

wish thank Ronald Brachman colleagues classic project
collaboration, JAIR referees excellent suggestions improving
paper. particular, one referees deserves medal thoroughness care
taken locating weaknesses arguments, thankful. remaining
errors course responsibility.

References

At-Kaci, H. (1984). Lattice Theoretic Approach Computation Based Calculus
Partially-Ordered Type Structures. Ph.D. thesis, University Pennsylvania.
At-Kaci, H., & Nasr, R. (1986). LOGIN: logic programming language built-in
inheritance. Journal Logic Programming, 3, 187{215.
American Association Artificial Intelligence (1992). Issues Description Logics: Users
Meet Developers. Working Notes AAAI 1992 Fall Symposium.
Baader, F., Burckert, H.-J., Heinsohn, J., Hollunder, B., Muller, J., Nebel, B., Nutt, W.,
& Profitlich, H.-J. (1991). Terminological knowledge representation: proposal
terminological logic. German Research Center Artificial Intelligence (DFKI).
Baader, F., & Hanschke, P. (1991). scheme integrating concrete domains concept
languages. Proceedings Twelfth International Joint Conference Artificial
Intelligence, pp. 452{457. International Joint Committee Artificial Intelligence.
long version appears Research Report RR-91-10 German Research Center
Artificial Intelligence (DFKI), April 1991.
Baader, F., & Hollunder, B. (1991). KRIS: Knowledge Representation Inference System.
SIGART Bulletin, 2 (2), 8{15.
Beck, H. W., Gala, S. K., & Navathe, S. B. (1989). Classification query processing
technique CANDIDE semantic data model. Proceedings Fifth International Data Engineering Conference, pp. 572{581. Institute Electric Electronic
Engineers.
Borgida, A., Brachman, R. J., McGuinness, D. L., & Resnick, L. A. (1989). CLASSIC:
structural data model objects. Proceedings 1989 ACM SIGMOD International Conference Mangement Data, pp. 59{67. Association Computing
Machinery.
304

fiSubsumption CLASSIC

Borgida, A. (1992). type systems knowledge representation: Natural semantics
specifications description logics. International Journal Intelligent Cooperative Information Systems, 1 (1), 93{126.
Brachman, R. J., Fikes, R. E., & Levesque, H. J. (1983). KRYPTON: functional approach
knowledge representation. IEEE Computer, 16 (10), 67{73.
Cohen, W. W., & Hirsh, H. (forthcoming). Learnability description logics equality
constraints. Machine Learning. preliminary version appears Proceedings
Fourth Annual Workshop Computational Learning Theory.
Devanbu, P., Brachman, R. J., Ballard, B., & Selfridge, P. G. (1991). LaSSIE: knowledgebased software information system. Communications ACM, 34 (5), 35{49.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991). Tractable concept languages.
Proceedings Twelfth International Joint Conference Artificial Intelligence,
pp. 458{453. International Joint Committee Artificial Intelligence.
Doyle, J., & Patil, R. (1991). Two theses knowledge representation: Language restrictions, taxonomic classification, utility representation services. Artificial
Intelligence, 48 (3), 261{297.
Pitt, L., & Frazier, M. (1994). Classic learning. Proceedings Seventh Annual ACM
Conference Computational Learning Theory New Brunswick, NJ. ACM Press.
Heinsohn, J., Kudenko, D., Nebel, B., & Profitlich, H.-J. (1992). empirical analysis terminological representation systems. Proceedings Tenth National
Conference Artificial Intelligence, pp. 767{773. American Association Artificial
Intelligence.
Hollunder, B., & Nutt, W. (1990). Subsumption algorithms concept languages. Research
report RR-90-04, German Research Center Artificial Intelligence (DFKI).
Lenzerini, M., & Schaerf, A. (1991). Concept languages query languages. Proceedings
Ninth National Conference Artificial Intelligence, pp. 471{476. American
Association Artificial Intelligence.
Levesque, H. J., & Brachman, R. J. (1987). Expressiveness tractability knowledge
representation reasoning. Computational Intelligence, 3 (2), 78{93.
MacGregor, R. M., & Bates, R. (1987). Loom knowledge representation language. Tech.
rep. ISI/RS-87-188, Information Sciences Institute, University Southern California.
Mays, E., Apte, C., Griesmer, J., & Kastner, J. (1987). Organizing knowledge complex
financial domain. IEEE Expert, 2, 61{70.
Nebel, B. (1988). Computational complexity terminological reasoning BACK. Artificial
Intelligence, 34 (3), 371{383.
Nebel, B. (1990). Terminological reasoning inherently intractable. Artificial Intelligence,
43 (2), 235{249.
305

fiBorgida & Patel-Schneider

Nebel, B., Peltason, C., & von Luck, K. (Eds.). (1991). International Workshop Terminological Logics. Document D-91-13, German Research Center Artificial Intelligence
(DFKI).
Owsnicki-Klewe, B. (1988). Configuration consistency maintenance task. Hoeppner, W. (Ed.), Proceedings GWAI-88|the 12th German Workshop Artificial
Intelligence, pp. 77{87. Springer Verlag.
Patel-Schneider, P. F. (1984). Small beautiful knowledge representation.
Proceedings IEEE Workshop Principles Knowledge-Based Systems, pp.
11{16. IEEE Computer Society.
Patel-Schneider, P. F. (1987). Decidable, Logic-Based Knowledge Representation. Ph.D.
thesis, Department Computer Science, University Toronto.
Patel-Schneider, P. F. (1989a). four-valued semantics terminological logics. Artificial
Intelligence, 38 (3), 319{351.
Patel-Schneider, P. F. (1989b). Undecidability subsumption NIKL. Artificial Intelligence, 39 (2), 263{272.
Peltason, C., von Luck, K., & Kindermann, C. (Eds.). (1991). Terminological Logic Users
Workshop. Fachbereich Informatik, Technische Universitat Berlin.
Peltason, C., von Luck, K., Nebel, B., & Schmiedel, A. (1987). user's guide
BACK system. Kit-report 42, Fachbereich Informatik, Technische Universitat Berlin.
Resnick, L. A., Borgida, A., Brachman, R. J., McGuinness, D. L., & Patel-Schneider,
P. F. (1992). CLASSIC description reference manual COMMON LISP
implementation. AI Principles Research Department, AT&T Bell Laboratories.
Schmidt-Schauss, M. (1989). Subsumption KL-ONE undecidable. Proceedings
First International Conference Principles Knowledge Representation
Reasoning, pp. 421{431. Morgan Kaufmann.
Wright, J. R., Weixelbaum, E. S., Brown, K., Vesonder, G. T., Palmer, S. R., Berman,
J. I., & Moore, H. H. (1993). knowledge-based configurator supports sales,
engineering, manufacturing AT&T network systems. Proceedings
Innovative Applications Artificial Intelligence Conference, pp. 183{193. American
Association Artificial Intelligence.

A. Intractability Reasoning ONE-OF

present formal proof subsumption set descriptions fact NP-hard.10
show term language allows set description need
\case analysis" order check whether extension individual belongs
description not; constructor behaves disjunction elements
10. original result submitted publication 1990. different, independent, proof
result since outlined (Lenzerini & Schaerf, 1991).

306

fiSubsumption CLASSIC

extensions individuals whose membership terms known priori, i.e., nonhost individuals. particular, show encode testing unsatisfiability
formula 3CNF question recognizing individual instance description.
Since problem known NP-hard, strong indication intractability.
Start formula F , 3CNF. Using DeMorgan's laws, construct formula G,
negation F , 3DNF. Testing validity G equivalent checking
unsatisfiability F .
Construct every propositional symbol p used F , two individual names P P^ .
(Here P^ represent negation p.) individual attribute truthValue,
possible fillers True False
P; P^ 2 8truthValue: fTrue Falseg:
make sure P P^ exactly one, opposite, truth values, create two
individual names, Yesp Nop, additional attributes approve deny respectively,
whose fillers need truth value True False respectively:
Yesp 2 8approve:(fP P^ g u 8truthValue: fTrueg)
Nop 2 8deny:(fP P^ g u 8truthValue: fFalseg)
Now, given formula G = C 1 _ C 2 _ : : : _ Cn, create individual names C1, C2,
: : : , Cn, role conjuncts containing propositions conjuncts.
example, C 1 = p ^ :q ^ :r
C1 2 8conjuncts: fP Q^ R^ g u 3 conjuncts:
Finally, construct individual G C1, C2, : : : , Cn possible fillers new role

disjunctsHolding :

G 2 8disjunctsHolding: fC1 C2 : : : Cng:

formula G valid iff always least one disjunct holds.
equivalent membership concept VALID-FORMULAE defined

1 disjunctsHolding u 8disjunctsHolding:(8conjuncts:(8truthValue:fTrueg)):
shows recognizing whether individuals instances descriptions
intractable presence set descriptions, minimum number restrictions, value
restrictions.
convert question concerning subsumption two descriptions
essentially making individuals involved attribute-fillers new dummy attributes,
descriptions restrictions attributes. description nonempty attribute values must satisfy corresponding restrictions.
So, define concept UPPER

8formula:VALID-FORMULAE
define concept LOWER
307

fiBorgida & Patel-Schneider

8dummy1-p:(fPg u [P 0s concept descriptor ]) u
8dummy2-p:(fP^g u [P^ 0s concept descriptor ]) u
8dummy3-p:(fYespg u : : :) u
8dummy4-p:(fNopg u : : :) u
:::
8dummy5-ci:(fCig u : : :) u
:::
8formula:(fGg u : : :)
database state either concept LOWER instances, case
subset extension UPPER, least one instance, case
individual names filling various dummy attributes must properties ascribed
them, whence C VALID-FORMULAE (and hence UPPER subsume LOWER) iff
C valid, completes proof.

308


