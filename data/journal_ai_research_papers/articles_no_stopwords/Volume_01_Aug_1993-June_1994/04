journal artificial intelligence

submitted published

diculties learning logic programs cut
francesco bergadano

bergadan di unito

daniele gunetti
umberto trinchero

gunetti di unito
trincher di unito

universita di catania dipartimento di matematica
via andrea doria catania italy
universita di torino dipartimento di informatica
corso svizzera torino italy

abstract

real logic programmers normally use cut effective learning procedure logic
programs able deal cut predicate procedural
meaning clauses containing cut cannot learned extensional evaluation method
done learning systems hand searching space possible
programs instead space independent clauses unfeasible alternative solution
generate first candidate base program covers positive examples
make consistent inserting cut appropriate learning programs
cut investigated seems natural reasonable
generalize scheme investigate diculties arise
major shortcomings actually caused general need intensional evaluation
conclusion analysis suggests precise technical grounds
learning cut dicult current induction techniques probably restricted
purely declarative logic languages

introduction

much recent ai machine learning addressing learning
relations examples especially title inductive logic programming muggleton one goal line although certainly one
inductive synthesis logic programs generally interested construction
program development tools machine learning techniques techniques
include ecient induction logical descriptions recursive relations
however real logic programs contain features purely logical notably
cut predicate learning programs cut studied
inductive logic programming analyzes diculties involved

learn programs cut

two main motivations learning logic programs cut
ilp provide practical tools developing logic programs context
general program development methodology e g bergadano b real
size logic programs normally contain cut learning cut important creating
integrated software engineering framework

c ai access foundation morgan kaufmann publishers rights reserved

fibergadano gunetti trinchero

extensive use cut make programs sensibly shorter diculty learning
given logic program much related length
objectives need cuts make programs
ecient without changing input output behavior green cuts cuts
eliminate possible computed red cuts red cuts sometimes considered
bad programming style often useful moreover red cuts effective
making programs shorter green cuts important less controversial
correct program inferred via inductive methods could made ecient
insertion green cuts manually means automated program
transformation techniques lau clement

standard approaches cannot used
machine learning generate rules clauses one time independently
rule useful covers positive example correct
cover negative example added description program
generated positive examples covered means searching
space possible clauses without backtracking obviously great advantage
programs sets clauses therefore space possible programs exponentially
larger
one principle allows simplification extensional
evaluation possible clauses used determine whether clause c covers example
e fact clause c covers example e used approximation
fact logic program containing c derives e consider instance clause c
p x suppose example e p b order see whether c covers e
extensionality principle makes us evaluate literal true matches
given positive example instance q x z p z example p b
extensionally covered iff ground term c q c p c b given
positive examples particular order obtain truth value p c b
need call clauses learned previously reason determining
whether c covers e depends c positive examples therefore learning
system decide whether accept c part final program p independently
clauses p contain
extensionality principle found foil quinlan derivatives
used bottom methods golem muggleton feng shapiro mis
system shapiro uses refining clauses although backtracing
inconsistencies used extensional evaluation clauses filp system
bergadano gunetti
learning programs cut clauses longer independent standalone extensional evaluation meaningless cut predicate evaluated possible clauses proving goal ignored changes meaning
clauses even clause extensionally covers example e may case
final program derive e derivation paths eliminated
evaluation cut predicate


fithe difficulties learning logic programs cut

however exhaustive search space programs prohibitive learning methods
even extensionality often considered inecient sucient prior information
available searching sets clauses exponentially worse would amount
brute force enumeration possible logic programs containing cut program
consistent given examples found

alternative method

cut eliminate computed e adding cut program
may case example longer derived observation suggests general
learning strategy base program p induced standard techniques given positive
maybe negative examples remaining negative examples ruled
inserting cut clause p obviously inserting cut must make sure
positive examples may still derived
given present technology discussion seems viable
path possible solution standard techniques base program p would generated one clause time positive examples extensionally covered however
think view restrictive programs derive given positive
examples although cover extensionally bergadano deraedt
lavrac dzeroski generally consider traces positive examples

definition given hypothesis space possible clauses example e


e set clauses ts used derivation e called trace e

use candidate base program p subset union
traces positive examples ps extensionally covers positive examples
union traces converse true candidate
program generated attempt made insert cuts negative examples
derived successful solution otherwise backtrack another
candidate base program analyze many inherent learning cut
class trace learning methods discuss later section
need faced restrictive framework extensional evaluation
words even choose learn base program p extensionally
try make consistent cut computational would still arise
main difference standard approaches extensionality allow
backtracking guarantee correct solution found bergadano
far computational complexity concerned trace methods complexity
standing search space independent clauses extensional methods
exhaustive search space possible programs need following

definition given hypothesis space depth example e maximum

number clauses successfully used derivation e

example list processing domain contains recursive calls
type p hjt p depth example p l length l
practical program induction tasks often case depth example


fibergadano gunetti trinchero

related complexity hypothesis space maximum depth
given positive examples complexity trace methods order
js jmd extensional methods enumerate possible clauses complexity
linear js j enumerating possible programs exponential js j

simple induction procedure
trace induction procedure analyze takes input finite set clauses
set positive negative examples e e tries subset
derives positive examples none negative examples every
positive example e e assume large enough derive moreover
assume clauses attened case clauses attened
preprocessing step
consider one possible proof e build intermediate program
containing trace derivation done positive examples
corresponding traces merged every time updated checked
negative examples derived cut inserted antecedents
clauses consistent program found exists case
procedure backtracks different proof e informally
described follows
input set clauses
set positive examples e
set negative examples es atten

positive example e e
sld e backtracking point

derives negative example e trycut e
trycut e fails backtrack
output clauses listed
trycut e
insert somewhere backtracking point
previously covered positive examples still derived
sld e

complexity adding cut somewhere trace negative example eis longer derived obviously depends size size depends
depth positive examples size hypothesis space although
clause flattened contain functional symbol given un attened clause alway
possible atten turning functions predicates additional argument representing
function vice versa rouveirol press



fithe difficulties learning logic programs cut

clever ways devised particular example e propose
simple enumerative technique implementation described appendix

example simplifying list

section example use induction procedure learn logic
program simplify simplify takes input list whose members may lists
transforms attened list single members containing repetitions
lists members program appears exercise number coelho cotta
composed nine clauses plus clauses append member six
recursive one doubly recursive cut extensively used even simplify
complex logic program complex usual ilp test cases instance
quicksort partition program often used composed five
clauses plus append three recursive moreover note
conciseness simplify essentially due extensive use cut without cut
program would much longer general longer logic program dicult
learn
consequence start relatively strong bias suppose following
hypothesis space n possible clauses defined user



clause simplify l nl atten l l remove l nl
clauses whose head atten x l whose body composed conjunction
following literals
head x h tail x l equal x l null null h null l equal x l
atten h x atten l x
append x x l assign x l assign x l list x l



clauses whose head remove il ol whose body composed conjunction following literals
cons x n ol null il assign ol
head il x tail il l member x l remove l ol remove l n



correct clauses null head tail equal assign member append given
null
head hj h
tail jt
equal x x
assign x x
member x xj
member x jt member x


fibergadano gunetti trinchero

append z z
append hjx hjz append x z
kinds constraints initial number clauses strongly reduced
possible constraints following
output produced must instantiated means
variable cannot occur output antecedent
inputs must used input variables head clause must occur
antecedent
conjunctions literals ruled never true e g
null il head il x
applying combination constraints possible strongly restrict
initial hypothesis space given input learning procedure set
positive negative examples used learning task
simplify pos b b remove pos
simplify neg b x equal x b
simplify neg b b remove neg
note define negative examples simplify examples
input given positive example different output instance simplify neg b b obviously possible give negative examples
normal ground literals learning procedure outputs program simplify reported
turns substantially equivalent one described coelho
cotta kept clauses un attened
simplify l nl atten l l remove l nl
atten x l equal x l null atten l x assign x l
atten x l head x h tail x l null h atten l x assign x l
atten x l equal x l atten l x assign x l
atten x l head x h tail x l
atten h x atten l x append x x l
atten x l list x l
remove il ol head il x tail il l member x l remove l ol
remove il ol head il x tail il l remove l n cons x n ol
remove il ol null il assign ol
learning task takes seconds implementation however obtained
special conditions thoroughly discussed next sections
constraints listed applied final hypothesis space
reduced less one hundred clauses


fithe difficulties learning logic programs cut





clauses hypothesis space generated correct order must appear
final program moreover literals clause correct position
important since logic program cut relative position clauses
literals significant consequence learn simplify without test
different clause literal orderings see subsections
tell learning procedure use two cuts per clause seems
quite intuitive constraint since fact many classical logic programs
one cut per clause see subsections



experiments induction procedure shown many arise
learning logic programs containing cut following analyze
major contribution present cut cannot evaluated extensionally
analysis general depend specific induction method adopted
possible partial solutions discussed section

intensional evaluation backtracking cut

learning procedure section simple inecient however
believe common every intensional method clauses cannot learned
independently one another consequence backtracking cannot avoided
impact complexity learning process moreover cut must
added every trace covering negative examples constraints force
range one cut whole trace cut two literals clause
trace clearly number possibilities exponential number literals
trace fortunately number usually much smaller size hypothesis
space depends depth positive examples
however backtracking advantages particular useful search
alternative solutions alternative programs confronted basis
required characteristic simplicity eciency example backtracking
discovered version simplify equivalent one given without cut predicate
two recursive calls fourth clause flatten

ordering clauses trace

logic program containing cut mutual position clauses significant different ordering lead different perhaps wrong behavior program example
following program intersection

c int x null x null
c int x head x h tail x tail member h int tail cons h
c int x head x h tail x tail int tail
behaves correctly c comes c suppose hypothesis space given input
induction procedure consists three clauses c


fibergadano gunetti trinchero

c int given negative example learning task fails
clauses c c derive example

words learning program containing cut means learn set
clauses specific ordering clauses terms induction procedure
means every trace covering negative example must check
every position inserting cuts every possible clause ordering trace
generate test behavior dicult implement dramatically decrease
performance learning task worst case possible permutations must
generated checked requires time proportional md trace md
clauses
necessity test different permutations clauses trace primary source
ineciency learning programs cut probably dicult
solve

kinds given examples

induction procedure able learn programs traces e every
clause program used derive least one positive example learning definite
clauses derivation monotone every program p
complete consistent w r given examples program p p
complete consistent trace hand learning clauses containing cut may happen complete consistent program hypothesis
space neither trace contains subset derivation longer
monotone case negative example derived set clauses
superset following simple example
fsum b c sum b n c n
sum b c c b g
sum pos sum neg
two clauses hypothesis space represent complete consistent program
given examples procedure unable learn observe negative
example derived second clause trace positive example
first second together
avoided require every negative example corresponding positive example input given case example
required sum pos way complete program exists hypothesis
space trace learned made consistent
cut order rule derivation negative examples constraint positive
negative examples seems quite intuitive fact writing program
must noted learning programs two different predicates j k clauses
respectively md j k consider j k different programs
j k better inside program known non recursive clauses fixed
position put recursive clauses
learned program p complete derives given positive examples consistent
derive given negative examples



fithe difficulties learning logic programs cut

programmer usually thinks terms program compute given inputs
tries avoid wrong computations inputs

ordering given examples
learning clauses cut even order positive examples may significant
example sum pos comes sum pos learning task
fails learn correct program sum cannot program consistent w r
first positive example negative one
general given set positive examples remedied
testing different example orderings worst case k different orderings set
k positive examples must checked moreover situations favorable ordering
exist consider following hypothesis space

c int x w head x tail x b notmember int b w
c int x w head x tail x b notmember int b w
c int x z head x tail x b int b w cons w z
c int x z head x tail x b int b w cons w z
c int x z null z
together set examples

e int pos b
e int pos
e int neg b
e int neg
induction procedure able correct program ordering
two positive examples even program exist c c c program
union two traces c c covers e c c covers e traces
inconsistent first covers e second covers e
remedied positive examples derived check negative
examples done
however case loss eciency inconsistent
traces discarded end words would need learn program
covering positive examples make consistent cut reordering clauses moreover way make program consistent cut
reorderings consequence time used build program wasted
example suppose given following hypothesis space

c int x z head x tail x b int b w cons w z
c int x z null x null z
c int x z null z


fibergadano gunetti trinchero

examples

e int pos
e int pos b c
e int neg b
learn trace c c e trace c e c c c covers
e way make consistent cut reordering clauses fact
first partial trace responsible inconsistency hence time used learn
c totally wasted
possible understand need attened clauses consider following program intersection equivalent c c c three clauses
un attened

u int ajb w notmember int b w
u int ajb ajw int b w
u int
program covers int neg e u u u int fact clause
u fails example member clause u fails empty
list cannot matched ajw clause u succeeds arguments match
negative example consequence program would rejected
induction procedure
use un attened clauses may happen clause body
evaluated example match head clause consequence
possible cuts clause evaluated cannot uence behavior entire
program example cut clause u effect output argument
int match ajw body u evaluated u
fired negative example covered attened version clause c fails
cons reached point cut force clause c cannot activated
note program u u u behaves correctly query int x gives x
output

ordering literals

even relative position literals cut clause significant consider
correct program intersection c c c c modified putting
cons literal front antecedent

c int x z cons w z head x tail x b int b w
way get correct program intersection clause rule
negative example int neg must put cut cons predicate
order prevent activation c positive examples longer
covered int pos fact wrong behavior every time clause c


fithe difficulties learning logic programs cut

called fails since prevents activation c general cannot
avoided even reordering clauses put c c c int neg
covered consequence test every possible permutation literals
every clause candidate program

situations learning cut still practical
analysis learning cut appears dicult since general learning
procedure able backtrack candidate base programs e g traces
position cut program order clauses program
order literals clauses order given positive examples however
spotted general conditions learning cut could still practical clearly
conditions cannot final solution learning cut applicable alleviate
computational task

small hypothesis space

first restricted hypothesis space necessary clauses cannot learned independently one another small hypothesis space would help limit backtracking
required candidate traces moreover even number clauses trace
would probably smaller hence number different permutations
number different positions inserted cuts small trace would
slight positive impact need test different literal orderings clauses

general many kinds constraints applied keep hypothesis space small
ij determinism muggleton feng rule sets schemata kietz wrobel
bergadano gunetti determinations russell locality cohen
etc fact restrictions others listed section
available actual implementation procedure see appendix moreover
candidate recursive clauses must designed infinite chains recursive calls
take place bergadano gunetti otherwise learning task could
non terminating general number possible recursive calls must kept small
order avoid much backtracking searching possible traces however general
constraints may sucient hypothesis space must designed carefully
beginning dicult example learning simplify initial
hypothesis space clauses obtained specifying set required
predicates even variables occurring every literal
clauses cannot learned independently experiments shown us dramatic improvement learning task obtained generating clauses
hypothesis space recursive clauses general complex clauses taken
consideration simpler non recursive ones since simpler non recursive
clauses require less time evaluated small impact learning time
moreover learning simpler clauses e shorter alleviates
found constraints particularly useful often able restrict hypothesis
space one order magnitude without ruling possible solution



fibergadano gunetti trinchero

finally must noted induction procedure necessarily require
hypothesis space possible clauses represented explicitly learning task could
start empty set implicit description hypothesis space example
one given section positive example cannot derived clause
asked clause generator added step repeated example
derivable updated learning task proceed normally

simple examples

another improvement achieved examples simple possible
fact example may involve recursive call potentially responsible
activation corresponding clauses hypothesis space complex
example larger number consecutive recursive activations clauses larger
number traces considered backtracking instance learn
append relation may sucient use example append b b instead
one append b c b b c b since simple examples would probably require
smaller number different clauses derived would smaller traces
alleviating permutation clauses literals trace
decreasing number positions cuts

small number examples

since candidate program formed taking union partial traces learned single
examples want small trace must use examples
possible still completely describing required concept words
avoid redundant information example want learn program append
normally sucient use one two positive examples append b b
append c c obviously may happen different examples derived
set clauses case final program change
check possible orderings set positive examples small number
examples solution fortunately experiments shown normally
positive examples needed learn program hence corresponding
number different orderings case small number moreover since
method positive example sucient learn clauses necessary derive
time complete program learned one well chosen example
example found case learning task section one
example simplify one remove given computational testing
different example orderings automatically solved
however must noted general small number examples may
sucient except simple programs fact want learn logic programs
member append reverse example involving recursion
sucient complex programs choice may trivial example
procedure able learn quicksort plus partition program one good
example one know quicksort partition work likely
provide example allowing learn partial description partition
particularly clear example simplify used positive example


fithe difficulties learning logic programs cut

simplify pos b b close one effectively used first clause
flatten would learned words give examples must give
good examples often possible mind least partially
informal way target program moreover complex programs good examples
mean complex examples contrast previous requirement
studies learning good examples refer reader work ling
aha ling matwin lapointe

constrained positions cut literals

experiments shown practical allow learning procedure test
possible positions cut trace even able keep number clauses
trace small user must able indicate positions cut allowed
occur e g beginning clause body recursive call case many
alternative programs cut automatically ruled thus tested
negative examples may useful limit maximum number cuts
per clause per trace example time one cut per clause sucient
learn correct program actual implementation procedure fact
possible specify exact position cut w r literal group literals within
clause hypothesis space information known
eliminate need test different ordering literals may
impose particular global order must maintained every clause hypothesis
space however requires deep knowledge program want otherwise
even solutions lost moreover solution contrast use
constrained positions cut since solution program particular literal ordering
particular positions cuts may exist

conclusion

induction procedure intensional evaluation clauses since cut
predicate declarative meaning believe intensional evaluation clauses
cannot abandoned independently kind learning method adopted
decrease performance learning task compared extensional methods
examine clauses one time without backtracking however computational
outlined section remain even choose learn complete program extensionally
try make consistent inserting cut difference
backtracking situation probably worse since extensional
methods fail learn complete program even exists hypothesis space
bergadano
even ability learn clauses containing procedural predicates cut seems
fundamental learning real logic programs particular short ecient programs
many uencing complexity learning task must faced include
number relative ordering clauses literals hypothesis space kind
relative ordering given examples seem related need
intensional evaluation clauses general particular learning method
adopted even alleviate seems necessary know lot


fibergadano gunetti trinchero

target program alternative solution simply ignore
avoid testing different clause literal example orderings clearly
way learning process become feasible fail solution even
exists however many ilp systems foil adopt incomplete fast
guided heuristic information
consequence view presented least partially negative raised appear computationally dicult suggest attention
restricted purely declarative logic languages case suciently
expressive

acknowledgements
work part supported bra esprit project inductive logic programming

appendix
induction procedure section written c prolog interpreted runs
sunsparcstation translate quintus prolog appendix
contains simplified description implementation preliminary step order
record trace clauses deriving positive example e every clause hypothesis
space must numbered modified adding body two literals first
one allowed n used activate clauses must checked
negative examples second one marker n used remember clause number n
successfully used deriving e hence general clause hypothesis
space takes following form

p x xm allowed n marker n
actual body clause n number clause set
number used deal cuts every clause n one without cut augmented
allowed n containing cut somewhere body augmented
allowed n allowed n moreover every augmented clause
fact alt n inserted order implement enumeration mechanism
simplified running version learning reported
output variable trace containing list numbers
clauses representing learned program p backtracking mechanism prolog
one solution trace found assume two predicates listpositive
listnegative build list given positive negative examples respectively
consult file containing set clauses
assume clauses hypothesis space attened



fithe difficulties learning logic programs cut

allowed x
marker x assert trace x
marker x retract trace x fail
main listpositive posexamplelist tracer posexamplelist trace
tracer covered examplejcdr trace example backtracking point
setof l trace l trace
notneg trace examplejcovered cdr
tracer examplejcovered cdr trace
tracer trace setof j allowed j trace asserta marker x true
assertem
assertem ijcdr alt j backassert allowed j assertem cdr
prep retract allowed x assertem
backassert x assert x
backassert x retract x fail
resetallowed
resetallowed abolish allowed assert allowed x
notneg covered remaining listnegative
notneg covered remaining listnegative negexamplelist
asserta marker x true
prep backtracking point
trypos covered trynegs negexamplelist
resetallowed remaining
retract marker x true
notneg covered remaining resetallowed remaining
retract marker x true fail
trypos examplejcdr example trypos cdr
trypos
trynegs examplejcdr example fail
trynegs examplejcdr trynegs cdr
trynegs
actually complete implementation complex order achieve greater
eciency behavior learning task quite simple initially set clauses
read prolog interpreter together learning learning
task started calling predicate main list positive examples formed


fibergadano gunetti trinchero

tracer procedure called list every positive example tracer calls
example firing clauses may resolved example
observe initially allowed x predicate asserted database way
clauses containing cut allowed used clauses cut
employed negative example derived trace numbers
associated clauses successfully used derivation example built
setof predicate
trace added traces found previous examples
checked set negative examples calling notneg procedure notneg
fail e negative examples covered trace positive
example taken consideration otherwise notneg modifies trace cut
tests fails backtracking occurs trace current example
possibly previous ones searched
notneg procedure works follows first clauses trace allowed
checked negative examples retracting allowed x clause
asserting allowed n n th clause without cut trace done
prep assertem predicates list negative examples formed
check derived clauses trace least one negative example
covered e trynegs fails backtrack prep procedure backtracking point
clause trace substituted equivalent one cut inserted
somewhere different position correct program found way
trying possible alternatives e cut possible ways notneg fails
backtracking backtracking point occurs another trace searched otherwise
clauses without cut reactivated asserting allowed x next
positive example considered note trypos used notneg verify modified
trace still derives set positive examples derived initially possibility substitute
clauses current trace others cut inserted somewhere achieved
alt predicate assertem procedure finally note simplified version
learning procedure able generate test different orderings clauses
trace different ordering literals clause use different orderings
set positive examples
order derive positive examples check negative ones
see subsection must change first clause tracer procedure
tracer pos posn pos posn setof l trace l notneg
actual implementation induction procedure available ftp
information contact gunetti di unito

references

aha ling c matwin lapointe learning singly recursive relations
small datasets proceedings ijcai workshop ilp
bergadano f inductive database relations ieee transactions data
knowledge engineering


fithe difficulties learning logic programs cut

bergadano f b test case generation means learning techniques proceedings acm sigsoft
bergadano f gunetti interactive system learn functional logic programs proceedings ijcai
coelho h cotta j c prolog example learn teach use berlin
springer verlag
cohen w rapid prototyping ilp systems explicit bias proceedings
ijcai workshop ilp
deraedt l lavrac n dzeroski multiple predicate learning proceedings
ijcai
kietz j u wrobel controlling complexity learning logic
syntactic task oriented muggleton ed inductive logic programming london academic press
lau k k clement eds logic program synthesis transformation
berlin springer verlag
ling x c learning good examples proceedings ijcai
muggleton ed inductive logic programming london academic press
muggleton feng c ecient induction logic programs proceedings
first conference algorithmic learning theory
quinlan r learning logical definitions relations machine learning

rouveirol c press flattening representation change generalization machine
learning
russell tree structured bias proceedings aaai
shapiro e algorithmic program debugging cambridge ca mit press




