journal artificial intelligence

submitted published

semantics complete
subsumption classic description logic
alex borgida

borgida cs rutgers edu

department computer science
rutgers university
brunswick nj u

peter f patel schneider

pfps att com

bell laboratories
mountain avenue
murray hill nj u

abstract

analyzes correctness subsumption used classic
description logic knowledge representation system used practical
applications order deal eciently individuals classic descriptions developers use incomplete respect standard
model theoretic semantics description logics provide variant semantics descriptions respect current implementation complete
independently motivated soundness completeness polynomial time subsumption established description graphs abstracted version
implementation structures used classic independent interest

introduction description logics

data knowledge bases part natural world
often built individual objects inter related relationships grouped
classes capture commonalities among instances description logics dls
known terminological logics form class languages used build access
distinguishing feature classes usually called concepts defined
intensionally terms descriptions specify properties objects must satisfy
belong concept descriptions expressed language allows
construction composite descriptions including restrictions binary relationships
usually called roles connecting objects
example consider description
game u participants u participants person u gender female
description characterizes objects intersection u three sub descriptions
game objects belong atomic concept participants objects least
four fillers participants role participants person u gender female objects
whose participants fillers restricted belong persons
gender role filled value female
notation used descriptions standard notation description logic community
baader et al classic notation used verbose

c ai access foundation morgan kaufmann publishers rights reserved

fiborgida patel schneider

key difference dls standard representation formalisms
first order logic e g relational deductive databases dls provide arena
exploring sets logical connectives constructors used form composite
descriptions different standard connectives conjunction universal
quantifiers etc therefore dls provide space search expressive
yet effectively computable representation languages moreover although possible
translate many aspects dls currently encountered first order logic reasoning
translation would poor substitute dl systems reason
way resemble standard theorem proving e g making use imperative
programming features
descriptions one used several ways knowledge base
management system kbms description logic
state queries kbms locate objects satisfy description
properties
define classify concepts identifiers attached descriptions manner views relational dbmss system addition automatically determine
subclass relationship pairs concepts definitions
example concept defined description would subsumed
concept defined games least two participants game u participants
provide partial information objects important understand distinct dl descriptions ascribed arbitrary individuals e g today game
cards individual bgm exactly two participants following
set three tea rum note unlike database systems dl kbmss require descriptions predefined provides
considerable power recording partial knowledge objects
detect errors possible determine whether two descriptions disjoint
whether description incoherent whether ascribing description
individual leads inconsistency
quite number kbmss description logics built including classic
resnick et al loom macgregor bates back peltason et al
systems used several practical situations including software information
bases devanbu et al financial management mays et al configuration management owsnicki klewe wright et al data exploration additional
signs dls significant subjects study several recent workshops dls
nebel et al peltason et al aaai

tractability completeness dl implementations

fundamental operation descriptions determining whether one description
general subsumes another sense object satisfying latter would
satisfy conditions former parallel surge work finding tractable
yet expressive subsets first order logic dl community investigating
complexity reasoning constructors first area levesque


fisubsumption classic

brachman showed even seemingly simple addition small language
lead subsumption determination becoming np hard recent striking pair
patel schneider b schmidt schauss shows adding ability
represent equalities role compositions makes complexity subsumption
leap quadratic undecidable
three possible responses intractability
provide incomplete implementation dl reasoner sense
inferences sanctioned standard semantics constructors
performed explicitly adopted loom system
implementers macgregor bates advocated users doyle
patil one major diculty one describe users inferences
actually drawn implementation systems known properties
implemented top kbms two solutions suggested alternative semantic accounts weaker valued logics example
patel schneider proof theoretic semantics borgida
provide complete implementation specific dl reasoner acknowledging
certain circumstances may take inordinate amount time
followed systems kris baader hollunder
unpredictability system go wild blue yonder
course circumstances impossible even attempt since reasoning
undecidable
carefully devise language limited expressive power reasoning tractable
provide complete implementation chosen
designers languages kandor patel schneider krypton
brachman et al close classic borgida et al

hidden diculty second third produce implementation
correct complete respect semantics diculty illustrated
discovery several years later implementation kandor well candide
beck et al fact incomplete subsumption np hard nebel
rather polynomial claimed happened despite fact kandor
small language comparison dls implementation appeared
evidently correct avoid necessary produce convincing
demonstrations correct several proofs fact already appeared dl literature e g patel schneider hollunder nutt donini
et al albeit languages seen use practical applications

outline

classic system reasoner moderately complicated dl
used commercial wright et al prototype applications made
available academic researchers bell laboratories
classic first released version classic version classic expressive dl
recently released



fiborgida patel schneider

one purpose provide rigorous formal analysis correctness
eciency classic dl subsumption start presenting
subset language call basic classic subsumption
relies transformation descriptions data structure call
description graphs generalization kaci psi terms
process normalizing graph canonical form remove obvious redundancies
explicate certain implicit facts encoding particular infinite set inferences
drawn called coreference constraints correctness subsumption
demonstrated rigorously showing construct inductively countermodel case returns answer
next explore effect adding individuals descriptions
individuals one encode disjunctive information leading need examine combinatorially many possibilities classic implementation fact incomplete respect
standard semantics second contribution well motivated
understandable small change standard semantics alleviates
extend subsumption proof correctness deal individuals
modified semantics thereby characterizing sense incompleteness
reasoner
therefore illustrates three paradigms described albeit nonstandard manner second paradigm first time realistic
language significant practical use

basic classic
descriptions basic classic built collection atomic concept names role
names attribute names roles attributes atomic descriptions
built operators constructors value restrictions number restrictions
indicate
basic classic incorporates objects host programming language called host
individuals form distinct group classic individuals latter
roles attributes former restricted role attribute fillers
denotational semantics classic descriptions starts usual domain
values subsets extensions descriptions subsets
extensions roles attributes domain fact disjointly divided two realms
host realm h containing objects corresponding host language individuals
classic realm c containing objects every description except thing
denotes entire domain extension subset classic realm
host realm nothing denotes empty set therefore classic host
concept extension role possible world relation classic realm
entire domain extension attribute function classic realm
entire domain
empirical tests heinsohn et al classic emerged fastest current dl
implementations
general scheme incorporating host objects described baader hanschke



fisubsumption classic

host descriptions relatively simple host thing denoting entire host realm
h ii special pre defined names corresponding types host programming language iii conjunctions descriptions descriptions corresponding
host programming language types pre defined extensions subsumption relationships mirroring subtype relationship host programming language
subtype relationship satisfied possible worlds interpretations require
host concepts extension infinite size empty ii
extensions two host concepts overlap one must subsumed e
types disjoint unless subtypes iii host concept
infinite number extra instances child concepts conditions
needed avoid able infer conclusions size host descriptions
allows host concepts integer real complex string boolean
non zero integer
non host classic descriptions basic classic formed according following
syntax
syntax
constructor name
classic thing
e
atomic concept name
cud
intersection
r c
role value restriction
c
attribute value restriction
n r
minimum number restriction
r
maximum number restriction
ak b bh equality restriction
e atomic concept name c classic descriptions r role ai
bj attributes n k h positive integers non negative integer set
constructors basic classic judiciously chosen language
subsumption easy compute
denotational semantics descriptions basic classic recursively built
extensions assigned atomic names possible world
definition possible world interpretation consists domain interpretation function domain disjointly divided classic realm c host
realm h interpretation function assigns extensions atomic identifiers follows
extension atomic concept name e subset ei classic realm
extension atomic role name r subset ri c
extension atomic attribute name total function ai c

extension ci non atomic classic description computed follows
classic thingi c
c u ci di


fiborgida patel schneider

p c fd c j x x pi x ci g e objects c
whose p role p attribute fillers extension c

n p resp n p objects c least resp n fillers
role p

ak b bh fd c j ak bhi b g e

objects c property applying composition extension
ai composition extension bj object
value

description said subsume another possible worlds


key interest computation subsumption relationship descriptions
basic classic subsumption computation multi part process first descriptions
turned description graphs next description graphs put canonical form
certain inferences explicated redundancies reduced combining
nodes edges graph finally subsumption determined description
canonical description graph
describe detail process start formal definition notion
description graph definition present techniques

translating description description graph section requires merging
pairs nodes pairs graphs definitions

putting description graph canonical form section
determining whether description subsumes description graph
prove correctness need first two steps
lead us right direction e following three questions equivalent
description subsume description c description subsume graph gc
description subsume graph canonical gc need define
formal semantics descriptions graphs definitions prove
theorems prove completeness subsumption
indicate subsumes canonical gc
construct interpretation graphical world object denotation
canonical gc

description graphs

one way developing subsumption first transform descriptions
canonical form determine subsumption relationships canonical
descriptions normally thought trees since descriptions terms first order
term language presence equality restrictions classic significantly changes
note attribute chains must definite value last cannot evaluate
host individuals since cannot attributes



fisubsumption classic

fclassic thing
g


fthing
g











captain
coach






participants fpersong




fgameg

father



figure description graph
handling subsumption introduce relationships different pieces
normal form significantly presence equalities small description
friend tall u friend friendfriend subsumed descriptions arbitrary size

friend friend friend tall
order record sets inferences canonical form resort graphbased representation suggested semantic network origins description logics
work kaci
intuitively description graph labelled directed multigraph distinguished
node nodes graph correspond descriptions edges graph correspond
restrictions roles attributes edges graph labelled role name
minimum maximum number fillers associated edge
attribute name nodes graph labelled concept names associated
node concept example figure description graph shall see later
corresponds description game u participants person u coach captainfather
equality restrictions hence non tree portions graph involve
attributes edges labelled roles cut edges e removal increases one
number connected components graph restriction important
graph tree form really difference graphical linear notation
semantics simple develop graph general directed acyclic graph
relating semantics generated two different paths
graph share beginning ending nodes graph contains cycles
developing correct semantics even dicult simplistic semantics
non well founded sort fixed point model preference semantics
required fortunately non tree parts graphical notation involve attributes
attributes functional job much easier
restrictions possible view description graph
following recursive structure distinguished node r island
nodes connected edges labelled attributes ii nodes island may
edges labelled roles leaving pointing distinguished nodes
description graphs iii graphs share nodes edges common
islands


fiborgida patel schneider

recursive structure easier represent description graphs
recursive definition instead usual graph definition recursive definition similar
recursive definition tree states tree consists information
information root tree plus set trees children root
tree description graphs complex simple trees use
two part definition

definition description graph triple hn e ri consisting set n nodes

bag e edges edges labelled attribute names distinguished node r n
elements e written hn n ai n n nodes attribute
name
node description graph pair hc h consisting set c concept names
atoms node bag h tuples r edges node r edge
tuple hr gi role name r min non negative integer max
non negative integer recursively nested description graph g
representing restriction fillers role g often called restriction
graph node
concept names description graph atomic concept names host concept names
thing classic thing host thing

descriptions graphs provided extensions starting possible worlds
used descriptions however addition need way identifying individuals
related attributes given function

definition let g hn e ri description graph let possible world

interpretation gi g interpretation ni nodes n recursively mutually defined follows
element gi iff function n
r
n n n ni
hn n ai e h n n ai equivalent n
ai n since ai function
element ni n hc h iff
c c ci
hr gi h
elements domain hd ri

b gi hd ri


fisubsumption classic

translating descriptions description graphs

basic classic description turned description graph recursive process
working inside process description graphs nodes often
merged

definition merge two nodes n n node whose atoms union

atoms two nodes whose r edges union r edges two
nodes

definition merge two description graphs g g description graph whose

nodes disjoint union non distinguished nodes g g plus
distinguished node edges merged graph union edges g g
except edges touching distinguished nodes g g modified touch
distinguished node distinguished node merge two distinguished
nodes g g

rules translating description c basic classic description graph gc
follows
description consists concept name turned description graph
one node edges atoms node contains concept name
node r edges
description form n r turned description graph one node
edges node atoms classic thing single r edge
role r min n max restriction gthing
description form n r turned description graph one node
edges node atoms classic thing single r edge role
r min max n restriction gthing
description form r c r role turned description graph
one node edges node atoms classic thing single
r edge role r min max restriction gc
turn description form c u description graph construct gc
gd merge
turn description form c attribute description graph
first construct description graph hnc ec rc c description graph
c hnc ftg ec fht rc aig ti node hfclassic thingg fgi
turn description form b bm description graph
first create distinguished node node r classic thing atoms
node e thing atoms n create node ai atoms
note duplicate edges ones joining ni ni removed since edges form bag
taking disjoint union two sets elements one may systematically renamed first make
sure sets non overlapping



fiborgida patel schneider

classic thing j create node bj atoms
classic thing none ai bj r edges
n create edge hr e n create edges hr han e
hai ai ai n
similarly create edge hr e b create edges hr b b
hbm e bmi hbi bi bii
creates two disjoint paths one ai one bj distinguished node end node
figure presents view description graph constructed fashion
description game u participants person u coach captainfather
want process preserves extensions use merge
operations first work correctly

lemma n n nodes n n ni ni description
graphs
proof since components atoms r edges merged node obtained

unioning components respective nodes since interpretation node
intersection interpretation components obviously true
nodes
merging graphs difference root nodes replaced
merger edges well root element clearly
element conversely since take disjoint union nodes
two graphs mapping functions definition simply unioned
element element merged root node hence


theorem possible worlds extension description ex

tension description graph
proof proof structural induction descriptions
extension concept names cardinality restrictions restrictions roles
easily seen agree extension description graphs formed
lemma shows conjunction properly handled restrictions attributes
construction correct attributes functional
equalities b bm construction forms description graph
two disjoint paths distinguished node end node one labelled ai
nodes ai labelled bj nodes bj

b bm fd c j ak bh b g
defining ai ai bj bj b g yields mapping

required definition converse satisfied requirement definition
edge hn n ai e n ai n


fisubsumption classic

canonical description graphs

following sections occasionally refer marking node incoherent
consists replacing special node outgoing r edges including
atoms nothing empty interpretation marking description
graph incoherent consists replacing description graph consisting
incoherent node incoherent graphs thought representing concepts
empty extension
description graphs transformed canonical form repeating following normalization steps whenever possible description graph descendants
node atoms pre defined host concept add host thing
atoms node atomic concept name atoms add classic thing
atoms pre defined host concept atoms node add
general pre defined host concepts atoms
node host thing classic thing atoms mark
node incoherent node atoms pair host concepts
related pre defined subsumption relationship mark node incoherent since
intersection empty
node description graph marked incoherent mark description graph
incoherent reason even node root attributes must value
value cannot belong empty set
r edge node min greater max mark node incoherent
r edge node description graph marked incoherent change max
reason cannot fillers belong empty set
r edge node max mark description graph incoherent
reason normalization step records equivalence r r nothing
used infer concept r c arbitrary c subsumes r
node two r edges labelled role merge two edges
described
description graph two edges node labelled
attribute merge two edges
merge two r edges node identical roles replace one redge r edge role role maximum two mins min
minimum two maxs max merge two description graphs
restriction
merge two edges hn n ai hn n ai replace single edge
hn n ai n merging n n e n n n n n
n n addition replace n n n edges description graph


fiborgida patel schneider

need transformations canonical form change extension
graph main diculty showing two edge merging processes
change extension

lemma let g hn e ri description graph two mergeable edges let
g hn e r merging two edges gi g
proof let two edges hn n ai hn n ai node n n n
choose gi let function n domain satisfying conditions

extensions definition r n n
equal ai n let except n n n
satisfies definition part g replace n n n everywhere
moreover n n ni ni lemma equals n n part
satisfied since n n n finally root modified merger e n
n r say n n n part definition satisfied
conversely given arbitrary g let function stipulated definition
r let except n n n n
argument traversed reverse verify satisfies definition
gi

lemma let n node two mergeable r edges let n node

edges merged ni n
proof let two r edges hr g hr g
let ni elements domain
hd ri therefore maximum
minimum elements domain hd ri
hd ri gi gi therefore hd ri gi gi
equals g g lemma thus n
let n maximum minimum
elements domain hd ri therefore
elements domain hd ri
hd ri g g gi gi therefore hd ri
gi gi therefore ni

dealt issue merging return desired showing
normalization affect meaning description graphs

theorem possible worlds extension canonical form description

graph g resulting basic classic description extension
description
proof steps justified since gi subset h c
disjoint
step justified fact definition description graphs must
element domain extension node description graph
steps easily derived definition
steps dealt preceding two lemmas


fisubsumption classic

subsumption
final part subsumption process checking see canonical description graph
subsumed description turns possible carry subsumption
test without expense normalizing candidate subsumer concept

subsumption given description description graph
g hn e ri subsumes g defined true following

conditions hold

description graph g marked incoherent
equivalent thing determined checking first thing
recursively testing whether subsumes canonical description graph gthing
concept name element atoms r
n r r edge r r role min greater equal n
n r r edge r r role max less equal n
r c r edge r r role g restriction graph
subsumes c g
r c subsumes c gthing r classic thing atoms reason r thing requires possibility r applicable object absent
host values
c edge g form hr r ai subsumes c hn e r
c subsumes c gthing r classic thing atoms
b bm paths b bm exist g
starting r end node
b bm bm paths
b bm exist g starting r end node
classic thing atoms reason aii bj b








aii bj b

attribute f long attribute applicable e value host
domain

c u e subsumes c g subsumes e g true


fiborgida patel schneider

correctness subsumption

soundness fairly obvious shall dwell completeness usual dicult establish first
canonical description graph node marked incoherent possible
world non empty extension description graph node constructed
constructive inductive manner constructing collection possible worlds called graphical worlds description graph graphical world
distinguished domain element extension description graph node
common operation merge two possible worlds
definition let two possible worlds merge
possible world classic realm disjoint union classic realm
classic realm extension atomic names disjoint union
extensions
easy extension description description graph node
union disjoint union classic realm regular union host realm
extensions
another operation add domain elements possible world domain
elements must classic realm extension atomic identifiers remain
except domain elements belong arbitrary set atomic concept
names arbitrary set fillers filler role attribute
easy domain element original world extension original
world iff extension augmented world
given node n marked incoherent construct graphical worlds
n follows
atoms n precisely thing n r edges
constructs cause r edges created add classic thing atoms
possible world domain element distinguished domain element
graphical world n
atoms n include host thing n r edges possible
world distinguished element domain element extension
atoms n host concepts graphical world n
requirements host domain infinite number domain
elements
atoms n include classic thing r edge hr gi n
construct graphical worlds g done number
g marked incoherent g
marked incoherent
two graphical worlds host domain element
distinguished element possible extension host concept
empty infinite merge graphical worlds r edge
one possible world add domain elements one exactly


fisubsumption classic

extensions atoms n fillers r exactly distinguished
elements appropriate graphical worlds domain element
correct number fillers r edge disjoint union classic
realms merge process different host domain elements picked
therefore extension n thus resulting world graphical
world n
given description graph g hn e ri marked incoherent construct
graphical worlds g follows node n n construct graphical world
n done none marked incoherent merge graphical
worlds modify resulting world hn n ai e filler
distinguished node graphical world n distinguished node graphical
world n easy distinguished node graphical world r
extension g making graphical world g
final part

theorem subsumption indicates canonical description
graph g subsumed basic classic description possible world
domain element extension graph extension
therefore g subsumed
proof proof actually shows subsumption indicates
canonical description graph g subsumed description
graphical worlds g distinguished domain elements
extension remember subsumption indicates g subsumed
g must marked incoherent thus graphical worlds g
proof proceeds structural induction let g hn e ri
atomic concept name pre defined host concept occur
atoms r construction graphical world g distinguished
domain element extension similarly classic thing
host thing distinguished domain elements wrong realm
thing possible subsumption indicate
non subsumption case graphical world g property
distinguished domain element extension

form u subsumption must indicate g

subsumed least one inductive hypothesis get
graphical worlds g distinguished domain elements
extension extension thus extension

form n r r edge r labelled r min less
n r edge
former case graphical worlds g distinguished node
n fillers r n greater min r edge r thus
distinguished node extension


fiborgida patel schneider

latter case graphical worlds g distinguished node
number fillers r n fillers property
distinguished node extension

form n r r edge r labelled r max greater
n including r edge
former case graphical worlds g distinguished node
n fillers r n less max r edge r thus
distinguished node extension
latter case graphical worlds g distinguished node
number fillers r n fillers property
distinguished node extension

form r c r role two cases arise
subsumes c gthing classic thing atoms r
graphical worlds g whose distinguished element host

realm thus extension
otherwise r edge r role r description graph h
subsumes c h false r edge r role r note
extension c entire domain thus must subset
host realm classic realm
former case h marked incoherent else subsumption could
false max r edge cannot thus graphical
worlds h whose distinguished element extension c
graphical worlds g use graphical worlds h distinguished
domain element r fillers graphical worlds g distinguished element extension
latter case pick graphical worlds g distinguished node
r filler wrong realm graphical worlds g distinguished
element extension

form c attribute two cases arise
subsumes c gthing classic thing atoms r
graphical worlds g whose distinguished element host
realm thus extension
otherwise edge r attribute node
r subsumes c h false h hn e r edge
r attribute note extension c entire domain
thus must subset host realm classic realm
former case h marked incoherent g marked incoherent thus graphical worlds h whose distinguished element
extension c given graphical world h graphical world
g formed simply changing distinguished domain element


fisubsumption classic

original graphical world distinguished element extension c
graphical world distinguished element extension
required
latter case pick graphical worlds g distinguished node
filler wrong realm graphical worlds g distinguished
element extension
form b bm several cases arise
one paths b bm exist g starting
r end partial path use graphical worlds
domain element node element host domain filler
next attribute path one full paths filler
paths b bm exist g starting r end
different nodes use graphical worlds domain elements
two nodes different
one paths b bm exist g starting
r paths b bm exist g starting r
end node classic thing atoms
node bm former case use graphical worlds domain
element node host realm latter case use graphical worlds
different fillers bm domain element node
one paths b bm exist g starting
r paths b bm exist g starting r
end different nodes use graphical worlds different fillers
domain elements nodes domain elements
host realm
cases one bmi b
exist bmi b distinguished domain element
extension

implementing subsumption

section provide comments actual subsumption
used classic system including rough analysis complexity
described deciding whether description c subsumes accomplished
three phases
convert description graph gd
normalize gd
verify whether c subsumes gd
step conversion accomplished simple recursive descent parser takes
advantage fact syntax description logics e leading term constructor makes amenable predictive parsing clearly constructing graphs fixed sized


fiborgida patel schneider

terms least constant time measure size integer size matter large time non recursive terms proportional
length finally recursive terms require fixed amount additional
work top recursive processing therefore first stage accomplished
time proportional size input description order speed later processing
useful maintain lists lists atomic concept identifiers
roles attributes sorted order sorting needs done initially later ordering
maintained performing list merges incurs worst case quadratic
overhead processing case total size graph constructed including
sizes nodes etc proportional size original concept description
step checking whether description c subsumes description graph gd
seen run time proportional size subsuming concept modulo cost
lookups lists since sorted lookup costs bounded
logarithm size candidate subsumee graph total cost bounded
j c j log j gd j
step normalization accomplished post order traversal description
graph processing description graph hn e ri node n normalized first independently see details afterwards attribute edges e normalized
later task involves identifying multiple identically labelled attribute edges leaving node
done one pass since attribute edges grouped source node sorted
attribute name merging merging two edges quite easy merging nodes tips must careful node mergers
may cascade example concept form b u b u u bn u
u u u original graph n nodes n
collapsed normalization step discover eciently use version
kaci unifying terms kaci kaci nasr
relies union technique identify nodes merged runs
time slightly linear number nodes n therefore cost
non recursive portion graph normalization roughly linear number nodes

merging two description graph nodes quite similar normalization
single node atomic concept identifier lists need sorted merged duplicates
eliminated done time proportional size nodes
make size node include size lists
atoms processing role edges leaving node one identifying merging
identically labelled edges case mergers labelled edges interact
single pass role edge list sucient cost non recursive aspects
merger proportional size local information
therefore left bounding total number procedure calls
normalizegraph normalizenode mergeedge mergenode bounding
sizes nodes merged
normalizegraph normalizenode called exactly every sub graph
node original graph part depth first traversal argued
tend use fancy sorting techniques since lists likely long



fisubsumption classic

contribute time proportional total size original graph
proportional size original description
number calls mergeedge mergenode simply bounded however
node may merged several times others however calls paired
invocation mergenode reduces number nodes graph one therefore since number nodes incremented elsewhere total number calls
mergeedge mergenode bounded number nodes original graph
non recursive cost call mergenode depends size
argument nodes call may increase size remaining node
sum sizes two original nodes
therefore original concept size graph n nodes size
vi worst case cost would iterative summation sizes
vi vi vi vi vi vi vi vi vi
n vi n vi vi
n

given n vj bounded
clearly worst case
p
fact given constraint j nvj possible argue worst case
cost occur vj every j e n case cost really

theoretical improvements could attempted
e g merging nodes correct order increasing size well analysis e g
nodes graphs depth tree merged
remark description logics classic permits identifiers associated complex descriptions identifiers used descriptions
though recursion allowed expansion identifiers standard operation
lead exponential growth size certain pathological cases nebel making
subsumption inherently intractable type system programming language standard ml pathological cases encountered practice
correct simple straightforward ecient normal cases unlike
correct reasoning set constructor say
users rarely ask whether concept subsumes another rather
interested relationship pairs concepts classic fact constructs
normalized description graph description given suggests might
better check whether one description graph subsumes another one rather checking
whether description subsumes graph general works quite well except
would verify attribute edges subsumer graph form subgraph
subsumee attribute edges since edges uniquely labelled normalization
inherently hard still requires complete traversal hence marking unmarking
upper graph therefore found useful encode part description
graph root restrictions lead construction corresponding aedges subsumption testing aspect subsumer related
checked list pairs
description tried optimize cost normalization dominates checking single subsumption overall use


fiborgida patel schneider

system e g processing individuals inquiries restrictions roles attributes
frequent space usage may practically advantageous
maintain r edges edges node hash table rather sorted list
order speed access note merging r edges one must however still
way iterating values stored hash table

individuals descriptions

practical applications dls used integrity constraint checking
often useful able specify ranges atomic values roles common
examples involve integers e g year student
called enumerated types pascal e g gender person f one way
allow constraints introduce description constructor set description
creates description list individual names whose obvious extension
set consisting extensions individuals appear list construct
could used terms year f g another useful constructor involving individuals
fills restriction p denotes objects extension individual
one fillers relationship denoted role attribute p note
attribute q q fig q
within paradigm dls constructors quite useful fact used
express forms incomplete information example know ringo
early fifties simply assert ringo described age f g
constructors used ask useful queries example
male persons suces determine instances gender
constructors interact previous ones cardinality constraints
clearly size set upper cardinality bound role restricts interaction
problematic long individuals set host values since individuals
properties fixed known ahead time however allow classic
individuals members sets properties individuals might
affect subsumption simple example know ringo instance
concept rock singer shall write ringo rock singer extension
friends rock singer superset extension friends fringog
disturbing classification hierarchy definitions would change
facts individuals added knowledge base definitions meant
contingent facts current world therefore subsumption usually defined
independent contingent assertions shall see use individual
properties description subsumption leads intractability

complex subsumption reasoning example

traditional proofs intractability e g levesque brachman occasionally
left users dls puzzled intuitive aspects language make reasoning
dicult reason present example illustrates complexity reasoning
set description
suppose concept jaded person one wants
visit arctic antarctic wherever penguins


fisubsumption classic

jaded person wantstovisit farctic antarcticg u haspenguins fyesg

suppose remember arctic antarctic know
south pole located one two places penguins
north pole located one two places penguins
assuming islocatedin haspenguins attributes roles exactly one filler
record
southpole islocatedin farctic antarcticg u haspenguins fyesg
northpole islocatedin farctic antarcticg u haspenguins fnog

thus unable distinguish exact location southpole northpole however
since haspenguins single filler exactly one arctic antarctic fact
must yes filler haspenguins therefore exactly one location
southpole
facts know extension jaded person must
subset extension wantstovisit database containing facts
southpole northpole
observe occasional worse case behavior generalized
diculty reasoning set descriptions subsumption ignores assertions
individuals yet subsumption per se must perform inferences
simple transformation given appendix establishes fact converting
recognition individuals question subsumption two descriptions
making individuals involved attribute fillers dummy attributes
descriptions restrictions attributes description non empty
attribute values must satisfy corresponding restrictions

modified semantics individuals

seen two individuals appearing descriptions effect
mutable facts extensional relationships immutable descriptions
computational intractability subsumption caused appearance individuals
descriptions
deal first reasonable restrict computation subsumption cannot access database facts individuals role fillers
individuals treated host identifiers procedural description
aspect reasoning sense negation failure prolog prolog
would desirable semantic account phenomenon
semantics ignores mutable facts determining subsumption hard
devise required two different sets possible worlds corresponding
kb containing concepts individuals one set consists possible worlds
model information kb second consists possible worlds
model information concepts roles attributes asking questions individuals first set possible worlds must considered asking
subsumption questions second larger set must considered thus ignoring effects
mutable facts


fiborgida patel schneider

however semantics solve computational individuals
descriptions deal semantics individuals modified
follows instead mapping individuals separate elements domain done
standard semantics individuals mapped disjoint subsets domain intuitively
representing different possible realizations platonic individual
therefore semantics set constructor stated follows domain value
belongs extension fb bn g iff belongs extension one bi
associated change notion cardinality required two elements domain
considered congruent belong extension individual
identical cardinality set elements domain size set
modulo congruence relationship means occurrences different identifiers
description guaranteed unequal distinct occurrences individual
identifier guaranteed denote individual
two consequences stance
looking descriptions southpole northpole section distinct
occurrences arctic might satisfied distinct domain elements different role
fillers greater detail extension arctic might include domain elements
satisfying condition haspenguins yes satisfies haspenguins
southpole located northpole located still
satisfying islocatedin arctic similarly domain elements
extension antarctic therefore one could two places visit
penguins
even though individual may description includes
islocatedin arctic u originatesin arctic
need satisfy condition islocatedin originatesin since equality restriction requires identity domain values

adding individuals classic

individuals occur classic host descriptions following constructs create
classic descriptions
r

ing
attribute r role name classic individual host value
collectively called individuals ij names classic individuals host descriptions
constructed g ij host values
interpretation function extended individual identifiers requiring ii
non empty subset c syntactically recognized host individual
making ii fig host values stated earlier interpretations distinct identifiers
must non overlapping
interpretation ci non atomic descriptions modified follows


fisubsumption classic

p ii fd c j x x pi x ii g
ingi sk iik ik classic individuals ingi g ik
host individuals empty otherwise

n p resp n p objects c least resp n noncongruent fillers role p

development subsumption section modified take
account added constructs modified semantics introduced earlier
first description graphs extended node description graph given third
field finite set individuals special marker denoting universal
set field often called dom node edges r edges given
extra field called fillers edge field finite set individuals
unspecified constructions previous sections dom node universal set
fillers edge r edge empty set
semantics description graphs definition extended following

definition let g hn e ri description graph let possible world

element gi iff function n

r
n n n ni
hn n f e h n n ai f f n f
element ni n hc h iff
c c ci
hr g f h

b
c

elements domain hd ri
gi hd ri
f f domain element hd ri f

universal set f f

merging nodes dom sets intersected merging description graphs unchanged merging edges r edges sets fillers unioned
translation descriptions description graphs extended following rules
description form r turned description graph one node
edges node atoms classic thing single r edge role
r min max fillers fig description graph restricting r edge
gclassic thing classic individual ghost thing otherwise


fiborgida patel schneider

description form turned description graph two nodes
single edge distinguished node graph source
edge r edges atoms classic thing node
r edges atoms classic thing classic individual
host thing otherwise edge single filler
description form g turned description graph one node
node dom set containing r edges atoms
node host thing individuals host values classic thing
individuals classic individual names note parser ensures
individuals must host values must classic individual names
short examination shows theorem true graphs e extension
description graphs formed rules extension description
formed
following transformations added canonicalization
dom node empty mark node incoherent
host value dom node atoms node remove
dom
edge one filler mark description graph incoherent
edge filler node end universal dom make dom
filler
filler edge included dom node end mark
description graph incoherent
node one element dom make element filler
edges pointing
fillers r edge subset dom distinguished node
restriction graph edge mark node r edge incoherent
min r edge less cardinality fillers let min
cardinality
max r edge greater cardinality dom distinguished node description graph r edge make max edge
cardinality dom
min r edge greater equal cardinality dom
distinguished node restriction graph r edge let fillers edge
union fillers dom min greater cardinality
steps detect inconsistency


fisubsumption classic

max edge equal cardinality fillers edge let dom
distinguished node description graph r edge intersection
dom fillers max less cardinality steps detect
inconsistency
note canonical form edges pointing single node
value fillers empty set node set
value dom
proofs lemmas work extension description graphs
proof theorem extended graphs
subsumption page extended follows
r r edge r role r fillers including
edge r attribute fillers including
g dom r subset g
soundness extended fairly obvious completeness
proof following additions construction graphical worlds

extension classic individual names starts empty
constructing graphical worlds node includes host thing
atoms non universal dom pick domain elements corresponding
elements dom

constructing graphical worlds node includes classic thing
atoms non universal dom add distinguished domain element
extension one dom elements

constructing graphical worlds r edges node ensure element

fillers r edge distinguished element least one graphical
worlds extension adding extension appropriate
host domain elements done fillers must subset
dom distinguished node graphical world host values must belong
atoms

fillers edges need considered pushed onto nodes
canonicalization process
proof theorem extended following cases

form ing dom r subset ing thus
graphical worlds g distinguished domain element
extension ij

form edge r labelled
filler edge



fiborgida patel schneider

former case node pointed edge cannot domain
singleton consisting therefore graphical worlds g
distinguished node filler extension required
latter case pick graphical worlds g distinguished node afiller wrong realm graphical worlds g distinguished element
extension

form r r edge r labelled r
filler r edge
former case cardinality dom distinguished node
description graph r edge greater min r edge dom
include dom include graphical worlds
node distinguished element extension required
dom include least elements dom besides
fillers r edge subset set elements thus graphical
worlds g use elements required
latter case pick graphical worlds g distinguished node rfiller wrong realm graphical worlds g distinguished element
extension

shows subsumption given sound complete
modified semantics presented

complete classic

make final pass deal less problematic aspects classic descriptions
appropriately covered far
classic allows primitive descriptions form primitive
description symbol extension arbitrary subset
extension extension primitive e provided
e subsume way one express employee kind person
must employee number
primitive person u employeenr employee
construct removed creating every primitive atomic concept e g
employeehood replacing definition concept conjunction
necessary conditions atom case employeehood u person u
employeenr care taken use atomic concept equivalent primitives
classic permits declaration disjoint primitives essentially allowing one state
extensions atomic concepts must disjoint possible worlds
deal declarations need modify creating canonical graphs
adding step marks node incoherent whenever atoms contains two identifiers
declared disjoint


fisubsumption classic

allow approximate representation ideas cannot encoded
constructors expressly provided classic allows use test defined concepts
following syntax
test host language boolean function
e g test prime number testing function purposes subsumption
treated black boxes semantics assigned atomic concepts test concepts
real effect reasoning level individuals perform constraint
checking
simple additions sound complete subsumption
descriptions classic modified semantics introduced


summary related work conclusions
believe makes two kinds contributions first presents abstracted form subsumption classic description logic shows
ecient correct modified semantics significant
previous claims correct ecient subsumption implemented dls
kandor patel schneider candide beck et al turned
unfounded nebel
tractability proof language basic classic claimed exist
proven donini et al alternate proof technique may found considering restriction corrected subsumption hollunder nutt
description graphs turned interest support
theoretical dls concerning learnability cohen hirsh pitt
frazier would seem harder obtain standard notation
dls
second investigates effect allowing individuals appear descriptions dls independently demonstrated lenzerini schaerf adding
set description introduces yet another source intractability provided
intuitive example illustrating source diculties implementers classic
system others use refutation tableaux theorem proving techniques chose
perform inferences validated standard semantics
formal intractability obvious apparent short enumerating possible ways filling roles subset inferences actually performed
initially described procedurally facts individuals taken account
subsumption provides denotational semantic account
incomplete set inferences formal proof correct account corollary
completeness proof subsumption section observation
graph construction subsumption section indeed ignore
order deal two realms classic fact provides two constructors h test ctest host classic descriptions cause added complications besides
keeping track correct realm



fiborgida patel schneider

properties individuals involved one difference original implementation classic current semantics attribute paths ending
filler used imply equality condition noted section modified
semantics support inference taken implementation
classic significant change standard semantics small easy explain
users procedurally semantically affects desired aspects
language e reasoning basic classic remains exactly

acknowledgments

wish thank ronald brachman colleagues classic project
collaboration jair referees excellent suggestions improving
particular one referees deserves medal thoroughness care
taken locating weaknesses arguments thankful remaining
errors course responsibility

references

kaci h lattice theoretic computation calculus
partially ordered type structures ph thesis university pennsylvania
kaci h nasr r login logic programming language built
inheritance journal logic programming
american association artificial intelligence issues description logics users
meet developers working notes aaai fall symposium
baader f burckert h j heinsohn j hollunder b muller j nebel b nutt w
profitlich h j terminological knowledge representation proposal
terminological logic german center artificial intelligence dfki
baader f hanschke p scheme integrating concrete domains concept
languages proceedings twelfth international joint conference artificial
intelligence pp international joint committee artificial intelligence
long version appears report rr german center
artificial intelligence dfki april
baader f hollunder b kris knowledge representation inference system
sigart bulletin
beck h w gala k navathe b classification query processing
technique candide semantic data model proceedings fifth international data engineering conference pp institute electric electronic
engineers
borgida brachman r j mcguinness l resnick l classic
structural data model objects proceedings acm sigmod international conference mangement data pp association computing
machinery


fisubsumption classic

borgida type systems knowledge representation natural semantics
specifications description logics international journal intelligent cooperative information systems
brachman r j fikes r e levesque h j krypton functional
knowledge representation ieee computer
cohen w w hirsh h forthcoming learnability description logics equality
constraints machine learning preliminary version appears proceedings
fourth annual workshop computational learning theory
devanbu p brachman r j ballard b selfridge p g lassie knowledgebased software information system communications acm
donini f lenzerini nardi nutt w tractable concept languages
proceedings twelfth international joint conference artificial intelligence
pp international joint committee artificial intelligence
doyle j patil r two theses knowledge representation language restrictions taxonomic classification utility representation services artificial
intelligence
pitt l frazier classic learning proceedings seventh annual acm
conference computational learning theory brunswick nj acm press
heinsohn j kudenko nebel b profitlich h j empirical analysis terminological representation systems proceedings tenth national
conference artificial intelligence pp american association artificial
intelligence
hollunder b nutt w subsumption concept languages
report rr german center artificial intelligence dfki
lenzerini schaerf concept languages query languages proceedings
ninth national conference artificial intelligence pp american
association artificial intelligence
levesque h j brachman r j expressiveness tractability knowledge
representation reasoning computational intelligence
macgregor r bates r loom knowledge representation language tech
rep isi rs information sciences institute university southern california
mays e apte c griesmer j kastner j organizing knowledge complex
financial domain ieee expert
nebel b computational complexity terminological reasoning back artificial
intelligence
nebel b terminological reasoning inherently intractable artificial intelligence



fiborgida patel schneider

nebel b peltason c von luck k eds international workshop terminological logics document german center artificial intelligence
dfki
owsnicki klewe b configuration consistency maintenance task hoeppner w ed proceedings gwai th german workshop artificial
intelligence pp springer verlag
patel schneider p f small beautiful knowledge representation
proceedings ieee workshop principles knowledge systems pp
ieee computer society
patel schneider p f decidable logic knowledge representation ph
thesis department computer science university toronto
patel schneider p f four valued semantics terminological logics artificial
intelligence
patel schneider p f b undecidability subsumption nikl artificial intelligence
peltason c von luck k kindermann c eds terminological logic users
workshop fachbereich informatik technische universitat berlin
peltason c von luck k nebel b schmiedel user guide
back system kit report fachbereich informatik technische universitat berlin
resnick l borgida brachman r j mcguinness l patel schneider
p f classic description reference manual common lisp
implementation ai principles department bell laboratories
schmidt schauss subsumption kl one undecidable proceedings
first international conference principles knowledge representation
reasoning pp morgan kaufmann
wright j r weixelbaum e brown k vesonder g palmer r berman
j moore h h knowledge configurator supports sales
engineering manufacturing network systems proceedings
innovative applications artificial intelligence conference pp american
association artificial intelligence

intractability reasoning one

present formal proof subsumption set descriptions fact np hard
term language allows set description need
case analysis order check whether extension individual belongs
description constructor behaves disjunction elements
original submitted publication different independent proof
since outlined lenzerini schaerf



fisubsumption classic

extensions individuals whose membership terms known priori e nonhost individuals particular encode testing unsatisfiability
formula cnf question recognizing individual instance description
since known np hard strong indication intractability
start formula f cnf demorgan laws construct formula g
negation f dnf testing validity g equivalent checking
unsatisfiability f
construct every propositional symbol p used f two individual names p p
p represent negation p individual attribute truthvalue
possible fillers true false
p p truthvalue ftrue falseg
make sure p p exactly one opposite truth values create two
individual names yesp nop additional attributes approve deny respectively
whose fillers need truth value true false respectively
yesp approve fp p g u truthvalue ftrueg
nop deny fp p g u truthvalue ffalseg
given formula g c c cn create individual names c c
cn role conjuncts containing propositions conjuncts
example c p q r
c conjuncts fp q r g u conjuncts
finally construct individual g c c cn possible fillers role

disjunctsholding

g disjunctsholding fc c cng

formula g valid iff least one disjunct holds
equivalent membership concept valid formulae defined

disjunctsholding u disjunctsholding conjuncts truthvalue ftrueg
shows recognizing whether individuals instances descriptions
intractable presence set descriptions minimum number restrictions value
restrictions
convert question concerning subsumption two descriptions
essentially making individuals involved attribute fillers dummy attributes
descriptions restrictions attributes description nonempty attribute values must satisfy corresponding restrictions
define concept upper

formula valid formulae
define concept lower


fiborgida patel schneider

dummy p fpg u p concept descriptor u
dummy p fp g u p concept descriptor u
dummy p fyespg u u
dummy p fnopg u u

dummy ci fcig u u

formula fgg u
database state concept lower instances case
subset extension upper least one instance case
individual names filling dummy attributes must properties ascribed
whence c valid formulae hence upper subsume lower iff
c valid completes proof




