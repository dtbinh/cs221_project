Journal Artificial Intelligence Research 1 (1993) 109-138

Submitted 7/93; published 12/93

Decidable Reasoning Terminological Knowledge
Representation Systems
Martin Buchheit

German Research Center Artificial Intelligence (DFKI)
Stuhlsatzenhausweg 3, D-66123 Saarbrucken, Germany

Francesco M. Donini
Andrea Schaerf

buchheit@dfki.uni-sb.de
donini@assi.dis.uniroma1.it
aschaerf@assi.dis.uniroma1.it

Dipartimento di Informatica e Sistemistica
Universita di Roma \La Sapienza", Via Salaria 113, I-00198 Roma, Italy

Abstract

Terminological knowledge representation systems (TKRSs) tools designing
using knowledge bases make use terminological languages (or concept languages).
analyze theoretical point view TKRS whose capabilities go beyond
ones presently available TKRSs. new features studied, often required practical
applications, summarized three main points. First, consider highly expressive terminological language, called ALCNR, including general complements concepts,
number restrictions role conjunction. Second, allow express inclusion statements general concepts, terminological cycles particular case. Third,
prove decidability number desirable TKRS-deduction services (like satisfiability,
subsumption instance checking) sound, complete terminating calculus
reasoning ALCNR-knowledge bases. calculus extends general technique
constraint systems. byproduct proof, get result inclusion
statements ALCNR simulated terminological cycles, descriptive semantics
adopted.

1. Introduction
general characteristic many proposed terminological knowledge representation systems
(TKRSs) krypton (Brachman, Pigman Gilbert, & Levesque, 1985), nikl (Kaczmarek, Bates, & Robins, 1986), back (Quantz & Kindermann, 1990), loom (MacGregor &
Bates, 1987), classic (Borgida, Brachman, McGuinness, & Alperin Resnick, 1989), kris
(Baader & Hollunder, 1991), k-rep (Mays, Dionne, & Weida, 1991), others (see Rich,
editor, 1991; Woods & Schmolze, 1992), made two different components. Informally speaking, first general schema concerning classes individuals
represented, general properties mutual relationships, second
(partial) instantiation schema, containing assertions relating either individuals
classes, individuals other. characteristic, mentioned proposals
inherit seminal TKRS kl-one (Brachman & Schmolze, 1985), shared
several proposals database models Abrial's (1974), candide (Beck, Gala, &
Navathe, 1989), taxis (Mylopoulos, Bernstein, & Wong, 1980).
Retrieving information actual knowledge bases (KBs) built using one systems deductive process involving schema (TBox) instantiation (ABox).
c 1993 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBuchheit, Donini, & Schaerf

fact, TBox set constraints possible ABoxes, contains intensional
information classes. information taken account answering queries
KB.
realization use KB, TKRS provide mechanical solution
least following problems (from point on, use word concept refer
class):
1. KB-satisfiability : ABox TBox consistent other? is,
KB admit model? positive answer useful validation phase,
negative answer used make inferences refutation-style. latter
precisely approach taken paper.
2. Concept Satisfiability : given KB concept C , exist least one
model KB assigning non-empty extension C ? important
rule meaningless concepts KB design phase, processing
user's queries, eliminate parts query cannot contribute answer.
3. Subsumption : given KB two concepts C D, C general
model KB? Subsumption detects implicit dependencies among concepts
KB.
4. Instance Checking : given KB, individual concept C , instance
C model KB? Note retrieving individuals described
given concept (a query database lexicon) formulated set parallel
instance checkings.
questions precisely characterized TKRS given semantics
(see next section), defines models KB gives meaning expressions
KB. problems formalized, one start theoretical analysis
them, and|maybe independently|a search reasoning procedures accomplishing
tasks. Completeness correctness procedures judged respect formal
statements problems.
now, proposed systems give incomplete procedures solving
problems 1{4, except kris1. is, inferences missed, cases without
precise semantical characterization ones are. designer user needs
(more) complete reasoning, she/he must either write programs suitable programming
language (as database proposal Abrial, taxis), define appropriate inference rules completing inference capabilities system (as back, loom,
classic). theoretical point view, several systems (e.g., loom) even
known complete procedures ever exist|i.e., decidability corresponding
problems known.
Recent research computational complexity subsumption uence
many TKRSs choice incomplete procedures. Brachman Levesque (1984)
1. system classic complete, w.r.t. non-standard semantics treatment
individuals. Complete reasoning w.r.t. standard semantics individuals provided, coNPhard (Lenzerini & Schaerf, 1991).

110

fiDecidable Reasoning Terminological KR Systems

started research analyzing complexity subsumption pure concept expressions, abstracting KBs (we call problem later paper pure subsumption). motivation focusing small problem pure subsumption
fundamental inference TKRS. turned pure subsumption tractable
(i.e., worst-case polynomial-time solvable) simple languages, intractable slight
extensions languages, subsequent research definitely confirmed (Nebel, 1988;
Donini, Lenzerini, Nardi, & Nutt, 1991a, 1991b; Schmidt-Schau & Smolka, 1991; Donini,
Hollunder, Lenzerini, Marchetti Spaccamela, Nardi, & Nutt, 1992). Also, beyond computational complexity, pure subsumption proved undecidable TKRSs U (Schild,
1988), kl-one (Schmidt-Schau, 1989) nikl (Patel-Schneider, 1989).
Note extending language results enhancing expressiveness, therefore
result research could summarized as: TKRS language expressive,
higher computational complexity reasoning language|as Levesque
(1984) first noted. result interpreted two different ways, leading two
different TKRSs design philosophies:
1. `General-purpose languages TKRSs intractable, even undecidable,
tractable languages expressive enough practical interest'. Following interpretation, several TKRSs (such nikl, loom back) incomplete
procedures pure subsumption considered satisfactory (e.g., see (MacGregor &
Brill, 1992) loom). completeness abandoned basic subproblem,
completeness overall reasoning procedures issue anymore; issues
arise, compare incomplete procedures (Heinsohn, Kudenko, Nebel,
& Profitlich, 1992), judge procedure \complete enough" (MacGregor,
1991). practical tool, inference rules used systems achieve
expected behavior KB w.r.t. information contained it.
2. `A TKRS (by definition) general-purpose, hence must provide tractable
complete reasoning user'. Following line, TKRSs (such krypton
classic) provide limited tractable languages expressing concepts, following
\small-can-be-beautiful" approach (see Patel-Schneider, 1984). gap
expressible TKRS language needed expressed
application filled user, (sort of) programming inference rules.
course, usual problems present program development debugging arise
(McGuinness, 1992).
common approaches user must cope incomplete reasoning.
difference former approach, burden regaining useful yet missed
inferences mostly left developers TKRS (and user supposed specify
\complete enough"), latter mainly left user.
perfectly reasonable approaches practical context, incomplete procedures
specialized programs often used deal intractable problems. opinion
incomplete procedures provisional answer problem|the best possible
now. order improve answer, theoretical analysis general problems
1{4 done.
Previous theoretical results deal problems 1{4 full generality.
example, problems studied (Nebel, 1990, Chapter 4), incomplete
111

fiBuchheit, Donini, & Schaerf

procedures given, cycles considered. (Donini, Lenzerini, Nardi, & Schaerf,
1993; Schaerf, 1993a) complexity instance checking analyzed, KBs
without TBox treated. Instance checking analyzed (Vilain, 1991),
addressing part problem performed parsing.
addition, think expressiveness actual systems enhanced
making terminological cycles (see Nebel, 1990, Chapter 5) available TKRSs.
feature undoubtable practical interest (MacGregor, 1992), yet present TKRSs
approximate cycles, using forward inference rules (as back, classic, loom).
opinion, order make terminological cycles fully available complete TKRSs,
theoretical investigation still needed.
Previous theoretical work cycles done (Baader, 1990a, 1990b; Baader, Burkert,
Hollunder, Nutt, & Siekmann, 1990; Dionne, Mays, & Oles, 1992, 1993; Nebel, 1990, 1991;
Schild, 1991), considering KBs formed TBox alone. Moreover, approaches
deal number restrictions (except Nebel, 1990, Section 5.3.5) |a basic feature
already provided TKRSs| techniques used seem easily extensible
reasoning ABoxes. compare detail several works Section 4.
paper, propose TKRS equipped highly expressive language, including constructors often required practical applications, prove decidability problems
1{4. particular, system uses language ALCNR, supports general complements concepts, number restrictions role conjunction. Moreover, system allows
one express inclusion statements general concepts and, particular case,
terminological cycles. prove decidability means suitable calculus, developed extending well established framework constraint systems (see Donini et al.,
1991a; Schmidt-Schau & Smolka, 1991), thus exploiting uniform approach reasoning
TKRSs. Moreover, calculus easily turned decision procedure.
paper organized follows. Section 2 introduce language,
give Tarski-style extensional semantics, commonly used. Using
semantics, establish relationships problems 1{4 allow us concentrate
KB-satisfiability only. Section 3 provide calculus KB-satisfiability, show
correctness termination calculus. Hence, conclude KB-satisfiability
decidable ALCNR, main result paper. Section 4 compare
approach previous results decidable TKRSs, establish equivalence
general (cyclic) inclusion statements general concept definitions using descriptive
semantics. Finally, discuss detail several practical issues related results
Section 5.

2. Preliminaries

section first present basic notions regarding concept languages.
describe knowledge bases built using concept languages, reasoning services
must provided extracting information knowledge bases.

2.1 Concept Languages

concept languages, concepts represent classes objects domain interest,
roles represent binary relations objects. Complex concepts roles
112

fiDecidable Reasoning Terminological KR Systems

defined means suitable constructors applied concept names role names.
particular, concepts roles ALCNR formed means following syntax
(where Pi (for = 1; : : :; k) denotes role name, C denote arbitrary concepts,
R arbitrary role):

C; ,! j

>j
?j

(C u D) j
(C D) j

:C j
8R.C j
9R.C j
( n R) j ( n R)
R ,! P1 u u Pk

(concept name)
(top concept)
(bottom concept)
(conjunction)
(disjunction)
(complement)
(universal quantification)
(existential quantification)
(number restrictions)
(role conjunction)

confusion arises drop brackets around conjunctions disjunctions.
interpret concepts subsets domain roles binary relations domain.
precisely, interpretation = (I ; ) consists nonempty set (the domain
) function (the extension function ), maps every concept subset
every role subset . interpretation concept names
role names thus restricted AI , P , respectively. Moreover,
interpretation complex concepts roles must satisfy following equations (]fg
denotes cardinality set):

>I =
?I = ;

(C u D)I
(C D)I
(:C )I
(8R.C )I
(9R.C )I
( n R)I
( n R)I
(P1 u u Pk )I

=
=
=
=
=
=
=
=

C \ DI
C [ DI
n C
fd1 2 j 8d2 : (d1; d2) 2 RI ! d2 2 C g
fd1 2 j 9d2 : (d1; d2) 2 RI ^ d2 2 C g
fd1 2 j ]fd2 j (d1; d2) 2 RI g ng
fd1 2 j ]fd2 j (d1; d2) 2 RI g ng
P1I \ \ PkI

2.2 Knowledge Bases

(1)

knowledge base built means concept languages generally formed two components: intensional one, called TBox, extensional one, called ABox.
first turn attention TBox. said before, intensional level specifies properties concepts interest particular application. Syntactically,
properties expressed terms call inclusion statements. inclusion
113

fiBuchheit, Donini, & Schaerf

statement (or simply inclusion) form

CvD
C two arbitrary ALCNR-concepts. Intuitively, statement specifies
every instance C instance D. precisely, interpretation satisfies
inclusion C v C DI .
TBox finite set inclusions. interpretation model TBox
satisfies inclusions .
general, TKRSs provide user mechanisms stating concept introductions
(e.g., Nebel, 1990, Section 3.2) form =: (concept definition, interpreted set
equality), _ (concept specification, interpreted set inclusion), restrictions
left-hand side concept must concept name, concept name
one introduction allowed, terminological cycles allowed, i.e.,
concept name may occur|neither directly indirectly|within introduction.
restrictions make possible substitute occurrence defined concept
definition.
impose restrictions form inclusions, obtaining statements
syntactically expressive concept introductions. particular, definition
form =: expressed system using pair inclusions v
v specification form _ simply expressed v D.
Conversely, inclusion form C v D, C arbitrary concepts, cannot
expressed concept introductions. Moreover, cyclic inclusions allowed
statements, realizing terminological cycles.
shown (Nebel, 1991), least three types semantics terminological cycles, namely least fixpoint, greatest fixpoint, descriptive semantics.
Fixpoint semantics choose particular models among set interpretations satisfy
statement form =: D. models chosen least greatest fixpoint
equation. descriptive semantics instead considers interpretations
satisfy statement (i.e., fixpoints) models.
However, fixpoint semantics naturally apply fixpoint statements =: D,
\function" A, i.e., may appear D, obvious way
extend general inclusions. addition, since language includes constructor
complement general concepts, \function" may monotone, therefore
least greatest fixpoints may unique. Whether exists
definitional semantics suitable cyclic definitions expressive languages still
unclear.
Conversely, descriptive semantics interprets statements restricting set
possible models, definitional import. Although completely satisfactory
practical cases (Baader, 1990b; Nebel, 1991), descriptive semantics considered
appropriate one general cyclic statements powerful concept languages.
Hence, seems suitable extended case exactly one
adopted above.
Observe decision put general inclusions TBox standard one.
fact, TKRS krypton statements put ABox. However, conceive
114

fiDecidable Reasoning Terminological KR Systems

inclusions generalization traditional TBox statements: acyclic concept introductions,
definitional import, perfectly expressed inclusions; cyclic concept
introductions expressed well, descriptive semantics adopted. Therefore,
believe inclusions part TBox.
Notice role conjunction allows one express practical feature subroles.
example, role ADOPTEDCHILD written CHILD u ADOPTEDCHILD0, ADOPTEDCHILD' role name, making subrole CHILD. Following idea, every hierarchy
role names rephrased set role conjunctions, vice versa.
Actual systems usually provide construction hierarchies roles means
role introductions (i.e., statements form P =: R P _ R) TBox. However,
simple language roles, cyclic definitions roles always reduced acyclic
definitions, explained (Nebel, 1990, Sec.5.3.1). role definitions acyclic, one
always substitute every concept role name definition, obtaining
equivalent concept. Therefore, consider role definitions paper,
conceive TBox set concept inclusions.
Even so, worth notice concept inclusions express knowledge roles.
particular, domain range restrictions roles expressed, way similar
one (Catarci & Lenzerini, 1993). Restricting domain role R concept C
range concept done two inclusions

9R.> v C; > v 8R.D
straightforward show interpretation satisfies two inclusions,
RI C .

Combining subroles domain range restrictions possible partially
express constructor role restriction, present various proposals (e.g.,
language FL Brachman & Levesque, 1984). Role restriction, written R : C ,
defined (R : C )I = f(d1; d2) 2 j (d1; d2) 2 RI ^ d2 2 C g. example
role DAUGHTER, formulated CHILD:Female, partially simulated
CHILD u DAUGHTER0, inclusion > v 8DAUGHTER0.Female. However, simulation
would complete number restrictions: E.g., mother least three daughters,
know least three female children; instead know three
female children cannot infer three daughters.
turn attention extensional level, i.e., ABox. ABox
essentially allows one specify instance-of relations individuals concepts,
pairs individuals roles.
Let alphabet symbols, called individuals. Instance-of relationships expressed terms membership assertions form:

C (a);

R(a; b);

b individuals, C ALCNR-concept, R ALCNR-role. Intuitively, first form states instance C , whereas second form states
related b means role R.
115

fiBuchheit, Donini, & Schaerf

order assign meaning membership assertions, extension function
interpretation extended individuals mapping elements
way aI 6= bI 6= b. property called Unique Name Assumption; ensures
different individuals interpreted different objects.
interpretation satisfies assertion C (a) aI 2 C , satisfies R(a; b)

(a ; bI ) 2 RI . ABox finite set membership assertions. model ABox
satisfies assertions A.
ALCNR-knowledge base pair = hT ; Ai TBox
ABox. interpretation model model model A.
formally define problems 1{4 mentioned introduction. Let
ALCNR-knowledge base.
1. KB-satisfiability : satisfiable, model;
2. Concept Satisfiability : C satisfiable w.r.t , exists model
C 6= ;;
3. Subsumption : C subsumed w.r.t. , C DI every model ;
4. Instance Checking : instance C , written j= C (a), assertion C (a)
satisfied every model .
(Nebel, 1990, Sec.3.3.2) shown ABox plays active role checking
concept satisfiability subsumption. particular, Nebel shows ABox (subject
satisfiability) replaced empty one without affecting result
services. Actually, (Nebel, 1990), property stated language less expressive ALCNR. However, easy show extends ALCNR. important
remark property valid concept languages. fact,
languages include constructors refer individuals concept language, e.g., constructor one-of (Borgida et al., 1989) forms concept set
enumerated individuals. concept language includes constructor individuals
TBox interact individuals ABox, shown (Schaerf, 1993b).
consequence, concept satisfiability subsumption depend ABox.

Example 2.1 Consider following knowledge base = hT ; Ai:
= f9TEACHES.Course v (Student u 9DEGREE.BS) Prof;
Prof v 9DEGREE.MS;
9DEGREE.MS v 9DEGREE.BS;
MS u BS v ?g
= fTEACHES(john; cs156); ( 1 DEGREE)(john); Course(cs156)g
fragment hypothetical knowledge base describing organization university.
first inclusion, instance, states persons teaching course either graduate
students (students BS degree) professors. easy see satisfiable.
example, following interpretation satisfies inclusions assertions
116

fiDecidable Reasoning Terminological KR Systems

A, therefore model :
= fjohn; cs156; csbg; johnI = john; cs156I = cs156
StudentI = fjohng; ProfI = ;; CourseI = fcs156g; BSI = fcsbg
MSI = ;; TEACHESI = f(john; cs156)g; DEGREEI = f(john; csb)g
described interpretation giving , values
concept names role names. straightforward see values complex
concepts roles uniquely determined imposing must satisfy Equations 1
page 113.
Notice possible draw several non-trivial conclusions . example,
infer j= Student(john). Intuitively shown follows: John teaches
course, thus either student BS professor. can't professor
since professors least two degrees (BS MS) one, therefore
student.
Given previous semantics, problems 1{4 reduced KB-satisfiability
(or complement) linear time. fact, given knowledge base = hT ; Ai, two
concepts C D, individual a, individual b appearing , following
equivalences hold:

C satisfiable w:r:t iff hT ; [ fC (b)gi satisfiable:
C subsumed w:r:t: iff hT ; [ f(C u :D)(b)gi satisfiable:
j= C (a) iff hT ; [ f(:C )(a)gi satisfiable:
slightly different form equivalences given (Hollunder, 1990).
equivalences given straightforward consequence ones given Hollunder.
However, equivalences valid languages including constructors refer
individuals concept language. equivalences reasoning services
languages studied (Schaerf, 1993b).
Based equivalences, next section concentrate KBsatisfiability.

3. Decidability Result

section provide calculus deciding KB-satisfiability. particular, Subsection 3.1 present calculus state correctness. Then, Subsection 3.2,
prove termination calculus. sucient assess decidability
problems 1{4, thanks relationships four problems.

3.1 calculus correctness

method makes use notion constraint system (Donini et al., 1991a; SchmidtSchau & Smolka, 1991; Donini, Lenzerini, Nardi, & Schaerf, 1991c), based
tableaux-like calculus (Fitting, 1990) tries build model logical formula
corresponding KB.
117

fiBuchheit, Donini, & Schaerf

introduce alphabet variable symbols V together well-founded total
ordering `' V . alphabet V disjoint ones defined far.
purpose ordering become clear later. elements V denoted
letters x; y; z; w. point on, use term object abstraction individual
variable (i.e., object element [ V ). Objects denoted symbols
s; and, Section 2, individuals denoted a; b.
constraint syntactic entity one forms:

s: C; sPt;

8x.x: C; =6 : t;

C concept P role name. Concepts assumed simple, i.e.,
complements contain form :A, concept name. Arbitrary
ALCNR-concepts rewritten equivalent simple concepts linear time (Donini
et al., 1991a). constraint system finite nonempty set constraints.
Given interpretation , define -assignment function maps every
variable V element , every individual aI (i.e., ff(a) = aI
2 O).
pair (I ; ff) satisfies: constraint s: C ff(s) 2 C , constraint sPt (ff(s); ff(t))
2 P , constraint =6 ff(s) 6= ff(t), finally, constraint 8x.x: C C =
(notice play role case). constraint system satisfiable
pair (I ; ff) satisfies every constraint .
ALCNR-knowledge base = hT ; Ai translated constraint system
replacing every inclusion C v 2 constraint 8x.x: :C D, every
membership assertion C (a) constraint a: C , every R(a; b) constraints
aP1 b; : : :; aPk b R = P1 u : : : u Pk , including constraint =
6 : b every pair (a; b)
individuals appearing A. easy see satisfiable
satisfiable.
order check constraint system satisfiability, technique adds constraints
either evident contradiction generated interpretation satisfying
obtained resulting system. Constraints added basis suitable set
so-called propagation rules.
providing rules, need additional definitions. Let constraint
system R = P1 u : : : u Pk (k 1) role. say R-successor
sP1 t; : : :; sPk . say direct successor role R,
R-successor s. call direct predecessor inverse relation direct successor.
clear context omit it. Moreover, denote successor transitive
closure relation direct successor, denote predecessor inverse.
assume variables introduced constraint system according ordering
`'. means, introduced constraint system x variables x
already .
denote [x=s] constraint system obtained replacing occurrence
variable x object s.
say separated constraint =
6 : .
Given constraint system object s, define function (; ) follows:
(S; s) := fC j s: C 2 g. Moreover, say two variables x -equivalent,
118

fiDecidable Reasoning Terminological KR Systems

written x , (S; x) = (S; ). Intuitively, two S-equivalent variables represent
element potential interpretation built rules, unless separated.
propagation rules are:
1. !u fs: C1; s: C2g [
1. s: C1 u C2 ,
2. s: C1 s: C2
2. !t fs: Dg [
1. s: C1 C2 ,
2. neither s: C1 s: C2 ,
3. = C1 = C2
3. !8 ft: C g [
1. s: 8R.C ,
2. R-successor s,
3. t: C
4. !9 fsP1 y; : : :; sPk y; : C g [
1. s: 9R.C ,
2. R = P1 u : : : u Pk ,
3. new variable,
4. R-successor t: C ,
5. variable variable w w w
5. ! fsP1 yi ; : : :; sPk yi j 2 1::ng [ fyi 6=: yj j i; j 2 1::n; 6= j g [
1. s: ( n R) ,
2. R = P1 u : : : u Pk ,
3. y1 ; : : :; yn new variables,
4. exist n pairwise separated R-successors ,
5. variable variable w w w
6. ! [y=t]
1. s: ( n R) ,
2. n R-successors ,
3. y; two R-successors separated
7. !8x fs: C g [
1. 8x.x: C ,
2. appears ,
3. s: C .
call rules !t ! nondeterministic rules, since applied
different ways constraint system (intuitively, correspond branching
rules tableaux). rules called deterministic rules. Moreover, call
rules !9 ! generating rules, since introduce new variables constraint
system. rules called nongenerating ones.
119

fiBuchheit, Donini, & Schaerf

use condition based -equivalence relation generating rules
(condition 5) related goal keeping constraint system finite even presence
potentially infinite chains applications generating rules. role become clearer
later paper.
One verify rules always applied system either presence
given constraint s: C (condition 1), or, case !8x-rule,
presence object . confusion arises, say rule applied
constraint s: C object (instead saying applied constraint
system ).
Proposition 3.1 (Invariance) Let 0 constraint systems. Then:
1. 0 obtained application deterministic rule, satisfiable
0 satisfiable.
2. 0 obtained application nondeterministic rule, satisfiable 0 satisfiable. Conversely, satisfiable nondeterministic rule
applicable object , applied way yields
satisfiable constraint system.
Proof. proof mainly rephrasing typical soundness proofs tableaux methods (e.g., Fitting, 1990, Lemma 6.3.2). non-standard constructors number
restrictions.
1. \(" Considering deterministic rules one directly check subset 0.
obvious satisfiable 0 satisfiable.
\)" order show 0 satisfiable case consider turn
possible deterministic rule application leading 0. assume (I ; ff)
satisfies .
!u -rule applied s: C1 u C2 , 0 = [ fs: C1; s: C2g. Since (I ; ff)
satisfies s: C1 u C2, (I ; ff) satisfies s: C1 s: C2 therefore 0.
!8-rule applied s: 8R.C , must R-successor
0 = [ft: C g. Since (I ; ff) satisfies , holds (ff(s); ff(t)) 2 RI . Since (I ; ff) satisfies
s: 8R.C , holds ff(t) 2 C . (I ; ff) satisfies t: C therefore 0.
!8x-rule applied presence 8x.x: C , 0 =
[ fs: C g. Since (I ; ff) satisfies holds C = . Therefore ff(s) 2 C
(I ; ff) satisfies 0 .
!9 -rule applied s: 9R.C , 0 = [ fsP1 y; : : :; sPk y; : C g. Since (I ; ff)
satisfies , exists (ff(s); d) 2 RI 2 C . define -assignment
ff0 ff0 (y) := ff0(t) := ff(t) 6= . easy show (I ; ff0) satisfies 0.
! -rule applied s: ( n R), 0 = [ fsP1 yi ; : : :; sPk yi j 2 1::ng [
fyi 6=: yj j i; j 2 1::n; 6= j g. Since (I ; ff) satisfies , exist n distinct elements
d1; : : :; dn 2 (ff(s); di) 2 RI . define -assignment ff0 ff0 (yi) := di
2 1::n ff0 (t) := ff(t) 62 fy1 ; : : :; yn g. easy show (I ; ff0) satisfies 0.
2. \(" Assume 0 satisfied (I ; ff0). show satisfiable. 0
obtained application !t -rule, subset 0 therefore
satisfied (I ; ff0).
120

fiDecidable Reasoning Terminological KR Systems

0 obtained application ! -rule s: ( n R) ,
y; 0 = [y=t]. define -assignment ff(y ) := ff0 (t)
ff(v ) := ff0(v ) every object v v 6= y. Obviously (I ; ff) satisfies .
\)" suppose satisfied (I ; ff) nondeterministic rule applicable
object s.
!t -rule applicable s: C1 C2 then, since satisfiable, ff(s) 2 (C1 C2)I .
follows either ff(s) 2 C1I ff(s) 2 C2I (or both). Hence, !t -rule obviously
applied way (I ; ff) satisfies resulting constraint system 0.
! -rule applicable s: ( n R), then|since (I ; ff) satisfies |it holds
ff(s) 2 ( n R)I therefore set fd 2 j (ff(s); d) 2 RI g n elements.
hand, n R-successors R-successor
(ff(s); ff(t)) 2 RI . Thus, conclude Pigeonhole Principle (see e.g.,
Lewis & Papadimitriou, 1981, page 26) exist least :two R-successors t; t0
ff(t) = ff(t0 ). Since (I ; ff) satisfies , constraint 6= t0 . Therefore
one two must variable, let's say t0 = . obviously (I ; ff) satisfies [y=t].
Given constraint system , one rule might applicable it. define
following strategy application rules:
1. apply rule variable rule applicable individuals;
2. apply rule variable x rule applicable variable x;
3. apply generating rules nongenerating rule applicable.
strategy ensures variables processed one time according
ordering `'.
point on, assume rules always applied according strategy
always start constraint system coming ALCNR-knowledge
base . following lemma direct consequence assumptions.

Lemma 3.2 (Stability) Let constraint system x variable . Let

generating rule applicable x according strategy. Let 0 constraint system
derivable sequence (possibly empty) applications rules.
1. rule applicable 0 variable x
2. (S; x) = (S 0; x)
3. variable x variable 0, i.e., variable
substituted another variable constant.
1. contradiction: Suppose S0 ! S1 ! ! Sn 0, 2
ft; u; 9; 8; ; ; 8xg rule applicable variable x 0.
exists minimal i, n, case Si . Note 6= 0;
fact, strategy, rule applicable x rule applicable .
rule applicable variable z z x S0; : : :; Si,1. follows
Si,1 Si rule applied x variable w x w. exhaustive
Proof.

121

fiBuchheit, Donini, & Schaerf

analysis rules see that|whichever rule applied Si,1 Si |no new
constraint form : C yRz added Si,1 , therefore rule applicable
Si , contradicting assumption.
2. contradiction: Suppose (S; x) 6= (S 0; x). Call direct predecessor x,
rule must applied either x itself. Obviously x, therefore
former case cannot point 1. case analysis shows rules
applied x generating ones !8 ! rules.
rules add new constraints direct successors x x
therefore change (; x).
3. follows point 1. strategy.
Lemma 3.2 proves variable x direct successor, (; x) stable,
i.e., change subsequent applications rules. fact, variable
direct successor means generating rule applied it, therefore
(Lemma 3.2.2) point (; x) change.
constraint system complete propagation rule applies it. complete system
derived system called completion . clash constraint system
one following forms:

fs: ?g
fs: A; s: :Ag, concept name.
fs: ( n R)g [ fsP1: ti ; : : :; sPk ti j 2 1::n + 1g
[ fti =6 tj j i; j 2 1::n + 1; =6 j g,
R = P1 u : : : u Pk .
clash evidently unsatisfiable constraint system. example, last case
represents situation object at-most restriction set Rsuccessors cannot identified (either individuals
created at-least restrictions).
constraint system containing clash obviously unsatisfiable. purpose
calculus generate completions, look presence clashes inside.
completion contains clash, prove always possible construct
model basis . looking technical details proof, let us
consider example application calculus checking satisfiability.

Example 3.3 Consider following knowledge base = hT ; Ai:
= fItalian v 9FRIEND.Italiang
= fFRIEND(peter; susan);
8FRIEND.:Italian(peter);
9FRIEND.Italian(susan)g
corresponding constraint system is:
= f8x.x: :Italian 9FRIEND.Italian;
peterFRIENDsusan

;

122

fiDecidable Reasoning Terminological KR Systems

8
9:

.:
.
g

;

peter: FRIEND Italian
susan: FRIEND Italian
peter = susan

6

sequence applications propagation rules follows:
S1 = [ fsusan: :Italiang (!8-rule)
S2 = S1 [ fpeter: :Italian 9FRIEND.Italiang (!8x-rule)
S3 = S2 [ fsusan: :Italian 9FRIEND.Italiang (!8x-rule)
S4 = S3 [ fpeter: :Italiang (!t -rule)
S5 = S4 [ fsusanFRIENDx; x: Italiang (!9 -rule)
S6 = S5 [ fx: :Italian 9FRIEND.Italiang (!8x-rule)
S7 = S6 [ fx: 9FRIEND.Italiang (!t-rule)
S8 = S7 [ fxFRIENDy; y: Italiang (!9-rule)
S9 = S8 [ fy: :Italian 9FRIEND.Italiang (!8x-rule)
S10 = S9 [ fy: 9FRIEND.Italiang (!t -rule)
One verify S10 complete clash-free constraint system. particular, !9 rule applicable . fact, since x S10 condition 5 satisfied. S10 one
build interpretation , follows (again, give interpretation concept
role names):
= fpeter; susan; x; yg
peterI = peter, susanI = susan, ff(x) = x, ff(y) = y,
ItalianI = fx; yg
FRIENDI = f(peter; susan); (susan; x); (x; y); (y; y)g
easy see indeed model .
order prove always possible obtain interpretation complete
clash-free constraint system need additional notions. Let constraint system
x, w variables . call w witness x three following conditions hold:
1. x w
2. w x
3. variable z z w z satisfies conditions 1. 2., i.e., w
least variable w.r.t. satisfying conditions 1. 2.
say x blocked (by w) x witness (w) . following lemma states
property witnesses.

Lemma 3.4 Let constraint system, x variable . x blocked
1. x direct successor
2. x exactly one witness.
123

fiBuchheit, Donini, & Schaerf

1. contradiction: Suppose x blocked xPy .
completion process leading generating rule must applied x system
0. follows definition rules 0 every variable w x
x6s w. Lemma 3.2 know, constraint system derivable
0 every w x x6s w. Hence witness x ,
contradicting hypothesis x blocked.
2. follows directly condition 3. witness.
consequence Lemma 3.4, constraint system , w1 witness x w1
cannot witness itself, since relations `' -equivalence transitive.
uniqueness witness blocked variable important defining following
particular interpretation .
Let constraint system. define canonical interpretation canonical -assignment ffS follows:
Proof.

0

1.
2.
3.
4.

:= fs j object g
ffS (s) :=
2 AIS s:
(s; t) 2 P
(a) sPt
(b) blocked variable, w witness wPt .

call (s; t) P-role-pair (s; t) 2 P , call (s; t) role-pair
(s; t) P-role-pair role P . call role-pair explicit comes case
4.(a) definition canonical interpretation call implicit comes
case 4.(b).
Lemma 3.4 obvious role-pair cannot explicit implicit.
Moreover, variable implicit role-pair role-pairs implicit
come exactly one witness, stated following lemma.

Lemma 3.5 Let completion x variable . Let canonical interpretation . x implicit role-pair (x; ),
1. role-pairs x implicit
2. exactly one witness w x roles P P -rolepairs (x,y) x, constraint wPy .

first statement follows Lemma 3.4 (point 1 ). second statement follows
Lemma 3.4 (point 2 ) together definition .
machinery needed prove main theorem subsection.
Proof.

Theorem 3.6 Let complete constraint system. contains clash

satisfiable.

124

fiDecidable Reasoning Terminological KR Systems

Proof. Let ffS canonical interpretation canonical -assignment .
We: prove pair (IS ; ffS ) satisfies every constraint c . c form sPt
6= t, (IS ; ffS ) satisfies definition :and ffS . Considering ! -rule
! -rule see constraint form =
6 . c form
s: C , show induction structure C 2 C .
first consider base cases. C concept name, 2 C definition
. C = >, obviously 2 >IS . case C = ? cannot occur since
clash-free.
Next analyze turn possible complex concept C . C form :C1
C1 concept name since concepts simple. constraint s: C1
since clash-free. 62 C1IS , is, 2 n C1IS . Hence 2 (:C1)IS .
C form C1 u C2 (since complete) s: C1 s: C2 .
induction hypothesis, 2 C1IS 2 C2IS . Hence 2 (C1 u C2)IS .
C form C1 C2 (since complete) either s: C1 s: C2
. induction hypothesis, either 2 C1IS 2 C2IS . Hence 2 (C1 C2)IS .
C form 8R.D, show (s; t) 2 RIS holds
2 DIS . (s; t) 2 RIS , according Lemma 3.5 two cases occur. Either
R-successor blocked witness w R-successor w .
first case t: must since complete. induction hypothesis
2 DIS . second case definition witness, w: 8R.D
completeness , t: must . induction hypothesis
2 DIS .
C form 9R.D show exists 2 (s; t) 2 RIS
2 DIS . Since complete, either R-successor
t: , variable blocked witness w . first case, induction
hypothesis definition , 2 DIS (s; t) 2 RIS . second case
w: 9R.D . Since w cannot blocked complete,
R-successor w t: . induction hypothesis
2 DIS definition (s; t) 2 RIS .
C form ( n R) show goal contradiction. Assume 62 (
n R)IS . exist atleast n + 1 distinct objects t1 ; : : :; tn+1 (s; ti ) 2 RIS ; 2
1::n + 1. means that, since R = P1 u : : : u Pk , pairs (s; ti) 2 PjIS ,
2 1::n + 1 j 2 1::k. according Lemma 3.5 one two following cases must
occur. Either sPj ti j 2 1::k; 2 1::n + 1 exists witness w
wPiti j 2 1::k 2 1::n + 1 . first case ! -rule
applicable completeness. :This means ti 's pairwise separated,
i.e., contains constraints ti 6= tj ; i; j 2 1::n + 1; 6= j . contradicts fact
clash-free. second case leads analogous contradiction.
C form ( n R) show goal contradiction. Assume 62 (
n R)IS . exist atmost < n (m possibly 0) distinct objects t1; : : :; tm
(s; ti ) 2 RIS ; 2 1::m. consider two cases. First case: blocked
. Since R-successors , ! -rule applicable s.
contradicts fact complete. Second case: blocked witness w .
Since R-successors w , ! -rule applicable w. leads
contradiction.

125

fiBuchheit, Donini, & Schaerf

c form 8x.x: then, since complete, object , t:
|and, previous cases, 2 DIS . Therefore, pair (IS ; ffS ) satisfies 8x.x: D.
Finally, since (IS ; ffS ) satisfies constraints , (IS ; ffS ) satisfies .

Theorem 3.7 (Correctness) constraint system satisfiable exists
least one clash-free completion .

\(" Follows immediately Theorem 3.6. \)" Clearly, system containing
clash unsatisfiable. every completion unsatisfiable, Proposition 3.1
, unsatisfiable.
Proof.

3.2 Termination complexity calculus

Given constraint system , call nS number concepts appearing , including
concepts appearing substring another concept. Notice nS bounded
length string expressing .

Lemma 3.8 Let constraint system let 0 derived means

propagation rules. set variables 0 including 2nS variables
least two variables x,y x .
0

constraint x: C 2 0 may contain concepts constraint system .
Since nS concepts, given variable x cannot 2nS different
sets constraints x: C 0 .
Proof.

Lemma 3.9 Let constraint system let 0 constraint system derived

applying propagation rules given strategy. Then, 0
2nS non-blocked variables.

Suppose 2nS + 1 non-blocked variables. Lemma 3.8, know
0 least two variables y1 , y2 y1 y2 . Obviously either y1 y2
y2 y1 holds; suppose y1 y2 . definitions witness blocked either y1
witness y2 exists variable y3 y3 y1 y3 witness y2 .
cases y2 blocked, contradicting hypothesis.
Proof.

Theorem 3.10 (Termination space complexity) Let ALCNR-knowledge
base let n size. Every completion finite size O(24n ).

Let completion . Lemma 3.9 follows 2n
non-blocked variables . Therefore 2n total variables ,
maximum number direct successors variable .
Observe bounded number 9R.C concepts (at n) plus sum
numbers appearing number restrictions. Since numbers expressed binary,
sum bounded 2n . Hence, 2n + n. Since number individuals
bounded n, total number objects (2n + n) (2n + n) (2n + n),
is, O(22n).
Proof.

126

fiDecidable Reasoning Terminological KR Systems

number different constraints form s: C , 8x.x: C object
involved bounded n, constraint size linear n. Hence, total size
constraints bounded n n 22n , O(23n).
number constraints form sPt, =
6 : bounded (22n)2 = 24n,
constraint constant size.
conclusion, size O(24n).
Notice one coarse upper bound, obtained theoretical purposes.
practical cases expect actual size much smaller that. example,
numbers involved number restrictions either expressed unary notation,
limited constant (the latter reasonable restriction practical systems)
argumentation analogous one would lead bound 23n .

Theorem 3.11 (Decidability) Given ALCNR-knowledge base , checking whether
satisfiable decidable problem.

follows Theorems 3.7 3.10 fact satisfiable
satisfiable.
refine theorem, giving tighter bounds time required
decide satisfiability.
Proof.

Theorem 3.12 (Time complexity) Given ALCNR-knowledge base , checking
whether satisfiable done nondeterministic exponential time.

order prove claim sucient show completion obtained
exponential number applications rules. Since number constraints
completion exponential (Theorem 3.10) rule, ! -rule, adds new
constraints constraint system, follows rules applied
exponential number times. Regarding ! -rule, applied object
many times number direct successors. Since number exponential
(if numbers coded binary) w.r.t. size knowledge base, claim follows.
lower bound complexity KB-satisfiability obtained exploiting previous
results language ALC , sublanguage ALCNR include
number restrictions role conjunction. know McAllester (1991), (independently) observation Nutt (1992) KB-satisfiability ALC -knowledge bases
EXPTIME-hard (see (Garey & Johnson, 1979, page 183) definition) hence
hard ALCNR-knowledge bases, too. Hence, expect find algorithm
solving problem polynomial space, unless PSPACE=EXPTIME. Therefore,
expect substantially improve space complexity calculus, already works
exponential space. discuss possible improvements time complexity.
proposed calculus works nondeterministic exponential time, hence improves
one proposed (Buchheit, Donini, & Schaerf, 1993, Sec.4), works deterministic double exponential time. key improvement showed KB
model model exponential size. However, may argued
is, calculus cannot yet turned practical procedure, since procedure would simply simulate nondeterminism second level exponentiality, resulting
Proof.

127

fiBuchheit, Donini, & Schaerf

double exponential time procedure. However, different combinations concepts
exponentially many (this cardinality powerset set concepts). Hence, double exponential time procedure wastes time re-analyzing
objects different names yet (; ), different constraint
systems. could avoided allow variable blocked witness
previously analyzed constraint system. technique would similar one
used (Pratt, 1978), tree-automata technique used (Vardi & Wolper, 1986),
improving simple tableaux methods variants propositional dynamic logics. Since
calculus considers one constraint system time, modification calculus
would necessary accomplish task formal way, outside scope
paper. formal development deterministic exponential time procedure
subject future research.
Notice that, since domain canonical interpretation always finite,
implicitly proved ALCNR-knowledge bases finite model property,
i.e., satisfiable knowledge base finite model. property extensively
studied modal logics (Hughes & Cresswell, 1984) dynamic logics (Harel, 1984).
particular, technique, called filtration, developed prove finite model
property build finite model satisfiable formula. technique allows one
build finite model infinite one grouping worlds structure equivalence
classes, based set formulae satisfied world. interesting
observe calculus, based witnesses, considered variant filtration
technique equivalence classes determined basis -equivalence
relation. However, number restrictions, variables -equivalent cannot
grouped, since might separated (e.g., might introduced
application ! -rule). Nevertheless, direct successors,
stated point 4.(b) definition canonical interpretation page 124. would
correspond grouping variables infinite model way separations
preserved.

4. Relation previous work
section discuss relation paper previous work reasoning inclusions. particular, first consider previously proposed reasoning techniques deal
inclusions terminological cycles, discuss relation inclusions
terminological cycles.

4.1 Reasoning Techniques
mentioned introduction, previous results obtained Baader et al. (1990),
Baader (1990a, 1990b), Nebel (1990, 1991), Schild (1991) Dionne et al. (1992, 1993).
Nebel (1990, Chapter 5) considers language F , containing concept conjunction,
universal quantification number restrictions, TBoxes containing (possibly cyclic)
concept definitions, role definitions disjointness axioms (stating two concept names
disjoint). Nebel shows subsumption F -concepts w.r.t. TBox decidable.
However, argument uses non-constructive: shows sucient con128

fiDecidable Reasoning Terminological KR Systems

sider finite interpretations size bounded size TBox order decide
subsumption.
(Baader, 1990b) effect three types semantics|descriptive, greatest fixpoint least fixpoint semantics|for language FL0, containing concept conjunction
universal quantification, described help finite automata. Baader reduces
subsumption FL0 -concepts w.r.t. TBox containing (possibly cyclic) definitions
form =: C (which calls terminological axioms) decision problems finite automata.
particular, shows subsumption w.r.t. descriptive semantics decided polynomial space using Buchi automata. Using results (Baader, 1990b), (Nebel, 1991)
characterization subsumption problem w.r.t. descriptive semantics given
help deterministic automata (whereas Buchi automata nondeterministic).
yields PSPACE-algorithm deciding subsumption.
(Baader et al., 1990) attention restricted language ALC . particular,
paper considers problem checking satisfiability single equation
form C = >, C ALC -concept. problem, called universal satisfiability problem, shown equivalent checking satisfiability ALC -TBox (see
Proposition 4.1).
(Baader, 1990a), extension ALC , called ALC reg , introduced, supports
constructor express transitive closure roles. means transitive closure
roles possible replace cyclic inclusions form v equivalent acyclic
ones. problem checking satisfiability ALC reg -concept solved
paper. shown using transitive closure possible reduce satisfiability
ALC -concept w.r.t. ALC -TBox = fC1 v D1; : : :; Cn v Dn g concept
satisfiability problem ALC reg (w.r.t. empty TBox). Since problem concept
satisfiability w.r.t. TBox trivially harder checking satisfiability TBox,
paper extends result given (Baader et al., 1990).
technique exploited (Baader et al., 1990) (Baader, 1990a) based
notion concept tree. concept tree generated starting concept C order
check satisfiability (or universal satisfiability). way concept tree generated
concept C similar avor way complete constraint system generated
constraint system fx: C g. However, extension concept tree method
deal number restrictions individuals knowledge base neither obvious,
suggested cited papers; hand, extension calculus based
constraint systems immediate, provided additional features counterpart
First Order Logic.
(Schild, 1991) results general (Baader, 1990a) obtained
considering languages expressive ALC reg dealing concept satisfiability problem languages. results obtained establishing correspondence
concept languages Propositional Dynamic Logics (PDL), reducing
given problem satisfiability problem PDL. approach allows Schild find
several new results exploiting known results PDL framework. However, cannot
used deal every concept language. fact, correspondence cannot established
language includes concept constructors counterpart PDL (e.g.,
number restrictions, individuals ABox).
129

fiBuchheit, Donini, & Schaerf

Recently, algebraic approach cycles proposed (Dionne et al., 1992),
(possibly cyclic) definitions interpreted determining equivalence relation
terms describing concepts. existence uniqueness equivalence relation
derives Aczel's results non-well founded sets. (Dionne et al., 1993)
researchers prove subsumption based approach equivalent subsumption
greatest fixpoint semantics. language analyzed small fragment one used
TKRS k-rep, contains conjunction existential-universal quantifications combined
one construct (hence similar FL0 ). diculty extending results
lies fact clear individuals interpreted algebraic
setting. Moreover, believe constructive approaches algebraic one, give
counterintuitive results applied non-constructive features concept languages|as
negation number restrictions.
conclusion, approaches, i.e., reduction automata problems, concept trees,
reduction PDL algebraic semantics, deal TBoxes don't seem
suitable deal ABoxes. hand, constraint system technique, even
though conceived TBox-reasoning, easily extended ABox-reasoning,
shown (Hollunder, 1990; Baader & Hollunder, 1991; Donini et al., 1993).

4.2 Inclusions versus Concept Definitions
compare expressive power TBoxes defined set inclusions (as done
paper) TBoxes defined set (possibly cyclic) concept introductions
form _ =: D.
Unlike (Baader, 1990a) (Schild, 1991), consider reasoning problems dealing
TBox ABox together. Moreover, use descriptive semantics concept introductions, inclusions. result obtained inclusion statements
concept introductions actually expressive power. detail, show
satisfiability knowledge base = hA; i, set inclusion statements,
reduced satisfiability knowledge base 0 = hA0; 0i 0 set
concept introductions. direction, concept introductions inclusions,
trivial since introductions form =: expressed pair inclusions
v v A, concept name specification _ rewritten
inclusion v (as already mentioned Section 2).
notation, given TBox = fC1 v D1 ; : : :; Cn v Dn g, define concept CT
CT = (:C1 D1) u u (:Cn Dn ). pointed (Baader, 1990a) ALC ,
interpretation satisfies TBox satisfies equation CT = >. result
easily extends ALCNR, stated following proposition.

Proposition 4.1 Given ALCNR-TBox = fC1 v D1; : : :; Cn v Dng, interpretation satisfies satisfies equation CT = >.
interpretation satisfies inclusion C v satisfies equation
:C = >; satisfies set equations :C1 D1 = >,: : : , :Cn Dn = >
satisfies (:C1 D1) u u (:Cn Dn ) = >. claim follows.
Proof.

130

fiDecidable Reasoning Terminological KR Systems

Given knowledge base = hA; concept appearing , define
knowledge base 0 = hA0 ; 0 follows:
A0 = [ fA(b) j b individual g
0 = fA _ CT u 8P1.A u u 8Pn .Ag
P1 ; P2; : : :; Pn role names appearing . Note 0 single
inclusion, could thought one primitive concept specification.
Theorem 4.2 = hA; satisfiable 0 = hA0; 0i satisfiable.
0 following
Proof. order simplify machinery proof, use
(logically equivalent) form:
0 = fA v CT ; v 8P1.A; : : :; v 8Pn .Ag
(Note use symbol `v' instead `_ ' concept name appears
left-hand side many statements, must consider statements inclusions).
\)" Suppose = hA; satisfiable. Theorem 3.7, exists complete
constraint system without clash, defines canonical interpretation
model . Define constraint system 0 follows:
0 = [ fw: j w object g
call canonical interpretation associated 0. prove model
0 .
First observe every assertion satisfied since equal except
interpretation A, appear A. Therefore, every assertion A0
satisfied , either assertion A, (if assertion
form A(b)) definition 0.
Regarding 0 , note definition 0, AIS = = ; therefore
sides inclusions form v 8Pi .A (i = 1; : : :; n) interpreted , hence
satisfied . Since appear CT , (CT )IS = (CT )IS .
Moreover, since satisfies , have, Proposition 4.1, (CT )IS = ,
therefore (CT )IS = (CT )IS = = . follows sides inclusion
v CT interpreted . conclusion, satisfies 0 .
\(" Suppose 0 = hA0 ; 0 satisfiable. Again, Theorem 3.7, exists
complete constraint system 0 without clash, defines canonical interpretation
model 0. show model .
First all, assertions satisfied A0 , satisfies every
assertion A0 . prove satisfies , first prove following equation:
AIS =
(2)
Equation 2 proved showing that, every object 2 , AIS . order
that, observe general property constraint systems: Every variable 0 successor
individual. comes definition generating rules, add variables
constraint system direct successors existing objects, beginning
contains individuals.
Then, Equation 2 proved observing following three facts:
0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

0

131

0

fiBuchheit, Donini, & Schaerf

1. every individual b , b 2 AIS ;
0

0

2. object AIS , satisfies inclusions AIS (8P1.A)IS ; : : :;
AIS (8Pn .A)IS , every direct successor AIS ;
3. successor relation closed direct successor relation
0

0

0

0

0

0

0

Fundamental Theorem Induction (see e.g., Wand, 1980, page 41) conclude every object AIS . proves Equation 2 holds.
Equation 2, fact satisfies inclusion AIS (CT )IS , derive
(CT )IS = , satisfies equation CT = >. Hence, Proposition
4.1, satisfies , completes proof theorem.
machinery present proof new. fact, realizing inclusions
v 8P1 .A; : : :; v 8Pn .A simulate transitive closure roles P1 ; : : :; Pn , one
recognize similarities proofs given Schild (1991) Baader (1990a). difference proofs rely notion connected model (Baader uses equivalent
notion rooted model). contrast, models obtain connected,
individuals knowledge base not. exploit weaker property
every variable model successor individual.
Note reduction strongly relies fact disjunction `t' complement `:' within language. fact, disjunction complement necessary
order express inclusions TBox inside concept CT . Therefore,
proof holds ALC -knowledge bases, hold TKRSs allowing
constructors concepts (e.g., back).
Furthermore, language FL0 introduced Section 4.1, opposite result holds.
fact, McAllester (1991) proves computing subsumption w.r.t. set inclusions
EXPTIME-hard, even small language FL0 . Conversely, Nebel (1991) proves
subsumption w.r.t. set cyclic definitions FL0 done PSPACE. Combining
two results, conclude FL0 subsumption w.r.t. set inclusions
subsumption w.r.t. set definitions different complexity classes, hence (assuming
EXPTIME 6= PSPACE) inclusion statements strictly expressive concept
definitions FL0.
still open whether inclusions definitions equivalent languages whose
expressivity FL0 ALC .
0

0

0

0

0

0

0

0

0

5. Discussion

paper proved decidability main inference services TKRS based
concept language ALCNR. believe result theoretical
importance, bears impact existing TKRSs, complete procedure
easily devised calculus provided Section 3. procedure, one build
ecient (but still complete) ones, described end Section 3.2,
applying standard optimization techniques described (Baader, Hollunder,
Nebel, Profitlich, & Franconi, 1992). optimized procedure perform well small
sublanguages reasoning tractable, still complete solving
complex tasks. However, complete procedure still take exponential time
132

fiDecidable Reasoning Terminological KR Systems

space worst case, may argued could practical applicability.
comment following point.
Firstly, complete procedure (possibly optimized) offers benchmark comparing
incomplete procedures, terms performance, terms missed inferences. Let us illustrate point detail, providing blatant paradox: consider
mostly incomplete constant-time procedure, answering always \No" check. Obviously useless procedure outperforms one, missed inferences taken
account. paradox shows incomplete procedures meaningfully compared missed inferences considered. recognize missed inferences large
examples, one needs exactly complete procedure|even ecient one|like ours.
believe fair detection missed inferences would great help even
satisfaction end users primary criterion judging incomplete procedures.
Secondly, complete procedure used \anytime classification", proposed
(MacGregor, 1992). idea use fast, incomplete algorithm first step
analyzing input knowledge, reasoning background.
cited paper, resolution-based theorem provers proposed performing background
reasoning. argue specialized complete procedure perform better
general theorem prover. instance, theorem provers usually specifically designed
deal filtration techniques.
Moreover, calculus easily adapted deal rules. outlined
introduction, rules often used practical TKRSs. Rules behave one-way concept
inclusions|no contrapositive allowed|and applied known individuals.
result shows rules ALCNR applied unknown individuals (our
variables constraint system) without endangering decidability. result
compared negative result (Baader & Hollunder, 1992), shown
subsumption becomes undecidable rules applied unknown individuals classic.
Finally, calculus provides new way building incomplete procedures, modifying
propagation rules. Since rules build model, modifications
semantical counterpart gives precise account incomplete procedures
obtained. example, one could limit size canonical model polynomial
size KB. Semantically, would mean consider \small" models,
reasonable intended models KB much bigger size
KB itself. believe way designing incomplete procedures \from above", i.e.,
starting complete set inferences weakening it, dual way incomplete
procedures realized far \from below", i.e., starting already incomplete
inferences adding inference power need.
research still needed address problems issuing practical systems.
example, completely express role restrictions inside number restrictions, qualified number
restrictions (Hollunder & Baader, 1991) taken account. Also, language
resulting addition enumerated sets (called one-of classic), role fillers
ALCNR still studied, although seem endanger filtration
method used. Instead, different method might necessary inverse roles added
ALCNR, since finite model property lost (as shown Schild, 1991). Finally,
addition concrete domains (Baader & Hanschke, 1991) remains open.
133

fiBuchheit, Donini, & Schaerf

Acknowledgements
thank Maurizio Lenzerini inspiration work, well several discussions contributed paper. Werner Nutt pointed us observation mentioned end Section 3, thank Franz Baader helpful comments
earlier drafts. thank anonymous reviewers, whose stimulating comments
helped us improving submitted version.
research partly done first author visiting Dipartimento di Informatica e Sistemistica, Universita di Roma \La Sapienza". third author acknowledges Yoav Shoham hospitality Computer Science Department Stanford
University, author developing part research.
work supported ESPRIT Basic Research Action N.6810 (COMPULOG 2) Progetto Finalizzato Sistemi Informatici e Calcolo Parallelo
CNR (Italian Research Council), LdR \Ibridi".

References

Abrial, J. (1974). Data semantics. Klimbie, J., & Koffeman, K. (Eds.), Data Base
Management, pp. 1{59. North-Holland Publ. Co., Amsterdam.
Baader, F. (1990a). Augmenting concept languages transitive closure roles: alternative terminological cycles. Tech. rep. RR-90-13, Deutsches Forschungszentrum
fur Kunstliche Intelligenz (DFKI), Kaiserslautern, Germany. abridged version appeared Proc. 12th Int. Joint Conf. Artificial Intelligence IJCAI-91, pp.
446{451.
Baader, F. (1990b). Terminological cycles KL-ONE-based knowledge representation languages. Tech. rep. RR-90-01, Deutsches Forschungszentrum fur Kunstliche Intelligenz
(DFKI), Kaiserslautern, Germany. abridged version appeared Proc. 8th
Nat. Conf. Artificial Intelligence AAAI-90, pp. 621{626.
Baader, F., Burkert, H.-J., Hollunder, B., Nutt, W., & Siekmann, J. H. (1990). Concept
logics. Lloyd, J. W. (Ed.), Computational Logics, Symposium Proceedings, pp.
177{201. Springer-Verlag.
Baader, F., & Hanschke, P. (1991). schema integrating concrete domains concept
languages. Proc. 12th Int. Joint Conf. Artificial Intelligence IJCAI-91,
pp. 452{457 Sydney.
Baader, F., & Hollunder, B. (1991). terminological knowledge representation system
complete inference algorithm. Proc. Workshop Processing Declarative
Knowledge, PDK-91, Lecture Notes Artificial Intelligence, pp. 67{86. SpringerVerlag.
Baader, F., & Hollunder, B. (1992). Embedding defaults terminological knowledge
representation formalisms. Proc. 3rd Int. Conf. Principles Knowledge
Representation Reasoning KR-92, pp. 306{317. Morgan Kaufmann, Los Altos.
134

fiDecidable Reasoning Terminological KR Systems

Baader, F., Hollunder, B., Nebel, B., Profitlich, H.-J., & Franconi, E. (1992). empirical
analisys optimization techniques terminological representation systems. Proc.
3rd Int. Conf. Principles Knowledge Representation Reasoning KR92, pp. 270{281. Morgan Kaufmann, Los Altos.
Beck, H. W., Gala, S. K., & Navathe, S. B. (1989). Classification query processing
technique CANDIDE semantic data model. Proc. 5th IEEE Int. Conf.
Data Engineering.
Borgida, A., Brachman, R. J., McGuinness, D. L., & Alperin Resnick, L. (1989). CLASSIC:
structural data model objects. Proc. ACM SIGMOD Int. Conf.
Management Data, pp. 59{67.
Brachman, R. J., & Levesque, H. J. (1984). tractability subsumption framebased description languages. Proc. 4th Nat. Conf. Artificial Intelligence
AAAI-84, pp. 34{37.
Brachman, R. J., Pigman Gilbert, V., & Levesque, H. J. (1985). essential hybrid
reasoning system: Knowledge symbol level accounts KRYPTON. Proc.
9th Int. Joint Conf. Artificial Intelligence IJCAI-85, pp. 532{539 Los Angeles.
Brachman, R. J., & Schmolze, J. G. (1985). overview KL-ONE knowledge representation system. Cognitive Science, 9 (2), 171{216.
Buchheit, M., Donini, F. M., & Schaerf, A. (1993). Decidable reasoning terminological
knowledge representation systems. Tech. rep. RR-93-10, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Saarbrucken, Germany. abridged version
appeared Proc. 13th Int. Joint Conf. Artificial Intelligence IJCAI-93 pp.
704{709.
Catarci, T., & Lenzerini, M. (1993). Representing using interschema knowledge
cooperative information systems. Journal Intelligent Cooperative Inf. Syst.
appear.
Dionne, R., Mays, E., & Oles, F. J. (1992). non-well-founded approach terminological
cycles. Proc. 10th Nat. Conf. Artificial Intelligence AAAI-92, pp. 761{766.
AAAI Press/The MIT Press.
Dionne, R., Mays, E., & Oles, F. J. (1993). equivalence model theoretic structural
subsumption description logics. Proc. 13th Int. Joint Conf. Artificial
Intelligence IJCAI-93, pp. 710{716 Chambery, France. Morgan Kaufmann, Los Altos.
Donini, F. M., Hollunder, B., Lenzerini, M., Marchetti Spaccamela, A., Nardi, D., & Nutt,
W. (1992). complexity existential quantification concept languages. Artificial
Intelligence, 2{3, 309{327.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991a). complexity concept
languages. Allen, J., Fikes, R., & Sandewall, E. (Eds.), Proc. 2nd Int.
Conf. Principles Knowledge Representation Reasoning KR-91, pp. 151{162.
Morgan Kaufmann, Los Altos.
135

fiBuchheit, Donini, & Schaerf

Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991b). Tractable concept languages.
Proc. 12th Int. Joint Conf. Artificial Intelligence IJCAI-91, pp. 458{463
Sydney.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1991c). hybrid system integrating
datalog concept languages. Proc. 2nd Conf. Italian Association
Artificial Intelligence, No. 549 Lecture Notes Artificial Intelligence. SpringerVerlag. extended version appeared Working Notes AAAI Fall
Symposium \Principles Hybrid Reasoning".
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1993). Deduction concept languages: subsumption instance checking. Journal Logic Computation.
appear.
Fitting, M. (1990). First-Order Logic Automated Theorem Proving. Springer-Verlag.
Garey, M., & Johnson, D. (1979). Computers Intractability|A guide NPcompleteness. W.H. Freeman Company, San Francisco.
Harel, D. (1984). Dynamic logic. Handbook Philosophical Logic, Vol. 2, pp. 497{640.
D. Reidel, Dordrecht, Holland.
Heinsohn, J., Kudenko, D., Nebel, B., & Profitlich, H.-J. (1992). empirical analysis
terminological representation systems. Proc. 10th Nat. Conf. Artificial
Intelligence AAAI-92, pp. 767{773. AAAI Press/The MIT Press.
Hollunder, B. (1990). Hybrid inferences KL-ONE-based knowledge representation systems. Proc. German Workshop Artificial Intelligence, pp. 38{47. SpringerVerlag.
Hollunder, B., & Baader, F. (1991). Qualifying number restrictions concept languages.
Tech. rep. RR-91-03, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI),
Kaiserslautern, Germany. abridged version appeared Proc. 2nd Int. Conf.
Principles Knowledge Representation Reasoning KR-91.
Hughes, G. E., & Cresswell, M. J. (1984). Companion Modal Logic. Methuen, London.
Kaczmarek, T. S., Bates, R., & Robins, G. (1986). Recent developments NIKL. Proc.
5th Nat. Conf. Artificial Intelligence AAAI-86, pp. 978{985.
Lenzerini, M., & Schaerf, A. (1991). Concept languages query languages. Proc.
9th Nat. Conf. Artificial Intelligence AAAI-91, pp. 471{476.
Levesque, H. J. (1984). Foundations functional approach knowledge representation.
Artificial Intelligence, 23, 155{212.
Lewis, H. R., & Papadimitriou, C. H. (1981). Elements Theory Computation.
Prentice-Hall, Englewood Cliffs, New Jersey.
MacGregor, R. (1991). Inside LOOM description classifier. SIGART Bulletin, 2 (3),
88{92.
136

fiDecidable Reasoning Terminological KR Systems

MacGregor, R. (1992). What's needed make description logic good KR citizen.
Working Notes AAAI Fall Symposium Issues Description Logics: Users
meet Developers, pp. 53{55.
MacGregor, R., & Bates, R. (1987). Loom knowledge representation language. Tech.
rep. ISI/RS-87-188, University Southern California, Information Science Institute,
Marina del Rey, Cal.
MacGregor, R., & Brill, D. (1992). Recognition algorithms LOOM classifier.
Proc. 10th Nat. Conf. Artificial Intelligence AAAI-92, pp. 774{779. AAAI
Press/The MIT Press.
Mays, E., Dionne, R., & Weida, R. (1991). K-REP system overview. SIGART Bulletin,
2 (3).
McAllester, D. (1991). Unpublished manuscript.
McGuinness, D. L. (1992). Making description logic based knowledge representation systems
usable. Working Notes AAAI Fall Sysmposium Issues Description
Logics: Users meet Developers, pp. 56{58.
Mylopoulos, J., Bernstein, P., & Wong, E. (1980). language facility designing databaseintensive applications. ACM Trans. Database Syst., 5 (2), 185{207.
Nebel, B. (1988). Computational complexity terminological reasoning BACK. Artificial
Intelligence, 34 (3), 371{383.
Nebel, B. (1990). Reasoning Revision Hybrid Representation Systems. Lecture Notes
Artificial Intelligence. Springer-Verlag.
Nebel, B. (1991). Terminological cycles: Semantics computational properties. Sowa,
J. F. (Ed.), Principles Semantic Networks, pp. 331{361. Morgan Kaufmann, Los
Altos.
Nutt, W. (1992). Personal communication.
Patel-Schneider, P. F. (1984). Small beautiful knowledge representation. Proc.
IEEE Workshop Knowledge-Based Systems. extended version appeared
Fairchild Tech. Rep. 660 FLAIR Tech. Rep. 37, October 1984.
Patel-Schneider, P. (1989). Undecidability subsumption NIKL. Artificial Intelligence,
39, 263{272.
Pratt, V. R. (1978). practical decision method propositional dynamic logic. Proc.
10th ACM SIGACT Symp. Theory Computing STOC-78, pp. 326{337.
Quantz, J., & Kindermann, C. (1990). Implementation BACK system version 4. Tech.
rep. KIT-Report 78, FB Informatik, Technische Universitat Berlin, Berlin, Germany.
Rich, editor, C. (1991). SIGART bulletin. Special issue implemented knowledge representation reasoning systems. (2)3.
137

fiBuchheit, Donini, & Schaerf

Schaerf, A. (1993a). complexity instance checking problem concept languages existential quantification. Journal Intelligent Information Systems, 2,
265{278. abridged version appeared Proc. 7th Int. Symp. Methodologies Intelligent Systems ISMIS-93.
Schaerf, A. (1993b). Reasoning individuals concept languages. Tech. rep. 07.93,
Dipartimento di Informatica e Sistemistica, Universita di Roma \La Sapienza".
abridged version appeared Proc. 3rd Conf. Italian Association
Artificial Intelligence AI*IA-93.
Schild, K. (1988). Undecidability subsumption U . Tech. rep. KIT-Report 67, FB
Informatik, Technische Universitat Berlin, Berlin, Germany.
Schild, K. (1991). correspondence theory terminological logics: Preliminary report.
Proc. 12th Int. Joint Conf. Artificial Intelligence IJCAI-91, pp. 466{471
Sydney.
Schmidt-Schau, M. (1989). Subsumption KL-ONE undecidable. Brachman, R. J.,
Levesque, H. J., & Reiter, R. (Eds.), Proc. 1st Int. Conf. Principles
Knowledge Representation Reasoning KR-89, pp. 421{431. Morgan Kaufmann,
Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 1{26.
Vardi, M., & Wolper, P. (1986). Automata-theoretic techniques modal logics programs. Journal Computer System Science, 32, 183{221. preliminary version
appeared Proc. 16th ACM SIGACT Symp. Theory Computing STOC84.
Vilain, M. (1991). Deduction parsing: Tractable classification KL-ONE framework.
Proc. 9th Nat. Conf. Artificial Intelligence AAAI-91, pp. 464{470.
Wand, M. (1980). Induction, Recursion, Programming. North-Holland Publ. Co.,
Amsterdam.
Woods, W. A., & Schmolze, J. G. (1992). KL-ONE family. Lehmann, F. (Ed.),
Semantic Networks Artificial Intelligence, pp. 133{178. Pergamon Press. Published
special issue Computers & Mathematics Applications, Volume 23, Number
2{9.

138


