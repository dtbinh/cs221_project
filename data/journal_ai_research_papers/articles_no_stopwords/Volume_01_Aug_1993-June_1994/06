journal artificial intelligence

submitted published

teleo reactive programs agent control
nils j nilsson

nilsson cs stanford edu

robotics laboratory department computer science
stanford university stanford ca usa

abstract

formalism presented computing organizing actions autonomous agents
dynamic environments introduce notion teleo reactive r programs whose
execution entails construction circuitry continuous computation parameters conditions agent action addition continuous feedback
r programs support parameter binding recursion primary difference
r programs many circuit systems circuitry r programs
compact constructed run time thus anticipate
contingencies might arise possible runs addition r programs
intuitive easy write written form compatible automatic
learning methods brie describe experimental applications r
programs control simulated actual mobile robots
introduction

autonomous agents mobile robots typically operate dynamic uncertain
environments environments sensed imperfectly effects
completely predictable may subject changes agent
control designing agents operate environments presented challenges
standard methods artificial intelligence explicit declarative representations reasoning processes prominent among alternative approaches
called behavior situated animat methods brooks maes kaelbling rosenschein wilson convert sensory inputs actions
much direct fashion ai systems representation reasoning many
alternative approaches share control theory central notion continuous
feedback environment necessary component effective action
perhaps relatively easier control theorists computer scientists
deal continuous feedback control theorists accustomed thinking
controlling mechanisms composed analog electrical circuits physical
systems rather automata discrete read compute write cycles notions
goal seeking servo mechanisms homeostasis feedback filtering stability essential
control dynamic environments developed analog circuitry mind
circuits nature continously responsive inputs
contrast central ideas computer science namely sequences events
discrete actions subroutines seem odds notion continuous feedback
example conventional programming one program calls another calling
program suspended called program returns control feature awkward
applications called program might encounter unexpected environmental

c ai access foundation morgan kaufmann publishers rights reserved

finilsson

circumstances designed cope cases calling program
regain control interrupts explicitly provided programmer
sure attempts blend control theory computer science
example work ramadge wonham ramadge wonham discrete event
systems used computer science notions events grammars discrete states
study control processes ideas appropriate book dean
wellman dean wellman focusses overlap control theory
artificial intelligence little effort import fundamental control theory
ideas computer science precisely set
propose computational system works differently conventional ones
formalism call circuit semantics nilsson program execution produces
least conceptually electrical circuits circuits used control
importing control theory concept continuous feedback nevertheless want
retain useful ideas computer science control programs parameters
bound run time passed subordinate routines hierarchical
organization recursive contrast behavior
approaches want programs responsive stored environment
well immediate sensory inputs
presentation ideas somewhat informal line belief
formalization best done certain amount experience obtained although
preliminary experiments indicate formalism works quite well work remains
done establish place agent control
teleo reactive sequences
condition action rules

teleo reactive r sequence agent control program directs agent toward
goal hence teleo manner takes account changing environmental circumstances
hence reactive simplest form consists ordered set production rules

k
k









ki



ai



km





ki conditions sensory inputs model world ai
actions world change model r sequence interpreted
manner roughly similar way production systems interpreted
list rules scanned top first rule whose condition part satisfied
corresponding action executed r sequences differ substantively conventional
production systems however r actions durative rather discrete durative


fiteleo reactive programs

action one continues indefinitely example mobile robot capable executing
durative action move propels robot ahead say constant speed indefinitely
action contrasts discrete one move forward one meter r
sequence durative action continues long corresponding condition remains first
true condition first true condition changes action changes correspondingly
thus unlike production systems computer science conditions must continuously
evaluated action associated currently first true condition one
executed action terminates energizing condition ceases
first true condition
indeed rather thinking r sequences terms computer science idea
discrete events appropriate think implemented circuitry
example sequence implemented circuit shown figure
furthermore imagine conditions ki continuously computed
sensors

model

conditioncomputing
circuits

k






k





k











km

figure implementing r sequence circuitry
actions ai r sequence primitive actions r
sequences thus programs written formalism hierarchical even
recursive shall see later case hierarchical programs important
realize conditions levels hierarchy continuously evaluated
high level sequence redirect control different path lower level sequences
dictated values conditions levels


finilsson

writing r sequence programmer ordinarily works backward whatever goal
condition sequence designed achieve condition k taken
goal condition corresponding action null action condition k
weakest condition satisfied k durative execution
things equal eventually achieve k non null
action ai supposed achieve condition kj strictly higher list j
conditions therefore regressions nilsson higher conditions actions
achieve higher conditions
formally say r sequence satisfies regression property condition
regression higher condition sequence kj j
action ai say r sequence complete k ki
km tautology r sequence universal satisfies regression property
complete easy see universal r sequence achieve goal
condition k sensing execution errors

ki

sometimes action effect anticipated agent designer
normal effect sometimes exogenous events separate actions
agent change world unexpected ways phenomena course reason
continuous feedback required universal r sequences universal plans schoppers
robust face occasional deviations normal execution
exploit serendipitous effects may accidentally happen action achieves
condition higher list condition action rules normally expected even
action sometimes achieve normal effect due occasional sensing execution
errors nevertheless action executed long environment
often frustrate achievement normal effects actions goal condition
universal r sequence ultimately achieved

example

following rather simple example make ideas concrete consider
simulated robots figure let suppose robots move bars around
two dimensional world robot right holding bar want
robot go grab bar marked presume robot sense
environment evaluate conditions tell whether already grabbing
bar grabbing facing toward bar facing bar positioned respect bar
reach grab bar center perpendicular bisector bar
bar midline facing zone perpendicular bisector bar
would appropriate move toward bar facing midline zone let assume
conditions appropriate amount hysteresis hunting behavior
dampened suppose robot capable executing primitive actions grab bar move
rotate obvious effects execution following r sequence
robot grabbing bar


fibar midline



bar center

midline zone

figure robots bars
notice properly executed action sequence achieves condition
rule way actions inexorably proceed toward goal occasional
setbacks merely cause delays achieving goal long actions usually achieve
normal effects
teleo reactive programs
rules variables

generalize notion r sequence permitting rules contain free
variables bound sequence called call sequence r
program additional generality obtained assume variables necessarily
bound constants quantities whose values continuously computed
circuitry environment changes
simple example involving robot go designated goal location two
dimensions serve illustrate suppose goal location given value
variable loc run time loc bound pair x coordinates although allow
binding change run time time process robot x
position given value variable position assume robot
kind navigational aid reliably continuously computes value position
instantaneous values loc position robot compute direction
choose define usually precisely although probabilistic analysis could given



finilsson

face proceed straight line toward loc let value direction
time given value function course position loc time
process robot angular heading given value variable heading
variables r program drive robot loc
goto loc
equal position loc
equal heading course position loc






nil
move
rotate

implementing goto loc circuitry straightforward single parameter
program loc whose possibly changing value specified run time user
higher level program circuitry global parameters position heading
provided circuitry assume function course continuously
computed circuitry given values parameters computing action
energize computed circuitry manner figure
hierarchical programs

formalism allows writing hierarchical recursive programs actions
rules r programs example write recursive navigation
program calls goto navigation program requires complex sensory
functions imagine function clear path place place value
direct path clear place place assume robot compute
function continuously place position place equal target location
imagine function point place place computes intermediate position
place place whenever clear path value value newpoint lies appropriately side obstacle determined place
place robot heads toward point first toward place
navigate around obstacle clear path point continuously computed
perceptual systems endow robot name navigation
program amble loc code
amble loc
equal position loc
clear path position loc






nil
goto loc
amble point position loc

figure path robot controlled program might take
navigating around obstacles shown program necessarily compute shortest
paths present program simply illustration recursion note
obstacle positions goal location change execution changes ected
values parameters used program program execution proceed
manner appropriate changes particular clear path ever becomes manifest


figoal location

figure navigating amble
continuous computation parameters involved r programs ability
high level programs redirect control account great robustness formalism
formal syntax r programs given nilsson
implementational issues

r formalism implicit assumption continuous computation conditions
parameters thought fully legitimate level hierarchy program
structure controlling agent regardless level implemented levels
computer scientists think list processing level actual operation even though
implemented primitive logical operations assume
pace events agent environment slow compared amount time
taken perform continuous computations required r program r
programmer justified assuming real continuous sensing writes programs even
though underlying implentation may involve discrete sampling recommend
r formalism applications assumption justified
applications r level shields programmer worry
level implemented greatly facilitates program construction
several different ways r programs interpreted lower
level implementations beyond scope point
obvious methods leave important questions properties methods
subsequent one method implementation involves construction actual
simulated circuits according basic scheme figure first top level conditioncomputing circuits including circuits computing parameters used conditions
constructed allowed function specific action say ai energized ai


finilsson

primitive turned keeping circuitry place functioning
top level action energized ai r sequence circuitry needed
implement constructed done top level action selected
levels circuitry left functioning lower level
circuitry constructed circuitry longer functioning circuitry longer
called functioning higher level circuitry garbage collected
important questions parameter passing timing process
deal relying assumption times needed create circuitry circuitry function negligible compared pace events
world assumption similar synchrony hypothesis esterel programming language berry gonthier assumed program reaction
takes time respect external environment remains invariant
reaction
although reason principle circuitry could simulated actually
constructed sort programmable network logic gates straightforward implement r program standard computational techniques r
programs written lisp cond statements durative actions simulated
iterating short action increments example increment move action
simulated robot might move robot ahead small amount action
increment top level lisp cond executed anew course functions
parameters contains evaluated anew simulations robots moving
two dimensional worlds discussed computations involved suciently
fast effect reasonable pace apparent smooth motion
implementation method essentially involves sampling environment irregular
intervals course questions concerning computation times thus
sampling rate affect real time aspects agent behavior address
assuming sampling rate short
whatever method used interpret r programs care must taken con ate
r level levels programmer ought think
circuit simulators sampling intervals imagine sensing done continuously
immediately
graphical representations

goto program represented graph well list rules used earlier
graphical representation program shown figure nodes labeled
conditions arcs actions execute graphical version program
look shallowest true node taking goal condition root execute
action labeling arc leading node
graph figure action normally achieves condition head arc
condition tail arc shallowest true condition
one action achieve condition would tree instead single path
graph general graph teleo reactive tree depicted figure
r trees executed searching shallowest true node executing action
labeling arc leaving node alternatively could search true node judged


fiteleo reactive programs

equal position loc

move
equal heading course position loc

rotate


figure graphical representation goto
path least cost goal appropriate heuristic measure cost
used simplicity phrase shallowest true node taken mean
shallowest true node literally true node path least cost goal ties
among several equally shallow true nodes broken according fixed tie breaking rule
figure see particular least two ways achieve condition k
one way uses action k shallowest true node one way uses action
k shallowest true node
analogy definitions given r sequences r tree satisfies regression
property every non root node regression parent node action linking
parent r tree complete disjunction conditions
tautology r tree universal satisfies regression property
complete fixed tie breaking rule r tree becomes r sequence
r tree universal corresponding r sequence
one might first object method executing r tree grounds
sequence actions emerge hop erratically one path another
tree satisfies regression property heuristic measuring cost
goal reasonable however erratic actions may appear successfully
executed action brings agent closer goal
experiments

carried several preliminary experiments agents programmed language lisp cond statements short action increments one set experiments
uses simulated robots acting two dimensional space called botworld construction
original botworld interface including primitive perceptual functions actions robots
designed implemented jonas karlsson next computer system karlsson sub



finilsson

k




k

k

km

km

figure r tree
materials structures made materials robots construction materials bars robots build structures connecting bars ways
robot turn move grab release suitably adjacent bar turn move
grabbed bar connect bar bars structures robots continuously
sense whether holding bar see front giving
information location bars structures existence
robots may change world sometimes unexpected ways important
robot sense certain critical aspects environment continuously
typical botworld graphical display shown figure
written r programs cause robots build structures
kinds triangle constructed figure robot controlled one
programs exhibits homeostatic behavior long main goal whatever
satisfied robot inactive whenever goal whatever reason satisfied
robot becomes active persists achieves goal another agent achieves
part goal robot carries appropriately situation finds
complete process
experiments conditions used r rules conditions model
environment robot constructs sensory system maintains separately
r mechanism use model permits robot perform actions
response sensory stimuli past present used help construct
model r actions include direct changes model addition
sequently patrick teo implemented version runs x windows several different workstations teo latter version allows simulation several robots simultaneously
control independently running process



fiteleo reactive programs

figure botworld display
changes resulting perceived changes environment potential
undesirable instabilities system positive feedback
model environment model updated response sensory
data separate major outside scope work reported
experiments used nomadic technologies series mobile robot
robot equipped ring infrared sensors ring sonar sensors
controlled via radio modem macintosh ii running allegro common lisp
implemented robust r programs simple oce environment tasks
wall following corridor following galles programs initially developed
debugged nomadics simulator actual robot changes
made porting programs simulator robot performing tasks
robot highly reactive persistent even face occasional extreme sonar
infrared range errors deliberate attempts confuse robot quickly adapts
sudden changes environment caused people sharing hallways
writing r programs one need concerned inventing appropriate
predicates available perceptual functions model database one need
worry providing interrupts lower level programs higher level ones regain
control found debugging r programs presents challenges though
since designed quite robust face environmental uncertainty
sometimes work rather well even though completely debugged
residual errors might undesirable effects programs used higher
level programs making higher ones dicult debug


finilsson

approaches specifying behavior

several formalisms proposed prescribing sensory directed real time
activity dynamic environments closely related r formalism
proposed section point major similarities differences r
programs representative though complete sample closest relatives
reactive formalisms two types namely sample environments
discrete intervals perhaps rapidly enough suciently reactive
create circuitry r programs discrete sampling systems abstract
activity higher level environment monitored continuously
circuitry creating systems prior run time unlike r programs create
circuitry run time
discrete sampling systems
production systems

already mentioned r programs similar production systems waterman hayes roth intermediate level actions ilas used sri robot
shakey nilsson programmed production rules much
r programs r program resembles plan represented triangle table form
constructed strips fikes hart nilsson conditions r
sequence corresponds triangle table kernel planex execution system triangle tables action corresponding highest numbered satisfied kernel executed
major difference previous production system style programs tr programs r programs continuously responsive environment
ordinary production systems
reactive plans

several researchers adopted current situation index
set pre arranged action sequences georgeff lansky schoppers firby
set large enough cover substantial number situations
agent likely cover possible situations latter
case plan set said universal unlike r programs systems explicitly
sample environments discrete time steps rather continuously r
programs time space trade offs must taken account considering many
different conditions must anticipated providing reactive plans ginsberg noted
several domains number situations likely encountered agent
intractably large agent forced postpone run time
situations actually encountered ginsberg discussion
point see selman r programs advantage least rudimentary
form namely parameter binding done run time prs system georgeff
lansky capable extensive run time well reacting
appropriately current situation


fiteleo reactive programs

situated control rules

drummond drummond introduces notion plan net kind petri
net reisig representing effects actions executed parallel
taking account possible interactions actions projects effects
possible actions present state horizon effects represented
structure called plan projection plan projection analyzed see state
states possibly path goal state analysis forward version
backward analysis used programmer producing r tree situated control
rules analysis constrain actions might taken
state state still possibly path goal plan
nets petri nets discrete events thus continuously responsive
environments way r programs
circuit systems

kaelbling proposed formalism called gapps kaelbling kaelbling rosenschein involving goal reduction rules implicitly describing achieve goals
gapps programmer defines activity agent providing sucient goal reduction rules connect agent goals situations might
rules compiled circuitry real time control agent rosenschein
kaelbling rosenschein kaelbling call circuitry situated automata
collection gapps rules achieving goal thought implicit
specification r program computations needed construct program
performed rules compiled gapps programmer typically exerts less
specific control agent activity leaving work search process
performed gapps compiler example r program achieve goal p
implicitly specified following gapps rule
defgoalr ach p
holds p nil
holds regress p
ach regress p

recursion defined rule bottoms rules form
defgoalr ach
holds





conditions specific action
gapps compiles rules circuitry run time whereas circuit implementation r program depends parameters bound run time systems
control continuously responsive environment
implementing system play video game chapman chapman compiles
production rules digital circuitry real time control
calls arbitration macrology situated automata compilation process occurs
prior run time
brooks developed behavior language bl brooks writing reactive
robot control programs subsumption architecture brooks similar
language alfa implemented gat gat programs written


finilsson

languages compile structures much circuits compilation occurs prior
run time relatively straightforward translate examples subsumptionarchitecture programs r programs
circuit systems pre run time compiling means circuitry
must built might needed given run possible contingencies
must anticipated compile time r programs parameters bound run
time circuitry required specific bindings constructed
future work

r formalism might easily augmented embody features
discussed explicit reference time specifying actions might necessary
example might want make sure action initiated
time ceases time time predicates whose time terms evaluated
internal clock may suce purpose
applications may want control conditions r program
actually tested may example conditions checked
truth falsity guessed compelling accuracy
simultaneous asynchronous execution multiple actions achieved allowing right hand side rules contain sets actions member set
duratively executed asynchronously independently long condition
rule sustains set remains highest true condition course programmer
must decide conditions appropriate call parallel actions future
work related formalisms might reveal ways parallel actions might emerge
interaction program environment rather explicitly
programmed
although intend r programs agent control written human programmers interested methods modifying automatic
machine learning brie discuss preliminary ideas
learning
r trees resemble search trees constructed systems work
backwards goal condition overall goal root tree non root
node gi regression parent node gj action ak connecting
similarity suggests r trees constructed modified automatic
system capable regressing conditions durative actions indeed triangle
tables fikes hart nilsson degenerate form r tree consisting
single path constructed automatic system ebl style generalizer
mitchell keller kedar cabelli
reader might object reason suppose search trees produced automatic process contain nodes whose conditions
agent likely encounter behavior process incremental modification however gradually make constructed trees matched agent
environment tree achieving desired goal true nodes certain situation
agre running arguments construct agre one example circuit system
add circuitry run time needed



fiteleo reactive programs

search process employed automatic planner yet terminated
subgoal search tree satisfied current state case
system called upon continue search existing r tree
expanded true node produced pruning r trees accomplished
keeping statistics often nodes satisfied portions trees never
seldom used erased early unpublished work scott benson indicates r
programs effectively generated automatic methods benson
considering learning mechanisms note first r sequences related
class boolean functions rivest termed k decision lists rivest kohavi
benson k decision list ordered list condition value pairs
condition conjunction boolean variables length k value truth
value f value boolean function represented k decision list
value associated highest true condition rivest shown functions
polynomially pac learnable presented supervised learning procedure
see r sequence whose conditions limited k length conjunctions
boolean features slight generalization k decision lists difference
r sequence two different values actions
observe r sequence say n different actions pac learnable
since actions encoded log n decision lists george john john
investigated supervised learning mechanism learning r sequences
typically conditions used r programs conjunctions propositional features robot world model linear threshold function implement
conjunctions one led propose neural net implementation r sequence neural net implementation turn evokes ideas possible learning mechanisms consider
r sequence

k
k









ki



ai



km





suppose stipulate ki linear threshold functions set propositional
features ai necessarily distinct fact assume
k distinct actions let denoted b bk network structure figure
implements r sequence
propositional features tested conditions grouped n dimensional
binary vector x called input vector conditions implemented
threshold elements weighted connections components input vector
process finding first true condition implemented layer containing appropriate
inhibitory weights units one unit ever output
value unit corresponds first true condition unique action associated
condition layer binary valued weights unit associators


finilsson

inhibitory weights
weights

x

k

v

b

k

v

b





bi

v

ki





km
input
vector



bk

v

units

conditions

associators

actions


units

figure neural net implements r sequence
unit connected one one associator non zero weight since
one unit non zero output unit associator non zero
output associator could connected multiple units example
action bi associated conditions kj kl unit weights
j th l th units associator representing action bi zero valued weights
units associator action selected execution action
corresponding single associator non zero output investigating
learning methods suggested neural net implementation
work must done question constitutes goal assumed
goals achievement mechanisms found continously avoid making certain
conditions true false attempting achieve others suppose priorities
number possibly mutually contradictory conditions specified reasonable
methods attending achievable goals highest priorities
interesting ask sense r programs proved correct
would seem verification would make assumptions dynamics
environment environments might malevolent agents could never
achieve goals even verifier equipped model effects actions could
least check see regression property satisfied note lapses
work remains methods implementing interpreting r programs
real time properties implementations properties course depend
depth r program hierarchy conditions features must
evaluated


fiteleo reactive programs

finally might worthwhile investigate fuzzy versions r trees one could
imagine fuzzy predicates would energize actions strength depends
degree predicates true sri robot flakey uses fuzzy controller
saotti ruspini konolige
conclusions

presented formalism specifying actions dynamic uncertain domains since
work rests ideas somewhat different conventional computer science
expect considerably analysis experimentation required r
formalism fully evaluated need robotics control theoretic ideas
homeostasis continuous feedback stability appears suciently strong however
seems appropriate candidate formalisms embodying ideas put forward
consideration
experiments language produce stock advice write r
programs effectively already example apparent sustaining condition
r sequence must carefully specified restrictive really needs
overly restrictive condition likely rendered false action
supposed sustain action succeeds making higher condition
sequence true course overly restrictive conditions occur r programs
satisfy regression property
usefully employed r programs programs controlling agent action
need embodied overall agent architecture integrates perceptual processing
goal selection action computation environmental modeling learning
mechanisms several architectural schemes suggested summarize
except say three layers control often delineated typical example
sss architecture connell connell top symbolic layer overall
goal setting sequencing middle subsumption level selects specific actions
lower servo level exerts standard feedback control effectors believe r
programs would appropriately used middle level architectures
major limitation r programs involve much computation
programs check relevant conditions conditions computed
r program selecting action irrelevant situation hand
values might accurately predicted programmer wanted take trouble
essentially trading computing time ease programming
particular trade advantageous certain applications among think
mid level control robots possibly software agents
conclusion three main features embodied r formalism one
continuous computation parameters conditions action tr programs allow continuous feedback still supporting parameter binding
recursion second feature regression relationship conditions r
program condition regression condition closer goal
action normally achieves closer goal condition regression property
assures robust goal seeking behavior third conceptual circuitry controlling action
constructed run time feature permits programs universal still


finilsson

compact addition r programs intuitive easy write written
formalism compatible automatic learning methods
acknowledgements

trace interest reactive yet purposive systems early collaborative work
triangle tables ilas several former stanford students including jonas karlsson eric
ly rebecca moore mark torrance helped early stages work
want thank sabbatical hosts prof rodney brooks mit prof barbara grosz
harvard people santa fe institute recently benefitted
discussions scott benson george john ron kohavi thank anonymous
referees helpful suggestions work performed nasa grant ncc nsf grant iri
references

agre p dynamic structure everyday life tech rep tr ai lab
massachusetts institute technology
benson unpublished working robotics laboratory stanford university
berry g gonthier g esterel synchronous programming language
science computer programming november
brooks r robust layered control system mobile robot ieee journal
robotics automation march
brooks r behavior language user guide seymour implementation note
ai lab massachusetts institute technology
chapman vision instruction action tech rep ai lab massachusetts institute technology
connell j sss hybrid architecture applied robot navigation
report ibm division j watson center yorktown heights
ny
dean wellman control san francisco ca morgan kaufmann
drummond situated control rules proc first international conf principles knowledge representation reasoning san francisco ca morgan kaufmann
fikes r hart p nilsson n learning executing generalized robot plans
artificial intelligence
firby r investigation reactive complex domains proc
aaai san francisco ca morgan kaufmann


fiteleo reactive programs

galles map building following teleo reactive trees intelligent
autonomous systems ias groen f c hirose thorpe c e eds
washington ios press
gat e alfa language programming reactive robotic control systems
proceedings ieee robotics automation conference
georgeff lansky reactive reasoning proc aaai
san francisco ca morgan kaufmann
ginsberg l universal almost universally bad idea aaai
magazine winter
john g squish preprocessing method supervised learning r trees
solution paths unpublished robotics laboratory stanford university
kaelbling l p goals parallel program specifications proceedings aaai
menlo park ca american association artificial intelligence
kaelbling l p rosenschein j action embedded agents
robotics autonomous systems nos june
karlsson j building triangle action nets unpublished project
computer science dept stanford university june
kohavi r benson note decision lists machine learning

maes p right thing connection science
mitchell keller r kedar cabelli explanation generalization unifying view machine learning
nilsson n j principles artificial intelligence san francisco ca morgan kaufmann
nilsson n ed shakey robot tech note artificial intelligence center
sri international menlo park ca
nilsson n toward agent programs circuit semantics tech rep stan cs department computer science stanford university
ramadge p j g wonham w control discrete event systems
proceedings ieee january
reisig w petri nets introduction springer verlag
rivest r l learning decision lists machine learning


finilsson

rosenschein j kaelbling l p synthesis machines provable
epistemic properties proceedings conference theoretical aspects
reasoning knowledge halpern j ed san francisco ca morgan
kaufmann updated version technical note artificial intelligence center sri
international menlo park ca
saotti ruspini e konolige k integrating reactivity goaldirectedness fuzzy controller proc nd fuzzy ieee conference san
francisco ca
schoppers j universal plans reactive robots unpredictable domains
proceedings ijcai san francisco ca morgan kaufmann
selman b near optimal plans tractability reactivity tech rep ai dept
bell laboratories
teo p c botworld unpublished robotics laboratory computer science
dept stanford university december
teo p c botworld structures unpublished robotics laboratory computer
science dept stanford university june
waterman hayes roth f overview pattern directed inference
systems pattern directed inference systems waterman hayes roth f
eds york academic press
wilson animat path ai animals animats proceedings
first international conference simulation adaptive behavior meyer j
wilson eds cambridge mit press bradford books




