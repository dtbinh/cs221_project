Journal Artificial Intelligence Research 1 (1994) 139-158

Submitted 9/93; published 1/94

Teleo-Reactive Programs Agent Control
Nils J. Nilsson

nilsson@cs.stanford.edu

Robotics Laboratory, Department Computer Science
Stanford University, Stanford, CA 94305 USA

Abstract

formalism presented computing organizing actions autonomous agents
dynamic environments. introduce notion teleo-reactive (T-R) programs whose
execution entails construction circuitry continuous computation parameters conditions agent action based. addition continuous feedback,
T-R programs support parameter binding recursion. primary difference
T-R programs many circuit-based systems circuitry T-R programs
compact; constructed run time thus anticipate
contingencies might arise possible runs. addition, T-R programs
intuitive easy write written form compatible automatic
planning learning methods. brie describe experimental applications T-R
programs control simulated actual mobile robots.
1. Introduction

Autonomous agents, mobile robots, typically operate dynamic uncertain
environments. environments sensed imperfectly, effects
always completely predictable, may subject changes agent's
control. Designing agents operate environments presented challenges
standard methods artificial intelligence, based explicit declarative representations reasoning processes. Prominent among alternative approaches
so-called behavior-based, situated, animat methods (Brooks, 1986; Maes, 1989; Kaelbling & Rosenschein, 1990; Wilson, 1991), convert sensory inputs actions
much direct fashion AI systems based representation reasoning. Many
alternative approaches share control theory central notion continuous
feedback environment necessary component effective action.
Perhaps relatively easier control theorists computer scientists
deal continuous feedback control theorists accustomed thinking
controlling mechanisms composed analog electrical circuits physical
systems rather automata discrete read-compute-write cycles. notions
goal-seeking servo-mechanisms, homeostasis, feedback, filtering, stability|so essential
control dynamic environments|were developed analog circuitry mind.
Circuits, nature, continously responsive inputs.
contrast, central ideas computer science, namely sequences, events,
discrete actions, subroutines, seem odds notion continuous feedback.
example, conventional programming one program calls another, calling
program suspended called program returns control. feature awkward
applications called program might encounter unexpected environmental

c 1994 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiNilsson

circumstances designed cope. cases, calling program
regain control interrupts explicitly provided programmer.
sure, attempts blend control theory computer science.
example, work Ramadge Wonham (Ramadge & Wonham, 1989) discrete-event
systems used computer science notions events, grammars, discrete states
study control processes ideas appropriate. book Dean
Wellman (Dean & Wellman, 1991) focusses overlap control theory
artificial intelligence. little effort import fundamental control-theory
ideas computer science. precisely set paper.
propose computational system works differently conventional ones.
formalism call circuit semantics (Nilsson, 1992); program execution produces
(at least conceptually) electrical circuits, circuits used control.
importing control-theory concept continuous feedback, nevertheless want
retain useful ideas computer science. control programs parameters
bound run time passed subordinate routines. hierarchical
organization, recursive. contrast behavior-based
approaches, want programs responsive stored models environment
well immediate sensory inputs.
presentation ideas somewhat informal line belief
formalization best done certain amount experience obtained. Although
preliminary experiments indicate formalism works quite well, work remains
done establish place agent control.
2. Teleo-Reactive Sequences
2.1 Condition-Action Rules

teleo-reactive (T-R) sequence agent control program directs agent toward
goal (hence teleo) manner takes account changing environmental circumstances
(hence reactive). simplest form, consists ordered set production rules:

K1
K2

!
!

a1
a2

111

Ki

!

ai

111

Km

!



Ki conditions (on sensory inputs model world), ai
actions (on world change model). T-R sequence interpreted
manner roughly similar way production systems interpreted.
list rules scanned top first rule whose condition part satisfied,
corresponding action executed. T-R sequences differ substantively conventional
production systems, however. T-R actions durative rather discrete. durative
140

fiTeleo-Reactive Programs

action one continues indefinitely. example, mobile robot capable executing
durative action move, propels robot ahead (say constant speed) indefinitely.
action contrasts discrete one, move forward one meter. T-R
sequence, durative action continues long corresponding condition remains first
true condition. first true condition changes, action changes correspondingly.
Thus, unlike production systems computer science, conditions must continuously
evaluated; action associated currently first true condition always one
executed. action terminates energizing condition ceases
first true condition.
Indeed, rather thinking T-R sequences terms computer science idea
discrete events, appropriate think implemented circuitry.
example, sequence implemented circuit shown figure 1.
Furthermore, imagine conditions, Ki , continuously computed.
sensors

model

conditioncomputing
circuits

K1

a1


^

K2

a2



K3

^

a3

^





Km

Figure 1: Implementing T-R Sequence Circuitry
actions, ai , T-R sequence either primitive actions, T-R
sequences themselves. Thus, programs written formalism hierarchical (even
recursive, shall see later). case hierarchical programs, important
realize conditions levels hierarchy continuously evaluated;
high level sequence redirect control different path lower level sequences
dictated values conditions various levels.
141

fiNilsson

writing T-R sequence, programmer ordinarily works backward whatever goal
condition sequence designed achieve. condition K1 taken
goal condition, corresponding action, a1, null action. condition K2
weakest condition satisfied (and K1 not), durative execution
a2 (all things equal) eventually achieve K1 . on. non-null
action, ai , supposed achieve condition, Kj , strictly higher list (j < i).
conditions therefore regressions (Nilsson, 1980) higher conditions actions
achieve higher conditions.
Formally, say T-R sequence satisfies regression property condition,
> 1), regression higher condition sequence, Kj (j < i),
action ai . say T-R sequence complete K1 _ 1 1 1 _ Ki _
1 1 1 _ Km tautology. T-R sequence universal satisfies regression property
complete. easy see universal T-R sequence always achieve goal
condition, K1 , sensing execution errors.

Ki (m

Sometimes action effect anticipated agent's designer
(the normal effect), sometimes exogenous events (separate actions
agent) change world unexpected ways. phenomena, course, reason
continuous feedback required. Universal T-R sequences, universal plans (Schoppers,
1987), robust face occasional deviations normal execution.
exploit serendipitous effects; may accidentally happen action achieves
condition higher list condition/action rules normally expected. Even
action sometimes achieve normal effect (due occasional sensing execution
errors), nevertheless action executed. long environment
often frustrate achievement normal effects actions, goal condition
universal T-R sequence ultimately achieved.

2.2 Example

following rather simple example make ideas concrete. Consider
simulated robots figure 2. Let's suppose robots move bars around
two-dimensional world. robot right holding bar, want
robot go grab bar marked A. presume robot sense
environment evaluate conditions tell whether already grabbing
bar (is-grabbing), facing toward bar (facing-bar), positioned respect bar
reach grab (at-bar-center), perpendicular bisector bar
(on-bar-midline), facing zone perpendicular bisector bar
would appropriate move toward bar (facing-midline-zone). Let's assume
conditions appropriate amount hysteresis hunting behavior
dampened. Suppose robot capable executing primitive actions grab-bar, move,
rotate obvious effects. Execution following T-R sequence result
robot grabbing bar A:
142

fibar-midline



bar-center

midline-zone

Figure 2: Robots Bars
Notice properly executed action sequence achieves condition
rule it. way, actions inexorably proceed toward goal. Occasional
setbacks merely cause delays achieving goal long actions usually1 achieve
normal effects.
3. Teleo-Reactive Programs
3.1 Rules Variables

generalize notion T-R sequence permitting rules contain free
variables bound sequence \called." call sequence T-R
program. Additional generality obtained assume variables necessarily
bound constants quantities whose values continuously computed (as
circuitry) environment changes.
simple example involving robot go designated goal location two
dimensions serve illustrate. Suppose goal location given value
variable loc. run time, loc bound pair X; coordinates, although allow
binding change run time. time process, robot's X;
position given value variable position. (We assume robot
kind navigational aid reliably continuously computes value position.)
instantaneous values loc position, robot compute direction
1. choose define usually precisely here, although probabilistic analysis could given.

143

fiNilsson

face proceed straight line toward loc. Let value direction
time given value function course(position, loc). time
process, robot's angular heading given value variable heading. Using
variables, T-R program drive robot loc is:
goto(loc)
equal(position, loc)
equal(heading, course(position, loc))


!
!
!

nil
move
rotate

Implementing goto(loc) circuitry straightforward. single parameter
program loc whose (possibly changing) value specified run time user,
higher level program, circuitry. (global) parameters, position heading,
provided circuitry, assume function course continuously
computed circuitry. Given values parameters, computing action
energize computed circuitry manner figure 1.
3.2 Hierarchical Programs

formalism allows writing hierarchical recursive programs actions
rules T-R programs. example, write recursive navigation
program calls goto. new navigation program requires complex sensory
functions. Imagine function clear-path(place1, place2) value
direct path clear place1 place2. (We assume robot compute
function, continuously, place1 = position, place2 equal target location.)
imagine function new-point(place1, place2) computes intermediate position
place1 place2 whenever clear-path value . value newpoint lies appropriately side obstacle determined place1
place2 (so robot heads toward new-point first toward place2,
navigate around obstacle). clear-path new-point continuously computed
perceptual systems endow robot. We'll name new navigation
program amble(loc). code:
amble(loc)
equal(position, loc)
clear-path(position, loc)


!
!
!

nil
goto(loc)
amble(new-point(position, loc))

show figure 3 path robot controlled program might take
navigating around obstacles shown. (The program doesn't necessarily compute shortest
paths; present program simply illustration recursion.) Note
obstacle positions goal location change execution, changes ected
values parameters used program, program execution proceed
manner appropriate changes. particular, clear path ever becomes manifest
144

figoal location

Figure 3: Navigating using amble
continuous computation parameters involved T-R programs ability
high level programs redirect control account great robustness formalism.
formal syntax T-R programs given (Nilsson, 1992).
3.3 Implementational Issues

T-R formalism, implicit assumption continuous computation conditions
parameters, thought fully legitimate \level" hierarchy program
structure controlling agent, regardless level implemented levels below|
computer scientists think list processing level actual operation even though
implemented primitive logical operations below. assume (as do)
pace events agent's environment slow compared amount time
taken perform \continuous" computations required T-R program, T-R
programmer justified assuming \real" continuous sensing s/he writes programs (even
though underlying implentation may involve discrete sampling). recommend
T-R formalism applications assumption justified.
applications, T-R level shields programmer worry
level implemented greatly facilitates program construction.
several different ways T-R programs interpreted lower
level implementations. beyond scope paper point
obvious methods, leave important questions properties methods
subsequent research. One method implementation involves construction actual
simulated circuits according basic scheme figure 1. First, top level conditioncomputing circuits (including circuits computing parameters used conditions)
constructed allowed function. specific action, say ai , energized result. ai
145

fiNilsson

primitive, turned on, keeping circuitry place functioning
top-level action energized, on. ai T-R sequence, circuitry needed
implement constructed (just done top level), action selected,
on|and levels circuitry left functioning. new lower level
circuitry constructed, circuitry longer functioning (that is, circuitry longer
\called" functioning higher level circuitry) garbage collected.
important questions parameter passing timing process
deal here|relying assumption times needed create circuitry circuitry function negligible compared pace events
world. assumption similar synchrony hypothesis ESTEREL programming language (Berry & Gonthier, 1992) assumed program's reaction \. . .
takes time respect external environment, remains invariant [the
reaction]."
Although reason principle circuitry could simulated actually
constructed (using sort programmable network logic gates), straightforward implement T-R program using standard computational techniques. T-R
programs written LISP cond statements, durative actions simulated
iterating short action increments. example, increment move action
simulated robot might move robot ahead small amount. action
increment, top level LISP cond executed anew, course functions
parameters contains evaluated anew. simulations robots moving
two-dimensional worlds (to discussed below), computations involved suciently
fast effect reasonable pace apparent smooth motion.
implementation method essentially involves sampling environment irregular
intervals. course, questions concerning computation times (and thus
sampling rate) affect real-time aspects agent behavior address
here|again assuming sampling rate short.
Whatever method used interpret T-R programs, care must taken con ate
T-R level levels below. programmer ought think
circuit simulators sampling intervals imagine sensing done continuously
immediately.
3.4 Graphical Representations

goto program represented graph well list rules used earlier.
graphical representation program shown figure 4. nodes labeled
conditions, arcs actions. execute graphical version program,
look shallowest true node (taking goal condition root) execute
action labeling arc leading node.
graph figure 4, action normally achieves condition head arc
(when condition tail arc shallowest true condition).
one action achieve condition, would tree instead single-path
graph. general graph, then, teleo-reactive tree depicted figure 5.
T-R trees executed searching shallowest true node executing action
labeling arc leaving node. Alternatively, could search true node judged
146

fiTeleo-Reactive Programs

equal(position, loc)

move
equal(heading, course(position, loc))

rotate


Figure 4: Graphical Representation goto
path least cost goal, appropriate heuristic measure cost
used. [For simplicity, phrase \shallowest true node" taken mean either
shallowest true node (literally) true node path least cost goal.] Ties
among several equally shallow true nodes broken according fixed tie-breaking rule.
figure 5 see that, particular, least two ways achieve condition K1 .
One way uses action a2 (when K2 shallowest true node), one way uses action a3
(when K3 shallowest true node).
analogy definitions given T-R sequences, T-R tree satisfies regression
property every non-root node regression parent node action linking
parent. T-R tree complete disjunction conditions
tautology. T-R tree universal satisfies regression property
complete. fixed tie-breaking rule, T-R tree becomes T-R sequence.
T-R tree universal, corresponding T-R sequence.
One might first object method executing T-R tree grounds
sequence actions emerge hop erratically one path another.
tree satisfies regression property, heuristic measuring cost
goal reasonable, (however erratic actions may appear be), successfully
executed action brings agent closer goal.
4. Experiments

carried several preliminary experiments agents programmed language (using LISP cond statements short action increments). One set experiments
uses simulated robots acting two-dimensional space, called Botworld 2, construction
2. original Botworld interface, including primitive perceptual functions actions robots,
designed implemented Jonas Karlsson NeXT computer system (Karlsson, 1990). Sub-

147

fiNilsson

K1
a2

a3

K2

K3

Km -1

Km

Figure 5: T-R Tree
materials, structures made materials, robots. construction materials bars, robots build structures connecting bars various ways.
robot turn move, grab release suitably adjacent bar, turn move
grabbed bar, connect bar bars structures. robots continuously
sense whether holding bar, \see" front (giving
information location bars structures). existence
robots may change world sometimes unexpected ways, important
robot sense certain critical aspects environment continuously.
typical Botworld graphical display shown figure 6.
written various T-R programs cause robots build structures
various kinds (like triangle constructed figure 6). robot controlled one
programs exhibits homeostatic behavior. long main goal (whatever is)
satisfied, robot inactive. Whenever goal (for whatever reason) satisfied,
robot becomes active persists achieves goal. another agent achieves
part goal, robot carries appropriately situation finds
complete process.
experiments, conditions used T-R rules conditions model
environment robot constructs sensory system maintains separately
T-R mechanism. use model permits robot perform actions
response sensory stimuli (past present) used help construct
model. But, T-R actions include direct changes model (in addition
sequently, Patrick Teo implemented version runs X-windows several different workstations (Teo, 1991, 1992). latter version allows simulation several robots simultaneously|
control independently running process.

148

fiTeleo-Reactive Programs

Figure 6: Botworld Display
changes resulting perceived changes environment), potential
undesirable instabilities (as system positive feedback). (The problem
model environment model updated response sensory
data separate major research problem outside scope work reported here.)
experiments, used Nomadic Technologies 100 series mobile robot.
robot equipped ring 16 infrared sensors ring 16 sonar sensors.
controlled via radio modem Macintosh II running Allegro Common Lisp.
implemented robust T-R programs simple oce-environment tasks,
wall-following corridor-following (Galles, 1993). programs initially developed
debugged using Nomadics simulator actual robot; changes
made porting programs simulator robot. performing tasks,
robot highly reactive persistent even face occasional extreme sonar
infrared range errors deliberate attempts confuse it. robot quickly adapts
sudden changes environment, caused people sharing hallways.
writing T-R programs, one need concerned inventing appropriate
predicates using available perceptual functions model database. One need
worry providing interrupts lower level programs higher level ones regain
control. found debugging T-R programs presents challenges, though.
Since designed quite robust face environmental uncertainty,
sometimes work rather well even though completely debugged.
residual errors might undesirable effects programs used higher
level programs|making higher ones dicult debug.
149

fiNilsson

5. Approaches Specifying Behavior

several formalisms proposed prescribing sensory-directed, real-time
activity dynamic environments. closely related T-R formalism
proposed here. section point major similarities differences T-R
programs representative, though complete, sample closest relatives.
reactive formalisms two types, namely, sample environments
discrete intervals (perhaps rapidly enough suciently reactive),
create circuitry (like T-R programs). discrete-sampling systems abstract
activity higher level environment monitored continuously,
circuitry-creating systems prior run time (unlike T-R programs create
circuitry run time).
5.1 Discrete-Sampling Systems
5.1.1 Production Systems

already mentioned, T-R programs similar production systems (Waterman & Hayes-Roth, 1978). intermediate-level actions (ILAs) used SRI robot
Shakey (Nilsson, 1984) programmed using production rules much
T-R programs. T-R program resembles plan represented triangle-table form
constructed STRIPS (Fikes, Hart & Nilsson, 1972). conditions T-R
sequence corresponds triangle table kernel. PLANEX execution system triangle tables, action corresponding highest-numbered satisfied kernel executed.
major difference previous production-system style programs TR programs T-R programs continuously responsive environment
ordinary production systems not.
5.1.2 Reactive Plans

Several researchers adopted approach using current situation index
set pre-arranged action sequences (Georgeff & Lansky, 1987; Schoppers, 1987; Firby,
1987). set either large enough cover substantial number situations
agent likely find cover possible situations. latter
case, plan set said universal. Unlike T-R programs, systems explicitly
sample environments discrete time steps rather continuously. T-R
programs, time-space trade-offs must taken account considering many
different conditions must anticipated providing reactive plans. Ginsberg noted
several domains, number situations likely encountered agent
intractably large agent forced postpone planning run time
situations actually encountered (Ginsberg, 1989). (For discussion
point, see (Selman, 1993).) T-R programs advantage least rudimentary
form planning, namely parameter binding, done run time. PRS system (Georgeff
& Lansky, 1987) capable extensive planning run time well reacting
appropriately current situation.
150

fiTeleo-Reactive Programs

5.1.3 Situated Control Rules

Drummond (Drummond, 1989) introduces notion plan net kind Petri
net (Reisig, 1985) representing effects actions (which executed parallel).
Taking account possible interactions actions, projects effects
possible actions present state horizon. effects represented
structure called plan projection. plan projection analyzed see, state
it, states possibly path goal state. analysis forward version
backward analysis used programmer producing T-R tree. Situated control
rules result analysis; constrain actions might taken
state result state still possibly path goal. Plan
nets Petri nets based discrete events thus continuously responsive
environments way T-R programs are.
5.2 Circuit-Based Systems

Kaelbling proposed formalism called GAPPS (Kaelbling, 1988; Kaelbling & Rosenschein, 1990), involving goal reduction rules, implicitly describing achieve goals.
GAPPS programmer defines activity agent providing sucient goal reduction rules connect agent's goals situations might find itself.
rules compiled circuitry real-time control agent. Rosenschein
Kaelbling (Rosenschein & Kaelbling, 1986) call circuitry situated automata.
collection GAPPS rules achieving goal thought implicit
specification T-R program computations needed construct program
performed rules compiled. GAPPS programmer typically exerts less
specific control agent's activity|leaving work search process
performed GAPPS compiler. example, T-R program achieve goal, p ,
implicitly specified following GAPPS rule:
(defgoalr (ach ?p)
(if ((holds ?p) (do nil))
((holds (regress ?a ?p)) (do ?a))
(T ach (regress ?a ?p)) ))

recursion defined rule bottoms rules form:
(defgoalr (ach )
((holds

) (do

ff)) )

conditions specific action.
GAPPS compiles rules circuitry run time, whereas circuit implementation T-R program depends parameters bound run time. systems
result control continuously responsive environment.
implementing system play video game, Chapman (Chapman, 1990) compiles
production-like rules digital circuitry real-time control using approach
calls \arbitration macrology." situated automata, compilation process occurs
prior run time.
Brooks developed behavior language, BL, (Brooks, 1989), writing reactive
robot control programs based \subsumption architecture" (Brooks, 1986). similar
language, ALFA, implemented Gat (Gat, 1991). Programs written
151

fiNilsson

languages compile structures much circuits. Again, compilation occurs prior
run time. relatively straightforward translate examples subsumptionarchitecture programs T-R programs.
circuit-based systems, pre-run-time compiling means circuitry
must built might needed given run possible contingencies
must anticipated compile time.3 T-R programs, parameters bound run
time, circuitry required specific bindings constructed.
6. Future Work

T-R formalism might easily augmented embody features
discussed paper. Explicit reference time specifying actions might necessary.
example, might want make sure action initiated
time t1 ceases time t2. Time predicates, whose time terms evaluated
using internal clock, may suce purpose.
Also, applications may want control conditions T-R program
actually tested. may be, example, conditions won't checked
truth falsity guessed compelling accuracy.
Simultaneous asynchronous execution multiple actions achieved allowing right-hand side rules contain sets actions. member set
duratively executed asynchronously independently (so long condition
rule sustains set remains highest true condition). course, programmer
must decide conditions appropriate call parallel actions. Future
work related formalisms might reveal ways parallel actions might emerge
interaction program environment rather explicitly
programmed.
Although intend T-R programs agent control written human programmers, interested methods modifying automatic planning
machine learning. brie discuss preliminary ideas planning
learning here.
T-R trees resemble search trees constructed planning systems work
backwards goal condition. overall goal root tree; non-root
node gi regression parent node, gj action, ak , connecting them.
similarity suggests T-R trees constructed (and modified) automatic
planning system capable regressing conditions durative actions. Indeed triangle
tables (Fikes, Hart & Nilsson, 1972), degenerate form T-R tree consisting
single path, constructed automatic planning system EBL-style generalizer
(Mitchell, Keller & Kedar-Cabelli, 1986).
reader might object reason suppose search trees produced automatic planning process contain nodes whose conditions
agent likely encounter behavior. process incremental modification, however, gradually make constructed trees matched agent's
environment. tree achieving desired goal true nodes certain situation,
3. Agre's \running arguments" construct (Agre, 1989) one example circuit-based system
add circuitry run time needed.

152

fiTeleo-Reactive Programs

search process employed automatic planner yet terminated
subgoal search tree satisfied current state. case,
planning system called upon continue search; is, existing T-R tree
expanded true node produced. Pruning T-R trees accomplished
keeping statistics often nodes satisfied. Portions trees never
seldom used erased. Early unpublished work Scott Benson indicates T-R
programs effectively generated automatic planning methods (Benson, 1993).
considering learning mechanisms, note first T-R sequences related
class Boolean functions Rivest termed k-decision lists (Rivest, 1987; Kohavi &
Benson, 1993). k-decision list ordered list condition-value pairs
condition conjunction Boolean variables length k, value truth
value (T F ). value Boolean function represented k-decision list
value associated highest true condition. Rivest shown functions
polynomially PAC learnable presented supervised learning procedure them.
see T-R sequence whose conditions limited k-length conjunctions
Boolean features slight generalization k-decision lists. difference
T-R sequence two different \values" (that is, actions).
observe T-R sequence (with, say, n different actions) PAC learnable
since actions encoded log2 n decision lists. George John (John, 1993)
investigated supervised learning mechanism learning T-R sequences.
Typically, conditions used T-R programs conjunctions propositional features robot's world and/or model. linear threshold function implement
conjunctions, one led propose neural net implementation T-R sequence. neural net implementation, turn, evokes ideas possible learning mechanisms. Consider
T-R sequence:

K1
K2

!
!

a1
a2

111

Ki

!

ai

111

Km

!



Suppose stipulate Ki linear threshold functions set propositional
features. ai necessarily distinct; fact assume
k distinct actions. Let denoted b1; 1 1 1 ; bk . network structure figure
7 implements T-R sequence.
propositional features tested conditions grouped n-dimensional
binary (0,1) vector, X called input vector. conditions implemented
threshold elements weighted connections components input vector.
process finding first true condition implemented layer containing appropriate
inhibitory weights units one unit ever output
value 1, unit corresponds first true condition. unique action associated
condition layer binary-valued weights OR-unit associators.
153

fiNilsson

inhibitory weights
1 0 weights

X

K1

V

b1

K2

V

b2

...

...

bi

V

Ki

...

...

Km
input
vector

...
...
bk

V

units

conditions

associators

actions

(OR
units)

Figure 7: Neural Net Implements T-R Sequence
unit connected one one associator non-zero weight. Since
one unit non-zero output, unit's associator non-zero
output. (But associator could connected multiple units.) example,
action bi associated conditions Kj Kl , unit weights
j-th l-th units associator representing action bi zero-valued weights
units associator. action selected execution action
corresponding single associator non-zero output. investigating
various learning methods suggested neural net implementation.
Work must done question constitutes goal. assumed
goals achievement. mechanisms found continously avoid making certain
conditions true (or false) attempting achieve others? suppose priorities
number possibly mutually contradictory conditions specified; reasonable
methods attending achievable goals highest priorities?
Also, interesting ask sense T-R programs proved correct.
would seem verification would make assumptions dynamics
environment; environments might malevolent agents could never
achieve goals. Even so, verifier equipped model effects actions could
least check see regression property satisfied note lapses.
work remains methods implementing interpreting T-R programs
real-time properties implementations. properties will, course, depend
depth T-R program hierarchy conditions features must
evaluated.
154

fiTeleo-Reactive Programs

Finally, might worthwhile investigate \fuzzy" versions T-R trees. One could
imagine fuzzy predicates would energize actions \strength" depends
degree predicates true. SRI robot, Flakey, uses fuzzy controller
(Saotti, Ruspini & Konolige, 1993).
7. Conclusions

presented formalism specifying actions dynamic uncertain domains. Since
work rests ideas somewhat different conventional computer science,
expect considerably analysis experimentation required T-R
formalism fully evaluated. need robotics control-theoretic ideas
homeostasis, continuous feedback, stability appears suciently strong, however,
seems appropriate candidate formalisms embodying ideas put forward
consideration.
Experiments language produce stock advice write T-R
programs effectively. Already, example, apparent sustaining condition
T-R sequence must carefully specified restrictive really needs
be; overly restrictive condition likely rendered false action
supposed sustain action succeeds making higher condition
sequence true. But, course, overly restrictive conditions won't occur T-R programs
satisfy regression property.
usefully employed, T-R programs (or programs controlling agent action)
need embodied overall agent architecture integrates perceptual processing,
goal selection, action computation, environmental modeling, planning learning
mechanisms. Several architectural schemes suggested, summarize
except say three layers control often delineated. typical example
SSS architecture Connell (Connell, 1993). top (Symbolic) layer overall
goal setting sequencing, middle (Subsumption) level selects specific actions,
lower (Servo) level exerts standard feedback control effectors. believe T-R
programs would appropriately used middle level architectures.
major limitation T-R programs involve much computation
programs check relevant conditions. conditions computed
T-R program selecting action either irrelevant situation hand
values might accurately predicted (if programmer wanted take trouble
so). essentially trading computing time ease programming,
particular trade advantageous certain applications. Among these, think,
mid-level control robots (possibly) software agents.
conclusion, three main features embodied T-R formalism. One
continuous computation parameters conditions action based. TR programs allow continuous feedback still supporting parameter binding
recursion. second feature regression relationship conditions T-R
program. condition regression condition closer goal
action normally achieves closer-to-the-goal condition. regression property
assures robust goal-seeking behavior. Third, conceptual circuitry controlling action
constructed run time, feature permits programs universal still
155

fiNilsson

compact. addition, T-R programs intuitive easy write written
formalism compatible automatic planning learning methods.
Acknowledgements

trace interest reactive, yet purposive, systems early collaborative work
triangle tables ILAs. Several former Stanford students, including Jonas Karlsson, Eric
Ly, Rebecca Moore, Mark Torrance, helped early stages work.
want thank sabbatical hosts, Prof. Rodney Brooks MIT, Prof. Barbara Grosz
Harvard, people Santa Fe Institute. recently, benefitted
discussions Scott Benson, George John, Ron Kohavi. thank anonymous
referees helpful suggestions. work performed NASA Grant NCC2494 NSF Grant IRI-9116399.
References

Agre, P. (1989). Dynamic Structure Everyday Life. Tech. rep. TR 1085, AI Lab.,
Massachusetts Institute Technology.
Benson, S. (1993). Unpublished working paper. Robotics Laboratory, Stanford University.
Berry, G., & Gonthier, G. (1992). ESTEREL Synchronous Programming Language.
Science Computer Programming, 19, no. 2, 87-152, November.
Brooks, R. (1986). Robust Layered Control System Mobile Robot. IEEE Journal
Robotics Automation, March.
Brooks, R. (1989). Behavior Language User's Guide. Seymour Implementation Note 2,
AI Lab., Massachusetts Institute Technology.
Chapman, D. (1990). Vision, Instruction Action. Tech. rep. 1204, AI Lab., Massachusetts Institute Technology.
Connell, J. (1993). SSS: Hybrid Architecture Applied Robot Navigation. Research
Report, IBM Research Division, T. J. Watson Research Center, Yorktown Heights,
NY 10598.
Dean, T., & Wellman, M. (1991). Planning Control. San Francisco, CA: Morgan Kaufmann.
Drummond, M. (1989). Situated Control Rules. Proc. First International Conf. Principles Knowledge Representation Reasoning. San Francisco, CA: Morgan Kaufmann.
Fikes, R., Hart, P., & Nilsson, N. (1972). Learning Executing Generalized Robot Plans.
Artificial Intelligence, 3, 251-288.
Firby, R. (1987). Investigation Reactive Planning Complex Domains. Proc.
AAAI-87. San Francisco, CA: Morgan Kaufmann.
156

fiTeleo-Reactive Programs

Galles, D. (1993). Map Building Following Using Teleo-Reactive Trees. Intelligent
Autonomous Systems: IAS-3, Groen, F. C. A., Hirose, S. & Thorpe, C. E. (Eds.),
390-398. Washington: IOS Press.
Gat, E. (1991). ALFA: Language Programming Reactive Robotic Control Systems.
Proceedings 1991 IEEE Robotics Automation Conference.
Georgeff, M., & Lansky, A. (1989). Reactive Reasoning Planning. Proc. AAAI-87.
San Francisco, CA: Morgan Kaufmann.
Ginsberg, M. L. (1989). Universal Planning: (Almost) Universally Bad Idea. AAAI
Magazine, 10, no. 4, 40-44, Winter.
John, G. (1993). `SQUISH: Preprocessing Method Supervised Learning T-R Trees
Solution Paths, (unpublished). Robotics Laboratory, Stanford University.
Kaelbling, L. P. (1988). Goals Parallel Program Specifications. Proceedings AAAI-88,
60-65. Menlo Park, CA: American Association Artificial Intelligence.
Kaelbling, L. P., & Rosenschein, S. J. (1990). Action Planning Embedded Agents.
Robotics Autonomous Systems, 6, nos. 1 2, 35-48, June.
Karlsson, J. (1990). Building Triangle Using Action Nets. Unpublished project paper.
Computer Science Dept., Stanford University. June.
Kohavi, R., & Benson, S. (1993). Research Note Decision Lists. Machine Learning, 13,
131-134.
Maes, P. (1989). Right Thing. Connection Science, 1, no.3, 291-323.
Mitchell, T. M., Keller, R. M., & Kedar-Cabelli, S. T. (1986). Explanation-based Generalization: Unifying View. Machine Learning, 1, 47-80.
Nilsson, N. J. (1980). Principles Artificial Intelligence. San Francisco, CA: Morgan Kaufmann.
Nilsson, N. (Ed.) (1984). Shakey Robot. Tech. Note 323, Artificial Intelligence Center,
SRI International, Menlo Park, CA 94025.
Nilsson, N. (1992). Toward Agent Programs Circuit Semantics. Tech. rep. STAN-CS92-1412, Department Computer Science, Stanford University.
Ramadge, P. J. G., & Wonham, W. M. (1989). Control Discrete Event Systems.
Proceedings IEEE, 77, no. 1, 81-98, January.
Reisig, W. (1985). Petri Nets: Introduction, Springer Verlag.
Rivest, R. L. (1987). Learning Decision Lists. Machine Learning, 2, 229-246.
157

fiNilsson

Rosenschein, S. J. & Kaelbling, L.P. (1986). Synthesis Machines Provable
Epistemic Properties. Proceedings 1986 Conference Theoretical Aspects
Reasoning Knowledge. Halpern, J. (Ed.), 83-98, San Francisco, CA: Morgan
Kaufmann. (Updated version: Technical Note 412, Artificial Intelligence Center, SRI
International, Menlo Park, CA.)
Saotti, A., Ruspini, E., & Konolige, K. (1993). Integrating Reactivity Goaldirectedness Fuzzy Controller. Proc. 2nd Fuzzy-IEEE Conference, San
Francisco, CA.
Schoppers, M. J. (1987). Universal Plans Reactive Robots Unpredictable Domains.
Proceedings IJCAI-87. San Francisco, CA: Morgan Kaufmann.
Selman, B. (1993). Near-Optimal Plans, Tractability, Reactivity. Tech. rep., AI Dept.,
AT&T Bell Laboratories.
Teo, P. C-S. (1991). \Botworld," (unpublished). Robotics Laboratory, Computer Science
Dept., Stanford University, December.
Teo, P. C-S. (1992). Botworld Structures, (unpublished). Robotics Laboratory, Computer
Science Dept., Stanford University, June.
Waterman, D. A. & Hayes-Roth, F. (1978). Overview Pattern-Directed Inference
Systems. Pattern-Directed Inference Systems, Waterman, D. A. & Hayes-Roth, F.
(Eds.), 3-22. New York:Academic Press.
Wilson, S. (1991). Animat Path AI. Animals Animats; Proceedings
First International Conference Simulation Adaptive Behavior, Meyer, J.
A., & Wilson, S. (Eds.). Cambridge, MA: MIT Press/Bradford Books.

158


