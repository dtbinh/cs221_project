journal artificial intelligence

submitted published

approximate model diagnosis
greedy stochastic search
alexander feldman

b feldman tudelft nl

delft university technology
mekelweg cd delft netherlands

gregory provan

g provan cs ucc ie

university college cork
college road cork ireland

arjan van gemund

j c vangemund tudelft nl

delft university technology
mekelweg cd delft netherlands

abstract
propose stochastic fault diagnosis called safari trades
guarantees computing minimal diagnoses computational efficiency empirically
demonstrate xxx iscas suites benchmark combinatorial circuits
safari achieves several orders magnitude speedup two well known deterministic cda ha multiple fault diagnoses safari compute
range multiple fault diagnoses cda ha cannot prove safari
optimal range propositional fault widely used weak fault
ignorance abnormal behavior discuss optimality safari class strong fault circuit stuck failure modes modeling
markov chain provide exact bounds minimality diagnosis computed safari displays strong anytime behavior return diagnosis
non trivial inference time

introduction
model diagnosis mbd area artificial intelligence uses system model
together observations system behavior isolate sets faulty components diagnoses explain observed behavior according minimality criterion
standard mbd formalization reiter frames diagnostic terms set
logical clauses include mode variables describing nominal fault status
system components diagnostic status system computed given
observation systems sensors mbd provides sound complete
enumerating multiple fault diagnoses exact guarantee finding diagnosis optimal respect number faulty components probabilistic likelihood
etc
biggest challenge impediment industrial deployment computational
complexity mbd mbd determining exists diagnosis k faults np hard arbitrary propositional consider
article bylander allemang tanner josephson friedrich gottlob nejdl
computing set diagnoses harder still since possibly exponenc

ai access foundation rights reserved

fifeldman provan van gemund

tially many diagnoses since almost proposed mbd complete
exact authors proposing possible trade offs completeness faster
consistency checking employing methods bcp williams ragno
complexity still remains major challenge mbd
overcome complexity propose novel approximation
multiple fault diagnosis stochastic safari stochastic fault diagnosis sacrifices guarantees optimality diagnostic systems
faults described terms arbitrary deviation nominal behavior safari
compute diagnoses several orders magnitude faster competing
contributions follows introduces approximation
computing diagnoses within mbd framework greedy stochastic
compute minimal cardinality diagnoses weak fault
polynomial time calling incomplete sat solver implements boolean constraint
propagation bcp general frameworks sub class strong
fault amenable class model safari search
markov chain performance optimality trade offs makes
apply suite benchmark combinatorial circuits demonstrating order magnitude speedup two state art deterministic cda
ha multiple fault diagnoses compare performance safari
range max sat benchmark indicate
whereas search complexity deterministic tested increases exponentially fault cardinality search complexity stochastic appears
independent fault cardinality safari great practical significance
compute large fraction minimal cardinality diagnoses discrete systems large
complex diagnosed existing deterministic

technical background
discussion continues formalizing mbd notions uses traditional
diagnostic definitions de kleer williams except use propositional logic
terms conjunctions literals instead sets failing components
central mbd model artifact represented propositional formula
set variables discerning two subsets variables assumable observable
variables gives us diagnostic system
definition diagnostic system diagnostic system ds defined triple ds
hsd comps obsi sd propositional theory set variables v comps
v obs v comps set assumables obs set observables
throughout assume obs comps sd
propositional theories used system descriptions interest mbd diagnostic systems characterized restricted set restriction making
formulae conjunctive normal form cnf bcp implemented unit resolution
rule
mbd literature assumable variables referred component failure mode
health variables observable variables called measurable control variables



fiapproximate model diagnosis greedy stochastic search

computing diagnosis amenable one presented
consider two main classes
definition weak fault model diagnostic system ds hsd comps obsi belongs
class wfm iff comps h h hn sd equivalent h f h
f hn fn comps v v set variables appearing
propositional formulae f f fn
note conventional selection sign health variables h h hn alternatively negative literals e g f f fn used express faults case
weak fault model form f f fn fn authors use ab
abnormal ok healthy
weak fault sometimes referred ignorance abnormal
behavior de kleer mackworth reiter implicit fault systems alternatively
model may specify faulty behavior components following definition
aim simplifying formalism throughout adopt slightly restrictive
representation faults allowing single fault mode per assumable variable
easily generalized introducing multi valued logic suitable encodings hoos
definition strong fault model diagnostic system ds hsd comps obsi belongs
class sfm iff sd equivalent h f h f hn fn
hn fn j n k hi comps f j k propositional
formula none hi appears fj k
membership testing wfm sfm classes performed efficiently many
cases example model represented explicitly def def
running example
use boolean circuit shown fig running example illustrating
notions subtractor shown consists seven
components inverter two gates two xor gates two gates expression
h normative healthy behavior inverter variables
h represent input output health respectively similarly gate modeled
h gate h finally xor gate specified
h
propositional formulae copied gate fig variables
renamed way properly connect circuit disambiguate assumables
thus obtaining propositional formula boolean subtractor given
sdw h p h x h j p
h l j h b k h x l
h k p



strong fault model boolean circuit shown fig constructed assigning
fault modes different gate types assume malfunctioning
output xor gate value one inputs gate stuck one


fifeldman provan van gemund

x

p

h

h



j

h



h

b

h

l

h

h



k

figure subtractor circuit
gate stuck zero inverter behaves buffer gives us
following strong fault model formula boolean subtractor circuit
sds sdw h h x h j
h h b h x l h k



sds sdw set assumable variables comps h h h
set observable variables obs x p b
diagnosis minimal diagnosis
traditional query mbd computes terms assumable variables explanations system description observation
definition health assignment given diagnostic system ds hsd comps obsi
assignment variables comps defined health assignment
health assignment conjunction propositional literals cases convenient use set negative positive literals two sets denoted
lit lit respectively
example nominal assignment h h h health
assignment h h h h h h h means two gates fig
malfunctioning follows formal definition consistency diagnosis
definition diagnosis given diagnostic system ds hsd comps obsi observation instantiation variables obs health assignment
diagnosis iff sd
traditionally authors de kleer williams arrive minimal diagnosis computing minimal hitting set minimal conflicts broadly minimal health assignments
incompatible system description observation makes
use conflicts hence equivalent direct definition
total possible diagnoses given sdw observation x p
b example diagnoses h h h h h h h
trivially given weak fault model faulty health assignment example


fiapproximate model diagnosis greedy stochastic search

h h diagnosis instantiation observable variables obs
cf def
analysis need opposite notion diagnosis e health
assignments inconsistent model observation mbd literature
assignments usually called conflicts conflicts however necessarily instantiate
variables comps use full health instantiations use
term conflict avoided prevent confusion
mbd literature range types preferred diagnosis proposed
turns mbd optimization following definition
consider common subset ordering
definition minimal diagnosis diagnosis defined minimal diagnosis
exists lit lit
consider weak fault model sdw circuit shown fig observation
x p b example two minimal diagnoses
h h h h h h h h h h h h diagnosis
h h h h h h h non minimal negative literals form
subset negative literals
note set minimal diagnoses characterizes diagnoses weak fault
model hold general strong fault de kleer et al
latter case faulty components may exonerate resulting health
assignment containing proper superset negative literals another diagnosis
diagnosis example given sds x p b follows
h h h h h diagnosis h h h h h
diagnosis despite fact negative literals form superset
negative literals
definition number minimal diagnoses let set sd contain minimal diagnoses system description sd observation number minimal
diagnoses denoted sd defined cardinality sd
continuing running example sdw sds number
non minimal diagnoses sdw
definition cardinality diagnosis cardinality diagnosis denoted
defined number negative literals
diagnosis cardinality gives us another partial ordering diagnosis defined minimal
cardinality iff minimizes number negative literals
definition minimal cardinality diagnosis diagnosis defined minimalcardinality diagnosis exists
cardinality minimal cardinality diagnosis computed system description sd
observation denoted mincard sd example model sdw
observation x p b follows mincard sdw note
case minimal diagnoses minimal cardinality diagnoses


fifeldman provan van gemund

minimal cardinality diagnosis minimal diagnosis opposite need hold
general case minimal diagnoses minimal cardinality diagnoses consider example sdw given earlier section two resulting
minimal diagnoses two minimal cardinality diagnosis
definition number minimal cardinality diagnoses let set sd contain minimal cardinality diagnoses system description sd observation
number minimal cardinality diagnoses denoted sd defined
cardinality sd
computing number minimal cardinality diagnoses running example
sdw sds sdw
converting propositional formulae clausal form
related satisfiability safari uses sat solver sat solvers commonly accept input conjunctive normal form cnf although exist sat
solvers work directly propositional formulae thiffault bacchus walsh
converting propositional formula cnf done tseitin without
forbus de kleer introduction intermediate variables cases important structural information lost may lead performance degradation
checking formula consistent computing solution
lemma fault model sd f f fn sd wfm sd sfm
n comps component variables converted cnf time comps
time converting largest subformula n cnf
proof sketch conversion sd cnf done converting subformula
cnf concatenating resulting cnfs final cnf equivalent sd
complexity n complexity worst case
largest number variables subformula total time
converting sd dominated linear comps
lemma useful cases subformula small case many
practical situations sd composed small component case
experimental benchmark cf sec model combinational circuit
conjunction fault simple logic gates x bit gates typically x
xor gates etc ideally safari would use non cnf sat solver practical reasons
constrained reasoning diagnostic concise cnf encodings
consider example formula x x xn yn
disjunctive normal form dnf converted cnf n clauses although
similar examples propositional formulae exponentially many clauses cnf
representations easy artificial rarely encountered mbd
furthermore boolean circuits tested performance safari
exponential blow converted cnf
note dnf formulae propositional formulae



fiapproximate model diagnosis greedy stochastic search

complexity diagnostic inference
section discusses complexity interested namely
computing single set minimal diagnoses two minimality
criteria subset minimality cardinality minimality assume input cnf
formula defined variable set v comps assumable fault
variables table introduces notation use define types diagnosis
table summary definitions types diagnosis interest
symbol

diagnoses











preference criterion





subset minimality
cardinality minimality
subset minimality
cardinality minimality

complexity computing set diagnoses harder computing single
diagnosis since number diagnoses worst case exponential input size
number components bounded counting
number diagnoses shown co np complete hermann
pichler
restrict clauses horn definite horn reduce complexity
solving expense decreased model expressiveness
horn clause restriction sd wfm determining first minimal diagnosis exists
p restriction sd sfm deciding first minimal diagnosis
exists np hard friedrich et al cases sd wfm sfm deciding
next diagnosis exists np hard
diagnosis interest article intractable worst case
complexity closely related propositional abduction paps
studied eiter gottlob propositional pap
determining solution exists p complete computing minimal diagnosis
search hence difficult pose decision question proving
complexity consequently one note computing diagnosis minimal
respect requires log comps calls np oracle eiter gottlob
asking oracle step diagnosis containing k faulty components
exists
abduction indicate task approximate diagnosis intractable roth addressed abductive inference approximating inference roth focuses counting number satisfying assignments
range ai including instances paps addition roth shows
approximating number satisfying assignments intractable
abdelbar studied complexity approximating horn abduction
showing even particular horn restriction propositional interest
approximation intractable particular abduction
costs assigned assumables used model preference ordering


fifeldman provan van gemund

examined complexity finding least cost proof lcp evidence
obs cost proof taken sum costs hypotheses
must assumed order complete proof shown
np hard approximate lcp within fixed ratio r cost optimal solution
r
safari approximates intractable denoted table
wfm safari efficiently compute single diagnosis minimal
satisfiability oracle sd sfm safari generates sound possibly sub optimal
diagnosis set diagnoses referred papers indicating intractable
approximate within fixed ratio minimal diagnosis following adopt
stochastic cannot provide fixed ratio guarantees however safari trades
optimality efficiency compute diagnoses high likelihood

stochastic mbd
section discuss computing multiple fault diagnoses stochastic search
simple example continued
consider boolean subtractor shown fig weak fault model sdw given
observation preceding section four minimal diagnoses associated
sdw h h h h h h h h h h h h h h
h h h h h h h h h
nave deterministic would check consistency comps possible health assignments diagnostic case running example
furthermore deterministic first enumerate health assignments small
cardinality high priori probability renders impractical
situations minimal diagnosis higher cardinality performance
surprising even state art mbd utilize example conflict learning partial compilation considering bad worst case complexity finding
minimal diagnoses cf sec
follows two step diagnostic process requires fewer consistency checks first step involves finding random non minimal diagnosis starting
point cf sec details computing random sat solutions equal likelihood
second step attempts minimize fault cardinality diagnosis repeated
modification diagnosis
first step one random possibly non minimal diagnosis sdw
diagnosis obtain classical dpll solver modifying two ways
determine instance satisfiable extract satisfying solution
random satisfiable solution every time solver invoked modifications
trivial dpll solvers typically store current variable assignments easy
choose variable value randomly according uniform distribution instead
deterministically branching latter modification may possibly harm dpll
variable value selection heuristics later see


fiapproximate model diagnosis greedy stochastic search

concern type considering diagnostic systems typically
underconstrained
subtractor example call dpll solver sdw input
consider random solution obviously diagnosis h h h h h
h h second step stochastic try minimize
repetitively choosing random negative literal flipping value positive thus
obtaining candidate smaller number faults calling dpll solver
candidate diagnosis try improve newly discovered diagnosis
otherwise mark attempt failure choose another negative literal
constant number failures two example terminate search
store best diagnosis discovered far process
changing sign h discover health assignment
consistent sdw hence diagnosis discard instead
attempts changing h h time successfully obtaining
diagnosis h h h h h h h cardinality next
tries diagnosis even smaller cardinality randomly choosing h h
respectively trying change sign attempts return inconsistency
hence climb aborted stored current best diagnosis
repeating process another random initial dpll solution gives us diagnosis h h h h h h h changing sign h leads
inconsistency next two flips h h lead double fault diagnosis
h h h h diagnosis improved
minimal hence next two attempts improve fail stored
process illustrated fig search left right
gates shown solid black suspected faulty health assignment
participate tested consistency inconsistent candidates crossed
let us consider found two diagnoses
minimal diagnosis done price calls dpll subroutine
suboptimal diagnosis value cardinality near one minimal
diagnosis hence demonstrated way approximation minimal
diagnoses drastically reducing number consistency checks comparison
deterministic sacrificing optimality next formalize experience
behavior analyze extensively section follows
diagnosing strong fault model known strictly difficult weak fault
model friedrich et al many diagnostic instances alleviated
fact exist although without guarantee continuities diagnostic search
space similar one weak fault let us discuss process finding
minimal diagnosis subtractors strong fault model sds observation
sec
six distinct diagnoses sds shown fig
minimal visible fig diagnoses
component variables h h false h h true healthy hence
satisfying assignment sds would contain h h h h starting
maximal cardinality diagnosis must flip variables h h h order
reach two minimal diagnoses key insight shown fig


fifeldman provan van gemund

figure example stochastic diagnostic process
h



h




h

h

h

h

h

h

























h

h

h

h

h

h

























h



h




h

h

h

h

h

h

























h

h

h

h

h

h

























figure diagnoses strong fault model
possible flipping single literal time health faulty receiving another
consistent assignment diagnosis
follows formalize experience far stochastic
finding minimal diagnoses
greedy stochastic
shows pseudocode safari


fiapproximate model diagnosis greedy stochastic search

safari greedy stochastic hill climbing approximating
set minimal diagnoses
function safari ds n returns trie
inputs ds hsd comps obsi diagnostic system
term observation
integer climb restart limit
n integer number tries
local variables sdcnf cnf
n integers
terms
r set terms

sdcnf wfftocnf sd

n n

randomdiagnosis sdcnf
get random sat solution





improvediagnosis
flip unflipped health variable


sdcnf
consistency check





else

mm

end

end

unless issubsumed r

addtotrie r

removesubsumed r

end unless

end

return r
end function

safari accepts two input parameters n n independent searches
start randomly generated starting points tries improve
cardinality initial diagnoses preserving consistency randomly flipping fault literals change sign literal done one direction faulty
healthy attempt minimal diagnosis terminates unsuccessful attempts improve current diagnosis stored thus increasing lead
better exploration search space possibly diagnoses lower cardinality
decreasing improve overall speed
safari uses number utility functions wfftocnf converts propositional
formula sd cnf cf sec improvediagnosis subroutine takes term
argument changes sign random negative literal negative
literals function returns original argument


fifeldman provan van gemund

implementation randomdiagnosis uses modified dpll solver returning
random sat solution sd consider original dpll davis logemann
loveland without unit resolution rule one event
branching chooses unassigned variables polarity equal
probability dpll equally likely compute satisfiable solution
exists note order variables assigned matter course
dpll may end partial assignment e variables
dont care partial assignment extended
full satisfiable assignment randomly choosing signs unassigned variables
uniform distribution taking consideration unit resolution rule
change likelihood modified dpll solver finding particular solution
changes order variables assigned formal proof modified
dpll solver computes sat assignment equal probability beyond scope
idea build probabilistic model progress dpll solver
probabilistic model balanced tree nodes iterate branching performing
unit resolution assigning values zero unit clauses branching probability
set equal leaf nodes sat solutions equal depth one
equal likelihood arriving sat solution date sat solvers
dpll creating randomized dpll solver computes satisfiable solution
equal probability difficult course random polarity decisions may effect negatively
branching heuristics marques silva analysis beyond scope

similar deterministic methods mbd safari uses sat procedure
checking consistency sd increase implementation efficiency safari
combine bcp ltms engine mcallester full fledged dpll solver
two stage consistency checking experimentation shows combining ltms dpll
way allows order magnitude safari speed compared pure dpll
soundness completeness properties consistency checking preserved
implemented two stage consistency checking follows first safari calls
bcp ltms forbus de kleer check sd
unsat candidate diagnosis ltms unsat
means consistency candidate unknown call complete dpll
engine needed full dpll checking use posit freeman minisat
een sorensson
safari benefits two stage sat procedure typical mbd instance
involves many consistency checks comps n comps sd
change search time small number assumption clauses
updated incremental nature ltms greatly improves search efficiency
even though dpll running time per instance ltms dpll performs
bcp unit propagation dpll construction expensive avoided
possible dpll initialization typically slow involves building data structures
clauses variables counting literals initializing conflict databases etc
hand implementation ltms incremental reinitialized
shown bcp consistency check sd returns unsat formula
unsat opposite necessarily true



fiapproximate model diagnosis greedy stochastic search

consistency check efficient maintains counters clause
counter keeps number unassigned literals assigning value variable
requires decrementing clause counters counter becomes zero
contradiction handler signaled
guarantee two diagnostic searches starting random diagnoses
would lead minimal diagnosis prevent store generated
diagnoses trie r forbus de kleer straightforward extract
resulting diagnoses recursively visiting nodes diagnosis added trie r
function addtotrie iff subsuming diagnosis contained r issubsumed
subroutine checks condition adding diagnosis resulting trie r
diagnoses contained r subsumed removed call removesubsumed
basic properties greedy stochastic search
continue topics completeness optimality safari
sound e returns diagnoses
lemma soundness safari sound
proof sketch consistency check line alg guarantees terms
holds sd added set r according def
terms diagnoses
one key factors success proposed exploitation
continuity search space diagnosis continuity mean
monotonically reduce cardinality non minimal diagnosis exploitation continuity property safari configured guarantee finding minimal
diagnosis weak fault polynomial number calls satisfiability oracle
hypothesis comes next well studied prior work de kleer et al
determines conditions minimal diagnoses represent diagnoses
model observation interested hypothesis computational
viewpoint defines class possible establish theoretical bound
optimality performance safari
hypothesis minimal diagnosis hypothesis let ds hsd comps obsi diagnostic system diagnosis arbitrary observation minimal diagnosis hypothesis mdh holds ds iff health assignment lit lit
diagnosis
easy mdh holds weak fault theories
sd wfm mdh holds e g one directly construct theory conjunction
terms mdh holds unfortunately necessary condition known mdh
hold arbitrary sd lemma comes next direct consequence mdh
weak fault
lemma given diagnostic system ds hsd comps obsi sd wfm
diagnosis observation follows non minimal iff another diagnosis
obtained changing sign exactly one negative literal


fifeldman provan van gemund

proof sketch def sd wfm follows minimal diagnosis
diagnosis obtained flipping one positive literal diagnosis applying
argument direction gives us statement
safari operates performing subset flips non minimal diagnoses attempting compute minimal diagnoses next formalize notion flips order characterize
safari able compute minimal diagnosis
definition subset flip given diagnostic system ds hsd comps obsi
health assignment non empty set negative literals lit subset
flip turns one negative literals positive literal e creates health
assignment one positive literal
next characterize flips whether produce consistent flip
definition valid subset flip given diagnostic system ds hsd comps obsi
observation non minimal diagnosis valid flip exists perform
subset flip create sd
given notions define continuity diagnosis search space terms literal
flipping
definition continuity system model sd observation satisfy continuity
property respect set diagnoses sd iff diagnosis k sd
exists sequence h k k k n
n possible go via valid subset flip sd
n sd
definition allows trivial continuity cases model observation lead minimal diagnoses non minimal diagnoses see sec
observations diagnoses minimal rare practice course
created artificially note safari still works
theoretical properties preserved even case trivial continuity
given def easily following two lemmata
lemma sd satisfies mdh satisfies continuity property
proof follows directly hypothesis def
lemma sd wfm satisfies continuity property
proof sketch straightforward sd wfm sd satisfies mdh
lemma follows sd satisfies continuous property
greedy starts initial diagnosis randomly flips faulty assumable variables use mdh property starting non minimal
diagnosis greedy stochastic diagnosis monotonically reduce size
seed diagnosis obtain minimal diagnosis appropriately flipping fault
variable faulty healthy view flipping search search continuous diagnosis space


fiapproximate model diagnosis greedy stochastic search

proposition given diagnostic system ds hsd comps obsi observation
sd wfm safari configured comps n returns one minimal
diagnosis
proof diagnosis improvement loop starts worst case health assignment
conjunction negative literals necessarily case diagnosis
sd wfm diagnosis subsumed would found
consistency checks provided exists set equal number literals
repetitions randomly choosing literal flip next
trying negative literals diagnosis lemma follows
minimal diagnosis
simple inductive argument continue process obtain
minimal diagnosis
proposition follows upper bound comps consistency
checks finding single minimal diagnosis practical cases however
interested finding approximation minimal cardinality diagnoses
complexity optimally configured safari becomes comps
number minimal cardinality diagnoses given observation section
discusses detail computation multiple minimal cardinality diagnoses
number assumable variables system practical significance may exceed
thousands rendering optimally configured safari computationally expensive
sec see computationally efficient configure comps
still possible minimal diagnosis high probability
simple flip search complete continuous diagnosis search spaces given weak fault e sd wfm follow
mdh e lemma formally characterize guarantee finding minimal diagnosis safari terms continuous diagnosis space note sufficient
necessary condition example may configure safari flip multiple literals
time circumvent getting trapped discontinuous diagnosis spaces
theorem given diagnostic system ds hsd comps obsi starting diagnosis
safari configured comps n guaranteed compute minimal
diagnosis diagnosis space continuous
proof given initial diagnosis safari attempts compute minimal diagnosis
performing subset flips diagnosis space continuous know exists
sequence valid flips leading minimal diagnosis hence safari guaranteed
minimal diagnosis
finally safari provides strong probabilistic guarantee computing
minimal diagnoses
theorem probability safari configured comps computing
minimal diagnoses diagnostic system ds hsd comps obsi observation
denoted pr given continuous diagnosis space sd holds pr
n


fifeldman provan van gemund

proof sketch since search space continuous step non zero
probability flipping unflipped literal polynomial upper bound
steps comps computing diagnosis safari compute non minimal diagnosis
non zero probability hence n safari compute minimal diagnoses

complexity inference greedy stochastic search
next look complexity safari stochastic computing sound
incomplete diagnoses primary determinant inference complexity consistency checking safari randomly computes partial assignment
checks extended create satisfying assignment consistency
check e checks consistency sd solving satisfiability sat np complete cook use incomplete
satisfiability checking reduce complexity cost completeness guarantees
following call complexity consistency check assume
components fail e comps
lemma given diagnostic system ds hsd comps obsi sd wfm
worst case complexity finding minimal diagnosis cost
consistency check
proof upper bound succeeding consistency checks finding single
minimal diagnosis since maximum steps computing healthy
diagnosis safari performs consistency check flip step
must flip literals total complexity
practical cases however interested finding approximation minimal cardinality diagnoses

complexity optimally configured safari



becomes cardinality minimal cardinality
diagnoses given observation cf sec
complexity bcp well known allowing us get precise bounds
worst case complexity computing one minimal diagnosis safari follows
assume sd represented cnf cf sec
lemma given diagnostic system ds hsd comps obsi sd wfm sd
c clauses n variables worst case complexity wfm finding
minimal diagnosis cn bcp consistency checks
proof sketch implementation bcp forbus de kleer maintains total
c counters number unsatisfied literals clause consistency check requires
decrementing counters n variables sd gives us upper
bound cn execution time bcp combining complexity bcp
lemma gives us desired
efficient implementations bcp exist zhang stickel



fiapproximate model diagnosis greedy stochastic search

optimality analysis single diagnosis
contrast deterministic safari absolute guarantee optimum solution minimal diagnosis found provide
intuition behind performance safari means approximate
analytical model estimates probability reaching diagnostic solution specific
minimality
optimality safari weak fault
start considering single run without retries
assume existence one minimal diagnosis next extend model
considering retries
basic model
consider diagnostic system ds hsd comps obsi sd wfm
observation manifests one minimal diagnosis argument
follows configure safari n assume starting
solution trivial faulty diagnosis
safari randomly chooses faulty variable flips saying
success candidate diagnosis failure otherwise let k denote
number steps successfully traverses direction minimal
diagnosis cardinality thus k measures number variables whose values
flipped faulty healthy process climbing
let f k denote probability distribution function pdf k following
derive probability p k successfully making transition k k diagnosis
step k k positive literals comps k negative literals probability
next variable flip successful equals probability next negative positive
flip h k negative literals conflict negative literal belonging
diagnosis solution consequently k literals comps k literals
allowed flip therefore success probability equals
p k


comps k

comps k
comps k



search process modeled terms markov chain depicted fig
k equals state running inconsistency modeled
transitions state denoted fail
probability exactly attaining step k subsequently failing given
f k p k

k


p





substituting gives us pdf k

k




f k
comps k
comps






fifeldman provan van gemund

k

p

p

k

p

p

k

p

p

k

p n

p

k n



fail

figure model safari run single diagnosis n comps

optimum goal state k comps failure probability term correct
equals unity
p independent k f would geometrically distributed implies
chance reaching goal state k comps slim however fact p decreases
k moves probability mass tail distribution works favor
reaching higher k solutions instance single fault solutions distribution
becomes uniform figure shows pdf instances comps
increasing fault cardinality order decrease sampling noise empirical f k
values fig computed taking average samples k















f k



f k
























k















k

figure empirical left analytic right f k retries single diagnosis
next section retries move probability mass towards
optimum increasing tail distribution needed almost reaching
optimality
modeling retries
section extend model account retries profound effect
resulting pdf f consider transition step k k
spend retries exiting failure


fiapproximate model diagnosis greedy stochastic search

seen cf alg variable flip produces inconsistency retry
executed incremented
elementary combinatorics compute probability diagnosis
flipping different negative literals step k similar stage k
comps k faulty literals chosen variable flips leading
inconsistency recorded attempted difference choosing
variables advance one another probability advancing stage
k stage k becomes

p k


comps k




progress safari modeled values markov chain similar
one shown fig transition probability p replaced p resulting
pdf number successful steps becomes


k







comps
f k comps k






seen restricted case
retry effect shape pdf profound whereas single fault solutions
shape uniform probability mass already located
optimum k comps fig plots f number instances
increasing expected effect extremely significant note case
real system comps pdf would consist single unit probability spike
comps
although unable analytic treatment transition model
graphs immediately large probability moving k comps
large hence expect pdf considerable probability mass located
k comps depending relative comps
optimality safari strong fault
analysis seen wfm easy starting non minimal
diagnosis reach subset minimal diagnosis discussed detail
necessarily case strong fault many practical cases however
strong fault exhibit least partially behavior similar mdh thus allowing greedy
safari achieve close optimal values
partial continuity strong fault stuck
follows restrict attention large subclass sfm called sfsm
struss dressler
definition strong fault stuck model system ds hsd comps obsi belongs class sfsm iff sd equivalent h f h l hn
fn hn ln j n hi comps fj propositional formula
none hi appears fj lj positive negative literal fj


fifeldman provan van gemund












f k

f k




































k





















f k


f k






















k













k








k

figure empirical left analytic right f k multiple retries single diagnosis

mdh cf hypothesis hold sfsm consider adder whose inputs
outputs zeroes whose gate stuck faulty
case nominal assignment diagnosis example stuck output gate
diagnosis contradiction zero output
many practical observations involving sfsm however lead partial continuity means groups diagnoses differ one literal e
flip search improve cardinality diagnosis next formalize notion
definition partial continuity system model sd observation satisfy
partial continuity property respect set sd iff every diagnosis
satisfying lit lit exists finite sequence valid subset
flips
one extreme spectrum sd satisfy partial continuity property
respect set diagnoses extreme partial continuity


fiapproximate model diagnosis greedy stochastic search

property satisfied respect singleton consider example sd wfm
consists single faulty diagnosis
note continuous property trivally satisfied respect diagnosis
k sd e exists sequence containing k hk
interested non trivial cases
consider system sd observation satisfy partial continuity property
respect diagnosis k say diagnoses flip sequence
contains k form continuous subspace alternatively given diagnostic system sd
observation continuous diagnostic subspace sd set diagnoses sd
property diagnosis another diagnosis
lit lit
unfortunately general sfsm case cannot derive bounds sizes
continuous subspaces hence optimality safari follows
help examples illustrate fact partial continuity depends
model observation express optimality safari function
topologically dependent property later sec collect empirical data continuous
subspaces leading near optimal diagnoses exist class benchmark sfsm circuits
first example illustrates notion discontinuity lack partial continuity
respect diagnoses rare example model observation
leading set diagnoses contains diagnoses cardinality q q
diagnoses cardinality q
discontinuity example consider example boolean circuit shown fig
modeled propositional formula

h x h x

sdd
h x h x
observation x note sdd sfsm exactly two diagnoses
sdd h h h h note model cannot single
faults minimal starts
possible reach minimal diagnosis performing single flips similarly
construct impose arbitrarily bad bound optimality safari
however common see greedy performs
well wide class strong fault
h
x


h

figure two inverters circuit
obviously continuity distribution cardinalities set diagnoses necessary sufficient condition safari progress impose arbitrary
difficulty safari leading suboptimal diagnoses cardinality


fifeldman provan van gemund

example partial continuity continue running example started sec
first create system description sdsa sfsm model let sdsa sdw sdf
sdw given second part sdsa strong fault description sdf
specifies output faulty gate must stuck
sdf h h h j h
h b h l h k



clear sdsa sfsm next compute diagnoses sdsa x
p b one minimal diagnosis sdsa h h h h
cf fig choose two literals h h change signs h
h create two health assignments h h h h h h h
h h h h h h h checked
diagnoses e sdsa sdsa note
diagnoses weak part model e sdw follows
mdh fact minimal diagnosis sdw furthermore
diagnosis strong fault stuck model sdsa sdw h
lead contradictory value j strong fault part sdf similar argument
applies sdw h contradict sdf equivalently negating h
makes j stuck diagnosis negating h makes
stuck diagnosis negating h h
diagnosis consider fact fault mode h sets impose
constraints j argument extended similarly h h h hence
assignment comps containing h h diagnosis sdsa matter
combination signs take h h h h h note health assignment
containing h diagnosis conditioned k
x

p

h



h

h


l
h

h



j

h

b

h
k

figure continuous subspace strong fault stuck model subtractor
consider alternative way computing set ambiguous diagnoses sdsa given
sdsa compute consistent assignment internal variables example
propagation exactly one assignment j k l
sdsa cf fig note components h h h h
change state component healthy faulty lead different output
value example output j h gate gate healthy


fiapproximate model diagnosis greedy stochastic search

inputs j would stuck gate h diagnostic
reasoner determine components dashed region fig healthy faulty
stuck equivalently one change signs h h h diagnosis
resulting assignments still diagnoses call set components modeled
h h h h ambiguity group clearly safari start diagnosis
h h h h h h h reach
performing valid subset flips
make reasoning precise restrict class sfsm exclude malformed circuits ones disconnected inputs outputs etc furthermore
assume component exactly one output set component output variables denoted cout latter big restriction multi output component
replaced multiple components single output
definition well formed diagnostic system wfds diagnostic system ds
hsd comps obsi well formed ds wfds iff observation
diagnosis sd exactly one assignment component outputs
cout sd
consider sfsm model sd h f h l hn fn hn ln
denote comps set hi n respective li literals
negative cf def e comps set components whose failure modes stuckat similarly use comps set component variables whose stuck li literals
positive comps comps comps comps comps wfds
observation diagnosis force output component negative
positive value denote set health variables whose respective component
outputs forced negative values g ds similarly g ds
components whose outputs positive values define notion
component ambiguity group
definition component ambiguity group given system ds hsd comps obsi
sd sfsm sd wfds observation diagnosis sd component
ambiguity group u ds u comps defined u ds g ds
comps g ds comps
finally component ambiguity group leads continuous subspace
general case cannot say much size component ambiguity groups
experimentation noticed difficult assign inputs sfsm
values generate small continuous subspaces sd sd leads
large component ambiguity groups course possible consider adder
multiplier example whose inputs zeroes whose gate stuck
faulty number inputs circuit combinations small
proposition diagnostic system sd sd sfsm sd wfds observation
entail continuous diagnostic subspaces
multi output boolean function replaced composition single output boolean functions



fifeldman provan van gemund

proof def fact sd wfds follows output values
subset components sign stuck value denote
set comps comps comps health assignment differs signs
components belonging comps diagnosis set diagnoses sd
contains possible assignments assumables comps diagnoses form
continuous space cf def
best illustrate proposition consider gate modeled h fig output
gate healthy one gates inputs gate
stuck situation possible determine component healthy
faulty
clearly u ds lower bound progress safari stuck
shown safari starts diagnosis maximum cardinality
given subspace safari guaranteed comps improve cardinality
least u ds practice safari proceed even stuckat ambiguity groups one factor diagnostic uncertainty stuck component
effectively disconnects inputs outputs hence gates fan region
constrained instance continuing example h predecessors cone
h components h h h h h constitute continuous health subspace
contrary component ambiguity group set conditional health state
another component thorough study stuck continuity outside scope
shall see sec continuous subspaces justify safari experiments
stuck
performance modeling stuck
study optimality safari strong fault first define case
cannot improve non minimal diagnosis changing sign
faulty literal note existence cases sufficient condition safari
suboptimal possible reach minimal diagnosis first changing sign
faulty literal thus circumventing missing diagnosis
preceding section know number invalid flips depend
k e determined observation vector fault modes probability
safari progress non minimal diagnosis becomes
p k

x

comps k




x number invalid flips ratio number invalid flips x
comps call sfm density density gives average probability trying
invalid flip throughout diagnostic search approximation probability
success safari
p k



comps k








fiapproximate model diagnosis greedy stochastic search

plugging p allows us predict f k sfm assumptions
hold pdf measured implementation safari generated
shown fig different values density
comps

comps












f k

f k



































k















k

figure empirical left analytic right f k diagnostic densities multiple
retries single diagnosis

fig visible increasing density leads shift probability
density length walk k left effect however profound
even large values easily compensated increasing discussed
preceding sections
interesting note bounds computed sd independent
bounds used improve performance safari
validation
preceding sections illustrated progress safari synthetic circuits
exposing specific behavior diagnoses remainder section plot pdf
greedy search one small benchmark circuits information
model cf sec
progress safari weak fault model circuit shown fig
chosen difficult observation leading minimal diagnosis cardinality left
easy observation leading single fault diagnosis right plots
probability mass shifts right increasing effect profound
smaller cardinality
effect stuck stuck fault modes sfm probability
success safari shown fig
obviously case effect increasing smaller although still depending
difficulty observation vector last even small values absolute
probability safari finding minimal diagnosis sizeable allowing use safari


fifeldman provan van gemund












































f k

f k




k













k





figure empirical f k weak fault model circuit observations
leading two different minimal cardinality diagnoses

























f k

f k















k


















k

figure empirical f k stuck stuck strong fault
circuit

practical anytime returns diagnosis optimality
depends time allocated computation

optimality analysis multiple diagnoses
preceding section described process computing one diagnosis safari n
section discuss use safari computing counting minimalcardinality diagnoses n rest section assume safari
configured comps


fiapproximate model diagnosis greedy stochastic search

consider system description sd sd wfm observation number
minimal diagnoses sd exponential comps furthermore practice diagnosticians interested sampling set minimal cardinality diagnoses
sd recall sd sd minimal cardinality diagnoses
cover significant part posteriori diagnosis probability space de kleer
follows see safari well suited task
theorem probability safari configured comps computing minimal diagnosis cardinality system comps component variables approaches
comps comps
proof sketch assume minimal diagnosis cardinality exists proposition
follows safari configured comps guaranteed compute minimal
diagnoses starting faulty assignment consider step k improving
diagnosis cardinality state k contains one diagnosis state k safari
flip literal belonging diagnosis note literal may belong
one diagnosis subsequently prevent safari reaching diagnosis
flip literal belonging diagnosis already invalidated e one
literals flipped earlier step
probability solution cardinality survives flip iteration k e
invalidated
p k

comps k


comps k
comps k



similarly basic model sec probability diagnosis survives
returned
comps



f comps

comps

p






comps
comps



rewriting right hand side eq gives us
f comps

comps
comps

comps
comps



since

comps

comps
comps comps comps



holds
comps
comps
comps
comps
lim



small relative comps
f comps comps
gives us theorem




fifeldman provan van gemund

distribution hi cardinalities minimal diagnoses sd depends
topology sd e create sd hi denote
cardinality distribution minimal diagnoses computed safari h
theorem gives us termination criterion safari used enumerating
counting minimal cardinality diagnoses instead running safari
p fixed n
sufficient compute area output distribution function
h value
p
converge single value hence terminate safari change
h
drops fixed threshold note safari efficient enumerating minimalcardinality diagnoses computed probability exponentially higher
probability computing minimal diagnoses higher cardinality shown
theorem
corollary safari computes diagnoses equal cardinality equal probability
proof sketch theorem follows probability success f safari
computing diagnosis depends actual composition
corollary gives us simple termination criterion safari cases
minimal diagnoses minimal cardinality diagnoses proven
case minimal cardinality diagnoses computed probability
see given input cardinality distribution hi safari produces
output distribution h highly skewed right due theorem facilitate
study safari transforms hi h use monte carlo simulation
safari advantage monte carlo simulation much simpler analysing
run time behavior safari studying
monte carlo simulation safari
function safarisimulate n returns cardinality distribution
inputs set minimal diagnoses
n integer number tries
local variables hi h vectors cardinality distributions
b vector fault distribution n c integers

hi cardinalitydistribution

n n

c hi

b c c hi c

end




c discreteinverserandomvalue pb b

b c b c c

end

h c h c

end

return h
end function


fiapproximate model diagnosis greedy stochastic search

simulates diagnoses input set minimal diagnoses
reached safari n tries auxiliary subroutine cardinalitydistribution
computes input distribution hi iterating diagnoses store input
cardinality distribution hi resulting cardinality distribution h vectors note
vector sums lines division vector scalar line
outermost loop alg lines simulates n runs safari done
computing updating auxiliary vector b contains distribution
component variables according cardinalities diagnoses variables
belong initially b initialized number literals single faults position
number literals double faults position example three double
faults hi b etc done lines alg assume diagnoses
share literals restriction easily dropped counting assumables
input latter assumption change section
lines simulate process actual bit flipping safari step
simulation draws random literal probability distribution function pdf pb b
done discreteinverserandomvalue function line bit flip
invalidates diagnosis set e diagnosis cardinality c cannot reached
safari diagnosis invalidated vector b updated example
simulation invalidates quadruple fault b b line note number
iterations loop lines equals number diagnoses
terminating loop value integer variable c equal cardinality
last invalidated diagnosis latter diagnosis safari computes
run remains update resulting pdf right cardinality line
simulation alg links distribution actual diagnoses
distribution cardinalities diagnoses returned safari arbitrarily set apply alg range typical input distributions
simulation well running safari synthetic
input distributions shown fig
fig shows alg predicts actual behavior safari compare second
third column plots safari computes diagnoses small cardinality
agreement theorem case output distribution steep
exponential cardinalities set input minimal diagnoses grow exponentially table summarizes parameters exponential fits input cardinality
distributions shown fig initial zero cardinality decay constant
r coefficient determination seen safari suited computing
multiple diagnoses small probability occurrence next section provide
alternative argument leading similar conclusions

experimental
section discusses empirical measured implementation safari order compare optimality performance safari diagnostic
performed million diagnosis computations dual cpu nodes belonging cluster node contains two ghz amd opteron dp processors
gb ram


fifeldman provan van gemund

degenerate input

prediction model






h



h

h































h

h






exponential input






h

h







prediction model
















h

h

h





safari










reverse exponential input














safari







prediction model






























safari









prediction model






safari

h

h

h









normal input

h







h




prediction model








uniform input



safari


















figure predicted actual cardinality distributions




fiapproximate model diagnosis greedy stochastic search

table fit coefficients exponential goodness fit cardinality distribution
fig




r
















input distribution
uniform
normal
exponential
reverse exponential

default configuration safari stated otherwise n
safari configured maximum number retries giving
climb total attempts provide precise average run time optimality
performance data stochastic e ones sls max sat safari
repeatedly run times model observation vector
implementation notes test set description
implemented safari approximately lines c code excluding ltms
interface dpll code part lydia package
traditionally mbd tested diagnostic digital circuits
ones included iscas benchmark suite brglez fujiwara
derived iscas large traditional diagnostic perspective
considered four medium sized circuits xxx family hansen yalcin
hayes order provide weak strong fault cases translated
circuit weak stuck stuck model stuck
output faulty gate assumed constant cf def
performance diagnostic depends degrees observation
vectors designers strive produce performance
dependent observation vectors hence performed experimentation
number different observations model implemented
alg generates observations leading diagnoses different minimal cardinality
varying nearly maximum respective circuits xxx
maximum experiments omit nominal scenarios trivial
viewpoint mbd
uses number auxiliary functions randominputs line assigns
uniformly distributed random values input note generation
observation vectors partition observable variables obs inputs outputs
use input output information comes original xxx iscas
circuits simulation given healthy health assignment diagnostic system computenominaloutputs line performs simulation propagating input
assignment assignment contains values output variable

lydia safari diagnostic benchmark downloaded http fdir org lydia



fifeldman provan van gemund

generation observation vectors
function makealphas ds n k returns set observations
inputs ds hsd comps obsi diagnostic system
obs
n integer number tries safari
k integer maximal number diagnoses per cardinality
local variables n terms
c integer best cardinality far
set terms observation vectors

k k

randominputs

computenominaloutputs ds

c

v

n flip v

smallestcardinalitydiagnosis safari sd n comps n

c

c

n

end

end

end

return
end function
loop lines increases cardinality greedily flipping values
output variables candidate observation n alg uses diagnostic oracle
safari compute minimal diagnosis cardinality c safari returns
one diagnosis n use smallestcardinalitydiagnosis choose one
smallest cardinality cardinality c diagnosis increases comparison
previous iteration observation added list
running alg get k observations leading faults cardinality
cardinality mfmc diagnosis feldman provan van gemund
b respective circuit alg clearly shows bootstrapping order
create potentially difficult observations safari require safari solve
difficult observations although seen sec safari heavily biased
towards generating diagnoses small cardinality guarantee alleviate
generation observation vectors configured safari compute
subset minimal diagnoses comps n increased
table provides overview fault diagnosis benchmark used experiments
third fourth columns number observable assumable variables
characterize size circuits next three columns number observation
vectors tested weak stuck
chosen weak fault model observations consistent


fiapproximate model diagnosis greedy stochastic search

table overview xxx iscas benchmark circuits
name

description


l



bit
bit
bit
bit

c
c
c
c
c
c
c
c
c
c

channel interrupt controller
bit sec circuit
bit alu
bit sec circuit
bit sec dec
bit alu
bit alu
bit alu
bit multiplier
bit adder

variables
obs comps

carry lookahead generator
magnitude comparator
adder
alu

observations
weak

















































































respective system descriptions strong fault often case sd
considered scenarios
comparison complete
table shows comparing safari implementations two state art
complete deterministic diagnostic modification completeness cda
williams ragno ha feldman van gemund table shows
model percentage tests diagnosis could
computed within cut time minute
visible three rightmost columns table safari could diagnoses observation vectors performance two deterministic
columns two seven degraded increase model size cardinality
observation vector furthermore observed degradation performance
cda ha increased cardinality minimal cardinality diagnoses
performance safari remained unaffected
comparison allsat model counting
compared performance safari pure sat
uses blocking clauses avoiding duplicate diagnoses jin han somenzi
although sat encodings worked efficiently variety domains
weak health modeling makes diagnostic underconstrained
uninformed allsat strategy e search exploiting continuity imposed
weak fault modeling quite inefficient even small


fifeldman provan van gemund

table comparison cda ha safari tests solved
name

weak

cda



l


















c
c
c
c
c
c
c
c
c
c




































weak

ha




weak

































































































safari


substantiate claim experimented state art satisfiability
solver relsat version bayardo pehoushek instead enumerating
solutions filtering minimal diagnoses performed model counting whose
relation mbd extensively studied kumar possible solve
two smallest circuits solver terminate larger within
predetermined time hour shown table
second column table shows model count returned relsat sample single fault observations benchmark third column reports time
model counting slow performance relatively small diagnostic instances leads us
conclusion specialized solvers safari better suited finding minimal
diagnoses shelf allsat model counting implementations encode
inference properties similar encoded safari
used state art non exact model counting method samplecount
gomes hoffmann sabharwal selman compute lower bounds model
counts shown third fourth columns table configured
default settings z cutoff flips samplecount could
lower bounds circuits larger c although performance samplecount significantly better relsat fact samplecount computes lower
bounds scale large circuits prevent us building diagnosis
approximate model counting
satisfiability method diagnosing optimized version iscas
used smith veneris viglas recent smith veneris ali
viglas sat replaced quantified boolean formula
qbf solver computing multiple fault diagnoses methods report good absolute


fiapproximate model diagnosis greedy stochastic search

table model count time counting
relsat

time

name

samplecount

time


l























c
c
c
c
c
c
c
c
c
c
























































execution time single double faults believe scale well higher
cardinalities require modifications initial circuits e introduce cardinality
test constraints suggest specialized heuristics sat solvers order improve
search performance comparison performance safari timings reported
papers would difficult due number reasons use different
optimized benchmark sets trading memory speed rewriting original circuits etc
performance greedy stochastic search
table shows absolute performance safari comps n varies
millisecond small approx largest strong fault
model fast absolute times safari suitable line reasoning tasks
autonomy depends speedy computation diagnoses
model minimum maximum time computing diagnosis
computed values shown columns tmin tmax respectively small
range tmax tmin confirms theoretical safari insensitive fault
cardinalities diagnoses computes performance cda ha
hand dependent fault cardinality quickly degrades increasing fault
cardinality
optimality greedy stochastic search
produced complete diagnostic methods cda ha know
exact cardinalities minimal cardinality diagnoses observations
considering observations lead single double faults evaluated


fifeldman provan van gemund

table performance safari ms
weak
name

tmin


tmax


l













c
c
c
c
c
c
c
c
c
c























tmin






tmax





tmin





tmax




































average optimality safari table shows optimality greedy
search second column table shows number observation vectors leading
single faults weak fault model third column shows average cardinality
safari second third column repeated
table shows sd wfm average cardinality returned safari
near optimal single double faults c model shows worst case
single fault observations c difficult weak fault model
computing double fault diagnosis improved increasing n
discussed sec
strong fault close optimal small
quality diagnosis deteriorates c bigger surprising considering
modest number retries number flips safari configured
computing multiple minimal cardinality diagnoses
next experiments supporting claims made sec
first chosen observations could compute sd
deterministic cda ha mostly observations leading single double
faults configured safari comps n sd
finally diagnoses computed safari filtered minimal cardinality
ones summarized table
table repeats columns weak data
columns interpreted follows columns marked
minimal maximal number minimal cardinality diagnoses per model computed
deterministic columns mc percentage minimal cardinality


fiapproximate model diagnosis greedy stochastic search

table optimality safari average cardinality
single faults


card card

name

weak
card


l




























c
c
c
c
c
c
c
c
c
c





























































weak
card

double faults


card card































































































table minimal cardinality diagnoses computed safari
weak
mc

name




l













c
c
c
c
c
c
c
c
c
c
























mc mf






















































































































mc mf

mf

diagnoses returned safari minimal cardinality diagnoses
sd columns mf percentage observations safari
could compute minimal cardinality diagnosis


fifeldman provan van gemund

shown table even moderate values n n
safari capable computing significant portion minimal cardinality diagnoses
portion varies weak fault
strong fault percentage cases safari could reach minimalcardinality diagnosis limited mainly cases
exists one single fault diagnosis note even cases safari cannot
compute minimal cardinality diagnoses safari still useful
example subset minimal diagnosis small cardinality differing one two literals
nevertheless brings useful diagnostic information discussion diagnostic metrics
beyond scope
experimentation summary
applied safari suite benchmark combinatorial circuits encoded
weak fault stuck strong fault shown significant performance
improvements multiple fault diagnoses compared two state art deterministic
cda ha indicate safari shows least order ofmagnitude speedup cda ha multiple fault diagnoses moreover whereas
search complexity deterministic tested increases exponentially fault
cardinality search complexity stochastic appears independent
fault cardinality
compared performance safari maxsat safari shows least order magnitude speedup computing diagnoses
compared optimality safari sls maxsat safari consistently computes diagnoses smaller cardinality whereas sls
max sat diagnostic often fails compute diagnosis

related work
generalizes feldman provan van gemund introduces important theoretical strong fault extends experimental
provides comprehensive optimality analysis safari
gross level one classify types applied solve
mbd search compilation search take input diagnostic model observation search diagnosis may minimal
respect minimality criterion examples search include
cda williams ragno hitting set reiter
compilation pre process diagnostic model form
efficient line diagnostic inference examples include atms
de kleer prime implicant methods kean tsiknis dnnf darwiche obdd bryant knowledge approaches adopt
exact methods compute diagnoses contrast safari adopts stochastic
computing diagnoses
first glance seems mbd could efficiently solved encoding
sat jin et al constraint satisfaction freuder dechter ginsberg selman
tsang bayesian network kask dechter however one needs


fiapproximate model diagnosis greedy stochastic search

take account increase formula size direct mbd encoding addition
underconstrained nature mbd
safari close resemblance max sat hoos stutzle conducted extensive experimentation complete partial weighted sls
max sat experiments long published separate technical report feldman provan van gemund
although max sat compute diagnoses many cases performance maxsat degrades increasing circuit size cardinality injected faults
particular safari outperforms max sat least order magnitude class
diagnostic considered case sls max sat optimality
max sat inference significantly worse safari
safari exploits particular property mbd called diagnostic
continuity improves optimality safari compared example straightforward allsat encodings jin et al experimentally confirm favorable
performance optimality safari although safari close resemblance maxsat safari exploits specific landscape properties diagnostic allow
simple termination criteria optimality bounds due hybrid nature
safari use ltms sat safari avoids getting stuck local optima performs better max sat methods incorporating approaches max sat
particular saps hutter tompkins hoos future versions safari may
help solving general abduction may expose continuous
properties considered
stochastic discussed framework constraint satisfaction
freuder et al bayesian network inference kask dechter latter
two approaches used solving suitably translated mbd often
case though encodings difficult search specialized ones
mbd instance constraint optimization particular constraints failure
variables mbd developed exploit domain properties
proposed differs significantly almost mbd appear
literature advanced mbd deterministic safari borrows
sls rather backtracking may randomly flip variable assignments
determine satisfying assignment complete mbd typically make use
preferences e g fault mode probabilities improve search efficiency safari uses
technique top stochastic search space diagnoses
closely related diagnostic fijany vatan barrett james williams
mackey map minimal hitting set finding
assignment bounded weight satisfying monotone sat propose
use efficient sat computing diagnoses fijany et al
shown speedups comparison diagnosis main drawback
number extra variables clauses must added sat encoding
even significant strong fault multi valued variables contrast
works directly given diagnosis model requires conversion another
representation
work bears closest resemblance preference cost abduction
cba charniak shimony santos jr algorithmic work


fifeldman provan van gemund

area primary adopts stochastic local search abdelbar gheita
amer present hybrid two stage method
iterated local search ils repetitive simulated annealing rsa ils stage
uses simple hill climbing method randomly flipping assumables
local search phase tabu search perturbation phase rsa repeatedly applies
simulated annealing sa starting time random initial state hybrid
method initially starts arbitrary state greedily chosen state applies
ils fails optimal solution fixed number
hill climbing steps fixed number r repetitions perturbation local
search cycle ils search terminated rsa run optimal
solution found
work differs abdelbar et al several ways first initial
state generated random sat solution hill climbing phase use next
similar abdelbar et al however randomly restart hill climbing
identify better diagnosis rather applying tabu search simulated annealing
simpler abdelbar et al case weak fault
guaranteed optimal future work plan compare
abdelbar et al strong fault
safari competed diagnostic ngde de kleer
rodon bunus isaksson frey munker synthetic track first
diagnostic competition dxc kurtoglu narasimhan poll garcia kuhn de kleer van
gemund feldman conditions dxc experiments
conducted similar ones described cpu memory performance safari order magnitude better competing despite
fact ngde rodon performed better complete discussed
section addition computational metrics informally
used minimality diagnosis optimality criterion dxc organizers however defined utility metric approximates expected repair effort circuit
feldman provan van gemund b utility metric safari scored slightly
worse two competing expected safari trades
diagnostic precision computational efficiency refer reader dxc papers
mentioned thorough analysis competition

conclusion future work
described greedy stochastic computing diagnoses within modelbased diagnosis framework shown subset minimal diagnoses computed
optimally weak fault important subset strong fault
almost minimal cardinality diagnoses computed general fault
hill climbing proceeds follows given current state cost f neighbouring state
generated flipping randomly chosen assumable hypothesis f better f
becomes current state otherwise discarded iterations elapse without change
current state local search exits
perturbation local search starting current state cost f randomly chooses
assumable variable h applies tabu search identify better state flipping h tabu
status



fiapproximate model diagnosis greedy stochastic search

argue safari broad practical significance compute significant fraction minimal cardinality diagnoses systems large complex
diagnosed existing deterministic
future work plan experiment combination weak strong
failure mode descriptions plan experimenting wider variety stochastic
methods simulated annealing genetic search larger set benchmark
last plan apply wider class abduction constraint
optimization

references
abdelbar approximating cost abduction np hard artificial intelligence
abdelbar gheita h amer h exploring fitness landscape
run time behaviour iterated local search cost abduction
experimental theoretical artificial intelligence
bayardo r j pehoushek j counting connected components
proc aaai pp
brglez f fujiwara h neutral netlist combinational benchmark circuits
target translator fortran proc iscas pp
bryant r e symbolic boolean manipulation ordered binary decision diagrams acm computing surveys
bunus p isaksson frey b munker b rodon model diagnosis
dx diagnostic competition proc dx pp
bylander allemang tanner josephson j computational complexity abduction artificial intelligence
charniak e shimony e cost abduction map explanation artificial intelligence
cook complexity theorem proving procedures proc stoc pp

darwiche model diagnosis structured system descriptions journal
artificial intelligence
davis logemann g loveland machine program theorem proving
communications acm
de kleer j assumption tms artificial intelligence
de kleer j crude probability estimates guide diagnosis artificial intelligence
de kleer j minimum cardinality candidate generation proc dx pp

de kleer j mackworth reiter r characterizing diagnoses systems
artificial intelligence


fifeldman provan van gemund

de kleer j williams b diagnosing multiple faults artificial intelligence

een n sorensson n extensible sat solver proc sat vol
lecture notes computer science pp springer
eiter gottlob g complexity logic abduction journal
acm
feldman provan g van gemund computing minimal diagnoses
greedy stochastic search proc aaai pp
feldman provan g van gemund b computing observation vectors
max fault min cardinality diagnoses proc aaai pp
feldman provan g van gemund family model diagnosis
max sat tech rep es delft university technology
feldman provan g van gemund b lydia combinational
model diagnosis proc dx pp
feldman van gemund two step hierarchical model
diagnosis proc aaai pp
fijany vatan f barrett james williams c mackey r novel
model diagnosis engine theory applications proc ieee aerospace
vol pp
forbus k de kleer j building solvers mit press
freeman j w improvements propositional satisfiability search
ph thesis university pennsylvania
freuder e c dechter r ginsberg l selman b tsang e p k systematic versus stochastic constraint satisfaction proc ijcai vol pp
friedrich g gottlob g nejdl w physical impossibility instead fault
proc aaai pp
gomes c p hoffmann j sabharwal selman b sampling model
counting proc ijcai pp
hansen yalcin h hayes j unveiling iscas benchmarks case
study reverse engineering ieee design test
hermann pichler r counting complexity propositional abduction
proc ijcai pp
hoos h sat encodings search space structure local search performance
proc ijcai pp
hoos h stutzle stochastic local search foundations applications
morgan kaufmann publishers inc
hutter f tompkins hoos h h scaling probabilistic smoothing
efficient dynamic local search sat proc cp pp


fiapproximate model diagnosis greedy stochastic search

jin h han h somenzi f efficient conflict analysis finding satisfying
assignments boolean circuit proc tacas pp
kask k dechter r stochastic local search bayesian networks proc
aistat pp
kean tsiknis g k clause management systems computational intelligence

kumar k model counting characterization diagnoses proc dx
pp
kurtoglu narasimhan poll garcia kuhn l de kleer j van gemund
feldman first international diagnosis competition dxc proc
dx pp
marques silva j p impact branching heuristics propositional satisfiability
proc epia pp
mcallester truth maintenance proc aaai vol pp
reiter r theory diagnosis first principles artificial intelligence

roth hardness approximate reasoning artificial intelligence

santos jr e linear constraint satisfaction cost abduction
artificial intelligence
smith veneris ali f viglas fault diagnosis logic debugging
boolean satisfiability ieee transactions cad integrated circuits
systems
smith veneris viglas design diagnosis boolean satisfiability
proc asp dac pp
struss p dressler physical negation integrating fault general diagnostic engine readings model diagnosis pp morgan
kaufmann publishers inc
thiffault c bacchus f walsh solving non clausal formulas dpll
search proc cp pp
tseitin g complexity proofs propositional logics siekmann j
wrightson g eds automation reasoning classical papers computational
logic vol springer verlag
williams b ragno r conflict directed role model embedded systems journal discrete applied mathematics
zhang h stickel e efficient unit propagation proc
ai math pp




