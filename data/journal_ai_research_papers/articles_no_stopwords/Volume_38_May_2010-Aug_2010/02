journal articial intelligence

submitted published

bnb adopt
asynchronous branch bound dcop
william yeoh

wyeoh usc edu

computer science department
university southern california
los angeles ca usa

ariel felner

felner bgu ac il

information systems engineering
deutsche telekom labs
ben gurion university negev
beer sheva israel

sven koenig

skoenig usc edu

computer science department
university southern california
los angeles ca usa

abstract
distributed constraint optimization dcop popular way formulating
solving agent coordination dcop several agents coordinate values sum resulting constraint costs minimal often
desirable solve dcop memory bounded asynchronous introduce branch bound adopt bnb adopt memory bounded asynchronous dcop search
uses message passing communication framework adopt modi shen
tambe yokoo well known memory bounded asynchronous dcop search
changes search strategy adopt best first search depth first branch bound
search experimental bnb adopt finds cost minimal solutions one
order magnitude faster adopt variety large dcop fast
ncbb memory bounded synchronous dcop search dcop
additionally often desirable bounded error solutions dcop
within reasonable amount time since finding cost minimal solutions np hard existing bounded error approximation mechanism allows users specify absolute error bound
solution cost relative error bound often intuitive thus present two
bounded error approximation mechanisms allow relative error bounds implement
top bnb adopt

introduction
distributed constraint optimization dcop consists agents responsible taking
assigning value nite domain values agents coordinate values
subject constraints two agents constrained share constraint
constraint associated constraint cost depends values constrained agents
complete solution assignment values agents partial solution assignment
values subset agents solution cost partial complete solution sum
constraint costs constraints resulting given assignment values agents solving
dcop optimally means nding solution minimal solution cost np hard modi
et al
formulating agent coordination constraint optimization cop specic
type weighted constraint satisfaction schiex fargier verfaillie bistarelli

c

ai access foundation rights reserved

fiyeoh felner koenig






































constraint cost




constraint cost





b























constraint cost




constraint cost





c

figure example dcop
montanari rossi schiex verfaillie fargier general formulating
common constraint satisfaction dechter constraint satisfaction
constraints satised unsatised solving constraint satisfaction
means nding solution constraints satised example application
scheduling jobs job shop constraints express jobs performed
certain machines jobs performed jobs could
potentially multiple solutions satisfy constraints however solutions might
desirable others example one might prefer solution shortest completion time
unfortunately constraint satisfaction cannot capture preferences however cop
able constraint costs represent preferences
dcop better suited compared cop naturally distributed dcop applied coordinating unmanned
aerial vehicles schurr okamoto maheswaran scerri tambe scheduling meetings maheswaran tambe bowring pearce varakantham b petcu faltings b greenstadt
grosz smith zivan yeoh varakantham koenig coordinating sensor networks lesser ortiz tambe zhang xing wang wittenburg modi et al
jain taylor tambe yokoo stranders farinelli rogers jennings zivan glinton
sycara synchronizing trac lights junges bazzan truck routes ottens
faltings managing power distribution networks kumar faltings petcu
common visualize dcop constraint graph vertices
agents edges constraints dcop operate pseudo tree
spanning tree completely connected constraint graph property edges
constraint graph connect vertex one ancestor descendant vertices
constraint tree freuder quinn bayardo miranker edge constraint
graph part pseudo tree backedge agent c pseudo child agent
agent p agent c descendant agent agent p pseudo tree constrained
via backedge similarly agent p pseudo parent agent agent c sibling subtrees represent
independent dcop subproblems since two agents dierent sibling subtrees share constraint
figure shows constraint graph example dcop four agents
take value value figure b shows one possible pseudo tree assignments
values agents independent dcop subproblems dotted line backedge
figure c shows constraint costs example dcop cost minimal solution
agents take value minimal solution cost
dcop
provide taxonomy dcop figure shows taxonomy dcop
divided two groups complete incomplete dcop complete dcop nd cost minimal solutions incomplete dcop often faster typically
nd suboptimal solutions


fibnb adopt asynchronous branch bound dcop

dcop

incomplete
e g dba dsa mgm
k optimal

complete

partially centralized
e g optapo

fully decentralized


search
e g sbb adopt
ncbb afb

inference
e g dpop

figure taxonomy dcop
incomplete dcop
incomplete dcop typically use local search nd locally optimal solutions
thus potentially get trapped local minima nevertheless since solving dcop optimally
np hard dcop desirable large dcop nding costminimal solutions might slow dba yokoo hirayama dsa fitzpatrick meertens
mgm maheswaran pearce tambe recent class k optimal dcop
pearce tambe bowring pearce portway jain tambe greenstadt
examples incomplete dcop
complete dcop
complete dcop generally divided two groups namely partially centralized
fully decentralized dcop
partially centralized dcop
partially centralized dcop allow agents transfer constraint information
information regarding constraints involved central agent processing optapo mailler lesser example partially centralized dcop
uses cooperative mediation certain agents act mediators solve overlapping dcop
subproblems centrally
fully decentralized dcop
fully decentralized dcop central agents collect constraint information agents constrained rather every agent access
constraint information fully decentralized dcop generally divided two
groups namely dcop inference search
dcop inference dcop inference typically use dynamic programming propagate aggregated constraint costs one agent another agent thus reduce


fiyeoh felner koenig

dcop

sbb
adopt
ncbb
afb
bnb adopt

search
strategy
dfbnb
best first
dfbnb
dfbnb
dfbnb

agent
operation
sequential synchronous
concurrent asynchronous
sequential synchronous
concurrent asynchronous
concurrent asynchronous

communication
point point neighbors
point point neighbors
point point neighbors
broadcast agents
point point neighbors

agent
ordering
chain
tree
tree
chain
tree

table properties dcop search

dcop size one agent step repeat procedure dcop
size reduced one agent solution space space possible partial solutions thus cannot reduced anymore sole remaining agent sucient
knowledge nd cost minimal solution dpop petcu faltings b example
dcop inference number messages sent agents linear
number agents however memory requirements exponential induced
width dcop induced width depends number backedges
pseudo tree large number agents minus one constraint graph
fully connected every agent thus constrained every agent
dcop search dcop search use search strategies search
solution space nd cost minimal solution adopt modi et al uses best rst
search sbb hirayama yokoo ncbb chechetka sycara afb gershman meisels zivan dcop search bnb adopt use
depth rst branch bound search memory requirements polynomial
number agents however number messages sent agents exponential
number agents
therefore groups fully decentralized dcop desirable dierent
conditions tradeo space memory requirements time number messages
sent
motivation
describe motivation behind work
bnb adopt
study dcop search memory bounded property important applications sensor networks every agent sensor xed amount
memory available several dcop search sbb adopt ncbb
afb developed limitation mind described earlier memory requirements
polynomial number agents table shows properties dcop search well properties dcop search bnb adopt describe
property detail justify properties bnb adopt
search strategy adopt uses best rst search search solution space sbb
ncbb afb use depth rst branch bound dfbnb search best rst search repeatedly searches next best partial solution nds cost minimal solution next
best partial solution cost minimal partial solution among partial solutions
yet found depth rst branch bound search starts nding complete



fibnb adopt asynchronous branch bound dcop

often suboptimal solution stores solution cost upper bound continues
search solution whose solution cost less upper bound stores solution
cost solution upper bound search proceeds longer nd
solution whose solution cost less upper bound
centralized search known search depth bounded search trees
often solved faster depth rst branch bound search memory bounded
best rst search memory bounded best rst search rbfs korf
need repeatedly reconstruct partial solutions purged memory depthrst branch bound search memory bounded suer
zhang korf since dcop search depthbounded search trees hypothesize depth rst branch bound search might faster
best rst search therefore decided bnb adopt use depth rst branchand bound search
agent operation agents sbb ncbb operate sequentially agents tokens
active agents remain idle token holding agents done pass
tokens remain idle hand agents adopt afb operate
concurrently times agents operate concurrently might able solve dcop
faster agents operate sequentially since former agents perform
potentially useful computation instead wait agents therefore
decided agents bnb adopt operate concurrently agents sbb ncbb
operate synchronously communication agents often form messages
synchronous agents operate cycles modi et al cycle time required
agent process incoming messages queue send outgoing messages
processed receiving agents next cycle see section details
therefore agents wait last agent done sending messages start
cycle hand asynchronous agents agents adopt afb
able operate independently often increases robustness silaghi
landwehr larrosa example synchronous agents aected single
communication link suers congestion small number asynchronous agents
aected therefore decided agents bnb adopt operate asynchronously
communication
dcop search sbb adopt ncbb restrict
communication agents share constraints restriction motivated applications
sensor networks communication restricted neighboring agents sensors due
limited communication radius neighboring sensors share constraints since need
coordinate sense areas near dcop search afb
restriction allow agents broadcast messages agents decided
agents bnb adopt obey restrictions applications sensor networks
thus communicate neighboring agents
agent ordering dcop search mentioned start pre processing
step arranges agents pseudo tree dcop search sbb
afb arrange agents chain adopt ncbb arrange agents tree
tree ordering capture independent dcop subproblems represented sibling subtrees
chain ordering dcop search operate trees thus
operate independent dcop subproblems independently dcop search
operate chains therefore decided bnb adopt arrange
agents tree
adopt preferred properties mentioned except uses best rst search
therefore introduce bnb adopt memory bounded asynchronous dcop search


fiyeoh felner koenig

uses message passing communication framework adopt changes search strategy
adopt best rst search depth rst branch bound search
bounded error approximations
solving dcop optimally np hard makes advantageous allow users trade
solution cost smaller runtime desirable error resulting solution
cost bounded provide guarantees solution cost adopt best knowledge
dcop search property absolute error mechanism allows users
specify absolute error bound solution cost example solution cost
larger minimal solution cost however often much desirable
specify relative error bound solution cost example solution cost
percent larger minimal solution cost equivalently times larger
minimal solution cost cannot done absolute error mechanism without knowing
minimal solution cost priori thus propose two approximation mechanisms allow users
specify relative error bound solution cost namely relative error mechanism
weighted heuristics mechanism implement top bnb adopt approximation
mechanisms allow bnb adopt nd solutions bounded errors faster cost minimal
solutions
experimental
experimentally compare adopt bnb adopt ncbb three dierent dcop
types namely graph coloring sensor network meeting scheduling
bnb adopt one order magnitude faster measured number
non concurrent constraint checks number cycles adopt variety large
dcop bnb adopt inferred faster sbb since adopt faster
sbb modi et al bnb adopt fast ncbb dcop
suboptimal variants bnb adopt weighted heuristics
mechanism dominates absolute error mechanism relative error mechanism
article structure
article organized follows formalize dcop section describe
dcop search bnb adopt section describe approximation mechanisms
allow bnb adopt nd solutions bounded error section outline correctness
completeness proofs bnb adopt section lastly present experimental evaluations
section conclusions section

dcop
section formally dene distributed constraint optimization dcop describe
solution space
definition dcop
dcop dened following elements
nite set agents
set nite domains dom dom dom dom ai domain
possible oating point values agent ai



fibnb adopt asynchronous branch bound dcop



















b









b

c


















































c















g

e
h



e

f
j

k



g
l



f

h
n




p

q

j
r



k


u

v

b

figure search tree
set binary constraints f f f fm constraint dom ai
dom ai r species non negative constraint cost function values
distinct agents ai ai share constraint
denition assumes agent takes one value rather multiple values
example dierent value constraint involved dcop
commonly formulated agent responsible assignments values
multiple variables however exist techniques reduce dcop dcop
burke brown thus use terms agent variable interchangeably
denition assumes constraints binary two agents rather n ary
n agents one able extend bnb adopt solve dcop nary constraints techniques proposed extend adopt solve dcop
n ary constraints modi et al additionally assume messages sent
agents delayed nite amount time never lost
search trees
solution space dcop visualized search trees traditional search trees
synonymously search trees marinescu dechter assign values agents sequentially
utilize fact values agents belong independent dcop subproblems
assigned sequentially search trees pseudo trees remedy
issue marinescu dechter thus use search trees refer
search trees article depth bounded twice number agents
figure shows search tree pseudo tree figure b figure b
labels node search tree identier allow us refer nodes easily circular
nodes nodes labeled upper case letters correspond agents example
agent node c agent left branches nodes correspond agents taking value
right branches correspond agents taking value square nodes nodes
labeled lower case letters correspond partial solutions root node
nodes example partial solution node f subtree rooted
node represents dcop subproblem assumes partial solution node
example subtree rooted node f represents dcop subproblem assigning values
agents given number independent dcop subproblems
within dcop subproblem indicated number branches exiting node
example two branches exiting node f indicating two independent dcop
subproblems namely assigning values agents numbers nodes
delta costs nodes delta cost node dened sum
constraint costs constraints partial solution involve agent parent node



fiyeoh felner koenig

example partial solution node v two constraints
partial solution namely constraint agents constraint cost
constraint agents constraint cost since parent
node node v node k agent delta cost node v namely constraint cost
latter constraint former constraint included since involve agent
solution cost partial solution node sum delta costs nodes
along branch root node node example solution cost partial
solution node v sum delta costs nodes b f v example dcop
cost minimal solution union partial solutions nodes v agents
take value thus minimal solution cost sum delta costs nodes b f
v

bnb adopt
section present branch bound adopt bnb adopt describe bnbadopt modication adopt since requires readers depth
understanding adopt instead give stand alone description bnb adopt requires
knowledge adopt intention creating self contained hopefully easy read
description
search strategies adopt bnb adopt
rst describe centralized versions search strategies adopt bnb adopt omit
technical details since described detail later sections
search strategy adopt
adopt modi et al popular dcop search modi ali ali koenig
tambe bowring tambe yokoo davin modi pecora modi scerri
choxi modi silaghi yokoo matsui silaghi hirayama yokoo matsuo
traverses search tree best rst search order describe simplied version
best rst search complete version found marinescu dechter bestrst search maintains list initially contains child nodes root node
repeatedly performs following operations expands node smallest solution
cost list removing node list adding grandchild nodes
node list example dcop best rst search expands nodes
search tree figure rst time following order numbers parentheses
indicate solution costs partial solutions expanded nodes b f c
v
figure shows simplied trace adopt example dcop adopt terminates
fteen steps minimal solution cost numbers nodes delta costs
r
nodes lower bound lbx
r optimistic estimate minimal solution cost
smallest underestimated solution cost solutions underestimated solution cost
solution sum delta costs nodes solution whose parent node
root node whose grandparent node expanded example underestimated
solution cost solution node b expanded nodes f
r
v expanded upper bound u bx
r pessimistic estimate minimal solution
cost solution cost solution smallest solution cost found far adopt
r
r
terminates upper bound u bx
r larger lower bound lbx r order
memory bounded adopt maintains one branch search tree shaded grey gure
root node currently expanded node thus needs repeatedly reconstruct nodes



fibnb adopt asynchronous branch bound dcop

lbrxr









b





b

c



c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

r



k


u



v















j
































infinity































































































infinity

































infinity






























































































































































step

figure trace simplied memory bounded best first search centralized adopt


















step

lbrxr
ubrxr



























ubrxr infinity



step




lbrxr






step

























infinity








step

lbrxr
ubrxr








ubrxr infinity











lbrxr
















































infinity








step

lbrxr
ubrxr







ubrxr infinity



















step

lbrxr
ubrxr



























lbrxr





step
















































step





























step






















ubrxr infinity



ubrxr infinity














step
lbrxr
ubrxr




lbrxr






























step











lbrxr


infinity



lbrxr







step

lbrxr
ubrxr









ubrxr infinity


















step









step













ubrxr infinity










identifiers
lbrxr
ubrxr

lbrxr

ubrxr infinity



fiyeoh felner koenig

lbrxr









b





b

c



c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

r



k


u



v















j






























infinity






























































































































































































ubrxr








step





lbrxr



















step

lbrxr
ubrxr





























ubrxr




























lbrxr











step

lbrxr
ubrxr
























step














ubrxr












lbrxr
ubrxr






































step





lbrxr


infinity













step

lbrxr
ubrxr























step

lbrxr
ubrxr








































step




step













ubrxr infinity








identifiers
lbrxr
ubrxr

lbrxr

ubrxr infinity







step












































step

lbrxr

ubrxr
















































step

figure trace simplied depth first branch bound search centralized bnb adopt
purged memory example step adopt branch node f memory
next node best rst search expands node c adopt discards branch node f
step steps needs reconstruct discarded branch node f order
expand node v step
search strategy bnb adopt
describe simplied version depth rst branch bound search complete version
r
r
found marinescu dechter use denitions lbx
r u bx r
described earlier figure depth rst branch bound search maintains stack initially
contains child nodes root node expands node top



fibnb adopt asynchronous branch bound dcop

stack removing node stack performing following check solution
r
cost node smaller upper bound u bx
r prunes node repeats
operation otherwise adds grandchild nodes node top stack
r
repeats operation terminates upper bound u bx
r larger lower bound
r
lbx r depth rst branch bound search add grandchild nodes expanded
node child nodes root node decreasing order solution costs
instead random order top stack ordering ensures depth rst branchand bound search expands grandchild node smallest solution cost rst use
improvement throughout article example dcop depth rst branch andbound search expands nodes search tree following order prunes
nodes brackets c j g h n k l
b f v figure shows trace depth rst branch bound search
example dcop memory bounded without repeatedly reconstruct nodes
purged memory expands nodes best rst search expand
node j step depth rst branch bound search terminates twelve steps
minimal solution cost three steps fewer adopt
description bnb adopt
provide incremental description bnb adopt first provide notations key
terms bnb adopt describe bnb adopt updates bounds adheres memory
limitations performs depth rst search performs branch bound finally introduce
enhanced nal version bnb adopt pseudocode trace example
dcop
notation key terms
adopt following notation adopt describe bnb adopt
v alinit dom initial value agent
cd set child pseudo child agents agent
c cd set child agents agent
pa parent agent agent except root agent
p set ancestor agents including parent agent agent
scp p set ancestor agents including parent agent agent
parent pseudo parent agents agent one descendant agents
cp scp set ancestor agents including parent agent agent
parent pseudo parent agents agent
adopt following key terms adopt describe bnb adopt
context x context x agent set values ancestor agents agent
context x r root agent r equal

delta cost delta cost x
sum constraint costs constraints
involve agent one ancestor agents assumption agent
takes value ancestor agents take values context x search tree


x
example
delta cost node partial solution x

delta cost node f figure



fiyeoh felner koenig



gamma cost gamma costs x
x dened follows



x
x



c
x




cc

x


min


x


ddom




agents values contexts x thus gamma cost x
sum
constraint costs constraints involve agent one descendant agents
agent one ancestor agents agent one descendant
agents descendant agent ancestor agent agent two descendant agents
agent minimized possible values descendant agents assumption
agent takes value ancestor agents take values context x search



tree x
gamma cost node partial solution x


example gamma cost node f figure gamma cost x
sum
constraint costs constraints involve agent one descendant agents
minimized possible values agent descendant agents assumption
ancestor agents agent take values context x search tree

gamma cost x
gamma cost node whose agent agent whose parent

gamma cost node c
node partial solution x example

figure therefore gamma cost node sum delta cost
gamma costs child nodes gamma cost node minimum
gamma costs child nodes example gamma cost node f figure
sum delta cost gamma costs nodes j k gamma cost
node c figure minimum gamma costs nodes e f
r
solving dcop optimally means determine x
r root agent r equivalently
r
gamma cost root node since x r minimal solution cost dicult
agents cache information allows determine cost minimal solution

updating bounds
every agent bnb adopt stores updates several bounds gamma costs namely
c




lba c
x lbx lbx ubx u bx u bx values child agents c

contexts x maintaining following bound property

lbx


lbx

c
lbx





x


x

c
x



u bx











u bx

c
ubx

search tree


lbx
u bx lower upper bounds respectively gamma cost
node whose agent agent whose parent node partial solution x


lbx
u bx lower upper bounds respectively gamma cost
node partial solution x
c
lba c
x ubx lower upper bounds respectively gamma cost
node whose agent agent c whose parent node partial solution x



fibnb adopt asynchronous branch bound dcop




example lb
u b
bounds node c figure lb







u b bounds node f lb ub bounds node j




lba
uba
lb
u b
bounds node j agent




maintains rst two bounds agent maintains last two bounds
agent uses following update equations values child agents c
c
c
contexts x initialize bounds lba c
x ubx heuristic values hx
c
c
oating point numbers admissible thus satisfy hx x

c
lba c
x hx

uba c
x






agent uses repeatedly following update equations values child agents c
contexts x contexts x c x tighten bounds
c
c
lba c
x max lbx lbx c
c


lbx
lbx
x




cc

lbx


uba c
x

u bx





u bx



min lbx

ddom
c
min uba c
x u bx c


x
uba c

x
cc

min


u bx


ddom






updates maintain bound property improve bounds monotonically
lower bounds monotonically non decreasing upper bounds monotonically nona


increasing nite amount time u bx
lbx agents contexts x
r
r
bnb adopt terminates termination condition u bx r lbx r root agent r
r
r
r
r
satised u bx
r lbx r bound property u bx r lbx r together imply
r
r
r
u bx r x r lbx r dcop solved optimally
figure shows simplied trace updates lower upper bounds example
dcop assume updates proceed sequentially leaf agents root
agent due simplication lower upper bounds node identical
gamma cost independent heuristic values numbers nodes bounds
two agents maintain bounds nodes except root node gure shows bounds
parent agent maintains rather bounds child agent maintains example
number node b bounds agent rather agent maintains bounds
child agent maintains computed taking minimum bounds child
nodes node agents update bound node sum delta cost
bounds child nodes according update equations update
bound node minimum bounds child nodes according update
equations detailed description trace follows
step leaf agent updates bounds nodes g h k l p
delta costs according update equations bounds nodes f h
leaf agents use update equations since child agents sums child agents
u b leaf agents values contexts x
evaluate example lbx

xa
xa



fiyeoh felner koenig

















b













b

c











c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



k






u



v




















identifiers









step
































step































































step

figure simplied trace updates lower upper bounds
j minimum bounds child nodes according update equations
similarly leaf agent updates bounds nodes j n q r u
v delta costs according update equations bounds nodes
e g k minimum bounds child nodes according update
equations bounds nodes k shown gure since
yet maintained agent
step agent updates bounds nodes k maintains bounds
nodes leaf agents maintain according update equations
bounds nodes c f sum delta costs bounds
child nodes according update equations bounds nodes b
c minimum bounds child nodes according update equations
bounds nodes b c shown gure since yet
maintained agent
step agent updates bounds nodes b c maintains bounds
nodes agent maintains according update equations
bounds nodes b sum delta costs bounds child
nodes according update equations bounds node minimum
bounds child nodes according update equations since
lower upper bounds node equal gamma cost lower upper bounds
root node equal gamma cost turn equal minimal solution
cost propagation terminates three steps minimal solution cost
adhering memory limitations
description bnb adopt far assumes memory limitations however bnb adopt
memory bounded dcop search memory requirements per agent linear
number agents describe bnb adopt adheres memory limitations
techniques introduced adopt apply bnb adopt well
simplied trace figure assumes every agent maintains bounds values
child agents c contexts x number contexts exponential depth
agent pseudo tree example dcop agent four dierent contexts
four dierent combinations values ancestor agents agent cannot maintain


fibnb adopt asynchronous branch bound dcop

exponential number bounds due memory limitations therefore every agent maintains
bounds one context given time context stored variable x
agent size context linear number agents number bounds
agent linear product domain cardinality number child agents
thus memory requirements per agent linear number agents domain
cardinality magnitude bounds variables constant agent
performing depth first search
description bnb adopt far applies adopt well however bnb adopt uses
depth rst branch bound search adopt uses best rst search describe
bnb adopt implements depth rst search
agents bnb adopt send messages similar adopt processes
dierently send messages three dierent types namely value cost terminate
messages start every agent initializes context x uses update equations

initialize bounds takes best value da arg minddom lbx
sends
value messages child agents cost message parent agent repeatedly
waits incoming messages processes possibly takes dierent value sends
value messages child agents cost message parent agent description
three message types agents process follows
value messages agent context x value da sends value messages
child agents desired context x da context augmented
value leaf agents child agents thus send value messages value
messages thus propagate contexts pseudo tree
agent receives value message checks whether context identical
desired context value message agent changes context
desired context value message case executes common program
see
cost messages agent sends cost messages parent agent identity


context x bounds lbx
u bx root agent parent
agent thus send cost messages cost messages thus propagate bounds
pseudo tree
agent receives cost message checks whether context context
cost message compatible two contexts compatible agent takes dierent
values two contexts agent uses update equations
bounds cost message improve bounds value message
case executes common program see
r
r
terminate messages termination condition u bx
r lbx r satised
root agent r sends terminate messages without parameters child agents
inform search complete terminates agent receives
terminate message sends terminate messages child agents terminates
well leaf agents child agents thus send terminate messages
terminate messages thus propagate pseudo tree agents terminate

common program follows
context change agent changed context x executes following statements
uses update equations initialize bounds takes best

value da arg minddom lbx
sends value messages child agents
cost message parent agent


fiyeoh felner koenig

















b













b

c











c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



k






u



v













x



x

x

x

x

x x

x x

x x

x x

x x

x x













identifiers










x

x

x

x

x x

x x

x x

x x

x x

x x



















































x x

x x



x




x





x

x

x

x

x x

x x

x x

x x











x x

x x





cycle

x
x

x

x

x x

x x

x x

x x














x

x

x

x

x x

x x

x x

x x

x x

x x



































x








x







x



x

x









x x

x x

x x

x x

x x

x x





x



x

x

x

x



x x

x x

x x

x x

x x

cycle








x x






x



x

x

x

x



x x

x x

x x

x x

x x








x x

cycle
















x







x



cycle



x



cycle





x













x



cycle





x


x



cycle





x



cycle





x



x



x

x

x

x



x x

x x

x x

x x

x x








x x

cycle

figure trace updates lower bounds
context change agent change context x executes following




statements u bx
lbx value context agent augmented
value cannot completed solution whose solution cost smaller solution

cost best solution found far context x u bx
agent thus takes


best value arg minddom lbx sends value messages child
agents cost message parent agent
assume context x agent change nite amount time




u bx
agent takes best value repeats
lbx value


procedure nite amount time u bx
lbx values implies





u bx lbx agent takes every value u bx
lbx since lbx

remains unchanged u bx monotonically non increasing agent changes value
dierent value prevents agent changing value back


u bx
lbx bnb adopt thus performs depth rst search nite amount time
r
r
r
r
r
r
r
u bx r lbx r bound property u bx
r lbx r together imply u bx r x r lbx r
root agent r dcop solved optimally
figures traces updates lower upper bounds respectively
example dcop bnb adopt uses zero heuristic values initial context every


fibnb adopt asynchronous branch bound dcop





inf



inf







b



inf

inf



inf



b

c



inf

inf



inf

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



inf



k


u



v



inf

inf
inf





x

inf

x

x

x

x

x x

x x

x x

x x

x x

x x







inf






x

x

x

x

x x

x x

x x

x x

x x

x x

cycle











inf





inf









inf





inf











inf





x x

x x

inf

x
inf



x





x

x

x

x

x x

x x

x x

x x











x x

x x





cycle

x
x

x

x

x x

x x

x x

x x














x

x

x

x

x x

x x

x x

x x

x x

x x







inf





inf









inf





inf





x








x



inf

inf

x



x

x

inf

inf

inf

inf

x x

x x

x x

x x

x x

x x





x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

cycle

inf
inf

inf

inf

x x





inf
x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x


inf





x x

cycle
















x





inf

x



cycle



x



cycle





x







inf





x

inf

cycle





x


x

inf

cycle



x

inf











inf

identifiers


x

inf

x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x


inf





x x

cycle

figure trace updates upper bounds
agent assigns value ancestor agents agent partition time cycles agents
maintain bounds one context given time nodes gures crossed
agent maintain bounds nodes shaded partial solution equal
context agent parent node augmented value example agents
take value cycle agent takes value context agent
context agent contexts agents
description trace follows
cycle root agent initializes context x initializes lower bounds
nodes b lbax c lbax since uses zero heuristic values

updates lower bound node lbx
sum delta cost
lower bound node b according update equations updates lower bound

node b lbx
sum delta cost lower bound node c

according update equations updates lower bound node lbx

minimum lower bound node lower bound node b according
update equations initializes upper bounds nodes b c innity updates
upper bounds nodes b innity according update equations takes



fiyeoh felner koenig

best value take value value since lower bounds nodes
b takes value sends value message child agent
agent initializes context x initializes lower bounds nodes e
f g updates lower bounds nodes c b respectively
initializes upper bounds nodes e f g innity updates upper bounds
nodes c b innity bounds node b agent maintains shown
gures takes best value sends value messages child agents
sends cost message parent agent
leaf agent initializes context x updates lower bounds
nodes g h delta costs respectively since leaf agents child
agents updates lower bound node updates upper bounds nodes g
h delta costs respectively since leaf agents child agents
updates upper bound node bounds node leaf agent maintains
shown gures takes best value sends cost message
parent agent
leaf agent initializes context x updates lower bounds
nodes j delta costs respectively updates lower bound node e
updates upper bounds nodes j delta costs respectively
updates upper bound node e bounds node e leaf agent maintains
shown gures takes best value sends cost message
parent agent
summary following messages sent cycle
message value agent agent
message value agent agent
message value agent agent
message cost agent agent
message cost agent agent
message cost agent agent
cycle root agent receives cost message sent child agent cycle since
context agent compatible context message
improves bounds updates bounds node b bounds message
innity respectively updates bounds nodes b change value


value da still smaller
since lower bound node lbx


upper bound node u bx sends value message child agent

agent receives value message sent parent agent cycle context
remains unchanged since desired context message
agent receives cost messages sent child agents
cycle since context agent compatible contexts
messages improves bounds updates bounds node
bounds rst message respectively bounds node e
bounds second message respectively updates bounds nodes c


value
b changes value since lower bound node c lbx



longer smaller upper bound node b u bx takes
best value sends value messages child agents sends cost message
parent agent



fibnb adopt asynchronous branch bound dcop

leaf agents receive value messages sent parent agent cycle
contexts remain unchanged since desired
context message send cost messages
parent agent
summary messages sent cycle identical ones sent cycle
except messages sent agent follows
message value agent agent
message value agent agent
message cost agent agent
value messages dierent agent changed value cost
message dierent agent changed bounds
cycles messages sent cycle identical ones sent cycle
except messages sent agents follows
message cost agent agent
message cost agent agent
cost messages dierent agents changed contexts
termination condition holds nite amount time upper bound node


u bx
larger lower bound node lbx root agent
sends terminate messages child agents terminate messages propagate
pseudo tree agents terminate bnb adopt terminates nine cycles
minimal solution cost
performing branch bound
rene description bnb adopt explaining agents implement branchand bound search make bnb adopt faster every agent bnb adopt maintains

variable threshold hx
initializes innity threshold root agent
remains innity every agent uses threshold pruning meaning change
value earlier previously
first change agent change context x previously executed following




statements u bx
lbx value agent took best value
sent value messages child agents cost message parent agent





hx
lbx agent takes best value thus min hx u bx


lbx




agent
takes


best
value

thus
potentially
changes

value




earlier previously min hx

u
b



pruning
quantity

xa
second change agent context x value da sends value messages
child agents previously contained desired context x da




value messages contain desired threshold min hx
u bx x

c
c c c lbx child agent c agent c receives value message sets
threshold desired threshold proceeds described earlier desired



reaches
threshold set lower bound lbx
agent value
c
pruning quantity agent thus potentially changes value lower bound lbx
c
agent c reaches desired threshold property veried follows



fiyeoh felner koenig



c




lbx
c min hx u bx x




lba c
x



c c c








lba c
x min hx u bx x
c





min hx
u bx x lb
x




lba c
x



c c c






lba c
x



c c c



c





min hx
u bx x lb
x







min hx
u bx x




lba c
x



c c c



lba c
x



c c




min hx
u bx lbx



enhancements
continue rene description bnb adopt explaining number additional enhancements introduced adopt
reduced contexts agents use reduced contexts subsets contexts
described previously reduced context x agent contains values ancestor
agents p scp context x described previously contains values



ancestor agents p p agents use reduced contexts since x
x x




x values agents use reduced contexts need change
contexts thus initialize bounds less often receive value messages since
contexts often identical desired contexts value messages
example dcop reduced context agent contains values
agent rather values agents therefore following pairs nodes
search tree actually node nodes q nodes j r nodes u
nodes n v
value cost messages agent sends value messages child agents
previously contained desired context desired threshold desired context
context agent augmented value agent receives value message
previously checked whether context identical desired context value
message agent changed context desired context
value message agents update contexts dierently reduce size
value messages agent sends value messages child pseudo child agents
identity value desired threshold innity pseudo child agents
agent receives value message sets threshold desired threshold message
parent agent checks whether value ancestor agent value
message recent value ancestor agent context
agent changes value ancestor agent context value ancestor agent
value message however context agent contain values
parent pseudo parent agents values ancestor agents parent
pseudo parent agents one descendant agents ancestor agents
constrained agent cannot send value messages agent however
send value messages pseudo child agents least one descendant agent
agent information propagates pseudo tree cost messages
reaches agent agent receives cost message checks whether


fibnb adopt asynchronous branch bound dcop

value ancestor agent context cost message recent
value ancestor agent context agent changes value
ancestor agent context value ancestor agent context cost
message example dcop simple allow us illustrate propagation
information pseudo tree however imagine agent child agent
agent constrained agents context agent contains
value agent agent cannot send value messages agent however agent
sends value messages agent agent changes value agent context
sends cost messages context agent changes value agent
context well
agents need determine whether value agent value messages
contexts cost messages recent value agent contexts every
agent therefore maintains counter ida increments whenever changes
value therefore larger id indicates recent value values agents contexts
labeled ids value messages contain identity sending agent
value id desired threshold
bounds whenever agent changes context x previously initialized bounds
took best value reduced context child agent agent strict
subset reduced context agent since parent pseudo parent agents
agent might parent pseudo parent agents child agent descendant
agents context child agent c contain values agents whose values
changed context agent agent initialize lower bounds lba c
x
upper bounds uba c


agent
c


values



takes


best
value
agents
xa
use optimization need initialize bounds less often way
example dcop agent changes context
ids omitted simplicity initialize lower bounds lbax upper
bounds ubax child agent values since context agent
contain value agent
additionally agent changes context due cost message child agent c
context x compatible context cost message agent
c
set lower bound lba c
x upper bound ubx agent c value agent
cost message bounds cost message takes best value
agents use optimization bounds cost message informed
initialized bounds example dcop simple allow us illustrate
optimization however imagine agent child agent agent
constrained agents assume context agent
ids omitted simplicity receives cost message agent
context agent changes context sets


lower bound lba
upper bound uba
bounds


cost message initializes bounds takes best value

pseudocode
figure shows bnb adopt pseudocode every agent pseudocode index
variables context since context implicitly given variable x uses
predicate compatible x x id x id x
determines two
contexts x x compatible agent takes two dierent values two contexts
lines pseudocode uses procedure prioritymerge x x
executes x id x id x id x id x



fiyeoh felner koenig

procedure start

x p valinit p p scp

ida

forall c c dom

initchild c

initself

backtrack

loop forever

message queue empty

message queue empty

pop msg message queue

received msg

backtrack
procedure initchild c

lba c ha c

uba c
procedure initself


da arg minddom cc lba c



id id

h
procedure backtrack

forall dom

lb cc lba c


ub cc uba c


lb minddom lb

ub minddom ub

lb da min h ub

da arg minddom lb choose previous da possible

da chosen

ida ida

root ub lb termination message received

send terminate c c

terminate execution



send value da ida min h ub da c c c lba c da c c



send value id c cd c

send cost x lb ub pa root
procedure received value p dp idp h p

x x

prioritymerge p dp id p x

compatible x x

forall c c dom

p scp c

initchild c

initself

p pa

h h p
procedure received cost c x c lb c ub c

x x

prioritymerge x c x

compatible x x

forall c c dom

compatible p dp id p x p scp c x

initchild c

compatible x c x

lba c max lba c lb c unique id x c

uba c min uba c ub c unique id x c

compatible x x

initself
procedure received terminate

record termination message received

figure pseudocode bnb adopt
id id id x id x id id thus replaces values



fibnb adopt asynchronous branch bound dcop

agents context x recent values available agents context x lines

code identical every agent except variable self variable points
agent start bnb adopt calls start every agent agent receives
value message ancestor agent received handler value messages
called p ancestor agent dp value ancestor agent idp
id ancestor agent h p desired threshold agent ancestor agent
parent agent innity otherwise line agent receives cost message
child agent received handler cost messages called c child
c
agent x c context child agent lb c lower bound lbx
c child agent
c
c
u b upper bound u bx c child agent line finally agent receives
terminate message parent agent received handler terminate
messages called without arguments line
bnb adopt uses message passing communication framework adopt
memory requirements uses similar value cost terminate messages
similar strategy update context agent value messages ancestor
agents cost messages child agents semantics bounds
update equations update bounds bnb adopt adopt use thresholds bnbadopt uses thresholds pruning adopt uses reconstruct partial solutions
purged memory thus bnb adopt uses dierent threshold initialization line
dierent desired threshold calculation line dierent termination condition line
bnb adopt diers adopt maintains ids agents use indicate
recency values labels values agents contexts ids
trace
figures traces updates lower upper bounds respectively
example dcop table shows trace update variables bnb adopt
uses heuristic values hax hax hax hax hax
hax contexts x x heuristic values chosen hand every
agent assigns value ancestor agents initial context partition time
cycles figures continue use conventions made context gures
cycle root agent initializes context x line initializes lower bounds
nodes b lbax c lbax heuristic values respectively

line updates lower bound node lbx
sum delta cost
lower bound node b according update equations line

updates lower bound node b lbx
sum delta cost
lower bound node c according update equations line updates

lower bound node lbx
minimum lower bound node
lower bound node b according update equations line initializes
upper bounds nodes b c innity line updates upper bounds nodes
b innity according update equations lines takes best
value since lower bound node smaller lower bound node b
line initializes id ida lines initializes threshold h innity
line sends value messages child agent pseudo child agent lines

agent initializes context x line initializes lower bounds
nodes e f g heuristic value line updates lower bounds nodes
c b respectively lines initializes upper bounds
nodes e f g innity line updates upper bounds nodes c b
innity lines bounds node b agent maintains shown


fiyeoh felner koenig

cycle
x
da
id
h
lb
lb
lb
u b
u b
u b
lba
lba
uba
uba
x
da
id
h
lb
lb
lb
u b
u b
u b
lba
lba
uba
uba
lba
lba
uba
uba
x
da
id
h
lb
lb
lb
u b
u b
u b
x
da
id
h
lb
lb
lb
u b
u b
u b
















































































































































































































































































































































































































































































































table trace update variables bnb adopt



fibnb adopt asynchronous branch bound dcop

















b













b

c











c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



k






u



v













x



x

x

x

x

x x

x x

x x

x x

x x

x x













identifiers










x

x

x

x

x x

x x

x x

x x

x x

x x



















































x x

x x



x




x





x

x

x

x

x x

x x

x x

x x











x x

x x





cycle

x
x

x

x

x x

x x

x x

x x














x

x

x

x

x x

x x

x x

x x

x x

x x



































x





x

x

x

x

x x

x x

x x


x



x x








x







x x

x x





x



x

x

x

x



x x

x x

x x

x x

x x

cycle








x x




x



x

x

x

x



x x

x x

x x

x x

x x








x x

cycle
















x









x



cycle



x



cycle





x













x



cycle





x


x



cycle





x



cycle





x



x



x

x

x

x



x x

x x

x x

x x

x x








x x

cycle

figure trace update lower bounds bnb adopt
gure takes best value line initializes id lines
initializes threshold innity line sends value messages child agents
cost message parent agent lines
leaf agent initializes context x line updates lower
bounds nodes g h delta costs respectively since leaf agents
child agents line updates lower bound node line updates
upper bounds nodes g h delta costs respectively since leaf agents
child agents line updates upper bound node line
bounds node leaf agent maintains shown gure takes
best value line initializes id lines initializes threshold innity
line sends cost message parent agent line
leaf agent initializes reduced context x line updates lower
bounds nodes j delta costs respectively line updates
lower bound node e line updates upper bounds nodes j
delta costs respectively line updates upper bound node e line
bounds node e leaf agent maintains shown gure takes



fiyeoh felner koenig





inf



inf







b



inf

inf



inf



b

c



inf

inf



inf

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



inf



k


u



v



inf

inf
inf





x

inf

x

x

x

x

x x

x x

x x

x x

x x

x x







inf






x

x

x

x

x x

x x

x x

x x

x x

x x

cycle











inf





inf









inf





inf











inf





x x

x x

inf

x
inf



x





x

x

x

x

x x

x x

x x

x x











x x

x x





cycle

x
x

x

x

x x

x x

x x

x x














x

x

x

x

x x

x x

x x

x x

x x

x x







inf





inf









inf





inf





x





x

x

x

x

x x

x x

x x

inf
x

inf

x x

inf






x



inf



x x

x x





x



x

x

x

x



x x

x x

x x

x x

x x

cycle

inf


inf



x x



x

x

x



x x

x x

x x

x x

x x








x x

cycle
















x






x

x







x



cycle



x



cycle





x







inf





x

inf

cycle





x


x

inf

cycle



x

inf





inf





inf

identifiers


x

inf

x



x

x

x

x



x x

x x

x x

x x

x x








x x

cycle

figure trace update upper bounds bnb adopt
best value line initializes id lines initializes threshold
innity line sends cost message parent agent line
summary following messages sent cycle
message value agent agent
message value agent agent
message value agent agent
message value agent agent
message cost agent agent
message cost agent agent
message cost agent agent
cycle root agent receives cost message sent child agent cycle since
context agent compatible context message
improves bounds updates bounds node b bounds message
innity respectively lines updates bounds nodes b lines


fibnb adopt asynchronous branch bound dcop



change value since lower bound node lbx
value




still smaller pruning quantity min hx u bx min
sends value messages child agent pseudo child agent lines

agent receives value message sent parent agent cycle updates
context since id agent context smaller
id message line threshold remains unchanged since
desired threshold message agent receives cost
messages sent child agents cycle since context compatible contexts messages respectively
improves bounds updates bounds node bounds rst message
respectively bounds node e bounds second message
respectively lines updates bounds nodes c b lines


value da
changes value since lower bound node c lbx



longer smaller pruning quantity min hx u bx
min
takes best value line increments id lines sends value messages
child agents lines sends cost message parent agent
line
leaf agent receives value messages sent parent agent pseudo parent
agent cycle updates context
since ids agents context respectively smaller
ids messages respectively line threshold remains
unchanged since desired threshold message bounds
reinitialized since context compatible previous context line sends
cost message parent agent line
leaf agent receives value message sent parent agent cycle updates
contexts since id agent context smaller
id message line threshold remains unchanged since
desired threshold message bounds reinitialized since
context compatible previous context line sends cost message
parent agent line
summary messages sent cycle identical ones sent cycle
except messages sent agents follows
message value agent agent
message value agent agent
message cost agent agent
message cost agent agent
message cost agent agent
value messages dierent agent changed value cost
messages dierent agent changed bounds context agents
changed contexts
cycles messages sent cycle identical ones sent cycle
except messages sent agents follows
message cost agent agent
message cost agent agent



fiyeoh felner koenig

cost messages dierent agents changed contexts
termination conditions holds nite amount time upper bound node


u bx
larger lower bound node lbx line root
agent sends terminate messages child agents line terminate
messages propagate pseudo tree line agents terminate bnb adopt
terminates nine cycles minimal solution cost

bounded error approximations
section present three approximation mechanisms allow bnb adopt trade
solution cost smaller runtime bound error solution cost user dened
error bound first modify absolute error mechanism adopt modi et al
work bnb adopt approximation mechanism allows users specify absolute error
bound solution cost example solution cost larger
minimal solution cost however often much desirable specify relative error bound
solution cost example solution cost percent larger
minimal solution cost equivalently times larger minimal solution cost cannot
done absolute error mechanism without knowing minimal solution cost priori
thus introduce two approximation mechanisms allow users specify relative error bound
solution cost namely relative error mechanism weighted heuristics mechanism
approximation mechanisms let root agent r root agent maintain
limit limr root agent uses limit way termination condition
r
r
approximation mechanisms updates dierently termination condition u bx
r lbx r
r
r
line pseudocode bnb adopt replaced u bx r lim root agent updates
limit lines pseudocode outside preceding statement
absolute error mechanism
absolute error mechanism adopt requires user dened absolute error bound b
species solution cost b larger minimal solution cost
approximation mechanism easily modied bnb adopt setting limit follows
limr



r
b lbx
r



bnb adoptaem resulting variant bnb adopt absolute error mechanism
bnb adoptaem terminates upper bound root node equal solution
cost solution smallest solution cost found far larger limit
equal absolute error bound b plus lower bound root node lower
bound minimal solution cost bnb adoptaem terminates solution cost
equal upper bound root node although minimal solution cost could small
lower bound root node thus terminates solution cost b larger
minimal solution cost figure shows trace bnb adoptaem absolute error
bound b example dcop bnb adoptaem terminates three cycles
suboptimal solution cost six cycles faster bnb adopt
relative error mechanism
often much desirable specify relative error bound solution cost rather
absolute error bound fortunately absolute error mechanism bnb adopt easily
changed relative error mechanism setting limit follows relative error


fibnb adopt asynchronous branch bound dcop









lim

ub infinity



lim

ub infinity


























































x

x









x

x

x

x

x x

x x

x x

x x

x x

x x














x

x





x

x

x

x

x x

x x

x x

x x

x x

x x

cycle












lim

ub







x x

x x



x




cycle

x

x

x

x

x

x x

x x

x x

x x

cycle

figure trace update lower bounds bnb adoptaem b








lim

ub infinity



lim

ub infinity


























































x

x









x

x

x

x

x x

x x

x x

x x

x x

x x














x

x





x

x

x

x

x x

x x

x x

x x

x x

x x

cycle

cycle












lim

ub







x x

x x



x




x

x

x

x

x

x x

x x

x x

x x

cycle

figure trace update lower bounds bnb adoptrem p
mechanism requires user dened relative error bound p species solution
cost p times larger minimal solution cost
limr

r
p lbx
r



bnb adoptrem resulting variant bnb adopt relative error mechanism
bnb adoptrem terminates upper bound root node equal solution
cost solution smallest solution cost found far larger limit
equal relative error bound p times lower bound root node lower
bound minimal solution cost bnb adoptrem terminates solution cost
equal upper bound root node although minimal solution cost could small
lower bound root node thus terminates solution cost p times
larger minimal solution cost figure shows trace bnb adoptrem relative
error bound p example dcop bnb adoptrem terminates three cycles
suboptimal solution cost six cycles faster bnb adopt
weighted heuristics mechanism
second way implementing relative error bound bnb adopt since bnb adopt
uses admissible heuristic values common practice context trade solution
cost smaller runtime weighted heuristic values pohl derived
admissible heuristic values multiplying user dened weight w
resulting heuristic values inadmissible longer guaranteed nd cost minimal
solutions guaranteed terminate solution cost w times larger
minimal solution cost pohl approximation mechanism easily modied
bnb adopt setting limit follows
limr





r
lbx
r



fiyeoh felner koenig









lim

ub infinity



lim

lim

uba infinity



uba




















































x

x









x

x

x

x

x x

x x

x x

x x

x x

x x














x

x



x

x

x

x

x x

x x

x x

x x

x x

x x

cycle

cycle





















x x

x x



x




x

x

x

x

x

x x

x x

x x

x x

cycle

figure trace update lower bounds bnb adoptw hm w
initializing lower bounds lba c
x follows
lba c
x

w ha c
x



agents values child agents c contexts x bnb adoptw hm
resulting variant bnb adopt weighted heuristics mechanism bnb adoptw hm
terminates upper bound root node equal solution cost solution
smallest solution cost found far larger limit equal lower
bound root node lower bound w times minimal solution cost bnbadoptw hm terminates solution cost equal upper bound root node
although minimal solution cost could small lower bound root node divided
w thus terminates solution cost w times larger minimal
solution cost figure shows trace bnb adoptw hm w example dcop
bnb adoptw hm terminates three cycles suboptimal solution cost
six cycles faster bnb adopt

correctness completeness
section prove correctness completeness bnb adopt suboptimal
variants denitions lemmata theorems corollaries hold bnb adopt suboptimal variants except mentioned otherwise therefore agent uses following update
equation values child agents c contexts x initialize bounds lba c
x
c
lba c
x w hx



weight w oating point number satises w heuristic values
ha c
x oating point numbers satisfy
c
ha c
x x



messages sent end cycle received beginning cycle largest
duration time message sent time processed largest duration
cycle
lemma two contexts x x arbitrary agent agree values ancestor


x
agents p scp agent x

proof denition x x reduced context contains values ancestor agents

sum constraint costs constraints
p scp agent gamma cost x


fibnb adopt asynchronous branch bound dcop

involve agent one descendant agents minimized possible values agent
descendant agents assumption ancestor agents agent take values

thus depends values ancestor agents including
context x gamma cost x
parent agent agent parent pseudo parent agents agent one
descendant agents values ancestor agents p scp agent therefore




x
x
similarly x x
definition contexts correct ids values agents contexts equal
ids agents implies values agents contexts equal
values agents
lemma context x arbitrary agent change period time


lower bounds lba c
x lbx lbx monotonically non decreasing upper
c


bounds ubx u bx u bx monotonically non increasing period time
values dom child agents c c

proof since context x change delta values x
constant bounds
initialized updated according update equations thus lower bounds
monotonically non decreasing upper bounds monotonically non increasing

lemma value arbitrary ancestor agent p scp arbitrary agent
change current time future time
value agent p id context agent equal value agent p id
respectively time time
proof assume value arbitrary ancestor agent p scp arbitrary agent
change current time future time
following two cases
case agent p parent pseudo parent agent agent sent value message
agent value id time cycle took
value time since duration cycle larger
agents send value messages end every cycle agent receives value message
time since messages delivered nite delay updates value
agent p id context time since update done cycle
duration cycle larger thus value agent p id
context agent equal value agent p id respectively
time time since agent p change
value time time
case agent p parent pseudo parent agent agent one pseudo child
agents c descendant agent agent agent p sent value message agent c
value id time agent c receives value message time
updates value agent p id context sends cost message parent
agent pa c updated context time agents send cost messages
end every cycle agent pa c receives cost message time
updates value agent p id context sends cost message parent
agent pa pa c updated context time process continues
agent updates value agent p id context time n
n number messages chain messages thus value agent p
id context agent equal value agent p id respectively
time time n since agent
p change value time time



fiyeoh felner koenig

corollary values ancestor agents p scp arbitrary agent
change current time future time context
agent correct time time
c
c
c
lemma lbx
c w x c w u bx c times child agents c c arbitrary
c
c
c
c
agent contexts x lbx w x
w ubx times context
x agent values dom child agents c c

proof prove lemma induction number times agent changes context
c
updates bounds lba c
x ubx arbitrary value arbitrary child agent c
agent initializes bounds conclusion lemma holds agent context
x initializes bounds since
c
lba c
x w hx

eq

w

eq

c
x



w uba c
x

eq

unchanged context x agent induction basis assume lemma
holds agent changed context updated bounds number times induction assumption holds agent changes context updates bounds one
time induction step following two cases split operations
receiving cost message two parts
case conclusion lemma holds agent changes context x x
receiving value cost message two contexts agree values
ancestor agents p scp c since agent change bounds thus
lba c
lba c
x
x
c
w x


induction assumption

c
w x

c
ubx
c
x

c
x

lemma


uba c

x

premise case





premise case
induction assumption
lemma

receiving value cost message since contexts x x agree values
ancestor agents p scp c
case conclusion lemma holds agent updates bounds lba c
x
c
c
c


ubx lbx ubx respectively receiving cost message child
c
c
c
agent c bounds lbx
compatible context x
c u bx c context x
agent value since



fibnb adopt asynchronous branch bound dcop

ca max lba ca lb c c
lb
x
x
x
c
c
max w x
w x c

eq
induction assumption premise lemma

c
c
max w x
w x

w
ca
ub
x

lemma

c
x


c
min uba c
x u bx c
c
c
min x
x c

eq
induction assumption premise lemma

c
c
min x
x



lemma

c
x


receiving cost message since contexts x x c agree values
ancestor agents p scp c
c
c
thus lba c
x w x w ubx times values dom child
agents c c






lemma lbx
w x w u bx lbx w x w u bx times

values dom context x arbitrary agent

proof prove lemma induction depth agent pseudo tree lemma
holds leaf agent pseudo tree context x since


lbx
x

eq


x


x

x


eq
eq



u bx



eq





values times thus lbx
x w x w u bx values
times furthermore


lbx





u bx


min


lbx


eq

ddom

min


x


see

ddom


x

min

eq
eq


u bx

ddom



min


x


see

ddom

x


eq





times thus lbx
x w x w u bx times induction basis assume
lemma holds agents depth pseudo tree induction assumption
holds agents depth pseudo tree time update
bounds induction step lemma holds agent context x since



fiyeoh felner koenig





lbx
x

lba c
x

eq

cc




x


c
w x


induction assumption lemma

cc

w x



u bx
x

eq



uba c
x

eq

cc




x


c
x


induction assumption lemma

cc

x


eq




thus lbx
w x w u bx times values dom furthermore


lbx




min


lbx


eq

ddom

min


w x


see

ddom

w

min


x


ddom


w x


u bx





eq


min u bx

ddom

min

eq


x


see

ddom


x


eq




thus lbx
w x w u bx times

definition potential agent context x

lbx




ddom w


u bx


lemma context x arbitrary agent longer changes potential
agent monotonically non increasing decreases positive constant every time
agent changes value


proof lower bounds lbx
monotonically non decreasing upper bounds u bx
monotonically non increasing values according lemma since context x
agent longer changes therefore potential agent monotonically non increasing


furthermore agent changes value value minddom lbx
lbx

line thus lower bound lbx must strictly increased time
agent changed value time changes value value thus
potential decreased positive constant namely smallest possible increase

lower bound lbx
assume constraint costs weights heuristic values integers
smallest possible increase bounded one possible values

lbx
combinations constraint costs weighted heuristic values similar statement
holds constraint costs weights heuristic values oating point numbers since
transformed integers multiplying suciently large integer

lemma agents change values nite number times


fibnb adopt asynchronous branch bound dcop

proof assume lemma hold choose agent changes value
innite number times whose ancestor agents p scp change values nite
number times exists time ancestor agents change values
longer exists later time agent longer changes context x according
corollary every time agent changes value afterwards potential decreases
positive constant according lemma towards minus innity however potential cannot


become negative since lbx
w u bx values according lemma
contradiction thus agents change values nite number times

lemma bnb adopt suboptimal variants terminate earlier u bx



lbx nite amount time agents contexts x

proof prove lemma induction depth agent pseudo tree exists
time agent changes value longer according lemma exists later
time contexts agents correct longer change according corollary let
x context agent point time agents exists even later
c




time bounds lba c
x lbx lbx ubx u bx u bx longer change

agents values child agents c since lower bounds lba c
x lbx
c



lbx monotonically non decreasing upper bounds lbx u bx u bx

monotonically non increasing agents values child agents c according lemma






lbx
w x w u bx lbx w x w u bx agents
c
c
values according lemma lbx w ubx agents values
child agents c according lemma smallest possible increases lower bounds
smallest possible decreases upper bounds larger positive constant since
possible values bounds combinations constraint costs heuristic values
explained detail proof lemma consider rst cost message agent
sends time earliest time cost messages processed
receiving agents lemma holds leaf agent pseudo tree context x since


lbx
x

x


eq
eq



u bx
x

x


eq
eq

values considered time furthermore

lbx





u bx


min


lbx


min


x


eq

ddom

see

ddom


x

min

eq
eq


u bx

ddom



min


x


see

ddom


x


eq



considered time thus u bx
lbx considered time induction basis
assume lemma holds agents depth pseudo tree considered time
induction assumption holds agents depth pseudotree considered time induction step agent context x



fiyeoh felner koenig



lbx
x



lba c
x

eq

c
max lba c
x lbx c

eq

cc

x




cc

x




c
lbx
c

cc




x






c
u bx
c

induction assumption

cc

x




c
min uba c
x u bx c

cc




x






uba c
x

eq

cc

u bx


eq


value considered time since bounds longer change thus u bx





value



considered
time
since
agent



change

value

lbx





considered time must hold lbx


min
h

u
b

line


lb

xa
xa
x

minddom lbx

line


rst
disjunct
implies






min hx
u bx u bx

u bx


lbx

eq
see



min hx
u bx

rst disjunct

value contradiction second disjunct implies


u bx
u bx

lbx




min

eq
see


lbx


second disjunct

ddom


lbx


eq



value thus u bx
lbx

theorem bnb adopt suboptimal variants terminate nite amount time


proof bnb adopt suboptimal variants terminate earlier u bx
lbx
nite amount time agents contexts x according lemma
r
r
r
r
particular u bx
root agent r limr lbx
r lbx r lim
r bnb adopt
r
r

b



bnb adopt

limr p lbx
bnb adoptw hm limr b lbx
r
r
aem
p bnb adoptrem according section thus termination condition
r
r
r
r
u bx
suboptimal
r lbx r bnb adopt termination condition u bx r lim
variants satised
r
theorem bnb adopt terminates minimal solution cost x
r



fibnb adopt asynchronous branch bound dcop

proof bnb adopt terminates nite amount time according theorem solution
r
r
r
cost bnb adopt upper bound u bx
r root agent r u bx r lbx r upon termination
r
r
r
according termination condition w u bx r w x r lbx r according lemma
r
r
r
therefore u bx
r x r lbx r since w
theorem bnb adoptaem terminates solution cost bounded
r
user dened absolute error bound b plus minimal solution cost x
r
proof bnb adoptaem terminates nite amount time according theorem
r
r
r
solution cost bnb adoptaem upper bound u bx
r root agent r u bx r lim
r
r
r
b lbx r upon termination according termination condition lbx r w x r according
r
r
lemma therefore u bx
r b x r since w
theorem bnb adoptrem terminates solution cost bounded
r
user dened relative error bound p times minimal solution cost x
r
proof bnb adoptrem terminates nite amount time according theorem
r
r
r
solution cost bnb adoptrem upper bound u bx
r root agent r u bx r lim
r
r
r
p lbx r upon termination according termination condition lbx r w x r according
r
r
lemma therefore u bx
r p x r since w
theorem bnb adoptw hm terminates solution cost bounded
r
user dened weight w times minimal solution cost x
r
proof bnb adoptw hm terminates nite amount time according theorem
r
r
r
solution cost bnb adoptw hm upper bound u bx
r root agent r u bx r lim
r
r
r
upon
termination
according


termination
condition
lb

w


according

lbx
r
xr
xr
r
r
lemma therefore u bx

w



r
xr

experimental evaluations
section compare bnb adopt two memory bounded dcop search
restrict communication agents share constraints namely adopt ncbb
compare three suboptimal variants bnb adopt use distributed
dfs max degree heuristic hamadi bessiere quinqueton used
adopt construct pseudo trees use dp ali et al used adopt
pre calculate heuristic values adopt bnb adopt dp solves relaxed version
given dcop backedges ignored dynamic programming
ncbb calculates heuristic values search rather pre processing step
runtime metrics
use two common runtime metrics namely non concurrent constraint checks meisels kaplansky
razgon zivan cycles modi et al
non concurrent constraint checks ncccs ncccs weighted sum processing
communication time every agent maintains counter n ccc initialized
agent assigns n ccc n ccc every time performs constraint check
account time takes perform constraint check assigns n ccc

max n ccc n ccc every time receives message agent account

time takes wait agent send message n ccc transmission time
message use simulate fast communication simulate
slow communication number ncccs largest counter value agent



fiyeoh felner koenig

sensors





targets



















constraints

unit

figure example allocating targets

figure example scheduling meetings

ncccs good runtime metric ratio processing communication time
estimated reliably
cycles cycles time slices cycle time required agent process incoming
messages queue send outgoing messages processed receiving
agents next cycle thus number cycles indicates length longest chain
messages agents cycles good runtime metric communication time
much larger processing time cycles become better better runtime metric
future since communication time expected remain relatively stable
processing time expected decrease silaghi lass sultanik regli matsui yokoo
dcop types
use three dcop types experiments namely graph coloring sensor
network meeting scheduling
graph coloring graph coloring involve coloring vertices graph taking
restrictions colors adjacent vertices account agents vertices
domains colors constraints adjacent vertices vary
number vertices constraint density ratio number
constraints number agents sparse graphs dense graphs
range constraint costs range small range range large
range agent three possible values average experimental
dcop instances randomly generated constraints randomly generated
integer constraint costs
sensor network sensor network involve assigning targets sensors sensor
network taking restrictions availability sensors restrictions number
sensors need track target priorities targets account
agents targets domains time slots tracked
constraints adjacent targets maheswaran et al b figure shows sensor
network targets located grid target surrounded four sensors
needed track target vary number targets
use time slots cost assigning time slot target assigned
adjacent target innity precise since sensor cannot track
targets time slot cost targets tracked time
slot costs range average experimental
dcop instances randomly generated integer constraint costs
meeting scheduling meeting scheduling involve scheduling meetings
employees company taking restrictions availability well priorities
account agents meetings domains time slots
held constraints meetings share participants maheswaran et al


fibnb adopt asynchronous branch bound dcop

graph coloring density
communication cost

graph coloring density
communication cost

e
adopt
bnb adopt
ncbb

e

nccc

nccc

e

e
e

adopt
bnb adopt
ncbb

e
e
e



























number vertices






graph coloring density







graph coloring density
communication cost

e

adopt
bnb adopt
ncbb

nccc

e
cycles



b

e

e
adopt
bnb adopt
ncbb

e
e
e

e









number vertices























graph coloring density
communication cost

e



number vertices

c

graph coloring density
e

cycles

adopt
bnb adopt
ncbb

e
nccc



number vertices

e
e
e

e
adopt
bnb adopt
ncbb

e
e

































number vertices

number vertices

e

f

figure experimental comparing adopt bnb adopt ncbb graph coloring
constraint costs ranging

b figure shows hierarchical organization units supervisor three
subordinates example supervisor three subordinates unit
assume possible meetings one entire unit e g two parent child meetings
e g two sibling sibling meetings e g vary number
meetings unit units use time slots cost assigning
time slot meeting least one participant another meeting
time slot innity precise since person cannot attend
one meeting time cost non scheduled meeting costs
range average experimental dcop instances
randomly generated integer constraint costs



fiyeoh felner koenig

e

graph coloring density
communication cost

e
e
nccc

nccc

e

graph coloring density
communication cost

e
adopt
bnb adopt
ncbb

e

e
adopt
bnb adopt
ncbb

e

e

e










range constraint costs







range constraint costs



b

graph coloring density
e

e

graph coloring density
communication cost

nccc

cycles

e
e
adopt
bnb adopt
ncbb

e

e
e

adopt
bnb adopt
ncbb

e

e

e










range constraint costs

c

e







graph coloring density
communication cost

graph coloring density
e

e

e
cycles

nccc



range constraint costs

e
e

adopt
bnb adopt
ncbb

e

e

adopt
bnb adopt
ncbb

e

e

e








range constraint costs









range constraint costs

e

f

figure experimental comparing adopt bnb adopt ncbb graph coloring
vertices

experimental optimal dcop search
rst compare bnb adopt adopt ncbb figure shows experimental
graph coloring constraint costs ranging varied
number vertices figure shows experimental graph coloring
vertices varied range constraint costs figures c c
coloring sparse graphs figures f f coloring
dense graphs axes log scale runtimes ncccs cycles dcop search
sparse graphs faster dense graphs example larger
likelihood independent dcop subproblems sparse graphs bnb adopt generally faster
ncbb sparse graphs dense graphs bnb adopt allows agents send
messages parent agents pseudo tree along edges pseudo tree ncbb



fibnb adopt asynchronous branch bound dcop

sensor network
communication cost

e

e

e

e
nccc

nccc

sensor network
communication cost

e
e

adopt
bnb adopt
ncbb

e

adopt
bnb adopt
ncbb

e
e
e

e

e









number targets







b

sensor network

meeting scheduling
communication cost

e

e
adopt
bnb adopt
ncbb

e
nccc

cycles

e
e
e

e
adopt
bnb adopt
ncbb

e

e

e









number targets





c







meeting scheduling
e

e

e
cycles

e

e
adopt
bnb adopt
ncbb

e



number meetings



meeting scheduling
communication cost

nccc


number targets

e
adopt
bnb adopt
ncbb

e

e

e








number meetings







e









number meetings







f

figure experimental comparing adopt bnb adopt ncbb sensor network
meeting scheduling

allows agents send messages pseudo parent agents along backedges pseudotree thus agents ncbb receive updates faster agents bnb adopt eect
prevalent dense graphs since backedges dense graphs however dierence
bnb adopt ncbb becomes negligible communication slow
figure shows bnb adopt least half order magnitude faster adopt
number vertices small speedup adopt increases number vertices
gets larger dcop thus become complex similarly figure shows
speedup adopt increases range constant costs increases dcop
thus become complex however adopt faster bnb adopt simple dcop
example adopt requires fewer cycles bnb adopt dcop
constraint costs ranging figure shows trend sensor network meeting
scheduling reason behavior follows adopt uses memory bounded best

fiyeoh felner koenig

sensor network
communication cost

e

sensor network
communication cost

e

nccc

nccc

e
e
adopt

e

e
adopt

bnb adopt

bnb adopt

e

e






weight



















b

sensor network
e

sensor network
unique contexts explored

e

contexts

cycles



weight

e
adopt

adopt
bnb adopt

bnb adopt

e

e






weight









c



weight


sensor network
repeated contexts explored


contexts

e
e

adopt
bnb adopt

e
e






weight





e

figure experimental cause speedup adopt bnb adopt
rst search thus exploits heuristic values well needs repeatedly reconstruct partial
solutions purged memory especially heuristic values poorly informed bnbadopt uses depth rst branch bound search thus exploit heuristic values
quite well repeatedly reconstruct partial solutions adopt thus
faster bnb adopt dcop well informed heuristic values simple
dcop
conrm intuition additional experiment sensor network four
targets dierent informedness heuristic values use heuristic values cha c
x
c ha c
x heuristic values calculated dp used figures c
number ncccs dierent weights c heuristic values well informed large
weights adopt indeed faster bnb adopt since adopt relies heuristic
values bnb adopt speedup adopt much larger bnb adopt
heuristic values get informed figures e number unique



fibnb adopt asynchronous branch bound dcop

dierent repeated contexts per agent dierent weights c heuristic values
well informed large weights agents adopt explore fewer unique contexts agents bnbadopt since focused search however heuristic values poorly
informed small weights explore unique contexts agents adopt explore many
repeated contexts agents bnb adopt since need reconstruct partial solutions
purged memory agents bnb adopt explore repeated contexts even though
reconstruct partial solutions reason behavior distributed nature
bnb adopt example assume context agent next
context centralized variant bnb adopt would ids omitted
simplicity agent updates context receives message
agent takes value agent updates context
receives message agent takes value thus agent explores intermediate
context centralized variant bnb adopt would explore counts
repeated context agent explores context intentionally future overall bnb adopt
tends faster adopt heuristic values poorly informed small weights thus
bnb adopt great potential dcop search since heuristic values often poorly
informed complex dcop dcop large numbers agents large
domains large numbers constraints large ranges constraint costs
experimental suboptimal variants bnb adopt
compare three suboptimal variants bnb adopt experimental
setup identical one optimal dcop search except follows graph
coloring number vertices range constraint costs
constraint density sensor network number targets meeting
scheduling number meetings measure runtimes cycles
ncccs similar however report normalized runtimes runtimes divided
runtime nding cost minimal solution bnb adopt thus normalized runtime
refers one quarter number cycles takes nd cost minimal solution
bnb adopt similarly report normalized solution costs solution costs divided
minimal solution costs thus normalized solution cost refers solution cost
two half times larger minimal solution cost vary relative error bound
worst acceptable normalized solution cost relative error bound p
bnb adoptrem w bnb adoptw hm pre calculate minimal solution costs
set correct value b bnb adoptaem example minimal solution cost
relative error bound p bnb adoptrem w bnb adoptw hm
b bnb adoptaem
figure c shows experimental graph coloring figure shows
normalized solution costs three suboptimal variants increase relative error
bound increases however solution costs remain much smaller error bound
example normalized solution costs three suboptimal variants less rather
relative error bound normalized solution costs bnb adoptaem
usually larger normalized solution costs bnb adoptrem relative error
r
r
bound reason behavior bnb adoptaem terminates u bx

r lim
r
r
r
r
b lbx r p x r lbx r x r minimal solution cost thus solution cost
r
r
r
bnb adoptaem u bx
r lbx r p x r larger minimal solution
r
r
r
cost hand bnb adoptrem terminates u bx
r lim p lbx r thus
r
r
r
solution cost bnb adoptrem u bx r lbx r p lbx r larger
minimal solution cost absolute error bound bnb adoptaem thus smaller
r
r
absolute error bound bnb adoptrem since x
r lbx r initially strictly greater
r
r
absolute error bound bnb adoptrem since x r lbx
r search



fiyeoh felner koenig

graph coloring
solution cost bnb adopt variants

graph coloring
computation time bnb adopt variants

normalized runtimes
cycles

normalized costs







weighted heuristics whm
absolute error aem
relative error rem











relative error bound












weighted heuristics whm
absolute error aem
relative error rem








relative error bound


graph coloring
performance bnb adopt variants

sensor network
performance bnb adopt variants




normalized runtimes
cycles

normalized runtimes
cycles



b


weighted heuristics whm
absolute error aem
relative error rem














normalized costs







weighted heuristics whm
absolute error aem
relative error rem











c




normalized costs






meeting scheduling
performance bnb adopt variants
normalized runtimes
cycles




weighted heuristics whm
absolute error aem
relative error rem











normalized costs





e

figure experimental comparing suboptimal variants bnb adopt
figure b shows normalized runtimes three suboptimal variants decrease
relative error bound increases decrease almost relative error bound
therefore three suboptimal variants terminate almost immediately nding rst solution
normalized runtimes bnb adoptaem usually smaller normalized runtimes
bnb adoptrem relative error bound since bnb adoptaem terminate
suboptimal solution cost within absolute error bound yet within absolute error
bound bnb adoptrem absolute error bound bnb adoptaem strictly greater
absolute error bound bnb adoptrem words bnb adoptaem terminate
r
r
r
suboptimal solution cost p lbx
r u bx r p x r bnb adoptrem

figure c shows normalized runtimes needed achieve given normalized solution cost
bnb adoptw hm terminates faster bnb adoptaem turn terminates faster
bnb adoptrem example normalized runtime needed achieve normalized solu



fibnb adopt asynchronous branch bound dcop

tion cost bnb adoptw hm bnb adoptaem bnbadoptrem thus bnb adoptw hm suboptimal variant bnb adopt best
performance figures e trend sensor network meeting scheduling

conclusions
article introduced branch bound adopt bnb adopt memory bounded
dcop search bnb adopt uses message passing communication framework
adopt changes search strategy adopt best rst search depth rst branchand bound search make adopt faster taking advantage fact dcop
depth bounded search trees properties bnb adopt similar adopt
bnb adopt allows agents operate concurrently order decrease runtime asynchronously order increase robustness bnb adopt restricts communication agents
share constraints order restrictions applications sensor networks finally
bnb adopt orders agents pseudo tree order take advantage independent dcop
subproblems experimental showed bnb adopt nds cost minimal solutions
one order magnitude faster adopt variety large dcop fast
ncbb dcop reason behavior following agents
ncbb operate sequentially thus often idle adopt construct fewer partial solutions
bnb adopt reconstruct partial solutions purged memory
advantage adopt respect number constructed partial solutions decreases
disadvantage respect number reconstructed partial solutions increases heuristic
values become poorly informed thus bnb adopt great potential dcop search
since heuristic values often poorly informed complex dcop
dcop large numbers agents large domains large numbers constraints large
ranges constraint costs
investigated three approximation mechanisms trade solution cost bnbadopt smaller runtime namely absolute error mechanism adopt resulting
bnb adoptaem relative error mechanism resulting bnb adoptrem
weighted heuristics mechanism resulting bnb adoptw hm two approximation mechanisms allow users specify relative error bound often meaningful
absolute error bound weighted heuristics mechanism dominated absolute error mechanism relative error mechanism experiments apply
dcop search well since benet heuristic values focus
searches yeoh koenig sun b
future plan improve bnb adopt following ways first would
reduce number sent messages handle lost messages second would study
dierent pseudo tree arrangements atlas decker sultanik lass regli
pre processing techniques matsui et al aect eciency bnb adopt finally
would compare bnb adopt approximation mechanisms dcop
including optapo dpop variants petcu faltings

acknowledgments
article extension two earlier publications yeoh felner koenig yeoh et al
b contains additional expositions examples proofs thank anton chechetka
providing us implementation ncbb anonymous reviewers helpful
comments done ariel felner spent sabbatical university
southern california visiting sven koenig partly supported u army



fiyeoh felner koenig

laboratory arl u army oce aro award sven koenig
grant w nf oce naval onr award sven koenig grant
n national science foundation nsf award sven koenig grant
israeli science foundation isf award ariel felner grants
views conclusions contained document authors
interpreted representing ocial policies expressed implied sponsoring
organizations agencies companies u government

references
ali koenig tambe preprocessing techniques accelerating dcop
adopt proceedings international joint conference autonomous
agents multiagent systems aamas pp
atlas j decker k complete distributed constraint optimization method nontraditional pseudotree arrangements proceedings international joint conference
autonomous agents multiagent systems aamas pp
bayardo r miranker space time trade solving constraint satisfaction proceedings international joint conference articial intelligence
ijcai pp
bistarelli montanari u rossi f schiex verfaillie g fargier h semiring
csps valued csps basic properties comparison constraints
bowring e pearce j portway c jain tambe k optimal distributed
constraint optimization bounds proceedings international joint conference autonomous agents multiagent systems aamas pp

bowring e tambe yokoo multiply constrained distributed constraint optimization proceedings international joint conference autonomous agents
multiagent systems aamas pp
burke brown k eciently handling complex local distributed constraint
optimisation proceedings european conference articial intelligence ecai pp

chechetka sycara k commitment branch bound search distributed
constraint optimization proceedings international conference autonomous agents
multiagent systems aamas pp
choxi h modi p distributed constraint optimization wireless network
optimization proceedings aaai workshop conguration pp
davin j modi p hierarchical variable ordering multiagent agreement
proceedings international joint conference autonomous agents multiagent
systems aamas pp
dechter r ed constraint processing morgan kaufmann
fitzpatrick meertens l distributed coordination anarchic optimization
lesser v ortiz c tambe eds distributed sensor networks multiagent
perspective pp kluwer
freuder e quinn taking advantage stable sets variables constraint satisfaction proceedings international joint conference articial intelligence
ijcai pp



fibnb adopt asynchronous branch bound dcop

gershman meisels zivan r asynchronous forward bounding distributed
cops journal articial intelligence
greenstadt r overview privacy improvements k optimal dcop extended abstract proceedings international joint conference autonomous agents
multiagent systems aamas pp
greenstadt r grosz b smith ssdpop improving privacy dcop
secret sharing proceedings international joint conference autonomous agents
multiagent systems aamas pp
hamadi bessiere c quinqueton j distributed intelligent backtracking proceedings european conference articial intelligence ecai pp
hirayama k yokoo distributed partial constraint satisfaction proceedings international conference principles practice constraint programming
cp pp
jain taylor tambe yokoo dcops meet real world exploring
unknown reward matrices applications mobile sensor networks proceedings
international joint conference articial intelligence ijcai pp
junges r bazzan evaluating performance dcop real world
dynamic proceedings international joint conference autonomous agents
multiagent systems aamas pp
korf r linear space best rst search articial intelligence
kumar faltings b petcu distributed constraint optimization structured
resource constraints proceedings international joint conference autonomous
agents multiagent systems aamas pp
lesser v ortiz c tambe eds distributed sensor networks multiagent
perspective kluwer
maheswaran r pearce j tambe distributed dcop graphical game proceedings international conference parallel
distributed computing systems pdcs pp
maheswaran r tambe bowring e pearce j varakantham p b taking dcop
real world ecient complete solutions distributed event scheduling proceedings
international joint conference autonomous agents multiagent systems aamas
pp
mailler r lesser v solving distributed constraint optimization cooperative mediation proceedings international joint conference autonomous agents
multiagent systems aamas pp
marinescu r dechter r best rst search graphical proceedings
aaai conference articial intelligence aaai pp
marinescu r dechter r branch bound search combinatorial optimization graphical articial intelligence
matsui silaghi hirayama k yokoo matsuo h directed soft arc consistency
pseudo trees proceedings international joint conference autonomous agents
multiagent systems aamas pp
meisels kaplansky e razgon zivan r comparing performance distributed
constraints processing proceedings distributed constraint reasoning
workshop pp



fiyeoh felner koenig

modi p ali distributed constraint reasoning unreliable communication
zhang w sorge v eds frontiers articial intelligence applications vol
pp ios press
modi p shen w tambe yokoo adopt asynchronous distributed constraint optimization quality guarantees articial intelligence
ottens b faltings b coordinating agent plans distributed constraint optimization proceedings icaps workshop multiagent
pearce j tambe quality guarantees k optimal solutions distributed constraint
optimization proceedings international joint conference articial
intelligence ijcai pp
pecora f modi p scerri p reasoning dynamically posting n ary constraints
adopt proceedings distributed constraint reasoning workshop pp
petcu faltings b approximations distributed optimization proceedings
international conference principles practice constraint programming cp pp

petcu faltings b b scalable method multiagent constraint optimization
proceedings international joint conference articial intelligence ijcai pp

petcu faltings b odpop open distributed constraint optimization proceedings national conference articial intelligence aaai pp
pohl first eect error heuristic search machine intelligence

pohl avoidance relative catastrophe heuristic competence genuine dynamic
weighting computational issues heuristic solving proceedings international joint conference articial intelligence ijcai pp
schiex fargier h verfaillie g valued constraint satisfaction hard
easy proceedings international joint conference articial intelligence
ijcai pp
schurr n okamoto maheswaran r scerri p tambe evolution teamwork
model sun r ed cognition multi agent interaction cognitive modeling
social simulation pp cambridge university press
silaghi landwehr j larrosa j asynchronous branch bound diswcsps
heuristic function consistency maintenance zhang w sorge v eds
frontiers articial intelligence applications vol pp ios press
silaghi lass r sultanik e regli w matsui yokoo operation point
units distributed constraint solvers proceedings distributed constraint reasoning
workshop pp
silaghi yokoo adopt ing unifying asynchronous distributed optimization
asynchronous backtracking autonomous agents multi agent systems
stranders r farinelli rogers jennings n decentralised coordination mobile
sensors max sum proceedings international joint conference
articial intelligence ijcai pp
sultanik e lass r regli w dynamic conguration agent organizations
proceedings international joint conference articial intelligence ijcai pp




fibnb adopt asynchronous branch bound dcop

yeoh w felner koenig bnb adopt asynchronous branch bound
dcop proceedings international joint conference autonomous agents
multiagent systems aamas pp
yeoh w koenig sun x b trading solution cost smaller runtime dcop
search short proceedings international joint conference
autonomous agents multiagent systems aamas pp
yeoh w varakantham p koenig caching schemes dcop search
proceedings international joint conference autonomous agents multiagent
systems aamas pp
yokoo hirayama k distributed breakout solving distributed constraint
satisfaction proceedings international conference multiagent systems
icmas pp
zhang w korf r performance linear space search articial intelligence

zhang w xing z wang g wittenburg l analysis application distributed
constraint satisfaction optimization sensor networks proceedings
international joint conference autonomous agents multiagent systems aamas
pp
zivan r anytime local search distributed constraint optimization proceedings
aaai conference articial intelligence aaai pp
zivan r glinton r sycara k distributed constraint optimization large teams
mobile sensing agents proceedings international conference intelligent agent
technology iat pp




