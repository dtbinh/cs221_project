Journal Artificial Intelligence Research 38 (2010) 49-84

Submitted 11/09; published 05/10

Change Abstract Argumentation Frameworks:
Adding Argument
Claudette Cayrol
Florence Dupin de Saint-Cyr
Marie-Christine Lagasquie-Schiex

ccayrol@irit.fr
bannay@irit.fr
lagasq@irit.fr

IRIT, Universite Paul Sabatier,
118 route de Narbonne, 31062 Toulouse, France

Abstract
paper, address problem change abstract argumentation system.
focus particular change: addition new argument interacts
previous arguments. study impact addition outcome argumentation system, particularly set extensions. Several properties
change operation defined comparing new set extensions initial one,
properties called structural comparisons based set-cardinality setinclusion relations. Several properties proposed comparisons based
status particular arguments: accepted arguments; properties refer
evolution status change, e.g., Monotony Priority Recency.
properties may less desirable according specific applications.
studied two particular semantics: grounded preferred semantics.

1. Introduction
Argumentation become influential approach handle Artificial Intelligence problems
including defeasible reasoning (see e.g., Pollock, 1992; Dung, 1995; Bondarenko, Dung,
Kowalski, & Toni, 1997; Chesnevar, Maguitman, & Loui, 2000; Prakken & Vreeswijk, 2002;
Amgoud & Cayrol, 2002; Nute, 2003), modeling agents interactions (see e.g., Amgoud,
Maudet, & Parsons, 2000; Kakas & Moratis, 2003). Argumentation basically concerned
exchange interacting arguments. set arguments may come either
dialogue several agents available (and possibly contradictory)
pieces information disposal one unique agent. Usually, interaction
arguments takes form conflict, called attack. example, logical argument
pair hset assumptions, conclusioni, set assumptions entails
conclusion according logical inference schema. conflict occurs, instance,
conclusion argument contradicts assumption another argument.
main issue argumentation system selection acceptable sets arguments, called extensions, based way arguments interact (intuitively, acceptable
set arguments must sense coherent strong enough, e.g., able defend
attacking arguments). So, outcome argumentation system
often defined set extensions but, depending applications, may
defined set arguments belongs every extension. convenient explore
concept extension argumentation frameworks, especially Dungs (1995)
c
2010
AI Access Foundation. rights reserved.

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

framework, abstracts arguments nature, represents interaction
form binary relation attack set arguments.
Recent works considered dynamics abstract argumentation frameworks
(Cayrol, Dupin de Saint-Cyr, & Lagasquie-Schiex, 2008; Rotstein, Moguillansky, Garca, &
Simari, 2008b; Boella, Kaci, & van der Torre, 2009a, 2009b). problem study
outcome changes set arguments and/or set attacks
changed. paper, focus case new argument interactions
added argumentation system. study impact addition
set initial extensions. leads us identify properties change operation
respect modification induces outcome. study two main
applications, first one concerns computational issues, second one concerns
definition dialogue strategies. one hand, interest computational processing
knowledge properties change may help deduce
modifications extensions. instance, useful know conditions
change modify previous extensions. hand, knowing impact
adding argument may help choosing good one order achieve given goal.
instance, multi-agent setting, i.e., several agents may present several arguments,
results presented paper help one agent determine arguments
present order outcome dialogue satisfies desired properties.
example, wants widen debate, argument must added induce
change producing larger extensions (i.e. contain arguments, see Section 3
Section 5).
paper organized follows. Section 2 recalls basic concepts argumentation.
Section 3 settles definition change argumentation. Many features taken
account order characterize change operation. first propose class properties
based impact change structure resulting set extensions (see
Section 3.2). second step, define several properties regarding arguments
themselves, particularly accepted change (see Section 3.3).
properties defined regardless semantics.
Then, focus particular change: addition new argument may
interact previously introduced arguments. Section 4 dedicated study
properties addition case two particular semantics, grounded
preferred semantics. give conditions given property satisfied. Section 5
discusses related approaches literature. proofs (and two important lemmas) given Appendix A. additional examples presented Appendix B
illustrating change operations.
Note paper generalizes previous work (Cayrol et al., 2008), argument
addition, called revision, restricted one argument one interaction
existing argumentation system. Here, added argument may interact
number previous arguments. Moreover, broader analysis generalized addition
provided considering new properties as, e.g., Monotony, establishing new
connections different properties.
50

fiChange Argumentation Systems

2. Basic Concepts Argumentation Frameworks
present work lies frame general theory abstract argumentation frameworks proposed Dung (1995). abstract framework assumes set arguments given, well different conflicts them, focuses definition
status arguments.
Definition 1 (Argumentation framework) argumentation framework hA, Ri
pair, non-empty set R binary relation A, called attack relation.
Let A, B A, (A, B) R equivalently ARB means attacks B, B attacked
A.
following, hA, Ri argumentation framework, assume set
arguments finite. First, easy extend concept attack sets arguments.
Definition 2 (Attack set) Let A.1
attacks iff X XRA.
attacks iff X ARX.
main issue argumentation system selection acceptable sets arguments. Intuitively, acceptable set arguments must sense coherent
strong enough (e.g., able defend every attacking argument). argumentation semantics defines properties required set arguments acceptable (this
collective acceptability). selected sets arguments given semantics
called extensions semantics. set extensions characterizes outcome
argumentation system. recall basic concepts used defining usual semantics:
Definition 3 (Conflict-free, defense) Let A.
conflict-free iff A, B ARB.
defends iff attacks argument attacks A. set arguments
defends denoted F(S). F called characteristic function hA, Ri.
literature proposes increasing variety semantics, refining Dungs traditional
ones (Baroni, Giacomin, & Guida, 2005; Caminada, 2006; Dung, Mancarella, & Toni, 2006;
Coste-Marquis, Devred, & Marquis, 2005). paper, well-known traditional semantics considered: grounded, preferred stable semantics.
Definition 4 (Acceptability semantics) Let E A.
E admissible iff E conflict-free defends elements (i.e. E F(E)).
E preferred extension iff E maximal (w.r.t. set-inclusion) admissible set.
1. paper, use denote strict inclusion denote classical inclusion.

51

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

E grounded extension iff E least fixed point (w.r.t. set-inclusion)
characteristic function F.
E stable extension iff E conflict-free attacks argument
belong E.
argumentation framework represented directed graph, called attack
graph, nodes arguments edges represent attack relation. Throughout
paper, examples using graph representation.
Example 1
= {A, B, C, D, F } R = {(A, B), (B, A), (B, C), (C, D), (D, F ), (F, C)}.
admissible sets {}, {A}, {B} {B, D}.
B
C

preferred extensions {A} {B, D}.

grounded extension {}.

F
{B, D} unique stable extension.
Using graph-based representation argumentation framework, extend
definition individual attack follows:
Definition 5 (indirect attack defense) Let G denote attack graph associated
hA, Ri. Let A, B A.
indirectly attacks B iff odd-length path B attack graph
G.
indirectly defends B iff even-length path (with non-zero length)
B attack graph G.
Note case attacks B considered particular case indirect attack.
Dung (1995) proved following results.
Proposition 1 Let hA, Ri argumentation framework.
1. least one preferred extension, always unique grounded extension,
may zero, one many stable extensions.
2. admissible set included preferred extension.
3. stable extension preferred extension, converse false.
4. grounded extension included preferred extension.
5. argument attacked belongs grounded extension (hence
preferred stable extension).
6. R finite, grounded extension computed iteratively applying
function F empty set.
52

fiChange Argumentation Systems

presence cycles attack graph often raised problems, namely
stable semantics, may happen extension exists. Note authors
consider attack graphs without odd-length cycles, arguing odd-length cycle
carries counterintuitive information. following results give properties preferred,
grounded stable extensions depending existence cycles attack graph.
Proposition 2 (Dunne & Bench-Capon, 2001, 2002) Let G denote attack graph associated hA, Ri.
1. G contains cycle, hA, Ri unique preferred extension,
grounded extension unique stable extension.
2. {} unique preferred extension hA, Ri, G contains odd-length cycle.
3. hA, Ri stable extension, G contains odd-length cycle.
4. G contains odd-length cycle, preferred stable extensions coincide.
5. G contains even-length cycle, hA, Ri unique preferred extension.
acceptable sets arguments defined, possible define status
individual argument.
Definition 6 (Argument status) Let hA, Ri argumentation framework
A. Given semantics s:
skeptically accepted iff belongs extension hA, Ri s.
credulously accepted iff belongs least one extension hA, Ri
s.
rejected iff belong extension hA, Ri s.
Obviously, credulous skeptical acceptance coincide grounded semantics.

3. Change Argumentation
introduce formal definition change argumentation enables distinguish
four types change. define properties change argumentation. First,
consider impact change operation structure set extensions,
study structure modified. point view leads definition
structural properties. Then, consider impact change operation set
arguments accepted. Finally, connections classes properties
studied.
Note properties introduce, definition general
sense applied type change. Section 4 (where give conditions
satisfying properties), focus particular case addition
argument interactions.
53

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

3.1 Definition
section, give definition change argumentation. change may concern
set arguments and/or set attacks them. So, least four cases
encountered:
Definition 7 (Change operations) Let hA, Ri argumentation framework.
adding one interaction i0 two existing arguments (i0 = (X, )
X A) change operation defined by:
hA, Rii i0 = hA, R {i0 }i
removing one existing interaction i0 hA, Ri (i0 R) change operation
defined by:
hA, Rii i0 = hA, R \ {i0 }i
adding one argument Z 6 set interactions concerning Z denoted
Iz change operation defined by:


hA, Rii (Z, Iz ) = hA {Z}, R Iz
Here, Iz supposed non-empty set pairs arguments (either form
(X, Z) (Z, X) X A)2
removing one argument Z interacts arguments change
operation defined by:

hA, Rii Z = hA \ {Z}, R \ Iz
Here, Iz denotes set interactions concerning Z, set {(Z, X) |
(Z, X) R} {(X, Z)|(X, Z) R}3
Note case adding new argument (resp. removing existing argument)
interact argument trivial: added (resp.
removed from) extension. Indeed, change interesting concerned
argument interacts previous ones.
recent work dynamics argumentation (Boella et al., 2009a, 2009b),
four types change defined introduced different names, respectively attack refinement, attack abstraction, argument refinement argument abstraction. However, operations attack refinement, attack abstraction argument
abstraction studied restricted context (see Section 5 discussion).
following, identify argumentation framework hA, Ri associated
attack graph G. write X G instead X argument represented node G.
set extensions hA, Ri denoted E (with E1 , . . . , En denoting extensions).
2. Note that, definition, impossible (Z, Z) Iz .
3. Note Z removed, set interactions concerning Z must removed.

54

fiChange Argumentation Systems

change operation produces new framework hA , R represented graph G ,
new set extensions E (with E1 , . . . , Ep denoting extensions).
explained above, changing argumentation framework may modify set extensions. Given semantics, modifications less important. depends
kinds interactions added removed precisely status
arguments involved interactions.
impact change studied two points view:
first one concerns structure set extensions address either
comparison number extensions change, or,
number remains unchanged, comparison contents extensions
change;
second point view concerns status particular arguments.
So, next sections, propose two classes general properties change
operation, one point view. proposed properties characterize relation
particular framework resulting framework change.
3.2 Structural Properties
Structural properties, presented section, based impact change
structure set extensions. Note property, definition general
sense type change operation specified: consist adding
one interaction, removing one interaction, adding argument set interactions
concerning argument, removing one argument. However, sake clarity,

property illustrated section examples change operation ;
reader find examples change operations Appendix B.
Let hA, Ri argumentation framework E set extensions hA, Ri
(under given semantics s). Various situations may encountered general case.
E may empty (implying stable semantics), may reduced singleton
{E1 } (where E1 may empty), may contain one extension {E1 , . . . , En }.
situation one non-empty extension convenient determination
status argument. contrast, several extensions exist, different choices
available. Table 1 summarizes various definitions presented below.
first consider decisive property change operation, meaning G
unique non-empty extension, case G.
Definition 8 (Decisive change) change G G decisive iff E = , E =
{{}}, E = {E1 , . . . , En }, n 2, E = {E }, E 6= {}.
Example 2
1. stable (resp. grounded preferred) semantics, change
Iz = {(Z, A)} decisive since:


B

Z

C

E = (resp. E = {{}}),
E = {{Z, B}}
55

ai Z



fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Property change operation
change decisive
change restrictive
change questioning
change destructive
change expansive
change conservative
change altering

Characterization property
E = E = {{}} |E| > 2
|E | = 1 E 6= {{}}
|E| > |E | > 2
|E| < |E |
E 6= E 6= {{}}
E = E = {{}}
|E| = |E |

Ej E , Ei E, Ei Ej
E = E
|E| = |E |
Ei E s.t. Ej E , Ei 6 Ej

Table 1: Structural properties change operation
2. grounded semantics, change
since:
Z



B

C

B

Z

C

F



B

ai

Z Iz = {(Z, A)} decisive

ai

Z Iz = {(Z, A), (B, Z)}

E = {{A}, {B, D}},
E = {{Z, B, D}}

4. preferred semantics, change
decisive since:


Z Iz = {(Z, A)} decisive

E = {{}},
E = {{Z, B}}

3. preferred semantics, change
since:


ai

E = {{A}, {B}},
E = {{B}} (note Z rejected)

Z

weaker requirement decrease number choices. change G
strictly less extensions G, still least two, called restrictive4 . Note
restrictive property make sense grounded semantics, since
always unique grounded extension.
Definition 9 (Restrictive change) change G G restrictive iff E = {E1 ,
. . . , En }, n 2, E = {E1 , . . . , Ep }, n > p 2.
Example 3
1. preferred (or stable) semantics, change
restrictive since:


B

C

Z

F



ai

Z Iz = {(Z, A)}

E = {{A, C, F }, {A, D}, {B, D}, {B, F }},
E = {{Z, C, F }, {Z, B, D}, {Z, B, F }}

4. work Cayrol et al. (2008), kind change called selective.

56

fiChange Argumentation Systems

2. preferred semantics, change
restrictive since:


B

C

Z

ai

Z Iz = {(Z, A), (B, Z)}

E = {{A}, {B}, {C}},
E = {{B}, {C, Z}} (note Z skeptically
accepted)

opposite point view enables consider changes raise ambiguity, increasing number extensions. case instance G least one
non-empty extension G strictly extensions G. slightly different situation occurs G extension empty one, G one extension.
case, change brings information, decisive. changes called
questioning. restrictive property, questioning property make sense
grounded semantics.
Definition 10 (Questioning change) change G G questioning iff E =
{E1 , . . . , Ep }, p 2, either E = , E = {E1 , . . . , En } p > n 1.
Example 4
1. preferred (or stable) semantics, change
questioning since:


B



Z

C

F

B

Z

C



G

F

ai





B

C

Z Iz = {(Z, A)} questioning

E = ,
E = {{Z, B, F }, {Z, B, G}}

3. preferred semantics, change
(Z, B), (B, Z)} questioning since:
Z

Z Iz = {(Z, A)}

E = {{A, D, F }},
E = {{Z, B, C}, {Z, B, F }, {Z, D, C}, {Z, D, F }}

2. stable semantics, change
since:


ai

ai

Z Iz = {(Z, A), (A, Z),

E = {{A, D}, {B, D}},
E = {{A, D}, {B, D}, {Z}} (note Z skeptically accepted)

Pursuing along previous line, consider changes leading kind decisional
dead-end. case G least one non-empty extension G
extension, empty one5 . change called destructive.
Definition 11 (Destructive change) change G G destructive iff E =
{E1 , . . . , En }, n 1, Ei 6= {} E = E = {{}}.
Example 5
5. two different cases impact: possible decision
argument accepted.

57

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

1. stable semantics, change
since:


B



H

Z

C

G

F

ai

Z Iz = {(Z, A)} destructive

E = {{A, D, F }, {A, D, G}},
E =


2. preferred (or grounded) semantics, change Z Iz = {(Z, A),
(B, Z)} destructive since:
B



E = {{A}},
E = {{}}

Z



3. preferred semantics, change Z Iz = {(Z, A), (Z, B), (F, Z)}
destructive since:
B



C

Z

F



E = {{A}, {B, D}},
E = {{}}

far, considered changes impact number extensions. Now,
interested changes may modify content extensions, without modifying
number extensions. interesting situation occurs extension G
strictly includes one extension G, number extensions same. changes
called expansive.
Definition 12 (Expansive change) change G G expansive iff G G
number extensions extension G strictly includes extension
G.
Example 6 preferred (or stable) semantics, change
{(B, Z)} expansive since:


B

C

Z



ai

Z Iz =

E = {{A, C}, {A, D}},
E = {{Z, A, C}, {Z, A, D}}

particular case set extensions remains unchanged, change called
conservative.
Definition 13 (Conservative change) change G G conservative iff G
G exactly extensions, E = E .
Example 7
1. preferred semantics, change
vative since:


B

C

Z

B

Z

Z Iz = {(B, Z)} conser-

ai

Z Iz = {(A, Z)} conser-

E = {{}},
E = {{}}

2. preferred semantics, change
vative since:


ai

C

E = {{A, C}},
E = {{A, C}}

58

fiChange Argumentation Systems

3. preferred semantics, change
vative since:


B

C

Z



ai

Z Iz = {(A, Z)} conser-

E = {{A, C}, {A, D}},
E = {{A, C}, {A, D}}

Otherwise, may happen G G number extensions
extensions (and sometimes them) altered. called altering change.
Definition 14 (Altering change) change G G altering iff G G
number extensions exists least one extension Ei G Ej
extension G , Ei * Ej .
case instance extension G non-empty intersection
(but include) extension G.
Example 8
1. grounded semantics, change
since:


B

Z

C



B

C

Z Iz = {(Z, A)} altering

ai

Z Iz = {(Z, E), (F, Z)}

E = {{A, D},
E = {{Z, B, D}}

2. preferred semantics, change
altering since:


ai



E

F

Z

E = {{A, C, E}},
E = {{A, C}} (note Z rejected)

discussion summarized Table 2. table, checked
cells #i correspond situations cannot occur:
#1 #2 acceptability semantics argumentation framework may
extension stable semantics. However, stable semantics,
argumentation framework cannot empty extension set arguments
empty. And, assumption, cases #1 #2 correspond argumentation
frameworks non-empty sets arguments (because assumption either Iz 6=
exists one interaction = (X, ), least one X G X
eventually Z belong G ). cases occur change operation
acceptability semantics considered paper.
Note structural properties presented Table 2 mutually exclusive (that
change operation cannot satisfy two them).
59

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

E =



E=

{{}}

{{}}

conservative
#2

#1
conservative

{E1 }

{E1 , . . . , Ep }
p2

decisive

questioning

conservative
expansive
altering

{E1 }

destructive
{E1 , . . . , En }
n2

decisive

questioning
n < p:
questioning
n > p:
restrictive
n = p:
conservative
expansive
altering

Ei 6= {} Ei 6= {}. cell table contains name corresponding
property change operation.

Table 2: Structural properties change operation
3.3 Status-Based Properties
section, interested impact change operation status
particular arguments.
First, interested status arguments accepted
change. leads propose property called Monotony, defined
type change.
Another interesting issue concerns status argument added

change. Obviously, concerns change operation ; leads propose
property called Priority Recency makes sense one type change.
3.3.1 Monotony
Inspired done field non-monotonic inference, define property
monotony expressing arguments accepted change remain accepted
change. Since aim define general properties, make assumption
number extensions, consider different cases acceptance argument
(credulously skeptically accepted).
monotony definition straightforward semantics providing one extension
(such grounded semantics, instance). Following Definition 6, argument
accepted (credulously skeptically) hA, Ri iff belongs (unique) extension
G. So, particular case, monotony means extension G included
extension G . several extensions, monotony take different forms.
credulous form corresponds case argument credulously accepted G
60

fiChange Argumentation Systems

credulously accepted G . skeptical form corresponds case
argument skeptically accepted G skeptically accepted G . ideas
lead following definition:
Definition 15 (Monotony)
change G G satisfies Monotony iff extension G included
least one extension G .
change G G satisfies Credulous Monotony6 iff union extensions
G included union extensions G .
change G G satisfies Skeptical Monotony iff intersection extensions G included intersection extensions G .


change operation , Examples 2.1, 2.2, 4.3, 6, 7 illustrate case

property Monotony holds; and, change operation , Examples 2.3, 2.4,
3.1, 3.2, 4.1, 4.2, 5, 8.1, 8.2 illustrate case property Monotony
hold7 .
Obviously, Monotony implies Credulous Monotony. However, Monotony imply
Skeptical Monotony (see Example 4. 3) Skeptical Monotony imply Monotony
(see Examples 2.3, 2.4, 3.1, 3.2). semantics providing one extension, three
notions Monotony coincide.
Monotony property defined level extensions. similar notion
defined level arguments:
Definition 16 (Partial Monotony argument) Let X argument.
change G G satisfies Partial Monotony X iff X belongs extension
G, belongs least one extension G .
easy prove Monotony (resp. Credulous Monotony) implies Partial Monotony
argument G. case property Skeptical Monotony (see
argument Example 2.4).
3.3.2 Priority Recency
next property concerns status argument added change. Inspired done field belief revision (see Alchourron, Gardenfors, &
Makinson, 1985), postulate concerning priority new piece information,
define property expressing new argument accepted change.

property called Priority Recency8 makes sense change operation .
6. Credulous Monotony related well-known decision problem credulous acceptance argumentation (see Definition 6).
7. Appendix B, reader find examples illustrating property Monotony
change operations.
8. property characteristic postulate AGMs sense; inspired Success
postulate proposed Alchourron et al. (1985).

61

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex



Definition 17 (Priority Recency) change G G satisfies Priority
Recency iff G least one extension added argument Z belongs extension
G .
Examples 2.1 2.3, 3.1, 4.1, 4.2, 6, 8.1 examples change satisfying Priority
Recency. Examples 2.4, 3.2, 4.3, 5, 7, 8.2 examples change satisfy Priority
Recency.
3.4 Connections Properties
links structural properties status-based properties established.
following propositions enumerate results hold type change.
Proposition 3
conservative change always satisfies Monotony Skeptical Monotony.
expansive change always satisfies Monotony Skeptical Monotony.
decisive change satisfies Monotony satisfies Skeptical Monotony.
particular case semantics providing one extension, change satisfies
Monotony (and Skeptical Monotony) iff either decisive, expansive, conservative.
Proposition 4
destructive change never satisfies Monotony.
altering change never satisfies Monotony.
restrictive change never satisfies Monotony.


Moreover, particular case change , connections structural
properties Priority Recency established.
Proposition 5
conservative change
destructive change

ai

ai

never satisfies Priority Recency.

never satisfies Priority Recency.

particular case grounded, stable preferred semantics, have:
Proposition 6 grounded, stable preferred semantics, expansive change
ai always satisfies Priority Recency.
results examples given Sections 3.2 3.3, inclusion links

different changes type synthesized Figure 19 . Table 3 gives
references examples propositions used identifying links.
9. inclusion Expansive changes operations satisfy Priority Recency
shown Figure 1, checked stable, grounded preferred semantics see Proposition 6
(hence, may hold semantics).

62

fiChange Argumentation Systems

Monotony
Destructive
Conservative

Questioning
Expansive
Decisive

Priority recency
Restrictive

Altering

Figure 1: Inclusion links changes type

conservative
decisive
destructive
expansive
altering
questioning
restrictive

Priority Recency
Never satisfied (Conseq. 5)
May hold (Ex. 2.1 2.3)
(Ex. 2.4)
Never satisfied (Conseq. 5)
Hold stable, grounded, preferred sem. (Prop. 6)
May hold (Ex. 8.1)
(Ex. 8.2)
May hold (Ex. 4.1)
(Ex. 4.3)
May hold (Ex. 3.1)
(Ex. 3.2)

ai

Monotony
Always satisfied(Conseq. 3)
May hold (Ex. 2.1)
(Ex. 2.3)
Never satisfied (Conseq. 4)
Always (Conseq. 3)
Never (Conseq. 4)
May hold (Ex. 4.3)
(Ex. 4.1)
Never (Conseq. 4)



Table 3: Synthesis connections structural status-based properties

63

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

4. Characterizing Argument Addition Grounded Preferred
Semantics


section, focus change , i.e., addition exactly one argument Z
interacts least one argument belonging A. Indeed, adding argument
may interact existing ones frequently encountered type change
real-life situations. Besides, type change sufficiently complex provide rich
analysis properties results.

Moreover, consider change grounded preferred semantics.
chosen two semantics well-known traditional
semantics existence extensions guaranteed.
purpose identify conditions given property satisfied

change operation . conditions concern added argument associated
interactions, may depend semantics.
Arguably, properties seem desirable others according context.
instance, decisive change operation reduce ignorance, since change one
one extension remains, enabling determine status argument (which
always case change). expansive change raise number
accepted arguments, interesting achieving goal persuasion instance.
conservative change keeps extensions unchanged, interesting want add
argument without changing state knowledge. properties Monotony
Priority Recency desirable focus particular arguments,
want get resulting extensions.
constrast, questioning destructive operation increase ignorance, seems
less interesting.
altering operation enforces new look problem, since nothing
kept state change (the number extension remains
different previous ones). According discussion, provide:
sufficient conditions (CS) interesting properties hold (e.g., decisive,
expansive, conservative, monotonic, satisfying Priority Recency);
necessary conditions (CN) undesirable properties (e.g., questioning, destructive, altering), order avoid properties.
following subsections, consider change
ment Z interactions Iz , that:

ai addition argu-



hA, Rii (Z, Iz ) = hA {Z}, R Iz
4.1 Argument Addition Grounded Semantics
grounded semantics, E = {E} E = {E }.
following result gives condition given accepted argument X remains

accepted change (hence Partial Monotony holds X).
Proposition 7 grounded semantics, X belongs E, Z indirectly

attack X, satisfies Partial Monotony X (i.e. X belongs E ).
64

fiChange Argumentation Systems

Example 9 grounded semantics:
C

B

Z

E = {{A, B}}, E = {{Z, B}}
Z indirectly attack B B E, B E



ai

following result gives condition change
Recency.

satisfies Priority

Proposition 8 grounded semantics, Z attacked G,
Priority Recency (i.e. Z belongs E ).

ai satisfies

Example 10 grounded semantics:


B

Z



C

E = {{A, C}}, E = {{Z}}

Let us first study particular case E = {}.
Proposition 9 grounded semantics,
E = {} following equivalence holds: E = {} iff Z attacked G;

moreover, E = {} Z attacked G, E = {Z} i1 F ({Z}).
So, case E = {}, have:

ai conservative).

Either Z attacked G E = {} (and change

Z attacked G E contains Z arguments

indirectly defended Z (and change decisive).
consequence Proposition 9, have:
Corollary 1 grounded semantics,
E = {} Z attacked G, change
change

ai

ai

decisive;

decisive, Z attacked G hence Z attacks G.

Example 11 grounded semantics, following change


B



C

Z

ai

decisive:

E = {{}}, E = {{Z, A, D}}

Now, study particular case E =
6 {}.
following result gives condition change

ai satisfies Monotony.

Proposition 10 grounded semantics, E =
6 {} Z attack E,
ai satisfies Monotony (i.e. E E ).
precisely, two conditions (one conservative change

another one expansive change ):
65

ai



fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Proposition 11 grounded semantics, E =
6 {} Z attack E,
have:
E defend Z, E = E. (The change

ai

conservative).


E defends Z, E = E {Z} i1 F ({Z}). Moreover, case, Z

attack G, E reduces E {Z}. (The change expansive).
Example 12 grounded semantics, following change


B

ai

expansive:

C

E = {{A}}, E = {{Z, A, D}}
Z

F



consequence Proposition 11, another condition change

ai satisfies Priority Recency:

Corollary 2 grounded semantics, E =
6 {}, Z attack E, E defends

Z, satisfies Priority Recency (i.e. Z belongs E ).
Example 13 grounded semantics:


B

C

E = {{A}}, E = {{Z, A}}
Z

F



Note Corollary 2 hold E defend Z.
Example 14 grounded semantics:


B

C

Z

F



E = E = {A}.
So, E = E = {{A}}.

Another interesting point fact properties change
satisfied grounded semantics:
Proposition 12 grounded semantics, change
restrictive.

ai

ai cannot

never questioning,



case destructive change interesting sufficient add
attack unattacked argument obtaining change:
Proposition 13 grounded semantics, E =
6 {}, Z attacks unattacked

argument Ai G Z attacked G change destructive; converse
holds.
66

fiChange Argumentation Systems

4.2 Argument Addition Preferred Semantics
preferred semantics, always least one extension. E may reduced
singleton {E1 } (where E1 may empty), may contain one extension
{E1 , . . . , En }. Similarly, E may reduced singleton {E1 } (where E1 may empty),
may contain one extension {E1 , . . . , En }.

following result gives condition change satisfies Priority
Recency.


Proposition 14 preferred semantics, Z attacked G, satisfies
Priority Recency (i.e. Z belongs Ei ).
Example 15


B

Z

C



B

preferred semantics:
E = {{A, C}, {B}},
E = {{Z, B}, {Z, C}}
C

Z

E = {{A, C}, {B}},
E = {{Z, A, C}}

following proposition establishes admissible sets G kept cases

(so, cases change neither altering, restrictive):
Proposition 15 preferred semantics,
Z attack Ei , Ei remains admissible G ;
Z attack Ei Ei defends Z, Ei {Z} admissible G .
Example 16 preferred semantics:
Z



B

C

E = {{}},
{}{Z} admissible G E = {{Z, B}}.

Example 12 (continued) preferred semantics, E = {{A}}, {A} {Z}
admissible G , nevertheless, E = {{Z, A, D}}.
Note preferred extensions may appear G .
Example 17 preferred semantics:


B

C

E = {{A}},
E = {{Z, A}, {Z, C}}

Z

consequence Proposition 15, another condition change

ai satisfies Priority Recency.

Corollary 3 preferred semantics, Z attacks extension G, Ei

defends Z, satisfies Priority Recency (i.e. Z belongs Ei ).
67

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Example 18 preferred semantics:


B

C

F

Z



E = {{A, C}, {A, D}},
E = {{Z, A, C}, {Z, A, D}}

following result gives condition change

ai decisive.

Proposition 16 preferred semantics, E = {{}} Z attacked G

even-length cycle G E = {E } Z belongs E (so,
decisive).
Example 11 (continued) preferred semantics, E = {{}}, E = {{Z, A, D}}
Note that, even-length cycles exist graph, change
extensions; change would questioning one:


B



Z

C

F

ai

may induce several

E = {{}},
E = {{Z, A, D}, {Z, A, F }}

reason, considered graphs without even-length cycle Proposition 16.

following result gives necessary condition decisive change (and
condition conservative change).
Proposition 17 preferred semantics, Z attacks argument G E =

{{}}, E = {{}}; equivalently, E = {{}} change Z decisive
Z attacks G.
following result relates case exists non empty extension G

gives conditions either conservative change, expansive
one.
Proposition 18 preferred semantics, Z attacks argument G, E 6=
{{}}, i:
Ei defends Z, Ei {Z} extension G ;
Ei defend Z, Ei extension G ;
moreover, G G number extensions.
Example 6 (continued) preferred semantics, change
= {{A, C}, {A, D}} E = {{Z, A, C}, {Z, A, D}}

ai

expansive: E

consequence previous results, condition change

ai satisfies Monotony.

Proposition 19 preferred semantics, Z attacks extension G

change satisfies Monotony.
68

fiChange Argumentation Systems

particular case non controversial argumentation framework, obtain cona
dition change satisfies Skeptical Monotony. notion controversial
argument introduced Dung, proved argumentation framework
without controversial argument nice properties. Roughly speaking, argument X
controversial indirectly attacks indirectly defends argument .
Proposition 20 preferred semantics, assume G contains controversial

argument. Z attack i1 Ei , change satisfies Skeptical Monotony,
i1 Ei i1 Ei .
grounded semantics, exists proposition destructive change

ai :

Proposition 21 preferred semantics, E 6= {{}}, even-length
cycle G , unattacked argument Ai G attacked G Z attacked G

change destructive.
4.3 Synthesis Results
Tables 4 5, display summary necessary (CN) sufficient (CS) conditions

property hold change (in cases, several CS resp. CN may given
denoted CS, CS , . . . resp. CN, CN , . . .).
tables, E, E , E, E , Ei , Ej denote respectively set extensions change,
change, grounded extension change, change, preferred extension
change change.

Table 4 concerns structural properties change .

Table 5 concerns status-based properties change .
tables underline fact able identify sufficient conditions
(CS) interesting properties hold (e.g., decisive, expansive, conservative,
monotonic, satisfying Priority Recency). properties changes less
desirable questioning, destructive, altering, focused search necessary
conditions (CN), allowing us enunciate sufficient conditions order avoid them.

5. Discussion Future Works
paper, study change argumentation. propose properties characterize
impact change operation outcome argumentation framework. Then,
focus particular type change: addition new argument may interact
previously introduced arguments10 . establish conditions given
property satisfied.
study change important issue Artificial Intelligence, traditionally
concerns belief change. agent receives new piece information, must
adapt beliefs; adaptation always easy may imply drop
previous knowledge. seminal work Alchourron, Gardenfors Makinson (AGM)
(1985) settled formal framework reasoning belief change introduced
10. consider knowledge arguments interactions could built.

69

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Properties change

ai

Grounded semantics

Preferred semantics

Decisive
(E = E = {{}} |E| > 2)
|E | = 1 E 6= {{}}

CS CN: E = {} Z
attacked. (Prop.9)

CS: E = {{}} Z attacked even-length cycle G. (Prop.16)
E = {{}} CN: Z attacks G.
(Prop.17)

Restrictive
|E| > |E | > 2

Never (Prop.12)

CN: even-length cycle
G Z attacks least one Ei
(Prop.15)

Questioning
|E| < |E |

Never (Prop.12)

CN: even-length cycle
G Z attacks G (Prop.17,
Prop.18)

CN CS: E =
6 {} Z attacks unattacked argt
G Z attacked (Prop.13)

CS: E 6= {{}} Z attacked even-length cycle G Z attacks
unattacked argt G (Prop.21)
CN: E 6= {{}} Z attacked odd-length cycle G Z attacks
unattacked argt G (Prop.1.5,
Prop.2.2)

CS: E =
6 {} Z
attack E E defends Z
(Prop.11)

CS: E 6= {{}} Z
attack G i, Ei defends Z
(Prop.18)

CS: E = {} Z attacked
G (Prop.9)
CS : E =
6 {} Z
attack E E defend
Z (Prop.11)

CS: E = {{}} Z
attack G (Prop.17)
CS : E 6= {{}} Z
attack G i, Ei defend Z (Prop.18)

CN: E =
6 {} Z attacks E
(Prop.10)

CN: E 6= {{}} Ei s.t. Z
attacks Ei (Prop.15)

Destructive
E 6= E 6= {{}} (E =
E = {{}})

Expansive
|E| = |E | Ej E , Ei
E, s.t. Ei Ej
Conservative
E = E

Altering
|E| = |E | Ei E s.t. Ej
E , Ei 6 Ej

Table 4: Synthesis necessary sufficient conditions (CN CS) structural

properties Case

70

fiChange Argumentation Systems


Properties change
Monotony
Ei E, Ej E , s.t. Ei Ej

Grounded Semantics

Preferred Semantics

CS: E = {}

CS: Z attack Ei
(Prop.19)

CS : E =
6 {} Z
attack E (Prop.10)
Priority Recency
|E | 1 Ej E , Z Ej

Partial Monotony X
Ei E s.t. X Ei ,
Ej E s.t. X Ej
Skeptical Monotony
i1 Ei j1 Ej

CS: Z attacked (Prop.8)
CS : E =
6 {}, Z attack
E E defends Z (Prop.11)

CS: Z attacked (Prop.14),
CS : Ei E, Z
attack Ei Ei defends Z
(Corol.3)

CS: X E Z indirectly attack X (Prop.7)

cf. Monotony (because, X,
Partial Monotony X implied Monotony)

cf. Monotony (because,
grounded semantics, Skeptical
Monotony Monotony)

CS: controversial argt G
Z attack i1 Ei
(Prop.20)

Table 5: Synthesis necessary sufficient conditions (CN CS) status-based

properties Case

concept belief revision together two types belief change, namely
contraction expansion. Expansion consists adding information without
checking consistency previous beliefs. Contraction operation designed
removing information. Revision consists adding information preserving consistency.
last operation interesting one since, belief theory, inconsistency leads
unexploitable information.
Although change operations defined Section 3 could thought related
AGM theory11 , comparison appropriate two main reasons:
basic underlying formalism different: standard belief revision, logical formulae used knowledge representation whereas, paper, argumentation
framework represents current knowledge. first case, outcome new
set logical formulae, whereas, second case, outcome new argumentation framework induces new set extensions, extension set
arguments.
Revision task knowledge representation strongly related concepts
inference consistency. postulates standard belief revision (AGM)
built consistency notion, since revision aims incorporating new piece
11. Note important cognitive tasks linked belief change theory already studied
field argumentation, see instance work merging Coste-Marquis, Devred, Konieczny,
Lagasquie-Schiex, Marquis (2007).

71

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

information preserving consistency. However, framework argumentation, notion consistency clear standard accepted meaning (even
authors propose take account kind degree inconsistency
argumentation context works Matt & Toni, 2008; Besnard & Hunter,
2008).
Moreover, revision studied framework non-monotonic theories (Witteveen & van der Hoek, 1997) argumentation theory linked nonmonotony, postulates non-monotonic theories based consistency
inference notions explicitly present abstract argumentation
system. So, postulates suited problem. belief revision postulates restated (this case property called Priority
Recency inspired AGM Success postulate ), principles must proposed (for instance, identified property called Monotony
checks kind preservation existing extensions change process).
work extension previous work (Cayrol et al., 2008) presented
preliminary step towards formal characterization notion change argumentation
frameworks. work Cayrol et al. (2008), change defined addition
one argument one interaction studied structural properties
Priority Recency (called classicity Cayrol et al., 2008). new version
work, proposed current paper, taking account addition
several interactions (so properties given Cayrol et al., 2008 hold here)
defining new properties around notion Monotony. look
connections proposed properties conditions (necessary
sufficient) obtaining avoiding properties.
many approaches deal adding new pieces information
within argumentation system. point view adopted family works
different status new piece information added.
instance, Wassermann (1999), well Falappa, Garca, Simari (2004) Paglieri
Castelfranchi (2005), define conditions, expressed terms arguments,
unjustified beliefs become accepted. Pollock Gilliess (2000) approach studies
properties knowledge revision argumentation point view, i.e., problem
generate knowledge base piece information justified good
arguments. kind problem studied Amgoud Vesic (2009) context
argument-based decision. Argument-based decision takes input set options, set
arguments defeat relation among them, returns status option together
total preorder set options. authors study conditions
option may change status new argument received conditions
new argument useless.
Recently, Rotstein, Moguillansky, Falappa, Garca, Simari (2008a) proposed
warrant-prioritized revision operation, consists adding argument theory
way argument warranted afterwards. Even underlying ideas
similar, work differs approach least two points:
First, work Rotstein et al. (2008a), arguments given structure
sub-argument relation, properties minimality, consistency atom72

fiChange Argumentation Systems

icity. definition warranted arguments relies upon evaluation argumentation lines. contrast, approach remains abstract level,
sets accepted arguments computed well-known extension-based
semantics.
Secondly, warrant-prioritized argument revision designed order satisfy
AGM Postulate, corresponding property Priority recency, since
added argument must warranted revised theory. work follows another
direction. propose extensive theoretical study impact addition
outcome abstract argumentation framework, enables us define
several properties change operation.
Concerning general question handling dynamics argumentation, proposal related recent works Boella et al. (2009a, 2009b), Rotstein et al.
(2008b):
work Boella et al. (2009a, 2009b) studies extensions argumentation system remain unchanged set arguments attacks
changed.
four types change proposed Definition 7 introduced
different names, respectively attack refinement, attack abstraction, argument refinement argument abstraction. However, operations attack refinement,
attack abstraction argument abstraction studied,
restrictive point view:
Boella et al. (2009a, 2009b) consider case semantics provides
exactly one extension.
principles defined correspond conditions change
conservative, terminology. property considered.
focus addition argument interactions, work Boella
et al. (2009a, 2009b) viewed complementary work.
Rotstein et al. (2008b) introduce notion dynamics considering arguments
built evidence. Evidence used determine whether argument active (i.e.
used draw inferences) inactive. question addressed Rotstein et al.
(2008b) is: variation set evidence affects nature arguments
(active not)?. question cannot handled pure abstract level
concerns internal dynamics. contrast, remain abstract level:
interested impact change abstract framework outcome
framework.
promising application work could design dialogue strategies. Indeed,
dialogue may defined exchange (called move) arguments two more,
human artificial, agents given protocol. protocol program defines
set allowed moves step dialogue. agent aim
73

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

may develop strategy. works dialogue strategies consider
strategy selects exactly one move (the move must done next). instance,
Bench-Capon (1998) proposes selection strategy (for agents) leading cooperative
dialogues. approaches study strategies context persuasion dialogues,
two agents argue order persuade given initial argument true (or
false according agent opinion). case, strategy helps choose argument must defeated order initial argument accepted (or rejected).
Amgoud Maudet (2002) proposed heuristics select less attackable arguments persuasion dialogue. similar way, Riveret, Prakken, Rotolo, Sartor
(2008) proposed optimal strategy order win debate based probability
success argument cost argument agent. Hunter (2004),
global approach, defined strategy builds optimal subtree
arguments maximizing resonance agent goals minimizing cost.
approach takes another point view. define protocol
restrict dialogue type. Given set arguments may interact, interested
outcome argumentation system, set extensions given
semantics. words, study impact addition argument respect
two points view: first, structural modification induced set extensions,
second, impact acceptability arguments. Although concern acceptability
evolution looks similar aim existing dialogue approaches presented above,
proposal general, since work, interested finding strategies
order make accepted precise argument rather interested establishing
general conditions preservation acceptability. instance, grounded
preferred semantics, provide sufficient condition maintaining argument
accepted arrival new one (Monotony property) sufficient condition
new argument accepted (Priority Recency).
structural point view analysis completely original respect
existing literature. Indeed, analyze impact new argument set extensions
amounts consider addition argument operation performed order
modify form change outcome (by expansive change, decisive
change instance). work reported paper enables us choose right way
changing (which argument must affected change, kind interaction)
order obtain new outcome. plan focus strategies
directing dialogue (i.e., integrated protocol) strategies taking part
(i.e., concerning agent). instance, dialogue arbitrator wants debate
open rather force next speaker use arguments appropriate
expansive change. wants debate focused arguments
appropriate restrictive (and even decisive) change accepted.
several directions research:

1. plan study change operations defined paper, corresponding
removal one argument interactions addition removal
interaction (for instance, exploiting properties symmetry
change operations).
74

fiChange Argumentation Systems

2. would generalize change operations case addition
removal subgraph arguments (which would kind iterated change).
3. think decisive property desirable property change operation.
So, intend investigate question make minimal change12
given argumentation framework unique non-empty extension?.

Acknowledgments
would thank reviewers help interesting suggestions.

Appendix A. Proofs
Lemma 1
X G s.t. (Z, X) Iz , change operation

ai

introduces new cycle G .

X G s.t. (X, Z) Iz , change operation

ai

introduces new cycle G .

words, Z attack argument G, Z attacked G,

change operation introduces new cycle G .
Proof Lemma 1: follows directly fact one argument added.



Proofs Related Section 3.4 (Connections Properties)
Proof Proposition 3: follows directly definitions properties (Definitions 8,
12, 13, 15).

Proof Proposition 4: follows directly definitions properties (Definitions 11,
9, 14, 15).

Proof Proposition 5: follows directly definitions properties (Definitions 11,
13, 17).

Proof Proposition 6:
Grounded semantics: Let us show E ( E Z E . Assume E ( E
Z 6 E . going prove E E (which contradiction assumption
E ( E ), proving F ({}) F ({}), induction 1.
Basic case (i = 1): Z 6 E Z attacked G. Thus, X F ({}) X
G definition X unattacked G . X unattacked G. So,
F ({}) F({}).
Induction hypothesis (for 1 p, F ({}) F ({})):
12. terms number edges add remove and/or terms number arguments add
remove.

75

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Let us first show subset arguments G F (S) G,
F (S) F(S): Let X F (S), means defends X G X G.
exists G attacks X G, attacks X G .
defends X G , attacks . defends X G. F (S) F(S).
Let us compute F p+1 ({}) = F (F p ({})). induction hypothesis, F p ({})
F p ({}). F monotonic, F p+1 ({}) F (F p ({})). let denote
set F p ({}), E G. assumed E ( E Z 6 E
E G. Then, F monotonic, F (S) F (E ) = E G
Due previous point, conclude F (S) F(S). Then, obtain
F p+1 ({}) F(F p ({})) = F p+1 ({}).
Preferred semantics: Given expansive change G Z Iz , let us suppose
exists extension Ej G contain Z. extension included G.
change expansive, exists extension Ei G strictly included Ej . Ei
maximal admissible set inclusion. Since inclusion Ei inside Ej strict, therefore
Ej admissible G. Ej extension G , conflict, hence Ej
defend elements G. exists X Ej attacked G (and thus G )
defended Ej G. means Ej attack . But, since Ej
included G attack G . edge element Ej
G, neither edge G . (Note attacked Z Z Ej )
Stable semantics: Assume exists extension Ej G contain Z.
change expansive, exists extension Ei G strictly included Ej . Since
inclusion strict, exists Ej , belong Ei . assumed
Ej contain Z, G. Ei stable extension G, Ei attacks . Then,
Ei included Ej conflict Ej , contradicts fact Ej stable
extension.


Proofs Related Section 4.1 (Under Grounded Semantics)
Proof Proposition 7: E grounded extension G. Due fact R finite,
E = i1 F ({}). prove induction 1 X belongs F ({}) Z
indirectly attack X, X belongs F ({}).
Basic case (i = 1): X F({}) X attacked G. Since Z attack X,
X remains unattacked G belongs F ({}).
Induction hypothesis (for 1 p, proposition holds): Let X F p+1 ({}).
prove X F p+1 ({})(= F (F p ({}))). Assume X attacked G . Z
attack X, G. X F p+1 ({}) = F(F p ({})), F p ({}) defends X attacking
. exists W F p ({}) attacks , turn attacks X. Z
indirectly attack X, sure Z indirectly attack W . Using induction
hypothesis W , W F p ({}). So, proved F p ({}) defends X G
X F p+1 ({}).

Proof Proposition 8: Z attacked G, Z attacked G . So, due
Proposition 1.5, grounded extension G contains Z.

Proof Proposition 9:
76

fiChange Argumentation Systems

E = {} argument G attacked. Z attacked G, argument
G attacked due Proposition 1.5 Proposition 1.6, E = {}. Z attacked
G, Z attacked G , Z belongs E , empty.
E = {} Z attacked G, Z E . F monotonic,
E fixed point




F , F ({Z}) E 1, {Z} i1 F ({Z}) E . Let

denote {Z} i1 F ({Z}). Now, prove E S. E least fixed


point F , sufficient
proveithat fixed point F . Obviously, F (S) = {X

G s.t. X attacked} i1 F ({Z}). Since E = {}, {X G s.t. X attacked } =

{Z}, F (S) = fixed point F . proved E = {Z} i1 F ({Z}).

Proof Corollary 1:
follows directly Proposition 9. Due Definition 8, grounded semantics,
change decisive E = {} E 6= {}.
Z interacts G, Z attacked G, Z must attack G.

Proof Proposition 10: Due fact R finite, E = i1 F ({}) E =
i1 F ({}). prove induction 1 F ({}) F ({}).
Basic case (i = 1): F({}) attacked G due fact Z
attack E, attacked G F ({}).
Induction hypothesis (for 1 p, F ({}) F ({})): let = F p ({}) = F p ({}).
First, prove F(S) F (S). Let F(S). Obviously, F(S) E. E
Z attack since Z attack E. So, attacked G
attacked G. F(S), defends attacking A. defends G ,
F (S).
Using induction hypothesis, . Moreover, definition F monotonic.
F(S) = F p+1 ({}) F (S) F (S ) = F p+1 ({}). So, E E .

Proof Proposition 11: E =
6 {} Z attack E. Let us first notice (1)
F (E) G, F(E) = E. Indeed, F (E) means E defends G . So,
G, E defends G, i.e., F(E) = E.
Due Proposition 10, E E . So, prove E defend
Z, E E. Indeed, prove F (E) = E. Then, definition E (least fixed
point), follow E E. Let F (E), E defend Z, hence G,
according (1), F(E) = E. Conversely, let E = F(E), let argument
attacks G . Z attack E, 6= Z, G, E defends attacking
A. So, E defends G F (E).
First, prove E defends Z F (E) = E {Z}. Due (1), F (E) G,
F(E) = E. Now, E defends Z, Z F (E). So, F (E) E {Z}.
Conversely, let F(E) = E. E defends G. Z attack E, Z attack
, E defends G , F (E). Z F (E), E {Z} F (E).
particular case Z attack G, Z cannot defend argument. So, F (E
{Z}) = F (E) F (E {Z}) = E {Z}. means E {Z} fixed point
77

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

F , definition E , E E {Z}. Due Proposition 10, E E .
So, E {Z} E . Finally, E reduces E {Z}.

general case, Z attacks G. Let denote E {Z} i1 F ({Z}). prove

E = S. Obviously, E since E {Z} = F (E) E , E contains i1 F (E ),

hence contains i1 F ({Z}), since F monotonic. Conversely, prove
fixed point F definition E (least fixed point), follow E S.
Since F monotonic, F (E) F (S), F ({Z}) F (S) 2
F ({Z}) F (S). So, F (E) = E {Z}, F (S). Conversely, let F (S)
assume
/ E {Z} = F (E). Then, exists
attacker
attacked E. F (S), must attack A. {Z} i1 F ({Z}) attacks A,

means i1 F ({Z}). So, proved F (S), either E {Z}

i1 F ({Z}), S.

Proof Corollary 2: direct consequence Proposition 11.



Proof Proposition 12: direct consequence definitions: restrictive questioning changes need number extensions strictly greater one, exists one
grounded extension.

Proof Proposition 13: E =
6 {}, unattacked arguments denoted Ai G. Ai ,

Ai attacked G Z attacked G . unattacked argument G , 1
F ({}) = {} E = {}. change destructive.
Conversely, change destructive, definition E =
6 {} E = {}. Then, due

Proposition 1.5, unattacked argument G . So, Z attacked Ai (unattacked
argument G) attacked G .


Proofs Related Section 4.2 (Under Preferred Semantics)
Proof Proposition 14: Z attacked G, Z attacked G . So, due
Proposition 1, preferred extension G contains Z.

Proof Proposition 15:
Ei conflict-free G, G . Let Ei attacked G . Z attack
Ei , attacked G Ei admissible G, Ei defends A. So, Ei remains admissible
G.
Z attack Ei , Ei defends Z, Ei attack Z Ei {Z} conflictfree G . Let Ei {Z} attacked G . Either Ei proved
first item Ei admissible G , Ei defends A. = Z, assumed
Ei defends Z. case, Ei {Z} admissible G .


Lemma 2 Ei extension G containing Z, Ei admissible G.
Proof Lemma 2:
78

fiChange Argumentation Systems

Ei contain Z, Ei G. Ei conflict-free G Ei conflict-free G. Let
Ei attacked argument A, G. Ei admissible, defends . So,
argument B Ei attacking A. Ei G, B G. So, proved Ei admissible G.

Proof Corollary 3: Proposition 15, Ei E, Ei {Z} admissible G . So, exists
j 1 Ei {Z} Ej . Lemma 2, Ek extension G containing Z, Ek
admissible G. So, exists 1 Ek Ei . So, Ek Ei Ei {Z} Ej .
consequence, would strict inclusion two extensions G , impossible.
So, cannot exist Ek extension G containing Z, extension G contains Z.

Proof Proposition 16: Z attacked G, Z attacked G Z belongs
preferred extension. Moreover, even-length cycle G, due Lemma 1,
even-length cycle G . So, due Proposition 2.5, G one preferred extension
empty (it contains least Z).


Lemma 3 Z attacks argument G Ei non empty extension G ,
Ei \ {Z} admissible G.
Proof Lemma 3:
Ei conflict-free G Ei \ {Z} conflict-free G G.
Let Ei \ {Z}. Assume argument attacking . 6= Z since Z
attacks argument G. Ei non-empty preferred extension G , argument
B Ei attacking A, B 6= Z (always Z attacks argument G). So,
B Ei \ {Z}, Ei \ {Z} defends . So, Ei \ {Z} admissible G.

Proof Proposition 17: Suppose Z attacks argument G E = {{}}.
(reductio ad absurdum): Assume exists non-empty extension G denoted E .
exists E . Either = Z, G. cases, attacked,
arguments G attacked (since E = {{}}) Z attacks argument G. E must
defend . = Z, E cannot reduced (because Z attacks argument cannot defend
itself). E \ {Z} 6= {}. 6= Z, E \ {Z}, E \ {Z} =
6 {}. Due Lemma 3, E \ {Z}
admissible G E \ {Z} E E preferred extension G. G non-empty
extension, contradiction assumption.

Proof Proposition 18:
Z attacks argument G, due Proposition 15, i, Ei admissible G .
exists preferred extension Ej G including Ei . E 6= {{}}, i, Ei 6= {} Ej 6= {}.
Z 6 Ei , Ei Ej \ {Z}. Due Lemma 3, Ej \ {Z} admissible G, exists
k 1 Ei Ej \ {Z} Ek . Using definition preferred extension (-maximal
among admissible sets), conclude Ei = Ej \ {Z} = Ek . So, either Ej = Ei (if
Z 6 Ej ), Ej = Ei {Z} (if Z Ej ). first case, Ei extension G . second
case, Ei {Z} extension G . Moreover, Z Ej , Ej defends Z (which attacked
G, since attack G) Z attacks argument, Ei = Ej \ {Z} defends Z. So,
79

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Ei defend Z, Ei extension G . hand, Ei defends Z, Ei {Z}
conflict-free G . So, Ei {Z} admissible G case Z Ej Ei {Z}
extension G .
Now, prove G G number extensions. first part
proof, know extension G included extension G . Moreover, two
distinct extensions G cannot included extension G . Indeed, union
two non-empty preferred extensions defends elements strictly contains
extensions. union two extensions cannot conflict-free.
So,we know G least many extensions G G least one nonempty extension. So, Ej E , Ej 6= {}. Due Lemma 3, Ej \ {Z} admissible G. So,
Ej , exists Ei , extension G Ej \ {Z} Ei . first part
proof, have:
Either Ei defends Z, Ei {Z} extension G . Ej \ {Z} Ei ,
Ej Ei {Z}, Ej maximal admissible G , Ej = Ei {Z}.
Ei defend Z, Ei extension G . Ej maximal admissible G ,
Z 6 Ej Ej = Ej \ {Z} = Ei .
So, G G number extensions.

Proof Proposition 19:
E = {{}}, obviously change satisfies Monotony.
G non-empty extension, Proposition 15 applied. extension G
remains admissible G included preferred extension G . So, change satisfies
Monotony.

Proof Proposition 20: Let E = i1 Ei E = i1 Ei .
Let Eg (resp. Eg ) denote grounded extension G (resp G ). Due Proposition 1.4, know
Eg E Eg E . Dung (1995) proved controversial argument,
grounded extension exactly intersection preferred extensions. So, G contains
controversial argument, Eg = E.
Now, Z attack i1 Ei , Z attack Eg , due Proposition 10, E =
6 {}
Eg Eg E = {} i1 Ei = {} inclusion trivially holds. So,

E = Eg Eg E , i1 Ei i1 Ei .
Proof Proposition 21: E 6= {{}} even-length cycle G evenlength cycle G; consequence, according Proposition 2.5 one extension E G;
moreover, E =
6 {}. Since even-length cycle G , know one extension


E G . Assume Z unattacked argument Ai G attacked G ;
unattacked argument G .
Assume E 6= {}. Let X E . X attacked G . Let Y1 denote attacker X. E
admissible, E defends X. E contains X2 attacks Y1 . even-length cycle
G , know X2 6= X. X2 unattacked.
able built infinite sequence distinct arguments:
X attacked Y1 attacked X2 . . . Yp attacked Xp+1 attacked Yp+1 . . .
Xi (resp. Yi s) distinct due absence even-length cycles G .
contradicts assumption finite. E = {} change destructive.
80



fiChange Argumentation Systems

Appendix B. Illustration Properties Change Operations
following examples illustrate structural properties property Monotony

change operations distinct (let us recall property Priority Recency
make sense change operations).


ai




First, notice hA, Rii (Z, Iz ) = hA , R hA , R ii Z = hA, Ri.

example Section 3.2, change illustrated.
Example 4.1 show decisive change
property Monotony.

ai change ai satisfy




Example 5.2 shows decisive change change satisfies property
Monotony .
Example 4.3 shows restrictive change
property Monotony

ai change ai satisfy

Examples 2.3, 3.1, 5.1 show questioning change
satisfy property Monotony

ai

change

ai



Examples 2.1, 2.2, 4.2 show destructive change
satisfy property Monotony

ai

change

ai



Example 8.2 shows expansive change
property Monotony

ai

change

ai

satisfies




Examples 7.1, 7.2, 7.3 show conservative change change satisfies
property Monotony




Examples 6, 8.1 show altering change change satisfy
property Monotony








hA = {A, B, C}, R = {(A, B), (B, C), (C, A)}i, hA, Rii (A, C) decisive
change (before change E = {{}}, change E = {{A}}); inverse
operation hA, R {(A, C)}ii (A, C) destructive.
example,

satisfies property Monotony not.

hA = {A, B, C}, R = {(A, B), (B, C)}i, hA, Rii (C, A) destructive change
(before change E = {{A, C}}, change E = {{}}); inverse
operation hA, R {(C, A)}ii (C, A) decisive.
example,

satisfy property Monotony satisfies it.

hA = {A, B, C}, R = {(A, B), (B, C)}i, hA, Rii (A, C) altering change
(before change E = {{A, C}}, change E = {{A}}); inverse
operation hA, R {(A, C)}ii (A, C) expansive.
81

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

example,

satisfy property Monotony satisfies it.

hA = {A, B, C}, R = {(A, B)}i, hA, Rii (C, B) conservative change (before change E = {{A, C}}, change E = {{A, C}}); inverse
operation hA, R {(A, C)}ii (A, C) conservative.
example,

satisfy property Monotony.

hA = {A, B, C, D}, R = {(A, B), (B, A), (B, C), (D, C)}i, hA, Rii (C, D)
questioning change (before change E = {{A, D}, {B, D}}, change
E = {{A, D}, {B, D}, {A, C}}); inverse operation hA, R{(C, D)}ii (C, D)
restrictive.
example,

satisfies property Monotony not.

hA = {A, B, C, D}, R = {(A, B), (B, A), (B, C), (D, C), (C, D)}i, change
hA, Rii (A, D) restrictive one (before change E = {{A, D}, {B, D}, {A, C}},
change E = {{B, D}, {A, C}}).
inverse operation hA, R {(A, D)}ii (A, D) questioning.
example,

satisfy property Monotony satisfies it.

hA = {A, B, C}, R = {(A, B), (B, C)}i, hA, Rii (A, B) altering change
(before change E = {{A, C}}, change E = {{A, B}}).
example,

satisfy property Monotony.

hA = {A, B, C, D}, R = {(A, B), (B, C), (C, A)}i, hA, Rii (D, A) expansive change (before change E = {{D}}, change E = {{D, B}}).
example,

satisfies property Monotony.

References
Alchourron, C. E., Gardenfors, P., & Makinson, D. (1985). logic theory change:
partial meet contraction revision functions. Journal Symbolic Logic, 50, 510
530.
Amgoud, L., & Cayrol, C. (2002). Inferring inconsistency preference-based argumentation frameworks. Journal Automated Reasoning, 29, 125169.
Amgoud, L., & Maudet, N. (2002). Strategical considerations argumentative agents
(preliminary report). Proc. NMR, pp. 409417.
Amgoud, L., Maudet, N., & Parsons, S. (2000). Modelling dialogues using argumentation.
Proc. ICMAS, pp. 3138.
Amgoud, L., & Vesic, S. (2009). Revising Argumentation-Based Decision Systems.
Proc. ECSQARU, Vol. LNAI 5590, pp. 7182. Springer-Verlag.
Baroni, P., Giacomin, M., & Guida, G. (2005). Scc-recursiveness: general schema
argumentation semantics. Artifical Intelligence, 168, 162210.
Bench-Capon, T. (1998). Specification implementation Toulmin dialogue game.
Proc. JURIX, pp. 520.
82

fiChange Argumentation Systems

Besnard, P., & Hunter, A. (2008). Elements argumentation. MIT Press.
Boella, G., Kaci, S., & van der Torre, L. (2009a). Dynamics argumentation single
extensions: Abstraction principles grounded extension. Proc. ECSQARU
(LNAI 5590), pp. 107118.
Boella, G., Kaci, S., & van der Torre, L. (2009b). Dynamics argumentation single
extensions: Attack refinement grounded extension. Proc. AAMAS, pp.
12131214.
Bondarenko, A., Dung, P., Kowalski, R., & Toni, F. (1997). abstract, argumentationtheoretic approach default reasoning. Artificial Intelligence, 93, 63101.
Caminada, M. (2006). Semi-stable semantics. Proc. COMMA, pp. 121128.
Cayrol, C., Dupin de Saint-Cyr, F., & Lagasquie-Schiex, M. (2008). Revision argumentation system. Proc. KR 2008, pp. 124134. AAAI Press.
Chesnevar, C., Maguitman, A., & Loui, R. (2000). Logical models argument. ACM
Computing surveys, 32 (4), 337383.
Coste-Marquis, S., Devred, C., Konieczny, S., Lagasquie-Schiex, M., & Marquis, P. (2007).
merging Dungs argumentation systems. Artificial Intelligence, Argumentation Artificial Intelligence, 171 (10-15), 730753.
Coste-Marquis, S., Devred, C., & Marquis, P. (2005). Prudent semantics argumentation
frameworks. Proc. ICTAI, pp. 568572.
Dung, P. M. (1995). acceptability arguments fundamental role nonmonotonic reasoning, logic programming n-person games. Artificial Intelligence,
77, 321357.
Dung, P. M., Mancarella, P., & Toni, F. (2006). dialectic procedure sceptical
assumption-based argumentation. Proc. COMMA, pp. 145156.
Dunne, P., & Bench-Capon, T. (2001). Complexity combinatorial properties argument systems. Tech. report, U.L.C.S.
Dunne, P., & Bench-Capon, T. (2002). Coherence finite argument system. Artificial
Intelligence, 141 (1-2), 187203.
Falappa, M., Garca, A., & Simari, G. (2004). Belief dynamics defeasible argumentation
rational agents. Proc. NMR, pp. 164170.
Hunter, A. (2004). Making argumentation believable. Proc. AAAI, pp. 269274.
Kakas, A. C., & Moratis, P. (2003). Argumentation based decision making autonomous
agents. Proc. AAMAS, pp. 883890.
Matt, P., & Toni, F. (2008). game-theoretic measure argument strength abstract
argumentation. Proc. JELIA (LNAI 5293), pp. 285297.
Nute, D. (2003). Defeasible logic. Proc. INAP 2001, LNAI 2543, pp. 151169.
Paglieri, F., & Castelfranchi, C. (2005). Revising beliefs arguments: Bridging
gap argumentation belief revision MAS. Argumentation MultiAgent Systems, pp. 7894. Springer.
83

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Pollock, J., & Gillies, A. (2000). Belief revision epistemology. Synthese, 122 (1-2),
6992.
Pollock, J. L. (1992). reason defeasibly. Artificial Intelligence, 57, 142.
Prakken, H., & Vreeswijk, G. (2002). Logics defeasible argumentation. Handbook
Philosophical Logic, Vol. 4, pp. 218319. Kluwer Academic.
Riveret, R., Prakken, H., Rotolo, A., & Sartor, G. (2008). Heuristics argumentation:
game-theoretical investigation. Proc. COMMA, pp. 324335.
Rotstein, N. D., Moguillansky, M. O., Falappa, M. A., Garca, A. J., & Simari, G. R. (2008a).
Argument theory change: revision upon warrant. Proc. COMMA, pp. 336347.
IOS Press.
Rotstein, N. D., Moguillansky, M. O., Garca, A. J., & Simari, G. R. (2008b). abstract
argumentation framework handling dynamics. Proc. NMR, pp. 131139.
Wassermann, R. (1999). Full acceptance argumentation - preliminary report.
Proc. IJCAI Workshop Practical Reasoning Rationality.
Witteveen, C., & van der Hoek, W. (1997). general framework revising nonmonotonic
theories. Proc. LPNMR (LNAI 1265), pp. 258272. Springer.

84


