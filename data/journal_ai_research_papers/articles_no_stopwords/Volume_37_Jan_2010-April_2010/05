Journal Artificial Intelligence Research 37 (2010) 189-246

Submitted 10/2009; published 02/2010

Action Theory Change
Ivan Jose Varzinczak

ivan.varzinczak@meraka.org.za

Meraka Institute, CSIR
Pretoria, South Africa

Abstract
historically acknowledged Reasoning Actions Change community,
intuitiveness logical domain description cannot fully automated. Moreover,
logical theory, action theories may evolve, thus knowledge engineers need
revision methods help accommodating new incoming information behavior
actions adequate manner. present work changing action domain
descriptions multimodal logic. contribution threefold: first revisit semantics
action theory contraction proposed previous work, giving robust operators
express minimal change based notion distance Kripke-models. Second
give algorithms syntactical action theory contraction establish correctness
respect semantics action theories satisfy principle modularity
investigated previous work. Since modularity ensured every action theory
and, show here, needs computed evolution domain
description, represent limitation method studied. Finally
state AGM-like postulates action theory contraction assess behavior
operators respect them. Moreover, address revision counterpart
action theory change, showing benefits semantics contraction.

1. Introduction
Consider intelligent agent designed perform rationally dynamic world, suppose
reason dynamics automatic coffee machine (Figure 1).

NiceCaf
$

Figure 1: coffee deliverer agent.
Suppose, example, agent believes coffee always hot beverage.
Suppose day gets coffee machine observes cold.
case, agent must change beliefs relationship two
propositions hold coffee hold hot drink. example instance
problem changing propositional belief bases largely addressed
c
2010
AI Access Foundation. rights reserved.

fiVarzinczak

literature belief revision (Alchourron, Gardenfors, & Makinson, 1985; Gardenfors,
1988; Hansson, 1999) belief update (Katsuno & Mendelzon, 1992).
Next, let agent believe whenever buys coffee machine, gets
hot drink. means every state world follows execution buying
coffee, agent ends hot drink. Now, situation machine
running cups, buying, coffee runs shelf agent, contrary
expecting, hold hot drink hands.
Imagine agent never considered relation buying coffee
machine service availability, sense always believed (quite reasonably)
buying prevent users using machine. Nevertheless, someday
agent queuing buy coffee observes agent
bought, machine went order (maybe due lack coffee powder).
Completing agents struggle discovering intricacies operating coffee machine, let us suppose always believed token, possible
buy coffee, provided preconditions close enough button,
free hand, etc, satisfied. Eventually, due blackout, agent realizes
manage buy coffee, even token.
last three examples illustrate cases changing beliefs behavior
action buying coffee mandatory. first one, buying coffee, believed
deterministic outcome, namely always hot drink, seen nondeterministic or, alternatively, different effect specific context (e.g.
cup machine). second example, buying coffee known
side-effects (ramifications) one aware of. Finally, last example,
feasibility action concern questioned light new information showing
context known preclude execution.
cases theory change important one deals logical descriptions
dynamic domains: may always happen one discovers action actually
behavior different one always believed had.
now, theory change studied mainly knowledge bases classical logics,
terms revision update. Since work Fuhrmann (1989), recent studies considered realm modal logics, viz. epistemic logic (Hansson, 1999) dynamic logics (Herzig, Perrussel, & Varzinczak, 2006). Recently
studies investigated revision beliefs facts world (Shapiro, Pagnucco,
Lesperance, & Levesque, 2000; Jin & Thielscher, 2005) agents goals (Shapiro,
Lesperance, & Levesque, 2005). scenario, would concern instance truth
token given state: agent believes token, actually wrong
that. might subsequently forced revise beliefs current
state affairs change goals according perform state.
belief revision operations modify agents beliefs action laws.
hand, interested exactly modifications. Starting Baral
Lobos work (1997), recent studies done issue (Eiter, Erdem, Fink,
& Senko, 2005) domain descriptions action languages (Gelfond & Lifschitz, 1993).
take step direction propose method robust
integrating notion minimal change complying postulates theory change.
190

fiOn Action Theory Change

present text structured follows: Section 2 establish formal background used throughout article. Sections 36 core work:
Section 3 present central definitions semantics action theory change, providing justifications design choices made (Section 4). Section 5 devoted
syntactical counterpart operators Section 6 proof correspondence semantics certain acceptable conditions. Section 7 discuss
postulates contraction/erasure present semantics action theory revision
(Section 8). discussion comparison existing work field (Section 9),
conclude overview future directions research.

2. Logical Preliminaries
Following tradition Reasoning Actions Change (RAC) community,
consider action theories finite collections statements particular
form (Shanahan, 1997):
context, effect every execution action (effect laws);
precondition, action executable (executability laws).
Statements mentioning action represent laws underlying structure
world, i.e., possible states (static laws).
Several logical frameworks proposed formalize statements (Shanahan,
1997). Among prominent ones first-order based Situation Calculus (McCarthy & Hayes, 1969; Reiter, 2001), family Action Languages (Gelfond & Lifschitz,
1993; Giunchiglia, Kartha, & Lifschitz, 1997), Fluent Calculus (Thielscher, 1997),
Propositional Dynamic Logic (PDL) (Harel, Tiuryn, & Kozen, 2000) different specific extensions thereof (De Giacomo & Lenzerini, 1995; Castilho, Gasquet, & Herzig, 1999;
Zhang & Foo, 2001; Castilho, Herzig, & Varzinczak, 2002).
opt formalize action theories using multimodal logic Kn (Popkorn, 1994).
Among main reasons choice are:
benefit well defined semantics multimodal logics which,
going see sequel, provides simple intuitive foundations build
meaning changing action domain descriptions.
Kn syntax allows us express afore mentioned types laws without requiring
full expressiveness PDL machinery first-order language.
Since Kn core mentioned PDL-based action formalisms, shall
say sequel smoothly transfer them.
Contrary first-order based approaches, Kn decidable several implemented
theorem provers available literature.
191

fiVarzinczak

2.1 Action Theories Multimodal Logic
Let Act = {a1 , a2 , . . . , } set atomic action constants given dynamic
domain. example atomic action buy. atomic action associated
modal operator [a]. suppose multimodal logic independently axiomatized (Kracht & Wolter, 1991), i.e., logic fusion interaction
different modal operators.1
Prop = {p1 , p2 , . . . , pn } denotes finite set propositional constants, called fluents
elementary atoms. Examples token (the agent token) coffee
(the agent holds coffee). Lit = {p, p : p Prop} set literals. use `
denote literal. ` = p, identify ` p. |`| denote atom `.
use small Greek letters , , . . . denote Boolean (propositional) formulas.
recursively defined usual way:
::= p | > | | | | | |
( denotes ( ) ( ).) Fml set Boolean formulas. example
Boolean formula coffee hot. propositional valuation v maximal consistent set
literals. denote v fact v satisfies propositional formula . val()
denote set valuations satisfying . CPL denote Classical Propositional
Logic |=CPL respective consequence relation. Cn() denotes logical consequences
CPL, i.e., Cn() = { : |=
}.
CPL
propositional formula, atm() denotes set elementary atoms actually
occurring . example, atm(p1 (p1 p2 )) = {p1 , p2 }.
Boolean formula, IP() denotes set prime implicants (Quine, 1952),
i.e., weakest terms (conjunctions literals) imply . example, IP(p1 p2 ) =
{p1 p2 , p1 p2 }. prime implicants, properties compute
them, see chapter Marquis (2000). denote prime implicant, given `
, ` abbreviates ` literal . given set X, X denotes complement.
Hence atm() denotes Prop \ atm().
denote complex formulas (possibly modal operators) , , . . .
recursively defined following way:
::= | [a] | | | | |
hai dual operator [a], defined hai =def [a]. instance complex
formula scenario example coffee [buy]coffee.
Given complex formula , act() denote action names occurring ,
i.e., modalities . example, act([a2 ]p1 ([a1 ]p2 [a2 ]p3 )) = {a1 , a2 }.
semantics standard semantics multimodal logic Kn (Popkorn, 1994).
Definition 2.1 (Kn -Model) Kn -model tuple = hW, Ri W set valuations (also called possible worlds), R maps action constants accessibility relations
Ra W W.
1. Later see requirement ensure action theory modular.

192

fiOn Action Theory Change

example, Act = {a1 , a2 } Prop = {p1 , p2 }, Kn -model =
hW, Ri,
W = {{p1 , p2 }, {p1 , p2 }, {p1 , p2 }},


({p1 , p2 }, {p1 , p2 }), ({p1 , p2 }, {p1 , p2 }),
R(a1 ) =
({p1 , p2 }, {p1 , p2 }), ({p1 , p2 }, {p1 , p2 })
R(a2 ) = {({p1 , p2 }, {p1 , p2 }), ({p1 , p2 }, {p1 , p2 })}
Figure 2 gives graphical representation model .
a1
w1
p1 , p2

w2

a1

p1 , p2

a2

:

a1

a1

w3
p1 , p2
a2

Figure 2: Example Kn -model Act = {a1 , a2 }, Prop = {p1 , p2 }.
Notice definition Kn -model follow traditional notion modal
logics: two worlds satisfy valuation. pragmatic choice,
see Section 5. Nevertheless, shall say sequel straightforwardly
formulated standard Kn models well.
Definition 2.2 (Truth Conditions) Given Kn -model = hW, Ri,


|=
p (p true world w ) iff w p (valuation w satisfies p, i.e., p w);
w




|=
[a] iff |= 0 every w0 (w, w0 ) Ra ;
w
w







|=
iff |=
|=
;
w
w
w






|=
iff 6|=w , i.e., |=w ;
w
truth conditions connectives usual.
denote (possibly empty) set Kn -models.




Kn -model model (denoted |= ) w W, |=
.
w




model depicted Figure 2, |= p1 [a2 ]p2 |= p1 p2 . model set


formulas (noted |= ) |= every . set formulas
start (our non-logical theory), called global axiom.
193

fiVarzinczak

Definition 2.3 (Global Consequence) formula global consequence set
global axioms class Kn -models (noted |=
) every
K


n



Kn -model , |= , |= .
Kn state laws describing behavior actions. One way
stating formulas global axioms.2 usually done RAC community (Shanahan, 1997), distinguish three types laws. first kind statements static
laws, constraints allowed states dynamic domain.
Definition 2.4 (Static Law) static law global axiom Fml.
example static law coffee hot, saying agent holds coffee,
holds hot drink. Situation Calculus formalism (Reiter, 2001) one would write
first-order formula s.[coffee(s) hot(s)]. set static laws scenario denoted
Fml. example = {coffee hot}.
second kind action law consider given effect laws. formulas
relating action effects, conditional.
Definition 2.5 (Effect Law) Let , Fml. effect law action global axiom
form [a].
consequent effect always obtains accessible states (which need
exist general) action executed state antecedent holds.
Kripke semantics, means every possible world holds, every transition
a-labeled arrow (if any) leads possible world holds. nondeterministic action, consequent typically disjunction. example effect
law coffee [buy]coffee, saying situation agent coffee,
buying, agent coffee. inconsistent, special kind effect
law call inexecutability law. example, could token [buy],
expressing buy cannot executed agent token. Situation Calculus examples effect inexecutability laws would expressed respectively
s.[coffee(s) coffee(do(buy, s))] s.[token(s) Poss(buy, s)].
set effect laws given scenario denoted E . coffee machine scenario,
could example:


coffee [buy]coffee,
token [buy]token,
E =


token [buy]
Finally, define executability laws, stipulate context action
guaranteed executable. Kn , operator hai used express executability. hai>
thus reads execution possible. Formally, hai> true world w means
least one world w0 accessible w via Ra (cf. Definition 2.2).
2. alternative given Castilho et al. (1999, 2002), laws stated aid
extra universal modality local consequence thus considered.

194

fiOn Action Theory Change

Definition 2.6 (Executability Law) Let Fml. executability law action
global axiom form hai>.
instance, token hbuyi> says buying executed whenever agent
token. set executability laws given domain denoted X . scenario
example X = {token hbuyi>}.
Note principle one needs know nothing accessible world w0 . However,
common (albeit tacit) assumption RAC community state executability
laws actions know effects, words act(X ) act(E ).
Situation Calculus example would stated s.[token(s) Poss(buy, s)].
However, point that, traditionally, Reiter basic action theories (Reiter, 2001)
executability laws inexecutability laws mixed together form bi-conditionals
s.[token(s) Poss(buy, s)], called precondition axioms. critique
practice implications formalizing dynamic domains, see work Herzig
Varzinczak (2007).
three basic types laws, able define action theories:
Definition 2.7 (Action Theory) Given (possibly empty) sets laws , E , X ,
= E X action theory.
Given action theory action a, Ea (resp. Xa ) denote set
effect (resp. executability) laws E (resp. X ). Ta = Ea Xa action
theory a.
worth noting a1 , a2 Act, a1 6= a2 , intuition indeed Ta1 Ta2
overlap , i.e., laws common Ta1 Ta2 laws
structure world. requirement somehow related underlying
modal logic independently axiomatized (see note above).
2.2 Frame, Ramification Qualification Problems
last 40 years, effort reasoning actions community
devoted searching satisfactory solutions frame problem, ramification
problem qualification problem.
Roughly speaking, frame problem (McCarthy & Hayes, 1969) relates need
inferring persistence facts world execution action known
affect them, without state explicitly form frame axioms.
(Frame axioms special type effect law, form ` [a]`, ` Lit.)
example, buying coffee context agent already got one
make lose coffee: coffee [buy]coffee consequence theory.
ramification problem (Finger, 1987) comes observation action may
several possibly interdependent effects stating explicitly huge
task. scenario, want able infer [buy]hot without saying theory,
way intrinsic causal connection coffee hot taken
account. Finally, qualification problem (McCarthy, 1977) amounts addressing
issue ensuring action executable given context. Specifying sufficient
195

fiVarzinczak

conditions action executable incredibly hard task. example, one
may state token hbuyi>, may well case buying fails due
condition unforeseen design time, agents arm rusty stuck.
core problems RAC community, reader referred
book Shanahan (1997).
sake clarity, abstract frame ramification problems,
suppose agents theory already entails relevant frame axioms. point
however shall say could defined within formalism solution
frame ramification problems. instance, could used suitable solution
frame problem, e.g. dependence relation (Castilho et al., 1999), used
work Herzig et al. (2006), kind successor state axioms slightly modified
setting (Demolombe, Herzig, & Varzinczak, 2003). make presentation clear
reader, bother particular solution frame problem
assume frame axioms inferred action theory. Actually
suppose intended frame axioms automatically recovered stated
theory, specifically, set effect laws.
Given largely acknowledged difficulty qualification problem literature (Shanahan, 1997), assume priori solution it. Instead, tacitly
assumed many approaches reasoning actions (Castilho et al., 1999; Zhang &
Foo, 2001; Reiter, 2001), suppose knowledge engineer may want state
(not necessarily fully specified) executability laws actions. may incorrect
starting point (and probability be), revising wrong executability
laws approach towards solution one aims work.
information knowledge engineer chance change eventually
correspond intuition (cf. Sections 3 8).
agreed points, action theory example be:


coffee

hot,
token

hbuyi>,






coffee [buy]coffee,
T=
token [buy]token, token [buy],





coffee [buy]coffee, hot [buy]hot
(We stated frame axiom token [buy]token trivially
deduced inexecutability law token [buy].)
Figure 3 shows Kn -model action theory above.
going see sequel finite base formalizing action theory
plays role contraction laws. particular, base representing static laws
turns quite important. given action theory T, useful consider
models whose possible worlds possible valuations allowed :
Definition 2.8 (Canonical Frame) Let = E X action theory.
tuple Mcan = hWcan , Rcan canonical frame if:
Wcan = val(S );



Rcan = aAct Ra s.t. Ra = {(w, w0 ) : [a] Ea , |=w , |= 0 }.
w

196

fiOn Action Theory Change

w1
t, c, h
b

b
w3

w2

:

t, c, h

t, c, h

b

w4
t, c, h

Figure 3: model coffee machine scenario: b, t, c, h stand for, respectively,
buy, token, coffee, hot.

canonical frame action theory need one models. witness why,
let Prop = {p}, Act = {a}, consider simple action theory {p [a], p hai>}.
associated canonical frame Wcan = {{p}, {p}}. Clearly world {p}
satisfy theory.
Definition 2.9 (Canonical Model) canonical model

canonical frame |= T.
Figure 4 shows canonical model action theory example T.
w1
t, c, h
b

:

b
w3

w2
t, c, h

w5

b

t, c, h

w6

w4
t, c, h

t, c, h

t, c, h

Figure 4: canonical model coffee machine scenario.

2.3 Prime Valuations
say atom p essential formula p atm(0 ) every 0
|=
0 . instance, p1 essential p1 (p1 p2 ). Given , atm!()
CPL
denotes set essential atoms . (If contingent, i.e., tautology
contradiction, atm!() = .)
Given Boolean formula, set formulas 0 |=
0
CPL
0
atm( ) atm!(). ForV instance, p1 V
p2
/ p1 , p1 |=
p p2 atm(p1 p2 ) 6
CPL 1
atm!(p1 ). Clearly, atm( ) = atm!( ), moreover whenever |=CPL 0 case,
atm!() = atm!(0 ) = 0 .
197

fiVarzinczak

Theorem 2.1 (LeastVAtom-Set Theorem, Parikh, 1999) Let propositional formula. |=CPL , every 0 |=CPL 0 , atm() atm(0 ).
proof theorem given Makinson (2007) state here.
Essentially, theorem establishes every Boolean formula , unique
least set elementary atoms may equivalently expressed using atoms
set. Hence, Cn() = Cn().
Given valuation v, v0 v subvaluation. Given set valuations W, subvaluation
v0 satisfies propositional formula modulo W (noted v0 W ) v
v W v0 v. say subvaluation v essentially satisfies (modulo W),
!
!
noted v W , v W {|`| : ` v} atm!(). v W , call v
essential subvaluation (modulo W).
Definition 2.10 (Prime Subvaluation) Let Boolean formula W set val!
uations. subvaluation v prime subvaluation (modulo W) v

W
!

v0 v v0 W .
prime subvaluation formula thus one weakest states truth
true. Hence, prime subvaluations another way seeing prime implicants (Quine,
1952) . base(, W) denote set prime subvaluations modulo W.
Proposition 2.1 W
Let FmlVand W set valuations. w W, w
w vbase(,W) `v `.
Proof: Right left direction straightforward. left right direction, w ,
0
w . Let w0 w least subset w still
Vsatisfying . Clearly, w prime
subvaluation modulo W, w `w0 `, result follows.
2
2.4 Closeness Models
contracting formula model, perform change structure.
several different ways modifying model (not minimal), need
notion distance models identify closest original one.
going see depth next section, changing model amounts
modifying possible worlds accessibility relation. Hence, distance
two Kn -models depend upon distance sets worlds accessibility
relations. based symmetric difference sets, defined
X = (X \ ) (Y \ X).
Definition 2.11 (Closeness Kn -Models) Let = hW, Ri model.
0 = hW0 , R0 least close 00 = hW00 , R00 i, noted 0 00 ,
either WW0 WW00 ;
WW0 = WW00 RR0 RR00 .
198

fiOn Action Theory Change

extension Burger Heidemas relation (Burger & Heidema, 2002)
modal case. defines lexicographic order set Kn -models. Although simple,
notion closeness turns sufficient purposes here, shall see
sequel. Notice notions distance models could considered
well, namely cardinality symmetric differences Hamming distance. (See Section 4
discussion this.)

3. Semantics Action Theory Change
admitting possibility law failing, one must ensure becomes invalid,
i.e., true least one model dynamic domain formalized.
lots models, may set models (potentially) valid.
Thus contracting amounts making longer valid set models.
operations must carried achieve that? Throwing models
work, since keep valid models remaining set. Thus one
add new models M. models? Well, models true.
models: taking models falsifying different original
models certainly violate principle minimal change.
Hence, shall take model basis manipulate get new model
0
true. modal semantics, removal law model
= hW, Ri means modifying possible worlds accessibility relation
becomes false. operation gives result set models
longer model . several candidates, ones choose?
shall take models minimal modifications original , i.e.,
minimal respect distance models. course,
one 0 minimal respect . case, adding
one new models enough invalidate , take possible combinations
{M 0 } expanding original set models one minimal models.
(Observe approach relates orderly maxichoice contraction Hansson, 1999.)
result set sets models. set models precisely one model
0 falsifying .
might claimed that, such, contraction method described
respect so-called principle categorical matching: input output different
sorts objects, namely set models set sets models. easy see,
however, reasoning stated way output set
models corresponds precisely result one contraction operator, satisfying
referred principle. choice defining result operation set possible
outputs become clear Section 5, going present algorithms
correspond exactly semantic constructions.
3.1 Model Contraction Executability Laws
contract executability law hai> one model, intuitively remove
transitions leaving -worlds. order succeed operation, guarantee
resulting model least one -world departing a-arrow.

199

fiVarzinczak


Definition 3.1 Let = hW, Ri. 0 = hW0 , R0 Mhai>


W0 = W;
R0 R;


;
(w, w0 ) R \ R0 , |=
w
M0

w W0 6|=w hai>.


Observe Mhai>
6= satisfiable W. Moreover, Mhai>


6|= hai>.
provide reader insight operation would carried
Situation Calculus, one look given situation holds
modify interpretation predicate Poss(a) becomes false s.
case, may many situations must taken
account. essential difference Kripke structures always finite,
whereas space situations possibly infinite (Reiter, 2001).
get minimal change, want operation removing transitions minimal
respect original model: one remove minimum set transitions
sufficient get desired result.
Definition 3.2 contract(M , hai>) =




min{Mhai>
, }

define sets possible models resulting contraction
executability law set models:
Definition 3.3 Let set models, hai> executability law.
0
0
0
0

hai> = {M : = {M }, contract(M , hai>), M}

running example, consider = {M }, model Figure 4.
agent discovers even token manage buy coffee more,
change models order admit (new) models states token
case buy-transition all. one
world new model enough, taking resulting models whose accessibility
relations maximal guarantees minimal change. Hence
tokenhbuyi> =
0
0
0
0
{M {M1 }, {M2 }, {M3 }}, Mi depicted Figure 5.


Clearly, satisfied M, i.e., |= M, contraction
hai> succeed. line expectations relates
Success Postulate (cf. Section 7.2).
200

fiOn Action Theory Change

w1

w1
t, c, h

t, c, h
b

M10 :

b
w3

w2
t, c, h

w5

w6

w4
t, c, h

t, c, h

b

t, c, h

w6

w4

w5

t, c, h

t, c, h

w3

w2

M20 :

t, c, h

b

t, c, h

t, c, h

t, c, h

w1
t, c, h
b

M30 :

b
w3

w2
t, c, h

t, c, h

w5

w6

w4
t, c, h

t, c, h

t, c, h

Figure 5: Models resulting contracting token hbuyi> model Figure 4.
3.2 Model Contraction Effect Laws
agent discovers may cases buying gets
hot drink, must e.g. give belief effect law token [buy]hot set
models. means token hbuyihot shall admitted least one world
new models set beliefs. Therefore, contract effect law [a]
given model, intuitively add new transitions -worlds worlds
satisfying . shall see, great challenge operation precisely
guarantee minimal change.
example, contracting token [buy]hot model Figure 4 shall
add transitions token-worlds hot-worlds. coffee hot static law
hot coffee, give us hbuyicoffee token-world (coffee
causally relevant hot, i.e., hot must coffee). means
allow hbuyihot token-world, allow hbuyicoffee
world. argument necessarily hold token: allowing hbuyihot
necessarily oblige us allow hbuyitoken respective world.
token relevant hot (as coffee is). means freedom either
allow not.
Hence, running example add transitions token-worlds hot
coffee token-worlds, well hot coffee token. situation depicted
Figure 6. instance, add new buy-arrow world {token, coffee, hot}
one candidates (Figure 7).
Situation Calculus, modification would slightly different,
intuition behind: one look given situation holds
modify interpretation fluents (atoms) do(a, s), situation resulting
performing s. Alternatively, new -situations lead least one -situation.
201

fiVarzinczak

w1
t, c, h
b

:

b
w3

w2
t, c, h

w5

t, c, h

b

w6

w4
t, c, h

t, c, h

t, c, h

Figure 6: Candidate worlds receive transitions coming token-worlds.
w1
t, c, h
b

:

b
w3

w2
t, c, h

w5

b

t, c, h

w6

w4
t, c, h

b

t, c, h

t, c, h

b

Figure 7: Two candidate new buy-arrows falsify token [buy]hot .
Notice however would require addition new whole branches tree-like
first-order model induced Reiter basic action theories (Reiter, 2001).
Back example, observe adding new transition {token, coffee, hot}
would make us lose effect token, true every execution buy original

model (|= token [buy]token). preserve law allowing new
transition hot-world? is, get rid effect hot without losing effects
relevant that? develop approach issue.
adding new transition leaving world w intuitively want preserve many
effects so. achieve this, enough preserve old effects
w (because remaining structure model remains unchanged adding
new transition). course, cannot preserve effects inconsistent (those
lost). Hence suffices preserve effects consistent .
achieve must observe true w target world w0 :
proper effects action world w0 , i.e., changes w w0 (w0 \ w)
new execution must obliged so: either
literals change w w0 necessary w0 (like coffee
example) necessary another effect (independent
, token) world w0 .
202

fiOn Action Theory Change

non-effects action world w0 , i.e., change w w0
(w w0 ) new execution allowed so: certain
literals never preserved (like token example), pointing new
transition towards world change respect leaving world
(hot coffee token example), may lose effects held w
adding transition.
means things allowed change candidate target world must
forced change, either non-related law
modulo set states W. words, want literals (now) change
w w0 sufficient get modulo W, preserving
maximum effects. Every change beyond intended one. Similarly,
want literals w (now) preserved target world w0
usually preserved given set models. Every preservation beyond
may make us lose law. looks prime implicants, prime
subvaluations play role: worlds new transition point
whose difference respect departing world literals relevant whose
similarity respect literals know change.
Definition 3.4 (Relevant Target Worlds) Let = hW, Ri model, w, w0 W,
set models M, [a] effect law. w0 relevant target
world w respect [a]




|=
6|= 0 ;
w
w

` w0 \ w:
either v base(, W) v w0 ` v;
0 Fml v0 base( 0 , W) v0 w0 , ` v0 ,

every Mi M, |=w [a] 0
` w w0 :
either v base(, W) v w0 ` v;



Mi 6|=
[a]`;
w

RelTarget(w, [a], , M) denote set relevant target worlds w
respect [a] M.
Note need set models (and suppose contains models
theory want change) preserving effects depends effects
hold models interest us. need take account
local operation changing one model. (The reason need definition

local, one model contraction executability laws Mhai>
removing
transitions way losing effects, every effect law held world
transition removed remains true world resulting model.)
203

fiVarzinczak

Definition 3.5 Let = hW, Ri, M. 0 = hW0 , R0

M[a]

W0 = W;
R R0 ;
(w, w0 ) R0 \ R, w0 RelTarget(w, [a], , M);
M0

w W0 6|=w [a].

Observe M[a]
6= satisfiable W. Moreover,



M[a]
6|= [a].

one world law longer true model enough,
taking resulting models whose accessibility relations minimal respect
original one guarantees minimal change.
Definition 3.6 contract(M , [a]) =




min{M[a]
, }

define possible sets models resulting contracting effect law
set models:
Definition 3.7 Let set models, [a] effect law.
0
0
0
0

[a] = {M : = {M }, contract(M , [a]), M}

Taking = {M }, model Figure 4, contracting token
0
0
0
[buy]hot get
token[buy]hot = {M {M1 }, {M2 }, {M3 }},
Mi0 depicted Figure 8.
cases satisfiable valid , course operator
succeed falsifying [a] (cf. end Section 3.1). Again, works
expected Success Postulate (see Section 7.2).
3.3 Model Contraction Static Laws
contracting static law model, want admit existence least
one (new) possible state falsifying it. means intuitively add new worlds
original model. (In Situation Calculus setting would correspond allowing
situations satisfying domain constraints.) quite easy.
delicate issue however accessibility relation: new transitions
leave/arrive new world? transition leaves new added world, may lose
executability law. transition leaves it, may lose effect law,
holding add transition pointing new world. hand,
transition arrives new world, intuition? intuitive
unreachable state? (Similar issues would arise Situation Calculus interpretations,
means independent underlying formalism.)
204

fiOn Action Theory Change

w1

w1
t, c, h

b

M10 :

t, c, h
b

b
w3

w2
t, c, h

w3

w2

M20 :

t, c, h

b

b

t, c, h

b

t, c, h

b
w5

w6

w4
t, c, h

w5

t, c, h

t, c, h

b

t, c, h

w6

w4
t, c, h

t, c, h

w1
t, c, h
b

M30 :

b
w3

w2
t, c, h

b

t, c, h

b
w5

w6

w4
t, c, h

t, c, h

t, c, h

Figure 8: Models resulting contracting token [buy]hot model Figure 4.

discussion shows drastic change static laws might be: change
underlying structure (possible states) world! Changing may
indirect, unexpected (and probability unwanted) consequence loss effect
law(s) executability law(s). choose type(s) laws
may accept lose process postpone change (by operators).
Following tradition RAC community, states executability laws
general difficult formalize effect laws, therefore likely
incorrect (Shanahan, 1997), prefer change accessibility relation,
means preserve effect laws postpone correction executability laws,
required. (Remember approach towards solution qualification
problem cf. Section 2.2 above.)
One may argue things way makes three operators incoherent
sense effect executability laws adopt minimal change approach, giving
stronger theories, whereas static laws adopt cautious approach, giving weaker
theories (see next section). worth noting however largely recognized
RAC community, different laws domain description status:
minimal change approach static law contraction preserves many executability
laws possible, even coherent, would definitely fail cope qualification problem.
Moreover, propagating wrong executability laws, coherent method would definitely
less elaboration tolerant (McCarthy, 1998) one defining regards
modifications theory.
reasons, contention static law contraction cautious.
(For detailed discussion this, see Section 4.2 end Section 5.3.)

205

fiVarzinczak

Definition 3.8 Let = hW, Ri. 0 = hW0 , R0
W W0 ;
R = R0 ;
M0

w W0 6|=w .


Note = |= . Moreover, 6|= .
minimal modifications one model defined usual:

Definition 3.9 contract(M , ) = min{M , }
define sets models resulting contracting static law
given set models:
Definition 3.10 Let set models, static law.
0
0
0
0

= {M : = {M }, contract(M , ), M}

scenario example, initial set models = {M }, model
Figure 4, contracting static law coffee hot would give us resulting
0
0
0
new set models
coffeehot = {M {M1 }, {M2 }}, Mi depicted
Figure 9 below.
w1

w7
t, c, h

b

M10 :

w5

t, c, h
b

w3
b

M20 :

t, c, h

w6

w4
t, c, h

t, c, h

b

w2
t, c, h

w1

w7

t, c, h

t, c, h

t, c, h

b
w3

w2
t, c, h

b

t, c, h

w6

w4

w5
t, c, h

t, c, h

t, c, h

Figure 9: Models resulting contracting coffee hot model Figure 4.
Notice modifying accessibility relation effect laws true
original model preserved resulting models. ensured [buy]
true new world w7 .
executability laws potentially lost, due cautiousness
approach. instance, M10 above, longer case token hbuyi>
true, since world, namely w7 , satisfy anymore. (In M20
executability law still true every possible world.)
worth point out, however, approach indeed line intuition:
learning new state possible, necessarily know behavior
actions new added state. may expect action laws hold new world
(see end Section 5.3), but, information dispose, touching accessibility
relation safest way contracting static laws (cf. Section 4.2 below).
206

fiOn Action Theory Change

4. Interlude
presenting algorithmic counterpart action theory change operators,
section discuss alternatives technical constructions. point
issues alternatives would raise. provide justifications
design choices made previous sections.
4.1 Distance Notions
defined used model distance based symmetric difference sets (Definition 2.11). distance extension Kripke structures
Winsletts (1988) notion closeness propositional interpretations Possible
Models Approach (PMA). Instead it, however, could considered distance
notions well, Dalals (1988) distance, Hamming distance (1950), weighted distance. Due space limitations, develop comparison among
distances here. (For details, reader may want refer Schlechtas 2004 book.)
nevertheless show cardinality-based distance, example, may
always get intended result.
Let card(X) denote number elements set X. suppose closeness
Kn -models defined follows:
Definition 4.1 (Cardinality-based Closeness Kn -Models) Let = hW, Ri
model. 0 = hW0 , R0 least close 00 = hW00 , R00 i, noted
0 00 ,
either card(WW0 ) card(WW00 );
card(WW0 ) = card(WW00 ) card(RR0 ) card(RR00 ).
notion distance closely related Dalals (1988) closeness.
contracting static law model usually add one new
possible world, easy see cardinality-based distance get
result contract(M , ) distance Definition 2.11.
comes contraction action laws, changing accessibility
relations, however, cardinality-based distance seem fit intuitions.
witness, consider model Figure 10, law p1 hai> true.


w1

w2
p1 , p2

p1 , p2


:


w3
p1 , p2

Figure 10: model executability law p1 hai>.
207

fiVarzinczak

Then, models resulting contraction p1 hai> model
Mphai> = {M 0 , 00 }, 0 00 depicted Figure 11.
1

w2

w1



w1

p1 , p2

p1 , p2

w2
p1 , p2

p1 , p2



M0 :



00 :

w3

w3

p1 , p2

p1 , p2

Figure 11: Models resulting contracting p1 hai> model Figure 10.
00

Note 00 intended contracted model: 6|= p1 hai>. However,
0
cardinality-based distance get {M }
p1 hai> = {{M , }}.
00
0
00
0
{M , } result since : one transition removed,
00 two.
4.2 Minimal Change v. Cautiousness
usually done literature classical belief revision, defining (traditional)
theory change operator one must always make fundamental decision two opposing principles guiding one: minimizing change, leads
strong modified theories, versus cautious change, leads weak theories.
regard, one might argue action theory change operators incoherent.
adopt first principle contraction effect executability laws,
latter principle contraction static laws.3
turns out, however, view debatable. different perspective one
think three operators coherent following sense: perform
version maxichoice, namely addition precisely single model original models
theory.4
case, sequel give justification behavior operators
show operator contraction static laws cautious
coherent operators contraction effect executability laws. (We
say operator static law contraction coherent respect operators
contraction effect executability laws performs minimal change respect
types laws, i.e., preserves effect executability laws.)
claimed incoherence come from? contention
inherent problem action theory change itself, flaw definitions.
justification follows. Remembering intuitions semantic constructions,
easy see contraction executability laws knowledge actions
feasibility (the transitions) removed that. contraction effect laws,
3. thank anonymous referee pointed out.
4. thank another anonymous referee pointed out.

208

fiOn Action Theory Change

piece knowledge added (the new transition), notice one guided
given concrete extra information, namely effect want allow.
Now, contraction static laws, notice extra information whatsoever
given new possible state could guide addition knowledge
feasibility action. thing know new world exist.
Nothing said whether transition leaving arriving
all. property problem per se: problem removing static law
mention executabilities, reflected operator.
Therefore, incoherence already problem, surprising
find proposed operators. designed allowed
given constraints problem. information hands
regarding new added state, coherent version corresponding operator would
defined. (See discussion Section 9 comparison Eiter et al.s 2005
constraint-based method update action theories.)
Proposition 4.1 minimal change operator static law contraction
coherent operators contraction effect executability laws.
Proof: Suppose minimal change based (non-cautious) contraction operator
static laws coherent operators. operator must
contracting Fml formulas type removed (otherwise
coherent operators). means effect executability laws
preserved. particular, operator coherent respect contracting
formula p1 p2 model Figure 12 below.
w1

w1
p1 , p2

:



p1 , p2

w3

M0 :

w2



w2
p1 , p2

p1 , p2



p1 , p2

Figure 12: Adding transition new added world alternative semantics
static law contraction. denotes original model, 0 shows new
added world candidate transition add Ra .
Following intuition contraction Boolean formulas, new world, viz.
valuation {p1 , p2 }, added W . operator question non-cautious,
transition added new added world {p1 , p2 } , order
preserve executability law p1 hai>. operator non-cautious,
effect law p1 [a]p1 preserved. Hence, new transition point
neither world {p1 , p2 } {p1 , p2 } itself. Now, direct new transition
{p1 , p2 } (the world left), get model 0 Figure 12.
209

fiVarzinczak



M0

Observe |= (p1 p2 ) [a]p1 . However, 6|= (p1 p2 ) [a]p1 : operator
makes us lose effect law! means coherent. order us keep
effect law, option direct new transition {p1 , p2 }. then,
transition added all: operator cautious! Hence operator
static law contraction based minimal change coherent operators
laws.
2
result supports contention cannot coherent set minimal
change operators action theory contraction. general result holds
modal-based approaches ours, applies framework reasoning
actions based transition systems allows three types
laws consider here.
Furthermore, result illustrates well difference action theory change
classical belief change. witness, even though contraction static laws amounts
propositional contraction Boolean formulas, remains special case latter.
reason contracting static laws one always asks happens laws
types?, question asked classical propositional contraction
obvious reason simply types formulas.

5. Syntactic Operators Contraction Laws
given semantic construction action theory change, turn
attention definition syntactic operators changing sets formulas describing
dynamic domain.
Nebel (1989) says, [. . . ] finite bases usually represent [. . . ] laws,
forced change theory would stay close possible original
[. . . ] base. Hence, besides definition syntactical operators, guarantee
perform minimal change theory level. mean resulting
theory course entail law want contract theory with,
preserve much previous knowledge possible performing syntactical
manipulations laws original theory. Ideally, knowledge engineers
perspective, modified theory keep certain degree resemblance
original one: resulting laws slight modifications relevant ones
original action theory.

denote sequel result contracting law set laws T.
5.1 Contracting Executability Laws
case contracting executability law hai> action theory, first
ensure action keeps executability state contexts
antecedent holds, case. achieve strengthening antecedents
relevant executability laws. Second, order get minimality, must make
executable contexts true, viz. -worlds one. Since
possibly many different alternatives that, means several action
theories outcome. Algorithm 1 gives syntactical operator achieve this.
210

fiOn Action Theory Change

easily checked Algorithm 1 always terminates: input action theory
always finite; finiteness Prop follows atm(), IP(S ).
Moreover, entailment problem multimodal K decidable (Harel et al., 2000),
classical propositional logic. Therefore contracting executability laws decidable.
Algorithm 1: Contraction Executability Law
Input: T, hai>
Output:
hai> /* set theories output knowledge engineer */
1

begin

2

:=

hai>

3

|=
hai> 6|=

K
CPL
n

foreach IP(S )

4

forall atm()
V
V
:= pi atm() pi pi atm() pi /* extend valuation */

5
6

pi

6|=
( )
CPL

7

9

else
:= {T}

hai>

11
12
13

/* allowed state */

/* construct theory weaker state */
0 := (T \ Xa ) {(i ( )) hai> : hai> Xa }
0
:=

hai>
hai> {T }

8

10

pi
/

return
hai>
end

straightforward see Algorithm 1 adapted Situation Calculus
action theories well. crucial point however would termination, since entailment
Situation Calculus general undecidable.
running example, contracting executability law token hbuyi>
0
0
0
action theory would give us
tokenhbuyi> = {T1 , T2 , T3 }, where:


coffee hot, coffee [buy]coffee,





token [buy]token, token [buy],
0
T1 =
coffee [buy]coffee, hot [buy]hot,





(token (coffee hot)) hbuyi>


coffee

hot,
coffee

[buy]coffee,






token [buy]token, token [buy],
0
T2 =
coffee [buy]coffee, hot [buy]hot,





(token (coffee hot)) hbuyi>
211

fiVarzinczak






coffee hot, coffee [buy]coffee,
token
[buy]token, token [buy],
T30 =
coffee
[buy]coffee, hot [buy]hot,



(token (coffee hot)) hbuyi>









knowledge engineer choose theory line
intuitions implement required changes (cf. Figure 5).
5.2 Contracting Effect Laws
contracting effect law [a] action theory T, intuitively contract effect laws preclude target worlds. order cope minimality,
must change laws relevant unwanted [a].
Let (Ea, )1 , . . . , (Ea, )n denote minimal subsets (with respect set inclusion) Ea
, (Ea, )i |=
[a], 1 n. words, (Ea, )i support set
Kn
effect law [a] T. make parallel terminology usually adopted
belief change community, shall see (Ea, )i special type kernel (Hansson,
1994) formula [a].
According Herzig Varzinczak (2007), given action theory one always
ensure least one support set [a] exists. let
[
Ea =
(Ea, )i
1in

laws Ea serve guidelines get rid [a] -world allowed
theory T: effect laws weakened allow hai -contexts.
resembles classical kernel contraction (Hansson, 1994): finding minimal sets implying
formula changing them. crucial difference, however, instead completely
removing formula kernel, weaken laws.
modifying support sets, first thing must ensure action
still effect contexts hold, case.
means shall weaken laws Ea, specializing . Now, need preserve
old effects -worlds one. achieve specialize laws
possible valuation (maximal consistent conjunction literals) satisfying one.
Then, left -valuation, must ensure action either old effects
outcome. achieve weakening consequent laws Ea . Finally,
order get minimal change, must ensure literals -valuation
forced change -worlds preserved. stating effect law
form (k `) [a]( `), k -valuation. reason
needed clear: several -valuations, far want one
reachable k -world, force one whose difference
k -valuation minimal.
Situation Calculus terms, syntactical operations would correspond strengthening right-hand side relevant successor state axioms and/or weakening
212

fiOn Action Theory Change

left-hand side. Alternatively, done original effect axioms,
recompiling new successor state axioms afterwards.
output operations described set action theories
output knowledge engineer. Algorithm 2 gives operator.
Algorithm 2: Contraction Effect Law
Input: T, [a]
Output:
[a] /* set theories output knowledge engineer */
1

begin

2

:=

[a]

3

|=K [a] 6|=

CPL
n

foreach IP(S )

4

forall atm()
V
V
:= pi atm() pi pi atm() pi /* extend valuation */

5
6

pi

pi
/

6|=
( )
CPL

7

/* allowed state */

0

foreach IP(S )
0 := \ Ea /* support sets weakened */
0 := 0 {(i ( )) [a]i : [a]i Ea }

8
9
10

11

/* allow state */
0 := 0 {(i ) [a](i 0 ) : [a]i Ea }

12

forall L Lit
|=
( )
CPL

13

V

`L `)



n

0 := 0 {( `) [a]( `)}

16

0
:=

[a]
[a] {T }

17

else
:= {T}

[a]

19

21

6|=
( 0
CPL

6|=
( `) [a]` ` 0
K

15

20

`L `

foreach ` L

14

18

V

return
[a]
end

Again, finiteness action theory atm(),
IP(S ), decidability multimodal K (Harel et al., 2000) well
classical propositional logic, easily verified Algorithm 2 always terminates.
213

fiVarzinczak

Therefore, contracting effect laws decidable. course, complexity computing
support sets well prime implicants quite high (see Section 5.4 later
discussion matter).
example execution Algorithm 2, let us suppose want contract
effect law token [buy]hot action theory running example. First
compute support sets token [buy]hot (i.e., minimal subsets
Ebuy together entail token [buy]hot). following:
token,hot
(Ebuy
)1

token,hot
(Ebuy
)2



coffee [buy]coffee,
coffee [buy]coffee





hot [buy]hot,
coffee [buy]coffee



=

=

possible context antecedent token case,
token,hot
token,hot

)2 . Since = {coffee hot},
)1 (Ebuy
= (Ebuy
weaken effect laws Ebuy
contexts token coffee hot, token coffee hot token coffee hot.


token coffee hot: Algorithm 2 replaces laws Ebuy



(coffee (token coffee hot)) [buy]coffee,
(hot (token coffee hot)) [buy]hot,


(coffee (token coffee hot)) [buy]coffee
preserve effects possible contexts token coffee hot. Now,
order preserve effects token coffee hot-contexts allowing reachable
hot-worlds, algorithm adds laws:


(token coffee hot) [buy](coffee hot),
(token coffee hot) [buy](hot coffee)
Now, search possible combinations laws Ebuy apply token coffee hot
contexts find token [buy]token. token must true every execution
action buy, state law (token coffee hot) [buy](hot token), end
following theory:


coffee hot, token hbuyi>,








token

[buy]token,
token

[buy],







(coffee (token coffee hot)) [buy]coffee,

(hot (token coffee hot)) [buy]hot,
T10 =



(coffee (token coffee hot)) [buy]coffee,









(token

coffee

hot)

[buy](coffee

hot),




(token coffee hot) [buy](hot coffee)
hand, language atom p theory T,
added law (token coffee hot p) [buy](hot p) meet minimal
change preserving effects relevant (cf. Definition 3.4).
214

fiOn Action Theory Change

execution contexts token coffee hot token coffee hot analogous
0
0
0
algorithm ends
token[buy]hot = {T1 , T2 , T3 }, where:

T20 =

















coffee hot, token hbuyi>,
token [buy]token, token [buy],
(coffee (token coffee hot)) [buy]coffee,
(hot (token coffee hot)) [buy]hot,
(coffee (token coffee hot)) [buy]coffee,
(token coffee hot) [buy](coffee hot)


coffee hot, token hbuyi>,




token [buy]token, token [buy],




(coffee (token coffee hot)) [buy]coffee,
(hot (token coffee hot)) [buy]hot,
T30 =


(coffee
(token coffee hot)) [buy]coffee,





(token
coffee hot) [buy](hot coffee),


(token coffee hot) [buy](coffee hot)




































Looking Figure 8, see correspondence theories
respective models. knowledge engineer look action theories
pick one corresponding expectations.
5.3 Contracting Static Laws
Finally, order contract static law theory, use contraction/erasure
operator classical logic available literature. contracting static
laws means admitting new possible states (cf. semantics), modifying set
static laws may enough multimodal logic case. However, since general
necessarily know behavior actions new discovered state
world, careful approach change theory action laws remain
contexts contracted law case. (The reader invited see
Situation Calculus allowing new situation exist one may need change
precondition axioms well, means problem described independent
logical formalism chosen.)
scenario example, contracting static law coffee hot knowledge
engineer really sure whether action buy still executable not,
weaken set executability laws specializing context coffee hot,
make buy priori inexecutable (coffee hot)-contexts. worth noting
line assumption commonly made RAC community according
executability laws large much likely incorrect right
beginning (Shanahan, 1997). Therefore extrapolating previously unknown states
might (and probability will) result propagation errors and, even worse,
loss effect laws (remember discussion Sections 3.3 4.2). operator given
Algorithm 3 formalizes this.
215

fiVarzinczak

Algorithm 3: Contraction Static Law
Input: T,
Output:
/* set theories output knowledge engineer */
1

begin

2


:=

3

|=CPL
/* call classical contraction */
foreach

4

/* build theory preserving executability old states */
0 := ((T \ ) ) \ Xa

5

0 := 0 {(i ) hai> : hai> Xa } { [a]}

0

:= {T }

6
7
8

else

:= {T}

9
10
11

return

end

running coffee example, contracting static law coffee hot action
0
0
theory produces
coffeehot = {T1 , T2 },

T10 =













T20 =













(token coffee hot),
(token coffee hot) hbuyi>,
coffee [buy]coffee, token [buy]token,
token [buy], coffee [buy]coffee,
hot [buy]hot, (coffee hot) [buy]








(token coffee hot),
(token coffee hot) hbuyi>,
coffee [buy]coffee, token [buy]token,
token [buy], coffee [buy]coffee,
hot [buy]hot, (coffee hot) [buy]




















Observe effect laws affected change: far
pronounce executability action new added world,
effect laws remain true it.
knowledge engineer happy (coffee hot) [buy], contract
formula theory using Algorithm 2. Ideally, besides stating buy executable context coffee hot, want specify outcome context
well. example, could want (coffee hot) hbuyihot true result.
requires theory revision. See Section 8 semantics operation.
216

fiOn Action Theory Change

5.4 Complexity Issues
terminating, algorithms come considerable computational cost: Kn entailment tests global axioms beginning algorithms inside loops
known exptime-complete (Harel
V et al., 2000).
V computation possible
contexts allowed theory, namely pi atm() pi pi atm() pi , atm()
pi

pi
/

IP(S ), clearly exponential. Moreover, computation prime implicants
IP(.) might result exponential growth (Marquis, 2000).
Given theory change carried offline, perspective knowledge engineer important complexity size computed contracted theories: number formulas well length modified ones.
plays important role deciding among several output theories one corresponds
knowledge engineers expectations. matter, whereas length new added
formulas may increase exponentially, respect number laws results
positive: size computed contracted theories linear size original
action theory. (Remember card(X) denotes number elements set X.)
Proposition 5.1 Let action theory, hai> executability law, 0
0

hai> . card(T ) = card(T).
0
Proof: 6|=
hai>,
hai> = {T}, = T, result
Kn
0
follows. Suppose |=
hai> case. 0 = (T \ Xa ) Xa 0 ,
Kn
Xa 0 obtained Xa way (i 0 ) hai> Xa 0
hai> Xa , fixed 0 . follows card(Xa 0 ) = card(Xa ). Now,
card((T \ Xa ) Xa 0 ) = card(T \ Xa )+card(Xa 0 )card((T \ Xa ) Xa 0 ) = card(T)card(Xa )+
card(Xa 0 ) card() = card(T) card(Xa ) + card(Xa ) 0 = card(T).
2

Proposition 5.2 Let action theory, [a] effect law, 0
[a] .
card(T 0 ) card(T) + card(Ea ) + card(Lit).
0
Proof: 6|=
[a],
[a] = {T}, = T, get
Kn
card(T 0 ) = card(T). Since card(T) card(T) + card(Ea ) + card(Lit), result follows.
Suppose |=K [a] case. 0 = (T \ Ea ) Ea 0 Ea 00 Fa , where:
n

0

00

Ea Ea obtained Ea way (i 0 ) [a]i Ea 0
(i 0 ) [a](i 0 ) Ea 00 [a]i Ea , fixed 0 , 0 ;
Fa {(0 `) [a]( `) : ` Lit}, fixed 0 ;
T, Ea 0 , Ea 00 , Fa pairwise disjoint.
Hence card(Ea 0 ) = card(Ea 00 ) = card(Ea ), card(Fa ) card(Lit). card(T 0 ) =
card(T \ Ea ) + card(Ea 0 ) + card(Ea 00 ) + card(Fa ) = card(T \ Ea ) + card(Ea ) + card(Ea ) +
card(Fa ) = card(T) card(Ea ) + card(Ea ) + card(Ea ) + card(Fa ) = card(T) + card(Ea ) +
card(Fa ) card(T) + card(Ea ) + card(Lit).
2
217

fiVarzinczak

Given arbitrary choice contraction operator static laws, without loss
generality resort slightly modified version it, viz. one always gives us
result set static laws cardinality original . (This possible
since, contrary E X , conjunction static laws still static law,
rewriting.) agreeing that, following proposition straightforward:
0
Proposition 5.3 Let action theory, static law, 0
. card(T ) =
card(T) + 1.

Propositions 5.15.3 positive results: knowledge engineer deal
original action theory, able deal output algorithms.
(Observe given 0 conditional frame axioms added Fa contraction
effect law factored single law, resulting theory
cardinality card(T) + card(Ea ) + 1.)
finish section observing size
, set resulting contracted
theories, depends solely set static laws plus law contract with:
Proposition 5.4 Let action theory, let law |=
.
K
n

card(T
) = card(S ),
card(T
) = card(val(S {})), either hai> [a].
Proof: proof follows straightforwardly outermost loops Algorithms 13. 2

6. Correctness Operators
address correctness algorithms respect semantics contraction. Correctness understood completeness adequacy. Adequacy means
algorithms output theories whose models result semantic modifications
models original theory. Conversely, completeness says every model resulting
semantic modifications models original theory indeed model
theory output algorithm.
6.1 Challenges Completeness Adequacy
Let theory = {p1 hai>, (p1 p2 ) [a], [a]p2 } consider model
depicted Figure 13. (Notice |=
(p1 p2 ).) contracting p1 [a]p2 ,
Kn
0
get Figure 13.
0
contracting p1 [a]p2 using Algorithm 2 gives
p [a]p = {T },
1

2



p1 hai>, (p1 p2 ) [a],
(p1 p2 ) [a](p2 p2 ),
T0=


(p1 p2 ) [a](p2 p1 )
Notice formula (p1 p2 ) [a](p2 p1 ) put 0 Algorithm 2
{p1 } Lit 6|=
(p p2 ) 6|=K (p1 p2 ) [a]p1 .
CPL 1
n

218

fiOn Action Theory Change





w1



p1 , p2

w2

w1

p1 , p2

:

M0 :
w3

w2
p1 , p2



p1 , p2


w3

p1 , p2

p1 , p2

Figure 13: model result 0 contracting p1 [a]p2 it.
M0

0
clearly case 6|= 0 theory
p1 [a]p2 model. means
theories contraction operators complete.
issue arises Algorithm 2 tries allow transition p1 p2 -world
p2 -world closest it, viz. {p1 , p2 }, way knowing
V
0
world exist. remedy replacing test 6`
(
`L `)
Kn
V
0
6`CPL ( `L `) , would increase even complexity algorithm.
better option would complete enough allow algorithm determine
worlds new transition could exist.

way round, hold general models 0
result
semantic contraction models . see suppose
one atom p one action a, consider action theory = {p [a], hai>}.
model = h{{p}}, {({p}, {p})}i Figure 14.




w2

w1

w1

:

p

M0 :

p

p

Figure 14: Inadequacy contraction: model model 0 theory
resulting contracting p hai> T.
definitions, contract(M , p hai>) = {M }. (There p-world
0
remove arrow.) hand,
phai> singleton {T }
0 = {p [a], p hai>}. 0 = h{{p}, {p}}, ({p}, {p})i Figure 14
model resulting contracted theory. Clearly, 0 result semantic
contraction p hai> : p valid contraction models T,
valid models 0 . means theories operators
adequate.
problem occurs because, example, worlds forbidden T, e.g.
{p}, preserved 0 . contracting executability effect law,
supposed change possible worlds theory (cf. Section 3).
Fortunately correctness algorithms respect semantics established action theories whose maximal, i.e., set static laws alone
219

fiVarzinczak

characterize worlds possible models theory. principle
modularity (Herzig & Varzinczak, 2005b) briefly review next section.
6.2 Modular Action Theories
quite useful, albeit simple, property domain descriptions reasoning actions
action theory modularity (Herzig & Varzinczak, 2005b).
Definition 6.1 (Modularity) action theory modular every
Boolean formula Fml, |=
, |=CPL .
K
n

example non-modular theory, let us suppose action theory
coffee machine scenario stated


coffee

hot,
hbuyi>,






coffee [buy]coffee,
T=

token [buy]token, token [buy],




coffee [buy]coffee, hot [buy]hot
modified law underlined: (in case wrongly) stated agent
always buy machine. |=K token, 6|=
token.
CPL
n

Since underlying multimodal logic independently axiomatized (see Section 2.1),
use algorithms given Herzig Varzinczak (2005b) check whether action
theory satisfies principle modularity. Whenever case, algorithms
return Boolean formulas entailed theory consequences alone.
theory above, would return {token}: stated hbuyi>,
inexecutability law token [buy] |=
token. 6|=
token,
Kn
CPL
token called implicit static law (Herzig & Varzinczak, 2004) action
theory T.5
Modular action theories several interesting computational properties. example, consistency checked checking consistency static laws :
modular, |=
|=
. Deduction effect laws
Kn
CPL
need executability ones vice versa. Deduction effect sequence actions a1 ; . . . ; (prediction) need take account effect laws actions
a1 , . . . , . applies particular plan validation deciding whether
ha1 ; . . . ; case.
Modularity exclusive property action theories formalized Kn : similar
notions investigated different contexts formalisms, regulation consistency deontic logic (Cholvy, 1999), Situation Calculus (Herzig & Varzinczak,
2005a), DL ontologies (Herzig & Varzinczak, 2006), dynamic logic (Zhang, Chopra, & Foo,
2002) Fluent Calculus (Thielscher, 2010). details modularity
Kn action theories, well role presence solution frame
ramification problems, see work Varzinczak (2006).
5. Implicit static laws closely related veridical paradoxes (Quine, 1962). turns sometimes
intuitive, sometimes not. deep discussion implicit static laws, see
work Varzinczak (2006).

220

fiOn Action Theory Change

Another interesting property modular action theories following:
Theorem 6.1 modular canonical model.
Proof: Let Mcan = hWcan , Rcan canonical frame T.
Mcan

Mcan

(): definition, Mcan |= E . remains show |= X . Let
Mcan
hai> Xa , let w Wcan |=w . Therefore j Fml
Mcan

|=K j [a], must 6|=
w
n

Mcan

|=
(i j ), hence |=
CPL

Mcan

w0 Wcan |= 0
Mcan

|=

w

j , |=
(i j ), modular,
K
n

(i j ). construction Mcan ,
Mcan

[a] Ea |=
w

. Thus Ra (w) 6=

hai>.

(): Suppose modular. must Fml |=

Kn
6|=
. means v val(S ) v 6 . v Wcan (because Wcan
CPL
contains possible valuations ), Mcan model T.
2
6.3 Correctness Modularity
shown Herzig Varzinczak (2007), given action theory formalized
framework available literature allowing expression three basic types
laws, always possible ensure modularity. Moreover, going see
sequel (cf. Section 7.2), computed evolution
action theory. Hence, relying modular theories limitation approach.
following theorem establishes assumption action theory
modular, semantic contraction formula set models produces
models contracted theory
.


Theorem 6.2 Let modular, law. M0
|=
M0

0
0
0
every M, 0
|= every .

2

Proof: See Appendix A.

next theorem establishes way round: modularity models theories

models semantic contraction models T.
M0

0
0
Theorem 6.3 Let modular, law, 0
. |= ,


0
0
M0
|= every M.

2

Proof: See Appendix B.
two theorems get correctness operators:
M0

0
Corollary 6.1 Let modular, law, 0
|=
. |=
K


n

every 0 M0 M0
|= M.
221

fiVarzinczak

Proof:
M0
0
0
(): Let 0 |= 0 . Theorem 6.3, M0



M0

|= M. 0 |=
, |= .
K
n

(): Suppose 0 6|=K . (We show model 0 M0 M0

n



M0

|= M, 6|= .)
Given modular, Lemma B.1 0 modular, too. Then, Lemma B.3,
M0
M0
0 = hval(S 0 ), R0 6|= . Clearly |= 0 , Lemma B.4
result follows.
2

7. Assessment Postulates Change
action theory change operators satisfy classical postulates change?
answering question, one ask: operators behave revision update
operators? address issue show postulates theory change
satisfied definitions.
7.1 Contraction Erasure?
distinction revision/contraction update/erasure classical theories
historically controversial literature. true case modal theories
describing actions effects. rephrase Katsuno Mendelzons definitions (1992) terms see one method closer.
Katsuno Mendelzons view, contracting law action theory intuitively means description possible behavior dynamic world must
adjusted possibility false. amounts selecting models
closest models allow models result.
contrast, update methods select, model T, set models
closest . Erasing means adding models T; model , add
models closest false. Hence, constructions far
seems operators closer update revision.
Moreover, according Katsuno Mendelzons view (1992), change operators
would classified update make modifications model independently, i.e., without changing models.6 Besides that, setting different
ordering resulting models induced model theory (see Definitions 3.3, 3.7 3.10), according Katsuno Mendelzon typical property
update/erasure method.
Nevertheless, things get quite different comes postulates theory change.
7.2 Postulates
section analyze behavior action theory change operators respect
AGM-like postulates. follow Katsuno Mendelzons presentation
6. Even contracting effect law one particular model need check models
theory, modified.

222

fiOn Action Theory Change

postulates assess contraction erasure. Let = E X denote action
theory denote law.
0 , 0
Monotonicity Postulate: |=
.
K
n

postulate version Katsuno Mendelzons (C1) (E1) postulates
contraction erasure, respectively, satisfied change operators.
proof Lemma A.1. postulate satisfied operators proposed
Herzig et al. (2006): removing e.g. executability law hai> one may
make [a] valid models resulting theory.
Preservation Postulate: 6|=
, |=
0 , 0
.
K
K
n

n

Katsuno Mendelzons (C2) postulate. operators satisfy far
whenever 6|=
, models resulting theory exactly models T,
Kn
minimal models falsifying .
corresponding version Katsuno Mendelzons (E2) postulate erasure,
i.e., |=
, |=K 0 , 0
, clearly satisfied operators
Kn
n
special case postulate above. Satisfaction (C2) indicates operators
closer contraction erasure.
6|=K 6|=K , 0 6|=K , 0
.

Success Postulate:

n

n

n

postulate version Katsuno Mendelzons (C3) (E3) postulates.
propositional Fml, operators satisfy it, long classical propositional
change operator satisfies well. general case, however, stated postulate
always satisfied. shown following example: let = {p, hai>, p [a]}.
Note modular consistent. Now, contracting (contingent) formula p hai>
gives us 0 = T. Clearly 0 |=K p hai>. happens because, despite
n
tautology, p hai> trivial formula respect T: since p valid T-models,
p hai> trivially true models (cf. end Section 3.1).
Fortunately, formulas non-trivial consequences theory,
operators guarantee success contraction:
Theorem 7.1 Let consistent, executability effect law
6|=
. modular, 0 6|=K every 0
.
K
n

n

0
Proof: Let us suppose 0
. Since modular,
|=
K
n

M0

Corollary 6.1 tells us |= every 0 M0 M0
, = {M :


|= = hval(S ), Ri}.
M0

00

|= every 0 M0 , even 00 M0 \M |= . 00
00

M, definition 6|= . Hence = , truth
depend accessibility relation Ra . Hence, whether form hai>
[a], , Fml, holds |=CPL (see Definitions 3.1 3.5),
therefore get |=K .
2
n

223

fiVarzinczak

Equivalences Postulate: |=K T1 T2 |=
1 2 , |=K T10 T20 ,
K

0
T10 (T1 )
2 T2 (T2 )1 .

n

n

n

postulate corresponds Katsuno Mendelzons (C4) (E4) postulates.
worth noting equivalence considered always modulo action laws, i.e.,
formulas assumed either static laws, effect laws executability laws, well
equivalents. Moreover remember theories must action theories,
i.e., sets action laws three basic types. modularity assumption
propositional change operator satisfies (C4)/(E4), operations satisfy postulate:
T1 T2 |=K 1 2 ,
Theorem 7.2 Let T1 T2 modular. |=
K
n

n


0
0 T20 , vice-versa.
T10 (T1 )
2 T2 (T2 )1 |=
K 1
n

Proof: proof follows straight results: since |=
T2 |=K 1 2 ,
K 1
n





n

pairwise models. Hence, given |= T1 |= T2 , semantic
contraction 1 2 operations . T1 T2
modular, Corollary 6.1 guarantees get syntactical results. Moreover,
classical operator satisfies (C4)/(E4), follows |=K T10 T20 .
2
n

Recovery Postulate: 0 {} |=
T, 0
.
K
n

action theory counterpart Katsuno Mendelzons (C5) (E5) postulates. rely modularity order satisfy it.
Theorem 7.3 Let modular. 0 {} |=
T, 0
.
K
n

Proof: 6|=K , operators satisfy preservation postulate, 0 = T,
n
result follows monotonicity.
Let |=
, let M0 denote set models 0 . modular, CorolK
n

M0

M0

lary 6.1 every 0 M0 either |= (and |= ) 0 contract(M , )

(and 0 ) |= T.
Let M00 denote set models 0 {}. Clearly M00 M0 , monotonicity.
00

Moreover, every 00 M00 |= , hence 00
/ every


|= T, 00
/ contract(M , ), model T. Thus 00 model
0
{} |=K T.
2
n
W

0
Let
denote disjunction .
W
W
Disjunctive Rule: (T1 T2 )
(T1 )
(T2 )
equivalent

.
version (E8) erasure postulate Katsuno Mendelzon. Clearly
syntactical operators manage contract law disjunction theories: T1 T2
action theory cannot general rewritten one. Nevertheless, proving
holds semantics, correctness operators, get equivalent
operation. fact theories concern modular gives us result.
224

fiOn Action Theory Change

Theorem 7.4 Let T1 T2 modular, law.
_
_
_
(T2 )
(T1 )
|=K
(T1 T2 )
)

(
n

Proof:
W
0W
0W
0W

(T2 )
(T1 )
(): Let 0 |=
(T1 )
. Suppose
|=
(T2 ) . |=
0
M0
W


|=
(T1 ) (the case analogous). (T1 )0 (T1 ) |= (T1 )0 .
0
0
Corollary 6.1, M0
, set models
0
T1 . model resulting contracting models T1 , 0
results contracting models T1 T2 , viz. models T1 . CorolM0
0W
0 , |=


|=
(T


)
(T1 T2 )
lary 6.1, (T1 T2 )0 (T1 T2 )
1
2
.

0W

(): Let 0 |=
M0


0
(T1 T2 )
. (T1 T2 ) (T1 T2 )

0
0
|= (T1 T2 )0 . Corollary 6.1, M0
, set
0
models T1 T2 . model resulting contracting models T1 T2 .
Hence 0 results contracting models T1 models T2 . Suppose
former case (the second analogous). Corollary 6.1 (T1 )0 (T1 )

M0
0W
|= (T1 )0 , |=
(T1 )
.
2


thus shown constructions satisfy (E8) postulate. Nevertheless,
far see, immediate whether really expected here. supports
position operators behavior closer contraction erasure.
seen results above, modularity sufficient condition
satisfaction AGM-like postulates action theory contraction. finish state
new postulate:
Preservation Modularity: modular, every 0
modular.
Changing modular theory make non-modular. standard
postulate, think since good property modularity preserved
across changing action theory. so, means whether theory modular
checked one need care future
evolution action theory, i.e., changes made it. operators
satisfy postulate proof given Appendix B.
one may naturally asks whether get characterization result traditional AGM sense, i.e., whether contraction operator satisfying versions
postulates one three contraction operations. Unfortunately, good sense points
towards negative answer: might well operator satisfying postulates that, complying assumptions RAC community (Shanahan,
1997), necessarily one operators defined Section 3 (cf. discussion
general formula contraction Section 10). witness, consider example operator
modifies worlds contracting effect laws. supports one contentions
present work, viz. classical belief change cannot fully transposed action
theories expected give exactly kind outcome. Similar negative results
found revision DL ontologies (Flouris, Plexousakis, & Antoniou, 2004)
contraction Horn theories (Booth, Meyer, & Varzinczak, 2009).
225

fiVarzinczak

8. Semantics Action Theory Revision
far analyzed case contraction: knowledge engineer realizes
theory strong therefore weakened. Let us take look
way round, i.e., theory (possibly) liberal agent discovers new laws
world added beliefs, amounts strengthening them.
Suppose action theory scenario example initially stated follows:


coffee hot, token hbuyi>,


coffee [buy]coffee, token [buy],
T=


coffee [buy]coffee, hot [buy]hot
canonical model theory shown Figure 15.
w1
t, c, h
b

b

w2

:

b

w3

b

t, c, h

t, c, h

b
b

w5
t, c, h

w6

w4
t, c, h

t, c, h

Figure 15: Canonical model new initial action domain description.
Looking model Figure 15 see that, example, agent know
loses token every time buys coffee machine. new law
incorporate knowledge base stage action theory evolution.
Contrary contraction, want negation law become satisfiable,
revision want make new law valid. means one eliminate cases
satisfying negation. depicts duality revision contraction: whereas
latter one invalidates formula making negation satisfiable, former one
makes formula valid forcing negation unsatisfiable prior adding new
law theory.
idea behind semantics revision follows: initially set models
given formula (potentially) valid, i.e., (possibly) true
every model M. result want models . Adding -models
help. Moreover, adding models makes us lose laws: corresponding resulting
theory would liberal.
One solution amounts deleting models -models.
course removing solve problem, must delete every
model. that, resulting models models . (This corresponds theory
expansion, resulting theory satisfiable.) However, contains model
, end . Consequence: resulting theory inconsistent. (This
main revision problem.) case solution substitute model
226

fiOn Action Theory Change

nearest modification M? makes true. lets us keep close possible
original models had. But, one model several minimal
(incomparable) modifications validating ? case shall consider them.
result list models M? , models .
defining revision sets models, present modifications (individual) models are.
8.1 Revising Model Static Law
Suppose coffee deliverer agent discovers hot drink served
machine coffee. case, might want revise beliefs new static
law coffee hot: cannot hold hot drink coffee.
Considering model depicted Figure 15, one see Boolean formula
coffee hot satisfiable (there world model holds). Since
want case, first step remove worlds coffee hot
true. second step guarantee remaining worlds (if any) satisfy new
static law. issue largely addressed literature propositional belief
base revision update (Gardenfors, 1988; Winslett, 1988; Katsuno & Mendelzon, 1992;
Herzig & Rifi, 1999). achieve semantics similar classical
revision operators: basically one change set possible valuations, removing
adding worlds.
example, removing possible worlds {t, c, h} {t, c, h} would job
(there need add new valuations since new incoming law already satisfied
least one world original model, therefore resulting set worlds non-empty).
delicate point removing worlds may consequence loss
executability laws: example, transition world w
say {t, c, h}, removing latter model would make action
concern longer executable w, transition labeled action leaving
it. semantic point view, intuitive: state world
could move longer possible, transition state anymore.
Therefore, transition one had, natural lose it.
Similarly, one could ask accessibility relation new worlds
added, i.e., expansion possible. Following discussion Section 3.3,
prefer add new transitions systematically accessibility relation. Hence shall
postpone correction executability laws, needed. approach may debatable,
information hand, safest way changing static laws. (See
discussion Sections 3.3 4.2.)
semantics revision one model static law follows:
Definition 8.1 Let = hW, Ri. 0 = hW0 , R0 M? if:
W0 = (W \ val()) W , W val();
R0 R.
227

fiVarzinczak

M0

Clearly unless |=
, |= 0 M? . minimal models
CPL
resulting revising model closest respect :
Definition 8.2 Let model static law. revise(M , ) =



min{M? , }.

example model Figure 15, revise(M , coffee hot) singleton
{M 0 }, 0 shown Figure 16.
w1
t, c, h
b
w2

M0 :

b

t, c, h
b
b

w5
t, c, h

w4
t, c, h

Figure 16: Model resulting revising model Figure 15 coffee hot.

8.2 Revising Model Effect Law
Let us suppose agent eventually discovers buying coffee
keep token anymore. (That design mistake agent still possesses
token even ordering coffee machine). means theory
revised way new effect law token [buy]token holds. Looking
model Figure 15, amounts guaranteeing formula token hbuyitoken
satisfiable none worlds. that, look worlds satisfying
formula (if any) either (i) make token false worlds; (ii) make
hbuyitoken false them. chose first option, essentially flip truth
value literal token respective worlds, changes set valuations
model. chose latter, basically remove buy-arrows leading token-worlds.
case, change accessibility relation made.
example, possible worlds {token, coffee, hot}, {token, coffee, hot}
{token, coffee, hot} satisfy token hbuyitoken change.
Flipping token worlds token would job, would
consequence introduction new static law: token would valid, i.e.,
agent never token! Another issue approach making token true
everywhere, new incoming law token [buy]token trivially true resulting
model, mean execution action buy token-world
token one. defeats purpose changing action theory basis
observed every execution action consideration lead
token-contexts.
One contentions present work changing action laws never
side effect change static laws (cf. Sections 3 4). Given special status (Shanahan, 1997), change explicitly required. case, world
228

fiOn Action Theory Change

satisfying token hbuyitoken changed hbuyitoken longer true it.
example, remove transitions ({token, coffee, hot}, {token, coffee, hot}),
({token, coffee, hot}, {token, coffee, hot}) ({token, coffee, hot}, {token, coffee, hot}).
semantics one model revision case new effect law is:
?
Definition 8.3 Let = hW, Ri. 0 = hW0 , R0 M[a]
if:

W0 = W;
R0 R;


(w, w0 ) R \ R0 , |=w ;
M0

|= [a].
minimal models resulting revision model new effect law
closest respect order models :
Definition 8.4 Let model [a] effect law. revise(M , [a]) =

?
min{M[a]
, }.
Taking shown Figure 15, revise(M , token [buy]token)
singleton {M 0 } (Figure 17).
w1
t, c, h
b

b
w3

w2

M0 :

t, c, h

t, c, h
b

w5

w6

w4
t, c, h

t, c, h

t, c, h

Figure 17: Model resulting revising model Figure 15 new effect law
token [buy]token.

8.3 Revising Model Executability Law
Let us suppose stage decided grant free coffee everybody.
Faced information, agent revise laws reflect fact buy
executed token-contexts: token hbuyi> new executability law (and
therefore hbuyi> new models agents beliefs).
Considering model Figure 15, observe (token hbuyi>)
satisfiable . means must throw token [buy] away ensure
new formula becomes true new model, i.e., satisfied worlds.
229

fiVarzinczak

remove token [buy] look worlds satisfying modify
longer satisfy formula. Given worlds {token, coffee, hot}
{token, coffee, hot}, two options: change interpretation token add new
transitions leaving worlds. question arises choice drastic:
change world transition ? Again, think changing worlds content
(the valuation) drastic, existence world foreseen static
law hence assumed is, unless enough information supporting
contrary, case explicitly change static laws (see above). Moreover,
changing truth value token worlds would trivialize new incoming law
token hbuyi> new model, defeating purpose guaranteeing existence
buy-transition token-context. Therefore shall add new buy-arrow
{token, coffee, hot} {token, coffee, hot}.
agreed that, issue is: worlds new transitions
directed to? Recalling reasoning developed Section 3.2, order comply
minimal change, new transitions shall directed worlds relevant targets
token-worlds question. example, {token, coffee, hot}
relevant target world here: two token-worlds violate effect coffee buy,
three token-worlds would make us violate frame axiom token [buy]token.
semantics one model revision new executability law follows:
?
Definition 8.5 Let = hW, Ri. 0 = hW0 , R0 Mhai>
if:

W0 = W;
R R0 ;
(w, w0 ) R0 \ R, w0 RelTarget(w, [a], , M);
M0

|= hai>.
minimal models resulting revising model new executability law
closest respect :
Definition
model hai> executability law. revise(M ,
8.6 Let
?
hai>) = min{Mhai>
, }.
running example, revise(M , token hbuyi>) singleton {M 0 }, 0
depicted Figure 18.
example, observe single relevant target world get
single model result revision.
8.4 Revising Sets Models
seen revision single models means. needed
expansion new law possible due inconsistency. give unified
definition revision set models new law :
230

fiOn Action Theory Change

b
w1
t, c, h
b

b

b

w2

M0 :

b

t, c, h
b

t, c, h

t, c, h

b
b

w5

b
w3

w6

w4
t, c, h

t, c, h

Figure 18: Result revising Figure 15 new executability law token hbuyi>.

Definition 8.7 Let set models law.
(


\ {M : 6|= }, |= ;
?
=

revise(M , ), otherwise.
Observe Definition 8.7 comprises expansion revision: first one, simple
addition new law gives satisfiable theory; latter deeper change needed
get rid inconsistency.

9. Related Work
best knowledge, first work updating action domain description
Li Pereira (1996) narrative-based action description language (Gelfond &
Lifschitz, 1993). Contrary us, however, mainly investigate problem updating
narrative new observed facts (possibly) occurrences actions explain
facts. amounts updating given state/configuration world (in terms,
true possible world) focusing models narrative
actions took place (in terms, models action theory particular sequence
action executions). Clearly models action laws remain same.
Baral Lobo (1997) introduce extensions action languages allow
causal laws stated defeasible. work similar allow
weakening laws: setting, effect propositions replaced call
defeasible (weakened versions of) effect propositions. approach different
way executability laws dealt with. executability laws explicit
able contract them. feature important qualification problem
considered: may always discover contexts preclude execution given action
(cf. Introduction).
Liberatore (2000) proposes framework reasoning actions possible express given semantics belief update, Winsletts (1988) Katsuno
Mendelzons (1992). means formalism, essentially action description lan231

fiVarzinczak

guage, used describe updates (the change propositions one state
world another) expressing laws action theory.
main difference Liberatores work (2000) Li Pereiras (1996)
that, despite concerned, least priori, changing action laws, Liberatores
framework allows abductively introducing action theory new effect propositions
(effect laws, terms) consistently explain occurrence event.
work Eiter et al. (2005) similar propose framework
oriented updating action laws. mainly investigate case e.g.
new effect law added description (and true models
modified theory). problem dual contraction closer definition
revision (cf. Section 8).
Eiter et al.s framework (2005), action theories described variant narrativebased action description language. present work, semantics terms
transition systems, transitions (action occurrences) linking states (configurations
world). Contrary us, however, minimality condition outcome
update terms inclusion sets laws, means approach syntax
oriented extent.
setting, update action theory seen composed two pieces,
Tu Tm , Tu stands part supposed change Tm contains
laws may modified. terms, contracting static law would
Tm = Xa ; contracting executability law Tm = Xa ; contracting
effects laws Tm = Ea . difference approach always clear
laws change given type contraction, therefore Tu Tm need
explicitly specified prior update.
approach described constraint-based update,
theory change carried relative constraints (a set laws want hold
result). framework, example, changes action laws relative
set static laws (and concentrate models val(S )
worlds). changing law, want keep set states. difference
respect Eiter et al.s (2005) approach possible update theory
relatively e.g. executability laws: expanding new effect law, one may want
constrain change action concern guaranteed executable
result.7 shown referred work, may require withdrawal static
law. Hence, Eiter et al.s framework, static laws status ours.
Herzig et al. (2006) define method action theory contraction that, despite
similarity current work common underlying motivations, limited
present constructions.
First, referred approach get minimal change. example,
referred work operator contracting executability laws resulting
theory modified set executability laws given
Xa = {(i ) hai> : hai> Xa }
7. could simulate approach two successive modifications T: first adding effect
law executability law (cf. Section 8).

232

fiOn Action Theory Change

which, according semantics, gives theories among whose models resulting
removing transitions -worlds. similar comment made respect
contraction effect laws.
Second, Herzig et al.s (2006) contraction method satisfy postulates
action theory change addressed Section 7. Besides satisfying
monotonicity postulate, satisfy preservation one. witness, suppose
language one atom p, model depicted Figure 19.

w1

:





w2
p

p




w1

:
0



w2
p

p


Figure 19: Counter-example preservation method Herzig et al. (2006).




|= p [a]p 6|= [a]p. contraction operator defined
removing [a]p yields model 0 Figure 19 R0a = WW.
M0

6|= p [a]p, i.e., effect law p [a]p preserved.
Finally, another work related Zhang Ding (2008).
ours, approach giving semantic characterization basic operations
changing Kripke models. Contrary us however, focus model checking,
entailment. Despite definition use operations essence similar
(modifications set possible worlds accessibility relation), work
concerned mainly modifications single model, sets models
do, hence provide operations changing action laws.
that, approach directly comparable ours, since interested
entailment-based revision.

10. Concluding Remarks
work addressed problem changing action domain description
reasoning actions, problem sufficiently investigated literature far.
seen intuitions behind kind theory modification given
semantics action theory change terms distances models captures
notion minimal change. given algorithms contract formula theory
terminate correct respect semantics (Corollary 6.1).
shown importance modularity notion result others.
extended Varzinczaks investigations (2008) defining semantics
action theory revision based minimal modifications models. corresponding
revision algorithms, reader referred work Varzinczak (2009). One
ongoing research topics assessing revision operators behavior respect
appropriate versions AGM postulates revision (Alchourron et al., 1985)
links contraction counterpart.
algorithms provide set tools used knowledge engineer
interactive possibly iterative way modify action theory. tools guaranteed
233

fiVarzinczak

perform minimal change assisting knowledge engineer implementing
desired modifications. give set options knowledge engineer
decide one line intuitions.
Given action theory change single step operation, knowledge engineer
expected make use contraction/revision operators make series modifications
eventually give fine-grained theory entailing contracted laws entailing
new learned laws domain.
sake presentation, abstracted frame ramification
problems. However definitions could stated formalism suitable solution them, Castilho et al.s approaches (1999, 2002). regards
qualification problem, ignored here: contracting wrong executability laws
approach towards solution. Indeed, given difficulty stating sufficient conditions
executability action, knowledge engineer writes lets
theory evolve via subsequent revisions.
possible criticism approach developed concerns cautiousness
operator contracting static laws: prefer lose executability laws rather
induce lose effect laws. behavior could make operators interpreted
incoherent. pointed nevertheless line largely accepted
assumptions RAC community, moreover shown impossibility
non-cautious static law contraction operator complies coherent
operators.
Indeed one purposes present work shed light fundamental
differences belief change action domain descriptions logical theories
general. Classical belief change cannot fully transplanted action theories,
shown (cf. Sections 3.2, 4.2, 5.3 8.3).
particular, looking postulates classical belief change (or versions thereof)
one sees enough fully characterize operators action theory change.
achieved fundamental assumptions reasoning actions
extensively used throughout work somehow compiled postulates
supplementing classical ones. immediately clear new postulates
would look like, interesting thread investigation worth pursuing.
might argued semantic operations respect principle
categorical matching, given input output different sorts objects, viz.
set models set sets models (cf. Definitions 3.3, 3.7 3.10). easy see,
however, semantic constructions could defined way
M0
corresponds result one contraction operator. choice defining
result operation set possible outputs driven definition
algorithms, theory (corresponding set models) given input
output set theories (hence corresponding set set models).
Although semantic operators redefined satisfy principle categorical matching, immediate algorithms (they would nondeterministic). Therefore preferred keep balance semantic
syntactic definitions see clearly direct correspondence.
234

fiOn Action Theory Change

One contentions sticking modular theories (and hence canonical models) big deal: use existent algorithms literature (Herzig &
Varzinczak, 2007) ensure action theory characterized canonical models.
seen modularity, operators satisfy postulates contraction: Modularity one sufficient conditions Success Theorem 7.1.
sufficient condition Theorem 7.2, and, shown Theorem 7.3, sufficient
condition Recovery. Finally sufficient condition Disjunctive Rule
hold, shown preserved contraction operators (cf. last paragraph
Section 7.2, proof Appendix B). Preservation modularity important result since
means checked/ensured lifetime action
theory. results support thesis modularity notion fruitful.
forcing formulas explicitly stated respective modules (and thus possibly
making inferable independently different ways), modularity intuitively could
seen diminish elaboration tolerance (McCarthy, 1998). instance, contracting
Boolean formula non-modular theory, seems reasonable expect change
set static laws , theory modular surely forces changing module.
difficult, however, conceive non-modular theories contraction formula
may demand change well. example, suppose = {1 2 } action
theory whose dynamic part (implicitly) infer 2 . case, contracting 1
keeping 2 would necessarily ask change .
point nevertheless cases (modular non-modular) extra work
changing modules stays mechanical level, i.e., algorithms carry
modification, augment significant way amount work
knowledge engineer expected do.
Contrary trend belief change community, focus either belief
bases belief sets (Hansson, 1999), method proposed hybrid one (Delgrande,
2009). one hand, semantics plays crucial role notion minimal change
studied. hand, deal domain descriptions reasoning
actions, sets laws specific types. top that, modularity property (a
syntactical one) fundamental main results.
Following lines, another issue drives future research subject
contract laws Kn -formula. defined, order application
operators matter final result: contract [a] theory T,
result may contracting [a] first removing .
problem would appear general framework formula could
contracted: removing ( [a]) give result ( [a]) .
principle syntax independence (Dalal, 1988).
Related question revision definitions relate contraction
operators. known Levi identity (1977), ? =
{}, general
hold action laws (effect executability ones). reason
contraction operator effect executability law. Indeed
general contraction problem non-classical logics: contraction general
formula (like above) still open problem belief change area. insights
direction given revision definitions, make false every
possible world Kripke model.
235

fiVarzinczak

Definitions 3.1, 3.5 3.8 appear important better understanding problem
contracting general formulas: basically set modifications perform given
model order force falsify general formula comprise removal/addition
transitions/worlds. definition general revision/contraction method benefit
constructions.
Furthermore, given well-known connection multimodal logics Description Logics (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003), believe
definitions may contribute ontology evolution debugging specific
families DLs.

Acknowledgments
Parts work done authors stay Institut de Recherche en
Informatique de Toulouse (IRIT), France, visit National ICT Australia
(NICTA), Sydney.
author grateful anonymous referees constructive useful remarks, helped improving quality work. paper benefited
discussions Andreas Herzig Laurent Perrussel.
Special thanks colleagues Meraka Institute Arina Britz, Ken Halland,
Johannes Heidema Tommie Meyer invaluable comments suggestions
earlier versions article.

Appendix A. Proof Theorem 6.2


Let modular, law. M0
|= every M,
M0

0
0
0
0
|= every .

give proof theorem, need following lemma (cf.
Monotonicity Postulate Section 7.2):
Lemma A.1 |=
0.
K
n

Proof: Let action theory, let 0
, given law . going
analyze case.
Let form hai>, Fml. 0
0 = (T \ Xa ) {(i ( )) hai> : hai> Xa }
V
V
IP(S ) = pi atm() pi pi atm() pi , atm().
pi

pi
/



Let = hW, Ri |= T. enough show model new


laws. every (i ( )) hai>, every w W, |=w ( ), |=
.
w


|=K hai>, |= hai>, Ra (w) 6= .
n



Therefore |= 0 .
236

fiOn Action Theory Change

Let form [a], , Fml. 0
(T \ Ea )
{(i ( )) [a]i : [a]i Ea }
0

0 = {(i ) [a](i ) : [a]i Ea }


` L, forVsome L Lit s.t.


( `) [a]( `) : 6` ( 0 `L `) , ` 0


6`Kn ( `) [a]`

Ea =



,
1in (Ea )i ,

IP(S ), =

V
pi atm()
pi

pi

V
pi atm()
pi
/

pi ,

atm(), 0 IP(S ).

Let = hW, Ri |= T. enough show model

added laws. Given (i ( )) [a]i , every w W, |=w ( ),






|=w . |=K [a]i , |= [a]i , |= 0 every w0 W
w
n
(w, w0 ) Ra .


(i ) [a](i 0 ), every w W, |=w , |= 0
w
every w0 W (w, w0 ) Ra .


Now, given ( `) [a]( `), every w W, |=w `, |=
,
w






|=
. Since |=
[a], |= [a], |= 0 every w0 W
Kn
w
w
0
(w, w ) Ra .

Therefore |= 0 .
Let propositional . 0
((T \ ) ) \ Xa
0 = {(i ) hai> : hai> Xa }
{ [a]}
.

Let = hW, Ri |= T. suffices show satisfies added laws.
Since assume behaves classical contraction operator, e.g. Katsuno


Mendelzons (1992), |=
, then, |= , |= .
CPL






given (i ) hai>, every w W, |=w , |=
,
w

|= hai>, Ra (w) 6= .

Finally, [a], |= , trivially satisfies [a].

Therefore |= 0 .

2

Proof Theorem 6.2


M0


0
0
Let = {M : |= T}, M0
. show |=
0
0
every .

237

fiVarzinczak

M0

M0

definition, 0 M0 either |= 6|= .
6= ,
M0

M0

0
must 0
. |= T, Lemma A.1 |= done. Let us suppose
M0

6|= . analyze case.
Let form hai> Fml. 0 = hW0 , R0 i, W0 = W,


0
(w, w0 ) Ra }, M.
R0 = R \ R
, Ra = {(w, w ) : |=
w
M0

M0

Let u W0 6|=
hai>, i.e., |=
R0a (u) = .
u
u
V
0
u , must v base(, WV
) v u. Let = `v `. Clearly
prime implicant . Let = `u\v `, consider
0 = (T \ Xa ) {(i ( )) hai> : hai> Xa }
(Clearly, 0 theory produced Algorithm 1.)
enough show 0 model new added laws. Given (i (A ))


M0

M0

, follows |=w .
( ), |=
hai> 0 , every w W0 , |=
w
w


|= hai>, w0 W w0 Ra (w). need show


0
0
(w, w0 ) R0a . 6|=
, R
, either w = u,
= , (w, w ) Ra . |=
w
w
M0

M0

|=u conclude |=u (i ( )) hai>, w 6= u must



(w, w0 ) R0a , otherwise
Ra R(R \ Sa ) R(R \ Ra ),
00

00
0
00 = hW0 , R \
6|= hai> , contradiction
M0

M0

0 minimal respect . Thus (w, w0 ) R0a , |=
hai>. Hence |= 0 .
w
let form [a], , Boolean. 0 = hW0 , R0 i,
W0 = W, R0 = R R,
,

R,
= {(w, w0 ) : w0 RelTarget(w, [a], , M)}

= hW, Ri M.
M0

M0

[a]. u0 W0 (u, u0 ) R0a
Let u W0 6|=
u

6|=0 . u , v base(, W0 ) v u, u0 , must
u
V
V
V
v 0 base(, W0 ) v 0 u0 . Let = `v `, = `u\v `, 0 = `v0 `.
Clearly (resp. 0 ) prime implicant (resp. ).

let Ea = 1in (Ea, )i let theory
(T \ Ea )
{(i ( )) [a]i : [a]i Ea }
0

0 = {(i ) [a](i ) : [a]i Ea }


` L, forVsome L Lit s.t.


( `) [a]( `) : 6` ( 0 `L `) , ` 0


6`Kn ( `) [a]`

(Clearly, 0 theory produced Algorithm 2.)
238

fiOn Action Theory Change

order show 0 model 0 , enough show model
M0
added laws. Given (i (A )) [a]i 0 , every w W0 , |=w (A ),
M0







|=
, |=w . |= [a]i , |= 0 w0 W (w, w0 ) Ra .
w


w

= , R0a (w) = Ra (w).
need show R0a (w) = Ra (w). 6|=w , R,



M0

M0

|=
, either w = u, |=u conclude |=
(i ( )) [a]i ,
w
u
,
w 6= u, must Ra
= , otherwise would S,
R,



,
,
0
,
00
R(R Sa ) R(R Ra ), = hW , R Sa would
00

6|= [a] 00 0 , contradiction since 0 minimal respect .
M0

Hence R0a (w) = Ra (w), |= 0 w0 (w, w0 ) R0a .
w

M0

M0

Now, given (i ) [a](i 0 ), every w W0 , |=w ,






|=w , |=
. Because, |= [a]i , |= 0 w0 W
w
w

M0

(w, w0 ) Ra , |= 0 every w0 W0 (w, w0 ) R0a \ Ra, . Now, given
w

M0

, |= 0 0 , result follows.
(w, w0 ) R,

w

M0

M0

Now, ( `) [a]( `), every w W0 , |=
`,
w






|=w , |=
. |= [a], |= 0 every w0 W
w
(w, w0 )

w

M0

Ra , |= 0
w

M0

w0

0

W (w, w0 ) R0a \ R,
. remains


show |= 0 ` every w0 W0 (w, w0 ) R,
. Since 0 minimal,

w

M0

M0

enough show |=0 ` every ` Lit |=
`. ` 0 , result
u
u

M0

follows. Otherwise, suppose 6|=0 `.
u

either ` 0 , 0 ` unsatisfiable, case Algorithm 2
put law ( `) [a]( `) 0 , contradiction;
` u0 \ v 0 . case, valuation u00 = (u0 \ {`}) {`}
0
00
0
u00 6 .
: `i u00 }
iV
V must u W , otherwise L = {`
0
0
|=K ( `i L0 `i ) , and, modular, |=CPL ( `i L0 `i ) ,
n
Algorithm 2 put law ( `) [a]( `) 0 , contradiction.
u00 W0 , moreover u00
/ R,
(u), otherwise 0 minimal.

,
u00 \ u u0 \ u, reason u00
/ Ra (u) `0 u u00
Mi V
0
|= `j u `j [a]` every Mi `0
/ v0 v0 base(, W 0 )
V
v0 u00 . Clearly `0 = `, `
/ 0 , |= `j u `j [a]`
every Mi M. |=
( `) [a]`, Algorithm 2
Kn
put law ( `) [a]( `) 0 , contradiction.
M0

Hence |= 0 ` every w0 W0 (w, w0 ) R0a .
w

M0

Putting results together, get |= 0 .
Let propositional . 0 = hW0 , R0 i, W W0 , R0 = R,
minimal respect , i.e., W0 minimal superset W u W0
239

fiVarzinczak

u 6 . assumed syntactical classical contraction operator
sound complete respect semantics moreover minimal, must
M0
W0 = val(S ). Therefore |= .
R0 = R, every effect law remains true 0 .
Now, let
((T \ ) ) \ Xa
0 = {(i ) hai> : hai> Xa }
{ [a]}
(Clearly, 0 theory produced Algorithm 3.)
M0

every (i ) hai> 0 every w W0 , |=
, Ra (w) 6= ,
w
M0



hai>. Given [a], every w W0 , |=
, w = u,
|=
w
w
Ra (w) = .
M0

2

Putting results together, |= 0 .

Appendix B. Proof Theorem 6.3
M0


0
0
0
Let modular, law, 0
. |= ,


0 M0 |= every M.
order prove result, first need show four important lemmas.
Lemma B.1 Let law. modular, every 0
modular.
0
Proof: Let nonclassical, suppose 0
modular.
0
0
0
0
0
0
Fml |=K 6|=
, set static
CPL
n
0
0
laws . Lemma A.1, |=
, |=
0 . nonclassical,
Kn
Kn
0
= . Thus 6|=CPL 0 , therefore modular.

Let Fml.
((T \ ) ) \ Xa
0 = {(i ) hai> : hai> Xa }
{ [a]}
.
Assume modular, let 0 Fml 0 |=
0 6|=
0 .
Kn
CPL
6|=
0 , v val(S ) v 6 0 . v val(S ), 6|=CPL 0 ,
CPL
modular, 6|=K 0 . Lemma A.1, |=K 0 , 0 6|=K 0 , contradiction.
n
n
n
Hence v
/ val(S ). Moreover, must v 6 , otherwise worked expected.

Let = hW, Ri |= 0 . (We extend another model 0 .) Let
0 = hW0 , R0 W0 = W {v} R0 = R. show 0 model
M0

0 , suffices show v satisfies every law 0 . v val(S ), |=
. Given
v
240

fiOn Action Theory Change

M0

[a] 0 , v 6 R0a (v) = , |=v [a]. Now, every [a]i 0 ,
M0

M0

|=v , trivially |=0 every v0 (v, v0 ) R0a . Finally, given
v

M0

(i ) hai> 0 , v 6 , formula trivially holds v. Hence |= 0 ,
M0

v W0 6|=
0 , 0 6|=K 0 , contradiction. Hence 0 Fml
v
n
0 , 0 modular.
0 |=K 0 , |=

2
CPL
n

Lemma B.2 Mcan = hWcan , Rcan model T, every = hW, Ri

|= minimal (with respect set inclusion) extension R0 Rcan \ R
0 = hval(S ), R R0 model T.


Proof: Let Mcan = hWcan , Rcan model T, let = hW, Ri |= T.
M0

Consider 0 = hval(S ), Ri. |= T, R0 = Rcan \ R minimal. Suppose
M0

M0

6|= T. extend 0 model minimal extension . 6|= T,
M0

M0

v val(S ) \ W 6|=
T. 6|=v .
v
Fml, v Wcan , Mcan model T. form [a],
, Fml, v0 val(S ) (v, v0 ) Ra v0 6 , contradiction since
M0

Ra (v) = . Let form hai> Fml. |=
. v Wcan ,
v
Mcan

Mcan

6|=v hai>, 6|= T. Hence, Rcana (v) 6= . Thus taking (v, v0 ) Rcana gives
us minimal R0 = {(v, v0 )} 00 = hval(S ), R R0 model T.
2
Lemma B.3 Let modular, law. |=
every 0 =
K
0

hW,Ri

hval(S ), R |=

n

0

R R model .

Proof:


(): Straightforward, since |=
implies |= every |= T, particular
Kn
extensions model T.




(): Suppose 6|=
. = hW, Ri |= 6|= . modular,
Kn
canonical frame Mcan = hWcan , Rcan model T. Lemma B.2
minimal extension R0 R respect Rcan 0 = hval(S ), R R0 model


T. 6|= , w W 6|=w . propositional Fml
M0

effect law, extension 0 6|=w . form hai>,


|=
Ra (w) = . extension (u, v) R0
w
u val(S ) \ W, worlds W get new departing transition. Thus
M0

2

(R R0 )a (w) = , 6|=w .

0
0
0
Lemma B.4 Let modular, law, 0
. = hval(S ), R model


0 , = {M : = hval(S ), Ri |= T} 0 M0
M0
.
241

fiVarzinczak

M0

M0

Proof: Let 0 = hval(S 0 ), R0 |= 0 . |= T, result follows. Let us
M0

suppose 6|= T. analyze case.
Let form hai>, Fml. Let = {M : = hval(S ), Ri}.
Since hypothesis modular, Lemmas B.2 B.3 follows non-empty
contains models T.
Suppose 0 minimal model 0 , i.e., 00 00 0
M. 0 00 differ executability
inVa given -world,
V
viz. -context, IP(S ) = pi atm() pi pi atm() pi
pi

M0

00

pi
/

atm(). 6|= ( ) hai>, must |= ( ) hai>
00

|= T. Hence 0 minimal respect .
contracting executability laws, 0 = . Hence taking right R minimal

0


0
R
(w, w0 )
= hval(S ), Ri R = R \ Ra , Ra {(w, w ) :|=
w

Ra }, construct M0 = {M 0 } Mhai> .
Let form [a], , Fml. Let = {M : = hval(S ), Ri}.
Since hypothesis modular, Lemmas B.2 B.3 follows non-empty
contains models T.
claim 0 oneVtransition linking
V -world, viz. context
IP(S ) = pi atm() pi pi atm() pi , atm(),
pi

pi
/

0 -world, 0 IP(S ). proof follows: given ` Lit ` holds
-world
( `) [a]( `)
/ 0 , `
/ 0 |=
( `) [a]`.
Kn
world `-successors.
( `) [a]( `) 0 , every 0 -successor `-world.
successively applying reasoning ` holds -world,
end one 0 -successor.
00
Suppose 0 minimal model 0 , i.e., 00 |= 0
00 0 M. 0 00 differ effects
-world: 00 transition linking 0 -world.
00
00
|= (i ) [a]i , |= T. Therefore 0 minimal model 0
respect .
contracting effect laws, 0 = . Thus taking right R minimal R,


0
,
,
0
= hval(S ), Ri R = R Ra , Ra {(w, w ) :|=
w0
w

RelTarget(w, [a], , M)}, construct M0 = {M 0 } M[a] .
Let Fml. Since modular, Lemmas B.2 B.3

= hval(S ), Ri |= T. know val(S ) val(S ). [a] 0 ,
R0a (v) = every -world v added 0 . Hence, minimal, taking =
{M } gives us result.
2
242

fiOn Action Theory Change

Proof Theorem 6.3
hypothesis modular Lemma B.1, follows 0 modular,
too. 0 = hval(S 0 ), Ri model 0 , Lemma B.3. Lemma B.4
result follows.
2

References
Alchourron, C., Gardenfors, P., & Makinson, D. (1985). logic theory change:
Partial meet contraction revision functions. Journal Symbolic Logic, 50, 510
530.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. (Eds.). (2003).
Description Logic Handbook. Cambridge University Press.
Baral, C., & Lobo, J. (1997). Defeasible specifications action theories. Pollack, M.
(Ed.), Proceedings 15th International Joint Conference Artificial Intelligence
(IJCAI), pp. 14411446. Morgan Kaufmann Publishers.
Booth, R., Meyer, T., & Varzinczak, I. (2009). Next steps propositional Horn contraction. Boutilier, C. (Ed.), Proceedings 21st International Joint Conference
Artificial Intelligence (IJCAI), pp. 702707. AAAI Press.
Burger, I., & Heidema, J. (2002). Merging inference conjecture information. Synthese, 131 (2), 223258.
Castilho, M., Gasquet, O., & Herzig, A. (1999). Formalizing action change modal
logic I: frame problem. Journal Logic Computation, 9 (5), 701735.
Castilho, M., Herzig, A., & Varzinczak, I. (2002). depends context! decidable
logic actions plans based ternary dependence relation. 9th International
Workshop Nonmonotonic Reasoning (NMR).
Cholvy, L. (1999). Checking regulation consistency using SOL-resolution. Proceedings
7th International Conference AI Law, pp. 7379.
Dalal, M. (1988). Investigations theory knowledge base revision: preliminary report.
Smith, R., & Mitchell, T. (Eds.), Proceedings 7th National Conference
Artificial Intelligence (AAAI), pp. 475479. Morgan Kaufmann Publishers.
De Giacomo, G., & Lenzerini, M. (1995). PDL-based framework reasoning actions. Gori, M., & Soda, G. (Eds.), Proceedings 4th Congress Italian Association Artificial Intelligence (IA*AI), No. 992 LNAI, pp. 103114.
Springer-Verlag.
Delgrande, J. (2009). Personal communication. Commonsense09, Toronto.
Demolombe, R., Herzig, A., & Varzinczak, I. (2003). Regression modal logic. Journal
Applied Non-Classical Logic, 13 (2), 165185.
Eiter, T., Erdem, E., Fink, M., & Senko, J. (2005). Updating action domain descriptions.
Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings 19th International Joint
Conference Artificial Intelligence (IJCAI), pp. 418423. Morgan Kaufmann Publishers.
243

fiVarzinczak

Finger, J. (1987). Exploiting constraints design synthesis. Ph.D. thesis, Stanford University.
Flouris, G., Plexousakis, D., & Antoniou, G. (2004). Generalizing AGM postulates.
10th International Workshop Nonmonotonic Reasoning (NMR).
Fuhrmann, A. (1989). modal logic theory change. Logic Theory Change,
pp. 259281.
Gardenfors, P. (1988). Knowledge Flux: Modeling Dynamics Epistemic States.
MIT Press.
Gelfond, M., & Lifschitz, V. (1993). Representing action change logic programs.
Journal Logic Programming, 17 (2/3&4), 301321.
Giunchiglia, E., Kartha, G., & Lifschitz, V. (1997). Representing action: indeterminacy
ramifications. Artificial Intelligence, 95 (2), 409438.
Hamming, R. (1950). Error detecting error correcting codes. Bell System Technical
Journal, 26 (2), 147160.
Hansson, S. (1994). Kernel contraction. Journal Symbolic Logic, 59 (3), 845859.
Hansson, S. (1999). Textbook Belief Dynamics: Theory Change Database Updating.
Kluwer Academic Publishers.
Harel, D., Tiuryn, J., & Kozen, D. (2000). Dynamic Logic. MIT Press.
Herzig, A., Perrussel, L., & Varzinczak, I. (2006). Elaborating domain descriptions.
Brewka, G., Coradeschi, S., Perini, A., & Traverso, P. (Eds.), Proceedings 17th
European Conference Artificial Intelligence (ECAI), pp. 397401. IOS Press.
Herzig, A., & Rifi, O. (1999). Propositional belief base update minimal change. Artificial
Intelligence, 115 (1), 107138.
Herzig, A., & Varzinczak, I. (2004). Domain descriptions modular. Lopez de
Mantaras, R., & Saitta, L. (Eds.), Proceedings 16th European Conference
Artificial Intelligence (ECAI), pp. 348352. IOS Press.
Herzig, A., & Varzinczak, I. (2005a). Cohesion, coupling meta-theory actions.
Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings 19th International Joint
Conference Artificial Intelligence (IJCAI), pp. 442447. Morgan Kaufmann Publishers.
Herzig, A., & Varzinczak, I. (2005b). modularity theories. Schmidt, R., PrattHartmann, I., Reynolds, M., & Wansing, H. (Eds.), Advances Modal Logic, Vol. 5,
pp. 93109. Kings College Publications.
Herzig, A., & Varzinczak, I. (2006). modularity approach fragment ALC.
Fisher, M., van der Hoek, W., Konev, B., & Lisitsa, A. (Eds.), Proceedings 10th
European Conference Logics Artificial Intelligence (JELIA), No. 4160 LNAI,
pp. 216228. Springer-Verlag.
Herzig, A., & Varzinczak, I. (2007). Metatheory actions: beyond consistency. Artificial
Intelligence, 171, 951984.
244

fiOn Action Theory Change

Jin, Y., & Thielscher, M. (2005). Iterated belief revision, revised. Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings 19th International Joint Conference Artificial
Intelligence (IJCAI), pp. 478483. Morgan Kaufmann Publishers.
Katsuno, H., & Mendelzon, A. (1992). difference updating knowledge
base revising it. Gardenfors, P. (Ed.), Belief revision, pp. 183203. Cambridge
University Press.
Kracht, M., & Wolter, F. (1991). Properties independently axiomatizable bimodal logics.
Journal Symbolic Logic, 56 (4), 14691485.
Levi, I. (1977). Subjunctives, dispositions chances. Synthese, 34, 423455.
Li, R., & Pereira, L. (1996). believed explained. Shrobe, H., & Senator, T. (Eds.), Proceedings 13th National Conference Artificial Intelligence
(AAAI), pp. 550555. AAAI Press/MIT Press.
Liberatore, P. (2000). framework belief update. Proceedings 7th European
Conference Logics Artificial Intelligence (JELIA), pp. 361375.
Makinson, D. (2007). Friendliness sympathy logic. Beziau, J.-Y. (Ed.), Logica
Universalis, Vol. 2, pp. 195224. Springer-Verlag.
Marquis, P. (2000). Consequence finding algorithms. Gabbay, D., & Smets, P. (Eds.),
Handbook Defeasible Reasoning Uncertainty Management Systems, Vol. 5:
Algorithms Uncertainty Defeasible Reasoning, edited J. Kohlas S.
Moral, chap. 2, pp. 41145. Kluwer Academic Publishers.
McCarthy, J. (1977). Epistemological problems artificial intelligence. Sridharan, N.
(Ed.), Proceedings 5th International Joint Conference Artificial Intelligence
(IJCAI), pp. 10381044. Morgan Kaufmann Publishers.
McCarthy, J. (1998). Elaboration tolerance. Proceedings 4th International Symposium Logical Formalizations Commonsense Reasoning.
McCarthy, J., & Hayes, P. (1969). philosophical problems standpoint
artificial intelligence. Meltzer, B., & Mitchie, D. (Eds.), Machine Intelligence,
Vol. 4, pp. 463502. Edinburgh University Press.
Nebel, B. (1989). knowledge level analysis belief revision. Brachman, R., Levesque,
H., & Reiter, R. (Eds.), Proceedings 1st International Conference Principles
Knowledge Representation Reasoning (KR), pp. 301311. Morgan Kaufmann
Publishers.
Parikh, R. (1999). Beliefs, belief revision, splitting languages. Moss, L. (Ed.),
Logic, Language Computation, No. 96 CSLI Lecture Notes, pp. 266278. CSLI
Publications.
Popkorn, S. (1994). First Steps Modal Logic. Cambridge University Press.
Quine, W. (1952). problem simplifying truth functions. American Mathematical
Monthly, 59, 521531.
Quine, W. (1962). Paradox. Scientific American, 1, 8496.
245

fiVarzinczak

Reiter, R. (2001). Knowledge Action: Logical Foundations Specifying Implementing Dynamical Systems. MIT Press.
Schlechta, K. (2004). Coherent Systems. Studies Logic Practical Reasoning 2.
Elsevier.
Shanahan, M. (1997). Solving frame problem: mathematical investigation common sense law inertia. MIT Press.
Shapiro, S., Lesperance, Y., & Levesque, H. (2005). Goal change. Kaelbling, L., & Saffiotti, A. (Eds.), Proceedings 19th International Joint Conference Artificial
Intelligence (IJCAI), pp. 582588. Morgan Kaufmann Publishers.
Shapiro, S., Pagnucco, M., Lesperance, Y., & Levesque, H. (2000). Iterated belief change
situation calculus. Cohn, T., Giunchiglia, F., & Selman, B. (Eds.), Proceedings
7th International Conference Principles Knowledge Representation
Reasoning (KR), pp. 527538. Morgan Kaufmann Publishers.
Thielscher, M. (1997). Ramification causality. Artificial Intelligence, 89 (12), 317364.
Thielscher, M. (2010). unifying action calculus. appear Artificial Intelligence.
Varzinczak, I. (2006). good domain description? Evaluating revising action
theories dynamic logic. Ph.D. thesis, Universite Paul Sabatier, Toulouse.
Varzinczak, I. (2008). Action theory contraction minimal change. Lang, J., &
Brewka, G. (Eds.), Proceedings 11th International Conference Principles
Knowledge Representation Reasoning (KR), pp. 651661. AAAI Press.
Varzinczak, I. (2009). revision action laws: algorithmic approach. IJCAI
Workshop Nonmonotonic Reasoning, Action Change (NRAC).
Winslett, M.-A. (1988). Reasoning action using possible models approach. Smith,
R., & Mitchell, T. (Eds.), Proceedings 7th National Conference Artificial
Intelligence (AAAI), pp. 8993. Morgan Kaufmann Publishers.
Zhang, D., Chopra, S., & Foo, N. (2002). Consistency action descriptions. Ishizuka,
M., & Sattar, A. (Eds.), Proceedings 7th Pacific Rim International Conference
Artificial Intelligence, No. 2417 LNCS, pp. 7079. Springer-Verlag.
Zhang, D., & Foo, N. (2001). EPDL: logic causal reasoning. Nebel, B. (Ed.), Proceedings 17th International Joint Conference Artificial Intelligence (IJCAI),
pp. 131138. Morgan Kaufmann Publishers.
Zhang, Y., & Ding, Y. (2008). CTL model update system modifications. Journal
Artificial Intelligence Research, 31, 113155.

246


