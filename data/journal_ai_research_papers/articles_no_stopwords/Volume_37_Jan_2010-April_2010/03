journal artificial intelligence

submitted published

interactive cost configuration decision diagrams
henrik reif andersen

hra configit com

configit
dk copenhagen denmark

tarik hadzic

hadzic c ucc ie

cork constraint computation centre
university college cork
cork ireland

david pisinger

pisinger man dtu dk

dtu management
technical university denmark
dk kgs lyngby denmark

abstract
many ai domains product configuration user interactively specify
solution must satisfy set constraints scenarios offline compilation
feasible solutions tractable representation important delivering efficient backtrack free user interaction online particular binary decision diagrams
bdds successfully used compilation target product service configuration discuss extend bdd configuration scenarios
involving cost functions express user preferences
first efficient robust easy implement extension possible
cost function additive feasible solutions represented multi valued decision diagrams mdds discuss effect mdd size cost function
non additive encoded explicitly mdd discuss interactive configuration presence multiple cost functions prove even simplest form
multiple cost configuration np hard input mdd however solving two cost
configuration develop pseudo polynomial scheme fully polynomial approximation scheme applicability demonstrated experiments
real world configuration product catalogue datasets response times generally within fraction second even large instances

introduction
interactively specifying solution must satisfy number combinatorial restrictions
important many ai domains related decision making buying
product online selling insurance policy setting piece equipment solutions
often modeled assignments variables constraints imposed
assigning variables without sufficient guidance user might forced backtrack since
choices made cannot extended way would satisfy
succeeding constraints improve usability interaction therefore important
indicate user values participate least one remaining solution
c

ai access foundation rights reserved

fiandersen hadzic pisinger

user assigning values guaranteed able reach feasible solution
never forced backtrack refer task computing values
calculating valid domains cvd since computationally challenging np hard
short execution times important interactive setting
suggested compile offline prior user interaction set feasible solutions
representation form supports efficient execution cvd online interaction
mller andersen hulgaard hadzic subbarayan jensen andersen
mller hulgaard investigated binary decision diagrams bdds compilation target bdds one data structures investigated
knowledge compilation community preprocess original formulations
tractable representations enhance solving subsequent tasks cvd one
tasks occurring configuration domain knowledge compilation successfully applied number areas diagnosis model checking etc
beside bdds number structures sublanguages negation normal forms nnfs darwiche marquis diagrams mateescu dechter
marinescu finite state automata vempaty amilhastre fargier marquis
extensions decision diagrams drechsler wegener meinel
theobald used compilation targets suitable interactive configuration well particular vempaty suggested compiling constraints
automaton however bdds investigated data structures tool
support unrivaled emerging representations many highly optimized
open source bdd packages e g somenzi lind nielsen allow easy
efficient manipulation bdds contrast publicly available open source compilers
still developed many newer representations particular application bdds
configuration resulted patent approval lichtenberg andersen hulgaard mller
rasmussen establishment spinoff company configit
work motivated decision making scenarios solutions
associated cost function expressing implicitly properties price quality failure probability etc user might prefer one solution another given value
properties natural way user expresses cost preferences configuration
setting bound minimal maximal cost solution willing accept
therefore study calculating weighted valid domains wcvd
eliminate values every valid solution expensive user provided
maximal cost present configurator supports efficient cost bounding wide
class additive cost functions easily implementable scales well
instances previously compiled bdds standard interactive configuration cornerstone reuse robust compilation constraints
bdd extract corresponding multi valued decision diagram mdd
resulting mdd allows us label edges weights utilize efficient shortest path label nodes filter expensive values mdd edges mdd extraction
technique novel labeling edges decision diagram suggested works well
generic interpretation wilson edges decision diagram labeled
elements semiring support algebraic computations relevant probabilistic rea http www configit com



fiinteractive cost configuration decision diagrams

soning optimization etc amilhastre et al suggest labeling edges automaton
reason abut optimal restorations explanations general many knowledge compilation
structures weighted counterparts many captured framework
valued negation normal forms vnnfs fargier marquis structures
utilized probabilistic reasoning diagnosis tasks involving reasoning
real valued rather boolean functions principle used wcvd
queries public tool support weighted variants less available tailored
tasks outside configuration domain
extend support valid domains computation presence
multiple cost functions user often multiple conflicting objectives
satisfied simultaneously traditional approaches multi criteria optimization figueira
greco ehrgott ehrgott gandibleux typically interact user
way unsuitable configuration setting cost functions combined single
objective interaction step non dominated solutions sampled displayed user user selections adequate aggregation costs performed
next interaction step suggest configuration oriented interaction domains bounded respect multiple costs prove
particularly challenging computing valid domains mdd presence
two cost functions wcvd np hard even simplest extension linear inequalities
positive coefficients boolean variables despite negative provide
implementation wcvd queries pseudo polynomial time space develop
fully polynomial time approximation scheme fptas prove pseudo polynomial
hence fully polynomial approximation scheme exists computing domains presence arbitrarily many cost functions since np hard
strong sense finally demonstrate experimental evaluation applicability wcvd wcvd query large real world configuration
product catalogue datasets best knowledge present first interactive configurator supporting configuration wrt cost restrictions backtrack free
complete manner constitutes novel addition existing product configuration
approaches well approaches within multi criteria decision making figueira et al

remainder organized follows section describe background
work notation section describe implementing wcvd query
mdd section compile mdd section discuss
configuring presence multiple costs section present empirical evaluation
section describe related work finally conclude section

preliminaries
briefly review important concepts background
constraint satisfaction
constraint satisfaction csps form framework modeling solving combinatorial solution formulated assignment


fiandersen hadzic pisinger

variables satisfy certain constraints standard form csp involves finite
number variables defined finite domains
definition csp constraint satisfaction csp triple x f
x set variables x xn dn cartesian product finite
domains dn f f fm set constraints defined variables x
constraint f function defined subset variables xf x called scope
f maps assignment xf variables indicates f
satisfied indicates f violated assignment solution assignment
variables x satisfies constraints simultaneously
formally assignment values variables x xn denoted set
pairs x xn domain assignment dom set
variables assigned dom xi di xi variables
assigned e dom x refer total assignment say total
assignment valid satisfies rules denoted f partial
assignment dom x valid extended total assignment
valid f define solution space sol set valid total assignments
e sol f dom x
interactive configuration
interactive configuration important application domain user assisted
specifying valid configuration product service something else interactively
providing feedback valid options unspecified attributes arises
number domains example buying product user specify number
product attributes attribute combinations might feasible guidance
provided user might reach dead end interacting system
forced backtrack might seriously decrease user satisfaction
many cases valid configurations implicitly described specifying restrictions
combining product attributes use csp model represent restrictions
csp solution corresponds valid configuration configurable attribute
represented variable attribute option corresponds value
variable domain example illustrate simple configuration csp
model
example specify shirt choose color black white red blue
size small medium large print men black mib save
whales stw choose mib print color black chosen well
choose small size stw print including large picture whale
cannot selected picture whale fit small shirt configuration
x f shirt example consists variables x x x x representing
color size print variable domains black white red blue
small medium large mib stw two rules translate
f f f f x x mib black f x x
small stw possible assignments eleven
assignments valid configurations form solution space shown fig


fiinteractive cost configuration decision diagrams

black small mib
black medium mib
black medium stw
black large mib

black large stw
white medium stw
white large stw
red medium stw

red large stw
blue medium stw
blue large stw

figure solution space shirt example
fundamental task concerned calculating valid
domains cvd query partial assignment representing previously made user assignments configurator calculates displays valid domain vd di
unassigned variable xi x dom domain valid contains
values extended total valid assignment example
user selects small shirt x valid domains restricted mib print
v black color v
definition cvd given csp model x f given partial assignment compute valid domains
vdi di f xi
task main interest since delivers important interaction requirements backtrackfreeness user never forced backtrack completeness valid configurations
reachable hadzic et al queries relevant supporting
user interaction explanations restorations failure recommendations
relevant products etc cvd essential operation mode interaction
primary importance
decision diagrams
decision diagrams form family rooted directed acyclic graphs dags node
u labeled variable xi outgoing edges e labeled value di
node may one outgoing edge label decision diagram
contains one terminal nodes labeled constant outgoing
edges well known member family binary decision diagrams bdds
bryant used manipulating boolean functions many areas
verification model checking vlsi design meinel theobald wegener
drechsler etc primarily operate following variant
multi valued decision diagrams
definition mdd mdd denoted rooted directed acyclic graph v e
v set vertices containing special terminal vertex root r v
var v n labeling nodes variable index var
n edge e e denoted triple u u start node u end node u
associated value
work ordered mdds total ordering variables assumed
edges u u var u var u convenience assume variables


fiandersen hadzic pisinger

x ordered according indices ordered mdds considered
arranged n layers vertices layer labeled variable index
denote vi set nodes labeled xi vi u v var u similarly
denote ei set edges originating vi e ei e u u e
var u unless otherwise specified assume path root
terminal every variable labels exactly one node
mdd encodes csp solution set sol dn defined variables
x xn check whether assignment dn sol
traverse root every node u labeled variable xi follow edge
labeled ai edge solution e sol otherwise
traversal eventually ends terminal sol denote p u
u
path mdd u u edges u u sometimes denoted
e u u value edge e u u sometimes denoted v e
make distinction paths assignments hence set solutions represented
mdd sol p p r
fact every node u vi associated
subset solutions sol u p p u
di dn
x




x

x



x





x



x









x






x

x





x

x

x

x









x






x


x


x

x





x


x




mdd merging

b merged mdd

figure uncompressed merged mdd shirt example
decision diagrams exponentially smaller size solution set
encode merging isomorphic subgraphs two nodes u u isomorphic encode
solution set sol u sol u figure fully expanded mdd
equivalent merged mdd b shirt solution space addition merging
isomorphic subgraphs another compression rule usually utilized removing redundant
nodes node u vi redundant di outgoing edges pointing
node u nodes eliminated redirecting incoming edges u u deleting u
v introduces long edges skip layers edge e u u long var u
var u case e encodes set solutions dvar u dvar u
refer mdd merging isomorphic nodes removal redundant
nodes taken place reduced mdd constitutes multi valued generalization
bdds typically reduced ordered reduced mdd shirt csp
shown figure unless emphasized otherwise mdd
assume ordered merged reduced mdd since exposition simpler removal
redundant nodes linear effect size given variable ordering


fiinteractive cost configuration decision diagrams

unique merged mdd given csp x f solution set sol
size mdd depends critically ordering could vary exponentially grow
exponentially number variables practice many interesting
size surprisingly small
x

x


x


x






x




figure reduced mdd shirt example
interactive configuration decision diagrams particularly attractive property decision diagrams support efficient execution number important
queries checking consistency validity equivalence counting optimization etc
utilized number application domains description
known offline diagnosis verification etc particular calculating valid domains linear
size mdd since calculating valid domains np hard size
input csp model possible guarantee interactive response real time
fact unacceptably long worst case response times empirically observed
purely search computing valid domains subbarayan et al
therefore compiling csp solutions line prior user interaction decision
diagram efficiently size mdd compute valid domains online
interaction user important note order user decides
variables completely unconstrained e depend ordering mdd variables previous work utilized binary decision diagrams bdds represent
valid configurations cvd queries executed efficiently hadzic et al
course bdds might exponentially large input csp many classes
constraints surprisingly compact

interactive cost processing mdds
main motivation work extending interactive configuration
mller et al hadzic et al subbarayan et al situations
addition csp model x f involving hard constraints cost
function
c dn r
product configuration setting could product price uncertainty setting
cost function might indicate probability occurrence event represented


fiandersen hadzic pisinger

solution failure hardware component withdrawal bid auction etc
decision support context cost function might indicate user preferences
number cost related queries user might interested e g finding optimal
solution computing probable explanation however assume user
interested tight control variable values well cost selected solutions
example user might desire specific option xi would care
would assignment affect cost remaining optimal solutions
communicate information user allow strike right balance
cost variable values allowing interactively limit maximal cost
product addition assigning variable values therefore primarily
concerned implementing weighted cvd wcvd query user specified maximum
cost k indicate values unassigned variable domains extended
total assignment valid costs less k assume
user interested bounding maximal cost limiting minimal cost symmetric
definition wcvd given csp model x f cost function c r
maximal cost k given partial assignment weighted cvd wcvd query requires
computation valid domains
vdi k di f xi c k
section assume mdd representation csp solutions already
generated offline compilation step postpone discussion mdd compilation
section discuss delivering efficient online interaction top mdd
first discuss practicability implementing wcvd queries explicit encoding
costs mdd provide practical efficient implementing
wcvd mdd cost function additive finally discuss
extensions handling expressive cost functions
handling costs explicitly
immediate interactively handling cost function treat cost
solution attribute e add variable variables x add constraint
c x xn



formulas f enforce equal total cost resulting configuration model
compiled mdd user able bound cost restricting domain

assuming variable ordering x xn original csp model x f
assuming inserted cost variable th position variable set x
variable ordering x x n x x x xi x x
xi x n xn domain di variable x set feasible costs c sol
c sol demonstrate mdd may exponentially larger

lemma ei c sol


fiinteractive cost configuration decision diagrams

proof th layer mdd corresponding variable cost c c sol
must least one path p r
c p c path edge e ei
th layer must labeled v e c hence cost must least
one edge ei proves lemma

furthermore least one layers nodes vi vi
number nodes greater
p
ei follows following lemma
e
lemma th layer mdd vi vi


pairs nodes u u v v statement
proof since vi vi



follows fact pair u u one edge e u u
namely every solution p formed concatenating paths p r
u p u

unique cost c p however two edges e e u u would
different values v e v e solution c p would correspond
two different costs v e v e

considerations see whenever range possible costs c sol
exponential resulting mdd would exponentially large well would
significantly increased size v v particularly large number
isomorphic nodes would become non isomorphic variable introduced
since root paths different costs extreme instance behavior
presented example furthermore even c sol large could orders
magnitude increase size due breaking isomorphic nodes mdd
empirically demonstrated section table number configuration
instances major disadvantage otherwise efficient cvd become
unusable since operate significantly larger structure
example consider model c x f constraints f boolean variables dj j n solution space includes assignments sol
dn corresponding mdd v e one vertex two
layer
pnedgesj
xj
v n e n use cost function c x xn j
exponential number feasible costs c sol n hence ei n
greater
th layer corresponding variable least one layers vi vi

n
n
however significant node isomorphism adding variable
necessarily lead significant increase size extreme instance mdd
isomorphic nodes example every edge labeled unique value
mdd number non terminal nodes n sol adding cost variable
resulting mdd would add one node per path leading mdd
n sol nodes translates minor increase size v v n n
property empirically demonstrated section table product catalogue
datasets remainder develop techniques tailored instances
large increase size occurs avoid explicit cost encoding aim exploit
structure cost function implement wcvd


fiandersen hadzic pisinger

processing additive cost functions
one main contributions practical efficient deliver
wcvd queries cost function additive additive cost function form
c x xn

n
x

ci xi



cost ci ai r assigned every variable xi every value domain
ai di
additive functions one important frequently used modeling constructs number important combinatorial modeled integer linear programs often constraints objective function linear e represent
special cases additive cost functions multi attribute utility theory user preferences
certain assumptions aggregated single additive function weighted
summation utilities individual attributes product configuration context many
properties additive memory capacity computer total weight
particular experience commercially applying configuration technology
price product often modeled weighted sum prices individual parts
labeling
assuming given mdd representation solution space sol cost
function c answering wcvd queries three steps restricting
mdd wrt latest user assignment labeling remaining nodes executing shortest
path filtering expensive values node labels
restricting mdd given user assignment xi ai xi
unassigned variables regardless position mdd variable ordering initialize
mdd pruning removing edges e u u agreement latest
assignment e var u ai might cause number edges
nodes become unreachable terminal root removed last edge
set children edges ch u parent edges p u unreachable edge must
removed well pruning repeated fixpoint reached e
nodes edges removed implements scheme v e time
space queue q maintain set edges yet removed
note unassigning user assignment xi ai easily implemented linear
time well suffices restore copy initial mdd perform restriction wrt
partial assignment xi ai current assignment easily
extended purpose initializing edge removal list q edges incompatible
wrt assignments
computing node labels remaining edges e u u layer ei implicitly
labeled c e ci second step compute mdd node u v
upstream cost shortest path root r u denoted u u downstream
cost shortest path u terminal denoted u




x
x
u u min
c e

c e u min
p r

u

p u

ep





ep

fiinteractive cost configuration decision diagrams

restrict mdd
data mdd v e variable xi value ai
foreach e ei v e ai
q push e
q
e u u q pop
delete e
ch u
foreach e u u
q push e
p u
foreach e u u
q push e

computes u u u labels v e time space
update u labels
data mdd v e cost function c

foreach n
foreach u vi
foreach e u u
u min u c e u
u u r
foreach n
foreach u vi
foreach e u u
u u min u u c e u u

computing valid domains upstream downstream costs u computed efficiently compute valid domains vdi wrt maximal cost bound k
since
vdi k v e u u c e u k e u u u vi

achieved linear time traversal v e shown
compute valid domains
data mdd v e cost function c maximal cost k
foreach n
v di
foreach u vi
foreach e u u
u u c e u k
v di v di v e

hence overall interaction follows given current partial assignment mdd
restricted wrt labels u computed
valid domains computed execution


fiandersen hadzic pisinger

requires v e time space hence mdd representation solution
space available interactively enforce additive cost restrictions linear time
space
processing additive costs long edges
scheme extended mdds containing long edges multivalued csp
large domains space savings due long edges might significant
binary binary decision diagrams bdds significant savings possible
furthermore similar fashion scheme might adopted versions
decision diagrams contain long edges different semantics zero suppressed
bdds long edge implies skipped variables assigned
recall reduced mdds redundant nodes u vi di outgoing edges
pointing node u eliminated edge e u u var u
k var u l long k l case e encodes set solutions
dk dl labeling edges generalized accommodate
edges well let domains dj j n represent variable domains updated wrt
current assignment e dj dj xj unassigned dj xj otherwise edge
e u u var u k var u l removed dk analogous way mdd
pruning previous subsection otherwise labeled
c e ck

l
x

j k

min cj

dj



cost cheapest assignment xk xl consistent edge
partial assignment edges labeled upstream downstream costs
u computed v e time manner previous subsection
however computing valid domains extended sufficient condition
vd existence edge e u u originating th layer u vi
v e
u u c e u k

however longer necessary condition even edge satisfying
could exist long edge skipping th layer still allows vd therefore
layer compute cost cheapest path skipping layer
p min u u c e u e u u e var u var u



edge skipping th layer set p let cmin denote cheapest
value di e cmin minadi ci determine long edge allowing
vd unassigned variable xi following must hold
p ci cmin k



finally sufficient necessary condition vd one conditions
holds variable xi assigned value drawn valid domain previous
step guaranteed v di xi calculations necessary labels p


fiinteractive cost configuration decision diagrams

update p labels
data mdd v e cost function c
p
foreach n
foreach u vi
foreach e u u
foreach j var u var u
p j min p j u u c e u

computed worst case e n time note bound
pessimistic assumes every edge e skipping every variable x

auxiliary structures u p computed valid domains efficiently
extracted unassigned variable xi value di valid
domain vdi k iff following holds condition satisfied edge e u u e
condition satisfied non assigned variable first checks
value di whether supported skipping edge p afterwards scans
th layer extracts
p values supported edges ei achieved v e
time ni di
computing valid domains v di
data mdd v e cost function c maximal cost k
foreach n
v di
xi assigned ai
v di ai
continue
foreach di
p ci cmin k
v di v di
foreach u vi
foreach e u u
u u c e u k
v di v di v e

overall interaction remains labels p incrementally updated
worst case e n time valid domains extracted v e time
response changing cost restriction k auxiliary labels need updated valid
domains extracted directly v e time
handling non additive cost functions
certain interaction settings cost function additive example user preferences might depend entire package features rather selection individual
feature similarly price product need simple sum costs individual
parts might depend combinations parts selected general cost


fiandersen hadzic pisinger

function c x xn might sum non unary cost functions ci k
c x xn

k
x

ci xi



cost function ci expresses unique contribution combination features within
subset variables xi x

dj r
ci
jxi

non unary labeling
extended handle non unary costs adopting labeling techniques
used graphical representations e g wilson
mateescu et al
pk
assume given cost function c x xn ci xi let denote
set cost functions cj xi last variable scope cj
cj xi xj xi xj
given assignment ai variables x xi evaluate every function cj
ai scope cj strict subset x xi set cj value
u u
cj xj xj projection onto xj every path p r
vi last edge th layer e ei label e sum cost functions
become completely instantiated assigning xi ai
x
cj p

c e p
cj

respect labeling ap
cost solution represented path p would indeed
sum costs edges ep c e p order apply developed
additive cost functions section edge labeled cost
incoming path however possible general therefore
expand original mdd creating multiple copies e splitting incoming paths
ensure two paths p p sharing copy e edge e induce edge
cost c e p c e p mdd denoted mc generated example
search caching isomorphic nodes suggested wilson extending
standard apply operator handle weights suggested mateescu et al
impact size
increase size mc relatively cost oblivious version depends additivity cost function c example fully additive cost functions scope
xi contains single variable mc since label c e regardless
incoming path however entire cost function c single non additive component
c x global scope x x edges last mdd layer labeled
case explicit cost encoding mdd section must least
c sol edges last layer one feasible cost hence range costs c sol


fiinteractive cost configuration decision diagrams

exponential size mc furthermore even c sol limited size increase mc might significant due breakup node isomorphisms previous layers
case explicit cost encoding section effect demonstrated empirically
section similar effect size would occur graphical representations
example representations exploiting global csp structure weighted cluster trees
pargamin adding non additive cost functions increases size clusters
required non additive component ci xi least one cluster contains
entire scope xi furthermore criteria node merging wilson mateescu
et al refined since nodes longer isomorphic root
set feasible paths paths must cost well
semiring costs probabilistic queries
note generalized accommodate general aggregation costs discussed wilson cost functions ci need map assignments
xi variables set real numbers r set equipped operators
semiring mdd property computed
p r ep c e operator aggregates edge costs operator aggregates path costs
semiring distributes global computation done efficiently local node aggregations much shortest path computed framework
reasoning paths minimal cost corresponds r min
different semirings could used particular taking r
handle probabilistic reasoning cost function ci corresponds conditional probability table cost edge c e e u u ei corresponds probability

q
p xi v e given assignments p r
u cost path c p ep c e
probability event represented path
pfor given value di
get marginal probability p xi computing e u u ei u u c e u

compiling mdds
previous section showed implement cost queries solution space
represented mdd section discuss generate mdds
csp model description x f goal develop efficient easy implement
handle instances handled previously bdd configuration
hadzic et al
variable ordering first step choose ordering csp variables x
critical since different variable orders could lead exponential differences mdd size
well investigated especially binary decision diagrams fixed
formula deciding ordering resulting bdd would
nodes threshold np hard bollig wegener however
well developed heuristics exploit structure input model
use variable swapping existing bdd improve ordering local search manner
meinel theobald example fan weight heuristics popular
input form combinational circuits input csp reasonable heuristic
choose ordering minimizes path width corresponding constraint graph


fiandersen hadzic pisinger

mdd worst case exponential path width bodlaender wilson
mateescu et al investigating heuristics variable ordering scope
work remainder assume ordering already given
experiments use default orderings provided instances
compilation technique first compile csp model binary
decision diagrams bdd exploiting highly optimized stable bdd packages e g
somenzi afterwards extract corresponding mdd dedicated mdd packages
rare provide limited functionality implementations optimized
bdd packages offer competitive performance miller drechsler interesting
recent alternative generate bdds search caching isomorphic nodes
suggested huang darwiche compile bdds cnf
formulas proved valuable addition standard compilation pairwise
bdd conjunctions however compilation technology still early stages
development open source implementation publicly available
bdd encoding
regardless bdd compilation method finite domain csp variables x first
encoded boolean variables choosing proper encoding important since
intermediate bdd might large inadequate subsequent extraction general
csp variable xi would encoded ki boolean variables xi xiki di
mapped bit vector enci aki ki different
values get different vectors enci enci several standard boolean
encodings multi valued variables walsh log encoding scheme xi
encoded ki dlog di e boolean variables representing digit binary notation
multivalued assignment xi translated set assignments xij aj
p j
pki j
xj di added
aj additionally domain constraint kj

j


forbid bit assignments aki encode values outside domain di
direct encoding hot encoding common especially well suited efficient
propagation searching single solution scheme multi valued variable
xi encoded di boolean variables xi xiki variable xij indicates
whether j th value domain aj di assigned variable xi exactly one
value di assigned therefore enforce domain constraint xi xiki
n hadzic hansen osullivan empirically demonstrated
log encoding rather direct encoding yields smaller bdds
sn thei set boolean variables fixed union encoding variables xb
x xki still specify ordering common ordering
well suited efficiently answering configuration queries clustered ordering
boolean variables xi xiki grouped blocks respect ordering among
finite domain variables x xn
xij xij j j
might orderings yield smaller bdds specific classes constraints
bartzis bultan shown linear arithmetic constraints represented


fiinteractive cost configuration decision diagrams

compactly boolean variables xij grouped wrt bit position j rather
finite domain variable xi e xij xij j j j j however
configuration constraints involve linear arithmetic constraints space savings
reported bartzis bultan significant variable domains
size power two furthermore clustered orderings yield bdds
preserve essentially combinatorial structure allows us extract mdds
efficiently seen section
example recall shirt example
log encoding variables x x x x x inducing variable set
xb log bdd clustered variable ordering shown figure

x

x
x



x

x

x

x

x

x


x

x
x

x




x






log bdd



x

b extracted mdd

figure log bdd clustered ordering extracted mdd shirt example bdd draw terminal node terminal node
incoming edges omitted clarity node corresponding boolean
encoding variable xij labeled corresponding csp variable xi edges
labeled drawn dashed full lines respectively

mdd extraction
bdd generated clustered variable ordering extract corresponding
mdd method originally suggested hadzic andersen
subsequently expanded hadzic et al following considerations
use mapping cvar xij denote csp variable xi encoding variable
xij slight abuse notation apply cvar bdd nodes u labeled
xij terminal nodes define cvar cvar n recall bdd two
terminal nodes indicating false true respectively analogously use
mapping pos xij j denote position bit variable encoding
method recognizing subset bdd nodes captures core
mdd structure used directly construct corresponding mdd


fiandersen hadzic pisinger

block bdd layers corresponding csp variable xi li vxi vxi

ki
suffices consider nodes reachable edge previous block
layers
ini u li u u e cvar u cvar u



first layer
sn take r resulting mdd v e contains nodes

ini v ini constructed extraction edge e u u
added e whenever traversing bdd b u wrt encoding ends u
traversals executed starting u step
traverses bdd taking low branch corresponding bit ai high branch
ai traversal takes ki steps terminating soon reaches node
labeled different csp variable mdd extracted log bdd figure
shown figure b

extract mdd
data bdd b v e
e v r
foreach n
foreach u ini
foreach di

u traverse u
u
e e u u
v v u
return v e

traverse bdd
data bdd b v e u
cvar u
aki enci v
repeat
pos u

u low u
else
u high u
cvar u
return u

since traversal linep
takes dlog di e steps running time
mdd extraction
ni ini di dlog di e resulting mdd v e
pn
ini di edges
pnadd di edges every node

u ini since keep nodes ini v ini v
input model implementation details

important factor usability easiness specifying input
csp model bdd packages callable libraries default support csp input
language best knowledge open source bdd compilation tool


fiinteractive cost configuration decision diagrams

accepts input csp model clab jensen configuration interface
top bdd package buddy lind nielsen clab constructs bdd
input constraint conjoins get final bdd furthermore clab generates
bdd log encoding clustered ordering suits well extraction
therefore compilation clab specify input model
generate bdd used extraction
note extracting mdd preprocess efficient online querying
expand long edges merge isomorphic nodes get merged mdd
translate efficient form online processing rename bdd node names
indexes v root index terminal index v
allows subsequent efficient implementation u labels well efficient
access children parent edges node initial experiments got order
magnitude speed wcvd queries switched bdd node names
required less efficient mapping u ch p structures

interactive configuration multiple costs
number domains user configure presence multiple cost functions
express often conflicting objectives user wants achieve simultaneously
example configuring product user wants minimize price maximizing quality reducing ecological impact shortening delivery time etc assume
therefore addition csp model x f whose solution space represented
merged mdd given k additive cost functions
ci x xn

n
x

cij xi k

j

expressing multiple objectives multi cost scenarios often considered within multicriteria optimization framework figueira et al ehrgott gandibleux
usually assumed optimal unknown way aggregate multiple
objectives single objective function would lead solution achieves
best balance satisfying objectives sample efficient solutions
nondominated wrt objective criteria display user user input
learn aggregate objectives adequately used
next sampling efficient solutions etc approaches user asked explicitly
assign
pkweights wi objectives ci aggregated weighted summation
c wi ci
adopting techniques run compiled representation solution space
would immediately improve complexity guarantees would useful many scenarios multi criteria techniques traditionally used believe configuration
setting explicit control variable values needed user easily explore
effect assigning variable values variables well cost functions
therefore suggest directly extend wcvd query user could explore
effect cost restrictions way explores interactions regular variables key query want deliver computing valid domains wrt multiple cost
restrictions


fiandersen hadzic pisinger

definition k wcvd given csp model x f additive cost functions cj r
maximal costs kj j k given partial assignment compute
vd kj kj di f xi

k


j

cj kj

particularly interested two cost configuration likely occur
practice strong connections existing solving knapsack
multi criteria optimization reminder section first discuss
complexity wcvd queries develop practical implementation
discuss general k wcvd query
complexity wcvd query
assume input merged mdd additive cost
functions c c cost bounds k k first question whether possible
restricted forms additive cost functions c c implement wcvd polynomial
time purpose formulate decision version wcvd
wcvd sat given csp x f mdd
pnm representation solution space given two additive cost functions ci x j cij xj cost
restrictions k k decide whether f c x k c x k satisfiable
unfortunately answer even constraints involve positive coefficients
binary domains reduce well known two partition
tpp np hard garey johnson given set positive
integers sn tpp asks decide whether possible split set
indexes
p n two sets sum set
p

ii si
ia

proposition wcvd sat defined boolean variables involving
linear cost functions positive coefficients np hard

proof stated reduction tpp order reduce tpp two cost
configuration introduce n binary variables x x n
x x construct mdd f
x x p
x n x n introduce
p two linear cost functions positive coefficients
c x ni si p
x c x ni si x overall capacity constraints set
k k
ii si setting x easily seen
f c x k c x k satisfiable tpp feasible solution
hence able solve wcvd sat boolean variables positive linear cost
functions polynomial time would able solve tpp polynomially
pseudo polynomial scheme wcvd
previous subsection demonstrated answering wcvd queries np hard even
simplest class positive linear cost functions boolean domains hence


fiinteractive cost configuration decision diagrams

hope solving wcvd guaranteed polynomial execution time unless p n p
however still want provide practical solution wcvd hope
avoid worst case performance exploiting specific nature cost functions
processing subsection therefore wcvd solved pseudopolynomial time extending labeling section furthermore
adopt advanced techniques used knapsack kellerer pferschy
pisinger
overall
runs analogous single cost developed section
restricting mdd wrt current assignment calculate upstream downstream
costs u longer constants lists tuples use check
edge e whether v e valid domain
given edge e u u labeled costs c e c e follows v e v di iff
paths p r
u p u
c p c e c p k

c p c e c p k node u suffices store two sets labels
u u c p c p p r

u

u c p c p p u



given cost restrictions k k edge e u u u vi domain v di k k
contains v e u u b b u holds
c e b k c e b k



exploiting pareto optimality
single cost case sufficient store u u u minimal value
cost shortest path root terminal multi cost case need store multiple
tuples immediate extension would require storing k k tuples node
however need store non dominated tuples u lists two
tuples list

may delete test succeeds succeed
remaining entries costs pareto optimal solutions solution pareto optimal
wrt solution set cost functions c c possible cheaper solution
respect one cost without increasing path p r
represents
pareto optimal solution sol iff node u path sub paths p r
u
p u
pareto optimal wrt sets paths p r
u p u

respectively hence node u suffices store
u u c p c p p r

u p r

u c p

c p c p c p

u c p c p p u

p u

c p

c p c p c p



fiandersen hadzic pisinger

note due pareto optimality k k
one tuple u first coordinate second
coordinate therefore node u u u u min k k
entries hence space requirements algorithmic scheme worst case v k
k min k k
computing u sets
discuss compute u sets efficiently utilizing advanced
techniques solving knapsack kellerer et al recursively update u
sets layer layer manner shown critical component
recursion step merging lists lines operation
list formed dominated tuples detected eliminated order
efficiently critical keep u lists sorted wrt first coordinate
e

u sorted merged k time list merging
knapsack optimization kellerer et al section
update u labels







data mdd cost functions c c bounds k k
u u r
foreach n
foreach u vi
foreach e u u

foreach u u
c e k c e k
c e c e
u u ergelists u u

foreach n
foreach u vi
foreach e u u

foreach u
c e k c e k
c e c e
u ergelists u

time complexity determined populating list lines merging
lines updates takes k worst case since perform
updates edge e e total time complexity e k
worst case


fiinteractive cost configuration decision diagrams

valid domains computation
u sets updated extract valid domains straightforward manner
edge e u u evaluates whether v e v di
worst case u u u k steps hence valid domain extraction takes worst
case e k steps
compute valid domains
data mdd cost functions c c cost bounds k k labels u
foreach n
vdi
foreach u vi
foreach e u u
foreach u u b b u
c e b k c e b k
vdi vdi v e
break

however improve running time valid domains computation exploiting
pareto optimality fact sets u sorted critical observe
given edge e u u u u suffices perform validity
test tuple b b u b maximal first coordinate satisfying
c e b k e
b max b b b u c e b k

namely test succeeds b b b b succeed b b
since due pareto optimality b b b b hence c e b c e b
k since lists sorted comparing relevant tuples performed efficiently
traversing u u increasing order traversing u decreasing order
implements procedure
extract edge value




data mdd cost constraints c c bounds k k edge e u u ei
u u begin
b b b u end
b
c e b k
b b b u previous
continue
else c e b k c e b k
vdi vdi v e
return
u u next

relies several list operations given list l sorted tuples operations
l begin l end return first last tuple respectively wrt list ordering


fiandersen hadzic pisinger

operations l next l previous return next previous element
list wrt ordering elements indicate two special elements appear
last first element list respectively indicate
passed beyond boundary list terminates line soon
test succeeds otherwise keeps iterating tuples processed
last tuple u u first tuple u case terminates
guaranteed v e v di step traverse least one element
u u u hence total execute u u u k operations
therefore time complexity single edge traversal k complexity valid
domains computation replacing quadratic loop
e k k min k k
conclusion developed pseudo polynomial scheme computing valid domains wrt two cost functions wcvd space complexity dominated storing u
sets node worst case store v k entries time
complexity compute u labels extract valid domains takes e k steps
overall interaction similar single cost assigning variable
recompute labels well extract domains tighten cost restrictions
k k k k k k need extract domains however relax
cost restrictions k k need recompute labels well
precisely labels u need recomputed k k max k max initial
cost restriction last assignment
extensions
note principle extended handle general k wcvd query
fixed k lists u would contain set non dominated k tuples ordered
ak k iff smallest coordinate j aj j holds aj j
list merging well valid domains extraction would directly generalized
operate ordered sets although time complexity testing dominans
increase worst case complexity would depend size efficient frontier
k cost functions cost bounds k bounded k k practice however
could expect number non dominated tuples much smaller especially cost
functions smaller scopes smaller coefficients note
extended accommodate non additive cost functions expanding mdd
accommodate non unary labels fashion discussed section
approximation scheme wcvd
subsection analyze complexity answering wcvd queries approximative
manner e improve running time guarantees settling approximate
solution assume one constraints k fixed second constraint may
exceeded small tolerance k example user might willing tolerate
small increase price long strict quality restrictions met section present
fully polynomial time approximation scheme fptas calculating valid domains
time en fptas satisfy feasible solution
respect original costs fathomed feasible configuration found


fiinteractive cost configuration decision diagrams

use fptas domain restriction satisfy cost constraint within
k finally fptas running time polynomial input
size
order develop fptas use standard scaling technique schuurman
woeginger originally presented ibarra kim given let n
number decision variables set k n determine costs c e
bc e c bounds k dk e perform valid domains computation
label updating domain extraction described section scaled weights
following propositions prove obtained fptas scheme
proposition running time valid domains computation en
proof may assume k k otherwise may interchange two costs
running time becomes

n
en
e k ek ek
k

since n v polynomial input size v e precision
proposition solution feasible respect original costs
feasible respect scaled costs
p
proof assume ep c e k
x
x


x
c e k k e k
c e
bc e c
ep


ep
ep
proposition solution feasible respect scaled costs c e satisfies
original constraints within k
p
proof assume ep c e c
p
p
p
p
ep c e n
ep bc e c
ep c e
ep c e
k n dk e n k n

k n

since k n get
x
c e k n k n k
ep

shows stated

time complexity improved techniques kellerer et al
knapsack interested showing existence
fptas
considerations previous subsections fully analyzed complexity
answering wcvd queries first showed np hard
developed pseudo polynomial scheme solving finally devised fully polynomial time approximation scheme even though cannot provide polynomial running time
guarantees considerations hope provide reasonable performance
practical instances demonstrated section


fiandersen hadzic pisinger

complexity k wcvd query
conclude section discussing complexity general k wcvd queries
practical implementation efforts focused implementing wcvd queries wcvd
queries number cost constraints known advance completeness
consider generic delivering k wcvd arbitrary k e k part
input
prove pseudo polynomial scheme unless
np p decision version k wcvd sat np hard
strong sense garey johnson reduction bin packing bpp
strongly np hard garey johnson decision form bpp asks
whether given set numbers sn placed k bins size k notice
cannot use reduction showing np hardness wcvd sat since k
part input bpp
theorem k wcvd sat variable k strongly np hard
proof given instance bpp reduce k wcvd sat instance follows
construct mdd csp x f n variables x x xn
domain size k di k n set f resulting mdd
allows assignments n nonterminal nodes u un corresponding numbers
sn two nodes ui ui k edges costs c e c e ck e
set
si si si si
first node u root u r last node un connected terminal
un overall capacity constraints k kk k k
easily seen may path r bpp
feasible solution since bpp strongly np hard shown k wcvd sat
strongly np hard

experimental evaluation
implemented compilation scheme wcvd wcvd queries
performed number experiments evaluate applicability
well confirm hypotheses made throughout used two sets
instances whose properties presented table first set corresponds real world
configuration available configuration benchmarks library clib csp
configuration constraints correspond highly structured configuration
huge number similar solutions second set instances represents
product catalogue datasets used nicholson bridge wilson catalogues
defined explicitly tables solutions represent much smaller sparser set
solutions
http www itu dk cla externals clib



fiinteractive cost configuration decision diagrams

instance
esvs
fs
bike
pc
pc
big pc
renault
travel
laptops
cameras
lettings

sol












x












dmin












dmax












davg












table first seven instances real world configuration available configuration benchmarks library clib remaining four instances product catalogues
used nicholson et al instance provide number solutions sol number variables x minimal maximal average domain
size

mdd size
first set experiments instance generated log encoded bdd b
clab jensen extracted corresponding mdd b finally
expanded long edges merged isomorphic nodes generate merged mdd
compare sizes b table structure provide number
nodes v edges e provide size bdd b conclude
table bdds mdds exponentially smaller size solution
space configuration instances significantly smaller diverse product
configuration catalogues furthermore see number edges merged
mdds significantly larger comparison extracted mdds hence due
simpler online merged mdds seems well suited online reasoning
see multi valued encoding many cases reduces number nodes
edges comparison bdds even though compilation times less important since
generation mdd performed offline worth noting largest instance
renault took around min sec compile instance bdd extract
mdd
encoding cost explicitly
investigated impact encoding cost information explicitly mdd
instance compared size mdd without cost variables
c respectively configuration
benchmarks introduce additional variable
p
ni ai xi coefficients ai randomly drawn
interval put variable last ordering since positions
get mdds similar size putting end allows easier theoretical analysis since


fiandersen hadzic pisinger

instance
esvs
fs
bike
pc
pc
big pc
renault
travel
laptops
cameras
lettings

vb












eb












kb












vm












em












vm












em












table comparison bdds mdds instances table second
third fourth column give number non terminal bdd nodes vb
number edges eb size disk bdd kilobytes kb fifth
sixth column give number vertices vm edges em mdd
extracted bdd page final two columns
provide number nodes edges merged mdd long
edges extracted mdd expanded

product catalogues already contain cost variable price produce cost oblivious
version existentially quantifying c
table compare mdds c structures provide number
edges well representation size kilobytes size cost range
c sol observe configuration instances high level sharing
compression introducing cost information explicitly induces order magnitude increase
size even cost range c sol limited times increase bike instance
mdds two largest instances could generated however product catalogues
much less sharing removing cost information dramatic effect
worst case number edges c two times larger hence
experimental confirm introducing cost explicitly could dramatic effect
mdd representations highly compressed solution spaces usually implicitly defined
conjunction combinatorial constraints however effect adding explicit cost
information might modest solution space defined explicitly sparse list
database entries case product catalogues furthermore size
cost range c sol needs significant large increase size take place
response times wcvd queries
second set experiments evaluated performance wcvd queries merged
mdd representations configuration instances report running times
computing u labels well computing valid domains
table report average worst case running times initial merged mdds


fiinteractive cost configuration decision diagrams

instance
esvs
fs
bike
pc
pc
big pc
renault
travel
laptops
cameras
lettings

e












kb












ec










kb










c sol










table effect explicitly encoding cost information second third column indicate number edges representation size kilobytes cost oblivious
mdd fourth fifth column mdd containing
cost information column c sol indicates range available costs
solutions

table report time necessary restrict mdd wrt assignment
randomly create additive cost function c assigning variable
xi value di cost ci valid domains computed wrt
maximal cost restriction k set value larger length longest
mdd path wrt cost function c ensures longest execution time
data point table average maximum executions fedora
operating system dual quad core intel xeon processor running ghz
one core used instance empirical evaluation demonstrates response times
easily within acceptable interaction bounds even largest instances worst
case mdd nodes labeled within seconds valid domains computed within
seconds mdd restricted wrt assignment within seconds
response times wcvd query
generated analogous statistics wcvd table tested performance
computationally demanding circumstances operate
original fully sized mdd even though interaction would reduced due
user assignments furthermore cost functions c c global scope
use cost restrictions computing u labels e ignore condition
line hence u r correspond entire efficient frontier
normally cost functions would involve subset variables fraction
labels efficient frontier within restrictions k k would relevant user
generate cost functions c c drawing costs ci randomly computing
valid domains use restrictions k k larger lengths corresponding longest


fiandersen hadzic pisinger

instance
esvs
fs
bike
pc
pc
big pc
renault

labeling u
avg
max















valid domain
avg
max















restrict
avg
max








table interaction time seconds wcvd queries report time required computing u labels valid domain computation restriction wrt single
assignment

paths possible solutions efficient frontier allowed would lead
longest execution time
easily handle first five instances largest two instances
u labels known calculating valid domains done within fraction
second hence user efficiently explore effect cost restrictions k k wrt
fixed partial assignment user assigns variable recomputing u labels
takes total average less seconds worst case less seconds
already within acceptable interaction times usability system
enhanced e g layered display information reacting
information fastest compute cvd wcvd user analyzing
execute time consuming operations particular entire efficient frontier
known soon u labels generated worst case within seconds
stage user explore cost space labels computed average within
next seconds note running times reduced number
additional schemes e g computing u labels parallel two processors
present

instance
esvs
fs
bike
pc
pc
big pc
renault

labeling u
avg
max








labeling
avg
max








valid domain
avg
max















table interaction time seconds wcvd query



fiinteractive cost configuration decision diagrams

empirical evaluation demonstrates practical value even
np hard wcvd query implemented response times suitable interactive use
applied huge configuration instances note however order achieve
performance critical optimize mdd implementation well utilize advanced
list operation techniques initial implementation efforts failed led
response times measured tens seconds largest instances

related work
several directions related work large variety representations
investigated area knowledge compilation might suitable supporting
interactive decision making cost restrictions number approaches
handle multiple cost functions multi criteria optimization
compiled knowledge representation forms
used binary decision diagrams bdds multi valued decision diagrams
mdds compiled representations csp model however might compiled representations might suitable supporting interactive configuration
compiled representation supports efficient consistency checking conditioning
would theory support polytime interactive configuration calculate valid domains
suffices value restrict representation check consistent representation supports efficient optimization conditioning would support polytime
cost restrictions would suffice restrict representation value check
minimum smaller threshold value therefore briefly survey
related compiled representations evaluate suitability framework
knowledge compilation structures probably well known framework
comparing compiled forms propositional theories viewing
special classes negation normal form nnf languages darwiche marquis
nnfs directed acyclic graphs internal nodes associated conjunctions
disjunctions leaf nodes labeled literals x x constants true
false imposing restrictions get subclasses nnf languages support
efficient execution queries transformations restrictive representations
less succinct e exponentially larger instances support
larger number queries transformations polytime comprehensive overview
representations presented darwiche marquis
critical restriction makes nnf languages tractable decomposability
exploits variable independencies enforcing children node nonoverlapping
variable scopes hence propositional formula f f f
var f var f evaluate satisfiability f suffices independently evaluate
f f resulting language decomposable negation normal form dnnf
already supports polytime two operations critical calculating valid domains consistency checking conditioning however general dnnf compiler exists current
compilation exhaustive dpll search caching isomorphic nodes
huang darwiche constructs subsets dnnf satisfy additional property


fiandersen hadzic pisinger

determinism two children node mutually exclusive resulting structure called deterministic decomposable negation normal form dnnf structure
would interesting target cost configuration boolean csp additive
cost functions could efficiently optimized dnnfs multi valued however necessary encode finite domain values way allows
efficient cost processing tool support compiling dnnfs far takes input
cnf formulas unaware extensions allowing direct compilation general
csp
known knowledge representation forms retrieved enforcing additional
properties example enforcing nodes decision nodes
variable encountered path read property get free
bdds fbdds enforcing decision nodes appear wrt fixed ordering get
ordered bdds obdds fact dnnf compiler huang darwiche
specialized compile obdds proved valuable alternative way bdd
compilation
weighted multi valued knowledge compilation structures compiled representations propositional theories valued counterparts many
seen special cases valued nnfs vnnf fargier marquis roughly every
valued counterpart obtained changing semantics nodes logical operators
general operators could arithmetic values
functions represented structures longer r furthermore
functions need defined boolean domains could take finite domain values
general subsets vnnf satisfy decomposability operator distributivity support
efficient optimization fargier marquis could principle used support
cost configuration
construction mdds encoding bdds discussed srinivasan
kam malik brayton amilhastre et al augmented automata vempaty edge weights reason optimal restorations explanations
weighted extensions correspond closely weighted mdds since variant automata
used vempaty equivalent merged mdds hadzic et al however
weights used compute different queries generate mdds widely
available bdd packages vempaty report compilation tools used semiring
labeled decision diagrams sldds wilson label edges unordered mdd
values semiring allow computation number queries relevant reasoning
uncertainty due relaxed ordering sldds succinct weighted
mdds therefore attractive target cost configuration however
proposal seems theoretic seem implemented arithmetic
circuits directed acyclic graphs internal nodes labeled summation
multiplication operators leaf nodes labeled constants variables darwiche
could seen valued extension dnnfs hence succinct
sldds furthermore support efficient optimization coefficients
positive bayesian context support efficient computing probable explanations compilation technology acs directly applicable general csp
used primarily representing bayesian networks compiling dnnfs
tree clustering approaches darwiche context acs might use

fiinteractive cost configuration decision diagrams

ful optimizing non additive objective functions multiplicative coefficients
multi linear functions induced bayesian networks however purely propositional
constraints additive cost function optimized purely propositional
representation form dnnf would adequate furthermore efficient optimization queries acs implicitly assume constants leaf nodes
positive case modeling bayesian networks hold general
cost functions
global structure approaches number techniques tree clustering dechter
pearl variable elimination dechter exploit variable independencies
present globally csp model time space complexity techniques
turn bounded exponentially size important graph connectivity notion
tree width bodlaender techniques geared towards enhancing search single optimal solution adaptive consistency bucket elimination etc
concepts utilized compiling representations solutions
mdds mateescu et al restricted boolean variables subset dnnf
formulas variable labeling respects pseudo tree obtained variable elimination
order due utilization variable independencies nodes succinct mdds therefore attractive compilation target cost configuration
furthermore already extended handle weighted graphical support
bayesian reasoning however publicly available tool support limited allow
processing weighted cvd queries tree driven automata fargier vilarem utilize
tree clustering dechter pearl generate partial variable ordering used
generate automaton tree driven automata equivalent mdds
restricted boolean case represent subset dnnf languages called
strongly ordered decomposable decision graphs ddg fargier marquis
mdds succinct mdds therefore interesting target
cost configuration however tools compiling tree driven automata yet become publicly available far extended handle costs weighted
cluster trees pargamin weighted extension cluster trees used support
interactive configuration preferences however publicly available compilation tool internal company implementation presented clusters
represented explicitly without utilizing compressions local structure decision diagrams compiled representations tree bdds tob subbarayan
directly exploit tree clustering representing cluster bdd however
support conditioning polytime fundamental transformation supporting user
interaction assigning variables however compiled instances
dnnf compilation fails empirical evaluation shows average conditioning
times short
bdd extensions large variety weighted extensions binary decision diagrams represent real valued functions f n r rather boolean functions
f n extensions limited boolean variables adoption
future would consider encoding techniques multi valued variables avoid explosion size support cost processing comprehensive overviews extensions
presented drechsler wegener meinel theobald immediate extension form algebraic decision diagrams adds bahar frohm gaona


fiandersen hadzic pisinger

hachtel macii pardo somenzi known multi terminal bdds mtbdds
essentially bdds multiple terminal nodes one cost value
structure oblivious encoding cost much explicitly encoding
cost variable size grows quickly increase number terminals therefore number bdd extensions introduced labeling edges weights
differ mostly cost operators decomposition types associated nodes edge valued
bdds evbdds lai sastry label every edge additive cost value c e
edge e u u value val u c e val u v e otherwise
val u val u factored evbdds fevbdds tafertshofer pedram introduce multiplicative weights v e value val u c e w e val u
otherwise val u val u affine adds aadds sanner mcallester
introduce additive multiplicative edge weights edge regardless v e
val u c e w e val u every edge shown aadds
special case valued nnfs fargier marquis
orthogonal extension bdds change decomposition type nodes obdds
shannon decomposition fu xi fu xi fu change decomposition
type positive davio pd decomposition fu f xi f negative davio nd decomposition fu f xi f pd decomposition get ordered functional decision
diagrams ofdds kebschull rosenstiel structures incomparable
obdds e might exponentially larger smaller obdds depending
instance however ordered kronecker functional decision diagrams okfdds drechsler
sarabi theobald becker perkowski allow three decomposition types thus generalizing obdds ofdds extending ofdds additive edge weights leads
binary moment diagrams bmds bryant chen adding multiplicative
edge weights leads multiplicative binary moment diagrams bm ds analogously
extending okfdds additive multiplicative edge weights get kronecker binary
moment diagrams kbmds k bm ds respectively drechsler becker ruppertz

unclear whether boolean structures advanced cost labeling schemes
used directly represent multi valued csp cost functions however could
compare generalizations labeling schemes multi valued structures multivalued generalization evbdds would correspond roughly weighted mdds however introducing additive multiplicative weights aadds would correspond
generalization labeling scheme could prove useful labeling multilinear cost functions namely introduction multiplicative weights would
subgraph sharing many nodes would refined accommodate non additive costs however due multiplicative factors obvious
cashing technique computing u directly extended especially
coefficients negative case additive cost functions though schemes
would correspond labeling scheme structures pay price less
efficient operators apply operator larger memory requirements maintain information therefore compiling boolean functions structures
would pose unnecessary overhead comparison obdds hence
large number propositional configuration constraints additive cost function
would gain compiling structures even boolean case


fiinteractive cost configuration decision diagrams

cost function non additive introducing elaborate cost representations might
prove beneficial reducing memory requirements might make label computing
technique unapplicable practical point view implementations
supporting boolean versions structures aware tool supporting
multi valued generalizations structures input language format used
specifying general propositional constraints
multi objective cost processing
multiple cost configuration close approaches within framework multi criteria
optimization decision maker solution subject multiple often conflicting objectives figueira et al ehrgott gandibleux particular
mdd close approaches solving multiobjective shortest
path given graph v e arc labeled multiple costs
goal typically compute set pareto optimal efficient non dominated solutions
ehrgott gandibleux muller hannemann weihe tarapata reinhardt pisinger shown multi objective shortest path
intractable particular number pareto optimal solutions grow exponentially number vertices v fptas fully polynomial time approximation
scheme developed approximating set pareto optimal solutions however way solution space multi criteria optimization explored
significantly different typically interaction step subset
pareto optimal solutions computed afterwards decision maker interactively navigates set order reach satisfying compromising solution interactive
methods multi criteria optimization usually compute subset solutions efficient
frontier suggest user evaluation input compute set
solutions figueira et al chapter techniques would use user input
better estimate way aggregate multiple objectives would require
user explicitly assign weights importance objectives contrast instead primarily driven costs solutions interactive supports reasoning
variable assignments solutions valid domains computation inherently different way exploring solution space adequate
users want explicit control variable assignments indicating
importance cost functions
approaches csp community model preferences soft constraints
meseguer rossi shiex partially satisfied violated goal
satisfying least violating solution usually presupposes preferences aggregated via algebraic operators related single cost
optimization however rollon larrosa deals
multiple costs explicitly utilizes global structure e variable independencies
weighted csp model compute efficient frontier bucket variable elimination highly related utilizes global structure generalized additive
independence gai network presented dubus gonzales perny order
compute efficient frontier authors use message passing computation mechanism analogous computing buckets addition authors develop fully


fiandersen hadzic pisinger

polynomial approximation scheme approximate efficient frontier demonstrate
significant improvement performance however neither methods exploit
fact solution space hard constraints available compiled representation
instead methods operate unprocessed model specification whether
weighted csp gai network treating hard soft constraints uniformly
hence allowing scope hard constraints decrease variable independencies
model thus decrease performance furthermore
computation methods allow full exploration efficient solutions
value frontier single supporting efficient solution maintained
maintain efficient value set supporting efficient solutions hence
possible efficiently retrieve valid domains even terminate would
interesting see however whether methods could adopted work mdd
representations solution space
knapsack constraints special case two cost configuration universally true mdd trick used dynamic programming propagate knapsack constraints csp search fahle sellmann presented approximated filtering
integer programming bounds knapsack sellmann presented fully polynomial time approximation approximated
filtering however techniques considered constraint propagation context
none considered processing existing mdd structure

conclusions future work
presented extension bdd interactive configuration configuring presence cost restrictions guarantee polynomial time cost configuration
cost function additive feasible solutions represented multi valued
decision diagram process cost restrictions mdd extracted
underlying bdd therefore strictly extend bdd configuration hadzic et al
support cost bounding additive cost functions without incurring exponential
increase complexity implementation delivers running times easily satisfy interactive response time requirements furthermore extended support
bounding presence non additive semiring costs
extended considering cost bounding wrt multiple costs
proved np hard input mdd size even processing
two linear inequalities positive coefficients boolean variables however
provided pseudo polynomial scheme fully polynomial approximation scheme twocost configuration principle extended k cost configuration
fixed k empirical evaluation demonstrated despite inherent hardness
still provide satisfying performance interactive setting interaction
computing valid domains wrt multiple cost restrictions novel addition
interaction modes within multiple criteria decision making figueira et al
provide explicit control variable assignments well cost functions
future plan investigate compiled representations delivering
cost configuration might efficient investigate practical approaches processing
non unary cost functions particular plan examine whether existing methods


fiinteractive cost configuration decision diagrams

multiobjective non unary optimization e g rollon larrosa dubus et al
adopted operate mdd representation solution space

acknowledgments
would thank anonymous reviewers extensive comments helped
us improve would thank erik van der meer providing
shirt example first version created tarik hadzic
university copenhagen updated version made cork constraint
computation centre support ircset embark initiative postdoctoral fellowship scheme

references
amilhastre j fargier h marquis p consistency restoration explanations
dynamic csps application configuration artificial intelligence

bahar r frohm e gaona c hachtel e macii pardo somenzi f
algebraic decision diagrams applications ieee acm international conference cad pp
bartzis c bultan construction efficient bdds bounded arithmetic
constraints garavel h hatcliff j eds tacas vol lecture notes
computer science pp springer
bodlaender h l tourist guide treewidth acta cybernetica
bollig b wegener improving variable ordering obdds np complete
computers ieee transactions
bryant r e graph boolean function manipulation ieee
transactions computers
bryant r e chen verification arithmetic circuits binary
moment diagrams proceedings nd acm ieee design automation
conference pp
darwiche marquis p knowledge compilation map journal artificial
intelligence
darwiche logical factoring belief networks fensel
giunchiglia f mcguinness williams eds kr principles
knowledge representation reasoning pp san francisco california
morgan kaufmann
darwiche differential inference bayesian networks journal
acm


fiandersen hadzic pisinger

dechter r bucket elimination unifying framework reasoning artificial
intelligence
dechter r pearl j tree clustering constraint networks artificial intelligence
drechsler r sarabi theobald becker b perkowski efficient
representation manipulation switching functions ordered kronecker
functional decision diagrams dac proceedings st annual conference
design automation pp york ny usa acm
drechsler r binary decision diagrams theory practice international journal
software tools technology transfer sttt
drechsler r becker b ruppertz k bmds data structure
verification edtc proceedings european conference design
test p washington dc usa ieee computer society
dubus j p gonzales c perny p multiobjective optimization gai
boutilier c ed ijcai pp
ehrgott gandibleux x survey annotated bibliography multiobjective combinatorial optimization spektrum
fahle sellmann cost filtering constrained knapsack
annals operations
fargier h marquis p use partially ordered decision graphs
knowledge compilation quantified boolean formulae proceedings aaai
pp
fargier h marquis p valued negation normal form formulas proceedings ijcai pp
fargier h vilarem c compiling csps tree driven automata
interactive solving constraints
figueira j r greco ehrgott multiple criteria decision analysis state
art surveys springer verlag boston dordrecht london
garey r johnson computers intractability guide theory
np completeness w h freeman co
hadzic subbarayan jensen r andersen h r mller j hulgaard h
fast backtrack free product configuration precompiled solution
space representation proceedings peto conference pp dtutryk
hadzic andersen h r bdd polytime cost bounded
interactive configuration proceedings aaai pp


fiinteractive cost configuration decision diagrams

hadzic hansen e r osullivan b automata mdds bdds
constraint satisfaction proceedings ecai workshop inference
methods graphical structures knowledge
huang j darwiche dpll efficient obdd construction
proceedings sat pp
huang j darwiche dpll trace sat knowledge compilation
kaelbling l p saffiotti eds ijcai pp professional book
center
ibarra kim c fast approximation knapsack sum
subset journal acm
jensen r clab c library fast backtrack free interactive product
configuration http www itu dk people rmj clab
kebschull u rosenstiel w efficient graph computation manipulation functional decision diagrams design automation european
event asic design proceedings th european conference
kellerer h pferschy u pisinger knapsack springer berlin
germany
lai sastry edge valued binary decision diagrams multi level hierarchical verification dac proceedings th acm ieee conference
design automation pp los alamitos ca usa ieee computer society
press
lichtenberg j andersen h r hulgaard h mller j rasmussen
method configuring product us patent
lind nielsen j
buddy binary
http sourceforge net projects buddy

decision

diagram

package

mateescu r dechter r marinescu r multi valued decision diagrams aomdds graphical journal artificial intelligence

meinel c theobald data structures vlsi design
springer
meseguer p rossi f shiex soft constraints rossi f van beek
p walsh eds handbook constraint programming foundations artificial intelligence chap pp elsevier science publishers amsterdam
netherlands
miller drechsler r construction multiple valued decision
diagrams proceedings nd international symposium multiple valued
logic ismvl p washington dc usa ieee computer society


fiandersen hadzic pisinger

mller j andersen h r hulgaard h product configuration internet
informs conference information systems technology
muller hannemann weihe k pareto shortest paths often feasible
practice wae proceedings th international workshop
engineering pp london uk springer verlag
nicholson r bridge g wilson n decision diagrams fast flexible
support case retrieval recommendation proceedings eccbr
pp
pargamin b extending cluster tree compilation non boolean variables
product configuration tractable preference configuration
ijcai workshop configuration
reinhardt l b pisinger multi objective multi constrained nonadditive shortest path computers operations submitted
technical report version available http man dtu dk upload institutter
ipl publ publikationer rapport pdf
rollon e larrosa j bucket elimination multiobjective optimization journal heuristics
sanner mcallester affine algebraic decision diagrams aadds
application structured probabilistic inference proceedings ijcai
pp
schuurman p woeginger g j approximation schemes tutorial
moehring r potts c schulz woeginger g wolsey l eds lectures
scheduling forthcoming
sellmann practice approximated consistency knapsack constraints
mcguinness l ferguson g eds aaai pp aaai press
mit press
somenzi f cudd colorado university decision diagram package ftp vlsi
colorado edu pub
srinivasan kam malik brayton r k discrete
function manipulation international conference cad pp
subbarayan jensen r hadzic andersen h r hulgaard h mller j
comparing two implementations complete backtrack free interactive
configurator proceedings cp cspia workshop pp
subbarayan exploiting structures constraint solving ph thesis
university copenhagen copenhagen
tafertshofer p pedram factored edge valued binary decision diagrams
formal methods system design vol pp kluwer


fiinteractive cost configuration decision diagrams

tarapata z selected multicriteria shortest path analysis complexity adaptation standard international journal applied
mathematics computer science
trick dynamic programming consistency propagation
knapsack constraints rd international workshop integration ai
techniques constraint programming combinatorial optimization cpai pp
vempaty n r solving constraint satisfaction finite state automata
proceedings tenth national conference artificial intelligence pp

walsh sat v csp dechter r ed proceedings cp lecture notes
computer science pp
wegener branching programs binary decision diagrams society industrial applied mathematics siam
wilson n decision diagrams computation semiring valuations
proceedings nineteenth international joint conference artificial intelligence
ijcai pp




