Journal Artificial Intelligence Research 37 (2010) 99-139

Submitted 08/09; published 02/10

Interactive Cost Configuration Decision Diagrams
Henrik Reif Andersen

hra@configit.com

Configit A/S
DK-2100 Copenhagen, Denmark

Tarik Hadzic

t.hadzic@4c.ucc.ie

Cork Constraint Computation Centre
University College Cork
Cork, Ireland

David Pisinger

pisinger@man.dtu.dk

DTU Management
Technical University Denmark
DK-2800 Kgs. Lyngby, Denmark

Abstract
many AI domains product configuration, user interactively specify
solution must satisfy set constraints. scenarios, offline compilation
feasible solutions tractable representation important approach delivering efficient backtrack-free user interaction online. particular, binary decision diagrams
(BDDs) successfully used compilation target product service configuration. paper discuss extend BDD-based configuration scenarios
involving cost functions express user preferences.
first show efficient, robust easy implement extension possible
cost function additive, feasible solutions represented using multi-valued decision diagrams (MDDs). discuss effect MDD size cost function
non-additive encoded explicitly MDD. discuss interactive configuration presence multiple cost functions. prove even simplest form,
multiple-cost configuration NP-hard input MDD. However, solving two-cost
configuration develop pseudo-polynomial scheme fully polynomial approximation scheme. applicability approach demonstrated experiments
real-world configuration models product-catalogue datasets. Response times generally within fraction second even large instances.

1. Introduction
Interactively specifying solution must satisfy number combinatorial restrictions
important problem many AI domains related decision making: buying
product online, selling insurance policy setting piece equipment. Solutions
often modeled assignments variables constraints imposed.
assigning variables without sufficient guidance, user might forced backtrack, since
choices made cannot extended way would satisfy
succeeding constraints. improve usability interaction therefore important
indicate user values participate least one remaining solution.
c
2010
AI Access Foundation. rights reserved.

fiAndersen, Hadzic, & Pisinger

user assigning values guaranteed able reach feasible solution
never forced backtrack. refer task computing values
calculating valid domains (CVD). Since computationally challenging (NP-hard)
problem, short execution times important interactive setting,
suggested compile offline (prior user interaction) set feasible solutions
representation form supports efficient execution CVD online interaction.
Mller, Andersen, Hulgaard (2002) Hadzic, Subbarayan, Jensen, Andersen,
Mller, Hulgaard (2004) investigated approach using binary decision diagrams (BDDs) compilation target. BDDs one data-structures investigated
knowledge compilation community preprocess original problem formulations
tractable representations enhance solving subsequent tasks. CVD one
tasks occurring configuration domain. Knowledge compilation successfully applied number areas planning, diagnosis, model checking etc.
Beside BDDs, number structures, various sublanguages negation normal forms (NNFs) (Darwiche & Marquis, 2002), AND/OR diagrams (Mateescu, Dechter, &
Marinescu, 2008), finite state automata (Vempaty, 1992; Amilhastre, Fargier, & Marquis,
2002) various extensions decision diagrams (Drechsler, 2001; Wegener, 2000; Meinel
& Theobald, 1998) used compilation targets. suitable interactive configuration well. particular, Vempaty (1992) suggested compiling constraints
automaton. However, BDDs investigated data structures tool
support unrivaled emerging representations. many highly optimized
open-source BDD packages (e.g., Somenzi, 1996; Lind-Nielsen, 2001) allow easy
efficient manipulation BDDs. contrast, publicly available, open-source compilers
still developed many newer representations. particular, application BDDs
configuration resulted patent approval (Lichtenberg, Andersen, Hulgaard, Mller, &
Rasmussen, 2001) establishment spinoff company Configit A/S1 .
work paper motivated decision making scenarios solutions
associated cost function, expressing implicitly properties price, quality, failure probability etc. user might prefer one solution another given value
properties. natural way user expresses cost preferences configuration
setting bound minimal maximal cost solution willing accept.
therefore study problem calculating weighted valid domains (wCVD),
eliminate values every valid solution expensive user-provided
maximal cost. present configurator supports efficient cost bounding wide
class additive cost functions. approach easily implementable scales well
instances previously compiled BDDs standard interactive configuration. cornerstone approach reuse robust compilation constraints
BDD, extract corresponding multi-valued decision diagram (MDD).
resulting MDD allows us label edges weights utilize efficient shortest path algorithms label nodes filter expensive values MDD edges. MDD extraction
technique novel, labeling edges decision diagram suggested works well.
generic interpretation (Wilson, 2005), edges decision diagram labeled
elements semiring support algebraic computations relevant probabilistic rea1. http://www.configit.com

100

fiInteractive Cost Configuration Decision Diagrams

soning, optimization etc. Amilhastre et al. (2002) suggest labeling edges automaton
reason abut optimal restorations explanations. general, many knowledge compilation
structures weighted counterparts, many captured framework
valued negation normal forms (VNNFs) (Fargier & Marquis, 2007). structures
utilized probabilistic reasoning, diagnosis, tasks involving reasoning
real-valued rather Boolean functions. principle used wCVD
queries, public tool support weighted variants less available tailored
tasks outside configuration domain.
extend approach support valid domains computation presence
multiple cost functions. user often multiple conflicting objectives,
satisfied simultaneously. Traditional approaches multi-criteria optimization (Figueira,
Greco, & Ehrgott, 2005; Ehrgott & Gandibleux, 2000) typically interact user
way unsuitable configuration setting cost functions combined single
objective interaction step non-dominated solutions sampled displayed user. Based user selections adequate aggregation costs performed
next interaction step. suggest configuration-oriented interaction approach domains bounded respect multiple costs. prove
particularly challenging problem. Computing valid domains MDD presence
two cost functions (2-wCVD) NP-hard, even simplest extension linear inequalities
positive coefficients Boolean variables. Despite negative result, provide
implementation 2-wCVD queries pseudo-polynomial time space develop
fully polynomial time approximation scheme (FPTAS). prove pseudo-polynomial
algorithm hence fully polynomial approximation scheme exists computing domains presence arbitrarily many cost functions since NP-hard problem
strong sense. Finally, demonstrate experimental evaluation applicability wCVD 2-wCVD query large real-world configuration models
product-catalogue datasets. best knowledge, present first interactive configurator supporting configuration wrt. cost restrictions backtrack-free
complete manner. constitutes novel addition existing product-configuration
approaches well approaches within multi-criteria decision making (Figueira et al.,
2005).
remainder paper organized follows. Section 2 describe background
work notation. Section 3 describe approach implementing wCVD query
MDD Section 4 show compile MDD. Section 5 discuss
configuring presence multiple costs. Section 6 present empirical evaluation
approach. Section 7 describe related work finally conclude Section 8.

2. Preliminaries
briefly review important concepts background.
2.1 Constraint Satisfaction Problems
Constraint satisfaction problems (CSPs) form framework modeling solving combinatorial problems, solution problem formulated assignment
101

fiAndersen, Hadzic, & Pisinger

variables satisfy certain constraints. standard form, CSP involves finite
number variables, defined finite domains.
Definition 1 (CSP) constraint satisfaction problem (CSP) triple (X, D, F )
X set variables {x1 , . . . , xn }, = D1 . . .Dn Cartesian product finite
domains D1 , . . . , Dn F = {f1 , ..., fm } set constraints defined variables X.
constraint f function defined subset variables Xf X called scope
f . maps assignment Xf variables {0, 1} 1 indicates f
satisfied 0 indicates f violated assignment. solution assignment
variables X satisfies constraints simultaneously.
Formally, assignment values a1 , . . . , variables x1 , . . . , xn denoted set
pairs = {(x1 , a1 ), . . . , (xn , )}. domain assignment dom() set
variables assigned: dom() = {xi | Di .(xi , a) } variables
assigned, i.e. dom() = X, refer total assignment. say total
assignment valid satisfies rules, denoted |= F . partial
assignment , dom() X valid extended total assignment 0
valid 0 |= F . define solution space Sol set valid total assignments,
i.e. Sol = { | |= F, dom() = X}.
2.2 Interactive Configuration
Interactive configuration important application domain user assisted
specifying valid configuration (of product, service something else) interactively
providing feedback valid options unspecified attributes. problem arises
number domains. example, buying product, user specify number
product attributes. attribute combinations might feasible guidance
provided, user might reach dead-end interacting system.
forced backtrack, might seriously decrease user satisfaction.
many cases, valid configurations implicitly described specifying restrictions
combining product attributes. use CSP model represent restrictions,
CSP solution corresponds valid configuration. configurable attribute
represented variable, attribute option corresponds value
variable domain. Example 1 illustrate simple configuration problem CSP
model.
Example 1 specify T-shirt choose color (black, white, red, blue),
size (small, medium, large) print (Men Black - MIB Save
Whales - STW). choose MIB print color black chosen well,
choose small size STW print (including large picture whale)
cannot selected picture whale fit small shirt. configuration
problem (X, D, F ) T-shirt example consists variables X = {x1 , x2 , x3 } representing
color, size print. Variable domains D1 = {0, 1, 2, 3} (black , white, red , blue), D2 =
{0, 1, 2} (small , medium, large), D3 = {0, 1} (MIB , STW ). two rules translate
F = {f1 , f2 }, f1 x3 = 0 x1 = 0 (MIB black ) f2 (x2 = 0 x3 6= 1)
(small STW ). |D1 ||D2 ||D3 | = 24 possible assignments. Eleven
assignments valid configurations form solution space shown Fig. 1.
102

fiInteractive Cost Configuration Decision Diagrams

(black , small , MIB )
(black , medium, MIB )
(black , medium, STW )
(black , large, MIB )

(black , large, STW )
(white, medium, STW )
(white, large, STW )
(red , medium, STW )

(red , large, STW )
(blue, medium, STW )
(blue, large, STW )

Figure 1: Solution space T-shirt example.
fundamental task concerned paper calculating valid
domains (CVD) query. partial assignment representing previously made user assignments, configurator calculates displays valid domain VD [] Di
unassigned variable xi X \ dom(). domain valid contains
values extended total valid assignment 0 . example,
user selects small T-shirt (x2 = 0), valid domains restricted MIB print
V D3 = {0} black color V D1 = {0}.
Definition 2 (CVD) Given CSP model (X, D, F ), given partial assignment compute valid domains:
VDi [] = {a Di | 0 .(0 |= F {(xi , a)} 0 )}
task main interest since delivers important interaction requirements: backtrackfreeness (user never forced backtrack) completeness (all valid configurations
reachable) (Hadzic et al., 2004). queries relevant supporting
user interaction explanations restorations failure, recommendations
relevant products, etc., CVD essential operation mode interaction
primary importance paper.
2.3 Decision Diagrams
Decision diagrams form family rooted directed acyclic graphs (DAGs) node
u labeled variable xi outgoing edges e labeled value Di .
node may one outgoing edge label. decision diagram
contains one terminal nodes, labeled constant outgoing
edges. well known member family binary decision diagrams (BDDs)
(Bryant, 1986) used manipulating Boolean functions many areas,
verification, model checking, VLSI design (Meinel & Theobald, 1998; Wegener, 2000;
Drechsler, 2001) etc. paper primarily operate following variant
multi-valued decision diagrams:
Definition 3 (MDD) MDD denoted rooted directed acyclic graph (V, E),
V set vertices containing special terminal vertex 1 root r V . Further,
var : V {1, . . . , n + 1} labeling nodes variable index var(1) =
n + 1. edge e E denoted triple (u, u0 , a) start node u, end node u0
associated value a.
work ordered MDDs. total ordering < variables assumed
edges (u, u0 , a), var(u) < var(u0 ). convenience assume variables
103

fiAndersen, Hadzic, & Pisinger

X ordered according indices. Ordered MDDs considered
arranged n layers vertices, layer labeled variable index.
denote Vi set nodes labeled xi , Vi = {u V | var(u) = i}. Similarly,
denote Ei set edges originating Vi , i.e. Ei = {e(u, u0 , a) E |
var(u) = i}. Unless otherwise specified, assume path root
terminal, every variable labels exactly one node.
MDD encodes CSP solution set Sol D1 . . . Dn , defined variables
{x1 , . . . , xn }. check whether assignment = (a1 , . . . , ) D1 . . . Dn Sol
traverse root, every node u labeled variable xi , follow edge
labeled ai . edge solution, i.e., 6 Sol. Otherwise,
traversal eventually ends terminal 1 Sol. denote p : u1
u2
path MDD u1 u2 . Also, edges u u0 sometimes denoted
e : u u0 . value edge e(u, u0 , a) sometimes denoted v(e).
make distinction paths assignments. Hence, set solutions represented
MDD Sol = {p | p : r
1}. fact, every node u Vi associated
subset solutions Sol(u) = {p | p : u
1} Di . . . Dn .
x1
0

1

x2
0
x3

1

x3
0

2

1
x3

0

x3

1 0

1

1

1

x1
2

3

0 1

x2

x2

2

1

x3

x3

x3

x3

1

1

1

1

x2
2

1

1

x2
2

x2

0 2 1
x3

x3

2 3

1 2

x3
0 0 1

x3
1

1

(a) MDD merging.

(b) merged MDD.

Figure 2: uncompressed merged MDD T-Shirt example.
Decision diagrams exponentially smaller size solution set
encode merging isomorphic subgraphs. Two nodes u1 , u2 isomorphic encode
solution set Sol(u1 ) = Sol(u2 ). Figure 2 show fully expanded MDD 2(a)
equivalent merged MDD 2(b) T-shirt solution space. addition merging
isomorphic subgraphs, another compression rule usually utilized: removing redundant
nodes. node u Vi redundant Di outgoing edges, pointing
node u0 . nodes eliminated redirecting incoming edges u u0 deleting u
V . introduces long edges skip layers. edge e(u, u0 , a) long var(u)+1 <
var(u0 ). case, e encodes set solutions: {a} Dvar(u)+1 . . . Dvar(u0 )1 .
refer MDD merging isomorphic nodes removal redundant
nodes taken place reduced MDD, constitutes multi-valued generalization
BDDs typically reduced ordered. reduced MDD T-shirt CSP
shown Figure 3. paper, unless emphasized otherwise, MDD always
assume ordered merged reduced MDD, since exposition simpler, removal
redundant nodes linear effect size. Given variable ordering
104

fiInteractive Cost Configuration Decision Diagrams

unique merged MDD given CSP (X, D, F ) solution set Sol.
size MDD depends critically ordering, could vary exponentially. grow
exponentially number variables, practice, many interesting problems
size surprisingly small.
x1
0 1
x2

2 3
x2

0
x3

12
2 1

0

x3
1

1

Figure 3: reduced MDD T-shirt example.
Interactive Configuration Decision Diagrams. particularly attractive property decision diagrams support efficient execution number important
queries, checking consistency, validity, equivalence, counting, optimization etc.
utilized number application domains problem description
known offline (diagnosis, verification,etc.). particular, calculating valid domains linear
size MDD. Since calculating valid domains NP-hard problem size
input CSP model, possible guarantee interactive response real-time.
fact, unacceptably long worst-case response times empirically observed
purely search-based approach computing valid domains (Subbarayan et al., 2004).
Therefore, compiling CSP solutions off-line (prior user interaction) decision
diagram, efficiently (in size MDD) compute valid domains online
interaction user. important note order user decides
variables completely unconstrained, i.e. depend ordering MDD variables. previous work utilized Binary Decision Diagrams (BDDs) represent
valid configurations CVD queries executed efficiently (Hadzic et al., 2004).
course, BDDs might exponentially large input CSP, many classes
constraints surprisingly compact.

3. Interactive Cost Processing MDDs
main motivation work extending interactive configuration approach
Mller et al. (2002), Hadzic et al. (2004), Subbarayan et al. (2004) situations
addition CSP model (X, D, F ) involving hard constraints, cost
function:
c : D1 . . . Dn R.
product configuration setting, could product price. uncertainty setting,
cost function might indicate probability occurrence event represented
105

fiAndersen, Hadzic, & Pisinger

solution (failure hardware component, withdrawal bid auction etc.).
decision support context, cost function might indicate user preferences.
number cost-related queries user might interested, e.g. finding optimal
solution, computing probable explanation. We, however, assume user
interested tight control variable values well cost selected solutions.
example, user might desire specific option xi = a, would care
would assignment affect cost remaining optimal solutions.
communicate information user, allow strike right balance
cost variable values allowing interactively limit maximal cost
product addition assigning variable values. Therefore, paper primarily
concerned implementing weighted CVD (wCVD) query: user-specified maximum
cost K, indicate values unassigned variable domains extended
total assignment valid costs less K. on, assume
user interested bounding maximal cost (limiting minimal cost symmetric).
Definition 4 (wCVD) Given CSP model (X, D, F ), cost function c : R
maximal cost K, given partial assignment weighted CVD (wCVD) query requires
computation valid domains:
VDi [, K] = {a Di | 0 .(0 |= F {(xi , a)} 0 c(0 ) K)}
section assume MDD representation CSP solutions already
generated offline compilation step. postpone discussion MDD compilation
Section 4 discuss delivering efficient online interaction top MDD.
first discuss practicability implementing wCVD queries explicit encoding
costs MDD. provide practical efficient approach implementing
wCVD MDD cost function additive. Finally, discuss
extensions handling expressive cost functions.
3.1 Handling Costs Explicitly
immediate approach interactively handling cost function treat cost
solution attribute, i.e. add variable variables X add constraint
= c(x1 , . . . , xn )

(1)

formulas F enforce equal total cost. resulting configuration model
compiled MDD 0 user able bound cost restricting domain
y.
Assuming variable ordering x1 < . . . < xn original CSP model (X, D, F ),
assuming inserted cost variable i-th position, new variable set X 0
variable ordering x01 < . . . < x0n+1 s.t. x01 = x1 , . . . , x0i1 = xi1 , x0i = x0i+1 =
xi , . . . , x0n+1 = xn . domain Di0 variable x0i set feasible costs C(Sol) =
{c(s) | Sol}. demonstrate MDD 0 may exponentially larger
.
Lemma 1 |Ei0 | |C(Sol)|.
106

fiInteractive Cost Configuration Decision Diagrams

Proof 1 i-th layer MDD 0 corresponding variable y, cost c C(Sol)
must least one path p : r
1 c(p) = c, path, edge e Ei0
i-th layer must labeled v(e) = c. Hence, cost must least
one edge Ei0 . proves lemma.
0
Furthermore, least one layers nodes Vi0 , Vi+1
number nodes greater
p 0
|Ei |. follows following lemma:
0 | |E 0 |.
Lemma 2 i-th layer MDD 0 , |Vi0 | |Vi+1


0 | pairs nodes (u , u ) V 0 V 0 , statement
Proof 2 Since |Vi0 ||Vi+1
1 2
i+1

follows fact pair (u1 , u2 ) one edge e : u1 u2 .
Namely, every solution p3 formed concatenating paths p1 : r
u1 p2 : u2
1
unique cost c(p3 ). However, two edges e1 , e2 : u1 u2 , would
different values v(e1 ) 6= v(e2 ). then, solution c(p3 ) would correspond
two different costs v(e1 ), v(e2 ).

considerations see whenever range possible costs C(Sol)
exponential, resulting MDD 0 would exponentially large well. would
result significantly increased size |V 0 |/|V |, particularly large number
isomorphic nodes would become non-isomorphic variable introduced
(since root paths different costs). extreme instance behavior
presented Example 2. Furthermore, even C(Sol) large, could orders
magnitude increase size 0 due breaking isomorphic nodes MDD
empirically demonstrated Section 6, Table 3, number configuration
instances. major disadvantage otherwise efficient CVD algorithms become
unusable since operate significantly larger structure.
Example 2 Consider model C(X, D, F ) constraints F = {}, Boolean variables Dj = {0, 1}, j = 1 . . . , n. solution space includes assignments Sol = D1
. . . Dn corresponding MDD (V, E) one vertex two
layer,
Pnedgesj1
xj ,
|V | = n + 1, |E| = 2 n. use cost function: c(x1 , . . . , xn ) = j=1 2
exponential number feasible costs C(Sol) = {0, . . . , 2n 1}. Hence, |Ei0 | 2n
0 | greater
i-th layer corresponding variable y, least one layers |Vi0 |, |Vi+1

n/2
2n = 2 .
However, significant node isomorphism , adding variable
necessarily lead significant increase size. extreme instance MDD
isomorphic nodes, example every edge labeled unique value.
MDD, number non-terminal nodes n |Sol|. adding cost variable
y, resulting MDD would add one node per path, leading MDD
(n + 1) |Sol| nodes. translates minor increase size: |V 0 |/|V | = (n + 1)/n.
property empirically demonstrated Section 6, Table 3, product-catalogue
datasets. remainder paper develop techniques tailored instances
large increase size occurs. avoid explicit cost encoding aim exploit
structure cost function implement wCVD.
107

fiAndersen, Hadzic, & Pisinger

3.2 Processing Additive Cost Functions
One main contributions paper practical efficient approach deliver
wCVD queries cost function additive. additive cost function form
c(x1 , . . . , xn ) =

n
X

ci (xi )

i=1

cost ci (ai ) R assigned every variable xi every value domain
ai Di .
Additive functions one important frequently used modeling constructs. number important combinatorial problems modeled integer linear programs often constraints objective function linear, i.e. represent
special cases additive cost functions. multi-attribute utility theory user preferences
certain assumptions aggregated single additive function weighted
summation utilities individual attributes. product configuration context, many
properties additive memory capacity computer total weight.
particular, based experience commercially applying configuration technology,
price product often modeled (weighted) sum prices individual parts.
3.2.1 Labeling Approach
Assuming given MDD representation solution space Sol cost
function c, approach answering wCVD queries based three steps: 1) restricting
MDD wrt. latest user assignment, 2) labeling remaining nodes executing shortest
path algorithms 3) filtering expensive values using node labels.
Restricting MDD. given user assignment xi = ai , xi
unassigned variables, regardless position MDD variable ordering. initialize
MDD pruning removing edges e(u, u0 , a), agreement latest
assignment, i.e. var(u) = 6= ai . might cause number edges
nodes become unreachable terminal root removed last edge
set children edges Ch(u) parent edges P (u0 ). unreachable edge must
removed well. pruning repeated fixpoint reached, i.e.
nodes edges removed. Algorithm 1 implements scheme O(|V | + |E|) time
space using queue Q maintain set edges yet removed.
Note unassigning user assignment xi = ai easily implemented linear
time well. suffices restore copy initial MDD , perform restriction wrt.
partial assignment \ {(xi , ai )} current assignment. Algorithm 1 easily
extended purpose initializing edge removal list Q edges incompatible
wrt. assignments .
Computing Node Labels. Remaining edges e(u, u0 , a) layer Ei implicitly
labeled c(e) = ci (a). second step compute MDD node u V
upstream cost shortest path root r u, denoted U [u], downstream
cost shortest path u terminal 1, denoted D[u]:
(
(
)
)
X
X
U [u] = min
c(e)
(2)
c(e) , D[u] = min
p:r

u

p:u

ep

108

1

ep

fiInteractive Cost Configuration Decision Diagrams

Algorithm 1: Restrict MDD.
Data: MDD (V, E), variable xi , value ai
foreach e Ei , v(e) 6= ai
Q.push(e);
Q 6=
e(u, u0 , a) Q.pop();
delete e ;
Ch(u) =
foreach e : u00 u
Q.push(e);
P (u0 ) =
foreach e : u0 u00
Q.push(e);

Algorithm 2 computes U [u] D[u] labels (|V | + |E|) time space.
Algorithm 2: Update U, labels.
Data: MDD (V, E), Cost function c
D[] = , D[1] = 0;
foreach = n, . . . , 1
foreach u Vi
foreach e : u u0
D[u] = min{D[u], c(e) + D[u0 ]}
U [] = , U [r] = 0;
foreach = 1, . . . , n
foreach u Vi
foreach e : u u0
U [u0 ] = min{U [u0 ], c(e) + U [u]}

Computing Valid Domains. upstream downstream costs U, computed, efficiently compute valid domains VDi wrt. maximal cost bound K
since:
VDi [K] = {v(e) | U [u] + c(e) + D[u0 ] K, e : u u0 , u Vi }
(3)
achieved linear-time traversal (|V | + |E|) shown Algorithm 3.
Algorithm 3: Compute valid domains.
Data: MDD (V, E), Cost function c, Maximal cost K
foreach = 1, . . . , n
V Di = ;
foreach u Vi
foreach e : u u0
U [u] + c[e] + D[u0 ] K
V Di V Di {v(e)};

Hence overall interaction follows. Given current partial assignment , MDD
restricted wrt. Algorithm 1. Labels U, computed Algorithm 2
valid domains computed using Algorithm 3. execution algorithms
109

fiAndersen, Hadzic, & Pisinger

requires (|V | + |E|) time space. Hence, MDD representation solution
space available, interactively enforce additive cost restrictions linear time
space.
3.3 Processing Additive Costs Long Edges
scheme extended MDDs containing long edges. multivalued CSP
models large domains space savings due long edges might significant,
binary models binary decision diagrams (BDDs) significant savings possible.
Furthermore, similar fashion, scheme might adopted versions
decision diagrams contain long edges (with different semantics) zero-suppressed
BDDs long edge implies skipped variables assigned 0.
Recall reduced MDDs, redundant nodes u Vi Di outgoing edges,
pointing node u0 , eliminated. edge e(u, u0 , a) var(u) =
k var(u0 ) = l long k + 1 < l, case, e encodes set solutions:
{a} Dk+1 . . . Dl1 . labeling edges generalized accommodate
edges well. Let domains Dj0 , j = 1, . . . , n represent variable domains updated wrt.
current assignment, i.e. Dj0 = Dj xj unassigned, Dj0 = {[xj ]} otherwise. edge
e(u, u0 , a), (var(u) = k, var(u0 ) = l) removed 6 Dk0 analogous way MDD
pruning previous subsection. Otherwise, labeled
c(e) = ck (a) +

l1
X

j=k+1

min cj (a0 )

a0 Dj0

(4)

cost cheapest assignment xk , . . . , xl1 consistent edge
partial assignment . edges labeled, upstream downstream costs
U, computed (|V | + |E|) time, manner previous subsection.
However, computing valid domains extended. before, sufficient condition
VD existence edge e : u u0 , originating i-th layer u Vi
v(e) =
U [u] + c[e] + D[u0 ] K.
(5)
However, longer necessary condition, even edge satisfying (5),
could exist long edge skipping i-th layer still allows VD . therefore,
layer i, compute cost cheapest path skipping layer:
P [i] = min{U [u] + c(e) + D[u0 ] | e : u u0 E, var(u) < < var(u0 )}

(6)

edge skipping i-th layer, set P [i] = . Let cmin [i] denote cheapest
value Di0 , i.e. cmin [i] = minaDi0 ci (a). determine long edge allowing
VD , unassigned variable xi , following must hold:
P [i] + ci (a) cmin [i] K

(7)

Finally, sufficient necessary condition VD one conditions (5)
(7) holds. variable xi assigned value drawn valid domain previous
step, guaranteed V Di = {[xi ]} calculations necessary. Labels P [i]
110

fiInteractive Cost Configuration Decision Diagrams

Algorithm 4: Update P labels.
Data: MDD (V, E), Cost function c
P [] = ;
foreach = 1, . . . , n
foreach u Vi
foreach e : u u0
foreach j {var(u) + 1, . . . , var(u0 ) 1}
P [j] = min{P [j], U [u] + c(e) + D[u0 ]};

computed Algorithm 4 worst-case O(|E| n) time. Note bound
over-pessimistic assumes every edge |E| skipping every variable X.

auxiliary structures U, D, P computed, valid domains efficiently
extracted using Algorithm 5. unassigned variable xi , value Di valid
domain VDi [K] iff following holds: condition (7) satisfied edge e(u, u0 , a) E
condition (5) satisfied. non-assigned variable i, algorithm first checks
value Di whether supported skipping edge P [i]. Afterwards, scans
i-th layer extracts
P values supported edges Ei . achieved (|D| + |V | + |E|)
time, |D| = ni=1 |Di |.
Algorithm 5: Computing valid domains V Di .
Data: MDD (V, E), cost function C, maximal cost K
foreach = 1, . . . , n
V Di = ;
xi assigned ai
V Di {ai };
continue;
foreach Di
P [i] + ci (a) cmin [i] K
V Di V Di {a};
foreach u Vi
foreach e : u u0
U [u] + c[e] + D[u0 ] K
V Di V Di {v(e)};

Again, overall interaction remains same. Labels P incrementally updated
worst case O(|E| n) time. Valid domains extracted (|D| + |V | + |E|) time.
response changing cost restriction K, auxiliary labels need updated. Valid
domains extracted directly using Algorithm 5 (|D| + |V | + |E|) time.
3.4 Handling Non-Additive Cost Functions
certain interaction settings, cost function additive. example, user preferences might depend entire package features rather selection individual
feature. Similarly, price product need simple sum costs individual
parts, might depend combinations parts selected. general, cost
111

fiAndersen, Hadzic, & Pisinger

function c(x1 , . . . , xn ) might sum non-unary cost functions ci , = 1, . . . , k,
c(x1 , . . . , xn ) =

k
X

ci (Xi )

i=1

cost function ci expresses unique contribution combination features within
subset variables Xi X,

Dj R.
ci :
jXi

3.4.1 Non-Unary Labeling
approach extended handle non-unary costs adopting labeling techniques
used graphical representations (e.g., Wilson,
2005; Mateescu et al.,
Pk
2008). Assume given cost function c(x1 , . . . , xn ) = i=1 ci (Xi ). Let A(i) denote
set cost functions cj xi last variable scope cj :
A(i) = {cj | xi Xj xi0 6 Xj , i0 > i}.
Given assignment a(a1 , . . . , ai ) variables x1 , . . . , xi , evaluate every function cj
Ai . scope cj strict subset {x1 , . . . , xi }, set cj (a) value
u, u
cj (Xj (a)) Xj (a) projection onto Xj . Now, every path p : r
Vi+1 , last edge (in i-th layer) e Ei , label e sum cost functions
become completely instantiated assigning xi = ai :
X
cj (p).
(8)
c(e, p) =
cj A(i)

respect labeling, aP
cost solution represented path p would indeed
sum costs edges: ep c(e, p). order apply approach developed
additive cost functions Section 3.2, edge labeled cost
incoming path. However, possible general. therefore
expand original MDD, creating multiple copies e splitting incoming paths
ensure two paths p1 , p2 sharing copy e0 edge e induce edge
cost c(e0 , p1 ) = c(e0 , p2 ). MDD, denoted Mc , generated using example
search caching isomorphic nodes suggested Wilson (2005), extending
standard apply operator handle weights suggested Mateescu et al. (2008).
3.4.2 Impact Size
increase size Mc relatively cost-oblivious version depends additivity cost function c. example, fully additive cost functions (each scope
Xi contains single variable) Mc = , since label c(e) regardless
incoming path. However, entire cost function c single non-additive component
c1 (X1 ) global scope (X1 = X), edges last MDD layer labeled,
case explicit cost encoding MDD Section 3.1. must least
C(Sol) edges last layer, one feasible cost. Hence, range costs C(Sol)
112

fiInteractive Cost Configuration Decision Diagrams

exponential, size Mc . Furthermore, even C(Sol) limited size, increase Mc might significant due breakup node isomorphisms previous layers.
case explicit cost encoding (Section 3.1) effect demonstrated empirically
Section 6. similar effect size would occur graphical-representations.
example, representations exploiting global CSP structure - weighted cluster trees
(Pargamin, 2003) - adding non-additive cost functions increases size clusters,
required non-additive component ci (Xi ) least one cluster contains
entire scope Xi . Furthermore, criteria node merging Wilson (2005) Mateescu
et al. (2008) refined, since nodes longer isomorphic root
set feasible paths, paths must cost well.
3.4.3 Semiring Costs Probabilistic Queries
Note approach generalized accommodate general aggregation costs discussed Wilson (2005). Cost functions ci need map assignments
Xi variables set real numbers R set equipped operators
, = (A, 0, 1, , ) semiring. MDD property computed
p:r 1 ep c(e). Operator aggregates edge costs operator aggregates path costs.
semiring distributes , global computation done efficiently local node-based aggregations, much shortest path computed. framework based
reasoning paths minimal cost corresponds using = (R+ , 0, 1, min, +)
different semirings could used. particular, taking = (R+ , 0, 1, +, )
handle probabilistic reasoning. cost function ci corresponds conditional probability table, cost edge c(e), e : u u0 Ei corresponds probability

Q
P (xi = v(e)) given assignments p : r
u. cost path c(p) = ep c(e)
probability event represented path,
Pfor given value Di 0can
get marginal probability P (xi = a) computing e(u,u0 ,a)Ei (U [u] c(e) D[u ]).

4. Compiling MDDs
previous section showed implement cost queries solution space
represented MDD. section, discuss generate MDDs
CSP model description (X, D, F ). goal develop efficient easy implement
approach handle instances handled previously BDD-based configuration
(Hadzic et al., 2004).
Variable Ordering. first step choose ordering CSP variables X.
critical since different variable orders could lead exponential differences MDD size.
well investigated problem, especially binary decision diagrams. fixed
formula, deciding ordering resulting BDD would
nodes (for threshold ) NP-hard problem (Bollig & Wegener, 1996). However,
well developed heuristics, either exploit structure input model
use variable swapping existing BDD improve ordering local-search manner
(Meinel & Theobald, 1998). example, fan-in weight heuristics popular
input form combinational circuits. input CSP, reasonable heuristic
choose ordering minimizes path-width corresponding constraint graph,
113

fiAndersen, Hadzic, & Pisinger

MDD worst case exponential path-width (Bodlaender, 1993; Wilson, 2005;
Mateescu et al., 2008). Investigating heuristics variable ordering scope
work, remainder paper assume ordering already given.
experiments use default orderings provided instances.
Compilation Technique. approach first compile CSP model binary
decision diagrams (BDD) exploiting highly optimized stable BDD packages (e.g.,
Somenzi, 1996) afterwards extract corresponding MDD. Dedicated MDD packages
rare, provide limited functionality implementations optimized
BDD packages offer competitive performance (Miller & Drechsler, 2002). interesting
recent alternative generate BDDs search caching isomorphic nodes.
approach suggested Huang Darwiche (2004) compile BDDs CNF
formulas, proved valuable addition standard compilation based pairwise
BDD conjunctions. However, compilation technology still early stages
development open-source implementation publicly available.
4.1 BDD Encoding
Regardless BDD compilation method, finite domain CSP variables X first
encoded Boolean variables. Choosing proper encoding important since
intermediate BDD might large inadequate subsequent extraction. general,
CSP variable xi would encoded ki Boolean variables {xi1 , . . . , xiki }. Di
mapped bit vector enci (a) = (a1 , . . . , aki ) {0, 1}ki different
values 6= a0 get different vectors enci (a) 6= enci (a0 ). several standard Boolean
encodings multi-valued variables (Walsh, 2000). log encoding scheme xi
encoded ki = dlog|Di |e Boolean variables, representing digit binary notation.
multivalued assignment xi = translated set assignments xij = aj
P j1
Pki j1
2 xj < |Di | added
aj . Additionally, domain constraint kj=1
=
j=1 2


forbid bit assignments (a1 , . . . , aki ) encode values outside domain Di .
direct encoding (or 1-hot encoding) common, especially well suited efficient
propagation searching single solution. scheme, multi-valued variable
xi encoded |Di | Boolean variables {xi1 , . . . , xiki }, variable xij indicates
whether j-th value domain aj Di assigned. variable xi , exactly one
value Di assigned. Therefore, enforce domain constraint xi1 +. . .+xiki = 1
= 1, . . . , n. Hadzic, Hansen, OSullivan (2008) empirically demonstrated
using log encoding rather direct encoding yields smaller BDDs.
Sn Thei set Boolean variables fixed union encoding variables, Xb =
i=1 {x1 , . . . , xki } still specify ordering. common ordering
well suited efficiently answering configuration queries clustered ordering. Here,
Boolean variables {xi1 , . . . , xiki } grouped blocks respect ordering among
finite-domain variables x1 < . . . < xn . is,
xij11 < xij22 i1 < i2 (i1 = i2 j1 < j2 ).
might orderings yield smaller BDDs specific classes constraints.
Bartzis Bultan (2003) shown linear arithmetic constraints represented
114

fiInteractive Cost Configuration Decision Diagrams

compactly Boolean variables xij grouped wrt. bit-position j rather
finite-domain variable xi , i.e. xij11 < xij22 j1 < j2 (j1 = j2 i1 < i2 ). However,
configuration constraints involve linear arithmetic constraints, space savings
reported Bartzis Bultan (2003) significant variable domains
size power two. Furthermore, clustered orderings yield BDDs
preserve essentially combinatorial structure allows us extract MDDs
efficiently seen Section 4.2.
Example 3 Recall T-shirt example D1 = {0, 1, 2, 3}, D2 = {0, 1, 2}, D3 =
{0, 1}. log encoding variables x11 < x12 < x21 < x22 < x31 , inducing variable set
Xb = {1, 2, 3, 4, 5}. log-BDD clustered variable ordering shown Figure 4(a).

x1

x1
x1

0 1 2 3

x2

x2

x2

x2

x2

x2

0
x2

x3
x3

x3

2 1
0

x3
1

1

1

(a) log-BDD.

12

x2

(b) extracted MDD.

Figure 4: log-BDD clustered ordering, extracted MDD T-shirt example. BDD, draw terminal node 1 terminal node 0
incoming edges omitted clarity. node corresponding Boolean
encoding variable xij labeled corresponding CSP variable xi . Edges
labeled 0 1 drawn dashed full lines, respectively.

4.2 MDD Extraction
BDD generated using clustered variable ordering extract corresponding
MDD using method originally suggested Hadzic Andersen (2006)
subsequently expanded Hadzic et al. (2008). following considerations,
use mapping cvar(xij ) = denote CSP variable xi encoding variable
xij and, slight abuse notation, apply cvar BDD nodes u labeled
xij . terminal nodes, define cvar(0) = cvar(1) = n + 1 (recall BDD two
terminal nodes 0 1 indicating false true respectively). Analogously, use
mapping pos(xij ) = j denote position bit variable encoding.
method based recognizing subset BDD nodes captures core
MDD structure, used directly construct corresponding MDD.
115

fiAndersen, Hadzic, & Pisinger

block BDD layers corresponding CSP variable xi , Li = Vxi . . . Vxi ,
1
ki
suffices consider nodes reachable edge previous block
layers:
Ini = {u Li | (u0 ,u)E cvar(u0 ) < cvar(u)}.

0
0
first layer
Sn+1we take In1 = {r}. resulting MDD (V , E ) contains nodes
0
Ini , V = i=1 Ini constructed using extraction Algorithm 6. edge e(u, u0 , a)
added E 0 whenever traversing BDD B u wrt. encoding ends u0 6= 0.
Traversals executed using Algorithm 7. Starting u, step algorithm
traverses BDD taking low branch corresponding bit ai = 0 high branch
ai = 1. Traversal takes ki steps, terminating soon reaches node
labeled different CSP variable. MDD extracted log-BDD Figure 4(a)
shown Figure 4(b).

Algorithm 6: Extract MDD.
Data: BDD B(V, E)
E 0 {},V 0 {r};
foreach = 1, . . . , n
foreach u Ini
foreach Di
1
u0 Traverse(u, a);
u0 6= 0
E 0 E 0 {(u, u0 , a)};
V 0 V 0 {u0 }
return (V 0 , E 0 );

Algorithm 7: Traverse BDD.
Data: BDD B(V, E), u,
cvar(u);
(a1 , . . . , aki ) enci (v);
repeat
pos(u);
= 0
u low(u);
else
u high(u);
cvar(u) 6= ;
return u;

Since traversal (in lineP
1 Algorithm 6) takes O(dlog|Di |e) steps, running time
MDD extraction
O( ni=1 |Ini | |Di | dlog|Di |e). resulting MDD (V 0 , E 0 )
Pn
O( i=1 |Ini | |Di |) edges
Pnadd |Di | edges every node
0
u Ini . Since keep nodes Ini , |V | = i=1 |Ini | |V |.
4.3 Input Model Implementation Details

important factor usability approach easiness specifying input
CSP model. BDD packages callable libraries default support CSP-like input
language. best knowledge, open-source BDD-compilation tool
116

fiInteractive Cost Configuration Decision Diagrams

accepts input CSP-like model CLab (Jensen, 2007). configuration interface
top BDD package BuDDy (Lind-Nielsen, 2001). CLab constructs BDD
input constraint conjoins get final BDD. Furthermore CLab generates
BDD using log-encoding clustered ordering suits well extraction approach.
Therefore, compilation approach based using CLab specify input model
generate BDD used extraction Algorithm 6.
Note extracting MDD, preprocess efficient online querying.
expand long edges merge isomorphic nodes get merged MDD.
translate efficient form online processing. rename BDD node names
indexes 0, . . . , |V |, root index 0 terminal 1 index |V |.
allows subsequent efficient implementation U labels, well efficient
access children parent edges node. initial experiments got order
magnitude speed-up wCVD queries switched BDD node names (which
required using less efficient mapping U , D, Ch P structures).

5. Interactive Configuration Multiple Costs
number domains, user configure presence multiple cost functions
express often conflicting objectives user wants achieve simultaneously.
example, configuring product, user wants minimize price, maximizing quality, reducing ecological impact, shortening delivery time etc. assume
therefore addition CSP model (X, D, F ) whose solution space represented
merged MDD , given k additive cost functions
ci (x1 , . . . , xn ) =

n
X

cij (xi ), = 1 . . . , k

j=1

expressing multiple objectives. Multi-cost scenarios often considered within multicriteria optimization framework (Figueira et al., 2005; Ehrgott & Gandibleux, 2000).
usually assumed optimal (but unknown) way aggregate multiple
objectives single objective function would lead solution achieves
best balance satisfying various objectives. algorithms sample efficient solutions
(nondominated wrt. objective criteria) display user. user input,
algorithms learn aggregate objectives adequately used
next sampling efficient solutions etc. approaches user asked explicitly
assign
Pkweights wi objectives ci aggregated weighted summation
c = i=1 wi ci .
adopting techniques run compiled representation solution space
would immediately improve complexity guarantees would useful many scenarios multi-criteria techniques traditionally used, believe configuration
setting, explicit control variable values needed. user easily explore
effect assigning various variable values variables well cost functions.
therefore suggest directly extend wCVD query user could explore
effect cost restrictions way explores interactions regular variables. key query want deliver computing valid domains wrt. multiple cost
restrictions:
117

fiAndersen, Hadzic, & Pisinger

Definition 5 (k-wCVD) Given CSP model (X, D, F ), additive cost functions cj : R,
maximal costs Kj , j = 1, . . . , k, given partial assignment , compute:
VD [, {Kj }kj=1 ] = {a Di | 0 .(0 |= F {(xi , a)} 0

k
^

j=1

cj (0 ) Kj )}

particularly interested two-cost configuration likely occur
practice strong connections existing research solving Knapsack problems
multi-criteria optimization. reminder section first discuss
complexity 2-wCVD queries develop practical implementation approach.
discuss general k-wCVD query.
5.1 Complexity 2-wCVD query
assume input problem merged MDD , additive cost
functions c1 , c2 cost bounds K1 , K2 . first question whether possible
restricted forms additive cost functions c1 , c2 implement 2-wCVD polynomial
time. purpose formulate decision-version 2-wCVD problem:
Problem 1 (2-wCVD-SAT) Given CSP (X, D, F ) MDD
PnM representation solution space, given two additive cost functions ci (x) = j=1 cij (xj ), = 1, 2 cost
restrictions K1 , K2 , decide whether F c1 (x) K1 c2 (x) K2 satisfiable.
Unfortunately, answer even constraints involve positive coefficients,
binary domains. show reduce well-known Two-Partition
Problem (TPP) NP-hard (Garey & Johnson, 1979). given set positive
integers = {s1 , . . . , sn }, TPP asks decide whether possible split set
indexes
=P{1, . . . , n} two sets \ sum set same:
P

iI\A si .
iA =

Proposition 3 2-wCVD-SAT problem defined Boolean variables involving
linear cost functions positive coefficients NP-hard.

Proof 3 show stated reduction TPP. order reduce TPP two-cost
configuration introduce 2n binary variables x1 , . . . , x2n
x2i1 = 1 \ x2i = 1. construct MDD F =
{x1 6= x2P
, . . . , x2n1 6= x2n } introduce
P two linear cost functions positive coefficients,
c1 (x) = ni=1 si P
x2i1 c2 (x) = ni=1 si x2i . overall capacity constraints set
K1 = K2 =
iI si /2. setting = {i | x2i1 = 1} easily seen
F c1 (x) K1 c2 (x) K2 satisfiable TPP feasible solution.
Hence, able solve 2-wCVD-SAT Boolean variables positive linear cost
functions polynomial time, would able solve TPP problem polynomially.
5.2 Pseudo-Polynomial Scheme 2-wCVD
previous subsection demonstrated answering 2-wCVD queries NP-hard even
simplest class positive linear cost functions Boolean domains. Hence,
118

fiInteractive Cost Configuration Decision Diagrams

hope solving 2-wCVD guaranteed polynomial execution time unless P = N P .
However, still want provide practical solution 2-wCVD problem. hope
avoid worst-case performance exploiting specific nature cost-functions
processing. subsection therefore show 2-wCVD solved pseudopolynomial time extending labeling approach Section 3.2. Furthermore,
show adopt advanced techniques used Knapsack problem (Kellerer, Pferschy,
& Pisinger, 2004).
5.2.1 Overall Approach
algorithm runs analogous single-cost approach developed Section 3.2.
restricting MDD wrt. current assignment, calculate upstream downstream
costs U, (which longer constants lists tuples), use check
edge e, whether v(e) valid domain.
given edge e : u u0 , labeled costs c1 (e), c2 (e), follows v(e) V Di iff
paths p : r
u, p0 : u0
1 c1 (p) + c1 (e) + c1 (p0 ) K1
0
c2 (p) + c2 (e) + c2 (p ) K2 . node u suffices store two sets labels:
U [u] = {(c1 (p), c2 (p)) | p : r

u}

D[u] = {(c1 (p), c2 (p)) | p : u

1}

Then, given cost restrictions K1 , K2 , edge e : u u0 , u Vi , domain V Di [K1 , K2 ]
contains v(e) (a1 , a2 ) U [u] (b1 , b2 ) D[u] holds
a1 + c1 (e) + b1 K1 a2 + c2 (e) + b2 K2

(9)

5.2.2 Exploiting Pareto Optimality
single-cost case sufficient store U [u], D[u] minimal value
(the cost shortest path root/terminal), multi-cost case need store multiple
tuples. immediate extension would require storing K1 K2 tuples node.
However, need store non-dominated tuples U lists. two
tuples (a1 , a2 ) (a01 , a02 ) list
a1 a01 a2 a02
may delete (a01 , a02 ) test (9) succeeds (a01 , a02 ) succeed (a1 , a2 ).
remaining entries costs pareto-optimal solutions. solution pareto-optimal
wrt. solution set cost functions c1 , c2 possible find cheaper solution
respect one cost without increasing other. Path p : r
1 represents
pareto-optimal solution Sol iff node u path, sub-paths p1 : r
u
p2 : u
1 pareto-optimal wrt. sets paths {p : r
u} {p : u
1}
respectively. Hence, node u suffices store:
U [u] = {(c1 (p), c2 (p)) | p : r

u, p0 :r

u (c1 (p)

c1 (p0 ) (c2 (p) c2 (p0 ))}

D[u] = {(c1 (p), c2 (p)) | p : u

1, p0 :u

1 (c1 (p)

c1 (p0 ) (c2 (p) c2 (p0 ))}

119

fiAndersen, Hadzic, & Pisinger

Note due pareto-optimality, a1 {0, . . . , K1 } a2 {0, . . . , K2 }
one tuple U first coordinate a1 second
coordinate a2 . Therefore, node u, U [u] D[u] min{K1 , K2 }
entries. Hence, space requirements algorithmic scheme worst case O(|V |K)
K = min{K1 , K2 }.
5.2.3 Computing U Sets
discuss compute U sets efficiently utilizing advanced
techniques solving Knapsack problems (Kellerer et al., 2004). recursively update U
sets layer layer manner shown Algorithm 8. critical component
recursion step algorithm merging lists lines 2 4. operation
new list formed dominated tuples detected eliminated. order
efficiently, critical keep U lists sorted wrt. first coordinate,
i.e.
(a1 , a2 ) (a01 , a02 ) a1 < a2 .
U sorted, merged O(K) time using list-merging algorithm
Knapsack optimization (Kellerer et al., 2004, Section 3.4).
Algorithm 8: Update U, labels.

1
2

3
4

Data: MDD , Cost functions c1 , c2 , Bounds K1 , K2
U [] = {(, )}, U [r] = {(0, 0)};
foreach = 1, . . . , n
foreach u Vi
foreach e : u u0
;
foreach (a1 , a2 ) U [u]
a1 + c1 (e) K1 a2 + c2 (e) K2
(a1 + c1 (e), a2 + c2 (e));
U [u0 ] ergeLists(S, U [u0 ]);
D[] = {(, )}, D[1] = {(0, 0)};
foreach = n, . . . , 1
foreach u Vi
foreach e : u u0
;
foreach (a1 , a2 ) D[u0 ]
a1 + c1 (e) K1 a2 + c2 (e) K2
(a1 + c1 (e), a2 + c2 (e));
D[u] ergeLists(S, D[u]);

time complexity determined populating list (in lines 1 3) merging
(in lines 2 4). updates takes O(K) worst case. Since perform
updates edge e E, total time complexity Algorithm 8 O(|E| K)
worst case.
120

fiInteractive Cost Configuration Decision Diagrams

5.2.4 Valid Domains Computation
U, sets updated extract valid domains straightforward manner
using Algorithm 9. edge e : u u0 algorithm evaluates whether v(e) V Di
worst case O(|U [u]| |D[u0 ]|) = O(K 2 ) steps. Hence, valid domain extraction takes worst
case O(|E| K 2 ) steps.
Algorithm 9: Compute valid domains.
Data: MDD , Cost functions c1 , c2 , Cost bounds K1 , K2 , Labels U ,D
foreach = 1, . . . , n
VDi ;
foreach u Vi
foreach e : u u0
foreach (a1 , a2 ) U [u], (b1 , b2 ) D[u0 ]
a1 + c1 (e) + b1 K1 a2 + c2 (e) + b2 K2
VDi VDi {v(e)};
break;

However, improve running time valid domains computation exploiting
(1) pareto-optimality (2) fact sets U, sorted. critical observe
given edge e : u u0 , (a1 , a2 ) U [u] suffices perform validity
test (9) tuple (b1 , b2 ) D[u0 ], b1 maximal first coordinate satisfying
a1 + c1 (e) + b1 K1 , i.e.
b1 = max{b1 | (b1 , b2 ) D[u0 ], a1 + c1 (e) + b1 K1 }.

Namely, test succeeds (b01 , b02 ) b01 < b1 , succeed (b1 , b2 )
since due pareto-optimality, b01 < b1 b2 < b02 hence a2 +c2 (e)+b2 < a2 +c2 (e)+b02
K2 . Since lists sorted, comparing relevant tuples performed efficiently
traversing U [u] increasing order, traversing D[u0 ] decreasing order. Algorithm
10 implements procedure.
Algorithm 10: Extract edge value.

1
2

Data: MDD , Cost constraints c1 , c2 , Bounds K1 , K2 , Edge e : u u0 Ei
a(a1 , a2 ) = U [u].begin();
b(b1 , b2 ) = D[u0 ].end();
6= > b 6=
a1 + c1 (e) + b1 > K1
b(b1 , b2 ) D[u0 ].previous();
continue;
else a1 + c1 (e) + b1 K1 a2 + c2 (e) + b2 K2
VDi VDi {v(e)};
return;
a(a1 , a2 ) U [u].next();

algorithm relies several list operations. Given list L sorted tuples, operations
L.begin() L.end() return first last tuple respectively wrt. list ordering.
121

fiAndersen, Hadzic, & Pisinger

Operations L.next() L.previous() return next previous element
list wrt. ordering. Elements > indicate two special elements appear
last first element list respectively. indicate
passed beyond boundary list. algorithm terminates (line 2) soon
test succeeds. Otherwise, keeps iterating tuples processed either
last tuple U [u] first tuple D[u0 ]. case algorithm terminates
guaranteed v(e) 6 V Di . step, traverse least one element
U [u] D[u0 ]. Hence, total execute U [u] + D[u0 ] 2K operations.
Therefore, time complexity single edge traversal O(K) complexity valid
domains computation Algorithm 9 (after replacing quadratic loop Algorithm
10) O(|E| K) K = min{K1 , K2 }.
conclusion, developed pseudo-polynomial scheme computing valid domains wrt. two cost functions (2-wCVD). space complexity dominated storing U
sets node. worst case store O(|V | K) entries. time
complexity compute U labels extract valid domains takes O(|E| K) steps.
overall interaction similar single-cost approach. assigning variable,
recompute labels well extract domains. tighten cost restrictions
K1 , K2 K10 K1 , K20 K2 need extract domains. However, relax either
cost restrictions, K10 > K1 need recompute labels well.
precisely, labels U, need recomputed K1 > K1max K1max initial
cost restriction last assignment.
5.2.5 Extensions
Note approach can, principle, extended handle general k-wCVD query
fixed k. Lists U would contain set non-dominated k-tuples, ordered that:
(a1 , . . . , ak ) (a01 , . . . , a0k ) iff smallest coordinate j aj 6= a0j holds aj < a0j .
list merging well valid domains extraction would directly generalized
operate ordered sets, although time complexity testing dominans
increase. worst-case complexity would depend size efficient frontier,
k cost functions cost bounds K bounded O(K k1 ). practice however,
could expect number non-dominated tuples much smaller, especially cost
functions smaller scopes smaller coefficients. Note approach
extended accommodate non-additive cost functions expanding MDD
accommodate non-unary labels fashion discussed Section 3.4.
5.3 Approximation Scheme 2-wCVD
subsection analyze complexity answering 2-wCVD queries approximative
manner, i.e. improve running time guarantees settling approximate
solution. Assume one constraints K2 fixed second constraint may
exceeded small tolerance (1+)K1 . example, user might willing tolerate
small increase price long strict quality restrictions met. section present
fully polynomial time approximation scheme (FPTAS) calculating valid domains
time O(En 1 ) problem. FPTAS satisfy feasible solution
respect original costs fathomed, feasible configuration found
122

fiInteractive Cost Configuration Decision Diagrams

use FPTAS domain restriction satisfy cost constraint within
(1 + )K1 . Finally, FPTAS running time polynomial 1/ input
size.
order develop FPTAS use standard scaling technique (Schuurman &
Woeginger, 2005) originally presented Ibarra Kim (1975). Given , let n
number decision variables. Set = K1 /(n + 1) determine new costs c1 (e) =
bc1 (e)/T c new bounds K1 = dK1 /T e. perform valid domains computation
(label updating domain extraction) described Section 5.2, using scaled weights.
following propositions prove obtained FPTAS scheme.
Proposition 4 running time valid domains computation O( 1 En)
Proof 4 may assume K1 < K2 otherwise may interchange two costs.
running time becomes
1
n+1
) = O(En )
O(E K1 ) = O(EK1 /T ) = O(EK1
K1

since n V polynomial input size O(V + E) precision 1 .
Proposition 5 solution feasible respect original costs,
feasible respect scaled costs.
P
Proof 5 Assume ep c1 (e) K1 .
X
X
1
1
1X
c1 (e) K1 K1 e = K1
c1 (e) =
bc1 (e)/T c
ep


ep
ep
Proposition 6 solution feasible respect scaled costs c1 (e) satisfies
original constraints within (1 + )K1 .
P
Proof 6 Assume ep c1 (e) C1 .
P
P
P
P
ep c1 (e) + n
ep (bc1 (e)/T c + 1)
ep c1 (e)/T
ep c1 (e) =
K1 + n = dK1 /T e + n (K1 /T + 1) + n

= K1 + (n + 1)

Since = K1 /(n + 1) get
X
c1 (e) K1 + (n + 1)K1 /(n + 1) = (1 + )K1
ep

shows stated.

time complexity improved using techniques Kellerer et al. (2004)
Knapsack Problem, interested showing existence
FPTAS.
considerations previous subsections fully analyzed complexity
answering 2-wCVD queries. first showed NP-hard problem.
developed pseudo-polynomial scheme solving it, finally devised fully polynomial time approximation scheme. Even though cannot provide polynomial running-time
guarantees, based considerations, hope provide reasonable performance
practical instances, demonstrated Section 6.
123

fiAndersen, Hadzic, & Pisinger

5.4 Complexity k-wCVD Query
conclude section discussing complexity general k-wCVD queries.
practical implementation efforts focused implementing 2-wCVD queries, wCVD
queries number cost constraints known advance, completeness
consider generic problem delivering k-wCVD arbitrary k, i.e. k part
input problem.
prove problem pseudo-polynomial scheme unless
NP=P. show decision version problem k-wCVD-SAT NP-hard
strong sense (Garey & Johnson, 1979) reduction bin-packing problem (BPP)
strongly NP-hard (Garey & Johnson, 1979). decision form BPP asks
whether given set numbers s1 , . . . , sn placed k bins size K each. Notice,
cannot use reduction showing NP-hardness 2-wCVD-SAT, since k
part input BPP.
Theorem 7 k-wCVD-SAT problem variable k, strongly NP-hard.
Proof 7 given instance BPP reduce k-wCVD-SAT instance follows:
construct MDD CSP (X, D, F ) n variables X = {x1 , . . . , xn }
domain size k, Di = {1, . . . , k}, = 1, . . . , n. set F = , resulting MDD
allows assignments. n nonterminal nodes u1 , . . . , un corresponding numbers
s1 , . . . , sn . two nodes ui , ui+1 k edges costs (c1 (e), c2 (e), . . . , ck (e))
set
(si , 0, . . . , 0), (0, si , 0, . . . , 0), (0, 0, si , 0, . . . , 0), . . . , (0, . . . , si ),
first node u1 root u1 = r last node un connected terminal
un+1 = 1. overall capacity constraints (K1 , . . . , Kk ) = (K, . . . , K).
easily seen may find path r 1 BPP
feasible solution. Since BPP strongly NP-hard shown k-wCVD-SAT
strongly NP-hard.

6. Experimental Evaluation
implemented compilation scheme algorithms wCVD 2-wCVD queries.
performed number experiments evaluate applicability approach
well confirm various hypotheses made throughout paper. used two sets
instances whose properties presented Table 1. first set corresponds real-world
configuration problems available configuration benchmarks library CLib2 . CSP
models configuration constraints. correspond highly structured configuration
problems huge number similar solutions. second set instances represents
product-catalogue datasets used Nicholson, Bridge, Wilson (2006). catalogues
defined explicitly, tables solutions. represent much smaller sparser set
solutions.
2. http://www.itu.dk/research/cla/externals/clib/

124

fiInteractive Cost Configuration Decision Diagrams

Instance
ESVS
FS
Bike2
PC2
PC
Big-PC
Renault
Travel
Laptops
Cameras
Lettings

Sol
231
224
226
220
220
283
241
1461
683
210
751

X
26
23
34
41
45
124
99
7
14
9
6

dmin
2
2
2
4
2
2
2
4
2
5
2

dmax
61
51
38
34
33
66
42
839
438
165
174

davg
5
5
6
9
8
12
4
134
42
40
45

Table 1: First seven instances real-world configuration problems available configuration benchmarks library CLib. Remaining four instances product catalogues
used Nicholson et al. (2006). instance provide number solutions Sol, number variables X, minimal, maximal average domain
size.

6.1 MDD Size
first set experiments, instance generated log-encoded BDD B using
CLab (Jensen, 2007). extracted corresponding MDD B. Finally,
expanded long edges merged isomorphic nodes generate merged MDD 0 .
compare sizes B, 0 Table 2. structure provide number
nodes V edges E. provide size BDD B. conclude
table BDDs MDDs exponentially smaller size solution
space configuration instances significantly smaller diverse product
configuration catalogues. Furthermore, see number edges merged
MDDs 0 significantly larger comparison extracted MDDs . Hence, due
simpler online algorithms, using merged MDDs seems well suited online reasoning.
see multi-valued encoding many cases reduces number nodes
edges comparison BDDs. Even though compilation times less important since
generation MDD performed offline, worth noting largest instance,
Renault, took around 2min 30sec compile instance BDD extract
MDD.
6.1.1 Encoding Cost Explicitly
investigated impact encoding cost information explicitly MDD.
instance compared size MDD without cost variables (M
c respectively). configuration
benchmarks introduce additional variable
P
[0, 10000] = ni=1 ai xi coefficients ai randomly drawn
interval [0, 50]. put variable last ordering since positions
get MDDs similar size, putting end allows easier theoretical analysis. Since
125

fiAndersen, Hadzic, & Pisinger

Instance
ESVS
FS
Bike2
PC2
PC
Big-PC
Renault
Travel
Laptops
Cameras
Lettings

VB
306
3,044
3,129
13,332
16,494
356,696
455,796
8479
9528
4274
2122

EB
612
6,088
6,258
26,664
32,988
713,392
911,592
16,958
19,056
8,548
4,244

KB
5
41
56
237
298
7,945
9,891
154
172
71
36

VM
87
753
853
3,907
4875
100,193
283,033
1469
2033
791
351

EM
202
1,989
1,726
6,136
7989
132,595
334,008
2928
2713
999
1099

VM0
96
767
933
3907
4875
100,272
329,135
1469
2033
791
351

EM0
220
2017
1886
6136
7989
132,889
426,212
2928
2713
999
1099

Table 2: Comparison BDDs MDDs instances Table 1. second,
third fourth column give number non-terminal BDD nodes VB ,
number edges EB size disk BDD kilobytes KB. fifth
sixth column give number vertices VM edges EM MDD
extracted BDD using Algorithm 6 page 116. final two columns
provide number nodes edges merged MDD (M 0 ) long
edges extracted MDD expanded.

product catalogues already contain cost variable (price), produce cost-oblivious
version existentially quantifying y, = c .
Table 3 compare MDDs c . structures provide number
edges well representation size kilobytes. show size cost range
C(Sol). observe configuration instances high level sharing
compression, introducing cost information explicitly induces order magnitude increase
size even cost range C(Sol) limited (400 times increase Bike2 instance).
MDDs two largest instances could generated. However, product catalogues
much less sharing, removing cost information dramatic effect.
worst case, number edges c two times larger . Hence,
experimental results confirm introducing cost explicitly could dramatic effect
MDD representations highly compressed solution spaces, usually implicitly defined
conjunction combinatorial constraints. However, effect adding explicit cost
information might modest solution space defined explicitly, (sparse) list
database entries, case product catalogues. Furthermore, size
cost range C(Sol) needs significant large increase size take place.
6.2 Response Times wCVD Queries
second set experiments, evaluated performance wCVD queries merged
MDD representations configuration instances. report running times
computing U labels (Algorithm 2) well computing valid domains (Algorithm 3).
Table 4 report average worst-case running times initial merged MDDs
126

fiInteractive Cost Configuration Decision Diagrams

Instance
ESVS
FS
Bike2
PC2
PC
Big-PC
Renault
Travel
Laptops
Cameras
Lettings

E
202
1,989
1,726
6,136
7,989
132,595
334,008
1640
1592
725
496

KB
5
41
56
237
298
7,945
9,891
45
80
44
9

Ec
129,514
407,662
693,824
1,099,842
1,479,306
2928
2713
999
1099

KB
4,408
12,767
31,467
57,909
70,900
154
172
71
36

C(Sol)
1,966
1,497
3,008
2,000
2,072
839
438
165
174

Table 3: Effect explicitly encoding cost information. second third column indicate number edges representation size kilobytes cost-oblivious
MDD, fourth fifth column show MDD containing
cost information. Column C(Sol) indicates range available costs
solutions.

Table 2. report time necessary restrict MDD wrt. assignment
(Algorithm 1). randomly create additive cost function c assigning variable
xi value Di cost ci (a) [0, 50]. Valid domains computed wrt.
maximal cost restriction K set value larger length longest
MDD path wrt. cost function c. ensures longest execution time Algorithm 3.
data-point table average maximum 1000 executions Fedora
9 operating system, using dual Quad core Intel Xeon processor running 2.66 GHz.
one core used instance. Empirical evaluation demonstrates response times
easily within acceptable interaction bounds even largest instances, worst
case MDD nodes labeled within 0.13 seconds, valid domains computed within
0.07 seconds MDD restricted wrt. assignment within 0.28 seconds.
6.3 Response Times 2-wCVD Query
generated analogous statistics 2-wCVD Table 5. tested performance
algorithms computationally demanding circumstances: operate
original (fully-sized) MDD, even though interaction would reduced due
user assignments. Furthermore, cost functions c1 , c2 global scope,
use cost restrictions computing U labels (i.e. ignore condition
line 1 Algorithm 10 hence, U [1] D[r] correspond entire efficient frontier).
Normally, cost functions would involve subset variables fraction
labels efficient frontier (within restrictions K1 , K2 ) would relevant user.
generate cost functions c1 , c2 drawing costs ci (a) randomly [0, 50]. computing
valid domains, use restrictions K1 , K2 larger lengths corresponding longest
127

fiAndersen, Hadzic, & Pisinger

Instance
ESVS
FS
Bike2
PC2
PC
Big-PC
Renault

Labeling U,
avg
max
0.0001
0.01
0.0001
0.01
0.0002
0.01
0.0002
0.01
0.0003
0.01
0.0210
0.04
0.0590
0.13

Valid domain
avg
max
0.0001
0.01
0.0001
0.01
0.0001
0.01
0.0002
0.01
0.0003
0.01
0.0110
0.03
0.0310
0.07

Restrict
avg
max
0.0001 0.01
0.0002 0.01
0.0010 0.01
0.0010 0.02
0.0010 0.01
0.0400 0.08
0.1600 0.28

Table 4: Interaction time seconds wCVD queries. report time required computing U labels, valid domain computation restriction wrt. single
assignment.

paths, possible solutions efficient frontier allowed. would lead
longest execution time Algorithm 9.
algorithms easily handle first five instances. largest two instances,
U labels known, calculating valid domains done within fraction
second. Hence, user efficiently explore effect various cost restrictions K1 , K2 wrt.
fixed partial assignment. user assigns variable, recomputing U labels
takes total average less 0.85 seconds, worst case less 1.4 seconds.
already within acceptable interaction times, usability system
enhanced, e.g. using layered display information: always reacting
information fastest compute (such CVD wCVD), user analyzing
it, execute time consuming operations. particular, entire efficient frontier
known soon U labels generated worst case within 0.64 seconds.
stage, user explore cost-space labels computed (on average within
next 0.79 seconds). Note running times reduced number
additional schemes, e.g. computing U labels parallel, two processors
present.

Instance
ESVS
FS
Bike2
PC2
PC
Big-PC
Renault

Labeling U
avg
max
0.0001 0.01
0.0010 0.01
0.0010 0.02
0.0030 0.02
0.0050 0.02
0.2070 0.45
0.3470 0.64

Labeling
avg
max
0.0002 0.01
0.0020 0.02
0.0020 0.01
0.0030 0.02
0.0040 0.02
0.3160 0.60
0.4700 0.79

Valid domain
avg
max
0.0001
0.01
0.0001
0.01
0.0001
0.01
0.0005
0.01
0.0008
0.01
0.0300
0.04
0.0700
0.08

Table 5: Interaction time seconds 2-wCVD query.

128

fiInteractive Cost Configuration Decision Diagrams

empirical evaluation demonstrates practical value approach. Even
NP-hard 2-wCVD query implemented response times suitable interactive use,
applied huge configuration instances. Note, however, order achieve
performance critical optimize MDD implementation well utilize advanced
list operation techniques. initial implementation efforts failed so, led
response times measured tens seconds largest instances.

7. Related Work
several directions related work. large variety representations
investigated area knowledge compilation might suitable supporting
interactive decision making cost restrictions. number approaches
handle multiple cost functions multi-criteria optimization.
7.1 Compiled Knowledge Representation Forms
paper used binary decision diagrams (BDDs) multi-valued decision diagrams
(MDDs) compiled representations CSP model. However, might compiled representations might suitable supporting interactive configuration.
compiled representation supports efficient consistency checking conditioning
would theory support polytime interactive configuration. calculate valid domains
suffices value restrict representation check consistent. representation supports efficient optimization conditioning would support polytime
cost restrictions. would suffice restrict representation value check
minimum smaller threshold value. therefore briefly survey
related compiled representations evaluate suitability framework.
Knowledge-Compilation Structures. Probably well known framework
comparing various compiled forms propositional theories based viewing
special classes negation normal form (NNF) languages (Darwiche & Marquis, 2002).
NNFs directed acyclic graphs internal nodes associated conjunctions ()
disjunctions (), leaf nodes labeled literals (x,x) constants true
false. imposing various restrictions get subclasses NNF languages support
efficient execution various queries transformations. restrictive representations
less succinct i.e. exponentially larger instances, support
larger number queries transformations polytime. comprehensive overview
representations presented Darwiche Marquis (2002).
critical restriction makes NNF languages tractable decomposability.
exploits variable independencies enforcing children -node nonoverlapping
variable scopes. Hence, propositional formula F = F1 F2
var(F1 ) var(F2 ) = , evaluate satisfiability F suffices independently evaluate
F1 F2 . resulting language decomposable negation normal form (DNNF)
already supports polytime two operations critical calculating valid domains: consistency checking conditioning. However, general DNNF compiler exists. Current
compilation approach based exhaustive DPLL search caching isomorphic nodes
(Huang & Darwiche, 2005) constructs subsets DNNF satisfy additional property
129

fiAndersen, Hadzic, & Pisinger

determinism. two children -node mutually exclusive. resulting structure called deterministic decomposable negation normal form (d-DNNF). structure
would interesting target cost-configuration. Boolean CSP models, additive
cost functions could efficiently optimized d-DNNFs. multi-valued models however, research necessary encode finite-domain values way allows
efficient cost processing. tool support compiling d-DNNFs far takes input
CNF formulas, unaware extensions allowing direct compilation general
CSP models.
known knowledge representation forms retrieved enforcing additional
properties. example, enforcing nodes decision nodes
variable encountered path (read-once property) get free
BDDs (FBDDs). enforcing decision nodes appear wrt. fixed ordering get
ordered BDDs (OBDDs). fact, d-DNNF compiler Huang Darwiche (2005)
specialized compile OBDDs, proved valuable alternative way BDD
compilation.
Weighted Multi-Valued Knowledge Compilation Structures. compiled representations propositional theories valued counterparts. Many
seen special cases valued NNFs (VNNF) (Fargier & Marquis, 2007). Roughly, every
valued counterpart obtained changing semantics nodes, logical operators
(such , ) general operators (that could arithmetic, + ). Values
functions represented structures longer {0, 1} R. Furthermore,
functions need defined Boolean domains, could take finite-domain values.
general, subsets VNNF satisfy decomposability operator distributivity support
efficient optimization (Fargier & Marquis, 2007) could, principle, used support
cost configuration.
Construction MDDs based encoding BDDs discussed Srinivasan,
Kam, Malik, Brayton (1990). Amilhastre et al. (2002) augmented automata Vempaty (1992) edge weights reason optimal restorations explanations.
weighted extensions correspond closely weighted MDDs since variant automata
used Vempaty (1992) equivalent merged MDDs (Hadzic et al., 2008). However,
weights used compute different queries generate MDDs based widely
available BDD-packages, Vempaty (1992) report compilation tools used. Semiring
labeled decision diagrams (SLDDs) (Wilson, 2005) label edges (unordered) MDD
values semiring allow computation number queries relevant reasoning
uncertainty. Due relaxed ordering, SLDDs succinct weighted
MDDs therefore attractive target cost-based configuration. However,
proposal seems theoretic, seem implemented. Arithmetic
circuits directed acyclic graphs internal nodes labeled summation
multiplication operators leaf nodes labeled constants variables (Darwiche,
2002). could seen valued extension d-DNNFs hence succinct
SLDDs. Furthermore, support efficient optimization coefficients
positive (in Bayesian context - support efficient computing probable explanations). Compilation technology ACs directly applicable general CSP models,
used primarily representing Bayesian networks. based compiling d-DNNFs
tree clustering approaches (Darwiche, 2002, 2003). context, ACs might use130

fiInteractive Cost Configuration Decision Diagrams

ful optimizing non-additive objective functions multiplicative coefficients
multi-linear functions induced Bayesian networks. However, purely propositional
constraints additive cost function optimized, purely propositional
representation form (such d-DNNF) would adequate. Furthermore, efficient optimization queries based ACs implicitly assume constants (at leaf nodes)
positive, case modeling Bayesian networks, hold general
cost functions.
Global Structure Approaches. number techniques based tree-clustering (Dechter
& Pearl, 1989) variable-elimination (Dechter, 1999) exploit variable independencies
present globally CSP model. time space complexity techniques
turn bounded exponentially size important graph-connectivity notion
tree-width (Bodlaender, 1993). techniques geared towards enhancing search single (optimal) solution (adaptive consistency, bucket elimination etc),
concepts utilized compiling representations solutions. AND/OR
MDDs (Mateescu et al., 2008) restricted Boolean variables subset d-DNNF
formulas, variable labeling respects pseudo-tree obtained variable elimination
order. Due utilization variable independencies -nodes, succinct MDDs therefore attractive compilation target cost-configuration.
Furthermore, already extended handle weighted graphical models support
Bayesian reasoning. However, publicly available tool support limited allow
processing weighted CVD queries. Tree-driven-automata (Fargier & Vilarem, 2004) utilize
tree clustering (Dechter & Pearl, 1989), generate partial variable ordering used
generate automaton. Tree-driven-automata equivalent AND/OR MDDs
restricted Boolean case represent subset d-DNNF languages called
strongly ordered decomposable decision graphs (SO-DDG) (Fargier & Marquis, 2006).
AND/OR MDDs succinct MDDs therefore interesting target
cost-configuration. However, tools compiling tree-driven-automata yet become publicly available, far extended handle costs. Weighted
cluster trees Pargamin (2003) weighted extension cluster trees used support
interactive configuration preferences. However, publicly available compilation tool (an internal company-based implementation presented), clusters
represented explicitly without utilizing compressions based local structure decision diagrams compiled representations. Tree-of-BDDs (ToB) (Subbarayan, 2008)
directly exploit tree clustering representing cluster BDD. However,
support conditioning polytime fundamental transformation supporting user
interaction (assigning variables). However, compiled instances
d-DNNF compilation fails, empirical evaluation shows average conditioning
times short.
BDD Extensions. large variety weighted extensions binary decision diagrams, represent real-valued functions f : {0, 1}n R rather Boolean functions
f : {0, 1}n {0, 1}. extensions limited Boolean variables adoption
future would consider encoding techniques multi-valued variables avoid explosion size support cost processing. Comprehensive overviews extensions
presented Drechsler (2001), Wegener (2000), Meinel Theobald (1998). immediate extension form algebraic decision diagrams (ADDs) (Bahar, Frohm, Gaona,
131

fiAndersen, Hadzic, & Pisinger

Hachtel, Macii, Pardo, & Somenzi, 1993), known multi-terminal BDDs (MTBDDs),
essentially BDDs multiple terminal nodes - one cost value.
structure-oblivious approach encoding cost, much approach explicitly encoding
cost variable. size grows quickly increase number terminals. Therefore number BDD extensions introduced based labeling edges weights.
differ mostly cost operators decomposition types associated nodes. Edge-valued
BDDs (EVBDDs) (Lai & Sastry, 1992) label every edge additive cost value c(e)
edge e : u u0 , value val(u) = c(e) + val(u0 ) v(e) = 1 (otherwise
val(u) = val(u0 )). Factored EVBDDs (FEVBDDs) (Tafertshofer & Pedram, 1997) introduce multiplicative weights, v(e) = 1, value val(u) = c(e) + w(e) val(u0 )
(otherwise val(u) = val(u0 )). Affine ADDs (AADDs) Sanner McAllester (2005)
introduce additive multiplicative edge weights edge (regardless v(e)).
val(u) = c(e) + w(e) val(u0 ) every edge. shown AADDs
special case valued NNFs (Fargier & Marquis, 2007).
orthogonal extension BDDs change decomposition type nodes. OBDDs
based Shannon decomposition fu = xi fu0 xi fu1 . change decomposition
type positive Davio (pD) decomposition fu = f0 xi f1 negative Davio(nD) decomposition fu = f0 xi f1 . using pD decomposition get ordered functional decision
diagrams (OFDDs) (Kebschull & Rosenstiel, 1993). structures incomparable
OBDDs, i.e. might exponentially larger smaller OBDDs depending
instance. However, ordered Kronecker functional decision diagrams (OKFDDs)(Drechsler,
Sarabi, Theobald, Becker, & Perkowski, 1994) allow three decomposition types, thus generalizing OBDDs OFDDs. Extending OFDDs additive edge weights leads
binary moment diagrams (BMDs) (Bryant & Chen, 1995), adding multiplicative
edge weights leads multiplicative binary moment diagrams ( BM Ds). Analogously,
extending OKFDDs additive multiplicative edge weights get Kronecker binary
moment diagrams (KBMDs) K BM Ds respectively (Drechsler, Becker, & Ruppertz,
1996).
unclear whether Boolean structures advanced cost labeling schemes
used directly represent multi-valued CSP models cost functions. However, could
compare generalizations labeling schemes multi-valued structures. multivalued generalization EVBDDs would correspond roughly weighted MDDs. However, introducing additive multiplicative weights AADDs would correspond
generalization labeling scheme could prove useful labeling multilinear cost functions. Namely, introduction multiplicative weights would
subgraph sharing, many nodes would refined accommodate non-additive costs. However, due multiplicative factors, obvious
cashing technique based computing U, directly extended, especially
coefficients negative. case additive cost functions though, schemes
would correspond labeling scheme. structures pay price less
efficient operators (such apply operator) larger memory requirements maintain information. Therefore, compiling Boolean functions, using structures
would pose unnecessary overhead comparison OBDDs. Hence, models
large number propositional (configuration) constraints, additive cost function,
would gain compiling using structures even Boolean case.
132

fiInteractive Cost Configuration Decision Diagrams

cost function non-additive, introducing elaborate cost representations might
prove beneficial reducing memory requirements, might make label computing
technique unapplicable. practical point view, implementations
supporting Boolean versions structures, aware tool supporting
multi-valued generalizations structures input language format used
specifying general propositional constraints.
7.2 Multi-Objective Cost Processing
multiple-cost configuration close approaches within framework multi-criteria
optimization decision maker find solution subject multiple (often conflicting) objectives (Figueira et al., 2005; Ehrgott & Gandibleux, 2000). particular,
MDD-based algorithms close approaches solving multiobjective shortest
path problem, given graph (V, E) arc labeled multiple costs,
goal typically compute set Pareto-optimal (efficient, non-dominated) solutions
(Ehrgott & Gandibleux, 2000; Muller-Hannemann & Weihe, 2001; Tarapata, 2007; Reinhardt & Pisinger, 2009). shown multi-objective shortest path problem
intractable. particular, number Pareto-optimal solutions grow exponentially number vertices |V |, FPTAS (fully polynomial time approximation
scheme) developed approximating set Pareto-optimal solutions. However, way solution space multi-criteria optimization problems explored
significantly different approach. Typically, interaction step subset
Pareto-optimal solutions computed afterwards decision maker interactively navigates set order reach satisfying compromising solution. Interactive
methods multi-criteria optimization usually compute subset solutions efficient
frontier, suggest user evaluation, based input compute new set
solutions (Figueira et al., 2005, Chapter 16). techniques would use user input
better estimate way aggregate multiple objectives, would require
user explicitly assign weights importance objectives. contrast, instead primarily driven costs solutions, interactive approach supports reasoning
variable assignments solutions valid domains computation. inherently different way exploring solution space adequate
users want explicit control variable assignments indicating
importance cost functions.
approaches CSP community model preferences soft constraints
(Meseguer, Rossi, & Shiex, 2006) partially satisfied violated, goal
find satisfying least violating solution. usually presupposes preferences aggregated via algebraic operators, related single-cost
optimization problems. However, approach Rollon Larrosa (2006) deals
multiple costs explicitly. utilizes global structure (i.e. variable independencies)
weighted CSP model compute efficient frontier bucket-based variable elimination. highly related approach utilizes global structure generalized additive
independence (GAI) network presented Dubus, Gonzales, Perny (2009). order
compute efficient frontier, authors use message passing computation mechanism analogous computing buckets. addition, authors develop fully
133

fiAndersen, Hadzic, & Pisinger

polynomial approximation scheme approximate efficient frontier demonstrate
significant improvement performance. However, neither methods exploit
fact solution space hard constraints available compiled representation.
Instead, methods operate unprocessed model specification (whether
weighted CSP GAI network) treating hard soft constraints uniformly
hence allowing scope hard constraints decrease variable independencies
model (and thus decrease performance algorithms). Furthermore, result
computation methods allow full exploration efficient solutions.
value frontier single supporting efficient solution maintained
maintain efficient value set supporting efficient solutions. Hence,
possible efficiently retrieve valid domains even algorithms terminate. would
interesting see however, whether methods could adopted work MDD
representations solution space.
Knapsack constraints special case two-cost configuration problems universally true MDD. Trick (2001) used dynamic programming propagate Knapsack constraints CSP search. Fahle Sellmann (2002) presented approximated filtering
algorithm, based various integer programming bounds Knapsack problem. Sellmann (2004) presented fully polynomial time approximation algorithm approximated
filtering. However, techniques considered constraint propagation context
none considered processing existing MDD structure.

8. Conclusions Future Work
paper presented extension BDD-based interactive configuration configuring presence cost restrictions. guarantee polynomial-time cost configuration
cost function additive feasible solutions represented using multi-valued
decision diagram. process cost restrictions MDD extracted
underlying BDD. therefore strictly extend BDD-based configuration Hadzic et al.
(2004) support cost-bounding additive cost functions without incurring exponential
increase complexity. implementation delivers running times easily satisfy interactive response-time requirements. Furthermore, approach extended support
bounding presence non-additive semiring-based costs.
extended approach considering cost bounding wrt. multiple costs.
proved NP-hard problem input MDD size even processing
two linear inequalities positive coefficients Boolean variables. However,
provided pseudo-polynomial scheme fully polynomial approximation scheme twocost configuration (which, principle, extended k-cost configuration
fixed k). empirical evaluation demonstrated despite inherent hardness
problem still provide satisfying performance interactive setting. interaction
based computing valid domains wrt. multiple cost restrictions novel addition
interaction modes within multiple-criteria decision making (Figueira et al., 2005).
provide explicit control variable assignments well cost functions.
future plan investigate compiled representations delivering
cost configuration might efficient investigate practical approaches processing
non-unary cost functions. particular, plan examine whether existing methods
134

fiInteractive Cost Configuration Decision Diagrams

multiobjective non-unary optimization (e.g., Rollon & Larrosa, 2006; Dubus et al., 2009)
adopted operate MDD representation solution space.

Acknowledgments
would thank anonymous reviewers extensive comments helped
us improve paper. would thank Erik van der Meer providing
T-shirt example. first version paper created Tarik Hadzic
University Copenhagen, updated version made Cork Constraint
Computation Centre support IRCSET/Embark Initiative Postdoctoral Fellowship Scheme.

References
Amilhastre, J., Fargier, H., & Marquis, P. (2002). Consistency Restoration Explanations
Dynamic CSPs-Application Configuration. Artificial Intelligence, 135 (1-2), 199
234.
Bahar, R., Frohm, E., Gaona, C., Hachtel, E., Macii, A., Pardo, A., & Somenzi, F. (1993).
Algebraic decision diagrams applications. IEEE/ACM International Conference CAD, pp. 188191.
Bartzis, C., & Bultan, T. (2003). Construction efficient BDDs bounded arithmetic
constraints. Garavel, H., & Hatcliff, J. (Eds.), TACAS, Vol. 2619 Lecture Notes
Computer Science, pp. 394408. Springer.
Bodlaender, H. L. (1993). tourist guide treewidth. Acta Cybernetica, 11, 123.
Bollig, B., & Wegener, I. (1996). Improving variable ordering OBDDs NP-complete.
Computers, IEEE Transactions on, 45 (9), 9931002.
Bryant, R. E. (1986). Graph-Based Algorithms Boolean Function Manipulation. IEEE
Transactions Computers, 35, 677691.
Bryant, R. E., & Chen, Y.-A. (1995). Verification Arithmetic Circuits Binary
Moment Diagrams. Proceedings 32nd ACM/IEEE Design Automation
Conference, pp. 535541.
Darwiche, A., & Marquis, P. (2002). Knowledge Compilation Map. Journal Artificial
Intelligence Research, 17, 229264.
Darwiche, A. (2002). Logical Approach Factoring Belief Networks. Fensel, D.,
Giunchiglia, F., McGuinness, D., & Williams, M.-A. (Eds.), KR2002: Principles
Knowledge Representation Reasoning, pp. 409420 San Francisco, California.
Morgan Kaufmann.
Darwiche, A. (2003). differential approach inference Bayesian networks. Journal
ACM, 50 (3), 280305.
135

fiAndersen, Hadzic, & Pisinger

Dechter, R. (1999). Bucket Elimination: Unifying Framework Reasoning. Artificial
Intelligence, 113 (1-2), 4185.
Dechter, R., & Pearl, J. (1989). Tree-Clustering Constraint Networks. Artificial Intelligence, 38 (3), 353366.
Drechsler, R., Sarabi, A., Theobald, M., Becker, B., & Perkowski, M. A. (1994). Efficient
representation manipulation switching functions based ordered Kronecker
functional decision diagrams. DAC 94: Proceedings 31st annual conference
Design automation, pp. 415419 New York, NY, USA. ACM.
Drechsler, R. (2001). Binary decision diagrams theory practice. International Journal
Software Tools Technology Transfer (STTT), 3 (2), 112136.
Drechsler, R., Becker, B., & Ruppertz, S. (1996). K*BMDs: New Data Structure
Verification. EDTC 96: Proceedings 1996 European conference Design
Test, p. 2 Washington, DC, USA. IEEE Computer Society.
Dubus, J.-P., Gonzales, C., & Perny, P. (2009). Multiobjective Optimization using GAI
Models. Boutilier, C. (Ed.), IJCAI, pp. 19021907.
Ehrgott, M., & Gandibleux, X. (2000). Survey Annotated Bibliography Multiobjective Combinatorial Optimization. Spektrum, 22, 425460.
Fahle, T., & Sellmann, M. (2002). Cost Based Filtering Constrained Knapsack
Problem. Annals Operations Research, 115, 7393.
Fargier, H., & Marquis, P. (2006). Use Partially Ordered Decision Graphs
Knowledge Compilation Quantified Boolean Formulae. Proceedings AAAI
2006, pp. 4247.
Fargier, H., & Marquis, P. (2007). Valued Negation Normal Form Formulas. Proceedings IJCAI 2007, pp. 360365.
Fargier, H., & Vilarem, M.-C. (2004). Compiling CSPs Tree-Driven Automata
Interactive Solving. Constraints, 9 (4), 263287.
Figueira, J. R., Greco, S., & Ehrgott, M. (2005). Multiple Criteria Decision Analysis: State
Art Surveys. Springer Verlag, Boston, Dordrecht, London.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability-A Guide Theory
NP-Completeness. W H Freeman & Co.
Hadzic, T., Subbarayan, S., Jensen, R. M., Andersen, H. R., Mller, J., & Hulgaard, H.
(2004). Fast Backtrack-Free Product Configuration using Precompiled Solution
Space Representation. Proceedings PETO Conference, pp. 131138. DTUtryk.
Hadzic, T., & Andersen, H. R. (2006). BDD-based Polytime Algorithm Cost-Bounded
Interactive Configuration. Proceedings AAAI 2006, pp. 6267.
136

fiInteractive Cost Configuration Decision Diagrams

Hadzic, T., Hansen, E. R., & OSullivan, B. (2008). Automata, MDDs BDDs
Constraint Satisfaction. Proceedings ECAI 2008 Workshop Inference
Methods based Graphical Structures Knowledge.
Huang, J., & Darwiche, A. (2004). Using DPLL efficient OBDD construction.
Proceedings SAT 2004, pp. 127136.
Huang, J., & Darwiche, A. (2005). DPLL trace: SAT knowledge compilation.
Kaelbling, L. P., & Saffiotti, A. (Eds.), IJCAI, pp. 156162. Professional Book
Center.
Ibarra, O., & Kim, C. (1975). Fast approximation algorithms knapsack sum
subset problem. Journal ACM, 22, 463468.
Jensen, R. M. (2007). CLab: C++ library fast backtrack-free interactive product
configuration. http://www.itu.dk/people/rmj/clab/.
Kebschull, U., & Rosenstiel, W. (1993). Efficient graph-based computation manipulation functional decision diagrams. Design Automation, 1993, European
Event ASIC Design. Proceedings. [4th] European Conference on, 278282.
Kellerer, H., Pferschy, U., & Pisinger, D. (2004). Knapsack Problems. Springer, Berlin,
Germany.
Lai, Y.-T., & Sastry, S. (1992). Edge-valued binary decision diagrams multi-level hierarchical verification. DAC 92: Proceedings 29th ACM/IEEE conference
Design automation, pp. 608613 Los Alamitos, CA, USA. IEEE Computer Society
Press.
Lichtenberg, J., Andersen, H. R., Hulgaard, H., Mller, J., & Rasmussen, A. S. (2001).
Method configuring product. US Patent No: 7,584,079.
Lind-Nielsen, J. (2001).
BuDDy - Binary
http://sourceforge.net/projects/buddy.

Decision

Diagram

Package.

Mateescu, R., Dechter, R., & Marinescu, R. (2008). AND/OR Multi-Valued Decision Diagrams (AOMDDs) Graphical Models. Journal Artificial Intelligence Research,
33, 465519.
Meinel, C., & Theobald, T. (1998). Algorithms Data Structures VLSI Design.
Springer.
Meseguer, P., Rossi, F., & Shiex, T. (2006). Soft constraints. Rossi, F., van Beek,
P., & Walsh, T. (Eds.), Handbook Constraint Programming, Foundations Artificial Intelligence, chap. 9, pp. 281328. Elsevier Science Publishers, Amsterdam,
Netherlands.
Miller, D. M., & Drechsler, R. (2002). Construction Multiple-Valued Decision
Diagrams. Proceedings 32nd International Symposium Multiple-Valued
Logic (ISMVL02), p. 245 Washington, DC, USA. IEEE Computer Society.
137

fiAndersen, Hadzic, & Pisinger

Mller, J., Andersen, H. R., & Hulgaard, H. (2002). Product configuration internet.
INFORMS Conference Information Systems Technology.
Muller-Hannemann, M., & Weihe, K. (2001). Pareto Shortest Paths Often Feasible
Practice. WAE 01: Proceedings 5th International Workshop Algorithm
Engineering, pp. 185198 London, UK. Springer-Verlag.
Nicholson, R., Bridge, D. G., & Wilson, N. (2006). Decision Diagrams: Fast Flexible
Support Case Retrieval Recommendation. Proceedings ECCBR 2006,
pp. 136150.
Pargamin, B. (2003). Extending Cluster Tree Compilation non-Boolean variables
Product Configuration: Tractable Approach Preference-based Configuration.
IJCAI03 Workshop Configuration.
Reinhardt, L. B., & Pisinger, D. (2009). Multi-Objective Multi-Constrained NonAdditive Shortest Path Problems. Computers Operations Research. Submitted.
Technical report version available at: http://man.dtu.dk/upload/institutter/
ipl/publ/publikationer%202009/rapport%2016.pdf.
Rollon, E., & Larrosa, J. (2006). Bucket elimination multiobjective optimization problems. Journal Heuristics, 12 (4-5), 307328.
Sanner, S., & McAllester, D. A. (2005). Affine Algebraic Decision Diagrams (AADDs)
Application Structured Probabilistic Inference. Proceedings IJCAI 2005,
pp. 13841390.
Schuurman, P., & Woeginger, G. J. (2005). Approximation schemes tutorial.
Moehring, R., Potts, C., Schulz, A., Woeginger, G., & Wolsey, L. (Eds.), Lectures
Scheduling. Forthcoming.
Sellmann, M. (2004). Practice Approximated Consistency Knapsack Constraints.
McGuinness, D. L., & Ferguson, G. (Eds.), AAAI, pp. 179184. AAAI Press /
MIT Press.
Somenzi, F. (1996). CUDD: Colorado university decision diagram package. ftp://vlsi
.colorado.edu/pub/.
Srinivasan, A., Kam, T., Malik, S., & Brayton, R. K. (1990). Algorithms discrete
function manipulation. International Conference CAD, pp. 9295.
Subbarayan, S., Jensen, R. M., Hadzic, T., Andersen, H. R., Hulgaard, H., & Mller, J.
(2004). Comparing two implementations complete backtrack-free interactive
configurator. Proceedings CP04 CSPIA Workshop, pp. 97111.
Subbarayan, S. M. (2008). Exploiting Structures Constraint Solving. Ph.D. thesis,
University Copenhagen, Copenhagen.
Tafertshofer, P., & Pedram, M. (1997). Factored edge-valued binary decision diagrams.
Formal Methods System Design, Vol. 10, pp. 243270. Kluwer.
138

fiInteractive Cost Configuration Decision Diagrams

Tarapata, Z. (2007). Selected multicriteria shortest path problems: analysis complexity, models adaptation standard algorithms. International Journal Applied
Mathematics Computer Science, 17 (2), 269287.
Trick, M. (2001). dynamic programming approach consistency propagation
knapsack constraints. 3rd international workshop integration AI
techniques constraint programming combinatorial optimization problems CPAI-OR, pp. 113124.
Vempaty, N. R. (1992). Solving constraint satisfaction problems using finite state automata.
Proceedings Tenth National Conference Artificial Intelligence, pp. 453
458.
Walsh, T. (2000). SAT v CSP. Dechter, R. (Ed.), Proceedings CP 2000, Lecture Notes
Computer Science, pp. 441456.
Wegener, I. (2000). Branching Programs Binary Decision Diagrams. Society Industrial Applied Mathematics (SIAM).
Wilson, N. (2005). Decision diagrams computation semiring valuations.
Proceedings Nineteenth International Joint Conference Artificial Intelligence
(IJCAI-05), pp. 331336.

139


