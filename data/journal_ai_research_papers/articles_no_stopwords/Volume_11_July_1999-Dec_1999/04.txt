Journal Artificial Intelligence Research 11 (1999) 199-240

Submitted 7/98; published 9/99

Unifying Class-Based Representation Formalisms

calvanese@dis.uniroma1.it
lenzerini@dis.uniroma1.it
nardi@dis.uniroma1.it

Diego Calvanese
Maurizio Lenzerini
Daniele Nardi

Dipartimento di Informatica e Sistemistica
Universita di Roma \La Sapienza"
Via Salaria 113, I-00198 Roma, Italy
Abstract

notion class ubiquitous computer science central many formalisms
representation structured knowledge used knowledge representation
databases. paper study basic issues underlying representation formalisms single common characteristics distinguishing features.
investigation leads us propose unifying framework able capture fundamental aspects several representation languages used different contexts.
proposed formalism expressed style description logics,
introduced knowledge representation means provide semantically well-founded
basis structural aspects knowledge representation systems. description logic
considered paper subset first order logic nice computational characteristics. quite expressive features novel combination constructs
studied before. distinguishing constructs number restrictions, generalize existence functional dependencies, inverse roles, allow one refer inverse
relationship, possibly cyclic assertions, necessary capturing real world
domains. able show precisely combination constructs makes
logic powerful enough model essential set features defining class structures
common frame systems, object-oriented database languages, semantic data
models. consequence established correspondences, several significant extensions
formalisms become available. high expressiveness logic
propose need capturing reasoning different contexts forces us distinguish unrestricted finite model reasoning. notable feature proposal
reasoning cases decidable. argue that, virtue high expressive
power associated reasoning capabilities unrestricted finite models,
logic provides common core class-based representation formalisms.
1. Introduction

many fields computer science find formalisms representation objects
classes (Motschnig-Pitrik & Mylopoulous, 1992). Generally speaking, object denotes
element domain interest, class denotes set objects common characteristics. use term \class-based representation formalism" refer formalism
allows one express several kinds relationships constraints (e.g., subclass constraints) holding among classes meaningful set applications. Moreover,
class-based formalisms aim taking advantage class structure order provide
various information, whether class consistent, i.e., admits least one object,
whether class subclass another class, generally, whether given constraint
c 1999 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiCalvanese, Lenzerini, & Nardi

holds given set classes. characterization, clear
formalisms referred paper deal structural aspects objects
classes, include features specification behavioral properties
objects.
Three main families class-based formalisms identified paper. first one
comes knowledge representation particular work semantic networks
frames (see example Lehmann, 1992; Sowa, 1991). second one originates
field databases particular work semantic data models (see
example Hull & King, 1987). third one arises work types programming
languages object-oriented systems (see example Kim & Lochovsky, 1989).
past several attempts establish relationships among various
families class-based formalisms (see Section 6 brief survey). proposed solutions
fully general formalism capturing modeling constructs
reasoning techniques families still missing. paper address
problem proposing class-based representation formalism, based description logics
(Brachman & Levesque, 1984; Schmidt-Schau & Smolka, 1991; Donini, Lenzerini, Nardi,
& Schaerf, 1996), using comparing formalisms.
description logics, structured knowledge described means called concepts
roles, denote unary binary predicates, respectively. Starting set
atomic symbols one build complex concept role expressions applying suitable
constructors characterize description logic. Formally, concepts interpreted
subsets domain roles binary relations domain, constructs
equipped precise set-theoretic semantics. common constructs include
boolean operations concepts, quantification roles. example, concept
Person u 8child.Male, denotes set individuals instances concept
Person connected role child instances concept Male,
concept 9child denotes individuals connected role child
individual. constructs considered important include
general forms quantification, number restrictions, allow one state limits
number connections individual may via certain role, constructs
roles, intersection, concatenation inverse. description logic knowledge base,
expressing intensional knowledge modeled domain, built stating inclusion
assertions concepts, satisfied models knowledge base.
assertions used specify necessary and/or necessary sucient conditions
individuals instances certain concepts. Reasoning knowledge bases includes
detection inconsistencies knowledge base itself, determining whether concept
populated model knowledge base, checking subsumption, i.e., whether
instances concept necessarily instances another concept models
knowledge base.
paper propose description logic called aluni, quite expressive
includes novel combination constructs, including number restrictions, inverse roles,
inclusion assertions restrictions cycles. features make aluni powerful
enough provide unified framework frame systems, object-oriented languages,
semantic data models. show establishing precise correspondence framebased language style one proposed Fikes Kehler (1985),
200

fiUnifying Class-Based Representation Formalisms

Entity-Relationship model (Chen, 1976), object-oriented language style
one introduced Abiteboul Kanellakis (1989). specifically, identify
relevant features model classes cited settings show
specification class-based formalisms equivalently expressed
knowledge base aluni. way, able identify commonalities
among families specificities family. Therefore, even though
specific features every family addressed aluni, able
show formalism proposed paper provides important features
currently missing family, although relevance often stressed.
sense, unifying framework points possible developments languages belonging
three families.
One fundamental reason regarding aluni unifying framework class-based
representation formalisms reasoning aluni hard, nonetheless decidable,
shown Calvanese, Lenzerini, Nardi (1994), Calvanese (1996c). Consequently,
language features arising different frameworks build class-based representations
given common semantic account, combined expressive setting
one retains capability solving reasoning tasks. combination constructs
included language makes necessary distinguish reasoning respect
finite models, i.e., models finite domain, reasoning respect unrestricted
models. Calvanese (1996c) devises suitable techniques unrestricted finite model
reasoning, enable reasoning different contexts arising assuming finite
domain, often case field databases, assuming domain
infinite. paper, discuss results reasoning aluni, compare
results reasoning class-based representation formalisms.
Summarizing, framework provides adequate expressive power account
significant features major families class-based formalisms. Moreover,
equipped suitable techniques reasoning finite unrestricted models.
Therefore, believe aluni captures essential core class-based representation
formalisms belonging three families mentioned above.
paper organized follows. next section present formalism
Sections 3, 4, 5 discuss three families class-based formalisms, namely, frame
languages, semantic data models, object-oriented data models, showing basic
features captured knowledge bases aluni. final sections contain review
related work, including discussion reasoning aluni class-based formalism,
concluding remarks.
2. Unifying Class-Based Representation Language

section, present aluni, class-based formalism style description logics
(DLs) (Brachman & Levesque, 1984; Schmidt-Schau & Smolka, 1991; Donini et al., 1996;
Donini, Lenzerini, Nardi, & Nutt, 1997). DLs domain interest modeled means
concepts roles, denote classes binary relations, respectively. Generally
speaking, DL formed three basic components:
description language, specifies construct complex concept role
expressions (also called simply concepts roles), starting set atomic
201

fiCalvanese, Lenzerini, & Nardi
Construct

atomic concept
atomic negation
conjunction
disjunction
universal quantification
number restrictions
atomic role
inverse role

Syntax

:A
C1 u C2
C1 C2
8R.C
9nR
9nR
P
P

Semantics
AI
n AI
C1I \ C2I
C1I [ C2I
fo j 8o0 . (o; o0 ) 2 RI ! o0 2 C g
fo j ]fo0 j (o; o0 ) 2 RI g ng1
fo j ]fo0 j (o; o0 ) 2 RI g ng
P
f(o; o0 ) j (o0 ; o) 2 P g

Table 1: Syntax semantics ALUNI
symbols applying suitable constructors. set allowed constructs
characterizes description language.
knowledge specification mechanism, specifies construct DL knowledge base, properties concepts roles asserted.
set basic reasoning tasks provided DL.
rest section describe specific form three components assume
aluni.
2.1 Description Language

aluni

description language aluni, called ALUNI , concepts roles formed according syntax shown Table 1, denotes atomic concept, P atomic
role, C arbitrary concept expression, R arbitrary role expression, n nonnegative integer. increase readability concept expressions, introduce following
abbreviations:
> :A; atomic concept
? u :A; atomic concept
9R 91R
9=nR 9nR u 9nR

Concepts interpreted subsets domain roles binary relations
domain. Intuitively, :A represents negation atomic concept, interpreted
complement respect domain interpretation. C1 u C2 represents
conjunction two concepts interpreted set intersection, C1 C2 represents
disjunction interpreted set union. Consequently, > represents whole domain,
1. ]S denotes cardinality set .

202

fiUnifying Class-Based Representation Formalisms

? empty set. 8R.C called universal quantification roles used
denote elements interpretation domain connected role R
instances concept C . 9nR 9nR called number restrictions, impose
instances restrictions minimum maximum number objects
connected role R. P , called inverse role P , represents inverse
binary relation denoted P .
formally, interpretation = (I ; ) consists interpretation domain
interpretation function maps every concept C subset C
every role R subset RI according semantic rules specified Table 1.
sets C RI called extensions C R respectively.
Example 2.1 Consider concept expression
8enrolls.Student u 92enrolls u 930 enrolls u
8teaches .(Professor GradStudent) u 9=1teaches u
:AdvCourse

specifying constraints object university course. expression ects
fact course enrolls students, restrictions minimum maximum
number enrolled students. using role teaches inverse constructor
state property course taught exactly one individual, either
professor graduate student. Finally, negation used express disjointness
concept denoting advanced courses.
2.2 Knowledge Bases

aluni

aluni knowledge base, expresses knowledge classes relations
modeled domain, formally defined triple K = (A; P ; ), finite set
atomic concepts, P finite set atomic roles, finite set called inclusion
assertions. assertion form
_ C
atomic concept C arbitrary concept expression. inclusion
assertion states means concept C necessary properties element domain
order instance atomic concept A. Formally, interpretation satisfies
inclusion assertion _ C AI C . interpretation model knowledge
base K satisfies inclusion assertions K. finite model model finite
domain.
Example 2.1 (cont.) assertion
_ 8enrolls.Student u 92enrolls u 930enrolls u
Course
8teaches .(Professor GradStudent) u 9=1teaches
makes use complex concept expression state necessary conditions object
instance concept Course.
203

fiCalvanese, Lenzerini, & Nardi

aluni restrictions imposed form inclusion assertions may
assume. particular rule cyclic assertions, i.e., assertions
concept expression right hand side refers, either directly indirectly via
assertions, atomic concept left hand side. presence cyclic assertions
different semantics may adopted (Nebel, 1991). one defined above, called descriptive
semantics, accepts interpretations satisfy assertions knowledge base,
hence interprets assertions constraints domain modeled. inclusion
assertions, descriptive semantics claimed provide intuitive results
(Buchheit, Donini, Nutt, & Schaerf, 1998). Alternative semantics proposed
based fixpoint constructions (Nebel, 1991; Schild, 1994; De Giacomo & Lenzerini,
1994b), hence allow define unique way interpretation concepts.
general, cycles knowledge base increase complexity reasoning (Nebel,
1991; Baader, 1996; Calvanese, 1996b) require special treatment reasoning procedures (Baader, 1991; Buchheit, Donini, & Schaerf, 1993). reason, many DL based
systems assume knowledge base acyclic (Brachman, McGuinness, Patel-Schneider,
Alperin Resnick, & Borgida, 1991; Bresciani, Franconi, & Tessaris, 1995). However, assumption unrealistic practice, cycles definitely necessary correct modeling
many application domains. Indeed, use cycles allowed data models used
databases, and, shown following sections, order capture semantics
aluni possibility using cyclic assertions fundamental.
Besides inclusion assertions, DL based systems make use equivalence assertions (Buchheit et al., 1993), express necessary sucient conditions
object instance concept. Although possibility ruled aluni,
limit ability capturing frame based systems database models,
constraints expressed correspond naturally inclusion assertions.
2.3 Reasoning

aluni

basic tasks consider reasoning aluni knowledge base concept
consistency concept subsumption:
Concept consistency problem deciding whether concept C consistent
knowledge base K (written K 6j= C ?), i.e., whether K admits model
C 6= ;.
Concept subsumption problem deciding whether concept C1 subsumed
concept C2 knowledge base K (written K j= C1 C2), i.e., whether C1I C2I
model K.
inclusion number restrictions inverse roles ALUNI ability
aluni using arbitrary, possibly cyclic inclusion assertions allows one construct knowledge base certain concept consistent necessarily empty extension
finite models knowledge base. Similarly, subsumption relation two
concepts may hold infinite models knowledge base ruled finite
models considered.
204

fiUnifying Class-Based Representation Formalisms
Keven = (A P ),
= fNumber Eveng,
P = fdoublesg,
set assertions consists of:
;

;

;

Number
Even

_ 9doubles u 8doubles .Even
_ Number u 91 doubles u 8doubles.Number

Figure 1: aluni knowledge base two concepts equivalent finite
models
Let Keven knowledge base shown Figure 1. Intuitively, assertions Keven state number even number doubles it,
numbers double even. even number number, doubles
one number, doubles numbers. Observe model Keven , universal quantifications together functionality doubles assertions imply
]EvenI ]NumberI , direct inclusion assertion Even Number implies
]EvenI ]NumberI . Therefore, two concepts cardinality, since
one sub-concept other, domain finite, extensions coincide.
necessarily hold infinite domains. fact, names chosen suggest
already infinite model knowledge base Number Even interpreted
differently. model obtained taking natural numbers domain, interpreting Number whole domain, Even even numbers, doubles set
f(2n; n) j n 0g.
example shows aluni finite model property,
states concept consistent knowledge base knowledge base admits
finite model concept nonempty extension. Therefore, important
distinguish reasoning respect unrestricted models reasoning
respect finite models. call (unrestricted) concept consistency (written K 6j=u C
?) (unrestricted) concept subsumption (written K j=u C ) reasoning tasks
described above, i.e., carried without restricting attention finite models.
corresponding reasoning tasks carried considering finite models only, called finite
concept consistency (written K 6j=f C ?) finite concept subsumption (written
K j=f C ).
Example 2.2 (cont.) Summing previous considerations, say Number
subsumed Even Keven , i.e., Keven 6j=u Number Even, finitely subsumed, i.e.,
Keven j=f Number Even. Equivalently Numberu:Even consistent Keven , i.e., Keven 6j=u
Number u:Even ?, finitely consistent, i.e., Keven j=f Number u:Even ?.
distinguishing feature aluni reasoning finite unrestricted case decidable. particular, unrestricted concept satisfiability concept
subsumption decidable deterministic exponential time (De Giacomo & Lenzerini,
Example 2.2

205

fiCalvanese, Lenzerini, & Nardi

1994a; Calvanese et al., 1994), since reasoning strict sublanguages aluni already EXPTIME-hard (Calvanese, 1996c), known algorithms computationally optimal. Finite concept consistency aluni decidable deterministic exponential time
finite concept subsumption (in general case) decidable deterministic double
exponential time (Calvanese, 1996c). precise discussion methods reasoning aluni provided Section 6.2, detailed account adopted algorithms
analysis computational complexity presented Calvanese (1996c).
next sections show two forms reasoning respect unrestricted
finite models, capture reasoning tasks typically considered different
formalisms structured representation knowledge.
3. Frame Based Systems

Frame languages based idea expressing knowledge means frames,
structures representing classes objects terms properties instances
must satisfy. properties defined frame slots, constitute items
frame definition. Since 70s large number frame systems developed,
different goals different features. DLs bear close relationship kl-one family
frame systems (Woods & Schmolze, 1992). However, would consider frame
systems general perspective, discussed example Karp (1992), Karp,
Myers, Gruber (1995), establish correspondence aluni knowledge bases
context.
remark restricting attention aspects related
taxonomic structure. Moreover, discussed below, consider assertional knowledge
bases, intensional knowledge characterized terms inclusion assertions rather
definitions. addition, consider features cannot captured
first-order framework, default values slots, attached procedures,
specification overriding inheritance policies. issues concerning modeling
aspects DLs addressed Donini, Lenzerini, Nardi, Nutt, Schaerf (1994),
Donini, Nardi, Rosati (1995), within modal nonmonotonic extension DLs.
3.1 Syntax Frame Based Systems

make correspondence precise, need fix syntax semantics frame
systems consider. Unfortunately, accepted standard chosen
use basically notation adopted Fikes Kehler (1985), used
KEE2 system.
frame knowledge base, denoted F , formed set frame
slot names, constituted set frame definitions following form:
Definition 3.1

Frame : F KB F E;
2. KEE trademark Intellicorp. Note KEE user directly specify knowledge base
notation, allowed define frames interactively via graphical system interface.

206

fiUnifying Class-Based Representation Formalisms
: Course KB University
: enrolls
ValueClass: Student
Cardinality.Min: 2
Cardinality.Max: 30
MemberSlot: taughtby
ValueClass: (UNION GradStudent
Professor)
Cardinality.Min: 1
Cardinality.Max: 1

Frame

: BasCourse KB University
: Course
MemberSlot: taughtby
ValueClass: Professor

Frame

MemberSlot

SuperClasses

: Professor

Frame

: Student

Frame

KB

University

University

: GradStudent KB University
: Student
MemberSlot: degree
ValueClass: String
Cardinality.Min: 1
Cardinality.Max: 1

Frame

SuperClasses

: AdvCourse KB University
: Course
MemberSlot: enrolls
ValueClass: (INTERSECTION

Frame

SuperClasses

GradStudent
(NOT Undergrad))

KB

: Undergrad KB University
: Student

Frame

SuperClasses

: 20

Cardinality.Max

Figure 2: KEE knowledge base
E frame expression, i.e., expression formed according following syntax:
E ! SuperClasses : F1 ; : : : ; Fh
MemberSlot : S1
ValueClass : H1
Cardinality.Min : m1
Cardinality.Max : n1

MemberSlot : Sk
ValueClass : Hk
Cardinality.Min : mk
Cardinality.Max : nk
F denote frame slot names, respectively, n denote positive integers,
H denotes slot constraint, specified follows:
H

! Fj

(INTERSECTION H1 H2) j
(UNION H1 H2) j
(NOT H )

readers familiar KEE system, point omit
specification sub-classes frame present KEE, since directly derived
specification super-classes.
Example 3.2 Figure 2 shows simple example knowledge base modeling situation
university expressed frame language presented. frame Course
207

fiCalvanese, Lenzerini, & Nardi

represents courses enroll students taught either graduate students
professors. Cardinality restrictions used impose minimum maximum number
students may enrolled course, express course taught
exactly one individual. frame AdvCourse represents courses enroll graduate
students, i.e., students already degree. Basic courses, hand, may
taught professors.
3.2 Semantics Frame Based Systems

give semantics set frame definitions resort interpretation terms
first-order predicate calculus (Hayes, 1979). According interpretation, frame names
treated unary predicates, slots considered binary predicates.
frame expression E interpreted predicate logic formula E (x), one
free variable, consists conjunction sentences, obtained super-class
specification slot specification. particular, super-classes F1 ; : : : ; Fh
have:
F1 (x) ^ : : : ^ Fh (x)
slot specification
MemberSlot :
ValueClass : H
Cardinality.Min :
Cardinality.Max : n

8y. (S (x; y) !VH (y)) ^
9y1; : : : ; ym. (( i6=j yi 6= yj ) ^ (x; y1 ) ^ ^ (x; ym )) ^
8y1; : : : ; yn+1. ((S (x; y1 ) ^ ^ (x; yn+1)) ! Wi6=j yi = yj );
assumption within one frame definition occurrences x refer
free variable. Finally constraints slots interpreted conjunction, disjunction
negation, respectively, i.e.:
(INTERSECTION H1 H2) interpreted H1(x) ^ H2(x)
(UNION H1 H2)
interpreted H1(x) _ H2(x)
(NOT H )
interpreted :H (x)
frame definition
Frame : F KB F E
considered universally quantified sentence form
8x.(F (x) ! E (x)):
whole frame knowledge base F considered conjunction first-order sentences corresponding frame definitions F .
regard frame definitions necessary conditions, commonplace
frame systems known assertional frame systems, opposed definitional systems,
frame definitions interpreted necessary sucient conditions.
208

fiUnifying Class-Based Representation Formalisms

order enable comparison formalisms representing structured knowledge restrict attention reasoning tasks involve frame knowledge base,
independently assertional knowledge, i.e., frames instances. Fikes Kehler
(1985) mention several reasoning services associated frames, as:
Consistency checking, amounts verifying whether frame F satisfiable
knowledge base. particular, involves reasoning cardinalities
checking whether filler given slot belongs certain frame.
Inheritance, which, case, amounts ability identifying
frames general given frame, sometimes called all-super-of (Karp
et al., 1995). properties general frames inherited
specific one. reasoning therefore based general ability
check mutual relationhips frame descriptions knowledge base.
reasoning services formalized first-order semantics follows.
Definition 3.3 Let F frame knowledge base F frame F . say F
consistent F first-order sentence F ^ 9x.F (x) satisfiable. Moreover, say
frame description E general F F F j= 8x.(F (x) ! E (x)).
3.3 Relationship Frame Based Systems

aluni

first-order semantics given allows us establish straightforward relationship
frame languages aluni. Indeed, present translation frame
knowledge bases aluni knowledge bases.
first define function maps frame expression ALUNI concept
expression follows:
Every frame name F mapped atomic concept (F ).
Every slot name mapped atomic role (S ).
Every slot constraint mapped follows
(UNION H1 H2)
mapped (H1) (H2):
(INTERSECTION H1 H2) mapped (H1) u (H2):
(NOT H )
mapped :(H ):
Every frame expression form
SuperClasses : F1 ; : : : ; Fh
MemberSlot : S1
ValueClass : H1
Cardinality.Min : m1
Cardinality.Max : n1

MemberSlot : Sk
ValueClass : Hk
Cardinality.Min : mk
Cardinality.Max : nk
209

fiCalvanese, Lenzerini, & Nardi
K = (A P ),
= fCourse AdvCourse BasCourse Professor Student GradStudent Undergrad Stringg,
P = fenrolls taughtby degreeg,
set assertions consists of:
;

;

;

;

;

Course
AdvCourse
BasCourse
GradStudent
Undergrad

;

;

;

;

;

;

_ 8enrolls.Student u 92 enrolls u 930 enrolls u
8taughtby.(Professor GradStudent) u 9=1 taughtby
_ Course u 8enrolls.(GradStudent u :Undergrad) u 920 enrolls
_ Course u 8taughtby.Professor
_ Student u 8degree.String u 9=1 degree
_ Student

Figure 3: aluni knowledge base corresponding KEE knowledge base Figure 2
mapped class expression
(F1 ) u u (Fh ) u
8(S1).(H1) u 9m (S1) u 9n (S1) u

8(Sk ).(Hk ) u 9mk (Sk ) u 9nk (Sk):
1

1

mapping allows us translate frame knowledge base aluni knowledge base,
specified following definition.
aluni knowledge base (F ) = (A; P ; ) corresponding frame
knowledge base F obtained follows:
consists one atomic concept (F ) frame name F F .
P consists one atomic role (S ) slot name F .
consists inclusion assertion
(F ) _ (E )
frame definition
Frame : F KB F E
F .
Definition 3.4

Example 3.2 (cont.) illustrate translation frame knowledge base Figure 2. corresponding aluni knowledge base shown Figure 3.
210

fiUnifying Class-Based Representation Formalisms

correctness translation follows correspondence settheoretic semantics aluni first-order interpretation frames (see example
Hayes, 1979; Borgida, 1996; Donini et al., 1996). observe inverse roles
fact necessary formalization frames. Indeed, possibility referring
inverse slot rarely considered frame knowledge representation systems (Some
exceptions reported Karp, 1992). Due absence inverse roles distinction
reasoning finite unrestricted models necessary3 . Consequently,
mentioned forms reasoning captured unrestricted concept consistency
concept subsumption aluni knowledge bases. summarized following
theorem.
Theorem 3.5 Let F frame knowledge-base, F frame F , E frame description, (F ), (F ), (E ) translations aluni. following
hold:

F consistent F (F ) 6j=u (F ) ?.
E general F F (F ) j=u (F ) (E ).

claim directly follows semantics frame knowledge bases
translation DLs adopted.
Theorem 3.5 becomes possible exploit methods unrestricted reasoning
aluni knowledge bases order reason frame knowledge bases. Since problem
reasoning, e.g., KEE already EXPTIME-complete, pay terms computational complexity expressiveness added constructs aluni. fact,
resorting correspondence aluni becomes possible add frame systems
useful features, possibility specifying inverse slot (Karp, 1992),
still retain ability reason EXPTIME.
Proof.

4. Semantic Data Models

Semantic data models introduced primarily formalisms database schema design.
provide means model databases much richer way traditional data
models supported Database Management Systems, becoming
important adopted recent database design methodologies
Computer Aided Software Engineering tools.
widespread semantic data model Entity-Relationship (ER) model introduced Chen (1976). become standard, extensively used design
phase commercial applications. commonly accepted ER notation, classes called
entities represented boxes, whereas relationships entities represented
diamonds. Arrows entities, called ISA relationships, represent inclusion assertions. links entities relationships represent ER-roles, number
restrictions associated. Dashed links used whenever restrictions refined
specific entities. Finally, elementary properties entities modeled attributes,
3. eliminate

ALUNI inverse roles, resulting DL finite model property.
211

fiCalvanese, Lenzerini, & Nardi

whose values belong one several predefined domains, Integer, String,
Boolean.
ER model provide constructs expressing explicit disjointness disjunction entities, extensions model allow use generalization hierarchies
represent combination two constructs. order keep presentation simple, consider generalization hierarchies formalization provide,
although addition would straightforward. Similarly, omit attributes relations.
show relevant aspects ER model captured aluni,
thus reasoning ER schema reduced reasoning corresponding
aluni knowledge base. Since aluni equipped capabilities reason knowledge
bases, respect finite unrestricted models (see Section 6.2), reduction
shows reasoning ER model, generally semantic data models,
decidable.
case frame-based systems, restrict attention aspects
constitute core ER model. reason consider features,
keys weak entities, introduced literature (Chen, 1976),
appear formalizations ER model methodologies
conceptual modeling based model. proposal treatment keys description
logics presented Borgida Weddell (1997).
order establish correspondence ER model aluni, present
formal syntax semantics ER schemata.
4.1 Syntax Entity-Relationship Model

Although ER model become industrial standard, several variants
extensions introduced, differ minor aspects expressiveness
notation (Chen, 1976; Teorey, 1989; Batini, Ceri, & Navathe, 1992; Thalheim, 1992, 1993).
Also, ER schemata usually defined using graphical notation particularly
useful easy visualization data dependencies, well suited
purposes. Therefore chosen formalization ER model abstracts
respect important characteristics allows us develop correspondence
aluni.
following, two finite sets X call function subset X
X -labeled tuple . labeled tuple maps xi 2 X yi 2 ,
2 f1; : : : ; kg, denoted [x1 : y1 ; : : : ; xk : yk ]. write [xi ] denote yi .
ER schema tuple = (LS ; ; att ; rel ; card ),
LS finite alphabet partitioned set ES entity symbols, set attribute
symbols, set US role symbols, set RS relationship symbols, set DS
domain symbols; domain symbol associated predefined basic domain
DBD , assume various basic domains pairwise disjoint.
ES ES binary relation ES .
att function maps entity symbol ES -labeled tuple DS .

Definition 4.1

212

fiUnifying Class-Based Representation Formalisms

function maps relationship symbol RS US -labeled tuple
ES . assume without loss generality that:
{ role specific exactly one relationship, i.e., two relationships
R; R0 2 RS R 6= R0 , rel (R) = [U1 : E1 ; : : : ; Uk : Ek ] rel (R0 ) =
[U10 : E10 ; : : : ; Uk0 0 : Ek0 0 ], fU1; : : : ; Uk g fU10 ; : : : ; Uk0 0 g disjoint.
{ role U 2 US relationship R entity E
rel (R) = [: : : ; U : E; : : :].
card function ES RS US IN0 (IN0 [ f1g) satisfies following condition: relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ],
card (E; R; U ) defined U = Ui 2 f1; : : : ; kg, E Ei
(where denotes exive transitive closure ). first component
card (E; R; U ) denoted cmin (E; R; U ) second component
cmax (E; R; U ). stated otherwise, cmin (E; R; U ) assumed 0
cmax (E; R; U ) assumed 1.
specifying formal semantics ER schemata give intuitive description
components schema. relation models ISA-relationship entities.
need make special assumption form acyclicity
injectivity. function att used model attributes entities. example
att associates -labeled tuple [A1 : Integer; A2 : String] entity E , E
two attributes A1 ; A2 whose values integers strings respectively. simplicity
assume attributes single-valued mandatory, could easily handle multivalued attributes associated cardinalities. function rel associates set roles
relationship symbol R, determining implicitly arity R, role
U set distinguished entity, called primary entity U R. database
satisfying schema instances primary entity allowed participate
relationship via role U . function card specifies cardinality constraints, i.e.,
constraints minimum maximum number times instance entity may
participate relationship via role. Since constraints meaningful
entity effectively participate relationship, function defined
sub-entities primary entity. special value 1 used restriction
posed maximum cardinality. constraints used specify existence
dependencies functionality relations (Cosmadakis & Kanellakis, 1986).
often used restricted form, minimum cardinality either 0 1
maximum cardinality either 1 1. Cardinality constraints form considered
introduced already Abrial (1974) subsequently studied Grant
Minker (1984), Lenzerini Nobili (1990), Ferg (1991), Ye, Parent, Spaccapietra
(1994), Thalheim (1992).
Example 4.2 Figure 4 shows simple ER schema modeling state affairs similar
one represented KEE knowledge base Figure 2. used standard graphic
notation ER schemata, except dashed link, represents refinement
cardinality constraint participation sub-entity (in case AdvCourse)
relationship (in case ENROLLING).


rel

213

fiCalvanese, Lenzerini, & Nardi

Tof

(1,1)

Course

6

Ein

(2,30)

TEACHING

ENROLLING

Tby

(0,1)

Eof

(4,6)

Teacher

Student

6

(2,20)
AdvCourse

degree/String

GradStudent

Figure 4: ER schema
4.2 Semantics Entity-Relationship Model

semantics ER schema given specifying database states
consistent information structure represented schema. Formally, database
state B corresponding ER schema = (LS ; ; att ; rel ; card ) constituted
nonempty finite set B , assumed disjoint basic domains, function B
maps
every domain symbol 2 DS corresponding basic domain DBD ,
every entity E 2 ES subset E B B ,
every attribute 2 set AB B SD2DS DBD ,
every relationship R 2 RS set RB US -labeled tuples B .
elements E B , AB , RB called instances E , A, R respectively.
database state considered acceptable satisfies integrity constraints
part schema. captured definition legal database state.
Definition 4.3 database state B said legal ER schema =
(LS ; ; att ; rel ; card ), satisfies following conditions:
pair entities E1; E2 2 ES E1 E2, holds E1B E2B .
entity E 2 ES , att (E ) = [A1 : D1 ; : : : ; Ah : Dh], instance
e 2 E B 2 f1; : : : ; hg following holds:
{ exactly one element ai 2 ABi whose first component e,
{ second component ai element DiBD .
relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ], instances
R form [U1: e1 ; : : : ; Uk : ek ], ei 2 EiB , 2 f1; : : : ; kg.
214

fiUnifying Class-Based Representation Formalisms
Number

(1,1)

6

Even

DOUBLES

(0,1)

Figure 5: ER schema corresponding Example 2.2
relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ],
2 f1; : : : ; kg, entity E 2 ES E Ei instance e E
, holds
cmin (E; R; Ui ) ]fr 2 RB j r[Ui ] = eg cmax (E; R; Ui ):

Notice definition database state ects usual assumption databases
database states finite structures (see Cosmadakis, Kanellakis, & Vardi, 1990).
fact, basic domains required finite, legal database state
schema, finite set values basic domains actually interest.
define active domain Bact database state B set elements basic
domains DBD , 2 DS , effectively appear values attributes B. formally:
Bact = fd 2 DBD j 2 DS ^ 9A 2 ; e 2 B . (e; d) 2 AB g:
Since B finite contains finite number attributes, functional
definition, Bact finite.
Reasoning ER model includes verifying entity satisfiability deducing inheritance. Entity satisfiability amounts checking whether given entity populated
legal database state (Atzeni & Parker Jr., 1986; Lenzerini & Nobili, 1990; Di Battista
& Lenzerini, 1993), corresponds notion concept consistency DLs. Deducing
inheritance amounts verifying whether databases legal schema,
every instance entity instance another entity. implied ISA relationships arise different reasons. Either trivially, transitive closure
explicit ISA relationships present schema, subtle ways, specific
patterns cardinality restrictions along cycles schema requirement
database state finite (Lenzerini & Nobili, 1990; Cosmadakis et al., 1990).
Figure 5 shows ER schema modeling situation knowledge
base Example 2.2. Arguing exactly example conclude two
entities Number Even denote set elements every finite database legal
schema, although ISA relation Number Even stated explicitly.
implied, however, due cycle involving relationship two entities due
particular form cardinality constraints.
Example 4.4

215

fiCalvanese, Lenzerini, & Nardi
4.3 Relationship Entity-Relationship Schemata

aluni

show different forms reasoning ER schemata captured finite
concept consistency finite concept subsumption aluni. correspondence
two formalisms established defining translation ER schemata aluni
knowledge bases, proving correspondence legal database
states finite models derived knowledge base.
Definition 4.5 Let = (LS ; ; att ; rel ; card ) ER schema. aluni knowledge base (S ) = (A; P ; ) defined follows:
set atomic concepts (S ) contains following elements:
domain symbol 2 DS , atomic concept (D);
entity E 2 ES , atomic concept (E );
relationship R 2 RS , atomic concept (R).
set P atomic roles (S ) contains following elements:
attribute 2 , atomic role (A);
relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ], k atomic roles
(U1 ); : : : ; (Uk ).
set assertions (S ) contains following elements:
pair entities E1; E2 2 ES E1 E2, assertion
(E1 ) _ (E2 )
(1)
entity E 2 ES att (E ) = [A1 : D1 ; : : : ; Ah: Dh ], assertion
(E ) _ 8(A1 ).(D1 ) u u 8(Ah ).(Dh ) u 9=1(A1 ) u u 9=1 (Ah ) (2)
relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ], assertions
(R) _ 8(U1 ).(E1 ) u u 8(Uk ).(Ek ) u 9=1 (U1 ) u u 9=1(Uk ) (3)
(Ei ) _ 8((Ui )) .(R);
2 f1; : : : ; kg
(4)
relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ], 2
f1; : : : ; kg, entity E 2 ES E Ei,
{ = cmin (E; R; Ui ) 6= 0, assertion
(E ) _ 9m ((Ui )) :
(5)
{ n = cmax (E; R; Ui ) 6= 1, assertion
(E ) _ 9n ((Ui )) :
(6)
pair symbols X1 ; X2 2 ES [RS [DS X1 6= X2 X1 2 RS [DS ,
assertion
(X1 ) _ :(X2 ):
(7)
216

fiUnifying Class-Based Representation Formalisms
K = (A P ),
= fCourse AdvCourse Teacher Student GradStudent TEACHING ENROLLING Stringg,
P = fTof Tby Ein Eof degreeg,
set assertions consists of:
;

;

;

;

;

;

;

;

;

;

;

;

;

TEACHING
ENROLLING
Course
AdvCourse
Teacher
Student
GradStudent

_ 8Tof.Course u 9=1 Tof u
8Tby.Teacher u 9=1 Tby
_ 8Ein.Course u 9=1 Ein u
8Eof.Student u 9=1 Eof
_ 8Tof .TEACHING u 9=1 Tof u
8Ein .ENROLLING u 92 Ein u 930 Ein
_ Course u 920 Ein
_ 8Tby .TEACHING
_ 8Eof .ENROLLING u 94 Eof u 96 Eof
_ Student u 8degree.String u 9=1 degree

:

Figure 6: aluni knowledge base corresponding ER schema Figure 4
illustrate translation ER schema Figure 4.
knowledge base captures exactly semantics shown Figure 6,
brevity disjointness assertions (7) omitted, assertions concept
left hand side collapsed.
translation makes use inverse attributes number restrictions capture
semantics ER schemata. observe that, means inverse constructor,
binary relationship could treated simpler way choosing traversal direction
mapping relationship directly role. Notice assumption acyclicity
resulting knowledge base unrealistic case, order exploit correspondence reasoning ER model, need techniques deal inverse
attributes, number restrictions, cycles together. shown Example 2.2, combination factors causes finite model property fail hold, need
resort reasoning methods finite models.
fact, reduce reasoning ER model finite model reasoning aluni
knowledge bases. purpose define mapping database states corresponding ER schema finite interpretations knowledge base derived it.
Due possible presence relations arity greater 2, mapping however
one-to-one first need characterize interpretations knowledge base
directly correspond database states.
Definition 4.6 Let = (LS ; ; att ; rel ; card ) ER schema (S ) defined
above. interpretation (S ) relation-descriptive, every relationship R 2
RS , rel (R) = [U1 : E1 ; : : : ; Uk : Ek ], every d; d0 2 ((R))I ,
^
(8)
( 8d00 2 . ((d; d00 ) 2 ((Ui ))I $ (d0 ; d00 ) 2 ((Ui ))I )) ! = d0 :
Example 4.2 (cont.)
aluni

1ik

217

fiCalvanese, Lenzerini, & Nardi

Intuitively, extension relationship database state set labeled tuples,
set contain element twice. Therefore implicit
semantics ER model cannot two labeled tuples connected
roles relationship exactly elements domain. model
aluni knowledge base corresponding ER schema, hand, tuple
represented new individual, condition implicit anymore.
cannot imposed aluni suitable assertions. following lemma, however, shows
need explicit condition, interested reasoning
aluni knowledge base corresponding ER schema. due fact
always restrict considering relation-descriptive models.
ER schema, (S ) aluni knowledge base obtained
according Definition 4.5, C concept expression (S ). C finitely consistent
(S ), finite relation-descriptive model (S ) C 6= ;.
Lemma 4.7 Let

Let I0 finite model (S ) C 6= ;. build finite relationdescriptive model 0 starting I0 applying following construction
relationship RS .
Let model obtained previous step let R 2 RS rel (R) =
[U1 : E1 ; : : : ; Uk : Ek ] next relationship apply construction. construct model IR condition 8 satisfied relationship R.
Given individual r 2 ((R))I , denote Ui(d), 2 f1; : : : ; kg (unique)
individual e (r; e) 2 ((Ui ))I . ei 2 ((Ei ))I , 2 f1; : : : ; kg define
X(U :e ;:::;Uk :ek ) = fr 2 ((R))I j Ui (d) = ei ; 2 f1; : : : ; kgg. call con ict-set
set X(U :e ;:::;Uk:ek ) one element. con ict-set X(U :e ;:::;Uk:ek)
randomly choose one individual r, say others induce con ict
(U1 : e1 ; : : : ; Uk : ek ). call Conf (finite) set objects inducing con ict
(U1 : e1 ; : : : ; Uk : ek ).
define interpretation I2Conf disjoint union 2]Conf copies , one copy,
denoted IZ , every set Z 2 2Conf . denote dZ copy IZ individual
. Since disjoint union two models aluni knowledge base
model, I2Conf model (S ). Let IZ IZ 0 two copies I2Conf . call
exchanging Uk (rZ ) Uk (rZ 0 ) operation I2Conf consisting replacing ((Uk ))IZ
pair (rZ ; Uk (rZ )) (rZ ; Uk (rZ 0 )) and, time, replacing ((Uk ))IZ0
pair (rZ 0 ; Uk (rZ 0 )) (rZ 0 ; Uk (rZ )). Intuitively, exchanging Uk (rZ ) Uk (rZ 0 ),
individuals rZ rZ 0 induce con icts anymore.
construct I2Conf interpretation IR follows: r 2 Conf
Z 2 2Conf r 2 Z , exchange Uk (rZ ) Uk (rZnfrg ). possible
show con icts thus eliminated new con ict created. Hence,
IR, condition 8 R satisfied. still show IR model (S )
C IR 6= ;. Indeed, straightforward check induction every concept
expression C 0 appearing (S ), Z 2 2Conf , 2 C 0I dZ 2 C 0IR . Thus
assertions (S ) still satisfied IR C IR 6= ;.
Proof.

1 1

1 1

1 1

218

fiUnifying Class-Based Representation Formalisms

result, following correspondence legal database states
ER schema relation-descriptive models resulting aluni knowledge base
established.
Proposition 4.8 every ER schema = (LS ; ; att ; rel ; card ) exist two
mappings ffS , database states corresponding finite interpretations translation (S ), fiS , finite relation-descriptive interpretations (S ) database states
corresponding , that:

1. legal database state B , ffS (B) finite model (S ),
symbol X 2 ES [ [ RS [ DS , X B = ((X ))ffS (B) .

2. finite relation-descriptive model (S ), fiS (I ) legal database state
, entity E 2 ES , ((E ))I = E fiS (I ) , symbol X 2 [RS [DS ,
](X )I = ]X fiS (I ) .

Proof.

(1) Given database state B, define interpretation = ffS (B) (S )

follows:
= B [ Bact [ SR2RS RB .
symbol X 2 ES [ [ RS [ DS ,
((X ))I = X B :

relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ],
((Ui ))I = f(r; e) 2 j r 2 RB ; r[Ui] = eg; 2 f1; : : : ; kg:

(9)
(10)

Let B legal database state. prove claim (1) sucient show satisfies
every assertion (S ). Assertions 1 satisfied since B satisfies set inclusion
extensions corresponding entities. respect assertions 2, let E 2 ES
entity att (E ) = [A1 : D1 ; : : : ; Ah : Dh], consider instance e 2 ((E ))I .
show 2 f1; : : : ; hg, exactly one element ei 2
(e; ei ) 2 ((Ai ))I , moreover ei 2 ((Di ))I . 9, e 2 E B , definition legal
database state exactly one element ai 2 ABi = ((Ai ))BI whose first component e.
Moreover, second component ei ai element Di = ((Di ))I . respect
assertions 3, let R 2 RS relationship rel (R) = [U1 : E1 ; : : : ; Uk : Ek ],
consider instance r 2 ((R))I . show 2 f1; : : : ; kg
exactly one element ei 2 (r; ei ) 2 ((Ui ))I , moreover
ei 2 ((Ei ))I . 9, r 2 RB , definition legal database state, r labeled tuple
form [U1 : e01 ; : : : ; Uk : e0k ], e0i 2 EiB , 2 f1; : : : ; kg. Therefore r function
defined fU1 ; : : : ; Uk g, 10, ei unique equal e0i. Moreover, 9,
ei 2 ((Ei ))I = EiB . Assertions 4 satisfied, since 10 first component
element ((Ui ))I always element RB = ((R))I . respect assertions 5,
let R 2 RS relationship rel (R) = [U1 : E1 ; : : : ; Uk : Ek ], let E 2 ES
entity E Ei, 2 f1; : : : ; kg, = cmin (E; R; Ui ) 6= 0.
219

fiCalvanese, Lenzerini, & Nardi

Consider instance e 2 ((E ))I . show least pairs
((Ui ))I e second component. Since assertions 4 satisfied know
first component pairs instance (R). 9 definition
legal database state, least labeled tuples RB whose Ui component
equal e. 10, ((Ui ))I contains least pairs whose second component equal
e. respect assertions 6 proceed similar way. Finally, assertions 7
satisfied since first, definition basic domains pairwise disjoint disjoint
B set labeled tuples, second, element B labeled tuple,
third, labeled tuples corresponding different relationships cannot equal since
defined different sets roles.
(2) Let finite relation-descriptive interpretation (S ). basic domain
2 DS , let fiD function DBD one-to-one onto. Since
finite basic domain contains countable number elements, function
always exists. order define fiS (I ) first specify mapping associates
individual 2 element follows:
2 ((E ))I entity E 2 ES , (d) = d.
2 ((R))I relationship R 2 RS rel (R) = [U1 : E1 ; : : : ; Uk : Ek ],
individuals d1; : : : ; dk 2 (d; di ) 2 ((Ui ))I , 2 f1; : : : ; kg,

(d) = [U1 : d1 ; : : : ; Uk : dk ].

2 ((D))I basic domain 2 DS , (d) = fiD (d).
Otherwise (d) = d.

pair individuals (d1 ; d2 ) 2 , fi((d1 ; d2 )) = (fi (d1 ); (d2 )), set
X , (X ) = ffi (x) j x 2 X g.
model (S ) rules define fi(d) every 2 . Indeed,
assertions 7, 2 instance one atomic concept corresponding
relationship basic domain, case instance atomic
concept corresponding entity. Moreover, 2 ((R))I relationship R 2 RS
rel (R) = [U1: E1 ; : : : ; Uk : Ek ], assertions 3, 2 f1; : : : ; kg
exactly one element di 2 (d; di ) 2 ((Ui ))I . model (S )
2 , fi(d) uniquely determined, choose nondeterministically
one possible value.
define database state B = fiS (I ) corresponding :
B = n







R2RS ((R)) [ D2DS ((D )) .

symbol X 2 ES [ [ RS [ DS , X B = fi(((X ))I ).

dicult see, model (S ), B defined way legal
database state active domain SD2DS ((D))I .
220

fiUnifying Class-Based Representation Formalisms

following theorem allows us reduce reasoning ER schemata finite model
reasoning aluni knowledge bases.
Theorem 4.9 Let ER schema, E; E 0 two entities , (S ) translation . following holds:

(S ) 6j=f (E ) ?.
2. E inherits E 0 (S ) j=f (E ) (E 0 ).
B 6 ;. part 1 Proposition 4.8,
Proof. (1) \)" Let B legal database state E =

(
B
)

ffS (B) finite model (S ) ((E ))
=6 ;.
\(" Let (E ) finitely consistent (S ). Lemma 4.7 finite relationdescriptive model (S ) (E )I =6 ;. part 2 Proposition 4.8, fiS (I )
database state legal E B =6 ;.
(2) \)" Let (S ) 6j=f (E ) (E 0 ). (E ) u:(E 0 ) finitely consistent (S ).
Lemma 4.7 finite relation-descriptive model (S ) 2 ((E ))I
62 ((E 0 ))I , 2 . part 2 Proposition 4.8, fiS (I ) database state legal
2 E B 62 E 0B . Therefore E inherit E 0.
\(" Assume E inherit E 0. database state B legal
instance e 2 E B e 62 E 0B . part 1 Proposition 4.8,
ffS (B) finite model (S ) e 2 ((E ))ffS (B) e 62 ((E 0 ))ffS (B) . Therefore
(S ) 6j=f (E ) (E 0 ).
1. E satisfiable

Theorem 4.9 allows us effectively exploit reasoning methods developed aluni order reason ER schemas. complexity resulting method
reasoning ER schemata exponential. Observe however, known algorithms
reasoning ER schemata exponential (Calvanese & Lenzerini, 1994b),
precise computational complexity problem still open.
Moreover, exploiting correspondence aluni, becomes possible add
ER model (and general semantic data models) several features modeling
primitives currently missing, considered important, fully
take account reasoning schemata. additional features include
example possibility specify use arbitrary boolean combinations entities,
refine properties entities along ISA hierarchies.
5. Object-Oriented Data Models

Object-oriented data models proposed goal devising database formalisms could integrated object-oriented programming systems (Kim, 1990).
subject active area research database field, based
following features:
rely notion object identifier extensional level (as opposed
traditional data models value-oriented) notion class
intensional level.
221

fiCalvanese, Lenzerini, & Nardi

structure classes specified means typing inheritance.

previous section, present common basis object-oriented data models
class-based formalisms introducing language specifying object-oriented
schemata show schemata correctly represented aluni knowledge
bases. analysis, concentrate attention structural aspects objectoriented data models. One characteristics object-oriented approach provide
mechanisms specifying dynamic properties classes objects, typically
definition methods associated classes. aspects outside
scope investigations. Nevertheless, argue general techniques schema level
reasoning, particular, type consistency type inference, profitably exploited
restricted forms reasoning methods (Abiteboul, Kanellakis, Ramaswamy, & Waller,
1992).
5.1 Syntax Object-Oriented Model

define simple object-oriented language style popular models
featuring complex objects object identity. Although refer specific
formalism, model inspired ones presented Abiteboul Kanellakis (1989),
Hull King (1987).
Definition 5.1 object-oriented schema tuple = (CS ; ; DS ), where:
CS finite set class names, denoted letter C .
finite set attribute names, denoted letter A.
DS finite set class declarations form
Class C is-a C1 ; : : : ; Ck type-is T;
denotes type expression built according following syntax:


! Cj

Union T1 ; : : : ; Tk End j
Set-of j
Record A1: T1 ; : : : ; Ak : Tk End:
DS contains exactly one declaration class C 2 CS .
Figure 7 shows fragment object-oriented schema corresponding
KEE knowledge base Figure 2.
class declaration imposes constraints instances class refers to.
is-a part class declaration allows one specify inclusion sets instances
involved classes, type-is part specifies type expression structure
assigned objects instances class.
Example 5.2

222

fiUnifying Class-Based Representation Formalisms
Class Teacher type-is
Union Professor, GradStudent
End
Class GradStudent is-a Student type-is
Record
degree: String
End

Class Course type-is
Record
enrolls: Set-of Student,
taughtby: Teacher
End

Figure 7: object-oriented schema
5.2 Semantics Object-Oriented Model

meaning object-oriented schema given specifying characteristics
instance schema. definition instance makes use notions object
identifier value.
Let us first characterize set values constructed set symbols,
called object identifiers. Given finite set symbols denoting real world objects, set
VO values inductively defined follows:
VO .
v1 ; : : : ; vk 2 VO fjv1 ; : : : ; vk jg 2 VO .
v1 ; : : : ; vk 2 VO [ A1 : v1 ; : : : ; Ak : vk ] 2 VO .
Nothing else VO .
database instance J schema = (CS ; ; DS ) constituted
finite set OJ object identifiers;
mapping J assigning class CS subset OJ ;
mapping J assigning value VOJ object OJ .
Although set VOJ values constructed set OJ object identifiers
infinite, database instance one needs consider finite subset VOJ .
Definition 5.3 Given object-oriented schema instance J , set VJ
active values respect J constituted by:
set OJ object identifiers.
set values assigned J elements OJ , including values
explicitly associated object identifiers, used form values.
interpretation type expressions J defined interpretation function J assigns type expression subset VOJ following conditions satisfied:
C J = J (C )
223

fiCalvanese, Lenzerini, & Nardi

(Union T1 ; : : : ; Tk End)J = T1J [ [ TkJ
(Set-of )J = ffjv1 ; : : : ; vk jg j k 0; vi 2 J ; 2 f1; : : : ; kgg
(Record A1 : T1 ; : : : ; Ak : Tk End)J = f[ A1 : v1 ; : : : ; Ah : vh] j h k;
vi 2 TiJ ; 2 f1; : : : ; kg;
vj 2 VOJ ; j 2 fk + 1; : : : ; hgg:
Notice instances type record may components specified
type class. Thus using open semantics records, typical
object-oriented data models (Abiteboul & Kanellakis, 1989).
order characterize object-oriented data models consider instances
admissible schema.
Definition 5.4 Let = (CS ; ; DS ) object-oriented schema. database instance
J said legal (with respect ) declaration
Class C is-a C1 ; : : : ; Cn type-is
DS , holds C J CiJ 2 f1; : : : ; ng, J (C J ) J .
Therefore, legal database instance, type expressions present
schema determine (finite) set active values must considered. construction
values limited depth type expressions.
5.3 Relationship Object-Oriented Schemata

aluni

establish relationship aluni object-oriented language presented
above. done providing mapping object-oriented schemata aluni
knowledge bases. Since interpretation domain aluni knowledge bases consists
atomic objects, whereas instance object-oriented schema assigned possibly
structured value (see definition VO ), need explicitly represent
notions underlie object-oriented language. particular, correspondence concepts classes, one must explicitly account type structure
class. accomplished introducing aluni concepts AbstractClass,
represent classes, RecType SetType represent corresponding types.
associations classes types induced class declarations, well
basic characteristics types, modeled means roles: (functional) role value
models association classes types, role member used specifying
type elements set. Moreover, concepts representing types assumed
mutually disjoint, disjoint concepts representing classes. constraints
expressed adequate inclusion assertions part knowledge base
going define.
first define function maps type expression ALUNI concept
expression follows:
Every class C mapped atomic concept (C ).
Every type expression Union T1; : : : ; Tk End mapped (T1 ) (Tk ).
224

fiUnifying Class-Based Representation Formalisms

Every type expression Set-of mapped SetType u 8member. (T ).
Every attribute mapped atomic role (A), every type expression

Record A1: T1 ; : : : ; Ak : Tk End mapped

(A1 ). (T1 ) u 9=1 (A1 ) u u
8 (Ak ). (Tk ) u 9=1 (Ak ):

RecType u 8

Using define aluni knowledge base corresponding object-oriented schema.
aluni knowledge base (S ) = (A; P ; ) corresponding objectoriented schema = (CS ; ; DS ) obtained follows:
Definition 5.5

= fAbstractClass; RecType; SetTypeg [ f (C ) j C 2 CS g.
P = fvalue; memberg [ f (A) j 2 g.
consists following assertions:
AbstractClass
RecType
SetType

_
_
_

9=1value
8value.?
8value.? u :RecType

class declaration
Class C is-a C1 ; : : : ; Cn type-is
DS , inclusion assertion
(C ) _ AbstractClass u (C1 ) u u (Cn) u 8value. (T ):
translation observe inverse roles necessary
formalization object-oriented data models. Indeed, possibility referring
inverse attribute generally ruled models. However, strongly limits
expressive power data model, pointed recent papers (see example
Albano, Ghelli, & Orsini, 1991; Cattell, 1994). Note use number restrictions
limited value 1, corresponds existence constraints functionality,
whereas union used general form example KEE system.
illustrate translation fragment object-oriented
schema Figure 7. corresponding aluni knowledge base shown Figure 8.
Example 5.2 (cont.)

225

fiCalvanese, Lenzerini, & Nardi
K = (A P ),
= fAbstractClass RecType SetType String
;

;

;

P

;

;

;

Course; Teacher; Professor; Student; GradStudentg,
= fvalue; member; enrolls; taughtby; degreeg,

set assertions consists of:
Course

_

Teacher
GradStudent

_
_

AbstractClass
RecType
SetType

AbstractClass u
8value.(RecType u 9=1 enrolls u 9=1 taughtby u
8enrolls.(SetType u 8member.Student) u 8taughtby.Teacher)
AbstractClass u 8value.(GradStudent Professor)
AbstractClass u Student u
8value.(RecType u 8degree.String u 9=1 degree)

_ 9=1 value
_ 8value.?
_ 8value.? u :RecType

Figure 8: aluni knowledge base corresponding object-oriented schema Figure 7
discuss effectiveness translation . First observe
knowledge base (S ) resulting translation object-oriented schema
may admit models direct counterpart among legal database instances
. precisely, interpretation (S ) database instance
viewed directed labeled graph: case interpretation, nodes domain
individuals arcs labeled roles. case database instance,
nodes either object identifiers active values, arc either connects object
identifier associated value (in case labeled value), part
sub-structure representing set record value (in case labeled member
attribute, accordance type value). legal database instance
, value v represented sub-structure form finite tree v
root, set record values intermediate nodes, objects identifiers leaves. Clearly,
substructure contain cycles. Conversely, model (S ), may
cycles involving nodes instances SetType RecType
roles different value. call cycles bad. model containing bad cycles
cannot put directly correspondence legal database instance. Also, due
open semantics records one cannot adopt different translation bad cycles
model ruled out.
aluni

Example 5.6

Consider object-oriented schema , containing single class declaration

Class C type-is Record a1 : Record a2 : Record a3 : C End End End
226

fiUnifying Class-Based Representation Formalisms

o1
C

value

v1

RecType
a3

a1

a2

o2
C

v2

RecType
value

v3

a1

RecType

v4

a2

RecType

v5

RecType

a3

Figure 9: model containing cycles
translated
C _ AbstractClass u
8value.(RecType u 9=1a1 u 8a1.(RecType u 9=1a2 u 8a2.(RecType u 9=1a3 u 8a3.C ))):
Figure 9 shows model (S ) represented graph. clarity, named
instances C , hence AbstractClass, instances RecType
v. Observe two different types cycles graph. cycle involving individuals
o2 ; v3 ; v4 , v5 cause problems since contains arc labeled value,
part structure constituting complex value. fact, v3 represents
record value [ a1 :[[a2:[[a3: o2 ] ] ] . hand, due bad cycle involving v1
v2 , individual v1 represents (together o2 connected via a3 v1 ) record infinite
depth.
nevertheless establish correspondence finite models (S ) possibly
containing bad cycles legal instances object-oriented schema .
achieved unfolding bad cycles model (S ) infinite trees. Obviously,
unfolding cycle infinite tree, generates infinite number nodes,
would correspond infinite database state. However, restrict duplication
individuals represent set record values, thus instances SetType
RecType. instances AbstractClass, instead, duplicated process
unfolding, therefore number remains finite. Moreover, since set possible
active values associated object identifier bound depth schema,
fact block unfolding bad cycles finite tree depth equal depth
schema.
Let us first formally define depth object-oriented schema .
Definition 5.7 type expression define depth (T ) inductively follows:
8 0;
= C .
>
>
< max
= Union T1 ; : : : ; Tk End.
1ik (depth (Ti ));
depth (T ) =
0 );
>
1
+
depth
(

= Set-of 0.
>
:
1 + max1ik (depth (Ti )); = Record A1: T1 ; : : : ; Ak : Tk End.
depth object-oriented schema defined maximum depth (T ) type
expression .
227

fiCalvanese, Lenzerini, & Nardi

o1
C

value

a1

0

v1

RecType

a2

0

v2

RecType

a3

a3

C

RecType

1

v2

a2

RecType

2

v1

a1

RecType

:::

a3

value
o2

a1

1

v1

a1

v3

RecType

v4

RecType

a2

v5

RecType

a3

Figure 10: unfolded version model Figure 9
introduce notion unfolding aluni interpretation.
Definition 5.8 Let object-oriented schema, (S ) translation aluni
finite interpretation (S ). call unfolded version interpretation obtained
follows: individual v part bad cycle, unfold bad cycle
(infinite) tree v root, generating new individuals instances
RecType SetType. nonnegative integer m, call m-unfolded version ,
denoted Ijm, interpretation obtained truncating depth infinite tree
generated process unfolding.
Example 5.6 (cont.) Figure 10 shows unfolded version model Figure 9.
Notice bad cycle unfolded infinite tree, arcs labeled
a3 lead o2, instance AbstractClass duplicated.

correctness (S ) sanctioned following proposition.
Proposition 5.9 every object-oriented schema depth m, exist mappings:

1. ffS instances finite interpretations (S ) ffV active values
instances domain elements finite interpretations (S ) that:
legal instance J , ffS (J ) finite model (S ), type
expression v 2 VJ , v 2 J ffV (v) 2 ( (T ))ffS (J ) .

2. fiS finite interpretations (S ) instances fiV domain elements m-unfolded versions finite interpretations (S ) active
values instances , that: finite model (S ), fiS (I ) legal
instance , concept (T ), translation type expression
2 Ijm , 2 ( (T ))Ijm fiV (d) 2 fiS (I ) .

Proof.

follows:

(1) Given database instance J define interpretation ffS (J ) (S )
228

fiUnifying Class-Based Representation Formalisms

ffV function mapping every element VJ distinct element ffS (J ) .
Therefore ffS (J ) defined set elements ffV (v) v 2 VJ . Moreover

denote id, rec, set elements ffS (J ) corresponding object
identifiers, record set values, respectively.
interpretation atomic concepts defined follows:
( (C ))ffS (J ) = fffV (o) j 2 J (C )g;
every (C ) corresponding class name C
AbstractClassffS (J ) = id
RecTypeffS (J ) = rec
SetTypeffS (J ) = set
interpretation atomic roles defined follows:
( (A))ffS (J ) = f(d1 ; d2 ) j d1 2 rec ffV 1 (d1 ) = [ : : : ; A: ffV 1 (d2 ); : : :] g;
every (A) corresponding attribute name

(
J
)

member
= f(d1 ; d2 ) j d1 2 set ffV 1(d1 ) = fj: : : ; ffV 1 (d2 ); : : :jgg

(
J
)
value
= f(d1 ; d2 ) j (ffV 1 (d1 ); ffV 1 (d2 )) 2 J g

prove type v 2 VJ , v 2 J ffV (v) 2
( (T ))ffS (J ) . first part thesis follows definition ffS (J ).
proof induction structure type expression.
Base case: = C (i.e., class1 name). 2 C J ffV (o) 2 ( (C ))ffS (J ) ,
vice-versa 2 ( (C ))ffS (J ) ffV (d) 2 C J .
Inductive case: = Record A1 : T1 ; : : : ; Ak : Tk End (T ) = RecType u
8 (A1 ). (T1 ) u 9=1 (A1 ) u u 8 (Ak ). (Tk ) u 9=1 (Ak ). assume v 2 TiJ
iff ffV (v) 2 ( (Ti ))ffS (J ), 2 f1; : : : ; kg, show v 2 J iff ffV (v) 2 ( (T ))ffJS (J ).
Suppose v 2 J , i.e., v = [ A1 : v1 ; : : : ; Ah: vh] h k vi 2 Ti
2 f1; : : : ; kg. induction hypothesis ffV (vi ) 2 ( (Ti ))ffS (J ) , 2 f1; : : : ; kg,
definition ffS , ffV (v) 2 RecTypeffS (J ) , (ffV (v); ffV (vi )) 2 ( (Ai ))ffS (J ) 2 f1; : : : ; kg,
roles (A) corresponding attribute names functional. Therefore, ffV (v) 2
( (T ))ffS (J ) .
Conversely, suppose = ffV (v) 2 ( (T ))ffS (J ) . Then, 2 f1; : : : ; kg
exactly one di 2 ffS (J ) (d; di ) 2 ( (Ai ))ffS (J ), moreover di 2 ( (T1i ))ffS (J ) .
definition ffS v = [ A1: v1 ; : : : ; AhJ: vh] , h k vi = ffV (di ),
2 f1; : : : ; kg. induction hypothesis vi 2 Ti , 2 f1; : : : ; kg, therefore v 2
(Record A1 : T1 ; : : : ; Ak : Tk End)J .
cases = Union T1; : : : ; Tk End = Set-of 0 treated analogously.
(2) Given finite model (S ) depth m, define legal database instance fiS (I )
follows:
fiV function mapping every element Ijm distinct element VfiS (I )
following conditions satisfied:
{ OfiS (I ) VfiS (I ) set elements fiV (d) 2 AbstractClassIjm .
229

fiCalvanese, Lenzerini, & Nardi

2 RecTypeIjm , (d;Idi ) 2 ( (Ai ))Ijm , 2 f1; : : : ; kg,

individual d0 2 jm attribute A0 (d; d0 ) 2 ( (A0 ))Ijm ,
fiV (d) = [ A1 : fiV (d1 ); : : : ; Ak : fiV (dk )]].
{ 2 SetTypeIjm , (d; di ) 2 memberIjm , 2 f1; : : : ; kg,
individual d0 2 Ijm (d; d0 ) 2 (member)Ijm , fiV (d) =
ffiV (d1 ); : : : ; fiV (dk )g.
every class name C , fiS (I ) (C ) = ffiV (d) j 2 ( (C ))Ijm g.
fiS (I ) = f(o; v) j fiV (d1 ) = o; fiV (d2 ) = v; (d1 ; d2 ) 2 valueIjm g.
first prove concept (T ), translation type expression
, 2 Ijm , 2 ( (T ))Ijm fiV (d) 2 fiS (I ) . proof
induction structure concept expression. inductive part
restrict attention case record types.
Base case: = C (i.e., (T ) atomic
concept).

2 ( (C ))Ijm fiV (d) 2
C fiS (I ) , vice-versa 2 C fiS (I ) fiV 1 (o) 2 ( (C ))Ijm .
Inductive case: (T ) = RecType u 8 (A1 ). (T1 ) u 9=1 (A1 ) u u 8 (Ak ). (ITk ) u
9=1 (Ak ) = Record A1: T1 ; : : : ; Ak : Tk End. assume 2 ( (Ti )) jm iff
fiV (d) 2 TifiS (I ) , 2 f1; : : : ; kg, show 2 ( (T ))Ijm iff fiV (d) 2 fiS (I ) .
Suppose 2 ( (T ))Ijm . 2I RecTypeIjm eachI 2 f1; : : : ; kg
individual di di 2 ( (Ti )) jm (d; di ) 2 ( (Ai )) jm . construction
fiV (d) = [ A1 : v1 ; : : : ; Ah : vh ] h k. Moreover, induction hypothesis fiV (di ) 2
TifiS (I ) therefore fiV (d) 2 fiS (I ) .
Conversely, suppose fiV (d) 2 fiS (I ) , i.e., fiV (d) = [ A1: v1 ; : : : ; Ah: vh ] h k
vi 2 TifiS (I ) 2 f1; : : : ; kg. induction hypothesis di = fiV 1(vi ) 2 ( (Ti ))Ijm ,
2 f1; : : : ; kg, definition fiV , 2 RecTypeIjm (d; di ) 2 ( (Ai ))Ijm ,
2 f1; : : : ; kg. Since roles (A) corresponding attribute names functional,
2 ( (T ))Ijm .
remains show declaration
Class C is-a C1 ; : : : ; Cn type-is
{

DS , (a) C fiS (I ) CifiS (I ) 2 f1; : : : ; ng, (b) fiS (I )(C fiS (I ) ) fiS (I ) .
(a) follows fact (S ) contains assertion (C ) _ (C1 ) u u (Cn )
definition fiS (I ) .
(b) follows shown fact Ijm still satisfies
assertion (C ) _ AbstractClass u 8value. (T ). fact, 2 ( (C ))I let d0
unique individual (d;I d0 ) 2 valueI . Since model (S ), d0 2 ( (T ))I .
argue d0 2 ( (T )) jm . d0 part bad cycle ,
Ijm coincide sub-structure rooted d0 formed individuals reached via
member roles corresponding attributes, done. Otherwise, Ijm
sub-structure expanded finite tree. Since construction depth tree
least depth (T ), connections individuals preserved Ijm,
follows d0 2 ( (T ))Ijm .
230

fiUnifying Class-Based Representation Formalisms

basic reasoning services considered object-oriented databases subtyping
(check whether type denotes subset another type every legal instance) type
consistency (check whether type consistent legal instance). Based Proposition 5.9, show forms reasoning fully captured finite concept
consistency finite concept subsumption aluni knowledge bases.
object-oriented schema, T; 0 two type expressions ,
translation . following holds:

Theorem 5.10 Let

(S )



(S ) 6j=f (T ) ?.
subtype 0 (S ) j=f (T ) (T 0 ).

1. consistent
2.

proof analogous proof Theorem 4.9, makes use Proposition 5.9 instead Proposition 4.8.
Again, correspondence aluni established Theorem 5.10 allows us make
use reasoning techniques developed aluni reason object-oriented schemas.
Observe reasoning object-oriented models already PSPACE-hard (Bergamaschi
& Nebel, 1994) thus known algorithms exponential. However, resorting
aluni, becomes possible take account reasoning various extensions
object-oriented formalism. extensions useful conceptual modeling
already proposed literature (Cattell & Barry, 1997). First all,
considerations developed ER model regard use arbitrary boolean
constructs classes applied object-oriented setting, provides
disjunction admit form negation. Additional features added
object oriented models inverses attributes, cardinality constraints set-valued
attributes, general forms restrictions values attributes.
Proof.

6. Related Work

section brie discuss recent results correspondence class-based
formalisms techniques reasoning aluni class-based representation
formalisms.
6.1 Relationships among Class-Based Formalisms

past several attempts establish relationships among class-based
formalisms. Blasius, Hedstuck, Rollinger (1990), Lenzerini, Nardi, Simi (1991)
carry comparative analysis class-based languages attempt provide unified
view. analysis makes clear several diculties arise identifying common
framework formalisms developed different areas. recent papers address
problem. example, analysis relationships frame-based languages
types programming languages carried Borgida (1992), Bergamaschi
Sartori (1992), Piza, Schewe, Schmidt (1992) use frame-based languages enrich
deductive capabilities semantic object-oriented data models.
231

fiCalvanese, Lenzerini, & Nardi

Artale, Cesarini, Soda (1996) study reasoning object-oriented data models
presenting translation DLs style one discussed Section 5. However,
proposed translation applicable case shema contains recursive
class declarations. limitation present work Bergamaschi Nebel
(1994), formalism derived DLs used model complex objects
algorithm computing subsumption classes provided.
recent survey application DLs problem data management
presented Borgida (1995) . application task data modeling reasoning
techniques derived correspondences presented Sections 4 5 discussed
detail Calvanese, Lenzerini, Nardi (1998).
Recently, proposals integrate object-oriented logic
programming paradigms (Kifer & Wu, 1993; Kifer, Lausen, & Wu, 1995). proposals
however directly related present work, since aim providing mechanisms
computing structured objects, rather means reasoning conceptual
(object-oriented) representation domain interest.
6.2 Reasoning

aluni

Class-Based Representation Formalisms

equipped techniques reason respect unrestricted
respect finite models. brie sketch main ideas underlying reasoning
contexts. detailed account reasoning techniques carried Calvanese
(1996c).
aluni

6.2.1 Unrestricted Model Reasoning

remind reasoning knowledge base respect unrestricted models amounts
check either concept consistency, i.e., determine whether knowledge base admits
(possibly infinite) model given concept nonempty extension, concept
subsumption, i.e., determine whether extension one concept contained extension another concept every model (including infinite ones) knowledge
base.
method reason aluni respect unrestricted models exploits well known
correspondence DLs Propositional Dynamic Logics (PDLs) (Kozen & Tiuryn,
1990), class logics specifically designed reason programs.
correspondence, first pointed Schild (1991), relies substantial
similarity interpretative structures formalisms, allows one exploit
reasoning techniques developed PDLs reason corresponding DLs. particular,
since ALUNI , description language aluni, includes construct inverse roles,
correspondence one resort converse-PDL, variant PDL includes
converse programs (Kozen & Tiuryn, 1990). However, presence number
restrictions ALUNI direct correspondence PDLs, cannot rely
traditional techniques reasoning PDLs. Recently, encoding techniques
developed, allow one eliminate number restrictions knowledge base
preserving concept consistency concept subsumption (De Giacomo & Lenzerini, 1994a).
encoding applicable knowledge bases formulated expressive variants DLs,
particular used reduce unrestricted model reasoning aluni knowledge
232

fiUnifying Class-Based Representation Formalisms

bases (both concept consistency concept subsumption) deciding satisfiability
formula converse-PDL. Reasoning converse-PDL decidable EXPTIME (Kozen &
Tiuryn, 1990), since encoding polynomial (De Giacomo & Lenzerini, 1994a)
obtain EXPTIME decision procedure unrestricted concept consistency concept
subsumption aluni knowledge bases. simplified form encoding,
applied decide unrestricted concept consistency aluni presented
Calvanese et al. (1994).
6.2.2 Finite Model Reasoning

remind reasoning knowledge base respect finite models amounts
check either finite concept consistency finite concept subsumption,
finite models knowledge base must considered.
finite model reasoning, techniques based reduction reasoning PDLs
applicable. Indeed, PDL formula corresponding aluni knowledge base
contains constructs converse programs (corresponding inverse roles)
functionality direct inverse programs, thus formula variant PDL
finite model property (Vardi, 1985). However, encoding
functionality, one obtains converse-PDL formula, since converse-PDL finite
model property (Fischer & Ladner, 1979), formula satisfiable
finitely satisfiable. shows encoding number restrictions (and particular
encoding functionality), preserving unrestricted satisfiability preserve
finite satisfiability (De Giacomo & Lenzerini, 1994a).
finite model reasoning aluni one adopt different technique, based
idea separating reasoning process two distinct phases (see Calvanese, 1996c,
full details). first phase deals constructs except number restrictions,
builds \expanded knowledge base" constructs embedded implicitly
concepts roles. second phase assertions involving number restrictions
used derive expanded knowledge base system linear inequalities.
system defined way solutions certain type (acceptable solutions)
directly related finite models original knowledge base. particular,
acceptable solution one directly deduce cardinalities extensions concepts
roles possible finite model. proposed method allows one establish aluni
EXPTIME decidability finite concept consistency special cases finite concept
subsumption. resorting complicated encoding one obtain 2EXPTIME
decision procedure finite concept subsumption aluni general (Calvanese, 1996a,
1996c).
Reasoning respect finite models investigated context dependency theory databases. shown Casanova, Fagin, Papadimitriou (1984)
relational model, functional inclusion dependencies interact, dependency
implication problem finite case differs one unrestricted case.
implication problem arbitrary functional inclusion dependencies undecidable
(Chandra & Vardi, 1985; Mitchell, 1983), functional unary inclusion dependencies
solvable polynomial time, finite unrestricted case (Cosmadakis
et al., 1990).
233

fiCalvanese, Lenzerini, & Nardi

Consistency respect finite models schemata expressed enriched EntityRelationship model cardinality constraints shown decidable polynomial
time Lenzerini Nobili (1990). Calvanese Lenzerini (1994b) extend decidability result include ISA relationships, Calvanese Lenzerini (1994a) show
EXPTIME decidability reasoning expressive object-oriented model. algorithm
computing refinement ordering types (the analogue concept hierarchy)
framework O2 object oriented model discussed Lecluse Richard (1989).
Reasoning strict sublanguage aluni obtained omitting inverse roles
number restrictions already EXPTIME-hard (Calvanese, 1996b). Therefore, known
algorithms deciding unrestricted concept consistency subsumption finite concept
consistency essentially optimal.
7. Conclusions

presented unified framework representing information class structures
reasoning them. pursued goal looking various class-based
formalisms proposed different fields computer science, namely frame based systems
used knowledge representation, semantic object-oriented data models used
databases, rephrasing framework description logics. resulting description logic, called aluni includes combination constructs addressed
before, although constructs previously considered separately.
major achievement paper demonstration class-based formalisms
given precise characterization means powerful fragment first-order logic,
thus regarded essential core class-based representation formalisms
belonging three families mentioned above. several consequences.
First all, formalisms considered paper enriched constructs
originating formalisms treated general framework. sense,
work reported provides common powerful representation formalism,
may contribute significant developments languages belonging three
families. example, usage inverse roles concept languages greatly enhances
expressivity roles, combination ISA, number restrictions, union enriches
reasoning capabilities available semantic data models.
Secondly, comparison class-based formalisms fields knowledge representation conceptual data modeling makes feasible address development
reasoning tools support conceptual modeling (Calvanese et al., 1998). fact, reasoning capabilities become especially important complex scenarios arising
heterogenous database applications Data Warehousing. line work among
motivations developing systems based expressive description logics (Horrocks,
1998; Horrocks & Patel-Schneider, 1999), lead extending language
description logics support Information Integration and, specifically, conceptual
modeling Data Warehouses (Calvanese, De Giacomo, Lenzerini, Nardi, & Rosati, 1998).
234

fiUnifying Class-Based Representation Formalisms
References

Abiteboul, S., Kanellakis, P., Ramaswamy, S., & Waller, E. (1992). Method schemas. Tech.
rep. CS-92-33, Brown University. earlier version appeared
.
Abiteboul, S., & Kanellakis, P. (1989). Object identity query language primitive.
Proceedings ACM SIGMOD International Conference Management Data,
pp. 159{173.
Abrial, J. R. (1974). Data semantics. Klimbie, J. W., & Koffeman, K. L. (Eds.), Data
Base Management, pp. 1{59. North-Holland Publ. Co., Amsterdam.
Albano, A., Ghelli, G., & Orsini, R. (1991). relationship mechanism strongly typed
Object-Oriented database programming languages. Proceedings Seventeenth International Conference Large Data Bases (VLDB'91), pp. 565{575
Barcelona.
Artale, A., Cesarini, F., & Soda, G. (1996). Describing database objects concept
language environment. IEEE Transactions Knowledge Data Engineering, 8 (2),
345{351.
Atzeni, P., & Parker Jr., D. S. (1986). Formal properties net-based knowledge representation schemes. Proceedings Second IEEE International Conference Data
Engineering (ICDE'86), pp. 700{706 Los Angeles.
Baader, F. (1991). Augmenting concept languages transitive closure roles: alternative terminological cycles. Proceedings Twelfth International Joint
Conference Artificial Intelligence (IJCAI'91) Sydney, Australia.
Baader, F. (1996). Using automata theory characterizing semantics terminological
cycles. Annals Mathematics Artificial Intelligence, 18, 175{219.
Batini, C., Ceri, S., & Navathe, S. B. (1992). Conceptual Database Design, EntityRelationship Approach. Benjamin Cummings Publ. Co., Menlo Park, California.
Bergamaschi, S., & Nebel, B. (1994). Acquisition validation complex object database
schemata supporting multiple inheritance. Applied Intelligence, 4 (2), 185{203.
Bergamaschi, S., & Sartori, C. (1992). taxonomic reasoning conceptual design. ACM
Transactions Database Systems, 17 (3), 385{422.
Blasius, K. H., Hedstuck, U., & Rollinger, C.-R. (Eds.). (1990). Sorts Types Artificial
Intelligence, Vol. 418 Lecture Notes Artificial Intelligence. Springer-Verlag.
Borgida, A. (1992). type systems knowledge representation: Natural semantics
specifications description logics. Journal Intelligent Cooperative Information
Systems, 1 (1), 93{126.
Borgida, A. (1995). Description logics data management. IEEE Transactions Knowledge Data Engineering, 7 (5), 671{682.
Proc. 9th

Symp. Principles Database Systems PODS-90

235

fiCalvanese, Lenzerini, & Nardi

Borgida, A. (1996). relative expressiveness description logics predicate logics.
Artificial Intelligence, 82, 353{367.
Borgida, A., & Weddell, G. E. (1997). Adding functional dependencies description logics.
Proceedings Fifth International Conference Deductive Object-Oriented
Databases (DOOD'97).
Brachman, R. J., & Levesque, H. J. (1984). tractability subsumption frame-based
description languages. Proceedings Fourth National Conference Artificial
Intelligence (AAAI'84), pp. 34{37.
Brachman, R. J., & Levesque, H. J. (Eds.). (1985). Readings Knowledge Representation.
Morgan Kaufmann, Los Altos.
Brachman, R. J., McGuinness, D. L., Patel-Schneider, P. F., Alperin Resnick, L., & Borgida,
A. (1991). Living CLASSIC: use KL-ONE-like language.
Sowa, J. F. (Ed.), Principles Semantic Networks, pp. 401{456. Morgan Kaufmann,
Los Altos.
Bresciani, P., Franconi, E., & Tessaris, S. (1995). Implementing testing expressive
description logics: Preliminary report. Borgida, A., Lenzerini, M., Nardi, D., &
Nebel, B. (Eds.), Working Notes 1995 Description Logics Workshop, Technical
Report, RAP 07.95, Dipartimento di Informatica e Sistemistica, Universita di Roma
\La Sapienza", pp. 131{139 Rome (Italy).
Buchheit, M., Donini, F. M., Nutt, W., & Schaerf, A. (1998). refined architecture
terminological systems: Terminology = schema + views. Artificial Intelligence, 99 (2),
209{260.
Buchheit, M., Donini, F. M., & Schaerf, A. (1993). Decidable reasoning terminological
knowledge representation systems. Journal Artificial Intelligence Research, 1, 109{
138.
Calvanese, D. (1996a). Finite model reasoning description logics. Aiello, L. C., Doyle,
J., & Shapiro, S. C. (Eds.), Proceedings Fifth International Conference
Principles Knowledge Representation Reasoning (KR'96), pp. 292{303. Morgan
Kaufmann, Los Altos.
Calvanese, D. (1996b). Reasoning inclusion axioms description logics: Algorithms
complexity. Wahlster, W. (Ed.), Proceedings Twelfth European Conference Artificial Intelligence (ECAI'96), pp. 303{307. John Wiley & Sons.
Calvanese, D. (1996c). Unrestricted Finite Model Reasoning ClassBased Representation Formalisms.
Ph.D. thesis, Dipartimento di Informatica e Sistemistica, Universita di Roma \La Sapienza". Available
http://www.dis.uniroma1.it/pub/calvanes/thesis.ps.gz.
Calvanese, D., De Giacomo, G., Lenzerini, M., Nardi, D., & Rosati, R. (1998). Description
logic framework information integration. Proceedings Sixth International
236

fiUnifying Class-Based Representation Formalisms
Conference Principles Knowledge Representation Reasoning (KR'98),

pp.
2{13.
Calvanese, D., & Lenzerini, M. (1994a). Making object-oriented schemas expressive.
Proceedings Thirteenth ACM SIGACT SIGMOD SIGART Symposium
Principles Database Systems (PODS'94), pp. 243{254 Minneapolis. ACM Press
Addison Wesley.
Calvanese, D., & Lenzerini, M. (1994b). interaction ISA cardinality
constraints. Proceedings Tenth IEEE International Conference Data
Engineering (ICDE'94), pp. 204{213 Houston (Texas). IEEE Computer Society Press.
Calvanese, D., Lenzerini, M., & Nardi, D. (1994). unified framework class based representation formalisms. Doyle, J., Sandewall, E., & Torasso, P. (Eds.), Proceedings
Fourth International Conference Principles Knowledge Representation
Reasoning (KR'94), pp. 109{120 Bonn. Morgan Kaufmann, Los Altos.
Calvanese, D., Lenzerini, M., & Nardi, D. (1998). Description logics conceptual data
modeling. Chomicki, J., & Saake, G. (Eds.), Logics Databases Information
Systems, pp. 229{264. Kluwer Academic Publisher.
Casanova, M. A., Fagin, R., & Papadimitriou, C. H. (1984). Inclusion dependencies
interaction functional dependencies. Journal Computer System
Sciences, 28 (1), 29{59.
Cattell, R. G. G. (Ed.). (1994). Object Database Standard: ODMG-93. Morgan Kaufmann, Los Altos. Release 1.1.
Cattell, R. G. G., & Barry, D. K. (Eds.). (1997). Object Database Standard: ODMG
2.0. Morgan Kaufmann, Los Altos.
Chandra, A. K., & Vardi, M. Y. (1985). implication problem functional inclusion
dependencies undecidable. SIAM Journal Computing, 14 (3), 671{677.
Chen, P. P. (1976). Entity-Relationship model: Toward unified view data. ACM
Transactions Database Systems, 1 (1), 9{36.
Cosmadakis, S. S., & Kanellakis, P. C. (1986). Functional inclusion dependencies -
graph theoretical approach. Kanellakis, P. C., & Preparata, F. P. (Eds.), Advances
Computing Research, Vol. 3, pp. 163{184. JAI Press.
Cosmadakis, S. S., Kanellakis, P. C., & Vardi, M. (1990). Polynomial-time implication
problems unary inclusion dependencies. Journal ACM, 37 (1), 15{46.
De Giacomo, G., & Lenzerini, M. (1994a). Boosting correspondence description logics propositional dynamic logics. Proceedings Twelfth National
Conference Artificial Intelligence (AAAI'94), pp. 205{212. AAAI Press/The MIT
Press.
237

fiCalvanese, Lenzerini, & Nardi

De Giacomo, G., & Lenzerini, M. (1994b). Concept language number restrictions
fixpoints, relationship -calculus. Proceedings Eleventh European
Conference Artificial Intelligence (ECAI'94), pp. 411{415.
Di Battista, G., & Lenzerini, M. (1993). Deductive entity-relationship modeling. IEEE
Transactions Knowledge Data Engineering, 5 (3), 439{450.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1997). complexity concept
languages. Information Computation, 134, 1{58.
Donini, F. M., Lenzerini, M., Nardi, D., Nutt, W., & Schaerf, A. (1994). Queries, rules
definitions. Foundations Knowledge Representation Reasoning. SpringerVerlag.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1996). Reasoning description
logics. Brewka, G. (Ed.), Principles Knowledge Representation, Studies Logic,
Language Information, pp. 193{238. CSLI Publications.
Donini, F. M., Nardi, D., & Rosati, R. (1995). Non-first-order features concept languages. Gori, M., & Soda, G. (Eds.), Proceedings Fourth Conference
Italian Association Artificial Intelligence (AI*IA'95), Vol. 992 Lecture Notes
Artificial Intelligence, pp. 91{102. Springer-Verlag.
Ferg, S. (1991). Cardinality concepts entity-relationship modeling. Proceedings
Tenth International Conference Entity-Relationship Approach (ER'91), pp.
1{30.
Fikes, R., & Kehler, T. (1985). role frame-based representation reasoning. Communications ACM, 28 (9), 904{920.
Fischer, M. J., & Ladner, R. E. (1979). Propositional dynamic logic regular programs.
Journal Computer System Sciences, 18, 194{211.
Grant, J., & Minker, J. (1984). Numerical dependencies. Gallaire, H., Minker, J., &
Nicolas, J.-M. (Eds.), Advances Database Theory II. Plenum Publ. Co., New York.
Hayes, P. J. (1979). logic frames. Metzing, D. (Ed.), Frame Conceptions Text
Understanding, pp. 46{61. Walter de Gruyter Co. Republished (Brachman &
Levesque, 1985).
Horrocks, I. (1998). Using expressive description logic: FaCT fiction?. Proceedings
Sixth International Conference Principles Knowledge Representation
Reasoning (KR'98), pp. 636{647.
Horrocks, I., & Patel-Schneider, P. F. (1999). Optimizing description logic subsumption.
Journal Logic Computation, 9 (3), 267{293.
Hull, R. B., & King, R. (1987). Semantic database modelling: Survey, applications
research issues. ACM Computing Surveys, 19 (3), 201{260.
238

fiUnifying Class-Based Representation Formalisms

Karp, P. D. (1992). design space knowledge representation systems. Tech. rep. SRI
AI Technical Note 520, SRI International, Menlo Park, CA.
Karp, P. D., Myers, K. L., & Gruber, T. (1995). generic frame protocol. Proceedings
Fourteenth International Joint Conference Artificial Intelligence (IJCAI'95),
Vol. A, pp. 768{774 Montreal, Canada.
Kifer, M., Lausen, G., & Wu, J. (1995). Logical foundations Object-Oriented framebased languages. Journal ACM, 42 (4), 741{843.
Kifer, M., & Wu, J. (1993). logic programming complex objects. Journal
Computer System Sciences, 47, 77{120.
Kim, W. (1990). Introduction Object-Oriented Databases. MIT Press.
Kim, W., & Lochovsky, F. H. (Eds.). (1989). Object-Oriented Concepts, Databases,
Applications. ACM Press Addison Wesley, New York.
Kozen, D., & Tiuryn, J. (1990). Logics programs. van Leeuwen, J. (Ed.), Handbook
Theoretical Computer Science { Formal Models Semantics, pp. 789{840. Elsevier
Science Publishers (North-Holland), Amsterdam.
Lecluse, C., & Richard, P. (1989). Modeling complex structures object-oriented databases.
Proceedings Eighth ACM SIGACT SIGMOD SIGART Symposium Principles Database Systems (PODS'89), pp. 362{369.
Lehmann, F. (Ed.). (1992). Semantic Networks Artificial Intelligence. Pergamon Press,
Oxford.
Lenzerini, M., Nardi, D., & Simi, M. (Eds.). (1991). Inheritance Hierarchies Knowledge
Representation Programming Languages. John Wiley & Sons, Chichester.
Lenzerini, M., & Nobili, P. (1990). satisfiability dependency constraints entityrelationship schemata. Information Systems, 15 (4), 453{461.
Mitchell, J. C. (1983). implication problem functional inclusion dependencies.
Information Control, 56, 154{173.
Motschnig-Pitrik, R., & Mylopoulous, J. (1992). Classes instances. Journal Intelligent Cooperative Information Systems, 1 (1).
Nebel, B. (1991). Terminological cycles: Semantics computational properties. Sowa,
J. F. (Ed.), Principles Semantic Networks, pp. 331{361. Morgan Kaufmann, Los
Altos.
Piza, B., Schewe, K.-D., & Schmidt, J. W. (1992). Term subsumption type constructors. Yesha, Y. (Ed.), Proceedings International Conference Information
Knowledge Management (CIKM'92), pp. 449{456 Baltimore.
239

fiCalvanese, Lenzerini, & Nardi

Schild, K. (1991). correspondence theory terminological logics: Preliminary report.
Proceedings Twelfth International Joint Conference Artificial Intelligence
(IJCAI'91), pp. 466{471 Sydney, Australia.
Schild, K. (1994). Terminological cycles propositional -calculus. Doyle, J.,
Sandewall, E., & Torasso, P. (Eds.), Proceedings Fourth International Conference Principles Knowledge Representation Reasoning (KR'94), pp.
509{520 Bonn. Morgan Kaufmann, Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 1{26.
Sowa, J. F. (Ed.). (1991). Principles Semantic Networks. Morgan Kaufmann, Los Altos.
Teorey, T. J. (1989). Database Modeling Design: Entity-Relationship Approach.
Morgan Kaufmann, Los Altos.
Thalheim, B. (1992). Fundamentals cardinality constraints. Pernoul, G., & Tjoa,
A. M. (Eds.), Proceedings Eleventh International Conference EntityRelationship Approach (ER'92), pp. 7{23. Springer-Verlag.
Thalheim, B. (1993). Fundamentals Entity Relationship Model. Springer-Verlag.
Vardi, M. Y. (1985). taming converse: Reasoning two-way computations.
Parikh, R. (Ed.), Proc. 4th Workshop Logics Programs, Vol. 193
Lecture Notes Computer Science, pp. 413{424. Springer-Verlag.
Woods, W. A., & Schmolze, J. G. (1992). KL-ONE family. Lehmann, F. W. (Ed.),
Semantic Networks Artificial Intelligence, pp. 133{178. Pergamon Press. Published
special issue Computers & Mathematics Applications, Volume 23, Number
2{9.
Ye, X., Parent, C., & Spaccapietra, S. (1994). Cardinality consistency derived objects
DOOD systems. Loucopoulos, P. (Ed.), Proceedings Thirteenth International
Conference Entity-Relationship Approach (ER'94), Vol. 881 Lecture Notes
Computer Science, pp. 278{295 Manchester (UK). Springer-Verlag.

240


