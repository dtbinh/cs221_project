journal artificial intelligence

submitted published

partial order concurrent interacting actions
craig boutilier

cebly cs toronto edu

department computer science
university toronto
toronto h canada

ronen brafman

brafman cs bgu ac il

department computer science
ben gurion university
beer sheva israel

abstract

order generate plans agents multiple actuators agent teams distributed controllers must able represent plan concurrent actions
interacting effects historically considered challenging task requiring
temporal planner ability reason explicitly time
simple modifications
action representation language used represent
interacting actions moreover partial order require small
modifications order applied multiagent domains demonstrate fact
developing sound complete partial order planner concurrent interacting actions pomp extends existing partial order planners straightforward
way open way use partial order planners centralized
control cooperative multiagent systems
strips

introduction
order construct plans agents multiple actuators multi armed robots
agent teams controllers distributed throughout environment must able
model effects interactions multiple actions executed concurrently generate plans take interactions account viable solution basic
multiagent multi actuator map must include economical action descriptions convenient specify easily manipulable
well methods deal interactions generally associated
concurrent actions
surprisingly despite interest multiagent applications instance robotics
donald jennings rus khatib yokoi chang ruspini holmberg casal
baader distributed ai e g see proceedings international
conference multiagent systems large body work distributed multiagent
little addresses basic context
concurrent interacting actions researchers distributed ai considered many central
issues multiagent multiagent interaction much existing
concerned mainly stemming distributed nature systems
task decomposition resource allocation durfee lesser wilkins
myers stone veloso obtaining local plans combine form global plans

c ai access foundation morgan kaufmann publishers rights reserved

fiboutilier brafman

durfee lesser ephrati pollack rosenschein minimizing communication
needs wolverton des jardins donald et al opposed
form distributed focus centralized agent
teams distributed actuators
representation concurrent actions dealt researchers
knowledge representation community e g lin shoham reiter de giacomo
lesperance levesque moses tennenholtz pinto particular
note action languages ac baral gelfond c giunchiglia lifschitz
enable specification concurrent interacting actions employ nonmonotonic override mechanism deduce effects set actions con icting
effects finally number contemporary planners handle concurrent noninteracting
actions certain degree examples include graphplan blum furst ipp
koehler extends graphplan handle resource constraints recently
obdd planners mbp cimatti giunchiglia giunchiglia traverso
umop jensen veloso knoblock provides good discussion
issue parallelizing serial plans
despite advances one often sees community suggestions
temporal planners required adequately deal concurrent interacting actions
example discussion parallel execution plans knoblock asserts
handle cases interacting actions requires introduction
explicit representation time provided temporal systems
similar perspective seems implicit work parallel action execution presented
lingard richards certainly time plays role planner
idea sequences actions occur embodies implicit notion time however
disagree time centralized multiagent must dealt explicit
fashion single agent main aim demonstrate
map solved simple extensions existing single agent planners
ucpop penberthy weld provide representation map
requires explicit representation time deny explicit temporal
representations useful many may necessary
think key bottleneck activities multiagent teams
specifically view temporal issues orthogonal main concerns facing multiagent

central issue multiagent lies fact individual agent actions
interact sometimes hindered action interaction action x
agent might destroy intended effect action agent executed concurrently
example half duplex communication line cannot allow simultaneous transmission
messages sides case make sure
x executed time interesting fact
often benefits action interaction action x agent might achieve
intended effect agent performs action concurrently example opening typical
door requires two simultaneous actions turning knob pushing door military
activities different units may coordinate actions order effective e g


fiplanning concurrent interacting actions

turn engines lights simultaneously attack time similar situations
arise variety domains cases ensure
appropriate actions executed time action representation makes
interactions explicit interactions
prescribe certain actions must must executed concurrently
main features multiagent planner temporal representations may play role
scheduling actions strictly necessary reasoning effects
interaction lack thereof
illustrate issues consider following example discussed
detail later two agents must move large set blocks one room
another could pick block separately better solution would use
existing table following manner first agents put blocks table
lift one side table however must lift table simultaneously
otherwise one side table lifted blocks fall lifted
table must move room put table fact
depending precise goal effects actions may better one agent drop
side table causing blocks slide notice generating
plan requires agents coordinate two different ways first must lift
table together blocks fall later one one must drop
side table let blocks fall
since actions distinct agents interact cannot general specify effects
individual actions without taking account actions might performed
agents time truly concurrent actions often desirable precludes
oft used trick interleaving semantics reiter de giacomo et al agents
lifting table number items must simultaneously risk
items sliding table perhaps causing damage interleaving individual lift side
table actions
one way handle action interactions specify effects joint actions directly
specifically let ai set actions available agent assuming n agents labeled
n let joint action space treat element
space separate action specify effects favorite action representation
main advantage reduction scheme resulting
tackled standard however serious drawbacks
respect ease representation first number joint actions increases exponentially number agents severe implications specification
process second reduction fails exploit fact substantial fraction individual actions may interact least interact certain
conditions would representation actions multiagent multi actuator settings
exploits independence individual action effects whatever extent possible
instance lift actions two agents may interact many actions
e g one agent lifting table another picking block hence need
discussion center strips action representation similar considerations apply
representations situation calculus mccarthy hayes reiter dynamic bayes
nets dean kanazawa boutilier goldszmidt



fiboutilier brafman

explicitly consider combinations actions specify certain individual
effects separately combining effects needed
joint actions cause process use context
planners forces seems excessive degree commitment whenever
individual action agent accomplish desired effect must insert
plan joint action thereby committing agents specific actions executed
concurrently even though actual choices may irrelevant reasons desire
distributed representation actions
therefore faced following two
representation naturally concisely represent interactions
among concurrently executed actions
plan context representation
strips action representation augmented
handle concurrent interacting actions existing nonlinear planners adapted
handle actions fact might come surprise solving
requires small number changes existing nonlinear planners ucpop
penberthy weld main addition strips representation action
concurrent action list describes restrictions actions cannot
executed concurrently order specified effect indeed number
different conditional effects depending concurrent actions applied order
handle richer language must make number modifications standard
partial order planners add equality respectively inequality constraints action
orderings enforce concurrency respectively nonconcurrency constraints b
expand definition threats cover concurrent actions could prevent intended
action effect
emphasize deal activities multiple agents
agents multiple actuators centralized fashion opposed distributed model assumes one available central controller decide
appropriate joint plan communicate plan individual agents actuators
distributed important dicult addressed
work assume mechanism available individual agents
ensure execution concurrent plans synchronized
issue significance subtlety task consider
note parallel actions addressed detail lingard
richards specifically provide general framework understanding
constraint posting least commitment planners allow concurrent action execution
however mentioned work takes explicit temporal view
focuses primarily issues action duration furthermore
multiagent could presumably made fit within model seems
main motivation fact discuss deal
issue ensuring parallel actions negative synergistic effects explicitly
moreover e g blum furst kautz selman prove
amenable extension concurrent interacting actions similar ideas



fiplanning concurrent interacting actions

exclude possibility positive synergy work abstract away temporal
component focus precisely presence synergies positive
negative
following section describe strips style representation concurrent
interacting actions multiagent plans section describe partial order multiagent pomp modified version ucpop
used generate plans multiagent teams multiactuator devices section illustrates
pomp extended example section discuss soundness
completeness pomp conclude section discussion
issues raised work

representing concurrent actions plans

begin considering representation concurrent actions partially ordered plans
simple extension traditional representations first describe standard action representation strips model specifically used ucpop
penberthy weld describe extension representation represent concurrent interacting actions semantics finally describe representation
semantics partially ordered multiagent plans

strips action representation

variants strips action representation language fikes nilsson
employed many systems assume finite set predicates domain
objects generally typed characterize domain question states system
truth assignments ground atomic formulae language state represented
set conjunction ground atoms true state
f

ontable b holding b g

thus embodying closed world assumption reiter actions induce state transitions
viewed partial mappings states states action represented
precondition effect conjunction literals sometimes referred
precondition effect list state satisfy conjunction literals
precondition list effect applying action undefined otherwise
state resulting performing action determined deleting current state
description negative literals appearing effect list adding positive
literals appearing effect list
example action picking particular block b oor described
figure usual lisp style notation many systems action
executed agent hand empty block b clear oor
action executed agent hand longer empty holds b b
oor
since action picking block location essentially regardless
particular block location whole class actions described
action schema operator free variables denoting object picked


fiboutilier brafman

define action pickup block b floor
precondition floor b handempty clear b
effect
handempty floor b holding b

figure pickup block b oor action
define operator pickup
parameters
x
precondition x handempty clear x x
effect
handempty x holding x

figure pickup action schema
pickup location action schema specification similar specification single
action except use free variables precondition list action schema
contain along predicates precisely proposition schemata equality
inequality constraints variables
figure illustrates action schema pickup action two variables x
stand object picked location object respectively
precondition list includes requirements x hand empty
x clear x designate different objects e one cannot pickup
object atop
strips representation enhanced obtaining expressive language
allows form universal quantification action description e g ucpop
penberthy weld addition conditional effects captured
clause consisting antecedent consequent semantics action description
similar original semantics except states satisfy preconditions
action antecedent clause actual effect action union
standard effect specified effect list consequent clause
clause change expressiveness language conditional
action description expressed separate non conditional actions classic
strips representation capture clause however allows economical natural specification actions example classic strips blocks world
putting block b destination block b block b longer clear however
putting b table table remains clear hence different putdown schema
required describe moving block table clause use single
schema conditional effect modifies standard effect action case
destination table e clause state destination
table become unclear addition conditional effects may allow us postpone
commitment e g may decide put block
commit whether destination table

representing concurrent actions strips

introduction concurrent interacting actions requires us address two issues specific
multiagent setting performing action actions


fiplanning concurrent interacting actions

define operator pickup
parameters
x
precondition x handempty clear x x
concurrent
pickup x
effect
handempty x holding x

figure multiagent pickup schema
performed time first deal identity performing agent
introducing agent variable action schema schema instantiated
variable bound constant denoting particular agent carrying action
second must take account fact action particular effect
certain actions may may performed concurrently capture constraints
adding concurrent action list existing precondition effect lists specification action concurrent action list list action schemata negated action
schemata partially instantiated action schema appears
concurrent action list action instance schema must performed
concurrently action order intended effect action schema
appears negated concurrent action list action instance schema
performed concurrently action prescribed effect
concurrent action list similar precondition list following sense
constraints specifies environment action performed
satisfied action effects specified effect list notice positive
action schemata implicitly existentially quantified one instance schema must
occur concurrently whereas negated action schema implicitly universally quantified
instance schema performed concurrently
schema appearing concurrent action list schema partially instantiated constrained contains free variables appearing parameter list
variables must instantiated instantiated addition constraints
restrict possible instantiations schema appear within concurrent
action list seen description multiagent setting version action
pickup shown figure multiagent pickup schema additional parameter
signifying performing agent list preconditions effects similar
single agent pickup schema concurrent action list
pickup x

prefix restricts set actions performed concurrently
instance schema pickup x particular disallow concurrent execution
instance schema pickup x different
agent attempt pickup object x time
representation represent actions whose effects modified
concurrent execution actions example suppose agent lifts
one side table blocks dumped onto oor long agent
lifts side agent lift side table
effect simply raise side table clearly distinguish two


fiboutilier brafman

define operator lower
parameters

precondition holding raised
effect
raised
forall x
ontable x
lower
onfloor x ontable x

figure lower action schema
cases concurrency conditions lift side lift side
however treating standard concurrency conditions essentially splits action
two separate actions similar effects single agent representations treat
modifiers clause antecedent clause two
parts list additional preconditions list additional concurrency conditions
general form clause antecedent effect antecedent
consists two parts preconditions concurrency constraints latter list
form concurrent action list similar semantics thus
whenever precondition part antecedent satisfied current state
concurrency condition satisfied actions executed concurrently actual effect
action obtained conjoining standard effect consequent
clause
syntax clauses illustrated table lowering action described figure notice operator contains universally quantified effect effect
form forall x effect x allows us state conditional effect
described clause applies object x satisfies precondition e g
every object table case use universally quantified conditional effects
finite domains well understood see weld discussion however simplify
presentation treat formally
lower one side table side longer raised addition
object table lowering one side table cause object fall
long side table lowered time use
universal quantification describe fact happen object
table notice concurrent part antecedent see constrained schema
stipulates additional effect e objects falling oor
table occur instance schema lower executed concurrently
different
action description clause one clause multiple
clauses latter case preconditions clauses must disjoint
one might insist set clauses exhaustive well however
certain cases might insist agents perform one action time
agent multiple effectors take one example might able lower one sides
concurrently see
case multiple clauses disjointness restriction relaxed effects independent
much bayes net action description boutilier goldszmidt



fiplanning concurrent interacting actions

require clause satisfied action performed assume
additional effect null effect action simply given main
effect list discuss clauses specific action formal definitions
generally assume existence implicit clause whose precondition
consists negation preconditions explicitly specified clauses whose
effect list empty allows definitions stated concisely

semantics concurrent action specifications

semantics individual actions course different multiagent setting
single agent case individual actions transform one state world
another state world rather joint actions define state transitions joint
actions describe set individual actions could ops performed
agents n tuples individual actions
given joint action ha ani refer individual actions ai elements
say concurrent action list element ai satisfied respect
every positive schema list contains element aj j
instance every negative schema list none elements
aj j n instance ignoring moment existence clauses
define notion joint action consistency straightforward manner

definition let joint action individual action ai contains
h





clause say consistent





precondition lists pi ai jointly logically consistent e
contain proposition negation
effect lists ei ai jointly consistent
concurrent action list element satisfied w r

given state consistent joint action ha executed
precondition lists elements satisfied resulting state obtained
taking union effect lists elements applying
single agent case fact consistent joint action viewed single agent
action whose preconditions union preconditions ai whose
effects union effects ai
notice semantics joint action inconsistent individual action
causes q true another b causes q false responsibility
axiomatizer domain recognize con icts state true
effect b performed concurrently imposing conditional effects concurrent action conditions disallow concurrent execution imposing nonconcurrency
conditions
assume clause ever explicitly constructed purposes merely
conceptual device
one easily preprocess actions descriptions order check consistency actions b
discovered con icting effects specification allows executed concurrently
could automatically add nonconcurrency constraint action description thus



fiboutilier brafman

clauses definition consistency bit involved consistent joint
actions without clauses applied consistently possible states
applicable contrast joint actions clauses may consistent
applied states inconsistent others given joint action ha ani
specific state exactly one clause action ai satisfied
one clause preconditions concurrency constraints satisfied thus
joint action state together determine conditional effects selected

definition given joint action state active clause wi
h





ai relative unique clause satisfied e
whose preconditions satisfied whose concurrency constraints satisfied


thus relativize notion consistency case

definition let joint action individual actions ai may contain
h





clauses let state let wi active clause ai w r
let wi preconditions wpi concurrency constraints wci effects wei
say consistent state





precondition lists pi active preconditions wpi ai mutually consistent
effect lists ei active effects wei ai mutually consistent
concurrent action list element satisfied w r

note require concurrent action lists clauses satisfied
since selected note definition reduces whenless
definition individual actions clauses action consistent respect
iff consistent original sense
given state joint action ha ani involving clauses consistent
respect executed precondition lists elements satisfied
resulting state obtained taking union effect lists
elements together effect lists active clauses applying

several interesting issues arise specification actions multiple agents first
assume throughout rest agent perform one action
time possible concurrent actions must performed distinct agents
allows action descriptions simpler otherwise might single
agent perform one action time captured group
agents denoting different actuators agents perform certain actions
preventing arising process would valid b could
fact meaningfully performed concurrently important domain
axiomatizer specify true interacting effect e g maybe action dominates note
automatic inconsistency detection repair admits certain additional degree convenience
domain specification
assume implicit clause corresponding negation explicitly stated clauses described




fiplanning concurrent interacting actions

concurrently captured adding extra concurrency constraints generally
different agents may different capabilities would useful ability
explicitly specify capabilities form constraints types actions
different agents execute one way handle constraints via preprocessing
step augments action descriptions additional preconditions concurrency
conditions capture constraints alternative alter
take constraints account explicitly simple constraints
instance fact n agents might imply n actions executed
concurrently done simple ecient manner
take develop section however capability
constraints complex former method seems better
another issue must addressed precise effect joint action one
whose individual actions negates precondition concurrently executed individual
action make special allowances simply retaining semantics described
complicate definition joint actions note
combinations may make sense example concurrent writing variable p
q variable q p computer program might seen action destroying
preconditions yet net effect individual actions simply swap
values hence certain circumstances may acceptable describe actions
way others may true effect joint action
treat issue several ways allow specification actions design
planner excludes combinations forming concurrent plans unless
explicit concurrency condition given means axiomatizer need think
interactions allow combinations general explicitly exclude
problematic cases adding nonconcurrency constraints
finally undesirable though theoretically unproblematic situation arise
provide incongruous concurrency lists example may require action concurrent b order particular effect b may required nonconcurrent
span set actions two elements naturally hence
b cannot occur together consistent joint action would able achieve
intended effect although planner eventually recognize fact
specifications lead unnecessary backtracking process
something easily detected preprocessor generally assume
concurrency lists congruous

concurrent plan representation
moving discuss process describe representation multiagent plans rather straightforward extension standard single agent partially
ordered plan representations single agent nonlinear plan consists set action
instances strict ordering constraints relations ordering actions codesignation non codesignation constraints values
variables appearing actions forcing different values
respectively weld penberthy weld plan sort represents set
possible linearizations set totally ordered plans formed action instances


fiboutilier brafman

violate ordering codesignation non codesignation constraints
say plan consistent linearization set linearizations seen
semantics nonlinear plan sense consistent nonlinear plan satisfies
goal set g given starting state linearization guaranteed satisfy g
concurrent nonlinear plan n agents labeled n similar consists set
action instances agent arguments though necessarily instantiated together
set arbitrary ordering constraints actions e
usual codesignation non codesignation constraints unlike single agent nonlinear plans
allow equality inequality ordering constraints concurrent nonconcurrent
execution pair actions imposed semantics must allow concurrent
execution actions n agents end extend notion linearization
definition let p concurrent nonlinear plan agents n n linearization
p sequence joint actions ak agents n
individual action instance p member exactly one joint action ai
individual action occurs ak p individual
op actions
codesignation non codesignation constraints p respected
ordering constraints p respected precisely individual
action instances b p joint actions aj ak b
occur ordering constraints b true aj ak
af gb j f gk
words actions p arranged set joint actions ordering
individual actions satisfies constraints synchronization ensured ops
note set k actions allowed executed distinct
agents ordering constraints set linearizations includes short plan
single joint action k actions executed concurrently different agents
assuming k n strung plan k actions executed one time
single agent others nothing different agents take turns
individual actions longer plans stretched even joint ops anything


example suppose planner outputs following plan group three agents
set actions

f

b c e f

g

ordering constraints

e b c e f

f



g

numerical arguments denote agent performing action joint actions
involve one action three agents simple linearization plan
depicted first linearization figure n denote ops
concurrent execution considered context non interacting actions see knoblock
discussion issue knoblock



fiplanning concurrent interacting actions

time











time







agent



e

n

n

n

agent



e

n

agent

n

b

c

n

f

agent

c

b

f

agent

n

n

n



n

agent

n



n

linearization

linearization

figure two possible linearizations partially ordered multiagent plan
corresponding agents
h

ha

n

n

e

b

n

hn


c

n

hn


n



hn


f

n

insert additional tuples form hn n n location
wish another possible linearization second figure

c n e b n f n

h

h

h



fact shortest linearization plan
definition n linearization requires agent perform one action
time conforms assumption made last section though definition could quite easily relaxed allow ops n linearizations
correspond shortest plans concurrently nonconcurrently executed
senses term however relatively easy matter sweep concurrent nonlinear plan construct shortest n linearization one fewest joint
actions taking least amount time though explicit notion
time sequence joint actions n linearization implicitly determines time line
along agent must execute individual actions fact concurrency
nonconcurrency constraints enforced linearizations ensure plan coordinated synchronized note order execute plan coordinated
fashion agents need synchronization mechanism issue dealt


concurrent actions

figure present pomp version weld pop weld
modified handle concurrent actions keep discussion simple begin
describing pomp without considering conditional action effects describe
simple modifications required add conditionals e build analog cpop
though discuss universal quantification could easily
extended handle universally quantified effects much way penberthy
weld full ucpop


fiboutilier brafman

pomp ha l nc b agenda
termination agenda empty return ha l nc b
goal selection let hq aneed pair agenda aneed action q conjunct
precondition list
action selection let aadd choose action one whose effects unifies q subject constraints b may newly instantiated action action already
ordered consistently prior aneed action exists return failure let
q g form b adding b codesignation constraints needed
l l faadd
need
order force aadd desired effect let faadd aneed g aadd newly
instantiated faadd g fa aadd g otherwise let
concurrent action selection aadd newly instantiated apply following steps positive
actions ffconc concurrent list let aconc choose newly instantiated action
action already ordered consistently concurrently aadd make sure
free agent perform action concurrently aadd concurrently
scheduled actions action exists return failure let faconc aneedg
aconc newly instantiated faadd g fa aconc g otherwise
let aadd agent variable aadd aconc agent variable aconc
add aadd aconc b well similar non codesignation constraints actions
aadd
apply step aconc needed
every negative action conc aadd concurrent list let nc nc fa conc aadd g add
b codesignation constraints associated conc
updating goal state let agenda agenda fhq aneedig
aadd newly instantiated add fhqj aaddig agenda every qj logical precondition aadd add preconditions b additional concurrent actions added add
preconditions well
causal link protection every action might threaten causal link ap r ac perform one
demotion add ap
b weak promotion add ac agent perform concurrently ac add
ac instead
neither constraint consistent return failure
nonconcurrency enforcement every action threatens nonconcurrency constraint
e instance schema violate constraint b add consistent
constraint
demotion add
b promotion add
neither constraint consistent return failure
recursive invocation pomp ha l nc b agenda


































































figure partially ordered multiagent



fiplanning concurrent interacting actions

assume existence function mgu q r b returns general
unifier literals q r respect codesignation constraints b
used wherever unification action schemata required see action selection step
figure discussion nc threats number input
variables set contains action instances inserted plan far set
contains ordering constraints elements set l contains causal links set
nc contains nonconcurrency constraints set b contains current codesignation
constraints set nc appear pop contains elements
form action schema action instance
intuitively nonconcurrency constraint form requires action instance
matches schema subject non codesignation constraints appear
concurrently plan
agenda set pairs form hq ai listing preconditions q
achieved yet actions require initially sets l nc b
empty contains two fictitious actions initial
state propositions effects goal state conditions preconditions
agenda contains pairs hq q one conjuncts description
goal state specification initial agenda identical used pop
weld finally note choose operator appears action
selection concurrent action selection steps denotes nondeterministic choice
device used pop make specification independent
search strategy actually used intuitively complete planner require
one search nondeterministic choices backtracking lead failure
many structures algorithmic steps pomp correspond exactly
used pop rather describe detail focus discussion elements
pomp differ pop apart additional data structure nc mentioned
one key difference additional concurrent action selection step pomp
takes care concurrency requirements newly instantiated action
one final key distinction notion threat used pomp general
used pop much pop given plan ha l nc say
q fa g consistent q
threatens causal link ap
c
p

c

effect threats handled demotion much pop weak promotion
latter differs standard promotion technique used pop allows
ordered concurrently ac ac
apart handling conventional threats different manner another form
threat concurrent plans namely nc threats say action instance threatens
nonconcurrency constraint ac fat ac g consistent instantiation
violate codesignation constraints demotion promotion
used handle nc threats conventional threats notice
although set nc contains negative inequality constraints ultimately
grounded set positive constraints following suggested weld
wish exclude actions negate precondition another concurrent action see discussion
section must use fap ac g definition threat must change weak
promotion standard promotion



fiboutilier brafman

consider action threat variables consistently
instantiated manner would remove threat
pomp must check consistency ordering constraints several
places action selection action chosen achieve effect must consistently ordered consumer effect concurrent action selection
concurrency requirement added plan must tested consistency
nonconcurrency enforcement demotion promotion used ensure
nonconcurrency requirements violated consistency testing set ordering
constraints similar employed pop see weld nice discussion one key difference existence equality inequality ordering
constraints opposed simple strict inequalities e however minor
modifications standard consistency checking strict ordering constraints
used equality dealt simply merging actions must occur concurrently e treating single action purposes consistency testing
inequalities easily handled assuming actions occur different points whenever
possible non strict inequalities e arise directly
though two easily dealt refer ghallab alaoui
details processing constraints
pomp described easily modified handle conditional effects
pop extended cpop main fact note
action selection phase use action whose conditional effects achieve chosen
subgoal case add preconditions selected action
agenda antecedent particular conditional effect ensure
action particular effect handle additional concurrency conditions
antecedent much regular concurrency conditions cpop
must consider possibility particular conditional effect added action
threatens established causal link case aside existing
threat resolution techniques consider form confrontation add negation
conditional effect antecedent agenda several ways
could add negation literal antecedent condition agenda
add concurrent action negate negative concurrency condition
antecedent post nonconcurrency constraint offset positive concurrency constraint
antecedent details steps straightforward look similar
involved unconditional

example pomp
section formalize example alluded introduction describe
construction concurrent plan pomp
initial state two agents agent agent located room together
table set blocks scattered around room goal ensure
blocks room table oor order simplify example
assume one block b omit certain natural operators simplify action
descriptions order compactly represent multiple block version would
require introduction universal quantification shown weld


fiplanning concurrent interacting actions

done little diculty intuitively agents gather blocks room
case one put table carry table room dump
blocks table put table best plan
single block illustrates plan would constructed multiple blocks
case strategy better agents making multiple trips carrying
individual blocks use following actions







pickup b agent picks block b
putdown b agent puts block b table
totable agent moves side left right table
movetable r agent moves room r table
lift agent lifts side table
lower agent lowers side table

variables type agent b variables type block r variables type room
variables type table side omit natural actions since
used plan interest
domain described following predicates









ontable b block b table
onfloor b block b oor
atside agent side left right table
side table raised
side table oor
inroom x r object x agent block table room r
handempty hand agent empty
holding x agent holding x block side table

operator descriptions defined figure
initial state
inroom b room onfloor b inroom agent room inroom agent room
inroom table room leftside rightside g

f

goal propositions
inroom b room onfloor b leftside rightside g

f

consider concurrent nonlinear plan multiagent
might generated pomp


fiboutilier brafman

define operator pickup
parameters
x
precondition inroom r inroom x r
handempty onfloor x
concurrent
pickup x
effect
handempty onfloor x holding x
define operator putdown
parameters
x
precondition
inroom r inroom x r inroom table r
holding x
concurrent
lift
effect
holding x ontable x handempty
define operator totable
parameters

precondition inroom r inroom table r atside
concurrent
totable
effect
atside

define operator movetable
parameters
r
precondition holding table
concurrent
movetable r
effect
inroom r table inroom r
ontable x inroom r x
define operator lower
parameters

precondition holding
concurrent
lift
effect
holding
ontable x
lower
onfloor x ontable x
define operator lift
parameters

precondition atside
concurrent
lower
effect
holding
ontable x
lift
onfloor x ontable x

figure table movers domain



fiplanning concurrent interacting actions

suppose inroom b room first goal selected achieved performing movetable room via conditional effect note agent variable commitment agent performs action must add
holding table ontable b agenda insert appropriate causal links
addition concurrent list forces us add action movetable room
plan together non codesignation constraint ordering constraint
added well add must add precondition holding table
agenda well structure partially constructed plan might viewed
follows
inroom block r



goal

movetable r



c

movetable r

next choose subgoal ontable b agenda added
add action putdown b plan appropriate ordering constraint
preconditions added agenda causal link added l
addition must add nc nonconcurrency constraint lift agent
lift side table block placed desired effect
achieved
inroom block r

ontable block


putdown block



movetable r

goal

c



movetable r

pursue notion heuristics action selection note action
plausible candidate selection multi block setting goal list asserts number
blocks second room single action moving table achieve
appropriate conditions e blocks table action selection favors conditional
actions achieve goals subgoals action considered actions needed
one one transport blocks individual agents choice silly might
seem single block setting
plan diagrams follow indicate actions ai name action variables
indicated lower case names indicate co designation constraints diagrams
arrow one action another denotes causal link producer consumer labeled
proposition produced large arrows labeled c resp nc denote concurrency resp
nonconcurrency constraints actions use left right ordering denote temporal
ordering actions constraints exist



fiboutilier brafman

choose subgoal holding table achieved
lift ordering constraint preconditions added
agenda concurrency conditions added yet action since
yet need invoke conditional effects action induced simultaneous lifting
side table
holding table


lift ls

inroom block r

nc ontable block





putdown block

goal

movetable r
c



movetable r

note conditional effect poses threat causal link ontable

lifting single side table dump block table
addition nonconcurrency constraint associated lifting performed
concurrently threatened nc threat indicated plan diagram
confrontation strategy used handle first threat action
lift scheduled concurrently constraints
imposed ensures undesirable effect occur resolve nc threat
ordering resulting partially completed plan free threats
holding table


lift ls

inroom block r
ontable block


putdown block

c



movetable r

goal

c





lift rs

movetable r

next choose subgoal leftside achieved action
lower leftside preconditions added agenda completely similar
way lower rightside added achieve rightside anticipate
unification agent variables
anticipation subsequent step use variable plan diagram instead since
soon unified keep things concrete replaced particular sides
table leftside rightside make discussion bit less convoluted



fiplanning concurrent interacting actions


lower ls
ls



holding table

lift ls
ontable block

inroom block r





putdown block c

movetable r

goal

c





lift rs

movetable r



rs

lower rs

choose work preconditions preconditions
holding effects lift use producers
stage constrained follow constraints
relative ordering see
potentially threaten causal link ontable

conditional
effect would cause block fall table several ways resolve
two threats including confrontation choose strict promotion order
occur
holding ls
ls




lower ls

holding table

ls

lift ls
ontable block





putdown block

c


lift rs

inroom block r



movetable r

goal

c



movetable r

rs


lower rs
rs
holding rs

choose subgoal onfloor b conditional effect lower
action choose accomplish existing action order obtain
desired effect ensure antecedent clause effect holds involves
adding conditions antecedent ontable b leftside agenda
imposing nonconcurrency constraint antecedent namely concurrent
lower action take place constraint threatened action order


fiboutilier brafman

posting constraint conditions antecedent
ontable b leftside use producers respectively
ontable block
holding ls
ls




lower ls

holding table

ls
onfloor block

lift ls
ontable block





putdown block

c

inroom block r



movetable r

goal

c
holding table

lift rs
movetable r



rs


rs

lower rs

holding rs

unsolved subgoal precondition initial putdown b action
others leftside lift action produced initial state
illustrate simple matter introduce pickup b action
putdown b
following plan first block picked put table
agent agent agent followed two concurrent
lift actions two concurrent move actions get table room
block top next single lower action makes block fall followed
another lower action ensures sides table oor
note plan care agents one lifts leftside
rightside initially puts block table

soundness completeness pomp
say sound generates plans guaranteed
achieve goals posed complete guaranteed generate plan
successful plan exists case concurrent nonlinear plans say
sound n linearization plan produced given
reach goal state complete successfully generates concurrent
nonlinear plan whenever sequence joint actions e n linearization
ordering could used resolve threat would cause unresolvable threat conditions antecedent require side remain
course unresolvable sense would require agents pick block etc
essentially introducing cycle plan
examples map plans produced pomp code implementing pomp
obtained http www cs bgu ac il ishayl project
formal definitions concepts refer reader penberthy weld



fiplanning concurrent interacting actions

concurrent plan achieves goal initial state pomp
sound complete
soundness proof straightforward suppose generated plan sound
thus n linearization plan achieve goal required subgoal
e precondition one plan actions agenda mechanism
clear needed goal precondition exists action plan
achieves subgoal goal precondition moreover explicit causal link
plan particular subgoal well ordering constraint requiring
producing action appear prior consuming action goal n linearization
plan another plan obtained original plan adding consistent strict
e ordering constraints recall original plan ordering constraints must
consistent otherwise would constitute solution
threats clearly adding strict ordering constraints cannot cause threats
causal links violate nonconcurrency constraint hence resulting n linearization
respects causal links original plan ordering constraints original plan
complete proof must convinced pomp actually considers possible
relevant interactions actions consider effect p action needed
action b ordered given semantics actions two reasons
p hold prior execution b action c b possibly
concurrent effect p actually p effect case
contradicts fact threats extended sense covering possibility
c occurring concurrently context plan case implies
p effect subject concurrency nonconcurrency condition violated
n linearization would taken care action
selection nonconcurrency enforcement steps ordering constraints
thus clear n linearization plan produced pomp fact
achieve goals pomp sound
completeness proof rests three key elements
reduction multiagent single agent
fact pomp solve multiagent iff pop solve
single agent obtained via reduction
fact pop sound complete penberthy weld
first given multiagent similar single agent
obtained shall refer generated equivalent single
agent esa reduction property plan
multiagent exists plan esa exists
introduction discussed reduction via use joint actions
use similar idea little care pomp pop perform
similar steps solution original esa respectively
combining fact pop sound complete deduce
pomp sound complete well


fiboutilier brafman

discussion ignore conditional effects avoid undue
part uninteresting complications extension arguments deal conditional
effects straightforward first recall following facts relevant argument
pop pomp nondeterministic although
ways making deterministic issue orthogonal
proof thus showing correspondence pop pomp alluded
point utilize exibility awarded us planner
use nondeterministic choice particular sucient
given solution path one planner similar solution path exists
b choice next agenda element work immaterial pop
pomp affect running time e g causing backtracking
existence solution hence exible ordering subgoals
achieved long respect causality e cannot achieve goal
derived precondition action introduced yet
c introducing additional ordering constraints consistent current constraints
valid plan obtain valid plan given
precise order actions ordering constraints inserted
affect validity solution fact well known
community one postpone threat resolution step without affecting
soundness completeness long threats eventually
resolved
proof proceed two stages first stage limit
restricted set connections pop
straightforward fashion relax restriction correspondence
two planners general case
recall section suggested possible restriction set actions one
allowed execute concurrently namely two actions b permitted
occur concurrently one effects negate preconditions remarked
concurrent non clobbering condition enforced action specification
easily enforced pomp modify definition threat
use promotions instead weak promotions resolve threats let us restrict attention
time domains respecting condition
first note following fact let pomp plan consider nlinearization occur concurrently
future actions require effects produced concurrent execution actions
actions forced occur concurrently plan case
similar n linearization ordered vice versa
ordering constraints violated linearization must exist achieve
goal case might happen one clobbers
preconditions explicitly disallowed restricted setting
imposition nonconcurrency constraint precondition


fiplanning concurrent interacting actions

consider esa actions available agent follows
individual action concurrency constraints multiagent
create action corresponding joint action performed owning
agent ops executed every agent individual action
concurrency conditions requiring actions b bk executed concurrently
create action corresponding joint action bi performed
actions apart ops performed note nonconcurrency
constraints ignored esa definition
clearly joint action sequence exists given exists concurrent nonlinear plan addition argument involving
assumption concurrent action clobber another precondition easy
see concurrent nonlinear plan found exists
concurrent nonlinear plan concurrency constraints involve actions whose
specification requires concurrent execution another action set actions order
obtain particular effect implies solvable solvable
sequence joint actions type constructed single agent individual actions together set ops involving minimal sets interacting
actions words concurrent nonlinear plan exists given iff plan
esa exists note structure solution esa
linearization nonlinear single agent plan esa specific
actions occur concurrently forced words solutions esa
strung plans agents take turns performing actions
next want restricted setting pomp solution path given
pop solution path esa resemble
becomes apparent combine pomp action selection concurrent action selection
steps obtain step equivalent action selection step pop esa
e whenever pomp chooses action requires another concurrent action
required concurrent action immediately inserted well equivalent inserting
proper esa action fact pop pomp look almost identical except
pomp nonconcurrency enforcement step however fashion
esa defined nonconcurrency constraints automatically imposed
plan produced pop since refer different joint actions linearization
joint actions enforces nonconcurrency joint actions therefore
single agent actions occur together pop solution esa
occur together nonconcurrency constraint
fact actions explicit concurrency constraint
argument demonstrates pop pomp generate identical sets
plans except two small differences first pomp semantics allows concurrent
execution certain actions even though need executed concurrently order
important note single action schema gives rise n individual actions one
agent e g lift agent lift agent distinct actions separate joint actions
created similarly concurrency conditions involve action schemata permitted
combination agent instantiations give rise distinct joint action
assumes concurrency lists congruous described section simple
redefinition esa given incongruous concurrent actions admitted



fiboutilier brafman

solve pop esa cannot generate plans admit
however difference cannot affect completeness argument since means
pomp exible pop second pomp commits particular ordering
actions nonconcurrency constraint pop make
commitment orderings consistent however consistent remain
unordered final plan esa choice pomp makes cannot
impact solution pomp produce alternative ordering matter
fact pop sound complete virtual equivalence pomp
pop steps facts strung plans esa see pomp
sound complete special case concurrent actions destroy
preconditions
finally wish remove restrictions placed concurrent actions admit
concurrent action clobber precondition another note
type exist cannot solved strung plan sense defined
instance consider following two actions


action precondition p effect q



action b precondition q effect p

actions b nonconcurrency constraints thus required
concurrent specified effects considered isolation suppose initial
state fp qg goal state f p qg plan achieves goal requires
b executed concurrently order one destroy
ability perform second goal reachable thus pomp solve
pop could solve esa formulated
deal general case extend construction esa
including addition actions used restricted case joint action esa
set actions satisfying following conditions


element permitted executed concurrently need forced
concurrent



element clobbers precondition element



element removed without destroying property

words create joint action corresponding concurrent execution
element set call self clobbering joint actions evident
concurrent nonlinear plan exists arbitrary multiagent iff
exists sequence joint actions allowing self clobbering actions solve
hence soundness completeness pop iff pop plan
generalized esa already seen pomp emulate step pop
additional exibility impacts soundness pomp addressed fact
could used current line reasoning part integrated soundness completeness proof
pop pomp correspondence case would need explain last point
hinder soundness pomp



fiplanning concurrent interacting actions

involving actions self clobbering actions simply pomp
emulate pop introduction self clobbering actions completeness
let self clobbering joint action claim pop complete
generalized esa ever considers adding incomplete plan
elements ai effect satisfies subgoal agenda suppose
contrary ai consumer current agenda
necessary successful plan since subset actions used
actions consume effects ai yet introduced discount
former case considering executions pop use action pop
complete even action never considered since able introduce
individual components concurrent subsets produce necessary effects
discount latter case since must valid execution pop introduces
ultimate consumers element ai introducing thus without loss
generality assume element ai satisfies subgoal agenda
introduced pop
suppose pop introduces self clobbering action since ai satisfy
agenda item pomp simulate step follows introduce ai turn satisfy
agenda item postponing threat resolution among ai resolve self threats among
ai weak promotion causal link protection step impose
ordering constraint ai aj ai threatens aj example instance
actions b added achieve subgoals q p respectively way
resolve mutual threat weak promotion actions impose b
b words forced concurrent thus introduction
self clobbering joint action pop assumptions stated strong
correspondence sequence possible steps pomp since pop
plan assumptions pomp thus completeness pomp
general case arbitrary multiagent demonstrated

concluding remarks
one often finds assertions literature interacting actions
inherently problematic affair requiring substantial extension existing single agent
representations thus somewhat surprising minor
changes needed enable strips action representation language capture interacting actions relatively small modifications existing nonlinear planners
required generate concurrent plans solution involves addition concurrent
action list standard action description specifying actions
scheduled concurrently current action order achieve desired effect
pop planner augmented two steps one handles insertion required
concurrent actions one handles threats emanating potential concurrent
execution two interfering actions addition explicit reasoning equality inequality constraints introduced strong resemblance solution
multiagent case solution single agent case little overhead incurred
actions interact fact extreme case non interacting actions
extension strips pop reduce single agent equivalents


fiboutilier brafman

close connection specification method knoblock
generating parallel execution plans knoblock adds action description
list describes resources used action actions require resource
e g access database cannot scheduled time hence knoblock
resource list actually characterizes one form nonconcurrency constraint fact
believe certain nonconcurrency constraints naturally described
resource list general method proposed augmenting language
lists prove dicult
treatment concurrent actions specification languages ac baral gelfond c giunchiglia lifschitz many features common
extension strips although c particular expressive language many
additional features languages allow use complex actions sets
primitive actions analogous ability provide combine number elements
joint action typically complex actions inherit effects primitive actions contained however explicit specification effects complex actions
possible overriding inheritance overriding mechanism extend arbitrary
number levels e g action effect overridden b
performed concurrently effect overridden c performed well
etc action description languages implicit view time adopted much
treatment concurrent actions assumed performed simultaneously quite recently tools actually synthesizing plans domains described
languages c however recent progress model techniques led
number including sat encoding language c giunchiglia

effects one agent actions depend actions performed agents
time action specification becomes complex task strips representation
useful admits relatively simple however despite strips
semantic adequacy ability principle represent set actions verifying
domain description accurate becomes dicult interactions must taken
account consequently believe use dynamic bayes nets conjunction
conditional outcome probability trees boutilier goldszmidt provide
natural concise representation actions multiagent settings specification
technique makes clear uence different context conditions action effects
allows one exploit independence different effects representation
used stochastic domains dynamic bayes nets offer advantages even
case purely deterministic actions pomp naturally extends form
domain description complete treatment issue would interesting
direction future
adapting existing nonlinear planners handle interacting actions conceptually
simple expect increase domain complexity inevitably lead poor computational performance indeed experiments pomp
found performance greatly affected ordering agenda items hence adequate
heuristics making choices planner faced namely choosing sub principle nonconcurrency constraint handled manner introducing fictitious
resources



fiplanning concurrent interacting actions

goals choosing actions achieve choosing threat resolution strategies
become even critical course issues central single agent nonlinear
planners though anticipate multiagent case interacting actions
require different additional heuristics
interesting topic future work would extending newer
graphplan blum furst handle multiagent representation language
indeed model cimatti et al seems offer promising developments direction naturally representational issues raised arise
regardless particular used although different implications
example question whether allow concurrent actions destroy
one another preconditions affected threat removal operators valid pomp
whereas graphplan would affect definition interfering actions consequently question actions considered mutually exclusive
finally note considered suitable team agents
common set goals assumes central entity generates plan
agents access global clock synchronization mechanism
typically case single agent multiple effectors applies certain
cases truly distributed systems important issue plans
generated executed distributed fashion execution
coordinated controlled important question answers
emerged dai literature des jardins durfee ortiz jr wolverton grosz
hunsberger kraus des jardins wolverton boutilier brafman
halpern shoham distributed systems literature fagin halpern moses
vardi

acknowledgments
thanks referees suggestions presentation ideas mike
wellman helpful comments thank daniel fogel ishay levy igor razgon
implementation pomp boutilier supported nserc grant ogp nce iris ii program project ic brafman supported paul ivanier center robotics nce iris ii program project ic much
work undertaken authors university british columbia
department computer science preliminary presented
concurrent interacting actions proceedings fourteenth national
conference artificial intelligence aaai providence ri pp

references
baral c gelfond reasoning effects concurrent actions journal
logic programming
blum l furst l fast graph analysis proceedings
fourteenth international joint conference artificial intelligence pp
montreal


fiboutilier brafman

boutilier c learning coordination multiagent decision processes
proceedings sixth conference theoretical aspects rationality
knowledge pp amsterdam
boutilier c sequential optimality coordination multiagent systems
proceedings sixteenth international joint conference artificial intelligence
pp stockholm
boutilier c goldszmidt frame bayesian network action
representations proceedings eleventh biennial canadian conference
artificial intelligence pp toronto
brafman r halpern j shoham knowledge requirements
tasks artificial intelligence
cimatti giunchiglia e giunchiglia f traverso p via model
checking decision procedure ar proceedings fourth european conference ecp pp toulouse
de giacomo g lesperance levesque h j reasoning concurrent
execution prioritized interrupts exogenous actions situation calculus
proceedings fifteenth international joint conference artificial intelligence
pp nagoya
dean kanazawa k persistence probabilistic projection ieee trans
systems man cybernetics
des jardins e durfee e h ortiz jr c l wolverton j survey
distributed continual ai magazine
des jardins e wolverton j coodinating distributed system
ai magazine
donald b r jennings j rus information invariants cooperating
autonomous mobile robots proceedings international symposium robotics
hidden valley pa
durfee e h lesser v r negotiating task decomposition allocation
partial global huhns gasser l eds distributed ai vol
morgan kaufmann
durfee e h lesser v r partial global coordination framework distributed hypothesis formation ieee transactions system man
cybernetics
ephrati e pollack e rosenschein j tractable heuristic maximizes global utility plan combination proceedings first international conference multiagent systems pp san francisco


fiplanning concurrent interacting actions

fagin r halpern j moses vardi reasoning knowledge
mit press cambridge
fikes r nilsson n strips application theorem
proving solving artificial intelligence
ghallab alaoui managing eciently temporal relations
indexed spanning trees proceedings eleventh international joint conference
artificial intelligence pp detroit
giunchiglia e satisfiability expressive action languages concurrency constraints nondeterminism proceedings seventh international
conference principles knowledge representation reasoning kr pp
breckenridge co
giunchiglia e lifschitz v action language causal explanation
preliminary report proceedings fifteenth national conference artificial
intelligence pp madison wi
grosz b j hunsberger l kraus acting together ai
magazine
jensen r veloso obdd universal synchronized
agents non deterministic domains journal artificial intelligence

kautz h selman b pushing envelope propositional logic
stochastic search proceedings thirteenth national conference artificial
intelligence pp portland
khatib yokoi k chang k ruspini holmberg r casal baader
force strategies cooperative tasks multiple mobile manipulation systems
giralt g hirzinger g eds robotics seventh international
symposium pp springer verlag berlin
knoblock c generating parallel execution plans partial order planner
proceedings second international conference ai systems pp
chicago
koehler j resource constraints proceedings thirteenth
european conference artificial intelligence pp brighton uk
lin f shoham concurrent actions situation calculus proceedings
tenth national conference artificial intelligence pp san jose
lingard r richards e b parallel actions artificial intelligence

mccarthy j hayes p philosophical standpoint
artificial intelligence machine intelligence


fiboutilier brafman

moses tennenholtz multi entity machine intelligence
penberthy j weld ucpop sound complete partial order planner
adl proceedings third international conference principles knowledge
representation reasoning kr pp cambridge
pinto j concurrent actions interacting effects proceedings sixth
international conference principles knowledge rerpresentation reasoning
kr pp trento
reiter r closed world databases gallaire h minker j eds logic
databases pp plenum york
reiter r frame situation calculus simple solution sometimes completeness goal regression lifschitz v ed artificial
intelligence mathematical theory computation papers honor john mccarthy pp academic press san diego
reiter r natural actions concurrency continuous time situation calculus proceedings fifth international conference principles knowledge
representation reasoning kr pp
stone p veloso task decomposition dynamic role assignment lowbandwidth communication real time strategic teamwork artificial intelligence

weld introduction least commitment ai magazine

wilkins e myers k l multiagent architecture proceedings
fourth international conference ai systems pp pittsburgh
wolverton j des jardins controlling communication distributed irrelevance reasoning proceedings fifteenth national conference
artificial intelligence pp madison wi




