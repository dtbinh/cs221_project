Journal Artificial Intelligence Research 14 (2001) 105{136

Submitted 3/00; published 4/01

Partial-Order Planning Concurrent Interacting Actions
Craig Boutilier

cebly@cs.toronto.edu

Department Computer Science
University Toronto
Toronto, ON, M5S 3H8, Canada

Ronen I. Brafman

brafman@cs.bgu.ac.il

Department Computer Science
Ben-Gurion University
Beer Sheva, Israel 84105

Abstract

order generate plans agents multiple actuators, agent teams, distributed controllers, must able represent plan using concurrent actions
interacting effects. historically considered challenging task requiring
temporal planner ability reason explicitly time. show
simple modifications,
action representation language used represent
interacting actions. Moreover, algorithms partial-order planning require small
modifications order applied multiagent domains. demonstrate fact
developing sound complete partial-order planner planning concurrent interacting actions, POMP, extends existing partial-order planners straightforward
way. results open way use partial-order planners centralized
control cooperative multiagent systems.
STRIPS

1. Introduction
order construct plans agents multiple actuators (such multi-armed robots),
agent teams, controllers distributed throughout environment, must able
model effects interactions multiple actions executed concurrently, generate plans take interactions account. viable solution basic
multiagent/multi-actuator planning (MAP) problem must include economical action descriptions convenient specify easily manipulable planning algorithms,
well planning methods deal interactions generally associated
concurrent actions.
Surprisingly, despite interest multiagent applications|for instance, robotics
(Donald, Jennings, & Rus, 1993; Khatib, Yokoi, Chang, Ruspini, Holmberg, Casal, &
Baader, 1996) distributed AI (e.g., see various proceedings International
Conference Multiagent Systems)|and large body work distributed multiagent
planning, little research addresses basic problem planning context
concurrent interacting actions. Researchers distributed AI considered many central
issues multiagent planning multiagent interaction, much existing research
concerned mainly problems stemming distributed nature systems,
task decomposition resource allocation (Durfee & Lesser, 1989; Wilkins &
Myers, 1998; Stone & Veloso, 1999), obtaining local plans combine form global plans

c 2001 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBoutilier & Brafman

(Durfee & Lesser, 1991; Ephrati, Pollack, & Rosenschein, 1995), minimizing communication
needs (Wolverton & des Jardins, 1998; Donald et al., 1993), on. opposed
form distributed planning, focus paper centralized planning agent
teams (or distributed actuators).
Representation concurrent actions dealt various researchers
knowledge-representation community (e.g., Lin & Shoham, 1992; Reiter, 1996; de Giacomo,
Lesperance, & Levesque, 1997; Moses & Tennenholtz, 1995; Pinto, 1998). particular
note action languages Ac (Baral & Gelfond, 1997) C (Giunchiglia & Lifschitz,
1998) enable specification concurrent interacting actions employ nonmonotonic override mechanism deduce effects set actions con icting
effects. Finally, number contemporary planners handle concurrent noninteracting
actions certain degree|examples include Graphplan (Blum & Furst, 1995), IPP
(Koehler, 1998), extends Graphplan handle resource constraints, recently
OBDD-based planners MBP (Cimatti, Giunchiglia, Giunchiglia, & Traverso, 1997)
UMOP (Jensen & Veloso, 2000)|while Knoblock (1994) provides good discussion
issue parallelizing serial plans.
Despite advances, one often sees planning community suggestions
temporal planners required adequately deal concurrent interacting actions.
example, discussion parallel execution plans, Knoblock (1994) asserts:
handle cases [of interacting actions] requires introduction
explicit representation time, provided temporal planning systems.
similar perspective seems implicit work parallel action execution presented
Lingard Richards (1998). Certainly time plays role planning|in planner
idea sequences actions occur embodies implicit notion time. However,
disagree time centralized multiagent planning must dealt explicit
fashion single-agent planning. main aim paper demonstrate
MAP problem solved using simple extensions existing (single-agent) planners
UCPOP (Penberthy & Weld, 1992). provide representation MAP algorithm
requires explicit representation time. deny explicit temporal
representations useful planning|for many problems may necessary|but
think key bottleneck planning activities multiagent teams.
Specifically, view temporal issues orthogonal main concerns facing multiagent
planning.
central issue multiagent planning lies fact individual agent actions
interact. Sometimes planning hindered result action interaction: action X
agent 1 might destroy intended effect action agent 2 executed concurrently.
example, half-duplex communication line, cannot allow simultaneous transmission
messages sides. case, planning algorithm make sure
X executed time. interesting fact planning
often benefits result action interaction: action X agent 1 might achieve
intended effect agent 2 performs action concurrently. example, opening typical
door requires two simultaneous actions: turning knob pushing door. military
activities, different units may coordinate actions order effective (e.g.,
106

fiPlanning Concurrent Interacting Actions

turn engines lights simultaneously, attack time). Similar situations
arise variety domains. cases, planning algorithm ensure
appropriate actions executed time. action representation makes
interactions explicit planning algorithm can, result interactions,
prescribe certain actions must must executed concurrently
main features multiagent planner. Temporal representations may play role
scheduling actions, strictly necessary reasoning effects
interaction (or lack thereof).
illustrate issues, consider following example discussed
detail later paper: two agents must move large set blocks one room
another. could pick block separately, better solution would use
existing table following manner. First, agents put blocks table,
lift one side table. However, must lift table simultaneously;
otherwise, one side table lifted, blocks fall off. lifted
table, must move room. put table down. fact,
depending precise goal effects actions, may better one agent drop
side table, causing blocks slide once. Notice generating
plan requires agents coordinate two different ways: first, must lift
table together blocks fall; later, one (and one) must drop
side table let blocks fall.
Since actions distinct agents interact, cannot, general, specify effects
individual's actions without taking account actions might performed
agents time. truly concurrent actions often desirable precludes
oft-used trick \interleaving semantics" (Reiter, 1996; de Giacomo et al., 1997). Agents
lifting table number items must simultaneously risk
items sliding table, perhaps causing damage. Interleaving individual \lift side
table" actions do.
One way handle action interactions specify effects joint actions directly.
specifically, let Ai set actions available agent (assuming n agents labeled
1 : : :n), let joint action space A1 A2 . treat element
space separate action, specify effects using favorite action representation.1
main advantage reduction scheme resulting planning problem
tackled using standard planning algorithm. However, serious drawbacks
respect ease representation. First, number joint actions increases exponentially number agents. severe implications specification
planning process. Second, reduction fails exploit fact substantial fraction individual actions may interact all, least interact certain
conditions. would representation actions multiagent/multi-actuator settings
exploits independence individual action effects whatever extent possible.
instance, lift actions two agents may interact, many actions
(e.g., one agent lifting table another picking block). Hence, need
1. discussion center STRIPS action representation, similar considerations apply
representations situation calculus (McCarthy & Hayes, 1969; Reiter, 1991) dynamic Bayes
nets (Dean & Kanazawa, 1989; Boutilier & Goldszmidt, 1996).

107

fiBoutilier & Brafman

explicitly consider combinations actions, specify certain individual
effects separately, combining effects \as needed."
Joint actions cause problems planning process itself: use context
planners forces seems excessive degree commitment. Whenever
individual action agent accomplish desired effect, must insert
plan joint action, thereby committing agents specific actions executed
concurrently, even though actual choices may irrelevant. reasons, desire
\distributed" representation actions.
therefore faced following two problems:
1. representation problem: naturally concisely represent interactions
among concurrently executed actions.
2. planning problem: plan context representation.
paper, show STRIPS action representation augmented
handle concurrent interacting actions existing nonlinear planners adapted
handle actions. fact, might come surprise solving problems
requires small number changes existing nonlinear planners, UCPOP
(Penberthy & Weld, 1992).2 main addition STRIPS representation action
concurrent action list: describes restrictions actions (or cannot)
executed concurrently order specified effect (indeed, number
different conditional effects depending concurrent actions applied). order
handle richer language, must make number modifications \standard"
partial-order planners: (a) add equality (respectively, inequality) constraints action
orderings enforce concurrency (respectively, nonconcurrency) constraints; (b)
expand definition threats cover concurrent actions could prevent intended
action effect.
emphasize deal problem planning activities multiple agents
agents multiple actuators centralized fashion, opposed distributed planning. model assumes one available central controller decide
appropriate joint plan communicate plan individual agents (or actuators).
distributed planning important dicult problem, problem addressed
work. assume mechanism available individual agents
ensure execution concurrent plans synchronized. Again,
issue significance subtlety, task consider paper.
note planning parallel actions addressed detail Lingard
Richards (1998). Specifically, provide general framework understanding
constraint-posting, least-commitment planners allow concurrent action execution.
However, mentioned above, work takes explicit temporal view problem
focuses primarily issues action duration. Furthermore,
multiagent planning could presumably made fit within model, seems
main motivation. fact, planning algorithms discuss deal
issue ensuring parallel actions negative synergistic effects, explicitly
2. Moreover, planning algorithms (e.g., Blum & Furst, 1995; Kautz & Selman, 1996) prove
amenable extension planning concurrent interacting actions using similar ideas.

108

fiPlanning Concurrent Interacting Actions

exclude possibility positive synergy. work, abstract away temporal
component focus precisely planning presence synergies, positive
negative.
following section describe STRIPS-style representation concurrent,
interacting actions multiagent plans. Section 3 describe Partial-Order Multiagent Planning algorithm (POMP), modified version UCPOP algorithm
used generate plans multiagent teams multiactuator devices. Section 4 illustrates
POMP algorithm extended example. Section 5 discuss soundness
completeness POMP algorithm. conclude Section 6 discussion
issues raised work.

2. Representing Concurrent Actions Plans

begin considering representation concurrent actions partially ordered plans
using simple extension traditional planning representations. first describe standard action representation based STRIPS model, specifically used UCPOP
(Penberthy & Weld, 1992). describe extension representation represent concurrent interacting actions semantics, finally describe representation
semantics partially ordered multiagent plans.

2.1 STRIPS Action Representation

Variants STRIPS action representation language (Fikes & Nilsson, 1971)
employed many planning systems. assume finite set predicates domain
objects (generally typed) characterize domain question. States system
truth assignments ground atomic formulae language. state represented
set (or conjunction) ground atoms true state,
f

OnTable(B 1); Holding(A; B 2)g

thus embodying closed world assumption (Reiter, 1978). Actions induce state transitions
viewed partial mappings states states. action represented
using precondition effect, conjunction literals (sometimes referred
precondition effect list). state satisfy conjunction literals
precondition list, effect applying action undefined. Otherwise,
state resulting performing action determined deleting current state
description negative literals appearing effect list adding positive
literals appearing effect list.
example, action picking particular block B oor described
Figure 1, using usual LISP-style notation many planning systems. action
executed agent's hand empty block B clear oor.
action executed, agent's hand longer empty (it holds B ), B
oor.
Since action picking block location essentially same, regardless
particular block location, whole class actions described using
action schema operator free variables denoting object picked
109

fiBoutilier & Brafman

(define (action pickup-block-B-from-floor)
:precondition (and (on floor B) (handempty) (clear B))
:effect
(and (not (handempty)) (not (on floor B)) (holding B))))

Figure 1: Pickup-block-B-from- oor action
(define (operator pickup)
:parameters
(?x ?y)
:precondition (and (on ?x ?y) (handempty) (clear ?x) (not (= ?x ?y)))
:effect
(and (not (handempty)) (not (on ?x ?y)) (holding ?x))))

Figure 2: Pickup action schema
pickup location. action schema specification similar specification single
action except use free variables. precondition list action schema
contain, along predicates (or precisely, proposition \schemata"), equality
inequality constraints variables.
Figure 2 illustrates action schema pickup action. two variables, ?x
?y , stand object picked location object, respectively.
precondition list includes requirements ?x ?y , hand empty,
?x clear, ?x ?y designate different objects (i.e., one cannot pickup
object atop itself).
STRIPS representation enhanced, obtaining expressive language
allows form universal quantification action description (e.g., UCPOP
Penberthy & Weld, 1992). addition, conditional effects captured using
clause consisting antecedent consequent. semantics action description
similar original semantics except states satisfy preconditions
action antecedent clause, actual effect action union
\standard" effect specified effect list consequent clause.
clause change expressiveness language|each conditional
action description expressed using separate non-conditional actions classic
STRIPS representation capture clause. However, allows economical natural specification actions. example, classic STRIPS blocks world,
putting block B1 destination block B2 , block B2 longer clear. However,
putting B1 table, table remains clear. Hence, different putdown schema
required describe moving block table. Using clause, use single
schema conditional effect modifies standard effect action case
destination table (i.e., clause state destination
table, become unclear). addition, conditional effects may allow us postpone
commitment planning (e.g., may decide put block down, don't
commit whether destination table not).

2.2 Representing Concurrent Actions STRIPS

introduction concurrent interacting actions requires us address two issues specific
multiagent setting: performing action, actions
110

fiPlanning Concurrent Interacting Actions

(define (operator pickup)
:parameters
(?a1 ?x ?y)
:precondition (and (on ?x ?y)(handempty ?a1) (clear ?x)(not (= ?x ?y)))
:concurrent
(not (and (pickup ?a2 ?x ?y) (not (= ?a1 ?a2))))
:effect
(and (not (handempty ?a1)) (not (on ?x ?y)) (holding ?a1 ?x)))

Figure 3: multiagent Pickup schema
performed time. First, deal identity performing agent
introducing agent variable action schema. schema instantiated,
variable bound constant denoting particular agent carrying action.
Second, must take account fact action particular effect,
certain actions may may performed concurrently. capture constraints
adding concurrent action list existing precondition effect lists specification action. concurrent action list list action schemata negated action
schemata, partially instantiated. action schema A0 appears
concurrent action list action instance schema A0 must performed
concurrently action order intended effect. action schema A0
appears negated concurrent action list action instance schema A0
performed concurrently action prescribed effect.
concurrent action list similar precondition list following sense:
constraints specifies environment action performed
satisfied, action effects specified effect list. Notice positive
action schemata implicitly existentially quantified|one instance schema must
occur concurrently|whereas negated action schema implicitly universally quantified|
instance schema performed concurrently.
schema A0 appearing concurrent action list schema partially instantiated constrained: A0 contains free variables appearing parameter list A,
variables must instantiated instantiated A. addition, constraints
restrict possible instantiations schema appear within concurrent
action list. seen description multiagent setting version action
pickup shown Figure 3. multiagent pickup schema additional parameter, ?a1,
signifying performing agent. list preconditions effects similar
single-agent pickup schema, concurrent action list:
(not (and (pickup ?a2 ?x ?y) (not (= ?a1 ?a2))))

\not" prefix restricts set actions performed concurrently
instance schema Pickup(?a1; ?x; ?y ). particular, disallow concurrent execution
instance schema Pickup(?a2; ?x; ?y ) ?a2 different ?a1.
is, agent attempt pickup object ?x time.
Using representation, represent actions whose effects modified
concurrent execution actions. example, suppose agent a1 lifts
one side table blocks dumped onto oor long agent
a2 lifts side; agent a2 lift side table
effect simply raise side table. Clearly, distinguish two
111

fiBoutilier & Brafman

(define (operator lower)
:parameters
(?a1 ?s1)
:precondition (and (holding ?a1 ?s1) (raised ?s1))
:effect
(and (not (raised ?s1))
(forall ?x
(when ((ontable ?x)
(not (and (lower ?a2 ?s2)(not (= ?s1 ?s2)))))
(and (onfloor ?x) (not (ontable ?x)))))))

Figure 4: Lower action schema
cases using concurrency conditions (not (lift ?a2 ?side)) (lift ?a2 ?side).
However, treating standard concurrency conditions essentially splits action
two separate actions similar effects. single-agent representations, treat
\modifiers" using clause; now, antecedent clause two
parts: list additional preconditions list additional concurrency conditions.
general form clause (when antecedent effect), antecedent
consists two parts: (preconditions concurrency-constraints). latter list
form concurrent-action list, similar semantics. Thus,
whenever precondition part antecedent satisfied current state
concurrency condition satisfied actions executed concurrently, actual effect
action obtained conjoining standard effect consequent
clause.
syntax clauses illustrated table-lowering action described Figure 4. Notice operator contains universally quantified effect, is, effect
form (forall ?x (effect ?x)). allows us state conditional effect,
described clause, applies object ?x satisfies precondition (e.g.,
every object table case). use universally quantified conditional effects
finite domains well understood (see Weld's (1994) discussion). However, simplify
presentation, treat formally paper.
lower one side table, side longer raised. addition,
object table, lowering one side table cause object fall,
long side table lowered time. Here, use
universal quantification describe fact happen object
table. Notice concurrent part antecedent see constrained schema
again. stipulates additional effect (i.e., objects falling oor
table) occur instance schema lower(?a2; ?s2) executed concurrently,
?s1 different ?s2.3
action description clause, one clause, multiple
clauses. latter case, preconditions clauses must disjoint.4
One might insist set clauses exhaustive well; however,
3. certain cases might insist ?a1 6=?a2, agents perform one action time.
agent multiple effectors (to take one example) might able lower one sides
concurrently. See this.
4. case multiple clauses, disjointness restriction relaxed effects independent,
much Bayes net action description (Boutilier & Goldszmidt, 1996).

112

fiPlanning Concurrent Interacting Actions

require this. clause satisfied action performed, assume
\additional" effect null; is, effect action simply given main
effect list. discuss clauses specific action formal definitions
below, generally assume existence implicit clause whose precondition
consists negation preconditions explicitly specified clauses, whose
effect list empty. allows definitions stated concisely.5

2.3 Semantics Concurrent Action Specifications

semantics individual actions is, course, different multiagent setting
single-agent case. individual actions transform one state world
another state world. Rather joint actions define state transitions. Joint
actions describe set individual actions (some could no-ops) performed
agents; is, n-tuples individual actions.
Given joint action = ha1 ; ; ani, refer individual actions ai elements
a. say concurrent action list element ai satisfied respect
when, every positive schema list, contains element aj (j 6= i)
instance A, every negative schema A0 list, none elements
aj (1 j n) instance A0. Ignoring moment existence clauses,
define notion joint action consistency straightforward manner:

Definition Let = a1; ; joint action individual action ai contains
h





clause. say consistent





precondition lists pi ai jointly (logically) consistent (i.e.,
contain proposition negation).
effect lists ei ai jointly consistent.
concurrent action list element satisfied w.r.t. a.

Given state s, consistent joint action = ha1; ; executed
precondition lists elements satisfied s. resulting state obtained
taking union effect lists elements applying s,
single-agent case. fact, consistent joint action viewed single-agent
action whose preconditions union preconditions various ai whose
effects union effects ai .
Notice semantics, joint action inconsistent individual action
causes Q true, another b causes Q false. responsibility
axiomatizer planning domain recognize con icts either state true
effect b performed concurrently (by imposing conditional effects concurrent action conditions) disallow concurrent execution (by imposing nonconcurrency
conditions).6
5. assume clause ever explicitly constructed planning purposes|it merely
conceptual device.
6. One easily preprocess actions descriptions order check consistency. actions b
discovered con icting effects, specification allows executed concurrently,
algorithm could automatically add nonconcurrency constraint action description, thus

113

fiBoutilier & Brafman

clauses definition consistency bit involved. Consistent joint
actions without clauses applied consistently possible states (if
applicable all). contrast, joint actions clauses may consistent
applied states, inconsistent others. Given joint action = ha1 ; ; ani
specific state s, exactly one clause action ai satisfied; is,
one clause preconditions concurrency constraints satisfied.7 Thus
joint action state together determine conditional effects selected.

Definition Given joint action = a1; ; state s, active clause wi
h





ai relative (unique) clause satisfied (i.e.,
whose preconditions satisfied whose concurrency constraints satisfied
a).

thus relativize notion consistency case.

Definition Let = a1; ; joint action (where individual actions ai may contain
h





clauses). Let state, let wi active clause ai (w.r.t. s,
a), let wi preconditions wpi, concurrency constraints wci, effects wei.
say consistent state if:





precondition lists pi active when-preconditions wpi ai mutually consistent.
effect lists ei active when-effects wei ai mutually consistent.
concurrent action list element satisfied w.r.t. a.

Note require concurrent action lists clauses satisfied,
since \selected" a. Note definition reduces \whenless"
definition individual actions clauses|an action consistent respect
iff consistent original sense.
Given state s, joint action = ha1 ; ; ani (involving clauses) consistent
respect executed precondition lists elements satisfied
s. resulting state obtained taking union effect lists
elements a, together effect lists active clauses, applying
s.
Several interesting issues arise specification actions multiple agents. First,
assume throughout rest paper agent perform one action
time, possible concurrent actions must performed distinct agents.
allows action descriptions simpler otherwise might. single
agent perform one action time, captured using group
\agents" denoting different actuators. agents perform certain actions
preventing problems arising planning process. would valid b could
not, fact, (meaningfully) performed concurrently. can, important domain
axiomatizer specify true interacting effect (e.g., maybe action dominates). note
automatic inconsistency detection repair admits certain additional degree convenience
domain specification.
7. assume implicit clause corresponding negation explicitly stated clauses described
above.

114

fiPlanning Concurrent Interacting Actions

concurrently, captured adding extra concurrency constraints. generally,
different agents may different capabilities, would useful ability
explicitly specify capabilities form constraints types actions
different agents execute. One way handle constraints via preprocessing
step augments action descriptions additional preconditions concurrency
conditions capture constraints. alternative alter planning algorithm
take constraints account explicitly. simple constraints|for
instance, fact n agents might imply n actions executed
concurrently|this done simple ecient manner. approach
take planning algorithm develop Section 3. However, capability
constraints complex, former method seems better.
Another issue must addressed precise effect joint action, one
whose individual actions negates precondition concurrently executed individual
action. make special allowances this, simply retaining semantics described
above. complicate definition joint actions, note
combinations may make sense. example, concurrent writing variable p
q variable q p computer program might seen action destroying
preconditions other; yet net effect individual actions simply swap
values. Hence, certain circumstances, may acceptable describe actions
way, others may true effect joint action. Again,
treat issue several ways: allow specification actions design
planner excludes combinations forming concurrent plans unless
explicit concurrency condition given (this means axiomatizer need think
interactions); allow combinations, general, explicitly exclude
problematic cases adding nonconcurrency constraints.
Finally, undesirable (though theoretically unproblematic) situation arise
provide \incongruous" concurrency lists. example, may require action concurrent b order particular effect, b may required nonconcurrent
(this span set actions two elements, naturally). Hence,
b cannot occur together consistent joint action, would able achieve
intended effect a. Although planner eventually \recognize" fact,
specifications lead unnecessary backtracking planning process. Again,
something easily detected preprocessor, generally assume
concurrency lists congruous.

2.4 Concurrent Plan Representation
moving discuss planning process, describe representation multiagent plans, rather straightforward extension standard single-agent, partially
ordered plan representations. (single-agent) nonlinear plan consists of: (1) set action
instances; (2) various strict ordering constraints using relations < > ordering actions; (3) codesignation non-codesignation constraints values
variables appearing actions, forcing different values,
respectively (Weld, 1994; Penberthy & Weld, 1992). plan sort represents set
possible linearizations, set totally ordered plans formed action instances
115

fiBoutilier & Brafman

violate ordering, codesignation, non-codesignation constraints.8
say plan consistent linearization. set linearizations seen
\semantics" nonlinear plan sense. (consistent) nonlinear plan satisfies
goal set G, given starting state s, linearization guaranteed satisfy G.
concurrent nonlinear plan n agents (labeled 1; : : :n) similar: consists set
action instances (with agent arguments, though necessarily instantiated) together
set arbitrary ordering constraints actions (i.e., <; >; = 6=)
usual codesignation non-codesignation constraints. Unlike single-agent nonlinear plans,
allow equality inequality ordering constraints concurrent nonconcurrent
execution pair actions imposed. semantics must allow concurrent
execution actions n agents. end extend notion linearization:
Definition Let P concurrent nonlinear plan agents 1; : : :n. n-linearization
P sequence joint actions A1; Ak agents 1; : : :n
1. individual action instance P member exactly one joint action Ai ;
2. individual action occurs A1 ; Ak P , individual
No-op actions;
3. codesignation non-codesignation constraints P respected;
4. ordering constraints P respected. precisely, individual
action instances b P , joint actions Aj Ak b
occur, ordering constraints b true Aj Ak ; is,
af<; >; =; 6=gb, j f<; >; =; 6=gk.
words, actions P arranged set joint actions ordering
individual actions satisfies constraints, \synchronization" ensured no-ops.
Note set k actions (which allowed executed distinct
agents) ordering constraints, set linearizations includes \short" plan
single joint action k actions executed concurrently different agents
(assuming k n), \strung out" plan k actions executed one time
single agent, others nothing (or different agents take turns
individual actions), \longer" plans stretched even joint no-ops, anything
between.

Example Suppose planner outputs following plan group three agents:
set actions

f

a(1); b(2); c(2); d(3); e(1); f (2)

g

ordering constraints

e(1) = b(2); c(2) = d(3); a(1) < e(1); d(3) < f (2)

f

6

g

Here, numerical arguments denote agent performing action. Joint actions
involve one action three agents. simple 3-linearization plan|
depicted first linearization Figure 5, using N denote no-ops
8. Concurrent execution considered context non-interacting actions; see Knoblock's
discussion issue (Knoblock, 1994).

116

fiPlanning Concurrent Interacting Actions

Time

1

2

3

4

5

Time

1

2

3

Agent 1



e

N

N

N

Agent 1



e

N

Agent 2

N

b

c

N

f

Agent 2

c

b

f

Agent 3

N

N

N



N

Agent 3

N



N

Linearization 1

Linearization 2

Figure 5: Two possible linearizations partially ordered multiagent plan
corresponding agents|is:
(1) (2) (3)i h (1) (2) (3)i

ha

;N

;N

; e

;b

;N

; hN

(1) (2) (3)i
;c

;N

; hN

(1) (2) (3)i
;N

;d

; hN

(1) (2) (3)i
;f

;N

insert additional tuples form hN (1); N (2); N (3)i location
wish. Another possible 3-linearization (the second Figure 5) is:

a(1); c(2); N (3) ; e(1); b(2); d(3) ; N (1); f (2); N (3)

h

h

h



fact, shortest 3-linearization plan.
definition n-linearization requires agent perform one action
time. conforms assumption made last section, though definition could quite easily relaxed allow this. no-ops, n-linearizations
correspond shortest plans, either concurrently nonconcurrently executed
senses term. However, relatively easy matter \sweep through" concurrent nonlinear plan construct shortest n-linearization, one fewest joint
actions, taking least amount \time." Though explicit notion
time, sequence joint actions n-linearization implicitly determines time line
along agent must execute individual actions. fact concurrency
nonconcurrency constraints enforced linearizations ensure plan coordinated synchronized. note order execute plan coordinated
fashion agents need synchronization mechanism. issue dealt
paper.

3. Planning Concurrent Actions

Figure 6, present POMP algorithm, version Weld's POP algorithm (Weld,
1994) modified handle concurrent actions. keep discussion simple, begin
describing POMP without considering conditional action effects. describe
simple modifications required add conditionals (i.e., build analog CPOP).
Though discuss universal quantification paper, algorithm could easily
extended handle universally quantified effects much way Penberthy
Weld's (1992) full UCPOP algorithm.
117

fiBoutilier & Brafman

POMP(hA; O; L; NC;B i,agenda )
Termination: agenda empty, return hA; O; L; NC;B i.
Goal Selection: Let hQ; Aneed pair agenda . (Aneed action Q conjunct
precondition list.)
Action Selection: Let Aadd = Choose action one whose effects unifies Q subject constraints B . (This may newly instantiated action action already
ordered consistently prior Aneed). action exists, return failure. Let
Q g. Form B adding B codesignation constraints needed
L = L [ fAadd !
need
order force Aadd desired effect. Let = [ fAadd < Aneed g. Aadd newly
instantiated, = [ fAadd g = [ fA0 < Aadd < g (otherwise, let = A).
Concurrent Action Selection: Aadd newly instantiated apply following steps positive
actions ffconc concurrent list: Let Aconc = Choose newly instantiated action
action already ordered consistently concurrently Aadd. Make sure
free agent perform action concurrently Aadd concurrently
scheduled actions. action exists return failure. Let = [ fAconc = Aneedg.
Aconc newly instantiated, = [ fAadd g = [ fA0 < Aconc < g (otherwise,
let = A). aadd agent variable Aadd aconc agent variable Aconc ,
add aadd 6= aconc B , well similar non-codesignation constraints actions
= Aadd 2 O.
Re-apply step Aconc , needed.
every negative action conc Aadd concurrent list let NC = NC [ fA conc 6= Aadd g. Add
B codesignation constraints associated conc .
Updating Goal State: Let agenda = agenda , fhQ; Aneedig.
Aadd newly instantiated, add fhQj ; Aaddig agenda every Qj logical precondition Aadd. Add preconditions B . additional concurrent actions added, add
preconditions well.
Causal Link Protection: every action might threaten causal link Ap !R Ac perform one
(a) Demotion: Add < Ap .
(b) Weak Promotion: Add Ac . agent perform concurrently Ac , add
> Ac, instead.
neither constraint consistent, return failure.
Nonconcurrency Enforcement every action threatens nonconcurrency constraint 6=
(i.e., instance schema violate constraint B ) add consistent
constraint, either
(a) Demotion: Add < .
(b) Promotion: Add > .
neither constraint consistent, return failure.
Recursive Invocation: POMP(hA ; ; L ; NC ; B i,agenda' )
0

0

0

0

0

0

0

1

0

0

0

0

1

0

0

0

:

0

:

:

0

0

0

0

0

0

0

0

0

0

0

0

0

Figure 6: Partially Ordered Multiagent Planning algorithm

118

fiPlanning Concurrent Interacting Actions

assume existence function MGU(Q; R; B ) returns general
unifier literals Q R respect codesignation constraints B .
used wherever unification action schemata required (see Action Selection step
Figure 6 discussion NC-threats below). algorithm number input
variables: set contains action instances inserted plan far; set
contains ordering constraints elements A; set L contains causal links; set
NC contains nonconcurrency constraints; set B contains current codesignation
constraints. set NC appear POP algorithm contains elements
form 6= a, 2 action schema action instance A.
Intuitively, nonconcurrency constraint form requires action instance a0
matches schema subject (non) codesignation constraints appear
concurrently plan.
agenda set pairs form hQ; Ai, listing preconditions Q
achieved yet actions require them. Initially, sets L, NC , B
empty, contains two fictitious actions A0 A1 , A0 initial
state propositions effects A1 goal state conditions preconditions.
agenda contains pairs hQ; A1 Q one conjuncts description
goal state. specification initial agenda identical used POP
(Weld, 1994). Finally, note choose operator, appears Action
Selection Concurrent Action Selection steps, denotes nondeterministic choice.
Again, device used POP make algorithm specification independent
search strategy actually used planning. Intuitively, complete planner require
one search nondeterministic choices, backtracking lead failure.
Many structures algorithmic steps POMP correspond exactly
used POP. Rather describe detail, focus discussion elements
POMP differ POP. Apart additional data structure NC mentioned
above, one key difference additional Concurrent Action Selection step POMP,
takes care concurrency requirements newly instantiated action.
One final key distinction notion threat used POMP, general
used POP. Much POP, given plan hA; O; L; NC i, say
Q [ fA < g consistent, :Q
threatens causal link Ap !
c
p

c

effect. Threats handled using demotion (much POP), weak promotion.
latter differs standard promotion technique used POP: allows
ordered concurrently Ac , Ac .9
Apart handling conventional threats different manner, another form
threat concurrent plans, namely, NC-threats . say action instance threatens
nonconcurrency constraint 6= Ac [ fAt = Ac g consistent instantiation
violate codesignation constraints. Demotion promotion
used handle NC-threats, conventional threats. Notice
although set NC contains negative (inequality) constraints, ultimately
grounded set positive constraints O. Following approach suggested Weld
9. wish exclude actions negate precondition another concurrent action (see discussion
Section 2), must use [ fAp Ac g definition threat, must change weak
promotion standard promotion.

119

fiBoutilier & Brafman

(1994), consider action threat variables consistently
instantiated manner would remove threat.
POMP algorithm must check consistency ordering constraints several
places: Action Selection action chosen achieve effect must consistently ordered consumer effect; Concurrent Action Selection
concurrency requirement added plan must tested consistency;
Nonconcurrency Enforcement demotion promotion used ensure
nonconcurrency requirements violated. consistency testing set ordering
constraints similar employed POP (see Weld (1994) nice discussion), one key difference: existence equality (=) inequality (6=) ordering
constraints opposed simple strict inequalities (i.e., < >). However, minor
modifications, standard consistency-checking algorithms strict ordering constraints
used. Equality dealt simply \merging" actions must occur concurrently (i.e., treating single action purposes consistency testing).
Inequalities easily handled assuming actions occur different points whenever
possible. Non-strict inequalities (i.e., ) arise directly algorithm
(though two easily dealt with). refer Ghallab Alaoui (1989)
details processing constraints.
POMP algorithm described easily modified handle conditional effects,
POP algorithm extended CPOP. main fact note
action selection phase, use action whose conditional effects achieve chosen
subgoal. case, add preconditions selected action
agenda, antecedent particular conditional effect (this ensure
action particular effect). handle additional concurrency conditions
antecedent much regular concurrency conditions. CPOP algorithm,
must consider possibility particular conditional effect added action
threatens established causal link. case, can, aside using existing
threat resolution techniques, consider form confrontation , add negation
conditional effect's antecedent agenda. Again, several ways
this: could add negation literal antecedent's condition agenda;
add concurrent action negate negative concurrency condition
antecedent, post nonconcurrency constraint offset positive concurrency constraint
antecedent. details steps straightforward look similar
involved unconditional algorithm.

4. Example POMP Algorithm
section, formalize example alluded introduction describe
construction concurrent plan problem using POMP algorithm.
initial state, two agents, Agent1 Agent2, located Room1, together
table set blocks scattered around room. goal ensure
blocks Room2 table oor. order simplify example,
assume one block B , omit certain natural operators, simplify action
descriptions. order compactly represent multiple block version this, would
require introduction universal quantification. shown Weld (1994),
120

fiPlanning Concurrent Interacting Actions

done little diculty. Intuitively, agents gather blocks room
(in case one), put table, carry table room, dump
blocks table, put table down. best plan
single block, illustrates plan would constructed multiple blocks
(in case strategy better agents making multiple trips carrying
individual blocks). use following actions:







Pickup(a; b): agent picks block b
PutDown(a; b): agent puts block b table
ToTable(a; s): agent moves side (left, right) table
MoveTable(a; r): agent moves room r table
Lift(a; s): agent lifts side table
Lower(a; s): agent lowers side table

variables type agent , b variables type block , r variables type room ,
variables type table-side. (We omit natural actions since won't
used plan interest.)
domain described using following predicates:









OnTable(b): block b table
OnFloor(b): block b oor
AtSide(a; s): agent side (left, right) table
Up(s): side table raised
Down(s): side table oor
InRoom(x; r): object x (agent, block, table) room r
HandEmpty(a): hand agent empty
Holding(a; x): agent holding x (block, side table)

operator descriptions defined Figure 7.
initial state planning problem is:
InRoom(B; Room1); OnFloor(B ); InRoom(Agent1; Room1); InRoom(Agent2; Room1);
InRoom(Table; Room1); Down(LeftSide); Down(RightSide)g

f

goal propositions are:
InRoom(B; Room2); OnFloor(B ); Down(LeftSide); Down(RightSide)g

f

consider concurrent nonlinear plan multiagent planning problem
might generated POMP.
121

fiBoutilier & Brafman

(define (operator pickup)
:parameters
(?a1 ?x)
:precondition (and (inroom ?a1 ?r1) (inroom ?x ?r1)
(handempty ?a1) (onfloor ?x))
:concurrent
(and (not (pickup ?a2 ?x)) (not (= ?a1 ?a2)))
:effect
(and (not (handempty ?a1)) (not (onfloor ?x)) (holding ?a1 ?x)))
(define (operator putdown)
:parameters
(?a1 ?x)
:precondition
(and (inroom ?a1 ?r1) (inroom ?x ?r1) (inroom Table ?r1)
(holding ?a1 ?x))
:concurrent
(not (lift ?a2 ?s1))
:effect
(and (not (holding ?a1 ?x)) (ontable ?x) (handempty ?a1)))
(define (operator totable)
:parameters
(?a1 ?s1)
:precondition (and (inroom ?a1 ?r1) (inroom Table ?r1) (not (atside ?a2 ?s1)))
:concurrent
(and (not (totable ?a2 ?s1)) (not (= ?a1 ?a2)))
:effect
(atside ?a1 ?s1))

(define (operator movetable)
:parameters
(?a1 ?r1)
:precondition (holding ?a1 Table)
:concurrent
(and (movetable ?a2 ?r1) (not (= ?a1 ?a2)))
:effect
(and (inroom ?r1 Table) (inroom ?r1 ?a1)
(when ((ontable ?x) ()) (inroom ?r1 ?x))))
(define (operator lower)
:parameters
(?a1 ?s1)
:precondition (and (holding ?a1 ?s1) (up ?s1))
:concurrent
(and (not (lift ?a2 ?s2)) (not (= ?a1 ?a2)) (not (= ?s1 ?s2)))
:effect
(and (not (up ?s1))(down ?s1) (not (holding ?a1 ?s1))
(when ((and (ontable ?x) (up ?s2) (not (= ?s1 ?s2)))
(and (not (lower ?a2 ?s2)) (not (= ?a2 ?a1))))
(and (onfloor ?x) (not (ontable x))))))
(define (operator lift)
:parameters
(?a1 ?s1)
:precondition (and (atside ?s1 ?a1) (down ?s1) (down ?s2) (not (= ?s1 ?s2)))
:concurrent
(and (not (lower ?a2 ?s2)) (not (= ?a1 ?a2)) (not (= ?s1 ?s2)))
:effect
(and (not (down ?s1)) (up ?s1) (holding ?a1 ?s1)
(when ((and (ontable ?x) (down ?s2) (not (= ?s1 ?s2)))
(and (not (lift ?a2 ?s2))))
(and (onfloor ?x) (not (ontable x))))))

Figure 7: table movers domain

122

fiPlanning Concurrent Interacting Actions

Suppose InRoom(B; Room2) first goal selected. achieved performing A1 = MoveTable(a1; Room2) via conditional effect (note a1 agent variable, commitment agent performs action).10 must add
Holding(a1; Table) OnTable(B ) agenda insert appropriate causal links.
addition, concurrent list forces us add action A2 = MoveTable(a2; Room2)
plan together non-codesignation constraint a1 6= a2. ordering constraint
A1 = A2 added well. add A2, must add precondition Holding(a2; Table)
agenda well. structure partially constructed plan might viewed
follows:11
InRoom(Block, R2)

A1

GOAL

MoveTable(a1,R2)

A2

C

MoveTable(a2,R2)

Next, choose subgoal OnTable(B ) agenda (which added).
add action A3 = PutDown(a3; B ) plan appropriate ordering constraint
A3 < A1; preconditions added agenda causal link added L.
addition, must add NC nonconcurrency constraint not(Lift(a; s)): agent
lift side table block placed desired effect
achieved.
InRoom(Block, R2)

OnTable(Block)

A3
PutDown(a3,Block)

A1

MoveTable(a1,R2)

GOAL

C

A2

MoveTable(a2,R2)

10. pursue notion heuristics action selection here; note action
plausible candidate selection multi-block setting. goal list asserts number
blocks second room, single action moving table achieve
appropriate conditions (i.e., blocks table). action selection favors (conditional)
actions achieve goals subgoals, action considered actions needed
\one one" transport blocks individual agents. choice silly might
seem single-block setting.
11. plan diagrams follow, indicate actions Ai name action it. Variables
indicated lower-case names (we indicate co-designation constraints diagrams).
arrow one action another denotes causal link (from producer consumer), labeled
proposition produced. Large arrows labeled C (resp. NC) denote concurrency (resp.
nonconcurrency) constraints actions. use left-to-right ordering denote temporal
ordering actions, constraints exist.

123

fiBoutilier & Brafman

choose subgoal Holding(a1; Table). achieved using A4 =
Lift(a1; s1), ordering constraint A4 < A1 . preconditions added
agenda, concurrency conditions added (yet!) action, since
yet need invoke conditional effects action induced simultaneous lifting
side table:
Holding(a1,Table)

A4
Lift(a1,LS)

InRoom(Block, R2)

NC OnTable(Block)

A3

A1

PutDown(a3,Block)

GOAL

MoveTable(a1,R2)
C

A2

MoveTable(a2,R2)

note conditional effect A4 poses threat causal link A3 ontable
!
A1; lifting single side table dump block table.
addition, nonconcurrency constraint associated A3 , lifting performed
concurrently A3 , threatened A4 (an NC-threat), indicated plan diagram
above. confrontation strategy used handle first threat, action A5 =
Lift(a4; s2) scheduled concurrently A4 . constraints s1 6= s2 a4 6= a1
imposed. ensures undesirable effect occur. resolve NC threat
ordering A3 A4 .12 resulting partially completed plan free threats:
Holding(a1,Table)

A4
Lift(a1,LS)

InRoom(Block, R2)
OnTable(Block)

A3
PutDown(a3,Block)

C

A1

MoveTable(a1,R2)

GOAL

C

A5

A2

Lift(a2,RS)

MoveTable(a2,R2)

Next, choose subgoal Down(LeftSide). achieved using action A6 =
Lower(a1; LeftSide) preconditions added agenda. completely similar
way, A7 = Lower(a2; RightSide) added achieve Down(RightSide) (again, anticipate
unification agent variables).
12. anticipation subsequent step, use variable a2 plan diagram instead a4, since
soon unified. keep things concrete, replaced s1 s2 particular sides
table, LeftSide RightSide, make discussion bit less convoluted.

124

fiPlanning Concurrent Interacting Actions

A6
Lower(a1,LS)
Down(LS)

A4

Holding(a1,Table)

Lift(a1,LS)
OnTable(Block)

InRoom(Block, R2)

A3

A1

PutDown(a3,Block) C

MoveTable(a1,R2)

GOAL

C

A5

A2

Lift(a2,RS)

MoveTable(a2,R2)

A7

Down(RS)

Lower(a2,RS)

choose work preconditions A6 A7 . preconditions,
Up(s) Holding(a; s), effects Lift, use A4 A5 producers.
stage, A6 A7 constrained follow A4 A5 , constraints
relative ordering A6 A7 themselves. see A6 A7
\potentially" threaten causal link A3 ontable
!
A1; is, conditional
effect would cause block fall table. several ways resolve
two threats, including confrontation. choose strict promotion, order A6
A7 occur A1 A2 .
Holding(a1,LS)
Up(a1,LS)

A4

A6
Lower(a1,LS)

Holding(a1,Table)

Down(LS)

Lift(a1,LS)
OnTable(Block)



3

PutDown(a3,Block)

C

A5
Lift(a2,RS)

InRoom(Block, R2)

A1

MoveTable(a1,R2)

GOAL

C

A2

MoveTable(a2,R2)

Down(RS)

A7
Lower(a2,RS)
Up(a2,RS)
Holding(a2,RS)

Now, choose subgoal OnFloor(B ), conditional effect Lower
action. choose accomplish using existing action, A6 . order obtain
desired effect, ensure antecedent clause effect holds: involves
adding conditions antecedent (OnTable(B ) Up(LeftSide)) agenda,
imposing nonconcurrency constraint antecedent, namely, concurrent
Lower action take place. constraint threatened action A7 , order
125

fiBoutilier & Brafman

A6 A7 posting constraint A6 < A7.13 conditions antecedent,
OnTable(B ) Up(LeftSide), use A3 A5 producers, respectively.
OnTable(Block)
Holding(a1,LS)
Up(a1,LS)

A4

A6
Lower(a1,LS)

Holding(a1,Table)

Down(LS)
OnFloor(Block)

Lift(a1,LS)
OnTable(Block)



3

PutDown(a3,Block)

C

InRoom(Block, R2)

A1

MoveTable(a1,R2)

GOAL

C
Holding(a2,Table)
2
Lift(a2,RS)
MoveTable(a2,R2)

A5

Down(RS)

A7
Up(a2,RS)

Lower(a2,RS)

Holding(a2,RS)

unsolved subgoal precondition initial PutDown(a3; B ) action
(others, Down(LeftSide) Lift action, produced initial state).
don't illustrate it, simple matter introduce Pickup(a3; B ) action
PutDown(a3; B ).
following plan: first, block picked put table
agent a3 (either Agent1 Agent2 this). followed two concurrent
lift actions two concurrent move actions get table room
block top. Next, single lower action, makes block fall off, followed
another lower action ensures sides table oor.
note plan care agents (the one lifts LeftSide
RightSide) initially puts block table.14

5. Soundness Completeness POMP Algorithm
say planning algorithm sound generates plans guaranteed
achieve goals posed it; complete algorithm guaranteed generate plan
successful plan exists.15 case concurrent nonlinear plans, say
algorithm sound n-linearization plan produced given problem
reach goal state, algorithm complete successfully generates concurrent
nonlinear plan whenever sequence joint actions (i.e., n-linearization
13. ordering A7 < A6 could used resolve threat; would cause \unresolvable" threat conditions antecedent, require side remain up. is,
course, \unresolvable" sense would require agents pick block, etc.,
essentially introducing cycle plan.
14. examples MAP problems, plans produced POMP, code implementing POMP
algorithm obtained http://www.cs.bgu.ac.il/ishayl/project/.
15. formal definitions concepts, refer reader (Penberthy & Weld, 1992).

126

fiPlanning Concurrent Interacting Actions

concurrent plan) achieves goal initial state. show POMP
algorithm sound complete.
soundness proof straightforward. Suppose generated plan sound.
Thus, n-linearization plan achieve goal required subgoal
(i.e., precondition one plan's actions). agenda mechanism,
clear needed goal precondition exists action plan
achieves subgoal (goal precondition). Moreover, explicit causal link
plan particular subgoal well ordering constraint requiring
producing action appear prior consuming action (or goal). n-linearization
plan another plan obtained original plan adding new, consistent, strict
(i.e. <; >) ordering constraints. Recall original plan's ordering constraints must
consistent, otherwise would constitute solution,
threats. Clearly, adding new strict ordering constraints cannot cause new threats
causal links violate nonconcurrency constraint. Hence, resulting n-linearization
respects causal links original plan ordering constraints original plan.
complete proof, must convinced POMP actually considers possible,
relevant interactions actions. Consider effect P action needed
action b ordered a. Given semantics actions, two reasons
P hold prior execution b: (1) action c b (possibly
concurrent a) effect :P ; (2) actually P effect. Case (1)
contradicts fact threats (in extended sense, covering possibility
c occurring concurrently a) context plan. Case (2) implies either
P effect subject concurrency nonconcurrency condition violated
n-linearization. problem would taken care Action
Selection Nonconcurrency Enforcement steps (and ordering constraints).
Thus clear n-linearization plan produced POMP fact
achieve goals; is, POMP sound.
completeness proof rests three key elements:
1. reduction multiagent planning problems single agent planning problems.
2. fact POMP solve multiagent planning problem iff POP solve
single agent planning problem obtained via reduction.
3. fact POP sound complete (Penberthy & Weld, 1992).
First, show given multiagent planning problem, similar single agent planning
problem obtained. shall refer generated problem equivalent single
agent planning problem (or ESA problem). reduction property plan
multiagent planning problem exists plan ESA problem exists.
introduction, discussed reduction via use joint actions. Here,
use similar idea, little care POMP POP perform
similar steps solution original problem ESA problem, respectively.
Combining results fact POP sound complete, deduce
POMP sound complete well.
127

fiBoutilier & Brafman

discussion below, ignore conditional effects avoid undue and,
part, uninteresting complications. extension arguments deal conditional
effects straightforward. first recall following facts relevant argument:
(a) POP POMP nondeterministic planning algorithms and, although
various ways making deterministic, issue orthogonal
proof. Thus, showing correspondence POP POMP alluded
point (2) above, utilize exibility awarded us planner's
use nondeterministic choice. particular, sucient show
given solution path one planner, similar solution path exists other.
(b) choice next agenda element work immaterial POP
POMP|it affect running time (e.g., causing backtracking)
existence solution. Hence, exible ordering subgoals
achieved, long respect causality (i.e., cannot achieve goal
derived precondition action introduced yet).
(c) introducing additional ordering constraints consistent current constraints
valid plan, obtain valid plan given problem.
(d) precise order actions ordering constraints inserted
affect validity solution. fact, well known planning
community, one postpone threat resolution step without affecting
soundness completeness algorithm, long threats eventually
resolved.
proof proceed two stages. first stage, limit
restricted set planning problems show connections POP
straightforward fashion. relax restriction show correspondence
two planners general case.
Recall Section 2.3 suggested possible restriction set actions one
allowed execute concurrently, namely, two actions b permitted
occur concurrently one's effects negate other's preconditions. remarked
concurrent, non-clobbering condition, enforced action specification
itself, easily enforced POMP algorithm modify definition threat
use promotions instead weak promotions resolve threats. Let us restrict attention,
time being, domains respecting condition.
first note following fact. Let POMP plan, consider nlinearization a1 a2 occur concurrently,
future actions require effects produced concurrent execution actions.
is, actions a1 a2 forced occur concurrently plan . case,
similar n-linearization a1 ordered a2 , vice versa,
ordering constraints violated (some linearization must exist) achieve
goal. case might happen one a1 a2 clobbers
other's preconditions; explicitly disallowed restricted setting (by
imposition nonconcurrency constraint \precondition").
128

fiPlanning Concurrent Interacting Actions

consider ESA problem, actions available agent follows:
individual action concurrency constraints multiagent problem,
create action corresponding joint action performed \owning"
agent, no-ops executed every agent; individual action
concurrency conditions, requiring actions b1; bk executed concurrently,
create action corresponding joint action bi performed,
actions apart no-ops performed.16 note nonconcurrency
constraints ignored ESA problem definition.
Clearly, joint action sequence exists given problem, exists concurrent nonlinear plan problem. addition, argument involving
assumption concurrent action clobber another's precondition, easy
see that, concurrent nonlinear plan found problem, exists
concurrent nonlinear plan concurrency constraints involve actions whose
specification requires concurrent execution another action (or set actions) order
obtain particular effect. implies that, problem solvable, solvable
sequence joint actions type constructed above, using single-agent individual actions together set no-ops, involving minimal sets interacting
actions. words, concurrent nonlinear plan exists given problem iff plan
ESA problem exists. note structure solution ESA problem
(or linearization nonlinear single-agent plan ESA problem) specific:
actions occur concurrently forced to. words, solutions ESA
problem strung plans, agents \take turns" performing actions.
Next, want show (in restricted setting) POMP's solution path given
planning problem POP's solution path ESA problem resemble other.
becomes apparent combine POMP's action selection concurrent action selection
steps. obtain step equivalent action selection step POP ESA
problem (i.e., whenever POMP chooses action requires another concurrent action,
required concurrent action immediately inserted well; equivalent inserting
proper ESA action). fact, POP POMP look almost identical, except
POMP's Nonconcurrency Enforcement step. However, fashion
ESA problem defined, nonconcurrency constraints automatically \imposed"
plan produced POP since refer different joint actions. linearization
joint actions enforces nonconcurrency joint actions. Therefore,
(single-agent) actions occur together POP's solution ESA problem
occur together nonconcurrency constraint. (In
fact, actions explicit concurrency constraint.)17
argument demonstrates POP POMP generate \identical" sets
plans, except two small differences. First, POMP's semantics allows concurrent
execution certain actions, even though need executed concurrently order
16. important note single action schema gives rise n individual actions, one
agent (e.g., Lift(Agent1; s) Lift(Agent2; s) distinct actions, separate joint actions
created). Similarly, concurrency conditions involve action schemata, permitted
combination agent instantiations give rise distinct joint action.
17. assumes concurrency lists congruous, described Section 2; if, not, simple
redefinition ESA problem given \incongruous" concurrent actions admitted.

129

fiBoutilier & Brafman

solve problem, POP (for ESA problem) cannot generate plans admit
this. However, difference cannot affect completeness argument (since means
POMP exible POP).18 Second, POMP commits particular ordering
actions nonconcurrency constraint, POP make
commitment orderings consistent. However, consistent (and remain
unordered final plan ESA problem) choice POMP makes cannot
impact solution (and POMP produce either alternative ordering matter).
Now, using fact POP sound complete, virtual equivalence POMP
POP steps, facts strung plans ESA problem, see POMP
sound complete special case concurrent actions destroy
other's preconditions.
Finally, wish remove restrictions placed concurrent actions, admit
problems concurrent action clobber precondition another. note
problems type exist cannot solved strung plan sense defined
above. instance, consider following problem. two actions:


Action a: Precondition P ; effect Q



Action b: Precondition :Q; effect :P

Actions b nonconcurrency constraints, thus required
concurrent specified effects considered isolation. Suppose initial
state fP; :Qg goal state f:P; Qg. plan achieves goal requires
b executed concurrently. order one other, destroy
ability perform second, goal reachable. Thus, POMP solve
problem POP could solve ESA problem (as formulated above).
deal general case, extend construction ESA problem
including (in addition actions used restricted case) joint action ESA
problem set actions satisfying following conditions:


element permitted executed concurrently (but need forced
concurrent).



element clobbers precondition element A.



element removed without destroying property.

words, create joint action corresponding concurrent execution
element set A. We'll call \self-clobbering" joint actions. evident
concurrent nonlinear plan exists arbitrary multiagent planning problem iff
exists sequence joint actions (allowing self-clobbering actions) solve problem,
hence (by soundness completeness POP) iff POP find plan
generalized ESA problem. already seen POMP emulate step POP
18. additional exibility impacts soundness POMP (and addressed above). fact,
could used current line reasoning part integrated soundness completeness proof
based POP/POMP correspondence, case, would need explain last point
hinder soundness POMP.

130

fiPlanning Concurrent Interacting Actions

involving actions self-clobbering actions. simply show POMP
emulate POP's introduction self-clobbering actions show completeness.
Let self-clobbering joint action. claim POP complete (for
generalized ESA problem) ever considers adding incomplete plan
elements ai 2 effect satisfies subgoal agenda. Suppose,
contrary, ai 2 consumer current agenda. either
necessary successful plan (since subset actions used),
actions consume effects ai yet introduced. discount
former case considering executions POP use action. POP
complete even action never considered, since able introduce
individual components (or concurrent subsets) produce necessary effects.
discount latter case, since must valid execution POP introduces
(ultimate) consumers element ai introducing A. Thus, without loss
generality, assume element ai 2 satisfies subgoal agenda
introduced POP.
suppose POP introduces self-clobbering action A. Since ai 2 satisfy
agenda item, POMP simulate step follows: introduce ai turn satisfy
agenda item, postponing threat resolution among ai ; resolve self-threats among
ai weak promotion Causal Link Protection step (so impose
ordering constraint ai aj ai threatens aj ). example above, instance,
actions b added achieve subgoals Q :P , respectively, way
resolve mutual threat weak promotion actions; is, impose b
b a. words, forced concurrent. Thus introduction
self-clobbering joint action POP (under assumptions stated above) strong
correspondence sequence possible steps POMP. Since POP always find
plan assumptions, POMP. Thus completeness POMP
general case arbitrary multiagent planning problems demonstrated.

6. Concluding Remarks
One often finds assertions planning literature planning interacting actions
inherently problematic affair, requiring substantial extension existing single-agent
planning representations algorithms. Thus, somewhat surprising minor
changes needed enable STRIPS action representation language capture interacting actions, relatively small modifications existing nonlinear planners
required generate concurrent plans. solution involves addition concurrent
action list standard action description, specifying actions
scheduled concurrently current action order achieve desired effect.
POP planner augmented two steps: one handles insertion required
concurrent actions, one handles threats emanating potential concurrent
execution two interfering actions. addition, explicit reasoning equality inequality constraints introduced. strong resemblance solution
multiagent case solution single agent case, little overhead incurred
actions interact. fact, extreme case non-interacting actions,
extension STRIPS POP reduce single-agent equivalents.
131

fiBoutilier & Brafman

close connection specification method Knoblock's (1994)
approach generating parallel execution plans. Knoblock adds action description
list describes resources used action: actions require resource
(e.g., access database) cannot scheduled time. Hence, Knoblock's
resource list actually characterizes one form nonconcurrency constraint.19 fact,
believe certain nonconcurrency constraints naturally described using
resource list general method proposed here|augmenting language
lists prove dicult.
treatment concurrent actions specification languages Ac (Baral & Gelfond, 1997) C (Giunchiglia & Lifschitz, 1998) many features common
extension STRIPS (although C , particular, expressive language many
additional features). languages allow use complex actions|which sets
primitive actions|analogous ability provide combine number elements
joint action. Typically, complex actions inherit effects primitive actions contained them. However, explicit specification effects complex actions
possible, overriding inheritance. overriding mechanism extend arbitrary
number levels (e.g., action effect, overridden b
performed concurrently, effect overridden c performed well,
etc.). action description languages, implicit view time adopted, much
treatment, concurrent actions assumed performed simultaneously. quite recently, tools actually synthesizing plans domains described
languages C . However, recent progress model-based techniques led
number new algorithms, including SAT encoding language C (Giunchiglia,
2000).
effects one agent's actions depend actions performed agents
time, action specification becomes complex task. STRIPS representation
useful admits relatively simple planning algorithm. However, despite STRIPS's
semantic adequacy ability, principle, represent set actions, verifying
domain description accurate becomes dicult interactions must taken
account. Consequently, believe use dynamic Bayes nets, conjunction
conditional outcome (or probability) trees (Boutilier & Goldszmidt, 1996), provide
natural concise representation actions multiagent settings. specification
technique makes clear uence different context conditions action's effects,
allows one exploit independence different effects. representation
used stochastic domains, dynamic Bayes nets offer advantages even
case purely deterministic actions. POMP algorithm naturally extends form
domain description, complete treatment issue would interesting
direction future research.
adapting existing nonlinear planners handle interacting actions conceptually
simple, expect increase domain complexity inevitably lead poor computational performance. Indeed, experiments POMP algorithm,
found performance greatly affected ordering agenda items. Hence, adequate
heuristics making various choices planner faced with|namely, choosing sub19. principle, nonconcurrency constraint handled manner introducing fictitious
resources.

132

fiPlanning Concurrent Interacting Actions

goals, choosing actions achieve them, choosing threat-resolution strategies|will
become even critical. course, issues central single-agent nonlinear
planners, though anticipate multiagent case interacting actions
require different, additional, heuristics.
interesting topic future work would extending newer planning algorithms
Graphplan (Blum & Furst, 1995) handle multiagent representation language.
Indeed, model-based algorithm Cimatti, et al. (1997) seems offer promising developments direction. Naturally, representational issues raised paper arise
regardless particular planning algorithm used, although different implications.
example, question whether allow concurrent actions destroy
one another's preconditions affected threat removal operators valid POMP,
whereas Graphplan would affect definition interfering actions (and consequently, question actions considered mutually exclusive).
Finally, note approach considered suitable team agents
common set goals. assumes central entity generates plan,
agents access global clock synchronization mechanism
(this typically case single agent multiple effectors, applies certain
cases truly distributed systems). important research issue plans
generated executed distributed fashion, execution
coordinated controlled. important question answers
emerged DAI literature (des Jardins, Durfee, Ortiz Jr., & Wolverton, 1999; Grosz,
Hunsberger, & Kraus, 1999; des Jardins & Wolverton, 1999; Boutilier, 1996, 1999; Brafman,
Halpern, & Shoham, 1998) distributed systems literature (Fagin, Halpern, Moses,
& Vardi, 1995).

Acknowledgments
Thanks referees suggestions presentation ideas Mike
Wellman helpful comments. thank Daniel Fogel, Ishay Levy, Igor Razgon
implementation POMP algorithm. Boutilier supported NSERC Research Grant OGP0121843, NCE IRIS-II program Project IC-7. Brafman supported Paul Ivanier Center Robotics NCE IRIS-II program Project IC-7. Much
work undertaken authors University British Columbia,
Department Computer Science. Preliminary results paper presented
\Planning Concurrent Interacting Actions," Proceedings Fourteenth National
Conference Artificial Intelligence (AAAI-97), Providence, RI, pp.720{729 (1997).

References
Baral, C., & Gelfond, M. (1997). Reasoning effects concurrent actions. Journal
Logic Programming, 85{117.
Blum, A. L., & Furst, M. L. (1995). Fast planning graph analysis. Proceedings
Fourteenth International Joint Conference Artificial Intelligence, pp. 1636{
1642 Montreal.
133

fiBoutilier & Brafman

Boutilier, C. (1996). Planning, learning coordination multiagent decision processes.
Proceedings Sixth Conference Theoretical Aspects Rationality
Knowledge, pp. 195{210 Amsterdam.
Boutilier, C. (1999). Sequential optimality coordination multiagent systems.
Proceedings Sixteenth International Joint Conference Artificial Intelligence,
pp. 478{485 Stockholm.
Boutilier, C., & Goldszmidt, M. (1996). frame problem Bayesian network action
representations. Proceedings Eleventh Biennial Canadian Conference
Artificial Intelligence, pp. 69{83 Toronto.
Brafman, R. I., Halpern, J. Y., & Shoham, Y. (1998). knowledge requirements
tasks. Artificial Intelligence, 98 (1-2), 317{350.
Cimatti, A., Giunchiglia, E., Giunchiglia, F., & Traverso, P. (1997). Planning via model
checking: decision procedure AR. Proceedings Fourth European Conference Planning (ECP'97), pp. 130{142 Toulouse.
de Giacomo, G., Lesperance, Y., & Levesque, H. J. (1997). Reasoning concurrent
execution, prioritized interrupts, exogenous actions situation calculus.
Proceedings Fifteenth International Joint Conference Artificial Intelligence,
pp. 1221{1226 Nagoya.
Dean, T., & Kanazawa, K. (1989). Persistence probabilistic projection. IEEE Trans.
Systems, Man Cybernetics, 19 (3), 574{585.
des Jardins, M. E., Durfee, E. H., Ortiz Jr., C. L., & Wolverton, M. J. (1999). survey
research distributed continual planning. AI Magazine, 20 (4), 13{22.
des Jardins, M. E., & Wolverton, M. J. (1999). Coodinating distributed planning system.
AI Magazine, 20 (4), 13{22.
Donald, B. R., Jennings, J., & Rus, D. (1993). Information invariants cooperating
autonomous mobile robots. Proceedings International Symposium Robotics
Research Hidden Valley, PA.
Durfee, E. H., & Lesser, V. R. (1989). Negotiating task decomposition allocation using
partial global planning. Huhns, M., & Gasser, L. (Eds.), Distributed AI, Vol. 2.
Morgan Kaufmann.
Durfee, E. H., & Lesser, V. R. (1991). Partial global planning: coordination framework distributed hypothesis formation. IEEE Transactions System, Man,
Cybernetics, 21 (5), 1167{1183.
Ephrati, E., Pollack, M. E., & Rosenschein, J. S. (1995). tractable heuristic maximizes global utility plan combination. Proceedings First International Conference Multiagent Systems, pp. 94{101 San Francisco.
134

fiPlanning Concurrent Interacting Actions

Fagin, R., Halpern, J. Y., Moses, Y., & Vardi, M. Y. (1995). Reasoning Knowledge.
MIT Press, Cambridge, MA.
Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 2 (3{4), 189{208.
Ghallab, M., & Alaoui, A. M. (1989). Managing eciently temporal relations
indexed spanning trees. Proceedings Eleventh International Joint Conference
Artificial Intelligence, pp. 1297{1303 Detroit.
Giunchiglia, E. (2000). Planning satisfiability expressive action languages: Concurrency, constraints nondeterminism. Proceedings Seventh International
Conference Principles Knowledge Representation Reasoning (KR'00), pp.
657{666 Breckenridge, CO.
Giunchiglia, E., & Lifschitz, V. (1998). action language based causal explanation:
Preliminary report. Proceedings Fifteenth National Conference Artificial
Intelligence, pp. 623{630 Madison, WI.
Grosz, B. J., Hunsberger, L., & Kraus, S. (1999). Planning acting together. AI
Magazine, 20 (4), 13{22.
Jensen, R. M., & Veloso, M. M. (2000). OBDD-based universal planning synchronized
agents non-deterministic domains. Journal Artificial Intelligence Research, 13,
189{226.
Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings Thirteenth National Conference Artificial
Intelligence, pp. 1194{1201 Portland, OR.
Khatib, O., Yokoi, K., Chang, K., Ruspini, D., Holmberg, R., Casal, A., & Baader, A.
(1996). Force strategies cooperative tasks multiple mobile manipulation systems.
Giralt, G., & Hirzinger, G. (Eds.), Robotics Research 7, Seventh International
Symposium, pp. 333{342. Springer-Verlag, Berlin.
Knoblock, C. A. (1994). Generating parallel execution plans partial-order planner.
Proceedings Second International Conference AI Planning Systems, pp.
98{103 Chicago.
Koehler, J. (1998). Planning resource constraints. Proceedings Thirteenth
European Conference Artificial Intelligence, pp. 489{493 Brighton, UK.
Lin, F., & Shoham, Y. (1992). Concurrent actions situation calculus. Proceedings
Tenth National Conference Artificial Intelligence, pp. 590{595 San Jose.
Lingard, A. R., & Richards, E. B. (1998). Planning parallel actions. Artificial Intelligence,
99 (2), 261{324.
McCarthy, J., & Hayes, P. (1969). philosophical problems standpoint
artificial intelligence. Machine Intelligence, 4, 463{502.
135

fiBoutilier & Brafman

Moses, Y., & Tennenholtz, M. (1995). Multi-entity models. Machine Intelligence, 14, 63{88.
Penberthy, J. S., & Weld, D. S. (1992). UCPOP: sound, complete, partial order planner
ADL. Proceedings Third International Conference Principles Knowledge
Representation Reasoning (KR'92), pp. 103{114 Cambridge, MA.
Pinto, J. (1998). Concurrent actions interacting effects. Proceedings Sixth
International Conference Principles Knowledge Rerpresentation Reasoning
(KR'98), pp. 292{303 Trento.
Reiter, R. (1978). closed world databases. Gallaire, H., & Minker, J. (Eds.), Logic
Databases, pp. 55{76. Plenum, New York.
Reiter, R. (1991). frame problem situation calculus: simple solution (sometimes) completeness result goal regression. Lifschitz, V. (Ed.), Artificial
Intelligence Mathematical Theory Computation (Papers Honor John McCarthy), pp. 359{380. Academic Press, San Diego.
Reiter, R. (1996). Natural actions, concurrency continuous time situation calculus. Proceedings Fifth International Conference Principles Knowledge
Representation Reasoning (KR'96), pp. 2{13.
Stone, P., & Veloso, M. M. (1999). Task decomposition, dynamic role assignment, lowbandwidth communication real-time strategic teamwork. Artificial Intelligence,
110 (2), 241{273.
Weld, D. S. (1994). introduction least commitment planning. AI Magazine, 15 (4),
27{61.
Wilkins, D. E., & Myers, K. L. (1998). multiagent planning architecture. Proceedings
Fourth International Conference AI Planning Systems, pp. 154{162 Pittsburgh.
Wolverton, M. J., & des Jardins, M. (1998). Controlling communication distributed planning using irrelevance reasoning. Proceedings Fifteenth National Conference
Artificial Intelligence, pp. 868{874 Madison, WI.

136


