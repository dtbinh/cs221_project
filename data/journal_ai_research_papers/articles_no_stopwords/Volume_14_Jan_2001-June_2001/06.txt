Journal Artificial Intelligence Research 14 (2001) 167{203

Submitted 12/99; published 04/01

What's Attribute?
Consequences Least Common Subsumer

Ralf Kusters

kuesters@ti.informatik.uni-kiel.de

Institut f
ur Informatik und Praktische Mathematik
Christian-Albrechts-Universit
zu Kiel
24098 Kiel
Germany

Alex Borgida

borgida@cs.rutgers.edu

Department Computer Science
Rutgers University
Piscataway, NJ 08855
USA

Abstract

Functional relationships objects, called \attributes", considerable importance knowledge representation languages, including Description Logics (DLs). study
literature indicates papers made, often implicitly, different assumptions
nature attributes: whether always required value, whether
partial functions. work presented first explicit study
difference subclasses Classic DL, involving same-as concept constructor.
shown although determining subsumption concept descriptions
complexity (though requiring different algorithms), story different case
determining least common subsumer (lcs). attributes interpreted partial
functions, lcs exists computed relatively easily; even case results
correct extend three previous papers lcs DLs. case attributes
must value, lcs may exist, even exists may exponential size.
Interestingly, possible decide polynomial time lcs exists.
1. Introduction

Knowledge representation systems based Description Logics (DLs) subject continued attention Artificial Intelligence, subject theoretical studies
(Borgida, 1994; Baader, 1996; Baader & Sattler, 2000; Giacomo & Lenzerini, 1996; Calvanese, Giacomo, & Lenzerini, 1999b) applications (Artale, Franconi, Guarino, &
Pazzi, 1996; Brachman, McGuinness, Patel-Schneider, & Borgida, 1999; McGuinness &
Patel-Schneider, 1998). impressively, DLs found applications areas involving information processing, databases (Borgida, 1995; Calvanese, Lenzerini,
& Nardi, 1999), semi-structured data (Calvanese, Giacomo, & Lenzerini, 1998, 1999a),
information integration (Calvanese, Giacomo, Lenzerini, Nardi, & Rosati, 1998; Borgida
& Kusters, 2000), well general problems configuration (McGuinness
& Wright, 1998) software engineering (Borgida & Devanbu, 1999; Devanbu & Jones,
1997). fact, wherever ubiquitous term \ontology" used days (e.g., pro c 2001 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

steres, Borgida
Ku

viding semantics web/XML documents), DLs prime contenders
clear semantics well-studied computational properties.
Description Logics, one takes object-centered view, world modeled
individuals, connected binary relationships (here called roles), grouped classes
(called concepts). familiar Predicate Logic, objects correspond
constants, roles binary predicates, concepts unary predicates. every DL system,
concepts application domain described concept descriptions built
atomic concepts roles using \constructors" provided DL language.
example, consider situation want concept describing individual cars
frequent (at least 10) repairs, record fact cars, model
manufacturer's model. Concepts thought built
(possibly nested) simpler noun-phrases, concept, called Lemon sequel,
might captured conjunction
(objects Cars)
(things whose model values concept Model)
(things whose madeBy values concept Manufacturer)
(things whose model value model madeBy attribute)
(things least 10 repairs values)
(things whose repairs values RepairReport).
Using syntax classic language, abbreviate above, emphasizing
term-like nature descriptions constructors used each:
(and Car
(all model Model)
(all madeBy Manufacturer)
(same-as (model) (madeBy model))
(at-least 10 repairs)
(all repairs RepairReport))
So, example, concept term (at-least n p) constructor at-least, denotes
objects related relationship p least n objects; turn, (all p
C) instances exactly objects related p instances C.
Finally, present concept mathematical notation succinct
preferred formal work DLs:
Lemon := Car u
8model:Model u
8madeBy:Manufacturer u
madeBy # (model madeBy) u
10 repairs u
8repairs:RepairReport

Unlike preceding formalisms, semantic networks frames (Quillian, 1968; Minsky,
1975), DLs equipped formal semantics, given translation
168

fiWhat's Attribute?

first-order predicate logic (Borgida, 1994), example. Moreover, DL systems provide
users various inference capabilities allow deduce implicit knowledge
explicitly represented knowledge. instance, subsumption algorithms allow one
determine subconcept-superconcept relationships: C subsumed (C v D)
instances C instances D, i.e., first description always interpreted
subset second description. example, concept Car obviously subsumes
concept description Lemon, (at-least 10 repairs) subsumed (at-least 8 repairs).
traditional inference problems DL systems, subsumption, inconsistency
detection, membership checking, well-investigated. Algorithms detailed
complexity results realizing inferences available variety DLs differing
expressive power | see, e.g., (Baader & Sattler, 2000) overview.
1.1 Least Common Subsumer

least common subsumer (lcs) concepts specific concept description subsuming given concepts. Finding lcs first introduced new inference problem
DLs Cohen, Borgida, Hirsh (1992). One motivation considering lcs
use alternative disjunction. idea replace disjunctions C1 C
lcs C1; : : : ; C . Borgida Etherington (1989) call operation knowledge-base
vivification. Although, general, lcs equivalent corresponding disjunction,
best approximation disjunctive concept within available language. Using
approximation motivated fact that, many cases, adding disjunction
would increase complexity reasoning.1
proposed Baader et al. (Baader & Kusters, 1998; Baader, Kusters, & Molitor,
1999), lcs operation used support \bottom-up" construction DL knowledge bases, where, roughly speaking, starting \typical" examples lcs algorithm
used compute concept description (i) contains examples, (ii)
specific description satisfying property (i). Baader Kusters presented
algorithm cyclic ALN -concept descriptions; ALN relatively simple language allowing concept conjunction, primitive negation, value restrictions, number
restrictions. Also, Baader et al. (1999) proposed lcs algorithm DL allowing
existential restrictions instead number restrictions.
Originally, lcs introduced operation context inductive learning
examples (Cohen et al., 1992), several papers followed lead. DLs
considered mostly sublanguages Classic allowed same-as equalities, i.e.,
expressions (same-as (madeBy) (model madeBy)). Cohen et al. proposed lcs
algorithm ALN language allows concept conjunction same-as,
call . algorithm extended Cohen Hirsh (1994a) CoreClassic, additionally allows value restrictions (see (Cohen & Hirsh, 1994b)
experimental results). Finally, Frazier Pitt (1996) presented lcs algorithm full
Classic.
n

n

1. Observe language already allows disjunction, lcs(C1 ; : : : ; Cn ) C1 Cn .
particular, means that, languages, lcs really interest.

169

steres, Borgida
Ku

1.2 Total vs. Partial Attributes

knowledge representation systems, including DLs, functional relationships,
called attributes (also called \features" literature), distinguished subclass
general relationships, least part functional restrictions occur frequently
practice2 . example, clearly madeBy model meant attributes,
thus making unnecessary number restrictions (and (at-most 1 madeBy) (at-least
1 madeBy)). addition, distinguishing attributes helps identify tractable subsets DL
constructors: Classic, coreferences attribute chains (as examples)
reasoned eciently (Borgida & Patel-Schneider, 1994), changed
roles, e.g., allowed (same-as (repairs) (ownedBy repairsPaidFor)), subsumption problem becomes undecidable (Schmidt-Schau, 1989).
Whereas distinction roles attributes DLs theoretically
practically well understood, discovered another distinction, namely one attributes interpreted total functions (total attributes ) interpreted
partial functions (partial attributes ), \slipped cracks" contemporary
research. total attribute always value \the world there", even
know knowledge base currently. partial attribute may value.
distinction useful practice, since difference car possibly,
necessarily, CD player, car necessarily manufacturer (which
may known current knowledge base). latter modeled defining
attribute madeBy total attribute. Note madeBy total attribute,
every individual world discourse (not cars) must filler madeBy.
Since, however, structural information provided fillers madeBy non-car individuals, implications drawn fillers trivial. Thus, making madeBy total
attribute seems reasonable case. car's CD player, hand,
modeled partial attribute express fact cars required CD
player. indicate particular car CD player, one would add
description (at-least 1 CDplayer).
1.3 New Results

mentioned above, conjunction same-as constructor, roles attributes
behave differently respect subsumption. main objective paper
show distinction total partial attributes induces significantly different
behaviour computing lcs, presence same-as. precisely, purpose
paper twofold.
First, show respect complexity deciding subsumption
difference partial total attributes. Borgida Patel-Schneider (1994)
shown attributes total, subsumption classic concept descriptions
decided polynomial time. shown present work, slight modifications
algorithm proposed Borgida Patel-Schneider suce handle partial attributes.
2. Readers coming Machine Learning community aware difference
\attributes" (functional roles) \attributes", components input feature vector
usually describes exemplar.

170

fiWhat's Attribute?

Moreover, modifications change complexity algorithm. Thus, partial
total attributes behave similarly subsumption point view.
Second, surprising result paper, distinction
partial total attributes significant impact problem computing
lcs. Previous results sublanguages classic show partial attributes used,
lcs two concept descriptions always exists, computed polynomial time.
If, however, total attributes involved, situation different. lcs need
longer even exist, case exists size may grow exponential size
given concept descriptions. Nevertheless, existence lcs two concept descriptions
decided polynomial time.
Specifically, previous work (Cohen et al., 1992; Cohen & Hirsh, 1994a; Frazier &
Pitt, 1996) concerning lcs computation classic, constructions proofs
made without realizing difference two types attributes. Without going
details here, main problem lcs merely finite graphs employed,
making constructions applicable partial attribute case. addition fixing
problems, paper presents proper handling inconsistent concepts
lcs algorithm classic presented Frazier Pitt (1996).
Although results subsumption intriguing, proofs show
results lcs make extensive use corresponding subsumption algorithms,
one reason present beforehand paper.
Returning general differences cases total partial attributes,
one could say fundamental cause differences lies same-as constructor,
whose semantics normally requires (i) two chains attributes value,
(ii) values coincide. case total attributes, same-as obeys principle
C v u # v implies C v u w # v w
u,v, w sequences total attributes, e.g., (madeBy model), condition
(i) ensured total aspect attributes. case partial attributes,
implication hold, w, hence u w, longer guaranteed
value, implying same-as restriction may hold. Clearly, implication affects
results subsumption. far lcs concerned, certain graph (representing lcs
two given concepts) may infinite case total attributes, thus jeopardizing
existence lcs.
general significance result knowledge representation language
designers users need explicitly check beginning whether deal total partial attributes choice significant effects. Although
situations total attributes convenient, guarantee existence attributes without
resort number restrictions, results show drawbacks.
things considered, requiring attributes total appears less desirable. Concerning classic, technical results paper support use partial attributes
ensure existence lcs computation polynomial time
well ecient decision subsumption. Moreover, current implementation
classic subsumption algorithm require major changes order handle partial
attributes.
171

steres, Borgida
Ku

outline paper follows: following section, basic notions necessary investigations introduced. Then, two subsequent sections, subsumption lcs computation classic partial attributes investigated. precisely,
Section 3 offer subsumption algorithm sublanguage classic classic,
contains main classic-constructors; Section 4, present lcs algorithm
classic concept descriptions, along lines proposed Cohen Hirsh
(1994a), formally prove correctness, thereby resolving shortcomings previous
lcs algorithms, handle inconsistencies properly. Finally, Section 5 covers
central new result paper, i.e., lcs computation presence total attributes.
section, restrict investigations sublanguage classic order
concentrate changes caused going partial total attributes. Nevertheless,
strongly conjecture results proved section easily extended
classic classic using similar techniques one employed two previous
sections.
2. Formal Preliminaries

section, introduce syntax semantics description languages considered paper formally define subsumption equivalence concept descriptions.
Finally, least common subsumer concept descriptions specified.
Definition 1 Let C , R, disjoint finite sets representing set concept names,
set role names, set attribute names. set classic -concept
descriptions C , R, inductively defined follows:
Every element C concept description (concept name, Car).
symbol > concept description (top concept, denoting universe
objects).
r 2 R role n 0 nonnegative integer, n r n r concept
descriptions (number restrictions, 10 repairs).
C concept descriptions, C u concept description (concept
conjunction).




C concept description r role attribute,
description (value restriction, 8madeBy:Manufacturer).

8r:C

concept

k; h 0 non-negative integers a1 ; : : : ; ; b1 ; : : : ; b 2 attributes,
# b1 b concept description (same-as equality, madeBy #
model madeBy). Note two sequences may empty, i.e., k = 0 h = 0.
empty sequence denoted ".
k

a1

k

h

h

Often dispense composition attributes. example, sequence
a1 simply written a1 . Moreover, use 8r1 r :C abbreviation
8r1:8r2 8r :C , 8":C case n = 0, denotes C .
usual, semantics classic defined model-theoretic way means
interpretations.
k

n

k

n

172

fiWhat's Attribute?

Definition 2 interpretation consists nonempty domain interpretation
function . interpretation function assigns extensions atomic identifiers follows:





extension concept name E subset E domain.
extension role name r subset rI .

extension attribute name partial function aI , i.e.,
(x; y1 ) 2 aI (x; y2 ) 2 aI y1 = y2 .
Given roles attributes r , use (r1 r )I denote composition binary
relations rI . n = 0 result "I , denotes identity relation, i.e., "I :=
f(d; d) j 2 g. individual 2 , define rI (d) := fe j (d; e) 2 rI g. r 's
attributes, say (r1 r )I defined iff (r1 r )I (d) 6= ;; occasionally,
refer (r1 r )(d)I image (r1 r )I (d).
extension C concept description C inductively defined follows:
>I := ;


n





n

n

n

n

( n r)I := fd 2 j cardinality(fe 2 j (d; e) 2 rI g) ng;
( n r)I := fd 2 j cardinality(fe 2 j (d; e) 2 rI g) ng;
(C u D)I := C \ DI ;
(8r:C )I := fd 2 j rI (d) C g r role attribute;
(a1 # b1 b )I := fd 2 j (a1 )I (b1 b )I defined
(a1 )I (d) = (b1 b )I (d)g:
Note definition attributes interpreted partial functions. Since
main point paper demonstrate impact different semantics attributes,
occasionally restrict set interpretations map attributes total
functions. interpretations called t-interpretations attributes interpreted
way called total attributes order distinguish partial ones.
stress, remarked introduction, definition (a1 # b1 b )I ,
a1 b1 b must defined order satisfy same-as restriction.
Although standard semantics same-as equalities, one could think
relaxing restriction. example, same-as condition might specified hold
either paths undefined images defined identical values.
third definition might satisfied even one paths undefined.
definitions semantics same-as might lead different results. However,
paper pursue standard semantics.
subsumption relationship concept descriptions defined follows.
Definition 3 concept description C subsumed concept description (C v
short) interpretations , C DI . consider total
interpretations, get t-subsumption: C v iff C DI t-interpretations .






k

h

k

h

k

h

k

k

h



173

h

steres, Borgida
Ku

defined subsumption, equivalence concept descriptions defined usual way:
C v v C . T-equivalence C specified analogously.
already mentioned introduction, main difference partial total
attributes respect subsumption u # v v u w # v w holds attribute
chains u; v; w, whereas necessarily case u # v v u w # v w.
Finally, introducing lcs operation formally concluding section,
comment expressive power classic , since (syntactically) classic lacks
common constructors. Although classic , introduced here, contain bottom
concept ? explicitly, expressed by, e.g., ( 1 r) u ( 0 r). use ?
abbreviation inconsistent concept descriptions. Furthermore, primitive negation, i.e.,
negation concept names, simulated number restrictions. concept name
E one replace every occurrence E ( 1 r ) negation :E E ( 0 r )
r new role name. Finally, attribute following equivalences hold:
( n a) ? n 2; ( 1 a) (a # a); ( 0 a) >; ( n a) > n 1;
( 0 a) (8a:?). show lose expressive power allowing
number restrictions attributes. Still, full classic somewhat expressive
classic . mainly due introduction individuals (also called nominals)
classic. sake completeness give syntax full classic language.3
requires set, O, representing set individual names. define
two additional concept constructors
fe1 ; :::; e g, individuals e 2 (enumeration all; Summer; Springg)
p : e role attribute p, individual e (fills currentSeason : Summer).
technical report, Kusters Borgida (1999) extend results presented
work full classic, case individuals non-standard semantics.
least common subsumer set concept descriptions specific concept
subsuming concept descriptions set:
Definition 4 concept description least common subsumer (lcs) concept
descriptions C1 ; : : : ; C (lcs(C1 ; : : : ; C ) short) iff i) C v = 1; : : : ; n ii)
every D0 property v D0 . Analogously, define lcs (C1 ; : : : ; C ) using v
C





E

E

E





n

n





instead v.

n



Note lcs concept descriptions may exist, does, definition
uniquely determined equivalence. sense, may refer lcs.
following two sections, attributes always interpreted partial functions;
Section 5 consider total attributes.
3. Characterizing Subsumption

classic

section modify characterization t-subsumption Classic, proposed
Borgida Patel-Schneider (1994), handle case partial attributes.
3. Even omitting constructs dealing integers so-called \host individuals",
cannot roles act role/attribute fillers.

174

fiWhat's Attribute?

detail, tools used deciding subsumption intimately related
computation lcs.
T-subsumption Classic decided multi-part process. First, descriptions
turned description graphs. Next, description graphs put canonical form,
certain inferences explicated redundancies reduced combining nodes
edges graph. Finally, t-subsumption determined description
canonical description graph.
order \inherit" proofs, tried minimize necessary adjustments
specification (Borgida & Patel-Schneider, 1994). reason, roughly speaking,
attributes treated roles unless form part same-as equality. (Note
attributes participating same-as construct must values!) extent,
allow us adopt semantics original description graphs, crucial
proofs. However, two different occurrences attributes, namely, same-as equality
vs. role value-restriction, require us modify extend definition description
graphs, normalization rules, subsumption algorithm itself.
following, present steps subsumption algorithm detail. start
definition description graphs.
3.1 Description Graphs

Intuitively, description graphs ect syntactic structure concept descriptions.
description graph labeled, directed multigraph, distinguished node. Roughly
speaking, edges (a-edges ) graph capture constraints expressed same-as
equalities. labels nodes contain, among others, set so-called r-edges,
correspond value restrictions. Unlike description graphs defined Borgida
Patel-Schneider, r-edges labeled role names attribute
names. (We shall comment later advantage modification order deal
partial attributes.) r-edges lead nested description graphs, representing concepts
corresponding value restrictions.
defining description graphs formally, Figure 1 present graph corresponding
concept description Lemon defined introduction. use G(Manufacturer),
G(Model), well G(RepairReport) denote description graphs concept names
Manufacturer, Model, RepairReport. graphs simple; merely consist
one node, labeled corresponding concept name. general, graphs
complex since value restriction 8r:C leads (possibly complex) nested
concept description C .
Although number restrictions attributes allowed, r-edges labeled attributes, model madeBy, always restriction [0; 1] order capture
semantics attributes. Formally, description graphs, nodes, edges defined mutually
recursively follows:
Definition 5 description graph G tuple (N; E; n0 ; l), consisting finite set N
nodes; finite set E edges (a-edges); distinguished node n0 2 N (root graph);
function l N set labels nodes. occasionally use notation
G:N odes, G:Edges, G:root access components N , E n0 graph G.
175

steres, Borgida
Ku

f>g

madeBy

f>g

RepairReport)

G(

madeBy

repairs

model

[10; 1]

Model)

G(

model [0; 1]

fCar >g
;

madeBy [0; 1]

Manufacturer)

G(

Figure 1: description graph Lemon, large node root graph
a-edge tuple form (n1 ; a; n2 ) n1 , n2 nodes attribute
name.
label node defined ? tuple form (C; H ), consisting finite
set C concept names (the atoms node) finite set H tuples (the r-edges
node). Concept names description graph stand atomic concept names >.
occasionally use notation n:Atoms n:REdges access components C
H node n.
r-edge tuple, (r; m; M; G0 ), consisting role attribute name, r; min, m,
non-negative integer; max, , non-negative integer 1;
(recursively nested) description graph G0 . graph G0 often called restriction
graph node role r. require nodes G0 distinct nodes
G nested description graphs G. r attribute, require: = 0
2 f0; 1g.

Given description graph G node n 2 G:N odes, define Gj graph
(N; E; n; l); Gj said rooted n. sequence p = n0a1 a2 n k 0
(n 1; ; n ) 2 G:Edges, = 1; : : : ; k, called path G node n0 n (p 2 G
short); k = 0 path p called empty; w = a1 called label p (the
empty path label "); p called rooted n0 root G. Occasionally, write
n0 a1 n 2 G omitting intermediate nodes.
Throughout work make assumption description graphs connected.
description graph said connected nodes graph reached
rooted path nested graphs connected. semantics description graphs (see
Definition 6) altered nodes cannot reached root deleted.
order merge description graphs need notion \recursive set nodes"
description graph G: recursive set nodes G union nodes G
recursive set nodes nested description graphs G.
concept descriptions, semantics description graphs defined means
interpretation . introduce function assigns individual domain
every node graph. ensures same-as equalities satisfied.
n

k

n







k

k

k

k

k

176

fiWhat's Attribute?

Definition 6 Let G = (N; E; n0 ; l) description graph let interpretation.
element, d, GI , iff total function, , N

1.



= (n0);

2 N , (n) 2 nI ;
3. (n1 ; a; n2 ) 2 E ((n1 ); (n2 )) 2 aI .
extension nI node n label ? empty set. element, d, nI ,
2.



( ) = (C; H ), iff

l n

2 C , 2 B ;
(r; m; M; G0 ) 2 H ,

1.
2.

n

B

(a) elements, d0 , domain

(b) d0 2 G0I d0 (d; d0 ) 2 rI .

(d; d0 ) 2 rI ;

Cohen Hirsh (1994a) defined semantics description graphs different way,
avoiding introduction total function . problem definition is,
however, well-defined acyclic graphs, which, example, excludes sameas equalities form " # spouse spouse, even p # p q.
semantics graphs proposed Borgida Patel-Schneider (1994) similar
Definition 6. However, paper a-edges captured same-as equalities
value restrictions attributes. Still, context partial attributes, could
define semantics description graphs means total function since
attributes might fillers. Specifying semantics description graphs terms
partial mappings would make definition even longer. Furthermore, proofs
(Borgida & Patel-Schneider, 1994) would carry easily. Therefore, order
keep total function, value restrictions attributes initially always translated redges. next section present translation concept descriptions description
graphs detail.
defined semantics description graphs, subsumption equivalence description graphs (e.g., H v G) well concept descriptions description
graphs (e.g., C v G) defined way subsumption equivalence
concept descriptions.
3.2 Translating Concept Descriptions Description Graphs

Following Borgida Patel-Schneider (1994), classic concept description turned
description graph recursive process. process, nodes description
graphs often merged.
Definition 7 merge two nodes, n1 n2 , new node n following label:
n1 n2 label ?, label n ?. Otherwise labels equal
?, n:Atoms = n1:Atoms [ n2:Atoms n:REdges = n1:REdges [ n2:REdges.
177

steres, Borgida
Ku

G1 = (N1 ; E1 ; n1 ; l1 ) G2 = (N2 ; E2 ; n2 ; l2 ) two description graphs disjoint
recursive sets nodes, merge G1 G2 , G := G1 G2 = (N; E; n0 ; l), defined
follows:

3.

:= n1 n2;
N := (N1 [ N2 [ fn0 g) n fn1 ; n2 g;
E := (E1 [ E2 )[n1 =n0 ; n2 =n0 ], i.e., E union E1 E2 every occurrence

4.

l n

1.
2.

n0

n1 ; n2 substituted n0 ;

( ) := l1(n) n 2 N1 n fn1g; l(n) := l2 (n) n 2 N2 n fn2 g; l(n0)

defined label obtained merging n1

n2 .

Now, classic -concept description C turned corresponding description
G(C ) following translation rules.
1. > turned description graph one node n0 a-edges. atom
node > set r-edges empty.
2. concept name turned description graph one node a-edges.
atoms node contain concept name node r-edges.
3. description form ( n r) turned description graph one node
a-edges. node atoms > single r-edge (r; n; 1; G(>))
G(>) specified first translation rule.
4. description form ( n r) turned description graph one node
a-edges. node atom > single r-edge (r; 0; n; G(>)).
5. description form a1 # b1 b turned graph pairwise
distinct nodes n1; : : : ; n 1; m1; : : : ; 1, root m0 := n0, additional node
n = := n; set a-edges consists (n0 ; a1 ; n1 ), (n1 ; a2 ; n2 ); : : : ; (n 1 ; ; n )
(m0; b1 ; m1 ), (m1; b2 ; m2 ), : : :, (m 1; b ; ), i.e., two disjoint paths coincide starting point, n0, final point, n. (Note p = 0 first
path empty path n0 n0 q = 0 second path empty path
n0 n0.) nodes > atom r-edges.
6. description form 8r:C , r role, turned description graph
one node a-edges. node atom f>g single r-edge
(r; 0; 1; G(C )).
7. description form 8a:C , attribute, turned description
graph one node a-edges. node atom f>g single
r-edge (a; 0; 1; G(C )). (In work Borgida Patel-Schneider, concept
description 8a:C turned a-edge. already mentioned, would cause
problems attributes interpreted partial functions defining semantics
means specified Definition 6.)

graph

p

p

p

q

q

q

p

q

178

q

q

p

p

fiWhat's Attribute?

8. turn description form C u description graph, construct G(C )
G(D ) merge them.
Figure 1 shows description graph built way concept Lemon example.
easily verified translation preserves extensions:
Theorem 1 concept description C corresponding description graph G(C )
equivalent, i.e.,C = G(C )I every interpretation .
main diculty proof theorem showing merging two description
graphs corresponds conjunction concept descriptions.
Lemma 1 interpretations , n1 n2 nodes, (n1 n2 )I = nI1 \ nI2 ;

G1 G2 description graphs (G1 G2 )I = GI
1 \ G2 .
proof preceding statement rather simple one (Borgida & PatelSchneider, 1994).
3.3 Translating Description Graphs Concept Descriptions

Although characterization subsumption require translating description
graphs back concept descriptions, translation presented show concept descriptions description graphs equivalent representations classic concept
descriptions. subsequent sections, fact need turn graphs concept descriptions.
translation description graph G specified rather straightforward
recursive definition. main idea translation stems Cohen Hirsh (1994a),
employed spanning trees translate same-as equalities. spanning tree (connected) graph tree rooted node graph containing nodes
graph. particular, coincides graph except a-edges deleted.
example, one possible spanning tree G Figure 1 obtained deleting a-edge
labeled madeBy, whose origin root G.
Now, let G connected description graph spanning tree it. Then,
corresponding concept description C obtained conjunction following
descriptions:
1. C contains (i) same-as equality v # v every leaf n , v label
rooted path n; (ii) same-as equality v1 # v2 a-edge
(n1 ; a; n2) 2 G:Edges contained , v label rooted path
n , = 1; 2.
2. every node n , C contains value restriction 8v:C , v label
rooted path n, C denotes translation label n, i.e., C
conjunction obtained follows:
every concept name atoms n conjunct C ;
every r-edge (r; m; M; G0 ) n, C contains (a) number restrictions (mr)
( r) (in case r role 6= 1) (b) value restriction 8r:C 0 ,
C 0 recursively defined translation G0 .
G

G





G

n

n

n

n

n

G

G

179

steres, Borgida
Ku

case set atoms r-edges n empty, define C := >.
Referring graph G Figure 1, C contains same-as equalities model madeBy #
model madeBy madeBy # model madeBy. Furthermore, n0 denotes root G,
C value restrictions 8":C , 8model:>, 8model madeBy:>, C
corresponds Lemon defined introduction, without same-as equality. Note
that, although case same-as equality model madeBy # model madeBy
needed, one cannot dispense 1.(i) construction above, illustrated following example: Without 1.(i), description graph G(a # a) would turned
description >, equivalent # since same-as equality requires
path value, may case.
easy prove translation thus defined correct following sense
(Kusters & Borgida, 1999).
n

G

n0

G

n0

Lemma 2 Every connected description graph G equivalent translation C , i.e.,
interpretations : GI = C .
G

G

3.4 Canonical Description Graphs

following occasionally refer \marking node incoherent"; means
label node changed ?. \Marking description graph incoherent" means
description graph replaced graph G(?) corresponding ?, i.e., graph
consisting one node label ?.
One important property canonical description graphs deterministic,
i.e., every node one outgoing edge (a-edge r-edge) labeled
attribute role name. Following Borgida Patel-Schneider (1994), order turn
description graph canonical graph need merge a-edges r-edges. addition,
different work, might necessary \lift" r-edges a-edges.
merge two a-edges (n; a; n1) (n; a; n2 ) description graph G, replace
single new edge (n; a; n0 ) n0 result merging n1 n2. addition,
replace n1 n2 n0 a-edges G.
order merge two r-edges (r; s1 ; k1 ; G1 ), (r; s2 ; k2 ; G2 ) replace new r-edge
(r; max(s1 ; s2 ); min(k1 ; k2 ); G1 G2 ).
lift r-edge (a; m; M; G ) node n concept graph G a-edge
(n; a; n1 ), remove n:REdges, augment G adding G :N odes G:N odes,
G :Edges G:Edges, well adding (n; a; G :Root) G:Edges. precondition
applying transformation = 1, = 0 G corresponds graph
G(?). reason precondition r-edge form (a; 0; 0; G ) lifted
without G inconsistent, fact a-successors allowed lost. Normalization rule 5 (see below) guarantee precondition always satisfied.
description graph G transformed canonical form exhaustively applying
following normalization rules. graph called canonical none rules
applied.
1. node G marked incoherent, mark description graph incoherent.
(Reason: Even node root, attributes corresponding a-edges must always














180

fiWhat's Attribute?

value (since participate same-as equalities), value cannot belong

)
2. r-edge node min greater max, mark node incoherent.
(Reason: 2
1
)
3. Add > atoms every node, absent.
4. r-edge node restriction graph marked incoherent, change max
0. (Reason: ( 0 )
.)
5. r-edge node max 0, mark restriction graph incoherent.
(Reason: See 4.)
6. r-edge form (r; 0; 1; G0 ) G0 contains one node empty
set atoms atoms set f>g r-edges, remove r-edge.
(Reason:
.)
7. node two r-edges labeled role, merge two edges,
described above. (Reason:
(
).)
8. description graph two a-edges node labeled
attribute, merge two edges, described above. (Reason:
(
).)
9. node graph a-edge r-edge attribute,
\lift r-edge" precondition satisfied (see above). (Reason: value
restrictions imposed attributes participate same-as equalities must made explicit
gathered one place similar previous cases.)
need show transformations canonical form change semantics
graph. main diculty showing merging processes lifting
preserve semantics. difference (Borgida & Patel-Schneider, 1994)
addition merging r-edges a-edges need lift r-edges. Therefore,
omit proofs showing merging edges preserves extensions. proofs
following two lemmas routine quite similar one Lemma 5.
Lemma 3 Let G = (N; E; n0 ; l) description graph two mergeable a-edges let
G0 = (N 0 ; E 0 ; n0 ; l0 ) result merging two a-edges. Then, G G0 .
empty set.



r u



r ?

r

8r:?

8r:> >

8r:C u 8r:D 8r: C u

8a:C u 8a:D

8a: C u

Lemma 4 Let n node two mergeable r-edges let n0 node
edges merged. Then, nI = n0I every interpretation .
Lemma 5 Let G = (N; E; n0 ; l) description graph node n a-edge (n; a; n00 ).
Suppose n associated r-edge (a; m; M; G ). Provided precondition lifting
r-edges satisfied G0 = (N 0 ; E 0 ; n0 ; l0 ) result transformation,
G G0 .
Proof. sucient show GIj = G0 Ij , since label n changed G0


n obtains additional a-edge, points graph G connected
n

n



181

steres, Borgida
Ku

RepairReport

G

fModel >g
;

model

repairs

model

[10; 1]

fCar >g
;

madeBy

fManufacturer >g
;

Figure 2: canonical description graph Lemon, left-most node root.
rest G0 . W.l.o.g. therefore may assume n root G, i.e., n = n0. Let
2 GI . Thus, function N specified Definition 6
individual e = (n), e = (n00), (d; e) 2 aI . implies e 2 GI . Hence,
exists function 0 G :N odes G e satisfying conditions
Definition 6. Since sets nodes G G disjoint, define 00
union 0, i.e., 00 (m) := (m) nodes G 00(m) := 0(m)
nodes G . Since, construction, additional a-edge (n; a; G :Root) 2 E 0
(00(n); 00 (G :Root)) 2 aI , follows conditions Definition 6 satisfied
G0, thus, 2 G0I .
let 2 G0I . Thus, function 00 N 0 according Definition 6.
Let e := 00(G :Root) = 00(n00). Let G00 description graph obtain G0
deleting nodes corresponding G , graph G without r-edge
(a; m; M; G ). restrict 00 nodes G00 , follows 2 G00I . Furthermore,
restricting 00 nodes G yields e 2 GI . particular, G marked
incoherent. Then, precondition ensures = 1. Thus, since e a-successor
d, conclude 2 GI .
ut


























dealt issue merging lifting, easy verify \normalization" affect meaning description graphs.
Theorem 2 G description graph G0 corresponding canonical description
graph, G G0 .

example, canonical description graph graph given Figure 1 depicted
Figure 2.
3.5 Subsumption Algorithm

final part subsumption process checking see canonical description graph
subsumed concept description. Borgida Patel-Schneider (1994),
attributes total, turns necessary turn potential subsumer
canonical description graph. subsumption algorithm presented next
considered characterization subsumption.
182

fiWhat's Attribute?

Algorithm 1 (Subsumption Algorithm) Given concept description description graph G = (N; E; n0 ; l), subsumes?(D; G) defined true one
following conditions hold:
1. description graph
2.



3.



4.



5.



G

marked incoherent.

concept name >, element atoms n0 .

( n r) i) r-edge n0 r role, min greater equal
n; ii) n = 0.

( n r) r-edge n0 r role, max less equal n.


# b1 b

, rooted paths label
G ending node.
a1

n



a1



n



b1

b



8r:C , role r, either (i) r-edge n0 r role G0
restriction graph subsumes?(C; G0 ); (ii) subsumes?(C; G(>)). (Reason:
8r:> >.)
7. 8a:C , attribute a, (i) a-edge G form (n0 ; a; n0 ),
subsumes?(C; (N; E; n0 ; l)); (ii) r-edge n0 attribute, G0
restriction graph subsumes?(C; G0 ); (iii) subsumes?(C; G(>)).

6.



8.



E u F subsumes?(E; G) subsumes?(F; G) true.

two differences algorithm one total attributes presented Borgida Patel-Schneider (see Algorithm 2). First, partial attribute
case, given = 8a:C , one needs look value restriction either a-edge
r-edge G, since attributes label a-edges r-edges. (In total attribute
case, attributes label a-edges examining r-edges necessary.)
second important distinction treatment same-as equalities. shown
algorithm, = a1 # b1 b one needs check whether
exist two paths labeled v := a1 w := b1 b leading node G.
total attribute case, however, suces exist prefixes v0 w0 v w
property, long remaining suxes identical.
Soundness completeness algorithm stated following theorem.
Theorem 3 Let C , classic descriptions. Then, C v iff subsumes?(D; G ),
G canonical form G(C ).
soundness subsumption algorithm, i.e., direction theorem stated
above, pretty obvious. (Borgida & Patel-Schneider, 1994), main point
only-if direction (proof completeness) canonical graph G deterministic,
i.e., node, given role attribute name r, one outgoing r-edge
a-edge r label. point reader (Borgida & Patel-Schneider, 1994)
proof, since almost identical one total attributes already published there.
proofs reveal that, direction Theorem 3, description graphs need
normalized. Thus, one show:
n



n



C

C

C

183

steres, Borgida
Ku

Remark 1 Let G (not necessarily normalized description graph) let
concept description. Then, subsumes?(D; G) implies G v D.





classic

Borgida Patel-Schneider argue canonical description graph G concept
description C constructed time polynomial size C . Furthermore, Algorithm 1 runs time polynomial size G D. hard see
changes presented increase complexity. Thus, soundness completeness
subsumption algorithm provides us following corollary.
Corollary 1 Subsumption classic concept descriptions C D, attributes
interpreted partial functions, decided time polynomial size C
D.
4. Computing LCS

classic

section, show lcs two classic concept descriptions stated
terms product canonical description graphs. similar result proven
Cohen Hirsh (1994a) sublanguage classic , allows concept
names, concept conjunction, value restrictions, same-as equalities. particular,
sublanguage allow inconsistent concept descriptions (which, example,
expressed con icting number-restrictions). Furthermore, semantics description
graphs provided Cohen Hirsh restricts results case description graphs
acyclic. excludes, example, same-as equalities form # spouse spouse.
following, first define product description graphs. Then, show
given concept descriptions C D, lcs equivalent description graph obtained
product G G . constructions proofs quite close
(Cohen & Hirsh, 1994a).
C



4.1 Product Description Graphs

description graph represents constraints must satisfied individuals
extension graph. Intuitively, product two description graphs intersection
constraints|as product finite automata corresponds intersection
words accepted automata. However, definition product description
graphs special care taken incoherent nodes, i.e., nodes labeled ?. Also,
since attributes may occur r-edges a-edges, one needs take product
restriction graphs r-edges, one hand, original graphs G1 G2
(rooted certain nodes), hand.
Definition 8 Let G1 = (N1 ; E1 ; n1 ; l1 ) G2 = (N2 ; E2 ; n2 ; l2 ) two description graphs.
Then, product G := G1 G2 := (N; E; n0 ; l) two graphs recursively defined
follows:
1.
2.
3.

:= N1 N2 ;
n0 := (n1 ; n2 );
E :=f((n; n0 ); a; (m; m0 )) j (n; a; m) 2 E1 (n0 ; a; m0 ) 2 E2 g;
N

184

fiWhat's Attribute?

4. Let n 2 N1 n0 2 N2 . l1 (n) = ?, let l((n; n0 )) := l2 (n0 ) and, analogously,
l2 (n0 ) = ?, l((n; n0 )) := l1 (n). Otherwise, l1 (n) = (S1 ; H1 ) l2 (n0 ) =
(S2 ; H2), define l((n; n0)) := (S; H )
(a)
(b)



:= S1 \ S2;

:=
(
(
)
(
)
) j (r; p1 ; q1 ; G1 ) 2 H1 , (r; p2 ; q2 ; G2 ) 2 H2 g [
f(a; 0; 1; G1 G2 ) j (n; a; m) 2 E1 , (a; p2 ; q2 ; G2 ) 2 H2 g [
f(a; 0; 1; G1 G2 ) j (a; p1 ; q1 ; G1 ) 2 H1 , (n ; a; m) 2 E2 g.
H

0

0

0

f r; min p1 ; p2 ; max q1 ; q2 ; G1 G2
0

j

0

0

0

0

j

0

According definition, tuple (n; n0) node, say n, incoherent,
label (n; n0 ) coincides one n0. reason defining label
way lcs(?; C ) C every concept description C . overlooked
Frazier Pitt (1996), thus making constructions proofs hold concept
descriptions contain inconsistent subexpressions.
Note G, defined here, might connected, i.e., might contain nodes
cannot reached root n0. Even G1 G2 connected happen
tuples (n1; n2 ) belong set nodes G regardless whether
reachable root not. However, already mentioned Section 3.1 may
assume G connected.
note product graph translated back classic concept
description since product two description graphs description graph.
4.2 Computing LCS

prove main theorem subsection, states product two
description graphs equivalent lcs corresponding concept descriptions.
Theorem 4 Let C1 C2 two concept descriptions, let G1 G2 corresponding
canonical description graphs. Then, C 1 2 lcs(C1 ; C2 ).
G

G

Let G := G1 G2 . sketch proof showing C subsumes C1 and,
symmetry, C2 (see (Kusters & Borgida, 1999) details). construction,
two rooted paths common node G, G1 corresponding paths leading
node well. Thus, Theorem 3, same-as equalities C subsume ones
C1 . Now, let spanning tree G, (m1; m2 ) node G, v label
rooted path (m1 ; m2 ). Then, construction follows exists rooted
path G1 m1 labeled v. Furthermore, rather straightforward inductive proof shows
concept description E corresponding label (m1 ; m2 ) subsumes G1 j .
implies 8v:E w G1 . result, conclude G w G1 .
interesting part proof show C common subsumer
C1 C2, least common subsumer.
show induction size D, C1, C2 subsumes C1
C2 , subsumes C : distinguish different cases according definition
\subsumes?". Let G1 = (N1 ; E1 ; n1; l1 ) canonical description graph C1, G2 =
(N2 ; E2 ; n2; l2 ) canonical description graph C2 , G = (N; E; n0 ; l) = G1 G2 .
following, assume C1 v C2 v D; thus, subsumes?(D; G1)
Proof.

G

G

m1

G

G

185

steres, Borgida
Ku

?(D; G2). show subsumes?(D; G). Then, Remark 1 implies G v D,
thus, C v D. Note one cannot use Theorem 3 since G might canonical
description graph.
1. G incoherent, nothing show.
2. concept name, >, number-restriction, definition label
n0 easy see subsumes?(D; G).
3. v # w, exist nodes m1 G1 m2 G2 two
paths n1 m1 label v w, respectively, well two paths n2
m2 label v w. Then, definition G easy see two
paths n0 = (n1; n2 ) (m1 ; m2) label v w, respectively. shows
subsumes?(D; G).
4. 8r:C , r role attribute, one several cases applies:
(i) n1 n2 r-edges role attribute r, restriction graphs G01 G02 ,
respectively, subsumes?(C; G01 ) subsumes?(C; G02 );
(ii) without loss generality, n1 a-edge pointing m1 attribute r,
subsumes?(C; G01 ), G01 := G1 j ; n2 r-edge restriction
graph G02 subsumes?(C; G02 ).
cases (i) (ii), subsumes?(C; G01 G02 ) follows induction. Furthermore,
definition G r-edge role r restriction graph G01 G02 n0.
implies subsumes?(D; G).
(iii) n1 n2 a-edges attribute r leading nodes m1 m2 , respectively. Then, subsumes?(C; G1 j ) subsumes?(C; G2 j ). induction, know
subsumes?(C; G1 j
G2 j ). easy see Gj(
G2 j . Fur) = G1 j
thermore, definition a-edge attribute r (n1; n2 ) (m1 ; m2 )
G. shows subsumes?(D; G).
(iv) (without loss generality) n1 r-edge a-edge role attribute
r . implies subsumes?(C; G(>)), ensures subsumes?(D; G).
5. E u F , definition subsumption algorithm, subsumes?(E; G1 )
subsumes?(E; G2 ) hold. induction, subsumes?(E; G), analogously,
subsumes?(F; G). Thus, subsumes?(D; G).
ut
stated Section 3.5, canonical description graph classic concept description
computed time polynomial size concept description. hard
verify product two description graphs computed time polynomial
size graphs. addition, concept description corresponding description
graph computed time polynomial size graph. Thus, consequence
Theorem 4 obtain:
subsumes
G

m1

m1

m1

m2

m2

m1 ;m2

m1

m2

Corollary 2 lcs two classic concept descriptions always exists computed time polynomial size concept descriptions.
186

fiWhat's Attribute?

j , j 6=

j , j 6=













Figure 3: canonical description graph , without node labels.


intimated (Cohen et al., 1992), statement hold sequences concept
descriptions. Intuitively, generalizing lcs algorithm sequences of, say, n concept descriptions, means computing product n description graphs. following proposition
shows size product graph may grow exponentially n. Thus, lcs
computed way grows exponentially size given sequence. However,
imply exponential blow-up unavoidable. might exist smaller,
still equivalent representation lcs. Nevertheless, show exponential
growth inevitable.
Proposition 1 integers n 2 exists sequence D1 ; : : : ; classic
concept descriptions size every classic concept description equivalent
lcs(D1 ; : : : ; ) least exponential n size 0 linear n.
Proof. Cohen et al. (1992), given n, define concept descriptions
follows:
:= u (" # ) u u (a # ) u (" # )
6=
6=
n

n







j

j



j







j





a1 ; : : : ; denote attributes. canonical description graph depicted
Figure 3. Using Algorithm 1 easy see v v # w iff number 0 v
number 0 w equal modulo 2 v; w words fa1 ; : : : ; g.
implies
D1 ; : : : ; v v # w
iff 1 n number 0s v
(1)
0
number w equal modulo 2.
Let f1; : : : ; ng non-empty set. define v := k i1 < <
elements w := 3 3 k 3 3 := . let E lcs
D1 ; : : : ; , let G corresponding canonical description graph root n0.
(1) know E v v # w every f1; : : : ; ng. Algorithm 1 implies
paths n0 G labeled v w exist lead node q .
Assume non-empty subsets s; f1; : : : ; ng, 6= t, q = q . would
imply E v v # v contradiction (1). Thus, 6= implies q 6= q . Since
2 1 non-empty subsets f1; : : : ; ng, shows G contains least 2 1 nodes.
fact size G linear size E completes proof.
ut
proposition shows algorithms computing lcs sequences necessarily worstcase exponential. Conversely, based polynomial time algorithm binary lcs
operation, exponential time algorithm easily specified employing following
identity lcs(D1 ; : : : ; ) lcs(D ; lcs(D 1 ; lcs( lcs(D2 ; D1 ) ).
n









n

n





i1



i1



n

i2



j



j

j

k

j

E





E















n

E

E

n

n

n

187





n

steres, Borgida
Ku

Corollary 3 size lcs sequences classic concept descriptions grow
exponentially size sequences exists exponential time algorithm
computing lcs.
5. LCS Same-as Total Attributes

previous sections, attributes interpreted partial functions. section,
present significant changes computing lcs occur considering
total functions instead partial functions. precisely, look sublanguage
classic allows concept conjunction same-as equalities,
general assumption attributes interpreted total functions.
restrict attention language order concentrate changes
caused going partial total functions. strongly conjecture, however,
results represented easily transfered classic extending description
graphs Section 4.
First, show lcs two concept descriptions always exist.
Then, present polynomial decision algorithm existence lcs two
concept descriptions. Finally, shown lcs two concept descriptions
exists, might exponential size given concept descriptions
computed exponential time.
sequel, simply refer lcs lcs. Since throughout section
attributes always assumed total, lead confusion.
again, may useful keep mind total (though partial) attributes
(u # v) v (u w # v w) u; w; v 2 A, set finite words
A, finite set attribute names. Indeed, differences partial
total attributes shown section finally trace back property.










5.1 Existence LCS

subsection, prove lcs two concept descriptions always
exist. Nevertheless, always infinite representation lcs, used
next subsection characterize existence lcs.
accomplish above, return graph-based characterization t-subsumption
proposed Borgida Patel-Schneider (1994), modified partial attributes Section 3. concept description C , let G denote corresponding canonical description
graph, defined Section 3.4. semantics specified Section 3.1, although
set interpretations restricted allow attributes interpreted total functions
only.
Since contains concept names allow value-restrictions, nodes
G contain concept names set r-edges empty. Therefore, G
defined triple (N; E; n0 ) N finite set nodes, E finite set
N N , n0 root graph.
corollary results Borgida Patel-Schneider, subsumption C v
concept descriptions C decided following algorithm,
provides us characterization t-subsumption.
C

C

C



188

fiWhat's Attribute?

G

C0 :

D0 :

c

G




b

b




c

Figure 4: canonical graphs C0 D0
Algorithm 2 Let C , concept descriptions , G = (N; E; n0 ) canonical
description graph C . Then, subsumes ?(D; G ) defined true one
following conditions hold:
C



1.

C

v # w words v0 ; w0 ; u 2 v = v0 u w = w0 u,
rooted paths G labeled v0 w0 , respectively, ending node.



C

) subsumes ?(D2 ; G ) true.
Apart additional constructors handled Algorithm 1, Algorithm 2 differs
Algorithm 1 that, total attributes, considered here, sucient prefixes
rooted paths v w lead common node, long remainder cases
path.
2.



D1 u D2 subsumes ?(D1 ; G


C



C

Theorem 5 concept descriptions lcs concept descriptions exist .

result corrects statement Cohen et al. (1992) lcs always exists,
statement inadvertently assumed attributes partial, total.
proof, offer following -concept descriptions, shown
lcs:
C0 := # b;
D0 := # ac u b # bc u ad # bd:
graphs concepts depicted Figure 4.
following statement shows lcs E C0 D0 would satisfy condition
\regular structure". statement easily verified using
Algorithm 2.
E v v#w
iff v = w exists nonnegative integer n u 2
v = ac du w = bc du vice versa.
Given description lcs C0 D0 , one show, again, employing Algorithm 2, finite description graph equivalent E . However, omit
elementary proof here, absence lcs follows Theorem 6,
infinite graphs used characterize existence lcs. Note partial
attribute case, lcs C0 D0 equivalent # u b # b, result


n

189

n

steres, Borgida
Ku

obtained lcs algorithm presented previous section. corresponding (finite) description graph consists root two additional nodes, root two
outgoing edges leading two nodes labeled b, respectively.
state Theorem 6, first introduce infinite description graphs show
always exists infinite description graph representing lcs two -concept descriptions.
infinite description graph G defined, finite graph, triple (N; E; n0 )
except set nodes N set edges E may infinite. finite case,
nvn0 2 G means G contains path n n0 labeled word v 2 .
semantics infinite graphs defined finite case. Furthermore, infinite graphs
translated concept descriptions follows: take (infinite) spanning tree G, and,
finite case, every edge G contained it, add C same-as equality.
Note contrast partial attribute case, C need contain same-as equalities
form v # v since, total attributes, v # v >. Still, C might concept description
infinite number conjuncts (thus, infinite concept description). semantics
concept descriptions defined obvious way. Analogously Lemma 2, one
show (infinite) graph G corresponding (infinite) concept description C
equivalent, i.e., C G.
call (infinite) description graph G deterministic if, if, every node n
G every attribute 2 exists one a-successor n G. graph
G called complete every node n G every attribute 2 (at least)
one a-successor n G. Clearly, deterministic complete (infinite) description
graph, every path uniquely determined starting point label.
Algorithm 2 (which deals finite description graphs G ) generalized deterministic complete (infinite) description graphs G straightforward way. see
this, first note (finite) description graph coming -concept description
canonical iff deterministic sense introduced. Analogously, deterministic
infinite graph viewed canonical. Thus, requiring (infinite) graphs
deterministic satisfies precondition Algorithm 2. Now, addition graphs
complete, (unlike condition stated subsumption algorithm) longer
necessary consider prefixes words complete graph contains rooted path
every word. precisely, v0 w0 lead node, case
v = v 0 u w = w0 u well, thus making unnecessary consider prefixes v 0 w0
v w, respectively. Summing up, conclude:
Corollary 4 Let G = (N; E; n0 ) deterministic complete (infinite) description
G

G

G

G

G

C

graph

v; w

2 A. Then,
Gv v#w
iff


n0 vn

2 G n0wn 2 G node n:

shall construct (infinite) graph representing lcs two concept descriptions
product so-called completed canonical graphs. infinite representation
lcs used later characterize existence lcs , i.e., existence
finite representation lcs.
define completion graph. Intuitively, graph completed iteratively
adding outgoing a-edges labeled attribute every node graph
outgoing a-edge. process might extend graph infinite trees.
example, completion G (cf. Figure 4) depicted Figure 5 = fa; b; c; dg.
C0

190

fiWhat's Attribute?

G

1
C :
0







c

c

b

b







b

c





b

c



...
...
Figure 5: complete graph C0
Formally, completions defined follows: Let G (infinite) description graph.
graph G0 extension G every node n G every attribute 2
n outgoing edges labeled a, new node added, well edge
(n; a; ). Now, let G0 ; G1 ; G2 ; : : : sequence graphs G0 = G G +1
extension G ; 0. G = (N ; E ; n0),
[ [
G1 := (
N;
E ; n0 )
n;a



n;a









0



0
construction, G1






called completion G.
complete graph. Furthermore,
1
G deterministic, G deterministic well. Finally, easy see graph
extension Sare equivalent. Thus, induction, G1 G.
nodes 1 N , i.e., nodes G1 G, called tree nodes;
nodes G called non-tree nodes. construction, every tree node G1
exactly one direct predecessor G1, i.e., exactly one node n one attribute
(n; a; t) edge G1 ; n called a-predecessor t. Furthermore,
exactly one youngest ancestor n G tree node G1; n youngest ancestor
path n G1 contain non-tree nodes except n.
Note one path n G1. Finally, observe non-tree nodes
non-tree nodes ancestors.
Note completion canonical description graph always complete deterministic.
sequel, let C , two concept descriptions , G = (N ; E ; n ), G =
(N ; E ; n ) corresponding canonical graphs, G1 , G1 completions
G , G . products G := G G G
1 := G1 G1 specified Definition 1.
usual, may assume G G1 connected, i.e., contain nodes
reachable root (n ; n ); otherwise, one remove nodes cannot
reached root without changing semantics graphs.
denote product G1 G1 G1 instead G1 (or G1) otherwise
graph could confused completion G. general, graphs






C



C





C



C

C



C



C



191



C



C

C



steres, Borgida
Ku

coincide. example, take products G G G1 G1 (see Figure 4
graphs G G ). former product results graph consists root
two outgoing a-edges, one labeled one labeled b. (As mentioned before,
graph corresponds lcs C0 D0 partial attribute case.) product
completed graphs, hand, graph obtained completion
graph depicted Figure 6 (the infinite trees omitted sake simplicity).
easy consequence fact G G1 Corollary 4, one prove
following lemma.
C0

Lemma 6

C0

D0

C

C

C0

D0

D0

C

v v # w iff n


C

vn

2 G1 n
C

C

wn

2 G1 node n G1 .
C

C

then, construction G1 know:
Proposition 2 C v
node n G1 .



v

# w v v # w iff (n


C

) 2 G1 (n

; nD vn

C

)

; nD wn

2 G1

particular, G1 represents lcs concept descriptions C following
sense:
Corollary 5 (infinite) concept description C 1 corresponding G1 lcs C
D, i.e., i) C; v C 1 ii) C; v E 0 implies C 1 v E 0 every -concept
description E 0 .
G





G



G

5.2 Characterizing Existence LCS

Let C , concept descriptions let graphs G , G , G, G1 , G1, G1
defined above.
show G1 represents (possibly infinite) lcs -concept
descriptions C (Corollary 5), G1 used characterize existence
finite lcs. existence depends whether G1 contains finite infinite number
so-called same-as nodes.
Definition 9 node n (infinite) description graph H called same-as node
C

exist two direct predecessors
may labeled differently.)



n



H.



(The a-edges leading

c

c

c








b







c

c

c

Figure 6: subgraph G1 G1
C0

192

D0

C

n



nodes

fiWhat's Attribute?

example, graph depicted Figure 6 contains infinite number same-as nodes.
show sucient necessary condition lcs C0 D0
exist.
helpful observe same-as nodes G1 one forms (g; f ), (f; t),
(t; f ), g f non-tree nodes tree node. cannot exist
same-as node form (t1; t2 ), t1 t2 tree nodes, since tree nodes
exactly one direct predecessor, thus (t1; t2 ) does. Moreover, G1
infinite number same-as nodes, must infinite number same-as nodes
form (f; t) (t; f ), exist finite number nodes G1 form
(g; f ). reason, following lemma characterize same-as nodes
form (f; t). (Nodes form (t; f ) dealt analogously.) state lemma,
recall n0un1vn2 2 H , graph H , describe path H labeled uv
n0 n2 passes node n1 u (i.e., n0un1 2 H n1vn2 2 H );
generalized obvious way interpret n0u1n1u2n2u3n3 2 H .
G

1

(nC ; nD )
v

w

(h1 ; p0 )

x

(h2 ; p0 )

G

..
.

6=
6
1=

v
h

w
h2

..
.x

(e1 ; q0 )

(e2 ; q0 )


e1

6=

e2


n

= (f; t)

Figure 7: same-as nodes G1
Lemma 7 Given node f G tree-node G1 , node n = (f; t) G1
same-as node iff
C






exist nodes (h1 ; p0 ), (h2 ; p0 ) G, h1 6= h2 ;
exist nodes (e1 ; q0 ), (e2 ; q0 ) G1 , e1 , e2 distinct nodes G
q0 node G1 ;
exists attribute 2 v; w; x 2 , v 6= w, set attributes
C ,
C







(n

C

) (

) (

) ( ) (n

) ( ) ( )
direct successors (h01 ; p00 ) (h02 ; p00 ) (h1 ; p0 )

; nD v h1 ; p0 x e1 ; q0 f;

C

) (

; nD w h2 ; p0 x e2 ; q0 f;

paths G1 (see Figure 7).
(h2 ; p0 ) paths, we, addition, require p00 tree node G1 .4


4. Note since G
1 deterministic, successors (h1 ; p0 ) (h2 ; p0 ) two paths must fact
form (; p00 ).

193

steres, Borgida
Ku

direction obvious. proceed only-if direction assume
same-as node G1. Let p0 (uniquely determined) youngest ancestor
G1 . particular, p0 node G exists p0 xq0 G1 2
x 2 successor p0 path tree node G .
Since n same-as node reached via q0 attribute a,
must exist e1 , e2 G , e1 6= e2 , (e1 ; q0 )a(f; t); (e2 ; q0)a(f; t) 2 G1. Since G1
connected, paths (n ; n ) (e1 ; q0) (e2 ; q0). Every path n q0
must pass p0 sux label path x. Consequently, exist
nodes h1 ; h2 G (h1 ; p0 )x(e1 ; q0 )a(f; t) (h2 ; p0)x(e2 ; q0)a(f; t) paths
G1. particular, xa label path h1 f G , label xa
consists attributes contained C . h1 = h2, this, together fact G
deterministic, would imply e1 = e2 . Hence, h1 6= h2 . Let v, w labels paths
(n ; n ) (h1 ; p0 ) (h2 ; p0), respectively. G deterministic h1 6= h2,
follows v 6= w.
ut
main results section stated next theorem. direct consequence
theorem, obtain exists lcs concept descriptions C0
D0 example.
Proof.
n









C

C





C

C

C

C



Theorem 6 lcs C exists iff number same-as nodes G1 finite.

start proving only-if direction. purpose, assume G1
contains infinite number same-as nodes show (finite) lcs C
.
argued before, may assume G1 contains infinite number same-as nodes
form (f; t) (t; f ), tree node f non-tree node. precisely,
say G1 contains every 1 nodes n = (f ; ) f node G
tree node G1. According Lemma 7, every same-as node n exist nodes
h1 ; h2 ; e1 ; e2 G , p0 G , q0 G1 well 2 x 2
properties required Lemma 7.
Since G G finite description graphs, number tuples form
h1 ; h2 ; e1 ; e2 ; f ; finite. Thus, must infinite number i's yielding
tuple h1; h2 ; e1 ; e2 ; f; a. particular, h1 6= h2 e1 6= e2 nodes G
infinite number same-as nodes form n = (f; t1 ). Finally,
lemma, let v, w label paths (in G) (n ; n ) (h1 ; p0 ) (h2 ; p0 ).
Now, assume lcs E C . According Corollary 5, E C 1 .
Let G finite canonical graph E root n0. Proposition 2 Lemma 7
know E v vx # wx a. Algorithm 2 follows words v0, w0 , u
vx = v0 u wx = w0 u, paths G starting n0 labeled v0 ,
w0 lead node G .
u 6= ", u = u0a word u0. Then, Algorithm 2 ensures E v vx # wx .
However, Lemma 7 know words vx wx lead different nodes
G
1 , namely, (e1 ; q0 ) (e2 ; q0 ), which, Proposition 2, leads contradiction
E G
1 6v vx # wx . Thus, u = ".
result, every 1 exists node q G n0vx aq n0wx aq
paths G . G finite description graph, exist i; j 1, 6= j ,
Proof.









C



;i

;i

;i

;i

C

C

;i

;i





;i



;i









;i

;i





C



C

;i





G

E











E

E





;i







;i





E





E

194

E









fiWhat's Attribute?

= q . Algorithm 2, implies E v vx # wx a. hand, path
starting (n ; n ) label vx leads node n one wx leads
n . Since n 6= n , Proposition 2 implies E 6v vx # wx a, contradiction.
sum up, shown exist lcs C .
shows lcs C , completes proof only-if
direction.
prove direction Theorem 6. purpose, assume G1
finite number same-as nodes. Note every same-as node G1
finite number direct predecessors. see this, two cases distinguished: i) node
form (g1 ; g2 ) G predecessors G; ii) tree node g non-tree node,
predecessor (g; t) G1 form (g0 ; t0) t0 unique predecessor
(tree non-tree node) g0 non-tree node. Since number nodes G
G finite, cases finite number predecessors. then,
spanning tree G1 coincides G1 except finite number edges because,
contain certain edge, edge leads same-as node. result, C 1
-concept description finite conjunction same-as equalities. Finally,
Corollary 5 shows C 1 lcs C D.
ut
v # w conjunct C 1 , v w lead root G1 same-as node.
mentioned before, same-as nodes form (f; g); (f; t), (t; f ), tree
node f; g non-tree nodes. Consequently, v w must paths G G .
Thus, contain attributes occurring C D.
qi

G
1

j



C

j







j





j





j

j

C



G

G

G

C



Corollary 6 lcs two concept description C exists,
concept description containing attributes occurring C equivalent
lcs.

Therefore, asking existence lcs, w.o.l.g. assume set
attributes finite. fact used following two subsections.
5.3 Deciding Existence LCS

following corollary derive desired decision algorithm existence
lcs two concept descriptions . state corollary need introduce
language L C (q1 ; q2) := fw 2 j path node q1 q2 G labeled wg.
Since description graphs viewed finite automata, language regular.
Moreover, let aA denote set faw j w 2 Ag attribute 2 A, finite
alphabet.
G

C

Corollary 7 G1 contains infinite number same-as nodes iff either
(i) exist nodes (h1 ; p0 ), (h2 ; p0 ) G well nodes f , e1 , e2 G , attributes
a; b 2
C

1.

h1

6= h2 , e1 6= e2 ;

2.

p0

b-successor G ;

3.

(e1 ; a; f ), (e2 ; a; f ) edges G



C

;
195

steres, Borgida
Ku

4.

(

LGC h1 ; e1

) \ L C (h2 ; e2 ) \ bA infinite set words;
G


(ii) statement (i) r^oles C



switched.

first prove only-if direction. Assume G1 contains infinite number
same-as nodes. Then, w.l.o.g., find configuration G1 described proof
Theorem 6. configuration satisfies conditions 1. 3. stated corollary.
If, 6= j , words x x coincide, conclude n = n G1
deterministic graph. However, definition, n 6= n . Hence, x 6= x . finite,
can, w.l.o.g., assume x 's b 2 first letter fixed b. Thus,
condition 4. satisfied well. According configuration, b-successor (; p0 )
G
1 form (; p00 ) p00 tree node. Thus, p0 b-successor
G , means condition 3. satisfied.
prove direction corollary. purpose, let bx 2 L C (h1 ; e1 ) \
L C (h2 ; e2 ) \ bA . Since p0 b-successor G follows tree nodes
t; t0 G1 p0 bxtat0 2 G1 . Thus, (h1 ; p0 )bx(e1 ; t)a(f; t0 ) 2 G
1
0

(h2 ; p0 )bx(e2 ; t)a(f; ) 2 G1. Since e1 6= e2, conclude (e1 ; t) 6= (e2 ; t). means
(f; t0) same-as node. Analogously, 2 L C (h1 ; e1 ) \ L C (h2 ; e2 ) \ bA
tree nodes s; s0 G1 p0bysas0 2 G1 (f; s0) same-as node G1.
Since bx start b, b-successor p0 G1 tree node, x 6=
implies s0 6= t0. Hence, (f; t0) (f; s0) distinct same-as nodes. shows
set L C (h1 ; e1 ) \ L C (h2 ; e2 ) \ bA infinite, G1 must infinite number same-as
nodes.
ut
given nodes (h1 ; p0), (h2 ; p0 ) G, attributes a; b 2 A, nodes f; e1; e2 2 G conditions 1. 3. Corollary 7 obviously checked time polynomial size
concept descriptions C D. last condition, note automaton accepting
language L C (h1 ; e1 ) \ L C (h2 ; e2 ) \ bA constructed time polynomial
size C . Furthermore, given finite automaton decidable time polynomial
size automaton accepts infinite language (see book Hopcroft
Ullman (1979) details). Thus, condition 4. tested time polynomial size
C well. Finally, since size G G polynomial size C D,
polynomial number configurations need tested. Together Corollary 7
complexities provide us following corollary.
Proof.



j





j

j



j





G

G







G



G





G

G

C

G

G

C

Corollary 8 given concept descriptions C decidable time polynomial
size C whether lcs C exists .
5.4 Computing LCS

subsection, first show size lcs two -concept descriptions may
grow exponentially size concept descriptions. stronger result
presented partial attributes, shown lcs sequence
concept descriptions grow exponentially. Then, present exponential time lcs
algorithm -concept descriptions.
196

fiWhat's Attribute?

GC 0

:

GDk

:



c

c





b







c

c

b








k

Figure 8: canonical description graphs C 0

k

order show lcs may exponential size, consider following
example, := fa; b; c; dg.We define
0 := # b;
C

:= u=1 ac # ad u u=1 bc # bd u ac # bc a:
corresponding canonical description graphs G 0 G k depicted Figure 8.
finite graph representing lcs C 0 depicted Figure 9 k = 2.
graph easily derived G10 G1k . graph comprises two binary trees
height k, thus, contains least 2 nodes. following, show
canonical description graph G k (with root n0) representing lcs E C 0
less 2 nodes. Let x 2 fc; dg word length k fc; dg, let
v := axa, w := bxa. Using canonical description graphs G 0 G k easy see
C 0 v v # w v v # w. Thus, E v v # w. Algorithm 2, means
words v0; w0 ; u v = v0 u, w = w0 u, paths n0 labeled
v 0 w0 G k leading node G k . Suppose u 6= ". Then, Algorithm 2
implies E v ax # bx. according G , 6v ax # bx. Therefore u must empty
k

k



k









k

k





C

k



C

k

E

k

k

k

k



C





k



k

E

k

E







c



b





c

2
c





c













c







c



Figure 9: finite graph representing lcs C 0 D2
197

steres, Borgida
Ku

word ". proves G k path n0 labeled axa every x 2 fc; dg .
Hence, path every ax. Now, let 2 fc; dg x 6= y. paths
ax ay n0 G k lead node, implies E v ax # ay
contradiction C 0 6v ax # ay. result, ax ay lead different nodes G k . Since
fc; dg contains 2 words, shows G k least 2 nodes. Finally, taking
account size canonical description graph concept description linear
size corresponding description obtain following theorem.
k

E

k

E

k





k

E

k

k

E

Theorem 7 lcs two -concept descriptions may grow exponentially size
concepts.

following (exponential time) algorithm computes lcs two -concept descriptions
case exists.
Algorithm 3
Input: concept descriptions C , , lcs exists ;
Output: lcs C ;
1. Compute G0 := G

G

C



;

2. every combination

nodes (h1 ; p0 ), (h2 ; p0) G = G G , h1 6= h2 ;
2 A, e1 ; e2 ; f G , e1 6= e2 , (e1 ; a; f ) (e2 ; a; f ) edges G
C



C

extend G0 follows: Let G


C

h1 ;t

,G

h2 ;t

two trees representing (finite) set words

0
L := @L C (h1 ; e1 ) \ L C (h2 ; e2 ) \
G

[

G

b

62succ(

p0

)

1 (
f"g; 62 succ(p0)
bA [

;

;

otherwise

succ(p0 ) := fb j p0 b-successorg set nodes G 1 , G 2 ,
G0 assumed disjoint. Now, replace root G 1 (h1 ; p0 ), root
G 2 (h2 ; p0 ), extend G0 nodes edges two trees. Finally,
add new node n every word v L, node trees G 1
G 2 reachable root G 1 G 2 path labeled v , add edge
label n . extension illustrated Figure 10.
h ;t

h ;t

h ;t

h ;t

v

h ;t

h ;t

h ;t

h ;t

v

3. step 2, r^oles C switched.
4. Compute canonical graph G0 , called G0 again. Then, output concept
description C 0 G0 .
G

Proposition 3 translation
C D.

CG0

graph G0 computed Algorithm 3 lcs E
198

fiWhat's Attribute?

0

G

(h1 ; p0 )

(h2 ; p0 )

b



b



b

n


c




c



bc

n








bad

n

Figure 10: extension nodes (h1 ; p0), (h2 ; p0 ) G0 L = fb; bc; badg
easy see two paths G0 labeled y1 y2 leading
root (n ; n ) node, G1 contains paths well. Consequently,
(E )G1 v G0.
Now, assume E v y1 # y2, y1 6= y2. Proposition 2 know paths
G1 labeled y1 y2 leading node n. W.l.o.g, may assume n
same-as node G1. Otherwise, exist words y10; y2 0; u y1 = y10u, y2 = y20u
y10 y20 lead same-as node. show G0 contains paths labeled y10
y20 leading node, then, Algorithm 2, sucient G0 v y1 # y2.
let n same-as node. distinguish two cases:
1. n node G = G G , paths y1 y2 paths G. Since G
subgraph G0 holds G0 well. Hence, C 0 v y1 # y2.
2. Assume n node G. Then, since n same-as node, know n
form (f; t) (t; f ) f non-tree node tree node. symmetry,
may assume n = (f; t). easy see exist nodes h1 ; h2 ; e1 ; e2
G , p0 G , tree node q0 G1 well 2 x; v; w 2 specified
Lemma 7 y1 = vxa y2 = wxa. then, h1 ; h2 ; e1 ; e2 ; p0; f
preconditions Algorithm 3 satisfied x 2 L. Therefore, construction
G0 paths labeled y1 y2, respectively, leading root
node.
ut
note product G G G computed time polynomial
size C D. Furthermore, polynomial number combinations nodes
(h1 ; p0 ), (h2 ; p0) G, e1 ; e2 ; f G , 2 A. Finally, finite automaton L
computed time polynomial size C D. particular, set states
automaton polynomially bounded size C D. L contained word
longer number states, accepting path automaton contains cycle.
then, automaton would accept infinitely many words, contradiction assumption
L finite. Thus, length words L bounded polynomially
size C D. particular, means L contains exponential number
words. Trees representing words computed time exponential size
C .
Proof.

C











C



G

C





C



C

199



steres, Borgida
Ku

Corollary 9 lcs two -concept descriptions exists, computed time
exponential size concept descriptions.
6. Conclusion

Attributes | binary relations one value { distinguished
many knowledge representation schemes object-centered modeling languages.
done facilitate modeling and, description logics, help identify tractable
sets concept constructors (e.g., restricting same-as attributes). fact, same-as restrictions quite important practical point view, support modeling
actions components (Borgida & Devanbu, 1999).
second distinction, attributes total versus partial functions,
considered essential now. paper shown distinction sometime
significant effects.
particular, first shown approach computing subsumption
Classic concepts total attributes, presented Borgida Patel-Schneider (1994),
modified accommodate partial attributes, treating partial attributes roles
participate same-as restrictions, case \converted" total attributes. result, obtain polynomial-time algorithms subsumption
consistency checking case also.
case computing least common subsumers, introduced technique
learning non-propositional descriptions concepts, first noted several
papers literature (Cohen & Hirsh, 1994a; Frazier & Pitt, 1996) (implicitly) used
partial attributes, considering Classic. Furthermore, papers used weaker
version \concept graphs" employed (Borgida & Patel-Schneider, 1994),
make results hold case same-as restrictions generate \cycles".
Furthermore, algorithm proposed Frazier Pitt (1996) handle inconsistent
concepts, easily arise Classic concepts result con icts lower
upper bounds roles.
Therefore, provided lcs algorithm together formal proof correctness
sublanguage Classic partial attributes, allows same-as equalities
inconsistent concepts | algorithm proofs easily extended full Classic
(Kusters & Borgida, 1999). case, lcs always exists, computed
time polynomial size two initial concept descriptions. shown Cohen et al.
(1992), sequences concept descriptions lcs may grow exponentially
size sequence.
complete picture, main part paper, examined
question computing lcs case total attributes. Surprisingly, situation
different partial attribute case (unlike subsumption). First,
language lcs may even exist. (The existence lcs mentioned Cohen et al.
(1992) due inadvertent switch partial semantics attributes.) Nevertheless,
existence lcs two concept descriptions decided polynomial time.
lcs exists, may grow exponentially size concept descriptions, hence
computation lcs may take time exponential size two given concept
descriptions.
200

fiWhat's Attribute?

aside, note pointed Cohen et al. (1992) concept
descriptions correspond finitely generated right congruence. Furthermore,
context lcs two concept descriptions intersection right congruences. Thus,
results presented paper show intersection finitely generated
right congruences always finitely generated right congruence,
polynomial algorithm deciding question. Finally, intersection finitely
generated, generating system may exponential computed
exponential time algorithm size generating systems given right
congruences.
results paper therefore lay scope effect making attributes
total partial functions description logic supports same-as constructor.
Moreover, correct problems extend results previous literature.
believe disparity results two cases serve
warning researchers knowledge representation reasoning, concerning
importance explicitly considering difference total partial attributes.
Acknowledgments

authors wish thank anonymous reviewers helpful comments.
research supported part NSF Grant IRI-9619979. carried
first author Rutgers University RWTH Aachen.
References

Artale, A., Franconi, E., Guarino, N., & Pazzi, L. (1996). Part-Whole Relations ObjectCentered Systems: Overview. Data & Knowledge Engineering, 20 (3), 347{383.
Baader, F. (1996). Formal Definition Expressive Power Terminological Knowledge Representation Languages. Journal Logic Computation, 6 (1), 33{54.
Baader, F., & Kusters, R. (1998). Computing Least Common Subsumer
Specific Concept Presence Cyclic ALN -Concept Descriptions. Herzog,
O., & Gunter, A. (Eds.), Proceedings 22nd Annual German Conference
Artificial Intelligence, KI-98, Vol. 1504 Lecture Notes Computer Science, pp.
129{140 Bremen, Germany. Springer{Verlag.
Baader, F., Kusters, R., & Molitor, R. (1999). Computing Least Common Subsumers
Description Logics Existential Restrictions. Dean, T. (Ed.), Proceedings
16th International Joint Conference Artificial Intelligence (IJCAI'99), pp. 96{101
Stockholm, Sweden. Morgan Kaufmann Publishers.
Baader, F., & Sattler, U. (2000). Tableaux Algorithms Description Logics. Proceedings International Conference Automated Reasoning Analytic Tableaux
Related Methods (TABLEAUX 2000), Vol. 1847 Lecture Notes Artifical Intelligence, pp. 1{18 University St. Andrews, Scotland.
201

steres, Borgida
Ku

Borgida, A. (1994). Relationship Description Logic Predicate Logic.
Proceedings Third International Conference Information Knowledge
Management (CIKM'94), pp. 219{225 Gaithersburg, Maryland. ACM Press.
Borgida, A. (1995). Description logics data management. IEEE Trans. Knowledge
Data Engineering, 7 (5), 671{682.
Borgida, A., & Devanbu, P. (1999). Adding "DL" IDL: towards knowledgeable
component inter-operability. Proceedings 1999 International Conference
Software Engineering, pp. 378{387 Los Angeles, CA USA. ACM.
Borgida, A., & Etherington, D. (1989). Hierarchical Knowledge Bases Ecient Disjunctive Reasoning. Brachman, R., & H.J. Levesque, R. R. (Eds.), Proceedings
1st International Conference Principles Knowledge Representation
Reasoning (KR'89), pp. 33{43 Toronto, Canada. Morgan Kaufmann Publishers.
Borgida, A., & Kusters, R. (2000). What's name: Properties Purely
Structural Approach Integrating Large DL Knowledge Bases. Baader, F., &
Sattler, U. (Eds.), Proceedings 2000 International Workshop Description
Logics (DL2000), No. 33 CEUR-WS Aachen, Germany. RWTH Aachen.
Borgida, A., & Patel-Schneider, P. (1994). Semantics Complete Algorithm Subsumption CLASSIC Description Logic. Journal Artificial Intelligence Research, 1, 277{308.
Brachman, R., McGuinness, D., Patel-Schneider, P., & Borgida, A. (1999). \Reducing"
CLASSIC Practice: Knowledge Representation Theory Meets Reality. Artificial
Intelligence, 114 (1{2), 203{237.
Calvanese, D., Giacomo, G. D., & Lenzerini, M. (1998). Knowledge Representation Semi-Structured Data?. Proceedings 16th National Conference
American Association Artificial Intelligence, AAAI-98, pp. 205{210. AAAI
Press/The MIT Press.
Calvanese, D., Giacomo, G. D., & Lenzerini, M. (1999a). Modeling Querying SemiStructured Data. Network Information Systems, 2 (2), 253{273.
Calvanese, D., Giacomo, G. D., & Lenzerini, M. (1999b). Reasoning Expressive Description Logics Fixpoints based Automata Infinite Trees. Dean, T. (Ed.),
Proceedings 16th International Joint Conference Artificial Intelligence (IJCAI'99), pp. 84{89 Stockholm, Sweden. Morgan Kaufmann Publishers.
Calvanese, D., Giacomo, G. D., Lenzerini, M., Nardi, D., & Rosati, R. (1998). Description
Logic Framework Information Integration. Cohn, A., Schubert, L., & Shapiro, S.
(Eds.), Proceedings 6th International Conference Principles Knowledge
Representation Reasoning (KR-98), pp. 2{13 Trento, Italy. Morgan Kaufmann
Publishers.
Calvanese, D., Lenzerini, M., & Nardi, D. (1999). Unifying Class-Based Representation
Formalisms. Journal Artificial Intelligence Research, 11, 199{240.
202

fiWhat's Attribute?

Cohen, W. W., & Hirsh, H. (1994a). Learnability description logics equality constraints. Machine Learning, 17 (2/3), 169{199.
Cohen, W. W., & Hirsh, H. (1994b). Learning CLASSIC Description Logic: Theoretical Experimental Results. Doyle, J., Sandewall, E., & Torasso, P. (Eds.),
Proceedings Fourth International Conference Principles Knowledge Representation Reasoning (KR'94), pp. 121{133 Bonn, Germany. Morgan Kaufmann
Publishers.
Cohen, W., Borgida, A., & Hirsh, H. (1992). Computing Least Common Subsumers Description Logics. Swartout, W. (Ed.), Proceedings 10th National Conference
Artificial Intelligence, pp. 754{760 San Jose, CA. MIT Press.
Devanbu, P., & Jones, M. (1997). Use Description Logics KBSE Systems. ACM
Transactions Software Engineering Methodology (TOSEM), 6 (2), 141{172.
Frazier, M., & Pitt, L. (1996). Classic learning. Machine Learning Journal, 25, 151{193.
Giacomo, G. D., & Lenzerini, M. (1996). TBox ABox reasoning expressive description logics. Aiello, L., Doyle, J., & Shapiro, S. (Eds.), Proceedings 5th
International Conference Principles Knowledge Representation Reasoning
(KR'96), pp. 316{327 Boston, USA. Morgan Kaufmann Publishers.
Hopcroft, J., & Ullman, J. (1979). Introduction Automata Theory. Addison-Wesley Publ.
Co.
Kusters, R., & Borgida, A. (1999). What's Attribute? Consequences Least
Common Subsumer. Tech. rep. DCS-TR-404, Rutgers University, USA. Available via
ftp://ftp.cs.rutgers.edu/pub/technical-reports/.
McGuinness, D., & Patel-Schneider, P. (1998). Usability Issues Knowledge Representation Systems. Proceedings 15th National Conference Artificial Intelligence
(AAAI-98) 10th Conference Innovative Applications Artificial Intelligence (IAAI-98), pp. 608{614 Menlo Park. AAAI Press.
McGuinness, D., & Wright, J. (1998). industrial strength Description Logic-based
configurator platform. IEEE Intelligent Systems, 13 (4), 66{77.
Minsky, M. (1975). framework representing knowledge. Winston, P. (Ed.),
Psychology Computer Vision McGraw-Hill, New York.
Quillian, M. (1968). Semantic memory. Minsky, M. (Ed.), Semantic Information Processing, pp. 216{270 Cambridge, Mass. MIT Press.
Schmidt-Schau, M. (1989). Subsumption KL-ONE undecidable. Brachman, R. J.
(Ed.), Proceedings 1st International Conference Principles Knowledge
Representation Reasoning (KR'89), pp. 421{431 Toronto, Ont. Morgan Kaufmann
Publishers.
203


