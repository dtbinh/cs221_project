Journal Artificial Intelligence Research 14 (2001) 1-28

Submitted 2/00; published 1/01

Reachability, Relevance, Resolution Planning
Satisfiability Approach
Ronen I. Brafman

brafman@cs.bgu.ac.il

Department Computer Science, Ben-Gurion University
P.O.Box 653, Beer-Sheva 84105, Israel

Abstract

recent years, growing awareness importance reachability
relevance-based pruning techniques planning, little work specifically targets
techniques. paper, compare ability two classes algorithms propagate
discover reachability relevance constraints classical planning problems. first
class algorithms operates SAT encoded planning problems obtained using linear
Graphplan encoding schemes. applies unit-propagation general resolution steps (involving larger clauses) plan encodings. second class operates
plan level contains two families pruning algorithms: Reachable-k Relevantk . Reachable-k provides coherent description number existing forward pruning
techniques used numerous algorithms, Relevant-k captures different grades backward pruning. results shed light ability different plan-encoding schemes
propagate information forward backward relative merit plan-level
SAT-level pruning methods.
1. Introduction

success planning satisfiability (PAS) approach (Kautz & Selman, 1992, 1996)
led various attempts refine initial methods used improve understanding performance. particular, various methods generating formulas
planning instances compared (Ernst, Millstein, & Weld, 1997), various systematic alternatives original stochastic method examined (e.g., Bayardo
& Schrag, 1997; Li & Anbulagan, 1997). Still, many issues surrounding approach
poorly understood. particular, little known uence encoding method
performance.
Concentrating two encoding methods proposed Kautz Selman (1996),
linear Graphplan-based encodings, examine uence ability
propagate reachability relevance information via unit propagation and, generally,
k -clause resolution. comparing pruning ability techniques
class algorithms reachability relevance analysis operate original
problem formulation: Reachable-k Relevant-k. Reachable-k simplified variant
similar algorithm state pruning Markov decision processes (Boutilier, Brafman, &
Geib, 1998), Relevant-k natural counterpart used relevance analysis.
algorithms provide coherent framework discussing different grades reachability
relevance-based pruning methods appear literature.
work motivated growing role forward backward pruning methods
play current planning algorithms important role propagation techniques

c 2001 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBrafman

SAT solvers used planning satisfiability approach. Unit propagation plays
central role Davis-Putnam algorithm (Davis & Putman, 1960) many
offsprings (e.g., Crawford & Auton, 1993; Freeman, 1995; Gomes, Selman, & Kautz, 1998;
Li & Anbulagan, 1997) used preprocessing step stochastic methods
applied. Moreover, limited form binary propagation used Crawford's Compact
program simplifying CNF formulas utilized Blackbox planner (Kautz
& Selman, 1999). results shed light relationship pruning
techniques.
paper organized follows. Section 2 provides background material, describing
basic ideas PAS framework Graphplan algorithm. Section 3,
discuss Reachable-k , algorithm performing reachability analysis, compare
ability prune possible actions k-clause resolution. Section 4 describe
Relevant-k similar Reachable-k applied relevance analysis. Again,
compare methods based resolution. Section 5 empirically compare results
various methods k = 1; 2. conclude discussion future related work
Section 6. Proofs appear appendix, main arguments described
body paper.
2. Background

Graphplan algorithm (Blum & Furst, 1997) Satplan algorithm (Kautz
& Selman, 1996) profoundly altered direction research within planning
community. Two main concepts studied paper, reachability analysis plan
encodings, become central current planning research thanks planners.
brie discuss planners, particular, aspects pertaining topic.

2.1 Reachability Analysis Graphplan
purpose reachability analysis discover unreachable states world
infeasible actions, i.e., actions cannot performed course successful plan.
discovering actions ahead time, reduce space needs searched
find valid plan. principle, full edged reachability analysis requires forward search
space possible states. expensive operation, instead, opt
sound, incomplete methods. methods discover actions
ruled out. However, action rule infeasible need considered
searching plan.
Graphplan planner provides good example utility approximate reachability analysis. Graphplan two main stages: first stage, approximate reachability analysis conducted, yielding data-structure called planning graph
represents sound, incomplete, approximation set states reachable
initial state. second stage, Graphplan searches plan structure.
Graphplan's planning graph construction algorithm presents particularly good tradeoff
computational complexity pruning power, utility pruning search
space attested planner's good performance.
planning graph construction algorithm viewed generating list annotated sets. odd elements list contain sets propositions. even elements
2

fiReachability, Relevance, Resolution

list contain sets actions. set annotated mutual exclusion constraints members. Intuitively, action set contains list actions could
performed step concurrent action plan (i.e., plan allowing concurrent
execution actions interfere other). proposition set contains
propositions could hold 1 (sets concurrent) actions performed.
mutual exclusion constraints circumscribe sets indicating certain pairs
actions propositions cannot occur time particular stage. Hence,
propositions p; q appear proposition set, possible (or accurately
{ algorithm rule possibility) i-step plan applied initial
state could lead world p and/or q hold. However, p q marked
mutually exclusive know p q cannot hold together i-step plan
performed.
sets constructed follows: first proposition set contains propositions
hold initial state. first action set contains actions performed
initial state. general, set propositions contains effects actions
i-1 action set, action set contains actions whose preconditions appear
i-1 set propositions, provided preconditions marked mutually
exclusive. Mutual exclusion constraints added follows: Two actions marked
mutually exclusive action set preconditions marked mutually exclusive
i-1 . Clearly, preconditions actions cannot hold time
point, cannot perform actions together time point. Another reason
marking actions mutually exclusive con ict. is, one action destroys
precondition effect action. Two propositions proposition set
marked mutually exclusive pairs actions i-1 action set
effects mutually exclusive. case, way us achieve
propositions together stage.
initial construction planning graph terminated goal propositions
appear last proposition set. point, Graphplan performs form regressionbased search planning-graph structure. search fails, planning graph
extended one additional layer actions one additional layer propositions
searched again. details, see article Blum Furst (1997).
th

th

th

th

th

th

th

th

th

th

th

th

2.2 Planning Satisfiability Approach
Planning Satisfiability approach (PAS short), works follows: given planning
problem bound n size plan, plan encoder generates propositional
formula conjunctive normal form. formula following property: satisfiable
iff planning problem solution n time steps. Intuitively, formula
composed propositions describing state world throughout execution
n-step plan.
propositional language top formula defined contains proposition
possible aspect world time point. example, suppose looking
blocks' world domain states described using clear relations.
case, pair blocks x; y, time point 0 n shall introduce
proposition pon( ) corresponds x top time t. Similarly,
x;y;t

3

fiBrafman

every block x time point 0 n, shall introduce proposition pclear( )
corresponds x clear time t.
truth assignment language described viewed describing state
world execution n-step plan. instance, pon( 3) assigned
true , block top block B time 3. course, truth assignments
language would correspond anything resembling true state world
execution actual plan. example, on(A,B) on(B,A) could
assigned true . goal encoding scheme generate formula
assignment satisfying formula correspond true state world
execution actual plan achieves desired goal. axiom formula
places constraint value propositions combined effect
constraints ensure resulting formula precisely desired truth
assignments. example, one type axiom conjunction propositions
corresponding initial state. truth assignment satisfying axiom must ensure
propositions hold time 0. Another class axioms could state
action performed time world time 1 must satisfy preconditions
a. next sections discuss two central plan encodings detail.
appropriate formula generated, simplified using various well
known techniques. particular, simplifiers employ unit-resolution step (Genesereth
& Nilsson, 1987). Unit resolution (also known unit propagation ) works follows:
satisfy CNF formula, must satisfy clauses. particular, one
clauses contains single literal (such clause known unit clause ) immediately
know variable appearing clause must assigned appropriate value.
clause containing literal satisfied now, removed
formula. clause c containing negation literal resolved
unit clause, resulting clause (which smaller c) replace c. example,
suppose formula (p) ^ (:q _:p) ^ (r _ p). first disjunct, (p) unit clause.
Hence, p must assigned true . makes third clause, (r _ p), satisfied. second
clause resolved first clause, replace (:q _ :p) (:q).
new unit clause, (:q), proposition q must assigned value false .
additional clauses containing q :q, could remove them, simplify them,
appropriate.
simplification, apply favorite algorithm finding satisfying assignments,
one attained, decoder used obtain actual plan solution.
find satisfying assignment, increase value n (the size plan),
try again.
Finally, note Blackbox planner (Kautz & Selman, 1999) combines PAS
Graphplan's reachability analysis. constructs planning graph, uses
generate particular plan encoding.
x;t

A;B;

3. Reachability Resolution

Reachability relevance analysis form essential part successful modern planning
algorithms. notable example reachability analysis Graphplan's planning
graph (Blum & Furst, 1997), many recent planners employ either reachability analysis
4

fiReachability, Relevance, Resolution

(e.g., Bonet, Loerincs, & Geffner, 1997), relevance analysis (e.g., McDermoot, 1996; Nebel,
Dimopoulos, & Koehler, 1997), (Kambhampati, Parker, & Lambrecht, 1997).
importance reachability relevance analysis noted context decisiontheoretic planning well. example, Boutilier Dearden (1994) employ relevance
analysis reduce state-space, Boutilier, Brafman, Geib (1998) describe
general method reachability analysis MDPs. Below, discuss method
simplified form suitable classical planning problems described using Strips representation language (Fikes & Nilsson, 1971). Section 4, present counterpart
method performing relevance analysis relate algorithms k-clause resolution
context SAT-encoded planning problems.

3.1 Propagating Reachability Information
Reachable-k (Boutilier, Brafman, & Geib, 1998) algorithm estimating states
reachable given initial state. formulated, quite general applies domains non-deterministic actions conditional effects. Figure 1, present
simplified version algorithm, Reachable-k , deals deterministic, unconditional actions represented Strips representation language. prolog implementation
Reachable-k available www.cs.bgu.ac.il/~pdm.
important reason interest Reachable-k similarity uential planning graph construction Graphplan planner (Blum & Furst, 1997).
fact, generalizes ideas behind Graphplan's planning graph, equivalent
Reachable-2. use denote set actions feasible steps initial state,

denote corresponding set propositions, C denote constraints
propositions, fp1 ; : : : ; p g 2 C propositions cannot co-occur

steps. C denotes similar constraints actions. Here, 2 fL; P g, L used
restrict attention linear action sequences, P used allow concurrent
non-con icting actions (i.e., actions destroy others' effects preconditions
whose preconditions constrained co-occur). course, k = 1 sets


C C empty 0. (Actually, defined, C
empty even
k = 1, plays real part algorithm, ignored). Finally, note
description, set possible actions contains actions form noop[l],
l literal.
k = 2, represent propositional action levels Graphplan's
planning graph, C C hold respective mutual exclusion constraints.
stated termination condition Reachable-k, one formulated
based content index itself. PAS framework, number
time-steps fixed, one would opt second alternative. Reachable-k gives us sets
actions propositions, ; , could occur performance j actions (or
j sets concurrently non-con icting actions) initial state. easy see
Reachable-k sound following sense:














L








P






j

j

Theorem 1 set propositions actions excluded Reachable-k time j

feasible plan which, time j , propositions hold or, respectively,
actions appear.
5

fiBrafman

= literals hold initial state.



S0



C S0

= fg.

= actions whose preconditions S0 .
C AL
0 = ffai ; aj gjai ; aj 2 A0 ; 6= j; neither ai aj noops aj noop whose effect
destroyed ai g.
C AP = ffai ; aj gjai ; aj 2 A0 ; 6= j; ai deletes precondition effect aj g.


A0

0

define Si ; Ai inductively follows:
= literals appear effects Ai 1 .
C Si = l-tuples literals, l k , appearing Si subset set
actions Ai 1 literals appearing among effects, appears C Ai 1
(where 2 fL; P g appropriate).




= actions whose preconditions appear Si subset preconditions appears
C Si .
C AL
= ffal ; aj gjal ; aj 2 Ai ; l 6= j; neither al aj noops, aj noop whose effect
destroyed al g.
C APi = ffaj1 ; : : : ; ajl gjl k; aj1 ; : : : ; ajl 2 Ai ; jm 6= jn 6= n; either (1) ajm
deletes precondition effect ajn 6= n (2) subset union
preconditions aj1 ; : : : ; ajl appears C Si g.




Figure 1: Reachable-k Algorithm
Sometimes, actions executed particular time point p holds
:p effect. case, ignore noop[p] action, part
useful plan.1 However, formulated, p appear Reachable-k 's next level.
denote Reachable -k variant noop[p] appear case.
computational complexity Reachable-k O(njAjjLj E + njLjjAj ), n
number levels generate, jAj number possible actions, jLj size
propositional language used, E maximal number actions particular
shared effect. detailed explanation appears Appendix B.
Example: illustrate parallel action version Reachable-k, use following
planning domain: four propositions, p1 ; p2 ; p3 ; p4 . Intuitively, think
representing binary counter 4 bits. 4 actions,
increases counter one different states. domain single non-noop
action applicable state. a1 changes least-significant bit, a2 changes next
bit, a3 changes third bit, a4 changes significant bit. applicable
first 1 bits one. specifically actions are:
k

k

k



1. planning algorithms, e.g., PAS approach, may necessary leave noops in.

6

fiReachability, Relevance, Resolution

a1

Precondition:

:

a2

Precondition:

p1

a3

Precondition:

p

p

a4

Precondition:

p

p

p1

; effect:

p1

.

^ : 2; effect: : 1 ^ 2.
1 ^ 2 ^ : 3 ; effect: : 1 ^ : 2 ^ 3 .
1 ^ 2 ^ 3 ^ : 4 ; effect: : 1 ^ : 2 ^ : 3 ^
p

p

p

p

p

p

p

p

p

p
p

p

p4

.

compare Reachable-1 Reachable-2 using initial state: :p1 ^:p2 ^:p3 ^:p4 ,
corresponds binary representation 0. concentrate (more interesting)
parallel action version algorithm, shall mention noops explicitly obvious
mutual exclusion constraints propositions negations.
context Reachable-1, C C empty, practical purpose.
start S0 = f:p1 ; :p2 ; :p3 ; :p4 g; action affecting first bit applicable,
A0 = fa1 g (and relevant noops); S1 = fp1 ; :p1 ; :p2 ; :p3 ; :p4 g.
preconditions a1 a2 appear S1 , A1 = fa1 ; a2 g. Consequently
S2 = fp1 ; :p1 ; p2 ; :p2 ; :p3 ; :p4 g. Now, apply a3 , A2 = fa1 ; a2 ; a3 g;
S3 = fp1 ; :p1 ; p2 ; :p2 ; p3 ; :p3 ; :p4 g. Finally, stage preconditions a4 appear
well, A3 = fa1 ; a2 ; a3 ; a4 g.
Next, consider Reachable-2. Again, S0 = f:p1 ; :p2 ; :p3 ; :p4 g, C S0 empty, A0 =
fa1 g. next step have: S1 = fp1; :p1 ; :p2; :p3; :p4g, interesting constraints
C S1 , A1 = fa1 ; a2 g. However, C contains (a1 ; a2 ), interfering
actions. S2 = fp1 ; :p1 ; p2 ; :p2 ; p3 ; :p3 ; :p4 g, case k = 1. However, C S2 contains
(p1 ; p2 ). follows fact actions A1 capable producing p1
a1 noop[p1 ], action A1 capable producing p2 a2 . a2 interferes
a1 noop[p1]. Therefore, C S2 contains (p1 ; p2 ), a3 applicable
stage. Hence, A2 = fa1 ; a2 g, one action less set A2 Reachable1. S3 = S2 = fp1 ; :p1 ; p2 ; :p2 ; p3 ; :p3 ; :p4 g. However, C S3 contain (p1 ; p2 )
(because noop[p2] used achieve p2 , con ict with, e.g., noop[p1]).
Therefore, A3 = fa1 ; a2 ; a3 g.
see k = 3 improves ability prune k = 2, suppose S0 =
fp1 ; p2; :p3; :p4 g (i.e., counter's value 0011) consider k = 2 first.
A0 = a3 S1 = f:p1; p1; :p2 ; p2 ; :p3 ; p3 ; :p4 g, (p1 ; p3 ); (p1 ; :p2 ); (:p1 ; p2 )
(p2 ; p3 ) C S1 . mutual exclusion relations stems fact a3
mutually exclusive noop[p1] noop[p2 ]. Therefore, A1 = fa1 ; a3 g.
S2 = S1 = f:p1; p1; :p2 ; p2 ; :p3 ; p3 ; :p4 g, C S2 contains (p1 ; p2 ) only,
A2 = fa1 ; a2 ; a3 g. Now, C S3 empty, A3 = fa1 ; a2 ; a3 ; a4 g. However, k = 3,
C S1 contains ternary constraint (p1 ; p2 ; p3 ). ternary constraint remains C S2
well, C S3 . C S3 k = 3, a4 62 A3 .






3.2 k-Clause Resolution Reachability
-clause resolution (or propagation) refers resolution pairs clauses one whose
length k most. k = 1 variant, i.e., unit propagation, integral part
major algorithms generating satisfying assignments.
wish compare type reachability information derived performing k-clause
resolution SAT-encoded planning problems, information obtained running
k

7

fiBrafman

Reachable-k algorithm. reachability information mean constraints set
actions possible time point constraints world states (in form of, e.g., sets
unreachable propositions k-tuples propositions). Hence, example, constraint
form a(t) _ a0 (t) implies one actions a0 must appear time
plan. constraint form :a(t) _:a0(t) implies one actions a0 must
appear plan. Similar constraints propositions holding time point
derived. principle, constraints reduce search space could help us attain
solution quickly. However, effectiveness deduced constraints depends
precise algorithm used. Moreover, comparison large class constraints
seems quite dicult. Therefore, article concentrate concrete class
reachability information form :a(t), i.e., action cannot performed
state reachable via steps. powerful constraint utilized effectively
almost planners (perhaps exception partial-order planners). Consequently,
shall say algorithm Alg1 generates reachability information another
algorithm Alg2 whenever Alg2 able determine action cannot performed
time t, Alg1 able reach conclusion well, addition,
conclusions Alg1 reach Alg2 cannot reach. Hence, Alg1 generates
strict superset constraints actions (of type interested in) generated
algorithm. Note mean Alg1 better Alg2
every instance, always good, cases better. section
shall compare pruning ability two Reachable-k variants two encoding
methods discussed Kautz Selman (1996):2 linear encoding Graphplan
encoding.
3.2.1 Linear Plan Encoding

linear plan encoding (Kautz & Selman, 1992) simple natural method
translating planning problem formula satisfiable iff valid plan
length n (for given n). clauses linear plan encoding fall following
classes:
1. action implies preconditions prior execution;
2. action implies effects following execution;
3. action affect proposition (frame axioms);
4. least one action time point;
5. one action time point.
explicit frame axioms, noops needed linear encoding (as
opposed Graphplan encoding). addition, formula contains unary clauses
describing initial goal states. However, purpose analyzing reachability
effects, exclude description goal state (which plays role relevance analysis).
Consider mechanism resolution yield reachability information: Given
propositions hold initial state, derive negation actions whose
2. third (state-based) encoding method cannot generated automatically.

8

fiReachability, Relevance, Resolution

preconditions hold using unit propagation axioms class 1. Propagating
unit clauses appropriate instance axiom class 4, obtain disjunction
actions executed first time point. far, identical
Reachable -k provides. propagate information forward, resolve
action disjunctions axioms class 2 3. This, however, requires binary resolution
(discussed below). Hence, except unlikely case single action possible,
derive using unit propagation alone. Reachable -1,
hand, provide us list possible effects actions possibly
prune future actions whose preconditions appear list. conclude:
Lemma 1 context linear encoding, Reachable -1 yields reachability in-

formation unit propagation.

Example: Consider blocks' world domain single action schema move(object,source,

destination).3 preconditions are: on(object,source), clear(object), clear(destination)
effects are: on(object,destination), clear(source), :on(object,source), : clear
(destination) (except destination table always clear). k
stacks blocks initially, k2 actions performed initial state (i.e., moving block
top stack top another stack table). discovered
algorithms. particular, unit propagation yield disjunction actions.
know blocks 2 blocks top cannot participate
second move action. Reachable-1 find due fact
clear. Suppose one block. initially feasible move actions participate
frame axiom form move(o,s,d)^:clear(A; 0) ! :clear(A; 1), which, clausal
form :move(o,s,d)_clear(A; 0) _ :clear(A; 1). Resolving :clear(A; 0),
:move(o,s,d)_:clear(A; 1). could deduce :clear(A; 1), could rule
actions precondition. restricted unit propagation,
requires deducing move(o,s,d) initially feasible action, cannot make
deduction.
propagated information forward using axioms class 2 3 used binary
resolution (as discussed Lemma 1), set disjunctions possible
effects (including frame effects) initially allowable actions. number
disjuncts O(e ), e maximal number effects action
number actions executed initially. cases, disjunctions could
contain single literal, e.g., initially allowable actions leave proposition
unchanged. one disjunctions contains literals negations
action's precondition, deduce negation action resolving
axioms class 1.
Example: example considered would generate disjunction form
move(o1 ; s1 ; d1 ) _ move(o2 ; s2 ; d2 ) _ move(o3 ; s3 ; d3 ), containing instances move
action time 0 whose negations deduced. discussed above,
actions, obtain clause form :move(o ; ; )_:clear(A; 1). resolve
binary clauses clause above, obtain unary clause :clear(A; 1),








3. fact, since use plain Strips, need three action schemas: one moving block block, one
moving block table, one moving block table. However,
affect analysis, stick single move action following examples.

9

fiBrafman

used conjunction class 1 axioms deduce negations step 2 actions
whose preconditions include clear(A; 1).
saw, effect disjunctions discussed allow us rule certain propositions combinations propositions. analogous mutual exclusion constraints.
mutual exclusion constraints used prune actions. example, deduce :p1 _ _ :p p preconditions action a, deduce :a
using binary resolution (by resolving precondition axioms disjunction). However,
show below, binary resolution trouble propagating even binary mutual exclusion
constraints forward. believe generally true, i.e., k-clause resolution
trouble propagating k-ary constraints. show following:




Lemma 2 Reachable-2 binary resolution (in case linear encoding) incomparable.

prove providing two examples. One Reachable-2 able prune
action binary resolution cannot, one converse hold.
First, consider 4-bit counter initial value 0000 (i.e., :p1; :p2 ; :p3 ; :p4 ). four steps obtain following: S4 = f:p1 ; p1 ; :p2 ; p2 ; :p3 ; p3 ; :p4 g C S4 =
f(p1 ; p3 ); (p2 ; p3)g. Therefore, A4 = fa1 ; a2 ; a3 g. implies S5 = S4 . claim
(p2 ; p3 ) 2 C S5 well, means a4 62 A5 . see this, consider pairs
actions p2 p3 effects. are: (a2 ; a3 ); (a2 ; noop[p3]); (noop[p2 ]; a3 ),
(noop[p2]; noop[p3 ]). (a2 ; a3 ) pair real actions, always mutually exclusive
linear encoding. preconditions (a2 ; noop[p3]) mutually exclusive according
C S4 , preconditions (noop[p2]; noop[p3]). Finally, (noop[p2]; a3 )
interfering actions. conclude (p2 ; p3 ) 2 C S5 a4 62 A5 .
run binary resolution procedure linear encoding problem,
could deduce a4 62 A5 . stems fact ternary resolution needed
propagate mutual exclusion p2 p3 . Recall obtain mutual exclusion
constraints resolving disjunction actions ruled out.
case, time 4 would following disjunction: a41 _ a42 _ a43 _ noop[:p1] _
_ noop[6= p4]. goal deduce :p52 _ :p53 using :p42 _ :p43 various axioms.
this, try deduce either :p52 _:p53 actions disjunction.
easy deduce :p52 a43 :p52 a42 . However, believe impossible
deduce :p52 _ :p53 a41 noops.4 reason
deduction involves use frame axioms, ternary. know that, e.g., :p42
holds, apply unit resolution frame axioms obtain binary clause. However,
know :p42 _ :p43. resolve frame axiom remain
ternary clause. get desired result must resolve two ternary clauses.
Finally, let us see example use binary resolution derive ternary
constraint. definition, Reachable-2 cannot derive constraints. Suppose
initial state :p; :q; :r. four actions: a1 p; r effects, a2 q; r effects,

a3 p; q effects, a4 p; q; r preconditions. Using Reachable -2 deduce
a1; a2; a3 possible time 0. get possible effects p; q; r; :p; :q; :r (recall
4. fact deduction impossible verified. hypothesizing reason
it.

10

fiReachability, Relevance, Resolution

must include noop actions Reachable-k order capture frame effects).
strict subset p; q; r appear set constraints C S1 . Since deal binary
constraints only, set fp; q; rg appear C S1 . Therefore, consider a4
possible time 1, although, fact, impossible. Using binary resolution, would
obtained constraint :p _ :q _ :r (referring time 1) would enabled
us deduce a4 impossible time 1.
3.2.2 Graphplan Encoding

Graphplan encoding differs linear encoding ability consider multiple
concurrent (non-interfering) actions, allowing one obtain shorter plans which, turn,
reduce search space size. constructs following sets clauses:
1. action implies preconditions;
2. effect implies one actions effect;
3. least one action time-point;
4. Two con icting actions cannot occur together.
Besides obvious ability consider multiple parallel (non-interfering) actions, important difference Graphplan Linear encoding axiom class 2 (referred
(Ernst et al., 1997) explanatory frame axioms.) Clauses class contain
positive occurrences action literals negative occurrences state literals.
linear case, using unit propagation infer actions cannot
applied initial state. Using axioms class 2, propagate information forward, deducing negation effects cannot produced initially allowable
actions. information enables us exclude actions whose preconditions cannot produced. forward propagation essentially identical Reachable-1. informally
conclude:

Lemma 3 context

encoding, unit propagation Reachable-1
yield reachability information, ignore explicit constraints appearing
axiom class 4. use constraints, unit propagation yield reachability
information.
Graphplan

precise carefully define notion reachability constraints context
Graphplan encoding. example, Graphplan encoding derive
constraint says one group actions must appear plan. constraint
necessarily rule action Graphplan encoding permits multiple
actions time point.5 However, linear encoding constraint
immediately rule actions single action allowed time
point. mentioned earlier, paper concentrate strict exclusion constraints
5. However, actions interfere cannot occur concurrently, know action
occur deduce action interferes occur. precisely
class 4 axioms enter picture.
0

11

fiBrafman

lead immediate reduction search space ruling need certain
actions certain time points.
k > 1, mechanism remains same. now, axioms class 4 play
prominent role use exclude actions cases
before. However, problem propagating mutual exclusion constraints forward
linear encoding reappear here. Consequently, k-clause resolution
context Graphplan encoding Reachable-k incomparable.
4. Relevance Resolution

Relevance analysis complex task performed various degrees.
instance, considering last action level, one exclude actions produce
literal goal. However, actions producing goal literal irrelevant.
example, consider blocks' world planning problem color blocks
specified part goal. observed Nebel, Dimopoulos, Koehler (1997),
paint-block action still, intuitively, irrelevant initial final colors blocks
same. However, goal literal effect.
section, formulate algorithm relevance analysis, called Relevant-k .
Relevant-k perform deeper relevance analysis needed determine
paint-block action irrelevant example. Rather, Relevant-k similar
motivation form Reachable-k , similar soundness property. Relevant-k
prunes search space excluding states goal reachable within
given number steps actions useful achieving goal state within
given number steps.
Relevant-1 similar number existing components existing planners,
McDermott's greedy regression graph (McDermoot, 1996) Nebel, Dimopoulos,
Koehler's And-Or trees (Nebel et al., 1997). Relevant-k generalizes ideas arbitrary
levels interactions, taking consideration mutual-exclusion constraints relevant
states must satisfy. Relevant-k slightly complicated Reachable-k
Strips formalism allows incomplete description goal states, propagating partial information raises diculties. Naturally, goal state partially specified,
fewer constraints available start with, fewer constraints derived.
algorithm described Figure 2. aware similar, general formulation
ideas. Therefore, worthwhile going central points algorithm,
concentrating interesting complex case parallel actions allowed. However, this, point important assumption shall make
action representation used: proposition symbol shall appear preconditions effects action. restriction dicult enforce,
Strips-based domain representation transformed description
assumptions satisfied. example, p precondition action appear
effect a, simply add effect, know must hold
action executed. p appears effect neither p :p appear
preconditions a, decompose two versions action, one p
precondition one :p precondition. Note worst case,
transformation cause exponential blow-up number actions.
12

fiReachability, Relevance, Resolution

r contains actions useful safe w.r.t. goal.
A0 contains Ar0 noops safe w.r.t. goal.


A0

contains pairs interfering actions A0 .
define Ri ; Si ; Ari ; Ai inductively follows:
Ri union preconditions actions Ari 1 .


C A0





union preconditions actions Ai 1 .

contains sets literals Si , jS j k set actions Ai 1
whose preconditions contain case 2 C Ai 1 .
Ari contains actions useful w.r.t. Ri subset effects contained
C Si .
Ai contains Ari noops useful w.r.t. Si .
C Ai contains action sets Ai either (1) contains two interfering
actions, (2) subset set effects C Si .



CS

Action descriptions must contain set propositional symbols precondition
effect lists.

Figure 2: Relevant-k Algorithm
k = 1 algorithm quite simple (and identical parallel linear cases).
case, ignore sets ; C ; C (as degenerate) consider
sets R only. Starting goal literals, stage set
literals construct next set actions. action set contains actions
effect current literal set. However, goal effects action
part preconditions, ignore action irrelevant. Next, new literal set
constructed, containing set preconditions current set actions, repeat
process new set.
k > 1, picture becomes bit complicated. start set
relevant actions, . actions achieve one desired literals.
particular, A0 contains actions one goal literals effect (but
precondition). goal partially specified, literals part could hold
previous time step. Hence, include appropriate noop actions larger set,
, contains noops destroy needed propositions. subset
actions mutually exclusive contains interfering actions actions whose
effects mutually exclusive. Given set 1 , generate set R , includes
preconditions 1 . set defined set preconditions actions .
goal completely specified state, sets R sets
identical, need distinguish them.








r




r


r

r






r


r












13



r


fiBrafman

facilitate description Relevant-k algorithm, would useful add
simple definitions. First, wish revise definition interfering actions
context Relevant-k algorithm. say actions a; a0 interfere
effect con icts precondition effect a0 (and beyond
previous definition term) preconditions inconsistent. action useful
w.r.t. (with respect to) literal l noop action preserving l l effect,
precondition, a. useful w.r.t. set literals useful w.r.t. one
set's elements. set actions safe w.r.t. set literals action
effect negates element .
Relevant-k embodies intuitions described above. Note increased index corresponds points earlier time. definition sets ; R ; ; quite intuitive:
contains preconditions actions previous , R contains preconditions actions . contains actions useful, mutually exclusive,
effects. defined much , w.r.t. rather R . set C contains
literals mutually exclusive particular point. set L literals mutually
exclusive set relevant actions L among preconditions mutually
exclusive. set C contains mutually exclusive sets actions. set actions
mutually exclusive contains interfering actions set effects mutually
exclusive.
Example: order illustrate Relevant-k algorithm, shall use counter
example used Section 3.1, starting three bit counter using propositions,
p1 ; p2 ; p3 . actions a1 ; a2 ; a3 change value single bit 0 1,
provided values lower bits 1.
start final state f:p1 ; :p2 ; p3 g k = 1. Since final state fully
specified, distinction sets R . A0
contains action a3 three relevant noops. S1 contains fp1 ; :p1 ; p2 ; :p2 ; p3 ; :p3 g,
A1 contains a1 ; a2 ; a3 , appropriate noops, remaining sets look
same.
k = 2, A0 S1 k = 1 case. However, C S1 contains (:p1 ; p2 )
(p1 ; :p2 ), implies a2 cannot applied. Hence, A1 contains a1 a3 ,
a2 , unlike case k = 1. action a2 would introduced next step.
Next, consider partially specified goal, fp3 ; p2 g k = 2. A0 =
fa2 ; noop[p2]; noop[p3]g a2 p2 effect, a2 destroy p3; whereas
a1 , example, effect goal. A0 would contain A0 well
noops p1 :p1 . R1 = fp1 ; p2 ; :p2 ; p3 g S1 = fp1 ; :p1 ; p2 ; :p2 ; p3 g. Next, A1
contains fa1 ; a2 g, etc.
Finally, suppose four bits, goal state f:p1 ; :p2 ; p3 ; p4 g (i.e.,
counter's bit value 1100). k = 2, A0 contains a3 S1 = fp1 ; :p1 ; p2 ; :p2 ; p3 ; :p3 ; p4 g.
However, C S1 contains pairs (:p1 ; :p3 ); (:p2 ; :p3 ) others. A1 contains a1 ; a3
noops. S2 = S1 , now, C S2 contain (:p1 ; :p3 ), contain
(:p2 ; :p3 ), though, precludes action a4 A2 . next step,
S3 = S2 = S1 , C S3 longer contains (:p2 ; :p3 ). implies
add a4 A3 effects longer mutually exclusive. overall,
A0 = fa3 g; A1 = fa1 ; a3 g; A2 = fa1 ; a2 ; a3 g, A3 = fa1 ; a2 ; a3 ; a4 g. However, k = 3,










r


r




r


r
















r




r

r

r

14

fiReachability, Relevance, Resolution

would still mutual exclusion constraint (:p1 ; :p2 ; :p3 ), would
allow us add a4 . Hence, k = 3, A3 = fa1 ; a2 ; a3 g.
prove following soundness results:
C S3

Theorem 2 Let

state goal reachable using m-step plan
(where step contain number non-interfering actions). (1) set
literals satisfied subset , subset C , (2) exists
m-step plan reaching goal set actions plan
v steps last subset C .






v

v

corollary theorem is:

Corollary 1 initial state goal reachable minimal (in
number operators) plan P = A0 ; : : : A00 (where steps numbered backwards)
reaching goal s, A0 C contain subset A0 .










complexity Relevant-k O(jAj jLj + jLj
jAj), jAj number
actions, jLj number proposition language, maximal number
preconditions action. details, see Appendix B.
compare amount relevance information propagated backwards
using k-clause resolution goal literals opposed Relevant-k . Consider unit
propagation first. context linear encoding, see actions destroy
goal condition ruled out. However, actions irrelevant
produce irrelevant effects pruned.6 hand, Relevant-1 prunes
actions destroy goal literal actions simply irrelevant.
slightly degenerate case actions one destroy goal proposition.
case, using unit propagation able deduce previous state. Consequently,
have:
k

k

k
mp

p

Lemma 4 context linear encoding, unless single safe, final action,

unit propagation yields less relevance information Relevant-1.

context Graphplan encoding situation often worse, unit propagation prunes even less linear encoding. goal propositions appear
class 2 (effect) axioms. Propagating axioms, obtain disjunctions
positive action propositions explaining particular goal proposition. assume
literals one explanation, see new unit clauses emerge. Consequently, prune nothing.
Example: Consider blocks' world domain again. Suppose three
blocks A,B, C, goal on(A,B). Clearly, action moves block C
moves another block top block C irrelevant last action. consider
Graphplan encoding, unit clause on(A,B,t) (where last
time point). resolve effect axiom lists possible causes
on(A,B,t). Aside noop action, actions moving C B
6. general, proving action ruled means shown models, i.e.,
plans, action appear. cannot expect able irrelevant action
since could possibly inserted plan without affecting it.

15

fiBrafman

moving Table B. yields new ternary clause additional unit
clauses. axioms on(A,B,t) appears negated.
Notice means excluding actions destroy one goal literals.
example, goal clear(A,t), would want action move(B,C,A,t-1)
last action. However, above, deduce clear(A,t) is: move(B,A,C,t1)_move(B,A,Table,t-1)_ move(C,A,B,t-1)_move(C,A,Table,t-1)_ noop[clear(A; 1)].
could use binary resolution stage, could deduce negation action
effect :clear(A,t), action would mutually exclusive
five actions.
goal literal l single explanation must noop action (which implies
\real" operator effect). case, would able deduce
noop action must hold, using precondition axioms, would deduce
l must hold previous step. Using mutex axioms (class 4) could deduce
negation action destroys l. However, cannot deduce negation
action interact l, whether simply irrelevant destroys
goal literal.
Example: Consider domain Rocket domain, rocket fuel,
action fueling rocket. Suppose rocket fuel goal
state. Hence, fuel(t) holds. Since explanation axiom fuel binary clause (i.e.,
:fuel(t) _ noop[fuel(t 1)]. Resolving axiom fact fuel(t), derive new
unit clause noop[fuel(t 1)]. Using precondition axioms, derive fuel(t-1).
Using mutex axiom, derive action fly(t-1), one whose effects
:fuel(t 1). Notice, though, cannot deduce negation action
interact proposition fuel, whether irrelevant. example, fuel
proposition goal, action loading rocket,
affect value proposition fuel need considered final action
plan. However, before, way deducing :load(t 1).
action produce fuel reasoning would apply step,
able deduce fact fuel holds time point plan.
Using fact, able prune actions :fuel precondition.
Relevant-1 able so: :fuel precondition effect
relevant point, considered relevant action.7

Lemma 5 context

encoding, action changing value every literal, unit propagation yields less relevance information
Relevant-1.
Graphplan

actual values appears Section 5. particular, examples looked at,
Graphplan encoding could prune action. follows (quite typical)
fact domains, facts hold final state achieved
number actions. Hence, unit propagation deduce disjunctions possible
7. course, particular domain action whose precondition :fuel,
observation still valid. example, may maintenance action performed
rocket without fuel.

16

fiReachability, Relevance, Resolution

actions, none unit clause. Since way deducing negated actions,
propagation stops point.
general case similar. linear encoding, obtained disjunction
allowable actions, generate disjunction allowable preconditions. information
propagated backwards much forward case. Yet, k = 1 case,
expect form backwards reachability analysis goal state, rather true
relevance analysis. Again, Relevant-k likely much better job here,
takes explicit relevance issues account. However, case reachability analysis,
ability k-clause resolution yield constraints order greater k,
cannot show Relevant-k always better.
context Graphplan encoding, generate disjunctions relevant
actions, disjunctions relevant preconditions deduced, etc. However,
irrelevant actions excluded explicitly (since one action allowed
step) conclude relevant action must appear.
exclude actions destroy goal proposition. Again, deduce constraints
order greater k via k-clause resolution, cannot provide general result here.
Finally, note (1) Graphplan planner incorporate relevance analysis, Mea-Graphplan, recent variant, (Kambhampati et al., 1997),
well IPP (Nebel et al., 1997). (2) Ernst, Millstein, Weld (1997) discuss enhanced
version Graphplan encoding contains effects axioms well (i.e., axioms
form action ! effect). terms ability propagate reachability relevance
information, see added ability rule actions destroy needed propositions
(as linear encoding.)
5. Empirical Evaluation

previous sections attempted understand mechanisms resolution
yields reachability relevance information compare natural class
direct reachability relevance algorithms. noted, relationship always
subsumption, interest examine actual pruning abilities
algorithms. section describe performance algorithms number
standard planning problems. limited number domains used, caution
exercised interpreting results. However, interesting results emerge.
first set experiments examined performance unary methods large blocks
world logistics domain problems. used blocks' world problems bw-dir.a/b/c/d
Satplan distribution8 involving 9/11/15/19 blocks, respectively, (minimal)
plans length 6/9/14/18. logistics' domain problems based instances described
(Brafman & Hoos, 1999) involving 8 packages 3 cities, minimal plans size
6/10/16, respectively. SAT-encodings generated using Medic program (Ernst
et al., 1997). used crse options obtain linear encoding erpe options
obtain Graphplan-like encodings. However, encoding obtained via erpe options contain explicit effect axioms, linear encoding. axiom improve
Graphplan-encoding's ability propagate relevance information.
8. instances part UCPOP distribution, maintained University Washington,
http://www.research.att.com/ kautz/blackbox/index.html, BlackBox home page.

17

fiBrafman

log.a
log.b
log.c
bw.a
bw.b
bw.c
bw.d

j j


4565
5941
8021
3888
10890
44100
116964

Reach Rel R+R U-rch(l) U-rel(l)
2922 617 3476
401
38
3517 680 3905
442
20
5051 2782 6214
600
32
1697 408 2105
639
300
3565 830 4395
1201
440
12818 2394 15212
3141
840
26963 5238 32201
6482
5114

Table 1: Pruning Effects Unary Methods. jAj number possible actions
course minimal length plan. following entries hold number
actions pruned using: Reachable-1, Relevant-1, combined, unit propagation
linear encoding using initial state, using final state. Unit propagation
Graphplan encoding using final state yielded pruning. Execution
times Reach/Relevant algorithms 0:01 seconds except bw.c (0.03
sec.), bw.d (0.07 sec.).
set experiments measured number potential actions eliminated
following algorithms: Reachable-1, Relevant-1, Reachable-1 Relevant-1 combined,
reachability analysis via unit-resolution using initial state, relevance analysis via
unit-resolution using goal state. consider Graphplan encoding
following reasons:
(1) Unit-propagation Graphplan encoding yields much information Reachable1. (2) particular experiments (and cases), unit-resolution based
final state Graphplan encoding prunes little, any, actions
fact appearing goal state number potential producing actions. (3)
version Graphplan-encoding produced Medic basically equivalent
linear-encoding terms relevance information contains explicit effect axioms.
actual numbers appear Table 1. first column provides size set
actions minimal plan length. following columns provide number actions
pruned various methods tested. evident Reachable-1 extremely effective.
Relevance analysis seems much less useful, although Relevant-1 prune non-negligible
number actions. results unit-resolution quite disappointing, although line
theoretical analysis. Recalling unit-resolution Graphplan encoding
equivalent Reachable-1, see much greater potential pruning
Graphplan encoding. Another interesting observation little overlap
reachability relevance analysis. stems fact pruning
effect algorithms often quite shallow: pruning done
first steps (in reachability) last steps (in relevance). Finally, note
k = 1 algorithms quite fast: Unit propagation important heuristic SAT
solution algorithms based David-Putnam algorithm (Davis & Putman, 1960),
extremely fast, negligible running times (i.e., < 0:01 seconds). surprisingly,
18

fiReachability, Relevance, Resolution

bw-sm.a
bw-sm.b
bw-sm.c
log-sm.a
log-sm.b
log-sm.c
hanoi-3
hanoi-4
hanoi-5

j j


18
48
100
18
42
66
38
68
110

Rch1 Rch2 Rel1/2 rch1(l) rch2(l) rch1(gp) rch2(gp) rel1/2(l/g)
21
22
8
15
22
21
22
4
68
70
44
44
74
68
70
6
199
204
184
96
210
199
204
12
39
57
8
14
49
39
44
1
111
165
18
36
141
111
126
3
196
292
26
58
244
196
220
5
94
97
21
36
117
94
118
9
224
230
34
66
281
224
280
14
450
460
50
108
558
450
551
20

Table 2: Effects Unary Binary Methods. jAj number possible actions per step . following columns hold number actions pruned
course minimal-length (or longer) plan using Reachable-1, Reachable-2,
Relevant-1 2 (which yield value), unit propagation linear
encoding using initial state, binary propagation linear encoding using initial state, unit propagation Graphplan encoding using initial state,
binary propagation Graphplan encoding using initial state. final
column correspond propagation using goal state. methods (i.e., unit
binary) encodings yielded values.
Reachable-1 Relevant-1 extremely fast. Execution times algorithms
less 0:01 seconds, except bw.c (0.03 sec.), bw.d (0.07 sec.),
amount small fraction running times required modern SAT algorithms.9
next set experiments, shown Table 2, introduces binary pruning methods
well. Here, limited slow performance prolog implementation
Reachable-2 Medic encoder (Ernst et al., 1997). looked blocks world problems involving 3,4, 5 blocks, respectively, looked logistics domain problems
involving one package two cities, three packages two cities, three packages
three cities. addition, looked three hanoi-tower problems 3,4, 5 disks.
number points worth mentioning:



two domains (blocks' world hanoi), Reachable-2 slightly useful
Reachable-1. logistics domain, hand, Reachable-2 much
effective. However, must remember Reachable-2 yields mutual exclusion
constraints measure. constraints quite useful
important role Graphplan planner.



clear winner emerges. blocks-world domain, binary resolution linear
encoding prunes Reachable-2, whereas logistics domain, Reachable2 prunes more. Interestingly, binary resolution Graphplan-encoding less

9. experiments conducted PC PentiumII-200 processor.

19

fiBrafman

Time
Reach-1
Reach-2
U-Res(lin)
B-Res(lin)
U/B-Res(gp)

1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
1 2 2 3 3 3 4 4 4 4
1 16 16 16 16 16 16 16 16 16
1 2 2 3 3 4 4 5 5 6
1 2 3 4 5 6 7 8 9 10

11
11
5
16
6
11

12
12
5
16
7
12

13
13
5
16
7
13

14
14
5
16
8
14

15
15
5
16
8
15

16
16
6
16
9
16

Table 3: Reachability Analysis 16-bit Counter. Shown number unpruned actions per time step. Rows correspond Reachable-1, Reachable-2, unit
resolution linear encoding, binary resolution linear encoding.
last row corresponds unit binary resolution Graphplan encoding,
identical effect.
effective linear encoding. However, Graphplan-encoding allows
shorter plans, consequently, smaller search spaces. Therefore, Graphplanencoding still likely ecient.



Relevant-2 advantage relevant-1. fact, behavior observed
using resolution well: unit binary resolution linear Graphplan
encodings pruned amount actions. Consequently, present one
column. Indeed, see sets experiments reported Tables 1 2,
relevance analysis contributes little. One obvious reason goal state
often incomplete much less constrained initial state (at least explicitly).
Therefore, algorithms diculty deriving relevance constraints. However,
one's intuition seems indicate case, least
extent observed. means providing better relevance analysis,
although may require sophisticated derivation state constraints.



predicted, relevance analysis much useful state-space level
truth-assignment level.



expected, Graphplan encoding typically better linear encoding.

Finally, ran tests 16 bit version counter domains described
text. constrained domain single action applicable
state wanted see much would discovered algorithms. results shown Tables 3 4, number permisable actions
given function time step. Table 3 presents results forward pruning
using Reachable-1, Reachable-2, unit binary propagation using Graphplan
linear encodings. Table 4 presents results backward pruning using Relevant-1,
Relevant-2, unit binary propagation using linear encodings.

20

fiReachability, Relevance, Resolution

Time
Rel1/2,U/B-Res(gp)
U-Res(l)
B-Res(l)

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
1 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9

Table 4: Relevance Analysis 16-bit Counter. Shown number unpruned
actions per time step. (identical) results Reachable-1, Reachable-2, unitresolution Graphplan encoding, binary-resolution Graphplan
encoding appear first row. next rows correspond unit binary
resolution linear encoding, respectively.

6. Conclusion

shown connection scheme used encode planning instances
ability propagate reachability relevance information initial final steps
time points. hope results serve improve understanding
factors contributing performance different encoding methods. addition,
provided crisp general formulation class reachability relevance algorithms
appear various forms different planning algorithms. compared pruning
ability resolution-based propagation methods operate encoded plans,
Reachable-k Relevant-k algorithms operate plan level. empirical
results show complex picture, clear winner emerges. However, seems
domain constrained (making parallel actions less useful) binary methods
little advantage unary methods. addition, show relevance analysis best
conducted plan level. SAT-based planning algorithms, would suggest use
simple plan-level relevance analysis stage prior plan encoding. observation
confirmed recent results reported Do, Srivastava, Kambhampati (2000).
(Brafman, 1999), pointed binary clauses form large fraction
clauses SAT-encoded planning problems. Given results regarding utility binary
resolution, natural idea augment standard clause simplification techniques (e.g., unit
propagation) limited form binary clause preprocessing. Initial results presented
indicated utility idea: instances unit clauses could derived
form binary resolution, nice reductions running time demonstrated.
unit clauses derivable via method, small overhead incurred.
principled, systematic, ecient technique based ideas investigated
(Brafman, 2000).
work among first attempts theoretically analyze different encoding schemes.
concentrated one particular aspect encodings, i.e., ability propagate concrete state information backwards forwards. Naturally, attempt a-priori
limited scope, ability one factor uencing performance various
algorithms, uence probably significant systematic methods based
David-Putnam procedure methods based stochastic local search.
21

fiBrafman

authors considered ideas presented here, too. Kautz Selman
(1999) discuss relation Graphplan's mutex constraint restricted form
binary propagation. particular show mutex computation limited form
negative binary propagation. mutex propagation, two assertions mutual exclusion
yield new one. course, mutual exclusion statement equivalent binary
clause (e.g., either action performed action b performed), hence
view process limited form binary propagation: f:p _ :qg fp _ :rg
deduce f:q _ :rg. Graphplan performs operation, incomplete manner.
addition, tested additional limited inference methods failed literal strategy
(attempting prove particular literal inconsistent using unit propagation)
binary failed literal strategy (attempting prove binary clause inconsistent using
unit propagation). methods directly correspond methods considered
paper. closely related one options Medic system encoding
planning problems: simple inference method referred simple data- ow
analysis (Ernst et al., 1997). method basically instance Reachable-1.
Haslum Geffner (2000) present parametrized class admissible heuristics functions H . interesting important relation heuristic function
generation technique discussed paper parameterized class reachability
analysis algorithms discussed paper. heuristic function assigns 1
state means believes goal reachable s. heuristic function
admissible, fact, true. Thus, admissible heuristic functions provide sound
tool pruning { goal reachable state assign value
1. fact, derivation heuristic functions class H closely related
computation Reachable-k. cases, instead analyzing actual states, analyze
subsets states size k interactions. However, designing heuristic functions,
greater emphasis put distance current state state
set literals appears without mutual exclusion constraints (i.e., indices sets
C ).
Finally, recent paper Do, Srivastava, Khambhampati (2000) examines encoded
planning problems generated Blackbox planner. Blackbox utilizes mutual exclusion constraints derived Graphplan's planning graph. authors show
constraints useful, despite fact increase size encoding.
addition, authors examine utility adding explicit mutual-exclusion constraints
stemming (state-space based) relevance analysis. constraints appear improve
planner's performance. fact, seems constraints described Do, Srivastava, Kambhampati (2000) powerful generated Relevant-2.
believe Relevant-k strengthened, hope examine issue
closely future.
k

k





Acknowledgments

wish thank Craig Boutilier Chris Geib valuable discussions reachability analysis anonymous reviewers useful detailed comments. particularly
grateful Olga Rozenfeld implemented algorithms Prolog, suggested use
22

fiReachability, Relevance, Resolution

counter example illustrating algorithms, provided important corrections
previous drafts. work supported part Paul Ivanier Center Robotics
Research Production Management.
Appendix A. Proofs

Theorem 1 set propositions actions excluded Reachable-k time j

feasible plan which, time j , propositions hold, or, respectively,
actions appear.

Proof: immediate: Consider valid plan states world
execution plan. straightforward show appear within sets
without constrained virtue valid plan.

Ai



Lemma 1 context linear encoding, Reachable -1 yields reachability information unit propagation.

Proof: Given definitions used earlier on, formal statement lemma
follows: Let k integer denoting length plan. Let
1 set

actions pruned Reachable -1 k-th level given planning domain initial
state. Let
set actions pruned unit-resolution linear
encoding planning domain using k steps (i.e., actions deduce unit
clause containing negation corresponding variable), without goal state
supplied.
, planning instances
.
1A
1A
First let us consider unit resolution. unit clauses available initially correspond propositions hold initial state. axioms propositions denoting state time 0 appear class 1 (precondition axioms) 3
(frame axioms). However, clauses class 3 ternary contain one
proposition. ternary frame clauses yield unit clause able rule
actions one, cannot, stage. Therefore, unit clauses
derived resolving current unit clauses class 1 clauses. resolutions
yield new unit clauses containing negated actions. negated actions resolved
clauses containing positive action variables. variables appear class 4
(at-least-one-action) axioms.
two cases consider. First, suppose able rule
actions one. Using frame effect axioms, derive state time 1.
situation analogous time 0 knowledge
initial state. Since Reachable -1 puts us position, claim follows (using
simple inductive argument). Next, suppose cannot rule actions one.
case, new unit clauses, unit propagation stops. Reachable -1
able rule actions ruled unit propagation process. Moreover,
actions ruled common effect, effect deduced using
Reachable- -1, rule actions require negation precondition.
type information obtained via unit propagation.
reach

u

res

reach

u

res

reach

23

u

res

fiBrafman

Lemma 3 context

Graphplan encoding, unit propagation Reachable-1
rule sets actions, ignore explicit constraints appearing axiom
class 4. use constraints, unit propagation yield reachability information.

Proof: First, suppose ignore mutex axioms class 4. Using unit propagation,

deduce negation actions whose preconditions violated time 0. Negated
action literals resolved class 2 (effect explanation) axioms.
able rule explanations time 1 proposition, deduce negation
manner. mechanism allow us exclude variable using
Reachable-1. Similarly, negated action literals resolved class 3 (at-least-oneaction) axioms, yields information. time 1 variables deduce
used rule time 1 actions.
Notice following. deduce p time 1, one actions produce p
must hold time 0. information explicit Reachable-1 algorithm (although
appear Graphplan's planning graph form edges). However, cannot
used rule actions restricted unit resolution.
Class 4 axioms make difference case. Suppose able
conclude particular action produces p must occur (i.e., deducing p
ruling causes except a). case, actions mutually exclusive
cannot occur. actions may affect p all, negation need
necessarily derivable using Reachable-1.

Theorem 2 Let

state goal reachable using m-step plan
(where step contain number non-interfering actions). (1) set
literals satisfied subset , subset C , (2) exists
m-step plan reaching goal set actions plan
v steps last subset C .




v

v

Proof: Recall assume proposition appearing effects action

appears preconditions well. always enforce requirement converting
action satisfy set actions satisfy it.
proof proceeds induction number steps goal reachable.
Let state goal G reachable single step. Let set
actions one-step plan reaching G . definition, contain
interfering actions. addition, know G reachable performing
preconditions G n Effects-Of (A) must hold .
First, suppose contrary literal l 2 , l 62 S1 . Notice
definition A0 , S1 contains literals consistent
G. Therefore, l must inconsistent G, i.e., :l 2 G. Since l 2 , must
action 2 precondition l effect :l (otherwise, l would hold
performing A). action would A0 preconditions, l among them, would
S1 . conclude S1 .
Next, want show one-step plan reaching G whose
actions A0 . discussion see plan reaching G
r

24

fiReachability, Relevance, Resolution

contains action A0 changing value every proposition l holds
inconsistent G. Clearly, none actions effect
inconsistent G. Let A0 denote set actions. applying A0
transform literals inconsistent G value G destroy
value literal consistent G. Since A0 A, constitutes valid plan (i.e.,
actions interfere other) achieves G. definition, A0 A0 .
conclude proof base step, must show subset C S1 .
Suppose, contrary subset 0 C S1 . seen
0 , set actions A0 A0 A0 l 2 0 either
precondition action A0 l consistent G destroyed A0 .
Denote A00 set consisting A0 noop[] corresponding l 2 0
preconditions element A0 . definition A0 , A00 2 A0 .
However, 0 2 C S1 A00 2 C A0 implies A00 contains interfering actions.
claim impossible. First, effects A00 either G consistent
G, construction. addition, preconditions A00 0 therefore
. actual state world, cannot contain con icting literals. Hence,
0
62 C S1 .
Next, suppose established inductive hypothesis < let
us prove holds = m. Hence, let state exists mstep plan = A1 ; : : : ; attaining G. Let +1 denote state obtained applying
A1 . know
1 step plan achieving G +1 .
+1
inductive hypothesis, satisfies conditions Theorem. particular, know
+1 1 subset +1 C 1 . complete proof would
sucient show +1 reachable one-step plan A0 whose actions
C . proof similar base case.
r













Corollary 1 initial state goal reachable minimal (in
number operators) plan P = A0 ; : : : A00 (where steps numbered backwards)
reaching goal s, A0 C contain subset A0 .










Proof: inspection proof previous theorem shows every step

found subset set actions candidate plan satisfied
relevant conditions. particular, consider minimal plan, elements must satisfy
conditions.

Lemma 4 context linear encoding, unless single safe, final action,
unit propagation yields less relevance information Relevant-1.

Initially, unit clauses goal literals. resolve effect
axioms only. would yield negation various actions (i.e., unsafe actions).
negated action literals resolved action disjunction (axiom class 4).
However, one safe final action, obtain unit clause
disjunction, nothing farther do. information,
more, easily obtainable Relevant-1.
25

fiBrafman

Lemma 5 context

Graphplan encoding, action changing value every literal, unit propagation yields less relevance information
Relevant-1.

Proof: See text prior Lemma.
Appendix B. Complexity Reachable-k Relevant-k

computational complexity Reachable-k O(njAjjLj E + njLjjAj ), n
number levels generate, jAj number possible actions, jLj size
propositional language used, E maximal number actions particular
shared effect. explain below, complexity dominated time required
produce sets C C .
set possible effects, , produced O(jAj ) steps, maximal
number effects.
C requires examining l -tuples elements , l k ,
(jLj ) elements. tuple find set actions produce
it. done quickly, provided maintained pointers actions. number
sets actions O(E ) (since k actions needed).
set actions must check whether subset member C 1 . Given
appropriate representation C 1 , done time O(jAj). accomplish this,
use binary tree whose leafs correspond bit vectors. depth tree
jAj size O(jC 1j). Finally, need maintain C similar tree bitvectors. done O(jLj ) (or, C small, lower cost). overall cost
producing C O(jLj jE j jAj).
produce set , go actions check whether preconditions
appear . requires O(jAj ) steps (assuming bit-vector representation ),
maximal number preconditions action. check
whether preconditions appear C . Since jA j jAj check whether
subset set preconditions appears C time O(jLj), requires O(jAjjLj)
steps.
Finally, need produce C . requires generating subsets size
k less, taking (jAj ) steps. subset must check whether preconditions contain element C . Again, provided appropriate data-structure C
maintained, done O(jLj) set preconditions. case
C , assumed C maintained tree bit-vectors, generated time
(jAj ). overall complexity step (jLjjAj ).
Note small values k data-structures likely provide better performance.
Next, address Relevant-k. analysis assumption
set variables appear preconditions effects operator. noted,
transforming set operators satisfy property set operators
satisfy may cause exponential blow-up worst case.
complexity Relevant-k O(jAj jLj + jLj jAj), jAj number
actions, jLj number proposition language, maximal number
k



k

k





e



e



k

K









k

k





k





p



p











k







k

k

k

k

k

k
p

p

26

fiReachability, Relevance, Resolution

preconditions action. analysis quite similar case Reachable-k,
ignore sets R subsets larger whose generation
contributes constant factors:
set preconditions, , produced O(jAj ) steps.
compute C , iterate O(jLj ) sets literals. set examine
sets actions preconditions, O(m ) sets.
set actions, need check C 1 . check
performed O(jAj) steps. overall complexity step O(jLj jAj).
produce set , go actions useful , require O(jLjE ) (where
before, E maximal number actions particular effect). action,
check whether effects C . Since need perform check
every action, overall complexity O(jLjE + jLjjAj).
Finally, need produce sets C . Interfering actions pre-computed
cost amortized steps. case, computation requires
2
(mjAj ) steps, maximal sum preconditions effects action.
Next, examine effects l-tuples actions, l k, see whether
effects subset C . takes O(jAj jLj) steps.
Again, small values k (and particular, k = 1; 2) tighter analysis possible.
r










p

k



k
p



k



k
p







k



References

Bayardo, R. J., & Schrag, R. C. (1997). Using CSP look-back techniques solve real-world
SAT instances. Proc. AAAI-97, pp. 203{208.
Blum, A., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90, 281{300.
Bonet, B., Loerincs, G., & Geffner, H. (1997). robust fast action selection mechanism
planning. Proc. AAAI-97, pp. 714{719.
Boutilier, C., Brafman, R. I., & Geib, C. (1998). Structured reachability analysis markov
decision processes. Proc. 14th Conference Uncertainty AI, pp. 24{32.
Boutilier, C., & Dearden, R. (1994). Using abstractions decision theoretic planning
time constraints. Proc. AAAI'94, pp. 1016{1022.
Brafman, R. I. (1999). Reachability, relevance, resolution, planning satisfiability
approach. IJCAI'99, pp. 976{981.
Brafman, R. I., & Hoos, H. H. (1999). encode encode - i: linear planning.
IJCAI'99, pp. 988{993.
Brafman, R. I. (2000). simplifier propositional formulas many binary clauses.
Tech. rep. 00-04, Dept. Computer Science, Ben-Gurion University.
Crawford, J., & Auton, L. D. (1993). Experimental results cross-over point
satisfiability problems. Proc. AAAI'93, pp. 21{27.
27

fiBrafman

Davis, M., & Putman, H. (1960). computing procedure quantification theory. Journal
ACM, 7, 201{215.
Do, M. B., Srivastava, B., & Kambhampati, S. (2000). Investigating effect relevance
reachability constraints sat encodings planning. Proc. Fifth Intl.
Conf. AI Planning Scheduling Systems.
Ernst, M. D., Millstein, T. D., & Weld, D. S. (1997). Automatic SAT-compilation
planning problems. Proceedings International Joint Conference Artificial
Intelligence.
Fikes, R., & Nilsson, N. (1971). Strips: new approach application theorem
proving problem solving. Artificial Intelligence, 2 (3{4), 189{208.
Freeman, J. W. (1995). Improvements Propositional Satisfiability Search Algorithms.
Ph.D. thesis, U. Pennsylvania Dept. Computer Information Science.
Genesereth, M. R., & Nilsson, N. J. (1987). Logical Foundations Artificial Intelligence.
Kaufmann, Los Altos, CA.
Gomes, C. P., Selman, B., & Kautz, H. (1998). Boosting combinatorial search
randomization. Proc. 15th Nat. Conf. AI, pp. 431{437.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning. Proc.
Fifth Intl. Conf. AI Planning Scheduling Systems, pp. 140{149.
Kambhampati, S., Parker, E., & Lambrecht, E. (1997). Understanding exending graphplan. Proc. 4th European Conf. Planning, pp. 260{272.
Kautz, H., & Selman, B. (1992). Planning satisfiability. Proc. 10th European
Conf. AI, pp. 359{363.
Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proc. 13th National Conference AI (AAAI'96), pp.
1194{1201.
Kautz, H., & Selman, B. (1999). Unifying sat-based graph-based planning. Proc.
16th Intl. Joint Conf. AI (IJCAI'99), pp. 318{325.
Li, C. M., & Anbulagan (1997). Heuristics based unit propagation satisfiability
problems. Proc. IJCAI-97.
McDermoot, D. (1996). heuristic estimator means-ends analysis planning. Proc.
3rd Int. Conf AI Planning Systems, pp. 142{149.
Nebel, B., Dimopoulos, Y., & Koehler, J. (1997). Ignoring irrelevant facts operators
plan generation. Proc. 4th European Conf. Planning.

28


