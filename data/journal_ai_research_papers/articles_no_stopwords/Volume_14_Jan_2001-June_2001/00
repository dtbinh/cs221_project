journal artificial intelligence

submitted published

reachability relevance resolution
satisfiability
ronen brafman

brafman cs bgu ac il

department computer science ben gurion university
p box beer sheva israel

abstract

recent years growing awareness importance reachability
relevance pruning techniques little work specifically targets
techniques compare ability two classes propagate
discover reachability relevance constraints classical first
class operates sat encoded obtained linear
graphplan encoding schemes applies unit propagation general resolution steps involving larger clauses plan encodings second class operates
plan level contains two families pruning reachable k relevantk reachable k provides coherent description number existing forward pruning
techniques used numerous relevant k captures different grades backward pruning shed light ability different plan encoding schemes
propagate information forward backward relative merit plan level
sat level pruning methods
introduction

success satisfiability pas kautz selman
led attempts refine initial methods used improve understanding performance particular methods generating formulas
instances compared ernst millstein weld systematic alternatives original stochastic method examined e g bayardo
schrag li anbulagan still many issues surrounding
poorly understood particular little known uence encoding method
performance
concentrating two encoding methods proposed kautz selman
linear graphplan encodings examine uence ability
propagate reachability relevance information via unit propagation generally
k clause resolution comparing pruning ability techniques
class reachability relevance analysis operate original
formulation reachable k relevant k reachable k simplified variant
similar state pruning markov decision processes boutilier brafman
geib relevant k natural counterpart used relevance analysis
provide coherent framework discussing different grades reachability
relevance pruning methods appear literature
work motivated growing role forward backward pruning methods
play current important role propagation techniques

c ai access foundation morgan kaufmann publishers rights reserved

fibrafman

sat solvers used satisfiability unit propagation plays
central role davis putnam davis putman many
offsprings e g crawford auton freeman gomes selman kautz
li anbulagan used preprocessing step stochastic methods
applied moreover limited form binary propagation used crawford compact
program simplifying cnf formulas utilized blackbox planner kautz
selman shed light relationship pruning
techniques
organized follows section provides background material describing
basic ideas pas framework graphplan section
discuss reachable k performing reachability analysis compare
ability prune possible actions k clause resolution section describe
relevant k similar reachable k applied relevance analysis
compare methods resolution section empirically compare
methods k conclude discussion future related work
section proofs appear appendix main arguments described
body
background

graphplan blum furst satplan kautz
selman profoundly altered direction within
community two main concepts studied reachability analysis plan
encodings become central current thanks planners
brie discuss planners particular aspects pertaining topic

reachability analysis graphplan
purpose reachability analysis discover unreachable states world
infeasible actions e actions cannot performed course successful plan
discovering actions ahead time reduce space needs searched
valid plan principle full edged reachability analysis requires forward search
space possible states expensive operation instead opt
sound incomplete methods methods discover actions
ruled however action rule infeasible need considered
searching plan
graphplan planner provides good example utility approximate reachability analysis graphplan two main stages first stage approximate reachability analysis conducted yielding data structure called graph
represents sound incomplete approximation set states reachable
initial state second stage graphplan searches plan structure
graphplan graph construction presents particularly good tradeoff
computational complexity pruning power utility pruning search
space attested planner good performance
graph construction viewed generating list annotated sets odd elements list contain sets propositions even elements


fireachability relevance resolution

list contain sets actions set annotated mutual exclusion constraints members intuitively action set contains list actions could
performed step concurrent action plan e plan allowing concurrent
execution actions interfere proposition set contains
propositions could hold sets concurrent actions performed
mutual exclusion constraints circumscribe sets indicating certain pairs
actions propositions cannot occur time particular stage hence
propositions p q appear proposition set possible accurately
rule possibility step plan applied initial
state could lead world p q hold however p q marked
mutually exclusive know p q cannot hold together step plan
performed
sets constructed follows first proposition set contains propositions
hold initial state first action set contains actions performed
initial state general set propositions contains effects actions
action set action set contains actions whose preconditions appear
set propositions provided preconditions marked mutually
exclusive mutual exclusion constraints added follows two actions marked
mutually exclusive action set preconditions marked mutually exclusive
clearly preconditions actions cannot hold time
point cannot perform actions together time point another reason
marking actions mutually exclusive con ict one action destroys
precondition effect action two propositions proposition set
marked mutually exclusive pairs actions action set
effects mutually exclusive case way us achieve
propositions together stage
initial construction graph terminated goal propositions
appear last proposition set point graphplan performs form regressionbased search graph structure search fails graph
extended one additional layer actions one additional layer propositions
searched details see article blum furst
th

th

th

th

th

th

th

th

th

th

th

th

satisfiability
satisfiability pas short works follows given
bound n size plan plan encoder generates propositional
formula conjunctive normal form formula following property satisfiable
iff solution n time steps intuitively formula
composed propositions describing state world throughout execution
n step plan
propositional language top formula defined contains proposition
possible aspect world time point example suppose looking
blocks world domain states described clear relations
case pair blocks x time point n shall introduce
proposition pon corresponds x top time similarly
x



fibrafman

every block x time point n shall introduce proposition pclear
corresponds x clear time
truth assignment language described viewed describing state
world execution n step plan instance pon assigned
true block top block b time course truth assignments
language would correspond anything resembling true state world
execution actual plan example b b could
assigned true goal encoding scheme generate formula
assignment satisfying formula correspond true state world
execution actual plan achieves desired goal axiom formula
places constraint value propositions combined effect
constraints ensure resulting formula precisely desired truth
assignments example one type axiom conjunction propositions
corresponding initial state truth assignment satisfying axiom must ensure
propositions hold time another class axioms could state
action performed time world time must satisfy preconditions
next sections discuss two central plan encodings detail
appropriate formula generated simplified well
known techniques particular simplifiers employ unit resolution step genesereth
nilsson unit resolution known unit propagation works follows
satisfy cnf formula must satisfy clauses particular one
clauses contains single literal clause known unit clause immediately
know variable appearing clause must assigned appropriate value
clause containing literal satisfied removed
formula clause c containing negation literal resolved
unit clause resulting clause smaller c replace c example
suppose formula p q p r p first disjunct p unit clause
hence p must assigned true makes third clause r p satisfied second
clause resolved first clause replace q p q
unit clause q proposition q must assigned value false
additional clauses containing q q could remove simplify
appropriate
simplification apply favorite finding satisfying assignments
one attained decoder used obtain actual plan solution
satisfying assignment increase value n size plan
try
finally note blackbox planner kautz selman combines pas
graphplan reachability analysis constructs graph uses
generate particular plan encoding
x

b

reachability resolution

reachability relevance analysis form essential part successful modern
notable example reachability analysis graphplan
graph blum furst many recent planners employ reachability analysis


fireachability relevance resolution

e g bonet loerincs geffner relevance analysis e g mcdermoot nebel
dimopoulos koehler kambhampati parker lambrecht
importance reachability relevance analysis noted context decisiontheoretic well example boutilier dearden employ relevance
analysis reduce state space boutilier brafman geib describe
general method reachability analysis mdps discuss method
simplified form suitable classical described strips representation language fikes nilsson section present counterpart
method performing relevance analysis relate k clause resolution
context sat encoded

propagating reachability information
reachable k boutilier brafman geib estimating states
reachable given initial state formulated quite general applies domains non deterministic actions conditional effects figure present
simplified version reachable k deals deterministic unconditional actions represented strips representation language prolog implementation
reachable k available www cs bgu ac il pdm
important reason interest reachable k similarity uential graph construction graphplan planner blum furst
fact generalizes ideas behind graphplan graph equivalent
reachable use denote set actions feasible steps initial state

denote corresponding set propositions c denote constraints
propositions fp p g c propositions cannot co occur

steps c denotes similar constraints actions fl p g l used
restrict attention linear action sequences p used allow concurrent
non con icting actions e actions destroy others effects preconditions
whose preconditions constrained co occur course k sets


c c empty actually defined c
empty even
k plays real part ignored finally note
description set possible actions contains actions form noop l
l literal
k represent propositional action levels graphplan
graph c c hold respective mutual exclusion constraints
stated termination condition reachable k one formulated
content index pas framework number
time steps fixed one would opt second alternative reachable k gives us sets
actions propositions could occur performance j actions
j sets concurrently non con icting actions initial state easy see
reachable k sound following sense














l








p






j

j

theorem set propositions actions excluded reachable k time j

feasible plan time j propositions hold respectively
actions appear


fibrafman

literals hold initial state







c

fg

actions whose preconditions
c al
ffai aj gjai aj j neither ai aj noops aj noop whose effect
destroyed ai g
c ap ffai aj gjai aj j ai deletes precondition effect aj g






define si ai inductively follows
literals appear effects ai
c si l tuples literals l k appearing si subset set
actions ai literals appearing among effects appears c ai
fl p g appropriate




actions whose preconditions appear si subset preconditions appears
c si
c al
ffal aj gjal aj ai l j neither al aj noops aj noop whose effect
destroyed al g
c api ffaj ajl gjl k aj ajl ai jm jn n ajm
deletes precondition effect ajn n subset union
preconditions aj ajl appears c si g




figure reachable k
sometimes actions executed particular time point p holds
p effect case ignore noop p action part
useful plan however formulated p appear reachable k next level
denote reachable k variant noop p appear case
computational complexity reachable k njajjlj e njljjaj n
number levels generate jaj number possible actions jlj size
propositional language used e maximal number actions particular
shared effect detailed explanation appears appendix b
example illustrate parallel action version reachable k use following
domain four propositions p p p p intuitively think
representing binary counter bits actions
increases counter one different states domain single non noop
action applicable state changes least significant bit changes next
bit changes third bit changes significant bit applicable
first bits one specifically actions
k

k

k



e g pas may necessary leave noops



fireachability relevance resolution



precondition





precondition

p



precondition

p

p



precondition

p

p

p

effect

p



effect
effect
effect
p

p

p

p

p

p

p

p

p

p
p

p

p



compare reachable reachable initial state p p p p
corresponds binary representation concentrate interesting
parallel action version shall mention noops explicitly obvious
mutual exclusion constraints propositions negations
context reachable c c empty practical purpose
start f p p p p g action affecting first bit applicable
fa g relevant noops fp p p p p g
preconditions appear fa g consequently
fp p p p p p g apply fa g
fp p p p p p p g finally stage preconditions appear
well fa g
next consider reachable f p p p p g c empty
fa g next step fp p p p p g interesting constraints
c fa g however c contains interfering
actions fp p p p p p p g case k however c contains
p p follows fact actions capable producing p
noop p action capable producing p interferes
noop p therefore c contains p p applicable
stage hence fa g one action less set reachable fp p p p p p p g however c contain p p
noop p used achieve p con ict e g noop p
therefore fa g
see k improves ability prune k suppose
fp p p p g e counter value consider k first
f p p p p p p p g p p p p p p
p p c mutual exclusion relations stems fact
mutually exclusive noop p noop p therefore fa g
f p p p p p p p g c contains p p
fa g c empty fa g however k
c contains ternary constraint p p p ternary constraint remains c
well c c k






k clause resolution reachability
clause resolution propagation refers resolution pairs clauses one whose
length k k variant e unit propagation integral part
major generating satisfying assignments
wish compare type reachability information derived performing k clause
resolution sat encoded information obtained running
k



fibrafman

reachable k reachability information mean constraints set
actions possible time point constraints world states form e g sets
unreachable propositions k tuples propositions hence example constraint
form implies one actions must appear time
plan constraint form implies one actions must
appear plan similar constraints propositions holding time point
derived principle constraints reduce search space could help us attain
solution quickly however effectiveness deduced constraints depends
precise used moreover comparison large class constraints
seems quite dicult therefore article concentrate concrete class
reachability information form e action cannot performed
state reachable via steps powerful constraint utilized effectively
almost planners perhaps exception partial order planners consequently
shall say alg generates reachability information another
alg whenever alg able determine action cannot performed
time alg able reach conclusion well addition
conclusions alg reach alg cannot reach hence alg generates
strict superset constraints actions type interested generated
note mean alg better alg
every instance good cases better section
shall compare pruning ability two reachable k variants two encoding
methods discussed kautz selman linear encoding graphplan
encoding
linear plan encoding

linear plan encoding kautz selman simple natural method
translating formula satisfiable iff valid plan
length n given n clauses linear plan encoding fall following
classes
action implies preconditions prior execution
action implies effects following execution
action affect proposition frame axioms
least one action time point
one action time point
explicit frame axioms noops needed linear encoding
opposed graphplan encoding addition formula contains unary clauses
describing initial goal states however purpose analyzing reachability
effects exclude description goal state plays role relevance analysis
consider mechanism resolution yield reachability information given
propositions hold initial state derive negation actions whose
third state encoding method cannot generated automatically



fireachability relevance resolution

preconditions hold unit propagation axioms class propagating
unit clauses appropriate instance axiom class obtain disjunction
actions executed first time point far identical
reachable k provides propagate information forward resolve
action disjunctions axioms class however requires binary resolution
discussed hence except unlikely case single action possible
derive unit propagation alone reachable
hand provide us list possible effects actions possibly
prune future actions whose preconditions appear list conclude
lemma context linear encoding reachable yields reachability

formation unit propagation

example consider blocks world domain single action schema move object source

destination preconditions object source clear object clear destination
effects object destination clear source object source clear
destination except destination table clear k
stacks blocks initially k actions performed initial state e moving block
top stack top another stack table discovered
particular unit propagation yield disjunction actions
know blocks blocks top cannot participate
second move action reachable due fact
clear suppose one block initially feasible move actions participate
frame axiom form move clear clear clausal
form move clear clear resolving clear
move clear could deduce clear could rule
actions precondition restricted unit propagation
requires deducing move initially feasible action cannot make
deduction
propagated information forward axioms class used binary
resolution discussed lemma set disjunctions possible
effects including frame effects initially allowable actions number
disjuncts e e maximal number effects action
number actions executed initially cases disjunctions could
contain single literal e g initially allowable actions leave proposition
unchanged one disjunctions contains literals negations
action precondition deduce negation action resolving
axioms class
example example considered would generate disjunction form
move move move containing instances move
action time whose negations deduced discussed
actions obtain clause form move clear resolve
binary clauses clause obtain unary clause clear








fact since use plain strips need three action schemas one moving block block one
moving block table one moving block table however
affect analysis stick single move action following examples



fibrafman

used conjunction class axioms deduce negations step actions
whose preconditions include clear
saw effect disjunctions discussed allow us rule certain propositions combinations propositions analogous mutual exclusion constraints
mutual exclusion constraints used prune actions example deduce p p p preconditions action deduce
binary resolution resolving precondition axioms disjunction however
binary resolution trouble propagating even binary mutual exclusion
constraints forward believe generally true e k clause resolution
trouble propagating k ary constraints following




lemma reachable binary resolution case linear encoding incomparable

prove providing two examples one reachable able prune
action binary resolution cannot one converse hold
first consider bit counter initial value e p p p p four steps obtain following f p p p p p p p g c
f p p p p g therefore fa g implies claim
p p c well means see consider pairs
actions p p effects noop p noop p
noop p noop p pair real actions mutually exclusive
linear encoding preconditions noop p mutually exclusive according
c preconditions noop p noop p finally noop p
interfering actions conclude p p c
run binary resolution procedure linear encoding
could deduce stems fact ternary resolution needed
propagate mutual exclusion p p recall obtain mutual exclusion
constraints resolving disjunction actions ruled
case time would following disjunction noop p
noop p goal deduce p p p p axioms
try deduce p p actions disjunction
easy deduce p p however believe impossible
deduce p p noops reason
deduction involves use frame axioms ternary know e g p
holds apply unit resolution frame axioms obtain binary clause however
know p p resolve frame axiom remain
ternary clause get desired must resolve two ternary clauses
finally let us see example use binary resolution derive ternary
constraint definition reachable cannot derive constraints suppose
initial state p q r four actions p r effects q r effects

p q effects p q r preconditions reachable deduce
possible time get possible effects p q r p q r recall
fact deduction impossible verified hypothesizing reason




fireachability relevance resolution

must include noop actions reachable k order capture frame effects
strict subset p q r appear set constraints c since deal binary
constraints set fp q rg appear c therefore consider
possible time although fact impossible binary resolution would
obtained constraint p q r referring time would enabled
us deduce impossible time
graphplan encoding

graphplan encoding differs linear encoding ability consider multiple
concurrent non interfering actions allowing one obtain shorter plans turn
reduce search space size constructs following sets clauses
action implies preconditions
effect implies one actions effect
least one action time point
two con icting actions cannot occur together
besides obvious ability consider multiple parallel non interfering actions important difference graphplan linear encoding axiom class referred
ernst et al explanatory frame axioms clauses class contain
positive occurrences action literals negative occurrences state literals
linear case unit propagation infer actions cannot
applied initial state axioms class propagate information forward deducing negation effects cannot produced initially allowable
actions information enables us exclude actions whose preconditions cannot produced forward propagation essentially identical reachable informally
conclude

lemma context

encoding unit propagation reachable
yield reachability information ignore explicit constraints appearing
axiom class use constraints unit propagation yield reachability
information
graphplan

precise carefully define notion reachability constraints context
graphplan encoding example graphplan encoding derive
constraint says one group actions must appear plan constraint
necessarily rule action graphplan encoding permits multiple
actions time point however linear encoding constraint
immediately rule actions single action allowed time
point mentioned earlier concentrate strict exclusion constraints
however actions interfere cannot occur concurrently know action
occur deduce action interferes occur precisely
class axioms enter picture




fibrafman

lead immediate reduction search space ruling need certain
actions certain time points
k mechanism remains axioms class play
prominent role use exclude actions cases
however propagating mutual exclusion constraints forward
linear encoding reappear consequently k clause resolution
context graphplan encoding reachable k incomparable
relevance resolution

relevance analysis complex task performed degrees
instance considering last action level one exclude actions produce
literal goal however actions producing goal literal irrelevant
example consider blocks world color blocks
specified part goal observed nebel dimopoulos koehler
paint block action still intuitively irrelevant initial final colors blocks
however goal literal effect
section formulate relevance analysis called relevant k
relevant k perform deeper relevance analysis needed determine
paint block action irrelevant example rather relevant k similar
motivation form reachable k similar soundness property relevant k
prunes search space excluding states goal reachable within
given number steps actions useful achieving goal state within
given number steps
relevant similar number existing components existing planners
mcdermott greedy regression graph mcdermoot nebel dimopoulos
koehler trees nebel et al relevant k generalizes ideas arbitrary
levels interactions taking consideration mutual exclusion constraints relevant
states must satisfy relevant k slightly complicated reachable k
strips formalism allows incomplete description goal states propagating partial information raises diculties naturally goal state partially specified
fewer constraints available start fewer constraints derived
described figure aware similar general formulation
ideas therefore worthwhile going central points
concentrating interesting complex case parallel actions allowed however point important assumption shall make
action representation used proposition symbol shall appear preconditions effects action restriction dicult enforce
strips domain representation transformed description
assumptions satisfied example p precondition action appear
effect simply add effect know must hold
action executed p appears effect neither p p appear
preconditions decompose two versions action one p
precondition one p precondition note worst case
transformation cause exponential blow number actions


fireachability relevance resolution

r contains actions useful safe w r goal
contains ar noops safe w r goal




contains pairs interfering actions
define ri si ari ai inductively follows
ri union preconditions actions ari


c





union preconditions actions ai

contains sets literals si js j k set actions ai
whose preconditions contain case c ai
ari contains actions useful w r ri subset effects contained
c si
ai contains ari noops useful w r si
c ai contains action sets ai contains two interfering
actions subset set effects c si



cs

action descriptions must contain set propositional symbols precondition
effect lists

figure relevant k
k quite simple identical parallel linear cases
case ignore sets c c degenerate consider
sets r starting goal literals stage set
literals construct next set actions action set contains actions
effect current literal set however goal effects action
part preconditions ignore action irrelevant next literal set
constructed containing set preconditions current set actions repeat
process set
k picture becomes bit complicated start set
relevant actions actions achieve one desired literals
particular contains actions one goal literals effect
precondition goal partially specified literals part could hold
previous time step hence include appropriate noop actions larger set
contains noops destroy needed propositions subset
actions mutually exclusive contains interfering actions actions whose
effects mutually exclusive given set generate set r includes
preconditions set defined set preconditions actions
goal completely specified state sets r sets
identical need distinguish








r




r


r

r






r


r
















r


fibrafman

facilitate description relevant k would useful add
simple definitions first wish revise definition interfering actions
context relevant k say actions interfere
effect con icts precondition effect beyond
previous definition term preconditions inconsistent action useful
w r respect literal l noop action preserving l l effect
precondition useful w r set literals useful w r one
set elements set actions safe w r set literals action
effect negates element
relevant k embodies intuitions described note increased index corresponds points earlier time definition sets r quite intuitive
contains preconditions actions previous r contains preconditions actions contains actions useful mutually exclusive
effects defined much w r rather r set c contains
literals mutually exclusive particular point set l literals mutually
exclusive set relevant actions l among preconditions mutually
exclusive set c contains mutually exclusive sets actions set actions
mutually exclusive contains interfering actions set effects mutually
exclusive
example order illustrate relevant k shall use counter
example used section starting three bit counter propositions
p p p actions change value single bit
provided values lower bits
start final state f p p p g k since final state fully
specified distinction sets r
contains action three relevant noops contains fp p p p p p g
contains appropriate noops remaining sets look

k k case however c contains p p
p p implies cannot applied hence contains
unlike case k action would introduced next step
next consider partially specified goal fp p g k
fa noop p noop p g p effect destroy p whereas
example effect goal would contain well
noops p p r fp p p p g fp p p p p g next
contains fa g etc
finally suppose four bits goal state f p p p p g e
counter bit value k contains fp p p p p p p g
however c contains pairs p p p p others contains
noops c contain p p contain
p p though precludes action next step
c longer contains p p implies
add effects longer mutually exclusive overall
fa g fa g fa g fa g however k










r


r




r


r
















r




r

r

r



fireachability relevance resolution

would still mutual exclusion constraint p p p would
allow us add hence k fa g
prove following soundness
c

theorem let

state goal reachable step plan
step contain number non interfering actions set
literals satisfied subset subset c exists
step plan reaching goal set actions plan
v steps last subset c






v

v

corollary theorem

corollary initial state goal reachable minimal
number operators plan p steps numbered backwards
reaching goal c contain subset










complexity relevant k jaj jlj jlj
jaj jaj number
actions jlj number proposition language maximal number
preconditions action details see appendix b
compare amount relevance information propagated backwards
k clause resolution goal literals opposed relevant k consider unit
propagation first context linear encoding see actions destroy
goal condition ruled however actions irrelevant
produce irrelevant effects pruned hand relevant prunes
actions destroy goal literal actions simply irrelevant
slightly degenerate case actions one destroy goal proposition
case unit propagation able deduce previous state consequently

k

k

k
mp

p

lemma context linear encoding unless single safe final action

unit propagation yields less relevance information relevant

context graphplan encoding situation often worse unit propagation prunes even less linear encoding goal propositions appear
class effect axioms propagating axioms obtain disjunctions
positive action propositions explaining particular goal proposition assume
literals one explanation see unit clauses emerge consequently prune nothing
example consider blocks world domain suppose three
blocks b c goal b clearly action moves block c
moves another block top block c irrelevant last action consider
graphplan encoding unit clause b last
time point resolve effect axiom lists possible causes
b aside noop action actions moving c b
general proving action ruled means shown e
plans action appear cannot expect able irrelevant action
since could possibly inserted plan without affecting



fibrafman

moving table b yields ternary clause additional unit
clauses axioms b appears negated
notice means excluding actions destroy one goal literals
example goal clear would want action move b c
last action however deduce clear move b c move b table move c b move c table noop clear
could use binary resolution stage could deduce negation action
effect clear action would mutually exclusive
five actions
goal literal l single explanation must noop action implies
real operator effect case would able deduce
noop action must hold precondition axioms would deduce
l must hold previous step mutex axioms class could deduce
negation action destroys l however cannot deduce negation
action interact l whether simply irrelevant destroys
goal literal
example consider domain rocket domain rocket fuel
action fueling rocket suppose rocket fuel goal
state hence fuel holds since explanation axiom fuel binary clause e
fuel noop fuel resolving axiom fact fuel derive
unit clause noop fuel precondition axioms derive fuel
mutex axiom derive action fly one whose effects
fuel notice though cannot deduce negation action
interact proposition fuel whether irrelevant example fuel
proposition goal action loading rocket
affect value proposition fuel need considered final action
plan however way deducing load
action produce fuel reasoning would apply step
able deduce fact fuel holds time point plan
fact able prune actions fuel precondition
relevant able fuel precondition effect
relevant point considered relevant action

lemma context

encoding action changing value every literal unit propagation yields less relevance information
relevant
graphplan

actual values appears section particular examples looked
graphplan encoding could prune action follows quite typical
fact domains facts hold final state achieved
number actions hence unit propagation deduce disjunctions possible
course particular domain action whose precondition fuel
observation still valid example may maintenance action performed
rocket without fuel



fireachability relevance resolution

actions none unit clause since way deducing negated actions
propagation stops point
general case similar linear encoding obtained disjunction
allowable actions generate disjunction allowable preconditions information
propagated backwards much forward case yet k case
expect form backwards reachability analysis goal state rather true
relevance analysis relevant k likely much better job
takes explicit relevance issues account however case reachability analysis
ability k clause resolution yield constraints order greater k
cannot relevant k better
context graphplan encoding generate disjunctions relevant
actions disjunctions relevant preconditions deduced etc however
irrelevant actions excluded explicitly since one action allowed
step conclude relevant action must appear
exclude actions destroy goal proposition deduce constraints
order greater k via k clause resolution cannot provide general
finally note graphplan planner incorporate relevance analysis mea graphplan recent variant kambhampati et al
well ipp nebel et al ernst millstein weld discuss enhanced
version graphplan encoding contains effects axioms well e axioms
form action effect terms ability propagate reachability relevance
information see added ability rule actions destroy needed propositions
linear encoding
empirical evaluation

previous sections attempted understand mechanisms resolution
yields reachability relevance information compare natural class
direct reachability relevance noted relationship
subsumption interest examine actual pruning abilities
section describe performance number
standard limited number domains used caution
exercised interpreting however interesting emerge
first set experiments examined performance unary methods large blocks
world logistics domain used blocks world bw dir b c
satplan distribution involving blocks respectively minimal
plans length logistics domain instances described
brafman hoos involving packages cities minimal plans size
respectively sat encodings generated medic program ernst
et al used crse options obtain linear encoding erpe options
obtain graphplan encodings however encoding obtained via erpe options contain explicit effect axioms linear encoding axiom improve
graphplan encoding ability propagate relevance information
instances part ucpop distribution maintained university washington
http www att com kautz blackbox index html blackbox home page



fibrafman

log
log b
log c
bw
bw b
bw c
bw

j j










reach rel r r u rch l u rel l






















table pruning effects unary methods jaj number possible actions
course minimal length plan following entries hold number
actions pruned reachable relevant combined unit propagation
linear encoding initial state final state unit propagation
graphplan encoding final state yielded pruning execution
times reach relevant seconds except bw c
sec bw sec
set experiments measured number potential actions eliminated
following reachable relevant reachable relevant combined
reachability analysis via unit resolution initial state relevance analysis via
unit resolution goal state consider graphplan encoding
following reasons
unit propagation graphplan encoding yields much information reachable particular experiments cases unit resolution
final state graphplan encoding prunes little actions
fact appearing goal state number potential producing actions
version graphplan encoding produced medic basically equivalent
linear encoding terms relevance information contains explicit effect axioms
actual numbers appear table first column provides size set
actions minimal plan length following columns provide number actions
pruned methods tested evident reachable extremely effective
relevance analysis seems much less useful although relevant prune non negligible
number actions unit resolution quite disappointing although line
theoretical analysis recalling unit resolution graphplan encoding
equivalent reachable see much greater potential pruning
graphplan encoding another interesting observation little overlap
reachability relevance analysis stems fact pruning
effect often quite shallow pruning done
first steps reachability last steps relevance finally note
k quite fast unit propagation important heuristic sat
solution david putnam davis putman
extremely fast negligible running times e seconds surprisingly


fireachability relevance resolution

bw sm
bw sm b
bw sm c
log sm
log sm b
log sm c
hanoi
hanoi
hanoi

j j












rch rch rel rch l rch l rch gp rch gp rel l g









































































table effects unary binary methods jaj number possible actions per step following columns hold number actions pruned
course minimal length longer plan reachable reachable
relevant yield value unit propagation linear
encoding initial state binary propagation linear encoding initial state unit propagation graphplan encoding initial state
binary propagation graphplan encoding initial state final
column correspond propagation goal state methods e unit
binary encodings yielded values
reachable relevant extremely fast execution times
less seconds except bw c sec bw sec
amount small fraction running times required modern sat
next set experiments shown table introduces binary pruning methods
well limited slow performance prolog implementation
reachable medic encoder ernst et al looked blocks world involving blocks respectively looked logistics domain
involving one package two cities three packages two cities three packages
three cities addition looked three hanoi tower disks
number points worth mentioning



two domains blocks world hanoi reachable slightly useful
reachable logistics domain hand reachable much
effective however must remember reachable yields mutual exclusion
constraints measure constraints quite useful
important role graphplan planner



clear winner emerges blocks world domain binary resolution linear
encoding prunes reachable whereas logistics domain reachable prunes interestingly binary resolution graphplan encoding less

experiments conducted pc pentiumii processor



fibrafman

time
reach
reach
u res lin
b res lin
u b res gp


















































table reachability analysis bit counter shown number unpruned actions per time step rows correspond reachable reachable unit
resolution linear encoding binary resolution linear encoding
last row corresponds unit binary resolution graphplan encoding
identical effect
effective linear encoding however graphplan encoding allows
shorter plans consequently smaller search spaces therefore graphplanencoding still likely ecient



relevant advantage relevant fact behavior observed
resolution well unit binary resolution linear graphplan
encodings pruned amount actions consequently present one
column indeed see sets experiments reported tables
relevance analysis contributes little one obvious reason goal state
often incomplete much less constrained initial state least explicitly
therefore diculty deriving relevance constraints however
one intuition seems indicate case least
extent observed means providing better relevance analysis
although may require sophisticated derivation state constraints



predicted relevance analysis much useful state space level
truth assignment level



expected graphplan encoding typically better linear encoding

finally ran tests bit version counter domains described
text constrained domain single action applicable
state wanted see much would discovered shown tables number permisable actions
given function time step table presents forward pruning
reachable reachable unit binary propagation graphplan
linear encodings table presents backward pruning relevant
relevant unit binary propagation linear encodings



fireachability relevance resolution

time
rel u b res gp
u res l
b res l






table relevance analysis bit counter shown number unpruned
actions per time step identical reachable reachable unitresolution graphplan encoding binary resolution graphplan
encoding appear first row next rows correspond unit binary
resolution linear encoding respectively

conclusion

shown connection scheme used encode instances
ability propagate reachability relevance information initial final steps
time points hope serve improve understanding
factors contributing performance different encoding methods addition
provided crisp general formulation class reachability relevance
appear forms different compared pruning
ability resolution propagation methods operate encoded plans
reachable k relevant k operate plan level empirical
complex picture clear winner emerges however seems
domain constrained making parallel actions less useful binary methods
little advantage unary methods addition relevance analysis best
conducted plan level sat would suggest use
simple plan level relevance analysis stage prior plan encoding observation
confirmed recent reported srivastava kambhampati
brafman pointed binary clauses form large fraction
clauses sat encoded given regarding utility binary
resolution natural idea augment standard clause simplification techniques e g unit
propagation limited form binary clause preprocessing initial presented
indicated utility idea instances unit clauses could derived
form binary resolution nice reductions running time demonstrated
unit clauses derivable via method small overhead incurred
principled systematic ecient technique ideas investigated
brafman
work among first attempts theoretically analyze different encoding schemes
concentrated one particular aspect encodings e ability propagate concrete state information backwards forwards naturally attempt priori
limited scope ability one factor uencing performance
uence probably significant systematic methods
david putnam procedure methods stochastic local search


fibrafman

authors considered ideas presented kautz selman
discuss relation graphplan mutex constraint restricted form
binary propagation particular mutex computation limited form
negative binary propagation mutex propagation two assertions mutual exclusion
yield one course mutual exclusion statement equivalent binary
clause e g action performed action b performed hence
view process limited form binary propagation f p qg fp rg
deduce f q rg graphplan performs operation incomplete manner
addition tested additional limited inference methods failed literal strategy
attempting prove particular literal inconsistent unit propagation
binary failed literal strategy attempting prove binary clause inconsistent
unit propagation methods directly correspond methods considered
closely related one options medic system encoding
simple inference method referred simple data ow
analysis ernst et al method basically instance reachable
haslum geffner present parametrized class admissible heuristics functions h interesting important relation heuristic function
generation technique discussed parameterized class reachability
analysis discussed heuristic function assigns
state means believes goal reachable heuristic function
admissible fact true thus admissible heuristic functions provide sound
tool pruning goal reachable state assign value
fact derivation heuristic functions class h closely related
computation reachable k cases instead analyzing actual states analyze
subsets states size k interactions however designing heuristic functions
greater emphasis put distance current state state
set literals appears without mutual exclusion constraints e indices sets
c
finally recent srivastava khambhampati examines encoded
generated blackbox planner blackbox utilizes mutual exclusion constraints derived graphplan graph authors
constraints useful despite fact increase size encoding
addition authors examine utility adding explicit mutual exclusion constraints
stemming state space relevance analysis constraints appear improve
planner performance fact seems constraints described srivastava kambhampati powerful generated relevant
believe relevant k strengthened hope examine issue
closely future
k

k





acknowledgments

wish thank craig boutilier chris geib valuable discussions reachability analysis anonymous reviewers useful detailed comments particularly
grateful olga rozenfeld implemented prolog suggested use


fireachability relevance resolution

counter example illustrating provided important corrections
previous drafts work supported part paul ivanier center robotics
production management
appendix proofs

theorem set propositions actions excluded reachable k time j

feasible plan time j propositions hold respectively
actions appear

proof immediate consider valid plan states world
execution plan straightforward appear within sets
without constrained virtue valid plan

ai



lemma context linear encoding reachable yields reachability information unit propagation

proof given definitions used earlier formal statement lemma
follows let k integer denoting length plan let
set

actions pruned reachable k th level given domain initial
state let
set actions pruned unit resolution linear
encoding domain k steps e actions deduce unit
clause containing negation corresponding variable without goal state
supplied
instances



first let us consider unit resolution unit clauses available initially correspond propositions hold initial state axioms propositions denoting state time appear class precondition axioms
frame axioms however clauses class ternary contain one
proposition ternary frame clauses yield unit clause able rule
actions one cannot stage therefore unit clauses
derived resolving current unit clauses class clauses resolutions
yield unit clauses containing negated actions negated actions resolved
clauses containing positive action variables variables appear class
least one action axioms
two cases consider first suppose able rule
actions one frame effect axioms derive state time
situation analogous time knowledge
initial state since reachable puts us position claim follows
simple inductive argument next suppose cannot rule actions one
case unit clauses unit propagation stops reachable
able rule actions ruled unit propagation process moreover
actions ruled common effect effect deduced
reachable rule actions require negation precondition
type information obtained via unit propagation
reach

u

res

reach

u

res

reach



u

res

fibrafman

lemma context

graphplan encoding unit propagation reachable
rule sets actions ignore explicit constraints appearing axiom
class use constraints unit propagation yield reachability information

proof first suppose ignore mutex axioms class unit propagation

deduce negation actions whose preconditions violated time negated
action literals resolved class effect explanation axioms
able rule explanations time proposition deduce negation
manner mechanism allow us exclude variable
reachable similarly negated action literals resolved class least oneaction axioms yields information time variables deduce
used rule time actions
notice following deduce p time one actions produce p
must hold time information explicit reachable although
appear graphplan graph form edges however cannot
used rule actions restricted unit resolution
class axioms make difference case suppose able
conclude particular action produces p must occur e deducing p
ruling causes except case actions mutually exclusive
cannot occur actions may affect p negation need
necessarily derivable reachable

theorem let

state goal reachable step plan
step contain number non interfering actions set
literals satisfied subset subset c exists
step plan reaching goal set actions plan
v steps last subset c




v

v

proof recall assume proposition appearing effects action

appears preconditions well enforce requirement converting
action satisfy set actions satisfy
proof proceeds induction number steps goal reachable
let state goal g reachable single step let set
actions one step plan reaching g definition contain
interfering actions addition know g reachable performing
preconditions g n effects must hold
first suppose contrary literal l l notice
definition contains literals consistent
g therefore l must inconsistent g e l g since l must
action precondition l effect l otherwise l would hold
performing action would preconditions l among would
conclude
next want one step plan reaching g whose
actions discussion see plan reaching g
r



fireachability relevance resolution

contains action changing value every proposition l holds
inconsistent g clearly none actions effect
inconsistent g let denote set actions applying
transform literals inconsistent g value g destroy
value literal consistent g since constitutes valid plan e
actions interfere achieves g definition
conclude proof base step must subset c
suppose contrary subset c seen
set actions l
precondition action l consistent g destroyed
denote set consisting noop corresponding l
preconditions element definition
however c c implies contains interfering actions
claim impossible first effects g consistent
g construction addition preconditions therefore
actual state world cannot contain con icting literals hence

c
next suppose established inductive hypothesis let
us prove holds hence let state exists mstep plan attaining g let denote state obtained applying
know
step plan achieving g

inductive hypothesis satisfies conditions theorem particular know
subset c complete proof would
sucient reachable one step plan whose actions
c proof similar base case
r













corollary initial state goal reachable minimal
number operators plan p steps numbered backwards
reaching goal c contain subset










proof inspection proof previous theorem shows every step

found subset set actions candidate plan satisfied
relevant conditions particular consider minimal plan elements must satisfy
conditions

lemma context linear encoding unless single safe final action
unit propagation yields less relevance information relevant

initially unit clauses goal literals resolve effect
axioms would yield negation actions e unsafe actions
negated action literals resolved action disjunction axiom class
however one safe final action obtain unit clause
disjunction nothing farther information
easily obtainable relevant


fibrafman

lemma context

graphplan encoding action changing value every literal unit propagation yields less relevance information
relevant

proof see text prior lemma
appendix b complexity reachable k relevant k

computational complexity reachable k njajjlj e njljjaj n
number levels generate jaj number possible actions jlj size
propositional language used e maximal number actions particular
shared effect explain complexity dominated time required
produce sets c c
set possible effects produced jaj steps maximal
number effects
c requires examining l tuples elements l k
jlj elements tuple set actions produce
done quickly provided maintained pointers actions number
sets actions e since k actions needed
set actions must check whether subset member c given
appropriate representation c done time jaj accomplish
use binary tree whose leafs correspond bit vectors depth tree
jaj size jc j finally need maintain c similar tree bitvectors done jlj c small lower cost overall cost
producing c jlj je j jaj
produce set go actions check whether preconditions
appear requires jaj steps assuming bit vector representation
maximal number preconditions action check
whether preconditions appear c since ja j jaj check whether
subset set preconditions appears c time jlj requires jajjlj
steps
finally need produce c requires generating subsets size
k less taking jaj steps subset must check whether preconditions contain element c provided appropriate data structure c
maintained done jlj set preconditions case
c assumed c maintained tree bit vectors generated time
jaj overall complexity step jljjaj
note small values k data structures likely provide better performance
next address relevant k analysis assumption
set variables appear preconditions effects operator noted
transforming set operators satisfy property set operators
satisfy may cause exponential blow worst case
complexity relevant k jaj jlj jlj jaj jaj number
actions jlj number proposition language maximal number
k



k

k





e



e



k

k









k

k





k





p



p











k







k

k

k

k

k

k
p

p



fireachability relevance resolution

preconditions action analysis quite similar case reachable k
ignore sets r subsets larger whose generation
contributes constant factors
set preconditions produced jaj steps
compute c iterate jlj sets literals set examine
sets actions preconditions sets
set actions need check c check
performed jaj steps overall complexity step jlj jaj
produce set go actions useful require jlje
e maximal number actions particular effect action
check whether effects c since need perform check
every action overall complexity jlje jljjaj
finally need produce sets c interfering actions pre computed
cost amortized steps case computation requires

mjaj steps maximal sum preconditions effects action
next examine effects l tuples actions l k see whether
effects subset c takes jaj jlj steps
small values k particular k tighter analysis possible
r










p

k



k
p



k



k
p







k



references

bayardo r j schrag r c csp look back techniques solve real world
sat instances proc aaai pp
blum furst l fast graph analysis artificial
intelligence
bonet b loerincs g geffner h robust fast action selection mechanism
proc aaai pp
boutilier c brafman r geib c structured reachability analysis markov
decision processes proc th conference uncertainty ai pp
boutilier c dearden r abstractions decision theoretic
time constraints proc aaai pp
brafman r reachability relevance resolution satisfiability
ijcai pp
brafman r hoos h h encode encode linear
ijcai pp
brafman r simplifier propositional formulas many binary clauses
tech rep dept computer science ben gurion university
crawford j auton l experimental cross point
satisfiability proc aaai pp


fibrafman

davis putman h computing procedure quantification theory journal
acm
b srivastava b kambhampati investigating effect relevance
reachability constraints sat encodings proc fifth intl
conf ai scheduling systems
ernst millstein weld automatic sat compilation
proceedings international joint conference artificial
intelligence
fikes r nilsson n strips application theorem
proving solving artificial intelligence
freeman j w improvements propositional satisfiability search
ph thesis u pennsylvania dept computer information science
genesereth r nilsson n j logical foundations artificial intelligence
kaufmann los altos ca
gomes c p selman b kautz h boosting combinatorial search
randomization proc th nat conf ai pp
haslum p geffner h admissible heuristics optimal proc
fifth intl conf ai scheduling systems pp
kambhampati parker e lambrecht e understanding exending graphplan proc th european conf pp
kautz h selman b satisfiability proc th european
conf ai pp
kautz h selman b pushing envelope propositional logic
stochastic search proc th national conference ai aaai pp

kautz h selman b unifying sat graph proc
th intl joint conf ai ijcai pp
li c anbulagan heuristics unit propagation satisfiability
proc ijcai
mcdermoot heuristic estimator means ends analysis proc
rd int conf ai systems pp
nebel b dimopoulos koehler j ignoring irrelevant facts operators
plan generation proc th european conf




