journal artificial intelligence

submitted published

attribute
consequences least common subsumer

ralf kusters

kuesters ti informatik uni kiel de

institut f
ur informatik und praktische mathematik
christian albrechts universit
zu kiel
kiel
germany

alex borgida

borgida cs rutgers edu

department computer science
rutgers university
piscataway nj
usa

abstract

functional relationships objects called attributes considerable importance knowledge representation languages including description logics dls study
literature indicates papers made often implicitly different assumptions
nature attributes whether required value whether
partial functions work presented first explicit study
difference subclasses classic dl involving concept constructor
shown although determining subsumption concept descriptions
complexity though requiring different story different case
determining least common subsumer lcs attributes interpreted partial
functions lcs exists computed relatively easily even case
correct extend three previous papers lcs dls case attributes
must value lcs may exist even exists may exponential size
interestingly possible decide polynomial time lcs exists
introduction

knowledge representation systems description logics dls subject continued attention artificial intelligence subject theoretical studies
borgida baader baader sattler giacomo lenzerini calvanese giacomo lenzerini b applications artale franconi guarino
pazzi brachman mcguinness patel schneider borgida mcguinness
patel schneider impressively dls found applications areas involving information processing databases borgida calvanese lenzerini
nardi semi structured data calvanese giacomo lenzerini
information integration calvanese giacomo lenzerini nardi rosati borgida
kusters well general configuration mcguinness
wright software engineering borgida devanbu devanbu jones
fact wherever ubiquitous term ontology used days e g pro c ai access foundation morgan kaufmann publishers rights reserved

steres borgida
ku

viding semantics web xml documents dls prime contenders
clear semantics well studied computational properties
description logics one takes object centered view world modeled
individuals connected binary relationships called roles grouped classes
called concepts familiar predicate logic objects correspond
constants roles binary predicates concepts unary predicates every dl system
concepts application domain described concept descriptions built
atomic concepts roles constructors provided dl language
example consider situation want concept describing individual cars
frequent least repairs record fact cars model
manufacturer model concepts thought built
possibly nested simpler noun phrases concept called lemon sequel
might captured conjunction
objects cars
things whose model values concept model
things whose madeby values concept manufacturer
things whose model value model madeby attribute
things least repairs values
things whose repairs values repairreport
syntax classic language abbreviate emphasizing
term nature descriptions constructors used
car
model model
madeby manufacturer
model madeby model
least repairs
repairs repairreport
example concept term least n p constructor least denotes
objects related relationship p least n objects turn p
c instances exactly objects related p instances c
finally present concept mathematical notation succinct
preferred formal work dls
lemon car u
model model u
madeby manufacturer u
madeby model madeby u
repairs u
repairs repairreport

unlike preceding formalisms semantic networks frames quillian minsky
dls equipped formal semantics given translation


fiwhat attribute

first order predicate logic borgida example moreover dl systems provide
users inference capabilities allow deduce implicit knowledge
explicitly represented knowledge instance subsumption allow one
determine subconcept superconcept relationships c subsumed c v
instances c instances e first description interpreted
subset second description example concept car obviously subsumes
concept description lemon least repairs subsumed least repairs
traditional inference dl systems subsumption inconsistency
detection membership checking well investigated detailed
complexity realizing inferences available variety dls differing
expressive power see e g baader sattler overview
least common subsumer

least common subsumer lcs concepts specific concept description subsuming given concepts finding lcs first introduced inference
dls cohen borgida hirsh one motivation considering lcs
use alternative disjunction idea replace disjunctions c c
lcs c c borgida etherington call operation knowledge base
vivification although general lcs equivalent corresponding disjunction
best approximation disjunctive concept within available language
approximation motivated fact many cases adding disjunction
would increase complexity reasoning
proposed baader et al baader kusters baader kusters molitor
lcs operation used support bottom construction dl knowledge bases roughly speaking starting typical examples lcs
used compute concept description contains examples ii
specific description satisfying property baader kusters presented
cyclic aln concept descriptions aln relatively simple language allowing concept conjunction primitive negation value restrictions number
restrictions baader et al proposed lcs dl allowing
existential restrictions instead number restrictions
originally lcs introduced operation context inductive learning
examples cohen et al several papers followed lead dls
considered mostly sublanguages classic allowed equalities e
expressions madeby model madeby cohen et al proposed lcs
aln language allows concept conjunction
call extended cohen hirsh coreclassic additionally allows value restrictions see cohen hirsh b
experimental finally frazier pitt presented lcs full
classic
n

n

observe language already allows disjunction lcs c cn c cn
particular means languages lcs really interest



steres borgida
ku

total vs partial attributes

knowledge representation systems including dls functional relationships
called attributes called features literature distinguished subclass
general relationships least part functional restrictions occur frequently
practice example clearly madeby model meant attributes
thus making unnecessary number restrictions madeby least
madeby addition distinguishing attributes helps identify tractable subsets dl
constructors classic coreferences attribute chains examples
reasoned eciently borgida patel schneider changed
roles e g allowed repairs ownedby repairspaidfor subsumption becomes undecidable schmidt schau
whereas distinction roles attributes dls theoretically
practically well understood discovered another distinction namely one attributes interpreted total functions total attributes interpreted
partial functions partial attributes slipped cracks contemporary
total attribute value world even
know knowledge base currently partial attribute may value
distinction useful practice since difference car possibly
necessarily cd player car necessarily manufacturer
may known current knowledge base latter modeled defining
attribute madeby total attribute note madeby total attribute
every individual world discourse cars must filler madeby
since however structural information provided fillers madeby non car individuals implications drawn fillers trivial thus making madeby total
attribute seems reasonable case car cd player hand
modeled partial attribute express fact cars required cd
player indicate particular car cd player one would add
description least cdplayer


mentioned conjunction constructor roles attributes
behave differently respect subsumption main objective
distinction total partial attributes induces significantly different
behaviour computing lcs presence precisely purpose
twofold
first respect complexity deciding subsumption
difference partial total attributes borgida patel schneider
shown attributes total subsumption classic concept descriptions
decided polynomial time shown present work slight modifications
proposed borgida patel schneider suce handle partial attributes
readers coming machine learning community aware difference
attributes functional roles attributes components input feature vector
usually describes exemplar



fiwhat attribute

moreover modifications change complexity thus partial
total attributes behave similarly subsumption point view
second surprising distinction
partial total attributes significant impact computing
lcs previous sublanguages classic partial attributes used
lcs two concept descriptions exists computed polynomial time
however total attributes involved situation different lcs need
longer even exist case exists size may grow exponential size
given concept descriptions nevertheless existence lcs two concept descriptions
decided polynomial time
specifically previous work cohen et al cohen hirsh frazier
pitt concerning lcs computation classic constructions proofs
made without realizing difference two types attributes without going
details main lcs merely finite graphs employed
making constructions applicable partial attribute case addition fixing
presents proper handling inconsistent concepts
lcs classic presented frazier pitt
although subsumption intriguing proofs
lcs make extensive use corresponding subsumption
one reason present beforehand
returning general differences cases total partial attributes
one could say fundamental cause differences lies constructor
whose semantics normally requires two chains attributes value
ii values coincide case total attributes obeys principle
c v u v implies c v u w v w
u v w sequences total attributes e g madeby model condition
ensured total aspect attributes case partial attributes
implication hold w hence u w longer guaranteed
value implying restriction may hold clearly implication affects
subsumption far lcs concerned certain graph representing lcs
two given concepts may infinite case total attributes thus jeopardizing
existence lcs
general significance knowledge representation language
designers users need explicitly check beginning whether deal total partial attributes choice significant effects although
situations total attributes convenient guarantee existence attributes without
resort number restrictions drawbacks
things considered requiring attributes total appears less desirable concerning classic technical support use partial attributes
ensure existence lcs computation polynomial time
well ecient decision subsumption moreover current implementation
classic subsumption require major changes order handle partial
attributes


steres borgida
ku

outline follows following section basic notions necessary investigations introduced two subsequent sections subsumption lcs computation classic partial attributes investigated precisely
section offer subsumption sublanguage classic classic
contains main classic constructors section present lcs
classic concept descriptions along lines proposed cohen hirsh
formally prove correctness thereby resolving shortcomings previous
lcs handle inconsistencies properly finally section covers
central e lcs computation presence total attributes
section restrict investigations sublanguage classic order
concentrate changes caused going partial total attributes nevertheless
strongly conjecture proved section easily extended
classic classic similar techniques one employed two previous
sections
formal preliminaries

section introduce syntax semantics description languages considered formally define subsumption equivalence concept descriptions
finally least common subsumer concept descriptions specified
definition let c r disjoint finite sets representing set concept names
set role names set attribute names set classic concept
descriptions c r inductively defined follows
every element c concept description concept name car
symbol concept description top concept denoting universe
objects
r r role n nonnegative integer n r n r concept
descriptions number restrictions repairs
c concept descriptions c u concept description concept
conjunction




c concept description r role attribute
description value restriction madeby manufacturer

r c

concept

k h non negative integers b b attributes
b b concept description equality madeby
model madeby note two sequences may empty e k h
empty sequence denoted
k



k

h

h

often dispense composition attributes example sequence
simply written moreover use r r c abbreviation
r r r c c case n denotes c
usual semantics classic defined model theoretic way means
interpretations
k

n

k

n



fiwhat attribute

definition interpretation consists nonempty domain interpretation
function interpretation function assigns extensions atomic identifiers follows





extension concept name e subset e domain
extension role name r subset ri

extension attribute name partial function ai e
x ai x ai
given roles attributes r use r r denote composition binary
relations ri n denotes identity relation e
f j g individual define ri fe j e ri g r
attributes say r r defined iff r r occasionally
refer r r image r r
extension c concept description c inductively defined follows



n





n

n

n

n

n r fd j cardinality fe j e ri g ng
n r fd j cardinality fe j e ri g ng
c u c di
r c fd j ri c g r role attribute
b b fd j b b defined
b b g
note definition attributes interpreted partial functions since
main point demonstrate impact different semantics attributes
occasionally restrict set interpretations map attributes total
functions interpretations called interpretations attributes interpreted
way called total attributes order distinguish partial ones
stress remarked introduction definition b b
b b must defined order satisfy restriction
although standard semantics equalities one could think
relaxing restriction example condition might specified hold
paths undefined images defined identical values
third definition might satisfied even one paths undefined
definitions semantics might lead different however
pursue standard semantics
subsumption relationship concept descriptions defined follows
definition concept description c subsumed concept description c v
short interpretations c di consider total
interpretations get subsumption c v iff c di interpretations






k

h

k

h

k

h

k

k

h





h

steres borgida
ku

defined subsumption equivalence concept descriptions defined usual way
c v v c equivalence c specified analogously
already mentioned introduction main difference partial total
attributes respect subsumption u v v u w v w holds attribute
chains u v w whereas necessarily case u v v u w v w
finally introducing lcs operation formally concluding section
comment expressive power classic since syntactically classic lacks
common constructors although classic introduced contain bottom
concept explicitly expressed e g r u r use
abbreviation inconsistent concept descriptions furthermore primitive negation e
negation concept names simulated number restrictions concept name
e one replace every occurrence e r negation e e r
r role name finally attribute following equivalences hold
n n n n
lose expressive power allowing
number restrictions attributes still full classic somewhat expressive
classic mainly due introduction individuals called nominals
classic sake completeness give syntax full classic language
requires set representing set individual names define
two additional concept constructors
fe e g individuals e enumeration summer springg
p e role attribute p individual e fills currentseason summer
technical report kusters borgida extend presented
work full classic case individuals non standard semantics
least common subsumer set concept descriptions specific concept
subsuming concept descriptions set
definition concept description least common subsumer lcs concept
descriptions c c lcs c c short iff c v n ii
every property v analogously define lcs c c v
c





e

e

e





n

n





instead v

n



note lcs concept descriptions may exist definition
uniquely determined equivalence sense may refer lcs
following two sections attributes interpreted partial functions
section consider total attributes
characterizing subsumption

classic

section modify characterization subsumption classic proposed
borgida patel schneider handle case partial attributes
even omitting constructs dealing integers called host individuals
cannot roles act role attribute fillers



fiwhat attribute

detail tools used deciding subsumption intimately related
computation lcs
subsumption classic decided multi part process first descriptions
turned description graphs next description graphs put canonical form
certain inferences explicated redundancies reduced combining nodes
edges graph finally subsumption determined description
canonical description graph
order inherit proofs tried minimize necessary adjustments
specification borgida patel schneider reason roughly speaking
attributes treated roles unless form part equality note
attributes participating construct must values extent
allow us adopt semantics original description graphs crucial
proofs however two different occurrences attributes namely equality
vs role value restriction require us modify extend definition description
graphs normalization rules subsumption
following present steps subsumption detail start
definition description graphs
description graphs

intuitively description graphs ect syntactic structure concept descriptions
description graph labeled directed multigraph distinguished node roughly
speaking edges edges graph capture constraints expressed
equalities labels nodes contain among others set called r edges
correspond value restrictions unlike description graphs defined borgida
patel schneider r edges labeled role names attribute
names shall comment later advantage modification order deal
partial attributes r edges lead nested description graphs representing concepts
corresponding value restrictions
defining description graphs formally figure present graph corresponding
concept description lemon defined introduction use g manufacturer
g model well g repairreport denote description graphs concept names
manufacturer model repairreport graphs simple merely consist
one node labeled corresponding concept name general graphs
complex since value restriction r c leads possibly complex nested
concept description c
although number restrictions attributes allowed r edges labeled attributes model madeby restriction order capture
semantics attributes formally description graphs nodes edges defined mutually
recursively follows
definition description graph g tuple n e n l consisting finite set n
nodes finite set e edges edges distinguished node n n root graph
function l n set labels nodes occasionally use notation
g n odes g edges g root access components n e n graph g


steres borgida
ku

f g

madeby

f g

repairreport

g

madeby

repairs

model



model

g

model

fcar g


madeby

manufacturer

g

figure description graph lemon large node root graph
edge tuple form n n n n nodes attribute
name
label node defined tuple form c h consisting finite
set c concept names atoms node finite set h tuples r edges
node concept names description graph stand atomic concept names
occasionally use notation n atoms n redges access components c
h node n
r edge tuple r g consisting role attribute name r min
non negative integer max non negative integer
recursively nested description graph g graph g often called restriction
graph node role r require nodes g distinct nodes
g nested description graphs g r attribute require
f g

given description graph g node n g n odes define gj graph
n e n l gj said rooted n sequence p n n k
n n g edges k called path g node n n p g
short k path p called empty w called label p
empty path label p called rooted n root g occasionally write
n n g omitting intermediate nodes
throughout work make assumption description graphs connected
description graph said connected nodes graph reached
rooted path nested graphs connected semantics description graphs see
definition altered nodes cannot reached root deleted
order merge description graphs need notion recursive set nodes
description graph g recursive set nodes g union nodes g
recursive set nodes nested description graphs g
concept descriptions semantics description graphs defined means
interpretation introduce function assigns individual domain
every node graph ensures equalities satisfied
n

k

n







k

k

k

k

k



fiwhat attribute

definition let g n e n l description graph let interpretation
element gi iff total function n





n

n n ni
n n e n n ai
extension ni node n label empty set element ni




c h iff

l n

c b
r g h




n

b

elements domain

b g ri

ri

cohen hirsh defined semantics description graphs different way
avoiding introduction total function definition
however well defined acyclic graphs example excludes sameas equalities form spouse spouse even p p q
semantics graphs proposed borgida patel schneider similar
definition however edges captured equalities
value restrictions attributes still context partial attributes could
define semantics description graphs means total function since
attributes might fillers specifying semantics description graphs terms
partial mappings would make definition even longer furthermore proofs
borgida patel schneider would carry easily therefore order
keep total function value restrictions attributes initially translated redges next section present translation concept descriptions description
graphs detail
defined semantics description graphs subsumption equivalence description graphs e g h v g well concept descriptions description
graphs e g c v g defined way subsumption equivalence
concept descriptions
translating concept descriptions description graphs

following borgida patel schneider classic concept description turned
description graph recursive process process nodes description
graphs often merged
definition merge two nodes n n node n following label
n n label label n otherwise labels equal
n atoms n atoms n atoms n redges n redges n redges


steres borgida
ku

g n e n l g n e n l two description graphs disjoint
recursive sets nodes merge g g g g g n e n l defined
follows



n n
n n n fn g n fn n g
e e e n n n n e e union e e every occurrence



l n




n

n n substituted n

l n n n n fn g l n l n n n n fn g l n

defined label obtained merging n

n

classic concept description c turned corresponding description
g c following translation rules
turned description graph one node n edges atom
node set r edges empty
concept name turned description graph one node edges
atoms node contain concept name node r edges
description form n r turned description graph one node
edges node atoms single r edge r n g
g specified first translation rule
description form n r turned description graph one node
edges node atom single r edge r n g
description form b b turned graph pairwise
distinct nodes n n root n additional node
n n set edges consists n n n n n n
b b b e two disjoint paths coincide starting point n final point n note p first
path empty path n n q second path empty path
n n nodes atom r edges
description form r c r role turned description graph
one node edges node atom f g single r edge
r g c
description form c attribute turned description
graph one node edges node atom f g single
r edge g c work borgida patel schneider concept
description c turned edge already mentioned would cause
attributes interpreted partial functions defining semantics
means specified definition

graph

p

p

p

q

q

q

p

q



q

q

p

p

fiwhat attribute

turn description form c u description graph construct g c
g merge
figure shows description graph built way concept lemon example
easily verified translation preserves extensions
theorem concept description c corresponding description graph g c
equivalent e c g c every interpretation
main diculty proof theorem showing merging two description
graphs corresponds conjunction concept descriptions
lemma interpretations n n nodes n n ni ni

g g description graphs g g gi
g
proof preceding statement rather simple one borgida patelschneider
translating description graphs concept descriptions

although characterization subsumption require translating description
graphs back concept descriptions translation presented concept descriptions description graphs equivalent representations classic concept
descriptions subsequent sections fact need turn graphs concept descriptions
translation description graph g specified rather straightforward
recursive definition main idea translation stems cohen hirsh
employed spanning trees translate equalities spanning tree connected graph tree rooted node graph containing nodes
graph particular coincides graph except edges deleted
example one possible spanning tree g figure obtained deleting edge
labeled madeby whose origin root g
let g connected description graph spanning tree
corresponding concept description c obtained conjunction following
descriptions
c contains equality v v every leaf n v label
rooted path n ii equality v v edge
n n g edges contained v label rooted path
n
every node n c contains value restriction v c v label
rooted path n c denotes translation label n e c
conjunction obtained follows
every concept name atoms n conjunct c
every r edge r g n c contains number restrictions mr
r case r role b value restriction r c
c recursively defined translation g
g

g





g

n

n

n

n

n

g

g



steres borgida
ku

case set atoms r edges n empty define c
referring graph g figure c contains equalities model madeby
model madeby madeby model madeby furthermore n denotes root g
c value restrictions c model model madeby c
corresponds lemon defined introduction without equality note
although case equality model madeby model madeby
needed one cannot dispense construction illustrated following example without description graph g would turned
description equivalent since equality requires
path value may case
easy prove translation thus defined correct following sense
kusters borgida
n

g

n

g

n

lemma every connected description graph g equivalent translation c e
interpretations gi c
g

g

canonical description graphs

following occasionally refer marking node incoherent means
label node changed marking description graph incoherent means
description graph replaced graph g corresponding e graph
consisting one node label
one important property canonical description graphs deterministic
e every node one outgoing edge edge r edge labeled
attribute role name following borgida patel schneider order turn
description graph canonical graph need merge edges r edges addition
different work might necessary lift r edges edges
merge two edges n n n n description graph g replace
single edge n n n merging n n addition
replace n n n edges g
order merge two r edges r k g r k g replace r edge
r max min k k g g
lift r edge g node n concept graph g edge
n n remove n redges augment g adding g n odes g n odes
g edges g edges well adding n g root g edges precondition
applying transformation g corresponds graph
g reason precondition r edge form g lifted
without g inconsistent fact successors allowed lost normalization rule see guarantee precondition satisfied
description graph g transformed canonical form exhaustively applying
following normalization rules graph called canonical none rules
applied
node g marked incoherent mark description graph incoherent
reason even node root attributes corresponding edges must
















fiwhat attribute

value since participate equalities value cannot belong


r edge node min greater max mark node incoherent
reason


add atoms every node absent
r edge node restriction graph marked incoherent change max
reason

r edge node max mark restriction graph incoherent
reason see
r edge form r g g contains one node empty
set atoms atoms set f g r edges remove r edge
reason

node two r edges labeled role merge two edges
described reason


description graph two edges node labeled
attribute merge two edges described reason


node graph edge r edge attribute
lift r edge precondition satisfied see reason value
restrictions imposed attributes participate equalities must made explicit
gathered one place similar previous cases
need transformations canonical form change semantics
graph main diculty showing merging processes lifting
preserve semantics difference borgida patel schneider
addition merging r edges edges need lift r edges therefore
omit proofs showing merging edges preserves extensions proofs
following two lemmas routine quite similar one lemma
lemma let g n e n l description graph two mergeable edges let
g n e n l merging two edges g g
empty set



r u



r

r

r

r

r c u r r c u

c u

c u

lemma let n node two mergeable r edges let n node
edges merged ni n every interpretation
lemma let g n e n l description graph node n edge n n
suppose n associated r edge g provided precondition lifting
r edges satisfied g n e n l transformation
g g
proof sucient gij g ij since label n changed g


n obtains additional edge points graph g connected
n

n





steres borgida
ku

repairreport

g

fmodel g


model

repairs

model



fcar g


madeby

fmanufacturer g


figure canonical description graph lemon left node root
rest g w l g therefore may assume n root g e n n let
gi thus function n specified definition
individual e n e n e ai implies e gi hence
exists function g n odes g e satisfying conditions
definition since sets nodes g g disjoint define
union e nodes g
nodes g since construction additional edge n g root e
n g root ai follows conditions definition satisfied
g thus g
let g thus function n according definition
let e g root n let g description graph obtain g
deleting nodes corresponding g graph g without r edge
g restrict nodes g follows g furthermore
restricting nodes g yields e gi particular g marked
incoherent precondition ensures thus since e successor
conclude gi
ut


























dealt issue merging lifting easy verify normalization affect meaning description graphs
theorem g description graph g corresponding canonical description
graph g g

example canonical description graph graph given figure depicted
figure
subsumption

final part subsumption process checking see canonical description graph
subsumed concept description borgida patel schneider
attributes total turns necessary turn potential subsumer
canonical description graph subsumption presented next
considered characterization subsumption


fiwhat attribute

subsumption given concept description description graph g n e n l subsumes g defined true one
following conditions hold
description graph
















g

marked incoherent

concept name element atoms n

n r r edge n r role min greater equal
n ii n

n r r edge n r role max less equal n


b b

rooted paths label
g ending node


n







n



b

b



r c role r r edge n r role g
restriction graph subsumes c g ii subsumes c g reason
r
c attribute edge g form n n
subsumes c n e n l ii r edge n attribute g
restriction graph subsumes c g iii subsumes c g









e u f subsumes e g subsumes f g true

two differences one total attributes presented borgida patel schneider see first partial attribute
case given c one needs look value restriction edge
r edge g since attributes label edges r edges total attribute
case attributes label edges examining r edges necessary
second important distinction treatment equalities shown
b b one needs check whether
exist two paths labeled v w b b leading node g
total attribute case however suces exist prefixes v w v w
property long remaining suxes identical
soundness completeness stated following theorem
theorem let c classic descriptions c v iff subsumes g
g canonical form g c
soundness subsumption e direction theorem stated
pretty obvious borgida patel schneider main point
direction proof completeness canonical graph g deterministic
e node given role attribute name r one outgoing r edge
edge r label point reader borgida patel schneider
proof since almost identical one total attributes already published
proofs reveal direction theorem description graphs need
normalized thus one
n



n



c

c

c



steres borgida
ku

remark let g necessarily normalized description graph let
concept description subsumes g implies g v





classic

borgida patel schneider argue canonical description graph g concept
description c constructed time polynomial size c furthermore runs time polynomial size g hard see
changes presented increase complexity thus soundness completeness
subsumption provides us following corollary
corollary subsumption classic concept descriptions c attributes
interpreted partial functions decided time polynomial size c

computing lcs

classic

section lcs two classic concept descriptions stated
terms product canonical description graphs similar proven
cohen hirsh sublanguage classic allows concept
names concept conjunction value restrictions equalities particular
sublanguage allow inconsistent concept descriptions example
expressed con icting number restrictions furthermore semantics description
graphs provided cohen hirsh restricts case description graphs
acyclic excludes example equalities form spouse spouse
following first define product description graphs
given concept descriptions c lcs equivalent description graph obtained
product g g constructions proofs quite close
cohen hirsh
c



product description graphs

description graph represents constraints must satisfied individuals
extension graph intuitively product two description graphs intersection
constraints product finite automata corresponds intersection
words accepted automata however definition product description
graphs special care taken incoherent nodes e nodes labeled
since attributes may occur r edges edges one needs take product
restriction graphs r edges one hand original graphs g g
rooted certain nodes hand
definition let g n e n l g n e n l two description graphs
product g g g n e n l two graphs recursively defined
follows




n n
n n n
e f n n j n e n e g
n



fiwhat attribute

let n n n n l n let l n n l n analogously
l n l n n l n otherwise l n h l n
h define l n n h

b











j r p q g h r p q g h g
f g g j n e p q g h g
f g g j p q g h n e g
h







f r min p p max q q g g


j









j



according definition tuple n n node say n incoherent
label n n coincides one n reason defining label
way lcs c c every concept description c overlooked
frazier pitt thus making constructions proofs hold concept
descriptions contain inconsistent subexpressions
note g defined might connected e might contain nodes
cannot reached root n even g g connected happen
tuples n n belong set nodes g regardless whether
reachable root however already mentioned section may
assume g connected
note product graph translated back classic concept
description since product two description graphs description graph
computing lcs

prove main theorem subsection states product two
description graphs equivalent lcs corresponding concept descriptions
theorem let c c two concept descriptions let g g corresponding
canonical description graphs c lcs c c
g

g

let g g g sketch proof showing c subsumes c
symmetry c see kusters borgida details construction
two rooted paths common node g g corresponding paths leading
node well thus theorem equalities c subsume ones
c let spanning tree g node g v label
rooted path construction follows exists rooted
path g labeled v furthermore rather straightforward inductive proof shows
concept description e corresponding label subsumes g j
implies v e w g conclude g w g
interesting part proof c common subsumer
c c least common subsumer
induction size c c subsumes c
c subsumes c distinguish different cases according definition
subsumes let g n e n l canonical description graph c g
n e n l canonical description graph c g n e n l g g
following assume c v c v thus subsumes g
proof

g

g



g

g



steres borgida
ku

g subsumes g remark implies g v
thus c v note one cannot use theorem since g might canonical
description graph
g incoherent nothing
concept name number restriction definition label
n easy see subsumes g
v w exist nodes g g two
paths n label v w respectively well two paths n
label v w definition g easy see two
paths n n n label v w respectively shows
subsumes g
r c r role attribute one several cases applies
n n r edges role attribute r restriction graphs g g
respectively subsumes c g subsumes c g
ii without loss generality n edge pointing attribute r
subsumes c g g g j n r edge restriction
graph g subsumes c g
cases ii subsumes c g g follows induction furthermore
definition g r edge role r restriction graph g g n
implies subsumes g
iii n n edges attribute r leading nodes respectively subsumes c g j subsumes c g j induction know
subsumes c g j
g j easy see gj
g j fur g j
thermore definition edge attribute r n n
g shows subsumes g
iv without loss generality n r edge edge role attribute
r implies subsumes c g ensures subsumes g
e u f definition subsumption subsumes e g
subsumes e g hold induction subsumes e g analogously
subsumes f g thus subsumes g
ut
stated section canonical description graph classic concept description
computed time polynomial size concept description hard
verify product two description graphs computed time polynomial
size graphs addition concept description corresponding description
graph computed time polynomial size graph thus consequence
theorem obtain
subsumes
g

















corollary lcs two classic concept descriptions exists computed time polynomial size concept descriptions


fiwhat attribute

j j

j j













figure canonical description graph without node labels


intimated cohen et al statement hold sequences concept
descriptions intuitively generalizing lcs sequences say n concept descriptions means computing product n description graphs following proposition
shows size product graph may grow exponentially n thus lcs
computed way grows exponentially size given sequence however
imply exponential blow unavoidable might exist smaller
still equivalent representation lcs nevertheless exponential
growth inevitable
proposition integers n exists sequence classic
concept descriptions size every classic concept description equivalent
lcs least exponential n size linear n
proof cohen et al given n define concept descriptions
follows
u u u u


n

n







j

j



j







j





denote attributes canonical description graph depicted
figure easy see v v w iff number v
number w equal modulo v w words fa g
implies
v v w
iff n number v


number w equal modulo
let f ng non empty set define v k
elements w k let e lcs
let g corresponding canonical description graph root n
know e v v w every f ng implies
paths n g labeled v w exist lead node q
assume non empty subsets f ng q q would
imply e v v v contradiction thus implies q q since
non empty subsets f ng shows g contains least nodes
fact size g linear size e completes proof
ut
proposition shows computing lcs sequences necessarily worstcase exponential conversely polynomial time binary lcs
operation exponential time easily specified employing following
identity lcs lcs lcs lcs lcs
n









n

n













n





j



j

j

k

j

e





e















n

e

e

n

n

n







n

steres borgida
ku

corollary size lcs sequences classic concept descriptions grow
exponentially size sequences exists exponential time
computing lcs
lcs total attributes

previous sections attributes interpreted partial functions section
present significant changes computing lcs occur considering
total functions instead partial functions precisely look sublanguage
classic allows concept conjunction equalities
general assumption attributes interpreted total functions
restrict attention language order concentrate changes
caused going partial total functions strongly conjecture however
represented easily transfered classic extending description
graphs section
first lcs two concept descriptions exist
present polynomial decision existence lcs two
concept descriptions finally shown lcs two concept descriptions
exists might exponential size given concept descriptions
computed exponential time
sequel simply refer lcs lcs since throughout section
attributes assumed total lead confusion
may useful keep mind total though partial attributes
u v v u w v w u w v set finite words
finite set attribute names indeed differences partial
total attributes shown section finally trace back property










existence lcs

subsection prove lcs two concept descriptions
exist nevertheless infinite representation lcs used
next subsection characterize existence lcs
accomplish return graph characterization subsumption
proposed borgida patel schneider modified partial attributes section concept description c let g denote corresponding canonical description
graph defined section semantics specified section although
set interpretations restricted allow attributes interpreted total functions

since contains concept names allow value restrictions nodes
g contain concept names set r edges empty therefore g
defined triple n e n n finite set nodes e finite set
n n n root graph
corollary borgida patel schneider subsumption c v
concept descriptions c decided following
provides us characterization subsumption
c

c

c





fiwhat attribute

g

c



c

g




b

b




c

figure canonical graphs c
let c concept descriptions g n e n canonical
description graph c subsumes g defined true one
following conditions hold
c





c

v w words v w u v v u w w u
rooted paths g labeled v w respectively ending node



c

subsumes g true
apart additional constructors handled differs
total attributes considered sucient prefixes
rooted paths v w lead common node long remainder cases
path




u subsumes g


c



c

theorem concept descriptions lcs concept descriptions exist

corrects statement cohen et al lcs exists
statement inadvertently assumed attributes partial total
proof offer following concept descriptions shown
lcs
c b
ac u b bc u ad bd
graphs concepts depicted figure
following statement shows lcs e c would satisfy condition
regular structure statement easily verified

e v v w
iff v w exists nonnegative integer n u
v ac du w bc du vice versa
given description lcs c one employing finite description graph equivalent e however omit
elementary proof absence lcs follows theorem
infinite graphs used characterize existence lcs note partial
attribute case lcs c equivalent u b b


n



n

steres borgida
ku

obtained lcs presented previous section corresponding finite description graph consists root two additional nodes root two
outgoing edges leading two nodes labeled b respectively
state theorem first introduce infinite description graphs
exists infinite description graph representing lcs two concept descriptions
infinite description graph g defined finite graph triple n e n
except set nodes n set edges e may infinite finite case
nvn g means g contains path n n labeled word v
semantics infinite graphs defined finite case furthermore infinite graphs
translated concept descriptions follows take infinite spanning tree g
finite case every edge g contained add c equality
note contrast partial attribute case c need contain equalities
form v v since total attributes v v still c might concept description
infinite number conjuncts thus infinite concept description semantics
concept descriptions defined obvious way analogously lemma one
infinite graph g corresponding infinite concept description c
equivalent e c g
call infinite description graph g deterministic every node n
g every attribute exists one successor n g graph
g called complete every node n g every attribute least
one successor n g clearly deterministic complete infinite description
graph every path uniquely determined starting point label
deals finite description graphs g generalized deterministic complete infinite description graphs g straightforward way see
first note finite description graph coming concept description
canonical iff deterministic sense introduced analogously deterministic
infinite graph viewed canonical thus requiring infinite graphs
deterministic satisfies precondition addition graphs
complete unlike condition stated subsumption longer
necessary consider prefixes words complete graph contains rooted path
every word precisely v w lead node case
v v u w w u well thus making unnecessary consider prefixes v w
v w respectively summing conclude
corollary let g n e n deterministic complete infinite description
g

g

g

g

g

c

graph

v w


gv v w
iff


n vn

g n wn g node n

shall construct infinite graph representing lcs two concept descriptions
product called completed canonical graphs infinite representation
lcs used later characterize existence lcs e existence
finite representation lcs
define completion graph intuitively graph completed iteratively
adding outgoing edges labeled attribute every node graph
outgoing edge process might extend graph infinite trees
example completion g cf figure depicted figure fa b c dg
c



fiwhat attribute

g


c








c

c

b

b







b

c





b

c





figure complete graph c
formally completions defined follows let g infinite description graph
graph g extension g every node n g every attribute
n outgoing edges labeled node added well edge
n let g g g sequence graphs g g g
extension g g n e n

g
n
e n
n



n














construction g






called completion g
complete graph furthermore

g deterministic g deterministic well finally easy see graph
extension sare equivalent thus induction g g
nodes n e nodes g g called tree nodes
nodes g called non tree nodes construction every tree node g
exactly one direct predecessor g e exactly one node n one attribute
n edge g n called predecessor furthermore
exactly one youngest ancestor n g tree node g n youngest ancestor
path n g contain non tree nodes except n
note one path n g finally observe non tree nodes
non tree nodes ancestors
note completion canonical description graph complete deterministic
sequel let c two concept descriptions g n e n g
n e n corresponding canonical graphs g g completions
g g products g g g g
g g specified definition
usual may assume g g connected e contain nodes
reachable root n n otherwise one remove nodes cannot
reached root without changing semantics graphs
denote product g g g instead g g otherwise
graph could confused completion g general graphs






c



c





c



c

c



c



c







c



c

c



steres borgida
ku

coincide example take products g g g g see figure
graphs g g former product graph consists root
two outgoing edges one labeled one labeled b mentioned
graph corresponds lcs c partial attribute case product
completed graphs hand graph obtained completion
graph depicted figure infinite trees omitted sake simplicity
easy consequence fact g g corollary one prove
following lemma
c

lemma

c



c

c

c





c

v v w iff n


c

vn

g n
c

c

wn

g node n g
c

c

construction g know
proposition c v
node n g



v

w v v w iff n


c

g n

nd vn

c



nd wn

g

particular g represents lcs concept descriptions c following
sense
corollary infinite concept description c corresponding g lcs c
e c v c ii c v e implies c v e every concept
description e
g





g



g

characterizing existence lcs

let c concept descriptions let graphs g g g g g g
defined
g represents possibly infinite lcs concept
descriptions c corollary g used characterize existence
finite lcs existence depends whether g contains finite infinite number
called nodes
definition node n infinite description graph h called node
c

exist two direct predecessors
may labeled differently



n



h



edges leading

c

c

c








b







c

c

c

figure subgraph g g
c





c

n



nodes

fiwhat attribute

example graph depicted figure contains infinite number nodes
sucient necessary condition lcs c
exist
helpful observe nodes g one forms g f f
f g f non tree nodes tree node cannot exist
node form tree nodes since tree nodes
exactly one direct predecessor thus moreover g
infinite number nodes must infinite number nodes
form f f exist finite number nodes g form
g f reason following lemma characterize nodes
form f nodes form f dealt analogously state lemma
recall n un vn h graph h describe path h labeled uv
n n passes node n u e n un h n vn h
generalized obvious way interpret n u n u n u n h
g



nc nd
v

w

h p

x

h p

g








v
h

w
h


x

e q

e q


e



e


n

f

figure nodes g
lemma given node f g tree node g node n f g
node iff
c






exist nodes h p h p g h h
exist nodes e q e q g e e distinct nodes g
q node g
exists attribute v w x v w set attributes
c
c







n

c





n


direct successors h p h p h p

nd v h p x e q f

c



nd w h p x e q f

paths g see figure
h p paths addition require p tree node g


note since g
deterministic successors h p h p two paths must fact
form p



steres borgida
ku

direction obvious proceed direction assume
node g let p uniquely determined youngest ancestor
g particular p node g exists p xq g
x successor p path tree node g
since n node reached via q attribute
must exist e e g e e e q f e q f g since g
connected paths n n e q e q every path n q
must pass p sux label path x consequently exist
nodes h h g h p x e q f h p x e q f paths
g particular xa label path h f g label xa
consists attributes contained c h h together fact g
deterministic would imply e e hence h h let v w labels paths
n n h p h p respectively g deterministic h h
follows v w
ut
main section stated next theorem direct consequence
theorem obtain exists lcs concept descriptions c
example
proof
n









c

c





c

c

c

c



theorem lcs c exists iff number nodes g finite

start proving direction purpose assume g
contains infinite number nodes finite lcs c

argued may assume g contains infinite number nodes
form f f tree node f non tree node precisely
say g contains every nodes n f f node g
tree node g according lemma every node n exist nodes
h h e e g p g q g well x
properties required lemma
since g g finite description graphs number tuples form
h h e e f finite thus must infinite number yielding
tuple h h e e f particular h h e e nodes g
infinite number nodes form n f finally
lemma let v w label paths g n n h p h p
assume lcs e c according corollary e c
let g finite canonical graph e root n proposition lemma
know e v vx wx follows words v w u
vx v u wx w u paths g starting n labeled v
w lead node g
u u u word u ensures e v vx wx
however lemma know words vx wx lead different nodes
g
namely e q e q proposition leads contradiction
e g
v vx wx thus u
every exists node q g n vx aq n wx aq
paths g g finite description graph exist j j
proof









c











c

c































c



c







g

e











e

e



















e





e



e









fiwhat attribute

q implies e v vx wx hand path
starting n n label vx leads node n one wx leads
n since n n proposition implies e v vx wx contradiction
sum shown exist lcs c
shows lcs c completes proof
direction
prove direction theorem purpose assume g
finite number nodes note every node g
finite number direct predecessors see two cases distinguished node
form g g g predecessors g ii tree node g non tree node
predecessor g g form g unique predecessor
tree non tree node g non tree node since number nodes g
g finite cases finite number predecessors
spanning tree g coincides g except finite number edges
contain certain edge edge leads node c
concept description finite conjunction equalities finally
corollary shows c lcs c
ut
v w conjunct c v w lead root g node
mentioned nodes form f g f f tree
node f g non tree nodes consequently v w must paths g g
thus contain attributes occurring c
qi

g


j



c

j







j





j





j

j

c



g

g

g

c



corollary lcs two concept description c exists
concept description containing attributes occurring c equivalent
lcs

therefore asking existence lcs w l g assume set
attributes finite fact used following two subsections
deciding existence lcs

following corollary derive desired decision existence
lcs two concept descriptions state corollary need introduce
language l c q q fw j path node q q g labeled wg
since description graphs viewed finite automata language regular
moreover let aa denote set faw j w ag attribute finite
alphabet
g

c

corollary g contains infinite number nodes iff
exist nodes h p h p g well nodes f e e g attributes
b
c



h

h e e



p

b successor g



e f e f edges g



c




steres borgida
ku





lgc h e

l c h e ba infinite set words
g


ii statement r oles c



switched

first prove direction assume g contains infinite number
nodes w l g configuration g described proof
theorem configuration satisfies conditions stated corollary
j words x x coincide conclude n n g
deterministic graph however definition n n hence x x finite
w l g assume x b first letter fixed b thus
condition satisfied well according configuration b successor p
g
form p p tree node thus p b successor
g means condition satisfied
prove direction corollary purpose let bx l c h e
l c h e ba since p b successor g follows tree nodes
g p bxtat g thus h p bx e f g



h p bx e f g since e e conclude e e means
f node analogously l c h e l c h e ba
tree nodes g p bysas g f node g
since bx start b b successor p g tree node x
implies hence f f distinct nodes shows
set l c h e l c h e ba infinite g must infinite number
nodes
ut
given nodes h p h p g attributes b nodes f e e g conditions corollary obviously checked time polynomial size
concept descriptions c last condition note automaton accepting
language l c h e l c h e ba constructed time polynomial
size c furthermore given finite automaton decidable time polynomial
size automaton accepts infinite language see book hopcroft
ullman details thus condition tested time polynomial size
c well finally since size g g polynomial size c
polynomial number configurations need tested together corollary
complexities provide us following corollary
proof



j





j

j



j





g

g







g



g





g

g

c

g

g

c

corollary given concept descriptions c decidable time polynomial
size c whether lcs c exists
computing lcs

subsection first size lcs two concept descriptions may
grow exponentially size concept descriptions stronger
presented partial attributes shown lcs sequence
concept descriptions grow exponentially present exponential time lcs
concept descriptions


fiwhat attribute

gc



gdk





c

c





b







c

c

b








k

figure canonical description graphs c

k

order lcs may exponential size consider following
example fa b c dg define
b
c

u ac ad u u bc bd u ac bc
corresponding canonical description graphs g g k depicted figure
finite graph representing lcs c depicted figure k
graph easily derived g g k graph comprises two binary trees
height k thus contains least nodes following
canonical description graph g k root n representing lcs e c
less nodes let x fc dg word length k fc dg let
v axa w bxa canonical description graphs g g k easy see
c v v w v v w thus e v v w means
words v w u v v u w w u paths n labeled
v w g k leading node g k suppose u
implies e v ax bx according g v ax bx therefore u must empty
k

k



k









k

k





c

k



c

k

e

k

k

k

k



c





k



k

e

k

e







c



b





c


c





c













c







c



figure finite graph representing lcs c


steres borgida
ku

word proves g k path n labeled axa every x fc dg
hence path every ax let fc dg x paths
ax ay n g k lead node implies e v ax ay
contradiction c v ax ay ax ay lead different nodes g k since
fc dg contains words shows g k least nodes finally taking
account size canonical description graph concept description linear
size corresponding description obtain following theorem
k

e

k

e

k





k

e

k

k

e

theorem lcs two concept descriptions may grow exponentially size
concepts

following exponential time computes lcs two concept descriptions
case exists

input concept descriptions c lcs exists
output lcs c
compute g g

g

c





every combination

nodes h p h p g g g h h
e e f g e e e f e f edges g
c



c

extend g follows let g


c

h

g

h

two trees representing finite set words


l l c h e l c h e
g



g

b

succ

p




f g succ p
ba





otherwise

succ p fb j p b successorg set nodes g g
g assumed disjoint replace root g h p root
g h p extend g nodes edges two trees finally
add node n every word v l node trees g
g reachable root g g path labeled v add edge
label n extension illustrated figure
h

h

h

h

v

h

h

h

h

v

step r oles c switched
compute canonical graph g called g output concept
description c g
g

proposition translation
c

cg

graph g computed lcs e


fiwhat attribute



g

h p

h p

b



b



b

n


c




c



bc

n








bad

n

figure extension nodes h p h p g l fb bc badg
easy see two paths g labeled leading
root n n node g contains paths well consequently
e g v g
assume e v proposition know paths
g labeled leading node n w l g may assume n
node g otherwise exist words u u u
lead node g contains paths labeled
leading node sucient g v
let n node distinguish two cases
n node g g g paths paths g since g
subgraph g holds g well hence c v
assume n node g since n node know n
form f f f non tree node tree node symmetry
may assume n f easy see exist nodes h h e e
g p g tree node q g well x v w specified
lemma vxa wxa h h e e p f
preconditions satisfied x l therefore construction
g paths labeled respectively leading root
node
ut
note product g g g computed time polynomial
size c furthermore polynomial number combinations nodes
h p h p g e e f g finally finite automaton l
computed time polynomial size c particular set states
automaton polynomially bounded size c l contained word
longer number states accepting path automaton contains cycle
automaton would accept infinitely many words contradiction assumption
l finite thus length words l bounded polynomially
size c particular means l contains exponential number
words trees representing words computed time exponential size
c
proof

c











c



g

c





c



c





steres borgida
ku

corollary lcs two concept descriptions exists computed time
exponential size concept descriptions
conclusion

attributes binary relations one value distinguished
many knowledge representation schemes object centered modeling languages
done facilitate modeling description logics help identify tractable
sets concept constructors e g restricting attributes fact restrictions quite important practical point view support modeling
actions components borgida devanbu
second distinction attributes total versus partial functions
considered essential shown distinction sometime
significant effects
particular first shown computing subsumption
classic concepts total attributes presented borgida patel schneider
modified accommodate partial attributes treating partial attributes roles
participate restrictions case converted total attributes obtain polynomial time subsumption
consistency checking case
case computing least common subsumers introduced technique
learning non propositional descriptions concepts first noted several
papers literature cohen hirsh frazier pitt implicitly used
partial attributes considering classic furthermore papers used weaker
version concept graphs employed borgida patel schneider
make hold case restrictions generate cycles
furthermore proposed frazier pitt handle inconsistent
concepts easily arise classic concepts con icts lower
upper bounds roles
therefore provided lcs together formal proof correctness
sublanguage classic partial attributes allows equalities
inconsistent concepts proofs easily extended full classic
kusters borgida case lcs exists computed
time polynomial size two initial concept descriptions shown cohen et al
sequences concept descriptions lcs may grow exponentially
size sequence
complete picture main part examined
question computing lcs case total attributes surprisingly situation
different partial attribute case unlike subsumption first
language lcs may even exist existence lcs mentioned cohen et al
due inadvertent switch partial semantics attributes nevertheless
existence lcs two concept descriptions decided polynomial time
lcs exists may grow exponentially size concept descriptions hence
computation lcs may take time exponential size two given concept
descriptions


fiwhat attribute

aside note pointed cohen et al concept
descriptions correspond finitely generated right congruence furthermore
context lcs two concept descriptions intersection right congruences thus
presented intersection finitely generated
right congruences finitely generated right congruence
polynomial deciding question finally intersection finitely
generated generating system may exponential computed
exponential time size generating systems given right
congruences
therefore lay scope effect making attributes
total partial functions description logic supports constructor
moreover correct extend previous literature
believe disparity two cases serve
warning researchers knowledge representation reasoning concerning
importance explicitly considering difference total partial attributes
acknowledgments

authors wish thank anonymous reviewers helpful comments
supported part nsf grant iri carried
first author rutgers university rwth aachen
references

artale franconi e guarino n pazzi l part whole relations objectcentered systems overview data knowledge engineering
baader f formal definition expressive power terminological knowledge representation languages journal logic computation
baader f kusters r computing least common subsumer
specific concept presence cyclic aln concept descriptions herzog
gunter eds proceedings nd annual german conference
artificial intelligence ki vol lecture notes computer science pp
bremen germany springer verlag
baader f kusters r molitor r computing least common subsumers
description logics existential restrictions dean ed proceedings
th international joint conference artificial intelligence ijcai pp
stockholm sweden morgan kaufmann publishers
baader f sattler u tableaux description logics proceedings international conference automated reasoning analytic tableaux
related methods tableaux vol lecture notes artifical intelligence pp university st andrews scotland


steres borgida
ku

borgida relationship description logic predicate logic
proceedings third international conference information knowledge
management cikm pp gaithersburg maryland acm press
borgida description logics data management ieee trans knowledge
data engineering
borgida devanbu p adding dl idl towards knowledgeable
component inter operability proceedings international conference
software engineering pp los angeles ca usa acm
borgida etherington hierarchical knowledge bases ecient disjunctive reasoning brachman r h j levesque r r eds proceedings
st international conference principles knowledge representation
reasoning kr pp toronto canada morgan kaufmann publishers
borgida kusters r name properties purely
structural integrating large dl knowledge bases baader f
sattler u eds proceedings international workshop description
logics dl ceur ws aachen germany rwth aachen
borgida patel schneider p semantics complete subsumption classic description logic journal artificial intelligence
brachman r mcguinness patel schneider p borgida reducing
classic practice knowledge representation theory meets reality artificial
intelligence
calvanese giacomo g lenzerini knowledge representation semi structured data proceedings th national conference
american association artificial intelligence aaai pp aaai
press mit press
calvanese giacomo g lenzerini modeling querying semistructured data network information systems
calvanese giacomo g lenzerini b reasoning expressive description logics fixpoints automata infinite trees dean ed
proceedings th international joint conference artificial intelligence ijcai pp stockholm sweden morgan kaufmann publishers
calvanese giacomo g lenzerini nardi rosati r description
logic framework information integration cohn schubert l shapiro
eds proceedings th international conference principles knowledge
representation reasoning kr pp trento italy morgan kaufmann
publishers
calvanese lenzerini nardi unifying class representation
formalisms journal artificial intelligence


fiwhat attribute

cohen w w hirsh h learnability description logics equality constraints machine learning
cohen w w hirsh h b learning classic description logic theoretical experimental doyle j sandewall e torasso p eds
proceedings fourth international conference principles knowledge representation reasoning kr pp bonn germany morgan kaufmann
publishers
cohen w borgida hirsh h computing least common subsumers description logics swartout w ed proceedings th national conference
artificial intelligence pp san jose ca mit press
devanbu p jones use description logics kbse systems acm
transactions software engineering methodology tosem
frazier pitt l classic learning machine learning journal
giacomo g lenzerini tbox abox reasoning expressive description logics aiello l doyle j shapiro eds proceedings th
international conference principles knowledge representation reasoning
kr pp boston usa morgan kaufmann publishers
hopcroft j ullman j introduction automata theory addison wesley publ
co
kusters r borgida attribute consequences least
common subsumer tech rep dcs tr rutgers university usa available via
ftp ftp cs rutgers edu pub technical reports
mcguinness patel schneider p usability issues knowledge representation systems proceedings th national conference artificial intelligence
aaai th conference innovative applications artificial intelligence iaai pp menlo park aaai press
mcguinness wright j industrial strength description logic
configurator platform ieee intelligent systems
minsky framework representing knowledge winston p ed
psychology computer vision mcgraw hill york
quillian semantic memory minsky ed semantic information processing pp cambridge mass mit press
schmidt schau subsumption kl one undecidable brachman r j
ed proceedings st international conference principles knowledge
representation reasoning kr pp toronto ont morgan kaufmann
publishers



