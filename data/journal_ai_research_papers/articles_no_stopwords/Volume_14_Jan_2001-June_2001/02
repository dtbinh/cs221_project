Journal Artificial Intelligence Research 14 (2001) 53-81

Submitted 8/00; published 3/01

Con ict-Directed Backjumping Revisited
Xinguang Chen

xinguang@cs.ualberta.ca

Peter van Beek

vanbeek@uwaterloo.ca

Department Computing Science, University Alberta
Edmonton, Alberta, Canada T6G 2H1
Department Computer Science, University Waterloo
Waterloo, Ontario, Canada N2L 3G1

Abstract

recent years, many improvements backtracking algorithms solving constraint
satisfaction problems proposed. techniques improving backtracking algorithms conveniently classified look-ahead schemes look-back schemes. Unfortunately, look-ahead look-back schemes entirely orthogonal
observed empirically enhancement look-ahead techniques sometimes counterproductive effects look-back techniques. paper, focus relationship
two important look-ahead techniques|using variable ordering heuristic maintaining level local consistency backtracking search|and
look-back technique con ict-directed backjumping (CBJ). show exists
\perfect" dynamic variable ordering CBJ becomes redundant. show
theoretically level local consistency maintained backtracking
search increased, less backjumping improvement. theoretical
results partially explain backtracking algorithm look-ahead phase
cannot benefit backjumping look-back scheme. Finally, show empirically
adding CBJ backtracking algorithm maintains generalized arc consistency
(GAC), algorithm refer GAC-CBJ, still provide orders magnitude
speedups. empirical results contrast Bessiere Regin's conclusion (1996)
CBJ useless algorithm maintains arc consistency.

1. Introduction

Constraint satisfaction problems (CSPs) generic problem solving framework. constraint satisfaction problem consists set variables, associated domain
values, set constraints. constraints expressed relation, defined
subset variables, denoting consistent value assignments satisfy
constraint. solution CSP assignment value every variable, way
every constraint satisfied.
Constraint satisfaction problems usually solved search methods, among
backtracking algorithm improvements widely used. techniques
improving backtracking algorithms conveniently classified look-ahead schemes
look-back schemes (Dechter, 1992). Look-ahead schemes invoked whenever
algorithm preparing extend current partial solution. Look-ahead schemes include
functions choose next variable instantiated, choose next value
give current variable, reduce search space maintaining certain level
local consistency search (e.g., Bacchus & van Run, 1995; Bessiere & Regin, 1996;
c 2001 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiChen & van Beek

Haralick & Elliott, 1980; McGregor, 1979; Nadel, 1989; Sabin & Freuder, 1994). Lookback schemes invoked whenever algorithm encounters dead-end prepares
backtracking step. Look-back schemes include functions decide far
backtrack analyzing reasons dead-end (backjumping) decide new
constraints record con icts arise later search (e.g.,
Bruynooghe, 1981; Dechter, 1990; Frost & Dechter, 1994; Gaschnig, 1978; Prosser, 1993b;
Schiex & Verfaillie, 1994).
backtracking algorithm hybrid look-ahead look-back schemes
(Prosser, 1993b). paper, focus relationship two important look-ahead techniques|using variable ordering heuristic maintaining level
local consistency backtracking search|and look-back technique con ictdirected backjumping (CBJ) (Prosser, 1993b). Unfortunately, look-ahead lookback schemes entirely orthogonal observed previous experimental
work level consistency maintained backtracking search increased variable ordering heuristic improved, effects CBJ diminished
(Bacchus & van Run, 1995; Bessiere & Regin, 1996; Prosser, 1993a, 1993b). example,
observed Prosser's (1993b) experiments that, given static variable ordering, increasing level local consistency maintained none level forward checking,
diminishes effects CBJ. Bacchus van Run (1995) observe experiments
adding dynamic variable ordering (an improvement static variable ordering)
forward checking algorithm diminishes effects CBJ. experiments
effects diminished almost negligible present argument
might hold general. Bessiere Regin (1996) observe experiments
simultaneously increasing level local consistency even arc consistency
improving dynamic variable ordering heuristic diminishes effects CBJ
much that, implementation, overhead maintaining data structures
backjumping actually slows algorithm. conjecture arc consistency
maintained good variable ordering heuristic used, \CBJ becomes useless".
paper, present theoretical results deepen understanding relationship look-ahead techniques CBJ look-back technique. show
exists \perfect" dynamic variable ordering chronological backtracking algorithm CBJ becomes redundant. variable ordering heuristic
consistent \perfect" heuristic, less chance CBJ reduce search effort.
show CBJ algorithm maintains strong k-consistency backtracking search incomparable exponentially better other.
result refined introducing concept backjump level execution
backjumping algorithm showing algorithm maintains strong k-consistency
never visits nodes backjumping algorithm allowed backjump
k levels. Thus, level local consistency maintained backtracking search
increased, less backjumping improvement. Together, theoretical
results partially explain backtracking algorithm look-ahead phase
cannot benefit backjumping look-back scheme. results extend
partial ordering backtracking algorithms presented Kondrak van Beek (1997)
include backtracking algorithms CBJ hybrids maintain levels local con54

fiConflict-Directed Backjumping Revisited

sistency beyond forward checking, including important algorithms maintain arc
consistency.
present empirical results show that, although effects CBJ may
diminished, adding CBJ backtracking algorithm maintains generalized arc
consistency (GAC), algorithm refer GAC-CBJ, still provide orders
magnitude speedups. empirical results contrast Bessiere Regin's (1996)
conclusion CBJ useless algorithm maintains arc consistency.

2. Background

section, formally define constraint satisfaction problems, brie review local
consistency search tree explored backtracking algorithm.

2.1 Constraint Satisfaction Problems
Definition 1 (CSP) instance constraint satisfaction problem tuple P =
(V ; D; C ), where1
V = fx1; : : :; xng finite set n variables,
= fdom(x1); : : :; dom(xn)g set domains. variable x 2 V associated finite domain possible values, dom(x). maximum domain size
maxx2V jdom(x)j denoted d,

C = fC1; : : :; Cmg finite set constraints relations. constraint C 2 C
pair (vars(C ); rel(C )),

{ vars(C ) = fxi1 ; : : :; xiri g ordered subset variables, called con-

straint scope scheme, size vars(C ) known arity constraint. arity constraint equal 2, called binary constraint.
non-binary constraint constraint arity greater 2. maximum
arity constraints C , maxC 2C jvars(C )j, denoted r,
{ rel(C ) subset Cartesian product dom(xi1 ) dom(xiri ) specifies
allowed combinations values variables vars(C ). element
Cartesian product dom(xi1 ) dom(xiri ) called tuple vars(C ).
Thus, rel(C ) often regarded set tuples vars(C ).

following, assume variable x 2 V , least one constraint
C 2 C x 2 vars(C ). definition, tuple set variables X = fx1; : : :; xkg
ordered list values (a1 ; : : :; ak ) ai 2 dom(xi ), = 1; : : :; k. tuple X
regarded set variable-value pairs fx1 a1 ; : : :; xk ak g. Furthermore,
tuple X viewed function : X ! [x2X dom(x) variable
x 2 X , t[x] 2 dom(x). subset variables X 0 X , use t[X 0] denote tuple
X 0 restricting X 0. use vars(t) denote set variables tuple t.
1. Throughout paper, use n, d, m, r denote number variables, maximum domain
size, number constraints, maximum arity constraints CSP, respectively.

55

fiChen & van Beek

assignment set variables X tuple X . say assignment X
consistent constraint C either vars(C ) 6 X t[vars(C )] 2 rel(C ). partial
solution CSP assignment subset variables. say partial solution
consistent consistent constraints. solution CSP consistent
partial solution variables. solution exists, CSP said insoluble.
CSP empty either one variables empty domain one constraints
empty set tuples. Obviously, empty CSP insoluble. Given two CSP instances
P1 P2 , say P1 = P2 exactly set variables, set
domains set constraints; i.e., syntactically same.

Definition 2 (projection) Given constraint C subset variables vars(C ),
projection C constraint, vars(S C ) = rel(S C ) = ft[S ] j 2
rel(C )g.
Definition 3 (selection) Given constraint C assignment subset variables X vars(C ), selection tC constraint, vars(t C ) = vars(C )
rel(tC ) = fs j s[X ] = 2 rel(C )g.
2.2 Local Consistency

inconsistency consistent partial solution variables cannot
extended additional variables cannot part global solution.
using backtracking search find solution, inconsistency lead dead end
search. insight led definition properties characterize level
consistency CSP development algorithms achieving levels
consistency removing inconsistencies (e.g., Mackworth, 1977a; Montanari, 1974),
effective backtracking algorithms finding solutions CSPs maintain level
consistency search (e.g., Gaschnig, 1978; Haralick & Elliott, 1980; McGregor,
1979; Sabin & Freuder, 1994).
Mackworth (1977a) defines three properties binary CSPs characterize local consistencies: node, arc, path consistency. Mackworth (1977b) generalizes arc consistency
non-binary CSPs.

Definition 4 (arc consistency) Given constraint C variable x 2 vars(C ),
value 2 dom(x) supported C tuple 2 rel(C ), t[x] = a.
called support fx ag C . C arc consistent variables
x 2 vars(C ), values 2 dom(x), fx ag supported C . CSP arc

consistent constraints arc consistent.
Freuder (1978) generalizes node, arc, path consistency, k-consistency.

Definition 5 (k-consistency) CSP k-consistent given consistent
partial solution k , 1 distinct variables, exists instantiation kth variable
partial solution plus instantiation consistent. CSP strongly kconsistent j -consistent 1 j k.
56

fiConflict-Directed Backjumping Revisited

binary CSPs, node, arc path consistency correspond one-, two- threeconsistency, respectively. However, definition k-consistency require CSP
binary arc consistency two-consistency non-binary CSPs.
strongly n-consistent CSP property consistent partial solution
successively extended full solution CSP without backtracking.

2.3 Search Tree Backtracking Algorithms

idea backtracking algorithm extend partial solutions. stage, uninstantiated variable selected assigned value domain extend current
partial solution2 . Constraints used check whether extension may lead
possible solution CSP prune subtrees containing solutions based
current partial solution. backtracking search, variables divided
three sets: past variables (already instantiated), current variable (now instantiated),
future variables (not yet instantiated). dead-end occurs values current variable rejected leading full solution. case, instantiated
variables become uninstantiated ; i.e., removed current partial solution.
process called backtracking. recently instantiated variable becomes
uninstantiated called chronological backtracking ; otherwise, called backjumping. backtracking algorithm terminates possible assignments tested
certain number solutions found.
backtracking search may seen search tree traversal. approach
identify tuples (assignments values variables) nodes: empty tuple root
tree, first level nodes 1-tuples (representing assignment value
single variable), second level nodes 2-tuples, on. levels closer
root called shallower levels levels farther root called deeper levels.
Similarly, variables corresponding levels called shallower deeper.
say backtracking algorithm visits node search tree stage
algorithm's execution current partial solution identifies node. nodes visited
backtracking algorithm form subset nodes belonging search tree.
call subset, together connecting edges, backtrack tree generated
backtracking algorithm.
backtracking algorithm con ict-directed backjumping (CBJ) (Prosser, 1993b) maintains con ict set every variable. Every time instantiation current variable
xi con ict instantiation past variable xh , variable xh added
con ict set xi . values tried current variable xi ,
CBJ backtracks deepest variable xh con ict set xi . time,
variables con ict set xi , exception xh , added con ict set
xh , information con icts lost.
Throughout paper refer following backtracking algorithms (see Kondrak
& van Beek, 1997; Prosser, 1993b detailed explanations examples
algorithms): chronological backtracking (BT), backjumping (BJ) (Gaschnig, 1978), con ictdirected backjumping (CBJ) (Prosser, 1993b), forward checking (FC) (Haralick & Elliott,
1980; McGregor, 1979), forward checking con ict-directed backjumping (FC-CBJ)
2. Throughout paper, assume static value ordering used backtracking search.

57

fiChen & van Beek

(Prosser, 1993b), maintaining arc consistency (MAC) (Gaschnig, 1978; Sabin & Freuder,
1994), maintaining arc consistency con icted-directed backjumping (MAC-CBJ)
(Prosser, 1995).

3. Variable Ordering Heuristics Backjumping

section, present theoretical results deepen understanding relationship look-ahead technique using variable ordering heuristic
look-back technique CBJ.
previous work, Kondrak van Beek (1997) show that, given deterministic
static dynamic variable ordering heuristic, CBJ never visits nodes BT. Bacchus
van Run (1995) show BJ, restricted version CBJ, visits exactly nodes
BT fail-first dynamic variable ordering heuristic used. Previous empirical work
shows number nodes CBJ saves depends variable ordering heuristic
used (Bacchus & van Run, 1995; Bessiere & Regin, 1996; Prosser, 1993b).
show that, given CSP variable ordering CBJ, exists \perfect"
variable ordering chronological backtracking algorithm (BT) BT never
visits nodes CBJ. variable ordering heuristic consistent
\perfect" heuristic, less chance CBJ reduce search effort.
first consider case insoluble CSPs. CBJ applied insoluble CSP,
always backjumps dead-end state; i.e., terminate backjump
situation solution CSP found.

Lemma 1 Given insoluble CSP variable ordering CBJ, exists variable

ordering BT BT never visits nodes CBJ show solution
exists.

Proof backtrack tree generated CBJ variable ordering, let last

backjump terminates execution CBJ variable xj root
backtrack tree. choose xj first variable BT. value domain
xj , current node backtrack tree CBJ consistent (not leaf node),
next variable chosen instantiated assigning xj variable backjumps
xj causes assignment xj revoked. entire variable ordering
BT worked similar, recursive manner. variable ordering BT
well-defined, remains show current node backtrack tree CBJ
inconsistent (a leaf node), corresponding node backtrack tree BT
inconsistent (and therefore next variable needs chosen). show variables
skipped variable ordering constructed BT irrelevant dead-end states
encountered CBJ. Suppose stage ordered variables instantiated
BT xj1 ; : : :; xjk , value 2 dom(xjk ) choose next variable xjk+1
variable backjumps current variable xjk CBJ backtrack tree.
prove induction con ict set xjk+1 used backjumping subsumed
fxj1 ; : : :; xjk g. k = 1 case last backjump terminates execution CBJ.
hypothesis true con ict set xj1 empty set. Suppose true
case k > 1. xjk+1 backjumps xjk , con ict set xjk+1 merged
con ict set xjk . inductive assumption, con ict set xjk subsumed
58

fiConflict-Directed Backjumping Revisited

fxj1 ; : : :; xjk,1 g, thus con ict set xjk+1 subsumed fxj1 ; : : :; xjk g. Therefore,
hypothesis holds case k + 1. CBJ finds instantiation xjk
inconsistent assignments past variables added con ict
set xjk , BT able find inconsistency con ict set xjk
subsumed fxj1 ; : : :; xjk,1 g. Thus, variable ordering BT well-defined.
soluble CSPs, distinguish problem finding one solution
finding solutions.

Lemma 2 Given CSP variable ordering CBJ find first solution,

exists variable ordering BT BT never visits nodes CBJ find
first solution.

Proof Without loss generality, let fx1 a1; : : :; xn g first solution found.

variable ordering BT constructed following way. first variable chosen
BT x1 first variable path root solution CBJ
backtrack tree. assume static value ordering backtracking search,
values domain x1 precede value a1 must rejected CBJ BT
value a1 used instantiate x1 . Furthermore, fx1 a1 ; : : :; xn g
first solution encountered CBJ variable ordering value ordering,
instantiation x1 value preceding a1 leads insoluble subproblem
eventually CBJ backjumps deeper variable x1 revoke assignment. Note
x1 cannot skipped backjump deeper variable x1 first
level search tree solution CSP. Assigning x1
values precede a1 domain leads insoluble subproblems instantiation
order BT arranged Lemma 1. Whenever xk instantiated value ak ,
xk+1 chosen next variable, follows xk path root
solution CBJ backtrack tree. Again, values domain xk+1 precede
ak+1 value ordering must rejected CBJ BT ak+1 assigned
xk+1. instantiation xk+1 values leads insoluble subproblem
eventually CBJ backjumps deeper variable xk+1 . Similarly, xk+1 cannot
skipped backjump deeper variable otherwise least one
assignments x1 ; : : :; xk must changed fx1 a1 ; : : :; xn g
first solution encountered CBJ. insoluble subproblems, instantiation
order BT arranged Lemma 1. Finally, xn instantiated BT
finds solution.
CBJ used find solutions, special steps must taken handle con ict sets. problem con ict sets CBJ meant indicate
instantiations responsible previously discovered inconsistency. However,
solution found, con ict sets cannot always interpreted way. search
solutions, rather inconsistency, causes algorithm backtrack.
need differentiate two causes CBJ backtracks: (1) detecting inconsistency, (2) searching solutions. latter case, backtrack must
always chronological; is, immediately preceding variable. simple solution
remember number solutions found far variable chosen instantiated,
59

fiChen & van Beek

later dead-end state encountered level, compare recorded number current number solutions. difference indicates solutions
found interval search, forces algorithm backtrack chronologically.
Otherwise algorithm performs normal backjumping analyzing con ict set
current variable.

Lemma 3 Given CSP variable ordering CBJ find solutions, exists
variable ordering BT BT never visits nodes CBJ find
solutions.
Proof Let first solution found CBJ fx1

a1; : : :; xn g order
x1 ; : : :; xn. first construct variable ordering BT applied find first

solution. However, BT follows strict chronological backtracking, inevitably
visit nodes fx1 a1 ; : : :; xj ,1 aj ,1 ; xj a0j g, 1 j n a0j comes
aj domain xj . CBJ skips nodes, example, deeper
level variable xh xj ,1 , instantiations x1 ; : : :; xj changed, BT
possibly visit nodes CBJ. show cannot happen induction
distance current level j deepest level n. CBJ found
solution level n, try values xn eventually backtrack xn,1 .
nodes level n cannot skipped. Suppose true case level j + 1
consider case level j . xj aj skipped backjumping,
aj last value domain, CBJ backtrack xj ,1 number
solutions changed. true case j . Otherwise CBJ change
instantiation xj next value domain. Let current partial solution
= fx1 a1; : : :; xj,1 aj,1; xj a0j g. subtree rooted contains solutions,
inductive hypothesis, CBJ skip node level j .
subtree rooted contains solution, exists backjump deeper level
variable xh escape subtree. Could jump beyond xj skipped?
case, con ict set xh subsumed fx1 ; : : :; xj ,1 g. definition con ict
set, know current instantiations variables con ict set cannot lead
solution. However current instantiations fx1 ; : : :; xj ,1 g lead solution,
fx1 a1; : : :; xn ang. contradiction. con ict set xh must contain
xj thus node level j cannot skipped. values domain
xj tried, CBJ chronologically backtrack xj ,1 number
solutions changed. Thus, xj ,1 aj ,1 skipped. hypothesis true
case level j . construct variable ordering BT following way:
current partial solution = fx1 a1 ; : : :; xj ,1 aj ,1 ; xj a0j g cannot extended
solution, construct variable ordering insoluble subproblem.
extended solution, construct variable ordering BT case finding
first solution subproblem, recursively apply steps backjump
level xj changes instantiation xj a0j . variable ordering, BT
never visit nodes CBJ.

Theorem 4 Given CSP variable ordering CBJ, exists variable ordering

BT BT never visits nodes CBJ solving CSP.
60

fiConflict-Directed Backjumping Revisited

x1 + x2 x3
x1 + x3 > x5 + 1
x2 , x4 x5
x1 ; :: : ;x5 2 f0; 1; 2g

x1

0

CBJ backtrack tree

x2

2

x3

x3

x3
3

x4

x4

x5

x4

x5

x5
4

x5

x5

x4

x5

x4

x4
5

p

p p
x1

x2

0

p p p

BT backtrack tree
2

x3

x3

x3
3

x5

x5

x5

x5

x5

x5
4

x4

x4

x4
5

p

p p

p p p

Figure 1: illustration variable ordering constructed BT CBJ backtrack
tree (for CSP shown upper left).

Proof Follows Lemmas 1, 2, 3.
Example 1 Figure 1 shows BT backtrack tree based variable ordering constructed
execution CBJ solve CSP (hypothetical) dynamic variable ordering.
first solution found CBJ fx1 0; x2 0; x3 2; x5 0; x4 0g. Thus, BT
first instantiates x1 x2 0. node fx1 0; x2 0; x3 0g fx1 0; x2
0; x2 1g CBJ backtrack tree lead insoluble subproblems. variable ordering
BT nodes constructed case insoluble CSPs. example,
CBJ backtrack tree, last backjump revoke node fx1 0; x2 0; x3 0g
61

fiChen & van Beek

x5 x3 , next variable instantiated BT node x5 .
ordering, BT avoids instantiating x4 visits fewer nodes CBJ. BT instantiates
x3 2, x5 0, x4 0, finds first solution.
shown exists \perfect" variable ordering CBJ becomes
redundant. course, \perfect" ordering would known priori, practice,
primary goal designing variable ordering heuristics simulate execution
CBJ, reduce size overall backtrack tree. example, popular failfirst heuristic selects next variable instantiated variable minimal
remaining domain size (the size domain removing values con ict
past instantiations) shown minimize size overall tree
certain assumptions. secondary effect, however, variables con icts
past instantiations likely instantiated sooner, thus approximating \perfect"
ordering diminishing effects backjumping.

4. Maintaining Consistency Backjumping

section, present theoretical results deepen understanding relationship look-ahead technique maintaining level local consistency
backtracking search look-back technique CBJ.
previous work, Kondrak van Beek (1997) show that, given deterministic
static dynamic variable ordering heuristic, CBJ never visits nodes BT
FC-CBJ never visits nodes FC. Prosser (1993a) shows removal
inconsistent value domain variable diminish effects CBJ
CBJ visit fewer nodes algorithm combines CBJ discovery
removal inconsistent values. Previous empirical work shows number
nodes CBJ saves depends level local consistency maintained (Bacchus & van
Run, 1995; Bessiere & Regin, 1996; Prosser, 1993b).
extend partial ordering backtracking algorithms presented Kondrak
van Beek (1997) include backtracking algorithms CBJ hybrids maintain
levels local consistency beyond forward checking, including important algorithms
maintain arc consistency. show CBJ algorithm maintains strong kconsistency backtracking search incomparable exponentially
better other. result refined using concept backjump level
execution backjumping algorithm showing algorithm maintains
strong k-consistency never visits nodes backjumping algorithm allowed
backjump k levels. Thus, level local consistency maintained
backtracking search increased, less backjumping improvement.
Section 4.1, consider backjumping algorithms define series algorithms BJk . Section 4.2, consider look-ahead algorithms maintain level
local consistency define series algorithms MCk . Finally, Section 4.3, consider relationships backjumping look-ahead algorithms
hybrids. reader interested technical proofs results jump
directly section.
62

fiConflict-Directed Backjumping Revisited

x1

x1 + x2 x3
x1 + x3 > x5 + 1
x2 , x4 x5
x1 ; : : : ; x5 2 f0; 1; 2g

0

x2

1

x3

d=3
x4

x5

3

x5
d=1

x4

2

d=2
d=1

4
5

p p

Figure 2: illustration backjump levels CBJ backtrack tree (for CSP shown
upper right).

4.1 Backjump Level BJk

analyze uence level consistency backjumping, need notion
backjump level. Informally, level backjump distance, measured backjumps,
backjump destination \farthest" dead-end.

Definition 6 (backjump level, Kondrak & van Beek, 1997) definition back-

jump level recursive:
1. backjump variable xi variable xh level 1 performed directly
dead-end state every value xi fails consistency check.
2. backjump variable xi variable xh level 2, backjumps performed
variable xi level less d, least one level , 1.

Example 2 Figure 2 shows backjump levels example CBJ backtrack tree.

one-level backjump x5 x3 every value domain x5 fails consistency
check. CBJ finds two solutions problem thus chronologically backtracks
x4 x5 , later x3. backjumps level one two respectively. last
three-level backjump x3 x2 .
classifying backjumps performed backjumping algorithm different levels,
weaken CBJ series backjumping algorithms perform limited
levels backjumps. BJk backjumping algorithm allowed perform
k-level backjumps chronologically backtracks j -level backjump j > k
encountered3 . BJn equivalent CBJ, performs unlimited backjumps, BJ1
3. BJk theoretical interest since practice one would use CBJ rather artificially prevent
backjumping; i.e., one actually add code prevent backjumping.

63

fiChen & van Beek

equivalent Gaschnig's (1978) BJ, first level backjumps backjumps
dead-ends.
One may immediately conclude BJk+1 always better BJk one
level backjumps. However, precise, need justify situation
BJk may skip node visited BJk+1 exist. Similar result Kondrak
van Beek (Theorem 11, 1997), show that:

Theorem 5 BJk visits nodes BJk+1 visits.
4.2 Maintaining Strong k-consistency (MCk )

Although backtracking algorithms maintain arc consistency (or truncated form arc
consistency called forward checking) search well-studied, backtracking algorithm maintains strong k-consistency (MCk ) never fully addressed
literature. order study relationship BJk MCk , need specify
precisely MCk algorithms.
generic scheme maintain level local consistency backtracking search
perform node search tree one full cycle consistency achievement. consistency achievement algorithm applied CSP induced current partial
solution. If, result, induced CSP becomes empty applying consistency
algorithm, instantiation current variable dead-end rejected.
resulting CSP empty, instantiation current variable accepted
search continues next level.
simplest form induced CSP restrict domains instantiated
variables one value leave set constraints unchanged. idea
traced back Gaschnig's (1978) implementation MAC, referred DEEB; i.e.,
Domain Element Elimination Backtracking. However, order establish relation
BJk MCk , need restricted definition induced CSP,
constraints induced CSP selections projections constraints
original CSP respect partial solution.

Definition 7 (induced CSP) Given consistent partial solution CSP P , CSP
induced t, denoted P jt , variables P except instantiated t,
domain variable P , constraint C P
vars(C ) 6 vars(t), constraint C 0 = vars(C),vars(t) (t[vars(C )\vars(t)](C )) P jt.
Example 3 Consider graph coloring problem corresponding CSP shown
Figure 3. original CSP four variables, x1 ; : : :; x4, x1 ; x2; x3 2 fr; g; bg
x4 2 frg, five binary constraints, x1 =
6 x2, x1 =6 x3, x2 =6 x3, x2 =6 x4 x3 =6 x4.
Given partial solution = fx1 g; x2 bg, CSP induced t, P jt , two variables,
x3 x4 , unary binary constraints shown Figure 4.
maintaining strong k-consistency algorithm (MCk ) node backtrack
tree applies strong k-consistency achievement algorithm CSP induced

current partial solution. architecture, FC viewed maintaining
one-consistency, binary CSPs, MAC viewed maintaining strong twoconsistency.
64

fiConflict-Directed Backjumping Revisited

algorithm enforcing strong k-consistency CSP instance detect remove
inconsistencies = fx1 a1 ; : : :; xj aj ,1 g 1 j k consistent
cannot consistently extended j th variable xj . remove inconsistency,
make inconsistent resulting CSP removing values domains, removing
inconsistent tuples existing constraints, adding new constraints CSP.
use concept k-proof-tree characterizing tuples removed
strong k-consistency achievement algorithm.

Definition 8 (k-proof-tree) k-proof-tree partial solution k vari-

ables CSP tree node associated partial solution
k variables CSP, (1) root k-proof-tree associated t, (2)
leaf node k-proof-tree inconsistent CSP, (3) non-leaf node
k-proof-tree consistent CSP, children next level nodes
s0 [ fx a1g; : : :; s0 [ fx alg s0 s, x 62 vars(s), dom(x) = fa1 ; : : :; al g.

Example 4 Figure 3 shows three-proof-tree (more one possible) = fx1 gg

given graph coloring problem. non-leaf node, including root t, consistent,
leaf node inconsistent CSP. Since constructed three-prooftree tuple cannot part solution CSP strong 3-consistency
achievement algorithm would remove it.
general, k-proof-tree inconsistency CSP constructed, algorithm achieving strong k-consistency would deduce remove inconsistency.
applying strong k-consistency achievement algorithm CSP, children
node k-proof-tree inconsistent resulting CSP, node inconsistent resulting CSP one subtuples cannot consistently extended
additional variable. leaf nodes k-proof-tree inconsistent
original CSP, bottom-up manner inconsistency root tree
deduced removed resulting CSP. special case, k-proof-tree
empty inconsistency CSP constructed, CSP empty enforcing
strong k-consistency since every way extend variable shown lead
inconsistency (and therefore, value would removed domain resulting
empty domain). hand, CSP made strongly k-consistent,
partial solution k variables inconsistent resulting CSP, k-proof-tree
original CSP constructed. inconsistent original CSP,
k-proof-tree contains single node t. Otherwise, subtuple t0 cannot extended
additional variable x; i.e., partial solutions t0 [ fx a1 g; : : :; t0 [ fx al g,
dom(x) = fa1; : : :; alg, inconsistent resulting CSP. construct
k-proof-tree recursively inconsistencies. special case, CSP
empty enforcing strong k-consistency, k-proof-tree empty inconsistency
original CSP constructed.
following lemmas (Lemma 6 Lemma 8) reveal basic properties induced CSPs strong k-consistency enforcement induced CSPs, used
proofs Theorem 10 Theorem 14.

65

fiChen & van Beek

x2

6=
x1

r;g; b

6=

6=

r;g; b

6=

r

x4

x1

g

x1
x2

g
g

x1 ;x2 ; x3 2 fr; g;bg; x4 2 frg
C (x1 ;x2 ) : x1 6= x2
C (x1 ;x3 ) : x1 6= x3
C (x2 ;x3 ) : x2 6= x3
C (x2 ;x4 ) : x2 6= x4
C (x3 ;x4 ) : x3 6= x4

6=

r;g; b
x3

x1
x2

g
r

x2
x4

r
r

x1
x2
x3

g
b
r

x3
x4

r
r

x1
x2

g
b

x1
x2
x3

g
b
g

x1
x2
x3

g
b
b

Figure 3: three-proof-tree fx1 g g graph coloring problem. leaf nodes
proof-tree inconsistent CSP.

Lemma 6 Given CSP P two partial solutions t0 P , t0, P jt0 =
(P jt )jt0,t .
Proof Clearly P jt0 (P jt)jt0,t set variables set domains.

vars(C ),vars(t0 ) t0 C = vars(C ),vars(t0 ) t0 ,t (vars(C ),vars(t) C ), constraint
C P , selection projection made P jt0 (P jt )jt0,t. Therefore, P jt0
(P jt )jt0,t set constraints.

Lemma 7 Given CSP P consistent partial solution P , (i) P empty
achieving strong k-consistency, (ii) exists variable x 2 vars(t) value
t[x] removed domain x achieving strong k-consistency P , P jt
empty achieving strong k-consistency,

Proof first show that, given consistent partial solution CSP P , k-proof-

tree inconsistency P , corresponding well-defined k-proof-tree Tt
inconsistency s0 = s[vars(s) , vars(t)], induced CSP P jt , provided
66

fiConflict-Directed Backjumping Revisited

x3 2 fr; g; bg; x4 2 frg
C (x3 ) : f(r); (b)g
C (x3 ) : f(r); (g)g
C (x4 ) : f(r)g
C (x3 ; x4 ) : x3 6= x4


x3

r

x3
x4

r
r

x3

g

x3

b

Figure 4: Proof-tree empty inconsistency CSP P jt induced = fx1
g; x2 bg constructed proof-tree fx1 g g CSP P shown
Figure 3.
contain assignments inconsistent assignments t. Tt constructed
three steps (see Figure 4 example): (Step 1) Remove nodes
descendants contain assignments inconsistent assignments
t. (Step 2) Replace remaining node t0 node t00 = t0 [vars(t0) , vars(t)];
i.e., remove variables occur thus occur P jt . t0
leaf node , definition t0 consistent P . possible corresponding
node t00 Tt inconsistent P jt . case, make t00 leaf node
removing descendants. t0 leaf node , definition t0 inconsistent
P ; i.e., exists constraint C P t0 satisfy C . must
case vars(C ) 6 vars(t) (since vars(C ) vars(t) contradicts fact t0
inconsistent C consistent therefore consistent C , t0 agree
assignments Step 1). Hence, corresponding constraint C 0 P jt
selection projection C P . Now, easy verify corresponding node
t00 inconsistent C 0 therefore well-defined leaf node. (Step 3) Remove
subsumed nodes , node t2 subsumed node t1 t2 (necessarily only)
child t1 vars(t2) vars(t1). children subsumed node t2 made children
parent t2 .
Now, suppose P empty achieving strong k-consistency. k-prooftree empty inconsistency P construct k-proof-tree empty
inconsistency P jt . Therefore, P jt empty achieving strong k-consistency. Suppose
exists variable x 2 vars(t), value t[x] removed domain
x achieving strong k-consistency P . k-proof-tree fx t[x]g
P construct k-proof-tree empty inconsistency P jt. Therefore P jt
empty achieving strong k-consistency.

67

fiChen & van Beek

Lemma 8 Given CSP P assignment fx ag, 2 dom(x), induced CSP
P jfx ag empty achieving strong (k , 1)-consistency, value removed
domain x achieving strong k-consistency P .

Proof Suppose P jfx ag empty achieving strong (k , 1)-consistency. Thus,
(k , 1)-proof-tree empty inconsistency P jfx ag . convert (k , 1)proof-tree k-proof-tree fx ag P . node original (k , 1)-proof-tree
replaced [ fx ag. Thus, root tree becomes fx ag. Furthermore,
leaf node original (k , 1)-proof-tree; i.e., consistent P jfx ag ,
easy verify [ fx ag consistent P . leaf node original
(k , 1)-proof-tree; i.e., inconsistent P jfx ag, constraint C 0 P jfx ag

satisfy C 0. Let C 0 selection projection constraint C P .
Thus, [ fx ag satisfy constraint C P therefore inconsistent P .
Hence, constructed k-proof-tree fx ag P thus would removed
domain x achieving strong k-consistency P .

MCk extends current node CSP induced current partial solution
empty achieving strong k-consistency. node thus called k-consistent node.

Definition 9 (k-consistent node) node search tree k-consistent node
CSP induced empty enforcing strong k-consistency. node
k-consistent called k-inconsistent.

Lemma 9 node k-consistent, ancestors k-consistent.
Proof Let t0 one t's ancestors. t0 t, Lemma 6, P jt = (P jt0 )jt,t0 . Thus,
P jt induced subproblem P jt0 . Lemma 7, P jt empty achieving
strong k-consistency, P jt0 empty either achieving strong k-consistency. Thus, t0
k-consistent.

following theorem applies case finding solutions.

Theorem 10 MCk visits node, parent k-consistent. node k-consistent,
MCk visits node.

Proof first part true MCk would branch node parent
found k-inconsistent. prove second part induction depth search tree.
hypothesis trivial j = 1. Suppose true j > 1 k-consistent
node level j + 1. Let current variable x. Lemma 9, t's parent t0 level
j k-consistent. Thus, MCk visit t0 . Lemma 6, P jt = (P jt0 )jfx t[x]g.
(P jt0 )jfx t[x]g empty achieving strong k-consistency, Lemma 7, value t[x]
removed domain x achieving strong k-consistency P jt0 .
consequence, MCk visit t.

necessary sucient condition MCk visit node t's parent kconsistent value assigned current variable removed
domain enforcing strong k-consistency t's parent.
68

fiConflict-Directed Backjumping Revisited

Theorem 11 Given CSP variable ordering, MCk visits nodes MCk+1

visits.

Proof Follows Theorem 10 Lemma 7.
4.3 Relationship BJk MCk

Kondrak van Beek (1997) shown binary CSPs, BJ (BJ1 ) visits
nodes FC (MC1) visits, FC-CBJ (MC1-CBJ) CBJ incomparable.
extend partial ordering backtracking algorithms include relationship
MCk , BJk , MCk -CBJ, 1 k n. results case general CSPs;
i.e., restricted binary CSPs.
begin characterizing important property CBJ algorithm.

Lemma 12 CBJ performs one-level backjump deeper variable xi shallower
variable xh , node th level xh one-inconsistent.

Proof Let Si con ict set xi used backjumping xh deepest variable. show xi experience domain wipe enforcing oneconsistency induced CSP P jth [Si ] . node ti level xi leaf node;
i.e., ti inconsistent P . Suppose ti satisfy constraint C xi 2 vars(C )
vars(C ) Si [ fxi g. selection C P jth [Si ] , constrains one variable
fxig, prohibit value ti [xi] xi. Thus, xi experience domain wipe
enforcing one-consistency P jth [Si ] . Note P jth induced subproblem P jth [Si ] .
Lemma 7, P jth empty enforcing one-consistency. Thus, th level xh
one-inconsistent.
Lemma 13 CBJ performs k-level backjump deeper variable xi shallower
variable xh , current node th level xh k-inconsistent.
Proof Let Si current con ict set xi xh deepest variable. show
k-level backjump xi xh , P jth [Si ] empty enforcing strong

k-consistency thus th k-inconsistent. proof induction k. k = 1 true
Lemma 12. Suppose hypothesis true case k , 1 true
case k; i.e., k-level backjump xi xh , induced CSP P jth [Si ]
empty enforcing strong k-consistency. least one value left
domain xi enforcing strong k-consistency P jth [Si ] . know node ti
level xi instantiating xi either incompatible th (i.e., leaf node)
l-level backjumped deeper variable xj , 1 l < k (see Figure 5).
However, ti cannot leaf node otherwise would removed domain xi
enforcing strong k-consistency. Let Sj con ict set xj . hypothesis,
induced CSP P jti [Sj ] empty achieving strong l-consistency. value
removed resulting CSP, Lemma 8, induced CSP P jth [Si ][fxi ag
empty achieving strong (k , 1)-consistency. ti [Sj ] th [Si ] [ fxi ag,
induced CSP P jti [Sj ] empty achieving strong (k , 1)-consistency. leads
contradiction. Thus P jth [Si ] empty achieving strong k-consistency th
level xh k-inconsistent.
69

fiChen & van Beek

th

xh
k-level backjumping

:::

ti

con ict set Si xi

l-level backjumping, l < k

:::

con ict set Sj xj

Figure 5: scenario CBJ backtrack tree used proof Lemma 13.

Theorem 14 Given CSP variable ordering, BJk visits nodes MCk
visits.

Proof proof induction level search tree. MCk visits node
level j search tree, BJk visits node. j = 1 trivial. Suppose true
case j > 1 node visited MCk level j + 1. know
MCk BJk visit t's parent level j . chance may skipped BJk
BJk backjumps deeper variable xi level shallower variable xh
level h, h < j + 1 < i. Thus, node level h k-inconsistent (by Lemma 13).
Since node level h ancestor know t's parent k-consistent
Lemma 9, node level h k-consistent. contradiction. Therefore, BJk
visits level j + 1.
MCk combined backjumping, namely MCk -CBJ, provided con ict sets
computed correctly achieving strong k-consistency induced CSPs.

Theorem 15 Given CSP variable ordering, MCk visits nodes MCk-CBJ

visits.

Proof MCk-CBJ behaves exactly MCk forward phase

backtracking search, easy verify MCk -CBJ visits node t's parent
k-consistent value assigned current variable removed
domain achieving strong k-consistency t's parent. Therefore, MCk -CBJ never
visits nodes MCk does.
Figure 6, present hierarchy terms size backtrack tree BJk ,
MCk , MCk -CBJ. path algorithm algorithm B figure,
know never visits nodes B does. example, MCk never visits
nodes BJj , j k. Otherwise, instances show may
exponentially better B, vice versa.
70

fiConflict-Directed Backjumping Revisited

BJn
(CBJ)

..
.

+1

BJk

BJk

MCn

MCn -CBJ

..
.

..
.

+1

MCk

+1 -CBJ

MCk

MCk

MCk -CBJ

..
.

..
.

..
.

BJ

1

MC

1

MC -CBJ

(BJ)

(FC)

(FC-CBJ)

1

Figure 6: hierarchy BJk , MCk , MCk -CBJ terms size backtrack
tree.
following example shows, fixed integer k < n, exists CSP instance
CBJ visits exponentially fewer nodes algorithm maintains strong
k-consistency backtracking search4.

Example 5 Given fixed integer k, construct binary CSP n + k +2 variables,
x1 ; : : :; xn,k+1; y1; : : :; yk+1 ; xn,k+2; : : :; xn+1, dom(xi ) = f1; : : :; ng 1 n +1
dom(yj ) = f1; : : :; kg 1 j k + 1. constraints are: xi =
6 xj , =6 j ,
yi =
6 yj , =6 j . problem consists two separate pigeon-hole subproblems, one

variables x1; : : :; xn+1 variables y1 ; : : :; yk+1 , insoluble.
see, pigeon-hole problem highly locally consistent. first subproblem strongly nconsistent second strongly k-consistent. static variable ordering,
4. Independently, Bacchus Grove (1999) present similar example show given fixed k, CBJ
may exponentially better algorithm called MIkC , essentially maintains k-consistency
backtracking search.

71

fiChen & van Beek

backtracking algorithm maintaining strong k-consistency would encounter dead-end
xn,k+1 instantiated. would find subproblem xn,k+2 ; : : :; xn+1
strongly k-consistent. Thus, algorithm backtrack reaches second
pigeon-hole subproblem. explore nk!! nodes level n , k + 1 search tree
thus take exponential number steps find problem insoluble. CBJ
encounter dead-end level xn,k+1 continues second pigeon-hole
problem. Eventually find second-pigeon hole problem insoluble backjump
root search tree. total number nodes explored bounded constant,
O((k + 1)k), fixed k. Therefore, CBJ exponentially better algorithm
maintaining strong k-consistency.
Example 5 shows that, although MCk visits fewer nodes BJk Theorem 14,
BJk+1 exponentially better MCk . However, BJk+1 better MCk
(k + 1)-level backjump chronological backtrack. see
true, suppose particular instance (k + 1)-level backjumps
chronological backtracks (i.e., backjump immediately preceding variable
variable ordering single variable becomes uninstantiated removed
current partial solution). case, freedom backjump one additional level
rather chronologically backtrack make difference BJk+1 effectively
BJk thus cannot better MCk . Thus, BJk+1 better MCk
(k + 1)-level non-chronological backjump. note, however, since
number backjumps level k +1 less equal number backjumps level
k, k increases gets unlikely. Thus, level local consistency
maintained backtracking search increased, less backjumping
improvement.
Consider Example 5 again. level backtrack tree MCk , instantiation
past variables removes one distinct value domain current
variable (recall MCk never instantiates variable y1 reaches dead-end
xn,k+1 ). maintain con ict sets variables, con ict set current
variable would include past variables thus dead-end encountered
algorithm, backjump computed con ict sets would necessarily
chronologically backtrack. Thus, example shows, MCk -CBJ MCk visit
exactly nodes consequently BJk+1 exponentially better MCk CBJ. Furthermore, MCk,1 -CBJ reach second pigeon-hole problem without
encountering dead-end, finally retreat second pigeon-hole problem
root search tree backjumps. Thus, MCk,1 -CBJ may exponentially better
MCk -CBJ. particular, shows surprising result MAC-CBJ visit
exponentially nodes FC-CBJ.
Finally, following example shows, fixed integer k < n, exists CSP
instance algorithm maintains strong k-consistency backtracking
search visits exponentially fewer nodes CBJ.

Example 6 Consider CSP defined Example 5, searched static variable
ordering y1 ; : : :; yk ; x1; : : :; xn+1 ; yk+1 .

72

fiConflict-Directed Backjumping Revisited

5. Empirical Evaluation Adding CBJ GAC

section, report experiments examined effect adding CBJ
backtracking algorithm maintains generalized arc consistency (GAC), algorithm
refer GAC-CBJ. Previous work shown importance algorithms
maintain arc consistency (e.g., Sabin & Freuder, 1994; Bessiere & Regin, 1996). show
adding CBJ backtracking algorithm maintains generalized arc consistency
speed algorithm several orders magnitude hard, structured problems.
Previous empirical studies adding CBJ backtracking algorithm maintains
level local consistency led mixed conclusions. Adding CBJ forward checking,
truncated form arc consistency, shown give improvements always
significant ones. Prosser (1993b) observes static variable ordering, FC-CBJ
three times faster FC Zebra problem. Smith Grant (1995) observe
dynamic variable ordering, adding CBJ FC led significant savings
hard random problems occur easy region. Bacchus van Run (1995)
observe dynamic variable ordering, adding CBJ FC led
5% improvement Zebra problem, n-Queens problems, random binary problems.
Bayardo Schrag (1996, 1997) show adding CBJ well-known Davis-Putnam
algorithm, SAT version forward checking, significant improvement hard
random real-world 3-SAT problems.
Adding CBJ algorithm maintains full arc consistency received less attention literature. one study aware of, Bessiere Regin (1996)
observe adding CBJ MAC (the binary version GAC) actually slows
algorithm random binary problems due overhead maintaining con ict sets.
conjecture \when MAC good variable ordering heuristic used, CBJ
becomes useless".
empirical results lead us differ Bessiere Regin's conclusion
usefulness adding CBJ algorithm maintains full arc consistency. implementation able significantly reduce overhead maintaining con ict sets
use additional data structures5. problems adding CBJ
lead many savings nodes visited, implementation CBJ degrade performance significant factor. demonstrate improvement re-doing Bessiere
Regin's (1996) experiments random binary problems. show experiments two structured domains GAC-CBJ sometimes improve GAC several
orders magnitude hard instances.
experiments, ran GAC GAC-CBJ instance problem
recorded CPU times. Comparing CPU times appropriate underlying code
GAC GAC-CBJ identical, GAC-CBJ containing additional code
maintain con ict sets determine far jump back. Two dynamic variable
orderings used: popular dom+deg heuristic chooses next variable
minimal domain size breaks ties choosing variable maximum degree
(the number constraints constrain variable) dom/deg heuristic
proposed Bessiere Regin (1996) chooses next variable minimal
5. See online appendix source code description key data structures implementations GAC GAC-CBJ.

73

fiChen & van Beek

value domain size divided degree. experiments run 400 MHz
Pentium II's 256 Megabytes memory.

5.1 Random Problems

run time performance GAC GAC-CBJ compared sets randomly
generated binary CSPs. set random problems defined 5-tuple (n; d; r; m; t),
n number variables, uniform domain size, r uniform arity
constraints, number randomly generated constraints, uniform
tightness number tuples constraint. case, constraint tightness
chosen approximately half instances population insoluble;
i.e., instances phase transition region.
Table 1: Effect domain size average time (seconds) solve random instances
(50; d; 2; 95; t). set contained 100 random instances. GAC-CBJ
GAC used dom/deg variable ordering.

GAC-CBJ GAC
5
0:0027 0:0030
10
0:026
0:027
0:10
0:10
15
20
0:41
0:41
25
0:79
0:78
30
2:46
2:47
35
3:82
3:80
10:98
10:75
40

ratio
0:90
0:96
1:00
1:00
1:01
1:00
1:01
1:02

Bessiere Regin (1996) examine effect domain size average time
solve random instances (50; d; 2; 95; t) (see Figure 5 (right) Bessiere & Regin, 1996).
implementation CBJ, adding CBJ steadily worsens performance domain
size increases = 40 MAC-CBJ 1.7 times slower MAC alone.
implementation, difference performance GAC-CBJ GAC negligible
problems (see Table 1).
remaining sets random problems Bessiere Regin used experiments compare performance MAC-CBJ MAC simple provide
meaningful comparison solved less 0.01 seconds 400 MHz
Pentium II computer. Thus, chose harder sets random binary problems.
instance ran GAC GAC-CBJ recorded CPU times. report
average ratio CPU times (GAC GAC-CBJ). set contained 100 random
instances. first set problems, (150; 5; 2; 750; 19), average ratio dom+deg
variable ordering 0.90 average ratio dom/deg variable ordering 0.88.
second set problems, (150; 5; 2; 1500; 21), average ratios dom+deg
74

fiConflict-Directed Backjumping Revisited

dom/deg variable orderings 0.93. words, average GAC little
10% faster GAC-CBJ problems.

5.2 Planning Problems

Planning, one required find sequence actions initial state goal
state, formulated CSP. formulation used experiments,
state modeled collection variables constraints enforce assignments
variables represent consistent state valid transition states. (See Kautz &
Selman, 1992; van Beek & Chen, 1999 details formulation planning
CSP.)
Table 2: Time (seconds) solve instances grid planning problem. absence
entry indicates problem solved within 72000 seconds (20 hours)
CPU time.
dom+deg
GAC GAC-CBJ
0.66
0.68

1
2 762.47
3
.
4
.
.
5

dom/deg
GAC GAC-CBJ
1.58
0.86

33.33 3965.10
.

1753.13

.

.
.
.

321.17

.
.
.

experiments used 130 instances used First AI Planning Systems
Competition, June 6{9, 1998. instances come five different domains: gripper,
mystery, mprime, logistics, grid. experiments report, GAC GACCBJ based AC3 (Mackworth, 1977a) found give best performance.
gripper, mystery, mprime domains, instances could solved
25 seconds GAC GAC-CBJ. easy problems, increased
overhead CBJ rarely led savings, overall GAC 10-15% faster GAC-CBJ.
Table 2 shows comparison GAC GAC-CBJ solving 5 instances
grid problems. GAC-CBJ showed improvement grid problems. example,
solved problem 4 half hour, GAC failed find solution 20 hours.
Table 3 shows comparison GAC GAC-CBJ solving 30 instances
logistics problem. one third instances, GAC-CBJ improved GAC.
example, instances 18, 20 27, GAC-CBJ ran several orders magnitude faster
GAC, instance 15, GAC exhausted 20 hours time limit GAC-CBJ found
solution within 3 minutes. GAC-CBJ GAC performed similarly easier instances
sometimes GAC-CBJ 10% slower GAC.

75

fiChen & van Beek

Table 3: Time (seconds) solve instances logistics planning problem. absence
entry indicates problem solved within 72000 seconds (20
hours) CPU time.
dom+deg
GAC
GAC-CBJ
0.03
0.03
0.03
0.05

1
2
3
10.91
4
0.16
5
1.51
6
36.49
7
0.08
0.15
8
9
0.30
.
10
11
0.04
12
0.11
13
0.54
14
0.63
15
.
16
12.49
17
264.46
18 15382.82
1.29
19
20 6268.16
0.66
21
22
.
23
.
24
0.08
25
34.03
26
.
27 12239.26
28
.
29
.
30
.

0.86

dom/deg
GAC
GAC-CBJ
0.03
0.03
0.03
0.06

9.63

0.81

35.77

16.76

182.51
.
0.42
12.32
0.32 261.33
1165.54 15157.71

8540.58
0.41
0.32
1184.67

0.17
1.54

16.86

0.08
0.15
0.33
.
0.05
0.13
0.57
0.64

1.37

27.66

0.14
1.54
0.08
0.14
0.32
.
0.05
0.11
0.54
0.64

1.33

0.18
1.57
0.09
0.16
0.33
.
0.05
0.11
0.56
0.68

1.31

6125.87

28.55

47.06 12105.62

47.76

0.70
.
.
0.09
13.03
.
.
.
.

76

0.68
.
.
0.08
11.58
.
.
.
.

0.74
.
.
0.09
12.10
.
.
.
.

fiConflict-Directed Backjumping Revisited

5.3 Crossword Puzzle Problems

Crossword puzzle generation, one required fill grid words
dictionary, formulated CSP. formulation used experiments,
unknown words represented variable takes values dictionary.
Binary constraints enforce intersecting words agree intersecting letter
word dictionary appears solution. Figure 7 shows
example 5 5 crossword puzzle grid. CSP model grid 10 variables, 21 binary
\intersection" constraints, 13 \not equals" constraints.
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

Figure 7: crossword puzzle.
experiments used 50 grids two dictionaries total 100 instances
problem ranged easy hard. grids, used 10 instances
following sizes: 55, 1515, 1919, 2121, 2323. dictionaries used
UK dictionary, collects 220,000 words largest domain
word variable contains 30,000 values, Linux dictionary, collects 45,000
words largest domain word variable 5,000 values.
experiments report, GAC GAC-CBJ based AC7 (Bessiere & Regin,
1997) found give best performance (see Sillito, 2000 discussion
integrating AC7 backtracking search).
Figure 8 shows approximate cumulative frequency curves empirical results,
plotting ratio time taken solve instance GAC time
taken solve instance GAC-CBJ. Thus, example, read curve
representing dom+deg variable ordering approximately 85% tests adding
CBJ little effect remaining 15% tests led orders magnitude
improvements. read curves 0, 10, . . . , 100 percentiles data
sets (where value median 50th percentile value 50th test).
crossover point, GAC-CBJ starts perform well better GAC occurs
around 35th percentile. Tables 4 5 examine data closely showing
77

fiChen & van Beek

1000

ratio (GAC / GAC-CBJ)

dom+degree
dom/degree

100

10

1

0.1
10

20

30

40

50
test

60

70

80

90

100

Figure 8: Effect execution time GAC adding con ict-directed backjumping (GACCBJ). curve represents 100 tests instances crossword puzzle problem
tests ordered ratio time taken solve instance
GAC time taken solve instance GAC-CBJ.
actual times solve instances GAC performed best instances
GAC-CBJ performed best.
Table 4: GAC versus GAC-CBJ instances crossword puzzle problem. ten
best improvements time (seconds) GAC GAC-CBJ solve instance
presented.
dom+deg
rank GAC GAC-CBJ
1
1.21
1.35
2
1.10
1.20
3
6.12
6.53
4
0.78
0.81
5 110.23
114.52
68.67
71.28
6
7
47.16
48.42
8
32.69
33.63
9
25.17
26.08
21.37
10 20.73
78

dom/deg
GAC GAC-CBJ
1.11
1.23
0.95
1.02
1.16
1.24
56.66
60.36
1.30
1.37
4.86
5.11
0.22
0.23
14.23
14.76
74.38
77.52
7.43
7.67

fiConflict-Directed Backjumping Revisited

Table 5: GAC versus GAC-CBJ instances crossword puzzle problem. ten
best improvements time (seconds) GAC-CBJ GAC solve instance
presented. absence entry indicates problem solved
within 36000 seconds (10 hours) CPU time.
dom+deg
dom/deg
rank GAC GAC-CBJ GAC GAC-CBJ
1
.
37.85
.
54.60
2
.
41.43 10311.32
33.43
3
.
67.07
.
225.92
4
.
82.58
.
244.81
.
276.00
.
308.04
5
.
542.80
.
374.72
6
7
.
939.71
.
832.68
8 2716.86
115.87
.
1486.43
9
390.91
34.90
.
1890.24
10
.
3336.37
.
3411.83

summary, smaller, easier crossword puzzle instances GAC slightly
faster GAC-CBJ, many puzzles noticeable difference,
larger, harder puzzles GAC-CBJ orders magnitude faster GAC.

6. Conclusion

paper, presented three main results. First, showed choice dynamic
variable ordering heuristic weaken effects backjumping technique. Second,
showed level local consistency maintained backtracking
search increased, less backjumping improvement. Together
results partially explain backtracking algorithm look-ahead phase
cannot benefit backjumping look-back scheme extend partial
ordering backtracking algorithms presented Kondrak van Beek (1997) include
backtracking algorithms CBJ hybrids maintain levels local consistency
beyond forward checking. Third, finally, showed adding CBJ backtracking
algorithm maintains generalized arc consistency (still) speed algorithm
several orders magnitude hard, structured problems. Throughout paper,
restrict binary CSPs.

Acknowledgements
authors wish thank referees careful reading previous version
paper helpful comments. financial support Canadian Government
NSERC program gratefully acknowledged.
79

fiChen & van Beek

References

Bacchus, F., & Grove, A. (1999). Looking forward constraint satisfaction algorithms.
Unpublished manuscript.
Bacchus, F., & van Run, P. (1995). Dynamic variable ordering CSPs. Proceedings
First International Conference Principles Practice Constraint Programming,
pp. 258{275, Cassis, France. Available as: Springer Lecture Notes Computer Science
976.
Bayardo Jr., R. J., & Schrag, R. (1996). Using CSP look-back techniques solve exceptionally hard SAT instances. Proceedings Second International Conference
Principles Practice Constraint Programming, pp. 46{60, Cambridge, Mass.
Available as: Springer Lecture Notes Computer Science 1118.
Bayardo Jr, R. J., & Schrag, R. C. (1997). Using CSP look-back techniques solve realworld SAT instances. Proceedings Fourteenth National Conference Artificial Intelligence, pp. 203{208, Providence, RI.
Bessiere, C., & Regin, J.-C. (1996). MAC combined heuristics: Two reasons forsake
FC (and CBJ?) hard problems. Proceedings Second International Conference Principles Practice Constraint Programming, pp. 61{75, Cambridge,
Mass.
Bessiere, C., & Regin, J.-C. (1997). Arc consistency general constraint networks: Preliminary results. Proceedings Sixteenth International Joint Conference
Artificial Intelligence, pp. 398{404, Nagoya, Japan.
Bruynooghe, M. (1981). Solving combinatorial search problems intelligent backtracking.
Information Processing Letters, 12, 36{39.
Chen, X. (2000). Theoretical Comparison Selected CSP Solving Modeling Techniques. Ph.D. thesis, University Alberta.
Dechter, R. (1990). Enhancement schemes constraint processing: Backjumping, learning,
cutset decomposition. Artificial Intelligence, 41, 273{312.
Dechter, R. (1992). Constraint networks. Shapiro, S. C. (Ed.), Encyclopedia Artificial
Intelligence, 2nd Edition, pp. 276{285. John Wiley & Sons.
Freuder, E. C. (1978). Synthesizing constraint expressions. Comm. ACM, 21, 958{966.
Frost, D., & Dechter, R. (1994). Dead-end driven learning. Proceedings Twelfth
National Conference Artificial Intelligence, pp. 294{300, Seattle, Wash.
Gaschnig, J. (1978). Experimental case studies backtrack vs. Waltz-type vs. new algorithms satisficing assignment problems. Proceedings Second Canadian
Conference Artificial Intelligence, pp. 268{277, Toronto, Ont.
Haralick, R. M., & Elliott, G. L. (1980). Increasing tree search eciency constraint
satisfaction problems. Artificial Intelligence, 14, 263{313.
Kautz, H., & Selman, B. (1992). Planning satisfiability. Proceedings 10th
European Conference Artificial Intelligence, pp. 359{363, Vienna.
80

fiConflict-Directed Backjumping Revisited

Kondrak, G., & van Beek, P. (1997). theoretical evaluation selected backtracking
algorithms. Artificial Intelligence, 89, 365{387.
Mackworth, A. K. (1977a). Consistency networks relations. Artificial Intelligence, 8,
99{118.
Mackworth, A. K. (1977b). reading sketch maps. Proceedings Fifth International Joint Conference Artificial Intelligence, pp. 598{606, Cambridge, Mass.
McGregor, J. J. (1979). Relational consistency algorithms application finding
subgraph graph isomorphisms. Inform. Sci., 19, 229{250.
Montanari, U. (1974). Networks constraints: Fundamental properties applications
picture processing. Inform. Sci., 7, 95{132.
Nadel, B. A. (1989). Constraint satisfaction algorithms. Computational Intelligence, 5,
188{224.
Prosser, P. (1993a). Domain filtering degrade intelligent backtracking search. Proceedings Thirteenth International Joint Conference Artificial Intelligence,
pp. 262{267, Chambery, France.
Prosser, P. (1993b). Hybrid algorithms constraint satisfaction problem. Computational Intelligence, 9, 268{299.
Prosser, P. (1995). MAC-CBJ: Maintaining arc consistency con ict-directed backjumping. Research report 177, University Strathclyde.
Sabin, D., & Freuder, E. C. (1994). Contradicting conventional wisdom constraint satisfaction. Proceedings 11th European Conference Artificial Intelligence,
pp. 125{129, Amsterdam.
Schiex, T., & Verfaillie, G. (1994). Nogood recording static dynamic constraint
satisfaction problems. International Journal Artificial Intelligence Tools, 3, 1{15.
Sillito, J. (2000). Improving Estimating Cost Backtracking Algorithms CSPs..
MSc thesis, University Alberta, 2000.
Smith, B. M., & Grant, S. A. (1995). Sparse constraint graphs exceptionally hard problems. Proceedings Fourteenth International Joint Conference Artificial
Intelligence, pp. 646{651, Montreal.
van Beek, P., & Chen, X. (1999). CPlan: constraint programming approach planning.
Proceedings Sixteenth National Conference Artificial Intelligence, pp.
585{590, Orlando, Florida.

81


