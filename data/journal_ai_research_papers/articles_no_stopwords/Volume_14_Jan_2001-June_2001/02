journal artificial intelligence

submitted published

con ict directed backjumping revisited
xinguang chen

xinguang cs ualberta ca

peter van beek

vanbeek uwaterloo ca

department computing science university alberta
edmonton alberta canada g h
department computer science university waterloo
waterloo ontario canada n l g

abstract

recent years many improvements backtracking solving constraint
satisfaction proposed techniques improving backtracking conveniently classified look ahead schemes look back schemes unfortunately look ahead look back schemes entirely orthogonal
observed empirically enhancement look ahead techniques sometimes counterproductive effects look back techniques focus relationship
two important look ahead techniques variable ordering heuristic maintaining level local consistency backtracking search
look back technique con ict directed backjumping cbj exists
perfect dynamic variable ordering cbj becomes redundant
theoretically level local consistency maintained backtracking
search increased less backjumping improvement theoretical
partially explain backtracking look ahead phase
cannot benefit backjumping look back scheme finally empirically
adding cbj backtracking maintains generalized arc consistency
gac refer gac cbj still provide orders magnitude
speedups empirical contrast bessiere regin conclusion
cbj useless maintains arc consistency

introduction

constraint satisfaction csps generic solving framework constraint satisfaction consists set variables associated domain
values set constraints constraints expressed relation defined
subset variables denoting consistent value assignments satisfy
constraint solution csp assignment value every variable way
every constraint satisfied
constraint satisfaction usually solved search methods among
backtracking improvements widely used techniques
improving backtracking conveniently classified look ahead schemes
look back schemes dechter look ahead schemes invoked whenever
preparing extend current partial solution look ahead schemes include
functions choose next variable instantiated choose next value
give current variable reduce search space maintaining certain level
local consistency search e g bacchus van run bessiere regin
c ai access foundation morgan kaufmann publishers rights reserved

fichen van beek

haralick elliott mcgregor nadel sabin freuder lookback schemes invoked whenever encounters dead end prepares
backtracking step look back schemes include functions decide far
backtrack analyzing reasons dead end backjumping decide
constraints record con icts arise later search e g
bruynooghe dechter frost dechter gaschnig prosser b
schiex verfaillie
backtracking hybrid look ahead look back schemes
prosser b focus relationship two important look ahead techniques variable ordering heuristic maintaining level
local consistency backtracking search look back technique con ictdirected backjumping cbj prosser b unfortunately look ahead lookback schemes entirely orthogonal observed previous experimental
work level consistency maintained backtracking search increased variable ordering heuristic improved effects cbj diminished
bacchus van run bessiere regin prosser b example
observed prosser b experiments given static variable ordering increasing level local consistency maintained none level forward checking
diminishes effects cbj bacchus van run observe experiments
adding dynamic variable ordering improvement static variable ordering
forward checking diminishes effects cbj experiments
effects diminished almost negligible present argument
might hold general bessiere regin observe experiments
simultaneously increasing level local consistency even arc consistency
improving dynamic variable ordering heuristic diminishes effects cbj
much implementation overhead maintaining data structures
backjumping actually slows conjecture arc consistency
maintained good variable ordering heuristic used cbj becomes useless
present theoretical deepen understanding relationship look ahead techniques cbj look back technique
exists perfect dynamic variable ordering chronological backtracking cbj becomes redundant variable ordering heuristic
consistent perfect heuristic less chance cbj reduce search effort
cbj maintains strong k consistency backtracking search incomparable exponentially better
refined introducing concept backjump level execution
backjumping showing maintains strong k consistency
never visits nodes backjumping allowed backjump
k levels thus level local consistency maintained backtracking search
increased less backjumping improvement together theoretical
partially explain backtracking look ahead phase
cannot benefit backjumping look back scheme extend
partial ordering backtracking presented kondrak van beek
include backtracking cbj hybrids maintain levels local con

ficonflict directed backjumping revisited

sistency beyond forward checking including important maintain arc
consistency
present empirical although effects cbj may
diminished adding cbj backtracking maintains generalized arc
consistency gac refer gac cbj still provide orders
magnitude speedups empirical contrast bessiere regin
conclusion cbj useless maintains arc consistency

background

section formally define constraint satisfaction brie review local
consistency search tree explored backtracking

constraint satisfaction
definition csp instance constraint satisfaction tuple p
v c
v fx xng finite set n variables
fdom x dom xn g set domains variable x v associated finite domain possible values dom x maximum domain size
maxx v jdom x j denoted

c fc cmg finite set constraints relations constraint c c
pair vars c rel c

vars c fxi xiri g ordered subset variables called con

straint scope scheme size vars c known arity constraint arity constraint equal called binary constraint
non binary constraint constraint arity greater maximum
arity constraints c maxc c jvars c j denoted r
rel c subset cartesian product dom xi dom xiri specifies
allowed combinations values variables vars c element
cartesian product dom xi dom xiri called tuple vars c
thus rel c often regarded set tuples vars c

following assume variable x v least one constraint
c c x vars c definition tuple set variables x fx xkg
ordered list values ak ai dom xi k tuple x
regarded set variable value pairs fx xk ak g furthermore
tuple x viewed function x x x dom x variable
x x x dom x subset variables x x use x denote tuple
x restricting x use vars denote set variables tuple
throughout use n r denote number variables maximum domain
size number constraints maximum arity constraints csp respectively



fichen van beek

assignment set variables x tuple x say assignment x
consistent constraint c vars c x vars c rel c partial
solution csp assignment subset variables say partial solution
consistent consistent constraints solution csp consistent
partial solution variables solution exists csp said insoluble
csp empty one variables empty domain one constraints
empty set tuples obviously empty csp insoluble given two csp instances
p p say p p exactly set variables set
domains set constraints e syntactically

definition projection given constraint c subset variables vars c
projection c constraint vars c rel c ft j
rel c g
definition selection given constraint c assignment subset variables x vars c selection tc constraint vars c vars c
rel tc fs j x rel c g
local consistency

inconsistency consistent partial solution variables cannot
extended additional variables cannot part global solution
backtracking search solution inconsistency lead dead end
search insight led definition properties characterize level
consistency csp development achieving levels
consistency removing inconsistencies e g mackworth montanari
effective backtracking finding solutions csps maintain level
consistency search e g gaschnig haralick elliott mcgregor
sabin freuder
mackworth defines three properties binary csps characterize local consistencies node arc path consistency mackworth b generalizes arc consistency
non binary csps

definition arc consistency given constraint c variable x vars c
value dom x supported c tuple rel c x
called support fx ag c c arc consistent variables
x vars c values dom x fx ag supported c csp arc

consistent constraints arc consistent
freuder generalizes node arc path consistency k consistency

definition k consistency csp k consistent given consistent
partial solution k distinct variables exists instantiation kth variable
partial solution plus instantiation consistent csp strongly kconsistent j consistent j k


ficonflict directed backjumping revisited

binary csps node arc path consistency correspond one two threeconsistency respectively however definition k consistency require csp
binary arc consistency two consistency non binary csps
strongly n consistent csp property consistent partial solution
successively extended full solution csp without backtracking

search tree backtracking

idea backtracking extend partial solutions stage uninstantiated variable selected assigned value domain extend current
partial solution constraints used check whether extension may lead
possible solution csp prune subtrees containing solutions
current partial solution backtracking search variables divided
three sets past variables already instantiated current variable instantiated
future variables yet instantiated dead end occurs values current variable rejected leading full solution case instantiated
variables become uninstantiated e removed current partial solution
process called backtracking recently instantiated variable becomes
uninstantiated called chronological backtracking otherwise called backjumping backtracking terminates possible assignments tested
certain number solutions found
backtracking search may seen search tree traversal
identify tuples assignments values variables nodes empty tuple root
tree first level nodes tuples representing assignment value
single variable second level nodes tuples levels closer
root called shallower levels levels farther root called deeper levels
similarly variables corresponding levels called shallower deeper
say backtracking visits node search tree stage
execution current partial solution identifies node nodes visited
backtracking form subset nodes belonging search tree
call subset together connecting edges backtrack tree generated
backtracking
backtracking con ict directed backjumping cbj prosser b maintains con ict set every variable every time instantiation current variable
xi con ict instantiation past variable xh variable xh added
con ict set xi values tried current variable xi
cbj backtracks deepest variable xh con ict set xi time
variables con ict set xi exception xh added con ict set
xh information con icts lost
throughout refer following backtracking see kondrak
van beek prosser b detailed explanations examples
chronological backtracking bt backjumping bj gaschnig con ictdirected backjumping cbj prosser b forward checking fc haralick elliott
mcgregor forward checking con ict directed backjumping fc cbj
throughout assume static value ordering used backtracking search



fichen van beek

prosser b maintaining arc consistency mac gaschnig sabin freuder
maintaining arc consistency con icted directed backjumping mac cbj
prosser

variable ordering heuristics backjumping

section present theoretical deepen understanding relationship look ahead technique variable ordering heuristic
look back technique cbj
previous work kondrak van beek given deterministic
static dynamic variable ordering heuristic cbj never visits nodes bt bacchus
van run bj restricted version cbj visits exactly nodes
bt fail first dynamic variable ordering heuristic used previous empirical work
shows number nodes cbj saves depends variable ordering heuristic
used bacchus van run bessiere regin prosser b
given csp variable ordering cbj exists perfect
variable ordering chronological backtracking bt bt never
visits nodes cbj variable ordering heuristic consistent
perfect heuristic less chance cbj reduce search effort
first consider case insoluble csps cbj applied insoluble csp
backjumps dead end state e terminate backjump
situation solution csp found

lemma given insoluble csp variable ordering cbj exists variable

ordering bt bt never visits nodes cbj solution
exists

proof backtrack tree generated cbj variable ordering let last

backjump terminates execution cbj variable xj root
backtrack tree choose xj first variable bt value domain
xj current node backtrack tree cbj consistent leaf node
next variable chosen instantiated assigning xj variable backjumps
xj causes assignment xj revoked entire variable ordering
bt worked similar recursive manner variable ordering bt
well defined remains current node backtrack tree cbj
inconsistent leaf node corresponding node backtrack tree bt
inconsistent therefore next variable needs chosen variables
skipped variable ordering constructed bt irrelevant dead end states
encountered cbj suppose stage ordered variables instantiated
bt xj xjk value dom xjk choose next variable xjk
variable backjumps current variable xjk cbj backtrack tree
prove induction con ict set xjk used backjumping subsumed
fxj xjk g k case last backjump terminates execution cbj
hypothesis true con ict set xj empty set suppose true
case k xjk backjumps xjk con ict set xjk merged
con ict set xjk inductive assumption con ict set xjk subsumed


ficonflict directed backjumping revisited

fxj xjk g thus con ict set xjk subsumed fxj xjk g therefore
hypothesis holds case k cbj finds instantiation xjk
inconsistent assignments past variables added con ict
set xjk bt able inconsistency con ict set xjk
subsumed fxj xjk g thus variable ordering bt well defined
soluble csps distinguish finding one solution
finding solutions

lemma given csp variable ordering cbj first solution

exists variable ordering bt bt never visits nodes cbj
first solution

proof without loss generality let fx xn g first solution found

variable ordering bt constructed following way first variable chosen
bt x first variable path root solution cbj
backtrack tree assume static value ordering backtracking search
values domain x precede value must rejected cbj bt
value used instantiate x furthermore fx xn g
first solution encountered cbj variable ordering value ordering
instantiation x value preceding leads insoluble subproblem
eventually cbj backjumps deeper variable x revoke assignment note
x cannot skipped backjump deeper variable x first
level search tree solution csp assigning x
values precede domain leads insoluble subproblems instantiation
order bt arranged lemma whenever xk instantiated value ak
xk chosen next variable follows xk path root
solution cbj backtrack tree values domain xk precede
ak value ordering must rejected cbj bt ak assigned
xk instantiation xk values leads insoluble subproblem
eventually cbj backjumps deeper variable xk similarly xk cannot
skipped backjump deeper variable otherwise least one
assignments x xk must changed fx xn g
first solution encountered cbj insoluble subproblems instantiation
order bt arranged lemma finally xn instantiated bt
finds solution
cbj used solutions special steps must taken handle con ict sets con ict sets cbj meant indicate
instantiations responsible previously discovered inconsistency however
solution found con ict sets cannot interpreted way search
solutions rather inconsistency causes backtrack
need differentiate two causes cbj backtracks detecting inconsistency searching solutions latter case backtrack must
chronological immediately preceding variable simple solution
remember number solutions found far variable chosen instantiated


fichen van beek

later dead end state encountered level compare recorded number current number solutions difference indicates solutions
found interval search forces backtrack chronologically
otherwise performs normal backjumping analyzing con ict set
current variable

lemma given csp variable ordering cbj solutions exists
variable ordering bt bt never visits nodes cbj
solutions
proof let first solution found cbj fx

xn g order
x xn first construct variable ordering bt applied first

solution however bt follows strict chronological backtracking inevitably
visit nodes fx xj aj xj j g j n j comes
aj domain xj cbj skips nodes example deeper
level variable xh xj instantiations x xj changed bt
possibly visit nodes cbj cannot happen induction
distance current level j deepest level n cbj found
solution level n try values xn eventually backtrack xn
nodes level n cannot skipped suppose true case level j
consider case level j xj aj skipped backjumping
aj last value domain cbj backtrack xj number
solutions changed true case j otherwise cbj change
instantiation xj next value domain let current partial solution
fx xj aj xj j g subtree rooted contains solutions
inductive hypothesis cbj skip node level j
subtree rooted contains solution exists backjump deeper level
variable xh escape subtree could jump beyond xj skipped
case con ict set xh subsumed fx xj g definition con ict
set know current instantiations variables con ict set cannot lead
solution however current instantiations fx xj g lead solution
fx xn ang contradiction con ict set xh must contain
xj thus node level j cannot skipped values domain
xj tried cbj chronologically backtrack xj number
solutions changed thus xj aj skipped hypothesis true
case level j construct variable ordering bt following way
current partial solution fx xj aj xj j g cannot extended
solution construct variable ordering insoluble subproblem
extended solution construct variable ordering bt case finding
first solution subproblem recursively apply steps backjump
level xj changes instantiation xj j variable ordering bt
never visit nodes cbj

theorem given csp variable ordering cbj exists variable ordering

bt bt never visits nodes cbj solving csp


ficonflict directed backjumping revisited

x x x
x x x
x x x
x x f g

x



cbj backtrack tree

x



x

x

x


x

x

x

x

x

x


x

x

x

x

x

x


p

p p
x

x



p p p

bt backtrack tree


x

x

x


x

x

x

x

x

x


x

x

x


p

p p

p p p

figure illustration variable ordering constructed bt cbj backtrack
tree csp shown upper left

proof follows lemmas
example figure shows bt backtrack tree variable ordering constructed
execution cbj solve csp hypothetical dynamic variable ordering
first solution found cbj fx x x x x g thus bt
first instantiates x x node fx x x g fx x
x g cbj backtrack tree lead insoluble subproblems variable ordering
bt nodes constructed case insoluble csps example
cbj backtrack tree last backjump revoke node fx x x g


fichen van beek

x x next variable instantiated bt node x
ordering bt avoids instantiating x visits fewer nodes cbj bt instantiates
x x x finds first solution
shown exists perfect variable ordering cbj becomes
redundant course perfect ordering would known priori practice
primary goal designing variable ordering heuristics simulate execution
cbj reduce size overall backtrack tree example popular failfirst heuristic selects next variable instantiated variable minimal
remaining domain size size domain removing values con ict
past instantiations shown minimize size overall tree
certain assumptions secondary effect however variables con icts
past instantiations likely instantiated sooner thus approximating perfect
ordering diminishing effects backjumping

maintaining consistency backjumping

section present theoretical deepen understanding relationship look ahead technique maintaining level local consistency
backtracking search look back technique cbj
previous work kondrak van beek given deterministic
static dynamic variable ordering heuristic cbj never visits nodes bt
fc cbj never visits nodes fc prosser shows removal
inconsistent value domain variable diminish effects cbj
cbj visit fewer nodes combines cbj discovery
removal inconsistent values previous empirical work shows number
nodes cbj saves depends level local consistency maintained bacchus van
run bessiere regin prosser b
extend partial ordering backtracking presented kondrak
van beek include backtracking cbj hybrids maintain
levels local consistency beyond forward checking including important
maintain arc consistency cbj maintains strong kconsistency backtracking search incomparable exponentially
better refined concept backjump level
execution backjumping showing maintains
strong k consistency never visits nodes backjumping allowed
backjump k levels thus level local consistency maintained
backtracking search increased less backjumping improvement
section consider backjumping define series bjk section consider look ahead maintain level
local consistency define series mck finally section consider relationships backjumping look ahead
hybrids reader interested technical proofs jump
directly section


ficonflict directed backjumping revisited

x

x x x
x x x
x x x
x x f g



x



x


x

x



x


x









p p

figure illustration backjump levels cbj backtrack tree csp shown
upper right

backjump level bjk

analyze uence level consistency backjumping need notion
backjump level informally level backjump distance measured backjumps
backjump destination farthest dead end

definition backjump level kondrak van beek definition back

jump level recursive
backjump variable xi variable xh level performed directly
dead end state every value xi fails consistency check
backjump variable xi variable xh level backjumps performed
variable xi level less least one level

example figure shows backjump levels example cbj backtrack tree

one level backjump x x every value domain x fails consistency
check cbj finds two solutions thus chronologically backtracks
x x later x backjumps level one two respectively last
three level backjump x x
classifying backjumps performed backjumping different levels
weaken cbj series backjumping perform limited
levels backjumps bjk backjumping allowed perform
k level backjumps chronologically backtracks j level backjump j k
encountered bjn equivalent cbj performs unlimited backjumps bj
bjk theoretical interest since practice one would use cbj rather artificially prevent
backjumping e one actually add code prevent backjumping



fichen van beek

equivalent gaschnig bj first level backjumps backjumps
dead ends
one may immediately conclude bjk better bjk one
level backjumps however precise need justify situation
bjk may skip node visited bjk exist similar kondrak
van beek theorem

theorem bjk visits nodes bjk visits
maintaining strong k consistency mck

although backtracking maintain arc consistency truncated form arc
consistency called forward checking search well studied backtracking maintains strong k consistency mck never fully addressed
literature order study relationship bjk mck need specify
precisely mck
generic scheme maintain level local consistency backtracking search
perform node search tree one full cycle consistency achievement consistency achievement applied csp induced current partial
solution induced csp becomes empty applying consistency
instantiation current variable dead end rejected
resulting csp empty instantiation current variable accepted
search continues next level
simplest form induced csp restrict domains instantiated
variables one value leave set constraints unchanged idea
traced back gaschnig implementation mac referred deeb e
domain element elimination backtracking however order establish relation
bjk mck need restricted definition induced csp
constraints induced csp selections projections constraints
original csp respect partial solution

definition induced csp given consistent partial solution csp p csp
induced denoted p jt variables p except instantiated
domain variable p constraint c p
vars c vars constraint c vars c vars vars c vars c p jt
example consider graph coloring corresponding csp shown
figure original csp four variables x x x x x fr g bg
x frg five binary constraints x
x x x x x x x x x
given partial solution fx g x bg csp induced p jt two variables
x x unary binary constraints shown figure
maintaining strong k consistency mck node backtrack
tree applies strong k consistency achievement csp induced

current partial solution architecture fc viewed maintaining
one consistency binary csps mac viewed maintaining strong twoconsistency


ficonflict directed backjumping revisited

enforcing strong k consistency csp instance detect remove
inconsistencies fx xj aj g j k consistent
cannot consistently extended j th variable xj remove inconsistency
make inconsistent resulting csp removing values domains removing
inconsistent tuples existing constraints adding constraints csp
use concept k proof tree characterizing tuples removed
strong k consistency achievement

definition k proof tree k proof tree partial solution k vari

ables csp tree node associated partial solution
k variables csp root k proof tree associated
leaf node k proof tree inconsistent csp non leaf node
k proof tree consistent csp children next level nodes
fx g fx alg x vars dom x fa al g

example figure shows three proof tree one possible fx gg

given graph coloring non leaf node including root consistent
leaf node inconsistent csp since constructed three prooftree tuple cannot part solution csp strong consistency
achievement would remove
general k proof tree inconsistency csp constructed achieving strong k consistency would deduce remove inconsistency
applying strong k consistency achievement csp children
node k proof tree inconsistent resulting csp node inconsistent resulting csp one subtuples cannot consistently extended
additional variable leaf nodes k proof tree inconsistent
original csp bottom manner inconsistency root tree
deduced removed resulting csp special case k proof tree
empty inconsistency csp constructed csp empty enforcing
strong k consistency since every way extend variable shown lead
inconsistency therefore value would removed domain resulting
empty domain hand csp made strongly k consistent
partial solution k variables inconsistent resulting csp k proof tree
original csp constructed inconsistent original csp
k proof tree contains single node otherwise subtuple cannot extended
additional variable x e partial solutions fx g fx al g
dom x fa alg inconsistent resulting csp construct
k proof tree recursively inconsistencies special case csp
empty enforcing strong k consistency k proof tree empty inconsistency
original csp constructed
following lemmas lemma lemma reveal basic properties induced csps strong k consistency enforcement induced csps used
proofs theorem theorem



fichen van beek

x


x

r g b





r g b



r

x

x

g

x
x

g
g

x x x fr g bg x frg
c x x x x
c x x x x
c x x x x
c x x x x
c x x x x



r g b
x

x
x

g
r

x
x

r
r

x
x
x

g
b
r

x
x

r
r

x
x

g
b

x
x
x

g
b
g

x
x
x

g
b
b

figure three proof tree fx g g graph coloring leaf nodes
proof tree inconsistent csp

lemma given csp p two partial solutions p p jt
p jt jt
proof clearly p jt p jt jt set variables set domains

vars c vars c vars c vars vars c vars c constraint
c p selection projection made p jt p jt jt therefore p jt
p jt jt set constraints

lemma given csp p consistent partial solution p p empty
achieving strong k consistency ii exists variable x vars value
x removed domain x achieving strong k consistency p p jt
empty achieving strong k consistency

proof first given consistent partial solution csp p k proof

tree inconsistency p corresponding well defined k proof tree tt
inconsistency vars vars induced csp p jt provided


ficonflict directed backjumping revisited

x fr g bg x frg
c x f r b g
c x f r g g
c x f r g
c x x x x


x

r

x
x

r
r

x

g

x

b

figure proof tree empty inconsistency csp p jt induced fx
g x bg constructed proof tree fx g g csp p shown
figure
contain assignments inconsistent assignments tt constructed
three steps see figure example step remove nodes
descendants contain assignments inconsistent assignments
step replace remaining node node vars vars
e remove variables occur thus occur p jt
leaf node definition consistent p possible corresponding
node tt inconsistent p jt case make leaf node
removing descendants leaf node definition inconsistent
p e exists constraint c p satisfy c must
case vars c vars since vars c vars contradicts fact
inconsistent c consistent therefore consistent c agree
assignments step hence corresponding constraint c p jt
selection projection c p easy verify corresponding node
inconsistent c therefore well defined leaf node step remove
subsumed nodes node subsumed node necessarily
child vars vars children subsumed node made children
parent
suppose p empty achieving strong k consistency k prooftree empty inconsistency p construct k proof tree empty
inconsistency p jt therefore p jt empty achieving strong k consistency suppose
exists variable x vars value x removed domain
x achieving strong k consistency p k proof tree fx x g
p construct k proof tree empty inconsistency p jt therefore p jt
empty achieving strong k consistency



fichen van beek

lemma given csp p assignment fx ag dom x induced csp
p jfx ag empty achieving strong k consistency value removed
domain x achieving strong k consistency p

proof suppose p jfx ag empty achieving strong k consistency thus
k proof tree empty inconsistency p jfx ag convert k proof tree k proof tree fx ag p node original k proof tree
replaced fx ag thus root tree becomes fx ag furthermore
leaf node original k proof tree e consistent p jfx ag
easy verify fx ag consistent p leaf node original
k proof tree e inconsistent p jfx ag constraint c p jfx ag

satisfy c let c selection projection constraint c p
thus fx ag satisfy constraint c p therefore inconsistent p
hence constructed k proof tree fx ag p thus would removed
domain x achieving strong k consistency p

mck extends current node csp induced current partial solution
empty achieving strong k consistency node thus called k consistent node

definition k consistent node node search tree k consistent node
csp induced empty enforcing strong k consistency node
k consistent called k inconsistent

lemma node k consistent ancestors k consistent
proof let one ancestors lemma p jt p jt jt thus
p jt induced subproblem p jt lemma p jt empty achieving
strong k consistency p jt empty achieving strong k consistency thus
k consistent

following theorem applies case finding solutions

theorem mck visits node parent k consistent node k consistent
mck visits node

proof first part true mck would branch node parent
found k inconsistent prove second part induction depth search tree
hypothesis trivial j suppose true j k consistent
node level j let current variable x lemma parent level
j k consistent thus mck visit lemma p jt p jt jfx x g
p jt jfx x g empty achieving strong k consistency lemma value x
removed domain x achieving strong k consistency p jt
consequence mck visit

necessary sucient condition mck visit node parent kconsistent value assigned current variable removed
domain enforcing strong k consistency parent


ficonflict directed backjumping revisited

theorem given csp variable ordering mck visits nodes mck

visits

proof follows theorem lemma
relationship bjk mck

kondrak van beek shown binary csps bj bj visits
nodes fc mc visits fc cbj mc cbj cbj incomparable
extend partial ordering backtracking include relationship
mck bjk mck cbj k n case general csps
e restricted binary csps
begin characterizing important property cbj

lemma cbj performs one level backjump deeper variable xi shallower
variable xh node th level xh one inconsistent

proof let si con ict set xi used backjumping xh deepest variable xi experience domain wipe enforcing oneconsistency induced csp p jth si node ti level xi leaf node
e ti inconsistent p suppose ti satisfy constraint c xi vars c
vars c si fxi g selection c p jth si constrains one variable
fxig prohibit value ti xi xi thus xi experience domain wipe
enforcing one consistency p jth si note p jth induced subproblem p jth si
lemma p jth empty enforcing one consistency thus th level xh
one inconsistent
lemma cbj performs k level backjump deeper variable xi shallower
variable xh current node th level xh k inconsistent
proof let si current con ict set xi xh deepest variable
k level backjump xi xh p jth si empty enforcing strong

k consistency thus th k inconsistent proof induction k k true
lemma suppose hypothesis true case k true
case k e k level backjump xi xh induced csp p jth si
empty enforcing strong k consistency least one value left
domain xi enforcing strong k consistency p jth si know node ti
level xi instantiating xi incompatible th e leaf node
l level backjumped deeper variable xj l k see figure
however ti cannot leaf node otherwise would removed domain xi
enforcing strong k consistency let sj con ict set xj hypothesis
induced csp p jti sj empty achieving strong l consistency value
removed resulting csp lemma induced csp p jth si fxi ag
empty achieving strong k consistency ti sj th si fxi ag
induced csp p jti sj empty achieving strong k consistency leads
contradiction thus p jth si empty achieving strong k consistency th
level xh k inconsistent


fichen van beek

th

xh
k level backjumping



ti

con ict set si xi

l level backjumping l k



con ict set sj xj

figure scenario cbj backtrack tree used proof lemma

theorem given csp variable ordering bjk visits nodes mck
visits

proof proof induction level search tree mck visits node
level j search tree bjk visits node j trivial suppose true
case j node visited mck level j know
mck bjk visit parent level j chance may skipped bjk
bjk backjumps deeper variable xi level shallower variable xh
level h h j thus node level h k inconsistent lemma
since node level h ancestor know parent k consistent
lemma node level h k consistent contradiction therefore bjk
visits level j
mck combined backjumping namely mck cbj provided con ict sets
computed correctly achieving strong k consistency induced csps

theorem given csp variable ordering mck visits nodes mck cbj

visits

proof mck cbj behaves exactly mck forward phase

backtracking search easy verify mck cbj visits node parent
k consistent value assigned current variable removed
domain achieving strong k consistency parent therefore mck cbj never
visits nodes mck
figure present hierarchy terms size backtrack tree bjk
mck mck cbj path b figure
know never visits nodes b example mck never visits
nodes bjj j k otherwise instances may
exponentially better b vice versa


ficonflict directed backjumping revisited

bjn
cbj






bjk

bjk

mcn

mcn cbj









mck

cbj

mck

mck

mck cbj










bj



mc



mc cbj

bj

fc

fc cbj



figure hierarchy bjk mck mck cbj terms size backtrack
tree
following example shows fixed integer k n exists csp instance
cbj visits exponentially fewer nodes maintains strong
k consistency backtracking search

example given fixed integer k construct binary csp n k variables
x xn k yk xn k xn dom xi f ng n
dom yj f kg j k constraints xi
xj j
yi
yj j consists two separate pigeon hole subproblems one

variables x xn variables yk insoluble
see pigeon hole highly locally consistent first subproblem strongly nconsistent second strongly k consistent static variable ordering
independently bacchus grove present similar example given fixed k cbj
may exponentially better called mikc essentially maintains k consistency
backtracking search



fichen van beek

backtracking maintaining strong k consistency would encounter dead end
xn k instantiated would subproblem xn k xn
strongly k consistent thus backtrack reaches second
pigeon hole subproblem explore nk nodes level n k search tree
thus take exponential number steps insoluble cbj
encounter dead end level xn k continues second pigeon hole
eventually second pigeon hole insoluble backjump
root search tree total number nodes explored bounded constant
k k fixed k therefore cbj exponentially better
maintaining strong k consistency
example shows although mck visits fewer nodes bjk theorem
bjk exponentially better mck however bjk better mck
k level backjump chronological backtrack see
true suppose particular instance k level backjumps
chronological backtracks e backjump immediately preceding variable
variable ordering single variable becomes uninstantiated removed
current partial solution case freedom backjump one additional level
rather chronologically backtrack make difference bjk effectively
bjk thus cannot better mck thus bjk better mck
k level non chronological backjump note however since
number backjumps level k less equal number backjumps level
k k increases gets unlikely thus level local consistency
maintained backtracking search increased less backjumping
improvement
consider example level backtrack tree mck instantiation
past variables removes one distinct value domain current
variable recall mck never instantiates variable reaches dead end
xn k maintain con ict sets variables con ict set current
variable would include past variables thus dead end encountered
backjump computed con ict sets would necessarily
chronologically backtrack thus example shows mck cbj mck visit
exactly nodes consequently bjk exponentially better mck cbj furthermore mck cbj reach second pigeon hole without
encountering dead end finally retreat second pigeon hole
root search tree backjumps thus mck cbj may exponentially better
mck cbj particular shows surprising mac cbj visit
exponentially nodes fc cbj
finally following example shows fixed integer k n exists csp
instance maintains strong k consistency backtracking
search visits exponentially fewer nodes cbj

example consider csp defined example searched static variable
ordering yk x xn yk



ficonflict directed backjumping revisited

empirical evaluation adding cbj gac

section report experiments examined effect adding cbj
backtracking maintains generalized arc consistency gac
refer gac cbj previous work shown importance
maintain arc consistency e g sabin freuder bessiere regin
adding cbj backtracking maintains generalized arc consistency
speed several orders magnitude hard structured
previous empirical studies adding cbj backtracking maintains
level local consistency led mixed conclusions adding cbj forward checking
truncated form arc consistency shown give improvements
significant ones prosser b observes static variable ordering fc cbj
three times faster fc zebra smith grant observe
dynamic variable ordering adding cbj fc led significant savings
hard random occur easy region bacchus van run
observe dynamic variable ordering adding cbj fc led
improvement zebra n queens random binary
bayardo schrag adding cbj well known davis putnam
sat version forward checking significant improvement hard
random real world sat
adding cbj maintains full arc consistency received less attention literature one study aware bessiere regin
observe adding cbj mac binary version gac actually slows
random binary due overhead maintaining con ict sets
conjecture mac good variable ordering heuristic used cbj
becomes useless
empirical lead us differ bessiere regin conclusion
usefulness adding cbj maintains full arc consistency implementation able significantly reduce overhead maintaining con ict sets
use additional data structures adding cbj
lead many savings nodes visited implementation cbj degrade performance significant factor demonstrate improvement bessiere
regin experiments random binary experiments two structured domains gac cbj sometimes improve gac several
orders magnitude hard instances
experiments ran gac gac cbj instance
recorded cpu times comparing cpu times appropriate underlying code
gac gac cbj identical gac cbj containing additional code
maintain con ict sets determine far jump back two dynamic variable
orderings used popular dom deg heuristic chooses next variable
minimal domain size breaks ties choosing variable maximum degree
number constraints constrain variable dom deg heuristic
proposed bessiere regin chooses next variable minimal
see online appendix source code description key data structures implementations gac gac cbj



fichen van beek

value domain size divided degree experiments run mhz
pentium ii megabytes memory

random

run time performance gac gac cbj compared sets randomly
generated binary csps set random defined tuple n r
n number variables uniform domain size r uniform arity
constraints number randomly generated constraints uniform
tightness number tuples constraint case constraint tightness
chosen approximately half instances population insoluble
e instances phase transition region
table effect domain size average time seconds solve random instances
set contained random instances gac cbj
gac used dom deg variable ordering

gac cbj gac
























ratio









bessiere regin examine effect domain size average time
solve random instances see figure right bessiere regin
implementation cbj adding cbj steadily worsens performance domain
size increases mac cbj times slower mac alone
implementation difference performance gac cbj gac negligible
see table
remaining sets random bessiere regin used experiments compare performance mac cbj mac simple provide
meaningful comparison solved less seconds mhz
pentium ii computer thus chose harder sets random binary
instance ran gac gac cbj recorded cpu times report
average ratio cpu times gac gac cbj set contained random
instances first set average ratio dom deg
variable ordering average ratio dom deg variable ordering
second set average ratios dom deg


ficonflict directed backjumping revisited

dom deg variable orderings words average gac little
faster gac cbj



one required sequence actions initial state goal
state formulated csp formulation used experiments
state modeled collection variables constraints enforce assignments
variables represent consistent state valid transition states see kautz
selman van beek chen details formulation
csp
table time seconds solve instances grid absence
entry indicates solved within seconds hours
cpu time
dom deg
gac gac cbj












dom deg
gac gac cbj




















experiments used instances used first ai systems
competition june instances come five different domains gripper
mystery mprime logistics grid experiments report gac gaccbj ac mackworth found give best performance
gripper mystery mprime domains instances could solved
seconds gac gac cbj easy increased
overhead cbj rarely led savings overall gac faster gac cbj
table shows comparison gac gac cbj solving instances
grid gac cbj showed improvement grid example
solved half hour gac failed solution hours
table shows comparison gac gac cbj solving instances
logistics one third instances gac cbj improved gac
example instances gac cbj ran several orders magnitude faster
gac instance gac exhausted hours time limit gac cbj found
solution within minutes gac cbj gac performed similarly easier instances
sometimes gac cbj slower gac



fichen van beek

table time seconds solve instances logistics absence
entry indicates solved within seconds
hours cpu time
dom deg
gac
gac cbj































































dom deg
gac
gac cbj













































































































ficonflict directed backjumping revisited

crossword puzzle

crossword puzzle generation one required fill grid words
dictionary formulated csp formulation used experiments
unknown words represented variable takes values dictionary
binary constraints enforce intersecting words agree intersecting letter
word dictionary appears solution figure shows
example crossword puzzle grid csp model grid variables binary
intersection constraints equals constraints










































figure crossword puzzle
experiments used grids two dictionaries total instances
ranged easy hard grids used instances
following sizes dictionaries used
uk dictionary collects words largest domain
word variable contains values linux dictionary collects
words largest domain word variable values
experiments report gac gac cbj ac bessiere regin
found give best performance see sillito discussion
integrating ac backtracking search
figure shows approximate cumulative frequency curves empirical
plotting ratio time taken solve instance gac time
taken solve instance gac cbj thus example read curve
representing dom deg variable ordering approximately tests adding
cbj little effect remaining tests led orders magnitude
improvements read curves percentiles data
sets value median th percentile value th test
crossover point gac cbj starts perform well better gac occurs
around th percentile tables examine data closely showing


fichen van beek



ratio gac gac cbj

dom degree
dom degree

















test











figure effect execution time gac adding con ict directed backjumping gaccbj curve represents tests instances crossword puzzle
tests ordered ratio time taken solve instance
gac time taken solve instance gac cbj
actual times solve instances gac performed best instances
gac cbj performed best
table gac versus gac cbj instances crossword puzzle ten
best improvements time seconds gac gac cbj solve instance
presented
dom deg
rank gac gac cbj






























dom deg
gac gac cbj





















ficonflict directed backjumping revisited

table gac versus gac cbj instances crossword puzzle ten
best improvements time seconds gac cbj gac solve instance
presented absence entry indicates solved
within seconds hours cpu time
dom deg
dom deg
rank gac gac cbj gac gac cbj

















































summary smaller easier crossword puzzle instances gac slightly
faster gac cbj many puzzles noticeable difference
larger harder puzzles gac cbj orders magnitude faster gac

conclusion

presented three main first showed choice dynamic
variable ordering heuristic weaken effects backjumping technique second
showed level local consistency maintained backtracking
search increased less backjumping improvement together
partially explain backtracking look ahead phase
cannot benefit backjumping look back scheme extend partial
ordering backtracking presented kondrak van beek include
backtracking cbj hybrids maintain levels local consistency
beyond forward checking third finally showed adding cbj backtracking
maintains generalized arc consistency still speed
several orders magnitude hard structured throughout
restrict binary csps

acknowledgements
authors wish thank referees careful reading previous version
helpful comments financial support canadian government
nserc program gratefully acknowledged


fichen van beek

references

bacchus f grove looking forward constraint satisfaction
unpublished manuscript
bacchus f van run p dynamic variable ordering csps proceedings
first international conference principles practice constraint programming
pp cassis france available springer lecture notes computer science

bayardo jr r j schrag r csp look back techniques solve exceptionally hard sat instances proceedings second international conference
principles practice constraint programming pp cambridge mass
available springer lecture notes computer science
bayardo jr r j schrag r c csp look back techniques solve realworld sat instances proceedings fourteenth national conference artificial intelligence pp providence ri
bessiere c regin j c mac combined heuristics two reasons forsake
fc cbj hard proceedings second international conference principles practice constraint programming pp cambridge
mass
bessiere c regin j c arc consistency general constraint networks preliminary proceedings sixteenth international joint conference
artificial intelligence pp nagoya japan
bruynooghe solving combinatorial search intelligent backtracking
information processing letters
chen x theoretical comparison selected csp solving modeling techniques ph thesis university alberta
dechter r enhancement schemes constraint processing backjumping learning
cutset decomposition artificial intelligence
dechter r constraint networks shapiro c ed encyclopedia artificial
intelligence nd edition pp john wiley sons
freuder e c synthesizing constraint expressions comm acm
frost dechter r dead end driven learning proceedings twelfth
national conference artificial intelligence pp seattle wash
gaschnig j experimental case studies backtrack vs waltz type vs satisficing assignment proceedings second canadian
conference artificial intelligence pp toronto ont
haralick r elliott g l increasing tree search eciency constraint
satisfaction artificial intelligence
kautz h selman b satisfiability proceedings th
european conference artificial intelligence pp vienna


ficonflict directed backjumping revisited

kondrak g van beek p theoretical evaluation selected backtracking
artificial intelligence
mackworth k consistency networks relations artificial intelligence

mackworth k b reading sketch maps proceedings fifth international joint conference artificial intelligence pp cambridge mass
mcgregor j j relational consistency application finding
subgraph graph isomorphisms inform sci
montanari u networks constraints fundamental properties applications
picture processing inform sci
nadel b constraint satisfaction computational intelligence

prosser p domain filtering degrade intelligent backtracking search proceedings thirteenth international joint conference artificial intelligence
pp chambery france
prosser p b hybrid constraint satisfaction computational intelligence
prosser p mac cbj maintaining arc consistency con ict directed backjumping report university strathclyde
sabin freuder e c contradicting conventional wisdom constraint satisfaction proceedings th european conference artificial intelligence
pp amsterdam
schiex verfaillie g nogood recording static dynamic constraint
satisfaction international journal artificial intelligence tools
sillito j improving estimating cost backtracking csps
msc thesis university alberta
smith b grant sparse constraint graphs exceptionally hard proceedings fourteenth international joint conference artificial
intelligence pp montreal
van beek p chen x cplan constraint programming
proceedings sixteenth national conference artificial intelligence pp
orlando florida




